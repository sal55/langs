mafile 77
  1 cc.m               17095     3341   0
  2 help.txt            1308    20459   1
  3 info.txt            2162    21790   1
  4 msyslib.m          35263    23976   0
  5 mclib.m             3502    59261   0
  6 mlibnew.m          26375    62787   0
  7 mwindows.m         13091    89187   0
  8 cc_decls.m          9483   102303   0
  9 cc_tables.m        25880   111812   0
 10 cc_support.m        6296   137720   0
 11 cc_lex.m           72967   144040   0
 12 cc_headers.m        4671   217035   0
 13 bcclib.asm          2771   221732   1
 14 assert.h              67   224527   1
 15 ctype.h              372   224617   1
 16 errno.h             1736   225012   1
 17 fenv.h               338   226770   1
 18 float.h             1511   227131   1
 19 inttypes.h          2016   228668   1
 20 stdint.h            1847   230708   1
 21 limits.h             660   232579   1
 22 locale.h             751   233263   1
 23 _ansi.h               22   234037   1
 24 math.h              3114   234081   1
 25 setjmp.h             364   237219   1
 26 signal.h             455   237607   1
 27 stdarg.h             340   238086   1
 28 stdbool.h             91   238451   1
 29 stddef.h             368   238566   1
 30 stdio.h             2924   238957   1
 31 stdlib.h            1519   241905   1
 32 _syslist.h            25   243450   1
 33 string.h            1513   243499   1
 34 time.h               903   245034   1
 35 utime.h               48   245960   1
 36 unistd.h             232   246032   1
 37 safelib.h             24   246289   1
 38 wchar.h              540   246336   1
 39 wctype.h              23   246900   1
 40 types.h              175   246946   1
 41 stat.h              2083   247143   1
 42 timeb.h              284   249249   1
 43 utime.h              128   249556   1
 44 memory.h              21   249708   1
 45 windows.h         628270   249754   1
 46 fcntl.h             1106   878047   1
 47 io.h                1216   879173   1
 48 direct.h             735   880413   1
 49 process.h            740   881173   1
 50 malloc.h             123   881937   1
 51 bcc.h                274   882081   1
 52 conio.h              353   882378   1
 53 winsock2.h          4255   882757   1
 54 _mingw.h            4027   887036   1
 55 windowsx.h           241   891089   1
 56 cc_lib.m           37580   891354   0
 57 cc_parse.m         87010   928960   0
 58 cc_genmcl.m        12785  1015997   0
 59 cc_libmcl.m        34436  1028809   0
 60 cc_blockmcl.m      61965  1063274   0
 61 cc_genasm.m        28525  1125266   0
 62 cc_export.m         5991  1153818   0
 63 cc_assembler.m      6307  1159839   0
 64 aa_tables.m        12416  1166173   0
 65 aa_decls.m          4820  1178615   0
 66 aa_lex.m           12657  1183459   0
 67 aa_common.m          262  1196143   0
 68 aa_objdecls.m       4301  1196434   0
 69 aa.m               10757  1200755   0
 70 help.txt             878  1211536   1
 71 aa_parse.m          8894  1212440   0
 72 aa_writeobj.m       7015  1221363   0
 73 aa_writeexe.m      25227  1228407   0
 74 aa_writess.m        5045  1253662   0
 75 aa_disasm.m        26792  1258734   0
 76 aa_genss.m         40749  1285552   0
 77 aa_lib.m           16734  1326325   0
=== cc.m 1/77 ===
!mapmodule cc_headers => cc_headersx

import msys
import mlib
import clib
import oslib

import cc_decls
import cc_support
import cc_lex
import cc_tables
import cc_lib
import cc_parse
import cc_headers
import cc_genmcl
import cc_libmcl
import cc_genasm
import cc_export

import cc_assembler
import CC_BLOCKMCL

tabledata() []ichar modenames =
	(preprocess_mode,	$),
	(compile_mode,		$),
	(link_mode,			$),
	(run_mode,			$),
end

int cc_mode				!one of the above, default is link_mode
ichar linkoption
ichar destfilename		!base file
ichar destfileext		!extension

byte fdebugcompiler
byte fshowpaths
byte fshowheaders
byte fwriteheaders
byte fgetlib
byte fshowinfo
byte fstdin
byte fstdout
byte fmheaders
byte fshowlog
byte fatfile
byte fshowtiming
byte fbcclib

ichar entrypointname


tabledata() []ichar optionnames=
	(e_sw,			"e"),
	(compile_sw,	"c"),
	(toassem_sw,	"s"),
	(obj_sw,		"obj"),
	(exe_sw,		"exe"),
	(run_sw,		"run"),

	(paths_sw,		"paths"),
	(headers_sw,	"headers"),
	(stdin_sw,		"stdin"),
	(stdout_sw,		"stdout"),

	(inclpath_sw,	"i"),
	(showincl_sw,	"includes"),

	(time_sw,		"time"),
	(v_sw,			"v"),
	(v2_sw,			"v2"),
	(quiet_sw,		"q"),
	(help_sw,		"h"),
	(help2_sw,		"help"),
	(info_sw,		"info"),
	(ext_sw,		"ext"),
	(writeheaders_sw,	"writeheaders"),
	(old_sw,		"old"),
	(getlib_sw,		"getlib"),
	(mheaders_sw,	"mheaders"),
	(automodules_sw,"auto"),
	(out_sw,		"out"),
	(at_sw,			"at"),
	(debug_sw,		"debug"),
	(bcclib_sw,		"bcclib"),
	(callback_sw,	"callback"),
	(entry_sw,		"entry"),
	(splicing_sw,	"splicing"),
	(source_sw,		"source"),
end

const logfile="bcc.log"

int totallines=0
int nstringobjects=0

[sysparams.len]ichar extraparams	!after ":"
[sysparams.len]ichar extravalues
int nextraparams=0

global int progstart,progend

proc start=
int pass
int nextmodule
ichar file
int i
ichar x

!CPL =STREC.BYTES

starttiming()

initdata()

getinputoptions()

if fdebugcompiler then
	debugcompile()
	stop
fi

if cc_mode>=link_mode then
	fastasm:=1
fi

initsearchdirs()
initlogfile()

nextmodule:=1
pass:=1

repeat
	compilemodules(nextmodule,ninputfiles,pass++)

	nextmodule:=addnewmodules()

until nextmodule=0

if cc_mode>=link_mode then
!CPL "LL1"
	do_genlink()
!CPL "LL2"
fi

!CPL =NLOOKUPS
!CPL =NCLASHES
!CPL =GETHASHTABLESIZE()
!CPL =HSTSIZE
!CPL =NALLPROCS
!CPL =NMIXED


if cc_mode=run_mode then
	do_runprog()
fi

if fshowtiming then showtiming() fi
if fmheaders then writemheader(inputfiles[1]) fi

if fatfile then
	writeatfile()
fi

stop 0
end

proc compilemodules(int a,b,pass)=
[256]char str
ichar ext

if destfileext=nil then
	if cc_mode=preprocess_mode then
		ext:="i"
	elsif not fautomodules then
		ext:="asm"
		if ninputfiles=1 and cc_mode>=link_mode then
			ext:=linkoption
		fi
	else
		ext:="asm"
	fi
else
	ext:=destfileext
fi

for m:=a to b do

	if fautomodules then
		fprint @&.str,"## Compiling # to # (Pass #)",
			(pass=1|"  "|"* "), m:"2",inputfiles[m]:"jl12",
			changeext(inputfiles[m],ext):"jl16", pass

		println &.str
	elsif not fquiet then
		if cc_mode=preprocess_mode then
			println "Preprocessing",inputfiles[m],"to",changeext(inputfiles[m],"i")
		elsif ninputfiles=1 then
			println "Compiling",inputfiles[m],"to",changeext(destfilename,ext)
		else
			println "Compiling",inputfiles[m],"to",changeext(inputfiles[m],"asm")
		fi
	fi

!CPL "LOAD"
	do_loadmodule(m)

	if cc_mode=preprocess_mode then
		do_preprocess(m)
		resetcompiler()
		next
	fi
!CPL "PARSE"

	do_parsemodule(m)
!CPL "GENMCL"

	if not fatfile then
		do_genmcl(m)
!CPL "GENASM"
		do_genasm(m)
	fi
!CPL "DONE"

	if not fmheaders then
		resetcompiler()
	fi
od
end

proc debugcompile=
int pass
int nextmodule
ichar file

!PRINTLN "DEBUG COMPILE"

initsearchdirs()

logdest:=2
initlogfile()

do_loadmodule(1)

do_parsemodule(1)
	showast(1)

do_genmcl(1)
	showmcl("MCL",1)

do_genasm(1)
	showasm(1)

showsttree("ST",1)
showstflat("STFLAT")

!printmodelist(logdev)

!do_genlink()

closelogfile()
end

proc do_loadmodule(int n)=
if fverbose then
	CPL "Loading:",inputfiles[n]
fi

loadmainmodule(inputfiles[n])
end

proc do_preprocess(int n)=
	lex_preprocess_only(inputfiles[n],1, n, fstdout)
end

proc do_parsemodule(int n)=
	if fverbose then
		CPL "Parsing:"
	fi
	parsemodule(n)
end

proc do_genmcl(int n)=
	codegen_mcl(n)
end

proc do_genasm(int n)=
	ichar outfileasm

	outfileasm:=pcm_copyheapstring(changeext(inputfiles[n],"asm"))

	codegen_writeasm(n,outfileasm)
end

proc do_runprog=
	[300]char str

	strcpy(&.str,destfilename)
	for i to nextraparams do
		strcat(&.str," ")
		strcat(&.str,extraparams[i])
		if extravalues[i] then
			strcat(&.str,":")
			strcat(&.str,extravalues[i])
		fi
	od

	os_execwait(&.str)
end

function loadmainmodule(ichar filespec)int=
!Used for main module. Will always be first module loaded, module list
!will be empty.
!Load file as string
!extract modulename
!call compilemodile(modulename, filename, source)
	[100]char modulename
	[300]char path
	int status
	modulerec m
	int i,flag,fileno

!set up special module to represent the whole program
	pcm_clearmem(&moduletable[0],modulerec.bytes)
	sourcefilenames[0]:="<dummy file>"
	sourcefilepaths[0]:="<dummy path>"
	sourcefiletext[0]:="<sourcefile0>"
	sourcefilesizes[0]:=strlen(sourcefiletext[0])

	moduletable[0].name:="PROGRAM"
	moduletable[0].fileno:=0

	stprogram:=createdupldef(nil,addnamestr("$prog"),programid)
	moduletable[0].stmodule:=stprogram

	if not checkfile(filespec) and not fstdin then					!don't use searchdirs
		loaderror("Can't load main module: %s",filespec)
	fi

if fstdin then
	fileno:=loadfromstdin(filespec)
else
	fileno:=loadsourcefile(filespec,filespec)
fi
	strcpy(&.modulename,extractbasefile(filespec))

	strcpy(&.path,extractpath(filespec))
	if path[1] then
		++nsearchdirs
		for i:=nsearchdirs downto 2 do
			searchdirs[i]:=searchdirs[i-1]
		od
		searchdirs[1]:=ref char(pcm_copyheapstring(&.path))
	fi

	addmodule(&.modulename,fileno,moduleid)

return 1
end

function addmodule(ichar modulename,int fileno,id)int=
!Add new module with given name
!Source for module is already loaded in <fileno>
!return module no just added

!return new module number, or 0
!The module entry is NOT linked to the module list until imports have been loaded.

modulerec m
int i,status,k,flag,j
ref modulerec pmodule

pcm_clearmem(&m,m.bytes)

m.name:=pcm_copyheapstring(modulename)
m.fileno:=fileno

stmodule:=createnewmoduledef(stprogram,addnamestr(m.name))
m.stmodule:=stmodule

if nmodules>=maxmodule then
	loaderror("Too many modules %s",modulename)
fi

pmodule:=&moduletable[++nmodules]
pmodule^:=m
m.stmodule^.attribs.ax_moduleno:=nmodules

if nmodules>=maxmodule then
	loaderror("Too many modules %s",modulename)
fi

return nmodules
end

proc initlogfile=			!INITLOGFILE

case logdest
when 2 then
	remove(logfile)
	logdev:=cast(fopen(logfile,"w"))
when 0,1 then
	logdev:=ref void(os_getstdout())
esac
end

proc closelogfile=			!CLOSELOGFILE
[100]char str
int pos

if logdest=2 then
	fclose(cast(logdev))
	print @&.str,"\\m\\med.bat",logfile

	if checkfile("cc.m") then
		os_execwait(&.str,1,nil)
	else
		println "Diagnostic outputs written to",logfile
	fi

fi
end

proc initdata=

pcm_init()
lexsetup()
inittypetables()
initcclib()

checkbcclib()

end

proc initsearchdirs=
[300]char str1,str2
int i

searchdirs[++nsearchdirs]:=""
if dointheaders=0 then
	searchdirs[++nsearchdirs]:="/cx/headers/"
!	searchdirs[++nsearchdirs]:="/cx2/headers/"
fi

for i to nincludepaths when includepaths[i]^ do
	searchdirs[++nsearchdirs]:=includepaths[i]
od
end

proc showsearchdirs=
int i

println "Include search paths:"
if dointheaders then
	println "0: Internal standard headers (disable with -ext)"
fi

for i to nsearchdirs do
	if searchdirs[i]^ then
		println i,,":",searchdirs[i]
	else
		println i,,": ."
	fi
od
println
end

proc showast(int n)=		!SHOWAST
if logdest then
	if logdest=2 then
		println @logdev			!make sure pos is not 0 (will stop displaying if first in file)
	fi

	printcode(logdev,"PROC AST",n)
	println @logdev
fi
end

proc showstflat(ichar caption)=		!SHOWSTFLAT
if logdest then
	println @logdev,"PROC",caption
	printstflat(logdev)
	println @logdev
fi
end

proc showsttree(ichar caption,int n)=		!SHOWSTTREE
if logdest then
	println @logdev,"PROC",caption
	printst(logdev,moduletable[n].stmodule)
	println @logdev
fi
end

proc showmcl(ichar caption,int n)=			!SHOWPCL
ref strbuffer mclstr

if logdest then
	mclstr:=writemclcode(caption,n)
	gs_println(mclstr,logdev)
fi
end

proc showasm(int n)=
ichar asmstr,caption

caption:="PROC ASSEMBLY LISTING"

asmstr:=moduletable[n].asmstr
if asmstr=nil then
	return
fi

if logdest then
	println @logdev,caption,n
	println @logdev,asmstr
fi
end

proc showfiles=
int i
println "Sourcefiles:"

for i:=1 to nsourcefiles do
	cpl i,":",sourcefilepaths[i],sourcefilenames[i],"Size:",sourcefilesizes[i]
od
println
end

proc starttiming=
int t
progstart:=os_clock()
end

proc showtiming=
cpl os_clock()-progstart
!showlps("Program",os_clock()-progstart)
end

global proc showlps(ichar caption,int t)= !non-global gives odd error with lccwin)
![256]char str
!int lps,txi
!real tx,lpsx
!
!txi:=t
!if t>1 then
!	lpsx:=(NALLLINES/real(t))
!else
!	lps:=lpsx:=0
!fi
!
!println nalllines,"Lines"
!
!!sprintf(&.str,"%18s: %4d ms  %8dK Lines per second\n",caption,int32(txi),int32(lpsx))
!
!fprintln "#: # ms  #dK Lines per second",caption:"18",txi:"4", int(lpsx):"8"
!
!print &.str
end

proc getinputoptions=
const slash='-'
int i,j,k
int paramno,pmtype,sw,ncolons
ichar name,value,ext

paramno:=2
ncolons:=0

do

pmtype:=nextcmdparam(paramno,name,value,".c")
case pmtype
when pm_option then
	convlcstring(name)
	for sw to optionnames.len do
		if eqstring(name,optionnames[sw]) then
			do_option(sw,value)
			exit
		fi
	else
		println "Unknown option:",name
		stop 1
	od
when pm_sourcefile then
	if ninputfiles>=maxmodule then
		loaderror("Too many input files")
	fi
	inputfiles[++ninputfiles]:=pcm_copyheapstring(name)
when pm_libfile then
	if nlibfiles>=maxlibfile then
		loaderror("Too many lib files")
	fi
	libfiles[++nlibfiles]:=pcm_copyheapstring(name)
when pm_colon then
	if ++ncolons>1 then
		name:=":"
		value:=nil
!		recase pm_extra
		goto doextra
	fi
when pm_extra then
doextra::
	extraparams[++nextraparams]:=pcm_copyheapstring(name)
	extravalues[nextraparams]:=pcm_copyheapstring(value)
when 0 then
	exit
esac
od

if cc_mode=0 then cc_mode:=link_mode fi
if linkoption=nil then linkoption:="exe" fi

if ninputfiles=0 and not fwriteheaders and not fgetlib then
	showcaption()
	println "Usage:"
	println "	",,sysparams[1],"prog[.c]                 # Compile prog.c to prog.exe"
	println "	",,sysparams[1],"-help                    # Show options"
	println "	",,sysparams[1],"-info                    # Further info"
	stop 22
fi

if fwriteheaders then
	writeheaders()
	stop 20
fi

ext:=linkoption
case cc_mode
when preprocess_mode then ext:="i"
when compile_mode then ext:="asm"
else ext:=linkoption
esac

if destfilename=nil then
	destfilename:=pcm_copyheapstring(changeext(inputfiles[1],ext))
elsif eqstring(destfileext,"") then
	destfileext:=ext
fi

if fmheaders and ninputfiles>1 then
	loaderror("-mheaders works on one file only")
fi

end

proc do_option(int sw, ichar value)=
[300]char str
int length

case sw

when obj_sw then
	linkoption:="obj"
	cc_mode:=link_mode

when exe_sw then
	linkoption:="exe"
	cc_mode:=link_mode

when e_sw then
	cc_mode:=preprocess_mode

!when compile_sw then
!	cc_mode:=compile_mode

when compile_sw then
	linkoption:="obj"
	cc_mode:=link_mode

!	cc_mode:=compile_mode

when toassem_sw then
	cc_mode:=compile_mode

when run_sw then
	cc_mode:=run_mode

when paths_sw then
	fshowpaths:=1

when headers_sw then
	fshowheaders:=1

when inclpath_sw then
	if nincludepaths>maxincludepaths then
		loaderror("Too many include paths","")
	fi
	length:=strlen(value)
	case (value+length-1)^
	when '\\', '/' then
	else
		strcpy(&.str,value)
		strcat(&.str,"/")
		value:=&.str
!		loaderror("Path should end with / or \\: %s",value)
	esac

	includepaths[++nincludepaths]:=pcm_copyheapstring(value)

when v_sw then
	fverbose:=1
when v2_sw then
	fverbose:=1

when quiet_sw then
	fquiet:=1

when help_sw,help2_sw then
	showhelp()

when info_sw then
	showextrainfo()

when ext_sw then
	dointheaders:=0

when writeheaders_sw then
	fwriteheaders:=1

when getlib_sw then
	fgetlib:=1

when old_sw then
	fmodern:=0

when stdin_sw then
	fstdin:=1

when stdout_sw then
	fstdout:=1

when showincl_sw then
	fshowincludes:=1

when mheaders_sw then
	fmheaders:=1

when automodules_sw then
	fautomodules:=1

when out_sw then
!	destfilename:=pcm_copyheapstring(extractbasefile(value))
	destfilename:=pcm_copyheapstring(value)
	destfileext:=pcm_copyheapstring(extractext(value))

when at_sw then
	fatfile:=1

when time_sw then
	fshowtiming:=1

when debug_sw then
	fdebugcompiler:=1

when bcclib_sw then
	fbcclib:=1

when callback_sw then
	fcallback:=1

when entry_sw then
	entrypointname:=pcm_copyheapstring(value)

when splicing_sw then
	flinesplicing:=1

!when source_sw then
!	println strinclude "cc.ma"
!	stop

esac
end

proc showincludepaths=
int i
println "Include paths",nincludepaths
for i to nincludepaths do
	println i,includepaths[i]
od
println
end

proc showhelp=
showcaption()
println strinclude "help.txt"

stop 23
end

proc showextrainfo=
static ichar infotext=strinclude "info.txt"

println infotext

stop 24
end

proc showcaption=
println "BCC 'C' Compiler",$date,$time
end

proc do_genlink=
[maxmodule]ichar asmfiles
[maxmodule]ichar dllfiles
[maxmodule]ichar assemsources
ichar exefile,ext
int status, nfiles

nfiles:=ninputfiles

for i:=1 to ninputfiles do
	asmfiles[i]:=pcm_copyheapstring(changeext(inputfiles[i],"asm"))
	if fastasm then
		assemsources[i]:=moduletable[i].asmstr
	fi
od

if not eqstring(linkoption,"obj") or fbcclib then
	++nfiles
	asmfiles[nfiles]:="bcclib.asm"
	if fastasm then
		assemsources[nfiles]:=getbcclib()
	fi
fi
for i:=1 to nlibfiles do
	dllfiles[i]:=pcm_copyheapstring(libfiles[i])
od

if destfileext=nil then
	ext:=linkoption
else
	ext:=destfileext
fi
exefile:=pcm_copyheapstring(changeext(destfilename, ext))

if not assembler(exefile,&asmfiles,&dllfiles,
			nfiles,nlibfiles,eqstring(linkoption,"obj"),
			fautomodules or ninputfiles>1, (fastasm|&assemsources|nil),
			entrypointname) then
	println "Couldn't assemble or link"
	stop 1
fi
end

proc resetcompiler=
!println "Reset compiler"
freehashtable()

ntypes:=ntypesreset
nstrings:=nreals:=ndints:=0
stprogram:=stmodule:=nil
currblockno:=nextblockno:=blocklevel:=0
autotypeno:=0
nextafindex:=0
labelno:=0

!can't free fully at present as I don't know exact allocation size
!free only blocks allocated with malloc
for i:=1 to nsourcefiles do
	if sourcefilesizes[i]>maxblocksize then
		free(sourcefiletext[i])
	fi
od

nsourcefiles:=0

pcm_clearmem(&ttnamedef,ttnamedef.bytes)
pcm_clearmem(&ttbasetype,ttbasetype.bytes)
pcm_clearmem(&ttlength,ttlength.bytes)
pcm_clearmem(&ttconst,ttconst.bytes)
pcm_clearmem(&ttrestrict,ttrestrict.bytes)
pcm_clearmem(&ttvolatile,ttvolatile.bytes)
pcm_clearmem(&ttusertype,ttusertype.bytes)
pcm_clearmem(&tttarget,tttarget.bytes)
pcm_clearmem(&ttreftype,ttreftype.bytes)
pcm_clearmem(&ttconsttype,ttconsttype.bytes)
pcm_clearmem(&ttsize,ttsize.bytes)
pcm_clearmem(&ttbitwidth,ttbitwidth.bytes)
pcm_clearmem(&ttisref,ttisref.bytes)
pcm_clearmem(&ttparams,ttparams.bytes)
pcm_clearmem(&tttypedef,tttypedef.bytes)

inittypetables()
end

function addnewmodules:int=
!see if any more modules have been discovered
!if so, add to inputfiles, increment ninputfile, and return
! old ninputfiles+1 (next file to compile)
!otherwise return 0 
int nextinputfile,n,newfile

nextinputfile:=ninputfiles+1
n:=0

for i:=1 to nautomodules do
	newfile:=1
	for j:=1 to ninputfiles do
		if eqstring(inputfiles[j],automodulenames[i]) then
			newfile:=0
			exit
		fi
	od
	if newfile then
		inputfiles[++ninputfiles]:=automodulenames[i]
		++n
	fi
od

nautomodules:=0

if n=0 then return 0 fi
return nextinputfile
end

proc writeatfile=
filehandle f
ichar file

f:=fopen(file:=changeext(destfilename,""),"w")
return unless f

println "Writing @ file",file

for i to ninputfiles do
	println @f,"	",,inputfiles[i]
od
for i to nlibfiles do
	println @f,"	",,libfiles[i]
od

fclose(f)

end
=== help.txt 2/77 ===
C Subset Compiler for 64-bit Windows

Normal use:

    bcc prog            Compile file prog.c to prog.exe
    bcc prog.c          Same (extension is optional)
    bcc a b c d.dll     Compile a.c, b.c, c.c and link with d.dll to a.exe

Options:

    -e              Write preprocessed output to prog.i
    -s              Compile only, to .asm
    -c              Same as -obj
    -exe            (DEFAULT) compile and link to .exe file

    -i:path         Add include path
    -ext            Don't use internal standard headers
    -old            Allow features such as () parameter lists, for old programs
    -out:file       Name exe file

    -obj            Link to single .obj file rather .exe
    -run            Link to .exe then run that program
    -auto           Locate .c files matched to headers and add to modules
    @file           Read further files and options from a file

Other Options:

    -info           Show further information
    -time           Show compiler timing stats
    -writeheaders   Write out internal headers as .hdr (not .h) files
    -at             Create an @ file of filenames suitable for most compilers
    -stdin          Read C file from console
    -stdout         Write preprocessor output to console, rather than .i file
=== info.txt 3/77 ===
    The 'BCC' C Compiler. Included in the one executable file:

       * A compiler that produces .asm (external or internal)
       * A minimal set of standard headers
       * A very minimal windows.h
       * An assembler/linker generating one .exe or .obj file
       * The bcclib.asm file (written out as needed)

    BCC only targets x64 with Win64 call convention. It will compile
    single or multiple .c files to one .asm, .exe or .obj file:

      -e    Preprocess each module to .i file
      -s    Compile all modules to one .asm file (NOT multiple)
      -exe  (DEFAULT) Compile all modules to one .exe file
      -obj  Compile all modules to one .obj file (NOT multiple)
      -c    Same as -obj
      -run  Compile to .exe then run the new program. Provide
            params after " : " (spaces needed)

    When there is one output file, it will be named based on the first
    input file. Otherwise use -out option (see bcc -help).

    .obj files can be linked using gcc on Windows. This option is
    needed to be able to generate .dll files.

    Libraries msvcrt.dll, gdi32.dll, user32.dll and kernel32.dll are
    automatically included as search libraries for imported functions.

    For other libraries, add .dll files to bcc command line or @ list.
    (Note that when any .dll is specified, the default set of DLLs
    is no longer included. You may need to explicitly specify msvcrt.dll etc.)
    Other kinds of binary libraries (.a, .lib etc) are not supported.

    (Programs using setjmp and certain internal ops will need bcclib.asm.
    This file is automatically written by bcc if not present, and
    automatically linked.)

    Omissions, Restrictsions and Bugs (highlights only as there are dozens):

       * No VLAs, compound literals, designated initialisers
       * Restrictions on complexity of data initialisers
       * Callback functions are buggy if called from external code (not
         compiled with bcc). Fix by adding $callback attribute to such
         functions, or the portable #pragma $callback just before.
         Typically, functions passed to qsort().
=== msyslib.m 4/77 ===
import clib
import mlib

global record procinforec=
	word16		fnindex
	byte		rettype
	byte		nparams
	[12]byte	paramlist
end

!for print/read routines
!------------------------------------------
record fmtrec=	! (default)
	byte	minwidth	! n (0)   min field width (0 if not used or don't care)
	i8		precision	! .n (0)   number of decimals/significant figures/max width
	byte	base		! B,H or Xn (10)  2 to 16

	char	quotechar	! Qc (0)   0 or '"' or c
	char	padchar		! Pc, Z (' ')
	char	realfmt		! E,F,G ('f') 'e' or 'f' or 'g'

	char	plus		! (0)   0 or '+'
	char	sepchar		! Sc (0)   0 or ',' or c placed every 3 (base=10) or 4 digits
	char	lettercase	! A,a ('A') 'A' or 'a'
	char	justify		! JL, JR, JC ('R') 'L' or 'R' or 'C'?
	char	suffix		! Tc (0)   0 or 'B' or 'H' or c
	char	usigned		! W (0)   0 or 'W' force unsigned o/p for ints (eg. for hex display)
	char	charmode	! C,D (0)  0 or 'C' or 'D'	o/p int as int or single char or double/multi-char
	char	heapmode	! M (0)  'M' for str-functions, return ptr tp heap string
	char	param		! Use int value for <fmtparam>
	byte	spare
end

int fmtparam			!as set with :'V'

enum (std_io,file_io,str_io)

const comma = ','

global int needgap			= 0
int outdev			= std_io
filehandle outchan	= nil
ref char fmtstr 	= nil

const maxiostack=10
[maxiostack]filehandle	outchan_stack
[maxiostack]int			outdev_stack
[maxiostack]ref char	fmtstr_stack
[maxiostack]byte		needgap_stack

[maxiostack]ref char	ptr_stack		!this one doesn't need pushing, as each is pointed to from outchan
int niostack=0

[0:]char digits=A"0123456789ABCDEF"
const onesixty=360
fmtrec defaultfmt = (0,0, 10, 0,' ','f', 0,0,0,'R',0,0, 0,0,0,0)

!Read buffer vars
!const rd_buffersize = 16384	!total capacity of line buffer
const rd_buffersize = 524288	!total capacity of line buffer

global ref char rd_buffer		! point to start of read buffer
int rd_length			! length of this line (as read by readln)
ref char rd_pos			! current position it's up to (next read starts here)
ref char rd_lastpos		! set by sread() just before reading used for reread()
int termchar			! terminator char set by readxxx()
int itemerror			!	set by some read functions, eg for reals

!------------------------------------------

const maxparam=128
global int nsysparams
global int nenvstrings
global [maxparam]ichar sysparams
global [maxparam]ichar envstrings

const maxcallback=8
[0..maxcallback,8]word64 callbackstack
int ncallbacks=0

word64 mask63	= 0x7FFF'FFFF'FFFF'FFFF
real offset64	= 9223372036854775808.0		! 2**63 as r64
real offset32	= 9223372036854775808.0		! 2**63 as r32

global proc m$init=
int32 nargs
int nargs64
ref[]ichar args
ref[]ichar env
static [128]byte startupinfo			! 68 or 104 bytes
int res
ichar s

!PUTS("M$INIT")

res:=__getmainargs(&nargs,cast(&args),cast(&env),0,cast(&startupinfo))

nsysparams:=nargs

if nsysparams>maxparam then
	printf("Too many params\n")
	stop 50
fi

nargs64:=nargs			!bug when using 32-bit limit when compiled with mm
for i:=1 to nargs64 do
	sysparams[i]:=args[i]
od

int j:=1
nenvstrings:=0
while env[j] do
!	println "ENV:",J,ENV[J]
	envstrings[++nenvstrings]:=env[j]
	++j
OD



!PUTS("M$INIT")
m$print_startcon()		!allow most print stmts without startcon/end

end

global proc m$stop(int n)=
	`exit(n)
!	assem
!		mov d10,[n]
!		mov d0,`exit
!		call m$callff_4
!	end
end

global function m$lenstr_stringz(ref char s)int=
	strlen(s)
end

!global function m$getdotindex(word64 a,int i)int=
!!return (a iand (1dw<<i))>>i
!return (a iand (1<<i))>>i
!end
!
!global proc m$setdotindex(ref word64 a, int i,x)=
!ref word32 a32
!
!!see comments on setdotslice
!if i>=32 then
!	a^:=(a^ iand inot (1<<i)) ior (word64(x)<<i)
!
!else
!	a32:=cast(a)
!	a32^:=(a32^ iand inot (1<<i)) ior (word(x)<<i)
!fi
!end
!
!global function m$getdotslice(word64 a,int i,j)int=
!if i>=j then
!	return (a>>j)  iand  inot(0xFFFF'FFFF'FFFF'FFFF<<(i-j+1))
!else
!	return (a>>i)  iand  inot(0xFFFF'FFFF'FFFF'FFFF<<(j-i+1))
!fi
!end
!
!global proc m$setdotslice(ref word64 a, int i,j,word64 x)=
!!a^:=(a^ iand inot (1dw<<i)) ior (word64(x)<<i)
!int w
!word64 mask64
!word mask
!ref word32 a32
!
!if i>j then println "SETDOTSLICE?"; stop 52 fi
!
!!when j>=32, assume 64 bit dest, otherwise assume 32 bits to avoid writing
!!to bytes beyond the 32-bit value
!!THIS WILL BE A PROBLEM IF writing to 8/16 bit values too
!
!if j>=32 then
!	mask64:=inot((0xFFFF'FFFF'FFFF'FFFF<<(j-i+1)))<<i			!shifted field of w 1s
!	a^:=(a^ iand inot mask64) ior x<<i
!else
!	a32:=cast(a)
!	mask:=inot((0xFFFF'FFFF'FFFF'FFFF<<(j-i+1)))<<i			!shifted field of w 1s
!	a32^:=(a32^ iand inot mask) ior x<<i
!fi
!
!end

!function m$get_nprocs:int=
!	5
!!	assem
!!		mov D0,[$nprocs]
!!	end
!end
!
!function m$get_procname(int n)ichar=
!nil
!!	assem
!!		lea D0,[$procnames]
!!		mov D1,[n]
!!		mov D0,[D0+D1*8-8]
!!!		mov D0,[sss]
!!	end
!end
!
!function m$get_procaddr(int n)ref proc=
!nil
!!	assem
!!		lea D0,[$procaddrs]
!!		mov D1,[n]
!!		mov D0,[D0+D1*8-8]
!!	end
!end
!
!global function m$get_nexports:int=
!786
!!	assem
!!		mov D0,[$nexports]
!!	end
!end
!
!global function m$get_procexport(int n)ref void=
!nil
!!	assem
!!		lea D0,[$procexports]
!!		mov D1,[n]
!!		shl D1,1
!!		lea D0,[D0+D1*8-16]
!!	end
!end

proc pushio=
	if niostack>=maxiostack then
		printf("Too many io levels\n")
		stop 53
	fi
	++niostack
	outchan_stack[niostack]	:= outchan
	outdev_stack[niostack]	:= outdev
	fmtstr_stack[niostack]	:= fmtstr
	needgap_stack[niostack]	:= needgap
	needgap:=0
	fmtstr:=nil
	outchan:=nil
end

global proc m$print_startfile(ref void dev)=
	pushio()
	outchan:=cast(dev)
	if dev then
		outdev:=file_io
	else
		outdev:=std_io
	fi
end

global proc m$print_startstr(ref char s)=
	ref ref char p
	pushio()

	ptr_stack[niostack]:=s
	p:=&ptr_stack[niostack]

	outchan:=cast(p)
	outdev:=str_io
end

global proc m$print_startptr(ref ref char p)=
	pushio()

	outchan:=cast(p)
	outdev:=str_io
end

global proc m$print_startcon=
	pushio()
	outdev:=std_io
end

global proc m$print_setfmt(ref char format)=
	fmtstr:=format
end

global proc m$print_end=
	needgap:=0
	nextfmtchars(1)
	if niostack=0 then return fi
	outchan	:= outchan_stack[niostack]
	outdev	:= outdev_stack[niostack]
	fmtstr	:= fmtstr_stack[niostack]
	needgap	:= needgap_stack[niostack]
	--niostack
end

global proc m$print_ptr(u64 a,ichar fmtstyle=nil)=
	[20]char s

	if fmtstyle=nil then
		fmtstyle:="z8H"
	fi
	m$print_u64(a,fmtstyle)
end

global proc m$print_ptr_nf(u64 a)=
	m$print_ptr(a)
end

global proc m$print_i64(int64 a,ichar fmtstyle=nil)=
	[40]char s
	fmtrec fmt
	int n

	nextfmtchars()
	if fmtstyle=nil then
		if a>=0 then
			n:=u64tostr(a,&.s,10,0)
		else
			s[1]:='-'
			n:=u64tostr(-a,&s[2],10,0)+1
		fi

		printstr_n(&.s,n)

	else

		strtofmt(fmtstyle,-1,&fmt)
		if fmt.param='V' then
			fmtparam:=a
			needgap:=0
		else
			tostr_i64(a,&fmt)
		fi
	fi
	needgap:=1
end

global proc m$print_i64_nf(int64 a)=
	m$print_i64(a)
end

global proc m$print_u64(word64 a,ichar fmtstyle=nil)=
	[40]char s
	fmtrec fmt

	nextfmtchars()
	if fmtstyle=nil then
		sprintf(&.s,"%llu",a)
		printstr(&.s)
	else
		strtofmt(fmtstyle,-1,&fmt)
		tostr_u64(a,&fmt)
	fi
	needgap:=1
end

global proc m$print_i128(int128 a,ichar fmtstyle=nil)=
	[40]char s
	fmtrec fmt

	nextfmtchars()
	strtofmt(fmtstyle,-1,&fmt)
	if a>=0 then
		tostr_u128(a,&fmt,0)
	else
		tostr_u128(-a,&fmt,1)
	fi

	needgap:=1
end

global proc m$print_u128(word128 a,ichar fmtstyle=nil)=
	[40]char s
	fmtrec fmt

	nextfmtchars()
	strtofmt(fmtstyle,-1,&fmt)
	tostr_u128(a,&fmt,0)
	needgap:=1
end

global proc m$print_r64(real x,ichar fmtstyle=nil)=
	[360]char s
	fmtrec fmt

	nextfmtchars()
	if fmtstyle=nil then
		sprintf(&.s,"%f",x)
		printstr(&.s)
	else
		strtofmt(fmtstyle,-1,&fmt)
		tostr_r64(x,&fmt)
	fi

	needgap:=1
end

global proc m$print_r32(real32 x,ichar fmtstyle=nil)=
	m$print_r64(x,fmtstyle)
end

global proc m$print_c8(int64 a,ichar fmtstyle=nil)=
	[40]char s
	fmtrec fmt
	int n

	nextfmtchars()

	s[1]:=a
	s[2]:=0
	printstr(&.s)
	needgap:=1
end

global proc m$print_str(ichar s, fmtstyle=nil)=
	nextfmtchars()

	if s=nil then
		printstr("<null>")
		return
	fi


	fmtrec fmt
	if fmtstyle=nil then
		printstr(s)
	else
		strtofmt(fmtstyle,-1,&fmt)
		tostr_str(s,&fmt)
	fi
	needgap:=1
end

global proc m$print_str_nf(ichar s)=
	m$print_str(s)
end

global proc m$print_strsl(slice[]char s, ichar fmtstyle=nil)=
	nextfmtchars()
	fmtrec fmt
	if fmtstyle=nil then
		printstr_n(cast(s.sliceptr),s.len)
	else
		abortprogram("FORMATED PRINT SLICE NOT READY")
!		strtofmt(fmtstyle,-1,&fmt)
!		tostr_str(s,&fmt)
	fi
	needgap:=1
end

global proc m$print_newline=
	needgap:=0
	nextfmtchars(1)
	printstr("\w")
end

global proc m$print_nogap=
	needgap:=0
end

global proc m$print_space=
	needgap:=0
	printstr(" ")
end

global proc printstr(ichar s)=
	int n
	ref ref char p

	case outdev
	when std_io then
		printf("%s",s)
	when file_io then
		fprintf(outchan,"%s",s)
	when str_io then
		p:=cast(outchan)
		strcpy(p^,s)
		p^+:=strlen(s)
		p^^:=0
	esac
end

global proc printstr_n(ichar s,int n=-1)=
	ref ref char p

	case n
	when -1 then n:=strlen(s)
	when 0 then return
	esac

	case outdev
	when std_io then
		printf("%.*s",n,s)
	when file_io then
		fprintf(outchan,"%.*s",n,s)
	when str_io then
		p:=cast(outchan)
		memcpy(p^,s,n)
		p^+:=n
		p^^:=0
	esac
end

global proc printstrn_app(ichar s, int length, filehandle f=nil)=
if length then
!	emitc "printf(""%.*s"",(i32)length,s);"
	if f=nil then
		printf("%.*s",length,s)
	else
		fprintf(f,"%.*s",length,s)
	fi
fi
end

proc printchar(int ch)=
	ref ref char p
	case outdev
	when std_io then
		printf("%c",ch)
	when file_io then
		fprintf(outchan,"%c",ch)
	when str_io then
		p:=cast(outchan)
		p^^:=ch
		p^+:=1
		p^^:=0
	esac
end

global proc nextfmtchars(int lastx=0)=
	char c
	ref char pstart
	int n
	if not fmtstr then			!format not in use
		if needgap then
			printchar(' ')
		fi
		needgap:=0
		return
	fi

	pstart:=fmtstr
	n:=0

	do
		c:=fmtstr^
		switch c
		when '#' then
			if lastx then
				goto skip
			fi
			++fmtstr
			if n then
				printstr_n(pstart,n)
			fi
			return
		when 0 then
			if n then
				printstr_n(pstart,n)
			elsif not lastx then
				printstr_n("|",1)
			fi
			return
		when '~' then
			if n then
				printstr_n(pstart,n)
				n:=0
			fi
			++fmtstr
			c:=fmtstr^
			if c then
				++fmtstr
				printchar(c)
			fi
			pstart:=fmtstr
		else
	skip::
			++n
			++fmtstr
		endswitch
	od
end

global proc strtofmt(ref char s,int slen,ref fmtrec fmt) =		!PC_STRTOFMT
!convert format code string in s, to fmtrec at fmt^
!Format code is a string containing the following char codes (upper or lower when mostly)
!n	Width
!.n	Max width/precision
!A	Convert to upper when
!a	Convert to lower when
!B	Binary
!C	Show int as single n-bit (unicode) character
!D	Show int as multi-bit (unicode) character
!E,F,G	Specify format for double (corresponds to C format codes)
!F
!G
!H	Hex
!JC	Justify centre
!JL	Justify left
!JR	Justify right
!M	HEAPMODE???
!O	Octal
!Pc	Use padding char c
!Q	Add double quotes around string (and deal with embedded quotes)
!'	Add single quotes around string (and deal with embedded quotes)
!Sc	Use separator char c between every 3 or 4 digits
!Tc	Use terminator char c (typically B or H)
!U	Show ints as unsigned
!V	For ints, don't display: store value as parameter for subsequent '*'
!W	Unsigned
!Xn	Use base n (n is hex 0 to F)
!Z	Use "0" padding
!+	Always have + or - in front of integers
!~	Quote char is ~
!*	Same as n but uses parameter set with :'V' on previous int

	int c
	byte wset
	int n
	[0:100]char str

	fmt^:=defaultfmt

	if s=nil then return fi

	if slen=-1 then slen:=strlen(s) fi

	memcpy(&.str,s,slen)		!convert s/slen to zero-terminated string
	str[slen]:=0
	s:=&.str

	wset:=0
	while s^ do
		c:=s^
		++s
		switch c
		when 'B', 'b' then fmt^.base:=2
		when 'H', 'h' then fmt^.base:=16
		when 'O', 'o' then fmt^.base:=8
		when 'X', 'x' then
			c:=s^
			if c then
				switch c
				when '0'..'9' then c:=c-'0'
				when 'A'..'F' then c:=c-'A'+10
				when 'a'..'f' then c:=c-'a'+10
				else
					c:=10
				end
				fmt^.base:=c
				++s
			fi
		when 'Q', 'q' then fmt^.quotechar:='"'
		when '~' then fmt^.quotechar:='~'
		when 'J', 'j' then
			fmt^.justify:=toupper(s^)
			if s^ then
				++s
			fi
		when 'A' then fmt^.lettercase:='A'
		when 'a' then fmt^.lettercase:='a'
		when 'Z', 'z' then fmt^.padchar:='0'
		when 'S', 's' then
			fmt^.sepchar:=s^
			if s^ then
				++s
			fi
		when 'P', 'p' then
			fmt^.padchar:=s^
			if s^ then
				++s
			fi
		when 'T', 't' then
			fmt^.suffix:=s^
			if s^ then
				++s
			fi
		when 'W', 'w' then fmt^.usigned:='W'
		when 'E', 'e' then fmt^.realfmt:='e'
		when 'F', 'f' then fmt^.realfmt:='f'
		when 'G', 'g' then fmt^.realfmt:='g'
! when '0','1','2','3','4','5','6','7','8','9' then
		when '.' then
			wset:=1
		when comma,'_' then fmt^.sepchar:=c
		when '+' then fmt^.plus:='+'
		when 'D', 'd' then fmt^.charmode:='D'
		when 'C', 'c' then fmt^.charmode:='C'
		when 'M', 'm' then fmt^.heapmode:='M'
		when 'V','v' then fmt.param:='V'
		when '*' then
			n:=fmtparam
			goto gotwidth
		else
			if c>='0' and c<='9' then
				n:=c-'0'
				do
					c:=s^
					if s^=0 then
						exit
					fi
					if c>='0' and c<='9' then
						++s
						n:=n*10+c-'0'
					else
						exit
					fi
				od
gotwidth::
				if not wset then
					fmt^.minwidth:=n
					wset:=1
				else
					fmt^.precision:=n
				fi
			fi
		endswitch
	od
end

function domultichar (ref char p,int n,ref char dest,ref fmtrec fmt)int =
!there are n (4 or 8) chars at p.!
!There could be 0 to 4 or 8 printable chars converted to string at dest
	[0:20]char str
	ref char q
	int i,nchars

	q:=&.str

	nchars:=n

	to n do
		if p^=0 then exit fi
		q^:=p^
		++q
		++p
	od
	q^:=0

	return expandstr(&.str,dest,strlen(&.str),fmt)
end

function expandstr(ref char s,ref char t,int n,ref fmtrec fmt)int =		!EXPANDSTR
!s contains a partly stringified value.
!widen s if necessary, according to fmt, and copy result to t
!n is current length of s
!note) = for non-numeric strings, fmt^.base should be set to 0, to avoid moving
!a leading +/- when right-justifying with '0' padding.
!t MUST be big enough for the expanded string; caller must take care of this
!result will be zero-terminated, for use in this module

	int i,w,m

!check to see if result is acceptable as it is
	w:=fmt^.minwidth
	if w=0 or w<=n then		! allow str to be longer than minwidth
		strncpy(t,s,n)
		(t+n)^:=0
		return n
	fi

	if fmt^.justify='L' then	! left-justify
		strncpy(t,s,n)
		t+:=n
		for i:=1 to w-n do
			t^:=fmt^.padchar
			++t
		od
		t^:=0
	elsif fmt^.justify='R' then
		if fmt^.padchar='0' and fmt^.base and (s^='-' or s^='+') then ! need to move sign outside 
			t^:=s^
			++t
			to w-n do
				t^:=fmt^.padchar
				++t
			od
			strncpy(t,s+1,n-1)
			(t+n-1)^:=0
		else
			to w-n do
				t^:=fmt^.padchar
				++t
			od
			strncpy(t,s,n)
			(t+n)^:=0
		fi

	else				! centre-justify?

		m:=(w-n+1)/2
		to m do
			t^:=fmt^.padchar
			++t
		od
		strncpy(t,s,n)
		t+:=n
		to w-n-m do
			t^:=fmt^.padchar
			++t
		od
		t^:=0

	fi
	return w
end

!function mdivrem(word64 a,b)word64,word64=
!	word64 q,r
!	assem
!		xor rdx,rdx
!		mov rax,[a]
!		div u64 [b]
!		mov [q],rax	
!		mov [r],rdx	
!	end
!	return (q,r)
!end

function u64tostr(u64 aa,ref char s,word base,int sep)int =		!U64TOSTR
!convert 64-bit int a to string in s^
!base is number base, usually 10 but can be 2 or 16. Other bases allowed
!result when a=minint (will give "<minint>")
	[0:onesixty]char t
	u64 dd
	int i,j,k,g
	int cc
	int dummy
	ref char s0

	i:=0
	k:=0
	g:=(base=10|3|4)

	repeat
		dd:=aa rem base
		aa:=aa/base

		t[++i]:=digits[dd]

!BUG in separator logic, doesn't work when leading zeros used, eg. printing
!out a full length binary
!so perhaps move this out to expandstr
		++k
		if sep and aa<>0 and k=g then
			t[++i]:=sep
			k:=0
		fi
	until aa=0

	j:=i
	s0:=s
	while i do
		s^:=t[i--]
		++s
	od
	s^:=0

	return j
end

function u128tostr(u128 aa,ref char s,word base,int sep)int =
!convert 128-bit int a to string in s^
!base is number base, usually 10 but can be 2 to 16
	[0:160]char t
	u64 dd
	int i,j,k,g
	int dummy
	ref char s0

	i:=0
	k:=0
	g:=(base=10|3|4)

	repeat
		aa:=xdivrem128(aa,base,dd)
		t[++i]:=digits[dd]

!		t[++i]:=digits[aa rem base]
!		aa:=aa/base

!BUG in separator logic, doesn't work when leading zeros used, eg. printing
!out a full length binary
!so perhaps move this out to expandstr
		++k
		if sep and aa<>0 and k=g then
			t[++i]:=sep
			k:=0
		fi
	until aa=0

	j:=i
	s0:=s
	while i do
		s^:=t[i--]
		++s
	od
	s^:=0

	return j
end

function xdivrem128(word128 a, word64 b, &remainder)word128=
	word128 d,e,r
	word rlow

	d:=a/b
	r:=a-d*b

	assem
		mov d0,[r]
		mov [rlow],d0
	end
	remainder:=rlow
	return d
end

function i64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int =
!a is signed 64-bit int/long, fmt is a ref to a filled-in fmtrec
!convert a to a string in s, according to fmt
!a basic conversion is done first,: the field manipulation is done
!signed=1 for int, 0 for u32 (fmt^.unsigned forces ints to be treated as longs)
!returns length of s
	[0:onesixty]char str				! allow for binary with separators!
	int i,j,k,n,w,usigned
!	static u64 mindint=0x8000'0000'0000'0000
	const i64 mindint=0x8000'0000'0000'0000

	usigned:=0
	if fmt^.usigned then
		usigned:=1
	fi

	if aa=mindint and not usigned then		! minint

		str[0]:='-'
		n:=i64mintostr(&str[1],fmt^.base,fmt^.sepchar)+1
	else
		if (not usigned and aa<-0) or fmt^.plus then
			if aa<0 then
				aa:=-aa
				str[0]:='-'
			else
				str[0]:='+'
			fi
			n:=u64tostr(aa,&str[1],fmt^.base,fmt^.sepchar)+1
		else
			n:=u64tostr(aa,&.str,fmt^.base,fmt^.sepchar)
		fi
	fi

	if fmt^.suffix then
		str[n]:=fmt^.suffix
		str[++n]:=0
	fi

!str uses upper cases for hex/etc see if lc needed
	if (fmt^.base>10 or fmt^.suffix) and fmt^.lettercase='a'	then	! need lower when
		convlcstring(&.str)
	fi

!at this point, n is the str length including signs and suffix
	return expandstr(&.str,s,n,fmt)
end

function u64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int =		!U64TOSTRFMT
!see i64tostrfmt
	[0:onesixty]char str				! allow for binary with separators!
	int i,j,k,n,w

	n:=u64tostr(aa,&.str,fmt^.base,fmt^.sepchar)

	if fmt^.suffix then
		str[n]:=fmt^.suffix
		str[++n]:=0
	fi

!str uses upper cases for hex/etc see if lc needed
	if fmt^.base>10 or fmt^.suffix and fmt^.lettercase='a'	then	! need lower when
!		convlcstring(&.str)
	fi

!at this point, n is the str length including signs and suffix
	return expandstr(&.str,s,n,fmt)
end

function u128tostrfmt(i128 aa,ref char s,ref fmtrec fmt)int =		!U64TOSTRFMT
!see i64tostrfmt
	[0:onesixty]char str				! allow for binary with separators!
	int i,j,k,n,w

	n:=u128tostr(aa,&.str,fmt^.base,fmt^.sepchar)

	if fmt^.suffix then
		str[n]:=fmt^.suffix
		str[++n]:=0
	fi

!str uses upper cases for hex/etc see if lc needed
	if fmt^.base>10 or fmt^.suffix and fmt^.lettercase='a'	then	! need lower when
		convlcstring(&.str)
	fi

!at this point, n is the str length including signs and suffix
	return expandstr(&.str,s,n,fmt)
end

function i64mintostr(ref char s,int base,int sep)int =		!I64MINTOSTR
!convert minint to string in s do not include minus sign
!return number of chars in string
	[0:onesixty]char t
	int i,j,k,g,neg

	switch base
	when 10 then
		strcpy(&t[0],"9223372036854775808")
		j:=3
	when 16 then
		strcpy(&t[0],"8000000000000000")
		j:=1
	when 2 then
		strcpy(&t[0],"1000000000000000000000000000000000000000000000000000000000000000")
		j:=7
	else
		strcpy(&t[0],"<mindint>")
	endswitch

	i:=strlen(&t[0])
	s+:=i
	if sep then
		s+:=j
	fi
	s^:=0

	k:=0
	g:=(base=10|3|4)

	while i do
		--s
		s^:=t[i-- -1]
		if sep and i and ++k=g then
			--s
			s^:=sep
			k:=0
		fi
	od
	return strlen(s)
end

function strtostrfmt(ref char s,ref char t,int n,ref fmtrec fmt)int =
!s is a string process according to fmtrec fmt^, and return result in t
!caller should check whether any changes are required to s (now it can just use s), but this
!check is done here anyway (with a simple copy to t)
!n is current length of s
!return length of t
!Three processing stages:
!1 Basic input string s
!2 Additions or mods: quotes, suffix, when conversion
!3 Width adjustment
!1 is detected here, 2 is done here, 3 is done by expandstr
	ref char u,v
	[256]char str
	int w,nheap		! whether any heap storage is used  bytes allocated

	nheap:=0

	if fmt^.quotechar or fmt^.lettercase then		! need local copy
		if n<256 then
			u:=&.str
		else
			nheap:=n+3					! allow for quotes+terminator
			u:=pcm_alloc(nheap)
		fi
		if fmt^.quotechar then
			v:=u
			v^:=fmt^.quotechar
			++v
			if n then
				strcpy(v,s)
				v+:=n
			fi
			v^:=fmt^.quotechar
			++v
			v^:=0
			n+:=2
		else
			memcpy(u,s,n)
		fi
		switch fmt^.lettercase
		when 'a' then	! need lower when
			convlcstring(u)
		when 'A' then
			convucstring(u)
		endswitch
		s:=u
	fi

	w:=fmt^.minwidth
	if w>n then
		n:=expandstr(s,t,n,fmt)
	else
		memcpy(t,s,n)
	fi
	if nheap then
		pcm_free(u,nheap)
	fi
	return n
end

proc tostr_i64(int64 a, ref fmtrec fmt)=
	[360]char str
	int n

	case fmt^.charmode
	when 0 then
		n:=i64tostrfmt(a,&.str,fmt)
	when 'D','d' then
		n:=domultichar(ref char(&a),8,&.str,fmt)

	else						!assume 'C'
		printchar(a)			!no other formatting allowed
		return
	esac

	printstr_n(&.str,n)
end

proc tostr_u64(word64 a, ref fmtrec fmt)=
	[360]char str
	int n

	case fmt^.charmode
	when 'D','d' then
		n:=domultichar(ref char(&a),8,&.str,fmt)

	when 'C','c' then
		printchar(a)			!no other formatting allowed
		return

	else
		n:=u64tostrfmt(a,&.str,fmt)
	esac

	printstr_n(&.str,n)
end

proc tostr_u128(word128 a, ref fmtrec fmt,int neg)=
	[360]char str
	int n

	case fmt^.charmode
	when 'D','d' then
		n:=domultichar(ref char(&a),8,&.str,fmt)

	when 'C','c' then
		printchar(a)			!no other formatting allowed
		return

	else
		if neg then
			str[1]:='-'
			n:=u128tostrfmt(a,&str[2],fmt)+1
		else
			n:=u128tostrfmt(a,&.str,fmt)
		fi
	esac

	printstr_n(&.str,n)
end

proc tostr_r64(real x,ref fmtrec fmt) =
	[360]char str,str2
	[0:10]char cfmt
	int n

	cfmt[0]:='%'

	if fmt^.precision then
		cfmt[1]:='.'
		cfmt[2]:='*'
		cfmt[3]:=fmt^.realfmt
		cfmt[4]:=0
		sprintf(&.str,&.cfmt,fmt^.precision,x)
	else
		cfmt[1]:=fmt^.realfmt
		cfmt[2]:=0
		sprintf(&.str,&.cfmt,x)
	fi

!at this point, n is the str length including signs and suffix

!(TRY TAKING N FROM RESULT OF SPRINTF ABOVE)
	n:=strlen(&.str)		! current length

	if n<fmt^.minwidth then
		n:=expandstr(&.str,&.str2,n,fmt)
		strcpy(&.str,&.str2)
	fi

	printstr_n(&.str,n)
end

proc tostr_str(ref char s, ref fmtrec fmt) =
	int oldlen,newlen,n
	ref char t

!try and work out size of formatted string
	oldlen:=strlen(s)
	newlen:=oldlen

	if fmt^.quotechar or fmt^.minwidth>newlen or fmt^.lettercase or fmt.precision then
		if fmt^.quotechar then
			newlen+:=2
		fi
		if fmt^.minwidth>newlen then
			newlen:=fmt^.minwidth
		fi
		t:=pcm_alloc(newlen+1)
		n:=strtostrfmt(s,t,oldlen,fmt)
		if fmt.precision then
			n min:=fmt.precision
		fi

		printstr_n(t,n)
		pcm_free(t,newlen+1)
	else
		printstr_n(s,oldlen)
	fi
end

global function getfmt(ichar fmtstyle)ref fmtrec=
	static fmtrec fmt
	if fmtstyle then
		strtofmt(fmtstyle,-1,&fmt)
		return &fmt
	else
		return &defaultfmt
	fi
end

global function strint(int64 a, ichar fmtstyle=nil)ichar=
	static [100]char str
	ref fmtrec fmt

	m$print_startstr(&.str)
	tostr_i64(a,fmt:=getfmt(fmtstyle))
	m$print_end()
	return getstr(&.str,fmt)
end

global proc getstrint(int64 a, ichar dest)=
	m$print_startstr(dest)
	tostr_i64(a,getfmt(nil))
	m$print_end()
end

global function strword(word64 a, ichar fmtstyle=nil)ichar=
	static [100]char str
	ref fmtrec fmt

	m$print_startstr(&.str)
	tostr_u64(a,fmt:=getfmt(fmtstyle))
	m$print_end()
	return getstr(&.str,fmt)
end

global function strreal(real a, ichar fmtstyle=nil)ichar=
	static [320]char str
	ref fmtrec fmt

	m$print_startstr(&.str)
	tostr_r64(a,fmt:=getfmt(fmtstyle))
	m$print_end()
	return getstr(&.str,fmt)
end

function getstr(ichar s, ref fmtrec fmt)ichar=
	if fmt^.heapmode then
		return pcm_copyheapstring(s)
	else
		return s
	fi
end

proc initreadbuffer=
	if rd_buffer then return fi
	rd_buffer:=pcm_alloc(rd_buffersize)
	rd_buffer^:=0
	rd_pos:=rd_lastpos:=rd_buffer
end

global proc m$read_conline=
	initreadbuffer()

	readlinen(nil,rd_buffer,rd_buffersize)

	rd_length:=strlen(rd_buffer)
	rd_pos:=rd_buffer
	rd_lastpos:=nil
end

global proc m$read_fileline(filehandle f)=
	initreadbuffer()
	readlinen(f,rd_buffer,rd_buffersize)

	rd_length:=strlen(rd_buffer)
	rd_pos:=rd_buffer
	rd_lastpos:=nil
end

global proc m$read_strline(ichar s)=
	int n

	initreadbuffer()
	n:=strlen(s)

	if n<rd_buffersize then
		strcpy(rd_buffer,s)
	else
		memcpy(rd_buffer,s,rd_buffersize-1)
		(rd_buffer+rd_buffersize-1)^:=0
	fi
	rd_length:=n
	rd_pos:=rd_buffer
	rd_lastpos:=nil
end

function readitem(int &itemlength)ref char =
!read next item from rd_buffer
!identify a substring that can contain a name, int, real, string or filename
!return updated position of s that points past the item and past the immediate
!terminator 
!information about the read item is returned in itemstr, which points to
!the start of the item, and in itemlength. Item excludes any surrounding whitespace
!Item can be quoted, then the item points inside the quotes
!Any embedded quotes are removed, and the characters moved up. The item will
!be that reduced subsequence
!NOTE THAT THIS IS DESTRUCTIVE. On reread, the input will be different.
!I can mitigate this by adding spaces between the end of the item, and the next item,
!overwriting also the terminator. But this won't restore the line if one of the next
!reads is literal, using 'L' or 'C' codes.
	ref char p,s,itemstr
	char quotechar, c

	unless rd_buffer then 
		initreadbuffer()
!abortprogram("No readln")
	end unless


	s:=rd_pos

!scan string, eliminating leading white space
	while s^=' ' or s^=9 do
		++s
	od

	itemstr:=s				!assume starts here
	rd_lastpos:=rd_pos:=s

	if s^=0 then			! No more chars left to read return null string
		termchar:=0
		itemlength:=0
		return s
	fi

	quotechar:=0			! Allow possible enclosing single or double quotes
	if s^='"' then
		quotechar:='"'
		++s
	elsif s^='\'' then
		quotechar:='\''
		++s
	fi

!loop reading characters until separator or end reached
	p:=itemstr:=s

	while s^ do
		c:=s++^
		switch c
		when ' ', 9, comma, '=' then		! separator
			if quotechar or p=s then			!can be considered part of name if inside quotes, or is only char
				goto normalchar
			fi
			termchar:=c
			exit
		else
	normalchar::
			if c=quotechar then
				if s^=quotechar then	! embedded quote
					p^:=c
					++s
					++p
				else					! end of name
					termchar:=s^
					if termchar=',' or termchar='=' then
						++s
						termchar:=s^
					fi
					exit
				fi
			else
				p^:=c
				++p
			fi
		endswitch
	od

	if s^=0 then
		termchar:=0
	fi
	itemlength:=p-itemstr				! actual length of token
	rd_pos:=s

	return itemstr
end

global function strtoint(ichar s,int length=-1, word base=10)int64=
!return point to next char after terminator (which can be just off length of string)
	byte signd
	word64 aa
	word c,d

	itemerror:=0

	if length=-1 then
		length:=strlen(s)
	fi
!check for sign
	signd:=0
	if length and s^='-' then
		signd:=1; ++s; --length
	elsif length and s^='+' then
		++s; --length
	fi

	aa:=0
	while length do
		c:=s++^
		--length
		switch c
		when 'A'..'F' then d:=c-'A'+10
		when 'a'..'f' then d:=c-'a'+10
		when '0'..'9' then d:=c-'0'
		when '_', '\'' then
			next
		else
			itemerror:=1
			exit
		endswitch

		if d>=base then
			itemerror:=1
			exit
		fi
		aa:=aa*base+d
	od

	if signd then
		return -aa
	else
		return aa
	fi
end

global function m$read_i64(int fmt=0)int64=
	ref char s
	int length,c
	int64 aa

	case fmt
	when 'C','c' then
		rd_lastpos:=rd_pos
		if rd_pos^ then
			return rd_pos++^
		else
			return 0
		fi
	when 'T','t' then
		return termchar
	when 'E','e' then
		return itemerror
	esac

	s:=readitem(length)

	case fmt
	when 0,'I','i' then
		return strtoint(s,length)
	when 'B','b' then
		return strtoint(s,length,2)
	when 'H','h' then
		return strtoint(s,length,16)
	esac
	return 0
end

global function m$read_r64(int fmt=0)real=
	[512]char str
	ref char s
	int length
	int32 numlength
	real x

	s:=readitem(length)

	if length=0 or length>=str.len then		!assume not a real
		return 0.0
	fi
	memcpy(&.str,s,length)
	str[length+1]:=0

	itemerror:=0

	if sscanf(&.str,"%lf%n", &x, &numlength)=0 or numlength<>length then
		x:=0.0
		itemerror:=1
	fi

	return x
end

global proc m$read_str(ref char dest, int destlen=0,fmt=0)=
	ref char s
	int length,numlength
	real x

	itemerror:=0
	if fmt='L' or fmt='l' then
		s:=rd_pos
		length:=rd_buffer+rd_length-rd_pos

	else
		s:=readitem(length)

		if fmt='N' or fmt='n' then
			iconvlcn(s,length)
		fi
	fi

	if destlen>0 then
		if length>=destlen then
			length:=destlen-1
			itemerror:=1
		fi
	fi
	memcpy(dest,s,length)
	(dest+length)^:=0
end

global proc readstr(ref char dest, int fmt=0,destlen=0)=
	m$read_str(dest,destlen,fmt)
end

global proc rereadln=
	rd_pos:=rd_buffer
	rd_lastpos:=rd_pos
end

global proc reread=
	rd_pos:=rd_lastpos
end

global function valint(ichar s, int fmt=0)int64=
ref char old_pos, old_lastpos
int64 aa

initreadbuffer()
old_pos:=rd_pos
old_lastpos:=rd_lastpos

rd_pos:=s
aa:=m$read_i64(fmt)
rd_pos:=old_pos
rd_lastpos:=old_lastpos
return aa
end

global function valreal(ichar s)real=
ref char old_pos, old_lastpos
real x

initreadbuffer()
old_pos:=rd_pos
old_lastpos:=rd_lastpos

rd_pos:=s
x:=m$read_r64()
rd_pos:=old_pos
rd_lastpos:=old_lastpos
return x
end

proc iconvlcn(ref char s,int n) =		!ICONVLCN
to n do
	s^:=tolower(s^)
	++s
od
end

proc iconvucn(ref char s,int n) =		!ICONVUCN
to n do
	s^:=toupper(s^)
	++s
od
end

proc convlcstring(ref char s)=		!CONVLCSTRING
while (s^) do
	s^:=tolower(s^)
	++s
od
end

proc convucstring(ref char s)=		!CONVUCSTRING
while (s^) do
	s^:=toupper(s^)
	++s
od
end

global proc m$float_u64_r64(word a)=
	assem
		cmp D10,0
		jl fl1
!number is positive, so can treat like i64
		cvtsi2sd XMM0,D10
		jmp flx
fl1:						!negative value
		and D10,[mask63]		!clear top bit (subtract 2**63)
		cvtsi2sd XMM0,D10
		addsd XMM0,[offset64]	!(add 2**63 back to result)
flx:
	end
end

global function m$power_i64(int64 a,n)int64=
	if n<0 then
		return 0
	elsif n=0 then
		return 1
	elsif n=1 then
		return a
	elsif n.even then
		return m$power_i64(sqr a, n/2)
	else			!assume odd
		return m$power_i64(sqr a, (n-1)/2)*a
	fi
end

!global proc m$intoverflow=
!	abortprogram("Integer overflow detected")
!end

global proc m$mul_i128(word128 aa,bb)=
	assem
		push d3
		push d4
		push d5
		mov d2,[aa]			!a1
		mov d3,[aa+8]		!a2
		mov d4,[bb]			!b1
		mov d5,[bb+8]		!b2


		mov d0,d2			!a1
		imul2 d0,d5			!*b2	
		mov d6,d0			!=>d6

		mov d0,d3			!a2
		imul2 d0,d4			!*b1
		mov d7,d0			!=>d7

		mov d0,d2			!a1
		mul d4				!*b1
		add d11,d6			! + a1*b2<<64
		add d11,d7			! + a2*b1<<64
		mov d1,d11
		pop d5
		pop d4
		pop d3
	end
end

global proc m$idiv_i128(word128 aa,bb)=
!does 128/64 bits only
charlie::
	assem
		push d3
		push d4
		push d6


		mov d2,[aa]
		mov d3,[aa+8]

		mov d4,[bb]
		or d4,d4
		jz divbyzero

		mov d0,d3		!a2
		xor d11,d11
		div d4			!a2/b
		mov d6,d0		! => c2
		mul d4			!c2*b
		sub d3,d0		!a2-:=c2*b

		mov d0,d2
		mov d11,d3		!a2:a1
		div d4			!/b
		mov d1,d6
		pop d6
		pop d4
		pop d3

	end
	return

asm divbyzero:
CPL "DIV BY ZERO"
	stop 1
end

global proc m$dotindex(word i,a)=
!return a.[i] in d0
!	assem
!		mov d0,[a]
!		mov cl,[i]
!		shr d0,cl
!		and d0,1
!	end	
end

global proc m$dotslice(word j,i,a)=
!!return a.[i..j] in d0; assumes j>=i
!	assem
!		mov d0,[a]
!		mov rcx,[i]
!		shr d0,cl
!		sub rcx,[j]
!		neg rcx				!j-1
!		mov d2,0xFFFF'FFFF'FFFF'FFFE
!		shl d2,cl
!		not d2
!		and d0,d2
!	end	
end

global proc m$popdotindex(word i,ref word p,word x)=
!!p^.[i]:=x
!	assem
!		mov d3,[p]
!		mov cl,[i]
!		mov d0,[d3]
!		mov d1,1
!		shl d1,cl			!000001000
!		not d1				!111110111
!		and d0,d1			!clear that bit in dest
!		mov d1,[x]
!		and d1,1
!		shl d1,cl
!		or d0,d1
!		mov [d3],d0
!	end	
end

global proc m$popdotslice(word j,i, ref word p, word x)=
!p^.[i..j]:=x
!	assem
!!d3 = p
!!d4 = x, then shifted then masked x
!!d5 = i
!!d6 = clear mask
!
!		mov d3,[p]
!		mov d4,[x]
!		mov d5,[i]
!		mov rcx,d5			!i
!		shl d4,cl			!x<<i
!		mov rcx,[j]
!		sub rcx,d5			!j-i
!		inc rcx				!j-i+1
!		mov d2,0xFFFF'FFFF'FFFF'FFFF
!		shl d2,cl			!...111100000     (assume 5-bit slice)
!		not d2				!...000011111
!		mov rcx,d5			!i
!		shl d2,cl			!...000011111000  (assume i=3)
!		and d4,d2			!mask x (truncate extra bits)
!		mov d0,[d3]
!		not d2				!...111100000111
!		and d0,d2			!clear dest bits
!		or d0,d4			!add in new bits
!		mov [d3],d0
!	end	
end


!global function m$sin(real x)real = {`sin(x)}
!global function m$cos(real x)real = {`cos(x)}
!global function m$tan(real x)real = {`tan(x)}
!global function m$asin(real x)real = {`asin(x)}
!global function m$acos(real x)real = {`acos(x)}
!global function m$atan(real x)real = {`atan(x)}
!global function m$ln(real x)real = {`log(x)}
!!global function m$lg(real x)real = {`lg(x)}
!global function m$log(real x)real = {`log10(x)}
!global function m$exp(real x)real = {`exp(x)}
!global function m$floor(real x)real = {`floor(x)}
!global function m$ceil(real x)real = {`ceil(x)}
!global function m$fract(real x)real = {abortprogram("FRACT");0}
!global function m$round(real x)real = {abortprogram("ROUND");0}

global proc mclunimpl(ichar mess)=
	printf("MCL-UNIMPL: %s\n",mess)
	stop 1
end
=== mclib.m 5/77 ===
global type filehandle=ref void

importlib $cstd=
!	clang function malloc	(wordm)ref void
	clang function malloc	(word64)ref void
	clang function realloc	(ref void, wordm)ref void
	clang proc     free		(ref void)
	clang proc     memset	(ref void, int32, wordm)
	clang proc     memcpy	(ref void, ref void, wordm)
	clang function clock	:int32
	clang function ftell	(filehandle)int32
	clang function fseek	(filehandle, int32, int32)int32
	clang function fread	(ref void, wordm, wordm, filehandle)wordm
	clang function fwrite	(ref void, wordm, wordm, filehandle)wordm
	clang function getc		(filehandle)int32
	clang function ungetc	(int32, filehandle)int32
	clang function fopen	(ichar,ichar="rb")filehandle
	clang function fclose	(filehandle)int32
	clang function fgets	(ichar, int, filehandle)ichar
	clang function remove	(ichar)int32
	clang function rename	(ichar, ichar)int32
	clang function getchar	:int32
	clang proc     putchar	(int32)
	clang proc     setbuf	(filehandle, ref byte)

	clang function strlen	(ichar)int
	clang function strcpy	(ichar, ichar)ichar
	clang function strcmp	(ichar, ichar)int32
	clang function strncmp	(ichar, ichar, wordm)int32
	clang function strncpy	(ichar, ichar, wordm)wordm
	clang function memcmp	(ref void, ref void, wordm)int32
	clang function strcat	(ichar, ichar)ichar
	clang function tolower	(int32)int32
	clang function toupper	(int32)int32
	clang function isalpha	(int32)int32
	clang function isupper	(int32)int32
	clang function islower	(int32)int32
	clang function isalnum	(int32)int32
	clang function isspace	(int32)int32
	clang function strstr	(ichar, ichar)ichar
	clang function atol		(ichar)intm
	clang function atoi		(ichar)int32
	clang function strtod	(ichar,ref ref char)real64
	clang function _strdup  (ichar)ichar

	clang function puts		(ichar)int32
	clang function puts99	(ichar)int32
	clang function printf	(ichar, ...)int32

	clang function sprintf	(ichar, ichar, ...)int32
!	clang function __mingw_sprintf	(ichar, ...)int32

	clang function sscanf	(ichar, ichar, ...)int32
	clang function scanf	(ichar, ...)int32

	clang function rand		:int32
	clang proc     srand	(word32)
	clang function system	(ichar)int32

	clang function fgetc	(filehandle)int32
	clang function fputc	(int32,  filehandle)int32
	clang function fprintf	(filehandle, ichar, ...)int32
	clang function fputs	(ichar,  filehandle)int32
	clang function feof		(filehandle)int32
	clang function getch	:int32
	clang function kbhit	:int32
	clang function _mkdir	(ichar)int32
	clang function mkdir	(ichar)int32
	clang function dummy	(real)real
	clang function strchr	(ichar,int32)ichar

	clang proc     _exit	(int32)
	clang proc     "exit"	(int32)
!	clang proc     `exit	(int32)
	clang function	pow		(real,real)real

	clang function	`sin	(real)real
	clang function	`cos	(real)real
	clang function	`tan	(real)real
	clang function	`asin	(real)real
	clang function	`acos	(real)real
	clang function	`atan	(real)real
	clang function	`log	(real)real
	clang function	`log10	(real)real
	clang function	`exp	(real)real
	clang function	`floor	(real)real
	clang function	`ceil	(real)real

	clang proc      qsort   (ref void, word64, word64, ref proc)

end

global macro strdup=_strdup

importlib $cstdextra=
	clang function __getmainargs(ref int32, ref void, ref void, int, ref void)int32
end

global const c_eof		=-1
global const seek_set	= 0
global const seek_curr	= 1
global const seek_end	= 2
=== mlibnew.m 6/77 ===
import msys
import clib
import oslib

!const mem_check=1
const mem_check=0

GLOBAL INT MDEBUG
GLOBAL INT NPCMALLOC


global [0..300]u64 allocupper
global int alloccode				!set by heapalloc
global int allocbytes				!set by heapalloc
global int fdebug=0
global int rfsize

const threshold=1<<25
const alloc_step=1<<25
word maxmemory
int  maxalloccode

byte pcm_setup=0

int show=0

GLOBAL REF VOID ALLOCBASE

global int memtotal=0
global int64 smallmemtotal=0
global int smallmemobjs=0
global int maxmemtotal=0

!store all allocated pointers
const int maxmemalloc=(mem_check|500000|2)
[maxmemalloc+1]ref int32 memalloctable
[maxmemalloc+1]int32 memallocsize

const pcheapsize=1048576*2
ref byte pcheapstart
ref byte pcheapend			!points to first address past heap
ref byte pcheapptr

const int maxblockindex = 8 		!2048
global const int maxblocksize = 2048

[0:maxblocksize+1]byte sizeindextable	!convert byte size to block index 1..maxblockindex

const int size16   = 1			!the various index codes
const int size32   = 2
const int size64   = 3
const int size128  = 4
const int size256  = 5
const int size512  = 6
const int size1024 = 7
const int size2048 = 8

GLOBAL [0:9]ref wordp freelist

global record strbuffer =
	ichar strptr
	int32 length
	int32 allocated
end

global tabledata() [0:]ichar pmnames=
	(pm_end=0,		$),
	(pm_option,		$),
	(pm_sourcefile,	$),
	(pm_libfile,	$),
	(pm_colon,		$),
	(pm_extra,		$),
end

[2]word seed = (0x2989'8811'1111'1272',0x1673'2673'7335'8264)

global function pcm_alloc(int n)ref void =		!PCM_ALLOC
ref byte p

if not pcm_setup then
	pcm_init()
fi

if n>maxblocksize then			!large block allocation

	alloccode:=pcm_getac(n)
	allocbytes:=allocupper[alloccode]

	p:=allocmem(allocbytes)
	if not p then
		abortprogram("pcm_alloc failure")
	fi

	if mem_check then addtomemalloc(ref int32(p),allocbytes) fi

	return p
fi

alloccode:=sizeindextable[n]		!Size code := 0,1,2 etc for 0, 16, 32 etc
allocbytes:=allocupper[alloccode]
smallmemtotal+:=allocbytes

if p:=ref byte(freelist[alloccode]) then		!Items of this block size available
if mem_check then addtomemalloc(ref int32(p),allocbytes) fi
	freelist[alloccode]:=ref wordp(int((freelist[alloccode])^))

	return p
fi

!No items in freelists: allocate new space in this heap block
p:=pcheapptr				!Create item at start of remaining pool in heap block
pcheapptr+:=allocbytes			!Shrink remaining pool

if pcheapptr>=pcheapend then		!Overflows?
	p:=pcm_newblock(allocbytes)		!Create new heap block, and allocate from start of that
	return p
fi
if mem_check then addtomemalloc(ref int32(p),allocbytes) fi

return p
end

global proc pcm_free(ref void p,int n) =		!PCM_FREE
!n can be the actual size requested it does not need to be the allocated size
int acode

if n=0 then return fi

if n>maxblocksize then		!large block
	if mem_check then removefrommemalloc(p,n) fi

	free(p)
	return
fi

if p then
	acode:=sizeindextable[n]		!Size code := 0,1,2 etc for 0, 16, 32 etc

	smallmemtotal-:=allocupper[acode]

	if mem_check then removefrommemalloc(p,allocupper[acode]) fi

	cast(p,ref wordp)^:=wordp(int(freelist[acode]))
	freelist[acode]:=p
fi
end

global proc pcm_freeac(ref void p,int alloc) =		!PCM_FREEAC
pcm_free(p,allocupper[alloc])
end

global proc pcm_copymem4(ref void p,q,int n) =	!PCM_COPYMEM4
!copy n bytes of memory from q to p.
!the memory spaces used are multiples of 16 bytes, but n itself could be anything
!n can be zero, and need not be a multiple of 4 bytes

memcpy(p,q,n)
end

global proc pcm_clearmem(ref void p,int n) =		!PCM_CLEARMEM
memset(p,0,n)
end

global proc pcm_init =		!PCM_INIT
!set up sizeindextable too
int j,k,k1,k2
int64 size
const limit=1<<33

if pcm_setup then
	return
fi

pcm_newblock(0)

ALLOCBASE:=PCHEAPPTR
!CPL "*** SETALLOCBASE",STRALLOC(ALLOCBASE)

for i to maxblocksize do	!table converts eg. 78 to 4 (4th of 16,32,64,128)
	j:=1
	k:=16
	while i>k do
		k:=k<<1
		++j
	od
	sizeindextable[i]:=j
od

allocupper[1]:=16
size:=16

for i:=2 to 27 do
	size*:=2
	allocupper[i]:=size
	if size>=threshold then
			k:=i
		exit
	fi
od

for i:=k+1 to allocupper.upb do
	size+:=alloc_step
	if size<limit then
		allocupper[i]:=size
		maxmemory:=size
	else
		maxalloccode:=i-1
		exit
	fi
		
od
pcm_setup:=1
end

global function pcm_getac(int size)int =		!PCM_GETAC
! convert linear blocksize from 0..approx 2GB to 8-bit allocation code

!sizeindextable scales values from 0 to 2048 to allocation code 0 to 9

if size<=maxblocksize then
	return sizeindextable[size]		!size 0 to 2KB
fi

size:=(size+255)>>8					!scale by 256

!now same sizetable can be used for 2KB to 512KB (288 to 2KB)

if size<=maxblocksize then
	return sizeindextable[size]+8
fi

!sizetable now used for 512KB to 128MB (to 2KB)
size:=(size+63)>>6					!scale by 256

if size<=maxblocksize then
	return sizeindextable[size]+14
fi


!size>2048, which means it had been over 128MB.

size:=(size-2048+2047)/2048+22
return size
end

global function pcm_newblock(int itemsize)ref void=
!create new heap block (can be first)
!also optionally allocate small item at start
!return pointer to this item (and to the heap block)
static int totalheapsize
ref byte p

totalheapsize+:=pcheapsize
alloccode:=0
p:=allocmem(pcheapsize)	!can't free this block until appl terminates
if p=nil then
	abortprogram("Can't alloc pc heap")
fi

pcheapptr:=p
pcheapend:=p+pcheapsize

if pcheapstart=nil then		!this is first block
	pcheapstart:=p
fi
pcheapptr+:=itemsize
return ref u32(p)
end

global function pcm_round(int n)int =		!PCM_ROUND
!for any size n, return actual number of bytes that would be allocated
static [0:maxblockindex+1]int32 allocbytes=(0,16,32,64,128,256,512,1024,2048)

if n>maxblocksize then
	return n
else
	return allocbytes[sizeindextable[n]]
fi
end

global function pcm_array(int n)int =		!PCM_ARRAY
!n bytes are needed for an array return the number of bytes to be actually allocated
int m

if n<=maxblocksize then	!automatic rounding up used for small heap
	return pcm_round(n)
else				!devise some strategy probably doubling up.
	m:=2048
	while n>m do
		m<<:=1
	od
	return m
fi

end

global proc pcm_printfreelist(int size,ref wordp p) =		!PCM_PRINTFREELIST
println "Size: ",size
while p do
	print " ",,p:"h"
	p:=ref wordp(int(p^))
od
puts("")
end

global proc pcm_diags(ref char caption) =		!PCM_DIAGS
int m

println "HEAP FREELISTS:",caption

m:=16
for i:=1 to 8 do
	pcm_printfreelist(m,freelist[i])
	m<<:=1
od
end

global function pcm_allocz(int n)ref void =		!PCM_ALLOCZ
ref void p
p:=pcm_alloc(n)

memset(p,0,n)
return p
end

global function pcm_copyheapstring(ref char s)ref char =
!allocate enough bytes for string s: copy s to the heap
!return pointer to new string
ref char q
int n
if s=nil then return nil fi

n:=strlen(s)+1
q:=pcm_alloc(n)
memcpy(q,s,n)
return q
end

global function pcm_copyheapstringn(ref char s,int n)ref char =
ref char q
if s=nil then return nil fi

q:=pcm_alloc(n+1)
memcpy(q,s,n)
(q+n)^:=0
return q
end

global function pcm_copyheapblock(ref char s, int length)ref char =
!allocate enough bytes for string s: copy s to the heap
!return pointer to new string
	ref char q
	if length=0 then return nil fi

	q:=pcm_alloc(length)
	memcpy(q,s,length)
	return q
end

proc addtomemalloc(ref int32 ptr,int size)=
!add ptr to allocated table

!CPL "***************ADD TO ALLOC:",ptr,size

for i to maxmemalloc do
	if memalloctable[i]=ptr then
		CPL "ALLOC ERROR:",ptr,"ALREADY ALLOCATED\n\n\n"
CPL
CPL
		stop 2
	fi

	if memalloctable[i]=nil then		!unused entry
		memalloctable[i]:=ptr
		memallocsize[i]:=size
		return
	fi
od
CPL "MEMALLOCTABLE FULL\n\n\n\n"; os_getch()
stop 3
end

proc removefrommemalloc(ref int32 ptr,int size)=
!remove ptr to allocated table

!CPL "------------------************REMOVE FROM ALLOC:",ptr,size

for i to maxmemalloc do
	if memalloctable[i]=ptr then

if memallocsize[i]<>size then
	CPL "REMOVE:FOUND",ptr,"IN MEMALLOCTABLE, FREESIZE=",size,", BUT STORED AS BLOCK SIZE:",memallocsize[i]
!PCERROR("MEMERROR")
CPL
CPL
	abortprogram("MEMSIZE")
fi

		memalloctable[i]:=nil
		return
	fi
od
CPL "CAN'T FIND",ptr,"IN MEMALLOCTABLE",size
CPL
CPL
abortprogram("MEM")
stop 4
end

global function allocmem(int n)ref void =		!ALLOCMEM
ref void p

p:=malloc(n)
if (p) then
	return p
fi
println n,memtotal
abortprogram("Alloc mem failure")
return nil
end

global function reallocmem(ref void p,int n)ref void =		!REALLOCMEM
p:=realloc(p,n)
return p when p
println n
abortprogram("Realloc mem failure")
return nil
end

global proc abortprogram(ref char s) =		!ABORTPROGRAM
println s
print   "ABORTING: Press key..."
!os_getch()
stop 5
end

global function getfilesize(filehandle handlex)int=		!GETFILESIZE
	word32 p,size

	p:=ftell(handlex)		!current position
	fseek(handlex,0,2)		!get to eof
	size:=ftell(handlex)		!size in bytes
	fseek(handlex,p,seek_set)	!restore position
	return size
end

global proc readrandom(filehandle handlex, ref byte mem, int offset, size) =		!READRANDOM
	int a
	fseek(handlex,offset,seek_set)
	a:=fread(mem,1,size,handlex)			!assign so as to remove gcc warning
end

global function writerandom(filehandle handlex, ref byte mem, int offset,size)int =		!WRITERANDOM
	fseek(handlex,offset,seek_set)
	return fwrite(mem,1,size,handlex)
end

global function setfilepos(filehandle file,int offset)int=
	return fseek(file,offset,0)
end

global function getfilepos(filehandle file)int=
	return ftell(file)
end

global function readfile(ref char filename)ref byte =		!READFILE
filehandle f
int size
ref byte m,p

f:=fopen(filename,"rb")
if f=nil then
	return nil
fi
rfsize:=size:=getfilesize(f)

m:=malloc(size+4)		!allow space for etx/zeof etc

if m=nil then
	return nil
fi

readrandom(f,m,0,size)
p:=m+size			!point to following byte
p^:=0
(p+1)^:=26
(p+2)^:=0			!allow use as string

fclose(f)
return m
end

global function writefile(ref char filename,ref byte data,int size)int =
filehandle f
int n

f:=fopen(filename,"wb")
if f=nil then
	return 0
fi

n:=writerandom(f,data,0,size)
fclose(f)
return n
end

global function checkfile(ref char file)int=		!CHECKFILE
filehandle f
if f:=fopen(file,"rb") then
	fclose(f)
	return 1
fi
return 0
end

global proc readlinen(filehandle handlex,ref char buffer,int size) =		!READLINEN
!size>2
int ch
ref char p
int n
[0:100]char buff
byte crseen

if handlex=nil then
	handlex:=filehandle(os_getstdin())
fi
if handlex=nil then
	n:=0
	p:=buffer
	do
		ch:=getchar()
		if ch=13 or ch=10 or ch=-1 then
			p^:=0
			return
		fi
		p++^:=ch
		++n
		if n>=(size-2) then
			p^:=0
			return
		fi
	od
fi

buffer^:=0
if fgets(buffer,size-2,handlex)=nil then
	return
fi

n:=strlen(buffer)
if n=0 then
	return
fi

p:=buffer+n-1		!point to last char
crseen:=0
while (p>=buffer and (p^=13 or p^=10)) do
	if p^=13 or p^=10 then crseen:=1 fi
	p--^ :=0
od

!NOTE: this check doesn't work when a line simply doesn't end with cr-lf

if not crseen and (n+4>size) then
	cpl size,n
	abortprogram("line too long")
fi
end

global proc iconvlcn(ref char s,int n) =		!ICONVLCN
to n do
	s^:=tolower(s^)
	++s
od
end

global proc iconvucn(ref char s,int n) =		!ICONVUCN
to n do
	s^:=toupper(s^)
	++s
od
end

global proc convlcstring(ref char s)=		!CONVLCSTRING
while (s^) do
	s^:=tolower(s^)
	++s
od
end

global proc convucstring(ref char s)=		!CONVUCSTRING
while (s^) do
	s^:=toupper(s^)
	++s
od
end

global function changeext(ref char s,newext)ichar=		!CHANGEEXT
!whether filespec has an extension or not, change it to newext
!newext should start with "."
!return new string (locally stored static string, so must be used before calling again)
static [260]char newfile
[32]char newext2
ref char sext
int n

strcpy(&newfile[1],s)

case newext^
when 0 then
	newext2[1]:=0
	newext2[2]:=0
when '.' then
	strcpy(&newext2[1],newext)
else
	strcpy(&newext2[1],".")
	strcat(&newext2[1],newext)
esac


sext:=extractext(s,1)			!include "." when it is only extension

case sext^
when 0 then						!no extension not even "."
	strcat(&newfile[1],&newext2[1])
when '.' then						!no extension not even "."
	strcat(&newfile[1],&newext2[2])
else							!has extension
	n:=sext-s-2			!n is number of chars before the "."
	strcpy(&newfile[1]+n+1,&newext2[1])
esac

return &newfile[1]
end

global function extractext(ref char s,int period=0)ichar=		!EXTRACTEXT
!if filespec s has an extension, then return pointer to it otherwise return ""
!if s ends with ".", then returns "."
ref char t,u

t:=extractfile(s)

if t^=0 then			!s contains no filename
	return ""
fi

!t contains filename+ext
u:=t+strlen(t)-1		!u points to last char of t

while u>=t do
	if u^='.' then		!start extension found
		if (u+1)^=0 then		!null extension
			return (period|"."|"")
		fi
		return u+1			!return last part of filename as extension exclude the dot
	fi
	--u
od
return ""			!no extension seen
end

global function extractpath(ref char s)ichar=		!EXTRACTPATH
static [0:260]char str
ref char t
int n

t:=s+strlen(s)-1		!t points to last char

while (t>=s) do
	switch t^
	when '\\','/',':' then		!path separator or drive letter terminator assume no extension
		n:=t-s+1			!n is number of chars in path, which includes rightmost / or \ or :
		memcpy(&.str,s,n)
		str[n]:=0
		return &.str
	endswitch
	--t
od
return ""			!no path found
end

global function extractfile(ref char s)ichar=		!EXTRACTFILE
ref char t

t:=extractpath(s)

if t^=0 then			!s contains no path
	return s
fi

return s+strlen(t)		!point to last part of s that contains the file
end

global function extractbasefile(ref char s)ichar=		!EXTRACTBASEFILE
static [0:100]char str
ref char f,e
int n,flen

f:=extractfile(s)
flen:=strlen(f)
if flen=0 then		!s contains no path
	return ""
fi
e:=extractext(f,0)

if e^ then			!not null extension
	n:=flen-strlen(e)-1
	memcpy(&str,f,n)
	str[n]:=0
	return &.str
fi
if (f+flen-1)^='.' then
	memcpy(&str,f,flen-1)
	str[flen-1]:=0
	return &.str
fi
return f
end

global function addext(ref char s,ref char newext)ichar=		!ADDEXT
!when filespec has no extension of its own, add newext
ref char sext

sext:=extractext(s,1)

if sext^=0 then						!no extension not even "."
	return changeext(s,newext)
fi

return s							!has own extension; use that
end

global function alloctable(int n, size)ref void =		!ALLOCTABLE
!Allocate table space for n elements, each of size <size>
!Allows for 1-based indexing, so allocates (n+1) elements
ref void p

p:=malloc((n+1)*size)

if not p then
	abortprogram("Alloctable failure")
fi
return p
end

global function zalloctable(int n, size)ref void =		!ALLOCTABLE
!Allocate table space for n elements, each of size <size>
!Allows for 1-based indexing, so allocates (n+1) elements
ref int p

p:=alloctable(n,size)

pcm_clearmem(p,(n+1)*size)
return p
end

global proc checkfreelists(ichar s)=
ref wordp p,q
int64 aa

for i:=2 to 2 do
	p:=freelist[i]

	while p do
		aa:=int64(p)
		if aa>0xffff'FFFF or aa<100 then
			CPL s,"FREE LIST ERROR",i,p,q
!			os_getch(); stop 1
		fi
		q:=p
		p:=ref wordp(int(p^))
	od

od
end


global function pcm_alloc32:ref void =		!PCM_ALLOC
ref byte p

allocbytes:=32

!No items in freelists: allocate new space in this heap block

return pcm_alloc(32)
end

global proc pcm_free32(ref void p) =
!n can be the actual size requested it does not need to be the allocated size

smallmemtotal-:=32
if mem_check then removefrommemalloc(p,32) fi

cast(p,ref wordp)^:=wordp(int(freelist[2]))
freelist[2]:=p
end

global proc outbyte(filehandle f,int x)=
fwrite(&x,1,1,f)
end

global proc outword16(filehandle f,word x)=
fwrite(&x,2,1,f)
end

global proc outword(filehandle f,word x)=
fwrite(&x,4,1,f)
end

global proc outword64(filehandle f,word64 x)=
fwrite(&x,8,1,f)
end

global function myeof(filehandle f)int=
int c

c:=fgetc(f)
if c=c_eof then return 1 fi
ungetc(c,f)
return 0;
end

global function pcm_smallallocz(int n)ref void =
ref byte p

allocbytes:=allocupper[alloccode:=sizeindextable[n]]

!No items in freelists: allocate new space in this heap block
p:=pcheapptr				!Create item at start of remaining pool in heap block
pcheapptr+:=allocbytes			!Shrink remaining pool

if pcheapptr>=pcheapend then		!Overflows?
	p:=pcm_newblock(allocbytes)		!Create new heap block, and allocate from start of that
	memset(p,0,n)
	return p
fi

memset(p,0,n)

return p
end

global function pcm_smallalloc(int n)ref void =
ref byte p

allocbytes:=allocupper[alloccode:=sizeindextable[n]]

!No items in freelists: allocate new space in this heap block
p:=pcheapptr				!Create item at start of remaining pool in heap block
pcheapptr+:=allocbytes			!Shrink remaining pool

if pcheapptr>=pcheapend then		!Overflows?
	p:=pcm_newblock(allocbytes)		!Create new heap block, and allocate from start of that
	return p
fi

return p
end

global proc strbuffer_add(ref strbuffer dest, ichar s, int n=-1)=
int newlen,oldlen
ichar newptr

IF N=0 THEN CPL "N=0" FI

if n=-1 then
	n:=strlen(s)
fi

oldlen:=dest^.length

if oldlen=0 then				!first string
	dest^.strptr:=pcm_alloc(n+1)
	dest^.allocated:=allocbytes
	dest^.length:=n				!length always excludes terminator
	memcpy(dest^.strptr,s,n)
	(dest^.strptr+n)^:=0
	return
fi

newlen:=oldlen+n
if newlen+1>dest^.allocated then
	newptr:=pcm_alloc(newlen+1)
	memcpy(newptr,dest^.strptr,oldlen)
	dest^.strptr:=newptr
	dest^.allocated:=allocbytes
fi

memcpy(dest^.strptr+oldlen,s,n)
(dest^.strptr+newlen)^:=0

dest^.length:=newlen
end

global proc gs_init(ref strbuffer dest)=			!INITGENSTR
pcm_clearmem(dest,strbuffer.bytes)
end

global proc gs_free(ref strbuffer dest)=
if dest^.allocated then
	pcm_free(dest^.strptr,dest^.allocated)
fi
end

global proc gs_str(ref strbuffer dest,ichar s)=			!GENSTR
strbuffer_add(dest,s)
end

global proc gs_char(ref strbuffer dest,int c)=
[16]char s

s[1]:=c
s[2]:=0

strbuffer_add(dest,&.s,1)
end

global proc gs_strn(ref strbuffer dest,ichar s,int length)=
strbuffer_add(dest,s,length)
end

global proc gs_strvar(ref strbuffer dest,s)=			!GENSTR
strbuffer_add(dest,s^.strptr)
end

global proc gs_strint(ref strbuffer dest,int64 a)=
strbuffer_add(dest,strint(a))
end

global proc gs_strln(ref strbuffer dest,ichar s)=		!GENSTRLN
gs_str(dest,s)
gs_line(dest)
end

global proc gs_strsp(ref strbuffer dest,ichar s)=
gs_str(dest,s)
gs_str(dest," ")
end

global proc gs_line(ref strbuffer dest)=
strbuffer_add(dest,"\w")
end

global function gs_getcol(ref strbuffer dest)int=
return dest^.length
end

global proc gs_leftstr(ref strbuffer dest, ichar s, int w, padch=' ')=
int col,i,n,slen
[2560]char str
col:=dest^.length
strcpy(&.str,s)
slen:=strlen(s)
n:=w-slen
if n>0 then
	for i:=1 to n do
		str[slen+i]:=padch
	od
	str[slen+n+1]:=0
fi
gs_str(dest,&.str)
end

global proc gs_leftint(ref strbuffer dest, int a, int w, padch=' ')=
gs_leftstr(dest,strint(a),w,padch)
end

global proc gs_padto(ref strbuffer dest,int col, ch=' ')=
int n
[2560]char str

n:=col-dest^.length
if n<=0 then return fi
for i:=1 to n do
	str[i]:=ch
od
str[n+1]:=0
gs_str(dest,&.str)
end

global proc gs_println(ref strbuffer dest,filehandle f=nil)=
(dest.strptr+dest.length)^:=0

if f=nil then
	println dest.strptr,,"\c"
else
	println @f,dest.strptr,,"\c"
fi
end

global function nextcmdparam(int &paramno, ichar &name, &value, ichar defext=nil)int=
static int infile=0
static ichar filestart=nil
static ichar fileptr=nil
static byte colonseen=0
ref char q
ichar item,fileext
ichar rest
int length
static [300]char str

reenter::
value:=nil
name:=nil

if infile then
	if readnextfileitem(fileptr,item)=0 then		!eof
		free(filestart)								!file allocated via malloc
		infile:=0
		goto reenter
	fi
else
	if paramno>nsysparams then
		return pm_end
	fi
	item:=sysparams[paramno]
	++paramno

	length:=strlen(item)

	if item^='@' then		!@ file
		filestart:=fileptr:=cast(readfile(item+1))
		if filestart=nil then
			println "Can't open",item
			stop 7
		fi
		infile:=1
		goto reenter
	fi

	if item^=':' then
		colonseen:=1
		return pm_colon
	fi
fi

value:=nil
if item^='-' then
	name:=item+(colonseen|0|1)
	q:=strchr(item,':')
	if not q then
		q:=strchr(item,'=')
	fi
	if q then
		value:=q+1
		q^:=0
	fi
	return (colonseen|pm_extra|pm_option)
fi

fileext:=extractext(item,0)
name:=item

if fileext^=0 then							!no extension
	strcpy(&.str,name)
	if defext and not colonseen then
		name:=addext(&.str,defext)				!try .c
	fi
elsif eqstring(fileext,"dll") then
	return (colonseen|pm_extra|pm_libfile)
fi
return (colonseen|pm_extra|pm_sourcefile)
end

function readnextfileitem(ichar &fileptr,&item)int=
ref char p,pstart,pend
int n
static [256]char str

p:=fileptr

reenter::
do
	case p^
	when ' ','\t',13,10 then	!skip white space
		++p
	when 26,0 then				!eof
		return 0
	else
		exit
	esac
od

case p^
when '!', '#' then			!comment
	++p
	docase p++^
	when 10 then
		goto reenter
	when 26,0 then
		fileptr:=p-1
		return 0
	else

	enddocase
esac


case p^
when '"' then				!read until closing "
	pstart:=++p
	do
		case p^
		when 0,26 then
			println "Unexpected EOF in @file"
			stop 8
		when '"' then
			pend:=p++
			if p^=',' then ++p fi
			exit
		esac
		++p
	od
else
	pstart:=p
	do
		case p^
		when 0,26 then
			pend:=p
			exit
		when ' ','\t',',',13,10 then
			pend:=p++
			exit
		esac
		++p
	od
esac

n:=pend-pstart
if n>=str.len then
	println "@file item too long"
	stop 9
fi
memcpy(&.str,pstart,n)
str[n+1]:=0
item:=&.str
fileptr:=p

return 1
end

global proc ipadstr(ref char s,int width,ref char padchar=" ")=
int n

n:=strlen(s)
to width-n do
	strcat(s,padchar)
od
end

global function padstr(ref char s,int width,ref char padchar=" ")ichar=
static [256]char str

strcpy(&.str,s)
ipadstr(&.str,width,padchar)
return &.str
end

global function chr(int c)ichar=
static [8]char str

str[1]:=c
str[2]:=0
return &.str
end

global function cmpstring(ichar s,t)int=
	int res
	if (res:=strcmp(s,t))<0 then
		return -1
	elsif res>0 then
		return 1
	else
		return 0
	fi
end

global function cmpstringn(ichar s,t,int n)int=
	int res
	if (res:=strncmp(s,t,n))<0 then
		return -1
	elsif res>0 then
		return 1
	else
		return 0
	fi
end

global function eqstring(ichar s,t)int=
	return strcmp(s,t)=0
end

global function cmpbytes(ref void p,q,int n)int=
	int res
	if (res:=memcmp(p,q,n))<0 then
		return -1
	elsif res>0 then
		return 1
	else
		return 0
	fi
end

global function eqbytes(ref void p,q,int n)int=
	return memcmp(p,q,n)=0
end

global proc mseed(word64 a,b=0)=
seed[1]:=a
if b then
	seed[2]:=b
else
	seed[2] ixor:=a
fi
end

global function mrandom:word =
!return pure 64-bit word value, 0 to 2**64-1
!(cast result for signed value)
	word64 x,y
	x:=seed[1]
	y:=seed[2]
	seed[1]:=y
	x ixor:=(x<<23)
	seed[2]:= x ixor y ixor (x>>17) ixor (y>>26)
	return seed[2]+y
end

global function mrandomp:int =
!pure 64-bit int value, positive only, 0 to 2**63-1
	return mrandom() iand 0x7FFF'FFFF'FFFF'FFFF
end

global function mrandomint(int n)int=
!positive random int value from 0 to n-1
	return mrandomp() rem n
end

global function mrandomrange(int a,b)int=
!random int value from a to b inclusive
!span extent must be 1 to 2**63-1
	int span
	span:=b-a+1
	if span<=0 then
		return 0
	fi
	return (mrandomp() rem span)+a
end

global function mrandomreal:real x=
!positive random real value from 0 to just under (but not including) 1.0
	repeat x:=mrandomp()/9223372036854775808.0 until x<>1.0
	return x
end

global function mrandomreal1:real=
!positive random real value from 0 to 1.0 inclusive
	return mrandomp()/9223372036854775807
end

global function checkpackfile:ref byte=
!find out if this executable contains extra packed files
!return 1 or 0

int a,offset,i,size
[100]char name
[300]char exefile
ref byte packexeptr			!for embedded pack files, contains pointer to in-memory version of this .exe file plus extras; else nil
int packexesize				!byte size
ref char packfilename
int packfilesize
ref byte packfileptr

!macro getfileint(data,offset)=(ref int32(data+offset))^
macro getfileint(data,offset)=cast(data+offset,ref int32)^

strcpy(&exefile[1],os_gethostname())
println "Attempting to open",&exefile
packexeptr:=readfile(&exefile[1])

if not packexeptr then
	cpl "Can't open",&exefile,&packexeptr
	stop
fi

packexesize:=rfsize
cpl "File read OK. Size",packexesize

a:=getfileint(packexeptr,packexesize-int32.bytes)
if a<>'PCAK' then
	free(packexeptr)
	packfileptr:=nil
	return nil
fi

offset:=getfileint(packexeptr,packexesize-int32.bytes*2)

packfilename:=cast(packexeptr+offset)
offset+:=strlen(packfilename)+1
packfilesize:=getfileint(packexeptr,offset)
packfileptr:=packexeptr+offset+int32.bytes

return packfileptr
end

global function pcm_allocx:ref void =
const n=32
ref word p

allocbytes:=32

if p:=ref word(freelist[2]) then		!Items of this block size available
	freelist[2]:=ref wordp(int((freelist[2])^))

else

!No items in freelists: allocate new space in this heap block
	p:=cast(pcheapptr)				!Create item at start of remaining pool in heap block
	pcheapptr+:=32			!Shrink remaining pool

	if pcheapptr>=pcheapend then		!Overflows?
		p:=pcm_newblock(32)		!Create new heap block, and allocate from start of that
	fi

	p^:=0
	(p+1)^:=0
	(p+2)^:=0
	(p+3)^:=0

	return p
fi
end

global function readline:ichar=
	readln
	return rd_buffer
end

global function stralloc(ref void p)ichar=
	return strint(int(ref byte(p)-allocbase))
end
=== mwindows.m 7/77 ===
import clib
import mlib

const wm_destroy=2

type wt_word	= word16
type wt_wordpm	= word32
type wt_bool	= word32
type wt_dword	= word32
type wt_wchar	= word16
type wt_wcharpm	= word32
type wt_char	= byte
type wt_ichar	= ref char
type wt_ptr		= ref void
type wt_wndproc	= ref proc
type wt_handle	= ref void
type wt_int		= int32
type wt_uint	= word32
type wt_long	= int32
type wt_wparam	= wordm
type wt_lparam	= wordm
type wt_point	= rpoint

global record rsystemtime =
	wt_word year
	wt_word month
	wt_word dayofweek
	wt_word day
	wt_word hour
	wt_word minute
	wt_word second
	wt_word milliseconds
end

importdll $windowsdlls=
!	windows function "VirtualAlloc"(wt_ptr, dint,wt_dword,wt_dword)wt_ptr
	windows function "GetStdHandle"(wt_dword)wt_handle
	windows function "GetConsoleScreenBufferInfo"(wt_handle,wt_ptr)int
	windows function "SetConsoleCtrlHandler"(wt_wndproc,int)int
	windows function "SetConsoleMode"(wt_handle,wt_dword)int
	windows function "CreateProcessA"(wt_ichar,wt_ichar,wt_ptr,wt_ptr, int,
						wt_dword, wt_ptr,wt_ichar,wt_ptr,wt_ptr)int
	windows function "GetLastError":wt_dword
	windows function "WaitForSingleObject"(wt_handle,wt_dword)wt_dword
	windows function "GetExitCodeProcess"(wt_handle,wt_ptr)int
	windows function "CloseHandle"(wt_handle)int
	windows function "GetNumberOfConsoleInputEvents"(wt_handle,wt_ptr)int
	windows function "FlushConsoleInputBuffer"(wt_handle)int
	windows function "LoadLibraryA"(wt_ichar)wt_handle
!	windows function "GetProcAddress"(wt_handle,wt_ichar)wt_wndproc
	windows function "GetProcAddress"(wt_handle,wt_ichar)ref void
	windows function "LoadCursorA"(wt_handle,wt_ichar)wt_handle
	windows function "RegisterClassExA"(wt_ptr)wt_wordpm
	windows function "DefWindowProcA"(wt_handle,wt_uint,wt_wparam,wt_lparam)intm
	windows function "ReadConsoleInputA"(wt_handle,wt_ptr,wt_dword,wt_ptr)int
	windows proc     "Sleep"(wt_dword)
	windows function "GetModuleFileNameA"(wt_handle,wt_ichar,wt_dword)wt_dword

	windows proc     "ExitProcess"(wt_uint)
	windows proc	 "PostQuitMessage"(wt_int)

!	windows proc	 "MessageBoxA"(wt_int,wt_ichar,wt_ichar,wt_int)

	windows proc	 "MessageBoxA"(wt_int x=0,wt_ichar message, caption="Caption",wt_int y=0)

	windows function "QueryPerformanceCounter"(ref int64)wt_bool
	windows function "QueryPerformanceFrequency"(ref int64)wt_bool

	windows function "CreateFileA"(wt_ichar,wt_dword,wt_dword,wt_ptr,wt_dword,wt_dword,wt_handle)wt_handle
	windows function "GetFileTime"(wt_handle,wt_ptr,wt_ptr,wt_ptr)wt_bool

	windows proc     "GetSystemTime"(ref rsystemtime)
	windows proc     "GetLocalTime"(ref rsystemtime)

	windows function "GetTickCount":wt_dword
	windows function "PeekMessageA"		(ref void, ref wt_handle, wt_uint,wt_uint,wt_uint)wt_bool

end

record input_record = $caligned
	wt_word	eventtype
!	word16	padding
		wt_bool	keydown			!key event record (was inside 'Event' union in win32)
		wt_word	repeatcount
		wt_word	virtualkeycode
		wt_word	virtualscancode
		union
			wt_word unicodechar
			wt_char asciichar
		end
		wt_dword controlkeystate
end

record rspoint=(int16 x,y)

record rsrect=
	int16 leftx,top,rightx,bottom
end

global record rpoint =
	wt_long x,y
end

record rconsole=
	rspoint size,pos
	word16 attributes
	rsrect window
	rspoint maxwindowsize
end

record rstartupinfo =
	wt_dword	size
!.if $64bit
	word32 dummy1
!.endif
	wt_ichar	reserved
	wt_ichar	desktop
	wt_ichar	title
	wt_dword	x
	wt_dword	y
	wt_dword	xsize
	wt_dword	ysize
	wt_dword	xcountchars
	wt_dword	ycountchars
	wt_dword	fillattribute
	wt_dword	flags
	wt_word		showwindow
	wt_word		reserved2
!.if $64bit
	word32 dummy2
!.endif
	wt_ptr		reserved4
	wt_handle	stdinput
	wt_handle	stdoutput
	wt_handle	stderror
end

record rprocess_information =
	wt_handle process
	wt_handle thread
	wt_dword processid
	wt_dword threadid
end

record rwndclassex =
	wt_uint		size
	wt_uint		style
	wt_wndproc	wndproc
	wt_int		clsextra
	wt_int		wndextra
	wt_handle	instance
	wt_handle	icon
	wt_handle	cursor
!	wt_handle	background
	wt_handle	background
	wt_ichar	menuname
	wt_ichar	classname
	wt_handle	iconsm
end

global record rmsg =
	wt_handle	hwnd
	wt_uint		message
!.if $64bit
	word32		dummy1
!.endif
	wt_wparam	wParam
	wt_lparam	lParam
	wt_dword	time
!.if $64bit
	word32		dummy2
!.endif
	wt_point	pt
end

!wt_word x
const NORMAL_PRIORITY_CLASS=32
const CREATE_NEW_CONSOLE=16
const DETACHED_PROCESS=16

wt_handle hconsole, hconsolein

input_record lastkey, pendkey
int keypending			!whether pendkey contains a new key event detected by flushkbd

ref function(ref void)int wndproc_callbackfn=nil	!windows call-back: address of handler

int init_flag=0

global proc os_init=
int i,count
rconsole info

!general initialisation
hconsole:=GetStdHandle(u32(-11))
hconsolein:=GetStdHandle(u32(-10))

lastkey.repeatcount:=0
keypending:=0

!CPL "OSINIT"
SetConsoleCtrlHandler(nil,1)

SetConsoleMode(hconsole,1 ior 2)
!SetConsoleMode(hconsole,1 )

init_flag:=1

end

global function os_execwait(ichar cmdline,int newconsole=0,ichar workdir=nil)int =
wt_dword exitcode
int status
int cflags:=0

rstartupinfo si
rprocess_information xpi

!memset(&si,0,si.bytes)
!memset(&xpi,0,xpi.bytes)
clear si
clear xpi

switch newconsole
when 0 then cflags := NORMAL_PRIORITY_CLASS
when 1 then cflags := NORMAL_PRIORITY_CLASS ior CREATE_NEW_CONSOLE
when 2 then cflags := NORMAL_PRIORITY_CLASS ior DETACHED_PROCESS
endswitch

si.size := rstartupinfo.bytes

!CPL "NEWEXECWAIT",CMDLINE
status:=CreateProcessA(
	nil,
	cmdline,
	nil,

	nil,
	1,
	cflags,

	nil,
	nil,
	&si,
	&xpi )

if status=0 then		!fails
	status:=GetLastError()
	println "Winexec error:",status
	return -1
end

WaitForSingleObject(xpi.process, 0xFFFF'FFFF)
GetExitCodeProcess(xpi.process,&exitcode)

CloseHandle(xpi.process)
CloseHandle(xpi.thread)

return exitcode
end

global function os_execcmd(ichar cmdline, int newconsole=0)int =
wt_dword exitcode
int i,j,k

rstartupinfo si
rprocess_information xpi

!memset(&si,0,si.bytes)
!memset(&xpi,0,xpi.bytes)
clear si
clear xpi

si.size := rstartupinfo.bytes

CreateProcessA( nil,
	cmdline,
	nil,
	nil,
	1,
	NORMAL_PRIORITY_CLASS ior (newconsole|CREATE_NEW_CONSOLE|0),
	nil,
	nil,
	&si,
	&xpi )

CloseHandle(xpi.process)
CloseHandle(xpi.thread)

return 1
end

global function os_getch:int=
int k

k:=os_getchx() iand 255

return k
end

global function os_kbhit:int=
wt_dword count
!os_init() unless init_flag

unless init_flag then os_init() end
!unless initflag then: os_init()

GetNumberOfConsoleInputEvents(hconsolein,&count)
return count>1
end

global proc os_flushkeys=
FlushConsoleInputBuffer(hconsolein)
end

global function os_getconsolein:ref void=
return ref void(hconsolein)
end

global function os_getconsoleout:ref void=
return ref void(hconsole)
end

global function os_proginstance:ref void=
abortprogram("PROGINST")
return nil
end

global function os_getdllinst(ichar name)u64=
wt_handle hinst

hinst:=LoadLibraryA(name)
!CPL =HINST
return cast(hinst)
end

global function os_getdllprocaddr(int hinst,ichar name)ref void=
!CPL "GETPROCADDR:",HINST,NAME

return GetProcAddress(cast(int(hinst)),name)
!REF VOID P
!
!P:=GetProcAddress(cast(int(hinst)),name)
!CPL =P
!CPL =getlasterror()
!return P
end

global proc os_initwindows=
os_init()
!CPL "INITWIND"
os_gxregisterclass("pcc001")
end

global proc os_gxregisterclass(ichar classname)=
const idcarrow=32512
rwndclassex r
static byte registered

if registered then
	return
fi

!CPL "REG CLASS"

!memset(&r,0,r.bytes)
clear r

r.size:=r.bytes
r.style:=8 ior 32		!CS_DBLCLKS | CS_OWNDC
r.wndproc:=cast(&mainwndproc)
!r.wndproc:=&xmainwndproc
!r.wndproc:=&cmainwndproc
r.instance:=nil

r.icon:=nil		!loadicon(proginstance,"SCW32")
r.cursor:=LoadCursorA(nil,ref void(idcarrow))		!IDC_ARROW)
r.background:=cast(15+1)					!COLOR_BTNFACE+1
r.menuname:=nil
r.classname:=classname
r.iconsm:=nil	!loadicon(proginstance,"SCW32")

if RegisterClassExA(&r)=0 then
	println classname,GetLastError
	abortprogram("Registerclass error")
end
registered:=1
end

global callback function mainwndproc (
		wt_handle hwnd, wt_uint message, wt_wparam wParam, wt_lparam lParam)intm=
rmsg m
int i,result
intm l
static int count=0

CPL "MAINWND/BB",MESSAGE

m.hwnd:=hwnd
m.message:=message
m.wParam:=wParam
m.lParam:=lParam
m.pt.x:=0
m.pt.y:=0

!CPL "BEFORE CALL",=HWND,=MESSAGE,=WPARAM,=REF VOID(LPARAM)
if (wndproc_callbackfn) then
	result:=(wndproc_callbackfn^)(&m)
else
	result:=0
fi

!CPL "AFTER CALL",=HWND,=MESSAGE,=WPARAM,=REF VOID(LPARAM)
if m.message=wm_destroy then
	return 0
fi

if not result then
	return DefWindowProcA(hwnd,message,wParam,lParam)
else
	return 0
fi
end

!callback proc timerproc(wt_handle hwnd, int msg, id, time)=
proc timerproc(wt_handle hwnd, int msg, id, time)=
println "TIMERPROC"
end

GLOBAL PROC OS_TESTCALLBACK(ref void p)=



	IF WNDPROC_CALLBACKFN THEN
		(WNDPROC_CALLBACKFN)(P)
	ELSE
		ABORTPROGRAM("MESS HANDLER NOT DEFINED")
	FI

END

global proc os_setmesshandler(ref void addr)=
wndproc_callbackfn:=addr
end

global function os_getchx:int=
!Q! function os_getchx_c:int
!return a 32-bit value containing:
! 15..B0:	char code
! 23..16	virtual keycode
! 31..24	shift flags (.[24]=shift, .[25]=ctrl, .[26]=alt, .[27]=capslock)
const rightaltmask	= 1
const leftaltmask	= 2
const leftctrlmask	= 8
const rightctrlmask	= 4
const shiftmask		= 16
const capsmask		= 128
const scrollmask	= 64
int count
int charcode,keyshift,keycode
int altdown,ctrldown,shiftdown,capslock

!os_init() unless init_flag
unless init_flag then os_init() end

if keypending then
	lastkey:=pendkey
	keypending:=0
else
	if lastkey.repeatcount=0 then
		repeat
			count:=0
			ReadConsoleInputA(hconsolein,&lastkey,1,&count)
		until (lastkey.eventtype=1 and lastkey.keydown=1)
	fi
fi

!set shift flags

altdown		:= ((lastkey.controlkeystate iand (leftaltmask ior rightaltmask))|1|0)
ctrldown	:= ((lastkey.controlkeystate iand (leftctrlmask ior rightctrlmask))|1|0)
shiftdown	:= ((lastkey.controlkeystate iand shiftmask)|1|0)
capslock	:= ((lastkey.controlkeystate iand capsmask)|1|0)

--lastkey.repeatcount		!count this key out

charcode:=lastkey.asciichar
keycode:=lastkey.virtualkeycode iand 255

if charcode<0 then
	if charcode<-128 then
		charcode:=0
	else
		charcode+:=256
	fi
fi

!CPL "CHARCODE2=%d %X\n",charcode,charcode
!for keycodes in range 186 to 223, which are all stand-alone punctuation keys, I might
!wish to set charcode to the appropriate printed char code (currently charcode will be
!zero, and keyboard handlers need to detect keycodes such as vkequals)
!....

if altdown and ctrldown and charcode=166 then
	altdown:=ctrldown:=0
else
	if altdown or ctrldown then
		charcode:=0
		if keycode>='A' and keycode<= 'Z' then
			charcode:=keycode-'@'
		fi
	fi
fi

keyshift:=capslock<<3 ior altdown<<2 ior ctrldown<<1 ior shiftdown

return keyshift<<24 ior keycode<<16 ior charcode
end

global function os_getos=>ichar=
if $targetbits=32 then
	return "W32"
else
	return "W64"
fi
end

global function os_gethostsize=>int=
return $targetbits
end

global function os_shellexec(ichar opc, file)int=
return system(file)
end

global proc  os_sleep(int a)=
Sleep(a)
end

global function os_getstdin:filehandle =
return fopen("con","rb")
end

global function os_getstdout:filehandle =
return fopen("con","wb")
end

global function os_gethostname:ichar=
static [300]char name
static int n

GetModuleFileNameA(nil,&.name,name.bytes)
strcat(&.name,"/")
return &.name
end

global function os_getmpath:ichar=
return F"C:\m\"
end

global proc os_exitprocess(int x)=
stop x
!ExitProcess(x)
end

global function os_clock:int64=
return clock()
end

global function os_getclockspersec:int64=
return 1000
end

global function os_iswindows:int=
return 1
end

global function os_filelastwritetime(ichar filename)int64=
wt_handle f;
int64 ctime,atime,wtime;

if filename=nil then				!used to test whether supported
	return 1
fi

f:=CreateFileA(filename,0x80000000,1,nil, 3,3,nil);
if int64(f)=-1 then
	return 0
fi

GetFileTime(f,&ctime,&atime,&wtime);
CloseHandle(f);

return wtime;
end

global proc os_getsystime(ref rsystemtime tm)=
GetLocalTime(tm)
end

global proc os_messagebox(ichar s,t)=
messageboxa(0,s,t,0)
end

global function os_hpcounter:int64=
int64 a

queryperformancecounter(&a)
return a

end

global function os_hpfrequency:int64=
int64 a

queryperformancefrequency(&a)
return a

end

global proc os_peek=
int ticks
static int lastticks
[100]byte m
	ticks:=GetTickCount()
	if ticks-lastticks>=1000 then
		lastticks:=ticks
		PeekMessageA(&m,nil,0,0,0)
	fi
end
=== cc_decls.m 8/77 ===
import clib
import cc_tables

global type unit = ref unitrec

global const maxmodule=200
global const maxlibfile=200
global const maxsourcefile=600

global record tokenrec = 		!should be 32-byte record
	union
		int64 value				!64-bit int
		real xvalue				!64-bit float
		word64 uvalue			!64-bit word
		ref char svalue			!pointer to string or charconst (not terminated)
		ref strec symptr		!pointer to symbol table entry for name
	end
	ref tokenrec nexttoken

	union
		struct
			byte subcode
			byte flags
		end
		word16 subcodex
	end
	byte symbol
	byte fileno

	word32 lineno

	int32 length					!length of name/string/char
	union
		int32 numberoffset		!offset of numeric token within file[fileno]
		int16 paramno				!for macro params
		int16 pasteno
	end
end

global record mparamrec =
	ref strec def
	ref mparamrec nextmparam
end

global record caserec =
	ref caserec nextcase
	int value
end

!param lists always have at least one 'parameter':
! ()				nparams=0	flags=pm_notset		mode=tnone
! (void)			nparams=0	flags=pm_empty		mode=tnone
! (...)				nparams=0	flags=pm_variadic	mode=tnone
! (t,u,v)			nparams=3	flags=0				mode=t (on 1st param)
! (t,u,v,...)		nparams=3	flags=pm_variadic	mode=t (on 1st param)

global record paramrec =
	ref strec def			!named param: st entry, otherwise nil
	ref paramrec nextparam
	int32 mode				!tnone when there are no normal params
	int16 nparams			!used on first param only
	int16 flags				!used on first param only
end

!mask bits for .flags of tokenrec; these can be combined if both are true
global const tk_macromask = 1		!is a name that is a macro def
global const tk_parammask = 2		!is a name that is a param def
global const tk_macrolit  = 4		!is an processed token that is a macro name
global const tk_pasted    = 8

global record attribrec =		!keep this 16 bytes
	byte ax_static				!0 or 1
	byte ax_equals					!0 or 1 if = used (static/frame vars only)
	byte ax_varparams				!0 or 1	
	byte ax_used				!0 or 1	
	byte ax_forward				!0 or 1: 1 means forward decl of label or function
	byte ax_frame				!0 or 1: 1 when frameid/paramid
	byte ax_autovar				!0 or 1: 1 when an autovar with "$" in the name
	byte ax_nparams				!no. formal params for procid/dllprocid

	byte ax_callback			!1 when proc is is a callback function
	byte ax_moduleno
	byte ax_loop				!1 if a loop label
	union
		byte ax_align				!1, 2, 4, 8; max align for struct/union
		byte ax_dllindex		!for dllproc: which dll in dlltable
		byte ax_extmodno		!for proc call chains: module no of proc owner
		byte ax_flmacro			!function-like macro; used when no params
	end
end

global record fieldrec = 			!linear list of fields/anon fields in a struct
	ref strec def
	ref strec gendef				!generic version of def
	ref fieldrec nextfield			!list may be created in reverse order
	int offset						!offset from start of struct
end

global record strec =
	ichar name
	ref strec owner
	ref strec deflist
	ref strec deflistx
	ref strec nextdef
	ref strec nextdupl
	ref strec prevdupl
	union
		ref void mclcode
		ref void opnd
	end

	union
		ref paramrec nextparam
		ref unitrec callchain
		ref strec nextmacro
		ref fieldrec nextfield
	end
	union
		ref unitrec code
		ref tokenrec tokenlist
	end
	union
!		ref strec paramlist
		ref paramrec paramlist
		ref mparamrec mparamlist
		ichar macrovalue
	end
	union
		ref void address
		int offset
		byte oldsymbol				!for #define/#undef on keyword
	end

	word32 lineno
	int32 index					!enum/label index
	union
		struct
			word16 blockno
			word16 namespace				!experimental: set to namespaces[.nameid]
		end
		word32 nsblock						!combined block no and namespace
	end
	int16 subcode
	int16 mode

	byte namelen
	byte symbol
	byte nameid
	byte scope		!linkage type

	attribrec attribs
end

global record unitrec =
	union
		ref strec def
		int64 value
		word64 uvalue
		real xvalue
		ichar svalue
		ref word16 wsvalue
		ref strec labeldef
		ref caserec nextcase
		int32 ptrscale			!use for derefoffset/addoffset
		int32 offset				!for j_dot
	end
	ref unitrec nextunit
	ref unitrec a	!single items, or linked lists
	ref unitrec b
	ref unitrec c

	int32 tag			!kcode tag number
	word32 lineno			!source lineno associated with item; fileno is in top byte

	union
		int32 opcode			!for conversion
		int32 index				!label index
		word32 uindex			!case index
		int32 slength			!for const/string
		int32 wslength
		int32 alength			!for deref units, length of any array before conversion to ptr
		int32 scale			!for scale unit (negative means divide)
		int32 aparams			!callfn/proc: no. actual params
		int32 count			!makelist, no. items
	end

	int32 mode
	byte simple
	byte fileno
	union
		byte callconv			!calling convention code for callfn/callproc, +128 if variadic
		byte convmem			!0, or 1 if conversion source is in memory
		byte isstrconst			!for string consts: initialised with "..."
	end
	union
		byte strarray			!for string consts: when idata type is char[] rather than char*
		byte convtomem			!0, or 1 if conversion result is to be stored to memory
	end
	byte iswstrconst
	byte spare1
	word16 spare2
!	word16 memtype
!	word32 spare4
end

global record modulerec =
	ichar name
	ref strec stmodule
	int fileno
	ichar asmstr
	ichar mhdrstr
	[maxmodule]byte importmap
end

global record dllprocrec =
	ichar name
	ref proc address
	int dllindex
end

global record procrec =
	ref strec def
	ref procrec nextproc
end
!
!global const int maxtype=10'000
global const int maxtype=20'000

global int ntypes
global int ntypesreset

!global [0:maxtype]ichar	ttname
global [0:maxtype]ref strec	ttnamedef
global [0:maxtype]int	ttbasetype			!basic t-code
global [0:maxtype]int	ttlength			!0, or array length
global [0:maxtype]byte	ttconst				!1 when const
global [0:maxtype]byte	ttrestrict			!1 when restrict used
global [0:maxtype]byte	ttvolatile			!1 when volatile used
global [0:maxtype]int	ttusertype			!0, or index of struct/union/enum type
global [0:maxtype]int	tttarget			!pointer target or array elem type
global [0:maxtype]int	ttreftype			!0, or index of type that is a pointer to this one
global [0:maxtype]int	ttconsttype			!0, or index of type that is a const version of this oneointer to this onee
global [0:maxtype]int	ttsize				!byte size
global [0:maxtype]int	ttbitwidth			!bit in basic type (not arrays/structs)
global [0:maxtype]byte	ttisref
global [0:maxtype]ref paramrec ttparams		!for modes involving function pointers
global [0:maxtype]ref strec tttypedef

global int trefchar							!set to to char* type
global int trefwchar						!set to to wchar* type

global [0..maxmodule]modulerec moduletable
global [0..maxmodule]ichar inputfiles
global [0..maxlibfile]ichar libfiles
global [0..maxsourcefile]ichar sourcefilenames
global [0..maxsourcefile]ichar sourcefilepaths
global [0..maxsourcefile]ichar sourcefiletext
global [0..maxsourcefile]int32 sourcefilesizes

global [0..maxmodule]ichar automodulenames		!auto modules
global int nmodules
global int nautomodules
global int nsourcefiles
global int ninputfiles
global int nlibfiles

global int currmoduleno				!used when compiling modules
global ref modulerec currmodule

global const maxsearchdirs=20
global const maxincludepaths=20

global [maxsearchdirs]ichar searchdirs
global int nsearchdirs=0
global [maxincludepaths]ichar includepaths
global int nincludepaths=0

global ref strec stprogram		!root into the symbol table
global ref strec stmodule		!main module

global filehandle logdev		!dest for diagnostics and output of tables
global int logdest=0
global int optflag=0			!1=stdoptimise; 0=disabled

global const sourceext="c"
global ref unitrec nullunit

global int fverbose=0		!whether to display message for each pass
global int fquiet=0
global int fshownames=0		!whether [dframe-8] or [dframe+a]
!global int fshownames=1		!whether [dframe-8] or [dframe+a]
global int fshowincludes=0
global int fautomodules=0

global int fmodern=1

global int foptimise=0		!whether to generate optimised j-codes

global int wintarget=1		!one of these three is true
global int lintarget=0
global int nostarget=0
global int clineno=0		!set in codegen scanner

global int fastasm=0		!1 to pass asm source via memory
global int fcallback=0		!1 to make all functions callbacks
global int flinesplicing=0	!1 to deal with \ line continuations
!global ichar assemsource=nil
!global [maxmodule]ichar assemsources

global tokenrec lx				!provides access to current token data
global tokenrec nextlx

!global int tlex=0		!timing

global int debug=0

global int hstsize	= 16384

global int hstmask				!filled in with hstsize-1

global ref[0:]ref strec hashtable

global const maxblock=2100,maxblockstack=100
global [0..maxblock]int32 blockowner
global [0..maxblock]int32 blockcounts
global [0..maxblockstack]int32 blockstack
global int currblockno,nextblockno,blocklevel
global ref strec currproc

global int labelno=0
global const maxnestedloops=64

global int dointheaders=1				!allow internal std headers
global ichar dheaderfile=nil			!result of -d:file.h switch

global int structpadding=1
global int callbackflag=0

global int slineno,sfileno

global ichar oemname="BCC"

GLOBAL INT NLOOKUPS
GLOBAL INT NCLASHES
GLOBAL INT NMIXED
GLOBAL INT NALLPROCS
=== cc_tables.m 9/77 ===
global tabledata() [0:]ichar stdtypenames, [0:]byte stdtypewidths,
		 [0:]byte stdtypesigned, [0:]byte stdexpandtypes,
		 [0:]byte stdtypecat, [0:]ichar stdtypemnames =
	(tnone=0,		"none",		0,	0,	0,		0,		""),		!error or not set or not used
	(tvoid,			"void",		0,	0,	0,		0,		"void"),

	(tschar,		"schar",	8,	1,	tsint,	'I',	"i8"),		! This ordering is important
	(tsshort,		"short",	16,	1,	tsint,	'I',	"i16"),	!
	(tsint,			"int",		32,	1,	0,		'I',	"i32"),	!
	(tsllong,		"llong",	64,	1,	0,		'I',	"i64"),	!

	(tbool,			"bool",		8,	0,	tuint,	'U',	"byte"),		! As is this
	(tuchar,		"uchar",	8,	0,	tuint,	'U',	"byte"),		!
	(tushort,		"ushort",	16,	0,	tuint,	'U',	"u16"),	!
	(tuint,			"uint",		32,	0,	0,		'U',	"u32"),	!
	(tullong,		"ullong",	64,	0,	0,		'U',	"u64"),	!

	(tfloat,		"float",	32,	0,	0,		'R',	"r32"),	! And tfloat must be >= integer types
	(tdouble,		"double",	64,	0,	0,		'R',	"r64"),	!
	(tldouble,		"ldouble",	128,0,	0,		'R',	"r64"),	!

	(tcomplex,		"complex",	128,0,	0,		0,		""),	!

	(tenum,			"enum",		0,	0,	0,		0,		""),		!
	(tref,			"ref",		64,	0,	0,		0,		""),	! 
	(tproc,			"proc",		64,	0,	0,		0,		""),	!
	(tlabel,		"label",	64,	0,	0,		0,		""),	!

	(tarray,		"array",	0,	0,	0,		0,		""),		!
	(tstruct,		"struct",	0,	0,	0,		0,		""),		!
	(tunion,		"union",	0,	0,	0,		0,		""),		!

!User-defined types go here
	(tlast,			$,			0,	0,	0,		0,		"")		! 	!

end

global const tfirstnum=tschar, tlastnum=tldouble
global const tfirstint=tschar, tlastint=tullong
global const tfirstreal=tfloat, tlastreal=tldouble

global const tptroffset = tsllong		!for 64-bit target

global tabledata() []ichar typespecnames, []int32 typespectypes, []byte typespecsizes =
	(ts_void,		$,	tvoid,		0),
!	(ts_char,		$,	tuchar,		1),
	(ts_char,		$,	tschar,		1),
	(ts_short,		$,	0,			2),
	(ts_long,		$,	0,			4),
	(ts_int,		$,	tsint,		4),
	(ts_float,		$,	tfloat,		4),
	(ts_double,		$,	tdouble,	8),
	(ts_signed,		$,	0,			0),
	(ts_unsigned,	$,	0,			0),
	(ts_bool,		$,	tbool,		1),
	(ts_complex,	$,	tcomplex,	0),
	(ts_user,		$,	0,			0),
	(ts_struct,		$,	0,			0),
	(ts_union,		$,	0,			0),
	(ts_enum,		$,	0,			4),
	(ts_atomic,		$,	0,			0)
end

global tabledata() [0:]ichar pmflagnames=
	(pm_normal=0,		$),		! Normal param
	(pm_notset,			$),		! ()     (applied to one dummy tnone param)
	(pm_empty,			$),		! (void) (applied to one dummy tnone param)
	(pm_variadic,		$)		! (...) or (t,u,v,...) (applied to dummy or first param)
end

!scope here refers to linkage across modules
global tabledata() [0:]ichar scopenames=
	(no_scope=0,		"-"),		! 
	(function_scope,	"Fn"),		!within a function (note import/exported names can be declared in a block scope)
	(local_scope,		"Loc"),		!file-scope/not exported 
	(imported_scope,	"Imp"),		!imported from another module
	(exported_scope,	"Exp")		!file-scope/exported
end

!Call conventions
global tabledata() []ichar ccnames=

	(open_cc=0,		$), ! Not set: either own or clang, depending on whether fn was defined
	(own_cc,		$), ! Internal (x86/x64)
	(clang_cc,		$), ! External (all x64; clang only x86)
	(stdcall_cc,	$), ! (x86 non-clang)
	(callback_cc,	$), ! Internal when called from External

	(dummy_cc,		$)	! 
end

global tabledata() [0:]ichar linkagenames=
	(none_ss=0,		$),
	(static_ss,		$),
	(auto_ss,		$),
	(register_ss,	$),
	(extern_ss,		$),
	(typedef_ss,	$)
end

global tabledata() []ichar typequalnames=
	(const_qual,	$),
	(volatile_qual,	$),
	(restrict_qual,	$),
	(atomic_qual,	$)
end

global tabledata() []ichar fnspecnames=
	(inline_fnspec,		$),
	(noreturn_fnspec,	$),
	(callback_fnspec,	$),
end

global tabledata() =
	(pdm_date),
	(pdm_time),
	(pdm_file),
	(pdm_line),
	(pdm_func),
	(pdm_cdecl),
	(pdm_bcc),
	(pdm_stdc)
end

global tabledata() [0:]ichar jtagnames=

	(j_none=0,		$), !
	(j_const,		$), !
	(j_null,		$), !
	(j_name,		$), !
!	(j_nameaddr,	$), !
	(j_widenmem,	$), !
	(j_funcname,	$), !
	(j_block,		$), !
	(j_tempdecl,	$), !
	(j_decl,		$), !
!	(j_typeof,		$), !
!	(j_makeref,		$), !

!Statements

	(j_callproc,	$), ! 
	(j_return,		$), ! 
	(j_returnx,		$), ! 

	(j_assign,		$), ! 
	(j_if,			$), ! 
	(j_for,			$), ! 
	(j_while,		$), ! 
	(j_dowhile,		$), ! 
	(j_goto,		$), ! 
	(j_labelstmt,	$), ! 
	(j_casestmt,	$), ! 
	(j_defaultstmt,	$), ! 
	(j_break,		$), ! [
	(j_continue,	$), ! [
	(j_switch,		$), ! 
	(j_breaksw,		$), ! [
!	(j_eval,		$), ! 

!Expressions and Operators

!Logical Operators

	(j_andl,		"&& andl"), ! 
	(j_orl,			"|| orl"), ! 
	(j_notl,		"! notl"), ! 
	(j_istruel,		$), ! 

!Expressions and Operators

	(j_makelist,	$), ! 
	(j_exprlist,	$), ! 

!	(j_assignx,		$), ! 
	(j_callfn,		$), ! 
	(j_ifx,			$), ! 

!Binary Ops

	(j_andand,		"&&"), ! a 

	(j_eq,			"=="), ! a 
	(j_ne,			"!="), ! a 
	(j_lt,			"<"), ! a 
	(j_le,			"<="), ! a 
	(j_gt,			">"), ! a 
	(j_ge,			">="), ! a 

	(j_add,			"+ add"), ! 
	(j_sub,			"- sub"), ! 
	(j_mul,			"* mul"), ! 
	(j_div,			"/ div"), ! 
	(j_rem,			"% mod"), ! 
	(j_iand,		"& iand"), ! 
	(j_ior,			"| ior"), ! 
	(j_ixor,		"^ ixor"), ! 
	(j_shl,			"<<"), ! a 
	(j_shr,			">>"), ! a 

	(j_dot,			$), ! 
	(j_idot,		$), ! 
!	(j_dotref,		$), ! 
	(j_index,		$), ! 

	(j_ptr,			"ptr"), ! 
!	(j_ptroffset,	"ptroffset *"), ! 
	(j_addptr,		"addptr"), ! 
	(j_subptr,		"subptr"), ! 
	(j_addrof,		"addrof &"), ! 
	(j_convert,		$), ! 
	(j_scale,		$), ! 

!Monadic Ops

	(j_neg,			"- neg"), ! 
	(j_abs,			"abs"), ! 
	(j_inot,		"~ inot"), ! a

!In-place operators

	(j_addto,		"+="), ! a b	a+:=b
	(j_subto,		"-="), ! a b
	(j_multo,		"*="), ! a b
	(j_divto,		"/="), ! a b
	(j_remto,		"%="), ! a b
	(j_iandto,		"&="), ! a b
	(j_iorto,		"|="), ! a b
	(j_ixorto,		"^="), ! a b
	(j_shlto,		"<<="), ! a b
	(j_shrto,		">>="), ! a b

	(j_sqrt,		"sqrt"), ! a

	(j_preincr,		"++ preincr"), ! a	++a
	(j_predecr,		"-- preincr"), ! a	--a
	(j_postincr,	"++ postincr"), ! a	a++
	(j_postdecr,	"-- postdecr"), ! a	a--

	(j_cputime,		"cputime"), ! a	a--

	(j_dummy,		$)
end

global tabledata() []ichar symbolnames, []ichar shortsymbolnames, []byte symboltojtag=

!First half are basic tokens returned by lexreadtoken()
	(errorsym,			$,	"",		0),			! Lex error
	(dotsym,			$,	".",	j_dot),		! "."
	(idotsym,			$,	"->",	j_idot),	! "->"
	(lexhashsym,		$,	"#",	0),			! "#" as first symbol on line
	(hashsym,			$,	"#",	0),			! "#" within macro def
	(lithashsym,		$,	"#",	0),			! "#" literal hash (not stringify op)
	(hashhashsym,		$,	"##",	0),			! "##" within macro def
	(commasym,			$,	",",	0),			! ","
	(semisym,			$,	";",	0),			! ";"
	(colonsym,			$,	":",	0),			! ":"
	(assignsym,			$,	"=",	j_assign),	! =
	(assignsym2,		$,	":=",	j_assign),	! =
	(lbracksym,			$,	"(",	0),			! (
	(rbracksym,			$,	")",	0),			! )
	(lsqsym,			$,	"[",	0),			!	 [
	(rsqsym,			$,	"]",	0),			! ]
	(lcurlysym,			$,	"{",	0),			! {
	(rcurlysym,			$,	"}",	0),			! }
	(questionsym,		$,	"?",	0),			! ?
	(curlsym,			$,	"~",	0),			! ~
	(ellipsissym,		$,	"...",	0),			! ...
	(backslashsym,		$,	"\\",	0),			! \
	(addsym,			$,	"+",	j_add),		! +
	(subsym,			$,	"-",	j_sub),		!
	(mulsym,			$,	"*",	j_mul),		!
	(divsym,			$,	"/",	j_div),		!
	(remsym,			$,	"%",	j_rem),		!
	(iorsym,			$,	"|",	j_ior),		!
	(iandsym,			$,	"&",	j_iand),	!
	(ixorsym,			$,	"^",	j_ixor),	!
	(orlsym,			$,	"||",	j_orl),		!
	(andlsym,			$,	"&&",	j_andl),	!
	(shlsym,			$,	"<<",	j_shl),		!
	(shrsym,			$,	">>",	j_shr),		!
	(inotsym,			$,	"~",	j_inot),	!
	(notlsym,			$,	"!",	j_notl),	!
	(incrsym,			$,	"++",	j_preincr),	!
	(decrsym,			$,	"--",	j_predecr),	!
	(abssym,			$,	"abs",	j_abs),		!

	(eqsym,				$,	"==",	j_eq),		!
	(nesym,				$,	"!=",	j_ne),		!
	(ltsym,				$,	"<",	j_lt),		!
	(lesym,				$,	"<=",	j_le),		!
	(gesym,				$,	">=",	j_ge),		!
	(gtsym,				$,	">",	j_gt),		!

	(addtosym,			$,	"+=",	j_addto),	!
	(subtosym,			$,	"-=",	j_subto),	!
	(multosym,			$,	"*=",	j_multo),	!
	(divtosym,			$,	"/=",	j_divto),	!
	(remtosym,			$,	"%=",	j_remto),	!
	(iortosym,			$,	"|=",	j_iorto),	!
	(iandtosym,			$,	"&=",	j_iandto),	!
	(ixortosym,			$,	"^=",	j_ixorto),	!
	(shltosym,			$,	"<<=",	j_shlto),	!
	(shrtosym,			$,	">>=",	j_shrto),	!
	(sqrtsym,			$,	"sqrt",	j_sqrt),	!

	(eolsym,			$,	"",		0),			!
	(eofsym,			$,	"",		0),			!
	(rawnumbersym,		$,	"n",	0),			!
	(intconstsym,		$,	"n",	0),			!
	(realconstsym,		$,	"n",	0),			!
	(charconstsym,		$,	"s",	0),			!
	(wcharconstsym,		$,	"s",	0),			!
	(stringconstsym,	$,	"s",	0),			!
	(wstringconstsym,	$,	"s",	0),			!
	(whitespacesym,		$,	"w",	0),			!
!	(placeholdersym,	$,	"<PH>",	0),			!
	(placeholdersym,	$,	"",	0),			!
	(kstrincludesym,	$,	"k",	0),			!

!Second half are tokens that can be yielded after a name lookup:
	(namesym,			$,	"k",	0),			! identifier symbol
	(ksourcedirsym,		$,	"k",	0),			! 
	(predefmacrosym,	$,	"k",	0),			! __LINE__ etc

	(ktypespecsym,		$,	"k",	0),			! INT, SHORT
	(kifsym,			$,	"k",	0),			! IF
	(kelsesym,			$,	"k",	0),			! ELSE
	(kcasesym,			$,	"k",	0),			! CASE
	(kdefaultsym,		$,	"k",	0),			! DEFAULT
	(kforsym,			$,	"k",	0),			! FOR
	(kwhilesym,			$,	"k",	0),			! WHILE
	(kdosym,			$,	"k",	0),			! DO
	(kreturnsym,		$,	"k",	0),			! RETURN
	(kbreaksym,			$,	"k",	0),			! BREAK
	(kcontinuesym,		$,	"k",	0),			! CONTINUE
	(kgotosym,			$,	"k",	0),			! GO/GOTO
	(kswitchsym,		$,	"k",	0),			! SWITCH
	(kstructsym,		$,	"k",	0),			! STRUCT
	(kunionsym	,		$,	"k",	0),			! UNION
	(klinkagesym,		$,	"k",	0),			! STATIC etc
	(ktypequalsym,		$,	"k",	0),			! CONST etc
	(kfnspecsym,		$,	"k",	0),			! INLINE etc
	(kalignassym,		$,	"k",	0),			! _ALIGNAS
	(kenumsym,			$,	"k",	0),			! ENUM
!	(kcallconvsym,		$,	"k",	0),			! CLANG etc
	(ksizeofsym,		$,	"k",	0),			! SIZEOF
	(klengthofsym,		$,	"k",	0),			! LENGTHOF
	(kdefinedsym,		$,	"k",	0),			! DEFINED
	(kgenericsym,		$,	"k",	0),			! _GENERIC
	(kalignofsym,		$,	"k",	0),			! _ALIGNOF
	(kshowmodesym,		$,	"k",	0),			! SHOWMODE
	(kshowtypesym,		$,	"k",	0),			! SHOWTYPE
	(ktypeofsym,		$,	"k",	0),			! TYPEOF
	(kstrtypesym,		$,	"k",	0),			! STRTYPE
	(kmccassertsym,		$,	"k",	0),			!
	(kcputimesym,		$,	"k",	0),			!
	(kconstantsym,		$,	"k",	0),			!CONSTANT
	(kstructinfosym,	$,	"k",	0),			!STRUCTINFO

	(kdummysym,			$,	"",		0)			!
end

global tabledata() []ichar sourcedirnames =
	(definedir,		$),
	(emitdir,		$),
	(ifdir,			$),
	(elifdir,		$),
	(elsedir,		$),
	(endifdir,		$),
	(includedir,	$),
	(ifdefdir,		$),
	(ifndefdir,		$),
	(undefdir,		$),
	(errordir,		$),
	(warningdir,	$),
	(messagedir,	$),
	(pausedir,		$),
	(debugondir,	$),
	(debugoffdir,	$),
	(showmacrodir,	$),
	(blankdir,		$),
	(linedir,		$),
!	(strincludedir,	$),
	(pragmadir,		$)
end

global tabledata() [0:]ichar namespacenames=
	(ns_none=0,		$),			!not set
	(ns_general,	$),			!variables, functions, typedefs, enum names
	(ns_tags,		$),			!struct, union, enum tags
	(ns_labels,		$),			!label names
	(ns_fields,		$)			!field names
end

global tabledata() [0:]ichar namenames, [0:]int32 namespaces=
	(nullid=0,		$,		ns_none),		!Not assigned, or keyword/macro defined by .symbol
	(macroid,		$,		ns_none),		!
	(programid,		$,		ns_none),		!Main root
	(moduleid,		$,		ns_none),		!
	(extmoduleid,	$,		ns_none),		!
	(typeid,		$,		ns_general),	!Type name in type, proc or module
	(procid,		$,		ns_general),	!Proc/method/function/op name
	(staticid,		$,		ns_general),	!Static in type or proc or module
	(frameid,		$,		ns_general),	!Local var
	(paramid,		$,		ns_general),	!Local param
	(fieldid,		$,		ns_fields),		!Field of Record or Class
	(enumid,		$,		ns_general),	!Enum name, part of enum type only
!	(macroparamid,	$,		0),				!
	(enumtagid,		$,		ns_tags),		!
	(structtagid,	$,		ns_tags),		!
	(constantid,	$,		ns_general),	!
	(labelid,		$,		ns_labels)		!Label name in proc only
end

global tabledata []ichar stnames, []int32 stsymbols, []int32 stsubcodes=

	("if",			kifsym,			j_if),
	("else",		kelsesym,		0),
	("case",		kcasesym,		0),
	("default",		kdefaultsym,	0),
	("for",			kforsym,		0),
	("do",			kdosym,			0),
	("while",		kwhilesym,		0),
	("return",		kreturnsym,		0),
	("break",		kbreaksym,		0),
	("continue",	kcontinuesym,	0),
	("goto",		kgotosym,		0),
	("switch",		kswitchsym,		0),

	("struct",		kstructsym,		0),
	("union",		kunionsym,		0),

	("include",		ksourcedirsym,	includedir),
	("define",		ksourcedirsym,	definedir),
	("elif",		ksourcedirsym,	elifdir),
	("ifdef",		ksourcedirsym,	ifdefdir),
	("ifndef",		ksourcedirsym,	ifndefdir),
	("endif",		ksourcedirsym,	endifdir),
	("undef",		ksourcedirsym,	undefdir),
	("error",		ksourcedirsym,	errordir),
	("warning",		ksourcedirsym,	warningdir),
	("message",		ksourcedirsym,	messagedir),
	("MESSAGE",		ksourcedirsym,	messagedir),
	("pragma",		ksourcedirsym,	pragmadir),
	("line",		ksourcedirsym,	linedir),
	("pause",		ksourcedirsym,	pausedir),
	("debugon",		ksourcedirsym,	debugondir),
	("debugoff",	ksourcedirsym,	debugoffdir),
	("showmacro",	ksourcedirsym,	showmacrodir),
!	("strinclude",	ksourcedirsym,	strincludedir),
	("strinclude",	kstrincludesym,	0),

	("auto",		klinkagesym,		auto_ss),
	("register",	klinkagesym,		register_ss),
	("static",		klinkagesym,		static_ss),
	("extern",		klinkagesym,		extern_ss),
	("typedef",		klinkagesym,		typedef_ss),
	
	("const",		ktypequalsym,	const_qual),
	("volatile",	ktypequalsym,	volatile_qual),
	("restrict",	ktypequalsym,	restrict_qual),
	("_Atomic",		ktypequalsym,	atomic_qual),

	("inline",		kfnspecsym,		inline_fnspec),
	("_Noreturn",	kfnspecsym,		noreturn_fnspec),
	("$callback",	kfnspecsym,		callback_fnspec),

	("_Alignas",	kalignassym,	0),

	("enum",		kenumsym,		0),

!	("$stdcall",	kcallconvsym,	stdcall_cc),
!	("$callback",	kcallconvsym,	callback_cc),
!	("$windows",	kcallconvsym,	stdcall_cc),
!!	("$clang",		kcallconvsym,	clang_cc),

	("void",		ktypespecsym,	ts_void),
	("char",		ktypespecsym,	ts_char),
	("short",		ktypespecsym,	ts_short),
	("long",		ktypespecsym,	ts_long),
	("int",			ktypespecsym,	ts_int),
	("float",		ktypespecsym,	ts_float),
	("double",		ktypespecsym,	ts_double),
	("signed",		ktypespecsym,	ts_signed),
	("unsigned",	ktypespecsym,	ts_unsigned),

	("_Bool",		ktypespecsym,	ts_char),

	("_Complex",	ktypespecsym,	ts_complex),

	("__DATE__",	predefmacrosym,	pdm_date),
	("__FILE__",	predefmacrosym,	pdm_file),
	("__LINE__",	predefmacrosym,	pdm_line),
!	("__STDC__",	predefmacrosym,	pdm_stdc),
	("__TIME__",	predefmacrosym,	pdm_time),
!	("__cdecl",		predefmacrosym,	pdm_cdecl),
	("__BCC__",		predefmacrosym,	pdm_bcc),
	("__func__",	predefmacrosym,	pdm_func),
	("__FUNCTION__",	predefmacrosym,	pdm_func),

!	("not",			notlsym,		0),
	("sizeof",		ksizeofsym,		0),
	("$sqrt",		sqrtsym,		0),
	("defined",		kdefinedsym,	0),
	("_Generic",	kgenericsym,	0),
	("_Alignof",	kalignofsym,	0),
	("$showmode",	kshowmodesym,	0),
	("$showtype",	kshowtypesym,	0),
	("typeof",		ktypeofsym,		0),
	("strtype",		kstrtypesym,	0),
	("_Static_assert",	kmccassertsym,	0),
	("cputime",		kcputimesym,	0),
!	("constant",	kconstantsym,	0),
	("structinfo",	kstructinfosym,	0),

	("$$dummy",		0,				0)
end

global tabledata() [0:]ichar convnames =

	(no_conv=0,	$),
	(soft_c,	$),			!no conversion needed, just type change
	(hard_c,	$),			!explicit conversion, done as uwiden or narrow to match sizes

	(swiden_c,	$),			!widen with sign-extension	(1/2/4 to 4/8)
	(uwiden_c,	$),			!widen with zero-extension	(1/2/4 to 4/8)
	(sfloat_c,	$),			!signed int to float		(1/2/4/8 to 4/8)
	(ufloat_c,	$),			!unsigned int to float		(1/2/4/8 to 4/8)
	(sfix_c,	$),			!float to signed int		(4/8 to 1/2/4/8)
	(ufix_c,	$),			!float to unsigned int		(4/8 to 1/2/4/8)
	(fwiden_c,	$),			!float to wider float		(4 to 8)
	(fnarrow_c,	$),			!float to narrower float	(8 to 4)
	(narrow_c,	$),			!narrow without truncation	(8/4/2 to 4/2/1)
	(truncate_c,$),			!narrow and truncate		(8/4/2 to 4/2/1)
	(bool_c,	$)			!int to bool				(1/2/4/8 to 1)
end

!take two basic numeric types and determine which is more dominant
!zeros mean not supported (error, not both numbers etc)
!(table could have been 16x16 but means checking both basic types being in-range first)

!dominantmode[s,t] returns the dominant type of s and t, widened to int/uint as needed
global [0:32,0:32]byte dominantmode

!conversionops[s,t] gives conversion op to convert numeric types s to t
global [0:16,0:16]byte conversionops

!table used to set up dominanttable[]
!3rd entry is the more dominant of the first two (wided as needed to int/unsigned int)
global [][3]byte dominantsetuptable=(
	(tschar,	tschar,		tsint),
	(tschar,	tsshort,	tsint),
	(tschar,	tsint,		tsint),
	(tschar,	tsllong,	tsllong),
	(tschar,	tbool,		tsint),
	(tschar,	tuchar,		tsint),
	(tschar,	tushort,	tsint),
	(tschar,	tuint,		tsint),
	(tschar,	tullong,	tsllong),
	(tschar,	tfloat,		tfloat),
	(tschar,	tdouble,	tdouble),
	(tschar,	tldouble,	tldouble),
	(tsshort,	tschar,		tsint),
	(tsshort,	tsshort,	tsint),
	(tsshort,	tsint,		tsint),
	(tsshort,	tsllong,	tsllong),
	(tsshort,	tbool,		tsint),
	(tsshort,	tuchar,		tsint),
	(tsshort,	tushort,	tsint),
	(tsshort,	tuint,		tsint),
	(tsshort,	tullong,	tsllong),
	(tsshort,	tfloat,		tfloat),
	(tsshort,	tdouble,	tdouble),
	(tsshort,	tldouble,	tldouble),
	(tsint,		tschar,		tsint),
	(tsint,		tsshort,	tsint),
	(tsint,		tsint,		tsint),
	(tsint,		tsllong,	tsllong),
	(tsint,		tbool,		tsint),
	(tsint,		tuchar,		tsint),
	(tsint,		tushort,	tsint),
	(tsint,		tuint,		tuint),
	(tsint,		tullong,	tsllong),
	(tsint,		tfloat,		tfloat),
	(tsint,		tdouble,	tdouble),
	(tsint,		tldouble,	tldouble),
	(tsllong,	tschar,		tsllong),
	(tsllong,	tsshort,	tsllong),
	(tsllong,	tsint,		tsllong),
	(tsllong,	tsllong,	tsllong),
	(tsllong,	tbool,		tsllong),
	(tsllong,	tuchar,		tsllong),
	(tsllong,	tushort,	tsllong),
	(tsllong,	tuint,		tsllong),
	(tsllong,	tullong,	tullong),
	(tsllong,	tfloat,		tfloat),
	(tsllong,	tdouble,	tdouble),
	(tsllong,	tldouble,	tldouble),
	(tbool,		tschar,		tsint),
	(tbool,		tsshort,	tsint),
	(tbool,		tsint,		tsint),
	(tbool,		tsllong,	tsllong),
	(tbool,		tbool,		tuint),
	(tbool,		tuchar,		tuint),
	(tbool,		tushort,	tuint),
	(tbool,		tuint,		tuint),
	(tbool,		tullong,	tullong),
	(tbool,		tfloat,		tfloat),
	(tbool,		tdouble,	tdouble),
	(tbool,		tldouble,	tldouble),
	(tuchar,	tschar,		tsint),
	(tuchar,	tsshort,	tsint),
	(tuchar,	tsint,		tsint),
	(tuchar,	tsllong,	tsllong),
	(tuchar,	tbool,		tnone),
	(tuchar,	tuchar,		tuint),
	(tuchar,	tushort,	tuint),
	(tuchar,	tuint,		tuint),
	(tuchar,	tullong,	tullong),
	(tuchar,	tfloat,		tfloat),
	(tuchar,	tdouble,	tdouble),
	(tuchar,	tldouble,	tldouble),
	(tushort,	tschar,		tsint),
	(tushort,	tsshort,	tsint),
	(tushort,	tsint,		tsint),
	(tushort,	tsllong,	tsllong),
	(tushort,	tbool,		tuint),
	(tushort,	tuchar,		tuint),
	(tushort,	tushort,	tuint),
	(tushort,	tuint,		tuint),
	(tushort,	tullong,	tullong),
	(tushort,	tfloat,		tfloat),
	(tushort,	tdouble,	tdouble),
	(tushort,	tldouble,	tldouble),
	(tuint,		tschar,		tsint),
	(tuint,		tsshort,	tsint),
	(tuint,		tsint,		tuint),
	(tuint,		tsllong,	tsllong),
	(tuint,		tbool,		tuint),
	(tuint,		tuchar,		tuint),
	(tuint,		tushort,	tuint),
	(tuint,		tuint,		tuint),
	(tuint,		tullong,	tullong),
	(tuint,		tfloat,		tfloat),
	(tuint,		tdouble,	tdouble),
	(tuint,		tldouble,	tldouble),
	(tullong,	tschar,		tullong),
	(tullong,	tsshort,	tullong),
	(tullong,	tsint,		tullong),
	(tullong,	tsllong,	tullong),
	(tullong,	tbool,		tullong),
	(tullong,	tuchar,		tullong),
	(tullong,	tushort,	tullong),
	(tullong,	tuint,		tullong),
	(tullong,	tullong,	tullong),
	(tullong,	tfloat,		tfloat),
	(tullong,	tdouble,	tdouble),
	(tullong,	tldouble,	tldouble),
	(tfloat,	tschar,		tdouble),
	(tfloat,	tsshort,	tdouble),
	(tfloat,	tsint,		tdouble),
	(tfloat,	tsllong,	tdouble),
	(tfloat,	tbool,		tdouble),
	(tfloat,	tuchar,		tdouble),
	(tfloat,	tushort,	tdouble),
	(tfloat,	tuint,		tdouble),
	(tfloat,	tullong,	tdouble),
	(tfloat,	tfloat,		tfloat),
	(tfloat,	tdouble,	tdouble),
	(tfloat,	tldouble,	tldouble),
	(tdouble,	tschar,		tdouble),
	(tdouble,	tsshort,	tdouble),
	(tdouble,	tsint,		tdouble),
	(tdouble,	tsllong,	tdouble),
	(tdouble,	tbool,		tdouble),
	(tdouble,	tuchar,		tdouble),
	(tdouble,	tushort,	tdouble),
	(tdouble,	tuint,		tdouble),
	(tdouble,	tullong,	tdouble),
	(tdouble,	tfloat,		tdouble),
	(tdouble,	tdouble,	tdouble),
	(tdouble,	tldouble,	tldouble),
	(tldouble,	tschar,		tdouble),
	(tldouble,	tsshort,	tdouble),
	(tldouble,	tsint,		tdouble),
	(tldouble,	tsllong,	tdouble),
	(tldouble,	tbool,		tdouble),
	(tldouble,	tuchar,		tdouble),
	(tldouble,	tushort,	tdouble),
	(tldouble,	tuint,		tdouble),
	(tldouble,	tullong,	tdouble),
	(tldouble,	tfloat,		tdouble),
	(tldouble,	tdouble,	tdouble),
	(tldouble,	tldouble,	tldouble),
)

!table used to set up conversionops
global [][3]byte convsetuptable=(
	(tschar,	tschar,		swiden_c),
	(tschar,	tsshort,	swiden_c),
	(tschar,	tsint,		swiden_c),
	(tschar,	tsllong,	swiden_c),
	(tschar,	tbool,		bool_c),
	(tschar,	tuchar,		soft_c),
	(tschar,	tushort,	swiden_c),
	(tschar,	tuint,		swiden_c),
	(tschar,	tullong,	swiden_c),
	(tschar,	tfloat,		sfloat_c),
	(tschar,	tdouble,	sfloat_c),
	(tschar,	tldouble,	sfloat_c),

	(tsshort,	tschar,		truncate_c),
	(tsshort,	tsshort,	no_conv),
	(tsshort,	tsint,		swiden_c),
	(tsshort,	tsllong,	swiden_c),
	(tsshort,	tbool,		bool_c),
	(tsshort,	tuchar,		truncate_c),
	(tsshort,	tushort,	soft_c),
	(tsshort,	tuint,		swiden_c),
	(tsshort,	tullong,	swiden_c),
	(tsshort,	tfloat,		sfloat_c),
	(tsshort,	tdouble,	sfloat_c),
	(tsshort,	tldouble,	sfloat_c),
	(tsint,		tschar,		truncate_c),

	(tsint,		tsshort,	truncate_c),

	(tsint,		tsint,		no_conv),
	(tsint,		tsllong,	swiden_c),
	(tsint,		tbool,		bool_c),
	(tsint,		tuchar,		truncate_c),
	(tsint,		tushort,	truncate_c),
	(tsint,		tuint,		soft_c),
	(tsint,		tullong,	swiden_c),
	(tsint,		tfloat,		sfloat_c),
	(tsint,		tdouble,	sfloat_c),
	(tsint,		tldouble,	sfloat_c),

	(tsllong,	tschar,		truncate_c),
!	(tsllong,	tschar,		narrow_c),

	(tsllong,	tsshort,	truncate_c),
	(tsllong,	tsint,		truncate_c),
	(tsllong,	tsllong,	no_conv),
	(tsllong,	tbool,		bool_c),

	(tsllong,	tuchar,		truncate_c),
!	(tsllong,	tuchar,		narrow_c),

	(tsllong,	tushort,	truncate_c),
	(tsllong,	tuint,		truncate_c),
	(tsllong,	tullong,	soft_c),
	(tsllong,	tfloat,		sfloat_c),
	(tsllong,	tdouble,	sfloat_c),
	(tsllong,	tldouble,	sfloat_c),
	(tbool,		tschar,		soft_c),
	(tbool,		tsshort,	uwiden_c),
	(tbool,		tsint,		uwiden_c),
	(tbool,		tsllong,	uwiden_c),
	(tbool,		tbool,		no_conv),
	(tbool,		tuchar,		soft_c),
	(tbool,		tushort,	uwiden_c),
	(tbool,		tuint,		uwiden_c),
	(tbool,		tullong,	uwiden_c),
	(tbool,		tfloat,		ufloat_c),
	(tbool,		tdouble,	ufloat_c),
	(tbool,		tldouble,	ufloat_c),
	(tuchar,	tschar,		soft_c),
	(tuchar,	tsshort,	uwiden_c),
	(tuchar,	tsint,		uwiden_c),
	(tuchar,	tsllong,	uwiden_c),
	(tuchar,	tbool,		bool_c),
	(tuchar,	tuchar,		soft_c),
	(tuchar,	tushort,	uwiden_c),
	(tuchar,	tuint,		uwiden_c),
	(tuchar,	tullong,	uwiden_c),
	(tuchar,	tfloat,		ufloat_c),
	(tuchar,	tdouble,	ufloat_c),
	(tuchar,	tldouble,	ufloat_c),

	(tushort,	tschar,		truncate_c),
	(tushort,	tsshort,	soft_c),
	(tushort,	tsint,		uwiden_c),
	(tushort,	tsllong,	uwiden_c),
	(tushort,	tbool,		bool_c),
	(tushort,	tuchar,		truncate_c),
	(tushort,	tushort,	no_conv),
	(tushort,	tuint,		uwiden_c),
	(tushort,	tullong,	uwiden_c),
	(tushort,	tfloat,		ufloat_c),
	(tushort,	tdouble,	ufloat_c),
	(tushort,	tldouble,	ufloat_c),

	(tuint,		tschar,		truncate_c),
	(tuint,		tsshort,	truncate_c),
	(tuint,		tsint,		soft_c),
	(tuint,		tsllong,	uwiden_c),
	(tuint,		tbool,		bool_c),
	(tuint,		tuchar,		truncate_c),
	(tuint,		tushort,	truncate_c),
	(tuint,		tuint,		no_conv),
	(tuint,		tullong,	uwiden_c),
	(tuint,		tfloat,		ufloat_c),
	(tuint,		tdouble,	ufloat_c),
	(tuint,		tldouble,	ufloat_c),

	(tullong,	tschar,		truncate_c),
	(tullong,	tsshort,	truncate_c),
	(tullong,	tsint,		truncate_c),
	(tullong,	tsllong,	soft_c),
	(tullong,	tbool,		bool_c),
	(tullong,	tuchar,		truncate_c),
	(tullong,	tushort,	truncate_c),
	(tullong,	tuint,		truncate_c),
	(tullong,	tullong,	no_conv),
	(tullong,	tfloat,		ufloat_c),
	(tullong,	tdouble,	ufloat_c),
	(tullong,	tldouble,	ufloat_c),

	(tfloat,	tschar,		sfix_c),
	(tfloat,	tsshort,	sfix_c),
	(tfloat,	tsint,		sfix_c),
	(tfloat,	tsllong,	sfix_c),
	(tfloat,	tbool,		ufix_c),
	(tfloat,	tuchar,		ufix_c),
	(tfloat,	tushort,	ufix_c),
	(tfloat,	tuint,		ufix_c),
	(tfloat,	tullong,	ufix_c),
	(tfloat,	tfloat,		no_conv),
	(tfloat,	tdouble,	fwiden_c),
	(tfloat,	tldouble,	fwiden_c),

	(tdouble,	tschar,		sfix_c),
	(tdouble,	tsshort,	sfix_c),
	(tdouble,	tsint,		sfix_c),
	(tdouble,	tsllong,	sfix_c),
	(tdouble,	tbool,		ufix_c),
	(tdouble,	tuchar,		ufix_c),
	(tdouble,	tushort,	ufix_c),
	(tdouble,	tuint,		ufix_c),
	(tdouble,	tullong,	ufix_c),
	(tdouble,	tfloat,		fnarrow_c),
	(tdouble,	tdouble,	no_conv),
	(tdouble,	tldouble,	no_conv),

	(tldouble,	tschar,		sfix_c),
	(tldouble,	tsshort,	sfix_c),
	(tldouble,	tsint,		sfix_c),
	(tldouble,	tsllong,	sfix_c),
	(tldouble,	tbool,		ufix_c),
	(tldouble,	tuchar,		ufix_c),
	(tldouble,	tushort,	ufix_c),
	(tldouble,	tuint,		ufix_c),
	(tldouble,	tullong,	ufix_c),
	(tldouble,	tfloat,		fnarrow_c),
	(tldouble,	tdouble,	no_conv),
	(tldouble,	tldouble,	no_conv),
)

global []int badexprs=(
j_const,
j_name,
j_ifx,
j_andl,
j_orl,
j_notl,
j_istruel,
j_exprlist,
j_andand,
j_eq,
j_ne,
j_lt,
j_le,
j_ge,
j_gt,
j_add,
j_sub,
j_mul,
j_div,
j_rem,
j_iand,
j_ior,
j_ixor,
j_shl,
j_shr,
j_dot,
j_idot,
j_index,
j_ptr,
j_addptr,
j_subptr,
j_neg,
j_abs,
j_inot)

=== cc_support.m 10/77 ===
import clib
import mlib
import oslib

import cc_decls
import cc_tables


global [0:]byte bytemasks=(1,2,4,8,16,32,64,128)

proc stopcompiler(ichar filename,int lineno)=
	filehandle f

	println
	println
	stop 1
end

global proc mcerror(ichar mess)=
println "MC Error:",mess
!os_getch()
stop 40
end

global proc serror(ichar mess)=
serror_gen(mess)
end

global proc serror_gen(ichar mess)=
if currproc then
	print "In function",currproc^.name,," "
fi

println "On line",lx.lineno,"in file",sourcefilepaths[lx.fileno],sourcefilenames[lx.fileno]
showmacrolineno()

println
println "**** Syntax Error:",mess,"****"
println

stopcompiler(sourcefilepaths[lx.fileno],lx.lineno)
end

global proc serror_ss(ichar mess,a,b)=
[256]char str
sprintf(&.str,mess,a,b)
serror_gen(&.str)
end

global proc serror_s(ichar mess,a)=
[256]char str
sprintf(&.str,mess,a)
serror_gen(&.str)
end

global proc terror_gen(ichar mess)=

if currproc then
	println "In function",currproc^.name
fi

println "Type error:",mess,"on line",lx.lineno,sourcefilepaths[lx.fileno]

showmacrolineno()

stopcompiler(sourcefilepaths[lx.fileno],lx.lineno)
end

global proc terror(ichar mess)=
terror_gen(mess)
end

global proc terror_s(ichar mess,a)=
[256]char str

sprintf(&.str,mess,a)
terror_gen(&.str)
end

global proc terror_ss(ichar mess,a,b)=
[256]char str

sprintf(&.str,mess,a,b)
terror_gen(&.str)
end

global proc gerror_gen(ichar mess,ref unitrec p=nil)=
int lineno,fileno

if p then
!CPL "GERROR/P GIVEN"
	lineno:=p^.lineno
	fileno:=p.fileno
else
	lineno:=clineno
	fileno:=lineno>>24
fi

if currproc then
	print "In function",currproc^.name,," "
fi

!CPL =LINENO,CLINENO, P.LINENO,P.FILENO
println "On line",lineno iand 16777215,"in file",sourcefilepaths[fileno]
println
println "**** Code Gen Error:",mess,"****"
stopcompiler(sourcefilepaths[fileno],lineno)
end


global proc gerror(ichar mess,ref unitrec p=nil)=
gerror_gen(mess,p)
end

global proc gerror_s(ichar mess,s,ref unitrec p=nil)=
[256]char str

sprintf(&.str,mess,s)
gerror_gen(&.str,p)
end

global proc nxerror(ichar mess,ref unitrec p=nil)=
int lineno

if p then
	lineno:=p^.lineno
else
	lineno:=0
fi
println "NX error:",mess,"on line",lineno,stmodule^.name
!os_getch()
stopcompiler(stmodule^.name,lineno)
end

global function testelem(ref[0:]byte p,int n)int =		!TESTELEM
!caller must check that n is in range
return ((p^[n>>3] iand bytemasks[n iand 7])|1|0)
end

global proc setelem(ref[0:]byte p,int n) =		!SETELEM
p^[n>>3] ior:= bytemasks[n iand 7]
end

global function nextpoweroftwo(int x)int=
!return next power of 2 >= x

if x=0 then return 0 fi

int a:=1
while a<x do
	a<<:=1
od
return a
end

global proc loaderror(ichar mess,mess2="")=
[512]char str

sprintf(&.str,mess,mess2)
println "Load Error:",&.str
println "Stopping"
stop 45
end

global function loadfromstdin(ichar file)int=
ichar s
[30000]CHAR SRC
ref char p
int n,c

if nsourcefiles>maxsourcefile then
	loaderror("Too many source files")
fi
++nsourcefiles
sourcefilepaths[nsourcefiles]:=pcm_copyheapstring(file)
sourcefilenames[nsourcefiles]:=pcm_copyheapstring(file)

println "Reading from stdin. Finish with Ctrl-Z:"
p:=&.src
n:=0
while (c:=getchar())<>c_eof do
	p++^:=c
	if ++n>=src.len then
		loaderror("stdin overflow")
	fi
od
!p++^:=26
p^:=0	

sourcefiletext[nsourcefiles]:=pcm_copyheapstring(&.src)
sourcefilesizes[nsourcefiles]:=strlen(&.src)
return nsourcefiles
end

global function loadsourcefile(ichar file,shortfile)int=
!file is a complete file spec of a file known to exist
!shortfile is the name as it might appear in an include statement; part- or fully-qualified
!return index into sourcefile tables
ichar s

if nsourcefiles>maxsourcefile then
	loaderror("Too many source files")
fi
++nsourcefiles
sourcefilepaths[nsourcefiles]:=pcm_copyheapstring(file)
sourcefilenames[nsourcefiles]:=pcm_copyheapstring(shortfile)

s:=cast(readfile(file))			!will overallocate by a few bytes
if not s then				!unexpected error
	loaderror("LSF can't load ",file)
fi

if flinesplicing then
!CPL "SPLICELINES",FILE
	s:=splicelines(s)
fi

!CPL "SETFILETEXT2",=NSOURCEFILES,REF VOID S,=RFSIZE
sourcefiletext[nsourcefiles]:=s
sourcefilesizes[nsourcefiles]:=rfsize
(s+rfsize)^:=0				!replace etx,0 by 0,0 (effectively, just zero)

return nsourcefiles
end

function splicelines(ichar s)ichar=
	ichar t,u

	t:=u:=pcm_alloc(strlen(s)+1)

	while s^ do
		if s^='\\' and (s+1)^=10 then s+:=2
		elsif s^='\\' and (s+1)^=13 and (s+2)^=10 then s+:=3
		else t++^ := s++^
		fi
		t^:=0
	od
	return u
end

global function loadbuiltin(ichar shortfile,hdrtext)int=
!loading build-in header with text at hdrtext
!Name of header is in 'file'.
ichar s

if nsourcefiles>maxsourcefile then
	loaderror("Too many source files")
fi
++nsourcefiles
sourcefilepaths[nsourcefiles]:="<builtin>"
sourcefilenames[nsourcefiles]:=pcm_copyheapstring(shortfile)

!source code may be written to (avoids doing that with names
!but may happen with real numbers); need to make writeable copy
!sourcefiletext[nsourcefiles]:=hdrtext
sourcefiletext[nsourcefiles]:=pcm_copyheapstring(hdrtext)
!CPL "SETFILETEXT3",=NSOURCEFILES,REF VOID SOURCEFILETEXT[NSOURCEFILES]

sourcefilesizes[nsourcefiles]:=strlen(hdrtext)
return nsourcefiles
end

proc gs_copytostr(ref strbuffer source,ref char s)=
if source^.length then
	memcpy(s,source^.strptr,source^.length)
	(s+source^.length)^:=0
else
	s^:=0
fi
end

global proc gs_additem(ref strbuffer dest,ichar s)=		!GENITEM
!like genstr, but ensure there is white space separation as needed from the last output
ichar d
int lastchar,nextchar

d:=dest^.strptr

if dest^.length then
	lastchar:=(d+dest^.length-1)^
	nextchar:=s^
	if isalphanum(lastchar) and isalphanum(nextchar) then
		strbuffer_add(dest," ")
	fi
fi
strbuffer_add(dest,s)
end

function isalphanum(int c)int=
if c>='A' and c<='Z' or c>='a' and c<='z' or c>='0' and c<='9' then
	return 1
fi
return 0
end

proc showmacrolineno=
if slineno then
	println "	(Last macro invoked near line",
		slineno,"in file",sourcefilenames[sfileno],,")"
fi
end
=== cc_lex.m 11/77 ===
! (C tokeniser module)

import msys
import mlib
import clib
import oslib

import cc_decls
import cc_support
import cc_tables
import cc_headers
import cc_lib

ref tokenrec tkptr=nil

int dowhitespace=0

int NINCLUDES

record stackinforec =
	ref char startptr
	ref char sptr
	int32 lineno
	int32 fileno
end

const maxmacroargs=200
tokenrec normaltkx
ref tokenrec normaltk = &normaltkx			!indicates use lexm to get tokens
int noexpand=0						!inhibit macro expansion for 'defined'

const maxnesting=20
[maxnesting]stackinforec lx_stack
int lx_stackindex
int ifcondlevel=0					!counts #if levels
[maxnesting]ichar headerpathlist	!remember path at each level
[300]char headerpath				!as set up by getsource()

const cr	= 13
const lf	= 10
const tab	= 9

ref char lxstart
ref char lxsptr
int lxhashvalue
ref char lxsvalue

[0..255]char alphamap
[0..255]char digitmap
[0..255]char commentmap
[0..255]char linecommentmap
[0..255]char spacemap

ref strbuffer destcopy
!const int maxpastedtokens=17000
const int maxpastedtokens=87000
[maxpastedtokens]ichar pastedtokenlist
int npastedtokens=0
int isincludefile=0				!whether readng include file name

int firstsymbol=1
ref byte reallxsptr

GLOBAL int nhstsymbols
int hstthreshold				!limit above which new hst should be generated

global proc lex_preprocess_only(ichar infile,int showtokens, NN, toconsole=0)=
	ref char psource
	int ntokens,nlines,fileno,size
	int LENGTH
	int64 nchars,t,hashtot,symtot
	real tsecs
	static strbuffer sbuffer
	static ref strbuffer dest=&sbuffer
	filehandle f
	[300]char outfile
	ICHAR SS

	dowhitespace:=1
	fileno:=loadsourcefile(infile,infile)

	strcpy(&.outfile,changeext(infile,"i"))

	psource:=cast(sourcefiletext[fileno])

	size:=sourcefilesizes[fileno]

	nlines:=ntokens:=0
	hashtot:=symtot:=0
	t:=os_clock()

	destcopy:=dest
	gs_init(dest)

!println "FAST Preprocessing",infile

	lxsptr:=psource
	lxstart:=lxsptr
	nextlx.lineno:=1
	setfileno(1)
	ifcondlevel:=0

	stacksourcefile("bcc.h",1)

	nextlx.symbol:=eolsym

	repeat
		lexm()
!lexreadtoken()
		++ntokens

		if showtokens then
			emittoken(&nextlx,dest)
		fi

	until nextlx.symbol=eofsym

	if ifcondlevel then
		lxerror("#endif missing")
	fi

	if showtokens then
		if toconsole then
			gs_println(dest,nil)
		else
			f:=fopen(&.outfile,"wb")
			gs_println(dest,f)
			fclose(f)
		fi
	fi
!CPL "DONE PREPROCESSING"

end

global proc lexreadtoken=
!read next token into nextlx
!	int c,csum,hsum,dodir
	word c,csum,hsum,dodir
	ref char p,ss
	ichar searchstr

	nextlx.subcodex:=0

	doswitch lxsptr++^
	when 'A'..'Z','a'..'z','$','_' then
doname::
		lxsvalue:=lxsptr-1
		hsum:=lxsvalue^

		while alphamap[c:=lxsptr++^] do
			hsum:=hsum<<4-hsum+c
		od
		--lxsptr
		nextlx.symbol:=namesym
		nextlx.length:=lxsptr-lxsvalue
		case c
		when '\'', '"' then
			if nextlx.length=1 then
				case lxsvalue^
				when 'l','L','u','U' then
					++lxsptr
					lxreadstring(c,1)
					return
				esac
			fi
		esac

		lxhashvalue:=hsum<<5-hsum

		ss:=pcm_alloc(nextlx.length+1)		!zero-term in lex(), as headers may need to be
		memcpy(ss,lxsvalue,nextlx.length)	!re-tokenised
		(ss+nextlx.length)^:=0
		lxsvalue:=ss

		lookup()						!clash, so do normal lookup to set lxsymptr
		return

	when '1'..'9' then					!can only be decimal
		case lxsptr^
		when ' ',')',cr,',',';' then		!assume single digit decimal
			nextlx.symbol:=intconstsym
			nextlx.subcode:=tsint
			nextlx.value:=(lxsptr-1)^-'0'
			nextlx.length:=1

			setnumberoffset(lxsptr-1-lxstart)
		else
			readdecimal(lxsptr-1)				!note: can also be real const;
		esac
		return

	when '0' then					!0, hex, binary or octal
		switch lxsptr^
		when 'x','X' then
			++lxsptr
			readhex(lxsptr-2)
			return
		when 'b','B' then
			++lxsptr
			readbinary(lxsptr-2)
			return
		when '.' then
			readrealnumber(lxsptr-1,lxsptr-1,1,10)
			return
		when 'u','U','l','L' then
			readdecimal(lxsptr-1)				!note: can also be real const;
			return
		when ',', ')', ']', '}', ';', ' ',':',cr,lf,'&','=','?' then	!assume just zero
			nextlx.symbol:=intconstsym
			nextlx.subcode:=tsint
			nextlx.value:=0
			nextlx.length:=1
			setnumberoffset(lxsptr-1-lxstart)
			return
		else

			readoctal(lxsptr-1)
			return
		endswitch					!else assume just zero	

	when '#' then			!
		if nextlx.symbol=eolsym then
			nextlx.symbol:=lexhashsym

			return

		elsif lxsptr^='#' then
			++lxsptr
			nextlx.symbol:=hashhashsym
			return
		else
			nextlx.symbol:=hashsym
			return
		fi

	when '\\' then			!line continuation
		docase lxsptr^
		when cr,lf then
			exit
		when ' ',tab then
			++lxsptr
		else
			nextlx.symbol:=backslashsym
			return
		end docase

		(lxsptr-1)^:=' '	!convert \ to space
		++nextlx.lineno
		case lxsptr^
		when cr then
			++lxsptr			!point to lf
			lxsptr++^:=' '		!set lf to space (so that '#' processing works
		when lf then
			lxsptr++^:=' '
		else
!		lxerror("\\ not followed by newline")	
		esac

	when '{' then
		nextlx.symbol:=lcurlysym
		return

	when '}' then
		nextlx.symbol:=rcurlysym
		return

	when '.' then
		switch lxsptr^
		when '.' then				!.. or ...
			++lxsptr
			if lxsptr^='.' then
				++lxsptr
				nextlx.symbol:=ellipsissym
			else
				--lxsptr
				nextlx.symbol:=dotsym
				return
			fi
			return
		when '0'..'9' then			!real const: deal with this after the switch
			--lxsptr
			readrealnumber(lxsptr,lxsptr,0,10)
			return
		else
			nextlx.symbol:=dotsym
			return
		endswitch

	when ',' then
		nextlx.symbol:=commasym
		return

	when ';' then
		nextlx.symbol:=semisym
		return

	when ':' then
		case lxsptr^
		when '=' then
			++lxsptr
			nextlx.symbol:=assignsym
		else
			nextlx.symbol:=colonsym
		esac
		return

	when '(' then
		nextlx.symbol:=lbracksym
		return

	when ')' then
		nextlx.symbol:=rbracksym
		return

	when '[' then
		nextlx.symbol:=lsqsym
		return

	when ']' then
		nextlx.symbol:=rsqsym
		return

	when '|' then
		case lxsptr^
		when '|' then
			++lxsptr
			nextlx.symbol:=orlsym
		when '=' then
			++lxsptr
			nextlx.symbol:=iortosym
		else
			nextlx.symbol:=iorsym
		esac
		return

	when '^' then
		if lxsptr^='=' then
			++lxsptr
			nextlx.symbol:=ixortosym
		else
			nextlx.symbol:=ixorsym
		fi
		return

	when '?' then
		nextlx.symbol:=questionsym
		return

	when '~' then
		nextlx.symbol:=inotsym
		return

	when '+' then
		case lxsptr^
		when '+' then
			++lxsptr
			nextlx.symbol:=incrsym
		when '=' then
			++lxsptr
			nextlx.symbol:=addtosym
		else
			nextlx.symbol:=addsym
		esac
		return

	when '-' then
		case lxsptr^
		when '-' then
			++lxsptr
			nextlx.symbol:=decrsym
		when '>' then
			++lxsptr
			nextlx.symbol:=idotsym
		when '=' then
			++lxsptr
			nextlx.symbol:=subtosym
		else
			nextlx.symbol:=subsym
		esac
		return

	when '*' then
		if lxsptr^='=' then
			++lxsptr
			nextlx.symbol:=multosym
		else
			nextlx.symbol:=mulsym
		fi
		return

	when '/' then
		case lxsptr^
		when '/' then					!comment to 
			readlinecomment()
			nextlx.symbol:=eolsym
			nextlx.length:=0
			return
		when '*' then
			readblockcomment()
		when '=' then
			++lxsptr
			nextlx.symbol:=divtosym
			return
		else
			nextlx.symbol:=divsym
			return
		esac

	when '%' then
		if lxsptr^='=' then
			++lxsptr
			nextlx.symbol:=remtosym
		else
			nextlx.symbol:=remsym
		fi
		return

	when '=' then
		case lxsptr^
		when '=' then
			nextlx.symbol:=eqsym
			++lxsptr
		else
			nextlx.symbol:=assignsym
		esac
		return

	when '<' then
		switch lxsptr^
		when '=' then
			++lxsptr
			nextlx.symbol:=lesym
		when '<' then
			if (++lxsptr)^='=' then
				++lxsptr
				nextlx.symbol:=shltosym
			else
				nextlx.symbol:=shlsym
			fi
		else
			nextlx.symbol:=ltsym
		endswitch
		return

	when '>' then
		switch lxsptr^
		when '=' then
			++lxsptr
			nextlx.symbol:=gesym
		when '>' then
			if (++lxsptr)^='=' then
				++lxsptr
				nextlx.symbol:=shrtosym
			else
				nextlx.symbol:=shrsym
			fi
		else
			nextlx.symbol:=gtsym
		endswitch
		return

	when '&' then
		case lxsptr^
		when '&' then
			++lxsptr
			nextlx.symbol:=andlsym
		when '=' then
			++lxsptr
			nextlx.symbol:=iandtosym
		else
			nextlx.symbol:=iandsym
		esac
		return

	when '\'' then
		lxreadstring('\'',0)
		return

	when '"' then
		lxreadstring('"',0)
		return

	when ' ',tab then

	when lf then
		++nextlx.lineno
		nextlx.symbol:=eolsym
		nextlx.length:=0
		if dowhitespace then
			nextlx.svalue:=cast(lxsptr)
			doswitch (lxsptr++)^
			when ' ',tab then
			else
				--lxsptr
				exit
			end
!		while spacemap[(++lxsptr)^] do od
			nextlx.length:=lxsptr-nextlx.svalue
		fi
		return
	when cr then				!ignore; always expect lf to follow

	when '!' then
		case lxsptr^
		when '=' then
			nextlx.symbol:=nesym
			++lxsptr
		else
			nextlx.symbol:=notlsym
		esac
		return

	when '@' then
PRINTLN "@ SEEN",nextlx.lineno,sourcefilenames[nextlx.fileno],lx_stackindex

	when 0 then
	doeof::
		--lxsptr
		if lx_stackindex then
			unstacksourcefile()
			nextlx.symbol:=eolsym
		else
			nextlx.symbol:=eofsym
		fi
		return

	when 12 then

	when 0xEF then			!BOM
		lxsptr+:=2

	else
		!codes above 127 can be names; later, decode the actual unicode from
		!the utf8 sequence, and check for correct ranges of chars that are allowed
!		if (lxsptr-1)^ in 128..255 then goto doname fi
		if 128<=(lxsptr-1)^<= 255then goto doname fi
!		if 128<=(lxsptr-1)^<= 255then recase 'A' fi

		PRINTLN "ERROR CHAR",(lxsptr-1)^,int((lxsptr-1)^),lx_stackindex
		lxerror("ERROR CHAR")
		nextlx.symbol:=errorsym
		return

	end doswitch

end

proc readrealnumber(ref char pstart,intstart, int intlen, base)=
!'e' or '.' has been encountered, possibly after a string of digits
!intstart points to int prefix, (or to "." if there was no prefix, then intlen=0)
!lxsptr still points at '.', 'e' or 'E' (might be 'p' or 'P' for hex base)
!read entire numbers, convert to real value in nextlx.xvalue
	ref char fractstart
	int fractlen,expon,i,c,badexpon,n,adj
	real basex,x,expbase,f,y,y2,g
	int64 aa,cc,pref
	const maxrealdigits=500
	[maxrealdigits+12]char realstr
	ref char rs
	[32]char expstr
	word64 xx1,xx2

!	if base<>10 then
		old_readrealnumber(pstart,intstart,intlen,base)
		return
!	fi

	fractstart:=nil
	fractlen:=0
	expon:=0

	if lxsptr^='.' then		!read
		fractstart:=++lxsptr
		fractlen:=scannumber(base)-fractstart
	fi
	badexpon:=0

	case lxsptr^
	when 'e','E' then
		if base<>16 then
			++lxsptr
			expon:=readexponent(badexpon)
		fi
	when 'p','P' then
		if base=16 then
			++lxsptr
			expon:=readexponent(badexpon)
		fi
	esac

	if badexpon then
		--lxsptr
		readalphanumeric(pstart)
		return
	fi

	case lxsptr^
	when 'f','F','l','L' then
		++lxsptr
	else
		if alphamap[lxsptr^] then
			readalphanumeric(pstart)
			return
		fi
	esac

	if base=16 then
		realstr[1]:='0'
		realstr[2]:='x'
		rs:=&realstr[3]
		pref:=2
	else
		rs:=&realstr[1]
		pref:=0
	fi

	if intlen+fractlen>maxrealdigits then
		lxerror("Real too long")
	fi
	if intlen then
		memcpy(rs,intstart,intlen)
	fi
	if fractlen then
		memcpy(rs+intlen,fractstart,fractlen)
	fi

	expbase:=basex:=base

	if base=10 then
		expon-:=fractlen
	else
		expon-:=fractlen*4				!each hex digit is 4 binary bits
		expbase:=2.0
	fi

	realstr[pref+intlen+fractlen+1]:=0

	print @&.expstr,(base=10|"e"|"p"),,expon

	strcat(&.realstr,&.expstr)
	if base<>10 then
		lxerror("Non-base-10 floats temporarily unavailable")
	fi

	x:=strtod(&.realstr,nil)

	nextlx.symbol:=realconstsym
	nextlx.subcode:=tdouble
	nextlx.xvalue:=x

	setnumberoffset(intstart-lxstart)
	nextlx.length:=lxsptr-intstart
end

function readexponent(int &badexpon)int=
!positioned just after 'e' etc
!read exponent, which can have optional + or -, and return actual exponent value
!exponent is always in base 10
	ref char numstart
	int length,neg,c
	int64 a

	neg:=0
	case lxsptr^
	when '+' then ++lxsptr
	when '-' then ++lxsptr; neg:=1
	esac

	numstart:=lxsptr
	length:=scannumber(10)-numstart

	if length=0 then
		badexpon:=1
		return 0
	fi

	a:=0

	to length do
		c:=numstart++^
		a:=a*10+c-'0'
	od

	return (neg|-a|a)
end

proc lxerror(ichar mess)=
!int i
	PRINTLN "Lex error",mess,"in:",,sourcefilepaths[getfileno()],
	 "Line:",nextlx.lineno
	println
	println
	println
!	os_getch()
	stop 11
end

global proc printsymbol(ref tokenrec lp)=
	tokenrec l
	l:=lp^

	printf("%-18s",symbolnames[l.symbol])

	case l.symbol
	when namesym then
		printstrn(l.symptr^.name,l.symptr^.namelen)

	when intconstsym then
		print l.value,," "
		shownumberstr(lp)

	when realconstsym then
		print l.xvalue,," "
		shownumberstr(lp)

	when stringconstsym then
		print """"
		printstrn(l.svalue,l.length)
		print """"
	when charconstsym then
		print "'"
		printstrn(l.svalue,l.length)
		print "'"

	elsif l.subcode then
		print "#",l.subcode
	end

	println
end

global proc lexsetup=
!do one-time setup:
! clear the hash table and populated it with reserved words
! do maxnum support and such
	int i

	inithashtable()
	fillhashtable()

	for i:=0 to 255 do
		switch i
!		when 'A'..'Z','a'..'z','$','_','0'..'9' then
		when 'A'..'Z','a'..'z','$','_','0'..'9', 128..255 then
			alphamap[i]:=1
		end
		switch i
		when '0'..'9' then
			digitmap[i]:=1
		end
		commentmap[i]:=1
		linecommentmap[i]:=1
		spacemap[i]:=0
	od

	commentmap['*']:=0
	commentmap[0]:=0
	commentmap[lf]:=0

	linecommentmap[0]:=0
	linecommentmap['\\']:=0
	linecommentmap[lf]:=0

	spacemap[' ']:=1
	spacemap[tab]:=1

	normaltkx.symbol:=eolsym
	npastedtokens:=0
end

global proc printstrn(ichar s, int length,filehandle f=nil)=
	if length then
		if f=nil then
			print length:"v",,s:".*"
		else
			print @f,length:"v",,s:".*"
		fi
	fi
end

function scannumber(int base)ref char=
	ref char dest
	int c

	dest:=lxsptr

	doswitch c:=lxsptr++^
	when '0'..'9' then
		dest++^:=c
		if c>='0'+base then
			lxerror("Digit out of range")
		fi
	when 'A'..'F','a'..'f' then
			if base=16 then
			dest++^:=c
		else
			--lxsptr
			exit
		fi
	when '_','\'','`' then
	else
		--lxsptr
		exit
	end doswitch
	return dest
end

function lookup:int=
	int j, wrapped,length

!++NLOOKUPS

	retry::
	j:=lxhashvalue iand hstmask
	wrapped:=0

	do
		nextlx.symptr:=hashtable^[j]
		length:=nextlx.symptr^.namelen

		if not length then
			exit
		fi

		if length=nextlx.length then	!match on length
			if memcmp(nextlx.symptr^.name,lxsvalue,length)=0 then	!match
				return 1
			fi
		fi

!++NCLASHES

		if ++j>=hstsize then
			if wrapped then
				abortprogram("HASHTABLE FULL")
			fi
			wrapped:=1
			j:=0
		fi
	od

!exit when not found; new name will go in entry pointed to by lxsymptr

	if nhstsymbols>=hstthreshold then
		newhashtable()

		lxhashvalue:=gethashvalue(lxsvalue,nextlx.length)
		goto retry
	fi

	nextlx.symptr^.name:=lxsvalue
	nextlx.symptr^.namelen:=nextlx.length
	nextlx.symptr^.symbol:=namesym
	++nhstsymbols

	return 0
end

global function gethashvalue(ichar s,int length=-1)word=
!get identical hash function to that calculated by lexreadtoken
!but for a zero-terminated string
!assumes s is lower-case, as conversion not done
!	int c,hsum
	word c,hsum

	if length=-1 then
		length:=strlen(s)
	fi
	hsum:=0

	to length do
		hsum:=hsum<<4-hsum+word(s++^)
	od
	return hsum<<5 -hsum
end

proc inithashtable=
	hashtable:=pcm_alloc(hstsize*(ref void.bytes))
	hstmask:=hstsize-1

	for i:=0 to hstmask do
		hashtable^[i]:=pcm_allocz(strec.bytes)
	od

	nhstsymbols:=0
	hstthreshold:=(6*hstsize)/10

end

proc fillhashtable=
!populate hashtable with standard symbols
	int i

	for i:=1 to stnames.len do
		lxsvalue:=stnames[i]

!sourcedir names can be converted to user name types, which could have a
!zero appended in lex() as the assumption is they are still in-situ within the source
!But with compilers like gcc, these names are in read-only memory.
!So copy them to the heap.

		if stsymbols[i]=ksourcedirsym then
			lxsvalue:=pcm_copyheapstring(lxsvalue)
		fi
		nextlx.length:=strlen(lxsvalue)
		lxhashvalue:=gethashvalue(lxsvalue,nextlx.length)

		if lookup() then
			println stnames[i]
			abortprogram("Duplicate symbol table entry")
		fi

		nextlx.symptr^.symbol:=stsymbols[i]
		nextlx.symptr^.subcode:=stsubcodes[i]
	od

end

function dolexdirective:int=
!positioned just after '#' which is first symbol on a line
!read pp directive and act on it
!return 1: returns a new symbol
!return 0: symbol has been absorbed; caller needs to read a new symbol
	ref strec symptr,d
	ref char p,pstart,s
	int i,cond,c,syshdr,dir,length, allowmacros
	[300]char filename

	pstart:=lxsptr

	dir:=getlexdirective()
	if dir=0 then
		printstrn(pstart,lxsptr-pstart); PRINTLN
		lxerror("Invalid # directive")
	fi

	case dir
	when includedir then
		isincludefile:=1

		while lxsptr^=' ' or lxsptr^=tab do ++lxsptr od
		allowmacros:=lxsptr^ <> '<'

		lexm()
		isincludefile:=0

		if nextlx.symbol=ltsym then
			syshdr:=1
			p:=&.filename

			if allowmacros then

				do
					lexm()
					case nextlx.symbol
					when eofsym, eolsym then
						lxerror("Bad include file")
					when gtsym then
						exit
					else
						s:=strtoken(&nextlx,length)
						memcpy(p,s,length)
						p+:=length
					esac
				od
			else
				do
					c:=lxsptr++^
					case c
					when '>' then
						exit
					when lf,0 then
						lxerror("include: > expected")
					else
						p++^:=c
					esac
				od
			fi
			p^:=0

		elsif nextlx.symbol=stringconstsym then
			syshdr:=0
			strcpy(&.filename,nextlx.svalue)
		else
			lxerror("include?")
		fi
		lexm()

	IF FSHOWINCLUDES THEN
		PRINTLN "INCLUDE",&.filename,"FROM",sourcefilepaths[getfileno()],nextlx.lineno,
			=nsourcefiles
	FI
	++NINCLUDES

		stacksourcefile(&.filename,syshdr)
		if not syshdr then
			addautomodule(&.filename,getfileno())
		fi

	when definedir then
		dodefine()

	when undefdir then
		lexreadtoken()
		if nextlx.symbol<>namesym then
			lxerror("undef: name expected")
		fi
		d:=nextlx.symptr
		if d^.nameid<>macroid then
!		println getstname(nextlx.symptr)
!		lxerror("#undef: can't find macro")
		else
			d^.nameid:=nullid
			d^.symbol:=nextlx.symptr^.oldsymbol
			d^.mparamlist:=nil
			d^.attribs.ax_flmacro:=0
		fi

	when ifdefdir then
		cond:=getifdef()
		goto doif

	when ifndefdir then
		cond:=not getifdef()
		goto doif

	when ifdir then
		cond:=getifexpr()
	doif::

		++ifcondlevel
		if cond then			!carry on reading code as normal
			return 0
		else
	doskipcode::
			dir:=skipcode()
			case dir
			when elifdir then
				cond:=getifexpr()
				if cond then			!do this
					return 0
				fi
				goto doskipcode
			when elsedir then			!do following code
			when endifdir then
				--ifcondlevel
			esac
		fi

	when elifdir, elsedir then			!encountered after true block
		if not ifcondlevel then
			lxerror("#if missing/elif/else")
		fi
		repeat
			dir:=skipcode()
		until dir=endifdir
		--ifcondlevel

	when endifdir then
		if not ifcondlevel then
			lxerror("#if missing/endif")
		fi
		--ifcondlevel

	when blankdir then
	when linedir then
		repeat
			lexreadtoken()
		until nextlx.symbol=eolsym
	when errordir then
		lexm()
		print "#ERROR:"; showtoken(&nextlx); println
		lxerror("ABORTING")
		goto dowarning2

	when messagedir then
		lexm()
		print "#MESSAGE "
		if nextlx.symbol=eolsym then
			println " Line",nextlx.lineno+1,sourcefilenames[getfileno()]
		else
			showtoken(&nextlx); println
		fi
		goto dowarning2
	when warningdir,pausedir then
		lexm()
		print "#WARNING:"; showtoken(&nextlx); println
	dowarning2::
		while nextlx.symbol<>eolsym and nextlx.symbol<>eofsym do lexm() od
		if dir=pausedir then
			print "Press key..."
			os_getch()
			println
		fi

	when pragmadir then
		dopragmadir()

	when debugondir then
		debug:=1

	when debugoffdir then
		debug:=0

	when showmacrodir then
		lexreadtoken()
		if nextlx.symbol=namesym then
			d:=nextlx.symptr
			print nextlx.lineno, sourcefilenames[getfileno()],":"
			PRINT "SHOW MACRO",getstname(d),":"
			if d^.nameid=macroid then
				showtokens("tokens:",d^.tokenlist)
				println
			else
				PRINTLN "not a macro"
			fi
		else
			println "Not a name"
		fi

	else
	skip::
		println "DIRECTIVE NOT IMPL:",sourcedirnames[dir]
		lxsptr:=pstart
		nextlx.symbol:=lexhashsym
		return 1
		lxerror("Directive not implemented")
	esac
	return 0
END

function getlexdirective:int=
!at '#'; read directive, and return index; 0 on error
	ref strec d

	lexreadtoken()

	case nextlx.symbol
	when namesym then
	when eolsym then
		return blankdir
	when intconstsym then
		repeat
			lexreadtoken()
		until nextlx.symbol=eolsym or nextlx.symbol=eofsym
		return blankdir
	else
		return 0
	esac

	case nextlx.symptr^.symbol
	when ksourcedirsym then
		return nextlx.symptr^.subcode
	when kifsym then
		return ifdir
	when kelsesym then
		return elsedir
	when eolsym then
		return blankdir
	esac

	d:=nextlx.symptr
	if d^.nameid=macroid then			!could have redefined 'define' etc
		if d^.oldsymbol=ksourcedirsym then
			return d^.subcode
		fi
	fi

	return 0
end

global proc startlex(ichar caption,int fileno)=
!s is a 0-terminated source string representing perhaps
!an entire file.
!Initial lex vars so that it is possible to start reading tokens from it

	ifcondlevel:=0
	lx_stackindex:=0
	noexpand:=0

	normaltk := &normaltkx			!indicates use lexm to get tokens

	lx_stackindex:=0
	ifcondlevel:=0
	firstsymbol:=1
	npastedtokens:=0
	isincludefile:=0
	tkptr:=nil

	lxstart:=lxsptr:=sourcefiletext[fileno]
	setfileno(fileno)
	nextlx.lineno:=1
	nextlx.numberoffset:=0

	nextlx.symbol:=eolsym
	nextlx.subcode:=0
	lex()
end

global proc endlex=
	if ifcondlevel then
		println ifcondlevel
		lxerror("#endif missing")
	fi
end

global proc PS(ichar caption)=
	print caption,,":::"
	printsymbol(&lx)
end

global proc PSNEXT(ichar caption)=
	print caption,,":##"
	printsymbol(&nextlx)
end

global function gethashtablesize:int=
	int i,n

	n:=0
	for i:=0 to hstmask do
		if hashtable^[i]^.name then
			++n
		fi
	od

	return n
end

proc readlinecomment=
!positioned at second '/' of '//'

	do
		while linecommentmap[(++lxsptr)^] do od		!skip bulk of characters

		case lxsptr^
		when lf then
			++lxsptr
			exit
		when 0 then
			exit					!assume on last line not ending in newline char
		when '\\' then
			++lxsptr
			case lxsptr^
			when cr then			!skip following lf and loop
				lxsptr+:=2
				++nextlx.lineno
			when lf then			!loop
				++lxsptr
				++nextlx.lineno
			esac					!else ignore and loop
!		lxerror("line comment LINE CONT")
		esac
	od
	++nextlx.lineno
end

proc readblockcomment=
!positioned at '*' of '/*'

	do
		while commentmap[(++lxsptr)^] do od		!skip bulk of characters

		case lxsptr^
		when lf then
			++nextlx.lineno
		when 0 then
			lxerror("block comment eof")
		when '*' then
			if (lxsptr+1)^='/' then		!found end of comment
				lxsptr+:=2
				exit
			fi
		esac
	od
end

proc readhex(ref char pstart)=
!positioned at first char of hex number, after 0x/0X
	word64 aa
	word c
	int length,leading,ll,usigned
	ref char p

	aa:=0
	p:=lxsptr
	leading:=1
	ll:=usigned:=0
	length:=0

	doswitch c:=lxsptr++^
	when '1'..'9' then
		leading:=0
		aa:=aa*16+(c-'0')
		++length
	when '0' then
		if leading then
			++p			!ignore leading zeros
		else
			++length
			aa:=aa*16
		fi
	when 'A'..'F' then
		leading:=0
		++length
		aa:=aa*word(16)+(c-'A'+10)
	when 'a'..'f' then
		leading:=0
		++length
		aa:=aa*word(16)+(c-'a'+10)
	when '.','P','p' then
		--lxsptr
		readrealnumber(pstart,p,lxsptr-p,16)
		return
	when 'L','l' then
		++ll
		if ll>2 then lxerror("-LL?") fi
	when 'U','u' then
		if usigned then lxerror("-U?") fi
		usigned:=1
	else
		--lxsptr
		exit
	enddoswitch

!CPL =AA

	setnumberoffset(pstart-lxstart)
	nextlx.length:=lxsptr-pstart

	if length>16 then
		lxerror("Overflow in hex number")
	fi

	nextlx.symbol:=intconstsym
	if aa>0x7FFF'FFFF'FFFF'FFFF then
		nextlx.subcode:=tullong
	elsif aa>0xFFFF'FFFF then
		nextlx.subcode:=tsllong
	elsif aa>0x7FFF'FFFF then
		nextlx.subcode:=tuint
	else
		nextlx.subcode:=tsint
	fi
!	if aa>word(0x7FFF'FFFF'FFFF'FFFF) then
!		nextlx.subcode:=tullong
!	elsif aa>word(0xFFFF'FFFF) then
!		nextlx.subcode:=tsllong
!	elsif aa>word(0x7FFF'FFFF) then
!		nextlx.subcode:=tuint
!	else
!		nextlx.subcode:=tsint
!	fi
	nextlx.value:=aa

	checknumbersuffix()
end

proc readbinary(ref char pstart)=
!positioned at first char of binary number, after 0b/0B
	word64 aa
	int c,length,res,leading
	ref char p

	aa:=0
	p:=lxsptr
	leading:=1

	doswitch c:=lxsptr++^
	when '1' then
		leading:=0
	when '0' then
		if leading then ++p fi					!ignore leading zeros
	when '2'..'9' then
		lxerror("Binary bad digit")
	when '.' then
		lxerror("Binary fp")

	else
		--lxsptr
		exit
	enddoswitch

	length:=lxsptr-p
	setnumberoffset(pstart-lxstart)
	nextlx.length:=lxsptr-pstart

	if length>64 then
		lxerror("Overflow in binary number")
	fi

	to length do
		aa:=aa*2+p++^-'0'
	od

	nextlx.symbol:=intconstsym
	nextlx.subcode:=tsint
	if aa>=0x7FFF'FFFF then
		nextlx.subcode:=tsllong
	fi
	nextlx.value:=aa

	checknumbersuffix()
end

proc readoctal(ref char pstart)=
!positioned at first char of octal number, after 0 (or at 8 or 9)
	word64 aa
	int c,length,res,leading,ll,usigned
	ref char p

	aa:=0
	p:=lxsptr
	leading:=1
	ll:=usigned:=0
	length:=0

	doswitch c:=lxsptr++^
	when '1'..'7' then
		leading:=0
		++length
	when '0' then
		if leading then
			++p				!ignore leading zeros
		else
			++length
		fi
	when '.' then
!	lxerror("Can't do octal/floats")
		--lxsptr
		readrealnumber(pstart,p,lxsptr-p,10)
		return
	when 'L','l' then
		++ll
		if ll>2 then lxerror("-LL?") fi
	when 'U','u' then
		if usigned then lxerror("-U?") fi
		usigned:=1
	else
		if alphamap[c] then
	doalpha::
			readalphanumeric(pstart)
			return
		fi
		--lxsptr
		exit
	enddoswitch

	setnumberoffset(pstart-lxstart)
	nextlx.length:=lxsptr-pstart

	if length>22 or length=22 and (res:=cmpstringn(p,"1777777777777777777777",22))>0 then
		lxerror("Overflow in octal number")
	fi

	to length do
		aa:=aa*8+p++^-'0'
	od

	nextlx.symbol:=intconstsym
	nextlx.subcode:=tsint
	if aa>=0x7FFF'FFFF then
		nextlx.subcode:=tsllong
	fi
	nextlx.value:=aa

	checknumbersuffix()
end

proc readdecimal(ref char pstart)=
!positioned at first char of decimal number
!will read integer, unless ends with any of ".eE" than assumed to be real
	word64 aa
	int c,length,res,leading
	byte ll,usigned

	ref char p

	aa:=0
	ll:=usigned:=0

	p:=--lxsptr

	while digitmap[(++lxsptr)^] do od

	while p^='0' do ++p od
	length:=lxsptr-p

	doswitch c:=lxsptr++^
	when '.','E','e' then
		--lxsptr
		readrealnumber(pstart,p,lxsptr-p,10)
		return
	when 'L','l' then
		++ll
		if ll>2 then lxerror("-LL?") fi
	when 'U','u' then
		if usigned then lxerror("-U?") fi
		usigned:=1
	else
		if alphamap[c] then
			readalphanumeric(pstart)
			return
		fi
		--lxsptr
		exit
	enddoswitch

	setnumberoffset(pstart-lxstart)
	nextlx.length:=lxsptr-pstart

	if length>20 or length=20 and (res:=cmpstringn(p,"18446744073709551615",20))>0 then
		lxerror("Overflow in decimal number")
	fi

	to length do				!A..Z have been preprocessed so that they carry on from '9'
		aa:=aa*word64(10)+word(p++^-'0')
	od

	nextlx.symbol:=intconstsym
	nextlx.subcode:=tsint

	case ll
	when 0,1 then
		if usigned then
			if aa>=0xFFFF'FFFF then
				nextlx.subcode:=tullong
			else
				nextlx.subcode:=tuint
			fi
		else
			if aa>=0x7FFF'FFFF then
				nextlx.subcode:=tsllong
			fi
		fi
	else
		if usigned then
			nextlx.subcode:=tullong
		else
			nextlx.subcode:=tsllong
		fi
	esac

	nextlx.value:=aa
end

function checknumbersuffix:int=
!return type of the constant
!positioned at terminator character which might be a suffix
	char c

	doswitch c:=lxsptr++^
	when 'L','l','u','U' then
!	lxerror("Numeric SUFFIX")
	else
		if alphamap[c] then
!*!		lxerror("Bad number suffix")
		fi
		--lxsptr
		exit
	enddoswitch

	return tsint			!don't bother for now
end

proc stacksourcefile(ichar file,int syshdr)=
	ref char sptr
	int fileno
	stackinforec info
	[500]char fullpath

	fileno:=getsourcefile(file,syshdr)
	if fileno=0 then
		println file,strlen(file)
		lxerror("Can't find include file")
	fi

	if lx_stackindex>=maxnesting then
		lxerror("Too many nested includes")
	fi
	++lx_stackindex

	fullpath[1]:=0
	if lx_stackindex>1 then
		strcpy(&.fullpath,headerpathlist[lx_stackindex-1])
	fi

	if headerpath[1] then
		strcat(&.fullpath,pcm_copyheapstring(&.headerpath))
	fi

	headerpathlist[lx_stackindex]:=pcm_copyheapstring(&.fullpath)

	info.startptr:=lxstart
	info.sptr:=lxsptr
	info.lineno:=nextlx.lineno
	info.fileno:=getfileno()
	lx_stack[lx_stackindex]:=info

	lxstart:=lxsptr:=sourcefiletext[fileno]
	setfileno(fileno)
	nextlx.lineno:=1
end

proc unstacksourcefile=
!called has checked that stack has >=1 entries
	ichar path
	stackinforec info

	path:=headerpathlist[lx_stackindex]
	pcm_free(path,strlen(path))

	info:=lx_stack[lx_stackindex--]
	lxstart:=info.startptr
	lxsptr:=info.sptr
	nextlx.lineno:=info.lineno
	setfileno(info.fileno)
end

function getsourcefile(ichar file,int syshdr)int=
!locate using search dirs; 
!read contents into memory, and return fileno
!returns 0 in case of error (file not found, memory problem)

	static [300]char filespec
	[300]char filespec2
	ichar hdrtext
	int i

	headerpath[1]:=0

	strcpy(&.filespec,file)
	convlcstring(&.filespec)

!check to see if already loaded
	for i:=1 to nsourcefiles do
		if eqstring(&.filespec,sourcefilenames[i]) then
			return i
		fi
	od

!see if a builtin header
	if dointheaders then
		hdrtext:=findheader(&.filespec)
		if hdrtext then
			return loadbuiltin(&.filespec,hdrtext)
		fi
	fi

	strcpy(&.headerpath,extractpath(file))

	if headerpath[1]='/' or headerpath[2]=':' and headerpath[3]='/' then
		if checkfile(file) then
			return loadsourcefile(file,file)
		fi
		return 0			!don't both looking anywhere else
	fi

	for i:=lx_stackindex downto 1 do
		strcpy(&.filespec,headerpathlist[i])
		strcat(&.filespec,file)


		if checkfile(&.filespec) then
			return loadsourcefile(&.filespec,file)
		fi
	od

	for i to nsearchdirs do
		strcpy(&.filespec,searchdirs[i])
		strcat(&.filespec,file)

		if checkfile(&.filespec) then
			strcpy(&.headerpath,extractpath(&.filespec))
			return loadsourcefile(&.filespec,file)
		fi
	od

	return 0
end

global proc lex=
!return next token in lx, using lexreadtoken but working a token ahead.
	reenter::

	lx:=nextlx				!grab that already read basic token

	lexm()			!read new token for next time around

	if lx.symbol=namesym and lx_stackindex=0 then
		(lx.symptr^.name+lx.length)^:=0
	fi

	docase nextlx.symbol
	when namesym then
		nextlx.symbol:=nextlx.symptr^.symbol			!convert to reserved word, type, op etc
		if nextlx.symbol=ksourcedirsym then
			nextlx.symbol:=namesym
		fi
		nextlx.subcode:=nextlx.symptr^.subcode

		return

	when eolsym then								!lose eols
		lexm()
	else
		return	
	enddocase

end

proc shownumberstr(ref tokenrec l,filehandle f=nil)=
	ref char s

	if getfilenox(l) then
		s:=sourcefiletext[getfilenox(l)]+getnumberoffsetx(l)
	else
		s:=pastedtokenlist[l^.pasteno]
	fi
	printstrn(s,l^.length,f)

end

global function addnamestr(ichar name)ref strec=
!look up arbitrary name and return symptr to generic st entry

	tokenrec oldlx
	ref strec symptr

	oldlx:=nextlx
	nextlx.length:=strlen(name)
	lxhashvalue:=gethashvalue(name,nextlx.length)

	lxsvalue:=pcm_alloc(nextlx.length+1)
	memcpy(lxsvalue,name,nextlx.length+1)
	lookup()
	symptr:=nextlx.symptr

	nextlx:=oldlx

	return symptr
end

proc lxreadstring(int termchar,int fwide)=
!read string inplace: new string, with expanded control characters,
!is stored on top of original string in the source
!new string is same length or shorter

	const maxlocalstr=2048
	[maxlocalstr]char str
	ref char dest,ws
	ref word16 wd,wd0
	int c,d,length,useheap

	if termchar='"' then
		nextlx.symbol:=(fwide|wstringconstsym|stringconstsym)
	else
		nextlx.symbol:=charconstsym
	fi

	nextlx.svalue:=lxsptr

	if lx_stackindex=0 and not fwide then
		dest:=lxsptr				!form string into same buffer
		ws:=dest					!for wide only
		useheap:=0
	else							!for headers that can be re-read, form string externally
		dest:=&.str
		ws:=dest					!for wide only
		useheap:=1
	fi
	length:=0

	do
!CPL "STR LOOP",LXSPTR^
		switch c:=lxsptr++^
		when '\\' then			!escape char
			if isincludefile then
				c:='/'
				goto normalchar
			fi
			c:=lxsptr++^
	reenter::
			switch c
			when 'a' then			!bell ('alert')
				c:=7
			when 'b' then			!backspace
				c:=8
			when 'f' then
				c:=12
			when 'n' then
				c:=lf
			when 'r' then
				c:=cr
			when 't' then			!tab
				c:=tab
			when 'v' then			!vertical tab
				c:=11
			when 'x' then	!2-digit hex code follows
				c:=0
!			to 2 do
				do
					switch d:=lxsptr++^
					when 'A','B','C','D','E','F' then
						c:=c*16+d-'A'+10
					when 'a','b','c','d','e','f' then
						c:=c*16+d-'a'+10
					when '0','1','2','3','4','5','6','7','8','9' then
						c:=c*16+d-'0'
					else
						--lxsptr
						exit
					end
				od
			when '0'..'7' then		!octal sequence
				c-:='0'				!get first digit
				to 2 do				!up to 2 more digits (some compilers will read N digits
					switch d:=lxsptr++^				!then check for overflow)
					when '0','1','2','3','4','5','6','7' then
						c:=c*8+d-'0'
					else
						--lxsptr
						exit
					end
				od

			when '"' then		!embedded double quote
				c:='"'
			when '\\' then
				c:='\\'
			when '\'' then			!embedded single quote
				c:='\''
			when cr then			!skip
				++nextlx.lineno
				if lxsptr^=lf then ++lxsptr fi
				next
			when lf then
				next
			end						!else use the escaped character itself
		when '"','\'' then		!possible terminators
			if c=termchar then		!terminator char
				exit
			fi
!		when lf,0 then
		when 0 then
			println =nextlx.lineno
			lxerror("String not terminated")
		endswitch
	normalchar::

		if not useheap then
			dest++^:=c
		elsif ++length<maxlocalstr then
			dest++^:=c
		else
			lxerror("Local str too long")
		fi
	od
	dest^:=0


	if fwide then			!need to put string on heap was will use 16-bit chars
		wd0:=wd:=pcm_alloc(length*2+2)
		to length do
			wd++^:=ws++^
		od
		wd^:=0
		nextlx.svalue:=cast(wd0)

	elsif useheap then
		nextlx.length:=length

		nextlx.svalue:=pcm_alloc(length+1)
		memcpy(nextlx.svalue,&.str,length+1)
	else
		nextlx.length:=dest-nextlx.svalue
	fi
end

proc addlisttoken(ref ref tokenrec ulist,ulistx,ref tokenrec p)=
!add strec p to end of linked list headed by ulist^. ulistx^ is current end of list
	if ulist^=nil then		!first
		ulist^:=ulistx^:=p
	else
		ulistx^^.nexttoken:=p
	fi
	p^.nexttoken:=nil

	ulistx^:=p			!update end-of-list pointer
end

proc addlisttoken_copy(ref ref tokenrec ulist,ulistx,ref tokenrec q)=
!like addlisttoken but add copy of nextlx
!(as will likely be in nextlx)
!add strec p to end of linked list headed by ulist^. ulistx^ is current end of list
	ref tokenrec p

	p:=alloctoken()

	p^:=q^
	p^.nexttoken:=nil

	if ulist^=nil then		!first
		ulist^:=ulistx^:=p
	else
		ulistx^^.nexttoken:=p
	fi
	p^.nexttoken:=nil

	ulistx^:=p			!update end-of-list pointer
end

proc addlist_nextlx(ref ref tokenrec ulist,ulistx)=
!like addlisttoken but add copy of nextlx

	ref tokenrec p
	p:=alloctoken()
	p^:=nextlx
	p^.nexttoken:=nil

	if ulist^=nil then		!first
		ulist^:=ulistx^:=p
	else
		ulistx^^.nexttoken:=p
	fi
	p^.nexttoken:=nil

	ulistx^:=p			!update end-of-list pointer
end

proc addlisttoken_seq(ref ref tokenrec ulist,ulistx,ref tokenrec seq)=
	ref tokenrec tk

	while seq do
		tk:=alloctoken()
		tk^:=seq^

		if ulist^=nil then		!first
			ulist^:=ulistx^:=tk
		else
			ulistx^^.nexttoken:=tk
		fi
		tk^.nexttoken:=nil
		ulistx^:=tk

		seq:=seq^.nexttoken
	od
end

proc addlistmparam(ref ref mparamrec ulist,ulistx,ref mparamrec p)=
	if ulist^=nil then		!first
		ulist^:=ulistx^:=p
	else
		ulistx^^.nextmparam:=p
	fi
	ulistx^:=p			!update end-of-list pointer
end

proc dodefine=
!'define' just seen

	ref mparamrec stlist,stlistx,p,q
	ref strec stname, d
	ref tokenrec tklist,tklistx,tk
	int nparams,ntokens,paramno

	lexreadtoken()
	if nextlx.symbol<>namesym then
		lxerror("define: name expected")
	fi
	stname:=nextlx.symptr
	stname^.lineno:=nextlx.lineno+int(getfileno())<<24

	stname^.oldsymbol:=stname^.symbol

	stname^.symbol:=namesym
	stname^.nameid:=macroid
	nparams:=0

	if lxsptr^='(' then
		++lxsptr
		stlist:=stlistx:=nil
		stname^.attribs.ax_flmacro:=1

		lexreadtoken()
		do
			case nextlx.symbol
			when namesym then			!next param
				d:=nextlx.symptr
				p:=stlist
				while p do
					if p^.def=d then
						lxerror("Dupl macro param")
					fi
					p:=p^.nextmparam
				od
				q:=pcm_alloc(mparamrec.bytes)
				q^.def:=d
				q^.nextmparam:=nil
				addlistmparam(&stlist,&stlistx,q)
				++nparams
				lexreadtoken()
!			(d^.name+d^.namelen)^:=0			!zero-term param name; it might be an identifier
				if nextlx.symbol=commasym then
					lexreadtoken()
				fi
			when rbracksym then
				exit
			when ellipsissym then					!I need to create a special symbol name
				d:=addnamestr("__VA_ARGS__")
				stname^.attribs.ax_varparams:=1		!flag macro as having a va/args as last param
				lexreadtoken()
				if nextlx.symbol<>rbracksym then
					lxerror("')' expected")
				fi

				q:=pcm_alloc(mparamrec.bytes)
				q^.def:=d
				q^.nextmparam:=nil
				addlistmparam(&stlist,&stlistx,q)
				++nparams
				exit
			else
				lxerror("macro params?")
			esac
		od
		stname^.mparamlist:=stlist
	fi

!Now, loop reading tokens until eol
!Store tokens in list
	tklist:=tklistx:=nil
	ntokens:=0

	do
		lexreadtoken()
		case nextlx.symbol
		when eolsym,eofsym then
			exit
		when namesym then
			p:=stname^.mparamlist
			paramno:=1
			while p do
				if p^.def=nextlx.symptr then
					nextlx.flags ior:=tk_parammask
					nextlx.paramno:=paramno
					exit
				fi
				p:=p^.nextmparam
				++paramno
			od
			if nextlx.symptr=stname then
				nextlx.flags ior:=tk_macromask
			fi
		esac

		++ntokens
		tk:=alloctoken()
		tk^:=nextlx
		addlisttoken(&tklist,&tklistx,tk)
	od

	stname^.tokenlist:=tklist
	stname^.attribs.ax_nparams:=nparams
end

proc readalphanumeric(ref char pstart)=
!part-read numeric value starting at pstart is followed by non-numeric chars
!read rest of token starting from lxsptr, and form into a name token
	while alphamap[lxsptr++^] do od
	--lxsptr
	nextlx.svalue:=pstart
	nextlx.symbol:=rawnumbersym
	nextlx.length:=lxsptr-pstart
end

function inmacrostack(ref strec d, ref tokenrec macrostack)int=
!return 1 if d is part of the macrostack
!the macrostack is a linked list of strecs, but conveniently uses a list
!of tokens although it is not really a list of tokens

	while macrostack do
		if macrostack^.symptr=d then return 1 fi
		macrostack:=macrostack^.nexttoken
	od
	return 0
end

proc showtokens(ichar caption,ref tokenrec tk)=
	print caption,,"<"
	while tk do
		showtoken(tk)
		tk:=tk^.nexttoken
	od
	println ">"
end

proc lexa(ref tokenrec &tk)=
	if tk=normaltk then
		lexreadtoken()
		return
	fi
	if tk=nil then
		nextlx.symbol:=eofsym
		return
	fi
	nextlx:=tk^
	tk:=tk^.nexttoken
end

proc lexm=
!wrapper around lexreadtoken that applies macro expansion to names
	ref strec d
	static int doreset=0
	int newlineno

	do
		if tkptr then
			nextlx:=tkptr^
			tkptr:=tkptr^.nexttoken
			if tkptr=nil then

				if nextlx.symbol=namesym and nextlx.symptr^.nameid=macroid and peeklb() then
!fix pp bug: macro expansion ending with fn-macro name, with (...) following
!but at normal lexical level. Pick that up here
					setfileno(sfileno)
					nextlx.lineno:=slineno
					doreset:=0
					goto TEST1
				fi
				doreset:=1

			fi
			return
		fi

		if doreset then
			setfileno(sfileno)
			nextlx.lineno:=slineno
			doreset:=0
		fi

		if firstsymbol then
			firstsymbol:=0
			dospecialinclude()
		fi	
		lexreadtoken()
	TEST1::

		case nextlx.symbol
		when lexhashsym then

			if dolexdirective() then
				return
			fi
!repeat lexreadtoken() until nextlx.symbol=eolsym

			next
		when namesym then
			d:=nextlx.symptr
			case d^.symbol
			when predefmacrosym then

				sfileno:=getfileno()
				slineno:=nextlx.lineno
				expandpredefmacro(d^.subcode,&nextlx,slineno)
				doreset:=1					!can screw up line/file numbers
				return
			else
				if d^.nameid<>macroid or noexpand then
					return
				fi
			esac
		else
			return
		esac
!have a macro. Now see whether this should be expanded
		sfileno:=getfileno()
		slineno:=nextlx.lineno
		if d^.attribs.ax_flmacro then		!function-like macro; need to peek for "("
			if not peeklb() then
				return
			fi
			tkptr:=expandfnmacro(d,nil,normaltk,1,newlineno)
			slineno:=newlineno
		else										!object-like macro: always expand
			tkptr:=expandobjmacro(d,nil,normaltk,1)
		fi

		if tkptr=nil then doreset:=1 fi			!immediately restore file/lineno

	od
end

function peeklb:int=
!look at lxsptr seqence and return 1 if the next token is a "(" left bracket
!lxsptr is left unchanged whatever the result
!only a simplistic approach is used, eg. 0 or 1 space then a "(" must be next
!In theory, there could be any number and combination of spaces, tabs, newlines,
!comments, strings, #-directives between this point and the next token, or
!it could be inside the next #include or just outside this one.
	if lxsptr^='(' or (lxsptr^=' ' and (lxsptr+1)^='(') then
		return 1
	fi
	return 0
end

function peektk(ref tokenrec tk)int=
!version of peeklb that works on a token list rather than chars
!tk is the current token
	tk:=tk^.nexttoken
	if tk=nil then			!nothing follows
		return 0
	fi
	if tk^.symbol=lbracksym then
		return 1
	fi
	return 0
end

function expandobjmacro(ref strec m,ref tokenrec macrostack, &tksource,
		int frombaselevel)ref tokenrec=
	ref tokenrec tk,p,repl
	tokenrec newmacro
	int iscomplex,useshh,expanded
	ref strec d

	p:=tk:=m^.tokenlist

	iscomplex:=useshh:=0
	while p do
		if p^.symbol=namesym then
			d:=p^.symptr
			if d^.nameid=macroid or d^.symbol=predefmacrosym then
				iscomplex:=1
				exit
			fi
		elsif p^.symbol=hashhashsym then
			iscomplex:=useshh:=1
			exit
		fi

		p:=p^.nexttoken
	od

	if not iscomplex then
		return tk
	fi

	newmacro.symptr:=m				!add m to macrostack
	newmacro.nexttoken:=macrostack

	if useshh then
		repl:=substituteargs(m,nil,nil,0,nil)
	else
		repl:=m^.tokenlist
	fi

	tk:=scantokenseq(repl,&newmacro,expanded)
	return tk
end

function expandfnmacro(ref strec m, ref tokenrec macrostack, &tksource,
		int frombaselevel, &endlineno)ref tokenrec=
!positioned just before "(" token
!read arguments from source (need to use lexm(), reading from char-sourc or tokenlist)
!store args in special arg lists, and prepare args for expansion
!(for this version, args expanded on demand only)
!get tokenlist for m, do argument substitution, then scan it looking for new
!macros to expand
	[maxmacroargs]ref tokenrec args,expargs
	ref tokenrec repl,tk
	tokenrec newmacro
	int nargs,i,expanded

	nargs:=readmacrocall(m,&args,tksource)
	if frombaselevel then
		endlineno:=nextlx.lineno
	fi

	for i:=1 to nargs do
		expargs[i]:=nil
	od

	repl:=substituteargs(m,&args,&expargs,nargs,macrostack)

	newmacro.symptr:=m				!add m to macrostack
	newmacro.nexttoken:=macrostack

	repl:=scantokenseq(repl,&newmacro,expanded)
	return repl
end

function scantokenseq(ref tokenrec tk, macrostack,int &expanded)ref tokenrec=
!scan token sequence belonging to:
! The replacelist of an object macro
! The substituted replacement list of a function macro
! An argument of a macro
!scan object macro, but can also be an argument

!d is an object macro that may contains further macro definitions
!scan it, and produce a new tokenlist that contains expanded versions
!of nested macro calls
!macrostack is a list of active nested macro defs. This is stored as
!a linked list of tokenrec records, in reverse order. This is just for
!convenience; the .symptr field is used to refer to the macro st entry

	ref tokenrec newtk,newtkx	!new list of tokens
	ref tokenrec expandtk		!token seqence from expanding a macro
	ref tokenrec oldtk
	ref strec m
	tokenrec newmacro
	int noexpandflag,simple,dummy

	reenter::
	expanded:=0

	newtk:=newtkx:=nil
	noexpandflag:=0

	simple:=1
	oldtk:=tk

	while tk do
		case tk^.symbol
		when namesym then
			if tk^.symptr^.nameid=macroid or tk^.symptr^.symbol=predefmacrosym then
				simple:=0
				exit
			fi
		esac

		if tk=nil then exit fi
		tk:=tk^.nexttoken
	od

	if simple then
		return oldtk
	fi

	tk:=oldtk
	while tk do
		case tk^.symbol
		when namesym then
			m:=tk^.symptr
			if m^.nameid=macroid and not noexpandflag then
!macro detected; check if candidate for expansion
				if tk^.flags iand tk_macrolit or noexpand then
					goto simpletoken
				fi

				if inmacrostack(m,macrostack) then		!is an active macro name
					addlisttoken_copy(&newtk,&newtkx,tk)
					newtkx^.flags ior:= tk_macrolit
					goto skip

				fi
	simple:=0
				if m^.attribs.ax_flmacro then
					if not peektk(tk) then goto simpletoken fi
					lexa(tk)
					expandtk:=expandfnmacro(m,macrostack,tk,1,dummy)
					addlisttoken_seq(&newtk,&newtkx,expandtk)
					expanded:=1
					next
				else
					expandtk:=expandobjmacro(m,macrostack,tk,0)
					expanded:=1
					addlisttoken_seq(&newtk,&newtkx,expandtk)
				fi
			elsif m^.symbol=kdefinedsym then
				noexpandflag:=1
				goto simpletoken
			elsif m^.symbol=predefmacrosym then
				expandtk:=alloctokenz()
!CPL "EXPAND PDM 2"
!				expandpredefmacro(m^.subcode,expandtk,nextlx.lineno)
				expandpredefmacro(m^.subcode,expandtk,slineno)
				addlisttoken_copy(&newtk,&newtkx,expandtk)
				goto skip2
			else
				noexpandflag:=0
				goto simpletoken
			fi
		else
	simpletoken::
			addlisttoken_copy(&newtk,&newtkx,tk)
		esac

	skip::
		if tk=nil then exit fi
	skip2::
		tk:=tk^.nexttoken
	od

	if expanded then
		tk:=newtk
		goto reenter
	fi

	return newtk
end

function readmacrocall(ref strec d, ref[]ref tokenrec args, ref tokenrec &tksource)int=
!positioned just before "(" of a macro call
!read arguments for the macro, and store into args
!return total number of arguments
!each args^[i] entry is a list of tokenrecs
!Caller has already checked that "(" is next token, and this will be a function macro
!tksource will point to an input stream of tokens, but can also be nil, meaning
!read via lexm from actual source. (tksource can't be nil because it's at the
!end of ...

	int nparams,lbcount,paramno
	int nargs,usesvargs,varg
	ref tokenrec tklist,tklistx			!form list of tokens for argument

	lexa(tksource)

	if nextlx.symbol<>lbracksym then lxerror("rmc: no '('") fi

	nparams:=d^.attribs.ax_nparams
	nargs:=0
	if nparams=0 then				!) must follow
		lexa(tksource)
		if nextlx.symbol<>rbracksym then lxerror("rmc: ')' expected") fi
		return 0					!no args
	fi

	paramno:=1
	lbcount:=1
	tklist:=tklistx:=nil
	usesvargs:=d^.attribs.ax_varparams			!whether macro contains ... va/args
	varg:=0										!whether encountered ... yet in arguments

	do
		if paramno=nparams and usesvargs then varg:=1 fi
		lexa(tksource)

		case nextlx.symbol
		when commasym then
			if lbcount=1 and not varg then
				if tklist=nil then					!empty list: create place-holder token
					tklist:=alloctokenz()
					setfilenox(tklist,getfileno())
					tklist^.symbol:=placeholdersym
				fi
				args^[paramno]:=tklist				!store this list
				tklist:=tklistx:=nil
				++paramno
			else
				goto addtoken
			fi

		when eofsym then
			lxerror("EOS in macro call")
		when lbracksym then
			++lbcount
			goto addtoken
		when rbracksym then
			if lbcount>1 then
				--lbcount
				addlist_nextlx(&tklist,&tklistx)
			else
				if tklist=nil then
					tklist:=alloctokenz()
					setfilenox(tklist,getfileno())
					tklist^.symbol:=placeholdersym
				fi
				args^[paramno]:=tklist				!store this list
				exit
			fi
		else
	addtoken::
			addlist_nextlx(&tklist,&tklistx)
		esac
	od

	if paramno<>nparams then
		if paramno+1=nparams and usesvargs then		!no args for ... part, needs dummy arg
			args^[nparams]:=nil
		else
			lxerror("Wrong # macro params")
		fi
	fi
	return nparams
end

function substituteargs(ref strec m,ref[]ref tokenrec args,expargs, int nargs,
ref tokenrec macrostack)ref tokenrec=
!m is a macro def
!args/expargs are arguments that will replace any parameter names encountered
!in m's replacement list
!returns new replacement list with arguments inserted
	ref mparamrec params
	ref tokenrec seq,seqstart,lasttoken
	ref tokenrec newtk,newtkx,niltk,tkexp
	tokenrec tk
	int n,i,expanded

!	const maxhashhash=100
!	const maxhashhash=200
	const maxhashhash=250
!	const maxhashhash=1000
	[maxhashhash]ref tokenrec hhpoints
	int nhashhash

	params:=m^.mparamlist
	seq:=seqstart:=m^.tokenlist		!input token sequence

	newtk:=newtkx:=nil				!output token sequence
	nhashhash:=0
	lasttoken:=nil

	while seq do
		case seq^.symbol
		when hashsym then
			if nargs then
				seq:=seq^.nexttoken
				if seq=nil then lxerror("# at end") fi
				unless seq^.flags iand tk_parammask then
					lxerror("# not followed by param")
				end unless
				n:=seq^.paramno

				stringify(args^[n],&tk)

				addlisttoken_copy(&newtk,&newtkx,&tk)
			else
				addlisttoken(&newtk,&newtkx,seq)
				newtkx^.symbol:=lithashsym				!change to #'
			fi
		when hashhashsym then
			if seq=seqstart then lxerror("## at start") fi
			if nhashhash>=maxhashhash then lxerror("Too many ##") fi
			hhpoints[++nhashhash]:=newtkx

		elsif seq^.symbol=namesym and seq^.flags iand tk_parammask and nargs then		!args can be () if no "(...)" followed
			n:=seq^.paramno
			if seq^.nexttoken and seq^.nexttoken^.symbol=hashhashsym or
			   lasttoken and lasttoken^.symbol=hashhashsym then
				addlisttoken_seq(&newtk,&newtkx,args^[n])
			else
				tkexp:=expargs^[n]
				if tkexp=nil then
					tkexp:=expargs^[n]:=scantokenseq(args^[n],macrostack,expanded)
				fi
				addlisttoken_seq(&newtk,&newtkx,tkexp)
			fi

		else
	doother::
			addlisttoken_copy(&newtk,&newtkx,seq)
		esac

		lasttoken:=seq
		seq:=seq^.nexttoken
	od

	if nhashhash then
		niltk:=nil
		for i:=1 to nhashhash do
			pastetokens(hhpoints[i],(i<nhashhash | hhpoints[i+1]| niltk))
		od
	fi

	return newtk
end

function strtoken(ref tokenrec lp,int &length)ichar=
!convert token to a string
!return pointer to the string *which is likely to be unterminated*
!return length of the string in 'length'
!(not sure yet if -1 is a possible length, meaning the string is zero-terminated)
!display token contents naturally
!note that caller should copy the string involved as no promises can be 
!made to ownership
	ichar name,s
	tokenrec l
	l:=lp^

	case l.symbol
	when namesym then
	doname::
		length:=l.symptr^.namelen
		return l.symptr^.name

	when intconstsym,realconstsym then
		length:=l.length


		if getfilenox(&l) then
			return sourcefiletext[getfilenox(&l)]+getnumberoffsetx(&l)
		else
			return pastedtokenlist[l.pasteno]
		fi
	when rawnumbersym then
		length:=l.length
		return l.svalue

	when stringconstsym,wstringconstsym then
		s:=strstring(l.svalue,l.length,length,'"')
		return s

	when charconstsym then
		s:=strstring(l.svalue,l.length,length,'\'')
		return s

	when eolsym then
		if dowhitespace then
			length:=l.length+1
			s:=pcm_alloc(length)
			s^:=10		!'\n'
			memcpy(s+1,l.svalue,l.length)
		else
			length:=1
			return "\n"
		fi
		return s

	when eofsym then
		length:=0
		return ""

	when ktypespecsym, ktypequalsym, klinkagesym, kfnspecsym then
		goto doname

	else
!length:=1
!return " "
		name:=shortsymbolnames[l.symbol]
		if length:=strlen(name) then
			if name^<>'k' then
				return name
			else
				length:=strlen(symbolnames[l.symbol]+1)
				return symbolnames[l.symbol]+1
			fi
		else
			return ""
		fi
	esac
	return ""
end

function strstring(ichar s,int length,&newlength,quotechar)ichar=
!stringify the string, which means converting control codes to
!escape sequences, and adding optional quotes

	ichar t,u

	t:=u:=pcm_alloc(length*2+4)
	if quotechar then
		u^:=quotechar
		++u
	fi
	convertstring(s,u,length)
	newlength:=strlen(t)
	if quotechar then
		(t+newlength)^:=quotechar
		++newlength
	fi
	return t
end

int lasttoken=0

global proc emittoken(ref tokenrec lp,ref strbuffer dest,int forcespace=0)=
!display token contents naturally
	int length
	ichar s

	if lp^.symbol=eolsym and lasttoken=eolsym then
		return
	fi

	s:=strtoken(lp,length)

	if forcespace or needspace(lasttoken,lp^.symbol) then
		gs_char(dest,' ')
	fi

	gs_strn(dest,s,length)


	lasttoken:=lp^.symbol
end

global proc showtoken(ref tokenrec lp)=
	static strbuffer buffer
	static ref strbuffer dest=&buffer

	gs_init(dest)
	
	emittoken(lp,dest)
	
print dest^.length:"v",,dest^.strptr:".*"
end

proc stringify(ref tokenrec seq,dest)=
!stringify single or multiple token sequence, and store result as a single
!string token in dest
	ref char s
	int length,addspace
	static strbuffer buffer
	static ref strbuffer deststr=&buffer

	dest^.symbol:=stringconstsym
	dest^.nexttoken:=nil

	if seq^.nexttoken=nil then		!single
		s:=strtoken(seq,length)
		dest^.length:=length
		dest^.svalue:=s
		return 
	fi

!now do multiple tokens into one string
	gs_init(deststr)
	lasttoken:=0
	addspace:=0
	while seq do
		emittoken(seq,deststr,forcespace:addspace)
		addspace:=1
		seq:=seq^.nexttoken
	od

	dest^.length:=length
	dest^.svalue:=deststr^.strptr
	dest^.length:=deststr^.length
end

proc pastetokens(ref tokenrec tk, &tknext)=
!tk points into a token sequence
!paste the token at tk with the one at tk^.nexttoken, and replace
!tk with the new composite token; tk^.nexttoken is removed
!tknext is either nil, or refers to the next pair of tokens to be pasted together;
!there is a problem when tk^.nexttoken and tknext coincide, so something needs to
!be done in that case (set tknext to point to tk)

	ref tokenrec tk2
	int length1,length2
	ref char s,t,u
	tokenrec oldtoken,token
	ref char oldlxsptr
	int oldlx_stackindex

	tk2:=tk^.nexttoken
	if tk2=tknext then tknext:=tk fi
	tk^.nexttoken:=tk2^.nexttoken				!lose second token

	if tk^.symbol=placeholdersym then
		if tk2^.symbol=placeholdersym then			!two placeholders; leave only first
		else										!ph/token; use second
			tk^:=tk2^								!also unlinks the tk2 token
		fi
	elsif tk2^.symbol=placeholdersym then			!token/ph; leave only first
	else						!two normal tokens

		s:=strtoken(tk,length1)
		t:=strtoken(tk2,length2)

		u:=pcm_alloc(length1+length2)
		memcpy(u,s,length1)
		memcpy(u+length1,t,length2)
		(u+length1+length2)^:=0

		if npastedtokens>=maxpastedtokens then
			lxerror("Too many pasted tokens")
		fi
		pastedtokenlist[++npastedtokens]:=u

		oldtoken:=nextlx
		oldlxsptr:=lxsptr
		oldlx_stackindex:=lx_stackindex

		lxsptr:=u
		lx_stackindex:=0

		setfileno(0)
		nextlx.lineno:=0
		lexreadtoken()
		token:=nextlx
		lexreadtoken()

		if nextlx.symbol<>eofsym then
!		lxerror("token-paste error")
		fi

		nextlx:=oldtoken
		lxsptr:=oldlxsptr
		lx_stackindex:=oldlx_stackindex

		token.nexttoken:=tk^.nexttoken
		setfilenox(&token,0)
		token.pasteno:=npastedtokens

	token.flags ior:=tk_pasted
		tk^:=token
	fi
end

function getifexpr:int=
	int sx
	int x

	lexm()
	x:=evalcondexpr(sx)

	if nextlx.symbol<>eolsym then
		lxerror("#if:eol expected")
	fi

	return x<>0
end

function evalcondexpr(int &sx)i64=
!Main entry point for pp expressions
!Will do conditional ?: expressions here
!Positioned at first symbol of expression, which is in nextlx (if a macro
!it will have been expanded, and this is the first token of that expansion)
	i64 x,y,z
	int sy,sz

	x:=evalorexpr(sx)

	if nextlx.symbol=questionsym then
		lexm()
		y:=evalcondexpr(sy)
		if nextlx.symbol<>colonsym then lxerror(": expected") fi
		lexm()
		z:=evalcondexpr(sz)
		if x then
			sx:=sy
			x:=y
		else
			sx:=sz
			x:=z
		fi
	fi

	return x
end

function evalorexpr(int &sx)i64=
	i64 x,y
	int sy,opc

	x:=evalandexpr(sx)
	while nextlx.symbol=orlsym do
		lexm()
		y:=evalandexpr(sy)
		x := (x or y|1|0)
	od

	return x
end

function evalandexpr(int &sx)i64=
	i64 x,y
	int sy,opc

	x:=evaliorexpr(sx)
	while nextlx.symbol=andlsym do
		lexm()
		y:=evaliorexpr(sy)
		x := (x and y|1|0)
	od

	return x
end

function evaliorexpr(int &sx)i64=
	i64 x,y
	int sy,opc

	x:=evalixorexpr(sx)
	while nextlx.symbol=iorsym do
		lexm()
		x ior:= evalixorexpr(sy)
	od

	return x
end

function evalixorexpr(int &sx)i64=
	i64 x,y
	int sy,opc

	x:=evaliandexpr(sx)
	while nextlx.symbol=ixorsym do
		lexm()
		x ixor:= evaliandexpr(sy)
	od

	return x
end

function evaliandexpr(int &sx)i64=
	i64 x,y
	int sy,opc

	x:=evaleqexpr(sx)
	while nextlx.symbol=iandsym do
		lexm()
		x iand:= evaleqexpr(sy)
	od

	return x
end

function evaleqexpr(int &sx)i64=
	i64 x,y
	int sy,opc

	x:=evalcmpexpr(sx)
	while (opc:=nextlx.symbol)=eqsym or opc=nesym do
		lexm()
		y:=evalcmpexpr(sy)
		case opc
		when eqsym then x := x = y
		when nesym then x := x <> y
		esac
	od

	return x
end

function evalcmpexpr(int &sx)i64=
	i64 x,y
	int sy,opc

	x:=evalshiftexpr(sx)
	while (opc:=nextlx.symbol)=ltsym or opc=lesym or opc=gesym or opc=gtsym do
		lexm()
		y:=evalshiftexpr(sy)
		case opc
		when ltsym then x := x < y
		when lesym then x := x <= y
		when gesym then x := x >= y
		when gtsym then x := x > y
		esac
	od

	return x
end

function evalshiftexpr(int &sx)i64=
	i64 x,y
	int sy,opc

	x:=evaladdexpr(sx)
	while (opc:=nextlx.symbol)=shlsym or opc=shrsym do
		lexm()
		y:=evaladdexpr(sy)
		case opc
		when shrsym then
			x := x>>y
		when shlsym then
			x := x<<y
		esac
	od

	return x
end

function evaladdexpr(int &sx)i64=
	i64 x,y
	int sy,opc

	x:=evalmulexpr(sx)
	while (opc:=nextlx.symbol)=addsym or opc=subsym do
		lexm()
		y:=evalmulexpr(sy)
		case opc
		when addsym then
			x +:= y
		when subsym then
			x -:= y
		esac
	od

	return x
end

function evalmulexpr(int &sx)i64=
	i64 x,y
	int sy,opc

	x:=evalunaryexpr(sx)
	while (opc:=nextlx.symbol)=mulsym or opc=divsym or opc=remsym do
		lexm()
		y:=evalunaryexpr(sy)
		if y=0 and opc<>mulsym then lxerror("#if:div by zero") fi
		case opc
		when mulsym then
			x *:= y
		when divsym then
			x := x/y
		when remsym then
			x := x rem y
		esac
	od

	return x
end

function evalunaryexpr(int &sx)i64=
	i64 x
	int opc

	case nextlx.symbol
	when addsym, subsym, notlsym, inotsym then
		opc:=nextlx.symbol
		lexm()
		x:=evalunaryexpr(sx)
		case opc
		when addsym then
			return x
		when subsym then
			return -x
		when notlsym then
			return not x
		when inotsym then
			return inot x
		esac
	esac

	return evalterm(sx)
end

function evalterm(int &sx)i64=
	i64 res
	int lb

	sx:=1
	case nextlx.symbol
	when namesym then
		case nextlx.symptr^.symbol
		when kdefinedsym then
			noexpand:=1
			lb:=0
			lexm()
			if nextlx.symbol=lbracksym then
				lb:=1;
				lexm()
			fi
			if nextlx.symbol<>namesym then lxerror("defined?") fi
			res:=nextlx.symptr^.nameid=macroid
			lexm()
			if lb then
				if nextlx.symbol<>rbracksym then lxerror("')' expected") fi
				lexm()
			fi
			noexpand:=0
		when ksizeofsym then
			lexm()
			if nextlx.symbol<>lbracksym then lxerror("'(' expected") fi
			lexm()
			if nextlx.symbol<>namesym then lxerror("name expected") fi
			case nextlx.symptr^.symbol
			when ktypespecsym then
				res:=typespecsizes[nextlx.symptr^.subcode]
			else
				lxerror("sizeof2")
			esac
			lexm()
			if nextlx.symbol<>rbracksym then lxerror("')' expected") fi
			lexm()
	
		else
!CPL NEXTLX.SYMPTR.NAME
!lxerror("Undefined macro name in cpp expr")
			lexm()
			return 0
		esac
	when intconstsym then
		res:=nextlx.value
		lexm()
	when charconstsym then
		if nextlx.length=0 then
			res:=0
		else
			res:=nextlx.svalue^
		fi
		lexm()
	when lbracksym then
		lexm()
		res:=evalcondexpr(sx)
		if nextlx.symbol<>rbracksym then
			lxerror(") expected")
		fi
		lexm()
	else
	printsymbol(&nextlx)
	printstrn(nextlx.svalue,nextlx.length); PRINTLN
		lxerror("evalterm?")
	esac

	return res
end

function getifdef:int=
!just read ifdef/ifndef
!read following name and return 1 if name is macro, or 0 if not
	int res
	ref strec d

	noexpand:=1
	lexreadtoken()
	noexpand:=0
	if nextlx.symbol<>namesym then lxerror("Name expected") fi
	d:=nextlx.symptr
	res:=0
	if d^.nameid=macroid then
		res:=1
	elsif d^.symbol=predefmacrosym then
		res:=1
	fi

	lexreadtoken()
	if nextlx.symbol<>eolsym then lxerror("EOL expected") fi

	return res
end

function skipcode:int=
!skip false branch of #if etc until matching #elif/else/endif
!return dir-code of that closing directive
	int level,dir
	ref byte pp

	level:=0						!count nested #if levels

	do
		fastreadtoken()

		case nextlx.symbol
		when lexhashsym then
			dir:=getlexdirective()
			case dir
			when ifdir, ifdefdir, ifndefdir then
				++level
			when elifdir, elsedir then
				if level=0 then
					return dir
				fi
			when endifdir then
				if level=0 then
					return dir
				fi
				--level
			esac
		when eofsym then
			lxerror("#if:Unexpected eof")
		esac
	od
	return 0
end

proc freetokens(ref tokenrec tk)=
	ref tokenrec nexttk

	while tk do
		nexttk:=tk^.nexttoken
		tk:=nexttk
	od
end

global proc fastreadtoken=
!read next token into nextlx
	int c,csum,hsum,commentseen,dodir,j
	ref char pstart,p
	ichar ss

	nextlx.subcodex:=0

!	doswitch lxsptr++^
	doswitch C:=lxsptr++^
	when '#' then			!
		p:=lxsptr-2
		dodir:=0
		while p>=lxstart do
			case p^
			when lf then		!# is first thing on a line
				dodir:=1
				exit
			when tab,' ' then	!might have leading white space
			else
				exit			!assume different hash symbol
			esac
			--p
		od
		if dodir or p<lxstart then
			nextlx.symbol:=lexhashsym
		return

		elsif lxsptr^='#' then
			++lxsptr
		fi

	when '/' then
		case lxsptr^
		when '/' then					!comment to 
			readlinecomment()
		when '*' then
			readblockcomment()
		esac
	
	when '\'' then
		lxreadstring('\'',0)

	when '"' then
		lxreadstring('"',0)

	when cr then
		++nextlx.lineno
		nextlx.symbol:=eolsym
		nextlx.length:=0
		++lxsptr				!skip lf
	when lf then			!only lfs not preceded by cr
		++nextlx.lineno
		nextlx.symbol:=eolsym
		nextlx.length:=0

	when 0 then
		--lxsptr
		if lx_stackindex then
			unstacksourcefile()
		else
			nextlx.symbol:=eofsym
			return
		fi

	when 12 then
else
!CPL "ELSE FAST OTHER",CHAR(C)
	end doswitch
end

function alloctoken:ref tokenrec=
	ref tokenrec tk
	tk:=pcm_alloc(tokenrec.bytes)
	return tk
end

function alloctokenz:ref tokenrec=
	ref tokenrec tk
	tk:=pcm_alloc(tokenrec.bytes)
	tk^.nexttoken:=nil
	return tk
end

proc expandpredefmacro(int pdmcode,ref tokenrec tk,int lineno)=
	[256]char str
	static []ichar monthnames=("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec")
	rsystemtime tm
	ichar s
	int fileno

	if noexpand then
		return
	fi

	case pdmcode
	when pdm_date then
		os_getsystime(&tm)

		fprint @&.str, "#-#-#",tm.day,monthnames[tm.month],tm.year:"4"

		tk^.symbol:=stringconstsym
		tk^.svalue:=pcm_copyheapstring(&.str)

	when pdm_time then
		os_getsystime(&tm)

		fprint @&.str,"#:#:#",tm.hour:"2",tm.minute:"z2",tm.second:"z2"

		tk^.symbol:=stringconstsym
		tk^.svalue:=pcm_copyheapstring(&.str)
	when pdm_file then
		tk^.symbol:=stringconstsym
		fileno:=getfilenox(tk)
		if fileno=0 then fileno:=sfileno fi
		if sfileno then
			tk^.svalue:=sourcefilenames[sfileno]
		else
			tk^.svalue:="(File not available)"
		fi
	when pdm_func then
		tk^.symbol:=stringconstsym
		if currproc then
			tk^.svalue:=currproc^.name
		else
			tk^.svalue:="???"
		fi
	when pdm_line then
		tk^.symbol:=intconstsym
		tk^.value:=lineno
	when pdm_stdc then
		tk^.symbol:=intconstsym
		tk^.value:=1
	when pdm_bcc then
		tk^.symbol:=intconstsym
		tk^.value:=1
	else
		println pdmcode
		lxerror("PDM")
	esac

	if tk^.symbol=stringconstsym then
		tk^.length:=strlen(tk^.svalue)
		tk^.subcode:=trefchar
	else
		tk^.subcode:=tsint
		s:=pcm_alloc(16)
!	sprintf(s,"%lld",tk^.value)
		getstrint(tk.value,s)
		tk^.length:=strlen(s)
		if npastedtokens>=maxpastedtokens then
			lxerror("2:Too many pasted tokens")
		fi
		pastedtokenlist[++npastedtokens]:=s
		setfilenox(tk,0)
		tk^.pasteno:=npastedtokens
	fi
end

proc dopragmadir=
	lexm()
	if nextlx.symbol=namesym then
		if memcmp(nextlx.symptr^.name,"pack",4)=0 then
			lexm()
			if nextlx.symbol<>lbracksym then lxerror("'(' expected") fi
			lexm()
			if nextlx.symbol=intconstsym then
				case nextlx.value
				when 1 then
					structpadding:=0
				else
					goto finish
					lxerror("Only pack(1) or () allowed")
				esac
				lexm()
			elsif nextlx.symbol=rbracksym then
				structpadding:=1
			fi
		elsif memcmp(nextlx.symptr^.name,"$callback",9)=0 then
			callbackflag:=1
		fi
	fi
finish::
	while nextlx.symbol<>eolsym and nextlx.symbol<>eofsym do lexm() od
end

function needspace(int a,b)int=
	ichar aname, bname

	if a=0 then return 0 fi			!first token

	aname:=shortsymbolnames[a]
	bname:=shortsymbolnames[b]

	case bname^
	when 'n','k' then
		case aname^
		when 'n','k' then
			return 1
		esac
	when '-','+' then
		case aname^
		when '-','+' then
			return 1
		esac
	esac

	return 0
end

global proc dospecialinclude=
	++NINCLUDES
	stacksourcefile("bcc.h",1)
	if dheaderfile then
		stacksourcefile(dheaderfile,1)
	fi
end

proc addautomodule(ichar headername,int fileno)=
	ichar cfilename
	ichar headerfile
	int present

	headerfile:=sourcefilepaths[fileno]

	if not fautomodules then
		return
	fi

	if eqstring(extractext(headerfile),"c") then		!ignore .c files
		return
	fi

	cfilename:=changeext(headerfile,"c")
	if checkfile(cfilename) then
		present:=1
		for i:=1 to nautomodules do
			if eqstring(automodulenames[i],cfilename) then
				present:=0
				exit
			fi
		od
		if present then
			automodulenames[++nautomodules]:=pcm_copyheapstring(cfilename)
		fi
	fi
end

proc setnumberoffset(int offset)=
!store offset into nextlx.numberoffset
!except that top byte is msb of fileno
	nextlx.numberoffset:=(nextlx.numberoffset iand 0xFF000000) ior (offset iand 0xFFFFFF)
end

proc setfileno(int fileno)=
	nextlx.fileno:=fileno iand 255
	nextlx.numberoffset := (nextlx.numberoffset iand 0xFFFFFF) ior((fileno iand 0xFF00)<<16)
end

proc setfilenox(ref tokenrec tk,int fileno)=

	tk^.fileno:=fileno iand 255
	tk^.numberoffset := (tk^.numberoffset iand 0xFFFFFF) ior (fileno iand 0xFF00)<<16
end

function getfileno:int=
	return (nextlx.numberoffset>>24)<<8 ior nextlx.fileno
end

function getfilenox(ref tokenrec tk)int=
	return (tk^.numberoffset>>24)<<8 ior tk^.fileno
end

function getnumberoffsetx(ref tokenrec tk)int=
	return tk^.numberoffset iand 0xFFFFFF
end

global proc freehashtable=
!free the user name entries in the hash table
!leave reserved words etc alone
	ref strec d,e,f

	for i:=0 to hstmask do
		d:=hashtable^[i]
		if d^.name and d^.symbol=namesym then
			if d^.nameid=macroid then
				freetokens(d^.tokenlist)
			fi
			f:=d^.nextdupl
			while f do
				freestentry(f)
				e:=f^.nextdupl
				pcm_free(f,strec.bytes)
				f:=e
			od
			pcm_clearmem(hashtable^[i],strec.bytes)
		elsif d^.name then
			d^.nextdupl:=nil
		fi
	od
end

proc freestentry(ref strec d)=
end

proc regenlookup(ref strec d)=
	int j, wrapped,length
	ref strec e

	j:=gethashvalue(d^.name,d^.namelen) iand hstmask
	wrapped:=0

	do
		e:=hashtable^[j]
		length:=e^.namelen

		if not length then
PCM_FREE(HASHTABLE^[J],STREC.BYTes)
			hashtable^[j]:=d
			++nhstsymbols
			return
		fi

		if length=d^.namelen then	!match on length
			if memcmp(e^.name,d^.name,length)=0 then	!match
				lxerror("regenhst dupl?")
			fi
		fi

		if ++j>=hstsize then
			if wrapped then
				abortprogram("REGENHST FULL?")
			fi
			wrapped:=1
			j:=0
		fi
	od
end

proc printhashtable(ichar caption)=
	ref strec d

	println caption,,":"
	for i:=0 to  hstsize-1 do
		d:=hashtable^[i]
		if d^.name then
			println i,":",d^.name
		else
			println i,": ----"
		fi
	od
	println
end

proc newhashtable=
	ref[0:]ref strec oldhashtable
	int oldhstsize
	ref strec d

!remember old hst
	oldhashtable:=hashtable
	oldhstsize:=hstsize
!generate new, blank hst
	hstsize*:=2
	hstmask:=hstsize-1
	nhstsymbols:=0
	hstthreshold:=(6*hstsize)/10

	hashtable:=pcm_alloc(hstsize*(ref void.bytes))

	for i:=0 to hstmask do
		hashtable^[i]:=pcm_allocz(strec.bytes)
	od

!now, rehash all existing hashentries
	for i:=0 to oldhstsize-1 do
		d:=oldhashtable^[i]
		if d^.name then
			regenlookup(d)
		fi
	od

	pcm_free(oldhashtable,oldhstsize*(ref void.bytes))
end

proc old_readrealnumber(ref char pstart,intstart, int intlen, base)=
!'e' or '.' has been encountered, possibly after a string of digits
!intstart points to int prefix, (or to "." if there was no prefix, then intlen=0)
!lxsptr still points at '.', 'e' or 'E' (might be 'p' or 'P' for hex base)
!read entire numbers, convert to real value in nextlx.xvalue
	ref char fractstart
	int fractlen,expon,i,c,badexpon
	real basex,x,expbase
	const maxrealdigits=500
	[maxrealdigits]char realstr

	fractstart:=nil
	fractlen:=0
	expon:=0

	if lxsptr^='.' then		!read
		fractstart:=++lxsptr
		fractlen:=scannumber(base)-fractstart
	fi
	badexpon:=0

	case lxsptr^
	when 'e','E' then
		if base<>16 then
			++lxsptr
			expon:=readexponent(badexpon)
		fi
	when 'p','P' then
		if base=16 then
			++lxsptr
			expon:=readexponent(badexpon)
		fi
	esac

	if badexpon then
		--lxsptr
		readalphanumeric(pstart)
		return
	fi

	case lxsptr^
	when 'f','F' then
		++lxsptr
	else
		if alphamap[lxsptr^] then
			readalphanumeric(pstart)
			return
		fi
	esac

	if intlen+fractlen>maxrealdigits then
		lxerror("Real too long")
	fi
	if intlen then
		memcpy(&realstr,intstart,intlen)
	fi
	if fractlen then
		memcpy(&realstr[1]+intlen,fractstart,fractlen)
	fi

	expbase:=basex:=base

	if base=10 then
		expon-:=fractlen
	else
		expon-:=fractlen*4				!each hex digit is 4 binary bits
		expbase:=2.0
	fi

	x:=0.0

	for i:=1 to intlen+fractlen do		!digits already range-checked
		c:=realstr[i]
		if c>='0' and c<='9' then
			x:=x*basex+(c-'0')
		elsif c>'a' then
			x:=x*basex+c-'a'+10
		else
			x:=x*basex+c-'A'+10
		fi
	od

	if expon>=0 then
		to expon do
			x*:=expbase
		od
	else
		to -expon do
			x/:=expbase
		od
	fi

	nextlx.symbol:=realconstsym
	nextlx.subcode:=tdouble
	nextlx.xvalue:=x

	setnumberoffset(intstart-lxstart)
	nextlx.length:=lxsptr-intstart
end
=== cc_headers.m 12/77 ===
!Built-in standard headers

import clib
import mlib

ichar bcclibstr = strinclude "bcclib.asm"

ichar h_assert		=	strinclude "headers/assert.h"
ichar h_ctype		=	strinclude "headers/ctype.h"
ichar h_errno		=	strinclude "headers/errno.h"
ichar h_fenv		=	strinclude "headers/fenv.h"
ichar h_float		=	strinclude "headers/float.h"
ichar h_inttypes	=	strinclude "headers/inttypes.h"
ichar h_stdint		=	strinclude "headers/stdint.h"
ichar h_limits		=	strinclude "headers/limits.h"
ichar h_locale		=	strinclude "headers/locale.h"
ichar h__ansi		=	strinclude "headers/_ansi.h"
ichar h_math		=	strinclude "headers/math.h"
ichar h_setjmp		=	strinclude "headers/setjmp.h"
ichar h_signal		=	strinclude "headers/signal.h"
ichar h_stdarg		=	strinclude "headers/stdarg.h"
ichar h_stdbool		=	strinclude "headers/stdbool.h"
ichar h_stddef		=	strinclude "headers/stddef.h"
ichar h_stdio		=	strinclude "headers/stdio.h"
ichar h_stdlib		=	strinclude "headers/stdlib.h"
ichar h__syslist	=	strinclude "headers/_syslist.h"
ichar h_string		=	strinclude "headers/string.h"
ichar h_time		=	strinclude "headers/time.h"
ichar h_utime		=	strinclude "headers/utime.h"
ichar h_unistd		=	strinclude "headers/unistd.h"
ichar h_safelib		=	strinclude "headers/safelib.h"
ichar h_wchar		=	strinclude "headers/wchar.h"
ichar h_wctype		=	strinclude "headers/wctype.h"
ichar h_systypes	=	strinclude "headers/sys/types.h"
ichar h_sysstat		=	strinclude "headers/sys/stat.h"
ichar h_systimeb	=	strinclude "headers/sys/timeb.h"
ichar h_sysutime	=	strinclude "headers/sys/utime.h"
ichar h_memory		=	strinclude "headers/memory.h"
ichar h_windows		=	strinclude "headers/windows.h"
ichar h_fcntl		=	strinclude "headers/fcntl.h"
ichar h_io			=	strinclude "headers/io.h"
ichar h_direct		=	strinclude "headers/direct.h"
ichar h_process		=	strinclude "headers/process.h"
ichar h_malloc		=	strinclude "headers/malloc.h"
ichar h_bcc			=	strinclude "headers/bcc.h"
ichar h_conio		=	strinclude "headers/conio.h"
ichar h_winsock2	=	strinclude "headers/winsock2.h"
ichar h__mingw		=	strinclude "headers/_mingw.h"
!ichar h_shellapi	=	strinclude "headers/shellapi.h"
ichar h_windowsx	=	strinclude "headers/windowsx.h"

global tabledata []ichar stdhdrnames, []ref ichar stdhdrtext =
	("bcc.h",		&h_bcc),
	("assert.h",	&h_assert),
	("ctype.h",		&h_ctype),
	("errno.h",		&h_errno),
	("fenv.h",		&h_fenv),
	("float.h",		&h_float),
	("inttypes.h",	&h_inttypes),
	("stdint.h",	&h_stdint),
	("limits.h",	&h_limits),
	("locale.h",	&h_locale),
	("_ansi.h",		&h__ansi),
	("math.h",		&h_math),
	("setjmp.h",	&h_setjmp),
	("signal.h",	&h_signal),
	("stdarg.h",	&h_stdarg),
	("stdbool.h",	&h_stdbool),
	("stddef.h",	&h_stddef),
	("stdio.h",		&h_stdio),
	("stdlib.h",	&h_stdlib),
	("_syslist.h",	&h__syslist),
	("string.h",	&h_string),
	("time.h",		&h_time),
	("utime.h",		&h_utime),
	("unistd.h",	&h_unistd),
	("safelib.h",	&h_safelib),
	("wchar.h",		&h_wchar),
	("wctype.h",	&h_wctype),
	("sys/types.h",	&h_systypes),
	("sys/stat.h",	&h_sysstat),
	("sys/timeb.h",	&h_systimeb),
	("sys/utime.h",	&h_sysutime),
	("malloc.h",	&h_malloc),
	("windows.h",	&h_windows),
	("fcntl.h",		&h_fcntl),
	("io.h",		&h_io),
	("direct.h",	&h_direct),
	("process.h",	&h_process),
	("memory.h",	&h_memory),
	("conio.h",		&h_conio),
	("winsock2.h",	&h_winsock2),
	("_mingw.h",	&h__mingw),
!	("shellapi.h",	&h_shellapi),
	("windowsx.h",	&h_windowsx)
end

global function findheader(ichar name)ichar=
	int i
	[256]char newname
	ichar s,t

	if strchr(name,'\\') then
		s:=name; t:=&.newname
		while s^ do
			if s^='\\' then
				t++^:='/'
			else
				t++^:=s^
			fi
			++s
		od
		t^:=0
		name:=&.newname
	fi

	for i:=1 to stdhdrnames.len do
		if eqstring(name,stdhdrnames[i]) then
			return stdhdrtext[i]^
		fi
	od
	return nil
end

global proc writeheaders=
filehandle f
ichar ifile
int i
for i:=1 to stdhdrnames.len do
	ifile:=changeext(stdhdrnames[i],"hdr")
	println "Writing internal",stdhdrnames[i],"as",ifile
	f:=fopen(ifile,"wb")
	fwrite(stdhdrtext[i]^,1,strlen(stdhdrtext[i]^),f)
	fclose(f)
od
end

global proc checkbcclib=
const libfile="bcclib.asm"
filehandle f

if not checkfile(libfile) then
	println "Writing",libfile
	f:=fopen(libfile,"wb")
	fwrite(bcclibstr,1,strlen(bcclibstr),f)
	fclose(f)
fi
end

global function getbcclib:ichar=
	ichar s
	int slen

	slen:=strlen(bcclibstr)
	s:=malloc(slen+1)
	memcpy(s,bcclibstr,slen+1)

	return s
end

global function isheaderfile(ichar file)int=
for i:=1 to stdhdrnames.len do
	if eqstring(stdhdrnames[i],file) then
		return 1
	fi
od
return 0
end
=== bcclib.asm 13/77 ===
;	bcc support library

;Offsets in buffer:
kreturn	= 0
kstack	= 8
kframe	= 16

	segment code
$mccsetjmp::

;on entry to setjmp:
;Dstack		points to return address
;D10		points to address of buffer to store restore info
;Caller will have subtracted 32 from Dstack, and will add it again on return

; Store current state

	mov [D10+kstack],Dstack
	mov [D10+kframe],Dframe
	mov D0,[Dstack]			; return address
	mov [D10+kreturn],D0

	mov	A0,0
	ret

$mcclongjmp::

;on entry to longjmp:
;Dstack		points to return address
;D10		points to address of buffer containing store restore info
;D11		has return value to use
;Caller will have subtracted 32 from Dstack, and will add it again on return

; Restore state as it was on call to setjmp


	mov Dstack,[D10+kstack]		; restore stack value
	mov Dframe,[D10+kframe]		; restore frame ptr

	mov D0,[D10+kreturn]		; stored return address
	mov [Dstack+0],D0			; replace return address, as it will return elsewhere
	mov A0,A11					; return value (from 'setjmp', as it will be)

	ret

;Float routines for unsigned
;Input passed in D10
;Output in XMM15

m$ufloat_r64u32::
	mov D10,D10					; clear top half (already done if value just moved there)
	cvtsi2sd XMM15,D10
	ret

m$ufloat_r32u32::
	mov D10,D10
	cvtsi2ss XMM15,D10
	ret

m$ufloat_r64u64::
	cmp D10,0
	jl fl1
;number is positive, so can treat like i64
	cvtsi2sd XMM15,D10
	ret
fl1:						;negative value
	and D10,[mask63]		;clear top bit (subtract 2**63)
	cvtsi2sd XMM15,D10
	addsd XMM15,[offset64]	;(add 2**63 back to result)
	ret

m$ufloat_r32u64::
	cmp D10,0
	jl fl2
;number is positive, so can treat like i64
	cvtsi2ss XMM15,D10
	ret
fl2:						;negative value
	and D10,[mask63]		;clear top bit (subtract 2**63)
	cvtsi2ss XMM15,D10
	addss XMM15,[offset32]	;(add 2**63 back to result)
	ret

	segment idata
mask63:
	dq 0x7fffffffffffffff
offset64:
	dq 9223372036854775808.0		! 2**63 as r64
offset32:
	dd 9223372036854775808.0		; 2**63 as r32

	segment code
__rdtsc::
!	rdtsc
	mov eax,eax
	shl rdx,32
	or rax,rdx
	ret

	segment zdata
callbackstack:
	resb 576			!8-level stack
;	resb 5'120'000

ncallbacks:
	resb 4

segment code

m$pushcallback::
	inc dword [ncallbacks]
	mov A2,[ncallbacks]
	shl A2,6					!8x8 bytes is size per entry
	lea D2,[A2+callbackstack]

	mov [D2],rbx
	mov [D2+8],rsi
	mov [D2+16],rdi

	mov [D2+24],r12
	mov [D2+32],r13
	mov [D2+40],r14
	mov [D2+48],r15
	ret

m$popcallback::
	mov A2,[ncallbacks]
	shl A2,6					!8x8 bytes is size per entry
	lea D2,[A2+callbackstack]

	mov rbx,[D2]
	mov rsi,[D2+8]
	mov rdi,[D2+16]

	mov r12,[D2+24]
	mov r13,[D2+32]
	mov r14,[D2+40]
	mov r15,[D2+48]
	dec dword [ncallbacks]
	ret


=== assert.h 14/77 ===
/* Header assert.h */

//#define assert(x) 0
#define assert(x)
=== ctype.h 15/77 ===
/* Header ctype.h */

int tolower(int);
int toupper(int);
int isalpha(int);
int isdigit(int);
int isspace(int);
int isalnum(int);
int isupper(int);
int islower(int);

int isxdigit(int);
int iscntrl(int);
int isgraph(int);
int ispunct(int);
int isprint(int);
int __isascii(int);
#define isascii __isascii

int __toascii(int);
#define toascii __toascii
=== errno.h 16/77 ===
/* Header errno.h */

#ifndef $errno
#define $errno

extern int* _errno(void);
#define errno (*_errno())

#define EPERM 1
#define ENOENT 2
#define ESRCH 3
#define EINTR 4
#define EIO 5
#define ENXIO 6
#define E2BIG 7
#define ENOEXEC 8
#define EBADF 9
#define ECHILD 10
#define EAGAIN 11
#define ENOMEM 12
#define EACCES 13
#define EFAULT 14
#define ENOTBLK 15
#define EBUSY 16
#define EEXIST 17
#define EXDEV 18
#define ENODEV 19
#define ENOTDIR 20
#define EISDIR 21
#define EINVAL 22
#define ENFILE 23
#define EMFILE 24
#define ENOTTY 25
#define ETXTBSY 26
#define EFBIG 27
#define ENOSPC 28
#define ESPIPE 29
#define EROFS 30
#define EMLINK 31
#define EPIPE 32
#define EDOM 33
#define ERANGE 34
#define ENOMSG 35
#define EIDRM 36
#define ECHRNG 37
#define EL2NSYNC 38
#define EL3HLT 39
#define EL3RST 40
#define ELNRNG 41
#define EUNATCH 42
#define ENOCSI 43
#define EL2HLT 44
#define EDEADLK 45
#define ENOLCK 46
#define EBADE 50
#define EBADR 51
#define EXFULL 52
#define ENOANO 53
#define EBADRQC 54
#define EBADSLT 55
#define EDEADLOCK 56
#define EBFONT 57
#define ENOSTR 60
#define ENODATA 61
#define ETIME 62
#define ENOSR 63
#define ENONET 64
#define ENOPKG 65
#define EREMOTE 66
#define ENOLINK 67
#define EADV 68
#define ESRMNT 69
#define ECOMM 70
#define EPROTO 71
#define EMULTIHOP 74
#define ELBIN 75
#define EOVERFLOW 76
#define EBADMSG 77
#define ENOTUNIQ 80
#define EBADFD 81
#define EREMCHG 82
#define ELIBACC 83
#define ELIBBAD 84
#define ELIBSCN 85
#define ELIBMAX 86
#define ELIBEXEC 87
#define ENOSYS 88
#define ENMFILE 89
#define ENOTEMPTY 90
#define ENAMETOOLONG 91
#define EILSEQ 92
#define __ELASTERROR 2000

#endif
=== fenv.h 17/77 ===
/* Header fenv.h */

int feclearexcept(int);
int fetestexcept(int);

#define FE_INVALID 1
#define FE_DENORMAL 2
#define FE_INEXACT 32
#define FE_DIVBYZERO 4 
#define FE_OVERFLOW 8
#define FE_UNDERFLOW 16
#define FE_STACKFAULT 64
#define FE_ALL_EXCEPT (FE_INVALID|FE_DENORMAL|FE_INEXACT|FE_DIVBYZERO|FE_OVERFLOW|FE_UNDERFLOW)
=== float.h 18/77 ===
/* Header float.h */

//#define DBL_MAX_10_EXP 308
//#define DBL_MANT_DIG 53

#define FLT_RADIX 2

#define FLT_DIG 6
#define FLT_MIN_EXP -125
#define FLT_MIN 1.17549435E-38F // decimal constant
#define FLT_MIN 0X1P-126F // hex constant
#define FLT_TRUE_MIN 1.40129846E-45F // decimal constant
#define FLT_TRUE_MIN 0X1P-149F // hex constant
#define FLT_HAS_SUBNORM 1
#define FLT_MIN_10_EXP -37
#define FLT_MAX_EXP +128
#define FLT_MAX 3.40282347E+38F // decimal constant
#define FLT_MAX 0X1.fffffeP127F // hex constant
#define FLT_MAX_10_EXP +38
#define FLT_EPSILON 1.19209290e-07F
#define FLT_MANT_DIG 23

#define DBL_MANT_DIG 53
#define DBL_EPSILON 2.2204460492503131E-16 // decimal constant
//#define DBL_EPSILON 0X1P-52 // hex constant
#define DBL_DECIMAL_DIG 17
#define DBL_DIG 15
#define DBL_MIN_EXP -1021
#define DBL_MIN 2.2250738585072014E-308 // decimal constant
//#define DBL_MIN 0X1P-1022 // hex constant
#define DBL_TRUE_MIN 4.9406564584124654E-324 // decimal constant
//#define DBL_TRUE_MIN 0X1P-1074 // hex constant
#define DBL_HAS_SUBNORM 1
#define DBL_MIN_10_EXP -307
#define DBL_MAX_EXP +1024
#define DBL_MAX 1.7976931348623157E+308 // decimal constant
//#define DBL_MAX 0X1.fffffffffffffP1023 // h
#define DBL_MAX_10_EXP +308

#define LDBL_MIN DBL_MIN
#define LDBL_MAX DBL_MAX
#define LDBL_EPSILON 2.2204460492503131E-16
#define LDBL_MANT_DIG 53
#define LDBL_MIN_EXP -1021
#define LDBL_MAX_EXP +1024

int     _isnan(double);
#define isnan _isnan
=== inttypes.h 19/77 ===
/* Header inttypes.h */

#include <stdint.h>

/* fprintf macros for signed types */
#define PRId8 "d"
#define PRId16 "d"
#define PRId32 "d"
#define PRId64 "I64d"

#define PRIdLEAST8 "d"
#define PRIdLEAST16 "d"
#define PRIdLEAST32 "d"
#define PRIdLEAST64 "I64d"

#define PRIdFAST8 "d"
#define PRIdFAST16 "d"
#define PRIdFAST32 "d"
#define PRIdFAST64 "I64d"

#define PRIdMAX "I64d"

#define PRIi8 "i"
#define PRIi16 "i"
#define PRIi32 "i"
#define PRIi64 "I64i"

#define PRIiLEAST8 "i"
#define PRIiLEAST16 "i"
#define PRIiLEAST32 "i"
#define PRIiLEAST64 "I64i"

#define PRIiFAST8 "i"
#define PRIiFAST16 "i"
#define PRIiFAST32 "i"
#define PRIiFAST64 "I64i"

#define PRIiMAX "I64i"

#define PRIo8 "o"
#define PRIo16 "o"
#define PRIo32 "o"
#define PRIo64 "I64o"

#define PRIoLEAST8 "o"
#define PRIoLEAST16 "o"
#define PRIoLEAST32 "o"
#define PRIoLEAST64 "I64o"

#define PRIoFAST8 "o"
#define PRIoFAST16 "o"
#define PRIoFAST32 "o"
#define PRIoFAST64 "I64o"

#define PRIoMAX "I64o"

/* fprintf macros for unsigned types */
#define PRIu8 "u"
#define PRIu16 "u"
#define PRIu32 "u"
#define PRIu64 "I64u"


#define PRIuLEAST8 "u"
#define PRIuLEAST16 "u"
#define PRIuLEAST32 "u"
#define PRIuLEAST64 "I64u"

#define PRIuFAST8 "u"
#define PRIuFAST16 "u"
#define PRIuFAST32 "u"
#define PRIuFAST64 "I64u"

#define PRIuMAX "I64u"

#define PRIx8 "x"
#define PRIx16 "x"
#define PRIx32 "x"
#define PRIx64 "I64x"

#define PRIxLEAST8 "x"
#define PRIxLEAST16 "x"
#define PRIxLEAST32 "x"
#define PRIxLEAST64 "I64x"

#define PRIxFAST8 "x"
#define PRIxFAST16 "x"
#define PRIxFAST32 "x"
#define PRIxFAST64 "I64x"

#define PRIxMAX "I64x"

#define PRIX8 "X"
#define PRIX16 "X"
#define PRIX32 "X"
#define PRIX64 "I64X"

#define PRIXLEAST8 "X"
#define PRIXLEAST16 "X"
#define PRIXLEAST32 "X"
#define PRIXLEAST64 "I64X"

#define PRIXFAST8 "X"
#define PRIXFAST16 "X"
#define PRIXFAST32 "X"
#define PRIXFAST64 "I64X"

#define PRIXMAX "I64X"

=== stdint.h 20/77 ===
/* Header stdint.h */

#ifndef $stdint
#define $stdint

typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long long int int64_t;

typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long int uint64_t;

typedef long long int intptr_t;
typedef unsigned long long int uintptr_t;
typedef long long intmax_t;
typedef unsigned long long uintmax_t;

typedef char int_least8_t;
typedef unsigned char uint_least8_t;
typedef short int_least16_t;
typedef unsigned short uint_least16_t;
typedef int int_least32_t;
typedef unsigned int uint_least32_t;
typedef long long int_least64_t;
typedef unsigned long long uint_least64_t;

#define INTMAX_C(a) (a##LL)
#define UINTMAX_C(a) (a##ULL)

typedef char int_fast8_t;
typedef unsigned char uint_fast8_t;
typedef short int_fast16_t;
typedef unsigned short uint_fast16_t;
typedef int int_fast32_t;
typedef unsigned int uint_fast32_t;
typedef long long int_fast64_t;
typedef unsigned long long uint_fast64_t;


#define INT8_MIN -128
#define INT8_MAX 127
#define INT16_MIN -32768
#define INT16_MAX 32767
#define INT32_MIN 0x80000000
#define INT32_MAX 0x7FFFFFFF
#define INT64_MIN 0x8000000000000000
#define INT64_MAX 0x7FFFFFFFFFFFFFFF

#define UINT8_MAX 255
#define UINT16_MAX 65535
#define UINT32_MAX 0xFFFFFFFF
#define UINT64_MAX 0xFFFFFFFFFFFFFFFF

#define INTPTR_MIN 0x8000000000000000
#define INTPTR_MAX 0x7FFFFFFFFFFFFFFF
#define UINTPTR_MAX 0xFFFFFFFFFFFFFFFF

#define UINT64_MAX 0xFFFFFFFFFFFFFFFF
#define SIZE_MAX 0xFFFFFFFFFFFFFFFF

#define PTRDIFF_MIN 0x8000000000000000
#define PTRDIFF_MAX 0x7FFFFFFFFFFFFFFF

#define WCHAR_MIN 0
#define WCHAR_MAX 65535

#define WINT_MIN 0
#define WINT_MAX 65535

#define UINT64_C(x) (x##ull)

#endif
=== limits.h 21/77 ===
/* Header limits.h */

#define CHAR_BIT 8

#define CHAR_MIN 0
#define CHAR_MAX 255

#define UCHAR_MIN 0
#define UCHAR_MAX 255

#define SCHAR_MIN -128
#define SCHAR_MAX 127

#define SHRT_MIN -32768
#define SHRT_MAX 32767

#define USHRT_MIN 0
#define USHRT_MAX 65536

#define INT_MIN -2147483648
#define INT_MAX  2147483647

#define UINT_MIN 0
#define UINT_MAX 4294967295

#define LONG_MIN -2147483648
#define LONG_MAX  2147483647

#define ULONG_MIN 0
#define ULONG_MAX 4294967295

#define LLONG_MIN -9223372036854775808LL
#define LLONG_MAX  9223372036854775807LL

#define ULLONG_MIN 0
#define ULLONG_MAX 0xFFFFFFFFFFFFFFFFLL
=== locale.h 22/77 ===
/* Header locale.h */

#ifndef $locale
#define $locale

#define LC_ALL 0
#define LC_COLLATE 1
#define LC_CTYPE 2
#define LC_MONETARY 3
#define LC_NUMERIC 4
#define LC_TIME 5

struct lconv {
	char *decimal_point;
	char *thousands_sep;
	char *grouping;
	char *int_curr_symbol;
	char *currency_symbol;
	char *mon_decimal_point;
	char *mon_thousands_sep;
	char *mon_grouping;
	char *positive_sign;
	char *negative_sign;
	char int_frac_digits;
	char frac_digits;
	char p_cs_precedes;
	char p_sep_by_space;
	char n_cs_precedes;
	char n_sep_by_space;
	char p_sign_posn;
	char n_sign_posn;
};
char *setlocale(int category, const char *locale);

struct lconv *localeconv(void);

char * setlocale(int,const char *);
#endif
=== _ansi.h 23/77 ===
/* Header _ansi.h */
=== math.h 24/77 ===
/* Header math.h */

#define HUGE_VAL 1.7976931348623156e+308

double floor(double);
double ceil(double);
double sqrt(double);
double sin(double);
double cos(double);
double tan(double);
double fmod(double,double);
double asin(double);
double acos(double);
double atan(double);
double log(double);
double log10(double);
double exp(double);
double modf(double,double*);
double atan2(double,double);
double pow(double,double);
double fabs(double);
double sinh(double);
double cosh(double);
double tanh(double);
double frexp(double,int*);
double ldexp(double,int);
int isnan(double);

float sinf(float);
float cosf(float);
float tanf(float);

float sqrtf(float);
float acosf(float);
float atan2f(float,float);
float ceilf(float);

double acosh (double);
long double acoshl(long double);
long double acoshl(long double);
float acoshf(float);

double asinh (double);
long double asinhl(long double);
long double sinhl(long double);
float asinhf(float);

double atanh(double);
long double atanhl(long double);
float atanhf(float);

long double expm1l(long double);
double expm1(double);
float expm1f(float);
double _expm1i(int);

double cbrt(double);
long double cbrtl(long double);
float cbrtf(float);

double trunc(double x);
long double truncl(long double);
float truncf(float);

double round(double);
float roundf(float);
long double roundl(long double);
double _roundi(int);

long double fminl(long double,long double);
float fminf(float ,float);
double fmin(double,double);
float fabsf(float);

double lgamma (double);
long double lgammal(long double);
float lgammaf(float);

long double tgammal(long double);
double tgamma(double);
float tgammaf(float);

double log1p(double);
long double log1pl(long double);
float log1pf(float);

long double log10l(long double);
float log10f(float);
double _log10i(int);
double log10(double);

double erf(double);
long double erfl(long double);
float erff(float);

double hypot (double, double);
double _hypot(double,double);
long double hypotl(long double,long double);
float hypotf(float,float);

double nextafter (double, double);
long double nextafterl(long double,long double);
float nextafterf(float,float);

double nexttoward(double,long double);
long double nexttowardl(long double,long double);
float nexttowardf(float,long double);

double erfc(double);
long double erfcl(long double);
float erfcf(float);

int _finite(double);
#define finite _finite

float floorf(float);

double _copysign(double,double);
#define copysign _copysign

long double fmaxl(long double,long double);
double fmax(double,double);
float fmaxf(float,float);
float fmodf(float,float);

//long double exp2l(long double);
double exp2(double);
float exp2f(float);

//double log2(double);
#define log2(x) (log(x)*1.442695041)

#define M_PI 3.1415926535897932384625433
#define M_PI_2 (M_PI/2.0)
#define M_2_PI 0.63661977236758134308

int isinf(double);

int _finite(double);

#define isfinite _finite

int isfinitef(float);
int isfinitel(long double);

=== setjmp.h 25/77 ===
/* Header setjmp.h */


#ifndef $setjmp
#define $setjmp 1

typedef int jmp_buf[128];

//void longjmp(char*, int);

//void $mcclongjmp(char*, int);
void $mcclongjmp(jmp_buf, int);

//int $mccsetjmp(char*);
int $mccsetjmp(jmp_buf);


//int	_setjmp(char*);
//int	setjmp(char*);

#define setjmp $mccsetjmp
#define longjmp $mcclongjmp

#endif

=== signal.h 26/77 ===
/* Header signal.h */

#define SIGINT    2
#define SIGILL    4
#define SIGFPE    8
#define SIGSEGV  11
#define SIGTERM  15
#define SIGBREAK 21
#define SIGABRT  22

#define SIG_DFL (void (*)(int))0
#define SIG_IGN (void (*)(int))1
#define SIG_SGE (void (*)(int))3
#define SIG_ACK (void (*)(int))4

#define SIG_ERR (void (*)(int))-1

extern void (*signal(int, void (*)(int)))(int);

extern int raise(int);


typedef int sig_atomic_t;
=== stdarg.h 27/77 ===
/* Header stdarg.h */

#ifndef $STDARG
 #define $STDARG

//coded for x64 target as used by mcc (with first four params also on stack)

 typedef char *	va_list;
 #define va_start(ap,v) ap=((va_list)&v+8)
 #define va_arg(ap,t) *(t*)((ap+=8)-8)
 #define va_copy(dest,src) (dest=src)
 #define va_end(ap)	( ap = (va_list)0 )
#endif
=== stdbool.h 28/77 ===
/* Header stdbool.h */

#define bool unsigned char
#define true 1
#define false 0


=== stddef.h 29/77 ===
/* Header stddef.h */

#ifndef $stddef
#define $stddef

typedef signed long long int ssize_t;
typedef unsigned long long int size_t;

#define _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
//typedef signed short wchar_t;

#define NULL ((void*)0)

#define offsetof(a,b) (size_t) &( ((a*)0) -> b)

typedef long long int ptrdiff_t;

#endif // stddef
=== stdio.h 30/77 ===
/* Header stdio.h */

#ifndef $stdio
#define $stdio 1

#define __attribute__(x)

#ifndef $valist
	typedef char* va_list;
	#define $valist
#endif

#include <stddef.h>

typedef long long int fpos_t;

#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2

#define	STDIN_FILENO	0
#define	STDOUT_FILENO	1
#define	STDERR_FILENO	2

#define EOF (-1)
#define FILENAME_MAX 260

#define L_tmpnam 10

typedef struct {
	char *_ptr;
	int   _cnt;
	char *_base;
	int   _flag;
	int   _file;
	int   _charbuf;
	int   _bufsiz;
	char *_tmpfname;
} FILE;

extern char* __iob_func(void);

#define stdin ((FILE*)(__iob_func()))
#define stdout ((FILE*)(__iob_func()+sizeof(FILE)))
#define stderr ((FILE*)(__iob_func()+sizeof(FILE)*2))

#define _IOREAD 0x0001
#define _IOWRT 0x0002

#define _IOFBF 0x0000
#define _IOLBF 0x0040
#define _IONBF 0x0004

#define _IOMYBUF 0x0008
#define _IOEOF 0x0010
#define _IOERR 0x0020
#define _IOSTRG 0x0040
#define _IORW 0x0080

#define BUFSIZ 512

FILE* fopen(const char*, const char*);
int fclose(FILE*);
long ftell(FILE*);
long long int _ftelli64(FILE*);
int fseek(FILE*,long,int);
int _fseeki64(FILE*,long long int,int);

size_t fread(void*, size_t, size_t, FILE*);
size_t fwrite(const void*, size_t, size_t, FILE*);
int remove(const char*);
int rename(const char *,const char *);
FILE* freopen(const char*, const char*, FILE*);
FILE* _wfopen(const wchar_t*,const wchar_t *);

int printf(const char*, ...);
int sprintf(char*,const char*, ...);
int fprintf(FILE*,const char*, ...);
int sscanf(const char*, const char*, ...);
int scanf(const char*, ...);
int fscanf(FILE *,const char *, ...);
int _snprintf(char *,size_t,const char*,...);
#define snprintf _snprintf
int _vsnprintf(char*, size_t, const char*, va_list);
int vsnprintf(char*,size_t,const char*,va_list);
int vsprintf(char*, const char*, va_list);
int _wremove(const wchar_t*);
int _wrename(const wchar_t*,const wchar_t*);

typedef char* va_list;

int vfprintf(FILE*, const char*, va_list);
int vprintf(const char*, va_list);

int puts(const char*);
char* fgets(char*, int, FILE*);
int fputs(const char*, FILE*);
int fgetc(FILE*);
int fputc(int, FILE*);
int ungetc(int, FILE*);
int getchar(void);
int putchar(int);
int fflush(FILE *);
int getc(FILE *);
int putc(int, FILE *);

int feof(FILE*);
int ferror(FILE*);
void clearerr(FILE*);

int fileno(FILE*);
int _fileno(FILE*);
int setvbuf(FILE*,char*,int,size_t);
FILE* _popen(const char*, const char*);
int _pclose(FILE*);
int _unlink(const char *);
#define unlink _unlink;
FILE* _fdopen(int, const char *);
#define fdopen _fdopen
int fgetpos(FILE*, fpos_t*);
int fsetpos(FILE*, const fpos_t*);
void perror(char*);
void setbuf(FILE*, char*);

void rewind(FILE*);

FILE* tmpfile(void);

char* tmpnam(char*);
wchar_t getwc(FILE *);

extern void* _wenviron;

#endif

=== stdlib.h 31/77 ===
/* Header stdlib.h */

#ifndef $stdlib
#define $stdlib 1

#include <stddef.h>

#define EXIT_FAILURE 1
#define EXIT_SUCCESS 0

#define RAND_MAX 32767

void* malloc(size_t);
void* realloc(void*, size_t);
void* calloc(size_t, size_t);

void free(void*);

void exit(int);

int system(const char*);
int _wsystem(const wchar_t*);

int abs(int);
long labs(long);
long long llabs(long);
int rand(void);
void srand(unsigned int);
int atoi(const char*);
long atol(const char*);
double atof(const char *);
int	atexit(void (*)(void));

void qsort(void*, size_t, size_t, int (*)(void*, void*));

typedef struct {
	long long int quot;
	long long int rem;
} lldiv_t;

lldiv_t lldiv(long long int, long long int);

char* getenv(const char*);
wchar_t* _wgetenv(const wchar_t*);
int _wputenv(const wchar_t*);


double strtod(const char*, char**);

//float strtof(const char *, char**);
#define strtof strtod

long double strtold(const char*, char**);
void abort(void);
long int strtol(const char*, char**, int);

long double strtold(const char *,char **);

long long int _strtoi64(const char *,char **,int);
#define strtoll _strtoi64

unsigned long long int _strtoui64(const char *,char **,int);

unsigned long long int strtoull(const char*, char**, int);
unsigned long strtoul(const char*, char**, int);

size_t _msize(void *);
#define msize _msize

void* bsearch(const void *,const void *, size_t, size_t,
		int (*_compar)(const void *,const void *));


#endif
=== _syslist.h 32/77 ===
/* Header _syslist.h */
=== string.h 33/77 ===
/* Header string.h */

#include <stddef.h>

void* memcpy(void*, const void*, size_t);
void* memmove(const void*, const void*, size_t);
void* memset(void*, int, size_t);
int memcmp(const void*, const void*, size_t);
void* memchr(const void *, int, size_t);

size_t strlen(const char*);
char* strcpy(char*, const char*);
char* strncpy(char*, const char*, size_t);
char* strcat(char*, const char*);
int strcmp(const char*, const char*);
int strncmp(const char*, const char*, size_t);
char* strchr(const char*, int);
char* strstr(const char*, const char*);
char* strrchr(const char*, int);
int _stricmp(const char*, const char*);
#define stricmp _stricmp

int _strnicmp(const char*, const char*, size_t);
#define strnicmp _strnicmp
char* strncat(char*, const char*, size_t);
char* strtok(char*, const char*);

size_t strcspn(const char*, const char*);
size_t strspn(const char*, const char*);
int strcoll(const char *, const char *);

unsigned long strtoul(const char*, char**, int);

char* strerror(int);
char* strpbrk(const char*, const char*);
size_t strxfrm(char*, const char *, size_t);

char* _strupr(char*);
char* _strlwr(char*);
#define strupr _strupr
#define strlwr _strlwr

char*strnupr(char*,size_t);
char*strnlwr(char*,size_t);
int strtrim(char*);
char*strrev(char*);

char* _strdup(const char*);
#define strdup _strdup

int _wcsicmp(const wchar_t *,const wchar_t *);

wchar_t *wcspbrk(const wchar_t*,const wchar_t*);

size_t wcslen(const wchar_t*);
=== time.h 34/77 ===
/* Header time.h */

#ifndef $time
#define $time

#include <stddef.h>

typedef long clock_t;
clock_t clock(void);

//typedef long time_t;
#ifndef _TIME_T_DEFINED
#define _TIME_T_DEFINED
typedef long long int time_t;
#endif

struct tm
{
  int	tm_sec;
  int	tm_min;
  int	tm_hour;
  int	tm_mday;
  int	tm_mon;
  int	tm_year;
  int	tm_wday;
  int	tm_yday;
  int	tm_isdst;
};

//struct tm *localtime(time_t*);
struct tm* _localtime32(time_t*);
#define localtime _localtime32

time_t _time64(time_t *_timer);
#define time _time64

#define CLOCKS_PER_SEC 1000

struct tm *gmtime(const time_t*);
size_t strftime(char *, size_t, const char *, const struct tm *);
time_t mktime(struct tm *);
double difftime(time_t, time_t);

char* asctime(const struct tm*);
//char* ctime(const time_t *_time);
char* _ctime64(const time_t *_time);
#define ctime _ctime64

#endif
=== utime.h 35/77 ===
/* utime.h header */

#include <sys/utime.h>
=== unistd.h 36/77 ===
/* unistd.h header */

unsigned int _sleep(unsigned int);
#define sleep _sleep

#define alarm(x) {puts("ALARM"); exit(1);}

int _write(int,void*,unsigned int);
#define write _write

int _close(int);
#define close _close
=== safelib.h 37/77 ===
/* Header safelib.h */
=== wchar.h 38/77 ===
/* Header wchar.h */

#include <stddef.h>


#define _WCHAR_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wchar_t;
//typedef signed short wchar_t;

size_t wcslen(const wchar_t*);
wchar_t* wcscpy(wchar_t*,const wchar_t*);
//wchar_t* _wgetenv(constwchar_t*);
wchar_t* wcstok(wchar_t*,wchar_t*,wchar_t**);
wchar_t* wcstok_s(wchar_t*,wchar_t*,wchar_t**);

wchar_t* wcschr(wchar_t*,wchar_t);
wchar_t* wcsstr(const wchar_t*,const wchar_t*);


int wcscmp(const wchar_t*,const wchar_t*);
typedef long _off_t;
=== wctype.h 39/77 ===
/* Header wctype.h */
=== types.h 40/77 ===
/* types.h */
#ifndef $systypes
#define $systypes 1

typedef long int off_t;
typedef long int ino_t;
typedef unsigned int dev_t;

typedef long long time_t;

#endif
=== stat.h 41/77 ===
/* stat.h */

#ifndef $sysstat
#define $sysstat

#include <stddef.h>

struct _stat {
	unsigned int	st_dev;
	unsigned short	st_ino;
	unsigned short	st_mode;
	short			st_nlink;
	short			st_uid;
	short			st_gid;
	unsigned long	st_rdev;
	unsigned int	st_size;
	unsigned long long int	st_atime;
	unsigned long long int	st_mtime;
	unsigned long long int	st_ctime;
};

#define stat _stat
#define _stati64 _stat

#define _S_IFMT 0xF000
#define _S_IFDIR 0x4000
#define _S_IFCHR 0x2000
#define _S_IFIFO 0x1000
#define _S_IFREG 0x8000
#define _S_IREAD 0x0100
#define _S_IWRITE 0x0080
#define _S_IEXEC 0x0040

#define S_IFMT 0xF000
#define S_IFDIR 0x4000
#define S_IFCHR 0x2000
#define S_IFIFO 0x1000
#define S_IFREG 0x8000
#define S_IREAD 0x0100
#define S_IWRITE 0x0080
#define S_IEXEC 0x0040

#define S_ISCHR(nd) (((nd) & S_IFMT) == S_IFCHR)
#define S_ISDIR(nd) (((nd) & S_IFMT) == S_IFDIR)
#define S_ISFIFO(nd) (((nd) & S_IFMT) == S_IFIFO)
#define S_ISREG(nd) (((nd) & S_IFMT) == S_IFREG)


#define	_S_IRWXU	(_S_IREAD | _S_IWRITE | _S_IEXEC)
#define	_S_IXUSR	_S_IEXEC
#define	_S_IWUSR	_S_IWRITE

#define	S_IRWXU		_S_IRWXU
#define	S_IXUSR		_S_IXUSR
#define	S_IWUSR		_S_IWUSR
#define	S_IRUSR		_S_IRUSR
#define	_S_IRUSR	_S_IREAD

#define S_IRGRP    (S_IRUSR >> 3)
#define S_IWGRP    (S_IWUSR >> 3)
#define S_IXGRP    (S_IXUSR >> 3)
#define S_IRWXG    (S_IRWXU >> 3)

#define S_IROTH    (S_IRGRP >> 3)
#define S_IWOTH    (S_IWGRP >> 3)
#define S_IXOTH    (S_IXGRP >> 3)
#define S_IRWXO    (S_IRWXG >> 3)

//#define	S_ISDIR(m)	(((m) & S_IFMT) == S_IFDIR)
//#define	S_ISFIFO(m)	(((m) & S_IFMT) == S_IFIFO)
//#define	S_ISCHR(m)	(((m) & S_IFMT) == S_IFCHR)
#define	S_IFBLK	0x3000	/* Block: Is this ever set under w32? */
#define	S_ISBLK(m)	(((m) & S_IFMT) == S_IFBLK)
#define	S_ISREG(m)	(((m) & S_IFMT) == S_IFREG)



int stat(const char *, struct stat*);

int _fstati64(int, struct stat*);

int fstat(int, struct stat *);
#define _fstat fstat

int _wstati64(const wchar_t,struct _stati64 *buffer);  



#endif
=== timeb.h 42/77 ===
/* timeb.h */

#ifndef $timeb
#define $timeb

#include <time.h>

struct _timeb {
	time_t time;
	unsigned short millitm;
	short timezone;
	short dstflag;
};
#define timeb _timeb

void _ftime64(struct _timeb*);
#define _ftime _ftime64
#define ftime _ftime64

#endif
=== utime.h 43/77 ===
/* sys/utime.h header */

#ifndef $utime
#define $utime

struct _utimbuf {
	long actime;
	long modtime;
};


#endif
=== memory.h 44/77 ===
#include <malloc.h>
=== windows.h 45/77 ===
#ifndef $windows
#define $windows 1
#include <stdarg.h>
#include <stddef.h>

#define FALSE 0
#define TRUE 1

typedef int BOOL;
typedef BOOL *PBOOL;
#define FAR
#define NEAR
#define Int32x32To64(a,b)(((long long)((long)(a))) *((long long)((long)(b))))


#define DECLARE_HANDLE(n) typedef HANDLE n
#define _WINBASE_
#define WINBASEAPI
typedef int WINBOOL;
typedef unsigned short UINT16;
typedef unsigned short ATOM;
typedef unsigned char BOOLEAN;
typedef unsigned char BYTE;
typedef unsigned long CALTYPE;
typedef unsigned long CALID;
typedef unsigned long long *PULONGLONG;
typedef long long LONG64;
typedef char CCHAR;
typedef char CHAR;
typedef unsigned long COLORREF;
#define CONST const
typedef unsigned long DWORD;

typedef unsigned long ULONG_PTR;
typedef ULONG_PTR *PULONG_PTR;
typedef ULONG_PTR DWORD_PTR;
typedef long long int LONGLONG;
typedef unsigned long long UINT_PTR;
typedef ULONG_PTR SIZE_T;
typedef SIZE_T *PSIZE_T;
typedef unsigned long long int DWORDLONG,*PDWORDLONG;
typedef float FLOAT;
typedef void *HANDLE;
typedef long SCODE,*PSCODE;
typedef double DOUBLE;
typedef HANDLE GLOBALHANDLE;
typedef HANDLE HSTMT;
typedef HANDLE HDBC;
typedef HANDLE HENV;
typedef HANDLE LOCALHANDLE;
typedef HANDLE HTASK;
typedef HANDLE HACCEL;
typedef HANDLE HBITMAP;
typedef HANDLE HBRUSH;
typedef HANDLE HCOLORSPACE;
typedef HANDLE HCONV;
typedef HANDLE HCONVLIST;
typedef HANDLE HCURSOR;
typedef HANDLE HDC;
typedef HANDLE HDDEDATA;
typedef HANDLE HDESK;
typedef HANDLE HWINEVENTHOOK;
typedef HANDLE HDWP;
typedef HANDLE HENHMETAFILE;
typedef int HFILE;
typedef HANDLE HFONT;
typedef HANDLE HGDIOBJ;
typedef HANDLE HGLOBAL;
typedef HANDLE HGLRC;
typedef HANDLE HHOOK;
typedef HANDLE HICON;
typedef HANDLE HIMAGELIST;
typedef HANDLE HINSTANCE;
typedef HANDLE HKEY,*PHKEY;
typedef HANDLE HKL;
typedef HANDLE HLOCAL;
typedef HANDLE HMENU;
typedef HANDLE HMETAFILE;
typedef HANDLE HMODULE;
typedef HANDLE HPALETTE;
typedef HANDLE HPEN;
typedef long HRESULT;
#define _HRESULT_DEFINED
#define SNDMSG SendMessage
typedef HANDLE HRGN;
typedef HANDLE HRSRC;
typedef HANDLE HSZ;
typedef HANDLE HWINSTA;
typedef HANDLE HWND;
typedef int INT;
typedef unsigned short LANGID;
typedef DWORD LCID;
#define _LCID_DEFINED
typedef DWORD LCTYPE;
typedef enum _SYSTEM_POWER_STATE { PowerSystemUnspecified=0,PowerSystemWorking=1,
	PowerSystemSleeping1 =2,PowerSystemSleeping2=3,PowerSystemSleeping3=4,
	PowerSystemHibernate=5,PowerSystemShutdown=6,PowerSystemMaximum=7
} SYSTEM_POWER_STATE,*PSYSTEM_POWER_STATE;
#define POWER_SYSTEM_MAXIMUM 7
typedef enum { PowerActionNone=0,PowerActionReserved,PowerActionSleep,PowerActionHibernate,
	PowerActionShutdown,PowerActionShutdownReset,PowerActionShutdownOff,PowerActionWarmEject
} POWER_ACTION, *PPOWER_ACTION;
typedef enum _DEVICE_POWER_STATE { PowerDeviceUnspecified=0,PowerDeviceD0,PowerDeviceD1,
	PowerDeviceD2,PowerDeviceD3,PowerDeviceMaximum
} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;
#define ES_SYSTEM_REQUIRED	0x1
#define ES_DISPLAY_REQUIRED	0x2
#define ES_USER_PRESENT	0x4
#define ES_CONTINUOUS	0x80000000
typedef DWORD EXECUTION_STATE;
typedef long LONG;
typedef long long USN;
typedef unsigned long long ULONGLONG;
typedef long LPARAM;
typedef BOOL *LPBOOL;
typedef BYTE *LPBYTE;
typedef CONST BYTE *LPCBYTE;
typedef CONST CHAR *LPCCH;
typedef CHAR *LPCH;
typedef COLORREF *LPCOLORREF;
typedef const char *LPCSTR;
typedef unsigned short * LPCOLESTR;
#define OLESTR(str) L##str
typedef unsigned char UCHAR;
typedef signed char SCHAR;
typedef long int SDWORD;
typedef short int SWORD;
typedef unsigned long int UDWORD;
typedef unsigned short int UWORD;
typedef unsigned long ULONG;
typedef unsigned short USHORT;
//#endif
typedef signed short RETCODE;
#define STDAPI
#define STDAPICALLTYPE
#define STDAPIVCALLTYPE
#define STDMETHODCALLTYPE
#define STDAPI_(type) type
#define APIPRIVATE
//#endif /* rc_invoked */
#define CONTROL_C_EXIT STATUS_CONTROL_C_EXIT
#define WC_LINK L"Syslink"
#define WC_SCROLLBARA "ScrollBar"
#define WC_SCROLLBARW L"ScrollBar"
#define WC_IPADDRESSW	L"SysIPAddress32"
#define WC_IPADDRESSA	"SysIPAddress32"
#define WC_NATIVEFONTCTLW	L"NativeFontCtl"
#define WC_NATIVEFONTCTLA	"NativeFontCtl"
#define WC_COMBOBOXEXW	L"ComboBoxEx32"
#define WC_COMBOBOXEXA	"ComboBoxEx32"
#define WC_BUTTONA "Button"
#define WC_BUTTONW L"Button"
#define WC_STATICA "Static"
#define WC_STATICW L"Static"
#define WC_EDITA "Edit"
#define WC_EDITW L"Edit"
#define WC_LISTBOXA "ListBox"
#define WC_LISTBOXW L"ListBox"
#define WC_COMBOBOXA "ComboBox"
#define WC_COMBOBOXW L"ComboBox"
#define SB_GETUNICODEFORMAT	CCM_GETUNICODEFORMAT
#define SB_SETUNICODEFORMAT	CCM_SETUNICODEFORMAT
#define TB_GETUNICODEFORMAT CCM_GETUNICODEFORMAT
#define TB_SETUNICODEFORMAT CCM_SETUNICODEFORMAT
#define TC_NORMAL 0
#define TC_HARDERR 1
#define TC_GP_TRAP 2
#define TC_SIGNAL 3
#ifdef UNICODE
#define WC_EDIT WC_EDITW
#define WC_BUTTON WC_BUTTONW
typedef const unsigned short *LPCTSTR;
typedef unsigned short *LPTCH;
typedef unsigned short *LPTSTR;
typedef unsigned short *PTBYTE;
typedef unsigned short *PTCH;
typedef unsigned short *PTCHAR;
typedef unsigned short *PTSTR;
typedef unsigned short TBYTE;
typedef unsigned short TCHAR;
typedef unsigned short BCHAR;
#define WC_STATIC WC_STATICW
#define WC_LISTBOX WC_LISTBOXW
#define WC_COMBOBOX WC_COMBOBOXW
#define ANYSIZE_ARRAY 1
#define TEXT(quote) L##quote
#define SERVICES_ACTIVE_DATABASE	SERVICES_ACTIVE_DATABASEW
#define SERVICES_FAILED_DATABASE	SERVICES_FAILED_DATABASEW
#define SC_GROUP_IDENTIFIER	SC_GROUP_IDENTIFIERW
#define HDM_GETITEM HDM_GETITEMW
#define HDM_INSERTITEM HDM_INSERTITEMW
#define HDM_SETITEM HDM_SETITEMW
#define HDM_SETUNICODEFORMAT CCM_SETUNICODEFORMAT
#define HDM_GETUNICODEFORMAT CCM_GETUNICODEFORMAT
#define ACM_OPEN ACM_OPENW
#define HDN_BEGINTRACK HDN_BEGINTRACKW
#define HDN_DIVIDERDBLCLICK HDN_DIVIDERDBLCLICKW
#define HDN_ENDTRACK HDN_ENDTRACKW
#define HDN_ITEMCHANGED HDN_ITEMCHANGEDW
#define HDN_ITEMCHANGING HDN_ITEMCHANGINGW
#define HDN_ITEMCLICK HDN_ITEMCLICKW
#define HDN_ITEMDBLCLICK HDN_ITEMDBLCLICKW
#define HDN_GETDISPINFO	HDN_GETDISPINFOW
#define HDN_TRACK HDN_TRACKW
#define WC_COMBOBOXEX	WC_COMBOBOXEXW
#define WC_IPADDRESS	WC_IPADDRESSW
#define WC_SCROLLBAR	WC_SCROLLBARW
#define GetSystemWindowsDirectory GetSystemWindowsDirectoryW
#define IPN_FIELDCHANGED	(IPN_FIRST - 0)
#define MAKEIPRANGE(low, high)	((LPARAM)(WORD)(((BYTE)(high) << 8) + (BYTE)(low)))
#define MAKEIPADDRESS(b1,b2,b3,b4)	((LPARAM)(((DWORD)(b1)<<24)+((DWORD)(b2)<<16)+((DWORD)(b3)<<8)+((DWORD)(b4))))
#define FIRST_IPADDRESS(x)	((x>>24) & 0xff)
#define SECOND_IPADDRESS(x)	((x>>16) & 0xff)
#define THIRD_IPADDRESS(x)	((x>>8) & 0xff)
#define FOURTH_IPADDRESS(x)	(x & 0xff)
#define LVM_EDITLABEL LVM_EDITLABELW
#define	LVM_FINDITEM	LVM_FINDITEMW
#define	LVM_GETCOLUMN	LVM_GETCOLUMNW
#define	LVM_GETITEMTEXT	LVM_GETITEMTEXTW
#define	LVM_GETSTRINGWIDTH	LVM_GETSTRINGWIDTHW
#define	LVM_INSERTCOLUMN	LVM_INSERTCOLUMNW
#define	LVM_SETCOLUMN	LVM_SETCOLUMNW
#define	LVM_SETITEMTEXT	LVM_SETITEMTEXTW
#define	LVM_EDITLABEL	LVM_EDITLABELW
#define	LVM_GETBKIMAGE	LVM_GETBKIMAGEW
#define	LVM_GETISEARCHSTRING	LVM_GETISEARCHSTRINGW
#define	LVM_GETITEM	LVM_GETITEMW
#define	LVM_INSERTITEM	LVM_INSERTITEMW
#define	LVM_SETBKIMAGE	LVM_SETBKIMAGEW
#define	LVM_SETITEM	LVM_SETITEMW
#define LVN_BEGINLABELEDIT LVN_BEGINLABELEDITW
#define LVN_ENDLABELEDIT LVN_ENDLABELEDITW
#define LVN_GETDISPINFO LVN_GETDISPINFOW
#define LVN_SETDISPINFO LVN_SETDISPINFOW
#define LVN_ODFNDITEM LVN_ODFINDITEMW
#define LVN_HOTTRACK	(LVN_FIRST+21)
#define PSM_SETFINISHTEXT PSM_SETFINISHTEXTW
#define PSM_SETTITLE PSM_SETTITLEW
#define SB_GETTEXT SB_GETTEXTW
#define SB_GETTEXTLENGTH SB_GETTEXTLENGTHW
#define SB_SETTEXT SB_SETTEXTW
#define TB_ADDSTRING TB_ADDSTRINGW
#define TB_GETBUTTONTEXT TB_GETBUTTONTEXTW
#define TB_SAVERESTORE TB_SAVERESTOREW
#define TBBUTTONINFO TBBUTTONINFOW
#define LPTBBUTTONINFO LPTBBUTTONINFOW
#define DESKTOPENUMPROC DESKTOPENUMPROCW
#define TBN_GETBUTTONINFO TBN_GETBUTTONINFOW
#define TBN_GETDISPINFO	TBN_GETDISPINFOW
#define TCM_GETITEM TCM_GETITEM
#define TCM_INSERTITEM TCM_INSERTITEMW
#define TCM_SETITEM TCM_SETITEMW
#define TTM_ADDTOOL TTM_ADDTOOLW
#define TTM_DELTOOL TTM_DELTOOLW
#define TTM_ENUMTOOLS TTM_ENUMTOOLSW
#define TTM_GETCURRENTTOOL TTM_GETCURRENTTOOLW
#define TTM_GETTEXT TTM_GETTEXTW
#define TTM_GETTOOLINFO TTM_GETTOOLINFOW
#define TTM_HITTEST TTM_HITTESTW
#define TTM_NEWTOOLRECT TTM_NEWTOOLRECTW
#define TTM_SETTOOLINFO TTM_SETTOOLINFOW
#define TTM_UPDATETIPTEXT TTM_UPDATETIPTEXTW
#define TTN_NEEDTEXT TTN_NEEDTEXTW
#define TTN_GETDISPINFO	TTN_GETDISPINFOW
#define TVM_EDITLABEL TVM_EDITLABELW
#define TVM_GETISEARCHSTRING TVM_GETISEARCHSTRINGW
#define TVM_GETITEM TVM_GETITEMW
#define TVM_INSERTITEM TVM_INSERTITEMW
#define TVM_SETITEM TVM_SETITEMW
#define TVN_BEGINDRAG TVN_BEGINDRAGW
#define TVN_BEGINLABELEDIT TVN_BEGINLABELEDITW
#define TVN_BEGINRDRAG TVN_BEGINRDRAGW
#define TVN_DELETEITEM TVN_DELETEITEMW
#define TVN_ENDLABELEDIT TVN_ENDLABELEDITW
#define TVN_GETDISPINFO TVN_GETDISPINFOW
#define TVN_ITEMEXPANDED TVN_ITEMEXPANDEDW
#define TVN_ITEMEXPANDING TVN_ITEMEXPANDINGW
#define TVN_SELCHANGED TVN_SELCHANGEDW
#define TVN_SELCHANGING TVN_SELCHANGINGW
#define TVN_SETDISPINFO TVN_SETDISPINFOW
#define ANIMATE_CLASS ANIMATE_CLASSW
#define HOTKEY_CLASS HOTKEY_CLASSW
#define PROGRESS_CLASS PROGRESS_CLASSW
#define STATUSCLASSNAME STATUSCLASSNAMEW
#define REBARCLASSNAME REBARCLASSNAMEW
#define REBARBANDINFO REBARBANDINFOW
#define TOOLBARCLASSNAME TOOLBARCLASSNAMEW
#define TOOLTIPS_CLASS TOOLTIPS_CLASSW
#define TRACKBAR_CLASS TRACKBAR_CLASSW
#define UPDOWN_CLASS UPDOWN_CLASSW
#define WC_HEADER WC_HEADERW
#define WC_NATIVEFONTCTL	WC_NATIVEFONTCTLA
#define WC_LISTVIEW WC_LISTVIEWW
#define WC_TABCONTROL WC_TABCONTROLW
#define WC_TREEVIEW WC_TREEVIEWW
#define LPSTR_TEXTCALLBACK LPSTR_TEXTCALLBACKW
#define RB_INSERTBAND	RB_INSERTBANDW
#define RB_SETBANDINFO	RB_SETBANDINFOW
#define LPREBARBANDINFO	LPREBARBANDINFOW
#define NMLVDISPINFO NMLVDISPINFOW
#define LVN_GETINFOTIP	LVN_GETINFOTIPW
#define NMLVGETINFOTIP	NMLVGETINFOTIPW
#define LPNMLVGETINFOTIP	LPNMLVGETINFOTIPW
#define LVFINDINFO	LVFINDINFOW
#define NMCBEDRAGBEGIN NMCBEDRAGBEGINW
#define LPNMCBEDRAGBEGIN LPNMCBEDRAGBEGINW
#define PNMCBEDRAGBEGIN PNMCBEDRAGBEGINW
#define NMCBEENDEDIT NMCBEENDEDITW
#define LPNMCBEENDEDIT LPNMCBEENDEDITW
#define PNMCBEENDEDIT PNMCBEENDEDITW
#define LPLVITEM	LPLVITEMW
#define LPLVCOLUMN	LPLVCOLUMNW
#define PGET_MODULE_HANDLE_EX PGET_MODULE_HANDLE_EXW
#else
typedef const char *LPCTSTR;
typedef char *LPTCH;
typedef char *LPTSTR;
typedef unsigned char *PTBYTE;
typedef char *PTCH;
typedef char *PTCHAR;
typedef char *PTSTR;
typedef unsigned char TBYTE;
typedef char TCHAR;
typedef BYTE BCHAR;
#define WC_EDIT WC_EDITA
#define WC_BUTTON WC_BUTTONA
#define WC_STATIC WC_STATICA
#define WC_LISTBOX WC_LISTBOXA
#define WC_COMBOBOX WC_COMBOBOXW
#define TEXT(quote) quote
#define SERVICES_ACTIVE_DATABASE	SERVICES_ACTIVE_DATABASEA
#define SERVICES_FAILED_DATABASE	SERVICES_FAILED_DATABASEA
#define SC_GROUP_IDENTIFIER	SC_GROUP_IDENTIFIERA
#define WC_COMBOBOXEX	WC_COMBOBOXEXA
#define WC_NATIVEFONTCTL	WC_NATIVEFONTCTLA
#define WC_IPADDRESS	WC_IPADDRESSA
#define WC_SCROLLBAR	WC_SCROLLBARA
#define GetSystemWindowsDirectory GetSystemWindowsDirectoryA
#define HDN_GETDISPINFO	HDN_GETDISPINFOA
#define HDM_GETITEM HDM_GETITEMA
#define HDM_INSERTITEM HDM_INSERTITEMA
#define HDM_SETITEM HDM_SETITEMA
#define ACM_OPEN ACM_OPENA
#define HDN_BEGINTRACK HDN_BEGINTRACKA
#define HDN_DIVIDERDBLCLICK HDN_DIVIDERDBLCLICKA
#define HDN_ENDTRACK HDN_ENDTRACKA
#define HDN_ITEMCHANGED HDN_ITEMCHANGEDA
#define HDN_ITEMCHANGING HDN_ITEMCHANGINGA
#define HDN_ITEMCLICK HDN_ITEMCLICKA
#define HDN_ITEMDBLCLICK HDN_ITEMDBLCLICKA
#define HDN_TRACK HDN_TRACKA
#define	LVM_FINDITEM	LVM_FINDITEMA
#define	LVM_GETCOLUMN	LVM_GETCOLUMNA
#define	LVM_GETITEMTEXT	LVM_GETITEMTEXTA
#define	LVM_GETSTRINGWIDTH	LVM_GETSTRINGWIDTHA
#define	LVM_INSERTCOLUMN	LVM_INSERTCOLUMNA
#define	LVM_SETCOLUMN	LVM_SETCOLUMNA
#define	LVM_SETITEMTEXT	LVM_SETITEMTEXTA
#define	LVM_EDITLABEL	LVM_EDITLABELA
#define	LVM_GETBKIMAGE	LVM_GETBKIMAGEA
#define	LVM_GETISEARCHSTRING	LVM_GETISEARCHSTRINGA
#define	LVM_GETITEM	LVM_GETITEMA
#define	LVM_INSERTITEM	LVM_INSERTITEMA
#define	LVM_SETBKIMAGE	LVM_SETBKIMAGEA
#define	LVM_SETITEM	LVM_SETITEMA
#define LVN_BEGINLABELEDIT LVN_BEGINLABELEDITA
#define LVN_ENDLABELEDIT LVN_ENDLABELEDITA
#define LVN_GETDISPINFO LVN_GETDISPINFOA
#define LVN_SETDISPINFO LVN_SETDISPINFOA
#define LVN_ODFINDITEM LVN_ODFINDITEMA
#define PSM_SETFINISHTEXT PSM_SETFINISHTEXTA
#define PSM_SETTITLE PSM_SETTITLEA
#define SB_GETTEXT SB_GETTEXTA
#define SB_GETTEXTLENGTH SB_GETTEXTLENGTHA
#define SB_SETTEXT SB_SETTEXTA
#define TB_ADDSTRING TB_ADDSTRINGA
#define TB_GETBUTTONTEXT TB_GETBUTTONTEXTA
#define TB_SAVERESTORE TB_SAVERESTOREA
#define TB_GETBUTTONINFO	TB_GETBUTTONINFOA
#define TB_SETBUTTONINFO	TB_SETBUTTONINFOA
#define TBBUTTONINFO TBBUTTONINFOA
#define LPTBBUTTONINFO LPTBBUTTONINFOA
#define DESKTOPENUMPROC DESKTOPENUMPROCA
#define TBN_GETBUTTONINFO TBN_GETBUTTONINFOA
#define TBN_GETDISPINFO TBN_GETDISPINFOA
#define TCM_GETITEM TCM_GETITEMA
#define TCM_INSERTITEM TCM_INSERTITEMA
#define TCM_SETITEM TCM_SETITEMA
#define TTM_ADDTOOL TTM_ADDTOOLA
#define TTM_DELTOOL TTM_DELTOOLA
#define TTM_ENUMTOOLS TTM_ENUMTOOLSA
#define TTM_GETCURRENTTOOL TTM_GETCURRENTTOOLA
#define TTM_GETTEXT TTM_GETTEXTA
#define TTM_GETTOOLINFO TTM_GETTOOLINFOA
#define TTM_HITTEST TTM_HITTESTA
#define TTM_NEWTOOLRECT TTM_NEWTOOLRECTA
#define TTM_SETTOOLINFO TTM_SETTOOLINFOA
#define TTM_UPDATETIPTEXT TTM_UPDATETIPTEXTA
#define TTN_NEEDTEXT TTN_NEEDTEXTA
#define TTN_GETDISPINFO	TTN_GETDISPINFOA
#define TVM_EDITLABEL TVM_EDITLABELA
#define TVM_GETISEARCHSTRING TVM_GETISEARCHSTRINGA
#define TVM_GETITEM TVM_GETITEMA
#define TVM_INSERTITEM TVM_INSERTITEMA
#define TVM_SETITEM TVM_SETITEMA
#define TVN_BEGINDRAG TVN_BEGINDRAGA
#define TVN_BEGINLABELEDIT TVN_BEGINLABELEDITA
#define TVN_BEGINRDRAG TVN_BEGINRDRAGA
#define TVN_DELETEITEM TVN_DELETEITEMA
#define TVN_ENDLABELEDIT TVN_ENDLABELEDITA
#define TVN_GETDISPINFO TVN_GETDISPINFOA
#define TVN_ITEMEXPANDED TVN_ITEMEXPANDEDA
#define TVN_ITEMEXPANDING TVN_ITEMEXPANDINGA
#define TVN_SELCHANGED TVN_SELCHANGEDA
#define TVN_SELCHANGING TVN_SELCHANGINGA
#define TVN_SETDISPINFO TVN_SETDISPINFOA
#define ANIMATE_CLASS ANIMATE_CLASSA
#define HOTKEY_CLASS HOTKEY_CLASSA
#define PROGRESS_CLASS PROGRESS_CLASSA
#define STATUSCLASSNAME STATUSCLASSNAMEA
#define REBARCLASSNAME REBARCLASSNAMEA
#define REBARBANDINFO REBARBANDINFOA
#define TOOLBARCLASSNAME TOOLBARCLASSNAMEA
#define TOOLTIPS_CLASS TOOLTIPS_CLASSA
#define TRACKBAR_CLASS TRACKBAR_CLASSA
#define UPDOWN_CLASS UPDOWN_CLASSA
#define WC_HEADER WC_HEADERA
#define WC_LISTVIEW WC_LISTVIEWA
#define WC_TABCONTROL WC_TABCONTROLA
#define WC_TREEVIEW WC_TREEVIEWA
#define LPSTR_TEXTCALLBACK LPSTR_TEXTCALLBACKA
#define RB_INSERTBAND	RB_INSERTBANDA
#define RB_SETBANDINFO	RB_SETBANDINFOA
#define LPREBARBANDINFO LPREBARBANDINFOA
#define NMLDISPINFO NMLDISPINFOA
#define LVN_GETINFOTIP	LVN_GETINFOTIPA
#define NMLVGETINFOTIP	NMLVGETINFOTIPA
#define LPNMLVGETINFOTIP	LPNMLVGETINFOTIPA
#define LVFINDINFO LVFINDINFOA
#define NMCBEDRAGBEGIN NMCBEDRAGBEGINA
#define NMLVDISPINFO NMLVDISPINFOA
#define LPNMCBEDRAGBEGIN LPNMCBEDRAGBEGINA
#define PNMCBEDRAGBEGIN PNMCBEDRAGBEGINA
#define NMCBEENDEDIT NMCBEENDEDITA
#define LPNMCBEENDEDIT LPNMCBEENDEDITA
#define PNMCBEENDEDIT PNMCBEENDEDITA
#define LPLVITEM	LPLVITEMA
#define LPLVCOLUMN	LPLVCOLUMNA
#define PGET_MODULE_HANDLE_EX PGET_MODULE_HANDLE_EXA
#endif // UNICODE

//#ifndef RC_INVOKED
typedef const unsigned short *LPCWCH;
typedef const unsigned short *LPCWSTR;
typedef DWORD *LPDWORD;
typedef HANDLE *LPHANDLE;
typedef int *LPINT;
typedef long *LPLONG;
typedef char *LPSTR;
typedef long LRESULT;
typedef void *LPVOID;
typedef const void *LPCVOID;
typedef unsigned short *LPWCH;
typedef unsigned short *LPWORD;
typedef unsigned short *LPWSTR;
typedef unsigned short *PWSTR;
typedef unsigned short *NWPSTR;
typedef BOOL *PWINBOOL;
typedef BYTE *PBOOLEAN;
typedef BYTE *PBYTE;
typedef const CHAR *PCCH;
typedef CHAR *PCH;
typedef CHAR *PCHAR;
typedef const char *PCSTR;
typedef const unsigned short *PCWCH;
typedef const unsigned short *PCWSTR;
typedef DWORD *PDWORD;
typedef float *PFLOAT;
typedef HANDLE *PHANDLE;
typedef int *PINT;
typedef long *PLONG;
typedef short *PSHORT;
typedef char *PSTR;
typedef char *PSZ;
typedef unsigned char *PUCHAR;
typedef unsigned int *PUINT;
typedef unsigned long *PULONG;
typedef unsigned short *PUSHORT;
typedef void *PVOID;
typedef unsigned short *PWCH;
typedef unsigned short *PWCHAR;
typedef unsigned short *PWORD;
typedef short SHORT;
typedef unsigned int UINT;
#define VOID void
typedef unsigned short WCHAR;
typedef unsigned short WORD;
typedef unsigned int WPARAM;
#define CDECL
#define CALLBACK
#define PASCAL
#define WINAPI	
#define NTAPI	
#define WINGDIAPI 
#define WINAPIV
#define APIENTRY	
#define IPM_CLEARADDRESS	(WM_USER+100)
#define IPM_SETADDRESS	(WM_USER+101)
#define IPM_GETADDRESS	(WM_USER+102)
#define IPM_SETRANGE	(WM_USER+103)
#define IPM_SETFOCUS	(WM_USER+104)
#define IPM_ISBLANK	(WM_USER+105)
typedef enum _ACL_INFORMATION_CLASS {
	AclRevisionInformation = 1,AclSizeInformation
} ACL_INFORMATION_CLASS;
typedef enum _SECURITY_IMPERSONATION_LEVEL {
	SecurityAnonymous,SecurityIdentification, SecurityImpersonation,
	SecurityDelegation
} SECURITY_IMPERSONATION_LEVEL;
typedef enum _SID_NAME_USE {
	SidTypeUser = 1,SidTypeGroup, SidTypeDomain, SidTypeAlias,
	SidTypeWellKnownGroup,SidTypeDeletedAccount, SidTypeInvalid,
	SidTypeUnknown
} SID_NAME_USE,*PSID_NAME_USE;
typedef enum _TOKEN_INFORMATION_CLASS {
	TokenUser = 1,TokenGroups, TokenPrivileges, TokenOwner,
	TokenPrimaryGroup,TokenDefaultDacl, TokenSource, TokenType,
	TokenImpersonationLevel,TokenStatistics
} TOKEN_INFORMATION_CLASS;
typedef enum tagTOKEN_TYPE {
	TokenPrimary = 1,TokenImpersonation
} TOKEN_TYPE;
typedef enum { LT_DONT_CARE, LT_LOWEST_LATENCY } LATENCY_TIME;
//#endif RC_INVOKED

#define FORWARD_WM_NOTIFY(h,id,hdr,fn) (void)(fn)((h),WM_NOTIFY,(WPARAM)(id),(LPARAM)(hdr))
#define GetBValue(rgb) ((BYTE) ((rgb) >> 16))
#define GetGValue(rgb) ((BYTE) (((WORD) (rgb)) >> 8))
#define GetRValue(rgb) ((BYTE) (rgb))
#define RGB(r,g,b) ((DWORD)(((BYTE)(r)|((WORD)(g) << 8))|(((DWORD)(BYTE)(b)) << 16)))
#define HANDLE_WM_NOTIFY(h,wP,lP,fn) (fn)((h),(int)(wP),(NMHDR *)(lP))
#define HIBYTE(w) ((BYTE) (((WORD) (w) >> 8) & 0xFF))
#define HIWORD(l) ((WORD) (((DWORD) (l) >> 16) & 0xFFFF))
#define LOBYTE(w) (((BYTE) (w)) & 0xFF)
#define LOWORD(l) (((WORD) (l)) & 0xFFFF)
#define MAKELONG(a,b) ((LONG) (((WORD) (a)) | ((DWORD) ((WORD) (b))) << 16))
#define MAKEWORD(a,b) ((WORD) (((BYTE) (a)) | ((WORD) ((BYTE) (b))) << 8))
#define INDEXTOOVERLAYMASK(i) ((i) << 8)
#define INDEXTOSTATEIMAGEMASK(i) ((i) << 12)
#define MAXINTATOM 0xC000
#define INVALID_ATOM ((ATOM)0)
#define MAKEINTATOM(i) (LPTSTR) ((DWORD) ((WORD) (i)))
#define MAKEINTRESOURCE(i) (LPTSTR) ((DWORD) ((WORD) (i)))
#define IS_INTRESOURCE(_r) (((ULONG_PTR)(_r) >> 16)==0)
#define MAKELANGID(p,s) ((((WORD) (s)) << 10) | (WORD) (p))
#define PRIMARYLANGID(lgid) ((WORD )(lgid) & 0x3ff)
#define SUBLANGID(lgid) ((WORD )(lgid) >> 10)
#define LANGIDFROMLCID(lcid) ((WORD) (lcid))
#define SORTIDFROMLCID(lcid) ((WORD )((((DWORD)(lcid)) & 0xFFFFF) >> 16))
#define MAKELCID(lgid,srtid) ((DWORD)((((DWORD)((WORD)(srtid))) << 16)|((DWORD)((WORD)(lgid)))))
#define MAKELPARAM(l,h) ((LPARAM) MAKELONG(l,h))
#define MAKELRESULT(l,h) ((LRESULT) MAKELONG(l,h))
#define MAKEPOINTS(l) (*((POINTS *) & (l)))
#define MAKEROP4(fore,back) (DWORD)((((back) << 8) & 0xFF000000) | (fore))
#define MAKEWPARAM(l,h)	((WPARAM) MAKELONG(l,h))
#define PALETTEINDEX(i) ((COLORREF) (0x01000000 | (DWORD) (WORD) (i)))
#define PALETTERGB(r,g,b) (0x02000000 | RGB(r,g,b))
#define POINTSTOPOINT(pt,pts) {(pt).x = (LONG)(SHORT) LOWORD(*(LONG*)&pts); (pt).y = (LONG)(SHORT) HIWORD(*(LONG*)&pts);}
#define POINTTOPOINTS(pt) (MAKELONG((short) ((pt).x),(short) ((pt).y)))
#define INDEXTOOVERLAYMASK(i) ((i) << 8)

typedef int (CALLBACK *BFFCALLBACK) (HWND,UINT,LPARAM,LPARAM);
typedef UINT (CALLBACK *LPCCHOOKPROC) (HWND,UINT,WPARAM,LPARAM);
typedef UINT (CALLBACK *LPCFHOOKPROC) (HWND,UINT,WPARAM,LPARAM);
typedef DWORD (CALLBACK *PTHREAD_START_ROUTINE) (LPVOID);
typedef PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;
typedef UINT (CALLBACK *LPFRHOOKPROC) (HWND,UINT,WPARAM,LPARAM);
typedef UINT (CALLBACK *LPOFNHOOKPROC) (HWND,UINT,WPARAM,LPARAM);
typedef UINT (CALLBACK *LPPRINTHOOKPROC) (HWND,UINT,WPARAM,LPARAM);
typedef UINT (CALLBACK *LPSETUPHOOKPROC) (HWND,UINT,WPARAM,LPARAM);
typedef BOOL (CALLBACK *DLGPROC) (HWND,UINT,WPARAM,LPARAM);
typedef int (CALLBACK *PFNPROPSHEETCALLBACK) (HWND,UINT,LPARAM);
typedef VOID (CALLBACK *LPSERVICE_MAIN_FUNCTION) (DWORD,LPTSTR);
typedef int (CALLBACK *PFNTVCOMPARE) (LPARAM,LPARAM,LPARAM);
typedef LRESULT (CALLBACK *WNDPROC) (HWND,UINT,WPARAM,LPARAM);
typedef int (CALLBACK *FARPROC)(void);
typedef int (WINAPI *PROC)(void);
typedef BOOL (CALLBACK *WNDENUMPROC)(HWND,LPARAM);
typedef BOOL (CALLBACK *ENUMRESTYPEPROCA) (HANDLE,LPSTR,LONG);
typedef BOOL (CALLBACK *ENUMRESTYPEPROCW) (HANDLE,LPWSTR,LONG);
typedef BOOL (CALLBACK *ENUMRESNAMEPROC) (HANDLE,LPCTSTR,LPTSTR,LONG);
typedef BOOL (CALLBACK *ENUMRESLANGPROC) (HANDLE,LPCTSTR,LPCTSTR,WORD,LONG);
typedef BOOL (CALLBACK *ENUMWINDOWSPROC) (HWND,LPARAM);
typedef BOOL (CALLBACK *ENUMWINDOWSTATIONPROC) (LPTSTR,LPARAM);
typedef VOID (CALLBACK *SENDASYNCPROC) (HWND,UINT,DWORD,LRESULT);
typedef VOID (CALLBACK *TIMERPROC) (HWND,UINT,UINT,DWORD);
typedef BOOL (CALLBACK *GRAYSTRINGPROC)(HDC,LPARAM,int);
typedef BOOL (CALLBACK *DRAWSTATEPROC) (HDC,LPARAM,WPARAM,int,int);
typedef BOOL (CALLBACK *PROPENUMPROCEX) (HWND,LPCTSTR,HANDLE,DWORD);
typedef BOOL (CALLBACK *PROPENUMPROC) (HWND,LPCTSTR,HANDLE);
typedef LRESULT (CALLBACK *HOOKPROC) (int,WPARAM,LPARAM);
typedef VOID (CALLBACK *ENUMOBJECTSPROC) (LPVOID,LPARAM);
typedef VOID (CALLBACK *LINEDDAPROC) (int,int,LPARAM);
typedef BOOL (CALLBACK *ABORTPROC) (HDC,int);
typedef UINT (CALLBACK *LPPAGEPAINTHOOK) (HWND,UINT,WPARAM,LPARAM);
typedef UINT (CALLBACK *LPPAGESETUPHOOK) (HWND,UINT,WPARAM,LPARAM);
typedef int (CALLBACK *ICMENUMPROC) (LPTSTR,LPARAM);
typedef LONG (*EDITWORDBREAKPROCEX) (char *,LONG,BYTE,INT);
typedef int (CALLBACK *PFNLVCOMPARE) (LPARAM,LPARAM,LPARAM);
typedef BOOL (CALLBACK *LOCALE_ENUMPROC) (LPTSTR);
typedef BOOL (CALLBACK *CODEPAGE_ENUMPROC) (LPTSTR);
typedef BOOL (CALLBACK *DATEFMT_ENUMPROC) (LPTSTR);
typedef BOOL (CALLBACK *TIMEFMT_ENUMPROC) (LPTSTR);
typedef BOOL (CALLBACK *CALINFO_ENUMPROC) (LPTSTR);
typedef BOOL (CALLBACK *PHANDLER_ROUTINE) (DWORD);
typedef UINT (CALLBACK *PFNGETPROFILEPATH) (LPCTSTR,LPSTR,UINT);
typedef UINT (CALLBACK *PFNRECONCILEPROFILE) (LPCTSTR,LPCTSTR,DWORD);
typedef BOOL (CALLBACK *PFNPROCESSPOLICIES) (HWND,LPCTSTR,LPCTSTR,LPCTSTR,DWORD);
typedef BOOL (CALLBACK* NAMEENUMPROCA)(LPSTR,LPARAM);
typedef BOOL (CALLBACK* NAMEENUMPROCW)(LPWSTR,LPARAM);
typedef NAMEENUMPROCA WINSTAENUMPROCA;
typedef NAMEENUMPROCA DESKTOPENUMPROCA;
typedef NAMEENUMPROCW WINSTAENUMPROCW;
typedef NAMEENUMPROCW DESKTOPENUMPROCW;

#define SECURITY_NULL_SID_AUTHORITY	{0,0,0,0,0,0}
#define SECURITY_WORLD_SID_AUTHORITY	{0,0,0,0,0,1}
#define SECURITY_LOCAL_SID_AUTHORITY	{0,0,0,0,0,2}
#define SECURITY_CREATOR_SID_AUTHORITY	{0,0,0,0,0,3}
#define SECURITY_NON_UNIQUE_AUTHORITY	{0,0,0,0,0,4}
#define SECURITY_NT_AUTHORITY	{0,0,0,0,0,5}
#define SE_CREATE_TOKEN_NAME	TEXT("SeCreateTokenPrivilege")
#define SE_ASSIGNPRIMARYTOKEN_NAME	TEXT("SeAssignPrimaryTokenPrivilege")
#define SE_LOCK_MEMORY_NAME	TEXT("SeLockMemoryPrivilege")
#define SE_INCREASE_QUOTA_NAME	TEXT("SeIncreaseQuotaPrivilege")
#define SE_UNSOLICITED_INPUT_NAME	TEXT("SeUnsolicitedInputPrivilege")
#define SE_MACHINE_ACCOUNT_NAME	TEXT("SeMachineAccountPrivilege")
#define SE_TCB_NAME	TEXT("SeTcbPrivilege")
#define SE_SECURITY_NAME	TEXT("SeSecurityPrivilege")
#define SE_TAKE_OWNERSHIP_NAME	TEXT("SeTakeOwnershipPrivilege")
#define SE_LOAD_DRIVER_NAME	TEXT("SeLoadDriverPrivilege")
#define SE_SYSTEM_PROFILE_NAME	TEXT("SeSystemProfilePrivilege")
#define SE_SYSTEMTIME_NAME	TEXT("SeSystemtimePrivilege")
#define SE_PROF_SINGLE_PROCESS_NAME	TEXT("SeProfileSingleProcessPrivilege")
#define SE_INC_BASE_PRIORITY_NAME	TEXT("SeIncreaseBasePriorityPrivilege")
#define SE_CREATE_PAGEFILE_NAME	TEXT("SeCreatePagefilePrivilege")
#define SE_CREATE_PERMANENT_NAME	TEXT("SeCreatePermanentPrivilege")
#define SE_BACKUP_NAME	TEXT("SeBackupPrivilege")
#define SE_RESTORE_NAME	TEXT("SeRestorePrivilege")
#define SE_SHUTDOWN_NAME	TEXT("SeShutdownPrivilege")
#define SE_DEBUG_NAME	TEXT("SeDebugPrivilege")
#define SE_AUDIT_NAME	TEXT("SeAuditPrivilege")
#define SE_SYSTEM_ENVIRONMENT_NAME	TEXT("SeSystemEnvironmentPrivilege")
#define SE_CHANGE_NOTIFY_NAME	TEXT("SeChangeNotifyPrivilege")
#define SE_REMOTE_SHUTDOWN_NAME	TEXT("SeRemoteShutdownPrivilege")
#define SERVICES_ACTIVE_DATABASEW	L"ServicesActive"
#define SERVICES_FAILED_DATABASEW	L"ServicesFailed"
#define SERVICES_ACTIVE_DATABASEA	"ServicesActive"
#define SERVICES_FAILED_DATABASEA	"ServicesFailed"
#define SC_GROUP_IDENTIFIERW	L'+'
#define SC_GROUP_IDENTIFIERA	'+'
/* Messages.h WIN32 message definitions */
#define ACM_OPENW	1127
#define ACM_OPENA	1124
#define ACM_PLAY	1125
#define ACM_STOP	1126
#define ACN_START	1
#define ACN_STOP	2
#define BM_CLICK	245
#define BM_GETCHECK	240
#define BM_GETIMAGE	246
#define BM_GETSTATE	242
#define BM_SETCHECK	241
#define BM_SETIMAGE	247
#define BM_SETSTATE	243
#define BM_SETSTYLE	244
#define BN_CLICKED	0
#define BN_DBLCLK	5
#define BN_DISABLE	4
#define BN_DOUBLECLICKED	5
#define BN_HILITE	2
#define BN_KILLFOCUS	7
#define BN_PAINT	1
#define BN_PUSHED	2
#define BN_SETFOCUS	6
#define BN_UNHILITE	3
#define BN_UNPUSHED	3
#define CB_ADDSTRING	323
#define CB_DELETESTRING	324
#define CB_DIR	325
#define CB_FINDSTRING	332
#define CB_FINDSTRINGEXACT	344
#define CB_GETCOUNT	326
#define CB_GETCURSEL	327
#define CB_GETDROPPEDCONTROLRECT	338
#define CB_GETDROPPEDSTATE	343
#define CB_GETDROPPEDWIDTH	351
#define CB_GETEDITSEL	320
#define CB_GETEXTENDEDUI	342
#define CB_GETHORIZONTALEXTENT	349
#define CB_GETITEMDATA	336
#define CB_GETITEMHEIGHT	340
#define CB_GETLBTEXT	328
#define CB_GETLBTEXTLEN	329
#define CB_GETLOCALE	346
#define CB_GETTOPINDEX	347
#define CB_INITSTORAGE	353
#define CB_INSERTSTRING	330
#define CB_LIMITTEXT	321
#define CB_RESETCONTENT	331
#define CB_SELECTSTRING	333
#define CB_SETCURSEL	334
#define CB_SETDROPPEDWIDTH	352
#define CB_SETEDITSEL	322
#define CB_SETEXTENDEDUI	341
#define CB_SETHORIZONTALEXTENT	350
#define CB_SETITEMDATA	337
#define CB_SETITEMHEIGHT	339
#define CB_SETLOCALE	345
#define CB_SETTOPINDEX	348
#define CB_SHOWDROPDOWN	335
#define CBN_CLOSEUP	8
#define CBN_DBLCLK	2
#define CBN_DROPDOWN	7
#define CBN_EDITCHANGE	5
#define CBN_EDITUPDATE	6
#define CBN_ERRSPACE	(-1)
#define CBN_KILLFOCUS	4
#define CBN_SELCHANGE	1
#define CBN_SELENDCANCEL	10
#define CBN_SELENDOK	9
#define CBN_SETFOCUS	3
#define DL_BEGINDRAG	1157
#define DL_CANCELDRAG	1160
#define DL_DRAGGING	1158
#define DL_DROPPED	1159
#define DRAGLISTMSGSTRING	TEXT("commctrl_DragListMsg")
#define DM_GETDEFID	1024
#define DM_REPOSITION	1026
#define DM_SETDEFID	1025
#define EM_SETCUEBANNER (ECM_FIRST+1)
#define EM_GETCUEBANNER (ECM_FIRST + 2)
#define EM_SHOWBALLOONTIP (ECM_FIRST + 3)
#define EM_HIDEBALLOONTIP (ECM_FIRST+4)
#define EM_CANPASTE	1074
#define EM_CANUNDO	198
#define EM_CHARFROMPOS	215
#define EM_DISPLAYBAND	1075
#define EM_EMPTYUNDOBUFFER	205
#define EM_EXGETSEL	1076
#define EM_EXLIMITTEXT	1077
#define EM_EXLINEFROMCHAR	1078
#define EM_EXSETSEL	1079
#define EM_FINDTEXT	1080
#define EM_FINDTEXTEX	1103
#define EM_FINDWORDBREAK	1100
#define EM_FMTLINES	200
#define EM_FORMATRANGE	1081
#define EM_GETCHARFORMAT	1082
#define EM_GETEVENTMASK	1083
#define EM_GETFIRSTVISIBLELINE	206
#define EM_GETHANDLE	189
#define EM_GETLIMITTEXT	213
#define EM_GETLINE	196
#define EM_GETLINECOUNT	186
#define EM_GETMARGINS	212
#define EM_GETMODIFY	184
#define EM_GETIMECOLOR	1129
#define EM_GETIMEOPTIONS	1131
#define EM_GETOPTIONS	1102
#define EM_GETOLEINTERFACE	1084
#define EM_GETPARAFORMAT	1085
#define EM_GETPASSWORDCHAR	210
#define EM_GETPUNCTUATION	1125
#define EM_GETRECT	178
#define EM_GETSEL	176
#define EM_GETSELTEXT	1086
#define EM_GETTEXTRANGE	1099
#define EM_GETTHUMB	190
#define EM_GETWORDBREAKPROC	209
#define EM_GETWORDBREAKPROCEX	1104
#define EM_GETWORDWRAPMODE	1127
#define EM_HIDESELECTION	1087
#define EM_LIMITTEXT	197
#define EM_LINEFROMCHAR	201
#define EM_LINEINDEX	187
#define EM_LINELENGTH	193
#define EM_LINESCROLL	182
#define EM_PASTESPECIAL	1088
#define EM_POSFROMCHAR	214
#define EM_REPLACESEL	194
#define EM_REQUESTRESIZE	1089
#define EM_SCROLL	181
#define EM_SCROLLCARET	183
#define EM_SELECTIONTYPE	1090
#define EM_SETBKGNDCOLOR	1091
#define EM_SETCHARFORMAT	1092
#define EM_SETEVENTMASK	1093
#define EM_SETHANDLE	188
#define EM_SETIMECOLOR	1128
#define EM_SETIMEOPTIONS	1130
#define EM_SETLIMITTEXT	197
#define EM_SETMARGINS	211
#define EM_SETMODIFY	185
#define EM_SETOLECALLBACK	1094
#define EM_SETOPTIONS	1101
#define EM_SETPARAFORMAT	1095
#define EM_SETPASSWORDCHAR	204
#define EM_SETPUNCTUATION	1124
#define EM_SETREADONLY	207
#define EM_SETRECT	179
#define EM_SETRECTNP	180
#define EM_SETSEL	177
#define EM_SETTABSTOPS	203
#define EM_SETTARGETDEVICE	1096
#define EM_SETWORDBREAKPROC	208
#define EM_SETWORDBREAKPROCEX	1105
#define EM_SETWORDWRAPMODE	1126
#define EM_STREAMIN	1097
#define EM_STREAMOUT	1098
#define EM_UNDO	199
#define EN_CHANGE	768
#define EN_CORRECTTEXT	1797
#define EN_DROPFILES	1795
#define EN_ERRSPACE	1280
#define EN_HSCROLL	1537
#define EN_IMECHANGE	1799
#define EN_KILLFOCUS	512
#define EN_MAXTEXT	1281
#define EN_MSGFILTER	1792
#define EN_OLEOPFAILED	1801
#define EN_PROTECTED	1796
#define EN_REQUESTRESIZE	1793
#define EN_SAVECLIPBOARD	1800
#define EN_SELCHANGE	1794
#define EN_SETFOCUS	256
#define EN_STOPNOUNDO	1798
#define EN_UPDATE	1024
#define EN_VSCROLL	1538
#define HDM_FIRST	0x1200
#define HDM_DELETEITEM	4610
#define HDM_GETITEMW	4619
#define HDM_INSERTITEMW	4618
#define HDM_SETITEMW	4620
#define HDM_GETITEMA	4611
#define HDM_INSERTITEMA	4609
#define HDM_SETITEMA	4612
#define HDM_GETITEMCOUNT	4608
#define HDM_HITTEST	4614
#define HDM_LAYOUT	4613
#define HDM_SETBITMAPMARGIN (HDM_FIRST + 20)
#define Header_SetBitmapMargin(hwnd, iWidth) (int)SNDMSG((hwnd), HDM_SETBITMAPMARGIN, (WPARAM)(iWidth), 0)
#define HDM_GETBITMAPMARGIN (HDM_FIRST + 21)
#define Header_GetBitmapMargin(hwnd) (int)SNDMSG((hwnd), HDM_GETBITMAPMARGIN, 0, 0)
#define HDM_SETFILTERCHANGETIMEOUT (HDM_FIRST+22)
#define Header_SetFilterChangeTimeout(hwnd, i) (int)SNDMSG((hwnd), HDM_SETFILTERCHANGETIMEOUT, 0, (LPARAM)(i))
#define HDM_EDITFILTER	(HDM_FIRST+23)
#define Header_EditFilter(h,i,f) (int)SNDMSG((h),HDM_EDITFILTER,(WPARAM)(i),MAKELPARAM(f,0))
#define HDM_CLEARFILTER	(HDM_FIRST+24)
#define Header_ClearFilter(h,i) (int)SNDMSG((h), HDM_CLEARFILTER, (WPARAM)(i),0)
#define Header_ClearAllFilters(hwnd) (int)SNDMSG((hwnd), HDM_CLEARFILTER, (WPARAM)-1, 0)
#define HDM_GETITEMRECT	(HDM_FIRST+7)
#define Header_GetItemRect(h,I,lprc) (BOOL)SendMessage((h), HDM_GETITEMRECT, (WPARAM)(I),(LPARAM)(lprc))
#define HDM_SETIMAGELIST	(HDM_FIRST+8)
#define Header_SetImageList(h,himl) (HIMAGELIST)SendMessage((h),HDM_SETIMAGELIST,0,(LPARAM)(himl))
#define HDM_GETIMAGELIST	(HDM_FIRST+9)
#define Header_GetImageList(h) (HIMAGELIST)SendMessage((h),HDM_GETIMAGELIST,0,0)
#define HDM_ORDERTOINDEX	(HDM_FIRST+15)
#define Header_OrderToIndex(hwnd, i) (int)SendMessage((hwnd), HDM_ORDERTOINDEX, (WPARAM)(i), 0)
#define HDM_CREATEDRAGIMAGE	(HDM_FIRST+16)
#define Header_CreateDragImage(h,i) (HIMAGELIST)SendMessage((h),HDM_CREATEDRAGIMAGE,(WPARAM)(i),0)
#define HDM_GETORDERARRAY	(HDM_FIRST+17)
#define Header_GetOrderArray(h,C,i) (BOOL)SendMessage((h),HDM_GETORDERARRAY,(WPARAM)(C),(LPARAM)(i))
#define HDM_SETORDERARRAY	(HDM_FIRST+18)
#define Header_SetOrderArray(h,C,lpi) (BOOL)SendMessage((h), HDM_SETORDERARRAY, (WPARAM)(C),(LPARAM)(lpi))
#define HDM_SETHOTDIVIDER	(HDM_FIRST+19)
#define Header_SetHotDivider(h,P,dw) (int)SendMessage((h),HDM_SETHOTDIVIDER,(WPARAM)(P),(LPARAM)(dw))
#define HDN_BEGINTRACKW	(-326)
#define HDN_DIVIDERDBLCLICKW	(-325)
#define HDN_ENDTRACKW	(-327)
#define HDN_ITEMCHANGEDW	(-321)
#define HDN_ITEMCHANGINGW	(-320)
#define HDN_ITEMCLICKW	(-322)
#define HDN_ITEMDBLCLICKW	(-323)
#define HDN_TRACKW	(-328)
#define HDN_BEGINTRACKA	(-306)
#define HDN_DIVIDERDBLCLICKA	(-305)
#define HDN_ENDTRACKA	(-307)
#define HDN_ITEMCHANGEDA	(-301)
#define HDN_ITEMCHANGINGA	(-300)
#define HDN_ITEMCLICKA	(-302)
#define HDN_ITEMDBLCLICKA	(-303)
#define HDN_TRACKA	(-308)
#define HDN_GETDISPINFOA	(HDN_FIRST-9)
#define HDN_GETDISPINFOW	(HDN_FIRST-29)
#define HDN_BEGINDRAG	(HDN_FIRST-10)
#define HDN_ENDDRAG	(HDN_FIRST-11)
#define HDN_FILTERCHANGE (HDN_FIRST-12)
#define HDN_FILTERBTNCLICK (HDN_FIRST-13)
#define HD_NOTIFYA NMHEADERA
#define HD_NOTIFYW NMHEADERW
#define HKM_GETHOTKEY	1026
#define HKM_SETHOTKEY	1025
#define HKM_SETRULES	1027
#define LB_ADDFILE	406
#define LB_ADDSTRING	384
#define LB_DELETESTRING	386
#define LB_DIR	397
#define LB_FINDSTRING	399
#define LB_FINDSTRINGEXACT	418
#define LB_GETANCHORINDEX	413
#define LB_GETCARETINDEX	415
#define LB_GETCOUNT	395
#define LB_GETCURSEL	392
#define LB_GETHORIZONTALEXTENT	403
#define LB_GETITEMDATA	409
#define LB_GETITEMHEIGHT	417
#define LB_GETITEMRECT	408
#define LB_GETLOCALE	422
#define LB_GETSEL	391
#define LB_GETSELCOUNT	400
#define LB_GETSELITEMS	401
#define LB_GETTEXT	393
#define LB_GETTEXTLEN	394
#define LB_GETTOPINDEX	398
#define LB_INITSTORAGE	424
#define LB_INSERTSTRING	385
#define LB_ITEMFROMPOINT	425
#define LB_RESETCONTENT	388
#define LB_SELECTSTRING	396
#define LB_SELITEMRANGE	411
#define LB_SELITEMRANGEEX	387
#define LB_SETANCHORINDEX	412
#define LB_SETCARETINDEX	414
#define LB_SETCOLUMNWIDTH	405
#define LB_SETCOUNT	423
#define LB_SETCURSEL	390
#define LB_SETHORIZONTALEXTENT	404
#define LB_SETITEMDATA	410
#define LB_SETITEMHEIGHT	416
#define LB_SETLOCALE	421
#define LB_SETSEL	389
#define LB_SETTABSTOPS	402
#define LB_SETTOPINDEX	407
#define LBN_DBLCLK	2
#define LBN_ERRSPACE	(-2)
#define LBN_KILLFOCUS	5
#define LBN_SELCANCEL	3
#define LBN_SELCHANGE	1
#define LBN_SETFOCUS	4
#define LVM_FIRST	0x1000
#define	LVM_APPROXIMATEVIEWRECT	(LVM_FIRST+64)
#define	LVM_ARRANGE	(LVM_FIRST+22)
#define	LVM_CANCELEDITLABEL	(LVM_FIRST+179)
#define	LVM_CREATEDRAGIMAGE	(LVM_FIRST+33)
#define	LVM_DELETEALLITEMS	(LVM_FIRST+9)
#define	LVM_DELETECOLUMN	(LVM_FIRST+28)
#define	LVM_DELETEITEM	(LVM_FIRST+8)
#define	LVM_EDITLABELA	(LVM_FIRST+23)
#define	LVM_EDITLABELW	(LVM_FIRST+118)
#define	LVM_ENABLEGROUPVIEW	(LVM_FIRST+157)
#define	LVM_ENSUREVISIBLE	(LVM_FIRST+19)
#define	LVM_FINDITEMA	(LVM_FIRST+13)
#define	LVM_FINDITEMW	(LVM_FIRST+83)
#define	LVM_GETBKCOLOR	(LVM_FIRST+0)
#define	LVM_GETBKIMAGEA	(LVM_FIRST+69)
#define	LVM_GETBKIMAGEW	(LVM_FIRST+139)
#define	LVM_GETCALLBACKMASK	(LVM_FIRST+10)
#define	LVM_GETCOLUMNA	(LVM_FIRST+25)
#define	LVM_GETCOLUMNORDERARRAY	(LVM_FIRST+59)
#define	LVM_GETCOLUMNW	(LVM_FIRST+95)
#define	LVM_GETCOLUMNWIDTH	(LVM_FIRST+29)
#define	LVM_GETCOUNTPERPAGE	(LVM_FIRST+40)
#define	LVM_GETEDITCONTROL	(LVM_FIRST+24)
#define	LVM_GETEXTENDEDLISTVIEWSTYLE	(LVM_FIRST+55)
#define	LVM_GETGROUPINFO	(LVM_FIRST+149)
#define	LVM_GETGROUPMETRICS	(LVM_FIRST+156)
#define	LVM_GETHEADER	(LVM_FIRST+31)
#define	LVM_GETHOTCURSOR	(LVM_FIRST+63)
#define	LVM_GETHOTITEM	(LVM_FIRST+61)
#define	LVM_GETHOVERTIME	(LVM_FIRST+72)
#define	LVM_GETIMAGELIST	(LVM_FIRST+2)
#define	LVM_GETINSERTMARK	(LVM_FIRST+167)
#define	LVM_GETINSERTMARKCOLOR	(LVM_FIRST+171)
#define	LVM_GETINSERTMARKRECT	(LVM_FIRST+169)
#define	LVM_GETISEARCHSTRINGA	(LVM_FIRST+52)
#define	LVM_GETISEARCHSTRINGW	(LVM_FIRST+117)
#define	LVM_GETITEMA	(LVM_FIRST+5)
#define	LVM_GETITEMCOUNT	(LVM_FIRST+4)
#define	LVM_GETITEMPOSITION	(LVM_FIRST+16)
#define	LVM_GETITEMRECT	(LVM_FIRST+14)
#define	LVM_GETITEMSPACING	(LVM_FIRST+51)
#define	LVM_GETITEMSTATE	(LVM_FIRST+44)
#define	LVM_GETITEMTEXTA	(LVM_FIRST+45)
#define	LVM_GETITEMTEXTW	(LVM_FIRST+115)
#define	LVM_GETITEMW	(LVM_FIRST+75)
#define	LVM_GETNEXTITEM	(LVM_FIRST+12)
#define	LVM_GETNUMBEROFWORKAREAS	(LVM_FIRST+73)
#define	LVM_GETORIGIN	(LVM_FIRST+41)
#define	LVM_GETOUTLINECOLOR	(LVM_FIRST+176)
#define	LVM_GETSELECTEDCOLUMN	(LVM_FIRST+174)
#define	LVM_GETSELECTEDCOUNT	(LVM_FIRST+50)
#define	LVM_GETSELECTIONMARK	(LVM_FIRST+66)
#define	LVM_GETSTRINGWIDTHA	(LVM_FIRST+17)
#define	LVM_GETSTRINGWIDTHW	(LVM_FIRST+87)
#define	LVM_GETSUBITEMRECT	(LVM_FIRST+56)
#define	LVM_GETTEXTBKCOLOR	(LVM_FIRST+37)
#define	LVM_GETTEXTCOLOR	(LVM_FIRST+35)
#define	LVM_GETTILEINFO	(LVM_FIRST+165)
#define	LVM_GETTILEVIEWINFO	(LVM_FIRST+163)
#define	LVM_GETTOOLTIPS	(LVM_FIRST+78)
#define	LVM_GETTOPINDEX	(LVM_FIRST+39)
#define	LVM_GETVIEW	(LVM_FIRST+143)
#define	LVM_GETVIEWRECT	(LVM_FIRST+34)
#define	LVM_GETWORKAREAS	(LVM_FIRST+70)
#define	LVM_HASGROUP	(LVM_FIRST+161)
#define	LVM_HITTEST	(LVM_FIRST+18)
#define	LVM_INSERTCOLUMNA	(LVM_FIRST+27)
#define	LVM_INSERTCOLUMNW	(LVM_FIRST+97)
#define	LVM_INSERTGROUP	(LVM_FIRST+145)
#define	LVM_INSERTGROUPSORTED	(LVM_FIRST+159)
#define	LVM_INSERTITEMA	(LVM_FIRST+7)
#define	LVM_INSERTITEMW	(LVM_FIRST+77)
#define	LVM_INSERTMARKHITTEST	(LVM_FIRST+168)
#define	LVM_ISGROUPVIEWENABLED	(LVM_FIRST+175)
#define	LVM_MAPIDTOINDEX	(LVM_FIRST+181)
#define	LVM_MAPINDEXTOID	(LVM_FIRST+180)
#define	LVM_MOVEGROUP	(LVM_FIRST+151)
#define	LVM_MOVEITEMTOGROUP	(LVM_FIRST+154)
#define	LVM_REDRAWITEMS	(LVM_FIRST+21)
#define	LVM_REMOVEALLGROUPS	(LVM_FIRST+160)
#define	LVM_REMOVEGROUP	(LVM_FIRST+150)
#define	LVM_SCROLL	(LVM_FIRST+20)
#define	LVM_SETBKCOLOR	(LVM_FIRST+1)
#define	LVM_SETBKIMAGEA	(LVM_FIRST+68)
#define	LVM_SETBKIMAGEW	(LVM_FIRST+138)
#define	LVM_SETCALLBACKMASK	(LVM_FIRST+11)
#define	LVM_SETCOLUMNA	(LVM_FIRST+26)
#define	LVM_SETCOLUMNORDERARRAY	(LVM_FIRST+58)
#define	LVM_SETCOLUMNW	(LVM_FIRST+96)
#define	LVM_SETCOLUMNWIDTH	(LVM_FIRST+30)
#define	LVM_SETEXTENDEDLISTVIEWSTYLE	(LVM_FIRST+54)
#define	LVM_SETGROUPINFO	(LVM_FIRST+147)
#define	LVM_SETGROUPMETRICS	(LVM_FIRST+155)
#define	LVM_SETHOTCURSOR	(LVM_FIRST+62)
#define	LVM_SETHOTITEM	(LVM_FIRST+60)
#define	LVM_SETHOVERTIME	(LVM_FIRST+71)
#define	LVM_SETICONSPACING	(LVM_FIRST+53)
#define	LVM_SETIMAGELIST	(LVM_FIRST+3)
#define	LVM_SETINFOTIP	(LVM_FIRST+173)
#define	LVM_SETINSERTMARK	(LVM_FIRST+166)
#define	LVM_SETINSERTMARKCOLOR	(LVM_FIRST+170)
#define	LVM_SETITEMA	(LVM_FIRST+6)
#define	LVM_SETITEMCOUNT	(LVM_FIRST+47)
#define	LVM_SETITEMPOSITION	(LVM_FIRST+15)
#define	LVM_SETITEMPOSITION32	(LVM_FIRST+49)
#define	LVM_SETITEMSTATE	(LVM_FIRST+43)
#define	LVM_SETITEMTEXTA	(LVM_FIRST+46)
#define	LVM_SETITEMTEXTW	(LVM_FIRST+116)
#define	LVM_SETITEMW	(LVM_FIRST+76)
#define	LVM_SETOUTLINECOLOR	(LVM_FIRST+177)
#define	LVM_SETSELECTEDCOLUMN	(LVM_FIRST+140)
#define	LVM_SETSELECTIONMARK	(LVM_FIRST+67)
#define	LVM_SETTEXTBKCOLOR	(LVM_FIRST+38)
#define	LVM_SETTEXTCOLOR	(LVM_FIRST+36)
#define	LVM_SETTILEINFO	(LVM_FIRST+164)
#define	LVM_SETTILEVIEWINFO	(LVM_FIRST+162)
#define	LVM_SETTILEWIDTH	(LVM_FIRST+141)
#define	LVM_SETTOOLTIPS	(LVM_FIRST+74)
#define	LVM_SETVIEW	(LVM_FIRST+142)
#define	LVM_SETWORKAREAS	(LVM_FIRST+65)
#define	LVM_SORTGROUPS	(LVM_FIRST+158)
#define	LVM_SORTITEMS	(LVM_FIRST+48)
#define	LVM_SORTITEMSEX	(LVM_FIRST+81)
#define	LVM_SUBITEMHITTEST	(LVM_FIRST+57)
#define	LVM_UPDATE	(LVM_FIRST+42)
#define LVM_GETUNICODEFORMAT CCM_GETUNICODEFORMAT
#define LVM_SETUNICODEFORMAT CCM_SETUNICODEFORMAT
#define LVN_BEGINDRAG	(-109)
#define LVN_BEGINRDRAG	(-111)
#define LVN_COLUMNCLICK	(-108)
#define LVN_DELETEALLITEMS	(-104)
#define LVN_DELETEITEM	(-103)
#define LVN_BEGINLABELEDITW	(-175)
#define LVN_ENDLABELEDITW	(-176)
#define LVN_GETDISPINFOW	(-177)
#define LVN_SETDISPINFOW	(-178)
#define LVN_BEGINLABELEDITA	(-105)
#define LVN_ENDLABELEDITA	(-106)
#define LVN_GETDISPINFOA	(-150)
#define LVN_SETDISPINFOA	(-151)
#define LVN_INSERTITEM	(-102)
#define LVN_ITEMCHANGED	(-101)
#define LVN_ITEMCHANGING	(-100)
#define LVN_KEYDOWN	(-155)
#define LVN_ODCACHEHINT (-113)
#define LVN_ODFINDITEMA (-152)
#define LVN_ODFINDITEMW (-179)
#define LVN_ODSTATECHANGED (-115)
#define LVN_ITEMACTIVATE	(LVN_FIRST-14)
#define LV_MAX_WORKAREAS	16
#define LV_VIEW_ICON	0
#define LV_VIEW_DETAILS	1
#define LV_VIEW_SMALLICON	2
#define LV_VIEW_LIST	3
#define LV_VIEW_TILE	4
#define LV_VIEW_MAX	4
#define LVGF_NONE 0
#define LVGF_HEADER	1
#define LVGF_FOOTER	2
#define LVGF_STATE	4
#define LVGF_ALIGN	8
#define LVGF_GROUPID	0x10
#define LVGS_NORMAL	0
#define LVGS_COLLAPSED	1
#define LVGS_HIDDEN	2
#define LVGA_HEADER_LEFT 1
#define LVGA_HEADER_CENTER 2
#define LVGA_HEADER_RIGHT 4
#define LVGA_FOOTER_LEFT 8
#define LVGA_FOOTER_CENTER 16
#define LVGA_FOOTER_RIGHT 32
#define LVGMF_NONE 0
#define LVGMF_BORDERSIZE 1
#define LVGMF_BORDERCOLOR 2
#define LVGMF_TEXTCOLOR 4
#define LVTVIF_AUTOSIZE 0
#define LVTVIF_FIXEDWIDTH 1
#define LVTVIF_FIXEDHEIGHT 2
#define LVTVIF_FIXEDSIZE 3
#define LVTVIM_TILESIZE 1
#define LVTVIM_COLUMNS 2
#define LVTVIM_LABELMARGIN 4
#define LVIM_AFTER 1
#define LVM_SETWORKAREAS	(LVM_FIRST+65)
#define LVM_GETWORKAREAS	(LVM_FIRST+70)
#define LVM_GETNUMBEROFWORKAREAS	(LVM_FIRST+73)
#define LVM_GETSELECTIONMARK	(LVM_FIRST+66)
#define LVM_SETSELECTIONMARK	(LVM_FIRST+67)
#define LVM_SETHOVERTIME	(LVM_FIRST+71)
#define LVM_GETHOVERTIME	(LVM_FIRST+72)
#define LVM_SETTOOLTIPS	(LVM_FIRST+74)
#define LVM_GETTOOLTIPS	(LVM_FIRST+78)
#define LVM_SORTITEMSEX	(LVM_FIRST+81)
#define LVBKIF_SOURCE_NONE	0
#define LVBKIF_SOURCE_HBITMAP	1
#define LVBKIF_SOURCE_URL	2
#define LVBKIF_SOURCE_MASK	3
#define LVBKIF_STYLE_NORMAL	0
#define LVBKIF_STYLE_TILE	16
#define LVBKIF_STYLE_MASK	16
#define LVBKIF_FLAG_TILEOFFSET	0x00000100
#define LVBKIF_TYPE_WATERMARK	0x10000000
#define LVM_SETBKIMAGEA		(LVM_FIRST+68)
#define LVM_SETBKIMAGEW		(LVM_FIRST+138)
#define LVM_GETBKIMAGEA		(LVM_FIRST+69)
#define LVM_GETBKIMAGEW		(LVM_FIRST+139)
#define LVKF_ALT	1
#define LVKF_CONTROL	2
#define LVKF_SHIFT	4

#ifdef UNICODE
#define ENUMRESTYPEPROC	ENUMRESTYPEPROCW
#define LVBKIMAGE	LVBKIMAGEW
#define LPLVBKIMAGE	LPLVBKIMAGEW
#define LVM_SETBKIMAGE	LVM_SETBKIMAGEW
#define LVM_GETBKIMAGE	LVM_GETBKIMAGEW
#define GetWindowModuleFileName GetWindowModuleFileNameW
#define NMTOOLBAR	NMTOOLBARW
#define LPNMTOOLBAR	LPNMTOOLBARW
#define TCITEMHEADER	TCITEMHEADERW
#define LPTCITEMHEADER	LPTCITEMHEADERW
#else
#define ENUMRESTYPEPROC	ENUMRESTYPEPROCA
#define LVBKIMAGE	LVBKIMAGEA
#define LPLVBKIMAGE	LPLVBKIMAGEA
#define LVM_SETBKIMAGE	LVM_SETBKIMAGEA
#define LVM_GETBKIMAGE	LVM_GETBKIMAGEA
#define GetWindowModuleFileName GetWindowModuleFileNameA
#define NMTOOLBAR	NMTOOLBARA
#define LPNMTOOLBAR	LPNMTOOLBARA
#define TCITEMHEADER	TCITEMHEADERA
#define LPTCITEMHEADER	LPTCITEMHEADERA
#endif

#define NM_CLICK	(-2)
#define NM_DBLCLK	(-3)
#define NM_KILLFOCUS	(-8)
#define NM_OUTOFMEMORY	(-1)
#define NM_RCLICK	(-5)
#define NM_RDBLCLK	(-6)
#define NM_RETURN	(-4)
#define NM_SETFOCUS	(-7)
#define NM_KILLFOCUS	(-8)
#define NM_CUSTOMDRAW	(-12)
#define NM_HOVER	(-13)
#define NM_NCHITTEST	(-14)
#define NM_KEYDOWN	(-15)
#define NM_RELEASEDCAPTURE (-16)
#define NM_SETCURSOR	(-17)
#define NM_CHAR		(-18)
#define NM_TOOLTIPSCREATED (-19)
#define NM_LDOWN	(-20)
#define NM_THEMECHANGED (-22)
#define NM_RDOWN	(-21)
#define NM_FIRST	0
#define NM_UPDOWN	NMUPDOWN
#define LPNM_UPDOWN	LPNMUPDOWN
#define PBM_DELTAPOS	1027
#define PBM_SETPOS	1026
#define PBM_SETRANGE	1025
#define PBM_SETSTEP	1028
#define PBM_STEPIT	1029
#define PSM_ADDPAGE	1127
#define PSM_APPLY	1134
#define PSM_CANCELTOCLOSE	1131
#define PSM_CHANGED	1128
#define PSM_GETTABCONTROL	1140
#define PSM_GETCURRENTPAGEHWND	1142
#define PSM_ISDIALOGMESSAGE	1141
#define PSM_PRESSBUTTON	1137
#define PSM_QUERYSIBLINGS	1132
#define PSM_REBOOTSYSTEM	1130
#define PSM_REMOVEPAGE	1126
#define PSM_RESTARTWINDOWS	1129
#define PSM_SETCURSEL	1125
#define PSM_SETCURSELID	1138
#define PSM_SETFINISHTEXTW	1145
#define PSM_SETTITLEW	1144
#define PSM_SETFINISHTEXTA	1139
#define PSM_SETTITLEA	1135
#define PSM_SETWIZBUTTONS	1136
#define PSM_UNCHANGED	1133
#define PSN_APPLY	(-202)
#define PSN_HELP	(-205)
#define PSN_KILLACTIVE	(-201)
#define PSN_QUERYCANCEL	(-209)
#define PSN_RESET	(-203)
#define PSN_SETACTIVE	(-200)
#define PSN_WIZBACK	(-206)
#define PSN_WIZFINISH	(-208)
#define PSN_WIZNEXT	(-207)
#define SB_GETBORDERS	1031
#define SB_GETPARTS	1030
#define SB_GETRECT	1034
#define SB_GETTEXTW	1037
#define SB_GETTEXTLENGTHW	1036
#define SB_SETTEXTW	1035
#define SB_GETTEXTA	1026
#define SB_GETTEXTLENGTHA	1027
#define SB_SETTEXTA	1025
#define SB_SETMINHEIGHT	1032
#define SB_SETPARTS	1028
#define SB_SIMPLE	1033
#define SBM_ENABLE_ARROWS	228
#define SBM_GETPOS	225
#define SBM_GETRANGE	227
#define SBM_GETSCROLLINFO	234
#define SBM_SETPOS	224
#define SBM_SETRANGE	226
#define SBM_SETRANGEREDRAW	230
#define SBM_SETSCROLLINFO	233
#define STM_GETICON	369
#define STM_GETIMAGE	371
#define STM_SETICON	368
#define STM_SETIMAGE	370
#define STN_CLICKED	0
#define STN_DBLCLK	1
#define STN_DISABLE	3
#define STN_ENABLE	2
#define TB_ADDBITMAP	1043
#define TB_ADDBUTTONS	1044
#define TB_AUTOSIZE	1057
#define TB_BUTTONCOUNT	1048
#define TB_BUTTONSTRUCTSIZE	1054
#define TB_CHANGEBITMAP	1067
#define TB_CHECKBUTTON	1026
#define TB_COMMANDTOINDEX	1049
#define TB_CUSTOMIZE	1051
#define TB_DELETEBUTTON	1046
#define TB_ENABLEBUTTON	1025
#define TB_GETBITMAP	1068
#define TB_GETBITMAPFLAGS	1065
#define TB_GETBUTTON	1047
#define TB_ADDSTRINGW	1101
#define TB_GETBUTTONTEXTW	1099
#define TB_SAVERESTOREW	1100
#define TB_ADDSTRINGA	1052
#define TB_GETBUTTONTEXTA	1069
#define TB_SAVERESTOREA	1050
#define TB_GETITEMRECT	1053
#define TB_GETROWS	1064
#define TB_GETSTATE	1042
#define TB_GETTOOLTIPS	1059
#define TB_HIDEBUTTON	1028
#define TB_INDETERMINATE	1029
#define TB_INSERTBUTTON	1045
#define TB_INSERTBUTTONW	(WM_USER+67)
#define TB_ADDBUTTONSW	(WM_USER+68)
#define TB_HITTEST	(WM_USER+69)
#define TB_ISBUTTONCHECKED	1034
#define TB_ISBUTTONENABLED	1033
#define TB_ISBUTTONHIDDEN	1036
#define TB_ISBUTTONINDETERMINATE	1037
#define TB_ISBUTTONPRESSED	1035
#define TB_PRESSBUTTON	1027
#define TB_SETBITMAPSIZE	1056
#define TB_SETBUTTONSIZE	1055
#define TB_SETCMDID	1066
#define TB_SETPARENT	1061
#define TB_SETROWS	1063
#define TB_SETSTATE	1041
#define TB_SETTOOLTIPS	1060
#define TB_HITTEST	(WM_USER+69)
#define TB_REPLACEBITMAP (WM_USER+46)
#define TB_SETINDENT	(WM_USER+47)
#define TB_SETIMAGELIST	(WM_USER+48)
#define TB_GETIMAGELIST	(WM_USER+49)
#define TB_LOADIMAGES	(WM_USER+50)
#define TB_GETRECT	(WM_USER+51)
#define TB_SETHOTIMAGELIST	(WM_USER+52)
#define TB_GETHOTIMAGELIST	(WM_USER+53)
#define TB_SETDISABLEDIMAGELIST (WM_USER+54)
#define TB_GETDISABLEDIMAGELIST	(WM_USER+55)
#define TB_SETSTYLE	(WM_USER+56)
#define TB_GETSTYLE	(WM_USER+57)
#define TB_GETBUTTONSIZE	(WM_USER+58)
#define TB_SETBUTTONWIDTH	(WM_USER+59)
#define TB_SETMAXTEXTROWS	(WM_USER+60)
#define TB_GETTEXTROWS	(WM_USER+61)
#define TB_GETINSERTMARK	(WM_USER+79)
#define TB_SETINSERTMARK	(WM_USER+80)
#define TB_INSERTMARKHITTEST	(WM_USER+81)
#define TB_MOVEBUTTON		(WM_USER+82)
#define TB_GETMAXSIZE		(WM_USER+83)
#define TB_SETEXTENDEDSTYLE	(WM_USER+84)
#define TB_GETEXTENDEDSTYLE	(WM_USER+85)
#define TB_GETPADDING		(WM_USER+86)
#define TB_SETPADDING		(WM_USER+87)
#define TB_SETINSERTMARKCOLOR	(WM_USER+88)
#define TB_GETINSERTMARKCOLOR	(WM_USER+89)
#define TB_SETCOLORSCHEME	CCM_SETCOLORSCHEME
#define TB_GETCOLORSCHEME	CCM_GETCOLORSCHEME
#define TB_SETUNICODEFORMAT	CCM_SETUNICODEFORMAT
#define TB_GETUNICODEFORMAT	CCM_GETUNICODEFORMAT
#define TB_MAPACCELERATORW	(WM_USER+90)
#define TB_ADDBUTTONSA		(WM_USER + 20)
#define TB_INSERTBUTTONA	(WM_USER + 21)
#define TB_GETOBJECT		(WM_USER + 62)
#define TB_GETHOTITEM		(WM_USER + 71)
#define TB_SETHOTITEM		(WM_USER + 72)
#define TB_SETANCHORHIGHLIGHT	(WM_USER + 73)
#define TB_GETANCHORHIGHLIGHT	(WM_USER + 74)
#define TB_GETBUTTONINFOW	(WM_USER + 63)
#define TB_SETBUTTONINFOW	(WM_USER + 64)
#define TB_SETDRAWTEXTFLAGS	(WM_USER + 70)
#define TB_GETSTRINGW		(WM_USER + 91)
#define TB_GETSTRINGA		(WM_USER + 92)
#define TB_GETMETRICS		(WM_USER + 101)
#define TB_SETMETRICS		(WM_USER + 102)
#define TB_SETWINDOWTHEME     CCM_SETWINDOWTHEME
#define TBNF_IMAGE	1
#define TBNF_TEXT	2
#define TBNF_DI_SETITEM 0x10000000
#define HICF_OTHER	0
#define HICF_MOUSE	1
#define HICF_ARROWKEYS	2
#define HICF_ACCELERATOR 4
#define HICF_DUPACCEL	8
#define HICF_ENTERING	0x10
#define HICF_LEAVING	0x20
#define HICF_RESELECT	0x40
#define HICF_LMOUSE	0x80
#define HICF_TOGGLEDROPDOWN 0x100
#define WMN_FIRST	(0U-1000U)
#define WMN_LAST	(0U-1200U)
#define BCN_FIRST	(0U-1250U)
#define BCN_HOTITEMCHANGE (BCN_FIRST + 0x0001)
#define BCN_LAST	(0U-1350U)
#define BST_HOT 0x0200
#define MSGF_COMMCTRL_BEGINDRAG	0x4200
#define CDIS_SHOWKEYBOARDCUES	0x0200
#define MSGF_COMMCTRL_SIZEHEADER	0x4201
#define MSGF_COMMCTRL_DRAGSELECT	0x4202
#define MSGF_COMMCTRL_TOOLBARCUST	0x4203

#ifdef UNICODE
#define TB_GETSTRING TB_GETSTRINGW
#define TB_MAPACCELERATOR	TB_MAPACCELERATORW
#else
#define TB_GETSTRING TB_GETSTRINGA
#define TB_MAPACCELERATOR	TB_MAPACCELERATORA
#endif

#define TBMF_PAD 1
#define TBMF_BARPAD 2
#define TBMF_BUTTONSPACING 4
#define TBBF_LARGE	1
#define TBIF_IMAGE	1
#define TBIF_TEXT	2
#define TBIF_STATE	4
#define TBIF_STYLE	8
#define TBIF_LPARAM	16
#define TBIF_COMMAND	32
#define TBIF_SIZE	64
#define TBIF_BYINDEX	0x80000000
#define PGS_VERT	0
#define PGS_HORZ	1
#define PGS_AUTOSCROLL	2
#define PGS_DRAGNDROP	4
#define PGF_INVISIBLE	0
#define PGF_NORMAL	1
#define PGF_GRAYED	2
#define PGF_DEPRESSED	4
#define PGF_HOT	8
#define PGB_TOPORLEFT	0
#define PGB_BOTTOMORRIGHT 1
#define PGM_SETCHILD	(PGM_FIRST+1)
#define Pager_SetChild(h,C) (void)SendMsg((h),PGM_SETCHILD,0,(LPARAM)(C))
#define PGM_RECALCSIZE	(PGM_FIRST+2)
#define Pager_RecalcSize(hwnd) (void)SendMessage((hwnd),PGM_RECALCSIZE,0,0)
#define PGM_FORWARDMOUSE	(PGM_FIRST+3)
#define Pager_ForwardMouse(hwnd,F) (void)SendMessage((hwnd), PGM_FORWARDMOUSE, (WPARAM)(F),0)
#define PGM_SETBKCOLOR	(PGM_FIRST+4)
#define Pager_SetBkColor(h,c) (COLORREF)SendMessage((h),PGM_SETBKCOLOR,0,(LPARAM)(c))
#define PGM_GETBKCOLOR	(PGM_FIRST+5)
#define Pager_GetBkColor(h) (COLORREF)SendMessage((h),PGM_GETBKCOLOR,0,0)
#define PGM_SETBORDER	(PGM_FIRST+6)
#define Pager_SetBorder(h,B) (int)SNDMSG((h),PGM_SETBORDER,0,(LPARAM)(B))
#define PGM_GETBORDER	(PGM_FIRST+7)
#define Pager_GetBorder(hwnd) (int)SNDMSG((hwnd),PGM_GETBORDER,0,0)
#define PGM_SETPOS	(PGM_FIRST+8)
#define Pager_SetPos(hwnd, iPos) (int)SNDMSG((hwnd),PGM_SETPOS,0,(LPARAM)(iPos))
#define PGM_GETPOS	(PGM_FIRST+9)
#define Pager_GetPos(hwnd) (int)SNDMSG((hwnd),PGM_GETPOS,0,0)
#define PGM_SETBUTTONSIZE	(PGM_FIRST+10)
#define Pager_SetButtonSize(hwnd, iSize) (int)SNDMSG((hwnd), PGM_SETBUTTONSIZE, 0, (LPARAM)(iSize))
#define PGM_GETBUTTONSIZE	(PGM_FIRST+11)
#define Pager_GetButtonSize(hwnd) (int)SNDMSG((hwnd),PGM_GETBUTTONSIZE, 0,0)
#define PGM_GETBUTTONSTATE	(PGM_FIRST+12)
#define Pager_GetButtonState(hwnd, iButton) (DWORD)SNDMSG((hwnd), PGM_GETBUTTONSTATE, 0, (LPARAM)(iButton))
#define PGM_GETDROPTARGET	CCM_GETDROPTARGET
#define Pager_GetDropTarget(h,t) (void)SNDMSG((h),PGM_GETDROPTARGET,0,(LPARAM)(t))
#define PGN_SCROLL	(PGN_FIRST-1)
#define PGN_CALCSIZE	(PGN_FIRST-2)
#define PGF_CALCWIDTH	1
#define PGF_CALCHEIGHT	2
#define PGF_SCROLLUP	1
#define PGF_SCROLLDOWN	2
#define PGF_SCROLLLEFT	4
#define PGF_SCROLLRIGHT	8
#define PGK_SHIFT	1
#define PGK_CONTROL	2
#define PGK_MENU	4
#define TBM_CLEARSEL	1043
#define TBM_CLEARTICS	1033
#define TBM_GETCHANNELRECT	1050
#define TBM_GETLINESIZE	1048
#define TBM_GETNUMTICS	1040
#define TBM_GETPAGESIZE	1046
#define TBM_GETPOS	1024
#define TBM_GETPTICS	1038
#define TBM_GETRANGEMAX	1026
#define TBM_GETRANGEMIN	1025
#define TBM_GETSELEND	1042
#define TBM_GETSELSTART	1041
#define TBM_GETTHUMBLENGTH	1052
#define TBM_GETTHUMBRECT	1049
#define TBM_GETTIC	1027
#define TBM_GETTICPOS	1039
#define TBM_SETLINESIZE	1047
#define TBM_SETPAGESIZE	1045
#define TBM_SETPOS	1029
#define TBM_SETRANGE	1030
#define TBM_SETRANGEMAX	1032
#define TBM_SETRANGEMIN	1031
#define TBM_SETSEL	1034
#define TBM_SETSELEND	1036
#define TBM_SETSELSTART	1035
#define TBM_SETTHUMBLENGTH	1051
#define TBM_SETTIC	1028
#define TBM_SETTICFREQ	1044
#define TBM_GETUNICODEFORMAT CCM_GETUNICODEFORMAT
#define TBM_SETUNICODEFORMAT CCM_SETUNICODEFORMAT
#define	TBN_FIRST	(-700U)
#define TBN_BEGINADJUST	(-703U)
#define TBN_BEGINDRAG	(-701U)
#define TBN_CUSTHELP	(-709U)
#define TBN_ENDADJUST	(-704U)
#define TBN_ENDDRAG	(-702U)
#define TBN_GETBUTTONINFOW	(-720U)
#define TBN_GETBUTTONINFOA	(-700U)
#define TBN_QUERYDELETE	(-707U)
#define TBN_QUERYINSERT	(-706U)
#define TBN_RESET	(-705U)
#define TBN_TOOLBARCHANGE	(-708U)
#define TBN_GETDISPINFOA	(TBN_FIRST-16)
#define TBN_GETDISPINFOW	(TBN_FIRST-17)
#define TBN_HOTITEMCHANGE	(TBN_FIRST - 13)
#define TBN_DRAGOUT	(TBN_FIRST - 14)
#define TBN_DELETINGBUTTON	(TBN_FIRST - 15)
#define TBN_GETINFOTIPA	(TBN_FIRST - 18)
#define TBN_GETINFOTIPW	(TBN_FIRST - 19)
#define TBN_RESTORE	(TBN_FIRST - 21)
#define TBN_SAVE	(TBN_FIRST - 22)
#define TBN_INITCUSTOMIZE	(TBN_FIRST - 23)
#define TBN_DROPDOWN	(TBN_FIRST-10)
#define TBN_GETOBJECT	(TBN_FIRST-12)
#define TBNRF_HIDEHELP	1
#define TBNRF_ENDCUSTOMIZE	2
#define TBDDRET_DEFAULT	0
#define TBDDRET_NODEFAULT	1
#define TBDDRET_TREATPRESSED	2
#define TBN_LAST	(-720U)
#define TCM_FIRST	0x1300
#define TCM_ADJUSTRECT	4904
#define TCM_DELETEALLITEMS	4873
#define TCM_DELETEITEM	4872
#define TCM_GETCURFOCUS	4911
#define TCM_GETCURSEL	4875
#define TCM_GETIMAGELIST	4866
#define TCM_GETITEMW	4924
#define TCM_INSERTITEMW	4926
#define TCM_SETITEMW	4925
#define TCM_GETITEMA	4869
#define TCM_INSERTITEMA	4871
#define TCM_SETITEMA	4870
#define TCM_GETITEMCOUNT	4868
#define TCM_GETITEMRECT	4874
#define TCM_GETROWCOUNT	4908
#define TCM_GETTOOLTIPS	4909
#define TCM_HITTEST	4877
#define TCM_REMOVEIMAGE	4906
#define TCM_SETCURFOCUS	4912
#define TCM_SETCURSEL	4876
#define TCM_SETIMAGELIST	4867
#define TCM_SETITEMEXTRA	4878
#define TCM_SETITEMSIZE	4905
#define TCM_SETPADDING	4907
#define TCM_SETTOOLTIPS	4910
#define TCM_GETUNICODEFORMAT CCM_GETUNICODEFORMAT
#define TCM_SETUNICODEFORMAT CCM_SETUNICODEFORMAT
#define TCM_SETMINTABWIDTH	(TCM_FIRST+49)
#define TCM_DESELECTALL	(TCM_FIRST+50)
#define TCM_HIGHLIGHTITEM	(TCM_FIRST+51)
#define TCM_SETEXTENDEDSTYLE	(TCM_FIRST+52)
#define TCM_GETEXTENDEDSTYLE	(TCM_FIRST+53)
#define TCM_SETUNICODEFORMAT	CCM_SETUNICODEFORMAT
#define TCM_GETUNICODEFORMAT	CCM_GETUNICODEFORMAT
#define TCN_KEYDOWN	(-550)
#define TCN_SELCHANGE	(-551)
#define TCN_SELCHANGING	(-552)
#define TCN_GETOBJECT	(TCN_FIRST-3)
#define TTM_ACTIVATE	1025
#define TTM_ADDTOOLW	1074
#define TTM_DELTOOLW	1075
#define TTM_ENUMTOOLSW	1082
#define TTM_GETCURRENTTOOLW	1083
#define TTM_SETWINDOWTHEME	CCM_SETWINDOWTHEME
#define TTM_GETTEXTW	1080
#define TTM_GETTOOLINFOW	1077
#define TTM_HITTESTW	1079
#define TTM_NEWTOOLRECTW	1076
#define TTM_SETTOOLINFOW	1078
#define TTM_UPDATETIPTEXTW	1081
#define TTM_ADDTOOLA	1028
#define TTM_DELTOOLA	1029
#define TTM_ENUMTOOLSA	1038
#define TTM_GETCURRENTTOOLA	1039
#define TTM_GETTEXTA	1035
#define TTM_GETTOOLINFOA	1032
#define TTM_HITTESTA	1034
#define TTM_NEWTOOLRECTA	1030
#define TTM_SETTOOLINFOA	1033
#define TTM_UPDATETIPTEXTA	1036
#define TTM_GETTOOLCOUNT	1037
#define TTM_RELAYEVENT	1031
#define TTM_SETDELAYTIME	1027
#define TTM_WINDOWFROMPOINT	1040
#define	TTM_POP (WM_USER+28)
#define TTM_SETMARGIN	(WM_USER+26)
#define TTM_GETMARGIN	(WM_USER+27)
#define TTM_GETMAXTIPWIDTH	(WM_USER+25)
#define TTM_SETMAXTIPWIDTH	(WM_USER+24)
#define TTM_TRACKACTIVATE	(WM_USER+17)
#define TTM_TRACKPOSITION	(WM_USER+18)
#define TTM_SETTIPBKCOLOR	(WM_USER+19)
#define TTM_SETTIPTEXTCOLOR	(WM_USER+20)
#define TTM_GETDELAYTIME	(WM_USER+21)
#define TTM_GETTIPBKCOLOR	(WM_USER+22)
#define TTM_GETTIPTEXTCOLOR	(WM_USER+23)
#define TTM_GETBUBBLESIZE	(WM_USER + 30)
#define TTM_ADJUSTRECT	(WM_USER+31)
#define TTM_SETTITLEA	(WM_USER+32)
#define TTM_SETTITLEW	(WM_USER+33)
#define TTM_POPUP	(WM_USER + 34)
#define TTM_GETTITLE	(WM_USER + 35)
#define TTN_GETDISPINFOA	(TTN_FIRST-0)
#define TTN_GETDISPINFOW	(TTN_FIRST-10)
#define TTN_SHOW	(TTN_FIRST-1)
#define TTN_POP	(TTN_FIRST - 2)
#define TTN_NEEDTEXTW	(-530)
#define TTN_NEEDTEXTA	(-520)
#define TVM_FIRST	0x1100
#define TV_FIRST	0x1100
#define TVM_INSERTITEMA	(TV_FIRST)
#define TVM_INSERTITEMW	(TV_FIRST+50)
#define TVM_GETTOOLTIPS	(TV_FIRST+25)
#define TVM_SETTOOLTIPS	(TV_FIRST+24)
#define TVM_SETITEMHEIGHT	(TV_FIRST + 27)
#define TVM_GETITEMHEIGHT	(TV_FIRST + 28)
#define TVM_SETBKCOLOR	(TV_FIRST + 29)
#define TVM_SETTEXTCOLOR	(TV_FIRST + 30)
#define TVM_GETBKCOLOR	(TV_FIRST + 31)
#define TVM_GETTEXTCOLOR	(TV_FIRST + 32)
#define TVM_SETSCROLLTIME	(TV_FIRST + 33)
#define TVM_GETSCROLLTIME	(TV_FIRST + 34)
#define TVM_SETINSERTMARKCOLOR	(TV_FIRST + 37)
#define TVM_GETINSERTMARKCOLOR	(TV_FIRST + 38)
#define TVM_CREATEDRAGIMAGE	4370
#define TVM_DELETEITEM	4353
#define TVM_ENDEDITLABELNOW	4374
#define TVM_ENSUREVISIBLE	4372
#define TVM_EXPAND	4354
#define TVM_GETCOUNT	4357
#define TVM_GETEDITCONTROL	4367
#define TVM_GETIMAGELIST	4360
#define TVM_GETINDENT	4358
#define TVM_GETITEMSTATE	(TV_FIRST+39)
#define TVM_SETLINECOLOR	(TV_FIRST+40)
#define TVM_GETLINECOLOR	(TV_FIRST+41)
#define TVM_GETITEMRECT	4356
#define TVM_GETNEXTITEM	4362
#define TVM_GETVISIBLECOUNT	4368
#define TVM_HITTEST	4369
#define TVM_EDITLABELW	4417
#define TVM_GETISEARCHSTRINGW	4416
#define TVM_GETITEMW	4414
#define TVM_SETITEMW	4415
#define TVM_EDITLABELA	4366
#define TVM_GETISEARCHSTRINGA	4375
#define TVM_GETITEMA	4364
#define TVM_SETITEMA	4365
#define TVM_SELECTITEM	4363
#define TVM_SETIMAGELIST	4361
#define TVM_SETINDENT	4359
#define TVM_SORTCHILDREN	4371
#define TVM_SORTCHILDRENCB	4373
#define TVM_GETUNICODEFORMAT CCM_GETUNICODEFORMAT
#define TVM_SETUNICODEFORMAT CCM_SETUNICODEFORMAT
#define TVN_KEYDOWN	(-412)
#define TVN_BEGINDRAGW	(-456)
#define TVN_BEGINLABELEDITW	(-459)
#define TVN_BEGINRDRAGW	(-457)
#define TVN_DELETEITEMW	(-458)
#define TVN_ENDLABELEDITW	(-460)
#define TVN_GETDISPINFOW	(-452)
#define TVN_ITEMEXPANDEDW	(-455)
#define TVN_ITEMEXPANDINGW	(-454)
#define TVN_SELCHANGEDW	(-451)
#define TVN_SELCHANGINGW	(-450)
#define TVN_SETDISPINFOW	(-453)
#define TVN_BEGINDRAGA	(-407)
#define TVN_BEGINLABELEDITA	(-410)
#define TVN_BEGINRDRAGA	(-408)
#define TVN_DELETEITEMA	(-409)
#define TVN_ENDLABELEDITA	(-411)
#define TVN_GETDISPINFOA	(-403)
#define TVN_ITEMEXPANDEDA	(-406)
#define TVN_ITEMEXPANDINGA	(-405)
#define TVN_SELCHANGEDA	(-402)
#define TVN_SELCHANGINGA	(-401)
#define TVN_SETDISPINFOA	(-404)
#define UDM_GETACCEL	1132
#define UDM_GETBASE	1134
#define UDM_GETBUDDY	1130
#define UDM_GETPOS	1128
#define UDM_GETRANGE	1126
#define UDM_SETACCEL	1131
#define UDM_SETBASE	1133
#define UDM_SETBUDDY	1129
#define UDM_SETPOS	1127
#define UDM_SETRANGE	1125
#define UDM_GETUNICODEFORMAT CCM_GETUNICODEFORMAT
#define UDM_SETUNICODEFORMAT CCM_SETUNICODEFORMAT
#define UDN_DELTAPOS	(-722)

#define WM_NULL	0
#define WM_APP	0x8000
#define WM_ACTIVATE	6
#define WM_ACTIVATEAPP	28
#define WM_ASKCBFORMATNAME	780
#define WM_CANCELJOURNAL	75
#define WM_CANCELMODE	31
#define WM_CAPTURECHANGED	533
#define WM_CHANGECBCHAIN	781
#define WM_CHAR	258
#define WM_CHARTOITEM	47
#define WM_CHILDACTIVATE	34
#define WM_CHOOSEFONT_GETLOGFONT	1025
#define WM_CHOOSEFONT_SETLOGFONT	1125
#define WM_CHOOSEFONT_SETFLAGS	1126
#define WM_CLEAR	771
#define WM_CLOSE	16
#define WM_COMMAND	273
#define WM_COMPACTING	65
#define WM_COMPAREITEM	57
#define WM_CONTEXTMENU	123
#define WM_COPY	769
#define WM_COPYDATA	74
#define WM_CREATE	1
#define WM_CTLCOLORBTN	309
#define WM_CTLCOLORDLG	310
#define WM_CTLCOLOREDIT	307
#define WM_CTLCOLORLISTBOX	308
#define WM_CTLCOLORMSGBOX	306
#define WM_CTLCOLORSCROLLBAR	311
#define WM_CTLCOLORSTATIC	312
#define WM_CUT	768
#define WM_DEADCHAR	259
#define WM_DELETEITEM	45
#define WM_DESTROY	2
#define WM_DESTROYCLIPBOARD	775
#define WM_DEVICECHANGE	537
#define WM_DEVMODECHANGE	27
#define WM_DISPLAYCHANGE	126
#define WM_DRAWCLIPBOARD	776
#define WM_DRAWITEM	43
#define WM_DROPFILES	563
#define WM_ENABLE	10
#define WM_ENDSESSION	22
#define WM_ENTERIDLE	289
#define WM_ENTERMENULOOP	529
#define WM_ENTERSIZEMOVE	561
#define WM_ERASEBKGND	20
#define WM_EXITMENULOOP	530
#define WM_EXITSIZEMOVE	562
#define WM_FONTCHANGE	29
#define WM_GETDLGCODE	135
#define WM_GETFONT	49
#define WM_GETHOTKEY	51
#define WM_GETICON	127
#define WM_GETMINMAXINFO	36
#define WM_GETTEXT	13
#define WM_GETTEXTLENGTH	14
#define WM_HELP	83
#define WM_HOTKEY	786
#define WM_HSCROLL	276
#define WM_HSCROLLCLIPBOARD	782
#define WM_ICONERASEBKGND	39
#define WM_IME_CHAR	646
#define WM_IME_COMPOSITION	271
#define WM_IME_COMPOSITIONFULL	644
#define WM_IME_CONTROL	643
#define WM_IME_ENDCOMPOSITION	270
#define WM_IME_KEYDOWN	656
#define WM_IME_KEYUP	657
#define WM_IME_NOTIFY	642
#define WM_IME_SELECT	645
#define WM_IME_SETCONTEXT	641
#define WM_IME_STARTCOMPOSITION	269
#define WM_INITDIALOG	272
#define WM_INITMENU	278
#define WM_INITMENUPOPUP	279
#define WM_INPUTLANGCHANGE	81
#define WM_INPUTLANGCHANGEREQUEST	80
#define WM_INPUT 0xff
#define WM_KEYDOWN	256
#define WM_KEYUP	257
#define WM_KILLFOCUS	8
#define WM_LBUTTONDBLCLK	515
#define WM_LBUTTONDOWN	513
#define WM_LBUTTONUP	514
#define WM_MBUTTONDBLCLK	521
#define WM_MBUTTONDOWN	519
#define WM_MBUTTONUP	520
#define WM_MDIACTIVATE	546
#define WM_MDICASCADE	551
#define WM_MDICREATE	544
#define WM_MDIDESTROY	545
#define WM_MDIGETACTIVE	553
#define WM_MDIICONARRANGE	552
#define WM_MDIMAXIMIZE	549
#define WM_MDINEXT	548
#define WM_MDIREFRESHMENU	564
#define WM_MDIRESTORE	547
#define WM_MDISETMENU	560
#define WM_MDITILE	550
#define WM_MEASUREITEM	44
#define WM_MENUCHAR	288
#define WM_MENUSELECT	287
#define WM_MENURBUTTONUP 0x0122
#define WM_MENUDRAG	0x0123
#define WM_MENUGETOBJECT 0x0124
#define WM_UNINITMENUPOPUP 0x0125
#define WM_MENUCOMMAND	0x0126
#define WM_CHANGEUISTATE 0x0127
#define WM_UPDATEUISTATE 0x0128
#define WM_QUERYUISTATE	0x0129
#define UIS_SET	1
#define UIS_CLEAR	2
#define UIS_INITIALIZE 3
#define WM_MOUSEACTIVATE	33
#define WM_MOUSEMOVE	512
#define WM_MOUSEHOVER	0x2a1
#define WM_MOUSELEAVE	0x2a3
#define WM_MOUSEWHEEL	0x20A
#define WM_MOVE	3
#define WM_MOVING	534
#define WM_NCACTIVATE	134
#define WM_NCCALCSIZE	131
#define WM_NCCREATE	129
#define WM_NCDESTROY	130
#define WM_NCHITTEST	132
#define WM_NCLBUTTONDBLCLK	163
#define WM_NCLBUTTONDOWN	161
#define WM_NCLBUTTONUP	162
#define WM_NCMBUTTONDBLCLK	169
#define WM_NCMBUTTONDOWN	167
#define WM_NCMBUTTONUP	168
#define WM_NCMOUSEMOVE	160
#define WM_NCPAINT	133
#define WM_NCRBUTTONDBLCLK	166
#define WM_NCRBUTTONDOWN	164
#define WM_NCRBUTTONUP	165
#define WM_NEXTDLGCTL	40
#define WM_NOTIFY	78
#define WM_NOTIFYFORMAT	85
#define WM_PAINT	15
#define WM_PAINTCLIPBOARD	777
#define WM_PAINTICON	38
#define WM_PALETTECHANGED	785
#define WM_PALETTEISCHANGING	784
#define WM_PARENTNOTIFY	528
#define WM_PASTE	770
#define WM_PENWINFIRST	896
#define WM_SYNCPAINT	0x0088
#define WM_AFXFIRST	0x0360
#define WM_AFXLAST	0x037F
#define WM_HANDHELDFIRST 0x0358
#define WM_HANDHELDLAST 0x035F
#define WM_PENWINLAST	911
#define WM_POWER	72
#define WM_POWERBROADCAST	536
#define WM_PRINT	791
#define WM_PRINTCLIENT	792
#define WM_PSD_ENVSTAMPRECT	1029
#define WM_PSD_FULLPAGERECT	1025
#define WM_PSD_GREEKTEXTRECT	1028
#define WM_PSD_MARGINRECT	1027
#define WM_PSD_MINMARGINRECT	1026
#define WM_PSD_PAGESETUPDLG	1024
#define WM_PSD_YAFULLPAGERECT	1030
#define WM_QUERYDRAGICON	55
#define WM_QUERYENDSESSION	17
#define WM_QUERYNEWPALETTE	783
#define WM_QUERYOPEN	19
#define WM_QUEUESYNC	35
#define WM_QUIT	18
#define WM_RBUTTONDBLCLK	518
#define WM_RBUTTONDOWN	516
#define WM_RBUTTONUP	517
#define WM_RENDERALLFORMATS	774
#define WM_RENDERFORMAT	773
#define WM_SETCURSOR	32
#define WM_SETFOCUS	7
#define WM_SETFONT	48
#define WM_SETHOTKEY	50
#define WM_SETICON	128
#define WM_SETREDRAW	11
#define WM_SETTEXT	12
#define WM_SETTINGCHANGE	26
#define WM_SHOWWINDOW	24
#define WM_SIZE	5
#define WM_SIZECLIPBOARD	779
#define WM_SIZING	532
#define WM_SPOOLERSTATUS	42
#define WM_STYLECHANGED	125
#define WM_STYLECHANGING	124
#define WM_SYSCHAR	262
#define WM_SYSCOLORCHANGE	21
#define WM_SYSCOMMAND	274
#define WM_SYSDEADCHAR	263
#define WM_SYSKEYDOWN	260
#define WM_SYSKEYUP	261
#define WM_TCARD	82
#define WM_TIMECHANGE	30
#define WM_TIMER	275
#define WM_UNDO	772
#define WM_USER	1024
#define WM_USERCHANGED	84
#define WM_VKEYTOITEM	46
#define WM_VSCROLL	277
#define WM_VSCROLLCLIPBOARD	778
#define WM_WINDOWPOSCHANGED	71
#define WM_WINDOWPOSCHANGING	70
#define WM_XBUTTONDOWN	0x020B
#define WM_XBUTTONUP	0x020C
#define WM_XBUTTONDBLCLK	0x020D
#define WM_WININICHANGE	26
#define WM_KEYFIRST	256
#define WM_KEYLAST	264
#define WM_MOUSEFIRST	512
#define WM_MOUSELAST 0x020D
#define WM_NEXTMENU	0x0213
#define WM_CHANGEUISTATE	0x0127
#define WM_UPDATEUISTATE	0x0128
#define WM_QUERYUISTATE	0x0129
#define WM_WTSSESSION_CHANGE 0x02B1
#define WM_LBTRACKPOINT	0x0131
#define WM_GETOBJECT 0x003D
#define WM_COMMNOTIFY 0x0044
#define WM_TABLET_FIRST	0x02c0
#define WM_TABLET_LAST	0x02df
#define WM_IME_REQUEST	0x0288
#define WM_IME_KEYLAST 0x010F
#define WM_NCMOUSEHOVER	0x02A0
#define WM_NCMOUSELEAVE 0x02A2

#define COMCTL32_VERSION 6
#define CCM_SETVERSION (CCM_FIRST+0x7)
#define CCM_GETVERSION (CCM_FIRST+0x8)
#define CCM_SETNOTIFYWINDOW (CCM_FIRST+0x9)
#define CCM_SETWINDOWTHEME    (CCM_FIRST + 0xb)
#define CCM_DPISCALE        (CCM_FIRST + 0xc)
#define INFOTIPSIZE	1024
#define PGM_FIRST	0x1400
#define CCM_FIRST	0x2000
#define CCM_LAST	(CCM_FIRST + 0x200)
#define CCM_SETBKCOLOR	(CCM_FIRST + 1)
#define CCM_SETCOLORSCHEME	(CCM_FIRST + 2)
#define CCM_GETCOLORSCHEME	(CCM_FIRST + 3)
#define CCM_GETDROPTARGET	(CCM_FIRST + 4)
#define CCM_SETUNICODEFORMAT	(CCM_FIRST + 5)
#define CCM_GETUNICODEFORMAT	(CCM_FIRST + 6)
#define CBEM_INSERTITEMA	(WM_USER+1)
#define CBEM_SETIMAGELIST	(WM_USER+2)
#define CBEM_GETIMAGELIST	(WM_USER+3)
#define CBEM_GETITEMA		(WM_USER+4)
#define CBEM_SETITEMA		(WM_USER+5)
#define CBEM_DELETEITEM	CB_DELETESTRING
#define CBEM_GETCOMBOCONTROL	(WM_USER+6)
#define CBEM_GETEDITCONTROL	(WM_USER+7)
#define CBEM_SETEXSTYLE		(WM_USER+8)
#define CBEM_SETEXTENDEDSTYLE	(WM_USER+14)
#define CBEM_GETEXSTYLE		(WM_USER+9)
#define CBEM_GETEXTENDEDSTYLE	(WM_USER+9)
#define CBEM_SETUNICODEFORMAT	CCM_SETUNICODEFORMAT
#define CBEM_GETUNICODEFORMAT	CCM_GETUNICODEFORMAT
#define CBEM_HASEDITCHANGED	(WM_USER+10)
#define CBEM_INSERTITEMW	(WM_USER+11)
#define CBEM_SETITEMW	(WM_USER+12)
#define CBEM_GETITEMW	(WM_USER+13)
/* Defines.h WIN32 definitions */
#undef MAX_PATH
#define MAX_PATH	260
#define UNICODE_NULL ((WCHAR)0)
#define LF_FACESIZE	32
#define LF_FULLFACESIZE	64
#define ELF_VENDOR_SIZE	4
#define SECURITY_STATIC_TRACKING	0
#define SECURITY_DYNAMIC_TRACKING	1
#define MAX_DEFAULTCHAR	2
#define MAX_LEADBYTES	12
#define EXCEPTION_MAXIMUM_PARAMETERS	15
#define CCHDEVICENAME	32
#define CCHFORMNAME	32
#define MENU_TEXT_LEN	40
#define MAX_LANA	254
#define NCBNAMSZ	16
#define NETBIOS_NAME_LEN	16
#define OFS_MAXPATHNAME	128
#define MAX_TAB_STOPS	32
#define ANYSIZE_ARRAY	1
#define FILE_BEGIN	0
#define FILE_CURRENT	1
#define FILE_END	2
#define OF_READ	0
#define OF_READWRITE	2
#define OF_WRITE	1
#define OF_SHARE_COMPAT	0
#define OF_SHARE_DENY_NONE	64
#define OF_SHARE_DENY_READ	48
#define OF_SHARE_DENY_WRITE	32
#define OF_SHARE_EXCLUSIVE	16
#define OF_CANCEL	2048
#define OF_CREATE	4096
#define OF_DELETE	512
#define OF_EXIST	16384
#define OF_PARSE	256
#define OF_PROMPT	8192
#define OF_REOPEN	32768
#define OF_VERIFY	1024
#define HKL_NEXT	1
#define HKL_PREV	0
#define KLF_REORDER	8
#define KLF_UNLOADPREVIOUS	4
#define KLF_ACTIVATE	1
#define KLF_NOTELLSHELL	128
#define KLF_REPLACELANG	16
#define KLF_SUBSTITUTE_OK	2
#define MF_BITMAP	4
#define MF_CHECKED	8
#define MF_DISABLED	2
#define MF_ENABLED	0
#define MF_GRAYED	1
#define MF_MENUBARBREAK	32
#define MF_MENUBREAK	64
#define MF_OWNERDRAW	256
#define MF_POPUP	16
#define MF_SEPARATOR	0x800
#define MF_STRING	0
#define MF_UNCHECKED	0
#define MF_DEFAULT	4096
#define MF_SYSMENU	0x2000
#define MF_HELP		0x4000
#define MF_END	128
#define MF_RIGHTJUSTIFY 0x4000
#define MF_MOUSESELECT 0x8000
#define BLACKNESS	0x42
#define NOTSRCERASE	0x1100A6
#define NOTSRCCOPY	0x330008
#define SRCERASE	0x440328
#define DSTINVERT	0x550009
#define PATINVERT	0x5A0049
#define SRCINVERT	0x660046
#define SRCAND	0x8800C6
#define MERGEPAINT	0xBB0226
#define MERGECOPY	0xC000CA
#define SRCCOPY	0xCC0020
#define SRCPAINT	0xEE0086
#define PATCOPY	0xF00021
#define PATPAINT	0xFB0A09
#define WHITENESS	0xFF0062
#define NOMIRRORBITMAP	0x80000000
#define CAPTUREBLT	0x40000000
#define R2_BLACK	1
#define R2_COPYPEN	13
#define R2_MASKNOTPEN	3
#define R2_MASKPEN	9
#define R2_MASKPENNOT	5
#define R2_MERGENOTPEN	12
#define R2_MERGEPEN	15
#define R2_MERGEPENNOT	14
#define R2_NOP	11
#define R2_NOT	6
#define R2_NOTCOPYPEN	4
#define R2_NOTMASKPEN	8
#define R2_NOTMERGEPEN	2
#define R2_NOTXORPEN	10
#define R2_WHITE	16
#define R2_XORPEN	7
#define R2_LAST		16
#define BSF_FLUSHDISK	4
#define BSF_FORCEIFHUNG	32
#define BSF_IGNORECURRENTTASK	2
#define BSF_NOHANG	8
#define BSF_POSTMESSAGE	16
#define BSF_QUERY	1
#define BSM_ALLCOMPONENTS	0
#define BSM_APPLICATIONS	8
#define BSM_INSTALLABLEDRIVERS	4
#define BSM_NETDRIVER	2
#define BSM_VXDS	1
#define BROADCAST_QUERY_DENY	1112363332
#define NMPWAIT_NOWAIT	1
#define NMPWAIT_WAIT_FOREVER	(-1)
#define NMPWAIT_USE_DEFAULT_WAIT	0
#define MDITILE_SKIPDISABLED	2
#define MDITILE_HORIZONTAL	1
#define MDITILE_VERTICAL	0
#define HCBT_ACTIVATE	5
#define HCBT_CLICKSKIPPED	6
#define HCBT_CREATEWND	3
#define HCBT_DESTROYWND	4
#define HCBT_KEYSKIPPED	7
#define HCBT_MINMAX	1
#define HCBT_MOVESIZE	0
#define HCBT_QS	2
#define HCBT_SETFOCUS	9
#define HCBT_SYSCOMMAND	8
#define DM_BITSPERPEL	0x40000
#define DM_PELSWIDTH	0x80000
#define DM_PELSHEIGHT	0x100000
#define DM_DISPLAYFLAGS	0x200000
#define DM_DISPLAYFREQUENCY 0x400000
#define CDS_UPDATEREGISTRY	1
#define CDS_TEST	2
#define CDS_GLOBAL	8
#define CDS_FULLSCREEN	4
#define CDS_SETPRIMARY	16
#define CDS_VIDEOPARAMETERS 32
#define CDS_RESET	0x40000000
#define CDS_NORESET	0x10000000
#define DISP_CHANGE_SUCCESSFUL	0
#define DISP_CHANGE_RESTART	1
#define DISP_CHANGE_BADPARAM     (-5)
#define DISP_CHANGE_BADFLAGS	(-4)
#define DISP_CHANGE_FAILED	(-1)
#define DISP_CHANGE_BADMODE	(-2)
#define DISP_CHANGE_NOTUPDATED	(-3)
#define BST_CHECKED	1
#define BST_INDETERMINATE	2
#define BST_UNCHECKED	0
#define BST_FOCUS	8
#define BST_PUSHED	4
#define MF_BYCOMMAND	0
#define MF_BYPOSITION	0x400
#define MF_UNCHECKED	0
#define MF_HILITE	128
#define MF_UNHILITE	0
#define CWP_ALL	0
#define CWP_SKIPINVISIBLE	1
#define CWP_SKIPDISABLED	2
#define CWP_SKIPTRANSPARENT	4
#define CE_BREAK	16
#define CE_DNS	2048
#define CE_FRAME	8
#define CE_IOE	1024
#define CE_MODE	32768
#define CE_OOP	4096
#define CE_OVERRUN	2
#define CE_PTO	512
#define CE_RXOVER	1
#define CE_RXPARITY	4
#define CE_TXFULL	256
#define RGN_AND	1
#define RGN_COPY	5
#define RGN_DIFF	4
#define RGN_OR	2
#define RGN_XOR	3
#define NULLREGION	1
#define SIMPLEREGION	2
#define COMPLEXREGION	3
#define ERROR	0
#define RGN_ERROR	ERROR
#define RGN_MIN	RGN_AND
#define RGN_MAX	RGN_COPY
#define LOCALE_SYSTEM_DEFAULT	0x800
#define LOCALE_USER_DEFAULT	0x400
#define NORM_IGNORECASE	1
#define NORM_IGNOREKANATYPE	65536
#define NORM_IGNORENONSPACE	2
#define NORM_IGNORESYMBOLS	4
#define NORM_IGNOREWIDTH	131072
#define SORT_STRINGSORT	4096
#define LCMAP_BYTEREV	2048
#define LCMAP_FULLWIDTH	8388608
#define LCMAP_HALFWIDTH	4194304
#define LCMAP_HIRAGANA	1048576
#define LCMAP_KATAKANA	2097152
#define LCMAP_LOWERCASE	256
#define LCMAP_SORTKEY	1024
#define LCMAP_UPPERCASE	512
#define DBG_CONTINUE ((DWORD)0x10002)
#define DBG_TERMINATE_THREAD ((DWORD)0x40010003)
#define DBG_TERMINATE_PROCESS ((DWORD)0x40010004)
#define DBG_CONTROL_C ((DWORD)0x40010005)
#define DBG_CONTROL_BREAK ((DWORD)0x40010008)
#define DBG_EXCEPTION_NOT_HANDLED ((DWORD)0x80010001)
#define IMAGE_BITMAP	0
#define IMAGE_CURSOR	2
#define IMAGE_ENHMETAFILE	1
#define IMAGE_ICON	1
#define LR_COPYDELETEORG	8
#define LR_COPYRETURNORG	4
#define LR_MONOCHROME	1
#define LR_DEFAULTSIZE	64
#define DF_ALLOWOTHERACCOUNTHOOK	1
#define DESKTOP_CREATEMENU	4
#define DESKTOP_CREATEWINDOW	2
#define DESKTOP_ENUMERATE	64
#define DESKTOP_HOOKCONTROL	8
#define DESKTOP_JOURNALPLAYBACK	32
#define DESKTOP_JOURNALRECORD	16
#define DESKTOP_READOBJECTS	1
#define DESKTOP_SWITCHDESKTOP	256
#define DESKTOP_WRITEOBJECTS	128
#define WSF_VISIBLE	1
#define CBM_INIT	4
#define DIB_PAL_COLORS	1
#define DIB_RGB_COLORS	0
#define GENERIC_READ	0x80000000
#define GENERIC_WRITE	0x40000000
#define FILE_SHARE_READ	1
#define FILE_SHARE_WRITE	2
#define FILE_SHARE_DELETE 4
#define CONSOLE_TEXTMODE_BUFFER	1
#define CREATE_NEW	1
#define CREATE_ALWAYS	2
#define OPEN_EXISTING	3
#define OPEN_ALWAYS	4
#define TRUNCATE_EXISTING	5
#define FILE_ATTRIBUTE_ARCHIVE	32
#define FILE_ATTRIBUTE_COMPRESSED	2048
#define FILE_ATTRIBUTE_NORMAL	128
#define FILE_ATTRIBUTE_DIRECTORY	16
#define FILE_ATTRIBUTE_HIDDEN	2
#define FILE_ATTRIBUTE_READONLY	1
#define FILE_ATTRIBUTE_SYSTEM	4
#define FILE_ATTRIBUTE_TEMPORARY	256
#define FILE_ATTRIBUTE_SPARSE_FILE 0x200
#define FILE_ATTRIBUTE_REPARSE_POINT 0x400
#define FILE_ATTRIBUTE_OFFLINE 0x1000
#define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED 0x00002000
#define FILE_ATTRIBUTE_ENCRYPTED 0x4000
#define FILE_FLAG_WRITE_THROUGH	0x80000000
#define FILE_FLAG_OVERLAPPED	1073741824
#define FILE_FLAG_NO_BUFFERING	536870912
#define FILE_FLAG_RANDOM_ACCESS	268435456
#define FILE_FLAG_SEQUENTIAL_SCAN	134217728
#define FILE_FLAG_DELETE_ON_CLOSE	67108864
#define FILE_FLAG_BACKUP_SEMANTICS	33554432
#define FILE_FLAG_POSIX_SEMANTICS	16777216
#define FILE_FLAG_OPEN_REPARSE_POINT	0x200000
#define FILE_FLAG_OPEN_NO_RECALL	0x100000
#define FILE_FLAG_FIRST_PIPE_INSTANCE	0x00080000
#define SECURITY_ANONYMOUS	0
#define SECURITY_IDENTIFICATION	65536
#define SECURITY_IMPERSONATION	131072
#define SECURITY_DELEGATION	196608
#define SECURITY_CONTEXT_TRACKING	262144
#define SECURITY_EFFECTIVE_ONLY	524288
#define SECURITY_SQOS_PRESENT	1048576
#define PAGE_READONLY	2
#define PAGE_READWRITE	4
#define PAGE_WRITECOPY	8
#define SEC_COMMIT	134217728
#define SEC_IMAGE	16777216
#define SEC_NOCACHE	268435456
#define SEC_RESERVE	67108864
#define MEM_COMMIT	4096
#define MEM_RESERVE	8192
#define MEM_TOP_DOWN	1048576
#define PAGE_EXECUTE	16
#define PAGE_EXECUTE_READ	32
#define PAGE_EXECUTE_READWRITE	64
#define PAGE_GUARD	256
#define PAGE_NOACCESS	1
#define PAGE_NOCACHE	512
#define MEM_COMMIT	4096
#define MEM_FREE	65536
#define MEM_RESERVE	8192
#define MEM_IMAGE	16777216
#define MEM_MAPPED	262144
#define MEM_PRIVATE	131072
#define MEM_DECOMMIT	16384
#define MEM_RELEASE	32768
#define WRITE_WATCH_FLAG_RESET 1
#define FILE_READ_DATA	1
#define FILE_LIST_DIRECTORY	1
#define FILE_WRITE_DATA	2
#define FILE_ADD_FILE	2
#define FILE_APPEND_DATA	4
#define FILE_ADD_SUBDIRECTORY	4
#define FILE_CREATE_PIPE_INSTANCE 4
#define FILE_READ_EA	8
#define FILE_WRITE_EA	0x10
#define FILE_EXECUTE	0x20
#define FILE_TRAVERSE	0x0020
#define FILE_DELETE_CHILD	0x0040
#define FILE_READ_ATTRIBUTES	0x0080
#define FILE_WRITE_ATTRIBUTES	0x100
#define FILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x1FF)
#define FILE_GENERIC_READ (STANDARD_RIGHTS_READ|FILE_READ_DATA| FILE_READ_ATTRIBUTES|FILE_READ_EA|SYNCHRONIZE)
#define FILE_GENERIC_WRITE (STANDARD_RIGHTS_WRITE|FILE_WRITE_DATA|FILE_WRITE_ATTRIBUTES|FILE_WRITE_EA|FILE_APPEND_DATA|SYNCHRONIZE)
#define FILE_GENERIC_EXECUTE (STANDARD_RIGHTS_EXECUTE|FILE_READ_ATTRIBUTES|FILE_EXECUTE|SYNCHRONIZE)
#define PAGE_EXECUTE_WRITECOPY	128
#define EXCEPTION_GUARD_PAGE	0x80000001
#define SECTION_EXTEND_SIZE	16
#define SECTION_MAP_READ	4
#define SECTION_MAP_WRITE	2
#define SECTION_QUERY	1
#define SECTION_ALL_ACCESS	0xf001f
#define FW_DONTCARE	0
#define FW_THIN	100
#define FW_EXTRALIGHT	200
#define FW_LIGHT	300
#define FW_NORMAL	400
#define FW_REGULAR	400
#define FW_MEDIUM	500
#define FW_SEMIBOLD	600
#define FW_BOLD	700
#define FW_EXTRABOLD	800
#define FW_HEAVY	900
#define CLEARTYPE_QUALITY 5
#define ANSI_CHARSET	0
#define DEFAULT_CHARSET	1
#define SYMBOL_CHARSET	2
#define SHIFTJIS_CHARSET	128
#define HANGEUL_CHARSET	129
#define GB2312_CHARSET	134
#define CHINESEBIG5_CHARSET	136
#define GREEK_CHARSET	161
#define TURKISH_CHARSET	162
#define HEBREW_CHARSET	177
#define ARABIC_CHARSET	178
#define BALTIC_CHARSET	186
#define RUSSIAN_CHARSET	204
#define THAI_CHARSET	222
#define EASTEUROPE_CHARSET	238
#define OEM_CHARSET	255
#define OUT_DEFAULT_PRECIS	0
#define OUT_STRING_PRECIS	1
#define OUT_CHARACTER_PRECIS	2
#define OUT_STROKE_PRECIS	3
#define OUT_TT_PRECIS	4
#define OUT_DEVICE_PRECIS	5
#define OUT_RASTER_PRECIS	6
#define OUT_TT_ONLY_PRECIS	7
#define OUT_OUTLINE_PRECIS	8
#define CLIP_DEFAULT_PRECIS	0
#define CLIP_CHARACTER_PRECIS	1
#define CLIP_STROKE_PRECIS	2
#define CLIP_MASK	15
#define CLIP_LH_ANGLES	16
#define CLIP_TT_ALWAYS	32
#define CLIP_EMBEDDED	128
#define DEFAULT_QUALITY	0
#define DRAFT_QUALITY	1
#define PROOF_QUALITY	2
#define NONANTIALIASED_QUALITY	3
#define ANTIALIASED_QUALITY	4
#define DEFAULT_PITCH	0
#define FIXED_PITCH	1
#define VARIABLE_PITCH	2
#define FF_DECORATIVE	80
#define FF_DONTCARE	0
#define FF_MODERN	48
#define FF_ROMAN	16
#define FF_SCRIPT	64
#define FF_SWISS	32
#define HS_BDIAGONAL	3
#define HS_CROSS	4
#define HS_DIAGCROSS	5
#define HS_FDIAGONAL	2
#define HS_HORIZONTAL	0
#define HS_VERTICAL	1
#define LR_DEFAULTCOLOR	0
#define LR_LOADREALSIZE	128
#define LR_MONOCHROME	1
#define LR_COPYRETURNORG 4
#define LR_COPYDELETEORG 8
#define LR_LOADFROMFILE	16
#define LR_LOADTRANSPARENT 32
#define LR_DEFAULTSIZE	64
#define LR_VGACOLOR	0x80
#define LR_LOADMAP3DCOLORS 0x1000
#define LR_CREATEDIBSECTION 0x2000
#define LR_COPYFROMRESOURCE 0x4000
#define LR_SHARED	0x8000
#define MAILSLOT_WAIT_FOREVER	0xffffffff
#define MAILSLOT_NO_MESSAGE	0xffffffff
#define CMB_MASKED	2
#define PIPE_ACCESS_DUPLEX	3
#define PIPE_ACCESS_INBOUND	1
#define PIPE_ACCESS_OUTBOUND	2
#define WRITE_DAC	0x40000
#define WRITE_OWNER	0x80000
#define ACCESS_SYSTEM_SECURITY	0x1000000
#define PIPE_TYPE_BYTE	0
#define PIPE_TYPE_MESSAGE	4
#define PIPE_READMODE_BYTE	0
#define PIPE_READMODE_MESSAGE	2
#define PIPE_WAIT	0
#define PIPE_NOWAIT	1
#define PIPE_UNLIMITED_INSTANCES 255
#define PROGRESS_CONTINUE 0
#define PROGRESS_CANCEL	1
#define PROGRESS_STOP	2
#define PROGRESS_QUIET	3
#define CALLBACK_CHUNK_FINISHED 0
#define CALLBACK_STREAM_SWITCH	1
#define COPY_FILE_FAIL_IF_EXISTS 1
#define COPY_FILE_RESTARTABLE	2
#define COPY_FILE_OPEN_SOURCE_FOR_WRITE 4
#define COPY_FILE_ALLOW_DECRYPTED_DESTINATION 8
#define REPLACEFILE_WRITE_THROUGH 1
#define REPLACEFILE_IGNORE_MERGE_ERRORS 2
#define PS_GEOMETRIC	65536
#define PS_COSMETIC	0
#define PS_ALTERNATE	8
#define PS_SOLID	0
#define PS_DASH	1
#define PS_DOT	2
#define PS_DASHDOT	3
#define PS_DASHDOTDOT	4
#define PS_NULL	5
#define PS_USERSTYLE	7
#define PS_INSIDEFRAME	6
#define PS_ENDCAP_ROUND	0
#define PS_ENDCAP_SQUARE	256
#define PS_ENDCAP_FLAT	512
#define PS_JOIN_BEVEL	4096
#define PS_JOIN_MITER	8192
#define PS_JOIN_ROUND	0
#define PS_STYLE_MASK	15
#define PS_ENDCAP_MASK	3840
#define PS_TYPE_MASK	983040
#define ALTERNATE	1
#define WINDING	2
#define POLYFILL_LAST	2
#define LAYOUT_RTL	1
#define LAYOUT_BTT	2
#define LAYOUT_VBH	4
#define LAYOUT_BITMAPORIENTATIONPRESERVED	8
#define LAYOUT_ORIENTATIONMASK	(LAYOUT_RTL|LAYOUT_BTT|LAYOUT_VBH)
#define CREATE_NEW_CONSOLE	16
#define CREATE_NEW_PROCESS_GROUP	512
#define CREATE_SEPARATE_WOW_VDM	2048
#define CREATE_SUSPENDED	4
#define CREATE_UNICODE_ENVIRONMENT	1024
#define CREATE_BREAKAWAY_FROM_JOB 0x01000000
#define CREATE_PRESERVE_CODE_AUTHZ_LEVEL 0x02000000
#define CREATE_DEFAULT_ERROR_MODE 0x04000000
#define CREATE_NO_WINDOW 0x08000000
#define CREATE_SHARED_WOW_VDM 0x00001000
#define CREATE_FORCEDOS 0x00002000
#define PROFILE_USER 0x10000000
#define PROFILE_KERNEL 0x20000000
#define PROFILE_SERVER 0x40000000
#define DEBUG_PROCESS	1
#define DEBUG_ONLY_THIS_PROCESS	2
#define DETACHED_PROCESS	8
#define HIGH_PRIORITY_CLASS	128
#define IDLE_PRIORITY_CLASS	64
#define NORMAL_PRIORITY_CLASS	32
#define REALTIME_PRIORITY_CLASS	256
#define BELOW_NORMAL_PRIORITY_CLASS 0x04000
#define ABOVE_NORMAL_PRIORITY_CLASS 0x08000
#define DELETE	0x10000
#define READ_CONTROL	0x20000
#define GENERIC_EXECUTE	0x20000000
#define SERVICE_WIN32_OWN_PROCESS	16
#define SERVICE_WIN32_SHARE_PROCESS	32
#define SERVICE_KERNEL_DRIVER	1
#define SERVICE_FILE_SYSTEM_DRIVER	2
#define SERVICE_INTERACTIVE_PROCESS	256
#define SERVICE_BOOT_START	0
#define SERVICE_SYSTEM_START	1
#define SERVICE_AUTO_START	2
#define SERVICE_DEMAND_START	3
#define SERVICE_DISABLED	4
#define SERVICE_ERROR_IGNORE	0
#define SERVICE_ERROR_NORMAL	1
#define SERVICE_ERROR_SEVERE	2
#define SERVICE_ERROR_CRITICAL	3
#define TAPE_FIXED_PARTITIONS	0
#define TAPE_INITIATOR_PARTITIONS	2
#define TAPE_SELECT_PARTITIONS	1
#define TAPE_FILEMARKS	1
#define TAPE_LONG_FILEMARKS	3
#define TAPE_SETMARKS	0
#define TAPE_SHORT_FILEMARKS	2
#define CW_USEDEFAULT	0x80000000
#define WS_BORDER	0x800000
#define WS_CAPTION	0xc00000
#define WS_CHILD	0x40000000
#define WS_CHILDWINDOW	0x40000000
#define WS_CLIPCHILDREN	0x2000000
#define WS_CLIPSIBLINGS	0x4000000
#define WS_DISABLED	0x8000000
#define WS_DLGFRAME	0x400000
#define WS_GROUP	0x20000
#define WS_HSCROLL	0x100000
#define WS_ICONIC	0x20000000
#define WS_MAXIMIZE	0x1000000
#define WS_MAXIMIZEBOX	0x10000
#define WS_MINIMIZE	0x20000000
#define WS_MINIMIZEBOX	0x20000
#define WS_OVERLAPPED	0
#define WS_OVERLAPPEDWINDOW	0xcf0000
#define WS_POPUP	0x80000000
#define WS_POPUPWINDOW	0x80880000
#define WS_SIZEBOX	0x40000
#define WS_SYSMENU	0x80000
#define WS_TABSTOP	0x10000
#define WS_THICKFRAME	0x40000
#define WS_TILED	0
#define WS_TILEDWINDOW	0xcf0000
#define WS_VISIBLE	0x10000000
#define WS_VSCROLL	0x200000
#define MDIS_ALLCHILDSTYLES	1
#define BS_3STATE	5
#define BS_AUTO3STATE	6
#define BS_AUTOCHECKBOX	3
#define BS_AUTORADIOBUTTON	9
#define BS_BITMAP	128
#define BS_BOTTOM	0x800
#define BS_CENTER	0x300
#define BS_CHECKBOX	2
#define BS_DEFPUSHBUTTON	1
#define BS_GROUPBOX	7
#define BS_ICON	64
#define BS_LEFT	256
#define BS_LEFTTEXT	32
#define BS_MULTILINE	0x2000
#define BS_NOTIFY	0x4000
#define BS_OWNERDRAW	0xb
#define BS_PUSHBUTTON	0
#define BS_PUSHBOX	10
#define BS_PUSHLIKE	4096
#define BS_RADIOBUTTON	4
#define BS_RIGHT	512
#define BS_RIGHTBUTTON	32
#define BS_TEXT	0
#define BS_TOP	0x400
#define BS_USERBUTTON	8
#define BS_VCENTER	0xc00
#define BS_FLAT	0x8000
#define BUTTON_IMAGELIST_ALIGN_LEFT	0
#define BUTTON_IMAGELIST_ALIGN_RIGHT	1
#define BUTTON_IMAGELIST_ALIGN_TOP	2
#define BUTTON_IMAGELIST_ALIGN_BOTTOM	3
#define BUTTON_IMAGELIST_ALIGN_CENTER	4
#define CBS_AUTOHSCROLL	64
#define CBS_DISABLENOSCROLL	0x800
#define CBS_DROPDOWN	2
#define CBS_DROPDOWNLIST	3
#define CBS_HASSTRINGS	512
#define CBS_LOWERCASE	0x4000
#define CBS_NOINTEGRALHEIGHT	0x400
#define CBS_OEMCONVERT	128
#define CBS_OWNERDRAWFIXED	16
#define CBS_OWNERDRAWVARIABLE	32
#define CBS_SIMPLE	1
#define CBS_SORT	256
#define CBS_UPPERCASE	0x2000
#define ES_AUTOHSCROLL	128
#define ES_AUTOVSCROLL	64
#define ES_CENTER	1
#define ES_LEFT	0
#define ES_LOWERCASE	16
#define ES_MULTILINE	4
#define ES_NOHIDESEL	256
#define ES_NUMBER	0x2000
#define ES_OEMCONVERT	0x400
#define ES_PASSWORD	32
#define ES_READONLY	0x800
#define ES_RIGHT	2
#define ES_UPPERCASE	8
#define ES_WANTRETURN	4096
#define LBS_DISABLENOSCROLL	4096
#define LBS_EXTENDEDSEL	0x800
#define LBS_HASSTRINGS	64
#define LBS_MULTICOLUMN	512
#define LBS_MULTIPLESEL	8
#define LBS_NODATA	0x2000
#define LBS_NOINTEGRALHEIGHT	256
#define LBS_NOREDRAW	4
#define LBS_NOSEL	0x4000
#define LBS_NOTIFY	1
#define LBS_OWNERDRAWFIXED	16
#define LBS_OWNERDRAWVARIABLE	32
#define LBS_SORT	2
#define LBS_STANDARD	0xa00003
#define LBS_USETABSTOPS	128
#define LBS_WANTKEYBOARDINPUT	0x400
#define SBS_BOTTOMALIGN	4
#define SBS_HORZ	0
#define SBS_LEFTALIGN	2
#define SBS_RIGHTALIGN	4
#define SBS_SIZEBOX	8
#define SBS_SIZEBOXBOTTOMRIGHTALIGN	4
#define SBS_SIZEBOXTOPLEFTALIGN	2
#define SBS_SIZEGRIP	16
#define SBS_TOPALIGN	2
#define SBS_VERT	1
#define SS_BITMAP	0xe
#define SS_BLACKFRAME	7
#define SS_BLACKRECT	4
#define SS_CENTER	1
#define SS_CENTERIMAGE	512
#define SS_ENHMETAFILE	0xf
#define SS_ETCHEDFRAME	0x12
#define SS_ETCHEDHORZ	16
#define SS_ETCHEDVERT	0x11
#define SS_GRAYFRAME	8
#define SS_GRAYRECT	5
#define SS_ICON	3
#define SS_LEFT	0
#define SS_LEFTNOWORDWRAP	0xc
#define SS_TYPEMASK	0x1f
#define SS_ENDELLIPSIS	0x4000
#define SS_PATHELLIPSIS	0x8000
#define SS_WORDELLIPSIS	0xC000
#define SS_ELLIPSISMASK	0xC000
#define SS_REALSIZECONTROL	0x40
#define SS_NOPREFIX	128
#define SS_NOTIFY	256
#define SS_OWNERDRAW	0xd
#define SS_REALSIZEIMAGE	0x800
#define SS_RIGHT	2
#define SS_RIGHTJUST	0x400
#define SS_SIMPLE	11
#define SS_SUNKEN	4096
#define SS_WHITEFRAME	9
#define SS_WHITERECT	6
#define SS_USERITEM 10
#define DS_3DLOOK	4
#define DS_ABSALIGN	1
#define DS_CENTER	0x800
#define DS_CENTERMOUSE	4096
#define DS_CONTEXTHELP	0x2000
#define DS_CONTROL	0x400
#define DS_FIXEDSYS	8
#define DS_LOCALEDIT	32
#define DS_MODALFRAME	128
#define DS_NOFAILCREATE	16
#define DS_NOIDLEMSG	256
#define DS_SETFONT	64
#define DS_SETFOREGROUND	512
#define DS_SYSMODAL	2
#define DS_FIXEDSYS	8
#define DS_SHELLFONT	(DS_SETFONT|DS_FIXEDSYS)
#define WS_EX_ACCEPTFILES	16
#define WS_EX_APPWINDOW	0x40000
#define WS_EX_CLIENTEDGE	512
#define WS_EX_CONTEXTHELP	0x400
#define WS_EX_CONTROLPARENT	0x10000
#define WS_EX_DLGMODALFRAME	1
#define WS_EX_LEFT	0
#define WS_EX_LEFTSCROLLBAR	0x4000
#define WS_EX_LTRREADING	0
#define WS_EX_MDICHILD	64
#define WS_EX_NOPARENTNOTIFY	4
#define WS_EX_OVERLAPPEDWINDOW	0x300
#define WS_EX_PALETTEWINDOW	0x188
#define WS_EX_RIGHT	0x1000
#define WS_EX_RIGHTSCROLLBAR	0
#define WS_EX_RTLREADING	0x2000
#define WS_EX_STATICEDGE	0x20000
#define WS_EX_TOOLWINDOW	128
#define WS_EX_TOPMOST	8
#define WS_EX_TRANSPARENT	32
#define WS_EX_WINDOWEDGE	256
#define WS_EX_LAYERED	0x080000
#define WINSTA_ACCESSCLIPBOARD	4
#define WINSTA_ACCESSGLOBALATOMS	32
#define WINSTA_CREATEDESKTOP	8
#define WINSTA_ENUMDESKTOPS	1
#define WINSTA_ENUMERATE	256
#define WINSTA_EXITWINDOWS	64
#define WINSTA_READATTRIBUTES	2
#define WINSTA_READSCREEN	512
#define WINSTA_WRITEATTRIBUTES	16
#define WH_CALLWNDPROC	4
#define WH_CALLWNDPROCRET	12
#define WH_KEYBOARD_LL	13
#define WH_MOUSE_LL	14
#define WH_MAX 14
#define WH_MINHOOK WH_MIN
#define WH_MAXHOOK WH_MAX
#define HC_ACTION 0
#define HC_GETNEXT 1
#define HC_ACTION	0
#define HC_GETNEXT	1
#define HC_SKIP	2
#define HC_NOREMOVE	3
#define HC_NOREM	HC_NOREMOVE
#define HC_SYSMODALON	4
#define HC_SYSMODALOFF	5
#define HCBT_MOVESIZE	0
#define HCBT_MINMAX	1
#define HCBT_QS	2
#define HCBT_CREATEWND	3
#define HCBT_DESTROYWND	4
#define HCBT_ACTIVATE	5
#define HCBT_CLICKSKIPPED	6
#define HCBT_KEYSKIPPED	7
#define HCBT_SYSCOMMAND	8
#define HCBT_SETFOCUS	9
#define HC_SYSMODALON	4
#define WH_CBT	5
#define WH_DEBUG	9
#define WH_GETMESSAGE	3
#define WH_JOURNALPLAYBACK	1
#define WH_JOURNALRECORD	0
#define WH_KEYBOARD	2
#define WH_MOUSE	7
#define WH_MSGFILTER	(-1)
#define WH_SHELL	10
#define WH_SYSMSGFILTER	6
#define WH_MIN (-1)
#define WH_FOREGROUNDIDLE	11
#define DDD_RAW_TARGET_PATH	1
#define DDD_REMOVE_DEFINITION	2
#define DDD_EXACT_MATCH_ON_REMOVE	4
#define DDD_NO_BROADCAST_SYSTEM 8
#define DDD_LUID_BROADCAST_DRIVE 16
#define DC_BINNAMES	12
#define DC_BINS	6
#define DC_COPIES	18
#define DC_DRIVER	11
#define DC_DATATYPE_PRODUCED	21
#define DC_DUPLEX	7
#define DC_EMF_COMPLIANT	20
#define DC_ENUMRESOLUTIONS	13
#define DC_EXTRA	9
#define DC_FIELDS	1
#define DC_FILEDEPENDENCIES	14
#define DC_MAXEXTENT	5
#define DC_MINEXTENT	4
#define DC_ORIENTATION	17
#define DC_PAPERNAMES	16
#define DC_PAPERS	2
#define DC_PAPERSIZE	3
#define DC_SIZE	8
#define DC_TRUETYPE	15
#define DCTT_BITMAP	1
#define DCTT_DOWNLOAD	2
#define DCTT_SUBDEV	4
#define DC_VERSION	10
#define DC_BINADJUST	19
#define DC_EMF_COMPLIANT	20
#define DC_DATATYPE_PRODUCED	21
#define DDL_ARCHIVE	32
#define DDL_DIRECTORY	16
#define DDL_DRIVES	16384
#define DDL_EXCLUSIVE	32768
#define DDL_HIDDEN	2
#define DDL_READONLY	1
#define DDL_READWRITE	0
#define DDL_SYSTEM	4
#define DDL_POSTMSGS	8192
#define DLL_PROCESS_ATTACH	1
#define DLL_THREAD_ATTACH	2
#define DLL_PROCESS_DETACH	0
#define DLL_THREAD_DETACH	3
#define DM_IN_BUFFER	8
#define DM_MODIFY	8
#define DM_IN_PROMPT	4
#define DM_PROMPT	4
#define DM_OUT_BUFFER	2
#define DM_COPY	2
#define DM_UPDATE	1
#define IDANI_OPEN	1
#define IDANI_CLOSE	2
#define DC_ACTIVE	1
#define DC_SMALLCAP	2
#define DC_ICON	4
#define DC_TEXT	8
#define DC_INBUTTON	16
#define DC_GRADIENT	32
#define BDR_RAISEDINNER	4
#define BDR_SUNKENINNER	8
#define BDR_RAISEDOUTER	1
#define BDR_SUNKENOUTER	2
#define BDR_OUTER	(BDR_RAISEDOUTER|BDR_SUNKENOUTER)
#define BDR_INNER	(BDR_RAISEDINNER|BDR_SUNKENINNER)
#define BDR_RAISED	(BDR_RAISEDOUTER|BDR_RAISEDINNER)
#define BDR_SUNKEN	(BDR_SUNKENOUTER|BDR_SUNKENINNER)
#define EDGE_BUMP	9
#define EDGE_ETCHED	6
#define EDGE_RAISED	5
#define EDGE_SUNKEN	10
#define BF_ADJUST	8192
#define BF_BOTTOM	8
#define BF_BOTTOMLEFT	9
#define BF_BOTTOMRIGHT	12
#define BF_DIAGONAL	16
#define BF_DIAGONAL_ENDBOTTOMLEFT	25
#define BF_DIAGONAL_ENDBOTTOMRIGHT	28
#define BF_DIAGONAL_ENDTOPLEFT	19
#define BF_DIAGONAL_ENDTOPRIGHT	22
#define BF_FLAT	16384
#define BF_LEFT	1
#define BF_MIDDLE	2048
#define BF_MONO	32768
#define BF_RECT	15
#define BF_RIGHT	4
#define BF_SOFT	4096
#define BF_TOP	2
#define BF_TOPLEFT	3
#define BF_TOPRIGHT	6
#define DFC_BUTTON	4
#define DFC_CAPTION	1
#define DFC_MENU	2
#define DFC_SCROLL	3
#define DFCS_BUTTON3STATE	8
#define DFCS_BUTTONCHECK	0
#define DFCS_BUTTONPUSH	16
#define DFCS_BUTTONRADIO	4
#define DFCS_BUTTONRADIOIMAGE	1
#define DFCS_BUTTONRADIOMASK	2
#define DFCS_CAPTIONCLOSE	0
#define DFCS_CAPTIONHELP	4
#define DFCS_CAPTIONMAX	2
#define DFCS_CAPTIONMIN	1
#define DFCS_CAPTIONRESTORE	3
#define DFCS_MENUARROW	0
#define DFCS_MENUBULLET	2
#define DFCS_MENUCHECK	1
#define DFCS_SCROLLCOMBOBOX	5
#define DFCS_SCROLLDOWN	1
#define DFCS_SCROLLLEFT	2
#define DFCS_SCROLLRIGHT	3
#define DFCS_SCROLLSIZEGRIP	8
#define DFCS_SCROLLUP	0
#define DFCS_ADJUSTRECT	8192
#define DFCS_CHECKED	1024
#define DFCS_FLAT	16384
#define DFCS_INACTIVE	256
#define DFCS_MONO	32768
#define DFCS_PUSHED	512
#define DI_COMPAT	4
#define DI_DEFAULTSIZE	8
#define DI_IMAGE	2
#define DI_MASK	1
#define DI_NORMAL	3
#define DST_BITMAP	4
#define DST_COMPLEX	0
#define DST_ICON	3
#define DST_PREFIXTEXT	2
#define DST_TEXT	1
#define DSS_NORMAL	0
#define DSS_UNION	16
#define DSS_DISABLED	32
#define DSS_MONO	128
#define SBT_NOBORDERS	256
#define SBT_OWNERDRAW	4096
#define SBT_POPOUT	512
#define SBT_RTLREADING	1024
#define SBT_TOOLTIPS	0x800
#define SB_SIMPLEID	0x00ff
#define DT_BOTTOM	8
#define DT_CALCRECT	1024
#define DT_CENTER	1
#define DT_EDITCONTROL	8192
#define DT_END_ELLIPSIS	32768
#define DT_PATH_ELLIPSIS	16384
#define DT_EXPANDTABS	64
#define DT_EXTERNALLEADING	512
#define DT_LEFT	0
#define DT_MODIFYSTRING	65536
#define DT_NOCLIP	256
#define DT_NOPREFIX	2048
#define DT_RIGHT	2
#define DT_RTLREADING	131072
#define DT_SINGLELINE	32
#define DT_TABSTOP	128
#define DT_TOP	0
#define DT_VCENTER	4
#define DT_WORDBREAK	16
#define DT_INTERNAL	4096
#define DT_WORD_ELLIPSIS	0x40000
#define DT_NOFULLWIDTHCHARBREAK	0x80000
#define DT_HIDEPREFIX	0x100000
#define DT_PREFIXONLY	0x200000
#define DUPLICATE_CLOSE_SOURCE	1
#define DUPLICATE_SAME_ACCESS	2
#define FILE_MAP_ALL_ACCESS	0xf001f
#define FILE_MAP_READ	4
#define FILE_MAP_WRITE	2
#define FILE_MAP_COPY	1
#define MUTEX_ALL_ACCESS	0x1f0001
#define MUTEX_MODIFY_STATE	1
#define SYNCHRONIZE	0x100000
#define SEMAPHORE_ALL_ACCESS	0x1f0003
#define SEMAPHORE_MODIFY_STATE	2
#define S_NORMAL 0
#define S_LEGATO 1
#define S_STACCATO 2
#define S_PERIOD512 0
#define S_PERIOD1024 1
#define S_PERIOD2048 2
#define S_PERIODVOICE 3
#define S_SERDVNA (-1)
#define S_SEROFM (-2)
#define S_SERMACT (-3)
#define S_SERQFUL (-4)
#define S_SERBDNT (-5)
#define S_SERDLN (-6)
#define S_SERDCC (-7)
#define S_SERDTP (-8)
#define S_SERDV  (-9)
#define S_SERDMD (-10)
#define S_SERDSH (-11)
#define S_SERDPT (-12)
#define S_SERDFQ (-13)
#define S_SERDDR (-14)
#define S_SERDSR (-15)
#define S_SERDST (-16)
#define S_WHITE512 4
#define S_WHITE1024 5
#define S_WHITE2048 6
#define S_WHITEVOICE 7
#define EVENT_ALL_ACCESS	0x1f0003
#define EVENT_MODIFY_STATE	2
#define KEY_ALL_ACCESS	0xf003f
#define KEY_CREATE_LINK	32
#define KEY_CREATE_SUB_KEY	4
#define KEY_ENUMERATE_SUB_KEYS	8
#define KEY_EXECUTE	0x20019
#define KEY_NOTIFY	16
#define KEY_QUERY_VALUE	1
#define KEY_READ	0x20019
#define KEY_SET_VALUE	2
#define KEY_WRITE	0x20006
#define PROCESS_ALL_ACCESS	0x1f0fff
#define PROCESS_CREATE_PROCESS	128
#define PROCESS_CREATE_THREAD	2
#define PROCESS_DUP_HANDLE	64
#define PROCESS_QUERY_INFORMATION	1024
#define PROCESS_SET_INFORMATION	512
#define PROCESS_TERMINATE	1
#define PROCESS_VM_OPERATION	8
#define PROCESS_VM_READ	16
#define PROCESS_VM_WRITE	32
#define THREAD_ALL_ACCESS	0x1f03ff
#define THREAD_DIRECT_IMPERSONATION	512
#define THREAD_GET_CONTEXT	8
#define THREAD_IMPERSONATE	256
#define THREAD_QUERY_INFORMATION	64
#define THREAD_SET_CONTEXT	16
#define THREAD_SET_INFORMATION	32
#define THREAD_SET_THREAD_TOKEN	128
#define THREAD_SUSPEND_RESUME	2
#define THREAD_TERMINATE	1
#define WB_ISDELIMITER	2
#define WB_LEFT	0
#define WB_RIGHT	1
#define SB_BOTH	3
#define SB_CTL	2
#define SB_HORZ	0
#define SB_VERT	1
#define ESB_DISABLE_BOTH	3
#define ESB_DISABLE_DOWN	2
#define ESB_DISABLE_LEFT	1
#define ESB_DISABLE_LTUP	1
#define ESB_DISABLE_RIGHT	2
#define ESB_DISABLE_RTDN	2
#define ESB_DISABLE_UP	1
#define ESB_ENABLE_BOTH	0
#define SB_LINEUP	0
#define SB_LINEDOWN	1
#define SB_LINELEFT	0
#define SB_LINERIGHT	1
#define SB_PAGEUP	2
#define SB_PAGEDOWN	3
#define SB_PAGELEFT	2
#define SB_PAGERIGHT	3
#define SB_THUMBPOSITION	4
#define SB_THUMBTRACK	5
#define SB_ENDSCROLL	8
#define SB_LEFT	6
#define SB_RIGHT	7
#define SB_BOTTOM	7
#define SB_TOP	6
#define ENUM_ALL_CALENDARS	0xffffffff
#define DATE_SHORTDATE	1
#define DATE_LONGDATE	2
#define SERVICE_ACTIVE	1
#define SERVICE_INACTIVE	2
#define DEVICE_FONTTYPE	2
#define RASTER_FONTTYPE	1
#define TRUETYPE_FONTTYPE	4
#define OBJ_BRUSH	2
#define OBJ_PEN	1
#define OBJ_PAL	5
#define OBJ_FONT	6
#define OBJ_BITMAP	7
#define OBJ_EXTPEN	11
#define OBJ_REGION	8
#define OBJ_DC	3
#define OBJ_MEMDC	10
#define OBJ_METAFILE	9
#define OBJ_METADC	4
#define OBJ_ENHMETAFILE	13
#define OBJ_COLORSPACE	14
#define OBJ_ENHMETADC	12
#define IPPROTO_TCP	6
#define IPPROTO_UDP	17
#define RT_ACCELERATOR	MAKEINTRESOURCE(9)
#define RT_BITMAP	MAKEINTRESOURCE(2)
#define RT_DIALOG	MAKEINTRESOURCE(5)
#define RT_FONT	MAKEINTRESOURCE(8)
#define RT_FONTDIR	MAKEINTRESOURCE(7)
#define RT_MENU	MAKEINTRESOURCE(4)
#define RT_RCDATA	MAKEINTRESOURCE(0xa)
#define RT_STRING	MAKEINTRESOURCE(0x6)
#define RT_MESSAGETABLE	MAKEINTRESOURCE(0xb)
#define RT_CURSOR	MAKEINTRESOURCE(1)
#define RT_GROUP_CURSOR	MAKEINTRESOURCE(0xc)
#define RT_ICON	MAKEINTRESOURCE(3)
#define RT_GROUP_ICON	MAKEINTRESOURCE(0xe)
#define RT_VERSION	MAKEINTRESOURCE(16)
#define RT_VXD		MAKEINTRESOURCE(20)
#define RT_ANICURSOR	MAKEINTRESOURCE(21)
#define RT_ANIICON	MAKEINTRESOURCE(22)
#define RT_HTML		MAKEINTRESOURCE(23)
#define RT_DLGINCLUDE MAKEINTRESOURCE(0x11)
#define RT_PLUGPLAY	MAKEINTRESOURCE(19)
#define RT_HTML	MAKEINTRESOURCE(23)
#define SERVICE_WIN32	48
#define SERVICE_DRIVER	11
#define CP_INSTALLED	1
#define CP_SUPPORTED	2
#define LCID_INSTALLED	1
#define LCID_SUPPORTED	2
#define TAPE_ERASE_LONG	1
#define TAPE_ERASE_SHORT	0
#define PR_JOBSTATUS	0
#define SP_NOTREPORTED	0x4000
#define SP_ERROR	(-1)
#define SP_OUTOFDISK	(-4)
#define SP_OUTOFMEMORY	(-5)
#define SP_USERABORT	(-3)
#define SP_APPABORT	(-2)
#define PHYSICALWIDTH	110
#define PHYSICALHEIGHT	111
#define PHYSICALOFFSETX	112
#define PHYSICALOFFSETY	113
#define SCALINGFACTORX	114
#define SCALINGFACTORY	115
#define QUERYESCSUPPORT	8
#define ABORTDOC	2
#define ENDDOC	11
#define GETPHYSPAGESIZE	12
#define GETPRINTINGOFFSET	13
#define GETSCALINGFACTOR	14
#define NEWFRAME	1
#define NEXTBAND	3
#define PASSTHROUGH	19
#define SETABORTPROC	9
#define STARTDOC	10
#define SETCOLORTABLE	4
#define GETCOLORTABLE	5
#define FLUSHOUTPUT	6
#define DRAFTMODE	7
#define MFCOMMENT	15
#define GETPENWIDTH	16
#define SETCOPYCOUNT	17
#define SELECTPAPERSOURCE	18
#define DEVICEDATA	19
#define GETTECHNOLGY	20
#define GETTECHNOLOGY	20
#define SETLINECAP	21
#define SETLINEJOIN	22
#define SETMITERLIMIT	23
#define BANDINFO	24
#define DRAWPATTERNRECT	25
#define GETVECTORPENSIZE	26
#define GETVECTORBRUSHSIZE	27
#define ENABLEDUPLEX	28
#define GETSETPAPERBINS	29
#define GETSETPRINTORIENT	30
#define ENUMPAPERBINS	31
#define SETDIBSCALING	32
#define EPSPRINTING	33
#define ENUMPAPERMETRICS	34
#define GETSETPAPERMETRICS	35
#define POSTSCRIPT_DATA	37
#define POSTSCRIPT_IGNORE	38
#define MOUSETRAILS	39
#define GETDEVICEUNITS	42
#define GETEXTENDEDTEXTMETRICS	256
#define GETEXTENTTABLE	257
#define GETPAIRKERNTABLE	258
#define GETTRACKKERNTABLE	259
#define EXTTEXTOUT	512
#define GETFACENAME	513
#define DOWNLOADFACE	514
#define ENABLERELATIVEWIDTHS	768
#define ENABLEPAIRKERNING	769
#define SETKERNTRACK	770
#define SETALLJUSTVALUES	771
#define SETCHARSET	772
#define STRETCHBLT	2048
#define METAFILE_DRIVER	2049
#define GETSETSCREENPARAMS	3072
#define QUERYDIBSUPPORT	3073
#define BEGIN_PATH	4096
#define CLIP_TO_PATH	4097
#define END_PATH	4098
#define EXT_DEVICE_CAPS	4099
#define RESTORE_CTM	4100
#define SAVE_CTM	4101
#define SET_ARC_DIRECTION	4102
#define SET_BACKGROUND_COLOR	4103
#define SET_POLY_MODE	4104
#define SET_SCREEN_ANGLE	4105
#define SET_SPREAD	4106
#define TRANSFORM_CTM	4107
#define SET_CLIP_BOX	4108
#define SET_BOUNDS	4109
#define SET_MIRROR_MODE	4110
#define OPENCHANNEL	4110
#define DOWNLOADHEADER	4111
#define CLOSECHANNEL	4112
#define POSTSCRIPT_PASSTHROUGH	4115
#define ENCAPSULATED_POSTSCRIPT	4116
#define POSTSCRIPT_IDENTIFY	4117
#define POSTSCRIPT_INJECTION	4118
#define CHECKJPEGFORMAT	4119
#define CHECKPNGFORMAT	4120
#define GET_PS_FEATURESETTING	4121
#define SPCLPASSTHROUGH2	4568
#define PSIDENT_GDICENTRIC	0
#define PSIDENT_PSCENTRIC	1
#define PSINJECT_BEGINSTREAM	1
#define PSINJECT_PSADOBE	2
#define PSINJECT_PAGESATEND	3
#define PSINJECT_PAGES	4
#define PSINJECT_DOCNEEDEDRES	5
#define PSINJECT_DOCSUPPLIEDRES	6
#define PSINJECT_PAGEORDER	7
#define PSINJECT_ORIENTATION	8
#define PSINJECT_BOUNDINGBOX	9
#define PSINJECT_DOCUMENTPROCESSCOLORS	10
#define PSINJECT_COMMENTS	11
#define PSINJECT_BEGINDEFAULTS	12
#define PSINJECT_ENDDEFAULTS	13
#define PSINJECT_BEGINPROLOG	14
#define PSINJECT_ENDPROLOG	15
#define PSINJECT_BEGINSETUP	16
#define PSINJECT_ENDSETUP	17
#define PSINJECT_TRAILER	18
#define PSINJECT_EOF	19
#define PSINJECT_ENDSTREAM	20
#define PSINJECT_DOCUMENTPROCESSCOLORSATEND 21
#define PSINJECT_PAGENUMBER	100
#define PSINJECT_BEGINPAGESETUP	101
#define PSINJECT_ENDPAGESETUP	102
#define PSINJECT_PAGETRAILER	103
#define PSINJECT_PLATECOLOR	104
#define PSINJECT_SHOWPAGE	105
#define PSINJECT_PAGEBBOX	106
#define PSINJECT_ENDPAGECOMMENTS 107
#define PSINJECT_VMSAVE	200
#define PSINJECT_VMRESTORE	201
#define FEATURESETTING_NUP	0
#define FEATURESETTING_OUTPUT	1
#define FEATURESETTING_PSLEVEL	2
#define FEATURESETTING_CUSTPAPER 3
#define FEATURESETTING_MIRROR	4
#define FEATURESETTING_NEGATIVE	5
#define FEATURESETTING_PROTOCOL	6
#define PSPROTOCOL_ASCII	0
#define PSPROTOCOL_BCP	1
#define PSPROTOCOL_TBCP	2
#define PSPROTOCOL_BINARY	3
#define CLRDTR	6
#define CLRRTS	4
#define SETDTR	5
#define SETRTS	3
#define SETXOFF	1
#define SETXON	2
#define RESETDEV 7
#define SETBREAK	8
#define CLRBREAK	9
#define EWX_FORCE	4
#define EWX_LOGOFF	0
#define EWX_POWEROFF	8
#define EWX_REBOOT	2
#define EWX_SHUTDOWN	1
#define FLOODFILLBORDER	0
#define FLOODFILLSURFACE	1
#define ETO_CLIPPED	4
#define ETO_GLYPH_INDEX	16
#define ETO_OPAQUE	2
#define ETO_RTLREADING	128
#define ETO_PDY	0x2000
#define ETO_NUMERICSLOCAL	0x0400
#define ETO_NUMERICSLATIN	0x0800
#define ETO_IGNORELANGUAGE	0x1000
#define ASPECT_FILTERING	1
#define FOREGROUND_BLUE	1
#define FOREGROUND_GREEN	2
#define FOREGROUND_RED	4
#define FOREGROUND_INTENSITY	8
#define BACKGROUND_BLUE	16
#define BACKGROUND_GREEN	32
#define BACKGROUND_RED	64
#define BACKGROUND_INTENSITY	128
#define FILE_NOTIFY_CHANGE_FILE_NAME	1
#define FILE_NOTIFY_CHANGE_DIR_NAME	2
#define FILE_NOTIFY_CHANGE_ATTRIBUTES	4
#define FILE_NOTIFY_CHANGE_SIZE	8
#define FILE_NOTIFY_CHANGE_LAST_WRITE	16
#define FILE_NOTIFY_CHANGE_LAST_ACCESS 0x20
#define FILE_NOTIFY_CHANGE_CREATION 0x40
#define FILE_NOTIFY_CHANGE_SECURITY 256
#define FILE_ACTION_ADDED 1
#define FILE_ACTION_REMOVED 2
#define FILE_ACTION_MODIFIED	3
#define FILE_ACTION_RENAMED_OLD_NAME	4
#define FILE_ACTION_RENAMED_NEW_NAME	5
#define FILE_CASE_SENSITIVE_SEARCH	1
#define FILE_CASE_PRESERVED_NAMES	2
#define FILE_UNICODE_ON_DISK	4
#define FILE_PERSISTENT_ACLS	8
#define FILE_FILE_COMPRESSION	16
#define FILE_VOLUME_QUOTAS	32
#define FILE_SUPPORTS_SPARSE_FILES	0x40
#define FILE_SUPPORTS_REPARSE_POINTS	0x80
#define FILE_SUPPORTS_REMOTE_STORAGE	0x100
#define FILE_VOLUME_IS_COMPRESSED	0x08000
#define FILE_SUPPORTS_OBJECT_IDS	0x10000
#define FILE_SUPPORTS_ENCRYPTION	0x20000
#define MAP_FOLDCZONE	16
#define MAP_FOLDDIGITS	128
#define MAP_PRECOMPOSED	32
#define MAP_COMPOSITE	64
#define HC_ACTION	0
#define FORMAT_MESSAGE_ALLOCATE_BUFFER	256
#define FORMAT_MESSAGE_IGNORE_INSERTS	512
#define FORMAT_MESSAGE_FROM_STRING	1024
#define FORMAT_MESSAGE_FROM_HMODULE	2048
#define FORMAT_MESSAGE_FROM_SYSTEM	4096
#define FORMAT_MESSAGE_ARGUMENT_ARRAY	8192
#define FORMAT_MESSAGE_MAX_WIDTH_MASK	255
#define GDICOMMENT_WINDOWS_METAFILE	(-2147483647)
#define GDICOMMENT_BEGINGROUP	2
#define GDICOMMENT_ENDGROUP	3
#define GDICOMMENT_MULTIFORMATS	1073741828
#define GDICOMMENT_IDENTIFIER	1128875079
#define CTRL_C_EVENT	0
#define CTRL_BREAK_EVENT	1
#define CTRL_CLOSE_EVENT	2
#define CTRL_LOGOFF_EVENT	5
#define CTRL_SHUTDOWN_EVENT	6
#define AD_COUNTERCLOCKWISE	1
#define AD_CLOCKWISE	2
#define SCS_32BIT_BINARY	0
#define SCS_DOS_BINARY	1
#define SCS_OS216_BINARY	5
#define SCS_PIF_BINARY	3
#define SCS_POSIX_BINARY	4
#define SCS_WOW_BINARY	2
#define SCS_OS216_BINARY 5
#define SCS_64BIT_BINARY 6
#define DCB_DISABLE	8
#define DCB_ENABLE	4
#define DCB_RESET	1
#define DCB_SET	3
#define DCB_ACCUMULATE	2
#define DCB_DIRTY	DCB_ACCUMULATE
#define GCP_DBCS	1
#define GCP_ERROR	0x8000
#define GCP_CLASSIN	0x80000
#define GCP_DIACRITIC	256
#define GCP_DISPLAYZWG	0x400000
#define GCP_GLYPHSHAPE	16
#define GCP_JUSTIFY	0x10000
#define GCP_JUSTIFYIN	0x200000
#define GCP_KASHIDA	1024
#define GCP_LIGATE	32
#define GCP_MAXEXTENT	0x100000
#define GCP_NEUTRALOVERRIDE	0x2000000
#define GCP_NUMERICOVERRIDE	0x1000000
#define GCP_NUMERICSLATIN	0x4000000
#define GCP_NUMERICSLOCAL	0x8000000
#define GCP_REORDER	2
#define GCP_SYMSWAPOFF	0x800000
#define GCP_USEKERNING	8
#define FLI_GLYPHS	0x40000
#define FLI_MASK	0x103b
#define GCW_ATOM	(-32)
#define GCL_CBCLSEXTRA	(-20)
#define GCL_CBWNDEXTRA	(-18)
#define GCL_HBRBACKGROUND	(-10)
#define GCL_HCURSOR	(-12)
#define GCL_HICON	(-14)
#define GCL_HICONSM	(-34)
#define GCL_HMODULE	(-16)
#define GCL_MENUNAME	(-8)
#define GCL_STYLE	(-26)
#define GCL_WNDPROC	(-24)
#define GCLP_MENUNAME	(-8)
#define GCLP_HBRBACKGROUND	(-10)
#define GCLP_HCURSOR	(-12)
#define GCLP_HICON	(-14)
#define GCLP_HMODULE	(-16)
#define GCLP_WNDPROC	(-24)
#define GCLP_HICONSM	(-34)
#define CF_BITMAP	2
#define CF_DIB	8
#define CF_PALETTE	9
#define CF_ENHMETAFILE	14
#define CF_METAFILEPICT	3
#define CF_OEMTEXT	7
#define CF_TEXT	1
#define CF_UNICODETEXT	13
#define CF_DIF	5
#define CF_DSPBITMAP	130
#define CF_DSPENHMETAFILE	142
#define CF_DSPMETAFILEPICT	131
#define CF_DSPTEXT	129
#define CF_GDIOBJFIRST	768
#define CF_GDIOBJLAST	1023
#define CF_HDROP	15
#define CF_LOCALE	16
#define CF_OWNERDISPLAY	128
#define CF_PENDATA	10
#define CF_PRIVATEFIRST	512
#define CF_PRIVATELAST	767
#define CF_RIFF	11
#define CF_SYLK	4
#define CF_WAVE	12
#define CF_TIFF	6
#define EV_BREAK	64
#define EV_CTS	8
#define EV_DSR	16
#define EV_ERR	128
#define EV_EVENT1	2048
#define EV_EVENT2	4096
#define EV_PERR	512
#define EV_RING	256
#define EV_RLSD	32
#define EV_RX80FULL	1024
#define EV_RXCHAR	1
#define EV_RXFLAG	2
#define EV_TXEMPTY	4
#define MS_CTS_ON	16
#define MS_DSR_ON	32
#define MS_RING_ON	64
#define MS_RLSD_ON	128
#define MAX_COMPUTERNAME_LENGTH	15
#define ENABLE_LINE_INPUT	2
#define ENABLE_ECHO_INPUT	4
#define ENABLE_PROCESSED_INPUT	1
#define ENABLE_WINDOW_INPUT	8
#define ENABLE_MOUSE_INPUT	16
#define ENABLE_PROCESSED_OUTPUT	1
#define ENABLE_WRAP_AT_EOL_OUTPUT	2
#define CP_ACP	0
#define CP_MACCP	2
#define CP_OEMCP	1
#define CP_THREAD_ACP 3
#define CP_SYMBOL 42
#define CP_UTF7 65000
#define CP_UTF8 65001
#define DATE_SHORTDATE	1
#define DATE_LONGDATE	2
#define DATE_USE_ALT_CALENDAR	4
#define DCX_WINDOW	1
#define DCX_CACHE	2
#define DCX_PARENTCLIP	32
#define DCX_CLIPSIBLINGS	16
#define DCX_CLIPCHILDREN	8
#define DCX_NORESETATTRS	4
#define DCX_LOCKWINDOWUPDATE	0x400
#define DCX_EXCLUDERGN	64
#define DCX_INTERSECTRGN	128
#define DCX_VALIDATE	0x200000
#define DRIVERVERSION	0
#define TECHNOLOGY	2
#define DT_PLOTTER	0
#define DT_RASDISPLAY	1
#define DT_RASPRINTER	2
#define DT_RASCAMERA	3
#define DT_CHARSTREAM	4
#define DT_METAFILE	5
#define DT_DISPFILE	6
#define HORZSIZE	4
#define VERTSIZE	6
#define HORZRES	8
#define VERTRES	10
#define LOGPIXELSX	88
#define LOGPIXELSY	90
#define BITSPIXEL	12
#define PLANES	14
#define NUMBRUSHES	16
#define NUMPENS	18
#define NUMFONTS	22
#define NUMCOLORS	24
#define	NUMMARKERS	20
#define ASPECTX	40
#define ASPECTY	42
#define ASPECTXY	44
#define PDEVICESIZE	26
#define CLIPCAPS	36
#define SIZEPALETTE	104
#define NUMRESERVED	106
#define COLORRES	108
#define VREFRESH	116
#define DESKTOPHORZRES	118
#define DESKTOPVERTRES	117
#define BLTALIGNMENT	119
#define RASTERCAPS	38
#define RC_BANDING	2
#define RC_BITBLT	1
#define RC_BITMAP64	8
#define RC_DI_BITMAP	128
#define RC_DIBTODEV	512
#define RC_FLOODFILL	4096
#define RC_GDI20_OUTPUT	16
#define RC_PALETTE	256
#define RC_SCALING	4
#define RC_STRETCHBLT	2048
#define RC_STRETCHDIB	8192
#define RC_DEVBITS	0x8000
#define RC_OP_DX_OUTPUT	0x4000
#define CURVECAPS	28
#define CC_NONE	0
#define CC_CIRCLES	1
#define CC_PIE	2
#define CC_CHORD	4
#define CC_ELLIPSES	8
#define CC_WIDE	16
#define CC_STYLED	32
#define CC_WIDESTYLED	64
#define CC_INTERIORS	128
#define CC_ROUNDRECT	256
#define LINECAPS	30
#define LC_NONE	0
#define LC_POLYLINE	2
#define LC_MARKER	4
#define LC_POLYMARKER	8
#define LC_WIDE	16
#define LC_STYLED	32
#define LC_WIDESTYLED	64
#define LC_INTERIORS	128
#define POLYGONALCAPS	32
#define RC_BANDING	2
#define RC_BIGFONT	1024
#define RC_BITBLT	1
#define RC_BITMAP64	8
#define RC_DEVBITS	0x8000
#define RC_DI_BITMAP	128
#define RC_GDI20_OUTPUT	16
#define RC_GDI20_STATE	32
#define RC_NONE	0
#define RC_OP_DX_OUTPUT	0x4000
#define RC_PALETTE	256
#define RC_SAVEBITMAP	64
#define RC_SCALING	4
#define PC_NONE	0
#define PC_POLYGON	1
#define PC_POLYPOLYGON	256
#define PC_PATHS	512
#define PC_RECTANGLE	2
#define PC_WINDPOLYGON	4
#define PC_SCANLINE	8
#define PC_TRAPEZOID	4
#define PC_WIDE	16
#define PC_STYLED	32
#define PC_WIDESTYLED	64
#define PC_INTERIORS	128
#define TEXTCAPS	34
#define TC_OP_CHARACTER	1
#define TC_OP_STROKE	2
#define TC_CP_STROKE	4
#define TC_CR_90	8
#define TC_CR_ANY	16
#define TC_SF_X_YINDEP	32
#define TC_SA_DOUBLE	64
#define TC_SA_INTEGER	128
#define TC_SA_CONTIN	256
#define TC_EA_DOUBLE	512
#define TC_IA_ABLE	1024
#define TC_UA_ABLE	2048
#define TC_SO_ABLE	4096
#define TC_RA_ABLE	8192
#define TC_VA_ABLE	16384
#define TC_RESERVED	32768
#define TC_SCROLLBLT	65536
#define PC_PATHS	512
#define CP_NONE	0
#define CP_RECTANGLE	1
#define CP_REGION	2
#define DRIVE_REMOVABLE	2
#define DRIVE_FIXED	3
#define DRIVE_REMOTE	4
#define DRIVE_CDROM	5
#define DRIVE_RAMDISK	6
#define DRIVE_UNKNOWN	0
#define DRIVE_NO_ROOT_DIR	1
#define EXCEPTION_ACCESS_VIOLATION	0xc0000005
#define EXCEPTION_BREAKPOINT	0x80000003
#define EXCEPTION_DATATYPE_MISALIGNMENT	0x80000002
#define EXCEPTION_SINGLE_STEP	0x80000004
#define EXCEPTION_ARRAY_BOUNDS_EXCEEDED	0xc000008c
#define EXCEPTION_FLT_DENORMAL_OPERAND	0xc000008d
#define EXCEPTION_FLT_DIVIDE_BY_ZERO	0xc000008e
#define EXCEPTION_FLT_INEXACT_RESULT	0xc000008f
#define EXCEPTION_FLT_INVALID_OPERATION	0xc0000090
#define EXCEPTION_FLT_OVERFLOW	0xc0000091
#define EXCEPTION_FLT_STACK_CHECK	0xc0000092
#define EXCEPTION_FLT_UNDERFLOW	0xc0000093
#define EXCEPTION_INT_DIVIDE_BY_ZERO	0xc0000094
#define EXCEPTION_INT_OVERFLOW	0xc0000095
#define EXCEPTION_PRIV_INSTRUCTION	0xc0000096
#define EXCEPTION_IN_PAGE_ERROR		0xC0000025
#define EXCEPTION_ILLEGAL_INSTRUCTION     STATUS_ILLEGAL_INSTRUCTION
#define EXCEPTION_INVALID_HANDLE        STATUS_INVALID_HANDLE
#define EXCEPTION_NONCONTINUABLE_EXCEPTION	0xc0000025
#define EXCEPTION_NONCONTINUABLE	1
#define EXCEPTION_STACK_OVERFLOW	0xc00000fd
#define EXCEPTION_INVALID_DISPOSITION	0xc0000026
#define EXCEPTION_POSSIBLE_DEADLOCK 0xC0000194L
#define CS_ENABLE 1
#define CS_DISABLE 2
#define CS_DELETE_TRANSFORM 3
#define LCS_SIGNATURE 'PSOC'
#define LCS_sRGB 'sRGB'
#define LCS_WINDOWS_COLOR_SPACE 'Win '
#define LCS_CALIBRATED_RGB	0
#define LCS_DEVICE_RGB	1
#define LCS_DEVICE_CMYK	2
#define LCS_GM_BUSINESS	1
#define LCS_GM_GRAPHICS	2
#define LCS_GM_IMAGES	4
#define ICM_ADDPROFILE	1
#define ICM_DELETEPROFILE	2
#define ICM_QUERYPROFILE	3
#define ICM_SETDEFAULTPROFILE	4
#define ICM_REGISTERICMATCHER	5
#define ICM_UNREGISTERICMATCHER 6
#define ICM_QUERYMATCH	7
#define CM_OUT_OF_GAMUT	255
#define CM_IN_GAMUT	0
#define FILE_TYPE_UNKNOWN	0
#define FILE_TYPE_DISK	1
#define FILE_TYPE_CHAR	2
#define FILE_TYPE_PIPE	3
#define FILE_TYPE_REMOTE 0x8000
#define GGO_BITMAP	1
#define GGO_NATIVE	2
#define GGO_METRICS	0
#define GGO_GRAY2_BITMAP	4
#define GGO_GRAY4_BITMAP	5
#define GGO_GRAY8_BITMAP	6
#define GDI_ERROR	0xffffffff
#define HGDI_ERROR (LongToHandle(0xFFFFFFFFL))
#define GM_COMPATIBLE	1
#define GM_ADVANCED	2

//#if(WINVER >= 0x0500)
#define WS_EX_NOINHERITLAYOUT  0x00100000L
#define WS_EX_LAYOUTRTL      0x00400000L
//#endif

//#if(_WIN32_WINNT >= 0x0501)
#define WS_EX_COMPOSITED     0x02000000L
//#endif
//#if(_WIN32_WINNT >= 0x0500)
#define WS_EX_NOACTIVATE     0x08000000L
//#endif
#define HANDLE_FLAG_INHERIT	1
#define HANDLE_FLAG_PROTECT_FROM_CLOSE	2
#define IE_BADID  (-1)
#define IE_OPEN   (-2)
#define IE_NOPEN  (-3)
#define IE_MEMORY (-4)
#define IE_DEFAULT (-5)
#define IE_HARDWARE (-10)
#define IE_BYTESIZE (-11)
#define IE_BAUDRATE (-12)
#define IDC_HAND	MAKEINTRESOURCE(32649)
#define IDC_ARROW	MAKEINTRESOURCE(32512)
#define IDC_IBEAM	MAKEINTRESOURCE(32513)
#define IDC_WAIT	MAKEINTRESOURCE(32514)
#define IDC_CROSS	MAKEINTRESOURCE(32515)
#define IDC_UPARROW	MAKEINTRESOURCE(32516)
#define IDC_SIZENWSE	MAKEINTRESOURCE(32642)
#define IDC_SIZENESW	MAKEINTRESOURCE(32643)
#define IDC_SIZEWE	MAKEINTRESOURCE(32644)
#define IDC_SIZENS	MAKEINTRESOURCE(32645)
#define IDC_SIZEALL	MAKEINTRESOURCE(32646)
#define IDC_ICON	MAKEINTRESOURCE(32641)
#define IDC_SIZE	MAKEINTRESOURCE(32640)
#define IDC_NO	MAKEINTRESOURCE(32648)
#define IDC_APPSTARTING	MAKEINTRESOURCE(32650)
#define IDC_HELP	MAKEINTRESOURCE(32651)
#define IDI_APPLICATION	MAKEINTRESOURCE(32512)
#define IDI_HAND	MAKEINTRESOURCE(32513)
#define IDI_QUESTION	MAKEINTRESOURCE(32514)
#define IDI_EXCLAMATION	MAKEINTRESOURCE(32515)
#define IDI_ASTERISK	MAKEINTRESOURCE(32516)
#define IDI_WINLOGO	MAKEINTRESOURCE(32517)
#define IDI_WARNING	IDI_EXCLAMATION
#define IDI_ERROR	IDI_HAND
#define IDI_INFORMATION IDI_ASTERISK
#define MM_ANISOTROPIC	8
#define MM_HIENGLISH	5
#define MM_HIMETRIC	3
#define MM_ISOTROPIC	7
#define MM_LOENGLISH	4
#define MM_LOMETRIC	2
#define MM_TEXT	1
#define MM_TWIPS	6
#define GMDI_GOINTOPOPUPS	2
#define GMDI_USEDISABLED	1
#define PM_NOREMOVE	0
#define PM_REMOVE	1
#define PM_NOYIELD	2
#define PIPE_NOWAIT	1
#define PIPE_READMODE_MESSAGE	2
#define PIPE_CLIENT_END	0
#define PIPE_SERVER_END	1
#define GW_HWNDNEXT	2
#define GW_HWNDPREV	3
#define GW_CHILD	5
#define GW_HWNDFIRST	0
#define GW_HWNDLAST	1
#define GW_OWNER	4
#define GetNextWindow(HWND,cmd) GetWindow(HWND,cmd)
#define PT_MOVETO	6
#define PT_LINETO	2
#define PT_BEZIERTO	4
#define PT_CLOSEFIGURE	1
#define SHUTDOWN_NORETRY	1
#define QS_ALLEVENTS	191
#define QS_ALLINPUT	255
#define QS_HOTKEY	128
#define QS_INPUT	7
#define QS_KEY	1
#define QS_MOUSE	6
#define QS_MOUSEBUTTON	4
#define QS_MOUSEMOVE	2
#define QS_PAINT	32
#define QS_POSTMESSAGE	8
#define QS_SENDMESSAGE	64
#define QS_TIMER	16
#define SIF_TRACKPOS	16
#define SIF_PAGE	2
#define SIF_POS	4
#define SIF_RANGE	1
#define SIF_DISABLENOSCROLL	8
#define SIF_ALL	(SIF_RANGE|SIF_PAGE|SIF_POS|SIF_TRACKPOS)
//#ifndef __stdio_h__
#define STD_INPUT_HANDLE	(DWORD)(0xfffffff6)
#define STD_OUTPUT_HANDLE	(DWORD)(0xfffffff5)
#define STD_ERROR_HANDLE	(DWORD)(0xfffffff4)
//#endif
#define INVALID_HANDLE_VALUE	(HANDLE)(0xffffffff)
#define INVALID_FILE_SIZE ((DWORD)0xFFFFFFFF)
#define INVALID_SET_FILE_POINTER ((DWORD)-1)
#define INVALID_FILE_ATTRIBUTES ((DWORD)-1)
#define BLACK_BRUSH	4
#define DKGRAY_BRUSH	3
#define GRAY_BRUSH	2
#define HOLLOW_BRUSH	5
#define LTGRAY_BRUSH	1
#define NULL_BRUSH	5
#define WHITE_BRUSH	0
#define BLACK_PEN	7
#define NULL_PEN	8
#define WHITE_PEN	6
#define ANSI_FIXED_FONT	11
#define ANSI_VAR_FONT	12
#define DEVICE_DEFAULT_FONT	14
#define DEFAULT_GUI_FONT	17
#define OEM_FIXED_FONT	10
#define SYSTEM_FONT	13
#define SYSTEM_FIXED_FONT	16

//#if(WINVER >= 0x0400)
#define DEFAULT_GUI_FONT	17
//#endif
#define DC_BRUSH        18
#define DC_PEN         19
//#if (_WIN32_WINNT >= _WIN32_WINNT_WIN2K)
#define STOCK_LAST       19
//#elif (WINVER >= 0x0400)
//#define STOCK_LAST       17
//#else
//#define STOCK_LAST       16
//#endif

#define DEFAULT_PALETTE	15
#define CT_CTYPE1	1
#define CT_CTYPE2	2
#define CT_CTYPE3	4
#define C1_UPPER	1
#define C1_LOWER	2
#define C1_DIGIT	4
#define C1_SPACE	8
#define C1_PUNCT	16
#define C1_CNTRL	32
#define C1_BLANK	64
#define C1_XDIGIT	128
#define C1_ALPHA	256
#define C2_LEFTTORIGHT	1
#define C2_RIGHTTOLEFT	2
#define C2_EUROPENUMBER	3
#define C2_EUROPESEPARATOR	4
#define C2_EUROPETERMINATOR	5
#define C2_ARABICNUMBER	6
#define C2_COMMONSEPARATOR	7
#define C2_BLOCKSEPARATOR	8
#define C2_SEGMENTSEPARATOR	9
#define C2_WHITESPACE	10
#define C2_OTHERNEUTRAL	11
#define C2_NOTAPPLICABLE	0
#define C3_NONSPACING	1
#define C3_DIACRITIC	2
#define C3_VOWELMARK	4
#define C3_SYMBOL	8
#define C3_KATAKANA	16
#define C3_HIRAGANA	32
#define C3_HALFWIDTH	64
#define C3_FULLWIDTH	128
#define C3_IDEOGRAPH	256
#define C3_KASHIDA	512
#define C3_ALPHA	32768
#define C3_NOTAPPLICABLE	0
#define COLOR_HOTLIGHT	26
#define COLOR_GRADIENTACTIVECAPTION 27
#define COLOR_GRADIENTINACTIVECAPTION 28
#define COLOR_MENUHILIGHT	29
#define COLOR_MENUBAR	30
#define COLOR_3DDKSHADOW	21
#define COLOR_3DFACE	15
#define COLOR_3DHILIGHT	20
#define COLOR_3DHIGHLIGHT	20
#define COLOR_3DLIGHT	22
#define COLOR_BTNHILIGHT	20
#define COLOR_3DSHADOW	16
#define COLOR_ACTIVEBORDER	10
#define COLOR_ACTIVECAPTION	2
#define COLOR_APPWORKSPACE	12
#define COLOR_BACKGROUND	1
#define COLOR_DESKTOP	1
#define COLOR_BTNFACE	15
#define COLOR_BTNHIGHLIGHT	20
#define COLOR_BTNSHADOW	16
#define COLOR_BTNTEXT	18
#define COLOR_CAPTIONTEXT	9
#define COLOR_GRAYTEXT	17
#define COLOR_HIGHLIGHT	13
#define COLOR_HIGHLIGHTTEXT	14
#define COLOR_INACTIVEBORDER	11
#define COLOR_INACTIVECAPTION	3
#define COLOR_INACTIVECAPTIONTEXT	19
#define COLOR_INFOBK	24
#define COLOR_INFOTEXT	23
#define COLOR_MENU	4
#define COLOR_MENUTEXT	7
#define COLOR_SCROLLBAR	0
#define COLOR_WINDOW	5
#define COLOR_WINDOWFRAME	6
#define COLOR_WINDOWTEXT	8
#define CTLCOLOR_MSGBOX 0
#define CTLCOLOR_EDIT 1
#define CTLCOLOR_LISTBOX 2
#define CTLCOLOR_BTN 3
#define CTLCOLOR_DLG 4
#define CTLCOLOR_SCROLLBAR 5
#define CTLCOLOR_STATIC 6
#define CTLCOLOR_MAX 7
#define	SM_CXSCREEN	0
#define	SM_CYSCREEN	1
#define	SM_CXVSCROLL	2
#define	SM_CYHSCROLL	3
#define	SM_CYCAPTION	4
#define	SM_CXBORDER	5
#define	SM_CYBORDER	6
#define	SM_CXDLGFRAME	7
#define	SM_CYDLGFRAME	8
#define	SM_CYVTHUMB	9
#define	SM_CXHTHUMB	10
#define	SM_CXICON	11
#define	SM_CYICON	12
#define	SM_CXCURSOR	13
#define	SM_CYCURSOR	14
#define	SM_CYMENU	15
#define	SM_CXFULLSCREEN	16
#define	SM_CYFULLSCREEN	17
#define	SM_CYKANJIWINDOW	18
#define	SM_MOUSEPRESENT	19
#define	SM_CYVSCROLL	20
#define	SM_CXHSCROLL	21
#define	SM_DEBUG	22
#define	SM_SWAPBUTTON	23
#define	SM_RESERVED1	24
#define	SM_RESERVED2	25
#define	SM_RESERVED3	26
#define	SM_RESERVED4	27
#define	SM_CXMIN	28
#define	SM_CYMIN	29
#define	SM_CXSIZE	30
#define	SM_CYSIZE	31
#define	SM_CXFRAME	32
#define	SM_CYFRAME	33
#define	SM_CXMINTRACK	34
#define	SM_CYMINTRACK	35
#define	SM_CXDOUBLECLK	36
#define	SM_CYDOUBLECLK	37
#define	SM_CXICONSPACING	38
#define	SM_CYICONSPACING	39
#define	SM_MENUDROPALIGNMENT	40
#define	SM_PENWINDOWS	41
#define	SM_DBCSENABLED	42
#define	SM_CMOUSEBUTTONS	43
#define	SM_CXFIXEDFRAME	SM_CXDLGFRAME
#define	SM_CYFIXEDFRAME	SM_CYDLGFRAME
#define	SM_CXSIZEFRAME	SM_CXFRAME
#define	SM_CYSIZEFRAME	SM_CYFRAME
#define	SM_SECURE	44
#define	SM_CXEDGE	45
#define	SM_CYEDGE	46
#define	SM_CXMINSPACING	47
#define	SM_CYMINSPACING	48
#define	SM_CXSMICON	49
#define	SM_CYSMICON	50
#define	SM_CYSMCAPTION	51
#define	SM_CXSMSIZE	52
#define	SM_CYSMSIZE	53
#define	SM_CXMENUSIZE	54
#define	SM_CYMENUSIZE	55
#define	SM_ARRANGE	56
#define	SM_CXMINIMIZED	57
#define	SM_CYMINIMIZED	58
#define	SM_CXMAXTRACK	59
#define	SM_CYMAXTRACK	60
#define	SM_CXMAXIMIZED	61
#define	SM_CYMAXIMIZED	62
#define	SM_NETWORK	63
#define	SM_CLEANBOOT	67
#define	SM_CXDRAG	68
#define	SM_CYDRAG	69
#define	SM_SHOWSOUNDS	70
#define	SM_CXMENUCHECK	71
#define	SM_CYMENUCHECK	72
#define	SM_SLOWMACHINE	73
#define	SM_MIDEASTENABLED	74
#define	SM_MOUSEWHEELPRESENT	75
#define	SM_XVIRTUALSCREEN	76
#define	SM_YVIRTUALSCREEN	77
#define	SM_CXVIRTUALSCREEN	78
#define	SM_CYVIRTUALSCREEN	79
#define	SM_CMONITORS	80
#define	SM_SAMEDISPLAYFORMAT	81
#define	SM_CMETRICS	76
#define ARW_BOTTOMLEFT	0
#define ARW_BOTTOMRIGHT	1
#define ARW_HIDE	8
#define ARW_TOPLEFT	2
#define ARW_TOPRIGHT	3
#define ARW_DOWN	4
#define ARW_LEFT	0
#define ARW_RIGHT	0
#define ARW_UP	4
#define SYSPAL_NOSTATIC	2
#define SYSPAL_STATIC	1
#define SYSPAL_ERROR	0
#define GET_TAPE_MEDIA_INFORMATION	0
#define GET_TAPE_DRIVE_INFORMATION	1
#define SET_TAPE_MEDIA_INFORMATION	0
#define SET_TAPE_DRIVE_INFORMATION	1
#define TAPE_ABSOLUTE_POSITION	0
#define TAPE_LOGICAL_POSITION	1
#define TA_BASELINE	24
#define TA_BOTTOM	8
#define TA_TOP	0
#define TA_CENTER	6
#define TA_LEFT	0
#define TA_RIGHT	2
#define TA_RTLREADING	256
#define TA_MASK	(TA_BASELINE+TA_CENTER+TA_UPDATECP+TA_RTLREADING)
#define TA_NOUPDATECP	0
#define TA_UPDATECP	1
#define VTA_BASELINE	24
#define VTA_CENTER	6
#define VTA_LEFT	TA_BOTTOM
#define VTA_RIGHT	TA_TOP
#define VTA_BOTTOM	TA_RIGHT
#define VTA_TOP	TA_LEFT
#define THREAD_PRIORITY_ABOVE_NORMAL	1
#define THREAD_PRIORITY_BELOW_NORMAL	(-1)
#define THREAD_PRIORITY_HIGHEST	2
#define THREAD_PRIORITY_IDLE	(-15)
#define THREAD_PRIORITY_LOWEST	(-2)
#define THREAD_PRIORITY_NORMAL	0
#define THREAD_PRIORITY_TIME_CRITICAL	15
#define THREAD_PRIORITY_ERROR_RETURN	2147483647
#define TLS_MINIMUM_AVAILABLE	64
#define TIME_NOMINUTESORSECONDS	1
#define TIME_NOSECONDS	2
#define TIME_NOTIMEMARKER	4
#define TIME_FORCE24HOURFORMAT	8
#define TIME_ZONE_ID_UNKNOWN	0
#define TIME_ZONE_ID_STANDARD	1
#define TIME_ZONE_ID_DAYLIGHT	2
#define UOI_FLAGS	1
#define UOI_NAME	2
#define UOI_TYPE	3
#define FS_CASE_IS_PRESERVED	2
#define FS_CASE_SENSITIVE	1
#define FS_UNICODE_STORED_ON_DISK	4
#define FS_PERSISTENT_ACLS	8
#define FS_FILE_COMPRESSION	16
#define FS_VOL_IS_COMPRESSED	32768
#define FS_FILE_ENCRYPTION FILE_SUPPORTS_ENCRYPTION
#define GWL_EXSTYLE	(-20)
#define GWL_STYLE	(-16)
#define GWL_WNDPROC	(-4)
#define GWL_HINSTANCE	(-6)
#define GWL_HWNDPARENT	(-8)
#define GWL_ID	(-12)
#define GWL_USERDATA	(-21)
#define GWLP_WNDPROC	(-4)
#define GWLP_HINSTANCE	(-6)
#define GWLP_HWNDPARENT	(-8)
#define GWLP_USERDATA	(-21)
#define GWLP_ID	(-12)
#define DWL_DLGPROC	4
#define DWL_MSGRESULT	0
#define DWL_USER	8
#define DWLP_MSGRESULT	0
#define DWLP_DLGPROC	DWLP_MSGRESULT+sizeof(LRESULT)
#define DWLP_USER	DWLP_DLGPROC+sizeof(DLGPROC)
#define GMEM_FIXED	0
#define GMEM_MOVEABLE	2
#define GMEM_MODIFY 128
#define GMEM_VALID_FLAGS 0x7F72
#define GPTR	64
#define GHND	66
#define GMEM_DDESHARE	8192
#define GMEM_DISCARDABLE	256
#define GMEM_LOWER	4096
#define GMEM_NOCOMPACT	16
#define GMEM_NODISCARD	32
#define GMEM_NOT_BANKED	4096
#define GMEM_NOTIFY	16384
#define GMEM_SHARE	8192
#define GMEM_ZEROINIT	64
#define GMEM_DISCARDED	16384
#define GMEM_INVALID_HANDLE	32768
#define GMEM_LOCKCOUNT	255
#define GlobalLRUNewest(h) ((HANDLE)(h))
#define GlobalLRUOldest(h) ((HANDLE)(h))
#define HEAP_GENERATE_EXCEPTIONS	4
#define HEAP_NO_SERIALIZE	1
#define HEAP_ZERO_MEMORY	8
#define STATUS_WAIT_0	0
#define STATUS_ABANDONED_WAIT_0	0x80
#define STATUS_USER_APC	0xC0
#define STATUS_TIMEOUT	0x102
#define STATUS_PENDING	0x103
#define STATUS_SEGMENT_NOTIFICATION	0x40000005
#define STATUS_GUARD_PAGE_VIOLATION	0x80000001
#define STATUS_DATATYPE_MISALIGNMENT	0x80000002
#define STATUS_BREAKPOINT	0x80000003
#define STATUS_SINGLE_STEP	0x80000004
#define STATUS_ACCESS_VIOLATION	0xC0000005
#define STATUS_IN_PAGE_ERROR	0xC0000006
#define STATUS_NO_MEMORY	0xC0000017
#define STATUS_ILLEGAL_INSTRUCTION	0xC000001D
#define STATUS_NONCONTINUABLE_EXCEPTION	0xC0000025
#define STATUS_INVALID_DISPOSITION	0xC0000026
#define STATUS_ARRAY_BOUNDS_EXCEEDED	0xC000008C
#define STATUS_FLOAT_DENORMAL_OPERAND	0xC000008D
#define STATUS_FLOAT_DIVIDE_BY_ZERO	0xC000008E
#define STATUS_FLOAT_INEXACT_RESULT	0xC000008F
#define STATUS_FLOAT_INVALID_OPERATION	0xC0000090
#define STATUS_FLOAT_OVERFLOW	0xC0000091
#define STATUS_FLOAT_STACK_CHECK	0xC0000092
#define STATUS_FLOAT_UNDERFLOW	0xC0000093
#define STATUS_INTEGER_DIVIDE_BY_ZERO	0xC0000094
#define STATUS_INTEGER_OVERFLOW	0xC0000095
#define STATUS_PRIVILEGED_INSTRUCTION	0xC0000096
#define STATUS_STACK_OVERFLOW	0xC00000FD
#define STATUS_CONTROL_C_EXIT	0xC000013A
#define STATUS_INVALID_HANDLE ((DWORD)0xC0000008L)
#define STATUS_POSSIBLE_DEADLOCK 0xC0000194L
#define ILC_COLOR	0
#define ILC_COLOR4	4
#define ILC_COLOR8	8
#define ILC_COLOR16	16
#define ILC_COLOR24	24
#define ILC_COLOR32	32
#define ILC_COLORDDB	254
#define ILC_MASK	1
#define ILC_MIRROR	0x00002000
#define ILC_PERITEMMIRROR	0x00008000
#define ILC_PALETTE	2048
#define ILD_BLEND25	2
#define ILD_BLEND50	4
#define ILD_SELECTED	4
#define ILD_BLEND	4
#define ILD_FOCUS	2
#define ILD_MASK	16
#define ILD_NORMAL	0
#define ILD_TRANSPARENT	1
#define ILD_IMAGE	0x00000020
#define ILD_ROP	0x040
#define ILD_BLEND25 2
#define ILD_BLEND50 4
#define ILD_OVERLAYMASK 0x0F00
#define INDEXTOOVERLAYMASK(i)	((i) << 8)
#define ILD_PRESERVEALPHA 0x1000
#define ILD_SCALE	0x00002000
#define ILD_DPISCALE	0x00004000
#define ILS_NORMAL	0
#define ILS_GLOW	1
#define ILS_SHADOW	2
#define ILS_SATURATE	4
#define ILS_ALPHA	8
#define ILCF_MOVE	0
#define ILCF_SWAP	1
#define CLR_NONE	0xffffffff
#define CLR_INVALID	CLR_NONE
#define CLR_DEFAULT	0xff000000
#define LR_DEFAULTCOLOR	0
#define LR_LOADFROMFILE	16
#define LR_LOADTRANSPARENT	32
#define LR_MONOCHROME	1
#define IME_CONFIG_GENERAL	1
#define IME_CONFIG_REGISTERWORD	2
#define IME_CONFIG_SELECTDICTIONARY	3
#define GCL_CONVERSION	1
#define GCL_REVERSECONVERSION	2
#define GCL_REVERSE_LENGTH	3
#define CPS_CANCEL	4
#define CPS_COMPLETE	1
#define CPS_CONVERT	2
#define CPS_REVERT	3
#define SECURITY_DESCRIPTOR_REVISION	1
#define SECURITY_DESCRIPTOR_REVISION1	1
#define IS_TEXT_UNICODE_ASCII16	1
#define IS_TEXT_UNICODE_REVERSE_ASCII16	16
#define IS_TEXT_UNICODE_STATISTICS	2
#define IS_TEXT_UNICODE_REVERSE_STATISTICS	32
#define IS_TEXT_UNICODE_CONTROLS	4
#define IS_TEXT_UNICODE_REVERSE_CONTROLS	64
#define IS_TEXT_UNICODE_SIGNATURE	8
#define IS_TEXT_UNICODE_REVERSE_SIGNATURE	128
#define IS_TEXT_UNICODE_ILLEGAL_CHARS	256
#define IS_TEXT_UNICODE_ODD_LENGTH	512
#define IS_TEXT_UNICODE_NULL_BYTES	4096
#define IS_TEXT_UNICODE_UNICODE_MASK	15
#define IS_TEXT_UNICODE_REVERSE_MASK	240
#define IS_TEXT_UNICODE_NOT_UNICODE_MASK	3840
#define IS_TEXT_UNICODE_NOT_ASCII_MASK	61440
#define HC_GETNEXT	1
#define HC_SKIP	2
#define HC_SYSMODALOFF	5
#define HC_SYSMODALON	4
#define HC_NOREMOVE	3
#define KEYEVENTF_EXTENDEDKEY	1
#define KEYEVENTF_KEYUP	2
#define OBM_BTNCORNERS	32758
#define OBM_BTSIZE	32761
#define OBM_CHECK	32760
#define OBM_CHECKBOXES	32759
#define OBM_CLOSE	32754
#define OBM_COMBO	32738
#define OBM_DNARROW	32752
#define OBM_DNARROWD	32742
#define OBM_DNARROWI	32736
#define OBM_LFARROW	32750
#define OBM_LFARROWI	32734
#define OBM_LFARROWD	32740
#define OBM_MNARROW	32739
#define OBM_OLD_CLOSE	32767
#define OBM_OLD_DNARROW	32764
#define OBM_OLD_LFARROW	32762
#define OBM_OLD_REDUCE	32757
#define OBM_OLD_RESTORE	32755
#define OBM_OLD_RGARROW	32763
#define OBM_OLD_UPARROW	32765
#define OBM_OLD_ZOOM	32756
#define OBM_REDUCE	32749
#define OBM_REDUCED	32746
#define OBM_RESTORE	32747
#define OBM_RESTORED	32744
#define OBM_RGARROW	32751
#define OBM_RGARROWD	32741
#define OBM_RGARROWI	32735
#define OBM_SIZE	32766
#define OBM_UPARROW	32753
#define OBM_UPARROWD	32743
#define OBM_UPARROWI	32737
#define OBM_ZOOM	32748
#define OBM_ZOOMD	32745
#define DONT_RESOLVE_DLL_REFERENCES	1
#define LOAD_LIBRARY_AS_DATAFILE	2
#define LOAD_WITH_ALTERED_SEARCH_PATH	8
#define LMEM_FIXED	0
#define LMEM_MOVEABLE	2
#define LPTR	64
#define LHND	66
#define NONZEROLHND	2
#define NONZEROLPTR	0
#define LMEM_NONZEROLHND	2
#define LMEM_NONZEROLPTR	0
#define LMEM_DISCARDABLE	3840
#define LMEM_NOCOMPACT	16
#define LMEM_NODISCARD	32
#define LMEM_ZEROINIT	64
#define LMEM_DISCARDED	16384
#define LMEM_MODIFY	128
#define LMEM_INVALID_HANDLE	32768
#define LMEM_LOCKCOUNT	255
#define LOCKFILE_FAIL_IMMEDIATELY	1
#define LOCKFILE_EXCLUSIVE_LOCK	2
#define MB_USERICON	128
#define MB_ICONASTERISK	64
#define MB_ICONEXCLAMATION	0x30
#define MB_ICONWARNING	0x30
#define MB_ICONERROR	16
#define MB_ICONHAND	16
#define MB_ICONQUESTION	32
#define MB_OK	0
#define MB_ABORTRETRYIGNORE	2
#define MB_APPLMODAL	0
#define MB_DEFAULT_DESKTOP_ONLY	0x20000
#define MB_HELP	0x4000
#define MB_RIGHT	0x80000
#define MB_RTLREADING	0x100000
#define MB_TOPMOST	0x40000
#define MB_DEFBUTTON1	0
#define MB_DEFBUTTON2	256
#define MB_DEFBUTTON3	512
#define MB_DEFBUTTON4	0x300
#define MB_ICONINFORMATION	64
#define MB_ICONSTOP	16
#define MB_OKCANCEL	1
#define MB_RETRYCANCEL	0x5
#define MB_SERVICE_NOTIFICATION	0x40000
#define MB_SETFOREGROUND	0x10000
#define MB_SYSTEMMODAL	4096
#define MB_TASKMODAL	0x2000
#define MB_YESNO	4
#define MB_YESNOCANCEL	3
#define IDABORT	3
#define IDCANCEL	2
#define IDCLOSE	8
#define IDHELP	9
#define IDIGNORE	5
#define IDNO	7
#define IDOK	1
#define IDRETRY	4
#define IDYES	6
#define MSGF_DIALOGBOX	0
#define MSGF_MENU	2
#define MSGF_NEXTWINDOW	6
#define MSGF_SCROLLBAR	5
#define MSGF_MAINLOOP	8
#define MSGF_USER	4096
#define MWT_IDENTITY	1
#define MWT_LEFTMULTIPLY	2
#define MWT_RIGHTMULTIPLY	3
#define MWT_MIN	MWT_IDENTITY
#define MWT_MAX	MWT_RIGHTMULTIPLY
#define MOUSEEVENTF_ABSOLUTE	32768
#define MOUSEEVENTF_MOVE	1
#define MOUSEEVENTF_LEFTDOWN	2
#define MOUSEEVENTF_LEFTUP	4
#define MOUSEEVENTF_RIGHTDOWN	8
#define MOUSEEVENTF_RIGHTUP	16
#define MOUSEEVENTF_MIDDLEDOWN	32
#define MOUSEEVENTF_MIDDLEUP	64
#define MOVEFILE_REPLACE_EXISTING	1
#define MOVEFILE_COPY_ALLOWED	2
#define MOVEFILE_DELAY_UNTIL_REBOOT	4
#define MOVEFILE_WRITE_THROUGH	8
#define MOVEFILE_CREATE_HARD_LINK 16
#define MOVEFILE_FAIL_IF_NOT_TRACKABLE 32
#define MOVEFILE_CREATE_HARDLINK 16
#define MOVEFILE_FAIL_IF_NOT_TRACKABLE 32
#define WAIT_OBJECT_0	0
#define WAIT_ABANDONED_0	128
#define WAIT_TIMEOUT	0x102
#define WAIT_IO_COMPLETION	0xc0
#define WAIT_ABANDONED	128
#define WAIT_FAILED	0xffffffff
#define MAXIMUM_WAIT_OBJECTS	64
#define MAXIMUM_SUSPEND_COUNT	0x7f
#define MB_PRECOMPOSED	1
#define MB_COMPOSITE	2
#define MB_ERR_INVALID_CHARS	8
#define MB_USEGLYPHCHARS	4
#define TOKEN_ADJUST_DEFAULT	128
#define TOKEN_ADJUST_GROUPS	64
#define TOKEN_ADJUST_PRIVILEGES	32
#define TOKEN_ALL_ACCESS	0xf00ff
#define TOKEN_ASSIGN_PRIMARY	1
#define TOKEN_DUPLICATE	2
#define TOKEN_EXECUTE	0x20000
#define TOKEN_IMPERSONATE	4
#define TOKEN_QUERY	8
#define TOKEN_QUERY_SOURCE	16
#define TOKEN_READ	0x20008
#define TOKEN_WRITE	0x200e0
#define HWND_BROADCAST	(HWND)65535
#define CopyMemory	RtlCopyMemory
#define RtlCopyMemory	memcpy
#define TAPE_FORMAT	5
#define TAPE_LOAD	0
#define TAPE_LOCK	3
#define TAPE_TENSION	2
#define TAPE_UNLOAD	1
#define TAPE_UNLOCK	4
#define IS_PSREBOOTSYSTEM	3
#define IS_PSRESTARTWINDOWS	2
#define PSPCB_CREATE	2
#define PSPCB_RELEASE	1
#define PURGE_TXABORT	1
#define PURGE_RXABORT	2
#define PURGE_TXCLEAR	4
#define PURGE_RXCLEAR	8
#define LPTx 0x80
#define OWNER_SECURITY_INFORMATION	1
#define GROUP_SECURITY_INFORMATION	2
#define DACL_SECURITY_INFORMATION	4
#define SACL_SECURITY_INFORMATION	8
#define EVENTLOG_FORWARDS_READ	4
#define EVENTLOG_BACKWARDS_READ	8
#define EVENTLOG_SEEK_READ	2
#define EVENTLOG_SEQUENTIAL_READ	1
#define EVENTLOG_ERROR_TYPE	1
#define EVENTLOG_WARNING_TYPE	2
#define EVENTLOG_INFORMATION_TYPE	4
#define EVENTLOG_AUDIT_SUCCESS	8
#define EVENTLOG_AUDIT_FAILURE	16
#define RDW_ERASE	4
#define RDW_FRAME	1024
#define RDW_INTERNALPAINT	2
#define RDW_INVALIDATE	1
#define RDW_NOERASE	32
#define RDW_NOFRAME	2048
#define RDW_NOINTERNALPAINT	16
#define RDW_VALIDATE	8
#define RDW_ERASENOW	512
#define RDW_UPDATENOW	256
#define RDW_ALLCHILDREN	128
#define RDW_NOCHILDREN	64
#define HKEY_CLASSES_ROOT	(HKEY)0x80000000
#define HKEY_CURRENT_USER	(HKEY)0x80000001
#define HKEY_LOCAL_MACHINE	(HKEY)0x80000002
#define HKEY_USERS	(HKEY)(-2147483645)
#define HKEY_PERFORMANCE_DATA	(HKEY)(-2147483644)
#define HKEY_CURRENT_CONFIG	(HKEY)(-2147483643)

//#ifndef HKEY_DYN_DATA
#define HKEY_DYN_DATA	((HKEY)(0x80000006))
//#endif
#define REG_OPTION_VOLATILE	1
#define REG_OPTION_NON_VOLATILE	0
#define REG_CREATED_NEW_KEY	1
#define REG_OPENED_EXISTING_KEY	2
#define REG_BINARY	3
#define REG_DWORD	4
#define REG_DWORD_LITTLE_ENDIAN	4
#define REG_DWORD_BIG_ENDIAN	5
#define REG_EXPAND_SZ	2
#define REG_LINK	6
#define REG_MULTI_SZ	7
#define REG_NONE	0
#define REG_RESOURCE_LIST	8
#define REG_FULL_RESOURCE_DESCRIPTOR 9
#define REG_RESOURCE_REQUIREMENTS_LIST 10
#define REG_SZ	1
#define MOD_ALT	1
#define MOD_CONTROL	2
#define MOD_SHIFT	4
#define MOD_WIN	8
#define IDHOT_SNAPDESKTOP	(-2)
#define IDHOT_SNAPWINDOW	(-1)
#define REG_NOTIFY_CHANGE_NAME	1
#define REG_NOTIFY_CHANGE_ATTRIBUTES	2
#define REG_NOTIFY_CHANGE_LAST_SET	4
#define REG_NOTIFY_CHANGE_SECURITY	8
#define SW_ERASE	4
#define SW_INVALIDATE	2
#define SW_SCROLLCHILDREN	1
#define SMTO_ABORTIFHUNG	2
#define SMTO_BLOCK	1
#define SMTO_NORMAL	0
#define OPAQUE	2
#define TRANSPARENT	1
#define SLE_ERROR	1
#define SLE_MINORERROR	2
#define SLE_WARNING	3
#define SEM_FAILCRITICALERRORS	1
#define SEM_NOALIGNMENTFAULTEXCEPT	4
#define SEM_NOGPFAULTERRORBOX	2
#define SEM_NOOPENFILEERRORBOX	32768
#define ICM_ON	2
#define ICM_OFF	1
#define ICM_QUERY	3
#define LOCALE_ILANGUAGE	1
#define LOCALE_SLANGUAGE	2
#define LOCALE_SENGLANGUAGE	4097
#define LOCALE_SABBREVLANGNAME	3
#define LOCALE_SNATIVELANGNAME	4
#define LOCALE_ICOUNTRY	5
#define LOCALE_SCOUNTRY	6
#define LOCALE_SENGCOUNTRY	4098
#define LOCALE_SABBREVCTRYNAME	7
#define LOCALE_SNATIVECTRYNAME	8
#define LOCALE_IDEFAULTLANGUAGE	9
#define LOCALE_IDEFAULTCOUNTRY	10
#define LOCALE_IDEFAULTANSICODEPAGE	4100
#define LOCALE_IDEFAULTCODEPAGE	11
#define LOCALE_SLIST	12
#define LOCALE_IMEASURE	13
#define LOCALE_SDECIMAL	14
#define LOCALE_STHOUSAND	15
#define LOCALE_SGROUPING	16
#define LOCALE_IDIGITS	17
#define LOCALE_ILZERO	18
#define LOCALE_INEGNUMBER	4112
#define LOCALE_SCURRENCY	20
#define LOCALE_SMONDECIMALSEP	22
#define LOCALE_SMONTHOUSANDSEP	23
#define LOCALE_SMONGROUPING	24
#define LOCALE_ICURRDIGITS	25
#define LOCALE_ICURRENCY	27
#define LOCALE_INEGCURR	28
#define LOCALE_SDATE	29
#define LOCALE_STIME	30
#define LOCALE_STIMEFORMAT	4099
#define LOCALE_SSHORTDATE	31
#define LOCALE_SLONGDATE	32
#define LOCALE_IDATE	33
#define LOCALE_ILDATE	34
#define LOCALE_ITIME	35
#define LOCALE_ITLZERO	37
#define LOCALE_IDAYLZERO	38
#define LOCALE_IMONLZERO	39
#define LOCALE_S1159	40
#define LOCALE_S2359	41
#define LOCALE_ICALENDARTYPE	4105
#define LOCALE_IOPTIONALCALENDAR	4107
#define LOCALE_IFIRSTDAYOFWEEK	4108
#define LOCALE_IFIRSTWEEKOFYEAR	4109
#define LOCALE_SDAYNAME1	42
#define LOCALE_SDAYNAME2	43
#define LOCALE_SDAYNAME3	44
#define LOCALE_SDAYNAME4	45
#define LOCALE_SDAYNAME5	46
#define LOCALE_SDAYNAME6	47
#define LOCALE_SDAYNAME7	48
#define LOCALE_SABBREVDAYNAME1	49
#define LOCALE_SABBREVDAYNAME2	50
#define LOCALE_SABBREVDAYNAME3	51
#define LOCALE_SABBREVDAYNAME4	52
#define LOCALE_SABBREVDAYNAME5	53
#define LOCALE_SABBREVDAYNAME6	54
#define LOCALE_SABBREVDAYNAME7	55
#define LOCALE_SMONTHNAME1	56
#define LOCALE_SMONTHNAME2	57
#define LOCALE_SMONTHNAME3	58
#define LOCALE_SMONTHNAME4	59
#define LOCALE_SMONTHNAME5	60
#define LOCALE_SMONTHNAME6	61
#define LOCALE_SMONTHNAME7	62
#define LOCALE_SMONTHNAME8	63
#define LOCALE_SMONTHNAME9	64
#define LOCALE_SMONTHNAME10	65
#define LOCALE_SMONTHNAME11	66
#define LOCALE_SMONTHNAME12	67
#define LOCALE_SMONTHNAME13	4110
#define LOCALE_SABBREVMONTHNAME1	68
#define LOCALE_SABBREVMONTHNAME2	69
#define LOCALE_SABBREVMONTHNAME3	70
#define LOCALE_SABBREVMONTHNAME4	71
#define LOCALE_SABBREVMONTHNAME5	72
#define LOCALE_SABBREVMONTHNAME6	73
#define LOCALE_SABBREVMONTHNAME7	74
#define LOCALE_SABBREVMONTHNAME8	75
#define LOCALE_SABBREVMONTHNAME9	76
#define LOCALE_SABBREVMONTHNAME10	77
#define LOCALE_SABBREVMONTHNAME11	78
#define LOCALE_SABBREVMONTHNAME12	79
#define LOCALE_SABBREVMONTHNAME13	4111
#define LOCALE_SPOSITIVESIGN	80
#define LOCALE_SNEGATIVESIGN	81
#define LOCALE_IPOSSIGNPOSN	82
#define LOCALE_INEGSIGNPOSN	83
#define LOCALE_IPOSSYMPRECEDES	84
#define LOCALE_IPOSSEPBYSPACE	85
#define LOCALE_INEGSYMPRECEDES	86
#define LOCALE_INEGSEPBYSPACE	87
#define LOCALE_NOUSEROVERRIDE	0x80000000
#define CAL_ICALINTVALUE	1
#define CAL_IYEAROFFSETRANGE	3
#define CAL_SABBREVDAYNAME1	14
#define CAL_SABBREVDAYNAME2	15
#define CAL_SABBREVDAYNAME3	16
#define CAL_SABBREVDAYNAME4	17
#define CAL_SABBREVDAYNAME5	18
#define CAL_SABBREVDAYNAME6	19
#define CAL_SABBREVDAYNAME7	20
#define CAL_SABBREVMONTHNAME1	34
#define CAL_SABBREVMONTHNAME2	35
#define CAL_SABBREVMONTHNAME3	36
#define CAL_SABBREVMONTHNAME4	37
#define CAL_SABBREVMONTHNAME5	38
#define CAL_SABBREVMONTHNAME6	39
#define CAL_SABBREVMONTHNAME7	40
#define CAL_SABBREVMONTHNAME8	41
#define CAL_SABBREVMONTHNAME9	42
#define CAL_SABBREVMONTHNAME10	43
#define CAL_SABBREVMONTHNAME11	44
#define CAL_SABBREVMONTHNAME12	45
#define CAL_SABBREVMONTHNAME13	46
#define CAL_SCALNAME	2
#define CAL_SDAYNAME1	7
#define CAL_SDAYNAME2	8
#define CAL_SDAYNAME3	9
#define CAL_SDAYNAME4	10
#define CAL_SDAYNAME5	11
#define CAL_SDAYNAME6	12
#define CAL_SDAYNAME7	13
#define CAL_SERASTRING	4
#define CAL_SLONGDATE	6
#define CAL_SMONTHNAME1	21
#define CAL_SMONTHNAME2	22
#define CAL_SMONTHNAME3	23
#define CAL_SMONTHNAME4	24
#define CAL_SMONTHNAME5	25
#define CAL_SMONTHNAME6	26
#define CAL_SMONTHNAME7	27
#define CAL_SMONTHNAME8	28
#define CAL_SMONTHNAME9	29
#define CAL_SMONTHNAME10	30
#define CAL_SMONTHNAME11	31
#define CAL_SMONTHNAME12	32
#define CAL_SMONTHNAME13	33
#define CAL_SSHORTDATE	5
#define PROCESS_SET_QUOTA	256
#define BLACKONWHITE	1
#define COLORONCOLOR	3
#define HALFTONE	4
#define MAXSTRETCHBLTMODE	4
#define STRETCH_ANDSCANS	1
#define STRETCH_DELETESCANS	3
#define STRETCH_HALFTONE	4
#define STRETCH_ORSCANS	2
#define WHITEONBLACK	2
#define OCR_NORMAL	32512
#define OCR_IBEAM	32513
#define OCR_WAIT	32514
#define OCR_CROSS	32515
#define OCR_UP	32516
#define OCR_SIZE	32640
#define OCR_ICON	32641
#define OCR_SIZENWSE	32642
#define OCR_SIZENESW	32643
#define OCR_SIZEWE	32644
#define OCR_SIZENS	32645
#define OCR_SIZEALL	32646
#define OCR_NO	32648
#define OCR_APPSTARTING	32650
#define TAPE_ABSOLUTE_BLOCK	1
#define TAPE_LOGICAL_BLOCK	2
#define TAPE_REWIND	0
#define TAPE_SPACE_END_OF_DATA	4
#define TAPE_SPACE_FILEMARKS	6
#define TAPE_SPACE_RELATIVE_BLOCKS	5
#define TAPE_SPACE_SEQUENTIAL_FMKS	7
#define TAPE_SPACE_SEQUENTIAL_SMKS	9
#define TAPE_SPACE_SETMARKS	8
#define EXCEPTION_EXECUTE_HANDLER	1
#define EXCEPTION_CONTINUE_EXECUTION	-1
#define EXCEPTION_CONTINUE_SEARCH	0
#define HWND_BOTTOM	(HWND)1
#define HWND_NOTOPMOST	(HWND)(-2)
#define HWND_TOP	(HWND)0
#define HWND_TOPMOST	(HWND)(-1)
#define SWP_DRAWFRAME	32
#define SWP_FRAMECHANGED	32
#define SWP_HIDEWINDOW	128
#define SWP_NOACTIVATE	16
#define SWP_NOCOPYBITS	256
#define SWP_NOMOVE	2
#define SWP_NOSIZE	1
#define SWP_NOREDRAW	8
#define SWP_NOZORDER	4
#define SWP_SHOWWINDOW	64
#define SWP_NOOWNERZORDER	512
#define SWP_NOREPOSITION	512
#define SWP_NOSENDCHANGING	1024
#define HSHELL_ACTIVATESHELLWINDOW	3
#define HSHELL_GETMINRECT	5
#define HSHELL_LANGUAGE	8
#define HSHELL_REDRAW	6
#define HSHELL_TASKMAN	7
#define HSHELL_WINDOWACTIVATED	4
#define HSHELL_WINDOWCREATED	1
#define HSHELL_WINDOWDESTROYED	2
#define HSHELL_ACCESSIBILITYSTATE	11
#define HSHELL_APPCOMMAND	12
#define SW_HIDE	0
#define SW_NORMAL 1
#define SW_MAXIMIZE	3
#define SW_MINIMIZE	6
#define SW_RESTORE	9
#define SW_SHOW	5
#define SW_SHOWDEFAULT	10
#define SW_SHOWMAXIMIZED	3
#define SW_SHOWMINIMIZED	2
#define SW_SHOWMINNOACTIVE	7
#define SW_SHOWNA	8
#define SW_SHOWNOACTIVATE	4
#define SW_SHOWNORMAL	1
#define WPF_RESTORETOMAXIMIZED	2
#define WPF_SETMINPOSITION	1
#define INFINITE	(-1)
#define SPI_GETACCESSTIMEOUT	60
#define SPI_GETANIMATION	72
#define SPI_GETBEEP	1
#define SPI_GETBORDER	5
#define SPI_GETDEFAULTINPUTLANG	89
#define SPI_GETDRAGFULLWINDOWS	38
#define SPI_GETFASTTASKSWITCH	35
#define SPI_GETFILTERKEYS	50
#define SPI_GETFONTSMOOTHING	74
#define SPI_GETGRIDGRANULARITY	18
#define SPI_GETHIGHCONTRAST	66
#define SPI_GETICONMETRICS	45
#define SPI_GETICONTITLELOGFONT	31
#define SPI_GETICONTITLEWRAP	25
#define SPI_GETKEYBOARDDELAY	22
#define SPI_GETKEYBOARDPREF	68
#define SPI_GETKEYBOARDSPEED	10
#define SPI_GETLOWPOWERACTIVE	83
#define SPI_GETLOWPOWERTIMEOUT	79
#define SPI_GETMENUDROPALIGNMENT	27
#define SPI_GETMINIMIZEDMETRICS	43
#define SPI_GETMOUSE	3
#define SPI_GETMOUSEKEYS	54
#define SPI_GETMOUSETRAILS	94
#define SPI_GETNONCLIENTMETRICS	41
#define SPI_GETPOWEROFFACTIVE	84
#define SPI_GETPOWEROFFTIMEOUT	80
#define SPI_GETSCREENREADER	70
#define SPI_GETSCREENSAVEACTIVE	16
#define SPI_GETSCREENSAVETIMEOUT	14
#define SPI_GETSERIALKEYS	62
#define SPI_GETSHOWSOUNDS	56
#define SPI_GETSOUNDSENTRY	64
#define SPI_GETSTICKYKEYS	58
#define SPI_GETTOGGLEKEYS	52
#define SPI_GETMOUSESPEED	0x70
#define SPI_SETMOUSESPEED	0x71
#define SPI_GETSCREENSAVERRUNNING 0x72
#define SPI_GETDESKWALLPAPER	0x73
#define SPI_GETWINDOWSEXTENSION	92
#define SPI_GETWORKAREA	48
#define SPI_GETACTIVEWINDOWTRACKING	0x1000
#define SPI_SETACTIVEWINDOWTRACKING	0x1001
#define SPI_GETMENUANIMATION	0x1002
#define SPI_SETMENUANIMATION	0x1003
#define SPI_GETCOMBOBOXANIMATION	0x1004
#define SPI_SETCOMBOBOXANIMATION	0x1005
#define SPI_GETLISTBOXSMOOTHSCROLLING	0x1006
#define SPI_SETLISTBOXSMOOTHSCROLLING	0x1007
#define SPI_GETGRADIENTCAPTIONS	0x1008
#define SPI_SETGRADIENTCAPTIONS	0x1009
#define SPI_GETKEYBOARDCUES	0x100A
#define SPI_SETKEYBOARDCUES	0x100B
#define SPI_GETMENUUNDERLINES	SPI_GETKEYBOARDCUES
#define SPI_SETMENUUNDERLINES	SPI_SETKEYBOARDCUES
#define SPI_GETACTIVEWNDTRKZORDER	0x100C
#define SPI_SETACTIVEWNDTRKZORDER	0x100D
#define SPI_GETHOTTRACKING	0x100E
#define SPI_SETHOTTRACKING	0x100F
#define SPI_GETMENUFADE	0x1012
#define SPI_SETMENUFADE	0x1013
#define SPI_GETSELECTIONFADE	0x1014
#define SPI_SETSELECTIONFADE	0x1015
#define SPI_GETTOOLTIPANIMATION	0x1016
#define SPI_SETTOOLTIPANIMATION	0x1017
#define SPI_GETTOOLTIPFADE	0x1018
#define SPI_SETTOOLTIPFADE	0x1019
#define SPI_GETCURSORSHADOW	0x101A
#define SPI_SETCURSORSHADOW	0x101B
#define SPI_GETMOUSESONAR	0x101C
#define SPI_SETMOUSESONAR	0x101D
#define SPI_GETMOUSECLICKLOCK	0x101E
#define SPI_SETMOUSECLICKLOCK	0x101F
#define SPI_GETMOUSEVANISH	0x1020
#define SPI_SETMOUSEVANISH	0x1021
#define SPI_GETFLATMENU	0x1022
#define SPI_SETFLATMENU	0x1023
#define SPI_GETDROPSHADOW	0x1024
#define SPI_SETDROPSHADOW	0x1025
#define SPI_GETMOUSECLICKLOCKTIME	0x2008
#define SPI_SETMOUSECLICKLOCKTIME	0x2009
#define SPI_GETFONTSMOOTHINGTYPE	0x200A
#define SPI_SETFONTSMOOTHINGTYPE	0x200B
#define FE_FONTSMOOTHINGSTANDARD	0x0001
#define FE_FONTSMOOTHINGCLEARTYPE	0x0002
#define FE_FONTSMOOTHINGDOCKING	0x8000
#define SPI_GETFONTSMOOTHINGCONTRAST	2
#define SPI_SETFONTSMOOTHINGCONTRAST	2
#define SPI_GETFOCUSBORDERWIDTH	0x200E
#define SPI_SETFOCUSBORDERWIDTH	0x200F
#define SPI_GETFOCUSBORDERHEIGHT	0x2010
#define SPI_SETFOCUSBORDERHEIGHT	0x2011
#define SPI_ICONHORIZONTALSPACING	13
#define SPI_ICONVERTICALSPACING	24
#define SPI_LANGDRIVER	12
#define SPI_SCREENSAVERRUNNING	97
#define SPI_SETACCESSTIMEOUT	61
#define SPI_SETANIMATION	73
#define SPI_SETBEEP	2
#define SPI_SETBORDER	6
#define SPI_SETDEFAULTINPUTLANG	90
#define SPI_SETDESKPATTERN	21
#define SPI_SETDESKWALLPAPER	20
#define SPI_SETDOUBLECLICKTIME	32
#define SPI_SETDOUBLECLKHEIGHT	30
#define SPI_SETDOUBLECLKWIDTH	29
#define SPI_SETDRAGFULLWINDOWS	37
#define SPI_SETDRAGHEIGHT	77
#define SPI_SETDRAGWIDTH	76
#define SPI_SETFASTTASKSWITCH	36
#define SPI_SETFILTERKEYS	51
#define SPI_SETFONTSMOOTHING	75
#define SPI_SETGRIDGRANULARITY	19
#define SPI_SETHANDHELD	78
#define SPI_SETHIGHCONTRAST	67
#define SPI_SETICONMETRICS	46
#define SPI_SETICONTITLELOGFONT	34
#define SPI_SETICONTITLEWRAP	26
#define SPI_SETKEYBOARDDELAY	23
#define SPI_SETKEYBOARDPREF	69
#define SPI_SETKEYBOARDSPEED	11
#define SPI_SETLANGTOGGLE	91
#define SPI_SETLOWPOWERACTIVE	85
#define SPI_SETLOWPOWERTIMEOUT	81
#define SPI_SETMENUDROPALIGNMENT	28
#define SPI_SETMINIMIZEDMETRICS	44
#define SPI_SETMOUSE	4
#define SPI_SETMOUSEBUTTONSWAP	33
#define SPI_SETMOUSEKEYS	55
#define SPI_SETMOUSETRAILS	93
#define SPI_SETNONCLIENTMETRICS	42
#define SPI_SETPENWINDOWS	49
#define SPI_SETPOWEROFFACTIVE	86
#define SPI_SETPOWEROFFTIMEOUT	82
#define SPI_SETSCREENREADER	71
#define SPI_SETSCREENSAVEACTIVE	17
#define SPI_SETSCREENSAVETIMEOUT	15
#define SPI_SETSERIALKEYS	63
#define SPI_SETSHOWSOUNDS	57
#define SPI_SETSOUNDSENTRY	65
#define SPI_SETSTICKYKEYS	59
#define SPI_SETTOGGLEKEYS	53
#define SPI_SETWORKAREA	47
#define SPIF_UPDATEINIFILE	1
#define SPIF_SENDWININICHANGE	2
#define SPIF_SENDCHANGE	2
#define TPM_CENTERALIGN	4
#define TPM_LEFTALIGN	0
#define TPM_RIGHTALIGN	8
#define TPM_LEFTBUTTON	0
#define TPM_RIGHTBUTTON	2
#define TPM_HORIZONTAL	0
#define TPM_VERTICAL	64
#define TPM_TOPALIGN 0
#define TPM_VCENTERALIGN 16
#define TPM_BOTTOMALIGN 32
#define TPM_NONOTIFY 128
#define TPM_RETURNCMD 256
#define TPM_RECURSE	1
#define TPM_HORPOSANIMATION 0x0400
#define TPM_HORNEGANIMATION 0x0800
#define TPM_VERPOSANIMATION 0x1000
#define TPM_VERNEGANIMATION 0x2000
#define TPM_NOANIMATION	0x4000
#define TCI_SRCCHARSET	1
#define TCI_SRCCODEPAGE	2
#define TCI_SRCFONTSIG	3
#define WC_COMPOSITECHECK	512
#define WC_DISCARDNS	16
#define WC_SEPCHARS	32
#define WC_DEFAULTCHAR	64
#define WC_DIALOG	MAKEINTATOM(0x8002)
#define HELP_COMMAND	0x102
#define HELP_CONTENTS	3
#define HELP_CONTEXT	1
#define HELP_CONTEXTPOPUP	8
#define HELP_FORCEFILE	9
#define HELP_HELPONHELP	4
#define HELP_INDEX	3
#define HELP_KEY	0x101
#define HELP_MULTIKEY	0x201
#define HELP_PARTIALKEY	0x105
#define HELP_QUIT	2
#define HELP_SETCONTENTS	5
#define HELP_SETINDEX	5
#define HELP_CONTEXTMENU	0xa
#define HELP_FINDER	0xb
#define HELP_WM_HELP	0xc
#define HELP_TCARD	0x8000
#define HELP_TCARD_DATA	16
#define HELP_TCARD_OTHER_CALLER	0x11
#define WNNC_NET_MSNET 0x010000
#define WNNC_NET_LANMAN 0x020000
#define WNNC_NET_NETWARE 0x030000
#define WNNC_NET_VINES 0x040000
#define WNNC_NET_10NET 0x050000
#define WNNC_NET_LOCUS 0x060000
#define WNNC_NET_SUN_PC_NFS 0x070000
#define WNNC_NET_LANSTEP 0x080000
#define WNNC_NET_9TILES 0x090000
#define WNNC_NET_LANTASTIC 0x0A0000
#define WNNC_NET_AS400 0x0B0000
#define WNNC_NET_FTP_NFS 0x0C0000
#define WNNC_NET_PATHWORKS 0x0D0000
#define WNNC_NET_LIFENET 0x0E0000
#define WNNC_NET_POWERLAN 0x0F0000
#define WNNC_NET_BWNFS 0x100000
#define WNNC_NET_COGENT 0x110000
#define WNNC_NET_FARALLON 0x120000
#define WNNC_NET_APPLETALK 0x130000
#define WNNC_NET_INTERGRAPH 0x140000
#define WNNC_NET_SYMFONET 0x150000
#define WNNC_NET_CLEARCASE 0x160000
#define WNNC_NET_FRONTIER 0x170000
#define WNNC_NET_BMC 0x180000
#define WNNC_NET_DCE 0x190000
#define WNNC_NET_DECORB 0x200000
#define WNNC_NET_PROTSTOR 0x210000
#define WNNC_NET_FJ_REDIR 0x220000
#define WNNC_NET_DISTINCT 0x230000
#define WNNC_NET_TWINS 0x240000
#define WNNC_NET_RDR2SAMPLE 0x250000
#define WNFMT_MULTILINE 1
#define WNFMT_ABBREVIATED 2
#define WNFMT_INENUM 16
#define WNFMT_CONNECTION	0x20
#define WNCON_FORNETCARD	1
#define WNCON_NOTROUTED	2
#define WNCON_SLOWLINK	4
#define WNCON_DYNAMIC	8
#define NETINFO_DLL16	1
#define NETINFO_DISKRED	4
#define NETINFO_PRINTERRED	8
#define NETPROPERTY_PERSISTENT	1
#define CONNECT_UPDATE_PROFILE	1
#define CONNECT_UPDATE_RECENT	2
#define CONNECT_TEMPORARY	4
#define CONNECT_INTERACTIVE	8
#define CONNECT_PROMPT		16
#define CONNECT_NEED_DRIVE	32
#define CONNECT_REFCOUNT	64
#define CONNECT_REDIRECT	0x80
#define CONNECT_LOCALDRIVE	0x100
#define CONNECT_CURRENT_MEDIA	0x200
#define CONNECT_DEFERRED	0x400
#define CONNECT_RESERVED	0xFF000000
#define CONNDLG_RO_PATH		1
#define CONNDLG_CONN_POINT	2
#define CONNDLG_USE_MRU		4
#define CONNDLG_HIDE_BOX	8
#define CONNDLG_PERSIST		16
#define CONNDLG_NOT_PERSIST	32
#define DISC_UPDATE_PROFILE	1
#define DISC_NO_FORCE		0x40
#define RESOURCETYPE_DISK	1
#define RESOURCETYPE_PRINT	2
#define RESOURCETYPE_ANY	0
#define RESOURCE_CONNECTED	1
#define RESOURCE_GLOBALNET	2
#define RESOURCE_REMEMBERED	3
#define RESOURCEUSAGE_CONNECTABLE	1
#define RESOURCEUSAGE_CONTAINER	2
#define WN_SUCCESS NO_ERROR
#define WN_NO_ERROR NO_ERROR
#define WN_NOT_SUPPORTED ERROR_NOT_SUPPORTED
#define WN_CANCEL ERROR_CANCELLED
#define WN_RETRY ERROR_RETRY
#define WN_NET_ERROR ERROR_UNEXP_NET_ERR
#define WN_MORE_DATA ERROR_MORE_DATA
#define WN_BAD_POINTER ERROR_INVALID_ADDRESS
#define WN_BAD_VALUE ERROR_INVALID_PARAMETER
#define WN_BAD_USER ERROR_BAD_USERNAME
#define WN_BAD_PASSWORD ERROR_INVALID_PASSWORD
#define WN_ACCESS_DENIED ERROR_ACCESS_DENIED
#define WN_FUNCTION_BUSY ERROR_BUSY
#define WN_WINDOWS_ERROR ERROR_UNEXP_NET_ERR
#define WN_OUT_OF_MEMORY ERROR_NOT_ENOUGH_MEMORY
#define WN_NO_NETWORK ERROR_NO_NETWORK
#define WN_EXTENDED_ERROR ERROR_EXTENDED_ERROR
#define WN_BAD_LEVEL ERROR_INVALID_LEVEL
#define WN_BAD_HANDLE ERROR_INVALID_HANDLE
#define WN_NOT_INITIALIZING ERROR_ALREADY_INITIALIZED
#define WN_NO_MORE_DEVICES ERROR_NO_MORE_DEVICES
#define WN_NOT_CONNECTED ERROR_NOT_CONNECTED
#define WN_OPEN_FILES ERROR_OPEN_FILES
#define WN_DEVICE_IN_USE ERROR_DEVICE_IN_USE
#define WN_BAD_NETNAME ERROR_BAD_NET_NAME
#define WN_BAD_LOCALNAME ERROR_BAD_DEVICE
#define WN_ALREADY_CONNECTED ERROR_ALREADY_ASSIGNED
#define WN_DEVICE_ERROR ERROR_GEN_FAILURE
#define WN_CONNECTION_CLOSED ERROR_CONNECTION_UNAVAIL
#define WN_NO_NET_OR_BAD_PATH ERROR_NO_NET_OR_BAD_PATH
#define WN_BAD_PROVIDER ERROR_BAD_PROVIDER
#define WN_CANNOT_OPEN_PROFILE ERROR_CANNOT_OPEN_PROFILE
#define WN_BAD_PROFILE ERROR_BAD_PROFILE
#define WN_BAD_DEV_TYPE ERROR_BAD_DEV_TYPE
#define WN_DEVICE_ALREADY_REMEMBERED ERROR_DEVICE_ALREADY_REMEMBERED
#define WN_CONNECTED_OTHER_PASSWORD ERROR_CONNECTED_OTHER_PASSWORD
#define WN_NO_MORE_ENTRIES ERROR_NO_MORE_ITEMS
#define WN_NOT_CONTAINER ERROR_NOT_CONTAINER
#define WN_NOT_AUTHENTICATED ERROR_NOT_AUTHENTICATED
#define WN_NOT_LOGGED_ON ERROR_NOT_LOGGED_ON
#define WN_NOT_VALIDATED ERROR_NO_LOGON_SERVERS
#define UNIVERSAL_NAME_INFO_LEVEL	1
#define REMOTE_NAME_INFO_LEVEL	2
#define STILL_ACTIVE	0x103
#define SP_SERIALCOMM	1
#define BAUD_075	1
#define BAUD_110	2
#define BAUD_134_5	4
#define BAUD_150	8
#define BAUD_300	16
#define BAUD_600	32
#define BAUD_1200	64
#define BAUD_1800	128
#define BAUD_2400	256
#define BAUD_4800	512
#define BAUD_7200	0x400
#define BAUD_9600	0x800
#define BAUD_14400	4096
#define BAUD_19200	0x2000
#define BAUD_38400	0x4000
#define BAUD_56K	0x8000
#define BAUD_57600	0x40000
#define BAUD_115200	0x20000
#define BAUD_128K	0x10000
#define BAUD_USER	0x10000000
#define PST_FAX	0x21
#define PST_LAT	0x101
#define PST_MODEM	6
#define PST_NETWORK_BRIDGE	256
#define PST_PARALLELPORT	2
#define PST_RS232	1
#define PST_RS422	3
#define PST_RS423	4
#define PST_RS449	5
#define PST_SCANNER	0x22
#define PST_TCPIP_TELNET	0x102
#define PST_UNSPECIFIED	0
#define PST_X25	0x103
#define PCF_16BITMODE	512
#define PCF_DTRDSR	1
#define PCF_INTTIMEOUTS	128
#define PCF_PARITY_CHECK	8
#define PCF_RLSD	4
#define PCF_RTSCTS	2
#define PCF_SETXCHAR	32
#define PCF_SPECIALCHARS	256
#define PCF_TOTALTIMEOUTS	64
#define PCF_XONXOFF	16
#define SP_BAUD	2
#define SP_DATABITS	4
#define SP_HANDSHAKING	0x10
#define SP_PARITY	1
#define SP_PARITY_CHECK	32
#define SP_RLSD	64
#define SP_STOPBITS	8
#define DATABITS_5	1
#define DATABITS_6	2
#define DATABITS_7	4
#define DATABITS_8	8
#define DATABITS_16	16
#define DATABITS_16X	32
#define STOPBITS_10	1
#define STOPBITS_15	2
#define STOPBITS_20	4
#define PARITY_NONE	256
#define PARITY_ODD	512
#define PARITY_EVEN	1024
#define PARITY_MARK	2048
#define PARITY_SPACE	4096
#define COMMPROP_INITIALIZED	0xe73cf52e
#define CBR_110	110
#define CBR_300	300
#define CBR_600	600
#define CBR_1200	1200
#define CBR_2400	2400
#define CBR_4800	4800
#define CBR_9600	9600
#define CBR_14400	14400
#define CBR_19200	19200
#define CBR_38400	38400
#define CBR_56000	56000
#define CBR_57600	57600
#define CBR_115200	115200
#define CBR_128000	128000
#define CBR_256000	256000
#define DTR_CONTROL_DISABLE	0
#define DTR_CONTROL_ENABLE	1
#define DTR_CONTROL_HANDSHAKE	2
#define RTS_CONTROL_DISABLE	0
#define RTS_CONTROL_ENABLE	1
#define RTS_CONTROL_HANDSHAKE	2
#define RTS_CONTROL_TOGGLE	3
#define EVENPARITY	2
#define MARKPARITY	3
#define NOPARITY	0
#define SPACEPARITY	4
#define ODDPARITY	1
#define ONESTOPBIT	0
#define ONE5STOPBITS	1
#define TWOSTOPBITS	2
#define CREATE_FOR_IMPORT 1
#define CREATE_FOR_DIR 2
#define OVERWRITE_HIDDEN 4
#define CREATE_PROCESS_DEBUG_EVENT	3
#define CREATE_THREAD_DEBUG_EVENT	2
#define EXCEPTION_DEBUG_EVENT	1
#define EXIT_PROCESS_DEBUG_EVENT	5
#define EXIT_THREAD_DEBUG_EVENT	4
#define LOAD_DLL_DEBUG_EVENT	6
#define OUTPUT_DEBUG_STRING_EVENT	8
#define UNLOAD_DLL_DEBUG_EVENT	7
#define RIP_EVENT	9
#define PROCESS_HEAP_REGION	1
#define PROCESS_HEAP_UNCOMMITTED_RANGE	2
#define PROCESS_HEAP_ENTRY_BUSY	4
#define PROCESS_HEAP_ENTRY_MOVEABLE	16
#define PROCESS_HEAP_ENTRY_DDESHARE	32
#define HINSTANCE_ERROR	32
#define BACKUP_INVALID	0
#define BACKUP_DATA	1
#define BACKUP_EA_DATA	2
#define BACKUP_SECURITY_DATA	3
#define BACKUP_ALTERNATE_DATA	4
#define BACKUP_LINK	5
#define BACKUP_PROPERTY_DATA	6
#define BACKUP_OBJECT_ID	7
#define BACKUP_REPARSE_DATA	8
#define BACKUP_SPARSE_BLOCK	9
#define STREAM_NORMAL_ATTRIBUTE	0
#define STREAM_MODIFIED_WHEN_READ	1
#define STREAM_CONTAINS_SECURITY	2
#define STREAM_CONTAINS_PROPERTIES	4
#define STREAM_SPARSE_ATTRIBUTE	8
#define STARTF_USESHOWWINDOW	1
#define STARTF_USEPOSITION	4
#define STARTF_USESIZE	2
#define STARTF_RUNFULLSCREEN	0x20
#define STARTF_USECOUNTCHARS	8
#define STARTF_USEFILLATTRIBUTE	16
#define STARTF_FORCEONFEEDBACK	64
#define STARTF_FORCEOFFFEEDBACK	128
#define STARTF_USESTDHANDLES	256
#define STARTF_USEHOTKEY	0x0200
#define VER_PLATFORM_WIN32s	0
#define VER_PLATFORM_WIN32_WINDOWS 1
#define VER_PLATFORM_WIN32_NT	2
#define MAXPROPPAGES	100
#define PSP_DEFAULT	0
#define PSP_HASHELP	32
#define PSP_USECALLBACK	128
#define PSP_USEHICON	2
#define PSP_USEICONID	4
#define PSP_USEREFPARENT	64
#define PSP_USETITLE	8
#define PSP_RTLREADING	16
#define PSP_DLGINDIRECT	1
#define PSH_DEFAULT	0
#define PSH_HASHELP	512
#define PSH_MODELESS	1024
#define PSH_NOAPPLYNOW	128
#define PSH_PROPSHEETPAGE	8
#define PSH_PROPTITLE	1
#define PSH_USECALLBACK	256
#define PSH_USEHICON	2
#define PSH_USEICONID	4
#define PSH_USEPSTARTPAGE	64
#define PSH_WIZARD	32
#define PSH_RTLREADING	2048
#define PSCB_INITIALIZED	1
#define PSCB_PRECREATE	2
#define PSNRET_NOERROR	0
#define PSNRET_INVALID_NOCHANGEPAGE	2
#define PSBTN_APPLYNOW	4
#define PSBTN_BACK	0
#define PSBTN_CANCEL	5
#define PSBTN_FINISH	2
#define PSBTN_HELP	6
#define PSBTN_NEXT	1
#define PSBTN_OK	3
#define PSWIZB_BACK	1
#define PSWIZB_NEXT	2
#define PSWIZB_FINISH	4
#define PSWIZB_DISABLEDFINISH	8
#define ID_PSREBOOTSYSTEM	3
#define ID_PSRESTARTWINDOWS	2
#define WIZ_BODYCX	184
#define WIZ_BODYX	92
#define WIZ_CXBMP	80
#define WIZ_CXDLG	276
#define WIZ_CYDLG	140
#define PAN_ANY	0
#define PAN_NO_FIT	1
#define PAN_FAMILY_TEXT_DISPLAY	2
#define PAN_FAMILY_SCRIPT	3
#define PAN_FAMILY_DECORATIVE	4
#define PAN_FAMILY_PICTORIAL	5
#define PAN_SERIF_COVE	2
#define PAN_SERIF_OBTUSE_COVE	3
#define PAN_SERIF_SQUARE_COVE	4
#define PAN_SERIF_OBTUSE_SQUARE_COVE	5
#define PAN_SERIF_SQUARE	6
#define PAN_SERIF_THIN	7
#define PAN_SERIF_BONE	8
#define PAN_SERIF_EXAGGERATED	9
#define PAN_SERIF_TRIANGLE	10
#define PAN_SERIF_NORMAL_SANS	11
#define PAN_SERIF_OBTUSE_SANS	12
#define PAN_SERIF_PERP_SANS	13
#define PAN_SERIF_FLARED	14
#define PAN_SERIF_ROUNDED	15
#define PAN_WEIGHT_VERY_LIGHT	2
#define PAN_WEIGHT_LIGHT	3
#define PAN_WEIGHT_THIN	4
#define PAN_WEIGHT_BOOK	5
#define PAN_WEIGHT_MEDIUM	6
#define PAN_WEIGHT_DEMI	7
#define PAN_WEIGHT_BOLD	8
#define PAN_WEIGHT_HEAVY	9
#define PAN_WEIGHT_BLACK	10
#define PAN_WEIGHT_NORD	11
#define PAN_PROP_OLD_STYLE	2
#define PAN_PROP_MODERN	3
#define PAN_PROP_EVEN_WIDTH	4
#define PAN_PROP_EXPANDED	5
#define PAN_PROP_CONDENSED	6
#define PAN_PROP_VERY_EXPANDED	7
#define PAN_PROP_VERY_CONDENSED	8
#define PAN_PROP_MONOSPACED	9
#define PAN_CONTRAST_NONE	2
#define PAN_CONTRAST_VERY_LOW	3
#define PAN_CONTRAST_LOW	4
#define PAN_CONTRAST_MEDIUM_LOW	5
#define PAN_CONTRAST_MEDIUM	6
#define PAN_CONTRAST_MEDIUM_HIGH	7
#define PAN_CONTRAST_HIGH	8
#define PAN_CONTRAST_VERY_HIGH	9
#define PAN_STROKE_GRADUAL_DIAG	2
#define PAN_STROKE_GRADUAL_TRAN	3
#define PAN_STROKE_GRADUAL_VERT	4
#define PAN_STROKE_GRADUAL_HORZ	5
#define PAN_STROKE_RAPID_VERT	6
#define PAN_STROKE_RAPID_HORZ	7
#define PAN_STROKE_INSTANT_VERT	8
#define PAN_STRAIGHT_ARMS_HORZ	2
#define PAN_STRAIGHT_ARMS_WEDGE	3
#define PAN_STRAIGHT_ARMS_VERT	4
#define PAN_STRAIGHT_ARMS_SINGLE_SERIF	5
#define PAN_STRAIGHT_ARMS_DOUBLE_SERIF	6
#define PAN_BENT_ARMS_HORZ	7
#define PAN_BENT_ARMS_VERT	9
#define PAN_BENT_ARMS_WEDGE	8
#define PAN_BENT_ARMS_SINGLE_SERIF	10
#define PAN_BENT_ARMS_DOUBLE_SERIF	11
#define PAN_LETT_NORMAL_CONTACT	2
#define PAN_LETT_NORMAL_WEIGHTED	3
#define PAN_LETT_NORMAL_BOXED	4
#define PAN_LETT_NORMAL_FLATTENED	5
#define PAN_LETT_NORMAL_ROUNDED	6
#define PAN_LETT_NORMAL_OFF_CENTER	7
#define PAN_LETT_NORMAL_SQUARE	8
#define PAN_LETT_OBLIQUE_CONTACT	9
#define PAN_LETT_OBLIQUE_WEIGHTED	10
#define PAN_LETT_OBLIQUE_BOXED	11
#define PAN_LETT_OBLIQUE_FLATTENED	12
#define PAN_LETT_OBLIQUE_ROUNDED	13
#define PAN_LETT_OBLIQUE_OFF_CENTER	14
#define PAN_LETT_OBLIQUE_SQUARE	15
#define PAN_MIDLINE_STANDARD_TRIMMED	2
#define PAN_MIDLINE_STANDARD_POINTED	3
#define PAN_MIDLINE_STANDARD_SERIFED	4
#define PAN_MIDLINE_HIGH_TRIMMED	5
#define PAN_MIDLINE_HIGH_POINTED	6
#define PAN_MIDLINE_HIGH_SERIFED	7
#define PAN_MIDLINE_CONSTANT_TRIMMED	8
#define PAN_MIDLINE_CONSTANT_POINTED	9
#define PAN_MIDLINE_CONSTANT_SERIFED	10
#define PAN_MIDLINE_LOW_TRIMMED	11
#define PAN_MIDLINE_LOW_POINTED	12
#define PAN_MIDLINE_LOW_SERIFED	13
#define PAN_XHEIGHT_CONSTANT_SMALL	2
#define PAN_XHEIGHT_CONSTANT_STD	3
#define PAN_XHEIGHT_CONSTANT_LARGE	4
#define PAN_XHEIGHT_DUCKING_SMALL	5
#define PAN_XHEIGHT_DUCKING_STD	6
#define PAN_XHEIGHT_DUCKING_LARGE	7
#define PC_EXPLICIT	2
#define PC_NOCOLLAPSE	4
#define PC_RESERVED	1
#define BS_DIBPATTERN	5
#define BS_DIBPATTERN8X8	8
#define BS_DIBPATTERNPT	6
#define BS_HATCHED	2
#define BS_HOLLOW	1
#define BS_NULL	1
#define BS_PATTERN	3
#define BS_PATTERN8X8	7
#define BS_SOLID	0
#define DM_ORIENTATION	1
#define DM_PAPERSIZE	2
#define DM_PAPERLENGTH	4
#define DM_PAPERWIDTH	8
#define DM_SCALE	16
#define DM_COPIES	256
#define DM_DEFAULTSOURCE	512
#define DM_PRINTQUALITY	0x400
#define DM_COLOR	0x800
#define DM_DUPLEX	4096
#define DM_YRESOLUTION	0x2000
#define DM_TTOPTION	0x4000
#define DM_COLLATE	0x8000
#define DM_FORMNAME	0x10000
#define DM_LOGPIXELS	0x20000
#define DM_ICMMETHOD	0x800000
#define DM_ICMINTENT	0x1000000
#define DM_MEDIATYPE	0x2000000
#define DM_DITHERTYPE	0x4000000
#define DMORIENT_LANDSCAPE	2
#define DMORIENT_PORTRAIT	1
#define DMPAPER_FIRST	1
#define DMPAPER_LETTER	1
#define DMPAPER_LEGAL	5
#define DMPAPER_A4	9
#define DMPAPER_CSHEET	24
#define DMPAPER_DSHEET	25
#define DMPAPER_ESHEET	26
#define DMPAPER_LETTERSMALL	2
#define DMPAPER_TABLOID	3
#define DMPAPER_LEDGER	4
#define DMPAPER_STATEMENT	6
#define DMPAPER_EXECUTIVE	7
#define DMPAPER_A3	8
#define DMPAPER_A4SMALL	10
#define DMPAPER_A5	11
#define DMPAPER_B4	12
#define DMPAPER_B5	13
#define DMPAPER_FOLIO	14
#define DMPAPER_QUARTO	15
#define DMPAPER_10X14	16
#define DMPAPER_11X17	17
#define DMPAPER_NOTE	18
#define DMPAPER_ENV_9	19
#define DMPAPER_ENV_10	20
#define DMPAPER_ENV_11	21
#define DMPAPER_ENV_12	22
#define DMPAPER_ENV_14	23
#define DMPAPER_ENV_DL	27
#define DMPAPER_ENV_C5	28
#define DMPAPER_ENV_C3	29
#define DMPAPER_ENV_C4	30
#define DMPAPER_ENV_C6	31
#define DMPAPER_ENV_C65	32
#define DMPAPER_ENV_B4	33
#define DMPAPER_ENV_B5	34
#define DMPAPER_ENV_B6	35
#define DMPAPER_ENV_ITALY	36
#define DMPAPER_ENV_MONARCH	37
#define DMPAPER_ENV_PERSONAL	38
#define DMPAPER_FANFOLD_US	39
#define DMPAPER_FANFOLD_STD_GERMAN	40
#define DMPAPER_FANFOLD_LGL_GERMAN	41
#define DMPAPER_ISO_B4	42
#define DMPAPER_JAPANESE_POSTCARD	43
#define DMPAPER_9X11	44
#define DMPAPER_10X11	45
#define DMPAPER_15X11	46
#define DMPAPER_ENV_INVITE	47
#define DMPAPER_RESERVED_48	48
#define DMPAPER_RESERVED_49	49
#define DMPAPER_LETTER_EXTRA	50
#define DMPAPER_LEGAL_EXTRA	51
#define DMPAPER_TABLOID_EXTRA	52
#define DMPAPER_A4_EXTRA	53
#define DMPAPER_LETTER_TRANSVERSE	54
#define DMPAPER_A4_TRANSVERSE	55
#define DMPAPER_LETTER_EXTRA_TRANSVERSE	56
#define DMPAPER_A_PLUS	57
#define DMPAPER_B_PLUS	58
#define DMPAPER_LETTER_PLUS	59
#define DMPAPER_A4_PLUS	60
#define DMPAPER_A5_TRANSVERSE	61
#define DMPAPER_B5_TRANSVERSE	62
#define DMPAPER_A3_EXTRA	63
#define DMPAPER_A5_EXTRA	64
#define DMPAPER_B5_EXTRA	65
#define DMPAPER_A2	66
#define DMPAPER_A3_TRANSVERSE	67
#define DMPAPER_A3_EXTRA_TRANSVERSE	68
#define DMPAPER_DBL_JAPANESE_POSTCARD 69
#define DMPAPER_A6 70
#define DMPAPER_JENV_KAKU2 71
#define DMPAPER_JENV_KAKU3 72
#define DMPAPER_JENV_CHOU3 73
#define DMPAPER_JENV_CHOU4 74
#define DMPAPER_LETTER_ROTATED 75
#define DMPAPER_A3_ROTATED 76
#define DMPAPER_A4_ROTATED 77
#define DMPAPER_A5_ROTATED 78
#define DMPAPER_B4_JIS_ROTATED 79
#define DMPAPER_B5_JIS_ROTATED 80
#define DMPAPER_JAPANESE_POSTCARD_ROTATED 81
#define DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED 82
#define DMPAPER_A6_ROTATED 83
#define DMPAPER_JENV_KAKU2_ROTATED 84
#define DMPAPER_JENV_KAKU3_ROTATED 85
#define DMPAPER_JENV_CHOU3_ROTATED 86
#define DMPAPER_JENV_CHOU4_ROTATED 87
#define DMPAPER_B6_JIS 88
#define DMPAPER_B6_JIS_ROTATED 89
#define DMPAPER_12X11 90
#define DMPAPER_JENV_YOU4 91
#define DMPAPER_JENV_YOU4_ROTATED 92
#define DMPAPER_P16K 93
#define DMPAPER_P32K 94
#define DMPAPER_P32KBIG 95
#define DMPAPER_PENV_1 96
#define DMPAPER_PENV_2 97
#define DMPAPER_PENV_3 98
#define DMPAPER_PENV_4 99
#define DMPAPER_PENV_5 100
#define DMPAPER_PENV_6 101
#define DMPAPER_PENV_7 102
#define DMPAPER_PENV_8 103
#define DMPAPER_PENV_9 104
#define DMPAPER_PENV_10 105
#define DMPAPER_P16K_ROTATED 106
#define DMPAPER_P32K_ROTATED 107
#define DMPAPER_P32KBIG_ROTATED 108
#define DMPAPER_PENV_1_ROTATED 109
#define DMPAPER_PENV_2_ROTATED 110
#define DMPAPER_PENV_3_ROTATED 111
#define DMPAPER_PENV_4_ROTATED 112
#define DMPAPER_PENV_5_ROTATED 113
#define DMPAPER_PENV_6_ROTATED 114
#define DMPAPER_PENV_7_ROTATED 115
#define DMPAPER_PENV_8_ROTATED 116
#define DMPAPER_PENV_9_ROTATED 117
#define DMPAPER_PENV_10_ROTATED 118
#define DMPAPER_LAST 118
#define DMPAPER_USER 256
#define DMBIN_FIRST	1
#define DMBIN_UPPER	1
#define DMBIN_ONLYONE	1
#define DMBIN_LOWER	2
#define DMBIN_MIDDLE	3
#define DMBIN_MANUAL	4
#define DMBIN_ENVELOPE	5
#define DMBIN_ENVMANUAL	6
#define DMBIN_AUTO	7
#define DMBIN_TRACTOR	8
#define DMBIN_SMALLFMT	9
#define DMBIN_LARGEFMT	10
#define DMBIN_LARGECAPACITY	11
#define DMBIN_CASSETTE	14
#define DMBIN_FORMSOURCE	15
#define DMBIN_LAST	15
#define DMBIN_USER	256
#define DMRES_HIGH	(-4)
#define DMRES_MEDIUM	(-3)
#define DMRES_LOW	(-2)
#define DMRES_DRAFT	(-1)
#define DMCOLOR_COLOR	2
#define DMCOLOR_MONOCHROME	1
#define DMDUP_SIMPLEX	1
#define DMDUP_HORIZONTAL	3
#define DMDUP_VERTICAL	2
#define DMTT_BITMAP	1
#define DMTT_DOWNLOAD	2
#define DMTT_SUBDEV	3
#define DMCOLLATE_TRUE	1
#define DMCOLLATE_FALSE	0
#define DM_GRAYSCALE	1
#define DM_INTERLACED	2
#define DMICMMETHOD_NONE	1
#define DMICMMETHOD_SYSTEM	2
#define DMICMMETHOD_DRIVER	3
#define DMICMMETHOD_DEVICE	4
#define DMICMMETHOD_USER	256
#define DMICM_SATURATE	1
#define DMICM_CONTRAST	2
#define DMICM_COLORMETRIC	3
#define DMICM_USER	256
#define DMMEDIA_STANDARD	1
#define DMMEDIA_GLOSSY	3
#define DMMEDIA_TRANSPARENCY	2
#define DMMEDIA_USER	256
#define DMDITHER_NONE	1
#define DMDITHER_COARSE	2
#define DMDITHER_FINE	3
#define DMDITHER_LINEART	4
#define DMDITHER_GRAYSCALE	10
#define DMDITHER_USER	256
#define DISPLAY_DEVICE_ATTACHED_TO_DESKTOP 1
#define DISPLAY_DEVICE_MULTI_DRIVER	2
#define DISPLAY_DEVICE_PRIMARY_DEVICE	4
#define DISPLAY_DEVICE_MIRRORING_DRIVER 8
#define DISPLAY_DEVICE_VGA_COMPATIBLE	0x10
#define DISPLAY_DEVICE_REMOVABLE	0x20
#define DISPLAY_DEVICE_MODESPRUNED	0x08000000
#define DISPLAY_DEVICE_REMOTE	0x04000000
#define DISPLAY_DEVICE_DISCONNECT 0x02000000
#define RDH_RECTANGLES	1
#define TT_POLYGON_TYPE	24
#define TT_PRIM_LINE	1
#define TT_PRIM_QSPLINE	2
#define GCPCLASS_ARABIC	2
#define GCPCLASS_HEBREW	2
#define GCPCLASS_LATIN	1
#define GCPCLASS_LATINNUMBER	5
#define GCPCLASS_LOCALNUMBER	4
#define GCPCLASS_LATINNUMERICSEPARATOR	7
#define GCPCLASS_LATINNUMERICTERMINATOR	6
#define GCPCLASS_NEUTRAL	3
#define GCPCLASS_NUMERICSEPARATOR	8
#define GCPCLASS_PREBOUNDLTR	128
#define GCPCLASS_PREBOUNDRTL	64
#define GCPCLASS_POSTBOUNDLTR	32
#define GCPCLASS_POSTBOUNDRTL	16
#define GCPGLYPH_LINKBEFORE	32768
#define GCPGLYPH_LINKAFTER	16384
#define TT_AVAILABLE	1
#define TT_ENABLED	2
#define CA_NEGATIVE	1
#define CA_LOG_FILTER	2
#define ILLUMINANT_DEVICE_DEFAULT	0
#define ILLUMINANT_A	1
#define ILLUMINANT_B	2
#define ILLUMINANT_C	3
#define ILLUMINANT_D50	4
#define ILLUMINANT_D55	5
#define ILLUMINANT_D65	6
#define ILLUMINANT_D75	7
#define ILLUMINANT_F2	8
#define ILLUMINANT_TUNGSTEN	1
#define ILLUMINANT_DAYLIGHT	3
#define ILLUMINANT_FLUORESCENT	8
#define ILLUMINANT_NTSC	3
#define ILLUMINANT_MAX_INDEX	ILLUMINANT_F2
#define REFERENCE_WHITE_MIN	(WORD)6000
#define REFERENCE_WHITE_MAX	(WORD)10000
#define REFERENCE_BLACK_MIN	(WORD)0
#define REFERENCE_BLACK_MAX	(WORD)4000
#define DI_APPBANDING	1
#define EMR_HEADER	1
#define EMR_POLYBEZIER	2
#define EMR_POLYGON	3
#define EMR_POLYLINE	4
#define EMR_POLYBEZIERTO	5
#define EMR_POLYLINETO	6
#define EMR_POLYPOLYLINE	7
#define EMR_POLYPOLYGON	8
#define EMR_SETWINDOWEXTEX	9
#define EMR_SETWINDOWORGEX	10
#define EMR_SETVIEWPORTEXTEX	11
#define EMR_SETVIEWPORTORGEX	12
#define EMR_SETBRUSHORGEX	13
#define EMR_EOF	14
#define EMR_SETPIXELV	15
#define EMR_SETMAPPERFLAGS	16
#define EMR_SETMAPMODE	17
#define EMR_SETBKMODE	18
#define EMR_SETPOLYFILLMODE	19
#define EMR_SETROP2	20
#define EMR_SETSTRETCHBLTMODE	21
#define EMR_SETTEXTALIGN	22
#define EMR_SETCOLORADJUSTMENT	23
#define EMR_SETTEXTCOLOR	24
#define EMR_SETBKCOLOR	25
#define EMR_OFFSETCLIPRGN	26
#define EMR_MOVETOEX	27
#define EMR_SETMETARGN	28
#define EMR_EXCLUDECLIPRECT	29
#define EMR_INTERSECTCLIPRECT	30
#define EMR_SCALEVIEWPORTEXTEX	31
#define EMR_SCALEWINDOWEXTEX	32
#define EMR_SAVEDC	33
#define EMR_RESTOREDC	34
#define EMR_SETWORLDTRANSFORM	35
#define EMR_MODIFYWORLDTRANSFORM	36
#define EMR_SELECTOBJECT	37
#define EMR_CREATEPEN	38
#define EMR_CREATEBRUSHINDIRECT	39
#define EMR_DELETEOBJECT	40
#define EMR_ANGLEARC	41
#define EMR_ELLIPSE	42
#define EMR_RECTANGLE	43
#define EMR_ROUNDRECT	44
#define EMR_ARC	45
#define EMR_CHORD	46
#define EMR_PIE	47
#define EMR_SELECTPALETTE	48
#define EMR_CREATEPALETTE	49
#define EMR_SETPALETTEENTRIES	50
#define EMR_RESIZEPALETTE	51
#define EMR_REALIZEPALETTE	52
#define EMR_EXTFLOODFILL	53
#define EMR_LINETO	54
#define EMR_ARCTO	55
#define EMR_POLYDRAW	56
#define EMR_SETARCDIRECTION	57
#define EMR_SETMITERLIMIT	58
#define EMR_BEGINPATH	59
#define EMR_ENDPATH	60
#define EMR_CLOSEFIGURE	61
#define EMR_FILLPATH	62
#define EMR_STROKEANDFILLPATH	63
#define EMR_STROKEPATH	64
#define EMR_FLATTENPATH	65
#define EMR_WIDENPATH	66
#define EMR_SELECTCLIPPATH	67
#define EMR_ABORTPATH	68
#define EMR_GDICOMMENT	70
#define EMR_FILLRGN	71
#define EMR_FRAMERGN	72
#define EMR_INVERTRGN	73
#define EMR_PAINTRGN	74
#define EMR_EXTSELECTCLIPRGN	75
#define EMR_BITBLT	76
#define EMR_STRETCHBLT	77
#define EMR_MASKBLT	78
#define EMR_PLGBLT	79
#define EMR_SETDIBITSTODEVICE	80
#define EMR_STRETCHDIBITS	81
#define EMR_EXTCREATEFONTINDIRECTW	82
#define EMR_EXTTEXTOUTA	83
#define EMR_EXTTEXTOUTW	84
#define EMR_POLYBEZIER16	85
#define EMR_POLYGON16	86
#define EMR_POLYLINE16	87
#define EMR_POLYBEZIERTO16	88
#define EMR_POLYLINETO16	89
#define EMR_POLYPOLYLINE16	90
#define EMR_POLYPOLYGON16	91
#define EMR_POLYDRAW16	92
#define EMR_CREATEMONOBRUSH	93
#define EMR_CREATEDIBPATTERNBRUSHPT	94
#define EMR_EXTCREATEPEN	95
#define EMR_POLYTEXTOUTA	96
#define EMR_POLYTEXTOUTW	97
#define EMR_SETICMMODE	98
#define EMR_CREATECOLORSPACE	99
#define EMR_SETCOLORSPACE	100
#define EMR_DELETECOLORSPACE	101
#define EMR_GLSRECORD	102
#define EMR_GLSBOUNDEDRECORD	103
#define EMR_PIXELFORMAT	104
#define EMR_RESERVED_105 105
#define EMR_RESERVED_106 106
#define EMR_RESERVED_107 107
#define EMR_RESERVED_108 108
#define EMR_RESERVED_109 109
#define EMR_RESERVED_110 110
#define EMR_COLORCORRECTPALETTE 111
#define EMR_SETICMPROFILEA 112
#define EMR_SETICMPROFILEW 113
#define EMR_ALPHABLEND 114
#define EMR_SETLAYOUT 115
#define EMR_TRANSPARENTBLT 116
#define EMR_RESERVED_117 117
#define EMR_GRADIENTFILL 118
#define EMR_RESERVED_119 119
#define EMR_RESERVED_120 120
#define EMR_COLORMATCHTOTARGETW 121
#define EMR_CREATECOLORSPACEW 122
#define ENHMETA_SIGNATURE	1179469088
#define ENM_NONE	0
#define ENM_CHANGE	1
#define ENM_UPDATE	2
#define ENM_SCROLL	4
#define ENM_KEYEVENTS 0x10000
#define ENM_MOUSEEVENTS 0x20000
#define ENM_REQUESTRESIZE 0x40000
#define ENM_SELCHANGE 0x80000
#define ENM_DROPFILES 0x100000
#define ENM_PROTECTED 0x200000
#define ENM_CORRECTTEXT 0x400000
#define ENM_SCROLLEVENTS	8
#define ENM_DRAGDROPDONE	16
#define ENM_PARAGRAPHEXPANDED	32
#define ENM_IMECHANGE	0x800000
#define ENM_LANGCHANGE	0x1000000
#define ENM_OBJECTPOSITIONS	0x2000000
#define ES_DISABLENOSCROLL	0x2000

//#if (WINVER > 1024)
#define ES_EX_NOCALLOLEINIT 0
//#else
//#define ES_EX_NOCALLOLEINIT 16777216
//#endif
#define ES_NOIME	0x80000
#define ES_SAVESEL	0x8000
#define ES_SELFIME	0x40000
#define ES_SUNKEN	0x4000
#define ES_VERTICAL	0x400000
#define ES_SELECTIONBAR	0x1000000
#define ECOOP_SET	1
#define ECOOP_OR	2
#define ECOOP_AND	3
#define ECOOP_XOR	4
#define ECO_AUTOWORDSELECTION	1
#define ECO_AUTOVSCROLL	64
#define ECO_AUTOHSCROLL	128
#define ECO_NOHIDESEL	256
#define ECO_READONLY	2048
#define ECO_WANTRETURN	4096
#define ECO_SAVESEL	0x8000
#define ECO_SELECTIONBAR	0x1000000
#define ECO_VERTICAL	0x400000
#define SCF_WORD	2
#define SCF_SELECTION	1
#define SF_TEXT	1
#define SF_RTF	2
#define SF_RTFNOOBJS	3
#define SF_TEXTIZED	4
#define SFF_SELECTION	0x8000
#define SFF_PLAINRTF	0x4000
#define WB_CLASSIFY	3
#define WB_ISDELIMITER	2
#define WB_LEFT	0
#define WB_LEFTBREAK	6
#define WB_PREVBREAK	6
#define WB_MOVEWORDLEFT	4
#define WB_MOVEWORDPREV	4
#define WB_MOVEWORDRIGHT	5
#define WB_MOVEWORDNEXT	5
#define WB_RIGHT	1
#define WB_RIGHTBREAK	7
#define WB_NEXTBREAK	7
#define PC_LEADING	2
#define PC_FOLLOWING	1
#define PC_DELIMITER	4
#define PC_OVERFLOW	3
#define WBF_WORDWRAP	16
#define WBF_WORDBREAK	32
#define WBF_OVERFLOW	64
#define WBF_LEVEL1	128
#define WBF_LEVEL2	256
#define WBF_CUSTOM	512
#define WBF_BREAKAFTER	64
#define WBF_BREAKLINE	32
#define WBF_ISWHITE	16
#define CFM_BOLD	1
#define CFM_COLOR	0x40000000
#define CFM_FACE	0x20000000
#define CFM_ITALIC	2
#define CFM_OFFSET	0x10000000
#define CFM_PROTECTED	16
#define CFM_SIZE	0x80000000
#define CFM_STRIKEOUT	8
#define CFM_UNDERLINE	4
#define CFE_AUTOCOLOR	0x40000000
#define CFE_BOLD	1
#define CFE_ITALIC	2
#define CFE_STRIKEOUT	8
#define CFE_UNDERLINE	4
#define CFE_PROTECTED	16
#define PFM_ALIGNMENT	8
#define PFM_NUMBERING	32
#define PFM_OFFSET	4
#define PFM_OFFSETINDENT	0x80000000
#define PFM_RIGHTINDENT	2
#define PFM_STARTINDENT	1
#define PFM_TABSTOPS	16
#define PFN_BULLET	1
#define PFA_LEFT	1
#define PFA_RIGHT	2
#define PFA_CENTER	3
#define SEL_EMPTY	0
#define SEL_TEXT	1
#define SEL_OBJECT	2
#define SEL_MULTICHAR	4
#define SEL_MULTIOBJECT	8
#define CF_RTF	TEXT("Rich Text Format")
#define CF_RETEXTOBJ	TEXT("RichEdit Text and Objects")
#define ODT_BUTTON	4
#define ODT_COMBOBOX	3
#define ODT_LISTBOX	2
#define ODT_LISTVIEW	102
#define ODT_MENU	1
#define ODT_STATIC	5
#define ODT_TAB	101
#define ODT_HEADER	100
#define ODA_DRAWENTIRE	1
#define ODA_FOCUS	4
#define ODA_SELECT	2
#define ODS_CHECKED	8
#define ODS_COMBOBOXEDIT	4096
#define ODS_DEFAULT	32
#define ODS_DISABLED	4
#define ODS_FOCUS	16
#define ODS_GRAYED	2
#define ODS_SELECTED	1
#define ANIMATE_CLASSW	L"SysAnimate32"
#define HOTKEY_CLASSW	L"msctls_hotkey32"
#define PROGRESS_CLASSW	L"msctls_progress32"
#define STATUSCLASSNAMEW	L"msctls_statusbar32"
#define REBARCLASSNAMEW		L"ReBarWindow32"
#define TOOLBARCLASSNAMEW	L"ToolbarWindow32"
#define TOOLTIPS_CLASSW	L"tooltips_class32"
#define TRACKBAR_CLASSW	L"msctls_trackbar32"
#define UPDOWN_CLASSW	L"msctls_updown32"
#define WC_HEADERW	L"SysHeader32"
#define WC_LISTVIEWW	L"SysListView32"
#define WC_TABCONTROLW	L"SysTabControl32"
#define WC_TREEVIEWW	L"SysTreeView32"
#define WC_PAGESCROLLERW	L"SysPager"
#define WC_PAGESCROLLERA	"SysPager"
#define DATETIMEPICK_CLASSW	L"SysDateTimePick32"
#define DATETIMEPICK_CLASSA	"SysDateTimePick32"
#define CCS_ADJUSTABLE	32
#define CCS_BOTTOM	3
#define CCS_NODIVIDER	64
#define CCS_NOMOVEY	2
#define CCS_NOPARENTALIGN	8
#define CCS_NORESIZE	4
#define CCS_TOP	1
#define CCS_VERT 0x80
#define CCS_LEFT 0x81
#define CCS_RIGHT	(CCS_VERT|CCS_BOTTOM)
#define CCS_NOMOVEX	(CCS_VERT|CCS_NOMOVEY)
#define RICHEDIT_CLASSA         "RichEdit20A"
#define RICHEDIT_CLASS10A   "RICHEDIT"

//#ifndef _RICHEDIT_VER
#define _RICHEDIT_VER  0x0210
//#endif

#define RICHEDIT_CLASSA      "RichEdit20A"
#define RICHEDIT_CLASS10A     "RICHEDIT"
#define RICHEDIT_CLASSW      L"RichEdit20W"
//#if (_RICHEDIT_VER >= 0x0200 )

#ifdef UNICODE
	#define RICHEDIT_CLASS       RICHEDIT_CLASSW
#else
	#define RICHEDIT_CLASS       RICHEDIT_CLASSA
#endif
//#else
//#define RICHEDIT_CLASS       RICHEDIT_CLASS10A
//#endif /* _RICHEDIT_VER >= 0x0200 */

#define ANIMATE_CLASSA	"SysAnimate32"
#define HOTKEY_CLASSA	"msctls_hotkey32"
#define PROGRESS_CLASSA	"msctls_progress32"
#define STATUSCLASSNAMEA	"msctls_statusbar32"
#define REBARCLASSNAMEA	"ReBarWindow32"
#define TOOLBARCLASSNAMEA	"ToolbarWindow32"
#define TOOLTIPS_CLASSA	"tooltips_class32"
#define TRACKBAR_CLASSA	"msctls_trackbar32"
#define UPDOWN_CLASSA	"msctls_updown32"
#define WC_HEADERA	"SysHeader32"
#define WC_LISTVIEWA	"SysListView32"
#define WC_TABCONTROLA	"SysTabControl32"
#define WC_TREEVIEWA	"SysTreeView32"
#define HDS_BUTTONS	2
#define HDS_HIDDEN	8
#define HDS_HOTTRACK	4
#define HDS_DRAGDROP	0x40
#define HDS_FULLDRAG	0x80
#define HDS_FILTERBAR	0x100
#define HDS_HORZ	0
#define HDS_FLAT	0x0200
#define HDFT_ISSTRING	0
#define HDFT_ISNUMBER	1
#define HDFT_HASNOVALUE 0x8000
#define HDI_BITMAP	16
#define HDI_FORMAT	4
#define HDI_HEIGHT	1
#define HDI_LPARAM	8
#define HDI_TEXT	2
#define HDI_WIDTH	1
#define HDI_IMAGE	0x20
#define HDI_DI_SETITEM	0x40
#define HDI_ORDER	0x80
#define HDI_FILTER	0x100
#define HDF_CENTER	2
#define HDF_LEFT	0
#define HDF_RIGHT	1
#define HDF_RTLREADING	4
#define HDF_BITMAP	8192
#define HDF_OWNERDRAW	32768
#define HDF_STRING	16384
#define HDF_BITMAP_ON_RIGHT 0x1000
#define HDF_IMAGE	0x800
#define HDF_SORTUP	0x0400
#define HDF_SORTDOWN	0x0200
#define HDF_JUSTIFYMASK	3
#define HHT_NOWHERE	1
#define HHT_ONDIVIDER	4
#define HHT_ONDIVOPEN	8
#define HHT_ONHEADER	2
#define HHT_TOLEFT	2048
#define HHT_TORIGHT	1024
#define HHT_ONFILTER	0x0010
#define HHT_ONFILTERBUTTON 0x0020
#define HHT_ABOVE	0x0100
#define HHT_BELOW	0x0200
#define HINST_COMMCTRL	((HANDLE)-1)
#define IDB_STD_LARGE_COLOR	1
#define IDB_STD_SMALL_COLOR	0
#define IDB_VIEW_LARGE_COLOR	5
#define IDB_VIEW_SMALL_COLOR	4
#define IDB_HIST_SMALL_COLOR	8
#define IDB_HIST_LARGE_COLOR	9
#define STD_COPY	1
#define STD_CUT	0
#define STD_DELETE	5
#define STD_FILENEW	6
#define STD_FILEOPEN	7
#define STD_FILESAVE	8
#define STD_FIND	12
#define STD_HELP	11
#define STD_PASTE	2
#define STD_PRINT	14
#define STD_PRINTPRE	9
#define STD_PROPERTIES	10
#define STD_REDOW	4
#define STD_REPLACE	13
#define STD_UNDO	3
#define VIEW_LARGEICONS	0
#define VIEW_SMALLICONS	1
#define VIEW_LIST	2
#define VIEW_DETAILS	3
#define VIEW_SORTNAME	4
#define VIEW_SORTSIZE	5
#define VIEW_SORTDATE	6
#define VIEW_SORTTYPE	7
#define VIEW_PARENTFOLDER	8
#define VIEW_NETCONNECT	9
#define VIEW_NETDISCONNECT	10
#define VIEW_NEWFOLDER	11
#define VIEW_VIEWMENU	12
#define HIST_BACK	0
#define HIST_FORWARD	1
#define HIST_FAVORITES	2
#define HIST_ADDTOFAVORITES	3
#define HIST_VIEWTREE	4
#define TBSTYLE_FLAT	2048
#define TBSTYLE_ALTDRAG	1024
#define TBSTYLE_TOOLTIPS	256
#define TBSTYLE_WRAPABLE	512
#define TBSTYLE_BUTTON	0
#define TBSTYLE_CHECK	2
#define TBSTYLE_CHECKGROUP	6
#define TBSTYLE_GROUP	4
#define TBSTYLE_SEP	1
#define TBSTYLE_DROPDOWN	8
#define TBSTYLE_AUTOSIZE	16
#define TBSTYLE_NOPREFIX	32
#define TBSTYLE_LIST	0x1000
#define TBSTYLE_CUSTOMERASE	0x2000
#define TBSTYLE_REGISTERDROP	0x4000
#define TBSTYLE_TRANSPARENT	0x8000
#define TBSTYLE_EX_DRAWDDARROWS	1
#define TBSTYLE_EX_MIXEDBUTTONS	0x8
#define TBSTYLE_EX_HIDECLIPPEDBUTTONS	0x10
#define TBSTYLE_EX_DOUBLEBUFFER 0x80
#define TBCDRF_NOEDGES	0x00010000
#define TBCDRF_HILITEHOTTRACK	0x00020000
#define TBCDRF_NOOFFSET	0x040000
#define TBCDRF_NOMARK	0x00080000
#define TBCDRF_NOETCHEDEFFECT	0x00100000
#define TBCDRF_BLENDICON	0x00200000
#define TBCDRF_NOBACKGROUND	0x00400000
#define BTNS_BUTTON	TBSTYLE_BUTTON
#define BTNS_SEP	TBSTYLE_SEP
#define BTNS_CHECK	TBSTYLE_CHECK
#define BTNS_GROUP	TBSTYLE_GROUP
#define BTNS_CHECKGROUP TBSTYLE_CHECKGROUP
#define BTNS_DROPDOWN	TBSTYLE_DROPDOWN
#define BTNS_AUTOSIZE	TBSTYLE_AUTOSIZE
#define BTNS_NOPREFIX	TBSTYLE_NOPREFIX
#define BTNS_SHOWTEXT	0x0040
#define BTNS_WHOLEDROPDOWN	0x0080
#define TBSTATE_CHECKED	1
#define TBSTATE_ENABLED	4
#define TBSTATE_HIDDEN	8
#define TBSTATE_INDETERMINATE	16
#define TBSTATE_PRESSED	2
#define TBSTATE_WRAP	32
#define TBSTATE_ELLIPSES	0x40
#define TBSTATE_MARKED	0x80
#define TBIMHT_AFTER	1
#define TBIMHT_BACKGROUND	2
#define TTS_ALWAYSTIP	1
#define TTS_NOPREFIX	2
#define TTS_NOANIMATE	0x10
#define TTS_NOFADE	0x20
#define TTS_BALLOON	0x40
#define TTS_CLOSE	0x80
#define TTF_IDISHWND	1
#define TTF_CENTERTIP	2
#define TTF_RTLREADING	4
#define TTF_SUBCLASS	16
#define TTF_TRACK	0x0020
#define TTF_ABSOLUTE	0x0080
#define TTF_PARSELINKS	0x1000
#define TTF_DI_SETITEM	0x8000
#define TTI_NONE	0
#define TTI_INFO	1
#define TTI_WARNING	2
#define TTI_ERROR	3
#define TTM_GETBUBBLESIZE	(WM_USER + 30)
#define TTM_POPUP	(WM_USER + 34)
#define TTM_GETTITLE	(WM_USER + 35)
#define TTDT_AUTOMATIC	0
#define TTDT_AUTOPOP	2
#define TTDT_INITIAL	3
#define TTDT_RESHOW	1
#define SBARS_SIZEGRIP	256
#define SBARS_SIZEGRIP	256
#define RBS_TOOLTIPS	0x0100
#define RBS_VARHEIGHT	0x0200
#define RBS_BANDBORDERS	0x0400
#define RBS_FIXEDORDER	0x0800
#define RBS_REGISTERDROP	0x1000
#define RBS_AUTOSIZE	0x2000
#define RBS_VERTICALGRIPPER 0x4000
#define RBS_DBLCLKTOGGLE	0x8000
#define RBIM_IMAGELIST	1
#define RB_INSERTBANDA	(WM_USER+1)
#define RB_DELETEBAND	(WM_USER+2)
#define RB_GETBARINFO	(WM_USER+3)
#define RB_SETBARINFO	(WM_USER+4)
#define RB_GETBANDINFO	(WM_USER+5)
#define RB_SETBANDINFOA	(WM_USER+6)
#define RB_SETPARENT	(WM_USER+7)
#define RB_HITTEST	(WM_USER+8)
#define RB_GETRECT	(WM_USER+9)
#define RB_INSERTBANDW	(WM_USER+10)
#define RB_SETBANDINFOW	(WM_USER+11)
#define RB_GETBANDCOUNT (WM_USER+12)
#define RB_GETROWCOUNT	(WM_USER+13)
#define RB_GETROWHEIGHT	(WM_USER+14)
#define RB_IDTOINDEX (WM_USER+16)
#define RB_GETTOOLTIPS (WM_USER+17)
#define RB_SETTOOLTIPS (WM_USER+18)
#define RB_SETBKCOLOR (WM_USER+19)
#define RB_GETBKCOLOR (WM_USER+20)
#define RB_SETTEXTCOLOR (WM_USER+21)
#define RB_GETTEXTCOLOR (WM_USER+22)
#define RB_SIZETORECT (WM_USER+23)
#define RB_BEGINDRAG	(WM_USER+24)
#define RB_ENDDRAG	(WM_USER+25)
#define RB_DRAGMOVE	(WM_USER+26)
#define RB_GETBARHEIGHT	(WM_USER+27)
#define RB_GETBANDINFOW (WM_USER+28)
#define RB_GETBANDINFOA (WM_USER+29)
#define RB_MINIMIZEBAND (WM_USER+30)
#define RB_MAXIMIZEBAND (WM_USER+31)
#define RB_GETBANDBORDERS (WM_USER+34)
#define RB_SHOWBAND	(WM_USER+35)
#define RB_SETPALETTE	(WM_USER+37)
#define RB_GETPALETTE	(WM_USER+38)
#define RB_SETCOLORSCHEME CCM_SETCOLORSCHEME
#define RB_GETCOLORSCHEME CCM_GETCOLORSCHEME
#define RB_GETDROPTARGET (CCM_GETDROPTARGET)
#define RB_SETUNICODEFORMAT CCM_SETUNICODEFORMAT
#define RB_GETUNICODEFORMAT CCM_GETUNICODEFORMAT
#define RB_GETBANDMARGINS	(WM_USER + 40)
#define RB_SETWINDOWTHEME	CCM_SETWINDOWTHEME
#define RB_PUSHCHEVRON	(WM_USER + 43)
#define RB_MOVEBAND	(WM_USER + 39)
#define RBBIM_STYLE	1
#define RBBIM_COLORS	2
#define RBBIM_TEXT	4
#define RBBIM_IMAGE	8
#define RBBIM_CHILD	16
#define RBBIM_CHILDSIZE	32
#define RBBIM_SIZE	64
#define RBBIM_BACKGROUND	0x80
#define RBBIM_ID	0x100
#define RBBIM_IDEALSIZE	0x200
#define RBBIM_LPARAM	0x400
#define RBBIM_HEADERSIZE	0x800
#define RBBS_BREAK	1
#define RBBS_FIXEDSIZE	2
#define RBBS_CHILDEDGE	4
#define RBBS_HIDDEN	8
#define RBBS_NOVERT	16
#define RBBS_FIXEDBMP	32
#define RBBS_VARIABLEHEIGHT	0x40
#define RBBS_GRIPPERALWAYS	0x80
#define RBBS_NOGRIPPER	0x100
#define RBBS_USECHEVRON	0x200
#define RBBS_HIDETITLE	0x400
#define RBBS_TOPALIGN	0x0800
#define RBHT_NOWHERE	1
#define RBHT_CAPTION	2
#define RBHT_CLIENT	3
#define RBHT_GRABBER	4
#define RBHT_CHEVRON	8
#define RB_INSERTBANDA	(WM_USER+1)
#define RB_DELETEBAND	(WM_USER+2)
#define RB_GETBARINFO	(WM_USER+3)
#define RB_SETBARINFO	(WM_USER+4)
#define RB_GETBANDINFO	(WM_USER+5)
#define RB_SETBANDINFOA	(WM_USER+6)
#define RB_SETPARENT	(WM_USER+7)
#define RB_HITTEST (WM_USER+8)
#define RB_GETRECT (WM_USER+9)
#define RB_INSERTBANDW (WM_USER+10)
#define RB_SETBANDINFOW (WM_USER+11)
#define RB_GETBANDCOUNT (WM_USER+12)
#define RB_GETROWCOUNT (WM_USER+13)
#define RB_GETROWHEIGHT (WM_USER+14)
#define RB_IDTOINDEX (WM_USER+16)
#define RB_GETTOOLTIPS (WM_USER+17)
#define RB_SETTOOLTIPS (WM_USER+18)
#define RB_SETBKCOLOR (WM_USER+19)
#define RB_GETBKCOLOR (WM_USER+20)
#define RB_SETTEXTCOLOR (WM_USER+21)
#define RB_GETTEXTCOLOR (WM_USER+22)
#define RB_SIZETORECT (WM_USER+23)
#define DL_MOVECURSOR	3
#define DL_COPYCURSOR	2
#define DL_STOPCURSOR	1
#define UDS_ALIGNLEFT	8
#define UDS_ALIGNRIGHT	4
#define UDS_ARROWKEYS	32
#define UDS_AUTOBUDDY	16
#define UDS_HORZ	64
#define UDS_NOTHOUSANDS	128
#define UDS_HOTTRACK	256
#define UDS_SETBUDDYINT	2
#define UDS_WRAP	1
#define PBS_SMOOTH 1
#define PBS_VERTICAL 4
#define UD_MAXVAL	32767
#define UD_MINVAL	(-32767)
#define HOTKEYF_ALT	4
#define HOTKEYF_CONTROL	2
#define HOTKEYF_EXT	8
#define HOTKEYF_SHIFT	1
#define HKCOMB_A	8
#define HKCOMB_C	4
#define HKCOMB_CA	64
#define HKCOMB_NONE	1
#define HKCOMB_S	2
#define HKCOMB_SA	32
#define HKCOMB_SC	16
#define HKCOMB_SCA	128
#define CBES_EX_NOEDITIMAGE	1
#define CBES_EX_NOEDITIMAGEINDENT	2
#define CBES_EX_PATHWORDBREAKPROC	4
#define CBES_EX_NOSIZELIMIT	8
#define CBES_EX_CASESENSITIVE	0x10
#define TBS_HORZ	0
#define TBS_VERT	2
#define TBS_AUTOTICKS	1
#define TBS_NOTICKS	16
#define TBS_TOP	4
#define TBS_BOTTOM	0
#define TBS_LEFT	4
#define TBS_RIGHT	0
#define TBS_BOTH	8
#define TBS_ENABLESELRANGE	32
#define TBS_FIXEDLENGTH	64
#define TBS_NOTHUMB	128
#define TBS_TOOLTIPS	256
#define TBS_REVERSED	0x200
#define TB_BOTTOM	7
#define TB_ENDTRACK	8
#define TB_LINEDOWN	1
#define TB_LINEUP	0
#define TB_PAGEDOWN	3
#define TB_PAGEUP	2
#define TB_THUMBPOSITION	4
#define TB_THUMBTRACK	5
#define TB_TOP	6
#define TB_MARKBUTTON	(WM_USER + 6)
#define TB_ISBUTTONHIGHLIGHTED (WM_USER + 14)
#define LVS_ALIGNLEFT	2048
#define LVS_ALIGNTOP	0
#define LVS_AUTOARRANGE	256
#define LVS_EDITLABELS	512
#define LVS_ICON	0
#define LVS_LIST	3
#define LVS_NOCOLUMNHEADER	16384
#define LVS_NOLABELWRAP	128
#define LVS_NOSCROLL	8192
#define LVS_NOSORTHEADER	32768
#define LVS_OWNERDRAWFIXED	1024
#define LVS_REPORT	1
#define LVS_SHAREIMAGELISTS	64
#define LVS_SHOWSELALWAYS	8
#define LVS_SINGLESEL	4
#define LVS_SMALLICON	2
#define LVS_SORTASCENDING	16
#define LVS_SORTDESCENDING	32
#define LVS_TYPESTYLEMASK	64512
#define LVS_TYPEMASK	3
#define LVS_ALIGNMASK	0xc00
#define LVS_OWNERDATA	0x1000
#define LVS_EX_GRIDLINES	1
#define LVS_EX_SUBITEMIMAGES	2
#define LVS_EX_CHECKBOXES	4
#define LVS_EX_TRACKSELECT	8
#define LVS_EX_HEADERDRAGDROP	16
#define LVS_EX_FULLROWSELECT	32
#define LVS_EX_ONECLICKACTIVATE 64
#define LVS_EX_TWOCLICKACTIVATE	128
#define LVS_EX_FLATSB	256
#define LVS_EX_REGIONAL	512
#define LVS_EX_INFOTIP	1024
#define LVS_EX_UNDERLINEHOT	0x800
#define LVS_EX_UNDERLINECOLD	0x1000
#define LVS_EX_MULTIWORKAREAS	0x2000
#define LVS_EX_LABELTIP	0x4000
#define LVS_EX_BORDERSELECT	0x8000
#define LVS_EX_LABELTIP	0x4000
#define LVS_EX_BORDERSELECT	0x8000
#define LVS_EX_DOUBLEBUFFER	0x10000
#define LVS_EX_HIDELABELS	0x20000
#define LVS_EX_SINGLEROW	0x40000
#define LVS_EX_SNAPTOGRID	0x80000
#define LVS_EX_SIMPLESELECT	0x100000
#define LVSIL_NORMAL	0
#define LVSIL_SMALL	1
#define LVSIL_STATE	2
#define LVIS_CUT	4
#define LVIS_DROPHILITED	8
#define LVIS_FOCUSED	1
#define LVIS_SELECTED	2
#define LVIS_OVERLAYMASK	3840
#define LVIS_STATEIMAGEMASK	61440
#define INDEXTOSTATEIMAGEMASK(i) ((i) << 12)
#define LPSTR_TEXTCALLBACKW	((LPWSTR)-1)
#define LPSTR_TEXTCALLBACKA	((LPSTR)-1)
#define LVIF_TEXT	1
#define LVIF_IMAGE	2
#define LVIF_PARAM	4
#define LVIF_STATE	8
#define LVIF_DI_SETITEM	4096
#define LVNI_ABOVE	256
#define LVNI_ALL	0
#define LVNI_BELOW	512
#define LVNI_TOLEFT	1024
#define LVNI_TORIGHT	2048
#define LVNI_CUT	4
#define LVNI_DROPHILITED	8
#define LVNI_FOCUSED	1
#define LVNI_SELECTED	2
#define LVFI_PARAM	1
#define LVFI_PARTIAL	8
#define LVFI_STRING	2
#define LVFI_WRAP	32
#define LVFI_NEARESTXY	64
#define LVHT_ABOVE	8
#define LVHT_BELOW	16
#define LVHT_NOWHERE	1
#define LVHT_ONITEMICON	2
#define LVHT_ONITEMLABEL	4
#define LVHT_ONITEMSTATEICON	8
#define LVHT_TOLEFT	64
#define LVHT_TORIGHT	32
#define LVHT_ONITEM	(LVHT_ONITEMICON|LVHT_ONITEMLABEL|LVHT_ONITEMSTATEICON)
#define LVCF_FMT	1
#define LVCF_SUBITEM	8
#define LVCF_TEXT	4
#define LVCF_WIDTH	2
#define LVCF_IMAGE         0x0010
#define LVCF_ORDER         0x0020
#define LVCFMT_CENTER	2
#define LVCFMT_LEFT	0
#define LVCFMT_RIGHT	1
#define LVCFMT_IMAGE        0x0800
#define LVCFMT_BITMAP_ON_RIGHT 0x1000
#define LVCFMT_COL_HAS_IMAGES  0x8000
#define LVCFMT_JUSTIFYMASK   0x0003
#define LVIR_BOUNDS	0
#define LVIR_ICON	1
#define LVIR_LABEL	2
#define LVIR_SELECTBOUNDS	3
#define LVA_ALIGNLEFT	1
#define LVA_ALIGNTOP	2
#define LVA_DEFAULT	0
#define LVA_SNAPTOGRID	5
#define LVSCW_AUTOSIZE	(-1)
#define LVSCW_AUTOSIZE_USEHEADER	(-2)
#define MONTHCAL_CLASSW	L"SysMonthCal32"
#define MONTHCAL_CLASSA	"SysMonthCal32"
#define MCM_FIRST	0x1000
#define MCM_GETCURSEL	(MCM_FIRST + 1)
#define MonthCal_GetCurSel(h,p) (BOOL)SNDMSG(h,MCM_GETCURSEL,0,(LPARAM)(p))
#define MCM_SETCURSEL	(MCM_FIRST+2)
#define MonthCal_SetCurSel(h,p) (BOOL)SNDMSG(h,MCM_SETCURSEL,0,(LPARAM)(p))
#define MCM_GETMAXSELCOUNT (MCM_FIRST+3)
#define MonthCal_GetMaxSelCount(h) (DWORD)SNDMSG(h,MCM_GETMAXSELCOUNT,0,0)
#define MCM_SETMAXSELCOUNT (MCM_FIRST+4)
#define MonthCal_SetMaxSelCount(h,n) (BOOL)SNDMSG(h,MCM_SETMAXSELCOUNT,(WPARAM)(n),0)
#define MCM_GETSELRANGE (MCM_FIRST+5)
#define MonthCal_GetSelRange(h,r) SNDMSG(h,MCM_GETSELRANGE,0,(LPARAM)(r))
#define MCM_SETSELRANGE	(MCM_FIRST+6)
#define MonthCal_SetSelRange(h,r) SNDMSG(h,MCM_SETSELRANGE,0,(LPARAM)(r))
#define MCM_GETMONTHRANGE (MCM_FIRST+7)
#define MonthCal_GetMonthRange(h,g,r) (DWORD)SNDMSG(h,MCM_GETMONTHRANGE,(WPARAM)(g),(LPARAM)(r))
#define MCM_SETDAYSTATE (MCM_FIRST+8)
#define MonthCal_SetDayState(h,c,r) SNDMSG(h,MCM_SETDAYSTATE,(WPARAM)(c),(LPARAM)(r))
#define MCM_GETMINREQRECT	(MCM_FIRST+9)
#define MonthCal_GetMinReqRect(h,p) SNDMSG(h,MCM_GETMINREQRECT,0,(LPARAM)(p))
#define MCM_SETCOLOR (MCM_FIRST + 10)
#define MonthCal_SetColor(h,i,c) SNDMSG(h,MCM_SETCOLOR,i,c)
#define MCM_GETCOLOR (MCM_FIRST+11)
#define MonthCal_GetColor(h,i) SNDMSG(h,MCM_GETCOLOR,i,0)
#define MCSC_BACKGROUND	0
#define MCSC_TEXT	1
#define MCSC_TITLEBK	2
#define MCSC_TITLETEXT	3
#define MCSC_MONTHBK	4
#define MCSC_TRAILINGTEXT	5
#define MCM_SETTODAY	(MCM_FIRST+12)
#define MonthCal_SetToday(h,p) SNDMSG(h,MCM_SETTODAY,0,(LPARAM)(p))
#define MCM_GETTODAY	(MCM_FIRST+13)
#define MonthCal_GetToday(h,p)	(BOOL)SNDMSG(h,MCM_GETTODAY,0,(LPARAM)(p))
#define MCM_HITTEST	(MCM_FIRST+14)
#define MonthCal_HitTest(h,p) SNDMSG(h, MCM_HITTEST, 0, (LPARAM)(PMCHITTESTINFO)(p))
#define MCHT_TITLE	0x10000
#define MCHT_CALENDAR	0x20000
#define MCHT_TODAYLINK	0x30000
#define MCHT_NEXT	0x1000000
#define MCHT_PREV	0x2000000
#define MCHT_NOWHERE	0
#define MCHT_TITLEBK	(MCHT_TITLE)
#define MCHT_TITLEMONTH	(MCHT_TITLE|1)
#define MCHT_TITLEYEAR	(MCHT_TITLE|2)
#define MCHT_TITLEBTNNEXT	(MCHT_TITLE|MCHT_NEXT|3)
#define MCHT_TITLEBTNPREV	(MCHT_TITLE|MCHT_PREV|3)
#define MCHT_CALENDARBK	(MCHT_CALENDAR)
#define MCHT_CALENDARDATE	(MCHT_CALENDAR|1)
#define MCHT_CALENDARDATENEXT	(MCHT_CALENDARDATE|MCHT_NEXT)
#define MCHT_CALENDARDATEPREV	(MCHT_CALENDARDATE|MCHT_PREV)
#define MCHT_CALENDARDAY	(MCHT_CALENDAR | 0x0002)
#define MCHT_CALENDARWEEKNUM	(MCHT_CALENDAR | 0x0003)
#define MCM_SETFIRSTDAYOFWEEK (MCM_FIRST+15)
#define MonthCal_SetFirstDayOfWeek(h,i) SNDMSG(h,MCM_SETFIRSTDAYOFWEEK,0,i)
#define MCM_GETFIRSTDAYOFWEEK (MCM_FIRST+16)
#define MonthCal_GetFirstDayOfWeek(h) (DWORD)SNDMSG(h,MCM_GETFIRSTDAYOFWEEK,0,0)
#define MCM_GETRANGE (MCM_FIRST+17)
#define MonthCal_GetRange(h, r) (DWORD)SNDMSG(h,MCM_GETRANGE,0,(LPARAM)(r))
#define MCM_SETRANGE (MCM_FIRST+18)
#define MonthCal_SetRange(h,g,r) (BOOL)SNDMSG(h,MCM_SETRANGE,(WPARAM)(g),(LPARAM)(r))
#define MCM_GETMONTHDELTA (MCM_FIRST + 19)
#define MonthCal_GetMonthDelta(hmc) (int)SNDMSG(h,MCM_GETMONTHDELTA,0,0)
#define MCM_SETMONTHDELTA (MCM_FIRST+20)
#define MonthCal_SetMonthDelta(h,n) (int)SNDMSG(h,MCM_SETMONTHDELTA,n,0)
#define MCM_GETMAXTODAYWIDTH (MCM_FIRST+21)
#define MonthCal_GetMaxTodayWidth(hmc) (DWORD)SNDMSG(h,MCM_GETMAXTODAYWIDTH,0,0)

//#if (_WIN32_IE >= 0x0400)
#define MCM_SETUNICODEFORMAT	CCM_SETUNICODEFORMAT
#define MonthCal_SetUnicodeFormat(h,f) (BOOL)SNDMSG((h),MCM_SETUNICODEFORMAT,(WPARAM)(f),0)
#define MCM_GETUNICODEFORMAT	CCM_GETUNICODEFORMAT
#define MonthCal_GetUnicodeFormat(h) (BOOL)SNDMSG((h),MCM_GETUNICODEFORMAT,0,0)
//#endif
#define MCN_SELCHANGE	(MCN_FIRST+1)
#define MCN_GETDAYSTATE	(MCN_FIRST+3)
#define MCN_SELECT	(MCN_FIRST+4)
#define MCS_DAYSTATE	1
#define MCS_MULTISELECT	2
#define MCS_WEEKNUMBERS	4
#define MCS_NOTODAYCIRCLE	8
#define MCS_NOTODAY	16
#define GMR_VISIBLE	0
#define GMR_DAYSTATE	1
#define TVS_DISABLEDRAGDROP	16
#define TVS_EDITLABELS	8
#define TVS_HASBUTTONS	1
#define TVS_HASLINES	2
#define TVS_LINESATROOT	4
#define TVS_SHOWSELALWAYS	32
#define TVS_NOTOOLTIPS	0x80
#define TVS_CHECKBOXES	0x100
#define TVS_TRACKSELECT	0x200
#define TVS_SINGLEEXPAND	0x400
#define TVS_INFOTIP	0x800
#define TVS_FULLROWSELECT	0x1000
#define TVS_NOSCROLL	0x2000
#define TVS_NONEVENHEIGHT	0x4000
#define TVS_NOHSCROLL	0x8000
#define TVS_RTLREADING	0x40
#define TVIS_BOLD	16
#define TVIS_CUT	4
#define TVIS_DROPHILITED	8
#define TVIS_EXPANDED	32
#define TVIS_EXPANDEDONCE	64
#define TVIS_FOCUSED	1
#define TVIS_OVERLAYMASK	3840
#define TVIS_SELECTED	2
#define TVIS_STATEIMAGEMASK	61440
#define TVIS_USERMASK	61440
#define TVIF_CHILDREN	64
#define TVIF_HANDLE	16
#define TVIF_IMAGE	2
#define TVIF_PARAM	4
#define TVIF_SELECTEDIMAGE	32
#define TVIF_STATE	8
#define TVIF_TEXT	1
#define TVIF_DI_SETITEM	0x1000
#define I_CHILDRENCALLBACK	(-1)
#define I_IMAGECALLBACK	(-1)
#define I_IMAGENONE	(-2)
#define TVI_ROOT	((HTREEITEM)(-65536))
#define TVI_FIRST	((HTREEITEM)(-65535))
#define TVI_LAST	((HTREEITEM)(-65534))
#define TVI_SORT	((HTREEITEM)(-65533))
#define TVHT_ABOVE	256
#define TVHT_BELOW	512
#define TVHT_NOWHERE	1
#define TVHT_ONITEM	70
#define TVHT_ONITEMBUTTON	16
#define TVHT_ONITEMICON	2
#define TVHT_ONITEMINDENT	8
#define TVHT_ONITEMLABEL	4
#define TVHT_ONITEMRIGHT	32
#define TVHT_ONITEMSTATEICON	64
#define TVHT_TOLEFT	2048
#define TVHT_TORIGHT	1024
#define TVE_COLLAPSE	1
#define TVE_COLLAPSERESET	32768
#define TVE_EXPAND	2
#define TVE_TOGGLE	3
#define TVSIL_NORMAL	0
#define TVSIL_STATE	2
#define TVGN_CARET	9
#define TVGN_CHILD	4
#define TVGN_DROPHILITE	8
#define TVGN_FIRSTVISIBLE	5
#define TVGN_NEXT	1
#define TVGN_NEXTVISIBLE	6
#define TVGN_PARENT	3
#define TVGN_PREVIOUS	2
#define TVGN_PREVIOUSVISIBLE	7
#define TVGN_ROOT	0
#define TVC_BYKEYBOARD	2
#define TVC_BYMOUSE	1
#define TVC_UNKNOWN	0
#define TCS_BUTTONS	256
#define TCS_FIXEDWIDTH	1024
#define TCS_FOCUSNEVER	32768
#define TCS_FOCUSONBUTTONDOWN	4096
#define TCS_FORCEICONLEFT	16
#define TCS_FORCELABELLEFT	32
#define TCS_MULTILINE	512
#define TCS_OWNERDRAWFIXED	8192
#define TCS_RAGGEDRIGHT	2048
#define TCS_RIGHTJUSTIFY	0
#define TCS_SINGLELINE	0
#define TCS_TABS	0
#define TCS_TOOLTIPS	16384
#define TCS_SCROLLOPPOSITE	1
#define TCS_BOTTOM	2
#define TCS_RIGHT	2
#define TCS_BOTTOM	2
#define TCS_MULTISELECT	4
#define TCS_HOTTRACK	0x40
#define TCS_VERTICAL	0x80
#define TCS_FLATBUTTONS	8
#define TCS_HOTTRACK	0x40
#define TCS_VERTICAL	0x80
#define TCS_TABS	0
#define TCS_SINGLELINE	0
#define TCS_RIGHTJUSTIFY	0
#define TCS_RAGGEDRIGH	0x800
#define TCS_EX_FLATSEPARATORS	1
#define TCS_EX_REGISTERDROP	2
#define TCIF_TEXT	1
#define TCIF_IMAGE	2
#define TCIF_PARAM	8
#define TCIF_RTLREADING	4
#define TCIF_STATE	0x10
#define TCIS_BUTTONPRESSED	1
#define TCIS_HIGHLIGHTED	2
#define TCHT_NOWHERE	1
#define TCHT_ONITEM	6
#define TCHT_ONITEMICON	2
#define TCHT_ONITEMLABEL	4
#define LPTC_HITTESTINFO	LPTCHITTESTINFO
#define TC_HITTESTINFO	TCHITTESTINFO
#define ACS_AUTOPLAY	4
#define ACS_CENTER	1
#define ACS_TRANSPARENT	2
#define ACS_TIMER	8
#define DIALOPTION_BILLING	64
#define DIALOPTION_QUIET	128
#define DIALOPTION_DIALTONE	256
#define MDMVOLFLAG_LOW	1
#define MDMVOLFLAG_MEDIUM	2
#define MDMVOLFLAG_HIGH	4
#define MDMVOL_LOW	0
#define MDMVOL_MEDIUM	1
#define MDMVOL_HIGH	2
#define MDMSPKRFLAG_OFF	1
#define MDMSPKRFLAG_DIAL	2
#define MDMSPKRFLAG_ON	4
#define MDMSPKRFLAG_CALLSETUP	8
#define MDMSPKR_OFF	0
#define MDMSPKR_DIAL	1
#define MDMSPKR_ON	2
#define MDMSPKR_CALLSETUP	3
#define MDM_BLIND_DIAL	512
#define MDM_CCITT_OVERRIDE	64
#define MDM_CELLULAR	8
#define MDM_COMPRESSION	1
#define MDM_ERROR_CONTROL	2
#define MDM_FLOWCONTROL_HARD	16
#define MDM_FLOWCONTROL_SOFT	32
#define MDM_FORCED_EC	4
#define MDM_SPEED_ADJUST	128
#define MDM_TONE_DIAL	256
#define MDM_V23_OVERRIDE	1024
#define MINCHAR	0x80
#define MAXCHAR	0x7f
#define MINSHORT	0x8000
#define MAXSHORT	0x7fff
#define MINLONG	0x80000000
#define MAXLONG	0x7fffffff
#define MAXBYTE	0xff
#define MAXWORD	0xffff
#define MAXDWORD	0xffffffff
#define LANG_BULGARIAN	2
#define LANG_CHINESE	4
#define LANG_CROATIAN	26
#define LANG_CZECH	5
#define LANG_DANISH	6
#define LANG_DUTCH	19
#define LANG_ENGLISH	9
#define LANG_FINNISH	11
#define LANG_FRENCH	12
#define LANG_GERMAN	7
#define LANG_GREEK	8
#define LANG_HUNGARIAN	14
#define LANG_ICELANDIC	15
#define LANG_ITALIAN	16
#define LANG_JAPANESE	17
#define LANG_KOREAN	18
#define LANG_NEUTRAL	0
#define LANG_NORWEGIAN	20
#define LANG_POLISH	21
#define LANG_PORTUGUESE	22
#define LANG_ROMANIAN	24
#define LANG_RUSSIAN	25
#define LANG_SLOVAK	27
#define LANG_SLOVENIAN	36
#define LANG_SPANISH	10
#define LANG_SWEDISH	29
#define LANG_TURKISH	31
#define SUBLANG_CHINESE_SIMPLIFIED	2
#define SUBLANG_CHINESE_TRADITIONAL	1
#define SUBLANG_CHINESE_HONGKONG	3
#define SUBLANG_CHINESE_SINGAPORE	4
#define SUBLANG_DEFAULT	1
#define SUBLANG_DUTCH	1
#define SUBLANG_DUTCH_BELGIAN	2
#define SUBLANG_ENGLISH_AUS	3
#define SUBLANG_ENGLISH_CAN	4
#define SUBLANG_ENGLISH_EIRE	6
#define SUBLANG_ENGLISH_NZ	5
#define SUBLANG_ENGLISH_UK	2
#define SUBLANG_ENGLISH_US	1
#define SUBLANG_FRENCH	1
#define SUBLANG_FRENCH_BELGIAN	2
#define SUBLANG_FRENCH_CANADIAN	3
#define SUBLANG_FRENCH_SWISS	4
#define SUBLANG_GERMAN	1
#define SUBLANG_GERMAN_AUSTRIAN	3
#define SUBLANG_GERMAN_SWISS	2
#define SUBLANG_ITALIAN	1
#define SUBLANG_ITALIAN_SWISS	2
#define SUBLANG_NEUTRAL	0
#define SUBLANG_NORWEGIAN_BOKMAL	1
#define SUBLANG_NORWEGIAN_NYNORSK	2
#define SUBLANG_PORTUGUESE	2
#define SUBLANG_PORTUGUESE_BRAZILIAN	1
#define SUBLANG_SPANISH	1
#define SUBLANG_SPANISH_MEXICAN	2
#define SUBLANG_SPANISH_MODERN	3
#define SUBLANG_SYS_DEFAULT	2
#define NLS_VALID_LOCALE_MASK	1048575
#define SORT_DEFAULT	0
#define SORT_JAPANESE_XJIS	0
#define SORT_JAPANESE_UNICODE	1
#define SORT_CHINESE_BIG5	0
#define SORT_CHINESE_UNICODE	1
#define SORT_KOREAN_KSC	0
#define SORT_KOREAN_UNICODE	1
#define NM_LAST	(-99U)
#define LVN_FIRST	((unsigned)-100)
#define LVN_LAST	(-199U)
#define HDN_FIRST	(-300U)
#define HDN_LAST	(-399U)
#define TVN_FIRST	(-400U)
#define TVN_LAST	(-499U)
#define TTN_FIRST	(-520U)
#define TTN_LAST	(-549U)
#define TCN_FIRST	(-550U)
#define TCN_LAST	(-580U)
#define CDN_FIRST	(-601U)
#define CDN_LAST	(-699U)
#define TBN_FIRST	(-700U)
#define TBN_LAST	(-720U)
#define UDN_FIRST	(-721)
#define UDN_LAST	(-740)
#define MCN_FIRST	(-750U)
#define MCN_LAST	(-759U)
#define DTN_FIRST	(-760U)
#define DTN_LAST	(-799U)
#define DTM_FIRST	0x1000
#define CBEN_FIRST	(0xfffffce0)
#define CBEN_GETDISPINFO CBEN_FIRST
#define CBEN_GETDISPINFOA CBEN_FIRST
#define CBEN_GETDISPINFOW (CBEN_FIRST-7)
#define CBEN_BEGINEDIT	(CBEN_FIRST-4)
#define CBEN_ENDEDITA	(CBEN_FIRST-5)
#define CBEN_ENDEDITW	(CBEN_FIRST-6)
#define CBEN_INSERTITEM	(CBEN_FIRST-1)
#define CBEN_DELETEITEM	(CBEN_FIRST-2)

#ifdef UNICODE
#define TVM_INSERTITEM	TVM_INSERTITEMW
#define CBEN_ENDEDIT CBEN_ENDEDITW
#define CBEN_DRAGBEGIN CBEN_DRAGBEGINW
#define MONTHCAL_CLASS	MONTHCAL_CLASSW
#define WC_PAGESCROLLER	WC_PAGESCROLLERW
#define TTM_SETTITLE	TTM_SETTITLEW
#else
#define TTM_SETTITLE	TTM_SETTITLEA
#define TVM_INSERTITEM	TVM_INSERTITEMA
#define CBEN_ENDEDIT CBEN_ENDEDITA
#define CBEN_DRAGBEGIN CBEN_DRAGBEGINA
#define MONTHCAL_CLASS	MONTHCAL_CLASSA
#define WC_PAGESCROLLER	WC_PAGESCROLLERA
#endif

#define CBENF_KILLFOCUS	1
#define CBENF_RETURN	2
#define CBENF_ESCAPE	3
#define CBENF_DROPDOWN	4
#define CBEMAXSTRLEN 260
#define CBEN_DRAGBEGINA	(CBEN_FIRST - 8)
#define CBEN_DRAGBEGINW	(CBEN_FIRST - 9)
#define CBEN_LAST	(-830U)
#define RBN_FIRST	(0U-831U)
#define RBN_LAST	(0U-859U)
#define RBN_HEIGHTCHANGE	(RBN_FIRST - 0)
#define RBN_GETOBJECT	(RBN_FIRST - 1)
#define RBN_LAYOUTCHANGED	(RBN_FIRST - 2)
#define RBN_AUTOSIZE	(RBN_FIRST - 3)
#define RBN_BEGINDRAG	(RBN_FIRST - 4)
#define RBN_ENDDRAG	(RBN_FIRST - 5)
#define RBN_DELETINGBAND	(RBN_FIRST - 6)
#define RBN_DELETEDBAND	(RBN_FIRST - 7)
#define RBN_CHILDSIZE	(RBN_FIRST - 8)
#define RBN_CHEVRONPUSHED	(RBN_FIRST - 10)
#define RBN_MINMAX	(RBN_FIRST - 21)
#define RBN_AUTOBREAK	(RBN_FIRST - 22)
#define RBNM_ID	1
#define RBNM_STYLE	2
#define RBNM_LPARAM	4
#define IPN_FIRST	(-860U)
#define IPN_LAST	(-879U)
#define PGN_FIRST	(-900U)
#define PGN_LAST	(-950U)
#define SBN_FIRST	(-880U)
#define SBN_LAST	(-899U)
#define DTM_GETSYSTEMTIME	(DTM_FIRST+1)
#define DTM_SETSYSTEMTIME	(DTM_FIRST+2)
#define DTM_GETRANGE	(DTM_FIRST+3)
#define DTM_SETRANGE	(DTM_FIRST+4)
#define DTM_SETFORMATA	(DTM_FIRST+5)
#define DTM_SETFORMATW	(DTM_FIRST+50)
#define DTM_SETMCCOLOR	(DTM_FIRST+6)
#define DTM_GETMCCOLOR	(DTM_FIRST+7)
#define DTM_GETMONTHCAL	(DTM_FIRST+8)
#define DTM_SETMCFONT	(DTM_FIRST+9)
#define DTM_GETMCFONT	(DTM_FIRST+10)
#define DTS_UPDOWN	1
#define DTS_SHOWNONE	2
#define DTS_SHORTDATEFORMAT 0
#define DTS_LONGDATEFORMAT 4
#define DTS_TIMEFORMAT	9
#define DTS_APPCANPARSE	16
#define DTS_RIGHTALIGN	32
#define DTS_SHORTDATECENTURYFORMAT 0xC
#define DTN_DATETIMECHANGE (DTN_FIRST+1)
#define DTN_USERSTRINGA	(DTN_FIRST+2)
#define DTN_USERSTRINGW	(DTN_FIRST+15)
#define DTN_WMKEYDOWNA	(DTN_FIRST+3)
#define DTN_WMKEYDOWNW	(DTN_FIRST+16)
#define DTN_FORMATA	(DTN_FIRST + 4)
#define DTN_FORMATW	(DTN_FIRST+17)
#define DTN_FORMATQUERYA	(DTN_FIRST+5)
#define DTN_FORMATQUERYW	(DTN_FIRST+18)
#define DTN_DROPDOWN	(DTN_FIRST + 6)
#define DTN_CLOSEUP	(DTN_FIRST + 7)
#define GDTR_MIN	1
#define GDTR_MAX	2
#define GDT_ERROR	-1
#define GDT_VALID	0
#define GDT_NONE	1
#define CDRF_DODEFAULT	0
#define CDRF_NEWFONT	2
#define CDRF_SKIPDEFAULT	4
#define CDRF_NOTIFYPOSTPAINT	16
#define CDRF_NOTIFYITEMDRAW	32
#define CDRF_NOTIFYSUBITEMDRAW	32
#define CDRF_NOTIFYPOSTERASE	0x40
#define CDDS_PREPAINT	1
#define CDDS_POSTPAINT	2
#define CDDS_PREERASE	3
#define CDDS_POSTERASE	4
#define CDDS_ITEM	0x10000
#define CDDS_ITEMPREPAINT	(CDDS_ITEM | CDDS_PREPAINT)
#define CDDS_ITEMPOSTPAINT	(CDDS_ITEM | CDDS_POSTPAINT)
#define CDDS_ITEMPREERASE	(CDDS_ITEM | CDDS_PREERASE)
#define CDDS_ITEMPOSTERASE	(CDDS_ITEM | CDDS_POSTERASE)
#define CDDS_SUBITEM	0x20000
#define CDIS_SELECTED	1
#define CDIS_GRAYED	2
#define CDIS_DISABLED	4
#define CDIS_CHECKED	8
#define CDIS_FOCUS	16
#define CDIS_DEFAULT	32
#define CDIS_HOT	64
#define CDIS_MARKED	0x80
#define CDIS_INDETERMINATE	0x0100
#define CLR_HILIGHT	CLR_DEFAULT
#define PROCESSOR_INTEL_386	386
#define PROCESSOR_INTEL_486	486
#define PROCESSOR_INTEL_PENTIUM	586
#define PROCESSOR_MIPS_R4000	4000
#define PROCESSOR_ALPHA_21064	21064
#define COMPRESSION_FORMAT_NONE	0
#define COMPRESSION_FORMAT_DEFAULT	1
#define COMPRESSION_FORMAT_LZNT1	2
#define TAPE_DRIVE_COMPRESSION	131072
#define TAPE_DRIVE_ECC	65536
#define TAPE_DRIVE_ERASE_BOP_ONLY	64
#define TAPE_DRIVE_ERASE_LONG	32
#define TAPE_DRIVE_ERASE_IMMEDIATE	128
#define TAPE_DRIVE_ERASE_SHORT	16
#define TAPE_DRIVE_FIXED	1
#define TAPE_DRIVE_FIXED_BLOCK	1024
#define TAPE_DRIVE_INITIATOR	4
#define TAPE_DRIVE_PADDING	262144
#define TAPE_DRIVE_GET_ABSOLUTE_BLK	1048576
#define TAPE_DRIVE_GET_LOGICAL_BLK	2097152
#define TAPE_DRIVE_REPORT_SMKS	524288
#define TAPE_DRIVE_SELECT	2
#define TAPE_DRIVE_SET_EOT_WZ_SIZE	4194304
#define TAPE_DRIVE_TAPE_CAPACITY	256
#define TAPE_DRIVE_TAPE_REMAINING	512
#define TAPE_DRIVE_VARIABLE_BLOCK	2048
#define TAPE_DRIVE_WRITE_PROTECT	4096
#define TAPE_DRIVE_ABS_BLK_IMMED	(-2147475456)
#define TAPE_DRIVE_ABSOLUTE_BLK	(-2147479552)
#define TAPE_DRIVE_END_OF_DATA	(-2147418112)
#define TAPE_DRIVE_FILEMARKS	(-2147221504)
#define TAPE_DRIVE_LOAD_UNLOAD	(-2147483647)
#define TAPE_DRIVE_LOAD_UNLD_IMMED	(-2147483616)
#define TAPE_DRIVE_LOCK_UNLOCK	(-2147483644)
#define TAPE_DRIVE_LOCK_UNLK_IMMED	(-2147483520)
#define TAPE_DRIVE_LOG_BLK_IMMED	(-2147450880)
#define TAPE_DRIVE_LOGICAL_BLK	(-2147467264)
#define TAPE_DRIVE_RELATIVE_BLKS	(-2147352576)
#define TAPE_DRIVE_REVERSE_POSITION	(-2143289344)
#define TAPE_DRIVE_REWIND_IMMEDIATE	(-2147483640)
#define TAPE_DRIVE_SEQUENTIAL_FMKS	(-2146959360)
#define TAPE_DRIVE_SEQUENTIAL_SMKS	(-2145386496)
#define TAPE_DRIVE_SET_BLOCK_SIZE	(-2147483632)
#define TAPE_DRIVE_SET_COMPRESSION	(-2147483136)
#define TAPE_DRIVE_SET_ECC	(-2147483392)
#define TAPE_DRIVE_SET_PADDING	(-2147482624)
#define TAPE_DRIVE_SET_REPORT_SMKS	(-2147481600)
#define TAPE_DRIVE_SETMARKS	(-2146435072)
#define TAPE_DRIVE_SPACE_IMMEDIATE	(-2139095040)
#define TAPE_DRIVE_TENSION	(-2147483646)
#define TAPE_DRIVE_TENSION_IMMED	(-2147483584)
#define TAPE_DRIVE_WRITE_FILEMARKS	(-2113929216)
#define TAPE_DRIVE_WRITE_LONG_FMKS	(-2013265920)
#define TAPE_DRIVE_WRITE_MARK_IMMED	(-1879048192)
#define TAPE_DRIVE_WRITE_SETMARKS	(-2130706432)
#define TAPE_DRIVE_WRITE_SHORT_FMKS	(-2080374784)
#define STANDARD_RIGHTS_REQUIRED	0xf0000
#define STANDARD_RIGHTS_WRITE	0x20000
#define STANDARD_RIGHTS_READ	0x20000
#define STANDARD_RIGHTS_EXECUTE	0x20000
#define STANDARD_RIGHTS_ALL	0x1f0000
#define SPECIFIC_RIGHTS_ALL	0xffff
#define MAXIMUM_ALLOWED	0x2000000
#define GENERIC_ALL	0x10000000
#define SECURITY_NULL_RID	0
#define SECURITY_WORLD_RID	0
#define SECURITY_LOCAL_RID	0
#define SECURITY_CREATOR_OWNER_RID	0
#define SECURITY_CREATOR_GROUP_RID	1
#define SECURITY_DIALUP_RID	1
#define SECURITY_NETWORK_RID	2
#define SECURITY_BATCH_RID	3
#define SECURITY_INTERACTIVE_RID	4
#define SECURITY_LOGON_IDS_RID	5
#define SECURITY_LOGON_IDS_RID_COUNT	3
#define SECURITY_SERVICE_RID	6
#define SECURITY_LOCAL_SYSTEM_RID	0x12
#define SECURITY_BUILTIN_DOMAIN_RID	32
#define DOMAIN_USER_RID_ADMIN	0x1f4
#define DOMAIN_USER_RID_GUEST	0x1f5
#define DOMAIN_GROUP_RID_ADMINS	512
#define DOMAIN_GROUP_RID_USERS	0x201
#define DOMAIN_ALIAS_RID_ADMINS	0x220
#define DOMAIN_ALIAS_RID_USERS	0x221
#define DOMAIN_ALIAS_RID_GUESTS	0x222
#define DOMAIN_ALIAS_RID_POWER_USERS	0x223
#define DOMAIN_ALIAS_RID_ACCOUNT_OPS	0x224
#define DOMAIN_ALIAS_RID_SYSTEM_OPS	0x225
#define DOMAIN_ALIAS_RID_PRINT_OPS	0x226
#define DOMAIN_ALIAS_RID_BACKUP_OPS	0x227
#define DOMAIN_ALIAS_RID_REPLICATOR	0x228
#define SE_GROUP_MANDATORY	1
#define SE_GROUP_ENABLED_BY_DEFAULT	2
#define SE_GROUP_ENABLED	4
#define SE_GROUP_OWNER	8
#define SE_GROUP_LOGON_ID	0xc0000000
#define SECURITY_DESCRIPTOR_REVISION	1
#define SECURITY_DESCRIPTOR_MIN_LENGTH	20
#define SE_OWNER_DEFAULTED	1
#define SE_GROUP_DEFAULTED	2
#define SE_DACL_PRESENT	4
#define SE_DACL_DEFAULTED	8
#define SE_SACL_PRESENT	16
#define SE_SACL_DEFAULTED	32
#define SE_SELF_RELATIVE	32768
#define SE_PRIVILEGE_ENABLED_BY_DEFAULT	1
#define SE_PRIVILEGE_ENABLED	2
#define SE_PRIVILEGE_USED_FOR_ACCESS	0x80000000
#define PRIVILEGE_SET_ALL_NECESSARY	1
#define OFN_ALLOWMULTISELECT	512
#define OFN_CREATEPROMPT	0x2000
#define OFN_ENABLEHOOK	32
#define OFN_ENABLETEMPLATE	64
#define OFN_ENABLETEMPLATEHANDLE	128
#define OFN_EXPLORER	0x80000
#define OFN_EXTENSIONDIFFERENT	0x400
#define OFN_FILEMUSTEXIST	0x1000
#define OFN_HIDEREADONLY	4
#define OFN_LONGNAMES	0x200000
#define OFN_NOCHANGEDIR	8
#define OFN_NODEREFERENCELINKS	0x100000
#define OFN_NOLONGNAMES	0x40000
#define OFN_NONETWORKBUTTON	0x20000
#define OFN_NOREADONLYRETURN	0x8000
#define OFN_NOTESTFILECREATE	0x10000
#define OFN_NOVALIDATE	256
#define OFN_OVERWRITEPROMPT	2
#define OFN_PATHMUSTEXIST	0x800
#define OFN_READONLY	1
#define OFN_SHAREAWARE	0x4000
#define OFN_SHOWHELP	16
#define OFN_SHAREFALLTHROUGH	2
#define OFN_SHARENOWARN	1
#define OFN_SHAREWARN	0
#define CDN_INITDONE	0xfffffda7
#define CDN_SELCHANGE	0xfffffda6
#define CDN_FOLDERCHANGE	0xfffffda5
#define CDN_SHAREVIOLATION	0xfffffda4
#define CDN_HELP	0xfffffda3
#define CDN_FILEOK	0xfffffda2
#define CDN_TYPECHANGE	0xfffffda1
#define CDM_GETFILEPATH	0x465
#define CDM_GETFOLDERIDLIST	0x467
#define CDM_GETFOLDERPATH	0x466
#define CDM_GETSPEC	0x464
#define CDM_HIDECONTROL	0x469
#define CDM_SETCONTROLTEXT	0x468
#define CDM_SETDEFEXT	0x46a
#define CC_ENABLEHOOK	16
#define CC_ENABLETEMPLATE	32
#define CC_ENABLETEMPLATEHANDLE	64
#define CC_FULLOPEN	2
#define CC_PREVENTFULLOPEN	4
#define CC_RGBINIT	1
#define CC_SHOWHELP	8
#define CC_SOLIDCOLOR	128
#define FR_DIALOGTERM	64
#define FR_DOWN	1
#define FR_ENABLEHOOK	256
#define FR_ENABLETEMPLATE	512
#define FR_ENABLETEMPLATEHANDLE	0x2000
#define FR_FINDNEXT	8
#define FR_HIDEUPDOWN	0x4000
#define FR_HIDEMATCHCASE	0x8000
#define FR_HIDEWHOLEWORD	0x10000
#define FR_MATCHCASE	4
#define FR_NOMATCHCASE	0x800
#define FR_NOUPDOWN	0x400
#define FR_NOWHOLEWORD	4096
#define FR_REPLACE	16
#define FR_REPLACEALL	32
#define FR_SHOWHELP	128
#define FR_WHOLEWORD	2
#define FR_PRIVATE	0x10
#define FR_NOT_ENUM	0x20
#define CF_APPLY	512
#define CF_ANSIONLY	0x400
#define CF_BOTH	3
#define CF_TTONLY	0x40000
#define CF_EFFECTS	256
#define CF_ENABLEHOOK	8
#define CF_ENABLETEMPLATE	16
#define CF_ENABLETEMPLATEHANDLE	32
#define CF_FIXEDPITCHONLY	0x4000
#define CF_FORCEFONTEXIST	0x10000
#define CF_INITTOLOGFONTSTRUCT	64
#define CF_LIMITSIZE	0x2000
#define CF_NOOEMFONTS	0x800
#define CF_NOFACESEL	0x80000
#define CF_NOSCRIPTSEL	0x800000
#define CF_NOSTYLESEL	0x100000
#define CF_NOSIZESEL	0x200000
#define CF_NOSIMULATIONS	4096
#define CF_NOVECTORFONTS	0x800
#define CF_NOVERTFONTS	0x1000000
#define CF_PRINTERFONTS	2
#define CF_SCALABLEONLY	0x20000
#define CF_SCREENFONTS	1
#define CF_SCRIPTSONLY	0x400
#define CF_SELECTSCRIPT	0x400000
#define CF_SHOWHELP	4
#define CF_USESTYLE	128
#define CF_WYSIWYG	0x8000
#define BOLD_FONTTYPE	256
#define ITALIC_FONTTYPE	512
#define PRINTER_FONTTYPE	0x4000
#define REGULAR_FONTTYPE	0x400
#define SCREEN_FONTTYPE	0x2000
#define SIMULATED_FONTTYPE	0x8000
#define COLOROKSTRINGW	L"commdlg_ColorOK"
#define FILEOKSTRINGW	L"commdlg_FileNameOK"
#define FINDMSGSTRINGW	L"commdlg_FindReplace"
#define HELPMSGSTRINGW	L"commdlg_help"
#define LBSELCHSTRINGW	L"commdlg_LBSelChangedNotify"
#define SETRGBSTRINGW	L"commdlg_SetRGBColor"
#define SHAREVISTRINGW	L"commdlg_ShareViolation"
#define COLOROKSTRINGA	"commdlg_ColorOK"
#define FILEOKSTRINGA	"commdlg_FileNameOK"
#define FINDMSGSTRINGA	"commdlg_FindReplace"
#define HELPMSGSTRINGA	"commdlg_help"
#define LBSELCHSTRINGA	"commdlg_LBSelChangedNotify"
#define SETRGBSTRINGA	"commdlg_SetRGBColor"
#define SHAREVISTRINGA	"commdlg_ShareViolation"
#define TBNOTIFYA NMTOOLBARA
#define TBNOTIFYW NMTOOLBARW
#define LPTBNOTIFYA LPNMTOOLBARA
#define LPTBNOTIFYW LPNMTOOLBARW
#define TBNOTIFY	NMTOOLBAR
#define LPTBNOTIFY	LPNMTOOLBAR

#ifdef UNICODE
#define COLOROKSTRING COLOROKSTRINGW
#define FILEOKSTRING FILEOKSTRINGW
#define FINDMSGSTRING FINDMSGSTRINGW
#define HELPMSGSTRING HELPMSGSTRINGW
#define LBSELCHSTRING LBSELCHSTRINGW
#define SETRGBSTRING SETRGBSTRINGW
#define SHAREVISTRING SHAREVISTRINGW
#define LVITEM	LVITEMW
#else
#define COLOROKSTRING COLOROKSTRINGA
#define FILEOKSTRING FILEOKSTRINGA
#define FINDMSGSTRING FINDMSGSTRINGA
#define HELPMSGSTRING HELPMSGSTRINGA
#define LBSELCHSTRING LBSELCHSTRINGA
#define SETRGBSTRING SETRGBSTRINGA
#define SHAREVISTRING SHAREVISTRINGA
#define LVITEM	LVITEMA
#endif

#define CD_LBSELCHANGE	0
#define CD_LBSELADD	2
#define CD_LBSELSUB	1
#define CD_LBSELNOITEMS	(-1)
#define DN_DEFAULTPRN	1
#define PD_ALLPAGES	0
#define PD_COLLATE	16
#define PD_DISABLEPRINTTOFILE	524288
#define PD_ENABLEPRINTHOOK	4096
#define PD_ENABLEPRINTTEMPLATE	16384
#define PD_ENABLEPRINTTEMPLATEHANDLE	65536
#define PD_ENABLESETUPHOOK	8192
#define PD_ENABLESETUPTEMPLATE	32768
#define PD_ENABLESETUPTEMPLATEHANDLE	131072
#define PD_HIDEPRINTTOFILE	1048576
#define PD_NOPAGENUMS	8
#define PD_NOSELECTION	4
#define PD_NOWARNING	128
#define PD_PAGENUMS	2
#define PD_PRINTSETUP	64
#define PD_PRINTTOFILE	32
#define PD_RETURNDC	256
#define PD_RETURNDEFAULT	1024
#define PD_RETURNIC	512
#define PD_SELECTION	1
#define PD_SHOWHELP	2048
#define PD_USEDEVMODECOPIES	262144
#define PD_USEDEVMODECOPIESANDCOLLATE	262144
#define PSD_DEFAULTMINMARGINS	0
#define PSD_DISABLEMARGINS	16
#define PSD_DISABLEORIENTATION	256
#define PSD_DISABLEPAGEPAINTING	524288
#define PSD_DISABLEPAPER	512
#define PSD_DISABLEPRINTER	32
#define PSD_ENABLEPAGEPAINTHOOK	262144
#define PSD_ENABLEPAGESETUPHOOK	8192
#define PSD_ENABLEPAGESETUPTEMPLATE	32768
#define PSD_ENABLEPAGESETUPTEMPLATEHANDLE	131072
#define PSD_INHUNDREDTHSOFMILLIMETERS	8
#define PSD_INTHOUSANDTHSOFINCHES	4
#define PSD_INWININIINTLMEASURE	0
#define PSD_MARGINS	2
#define PSD_MINMARGINS	1
#define PSD_NOWARNING	128
#define PSD_RETURNDEFAULT	1024
#define PSD_SHOWHELP	2048
#define SW_OTHERUNZOOM	4
#define SW_OTHERZOOM	2
#define SW_PARENTCLOSING	1
#define SW_PARENTOPENING	3
#define AW_HOR_POSITIVE	1
#define AW_HOR_NEGATIVE	2
#define AW_VER_POSITIVE	4
#define AW_VER_NEGATIVE	8
#define AW_CENTER	0x10
#define AW_HIDE	0x10000
#define AW_ACTIVATE	0x20000
#define AW_SLIDE	0x40000
#define AW_BLEND	0x80000
#define VK_LBUTTON	1
#define VK_RBUTTON	2
#define VK_CANCEL	3
#define VK_MBUTTON	4
#define VK_BACK	8
#define VK_TAB	9
#define VK_CLEAR	12
#define VK_RETURN	13
#define VK_SHIFT	16
#define VK_CONTROL	17
#define VK_MENU	18
#define VK_PAUSE	19
#define VK_PRINT	42
#define VK_CAPITAL	20
#define VK_KANA	0x15
#define VK_HANGEUL	0x15
#define VK_HANGUL	0x15
#define VK_JUNJA	0x17
#define VK_FINAL	0x18
#define VK_HANJA	0x19
#define VK_KANJI	0x19
#define VK_CONVERT	0x1C
#define VK_NONCONVERT	0x1D
#define VK_ACCEPT	0x1E
#define VK_MODECHANGE	0x1F
#define VK_ESCAPE	27
#define VK_SPACE	32
#define VK_PRIOR	33
#define VK_NEXT	34
#define VK_END	35
#define VK_HOME	36
#define VK_LEFT	37
#define VK_UP	38
#define VK_RIGHT	39
#define VK_DOWN	40
#define VK_SELECT	41
#define VK_EXECUTE	43
#define VK_SNAPSHOT	44
#define VK_INSERT	45
#define VK_DELETE	46
#define VK_HELP	47
#define VK_0	48
#define VK_1	49
#define VK_2	50
#define VK_3	51
#define VK_4	52
#define VK_5	53
#define VK_6	54
#define VK_7	55
#define VK_8	56
#define VK_9	57
#define VK_A	65
#define VK_B	66
#define VK_C	67
#define VK_D	68
#define VK_E	69
#define VK_F	70
#define VK_G	71
#define VK_H	72
#define VK_I	73
#define VK_J	74
#define VK_K	75
#define VK_L	76
#define VK_M	77
#define VK_N	78
#define VK_O	79
#define VK_P	80
#define VK_Q	81
#define VK_R	82
#define VK_S	83
#define VK_T	84
#define VK_U	85
#define VK_V	86
#define VK_W	87
#define VK_X	88
#define VK_Y	89
#define VK_Z	90
#define VK_LWIN	0x5B
#define VK_RWIN	0x5C
#define VK_APPS	0x5D
#define VK_NUMPAD0	96
#define VK_NUMPAD1	97
#define VK_NUMPAD2	98
#define VK_NUMPAD3	99
#define VK_NUMPAD4	100
#define VK_NUMPAD5	101
#define VK_NUMPAD6	102
#define VK_NUMPAD7	103
#define VK_NUMPAD8	104
#define VK_NUMPAD9	105
#define VK_MULTIPLY	106
#define VK_ADD	107
#define VK_SEPARATOR	108
#define VK_SUBTRACT	109
#define VK_DECIMAL	110
#define VK_DIVIDE	111
#define VK_F1	112
#define VK_F2	113
#define VK_F3	114
#define VK_F4	115
#define VK_F5	116
#define VK_F6	117
#define VK_F7	118
#define VK_F8	119
#define VK_F9	120
#define VK_F10	121
#define VK_F11	122
#define VK_F12	123
#define VK_F13	124
#define VK_F14	125
#define VK_F15	126
#define VK_F16	127
#define VK_F17	128
#define VK_F18	129
#define VK_F19	130
#define VK_F20	131
#define VK_F21	132
#define VK_F22	133
#define VK_F23	134
#define VK_F24	135
#define VK_NUMLOCK	144
#define VK_SCROLL	145
#define VK_LSHIFT	160
#define VK_LCONTROL	162
#define VK_LMENU	164
#define VK_RSHIFT	161
#define VK_RCONTROL	163
#define VK_RMENU	165
#define VK_PROCESSKEY	229
#define KF_ALTDOWN	8192
#define KF_DLGMODE	2048
#define KF_EXTENDED	256
#define KF_MENUMODE	4096
#define KF_REPEAT	16384
#define KF_UP	32768
#define KL_NAMELENGTH	9
#define WA_ACTIVE	1
#define WA_CLICKACTIVE	2
#define WA_INACTIVE	0
#define PWR_CRITICALRESUME	3
#define PWR_SUSPENDREQUEST	1
#define PWR_SUSPENDRESUME	2
#define PWR_FAIL	(-1)
#define PWR_OK	1
#define NF_QUERY	3
#define NF_REQUERY	4
#define NFR_ANSI	1
#define NFR_UNICODE	2
#define WMSZ_BOTTOM	6
#define WMSZ_BOTTOMLEFT	7
#define WMSZ_BOTTOMRIGHT	8
#define WMSZ_LEFT	1
#define WMSZ_RIGHT	2
#define WMSZ_TOP	3
#define WMSZ_TOPLEFT	4
#define WMSZ_TOPRIGHT	5
#define WMSZ_BOTTOM 6
#define WMSZ_BOTTOMLEFT 7
#define WMSZ_BOTTOMRIGHT 8
#define MA_ACTIVATE	1
#define MA_ACTIVATEANDEAT	2
#define MA_NOACTIVATE	3
#define MA_NOACTIVATEANDEAT	4
#define ICON_SMALL	0
#define ICON_BIG	1
#define SIZE_MAXHIDE	4
#define SIZE_MAXIMIZED	2
#define SIZEFULLSCREEN	2
#define SIZE_MAXSHOW	3
#define SIZE_MINIMIZED	1
#define SIZEICONIC	1
#define SIZE_RESTORED	0
#define SIZENORMAL	0
#define WVR_ALIGNTOP	16
#define WVR_ALIGNLEFT	32
#define WVR_ALIGNBOTTOM	64
#define WVR_ALIGNRIGHT	128
#define WVR_HREDRAW	256
#define WVR_VREDRAW	512
#define WVR_REDRAW	768
#define WVR_VALIDRECTS	1024
#define HTBOTTOM	15
#define HTBOTTOMLEFT	16
#define HTBOTTOMRIGHT	17
#define HTCAPTION	2
#define HTCLIENT	1
#define HTERROR	(-2)
#define HTGROWBOX	4
#define HTHSCROLL	6
#define HTLEFT	10
#define HTMENU	5
#define HTNOWHERE	0
#define HTREDUCE	8
#define HTRIGHT	11
#define HTSIZE	4
#define HTSYSMENU	3
#define HTTOP	12
#define HTTOPLEFT	13
#define HTTOPRIGHT	14
#define HTTRANSPARENT	(-1)
#define HTVSCROLL	7
#define HTZOOM	9
#define HTOBJECT	19
#define HTCLOSE	20
#define HTHELP	21
#define HTBORDER	18
#define HTMINBUTTON 8
#define HTMAXBUTTON 9
#define MK_CONTROL	8
#define MK_LBUTTON	1
#define MK_MBUTTON	16
#define MK_RBUTTON	2
#define MK_SHIFT	4
#define CS_BYTEALIGNCLIENT	4096
#define CS_BYTEALIGNWINDOW	8192
#define CS_KEYCVTWINDOW	4
#define	CS_NOKEYCVT	256
#define CS_CLASSDC	64
#define CS_DBLCLKS	8
#define CS_GLOBALCLASS	16384
#define CS_IME	0x10000
#define CS_DROPSHADOW	0x20000
#define CS_HREDRAW	2
#define CS_NOCLOSE	512
#define CS_OWNDC	32
#define CS_PARENTDC	128
#define CS_SAVEBITS	2048
#define CS_VREDRAW	1
#define DLGWINDOWEXTRA	30
#define FALT	16
#define FCONTROL	8
#define FNOINVERT	2
#define FSHIFT	4
#define FVIRTKEY	1
#define MIIM_CHECKMARKS	8
#define MIIM_DATA	32
#define MIIM_ID	2
#define MIIM_STATE	1
#define MIIM_SUBMENU	4
#define MIIM_TYPE	16
#define MIIM_STRING	0x040
#define MIIM_BITMAP	0x080
#define MIIM_FTYPE	0x0100
#define MFT_BITMAP	4
#define MFT_MENUBARBREAK	32
#define MFT_MENUBREAK	64
#define MFT_OWNERDRAW	256
#define MFT_RADIOCHECK	512
#define MFT_RIGHTJUSTIFY	0x4000
#define MFT_SEPARATOR	0x800
#define MFT_STRING	0
#define MFS_CHECKED	8
#define MFS_DEFAULT	4096
#define MFS_DISABLED	3
#define MFS_ENABLED	0
#define MFS_GRAYED	3
#define MFS_HILITE	128
#define MFS_UNCHECKED	0
#define MFS_UNHILITE	0
#define SERKF_AVAILABLE	2
#define SERKF_INDICATOR	4
#define SERKF_SERIALKEYSON	1
#define FKF_AVAILABLE	2
#define FKF_CLICKON	64
#define FKF_FILTERKEYSON	1
#define FKF_HOTKEYACTIVE	4
#define FKF_HOTKEYSOUND	16
#define FKF_CONFIRMHOTKEY	8
#define FKF_INDICATOR	32
#define HELPINFO_MENUITEM	2
#define HELPINFO_WINDOW	1
#define PRF_CHECKVISIBLE	1
#define PRF_CHILDREN	16
#define PRF_CLIENT	4
#define PRF_ERASEBKGND	8
#define PRF_NONCLIENT	2
#define PRF_OWNED	32
#define HWND_DESKTOP	(HWND)0
#define SC_CLOSE	61536
#define SC_CONTEXTHELP	61824
#define SC_DEFAULT	61792
#define SC_HOTKEY	61776
#define SC_HSCROLL	61568
#define SC_KEYMENU	61696
#define SC_MAXIMIZE	61488
#define SC_ZOOM	61488
#define SC_MINIMIZE	61472
#define SC_ICON	61472
#define SC_MONITORPOWER	61808
#define SC_MOUSEMENU	61584
#define SC_MOVE	61456
#define SC_NEXTWINDOW	61504
#define SC_PREVWINDOW	61520
#define SC_RESTORE	61728
#define SC_SCREENSAVE	61760
#define SC_SIZE	61440
#define SC_TASKLIST	61744
#define SC_VSCROLL	61552
#define SC_ARRANGE	61712
#define DC_HASDEFID	21323
#define DLGC_BUTTON	8192
#define DLGC_DEFPUSHBUTTON	16
#define DLGC_HASSETSEL	8
#define DLGC_RADIOBUTTON	64
#define DLGC_STATIC	256
#define DLGC_UNDEFPUSHBUTTON	32
#define DLGC_WANTALLKEYS	4
#define DLGC_WANTARROWS	1
#define DLGC_WANTCHARS	128
#define DLGC_WANTMESSAGE	4
#define DLGC_WANTTAB	2
#define EC_LEFTMARGIN	1
#define EC_RIGHTMARGIN	2
#define EC_USEFONTINFO	65535
#define LB_ERR	(-1)
#define LB_ERRSPACE	(-2)
#define CB_ERR	(-1)
#define CB_ERRSPACE	(-2)
#define SKF_AUDIBLEFEEDBACK	64
#define SKF_AVAILABLE	2
#define SKF_CONFIRMHOTKEY	8
#define SKF_HOTKEYACTIVE	4
#define SKF_HOTKEYSOUND	16
#define SKF_INDICATOR	32
#define SKF_STICKYKEYSON	1
#define SKF_TRISTATE	128
#define SKF_TWOKEYSOFF	256
#define MKF_AVAILABLE	2
#define MKF_CONFIRMHOTKEY	8
#define MKF_HOTKEYACTIVE	4
#define MKF_HOTKEYSOUND	16
#define MKF_INDICATOR	32
#define MKF_MOUSEKEYSON	1
#define MKF_MODIFIERS	64
#define MKF_REPLACENUMBERS	128
#define SSF_AVAILABLE	2
#define SSF_SOUNDSENTRYON	1
#define SSTF_BORDER	2
#define SSTF_CHARS	1
#define SSTF_DISPLAY	3
#define SSTF_NONE	0
#define SSGF_DISPLAY	3
#define SSGF_NONE	0
#define SSWF_CUSTOM	4
#define SSWF_DISPLAY	3
#define SSWF_NONE	0
#define SSWF_TITLE	1
#define SSWF_WINDOW	2
#define ATF_ONOFFFEEDBACK	2
#define ATF_TIMEOUTON	1
#define HCF_AVAILABLE	2
#define HCF_CONFIRMHOTKEY	8
#define HCF_HIGHCONTRASTON	1
#define HCF_HOTKEYACTIVE	4
#define HCF_HOTKEYAVAILABLE	64
#define HCF_HOTKEYSOUND	16
#define HCF_INDICATOR	32
#define TKF_AVAILABLE	2
#define TKF_CONFIRMHOTKEY	8
#define TKF_HOTKEYACTIVE	4
#define TKF_HOTKEYSOUND	16
#define TKF_TOGGLEKEYSON	1
#define PP_DISPLAYERRORS	1
#define RESOURCEDISPLAYTYPE_DOMAIN	1
#define RESOURCEDISPLAYTYPE_FILE	4
#define RESOURCEDISPLAYTYPE_GENERIC	0
#define RESOURCEDISPLAYTYPE_GROUP	5
#define RESOURCEDISPLAYTYPE_SERVER	2
#define RESOURCEDISPLAYTYPE_SHARE	3
#define CAPSLOCK_ON	128
#define ENHANCED_KEY	256
#define LEFT_ALT_PRESSED	2
#define LEFT_CTRL_PRESSED	8
#define NUMLOCK_ON	32
#define RIGHT_ALT_PRESSED	1
#define RIGHT_CTRL_PRESSED	4
#define SCROLLLOCK_ON	64
#define SHIFT_PRESSED	16
#define FROM_LEFT_1ST_BUTTON_PRESSED	1
#define RIGHTMOST_BUTTON_PRESSED	2
#define FROM_LEFT_2ND_BUTTON_PRESSED	4
#define FROM_LEFT_3RD_BUTTON_PRESSED	8
#define FROM_LEFT_4TH_BUTTON_PRESSED	16
#define DOUBLE_CLICK	2
#define MOUSE_MOVED	1
#define KEY_EVENT	1
#define MOUSE_EVENT	2
#define WINDOW_BUFFER_SIZE_EVENT	4
#define MENU_EVENT	8
#define FOCUS_EVENT	16
#define BI_RGB 0
#define BI_RLE8 1
#define BI_RLE4 2
#define BI_BITFIELDS 3
#define BI_JPEG 4
#define BI_PNG 5
#define HFILE_ERROR ((HFILE)-1)
#define CONTEXT_i386 0x10000
#define CONTEXT_i486 0x10000
#define CONTEXT_CONTROL (CONTEXT_i386 | 1)
#define CONTEXT_INTEGER (CONTEXT_i386 | 2)
#define CONTEXT_SEGMENTS (CONTEXT_i386 | 4)
#define CONTEXT_FLOATING_POINT (CONTEXT_i386 | 8)
#define CONTEXT_DEBUG_REGISTERS (CONTEXT_i386|0x10)
#define CONTEXT_EXTENDED_REGISTERS (CONTEXT_i386 | 0x00000020L)
#define CONTEXT_FULL (CONTEXT_CONTROL|CONTEXT_INTEGER|CONTEXT_SEGMENTS)
#define MAX_MODULE_NAME32 255
#define TH32CS_SNAPHEAPLIST 1
#define TH32CS_SNAPPROCESS 2
#define TH32CS_SNAPTHREAD 4
#define TH32CS_SNAPMODULE 8
#define TH32CS_SNAPALL (TH32CS_SNAPHEAPLIST|TH32CS_SNAPPROCESS|TH32CS_SNAPTHREAD|TH32CS_SNAPMODULE)
#define TH32CS_INHERIT 0x80000000
#define HF32_DEFAULT 1
#define HF32_SHARED 2
#define LF32_FIXED 1
#define LF32_FREE 2
#define LF32_MOVEABLE 4
#define UnlockResource(r) ((r),0)
#define METHOD_BUFFERED 0
#define METHOD_IN_DIRECT 1
#define METHOD_OUT_DIRECT 2
#define METHOD_NEITHER 3
#define FILE_ANY_ACCESS 0
#define FILE_READ_ACCESS 1
#define FILE_WRITE_ACCESS 2
#define TMPF_FIXED_PITCH 1
#define TMPF_VECTOR 2
#define TMPF_DEVICE 8
#define TMPF_TRUETYPE 4
#define NTM_REGULAR 0x40
#define NTM_BOLD 0x20
#define NTM_ITALIC 1
#define NTM_NONNEGATIVE_AC	0x00010000
#define NTM_PS_OPENTYPE	0x00020000
#define NTM_TT_OPENTYPE	0x00040000
#define NTM_MULTIPLEMASTER	0x00080000
#define NTM_TYPE1	0x00100000
#define NTM_DSIG	0x00200000
#define META_ANIMATEPALETTE	0x436
#define META_ARC	0x817
#define META_BITBLT	0x922
#define META_CHORD	0x830
#define META_CREATEBRUSHINDIRECT	0x2FC
#define META_CREATEFONTINDIRECT	0x2FB
#define META_CREATEPALETTE	0xf7
#define META_CREATEPATTERNBRUSH	0x1F9
#define META_CREATEPENINDIRECT	0x2FA
#define META_CREATEREGION	0x6FF
#define META_DELETEOBJECT	0x1f0
#define META_DIBBITBLT	0x940
#define META_DIBCREATEPATTERNBRUSH	0x142
#define META_DIBSTRETCHBLT	0xb41
#define META_ELLIPSE	0x418
#define META_ESCAPE	0x626
#define META_EXCLUDECLIPRECT	0x415
#define META_EXTFLOODFILL	0x548
#define META_EXTTEXTOUT	0xa32
#define META_FILLREGION	0x228
#define META_FLOODFILL	0x419
#define META_FRAMEREGION	0x429
#define META_INTERSECTCLIPRECT	0x416
#define META_INVERTREGION	0x12A
#define META_LINETO	0x213
#define META_MOVETO	0x214
#define META_OFFSETCLIPRGN	0x220
#define META_OFFSETVIEWPORTORG	0x211
#define META_OFFSETWINDOWORG	0x20F
#define META_PAINTREGION	0x12B
#define META_PATBLT	0x61D
#define META_PIE	0x81A
#define META_POLYGON	0x324
#define META_POLYLINE	0x325
#define META_POLYPOLYGON	0x538
#define META_REALIZEPALETTE	0x35
#define META_RECTANGLE	0x41B
#define META_RESIZEPALETTE	0x139
#define META_RESTOREDC	0x127
#define META_ROUNDRECT	0x61C
#define META_SAVEDC	0x1E
#define META_SCALEVIEWPORTEXT	0x412
#define META_SCALEWINDOWEXT	0x410
#define META_SELECTCLIPREGION	0x12C
#define META_SELECTOBJECT	0x12D
#define META_SELECTPALETTE	0x234
#define META_SETBKCOLOR	0x201
#define META_SETBKMODE	0x102
#define META_SETDIBTODEV	0xd33
#define META_SETMAPMODE	0x103
#define META_SETMAPPERFLAGS	0x231
#define META_SETPALENTRIES	0x37
#define META_SETPIXEL	0x41F
#define META_SETPOLYFILLMODE	0x106
#define META_SETRELABS	0x105
#define META_SETROP2	0x104
#define META_SETSTRETCHBLTMODE	0x107
#define META_SETTEXTALIGN	0x12E
#define META_SETTEXTCHAREXTRA	0x108
#define META_SETTEXTCOLOR	0x209
#define META_SETTEXTJUSTIFICATION	0x20A
#define META_SETVIEWPORTEXT	0x20E
#define META_SETVIEWPORTORG	0x20D
#define META_SETWINDOWEXT	0x20C
#define META_SETWINDOWORG	0x20B
#define META_STRETCHBLT	0xB23
#define META_STRETCHDIB	0xf43
#define META_TEXTOUT	0x521
#define PFD_DOUBLEBUFFER 1
#define PFD_STEREO 2
#define PFD_DRAW_TO_WINDOW 4
#define PFD_DRAW_TO_BITMAP 8
#define PFD_SUPPORT_GDI 0x10
#define PFD_SUPPORT_OPENGL 0x20
#define PFD_GENERIC_FORMAT 0x40
#define PFD_NEED_PALETTE 0x80
#define PFD_NEED_SYSTEM_PALETTE 0x100
#define PFD_SWAP_EXCHANGE 0x200
#define PFD_SWAP_COPY 0x400
#define PFD_SWAP_LAYER_BUFFERS 0x800
#define PFD_GENERIC_ACCELERATED	0x1000
#define PFD_TYPE_RGBA 0
#define PFD_TYPE_COLORINDEX 1
#define PFD_MAIN_PLANE 0
#define PFD_OVERLAY_PLANE 1
#define PFD_UNDERLAY_PLANE (-1)
#define QDI_SETDIBITS	1
#define QDI_GETDIBITS	2
#define QDI_DIBTOSCREEN	4
#define QDI_STRETCHDIB	8
#define RAS_MaxDeviceType	16
#define RAS_MaxPhoneNumber	128
#define RAS_MaxIpAddress	15
#define RAS_MaxIpxAddress	21
#define RAS_MaxEntryName	256
#define RAS_MaxDeviceName	128
#define RAS_MaxAreaCode	10
#define RAS_MaxPadType	32
#define RAS_MaxX25Address	200
#define RAS_MaxFacilities	200
#define RAS_MaxUserData	200
#define TME_HOVER 1
#define TME_LEAVE 2
#define TME_NONCLIENT 16
#define TME_QUERY	0x40000000
#define TME_CANCEL	0x80000000
#define HOVER_DEFAULT 0xFFFFFFFF
#define	GA_PARENT	1
#define	GA_ROOT	2
#define	GA_ROOTOWNER	3
#define CBEIF_TEXT	1
#define CBEIF_IMAGE	2
#define CBEIF_SELECTEDIMAGE	4
#define CBEIF_OVERLAY	8
#define CBEIF_INDENT	16
#define CBEIF_LPARAM	32
#define CBEIF_DI_SETITEM	0x10000000
#define HW_PROFILE_GUIDLEN 39
#define MAX_PROFILE_LEN	80
#define DOCKINFO_UNDOCKED	1
#define DOCKINFO_DOCKED	2
#define DOCKINFO_USER_SUPPLIED	4
#define DOCKINFO_USER_UNDOCKED (DOCKINFO_USER_SUPPLIED | DOCKINFO_UNDOCKED)
#define DOCKINFO_USER_DOCKED (DOCKINFO_USER_SUPPLIED | DOCKINFO_DOCKED)
#define FIND_FIRST_EX_CASE_SENSITIVE 1
#define ALL_TRANSPORTS "M\0\0\0"
#define MS_NBF "MNBF"
#define NCBCALL 0x10
#define NCBLISTEN 0x11
#define NCBHANGUP 0x12
#define NCBSEND 0x14
#define NCBRECV 0x15
#define NCBRECVANY 0x16
#define NCBCHAINSEND 0x17
#define NCBDGSEND 0x20
#define NCBDGRECV 0x21
#define NCBDGSENDBC 0x22
#define NCBDGRECVBC 0x23
#define NCBADDNAME 0x30
#define NCBDELNAME 0x31
#define NCBRESET 0x32
#define NCBASTAT 0x33
#define NCBSSTAT 0x34
#define NCBCANCEL 0x35
#define NCBADDGRNAME 0x36
#define NCBENUM 0x37
#define NCBUNLINK 0x70
#define NCBSENDNA 0x71
#define NCBCHAINSENDNA 0x72
#define NCBLANSTALERT 0x73
#define NCBACTION 0x77
#define NCBFINDNAME 0x78
#define NCBTRACE 0x79
#define ASYNCH 0x80
#define NRC_GOODRET 0x00
#define NRC_BUFLEN 0x01
#define NRC_ILLCMD 0x03
#define NRC_CMDTMO 0x05
#define NRC_INCOMP 0x06
#define NRC_BADDR 0x07
#define NRC_SNUMOUT 0x08
#define NRC_NORES 0x09
#define NRC_SCLOSED 0x0a
#define NRC_CMDCAN 0x0b
#define NRC_DUPNAME 0x0d
#define NRC_NAMTFUL 0x0e
#define NRC_ACTSES 0x0f
#define NRC_LOCTFUL 0x11
#define NRC_REMTFUL 0x12
#define NRC_ILLNN 0x13
#define NRC_NOCALL 0x14
#define NRC_NOWILD 0x15
#define NRC_INUSE 0x16
#define NRC_NAMERR 0x17
#define NRC_SABORT 0x18
#define NRC_NAMCONF 0x19
#define NRC_IFBUSY 0x21
#define NRC_TOOMANY 0x22
#define NRC_BRIDGE 0x23
#define NRC_CANOCCR 0x24
#define NRC_CANCEL 0x26
#define NRC_DUPENV 0x30
#define NRC_ENVNOTDEF 0x34
#define NRC_OSRESNOTAV 0x35
#define NRC_MAXAPPS 0x36
#define NRC_NOSAPS 0x37
#define NRC_NORESOURCES 0x38
#define NRC_INVADDRESS 0x39
#define NRC_INVDDID 0x3B
#define NRC_LOCKFAIL 0x3C
#define NRC_OPENERR 0x3f
#define NRC_SYSTEM 0x40
#define NRC_PENDING 0xff
#define NCB_POST void CALLBACK
#define ACL_REVISION	2
#define ACL_REVISION_DS	4
#define ACL_REVISION1	1
#define MIN_ACL_REVISION ACL_REVISION2
#define ACL_REVISION2	2
#define ACL_REVISION3	3
#define ACL_REVISION4	4
#define MAX_ACL_REVISION ACL_REVISION4
#define CONTAINING_RECORD(a,t,f) ((t *)((PCHAR)(a) - (ULONG_PTR)(&((t *)0)->f)))
#define LOGON32_LOGON_INTERACTIVE	2
#define LOGON32_LOGON_NETWORK	3
#define LOGON32_LOGON_BATCH	4
#define LOGON32_LOGON_SERVICE	5
#define LOGON32_LOGON_UNLOCK	7
#define LOGON32_LOGON_NETWORK_CLEARTEXT 8
#define LOGON32_LOGON_NEW_CREDENTIALS 9
#define LOGON32_PROVIDER_DEFAULT	0
#define LOGON32_PROVIDER_WINNT35	1
#define LOGON32_PROVIDER_WINNT40	2
#define LOGON32_PROVIDER_WINNT50	3
#define LOGON_WITH_PROFILE	1
#define LOGON_NETCREDENTIALS_ONLY	2
#define LOGON_ZERO_PASSWORD_BUFFER	0x80000000
#define WINEVENT_OUTOFCONTEXT	0
#define WINEVENT_SKIPOWNTHREAD	1
#define WINEVENT_SKIPOWNPROCESS	2
#define WINEVENT_INCONTEXT	4
#define GetKValue(cmyk)	((BYTE)(cmyk))
#define GetYValue(cmyk)	((BYTE)((cmyk)>> 8))
#define GetMValue(cmyk)	((BYTE)((cmyk)>>16))
#define GetCValue(cmyk)	((BYTE)((cmyk)>>24))
#define GR_GDIOBJECTS	0
#define GR_USEROBJECTS	1
#define ENUM_CURRENT_SETTINGS ((DWORD)-1)
#define ENUM_REGISTRY_SETTINGS ((DWORD)-2)
#define NFS_EDIT	1
#define NFS_STATIC	2
#define NFS_LISTCOMBO	4
#define NFS_BUTTON	8
#define NFS_ALL	0x10
#define NFS_USEFONTASSOC	0x20
#define ENDSESSION_LOGOFF	0x80000000
#define GET_RAWINPUT_CODE_WPARAM(wParam)	((wParam)&0xff)
#define RIM_INPUT	0
#define RIM_INPUTSINK	1
#define RIM_TYPEMOUSE	0
#define RIM_TYPEKEYBOARD	1
#define RIM_TYPEHID	2
#define RI_MOUSE_LEFT_BUTTON_DOWN	1
#define RI_MOUSE_LEFT_BUTTON_UP	2
#define RI_MOUSE_RIGHT_BUTTON_DOWN	4
#define RI_MOUSE_RIGHT_BUTTON_UP	8
#define RI_MOUSE_MIDDLE_BUTTON_DOWN	16
#define RI_MOUSE_MIDDLE_BUTTON_UP	0x20
#define RI_MOUSE_BUTTON_1_DOWN	RI_MOUSE_LEFT_BUTTON_DOWN
#define RI_MOUSE_BUTTON_1_UP	RI_MOUSE_LEFT_BUTTON_UP
#define RI_MOUSE_BUTTON_2_DOWN	RI_MOUSE_RIGHT_BUTTON_DOWN
#define RI_MOUSE_BUTTON_2_UP	RI_MOUSE_RIGHT_BUTTON_UP
#define RI_MOUSE_BUTTON_3_DOWN	RI_MOUSE_MIDDLE_BUTTON_DOWN
#define RI_MOUSE_BUTTON_3_UP	RI_MOUSE_MIDDLE_BUTTON_UP
#define RI_MOUSE_BUTTON_4_DOWN	0x0040
#define RI_MOUSE_BUTTON_4_UP	0x0080
#define RI_MOUSE_BUTTON_5_DOWN	0x0100
#define RI_MOUSE_BUTTON_5_UP	0x0200
#define RI_MOUSE_WHEEL	0x0400
#define MOUSE_MOVE_RELATIVE	0
#define MOUSE_MOVE_ABSOLUTE	1
#define MOUSE_VIRTUAL_DESKTOP	2
#define MOUSE_ATTRIBUTES_CHANGED 4
#define KEYBOARD_OVERRUN_MAKE_CODE	0xFF
#define RI_KEY_MAKE	0
#define RI_KEY_BREAK	1
#define RI_KEY_E0	2
#define RI_KEY_E1	4
#define RI_KEY_TERMSRV_SET_LED	8
#define RI_KEY_TERMSRV_SHADOW	0x10
#define RAWINPUT_ALIGN(x)	(((x) + sizeof(DWORD) - 1) & ~(sizeof(DWORD) - 1))
#define NEXTRAWINPUTBLOCK(ptr) ((PRAWINPUT)RAWINPUT_ALIGN((ULONG_PTR)((PBYTE)(ptr) + (ptr)->header.dwSize)))
#define RID_INPUT	0x10000003
#define RID_HEADER	0x10000005
#define RIDI_PREPARSEDDATA	0x20000005
#define RIDI_DEVICENAME	0x20000007
#define RIDI_DEVICEINFO	0x2000000b
#define RIDEV_REMOVE	1
#define RIDEV_EXCLUDE	0x10
#define RIDEV_PAGEONLY	0x20
#define RIDEV_NOLEGACY	0x30
#define RIDEV_CAPTUREMOUSE	0x200
#define RIDEV_NOHOTKEYS	0x200
#define RIDEV_EXMODEMASK	0x0F0
#define RIDEV_EXMODE(mode) ((mode)&RIDEV_EXMODEMASK)
#define WTS_CONSOLE_CONNECT	0x1
#define WTS_CONSOLE_DISCONNECT	0x2
#define WTS_REMOTE_CONNECT	0x3
#define WTS_REMOTE_DISCONNECT	0x4
#define WTS_SESSION_LOGON	0x5
#define WTS_SESSION_LOGOFF	0x6
#define WTS_SESSION_LOCK	0x7
#define WTS_SESSION_UNLOCK	0x8
#define APPCOMMAND_BROWSER_BACKWARD 1
#define APPCOMMAND_BROWSER_FORWARD 2
#define APPCOMMAND_BROWSER_REFRESH 3
#define APPCOMMAND_BROWSER_STOP 4
#define APPCOMMAND_BROWSER_SEARCH 5
#define APPCOMMAND_BROWSER_FAVORITES 6
#define APPCOMMAND_BROWSER_HOME 7
#define APPCOMMAND_VOLUME_MUTE 8
#define APPCOMMAND_VOLUME_DOWN 9
#define APPCOMMAND_VOLUME_UP 10
#define APPCOMMAND_MEDIA_NEXTTRACK 11
#define APPCOMMAND_MEDIA_PREVIOUSTRACK 12
#define APPCOMMAND_MEDIA_STOP 13
#define APPCOMMAND_MEDIA_PLAY_PAUSE 14
#define APPCOMMAND_LAUNCH_MAIL 15
#define APPCOMMAND_LAUNCH_MEDIA_SELECT 16
#define APPCOMMAND_LAUNCH_APP1 17
#define APPCOMMAND_LAUNCH_APP2 18
#define APPCOMMAND_BASS_DOWN 19
#define APPCOMMAND_BASS_BOOST 20
#define APPCOMMAND_BASS_UP 21
#define APPCOMMAND_TREBLE_DOWN 22
#define APPCOMMAND_TREBLE_UP 23
#define APPCOMMAND_MICROPHONE_VOLUME_MUTE 24
#define APPCOMMAND_MICROPHONE_VOLUME_DOWN 25
#define APPCOMMAND_MICROPHONE_VOLUME_UP 26
#define APPCOMMAND_HELP 27
#define APPCOMMAND_FIND 28
#define APPCOMMAND_NEW 29
#define APPCOMMAND_OPEN 30
#define APPCOMMAND_CLOSE 31
#define APPCOMMAND_SAVE 32
#define APPCOMMAND_PRINT 33
#define APPCOMMAND_UNDO 34
#define APPCOMMAND_REDO 35
#define APPCOMMAND_COPY 36
#define APPCOMMAND_CUT 37
#define APPCOMMAND_PASTE 38
#define APPCOMMAND_REPLY_TO_MAIL 39
#define APPCOMMAND_FORWARD_MAIL 40
#define APPCOMMAND_SEND_MAIL 41
#define APPCOMMAND_SPELL_CHECK 42
#define APPCOMMAND_DICTATE_OR_COMMAND_CONTROL_TOGGLE 43
#define APPCOMMAND_MIC_ON_OFF_TOGGLE 44
#define APPCOMMAND_CORRECTION_LIST 45
#define FAPPCOMMAND_MOUSE 0x8000
#define FAPPCOMMAND_KEY 0
#define FAPPCOMMAND_OEM 0x1000
#define FAPPCOMMAND_MASK 0xF000
#define GET_APPCOMMAND_LPARAM(lParam) ((short)(HIWORD(lParam) & ~FAPPCOMMAND_MASK))
#define GET_DEVICE_LPARAM(lParam) ((WORD)(HIWORD(lParam) & FAPPCOMMAND_MASK))
#define GET_MOUSEORKEY_LPARAM GET_DEVICE_LPARAM
#define GET_FLAGS_LPARAM(lParam) (LOWORD(lParam))
#define GET_KEYSTATE_LPARAM(lParam) GET_FLAGS_LPARAM(lParam)
#define UISF_HIDEFOCUS	1
#define UISF_HIDEACCEL	2
#define UISF_ACTIVE	4
#define UIS_SET	1
#define UIS_CLEAR	2
#define UIS_INITIALIZE	3
#define FLS_OUT_OF_INDEXES ((DWORD)0xFFFFFFFF)
#define TLS_OUT_OF_INDEXES ((DWORD)0xFFFFFFFF)
#define META_SETLAYOUT 0x0149
#define MSGF_MESSAGEBOX 1
#define MSGF_MAX 8
#define ACCESS_STICKYKEYS 1
#define ACCESS_FILTERKEYS 2
#define ACCESS_MOUSEKEYS 3
#define LLKHF_EXTENDED (KF_EXTENDED >> 8)
#define LLKHF_INJECTED 0x00000010
#define LLKHF_ALTDOWN (KF_ALTDOWN >> 8)
#define LLKHF_UP (KF_UP >> 8)
#define LLMHF_INJECTED 1
#define ACCESS_OBJECT_GUID	0
#define ACCESS_PROPERTY_SET_GUID 1
#define ACCESS_PROPERTY_GUID	2
#define ACCESS_MAX_LEVEL	4
#define VER_NT_WORKSTATION	1
#define VER_NT_DOMAIN_CONTROLLER	2
#define VER_NT_SERVER	3
#define VER_SERVER_NT	0x80000000
#define VER_WORKSTATION_NT	0x40000000
#define VER_SUITE_SMALLBUSINESS	1
#define VER_SUITE_ENTERPRISE	2
#define VER_SUITE_BACKOFFICE	4
#define VER_SUITE_COMMUNICATIONS 8
#define VER_SUITE_TERMINAL	0x10
#define VER_SUITE_SMALLBUSINESS_RESTRICTED 0x20
#define VER_SUITE_EMBEDDEDNT	0x40
#define VER_SUITE_DATACENTER	0x80
#define VER_SUITE_SINGLEUSERTS	0x100
#define VER_SUITE_PERSONAL	0x200
#define VER_SUITE_BLADE	0x400
#define VER_SUITE_EMBEDDED_RESTRICTED	0x800
#define VER_SUITE_SECURITY_APPLIANCE 0x1000
#define AC_LINE_OFFLINE	0
#define AC_LINE_ONLINE	1
#define AC_LINE_BACKUP_POWER	2
#define AC_LINE_UNKNOWN	0xFF
#define BATTERY_FLAG_HIGH	1
#define BATTERY_FLAG_LOW	2
#define BATTERY_FLAG_CRITICAL	4
#define BATTERY_FLAG_CHARGING	8
#define BATTERY_FLAG_NO_BATTERY	0x80
#define BATTERY_FLAG_UNKNOWN	0xFF
#define BATTERY_PERCENTAGE_UNKNOWN	0xFF
#define BATTERY_LIFE_UNKNOWN	0xFFFFFFFF
#define JOB_OBJECT_MSG_END_OF_JOB_TIME 1
#define JOB_OBJECT_MSG_END_OF_PROCESS_TIME 2
#define JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT 3
#define JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO 4
#define JOB_OBJECT_MSG_NEW_PROCESS 6
#define JOB_OBJECT_MSG_EXIT_PROCESS 7
#define JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS 8
#define JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT 9
#define JOB_OBJECT_MSG_JOB_MEMORY_LIMIT 10
#define JOB_OBJECT_LIMIT_WORKINGSET	1
#define JOB_OBJECT_LIMIT_PROCESS_TIME	2
#define JOB_OBJECT_LIMIT_JOB_TIME	4
#define JOB_OBJECT_LIMIT_ACTIVE_PROCESS	8
#define JOB_OBJECT_LIMIT_AFFINITY	0x10
#define JOB_OBJECT_LIMIT_PRIORITY_CLASS	0x20
#define JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME 0x40
#define JOB_OBJECT_LIMIT_SCHEDULING_CLASS	0x80
#define JOB_OBJECT_LIMIT_PROCESS_MEMORY	0x100
#define JOB_OBJECT_LIMIT_JOB_MEMORY	0x200
#define JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION 0x400
#define JOB_OBJECT_LIMIT_BREAKAWAY_OK	0x800
#define JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK	0x1000
#define JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE	0x2000
#define JOB_OBJECT_LIMIT_RESERVED2 0x4000
#define JOB_OBJECT_LIMIT_RESERVED3 0x8000
#define JOB_OBJECT_LIMIT_RESERVED4 0x10000
#define JOB_OBJECT_LIMIT_RESERVED5 0x20000
#define JOB_OBJECT_LIMIT_RESERVED6 0x40000
#define JOB_OBJECT_LIMIT_VALID_FLAGS	0x7ffff
#define JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS 0x0ff
#define JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS 0x003fff
#define JOB_OBJECT_RESERVED_LIMIT_VALID_FLAGS 0x07ffff
#define JOB_OBJECT_UILIMIT_NONE	0
#define JOB_OBJECT_UILIMIT_HANDLES	1
#define JOB_OBJECT_UILIMIT_READCLIPBOARD	2
#define JOB_OBJECT_UILIMIT_WRITECLIPBOARD	4
#define JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS	8
#define JOB_OBJECT_UILIMIT_DISPLAYSETTINGS	0x10
#define JOB_OBJECT_UILIMIT_GLOBALATOMS	0x20
#define JOB_OBJECT_UILIMIT_DESKTOP	0x40
#define JOB_OBJECT_UILIMIT_EXITWINDOWS	0x80
#define JOB_OBJECT_UILIMIT_ALL	0xFF
#define JOB_OBJECT_UI_VALID_FLAGS 0xFF
#define JOB_OBJECT_SECURITY_NO_ADMIN	1
#define JOB_OBJECT_SECURITY_RESTRICTED_TOKEN	2
#define JOB_OBJECT_SECURITY_ONLY_TOKEN	4
#define JOB_OBJECT_SECURITY_FILTER_TOKENS	8
#define JOB_OBJECT_SECURITY_VALID_FLAGS	0xf
#define SEF_DACL_AUTO_INHERIT	1
#define SEF_SACL_AUTO_INHERIT	2
#define SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT	4
#define SEF_AVOID_PRIVILEGE_CHECK	8
#define SEF_AVOID_OWNER_CHECK	0x10
#define SEF_DEFAULT_OWNER_FROM_PARENT	0x20
#define SEF_DEFAULT_GROUP_FROM_PARENT	0x40
#define MIM_MAXHEIGHT 1
#define MIM_BACKGROUND 2
#define MIM_HELPID 4
#define MIM_MENUDATA 8
#define MIM_STYLE 0x10
#define MIM_APPLYTOSUBMENUS 0x80000000
#define MNS_NOCHECK 0x80000000
#define MNS_MODELESS 0x40000000
#define MNS_DRAGDROP 0x20000000
#define MNS_AUTODISMISS 0x10000000
#define MNS_NOTIFYBYPOS 0x8000000
#define MNS_CHECKORBMP 0x4000000
#define QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX 4
#define QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE 8
#define QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS 0x10
#define QUERY_ACTCTX_FLAG_NO_ADDREF 0x80000000
#define EVENTLOG_FULL_INFO 0
//#if (_WIN32_IE >= 0x0300)
#define LPTV_HITTESTINFO	LPTVHITTESTINFO
#define TV_HITTESTINFO	TVHITTESTINFO
//#else
//#define tagTVHITTESTINFO	_TV_HITTESTINFO
//#define TVHITTESTINFO	TV_HITTESTINFO
//#define LPTVHITTESTINFO	LPTV_HITTESTINFO
//#endif
#define LWA_COLORKEY	1
#define LWA_ALPHA	2
#define ULW_COLORKEY	1
#define ULW_ALPHA	2
#define ULW_OPAQUE	4
#define ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID 1
#define ACTCTX_FLAG_LANGID_VALID 2
#define ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID 4
#define ACTCTX_FLAG_RESOURCE_NAME_VALID 8
#define ACTCTX_FLAG_SET_PROCESS_DEFAULT 0x10
#define ACTCTX_FLAG_APPLICATION_NAME_VALID 0x20
#define ACTCTX_FLAG_SOURCE_IS_ASSEMBLYREF 0x040
#define ACTCTX_FLAG_HMODULE_VALID 0x080
#define TIME_ZONE_ID_INVALID ((DWORD)0xFFFFFFFF)
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A "GetSystemWow64DirectoryA"
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_A_W L"GetSystemWow64DirectoryA"
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_A_T TEXT("GetSystemWow64DirectoryA")
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A "GetSystemWow64DirectoryW"
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_W_W L"GetSystemWow64DirectoryW"
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_W_T TEXT("GetSystemWow64DirectoryW")
#define HEAP_NO_SERIALIZE	1
#define HEAP_GROWABLE	2
#define HEAP_GENERATE_EXCEPTIONS	4
#define HEAP_ZERO_MEMORY	8
#define HEAP_REALLOC_IN_PLACE_ONLY	0x10
#define HEAP_TAIL_CHECKING_ENABLED	0x020
#define HEAP_FREE_CHECKING_ENABLED	0x040
#define HEAP_DISABLE_COALESCE_ON_FREE	0x080
#define HEAP_CREATE_ALIGN_16	0x010000
#define HEAP_CREATE_ENABLE_TRACING	0x00020000
#define HEAP_CREATE_ENABLE_EXECUTE	0x00040000
#define HEAP_MAXIMUM_TAG	0x0FFF
#define HEAP_PSEUDO_TAG_FLAG 0x8000
#define HEAP_TAG_SHIFT            18
#define HEAP_MAKE_TAG_FLAGS(b,o) ((DWORD)((b)+((o)<<18)))
#define FILE_ENCRYPTABLE 0
#define FILE_IS_ENCRYPTED 1
#define FILE_SYSTEM_ATTR 2
#define FILE_ROOT_DIR 3
#define FILE_SYSTEM_DIR 4
#define FILE_UNKNOWN 5
#define FILE_SYSTEM_NOT_SUPPORT 6
#define FILE_USER_DISALLOWED 7
#define FILE_READ_ONLY 8
#define FILE_DIR_DISALLOWED 9
#define HasOverlappedIoCompleted(lpOverlapped) (((DWORD)(lpOverlapped)->Internal) != STATUS_PENDING)
#define FIBER_FLAG_FLOAT_SWITCH 1
#define DEACTIVATE_ACTCTX_FLAG_FORCE_EARLY_DEACTIVATION 1
#define GET_MODULE_HANDLE_EX_FLAG_PIN 1
#define GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT 2
#define GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS	4
#define FreeModule(hLibModule) FreeLibrary((hLibModule))
#define PROFILE_LINKED	'LINK'
#define PROFILE_EMBEDDED	'MBED'
#define LVCF_IMAGE	0x0010
#define LVCF_ORDER	0x0020
#define LVCFMT_IMAGE	0x0800
#define LVCFMT_BITMAP_ON_RIGHT	0x1000
#define LVCFMT_COL_HAS_IMAGES	0x8000
#define LVCFMT_JUSTIFYMASK	0x0003

#ifdef UNICODE
#define HD_TEXTFILTER HD_TEXTFILTERW
#define HDTEXTFILTER HD_TEXTFILTERW
#define LPHD_TEXTFILTER LPHD_TEXTFILTERW
#define LPHDTEXTFILTER LPHD_TEXTFILTERW
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_W GET_SYSTEM_WOW64_DIRECTORY_NAME_W_W
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_T GET_SYSTEM_WOW64_DIRECTORY_NAME_W_T
#else
#define HD_TEXTFILTER HD_TEXTFILTERA
#define HDTEXTFILTER HD_TEXTFILTERA
#define LPHD_TEXTFILTER LPHD_TEXTFILTERA
#define LPHDTEXTFILTER LPHD_TEXTFILTERA
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_W GET_SYSTEM_WOW64_DIRECTORY_NAME_A_W
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_T GET_SYSTEM_WOW64_DIRECTORY_NAME_A_T
#endif

#define INVALID_LINK_INDEX (-1)
#define MAX_LINKID_TEXT	48
#define L_MAX_URL_LENGTH	(2048 + 32 + sizeof("://"))
#define LWS_TRANSPARENT 1
#define LWS_IGNORERETURN 2
#define LIF_ITEMINDEX 1
#define LIF_STATE 2
#define LIF_ITEMID 4
#define LIF_URL	8
#define LIS_FOCUSED 1
#define LIS_ENABLED 2
#define LIS_VISITED 4
/* Structures.h */
typedef struct tagACTCTXA {
	ULONG     cbSize;
	DWORD     dwFlags;
	LPCSTR    lpSource;
	USHORT    wProcessorArchitecture;
	LANGID    wLangId;
	LPCSTR    lpAssemblyDirectory;
	LPCSTR    lpResourceName;
	LPCSTR    lpApplicationName;
	HMODULE   hModule;
} ACTCTXA, *PACTCTXA;
typedef struct tagACTCTXW {
	ULONG     cbSize;
	DWORD     dwFlags;
	LPCWSTR   lpSource;
	USHORT    wProcessorArchitecture;
	LANGID    wLangId;
	LPCWSTR   lpAssemblyDirectory;
	LPCWSTR   lpResourceName;
	LPCWSTR   lpApplicationName;
	HMODULE   hModule;
} ACTCTXW, *PACTCTXW;
typedef const ACTCTXA *PCACTCTXA;
typedef const ACTCTXW *PCACTCTXW;

//#if !defined(ACTIVATION_CONTEXT_BASIC_INFORMATION_DEFINED)
//typedef struct _ACTIVATION_CONTEXT_BASIC_INFORMATION {
//	HANDLE hActCtx;
//	DWORD  dwFlags;
//} ACTIVATION_CONTEXT_BASIC_INFORMATION, *PACTIVATION_CONTEXT_BASIC_INFORMATION;
//typedef const struct _ACTIVATION_CONTEXT_BASIC_INFORMATION *PCACTIVATION_CONTEXT_BASIC_INFORMATION;
//#define ACTIVATION_CONTEXT_BASIC_INFORMATION_DEFINED 1
//#endif

typedef struct tagWTSSESSION_NOTIFICATION { DWORD cbSize; DWORD dwSessionId; } WTSSESSION_NOTIFICATION, *PWTSSESSION_NOTIFICATION;
//#ifndef RC_INVOKED
typedef struct tagKBDLLHOOKSTRUCT {
	DWORD vkCode;
	DWORD scanCode;
	DWORD flags;
	DWORD time;
	ULONG_PTR dwExtraInfo;
} KBDLLHOOKSTRUCT, *LPKBDLLHOOKSTRUCT, *PKBDLLHOOKSTRUCT;
typedef struct tagHARDWAREHOOKSTRUCT {
	HWND hwnd;
	UINT message;
	WPARAM wParam;
	LPARAM lParam;
} HARDWAREHOOKSTRUCT, *LPHARDWAREHOOKSTRUCT, *PHARDWAREHOOKSTRUCT;
typedef struct tagRAWHID{DWORD dwSizeHid;DWORD dwCount;BYTE bRawData[1];}RAWHID,*PRAWHID,*LPRAWHID;
typedef struct tagRID_DEVICE_INFO_MOUSE {
	DWORD dwId;
	DWORD dwNumberOfButtons;
	DWORD dwSampleRate;
} RID_DEVICE_INFO_MOUSE, *PRID_DEVICE_INFO_MOUSE;
typedef struct tagRID_DEVICE_INFO_KEYBOARD {
	DWORD dwType;
	DWORD dwSubType;
	DWORD dwKeyboardMode;
	DWORD dwNumberOfFunctionKeys;
	DWORD dwNumberOfIndicators;
	DWORD dwNumberOfKeysTotal;
} RID_DEVICE_INFO_KEYBOARD, *PRID_DEVICE_INFO_KEYBOARD;
typedef struct tagRID_DEVICE_INFO_HID {
	DWORD dwVendorId;
	DWORD dwProductId;
	DWORD dwVersionNumber;
	USHORT usUsagePage;
	USHORT usUsage;
} RID_DEVICE_INFO_HID, *PRID_DEVICE_INFO_HID;
typedef struct tagRID_DEVICE_INFO {
	DWORD cbSize;
	DWORD dwType;
	union {
		RID_DEVICE_INFO_MOUSE mouse;
		RID_DEVICE_INFO_KEYBOARD keyboard;
		RID_DEVICE_INFO_HID hid;
	};
} RID_DEVICE_INFO, *PRID_DEVICE_INFO, *LPRID_DEVICE_INFO;
typedef struct tagRAWKEYBOARD {
	USHORT MakeCode;
	USHORT Flags;
	USHORT Reserved;
	USHORT VKey;
	UINT Message;
	ULONG ExtraInformation;
} RAWKEYBOARD, *PRAWKEYBOARD, *LPRAWKEYBOARD;
typedef struct tagRAWINPUTHEADER {
	DWORD dwType;
	DWORD dwSize;
	HANDLE hDevice;
	WPARAM wParam;
} RAWINPUTHEADER, *PRAWINPUTHEADER, *LPRAWINPUTHEADER;
typedef struct tagRAWMOUSE {
	USHORT usFlags;
	union {
		ULONG ulButtons;
		struct {
		USHORT usButtonFlags;
		USHORT usButtonData;
		};
	};
	ULONG ulRawButtons;
	LONG lLastX;
	LONG lLastY;
	ULONG ulExtraInformation;
} RAWMOUSE, *PRAWMOUSE, *LPRAWMOUSE;
typedef struct tagRAWINPUT {
	RAWINPUTHEADER header;
	union {
		RAWMOUSE mouse;
		RAWKEYBOARD keyboard;
		RAWHID hid;
	} data;
} RAWINPUT, *PRAWINPUT, *LPRAWINPUT;
typedef struct tagRAWINPUTDEVICE {
	USHORT usUsagePage;
	USHORT usUsage;
	DWORD dwFlags;
	HWND hwndTarget;
} RAWINPUTDEVICE, *PRAWINPUTDEVICE, *LPRAWINPUTDEVICE;
typedef CONST RAWINPUTDEVICE* PCRAWINPUTDEVICE;
typedef struct tagRAWINPUTDEVICELIST { HANDLE hDevice; DWORD dwType;} RAWINPUTDEVICELIST, *PRAWINPUTDEVICELIST;
typedef union _LARGE_INTEGER {
	struct { DWORD LowPart; LONG HighPart;};
	struct { DWORD LowPart; LONG HighPart; } u;
	long long int QuadPart;
} LARGE_INTEGER,*PLARGE_INTEGER;
typedef DWORD (WINAPI *LPPROGRESS_ROUTINE)(LARGE_INTEGER,LARGE_INTEGER,LARGE_INTEGER,LARGE_INTEGER,DWORD,DWORD,HANDLE,HANDLE,LPVOID);
typedef struct _ABC {
	int abcA;
	UINT abcB;
	int abcC;
} ABC,*LPABC;
typedef struct _ABCFLOAT {
	FLOAT abcfA;
	FLOAT abcfB;
	FLOAT abcfC;
} ABCFLOAT,*LPABCFLOAT;
#pragma pack(push,2)
typedef struct tagACCEL {
	BYTE fVirt;
	WORD key;
	WORD cmd;
} ACCEL,*LPACCEL;
#pragma pack(pop)
typedef struct _ACE_HEADER {
	BYTE AceType;
	BYTE AceFlags;
	WORD AceSize;
} ACE_HEADER;
typedef DWORD ACCESS_MASK;
typedef ACCESS_MASK REGSAM;
typedef struct _ACCESS_ALLOWED_ACE {
	ACE_HEADER Header;
	ACCESS_MASK Mask;
	DWORD SidStart;
} ACCESS_ALLOWED_ACE;
typedef struct _ACCESS_DENIED_ACE {
	ACE_HEADER Header;
	ACCESS_MASK Mask;
	DWORD SidStart;
} ACCESS_DENIED_ACE;
typedef struct tagACCESSTIMEOUT {
	UINT cbSize;
	DWORD dwFlags;
	DWORD iTimeOutMSec;
} ACCESSTIMEOUT;
typedef struct _ACL {
	BYTE AclRevision;
	BYTE Sbz1;
	WORD AclSize;
	WORD AceCount;
	WORD Sbz2;
} ACL,*PACL;
typedef struct _ACL_REVISION_INFORMATION {
	DWORD AclRevision;
} ACL_REVISION_INFORMATION;
typedef struct _ACL_SIZE_INFORMATION {
	DWORD AceCount;
	DWORD AclBytesInUse;
	DWORD AclBytesFree;
} ACL_SIZE_INFORMATION;
typedef struct _ACTION_HEADER {
	ULONG transport_id;
	USHORT action_code;
	USHORT reserved;
} ACTION_HEADER;
typedef struct _ADAPTER_STATUS {
	UCHAR adapter_address[6];
	UCHAR rev_major;
	UCHAR reserved0;
	UCHAR adapter_type;
	UCHAR rev_minor;
	WORD duration;
	WORD frmr_recv;
	WORD frmr_xmit;
	WORD iframe_recv_err;
	WORD xmit_aborts;
	DWORD xmit_success;
	DWORD recv_success;
	WORD iframe_xmit_err;
	WORD recv_buff_unavail;
	WORD t1_timeouts;
	WORD ti_timeouts;
	DWORD reserved1;
	WORD free_ncbs;
	WORD max_cfg_ncbs;
	WORD max_ncbs;
	WORD xmit_buf_unavail;
	WORD max_dgram_size;
	WORD pending_sess;
	WORD max_cfg_sess;
	WORD max_sess;
	WORD max_sess_pkt_size;
	WORD name_count;
} ADAPTER_STATUS;
typedef struct tagANIMATIONINFO {
	UINT cbSize;
	int iMinAnimate;
} ANIMATIONINFO,*LPANIMATIONINFO;
typedef struct _RECT {
	LONG left;
	LONG top;
	LONG right;
	LONG bottom;
} RECT,*LPRECT;
typedef struct _RECT *PRECT;
typedef const RECT *LPCRECT;
typedef struct _RECTL {
	LONG left;
	LONG top;
	LONG right;
	LONG bottom;
} RECTL,*LPRECTL;
typedef const RECTL *LPCRECTL;
typedef struct tagBITMAP {
	LONG bmType;
	LONG bmWidth;
	LONG bmHeight;
	LONG bmWidthBytes;
	WORD bmPlanes;
	WORD bmBitsPixel;
	LPVOID bmBits;
} BITMAP,*PBITMAP,*NPBITMAP,*LPBITMAP;
typedef struct tagBITMAPCOREHEADER {
	DWORD bcSize;
	WORD bcWidth;
	WORD bcHeight;
	WORD bcPlanes;
	WORD bcBitCount;
} BITMAPCOREHEADER;
 /* was missing jn */
typedef BITMAPCOREHEADER *LPBITMAPCOREHEADER;
typedef struct tagRGBTRIPLE {
	BYTE rgbtBlue;
	BYTE rgbtGreen;
	BYTE rgbtRed;
} RGBTRIPLE;
typedef struct _BITMAPCOREINFO {
	BITMAPCOREHEADER bmciHeader;
	RGBTRIPLE bmciColors[1];
} BITMAPCOREINFO;
/* was missing jn */
typedef BITMAPCOREINFO *LPBITMAPCOREINFO;
typedef struct tagBITMAPFILEHEADER {
	WORD bfType;
	DWORD bfSize;
	WORD bfReserved1;
	WORD bfReserved2;
	DWORD bfOffBits;
} BITMAPFILEHEADER,*LPBITMAPFILEHEADER,*PBITMAPFILEHEADER;
typedef struct tagBITMAPINFOHEADER {
	DWORD biSize;
	LONG biWidth;
	LONG biHeight;
	WORD biPlanes;
	WORD biBitCount;
	DWORD biCompression;
	DWORD biSizeImage;
	LONG biXPelsPerMeter;
	LONG biYPelsPerMeter;
	DWORD biClrUsed;
	DWORD biClrImportant;
} BITMAPINFOHEADER,*LPBITMAPINFOHEADER,*PBITMAPINFOHEADER;
typedef struct tagRGBQUAD {
	BYTE rgbBlue;
	BYTE rgbGreen;
	BYTE rgbRed;
	BYTE rgbReserved;
} RGBQUAD,*LPRGBQUAD;
typedef struct tagBITMAPINFO {
	BITMAPINFOHEADER bmiHeader;
	RGBQUAD bmiColors[1];
} BITMAPINFO,*LPBITMAPINFO,*PBITMAPINFO;
typedef long FXPT2DOT30,*LPFXPT2DOT30;
typedef struct tagCIEXYZ {
	FXPT2DOT30 ciexyzX;
	FXPT2DOT30 ciexyzY;
	FXPT2DOT30 ciexyzZ;
} CIEXYZ;
typedef CIEXYZ *LPCIEXYZ;
typedef struct tagICEXYZTRIPLE {
	CIEXYZ ciexyzRed;
	CIEXYZ ciexyzGreen;
	CIEXYZ ciexyzBlue;
} CIEXYZTRIPLE, *LPCIEXYZTRIPLE;
typedef struct {
	DWORD bV4Size;
	LONG bV4Width;
	LONG bV4Height;
	WORD bV4Planes;
	WORD bV4BitCount;
	DWORD bV4V4Compression;
	DWORD bV4SizeImage;
	LONG bV4XPelsPerMeter;
	LONG bV4YPelsPerMeter;
	DWORD bV4ClrUsed;
	DWORD bV4ClrImportant;
	DWORD bV4RedMask;
	DWORD bV4GreenMask;
	DWORD bV4BlueMask;
	DWORD bV4AlphaMask;
	DWORD bV4CSType;
	CIEXYZTRIPLE bV4Endpoints;
	DWORD bV4GammaRed;
	DWORD bV4GammaGreen;
	DWORD bV4GammaBlue;
} BITMAPV4HEADER,*LPBITMAPV4HEADER,*PBITMAPV4HEADER;
typedef struct {
	DWORD bV5Size;
	LONG bV5Width;
	LONG bV5Height;
	WORD bV5Planes;
	WORD bV5BitCount;
	DWORD bV5Compression;
	DWORD bV5SizeImage;
	LONG bV5XPelsPerMeter;
	LONG bV5YPelsPerMeter;
	DWORD bV5ClrUsed;
	DWORD bV5ClrImportant;
	DWORD bV5RedMask;
	DWORD bV5GreenMask;
	DWORD bV5BlueMask;
	DWORD bV5AlphaMask;
	DWORD bV5CSType;
	CIEXYZTRIPLE bV5Endpoints;
	DWORD bV5GammaRed;
	DWORD bV5GammaGreen;
	DWORD bV5GammaBlue;
	DWORD bV5Intent;
	DWORD bV5ProfileData;
	DWORD bV5ProfileSize;
	DWORD bV5Reserved;
} BITMAPV5HEADER, *LPBITMAPV5HEADER, *PBITMAPV5HEADER;

//#ifndef _SHITEMID_DEFINED
typedef struct _SHITEMID { USHORT cb; BYTE abID[1]; } SHITEMID,*LPSHITEMID;
#define _SHITEMID_DEFINED
//#endif
typedef const SHITEMID *LPCSHITEMID;
//#ifndef _ITEMIDLIST_DEFINED
#define _ITEMIDLIST_DEFINED
typedef struct _ITEMIDLIST { SHITEMID mkid; } ITEMIDLIST,*LPITEMIDLIST;
//#endif
typedef const ITEMIDLIST *LPCITEMIDLIST;
typedef struct _browseinfo {
	HWND hwndOwner;
	LPCITEMIDLIST pidlRoot;
	LPSTR pszDisplayName;
	LPCSTR lpszTitle;
	UINT ulFlags;
	BFFCALLBACK lpfn;
	LPARAM lParam;
	int iImage;
} BROWSEINFO,*PBROWSEINFO,*LPBROWSEINFO;
typedef struct tagFILETIME {
	DWORD dwLowDateTime;
	DWORD dwHighDateTime;
} FILETIME,*LPFILETIME,*PFILETIME;
#define _FILETIME
typedef struct _BY_HANDLE_FILE_INFORMATION {
	DWORD dwFileAttributes;
	FILETIME ftCreationTime;
	FILETIME ftLastAccessTime;
	FILETIME ftLastWriteTime;
	DWORD dwVolumeSerialNumber;
	DWORD nFileSizeHigh;
	DWORD nFileSizeLow;
	DWORD nNumberOfLinks;
	DWORD nFileIndexHigh;
	DWORD nFileIndexLow;
} BY_HANDLE_FILE_INFORMATION,*LPBY_HANDLE_FILE_INFORMATION;
typedef struct _FIXED {
	WORD fract;
	short value;
} FIXED;
typedef struct tagPOINT {
	LONG x;
	LONG y;
} POINT,*PPOINT;
#define LPPOINT PPOINT
typedef struct tagPOINTFX {
	FIXED x;
	FIXED y;
} POINTFX;
typedef struct _POINTL {
	LONG x;
	LONG y;
} POINTL;
typedef struct tagPOINTS {
	SHORT x;
	SHORT y;
} POINTS;
typedef struct tagCREATESTRUCT {
	LPVOID lpCreateParams;
	HINSTANCE hInstance;
	HMENU hMenu;
	HWND hwndParent;
	int cy;
	int cx;
	int y;
	int x;
	LONG style;
	LPCTSTR lpszName;
	LPCTSTR lpszClass;
	DWORD dwExStyle;
} CREATESTRUCT,*LPCREATESTRUCT;
typedef struct tagCBT_CREATEWNDA {
	struct tagCREATESTRUCTA *lpcs;
	HWND	hwndInsertAfter;
} CBT_CREATEWNDA, *LPCBT_CREATEWNDA;
typedef struct tagCBT_CREATEWNDW {
	struct tagCREATESTRUCTW *lpcs;
	HWND hwndInsertAfter;
} CBT_CREATEWNDW, *LPCBT_CREATEWNDW;

#ifdef UNICODE
typedef ACTCTXW ACTCTX;
typedef PACTCTXW PACTCTX;
typedef CBT_CREATEWNDW CBT_CREATEWND;
typedef LPCBT_CREATEWNDW LPCBT_CREATEWND;
#else
typedef ACTCTXA ACTCTX;
typedef PACTCTXA PACTCTX;
typedef CBT_CREATEWNDA CBT_CREATEWND;
typedef LPCBT_CREATEWNDA LPCBT_CREATEWND;
#endif

typedef struct tagCBTACTIVATESTRUCT {
	BOOL fMouse;
	HWND hWndActive;
} CBTACTIVATESTRUCT, *LPCBTACTIVATESTRUCT;
#define WTS_CONSOLE_CONNECT		1
#define WTS_CONSOLE_DISCONNECT		2
#define WTS_REMOTE_CONNECT		3
#define WTS_REMOTE_DISCONNECT		4
#define WTS_SESSION_LOGON		5
#define WTS_SESSION_LOGOFF		6
#define WTS_SESSION_LOCK		7
#define WTS_SESSION_UNLOCK		8
#define WTS_SESSION_REMOTE_CONTROL	9
typedef struct _CHAR_INFO {
	union { WCHAR UnicodeChar; CHAR AsciiChar; } Char;
	WORD Attributes;
} CHAR_INFO,*PCHAR_INFO;
typedef struct tagMSLLHOOKSTRUCT {
	POINT pt;
	DWORD mouseData;
	DWORD flags;
	DWORD time;
	ULONG_PTR dwExtraInfo;
} MSLLHOOKSTRUCT, *LPMSLLHOOKSTRUCT, *PMSLLHOOKSTRUCT;
#ifndef _CHARRANGE_DEFINED
#define _CHARRANGE_DEFINED
typedef struct _charrange { LONG cpMin; LONG cpMax; } CHARRANGE;
#endif
typedef struct tagCHARSET { DWORD aflBlock[3]; DWORD flLang; } CHARSET;
typedef struct tagFONTSIGNATURE { DWORD fsUsb[4]; DWORD fsCsb[2]; }
	FONTSIGNATURE,*LPFONTSIGNATURE;
typedef struct {
	UINT ciCharset;
	UINT ciACP;
	FONTSIGNATURE fs;
} CHARSETINFO,*LPCHARSETINFO;
typedef struct {
	DWORD lStructSize;
	HWND hwndOwner;
	HWND hInstance;
	COLORREF rgbResult;
	COLORREF *lpCustColors;
	DWORD Flags;
	LPARAM lCustData;
	LPCCHOOKPROC lpfnHook;
	LPCTSTR lpTemplateName;
} CHOOSECOLOR,*LPCHOOSECOLOR;
typedef struct tagLOGFONTA {
	LONG	lfHeight;
	LONG	lfWidth;
	LONG	lfEscapement;
	LONG	lfOrientation;
	LONG	lfWeight;
	BYTE	lfItalic;
	BYTE	lfUnderline;
	BYTE	lfStrikeOut;
	BYTE	lfCharSet;
	BYTE	lfOutPrecision;
	BYTE	lfClipPrecision;
	BYTE	lfQuality;
	BYTE	lfPitchAndFamily;
	CHAR	lfFaceName[LF_FACESIZE];
} LOGFONTA, *PLOGFONTA, NEAR *NPLOGFONTA, FAR *LPLOGFONTA;
typedef struct tagLOGFONTW
{
	LONG	lfHeight;
	LONG	lfWidth;
	LONG	lfEscapement;
	LONG	lfOrientation;
	LONG	lfWeight;
	BYTE	lfItalic;
	BYTE	lfUnderline;
	BYTE	lfStrikeOut;
	BYTE	lfCharSet;
	BYTE	lfOutPrecision;
	BYTE	lfClipPrecision;
	BYTE	lfQuality;
	BYTE	lfPitchAndFamily;
	WCHAR	lfFaceName[LF_FACESIZE];
} LOGFONTW, *PLOGFONTW, *NPLOGFONTW, *LPLOGFONTW;
#ifdef UNICODE
typedef LOGFONTW LOGFONT;
typedef PLOGFONTW PLOGFONT;
typedef NPLOGFONTW NPLOGFONT;
typedef LPLOGFONTW LPLOGFONT;
#else
typedef LOGFONTA LOGFONT;
typedef PLOGFONTA PLOGFONT;
typedef NPLOGFONTA NPLOGFONT;
typedef LPLOGFONTA LPLOGFONT;
#endif
typedef struct {
	DWORD lStructSize;
	HWND hwndOwner;
	HDC hDC;
	LPLOGFONT lpLogFont;
	INT iPointSize;
	DWORD Flags;
	DWORD rgbColors;
	LPARAM lCustData;
	LPCFHOOKPROC lpfnHook;
	LPCTSTR lpTemplateName;
	HINSTANCE hInstance;
	LPTSTR lpszStyle;
	WORD nFontType;
	WORD ___MISSING_ALIGNMENT__;
	INT nSizeMin;
	INT nSizeMax;
} CHOOSEFONT,*LPCHOOSEFONT;
#ifndef _IDA_DEFINED
#define _IDA_DEFINED
typedef struct _IDA { UINT cidl; UINT aoffset[1]; } CIDA,*LPIDA;
#endif
typedef struct tagCLIENTCREATESTRUCT {
	HANDLE hWindowMenu;
	UINT idFirstChild;
} CLIENTCREATESTRUCT;
typedef struct tagCOLORADJUSTMENT {
	WORD caSize;
	WORD caFlags;
	WORD caIlluminantIndex;
	WORD caRedGamma;
	WORD caGreenGamma;
	WORD caBlueGamma;
	WORD caReferenceBlack;
	WORD caReferenceWhite;
	SHORT caContrast;
	SHORT caBrightness;
	SHORT caColorfulness;
	SHORT caRedGreenTint;
} COLORADJUSTMENT,*LPCOLORADJUSTMENT;
typedef struct _COLORMAP {
	COLORREF from;
	COLORREF to;
} COLORMAP,*LPCOLORMAP;
typedef struct _DCB {
	DWORD DCBlength;
	DWORD BaudRate;
	unsigned fBinary:1;
	unsigned fParity:1;
	unsigned fOutxCtsFlow:1;
	unsigned fOutxDsrFlow:1;
	unsigned fDtrControl:2;
	unsigned fDsrSensitivity:1;
	unsigned fTXContinueOnXoff:1;
	unsigned fOutX:1;
	unsigned fInX:1;
	unsigned fErrorChar:1;
	unsigned fNull:1;
	unsigned fRtsControl:2;
	unsigned fAbortOnError:1;
	unsigned fDummy2:17;
	WORD wReserved;
	WORD XonLim;
	WORD XoffLim;
	BYTE ByteSize;
	BYTE Parity;
	BYTE StopBits;
	char XonChar;
	char XoffChar;
	char ErrorChar;
	char EofChar;
	char EvtChar;
	WORD wReserved1;
} DCB,*LPDCB;
typedef struct _DEC { USHORT wReserved; BYTE scale; BYTE sign;
 ULONG Hi32; long long int Lo64; } DECIMAL;
typedef struct tagBLOB { ULONG cbSize; BYTE *pBlobData; } BLOB;
typedef struct tagBLOB *LPBLOB;
#define _LPBLOB_DEFINED
typedef struct _COMM_CONFIG {
	DWORD dwSize;
	WORD wVersion;
	WORD wReserved;
	DCB dcb;
	DWORD dwProviderSubType;
	DWORD dwProviderOffset;
	DWORD dwProviderSize;
	WCHAR wcProviderData[2];
} COMMCONFIG,*LPCOMMCONFIG;
typedef struct _COMMPROP {
	WORD wPacketLength;
	WORD wPacketVersion;
	DWORD dwServiceMask;
	DWORD dwReserved1;
	DWORD dwMaxTxQueue;
	DWORD dwMaxRxQueue;
	DWORD dwMaxBaud;
	DWORD dwProvSubType;
	DWORD dwProvCapabilities;
	DWORD dwSettableParams;
	DWORD dwSettableBaud;
	WORD wSettableData;
	WORD wSettableStopParity;
	DWORD dwCurrentTxQueue;
	DWORD dwCurrentRxQueue;
	DWORD dwProvSpec1;
	DWORD dwProvSpec2;
	WCHAR wcProvChar[1];
} COMMPROP,*LPCOMMPROP;
typedef struct _COMMTIMEOUTS {
	DWORD ReadIntervalTimeout;
	DWORD ReadTotalTimeoutMultiplier;
	DWORD ReadTotalTimeoutConstant;
	DWORD WriteTotalTimeoutMultiplier;
	DWORD WriteTotalTimeoutConstant;
} COMMTIMEOUTS,*LPCOMMTIMEOUTS;
typedef struct tagCOMPAREITEMSTRUCT {
	UINT CtlType;
	UINT CtlID;
	HWND hwndItem;
	UINT itemID1;
	DWORD itemData1;
	UINT itemID2;
	DWORD itemData2;
} COMPAREITEMSTRUCT;
typedef struct _COMSTAT {
	unsigned fCtsHold:1;
	unsigned fDsrHold:1;
	unsigned fRlsdHold:1;
	unsigned fXoffHold:1;
	unsigned fXoffSent:1;
	unsigned fEof:1;
	unsigned fTxim:1;
	unsigned fReserved:25;
	DWORD cbInQue;
	DWORD cbOutQue;
} COMSTAT,*LPCOMSTAT;
typedef struct _CONSOLE_CURSOR_INFO {
	DWORD dwSize;
	BOOL bVisible;
} CONSOLE_CURSOR_INFO,*PCONSOLE_CURSOR_INFO;
typedef struct _COORD {
	SHORT X;
	SHORT Y;
} COORD;
typedef struct _SMALL_RECT {
	SHORT Left;
	SHORT Top;
	SHORT Right;
	SHORT Bottom;
} SMALL_RECT,*PSMALL_RECT;
typedef struct _CONSOLE_SCREEN_BUFFER_INFO {
	COORD dwSize;
	COORD dwCursorPosition;
	WORD wAttributes;
	SMALL_RECT srWindow;
	COORD dwMaximumWindowSize;
} CONSOLE_SCREEN_BUFFER_INFO,*PCONSOLE_SCREEN_BUFFER_INFO;
#ifndef _CONTEXT_DEFINED_
#define _CONTEXT_DEFINED_
#define MAXIMUM_SUPPORTED_EXTENSION	512
typedef struct _FLOATING_SAVE_AREA {
	DWORD ControlWord;
	DWORD StatusWord;
	DWORD TagWord;
	DWORD ErrorOffset;
	DWORD ErrorSelector;
	DWORD DataOffset;
	DWORD DataSelector;
	BYTE RegisterArea[80];
	DWORD Cr0NpxState;
} FLOATING_SAVE_AREA;
typedef struct _CONTEXT {
	DWORD ContextFlags;
	DWORD Dr0;
	DWORD Dr1;
	DWORD Dr2;
	DWORD Dr3;
	DWORD Dr6;
	DWORD Dr7;
	FLOATING_SAVE_AREA FloatSave;
	DWORD SegGs;
	DWORD SegFs;
	DWORD SegEs;
	DWORD SegDs;
	DWORD Edi;
	DWORD Esi;
	DWORD Ebx;
	DWORD Edx;
	DWORD Ecx;
	DWORD Eax;
	DWORD Ebp;
	DWORD Eip;
	DWORD SegCs;
	DWORD EFlags;
	DWORD Esp;
	DWORD SegSs;
	BYTE ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];
} CONTEXT,*PCONTEXT,*LPCONTEXT;
#endif
typedef struct _POWER_DEVICE_TIMEOUTS {
 DWORD ConservationIdleTime;
 DWORD PerformanceIdleTime;
} POWER_DEVICE_TIMEOUTS, *PPOWER_DEVICE_TIMEOUTS;
typedef struct _LIST_ENTRY {
	struct _LIST_ENTRY *Flink;
	struct _LIST_ENTRY *Blink;
} LIST_ENTRY,*PLIST_ENTRY;
typedef struct _RTL_CRITICAL_SECTION_DEBUG {
	WORD Type;
	WORD CreatorBackTraceIndex;
	struct _RTL_CRITICAL_SECTION *CriticalSection;
	LIST_ENTRY ProcessLocksList;
	DWORD EntryCount;
	DWORD ContentionCount;
	DWORD Spare[ 2];
} RTL_CRITICAL_SECTION_DEBUG,*PRTL_CRITICAL_SECTION_DEBUG,RTL_RESOURCE_DEBUG,*PRTL_RESOURCE_DEBUG;
typedef struct _SECURITY_QUALITY_OF_SERVICE {
	DWORD Length;
	SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
	BOOL ContextTrackingMode;
	BOOLEAN EffectiveOnly;
} SECURITY_QUALITY_OF_SERVICE;
typedef struct tagCONVCONTEXT {
	UINT cb;
	UINT wFlags;
	UINT wCountryID;
	int iCodePage;
	DWORD dwLangID;
	DWORD dwSecurity;
	SECURITY_QUALITY_OF_SERVICE qos;
} CONVCONTEXT;
typedef struct tagCONVINFO {
	DWORD cb;
	DWORD hUser;
	HCONV hConvPartner;
	HSZ hszSvcPartner;
	HSZ hszServiceReq;
	HSZ hszTopic;
	HSZ hszItem;
	UINT wFmt;
	UINT wType;
	UINT wStatus;
	UINT wConvst;
	UINT wLastError;
	HCONVLIST hConvList;
	CONVCONTEXT ConvCtxt;
	HWND hwnd;
	HWND hwndPartner;
} CONVINFO;
typedef struct tagCOPYDATASTRUCT {
	DWORD dwData;
	DWORD cbData;
	PVOID lpData;
} COPYDATASTRUCT,*PCOPYDATASTRUCT;
typedef struct tagMDINEXTMENU {
	HMENU hmenuIn;
	HMENU hmenuNext;
	HWND hwndNext;
} MDINEXTMENU,*PMDINEXTMENU, *LPMDINEXTMENU;
typedef struct _cpinfo {
	UINT MaxCharSize;
	BYTE DefaultChar[MAX_DEFAULTCHAR];
	BYTE LeadByte[MAX_LEADBYTES];
} CPINFO,*LPCPINFO;
typedef struct _CREATE_PROCESS_DEBUG_INFO {
	HANDLE hFile;
	HANDLE hProcess;
	HANDLE hThread;
	LPVOID lpBaseOfImage;
	DWORD dwDebugInfoFileOffset;
	DWORD nDebugInfoSize;
	LPVOID lpThreadLocalBase;
	LPTHREAD_START_ROUTINE lpStartAddress;
	LPVOID lpImageName;
	WORD fUnicode;
} CREATE_PROCESS_DEBUG_INFO,*LPCREATE_PROCESS_DEBUG_INFO;
typedef struct _CREATE_THREAD_DEBUG_INFO {
	HANDLE hThread;
	LPVOID lpThreadLocalBase;
	LPTHREAD_START_ROUTINE lpStartAddress;
} CREATE_THREAD_DEBUG_INFO,*LPCREATE_THREAD_DEBUG_INFO;
typedef struct _currencyfmtA {
	UINT NumDigits;
	UINT LeadingZero;
	UINT Grouping;
	LPSTR lpDecimalSep;
	LPSTR lpThousandSep;
	UINT NegativeOrder;
	UINT PositiveOrder;
	LPTSTR lpCurrencySymbol;
} CURRENCYFMTA,*LPCURRENCYFMTA;
typedef struct _currencyfmtW {
	UINT NumDigits;
	UINT LeadingZero;
	UINT Grouping;
	LPWSTR lpDecimalSep;
	LPWSTR lpThousandSep;
	UINT NegativeOrder;
	UINT PositiveOrder;
	LPWSTR lpCurrencySymbol;
} CURRENCYFMTW,*LPCURRENCYFMTW;
typedef struct tagCURSORSHAPE {
	int xHotSpot;
	int yHotSpot;
	int cx;
	int cy;
	int cbWidth;
	BYTE Planes;
	BYTE BitsPixel;
} CURSORSHAPE,*LPCURSORSHAPE;
typedef struct tagCWPRETSTRUCT {
	LRESULT lResult;
	LPARAM lParam;
	WPARAM wParam;
	DWORD message;
	HWND hwnd;
} CWPRETSTRUCT;
typedef struct tagCWPSTRUCT {
	LPARAM lParam;
	WPARAM wParam;
	UINT message;
	HWND hwnd;
} CWPSTRUCT,*PWCWPSTRUCT;
typedef struct {
	unsigned bAppReturnCode:8,reserved:6,fBusy:1,fAck:1;
} DDEACK;
typedef struct {
	unsigned reserved:14,fDeferUpd:1,fAckReq:1;
	short cfFormat;
} DDEADVISE;
typedef struct {
	unsigned unused:12,fResponse:1,fRelease:1,reserved:1,fAckReq:1;
	short cfFormat;
	BYTE Value[1];
} DDEDATA;
typedef struct {
	unsigned unused:13,fRelease:1,fDeferUpd:1,fAckReq:1;
	short cfFormat;
} DDELN;
typedef struct tagDDEML_MSG_HOOK_DATA {
	UINT uiLo;
	UINT uiHi;
	DWORD cbData;
	DWORD Data[8];
} DDEML_MSG_HOOK_DATA;
typedef struct {
	unsigned unused:13,fRelease:1,fReserved:2;
	short cfFormat;
	BYTE Value[1];
} DDEPOKE;
typedef struct {
	unsigned unused:12,fAck:1,fRelease:1,fReserved:1,fAckReq:1;
	short cfFormat;
	BYTE rgb[1];
} DDEUP;
#ifndef _EXCEPTION_RECORD_DEFINED_
#define _EXCEPTION_RECORD_DEFINED_
typedef struct _EXCEPTION_RECORD {
	DWORD ExceptionCode;
	DWORD ExceptionFlags;
	struct _EXCEPTION_RECORD *ExceptionRecord;
	PVOID ExceptionAddress;
	DWORD NumberParameters;
	DWORD ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD,*PEXCEPTION_RECORD,*LPEXCEPTION_RECORD;
#endif
typedef struct _EXCEPTION_DEBUG_INFO {
	EXCEPTION_RECORD ExceptionRecord;
	DWORD dwFirstChance;
} EXCEPTION_DEBUG_INFO;
typedef struct _EXIT_PROCESS_DEBUG_INFO {
	DWORD dwExitCode;
} EXIT_PROCESS_DEBUG_INFO;
typedef struct _EXIT_THREAD_DEBUG_INFO {
	DWORD dwExitCode;
} EXIT_THREAD_DEBUG_INFO;
typedef struct _LOAD_DLL_DEBUG_INFO {
	HANDLE hFile;
	LPVOID lpBaseOfDll;
	DWORD dwDebugInfoFileOffset;
	DWORD nDebugInfoSize;
	LPVOID lpImageName;
	WORD fUnicode;
} LOAD_DLL_DEBUG_INFO;
typedef struct _UNLOAD_DLL_DEBUG_INFO {
	LPVOID lpBaseOfDll;
} UNLOAD_DLL_DEBUG_INFO;
typedef struct _OUTPUT_DEBUG_STRING_INFO {
	LPSTR lpDebugStringData;
	WORD fUnicode;
	WORD nDebugStringLength;
} OUTPUT_DEBUG_STRING_INFO;
typedef struct _RIP_INFO {
	DWORD dwError;
	DWORD dwType;
} RIP_INFO;
typedef struct _DEBUG_EVENT {
	DWORD dwDebugEventCode;
	DWORD dwProcessId;
	DWORD dwThreadId;
	union {
		EXCEPTION_DEBUG_INFO Exception;
		CREATE_THREAD_DEBUG_INFO CreateThread;
		CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
		EXIT_THREAD_DEBUG_INFO ExitThread;
		EXIT_PROCESS_DEBUG_INFO ExitProcess;
		LOAD_DLL_DEBUG_INFO LoadDll;
		UNLOAD_DLL_DEBUG_INFO UnloadDll;
		OUTPUT_DEBUG_STRING_INFO DebugString;
		RIP_INFO RipInfo;
	} u;
} DEBUG_EVENT,*LPDEBUG_EVENT;
typedef struct tagDEBUGHOOKINFO {
	DWORD idThread;
	DWORD idThreadInstaller;
	LPARAM lParam;
	WPARAM wParam;
	int code;
} DEBUGHOOKINFO;
#ifndef _EXCEPTION_POINTERS_DEFINED_
#define _EXCEPTION_POINTERS_DEFINED_
typedef struct _EXCEPTION_POINTERS {
	PEXCEPTION_RECORD ExceptionRecord;
	PCONTEXT ContextRecord;
} EXCEPTION_POINTERS,*PEXCEPTION_POINTERS,*LPEXCEPTION_POINTERS;
#endif
typedef LONG( * PTOP_LEVEL_EXCEPTION_FILTER) (struct _EXCEPTION_POINTERS * ExceptionInfo);
typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;
typedef struct tagDELETEITEMSTRUCT {
	UINT CtlType;
	UINT CtlID;
	UINT itemID;
	HWND hwndItem;
	UINT itemData;
} DELETEITEMSTRUCT,*LPDELETEITEMSTRUCT,*PDELETEITEMSTRUCT;
typedef struct _DEV_BROADCAST_HDR {
	ULONG dbch_size;
	ULONG dbch_devicetype;
	ULONG dbch_reserved;
} DEV_BROADCAST_HDR;
typedef DEV_BROADCAST_HDR *PDEV_BROADCAST_HDR;
typedef struct _DEV_BROADCAST_OEM {
	ULONG dbco_size;
	ULONG dbco_devicetype;
	ULONG dbco_reserved;
	ULONG dbco_identifier;
	ULONG dbco_suppfunc;
} DEV_BROADCAST_OEM;
typedef DEV_BROADCAST_OEM *PDEV_BROADCAST_OEM;
typedef struct _DEV_BROADCAST_PORT {
	ULONG dbcp_size;
	ULONG dbcp_devicetype;
	ULONG dbcp_reserved;
	char dbcp_name[1];
} DEV_BROADCAST_PORT;
typedef DEV_BROADCAST_PORT *PDEV_BROADCAST_PORT;
struct _DEV_BROADCAST_USERDEFINED {
	struct _DEV_BROADCAST_HDR dbud_dbh;
	char dbud_szName[1];
	BYTE dbud_rgbUserDefined[1];
};
typedef struct _DEV_BROADCAST_VOLUME {
	ULONG dbcv_size;
	ULONG dbcv_devicetype;
	ULONG dbcv_reserved;
	ULONG dbcv_unitmask;
	USHORT dbcv_flags;
} DEV_BROADCAST_VOLUME;
typedef DEV_BROADCAST_VOLUME *PDEV_BROADCAST_VOLUME;
typedef struct _devicemodeA {
	BYTE dmDeviceName[CCHDEVICENAME];
	WORD dmSpecVersion;
	WORD dmDriverVersion;
	WORD dmSize;
	WORD dmDriverExtra;
	DWORD dmFields;
	union {
	struct { short dmOrientation; short dmPaperSize; short dmPaperLength;
		short dmPaperWidth; };
	POINTL dmPosition;
	};
	short dmScale;
	short dmCopies;
	short dmDefaultSource;
	short dmPrintQuality;
	short dmColor;
	short dmDuplex;
	short dmYResolution;
	short dmTTOption;
	short dmCollate;
	BYTE dmFormName[CCHFORMNAME];
	WORD dmLogPixels;
	DWORD dmBitsPerPel;
	DWORD dmPelsWidth;
	DWORD dmPelsHeight;
	DWORD dmDisplayFlags;
	DWORD dmDisplayFrequency;
#if(WINVER >= 0x0400)
	DWORD dmICMMethod;
	DWORD dmICMIntent;
	DWORD dmMediaType;
	DWORD dmDitherType;
	DWORD dmReserved1;
	DWORD dmReserved2;
#if (WINVER >= 0x0500)
	DWORD dmPanningWidth;
	DWORD dmPanningHeight;
#endif
#endif
} DEVMODEA,*PDEVMODEA,*NPDEVMODEA,*LPDEVMODEA;
typedef struct _devicemodeW {
	WCHAR dmDeviceName[CCHDEVICENAME];
	WORD dmSpecVersion;
	WORD dmDriverVersion;
	WORD dmSize;
	WORD dmDriverExtra;
	DWORD dmFields;
	union {
	struct {
	short dmOrientation; short dmPaperSize; short dmPaperLength; short dmPaperWidth; };
	POINTL dmPosition;
	};
	short dmScale;
	short dmCopies;
	short dmDefaultSource;
	short dmPrintQuality;
	short dmColor;
	short dmDuplex;
	short dmYResolution;
	short dmTTOption;
	short dmCollate;
	WCHAR dmFormName[CCHFORMNAME];
	WORD dmLogPixels;
	DWORD dmBitsPerPel;
	DWORD dmPelsWidth;
	DWORD dmPelsHeight;
	DWORD dmDisplayFlags;
	DWORD dmDisplayFrequency;
#if(WINVER >= 0x0400)
	DWORD dmICMMethod;
	DWORD dmICMIntent;
	DWORD dmMediaType;
	DWORD dmDitherType;
	DWORD dmReserved1;
	DWORD dmReserved2;
#if (WINVER >= 0x0500)
	DWORD dmPanningWidth;
	DWORD dmPanningHeight;
#endif
#endif
} DEVMODEW, *PDEVMODEW, *NPDEVMODEW, *LPDEVMODEW;
#ifdef UNICODE
typedef DEVMODEW DEVMODE;
typedef PDEVMODEW PDEVMODE;
typedef NPDEVMODEW NPDEVMODE;
typedef LPDEVMODEW LPDEVMODE;
typedef CURRENCYFMTW CURRENCYFMT;
typedef LPCURRENCYFMTW LPCURRENCYFMT;
#else
typedef DEVMODEA DEVMODE;
typedef PDEVMODEA PDEVMODE;
typedef NPDEVMODEA NPDEVMODE;
typedef LPDEVMODEA LPDEVMODE;
typedef CURRENCYFMTA CURRENCYFMT;
typedef LPCURRENCYFMTA LPCURRENCYFMT;
#endif
typedef struct tagDEVNAMES {
	WORD wDriverOffset;
	WORD wDeviceOffset;
	WORD wOutputOffset;
	WORD wDefault;
} DEVNAMES,*LPDEVNAMES;
typedef struct tagDIBSECTION {
	BITMAP dsBm;
	BITMAPINFOHEADER dsBmih;
	DWORD dsBitfields[3];
	HANDLE dshSection;
	DWORD dsOffset;
} DIBSECTION,*LPDIBSECTION,*PDIBSECTION;
typedef struct {
	DWORD style;
	DWORD dwExtendedStyle;
	short x;
	short y;
	short cx;
	short cy;
	WORD id;
} DLGITEMTEMPLATE,*LPDLGITEMTEMPLATE;
typedef struct {
	DWORD style;
	DWORD dwExtendedStyle;
	WORD cdit;
	short x;
	short y;
	short cx;
	short cy;
} DLGTEMPLATE,*LPDLGTEMPLATE;
typedef const DLGTEMPLATE *LPCDLGTEMPLATE;
typedef struct {
	int cbSize;
	LPCTSTR lpszDocName;
	LPCTSTR lpszOutput;
	LPCTSTR lpszDatatype;
	DWORD fwType;
} DOCINFO;
typedef struct {
	UINT uNotification;
	HWND hWnd;
	POINT ptCursor;
} DRAGLISTINFO,*LPDRAGLISTINFO;
typedef struct tagDRAWITEMSTRUCT {
	UINT CtlType;
	UINT CtlID;
	UINT itemID;
	UINT itemAction;
	UINT itemState;
	HWND hwndItem;
	HDC hDC;
	RECT rcItem;
	DWORD itemData;
} DRAWITEMSTRUCT,*LPDRAWITEMSTRUCT,*PDRAWITEMSTRUCT;
typedef struct {
	UINT cbSize;
	int iTabLength;
	int iLeftMargin;
	int iRightMargin;
	UINT uiLengthDrawn;
} DRAWTEXTPARAMS,*LPDRAWTEXTPARAMS;
typedef struct tagEMR {
	DWORD iType;
	DWORD nSize;
} EMR,*PEMR;
typedef struct tagEMRANGLEARC {
	EMR emr;
	POINTL ptlCenter;
	DWORD nRadius;
	FLOAT eStartAngle;
	FLOAT eSweepAngle;
} EMRANGLEARC,*PEMRANGLEARC;
typedef struct tagEMRARC {
	EMR emr;
	RECTL rclBox;
	POINTL ptlStart;
	POINTL ptlEnd;
} EMRARC,*PEMRARC,
EMRARCTO,*PEMRARCTO,
EMRCHORD,*PEMRCHORD,
EMRPIE,*PEMRPIE;
typedef struct _XFORM {
	FLOAT eM11;
	FLOAT eM12;
	FLOAT eM21;
	FLOAT eM22;
	FLOAT eDx;
	FLOAT eDy;
} XFORM,*PXFORM,*LPXFORM;
typedef struct tagEMRBITBLT {
	EMR emr;
	RECTL rclBounds;
	LONG xDest;
	LONG yDest;
	LONG cxDest;
	LONG cyDest;
	DWORD dwRop;
	LONG xSrc;
	LONG ySrc;
	XFORM xformSrc;
	COLORREF crBkColorSrc;
	DWORD iUsageSrc;
	DWORD offBmiSrc;
	DWORD offBitsSrc;
	DWORD cbBitsSrc;
} EMRBITBLT,*PEMRBITBLT;
typedef struct tagLOGBRUSH {
	UINT lbStyle;
	COLORREF lbColor;
	LONG lbHatch;
} LOGBRUSH,*LPLOGBRUSH;
typedef struct tagLOGBRUSH32 {
	UINT	lbStyle;
	COLORREF	lbColor;
	ULONG	lbHatch;
} LOGBRUSH32, *PLOGBRUSH32, *NPLOGBRUSH32, *LPLOGBRUSH32;
typedef struct tagEMRCREATEBRUSHINDIRECT {
	EMR emr;
	DWORD ihBrush;
	LOGBRUSH lb;
} EMRCREATEBRUSHINDIRECT,*PEMRCREATEBRUSHINDIRECT;
typedef LONG LCSCSTYPE;
typedef LONG LCSGAMUTMATCH;
typedef struct tagLOGCOLORSPACE {
	DWORD lcsSignature;
	DWORD lcsVersion;
	DWORD lcsSize;
	LCSCSTYPE lcsCSType;
	LCSGAMUTMATCH lcsIntent;
	CIEXYZTRIPLE lcsEndpoints;
	DWORD lcsGammaRed;
	DWORD lcsGammaGreen;
	DWORD lcsGammaBlue;
	TCHAR lcsFilename[MAX_PATH];
} LOGCOLORSPACE,*LPLOGCOLORSPACE;
typedef struct tagEMRCREATECOLORSPACE {
	EMR emr;
	DWORD ihCS;
	LOGCOLORSPACE lcs;
} EMRCREATECOLORSPACE,*PEMRCREATECOLORSPACE;
typedef struct tagEMRCREATEDIBPATTERNBRUSHPT {
	EMR emr;
	DWORD ihBrush;
	DWORD iUsage;
	DWORD offBmi;
	DWORD cbBmi;
	DWORD offBits;
	DWORD cbBits;
} EMRCREATEDIBPATTERNBRUSHPT,
PEMRCREATEDIBPATTERNBRUSHPT;
typedef struct tagEMRCREATEMONOBRUSH {
	EMR emr;
	DWORD ihBrush;
	DWORD iUsage;
	DWORD offBmi;
	DWORD cbBmi;
	DWORD offBits;
	DWORD cbBits;
} EMRCREATEMONOBRUSH,*PEMRCREATEMONOBRUSH;
typedef struct tagPALETTEENTRY {
	BYTE peRed;
	BYTE peGreen;
	BYTE peBlue;
	BYTE peFlags;
} PALETTEENTRY,*LPPALETTEENTRY,*PPALETTEENTRY;
typedef struct tagLOGPALETTE {
	WORD palVersion;
	WORD palNumEntries;
	PALETTEENTRY palPalEntry[1];
} LOGPALETTE,*PLOGPALETTE;
typedef LOGPALETTE *LPLOGPALETTE;
typedef struct tagEMRCREATEPALETTE {
	EMR emr;
	DWORD ihPal;
	LOGPALETTE lgpl;
} EMRCREATEPALETTE,*PEMRCREATEPALETTE;
typedef struct tagLOGPEN {
	UINT lopnStyle;
	POINT lopnWidth;
	COLORREF lopnColor;
} LOGPEN,*LPLOGPEN;
typedef struct tagEMRCREATEPEN {
	EMR emr;
	DWORD ihPen;
	LOGPEN lopn;
} EMRCREATEPEN,*PEMRCREATEPEN;
typedef struct tagEMRELLIPSE {
	EMR emr;
	RECTL rclBox;
} EMRELLIPSE,*PEMRELLIPSE,
EMRRECTANGLE,*PEMRRECTANGLE;
typedef struct tagEMREOF {
	EMR emr;
	DWORD nPalEntries;
	DWORD offPalEntries;
	DWORD nSizeLast;
} EMREOF,*PEMREOF;
typedef struct tagEMREXCLUDECLIPRECT {
	EMR emr;
	RECTL rclClip;
} EMREXCLUDECLIPRECT,*PEMREXCLUDECLIPRECT,
EMRINTERSECTCLIPRECT,*PEMRINTERSECTCLIPRECT;
typedef struct tagPANOSE {
	BYTE bFamilyType;
	BYTE bSerifStyle;
	BYTE bWeight;
	BYTE bProportion;
	BYTE bContrast;
	BYTE bStrokeVariation;
	BYTE bArmStyle;
	BYTE bLetterform;
	BYTE bMidline;
	BYTE bXHeight;
} PANOSE,*LPPANOSE;
typedef struct tagEXTLOGFONT {
	LOGFONT elfLogFont;
	BCHAR elfFullName[LF_FULLFACESIZE];
	BCHAR elfStyle[LF_FACESIZE];
	DWORD elfVersion;
	DWORD elfStyleSize;
	DWORD elfMatch;
	DWORD elfReserved;
	BYTE elfVendorId[ELF_VENDOR_SIZE];
	DWORD elfCulture;
	PANOSE elfPanose;
} EXTLOGFONT,*LPEXTLOGFONT;
typedef struct tagEMREXTCREATEFONTINDIRECTW {
	EMR emr;
	DWORD ihFont;
	EXTLOGFONT elfw;
} EMREXTCREATEFONTINDIRECTW, *PEMREXTCREATEFONTINDIRECTW;
typedef struct tagEXTLOGPEN {
	UINT elpPenStyle;
	UINT elpWidth;
	UINT elpBrushStyle;
	COLORREF elpColor;
	LONG elpHatch;
	DWORD elpNumEntries;
	DWORD elpStyleEntry[1];
} EXTLOGPEN,*LPEXTLOGPEN,*NPEXTLOGPEN;
typedef struct tagEMREXTCREATEPEN {
	EMR emr;
	DWORD ihPen;
	DWORD offBmi;
	DWORD cbBmi;
	DWORD offBits;
	DWORD cbBits;
	EXTLOGPEN elp;
} EMREXTCREATEPEN,*PEMREXTCREATEPEN;
typedef struct tagEMREXTFLOODFILL {
	EMR emr;
	POINTL ptlStart;
	COLORREF crColor;
	DWORD iMode;
} EMREXTFLOODFILL,*PEMREXTFLOODFILL;
typedef struct tagEMREXTSELECTCLIPRGN {
	EMR emr;
	DWORD cbRgnData;
	DWORD iMode;
	BYTE RgnData[1];
} EMREXTSELECTCLIPRGN,*PEMREXTSELECTCLIPRGN;
typedef struct tagEMRTEXT {
	POINTL ptlReference;
	DWORD nChars;
	DWORD offString;
	DWORD fOptions;
	RECTL rcl;
	DWORD offDx;
} EMRTEXT,*PEMRTEXT;
typedef struct tagEMREXTTEXTOUTA {
	EMR emr;
	RECTL rclBounds;
	DWORD iGraphicsMode;
	FLOAT exScale;
	FLOAT eyScale;
	EMRTEXT emrtext;
} EMREXTTEXTOUTA,*PEMREXTTEXTOUTA,
EMREXTTEXTOUTW,*PEMREXTTEXTOUTW;
typedef struct tagEMRFILLPATH {
	EMR emr;
	RECTL rclBounds;
} EMRFILLPATH,*PEMRFILLPATH,
EMRSTROKEANDFILLPATH,*PEMRSTROKEANDFILLPATH,
EMRSTROKEPATH,*PEMRSTROKEPATH;
typedef struct tagEMRFILLRGN {
	EMR emr;
	RECTL rclBounds;
	DWORD cbRgnData;
	DWORD ihBrush;
	BYTE RgnData[1];
} EMRFILLRGN,*PEMRFILLRGN;
typedef struct tagEMRFORMAT {
	DWORD dSignature;
	DWORD nVersion;
	DWORD cbData;
	DWORD offData;
} EMRFORMAT;
typedef struct tagSIZE {
	LONG cx;
	LONG cy;
} SIZE,*PSIZE,*LPSIZE,SIZEL,*PSIZEL,*LPSIZEL;
typedef struct tagEMRFRAMERGN {
	EMR emr;
	RECTL rclBounds;
	DWORD cbRgnData;
	DWORD ihBrush;
	SIZEL szlStroke;
	BYTE RgnData[1];
} EMRFRAMERGN,*PEMRFRAMERGN;
typedef struct tagEMRGDICOMMENT {
	EMR emr;
	DWORD cbData;
	BYTE Data[1];
} EMRGDICOMMENT,*PEMRGDICOMMENT;
typedef struct tagEMRINVERTRGN {
	EMR emr;
	RECTL rclBounds;
	DWORD cbRgnData;
	BYTE RgnData[1];
} EMRINVERTRGN,*PEMRINVERTRGN,
EMRPAINTRGN,*PEMRPAINTRGN;
typedef struct tagEMRLINETO {
	EMR emr;
	POINTL ptl;
} EMRLINETO,*PEMRLINETO,
EMRMOVETOEX,*PEMRMOVETOEX;
typedef struct tagEMRMASKBLT {
	EMR emr;
	RECTL rclBounds;
	LONG xDest;
	LONG yDest;
	LONG cxDest;
	LONG cyDest;
	DWORD dwRop;
	LONG xSrc;
	LONG ySrc;
	XFORM xformSrc;
	COLORREF crBkColorSrc;
	DWORD iUsageSrc;
	DWORD offBmiSrc;
	DWORD cbBmiSrc;
	DWORD offBitsSrc;
	DWORD cbBitsSrc;
	LONG xMask;
	LONG yMask;
	DWORD iUsageMask;
	DWORD offBmiMask;
	DWORD cbBmiMask;
	DWORD offBitsMask;
	DWORD cbBitsMask;
} EMRMASKBLT,*PEMRMASKBLT;
typedef struct tagEMRMODIFYWORLDTRANSFORM {
	EMR emr;
	XFORM xform;
	DWORD iMode;
} EMRMODIFYWORLDTRANSFORM,
PEMRMODIFYWORLDTRANSFORM;
typedef struct tagEMROFFSETCLIPRGN {
	EMR emr;
	POINTL ptlOffset;
} EMROFFSETCLIPRGN,*PEMROFFSETCLIPRGN;
typedef struct tagEMRPLGBLT {
	EMR emr;
	RECTL rclBounds;
	POINTL aptlDest[3];
	LONG xSrc;
	LONG ySrc;
	LONG cxSrc;
	LONG cySrc;
	XFORM xformSrc;
	COLORREF crBkColorSrc;
	DWORD iUsageSrc;
	DWORD offBmiSrc;
	DWORD cbBmiSrc;
	DWORD offBitsSrc;
	DWORD cbBitsSrc;
	LONG xMask;
	LONG yMask;
	DWORD iUsageMask;
	DWORD offBmiMask;
	DWORD cbBmiMask;
	DWORD offBitsMask;
	DWORD cbBitsMask;
} EMRPLGBLT,*PEMRPLGBLT;
typedef struct tagEMRPOLYDRAW {
	EMR emr;
	RECTL rclBounds;
	DWORD cptl;
	POINTL aptl[1];
	BYTE abTypes[1];
} EMRPOLYDRAW,*PEMRPOLYDRAW;
typedef struct tagEMRPOLYDRAW16 {
	EMR emr;
	RECTL rclBounds;
	DWORD cpts;
	POINTS apts[1];
	BYTE abTypes[1];
} EMRPOLYDRAW16,*PEMRPOLYDRAW16;
typedef struct tagEMRPOLYLINE {
	EMR emr;
	RECTL rclBounds;
	DWORD cptl;
	POINTL aptl[1];
} EMRPOLYLINE,*PEMRPOLYLINE,
EMRPOLYBEZIER,*PEMRPOLYBEZIER,
EMRPOLYGON,*PEMRPOLYGON,
EMRPOLYBEZIERTO,*PEMRPOLYBEZIERTO,
EMRPOLYLINETO,*PEMRPOLYLINETO;
typedef struct tagEMRPOLYLINE16 {
	EMR emr;
	RECTL rclBounds;
	DWORD cpts;
	POINTL apts[1];
} EMRPOLYLINE16,*PEMRPOLYLINE16,
EMRPOLYBEZIER16,*PEMRPOLYBEZIER16,
EMRPOLYGON16,*PEMRPOLYGON16,
EMRPOLYBEZIERTO16,*PEMRPOLYBEZIERTO16,
EMRPOLYLINETO16,*PEMRPOLYLINETO16;
typedef struct tagEMRPOLYPOLYLINE {
	EMR emr;
	RECTL rclBounds;
	DWORD nPolys;
	DWORD cptl;
	DWORD aPolyCounts[1];
	POINTL aptl[1];
} EMRPOLYPOLYLINE,*PEMRPOLYPOLYLINE,
EMRPOLYPOLYGON,*PEMRPOLYPOLYGON;
typedef struct tagEMRPOLYPOLYLINE16 {
	EMR emr;
	RECTL rclBounds;
	DWORD nPolys;
	DWORD cpts;
	DWORD aPolyCounts[1];
	POINTS apts[1];
} EMRPOLYPOLYLINE16,*PEMRPOLYPOLYLINE16,
EMRPOLYPOLYGON16,*PEMRPOLYPOLYGON16;
typedef struct tagEMRPOLYTEXTOUTA {
	EMR emr;
	RECTL rclBounds;
	DWORD iGraphicsMode;
	FLOAT exScale;
	FLOAT eyScale;
	LONG cStrings;
	EMRTEXT aemrtext[1];
} EMRPOLYTEXTOUTA,*PEMRPOLYTEXTOUTA,
EMRPOLYTEXTOUTW,*PEMRPOLYTEXTOUTW;
typedef struct tagEMRRESIZEPALETTE {
	EMR emr;
	DWORD ihPal;
	DWORD cEntries;
} EMRRESIZEPALETTE,*PEMRRESIZEPALETTE;
typedef struct tagEMRRESTOREDC {
	EMR emr;
	LONG iRelative;
} EMRRESTOREDC,*PEMRRESTOREDC;
typedef struct tagEMRROUNDRECT {
	EMR emr;
	RECTL rclBox;
	SIZEL szlCorner;
} EMRROUNDRECT,*PEMRROUNDRECT;
typedef struct tagEMRSCALEVIEWPORTEXTEX {
	EMR emr;
	LONG xNum;
	LONG xDenom;
	LONG yNum;
	LONG yDenom;
} EMRSCALEVIEWPORTEXTEX,*PEMRSCALEVIEWPORTEXTEX,
EMRSCALEWINDOWEXTEX,*PEMRSCALEWINDOWEXTEX;
typedef struct tagEMRSELECTCOLORSPACE {
	EMR emr;
	DWORD ihCS;
} EMRSELECTCOLORSPACE,*PEMRSELECTCOLORSPACE,
EMRDELETECOLORSPACE,*PEMRDELETECOLORSPACE;
typedef struct tagEMRSELECTOBJECT {
	EMR emr;
	DWORD ihObject;
} EMRSELECTOBJECT,*PEMRSELECTOBJECT,
EMRDELETEOBJECT,*PEMRDELETEOBJECT;
typedef struct tagEMRSELECTPALETTE {
	EMR emr;
	DWORD ihPal;
} EMRSELECTPALETTE,*PEMRSELECTPALETTE;
typedef struct tagEMRSETARCDIRECTION {
	EMR emr;
	DWORD iArcDirection;
} EMRSETARCDIRECTION,*PEMRSETARCDIRECTION;
typedef struct tagEMRSETTEXTCOLOR {
	EMR emr;
	COLORREF crColor;
} EMRSETBKCOLOR,*PEMRSETBKCOLOR,
EMRSETTEXTCOLOR,*PEMRSETTEXTCOLOR;
typedef struct tagEMRSETCOLORADJUSTMENT {
	EMR emr;
	COLORADJUSTMENT ColorAdjustment;
} EMRSETCOLORADJUSTMENT,*PEMRSETCOLORADJUSTMENT;
typedef struct tagEMRSETDIBITSTODEVICE {
	EMR emr;
	RECTL rclBounds;
	LONG xDest;
	LONG yDest;
	LONG xSrc;
	LONG ySrc;
	LONG cxSrc;
	LONG cySrc;
	DWORD offBmiSrc;
	DWORD cbBmiSrc;
	DWORD offBitsSrc;
	DWORD cbBitsSrc;
	DWORD iUsageSrc;
	DWORD iStartScan;
	DWORD cScans;
} EMRSETDIBITSTODEVICE,*PEMRSETDIBITSTODEVICE;
typedef struct tagEMRSETMAPPERFLAGS {
	EMR emr;
	DWORD dwFlags;
} EMRSETMAPPERFLAGS,*PEMRSETMAPPERFLAGS;
typedef struct tagEMRSETMITERLIMIT {
	EMR emr;
	FLOAT eMiterLimit;
} EMRSETMITERLIMIT,*PEMRSETMITERLIMIT;
typedef struct tagEMRSETPALETTEENTRIES {
	EMR emr;
	DWORD ihPal;
	DWORD iStart;
	DWORD cEntries;
	PALETTEENTRY aPalEntries[1];
} EMRSETPALETTEENTRIES,*PEMRSETPALETTEENTRIES;
typedef struct tagEMRSETPIXELV {
	EMR emr;
	POINTL ptlPixel;
	COLORREF crColor;
} EMRSETPIXELV,*PEMRSETPIXELV;
typedef struct tagEMRSETVIEWPORTEXTEX {
	EMR emr;
	SIZEL szlExtent;
} EMRSETVIEWPORTEXTEX,*PEMRSETVIEWPORTEXTEX,
EMRSETWINDOWEXTEX,*PEMRSETWINDOWEXTEX;
typedef struct tagEMRSETVIEWPORTORGEX {
	EMR emr;
	POINTL ptlOrigin;
} EMRSETVIEWPORTORGEX,*PEMRSETVIEWPORTORGEX,
EMRSETWINDOWORGEX,*PEMRSETWINDOWORGEX,
EMRSETBRUSHORGEX,*PEMRSETBRUSHORGEX;
typedef struct tagEMRSETWORLDTRANSFORM {
	EMR emr;
	XFORM xform;
} EMRSETWORLDTRANSFORM,*PEMRSETWORLDTRANSFORM;
typedef struct tagEMRSTRETCHBLT {
	EMR emr;
	RECTL rclBounds;
	LONG xDest;
	LONG yDest;
	LONG cxDest;
	LONG cyDest;
	DWORD dwRop;
	LONG xSrc;
	LONG ySrc;
	XFORM xformSrc;
	COLORREF crBkColorSrc;
	DWORD iUsageSrc;
	DWORD offBmiSrc;
	DWORD cbBmiSrc;
	DWORD offBitsSrc;
	DWORD cbBitsSrc;
	LONG cxSrc;
	LONG cySrc;
} EMRSTRETCHBLT,*PEMRSTRETCHBLT;
typedef struct tagEMRSTRETCHDIBITS {
	EMR emr;
	RECTL rclBounds;
	LONG xDest;
	LONG yDest;
	LONG xSrc;
	LONG ySrc;
	LONG cxSrc;
	LONG cySrc;
	DWORD offBmiSrc;
	DWORD cbBmiSrc;
	DWORD offBitsSrc;
	DWORD cbBitsSrc;
	DWORD iUsageSrc;
	DWORD dwRop;
	LONG cxDest;
	LONG cyDest;
} EMRSTRETCHDIBITS,*PEMRSTRETCHDIBITS;
typedef struct tagABORTPATH {
	EMR emr;
} EMRABORTPATH,*PEMRABORTPATH,
EMRBEGINPATH,*PEMRBEGINPATH,
EMRENDPATH,*PEMRENDPATH,
EMRCLOSEFIGURE,*PEMRCLOSEFIGURE,
EMRFLATTENPATH,*PEMRFLATTENPATH,
EMRWIDENPATH,*PEMRWIDENPATH,
EMRSETMETARGN,*PEMRSETMETARGN,
EMRSAVEDC,*PEMRSAVEDC,
EMRREALIZEPALETTE,*PEMRREALIZEPALETTE;
typedef struct tagEMRSELECTCLIPPATH {
	EMR emr;
	DWORD iMode;
} EMRSELECTCLIPPATH,*PEMRSELECTCLIPPATH,
EMRSETBKMODE,*PEMRSETBKMODE,
EMRSETMAPMODE,*PEMRSETMAPMODE,
EMRSETPOLYFILLMODE,*PEMRSETPOLYFILLMODE,
EMRSETROP2,*PEMRSETROP2,
EMRSETSTRETCHBLTMODE,*PEMRSETSTRETCHBLTMODE,
EMRSETTEXTALIGN,*PEMRSETTEXTALIGN,
EMRENABLEICM,*PEMRENABLEICM;
typedef struct tagNMHDR {
	HWND hwndFrom;
	UINT idFrom;
	UINT code;
} NMHDR;
typedef struct tagNMIPADDRESS { NMHDR hdr; int iField; int iValue; } NMIPADDRESS, *LPNMIPADDRESS;
typedef NMHDR *LPNMHDR;
typedef struct tagENHMETAHEADER {
	DWORD iType;
	DWORD nSize;
	RECTL rclBounds;
	RECTL rclFrame;
	DWORD dSignature;
	DWORD nVersion;
	DWORD nBytes;
	DWORD nRecords;
	WORD nHandles;
	WORD sReserved;
	DWORD nDescription;
	DWORD offDescription;
	DWORD nPalEntries;
	SIZEL szlDevice;
	SIZEL szlMillimeters;
} ENHMETAHEADER,*LPENHMETAHEADER;
typedef struct tagENHMETARECORD {
	DWORD iType;
	DWORD nSize;
	DWORD dParm[1];
} ENHMETARECORD,*LPENHMETARECORD;
typedef struct tagENUMLOGFONT {
	LOGFONT elfLogFont;
	BCHAR elfFullName[LF_FULLFACESIZE];
	BCHAR elfStyle[LF_FACESIZE];
} ENUMLOGFONT;
typedef struct tagENUMLOGFONTEX {
	LOGFONT elfLogFont;
	BCHAR elfFullName[LF_FULLFACESIZE];
	BCHAR elfStyle[LF_FACESIZE];
	BCHAR elfScript[LF_FACESIZE];
} ENUMLOGFONTEX;
typedef struct _EVENTLOGRECORD {
	DWORD Length;
	DWORD Reserved;
	DWORD RecordNumber;
	DWORD TimeGenerated;
	DWORD TimeWritten;
	DWORD EventID;
	WORD EventType;
	WORD NumStrings;
	WORD EventCategory;
	WORD ReservedFlags;
	DWORD ClosingRecordNumber;
	DWORD StringOffset;
	DWORD UserSidLength;
	DWORD UserSidOffset;
	DWORD DataLength;
	DWORD DataOffset;
} EVENTLOGRECORD;
typedef struct tagEVENTMSG {
	UINT message;
	UINT paramL;
	UINT paramH;
	DWORD time;
	HWND hwnd;
} EVENTMSG;
typedef PVOID PACCESS_TOKEN;
typedef ACCESS_MASK *PACCESS_MASK;
typedef struct _EXT_BUTTON {
	WORD idCommand;
	WORD idsHelp;
	WORD fsStyle;
} EXT_BUTTON,*LPEXT_BUTTON;
typedef struct tagFILTERKEYS {
	UINT cbSize;
	DWORD dwFlags;
	DWORD iWaitMSec;
	DWORD iDelayMSec;
	DWORD iRepeatMSec;
	DWORD iBounceMSec;
} FILTERKEYS;
typedef struct _FIND_NAME_BUFFER {
	UCHAR length;
	UCHAR access_control;
	UCHAR frame_control;
	UCHAR destination_addr[6];
	UCHAR source_addr[6];
	UCHAR routing_info[18];
} FIND_NAME_BUFFER;
typedef struct _FIND_NAME_HEADER {
	WORD node_count;
	UCHAR reserved;
	UCHAR unique_group;
} FIND_NAME_HEADER;
typedef struct {
	DWORD lStructSize;
	HWND hwndOwner;
	HINSTANCE hInstance;
	DWORD Flags;
	LPTSTR lpstrFindWhat;
	LPTSTR lpstrReplaceWith;
	WORD wFindWhatLen;
	WORD wReplaceWithLen;
	LPARAM lCustData;
	LPFRHOOKPROC lpfnHook;
	LPCTSTR lpTemplateName;
} FINDREPLACE,*LPFINDREPLACE;
#ifndef __FINDTEXT_DEFINED
#define __FINDTEXT_DEFINED
typedef struct _findtext {
	CHARRANGE chrg;
	LPCSTR lpstrText;
} FINDTEXT;
#endif
typedef struct _findtextex {
	CHARRANGE chrg;
	LPSTR lpstrText;
	CHARRANGE chrgText;
} FINDTEXTEX;
typedef struct _FMS_GETDRIVEINFO {
	DWORD dwTotalSpace;
	DWORD dwFreeSpace;
	TCHAR szPath[260];
	TCHAR szVolume[14];
	TCHAR szShare[128];
} FMS_GETDRIVEINFO;
typedef struct _FMS_GETFILESEL {
	FILETIME ftTime;
	DWORD dwSize;
	BYTE bAttr;
	TCHAR szName[260];
} FMS_GETFILESEL;
typedef struct _FMS_LOAD {
	DWORD dwSize;
	TCHAR szMenuName[MENU_TEXT_LEN];
	HMENU hMenu;
	UINT wMenuDelta;
} FMS_LOAD;
typedef struct _FMS_TOOLBARLOAD {
	DWORD dwSize;
	LPEXT_BUTTON lpButtons;
	WORD cButtons;
	WORD cBitmaps;
	WORD idBitmap;
	HBITMAP hBitmap;
} FMS_TOOLBARLOAD;
typedef struct _FOCUS_EVENT_RECORD {
	BOOL bSetFocus;
} FOCUS_EVENT_RECORD;
typedef struct tagGCP_RESULTS {
	DWORD lStructSize;
	LPTSTR lpOutString;
	UINT *lpOrder;
	INT *lpDx;
	INT *lpCaretPos;
	LPTSTR lpClass;
	UINT *lpGlyphs;
	UINT nGlyphs;
	UINT nMaxFit;
} GCP_RESULTS,*LPGCP_RESULTS;
typedef struct _GENERIC_MAPPING {
	ACCESS_MASK GenericRead;
	ACCESS_MASK GenericWrite;
	ACCESS_MASK GenericExecute;
	ACCESS_MASK GenericAll;
} GENERIC_MAPPING,*PGENERIC_MAPPING;
typedef struct _GLYPHMETRICS {
	UINT gmBlackBoxX;
	UINT gmBlackBoxY;
	POINT gmptGlyphOrigin;
	short gmCellIncX;
	short gmCellIncY;
} GLYPHMETRICS,*LPGLYPHMETRICS;
typedef struct tagHANDLETABLE {
	HGDIOBJ objectHandle[1];
} HANDLETABLE,*LPHANDLETABLE;
typedef struct _HD_HITTESTINFO {
	POINT pt;
	UINT flags;
	int iItem;
} HD_HITTESTINFO,*LPHDHITTESTINFO;
#define HDHITTESTINFO	HD_HITTESTINFO
typedef struct _HD_ITEM {
	UINT mask;
	int cxy;
	LPTSTR pszText;
	HBITMAP hbm;
	int cchTextMax;
	int fmt;
	LPARAM lParam;
} HD_ITEM;
typedef struct _WINDOWPOS {
	HWND hwnd;
	HWND hwndInsertAfter;
	int x;
	int y;
	int cx;
	int cy;
	UINT flags;
} WINDOWPOS,*PWINDOWPOS,*LPWINDOWPOS;
typedef struct _HD_LAYOUT {
	RECT *prc;
	WINDOWPOS *pwpos;
} HD_LAYOUT,*LPHDLAYOUT;
#define HDLAYOUT HD_LAYOUT
typedef struct _HD_NOTIFY {
	NMHDR hdr;
	int iItem;
	int iButton;
	HD_ITEM *pitem;
} HD_NOTIFY;
typedef struct _HD_ITEMA {
	UINT	mask;
	int	cxy;
	LPSTR	pszText;
	HBITMAP hbm;
	int	cchTextMax;
	int	fmt;
	LPARAM lParam;
	int	iImage;
	int	iOrder;
	UINT	type;
	LPVOID	pvFilter;
} HDITEMA, *LPHDITEMA;
#define HDITEMA_V1_SIZE CCSIZEOF_STRUCT(HDITEMA, lParam)
#define HDITEMW_V1_SIZE CCSIZEOF_STRUCT(HDITEMW, lParam)
typedef struct _HD_ITEMW {
	UINT	mask;
	int	cxy;
	LPWSTR	pszText;
	HBITMAP hbm;
	int	cchTextMax;
	int	fmt;
	LPARAM lParam;
	int	iImage;
	int	iOrder;
	UINT	type;
	LPVOID pvFilter;
} HDITEMW, *LPHDITEMW;
#ifdef UNICODE
#define HDITEM HDITEMW
#define LPHDITEM LPHDITEMW
#define HDITEM_V1_SIZE HDITEMW_V1_SIZE
#else
#define HDITEM HDITEMA
#define LPHDITEM LPHDITEMA
#define HDITEM_V1_SIZE HDITEMA_V1_SIZE
#endif
typedef struct tagNMHEADERA {
	NMHDR	hdr;
	int	iItem;
	int	iButton;
	HDITEMA *pitem;
} NMHEADERA,* LPNMHEADERA;
typedef struct tagNMHEADERW {
	NMHDR	hdr;
	int	iItem;
	int	iButton;
	HDITEMW *pitem;
} NMHEADERW,*LPNMHEADERW;
#ifdef UNICODE
#define NMHEADER	NMHEADERW
#define LPNMHEADER	LPNMHEADERW
#else
#define NMHEADER	NMHEADERA
#define LPNMHEADER	LPNMHEADERA
#endif
typedef struct tagHELPINFO {
	UINT cbSize;
	int iContextType;
	int iCtrlId;
	HANDLE hItemHandle;
	DWORD dwContextId;
	POINT MousePos;
} HELPINFO,*LPHELPINFO;
typedef struct {
	int wStructSize;
	int x;
	int y;
	int dx;
	int dy;
	int wMax;
	TCHAR rgchMember[2];
} HELPWININFO;
typedef struct tagHIGHCONTRAST {
	UINT cbSize;
	DWORD dwFlags;
	LPTSTR lpszDefaultScheme;
} HIGHCONTRAST,*LPHIGHCONTRAST;
typedef struct tagHSZPAIR {
	HSZ hszSvc;
	HSZ hszTopic;
} HSZPAIR;
typedef struct _ICONINFO {
	BOOL fIcon;
	DWORD xHotspot;
	DWORD yHotspot;
	HBITMAP hbmMask;
	HBITMAP hbmColor;
} ICONINFO,*PICONINFO;
typedef struct tagICONMETRICS {
	UINT cbSize;
	int iHorzSpacing;
	int iVertSpacing;
	int iTitleWrap;
	LOGFONT lfFont;
} ICONMETRICS,*LPICONMETRICS;
typedef struct _IMAGEINFO {
	HBITMAP hbmImage;
	HBITMAP hbmMask;
	int Unused1;
	int Unused2;
	RECT rcImage;
} IMAGEINFO;
typedef struct _KEY_EVENT_RECORD {
	BOOL bKeyDown;
	WORD wRepeatCount;
	WORD wVirtualKeyCode;
	WORD wVirtualScanCode;
	union { WCHAR UnicodeChar; CHAR AsciiChar; } uChar;
	DWORD dwControlKeyState;
} KEY_EVENT_RECORD;
typedef struct _MOUSE_EVENT_RECORD {
	COORD dwMousePosition;
	DWORD dwButtonState;
	DWORD dwControlKeyState;
	DWORD dwEventFlags;
} MOUSE_EVENT_RECORD;
typedef struct _WINDOW_BUFFER_SIZE_RECORD {
	COORD dwSize;
} WINDOW_BUFFER_SIZE_RECORD;
typedef struct _MENU_EVENT_RECORD {
	UINT dwCommandId;
} MENU_EVENT_RECORD,*PMENU_EVENT_RECORD;
typedef struct _INPUT_RECORD {
	WORD EventType;
	WORD __alignmentDummy;
	union {
		KEY_EVENT_RECORD KeyEvent;
		MOUSE_EVENT_RECORD MouseEvent;
		WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
		MENU_EVENT_RECORD MenuEvent;
		FOCUS_EVENT_RECORD FocusEvent;
	} Event;
} INPUT_RECORD,*PINPUT_RECORD;
typedef struct _SYSTEMTIME {
	WORD wYear;
	WORD wMonth;
	WORD wDayOfWeek;
	WORD wDay;
	WORD wHour;
	WORD wMinute;
	WORD wSecond;
	WORD wMilliseconds;
} SYSTEMTIME,*LPSYSTEMTIME,*PSYSTEMTIME;
typedef struct _SID_IDENTIFIER_AUTHORITY {
	BYTE Value[6];
} SID_IDENTIFIER_AUTHORITY,*PSID_IDENTIFIER_AUTHORITY,
*LPSID_IDENTIFIER_AUTHORITY;
typedef struct _SID {
	BYTE Revision;
	BYTE SubAuthorityCount;
	SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
	DWORD SubAuthority[ANYSIZE_ARRAY];
} SID,*PSID;
#define SID_REVISION              (1)
#define SID_MAX_SUB_AUTHORITIES       (15)
#define SID_RECOMMENDED_SUB_AUTHORITIES (1)
#define SECURITY_MAX_SID_SIZE (sizeof(SID) - sizeof(DWORD) + (SID_MAX_SUB_AUTHORITIES * sizeof(DWORD)))
typedef WORD SECURITY_DESCRIPTOR_CONTROL,*PSECURITY_DESCRIPTOR_CONTROL;
typedef struct _SECURITY_DESCRIPTOR_RELATIVE {
	BYTE Revision;
	BYTE Sbz1;
	SECURITY_DESCRIPTOR_CONTROL Control;
	DWORD Owner;
	DWORD Group;
	DWORD Sacl;
	DWORD Dacl;
} SECURITY_DESCRIPTOR_RELATIVE, *PISECURITY_DESCRIPTOR_RELATIVE;
typedef struct _SECURITY_DESCRIPTOR {
	BYTE Revision;
	BYTE Sbz1;
	SECURITY_DESCRIPTOR_CONTROL Control;
	PSID Owner;
	PSID Group;
	PACL Sacl;
	PACL Dacl;
} SECURITY_DESCRIPTOR,*PSECURITY_DESCRIPTOR;
typedef struct tagKERNINGPAIR {
	WORD wFirst;
	WORD wSecond;
	int iKernAmount;
} KERNINGPAIR,*LPKERNINGPAIR;
typedef struct _LANA_ENUM {
	UCHAR length;
	UCHAR lana[MAX_LANA];
} LANA_ENUM;
typedef struct _LDT_ENTRY {
	WORD LimitLow;
	WORD BaseLow;
	union {
		struct {
			BYTE BaseMid;
			BYTE Flags1;
			BYTE Flags2;
			BYTE BaseHi;
		} Bytes;
		struct {
			unsigned BaseMid:8;
			unsigned Type:5;
			unsigned Dpl:2;
			unsigned Pres:1;
			unsigned LimitHi:4;
			unsigned Sys:1;
			unsigned Reserved_0:1;
			unsigned Default_Big:1;
			unsigned Granularity:1;
			unsigned BaseHi:8;
		} Bits;
	} HighWord;
} LDT_ENTRY,*PLDT_ENTRY,*LPLDT_ENTRY;
typedef struct tagLOCALESIGNATURE {
	DWORD lsUsb[4];
	DWORD lsCsbDefault[2];
	DWORD lsCsbSupported[2];
} LOCALESIGNATURE;
typedef long FXPT16DOT16,*LPFXPT16DOT16;
typedef LARGE_INTEGER LUID,*PLUID;
typedef struct _LUID_AND_ATTRIBUTES {
	LUID Luid;
	DWORD Attributes;
} LUID_AND_ATTRIBUTES,*PLUID_AND_ATTRIBUTES;
typedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[ANYSIZE_ARRAY];
typedef LUID_AND_ATTRIBUTES_ARRAY *PLUID_AND_ATTRIBUTES_ARRAY;
typedef struct _LV_COLUMN {
	UINT mask;
	int fmt;
	int cx;
	LPTSTR pszText;
	int cchTextMax;
	int iSubItem;
} LV_COLUMN;
typedef struct _LV_ITEM {
	UINT mask;
	int iItem;
	int iSubItem;
	UINT state;
	UINT stateMask;
	LPTSTR pszText;
	int cchTextMax;
	int iImage;
	LPARAM lParam;
} LV_ITEM;
typedef struct tagLV_DISPINFO {
	NMHDR hdr;
	LV_ITEM item;
} LV_DISPINFO;
typedef struct _LV_FINDINFO {
	UINT flags;
	LPCTSTR psz;
	LPARAM lParam;
	POINT pt;
	UINT vkDirection;
} LV_FINDINFO;
typedef struct _LV_HITTESTINFO {
	POINT pt;
	UINT flags;
	int iItem;
} LV_HITTESTINFO;
typedef struct tagLV_KEYDOWN {
	NMHDR hdr;
	WORD wVKey;
	UINT flags;
} LV_KEYDOWN;
typedef struct _MAT2 {
	FIXED eM11;
	FIXED eM12;
	FIXED eM21;
	FIXED eM22;
} MAT2;
typedef struct tagMDICREATESTRUCT {
	LPCTSTR szClass;
	LPCTSTR szTitle;
	HANDLE hOwner;
	int x;
	int y;
	int cx;
	int cy;
	DWORD style;
	LPARAM lParam;
} MDICREATESTRUCT;
typedef MDICREATESTRUCT *LPMDICREATESTRUCT;
typedef struct tagMEASUREITEMSTRUCT {
	UINT CtlType;
	UINT CtlID;
	UINT itemID;
	UINT itemWidth;
	UINT itemHeight;
	DWORD itemData;
} MEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT *LPMEASUREITEMSTRUCT,*PMEASUREITEMSTRUCT;
typedef struct _MEMORY_BASIC_INFORMATION {
	PVOID BaseAddress;
	PVOID AllocationBase;
	DWORD AllocationProtect;
	DWORD RegionSize;
	DWORD State;
	DWORD Protect;
	DWORD Type;
} MEMORY_BASIC_INFORMATION;
typedef MEMORY_BASIC_INFORMATION *PMEMORY_BASIC_INFORMATION;
typedef struct _MEMORYSTATUS {
	DWORD dwLength;
	DWORD dwMemoryLoad;
	DWORD dwTotalPhys;
	DWORD dwAvailPhys;
	DWORD dwTotalPageFile;
	DWORD dwAvailPageFile;
	DWORD dwTotalVirtual;
	DWORD dwAvailVirtual;
} MEMORYSTATUS,*LPMEMORYSTATUS;
typedef struct _MEMORYSTATUSEX {
	DWORD dwLength;
	DWORD dwMemoryLoad;
	long long ullTotalPhys;
	long long ullAvailPhys;
	long long ullTotalPageFile;
	long long ullAvailPageFile;
	long long ullTotalVirtual;
	long long ullAvailVirtual;
	long long ullAvailExtendedVirtual;
} MEMORYSTATUSEX, *LPMEMORYSTATUSEX;
typedef struct {
	WORD wVersion;
	WORD wOffset;
	DWORD dwHelpId;
} MENUEX_TEMPLATE_HEADER;
typedef struct {
	DWORD dwType;
	DWORD dwState;
	UINT uId;
	BYTE bResInfo;
	WCHAR szText[1];
	DWORD dwHelpId;
} MENUEX_TEMPLATE_ITEM;
typedef struct tagMENUITEMINFO {
	UINT cbSize;
	UINT fMask;
	UINT fType;
	UINT fState;
	UINT wID;
	HMENU hSubMenu;
	HBITMAP hbmpChecked;
	HBITMAP hbmpUnchecked;
	DWORD dwItemData;
	LPTSTR dwTypeData;
	UINT cch;
} MENUITEMINFO,*LPMENUITEMINFO;
typedef MENUITEMINFO CONST *LPCMENUITEMINFO;
typedef struct {
	WORD mtOption;
	WORD mtID;
	WCHAR mtString[1];
} MENUITEMTEMPLATE;
typedef struct {
	WORD versionNumber;
	WORD offset;
} MENUITEMTEMPLATEHEADER;
typedef VOID MENUTEMPLATE,*LPMENUTEMPLATE;
typedef struct tagMETAFILEPICT {
	LONG mm;
	LONG xExt;
	LONG yExt;
	HMETAFILE hMF;
} METAFILEPICT,*LPMETAFILEPICT;
typedef struct tagMETAHEADER {
	WORD mtType;
	WORD mtHeaderSize;
	WORD mtVersion;
	DWORD mtSize;
	WORD mtNoObjects;
	DWORD mtMaxRecord;
	WORD mtNoParameters;
} METAHEADER,*LPMETAHEADER;
typedef struct tagMETARECORD {
	DWORD rdSize;
	WORD rdFunction;
	WORD rdParm[1];
} METARECORD,*LPMETARECORD;
typedef struct tagMINIMIZEDMETRICS {
	UINT cbSize;
	int iWidth;
	int iHorzGap;
	int iVertGap;
	int iArrange;
} MINIMIZEDMETRICS,*LPMINIMIZEDMETRICS;
typedef struct tagMINMAXINFO {
	POINT ptReserved;
	POINT ptMaxSize;
	POINT ptMaxPosition;
	POINT ptMinTrackSize;
	POINT ptMaxTrackSize;
} MINMAXINFO,*LPMINMAXINFO;
typedef struct modemdevcaps_tag {
	DWORD dwActualSize;
	DWORD dwRequiredSize;
	DWORD dwDevSpecificOffset;
	DWORD dwDevSpecificSize;
	DWORD dwModemProviderVersion;
	DWORD dwModemManufacturerOffset;
	DWORD dwModemManufacturerSize;
	DWORD dwModemModelOffset;
	DWORD dwModemModelSize;
	DWORD dwModemVersionOffset;
	DWORD dwModemVersionSize;
	DWORD dwDialOptions;
	DWORD dwCallSetupFailTimer;
	DWORD dwInactivityTimeout;
	DWORD dwSpeakerVolume;
	DWORD dwSpeakerMode;
	DWORD dwModemOptions;
	DWORD dwMaxDTERate;
	DWORD dwMaxDCERate;
	BYTE abVariablePortion[1];
} MODEMDEVCAPS,*PMODEMDEVCAPS,*LPMODEMDEVCAPS;
typedef struct modemsettings_tag {
	DWORD dwActualSize;
	DWORD dwRequiredSize;
	DWORD dwDevSpecificOffset;
	DWORD dwDevSpecificSize;
	DWORD dwCallSetupFailTimer;
	DWORD dwInactivityTimeout;
	DWORD dwSpeakerVolume;
	DWORD dwSpeakerMode;
	DWORD dwPreferredModemOptions;
	DWORD dwNegotiatedModemOptions;
	DWORD dwNegotiatedDCERate;
	BYTE abVariablePortion[1];
} MODEMSETTINGS,*PMODEMSETTINGS,*LPMODEMSETTINGS;
typedef struct tagMONCBSTRUCT {
	UINT cb;
	DWORD dwTime;
	HANDLE hTask;
	DWORD dwRet;
	UINT wType;
	UINT wFmt;
	HCONV hConv;
	HSZ hsz1;
	HSZ hsz2;
	HDDEDATA hData;
	DWORD dwData1;
	DWORD dwData2;
	CONVCONTEXT cc;
	DWORD cbData;
	DWORD Data[8];
} MONCBSTRUCT;
typedef struct tagMONCONVSTRUCT {
	UINT cb;
	BOOL fConnect;
	DWORD dwTime;
	HANDLE hTask;
	HSZ hszSvc;
	HSZ hszTopic;
	HCONV hConvClient;
	HCONV hConvServer;
} MONCONVSTRUCT;
typedef struct tagMONERRSTRUCT {
	UINT cb;
	UINT wLastError;
	DWORD dwTime;
	HANDLE hTask;
} MONERRSTRUCT;
typedef struct tagMONHSZSTRUCT {
	UINT cb;
	BOOL fsAction;
	DWORD dwTime;
	HSZ hsz;
	HANDLE hTask;
	TCHAR str[1];
} MONHSZSTRUCT;
typedef struct tagMONLINKSTRUCT {
	UINT cb;
	DWORD dwTime;
	HANDLE hTask;
	BOOL fEstablished;
	BOOL fNoData;
	HSZ hszSvc;
	HSZ hszTopic;
	HSZ hszItem;
	UINT wFmt;
	BOOL fServer;
	HCONV hConvServer;
	HCONV hConvClient;
} MONLINKSTRUCT;
typedef struct tagMONMSGSTRUCT {
	UINT cb;
	HWND hwndTo;
	DWORD dwTime;
	HANDLE hTask;
	UINT wMsg;
	WPARAM wParam;
	LPARAM lParam;
	DDEML_MSG_HOOK_DATA dmhd;
} MONMSGSTRUCT;
typedef struct tagMOUSEHOOKSTRUCT {
	POINT pt;
	HWND hwnd;
	UINT wHitTestCode;
	DWORD dwExtraInfo;
} MOUSEHOOKSTRUCT,*PMOUSEHOOKSTRUCT;
typedef struct tagMOUSEHOOKSTRUCTEX {
	POINT pt;
	HWND hwnd;
	UINT wHitTestCode;
	DWORD dwExtraInfo;
	DWORD mouseData;
} MOUSEHOOKSTRUCTEX, *LPMOUSEHOOKSTRUCTEX, *PMOUSEHOOKSTRUCTEX;
typedef struct _MOUSEKEYS {
	DWORD cbSize;
	DWORD dwFlags;
	DWORD iMaxSpeed;
	DWORD iTimeToMaxSpeed;
	DWORD iCtrlSpeed;
	DWORD dwReserved1;
	DWORD dwReserved2;
} MOUSEKEYS;
typedef struct tagMSG {
	HWND hwnd;
	UINT message;
	WPARAM wParam;
	LPARAM lParam;
	DWORD time;
	POINT pt;
} MSG,*LPMSG,*PMSG;
typedef void (CALLBACK * MSGBOXCALLBACK) (LPHELPINFO lpHelpInfo);
typedef struct {
	UINT cbSize;
	HWND hwndOwner;
	HINSTANCE hInstance;
	LPCTSTR lpszText;
	LPCTSTR lpszCaption;
	DWORD dwStyle;
	LPCTSTR lpszIcon;
	DWORD dwContextHelpId;
	MSGBOXCALLBACK lpfnMsgBoxCallback;
	DWORD dwLanguageId;
} MSGBOXPARAMS,*PMSGBOXPARAMS,*LPMSGBOXPARAMS;
typedef struct tagMULTIKEYHELP {
	DWORD mkSize;
	TCHAR mkKeylist;
	TCHAR szKeyphrase[1];
} MULTIKEYHELP;
typedef struct _NAME_BUFFER {
	UCHAR name[NCBNAMSZ];
	UCHAR name_num;
	UCHAR name_flags;
} NAME_BUFFER;
typedef struct _NCB {
	UCHAR ncb_command;
	UCHAR ncb_retcode;
	UCHAR ncb_lsn;
	UCHAR ncb_num;
	PUCHAR ncb_buffer;
	WORD ncb_length;
	UCHAR ncb_callname[NCBNAMSZ];
	UCHAR ncb_name[NCBNAMSZ];
	UCHAR ncb_rto;
	UCHAR ncb_sto;
	void (*ncb_post) (struct _NCB *);
	UCHAR ncb_lana_num;
	UCHAR ncb_cmd_cplt;
	UCHAR ncb_reserve[10];
	HANDLE ncb_event;
} NCB,*PNCB;
typedef struct _NCCALCSIZE_PARAMS {
	RECT rgrc[3];
	PWINDOWPOS lppos;
} NCCALCSIZE_PARAMS;
typedef struct _NDDESHAREINFO {
	LONG lRevision;
	LPTSTR lpszShareName;
	LONG lShareType;
	LPTSTR lpszAppTopicList;
	LONG fSharedFlag;
	LONG fService;
	LONG fStartAppFlag;
	LONG nCmdShow;
	LONG qModifyId[2];
	LONG cNumItems;
	LPTSTR lpszItemList;
} NDDESHAREINFO;
#ifndef _NETRESOURCE_DEFINED
#define _NETRESOURCE_DEFINED
typedef struct _NETRESOURCE {
	DWORD dwScope;
	DWORD dwType;
	DWORD dwDisplayType;
	DWORD dwUsage;
	LPTSTR lpLocalName;
	LPTSTR lpRemoteName;
	LPTSTR lpComment;
	LPTSTR lpProvider;
} NETRESOURCE,*LPNETRESOURCE;
#endif
#pragma pack(push,4)
typedef struct tagNEWTEXTMETRIC {
	LONG tmHeight;
	LONG tmAscent;
	LONG tmDescent;
	LONG tmInternalLeading;
	LONG tmExternalLeading;
	LONG tmAveCharWidth;
	LONG tmMaxCharWidth;
	LONG tmWeight;
	LONG tmOverhang;
	LONG tmDigitizedAspectX;
	LONG tmDigitizedAspectY;
	BCHAR tmFirstChar;
	BCHAR tmLastChar;
	BCHAR tmDefaultChar;
	BCHAR tmBreakChar;
	BYTE tmItalic;
	BYTE tmUnderlined;
	BYTE tmStruckOut;
	BYTE tmPitchAndFamily;
	BYTE tmCharSet;
	DWORD ntmFlags;
	UINT ntmSizeEM;
	UINT ntmCellHeight;
	UINT ntmAvgWidth;
} NEWTEXTMETRIC;
#pragma pack(pop)
typedef struct tagNEWTEXTMETRICEX {
	NEWTEXTMETRIC ntmentm;
	FONTSIGNATURE ntmeFontSignature;
} NEWTEXTMETRICEX;
typedef struct tagNM_LISTVIEW {
	NMHDR hdr;
	int iItem;
	int iSubItem;
	UINT uNewState;
	UINT uOldState;
	UINT uChanged;
	POINT ptAction;
	LPARAM lParam;
} NM_LISTVIEW,*LPNM_LISTVIEW;
typedef struct _TREEITEM *HTREEITEM;
typedef struct tagTVITEMA {
	UINT mask;
	HTREEITEM hItem;
	UINT state;
	UINT stateMask;
	LPSTR pszText;
	int cchTextMax;
	int iImage;
	int iSelectedImage;
	int cChildren;
	LPARAM lParam;
} TVITEMA, *LPTVITEMA;
typedef struct tagTVITEMW {
	UINT mask;
	HTREEITEM hItem;
	UINT state;
	UINT stateMask;
	LPWSTR pszText;
	int cchTextMax;
	int iImage;
	int iSelectedImage;
	int cChildren;
	LPARAM lParam;
} TVITEMW, *LPTVITEMW;
#define TV_ITEM	TVITEM
#define LPTV_ITEM	LPTVITEM
#ifdef UNICODE
#define TVITEM	TVITEMW
#define	LPTVITEM LPTVITEMW
#else
#define TVITEM	TVITEMA
#define	LPTVITEM LPTVITEMA
#endif
typedef struct tagTVITEMEXA {
	UINT	mask;
	HTREEITEM hItem;
	UINT	state;
	UINT	stateMask;
	LPSTR	pszText;
	int	cchTextMax;
	int	iImage;
	int	iSelectedImage;
	int	cChildren;
	LPARAM	lParam;
	int	iIntegral;
} TVITEMEXA, *LPTVITEMEXA;
typedef struct tagTVITEMEXW {
	UINT	mask;
	HTREEITEM hItem;
	UINT	state;
	UINT	stateMask;
	LPWSTR	pszText;
	int	cchTextMax;
	int	iImage;
	int	iSelectedImage;
	int	cChildren;
	LPARAM	lParam;
	int	iIntegral;
} TVITEMEXW,*LPTVITEMEXW;
typedef struct tagTVINSERTSTRUCTA {
	HTREEITEM hParent;
	HTREEITEM hInsertAfter;
	union {
		TVITEMEXA itemex;
		TVITEMA item;
	};
} TVINSERTSTRUCTA,*LPTVINSERTSTRUCTA;
typedef struct tagTVINSERTSTRUCTW {
	HTREEITEM hParent;
	HTREEITEM hInsertAfter;
	union {
		TVITEMEXW itemex;
		TVITEMW item;
	} ;
} TVINSERTSTRUCTW,*LPTVINSERTSTRUCTW;
typedef struct _NM_TREEVIEW {
	NMHDR hdr;
	UINT action;
	TV_ITEM itemOld;
	TV_ITEM itemNew;
	POINT ptDrag;
} NM_TREEVIEW;
typedef NM_TREEVIEW *LPNM_TREEVIEW;
typedef NM_TREEVIEW *LPNMTREEVIEW;
typedef struct _NM_UPDOWN {
	NMHDR hdr;
	int iPos;
	int iDelta;
} NMUPDOWN,*LPNMUPDOWN;
typedef struct tagNONCLIENTMETRICS {
	UINT cbSize;
	int iBorderWidth;
	int iScrollWidth;
	int iScrollHeight;
	int iCaptionWidth;
	int iCaptionHeight;
	LOGFONT lfCaptionFont;
	int iSmCaptionWidth;
	int iSmCaptionHeight;
	LOGFONT lfSmCaptionFont;
	int iMenuWidth;
	int iMenuHeight;
	LOGFONT lfMenuFont;
	LOGFONT lfStatusFont;
	LOGFONT lfMessageFont;
} NONCLIENTMETRICS,*LPNONCLIENTMETRICS;
typedef struct _SERVICE_ADDRESS {
	DWORD dwAddressType;
	DWORD dwAddressFlags;
	DWORD dwAddressLength;
	DWORD dwPrincipalLength;
	BYTE *lpAddress;
	BYTE *lpPrincipal;
} SERVICE_ADDRESS;
typedef struct _SERVICE_ADDRESSES {
	DWORD dwAddressCount;
	SERVICE_ADDRESS Addresses[1];
} SERVICE_ADDRESSES,*LPSERVICE_ADDRESSES;
#ifndef GUID_DEFINED
typedef struct _GUID {
	unsigned long Data1;
	unsigned short Data2;
	unsigned short Data3;
	unsigned char Data4[8];
} GUID,*LPGUID;
typedef CONST GUID *LPCGUID;
#define GUID_DEFINED
#endif
#if !defined(__IID_DEFINED__)
#define __IID_DEFINED__
typedef GUID IID;
typedef IID *LPIID;
typedef IID *REFIID;
typedef GUID CLSID,*LPCLSID;
typedef CLSID *REFCLSID;
typedef GUID *REFGUID;
#endif
typedef struct tagRemHGLOBAL {
	long fNullHGlobal;
	unsigned long cbData;
	unsigned char data[1]; } RemHGLOBAL;
typedef struct tagRemHMETAFILEPICT {
	long mm;
	long xExt;
	long yExt;
	unsigned long cbData;
	unsigned char data[1];
}	RemHMETAFILEPICT;
typedef void *HMETAFILEPICT;
typedef struct tagRemHENHMETAFILE {
	unsigned long cbData;
	unsigned char data[1];
	} RemHENHMETAFILE;
typedef struct tagRemHBITMAP {
	unsigned long cbData;
	unsigned char data[1];
}	RemHBITMAP;
typedef struct tagRemHPALETTE {
	unsigned long cbData;
	unsigned char data[1];
}	RemHPALETTE;
typedef struct tagRemBRUSH {
	unsigned long cbData;
	unsigned char data[1];
}	RemHBRUSH;
typedef struct _numberfmta {
	UINT NumDigits;
	UINT LeadingZero;
	UINT Grouping;
	LPSTR lpDecimalSep;
	LPSTR lpThousandSep;
	UINT NegativeOrder;
} NUMBERFMTA;
typedef struct _numberfmtw {
	UINT NumDigits;
	UINT LeadingZero;
	UINT Grouping;
	LPWSTR lpDecimalSep;
	LPWSTR lpThousandSep;
	UINT NegativeOrder;
} NUMBERFMTW;
typedef struct _OFSTRUCT {
	BYTE cBytes;
	BYTE fFixedDisk;
	WORD nErrCode;
	WORD Reserved1;
	WORD Reserved2;
	CHAR szPathName[OFS_MAXPATHNAME];
} OFSTRUCT,*LPOFSTRUCT;
typedef struct tagOFNA {
	DWORD	lStructSize;
	HWND	hwndOwner;
	HINSTANCE	hInstance;
	LPCSTR	lpstrFilter;
	LPSTR	lpstrCustomFilter;
	DWORD	nMaxCustFilter;
	DWORD	nFilterIndex;
	LPSTR	lpstrFile;
	DWORD	nMaxFile;
	LPSTR	lpstrFileTitle;
	DWORD	nMaxFileTitle;
	LPCSTR	lpstrInitialDir;
	LPCSTR	lpstrTitle;
	DWORD	Flags;
	WORD	nFileOffset;
	WORD	nFileExtension;
	LPCSTR	lpstrDefExt;
	LPARAM	lCustData;
	LPOFNHOOKPROC	lpfnHook;
	LPCSTR	lpTemplateName;
} OPENFILENAMEA,*LPOPENFILENAMEA;
typedef struct tagOFNW {
	DWORD	lStructSize;
	HWND	hwndOwner;
	HINSTANCE	hInstance;
	LPCWSTR	lpstrFilter;
	LPWSTR	lpstrCustomFilter;
	DWORD	nMaxCustFilter;
	DWORD	nFilterIndex;
	LPWSTR	lpstrFile;
	DWORD	nMaxFile;
	LPWSTR	lpstrFileTitle;
	DWORD	nMaxFileTitle;
	LPCWSTR	lpstrInitialDir;
	LPCWSTR	lpstrTitle;
	DWORD	Flags;
	WORD	nFileOffset;
	WORD	nFileExtension;
	LPCWSTR	lpstrDefExt;
	LPARAM	lCustData;
	LPOFNHOOKPROC	lpfnHook;
	LPCWSTR	lpTemplateName;
} OPENFILENAMEW, *LPOPENFILENAMEW;
#ifdef UNICODE
typedef TVITEMEXW TVITEMEX;
typedef LPTVITEMEXW LPTVITEMEX;
#define LPOPENFILENAME LPOPENFILENAMEW
#define OPENFILENAME OPENFILENAMEW
#define TVINSERTSTRUCT		TVINSERTSTRUCTW
#define LPTVINSERTSTRUCT	LPTVINSERTSTRUCTW
#define NUMBERFMT	NUMBERFMTW
#else
#define LPOPENFILENAME LPOPENFILENAMEA
#define OPENFILENAME OPENFILENAMEA
typedef TVITEMEXA TVITEMEX;
typedef LPTVITEMEXA LPTVITEMEX;
#define TVINSERTSTRUCT		TVINSERTSTRUCTA
#define LPTVINSERTSTRUCT	LPTVINSERTSTRUCTA
#define NUMBERFMT	NUMBERFMTA
#endif
typedef struct _OFNOTIFY {
	NMHDR hdr;
	LPOPENFILENAME lpOFN;
	LPTSTR pszFile;
} OFNOTIFY,*LPOFNOTIFY;
typedef struct _OSVERSIONINFOA {
	DWORD dwOSVersionInfoSize;
	DWORD dwMajorVersion;
	DWORD dwMinorVersion;
	DWORD dwBuildNumber;
	DWORD dwPlatformId;
	CHAR szCSDVersion[128];
} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;

typedef struct _OSVERSIONINFOW {
	DWORD dwOSVersionInfoSize;
	DWORD dwMajorVersion;
	DWORD dwMinorVersion;
	DWORD dwBuildNumber;
	DWORD dwPlatformId;
	WCHAR szCSDVersion[128];
} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW, RTL_OSVERSIONINFOW, *PRTL_OSVERSIONINFOW;
typedef struct _OSVERSIONINFOEXA {
	DWORD dwOSVersionInfoSize;
	DWORD dwMajorVersion;
	DWORD dwMinorVersion;
	DWORD dwBuildNumber;
	DWORD dwPlatformId;
	CHAR szCSDVersion[128];
	WORD wServicePackMajor;
	WORD wServicePackMinor;
	WORD wSuiteMask;
	BYTE wProductType;
	BYTE wReserved;
} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;

typedef struct _OSVERSIONINFOEXW {
	DWORD dwOSVersionInfoSize;
	DWORD dwMajorVersion;
	DWORD dwMinorVersion;
	DWORD dwBuildNumber;
	DWORD dwPlatformId;
	WCHAR szCSDVersion[128];
	WORD wServicePackMajor;
	WORD wServicePackMinor;
	WORD wSuiteMask;
	BYTE wProductType;
	BYTE wReserved;
} OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW, RTL_OSVERSIONINFOEXW, *PRTL_OSVERSIONINFOEXW;
#ifdef UNICODE
typedef OSVERSIONINFOW OSVERSIONINFO;
typedef POSVERSIONINFOW POSVERSIONINFO;
typedef LPOSVERSIONINFOW LPOSVERSIONINFO;
typedef OSVERSIONINFOEXW OSVERSIONINFOEX;
typedef POSVERSIONINFOEXW POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXW LPOSVERSIONINFOEX;
#else
typedef OSVERSIONINFOEXA OSVERSIONINFOEX;
typedef POSVERSIONINFOEXA POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXA LPOSVERSIONINFOEX;
typedef OSVERSIONINFOA OSVERSIONINFO;
typedef POSVERSIONINFOA POSVERSIONINFO;
typedef LPOSVERSIONINFOA LPOSVERSIONINFO;
#endif
typedef struct tagTEXTMETRIC {
	LONG tmHeight;
	LONG tmAscent;
	LONG tmDescent;
	LONG tmInternalLeading;
	LONG tmExternalLeading;
	LONG tmAveCharWidth;
	LONG tmMaxCharWidth;
	LONG tmWeight;
	LONG tmOverhang;
	LONG tmDigitizedAspectX;
	LONG tmDigitizedAspectY;
	BCHAR tmFirstChar;
	BCHAR tmLastChar;
	BCHAR tmDefaultChar;
	BCHAR tmBreakChar;
	BYTE tmItalic;
	BYTE tmUnderlined;
	BYTE tmStruckOut;
	BYTE tmPitchAndFamily;
	BYTE tmCharSet;
	BYTE pad1;
	BYTE pad2;
	BYTE pad3;
	BYTE pad4;
} TEXTMETRIC,*LPTEXTMETRIC;
typedef int (CALLBACK *OLDFONTENUMPROC)(LOGFONT *,TEXTMETRIC *,DWORD,LPARAM);
typedef struct tagTEXTMETRIC *PTEXTMETRIC;
typedef struct tagTEXTMETRICW {
	LONG	tmHeight;
	LONG	tmAscent;
	LONG	tmDescent;
	LONG	tmInternalLeading;
	LONG	tmExternalLeading;
	LONG	tmAveCharWidth;
	LONG	tmMaxCharWidth;
	LONG	tmWeight;
	LONG	tmOverhang;
	LONG	tmDigitizedAspectX;
	LONG	tmDigitizedAspectY;
	WCHAR	tmFirstChar;
	WCHAR	tmLastChar;
	WCHAR	tmDefaultChar;
	WCHAR	tmBreakChar;
	BYTE	tmItalic;
	BYTE	tmUnderlined;
	BYTE	tmStruckOut;
	BYTE	tmPitchAndFamily;
	BYTE	tmCharSet;
} TEXTMETRICW,*PTEXTMETRICW,*NPTEXTMETRICW,*LPTEXTMETRICW;
typedef struct _OUTLINETEXTMETRIC {
	UINT otmSize;
	TEXTMETRIC otmTextMetrics;
	BYTE otmFiller;
	PANOSE otmPanoseNumber;
	UINT otmfsSelection;
	UINT otmfsType;
	int otmsCharSlopeRise;
	int otmsCharSlopeRun;
	int otmItalicAngle;
	UINT otmEMSquare;
	int otmAscent;
	int otmDescent;
	UINT otmLineGap;
	UINT otmsCapEmHeight;
	UINT otmsXHeight;
	RECT otmrcFontBox;
	int otmMacAscent;
	int otmMacDescent;
	UINT otmMacLineGap;
	UINT otmusMinimumPPEM;
	POINT otmptSubscriptSize;
	POINT otmptSubscriptOffset;
	POINT otmptSuperscriptSize;
	POINT otmptSuperscriptOffset;
	UINT otmsStrikeoutSize;
	int otmsStrikeoutPosition;
	int otmsUnderscoreSize;
	int otmsUnderscorePosition;
	PSTR otmpFamilyName;
	PSTR otmpFaceName;
	PSTR otmpStyleName;
	PSTR otmpFullName;
} OUTLINETEXTMETRIC,*LPOUTLINETEXTMETRIC;
typedef struct _OVERLAPPED {
	DWORD Internal;
	DWORD InternalHigh;
	DWORD Offset;
	DWORD OffsetHigh;
	HANDLE hEvent;
} OVERLAPPED,*LPOVERLAPPED;
typedef struct tagPSD {
	DWORD lStructSize;
	HWND hwndOwner;
	HGLOBAL hDevMode;
	HGLOBAL hDevNames;
	DWORD Flags;
	POINT ptPaperSize;
	RECT rtMinMargin;
	RECT rtMargin;
	HINSTANCE hInstance;
	LPARAM lCustData;
	LPPAGESETUPHOOK lpfnPageSetupHook;
	LPPAGEPAINTHOOK lpfnPagePaintHook;
	LPCTSTR lpPageSetupTemplateName;
	HGLOBAL hPageSetupTemplate;
} PAGESETUPDLG,*LPPAGESETUPDLG;
typedef struct tagPAINTSTRUCT {
	HDC hdc;
	BOOL fErase;
	RECT rcPaint;
	BOOL fRestore;
	BOOL fIncUpdate;
	BYTE rgbReserved[32];
} PAINTSTRUCT,*LPPAINTSTRUCT;
#ifndef __PARAFORMAT_DEFINED
#define __PARAFORMAT_DEFINED
typedef struct _paraformat {
	UINT cbSize;
	DWORD dwMask;
	WORD wNumbering;
	WORD wEffects;
	LONG dxStartIndent;
	LONG dxRightIndent;
	LONG dxOffset;
	WORD wAlignment;
	SHORT cTabCount;
	LONG rgxTabs[MAX_TAB_STOPS];
} PARAFORMAT;
#endif
typedef struct _POLYTEXT {
	int x;
	int y;
	UINT n;
	LPCTSTR lpstr;
	UINT uiFlags;
	RECT rcl;
	int *pdx;
} POLYTEXT;
typedef struct _PRIVILEGE_SET {
	DWORD PrivilegeCount;
	DWORD Control;
	LUID_AND_ATTRIBUTES Privilege[ANYSIZE_ARRAY];
} PRIVILEGE_SET,*PPRIVILEGE_SET,*LPPRIVILEGE_SET;
typedef struct _PROCESS_HEAP_ENTRY {
	PVOID lpData;
	DWORD cbData;
	BYTE cbOverhead;
	BYTE iRegionIndex;
	WORD wFlags;
	DWORD dwCommittedSize;
	DWORD dwUnCommittedSize;
	LPVOID lpFirstBlock;
	LPVOID lpLastBlock;
	HANDLE hMem;
} PROCESS_HEAP_ENTRY,*LPPROCESS_HEAP_ENTRY;
typedef struct _PROCESS_INFORMATION {
	HANDLE hProcess;
	HANDLE hThread;
	DWORD dwProcessId;
	DWORD dwThreadId;
} PROCESS_INFORMATION,*LPPROCESS_INFORMATION;
typedef PROCESS_INFORMATION *PPROCESS_INFORMATION;
typedef UINT(CALLBACK * LPFNPSPCALLBACK) (HWND,UINT,LPVOID);
typedef struct _PROPSHEETPAGE {
	DWORD dwSize;
	DWORD dwFlags;
	HINSTANCE hInstance;
	union {
		LPCTSTR pszTemplate;
		LPCDLGTEMPLATE pResource;
	};
	union {
		HICON hIcon;
		LPCTSTR pszIcon;
	};
	LPCTSTR pszTitle;
	DLGPROC pfnDlgProc;
	LPARAM lParam;
	LPFNPSPCALLBACK pfnCallback;
	UINT *pcRefParent;
} PROPSHEETPAGE,*LPPROPSHEETPAGE;
typedef const PROPSHEETPAGE *LPCPROPSHEETPAGE;
typedef struct _PSP *HPROPSHEETPAGE;
typedef struct _PROPSHEETHEADER {
	DWORD dwSize;
	DWORD dwFlags;
	HWND hwndParent;
	HINSTANCE hInstance;
	union {
		HICON hIcon;
		LPCTSTR pszIcon;
	};
	LPCTSTR pszCaption;
	UINT nPages;
	union {
		UINT nStartPage;
		LPCTSTR pStartPage;
	};
	union {
		LPCPROPSHEETPAGE ppsp;
		HPROPSHEETPAGE *phpage;
	};
	PFNPROPSHEETCALLBACK pfnCallback;
} PROPSHEETHEADER,*LPPROPSHEETHEADER;
typedef const PROPSHEETHEADER *LPCPROPSHEETHEADER;
typedef BOOL(CALLBACK * LPFNADDPROPSHEETPAGE) (HPROPSHEETPAGE,LPARAM);
typedef
BOOL(CALLBACK * LPFNADDPROPSHEETPAGES) (LPVOID, LPFNADDPROPSHEETPAGE, LPARAM);
typedef struct _PROTOCOL_INFO {
	DWORD dwServiceFlags;
	INT iAddressFamily;
	INT iMaxSockAddr;
	INT iMinSockAddr;
	INT iSocketType;
	INT iProtocol;
	DWORD dwMessageSize;
	LPTSTR lpProtocol;
} PROTOCOL_INFO;
typedef struct _PSHNOTIFY {
	NMHDR hdr;
	LPARAM lParam;
} PSHNOTIFY,*LPPSHNOTIFY;
typedef struct _RASAMB {
	DWORD dwSize;
	DWORD dwError;
	TCHAR szNetBiosError[NETBIOS_NAME_LEN + 1];
	BYTE bLana;
} RASAMB;
typedef struct _RASTERIZER_STATUS {
	short nSize;
	short wFlags;
	short nLanguageID;
} RASTERIZER_STATUS,*LPRASTERIZER_STATUS;
typedef struct _REMOTE_NAME_INFO {
	LPTSTR lpUniversalName;
	LPTSTR lpConnectionName;
	LPTSTR lpRemainingPath;
} REMOTE_NAME_INFO;
typedef struct _RGNDATAHEADER {
	DWORD dwSize;
	DWORD iType;
	DWORD nCount;
	DWORD nRgnSize;
	RECT rcBound;
} RGNDATAHEADER;
typedef struct _RGNDATA {
	RGNDATAHEADER rdh;
	char Buffer[1];
} RGNDATA,*LPRGNDATA;
typedef struct tagSCROLLINFO {
	UINT cbSize;
	UINT fMask;
	int nMin;
	int nMax;
	UINT nPage;
	int nPos;
	int nTrackPos;
} SCROLLINFO,*LPSCROLLINFO;
typedef SCROLLINFO const *LPCSCROLLINFO;
typedef struct _SECURITY_ATTRIBUTES {
	DWORD nLength;
	LPVOID lpSecurityDescriptor;
	BOOL bInheritHandle;
} SECURITY_ATTRIBUTES,*LPSECURITY_ATTRIBUTES;
typedef DWORD SECURITY_INFORMATION,*PSECURITY_INFORMATION;
typedef struct tagSERIALKEYS {
	DWORD cbSize;
	DWORD dwFlags;
	LPSTR lpszActivePort;
	LPSTR lpszPort;
	DWORD iBaudRate;
	DWORD iPortState;
} SERIALKEYS,*LPSERIALKEYS;
typedef struct _SESSION_BUFFER {
	UCHAR lsn;
	UCHAR state;
	UCHAR local_name[NCBNAMSZ];
	UCHAR remote_name[NCBNAMSZ];
	UCHAR rcvs_outstanding;
	UCHAR sends_outstanding;
} SESSION_BUFFER;
typedef struct _SESSION_HEADER {
	UCHAR sess_name;
	UCHAR num_sess;
	UCHAR rcv_dg_outstanding;
	UCHAR rcv_any_outstanding;
} SESSION_HEADER;
//#ifndef SHCONTF_DEFINED
//typedef enum tagSHCONTF { SHCONTF_FOLDERS=32, SHCONTF_NONFOLDERS=64, SHCONTF_INCLUDEHIDDEN=128,
//SHCONTF_INIT_ON_FIRST_NEXT=256, SHCONTF_NETPRINTERSRCH=512, SHCONTF_SHAREABLE=1024,
//SHCONTF_STORAGE=2048 };
//
//typedef DWORD SHCONTF;
//
//#define SHCONTF_DEFINED
//#endif
#ifndef __FILEOP_FLAGS_DEFINED
typedef WORD FILEOP_FLAGS;
#define __FILEOP_FLAGS_DEFINED
#endif
#ifndef SHGNO_DEFINED
typedef enum tagSHGDN { SHGDN_NORMAL=0, SHGDN_INFOLDER=1, SHGDN_FOREDITING=4096,
SHGDN_FORADDRESSBAR=0x4000, SHGDN_FORPARSING=0x8000 } SHGNO;
#define SHGNO_DEFINED
#endif
typedef struct _SID_AND_ATTRIBUTES {
	PSID Sid;
	DWORD Attributes;
} SID_AND_ATTRIBUTES,*PSID_AND_ATTRIBUTES;
typedef SID_AND_ATTRIBUTES SID_AND_ATTRIBUTES_ARRAY[ANYSIZE_ARRAY];
typedef SID_AND_ATTRIBUTES_ARRAY *PSID_AND_ATTRIBUTES_ARRAY;
typedef struct _SINGLE_LIST_ENTRY {
	struct _SINGLE_LIST_ENTRY *Next;
} SINGLE_LIST_ENTRY;
typedef struct tagSOUNDSENTRY {
	UINT cbSize;
	DWORD dwFlags;
	DWORD iFSTextEffect;
	DWORD iFSTextEffectMSec;
	DWORD iFSTextEffectColorBits;
	DWORD iFSGrafEffect;
	DWORD iFSGrafEffectMSec;
	DWORD iFSGrafEffectColor;
	DWORD iWindowsEffect;
	DWORD iWindowsEffectMSec;
	LPTSTR lpszWindowsEffectDLL;
	DWORD iWindowsEffectOrdinal;
} SOUNDSENTRY,*LPSOUNDSENTRY;
typedef struct _STARTUPINFOA {
	DWORD cb;
	LPSTR lpReserved;
	LPSTR lpDesktop;
	LPSTR lpTitle;
	DWORD dwX;
	DWORD dwY;
	DWORD dwXSize;
	DWORD dwYSize;
	DWORD dwXCountChars;
	DWORD dwYCountChars;
	DWORD dwFillAttribute;
	DWORD dwFlags;
	WORD wShowWindow;
	WORD cbReserved2;
	LPBYTE lpReserved2;
	HANDLE hStdInput;
	HANDLE hStdOutput;
	HANDLE hStdError;
} STARTUPINFOA, *LPSTARTUPINFOA;
typedef struct _STARTUPINFOW {
	DWORD cb;
	LPWSTR lpReserved;
	LPWSTR lpDesktop;
	LPWSTR lpTitle;
	DWORD dwX;
	DWORD dwY;
	DWORD dwXSize;
	DWORD dwYSize;
	DWORD dwXCountChars;
	DWORD dwYCountChars;
	DWORD dwFillAttribute;
	DWORD dwFlags;
	WORD wShowWindow;
	WORD cbReserved2;
	LPBYTE lpReserved2;
	HANDLE hStdInput;
	HANDLE hStdOutput;
	HANDLE hStdError;
} STARTUPINFOW, *LPSTARTUPINFOW;
#ifdef UNICODE
typedef STARTUPINFOW STARTUPINFO;
typedef LPSTARTUPINFOW LPSTARTUPINFO;
#else
typedef STARTUPINFOA STARTUPINFO;
typedef LPSTARTUPINFOA LPSTARTUPINFO;
#endif
typedef struct tagSTICKYKEYS {
	DWORD cbSize;
	DWORD dwFlags;
} STICKYKEYS,*LPSTICKYKEYS;
#ifndef _STRRET_DEFINED
#pragma pack(push,8)
typedef struct _STRRET { UINT uType; union { LPWSTR pOleStr; UINT uOffset; char cStr[260]; } ;
} STRRET,*LPSTRRET;
#define _STRRET_DEFINED
#endif
#pragma pack(pop)
typedef struct tagSTYLESTRUCT {
	DWORD styleOld;
	DWORD styleNew;
} STYLESTRUCT,*LPSTYLESTRUCT;
typedef struct _SYSTEM_AUDIT_ACE {
	ACE_HEADER Header;
	ACCESS_MASK Mask;
	DWORD SidStart;
} SYSTEM_AUDIT_ACE;
typedef struct _SYSTEM_INFO {
	WORD wProcessorArchitecture;
	WORD wReserved;
	DWORD dwPageSize;
	LPVOID lpMinimumApplicationAddress;
	LPVOID lpMaximumApplicationAddress;
	DWORD dwActiveProcessorMask;
	DWORD dwNumberOfProcessors;
	DWORD dwProcessorType;
	DWORD dwAllocationGranularity;
	WORD wProcessorLevel;
	WORD wProcessorRevision;
} SYSTEM_INFO,*LPSYSTEM_INFO;
typedef struct _SYSTEM_POWER_STATUS {
	BYTE ACLineStatus;
	BYTE BatteryFlag;
	BYTE BatteryLifePercent;
	BYTE Reserved1;
	DWORD BatteryLifeTime;
	DWORD BatteryFullLifeTime;
} SYSTEM_POWER_STATUS;
typedef SYSTEM_POWER_STATUS *LPSYSTEM_POWER_STATUS;
typedef struct _TAPE_ERASE {
	ULONG Type;
} TAPE_ERASE;
typedef struct _TAPE_GET_DRIVE_PARAMETERS {
	BOOLEAN ECC;
	BOOLEAN Compression;
	BOOLEAN DataPadding;
	BOOLEAN ReportSetmarks;
	ULONG DefaultBlockSize;
	ULONG MaximumBlockSize;
	ULONG MinimumBlockSize;
	ULONG MaximumPartitionCount;
	ULONG FeaturesLow;
	ULONG FeaturesHigh;
	ULONG EOTWarningZoneSize;
} TAPE_GET_DRIVE_PARAMETERS;
typedef struct _TAPE_GET_MEDIA_PARAMETERS {
	LARGE_INTEGER Capacity;
	LARGE_INTEGER Remaining;
	DWORD BlockSize;
	DWORD PartitionCount;
	BOOLEAN WriteProtected;
} TAPE_GET_MEDIA_PARAMETERS;
typedef struct _TAPE_GET_POSITION {
	ULONG Type;
	ULONG Partition;
	ULONG OffsetLow;
	ULONG OffsetHigh;
} TAPE_GET_POSITION;
typedef struct _TAPE_PREPARE {
	ULONG Operation;
} TAPE_PREPARE;
typedef struct _TAPE_SET_DRIVE_PARAMETERS {
	BOOLEAN ECC;
	BOOLEAN Compression;
	BOOLEAN DataPadding;
	BOOLEAN ReportSetmarks;
	ULONG EOTWarningZoneSize;
} TAPE_SET_DRIVE_PARAMETERS;
typedef struct _TAPE_SET_MEDIA_PARAMETERS {
	ULONG BlockSize;
} TAPE_SET_MEDIA_PARAMETERS;
typedef struct _TAPE_SET_POSITION {
	ULONG Method;
	ULONG Partition;
	ULONG OffsetLow;
	ULONG OffsetHigh;
} TAPE_SET_POSITION;
typedef struct _TAPE_WRITE_MARKS {
	ULONG Type;
	ULONG Count;
} TAPE_WRITE_MARKS;
typedef struct tagTBADDBITMAP {
	HINSTANCE hInst;
	UINT nID;
} TBADDBITMAP,*LPTBADDBITMAP;
typedef struct _TBBUTTON {
	int iBitmap;
	int idCommand;
	BYTE fsState;
	BYTE fsStyle;
	BYTE bReserved[2];
	DWORD dwData;
	int iString;
} TBBUTTON,*PTBBUTTON,*LPTBBUTTON;
typedef const TBBUTTON *LPCTBBUTTON;
typedef struct tagNMTOOLBARA {
	NMHDR	hdr;
	int	iItem;
	TBBUTTON tbButton;
	int	cchText;
	LPSTR	pszText;
	RECT	rcButton;
} NMTOOLBARA,*LPNMTOOLBARA;
typedef struct tagNMTOOLBARW {
	NMHDR	hdr;
	int	iItem;
	TBBUTTON tbButton;
	int	cchText;
	LPWSTR	pszText;
	RECT	rcButton;
} NMTOOLBARW, *LPNMTOOLBARW;
typedef struct tagNMTOOLTIPSCREATED {
	NMHDR hdr;
	HWND hwndToolTips;
} NMTOOLTIPSCREATED, * LPNMTOOLTIPSCREATED;
typedef struct tagTBSAVEPARAMSA {
	HKEY hkr;
	LPCSTR pszSubKey;
	LPCSTR pszValueName;
} TBSAVEPARAMSA,*LPTBSAVEPARAMSA;
typedef struct tagTBSAVEPARAMSW {
	HKEY hkr;
	LPCWSTR pszSubKey;
	LPCWSTR pszValueName;
} TBSAVEPARAMSW,*LPTBSAVEPARAMW;
#ifdef UNICODE
#define TBSAVEPARAMS	TBSAVEPARAMSW
#define LPTBSAVEPARAMS	LPTBSAVEPARAMSW
#else
#define TBSAVEPARAMS	TBSAVEPARAMSA
#define LPTBSAVEPARAMS	LPTBSAVEPARAMSA
#endif
typedef struct _TC_HITTESTINFO {
	POINT pt;
	UINT flags;
} TC_HITTESTINFO;
typedef struct _TC_ITEM {
	UINT mask;
	UINT lpReserved1;
	UINT lpReserved2;
	LPTSTR pszText;
	int cchTextMax;
	int iImage;
	LPARAM lParam;
} TC_ITEM;
typedef struct _TC_ITEMHEADER {
	UINT mask;
	UINT lpReserved1;
	UINT lpReserved2;
	LPTSTR pszText;
	int cchTextMax;
	int iImage;
} TC_ITEMHEADER;
typedef struct _TC_KEYDOWN {
	NMHDR hdr;
	WORD wVKey;
	UINT flags;
} NMTCKEYDOWN;
#ifndef _TEXTRANGE_DEFINED
#define _TEXTRANGE_DEFINED
typedef struct _textrange { CHARRANGE chrg; LPSTR lpstrText; } TEXTRANGE;
#endif
typedef struct _TIME_ZONE_INFORMATION {
	LONG Bias;
	WCHAR StandardName[32];
	SYSTEMTIME StandardDate;
	LONG StandardBias;
	WCHAR DaylightName[32];
	SYSTEMTIME DaylightDate;
	LONG DaylightBias;
} TIME_ZONE_INFORMATION,*LPTIME_ZONE_INFORMATION;
typedef struct tagTOGGLEKEYS {
	DWORD cbSize;
	DWORD dwFlags;
} TOGGLEKEYS;
typedef struct _TOKEN_SOURCE {
	CHAR SourceName[8];
	LUID SourceIdentifier;
} TOKEN_SOURCE,*PTOKEN_SOURCE;
typedef struct _TOKEN_CONTROL {
	LUID TokenId;
	LUID AuthenticationId;
	LUID ModifiedId;
	TOKEN_SOURCE TokenSource;
} TOKEN_CONTROL;
typedef struct _TOKEN_DEFAULT_DACL {
	PACL DefaultDacl;
} TOKEN_DEFAULT_DACL;
typedef struct _TOKEN_GROUPS {
	DWORD GroupCount;
	SID_AND_ATTRIBUTES Groups[ANYSIZE_ARRAY];
} TOKEN_GROUPS,*PTOKEN_GROUPS,*LPTOKEN_GROUPS;
typedef struct _TOKEN_OWNER {
	PSID Owner;
} TOKEN_OWNER;
typedef struct _TOKEN_PRIMARY_GROUP {
	PSID PrimaryGroup;
} TOKEN_PRIMARY_GROUP;
typedef struct _TOKEN_PRIVILEGES {
	DWORD PrivilegeCount;
	LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];
} TOKEN_PRIVILEGES,*PTOKEN_PRIVILEGES,*LPTOKEN_PRIVILEGES;
typedef struct _TOKEN_STATISTICS {
	LUID TokenId;
	LUID AuthenticationId;
	LARGE_INTEGER ExpirationTime;
	TOKEN_TYPE TokenType;
	SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
	DWORD DynamicCharged;
	DWORD DynamicAvailable;
	DWORD GroupCount;
	DWORD PrivilegeCount;
	LUID ModifiedId;
} TOKEN_STATISTICS;
typedef struct _TOKEN_USER {
	SID_AND_ATTRIBUTES User;
} TOKEN_USER;
typedef struct {
	UINT cbSize;
	UINT uFlags;
	HWND hwnd;
	UINT uId;
	RECT rect;
	HINSTANCE hinst;
	LPTSTR lpszText;
	LPARAM lParam;
} TOOLINFO,*PTOOLINFO,*LPTOOLINFO;
typedef struct {
	NMHDR hdr;
	LPTSTR lpszText;
	char szText[80];
	HINSTANCE hinst;
	UINT uFlags;
} TOOLTIPTEXT,*LPTOOLTIPTEXT;
typedef struct tagTPMPARAMS {
	UINT cbSize;
	RECT rcExclude;
} TPMPARAMS,*LPTPMPARAMS;
typedef struct _TT_HITTESTINFO {
	HWND hwnd;
	POINT pt;
	TOOLINFO ti;
} TTHITTESTINFO,*LPHITTESTINFO;
typedef struct tagTTPOLYCURVE {
	WORD wType;
	WORD cpfx;
	POINTFX apfx[1];
} TTPOLYCURVE,*LPTTPOLYCURVE;
typedef struct _TTPOLYGONHEADER {
	DWORD cb;
	DWORD dwType;
	POINTFX pfxStart;
} TTPOLYGONHEADER,*LPTTPOLYGONHEADER;
typedef struct _TV_DISPINFO {
	NMHDR hdr;
	TV_ITEM item;
} TV_DISPINFO;
typedef struct tagTVDISPINFOA {
	NMHDR hdr;
	TVITEMA item;
} NMTVDISPINFOA, *LPNMTVDISPINFOA;
typedef struct tagTVDISPINFOW {
	NMHDR hdr;
	TVITEMW item;
} NMTVDISPINFOW, *LPNMTVDISPINFOW;
typedef struct _TVHITTESTINFO {
	POINT pt;
	UINT flags;
	HTREEITEM hItem;
} TV_HITTESTINFO,*LPTV_HITTESTINFO;
typedef struct _TV_INSERTSTRUCT {
	HTREEITEM hParent;
	HTREEITEM hInsertAfter;
	TV_ITEM item;
} TV_INSERTSTRUCT,*LPTV_INSERTSTRUCT;
typedef struct _TV_KEYDOWN {
	NMHDR hdr;
	WORD wVKey;
	UINT flags;
} TV_KEYDOWN;
typedef struct _TV_SORTCB {
	HTREEITEM hParent;
	PFNTVCOMPARE lpfnCompare;
	LPARAM lParam;
} TV_SORTCB,*LPTV_SORTCB;
typedef union _ULARGE_INTEGER {
	struct {DWORD LowPart; DWORD HighPart;};
	long long QuadPart;
} ULARGE_INTEGER,*PULARGE_INTEGER;
typedef struct _UNIVERSAL_NAME_INFO {
	LPTSTR lpUniversalName;
} UNIVERSAL_NAME_INFO;
typedef struct tagUSEROBJECTFLAGS {
	BOOL fInherit;
	BOOL fReserved;
	DWORD dwFlags;
} USEROBJECTFLAGS;
typedef struct value_entA {
	LPSTR ve_valuename;
	DWORD ve_valuelen;
	DWORD ve_valueptr;
	DWORD ve_type;
}VALENTA, *PVALENTA;
typedef struct value_entW {
	LPWSTR ve_valuename;
	DWORD ve_valuelen;
	DWORD ve_valueptr;
	DWORD ve_type;
}VALENTW, *PVALENTW;
typedef struct pvalueA { LPSTR pv_valuename; int pv_valuelen; LPVOID pv_value_context;DWORD pv_type;}PVALUEA, *PPVALUEA;
typedef struct pvalueW { LPWSTR pv_valuename;int pv_valuelen;LPVOID pv_value_context;DWORD pv_type;}PVALUEW, *PPVALUEW;
#ifdef UNICODE
typedef PVALUEW PVALUE;
typedef PPVALUEW PPVALUE;
typedef VALENTW VALENT;
typedef PVALENTW PVALENT;
#define TBN_GETDISPINFO	TBN_GETDISPINFOW
#define NMTBDISPINFO	NMTBDISPINFOW
#define LPNMTBDISPINFO	LPNMTBDISPINFOW
#define TBN_GETINFOTIP	TBN_GETINFOTIPW
#define NMTBGETINFOTIP	NMTBGETINFOTIPW
#define LPNMTBGETINFOTIP	LPNMTBGETINFOTIPW
#define WIN32_FIND_DATA	WIN32_FIND_DATAW
#define LPWIN32_FIND_DATA LPWIN32_FIND_DATAW
#define NMTVDISPINFO	NMTVDISPINFOW
#define LPNMTVDISPINFO	LPNMTVDISPINFOW
#else
typedef PVALUEA PVALUE;
typedef PPVALUEA PPVALUE;
typedef VALENTA VALENT;
typedef PVALENTA PVALENT;
#define TBN_GETDISPINFO	TBN_GETDISPINFOA
#define NMTBDISPINFO	NMTBDISPINFOA
#define LPNMTBDISPINFO	LPNMTBDISPINFOA
#define TBN_GETINFOTIP	TBN_GETINFOTIPA
#define NMTBGETINFOTIP	NMTBGETINFOTIPA
#define LPNMTBGETINFOTIP	LPNMTBGETINFOTIPA
#define WIN32_FIND_DATA WIN32_FIND_DATAA
#define LPWIN32_FIND_DATA	LPWIN32_FIND_DATAA
#define NMTVDISPINFO	NMTVDISPINFOA
#define LPNMTVDISPINFO	LPNMTVDISPINFOA
#endif
typedef struct _WIN32_STREAM_ID {
	DWORD dwStreamId;
	DWORD dwStreamAttributes;
	LARGE_INTEGER Size;
	DWORD dwStreamNameSize;
	WCHAR *cStreamName;
} WIN32_STREAM_ID,*LPWIN32_STREAM_ID;
typedef struct _WINDOWPLACEMENT {
	UINT length;
	UINT flags;
	UINT showCmd;
	POINT ptMinPosition;
	POINT ptMaxPosition;
	RECT rcNormalPosition;
} WINDOWPLACEMENT,*LPWINDOWPLACEMENT,*PWINDOWPLACEMENT;
typedef struct tagWNDCLASSEXA {
	UINT	cbSize;
	UINT	style;
	WNDPROC	lpfnWndProc;
	int	cbClsExtra;
	int	cbWndExtra;
	HINSTANCE	hInstance;
	HICON	hIcon;
	HCURSOR	hCursor;
	HBRUSH	hbrBackground;
	LPCSTR	lpszMenuName;
	LPCSTR	lpszClassName;
	HICON	hIconSm;
} WNDCLASSEXA, *PWNDCLASSEXA,*NPWNDCLASSEXA,*LPWNDCLASSEXA;
typedef struct tagWNDCLASSEXW {
	UINT cbSize;
	UINT style;
	WNDPROC lpfnWndProc;
	int cbClsExtra;
	int cbWndExtra;
	HINSTANCE hInstance;
	HICON hIcon;
	HCURSOR hCursor;
	HBRUSH hbrBackground;
	LPCWSTR lpszMenuName;
	LPCWSTR lpszClassName;
	HICON hIconSm;
} WNDCLASSEXW,*PWNDCLASSEXW,*NPWNDCLASSEXW,*LPWNDCLASSEXW;
#ifdef UNICODE
typedef WNDCLASSEXW WNDCLASSEX;
typedef PWNDCLASSEXW PWNDCLASSEX;
typedef NPWNDCLASSEXW NPWNDCLASSEX;
typedef LPWNDCLASSEXW LPWNDCLASSEX;
#else
typedef WNDCLASSEXA WNDCLASSEX;
typedef PWNDCLASSEXA PWNDCLASSEX;
typedef NPWNDCLASSEXA NPWNDCLASSEX;
typedef LPWNDCLASSEXA LPWNDCLASSEX;
#endif
typedef struct tagWNDCLASSA {
	UINT	style;
	WNDPROC	lpfnWndProc;
	int	cbClsExtra;
	int	cbWndExtra;
	HINSTANCE	hInstance;
	HICON	hIcon;
	HCURSOR	hCursor;
	HBRUSH	hbrBackground;
	LPCSTR	lpszMenuName;
	LPCSTR	lpszClassName;
} WNDCLASSA, *PWNDCLASSA,*NPWNDCLASSA,*LPWNDCLASSA;
typedef struct tagWNDCLASSW {
	UINT	style;
	WNDPROC	lpfnWndProc;
	int	cbClsExtra;
	int	cbWndExtra;
	HINSTANCE hInstance;
	HICON	hIcon;
	HCURSOR	hCursor;
	HBRUSH	hbrBackground;
	LPCWSTR	lpszMenuName;
	LPCWSTR	lpszClassName;
} WNDCLASSW, *PWNDCLASSW,*NPWNDCLASSW,*LPWNDCLASSW;
#ifdef UNICODE
typedef WNDCLASSW WNDCLASS;
typedef PWNDCLASSW PWNDCLASS;
typedef NPWNDCLASSW NPWNDCLASS;
typedef LPWNDCLASSW LPWNDCLASS;
#else
typedef WNDCLASSA WNDCLASS;
typedef PWNDCLASSA PWNDCLASS;
typedef NPWNDCLASSA NPWNDCLASS;
typedef LPWNDCLASSA LPWNDCLASS;
#endif
typedef struct _CONNECTDLGSTRUCT {
	DWORD cbStructure;
	HWND hwndOwner;
	LPNETRESOURCE lpConnRes;
	DWORD dwFlags;
	DWORD dwDevNum;
} CONNECTDLGSTRUCT,*LPCONNECTDLGSTRUCT;
typedef struct _DISCDLGSTRUCT {
	DWORD cbStructure;
	HWND hwndOwner;
	LPTSTR lpLocalName;
	LPTSTR lpRemoteName;
	DWORD dwFlags;
} DISCDLGSTRUCT,*LPDISCDLGSTRUCT;
typedef struct _NETINFOSTRUCT {
	DWORD cbStructure;
	DWORD dwProviderVersion;
	DWORD dwStatus;
	DWORD dwCharacteristics;
	DWORD dwHandle;
	WORD wNetType;
	DWORD dwPrinters;
	DWORD dwDrives;
} NETINFOSTRUCT,*LPNETINFOSTRUCT;
typedef struct _NETCONNECTINFOSTRUCT {
	DWORD cbStructure;
	DWORD dwFlags;
	DWORD dwSpeed;
	DWORD dwDelay;
	DWORD dwOptDataSize;
} NETCONNECTINFOSTRUCT,*LPNETCONNECTINFOSTRUCT;
typedef struct _MESSAGE_RESOURCE_ENTRY {
	WORD	Length;
	WORD	Flags;
	BYTE	Text[ 1 ];
} MESSAGE_RESOURCE_ENTRY,*PMESSAGE_RESOURCE_ENTRY;
#define MESSAGE_RESOURCE_UNICODE 1
typedef struct _MESSAGE_RESOURCE_BLOCK {
	DWORD	LowId;
	DWORD	HighId;
	DWORD OffsetToEntries;
} MESSAGE_RESOURCE_BLOCK,*PMESSAGE_RESOURCE_BLOCK;
typedef struct _MESSAGE_RESOURCE_DATA {
	DWORD	NumberOfBlocks;
	MESSAGE_RESOURCE_BLOCK Blocks[1];
} MESSAGE_RESOURCE_DATA,*PMESSAGE_RESOURCE_DATA;
typedef enum tagMEMCTX {MEMCTX_TASK=1,MEMCTX_SHARED=2,MEMCTX_MACSYSTEM=3,MEMCTX_UNKNOWN = -1,MEMCTX_SAME=-2 }MEMCTX;
typedef enum tagCLSCTX {CLSCTX_INPROC_SERVER=1,CLSCTX_INPROC_HANDLER=2,
	CLSCTX_LOCAL_SERVER=4,CLSCTX_INPROC_SERVER16=8,CLSCTX_REMOTE_SERVER=16} CLSCTX;
typedef enum tagMSHLFLAGS {MSHLFLAGS_NORMAL=0,MSHLFLAGS_TABLESTRONG= 1,
	MSHLFLAGS_TABLEWEAK=2,MSHLFLAGS_NOPING=4} MSHLFLAGS;
typedef enum tagMSHCTX {MSHCTX_LOCAL=0,MSHCTX_NOSHAREDMEM=1,
	MSHCTX_DIFFERENTMACHINE=2,MSHCTX_INPROC=3,MSHCTX_CROSSCTX = 4} MSHCTX;
typedef enum _DVASPECT {DVASPECT_CONTENT=1,DVASPECT_THUMBNAIL=2,
 DVASPECT_ICON=4,DVASPECT_DOCPRINT=8} DVASPECT;
typedef enum tagSTGC {STGC_DEFAULT=0,STGC_OVERWRITE=1,
	STGC_ONLYIFCURRENT=2,STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE=4,STGC_CONSOLIDATE=8}STGC;
typedef enum tagSTGMOVE {STGMOVE_MOVE=0,STGMOVE_COPY=1,STGMOVE_SHALLOWCOPY=2}STGMOVE;
typedef enum tagSTATFLAG {STATFLAG_DEFAULT= 0,STATFLAG_NONAME=1,STATFLAG_NOOPEN=2} STATFLAG;
typedef void *HCONTEXT;
typedef struct tagLVBKIMAGEA {
	ULONG ulFlags;
	HBITMAP hbm;
	LPSTR pszImage;
	UINT cchImageMax;
	int xOffsetPercent;
	int yOffsetPercent;
} LVBKIMAGEA, *LPLVBKIMAGEA;
typedef struct tagLVBKIMAGEW {
	ULONG ulFlags;
	HBITMAP hbm;
	LPWSTR pszImage;
	UINT cchImageMax;
	int xOffsetPercent;
	int yOffsetPercent;
} LVBKIMAGEW, *LPLVBKIMAGEW;
typedef struct {
	UINT cbSize;
	DWORD dwMask;
	int idCommand;
	int iImage;
	BYTE fsState;
	BYTE fsStyle;
	WORD cx;
	DWORD_PTR lParam;
	LPSTR pszText;
	int cchText;
} TBBUTTONINFOA, *LPTBBUTTONINFOA;
typedef struct {
	UINT cbSize;
	DWORD dwMask;
	int idCommand;
	int iImage;
	BYTE fsState;
	BYTE fsStyle;
	WORD cx;
	DWORD *lParam;
	LPWSTR pszText;
	int cchText;
} TBBUTTONINFOW, *LPTBBUTTONINFOW;
typedef struct tagNMKEY {
	NMHDR hdr;
	UINT nVKey;
	UINT uFlags;
} NMKEY,*LPNMKEY;
typedef struct tagNMCHAR {
	NMHDR	hdr;
	UINT	ch;
	DWORD	dwItemPrev;
	DWORD	dwItemNext;
} NMCHAR,*LPNMCHAR;
typedef struct tagNMCUSTOMDRAWINFO {
	NMHDR hdr;
	DWORD dwDrawStage;
	HDC hdc;
	RECT rc;
	DWORD_PTR dwItemSpec;
	UINT uItemState;
	LPARAM lItemlParam;
} NMCUSTOMDRAW, FAR * LPNMCUSTOMDRAW;
typedef struct tagNMLVCUSTOMDRAW {
	NMCUSTOMDRAW nmcd;
	COLORREF clrText;
	COLORREF clrTextBk;
	int iSubItem;
} NMLVCUSTOMDRAW, *LPNMLVCUSTOMDRAW;
typedef struct _NMTBCUSTOMDRAW {
	NMCUSTOMDRAW nmcd;
	HBRUSH hbrMonoDither;
	HBRUSH hbrLines;
	HPEN hpenLines;
	COLORREF clrText;
	COLORREF clrMark;
	COLORREF clrTextHighlight;
	COLORREF clrBtnFace;
	COLORREF clrBtnHighlight;
	COLORREF clrHighlightHotTrack;
	RECT rcText;
	int nStringBkMode;
	int nHLStringBkMode;
} NMTBCUSTOMDRAW, *LPNMTBCUSTOMDRAW;
typedef struct {
	NMHDR hdr;
	DWORD dwMask;
	int idCommand;
	DWORD_PTR lParam;
	int iImage;
	LPSTR pszText;
	int cchText;
} NMTBDISPINFOA,*LPNMTBDISPINFOA;
typedef struct {
	NMHDR hdr;
	DWORD dwMask;
	int idCommand;
	DWORD_PTR lParam;
	int iImage;
	LPWSTR pszText;
	int cchText;
} NMTBDISPINFOW,*LPNMTBDISPINFOW;
typedef struct tagNMOBJECTNOTIFY {
	NMHDR	hdr;
	int	iItem;
	const void *piid;
	void *pObject;
	HRESULT hResult;
	DWORD dwFlags;
} NMOBJECTNOTIFY,*LPNMOBJECTNOTIFY;
typedef struct tagNMTBHOTITEM {
	NMHDR	hdr;
	int	idOld;
	int	idNew;
	DWORD	dwFlags;
} NMTBHOTITEM, * LPNMTBHOTITEM;
typedef struct tagNMTBGETINFOTIPA {
	NMHDR hdr;
	LPSTR pszText;
	int cchTextMax;
	int iItem;
	LPARAM lParam;
} NMTBGETINFOTIPA, *LPNMTBGETINFOTIPA;
typedef struct tagNMTBGETINFOTIPW {
	NMHDR hdr;
	LPWSTR pszText;
	int cchTextMax;
	int iItem;
	LPARAM lParam;
} NMTBGETINFOTIPW, *LPNMTBGETINFOTIPW;
typedef struct {
	int	iButton;
	DWORD dwFlags;
} TBINSERTMARK,*LPTBINSERTMARK;
typedef struct {
	HINSTANCE	hInstOld;
	UINT_PTR	nIDOld;
	HINSTANCE	hInstNew;
	UINT_PTR	nIDNew;
	int	nButtons;
} TBREPLACEBITMAP, *LPTBREPLACEBITMAP;
#define TBIMHT_AFTER	1
#define TBIMHT_BACKGROUND	2
typedef struct {
	NMHDR hdr;
	WORD fwKeys;
	RECT rcParent;
	int iDir;
	int iXpos;
	int iYpos;
	int iScroll;
}NMPGSCROLL,*LPNMPGSCROLL;
typedef struct {
	NMHDR	hdr;
	DWORD	dwFlag;
	int	iWidth;
	int	iHeight;
}NMPGCALCSIZE, *LPNMPGCALCSIZE;
#define PBM_SETRANGE32	(WM_USER+6)
typedef struct {
	int iLow;
	int iHigh;
} PBRANGE, *PPBRANGE;
#define PBM_GETRANGE	(WM_USER+7)
#define PBM_GETPOS	(WM_USER+8)
#define PBM_SETBARCOLOR	(WM_USER+9)
#define PBM_SETBKCOLOR	CCM_SETBKCOLOR
typedef struct _UDACCEL {
	UINT nSec;
	UINT nInc;
} UDACCEL,*LPUDACCEL;
typedef struct tagTCITEMHEADERA {
	UINT mask;
	UINT lpReserved1;
	UINT lpReserved2;
	LPSTR pszText;
	int cchTextMax;
	int iImage;
} TCITEMHEADERA,*LPTCITEMHEADERA;
typedef struct tagTCITEMHEADERW {
	UINT mask;
	UINT lpReserved1;
	UINT lpReserved2;
	LPWSTR pszText;
	int cchTextMax;
	int iImage;
} TCITEMHEADERW,*LPTCITEMHEADERW;
typedef struct tagTCITEMA {
	UINT mask;
	DWORD dwState;
	DWORD dwStateMask;
	LPSTR pszText;
	int cchTextMax;
	int iImage;
	LPARAM lParam;
} TCITEMA,*LPTCITEMA;
typedef struct tagTCITEMW {
	UINT mask;
	DWORD dwState;
	DWORD dwStateMask;
	LPWSTR pszText;
	int cchTextMax;
	int iImage;
	LPARAM lParam;
} TCITEMW, *LPTCITEMW;
#ifdef UNICODE
#define TCITEMHEADER	TCITEMHEADERW
#define LPTCITEMHEADER	LPTCITEMHEADERW
#define TCITEMHEADER	TCITEMHEADERW
#define LPTCITEMHEADER	LPTCITEMHEADERW
#define TCITEM	TCITEMW
#define LPTCITEM	LPTCITEMW
#else
#define TCITEMHEADER	TCITEMHEADERA
#define LPTCITEMHEADER	LPTCITEMHEADERA
#define TCITEMHEADER	TCITEMHEADERA
#define LPTCITEMHEADER	LPTCITEMHEADERA
#define TCITEM	TCITEMA
#define LPTCITEM	LPTCITEMA
#endif
#ifndef FIELD_OFFSET
#define FIELD_OFFSET(type, field) ((LONG)(LONG *)&(((type *)0)->field))
#endif
typedef DWORD MONTHDAYSTATE,*LPMONTHDAYSTATE;
typedef HANDLE HRAWINPUT;
/* Structures associated with the executable image files. jn */

#define IMAGE_DOS_SIGNATURE 0x5A4D
#define IMAGE_OS2_SIGNATURE 0x454E
#define IMAGE_OS2_SIGNATURE_LE 0x454C
#define IMAGE_VXD_SIGNATURE 0x454C
#define IMAGE_NT_SIGNATURE 0x4550
#define IMAGE_SIZEOF_FILE_HEADER 20
#define IMAGE_FILE_RELOCS_STRIPPED 1
#define IMAGE_FILE_EXECUTABLE_IMAGE 2
#define IMAGE_FILE_LINE_NUMS_STRIPPED 4
#define IMAGE_FILE_LOCAL_SYMS_STRIPPED 8
#define IMAGE_FILE_BYTES_REVERSED_LO 128
#define IMAGE_FILE_32BIT_MACHINE 256
#define IMAGE_FILE_DEBUG_STRIPPED 512
#define IMAGE_FILE_SYSTEM 0x1000
#define IMAGE_FILE_DLL 0x2000
#define IMAGE_FILE_BYTES_REVERSED_HI 0x8000
#define IMAGE_FILE_MACHINE_UNKNOWN 0
#define IMAGE_FILE_MACHINE_I386 0x14c
#define IMAGE_FILE_MACHINE_R3000 0x162
#define IMAGE_FILE_MACHINE_R4000 0x166
#define IMAGE_FILE_MACHINE_R10000 0x168
#define IMAGE_FILE_MACHINE_ALPHA 0x184
#define IMAGE_FILE_MACHINE_POWERPC 0x1F0
#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16
#define IMAGE_SIZEOF_ROM_OPTIONAL_HEADER 56
#define IMAGE_SIZEOF_STD_OPTIONAL_HEADER 28
#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER 224
#define IMAGE_NT_OPTIONAL_HDR_MAGIC 0x10b
#define IMAGE_ROM_OPTIONAL_HDR_MAGIC 0x107
#define IMAGE_FIRST_SECTION(nth) ((PIMAGE_SECTION_HEADER) \
 ((DWORD)nth + FIELD_OFFSET( IMAGE_NT_HEADERS,OptionalHeader ) + \
 ((PIMAGE_NT_HEADERS)(nth))->FileHeader.SizeOfOptionalHeader))
#define IMAGE_SUBSYSTEM_UNKNOWN 0
#define IMAGE_SUBSYSTEM_NATIVE 1
#define IMAGE_SUBSYSTEM_WINDOWS_GUI 2
#define IMAGE_SUBSYSTEM_WINDOWS_CUI 3
#define IMAGE_SUBSYSTEM_OS2_CUI 5
#define IMAGE_SUBSYSTEM_POSIX_CUI 7
#define IMAGE_SUBSYSTEM_WINDOWS_CE_GUI 9
#define IMAGE_DIRECTORY_ENTRY_EXPORT 0
#define IMAGE_DIRECTORY_ENTRY_IMPORT 1
#define IMAGE_DIRECTORY_ENTRY_RESOURCE 2
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3
#define IMAGE_DIRECTORY_ENTRY_SECURITY 4
#define IMAGE_DIRECTORY_ENTRY_BASERELOC 5
#define IMAGE_DIRECTORY_ENTRY_DEBUG 6
#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT 7
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8
#define IMAGE_DIRECTORY_ENTRY_TLS 9
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11
#define IMAGE_DIRECTORY_ENTRY_IAT 12
#define IMAGE_SIZEOF_SHORT_NAME 8
#define IMAGE_SIZEOF_SECTION_HEADER 40
#define IMAGE_SCN_TYPE_NO_PAD 8
#define IMAGE_SCN_CNT_CODE 32
#define IMAGE_SCN_CNT_INITIALIZED_DATA 64
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA 128
#define IMAGE_SCN_LNK_OTHER 256
#define IMAGE_SCN_LNK_INFO 512
#define IMAGE_SCN_LNK_REMOVE 0x800
#define IMAGE_SCN_LNK_COMDAT 0x1000
#define IMAGE_SCN_MEM_FARDATA 0x8000
#define IMAGE_SCN_MEM_PURGEABLE 0x20000
#define IMAGE_SCN_MEM_16BIT 0x20000
#define IMAGE_SCN_MEM_LOCKED 0x40000
#define IMAGE_SCN_MEM_PRELOAD 0x80000
#define IMAGE_SCN_ALIGN_1BYTES 0x100000
#define IMAGE_SCN_ALIGN_2BYTES 0x200000
#define IMAGE_SCN_ALIGN_4BYTES 0x300000
#define IMAGE_SCN_ALIGN_8BYTES 0x400000
#define IMAGE_SCN_ALIGN_16BYTES 0x500000
#define IMAGE_SCN_ALIGN_32BYTES 0x600000
#define IMAGE_SCN_ALIGN_64BYTES 0x700000
#define IMAGE_SCN_LNK_NRELOC_OVFL 0x1000000
#define IMAGE_SCN_MEM_DISCARDABLE 0x2000000
#define IMAGE_SCN_MEM_NOT_CACHED 0x4000000
#define IMAGE_SCN_MEM_NOT_PAGED 0x8000000
#define IMAGE_SCN_MEM_SHARED 0x10000000
#define IMAGE_SCN_MEM_EXECUTE 0x20000000
#define IMAGE_SCN_MEM_READ 0x40000000
#define IMAGE_SCN_MEM_WRITE 0x80000000
#define IMAGE_SIZEOF_SYMBOL 18
#define IMAGE_SYM_UNDEFINED (SHORT)0
#define IMAGE_SYM_ABSOLUTE (SHORT)-1
#define IMAGE_SYM_DEBUG (SHORT)-2
#define IMAGE_SYM_TYPE_NULL 0
#define IMAGE_SYM_TYPE_VOID 1
#define IMAGE_SYM_TYPE_CHAR 2
#define IMAGE_SYM_TYPE_SHORT 3
#define IMAGE_SYM_TYPE_INT 4
#define IMAGE_SYM_TYPE_LONG 5
#define IMAGE_SYM_TYPE_FLOAT 6
#define IMAGE_SYM_TYPE_DOUBLE 7
#define IMAGE_SYM_TYPE_STRUCT 8
#define IMAGE_SYM_TYPE_UNION 9
#define IMAGE_SYM_TYPE_ENUM 10
#define IMAGE_SYM_TYPE_MOE 11
#define IMAGE_SYM_TYPE_BYTE 12
#define IMAGE_SYM_TYPE_WORD 13
#define IMAGE_SYM_TYPE_UINT 14
#define IMAGE_SYM_TYPE_DWORD 15
#define IMAGE_SYM_TYPE_PCODE 0x8000
#define IMAGE_SYM_DTYPE_NULL 0
#define IMAGE_SYM_DTYPE_POINTER 1
#define IMAGE_SYM_DTYPE_FUNCTION 2
#define IMAGE_SYM_DTYPE_ARRAY 3
#define IMAGE_SYM_CLASS_END_OF_FUNCTION (BYTE )-1
#define IMAGE_SYM_CLASS_NULL 0
#define IMAGE_SYM_CLASS_AUTOMATIC 1
#define IMAGE_SYM_CLASS_EXTERNAL 2
#define IMAGE_SYM_CLASS_STATIC 3
#define IMAGE_SYM_CLASS_REGISTER 4
#define IMAGE_SYM_CLASS_EXTERNAL_DEF 5
#define IMAGE_SYM_CLASS_LABEL 6
#define IMAGE_SYM_CLASS_UNDEFINED_LABEL 7
#define IMAGE_SYM_CLASS_MEMBER_OF_STRUCT 8
#define IMAGE_SYM_CLASS_ARGUMENT 9
#define IMAGE_SYM_CLASS_STRUCT_TAG 10
#define IMAGE_SYM_CLASS_MEMBER_OF_UNION 11
#define IMAGE_SYM_CLASS_UNION_TAG 12
#define IMAGE_SYM_CLASS_TYPE_DEFINITION 13
#define IMAGE_SYM_CLASS_UNDEFINED_STATIC 14
#define IMAGE_SYM_CLASS_ENUM_TAG 15
#define IMAGE_SYM_CLASS_MEMBER_OF_ENUM 16
#define IMAGE_SYM_CLASS_REGISTER_PARAM 17
#define IMAGE_SYM_CLASS_BIT_FIELD 18
#define IMAGE_SYM_CLASS_FAR_EXTERNAL 0x44
#define IMAGE_SYM_CLASS_BLOCK 0x64
#define IMAGE_SYM_CLASS_FUNCTION 0x65
#define IMAGE_SYM_CLASS_END_OF_STRUCT 0x66
#define IMAGE_SYM_CLASS_FILE 0x67
#define IMAGE_SYM_CLASS_SECTION 0x68
#define IMAGE_SYM_CLASS_WEAK_EXTERNAL 0x69
#define N_BTMASK 0xF
#define N_TMASK 0x30
#define N_TMASK1 0xC0
#define N_TMASK2 0xF0
#define N_BTSHFT 4
#define N_TSHIFT 2
#define BTYPE(x) ((x) & N_BTMASK)
#ifndef ISPTR
#define ISPTR(x) (((x)&N_TMASK)==(IMAGE_SYM_DTYPE_POINTER << N_BTSHFT))
#endif
#ifndef ISFCN
#define ISFCN(x) (((x)&N_TMASK)==(IMAGE_SYM_DTYPE_FUNCTION << N_BTSHFT))
#endif
#ifndef ISARY
#define ISARY(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_ARRAY << N_BTSHFT))
#endif
#ifndef ISTAG
#define ISTAG(x) ((x)==IMAGE_SYM_CLASS_STRUCT_TAG || (x)==IMAGE_SYM_CLASS_UNION_TAG || (x)==IMAGE_SYM_CLASS_ENUM_TAG)
#endif
#ifndef INCREF
#define INCREF(x) ((((x)&~N_BTMASK)<<N_TSHIFT)|(IMAGE_SYM_DTYPE_POINTER<<N_BTSHFT)|((x)&N_BTMASK))
#endif
#ifndef DECREF
#define DECREF(x) ((((x)>>N_TSHIFT)&~N_BTMASK)|((x)&N_BTMASK))
#endif
#define IMAGE_SIZEOF_SYMBOL	18
#define IMAGE_COMDAT_SELECT_NODUPLICATES	1
#define IMAGE_COMDAT_SELECT_ANY	2
#define IMAGE_COMDAT_SELECT_SAME_SIZE	3
#define IMAGE_COMDAT_SELECT_EXACT_MATCH	4
#define IMAGE_COMDAT_SELECT_ASSOCIATIVE	5
#define IMAGE_COMDAT_SELECT_LARGEST	6
#define IMAGE_COMDAT_SELECT_NEWEST	7
#define IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY	1
#define IMAGE_WEAK_EXTERN_SEARCH_LIBRARY	2
#define IMAGE_WEAK_EXTERN_SEARCH_ALIAS	3
#define IMAGE_SIZEOF_RELOCATION 10
#define IMAGE_REL_I386_ABSOLUTE	0
#define IMAGE_REL_I386_DIR16	1
#define IMAGE_REL_I386_REL16	2
#define IMAGE_REL_I386_DIR32	6
#define IMAGE_REL_I386_DIR32NB	7
#define IMAGE_REL_I386_SEG12 9
#define IMAGE_REL_I386_SECTION 10
#define IMAGE_REL_I386_SECREL 11
#define IMAGE_REL_I386_REL32 0x14
#define IMAGE_SIZEOF_BASE_RELOCATION 8
#define IMAGE_REL_BASED_ABSOLUTE 0
#define IMAGE_REL_BASED_HIGH 1
#define IMAGE_REL_BASED_LOW 2
#define IMAGE_REL_BASED_HIGHLOW 3
#define IMAGE_REL_BASED_HIGHADJ 4
#define IMAGE_REL_BASED_MIPS_JMPADDR 5
#define IMAGE_SIZEOF_LINENUMBER 6
#define IMAGE_ARCHIVE_START_SIZE 8
#define IMAGE_ARCHIVE_START "!<arch>\n"
#define IMAGE_ARCHIVE_END "`\n"
#define IMAGE_ARCHIVE_PAD "\n"
#define IMAGE_ARCHIVE_LINKER_MEMBER "/ "
#define IMAGE_ARCHIVE_LONGNAMES_MEMBER "// "
#define IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR 60
#define IMAGE_ORDINAL_FLAG 0x80000000
#define IMAGE_SNAP_BY_ORDINAL(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG) != 0)
#define IMAGE_ORDINAL(Ordinal) (Ordinal & 0xffff)
#define IMAGE_RESOURCE_NAME_IS_STRING 0x80000000
#define IMAGE_RESOURCE_DATA_IS_DIRECTORY 0x80000000
#define IMAGE_DEBUG_TYPE_UNKNOWN 0
#define IMAGE_DEBUG_TYPE_COFF 1
#define IMAGE_DEBUG_TYPE_CODEVIEW 2
#define IMAGE_DEBUG_TYPE_FPO 3
#define IMAGE_DEBUG_TYPE_MISC 4
#define IMAGE_DEBUG_TYPE_EXCEPTION 5
#define IMAGE_DEBUG_TYPE_FIXUP 6
#define IMAGE_DEBUG_TYPE_OMAP_TO_SRC 7
#define IMAGE_DEBUG_TYPE_OMAP_FROM_SRC 8
#define FRAME_FPO 0
#define FRAME_TRAP 1
#define FRAME_TSS 2
#define FRAME_NONFPO 3
#define SIZEOF_RFPO_DATA 16
#define IMAGE_DEBUG_MISC_EXENAME 1
#define IMAGE_SEPARATE_DEBUG_SIGNATURE 0x4944
#define CCHILDREN_TITLEBAR	5
#define CCHILDREN_SCROLLBAR	5
typedef struct _IMAGE_DOS_HEADER {
	WORD e_magic;
	WORD e_cblp;
	WORD e_cp;
	WORD e_crlc;
	WORD e_cparhdr;
	WORD e_minalloc;
	WORD e_maxalloc;
	WORD e_ss;
	WORD e_sp;
	WORD e_csum;
	WORD e_ip;
	WORD e_cs;
	WORD e_lfarlc;
	WORD e_ovno;
	WORD e_res[4];
	WORD e_oemid;
	WORD e_oeminfo;
	WORD e_res2[10];
	LONG e_lfanew;
} IMAGE_DOS_HEADER,*PIMAGE_DOS_HEADER;
typedef struct _IMAGE_OS2_HEADER {
	WORD ne_magic;
	CHAR ne_ver;
	CHAR ne_rev;
	WORD ne_enttab;
	WORD ne_cbenttab;
	LONG ne_crc;
	WORD ne_flags;
	WORD ne_autodata;
	WORD ne_heap;
	WORD ne_stack;
	LONG ne_csip;
	LONG ne_sssp;
	WORD ne_cseg;
	WORD ne_cmod;
	WORD ne_cbnrestab;
	WORD ne_segtab;
	WORD ne_rsrctab;
	WORD ne_restab;
	WORD ne_modtab;
	WORD ne_imptab;
	LONG ne_nrestab;
	WORD ne_cmovent;
	WORD ne_align;
	WORD ne_cres;
	BYTE ne_exetyp;
	BYTE ne_flagsothers;
	WORD ne_pretthunks;
	WORD ne_psegrefbytes;
	WORD ne_swaparea;
	WORD ne_expver;
} IMAGE_OS2_HEADER,*PIMAGE_OS2_HEADER;
typedef struct _IMAGE_VXD_HEADER {
	WORD e32_magic;
	BYTE e32_border;
	BYTE e32_worder;
	DWORD e32_level;
	WORD e32_cpu;
	WORD e32_os;
	DWORD e32_ver;
	DWORD e32_mflags;
	DWORD e32_mpages;
	DWORD e32_startobj;
	DWORD e32_eip;
	DWORD e32_stackobj;
	DWORD e32_esp;
	DWORD e32_pagesize;
	DWORD e32_lastpagesize;
	DWORD e32_fixupsize;
	DWORD e32_fixupsum;
	DWORD e32_ldrsize;
	DWORD e32_ldrsum;
	DWORD e32_objtab;
	DWORD e32_objcnt;
	DWORD e32_objmap;
	DWORD e32_itermap;
	DWORD e32_rsrctab;
	DWORD e32_rsrccnt;
	DWORD e32_restab;
	DWORD e32_enttab;
	DWORD e32_dirtab;
	DWORD e32_dircnt;
	DWORD e32_fpagetab;
	DWORD e32_frectab;
	DWORD e32_impmod;
	DWORD e32_impmodcnt;
	DWORD e32_impproc;
	DWORD e32_pagesum;
	DWORD e32_datapage;
	DWORD e32_preload;
	DWORD e32_nrestab;
	DWORD e32_cbnrestab;
	DWORD e32_nressum;
	DWORD e32_autodata;
	DWORD e32_debuginfo;
	DWORD e32_debuglen;
	DWORD e32_instpreload;
	DWORD e32_instdemand;
	DWORD e32_heapsize;
	BYTE e32_res3[12];
	DWORD e32_winresoff;
	DWORD e32_winreslen;
	WORD e32_devid;
	WORD e32_ddkver;
} IMAGE_VXD_HEADER,*PIMAGE_VXD_HEADER;
typedef struct _IMAGE_FILE_HEADER {
	WORD Machine;
	WORD NumberOfSections;
	DWORD TimeDateStamp;
	DWORD PointerToSymbolTable;
	DWORD NumberOfSymbols;
	WORD SizeOfOptionalHeader;
	WORD Characteristics;
} IMAGE_FILE_HEADER,*PIMAGE_FILE_HEADER;
typedef struct _IMAGE_DATA_DIRECTORY {
	DWORD VirtualAddress;
	DWORD Size;
} IMAGE_DATA_DIRECTORY,*PIMAGE_DATA_DIRECTORY;
typedef struct _IMAGE_OPTIONAL_HEADERXXX {
	WORD Magic;
	BYTE MajorLinkerVersion;
	BYTE MinorLinkerVersion;
	DWORD SizeOfCode;
	DWORD SizeOfInitializedData;
	DWORD SizeOfUninitializedData;
	DWORD AddressOfEntryPoint;
	DWORD BaseOfCode;
	DWORD BaseOfData;
	DWORD ImageBase;
	DWORD SectionAlignment;
	DWORD FileAlignment;
	WORD MajorOperatingSystemVersion;
	WORD MinorOperatingSystemVersion;
	WORD MajorImageVersion;
	WORD MinorImageVersion;
	WORD MajorSubsystemVersion;
	WORD MinorSubsystemVersion;
	DWORD Win32VersionValue;
	DWORD SizeOfImage;
	DWORD SizeOfHeaders;
	DWORD CheckSum;
	WORD Subsystem;
	WORD DllCharacteristics;
	DWORD SizeOfStackReserve;
	DWORD SizeOfStackCommit;
	DWORD SizeOfHeapReserve;
	DWORD SizeOfHeapCommit;
	DWORD LoaderFlags;
	DWORD NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER,*PIMAGE_OPTIONAL_HEADER;
typedef struct _IMAGE_OPTIONAL_HEADER64 {
	WORD	Magic;
	BYTE	MajorLinkerVersion;
	BYTE	MinorLinkerVersion;
	DWORD	SizeOfCode;
	DWORD	SizeOfInitializedData;
	DWORD	SizeOfUninitializedData;
	DWORD	AddressOfEntryPoint;
	DWORD	BaseOfCode;
	ULONGLONG	ImageBase;
	DWORD	SectionAlignment;
	DWORD	FileAlignment;
	WORD	MajorOperatingSystemVersion;
	WORD	MinorOperatingSystemVersion;
	WORD	MajorImageVersion;
	WORD	MinorImageVersion;
	WORD	MajorSubsystemVersion;
	WORD	MinorSubsystemVersion;
	DWORD	Win32VersionValue;
	DWORD	SizeOfImage;
	DWORD	SizeOfHeaders;
	DWORD	CheckSum;
	WORD	Subsystem;
	WORD	DllCharacteristics;
	ULONGLONG SizeOfStackReserve;
	ULONGLONG SizeOfStackCommit;
	ULONGLONG SizeOfHeapReserve;
	ULONGLONG SizeOfHeapCommit;
	DWORD	LoaderFlags;
	DWORD	NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;


#define IMAGE_SIZEOF_NT_OPTIONAL64_HEADER	240


typedef struct _IMAGE_OPTIONAL_HEADER {
    //
    // Standard fields.
    //

    WORD    Magic;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;
    DWORD   BaseOfCode;
    DWORD   BaseOfData;

    //
    // NT additional fields.
    //

    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;



typedef struct _IMAGE_NT_HEADERS64 {
	DWORD Signature;
	IMAGE_FILE_HEADER FileHeader;
	IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
	WORD Magic;
	BYTE MajorLinkerVersion;
	BYTE MinorLinkerVersion;
	DWORD SizeOfCode;
	DWORD SizeOfInitializedData;
	DWORD SizeOfUninitializedData;
	DWORD AddressOfEntryPoint;
	DWORD BaseOfCode;
	DWORD BaseOfData;
	DWORD BaseOfBss;
	DWORD GprMask;
	DWORD CprMask[4];
	DWORD GpValue;
} IMAGE_ROM_OPTIONAL_HEADER,*PIMAGE_ROM_OPTIONAL_HEADER;
#define IMAGE_SIZEOF_ROM_OPTIONAL_HEADER 56
#define IMAGE_SIZEOF_STD_OPTIONAL_HEADER 28
#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER 224
#define IMAGE_NT_OPTIONAL_HDR_MAGIC 0x10b
#define IMAGE_ROM_OPTIONAL_HDR_MAGIC 0x107
typedef struct _IMAGE_NT_HEADERS {
	DWORD Signature;
	IMAGE_FILE_HEADER FileHeader;
	IMAGE_OPTIONAL_HEADER OptionalHeader;
} IMAGE_NT_HEADERS,*PIMAGE_NT_HEADERS;
typedef IMAGE_NT_HEADERS IMAGE_NT_HEADERS32;
typedef IMAGE_NT_HEADERS32 *PIMAGE_NT_HEADERS32;
#define LPIMAGE_NT_HEADERS PIMAGE_NT_HEADERS;
typedef struct _IMAGE_ROM_HEADERS {
	IMAGE_FILE_HEADER FileHeader;
	IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
} IMAGE_ROM_HEADERS,*PIMAGE_ROM_HEADERS;
typedef struct _IMAGE_SECTION_HEADER {
	BYTE Name[IMAGE_SIZEOF_SHORT_NAME];
	union {
		DWORD PhysicalAddress;
		DWORD VirtualSize;
	} Misc;
	DWORD VirtualAddress;
	DWORD SizeOfRawData;
	DWORD PointerToRawData;
	DWORD PointerToRelocations;
	DWORD PointerToLinenumbers;
	WORD NumberOfRelocations;
	WORD NumberOfLinenumbers;
	DWORD Characteristics;
} IMAGE_SECTION_HEADER,*PIMAGE_SECTION_HEADER;
typedef struct _IMAGE_SYMBOL {
	union {
		BYTE ShortName[8];
		struct {
			DWORD Short;
			DWORD Long;
		} Name;
		PBYTE LongName[2];
	} N;
	DWORD Value;
	SHORT SectionNumber;
	WORD Type;
	BYTE StorageClass;
	BYTE NumberOfAuxSymbols;
} IMAGE_SYMBOL;
typedef IMAGE_SYMBOL *PIMAGE_SYMBOL;
typedef union _IMAGE_AUX_SYMBOL {
	struct {
		DWORD TagIndex;
		union {
			struct { WORD Linenumber; WORD Size; } LnSz;
			DWORD TotalSize;
		} Misc;
		union {
			struct {
				DWORD PointerToLinenumber;
				DWORD PointerToNextFunction;
			} Function;
			struct {
				WORD Dimension[4];
			} Array;
		} FcnAry;
		WORD TvIndex;
	} Sym;
	struct {
		BYTE Name[IMAGE_SIZEOF_SYMBOL];
	} File;
	struct {
		DWORD Length;
		WORD NumberOfRelocations;
		WORD NumberOfLinenumbers;
		DWORD CheckSum;
		SHORT Number;
		BYTE Selection;
	} Section;
} IMAGE_AUX_SYMBOL;
typedef IMAGE_AUX_SYMBOL *PIMAGE_AUX_SYMBOL;
typedef struct _IMAGE_RELOCATION {
#ifdef __LCC__ /* I do not support unnamed unions... jn */
	DWORD VirtualAddress;
#else
	union {
		DWORD VirtualAddress;
		DWORD RelocCount;
	};
#endif
	DWORD SymbolTableIndex;
	WORD Type;
} IMAGE_RELOCATION;
typedef IMAGE_RELOCATION *PIMAGE_RELOCATION;
typedef struct _IMAGE_BASE_RELOCATION {
	DWORD VirtualAddress;
	DWORD SizeOfBlock;
} IMAGE_BASE_RELOCATION,*PIMAGE_BASE_RELOCATION;
typedef struct _IMAGE_LINENUMBER {
	union {
		DWORD SymbolTableIndex;
		DWORD VirtualAddress;
	} Type;
	WORD Linenumber;
} IMAGE_LINENUMBER;
typedef IMAGE_LINENUMBER *PIMAGE_LINENUMBER;
typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
	BYTE Name[16];
	BYTE Date[12];
	BYTE UserID[6];
	BYTE GroupID[6];
	BYTE Mode[8];
	BYTE Size[10];
	BYTE EndHeader[2];
} IMAGE_ARCHIVE_MEMBER_HEADER,*PIMAGE_ARCHIVE_MEMBER_HEADER;
typedef struct _IMAGE_EXPORT_DIRECTORY {
	DWORD Characteristics;
	DWORD TimeDateStamp;
	WORD MajorVersion;
	WORD MinorVersion;
	DWORD Name;
	DWORD Base;
	DWORD NumberOfFunctions;
	DWORD NumberOfNames;
	DWORD AddressOfFunctions;
	DWORD AddressOfNames;
	DWORD AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY;

typedef struct _IMAGE_IMPORT_BY_NAME {
	WORD Hint;
	BYTE Name[1];
} IMAGE_IMPORT_BY_NAME,*PIMAGE_IMPORT_BY_NAME;
typedef struct _IMAGE_THUNK_DATA {
	union {
		PBYTE ForwarderString;
		PDWORD Function;
		DWORD Ordinal;
		PIMAGE_IMPORT_BY_NAME AddressOfData;
	} ;
} IMAGE_THUNK_DATA,*PIMAGE_THUNK_DATA;
typedef struct _IMAGE_THUNK_DATA64 {
	union {
		ULONGLONG ForwarderString;
		ULONGLONG Function;
		ULONGLONG Ordinal;
		ULONGLONG AddressOfData;
	};
} IMAGE_THUNK_DATA64;
typedef IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;
typedef struct _IMAGE_IMPORT_DESCRIPTOR {
	union {
		DWORD Characteristics;
		DWORD OriginalFirstThunk;
	} ;
	DWORD TimeDateStamp;
	DWORD ForwarderChain;
	DWORD Name;
	DWORD FirstThunk;
} IMAGE_IMPORT_DESCRIPTOR,*PIMAGE_IMPORT_DESCRIPTOR;
typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {
	DWORD TimeDateStamp;
	WORD OffsetModuleName;
	WORD NumberOfModuleForwarderRefs;
} IMAGE_BOUND_IMPORT_DESCRIPTOR,*PIMAGE_BOUND_IMPORT_DESCRIPTOR;
typedef struct _IMAGE_BOUND_FORWARDER_REF {
	DWORD TimeDateStamp;
	WORD OffsetModuleName;
	WORD Reserved;
} IMAGE_BOUND_FORWARDER_REF,*PIMAGE_BOUND_FORWARDER_REF;
typedef VOID ( *PIMAGE_TLS_CALLBACK)(PVOID,DWORD,PVOID);
typedef struct _IMAGE_TLS_DIRECTORY {
	DWORD StartAddressOfRawData;
	DWORD EndAddressOfRawData;
	PDWORD AddressOfIndex;
	PIMAGE_TLS_CALLBACK *AddressOfCallBacks;
	DWORD SizeOfZeroFill;
	DWORD Characteristics;
} IMAGE_TLS_DIRECTORY,*PIMAGE_TLS_DIRECTORY;
typedef struct _IMAGE_RESOURCE_DIRECTORY {
	DWORD Characteristics;
	DWORD TimeDateStamp;
	WORD MajorVersion;
	WORD MinorVersion;
	WORD NumberOfNamedEntries;
	WORD NumberOfIdEntries;
} IMAGE_RESOURCE_DIRECTORY,*PIMAGE_RESOURCE_DIRECTORY;
typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
	union {
		struct { unsigned NameOffset:31; unsigned NameIsString:1; };
		DWORD Name;
		WORD Id;
	} ;
	union {
		DWORD OffsetToData;
		struct { unsigned OffsetToDirectory:31; unsigned DataIsDirectory:1; };
	} ;
} IMAGE_RESOURCE_DIRECTORY_ENTRY,*PIMAGE_RESOURCE_DIRECTORY_ENTRY;
typedef struct _IMAGE_RESOURCE_DIRECTORY_STRING {
	WORD Length;
	CHAR NameString[1];
} IMAGE_RESOURCE_DIRECTORY_STRING,*PIMAGE_RESOURCE_DIRECTORY_STRING;
typedef struct _IMAGE_RESOURCE_DIR_STRING_U {
	WORD Length;
	WCHAR NameString[1];
} IMAGE_RESOURCE_DIR_STRING_U,*PIMAGE_RESOURCE_DIR_STRING_U;
typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
	DWORD OffsetToData;
	DWORD Size;
	DWORD CodePage;
	DWORD Reserved;
} IMAGE_RESOURCE_DATA_ENTRY,*PIMAGE_RESOURCE_DATA_ENTRY;
typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY {
	DWORD Characteristics;
	DWORD TimeDateStamp;
	WORD MajorVersion;
	WORD MinorVersion;
	DWORD GlobalFlagsClear;
	DWORD GlobalFlagsSet;
	DWORD CriticalSectionDefaultTimeout;
	DWORD DeCommitFreeBlockThreshold;
	DWORD DeCommitTotalFreeThreshold;
	PVOID LockPrefixTable;
	DWORD MaximumAllocationSize;
	DWORD VirtualMemoryThreshold;
	DWORD ProcessHeapFlags;
	DWORD Reserved[4];
} IMAGE_LOAD_CONFIG_DIRECTORY,*PIMAGE_LOAD_CONFIG_DIRECTORY;
typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
	DWORD BeginAddress;
	DWORD EndAddress;
	PVOID ExceptionHandler;
	PVOID HandlerData;
	DWORD PrologEndAddress;
} IMAGE_RUNTIME_FUNCTION_ENTRY,*PIMAGE_RUNTIME_FUNCTION_ENTRY;
typedef struct _IMAGE_DEBUG_DIRECTORY {
	DWORD Characteristics;
	DWORD TimeDateStamp;
	WORD MajorVersion;
	WORD MinorVersion;
	DWORD Type;
	DWORD SizeOfData;
	DWORD AddressOfRawData;
	DWORD PointerToRawData;
} IMAGE_DEBUG_DIRECTORY,*PIMAGE_DEBUG_DIRECTORY;
typedef struct _IMAGE_COFF_SYMBOLS_HEADER {
	DWORD NumberOfSymbols;
	DWORD LvaToFirstSymbol;
	DWORD NumberOfLinenumbers;
	DWORD LvaToFirstLinenumber;
	DWORD RvaToFirstByteOfCode;
	DWORD RvaToLastByteOfCode;
	DWORD RvaToFirstByteOfData;
	DWORD RvaToLastByteOfData;
} IMAGE_COFF_SYMBOLS_HEADER,*PIMAGE_COFF_SYMBOLS_HEADER;
#define FRAME_FPO 0
#define FRAME_TRAP 1
#define FRAME_TSS 2
#define FRAME_NONFPO 3
typedef struct _FPO_DATA {
	DWORD ulOffStart;
	DWORD cbProcSize;
	DWORD cdwLocals;
	WORD cdwParams;
	unsigned cbProlog:8;
	unsigned cbRegs:3;
	unsigned fHasSEH:1;
	unsigned fUseBP:1;
	unsigned reserved:1;
	unsigned cbFrame:2;
} FPO_DATA,*PFPO_DATA;
#define SIZEOF_RFPO_DATA 16
typedef struct _IMAGE_DEBUG_MISC {
	DWORD DataType;
	DWORD Length;
	BOOLEAN Unicode;
	BYTE Reserved[3];
	BYTE Data[1];
} IMAGE_DEBUG_MISC,*PIMAGE_DEBUG_MISC;
typedef struct _IMAGE_FUNCTION_ENTRY {
	DWORD StartingAddress;
	DWORD EndingAddress;
	DWORD EndOfPrologue;
} IMAGE_FUNCTION_ENTRY,*PIMAGE_FUNCTION_ENTRY;
typedef struct _IMAGE_SEPARATE_DEBUG_HEADER {
	WORD Signature;
	WORD Flags;
	WORD Machine;
	WORD Characteristics;
	DWORD TimeDateStamp;
	DWORD CheckSum;
	DWORD ImageBase;
	DWORD SizeOfImage;
	DWORD NumberOfSections;
	DWORD ExportedNamesSize;
	DWORD DebugDirectorySize;
	DWORD SectionAlignment;
	DWORD Reserved[2];
} IMAGE_SEPARATE_DEBUG_HEADER,*PIMAGE_SEPARATE_DEBUG_HEADER;
typedef int (CALLBACK *ENUMMETAFILEPROC)(HDC,HANDLETABLE *,METARECORD *,int,LPARAM);
typedef int (CALLBACK *ENHMETAFILEPROC) (HDC,HANDLETABLE,ENHMETARECORD,int,LPARAM);
typedef int (CALLBACK *ENUMFONTSPROC) (LPLOGFONT,LPTEXTMETRIC,DWORD,LPARAM);
typedef int (CALLBACK *FONTENUMPROC)(ENUMLOGFONT *,NEWTEXTMETRIC *,int,LPARAM);
typedef int (CALLBACK *FONTENUMEXPROC)(ENUMLOGFONTEX *,NEWTEXTMETRICEX *,int,LPARAM);
typedef VOID(CALLBACK *LPOVERLAPPED_COMPLETION_ROUTINE)(DWORD,DWORD,LPOVERLAPPED);
typedef int (CALLBACK* ENHMFENUMPROC)(HDC,HANDLETABLE *,ENHMETARECORD *,int,LPARAM);
typedef int (CALLBACK* MFENUMPROC)(HDC,HANDLETABLE *,METARECORD *,int,LPARAM);
typedef struct _NT_TIB {
	struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;
	PVOID StackBase;
	PVOID StackLimit;
	PVOID SubSystemTib;
	union { PVOID FiberData; DWORD Version; };
	PVOID ArbitraryUserPointer;
	struct _NT_TIB *Self;
} NT_TIB;
typedef NT_TIB *PNT_TIB;
#define THREAD_BASE_PRIORITY_LOWRT	15
#define THREAD_BASE_PRIORITY_MAX	2
#define THREAD_BASE_PRIORITY_MIN	-2
#define THREAD_BASE_PRIORITY_IDLE	-15
#pragma pack(push,8)
typedef struct _QUOTA_LIMITS {
	SIZE_T PagedPoolLimit;
	SIZE_T NonPagedPoolLimit;
	SIZE_T MinimumWorkingSetSize;
	SIZE_T MaximumWorkingSetSize;
	SIZE_T PagefileLimit;
	LARGE_INTEGER TimeLimit;
} QUOTA_LIMITS, *PQUOTA_LIMITS;
#pragma pack(pop)
#define QUOTA_LIMITS_HARDWS_MIN_ENABLE	1
#define QUOTA_LIMITS_HARDWS_MIN_DISABLE 2
#define QUOTA_LIMITS_HARDWS_MAX_ENABLE	4
#define QUOTA_LIMITS_HARDWS_MAX_DISABLE 8
typedef struct _QUOTA_LIMITS_EX {
	SIZE_T PagedPoolLimit;
	SIZE_T NonPagedPoolLimit;
	SIZE_T MinimumWorkingSetSize;
	SIZE_T MaximumWorkingSetSize;
	SIZE_T PagefileLimit;
	LARGE_INTEGER TimeLimit;
	SIZE_T Reserved1;
	SIZE_T Reserved2;
	SIZE_T Reserved3;
	SIZE_T Reserved4;
	DWORD Flags;
	DWORD Reserved5;
} QUOTA_LIMITS_EX, *PQUOTA_LIMITS_EX;
typedef struct _IO_COUNTERS {
	ULONGLONG ReadOperationCount;
	ULONGLONG WriteOperationCount;
	ULONGLONG OtherOperationCount;
	ULONGLONG ReadTransferCount;
	ULONGLONG WriteTransferCount;
	ULONGLONG OtherTransferCount;
} IO_COUNTERS;
typedef IO_COUNTERS *PIO_COUNTERS;
typedef struct _JOBOBJECT_BASIC_LIMIT_INFORMATION {
	LARGE_INTEGER PerProcessUserTimeLimit;
	LARGE_INTEGER PerJobUserTimeLimit;
	DWORD LimitFlags;
	SIZE_T MinimumWorkingSetSize;
	SIZE_T MaximumWorkingSetSize;
	DWORD ActiveProcessLimit;
	ULONG_PTR Affinity;
	DWORD PriorityClass;
	DWORD SchedulingClass;
} JOBOBJECT_BASIC_LIMIT_INFORMATION, *PJOBOBJECT_BASIC_LIMIT_INFORMATION;
typedef struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
	JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
	DWORD align;
	IO_COUNTERS IoInfo;
	SIZE_T ProcessMemoryLimit;
	SIZE_T JobMemoryLimit;
	SIZE_T PeakProcessMemoryUsed;
	SIZE_T PeakJobMemoryUsed;
} JOBOBJECT_EXTENDED_LIMIT_INFORMATION, *PJOBOBJECT_EXTENDED_LIMIT_INFORMATION;
typedef struct _JOBOBJECT_BASIC_PROCESS_ID_LIST {
	DWORD NumberOfAssignedProcesses;
	DWORD NumberOfProcessIdsInList;
	ULONG_PTR ProcessIdList[1];
} JOBOBJECT_BASIC_PROCESS_ID_LIST, *PJOBOBJECT_BASIC_PROCESS_ID_LIST;
typedef struct _JOBOBJECT_BASIC_UI_RESTRICTIONS {
	DWORD UIRestrictionsClass;
} JOBOBJECT_BASIC_UI_RESTRICTIONS, *PJOBOBJECT_BASIC_UI_RESTRICTIONS;
typedef struct _JOBOBJECT_SECURITY_LIMIT_INFORMATION {
	DWORD SecurityLimitFlags ;
	HANDLE JobToken ;
	PTOKEN_GROUPS SidsToDisable ;
	PTOKEN_PRIVILEGES PrivilegesToDelete ;
	PTOKEN_GROUPS RestrictedSids ;
} JOBOBJECT_SECURITY_LIMIT_INFORMATION, *PJOBOBJECT_SECURITY_LIMIT_INFORMATION ;
typedef struct _JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
	DWORD EndOfJobTimeAction;
} JOBOBJECT_END_OF_JOB_TIME_INFORMATION, *PJOBOBJECT_END_OF_JOB_TIME_INFORMATION;
typedef struct _JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
	PVOID CompletionKey;
	HANDLE CompletionPort;
} JOBOBJECT_ASSOCIATE_COMPLETION_PORT, *PJOBOBJECT_ASSOCIATE_COMPLETION_PORT;
typedef struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
	LARGE_INTEGER TotalUserTime;
	LARGE_INTEGER TotalKernelTime;
	LARGE_INTEGER ThisPeriodTotalUserTime;
	LARGE_INTEGER ThisPeriodTotalKernelTime;
	DWORD TotalPageFaultCount;
	DWORD TotalProcesses;
	DWORD ActiveProcesses;
	DWORD TotalTerminatedProcesses;
} JOBOBJECT_BASIC_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION;
typedef struct _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
	JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
	IO_COUNTERS IoInfo;
} JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;
typedef struct _JOBOBJECT_JOBSET_INFORMATION {
	DWORD MemberLevel;
} JOBOBJECT_JOBSET_INFORMATION, *PJOBOBJECT_JOBSET_INFORMATION;
#define JOB_OBJECT_TERMINATE_AT_END_OF_JOB 0
#define JOB_OBJECT_POST_AT_END_OF_JOB	1
typedef struct tagPIXELFORMATDESCRIPTOR {
	WORD	nSize;
	WORD	nVersion;
	DWORD	dwFlags;
	BYTE	iPixelType;
	BYTE	cColorBits;
	BYTE	cRedBits;
	BYTE	cRedShift;
	BYTE	cGreenBits;
	BYTE	cGreenShift;
	BYTE	cBlueBits;
	BYTE	cBlueShift;
	BYTE	cAlphaBits;
	BYTE	cAlphaShift;
	BYTE	cAccumBits;
	BYTE	cAccumRedBits;
	BYTE	cAccumGreenBits;
	BYTE	cAccumBlueBits;
	BYTE	cAccumAlphaBits;
	BYTE	cDepthBits;
	BYTE	cStencilBits;
	BYTE	cAuxBuffers;
	BYTE	iLayerType;
	BYTE	bReserved;
	DWORD	dwLayerMask;
	DWORD	dwVisibleMask;
	DWORD	dwDamageMask;
} PIXELFORMATDESCRIPTOR,*PPIXELFORMATDESCRIPTOR,*LPPIXELFORMATDESCRIPTOR;
typedef struct _WIN_CERTIFICATE {
	DWORD	dwLength;
	WORD	wRevision;
	WORD	wCertificateType;
	BYTE	bCertificate[1];
} WIN_CERTIFICATE,*LPWIN_CERTIFICATE;
#define WIN_CERT_REVISION_1_0	0x100
#define WIN_CERT_TYPE_X509 1
#define WIN_CERT_TYPE_PKCS_SIGNED_DATA	2
#define WIN_CERT_TYPE_RESERVED_1	3
typedef LPVOID WIN_TRUST_SUBJECT;
typedef struct _WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT {
	HANDLE	hClientToken;
	GUID	*SubjectType;
	WIN_TRUST_SUBJECT Subject;
} WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT,*LPWIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT;
typedef struct _WIN_TRUST_ACTDATA_SUBJECT_ONLY {
	GUID	*SubjectType;
	WIN_TRUST_SUBJECT Subject;
} WIN_TRUST_ACTDATA_SUBJECT_ONLY,*LPWIN_TRUST_ACTDATA_SUBJECT_ONLY;
#define WIN_TRUST_SUBJTYPE_RAW_FILE {0x959dc450,0x8d9e,0x11cf,{0x87,0x36,0,0xaa,0,0xa4,0x85,0xeb}}
#define WIN_TRUST_SUBJTYPE_PE_IMAGE {0x43c9a1e0,0x8da0,0x11cf,{0x87,0x36,0,0xaa,0,0xa4,0x85,0xeb}}
#define WIN_TRUST_SUBJTYPE_OLE_STORAGE {0xc257e740,0x8da0,0x11cf,{0x87,0x36,0,0xaa,0,0xa4,0x85,0xeb}}
#define WIN_TRUST_SUBJTYPE_JAVA_CLASS {0x08ad3990,0x8da1,0x11cf,{0x87,0x36,0,0xaa,0,0xa4,0x85,0xeb}}
typedef struct _WIN_TRUST_SUBJECT_FILE {
	HANDLE hFile; LPCWSTR lpPath;
} WIN_TRUST_SUBJECT_FILE,*LPWIN_TRUST_SUBJECT_FILE;
/* TrustedPublisher == 66426730-8da1-11cf-8736-00aa00a485eb */
#define WIN_SPUB_ACTION_TRUSTED_PUBLISHER {0x66426730,0x8da1,0x11cf,{0x87,0x36,0,0xaa,0,0xa4,0x85,0xeb}}
#define WIN_SPUB_ACTION_NT_ACTIVATE_IMAGE {0x8bc96b00,0x8da1,0x11cf,{0x87,0x36,0,0xaa,0,0xa4,0x85,0xeb}}
#define WIN_SPUB_ACTION_PUBLISHED_SOFTWARE {0x64b9d180,0x8da2,0x11cf,{0x87,0x36,0,0xaa,0,0xa4,0x85,0xeb}}
typedef struct _WIN_SPUB_TRUSTED_PUBLISHER_DATA { HANDLE hClientToken;
	LPWIN_CERTIFICATE	lpCertificate;
} WIN_SPUB_TRUSTED_PUBLISHER_DATA,*LPWIN_SPUB_TRUSTED_PUBLISHER_DATA;
typedef VOID (WINAPI *PFIBER_START_ROUTINE)(LPVOID);
typedef PFIBER_START_ROUTINE LPFIBER_START_ROUTINE;
typedef struct tagNMDATETIMECHANGE {
 NMHDR nmhdr;
 DWORD dwFlags;
 SYSTEMTIME st;
} NMDATETIMECHANGE,*LPNMDATETIMECHANGE;
typedef struct tagNMDATETIMESTRINGA {
 NMHDR nmhdr;
 LPCSTR pszUserString;
 SYSTEMTIME st;
 DWORD dwFlags;
} NMDATETIMESTRINGA,FAR * LPNMDATETIMESTRINGA;
typedef struct tagNMDATETIMESTRINGW {
 NMHDR nmhdr;
 LPCWSTR pszUserString;
 SYSTEMTIME st;
 DWORD dwFlags;
} NMDATETIMESTRINGW,* LPNMDATETIMESTRINGW;
typedef struct tagNMDATETIMEWMKEYDOWNA {
	NMHDR	nmhdr;
	int	nVirtKey;
	LPCSTR	pszFormat;
	SYSTEMTIME	st;
} NMDATETIMEWMKEYDOWNA,* LPNMDATETIMEWMKEYDOWNA;
typedef struct tagNMDATETIMEWMKEYDOWNW {
	NMHDR	nmhdr;
	int	nVirtKey;
	LPCWSTR	pszFormat;
	SYSTEMTIME	st;
} NMDATETIMEWMKEYDOWNW,* LPNMDATETIMEWMKEYDOWNW;
typedef struct tagNMDATETIMEFORMATA {
	NMHDR	nmhdr;
	LPCSTR	pszFormat;
	SYSTEMTIME st;
	LPCSTR pszDisplay;
	CHAR szDisplay[64];
} NMDATETIMEFORMATA,* LPNMDATETIMEFORMATA;
typedef struct tagNMDATETIMEFORMATW {
	NMHDR nmhdr;
	LPCWSTR pszFormat;
	SYSTEMTIME st;
	LPCWSTR pszDisplay;
	WCHAR szDisplay[64];
} NMDATETIMEFORMATW,* LPNMDATETIMEFORMATW;
typedef struct tagNMDATETIMEFORMATQUERYA {
	NMHDR nmhdr;
	LPCSTR pszFormat;
	SIZE szMax;
} NMDATETIMEFORMATQUERYA,* LPNMDATETIMEFORMATQUERYA;
typedef struct tagNMDATETIMEFORMATQUERYW {
	NMHDR nmhdr;
	LPCWSTR pszFormat;
	SIZE szMax;
} NMDATETIMEFORMATQUERYW,* LPNMDATETIMEFORMATQUERYW;
typedef struct _COAUTHIDENTITY {
	USHORT *User;
	ULONG UserLength;
	USHORT *Domain;
	ULONG DomainLength;
	USHORT *Password;
	ULONG PasswordLength;
	ULONG Flags;
} COAUTHIDENTITY;
typedef struct _COAUTHINFO {
	DWORD dwAuthnSvc;
	DWORD dwAuthzSvc;
	LPWSTR pwszServerPrincName;
	DWORD dwAuthnLevel;
	DWORD dwImpersonationLevel;
	COAUTHIDENTITY *pAuthIdentityData;
	DWORD dwCapabilities;
} COAUTHINFO;
typedef WCHAR OLECHAR;
typedef struct _userCLIPFORMAT {
	long fContext;
	union __MIDL_IWinTypes_0001 {
		DWORD dwValue;
		short *pwszName;
	} u;
} userCLIPFORMAT;
typedef struct _userBITMAP {
	LONG bmType;
	LONG bmWidth;
	LONG bmHeight;
	LONG bmWidthBytes;
	WORD bmPlanes;
	WORD bmBitsPixel;
	ULONG cbSize;
	UCHAR pBuffer[1];
} userBITMAP;
typedef struct _userHBITMAP {
	long fContext;
	union __MIDL_IWinTypes_0007 {
		long hInproc;
		userBITMAP *hRemote;
		long hGlobal;
	} u;
} userHBITMAP;
typedef struct tagrpcLOGPALETTE {
	WORD palVersion;
	WORD palNumEntries;
	PALETTEENTRY palPalEntry[1];
} rpcLOGPALETTE;
typedef struct _FLAGGED_BYTE_BLOB {
	unsigned long fFlags;
	unsigned long clSize;
	BYTE abData[1];
} FLAGGED_BYTE_BLOB;
typedef struct _BYTE_BLOB {
	unsigned long clSize;
	BYTE abData[1];
} BYTE_BLOB;
typedef struct _userHMETAFILE {
	long fContext;
	union __MIDL_IWinTypes_0004 {
		long hInproc;
		BYTE_BLOB *hRemote;
		long hGlobal;
	} u;
} userHMETAFILE;
typedef struct _remoteMETAFILEPICT {
	long mm;
	long xExt;
	long yExt;
	userHMETAFILE *hMF;
} remoteMETAFILEPICT;
typedef struct _userHENHMETAFILE {
	long fContext;
	union __MIDL_IWinTypes_0006 {
		long hInproc;
		BYTE_BLOB *hRemote;
		long hGlobal;
	} u;
} userHENHMETAFILE;
typedef struct _userHMETAFILEPICT {
	long fContext;
	union __MIDL_IWinTypes_0005 {
		long hInproc;
		remoteMETAFILEPICT *hRemote;
		long hGlobal;
	} u;
} userHMETAFILEPICT;
typedef struct _userHGLOBAL {
	long fContext;
	union __MIDL_IWinTypes_0003 {
		long hInproc;
		FLAGGED_BYTE_BLOB *hRemote;
		long hGlobal;
	} u;
} userHGLOBAL;
typedef struct _userHPALETTE {
	long fContext;
	union __MIDL_IWinTypes_0008 {
		long hInproc;
		rpcLOGPALETTE *hRemote;
		long hGlobal;
	} u;
} userHPALETTE;
#ifndef _tagBSTRBLOB_DEFINED
#define _tagBSTRBLOB_DEFINED
typedef struct tagBSTRBLOB {
	ULONG cbSize;
	BYTE *pData;
} BSTRBLOB;
typedef struct tagBSTRBLOB *LPBSTRBLOB;
#endif
typedef struct _CLIPDATA {
	ULONG cbSize;
	long ulClipFmt;
	BYTE *pClipData;
} CLIPDATA;
typedef struct _FLAGGED_WORD_BLOB {
	unsigned long fFlags;
	unsigned long clSize;
	unsigned short asData[1];
}FLAGGED_WORD_BLOB;
typedef struct _BYTE_SIZEDARR {
	unsigned long clSize;
	unsigned char *pData;
}BYTE_SIZEDARR;
typedef struct _SHORT_SIZEDARR {
	unsigned long clSize;
	unsigned short *pData;
} WORD_SIZEDARR;
typedef struct _LONG_SIZEDARR {
	unsigned long clSize;
	unsigned long *pData;
}DWORD_SIZEDARR;
typedef struct _HYPER_SIZEDARR {
	unsigned long clSize;
	long long int *pData;
}HYPER_SIZEDARR;
typedef FLAGGED_WORD_BLOB *wireBSTR;
typedef userHENHMETAFILE *wireHENHMETAFILE;
typedef userHGLOBAL *wireHGLOBAL;
typedef userHMETAFILEPICT wireHMETAFILEPICT;
typedef userHMETAFILE *wireHMETAFILE;
typedef userHPALETTE *wireHPALETTE;
typedef userHBITMAP *wireHBITMAP;
typedef userCLIPFORMAT *wireCLIPFORMAT;
typedef WORD CLIPFORMAT;
typedef unsigned long PROPID;
typedef OLECHAR *LPOLESTR;
typedef GUID FMTID;
typedef FMTID *REFFMTID;
typedef enum _CLASSPATHTYPE { ExeNamePath=0,DllNamePath=ExeNamePath+1,TlbNamePath=DllNamePath+1,
	CabFilePath=TlbNamePath+1,InfFilePath=CabFilePath+1,DrwFilePath=InfFilePath+1,
	SetupNamePath=DrwFilePath+1 } CLASSPATHTYPE;
typedef struct __MIDL___MIDL_itf_wtypes_0002_0001 {
	DWORD tyspec;
	union __MIDL___MIDL_itf_wtypes_0002_00 {
		CLSID clsid;
		IID iid;
		GUID typelibID;
		LPOLESTR pFileExt;
		LPOLESTR pMimeType;
		LPOLESTR pProgId;
		LPOLESTR pFileName;
		LPOLESTR pJavaClassName;
		struct { LPOLESTR pPackageName; GUID PolicyId;} ByName;
		struct { LPOLESTR pScriptName; GUID PolicyId;} ByScript;
	} tagged_union;
} uCLSSPEC;
typedef struct _CSPLATFORM {
	DWORD dwPlatformId;
	DWORD dwVersionHi;
	DWORD dwVersionLo;
	DWORD dwProcessorArch;
} CSPLATFORM;
typedef struct _QUERYCONTEXT {
	DWORD dwContext;
	CSPLATFORM Platform;
	LCID Locale;
	DWORD dwVersionHi;
	DWORD dwVersionLo;
} QUERYCONTEXT;
typedef struct _CLASSDETAIL {
	CLSID Clsid;
	CLSID TreatAs;
	DWORD cProgId;
	DWORD dwComClassContext;
	LPOLESTR *prgProgId;
} CLASSDETAIL;
typedef struct _ACTIVATIONINFO {
	UINT cClasses;
	CLASSDETAIL *pClasses;
	UINT cShellFileExt;
	LPOLESTR *prgShellFileExt;
	UINT *prgPriority;
	UINT cInterfaces;
	IID *prgInterfaceId;
	UINT cTypeLib;
	GUID *prgTlbId;
} ACTIVATIONINFO;
typedef struct _PLATFORMINFO {
	UINT cPlatforms;
	CSPLATFORM *prgPlatform;
 UINT cLocales;
	LCID *prgLocale;
} PLATFORMINFO;
typedef struct tagINSTALLINFO {
	DWORD dwActFlags;
	CLASSPATHTYPE PathType;
	LPOLESTR pszScriptPath;
	LPOLESTR pszSetupCommand;
	LPOLESTR pszUrl;
	ULONGLONG Usn;
	UINT InstallUiLevel;
	GUID *pClsid;
	GUID ProductCode;
	GUID Mvipc;
	DWORD dwVersionHi;
	DWORD dwVersionLo;
	DWORD dwRevision;
	UINT cUpgrades;
	LPOLESTR *prgUpgradeScript;
	DWORD *prgUpgradeFlag;
	ULONG cScriptLen;
}INSTALLINFO;
typedef struct tagPACKAGEDETAIL {
	LPOLESTR pszPackageName;
	LPOLESTR pszPublisher;
	UINT cSources;
	LPOLESTR *pszSourceList;
	UINT cCategories;
	GUID *rpCategory;
	ACTIVATIONINFO *pActInfo;
	PLATFORMINFO *pPlatformInfo;
	INSTALLINFO *pInstallInfo;
} PACKAGEDETAIL;
typedef struct tagTRACKMOUSEEVENT {
	DWORD cbSize;
	DWORD dwFlags;
	HWND hwndTrack;
	DWORD dwHoverTime;
} TRACKMOUSEEVENT, *LPTRACKMOUSEEVENT;
typedef struct tagREBARINFO {
	UINT cbSize;
	UINT fMask;
	HANDLE himl;
} REBARINFO,*LPREBARINFO;
typedef struct tagREBARBANDINFOA {
	UINT cbSize;
	UINT fMask;
	UINT fStyle;
	COLORREF clrFore;
	COLORREF clrBack;
	LPSTR lpText;
	UINT cch;
	int iImage;
	HWND hwndChild;
	UINT cxMinChild;
	UINT cyMinChild;
	UINT cx;
	HBITMAP hbmBack;
	UINT wID;
	UINT cyChild;
	UINT cyMaxChild;
	UINT cyIntegral;
	UINT cxIdeal;
	LPARAM lParam;
	UINT cxHeader;
} REBARBANDINFOA,*LPREBARBANDINFOA;
typedef REBARBANDINFOA CONST *LPCREBARBANDINFOA;
typedef struct tagREBARBANDINFOW {
	UINT	cbSize;
	UINT	fMask;
	UINT	fStyle;
	COLORREF	clrFore;
	COLORREF	clrBack;
	LPWSTR	lpText;
	UINT	cch;
	int	iImage;
	HWND	hwndChild;
	UINT	cxMinChild;
	UINT	cyMinChild;
	UINT	cx;
	HBITMAP	hbmBack;
	UINT	wID;
	UINT	cyChild;
	UINT	cyMaxChild;
	UINT	cyIntegral;
	UINT	cxIdeal;
	LPARAM	lParam;
	UINT	cxHeader;
} REBARBANDINFOW, *LPREBARBANDINFOW;
typedef REBARBANDINFOW CONST *LPCREBARBANDINFOW;
typedef struct tagLVITEMA {
	UINT mask;
	int iItem;
	int iSubItem;
	UINT state;
	UINT stateMask;
	LPSTR pszText;
	int cchTextMax;
	int iImage;
	LPARAM lParam;
	int iIndent;
} LVITEMA, *LPLVITEMA;
typedef struct tagLVITEMW {
	UINT mask;
	int iItem;
	int iSubItem;
	UINT state;
	UINT stateMask;
	LPWSTR pszText;
	int cchTextMax;
	int iImage;
	LPARAM lParam;
	int iIndent;
} LVITEMW, *LPLVITEMW;
typedef struct tagLVDISPINFO {
	NMHDR hdr;
	LVITEMA item;
} NMLVDISPINFOA, *LPNMLVDISPINFOA;
typedef struct tagLVDISPINFOW {
	NMHDR hdr;
	LVITEMW item;
} NMLVDISPINFOW, *LPNMLVDISPINFOW;
#define LVN_KEYDOWN	(-155)
#define LV_KEYDOWN NMLVKEYDOWN
typedef struct tagLVKEYDOWN {
	NMHDR hdr;
	WORD wVKey;
	UINT flags;
} NMLVKEYDOWN, *LPNMLVKEYDOWN;
#define LVN_MARQUEEBEGIN	(-156)
typedef struct tagNMLVGETINFOTIPA {
	NMHDR hdr;
	DWORD dwFlags;
	LPSTR pszText;
	int cchTextMax;
	int iItem;
	int iSubItem;
	LPARAM lParam;
} NMLVGETINFOTIPA, *LPNMLVGETINFOTIPA;
typedef struct tagNMLVGETINFOTIPW {
	NMHDR hdr;
	DWORD dwFlags;
	LPWSTR pszText;
	int cchTextMax;
	int iItem;
	int iSubItem;
	LPARAM lParam;
} NMLVGETINFOTIPW, *LPNMLVGETINFOTIPW;
#define LVGIT_UNFOLDED	1
#define LVN_GETINFOTIPA (-157)
#define LVN_GETINFOTIPW (-158)
typedef struct tagNMMOUSE {
	NMHDR	hdr;
	DWORD_PTR dwItemSpec;
	DWORD_PTR dwItemData;
	POINT	pt;
	LPARAM dwHitInfo;
} NMMOUSE, *LPNMMOUSE;
typedef NMMOUSE NMCLICK;
typedef LPNMMOUSE LPNMCLICK;
typedef struct tagNMLVCACHEHINT {
	NMHDR hdr;
	int iFrom;
	int iTo;
} NMLVCACHEHINT,*LPNMLVCACHEHINT;
typedef struct tagCOLORSCHEME {
	DWORD	dwSize;
	COLORREF	clrBtnHighlight;
	COLORREF	clrBtnShadow;
} COLORSCHEME, *LPCOLORSCHEME;
#define LPNM_CACHEHINT	LPNMLVCACHEHINT
#define PNM_CACHEHINT	LPNMLVCACHEHINT
#define NM_CACHEHINT	NMLVCACHEHINT
typedef struct tagLVFINDINFOA {
	UINT flags;
	LPCSTR psz;
	LPARAM lParam;
	POINT pt;
	UINT vkDirection;
} LVFINDINFOA, *LPFINDINFOA;
typedef struct tagLVFINDINFOW {
	UINT flags;
	LPCWSTR psz;
	LPARAM lParam;
	POINT pt;
	UINT vkDirection;
} LVFINDINFOW, *LPFINDINFOW;
typedef struct tagNMLVFINDITEM {
	NMHDR hdr;
	int iStart;
	LVFINDINFO lvfi;
} NMLVFINDITEM, *LPNMLVFINDITEM;
#define PNM_FINDITEM LPNMLVFINDITEM
#define LPNM_FINDITEM LPNMLVFINDITEM
#define NM_FINDITEM NMLVFINDITEM
typedef struct tagNMLVODSTATECHANGE {
	NMHDR hdr;
	int iFrom;
	int iTo;
	UINT uNewState;
	UINT uOldState;
} NMLVODSTATECHANGE, *LPNMLVODSTATECHANGE;
#define PNM_ODSTATECHANGE LPNMLVODSTATECHANGE
#define LPNM_ODSTATECHANGE LPNMLVODSTATECHANGE
#define NM_ODSTATECHANGE NMLVODSTATECHANGE
#define IID_NULL	GUID_NULL
#define CLSID_NULL	GUID_NULL
#define FMTID_NULL	GUID_NULL
typedef struct tagNMITEMACTIVATE{
	NMHDR	hdr;
	int	iItem;
	int	iSubItem;
	UINT	uNewState;
	UINT	uOldState;
	UINT	uChanged;
	POINT	ptAction;
	LPARAM	lParam;
	UINT	uKeyFlags;
} NMITEMACTIVATE, *LPNMITEMACTIVATE;
typedef struct _LVHITTESTINFO {
	POINT pt;
	UINT flags;
	int iItem;
	int iSubItem;
} LVHITTESTINFO, *LPLVHITTESTINFO;
typedef struct tagCOMBOBOXINFO {
	DWORD cbSize;
	RECT rcItem;
	RECT rcButton;
	DWORD stateButton;
	HWND hwndCombo;
	HWND hwndItem;
	HWND hwndList;
} COMBOBOXINFO, *PCOMBOBOXINFO, *LPCOMBOBOXINFO;
typedef struct tagWINDOWINFO {
	DWORD cbSize;
	RECT rcWindow;
	RECT rcClient;
	DWORD dwStyle;
	DWORD dwExStyle;
	DWORD dwWindowStatus;
	UINT cxWindowBorders;
	UINT cyWindowBorders;
	ATOM atomWindowType;
	WORD wCreatorVersion;
} WINDOWINFO, *PWINDOWINFO, *LPWINDOWINFO;
typedef VOID (APIENTRY *PAPCFUNC)(ULONG *);
#define INPUT_MOUSE	0
#define INPUT_KEYBOARD	1
#define INPUT_HARDWARE	2
typedef struct tagMOUSEINPUT {
	LONG	dx;
	LONG	dy;
	DWORD	mouseData;
	DWORD	dwFlags;
	DWORD	time;
	DWORD	dwExtraInfo;
} MOUSEINPUT, *PMOUSEINPUT, * LPMOUSEINPUT;
typedef struct tagHARDWAREINPUT {
	DWORD	uMsg;
	WORD	wParamL;
	WORD	wParamH;
} HARDWAREINPUT, *PHARDWAREINPUT, *LPHARDWAREINPUT;
typedef struct tagKEYBDINPUT {
	WORD	wVk;
	WORD	wScan;
	DWORD	dwFlags;
	DWORD	time;
	DWORD	dwExtraInfo;
} KEYBDINPUT, *PKEYBDINPUT, FAR* LPKEYBDINPUT;
typedef struct tagINPUT {
	DWORD	type;
	union {
		MOUSEINPUT	mi;
		KEYBDINPUT	ki;
		HARDWAREINPUT	hi;
	};
} INPUT, *PINPUT, *LPINPUT;
typedef struct tagMENUBARINFO {
	DWORD cbSize;
	RECT rcBar;
	HMENU hMenu;
	HWND hwndMenu;
	BOOL fBarFocused:1;
	BOOL fFocused:1;
} MENUBARINFO, *PMENUBARINFO, *LPMENUBARINFO;
typedef struct tagSCROLLBARINFO {
	DWORD	cbSize;
	RECT	rcScrollBar;
	int	dxyLineButton;
	int	xyThumbTop;
	int	xyThumbBottom;
	int	reserved;
	DWORD rgstate[CCHILDREN_SCROLLBAR+1];
} SCROLLBARINFO, *PSCROLLBARINFO, *LPSCROLLBARINFO;
typedef struct tagTITLEBARINFO {
	DWORD	cbSize;
	RECT	rcTitleBar;
	DWORD	rgstate[CCHILDREN_TITLEBAR+1];
} TITLEBARINFO, *PTITLEBARINFO, *LPTITLEBARINFO;
typedef struct tagCURSORINFO {
	DWORD	cbSize;
	DWORD	flags;
	HCURSOR hCursor;
	POINT	ptScreenPos;
} CURSORINFO, *PCURSORINFO, *LPCURSORINFO;
typedef struct {
	NMHDR hdr;
	int	iItemid;
	WCHAR szText[CBEMAXSTRLEN];
}NMCBEDRAGBEGINW, *LPNMCBEDRAGBEGINW, *PNMCBEDRAGBEGINW;
typedef struct {
	NMHDR hdr;
	int	iItemid;
	char szText[CBEMAXSTRLEN];
}NMCBEDRAGBEGINA, *LPNMCBEDRAGBEGINA, *PNMCBEDRAGBEGINA;
typedef struct {
	NMHDR hdr;
	BOOL fChanged;
	int iNewSelection;
	WCHAR szText[CBEMAXSTRLEN];
	int iWhy;
} NMCBEENDEDITW, *LPNMCBEENDEDITW, *PNMCBEENDEDITW;

typedef struct {
	NMHDR hdr;
	BOOL fChanged;
	int iNewSelection;
	char szText[CBEMAXSTRLEN];
	int iWhy;
} NMCBEENDEDITA, *LPNMCBEENDEDITA,*PNMCBEENDEDITA;
typedef struct tagCOMBOBOXEXITEMA {
	UINT mask;
	int iItem;
	LPSTR pszText;
	int cchTextMax;
	int iImage;
	int iSelectedImage;
	int iOverlay;
	int iIndent;
	LPARAM lParam;
} COMBOBOXEXITEMA, *PCOMBOBOXEXITEMA;
typedef COMBOBOXEXITEMA CONST *PCCOMBOEXITEMA;
typedef struct tagCOMBOBOXEXITEMW {
	UINT mask;
	int iItem;
	LPWSTR pszText;
	int cchTextMax;
	int iImage;
	int iSelectedImage;
	int iOverlay;
	int iIndent;
	LPARAM lParam;
} COMBOBOXEXITEMW, *PCOMBOBOXEXITEMW;
typedef COMBOBOXEXITEMW CONST *PCCOMBOEXITEMW;
typedef struct tagNMHDDISPINFOW {
	NMHDR	hdr;
	int	iItem;
	UINT	mask;
	LPWSTR pszText;
	int	cchTextMax;
	int	iImage;
	LPARAM lParam;
} NMHDDISPINFOW, *LPNMHDDISPINFOW;
typedef struct tagNMHDDISPINFOA {
	NMHDR	hdr;
	int	iItem;
	UINT	mask;
	LPSTR	pszText;
	int	cchTextMax;
	int	iImage;
	LPARAM lParam;
} NMHDDISPINFOA,*LPNMHDDISPINFOA;
#ifdef UNICODE
#define NMHDDISPINFO	NMHDDISPINFOW
#define LPNMHDDISPINFO	LPNMHDDISPINFOW
#else
#define NMHDDISPINFO	NMHDDISPINFOA
#define LPNMHDDISPINFO	LPNMHDDISPINFOA
#endif
typedef enum _JOBOBJECTINFOCLASS { JobObjectBasicAccountingInformation = 1,
	JobObjectBasicLimitInformation, JobObjectBasicProcessIdList,
	JobObjectBasicUIRestrictions, JobObjectSecurityLimitInformation,
	JobObjectEndOfJobTimeInformation, JobObjectAssociateCompletionPortInformation,
	JobObjectBasicAndIoAccountingInformation, JobObjectExtendedLimitInformation,
	JobObjectJobSetInformation, MaxJobObjectInfoClass
} JOBOBJECTINFOCLASS;
typedef struct tagPDA {
	DWORD lStructSize;
	HWND hwndOwner;
	HGLOBAL hDevMode;
	HGLOBAL hDevNames;
	HDC hDC;
	DWORD Flags;
	WORD nFromPage;
	WORD nToPage;
	WORD nMinPage;
	WORD nMaxPage;
	WORD nCopies;
	HINSTANCE hInstance;
	LPARAM lCustData;
	LPPRINTHOOKPROC lpfnPrintHook;
	LPSETUPHOOKPROC lpfnSetupHook;
	LPCSTR lpPrintTemplateName;
	LPCSTR lpSetupTemplateName;
	HGLOBAL hPrintTemplate;
	HGLOBAL hSetupTemplate;
} PRINTDLGA, *LPPRINTDLGA;
typedef struct tagPDW {
	DWORD lStructSize;
	HWND hwndOwner;
	HGLOBAL hDevMode;
	HGLOBAL hDevNames;
	HDC	hDC;
	DWORD Flags;
	WORD nFromPage;
	WORD nToPage;
	WORD nMinPage;
	WORD nMaxPage;
	WORD nCopies;
	HINSTANCE hInstance;
	LPARAM lCustData;
	LPPRINTHOOKPROC lpfnPrintHook;
	LPSETUPHOOKPROC lpfnSetupHook;
	LPCWSTR lpPrintTemplateName;
	LPCWSTR lpSetupTemplateName;
	HGLOBAL hPrintTemplate;
	HGLOBAL		hSetupTemplate;
} PRINTDLGW, *LPPRINTDLGW;
typedef struct tagHW_PROFILE_INFOA {
	DWORD dwDockInfo; CHAR szHwProfileGuid[HW_PROFILE_GUIDLEN];
	CHAR	szHwProfileName[MAX_PROFILE_LEN];
} HW_PROFILE_INFOA, *LPHW_PROFILE_INFOA;
typedef struct tagHW_PROFILE_INFOW {
	DWORD dwDockInfo;
	WCHAR szHwProfileGuid[HW_PROFILE_GUIDLEN];
	WCHAR szHwProfileName[MAX_PROFILE_LEN];
} HW_PROFILE_INFOW, *LPHW_PROFILE_INFOW;
typedef struct _FILE_NOTIFY_INFORMATION {
	DWORD NextEntryOffset;
	DWORD Action;
	DWORD FileNameLength;
	WCHAR FileName[1];
} FILE_NOTIFY_INFORMATION, *PFILE_NOTIFY_INFORMATION;
typedef union _FILE_SEGMENT_ELEMENT {
	long long * Buffer;
	long long Alignment;
}FILE_SEGMENT_ELEMENT, *PFILE_SEGMENT_ELEMENT;
typedef struct tagALTTABINFO {
	DWORD	cbSize;
	int	cItems;
	int	cColumns;
	int	cRows;
	int	iColFocus;
	int	iRowFocus;
	int	cxItem;
	int	cyItem;
	POINT	ptStart;
} ALTTABINFO, *PALTTABINFO, *LPALTTABINFO;
typedef VOID (CALLBACK* WINEVENTPROC)(HWINEVENTHOOK,DWORD,HWND,LONG,LONG,DWORD,DWORD);
typedef VOID (APIENTRY *PTIMERAPCROUTINE)(LPVOID,DWORD,DWORD);
typedef enum _FINDEX_INFO_LEVELS { FindExInfoStandard, FindExInfoMaxInfoLevel } FINDEX_INFO_LEVELS;
typedef enum _FINDEX_SEARCH_OPS { FindExSearchNameMatch, FindExSearchLimitToDirectories, FindExSearchLimitToDevices, FindExSearchMaxSearchOp } FINDEX_SEARCH_OPS;
typedef struct { UINT cbSize; POINT pt; UINT uHit; SYSTEMTIME st; } MCHITTESTINFO, *PMCHITTESTINFO;
typedef struct tagNMSELCHANGE { NMHDR nmhdr;SYSTEMTIME stSelStart; SYSTEMTIME stSelEnd; } NMSELCHANGE, *LPNMSELCHANGE;
typedef struct tagNMDAYSTATE { NMHDR nmhdr; SYSTEMTIME stStart; int cDayState; LPMONTHDAYSTATE prgDayState; } NMDAYSTATE,*LPNMDAYSTATE;
#ifdef UNICODE
typedef HW_PROFILE_INFOW HW_PROFILE_INFO;
typedef LPHW_PROFILE_INFOW LPHW_PROFILE_INFO;
typedef PRINTDLGW PRINTDLG;
typedef LPPRINTDLGW LPPRINTDLG;
#else
typedef HW_PROFILE_INFOA HW_PROFILE_INFO;
typedef LPHW_PROFILE_INFOA LPHW_PROFILE_INFO;
typedef PRINTDLGA PRINTDLG;
typedef LPPRINTDLGA LPPRINTDLG;
#endif
typedef struct tagGUITHREADINFO {
	DWORD cbSize;
	DWORD flags;
	HWND hwndActive;
	HWND hwndFocus;
	HWND hwndCapture;
	HWND hwndMenuOwner;
	HWND hwndMoveSize;
	HWND hwndCaret;
	RECT rcCaret;
} GUITHREADINFO, *PGUITHREADINFO, *LPGUITHREADINFO;
#define GUI_CARETBLINKING	1
#define GUI_INMOVESIZE	2
#define GUI_INMENUMODE	4
#define GUI_SYSTEMMENUMODE 8
#define GUI_POPUPMENUMODE	16
typedef struct tagLVCOLUMNA {
	UINT mask;
	int fmt;
	int cx;
	LPSTR pszText;
	int cchTextMax;
	int iSubItem;
	int iImage;
	int iOrder;
} LVCOLUMNA, *LPLVCOLUMNA;
typedef struct tagLVCOLUMNW {
	UINT mask;
	int fmt;
	int cx;
	LPWSTR pszText;
	int cchTextMax;
	int iSubItem;
	int iImage;
	int iOrder;
} LVCOLUMNW, *LPLVCOLUMNW;
typedef struct {UINT cbSize; HWND hwnd; DWORD dwFlags; UINT uCount; DWORD dwTimeout; } FLASHWINFO, *PFLASHWINFO;
typedef enum _GET_FILEEX_INFO_LEVELS { GetFileExInfoStandard, GetFileExMaxInfoLevel } GET_FILEEX_INFO_LEVELS;
typedef struct _BLENDFUNCTION {
	BYTE	BlendOp;
	BYTE	BlendFlags;
	BYTE	SourceConstantAlpha;
	BYTE	AlphaFormat;
}BLENDFUNCTION,*PBLENDFUNCTION;
typedef struct _WIN32_FILE_ATTRIBUTE_DATA {
	DWORD dwFileAttributes;
	FILETIME ftCreationTime;
	FILETIME ftLastAccessTime;
	FILETIME ftLastWriteTime;
	DWORD nFileSizeHigh;
	DWORD nFileSizeLow;
} WIN32_FILE_ATTRIBUTE_DATA,*LPWIN32_FILE_ATTRIBUTE_DATA;
typedef VOID (WINAPI *PFLS_CALLBACK_FUNCTION)(PVOID);
typedef USHORT COLOR16;
typedef struct _TRIVERTEX {LONG x; LONG y; COLOR16 Red; COLOR16 Green;
COLOR16 Blue; COLOR16 Alpha; }TRIVERTEX,*PTRIVERTEX,*LPTRIVERTEX;
typedef struct _GRADIENT_TRIANGLE { ULONG Vertex1; ULONG Vertex2; ULONG Vertex3;
} GRADIENT_TRIANGLE,*PGRADIENT_TRIANGLE,*LPGRADIENT_TRIANGLE;
typedef struct _GRADIENT_RECT { ULONG UpperLeft; ULONG LowerRight;
}GRADIENT_RECT,*PGRADIENT_RECT,*LPGRADIENT_RECT;
typedef struct _OBJECT_TYPE_LIST { WORD Level; WORD Sbz; GUID *ObjectType; } OBJECT_TYPE_LIST, *POBJECT_TYPE_LIST;
typedef enum _AUDIT_EVENT_TYPE { AuditEventObjectAccess, AuditEventDirectoryServiceAccess } AUDIT_EVENT_TYPE, *PAUDIT_EVENT_TYPE;
typedef ACE_HEADER *PACE_HEADER;
typedef struct tagMENUINFO {
	DWORD cbSize;
	DWORD fMask;
	DWORD dwStyle;
	UINT cyMax;
	HBRUSH hbrBack;
	DWORD dwContextHelpID;
	ULONG_PTR dwMenuData;
} MENUINFO, *LPMENUINFO;
typedef MENUINFO CONST *LPCMENUINFO;
typedef struct tagMENUGETOBJECTINFO {
	DWORD dwFlags;
	UINT uPos;
	HMENU hmenu;
	PVOID riid;
	PVOID pvObj;
} MENUGETOBJECTINFO, *PMENUGETOBJECTINFO;
typedef struct _JOB_SET_ARRAY {
	HANDLE JobHandle;
	DWORD MemberLevel;
	DWORD Flags;
} JOB_SET_ARRAY, *PJOB_SET_ARRAY;
typedef enum _LOGICAL_PROCESSOR_RELATIONSHIP {
RelationProcessorCore, RelationNumaNode
} LOGICAL_PROCESSOR_RELATIONSHIP;
typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
	ULONG_PTR  ProcessorMask;
	LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
	union {
		struct {
			BYTE Flags;
		} ProcessorCore;
		struct {
			DWORD NodeNumber;
		} NumaNode;
		ULONGLONG Reserved[2];
	};
} SYSTEM_LOGICAL_PROCESSOR_INFORMATION, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION;
typedef LONG (NTAPI *PVECTORED_EXCEPTION_HANDLER)(struct _EXCEPTION_POINTERS *);
typedef struct tagACTCTX_SECTION_KEYED_DATA_2600 {
	ULONG cbSize;
	ULONG ulDataFormatVersion;
	PVOID lpData;
	ULONG ulLength;
	PVOID lpSectionGlobalData;
	ULONG ulSectionGlobalDataLength;
	PVOID lpSectionBase;
	ULONG ulSectionTotalLength;
	HANDLE hActCtx;
	ULONG ulAssemblyRosterIndex;
} ACTCTX_SECTION_KEYED_DATA_2600, *PACTCTX_SECTION_KEYED_DATA_2600;
typedef const ACTCTX_SECTION_KEYED_DATA_2600 * PCACTCTX_SECTION_KEYED_DATA_2600;

typedef struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {
	PVOID lpInformation;
	PVOID lpSectionBase;
	ULONG ulSectionLength;
	PVOID lpSectionGlobalDataBase;
	ULONG ulSectionGlobalDataLength;
} ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA, *PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
typedef const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA *PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
typedef struct tagACTCTX_SECTION_KEYED_DATA {
	ULONG cbSize;
	ULONG ulDataFormatVersion;
	PVOID lpData;
	ULONG ulLength;
	PVOID lpSectionGlobalData;
	ULONG ulSectionGlobalDataLength;
	PVOID lpSectionBase;
	ULONG ulSectionTotalLength;
	HANDLE hActCtx;
	ULONG ulAssemblyRosterIndex;
// 2600 stops here
	ULONG ulFlags;
	ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA AssemblyMetadata;
} ACTCTX_SECTION_KEYED_DATA, *PACTCTX_SECTION_KEYED_DATA;
typedef const ACTCTX_SECTION_KEYED_DATA * PCACTCTX_SECTION_KEYED_DATA;
typedef struct _EVENTLOG_FULL_INFORMATION { DWORD   dwFull; }
EVENTLOG_FULL_INFORMATION, *LPEVENTLOG_FULL_INFORMATION;
#define FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX 1
#define FIND_ACTCTX_SECTION_KEY_RETURN_FLAGS 2
#define FIND_ACTCTX_SECTION_KEY_RETURN_ASSEMBLY_METADATA 4
typedef enum _COMPUTER_NAME_FORMAT {
   ComputerNameNetBIOS, ComputerNameDnsHostname, ComputerNameDnsDomain,
   ComputerNameDnsFullyQualified, ComputerNamePhysicalNetBIOS, ComputerNamePhysicalDnsHostname,
   ComputerNamePhysicalDnsDomain, ComputerNamePhysicalDnsFullyQualified, ComputerNameMax
} COMPUTER_NAME_FORMAT ;
typedef enum _STREAM_INFO_LEVELS { FindStreamInfoStandard, FindStreamInfoMaxInfoLevel
} STREAM_INFO_LEVELS;
typedef struct _WIN32_FIND_DATAA {
	DWORD dwFileAttributes;
	FILETIME ftCreationTime;
	FILETIME ftLastAccessTime;
	FILETIME ftLastWriteTime;
	DWORD nFileSizeHigh;
	DWORD nFileSizeLow;
	DWORD dwReserved0;
	DWORD dwReserved1;
	CHAR  cFileName[ MAX_PATH ];
	CHAR  cAlternateFileName[ 14 ];
} WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;
typedef struct _WIN32_FIND_DATAW {
	DWORD dwFileAttributes;
	FILETIME ftCreationTime;
	FILETIME ftLastAccessTime;
	FILETIME ftLastWriteTime;
	DWORD nFileSizeHigh;
	DWORD nFileSizeLow;
	DWORD dwReserved0;
	DWORD dwReserved1;
	WCHAR cFileName[ MAX_PATH ];
	WCHAR cAlternateFileName[ 14 ];
} WIN32_FIND_DATAW, *PWIN32_FIND_DATAW, *LPWIN32_FIND_DATAW;
#define RTL_CRITSECT_TYPE 0
#define RTL_RESOURCE_TYPE 1
typedef struct _RTL_CRITICAL_SECTION {
	PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
	LONG LockCount;
	LONG RecursionCount;
	HANDLE OwningThread;
	HANDLE LockSemaphore;
	ULONG_PTR SpinCount;
} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;
typedef RTL_CRITICAL_SECTION CRITICAL_SECTION;
typedef RTL_CRITICAL_SECTION *LPCRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION_DEBUG LPCRITICAL_SECTION_DEBUG;
typedef enum _HEAP_INFORMATION_CLASS { HeapCompatibilityInformation } HEAP_INFORMATION_CLASS;
typedef enum { WinNullSid=0,WinWorldSid=1, WinLocalSid=2, WinCreatorOwnerSid=3,
 WinCreatorGroupSid=4, WinCreatorOwnerServerSid=5, WinCreatorGroupServerSid=6,
 WinNtAuthoritySid=7, WinDialupSid=8, WinNetworkSid=9, WinBatchSid=10,
 WinInteractiveSid=11, WinServiceSid=12, WinAnonymousSid=13, WinProxySid=14,
 WinEnterpriseControllersSid=15, WinSelfSid=16, WinAuthenticatedUserSid=17,
 WinRestrictedCodeSid=18, WinTerminalServerSid=19, WinRemoteLogonIdSid=20,
 WinLogonIdsSid=21, WinLocalSystemSid=22, WinLocalServiceSid=23,
 WinNetworkServiceSid=24, WinBuiltinDomainSid=25, WinBuiltinAdministratorsSid=26,
 WinBuiltinUsersSid=27, WinBuiltinGuestsSid=28, WinBuiltinPowerUsersSid=29,
 WinBuiltinAccountOperatorsSid=30, WinBuiltinSystemOperatorsSid=31,
 WinBuiltinPrintOperatorsSid=32, WinBuiltinBackupOperatorsSid=33,
 WinBuiltinReplicatorSid=34, WinBuiltinPreWindows2000CompatibleAccessSid=35,
 WinBuiltinRemoteDesktopUsersSid=36, WinBuiltinNetworkConfigurationOperatorsSid=37,
 WinAccountAdministratorSid=38, WinAccountGuestSid=39, WinAccountKrbtgtSid=40,
 WinAccountDomainAdminsSid=41, WinAccountDomainUsersSid=42, WinAccountDomainGuestsSid=43,
 WinAccountComputersSid=44, WinAccountControllersSid=45, WinAccountCertAdminsSid=46,
 WinAccountSchemaAdminsSid=47, WinAccountEnterpriseAdminsSid=48,
 WinAccountPolicyAdminsSid=49, WinAccountRasAndIasServersSid=50,
 WinNTLMAuthenticationSid=51, WinDigestAuthenticationSid=52,
 WinSChannelAuthenticationSid=53, WinThisOrganizationSid=54, WinOtherOrganizationSid=55,
 WinBuiltinIncomingForestTrustBuildersSid=56, WinBuiltinPerfMonitoringUsersSid=57,
 WinBuiltinPerfLoggingUsersSid=58, WinBuiltinAuthorizationAccessSid=59,
 WinBuiltinTerminalServerLicenseServersSid=60
} WELL_KNOWN_SID_TYPE;
typedef enum _MEMORY_RESOURCE_NOTIFICATION_TYPE { LowMemoryResourceNotification,
HighMemoryResourceNotification } MEMORY_RESOURCE_NOTIFICATION_TYPE;
typedef struct _WIN32_FIND_STREAM_DATA {
	LARGE_INTEGER StreamSize;
	WCHAR cStreamName[ MAX_PATH + 36 ];
} WIN32_FIND_STREAM_DATA, *PWIN32_FIND_STREAM_DATA;
typedef BOOL (WINAPI* PGET_MODULE_HANDLE_EXA)(DWORD,LPCSTR,HMODULE*);
typedef BOOL (WINAPI* PGET_MODULE_HANDLE_EXW)(DWORD,LPCWSTR,HMODULE*);
typedef DWORD (WINAPI *PFE_EXPORT_FUNC)(PBYTE,PVOID,ULONG);
typedef DWORD (WINAPI *PFE_IMPORT_FUNC)(PBYTE,PVOID,PULONG);
typedef struct tagNMTTCUSTOMDRAW {
	NMCUSTOMDRAW nmcd;
	UINT uDrawFlags;
} NMTTCUSTOMDRAW, *LPNMTTCUSTOMDRAW;
typedef struct _IMAGELISTDRAWPARAMS {
	DWORD cbSize;
	HIMAGELIST himl;
	int i;
	HDC hdcDst;
	int x;
	int y;
	int cx;
	int cy;
	int xBitmap;
	int yBitmap;
	COLORREF rgbBk;
	COLORREF rgbFg;
	UINT fStyle;
	DWORD dwRop;
#if (_WIN32_IE >= 0x501)
	DWORD fState;
	DWORD Frame;
	COLORREF crEffect;
#endif
} IMAGELISTDRAWPARAMS, *LPIMAGELISTDRAWPARAMS;
#ifndef __ISequentialStream_INTERFACE_DEFINED__
#define __ISequentialStream_INTERFACE_DEFINED__
struct ISequentialStream { const struct ISequentialStreamVtbl *lpVtbl; };
#endif
typedef struct _HD_TEXTFILTERA {
	LPSTR pszText;
	INT cchTextMax;
} HD_TEXTFILTERA, *LPHD_TEXTFILTERA;
typedef struct _HD_TEXTFILTERW {
	LPWSTR pszText;
	INT cchTextMax;
} HD_TEXTFILTERW, *LPHD_TEXTFILTERW;
typedef struct {
	UINT cbSize;
	DWORD dwMask;
	int cxPad;
	int cyPad;
	int cxBarPad;
	int cyBarPad;
	int cxButtonSpacing;
	int cyButtonSpacing;
} TBMETRICS, * LPTBMETRICS;
typedef struct tagNMTBSAVE {
	NMHDR hdr;
	DWORD* pData;
	DWORD* pCurrent;
	UINT cbData;
	int iItem;
	int cButtons;
	TBBUTTON tbButton;
} NMTBSAVE, *LPNMTBSAVE;
typedef struct tagNMTBRESTORE {
	NMHDR hdr;
	DWORD* pData;
	DWORD* pCurrent;
	UINT cbData;
	int iItem;
	int cButtons;
	int cbBytesPerRecord;
	TBBUTTON tbButton;
} NMTBRESTORE, *LPNMTBRESTORE;
typedef struct tagNMREBARCHILDSIZE {
	NMHDR hdr;
	UINT uBand;
	UINT wID;
	RECT rcChild;
	RECT rcBand;
} NMREBARCHILDSIZE, *LPNMREBARCHILDSIZE;
typedef struct tagNMREBAR {
	NMHDR  hdr;
	DWORD  dwMask;
	UINT   uBand;
	UINT   fStyle;
	UINT   wID;
	LPARAM lParam;
} NMREBAR, *LPNMREBAR;
typedef struct tagLVGROUPMETRICS {
	UINT cbSize;
	UINT mask;
	UINT Left;
	UINT Top;
	UINT Right;
	UINT Bottom;
	COLORREF crLeft;
	COLORREF crTop;
	COLORREF crRight;
	COLORREF crBottom;
	COLORREF crHeader;
	COLORREF crFooter;
} LVGROUPMETRICS, *PLVGROUPMETRICS;
typedef struct tagLVGROUP {
	UINT cbSize;
	UINT mask;
	LPWSTR pszHeader;
	int cchHeader;
	LPWSTR pszFooter;
	int cchFooter;
	int iGroupId;
	UINT stateMask;
	UINT state;
	UINT uAlign;
} LVGROUP, *PLVGROUP;
typedef int (CALLBACK *PFNLVGROUPCOMPARE)(int, int, void *);
typedef struct tagLVINSERTGROUPSORTED {
	PFNLVGROUPCOMPARE pfnGroupCompare;
	void *pvData;
	LVGROUP lvGroup;
}LVINSERTGROUPSORTED, *PLVINSERTGROUPSORTED;
typedef struct tagLVTILEVIEWINFO {
	UINT cbSize;
	DWORD dwMask;
	DWORD dwFlags;
	SIZE sizeTile;
	int cLines;
	RECT rcLabelMargin;
} LVTILEVIEWINFO, *PLVTILEVIEWINFO;
typedef struct {
	UINT cbSize;
	DWORD dwFlags;
	int iItem;
	DWORD dwReserved;
} LVINSERTMARK, * LPLVINSERTMARK;
typedef struct tagLVSETINFOTIP {
	UINT cbSize;
	DWORD dwFlags;
	LPWSTR pszText;
	int iItem;
	int iSubItem;
} LVSETINFOTIP, *PLVSETINFOTIP;
typedef struct {
	HIMAGELIST himl;
	RECT margin;
	UINT uAlign;
} BUTTON_IMAGELIST, *PBUTTON_IMAGELIST;
typedef struct tagNMBCHOTITEM {
	NMHDR hdr;
	DWORD dwFlags;
} NMBCHOTITEM, *LPNMBCHOTITEM;
typedef struct _tagEDITBALLOONTIP {
	DWORD  cbStruct;
	LPCWSTR pszTitle;
	LPCWSTR pszText;
	INT   ttiIcon;
} EDITBALLOONTIP, *PEDITBALLOONTIP;
typedef struct tagNMHDFILTERBTNCLICK {
	NMHDR hdr;
	INT iItem;
	RECT rc;
} NMHDFILTERBTNCLICK, *LPNMHDFILTERBTNCLICK;
typedef struct tagNMRBAUTOSIZE {
	NMHDR hdr;
	BOOL fChanged;
	RECT rcTarget;
	RECT rcActual;
} NMRBAUTOSIZE, *LPNMRBAUTOSIZE;
typedef struct tagNMREBARCHEVRON {
	NMHDR hdr;
	UINT uBand;
	UINT wID;
	LPARAM lParam;
	RECT rc;
	LPARAM lParamNM;
} NMREBARCHEVRON, *LPNMREBARCHEVRON;
typedef struct tagNMREBARAUTOBREAK {
	NMHDR hdr;
	UINT uBand;
	UINT wID;
	LPARAM lParam;
	UINT uMsg;
	UINT fStyleCurrent;
	BOOL fAutoBreak;
} NMREBARAUTOBREAK, *LPNMREBARAUTOBREAK;
typedef struct _RB_HITTESTINFO {
	POINT pt;
	UINT flags;
	int iBand;
} RBHITTESTINFO, *LPRBHITTESTINFO;
typedef struct _TTGETTITLE {
	DWORD dwSize;
	UINT uTitleBitmap;
	UINT cch;
	WCHAR* pszTitle;
} TTGETTITLE, *PTTGETTITLE;
typedef struct _DRAWPATRECT {
	POINT ptPosition;
	POINT ptSize;
	WORD wStyle;
	WORD wPattern;
} DRAWPATRECT, *PDRAWPATRECT;
typedef struct _PSINJECTDATA {
	DWORD	DataBytes;
	WORD	InjectionPoint;
	WORD   PageNumber;
} PSINJECTDATA, *PPSINJECTDATA;
typedef struct _PSFEATURE_OUTPUT {
	BOOL bPageIndependent;
	BOOL bSetPageDevice;
} PSFEATURE_OUTPUT, *PPSFEATURE_OUTPUT;
typedef struct _PSFEATURE_CUSTPAPER {
	LONG lOrientation;
	LONG lWidth;
	LONG lHeight;
	LONG lWidthOffset;
	LONG lHeightOffset;
} PSFEATURE_CUSTPAPER, *PPSFEATURE_CUSTPAPER;
typedef struct tagWCRANGE {
	WCHAR wcLow;
	USHORT cGlyphs;
} WCRANGE, *PWCRANGE,*LPWCRANGE;
typedef struct tagGLYPHSET {
	DWORD   cbThis;
	DWORD   flAccel;
	DWORD   cGlyphsSupported;
	DWORD   cRanges;
	WCRANGE ranges[1];
} GLYPHSET, *PGLYPHSET, *LPGLYPHSET;
typedef struct _WGLSWAP {
	HDC hdc;
	UINT uiFlags;
} WGLSWAP, *PWGLSWAP, *LPWGLSWAP;
typedef struct tagLITEM {
	UINT	mask ;
	int	iLink ;
	UINT	state ;
	UINT	stateMask ;
	WCHAR	szID[MAX_LINKID_TEXT] ;
	WCHAR	szUrl[L_MAX_URL_LENGTH] ;
} LITEM, * PLITEM ;
typedef struct tagNMLINK {
	NMHDR hdr;
	LITEM item ;
} NMLINK, *PNMLINK;
typedef struct tagUPDATELAYEREDWINDOWINFO {
	DWORD	cbSize;
	HDC	hdcDst;
	POINT	*pptDst;
	SIZE	*psize;
	HDC	hdcSrc;
	POINT	*pptSrc;
	COLORREF	crKey;
	BLENDFUNCTION	 *pblend;
	DWORD	dwFlags;
	RECT	*prcDirty;
} UPDATELAYEREDWINDOWINFO, *PUPDATELAYEREDWINDOWINFO;
typedef struct tagLASTINPUTINFO { UINT cbSize; DWORD dwTime; } LASTINPUTINFO,*PLASTINPUTINFO;
/* Functions.h Declarations for all the WIN32 Functions */
BOOL WINAPI GetLastInputInfo(PLASTINPUTINFO);
DWORD WINAPI GetClipboardSequenceNumber(void);
BOOL WINAPI UpdateLayeredWindow(HWND,HDC,POINT *,SIZE *,HDC,POINT *,COLORREF,BLENDFUNCTION *,DWORD);
UINT WINAPI GetEnhMetaFilePixelFormat(HENHMETAFILE,UINT,PIXELFORMATDESCRIPTOR *);
BOOL WINAPI ColorCorrectPalette(HDC,HPALETTE,DWORD,DWORD);
DWORD WINAPI ReadEncryptedFileRaw(PFE_EXPORT_FUNC,PVOID,PVOID);
DWORD WINAPI WriteEncryptedFileRaw(PFE_IMPORT_FUNC,PVOID,PVOID);
VOID WINAPI CloseEncryptedFileRaw(PVOID);
BOOLEAN WINAPI Wow64EnableWow64FsRedirection(BOOLEAN);
BOOL WINAPI FileEncryptionStatusA(LPCSTR,LPDWORD);
BOOL WINAPI FileEncryptionStatusW(LPCWSTR,LPDWORD);
BOOL WINAPI AddAuditAccessAceEx(PACL,DWORD,DWORD,DWORD,PSID,BOOL,BOOL);
BOOL WINAPI AddAccessDeniedObjectAce(PACL,DWORD,DWORD,DWORD,GUID *,GUID *,PSID);
BOOL WINAPI AddAuditAccessObjectAce(PACL,DWORD,DWORD,DWORD,GUID *,GUID *,PSID,BOOL,BOOL);
BOOL WINAPI ZombifyActCtx(HANDLE);
HANDLE WINAPI CreateActCtxA(PCACTCTXA);
HANDLE WINAPI CreateActCtxW(PCACTCTXW);
VOID WINAPI AddRefActCtx(HANDLE);
VOID WINAPI ReleaseActCtx(HANDLE);
BOOL WINAPI ActivateActCtx(HANDLE,ULONG_PTR *);
BOOL WINAPI DeactivateActCtx(DWORD,ULONG_PTR);
BOOL WINAPI GetCurrentActCtx(HANDLE *);
BOOL WINAPI SetThreadStackGuarantee(PULONG);
BOOL WINAPI SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR,SECURITY_DESCRIPTOR_CONTROL,SECURITY_DESCRIPTOR_CONTROL);
BOOL WINAPI SetPrivateObjectSecurityEx(SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR *,ULONG,PGENERIC_MAPPING,HANDLE);
BOOL WINAPI MakeAbsoluteSD2(PSECURITY_DESCRIPTOR,LPDWORD);
BOOL WINAPI TzSpecificLocalTimeToSystemTime(LPTIME_ZONE_INFORMATION,LPSYSTEMTIME,LPSYSTEMTIME);
BOOL WINAPI IsTokenRestricted(HANDLE);
DWORD WINAPI GetThreadId(HANDLE);
BOOL WINAPI GetThreadIOPendingFlag(HANDLE,PBOOL);
LPVOID WINAPI CreateFiberEx(SIZE_T,SIZE_T,DWORD,LPFIBER_START_ROUTINE,LPVOID);
LPVOID WINAPI ConvertThreadToFiberEx(LPVOID,DWORD);
BOOL WINAPI ConvertFiberToThread(VOID);
BOOL WINAPI IsWellKnownSid (PSID, WELL_KNOWN_SID_TYPE);
HANDLE WINAPI CreateMemoryResourceNotification(MEMORY_RESOURCE_NOTIFICATION_TYPE);
BOOL WINAPI QueryMemoryResourceNotification(HANDLE,PBOOL);
DWORD WINAPI OpenEncryptedFileRawA(LPCSTR,ULONG,PVOID *);
DWORD WINAPI OpenEncryptedFileRawW(LPCWSTR,ULONG,PVOID *);
BOOL WINAPI IsTokenUntrusted(HANDLE);
BOOL APIENTRY CheckTokenMembership(HANDLE,PSID,PBOOL);
BOOL WINAPI NeedCurrentDirectoryForExePathA(LPCSTR);
BOOL WINAPI NeedCurrentDirectoryForExePathW(LPCWSTR);
HANDLE WINAPI OpenWaitableTimerA(DWORD,BOOL,LPCSTR);
HANDLE WINAPI OpenWaitableTimerW(DWORD,BOOL,LPCWSTR);
BOOL WINAPI SetFirmwareEnvironmentVariableA(LPCSTR,LPCSTR,PVOID,DWORD);
BOOL WINAPI SetFirmwareEnvironmentVariableW(LPCWSTR,LPCWSTR,PVOID,DWORD);
DWORD WINAPI GetFirmwareEnvironmentVariableA(LPCSTR,LPCSTR,PVOID,DWORD);
DWORD WINAPI GetFirmwareEnvironmentVariableW(LPCWSTR,LPCWSTR,PVOID,DWORD);
BOOL WINAPI GetWindowsAccountDomainSid(PSID,PSID,DWORD *);
BOOL WINAPI EqualDomainSid(PSID,PSID,BOOL *);
BOOL WINAPI CreatePrivateObjectSecurityEx(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR,
	PSECURITY_DESCRIPTOR *,GUID *,BOOL,ULONG,HANDLE,PGENERIC_MAPPING);
BOOL WINAPI CreatePrivateObjectSecurityWithMultipleInheritance(PSECURITY_DESCRIPTOR,
	PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR *,GUID **,ULONG,BOOL,ULONG,
	HANDLE,PGENERIC_MAPPING);
BOOL WINAPI CreateWellKnownSid(WELL_KNOWN_SID_TYPE,PSID,PSID,DWORD *);
BOOL WINAPI AccessCheckByTypeResultListAndAuditAlarmByHandleA(LPCSTR,LPVOID,HANDLE,LPCSTR,
	LPCSTR,PSECURITY_DESCRIPTOR,PSID,DWORD,AUDIT_EVENT_TYPE,DWORD,POBJECT_TYPE_LIST,
	DWORD,PGENERIC_MAPPING,BOOL,LPDWORD,LPDWORD,LPBOOL);
BOOL WINAPI AccessCheckByTypeResultListAndAuditAlarmByHandleW(LPCWSTR,LPVOID,HANDLE,LPCWSTR,
	LPCWSTR,PSECURITY_DESCRIPTOR,PSID,DWORD,AUDIT_EVENT_TYPE,DWORD,POBJECT_TYPE_LIST,
	DWORD,PGENERIC_MAPPING,BOOL,LPDWORD,LPDWORD,LPBOOL);
BOOL WINAPI AccessCheckByTypeResultListAndAuditAlarmA(LPCSTR,LPVOID,LPCSTR,LPCSTR,
	PSECURITY_DESCRIPTOR,PSID,DWORD,AUDIT_EVENT_TYPE,DWORD,POBJECT_TYPE_LIST,
	DWORD,PGENERIC_MAPPING,BOOL,LPDWORD,LPDWORD,LPBOOL);
BOOL WINAPI AccessCheckByTypeResultListAndAuditAlarmW(LPCWSTR,LPVOID,LPCWSTR,LPCWSTR,
	PSECURITY_DESCRIPTOR,PSID,DWORD,AUDIT_EVENT_TYPE,DWORD,POBJECT_TYPE_LIST,
	DWORD,PGENERIC_MAPPING,BOOL,LPDWORD,LPDWORD,LPBOOL);
BOOL WINAPI CheckNameLegalDOS8Dot3A(LPCSTR,LPSTR,DWORD,PBOOL,PBOOL);
BOOL WINAPI CheckNameLegalDOS8Dot3W(LPCWSTR,LPSTR,DWORD,PBOOL,PBOOL);
DWORD WINAPI GetDllDirectoryA(DWORD,LPSTR);
DWORD WINAPI GetDllDirectoryW(DWORD,LPWSTR);
BOOL WINAPI SetDllDirectoryA(LPCSTR);
BOOL WINAPI SetDllDirectoryW(LPCWSTR);
BOOL WINAPI DnsHostnameToComputerNameA(LPCSTR,LPSTR,LPDWORD);
BOOL WINAPI DnsHostnameToComputerNameW(LPCWSTR,LPWSTR,LPDWORD);
UINT WINAPI GetWriteWatch(DWORD,PVOID,SIZE_T,PVOID *,PULONG_PTR,PULONG);
UINT WINAPI ResetWriteWatch(LPVOID,SIZE_T);
SIZE_T WINAPI GetLargePageMinimum(void);
BOOL WINAPI HeapSetInformation(HANDLE,HEAP_INFORMATION_CLASS,PVOID,SIZE_T);
BOOL WINAPI HeapQueryInformation(HANDLE,HEAP_INFORMATION_CLASS,PVOID,SIZE_T,PSIZE_T);
DWORD WINAPI GetFreeSpace(UINT);
BOOL WINAPI AccessCheckByType(PSECURITY_DESCRIPTOR,PSID,HANDLE,DWORD,POBJECT_TYPE_LIST,DWORD,PGENERIC_MAPPING,PPRIVILEGE_SET,LPDWORD,LPDWORD,LPBOOL);
BOOL WINAPI AccessCheckByTypeResultList (PSECURITY_DESCRIPTOR,PSID,HANDLE,DWORD,POBJECT_TYPE_LIST,DWORD,PGENERIC_MAPPING,PPRIVILEGE_SET,LPDWORD,LPDWORD,LPDWORD);
BOOL WINAPI AccessCheckByTypeAndAuditAlarmA(LPCSTR,LPVOID,LPCSTR,LPCSTR,PSECURITY_DESCRIPTOR,
	PSID,DWORD,AUDIT_EVENT_TYPE,DWORD,POBJECT_TYPE_LIST,DWORD,PGENERIC_MAPPING,
	BOOL,LPDWORD,LPBOOL,LPBOOL);
BOOL WINAPI AccessCheckByTypeAndAuditAlarmW(LPCWSTR,LPVOID,LPCWSTR,LPCWSTR,PSECURITY_DESCRIPTOR,
	PSID,DWORD,AUDIT_EVENT_TYPE,DWORD,POBJECT_TYPE_LIST,DWORD,PGENERIC_MAPPING,
	BOOL,LPDWORD,LPBOOL,LPBOOL);
BOOL WINAPI AccessCheckAndAuditAlarmA(LPCSTR,LPVOID,LPSTR,LPSTR,PSECURITY_DESCRIPTOR,DWORD,PGENERIC_MAPPING,BOOL,LPDWORD,LPBOOL,LPBOOL);
BOOL WINAPI AccessCheckAndAuditAlarmW(LPCWSTR,LPVOID,LPWSTR,LPWSTR,PSECURITY_DESCRIPTOR,DWORD,PGENERIC_MAPPING,BOOL,LPDWORD,LPBOOL,LPBOOL);
HANDLE WINAPI FindFirstStreamW(LPCWSTR,STREAM_INFO_LEVELS,LPVOID,DWORD);
BOOL APIENTRY FindNextStreamW(HANDLE,LPVOID);
PVOID WINAPI AddVectoredContinueHandler (ULONG,PVECTORED_EXCEPTION_HANDLER);
ULONG WINAPI RemoveVectoredContinueHandler (PVOID);
BOOL WINAPI UnregisterWaitEx(HANDLE,HANDLE);
BOOL WINAPI DeleteTimerQueueTimer(HANDLE,HANDLE,HANDLE);
BOOL WINAPI VerifyVersionInfoA(LPOSVERSIONINFOEXA,DWORD,DWORDLONG);
BOOL WINAPI VerifyVersionInfoW(LPOSVERSIONINFOEXW,DWORD,DWORDLONG);
BOOL WINAPI GetEventLogInformation (HANDLE,DWORD,LPVOID,DWORD,LPDWORD);
BOOL WINAPI GetLongPathNameW(LPCWSTR,LPWSTR,DWORD);
UINT GetRawInputDeviceInfoA(HANDLE,UINT,LPVOID,PUINT);
UINT GetRawInputDeviceInfoW(HANDLE,UINT,LPVOID,PUINT);
UINT WINAPI GetRegisteredRawInputDevices(PRAWINPUTDEVICE,PUINT,UINT);
UINT WINAPI GetRawInputDeviceList(PRAWINPUTDEVICELIST,PUINT,UINT);
LRESULT WINAPI DefRawInputProc(PRAWINPUT*,INT,UINT);
BOOL WINAPI ReplaceFileA(LPCSTR,LPCSTR,LPCSTR,DWORD,LPVOID,LPVOID);
BOOL WINAPI ReplaceFileW(LPCWSTR,LPCWSTR,LPCWSTR,DWORD,LPVOID,LPVOID);
HANDLE WINAPI ReOpenFile(HANDLE,DWORD,DWORD,DWORD);
#ifdef UNICODE
#define FileEncryptionStatus FileEncryptionStatusW
#define CreateActCtx CreateActCtxW
#define OpenEncryptedFileRaw OpenEncryptedFileRawW
#define NeedCurrentDirectoryForExePath NeedCurrentDirectoryForExePathW
#define OpenWaitableTimer OpenWaitableTimerW
#define SetFirmwareEnvironmentVariable SetFirmwareEnvironmentVariableW
#define GetFirmwareEnvironmentVariable GetFirmwareEnvironmentVariableW
#define AccessCheckByTypeResultListAndAuditAlarmByHandle AccessCheckByTypeResultListAndAuditAlarmByHandleW
#define AccessCheckByTypeResultListAndAuditAlarm AccessCheckByTypeResultListAndAuditAlarmW
#define AccessCheckByTypeAndAuditAlarm AccessCheckByTypeAndAuditAlarmW
#define CheckNameLegalDOS8Dot3 CheckNameLegalDOS8Dot3W
#define GetDllDirectory GetDllDirectoryW
#define SetDllDirectory SetDllDirectoryW
#define DnsHostnameToComputerName DnsHostnameToComputerNameW
typedef PWIN32_FIND_DATAW PWIN32_FIND_DATA;
typedef LPWIN32_FIND_DATAW LPWIN32_FIND_DATA;
#define ReplaceFile ReplaceFileW
#define AccessCheckAndAuditAlarm AccessCheckAndAuditAlarmW
#define VerifyVersionInfo VerifyVersionInfoW
#define GetRawInputDeviceInfo GetRawInputDeviceInfoW
#define FindActCtxSectionString FindActCtxSectionStringW
#else
#define FileEncryptionStatus FileEncryptionStatusA
#define CreateActCtx CreateActCtxA
#define OpenEncryptedFileRaw OpenEncryptedFileRawA
#define NeedCurrentDirectoryForExePath NeedCurrentDirectoryForExePathA
#define OpenWaitableTimer OpenWaitableTimerA
#define SetFirmwareEnvironmentVariable SetFirmwareEnvironmentVariableA
#define GetFirmwareEnvironmentVariable GetFirmwareEnvironmentVariableA
#define AccessCheckByTypeResultListAndAuditAlarmByHandle AccessCheckByTypeResultListAndAuditAlarmByHandleA
#define AccessCheckByTypeResultListAndAuditAlarm AccessCheckByTypeResultListAndAuditAlarmA
#define AccessCheckByTypeAndAuditAlarm AccessCheckByTypeAndAuditAlarmA
#define CheckNameLegalDOS8Dot3 CheckNameLegalDOS8Dot3A
#define GetDllDirectory GetDllDirectoryA
#define SetDllDirectory SetDllDirectoryA
#define DnsHostnameToComputerName DnsHostnameToComputerNameA
typedef PWIN32_FIND_DATAA PWIN32_FIND_DATA;
typedef LPWIN32_FIND_DATAA LPWIN32_FIND_DATA;
#define ReplaceFile ReplaceFileA
#define GetRawInputDeviceInfo GetRawInputDeviceInfoA
#define FindActCtxSectionString FindActCtxSectionStringA
#define VerifyVersionInfo VerifyVersionInfoA
#define AccessCheckAndAuditAlarm AccessCheckAndAuditAlarmA
#endif
BOOL WINAPI FindActCtxSectionStringA(DWORD,const GUID *,ULONG,LPCSTR,PACTCTX_SECTION_KEYED_DATA);
BOOL WINAPI FindActCtxSectionStringW(DWORD,const GUID *,ULONG,LPCWSTR,PACTCTX_SECTION_KEYED_DATA);
BOOL WINAPI FindActCtxSectionGuid(DWORD,const GUID *,ULONG,const GUID *,PACTCTX_SECTION_KEYED_DATA);
UINT WINAPI GetRawInputBuffer(PRAWINPUT,PUINT,UINT);
UINT GetRawInputData(HRAWINPUT,UINT,LPVOID,PUINT,UINT);
void RtlZeroMemory(void *,unsigned int);
BOOL GetBinaryTypeW(LPCWSTR,LPDWORD);
DWORD GetShortPathNameW(LPCWSTR,LPWSTR,DWORD);
LPWSTR GetEnvironmentStringsW(VOID);
BOOL FreeEnvironmentStringsW(LPWSTR);
DWORD FormatMessageW(DWORD,LPCVOID,DWORD,DWORD,LPWSTR,DWORD,va_list *);
HANDLE CreateMailslotW(LPCWSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
int lstrcmpW(LPCWSTR,LPCWSTR);
int lstrcmpiW( LPCWSTR,LPCWSTR);
LPWSTR lstrcpynW(LPWSTR,LPCWSTR,int);
LPWSTR lstrcpyW(LPWSTR,LPCWSTR);
LPWSTR lstrcatW(LPWSTR,LPCWSTR);
int lstrlenW(LPCWSTR);
HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES,BOOL,LPCWSTR);
HANDLE OpenMutexW(DWORD,BOOL,LPCWSTR);
HANDLE CreateEventW(LPSECURITY_ATTRIBUTES,BOOL,BOOL,LPCWSTR);
HANDLE OpenEventW(DWORD,BOOL,LPCWSTR);
HANDLE CreateSemaphoreW(LPSECURITY_ATTRIBUTES,LONG,LONG,LPCWSTR);
HANDLE OpenSemaphoreW(DWORD,BOOL,LPCWSTR);
HANDLE CreateFileMappingW(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,DWORD,DWORD,LPCWSTR);
HANDLE OpenFileMappingW(DWORD,BOOL,LPCWSTR);
DWORD GetLogicalDriveStringsW(DWORD,LPWSTR);
HINSTANCE LoadLibraryW(LPCWSTR);
HINSTANCE LoadLibraryExW(LPCWSTR,HANDLE,DWORD);
DWORD GetModuleFileNameW(HINSTANCE,LPWSTR,DWORD);
HMODULE GetModuleHandleW(LPCWSTR);
BOOL WINAPI GetModuleHandleExA(DWORD,LPCSTR,HMODULE*);
BOOL WINAPI GetModuleHandleExW(DWORD,LPCWSTR,HMODULE*);
VOID FatalAppExitW(UINT,LPCWSTR);
LPWSTR GetCommandLineW(VOID);
DWORD GetEnvironmentVariableW(LPCWSTR,LPWSTR,DWORD);
BOOL SetEnvironmentVariableW(LPCWSTR,LPCWSTR);
DWORD ExpandEnvironmentStringsW(LPCWSTR,LPWSTR,DWORD);
VOID OutputDebugStringW(LPCWSTR);
HRSRC FindResourceW(HINSTANCE,LPCWSTR,LPCWSTR);
HRSRC FindResourceExW(HINSTANCE,LPCWSTR,LPCWSTR,WORD);
BOOL EnumResourceTypesW(HINSTANCE,ENUMRESTYPEPROC,LONG);
BOOL EnumResourceNamesW(HINSTANCE,LPCWSTR,ENUMRESNAMEPROC,LONG);
BOOL EnumResourceLanguagesW(HINSTANCE,LPCWSTR,LPCWSTR,ENUMRESLANGPROC,LONG);
HANDLE BeginUpdateResourceW(LPCWSTR,BOOL);
BOOL UpdateResourceW(HANDLE,LPCWSTR,LPCWSTR,WORD,LPVOID,DWORD);
BOOL EndUpdateResourceW(HANDLE,BOOL);
ATOM GlobalAddAtomW( LPCWSTR);
ATOM GlobalFindAtomW( LPCWSTR);
UINT GlobalGetAtomNameW(ATOM,LPWSTR,int);
ATOM AddAtomW(LPCWSTR);
ATOM FindAtomW(LPCWSTR);
UINT GetAtomNameW(ATOM,LPWSTR,int);
UINT GetProfileIntW(LPCWSTR,LPCWSTR,INT);
DWORD GetProfileStringW(LPCWSTR,LPCWSTR,LPCWSTR,LPWSTR,DWORD);
BOOL WriteProfileStringW(LPCWSTR,LPCWSTR,LPCWSTR);
DWORD GetProfileSectionW(LPCWSTR,LPWSTR,DWORD);
BOOL WriteProfileSectionW(LPCWSTR,LPCWSTR);
UINT GetPrivateProfileIntW(LPCWSTR,LPCWSTR,INT,LPCWSTR);
BOOL WINAPI GetPrivateProfileStructA(LPCSTR,LPCSTR,LPVOID,UINT,LPCSTR);
BOOL WINAPI GetPrivateProfileStructW(LPCWSTR,LPCWSTR,LPVOID,UINT,LPCWSTR);
DWORD GetPrivateProfileStringW(LPCWSTR,LPCWSTR,LPCWSTR,LPWSTR,DWORD,LPCWSTR);
BOOL WritePrivateProfileStringW(LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR);
BOOL WINAPI WritePrivateProfileStructA(LPCSTR,LPCSTR,LPVOID,UINT,LPCSTR);
BOOL WINAPI WritePrivateProfileStructW(LPCWSTR,LPCWSTR,LPVOID,UINT,LPCWSTR);
DWORD GetPrivateProfileSectionW(LPCWSTR,LPWSTR,DWORD,LPCWSTR);
DWORD WINAPI GetPrivateProfileSectionNamesA(LPSTR,DWORD,LPCSTR);
DWORD WINAPI GetPrivateProfileSectionNamesW(LPWSTR,DWORD,LPCWSTR);
BOOL WritePrivateProfileSectionW(LPCWSTR,LPCWSTR,LPCWSTR);
UINT GetDriveTypeW(LPCWSTR);
UINT GetSystemDirectoryW(LPWSTR,UINT);
DWORD GetTempPathW(DWORD,LPWSTR);
UINT GetTempFileNameW(LPCWSTR,LPCWSTR,UINT,LPWSTR);
UINT WINAPI GetWindowModuleFileNameA(HWND,LPSTR,UINT);
UINT WINAPI GetWindowModuleFileNameW(HWND,LPWSTR,UINT);
UINT WINAPI GetWindowsDirectoryW(LPWSTR,UINT);
UINT WINAPI GetSystemWindowsDirectoryA(LPSTR,UINT);
UINT WINAPI GetSystemWindowsDirectoryW(LPWSTR,UINT);
BOOL WINAPI GetWindowInfo(HWND,PWINDOWINFO);
DWORD WINAPI GetListBoxInfo(HWND);
BOOL WINAPI GetScrollBarInfo(HWND,LONG,PSCROLLBARINFO);
BOOL WINAPI GetCursorInfo(PCURSORINFO);
BOOL WINAPI GetTitleBarInfo(HWND,PTITLEBARINFO);
BOOL SetCurrentDirectoryW(LPCWSTR);
DWORD GetCurrentDirectoryW(DWORD,LPWSTR);
BOOL WINAPI GetCurrentHwProfileA(LPHW_PROFILE_INFOA);
BOOL WINAPI GetCurrentHwProfileW(LPHW_PROFILE_INFOW);
BOOL GetDiskFreeSpaceW(LPCWSTR,LPDWORD,LPDWORD,LPDWORD,LPDWORD);
BOOL WINAPI GetDiskFreeSpaceExW(LPCWSTR,long long *,long long *,long long *);
BOOL CreateDirectoryW(LPCWSTR,LPSECURITY_ATTRIBUTES);
BOOL CreateDirectoryExW(LPCWSTR,LPCWSTR,LPSECURITY_ATTRIBUTES);
BOOL RemoveDirectoryW(LPCWSTR);
DWORD GetFullPathNameW(LPCWSTR,DWORD,LPWSTR,LPWSTR *);
BOOL DefineDosDeviceW(DWORD,LPCWSTR,LPCWSTR);
DWORD QueryDosDeviceW(LPCWSTR,LPWSTR,DWORD);
HANDLE CreateFileW(LPCWSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE);
BOOL SetFileAttributesW(LPCWSTR,DWORD);
DWORD GetFileAttributesW(LPCWSTR);
BOOL WINAPI GetFileAttributesExA(LPCSTR,GET_FILEEX_INFO_LEVELS,LPVOID);
BOOL WINAPI GetFileAttributesExW(LPCWSTR,GET_FILEEX_INFO_LEVELS,LPVOID);
DWORD GetCompressedFileSizeW(LPCWSTR,LPDWORD);
BOOL DeleteFileW(LPCWSTR);
DWORD SearchPathW(LPCWSTR,LPCWSTR,LPCWSTR,DWORD,LPWSTR,LPWSTR *);
BOOL CopyFileW(LPCWSTR,LPCWSTR,BOOL);
BOOL WINAPI CopyFileExW(LPCWSTR,LPCWSTR,LPPROGRESS_ROUTINE,LPVOID,LPBOOL,DWORD);
BOOL WINAPI CreateHardLinkW(LPCWSTR,LPCWSTR,LPSECURITY_ATTRIBUTES);
BOOL MoveFileW(LPCWSTR,LPCWSTR);
BOOL MoveFileExW(LPCWSTR,LPCWSTR,DWORD);
BOOL WINAPI MoveFileWithProgressW(LPCWSTR,LPCWSTR,LPPROGRESS_ROUTINE,LPVOID,DWORD);
HANDLE CreateNamedPipeW(LPCWSTR,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
BOOL GetNamedPipeHandleStateW(HANDLE,LPDWORD,LPDWORD,LPDWORD,LPDWORD,LPWSTR,DWORD);
BOOL CallNamedPipeW(LPCWSTR,LPVOID,DWORD,LPVOID,DWORD,LPDWORD,DWORD);
BOOL WaitNamedPipeW(LPCWSTR,DWORD);
BOOL SetVolumeLabelW(LPCWSTR,LPCWSTR);
BOOL GetVolumeInformationW(LPCWSTR,LPWSTR,DWORD,LPDWORD,LPDWORD,LPDWORD,LPWSTR,DWORD);
BOOL WINAPI CancelIo(HANDLE);
BOOL ClearEventLogW(HANDLE,LPCWSTR);
BOOL BackupEventLogW(HANDLE,LPCWSTR);
HANDLE OpenEventLogW(LPCWSTR,LPCWSTR);
HANDLE RegisterEventSourceW(LPCWSTR,LPCWSTR);
HANDLE OpenBackupEventLogW(LPCWSTR,LPCWSTR);
BOOL ReadEventLogW(HANDLE,DWORD,DWORD,LPVOID,DWORD,DWORD *,DWORD *);
BOOL ReportEventW(HANDLE,WORD,WORD,DWORD,PSID,WORD,DWORD,LPCWSTR *,LPVOID);
BOOL AccessCheckAndAuditAlarmW(LPCWSTR,LPVOID HandleId,LPWSTR,LPWSTR,PSECURITY_DESCRIPTOR,DWORD,PGENERIC_MAPPING,BOOL,LPDWORD,LPBOOL,LPBOOL);
BOOL ObjectOpenAuditAlarmW(LPCWSTR,LPVOID,LPWSTR,LPWSTR,PSECURITY_DESCRIPTOR,HANDLE,DWORD,DWORD,PPRIVILEGE_SET,BOOL,BOOL,LPBOOL);
BOOL ObjectPrivilegeAuditAlarmW(LPCWSTR,LPVOID,HANDLE,DWORD,PPRIVILEGE_SET,BOOL);
BOOL ObjectCloseAuditAlarmW(LPCWSTR,LPVOID,BOOL);
BOOL WINAPI ObjectDeleteAuditAlarmA(LPCSTR,LPVOID,BOOL);
BOOL WINAPI ObjectDeleteAuditAlarmW(LPCWSTR,LPVOID,BOOL);
DWORD WINAPI GetGuiResources(HANDLE,DWORD);
COLORREF WINAPI SetDCBrushColor(HDC,COLORREF);
COLORREF WINAPI SetDCPenColor(HDC,COLORREF);
DWORD WINAPI SetLayout(HDC,DWORD);
DWORD WINAPI GetLayout(HDC);
BOOL LockWorkStation(void);
BOOL WINAPI UserHandleGrantAccess(HANDLE,HANDLE,BOOL);
HANDLE WINAPI AddFontMemResourceEx(PVOID,DWORD,PVOID,DWORD*);
BOOL WINAPI RemoveFontMemResourceEx(HANDLE);
#ifdef UNICODE
#define GetModuleHandleEx GetModuleHandleExW
#define GetCurrentHwProfile GetCurrentHwProfileW
#define ObjectDeleteAuditAlarm	ObjectDeleteAuditAlarmW
#define GetComputerNameEx GetComputerNameExW
#define SetComputerNameEx SetComputerNameExW
#define AddFontResourceEx AddFontResourceExW
#define RemoveFontResourceEx RemoveFontResourceExW
#else
#define RemoveFontResourceEx RemoveFontResourceExA
#define AddFontResourceEx AddFontResourceExA
#define GetModuleHandleEx GetModuleHandleExA
#define GetCurrentHwProfile GetCurrentHwProfileA
#define ObjectDeleteAuditAlarm	ObjectDeleteAuditAlarmA
#define GetComputerNameEx GetComputerNameExA
#define SetComputerNameEx SetComputerNameExA
#endif
BOOL PrivilegedServiceAuditAlarmW(LPCWSTR,LPCWSTR,HANDLE,PPRIVILEGE_SET,BOOL);
BOOL SetFileSecurityW(LPCWSTR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR);
BOOL GetFileSecurityW(LPCWSTR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,LPDWORD);
HANDLE FindFirstChangeNotificationW(LPCWSTR,BOOL,DWORD);
BOOL IsBadStringPtrW(LPCWSTR,UINT);
BOOL LookupAccountSidW(LPCWSTR,PSID,LPWSTR,LPDWORD,LPWSTR,LPDWORD,PSID_NAME_USE);
BOOL LookupAccountNameW(LPCWSTR,LPCWSTR,PSID,LPDWORD,LPWSTR,LPDWORD,PSID_NAME_USE);
BOOL LookupPrivilegeValueW(LPCWSTR,LPCWSTR,PLUID);
BOOL LookupPrivilegeNameW(LPCWSTR,PLUID,LPWSTR,LPDWORD);
BOOL LookupPrivilegeDisplayNameW(LPCWSTR,LPCWSTR,LPWSTR,LPDWORD,LPDWORD);
BOOL BuildCommDCBW(LPCWSTR,LPDCB);
BOOL BuildCommDCBAndTimeoutsW(LPCWSTR,LPDCB,LPCOMMTIMEOUTS);
BOOL CommConfigDialogW(LPCWSTR,HWND,LPCOMMCONFIG);
BOOL GetDefaultCommConfigW(LPCWSTR,LPCOMMCONFIG,LPDWORD);
BOOL SetDefaultCommConfigW(LPCWSTR,LPCOMMCONFIG,DWORD);
BOOL GetComputerNameW(LPWSTR,LPDWORD);
BOOL SetComputerNameW(LPCWSTR);
BOOL WINAPI GetComputerNameExA(COMPUTER_NAME_FORMAT,LPSTR,LPDWORD);
BOOL WINAPI GetComputerNameExW(COMPUTER_NAME_FORMAT,LPWSTR,LPDWORD);
BOOL WINAPI SetComputerNameExA(COMPUTER_NAME_FORMAT,LPCSTR);
BOOL WINAPI SetComputerNameExW(COMPUTER_NAME_FORMAT,LPCWSTR);
BOOL GetUserNameW(LPWSTR,LPDWORD);
int wvsprintfW(LPWSTR,LPCWSTR,va_list arglist);
int CDECL wsprintfW(LPWSTR,LPCWSTR,...);
HKL LoadKeyboardLayoutW(LPCWSTR,UINT);
BOOL GetKeyboardLayoutNameW(LPWSTR);
HDESK CreateDesktopW(LPWSTR,LPWSTR,LPDEVMODE,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
HDESK OpenDesktopW(LPWSTR,DWORD,BOOL,DWORD);
BOOL EnumDesktopsW(HWINSTA,DESKTOPENUMPROC,LPARAM);
HWINSTA CreateWindowStationW(LPWSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
HWINSTA OpenWindowStationW(LPWSTR,BOOL,DWORD);
BOOL EnumWindowStationsW(ENUMWINDOWSTATIONPROC,LPARAM);
BOOL GetUserObjectInformationW(HANDLE,int,PVOID,DWORD,LPDWORD);
BOOL SetUserObjectInformationW(HANDLE,int,PVOID,DWORD);
UINT RegisterWindowMessageW(LPCWSTR);
BOOL GetMessageW(LPMSG,HWND,UINT,UINT);
LONG DispatchMessageW(CONST MSG *);
BOOL PeekMessageW(LPMSG,HWND,UINT,UINT,UINT);
LRESULT SendMessageW(HWND,UINT,WPARAM,LPARAM);
LRESULT SendMessageTimeoutW(HWND,UINT,WPARAM,LPARAM,UINT,UINT,LPDWORD);
BOOL SendNotifyMessageW(HWND,UINT,WPARAM,LPARAM);
BOOL SendMessageCallbackW(HWND,UINT,WPARAM,LPARAM,SENDASYNCPROC,DWORD);
BOOL PostMessageW(HWND,UINT,WPARAM,LPARAM);
BOOL PostThreadMessageW(DWORD,UINT,WPARAM,LPARAM);
LRESULT DefWindowProcW(HWND,UINT,WPARAM,LPARAM);
LRESULT CallWindowProcW(WNDPROC,HWND,UINT,WPARAM,LPARAM);
ATOM RegisterClassW(CONST WNDCLASSW *);
BOOL UnregisterClassW(LPCWSTR,HINSTANCE);
BOOL GetClassInfoW(HINSTANCE,LPCWSTR,LPWNDCLASS);
ATOM RegisterClassExW(CONST WNDCLASSEX *);
BOOL GetClassInfoExW(HINSTANCE,LPCWSTR,LPWNDCLASSEX);
HWND CreateWindowExW(DWORD,LPCWSTR,LPCWSTR,DWORD,int,int,int,int,HWND,HMENU,HINSTANCE,LPVOID);
HWND CreateDialogParamW(HINSTANCE,LPCWSTR,HWND,DLGPROC,LPARAM);
HWND CreateDialogIndirectParamW(HINSTANCE,LPCDLGTEMPLATE,HWND,DLGPROC,LPARAM);
int DialogBoxParamW(HINSTANCE,LPCWSTR,HWND,DLGPROC,LPARAM);
int DialogBoxIndirectParamW(HINSTANCE,LPCDLGTEMPLATE,HWND,DLGPROC,LPARAM);
BOOL SetDlgItemTextW(HWND,int,LPCWSTR);
UINT GetDlgItemTextW(HWND,int,LPWSTR,int);
LONG SendDlgItemMessageW(HWND,int,UINT,WPARAM,LPARAM);
LRESULT DefDlgProcW(HWND,UINT,WPARAM,LPARAM);
BOOL CallMsgFilterW(LPMSG,int);
UINT RegisterClipboardFormatW(LPCWSTR);
int GetClipboardFormatNameW(UINT,LPWSTR,int);
BOOL CharToOemW(LPCWSTR,LPSTR);
BOOL OemToCharW(LPCSTR,LPWSTR);
BOOL CharToOemBuffW(LPCWSTR,LPSTR,DWORD);
BOOL OemToCharBuffW(LPCSTR,LPWSTR,DWORD);
LPWSTR CharUpperW(LPWSTR);
DWORD CharUpperBuffW(LPWSTR,DWORD);
LPWSTR CharLowerW(LPWSTR);
DWORD CharLowerBuffW(LPWSTR,DWORD);
LPWSTR CharNextW(LPCWSTR);
LPWSTR CharPrevW(LPCWSTR,LPCWSTR);
BOOL IsCharAlphaW(WCHAR);
BOOL IsCharAlphaNumericW(WCHAR);
BOOL IsCharUpperW(WCHAR);
BOOL IsCharLowerW(WCHAR);
int GetKeyNameTextW(LONG,LPWSTR,int);
UINT WINAPI SendInput(UINT,LPINPUT,int);
SHORT VkKeyScanW(WCHAR);
SHORT VkKeyScanExW(WCHAR,HKL);
UINT MapVirtualKeyW(UINT,UINT);
UINT MapVirtualKeyExW(UINT,UINT,HKL);
HACCEL LoadAcceleratorsW(HINSTANCE,LPCWSTR);
HACCEL CreateAcceleratorTableW(LPACCEL,int);
int CopyAcceleratorTableW(HACCEL,LPACCEL,int);
int TranslateAcceleratorW(HWND,HACCEL,LPMSG);
HMENU LoadMenuW(HINSTANCE,LPCWSTR);
HMENU LoadMenuIndirectW(CONST MENUTEMPLATE *);
BOOL ChangeMenuW(HMENU,UINT,LPCWSTR,UINT,UINT);
int GetMenuStringW(HMENU,UINT,LPWSTR,int,UINT);
BOOL InsertMenuW(HMENU,UINT,UINT,UINT,LPCWSTR);
BOOL AppendMenuW(HMENU,UINT,UINT,LPCWSTR);
BOOL ModifyMenuW(HMENU,UINT,UINT,UINT,LPCWSTR);
BOOL InsertMenuItemW(HMENU,UINT,BOOL,LPCMENUITEMINFO);
BOOL GetMenuItemInfoW(HMENU,UINT,BOOL,LPMENUITEMINFO);
BOOL SetMenuItemInfoW( HMENU,UINT,BOOL,LPCMENUITEMINFO);
int DrawTextW(HDC,LPCWSTR,int,LPRECT,UINT);
int DrawTextExW(HDC,LPWSTR,int,LPRECT,UINT,LPDRAWTEXTPARAMS);
BOOL GrayStringW(HDC,HBRUSH,GRAYSTRINGPROC,LPARAM,int,int,int,int,int);
BOOL DrawStateW(HDC,HBRUSH,DRAWSTATEPROC,LPARAM,WPARAM,int,int,int,int,UINT);
LONG TabbedTextOutW(HDC,int,int,LPCWSTR,int,int,LPINT,int);
DWORD GetTabbedTextExtentW(HDC,LPCWSTR,int,int,LPINT);
BOOL SetPropW(HWND,LPCWSTR,HANDLE);
HANDLE GetPropW(HWND,LPCWSTR);
HANDLE RemovePropW(HWND,LPCWSTR);
int EnumPropsExW(HWND,PROPENUMPROCEX,LPARAM);
int EnumPropsW(HWND,PROPENUMPROC);
BOOL SetWindowTextW(HWND,LPCWSTR);
int GetWindowTextW(HWND,LPWSTR,int);
int GetWindowTextLengthW(HWND);
int MessageBoxW(HWND,LPCWSTR,LPCWSTR,UINT);
int MessageBoxExW(HWND,LPCWSTR,LPCWSTR,UINT,WORD);
int MessageBoxIndirectW(LPMSGBOXPARAMS);
LONG GetWindowLongW(HWND,int);
#define GetWindowLongPtrW	GetWindowLongW
#define GetWindowLongPtrA	GetWindowLongA
LONG SetWindowLongW(HWND,int,LONG);
#define SetWindowLongPtrW	SetWindowLongW
#define SetWindowLongPtrA	SetWindowLongA
#define GetClassLongPtrA	GetWindowLongA
#define GetClassLongPtrW	GetWindowLongW
#define SetClassLongPtrA	SetWindowLongA
#define SetClassLongPtrW	SetWindowLongA
DWORD GetClassLongW(HWND,int);
DWORD SetClassLongW(HWND,int,LONG);
HWND FindWindowW(LPCWSTR,LPCWSTR);
HWND FindWindowExW(HWND,HWND,LPCWSTR,LPCWSTR);
int GetClassNameW(HWND,LPWSTR,int);
HHOOK SetWindowsHookExW(int,HOOKPROC,HINSTANCE,DWORD);
#define DefHookProc(c,p,lp,hh) CallNextHookEx((HHOOK)*hh,c,p,lp)
HBITMAP LoadBitmapW(HINSTANCE,LPCWSTR);
HCURSOR LoadCursorW(HINSTANCE,LPCWSTR);
HCURSOR LoadCursorFromFileW(LPCWSTR);
HICON LoadIconW(HINSTANCE,LPCWSTR);
HANDLE LoadImageW(HINSTANCE,LPCWSTR,UINT,int,int,UINT);
int LoadStringW(HINSTANCE,UINT,LPWSTR,int);
BOOL IsDialogMessageW(HWND,LPMSG);
int DlgDirListW(HWND,LPWSTR,int,int,UINT);
BOOL DlgDirSelectExW(HWND,LPWSTR,int,int);
int DlgDirListComboBoxW(HWND,LPWSTR,int,int,UINT);
BOOL DlgDirSelectComboBoxExW(HWND,LPWSTR,int,int);
LRESULT DefFrameProcW(HWND,HWND,UINT,WPARAM,LPARAM);
LRESULT DefMDIChildProcW(HWND,UINT,WPARAM,LPARAM);
HWND CreateMDIWindowW(LPWSTR,LPWSTR,DWORD,int,int,int,int,HWND,HINSTANCE,LPARAM);
BOOL WinHelpW(HWND,LPCWSTR,UINT,DWORD);
LONG ChangeDisplaySettingsW(LPDEVMODE,DWORD);
LONG WINAPI ChangeDisplaySettingsExW(
   LPCWSTR lpszDeviceName,
   LPDEVMODEW lpDevMode,
   HWND hwnd,
   DWORD dwflags,
   LPVOID lParam);



BOOL EnumDisplaySettingsW(LPCWSTR,DWORD,LPDEVMODE);
BOOL SystemParametersInfoW(UINT,UINT,PVOID,UINT);
int AddFontResourceW(LPCWSTR);
int WINAPI AddFontResourceExA(LPCSTR,DWORD,PVOID);
int WINAPI AddFontResourceExW(LPCWSTR,DWORD,PVOID);
HMETAFILE CopyMetaFileW(HMETAFILE,LPCWSTR);
HFONT CreateFontIndirectW(CONST LOGFONT *);
HFONT CreateFontW(int,int,int,int,int,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPCWSTR);
HDC CreateICW(LPCWSTR,LPCWSTR,LPCWSTR,CONST DEVMODE *);
HDC CreateMetaFileW(LPCWSTR);
BOOL CreateScalableFontResourceW(DWORD,LPCWSTR,LPCWSTR,LPCWSTR);
int DeviceCapabilitiesW(LPCWSTR,LPCWSTR,WORD,LPWSTR,CONST DEVMODE *);
int EnumFontFamiliesExW(HDC,LPLOGFONT,FONTENUMEXPROC,LPARAM,DWORD);
int EnumFontFamiliesW(HDC,LPCWSTR,FONTENUMPROC,LPARAM);
int EnumFontsW(HDC,LPCWSTR,ENUMFONTSPROC,LPARAM);
BOOL GetCharWidthW(HDC,UINT,UINT,LPINT);
BOOL GetCharWidth32W(HDC,UINT,UINT,LPINT);
BOOL GetCharWidthFloatW(HDC,UINT,UINT,PFLOAT);
BOOL GetCharABCWidthsW(HDC,UINT,UINT,LPABC);
BOOL GetCharABCWidthsFloatW(HDC,UINT,UINT,LPABCFLOAT);
DWORD GetGlyphOutlineW(HDC,UINT,UINT,LPGLYPHMETRICS,DWORD,LPVOID,CONST MAT2 *);
HMETAFILE GetMetaFileW(LPCWSTR);
UINT GetOutlineTextMetricsW(HDC,UINT,LPOUTLINETEXTMETRIC);
BOOL GetTextExtentPointW(HDC,LPCWSTR,int,LPSIZE);
BOOL GetTextExtentPoint32W( HDC,LPCWSTR,int,LPSIZE);
BOOL GetTextExtentExPointW( HDC,LPCWSTR,int,int,LPINT,LPINT,LPSIZE );
BOOL WINAPI GetTextExtentPointI(HDC,LPWORD,int,LPSIZE);
BOOL WINAPI GetTextExtentExPointI(HDC,LPWORD,int,int,LPINT,LPINT,LPSIZE);
BOOL WINAPI GetCharWidthI(HDC,UINT,UINT,LPWORD,LPINT);
BOOL WINAPI GetCharABCWidthsI(HDC,UINT,UINT,LPWORD,LPABC);
DWORD GetCharacterPlacementW(HDC,LPCWSTR,int,int,LPGCP_RESULTS,DWORD);
HDC ResetDCW(HDC,CONST DEVMODE *);
BOOL RemoveFontResourceW(LPCWSTR);
BOOL WINAPI RemoveFontResourceExA(LPCSTR,DWORD,PVOID);
BOOL WINAPI RemoveFontResourceExW(LPCWSTR,DWORD,PVOID);
HENHMETAFILE CopyEnhMetaFileW(HENHMETAFILE,LPCWSTR);
HDC CreateEnhMetaFileW(HDC,LPCWSTR,CONST RECT *,LPCWSTR);
HENHMETAFILE GetEnhMetaFileW(LPCWSTR);
UINT GetEnhMetaFileDescriptionW(HENHMETAFILE,UINT,LPWSTR );
BOOL GetTextMetricsW(HDC,LPTEXTMETRICW);
int StartDocW(HDC,CONST DOCINFO *);
int GetObjectW(HGDIOBJ,int,LPVOID);
BOOL TextOutW(HDC,int,int,LPCWSTR,int);
BOOL ExtTextOutW(HDC,int,int,UINT,CONST RECT *,LPCWSTR,UINT,CONST INT *);
BOOL PolyTextOutW(HDC,CONST POLYTEXT *,int);
int GetTextFaceW(HDC,int,LPWSTR);
DWORD GetKerningPairsW(HDC,DWORD,LPKERNINGPAIR);
BOOL GetLogColorSpaceW(HCOLORSPACE,LPLOGCOLORSPACE,DWORD);
HCOLORSPACE CreateColorSpaceW(LPLOGCOLORSPACE);
BOOL GetICMProfileW(HDC,DWORD,LPWSTR);
BOOL SetICMProfileW(HDC,LPWSTR);
BOOL UpdateICMRegKeyW(DWORD,DWORD,LPWSTR,UINT);
int EnumICMProfilesW(HDC,ICMENUMPROC,LPARAM);
HPROPSHEETPAGE CreatePropertySheetPageW(LPCPROPSHEETPAGE);
int PropertySheetW(LPCPROPSHEETHEADER);
HIMAGELIST ImageList_LoadImageW(HINSTANCE,LPCWSTR,int,int,COLORREF,UINT,UINT);
HIMAGELIST WINAPI ImageList_Duplicate(HIMAGELIST);
BOOL WINAPI ImageList_Copy(HIMAGELIST,int,HIMAGELIST,int,UINT);
BOOL WINAPI ImageList_DrawIndirect(IMAGELISTDRAWPARAMS*);
#define	ImageList_LoadBitmap(h,l,x,G,M) ImageList_LoadImage(h,l,x,G,M,IMAGE_BITMAP,0)
#define ImageList_RemoveAll(himl) ImageList_Remove(himl,-1)
#define ImageList_ExtractIcon(hi, himl,i) ImageList_GetIcon(himl,i,0)
HWND CreateStatusWindowW(LONG,LPCWSTR,HWND,UINT);
void DrawStatusTextW(HDC,LPRECT,LPCWSTR,UINT);
BOOL GetOpenFileNameW(LPOPENFILENAME);
BOOL GetSaveFileNameW(LPOPENFILENAME);
short GetFileTitleW(LPCWSTR,LPWSTR,WORD);
BOOL ChooseColorW(LPCHOOSECOLOR);
HWND ReplaceTextW(LPFINDREPLACE);
BOOL ChooseFontW(LPCHOOSEFONT);
HWND FindTextW(LPFINDREPLACE);
BOOL PrintDlgW(LPPRINTDLG);
BOOL PageSetupDlgW(LPPAGESETUPDLG);
BOOL CreateProcessW(LPCWSTR,LPWSTR,LPSECURITY_ATTRIBUTES,LPSECURITY_ATTRIBUTES,BOOL,DWORD,LPVOID,LPCWSTR,LPSTARTUPINFO,LPPROCESS_INFORMATION);
BOOL WINAPI CreateProcessAsUserA(HANDLE,LPCSTR,LPSTR, LPSECURITY_ATTRIBUTES,LPSECURITY_ATTRIBUTES, BOOL,DWORD,LPVOID,LPCSTR, LPSTARTUPINFOA, LPPROCESS_INFORMATION);
BOOL WINAPI CreateProcessAsUserW(HANDLE,LPCWSTR,LPWSTR,LPSECURITY_ATTRIBUTES,LPSECURITY_ATTRIBUTES,BOOL,DWORD,LPVOID,LPCWSTR,LPSTARTUPINFOW,LPPROCESS_INFORMATION);
BOOL WINAPI CreateProcessWithLogonW(LPCWSTR,LPCWSTR,LPCWSTR,DWORD,LPCWSTR,LPWSTR,DWORD,LPVOID,LPCWSTR,LPSTARTUPINFOW,LPPROCESS_INFORMATION);
BOOL APIENTRY ImpersonateAnonymousToken(HANDLE);
VOID GetStartupInfoW(LPSTARTUPINFO);
HANDLE FindFirstFileW(LPCWSTR,LPWIN32_FIND_DATAW);
HANDLE WINAPI FindFirstFileExW(LPCWSTR,FINDEX_INFO_LEVELS,LPVOID,FINDEX_SEARCH_OPS,LPVOID,DWORD);
BOOL FindNextFileW(HANDLE,LPWIN32_FIND_DATA);
BOOL GetVersionExW(LPOSVERSIONINFO);
#define CreateWindowW(Class,Name,Style,x,y,W,H,Parent,Menu,Inst,Param) CreateWindowExW(0,Class,Name,Style,x,y,W,H,Parent,Menu,Inst,Param)
#define CreateDialogW(hI,lpN,hP,Func) CreateDialogParamW(hI,lpN,hP,Func,0)
#define CreateDialogIndirectW(I,T,hP,Func) CreateDialogIndirectParamW(I,T,hP,Func,0)
#define DialogBoxW(Inst,Template,Parent,Func) DialogBoxParamW(Inst,Template,Parent,Func,0)
#define DialogBoxIndirectW(Inst,Template,Parent,Func) DialogBoxIndirectParamW(Inst,Template,Parent,Func,0)
HDC CreateDCW(LPCWSTR,LPCWSTR,LPCWSTR,CONST DEVMODE *);
HFONT CreateFontA(int,int,int,int,int,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPCSTR);
DWORD VerInstallFileW(DWORD,LPWSTR,LPWSTR,LPWSTR,LPWSTR,LPWSTR,LPWSTR,PUINT);
DWORD GetFileVersionInfoSizeW(LPWSTR,LPDWORD);
BOOL GetFileVersionInfoW(LPWSTR,DWORD,DWORD,LPVOID);
DWORD VerLanguageNameW(DWORD,LPWSTR,DWORD);
DWORD VerFindFileW(DWORD,LPWSTR,LPWSTR,LPWSTR,LPWSTR,PUINT,LPWSTR,PUINT);
LONG RegSetValueExW(HKEY,LPCWSTR,DWORD,DWORD,BYTE*,DWORD);
LONG RegUnLoadKeyW(HKEY,LPCWSTR);
BOOL InitiateSystemShutdownW(LPWSTR,LPWSTR,DWORD,BOOL,BOOL);
BOOL AbortSystemShutdownW(LPWSTR);
LONG RegRestoreKeyW(HKEY,LPCWSTR,DWORD);
LONG RegSaveKeyW(HKEY,LPCWSTR,LPSECURITY_ATTRIBUTES);
LONG RegSetValueW(HKEY,LPCWSTR,DWORD,LPCWSTR,DWORD);
LONG RegQueryValueW(HKEY,LPCWSTR,LPWSTR,PLONG);
LONG RegQueryMultipleValuesW(HKEY,PVALENTW,DWORD,LPWSTR,LPDWORD);
LONG RegQueryValueExW(HKEY,LPCWSTR,LPDWORD,LPDWORD,LPBYTE,LPDWORD);
LONG RegReplaceKeyW(HKEY,LPCWSTR,LPCWSTR,LPCWSTR);
LONG RegConnectRegistryW(LPWSTR,HKEY,PHKEY);
LONG RegCreateKeyW(HKEY,LPCWSTR,PHKEY);
LONG RegCreateKeyExW(HKEY,LPCWSTR,DWORD,LPWSTR,DWORD,REGSAM,LPSECURITY_ATTRIBUTES,PHKEY,LPDWORD);
LONG RegDeleteKeyW(HKEY,LPCWSTR);
LONG RegDeleteValueW(HKEY,LPCWSTR);
LONG RegEnumKeyW(HKEY,DWORD,LPWSTR,DWORD);
LONG RegEnumKeyExW(HKEY,DWORD,LPWSTR,LPDWORD,LPDWORD,LPWSTR,LPDWORD,PFILETIME);
LONG RegEnumValueW(HKEY,DWORD,LPWSTR,LPDWORD,LPDWORD,LPDWORD,LPBYTE,LPDWORD);
LONG RegLoadKeyW(HKEY,LPCWSTR,LPCWSTR);
LONG RegOpenKeyW(HKEY,LPCWSTR,PHKEY);
LONG RegOpenKeyExW(HKEY,LPCWSTR,DWORD,REGSAM,PHKEY);
LONG RegQueryInfoKeyW(HKEY,LPWSTR,LPDWORD,LPDWORD,LPDWORD,LPDWORD,LPDWORD,LPDWORD,LPDWORD,LPDWORD,LPDWORD,PFILETIME);
int CompareStringW(LCID,DWORD,LPCWSTR,int,LPCWSTR,int);
int LCMapStringW(LCID,DWORD,LPCWSTR,int,LPWSTR,int);
int GetLocaleInfoW(LCID,LCTYPE,LPWSTR,int);
BOOL SetLocaleInfoW(LCID,LCTYPE,LPCWSTR);
int GetTimeFormatW(LCID,DWORD,CONST SYSTEMTIME *,LPCWSTR,LPWSTR,int);
int GetDateFormatW(LCID,DWORD,CONST SYSTEMTIME *,LPCWSTR,LPWSTR,int);
int GetNumberFormatW(LCID,DWORD,LPCWSTR,CONST NUMBERFMTW *,LPWSTR,int);
int GetCurrencyFormatW(LCID,DWORD,LPCWSTR,CONST CURRENCYFMTW *,LPWSTR,int);
BOOL EnumCalendarInfoW(CALINFO_ENUMPROC,LCID,CALID,CALTYPE);
BOOL EnumTimeFormatsW(TIMEFMT_ENUMPROC,LCID,DWORD);
BOOL EnumDateFormatsW(DATEFMT_ENUMPROC,LCID,DWORD);
BOOL GetStringTypeExW(LCID,DWORD,LPCWSTR,int,LPWORD);
BOOL GetStringTypeW(DWORD,LPCWSTR,int,LPWORD);
int FoldStringW(DWORD,LPCWSTR,int,LPWSTR,int);
BOOL EnumSystemLocalesW(LOCALE_ENUMPROC,DWORD);
BOOL EnumSystemCodePagesW(CODEPAGE_ENUMPROC,DWORD);
BOOL PeekConsoleInputW(HANDLE,PINPUT_RECORD,DWORD,LPDWORD);
BOOL ReadConsoleInputW(HANDLE,PINPUT_RECORD,DWORD,LPDWORD);
BOOL WriteConsoleInputW(HANDLE,CONST INPUT_RECORD *,DWORD,LPDWORD);
BOOL ReadConsoleOutputW(HANDLE,PCHAR_INFO,COORD,COORD,PSMALL_RECT);
BOOL WriteConsoleOutputW(HANDLE,CONST CHAR_INFO *,COORD,COORD,PSMALL_RECT);
BOOL ReadConsoleOutputCharacterW(HANDLE,LPWSTR,DWORD,COORD,LPDWORD);
BOOL WriteConsoleOutputCharacterW(HANDLE,LPCWSTR,DWORD,COORD,LPDWORD);
BOOL FillConsoleOutputCharacterW(HANDLE,WCHAR,DWORD,COORD,LPDWORD);
BOOL ScrollConsoleScreenBufferW(HANDLE,CONST SMALL_RECT *,CONST SMALL_RECT *,COORD,CONST CHAR_INFO *);
DWORD GetConsoleTitleW(LPWSTR,DWORD);
BOOL SetConsoleTitleW(LPCWSTR);
BOOL ReadConsoleW(HANDLE,LPVOID,DWORD,LPDWORD,LPVOID);
BOOL WriteConsoleW(HANDLE,CONST VOID *,DWORD,LPDWORD,LPVOID);
DWORD WNetAddConnectionW(LPCWSTR,LPCWSTR,LPCWSTR);
DWORD WNetAddConnection2W(LPNETRESOURCE,LPCWSTR,LPCWSTR,DWORD);
DWORD WNetAddConnection3W(HWND,LPNETRESOURCE,LPCWSTR,LPCWSTR,DWORD);
DWORD WNetCancelConnectionW(LPCWSTR,BOOL);
DWORD WNetCancelConnection2W(LPCWSTR,DWORD,BOOL);
DWORD WNetGetConnectionW(LPCWSTR,LPWSTR,LPDWORD);
DWORD WNetUseConnectionW(HWND,LPNETRESOURCE,LPCWSTR,LPCWSTR,DWORD,LPWSTR,LPDWORD,LPDWORD);
DWORD WNetSetConnectionW(LPCWSTR,DWORD,LPVOID);
DWORD WNetConnectionDialog1W(LPCONNECTDLGSTRUCT);
DWORD WNetDisconnectDialog1W(LPDISCDLGSTRUCT);
DWORD WNetOpenEnumW(DWORD,DWORD,DWORD,LPNETRESOURCE,LPHANDLE);
DWORD WNetEnumResourceW(HANDLE,LPDWORD,LPVOID,LPDWORD);
DWORD WNetGetUniversalNameW(LPCWSTR,DWORD,LPVOID,LPDWORD);
DWORD WNetGetUserW(LPCWSTR,LPWSTR,LPDWORD);
DWORD WNetGetProviderNameW(DWORD,LPWSTR,LPDWORD);
DWORD WNetGetNetworkInformationW(LPCWSTR,LPNETINFOSTRUCT);
DWORD WNetGetLastErrorW(LPDWORD,LPWSTR,DWORD,LPWSTR,DWORD);
DWORD MultinetGetConnectionPerformanceW(LPNETRESOURCE,LPNETCONNECTINFOSTRUCT);
/* ASCIIFunctions.h Declarations for all the WIN32 ASCII Functions */
DWORD WINAPI GetLongPathNameA(LPCSTR,LPSTR,DWORD);
BOOL GetBinaryTypeA(LPCSTR,LPDWORD);
DWORD GetShortPathNameA(LPCSTR,LPSTR,DWORD);
BOOL FreeEnvironmentStringsA(LPSTR);
DWORD FormatMessageA(DWORD,LPCVOID,DWORD,DWORD,LPSTR,DWORD,va_list *);
HANDLE CreateMailslotA(LPCSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
int lstrcmpA(LPCSTR,LPCSTR);
int lstrcmpiA(LPCSTR,LPCSTR);
LPSTR lstrcpynA(LPSTR,LPCSTR,int);
LPSTR lstrcpyA(LPSTR,LPCSTR);
LPSTR lstrcatA(LPSTR,LPCSTR);
int lstrlenA(LPCSTR);
HANDLE CreateMutexA(LPSECURITY_ATTRIBUTES,BOOL,LPCSTR);
HANDLE OpenMutexA(DWORD,BOOL,LPCSTR);
HANDLE CreateEventA(LPSECURITY_ATTRIBUTES,BOOL,BOOL,LPCSTR);
HANDLE OpenEventA(DWORD,BOOL,LPCSTR);
HANDLE CreateSemaphoreA(LPSECURITY_ATTRIBUTES,LONG,LONG,LPCSTR);
HANDLE OpenSemaphoreA(DWORD,BOOL,LPCSTR);
HANDLE CreateFileMappingA(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,DWORD,DWORD,LPCSTR);
HANDLE OpenFileMappingA(DWORD,BOOL,LPCSTR);
DWORD GetLogicalDriveStringsA(DWORD,LPSTR);
HINSTANCE LoadLibraryA(LPCSTR);
HINSTANCE LoadLibraryExA(LPCSTR,HANDLE,DWORD);
DWORD GetModuleFileNameA(HINSTANCE,LPSTR,DWORD);
HMODULE GetModuleHandleA(LPCSTR);
VOID FatalAppExitA(UINT,LPCSTR);
LPSTR GetCommandLineA(VOID);
DWORD GetEnvironmentVariableA(LPCSTR,LPSTR,DWORD);
BOOL SetEnvironmentVariableA(LPCSTR,LPCSTR);
DWORD ExpandEnvironmentStringsA(LPCSTR,LPSTR,DWORD);
VOID OutputDebugStringA(LPCSTR);
HRSRC FindResourceA(HMODULE,LPCSTR,LPCSTR);
HRSRC FindResourceExA(HINSTANCE,LPCSTR,LPCSTR,WORD);
BOOL EnumResourceTypesA(HINSTANCE,ENUMRESTYPEPROC,LONG);
BOOL EnumResourceNamesA(HINSTANCE,LPCSTR,ENUMRESNAMEPROC,LONG);
BOOL EnumResourceLanguagesA(HINSTANCE,LPCSTR,LPCSTR,ENUMRESLANGPROC,LONG);
HANDLE BeginUpdateResourceA(LPCSTR,BOOL);
BOOL UpdateResourceA(HANDLE,LPCSTR,LPCSTR,WORD,LPVOID,DWORD);
BOOL EndUpdateResourceA(HANDLE,BOOL);
ATOM GlobalAddAtomA(LPCSTR);
ATOM GlobalFindAtomA(LPCSTR);
UINT GlobalGetAtomNameA(ATOM,LPSTR,int);
ATOM AddAtomA(LPCSTR);
ATOM FindAtomA(LPCSTR);
UINT GetAtomNameA(ATOM,LPSTR,int);
UINT GetProfileIntA(LPCSTR,LPCSTR,INT);
DWORD GetProfileStringA(LPCSTR,LPCSTR,LPCSTR,LPSTR,DWORD);
BOOL WriteProfileStringA(LPCSTR,LPCSTR,LPCSTR);
DWORD GetProfileSectionA(LPCSTR,LPSTR,DWORD);
BOOL WriteProfileSectionA(LPCSTR,LPCSTR);
UINT GetPrivateProfileIntA(LPCSTR,LPCSTR,INT,LPCSTR);
DWORD GetPrivateProfileStringA(LPCSTR,LPCSTR,LPCSTR,LPSTR,DWORD,LPCSTR);
BOOL WritePrivateProfileStringA(LPCSTR,LPCSTR,LPCSTR,LPCSTR);
DWORD GetPrivateProfileSectionA(LPCSTR,LPSTR,DWORD,LPCSTR);
BOOL WritePrivateProfileSectionA(LPCSTR,LPCSTR,LPCSTR);
UINT GetDriveTypeA(LPCSTR);
UINT GetSystemDirectoryA(LPSTR,UINT);
BOOL WINAPI GetSystemRegistryQuota(PDWORD,PDWORD);
BOOL WINAPI GetSystemTimes(LPFILETIME,LPFILETIME,LPFILETIME);
VOID WINAPI GetNativeSystemInfo(LPSYSTEM_INFO);
DWORD GetTempPathA(DWORD,LPSTR);
UINT GetTempFileNameA(LPCSTR,LPCSTR,UINT,LPSTR);
UINT GetWindowsDirectoryA(LPSTR,UINT);
BOOL SetCurrentDirectoryA(LPCSTR);
DWORD GetCurrentDirectoryA(DWORD,LPSTR);
BOOL GetDiskFreeSpaceA(LPCSTR,LPDWORD,LPDWORD,LPDWORD,LPDWORD);
BOOL WINAPI GetDiskFreeSpaceExA(LPCSTR,long long *,long long *,long long *);
BOOL CreateDirectoryA(LPCSTR,LPSECURITY_ATTRIBUTES);
BOOL CreateDirectoryExA(LPCSTR,LPCSTR,LPSECURITY_ATTRIBUTES);
BOOL RemoveDirectoryA(LPCSTR);
DWORD GetFullPathNameA(LPCSTR,DWORD,LPSTR,LPSTR *);
BOOL DefineDosDeviceA(DWORD,LPCSTR,LPCSTR);
DWORD QueryDosDeviceA(LPCSTR,LPSTR,DWORD);
HANDLE CreateFileA(LPCSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE);
BOOL SetFileAttributesA(LPCSTR,DWORD);
DWORD GetFileAttributesA(LPCSTR);
DWORD GetCompressedFileSizeA(LPCSTR,LPDWORD);
BOOL DeleteFileA(LPCSTR);
DWORD SearchPathA(LPCSTR,LPCSTR,LPCSTR,DWORD,LPSTR,LPSTR *);
HANDLE WINAPI FindFirstVolumeA(LPSTR,DWORD);
HANDLE WINAPI FindFirstVolumeW(LPWSTR,DWORD);
BOOL WINAPI FindNextVolumeA(HANDLE,LPSTR,DWORD);
BOOL WINAPI FindNextVolumeW(HANDLE,LPWSTR,DWORD);
BOOL CopyFileA(LPCSTR,LPCSTR,BOOL);
HANDLE WINAPI FindFirstVolumeMountPointA(LPCSTR,LPSTR,DWORD);
HANDLE WINAPI FindFirstVolumeMountPointW(LPCWSTR,LPWSTR,DWORD);
BOOL WINAPI FindNextVolumeMountPointA(HANDLE,LPSTR,DWORD);
BOOL WINAPI FindNextVolumeMountPointW(HANDLE,LPWSTR,DWORD);
BOOL WINAPI FindVolumeMountPointClose(HANDLE);
BOOL WINAPI FindVolumeClose(HANDLE);
BOOL WINAPI SetVolumeMountPointA(LPCSTR,LPCSTR);
BOOL WINAPI SetVolumeMountPointW(LPCWSTR,LPCWSTR);
BOOL WINAPI DeleteVolumeMountPointA(LPCSTR);
BOOL WINAPI DeleteVolumeMountPointW(LPCWSTR);
BOOL WINAPI GetVolumeNameForVolumeMountPointA(LPCSTR,LPSTR,DWORD);
BOOL WINAPI GetVolumeNameForVolumeMountPointW(LPCWSTR,LPWSTR,DWORD);
BOOL WINAPI GetVolumePathNameA(LPCSTR,LPSTR,DWORD);
BOOL WINAPI GetVolumePathNameW(LPCWSTR,LPWSTR,DWORD);
BOOL WINAPI GetVolumePathNamesForVolumeNameA(LPCSTR,LPSTR,DWORD,PDWORD);
BOOL WINAPI GetVolumePathNamesForVolumeNameW(LPCWSTR,LPWSTR,DWORD,PDWORD);
BOOL WINAPI AllocateUserPhysicalPages(HANDLE,PULONG_PTR,PULONG_PTR);
BOOL WINAPI FreeUserPhysicalPages(HANDLE,PULONG_PTR,PULONG_PTR);
BOOL WINAPI MapUserPhysicalPages(PVOID,ULONG_PTR,PULONG_PTR);
BOOL WINAPI MapUserPhysicalPagesScatter(PVOID *,ULONG_PTR,PULONG_PTR);
HANDLE WINAPI CreateJobObjectA(LPSECURITY_ATTRIBUTES,LPCSTR);
HANDLE WINAPI CreateJobObjectW(LPSECURITY_ATTRIBUTES,LPCWSTR);
#ifdef UNICODE
#define CreateJobObject CreateJobObjectW
#define OpenJobObject OpenJobObjectW
#define EncryptFile EncryptFileW
#else
#define CreateJobObject CreateJobObjectA
#define OpenJobObject OpenJobObjectA
#define EncryptFile EncryptFileA
#endif
typedef BOOL(WINAPI *PQUERYACTCTXW_FUNC)(DWORD,HANDLE,PVOID,ULONG,PVOID,SIZE_T,SIZE_T *);
BOOL WINAPI QueryActCtxW(DWORD,HANDLE,PVOID,ULONG,PVOID,SIZE_T,SIZE_T *);
DWORD WINAPI WTSGetActiveConsoleSessionId(void);
BOOL WINAPI IsWow64Process(HANDLE,PBOOL);
BOOL WINAPI GetNumaProcessorNode(UCHAR,PUCHAR);
BOOL WINAPI GetNumaNodeProcessorMask(UCHAR,PULONGLONG);
BOOL WINAPI GetNumaAvailableMemoryNode(UCHAR,PULONGLONG);
BOOL WINAPI GetNumaHighestNodeNumber(PULONG);
BOOL WINAPI GetLogicalProcessorInformation(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION,PDWORD);
BOOL WINAPI EncryptFileA(LPCSTR);
BOOL WINAPI EncryptFileW(LPCWSTR);
BOOL WINAPI DecryptFileA(LPCSTR,DWORD);
BOOL WINAPI DecryptFileW(LPCWSTR,DWORD);
BOOL WINAPI AssignProcessToJobObject(HANDLE,HANDLE);
BOOL WINAPI TerminateJobObject(HANDLE,UINT);
BOOL WINAPI QueryInformationJobObject(HANDLE,JOBOBJECTINFOCLASS,LPVOID,DWORD,LPDWORD);
BOOL WINAPI SetInformationJobObject(HANDLE,JOBOBJECTINFOCLASS,LPVOID,DWORD);
BOOL WINAPI IsProcessInJob (HANDLE,HANDLE,PBOOL);
BOOL WINAPI CreateJobSet (ULONG,PJOB_SET_ARRAY,ULONG);
PVOID WINAPI AddVectoredExceptionHandler(ULONG,PVECTORED_EXCEPTION_HANDLER);
ULONG WINAPI RemoveVectoredExceptionHandler(PVOID);
HANDLE WINAPI OpenJobObjectA(DWORD,BOOL,LPCSTR);
HANDLE WINAPI OpenJobObjectW(DWORD,BOOL,LPCWSTR);
BOOL WINAPI CopyFileExA(LPCSTR,LPCSTR,LPPROGRESS_ROUTINE,LPVOID,LPBOOL,DWORD);
BOOL WINAPI CreateHardLinkA(LPCSTR,LPCSTR,LPSECURITY_ATTRIBUTES);
BOOL MoveFileA(LPCSTR,LPCSTR);
BOOL MoveFileExA(LPCSTR,LPCSTR,DWORD);
BOOL WINAPI MoveFileWithProgressA(LPCSTR,LPCSTR,LPPROGRESS_ROUTINE,LPVOID,DWORD);
HANDLE CreateNamedPipeA(LPCSTR,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
BOOL GetNamedPipeHandleStateA(HANDLE,LPDWORD,LPDWORD,LPDWORD,LPDWORD,LPSTR,DWORD);
BOOL CallNamedPipeA(LPCSTR,LPVOID,DWORD,LPVOID,DWORD,LPDWORD,DWORD);
BOOL WaitNamedPipeA(LPCSTR,DWORD);
BOOL SetVolumeLabelA(LPCSTR,LPCSTR);
BOOL GetVolumeInformationA(LPCSTR,LPSTR,DWORD,LPDWORD,LPDWORD,LPDWORD,LPSTR,DWORD);
BOOL ClearEventLogA(HANDLE,LPCSTR);
BOOL BackupEventLogA(HANDLE,LPCSTR);
HANDLE OpenEventLogA (LPCSTR,LPCSTR);
HANDLE RegisterEventSourceA (LPCSTR,LPCSTR);
HANDLE OpenBackupEventLogA(LPCSTR,LPCSTR);
BOOL ReadEventLogA(HANDLE,DWORD,DWORD,LPVOID,DWORD,DWORD *,DWORD *);
BOOL ReportEventA(HANDLE,WORD,WORD,DWORD,PSID,WORD,DWORD,LPCSTR *,LPVOID);
BOOL AccessCheckAndAuditAlarmA(LPCSTR,LPVOID,LPSTR,LPSTR,PSECURITY_DESCRIPTOR,
	DWORD,PGENERIC_MAPPING,BOOL,LPDWORD,LPBOOL,LPBOOL);
BOOL ObjectOpenAuditAlarmA(LPCSTR,LPVOID,LPSTR,LPSTR,PSECURITY_DESCRIPTOR,HANDLE,DWORD,DWORD,PPRIVILEGE_SET,BOOL,BOOL,LPBOOL);
BOOL ObjectPrivilegeAuditAlarmA(LPCSTR,LPVOID,HANDLE,DWORD,PPRIVILEGE_SET,BOOL);
BOOL ObjectCloseAuditAlarmA(LPCSTR,LPVOID,BOOL);
BOOL PrivilegedServiceAuditAlarmA(LPCSTR,LPCSTR,HANDLE,PPRIVILEGE_SET,BOOL);
BOOL SetFileSecurityA(LPCSTR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR);
BOOL GetFileSecurityA(LPCSTR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,LPDWORD);
HANDLE FindFirstChangeNotificationA(LPCSTR,BOOL,DWORD);
BOOL IsBadStringPtrA(LPCSTR,UINT);
BOOL LookupAccountSidA(LPCSTR,PSID,LPSTR,LPDWORD,LPSTR,LPDWORD,PSID_NAME_USE);
BOOL LookupAccountNameA(LPCSTR,LPCSTR,PSID,LPDWORD,LPSTR,LPDWORD,PSID_NAME_USE);
BOOL LookupPrivilegeValueA(LPCSTR,LPCSTR,PLUID);
BOOL LookupPrivilegeNameA(LPCSTR,PLUID,LPSTR,LPDWORD);
BOOL LookupPrivilegeDisplayNameA(LPCSTR,LPCSTR,LPSTR,LPDWORD,LPDWORD);
BOOL BuildCommDCBA(LPCSTR lpDef,LPDCB lpDCB);
BOOL BuildCommDCBAndTimeoutsA(LPCSTR,LPDCB,LPCOMMTIMEOUTS);
BOOL CommConfigDialogA(LPCSTR,HWND,LPCOMMCONFIG);
BOOL GetDefaultCommConfigA(LPCSTR,LPCOMMCONFIG,LPDWORD);
BOOL SetDefaultCommConfigA(LPCSTR,LPCOMMCONFIG,DWORD);
BOOL GetComputerNameA (LPSTR,LPDWORD);
BOOL SetComputerNameA (LPCSTR);
BOOL GetUserNameA (LPSTR,LPDWORD);
int wvsprintfA(LPSTR,LPCSTR,va_list arglist);
int CDECL wsprintfA(LPSTR,LPCSTR,...);
HKL LoadKeyboardLayoutA(LPCSTR,UINT);
BOOL GetKeyboardLayoutNameA(LPSTR);
HDESK CreateDesktopA(LPSTR,LPSTR,LPDEVMODE,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
HDESK OpenDesktopA(LPSTR,DWORD,BOOL,DWORD);
BOOL EnumDesktopsA(HWINSTA,DESKTOPENUMPROC,LPARAM);
HWINSTA CreateWindowStationA(LPSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
HWINSTA OpenWindowStationA(LPSTR,BOOL,DWORD);
BOOL EnumWindowStationsA(ENUMWINDOWSTATIONPROC,LPARAM);
BOOL GetUserObjectInformationA(HANDLE,int,PVOID,DWORD,LPDWORD);
BOOL SetUserObjectInformationA(HANDLE,int,PVOID,DWORD);
UINT RegisterWindowMessageA(LPCSTR);
BOOL GetMessageA(LPMSG,HWND,UINT,UINT);
LONG DispatchMessageA(CONST MSG *);
BOOL PeekMessageA(LPMSG,HWND,UINT,UINT,UINT);
LRESULT SendMessageA(HWND,UINT,WPARAM,LPARAM);
LRESULT SendMessageTimeoutA(HWND,UINT,WPARAM,LPARAM,UINT,UINT,LPDWORD);
BOOL SendNotifyMessageA(HWND,UINT,WPARAM,LPARAM);
BOOL SendMessageCallbackA(HWND,UINT,WPARAM,LPARAM,SENDASYNCPROC,DWORD);
BOOL PostMessageA(HWND,UINT,WPARAM,LPARAM);
BOOL PostThreadMessageA(DWORD,UINT,WPARAM,LPARAM);
LRESULT DefWindowProcA(HWND,UINT,WPARAM,LPARAM);
LRESULT CallWindowProcA(WNDPROC,HWND,UINT,WPARAM,LPARAM);
ATOM RegisterClassA(CONST WNDCLASS *);
BOOL UnregisterClassA(LPCSTR,HINSTANCE);
BOOL GetClassInfoA(HINSTANCE,LPCSTR,LPWNDCLASS);
ATOM RegisterClassExA(CONST WNDCLASSEX *);
BOOL GetClassInfoExA(HINSTANCE,LPCSTR,LPWNDCLASSEX);
HWND CreateWindowExA(DWORD,LPCSTR,LPCSTR,DWORD,int,int,int,int,HWND,HMENU,HINSTANCE,LPVOID);
HWND CreateDialogParamA(HINSTANCE,LPCSTR,HWND,DLGPROC,LPARAM);
HWND CreateDialogIndirectParamA(HINSTANCE,LPCDLGTEMPLATE,HWND,DLGPROC,LPARAM);
int DialogBoxParamA(HINSTANCE,LPCSTR,HWND,DLGPROC,LPARAM);
int DialogBoxIndirectParamA(HINSTANCE,LPCDLGTEMPLATE,HWND,DLGPROC,LPARAM);
BOOL SetDlgItemTextA(HWND,int,LPCSTR);
UINT GetDlgItemTextA(HWND,int,LPSTR,int);
LONG SendDlgItemMessageA(HWND,int,UINT,WPARAM,LPARAM);
LRESULT DefDlgProcA(HWND,UINT,WPARAM,LPARAM);
BOOL CallMsgFilterA(LPMSG,int);
UINT RegisterClipboardFormatA(LPCSTR);
int GetClipboardFormatNameA(UINT,LPSTR,int);
BOOL CharToOemA(LPCSTR,LPSTR);
BOOL OemToCharA(LPCSTR,LPSTR);
BOOL CharToOemBuffA(LPCSTR,LPSTR,DWORD);
BOOL OemToCharBuffA(LPCSTR,LPSTR,DWORD);
LPSTR CharUpperA(LPSTR);
DWORD CharUpperBuffA(LPSTR,DWORD);
LPSTR CharLowerA(LPSTR);
DWORD CharLowerBuffA(LPSTR,DWORD);
LPSTR CharNextA(LPCSTR);
LPSTR CharPrevA(LPCSTR,LPCSTR);
BOOL IsCharAlphaA(CHAR ch);
BOOL IsCharAlphaNumericA(CHAR);
BOOL IsCharUpperA(CHAR);
BOOL IsCharLowerA(CHAR);
int GetKeyNameTextA(LONG,LPSTR,int);
SHORT VkKeyScanA(CHAR);
SHORT VkKeyScanExA(CHAR,HKL);
UINT MapVirtualKeyA(UINT,UINT);
UINT MapVirtualKeyExA(UINT,UINT,HKL);
HACCEL LoadAcceleratorsA(HINSTANCE,LPCSTR);
HACCEL CreateAcceleratorTableA(LPACCEL,int);
int CopyAcceleratorTableA(HACCEL,LPACCEL,int);
int TranslateAcceleratorA(HWND,HACCEL,LPMSG);
HMENU LoadMenuA(HINSTANCE,LPCSTR);
HMENU LoadMenuIndirectA(CONST MENUTEMPLATE *);
BOOL ChangeMenuA(HMENU,UINT,LPCSTR,UINT,UINT);
int GetMenuStringA(HMENU,UINT,LPSTR,int,UINT);
BOOL InsertMenuA(HMENU,UINT,UINT,UINT,LPCSTR);
BOOL AppendMenuA(HMENU,UINT,UINT,LPCSTR);
BOOL ModifyMenuA(HMENU,UINT,UINT,UINT,LPCSTR);
BOOL InsertMenuItemA(HMENU,UINT,BOOL,LPCMENUITEMINFO);
BOOL GetMenuItemInfoA(HMENU,UINT,BOOL,LPMENUITEMINFO);
BOOL SetMenuItemInfoA(HMENU,UINT,BOOL,LPCMENUITEMINFO);
int DrawTextA(HDC,LPCSTR,int,LPRECT,UINT);
int DrawTextExA(HDC,LPSTR,int,LPRECT,UINT,LPDRAWTEXTPARAMS);
BOOL GrayStringA(HDC,HBRUSH,GRAYSTRINGPROC,LPARAM,int,int,int,int,int);
BOOL DrawStateA(HDC,HBRUSH,DRAWSTATEPROC,LPARAM,WPARAM,int,int,int,int,UINT);
LONG TabbedTextOutA(HDC,int,int,LPCSTR,int,int,LPINT,int);
DWORD GetTabbedTextExtentA(HDC,LPCSTR,int,int,LPINT);
BOOL SetPropA(HWND,LPCSTR,HANDLE);
HANDLE GetPropA(HWND,LPCSTR);
HANDLE RemovePropA(HWND,LPCSTR);
int EnumPropsExA(HWND,PROPENUMPROCEX,LPARAM);
int EnumPropsA(HWND,PROPENUMPROC);
BOOL SetWindowTextA(HWND,LPCSTR);
int GetWindowTextA(HWND,LPSTR,int);
int GetWindowTextLengthA(HWND);
int MessageBoxA(HWND,LPCSTR,LPCSTR,UINT);
int MessageBoxExA(HWND,LPCSTR,LPCSTR,UINT,WORD);
int MessageBoxIndirectA(LPMSGBOXPARAMS);
LONG GetWindowLongA(HWND,int);
LONG SetWindowLongA(HWND,int,LONG);
#define GetWindowLongPtrA	GetWindowLongA
#define SetWindowLongPtrA	SetWindowLongA
DWORD GetClassLongA(HWND,int);
DWORD SetClassLongA(HWND,int,LONG);
HWND FindWindowA(LPCSTR,LPCSTR);
HWND FindWindowExA(HWND,HWND,LPCSTR,LPCSTR);
int GetClassNameA(HWND,LPSTR,int);
HHOOK SetWindowsHookExA(int,HOOKPROC,HINSTANCE,DWORD);
HOOKPROC WINAPI SetWindowsHookA(int,HOOKPROC);
HBITMAP LoadBitmapA(HINSTANCE,LPCSTR);
HCURSOR LoadCursorA(HINSTANCE,LPCSTR);
HCURSOR LoadCursorFromFileA(LPCSTR);
HICON LoadIconA(HINSTANCE,LPCSTR);
HANDLE LoadImageA(HINSTANCE,LPCSTR,UINT,int,int,UINT);
int LoadStringA(HINSTANCE,UINT,LPSTR,int);
BOOL IsDialogMessageA(HWND,LPMSG);
int DlgDirListA(HWND,LPSTR,int,int,UINT);
BOOL DlgDirSelectExA(HWND,LPSTR,int,int);
int DlgDirListComboBoxA(HWND,LPSTR,int,int,UINT);
BOOL DlgDirSelectComboBoxExA(HWND,LPSTR,int,int);
LRESULT DefFrameProcA(HWND,HWND,UINT,WPARAM,LPARAM);
LRESULT DefMDIChildProcA(HWND,UINT,WPARAM,LPARAM);
HWND CreateMDIWindowA(LPSTR,LPSTR,DWORD,int,int,int,int,HWND,HINSTANCE,LPARAM);
BOOL WinHelpA(HWND,LPCSTR,UINT,DWORD);
LONG ChangeDisplaySettingsA(LPDEVMODE,DWORD);
LONG WINAPI ChangeDisplaySettingsExA(LPCSTR lpszDeviceName, LPDEVMODEA lpDevMode, HWND hwnd,
											   DWORD dwflags, LPVOID lParam);
BOOL EnumDisplaySettingsA(LPCSTR,DWORD,LPDEVMODE);
BOOL SystemParametersInfoA(UINT,UINT,PVOID,UINT);
int AddFontResourceA(LPCSTR);
int WINAPI ChoosePixelFormat(HDC,PIXELFORMATDESCRIPTOR *);
BOOL WINAPI SetPixelFormat(HDC,int,PIXELFORMATDESCRIPTOR *);
HMETAFILE CopyMetaFileA(HMETAFILE,LPCSTR);
HFONT CreateFontIndirectA(CONST LOGFONT *);
HDC CreateICA(LPCSTR,LPCSTR,LPCSTR,CONST DEVMODE *);
HDC CreateMetaFileA(LPCSTR);
BOOL CreateScalableFontResourceA(DWORD,LPCSTR,LPCSTR,LPCSTR);
int DeviceCapabilitiesA(LPCSTR,LPCSTR,WORD,LPSTR,CONST DEVMODE *);
int EnumFontFamiliesExA(HDC,LPLOGFONT,FONTENUMEXPROC,LPARAM,DWORD);
int EnumFontFamiliesA(HDC,LPCSTR,FONTENUMPROC,LPARAM);
int EnumFontsA(HDC,LPCSTR,ENUMFONTSPROC,LPARAM);
BOOL GetCharWidthA(HDC,UINT,UINT,LPINT);
BOOL GetCharWidth32A(HDC,UINT,UINT,LPINT);
BOOL GetCharWidthFloatA(HDC,UINT,UINT,PFLOAT);
BOOL GetCharABCWidthsA(HDC,UINT,UINT,LPABC);
BOOL GetCharABCWidthsFloatA(HDC,UINT,UINT,LPABCFLOAT);
DWORD GetGlyphOutlineA(HDC,UINT,UINT,LPGLYPHMETRICS,DWORD,LPVOID,CONST MAT2 *);
HMETAFILE GetMetaFileA(LPCSTR);
UINT GetOutlineTextMetricsA(HDC,UINT,LPOUTLINETEXTMETRIC);
BOOL GetTextExtentPointA(HDC,LPCSTR,int,LPSIZE);
BOOL GetTextExtentPoint32A(HDC,LPCSTR,int,LPSIZE);
BOOL GetTextExtentExPointA(HDC,LPCSTR,int,int,LPINT,LPINT,LPSIZE);
BOOL SignalObjectAndWait(HANDLE,HANDLE,DWORD,BOOL);
DWORD GetCharacterPlacementA(HDC,LPCSTR,int,int,LPGCP_RESULTS,DWORD);
HDC ResetDCA(HDC,CONST DEVMODE *);
BOOL RemoveFontResourceA(LPCSTR);
HENHMETAFILE CopyEnhMetaFileA(HENHMETAFILE,LPCSTR);
HDC CreateEnhMetaFileA(HDC,LPCSTR,CONST RECT *,LPCSTR);
HENHMETAFILE GetEnhMetaFileA(LPCSTR);
UINT GetEnhMetaFileDescriptionA(HENHMETAFILE,UINT,LPSTR);
BOOL GetTextMetricsA(HDC,LPTEXTMETRIC);
int StartDocA(HDC,CONST DOCINFO *);
int GetObjectA(HGDIOBJ,int,LPVOID);
BOOL TextOutA(HDC,int,int,LPCSTR,int);
BOOL ExtTextOutA(HDC,int,int,UINT,CONST RECT *,LPCSTR,UINT,CONST INT *);
BOOL PolyTextOutA(HDC,CONST POLYTEXT *,int);
int GetTextFaceA(HDC,int,LPSTR);
DWORD GetKerningPairsA(HDC,DWORD,LPKERNINGPAIR);
HCOLORSPACE CreateColorSpaceA(LPLOGCOLORSPACE);
BOOL GetLogColorSpaceA(HCOLORSPACE,LPLOGCOLORSPACE,DWORD);
BOOL GetICMProfileA(HDC,DWORD,LPSTR);
BOOL SetICMProfileA(HDC,LPSTR);
BOOL UpdateICMRegKeyA(DWORD,DWORD,LPSTR,UINT);
int EnumICMProfilesA(HDC,ICMENUMPROC,LPARAM);
int PropertySheetA(LPCPROPSHEETHEADER);
HIMAGELIST ImageList_LoadImageA(HINSTANCE,LPCSTR,int,int,COLORREF,UINT,UINT);
HWND CreateStatusWindowA(LONG,LPCSTR,HWND,UINT);
void DrawStatusTextA(HDC,LPRECT,LPCSTR,UINT);
BOOL GetOpenFileNameA(LPOPENFILENAME);
BOOL GetSaveFileNameA(LPOPENFILENAME);
short GetFileTitleA(LPCSTR,LPSTR,WORD);
BOOL ChooseColorA(LPCHOOSECOLOR);
HWND FindTextA(LPFINDREPLACE);
HWND ReplaceTextA(LPFINDREPLACE);
BOOL ChooseFontA(LPCHOOSEFONT);
BOOL PrintDlgA(LPPRINTDLG);
BOOL PageSetupDlgA(LPPAGESETUPDLG);
BOOL CreateProcessA(LPCSTR,LPSTR,LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES,BOOL,DWORD,LPVOID,LPCSTR,LPSTARTUPINFO,LPPROCESS_INFORMATION);
BOOL WINAPI CreateProcessWithTokenW(HANDLE,DWORD,LPCWSTR,LPWSTR,DWORD,LPVOID,
	LPCWSTR,LPSTARTUPINFOW,LPPROCESS_INFORMATION);
VOID GetStartupInfoA(LPSTARTUPINFO);
HANDLE FindFirstFileA(LPCSTR,LPWIN32_FIND_DATA);
HANDLE WINAPI FindFirstFileExA(LPCSTR,FINDEX_INFO_LEVELS,LPVOID,FINDEX_SEARCH_OPS,LPVOID,DWORD);
BOOL FindNextFileA(HANDLE,LPWIN32_FIND_DATA);
BOOL GetVersionExA(LPOSVERSIONINFO);
#define CreateWindowA(C,WN,S,x,y,W,H,hW,hM,hI,l) CreateWindowExA(0,C,WN,S,x,y,W,H,hW,hM,hI,l)
#define CreateDialogA(hI,Name,hP,Func) CreateDialogParamA(hI,Name,hP,Func,0)
#define CreateDialogIndirectA(hI,T,P,Func) CreateDialogIndirectParamA(hI,T,P,Func,0)
#define DialogBoxA(h,T,P,D) DialogBoxParamA(h,T,P,D,0)
#define DialogBoxIndirectA(h,T,P,D) DialogBoxIndirectParamA(h,T,P,D,0)
HDC CreateDCA(LPCSTR,LPCSTR,LPCSTR,CONST DEVMODE *);
DWORD VerInstallFileA(DWORD,LPSTR,LPSTR,LPSTR,LPSTR,LPSTR,LPSTR,PUINT);
DWORD GetFileVersionInfoSizeA(LPSTR,LPDWORD);
BOOL GetFileVersionInfoA(LPSTR,DWORD,DWORD,LPVOID);
DWORD VerLanguageNameA(DWORD,LPSTR,DWORD);
DWORD VerFindFileA(DWORD,LPSTR,LPSTR,LPSTR,LPSTR,PUINT,LPSTR,PUINT);
LONG RegConnectRegistryA(LPSTR,HKEY,PHKEY);
LONG RegCreateKeyA(HKEY,LPCSTR,PHKEY);
LONG RegCreateKeyExA(HKEY,LPCSTR,DWORD,LPSTR,DWORD,REGSAM,LPSECURITY_ATTRIBUTES,PHKEY,LPDWORD);
LONG RegDeleteKeyA(HKEY,LPCSTR);
LONG RegDeleteValueA (HKEY,LPCSTR);
LONG RegEnumKeyA (HKEY,DWORD,LPSTR,DWORD);
LONG RegEnumKeyExA(HKEY,DWORD,LPSTR,LPDWORD,LPDWORD,LPSTR,LPDWORD,PFILETIME);
LONG RegEnumValueA(HKEY,DWORD,LPSTR,LPDWORD,LPDWORD,LPDWORD,LPBYTE,LPDWORD);
LONG RegLoadKeyA(HKEY,LPCSTR,LPCSTR);
LONG RegOpenKeyA(HKEY,LPCSTR,PHKEY);
LONG RegOpenKeyExA(HKEY,LPCSTR,DWORD,REGSAM,PHKEY);
LONG RegQueryInfoKeyA(HKEY,LPSTR,LPDWORD,LPDWORD,LPDWORD,LPDWORD,
	LPDWORD,LPDWORD,LPDWORD,LPDWORD,LPDWORD,PFILETIME);
LONG RegQueryValueA(HKEY,LPCSTR,LPSTR,PLONG);
LONG RegQueryMultipleValuesA(HKEY,PVALENT,DWORD,LPSTR,LPDWORD);
LONG RegQueryValueExA (HKEY,LPCSTR,LPDWORD,LPDWORD,LPBYTE,LPDWORD);
LONG RegReplaceKeyA(HKEY,LPCSTR,LPCSTR,LPCSTR);
LONG RegRestoreKeyA (HKEY,LPCSTR,DWORD);
LONG RegSaveKeyA(HKEY,LPCSTR,LPSECURITY_ATTRIBUTES);
LONG RegSetValueA(HKEY,LPCSTR,DWORD,LPCSTR,DWORD);
LONG RegSetValueExA(HKEY,LPCSTR,DWORD,DWORD,BYTE*,DWORD);
LONG RegUnLoadKeyA(HKEY,LPCSTR);
BOOL InitiateSystemShutdownA(LPSTR,LPSTR,DWORD,BOOL,BOOL);
BOOL AbortSystemShutdownA(LPSTR);
int CompareStringA(LCID,DWORD,LPCSTR,int,LPCSTR,int);
int LCMapStringA(LCID,DWORD,LPCSTR,int,LPSTR,int);
int GetLocaleInfoA(LCID,LCTYPE,LPSTR,int);
BOOL SetLocaleInfoA(LCID,LCTYPE,LPCSTR);
int GetTimeFormatA(LCID,DWORD,CONST SYSTEMTIME *,LPCSTR,LPSTR,int);
int GetDateFormatA(LCID,DWORD,CONST SYSTEMTIME *,LPCSTR,LPSTR,int);
int GetNumberFormatA(LCID,DWORD,LPCSTR,CONST NUMBERFMTA *,LPSTR,int);
int GetCurrencyFormatA(LCID,DWORD,LPCSTR,CONST CURRENCYFMT *,LPSTR,int);
BOOL EnumCalendarInfoA(CALINFO_ENUMPROC,LCID,CALID,CALTYPE);
BOOL EnumTimeFormatsA(TIMEFMT_ENUMPROC,LCID,DWORD);
BOOL EnumDateFormatsA(DATEFMT_ENUMPROC,LCID,DWORD);
BOOL GetStringTypeExA(LCID,DWORD,LPCSTR,int,LPWORD);
BOOL GetStringTypeA(LCID,DWORD,LPCSTR,int,LPWORD);
int FoldStringA(DWORD,LPCSTR,int,LPSTR,int);
BOOL EnumSystemLocalesA(LOCALE_ENUMPROC,DWORD);
BOOL EnumSystemCodePagesA(CODEPAGE_ENUMPROC,DWORD);
BOOL PeekConsoleInputA(HANDLE,PINPUT_RECORD,DWORD,LPDWORD);
BOOL ReadConsoleInputA(HANDLE,PINPUT_RECORD,DWORD,LPDWORD);
BOOL WriteConsoleInputA(HANDLE,CONST INPUT_RECORD *,DWORD,LPDWORD);
BOOL ReadConsoleOutputA(HANDLE,PCHAR_INFO,COORD,COORD,PSMALL_RECT);
BOOL WriteConsoleOutputA(HANDLE,CONST CHAR_INFO *,COORD,COORD,PSMALL_RECT);
BOOL ReadConsoleOutputCharacterA(HANDLE,LPSTR,DWORD,COORD,LPDWORD);
BOOL WriteConsoleOutputCharacterA(HANDLE,LPCSTR,DWORD,COORD,LPDWORD);
BOOL FillConsoleOutputCharacterA(HANDLE,CHAR,DWORD,COORD,LPDWORD);
BOOL ScrollConsoleScreenBufferA(HANDLE,CONST SMALL_RECT *,CONST SMALL_RECT *,COORD,CONST CHAR_INFO *);
DWORD GetConsoleTitleA(LPSTR,DWORD);
BOOL SetConsoleTitleA(LPCSTR);
BOOL ReadConsoleA(HANDLE,LPVOID,DWORD,LPDWORD,LPVOID);
BOOL WriteConsoleA(HANDLE,CONST VOID *,DWORD,LPDWORD,LPVOID);
DWORD WNetAddConnectionA(LPCSTR,LPCSTR,LPCSTR);
DWORD WNetAddConnection2A(LPNETRESOURCE,LPCSTR,LPCSTR,DWORD);
DWORD WNetAddConnection3A(HWND,LPNETRESOURCE,LPCSTR,LPCSTR,DWORD);
DWORD WNetCancelConnectionA(LPCSTR,BOOL);
DWORD WNetCancelConnection2A(LPCSTR,DWORD,BOOL);
DWORD WNetGetConnectionA(LPCSTR,LPSTR,LPDWORD);
DWORD WNetUseConnectionA(HWND,LPNETRESOURCE,LPCSTR,LPCSTR,DWORD,LPSTR,LPDWORD,LPDWORD);
DWORD WNetSetConnectionA(LPCSTR,DWORD,LPVOID);
DWORD WNetConnectionDialog1A(LPCONNECTDLGSTRUCT);
DWORD WNetDisconnectDialog1A(LPDISCDLGSTRUCT);
DWORD WNetOpenEnumA(DWORD,DWORD,DWORD,LPNETRESOURCE,LPHANDLE);
DWORD WNetEnumResourceA(HANDLE,LPDWORD,LPVOID,LPDWORD);
DWORD WNetGetUniversalNameA(LPCSTR,DWORD,LPVOID,LPDWORD);
DWORD WNetGetUserA(LPCSTR,LPSTR,LPDWORD);
DWORD WNetGetProviderNameA(DWORD,LPSTR,LPDWORD);
DWORD WNetGetNetworkInformationA(LPCSTR,LPNETINFOSTRUCT);
DWORD WNetGetLastErrorA(LPDWORD,LPSTR,DWORD,LPSTR,DWORD);
DWORD MultinetGetConnectionPerformanceA(LPNETRESOURCE,LPNETCONNECTINFOSTRUCT);
BOOL WINAPI TrackMouseEvent(LPTRACKMOUSEEVENT);
HWND WINAPI GetAncestor(HWND,UINT);
BOOL WINAPI GetComboBoxInfo(HWND,PCOMBOBOXINFO);
UCHAR APIENTRY Netbios(PNCB);
LANGID WINAPI GetMUILanguage(void);
void WINAPI InitMUILanguage(LANGID);
#ifdef UNICODE
#define GetLongPathName GetLongPathNameW
#define GetDiskFreeSpaceEx GetDiskFreeSpaceExW
#define CreateProcessAsUser CreateProcessAsUserW
#define HDITEM	HDITEMW
#define LPHDITEM LPHDITEMW
#define COMBOBOXEXITEM	COMBOBOXEXITEMW
#define PCOMBOBOXEXITEM	PCOMBOBOXEXITEMW
#define PCCOMBOBOXEXITEM	PCCOMBOBOXEXITEMW
#define CBEM_INSERTITEM	CBEM_INSERTITEMW
#define CBEM_SETITEM	CBEM_SETITEMW
#define CBEM_GETITEM	CBEM_GETITEMW
#define DATETIMEPICK_CLASS	DATETIMEPICK_CLASSW
#define DTN_USERSTRING	DTN_USERSTRINGW
#define NMDATETIMESTRING	NMDATETIMESTRINGW
#define LPNMDATETIMESTRING	LPNMDATETIMESTRINGW
#define DTN_WMKEYDOWN	DTN_WMKEYDOWNW
#define NMDATETIMEWMKEYDOWN	NMDATETIMEWMKEYDOWNW
#define LPNMDATETIMEWMKEYDOWN	LPNMDATETIMEWMKEYDOWNW
#define DTN_FORMAT	DTN_FORMATW
#define NMDATETIMEFORMAT	NMDATETIMEFORMATW
#define LPNMDATETIMEFORMAT	LPNMDATETIMEFORMATW
#define DTN_FORMATQUERY	DTN_FORMATQUERYW
#define NMDATETIMEFORMATQUERY	NMDATETIMEFORMATQUERYW
#define LPNMDATETIMEFORMATQUERY	LPNMDATETIMEFORMATQUERYW
#define RegConnectRegistry	RegConnectRegistryW
#define RegCreateKey	RegCreateKeyW
#define RegCreateKeyEx	RegCreateKeyExW
#define RegDeleteKey	RegDeleteKeyW
#define RegDeleteValue	RegDeleteValueW
#define RegEnumKey	RegEnumKeyW
#define RegEnumKeyEx	RegEnumKeyExW
#define RegEnumValue	RegEnumValueW
#define RegLoadKey	RegLoadKeyW
#define RegOpenKey	RegOpenKeyW
#define RegOpenKeyEx	RegOpenKeyExW
#define RegQueryInfoKey RegQueryInfoKeyW
#define RegQueryValue	RegQueryValueW
#define RegQueryMultipleValues RegQueryMultipleValuesW
#define RegQueryValueEx RegQueryValueExW
#define RegReplaceKey	RegReplaceKeyW
#define RegRestoreKey	RegRestoreKeyW
#define RegSaveKey	RegSaveKeyW
#define RegSetValue	RegSetValueW
#define RegSetValueEx RegSetValueExW
#define AbortSystemShutdown AbortSystemShutdownW
#define InitiateSystemShutdown InitiateSystemShutdownW
#define RegUnLoadKey RegUnLoadKeyW
#define SetProp SetPropW
#define GetProp GetPropW
#define RemoveProp RemovePropW
#define EnumPropsEx EnumPropsExW
#define EnumProps EnumPropsW
#define SetWindowText SetWindowTextW
#define GetWindowText GetWindowTextW
#define GetWindowTextLength GetWindowTextLengthW
#define MessageBox MessageBoxW
#define MessageBoxEx MessageBoxExW
#define MessageBoxIndirect MessageBoxIndirectW
#define GetWindowLong GetWindowLongW
#define SetWindowLong SetWindowLongW
#define GetWindowLongPtr GetWindowLongPtrW
#define SetWindowLongPtr SetWindowLongPtrW
#define SetWindowLongPtrW	SetWindowLongW
#define GetClassLong GetClassLongW
#define SetClassLong SetClassLongW
#define GetClassLongPtr GetClassLongPtrW
#define SetClassLongPtr	SetClassLongPtrW
#define FindWindow FindWindowW
#define FindWindowEx FindWindowExW
#define GetClassName	GetClassNameW
#define SetWindowsHookEx	SetWindowsHookExW
#define SetWindowsHook	SetWindowsHookW
#define LoadBitmap	LoadBitmapW
#define LoadCursor	LoadCursorW
#define LoadCursorFromFile	LoadCursorFromFileW
#define LoadIcon	LoadIconW
#define LoadImage LoadImageW
#define LoadString LoadStringW
#define IsDialogMessage IsDialogMessageW
#define DlgDirList DlgDirListW
#define DlgDirSelectEx DlgDirSelectExW
#define DlgDirListComboBox DlgDirListComboBoxW
#define DlgDirSelectComboBoxEx DlgDirSelectComboBoxExW
#define DefFrameProc DefFrameProcW
#define DefMDIChildProc DefMDIChildProcW
#define CreateMDIWindow CreateMDIWindowW
#define WinHelp WinHelpW
#define ChangeDisplaySettings ChangeDisplaySettingsW
#define ChangeDisplaySettingsEx ChangeDisplaySettingsExW
#define EnumDisplaySettings EnumDisplaySettingsW
#define SystemParametersInfo SystemParametersInfoW
#define AddFontResource AddFontResourceW
#define CopyMetaFile CopyMetaFileW
#define CreateDC CreateDCW
#define CreateFontIndirect CreateFontIndirectW
#define CreateFont CreateFontW
#define CreateIC CreateICW
#define CreateMetaFile CreateMetaFileW
#define CreateScalableFontResource CreateScalableFontResourceW
#define DeviceCapabilities DeviceCapabilitiesW
#define EnumFontFamiliesEx EnumFontFamiliesExW
#define EnumFontFamilies EnumFontFamiliesW
#define EnumFonts EnumFontsW
#define GetCharWidth GetCharWidthW
#define GetCharWidth32 GetCharWidth32W
#define GetCharWidthFloat GetCharWidthFloatW
#define GetCharABCWidths GetCharABCWidthsW
#define GetCharABCWidthsFloat GetCharABCWidthsFloatW
#define GetGlyphOutline GetGlyphOutlineW
#define GetMetaFile GetMetaFileW
#define GetOutlineTextMetrics GetOutlineTextMetricsW
#define GetTextExtentPoint GetTextExtentPointW
#define GetTextExtentPoint32 GetTextExtentPoint32W
#define GetTextExtentExPoint GetTextExtentExPointW
#define GetCharacterPlacement GetCharacterPlacementW
#define ResetDC ResetDCW
#define RemoveFontResource RemoveFontResourceW
#define CopyEnhMetaFile CopyEnhMetaFileW
#define CreateEnhMetaFile CreateEnhMetaFileW
#define GetEnhMetaFile GetEnhMetaFileW
#define GetEnhMetaFileDescription GetEnhMetaFileDescriptionW
#define GetTextMetrics GetTextMetricsW
#define StartDoc StartDocW
#define GetObject GetObjectW
#define TextOut TextOutW
#define ExtTextOut ExtTextOutW
#define PolyTextOut PolyTextOutW
#define GetTextFace GetTextFaceW
#define GetKerningPairs GetKerningPairsW
#define GetLogColorSpace GetLogColorSpaceW
#define CreateColorSpace CreateColorSpaceW
#define GetICMProfile GetICMProfileW
#define SetICMProfile SetICMProfileW
#define UpdateICMRegKey UpdateICMRegKeyW
#define EnumICMProfiles EnumICMProfilesW
#define CreatePropertySheetPage CreatePropertySheetPageW
#define PropertySheet PropertySheetW
#define ImageList_LoadImage ImageList_LoadImageW
#define CreateStatusWindow CreateStatusWindowW
#define DrawStatusText DrawStatusTextW
#define GetOpenFileName GetOpenFileNameW
#define GetSaveFileName GetSaveFileNameW
#define GetFileTitle GetFileTitleW
#define ChooseColor ChooseColorW
#define FindText FindTextW
#define ReplaceText ReplaceTextW
#define ChooseFont ChooseFontW
#define PrintDlg PrintDlgW
#define PageSetupDlg PageSetupDlgW
#define DefWindowProc DefWindowProcW
#define CallWindowProc CallWindowProcW
#define RegisterClass RegisterClassW
#define UnregisterClass UnregisterClassW
#define GetClassInfo GetClassInfoW
#define RegisterClassEx RegisterClassExW
#define GetClassInfoEx GetClassInfoExW
#define CreateWindowEx CreateWindowExW
#define CreateWindow CreateWindowW
#define CreateDialogParam CreateDialogParamW
#define CreateDialogIndirectParam CreateDialogIndirectParamW
#define CreateDialog CreateDialogW
#define CreateDialogIndirect CreateDialogIndirectW
#define DialogBoxParam DialogBoxParamW
#define DialogBoxIndirectParam DialogBoxIndirectParamW
#define DialogBox DialogBoxW
#define DialogBoxIndirect DialogBoxIndirectW
#define RegisterClipboardFormat RegisterClipboardFormatW
#define SetDlgItemText SetDlgItemTextW
#define GetDlgItemText GetDlgItemTextW
#define SendDlgItemMessage SendDlgItemMessageW
#define DefDlgProc DefDlgProcW
#define CallMsgFilter CallMsgFilterW
#define GetClipboardFormatName GetClipboardFormatNameW
#define CharToOem CharToOemW
#define OemToChar OemToCharW
#define CharToOemBuff CharToOemBuffW
#define OemToCharBuff OemToCharBuffW
#define CharUpper CharUpperW
#define CharUpperBuff CharUpperBuffW
#define CharLower CharLowerW
#define CharLowerBuff CharLowerBuffW
#define CharNext CharNextW
#define CharPrev CharPrevW
#define IsCharAlpha IsCharAlphaW
#define IsCharAlphaNumeric IsCharAlphaNumericW
#define IsCharUpper IsCharUpperW
#define IsCharLower IsCharLowerW
#define GetKeyNameText GetKeyNameTextW
#define VkKeyScan VkKeyScanW
#define VkKeyScanEx VkKeyScanExW
#define MapVirtualKey MapVirtualKeyW
#define MapVirtualKeyEx MapVirtualKeyExW
#define LoadAccelerators LoadAcceleratorsW
#define CreateAcceleratorTable CreateAcceleratorTableW
#define CopyAcceleratorTable CopyAcceleratorTableW
#define TranslateAccelerator TranslateAcceleratorW
#define LoadMenu LoadMenuW
#define LoadMenuIndirect LoadMenuIndirectW
#define ChangeMenu ChangeMenuW
#define GetMenuString GetMenuStringW
#define InsertMenu InsertMenuW
#define AppendMenu AppendMenuW
#define ModifyMenu ModifyMenuW
#define InsertMenuItem InsertMenuItemW
#define GetMenuItemInfo GetMenuItemInfoW
#define SetMenuItemInfo SetMenuItemInfoW
#define DrawText DrawTextW
#define DrawTextEx DrawTextExW
#define GrayString GrayStringW
#define DrawState DrawStateW
#define TabbedTextOut TabbedTextOutW
#define GetTabbedTextExtent GetTabbedTextExtentW
#define GetVersionEx GetVersionExW
#define wvsprintf wvsprintfW
#define wsprintf wsprintfW
#define LoadKeyboardLayout LoadKeyboardLayoutW
#define GetKeyboardLayoutName GetKeyboardLayoutNameW
#define CreateDesktop CreateDesktopW
#define OpenDesktop OpenDesktopW
#define EnumDesktops EnumDesktopsW
#define CreateWindowStation CreateWindowStationW
#define OpenWindowStation OpenWindowStationW
#define EnumWindowStations EnumWindowStationsW
#define IsBadStringPtr IsBadStringPtrW
#define LookupAccountSid LookupAccountSidW
#define LookupAccountName LookupAccountNameW
#define LookupPrivilegeValue LookupPrivilegeValueW
#define LookupPrivilegeName LookupPrivilegeNameW
#define LookupPrivilegeDisplayName LookupPrivilegeDisplayNameW
#define BuildCommDCB BuildCommDCBW
#define BuildCommDCBAndTimeouts BuildCommDCBAndTimeoutsW
#define CommConfigDialog CommConfigDialogW
#define GetDefaultCommConfig GetDefaultCommConfigW
#define SetDefaultCommConfig SetDefaultCommConfigW
#define GetComputerName GetComputerNameW
#define SetComputerName SetComputerNameW
#define GetUserName GetUserNameW
#define CreateMailslot CreateMailslotW
#define FormatMessage FormatMessageW
#define GetEnvironmentStrings GetEnvironmentStringsW
#define FreeEnvironmentStrings FreeEnvironmentStringsW
#define lstrcmp lstrcmpW
#define lstrcmpi lstrcmpiW
#define lstrcpyn lstrcpynW
#define lstrcpy lstrcpyW
#define lstrcat lstrcatW
#define lstrlen lstrlenW
#define GetBinaryType GetBinaryTypeW
#define GetShortPathName GetShortPathNameW
#define SetFileSecurity SetFileSecurityW
#define GetFileSecurity GetFileSecurityW
#define FindFirstChangeNotification FindFirstChangeNotificationW
#define AccessCheckAndAuditAlarm AccessCheckAndAuditAlarmW
#define ObjectOpenAuditAlarm ObjectOpenAuditAlarmW
#define ObjectPrivilegeAuditAlarm ObjectPrivilegeAuditAlarmW
#define ObjectCloseAuditAlarm ObjectCloseAuditAlarmW
#define PrivilegedServiceAuditAlarm PrivilegedServiceAuditAlarmW
#define OpenEventLog OpenEventLogW
#define RegisterEventSource RegisterEventSourceW
#define OpenBackupEventLog OpenBackupEventLogW
#define ReadEventLog ReadEventLogW
#define ReportEvent ReportEventW
#define CreateProcess CreateProcessW
#define FatalAppExit FatalAppExitW
#define GetStartupInfo GetStartupInfoW
#define GetEnvironmentVariable GetEnvironmentVariableW
#define GetCommandLine GetCommandLineW
#define SetEnvironmentVariable SetEnvironmentVariableW
#define ExpandEnvironmentStrings ExpandEnvironmentStringsW
#define OutputDebugString OutputDebugStringW
#define FindResource FindResourceW
#define FindResourceEx FindResourceExW
#define EnumResourceTypes EnumResourceTypesW
#define EnumResourceNames EnumResourceNamesW
#define EnumResourceLanguages EnumResourceLanguagesW
#define BeginUpdateResource BeginUpdateResourceW
#define UpdateResource UpdateResourceW
#define EndUpdateResource EndUpdateResourceW
#define GlobalAddAtom GlobalAddAtomW
#define GlobalFindAtom GlobalFindAtomW
#define GlobalGetAtomName GlobalGetAtomNameW
#define AddAtom AddAtomW
#define FindAtom FindAtomW
#define GetAtomName GetAtomNameW
#define GetProfileInt GetProfileIntW
#define GetProfileString GetProfileStringW
#define WriteProfileString WriteProfileStringW
#define GetProfileSection GetProfileSectionW
#define WriteProfileSection WriteProfileSectionW
#define GetPrivateProfileInt GetPrivateProfileIntW
#define GetPrivateProfileSectionNames GetrivateProfileSectionNamesW
#define GetPrivateProfileString GetPrivateProfileStringW
#define WritePrivateProfileString WritePrivateProfileStringW
#define WritePrivateProfileStruct WritePrivateProfileStructW
#define GetPrivateProfileSection GetPrivateProfileSectionW
#define WritePrivateProfileSection WritePrivateProfileSectionW
#define GetDriveType GetDriveTypeW
#define GetSystemDirectory GetSystemDirectoryW
#define GetTempPath GetTempPathW
#define GetTempFileName GetTempFileNameW
#define GetWindowsDirectory GetWindowsDirectoryW
#define SetCurrentDirectory SetCurrentDirectoryW
#define GetCurrentDirectory GetCurrentDirectoryW
#define GetDiskFreeSpace GetDiskFreeSpaceW
#define CreateDirectory CreateDirectoryW
#define CreateDirectoryEx CreateDirectoryExW
#define RemoveDirectory RemoveDirectoryW
#define GetFullPathName GetFullPathNameW
#define DefineDosDevice DefineDosDeviceW
#define QueryDosDevice QueryDosDeviceW
#define CreateFile CreateFileW
#define SetFileAttributes SetFileAttributesW
#define GetFileAttributes GetFileAttributesW
#define GetCompressedFileSize GetCompressedFileSizeW
#define DeleteFile DeleteFileW
#define FindFirstFile FindFirstFileW
#define FindFirstFileEx FindFirstFileExW
#define FindNextFile FindNextFileW
#define SearchPath SearchPathW
#define CopyFile CopyFileW
#define CopyFileEx CopyFileExW
#define CreateHardLink CreateHardLinkW
#define MoveFile MoveFileW
#define MoveFileWithProgress MoveFileWithProgressW
#define MoveFileEx MoveFileExW
#define CreateNamedPipe CreateNamedPipeW
#define GetNamedPipeHandleState GetNamedPipeHandleStateW
#define CallNamedPipe CallNamedPipeW
#define WaitNamedPipe WaitNamedPipeW
#define SetVolumeLabel SetVolumeLabelW
#define GetVolumeInformation GetVolumeInformationW
#define ClearEventLog ClearEventLogW
#define BackupEventLog BackupEventLogW
#define CreateMutex CreateMutexW
#define OpenMutex OpenMutexW
#define CreateEvent CreateEventW
#define OpenEvent OpenEventW
#define CreateSemaphore CreateSemaphoreW
#define OpenSemaphore OpenSemaphoreW
#define CreateFileMapping CreateFileMappingW
#define OpenFileMapping OpenFileMappingW
#define GetLogicalDriveStrings GetLogicalDriveStringsW
#define LoadLibrary LoadLibraryW
#define LoadLibraryEx LoadLibraryExW
#define GetModuleFileName GetModuleFileNameW
#define GetModuleHandle GetModuleHandleW
#define GetUserObjectInformation GetUserObjectInformationW
#define SetUserObjectInformation SetUserObjectInformationW
#define RegisterWindowMessage RegisterWindowMessageW
#define GetMessage GetMessageW
#define DispatchMessage DispatchMessageW
#define PeekMessage PeekMessageW
#define SendMessage SendMessageW
#define SendMessageTimeout SendMessageTimeoutW
#define SendNotifyMessage SendNotifyMessageW
#define SendMessageCallback SendMessageCallbackW
#define PostMessage PostMessageW
#define PostThreadMessage PostThreadMessageW
#define VerFindFile VerFindFileW
#define VerInstallFile VerInstallFileW
#define GetFileVersionInfoSize GetFileVersionInfoSizeW
#define GetFileVersionInfo GetFileVersionInfoW
#define VerLanguageName VerLanguageNameW
#define VerQueryValue VerQueryValueW
#define CompareString CompareStringW
#define LCMapString LCMapStringW
#define GetLocaleInfo GetLocaleInfoW
#define SetLocaleInfo SetLocaleInfoW
#define GetTimeFormat GetTimeFormatW
#define GetDateFormat GetDateFormatW
#define GetNumberFormat GetNumberFormatW
#define GetCurrencyFormat GetCurrencyFormatW
#define EnumCalendarInfo EnumCalendarInfoW
#define EnumTimeFormats EnumTimeFormatsW
#define FoldString FoldStringW
#define EnumSystemCodePages EnumSystemCodePagesW
#define EnumSystemLocales EnumSystemLocalesW
#define GetStringTypeEx GetStringTypeExW
#define EnumDateFormats EnumDateFormatsW
#define GetConsoleTitle GetConsoleTitleW
#define ScrollConsoleScreenBuffer ScrollConsoleScreenBufferW
#define SetConsoleTitle SetConsoleTitleW
#define ReadConsole ReadConsoleW
#define WriteConsole WriteConsoleW
#define PeekConsoleInput PeekConsoleInputW
#define ReadConsoleInput ReadConsoleInputW
#define WriteConsoleInput WriteConsoleInputW
#define ReadConsoleOutput ReadConsoleOutputW
#define WriteConsoleOutput WriteConsoleOutputW
#define ReadConsoleOutputCharacter ReadConsoleOutputCharacterW
#define WriteConsoleOutputCharacter WriteConsoleOutputCharacterW
#define FillConsoleOutputCharacter FillConsoleOutputCharacterW
#define WNetGetProviderName WNetGetProviderNameW
#define WNetGetNetworkInformation WNetGetNetworkInformationW
#define WNetGetLastError WNetGetLastErrorW
#define MultinetGetConnectionPerformance MultinetGetConnectionPerformanceW
#define WNetConnectionDialog1 WNetConnectionDialog1W
#define WNetDisconnectDialog1 WNetDisconnectDialog1W
#define WNetOpenEnum WNetOpenEnumW
#define WNetEnumResource WNetEnumResourceW
#define WNetGetUniversalName WNetGetUniversalNameW
#define WNetGetUser WNetGetUserW
#define WNetAddConnection WNetAddConnectionW
#define WNetAddConnection2 WNetAddConnection2W
#define WNetAddConnection3 WNetAddConnection3W
#define WNetCancelConnection WNetCancelConnectionW
#define WNetCancelConnection2 WNetCancelConnection2W
#define WNetGetConnection WNetGetConnectionW
#define WNetUseConnection WNetUseConnectionW
#define WNetSetConnection WNetSetConnectionW
#define CreateService CreateServiceW
#define ChangeServiceConfig ChangeServiceConfigW
#define EnumDependentServices EnumDependentServicesW
#define EnumServicesStatus EnumServicesStatusW
#define GetServiceKeyName GetServiceKeyNameW
#define GetServiceDisplayName GetServiceDisplayNameW
#define OpenSCManager OpenSCManagerW
#define OpenService OpenServiceW
#define QueryServiceConfig QueryServiceConfigW
#define QueryServiceLockStatus QueryServiceLockStatusW
#define RegisterServiceCtrlHandler RegisterServiceCtrlHandlerW
#define StartServiceCtrlDispatcher StartServiceCtrlDispatcherW
#define StartService StartServiceW
#define CommDlg_OpenSave_GetSpec CommDlg_OpenSave_GetSpecW
#define CommDlg_OpenSave_GetFilePath CommDlg_OpenSave_GetFilePathW
#define CommDlg_OpenSave_GetFolderPath CommDlg_OpenSave_GetFolderPathW
#define GetPrivateProfileStruct GetPrivateProfileStructW
#define LVCOLUMN LVCOLUMNW
#define GetVolumeNameForVolumeMountPoint GetVolumeNameForVolumeMountPointW
#define GetVolumePathName GetVolumePathNameW
#define GetVolumePathNamesForVolumeName GetVolumePathNamesForVolumeNameW
#define DeleteVolumeMountPoint DeleteVolumeMountPointW
#define SetVolumeMountPoint SetVolumeMountPointW
#define FindNextVolumeMountPoint FindNextVolumeMountPointW
#define FindFirstVolumeMountPoint FindFirstVolumeMountPointW
#define FindNextVolume FindNextVolumeW
#define FindFirstVolume FindFirstVolumeW
#define GetGlyphIndices GetGlyphIndicesW
#else
#define GetGlyphIndices GetGlyphIndicesA
#define GetLongPathName GetLongPathNameA
#define GetDiskFreeSpaceEx GetDiskFreeSpaceExA
#define CreateProcessAsUser CreateProcessAsUserA
#define HDITEM HDITEMA
#define LPHDITEM LPHDITEMA
#define COMBOBOXEXITEM	COMBOBOXEXITEMA
#define PCOMBOBOXEXITEM	PCOMBOBOXEXITEMA
#define PCCOMBOBOXEXITEM	PCCOMBOBOXEXITEMA
#define CBEM_INSERTITEM	CBEM_INSERTITEMA
#define CBEM_SETITEM	CBEM_SETITEMA
#define CBEM_GETITEM	CBEM_GETITEMA
#define DATETIMEPICK_CLASS	DATETIMEPICK_CLASSA
#define DATETIMEPICK_CLASS	DATETIMEPICK_CLASSA
#define DTN_USERSTRING	DTN_USERSTRINGA
#define NMDATETIMESTRING	NMDATETIMESTRINGA
#define LPNMDATETIMESTRING	LPNMDATETIMESTRINGA
#define DTN_WMKEYDOWN	DTN_WMKEYDOWNA
#define NMDATETIMEWMKEYDOWN	NMDATETIMEWMKEYDOWNA
#define LPNMDATETIMEWMKEYDOWN	LPNMDATETIMEWMKEYDOWNA
#define DTN_FORMAT	DTN_FORMATA
#define NMDATETIMEFORMAT	NMDATETIMEFORMATA
#define LPNMDATETIMEFORMAT	LPNMDATETIMEFORMATA
#define DTN_FORMATQUERY	DTN_FORMATQUERYA
#define NMDATETIMEFORMATQUERY	NMDATETIMEFORMATQUERYA
#define LPNMDATETIMEFORMATQUERY	LPNMDATETIMEFORMATQUERYA
#define RegConnectRegistry RegConnectRegistryA
#define RegCreateKey RegCreateKeyA
#define RegCreateKeyEx RegCreateKeyExA
#define RegDeleteKey RegDeleteKeyA
#define RegDeleteValue RegDeleteValueA
#define RegEnumKey RegEnumKeyA
#define RegEnumKeyEx RegEnumKeyExA
#define RegEnumValue RegEnumValueA
#define RegLoadKey RegLoadKeyA
#define RegOpenKey RegOpenKeyA
#define RegOpenKeyEx RegOpenKeyExA
#define RegQueryInfoKey RegQueryInfoKeyA
#define RegQueryValue RegQueryValueA
#define RegQueryMultipleValues RegQueryMultipleValuesA
#define RegQueryValueEx RegQueryValueExA
#define RegReplaceKey RegReplaceKeyA
#define RegRestoreKey RegRestoreKeyA
#define RegSaveKey RegSaveKeyA
#define RegSetValue RegSetValueA
#define RegSetValueEx RegSetValueExA
#define AbortSystemShutdown AbortSystemShutdownA
#define InitiateSystemShutdown InitiateSystemShutdownA
#define RegUnLoadKey RegUnLoadKeyA
#define LoadIcon LoadIconA
#define LoadImage LoadImageA
#define LoadString LoadStringA
#define IsDialogMessage IsDialogMessageA
#define DlgDirList DlgDirListA
#define DlgDirSelectEx DlgDirSelectExA
#define DlgDirListComboBox DlgDirListComboBoxA
#define DlgDirSelectComboBoxEx DlgDirSelectComboBoxExA
#define DefFrameProc DefFrameProcA
#define DefMDIChildProc DefMDIChildProcA
#define CreateMDIWindow CreateMDIWindowA
#define WinHelp WinHelpA
#define ChangeDisplaySettings ChangeDisplaySettingsA
#define ChangeDisplaySettingsEx ChangeDisplaySettingsExA
#define EnumDisplaySettings EnumDisplaySettingsA
#define SystemParametersInfo SystemParametersInfoA
#define GetWindowLong GetWindowLongA
#define SetWindowLong SetWindowLongA
#define GetWindowLongPtrA	GetWindowLongA
#define GetWindowLongPtr	GetWindowLongPtrA
#define SetWindowLongPtr	SetWindowLongPtrA
#define GetClassLong GetClassLongA
#define GetClassLongPtr	GetClassLongPtrA
#define SetClassLongPtr	SetClassLongPtrA
#define SetClassLong SetClassLongA
#define FindWindow FindWindowA
#define FindWindowEx FindWindowExA
#define GetClassName GetClassNameA
#define SetWindowsHookEx SetWindowsHookExA
#define SetWindowsHook SetWindowsHookA
#define LoadBitmap LoadBitmapA
#define LoadCursor LoadCursorA
#define LoadCursorFromFile LoadCursorFromFileA
#define SetProp SetPropA
#define GetProp GetPropA
#define RemoveProp RemovePropA
#define EnumPropsEx EnumPropsExA
#define EnumProps EnumPropsA
#define SetWindowText SetWindowTextA
#define GetWindowText GetWindowTextA
#define GetWindowTextLength GetWindowTextLengthA
#define MessageBox MessageBoxA
#define MessageBoxEx MessageBoxExA
#define MessageBoxIndirect MessageBoxIndirectA
#define AddFontResource AddFontResourceA
#define CopyMetaFile CopyMetaFileA
#define CreateDC CreateDCA
#define CreateFontIndirect CreateFontIndirectA
#define CreateFont CreateFontA
#define CreateIC CreateICA
#define CreateMetaFile CreateMetaFileA
#define CreateScalableFontResource CreateScalableFontResourceA
#define DeviceCapabilities DeviceCapabilitiesA
#define EnumFontFamiliesEx EnumFontFamiliesExA
#define EnumFontFamilies EnumFontFamiliesA
#define EnumFonts EnumFontsA
#define GetCharWidth GetCharWidthA
#define GetCharWidth32 GetCharWidth32A
#define GetCharWidthFloat GetCharWidthFloatA
#define GetCharABCWidths GetCharABCWidthsA
#define GetCharABCWidthsFloat GetCharABCWidthsFloatA
#define GetGlyphOutline GetGlyphOutlineA
#define GetMetaFile GetMetaFileA
#define GetOutlineTextMetrics GetOutlineTextMetricsA
#define GetTextExtentPoint GetTextExtentPointA
#define GetTextExtentPoint32 GetTextExtentPoint32A
#define GetTextExtentExPoint GetTextExtentExPointA
#define GetCharacterPlacement GetCharacterPlacementA
#define ResetDC ResetDCA
#define RemoveFontResource RemoveFontResourceA
#define CopyEnhMetaFile CopyEnhMetaFileA
#define CreateEnhMetaFile CreateEnhMetaFileA
#define GetEnhMetaFile GetEnhMetaFileA
#define GetEnhMetaFileDescription GetEnhMetaFileDescriptionA
#define GetTextMetrics GetTextMetricsA
#define StartDoc StartDocA
#define GetObject GetObjectA
#define TextOut TextOutA
#define ExtTextOut ExtTextOutA
#define PolyTextOut PolyTextOutA
#define GetTextFace GetTextFaceA
#define GetKerningPairs GetKerningPairsA
#define GetLogColorSpace GetLogColorSpaceA
#define CreateColorSpace CreateColorSpaceA
#define GetICMProfile GetICMProfileA
#define SetICMProfile SetICMProfileA
#define UpdateICMRegKey UpdateICMRegKeyA
#define EnumICMProfiles EnumICMProfilesA
#define CreatePropertySheetPage CreatePropertySheetPageA
#define PropertySheet PropertySheetA
#define ImageList_LoadImage ImageList_LoadImageA
#define CreateStatusWindow CreateStatusWindowA
#define DrawStatusText DrawStatusTextA
#define GetOpenFileName GetOpenFileNameA
#define GetSaveFileName GetSaveFileNameA
#define GetFileTitle GetFileTitleA
#define ChooseColor ChooseColorA
#define FindText FindTextA
#define ReplaceText ReplaceTextA
#define ChooseFont ChooseFontA
#define PrintDlg PrintDlgA
#define PageSetupDlg PageSetupDlgA
#define DefWindowProc DefWindowProcA
#define CallWindowProc CallWindowProcA
#define RegisterClass RegisterClassA
#define UnregisterClass UnregisterClassA
#define GetClassInfo GetClassInfoA
#define RegisterClassEx RegisterClassExA
#define GetClassInfoEx GetClassInfoExA
#define CreateWindowEx CreateWindowExA
#define CreateWindow CreateWindowA
#define CreateDialogParam CreateDialogParamA
#define CreateDialogIndirectParam CreateDialogIndirectParamA
#define CreateDialog CreateDialogA
#define CreateDialogIndirect CreateDialogIndirectA
#define DialogBoxParam DialogBoxParamA
#define DialogBoxIndirectParam DialogBoxIndirectParamA
#define DialogBox DialogBoxA
#define DialogBoxIndirect DialogBoxIndirectA
#define RegisterClipboardFormat RegisterClipboardFormatA
#define SetDlgItemText SetDlgItemTextA
#define GetDlgItemText GetDlgItemTextA
#define SendDlgItemMessage SendDlgItemMessageA
#define DefDlgProc DefDlgProcA
#define CallMsgFilter CallMsgFilterA
#define GetClipboardFormatName GetClipboardFormatNameA
#define CharToOem CharToOemA
#define OemToChar OemToCharA
#define CharToOemBuff CharToOemBuffA
#define OemToCharBuff OemToCharBuffA
#define CharUpper CharUpperA
#define CharUpperBuff CharUpperBuffA
#define CharLower CharLowerA
#define CharLowerBuff CharLowerBuffA
#define CharNext CharNextA
#define CharPrev CharPrevA
#define IsCharAlpha IsCharAlphaA
#define IsCharAlphaNumeric IsCharAlphaNumericA
#define IsCharUpper IsCharUpperA
#define IsCharLower IsCharLowerA
#define GetKeyNameText GetKeyNameTextA
#define VkKeyScan VkKeyScanA
#define VkKeyScanEx VkKeyScanExA
#define MapVirtualKey MapVirtualKeyA
#define MapVirtualKeyEx MapVirtualKeyExA
#define LoadAccelerators LoadAcceleratorsA
#define CreateAcceleratorTable CreateAcceleratorTableA
#define CopyAcceleratorTable CopyAcceleratorTableA
#define TranslateAccelerator TranslateAcceleratorA
#define LoadMenu LoadMenuA
#define LoadMenuIndirect LoadMenuIndirectA
#define ChangeMenu ChangeMenuA
#define GetMenuString GetMenuStringA
#define InsertMenu InsertMenuA
#define AppendMenu AppendMenuA
#define ModifyMenu ModifyMenuA
#define InsertMenuItem InsertMenuItemA
#define GetMenuItemInfo GetMenuItemInfoA
#define SetMenuItemInfo SetMenuItemInfoA
#define DrawText DrawTextA
#define DrawTextEx DrawTextExA
#define GrayString GrayStringA
#define DrawState DrawStateA
#define TabbedTextOut TabbedTextOutA
#define GetTabbedTextExtent GetTabbedTextExtentA
#define GetVersionEx GetVersionExA
#define wvsprintf wvsprintfA
#define wsprintf wsprintfA
#define LoadKeyboardLayout LoadKeyboardLayoutA
#define GetKeyboardLayoutName GetKeyboardLayoutNameA
#define CreateDesktop CreateDesktopA
#define OpenDesktop OpenDesktopA
#define EnumDesktops EnumDesktopsA
#define CreateWindowStation CreateWindowStationA
#define OpenWindowStation OpenWindowStationA
#define EnumWindowStations EnumWindowStationsA
#define IsBadStringPtr IsBadStringPtrA
#define LookupAccountSid LookupAccountSidA
#define LookupAccountName LookupAccountNameA
#define LookupPrivilegeValue LookupPrivilegeValueA
#define LookupPrivilegeName LookupPrivilegeNameA
#define LookupPrivilegeDisplayName LookupPrivilegeDisplayNameA
#define BuildCommDCB BuildCommDCBA
#define BuildCommDCBAndTimeouts BuildCommDCBAndTimeoutsA
#define CommConfigDialog CommConfigDialogA
#define GetDefaultCommConfig GetDefaultCommConfigA
#define SetDefaultCommConfig SetDefaultCommConfigA
#define GetComputerName GetComputerNameA
#define SetComputerName SetComputerNameA
#define GetUserName GetUserNameA
#define CreateMailslot CreateMailslotA
#define FormatMessage FormatMessageA
#define GetEnvironmentStrings GetEnvironmentStringsA
#define FreeEnvironmentStrings FreeEnvironmentStringsA
#define lstrcmp lstrcmpA
#define lstrcmpi lstrcmpiA
#define lstrcpyn lstrcpynA
#define lstrcpy lstrcpyA
#define lstrcat lstrcatA
#define lstrlen lstrlenA
#define GetBinaryType GetBinaryTypeA
#define GetShortPathName GetShortPathNameA
#define SetFileSecurity SetFileSecurityA
#define GetFileSecurity GetFileSecurityA
#define FindFirstChangeNotification FindFirstChangeNotificationA
#define AccessCheckAndAuditAlarm AccessCheckAndAuditAlarmA
#define ObjectOpenAuditAlarm ObjectOpenAuditAlarmA
#define ObjectPrivilegeAuditAlarm ObjectPrivilegeAuditAlarmA
#define ObjectCloseAuditAlarm ObjectCloseAuditAlarmA
#define PrivilegedServiceAuditAlarm PrivilegedServiceAuditAlarmA
#define OpenEventLog OpenEventLogA
#define RegisterEventSource RegisterEventSourceA
#define OpenBackupEventLog OpenBackupEventLogA
#define ReadEventLog ReadEventLogA
#define ReportEvent ReportEventA
#define CreateProcess CreateProcessA
#define FatalAppExit FatalAppExitA
#define GetStartupInfo GetStartupInfoA
#define GetCommandLine GetCommandLineA
#define GetEnvironmentVariable GetEnvironmentVariableA
#define SetEnvironmentVariable SetEnvironmentVariableA
#define ExpandEnvironmentStrings ExpandEnvironmentStringsA
#define OutputDebugString OutputDebugStringA
#define FindResource FindResourceA
#define FindResourceEx FindResourceExA
#define EnumResourceTypes EnumResourceTypesA
#define EnumResourceNames EnumResourceNamesA
#define EnumResourceLanguages EnumResourceLanguagesA
#define BeginUpdateResource BeginUpdateResourceA
#define UpdateResource UpdateResourceA
#define EndUpdateResource EndUpdateResourceA
#define GlobalAddAtom GlobalAddAtomA
#define GlobalFindAtom GlobalFindAtomA
#define GlobalGetAtomName GlobalGetAtomNameA
#define AddAtom AddAtomA
#define FindAtom FindAtomA
#define GetProfileInt GetProfileIntA
#define GetAtomName GetAtomNameA
#define GetProfileString GetProfileStringA
#define WriteProfileString WriteProfileStringA
#define GetProfileSection GetProfileSectionA
#define WriteProfileSection WriteProfileSectionA
#define GetPrivateProfileInt GetPrivateProfileIntA
#define GetPrivateProfileSectionNames GetPrivateProfileSectionNamesA
#define GetPrivateProfileString GetPrivateProfileStringA
#define WritePrivateProfileString WritePrivateProfileStringA
#define WritePrivateProfileStruct WritePrivateProfileStructA
#define GetPrivateProfileSection GetPrivateProfileSectionA
#define WritePrivateProfileSection WritePrivateProfileSectionA
#define GetDriveType GetDriveTypeA
#define GetSystemDirectory GetSystemDirectoryA
#define GetTempPath GetTempPathA
#define GetTempFileName GetTempFileNameA
#define GetWindowsDirectory GetWindowsDirectoryA
#define SetCurrentDirectory SetCurrentDirectoryA
#define GetCurrentDirectory GetCurrentDirectoryA
#define GetDiskFreeSpace GetDiskFreeSpaceA
#define CreateDirectory CreateDirectoryA
#define CreateDirectoryEx CreateDirectoryExA
#define RemoveDirectory RemoveDirectoryA
#define GetFullPathName GetFullPathNameA
#define DefineDosDevice DefineDosDeviceA
#define QueryDosDevice QueryDosDeviceA
#define CreateFile CreateFileA
#define SetFileAttributes SetFileAttributesA
#define GetFileAttributes GetFileAttributesA
#define GetCompressedFileSize GetCompressedFileSizeA
#define DeleteFile DeleteFileA
#define FindFirstFile FindFirstFileA
#define FindFirstFileEx FindFirstFileExA
#define FindNextFile FindNextFileA
#define SearchPath SearchPathA
#define CopyFile CopyFileA
#define CopyFileEx CopyFileExA
#define CreateHardLink CreateHardLinkA
#define MoveFile MoveFileA
#define MoveFileEx MoveFileExA
#define MoveFileWithProgress MoveFileWithProgressA
#define CreateNamedPipe CreateNamedPipeA
#define GetNamedPipeHandleState GetNamedPipeHandleStateA
#define CallNamedPipe CallNamedPipeA
#define WaitNamedPipe WaitNamedPipeA
#define SetVolumeLabel SetVolumeLabelA
#define GetVolumeInformation GetVolumeInformationA
#define ClearEventLog ClearEventLogA
#define BackupEventLog BackupEventLogA
#define CreateMutex CreateMutexA
#define OpenMutex OpenMutexA
#define CreateEvent CreateEventA
#define OpenEvent OpenEventA
#define CreateSemaphore CreateSemaphoreA
#define OpenSemaphore OpenSemaphoreA
#define CreateFileMapping CreateFileMappingA
#define OpenFileMapping OpenFileMappingA
#define GetLogicalDriveStrings GetLogicalDriveStringsA
#define LoadLibrary LoadLibraryA
#define LoadLibraryEx LoadLibraryExA
#define GetModuleFileName GetModuleFileNameA
#define GetModuleHandle GetModuleHandleA
#define GetUserObjectInformation GetUserObjectInformationA
#define SetUserObjectInformation SetUserObjectInformationA
#define RegisterWindowMessage RegisterWindowMessageA
#define GetMessage GetMessageA
#define DispatchMessage DispatchMessageA
#define PeekMessage PeekMessageA
#define SendMessage SendMessageA
#define SendMessageTimeout SendMessageTimeoutA
#define SendNotifyMessage SendNotifyMessageA
#define SendMessageCallback SendMessageCallbackA
#define PostMessage PostMessageA
#define PostThreadMessage PostThreadMessageA
#define VerFindFile VerFindFileA
#define VerInstallFile VerInstallFileA
#define GetFileVersionInfoSize GetFileVersionInfoSizeA
#define GetFileVersionInfo GetFileVersionInfoA
#define VerLanguageName VerLanguageNameA
#define VerQueryValue VerQueryValueA
#define CompareString CompareStringA
#define LCMapString LCMapStringA
#define GetLocaleInfo GetLocaleInfoA
#define SetLocaleInfo SetLocaleInfoA
#define GetTimeFormat GetTimeFormatA
#define GetDateFormat GetDateFormatA
#define GetNumberFormat GetNumberFormatA
#define GetCurrencyFormat GetCurrencyFormatA
#define EnumCalendarInfo EnumCalendarInfoA
#define EnumTimeFormats EnumTimeFormatsA
#define FoldString FoldStringA
#define EnumSystemCodePages EnumSystemCodePagesA
#define EnumSystemLocales EnumSystemLocalesA
#define GetStringTypeEx GetStringTypeExA
#define EnumDateFormats EnumDateFormatsA
#define GetConsoleTitle GetConsoleTitleA
#define ScrollConsoleScreenBuffer ScrollConsoleScreenBufferA
#define SetConsoleTitle SetConsoleTitleA
#define ReadConsole ReadConsoleA
#define WriteConsole WriteConsoleA
#define PeekConsoleInput PeekConsoleInputA
#define ReadConsoleInput ReadConsoleInputA
#define WriteConsoleInput WriteConsoleInputA
#define ReadConsoleOutput ReadConsoleOutputA
#define WriteConsoleOutput WriteConsoleOutputA
#define ReadConsoleOutputCharacter ReadConsoleOutputCharacterA
#define WriteConsoleOutputCharacter WriteConsoleOutputCharacterA
#define FillConsoleOutputCharacter FillConsoleOutputCharacterA
#define MultinetGetConnectionPerformance MultinetGetConnectionPerformanceA
#define WNetGetLastError WNetGetLastErrorA
#define WNetGetProviderName WNetGetProviderNameA
#define WNetGetNetworkInformation WNetGetNetworkInformationA
#define WNetConnectionDialog1 WNetConnectionDialog1A
#define WNetDisconnectDialog1 WNetDisconnectDialog1A
#define WNetOpenEnum WNetOpenEnumA
#define WNetEnumResource WNetEnumResourceA
#define WNetGetUniversalName WNetGetUniversalNameA
#define WNetGetUser WNetGetUserA
#define WNetAddConnection WNetAddConnectionA
#define WNetAddConnection2 WNetAddConnection2A
#define WNetAddConnection3 WNetAddConnection3A
#define WNetCancelConnection WNetCancelConnectionA
#define WNetCancelConnection2 WNetCancelConnection2A
#define WNetGetConnection WNetGetConnectionA
#define WNetUseConnection WNetUseConnectionA
#define WNetSetConnection WNetSetConnectionA
#define OpenService OpenServiceA
#define QueryServiceConfig QueryServiceConfigA
#define QueryServiceLockStatus QueryServiceLockStatusA
#define RegisterServiceCtrlHandler RegisterServiceCtrlHandlerA
#define StartServiceCtrlDispatcher StartServiceCtrlDispatcherA
#define StartService StartServiceA
#define ChangeServiceConfig ChangeServiceConfigA
#define CreateService CreateServiceA
#define EnumDependentServices EnumDependentServicesA
#define EnumServicesStatus EnumServicesStatusA
#define GetServiceKeyName GetServiceKeyNameA
#define GetServiceDisplayName GetServiceDisplayNameA
#define OpenSCManager OpenSCManagerA
#define CommDlg_OpenSave_GetSpec CommDlg_OpenSave_GetSpecA
#define CommDlg_OpenSave_GetFilePath CommDlg_OpenSave_GetFilePathA
#define CommDlg_OpenSave_GetFolderPath CommDlg_OpenSave_GetFolderPathA
#define GetPrivateProfileStruct GetPrivateProfileStructA
#define LVCOLUMN LVCOLUMNA
#define GetVolumeNameForVolumeMountPoint GetVolumeNameForVolumeMountPointA
#define GetVolumePathName GetVolumePathNameA
#define GetVolumePathNamesForVolumeName GetVolumePathNamesForVolumeNameA
#define DeleteVolumeMountPoint DeleteVolumeMountPointA
#define SetVolumeMountPoint SetVolumeMountPointA
#define FindNextVolumeMountPoint FindNextVolumeMountPointA
#define FindFirstVolumeMountPoint FindFirstVolumeMountPointA
#define FindNextVolume FindNextVolumeA
#define FindFirstVolume FindFirstVolumeA
#endif
long get_osfhandle(int);
#define _get_osfhandle get_osfhandle
BOOL AbnormalTermination(VOID);
int AbortDoc(HDC);
BOOL AbortPrinter(HANDLE);
BOOL CALLBACK AbortProc(HDC,int);
LONG InterlockedIncrement(LPLONG);
LONG WINAPI InterlockedExchangeAdd ( LONG volatile *Addend, LONG Value );
LONG WINAPI InterlockedCompareExchange ( LONG volatile *Destination, LONG Exchange, LONG Comperand );
LONG InterlockedDecrement(LPLONG);
LONG InterlockedExchange(LPLONG,LONG);
BOOL FreeResource(HGLOBAL);
LPVOID LockResource(HGLOBAL);
int WinMain(HINSTANCE,HINSTANCE,LPSTR,int);
BOOL FreeLibrary(HINSTANCE);
VOID FreeLibraryAndExitThread(HMODULE,DWORD);
BOOL DisableThreadLibraryCalls(HMODULE);
FARPROC GetProcAddress(HINSTANCE,LPCSTR);
DWORD GetVersion(VOID);
HGLOBAL GlobalAlloc(UINT,DWORD);
HGLOBAL GlobalDiscard(HGLOBAL);
HGLOBAL GlobalReAlloc(HGLOBAL,DWORD,UINT);
DWORD GlobalSize(HGLOBAL);
UINT GlobalFlags(HGLOBAL);
LPVOID GlobalLock(HGLOBAL);
HGLOBAL GlobalHandle(LPCVOID);
BOOL GlobalUnlock(HGLOBAL);
HGLOBAL GlobalFree(HGLOBAL);
UINT GlobalCompact(DWORD);
VOID GlobalFix(HGLOBAL);
VOID GlobalUnfix(HGLOBAL);
LPVOID GlobalWire(HGLOBAL);
BOOL GlobalUnWire(HGLOBAL);
VOID GlobalMemoryStatus(LPMEMORYSTATUS);
BOOL GlobalMemoryStatusEx(LPMEMORYSTATUSEX);
HLOCAL LocalAlloc(UINT,UINT);
HLOCAL LocalDiscard(HLOCAL);
HLOCAL LocalReAlloc(HLOCAL,UINT,UINT);
LPVOID LocalLock(HLOCAL);
HLOCAL LocalHandle(LPCVOID);
BOOL LocalUnlock(HLOCAL);
UINT LocalSize(HLOCAL);
UINT LocalFlags(HLOCAL);
HLOCAL LocalFree(HLOCAL);
UINT LocalShrink(HLOCAL,UINT);
UINT LocalCompact(UINT);
BOOL FlushInstructionCache(HANDLE,LPCVOID,DWORD);
LPVOID VirtualAlloc(LPVOID,DWORD,DWORD,DWORD);
LPVOID WINAPI VirtualAllocEx(HANDLE,LPVOID,unsigned long,DWORD,DWORD);
BOOL VirtualFree(LPVOID,DWORD,DWORD);
BOOL WINAPI VirtualFreeEx(HANDLE,LPVOID,DWORD,DWORD);
BOOL VirtualProtect(LPVOID,DWORD,DWORD,PDWORD);
DWORD VirtualQuery(LPCVOID,PMEMORY_BASIC_INFORMATION,DWORD);
BOOL VirtualProtectEx(HANDLE,LPVOID,DWORD,DWORD,PDWORD);
DWORD VirtualQueryEx(HANDLE,LPCVOID,PMEMORY_BASIC_INFORMATION,DWORD);
HANDLE HeapCreate(DWORD,DWORD,DWORD);
BOOL HeapDestroy(HANDLE);
LPVOID HeapAlloc(HANDLE,DWORD,DWORD);
LPVOID HeapReAlloc(HANDLE,DWORD,LPVOID,DWORD);
BOOL HeapFree(HANDLE,DWORD,LPVOID);
DWORD HeapSize(HANDLE,DWORD,LPCVOID);
BOOL HeapValidate(HANDLE,DWORD,LPCVOID);
UINT HeapCompact(HANDLE,DWORD);
HANDLE GetProcessHeap(VOID);
DWORD WINAPI GetProcessIdOfThread(HANDLE);
DWORD WINAPI GetProcessId(HANDLE);
DWORD WINAPI GetCurrentProcessorNumber(void);
BOOL WINAPI GetProcessHandleCount(HANDLE,PDWORD);
BOOL WINAPI GetProcessIoCounters(HANDLE,PIO_COUNTERS);
BOOL WINAPI GetProcessWorkingSetSize(HANDLE,PSIZE_T,PSIZE_T);
BOOL WINAPI GetProcessWorkingSetSizeEx(HANDLE,PSIZE_T,PSIZE_T,PDWORD);
BOOL WINAPI SetProcessWorkingSetSize(HANDLE,SIZE_T,SIZE_T);
BOOL WINAPI SetProcessWorkingSetSizeEx(HANDLE,SIZE_T,SIZE_T,DWORD);
DWORD GetProcessHeaps(DWORD,PHANDLE);
DWORD GetProcessVersion(DWORD);
BOOL WINAPI SetEnvironmentStringsA(LPSTR);
BOOL WINAPI SetEnvironmentStringsW(LPWSTR);
BOOL HeapLock(HANDLE);
BOOL HeapUnlock(HANDLE);
BOOL HeapWalk(HANDLE,LPPROCESS_HEAP_ENTRY);
BOOL GetProcessAffinityMask(HANDLE,LPDWORD,LPDWORD);
BOOL GetProcessTimes(HANDLE,LPFILETIME,LPFILETIME,LPFILETIME,LPFILETIME);
BOOL GetProcessWorkingSetSize(HANDLE,LPDWORD,LPDWORD);
BOOL SetProcessWorkingSetSize(HANDLE,DWORD,DWORD);
BOOL WINAPI SetProcessAffinityMask(HANDLE,DWORD);
BOOL WINAPI SetProcessPriorityBoost(HANDLE,BOOL);
BOOL WINAPI GetProcessPriorityBoost(HANDLE,BOOL *);
BOOL WINAPI RequestWakeupLatency(LATENCY_TIME);
BOOL WINAPI IsSystemResumeAutomatic(VOID);
HANDLE WINAPI OpenThread(DWORD,BOOL,DWORD);
HANDLE OpenProcess(DWORD,BOOL,DWORD);
HANDLE GetCurrentProcess(VOID);
DWORD GetCurrentProcessId(VOID);
BOOL ProcessIdToSessionId(DWORD DWORD);
VOID ExitProcess(UINT);
BOOL TerminateProcess(HANDLE,UINT);
BOOL GetExitCodeProcess(HANDLE,LPDWORD);
VOID FatalExit(int);
LPTSTR GetEnvironmentStrings(VOID);
VOID RaiseException(DWORD,DWORD,DWORD,CONST DWORD *);
LONG UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *);
LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER);
HANDLE CreateThread(LPSECURITY_ATTRIBUTES,DWORD,LPTHREAD_START_ROUTINE,LPVOID,DWORD,LPDWORD);
HANDLE CreateRemoteThread(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,LPTHREAD_START_ROUTINE,LPVOID,DWORD,LPDWORD);
HANDLE GetCurrentThread(VOID);
DWORD GetCurrentThreadId(VOID);
DWORD SetThreadAffinityMask(HANDLE,DWORD);
DWORD WINAPI SetThreadIdealProcessor(HANDLE,DWORD);
BOOL SetThreadPriority(HANDLE,int);
int GetThreadPriority(HANDLE);
BOOL WINAPI SetThreadPriorityBoost(HANDLE,BOOL);
BOOL WINAPI GetThreadPriorityBoost(HANDLE,BOOL *);
BOOL GetThreadTimes(HANDLE,LPFILETIME,LPFILETIME,LPFILETIME,LPFILETIME);
BOOL WINAPI GetGUIThreadInfo(DWORD,PGUITHREADINFO pgui);
VOID ExitThread(DWORD);
BOOL TerminateThread(HANDLE,DWORD);
EXECUTION_STATE WINAPI SetThreadExecutionState(EXECUTION_STATE);
BOOL GetExitCodeThread(HANDLE,LPDWORD);
BOOL GetThreadSelectorEntry(HANDLE,DWORD,LPLDT_ENTRY);
DWORD GetLastError(VOID);
VOID WINAPI RestoreLastError(DWORD);
VOID SetLastError(DWORD);
BOOL GetOverlappedResult(HANDLE,LPOVERLAPPED,LPDWORD,BOOL);
HANDLE CreateIoCompletionPort(HANDLE,HANDLE,DWORD,DWORD);
BOOL GetQueuedCompletionStatus(HANDLE,LPDWORD,LPDWORD,LPOVERLAPPED *,DWORD);
BOOL WINAPI PostQueuedCompletionStatus(HANDLE,DWORD,long long int *,LPOVERLAPPED);
DWORD WINAPI QueueUserAPC(PAPCFUNC,HANDLE,long long int *);
BOOL WINAPI IsDebuggerPresent(void);
UINT SetErrorMode(UINT);
BOOL ReadProcessMemory(HANDLE,LPCVOID,LPVOID,DWORD,LPDWORD);
BOOL WriteProcessMemory(HANDLE,LPVOID,LPVOID,DWORD,LPDWORD);
BOOL GetThreadContext(HANDLE,LPCONTEXT);
BOOL SetThreadContext(HANDLE,CONST CONTEXT *);
DWORD SuspendThread(HANDLE);
DWORD ResumeThread(HANDLE);
VOID DebugBreak(VOID);
BOOL WaitForDebugEvent(LPDEBUG_EVENT,DWORD);
BOOL ContinueDebugEvent(DWORD,DWORD,DWORD);
BOOL DebugActiveProcess(DWORD);
BOOL WINAPI DebugActiveProcessStop(DWORD);
BOOL WINAPI DebugSetProcessKillOnExit(BOOL);
BOOL WINAPI DebugBreakProcess(HANDLE);
BOOL WINAPI CheckRemoteDebuggerPresent(HANDLE,PBOOL);
VOID InitializeCriticalSection(LPCRITICAL_SECTION);
VOID EnterCriticalSection(LPCRITICAL_SECTION);
VOID LeaveCriticalSection(LPCRITICAL_SECTION);
VOID DeleteCriticalSection(LPCRITICAL_SECTION);
BOOL WINAPI InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION,DWORD);
WINBASEAPI DWORD WINAPI SetCriticalSectionSpinCount(LPCRITICAL_SECTION,DWORD);
WINBASEAPI BOOL WINAPI TryEnterCriticalSection(LPCRITICAL_SECTION);
BOOL SetEvent(HANDLE);
BOOL ResetEvent(HANDLE);
BOOL PulseEvent(HANDLE);
BOOL ReleaseSemaphore(HANDLE,LONG,LPLONG);
BOOL ReleaseMutex(HANDLE);
DWORD WaitForSingleObject(HANDLE,DWORD);
DWORD WaitForMultipleObjects(DWORD,CONST HANDLE *,BOOL,DWORD);
VOID Sleep(DWORD);
HGLOBAL LoadResource(HINSTANCE,HRSRC);
DWORD SizeofResource(HINSTANCE,HRSRC);
ATOM GlobalDeleteAtom(ATOM);
BOOL InitAtomTable(DWORD);
ATOM DeleteAtom(ATOM);
UINT SetHandleCount(UINT);
DWORD GetLogicalDrives(VOID);
BOOL LockFile( HANDLE,DWORD,DWORD,DWORD,DWORD);
BOOL UnlockFile(HANDLE,DWORD,DWORD,DWORD,DWORD);
BOOL LockFileEx(HANDLE,DWORD,DWORD,DWORD,DWORD,LPOVERLAPPED);
BOOL UnlockFileEx(HANDLE,DWORD,DWORD,DWORD,LPOVERLAPPED);
BOOL GetFileInformationByHandle(HANDLE,LPBY_HANDLE_FILE_INFORMATION);
DWORD GetFileType(HANDLE);
DWORD GetFileSize(HANDLE,LPDWORD);
BOOL WINAPI GetFileSizeEx(HANDLE,PLARGE_INTEGER);
HANDLE GetStdHandle(DWORD);
BOOL SetStdHandle(DWORD,HANDLE);
BOOL WriteFile(HANDLE,LPCVOID,DWORD,LPDWORD,LPOVERLAPPED);
BOOL ReadFile(HANDLE,LPVOID,DWORD,LPDWORD,LPOVERLAPPED);
BOOL WINAPI ReadFileScatter(HANDLE h,FILE_SEGMENT_ELEMENT aSegmentArray[],DWORD,LPDWORD,LPOVERLAPPED);
BOOL WINAPI WriteFileGather(HANDLE hFile,FILE_SEGMENT_ELEMENT aSegmentArray[],DWORD n,LPDWORD l,LPOVERLAPPED);
BOOL FlushFileBuffers(HANDLE);
BOOL DeviceIoControl(HANDLE,DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD,LPOVERLAPPED);
BOOL WINAPI RequestDeviceWakeup(HANDLE);
BOOL WINAPI CancelDeviceWakeupRequest(HANDLE);
BOOL WINAPI GetDevicePowerState(HANDLE,BOOL *);
BOOL WINAPI SetMessageWaitingIndicator(HANDLE,ULONG);
BOOL SetEndOfFile(HANDLE);
DWORD SetFilePointer(HANDLE,LONG,PLONG,DWORD);
BOOL WINAPI SetFilePointerEx(HANDLE,LARGE_INTEGER,PLARGE_INTEGER,DWORD);
BOOL WINAPI SetFileValidData(HANDLE,LONGLONG);
BOOL WINAPI SetFileShortNameA(HANDLE,LPCSTR);
BOOL WINAPI SetFileShortNameW(HANDLE,LPCWSTR);
BOOL FindClose(HANDLE);
BOOL GetFileTime(HANDLE,LPFILETIME,LPFILETIME,LPFILETIME);
BOOL SetFileTime(HANDLE,CONST FILETIME *,CONST FILETIME *,CONST FILETIME *);
BOOL CloseHandle(HANDLE);
BOOL DuplicateHandle(HANDLE,HANDLE,HANDLE,LPHANDLE,DWORD,BOOL,DWORD);
BOOL GetHandleInformation(HANDLE,LPDWORD);
BOOL SetHandleInformation(HANDLE,DWORD,DWORD);
DWORD LoadModule(LPCSTR,LPVOID);
UINT WinExec(LPCSTR,UINT);
BOOL ClearCommBreak(HANDLE);
BOOL ClearCommError(HANDLE,LPDWORD,LPCOMSTAT);
BOOL SetupComm(HANDLE,DWORD,DWORD);
BOOL EscapeCommFunction(HANDLE,DWORD);
BOOL GetCommConfig(HANDLE,LPCOMMCONFIG,LPDWORD);
BOOL GetCommMask(HANDLE,LPDWORD);
BOOL GetCommProperties(HANDLE,LPCOMMPROP);
BOOL GetCommModemStatus(HANDLE,LPDWORD);
BOOL GetCommState(HANDLE,LPDCB);
BOOL GetCommTimeouts(HANDLE,LPCOMMTIMEOUTS);
BOOL PurgeComm(HANDLE,DWORD);
BOOL SetCommBreak(HANDLE);
BOOL SetCommConfig(HANDLE,LPCOMMCONFIG,DWORD);
BOOL SetCommMask(HANDLE,DWORD);
BOOL SetCommState(HANDLE,LPDCB);
BOOL SetCommTimeouts(HANDLE,LPCOMMTIMEOUTS);
BOOL TransmitCommChar(HANDLE,char);
BOOL WaitCommEvent(HANDLE,LPDWORD,LPOVERLAPPED);
DWORD SetTapePosition(HANDLE,DWORD,DWORD,DWORD,DWORD,BOOL);
DWORD GetTapePosition(HANDLE,DWORD,LPDWORD,LPDWORD,LPDWORD);
DWORD PrepareTape(HANDLE,DWORD,BOOL);
DWORD EraseTape(HANDLE,DWORD,BOOL);
DWORD CreateTapePartition(HANDLE,DWORD,DWORD,DWORD);
DWORD WriteTapemark(HANDLE,DWORD,DWORD,BOOL);
DWORD GetTapeStatus(HANDLE);
DWORD GetTapeParameters(HANDLE,DWORD,LPDWORD,LPVOID);
DWORD SetTapeParameters( HANDLE,DWORD,LPVOID);
BOOL Beep(DWORD,DWORD);
VOID OpenSound(VOID);
VOID CloseSound(VOID);
VOID StartSound(VOID);
VOID StopSound(VOID);
DWORD WaitSoundState(DWORD);
DWORD SyncAllVoices(VOID);
DWORD CountVoiceNotes(DWORD nVoice);
LPDWORD GetThresholdEvent(VOID);
DWORD GetThresholdStatus(VOID);
DWORD SetSoundNoise(DWORD,DWORD);
DWORD SetVoiceAccent(DWORD,DWORD,DWORD,DWORD,DWORD);
DWORD SetVoiceEnvelope(DWORD,DWORD,DWORD);
DWORD SetVoiceNote(DWORD,DWORD,DWORD,DWORD);
DWORD SetVoiceQueueSize(DWORD,DWORD);
DWORD SetVoiceSound(DWORD,DWORD,DWORD);
DWORD SetVoiceThreshold(DWORD,DWORD);
int MulDiv(int,int,int);
VOID GetSystemTime(LPSYSTEMTIME);
VOID GetSystemTimeAsFileTime(LPFILETIME);
BOOL SetSystemTime(CONST SYSTEMTIME *);
BOOL SetSystemPowerState(BOOL,BOOL);
BOOL WINAPI GetSystemPowerStatus(LPSYSTEM_POWER_STATUS);
VOID GetLocalTime(LPSYSTEMTIME);
BOOL SetLocalTime(CONST SYSTEMTIME *);
VOID GetSystemInfo(LPSYSTEM_INFO);
BOOL SystemTimeToTzSpecificLocalTime(LPTIME_ZONE_INFORMATION,LPSYSTEMTIME,LPSYSTEMTIME);
DWORD GetTimeZoneInformation(LPTIME_ZONE_INFORMATION);
BOOL SetTimeZoneInformation(CONST TIME_ZONE_INFORMATION *);
BOOL SystemTimeToFileTime(CONST SYSTEMTIME *,LPFILETIME);
BOOL FileTimeToLocalFileTime(CONST FILETIME *,LPFILETIME);
BOOL LocalFileTimeToFileTime(CONST FILETIME *,LPFILETIME);
BOOL FileTimeToSystemTime(CONST FILETIME *,LPSYSTEMTIME);
LONG CompareFileTime(CONST FILETIME *,CONST FILETIME *);
BOOL FileTimeToDosDateTime(CONST FILETIME *,LPWORD,LPWORD);
BOOL DosDateTimeToFileTime(WORD,WORD,LPFILETIME);
DWORD GetTickCount(VOID);
BOOL SetSystemTimeAdjustment(DWORD,BOOL);
BOOL GetSystemTimeAdjustment(PDWORD,PDWORD,PWINBOOL);
BOOL CreatePipe(PHANDLE,PHANDLE,LPSECURITY_ATTRIBUTES,DWORD);
BOOL ConnectNamedPipe(HANDLE,LPOVERLAPPED);
BOOL DisconnectNamedPipe(HANDLE);
BOOL SetNamedPipeHandleState(HANDLE,LPDWORD,LPDWORD,LPDWORD);
BOOL GetNamedPipeInfo(HANDLE,LPDWORD,LPDWORD,LPDWORD,LPDWORD);
BOOL PeekNamedPipe(HANDLE,LPVOID,DWORD,LPDWORD,LPDWORD,LPDWORD);
BOOL TransactNamedPipe(HANDLE,LPVOID,DWORD,LPVOID,DWORD,LPDWORD,LPOVERLAPPED);
BOOL GetMailslotInfo(HANDLE,LPDWORD,LPDWORD,LPDWORD,LPDWORD);
BOOL SetMailslotInfo(HANDLE,DWORD);
LPVOID MapViewOfFile(HANDLE,DWORD,DWORD,DWORD,DWORD);
BOOL FlushViewOfFile(LPCVOID,DWORD);
BOOL UnmapViewOfFile(LPVOID);
HFILE OpenFile(LPCSTR,LPOFSTRUCT,UINT);
HFILE _lopen( LPCSTR,int);
HFILE _lcreat(LPCSTR,int);
UINT _lread(HFILE,LPVOID,UINT);
UINT _lwrite(HFILE,LPCSTR,UINT);
long _hread(HFILE,LPVOID,long);
long _hwrite(HFILE,LPCSTR,long);
HFILE _lclose(HFILE);
LONG _llseek(HFILE,LONG,int);
BOOL IsTextUnicode(CONST LPVOID,int,LPINT);
WINBASEAPI DWORD WINAPI FlsAlloc(PFLS_CALLBACK_FUNCTION);
WINBASEAPI PVOID WINAPI FlsGetValue(DWORD);
WINBASEAPI BOOL WINAPI FlsSetValue(DWORD,PVOID);
WINBASEAPI BOOL WINAPI FlsFree(DWORD);
DWORD TlsAlloc(VOID);
LPVOID TlsGetValue(DWORD);
BOOL TlsSetValue(DWORD,LPVOID);
BOOL TlsFree(DWORD);
DWORD SleepEx(DWORD,BOOL);
DWORD WaitForSingleObjectEx(HANDLE,DWORD,BOOL);
DWORD WaitForMultipleObjectsEx(DWORD,CONST HANDLE *,BOOL,DWORD,BOOL);
BOOL ReadFileEx(HANDLE,LPVOID,DWORD,LPOVERLAPPED,LPOVERLAPPED_COMPLETION_ROUTINE);
BOOL WriteFileEx( HANDLE,LPCVOID,DWORD,LPOVERLAPPED,LPOVERLAPPED_COMPLETION_ROUTINE);
BOOL BackupRead(HANDLE,LPBYTE,DWORD,LPDWORD,BOOL,BOOL,LPVOID *);
BOOL BackupSeek(HANDLE,DWORD,DWORD,LPDWORD,LPDWORD,LPVOID *);
BOOL BackupWrite(HANDLE,LPBYTE,DWORD,LPDWORD,BOOL,BOOL,LPVOID *);
BOOL SetProcessShutdownParameters(DWORD,DWORD);
BOOL GetProcessShutdownParameters(LPDWORD,LPDWORD);
VOID SetFileApisToOEM(VOID);
VOID SetFileApisToANSI(VOID);
BOOL AreFileApisANSI(VOID);
BOOL CloseEventLog(HANDLE);
BOOL DeregisterEventSource(HANDLE);
BOOL NotifyChangeEventLog (HANDLE,HANDLE);
BOOL GetNumberOfEventLogRecords(HANDLE,PDWORD);
BOOL GetOldestEventLogRecord(HANDLE,PDWORD);
BOOL DuplicateToken(HANDLE,SECURITY_IMPERSONATION_LEVEL,PHANDLE);
BOOL WINAPI DuplicateTokenEx(HANDLE,DWORD,LPSECURITY_ATTRIBUTES,SECURITY_IMPERSONATION_LEVEL,TOKEN_TYPE,PHANDLE);
BOOL APIENTRY CreateRestrictedToken(HANDLE,DWORD,DWORD,PSID_AND_ATTRIBUTES,DWORD,PLUID_AND_ATTRIBUTES,DWORD,PSID_AND_ATTRIBUTES,PHANDLE);
BOOL GetKernelObjectSecurity(HANDLE,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,LPDWORD);
BOOL WINAPI IsProcessRestricted(void);
BOOL ImpersonateNamedPipeClient(HANDLE);
BOOL WINAPI ImpersonateLoggedOnUser(HANDLE);
BOOL WINAPI LogonUserA(LPSTR,LPSTR,LPSTR,DWORD,DWORD,PHANDLE);
BOOL WINAPI LogonUserW(LPWSTR,LPWSTR,LPWSTR,DWORD,DWORD,PHANDLE);
BOOL WINAPI LogonUserExA (LPCSTR,LPCSTR,LPCSTR,DWORD,DWORD,PHANDLE,PSID *,PVOID *,LPDWORD,PQUOTA_LIMITS);
BOOL WINAPI LogonUserExW (LPCWSTR,LPCWSTR,LPCWSTR,DWORD,DWORD,PHANDLE,PSID *,PVOID *,LPDWORD,PQUOTA_LIMITS);
#ifdef UNICODE
#define SetFileShortName SetFileShortNameW
#define SetEnvironmentStrings SetEnvironmentStringsW
#define LogonUserEx LogonUserExW
#define LogonUser LogonUserW
#define GetFileAttributesEx GetFileAttributesExW
#else
#define SetFileShortName SetFileShortNameA
#define SetEnvironmentStrings SetEnvironmentStringsW
#define LogonUser	LogonUserA
#define GetFileAttributesEx GetFileAttributesExA
#define LogonUserEx LogonUserExA
#endif
BOOL ImpersonateSelf(SECURITY_IMPERSONATION_LEVEL);
BOOL RevertToSelf(VOID);
BOOL SetThreadToken (PHANDLE,HANDLE);
BOOL AccessCheck(PSECURITY_DESCRIPTOR,HANDLE,DWORD,PGENERIC_MAPPING,PPRIVILEGE_SET,LPDWORD,LPDWORD,LPBOOL);
BOOL OpenProcessToken(HANDLE,DWORD,PHANDLE);
BOOL OpenThreadToken(HANDLE,DWORD,BOOL,PHANDLE);
BOOL GetTokenInformation(HANDLE,TOKEN_INFORMATION_CLASS,LPVOID,DWORD,PDWORD);
BOOL SetTokenInformation(HANDLE,TOKEN_INFORMATION_CLASS,LPVOID,DWORD);
BOOL AdjustTokenPrivileges(HANDLE,BOOL,PTOKEN_PRIVILEGES,DWORD,PTOKEN_PRIVILEGES,PDWORD);
BOOL AdjustTokenGroups (HANDLE,BOOL,PTOKEN_GROUPS,DWORD,PTOKEN_GROUPS,PDWORD);
BOOL PrivilegeCheck (HANDLE,PPRIVILEGE_SET,LPBOOL);
BOOL IsValidSid (PSID);
BOOL EqualSid(PSID,PSID);
BOOL EqualPrefixSid (PSID,PSID);
DWORD GetSidLengthRequired(UCHAR);
BOOL AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY,BYTE,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,PSID *);
PVOID FreeSid(PSID);
BOOL InitializeSid (PSID,PSID_IDENTIFIER_AUTHORITY,BYTE);
PSID_IDENTIFIER_AUTHORITY GetSidIdentifierAuthority(PSID);
PDWORD GetSidSubAuthority (PSID,DWORD);
PUCHAR GetSidSubAuthorityCount (PSID);
DWORD GetLengthSid (PSID);
BOOL CopySid(DWORD,PSID,PSID);
BOOL AreAllAccessesGranted (DWORD,DWORD);
BOOL AreAnyAccessesGranted (DWORD,DWORD);
VOID MapGenericMask(PDWORD,PGENERIC_MAPPING);
BOOL IsValidAcl(PACL);
BOOL InitializeAcl(PACL,DWORD,DWORD);
BOOL GetAclInformation(PACL,LPVOID,DWORD,ACL_INFORMATION_CLASS);
BOOL SetAclInformation (PACL,LPVOID,DWORD,ACL_INFORMATION_CLASS);
BOOL AddAce(PACL,DWORD,DWORD,LPVOID,DWORD);
BOOL WINAPI AddAccessAllowedObjectAce(PACL,DWORD,DWORD,DWORD,GUID *,GUID *,PSID);
BOOL WINAPI AddAccessDeniedAceEx(PACL,DWORD,DWORD,DWORD,PSID);
BOOL DeleteAce(PACL,DWORD);
BOOL GetAce (PACL,DWORD,LPVOID *);
BOOL AddAccessAllowedAce(PACL,DWORD,DWORD,PSID);
BOOL WINAPI AddAccessAllowedAceEx(PACL,DWORD,DWORD,DWORD,PSID);
BOOL AddAccessDeniedAce(PACL,DWORD,DWORD,PSID);
BOOL AddAuditAccessAce(PACL,DWORD,DWORD,PSID,BOOL,BOOL);
BOOL FindFirstFreeAce (PACL,LPVOID *);
BOOL InitializeSecurityDescriptor(PSECURITY_DESCRIPTOR,DWORD);
BOOL IsValidSecurityDescriptor(PSECURITY_DESCRIPTOR);
DWORD GetSecurityDescriptorLength(PSECURITY_DESCRIPTOR);
BOOL GetSecurityDescriptorControl(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR_CONTROL,LPDWORD);
BOOL SetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR,BOOL,PACL,BOOL);
BOOL GetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR,LPBOOL,PACL *,LPBOOL);
BOOL SetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR,BOOL,PACL,BOOL);
BOOL GetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR,LPBOOL,PACL *,LPBOOL);
BOOL SetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR,PSID pOwner,BOOL);
BOOL GetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR,PSID *,LPBOOL);
BOOL SetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR,PSID,BOOL);
BOOL GetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR,PSID *,LPBOOL);
DWORD WINAPI SetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR,PUCHAR);
DWORD WINAPI GetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR,PUCHAR);
BOOL WINAPI ConvertToAutoInheritPrivateObjectSecurity(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR *,GUID *,BOOLEAN,PGENERIC_MAPPING);
BOOL CreatePrivateObjectSecurity(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR *,BOOL,HANDLE,PGENERIC_MAPPING);
BOOL SetPrivateObjectSecurity(SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR *,PGENERIC_MAPPING,HANDLE);
BOOL GetPrivateObjectSecurity(PSECURITY_DESCRIPTOR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,PDWORD);
BOOL DestroyPrivateObjectSecurity(PSECURITY_DESCRIPTOR *);
BOOL MakeSelfRelativeSD(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR,LPDWORD);
BOOL MakeAbsoluteSD(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR,LPDWORD,PACL,LPDWORD,PACL,LPDWORD,PSID,LPDWORD,PSID,LPDWORD);
BOOL SetKernelObjectSecurity(HANDLE,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR);
BOOL FindNextChangeNotification(HANDLE);
BOOL FindCloseChangeNotification(HANDLE);
BOOL VirtualLock(LPVOID,DWORD);
BOOL VirtualUnlock(LPVOID,DWORD);
LPVOID MapViewOfFileEx(HANDLE,DWORD,DWORD,DWORD,DWORD,LPVOID);
BOOL SetPriorityClass(HANDLE,DWORD);
DWORD GetPriorityClass(HANDLE);
BOOL IsBadReadPtr(CONST VOID *,UINT);
BOOL IsBadWritePtr(LPVOID,UINT);
BOOL IsBadHugeReadPtr(CONST VOID *,UINT);
BOOL IsBadHugeWritePtr(LPVOID,UINT);
BOOL IsBadCodePtr(FARPROC);
BOOL AllocateLocallyUniqueId(PLUID);
BOOL QueryPerformanceCounter(LARGE_INTEGER *);
BOOL QueryPerformanceFrequency(LARGE_INTEGER *);
VOID MoveMemory(PVOID,CONST VOID *,DWORD);
VOID NTAPI RtlMoveMemory(VOID *,CONST VOID *,SIZE_T);
#define MoveMemory(a,b,c) RtlMoveMemory(a,b,c)
VOID FillMemory(PVOID,DWORD,BYTE);
VOID ZeroMemory(PVOID,DWORD);
#ifdef WIN95
HKL ActivateKeyboardLayout(HKL,UINT);
#else
BOOL ActivateKeyboardLayout(HKL,UINT);
#endif
int ToUnicodeEx(UINT,UINT,PBYTE,LPWSTR,int,UINT,HKL);
BOOL UnloadKeyboardLayout(HKL);
int GetKeyboardLayoutList(int,HKL *);
HKL GetKeyboardLayout(DWORD);
HDESK OpenInputDesktop(DWORD,BOOL,DWORD);
BOOL EnumDesktopWindows(HDESK,ENUMWINDOWSPROC,LPARAM);
BOOL SwitchDesktop(HDESK);
BOOL SetThreadDesktop(HDESK);
BOOL CloseDesktop(HDESK);
HDESK GetThreadDesktop(DWORD);
BOOL CloseWindowStation(HWINSTA);
BOOL SetProcessWindowStation(HWINSTA);
HWINSTA GetProcessWindowStation(VOID);
BOOL SetUserObjectSecurity(HANDLE,PSECURITY_INFORMATION,PSECURITY_DESCRIPTOR);
BOOL GetUserObjectSecurity(HANDLE,PSECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,LPDWORD);
BOOL TranslateMessage(CONST MSG *);
BOOL SetMessageQueue(int);
BOOL RegisterHotKey(HWND,int,UINT,UINT);
BOOL UnregisterHotKey(HWND,int);
BOOL ExitWindowsEx(UINT,DWORD);
#define ExitWindows(a,b) ExitWindowsEx(EWX_LOGOFF,0xFFFFFFFF)
BOOL SwapMouseButton(BOOL);
DWORD GetMessagePos(VOID);
LONG GetMessageTime(VOID);
LONG GetMessageExtraInfo(VOID);
LPARAM SetMessageExtraInfo(LPARAM);
long BroadcastSystemMessage(DWORD,LPDWORD,UINT,WPARAM,LPARAM);
BOOL AttachThreadInput(DWORD,DWORD,BOOL);
BOOL ReplyMessage(LRESULT);
BOOL WaitMessage(VOID);
DWORD WaitForInputIdle(HANDLE,DWORD);
VOID PostQuitMessage(int);
BOOL InSendMessage(VOID);
UINT GetDoubleClickTime(VOID);
BOOL SetDoubleClickTime(UINT);
BOOL IsWindow(HWND);
BOOL IsMenu(HMENU);
BOOL IsChild(HWND,HWND);
BOOL DestroyWindow(HWND);
BOOL ShowWindow(HWND,int);
BOOL AnimateWindow(HWND,DWORD,DWORD);
BOOL UpdateLayeredWindow(HWND,HDC,POINT *,SIZE *,HDC,POINT *,COLORREF,BLENDFUNCTION *,DWORD);
BOOL SetLayeredWindowAttributes(HWND,COLORREF,BYTE,DWORD);
#define LWA_COLORKEY	1
#define LWA_ALPHA	2
#define ULW_COLORKEY	1
#define ULW_ALPHA	2
#define ULW_OPAQUE	4
BOOL ShowWindowAsync(HWND,int);
BOOL FlashWindow(HWND,BOOL);
BOOL FlashWindowEx(PFLASHWINFO);
#define FLASHW_STOP	0
#define FLASHW_CAPTION	1
#define FLASHW_TRAY	2
#define FLASHW_ALL	(FLASHW_CAPTION|FLASHW_TRAY)
#define FLASHW_TIMER	4
#define FLASHW_TIMERNOFG	0xC
BOOL ShowOwnedPopups(HWND,BOOL);
BOOL OpenIcon(HWND);
BOOL CloseWindow(HWND);
BOOL MoveWindow(HWND,int,int,int,int,BOOL);
BOOL SetWindowPos(HWND,HWND,int,int,int,int,UINT);
BOOL GetWindowPlacement(HWND,WINDOWPLACEMENT *);
BOOL SetWindowPlacement(HWND hWnd,CONST WINDOWPLACEMENT *);
HDWP BeginDeferWindowPos(int);
HDWP DeferWindowPos(HDWP,HWND,HWND,int,int,int,int,UINT);
BOOL EndDeferWindowPos(HDWP);
BOOL IsWindowVisible(HWND);
BOOL IsIconic(HWND);
BOOL AnyPopup(VOID);
BOOL BringWindowToTop(HWND);
BOOL IsZoomed(HWND);
BOOL EndDialog(HWND,int);
HWND GetDlgItem(HWND,int);
BOOL SetDlgItemInt(HWND,int,UINT,BOOL);
UINT GetDlgItemInt(HWND,int,BOOL *,BOOL);
BOOL CheckDlgButton(HWND,int,UINT);
BOOL CheckRadioButton(HWND,int,int,int);
UINT IsDlgButtonChecked(HWND,int);
HWND GetNextDlgGroupItem(HWND,HWND,BOOL);
HWND GetNextDlgTabItem(HWND,HWND,BOOL);
int GetDlgCtrlID(HWND);
long GetDialogBaseUnits(VOID);
BOOL OpenClipboard(HWND);
BOOL CloseClipboard(VOID);
HWND GetClipboardOwner(VOID);
HWND SetClipboardViewer(HWND);
HWND GetClipboardViewer(VOID);
BOOL ChangeClipboardChain(HWND,HWND);
HANDLE SetClipboardData(UINT,HANDLE);
HANDLE GetClipboardData(UINT);
int CountClipboardFormats(VOID);
UINT EnumClipboardFormats(UINT);
BOOL EmptyClipboard(VOID);
BOOL IsClipboardFormatAvailable(UINT);
int GetPriorityClipboardFormat(UINT *,int);
HWND GetOpenClipboardWindow(VOID);
LPSTR CharNextExA(WORD,LPCSTR,DWORD);
LPSTR CharPrevExA(WORD,LPCSTR,LPCSTR,DWORD dwFlags);
HWND SetFocus(HWND);
HWND GetActiveWindow(VOID);
HWND GetFocus(VOID);
UINT GetKBCodePage(VOID);
SHORT GetKeyState(int);
SHORT GetAsyncKeyState(int);
BOOL GetKeyboardState(PBYTE);
BOOL SetKeyboardState(LPBYTE);
int GetKeyboardType(int);
int ToAscii(UINT,UINT,PBYTE,LPWORD,UINT);
int ToAsciiEx(UINT,UINT,PBYTE,LPWORD,UINT,HKL);
int ToUnicode(UINT,UINT,PBYTE,LPWSTR,int,UINT);
DWORD OemKeyScan(WORD);
VOID keybd_event(BYTE,BYTE,DWORD,DWORD);
VOID mouse_event(DWORD,DWORD,DWORD,DWORD,DWORD);
BOOL GetInputState(VOID);
DWORD GetQueueStatus(UINT flags);
HWND GetCapture(VOID);
HWND SetCapture(HWND hWnd);
BOOL ReleaseCapture(VOID);
DWORD MsgWaitForMultipleObjects(DWORD,LPHANDLE,BOOL,DWORD,DWORD);
DWORD WINAPI MsgWaitForMultipleObjectsEx(DWORD,CONST HANDLE *,DWORD,DWORD,DWORD);
UINT SetTimer(HWND,UINT,UINT,TIMERPROC);
BOOL KillTimer(HWND,UINT);
BOOL IsWindowUnicode(HWND);
BOOL EnableWindow(HWND,BOOL);
BOOL IsWindowEnabled(HWND);
BOOL DestroyAcceleratorTable(HACCEL);
int GetSystemMetrics(int);
HMENU GetMenu(HWND);
BOOL WINAPI GetMenuBarInfo(HWND,LONG,LONG,PMENUBARINFO);
BOOL SetMenu(HWND,HMENU);
BOOL HiliteMenuItem(HWND,HMENU,UINT,UINT);
UINT GetMenuState(HMENU,UINT,UINT);
BOOL DrawMenuBar(HWND);
HMENU GetSystemMenu(HWND,BOOL);
HMENU CreateMenu(VOID);
HMENU CreatePopupMenu(VOID);
BOOL DestroyMenu(HMENU);
DWORD CheckMenuItem(HMENU,UINT,UINT);
BOOL EnableMenuItem(HMENU,UINT,UINT);
HMENU GetSubMenu(HMENU,int);
UINT GetMenuItemID(HMENU,int);
int GetMenuItemCount(HMENU);
BOOL RemoveMenu(HMENU,UINT,UINT);
BOOL DeleteMenu(HMENU,UINT,UINT);
BOOL SetMenuItemBitmaps(HMENU,UINT,UINT,HBITMAP,HBITMAP);
LONG GetMenuCheckMarkDimensions(VOID);
BOOL TrackPopupMenu(HMENU,UINT,int,int,int,HWND,CONST RECT *);
BOOL WINAPI GetMenuInfo(HMENU,LPMENUINFO);
BOOL WINAPI SetMenuInfo(HMENU,LPCMENUINFO);
BOOL WINAPI EndMenu(VOID);
UINT GetMenuDefaultItem(HMENU,UINT,UINT);
BOOL SetMenuDefaultItem(HMENU,UINT,UINT);
BOOL GetMenuItemRect(HWND,HMENU,UINT,LPRECT);
int MenuItemFromPoint(HWND,HMENU,POINT);
DWORD DragObject(HWND,HWND,UINT,DWORD,HCURSOR);
BOOL DragDetect(HWND,POINT);
BOOL DrawIcon(HDC,int,int,HICON);
BOOL UpdateWindow(HWND);
HWND SetActiveWindow(HWND);
HWND GetForegroundWindow(VOID);
BOOL PaintDesktop(HDC);
BOOL SetForegroundWindow(HWND hWnd);
HWND WindowFromDC(HDC hDC);
HDC GetDC(HWND);
HDC GetDCEx(HWND,HRGN,DWORD);
HDC GetWindowDC(HWND);
int ReleaseDC(HWND,HDC);
HDC BeginPaint( HWND,LPPAINTSTRUCT);
BOOL EndPaint(HWND,CONST PAINTSTRUCT *);
BOOL GetUpdateRect(HWND,LPRECT,BOOL);
int GetUpdateRgn(HWND,HRGN,BOOL);
int SetWindowRgn(HWND,HRGN,BOOL);
int GetWindowRgn(HWND,HRGN);
int ExcludeUpdateRgn(HDC,HWND);
BOOL InvalidateRect(HWND,CONST RECT *,BOOL);
BOOL ValidateRect(HWND,CONST RECT *);
BOOL InvalidateRgn(HWND,HRGN,BOOL);
BOOL ValidateRgn(HWND,HRGN);
BOOL RedrawWindow(HWND,CONST RECT *,HRGN,UINT);
BOOL LockWindowUpdate(HWND );
BOOL ScrollWindow(HWND,int,int,CONST RECT *,CONST RECT *);
BOOL ScrollDC(HDC,int,int,CONST RECT *,CONST RECT *,HRGN,LPRECT);
int ScrollWindowEx(HWND,int,int,CONST RECT *,CONST RECT *,HRGN,LPRECT,UINT);
int SetScrollPos(HWND,int,int,BOOL);
int GetScrollPos(HWND,int);
BOOL SetScrollRange(HWND,int,int,int,BOOL);
BOOL GetScrollRange(HWND,int,LPINT,LPINT);
BOOL ShowScrollBar(HWND,int,BOOL);
BOOL EnableScrollBar(HWND,UINT,UINT);
BOOL GetClientRect(HWND,LPRECT);
BOOL GetWindowRect(HWND,LPRECT);
BOOL AdjustWindowRect(LPRECT,DWORD,BOOL);
BOOL AdjustWindowRectEx(LPRECT,DWORD,BOOL,DWORD);
BOOL SetWindowContextHelpId(HWND,DWORD);
DWORD GetWindowContextHelpId(HWND);
BOOL SetMenuContextHelpId(HMENU,DWORD);
DWORD GetMenuContextHelpId(HMENU);
BOOL MessageBeep(UINT);
int ShowCursor(BOOL);
BOOL SetCursorPos(int,int);
HCURSOR SetCursor(HCURSOR);
BOOL GetCursorPos(LPPOINT);
BOOL ClipCursor(CONST RECT *);
BOOL GetClipCursor(LPRECT);
HCURSOR GetCursor(VOID);
BOOL CreateCaret(HWND,HBITMAP,int,int);
UINT GetCaretBlinkTime(VOID);
BOOL SetCaretBlinkTime(UINT);
BOOL DestroyCaret(VOID);
BOOL HideCaret(HWND);
BOOL ShowCaret(HWND);
BOOL SetCaretPos(int,int);
BOOL GetCaretPos(LPPOINT);
BOOL ClientToScreen(HWND,LPPOINT);
BOOL ScreenToClient(HWND,LPPOINT);
int MapWindowPoints(HWND,HWND,LPPOINT,UINT);
HWND WindowFromPoint(POINT);
HWND ChildWindowFromPoint(HWND,POINT);
DWORD GetSysColor(int);
HBRUSH GetSysColorBrush(int);
BOOL SetSysColors(int,CONST INT *,CONST COLORREF *);
BOOL DrawFocusRect(HDC,CONST RECT *);
int FillRect(HDC,CONST RECT *,HBRUSH);
int FrameRect(HDC,CONST RECT *,HBRUSH);
BOOL InvertRect(HDC,CONST RECT *);
BOOL SetRect(LPRECT,int,int,int,int);
BOOL SetRectEmpty(LPRECT);
BOOL CopyRect(LPRECT,CONST RECT *);
BOOL InflateRect(LPRECT,int,int);
BOOL IntersectRect(LPRECT,CONST RECT *,CONST RECT *);
BOOL UnionRect(LPRECT,CONST RECT *,CONST RECT *);
BOOL SubtractRect(LPRECT,CONST RECT *,CONST RECT *);
BOOL OffsetRect(LPRECT,int,int);
BOOL IsRectEmpty( CONST RECT *);
BOOL EqualRect(CONST RECT *,CONST RECT *);
BOOL PtInRect( CONST RECT *lprc,POINT pt);
WORD GetWindowWord(HWND,int);
WORD SetWindowWord(HWND,int,WORD);
WORD GetClassWord(HWND,int);
WORD SetClassWord(HWND,int,WORD);
HWND GetDesktopWindow(VOID);
HWND GetParent(HWND);
HWND SetParent(HWND,HWND);
BOOL EnumChildWindows(HWND,ENUMWINDOWSPROC,LPARAM);
BOOL EnumWindows(ENUMWINDOWSPROC,LPARAM );
BOOL EnumThreadWindows(DWORD,ENUMWINDOWSPROC,LPARAM);
HWND GetTopWindow(HWND);
DWORD GetWindowThreadProcessId(HWND,LPDWORD);
HWND GetLastActivePopup(HWND);
HWND GetWindow(HWND,UINT);
BOOL UnhookWindowsHook(int,HOOKPROC);
BOOL UnhookWindowsHookEx(HHOOK);
BOOL WINAPI UnhookWinEvent(HWINEVENTHOOK);
HWINEVENTHOOK WINAPI SetWinEventHook(DWORD,DWORD,HMODULE,WINEVENTPROC,DWORD,DWORD,DWORD);
LRESULT CallNextHookEx(HHOOK,int,WPARAM,LPARAM);
VOID WINAPI NotifyWinEvent(DWORD,HWND,LONG,LONG);
BOOL CheckMenuRadioItem(HMENU,UINT,UINT,UINT,UINT);
HCURSOR CreateCursor(HINSTANCE,int,int,int,int,CONST VOID *,CONST VOID *);
BOOL DestroyCursor(HCURSOR);
BOOL SetSystemCursor( HCURSOR,DWORD);
HICON CreateIcon(HINSTANCE,int,int,BYTE,BYTE,CONST BYTE *,CONST BYTE *);
BOOL DestroyIcon(HICON);
int LookupIconIdFromDirectory(PBYTE,BOOL);
int LookupIconIdFromDirectoryEx(PBYTE,BOOL,int,int,UINT);
HICON CreateIconFromResource(PBYTE,DWORD,BOOL,DWORD);
HICON CreateIconFromResourceEx(PBYTE,DWORD,BOOL,DWORD,int,int,UINT);
HICON CopyImage( HANDLE,UINT,int,int,UINT);
HICON CreateIconIndirect(PICONINFO);
HICON CopyIcon(HICON);
#define CopyCursor(p) ((HCURSOR)CopyIcon((HICON)(p)))
BOOL GetIconInfo( HICON hIcon,PICONINFO piconinfo);
BOOL MapDialogRect( HWND hDlg,LPRECT lpRect);
int SetScrollInfo(HWND,int,LPCSCROLLINFO,BOOL);
BOOL GetScrollInfo(HWND,int,LPSCROLLINFO);
BOOL TranslateMDISysAccel(HWND,LPMSG);
UINT ArrangeIconicWindows(HWND);
WORD TileWindows(HWND,UINT,CONST RECT *,UINT,const HWND *);
WORD CascadeWindows(HWND,UINT,CONST RECT *,UINT,const HWND *);
VOID SetLastErrorEx(DWORD,DWORD);
VOID SetDebugErrorLevel(DWORD);
BOOL DrawEdge(HDC,LPRECT,UINT,UINT);
BOOL DrawFrameControl(HDC,LPRECT,UINT,UINT);
BOOL DrawCaption(HWND,HDC,CONST RECT *,UINT);
BOOL DrawAnimatedRects(HWND,int,CONST RECT *,CONST RECT *);
BOOL TrackPopupMenuEx(HMENU,UINT,int,int,HWND,LPTPMPARAMS);
HWND ChildWindowFromPointEx(HWND,POINT,UINT);
HWND WINAPI RealChildWindowFromPoint(HWND,POINT);
UINT WINAPI RealGetWindowClassA(HWND,LPSTR,UINT);
BOOL WINAPI IsProcessorFeaturePresent(DWORD);
BOOL DrawIconEx(HDC,int,int,HICON,int,int,UINT,HBRUSH,UINT);
BOOL AnimatePalette(HPALETTE,UINT,UINT,CONST PALETTEENTRY *);
BOOL Arc(HDC,int,int,int,int,int,int,int,int);
BOOL BitBlt(HDC,int,int,int,int,HDC,int,int,DWORD);
BOOL CancelDC(HDC);
BOOL Chord(HDC,int,int,int,int,int,int,int,int);
HMETAFILE CloseMetaFile(HDC);
int CombineRgn(HRGN,HRGN,HRGN,int);
HBITMAP CreateBitmap(int,int,UINT,UINT,CONST VOID *);
HBITMAP CreateBitmapIndirect(CONST BITMAP *);
HBRUSH CreateBrushIndirect(CONST LOGBRUSH *);
HBITMAP CreateCompatibleBitmap(HDC,int,int);
HBITMAP CreateDiscardableBitmap(HDC,int,int);
HDC CreateCompatibleDC(HDC);
HBITMAP CreateDIBitmap(HDC,CONST BITMAPINFOHEADER *,DWORD,CONST VOID *,CONST BITMAPINFO *,UINT);
HBRUSH CreateDIBPatternBrush(HGLOBAL,UINT);
HBRUSH CreateDIBPatternBrushPt(CONST VOID *,UINT);
HRGN CreateEllipticRgn(int,int,int,int);
HRGN CreateEllipticRgnIndirect(CONST RECT *);
HBRUSH CreateHatchBrush(int,COLORREF);
HPALETTE CreatePalette(CONST LOGPALETTE *);
HPEN CreatePen(int,int,COLORREF);
HPEN CreatePenIndirect(CONST LOGPEN *);
HRGN CreatePolyPolygonRgn(CONST POINT *,CONST INT *,int,int);
HBRUSH CreatePatternBrush(HBITMAP);
HRGN CreateRectRgn(int,int,int,int);
HRGN CreateRectRgnIndirect(CONST RECT *);
HRGN CreateRoundRectRgn(int,int,int,int,int,int);
HBRUSH CreateSolidBrush(COLORREF);
BOOL DeleteDC(HDC);
BOOL DeleteMetaFile(HMETAFILE);
BOOL DeleteObject(HGDIOBJ);
int WINAPI DescribePixelFormat(HDC,int, UINT, LPPIXELFORMATDESCRIPTOR);
BOOL WINAPI SwapBuffers(HDC);
int DrawEscape(HDC,int,int,LPCSTR);
BOOL Ellipse(HDC,int,int,int,int);
int EnumObjects(HDC,int,ENUMOBJECTSPROC,LPARAM);
BOOL EqualRgn(HRGN,HRGN);
int Escape(HDC,int,int,LPCSTR,LPVOID);
int ExtEscape(HDC,int,int,LPCSTR,int,LPSTR);
int ExcludeClipRect(HDC,int,int,int,int);
HRGN ExtCreateRegion(CONST XFORM *,DWORD,CONST RGNDATA *);
BOOL ExtFloodFill(HDC,int,int,COLORREF,UINT);
BOOL FillRgn(HDC,HRGN,HBRUSH);
BOOL FloodFill(HDC,int,int,COLORREF);
BOOL FrameRgn(HDC,HRGN,HBRUSH,int,int);
int GetROP2(HDC);
BOOL GetAspectRatioFilterEx(HDC,LPSIZE);
COLORREF GetBkColor(HDC);
COLORREF GetDCBrushColor(HDC);
COLORREF GetDCPenColor(HDC);
int GetBkMode(HDC);
LONG GetBitmapBits(HBITMAP,LONG,LPVOID);
BOOL GetBitmapDimensionEx(HBITMAP,LPSIZE);
UINT GetBoundsRect(HDC,LPRECT,UINT);
BOOL GetBrushOrgEx(HDC,LPPOINT);
int GetClipBox(HDC,LPRECT);
int GetClipRgn(HDC,HRGN);
int GetMetaRgn(HDC,HRGN);
HGDIOBJ GetCurrentObject(HDC,UINT);
BOOL GetCurrentPositionEx(HDC,LPPOINT);
int GetDeviceCaps(HDC,int);
int GetDIBits(HDC,HBITMAP,UINT,UINT,LPVOID,LPBITMAPINFO,UINT);
DWORD GetFontData(HDC,DWORD,DWORD,LPVOID,DWORD);
DWORD WINAPI GetFontUnicodeRanges(HDC,LPGLYPHSET);
DWORD WINAPI GetGlyphIndicesA(HDC,LPCSTR,int,LPWORD,DWORD);
DWORD WINAPI GetGlyphIndicesW(HDC,LPCWSTR,int,LPWORD,DWORD);
int GetGraphicsMode(HDC);
int GetMapMode(HDC);
UINT GetMetaFileBitsEx(HMETAFILE,UINT,LPVOID);
COLORREF GetNearestColor(HDC,COLORREF);
UINT GetNearestPaletteIndex(HPALETTE,COLORREF);
DWORD GetObjectType(HGDIOBJ);
UINT GetPaletteEntries(HPALETTE,UINT,UINT,LPPALETTEENTRY);
COLORREF GetPixel(HDC,int,int);
int GetPixelFormat(HDC);
int GetPolyFillMode(HDC);
BOOL GetRasterizerCaps(LPRASTERIZER_STATUS,UINT);
int WINAPI GetRandomRgn (HDC,HRGN,INT);
DWORD GetRegionData(HRGN,DWORD,LPRGNDATA);
int GetRgnBox(HRGN,LPRECT);
HGDIOBJ GetStockObject(int);
int GetStretchBltMode(HDC);
UINT GetSystemPaletteEntries(HDC,UINT,UINT,LPPALETTEENTRY);
UINT GetSystemPaletteUse(HDC);
int GetTextCharacterExtra(HDC);
UINT GetTextAlign(HDC);
COLORREF GetTextColor(HDC);
int GetTextCharset(HDC);
int GetTextCharsetInfo(HDC,LPFONTSIGNATURE,DWORD);
BOOL TranslateCharsetInfo( DWORD *,LPCHARSETINFO,DWORD);
DWORD GetFontLanguageInfo(HDC);
BOOL GetViewportExtEx(HDC,LPSIZE);
BOOL GetViewportOrgEx(HDC,LPPOINT);
BOOL GetWindowExtEx(HDC,LPSIZE);
BOOL GetWindowOrgEx(HDC,LPPOINT);
int IntersectClipRect(HDC,int,int,int,int);
BOOL InvertRgn(HDC,HRGN);
BOOL LineDDA(int,int,int,int,LINEDDAPROC,LPARAM);
BOOL LineTo(HDC,int,int);
BOOL MaskBlt(HDC,int,int,int,int,HDC,int,int,HBITMAP,int,int,DWORD);
BOOL PlgBlt(HDC,CONST POINT *,HDC,int,int,int,int,HBITMAP,int,int);
int OffsetClipRgn(HDC,int,int);
int OffsetRgn(HRGN,int,int);
BOOL PatBlt(HDC,int,int,int,int,DWORD);
BOOL Pie(HDC,int,int,int,int,int,int,int,int);
BOOL PlayMetaFile(HDC,HMETAFILE);
BOOL PaintRgn(HDC,HRGN);
BOOL PolyPolygon(HDC,CONST POINT *,CONST INT *,int);
BOOL PtInRegion(HRGN,int,int);
BOOL PtVisible(HDC,int,int);
BOOL RectInRegion(HRGN,CONST RECT *);
BOOL RectVisible(HDC,CONST RECT *);
BOOL Rectangle(HDC,int,int,int,int);
BOOL RestoreDC(HDC,int);
UINT RealizePalette(HDC);
BOOL RoundRect(HDC,int,int,int,int,int,int);
BOOL ResizePalette(HPALETTE,UINT);
int SaveDC(HDC);
int SelectClipRgn(HDC,HRGN);
int ExtSelectClipRgn(HDC,HRGN,int);
int SetMetaRgn(HDC);
HGDIOBJ SelectObject(HDC,HGDIOBJ);
HPALETTE SelectPalette(HDC,HPALETTE,BOOL);
COLORREF SetBkColor(HDC,COLORREF);
int SetBkMode(HDC,int);
LONG SetBitmapBits(HBITMAP,DWORD,CONST VOID *);
UINT SetBoundsRect(HDC,CONST RECT *,UINT);
int SetDIBits(HDC,HBITMAP,UINT,UINT,CONST VOID *,CONST BITMAPINFO *,UINT);
int SetDIBitsToDevice(HDC,int,int,DWORD,DWORD,int,int,UINT,UINT,CONST VOID *,CONST BITMAPINFO *,UINT);
DWORD SetMapperFlags(HDC,DWORD);
int SetGraphicsMode(HDC,int);
int SetMapMode(HDC,int);
HMETAFILE SetMetaFileBitsEx(UINT,CONST BYTE *);
UINT SetPaletteEntries(HPALETTE,UINT,UINT,CONST PALETTEENTRY *);
COLORREF SetPixel(HDC,int,int,COLORREF);
BOOL SetPixelV(HDC,int,int,COLORREF);
int SetPolyFillMode(HDC,int);
BOOL StretchBlt(HDC,int,int,int,int,HDC,int,int,int,int,DWORD);
BOOL SetRectRgn(HRGN,int,int,int,int);
int StretchDIBits(HDC,int,int,int,int,int,int,int,int,CONST VOID *,CONST BITMAPINFO *,UINT,DWORD);
int SetROP2(HDC,int);
int SetStretchBltMode(HDC,int);
UINT SetSystemPaletteUse(HDC,UINT);
int SetTextCharacterExtra(HDC,int);
COLORREF SetTextColor(HDC,COLORREF);
UINT SetTextAlign(HDC,UINT);
BOOL SetTextJustification(HDC,int,int);
BOOL UpdateColors(HDC);
BOOL PlayMetaFileRecord(HDC,LPHANDLETABLE,LPMETARECORD,UINT);
BOOL EnumMetaFile(HDC,HMETAFILE,ENUMMETAFILEPROC,LPARAM);
HENHMETAFILE CloseEnhMetaFile(HDC);
BOOL DeleteEnhMetaFile(HENHMETAFILE);
BOOL EnumEnhMetaFile(HDC,HENHMETAFILE,ENHMETAFILEPROC,LPVOID,CONST RECT *);
UINT GetEnhMetaFileHeader(HENHMETAFILE,UINT,LPENHMETAHEADER );
UINT GetEnhMetaFilePaletteEntries(HENHMETAFILE,UINT,LPPALETTEENTRY );
UINT WINAPI GetEnhMetaFileBits(HENHMETAFILE,UINT,LPBYTE);
UINT GetWinMetaFileBits(HENHMETAFILE,UINT,LPBYTE,INT,HDC);
BOOL PlayEnhMetaFile(HDC,HENHMETAFILE,CONST RECT *);
BOOL PlayEnhMetaFileRecord(HDC,LPHANDLETABLE,CONST ENHMETARECORD *,UINT);
HENHMETAFILE SetEnhMetaFileBits(UINT,CONST BYTE *);
HENHMETAFILE SetWinMetaFileBits(UINT,CONST BYTE *,HDC,CONST METAFILEPICT *);
BOOL GdiComment(HDC,UINT,CONST BYTE *);
BOOL AngleArc(HDC,int,int,DWORD,FLOAT,FLOAT);
BOOL PolyPolyline(HDC,CONST POINT *,CONST DWORD *,DWORD);
BOOL GetWorldTransform(HDC,LPXFORM);
BOOL SetWorldTransform(HDC,CONST XFORM *);
BOOL ModifyWorldTransform(HDC,CONST XFORM *,DWORD);
BOOL CombineTransform(LPXFORM,CONST XFORM *,CONST XFORM *);
HBITMAP CreateDIBSection(HDC,CONST BITMAPINFO *,UINT,VOID **,HANDLE,DWORD);
UINT GetDIBColorTable(HDC,UINT,UINT,RGBQUAD *);
UINT SetDIBColorTable(HDC,UINT,UINT,CONST RGBQUAD *);
BOOL SetColorAdjustment(HDC,CONST COLORADJUSTMENT *);
BOOL GetColorAdjustment(HDC,LPCOLORADJUSTMENT);
HPALETTE CreateHalftonePalette(HDC);
BOOL WINAPI ReadDirectoryChangesW(HANDLE,LPVOID,DWORD,BOOL,DWORD,LPDWORD,LPOVERLAPPED,LPOVERLAPPED_COMPLETION_ROUTINE);
int EndDoc(HDC);
int StartPage(HDC);
int EndPage(HDC);
int AbortDoc(HDC);
int SetAbortProc(HDC,ABORTPROC);
BOOL AbortPath(HDC);
BOOL ArcTo(HDC,int,int,int,int,int,int,int,int);
BOOL BeginPath(HDC);
BOOL CloseFigure(HDC);
BOOL EndPath(HDC);
BOOL FillPath(HDC);
BOOL FlattenPath(HDC);
int GetPath(HDC,LPPOINT,LPBYTE,int);
HRGN PathToRegion(HDC);
BOOL PolyDraw(HDC,CONST POINT *,CONST BYTE *,int);
BOOL SelectClipPath(HDC,int);
int SetArcDirection(HDC,int);
BOOL SetMiterLimit(HDC,FLOAT,PFLOAT);
BOOL StrokeAndFillPath(HDC);
BOOL StrokePath(HDC);
BOOL WidenPath(HDC);
HPEN ExtCreatePen(DWORD,DWORD,CONST LOGBRUSH *,DWORD,CONST DWORD *);
BOOL GetMiterLimit(HDC,PFLOAT);
int GetArcDirection(HDC);
BOOL MoveToEx(HDC,int,int,LPPOINT);
HRGN CreatePolygonRgn(CONST POINT *,int,int);
BOOL DPtoLP(HDC,LPPOINT,int);
BOOL LPtoDP(HDC,LPPOINT,int);
BOOL Polygon(HDC,CONST POINT *,int);
BOOL Polyline(HDC,CONST POINT *,int);
BOOL PolyBezier(HDC,CONST POINT *,DWORD);
BOOL PolyBezierTo(HDC,CONST POINT *,DWORD);
BOOL PolylineTo(HDC,CONST POINT *,DWORD);
BOOL SetViewportExtEx(HDC,int,int,LPSIZE);
BOOL SetViewportOrgEx(HDC,int,int,LPPOINT);
BOOL SetWindowExtEx(HDC,int,int,LPSIZE);
BOOL SetWindowOrgEx(HDC,int,int,LPPOINT);
BOOL OffsetViewportOrgEx(HDC,int,int,LPPOINT);
BOOL OffsetWindowOrgEx(HDC,int,int,LPPOINT);
BOOL ScaleViewportExtEx(HDC,int,int,int,int,LPSIZE);
BOOL ScaleWindowExtEx(HDC,int,int,int,int,LPSIZE);
BOOL SetBitmapDimensionEx(HBITMAP,int,int,LPSIZE);
BOOL SetBrushOrgEx(HDC,int,int,LPPOINT);
BOOL GetDCOrgEx(HDC,LPPOINT);
BOOL FixBrushOrgEx(HDC,int,int,LPPOINT);
BOOL UnrealizeObject(HGDIOBJ);
BOOL GdiFlush(void);
DWORD GdiSetBatchLimit(DWORD);
DWORD GdiGetBatchLimit(void);
int SetICMMode(HDC,int);
BOOL CheckColorsInGamut(HDC,LPVOID,LPVOID,DWORD);
HANDLE GetColorSpace(HDC);
BOOL SetColorSpace(HDC,HCOLORSPACE);
BOOL DeleteColorSpace(HCOLORSPACE);
BOOL GetDeviceGammaRamp(HDC,LPVOID);
BOOL SetDeviceGammaRamp(HDC,LPVOID);
BOOL ColorMatchToTarget(HDC,HDC,DWORD);
HPROPSHEETPAGE CreatePropertySheetPageA(LPCPROPSHEETPAGE);
BOOL DestroyPropertySheetPage(HPROPSHEETPAGE);
void InitCommonControls(void);
typedef struct tagINITCOMMONCONTROLSEX { DWORD dwSize; DWORD dwICC; } INITCOMMONCONTROLSEX, *LPINITCOMMONCONTROLSEX;
#define ICC_LISTVIEW_CLASSES 1
#define ICC_TREEVIEW_CLASSES 2
#define ICC_BAR_CLASSES	4
#define ICC_TAB_CLASSES 8
#define ICC_UPDOWN_CLASS 0x10
#define ICC_PROGRESS_CLASS 0x20
#define ICC_HOTKEY_CLASS 0x40
#define ICC_ANIMATE_CLASS 0x80
#define ICC_WIN95_CLASSES 0xFF
#define ICC_DATE_CLASSES 0x100
#define ICC_USEREX_CLASSES 0x200
#define ICC_COOL_CLASSES 0x400
#define ICC_INTERNET_CLASSES 0x800
#define ICC_PAGESCROLLER_CLASS 0x1000
#define ICC_NATIVEFNTCTL_CLASS 0x2000
#define ICC_STANDARD_CLASSES 0x04000
#define ECM_FIRST 0x1500
#define BCM_FIRST 0x1600
#define BCM_GETIDEALSIZE  (BCM_FIRST + 1)
#define BCM_SETIMAGELIST  (BCM_FIRST + 2)
#define BCM_GETIMAGELIST  (BCM_FIRST + 3)
#define BCM_SETTEXTMARGIN (BCM_FIRST + 4)
#define BCM_GETTEXTMARGIN (BCM_FIRST + 5)
#define CBM_FIRST 0x1700
#define ICC_LINK_CLASS 0x08000
BOOL AlphaBlend(HDC,int,int,int,int,HDC,int,int,int,int,BLENDFUNCTION);
BOOL TransparentBlt(HDC,int,int,int,int,HDC,int,int,int,int,UINT);
#define AC_SRC_OVER 0
#define AC_SRC_ALPHA 1
#define GRADIENT_FILL_RECT_H	0
#define GRADIENT_FILL_RECT_V	1
#define GRADIENT_FILL_TRIANGLE	2
#define GRADIENT_FILL_OP_FLAG	0x0ff
BOOL GradientFill(HDC,PTRIVERTEX,ULONG,PVOID,ULONG,ULONG);
BOOL WINAPI InitCommonControlsEx(LPINITCOMMONCONTROLSEX);
#define ImageList_AddIcon(himl,hicon) ImageList_ReplaceIcon(himl,-1,hicon)
HIMAGELIST ImageList_Create(int,int,UINT,int,int);
BOOL ImageList_Destroy(HIMAGELIST);
int ImageList_GetImageCount(HIMAGELIST);
int ImageList_Add(HIMAGELIST,HBITMAP,HBITMAP);
int ImageList_ReplaceIcon(HIMAGELIST,int,HICON);
COLORREF ImageList_SetBkColor(HIMAGELIST,COLORREF);
COLORREF ImageList_GetBkColor(HIMAGELIST himl);
BOOL ImageList_SetOverlayImage(HIMAGELIST,int,int);
BOOL ImageList_Draw(HIMAGELIST,int,HDC,int,int,UINT);
BOOL ImageList_Replace(HIMAGELIST,int,HBITMAP,HBITMAP);
int ImageList_AddMasked(HIMAGELIST,HBITMAP,COLORREF);
BOOL ImageList_DrawEx(HIMAGELIST,int,HDC,int,int,int,int,COLORREF,COLORREF,UINT);
BOOL ImageList_Remove(HIMAGELIST,int);
HICON ImageList_GetIcon(HIMAGELIST,int,UINT);
BOOL ImageList_BeginDrag(HIMAGELIST,int,int,int);
void ImageList_EndDrag(VOID);
BOOL ImageList_DragEnter(HWND,int,int);
BOOL ImageList_DragLeave(HWND);
BOOL ImageList_DragMove(int,int);
BOOL ImageList_SetDragCursorImage(HIMAGELIST,int,int,int);
BOOL ImageList_DragShowNolock(BOOL);
HIMAGELIST ImageList_GetDragImage(POINT *,POINT *);
BOOL ImageList_GetIconSize(HIMAGELIST,int *,int *);
BOOL ImageList_SetIconSize(HIMAGELIST,int,int);
BOOL ImageList_GetImageInfo(HIMAGELIST,int,IMAGEINFO *);
HIMAGELIST ImageList_Merge(HIMAGELIST,int,HIMAGELIST,int,int,int);
BOOL WINAPI ImageList_SetImageCount(HIMAGELIST,UINT);
HWND CreateToolbarEx(HWND,DWORD,UINT,int,HINSTANCE,UINT,LPCTBBUTTON,int,int,int,int,int,UINT);
HBITMAP CreateMappedBitmap(HINSTANCE,int,UINT,LPCOLORMAP,int);
void MenuHelp(UINT,WPARAM,LPARAM,HMENU,HINSTANCE,HWND,UINT *);
BOOL ShowHideMenuCtl(HWND,UINT,LPINT);
void GetEffectiveClientRect(HWND,LPRECT,LPINT);
BOOL MakeDragList(HWND);
void DrawInsert(HWND,HWND,int);
int LBItemFromPt(HWND,POINT,BOOL);
HWND CreateUpDownControl(DWORD,int,int,int,int,HWND,int,HINSTANCE,HWND,int,int,int);
DWORD CommDlgExtendedError(VOID);
BOOL SetWaitableTimer(HANDLE,const LARGE_INTEGER *,LONG,PTIMERAPCROUTINE,LPVOID,BOOL);
BOOL CancelWaitableTimer(HANDLE);
HANDLE WINAPI CreateWaitableTimerA(LPSECURITY_ATTRIBUTES,BOOL,LPCSTR);
HANDLE WINAPI CreateWaitableTimerW(LPSECURITY_ATTRIBUTES,BOOL,LPCWSTR);
#define WSB_PROP_CYVSCROLL	1
#define WSB_PROP_CXHSCROLL	2
#define WSB_PROP_CYHSCROLL	4
#define WSB_PROP_CXVSCROLL	8
#define WSB_PROP_CXHTHUMB	0x10
#define WSB_PROP_CYVTHUMB	0x20
#define WSB_PROP_VBKGCOLOR	0x40
#define WSB_PROP_HBKGCOLOR	0x80
#define WSB_PROP_VSTYLE	0x100
#define WSB_PROP_HSTYLE	0x200
#define WSB_PROP_WINSTYLE	0x400
#define WSB_PROP_PALETTE	0x800
#define WSB_PROP_MASK	0xFFF
#define FSB_FLAT_MODE	2
#define FSB_ENCARTA_MODE	1
#define FSB_REGULAR_MODE	0
BOOL WINAPI FlatSB_EnableScrollBar(HWND,int,UINT);
BOOL WINAPI FlatSB_ShowScrollBar(HWND,int,BOOL);
BOOL WINAPI FlatSB_GetScrollRange(HWND,int,LPINT,LPINT);
BOOL WINAPI FlatSB_GetScrollInfo(HWND,int,LPSCROLLINFO);
int WINAPI FlatSB_GetScrollPos(HWND,int);
BOOL WINAPI FlatSB_GetScrollProp(HWND,int,LPINT);
#define FlatSB_GetScrollPropPtr FlatSB_GetScrollProp
int WINAPI FlatSB_SetScrollPos(HWND,int,int,BOOL);
int WINAPI FlatSB_SetScrollInfo(HWND,int,LPSCROLLINFO,BOOL);
int WINAPI FlatSB_SetScrollRange(HWND,int,int,int,BOOL);
BOOL WINAPI FlatSB_SetScrollProp(HWND,UINT,int,BOOL);
#define FlatSB_SetScrollPropPtr FlatSB_SetScrollProp
BOOL WINAPI InitializeFlatSB(HWND);
HRESULT WINAPI UninitializeFlatSB(HWND);
#define Button_GetTextMargin(h,p) (BOOL)SNDMSG((h),BCM_GETTEXTMARGIN,0,(LPARAM)(p))
#define Button_SetTextMargin(h, p) (BOOL)SNDMSG((h),BCM_SETTEXTMARGIN,0, (LPARAM)(p))
#define Button_GetImageList(h,p) (BOOL)SNDMSG((h),BCM_GETIMAGELIST,0,(LPARAM)(p))
#define Button_SetImageList(hwnd, pbuttonImagelist) (BOOL)SNDMSG((hwnd), BCM_SETIMAGELIST, 0, (LPARAM)(pbuttonImagelist))
#define Button_GetIdealSize(hwnd, psize) (BOOL)SNDMSG((hwnd), BCM_GETIDEALSIZE, 0, (LPARAM)(psize))
#define Edit_SetCueBannerText(hwnd, lpcwText) (BOOL)SNDMSG((hwnd), EM_SETCUEBANNER, 0, (LPARAM)(lpcwText))
#define Edit_GetCueBannerText(h,lpwText, cchText) (BOOL)SNDMSG((h),EM_GETCUEBANNER, (WPARAM)(lpwText), (LPARAM)(cchText))
#define Edit_ShowBalloonTip(hwnd, peditballoontip) (BOOL)SNDMSG((hwnd), EM_SHOWBALLOONTIP, 0, (LPARAM)(peditballoontip))
#define Edit_HideBalloonTip(hwnd) (BOOL)SNDMSG((hwnd), EM_HIDEBALLOONTIP, 0, 0)
#define DateTime_GetSystemtime(hdp, pst) (DWORD)SNDMSG(hdp, DTM_GETSYSTEMTIME, 0, (LPARAM)(pst))
#define DateTime_SetSystemtime(hdp, gd, pst) (BOOL)SNDMSG(hdp, DTM_SETSYSTEMTIME, (WPARAM)(gd), (LPARAM)(pst))
#define DateTime_GetRange(hdp, rgst) (DWORD)SNDMSG(hdp, DTM_GETRANGE, 0, (LPARAM)(rgst))
#define DateTime_SetRange(hdp, gd, rgst) (BOOL)SNDMSG(hdp, DTM_SETRANGE, (WPARAM)(gd), (LPARAM)(rgst))
#define Animate_Create(hP,id,S,I) CreateWindow(ANIMATE_CLASS,NULL,S,0,0,0,0,hP,(HMENU)(id),I,NULL)
#define Animate_Open(hw,Name) SendMessage(hw,ACM_OPEN,0,(LPARAM)(LPTSTR)(Name))
#define Animate_Play(h,f,t,r) SendMessage(h,ACM_PLAY,(WPARAM)(r),(LPARAM)MAKELONG(f,t))
#define Animate_Stop(hw) SendMessage(hw,ACM_STOP,0,0)
#define Animate_Close(h) Animate_Open(h,NULL)
#define Animate_Seek(h,f) Animate_Play(h,f,f,1)
#define PropSheet_AddPage(h,hp) SendMessage(h,PSM_ADDPAGE,0,(LPARAM)hp)
#define PropSheet_Apply(h) SendMessage(h,PSM_APPLY,0,0)
#define PropSheet_CancelToClose(h) SendMessage(h,PSM_CANCELTOCLOSE,0,0)
#define PropSheet_Changed(h,w) SendMessage(h,PSM_CHANGED,(WPARAM)w,0)
#define PropSheet_GetCurrentPageHwnd(h) SendMessage(h,PSM_GETCURRENTPAGEHWND,0,0)
#define PropSheet_GetTabControl(h) SendMessage(h,PSM_GETTABCONTROL,0,0)
#define PropSheet_IsDialogMessage(h,M) SendMessage(h,PSM_ISDIALOGMESSAGE,0,(LPARAM)M)
#define PropSheet_PressButton(h,B) SendMessage(h,PSM_PRESSBUTTON,(WPARAM)B,0)
#define PropSheet_QuerySiblings(h,p1,p2) SendMessage(h,PSM_QUERYSIBLINGS,(WPARAM)p1,(LPARAM)p2)
#define PropSheet_RebootSystem(h) SendMessage(h,PSM_REBOOTSYSTEM,0,0)
#define PropSheet_RemovePage(h,i,p) SendMessage(h,PSM_REMOVEPAGE,(WPARAM)(int)i,(LPARAM)p)
#define PropSheet_RestartWindows(h) SendMessage(h,PSM_RESTARTWINDOWS,0,0)
#define PropSheet_SetCurSel(hDlg,hpage,index) SendMessage(hDlg,PSM_SETCURSEL,(WPARAM)index,(LPARAM)hpage)
#define PropSheet_SetCurSelByID(hPropSheetDlg,id) SendMessage(hPropSheetDlg,PSM_SETCURSELID,0,(LPARAM)id)
#define PropSheet_SetFinishText(h,T) SendMessage(h,PSM_SETFINISHTEXT,0,(LPARAM)T)
#define PropSheet_SetTitle(h,S,T) SendMessage(h,PSM_SETTITLE,(WPARAM)S,(LPARAM)T)
#define PropSheet_SetWizButtons(h,F) SendMessage(h,PSM_SETWIZBUTTONS,0,(LPARAM)F)
#define PropSheet_UnChanged(hDlg,hP) SendMessage(hDlg,PSM_UNCHANGED,(WPARAM)(HWND)hP,0)
#define Header_DeleteItem(hHD,i) (BOOL)SendMessage((hHD),HDM_DELETEITEM,(WPARAM)(i),0)
#define Header_GetItem(hHD,i,p) (BOOL)SendMessage((hHD),HDM_GETITEM,(WPARAM)(i),(LPARAM)(p))
#define Header_GetUnicodeFormat(h) (BOOL)SendMessage(h,HDM_GETUNICODEFORMAT,0,0)
#define Header_SetUnicodeFormat(h,f) (BOOL)SendMessage(h,HDM_SETUNICODEFORMAT,f,0)
#define Header_GetItemCount(hHD) (int)SendMessage((hHD),HDM_GETITEMCOUNT,0,0)
#define Header_InsertItem(hHD,i,phdi) (int)SendMessage((hHD),HDM_INSERTITEM,(WPARAM)(i),(LPARAM)(phdi))
#define Header_Layout(hHD,p) (BOOL)SendMessage((hHD),HDM_LAYOUT,0,(LPARAM)(p))
#define Header_SetItem(hHD,i,p) (BOOL)SendMessage((hHD),HDM_SETITEM,(WPARAM)(i),(LPARAM)(p))
#define ListView_MapIDToIndex(hwnd, id) (UINT)SNDMSG((hwnd), LVM_MAPIDTOINDEX, (WPARAM)id, (LPARAM)0)
#define ListView_MapIndexToID(hwnd, index) (UINT)SNDMSG((hwnd), LVM_MAPINDEXTOID, (WPARAM)index, (LPARAM)0)
#define ListView_CancelEditLabel(hwnd) (VOID)SNDMSG((hwnd), LVM_CANCELEDITLABEL, (WPARAM)0, (LPARAM)0)
#define ListView_SetOutlineColor(hwnd, color) (COLORREF)SNDMSG((hwnd), LVM_SETOUTLINECOLOR, (WPARAM)0, (LPARAM)(COLORREF)(color))
#define ListView_GetOutlineColor(hwnd) (COLORREF)SNDMSG((hwnd), LVM_GETOUTLINECOLOR, 0, 0)
#define ListView_IsGroupViewEnabled(h) (BOOL)SNDMSG((h), LVM_ISGROUPVIEWENABLED, 0, 0)
#define ListView_GetSelectedColumn(hwnd) (UINT)SNDMSG((hwnd), LVM_GETSELECTEDCOLUMN, 0, 0)
#define ListView_SetInfoTip(hwndLV, plvInfoTip) (BOOL)SNDMSG((hwndLV), LVM_SETINFOTIP, (WPARAM)0, (LPARAM)plvInfoTip)
#define ListView_GetInsertMarkColor(h) (COLORREF)SNDMSG((h),LVM_GETINSERTMARKCOLOR,(WPARAM)0, (LPARAM)0)
#define ListView_SetInsertMarkColor(hwnd, color) (COLORREF)SNDMSG((hwnd), LVM_SETINSERTMARKCOLOR, (WPARAM)0, (LPARAM)(COLORREF)(color))
#define ListView_GetInsertMarkRect(h,rc) (int)SNDMSG((h),LVM_GETINSERTMARKRECT,(WPARAM)0,(LPARAM)(LPRECT)(rc))
#define ListView_InsertMarkHitTest(h,p,lvim) (int)SNDMSG((h),LVM_INSERTMARKHITTEST,(WPARAM)(LPPOINT)(p),(LPARAM)(LPLVINSERTMARK)(lvim))
#define ListView_GetInsertMark(hwnd, lvim) (BOOL)SNDMSG((hwnd), LVM_GETINSERTMARK, (WPARAM) 0, (LPARAM) (lvim))
#define ListView_SetInsertMark(hwnd, lvim) (BOOL)SNDMSG((hwnd), LVM_SETINSERTMARK, (WPARAM) 0, (LPARAM) (lvim))
#define ListView_GetTileInfo(hwnd, pti) SNDMSG((hwnd), LVM_GETTILEINFO, 0, (LPARAM)pti)
#define ListView_SetTileInfo(hwnd, pti) SNDMSG((hwnd), LVM_SETTILEINFO, 0, (LPARAM)pti)
#define ListView_GetTileViewInfo(hwnd, ptvi) SNDMSG((hwnd), LVM_GETTILEVIEWINFO, 0, (LPARAM)ptvi)
#define ListView_SetTileViewInfo(hwnd, ptvi) SNDMSG((hwnd), LVM_SETTILEVIEWINFO, 0, (LPARAM)ptvi)
#define ListView_HasGroup(hwnd, dwGroupId) SNDMSG((hwnd), LVM_HASGROUP, dwGroupId, 0)
#define ListView_RemoveAllGroups(hwnd) SNDMSG((hwnd), LVM_REMOVEALLGROUPS, 0, 0)
#define ListView_InsertGroupSorted(hwnd, structInsert) SNDMSG((hwnd), LVM_INSERTGROUPSORTED, (WPARAM)structInsert, 0)
#define ListView_SortGroups(hwnd, _pfnGroupCompate, _plv) SNDMSG((hwnd), LVM_SORTGROUPS, (WPARAM)_pfnGroupCompate, (LPARAM)_plv)
#define ListView_EnableGroupView(hwnd, fEnable) SNDMSG((hwnd), LVM_ENABLEGROUPVIEW, (WPARAM)fEnable, 0)
#define ListView_GetGroupMetrics(hwnd, pGroupMetrics) SNDMSG((hwnd), LVM_GETGROUPMETRICS, 0, (LPARAM)pGroupMetrics)
#define ListView_SetGroupMetrics(hwnd, pGroupMetrics) SNDMSG((hwnd),LVM_SETGROUPMETRICS, 0, (LPARAM)pGroupMetrics)
#define ListView_MoveItemToGroup(hwnd, idItemFrom, idGroupTo) SNDMSG((hwnd), LVM_MOVEITEMTOGROUP, (WPARAM)idItemFrom, (LPARAM)idGroupTo)
#define ListView_MoveGroup(hwnd, iGroupId, toIndex) SNDMSG((hwnd), LVM_MOVEGROUP, (WPARAM)iGroupId, (LPARAM)toIndex)
#define ListView_RemoveGroup(hwnd, iGroupId) SNDMSG((hwnd), LVM_REMOVEGROUP, (WPARAM)iGroupId, 0)
#define ListView_GetGroupInfo(hwnd, iGroupId, pgrp) SNDMSG((hwnd),LVM_GETGROUPINFO, (WPARAM)iGroupId, (LPARAM)pgrp)
#define ListView_SetGroupInfo(hwnd, iGroupId, pgrp) SNDMSG((hwnd), LVM_SETGROUPINFO, (WPARAM)iGroupId, (LPARAM)pgrp)
#define ListView_InsertGroup(hwnd, index, pgrp) SNDMSG((hwnd), LVM_INSERTGROUP, (WPARAM)index, (LPARAM)pgrp)
#define ListView_SetTileWidth(h,cpWidth) SNDMSG((h), LVM_SETTILEWIDTH,(WPARAM)cpWidth,0)
#define ListView_SetSelectedColumn(h,iCol) SNDMSG((h), LVM_SETSELECTEDCOLUMN, (WPARAM)iCol, 0)
#define ListView_ApproximateViewRect(h,W,H,C) (DWORD)SNDMSG((h),LVM_APPROXIMATEVIEWRECT,C,MAKELPARAM(W,H))
#define ListView_SetView(hwnd, iView) (DWORD)SNDMSG((hwnd), LVM_SETVIEW, (WPARAM)(DWORD)iView, 0)
#define ListView_GetColumnOrderArray(h,iCount, pi) (BOOL)SendMessage((h),LVM_GETCOLUMNORDERARRAY,(WPARAM)(iCount),(LPARAM)(LPINT)(pi))
#define ListView_GetExtendedListViewStyle(h) (DWORD)SendMessage((h),LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0)
#define ListView_GetHeader(hwnd) (HWND)SendMessage((hwnd), LVM_GETHEADER, 0, 0L)
#define ListView_GetHotCursor(hwnd) (HCURSOR)SendMessage((hwnd), LVM_GETHOTCURSOR, 0, 0)
#define ListView_GetHotItem(hwnd) (int)SendMessage((hwnd), LVM_GETHOTITEM, 0, 0)
#define ListView_SetColumnOrderArray(hwnd, iCount, pi) (BOOL)SendMessage((hwnd), LVM_SETCOLUMNORDERARRAY, (WPARAM)(iCount), (LPARAM)(LPINT)(pi))
#define ListView_SetExtendedListViewStyle(h,dw) (DWORD)SNDMSG((h),LVM_SETEXTENDEDLISTVIEWSTYLE,0,dw)
#define ListView_SetExtendedListViewStyleEx(h,M,dw) (DWORD)SNDMSG(h,LVM_SETEXTENDEDLISTVIEWSTYLE,M,dw)
#define ListView_SetHotItem(hwnd, i) (int)SendMessage((hwnd),LVM_SETHOTITEM, (WPARAM)(i),0)
#define ListView_SetHotCursor(hwnd, hcur) (HCURSOR)SendMessage((hwnd), LVM_SETHOTCURSOR, 0, (LPARAM)(hcur))
#define ListView_SetIconSpacing(hwndLV, cx, cy) (DWORD)SendMessage((hwndLV), LVM_SETICONSPACING,0, MAKELONG(cx,cy))
#define ListView_SetWorkAreas(h,WA,prc) (BOOL)SNDMSG((h),LVM_SETWORKAREAS,(WPARAM)(int)(WA),(LPARAM)(RECT *)(prc))
#define ListView_SetCheckState(h,i,f) ListView_SetItemState(h,i,INDEXTOSTATEIMAGEMASK((f)?2:1),LVIS_STATEIMAGEMASK)
#define ListView_GetCheckState(h,i) ((((UINT)(SNDMSG((h),LVM_GETITEMSTATE,(WPARAM)(i),LVIS_STATEIMAGEMASK))) >> 12) -1)
#define ListView_GetWorkAreas(hwnd, nWorkAreas, prc) (BOOL)SNDMSG((hwnd),LVM_GETWORKAREAS,(WPARAM)(int)(nWorkAreas),(LPARAM)(RECT *)(prc))
#define ListView_GetNumberOfWorkAreas(hwnd, pnWorkAreas) (BOOL)SNDMSG((hwnd),LVM_GETNUMBEROFWORKAREAS,0,(LPARAM)(UINT *)(pnWorkAreas))
#define ListView_GetSelectionMark(hwnd) (int)SNDMSG((hwnd),LVM_GETSELECTIONMARK,0,0)
#define ListView_SetSelectionMark(hwnd, i) (int)SNDMSG((hwnd),LVM_SETSELECTIONMARK,0,(LPARAM)(i))
#define ListView_GetSubItemRect(h,i,SI,code,prc) (BOOL)SNDMSG((h),LVM_GETSUBITEMRECT,(WPARAM)(int)(i), ((prc) ? ((((LPRECT)(prc))->top=SI),(((LPRECT)(prc))->left = code), (LPARAM)(prc)) : (LPARAM)(LPRECT)NULL))
#define ListView_SubItemHitTest(h,p) (int)SNDMSG((h),LVM_SUBITEMHITTEST,0,(LPARAM)(LPLVHITTESTINFO)(p))
#define ListView_SetHoverTime(hwndLV, dwHoverTimeMs) (DWORD)SNDMSG((hwndLV),LVM_SETHOVERTIME,0,(LPARAM)(dwHoverTimeMs))
#define ListView_GetHoverTime(hwndLV) (DWORD)SNDMSG((hwndLV),LVM_GETHOVERTIME,0,0)
#define ListView_SetToolTips(hwndLV, hwndNewHwnd) (HWND)SNDMSG((hwndLV),LVM_SETTOOLTIPS,(WPARAM)(hwndNewHwnd),0)
#define ListView_GetToolTips(hwndLV) (HWND)SNDMSG((hwndLV),LVM_GETTOOLTIPS,0,0)
#define ListView_SortItemsEx(hwndLV, _pfnCompare, _lPrm) (BOOL)SNDMSG((hwndLV),LVM_SORTITEMSEX,(WPARAM)(LPARAM)(_lPrm),(LPARAM)(PFNLVCOMPARE)(_pfnCompare))
#define ListView_SetBkImage(hwnd, plvbki) (BOOL)SNDMSG((hwnd),LVM_SETBKIMAGE,0,(LPARAM)(plvbki))
#define ListView_GetBkImage(hwnd, plvbki) (BOOL)SNDMSG((hwnd),LVM_GETBKIMAGE,0,(LPARAM)(plvbki))
#define ListView_Arrange(hLV,c) SendMessage((hLV),LVM_ARRANGE,(WPARAM)(c),0)
#define ListView_CreateDragImage(h,i,l) SendMessage((h),LVM_CREATEDRAGIMAGE,(WPARAM)(i),(LPARAM)(l))
#define ListView_DeleteAllItems(h) SendMessage(h,LVM_DELETEALLITEMS,0,0)
#define ListView_DeleteColumn(h,iCol) SendMessage((h),LVM_DELETECOLUMN,(WPARAM)(iCol),0)
#define ListView_DeleteItem(h,iItem) SendMessage(h,LVM_DELETEITEM,(WPARAM)iItem,0)
#define ListView_EditLabel(hLV,i) (HWND)SendMessage((hLV),LVM_EDITLABEL,(WPARAM)i,0)
#define ListView_EnsureVisible(hLV,i,fOK) SendMessage(hLV,LVM_ENSUREVISIBLE,(WPARAM)i,MAKELPARAM((fOK),0))
#define ListView_FindItem(hwnd,i,p) SendMessage(hwnd,LVM_FINDITEM,(WPARAM)i,(LPARAM)p)
#define ListView_GetBkColor(hwnd) SendMessage((HWND)hwnd,LVM_GETBKCOLOR,0,0)
#define ListView_GetCallbackMask(h) SendMessage(h,LVM_GETCALLBACKMASK,0,0)
#define ListView_GetColumn(hwnd,iCol,pcol) SendMessage((hwnd),LVM_GETCOLUMN,(WPARAM)(iCol),(LPARAM)(pcol))
#define ListView_GetColumnWidth(h,iCol) SendMessage((h),LVM_GETCOLUMNWIDTH,(WPARAM)(iCol),0)
#define ListView_GetCountPerPage(h) SendMessage((h),LVM_GETCOUNTPERPAGE,0,0)
#define ListView_GetEditControl(h) (HWND)SendMessage((h),LVM_GETEDITCONTROL,0,0)
#define ListView_GetImageList(h,iIL) SendMessage(h,LVM_GETIMAGELIST,(WPARAM)iIL,0)
#define ListView_GetISearchString(h,l) SendMessage((h),LVM_GETISEARCHSTRING,0,(LPARAM)l)
#define ListView_GetItem(h,p) SendMessage(h,LVM_GETITEM,0,(LPARAM)(p))
#define ListView_GetItemCount(h) SendMessage(h,LVM_GETITEMCOUNT,0,0)
#define ListView_GetItemPosition(h,i,ppt) SendMessage(h,LVM_GETITEMPOSITION,(WPARAM)(int)i,(LPARAM)ppt)
#define ListView_GetItemRect(h,i,p,c) SendMessage(h,LVM_GETITEMRECT,(WPARAM)i,((p) ? (((RECT *)(p))->left=(c),(LPARAM)(p)):(LPARAM)NULL))
#define ListView_GetItemSpacing(hLV,f) SendMessage((hLV),LVM_GETITEMSPACING,f,0)
#define ListView_GetItemState(hLV,i,m) SendMessage((hLV),LVM_GETITEMSTATE,(WPARAM)i,(LPARAM)m)
#define ListView_GetItemText(hLV,i,iS,T,c) {LV_ITEM _gnu_l;_gnu_l.iSubItem=iS;_gnu_l.cchTextMax=c;_gnu_l.pszText=(TCHAR *)T;SendMessage((hLV),LVM_GETITEMTEXT,(WPARAM)i,(LPARAM)&_gnu_l);}
#define ListView_GetNextItem(h,S,f) SendMessage(h,LVM_GETNEXTITEM,(WPARAM)S,(LPARAM)f)
#define ListView_GetOrigin(hLV,ppt) SendMessage((hLV),LVM_GETORIGIN,(WPARAM)0,(LPARAM)(ppt))
#define ListView_GetSelectedCount(h) SendMessage((h),LVM_GETSELECTEDCOUNT,0,0)
#define ListView_GetStringWidth(h,psz) SendMessage(h,LVM_GETSTRINGWIDTH,0,(LPARAM)psz)
#define ListView_GetTextBkColor(h) SendMessage((h),LVM_GETTEXTBKCOLOR,0,0)
#define ListView_GetTextColor(h) SendMessage((h),LVM_GETTEXTCOLOR,0,0)
#define ListView_GetTopIndex(h) SendMessage((h),LVM_GETTOPINDEX,0,0)
#define ListView_GetViewRect(h,prc) SendMessage((h),LVM_GETVIEWRECT,0,(LPARAM)(prc))
#define ListView_HitTest(hLV,pinfo) SendMessage(hLV,LVM_HITTEST,0,(LPARAM)pinfo)
#define ListView_InsertColumn(hwnd,iCol,pcol) SendMessage((hwnd),LVM_INSERTCOLUMN,(WPARAM)(int)(iCol),(LPARAM)(pcol))
#define ListView_InsertItem(hwnd,pitem) SendMessage(hwnd,LVM_INSERTITEM,0,(LPARAM)pitem)
#define ListView_RedrawItems(hLV,iFirst,iLast) SendMessage((hLV),LVM_REDRAWITEMS,(WPARAM)iFirst,(LPARAM)iLast)
#define ListView_Scroll(hLV,dx,dy) SendMessage((hLV),LVM_SCROLL,(WPARAM)dx,(LPARAM)dy)
#define ListView_SetBkColor(h,clrBk) SendMessage(h,LVM_SETBKCOLOR,0,(LPARAM)(COLORREF)clrBk)
#define ListView_SetCallbackMask(h,m) SendMessage(h,LVM_SETCALLBACKMASK,(WPARAM)(UINT)(m),0)
#define ListView_SetColumn(h,iCol,pcol) SendMessage((h),LVM_SETCOLUMN,(WPARAM)(iCol),(LPARAM)(pcol))
#define ListView_SetColumnWidth(hwnd,iCol,cx) SendMessage((hwnd),LVM_SETCOLUMNWIDTH,(WPARAM)(int)(iCol),MAKELPARAM((cx),0))
#define ListView_SetImageList(hwnd,himl,iImageList) (HIMAGELIST)SendMessage(hwnd,LVM_SETIMAGELIST,(WPARAM)(iImageList),(LPARAM)(HIMAGELIST)(himl))
#define ListView_SetItem(hwnd,pitem) SendMessage(hwnd,LVM_SETITEM,0,(LPARAM)pitem)
#define ListView_SetItemCount(hLV,cItems) SendMessage((hLV),LVM_SETITEMCOUNT,(WPARAM)cItems,0)
#define ListView_SetItemPosition(hLV,i,x,y) SendMessage(hLV,LVM_SETITEMPOSITION,(WPARAM)(int)(i),MAKELPARAM((x),(y)))
#define ListView_SetItemPosition32(hLV,i,x,y) {POINT ptNewPos={x,y};SendMessage((hLV),LVM_SETITEMPOSITION32,(WPARAM)(i),(LPARAM)&ptNewPos);}
#define ListView_SetItemState(hLV,i,d,m) {LV_ITEM _gnu_l;_gnu_l.stateMask=m;_gnu_l.state=d;SendMessage((hLV),LVM_SETITEMSTATE,(WPARAM)(i),(LPARAM)&_gnu_l);}
#define ListView_SetItemText(hLV,i,iS,T) {LV_ITEM _gnu_l;_gnu_l.iSubItem=iS;_gnu_l.pszText=T;SendMessage((hLV),LVM_SETITEMTEXT,(WPARAM)(i),(LPARAM)&_gnu_l);}
#define ListView_SetTextBkColor(h,c) SendMessage((h),LVM_SETTEXTBKCOLOR,0,(LPARAM)(c))
#define ListView_SetTextColor(h,c) SendMessage((h),LVM_SETTEXTCOLOR,0,(LPARAM)(c))
#define ListView_SortItems(hLV,p,l) SendMessage((hLV),LVM_SORTITEMS,(WPARAM)l,(LPARAM)p)
#define ListView_Update(hLV,i) SendMessage((hLV),LVM_UPDATE,(WPARAM)i,0)
#define ListView_GetUnicodeFormat(h) (BOOL)SendMessage((h),LVM_GETUNICODEFORMAT,0,0)
#define ListView_SetUnicodeFormat(h,f) (BOOL)SendMessage((h),LVM_SETUNICODEFORMAT,(WPARAM)f,0)
#define TreeView_GetScrollTime(h) (UINT)SendMessage(h,TVM_GETSCROLLTIME,0,0)
#define TreeView_SetItemHeight(h,iHeight) (int)SendMessage((h), TVM_SETITEMHEIGHT,(WPARAM)(iHeight), 0)
#define TreeView_GetItemHeight(h) (int)SendMessage((h),TVM_GETITEMHEIGHT, 0, 0)
#define TreeView_SetItemState(h,hti,d,m) {TVITEM TVi;TVi.mask=TVIF_STATE;TVi.hItem = hti;TVi.stateMask=m;TVi.state=d;SNDMSG((h),TVM_SETITEM,0,(LPARAM)(TV_ITEM *)&TVi);}
#define TreeView_SetBkColor(h,clr) (COLORREF)SendMessage((h),TVM_SETBKCOLOR, 0, (LPARAM)(clr))
#define TreeView_SetTextColor(hwnd, clr) (COLORREF)SendMessage((hwnd), TVM_SETTEXTCOLOR, 0, (LPARAM)(clr))
#define TreeView_GetBkColor(hwnd) (COLORREF)SendMessage((hwnd), TVM_GETBKCOLOR, 0, 0)
#define TreeView_GetTextColor(hwnd) (COLORREF)SendMessage((hwnd),TVM_GETTEXTCOLOR, 0, 0)
#define TreeView_SetScrollTime(hwnd, uTime) (UINT)SendMessage((hwnd), TVM_SETSCROLLTIME, uTime, 0)
#define TreeView_SetInsertMarkColor(hwnd, clr) (COLORREF)SendMessage((hwnd),TVM_SETINSERTMARKCOLOR, 0, (LPARAM)(clr))
#define TreeView_GetInsertMarkColor(hwnd) (COLORREF)SendMessage((hwnd), TVM_GETINSERTMARKCOLOR, 0, 0)
#define TreeView_InsertItem(h,l) (HTREEITEM)SendMessage((h),TVM_INSERTITEM,0,(LPARAM)(l))
#define TreeView_DeleteItem(h,i) (HTREEITEM)SendMessage((h),TVM_DELETEITEM,0,(LPARAM)(i))
#define TreeView_DeleteAllItems(h) SendMessage((h),TVM_DELETEITEM,0,(LPARAM)TVI_ROOT)
#define TreeView_Expand(h,i,c) SendMessage((h),TVM_EXPAND,(WPARAM)c,(LPARAM)(i))
#define TreeView_GetLineColor(h) (COLORREF)SendMessage(h,TVM_GETLINECOLOR,0,0)
#define TreeView_SetLineColor(h,c) (COLORREF)SendMessage(h,TVM_SETLINECOLOR,0,(LPARAM)c)
#define TreeView_GetCheckState(h,i) ((((UINT)(SendMessage(h,TVM_GETITEMSTATE,(WPARAM)i,TVIS_STATEIMAGEMASK))) >> 12) -1)
#define TreeView_GetItemState(h,i,m) (UINT)SendMessage(h,TVM_GETITEMSTATE,(WPARAM)i,(LPARAM)m)
#define TreeView_SetCheckState(h,i,C) TreeView_SetItemState(h,i,INDEXTOSTATEIMAGEMASK((C)?2:1),TVIS_STATEIMAGEMASK)
#define TreeView_GetItemRect(h,hitem,prc,c) (*(HTREEITEM *)prc=(hitem),(BOOL)SendMessage((h),TVM_GETITEMRECT,(WPARAM)(c),(LPARAM)(RECT *)(prc)))
#define TreeView_GetCount(h) SendMessage((h),TVM_GETCOUNT,0,0)
#define TreeView_GetIndent(h) SendMessage((h),TVM_GETINDENT,0,0)
#define TreeView_SetIndent(h,i) SendMessage((h),TVM_SETINDENT,(WPARAM)i,0)
#define TreeView_GetImageList(h,i) SendMessage((h),TVM_GETIMAGELIST,i,0)
#define TreeView_SetImageList(h,hi,i) SendMessage((h),TVM_SETIMAGELIST,i,(LPARAM)(hi))
#define TreeView_GetNextItem(h,hi,c) (HTREEITEM)SendMessage((h),TVM_GETNEXTITEM,(WPARAM)c,(LPARAM)(hi))
#define TreeView_GetChild(h,i) TreeView_GetNextItem(h,i,TVGN_CHILD)
#define TreeView_GetNextSibling(h,i) TreeView_GetNextItem(h,i,TVGN_NEXT)
#define TreeView_GetPrevSibling(h,i) TreeView_GetNextItem(h,i,TVGN_PREVIOUS)
#define TreeView_GetParent(h,i) TreeView_GetNextItem(h,i,TVGN_PARENT)
#define TreeView_GetFirstVisible(h) TreeView_GetNextItem(h,NULL,TVGN_FIRSTVISIBLE)
#define TreeView_GetNextVisible(h,i) TreeView_GetNextItem(h,i,TVGN_NEXTVISIBLE)
#define TreeView_GetPrevVisible(h,i) TreeView_GetNextItem(h,i,TVGN_PREVIOUSVISIBLE)
#define TreeView_GetSelection(h) TreeView_GetNextItem(h,NULL,TVGN_CARET)
#define TreeView_GetDropHilight(h) TreeView_GetNextItem(h,NULL,TVGN_DROPHILITE)
#define TreeView_GetRoot(h) (HTREEITEM)TreeView_GetNextItem(h,NULL,TVGN_ROOT)
#define TreeView_Select(h,i,c) SendMessage((h),TVM_SELECTITEM,(WPARAM)c,(LPARAM)(i))
#define TreeView_SelectItem(h,i) TreeView_Select(h,i,TVGN_CARET)
#define TreeView_SelectDropTarget(h,i) TreeView_Select(h,i,TVGN_DROPHILITE)
#define TreeView_SelectSetFirstVisible(h,p) TreeView_Select(h,p,TVGN_FIRSTVISIBLE)
#define TreeView_GetItem(h,p) SendMessage((h),TVM_GETITEM,0,(LPARAM)(TV_ITEM *)(p))
#define TreeView_SetItem(h,p) (int)SendMessage((h),TVM_SETITEM,0,(LPARAM)(TV_ITEM *)(p))
#define TreeView_EditLabel(h,i) (HWND)SendMessage((h),TVM_EDITLABEL,0,(LPARAM)(HTREEITEM)(i))
#define TreeView_GetEditControl(h) (HWND)SendMessage((h),TVM_GETEDITCONTROL,0,0)
#define TreeView_GetVisibleCount(h) (unsigned int)SendMessage((h),TVM_GETVISIBLECOUNT,0,0)
#define TreeView_HitTest(h,l) (HTREEITEM)SendMessage((h),TVM_HITTEST,0,(LPARAM)(LPTV_HITTESTINFO)(l))
#define TreeView_CreateDragImage(hwnd,hitem) (HIMAGELIST)SendMessage((hwnd),TVM_CREATEDRAGIMAGE,0,(LPARAM)(hitem))
#define TreeView_SortChildren(h,i,r) (BOOL)SendMessage((h),TVM_SORTCHILDREN,(WPARAM)r,(LPARAM)(i))
#define TreeView_EnsureVisible(h,i) (BOOL)SendMessage((h),TVM_ENSUREVISIBLE,0,(LPARAM)(i))
#define TreeView_SortChildrenCB(h,p,r) SendMessage((h),TVM_SORTCHILDRENCB,(WPARAM)r,(LPARAM)(p))
#define TreeView_EndEditLabelNow(h,f) SendMessage((h),TVM_ENDEDITLABELNOW,(WPARAM)f,0)
#define TreeView_GetISearchString(h,lpsz) SendMessage((h),TVM_GETISEARCHSTRING,0,(LPARAM)(LPTSTR)lpsz)
#define TabCtrl_GetImageList(h) SendMessage((h),TCM_GETIMAGELIST,0,0)
#define TabCtrl_SetImageList(hwnd,himl) SendMessage((hwnd),TCM_SETIMAGELIST,0,(LPARAM)(himl))
#define TabCtrl_GetItemCount(hwnd) SendMessage((hwnd),TCM_GETITEMCOUNT,0,0)
#define TabCtrl_GetItem(h,i,p) SendMessage(h,TCM_GETITEM,(WPARAM)i,(LPARAM)(TC_ITEM *)(p))
#define TabCtrl_SetItem(h,i,p) SendMessage((h),TCM_SETITEM,(WPARAM)i,(LPARAM)(TC_ITEM *)(p))
#define TabCtrl_InsertItem(h,i,p) SendMessage((h),TCM_INSERTITEM,(WPARAM)i,(LPARAM)(TC_ITEM *)(p))
#define TabCtrl_DeleteItem(hwnd,i) SendMessage((hwnd),TCM_DELETEITEM,(WPARAM)(int)(i),0)
#define TabCtrl_DeleteAllItems(h) SendMessage((h),TCM_DELETEALLITEMS,0,0)
#define TabCtrl_GetItemRect(h,i,prc) SendMessage((h),TCM_GETITEMRECT,(WPARAM)(i),(LPARAM)(prc))
#define TabCtrl_GetCurSel(h) SendMessage((h),TCM_GETCURSEL,0,0)
#define TabCtrl_SetCurSel(h,i) SendMessage((h),TCM_SETCURSEL,(WPARAM)i,0)
#define TabCtrl_HitTest(h,p) SendMessage((h),TCM_HITTEST,0,(LPARAM)(TC_HITTESTINFO *)(p))
#define TabCtrl_SetItemExtra(h,cb) SendMessage((h),TCM_SETITEMEXTRA,(WPARAM)(cb),0)
#define TabCtrl_AdjustRect(h,L,prc) SendMessage(h,TCM_ADJUSTRECT,(WPARAM)L,(LPARAM)(RECT *)prc)
#define TabCtrl_SetItemSize(h,x,y) SendMessage((h),TCM_SETITEMSIZE,0,MAKELPARAM(x,y))
#define TabCtrl_RemoveImage(h,i) SendMessage((h),TCM_REMOVEIMAGE,i,0)
#define TabCtrl_SetPadding(h,cx,cy) SendMessage((h),TCM_SETPADDING,0,MAKELPARAM(cx,cy))
#define TabCtrl_GetRowCount(h) SendMessage((h),TCM_GETROWCOUNT,0,0)
#define TabCtrl_GetToolTips(h) SendMessage((h),TCM_GETTOOLTIPS,0,0)
#define TabCtrl_SetToolTips(h,T) SendMessage((h),TCM_SETTOOLTIPS,(WPARAM)T,0)
#define TabCtrl_GetCurFocus(hwnd) SendMessage((hwnd),TCM_GETCURFOCUS,0,0)
#define TabCtrl_SetCurFocus(hwnd,i) SendMessage((hwnd),TCM_SETCURFOCUS,i,0)
#define TabCtrl_SetMinTabWidth(h,x) (int)SNDMSG((h),TCM_SETMINTABWIDTH,0,x)
#define TabCtrl_DeselectAll(h,E) (void)SNDMSG((h), TCM_DESELECTALL,E,0)
#define TabCtrl_SetExtendedStyle(h,d) (DWORD)SNDMSG((h),TCM_SETEXTENDEDSTYLE,0,d)
#define TabCtrl_GetExtendedStyle(h) (DWORD)SNDMSG((h),TCM_GETEXTENDEDSTYLE,0,0)
#define TabCtrl_SetUnicodeFormat(h,U) (BOOL)SNDMSG((h),TCM_SETUNICODEFORMAT,(WPARAM)(U),0)
#define TabCtrl_GetUnicodeFormat(h) (BOOL)SNDMSG((h),TCM_GETUNICODEFORMAT,0,0)
#define CommDlg_OpenSave_GetSpecA(h,p,c) SendMessage(h,CDM_GETSPEC,(WPARAM)c,(LPARAM)p)
#define CommDlg_OpenSave_GetSpecW(h,_psz,c) SendMessage(h,CDM_GETSPEC,(WPARAM)c,(LPARAM)_psz)
#define CommDlg_OpenSave_GetFilePathA(_hdlg,_psz,c) SendMessage(_hdlg,CDM_GETFILEPATH,(WPARAM)c,(LPARAM)(LPSTR)_psz)
#define CommDlg_OpenSave_GetFilePathW(h,p,c) SendMessage(h,CDM_GETFILEPATH,(WPARAM)c,(LPARAM)(LPWSTR)p)
#define CommDlg_OpenSave_GetFolderPathA(h,_psz,c) SendMessage(h,CDM_GETFOLDERPATH,(WPARAM)c,(LPARAM)(LPSTR)_psz)
#define CommDlg_OpenSave_GetFolderPathW(h,p,c) SendMessage(h,CDM_GETFOLDERPATH,(WPARAM)c,(LPARAM)(LPWSTR)p)
#define CommDlg_OpenSave_GetFolderIDList(g,p,c) SendMessage(g,CDM_GETFOLDERIDLIST,(WPARAM)c,(LPARAM)(LPVOID)p)
#define CommDlg_OpenSave_SetControlText(h,id,t) SendMessage(h,CDM_SETCONTROLTEXT,(WPARAM)id,(LPARAM)t)
#define CommDlg_OpenSave_HideControl(_hdlg,_id) SendMessage(_hdlg,CDM_HIDECONTROL,(WPARAM)_id,0)
#define CommDlg_OpenSave_SetDefExt(h,psz) SendMessage(h,CDM_SETDEFEXT,0,(LPARAM)psz)
#define GetCurrentFiber() (((PNT_TIB)NtCurrentTeb())->FiberData)
#define GetFiberData() (*(PVOID *)(GetCurrentFiber()))
LONG RegCloseKey (HKEY);
LONG RegSetKeySecurity(HKEY,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR);
LONG RegFlushKey(HKEY);
LONG RegGetKeySecurity(HKEY,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,LPDWORD);
LONG RegNotifyChangeKeyValue(HKEY,BOOL,DWORD,HANDLE,BOOL);
BOOL IsValidCodePage(UINT);
UINT GetACP(void);
UINT GetOEMCP(void);
BOOL GetCPInfo(UINT,LPCPINFO);
BOOL IsDBCSLeadByte(BYTE);
BOOL IsDBCSLeadByteEx(UINT,BYTE);
int MultiByteToWideChar(UINT,DWORD,LPCSTR,int,LPWSTR,int);
int WideCharToMultiByte(UINT,DWORD,LPCWSTR,int,LPSTR,int,LPCSTR,LPBOOL);
BOOL IsValidLocale(LCID,DWORD);
LCID ConvertDefaultLocale(LCID);
LCID GetThreadLocale(void);
BOOL SetThreadLocale(LCID);
LANGID GetSystemDefaultLangID(void);
LANGID GetUserDefaultLangID(void);
LCID GetSystemDefaultLCID(void);
LCID GetUserDefaultLCID(void);
BOOL ReadConsoleOutputAttribute(HANDLE,LPWORD,DWORD,COORD,LPDWORD);
BOOL WriteConsoleOutputAttribute(HANDLE,CONST WORD *,DWORD,COORD,LPDWORD);
BOOL FillConsoleOutputAttribute(HANDLE,WORD,DWORD,COORD,LPDWORD);
BOOL GetConsoleMode(HANDLE,LPDWORD);
BOOL GetNumberOfConsoleInputEvents(HANDLE,LPDWORD);
BOOL GetConsoleScreenBufferInfo(HANDLE,PCONSOLE_SCREEN_BUFFER_INFO);
COORD GetLargestConsoleWindowSize(HANDLE);
BOOL GetConsoleCursorInfo(HANDLE,PCONSOLE_CURSOR_INFO);
BOOL GetNumberOfConsoleMouseButtons(LPDWORD);
BOOL SetConsoleMode(HANDLE,DWORD);
BOOL SetConsoleActiveScreenBuffer(HANDLE);
BOOL FlushConsoleInputBuffer(HANDLE);
BOOL SetConsoleScreenBufferSize(HANDLE,COORD);
BOOL SetConsoleCursorPosition(HANDLE,COORD);
BOOL SetConsoleCursorInfo(HANDLE,CONST CONSOLE_CURSOR_INFO *);
BOOL SetConsoleWindowInfo(HANDLE,BOOL,CONST SMALL_RECT *);
BOOL SetConsoleTextAttribute(HANDLE,WORD);
BOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE,BOOL);
BOOL GenerateConsoleCtrlEvent(DWORD,DWORD);
BOOL AllocConsole(VOID);
BOOL FreeConsole(VOID);
HANDLE CreateConsoleScreenBuffer(DWORD,DWORD,CONST SECURITY_ATTRIBUTES *,DWORD,LPVOID);
UINT GetConsoleCP(VOID);
BOOL SetConsoleCP(UINT);
UINT GetConsoleOutputCP(VOID);
BOOL SetConsoleOutputCP(UINT);
DWORD WNetConnectionDialog(HWND,DWORD);
DWORD WNetDisconnectDialog(HWND,DWORD);
DWORD WNetCloseEnum( HANDLE);
BOOL NotifyBootConfigStatus(BOOL);
BOOL WinLoadTrustProvider(GUID *);
LONG WinVerifyTrust(HWND,GUID *,LPVOID);
BOOL WinSubmitCertificate(LPWIN_CERTIFICATE);
BOOL	WINAPI wglCopyContext(HGLRC,HGLRC, UINT);
HGLRC	WINAPI wglCreateContext(HDC);
HGLRC	WINAPI wglCreateLayerContext(HDC,int);
BOOL	WINAPI wglDeleteContext(HGLRC);
HGLRC	WINAPI wglGetCurrentContext(VOID);
HDC	WINAPI wglGetCurrentDC(VOID);
FARPROC	WINAPI wglGetProcAddress(LPCSTR);
BOOL	WINAPI wglMakeCurrent(HDC,HGLRC);
BOOL	WINAPI wglShareLists(HGLRC,HGLRC);
BOOL	WINAPI wglUseFontBitmapsA(HDC,DWORD, DWORD, DWORD);
BOOL	WINAPI wglUseFontBitmapsW(HDC,DWORD, DWORD, DWORD);
BOOL	WINAPI SwapBuffers(HDC);
BOOL	WINAPI wglSwapLayerBuffers(HDC,UINT);
BOOL	WINAPI GetAltTabInfoA(HWND,int,PALTTABINFO,LPSTR,UINT);
BOOL	WINAPI GetAltTabInfoW(HWND,int,PALTTABINFO,LPWSTR,UINT);
#ifdef UNICODE
#define wglUseFontBitmaps wglUseFontBitmapsW
#define GetAltTabInfo	GetAltTabInfoW
#define CreateWaitableTimer	CreateWaitableTimerW
#else
#define wglUseFontBitmaps wglUseFontBitmapsA
#define GetAltTabInfo	GetAltTabInfoA
#define CreateWaitableTimer	CreateWaitableTimerA
#endif
typedef struct _POINTFLOAT {
	FLOAT	x;
	FLOAT	y;
} POINTFLOAT,*PPOINTFLOAT;
typedef struct _GLYPHMETRICSFLOAT {
	FLOAT	gmfBlackBoxX;
	FLOAT	gmfBlackBoxY;
	POINTFLOAT gmfptGlyphOrigin;
	FLOAT	gmfCellIncX;
	FLOAT	gmfCellIncY;
} GLYPHMETRICSFLOAT,*PGLYPHMETRICSFLOAT,*LPGLYPHMETRICSFLOAT;
#define WGL_FONT_LINES	0
#define WGL_FONT_POLYGONS	1
#define WGL_SWAPMULTIPLE_MAX 16
BOOL	WINAPI wglUseFontOutlinesA(HDC,DWORD,DWORD,DWORD,FLOAT,FLOAT,int,LPGLYPHMETRICSFLOAT);
BOOL	WINAPI wglUseFontOutlinesW(HDC,DWORD,DWORD,DWORD,FLOAT,FLOAT,int,LPGLYPHMETRICSFLOAT);
#ifdef UNICODE
#define wglUseFontOutlines wglUseFontOutlinesW
#else
#define wglUseFontOutlines wglUseFontOutlinesA
#endif
typedef struct _LAYERPLANEDESCRIPTOR {
	WORD	nSize;
	WORD	nVersion;
	DWORD	dwFlags;
	BYTE	iPixelType;
	BYTE	cColorBits;
	BYTE	cRedBits;
	BYTE	cRedShift;
	BYTE	cGreenBits;
	BYTE	cGreenShift;
	BYTE	cBlueBits;
	BYTE	cBlueShift;
	BYTE	cAlphaBits;
	BYTE	cAlphaShift;
	BYTE	cAccumBits;
	BYTE	cAccumRedBits;
	BYTE	cAccumGreenBits;
	BYTE	cAccumBlueBits;
	BYTE	cAccumAlphaBits;
	BYTE	cDepthBits;
	BYTE	cStencilBits;
	BYTE	cAuxBuffers;
	BYTE	iLayerPlane;
	BYTE	bReserved;
	COLORREF crTransparent;
} LAYERPLANEDESCRIPTOR,*PLAYERPLANEDESCRIPTOR,*LPLAYERPLANEDESCRIPTOR;
#define LPD_DOUBLEBUFFER	1
#define LPD_STEREO	2
#define LPD_SUPPORT_GDI	16
#define LPD_SUPPORT_OPENGL	32
#define LPD_SHARE_DEPTH	0x40
#define LPD_SHARE_STENCIL	0x80
#define LPD_SHARE_ACCUM	0x100
#define LPD_SWAP_EXCHANGE	0x200
#define LPD_SWAP_COPY	0x400
#define LPD_TRANSPARENT	0x1000
#define LPD_TYPE_RGBA	0
#define LPD_TYPE_COLORINDEX	1
#define WGL_SWAP_MAIN_PLANE	1
#define WGL_SWAP_OVERLAY1	2
#define WGL_SWAP_OVERLAY2	4
#define WGL_SWAP_OVERLAY3	8
#define	WGL_SWAP_OVERLAY4	0x10
#define	WGL_SWAP_OVERLAY5	0x20
#define	WGL_SWAP_OVERLAY6	0x40
#define	WGL_SWAP_OVERLAY7	0x80
#define	WGL_SWAP_OVERLAY8	0x100
#define	WGL_SWAP_OVERLAY9	0x200
#define	WGL_SWAP_OVERLAY10	0x400
#define	WGL_SWAP_OVERLAY11	0x800
#define	WGL_SWAP_OVERLAY12	0x1000
#define	WGL_SWAP_OVERLAY13	0x2000
#define	WGL_SWAP_OVERLAY14	0x4000
#define	WGL_SWAP_OVERLAY15	0x8000
#define	WGL_SWAP_UNDERLAY1	0x10000
#define	WGL_SWAP_UNDERLAY2	0x20000
#define	WGL_SWAP_UNDERLAY3	0x40000
#define	WGL_SWAP_UNDERLAY4	0x80000
#define	WGL_SWAP_UNDERLAY5	0x100000
#define	WGL_SWAP_UNDERLAY6	0x200000
#define	WGL_SWAP_UNDERLAY7	0x400000
#define	WGL_SWAP_UNDERLAY8	0x800000
#define	WGL_SWAP_UNDERLAY9	0x1000000
#define	WGL_SWAP_UNDERLAY10	0x2000000
#define	WGL_SWAP_UNDERLAY11	0x4000000
#define	WGL_SWAP_UNDERLAY12	0x08000000
#define WGL_SWAP_UNDERLAY13 0x10000000
#define WGL_SWAP_UNDERLAY14 0x20000000
#define WGL_SWAP_UNDERLAY15 0x40000000
BOOL WINAPI wglDescribeLayerPlane(HDC,int,int,UINT,LPLAYERPLANEDESCRIPTOR);
int WINAPI wglSetLayerPaletteEntries(HDC,int,int,int,COLORREF *);
int WINAPI wglGetLayerPaletteEntries(HDC,int,int,int,COLORREF *);
BOOL WINAPI wglRealizeLayerPalette(HDC,int, BOOL);
BOOL WINAPI wglSwapLayerBuffers(HDC,UINT);
struct	_TEB	*NtCurrentTeb(void);
LPVOID	WINAPI	CreateFiber(DWORD,LPFIBER_START_ROUTINE,LPVOID);
VOID WINAPI DeleteFiber(LPVOID);
LPVOID WINAPI ConvertThreadToFiber(LPVOID);
VOID WINAPI SwitchToFiber(LPVOID);
BOOL WINAPI SwitchToThread(VOID);
typedef void (* WAITORTIMERCALLBACKFUNC)(PVOID,BOOL);
typedef WAITORTIMERCALLBACKFUNC WAITORTIMERCALLBACK ;
HANDLE WINAPI RegisterWaitForSingleObject(HANDLE,WAITORTIMERCALLBACK,PVOID,ULONG);
HANDLE WINAPI RegisterWaitForSingleObjectEx(HANDLE,WAITORTIMERCALLBACK,PVOID,ULONG,ULONG);
BOOL WINAPI UnregisterWait(HANDLE);
BOOL WINAPI QueueUserWorkItem(LPTHREAD_START_ROUTINE,PVOID,BOOL);
BOOL WINAPI CreateTimerQueueTimer(PHANDLE,HANDLE, WAITORTIMERCALLBACK,PVOID,DWORD,DWORD,ULONG);
BOOL WINAPI BindIoCompletionCallback (HANDLE,LPOVERLAPPED_COMPLETION_ROUTINE,ULONG);
HANDLE WINAPI CreateTimerQueue(VOID);
HANDLE WINAPI SetTimerQueueTimer(HANDLE,WAITORTIMERCALLBACK,PVOID,DWORD,DWORD,BOOL);
BOOL WINAPI ChangeTimerQueueTimer(HANDLE,HANDLE,ULONG,ULONG);
WINBASEAPI BOOL WINAPI CancelTimerQueueTimer(HANDLE,HANDLE);
WINBASEAPI BOOL WINAPI DeleteTimerQueue(HANDLE);
BOOL WINAPI DeleteTimerQueueEx(HANDLE, HANDLE);
#define MakeProcInstance(a,b) (a)
#define FreeProcInstance(a)	(a)
#define AnsiToOem CharToOemA
#define OemToAnsi OemToCharA
#define AnsiToOemBuff CharToOemBuffA
#define OemToAnsiBuff OemToCharBuffA
#define AnsiUpper CharUpperA
#define AnsiUpperBuff CharUpperBuffA
#define AnsiLower CharLowerA
#define AnsiLowerBuff CharLowerBuffA
#define AnsiNext CharNextA
#define AnsiPrev CharPrevA
#define DefineHandleTable(w) ((w),TRUE)
#define LimitEmsPages(dw)
#define SetSwapAreaSize(w) (w)
#define LockSegment(w) GlobalFix((HANDLE)(w))
#define UnlockSegment(w) GlobalUnfix((HANDLE)(w))
#define GetCurrentTime() GetTickCount()
#define Yield()
#define ZeroMemory RtlZeroMemory
#define RtlFillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
#define MAKE_HRESULT(s,f,c) ((HRESULT)(((DWORD)(s)<<31)|((DWORD)(f)<<16)|((DWORD)(c))))

//#ifdef RC_INVOKED
//#define _HRESULT_TYPEDEF_(_sc) _sc
//#else
//#define _HRESULT_TYPEDEF_(_sc) ((HRESULT)_sc)
//#endif

#define E_FAIL	_HRESULT_TYPEDEF_(0x80004005)
#define E_UNEXPECTED	_HRESULT_TYPEDEF_(0x8000FFFF)
#define E_NOTIMPL	_HRESULT_TYPEDEF_(0x80004001)
#define E_OUTOFMEMORY	_HRESULT_TYPEDEF_(0x8007000E)
#define E_INVALIDARG	_HRESULT_TYPEDEF_(0x80070057)
#define E_NOINTERFACE	_HRESULT_TYPEDEF_(0x80004002)
#define E_POINTER	_HRESULT_TYPEDEF_(0x80004003)
#define E_HANDLE	_HRESULT_TYPEDEF_(0x80070006)
#define E_ABORT		_HRESULT_TYPEDEF_(0x80004004)
#define E_ACCESSDENIED	_HRESULT_TYPEDEF_(0x80070005)
#define CO_E_INIT_TLS	_HRESULT_TYPEDEF_(0x80004006)
#define CO_E_INIT_SHARED_ALLOCATOR	_HRESULT_TYPEDEF_(0x80004007)
#define CO_E_INIT_MEMORY_ALLOCATOR	_HRESULT_TYPEDEF_(0x80004008)
#define CO_E_INIT_CLASS_CACHE	_HRESULT_TYPEDEF_(0x80004009)
#define CO_E_INIT_RPC_CHANNEL	_HRESULT_TYPEDEF_(0x8000400A)
#define CO_E_INIT_TLS_SET_CHANNEL_CONTROL	_HRESULT_TYPEDEF_(0x8000400B)
#define CO_E_INIT_TLS_CHANNEL_CONTROL	_HRESULT_TYPEDEF_(0x8000400C)
#define CO_E_INIT_UNACCEPTED_USER_ALLOCATOR _HRESULT_TYPEDEF_(0x8000400D)
#define CO_E_INIT_SCM_MUTEX_EXISTS	_HRESULT_TYPEDEF_(0x8000400E)
#define CO_E_INIT_SCM_FILE_MAPPING_EXISTS _HRESULT_TYPEDEF_(0x8000400F)
#define CO_E_INIT_SCM_MAP_VIEW_OF_FILE	_HRESULT_TYPEDEF_(0x80004010)
#define CO_E_INIT_SCM_EXEC_FAILURE	_HRESULT_TYPEDEF_(0x80004011)
#define CO_E_INIT_ONLY_SINGLE_THREADED	_HRESULT_TYPEDEF_(0x80004012)
#define CO_E_CANT_REMOTE	_HRESULT_TYPEDEF_(0x80004013)
#define CO_E_BAD_SERVER_NAME	_HRESULT_TYPEDEF_(0x80004014)
#define CO_E_WRONG_SERVER_IDENTITY	_HRESULT_TYPEDEF_(0x80004015)
#define CO_E_OLE1DDE_DISABLED	_HRESULT_TYPEDEF_(0x80004016)
#define CO_E_RUNAS_SYNTAX	_HRESULT_TYPEDEF_(0x80004017)
#define CO_E_CREATEPROCESS_FAILURE	_HRESULT_TYPEDEF_(0x80004018)
#define CO_E_RUNAS_CREATEPROCESS_FAILURE _HRESULT_TYPEDEF_(0x80004019)
#define CO_E_RUNAS_LOGON_FAILURE	_HRESULT_TYPEDEF_(0x8000401A)
#define CO_E_LAUNCH_PERMSSION_DENIED	_HRESULT_TYPEDEF_(0x8000401B)
#define CO_E_START_SERVICE_FAILURE	_HRESULT_TYPEDEF_(0x8000401C)
#define CO_E_REMOTE_COMMUNICATION_FAILURE _HRESULT_TYPEDEF_(0x8000401D)
#define CO_E_SERVER_START_TIMEOUT	_HRESULT_TYPEDEF_(0x8000401E)
#define CO_E_CLSREG_INCONSISTENT	_HRESULT_TYPEDEF_(0x8000401F)
#define CO_E_IIDREG_INCONSISTENT	_HRESULT_TYPEDEF_(0x80004020)
#define CO_E_NOT_SUPPORTED	_HRESULT_TYPEDEF_(0x80004021)
#define CO_E_RELOAD_DLL	_HRESULT_TYPEDEF_(0x80004022)
#define CO_E_MSI_ERROR	_HRESULT_TYPEDEF_(0x80004023)
#define	CLASS_E_NOAGGREGATION	_HRESULT_TYPEDEF_(0x80040110)
#define CLASS_E_CLASSNOTAVAILABLE	_HRESULT_TYPEDEF_(0x80040111)
/* Errors.h WIN32 error codes Numerical order */
#define NO_ERROR 0
#define ERROR_SUCCESS 0
#define ERROR_INVALID_FUNCTION 1
#define ERROR_FILE_NOT_FOUND 2
#define ERROR_PATH_NOT_FOUND 3
#define ERROR_TOO_MANY_OPEN_FILES 4
#define ERROR_ACCESS_DENIED 5
#define ERROR_INVALID_HANDLE 6
#define ERROR_ARENA_TRASHED 7
#define ERROR_NOT_ENOUGH_MEMORY 8
#define ERROR_INVALID_BLOCK 9
#define ERROR_BAD_ENVIRONMENT 10
#define ERROR_BAD_FORMAT 11
#define ERROR_INVALID_ACCESS 12
#define ERROR_INVALID_DATA 13
#define ERROR_OUTOFMEMORY 14
#define ERROR_INVALID_DRIVE 15
#define ERROR_CURRENT_DIRECTORY 16
#define ERROR_NOT_SAME_DEVICE 17
#define ERROR_NO_MORE_FILES 18
#define ERROR_WRITE_PROTECT 19
#define ERROR_BAD_UNIT 20
#define ERROR_NOT_READY 21
#define ERROR_BAD_COMMAND 22
#define ERROR_CRC 23
#define ERROR_BAD_LENGTH 24
#define ERROR_SEEK 25
#define ERROR_NOT_DOS_DISK 26
#define ERROR_SECTOR_NOT_FOUND 27
#define ERROR_OUT_OF_PAPER 28
#define ERROR_WRITE_FAULT 29
#define ERROR_READ_FAULT 30
#define ERROR_GEN_FAILURE 31
#define ERROR_SHARING_VIOLATION 32
#define ERROR_LOCK_VIOLATION 33
#define ERROR_WRONG_DISK 34
#define ERROR_SHARING_BUFFER_EXCEEDED 36
#define ERROR_HANDLE_EOF 38
#define ERROR_HANDLE_DISK_FULL 39
#define ERROR_NOT_SUPPORTED 50
#define ERROR_REM_NOT_LIST 51
#define ERROR_DUP_NAME 52
#define ERROR_BAD_NETPATH 53
#define ERROR_NETWORK_BUSY 54
#define ERROR_DEV_NOT_EXIST 55
#define ERROR_TOO_MANY_CMDS 56
#define ERROR_ADAP_HDW_ERR 57
#define ERROR_BAD_NET_RESP 58
#define ERROR_UNEXP_NET_ERR 59
#define ERROR_BAD_REM_ADAP 60
#define ERROR_PRINTQ_FULL 61
#define ERROR_NO_SPOOL_SPACE 62
#define ERROR_PRINT_CANCELLED 63
#define ERROR_NETNAME_DELETED 64
#define ERROR_NETWORK_ACCESS_DENIED 65
#define ERROR_BAD_DEV_TYPE 66
#define ERROR_BAD_NET_NAME 67
#define ERROR_TOO_MANY_NAMES 68
#define ERROR_TOO_MANY_SESS 69
#define ERROR_SHARING_PAUSED 70
#define ERROR_REQ_NOT_ACCEP 71
#define ERROR_REDIR_PAUSED 72
#define ERROR_FILE_EXISTS 80
#define ERROR_CANNOT_MAKE 82
#define ERROR_FAIL_I24 83
#define ERROR_OUT_OF_STRUCTURES 84
#define ERROR_ALREADY_ASSIGNED 85
#define ERROR_INVALID_PASSWORD 86
#define ERROR_INVALID_PARAMETER 87
#define ERROR_NET_WRITE_FAULT 88
#define ERROR_NO_PROC_SLOTS 89
#define ERROR_TOO_MANY_SEMAPHORES 100
#define ERROR_EXCL_SEM_ALREADY_OWNED 101
#define ERROR_SEM_IS_SET 102
#define ERROR_TOO_MANY_SEM_REQUESTS 103
#define ERROR_INVALID_AT_INTERRUPT_TIME 104
#define ERROR_SEM_OWNER_DIED 105
#define ERROR_SEM_USER_LIMIT 106
#define ERROR_DISK_CHANGE 107
#define ERROR_DRIVE_LOCKED 108
#define ERROR_BROKEN_PIPE 109
#define ERROR_OPEN_FAILED 110
#define ERROR_BUFFER_OVERFLOW 111
#define ERROR_DISK_FULL 112
#define ERROR_NO_MORE_SEARCH_HANDLES 113
#define ERROR_INVALID_TARGET_HANDLE 114
#define ERROR_INVALID_CATEGORY 117
#define ERROR_INVALID_VERIFY_SWITCH 118
#define ERROR_BAD_DRIVER_LEVEL 119
#define ERROR_CALL_NOT_IMPLEMENTED 120
#define ERROR_SEM_TIMEOUT 121
#define ERROR_INSUFFICIENT_BUFFER 122
#define ERROR_INVALID_NAME 123
#define ERROR_INVALID_LEVEL 124
#define ERROR_NO_VOLUME_LABEL 125
#define ERROR_MOD_NOT_FOUND 126
#define ERROR_PROC_NOT_FOUND 127
#define ERROR_WAIT_NO_CHILDREN 128
#define ERROR_CHILD_NOT_COMPLETE 129
#define ERROR_DIRECT_ACCESS_HANDLE 130
#define ERROR_NEGATIVE_SEEK 131
#define ERROR_SEEK_ON_DEVICE 132
#define ERROR_IS_JOIN_TARGET 133
#define ERROR_IS_JOINED 134
#define ERROR_IS_SUBSTED 135
#define ERROR_NOT_JOINED 136
#define ERROR_NOT_SUBSTED 137
#define ERROR_JOIN_TO_JOIN 138
#define ERROR_SUBST_TO_SUBST 139
#define ERROR_JOIN_TO_SUBST 140
#define ERROR_SUBST_TO_JOIN 141
#define ERROR_BUSY_DRIVE 142
#define ERROR_SAME_DRIVE 143
#define ERROR_DIR_NOT_ROOT 144
#define ERROR_DIR_NOT_EMPTY 145
#define ERROR_IS_SUBST_PATH 146
#define ERROR_IS_JOIN_PATH 147
#define ERROR_PATH_BUSY 148
#define ERROR_IS_SUBST_TARGET 149
#define ERROR_SYSTEM_TRACE 150
#define ERROR_INVALID_EVENT_COUNT 151
#define ERROR_TOO_MANY_MUXWAITERS 152
#define ERROR_INVALID_LIST_FORMAT 153
#define ERROR_LABEL_TOO_LONG 154
#define ERROR_TOO_MANY_TCBS 155
#define ERROR_SIGNAL_REFUSED 156
#define ERROR_DISCARDED 157
#define ERROR_NOT_LOCKED 158
#define ERROR_BAD_THREADID_ADDR 159
#define ERROR_BAD_ARGUMENTS 160
#define ERROR_BAD_PATHNAME 161
#define ERROR_SIGNAL_PENDING 162
#define ERROR_MAX_THRDS_REACHED 164
#define ERROR_LOCK_FAILED 167
#define ERROR_BUSY 170
#define ERROR_CANCEL_VIOLATION 173
#define ERROR_ATOMIC_LOCKS_NOT_SUPPORTED 174
#define ERROR_INVALID_SEGMENT_NUMBER 180
#define ERROR_INVALID_ORDINAL 182
#define ERROR_ALREADY_EXISTS 183
#define ERROR_INVALID_FLAG_NUMBER 186
#define ERROR_SEM_NOT_FOUND 187
#define ERROR_INVALID_STARTING_CODESEG 188
#define ERROR_INVALID_STACKSEG 189
#define ERROR_INVALID_MODULETYPE 190
#define ERROR_INVALID_EXE_SIGNATURE 191
#define ERROR_EXE_MARKED_INVALID 192
#define ERROR_EXE_MACHINE_TYPE_MISMATCH 216
#define ERROR_BAD_EXE_FORMAT 193
#define ERROR_ITERATED_DATA_EXCEEDS_64k 194
#define ERROR_INVALID_MINALLOCSIZE 195
#define ERROR_DYNLINK_FROM_INVALID_RING 196
#define ERROR_IOPL_NOT_ENABLED 197
#define ERROR_INVALID_SEGDPL 198
#define ERROR_AUTODATASEG_EXCEEDS_64k 199
#define ERROR_RING2SEG_MUST_BE_MOVABLE 200
#define ERROR_RELOC_CHAIN_XEEDS_SEGLIM 201
#define ERROR_INFLOOP_IN_RELOC_CHAIN 202
#define ERROR_ENVVAR_NOT_FOUND 203
#define ERROR_NO_SIGNAL_SENT 205
#define ERROR_FILENAME_EXCED_RANGE 206
#define ERROR_RING2_STACK_IN_USE 207
#define ERROR_META_EXPANSION_TOO_LONG 208
#define ERROR_INVALID_SIGNAL_NUMBER 209
#define ERROR_THREAD_1_INACTIVE 210
#define ERROR_LOCKED 212
#define ERROR_TOO_MANY_MODULES 214
#define ERROR_NESTING_NOT_ALLOWED 215
#define ERROR_BAD_PIPE 230
#define ERROR_PIPE_BUSY 231
#define ERROR_NO_DATA 232
#define ERROR_PIPE_NOT_CONNECTED 233
#define ERROR_MORE_DATA 234
#define ERROR_VC_DISCONNECTED 240
#define ERROR_INVALID_EA_NAME 254
#define ERROR_EA_LIST_INCONSISTENT 255
#define ERROR_NO_MORE_ITEMS 259
#define ERROR_CANNOT_COPY 266
#define ERROR_DIRECTORY 267
#define ERROR_EAS_DIDNT_FIT 275
#define ERROR_EA_FILE_CORRUPT 276
#define ERROR_EA_TABLE_FULL 277
#define ERROR_INVALID_EA_HANDLE 278
#define ERROR_EAS_NOT_SUPPORTED 282
#define ERROR_NOT_OWNER 288
#define ERROR_TOO_MANY_POSTS 298
#define ERROR_PARTIAL_COPY 299
#define ERROR_MR_MID_NOT_FOUND 317
#define ERROR_INVALID_ADDRESS 487
#define ERROR_ARITHMETIC_OVERFLOW 534
#define ERROR_PIPE_CONNECTED 535
#define ERROR_PIPE_LISTENING 536
#define ERROR_EA_ACCESS_DENIED 994
#define ERROR_OPERATION_ABORTED 995
#define ERROR_IO_INCOMPLETE 996
#define ERROR_IO_PENDING 997
#define ERROR_NOACCESS 998
#define ERROR_SWAPERROR 999
#define ERROR_STACK_OVERFLOW 1001
#define ERROR_INVALID_MESSAGE 1002
#define ERROR_CAN_NOT_COMPLETE 1003
#define ERROR_INVALID_FLAGS 1004
#define ERROR_UNRECOGNIZED_VOLUME 1005
#define ERROR_FILE_INVALID 1006
#define ERROR_FULLSCREEN_MODE 1007
#define ERROR_NO_TOKEN 1008
#define ERROR_BADDB 1009
#define ERROR_BADKEY 1010
#define ERROR_CANTOPEN 1011
#define ERROR_CANTREAD 1012
#define ERROR_CANTWRITE 1013
#define ERROR_REGISTRY_RECOVERED 1014
#define ERROR_REGISTRY_CORRUPT 1015
#define ERROR_REGISTRY_IO_FAILED 1016
#define ERROR_NOT_REGISTRY_FILE 1017
#define ERROR_KEY_DELETED 1018
#define ERROR_NO_LOG_SPACE 1019
#define ERROR_KEY_HAS_CHILDREN 1020
#define ERROR_CHILD_MUST_BE_VOLATILE 1021
#define ERROR_NOTIFY_ENUM_DIR 1022
#define ERROR_DEPENDENT_SERVICES_RUNNING 1051
#define ERROR_INVALID_SERVICE_CONTROL 1052
#define ERROR_SERVICE_REQUEST_TIMEOUT 1053
#define ERROR_SERVICE_NO_THREAD 1054
#define ERROR_SERVICE_DATABASE_LOCKED 1055
#define ERROR_SERVICE_ALREADY_RUNNING 1056
#define ERROR_INVALID_SERVICE_ACCOUNT 1057
#define ERROR_SERVICE_DISABLED 1058
#define ERROR_CIRCULAR_DEPENDENCY 1059
#define ERROR_SERVICE_DOES_NOT_EXIST 1060
#define ERROR_SERVICE_CANNOT_ACCEPT_CTRL 1061
#define ERROR_SERVICE_NOT_ACTIVE 1062
#define ERROR_FAILED_SERVICE_CONTROLLER_CONNECT 1063
#define ERROR_EXCEPTION_IN_SERVICE 1064
#define ERROR_DATABASE_DOES_NOT_EXIST 1065
#define ERROR_SERVICE_SPECIFIC_ERROR 1066
#define ERROR_PROCESS_ABORTED 1067
#define ERROR_SERVICE_DEPENDENCY_FAIL 1068
#define ERROR_SERVICE_LOGON_FAILED 1069
#define ERROR_SERVICE_START_HANG 1070
#define ERROR_INVALID_SERVICE_LOCK 1071
#define ERROR_SERVICE_MARKED_FOR_DELETE 1072
#define ERROR_SERVICE_EXISTS 1073
#define ERROR_ALREADY_RUNNING_LKG 1074
#define ERROR_SERVICE_DEPENDENCY_DELETED 1075
#define ERROR_BOOT_ALREADY_ACCEPTED 1076
#define ERROR_SERVICE_NEVER_STARTED 1077
#define ERROR_DUPLICATE_SERVICE_NAME 1078
#define ERROR_DIFFERENT_SERVICE_ACCOUNT 1079
#define ERROR_END_OF_MEDIA 1100
#define ERROR_FILEMARK_DETECTED 1101
#define ERROR_BEGINNING_OF_MEDIA 1102
#define ERROR_SETMARK_DETECTED 1103
#define ERROR_NO_DATA_DETECTED 1104
#define ERROR_PARTITION_FAILURE 1105
#define ERROR_INVALID_BLOCK_LENGTH 1106

#define ERROR_DEVICE_NOT_PARTITIONED 1107
#define ERROR_UNABLE_TO_LOCK_MEDIA 1108
#define ERROR_UNABLE_TO_UNLOAD_MEDIA 1109
#define ERROR_MEDIA_CHANGED 1110
#define ERROR_BUS_RESET 1111
#define ERROR_NO_MEDIA_IN_DRIVE 1112
#define ERROR_NO_UNICODE_TRANSLATION 1113
#define ERROR_DLL_INIT_FAILED 1114
#define ERROR_SHUTDOWN_IN_PROGRESS 1115
#define ERROR_NO_SHUTDOWN_IN_PROGRESS 1116
#define ERROR_IO_DEVICE 1117
#define ERROR_SERIAL_NO_DEVICE 1118
#define ERROR_IRQ_BUSY 1119
#define ERROR_MORE_WRITES 1120
#define ERROR_COUNTER_TIMEOUT 1121
#define ERROR_FLOPPY_ID_MARK_NOT_FOUND 1122
#define ERROR_FLOPPY_WRONG_CYLINDER 1123
#define ERROR_FLOPPY_UNKNOWN_ERROR 1124
#define ERROR_FLOPPY_BAD_REGISTERS 1125
#define ERROR_DISK_RECALIBRATE_FAILED 1126
#define ERROR_DISK_OPERATION_FAILED 1127
#define ERROR_DISK_RESET_FAILED 1128
#define ERROR_EOM_OVERFLOW 1129
#define ERROR_NOT_ENOUGH_SERVER_MEMORY 1130
#define ERROR_POSSIBLE_DEADLOCK 1131
#define ERROR_MAPPED_ALIGNMENT 1132
#define ERROR_SET_POWER_STATE_VETOED 1140
#define ERROR_SET_POWER_STATE_FAILED 1141
#define ERROR_TOO_MANY_LINKS 1142
#define ERROR_OLD_WIN_VERSION 1150
#define ERROR_APP_WRONG_OS 1151
#define ERROR_SINGLE_INSTANCE_APP 1152
#define ERROR_RMODE_APP 1153
#define ERROR_INVALID_DLL 1154
#define ERROR_NO_ASSOCIATION 1155
#define ERROR_DDE_FAIL 1156
#define ERROR_DLL_NOT_FOUND 1157
#define ERROR_BAD_USERNAME 2202
#define ERROR_NOT_CONNECTED 2250
#define ERROR_OPEN_FILES 2401
#define ERROR_ACTIVE_CONNECTIONS 2402
#define ERROR_DEVICE_IN_USE 2404
#define ERROR_BAD_DEVICE 1200
#define ERROR_CONNECTION_UNAVAIL 1201
#define ERROR_DEVICE_ALREADY_REMEMBERED 1202
#define ERROR_NO_NET_OR_BAD_PATH 1203
#define ERROR_BAD_PROVIDER 1204
#define ERROR_CANNOT_OPEN_PROFILE 1205
#define ERROR_BAD_PROFILE 1206
#define ERROR_NOT_CONTAINER 1207
#define ERROR_EXTENDED_ERROR 1208
#define ERROR_INVALID_GROUPNAME 1209
#define ERROR_INVALID_COMPUTERNAME 1210
#define ERROR_INVALID_EVENTNAME 1211
#define ERROR_INVALID_DOMAINNAME 1212
#define ERROR_INVALID_SERVICENAME 1213
#define ERROR_INVALID_NETNAME 1214
#define ERROR_INVALID_SHARENAME 1215
#define ERROR_INVALID_PASSWORDNAME 1216
#define ERROR_INVALID_MESSAGENAME 1217
#define ERROR_INVALID_MESSAGEDEST 1218
#define ERROR_SESSION_CREDENTIAL_CONFLICT 1219
#define ERROR_REMOTE_SESSION_LIMIT_EXCEEDED 1220
#define ERROR_DUP_DOMAINNAME 1221
#define ERROR_NO_NETWORK 1222
#define ERROR_CANCELLED 1223
#define ERROR_USER_MAPPED_FILE 1224
#define ERROR_CONNECTION_REFUSED 1225
#define ERROR_GRACEFUL_DISCONNECT 1226
#define ERROR_ADDRESS_ALREADY_ASSOCIATED 1227
#define ERROR_ADDRESS_NOT_ASSOCIATED 1228
#define ERROR_CONNECTION_INVALID 1229
#define ERROR_CONNECTION_ACTIVE 1230
#define ERROR_NETWORK_UNREACHABLE 1231
#define ERROR_HOST_UNREACHABLE 1232
#define ERROR_PROTOCOL_UNREACHABLE 1233
#define ERROR_PORT_UNREACHABLE 1234
#define ERROR_REQUEST_ABORTED 1235
#define ERROR_CONNECTION_ABORTED 1236
#define ERROR_RETRY 1237
#define ERROR_CONNECTION_COUNT_LIMIT 1238
#define ERROR_LOGIN_TIME_RESTRICTION 1239
#define ERROR_LOGIN_WKSTA_RESTRICTION 1240
#define ERROR_INCORRECT_ADDRESS 1241
#define ERROR_ALREADY_REGISTERED 1242
#define ERROR_SERVICE_NOT_FOUND 1243
#define ERROR_NOT_AUTHENTICATED 1244
#define ERROR_NOT_LOGGED_ON 1245
#define ERROR_CONTINUE 1246
#define ERROR_ALREADY_INITIALIZED 1247
#define ERROR_NO_MORE_DEVICES 1248
#define ERROR_NOT_ALL_ASSIGNED 1300
#define ERROR_SOME_NOT_MAPPED 1301
#define ERROR_NO_QUOTAS_FOR_ACCOUNT 1302
#define ERROR_LOCAL_USER_SESSION_KEY 1303
#define ERROR_NULL_LM_PASSWORD 1304
#define ERROR_UNKNOWN_REVISION 1305
#define ERROR_REVISION_MISMATCH 1306
#define ERROR_INVALID_OWNER 1307
#define ERROR_INVALID_PRIMARY_GROUP 1308
#define ERROR_NO_IMPERSONATION_TOKEN 1309
#define ERROR_CANT_DISABLE_MANDATORY 1310
#define ERROR_NO_LOGON_SERVERS 1311
#define ERROR_NO_SUCH_LOGON_SESSION 1312
#define ERROR_NO_SUCH_PRIVILEGE 1313
#define ERROR_PRIVILEGE_NOT_HELD 1314
#define ERROR_INVALID_ACCOUNT_NAME 1315
#define ERROR_USER_EXISTS 1316
#define ERROR_NO_SUCH_USER 1317
#define ERROR_GROUP_EXISTS 1318
#define ERROR_NO_SUCH_GROUP 1319
#define ERROR_MEMBER_IN_GROUP 1320
#define ERROR_MEMBER_NOT_IN_GROUP 1321
#define ERROR_LAST_ADMIN 1322
#define ERROR_WRONG_PASSWORD 1323
#define ERROR_ILL_FORMED_PASSWORD 1324
#define ERROR_PASSWORD_RESTRICTION 1325
#define ERROR_LOGON_FAILURE 1326
#define ERROR_ACCOUNT_RESTRICTION 1327
#define ERROR_INVALID_LOGON_HOURS 1328
#define ERROR_INVALID_WORKSTATION 1329
#define ERROR_PASSWORD_EXPIRED 1330
#define ERROR_ACCOUNT_DISABLED 1331
#define ERROR_NONE_MAPPED 1332
#define ERROR_TOO_MANY_LUIDS_REQUESTED 1333
#define ERROR_LUIDS_EXHAUSTED 1334
#define ERROR_INVALID_SUB_AUTHORITY 1335
#define ERROR_INVALID_ACL 1336
#define ERROR_INVALID_SID 1337
#define ERROR_INVALID_SECURITY_DESCR 1338
#define ERROR_BAD_INHERITANCE_ACL 1340
#define ERROR_SERVER_DISABLED 1341
#define ERROR_SERVER_NOT_DISABLED 1342
#define ERROR_INVALID_ID_AUTHORITY 1343
#define ERROR_ALLOTTED_SPACE_EXCEEDED 1344
#define ERROR_INVALID_GROUP_ATTRIBUTES 1345
#define ERROR_BAD_IMPERSONATION_LEVEL 1346
#define ERROR_CANT_OPEN_ANONYMOUS 1347
#define ERROR_BAD_VALIDATION_CLASS 1348
#define ERROR_BAD_TOKEN_TYPE 1349
#define ERROR_NO_SECURITY_ON_OBJECT 1350
#define ERROR_CANT_ACCESS_DOMAIN_INFO 1351
#define ERROR_INVALID_SERVER_STATE 1352
#define ERROR_INVALID_DOMAIN_STATE 1353
#define ERROR_INVALID_DOMAIN_ROLE 1354
#define ERROR_NO_SUCH_DOMAIN 1355
#define ERROR_DOMAIN_EXISTS 1356
#define ERROR_DOMAIN_LIMIT_EXCEEDED 1357
#define ERROR_INTERNAL_DB_CORRUPTION 1358
#define ERROR_INTERNAL_ERROR 1359
#define ERROR_GENERIC_NOT_MAPPED 1360
#define ERROR_BAD_DESCRIPTOR_FORMAT 1361
#define ERROR_NOT_LOGON_PROCESS 1362
#define ERROR_LOGON_SESSION_EXISTS 1363
#define ERROR_NO_SUCH_PACKAGE 1364
#define ERROR_BAD_LOGON_SESSION_STATE 1365
#define ERROR_LOGON_SESSION_COLLISION 1366
#define ERROR_INVALID_LOGON_TYPE 1367
#define ERROR_CANNOT_IMPERSONATE 1368
#define ERROR_RXACT_INVALID_STATE 1369
#define ERROR_RXACT_COMMIT_FAILURE 1370
#define ERROR_SPECIAL_ACCOUNT 1371
#define ERROR_SPECIAL_GROUP 1372
#define ERROR_SPECIAL_USER 1373
#define ERROR_MEMBERS_PRIMARY_GROUP 1374
#define ERROR_TOKEN_ALREADY_IN_USE 1375
#define ERROR_NO_SUCH_ALIAS 1376
#define ERROR_MEMBER_NOT_IN_ALIAS 1377
#define ERROR_MEMBER_IN_ALIAS 1378
#define ERROR_ALIAS_EXISTS 1379
#define ERROR_LOGON_NOT_GRANTED 1380
#define ERROR_TOO_MANY_SECRETS 1381
#define ERROR_SECRET_TOO_LONG 1382
#define ERROR_INTERNAL_DB_ERROR 1383
#define ERROR_TOO_MANY_CONTEXT_IDS 1384
#define ERROR_LOGON_TYPE_NOT_GRANTED 1385
#define ERROR_NT_CROSS_ENCRYPTION_REQUIRED 1386
#define ERROR_NO_SUCH_MEMBER 1387
#define ERROR_INVALID_MEMBER 1388
#define ERROR_TOO_MANY_SIDS 1389
#define ERROR_LM_CROSS_ENCRYPTION_REQUIRED 1390
#define ERROR_NO_INHERITANCE 1391
#define ERROR_FILE_CORRUPT 1392
#define ERROR_DISK_CORRUPT 1393
#define ERROR_NO_USER_SESSION_KEY 1394
#define ERROR_LICENSE_QUOTA_EXCEEDED 1395
#define ERROR_INVALID_WINDOW_HANDLE 1400
#define ERROR_INVALID_MENU_HANDLE 1401
#define ERROR_INVALID_CURSOR_HANDLE 1402
#define ERROR_INVALID_ACCEL_HANDLE 1403
#define ERROR_INVALID_HOOK_HANDLE 1404
#define ERROR_INVALID_DWP_HANDLE 1405
#define ERROR_TLW_WITH_WSCHILD 1406
#define ERROR_CANNOT_FIND_WND_CLASS 1407
#define ERROR_WINDOW_OF_OTHER_THREAD 1408
#define ERROR_HOTKEY_ALREADY_REGISTERED 1409
#define ERROR_CLASS_ALREADY_EXISTS 1410
#define ERROR_CLASS_DOES_NOT_EXIST 1411
#define ERROR_CLASS_HAS_WINDOWS 1412
#define ERROR_INVALID_INDEX 1413
#define ERROR_INVALID_ICON_HANDLE 1414
#define ERROR_PRIVATE_DIALOG_INDEX 1415
#define ERROR_LISTBOX_ID_NOT_FOUND 1416
#define ERROR_NO_WILDCARD_CHARACTERS 1417
#define ERROR_CLIPBOARD_NOT_OPEN 1418
#define ERROR_HOTKEY_NOT_REGISTERED 1419
#define ERROR_WINDOW_NOT_DIALOG 1420
#define ERROR_CONTROL_ID_NOT_FOUND 1421
#define ERROR_INVALID_COMBOBOX_MESSAGE 1422
#define ERROR_WINDOW_NOT_COMBOBOX 1423
#define ERROR_INVALID_EDIT_HEIGHT 1424
#define ERROR_DC_NOT_FOUND 1425
#define ERROR_INVALID_HOOK_FILTER 1426
#define ERROR_INVALID_FILTER_PROC 1427
#define ERROR_HOOK_NEEDS_HMOD 1428
#define ERROR_GLOBAL_ONLY_HOOK 1429
#define ERROR_JOURNAL_HOOK_SET 1430
#define ERROR_HOOK_NOT_INSTALLED 1431
#define ERROR_INVALID_LB_MESSAGE 1432
#define ERROR_SETCOUNT_ON_BAD_LB 1433
#define ERROR_LB_WITHOUT_TABSTOPS 1434
#define ERROR_DESTROY_OBJECT_OF_OTHER_THREAD 1435
#define ERROR_CHILD_WINDOW_MENU 1436
#define ERROR_NO_SYSTEM_MENU 1437
#define ERROR_INVALID_MSGBOX_STYLE 1438
#define ERROR_INVALID_SPI_VALUE 1439
#define ERROR_SCREEN_ALREADY_LOCKED 1440
#define ERROR_HWNDS_HAVE_DIFF_PARENT 1441
#define ERROR_NOT_CHILD_WINDOW 1442
#define ERROR_INVALID_GW_COMMAND 1443
#define ERROR_INVALID_THREAD_ID 1444
#define ERROR_NON_MDICHILD_WINDOW 1445
#define ERROR_POPUP_ALREADY_ACTIVE 1446
#define ERROR_NO_SCROLLBARS 1447
#define ERROR_INVALID_SCROLLBAR_RANGE 1448
#define ERROR_INVALID_SHOWWIN_COMMAND 1449
#define ERROR_NO_SYSTEM_RESOURCES 1450
#define ERROR_NONPAGED_SYSTEM_RESOURCES 1451
#define ERROR_PAGED_SYSTEM_RESOURCES 1452
#define ERROR_WORKING_SET_QUOTA 1453
#define ERROR_PAGEFILE_QUOTA 1454
#define ERROR_COMMITMENT_LIMIT 1455
#define ERROR_MENU_ITEM_NOT_FOUND 1456
#define ERROR_INVALID_KEYBOARD_HANDLE 1457
#define ERROR_HOOK_TYPE_NOT_ALLOWED 1458
#define ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION 1459
#define ERROR_EVENTLOG_FILE_CORRUPT 1500
#define ERROR_EVENTLOG_CANT_START 1501
#define ERROR_LOG_FILE_FULL 1502
#define ERROR_EVENTLOG_FILE_CHANGED 1503
#define RPC_S_INVALID_STRING_BINDING 1700
#define RPC_S_WRONG_KIND_OF_BINDING 1701
#define RPC_S_INVALID_BINDING 1702
#define RPC_S_PROTSEQ_NOT_SUPPORTED 1703
#define RPC_S_INVALID_RPC_PROTSEQ 1704
#define RPC_S_INVALID_STRING_UUID 1705
#define RPC_S_INVALID_ENDPOINT_FORMAT 1706
#define RPC_S_INVALID_NET_ADDR 1707
#define RPC_S_NO_ENDPOINT_FOUND 1708
#define RPC_S_INVALID_TIMEOUT 1709
#define RPC_S_OBJECT_NOT_FOUND 1710
#define RPC_S_ALREADY_REGISTERED 1711
#define RPC_S_TYPE_ALREADY_REGISTERED 1712
#define RPC_S_ALREADY_LISTENING 1713
#define RPC_S_NO_PROTSEQS_REGISTERED 1714
#define RPC_S_NOT_LISTENING 1715
#define RPC_S_UNKNOWN_MGR_TYPE 1716
#define RPC_S_UNKNOWN_IF 1717
#define RPC_S_NO_BINDINGS 1718
#define RPC_S_NO_PROTSEQS 1719
#define RPC_S_CANT_CREATE_ENDPOINT 1720
#define RPC_S_OUT_OF_RESOURCES 1721
#define RPC_S_SERVER_UNAVAILABLE 1722
#define RPC_S_SERVER_TOO_BUSY 1723
#define RPC_S_INVALID_NETWORK_OPTIONS 1724
#define RPC_S_NO_CALL_ACTIVE 1725
#define RPC_S_CALL_FAILED 1726
#define RPC_S_CALL_FAILED_DNE 1727
#define RPC_S_PROTOCOL_ERROR 1728
#define RPC_S_UNSUPPORTED_TRANS_SYN 1730
#define RPC_S_UNSUPPORTED_TYPE 1732
#define RPC_S_INVALID_TAG 1733
#define RPC_S_INVALID_BOUND 1734
#define RPC_S_NO_ENTRY_NAME 1735
#define RPC_S_INVALID_NAME_SYNTAX 1736
#define RPC_S_UNSUPPORTED_NAME_SYNTAX 1737
#define RPC_S_UUID_NO_ADDRESS 1739
#define RPC_S_DUPLICATE_ENDPOINT 1740
#define RPC_S_UNKNOWN_AUTHN_TYPE 1741
#define RPC_S_MAX_CALLS_TOO_SMALL 1742
#define RPC_S_STRING_TOO_LONG 1743
#define RPC_S_PROTSEQ_NOT_FOUND 1744
#define RPC_S_PROCNUM_OUT_OF_RANGE 1745
#define RPC_S_BINDING_HAS_NO_AUTH 1746
#define RPC_S_UNKNOWN_AUTHN_SERVICE 1747
#define RPC_S_UNKNOWN_AUTHN_LEVEL 1748
#define RPC_S_INVALID_AUTH_IDENTITY 1749
#define RPC_S_UNKNOWN_AUTHZ_SERVICE 1750
#define EPT_S_INVALID_ENTRY 1751
#define EPT_S_CANT_PERFORM_OP 1752
#define EPT_S_NOT_REGISTERED 1753
#define RPC_S_NOTHING_TO_EXPORT 1754
#define RPC_S_INCOMPLETE_NAME 1755
#define RPC_S_INVALID_VERS_OPTION 1756
#define RPC_S_NO_MORE_MEMBERS 1757
#define RPC_S_NOT_ALL_OBJS_UNEXPORTED 1758
#define RPC_S_INTERFACE_NOT_FOUND 1759
#define RPC_S_ENTRY_ALREADY_EXISTS 1760
#define RPC_S_ENTRY_NOT_FOUND 1761
#define RPC_S_NAME_SERVICE_UNAVAILABLE 1762
#define RPC_S_INVALID_NAF_ID 1763
#define RPC_S_CANNOT_SUPPORT 1764
#define RPC_S_NO_CONTEXT_AVAILABLE 1765
#define RPC_S_INTERNAL_ERROR 1766
#define RPC_S_ZERO_DIVIDE 1767
#define RPC_S_ADDRESS_ERROR 1768
#define RPC_S_FP_DIV_ZERO 1769
#define RPC_S_FP_UNDERFLOW 1770
#define RPC_S_FP_OVERFLOW 1771
#define RPC_X_NO_MORE_ENTRIES 1772
#define RPC_X_SS_CHAR_TRANS_OPEN_FAIL 1773
#define RPC_X_SS_CHAR_TRANS_SHORT_FILE 1774
#define RPC_X_SS_IN_NULL_CONTEXT 1775
#define RPC_X_SS_CONTEXT_DAMAGED 1777
#define RPC_X_SS_HANDLES_MISMATCH 1778
#define RPC_X_SS_CANNOT_GET_CALL_HANDLE 1779
#define RPC_X_NULL_REF_POINTER 1780
#define RPC_X_ENUM_VALUE_OUT_OF_RANGE 1781
#define RPC_X_BYTE_COUNT_TOO_SMALL 1782
#define RPC_X_BAD_STUB_DATA 1783
#define ERROR_INVALID_USER_BUFFER 1784
#define ERROR_UNRECOGNIZED_MEDIA 1785
#define ERROR_NO_TRUST_LSA_SECRET 1786
#define ERROR_NO_TRUST_SAM_ACCOUNT 1787
#define ERROR_TRUSTED_DOMAIN_FAILURE 1788
#define ERROR_TRUSTED_RELATIONSHIP_FAILURE 1789
#define ERROR_TRUST_FAILURE 1790
#define RPC_S_CALL_IN_PROGRESS 1791
#define ERROR_NETLOGON_NOT_STARTED 1792
#define ERROR_ACCOUNT_EXPIRED 1793
#define ERROR_REDIRECTOR_HAS_OPEN_HANDLES 1794
#define ERROR_PRINTER_DRIVER_ALREADY_INSTALLED 1795
#define ERROR_UNKNOWN_PORT 1796
#define ERROR_UNKNOWN_PRINTER_DRIVER 1797
#define ERROR_UNKNOWN_PRINTPROCESSOR 1798
#define ERROR_INVALID_SEPARATOR_FILE 1799
#define ERROR_INVALID_PRIORITY 1800
#define ERROR_INVALID_PRINTER_NAME 1801
#define ERROR_PRINTER_ALREADY_EXISTS 1802
#define ERROR_INVALID_PRINTER_COMMAND 1803
#define ERROR_INVALID_DATATYPE 1804
#define ERROR_INVALID_ENVIRONMENT 1805
#define RPC_S_NO_MORE_BINDINGS 1806
#define ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT 1807
#define ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT 1808
#define ERROR_NOLOGON_SERVER_TRUST_ACCOUNT 1809
#define ERROR_DOMAIN_TRUST_INCONSISTENT 1810
#define ERROR_SERVER_HAS_OPEN_HANDLES 1811
#define ERROR_RESOURCE_DATA_NOT_FOUND 1812
#define ERROR_RESOURCE_TYPE_NOT_FOUND 1813
#define ERROR_RESOURCE_NAME_NOT_FOUND 1814
#define ERROR_RESOURCE_LANG_NOT_FOUND 1815
#define ERROR_NOT_ENOUGH_QUOTA 1816
#define RPC_S_NO_INTERFACES 1817
#define RPC_S_CALL_CANCELLED 1818
#define RPC_S_BINDING_INCOMPLETE 1819
#define RPC_S_COMM_FAILURE 1820
#define RPC_S_UNSUPPORTED_AUTHN_LEVEL 1821
#define RPC_S_NO_PRINC_NAME 1822
#define RPC_S_NOT_RPC_ERROR 1823
#define RPC_S_UUID_LOCAL_ONLY 1824
#define RPC_S_SEC_PKG_ERROR 1825
#define RPC_S_NOT_CANCELLED 1826
#define RPC_X_INVALID_ES_ACTION 1827
#define RPC_X_WRONG_ES_VERSION 1828
#define RPC_X_WRONG_STUB_VERSION 1829
#define RPC_S_GROUP_MEMBER_NOT_FOUND 1898
#define EPT_S_CANT_CREATE 1899
#define RPC_S_INVALID_OBJECT 1900
#define ERROR_INVALID_TIME 1901
#define ERROR_INVALID_FORM_NAME 1902
#define ERROR_INVALID_FORM_SIZE 1903
#define ERROR_ALREADY_WAITING 1904
#define ERROR_PRINTER_DELETED 1905
#define ERROR_INVALID_PRINTER_STATE 1906
#define ERROR_PASSWORD_MUST_CHANGE 1907
#define ERROR_DOMAIN_CONTROLLER_NOT_FOUND 1908
#define ERROR_ACCOUNT_LOCKED_OUT 1909
#define ERROR_NO_BROWSER_SERVERS_FOUND 6118
#define ERROR_INVALID_PIXEL_FORMAT 2000
#define ERROR_BAD_DRIVER 2001
#define ERROR_INVALID_WINDOW_STYLE 2002
#define ERROR_METAFILE_NOT_SUPPORTED 2003
#define ERROR_TRANSFORM_NOT_SUPPORTED 2004
#define ERROR_CLIPPING_NOT_SUPPORTED 2005
#define ERROR_UNKNOWN_PRINT_MONITOR 3000
#define ERROR_PRINTER_DRIVER_IN_USE 3001
#define ERROR_SPOOL_FILE_NOT_FOUND 3002
#define ERROR_SPL_NO_STARTDOC 3003
#define ERROR_SPL_NO_ADDJOB 3004
#define ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED 3005
#define ERROR_PRINT_MONITOR_ALREADY_INSTALLED 3006
#define ERROR_INVALID_PRINT_MONITOR 3007
#define ERROR_PRINT_MONITOR_IN_USE 3008
#define ERROR_PRINTER_HAS_JOBS_QUEUED 3009
#define ERROR_SUCCESS_REBOOT_REQUIRED 3010
#define ERROR_SUCCESS_RESTART_REQUIRED 3011
#define ERROR_WINS_INTERNAL 4000
#define ERROR_CAN_NOT_DEL_LOCAL_WINS 4001
#define ERROR_STATIC_INIT 4002
#define ERROR_INC_BACKUP 4003
#define ERROR_FULL_BACKUP 4004
#define ERROR_REC_NON_EXISTENT 4005
#define ERROR_RPL_NOT_ALLOWED 4006
#define ERROR_NO_BROWSER_SERVERS_FOUND 6118
#define FAILED(S) ((HRESULT)((S)<0))
#define SUCCEEDED(Status) ((HRESULT)(Status) >= 0)
#define FACILITY_WINDOWS	8
#define FACILITY_STORAGE	3
#define FACILITY_SSPI	9
#define FACILITY_SCARD	16
#define FACILITY_SETUPAPI	15
#define FACILITY_RPC	1
#define FACILITY_WIN32	7
#define FACILITY_CONTROL	10
#define FACILITY_NULL	0
#define FACILITY_MSMQ	14
#define FACILITY_MEDIASERVER	13
#define FACILITY_INTERNET	12
#define FACILITY_ITF	4
#define FACILITY_DISPATCH	2
#define FACILITY_CERT	11
#define FACILITY_NT_BIT 0x10000000
#define S_OK	0
#define S_FALSE	1
#define HRESULT_FROM_NT(x)	((HRESULT) ((x)|FACILITY_NT_BIT))
#define HRESULT_FROM_WIN32(x) ((HRESULT)(x) <= 0 ? ((HRESULT)(x)):((HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000)))
#define HRESULT_SEVERITY(hr) (((hr) >> 31) & 1)
#define SCODE_CODE(s)	((s)&0xFFFF)
#define GetScode(h)	((SCODE)(h))
#define NOERROR	S_OK
#define IS_ERROR(Status) ((unsigned long)(Status) >> 31 == SEVERITY_ERROR)
#define UNREFERENCED_PARAMETER(a)
#define CDERR_DIALOGFAILURE 0xFFFF
#define CDERR_GENERALCODES 0
#define CDERR_STRUCTSIZE 1
#define CDERR_INITIALIZATION 2
#define CDERR_NOTEMPLATE 3
#define CDERR_NOHINSTANCE 4
#define CDERR_LOADSTRFAILURE 5
#define CDERR_FINDRESFAILURE 6
#define CDERR_LOADRESFAILURE 7
#define CDERR_LOCKRESFAILURE 8
#define CDERR_MEMALLOCFAILURE 9
#define CDERR_MEMLOCKFAILURE 10
#define CDERR_NOHOOK 0xB
#define CDERR_REGISTERMSGFAIL 0xC
#define PDERR_PRINTERCODES 0x1000
#define PDERR_SETUPFAILURE 0x1001
#define PDERR_PARSEFAILURE 0x1002
#define PDERR_RETDEFFAILURE 0x1003
#define PDERR_LOADDRVFAILURE 0x1004
#define PDERR_GETDEVMODEFAIL 0x1005
#define PDERR_INITFAILURE 0x1006
#define PDERR_NODEVICES 0x1007
#define PDERR_NODEFAULTPRN 0x1008
#define PDERR_DNDMMISMATCH 0x1009
#define PDERR_CREATEICFAILURE 0x100A
#define PDERR_PRINTERNOTFOUND 0x100B
#define PDERR_DEFAULTDIFFERENT 0x100C
#define CFERR_CHOOSEFONTCODES 0x2000
#define CFERR_NOFONTS 0x2001
#define CFERR_MAXLESSTHANMIN 0x2002
#define FNERR_FILENAMECODES 0x3000
#define FNERR_SUBCLASSFAILURE 0x3001
#define FNERR_INVALIDFILENAME 0x3002
#define FNERR_BUFFERTOOSMALL 0x3003
#define FRERR_FINDREPLACECODES 0x4000
#define FRERR_BUFFERLENGTHZERO 0x4001
#define CCERR_CHOOSECOLORCODES 0x5000
#define	TYPE_E_BUFFERTOOSMALL	0x80028016
#define	TYPE_E_INVDATAREAD	0x80028018
#define	TYPE_E_UNSUPFORMAT	0x80028019
#define	TYPE_E_REGISTRYACCESS	0x8002801C
#define	TYPE_E_LIBNOTREGISTERED	0x8002801D
#define	TYPE_E_UNDEFINEDTYPE	0x80028027
#define	TYPE_E_QUALIFIEDNAMEDISALLOWED	0x80028028
#define	TYPE_E_INVALIDSTATE	0x80028029
#define	TYPE_E_WRONGTYPEKIND	0x8002802A
#define	TYPE_E_ELEMENTNOTFOUND	0x8002802B
#define	TYPE_E_AMBIGUOUSNAME	0x8002802C
#define	TYPE_E_NAMECONFLICT	0x8002802D
#define	TYPE_E_UNKNOWNLCID	0x8002802E
#define	TYPE_E_DLLFUNCTIONNOTFOUND	0x8002802F
#define	TYPE_E_BADMODULEKIND	0x800288BD
#define	TYPE_E_SIZETOOBIG	0x800288C5
#define	TYPE_E_DUPLICATEID	0x800288C6
#define	TYPE_E_INVALIDID	0x800288CF
#define	TYPE_E_TYPEMISMATCH	0x80028CA0
#define	TYPE_E_OUTOFBOUNDS	0x80028CA1
#define	TYPE_E_IOERROR	0x80028CA2
#define	TYPE_E_CANTCREATETMPFILE	0x80028CA3
#define	TYPE_E_CANTLOADLIBRARY	0x80029C4A
#define	TYPE_E_INCONSISTENTPROPFUNCS	0x80029C83
#define	TYPE_E_CIRCULARTYPE	0x80029C84
#define REGDB_E_FIRST	0x80040150
#define REGDB_E_LAST	0x8004015F
#define REGDB_S_FIRST	0x40150
#define REGDB_S_LAST	0x4015F
#define REGDB_E_READREGDB	_HRESULT_TYPEDEF_(0x80040150)
#define REGDB_E_WRITEREGDB	_HRESULT_TYPEDEF_(0x80040151)
#define REGDB_E_KEYMISSING	_HRESULT_TYPEDEF_(0x80040152)
#define REGDB_E_INVALIDVALUE	_HRESULT_TYPEDEF_(0x80040153)
#define REGDB_E_CLASSNOTREG	_HRESULT_TYPEDEF_(0x80040154)
#define REGDB_E_IIDNOTREG	_HRESULT_TYPEDEF_(0x80040155)
#define OLE_E_FIRST ((HRESULT)0x80040000)
#define OLE_E_LAST ((HRESULT)0x800400FF)
#define OLE_S_FIRST ((HRESULT)0x40000)
#define OLE_S_LAST ((HRESULT)0x400FF)
#define OLE_E_OLEVERB _HRESULT_TYPEDEF_(0x80040000)
#define OLE_E_ADVF _HRESULT_TYPEDEF_(0x80040001)
#define OLE_E_ENUM_NOMORE _HRESULT_TYPEDEF_(0x80040002)
#define OLE_E_ADVISENOTSUPPORTED _HRESULT_TYPEDEF_(0x80040003)
#define OLE_E_NOCONNECTION _HRESULT_TYPEDEF_(0x80040004)
#define OLE_E_NOTRUNNING _HRESULT_TYPEDEF_(0x80040005)
#define OLE_E_NOCACHE _HRESULT_TYPEDEF_(0x80040006)
#define OLE_E_BLANK _HRESULT_TYPEDEF_(0x80040007)
#define OLE_E_CLASSDIFF _HRESULT_TYPEDEF_(0x80040008)
#define OLE_E_CANT_GETMONIKER _HRESULT_TYPEDEF_(0x80040009)
#define OLE_E_CANT_BINDTOSOURCE _HRESULT_TYPEDEF_(0x8004000A)
#define OLE_E_STATIC _HRESULT_TYPEDEF_(0x8004000B)
#define OLE_E_PROMPTSAVECANCELLED _HRESULT_TYPEDEF_(0x8004000C)
#define OLE_E_INVALIDRECT _HRESULT_TYPEDEF_(0x8004000D)
#define OLE_E_WRONGCOMPOBJ _HRESULT_TYPEDEF_(0x8004000E)
#define OLE_E_INVALIDHWND _HRESULT_TYPEDEF_(0x8004000F)
#define OLE_E_NOT_INPLACEACTIVE _HRESULT_TYPEDEF_(0x80040010)
#define OLE_E_CANTCONVERT _HRESULT_TYPEDEF_(0x80040011)
#define OLE_E_NOSTORAGE _HRESULT_TYPEDEF_(0x80040012)
#define DV_E_FORMATETC _HRESULT_TYPEDEF_(0x80040064)
#define DV_E_DVTARGETDEVICE _HRESULT_TYPEDEF_(0x80040065)
#define DV_E_STGMEDIUM _HRESULT_TYPEDEF_(0x80040066)
#define DV_E_STATDATA _HRESULT_TYPEDEF_(0x80040067)
#define DV_E_LINDEX _HRESULT_TYPEDEF_(0x80040068)
#define DV_E_TYMED _HRESULT_TYPEDEF_(0x80040069)
#define DV_E_CLIPFORMAT _HRESULT_TYPEDEF_(0x8004006A)
#define DV_E_DVASPECT _HRESULT_TYPEDEF_(0x8004006B)
#define DV_E_DVTARGETDEVICE_SIZE _HRESULT_TYPEDEF_(0x8004006C)
#define DV_E_NOIVIEWOBJECT _HRESULT_TYPEDEF_(0x8004006D)
#define DRAGDROP_E_FIRST 0x80040100
#define DRAGDROP_E_LAST 0x8004010F
#define DRAGDROP_S_FIRST 0x40100
#define DRAGDROP_S_LAST 0x4010F
#define DRAGDROP_E_NOTREGISTERED _HRESULT_TYPEDEF_(0x80040100)
#define DRAGDROP_E_ALREADYREGISTERED _HRESULT_TYPEDEF_(0x80040101)
#define DRAGDROP_E_INVALIDHWND _HRESULT_TYPEDEF_(0x80040102)
#define CLASSFACTORY_E_FIRST 0x80040110
#define CLASSFACTORY_E_LAST 0x8004011F
#define CLASSFACTORY_S_FIRST 0x40110
#define CLASSFACTORY_S_LAST 0x4011F
#define CLASS_E_NOAGGREGATION _HRESULT_TYPEDEF_(0x80040110)
#define CLASS_E_CLASSNOTAVAILABLE _HRESULT_TYPEDEF_(0x80040111)
#define CLASS_E_NOTLICENSED _HRESULT_TYPEDEF_(0x80040112)
#define MARSHAL_E_FIRST 0x80040120
#define MARSHAL_E_LAST 0x8004012F
#define MARSHAL_S_FIRST 0x40120
#define MARSHAL_S_LAST 0x4012F
#define DATA_E_FIRST 0x80040130
#define DATA_E_LAST 0x8004013F
#define DATA_S_FIRST 0x40130
#define DATA_S_LAST 0x4013F
#define VIEW_E_FIRST 0x80040140
#define VIEW_E_LAST 0x8004014F
#define VIEW_S_FIRST 0x40140
#define VIEW_S_LAST 0x4014F
#define VIEW_E_DRAW _HRESULT_TYPEDEF_(0x80040140)
#define REGDB_E_FIRST 0x80040150
#define REGDB_E_LAST 0x8004015F
#define REGDB_S_FIRST 0x40150
#define REGDB_S_LAST 0x4015F
#define REGDB_E_READREGDB _HRESULT_TYPEDEF_(0x80040150)
#define REGDB_E_WRITEREGDB _HRESULT_TYPEDEF_(0x80040151)
#define REGDB_E_KEYMISSING _HRESULT_TYPEDEF_(0x80040152)
#define REGDB_E_INVALIDVALUE _HRESULT_TYPEDEF_(0x80040153)
#define REGDB_E_CLASSNOTREG _HRESULT_TYPEDEF_(0x80040154)
#define REGDB_E_IIDNOTREG _HRESULT_TYPEDEF_(0x80040155)
#define CAT_E_FIRST 0x80040160
#define CAT_E_LAST 0x80040161
#define CAT_E_CATIDNOEXIST _HRESULT_TYPEDEF_(0x80040160)
#define CAT_E_NODESCRIPTION _HRESULT_TYPEDEF_(0x80040161)
#define CS_E_FIRST 0x80040164
#define CS_E_LAST 0x8004016F
#define CS_E_PACKAGE_NOTFOUND _HRESULT_TYPEDEF_(0x80040164)
#define CS_E_NOT_DELETABLE _HRESULT_TYPEDEF_(0x80040165)
#define CS_E_CLASS_NOTFOUND _HRESULT_TYPEDEF_(0x80040166)
#define CS_E_INVALID_VERSION _HRESULT_TYPEDEF_(0x80040167)
#define CS_E_NO_CLASSSTORE _HRESULT_TYPEDEF_(0x80040168)
#define CS_E_OBJECT_NOTFOUND _HRESULT_TYPEDEF_(0x80040169)
#define CS_E_OBJECT_ALREADY_EXISTS _HRESULT_TYPEDEF_(0x8004016A)
#define CS_E_INVALID_PATH _HRESULT_TYPEDEF_(0x8004016B)
#define CS_E_NETWORK_ERROR _HRESULT_TYPEDEF_(0x8004016C)
#define CS_E_ADMIN_LIMIT_EXCEEDED _HRESULT_TYPEDEF_(0x8004016D)
#define CS_E_SCHEMA_MISMATCH _HRESULT_TYPEDEF_(0x8004016E)
#define CS_E_INTERNAL_ERROR _HRESULT_TYPEDEF_(0x8004016F)
#define CACHE_E_FIRST 0x80040170
#define CACHE_E_LAST 0x8004017F
#define CACHE_S_FIRST 0x40170
#define CACHE_S_LAST 0x4017F
#define CACHE_E_NOCACHE_UPDATED _HRESULT_TYPEDEF_(0x80040170)
#define OLEOBJ_E_FIRST 0x80040180
#define OLEOBJ_E_LAST 0x8004018F
#define OLEOBJ_S_FIRST 0x40180
#define OLEOBJ_S_LAST 0x4018F
#define OLEOBJ_E_NOVERBS _HRESULT_TYPEDEF_(0x80040180)
#define OLEOBJ_E_INVALIDVERB _HRESULT_TYPEDEF_(0x80040181)
#define CLIENTSITE_E_FIRST 0x80040190
#define CLIENTSITE_E_LAST 0x8004019F
#define CLIENTSITE_S_FIRST 0x40190
#define CLIENTSITE_S_LAST 0x4019F
#define INPLACE_E_NOTUNDOABLE _HRESULT_TYPEDEF_(0x800401A0)
#define INPLACE_E_NOTOOLSPACE _HRESULT_TYPEDEF_(0x800401A1)
#define INPLACE_E_FIRST 0x800401A0
#define INPLACE_E_LAST 0x800401AF
#define INPLACE_S_FIRST 0x401A0
#define INPLACE_S_LAST 0x401AF
#define ENUM_E_FIRST 0x800401B0
#define ENUM_E_LAST 0x800401BF
#define ENUM_S_FIRST 0x401B0
#define ENUM_S_LAST 0x401BF
#define CONVERT10_E_FIRST 0x800401C0
#define CONVERT10_E_LAST 0x800401CF
#define CONVERT10_S_FIRST 0x401C0
#define CONVERT10_S_LAST 0x401CF
#define CONVERT10_E_OLESTREAM_GET _HRESULT_TYPEDEF_(0x800401C0)
#define CONVERT10_E_OLESTREAM_PUT _HRESULT_TYPEDEF_(0x800401C1)
#define CONVERT10_E_OLESTREAM_FMT _HRESULT_TYPEDEF_(0x800401C2)
#define CONVERT10_E_OLESTREAM_BITMAP_TO_DIB _HRESULT_TYPEDEF_(0x800401C3)
#define CONVERT10_E_STG_FMT _HRESULT_TYPEDEF_(0x800401C4)
#define CONVERT10_E_STG_NO_STD_STREAM _HRESULT_TYPEDEF_(0x800401C5)
#define CONVERT10_E_STG_DIB_TO_BITMAP _HRESULT_TYPEDEF_(0x800401C6)
#define CLIPBRD_E_FIRST 0x800401D0
#define CLIPBRD_E_LAST 0x800401DF
#define CLIPBRD_S_FIRST 0x401D0
#define CLIPBRD_S_LAST 0x401DF
#define CLIPBRD_E_CANT_OPEN _HRESULT_TYPEDEF_(0x800401D0)
#define CLIPBRD_E_CANT_EMPTY _HRESULT_TYPEDEF_(0x800401D1)
#define CLIPBRD_E_CANT_SET _HRESULT_TYPEDEF_(0x800401D2)
#define CLIPBRD_E_BAD_DATA _HRESULT_TYPEDEF_(0x800401D3)
#define CLIPBRD_E_CANT_CLOSE _HRESULT_TYPEDEF_(0x800401D4)
#define MK_E_FIRST 0x800401E0
#define MK_E_LAST 0x800401EF
#define MK_S_FIRST 0x401E0
#define MK_S_LAST 0x401EF
#define MK_E_CONNECTMANUALLY _HRESULT_TYPEDEF_(0x800401E0)
#define MK_E_EXCEEDEDDEADLINE _HRESULT_TYPEDEF_(0x800401E1)
#define MK_E_NEEDGENERIC _HRESULT_TYPEDEF_(0x800401E2)
#define MK_E_UNAVAILABLE _HRESULT_TYPEDEF_(0x800401E3)
#define MK_E_SYNTAX _HRESULT_TYPEDEF_(0x800401E4)
#define MK_E_NOOBJECT _HRESULT_TYPEDEF_(0x800401E5)
#define MK_E_INVALIDEXTENSION _HRESULT_TYPEDEF_(0x800401E6)
#define MK_E_INTERMEDIATEINTERFACENOTSUPPORTED _HRESULT_TYPEDEF_(0x800401E7)
#define MK_E_NOTBINDABLE _HRESULT_TYPEDEF_(0x800401E8)
#define MK_E_NOTBOUND _HRESULT_TYPEDEF_(0x800401E9)
#define MK_E_CANTOPENFILE _HRESULT_TYPEDEF_(0x800401EA)
#define MK_E_MUSTBOTHERUSER _HRESULT_TYPEDEF_(0x800401EB)
#define MK_E_NOINVERSE _HRESULT_TYPEDEF_(0x800401EC)
#define MK_E_NOSTORAGE _HRESULT_TYPEDEF_(0x800401ED)
#define MK_E_NOPREFIX _HRESULT_TYPEDEF_(0x800401EE)
#define MK_E_ENUMERATION_FAILED _HRESULT_TYPEDEF_(0x800401EF)
#define CO_E_FIRST 0x800401F0
#define CO_E_LAST 0x800401FF
#define CO_S_FIRST 0x401F0
#define CO_S_LAST 0x401FF
#define CO_E_NOTINITIALIZED _HRESULT_TYPEDEF_(0x800401F0)
#define CO_E_ALREADYINITIALIZED _HRESULT_TYPEDEF_(0x800401F1)
#define CO_E_CANTDETERMINECLASS _HRESULT_TYPEDEF_(0x800401F2)
#define CO_E_CLASSSTRING _HRESULT_TYPEDEF_(0x800401F3)
#define CO_E_IIDSTRING _HRESULT_TYPEDEF_(0x800401F4)
#define CO_E_APPNOTFOUND _HRESULT_TYPEDEF_(0x800401F5)
#define CO_E_APPSINGLEUSE _HRESULT_TYPEDEF_(0x800401F6)
#define CO_E_ERRORINAPP _HRESULT_TYPEDEF_(0x800401F7)
#define CO_E_DLLNOTFOUND _HRESULT_TYPEDEF_(0x800401F8)
#define CO_E_ERRORINDLL _HRESULT_TYPEDEF_(0x800401F9)
#define CO_E_WRONGOSFORAPP _HRESULT_TYPEDEF_(0x800401FA)
#define CO_E_OBJNOTREG _HRESULT_TYPEDEF_(0x800401FB)
#define CO_E_OBJISREG _HRESULT_TYPEDEF_(0x800401FC)
#define CO_E_OBJNOTCONNECTED _HRESULT_TYPEDEF_(0x800401FD)
#define CO_E_APPDIDNTREG _HRESULT_TYPEDEF_(0x800401FE)
#define CO_E_RELEASED _HRESULT_TYPEDEF_(0x800401FF)
#define OLE_S_USEREG _HRESULT_TYPEDEF_(0x40000)
#define OLE_S_STATIC _HRESULT_TYPEDEF_(0x40001)
#define OLE_S_MAC_CLIPFORMAT _HRESULT_TYPEDEF_(0x40002)
#define DRAGDROP_S_DROP _HRESULT_TYPEDEF_(0x40100)
#define DRAGDROP_S_CANCEL _HRESULT_TYPEDEF_(0x40101)
#define DRAGDROP_S_USEDEFAULTCURSORS _HRESULT_TYPEDEF_(0x40102)
#define DATA_S_SAMEFORMATETC _HRESULT_TYPEDEF_(0x40130)
#define VIEW_S_ALREADY_FROZEN _HRESULT_TYPEDEF_(0x40140)
#define CACHE_S_FORMATETC_NOTSUPPORTED _HRESULT_TYPEDEF_(0x40170)
#define CACHE_S_SAMECACHE _HRESULT_TYPEDEF_(0x40171)
#define CACHE_S_SOMECACHES_NOTUPDATED _HRESULT_TYPEDEF_(0x40172)
#define OLEOBJ_S_INVALIDVERB _HRESULT_TYPEDEF_(0x40180)
#define OLEOBJ_S_CANNOT_DOVERB_NOW _HRESULT_TYPEDEF_(0x40181)
#define OLEOBJ_S_INVALIDHWND _HRESULT_TYPEDEF_(0x40182)
#define INPLACE_S_TRUNCATED _HRESULT_TYPEDEF_(0x401A0)
#define CONVERT10_S_NO_PRESENTATION _HRESULT_TYPEDEF_(0x401C0)
#define MK_S_REDUCED_TO_SELF _HRESULT_TYPEDEF_(0x401E2)
#define MK_S_ME _HRESULT_TYPEDEF_(0x401E4)
#define MK_S_HIM _HRESULT_TYPEDEF_(0x401E5)
#define MK_S_US _HRESULT_TYPEDEF_(0x401E6)
#define MK_S_MONIKERALREADYREGISTERED _HRESULT_TYPEDEF_(0x401E7)
#define CO_E_CLASS_CREATE_FAILED _HRESULT_TYPEDEF_(0x80080001)
#define CO_E_SCM_ERROR _HRESULT_TYPEDEF_(0x80080002)
#define CO_E_SCM_RPC_FAILURE _HRESULT_TYPEDEF_(0x80080003)
#define CO_E_BAD_PATH _HRESULT_TYPEDEF_(0x80080004)
#define CO_E_SERVER_EXEC_FAILURE _HRESULT_TYPEDEF_(0x80080005)
#define CO_E_OBJSRV_RPC_FAILURE _HRESULT_TYPEDEF_(0x80080006)
#define MK_E_NO_NORMALIZED _HRESULT_TYPEDEF_(0x80080007)
#define CO_E_SERVER_STOPPING _HRESULT_TYPEDEF_(0x80080008)
#define MEM_E_INVALID_ROOT _HRESULT_TYPEDEF_(0x80080009)
#define MEM_E_INVALID_LINK _HRESULT_TYPEDEF_(0x80080010)
#define MEM_E_INVALID_SIZE _HRESULT_TYPEDEF_(0x80080011)
#define CO_S_NOTALLINTERFACES _HRESULT_TYPEDEF_(0x80012)
#define DIGSIG_E_ENCODE	_HRESULT_TYPEDEF_(0x800B0005)
#define DIGSIG_E_DECODE	_HRESULT_TYPEDEF_(0x800B0006)
#define DIGSIG_E_EXTENSIBILITY	_HRESULT_TYPEDEF_(0x800B0007)
#define DIGSIG_E_CRYPTO	_HRESULT_TYPEDEF_(0x800B0008)
#define PERSIST_E_SIZEDEFINITE	_HRESULT_TYPEDEF_(0x800B0009)
#define PERSIST_E_SIZEINDEFINITE	_HRESULT_TYPEDEF_(0x800B000A)
#define PERSIST_E_NOTSELFSIZING	_HRESULT_TYPEDEF_(0x800B000B)
#define DISP_E_UNKNOWNINTERFACE _HRESULT_TYPEDEF_(0x80020001)
#define DISP_E_MEMBERNOTFOUND _HRESULT_TYPEDEF_(0x80020003)
#define DISP_E_PARAMNOTFOUND _HRESULT_TYPEDEF_(0x80020004)
#define DISP_E_TYPEMISMATCH _HRESULT_TYPEDEF_(0x80020005)
#define DISP_E_UNKNOWNNAME _HRESULT_TYPEDEF_(0x80020006)
#define DISP_E_NONAMEDARGS _HRESULT_TYPEDEF_(0x80020007)
#define DISP_E_BADVARTYPE _HRESULT_TYPEDEF_(0x80020008)
#define DISP_E_EXCEPTION _HRESULT_TYPEDEF_(0x80020009)
#define DISP_E_OVERFLOW _HRESULT_TYPEDEF_(0x8002000A)
#define DISP_E_BADINDEX _HRESULT_TYPEDEF_(0x8002000B)
#define DISP_E_UNKNOWNLCID _HRESULT_TYPEDEF_(0x8002000C)
#define DISP_E_ARRAYISLOCKED _HRESULT_TYPEDEF_(0x8002000D)
#define DISP_E_BADPARAMCOUNT _HRESULT_TYPEDEF_(0x8002000E)
#define DISP_E_PARAMNOTOPTIONAL _HRESULT_TYPEDEF_(0x8002000F)
#define DISP_E_BADCALLEE _HRESULT_TYPEDEF_(0x80020010)
#define DISP_E_NOTACOLLECTION _HRESULT_TYPEDEF_(0x80020011)
#define DISP_E_DIVBYZERO _HRESULT_TYPEDEF_(0x80020012)
#define DISP_E_BUFFERTOOSMALL _HRESULT_TYPEDEF_(0x80020013)
#define STG_E_INVALIDFUNCTION _HRESULT_TYPEDEF_(0x80030001)
#define STG_E_FILENOTFOUND _HRESULT_TYPEDEF_(0x80030002)
#define STG_E_PATHNOTFOUND _HRESULT_TYPEDEF_(0x80030003)
#define STG_E_TOOMANYOPENFILES _HRESULT_TYPEDEF_(0x80030004)
#define STG_E_ACCESSDENIED _HRESULT_TYPEDEF_(0x80030005)
#define STG_E_INVALIDHANDLE _HRESULT_TYPEDEF_(0x80030006)
#define STG_E_INSUFFICIENTMEMORY _HRESULT_TYPEDEF_(0x80030008)
#define STG_E_INVALIDPOINTER _HRESULT_TYPEDEF_(0x80030009)
#define STG_E_NOMOREFILES _HRESULT_TYPEDEF_(0x80030012)
#define STG_E_DISKISWRITEPROTECTED _HRESULT_TYPEDEF_(0x80030013)
#define STG_E_SEEKERROR _HRESULT_TYPEDEF_(0x80030019)
#define STG_E_WRITEFAULT _HRESULT_TYPEDEF_(0x8003001D)
#define STG_E_READFAULT _HRESULT_TYPEDEF_(0x8003001E)
#define STG_E_SHAREVIOLATION _HRESULT_TYPEDEF_(0x80030020)
#define STG_E_LOCKVIOLATION _HRESULT_TYPEDEF_(0x80030021)
#define STG_E_FILEALREADYEXISTS _HRESULT_TYPEDEF_(0x80030050)
#define STG_E_INVALIDPARAMETER _HRESULT_TYPEDEF_(0x80030057)
#define STG_E_MEDIUMFULL _HRESULT_TYPEDEF_(0x80030070)
#define STG_E_PROPSETMISMATCHED _HRESULT_TYPEDEF_(0x800300F0)
#define STG_E_ABNORMALAPIEXIT _HRESULT_TYPEDEF_(0x800300FA)
#define STG_E_INVALIDHEADER _HRESULT_TYPEDEF_(0x800300FB)
#define STG_E_INVALIDNAME _HRESULT_TYPEDEF_(0x800300FC)
#define STG_E_UNKNOWN _HRESULT_TYPEDEF_(0x800300FD)
#define STG_E_UNIMPLEMENTEDFUNCTION _HRESULT_TYPEDEF_(0x800300FE)
#define STG_E_INVALIDFLAG _HRESULT_TYPEDEF_(0x800300FF)
#define STG_E_INUSE _HRESULT_TYPEDEF_(0x80030100)
#define STG_E_NOTCURRENT _HRESULT_TYPEDEF_(0x80030101)
#define STG_E_REVERTED _HRESULT_TYPEDEF_(0x80030102)
#define STG_E_CANTSAVE _HRESULT_TYPEDEF_(0x80030103)
#define STG_E_OLDFORMAT _HRESULT_TYPEDEF_(0x80030104)
#define STG_E_OLDDLL _HRESULT_TYPEDEF_(0x80030105)
#define STG_E_SHAREREQUIRED _HRESULT_TYPEDEF_(0x80030106)
#define STG_E_NOTFILEBASEDSTORAGE _HRESULT_TYPEDEF_(0x80030107)
#define STG_E_EXTANTMARSHALLINGS _HRESULT_TYPEDEF_(0x80030108)
#define STG_E_DOCFILETOOLARGE _HRESULT_TYPEDEF_(0x80030111)
#define STG_E_NOTSIMPLEFORMAT _HRESULT_TYPEDEF_(0x80030112)
#define STG_E_INCOMPLETE _HRESULT_TYPEDEF_(0x80030201)
#define STG_E_TERMINATED _HRESULT_TYPEDEF_(0x80030202)
#define STG_E_DOCFILECORRUPT _HRESULT_TYPEDEF_(0x80030109)
#define STG_E_BADBASEADDRESS _HRESULT_TYPEDEF_(0x80030110)
#define STG_S_CONVERTED _HRESULT_TYPEDEF_(0x30200)
#define STG_S_BLOCK _HRESULT_TYPEDEF_(0x30201)
#define STG_S_RETRYNOW _HRESULT_TYPEDEF_(0x30202)
#define STG_S_MONITORING _HRESULT_TYPEDEF_(0x30203)
#define STG_S_MULTIPLEOPENS _HRESULT_TYPEDEF_(0x30204)
#define STG_S_CONSOLIDATIONFAILED _HRESULT_TYPEDEF_(0x30205)
#define STG_S_CANNOTCONSOLIDATE _HRESULT_TYPEDEF_(0x30206)
#define SCHED_E_SERVICE_NOT_LOCALSYSTEM	6200
#define SCHED_E_TRIGGER_NOT_FOUND	_HRESULT_TYPEDEF_(0x80041309L)
#define SCHED_E_TASK_NOT_READY		_HRESULT_TYPEDEF_(0x8004130AL)
#define SCHED_E_TASK_NOT_RUNNING	_HRESULT_TYPEDEF_(0x8004130BL)
#define SCHED_E_SERVICE_NOT_INSTALLED	_HRESULT_TYPEDEF_(0x8004130CL)
#define SCHED_E_CANNOT_OPEN_TASK	_HRESULT_TYPEDEF_(0x8004130DL)
#define SCHED_E_INVALID_TASK		_HRESULT_TYPEDEF_(0x8004130EL)
#define SCHED_E_ACCOUNT_INFORMATION_NOT_SET _HRESULT_TYPEDEF_(0x8004130FL)
#define SCHED_E_ACCOUNT_NAME_NOT_FOUND	_HRESULT_TYPEDEF_(0x80041310L)
#define SCHED_E_ACCOUNT_DBASE_CORRUPT	_HRESULT_TYPEDEF_(0x80041311L)
#define SCHED_E_NO_SECURITY_SERVICES	_HRESULT_TYPEDEF_(0x80041312L)
#define SCHED_E_UNKNOWN_OBJECT_VERSION	_HRESULT_TYPEDEF_(0x80041313L)
#define SCHED_E_UNSUPPORTED_ACCOUNT_OPTION _HRESULT_TYPEDEF_(0x80041314L)
#define SCHED_E_SERVICE_NOT_RUNNING	_HRESULT_TYPEDEF_(0x80041315L)
#define CERT_E_EXPIRED _HRESULT_TYPEDEF_(0x800B0101)
#define CERT_E_VALIDITYPERIODNESTING _HRESULT_TYPEDEF_(0x800B0102)
#define CERT_E_ROLE _HRESULT_TYPEDEF_(0x800B0103)
#define CERT_E_PATHLENCONST _HRESULT_TYPEDEF_(0x800B0104)
#define CERT_E_CRITICAL _HRESULT_TYPEDEF_(0x800B0105)
#define CERT_E_PURPOSE _HRESULT_TYPEDEF_(0x800B0106)
#define CERT_E_ISSUERCHAINING _HRESULT_TYPEDEF_(0x800B0107)
#define CERT_E_MALFORMED _HRESULT_TYPEDEF_(0x800B0108)
#define CERT_E_UNTRUSTEDROOT _HRESULT_TYPEDEF_(0x800B0109)
#define CERT_E_CHAINING _HRESULT_TYPEDEF_(0x800B010A)
#define CERT_E_REVOKED _HRESULT_TYPEDEF_(0x800B010C)
#define CERT_E_UNTRUSTEDTESTROOT _HRESULT_TYPEDEF_(0x800B010D)
#define CERT_E_REVOCATION_FAILURE _HRESULT_TYPEDEF_(0x800B010E)
#define CERT_E_CN_NO_MATCH _HRESULT_TYPEDEF_(0x800B010F)
#define CERT_E_WRONG_USAGE _HRESULT_TYPEDEF_(0x800B0110)
#define SEVERITY_ERROR 1
#define OR_INVALID_OXID	1910
#define OR_INVALID_OID	1911
#define OR_INVALID_SET	1912
#define MAKE_SCODE(sev,fac,code) ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )
#define HRESULT_FACILITY(hr) (((hr) >> 16) & 0x1fff)
#define HRESULT_CODE(hr) (hr&0xFFFF)
#define EXTERN_C extern
#define ResultFromScode(sc) ((HRESULT) (sc))
#define UNALIGNED
#define WHEEL_DELTA 120

enum VARENUM { VT_EMPTY=0,VT_NULL=1, VT_I2=2, VT_I4=3, VT_R4=4, VT_R8=5,
 VT_CY=6,VT_DATE=7, VT_BSTR=8, VT_DISPATCH=9, VT_ERROR=10, VT_BOOL=11,
 VT_VARIANT=12,VT_UNKNOWN=13, VT_DECIMAL=14, VT_I1=16, VT_UI1=17,
 VT_UI2=18,VT_UI4=19, VT_I8=20, VT_UI8=21, VT_INT=22, VT_UINT=23,
 VT_VOID=24,VT_HRESULT=25, VT_PTR=26, VT_SAFEARRAY=27, VT_CARRAY=28,
 VT_USERDEFINED=29,VT_LPSTR=30, VT_LPWSTR=31, VT_RECORD=36, VT_FILETIME=64,
 VT_BLOB=65,VT_STREAM=66, VT_STORAGE=67, VT_STREAMED_OBJECT=68, VT_STORED_OBJECT=69,
 VT_BLOB_OBJECT=70,VT_CF=71, VT_CLSID=72, VT_VERSIONED_STREAM=73, VT_BSTR_BLOB=0xfff,
 VT_VECTOR=0x1000,VT_ARRAY=0x2000, VT_BYREF=0x4000, VT_RESERVED=0x8000,
 VT_ILLEGAL=0xffff,VT_ILLEGALMASKED=0xfff, VT_TYPEMASK=0xfff
};

//#ifndef _VARIANT_BOOL_DEFINED
//typedef short VARIANT_BOOL;
//typedef short _VARIANT_BOOL;
//#define _VARIANT_BOOL_DEFINED
//#endif

#define VARIANT_TRUE ((VARIANT_BOOL)-1)
#define VARIANT_FALSE ((VARIANT_BOOL)0)

BOOL GdiGradientFill(
  HDC        hdc,
  PTRIVERTEX pVertex,
  ULONG      nVertex,
  PVOID      pMesh,
  ULONG      nCount,
  ULONG      ulMode
);

#endif
=== fcntl.h 46/77 ===
/* FCNTL.H */

int _setmode(int,int);

#ifndef _INC_FCNTL
#define _INC_FCNTL

#define _O_RDONLY 0x0000
#define _O_WRONLY 0x0001
#define _O_RDWR 0x0002
#define _O_APPEND 0x0008
#define _O_CREAT 0x0100
#define _O_TRUNC 0x0200
#define _O_EXCL 0x0400
#define _O_TEXT 0x4000
#define _O_BINARY 0x8000
#define _O_WTEXT 0x10000
#define _O_U16TEXT 0x20000
#define _O_U8TEXT 0x40000
#define _O_ACCMODE (_O_RDONLY|_O_WRONLY|_O_RDWR)

#define _O_RAW _O_BINARY
#define _O_NOINHERIT 0x0080
#define _O_TEMPORARY 0x0040
#define _O_SHORT_LIVED 0x1000

#define _O_SEQUENTIAL 0x0020
#define _O_RANDOM 0x0010

#if !defined(NO_OLDNAMES) || defined(_POSIX)
#define O_RDONLY _O_RDONLY
#define O_WRONLY _O_WRONLY
#define O_RDWR _O_RDWR
#define O_APPEND _O_APPEND
#define O_CREAT _O_CREAT
#define O_TRUNC _O_TRUNC
#define O_EXCL _O_EXCL
#define O_TEXT _O_TEXT
#define O_BINARY _O_BINARY
#define O_RAW _O_BINARY
#define O_TEMPORARY _O_TEMPORARY
#define O_NOINHERIT _O_NOINHERIT
#define O_SEQUENTIAL _O_SEQUENTIAL
#define O_RANDOM _O_RANDOM
#define O_ACCMODE _O_ACCMODE
#endif

#endif
=== io.h 47/77 ===

#ifndef $io
#define $io

#include <stdint.h>
#include <wchar.h>
#include <time.h>

/* io.h */

#define _A_NORMAL 0x00
#define _A_RDONLY 0x01
#define _A_HIDDEN 0x02
#define _A_SYSTEM 0x04
#define _A_SUBDIR 0x10
#define _A_ARCH 0x20


//#message "IO included"
struct _finddata_t {
        unsigned    attrib;
        time_t      time_create;
        time_t      time_access;
        time_t      time_write;
        unsigned long    size;
        char        name[260];
};

int _isatty(int);

int _read(int, void*, unsigned int);
#define read _read

int _open(const char*, int, ...);
#define open _open

long _lseek(int, long, int);
#define lseek _lseek

int _close(int);
#define close _close

intptr_t _get_osfhandle(int);
int _open_osfhandle(intptr_t,int);

int _setmode(int,int);
#define setmode _setmode

int _wchmod(const wchar_t*, int);

int _chmod(const char *, int);
#define chmod _chmod

int _dup(int);
#define dup _dup

intptr_t _findfirst(const char*, struct _finddata_t*);
int _findnext(intptr_t, struct _finddata_t*);
int _findclose(intptr_t);

int _access(const char*,int);
#define access _access

int _wunlink(const wchar_t*);


#endif
=== direct.h 48/77 ===
#ifndef $direct
#define $direct

typedef struct {
 unsigned int total_clusters;
 unsigned int avail_clusters;
 unsigned int sectors_per_cluster;
 unsigned int bytes_per_sector;
} diskfree_t;

int chdir(const char *);
char* _getcwd(char *, int);
#define getcwd _getcwd
int _mkdir(const char *);
int _rmdir(const char *);
int _wrmdir(const wchar_t*);
int _wmkdir(const wchar_t*);

#define mkdir _mkdir
#define rmdir _rmdir

int _chdrive(int);
char* _getdcwd(int, char *, int);
wchar_t* _wgetcwd(wchar_t*, int);
int _wchdir(const wchar_t*);
int _getdrive(void);
int _chdir(const char*);
#define chdir _chdir

unsigned long _getdrives(void);
unsigned int _getdiskfree(unsigned int, diskfree_t*);

#endif

=== process.h 49/77 ===
/* Header process.h */
#ifndef $process
#define $process

#include <stdint.h>

#define P_WAIT		0
#define P_NOWAIT	1
#define P_OVERLAY	2
#define P_DETACH	4
#define WAIT_CHILD 0
#define _P_WAIT P_WAIT
#define _P_NOWAIT P_NOWAIT
#define _P_OVERLAY P_OVERLAY

int _spawnvp(int, const char*, const char*const*);
#define spawnvp _spawnvp

void endthread(void);
unsigned long _beginthreadex(void *,unsigned,unsigned (*)(void *),void *,unsigned,unsigned *);
void _endthreadex(unsigned);
int _cwait(int*, int, int);
#define cwait _cwait
//int _System(const char *cmd,int nCmdShow);

intptr_t _execve(const char*, const char*const*, const char*const*);
#define execve _execve

//#define _WAIT_CHILD	0
//#endif
#endif

=== malloc.h 50/77 ===
#include <stddef.h>

void* malloc(size_t);
void* realloc(void *, size_t);
void  free(void *);
void *_alloca(size_t);
=== bcc.h 51/77 ===
#define __attribute__(x)
#define _WIN32
#define WIN32
#define __WIN32__
#define __inline
#define __dllimport(x)
#define __declspec(x)
#define __stdcall
#define CALLBACK $callback
#define __cdecl
#define EXTERN_C extern
#define DECLSPEC_IMPORT
#define __32BIT__
=== conio.h 52/77 ===
/* conio.h */
#include <stddef.h>
#include <wchar.h>

int _getch(void);
int _kbhit(void);
wint_t _getwch(void);

#define getch _getch
#define kbhit _kbhit

int _putch(int);
int _cprintf(char *, ...);
int _getche(void);
int _ungetch(int);

#define putch _putch
#define cprintf _cprintf
#define getche _getche
#define ungetch _ungetch
=== winsock2.h 53/77 ===
#ifndef _WINSOCK2_H
#define _WINSOCK2_H

#include <_mingw.h>
#include <windows.h>

#ifndef FD_SETSIZE
#define FD_SETSIZE 64
#endif

typedef unsigned int SOCKET;

typedef struct fd_set {
  unsigned int   fd_count;
  SOCKET  fd_array[FD_SETSIZE];
} fd_set;

extern int __stdcall __WSAFDIsSet(SOCKET,fd_set *);

#ifndef FD_CLR
#define FD_CLR(fd,set) do { unsigned int __i;\
for (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {\
    if (((fd_set *)(set))->fd_array[__i] == (fd)) {\
    while (__i < ((fd_set *)(set))->fd_count-1) {\
        ((fd_set*)(set))->fd_array[__i] = ((fd_set*)(set))->fd_array[__i+1];\
        __i++;\
    }\
    ((fd_set*)(set))->fd_count--;\
    break;\
    }\
}\
} while (0)
#endif

#ifndef FD_SET
/* this differs from the define in winsock.h and in cygwin sys/types.h */
#define FD_SET(fd, set) do { unsigned int __i;\
for (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {\
    if (((fd_set *)(set))->fd_array[__i] == (fd)) {\
        break;\
    }\
}\
if (__i == ((fd_set *)(set))->fd_count) {\
    if (((fd_set *)(set))->fd_count < FD_SETSIZE) {\
        ((fd_set *)(set))->fd_array[__i] = (fd);\
        ((fd_set *)(set))->fd_count++;\
    }\
}\
} while(0)
#endif

#ifndef FD_ZERO
#define FD_ZERO(set) (((fd_set *)(set))->fd_count=0)
#endif

#ifndef FD_ISSET
#define FD_ISSET(fd, set) __WSAFDIsSet((SOCKET)(fd), (fd_set *)(set))
#endif

#ifndef _TIMEVAL_DEFINED /* also in sys/time.h */
#define _TIMEVAL_DEFINED
struct timeval {
    long tv_sec;
    long tv_usec;
};
#endif

struct in_addr {
    union {
        struct { unsigned char s_b1,s_b2,s_b3,s_b4; } S_un_b;
        struct { unsigned short s_w1,s_w2; } S_un_w;
        unsigned long S_addr;
    } S_un;
};
#define s_addr  S_un.S_addr

struct sockaddr_in {
    short sin_family;
    unsigned short sin_port;
    struct in_addr sin_addr;
    char sin_zero[8];
};

struct sockaddr {
    unsigned short sa_family;
    char sa_data[14];
};

struct hostent {
    char *h_name;
    char **h_aliases;
    short h_addrtype;
    short h_length;
    char **h_addr_list;
};
#define h_addr h_addr_list[0]

#define WSADESCRIPTION_LEN  256
#define WSASYS_STATUS_LEN   128
typedef struct WSAData {
    WORD wVersion;
    WORD wHighVersion;
    char szDescription[WSADESCRIPTION_LEN+1];
    char szSystemStatus[WSASYS_STATUS_LEN+1];
    unsigned short iMaxSockets;
    unsigned short iMaxUdpDg;
    char *lpVendorInfo;
} WSADATA;
typedef WSADATA *LPWSADATA;

#define INVALID_SOCKET (SOCKET)(~0)
#define SOCK_STREAM  1
#define SO_REUSEADDR 4
#define AF_INET 2
#define MSG_PEEK 0x2
#define INADDR_ANY (unsigned long)0x00000000
#define INADDR_LOOPBACK 0x7f000001
#define SOL_SOCKET 0xffff

#define SD_RECEIVE  0x00
#define SD_SEND     0x01
#define SD_BOTH     0x02

#define h_errno WSAGetLastError()

#define WSABASEERR 10000
#define TRY_AGAIN (WSABASEERR+1002)

SOCKET __stdcall accept(SOCKET, struct sockaddr *, int *);
int __stdcall bind(SOCKET, const struct sockaddr *, int);
int __stdcall closesocket(SOCKET);
int __stdcall connect(SOCKET, const struct sockaddr *, int);
struct hostent *__stdcall gethostbyname(const char *);
int __stdcall gethostname(char *, int);
int __stdcall getpeername(SOCKET, struct sockaddr *, int *);
int __stdcall getsockname(SOCKET, struct sockaddr *, int *);
unsigned long __stdcall htonl(unsigned long);
unsigned short __stdcall htons(unsigned short);
int __stdcall listen(SOCKET, int);
unsigned long __stdcall ntohl(unsigned long);
unsigned short __stdcall ntohs(unsigned short);
int __stdcall recv(SOCKET, char *, int, int);
int __stdcall recvfrom(SOCKET, char *, int, int, struct sockaddr *, int *);
int __stdcall select(int nfds, fd_set *, fd_set *, fd_set *, const struct timeval *);
int __stdcall send(SOCKET, const char *, int, int);
int __stdcall sendto(SOCKET, const char *, int, int, const struct sockaddr *, int);
int __stdcall setsockopt(SOCKET, int, int, const char *, int);
int __stdcall shutdown(SOCKET, int);
int __stdcall WSACleanup(void);
int __stdcall WSAGetLastError(void);
int __stdcall WSAStartup(WORD, LPWSADATA);

SOCKET __stdcall socket(int, int, int);

#endif

=== _mingw.h 54/77 ===
/*
 * _mingw.h
 *
 *  This file is for TinyCC and not part of the Mingw32 package.
 *
 *  THIS SOFTWARE IS NOT COPYRIGHTED
 *
 *  This source code is offered for use in the public domain. You may
 *  use, modify or distribute it freely.
 *
 *  This code is distributed in the hope that it will be useful but
 *  WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 *  DISCLAIMED. This includes but is not limited to warranties of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#ifndef __MINGW_H
#define __MINGW_H

/* some winapi files define these before including _mingw.h --> */
#undef __cdecl
#undef _X86_
#undef WIN32
/* <-- */

#include <stddef.h>
#include <stdarg.h>

#define __int8 char
#define __int16 short
#define __int32 int
#define __int64 long long
#define _HAVE_INT64

#define __cdecl
#define __declspec(x) __attribute__((x))
#define __unaligned __attribute__((packed))
#define __fastcall __attribute__((fastcall))

#define __MSVCRT__ 1
#undef _MSVCRT_
#define __MINGW_IMPORT extern __declspec(dllimport)
#define __MINGW_ATTRIB_NORETURN
#define __MINGW_ATTRIB_CONST
#define __MINGW_ATTRIB_DEPRECATED
#define __MINGW_ATTRIB_MALLOC
#define __MINGW_ATTRIB_PURE
#define __MINGW_ATTRIB_NONNULL(arg)
#define __MINGW_NOTHROW
#define __GNUC_VA_LIST

#define _CRTIMP extern
#define __CRT_INLINE extern __inline__

#define _CRT_ALIGN(x) __attribute__((aligned(x)))
#define DECLSPEC_ALIGN(x) __attribute__((aligned(x)))
#define _CRT_PACKING 8
#define __CRT_UNALIGNED
#define _CONST_RETURN

#ifndef _TRUNCATE
#define _TRUNCATE ((size_t)-1)
#endif

#define __CRT_STRINGIZE(_Value) #_Value
#define _CRT_STRINGIZE(_Value) __CRT_STRINGIZE(_Value)
#define __CRT_WIDE(_String) L ## _String
#define _CRT_WIDE(_String) __CRT_WIDE(_String)

#ifdef _WIN64
#define __stdcall
#define _AMD64_ 1
#define __x86_64 1
#define _M_X64 100 /* Visual Studio */
#define _M_AMD64 100 /* Visual Studio */
#define USE_MINGW_SETJMP_TWO_ARGS
#define mingw_getsp tinyc_getbp
#define __TRY__
#else
#define __stdcall __attribute__((__stdcall__))
#define _X86_ 1
#define _M_IX86 300 /* Visual Studio */
#define WIN32 1
#define _USE_32BIT_TIME_T
#ifdef __arm__
#define __TRY__
#else
#define __TRY__ void __try__(void**), *_sehrec[6]; __try__(_sehrec);
#endif
#endif

/* in stddef.h */
#define _SIZE_T_DEFINED
#define _SSIZE_T_DEFINED
#define _PTRDIFF_T_DEFINED
#define _WCHAR_T_DEFINED
#define _UINTPTR_T_DEFINED
#define _INTPTR_T_DEFINED
#define _INTEGRAL_MAX_BITS 64

#ifndef _TIME32_T_DEFINED
#define _TIME32_T_DEFINED
typedef long __time32_t;
#endif

#ifndef _TIME64_T_DEFINED
#define _TIME64_T_DEFINED
typedef long long __time64_t;
#endif

#ifndef _TIME_T_DEFINED
#define _TIME_T_DEFINED
#ifdef _USE_32BIT_TIME_T
typedef __time32_t time_t;
#else
typedef __time64_t time_t;
#endif
#endif

#ifndef _WCTYPE_T_DEFINED
#define _WCTYPE_T_DEFINED
typedef wchar_t wctype_t;
#endif

#ifndef _WINT_T
#define _WINT_T
typedef short wint_t;
#endif

typedef int errno_t;
#define _ERRCODE_DEFINED

typedef struct threadlocaleinfostruct *pthreadlocinfo;
typedef struct threadmbcinfostruct *pthreadmbcinfo;
typedef struct localeinfo_struct _locale_tstruct,*_locale_t;

/* for winapi */
#define _ANONYMOUS_UNION
#define _ANONYMOUS_STRUCT
#define DECLSPEC_NORETURN
#define DECLARE_STDCALL_P(type) __stdcall type
#define NOSERVICE 1
#define NOMCX 1
#define NOIME 1
#define __INTRIN_H_
#ifndef DUMMYUNIONNAME
#  define DUMMYUNIONNAME
#  define DUMMYUNIONNAME1
#  define DUMMYUNIONNAME2
#  define DUMMYUNIONNAME3
#  define DUMMYUNIONNAME4
#  define DUMMYUNIONNAME5
#endif
#ifndef DUMMYSTRUCTNAME
#  define DUMMYSTRUCTNAME
#endif
#ifndef WINVER
# define WINVER 0x0502
#endif
#ifndef _WIN32_WINNT
# define _WIN32_WINNT 0x502
#endif

#define __C89_NAMELESS
#define __MINGW_EXTENSION
#define WINAPI_FAMILY_PARTITION(X) 1
#define MINGW_HAS_SECURE_API

#endif /* __MINGW_H */
=== windowsx.h 55/77 ===
/* Header windowsx.h */

#ifndef $windowsx
#define $windowsx 1

#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))
#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))

#endif // windowsx

=== cc_lib.m 56/77 ===
import msys
import mlib
import clib
import oslib

import cc_decls
import cc_support
import cc_tables
import cc_lex

global int autotypeno=0
int currlineno
global int nextafindex=0

strbuffer exprstrvar
ref strbuffer exprstr=&exprstrvar

const int unitheapsize=50000
ref unitrec unitheapptr=nil
int remainingunits=0

function newstrec:ref strec=
ref strec p
p:=pcm_alloc(strec.bytes)
memset(p,0,strec.bytes)
!clear p^

p^.lineno:=lx.lineno+int(lx.fileno)<<24

p^.attribs.ax_moduleno:=currmoduleno
return p
end

global proc initcclib=

end

global proc printst(filehandle f,ref strec p,int level=0)=	!PRINTST
ref strec q

if p^.symbol<>namesym then
	mcerror("PRINTST not name")
fi

printstrec(f,p,level)

q:=p^.deflist

while q<>nil do
	printst(f,q,level+1)
	q:=q^.nextdef
od
end

proc printstrec(filehandle f,ref strec p,int level)=		!PRINTSTREC
attribrec attrs
ref byte q
strbuffer v
ref strbuffer d:=&v
int col,offset
const tabstr="    "
[256]char str
int scope
ref paramrec pm

gs_init(d)

offset:=0
to level do
	gs_str(d,tabstr)
	offset+:=4
od
gs_str(d,":")

if p^.blockno then
!	sprintf(&.str,"%s.%d",p^.name,int32(p^.blockno))
	print @&.str,p^.name,,".",,p^.blockno

	gs_leftstr(d,&.str,28-offset,'-')
else
	gs_leftstr(d,p^.name,28-offset,'-')
fi
gs_leftstr(d,namenames[p^.nameid],12,'.')
col:=gs_getcol(d)
attrs:=p^.attribs

gs_str(d,"[")

gs_str(d,scopenames[p^.scope])
gs_str(d," ")

if attrs.ax_static then
	gs_str(d,"Stat")
fi
if attrs.ax_align then
	gs_str(d,"@@")
	gs_strint(d,attrs.ax_align)
	gs_str(d," ")
fi
if attrs.ax_varparams then
	gs_str(d,"Var ")
fi
if attrs.ax_used then
	gs_str(d,"Used ")
fi
if attrs.ax_forward then
	gs_str(d,"Fwd ")
fi
if attrs.ax_frame then
	gs_str(d,"Frm ")
fi
if attrs.ax_autovar then
	gs_str(d,"AV ")
fi
if attrs.ax_nparams then
!	sprintf(&.str,"Pm:%d ",int32(attrs.ax_nparams))
	fprint @&.str,"Pm:# ",attrs.ax_nparams

	gs_str(d,&.str)
fi
if attrs.ax_moduleno then
!	sprintf(&.str,"M#%d ",int32(attrs.ax_moduleno))
	fprint @&.str,"M# ",attrs.ax_moduleno
	gs_str(d,&.str)
fi
if attrs.ax_equals then
	gs_str(d,"= ")
fi
gs_str(d,"]")
gs_padto(d,col+10,'=')

if p^.owner then
!	sprintf(&.str,"(%s)",p^.owner^.name)
	fprint @&.str,"(#)",p.owner.name
	gs_leftstr(d,&.str,18,' ')
else
	gs_leftstr(d,"()",18,' ')
fi

case p^.mode
when tvoid then
	gs_str(d,"Void ")
else
	gs_strsp(d,Strmode(p^.mode))
esac

case p^.nameid
when fieldid then
	gs_str(d,"Offset:")
	gs_strint(d,p^.offset)

when frameid,paramid then
	if p^.code then
		gs_str(d,"=")
!CPL =P^.CODE,JTAGNAMES[P^.CODE^.TAG]
!STREXPR(P^.CODE)

		gs_strvar(d,strexpr(p^.code))
	fi
	gs_str(d," Offset: ")
	gs_strint(d,p^.offset)

when procid then

	gs_str(d,"Index:")
	gs_strint(d,p^.index)
	gs_str(d," Address:")
!	sprintf(&.str,"%p",ref void(p^.address))
	print @&.str,ref void(p^.address)
	gs_str(d,&.str)
	if p^.attribs.ax_callback then
		gs_str(d,"<callback fn>")
	fi

when enumid then
	gs_str(d,"Enum:")
	gs_strint(d,p^.index)

when staticid then
	if p^.code then
		gs_str(d,"=")
		gs_strvar(d,strexpr(p^.code))
	fi
	gs_str(d,"STATIC********")
esac

gs_str(d," ")

gs_str(d,"Lineno:")
gs_strint(d,p^.lineno iand 16777215)
gs_str(d," ")
gs_str(d,sourcefilenames[p^.lineno>>24])

if p^.nameid=procid then
	gs_line(d)
	pm:=p^.paramlist
	while pm do
		gs_str(d,"		Param: ")
		gs_leftstr(d,(pm^.def|pm^.def^.name|"Anon"),10,'-')
!		gs_leftstr(d,Strmode(pm^.mode),16, ' ')
		gs_str(d,pmflagnames[pm^.flags])
		gs_str(d," Mode:")
		gs_str(d,strmode(pm.mode))

		gs_line(d)
		pm:=pm^.nextparam
	od
fi

gs_str(d," MODE:")
gs_strint(d,p.mode)

gs_println(d,f)

if p^.code then
	case p^.nameid
	when frameid,staticid then
		printunit(f,p^.code,-3)
	esac
fi

end

global proc printstflat(filehandle f)=
int i
ref strec p
ref tokenrec lx
println @f,"GLOBAL SYMBOL TABLE:"

!RETURN
for i:=0 to hstsize-1 do
!cpl i
!	if hashtable[i].name and hashtable[i].symbol=namesym then
	p:=hashtable^[i]
	if p^.name then
		case p^.symbol
		when namesym then
!CPL P.NAME

!			println @f,i,p,":",p^.name,symbolnames[p^.symbol],namenames[p^.nameid]
			println @f,i,p,":",getstname(p),symbolnames[p^.symbol],namenames[p^.nameid]
			p:=p^.nextdupl
			while p do
				print   @f,"	",p,getstname(p),symbolnames[p^.symbol],namenames[p^.nameid],
					p^.prevdupl
				println @f,"(From",(p^.owner|getstname(p^.owner)|"-"),,")"
				p:=p^.nextdupl
			od
!		else
!			println @f,"not showing",p^.name
		esac
	fi
od
end

global function createname(ref strec p)ref unitrec=
ref unitrec u

u:=allocunitrec()

u^.tag:=j_name
u^.def:=p
u^.simple:=1

return u
end

global function createunit0(int tag)ref unitrec=
ref unitrec u

u:=allocunitrec()
u^.tag:=tag
return u
end

global function createunit1(int tag, ref unitrec p)ref unitrec=
ref unitrec u

u:=allocunitrec()
u^.tag:=tag
u^.a:=p
return u
end

global function createunit2(int tag, ref unitrec p,q)ref unitrec=
ref unitrec u

u:=allocunitrec()

u^.tag:=tag
u^.a:=p
u^.b:=q
return u
end

global function createunit3(int tag, ref unitrec p,q,r)ref unitrec=
ref unitrec u

u:=allocunitrec()
u^.tag:=tag
u^.a:=p
u^.b:=q
u^.c:=r
return u
end

global function createconstunit(word64 a, int t)ref unitrec=
ref unitrec u
u:=allocunitrec()
u^.tag:=j_const
u^.value:=a
u^.mode:=t
u^.simple:=1
return u
end

global function createstringconstunit(ichar s, int length)ref unitrec=
ref unitrec u
u:=allocunitrec()
u^.tag:=j_const
u^.svalue:=s
u^.mode:=trefchar
if length=-1 then
	u^.slength:=strlen(s)
else
	u^.slength:=length
fi
u^.isstrconst:=1
u^.simple:=1
return u
end

global function createwstringconstunit(ref word16 s, int length)ref unitrec=
ref unitrec u
u:=allocunitrec()
u^.tag:=j_const
u^.wsvalue:=s
u^.mode:=trefwchar
!if length=-1 then
!	u^.slength:=strlen(s)
!else
	u^.wslength:=length
!fi
u^.iswstrconst:=1
u^.simple:=1
return u
end

global function getoptocode(int opc)int=		!GETOPTOCODE
!opc is kadd etc
!return matching kaddto, etc
static [0:jtagnames.len]int16 opctotable
int n,opcto,i
[20]char str

opcto:=opctotable[opc]
if opcto then return opcto fi				!find

!assume memoising table not filled in for this opc

strcpy(&.str,jtagnames[opc])					!"add" etc
strcat(&.str,"to")							!"addto" etc

for i:=0 to jtagnames.upb do
	if eqstring(jtagnames[i],&.str) then
		opctotable[opc]:=i
		return i
	fi
od

cpl jtagnames[opc]
serror("Can't find -to version")
return 0
end

global function getconstvalue(ref unitrec p,int ID=0)int64=	!GETCONSTVALUE
!extract value from kconst
if p and p^.tag=j_const then
	return p^.value
fi
serror("GCV Not constant")
return 0
end

global function nextautotype:ichar=
static [32]char str

!sprintf(&.str,"$T%d",int32(++autotypeno))
print @&.str,"$T",,++autotypeno
return &.str
end

global function createconstmode(int m)int=
!create const version of mode m
int newm
if ttconst[m] then return m fi
if ttconsttype[m] then return ttconsttype[m] fi
newm:=copymode(m)
ttconsttype[m]:=newm
ttconst[newm]:=1

ttconsttype[newm]:=m			!use consttype to point back as well as forwards

return newm
end

global function createrefmode(int m)int=
!create ref version of mode m (including when m is already a ref)
int newm

!CPL "CREATEREFTO",STRMODE(M)

if ttreftype[m] then
!CPL "ALREADY EXISTS"

 return ttreftype[m] fi
newm:=createnewmode(tref)
ttreftype[m]:=newm
tttarget[newm]:=m
ttisref[newm]:=1
return newm
end

global function createprocmode(int m, ref paramrec pm)int=
!create proc mode with return type
int newm

newm:=createnewmode(tproc)
ttparams[newm]:=pm
tttarget[newm]:=m
return newm
end

global function createarraymode(int m, length)int=
!create array of mode m (including when m is already a ref)
int newm
!CPL "CREATEARRAYOF", STRMODE(M),LENGTH

!global [0:maxtype]ref strec	ttnamedef
!global [0:maxtype]int	ttbasetype			!basic t-code
!global [0:maxtype]int	ttlength			!0, or array length
!global [0:maxtype]byte	ttconst				!1 when const
!global [0:maxtype]byte	ttrestrict			!1 when restrict used
!global [0:maxtype]byte	ttvolatile			!1 when volatile used
!global [0:maxtype]int	ttusertype			!0, or index of struct/union/enum type
!global [0:maxtype]int	tttarget			!pointer target or array elem type
!global [0:maxtype]int	ttreftype			!0, or index of type that is a pointer to this one
!global [0:maxtype]int	ttconsttype			!0, or index of type that is a const version of this oneointer to this onee
!global [0:maxtype]int	ttsize				!byte size
!global [0:maxtype]int	ttbitwidth			!bit in basic type (not arrays/structs)
!global [0:maxtype]byte	ttisref
!global [0:maxtype]ref paramrec ttparams		!for modes involving function pointers
!global [0:maxtype]ref strec tttypedef

IF NTYPES>10000 THEN CPL =NTYPES FI

for i to ntypes do
	if ttbasetype[i]=tarray and tttarget[i]=m and ttlength[i]=length then
!CPL "ALREADY EXISTS"
		return i
	fi
od


newm:=createnewmode(tarray)
tttarget[newm]:=m
ttlength[newm]:=length
ttsize[newm]:=length*ttsize[m]

return newm
end

global function createenummode(ref strec e)int=
int newm
newm:=createnewmode(tenum)
ttnamedef[newm]:=e

return newm
end

global function createstructmode(ref strec s,int smode)int=
int newm
newm:=createnewmode(smode)
ttnamedef[newm]:=s

return newm
end

global proc setnameptr(ref unitrec p)=		!SETNAMEPTR
!p is a just created j_...def unit which has a nameptr in the .a parameter
!set up an xref from the strec back to the -def unit
!Set up a pointer in the associated strec that points back to q

p^.def^.code:=p
end

global proc printcode_all(filehandle f,ichar caption)=
int i
ref strec p

for i:=1 to nmodules do
	printcode(f,caption,i)
od
end

global proc printcode(filehandle f,ichar caption,int n)=
int i
ref strec p

!CPL "PRINTCODE",F

p:=moduletable[n].stmodule^.deflist

println @f, caption, "MODULE:",moduletable[n].name

while p do
	case p^.nameid
	when procid then
!		if p^.scope<>imported_scope and p^.code then
		if p^.code then
			println @f,p^.name,,"=",scopenames[p^.scope]
			printunit(f,p^.code,,"1")
			println @f
		fi
	esac
	p:=p^.nextdef
od
end

global proc printunit(filehandle dev,ref unitrec p,int level=0,ichar prefix="*")=		!PRINTUNIT
!p is a tagrec
ref unitrec q
ref strec d
int t,n,lincr
ichar idname
ref caserec pc

if p=nil then
	return
fi

if p^.tag>=j_dummy then
	println "print unit: bad tag",p^.tag
!	os_getch()
	stop 30
fi

if p^.lineno then
	currlineno:=p^.lineno
fi

lincr:=1
if level<0 then
	lincr:=-1
!	level:=-level
	print @dev,"             "
fi

!PRINT @DEV,P:"10",," "

print @dev,getprefix(abs(level),prefix,p)
idname:=jtagnames[p^.tag]
if idname^='j' then idname+:=2 fi

print @dev,idname,,": "

case p^.tag
when j_name, j_funcname then
	d:=p^.def

	print @dev,d^.name,namenames[d^.nameid]

	if d^.code then
		print @dev," {",,jtagnames[d^.code^.tag],,"}"
	fi

	print @dev," ",,getdottedname(d)!,q

	if p^.c then
		print @dev," Lastcall:",p^.c
	fi

when j_tempdecl, j_decl, j_goto then

	d:=p^.def
	print @dev,d^.name,namenames[d^.nameid]

	println @dev
	printunit(dev,d^.code,level+lincr,"1")
	return

when j_goto then

	d:=p^.def
	print @dev,d^.name,namenames[d^.nameid]

when j_labelstmt then
	print @dev,p^.def^.name!,"+ LABELED STATEMENT"

when j_casestmt then
	print @dev,"Index:",p^.index

when j_const then
	t:=p^.mode
	if t=trefchar then
		if not p^.isstrconst then
			goto doref
		fi
dostring::
		if p^.slength>256 then
			print @dev,"""",,"(LONGSTR)",""" *",,p^.slength
		else
			print @dev,"""",,p^.svalue,,""" *",,p^.slength
		fi
	elsif t=trefwchar then
		if not p^.iswstrconst then
			goto doref
		fi
		print @dev,"""",,"(WSTRING)",""" *",,p^.wslength
	elsif t>=tschar and t<=tsllong then
		print @dev,p^.value
	elsif t>=tuchar and t<=tullong then
		print @dev,p^.uvalue
	elsif isrealcc(t) then
		print @dev,p^.xvalue
	elsif ttbasetype[t]=tref then
		if p^.isstrconst then
			goto dostring
		fi
doref::
		print @dev,ref void(p^.value)
	elsif ttbasetype[t]=tarray then
		if p^.isstrconst then
			goto dostring
		fi
		serror("PRINTUNIT/CONST/aRRAY")
	else
		cpl typename(t)
		serror("PRINTUNIT BAD CONST")
	fi
	print @dev," ",,Strmode(t)
	if p^.isstrconst then print @dev,"<STRCONST>" fi
	if p^.iswstrconst then print @dev,"<WSTRCONST>" fi

when j_convert then
	print @dev,convnames[p^.opcode]
	print @dev," "
	if p^.convmem then print @dev,"Mem:" fi
	print @dev,typename(p^.a^.mode)
	print @dev," => "
	if p^.convtomem then print @dev,"Mem:" fi
	print @dev,typename(p^.mode)

when j_scale then
	print @dev,"Scale:",p^.scale

when j_addptr,j_subptr then
	print @dev,"Ptrscale:",p^.ptrscale

when j_switch then
	pc:=p^.nextcase
	n:=0
	while pc do ++n; pc:=pc^.nextcase od

	print @dev,p^.nextcase,n

when j_callfn then
	print @dev," Aparams:",p^.aparams

when j_ptr then
!	if p^.memtype then
!		print @dev," Memtype:",Strmode(p^.memtype)
!	fi

when j_dot then
	print @dev," Offset:",p^.offset

esac

!if p^.simple then print @dev," <simple>" fi

if p^.alength then print @dev," ALENGTH=",p^.alength fi

println @dev

printunitlist(dev,p^.a,level+lincr,"1")
printunitlist(dev,p^.b,level+lincr,"2")
if p^.tag<>j_block then					!.c is used to point to last element
	printunitlist(dev,p^.c,level+lincr,"3")
fi
end

proc printunitlist(filehandle dev,ref unitrec p,int level=0,ichar prefix="*")=		!PRINTUNIT
if p=nil then return fi

while p do
	printunit(dev,p,level,prefix)
	p:=p^.nextunit
od
end

function getprefix(int level,ichar prefix,ref unitrec p)ichar=		!GETPREFIX
!combine any lineno info with indent string, return string to be output at start of a line
static [512]char str
[512]char indentstr
ichar modestr
int length

indentstr[1]:=0
if level>10 then level:=10 fi

!strcpy(&.indentstr,"-----------------")
strcpy(&.indentstr,"-----------------------")

modestr:=Strmode(p^.mode,0)
length:=strlen(modestr)
if length<strlen(&.indentstr) then
	memcpy(&.indentstr,modestr,length)
else
	strcpy(&.indentstr,modestr)
fi

to level do
	strcat(&.indentstr,"|---")
!	strcat(&.indentstr,"|------")
od

strcpy(&.str,getlineinfok())
strcat(&.str,&.indentstr)
strcat(&.str,prefix)
if prefix^ then
	strcat(&.str," ")
fi

return &.str
end

global function getdottedname(ref strec p)ichar=		!GETDOTTEDNAME
!build full dotted name for st item p
static [256]char str
[256]char str2
ref strec owner

strcpy(&.str,p^.name)
owner:=p^.owner
while owner and owner^.nameid<>programid do
	strcpy(&.str2,&.str)
	strcpy(&.str,owner^.name)
	strcat(&.str,".")
	strcat(&.str,&.str2)
	owner:=owner^.owner
od
if p^.blockno then
!	sprintf(&.str2,".%d",int32(p^.blockno))
	print @&.str2,".",,p.blockno
	strcat(&.str,&.str2)
fi
return &.str
end

function getlineinfok:ichar=			!GETLINEINFO
static [40]char str

!sprintf(&.str,"%05d ",int32(currlineno))
fprint @&.str,"# ",currlineno:"z5"
return &.str
end

global function getautofieldname:ref strec=
!create auto-field name and return pointer to st entry
[32]char str
ichar name

!sprintf(&.str,"$F%d",int32(++nextafindex))
print @&.str,"$F",,++nextafindex

name:=pcm_copyheapstring(&.str)
return addnamestr(name)
end

global proc convertstring(ichar s, t,int length=-1)=		!CONVERTSTRING
!convert string s, that can contain control characters, into escaped form
!return new string in t, so that ABC"DEF is returned as ABC\"DEF
int c
[20]char str
ichar t0

if length=-1 then
	length:=strlen(s)
fi

t0:=t

to length do
	c:=s++^
	switch c
	when '"' then
		t++^:='\\'
		t++^:='"'
	when '\'' then
		t++^:='\\'
		t++^:='\''
	when 10 then
		t++^:='\\'
		t++^:='n'
	when 13 then
		t++^:='\\'
		t++^:='r'
	when 9 then
		t++^:='\\'
		t++^:='t'
	when '\\' then
		t++^:='\\'
		t++^:='\\'
	when 7 then
		t++^:='\\'
		t++^:='a'
	when 8 then
		t++^:='\\'
		t++^:='b'
	when 12 then
		t++^:='\\'
		t++^:='f'
	when 11 then
		t++^:='\\'
		t++^:='v'
	else
		if c<32 or c>=127 then
!			sprintf(&.str,"\\%03o",int32(c))
			fprint @&.str,"\\#o",c:"z3"
			t++^:=str[1]
			t++^:=str[2]
			t++^:=str[3]
			t++^:=str[4]
		else
			t++^:=c
		fi
	endswitch
od
t^:=0
end

global function strexpr(ref unitrec p)ref strbuffer=		!STREXPR
!vx_makestring("",exprstr)
gs_init(exprstr)

jeval(exprstr,p)
return exprstr
end

proc jeval(ref strbuffer dest, ref unitrec p)=			!JEVAL
!p represents an expression. It can be a unitrec only, not a list (lists only occur inside
!kmakelist and kmakeset units, which specially dealt with here)
!dest is a destination string. Special routines such as gs_additem() are used, which take care
!of separators so that successive alphanumeric items don't touch
ref unitrec q
[16000]char str
int lb,t

!CPL "JEVAL",P,JTAGNAMES[P^.TAG]

case p^.tag
when j_const then
	if (t:=p^.mode)=trefchar then
		if p^.slength=0 then goto doref fi		!might be initialised to something else
		if not p^.isstrconst then goto doref fi		!might be initialised to something else
		if p^.slength>str.len/2 then
			strcpy(&.str,"LONGSTR)")
		else
			convertstring(p^.svalue,&.str)
		fi
		gs_additem(dest,"""")
		gs_additem(dest,&.str)
		gs_additem(dest,"""")
		return
	elsif t>=tschar and t<=tsllong then
!		sprintf(&.str,"%lld",p^.value)
		getstrint(p.value, &.str)

	elsif t>=tuchar and t<=tullong then
!		sprintf(&.str,"%llu",p^.uvalue)
		strcpy(&.str,strword(p.uvalue))

	elsif t=tdouble or t=tfloat then
!		sprintf(&.str,"%f",p^.xvalue)
		strcpy(&.str,strreal(p.xvalue))
	else
		case ttbasetype[p^.mode]
		when tref then
doref::
!			sprintf(&.str,"%p",p^.svalue)
			print @&.str,ref void(p^.svalue)
		when tarray then
			strcpy(&.str,"ARRAY")
		else
			CPL typename(p^.mode)
			nxerror("EVAL/CONST",p)
		esac
	fi
	gs_additem(dest,&.str)

when j_name then
	gs_additem(dest,p^.def^.name)

when j_funcname then
	gs_str(dest,"&")
	gs_additem(dest,p^.def^.name)

when j_andl,j_orl,j_andand,j_eq,j_ne,j_lt,j_le,j_gt,j_ge,j_add,j_sub,j_mul,j_div,
		j_rem,j_iand,j_ior,j_ixor,j_shl,j_shr,
		j_addto,j_subto,j_multo,j_divto,
		j_remto,j_iandto,j_iorto,j_ixorto,j_shlto,j_shrto 	then

	strcpy(&.str,getopcjname(p^.tag))
	gs_additem(dest,"(")
	jeval(dest,p^.a)
	gs_additem(dest,&.str)
	jeval(dest,p^.b)
	gs_additem(dest,")")

when j_neg,j_abs,j_inot,j_notl,j_istruel then

	strcpy(&.str,getopcjname(p^.tag))
!	strcpy(&.str,"getopcjname(p^.tag)")
	gs_additem(dest,&.str)
	gs_additem(dest,"(")
	jeval(dest,p^.a)
	gs_additem(dest,")")

when j_callfn then
	jeval(dest,p^.a)
	gs_additem(dest,"(")

	q:=p^.b
	while q do
		jeval(dest,q)
		q:=q^.nextunit
		if q then gs_additem(dest,",") fi
	od
	gs_additem(dest,")")

when j_dot then
	jeval(dest,p^.a)
	gs_additem(dest,".")
GS_STR(DEST,"???")
!	jeval(dest,p^.b)

when j_idot then
	jeval(dest,p^.a)
	gs_additem(dest,"->")
	jeval(dest,p^.b)

when j_makelist,j_exprlist then
	lb:=p^.tag=j_exprlist
	gs_additem(dest,(lb|"("|"{"))

	q:=p^.a
	while q do
		jeval(dest,q)
		q:=q^.nextunit
		if q then gs_additem(dest,",") fi
	od
	gs_additem(dest,(lb|")"|"}"))

when j_assign then
	jeval(dest,p^.a)
	gs_additem(dest,"=")
	jeval(dest,p^.b)

when j_ifx then
	jeval(dest,p^.a)
	gs_additem(dest,"?")
	jeval(dest,p^.b)
	gs_additem(dest,":")
	jeval(dest,p^.c)

when j_convert then

	gs_additem(dest,Strmode(p^.mode))
	gs_additem(dest,"(")
	jeval(dest,p^.a)
	gs_additem(dest,")")

when j_ptr then
	gs_additem(dest,"*(")
	jeval(dest,p^.a)
	if p^.b then
		gs_additem(dest,"+")
		jeval(dest,p^.b)
	fi
	gs_additem(dest,")")

when j_block then
	gs_additem(dest,"<JBLOCK>")

when j_preincr then
	gs_additem(dest,"++")
	jeval(dest,p^.a)

when j_predecr then
	gs_additem(dest,"--")
	jeval(dest,p^.a)

when j_postincr then
	jeval(dest,p^.a)
	gs_additem(dest,"++")

when j_postdecr then
	jeval(dest,p^.a)
	gs_additem(dest,"--")


when j_null then
	gs_str(dest,"<nullunit>")

when j_scale then
	gs_str(dest,"scale((")
	jeval(dest,p^.a)
	if p^.scale>0 then
		gs_str(dest,")*")
		gs_strint(dest,p^.scale)
	else
		gs_str(dest,")/")
		gs_strint(dest,-p^.scale)
	fi
	gs_str(dest,")")
when j_addptr then
	gs_str(dest,"(")
	jeval(dest,p.a)
	gs_str(dest,"+")
	jeval(dest,p.b)
	gs_str(dest,")")

when j_widenmem then
	jeval(dest,p.a)


else
CPL JTAGNAMES[P.TAG]
gs_str(dest,"<CAN'T DO JEVAL>")
end
end

global function getopcjname(int opc)ichar=		!GETOPCJNAME
!op is a kcode representing an operator
!return the name as it might appear in J code
!caller must check for differences specific to the target
static [20]char str
ichar name,s

name:=jtagnames[opc]
s:=strchr(name,' ')
if s then
	memcpy(&.str,name,s-name)
	str[s-name+1]:=0
	return &.str
else
	return name
fi
end

global function Strmode(int m,expand=1)ichar=		!STRMODE
static [16384]char str

istrmode(m,expand,&.str)

return &.str
end

global function Strmode2(int m,expand=1)ichar=		!STRMODE
static [16384]char str

istrmode(m,expand,&.str)

return &.str
end

global proc istrmode(int m,expand=1,ichar dest)=		!ISTRMODE
ref strec d,q
int value,needcomma,x,i,target,t,n
strbuffer sxx
ref strbuffer xx:=&sxx
ref strbuffer sdim,slength
[100]char strdim,strlength
ref paramrec pm

if m<tlast then
	strcpy(dest,typename(m))
	return
fi

t:=ttbasetype[m]
case t
when tref then
	if ttconst[m] then
		strcpy(dest,"const ref ")
	else
		strcpy(dest,"ref ")
	fi
	target:=tttarget[m]
	if target>=0 and ttbasetype[tttarget[m]]=tstruct then
		strcat(dest,typename(tttarget[m]))
	else
		istrmode(tttarget[m],0,dest+strlen(dest))
	fi
when tarray then
	if ttlength[m] then
!		sprintf(dest,"[%d]",int32(ttlength[m]))
		fprint @dest,"[#]",ttlength[m]
	else
		strcpy(dest,"[]")
	fi
	istrmode(tttarget[m],0,dest+strlen(dest))

when tenum then
	strcpy(dest,"enum ")
	strcat(dest,typename(m))

when tstruct,tunion then
	if not expand then
		strcpy(dest,typename(m))
		return
	fi

	strcpy(dest,typename(ttbasetype[m]))
	strcat(dest,"(")
	d:=ttnamedef[m]
	needcomma:=0

	q:=d^.deflist
	while q do
		if needcomma then strcat(dest,",") fi
		needcomma:=1
		istrmode(q^.mode,0,dest+strlen(dest))
		strcat(dest," ")
		strcat(dest,q^.name)
		q:=q^.nextdef
	od
	strcat(dest,")")

when tvoid then			!must be a usertype that is not defined (as normal voids checked above)
	strcpy(dest,typename(m))

when tproc then
	strcpy(dest,"proc[PM](")
	pm:=ttparams[m]
	n:=pm^.nparams
	for i to n do
		istrmode(pm^.mode,0,dest+strlen(dest))
		if i<>n then
			strcat(dest,",")
		fi
		pm:=pm^.nextparam
	od
	strcat(dest,")")
	istrmode(tttarget[m],0,dest+strlen(dest))

elsif t<tlast then
	strcpy(dest,typename(m))
	return
else
CPL typename(m)
	mcerror("NEWSTRMODE")
esac
end

global function countunits(ref unitrec p)int=
int n
n:=0
while p do
	++n
	p:=p^.nextunit
od
return n
end

proc purgesymbol(ref strec p,prev,int del)=
!unlink and (when del=1) recover memory from st entry p
!p is removed from deflist chain of its owner, and from the dupllist chain
!prev is nil when p is the first entry in its owner's deflist, or points
!to the previous still existing entry in the chain. It is necessary so that
!the .nextdef link can be maintained, of either prev or owner
ref strec q

case p^.nameid
when fieldid then			!needed for genfieldtables
	return
esac

!Unlink child symbols
purgesymbollist(p^.deflist,0,del)

!unlink from deflist and continue deflist around it
if prev then
	prev^.nextdef:=p^.nextdef
else
	p^.owner^.deflist:=p^.nextdef
fi

!now need to unlink from dupllist. Here, the .prevdupl field will always
!be valid, pointing to the generic entry if necessary (that can't be unlinked
!here)

q:=p^.prevdupl
q^.nextdupl:=p^.nextdupl

!Now delete the entry
if del then
	pcm_free(p,strec.bytes)
fi
end

global proc purgesymbollist(ref strec p,int ismodule, del)=
!scan the list in p (the deflist of an owner symbol)
!and unlink a symbol when ismodule is 0 or it's not global
!when del=1, then also recover the memory used
!ismodule should be 1 for a module, then the global flag is checked

ref strec q,prev

serror("PURGESYMBOL")

end

global proc purgeprocs(ref strec p, int del)=
!scan procs in the list p, and remove frame vars

while p do
	if p^.nameid=procid then
		purgeproc(p,del)
	fi
	p:=p^.nextdef
od
end

global proc purgeproc(ref strec p, int del)=
!scan procs in the list p, and remove frame vars
ref strec q,prev,r

!NOTE: THIS CAN'T BE USED AT THE MINUTE, AS THE STRECS COMPRISING THE
!FRAME VARS CONTAIN FRAME OFFSETS NEEDED BY THE CODE GENERATOR.
!POSSIBLY, ENTRIES CAN BE UNLINKED INSTEAD, BUT CAN STILL BE POINTED
!TO BY REFERENCES WITHIN THE BYTE-CODE 

q:=p^.deflist
prev:=nil
while q do
	r:=q^.nextdef
	if q^.nameid=frameid then
		purgesymbol(q,prev,del)
	else
		prev:=q
	fi
	q:=r
od
end

global proc printmodelist(filehandle f)=		!PRINTMODELIST
const wtypeno	= 4
const wname		= 13
const wbasetype	= 13
const wbitsize	= 3
const wtarget	= 14
const wlength	= 4
const wsize		= 5
const wconst	= 3
const wrest		= 3
const wvolatile	= 3
const wused		= 3
const wconsttype= 5
const wreftype	= 5
const wnamedef	= 8
const wmode		= 32
[256]char str
ichar mstr
strbuffer destv
ref strbuffer dest := &destv
int m

println @f,"MODELIST",ntypes

gs_init(dest)

gs_leftstr(dest,"#",wtypeno)
gs_leftstr(dest,"Name",wname)
gs_leftstr(dest,"Base",wbasetype)
gs_leftstr(dest,"Bit",wbitsize)
gs_leftstr(dest,"Target",wtarget)
gs_leftstr(dest,"Len",wlength)
gs_leftstr(dest,"Size",wsize)
gs_leftstr(dest,"C",wconst)
gs_leftstr(dest,"R",wrest)
gs_leftstr(dest,"V",wvolatile)
gs_leftstr(dest,"@Cnst",wconsttype)
gs_leftstr(dest,"@Ref",wreftype)
gs_leftstr(dest,"Tag",wnamedef)
gs_leftstr(dest,"Mode",wmode)
gs_println(dest,f)


for m:=0 to ntypes do
	gs_init(dest)
	gs_leftint(dest,m,wtypeno)
	gs_leftstr(dest,typename(m),wname)
	gs_leftstr(dest,typename(ttbasetype[m]),wbasetype)
	gs_leftint(dest,ttbitwidth[m],wbitsize)

	if tttarget[m] then
		gs_leftint(dest,tttarget[m],3)
		gs_leftstr(dest,typename(tttarget[m]),wtarget-3)
	else
		gs_leftstr(dest,"-",wtarget)
	fi

	case ttbasetype[m]
	when tarray,tstruct,tunion then
		gs_leftint(dest,ttlength[m],wlength)
	else
		gs_leftstr(dest,"",wlength)
	esac

	gs_leftint(dest,ttsize[m],wsize)
	gs_leftint(dest,ttconst[m],wconst)
	gs_leftint(dest,ttrestrict[m],wrest)
	gs_leftint(dest,ttvolatile[m],wvolatile)

	gs_leftint(dest,ttconsttype[m],wconsttype)
	gs_leftint(dest,ttreftype[m],wreftype)

	if ttnamedef[m] then
		gs_leftstr(dest,ttnamedef[m]^.name,wnamedef)
	else
		gs_leftstr(dest,"-",wnamedef)
	fi

	mstr:=Strmode(m)
	if strlen(mstr)<16 then
		gs_str(dest,mstr)
	else
		gs_println(dest,f)
		gs_init(dest)
		gs_str(dest,"		")
		gs_str(dest,mstr)
	fi
	gs_println(dest,f)
od

println @f
end

global function typename(int m)ichar=
int basem
static [300]char str

basem:=ttbasetype[m]
case basem
when tstruct,tunion then
	strcpy(&.str,(basem=tstruct|"struct "|"union "))
	if ttnamedef[m] then
		strcat(&.str,ttnamedef[m]^.name)
	fi
	return &.str
when tarray then
	return "<array>"
when tenum then
	if ttnamedef[m] then
		return ttnamedef[m]^.name
	fi
	return "<enum>"
else
	if ttconst[m] then
		strcpy(&.str,"const ")
		strcat(&.str,stdtypenames[basem])
		return &.str
	fi
	return stdtypenames[basem]
esac
return ""
end

global function allocunitrec:ref unitrec=
ref unitrec p
ref int64 q
int nwords

if remainingunits-- then
	p:=unitheapptr
	++unitheapptr
	p^.lineno:=lx.lineno

	if lx.fileno<=255 then
		p^.fileno:=lx.fileno
	fi
	return p
fi

!need first or new heap
p:=unitheapptr:=pcm_alloc(unitheapsize*unitrec.bytes)

memset(p,0,unitheapsize*unitrec.bytes)
remainingunits:=unitheapsize-1
++unitheapptr
p^.lineno:=lx.lineno
if lx.fileno<=255 then
	p^.fileno:=lx.fileno
fi
return p
end

function copymode(int m)int=
if ntypes>=maxtype then
	serror("Too many types")
fi
++ntypes

!copy fields that won't already be zero
ttnamedef[ntypes]:=ttnamedef[m]
ttbasetype[ntypes]:=ttbasetype[m]
ttlength[ntypes]:=ttlength[m]
ttconst[ntypes]:=ttconst[m]
ttrestrict[ntypes]:=ttrestrict[m]
ttvolatile[ntypes]:=ttvolatile[m]
ttusertype[ntypes]:=ttusertype[m]
ttsize[ntypes]:=ttsize[m]
ttbitwidth[ntypes]:=ttbitwidth[m]
tttarget[ntypes]:=tttarget[m]
ttparams[ntypes]:=ttparams[m]
ttisref[ntypes]:=ttisref[m]

return ntypes
end

function createnewmode(int m)int=
!create new type unitialised except for given basetype m

!CPL "CNM",STRMODE(M),M

if ntypes>=maxtype then
CPL =STRMODE(M)
	serror("Too many types/cnm")
fi
++ntypes

!leave length, const etc all zero
!copy basic size info from basetype

ttbasetype[ntypes]:=m
ttsize[ntypes]:=ttsize[m]
ttbitwidth[ntypes]:=ttbitwidth[m]

return ntypes
end

global proc addlistunit(ref ref unitrec ulist,ulistx,ref unitrec p)=
!add strec p to end of linked list headed by ulist^. ulistx^ is current end of list
if ulist^=nil then		!first
	ulist^:=ulistx^:=p
else
	ulistx^^.nextunit:=p
fi
p^.nextunit:=nil

ulistx^:=p			!update end-of-list pointer
end

global proc addlistdef(ref ref strec ulist,ulistx,ref strec p)=
!add strec p to end of linked list headed by ulist^. ulistx^ is current end of list
if ulist^=nil then		!first
	ulist^:=ulistx^:=p
else
	ulistx^^.nextdef:=p
fi
p^.nextdef:=nil

ulistx^:=p			!update end-of-list pointer
end

global proc addlistparam(ref ref paramrec ulist,ulistx,ref paramrec p)=
!add paramrec p to end of linked list headed by ulist^. ulistx^ is current end of list
if ulist^=nil then		!first
	ulist^:=ulistx^:=p
else
	ulistx^^.nextparam:=p
fi
p^.nextparam:=nil

ulistx^:=p			!update end-of-list pointer
end

global proc checksymbol(int symbol)=
[256]char str

if lx.symbol<>symbol then
!	sprintf(&.str,"%s expected, not %s",symbolnames[symbol],symbolnames[lx.symbol])
	fprint @&.str,"# expected, not #",symbolnames[symbol],symbolnames[lx.symbol]

if lx.symbol=namesym then
	strcat(&.str," \"")
	strcat(&.str,getstname(lx.symptr))
	strcat(&.str,"\"")
fi
!	serror(symbolnames[symbol]+" expected, not "+symbolnames[lx.symbol])
	serror(&.str)
fi
end

global proc skipsymbol(int symbol)=
if lx.symbol<>symbol then checksymbol(symbol) fi
lex()
end

global proc inittypetables=
int i,j,size,bitsize,s,t,u

!Initialise type tt-tables from std types first all fields initially zero

for i:=0 to tlast-1 do
	ttbasetype[i]:=i

	bitsize:=stdtypewidths[i]
	size:=bitsize/8

	ttsize[i]:=size
	ttbitwidth[i]:=bitsize

od
ntypes:=tlast-1

!trefchar:=createrefmode(tuchar)
!trefwchar:=createrefmode(tushort)

trefchar:=createrefmode(tschar)

!trefwchar:=createrefmode(tsshort)
trefwchar:=createrefmode(tushort)

!do dominant table
for i:=1 to dominantsetuptable.len do
	s:=dominantsetuptable[i,1]
	t:=dominantsetuptable[i,2]
	u:=dominantsetuptable[i,3]
	dominantmode[s,t]:=u
od

!do conversion table
for i:=1 to convsetuptable.len do
	s:=convsetuptable[i,1]
	t:=convsetuptable[i,2]
	u:=convsetuptable[i,3]
	conversionops[s,t]:=u
od
ntypesreset:=ntypes
end

global function createdupldef(ref strec owner,symptr, int id)ref strec=
!create new proc entry
!symptr is the generic st entry for proc's name
ref strec p,q

p:=newstrec()

p^.name:=symptr^.name
p^.namelen:=symptr^.namelen
p^.symbol:=namesym
p^.owner:=owner
p^.nameid:=id
p^.namespace:=namespaces[id]
if q:=symptr^.nextdupl then			!1st in dupl list
	q^.prevdupl:=p
fi
p^.nextdupl:=q
p^.prevdupl:=symptr
symptr^.nextdupl:=p

if owner then
	if owner^.deflist=nil then			!first def
		owner^.deflist:=owner^.deflistx:=p
	else
		owner^.deflistx^.nextdef:=p
		owner^.deflistx:=p
	fi
fi

return p
end

global function createnewmoduledef(ref strec owner,symptr)ref strec=
ref strec p,q

p:=createdupldef(owner,symptr,moduleid)
return p
end

global function createnewproc(ref strec owner,symptr)ref strec=
!create new proc entry
!symptr is the generic st entry for proc's name
ref strec p,q

p:=createdupldef(owner,symptr,procid)

q:=p
while q:=q^.nextdupl do
	if q^.owner=owner then
		cpl q^.name,"in",owner^.name
		serror("Dupl proc name")
	fi
!	q:=q^.nextdupl
od

return p
end

global function resolvename(ref strec owner, symptr, int ns, blockno)ref strec=
!symptr is a generic st entry for a name
!owner is the st entry where the name has been encountered (the current
! module, or a function)
!ns is code of the namespace that is being searched
!blockno is zero, if searched at file scope, or non-zero if searching
!from inside a function. Then, it will be the current block number
!where the name has been encountered
!Search the symbol table (usually the dupl list for symptr) for
!any instance of the name which matches in owner, matches the
!namespace, and is within the blockno hierarchy
!return symptr of the st entry when resolved, or nil if not resolved
int nsblock
ref strec d

if symptr^.nameid>macroid then
	return symptr
fi

if ns=ns_labels then
	return resolvelabel(owner,symptr)
fi

if blockno and blockcounts[blockno]=0 then blockno:=blockowner[blockno] fi

do							!loop for each block level
	nsblock:=ns<<16 ior blockno
	d:=symptr				!reset dupl list
	while d:=d^.nextdupl do
		if owner.nameid=procid  and d.owner<>owner and d.owner.nameid=procid then
			exit
		fi
		if d^.owner=owner and d^.nsblock=nsblock then
			return d
		fi
	od

	if blockno=0 then
		case owner^.nameid
		when procid then			!was in function, now search filescope
				!(THIS MIGHT BE NEEDED FOR PARAM-SCOPES where block number is zero)
			owner:=stmodule
			redo
		when structtagid then		!was in struct; now try owner (proc/module/other struct)
			owner:=owner^.owner
			if owner=nil then		!not sure if possible, but just in case...
				return nil
			fi
		else
			return nil
		esac
	elsif (blockno:=blockowner[blockno])=0 then		!try next block level
		owner:=stmodule				!block 0 means outside outer block, so switch to module scope
	fi

od

return nil
end

global function resolvelabel(ref strec owner, symptr)ref strec=
	ref strec d
	d:=symptr				!reset dupl list
	while d:=d^.nextdupl do
		if owner.nameid=procid  and d.owner<>owner and d.owner.nameid=procid then
			exit
		fi

		if d^.owner=owner and d.namespace=ns_labels then
			return d
		fi
	od

	return nil
end

global function checkdupl(ref strec owner, symptr, int ns, blockno)ref strec=
!Same params as resolvename.
!But here, search only current scope level to see if something of the
!same name, and in the same namespace, already exists
!Returns nil, if such a name was not found, or a symptr to it
!A returned symbol might be of a different nameid, but that would
!be an error usually as you can't have two identical names in the same namespace.
!Some kinds of names can have repeated declarations in the same scope
int nsblock
ref strec d

d:=symptr

nsblock:=ns<<16 ior blockno

while d:=d^.nextdupl do
	if d^.owner=owner and d^.nsblock=nsblock then
		return d
	fi
od

return nil
end

global function checkdupl_inproc(ref strec owner, symptr, int ns, blockno)ref strec=
!special version of checkdupl
!assumes that dupl list starts at last proc

int nsblock
ref strec d

d:=symptr

nsblock:=ns<<16 ior blockno

while (d:=d^.nextdupl) and d^.owner=owner do
	if d^.nsblock=nsblock then
		return d
	fi
od

return nil
end

global function getalignment(int m)int=
!return alignment needed for type m, as 1,2,4,8
int a

case ttbasetype[m]
when tarray then
	return getalignment(tttarget[m])
when tstruct,tunion then
	a:=ttnamedef[m]^.attribs.ax_align
	if a=0 then
!		CPL("GETALIGN 0")
		RETURN 16
!		SERROR("GETALIGN 0")
	fi
	return a
esac

a:=ttsize[m]
case a
when 1,2,4,8 then
	return a
esac
cpl Strmode(m),A
serror("GETALIGN SIZE NOT 1248")

return 0
end

global function isexported(ref strec d)int=
if d^.nameid=procid then
	if d^.code and (d^.scope=imported_scope or d^.scope=exported_scope) then
		return 1
	fi
else
	if d^.scope=exported_scope then
		return 1
	fi
fi
return 0
end

global function isimported(ref strec d)int=
if d^.nameid=procid then
	if d^.code=nil and (d^.scope=imported_scope or d^.scope=exported_scope) then
		return 1
	fi
else
	if d^.scope=imported_scope then
		return 1
	fi
fi
return 0
end

global function isstructunion(int m)int=
case ttbasetype[m]
when tstruct,tunion then
	case ttsize[m]
	when 1,2,4,8 then
	else
	 return 1
	esac
esac
return 0
end

global function getstname(ref strec d)ichar=
static [256]char name
memcpy(&.name,d^.name,d^.namelen)
name[d^.namelen+1]:=0
return &.name
end

global function isrealcc(int m)int=
m:=ttbasetype[m]
return tfirstreal<=m<=tlastreal
!return tfirstreal<=m and m<=tlastreal
end

global function isintcc(int m)int=
m:=ttbasetype[m]
return tfirstint<=m<=tlastint
!return tfirstint<=m and m<=tlastint
end
=== cc_parse.m 57/77 ===
!Parse C Code

import mlib
import clib
import oslib

import cc_decls
import cc_support
import cc_tables

import cc_lex
import cc_lib

!const needcompoundblock=1
const needcompoundblock=0

ref strec ist_symptr

INT INSIDEFOR
INT INTYPEOF

const maxtypemods=32
[maxnestedloops]byte looptypestack		!contains either 'L' or 'S' (loop or switch)
int loopindex							!current level of nested loop/switch blocks
[maxnestedloops]ref caserec casevaluestack		!linked list of case values for current switch

byte iscallbackfnx
byte constantseen=0
byte ingeneric=0

REF STREC CURRFNNAME


proc readmodule=
int linkage,m,mbase,commaseen,wasdef
unit p
ref strec d
ref paramrec pm
int t,nitems,wasenum

while lx.symbol<>eofsym do
	nitems:=0
	case lx.symbol
	when kshowtypesym then
		lex()
		t:=readcasttype(d,0,pm)
		skipsymbol(semisym)
		println "Type is:",Strmode(t)
		next
	when kmccassertsym then
		nitems:=1
	when semisym then
		serror("Extra semicolon 2")
	esac
	wasenum:=lx.symbol

	if lx.symbol=kmccassertsym then nitems:=1 fi

	mbase:=readdeclspec(stmodule,linkage)
	commaseen:=0

	docase lx.symbol
	when namesym, mulsym, lbracksym then
		++nitems

		m:=readtype(stmodule,d,mbase,pm)

		if d=nil then
			serror("Var name expected")
		fi

		if linkage=typedef_ss then
			if pm then
				m:=createprocmode(m,pm)
			fi
			d:=createtypedef(stmodule,d,m)
			constantseen:=0
		elsif pm then
readfn::
			if lx.symbol=lcurlysym and commaseen then serror("fn def after comma") fi

			d:=readfunction(d,m,linkage,pm,wasdef)
			if wasdef then exit fi			!can't have comma-separate fn defs

		elsif ttbasetype[m]=tproc then
			pm:=ttparams[m]
			m:=tttarget[m]
			constantseen:=0
			goto readfn

		else
			d:=readmodulevar(d,m,linkage)
			constantseen:=0
		fi

		case lx.symbol
		when commasym then			!read next item
			commaseen:=1
			lex()
		else
			skipsymbol(semisym)
			exit
		esac
	when kconstantsym then
		constantseen:=1
		lex()
		next 2
	when kstructinfosym then
		readstructinfosym()
	else
		case ttbasetype[mbase]
		when tenum, tstruct, tunion then		!assume defining a [part]type only
			skipsymbol(semisym)
			exit
		when tsint then				!allow for now, as it migt be an enum decl with no name
			skipsymbol(semisym)
			exit
		else
			serror_s("Decl error %s",typename(mbase))
		esac
	enddocase

	if nitems=0 and fmodern then
		case ttbasetype[mbase]
		when tstruct,tunion,tenum then
		else
			if wasenum<>kenumsym then
				CPL =STRMODE(MBASE)
				serror("Empty declaration")
			fi
		esac
	fi

od
end

global function parsemodule(int n)int=
int size,t
ref strec owner
real tsecs

loopindex:=iscallbackfnx:=constantseen:=ingeneric:=0
ist_symptr:=nil
memset(&casevaluestack,0,casevaluestack.bytes)
!clear casevaluestack

startlex("PARSETEST",moduletable[n].fileno)
owner:=stmodule
currproc:=nil
loopindex:=0

lex()

!while lx.symbol<>eofsym do
!	lex()
!od
!RETURN 1

readmodule()

endlex()
return 1
end

function readdeclspec(ref strec owner,int &linkage)int=
!At first symbol of a declspec, or possible declspec
!read declspec and basetype
!return typecode for basetype, and linkage (static etc)
!if no declspec follows (usually eof) returns 0

record declrec=
	int32 typeno				!not set, int, float, char, struct, union, enum etc
	byte isconst				!0, or 1 when const used (more than 1 allowed)
	byte isvolatile				!0, or 1 when volatile used
	byte isrestrict
	byte linkage				!0, or static_ss etc; only one allowed
	byte isinline				!1 when inline used
	byte isshort				!1 when short used
	byte islong					!1 when long used (not short or long long)
	byte isllong				!1 when long long used (islong set to 0)
	byte issigned				!not set, signed
	byte isunsigned				!not set, unsigned
	byte isusertype				!1 if basetype set completely from typedef
								!so isshort/long etc or other basetype not allowed
!	byte iscallback				!1 if $callback fnspec used
end
declrec d
unit p
int t,mod,m,fstruct
ref paramrec pm
ref strec e

memset(&d,0,d.bytes)
!clear d
fstruct:=mod:=0

doswitch lx.symbol
when ktypespecsym then
	switch lx.subcode
	when ts_int, ts_char, ts_float, ts_double, ts_bool, ts_void then
		if d.typeno then
			if fstruct then checksymbol(semisym)
			else goto tserror
			fi
		fi
		d.typeno:=typespectypes[lx.subcode]

	when ts_short then
		if d.isshort or d.islong or d.isllong then goto tserror fi
		d.isshort:=mod:=1
	when ts_long then
		if d.isllong or d.isshort then goto tserror
		elsif d.islong then
			d.islong:=0
			d.isllong:=1
		else
			d.islong:=1
		fi
		mod:=1

	when ts_signed then
		if d.issigned or d.isunsigned then goto tserror fi
		d.issigned:=mod:=1
	when ts_unsigned then
		if d.issigned or d.isunsigned then goto tserror fi
		d.isunsigned:=mod:=1
	when ts_complex then
		if d.typeno and d.typeno<>tfloat and d.typeno<>tdouble then
			goto tserror
		fi
		d.typeno:=tcomplex
	else

tserror::
		serror_s("declspec/ts %s",typespecnames[lx.subcode])
	endswitch
	lex()

when ktypequalsym then
	case lx.subcode
	when const_qual then
		d.isconst:=1
	when volatile_qual then d.isvolatile:=1
	when restrict_qual then d.isrestrict:=1
	esac
	lex()

when klinkagesym then
	if d.linkage then serror("Dual storage spec") fi
	d.linkage:=lx.subcode
	lex()

when kfnspecsym then
	case lx.subcode
	when inline_fnspec then
		d.isinline:=1
	when callback_fnspec then
		callbackflag:=1
!		d.iscallback:=1
	esac
	lex()
when kstructsym,kunionsym then
	if d.typeno then serror("struct?") fi
	d.typeno:=readstructdecl(owner)
	d.isusertype:=1
	fstruct:=1

when kenumsym then
	if d.typeno then serror("enum?") fi
!	d.typeno:=readenumdecl(owner)
	readenumdecl(owner)
	d.typeno:=tsint			!disregard enum 'type'; just use int
	d.isusertype:=1

when namesym then			!should resolve to see if a user-type ...
							! ... unless a basetype already seen
	if not d.typeno and (m:=isusertype(owner)) then
		if mod then			!unsigned etc without proper base type; assume name is not part o it
			d.typeno:=tsint
			exit
		fi
!		if mod then serror("Can't mod usertype") fi
		d.typeno:=m
		d.isusertype:=1
		lex()
	else
		if d.typeno=0 and not mod then
			serror_s("Implicit decls not allowed: %s",lx.symptr^.name)
		fi

		if d.typeno=0 then d.typeno:=tsint fi
		exit
	fi

when ktypeofsym then
	lex()
	skipsymbol(lbracksym)
	intypeof:=1
	p:=readterm()
	intypeof:=0
	skipsymbol(rbracksym)
	if d.typeno or mod then serror("typeof") fi
	d.typeno:=p.def.mode

when kmccassertsym then
	dostaticassert()
else
	exit
end doswitch

t:=(d.typeno|d.typeno|tsint)

if not d.isusertype then				!otherwise everything should be set up
	case t
	when tsint then
		if d.isshort then
			t:=(d.isunsigned|tushort|tsshort)
		elsif d.islong then
			if wintarget then
				t:=(d.isunsigned|tuint|tsint)
			else
				t:=(d.isunsigned|tullong|tsllong)
			fi
		elsif d.isllong then
			t:=(d.isunsigned|tullong|tsllong)
		elsif d.isunsigned then
			t:=tuint
		fi
!	when tuchar then
	when tschar then
		if d.isshort or d.islong or d.isllong then serror("char decl?") fi
!		t:=(d.issigned|tschar|tuchar)
		t:=(d.isunsigned|tuchar|tschar)
	when tdouble then
		if d.isshort or d.isllong or d.issigned or d.isunsigned then serror("dbl decl?") fi
!long double not supported; just use double
!		t:=tldouble
	when tcomplex then
		if d.isshort or d.isllong or d.issigned or d.isunsigned then serror("Complex?") fi

	else
		if mod then serror("declspec/float") fi
	esac
fi

if d.isconst then
	t:=createconstmode(t)
fi

linkage:=d.linkage
return t
end

function istypestarter:int=
!return 1 when current symbol could start a type-spec
ref strec d

switch lx.symbol
when ktypespecsym then
	return 1
when ktypequalsym then
!	return lx.subcode=const_qual
	return 1
when namesym then
	d:=resolvename((currproc|currproc|stmodule),lx.symptr,ns_general,currblockno)
	if d then
		lx.symptr:=d
		return d^.nameid=typeid
	fi
when kstructsym,kunionsym,kenumsym then
	return 1
endswitch
return 0

end

function istypestarter_next:int=
!return 1 when current symbol could start a type-spec
ref strec d

switch nextlx.symbol
when ktypespecsym then
	return 1
when ktypequalsym then
!	return lx.subcode=const_qual
	return 1
when namesym then
	d:=resolvename((currproc|currproc|stmodule),nextlx.symptr,ns_general,currblockno)
	if d then
		nextlx.symptr:=d
		return d^.nameid=typeid
	fi
when kstructsym,kunionsym,kenumsym then
	return 1
endswitch
return 0

end

function readexpression:unit=
unit p, ulist, ulistx
int t

case nextlx.symbol
when  semisym,rbracksym then
	return readterm()
esac

p:=readassignexpr()

if lx.symbol=commasym then		!
	ulist:=ulistx:=nil
	do
		addlistunit(&ulist,&ulistx,p)
		exit when lx.symbol<>commasym
		lex()
		p:=readassignexpr()
	od
	p:=createunit1(j_exprlist,ulist)
	if ulistx then
		p^.mode:=ulistx^.mode
	fi

	return p
fi
return p
end

function readassignexpr:unit=
unit p,q,r
int opc,oldpmode

case nextlx.symbol
when commasym, semisym,rbracksym then
	return readterm()
when assignsym then
	p:=readterm()
	opc:=lx.symbol
	goto gotp
esac

p:=readcondexpr()

switch opc:=lx.symbol
when assignsym, multosym, divtosym, remtosym, addtosym, subtosym,
		shltosym, shrtosym, iandtosym, ixortosym, iortosym then
gotp::
	lex()
	oldpmode:=p^.mode
	checklvalue(p)
	q:=readassignexpr()
	if ttisref[p^.mode] then
		return createassignopref(opc,p,q)
	fi

	q:=coercemode(q,oldpmode)
	if ttconst[oldpmode] then
		terror("Modifying read-only var")
	fi

	if q^.tag=j_convert and opc=assignsym then
		q^.convtomem:=1
	fi

	if p^.tag=j_ptr and p^.a^.tag=j_const then
		terror("Modifying constant?")
	fi


	r:=createunit2(symboltojtag[opc],p,q)

	r^.mode:=oldpmode
	return r
endswitch

return p
end

function readcondexpr:unit=
unit x,y,pcond
int s,t,u

pcond:=readorlexpr()

if lx.symbol=questionsym then
	coercecond(pcond)

	lex()
	x:=readexpression()
	skipsymbol(colonsym)
	y:=readcondexpr()

	if u:=dominantmode[s:=ttbasetype[x^.mode],t:=ttbasetype[y^.mode]] then			!were both numeric
		x:=coercemode(x,u)
		y:=coercemode(y,u)
		if pcond^.tag=j_const and x^.tag=j_const and y^.tag=j_const then
			return (pcond^.value|x|y)
		fi

	elsif s=tref and t=tref then
		u:=x^.mode
	elsif s=tref and t=tsint and y^.tag=j_const and y^.value=0 then
		u:=x^.mode
		coercemode(y,u)
	elsif s=tsint and t=tref and x^.tag=j_const and x^.value=0 then
		u:=y^.mode
		coercemode(x,u)
	elsif s=tstruct and t=tstruct then
		u:=x^.mode
	elsif s=tunion and t=tunion then
		u:=x^.mode
	elsif s=t=tvoid then
		u:=tvoid
	else
CPL Strmode(x^.mode),Strmode(y^.mode)
		terror("?: incompatible types")
	fi

	pcond:=createunit3(j_ifx,pcond,x,y)
	pcond^.mode:=u
fi

return pcond
end

function readorlexpr:unit=
unit x,y

x:=readandlexpr()

while lx.symbol=orlsym do
	lex()
	y:=readandlexpr()
	coercecond(x)
	coercecond(y)

	if x^.tag=j_const and y^.tag=j_const then
		x^.value := (x^.value or y^.value|1|0)
		next
	fi
	x:=createunit2(j_orl,x,y)
	x^.mode:=tsint
od

return x
end

function readandlexpr:unit=
unit x,y

x:=readiorexpr()

while lx.symbol=andlsym do
	lex()
	y:=readiorexpr()
	coercecond(x)
	coercecond(y)

	if x^.tag=j_const and y^.tag=j_const then
		x^.value := (x^.value and y^.value|1|0)
		next
	fi
	x:=createunit2(j_andl,x,y)
	x^.mode:=tsint
od

return x
end

function readiorexpr:unit=
unit x,y
int u

x:=readixorexpr()

while lx.symbol=iorsym do
	lex()
	y:=readixorexpr()

	if u:=dominantmode[ttbasetype[x^.mode],ttbasetype[y^.mode]] then			!were both numeric
		if u>=tfloat then terror("float|float") fi
		x:=coercemode(x,u)
		y:=coercemode(y,u)
	else
		terror("invalid | operands")
	fi

	if x^.tag=j_const and y^.tag=j_const then
		case u
		when tsint,tsllong,tuint,tullong then
			x^.value ior:= y^.value
			next
		esac
	fi
	x:=createunit2(j_ior,x,y)
	x^.mode:=u
od

return x
end

function readixorexpr:unit=
unit x,y
int u

x:=readiandexpr()

while lx.symbol=ixorsym do
	lex()
	y:=readiandexpr()

	if u:=dominantmode[ttbasetype[x^.mode],ttbasetype[y^.mode]] then			!were both numeric
		if u>=tfloat then terror("float^float") fi
		x:=coercemode(x,u)
		y:=coercemode(y,u)
	else
		terror("invalid ^ operands")
	fi

	if x^.tag=j_const and y^.tag=j_const then
		case u
!		when tsint,tsllong then
		when tsint,tsllong,tuint,tullong then
			x^.value ixor:= y^.value
			next
		esac
	fi
	x:=createunit2(j_ixor,x,y)
	x^.mode:=u
od

return x
end

function readiandexpr:unit=
unit x,y
int u

x:=readeqexpr()

while lx.symbol=iandsym do
	lex()
	y:=readeqexpr()

	if u:=dominantmode[ttbasetype[x^.mode],ttbasetype[y^.mode]] then			!were both numeric
		if u>=tfloat then terror("float&float") fi
		x:=coercemode(x,u)
		y:=coercemode(y,u)
	else
		cpl Strmode(x^.mode)
		cpl Strmode(y^.mode)
		terror("invalid & operands")
	fi

	if x^.tag=j_const and y^.tag=j_const then
		case u
		when tsint,tsllong,tuint,tullong then
			x^.value iand:= y^.value
			next
		esac
	fi
	x:=createunit2(j_iand,x,y)
	x^.mode:=u
od

return x
end

function readeqexpr:unit=
unit x,y
int opc,s,t,u,ss,tt

x:=readrelexpr()

while (opc:=lx.symbol)=eqsym or opc=nesym do
	lex()
	y:=readrelexpr()

	if u:=dominantmode[s:=ttbasetype[x^.mode],t:=ttbasetype[y^.mode]] then			!were both numeric
		x:=coercemode(x,u)
		y:=coercemode(y,u)
	elsif s=tref and t=tref then
		if (ss:=tttarget[x^.mode])<>(tt:=tttarget[y^.mode]) then
			if ss<>tvoid and tt<>tvoid then
				if not checkpointertypes(x^.mode,y^.mode,1) then	!'hard'
!				if ttbasetype[ss]=tproc and ttbasetype[tt]=tproc then
!				elsif ttbasetype[ss]=tstruct and ttbasetype[tt]=tstruct then
!				else
					terror("Comparing distinct pointers/eq")
				fi
			fi
		fi
	elsif s=tref and t=tsint then
		if y^.tag<>j_const or y^.value<>0 then
			terror("Can't compare pointer to int")
		fi
	elsif s=tsint and t=tref then
		if x^.tag<>j_const or x^.value<>0 then
			terror("Can't compare pointer to int2")
		fi
	else
		terror("invalid == operands")
	fi

	if x^.tag=j_const and y^.tag=j_const then
		case u
		when tsint,tsllong,tuint,tullong,0 then			!0 when ref/ref ref/int int/ref
			if opc=eqsym then
				x^.value := x^.value = y^.value
			else
				x^.value := x^.value <> y^.value
			fi
			next
		esac
	fi
	x:=createunit2(symboltojtag[opc],x,y)
	x^.mode:=tsint
od


return x
end

function readrelexpr:unit=
unit x,y
int opc,s,t,u
int64 a,b,c
word64 aa,bb,cc

x:=readshiftexpr()

while (opc:=lx.symbol)=ltsym or opc=lesym or opc=gesym or opc=gtsym do
	lex()
	y:=readshiftexpr()

	if u:=dominantmode[s:=ttbasetype[x^.mode],t:=ttbasetype[y^.mode]] then			!were both numeric

		x:=coercemode(x,u)
		y:=coercemode(y,u)
	elsif s=tref and t=tref then
!		if tttarget[x^.mode]<>tttarget[y^.mode] then
		if not checkpointertypes(x^.mode,y^.mode,1) then		!use 'hard' mode
			terror("Comparing distinct pointers/rel")
		fi
	else
PRINTUNIT(NIL,X)
PRINTUNIT(NIL,Y)
CPL =STRMODE(X.MODE)
CPL =STRMODE(Y.MODE)
CPL =SYMBOLNAMES[OPC]

		terror("invalid rel operands")
	fi

	if x^.tag=j_const and y^.tag=j_const then
		a:=x^.value; b:=y^.value
		case u
		when tsint,tsllong then
			case opc
			when ltsym then c:=a<b
			when lesym then c:=a<=b
			when gesym then c:=a>=b
			else            c:=a>b
			esac
			x^.value:=c
			next
		when tuint,tullong then
			aa:=x^.value; bb:=y^.value
			case opc
			when ltsym then cc:=aa<bb
			when lesym then cc:=aa<=bb
			when gesym then cc:=aa>=bb
			else            cc:=aa>bb
			esac
			x^.value:=cc
			next
		esac
	fi

	x:=createunit2(symboltojtag[opc],x,y)
	x^.mode:=tsint
od

return x
end

function readshiftexpr:unit=
unit x,y
int opc,u

x:=readaddexpr()

while (opc:=lx.symbol)=shlsym or opc=shrsym do
	lex()
	y:=readaddexpr()

	coercebasetype(x)
	unless (u:=ttbasetype[x^.mode])>=tfirstint and u<=tlastint then
		terror("shift:Not an int")
	end unless
	y:=coercemode(y,tsint)
!
	if x^.tag=j_const and y^.tag=j_const then
		case u
		when tsint,tsllong then
			if opc=shlsym then
				x^.value := x^.value << y^.value
			else
				x^.value := x^.value >> y^.value
			fi
			next
		when tuint,tullong then
			if opc=shlsym then
				x^.uvalue := x^.uvalue << y^.value
			else
				x^.uvalue := x^.uvalue >> y^.value
			fi
			next
		esac
	fi
	x:=createunit2((opc=shlsym|j_shl|j_shr),x,y)
	x^.mode:=u
od

return x
end

function readaddexpr:unit=
unit p,q
int opc

p:=readmulexpr()

while (opc:=lx.symbol)=addsym or opc=subsym do
	lex()
	q:=readmulexpr()

	if opc=addsym then
		p:=createaddop(p,q)
	else
		p:=createsubop(p,q)
	fi
od

return p
end

function readmulexpr:unit=
unit p,q
int opc

p:=readterm()

while (opc:=lx.symbol)=mulsym or opc=divsym or opc=remsym do
	lex()
	q:=readterm()
	case opc
	when mulsym then
		p:=createmulop(p,q)
	when divsym then
		p:=createdivop(p,q)
	when remsym then
		p:=createremop(p,q)
	esac
od

return p
end

function readterm:unit=
unit p, q
int t,u,opc,shift,newlen,slength,tbase,fwide,newmode
ref char pbyte
int64 a
ref strec d
ichar ss,s
ref paramrec pm

switch lx.symbol
when intconstsym, realconstsym then
	p:=createconstunit(lx.value,lx.subcode)

	lex()
when namesym then
	if lx.symptr^.nameid<=macroid then
		d:=resolvename((currproc|currproc|stmodule),lx.symptr,ns_general,currblockno)
		if d=nil then
			serror_s("Undefined name \"%s\"", getstname(lx.symptr))
		fi
	else
		d:=lx.symptr
	fi

	d^.attribs.ax_used:=1
	case d^.nameid
	when enumid then
		p:=createconstunit(d^.index,tsint)
	when constantid then
		p:=createconstunit(d^.code^.value,d^.mode)
	when procid then
		if nextlx.symbol<>lbracksym then
			p:=createunit0(j_funcname)
			p^.def:=d
			p^.mode:=createrefmode(createprocmode(d^.mode,d^.paramlist))
!			p^.mode:=createprocmode(d^.mode,d^.paramlist)
		else
			goto doname
		fi

	else
doname::
		p:=createname(d)
		p^.mode:=t:=d^.mode
		if ttbasetype[t]=tarray then
			if not intypeof then
				p^.alength:=ttlength[t]
				p:=createaddrofop(p)
				p^.mode:=createrefmode(tttarget[t])
			fi
		elsif d^.nameid<>procid and d^.nameid<>constantid and ttsize[t]<4  then
			fixmemopnd(p)
		elsif d^.nameid=paramid then
			if isstructunion(p^.mode) then
				p^.lineno:=lx.lineno
				p^.mode:=createrefmode(p^.mode)
				p:=createptrop(p)
				p^.mode:=d^.mode
			fi
		fi
	esac
	p^.lineno:=lx.lineno
	lex()

when stringconstsym,wstringconstsym then
	fwide:=lx.symbol=wstringconstsym
	s:=lx.svalue
	slength:=lx.length
	while nextlx.symbol=stringconstsym do		!combine consecutive strings
		newlen:=slength+nextlx.length
		ss:=pcm_alloc(newlen+1)
		memcpy(ss,s,slength)
		memcpy(ss+slength,nextlx.svalue,nextlx.length)
		(ss+newlen)^:=0
		s:=ss
		slength:=newlen
		lex()
	od
	if fwide then
		p:=createwstringconstunit(cast(s),slength)
	    p^.wslength:=slength
		p^.mode:=trefwchar
	else
		p:=createstringconstunit(s,slength)
	    p^.slength:=slength
		p^.mode:=trefchar

	fi

	lex()

when kstrincludesym then
!when strincludedir then
	p:=readstrinclude()

!CPL "AFTER STRINCL",P.SLENGTH,p.alength
!PRINTUNIT(NIL,P)

when charconstsym then
	a:=0
	shift:=0
	pbyte:=lx.svalue
	if lx.length>8 then serror("char const too long") fi

!IF LX.LENGTH>1 THEN
!CPL "MULTICHAR CONST:",LX.SVALUE
!FI

	to lx.length do
		a:=a ior word64(pbyte^)<<shift
		shift+:=8
		++pbyte
	od
	p:=createconstunit(a,(lx.length<=4|tsint|tsllong))
	lex()

when addsym then
	lex()
	p:=readterm()

when subsym then
	lex()
	p:=createnegop(readterm())

when notlsym then
	lex()
	p:=readterm()
	coercecond(p)
	p:=createunit1(j_notl,p)
	p^.mode:=tsint

	if p^.a^.tag=j_notl and p^.a^.a^.tag=j_notl then
		p^.a:=p^.a^.a^.a
	fi

when inotsym then
	lex()
	p:=createinotop(readterm())

when iandsym then			!&
	lex()
!&* cancel, so detect this early to avoid more complicated code, which also
!has a bug when following term is an array that decays to a pointer; it ends up
!with an incorrect number of ptrs (one too many I think). The .alength trick
!doesn't work when the array is unbounded as in (*A)[]
!However, detecting &* doesn't cover &(*X) for example
!I need to have .alength plus also an array indicator. Fortunately array pointers
!and the use of &* mainly occur in my generated code
!
	if lx.symbol=mulsym then
		lex()
		p:=readterm()
	else
		p:=createaddrofop(readterm())
	fi

when andlsym then			!&&
	serror("rt/&&label")

when mulsym then			!*
	lex()
	p:=createptrop(readterm())

when incrsym, decrsym then			!*
	opc:=symboltojtag[lx.symbol]
	lex()
	p:=createincrop(opc,readterm())

when abssym then
	lex()
	skipsymbol(lbracksym)
	p:=createabsop(readexpression())
	skipsymbol(rbracksym)

when sqrtsym then
	lex()
	skipsymbol(lbracksym)
	p:=createsqrtop(readexpression())
	skipsymbol(rbracksym)

when lbracksym then			!(
	lex()
	if istypestarter() then
		t:=readcasttype(d,0,pm)
		skipsymbol(rbracksym)
		if lx.symbol=lcurlysym then
			serror("rt/compound lit")
		else
			p:=docast(readterm(),t)
		fi
	else
		p:=readexpression()
		skipsymbol(rbracksym)
	fi
when ksizeofsym then
	lex()
!	if lx.symbol=lbracksym then		!possible type
!		lex()
!		if istypestarter() then
!			t:=readcasttype(d,0,pm)
!			skipsymbol(rbracksym)
!			p:=createconstunit(ttsize[t],tullong)
!		else
!			p:=readexpression()
!!			p:=readterm()
!			skipsymbol(rbracksym)
!			p:=createsizeofop(p)
!		fi
!	else
!		p:=createsizeofop(readterm())
!	fi

	if lx.symbol=lbracksym then		!possible type
		if istypestarter_next() then
			lex()
			t:=readcasttype(d,0,pm)
			skipsymbol(rbracksym)
			p:=createconstunit(ttsize[t],tullong)
		else
			p:=readterm()
			p:=createsizeofop(p)
		fi
	else
		p:=createsizeofop(readterm())
	fi

when klengthofsym then
	lex()
	if lx.symbol=lbracksym then		!possible type
		lex()
		if istypestarter() then
			t:=readcasttype(d,0,pm)
			skipsymbol(rbracksym)
			p:=createconstunit(ttlength[t],tsint)
		else
			p:=readexpression()
			skipsymbol(rbracksym)
			p:=createlengthofop(p)
		fi
	else
		p:=createlengthofop(readterm())
	fi
when kgenericsym then
	p:=readgeneric()
when kalignofsym then
	serror("rt/alignof")
when kstrtypesym then
	lex()
	skipsymbol(lbracksym)
	t:=readcasttype(d,0,pm)
	skipsymbol(rbracksym)
	p:=createstringconstunit(pcm_copyheapstring(Strmode(t)),-1)
when kcputimesym then
	p:=createunit0(j_cputime)
	p^.mode:=tsllong
	lex()

else
PS("RT")
	serror("Readterm?")
endswitch

!look at the suffix

doswitch lx.symbol
when lsqsym then
	lex()
	q:=readexpression()
	skipsymbol(rsqsym)
	p:=createindexop(p,q)

when dotsym, idotsym then
	opc:=symboltojtag[lx.symbol]
	lex()
	checksymbol(namesym)
	d:=lx.symptr
	lex()

	p:=createdotop(opc,p,d)

when lbracksym then
	lex()
	if lx.symbol=rbracksym then			!()
		q:=nil
		lex()
	else
		q:=readexprlist(nil)
		skipsymbol(rbracksym)
	fi
	p:=createcall(p,q)

when incrsym then
	lex()
	p:=createincrop(j_postincr,p)

when decrsym then
	lex()
	p:=createincrop(j_postdecr,p)
else
	exit
enddoswitch

return p
end

function readexprlist(unit p)unit=
! read comma-separated list, and return head of list (not as j_makelist etc)
!p=nil:		at start of first expr (not ")")
!p<>nil:	p will be head of the list; comma skipped so at start of next expr
unit ulist, ulistx

ulist:=ulistx:=p
do
	p:=readassignexpr()
	addlistunit(&ulist,&ulistx,p)
	if lx.symbol<>commasym then
		exit
	fi
	lex()
od
return ulist

end

function readmodulevar(ref strec d, int m, linkage)ref strec=
!read or function decl at module scope
ref strec e
int scope,emode

e:=checkdupl(stmodule, d, ns_general, 0)

if e then					!already exists
	if e^.nameid<>staticid then
		serror_ss("var: name in use %s %s",e^.name,namenames[e^.nameid])
	fi
	emode:=e^.mode
	if emode<>m then
		if not comparemode(emode,m) then
redef::
			serror_s("var: redefining %s",e^.name)
		fi
		case ttbasetype[emode]
		when tarray then
			if ttlength[emode]=0 then			!replace empty array
				e^.mode:=m
			elsif ttlength[m] and ttlength[emode]<>ttlength[m] then
				goto redef
			fi
		esac

	fi
	d:=e

!see how scope interacts with existing decl
	scope:=d^.scope
	if scope=local_scope and linkage=none_ss or
	   scope=exported_scope and linkage=static_ss or
	   scope=imported_scope and linkage=static_ss then

!*!		serror("Linkage mismatch")

	elsif scope=imported_scope and linkage=none_ss then
		scope:=exported_scope
	fi

else
	d:=createdupldef(stmodule,d,(constantseen|constantid|staticid))
	d^.mode:=m
	case linkage
	when static_ss then
		scope:=local_scope
	when extern_ss then
		scope:=imported_scope
	else
		scope:=exported_scope
	esac

fi

if lx.symbol=assignsym then
	if d^.code then
		serror_s("Can't init twice %s",d^.name)
	fi
	if scope=imported_scope then
		serror_s("Can't init extern %s",d^.name)
	fi
	lex()
	d^.code:=readinitexpr(stmodule,d^.mode)

	if d^.nameid=constantid then
		unless tfirstint<=ttbasetype[d^.mode]<=tlastreal then
			serror("constant only for int/float")
		end unless
		if d^.code^.tag<>j_const then
			serror("constant expr must be constant")
		fi
	fi

elsif constantseen then
	serror("constant must be initialised")
fi

d^.scope:=scope

return d
end

function readframevar(ref strec d,int m, linkage)ref strec=
ref paramrec pm
ref strec e
int scope,id

e:=checkdupl_inproc(currproc, d, ns_general, currblockno)

if e then					!already exists
		serror_s("var: name in use %s",e^.name)
	d:=e

!see how scope interacts with existing decl
	scope:=d^.scope
	if scope=local_scope and linkage=none_ss or
	   scope=exported_scope and linkage=static_ss or
	   scope=imported_scope and linkage=static_ss then
!*!		serror("Linkage2 mismatch")
	elsif scope=imported_scope and linkage=none_ss then
		scope:=exported_scope
	fi
else
	id:=frameid
	scope:=function_scope
	case linkage
	when static_ss then
		id:=staticid
	when extern_ss then
		scope:=imported_scope
		id:=staticid
	esac
	d:=createdupldef(currproc,d,id)
	d^.mode:=m
	d^.blockno:=currblockno
	blockcounts[currblockno]:=1
fi

if lx.symbol=assignsym then
	if d^.code then
		serror_s("Can't init twice %s",d^.name)
	fi
	if scope=imported_scope then
		serror_s("Can't init extern %s",d^.name)
	fi
	lex()
	d^.code:=readinitexpr(currproc,d^.mode)
fi

d^.scope:=scope

return d
end

function readtype(ref strec owner, &d, int m, ref paramrec &pm)int=
[maxtypemods]int modtype
[maxtypemods]ref void modvalue
ref paramrec pmx
int nmodifiers,i
nmodifiers:=0

pm:=nil

readnamedtype(owner,d, modtype,modvalue,nmodifiers)

!now apply modifiers to base type:
for i:=nmodifiers downto 1 do
	case modtype[i]
	when 'A' then
		m:=createarraymode(m,int(modvalue[i]))
	when 'R' then
		m:=createrefmode(m)
	when 'C' then
		m:=createconstmode(m)
	when 'F' then
		if i=1 then				!indicate to caller that this is a normal function
			pm:=modvalue[1]
		else					!assume fu nction pointer of some sort
			m:=createprocmode(m,modvalue[i])
		fi
	esac
od

return m
end

proc readnamedtype(ref strec owner, &d,
			[]int &modtype, []ref void &modvalue, int &nmodifiers)=
int length
[maxtypemods]int fconst
int nrefs
unit pdim

d:=nil
nrefs:=0

if lx.symbol=kfnspecsym then
	lex()				!ignore $callback etc (not needed in a type decl, only a function def)
fi

!accumulate pointers
while lx.symbol=mulsym do			!pointer/qualifier loop
	++nrefs
	fconst[nrefs]:=0
	lex()
	while lx.symbol=ktypequalsym do
		case lx.subcode
		when const_qual then
			fconst[nrefs]:=1
		when volatile_qual, restrict_qual then
		else
			serror("rnt1")
		esac
		lex()
	od
od

case lx.symbol
when namesym then
	d:=lx.symptr
	lex()
when lbracksym then			!don't know how this would work...
	lex()
	readnamedtype(owner,d,modtype,modvalue,nmodifiers)
	skipsymbol(rbracksym)
esac

docase lx.symbol
when lsqsym then			!array
	lex()
	if lx.symbol=rsqsym then
		length:=0
	else
		pdim:=readassignexpr()
		if pdim^.tag=j_const then
			length:=pdim^.value
		else

			serror("Can't do VLAs")
		fi
		checksymbol(rsqsym)
	fi
	if length<0 then terror("Negative array dim") fi
	lex()
	modtype[++nmodifiers]:='A'
	modvalue[nmodifiers]:=ref void(length)

when lbracksym then			!fn params
	lex()
	modtype[++nmodifiers]:='F'
	modvalue[nmodifiers]:=readparams(owner)
else
	exit
enddocase

!now apply any pointers
while nrefs do
	if fconst[nrefs] then
		modtype[++nmodifiers]:='C'
	fi
	modtype[++nmodifiers]:='R'
	--nrefs
od
end

function readconstintexpr:int=
unit p
int val

p:=readassignexpr()
case p^.tag
when j_const then
	return p^.value

else
	serror_s("readconstint %s",jtagnames[p^.tag])
esac
return 0
end

function readinitexpr(ref strec owner, int m)unit=
int count
unit p

p:=readinitexpr2(owner,m,1)

return p
end

function readinitexpr2(ref strec owner, int m, istop)unit=
unit ulist, ulistx, p
int mbase,melem,mm
int dim,count
ref strec d,e
int braces

mbase:=ttbasetype[m]
count:=0

if lx.symbol=lcurlysym then
	lex()
	count:=0
	case mbase
	when tarray then
		dim:=ttlength[m]
		if not istop and dim=0 then terror("init/0-size array") fi
		melem:=tttarget[m]
		if ttbasetype[melem]=tuchar and lx.symbol=stringconstsym then
			braces:=1
			goto doarraystring
		fi

	when tstruct,tunion then
		d:=ttnamedef[m]
		e:=d^.deflist
		if e=nil then
			terror("init/Empty struct")
		fi
		melem:=e^.mode
	else
		p:=readassignexpr()
		p:=coercemode(p,m)
		skipsymbol(rcurlysym)
		return p
	esac

	ulist:=ulistx:=nil
	do
		p:=readinitexpr2(owner,melem,0)
		++count

		case mbase		
		when tarray then
			if dim and count>dim then
				terror("Too many array elems")
			fi

			if ttbasetype[melem]=tarray and ttbasetype[tttarget[melem]]=tuchar and p^.mode=trefchar then
			else
				p:=coercemode(p,melem)
			fi
		when tstruct then

			mm:=e^.mode

			if ttbasetype[mm]=tarray and ttbasetype[tttarget[mm]]=tuchar and p^.mode=trefchar then
			else
				p:=coercemode(p,mm)
			fi

			e:=e^.nextdef
			if e=nil then
				if lx.symbol=commasym and nextlx.symbol<>rcurlysym then
					terror("Too many struct elems")
				fi
			else
				melem:=e^.mode
			fi
		when tunion then
			p:=coercemode(p,melem)
			ulist:=ulistx:=p
			goto donestruct
		esac

		addlistunit(&ulist,&ulistx,p)
		if lx.symbol<>commasym then
			exit
		fi
		if nextlx.symbol=rcurlysym then		! {10,20,30,} allowed
			lex()
			exit
		fi
		lex()
	od
	if mbase=tarray and dim=0 then
		ttlength[m]:=count
		ttsize[m]:=count*ttsize[melem]
	fi

donestruct::
	skipsymbol(rcurlysym)
	p:=createunit1(j_makelist,ulist)
	p^.count:=count

	p^.mode:=m

else
	braces:=0
	case mbase
	when tarray then
doarraystring::
		if lx.symbol<>stringconstsym and lx.symbol<>wstringconstsym and 
			lx.symbol<>kstrincludesym and tttarget[m]<>tuchar then
			terror("{} initialiser expected")
		fi

		p:=readassignexpr()
		if p^.tag=j_const then p^.strarray:=1 fi
		case p^.mode
		when trefchar then
		when trefwchar then
		else
			terror("Array init")
		esac
		P^.MODE:=M

		if (dim:=ttlength[m])=0 then
			ttlength[m]:=ttsize[m]:=p^.slength+1
		else
			if p^.slength>dim then
				terror("Init str too long")
			fi
		fi
		if braces then skipsymbol(rcurlysym) fi
		return p
	esac
	p:=readassignexpr()
	p:=coercemode(p,m)

fi
return p
end

proc pushblock=
int n

if blocklevel>=maxblockstack then
	serror("Too many block levels")
fi
if nextblockno>=maxblock then
	serror("Too many blocks")
fi
++blocklevel
++nextblockno

n:=currblockno

int m:=blocklevel								!NEED TO ACCESS CONTAINING BLOCKS
												!VIA BLOCKSTACK

while m and blockcounts[blockstack[m]]=0 do
	--m
    n:=blockstack[m]
od

blockowner[nextblockno]:=n

currblockno:=blockstack[blocklevel]:=nextblockno
blockcounts[currblockno]:=0
end

proc popblock=
currblockno:=blockstack[--blocklevel]
end

function readcompoundstmt(int params):unit=
!read {...} statements
!positioned at first {, exit at symbol past final }
unit ulist, ulistx, p,q

ulist:=ulistx:=nil

lex()			!skip {
pushblock()
if params then		!assume top block of function
	blockcounts[1]:=1
fi

while lx.symbol<>rcurlysym do
!IF LX.SYMBOL=LCURLYSYM THEN
!!	CPL "STANDALONE {} SEEN?"
!SERROR("ANON BLOCK")
!	++NANONBLOCKS
!FI
	p:=readstatement()

	if p=nil then next fi				!might have been typedef etc
	if p^.tag=j_tempdecl then
		repeat
			q:=p^.nextunit
			if p^.def^.code and p^.def^.nameid<>staticid then
				p^.tag:=j_decl
				p^.nextunit:=nil
				addlistunit(&ulist,&ulistx,p)
			fi
			p:=q
		until p=nil
	else
		addlistunit(&ulist,&ulistx,p)
	fi
od
lex()
popblock()
return createunit3(j_block,ulist,nil,ulistx)
end

function readblock(int ifelse=0)unit=

	if not needcompoundblock then
		return readstatement()
	fi
	if lx.symbol=kifsym and ifelse then
		return readstatement()
	fi

	if lx.symbol<>lcurlysym then
		serror("{...} statement expected")
	fi
	return readcompoundstmt(0)
end

function readstatement:unit=
unit p,q
ref strbuffer ss
ref strec d
int index

switch lx.symbol
when kifsym then
	return readifstmt()

when kforsym then
	return readforstmt()

when kwhilesym then
	return readwhilestmt()

when kdosym then
	return readdostmt()

when kreturnsym then
	return readreturnstmt()

when kswitchsym then
	return readswitchstmt()

when lcurlysym then
	return readcompoundstmt(0)

when kgotosym then
	return readgotostmt()

when kbreaksym then
	if loopindex then
		if looptypestack[loopindex]='L'then
			p:=createunit0(j_break)
			lex()
!			if lx.symbol=namesym then
!				d:=resolvename(currproc,lx.symptr,ns_labels,0)
!				if d=nil then serror("block label not found") fi
!				d.attribs.ax_loop:=1
!				p.tag:=j_goto
!				p^.def:=d
!			fi

		else
			p:=createunit0(j_breaksw)
			lex()
		fi
	else
		serror("break outside loop/sw")
	fi

when kcontinuesym then
	index:=loopindex
	while index and looptypestack[index]<>'L' do --index od
	if index=0 then
		serror("continue outside loop")
	fi

	p:=createunit0(j_continue)
	lex()

when kcasesym then
	return readcaselabel()

when kdefaultsym then
	lex()
	skipsymbol(colonsym)
	return createunit1(j_defaultstmt,readstatement())

when kshowmodesym then
	lex()
	p:=readexpression()
	ss:=strexpr(p)
	print "Mode is:",ss^.strptr,":",Strmode(p^.mode),"	on line",lx.lineno,
		"Size is",ttsize[p^.mode]
	if ttisref[p^.mode] then
		print " target size",ttsize[tttarget[p^.mode]]
	fi
	println

when kmccassertsym then
	dostaticassert()

when semisym then
!CPL "READSEMI"
!SERROR("NULL STMT NOT ALLOWED")
	lex()	
	return nil

when namesym then
	if nextlx.symbol=colonsym then
		p:=createunit1(j_labelstmt,nil)
		d:=resolvename(currproc,lx.symptr,ns_labels,0)
		if d then
			if d^.index then
				cpl lx.symptr^.name
				terror("Duplicate label")
			else
				d^.index:=++labelno
			fi
		else
			d:=createdupldef(currproc,lx.symptr,labelid)
			d^.mode:=tvoid
			d^.index:=++labelno
		fi

		p^.def:=d
		lex()				!skip colon
		lex()
!		if lx.symbol=rcurlysym then serror("label before }") fi
		if lx.symbol=rcurlysym then
		elsif istypestarter() or lx.symbol=klinkagesym then
		else
			p^.a:=readstatement()
		fi
		return p
	else
		ist_symptr:=nil
		if isusertype(currproc) then
			goto doreaddecl
		fi
		if ist_symptr then lx.symptr:=ist_symptr fi		!make use of name resolve done by isusertype
		p:=readexpression()
	fi
when ktypespecsym, ktypequalsym, klinkagesym, kfnspecsym,
	kstructsym,kunionsym,kenumsym,ktypeofsym then
doreaddecl::
	return readlocaldecl()

else						!assume expression
	p:=readexpression()
!	TESTEXPR(p)
endswitch

skipsymbol(semisym)

return p
end

function readifstmt:unit=
unit pcond,pbody,pelse

lex()
pcond:=readcond()
coercecond(pcond)

pbody:=readblock()

!if pbody^.nextunit=nil and pbody^.tag=j_labelstmt then
!	serror("conditional label1")
!fi

pelse:=nil

if lx.symbol=kelsesym then
	lex()
	pelse:=readblock(1)
!	if pelse^.nextunit=nil and pelse^.tag=j_labelstmt then
!		serror("conditional label2")
!	fi
fi

return createunit3(j_if,pcond,pbody,pelse)
end

function readforstmt:unit=
unit pinit, pcond, pincr, pbody, ulist,ulistx, p
int linkage,hasblock,m,mbase
ref paramrec pm
ref strec d

lex()
skipsymbol(lbracksym)
hasblock:=0

if lx.symbol<>semisym then

	if istypestarter() then
		hasblock:=1
		pushblock()

		mbase:=readdeclspec(currproc,linkage)
		ulist:=ulistx:=nil

		docase lx.symbol
		when namesym, mulsym, lbracksym then

			m:=readtype(currproc,d,mbase,pm)
			if d=nil then
				serror("Var name expected")
			fi

			if linkage=typedef_ss or pm then
				serror("Not allowed in for stmt")
			fi
INSIDEFOR:=1
			d:=readframevar(d,m,linkage)
INSIDEFOR:=0

			if d^.code then
				p:=createunit0(j_decl)
				p^.def:=d
				addlistunit(&ulist,&ulistx,p)
			fi

			case lx.symbol
			when commasym then			!read next item
				lex()
			else
				exit
			esac
		else
			serror("For decl error")
		enddocase
		pinit:=createunit3(j_block,ulist,nil,ulistx)

	else
		pinit:=readexpression()
	fi
else
	pinit:=createunit0(j_null)
fi
skipsymbol(semisym)

if lx.symbol<>semisym then
	pcond:=readexpression()
	coercecond(pcond)
else
	pcond:=createunit0(j_null)
fi
skipsymbol(semisym)

if lx.symbol<>rbracksym then
	pincr:=readexprstmt()
else
	pincr:=nil
fi
skipsymbol(rbracksym)

pushloop('L')
pbody:=readblock()
poploop()
if hasblock then
	popblock()
fi

pinit^.nextunit:=pcond			!the 3 for elements are linked together
pcond^.nextunit:=pincr

return createunit2(j_for, pinit, pbody)
end

function readwhilestmt:unit=
unit pcond,pbody

lex()
pcond:=readcond()
coercecond(pcond)
pushloop('L')
pbody:=readblock()
poploop()

return createunit2(j_while,pcond,pbody)
end

function readdostmt:unit=
	unit pbody,pcond
	lex()
	pushloop('L')
	pbody:=readblock()
	poploop()
	skipsymbol(kwhilesym)
	pcond:=readcond()
	coercecond(pcond)
	skipsymbol(semisym)
	return createunit2(j_dowhile,pbody,pcond)
end

function readreturnstmt:unit=
	unit p
	lex()
	p:=nil

	if lx.symbol<>semisym then
		if currproc^.mode=tvoid then
			terror("Can't return value in void function")
		fi

		p:=readexpression()
		p:=coercemode(p,currproc^.mode)
		checksymbol(semisym)
	elsif currproc^.mode<>tvoid then
		terror("Return value needed")
	fi
	lex()

	return createunit1(j_return,p)
end

function readgotostmt:unit=
	ref strec d
	unit p

	lex()
	checksymbol(namesym)
!CPL "CALL RESOLVE/GOTO"
	d:=resolvename(currproc,lx.symptr,ns_labels,0)
!CPL "DONE",D
	if d=nil then					!assume fwd ref
		d:=createdupldef(currproc,lx.symptr,labelid)
		d^.mode:=tvoid
!		d^.index:=++labelno
	fi
	p:=createunit1(j_goto,nil)
	p^.def:=d
	lex()				!skip colon
	skipsymbol(semisym)
	return p
end

function readswitchstmt:unit=
	unit pindex,pstmt,p

	lex()
	pindex:=readcond()			!not a condition, but it doesn't matter
	coercemode(pindex,tsint)

	pushloop('S')
	pstmt:=readblock()			!not a condition, but it doesn't matter
	p:=createunit2(j_switch, pindex, pstmt)
	p^.nextcase:=casevaluestack[loopindex]

	poploop()
	return p
end

function readcaselabel:unit=
unit p,q
int value

lex()					!skip case/default
value:=readconstintexpr()
skipsymbol(colonsym)

p:=createunit1(j_casestmt,readstatement())
!p^.index:=value
!CPL =VALUE

!p^.uindex:=value
p^.value:=value
!CPL =P.UINDEX

addcasevalue(value)
return p
end

function readexprstmt:unit=
return readexpression()
end

function readcond:unit=
!should be at '(', read conditional expr
unit pcond
skipsymbol(lbracksym)
pcond:=readexpression()
skipsymbol(rbracksym)
return pcond
end

function isusertype(ref strec owner)int=
!current symbol is a namesymbol
!return typeno if it resolves to a user type, otherwise 0
!will peek at following symbol, and returns 0 if "," or ";" follows
ref strec d

d:=resolvename(owner,lx.symptr,ns_general,currblockno)
if d then
	if d^.nameid=typeid then
		return d^.mode
	fi
	ist_symptr:=d
fi
return 0
end

function readlocaldecl:unit=
!at typebase starter inside function or block
int m,mbase,linkage,nitems,wasenum,wasdef
ref strec d
unit ulist,ulistx,p
ref paramrec pm

ulist:=ulistx:=nil

wasenum:=lx.symbol
mbase:=readdeclspec(currproc,linkage)
nitems:=0

docase lx.symbol
when namesym, mulsym, lbracksym then
	++nitems

	m:=readtype(currproc,d,mbase,pm)
	if d=nil then
		serror("Var name expected")
	fi

	if linkage=typedef_ss then
		d:=createtypedef(currproc,d,m)
	elsif pm then
!PS("RLD")
		if lx.symbol=lcurlysym then
			serror("Nested function")
		fi
		d:=readfunction(d,m,linkage,pm,wasdef)
	else
		d:=readframevar(d,m,linkage)
		p:=createunit0(j_tempdecl)
		p^.def:=d
		addlistunit(&ulist,&ulistx,p)
	fi
	case lx.symbol
	when commasym then			!read next item
		lex()
	else
		skipsymbol(semisym)
		exit
	esac
else
	case ttbasetype[mbase]
	when tenum, tstruct, tunion then		!assume defining a [part]type only
		skipsymbol(semisym)
		exit
when tsint then
	skipsymbol(semisym)
	exit

	else
		serror_s("Local decl error %s",typename(m))
	esac
enddocase

if nitems=0 and fmodern then
	case ttbasetype[mbase]
	when tstruct,tunion,tenum then
	else
		if wasenum<>kenumsym then
			serror("Empty local declaration")
		fi
	esac
fi

return ulist
end

function createtypedef(ref strec owner, symptr, int mode)ref strec=
!symptr is a generic symbol for the name
ref strec d

d:=checkdupl(owner,symptr,ns_general,currblockno)

if d then			!existing name
	if d^.nameid<>typeid then
		serror_s("Typedef name in use %s",d^.name)
	fi

	if d^.mode<>mode then
		if not comparemode(d^.mode, mode) then
			serror_s("Typedef redefined or can't match types %s",d^.name)
		fi
	fi
	return d
fi

d:=createdupldef(owner,symptr,typeid)

d^.mode:=mode
tttypedef[mode]:=d
d^.blockno:=currblockno
blockcounts[currblockno]:=1

return d
end

function readparams(ref strec owner)ref paramrec=
ref paramrec ulist,ulistx, pm, q
int m,lastbasetype,nparams,variadic,flags,nnames
ref strec d

ulist:=ulistx:=nil
variadic:=nparams:=nnames:=0

if callbackflag then			!lex flag is out of step with parser
	iscallbackfnx:=1
	callbackflag:=0
fi
lastbasetype:=tvoid

!PS("RP0")
int names:=0, nonames:=0,reported:=0
++NALLPROCS

while lx.symbol<>rbracksym do
	if lx.symbol=ellipsissym then
		variadic:=1
		lex()
		exit
	fi

!PS("RP1")
	if istypestarter() then
		m:=readcasttype(d,1,pm,tvoid,&lastbasetype)
		if pm then			!was a fu nction; convert to fu nction pointer
			m:=createrefmode(createprocmode(m,pm))
		fi
!		lastbasetype:=m
	else
!SERROR("NAME IN PARAMLIST")
		if lastbasetype=tvoid then
			serror("Param type missing or misspelt")
		fi
!CPL "SHARED PARAMTYPE"
!		m:=readcasttype_xxx(d,1,pm, lastbasetype)
		m:=readcasttype(d,1,pm, lastbasetype)

	fi

!CPL =STRMODE(M)

	case ttbasetype[m]
	when tarray then
		m:=createrefmode(tttarget[m])
	when tproc then
		m:=createrefmode(createprocmode(m,ttparams[m]))
	esac

	pm:=pcm_allocz(paramrec.bytes)
	pm^.def:=d
	pm^.mode:=m
	++nparams

!CPL =D
!	if d and d.name^<>'_' then
	if d then
!CPL "SET NAMES=1",D,D.NAME
 names:=1 else nonames:=1 fi

!IF D THEN
!	CPL =NAMES
!FI

if names and nonames and not reported then
!CPL "Mixed:",(CURRFNNAME|CURRFNNAME.NAME|""),=NAMES,=NONAMES
!SERROR("MIXED NAMES")
++NMIXED
	reported:=1
fi

	if d then
		++nnames
		q:=ulist
		while q do
!CPL D.NAME, Q.DEF.NAME
			if q^.def=d then
				serror_ss("Param name reused %s %s",d^.name,namenames[d^.nameid])
			fi
			q:=q^.nextparam
		od

	fi

!IF TTLENGTH[TTTARGET[PM.MODE]]>1000 THEN
!	CPL STRMODE(PM.MODE),OWNER.NAME,(D|D.NAME|"?")
!FI

	addlistparam(&ulist,&ulistx,pm)
	case lx.symbol
	when commasym then
		lex()
	when ellipsissym, rbracksym then
	else
		serror("bad symbol in paramlist")
	esac
od

flags:=0
skipsymbol(rbracksym)

if variadic then
	flags:=pm_variadic
elsif nparams=0 then
	if fmodern then
		terror("() Params not allowed")
	else
		flags:=pm_notset
	fi
elsif nparams=1 and m=tvoid then
	flags:=pm_empty
	nparams:=0
	ulist^.mode:=tnone
fi

if ulist=nil then
	ulist:=pcm_allocz(paramrec.bytes)
fi
ulist^.nparams:=nparams
ulist^.flags:=flags

return ulist
end

function readcasttype(ref strec &d, int allowname=0,ref paramrec &pm,
	int m=tvoid, ref int mbase=nil)int=
!at first symbol of a type-spec
!ref paramrec pm
	ref strec owner
	int linkage

	owner:=(currproc|currproc|stmodule)

	linkage:=0
	d:=nil
	if m=tvoid then
		m:=readdeclspec(owner,linkage)
		if mbase then
			mbase^:=m
		fi

	fi
	pm:=nil

!CPL "BASETYPE", STRMODE(M)

	case lx.symbol
	when namesym, mulsym, lbracksym, lsqsym then
		m:=readtype(owner,d, m, pm)
		if d and not allowname then
			serror_s("NAME not allowed in cast type %s",d^.name)
		fi
	esac

	return m
end

!function readcasttype_xxx(ref strec &d, int allowname=0,ref paramrec &pm, int m)int=
!!at first symbol of a type-spec
!!ref paramrec pm
!	ref strec owner
!	int linkage
!
!	owner:=(currproc|currproc|stmodule)
!
!	linkage:=0
!	d:=nil
!!	m:=readdeclspec(owner,linkage)
!	pm:=nil
!
!	case lx.symbol
!	when namesym, mulsym, lbracksym, lsqsym then
!		m:=readtype(owner,d, m, pm)
!		if d and not allowname then
!			serror_s("NAME not allowed in cast type %s",d^.name)
!		fi
!	esac
!
!	return m
!end

function readfunction(ref strec d, int m, linkage, ref paramrec pm, int &wasdef)ref strec=
!have read function declaration, with ";" or "{" next
!d is generic st entry for name
!m is return type
!pm is linked list of parameter types
!set up the declaration properly in symbol table, checking for duplicates etc
!read function body if {...} follows
!return wasdef=1 if {...} encountered, as looping in the caller will be affected

ref strec f,owner
int scope

owner:=stmodule
wasdef:=0

CURRFNNAME:=D
!CPL "FUNCTION",D.NAME
!SKIP
f:=checkdupl(owner, d, ns_general, 0)


if f then					!already exists
	if f^.nameid<>procid then
		serror_s("fn: name in use %s",d^.name)
	fi
!COMPARE PARAM LISTS...
!	if e^.paramlist<>pm then
!		serror("fn: params don't match previous")
!	fi
	d:=f

!see how scope interacts with existing decl
	scope:=d^.scope
	if scope=local_scope and linkage=none_ss or
	   scope=exported_scope and linkage=static_ss or
	   scope=imported_scope and linkage=static_ss then
!*!		serror("Linkage3 mismatch")
	elsif scope=imported_scope and linkage=none_ss then
		scope:=exported_scope
	fi


else
!SKIP::
	d:=createdupldef(owner,d,procid)
	d^.mode:=m
	case linkage
	when static_ss then
		scope:=local_scope
	when extern_ss then
		scope:=imported_scope
	else
		scope:=exported_scope
	esac
fi

if iscallbackfnx or fcallback then
!CPL "CALLBACK SEEN",D^.NAME
	d^.attribs.ax_callback:=1
	iscallbackfnx:=0
fi

d^.paramlist:=pm
d^.scope:=scope

if lx.symbol=lcurlysym then
	wasdef:=1
	if d^.code then
		serror_s("Can't define function twice %s",d^.name)
	fi
	if scope=imported_scope then
!		serror("Can't define imported function")
	fi

	readfunctionbody(d)
	if lx.symbol=semisym then
		serror("; after function def")
	fi
fi

return d
end

proc readfunctionbody(ref strec f)=
!positioned just after '{'; return at '}' (checked by caller)
ref strec e
unit p
ref paramrec pm
int pmcount

currproc:=f
nextblockno:=currblockno:=0
pmcount:=0

!add named patams
pm:=f^.paramlist
if pm^.def then			!params are named
	to pm^.nparams do
		if pm.def=nil then
			serror("Param name missing")
		fi
		e:=createdupldef(f,pm^.def,paramid)
		e^.blockno:=1
		e^.mode:=pm^.mode
		pm:=pm^.nextparam
		pmcount:=1
	od
elsif pm^.nparams then
	serror("Param names missing")
fi

p:=readcompoundstmt(pmcount)
currproc^.code:=p
currproc:=nil
end

function createnegop(unit p)unit=
unit q
int t

t:=p^.mode

if p^.tag=j_const then
	case t
	when tsint,tsllong,tullong then
		p^.value:=-p^.value
		return p
	when tuint then
		p^.value:=(-p^.value) iand 0xFFFF'FFFF
		return p
	when tdouble then
		p^.xvalue:=-p^.xvalue
		return p
	esac
fi
retry::
if t>=tfirstnum and t<=tlastnum then
	coercebasetype(p)
	q:=createunit1(j_neg,p)
elsif ttconst[t] then
	t:=ttconsttype[t]
	goto retry
else
CPL Strmode(t)
	terror("neg bad type")
fi

q^.mode:=p^.mode
return q
end

function createabsop(unit p)unit=
unit q
int t

t:=p^.mode

if p^.tag=j_const then
	case t
	when tsint,tsllong then
		p^.value:=abs(p^.value)
		return p
	esac
fi

!if t>=tfirstint and t<=tlastint then
if isintcc(t) then
	coercebasetype(p)
	q:=createunit1(j_abs,p)
else
	terror("abs bad type")
fi

q^.mode:=p^.mode
return q
end

function createsqrtop(unit p)unit=
unit q
int t

t:=p^.mode

if p^.tag=j_const then
	case t
	when tfloat,tdouble then
		p^.value:=sqrt(p^.xvalue)
		return p
	esac
fi

coercemode(p,tdouble)

q:=createunit1(j_sqrt,p)
q^.mode:=tdouble

return q
end

function createinotop(unit p)unit=
unit q
int t

t:=ttbasetype[p^.mode]

if p^.tag=j_const then
	case t
	when tsint,tsllong,tuint,tullong then
		p^.value:=inot p^.value
		return p
	esac
fi
if isintcc(t) then
	coercebasetype(p)
	q:=createunit1(j_inot,p)
else
cpl Strmode(t)
	terror("! bad type")
fi

q^.mode:=p^.mode
return q
end

function createptrop(unit p)unit=
unit q
int t,m

if not ttisref[t:=p^.mode] then

PRINTUNIT(NIL,P)

	terror("* not pointer")
fi
m:=tttarget[t]

case p^.tag
when j_addrof then
	q:=p^.a
	if p^.alength then
		q^.mode:=tttarget[p^.mode]
	fi
	return q
esac

q:=createunit1(j_ptr,p)
q^.mode:=m
q:=arraytopointer(q)
fixmemopnd(q)

return q
end

function createincrop(int opc,unit p)unit=
!opc is j_preincr/decr or j_postincr/decr
unit q
int t

t:=p^.mode

checklvalue(p)
!unless t>=tfirstint and t<=tlastint and t<>tbool or ttisref[t] then
!if isreal(t) and opc in [j_preincr, j_predecr] then
!	q:=createunit2((opc=j_preincr|j_addto|j_subto),p,createconstunit(word64@(1.0),tdouble))
!	q^.mode:=p^.mode
!	return q
!fi

unless isintcc(t) and t<>tbool or ttisref[t] then
	terror("++ bad type")
endunless
q:=createunit1(opc,p)
q^.mode:=p^.mode

return q
end

function createlengthofop(unit p)unit=
unit q
int t,size

t:=p^.mode
switch p^.tag
when j_name then
	size:=ttlength[p^.def^.mode]			!take account of array

when j_const then
	if t=trefchar then					!const string
		size:=p^.slength+1
	else
		size:=ttlength[t]
	fi

when j_ptr then
	if ttisref[t] and p^.alength then		!result of array=>ptr conversion
		size:=ttlength[tttarget[t]]*p^.alength
	else
		size:=ttlength[t]
	fi
when j_widenmem then
	return createsizeofop(p^.a)

else
	size:=ttlength[t]
endswitch

q:=createconstunit(size,tsint)
return q
end

function createaddrofop(unit p)unit=
ref strec d
unit q
int t,u,alength

alength:=0

restartx::
t:=p^.mode
switch p^.tag
when j_name then
	if p^.alength then
		t:=p^.def^.mode
		alength:=p^.alength
	fi

when j_addrof then
	if p^.a^.tag=j_name and p^.a^.alength then		!sounds like ANAME => &ANAME
		p^.mode:=createrefmode(p^.a^.def^.mode)
p^.alength:=p^.a^.alength
		return p
	fi
!doname:
!	d:=p^.def
!	if d^.nameid=constantid then serror("&constant not allowed") fi
!	m:=createrefmode(d^.mode)
!
!when j_funcname then
!	m:=createprocmode(p^.def^.mode,p^.def^.paramlist)
!
!when j_ptr then				!should cancel out
!	return p^.a
!
!when j_ptroffset then
!	p^.tag:=j_addptr
!	p^.mode:=createrefmode(p^.mode)
!	return p
!
!when j_addptr then
!	if p^.alength then	!derived from array expr that converted to pointer
!		p^.mode:=createrefmode(createarraymode(tttarget[t],p^.alength))
!		return p
!	else
!		goto cad1
!	fi
!when j_convert then
!	if p^.a^.tag=j_name then			!assume added by readterm
!		p:=p^.a
!		goto doname
!	fi
!	goto cad1
when j_dot then
	q:=p^.a
	if q^.tag=j_ptr and q^.a^.tag=j_const then
		p:=createconstunit(p^.offset+q^.a^.value, tsint)
		return p
	fi
	goto cad1
when j_addptr then
	if p^.alength then
		p^.mode:=createrefmode(createarraymode(tttarget[p^.mode],p^.alength))
		return p
	fi
when j_widenmem then
	p:=p^.a
	goto restartx
when j_funcname then
	return p
!when j_const then
!	if t=trefchar then					!const string
!		t:=createarraymode(tuchar,p^.slength+1)
!	else
!		goto cad1
!	fi
else

cad1::
	checklvalue(p)
endswitch

p:=createunit1(j_addrof,p)
p^.mode:=createrefmode(t)
p^.alength:=alength

!CPL "ADDROF",STRMODE(P^.MODE),STRMODE2(T)

return p
end

function createaddop(unit x,y)unit=
unit z
int s,t,u,opc,elemsize

!s:=ttbasetype[x^.mode]
!t:=ttbasetype[y^.mode]
s:=ttbasetype[getmemmode(x)]
t:=ttbasetype[getmemmode(y)]
opc:=j_add

if u:=dominantmode[s,t] then			!were both numeric
	x:=coercemode(x,u)
	y:=coercemode(y,u)

elsif s=tref then
doaddref::
	u:=x^.mode
	elemsize:=ttsize[tttarget[u]]
	if x^.tag=j_const and y^.tag=j_const then
		x^.value +:=y^.value*elemsize
		return x
	fi

	y:=coercemode(y,tptroffset)

	z:=createunit2(j_addptr,x,y)
	z^.mode:=u
	z^.ptrscale:=elemsize
	return z

elsif t=tref then
	swap(x,y)
	goto doaddref
else
	terror("Sub bad types")
fi

if x^.tag=j_const and y^.tag=j_const then
	return eval_add(opc,x,y,u)
fi
z:=createunit2(opc,x,y)
z^.mode:=u

return z
end

function createsubop(unit x,y)unit=
unit z
int s,t,u,opc,elemsize

!s:=ttbasetype[x^.mode]
!t:=ttbasetype[y^.mode]
s:=ttbasetype[getmemmode(x)]
t:=ttbasetype[getmemmode(y)]
opc:=j_sub

if u:=dominantmode[s,t] then			!were both numeric
	x:=coercemode(x,u)
	y:=coercemode(y,u)
elsif s=tref then
	if t<>tref then
		u:=x^.mode
		elemsize:=ttsize[tttarget[u]]
		y:=coercemode(y,tptroffset)

		z:=createunit2(j_subptr,x,y)
		z^.mode:=u
		z^.ptrscale:=elemsize
		return z

	else							!ref-ref
!PRINTUNIT(NIL,X)
!PRINTUNIT(NIL,Y)
!CPL =TTSIZE[TTTARGET[X.MODE]],=STRMODE(X.MODE)
		if x^.tag=j_const and y^.tag=j_const then
			x^.value -:= y^.value/ttsize[tttarget[x.mode]]
			x.mode:=tsint
			return x

		else
			z:=createunit2(opc,x,y)
			z^.mode:=tptroffset
			z:=divunit(z,tttarget[x^.mode])
			z^.mode:=tptroffset
			return z
		fi
	fi
	y:=mulunit(y,tttarget[x^.mode])
else
	terror("Sub bad types")
fi

!CPL "SUB"
!PRINTUNIT(NIL,X)
!PRINTUNIT(NIL,Y)
if x^.tag=j_const and y^.tag=j_const then
	return eval_sub(opc,x,y,u)
fi
z:=createunit2(opc,x,y)
z^.mode:=u

return z
end

function createmulop(unit x,y)unit=
unit z
int s,t,u,opc

!s:=ttbasetype[x^.mode]
!t:=ttbasetype[y^.mode]
s:=ttbasetype[getmemmode(x)]
t:=ttbasetype[getmemmode(y)]

opc:=j_mul
if u:=dominantmode[s,t] then			!were both numeric
	x:=coercemode(x,u)
	y:=coercemode(y,u)
else
	terror("Mul bad types")
fi

if x^.tag=j_const and y^.tag=j_const then
	return eval_mul(opc,x,y,u)
fi
z:=createunit2(opc,x,y)
z^.mode:=u

return z
end

function createdivop(unit x,y)unit=
unit z
int s,t,u,opc

s:=ttbasetype[getmemmode(x)]
t:=ttbasetype[getmemmode(y)]

opc:=j_div
if u:=dominantmode[s,t] then			!were both numeric
	x:=coercemode(x,u)
	y:=coercemode(y,u)
else
	terror("Div bad types")
fi

if x^.tag=j_const and y^.tag=j_const then
	return eval_div(opc,x,y,u)
elsif y.tag=j_const and u=tdouble then
	opc:=j_mul
	y.xvalue:=1.0/y.xvalue
fi
z:=createunit2(opc,x,y)
z^.mode:=u

return z
end

function createremop(unit x,y)unit=
unit z
int s,t,u,opc

s:=ttbasetype[x^.mode]
t:=ttbasetype[y^.mode]

opc:=j_rem
if u:=dominantmode[s,t] then			!were both numeric
	if u=tdouble or u=tfloat then
!		u:=tsllong
		u:=tsint
	fi
	x:=coercemode(x,u)
	y:=coercemode(y,u)
else
	terror("Rem bad types")
fi

if x^.tag=j_const and y^.tag=j_const then
	return eval_rem(opc,x,y,u)
fi
z:=createunit2(opc,x,y)
z^.mode:=u

return z
end

proc insertunit(unit p, int tag)=
!wrap extra unit around p, using given tag
unit q
q:=createunit0(0)			!empty unit
q^:=p^
p^.tag:=tag
p^.a:=q
p^.b:=p^.c:=nil
p^.lineno:=q^.lineno
p^.simple:=0
p^.nextunit:=q^.nextunit

q^.nextunit:=nil
end

function eval_add(int opc,unit x,y,int t)unit=
unit z

case t
when tsint,tsllong,tuint,tullong then
	x^.value +:= y^.value
	return x
when tdouble then
	x^.xvalue +:= y^.xvalue
	return x
elsif ttbasetype[t]=tref then	!assume y is const 0 int of any sub-type
	x^.value +:= y^.value*ttsize[tttarget[t]]
	return x			!will not change x
esac

z:=createunit2(opc,x,y)
z^.mode:=t
return z
end

function eval_sub(int opc,unit x,y,int t)unit=
unit z

!CPL "EVALSUB"

case t
when tsint,tsllong,tuint,tullong then
	x^.value -:= y^.value
	return x
when tdouble then
	x^.xvalue -:= y^.xvalue
	return x
elsif ttbasetype[t]=tref then
	if ttbasetype[y^.mode]=tref then
		terror("EVALSUB/REF")
	fi
	return x
esac

z:=createunit2(opc,x,y)
z^.mode:=t
return z
end

function eval_mul(int opc,unit x,y,int t)unit=
unit z

case t
when tsint,tsllong,tsshort,tschar then
	x^.value *:= y^.value
	return x
when tuint,tullong,tushort,tuchar then
!	x^.uvalue *:= y^.uvalue
	x^.uvalue := x^.uvalue*y^.uvalue
	return x
when tdouble then
	x^.xvalue *:= y^.xvalue
	return x
esac

z:=createunit2(opc,x,y)
z^.mode:=t
return z
end

function eval_div(int opc,unit x,y,int t)unit=
unit z

case t
when tsint,tsllong then
!CPL "EVAL/I"
	if y^.value=0 then serror("div 0") fi
	x^.value := x^.value/y^.value
	return x
when tuint,tullong then
!CPL "EVAL/U",X.UVALUE/Y.UVALUE
	if y^.value=0 then serror("div 0") fi
	x^.uvalue := x^.uvalue/y^.uvalue
	return x
when tdouble then
!	if y^.xvalue=0 then serror("div 0.0") fi
	x^.xvalue /:= y^.xvalue
	return x
esac

z:=createunit2(opc,x,y)
z^.mode:=t
return z
end

function eval_rem(int opc,unit x,y,int t)unit=
unit z

case t
when tsint,tsllong then
	if y^.value=0 then serror("rem 0") fi
	x^.value := x^.value rem y^.value
	return x
esac

z:=createunit2(opc,x,y)
z^.mode:=t
return z
end

function eval_convert(unit p, int t,opc)int=
!p contains a const unit, t is a target type, opc is conv op
!try and convert if possible
!return 1 if converted
int s

!CPL "EVALCONVERT",CONVNAMES[OPC],JTAGNAMES[P.TAG],=OPC

if opc=soft_c then
dosoft::
	p^.mode:=t
	return 1
fi

s:=p^.mode
if s=t then return 1 fi

case s
when tsint,tsshort,tschar,tsllong then
	case t
	when tdouble,tfloat then
		p^.xvalue:=p^.value
		p^.mode:=t
		return 1
	when tullong,tsllong,tuint,tsint,tsshort,tschar,tuchar,tushort then
dotrunc::
		case ttsize[t]
		when 1 then p^.value iand:=255
		when 2 then p^.value iand:=65535
!		when 4 then p^.value iand:=0xFFFF'FFFF
		when 4 then p^.value :=p^.value iand 0xFFFF'FFFF
		esac

		goto dosoft
	esac
	if ttisref[t] then
		p^.mode:=t
		return 1
	fi

when tuint,tuchar,tushort,tullong then
	case t
	when tdouble,tfloat then

RETURN 0
!CPL "ULLONG TO FLOAT"
!		if p^.value>=0 then
!			p^.xvalue:=p^.uvalue
!		else
!			p^.xvalue:=-p^.value
!		fi
		p^.mode:=t
		return 1
	when tullong,tsllong,tsint,tuint,tullong,tushort,tschar,tuchar,tsshort then
		goto dotrunc
	esac
	if ttisref[t] then
		p^.mode:=t
		return 1
	fi

when tdouble then
	case t
	when tsint,tsllong then
		p^.value:=p^.xvalue
		p^.mode:=t
		return 1
!	when tuint,tullong then
!		p^.uvalue:=p^.xvalue
!		p^.mode:=t
!		return 1
	when tfloat then
		p^.mode:=tfloat
		return 1
	esac
elsif ttisref[p^.mode] then
	case t
	when tsint,tsllong,tuint,tullong then
		p^.mode:=t
		return 1
	esac
esac

return 0
end

proc coercecond(unit p)=
!p is an expression used as a condition
!make sure it is an int, or convert it to one
int t
if (t:=p^.mode)=tsint then return fi

retry::
case ttbasetype[t]
when tfloat,tdouble,tref then
	goto doint

!elsif t>=tfirstint and t<=tlastint then
elsif isintcc(t) then
doint::
	if p^.tag=j_const and p^.value then			!check all types as one 64-bit field
		p^.value:=1
	elsif p^.tag=j_const and not p^.value then			!check all types as one 64-bit field
		p^.value:=0
	else
		insertunit(p,j_istruel)
	fi
elsif ttconst[t] then
	t:=ttconsttype[t]
	goto retry
else

	serror_s("Invalid condition %s",Strmode(t))
esac
p^.mode:=tsint
end

proc coercebasetype(unit p)=
int t

if (t:=p^.mode)>=tschar and t<=tsshort then
	p:=coercemode(p,tsint)
elsif t>=tbool and t<=tushort then
	p:=coercemode(p,tuint)
fi
end

proc checklvalue(unit p)=
case p^.tag
when j_name then
	if p^.def^.nameid=constantid then
		serror("'constant' name can't be lvalue")
	fi
when j_ptr then

when j_funcname then

when j_widenmem then
	case p^.a^.tag
	when j_name,j_ptr,j_dot then
		p^:=p^.a^
	else
		terror("CHECKLV/WIDEN")
	esac

when j_dot then

!when j_ptroffset then

when j_const then
	if not ttisref[p^.mode] then
		goto notlv
	fi
when j_convert then
	if p^.a^.tag=j_name then
!		p^:=p^.a^
		return
	fi

else
notlv::
	printunit(nil,p)
	terror_s("Not lvalue: %s",jtagnames[p^.tag])
esac
end

function createcall(unit p,q)unit=
!p is unit on left of param list, while q is the param list as the head of a unitlist
!do type-checking on params, and construct and return callfn unit
!p can be a simple name, or an expression that should be a function po inter
unit r,s,u
ref strec d
ref paramrec pm
int i,nparams,aparams,retmode,mproc,m,c
[1024]char str
ichar ss,tt,uu
ref strbuffer exprstr

d:=nil

!CPL "CALL:"
!PRINTUNIT(NIL,P)

case p^.tag
when j_ptr then
doptr::
	mproc:=p^.mode

	while ttbasetype[mproc]=tref do
		r:=createunit1(j_ptr,p)
		mproc:=tttarget[mproc]
		r^.mode:=mproc
		p:=r
	od

	if ttbasetype[mproc]<>tproc then
!CPL =STRMODE(MPROC), =STRMODE(TTBASETYPE[MPROC]),=STRMODE(TPROC)
		serror_s("Not function pointer: %s",typename(mproc))
	fi

	pm:=ttparams[mproc]
	retmode:=tttarget[mproc]

when j_name,j_funcname then
!CPL "NAME",STRMODE(P.MODE)
	d:=p^.def
	if d^.nameid=procid then
!CPL "WAS PROC"
		pm:=d^.paramlist
		retmode:=d^.mode
	else							!assume fnptr, but needs ptr unit
!CPL "WAS FNPTR"
		r:=createunit1(j_ptr,p)

		r^.mode:=tttarget[d^.mode]
R.MODE:=P.MODE
		p:=r
!CPL =STRMODE(R.MODE)

		goto doptr
	fi
!when j_dot,j_callfn,j_ifx then
when j_dot,j_callfn,j_ifx,j_convert then
	r:=createunit1(j_ptr,p)
	r^.mode:=tttarget[p^.mode]
	p:=r
	goto doptr

!when j_callfn then
!	r:=createunit1(j_ptr,p)
!	r^.mode:=tttarget[p^.mode]
!	p:=r
!	goto doptr

else
CPL =JTAGNAMES[P^.TAG]
PRINTUNIT(NIL,P)
	serror("ccall?")
esac

!CPL "CALL2"

nparams:=pm^.nparams
aparams:=0

s:=q
while s do
	++aparams				!number of actual params supplied
	s:=s^.nextunit
od

!checking params is a little tricky because of variadic params
!but there must be at least <nparams> actual params.

if aparams<nparams then
	terror("Too few args")
elsif aparams>nparams and pm^.flags<>pm_variadic and pm^.flags<>pm_notset then
!elsif aparams>nparams and pm^.flags<>pm_variadic then
	if pm^.flags<>pm_notset then
		cpl aparams,nparams


		terror("Too many args")
	elsif fmodern then
		terror("Can't call () param function")
	fi
fi

s:=q

!REF PARAMREC QM:=PM
!FOR I TO NPARAMS DO
!	CPL I,STRMODE(QM.MODE),(QM.DEF|QM.DEF.NAME|"?")
!	QM:=QM.NEXTPARAM
!OD

for i:=1 to aparams do
	if i<=nparams then
!CPL "COERCE",STRMODE(PM.MODE),D.NAME,=NPARAMS,(PM.DEF|PM.DEF.NAME|"?")

		coercemode_inplace(s,pm^.mode)
		pm:=pm^.nextparam
	else					!assume variadic param
		if s^.mode=tvoid then
			terror("Variadic param is void")
		fi
		coercebasetype(s)
	fi
	s:=s^.nextunit
od

r:=createunit2(j_callfn,p,q)
r^.mode:=retmode
r^.aparams:=aparams

!CPL "DONE CALL",D,D.NAME
!IF d and q and q.tag=j_const then

!VAR UNIT XXX
!
!IF d and q then
!!CPL "DQ CALL",d.name
!!IF EQSTRING(D.NAME,"printf") THEN CPL "///PRINTF" FI
!!IF EQSTRING(D.NAME,"sprintf") THEN CPL "///SPRINTF",Q.NEXTUNIT,JTAGNAMES[Q.NEXTUNIT.TAG] FI
!
!	XXX:=Q
!	if eqstring(d.name,"printf") and q.tag=j_const or
!	   eqstring(d.name,"sprintf") and (XXX:=q.nextunit) or
!	   eqstring(d.name,"fprintf") and (XXX:=q.nextunit) then
!
!		while xxx.tag=j_convert do xxx:=xxx.a od
!IF XXX.TAG=J_CONST THEN
!!CPL =JTAGNAMES[XXX.TAG]
!		ss:=XXX.svalue
!!CPL =ss
!		while c:=ss++^ do
!			if c='%' then
!			++NFORMATS
!			fi
!		od
!FI
!	fi
!fi
!

if d and eqstring(d.name,"printf") and q and q.tag=j_const and
		q.slength<str.len/2 then
	ss:=q.svalue
	tt:=&.str

	u:=q.nextunit
	while c:=ss++^ do
		if c='%' and ss^ in ['?','='] and u then
			if ss^='=' then
				++ss				!should be '?'
				exprstr:=strexpr(u)
				uu:=exprstr.strptr
				convucstring(uu)
				to exprstr.length do
					tt++^:=uu++^
				od
				tt++^:='='
			fi
			++ss

			tt++^:='%'
!CPL =STRMODE(U.MODE)
			case ttbasetype[u.mode]
			when tsint then
				tt++^:='d'
			when tsllong then
				tt++^:='l'
				tt++^:='l'
				tt++^:='d'
			when tuint then
				tt++^:='u'
			when tullong then
				tt++^:='l'
				tt++^:='l'
				tt++^:='u'
			when tfloat, tdouble,tldouble then
				tt++^:='f'
			when tref then
				if tttarget[u.mode]=tschar then
					tt++^:='s'
				else
					tt++^:='p'
				fi
			else
				tt++^:='?'
			esac
			u:=u.nextunit
		else
			tt++^:=c
		fi
	od
	tt^:=0
	q.svalue:=pcm_copyheapstring(&.str)
	q.slength:=strlen(&.str)

!CPL =&.STR
fi

return r
end

function arraytopointer(unit p)unit=
unit q
int offset
int t,elemmode,refmode

t:=p^.mode
elemmode:=tttarget[t]

if ttbasetype[t]=tarray then
	refmode:=createrefmode(elemmode)
	case p^.tag
	when j_ptr then
		p:=p^.a

	when j_dot then						!about to access array field
		offset:=p^.offset
		p^.tag:=j_addptr
		p^.ptrscale:=0	!ttsize[elemmode]
!		p^.a^.mode:=refmode
		q:=createunit1(j_addrof,p^.a)
		q^.mode:=refmode
		p^.a:=q
		p^.b:=createconstunit(offset,tsint)

	else
		CPL "ATP:"
		printunit(nil,p)
		terror("ATP?")
	esac

	p^.mode:=refmode
	p^.alength:=ttlength[t]

fi
return p
end

function createindexop(unit p,q)unit=
!do p[q]
!convert to *(p+q)
unit a

a:=createaddop(p,q)
return createptrop(a)
end

function readstructdecl(ref strec owner)int=
ref strec d,e,currrecord
ref strec ulist,ulistx,tagowner
int funion,linkage,mbase,m
int offset,recsize,maxsize,maxalignment,alignment,size
ref paramrec pm
ref fieldrec fieldlist,fl

funion:=(lx.symbol=kunionsym)

lex()				!skip 'struct' etc

tagowner:=(currproc|currproc|stmodule)

if lx.symbol=lcurlysym then				!anonymous struct tag
	d:=addnamestr(nextautotype())
else
	checksymbol(namesym)
	d:=lx.symptr		!should be struct tag
	lex()

	if lx.symbol<>lcurlysym then			!reading incomplete enum
		e:=resolvename(tagowner,d,ns_tags,currblockno)
		if e then
			if e^.nameid<>structtagid then
				serror_s("Struct tag in use %s",e^.name)
			fi

			return e^.mode
		fi
!create new incomplete tag
		e:=createdupldef(tagowner,d,structtagid)
		e^.mode:=createstructmode(e,(funion|tunion|tstruct))
		e^.blockno:=currblockno
		blockcounts[currblockno]:=1
		return e^.mode
	fi
fi

!{ seen, so defining a new struct

e:=checkdupl(tagowner,d,ns_tags,currblockno)

if e then			!found in this linkage
	if e^.nameid<>structtagid then
		serror_s("Struct tag in use %s",e^.name)
	fi
	if e^.deflist then					!else filling in incomplete enum
		cpl "Prev",e^.lineno iand 1677215, sourcefilenames[e^.lineno>>24],sourcefilepaths[e^.lineno>>24]
		serror_s("Redefining struct %s",e^.name)
	fi
else						
	e:=createdupldef(tagowner,d,structtagid)
	e^.mode:=createstructmode(e,(funion|tunion|tstruct))
	e^.blockno:=currblockno
	blockcounts[currblockno]:=1
fi

!e points to an def which has an empty {...} list
lex()							!skip {

currrecord:=e
ulist:=ulistx:=nil
offset:=maxsize:=recsize:=0
maxalignment:=1
fieldlist:=nil
m:=-1

while lx.symbol<>rcurlysym do
	mbase:=readdeclspec(currrecord,linkage)

	docase lx.symbol
	when namesym, mulsym, lbracksym then

		m:=readtype(currrecord,d,mbase,pm)
		if d=nil then
			serror("Field name expected")
		fi

		if linkage=typedef_ss or pm then
			serror("typedef or function inside struct")
		fi

		e:=checkdupl(currrecord, d, ns_fields, 0)

		if e then					!already exists
			serror_s("member name in use %s",e^.name)
		fi

		if linkage<>none_ss then
			serror("Can't use ss in struct")
		fi

addanonfield::
		d:=createdupldef(nil,d,fieldid)
		d^.mode:=m
!name is not linked in to record as they must be in sequence
		addlistdef(&ulist,&ulistx,d)
		currrecord^.deflist:=ulist				!needed for dupl checking
		currrecord^.deflistx:=ulistx
		d^.owner:=currrecord
		alignment:=getalignment(m)
		if alignment>maxalignment then maxalignment:=alignment fi

		d^.offset:=roundoffset(offset,alignment)
		size:=ttsize[m]
		recsize+:=d^.offset-offset
		offset:=d^.offset

		addnewfield(fieldlist,d,offset)

		if funion then
			maxsize:=max(maxsize,size)
		else
			offset+:=size
			recsize+:=size
		fi

		if lx.symbol=colonsym then
			lex()
			readassignexpr()
		fi

		case lx.symbol
		when commasym then			!read next item
			lex()
		else
			skipsymbol(semisym)
			exit
		esac
	when colonsym then				!apparently int:24 is allowed, with no member name
		lex()
		readassignexpr()
		skipsymbol(semisym)
		exit
	else
		case ttbasetype[mbase]
		when tstruct, tunion then		!assume defining a [part]type only
			d:=getautofieldname()
			m:=mbase
			goto addanonfield
		else
			if m=-1 then
				serror("Struct decl error")
			else
				serror_s("Struct decl error %s",typename(m))
			fi
		esac
	enddocase
od

skipsymbol(rcurlysym)

currrecord^.nextfield:=fieldlist
ttsize[currrecord^.mode]:=roundoffset((funion|maxsize|recsize),maxalignment)
currrecord^.attribs.ax_align:=maxalignment

return currrecord^.mode
end

function checkpointertypes(int s,t,hard)int=
!return 1 if pointer types s and t are compatible
!it is assumed that s is to be converted to t, or passed as a parameter expecting t
int starget:=tttarget[s], ttarget:=tttarget[t]
int sconst:=0,tconst:=0

if ttconst[starget] then
	starget:=ttconsttype[starget]
	sconst:=1
fi
if ttconst[ttarget] then
	ttarget:=ttconsttype[ttarget]
	tconst:=1
fi

if not hard and sconst and not tconst then
	cpl Strmode(s)
	cpl Strmode(t)
	terror("const to non-const pointer")
fi

if starget=ttarget then return 1 fi
s:=starget
t:=ttarget
if ttbasetype[s]=tvoid or ttbasetype[t]=tvoid then
	return 1
fi

if ttisref[s] and ttisref[t] then
	return checkpointertypes(s,t,hard)

elsif ttbasetype[s]=tarray and ttbasetype[t]=tarray then
	if ttlength[s]<>ttlength[t] then
		if ttlength[s] and ttlength[t] then		!allow one dim to be 0
			return 0
		fi
	fi
	starget:=tttarget[s]
	ttarget:=tttarget[t]
	if starget=ttarget then return 1 fi
!CPL "ARRAY TARGS",STRMODE(STARGET), STRMODE(TTARGET),STARGET, TTARGET
 
	if ttisref[starget] and ttisref[ttarget] then
		return checkpointertypes(starget,ttarget,hard)
	fi
	if ttbasetype[starget]=tarray and ttbasetype[ttarget]=tarray then
		return checkpointertypes(starget,ttarget,hard)
	fi
elsif ttbasetype[s]=tproc and ttbasetype[t]=tproc then
	return 1				!NEED PROPER MATCH HERE
fi

return 0
end

function comparemode(int s,t)int=
!types s and t don't immediately match
!check further to see if they are compatible
!For example, if they are both arrays, then usually they will have different
!typenumbers. Arrays should match if they have the same element type, and
!same length, or one length is 0
!return 1 for compatible types

if s=t then return 1 fi			!for when used recursively
if ttbasetype[s]=tarray and ttbasetype[s]=tarray then
	if comparemode(tttarget[s],tttarget[t])=0 then
		return 0
	fi
	if ttlength[s]=0 or ttlength[t]=0 or ttlength[s]=ttlength[t] then
		return 1
	fi
fi
return 0
end

function readenumdecl(ref strec owner)int=
ref strec d,e

lex()				!skip 'enum'

if lx.symbol=lcurlysym then				!anonymous enum tag
	readenumnames(owner)
	return tenum			!return generic enum
fi

checksymbol(namesym)
d:=lx.symptr		!should be enum tag
lex()

if lx.symbol<>lcurlysym then			!reading incomplete enum
	e:=checkdupl(owner, d, ns_tags, currblockno)

	if e then
		if e^.nameid<>enumtagid then
			serror_s("Enum tag in use %s",e^.name)
		fi
	fi

!create new incomplete enum tag
	e:=createdupldef(owner,d,enumtagid)
	e^.mode:=createenummode(e)
	e^.blockno:=currblockno
	blockcounts[currblockno]:=1
	return e^.mode
fi

!{ seen, so defining a new enum
e:=checkdupl(owner,d,ns_tags,currblockno)

if e then			!found in this linkage
	if e^.nameid<>enumtagid then
		serror_s("Enum tag in use %s",e^.name)
	fi
	if e^.deflist then					!else filling in incomplete enum
		serror_s("Redefining enum %s",e^.name)
	fi
else						
	e:=createdupldef(owner,d,enumtagid)
	e^.mode:=createenummode(e)
	e^.blockno:=currblockno
	blockcounts[currblockno]:=1
fi

!e points to an enum def which has an empty {...} list
!Now loop reading enum values

readenumnames(owner)

ttnamedef[e^.mode]:=e
return e^.mode
end

proc readenumnames(ref strec owner)=
!at '{'; read set of enum names
ref strec d,e
ref strec ulist,ulistx
int enumseq

ulist:=ulistx:=nil
enumseq:=0
lex()

case owner^.nameid
when procid,moduleid then		!fine
else							!probably inside a struct
	owner:=(currproc|currproc|stmodule)
esac

while lx.symbol=namesym do
	d:=checkdupl(owner,lx.symptr,ns_general,currblockno)
	if d then
		serror_s("enum name reused %s",d^.name)
	fi
	d:=createdupldef(owner,lx.symptr,enumid)
!CPL "CREATED ENUM NAME",D^.NAME,"IN",OWNER^.NAME,NAMENAMES[OWNER^.NAMEID],CURRPROC,STMODULE
	lex()
	if lx.symbol=assignsym then
		lex()
		enumseq:=readconstintexpr()
	fi
	d^.index:=enumseq
	d^.blockno:=currblockno
	blockcounts[currblockno]:=1
	++enumseq	
	if lx.symbol=commasym then
		lex()
!		if lx.symbol=rcurlysym then			!this is allowed
!			serror("enum?")
!		fi
	fi
od
skipsymbol(rcurlysym)
end

function createdotop(int opc, unit p,ref strec d)unit=
!opc is j_dot or j_idot
!Deal with field selection for p.d or p->d
unit q,r,poffset,pb,pc
ref strec e,f,prec,panon,pfield,gend
int m,offset,scale
ref fieldrec fl

!CPL "CREATEDOTOP",jtagnames[opc]
!PRINTUNIT(NIL,P)

!check that m is a proper pointer if needed, and a struct or union
m:=p^.mode
if opc=j_idot then			!
!	if ttbasetype[m]<>tref then
	if not ttisref[m] then
		serror("-> needs pointer")
	fi
	m:=tttarget[m]
fi
case ttbasetype[m]
when tstruct,tunion then
else
	serror(". -> not a struct")
esac

!now need to resolve the field name d
prec:=ttnamedef[m]				!r is record def

f:=d
while f:=f^.nextdupl do
	if f^.owner=prec then
		offset:=f^.offset
		exit
	fi
od

!not found; look for any anon fields
if not f then
	gend:=d						!find generic field name version
	while gend^.prevdupl do
		gend:=gend^.prevdupl
	od

	fl:=prec^.nextfield
	while fl do					!now search linear field list matching generic entries
		if fl^.gendef=gend then
			f:=fl^.def
			offset:=fl^.offset
			exit
		fi
		fl:=fl^.nextfield
	od
fi

if not f then
	terror_ss("Not a field of struct %s %s",d^.name,Strmode(m))
fi


poffset:=createconstunit(offset,tsint)

!will be p->field, or p.field
!p.field: *(p+offset)

if opc=j_idot then				!apply offset to lhs
	p:=createptrop(p)
fi

p:=createunit1(j_dot,p)
p^.offset:=offset

p^.mode:=f^.mode
p:=arraytopointer(p)
fixmemopnd(p)

return p
end

function mulunit(unit p, int elemtype)unit=
!p is an int unit representing some offset i for *(A+i) or A[i]
!apply a scale so that is a byte offset
!t is the element type
int elemsize

if (elemsize:=ttsize[elemtype])<>1 then
	if p^.tag=j_const then
		p^.value:=p^.value*elemsize
	else
		p:=createunit1(j_scale,p)
		p^.scale:=elemsize
		p^.mode:=tptroffset
	fi
fi
return p
end

function divunit(unit p, int elemtype)unit=
int elemsize

if (elemsize:=ttsize[elemtype])<>1 then
	if p^.tag=j_const then
		p^.value:=p^.value/elemsize
	else
		p:=createunit1(j_scale,p)
		p^.scale:=-elemsize
		p^.mode:=tptroffset
	fi
fi
return p
end

function createassignopref(int opc, unit p,q)unit=
!opc is assignsym, addtosym etc
!do assign/addto when is a ref type
!return resulting unit
int pmode,qmode,rmode,elemmode
unit r

pmode:=rmode:=p^.mode
elemmode:=tttarget[pmode]
qmode:=q^.mode

case opc
when assignsym then
	q:=coercemode(q,pmode)
	r:=createunit2(j_assign,p,q)

when addtosym then
	if ttisref[qmode] then		!ref+=ref
		serror("ptr+=ptr")
	fi

	q:=coercemode(q,tptroffset)					!ref+=int
	r:=createunit2(j_addto,p,mulunit(q,elemmode))

when subtosym then
	if ttisref[qmode] then		!ref-=ref
		if not comparemode(pmode,qmode) then
			serror("-= refs don't match")
		fi
		r:=divunit(createunit2(j_sub,p,q),elemmode)
		rmode:=tsint
	else								!ref-=int
		r:=createunit2(j_subto,p,mulunit(q,elemmode))
	fi
else
	serror("Not allowed on ptrs")
esac

r^.mode:=rmode
return r
end

proc addnewfield(ref fieldrec &flist, ref strec d, int offset)=
!new field d has just been created for a record
!add it to the linear list of fields for the record
ref strec e
ref fieldrec f

if d^.name^<>'$' then			!normal field
	f:=pcm_allocz(f^.bytes)
	f^.def:=d
	while d^.prevdupl do			!look for generic entry
		d:=d^.prevdupl
	od
	f^.gendef:=d
	f^.offset:=offset

	f^.nextfield:=flist
	flist:=f

else
	e:=ttnamedef[d^.mode]^.deflist
	while e do
		addnewfield(flist,e,offset+e^.offset)
		e:=e^.nextdef
	od
fi
end

proc pushloop(int looptype)=
!looptype is 'L' or 'S', ie a switch, so not really a loop
if loopindex>=maxnestedloops then
	serror("Too many nested loop or switch")
fi
++loopindex
looptypestack[loopindex]:=looptype
casevaluestack[loopindex]:=nil

end

proc poploop=
if loopindex then
	--loopindex
else
	serror("poploop?")
fi
end

proc addcasevalue(int value)=
ref caserec p

int index:=loopindex
while index and looptypestack[index]<>'S' do
	--index
od
if index=0 then serror("case not inside switch stmt") fi

p:=pcm_alloc(caserec.bytes)
p^.value:=value
p^.nextcase:=casevaluestack[index]
casevaluestack[index]:=p
end

function roundoffset(int offset, alignment)int=
int mask

if structpadding then
	if alignment=1 then return offset fi
	mask:=alignment-1
	while offset iand mask do ++offset od
fi
return offset
end

proc fixmemopnd(unit p)=
int t

!when p refers to a 1- 2- byte value, adjust the type
if ingeneric then return fi

case t:= ttbasetype[p^.mode]
when tschar,tsshort then
	insertunit(p,j_widenmem)
	p^.mode:=tsint
when tuchar,tushort,tbool then
	insertunit(p,j_widenmem)
	p^.mode:=tuint
esac
end

function docast(unit p,int t,hard=1,inplace=0)unit=
!apply cast to unit p
!if no cast needed, then just return p
unit q
int s,opc

s:=p^.mode

!CPL "DOCAST",STRMODE(S), STRMODE(T)

retry::

!if t=tvoid then return p fi


if s=t then return p fi
opc:=0

if s<16 and t<16 then
	opc:=conversionops[s,t]

elsif ttisref[s] and ttisref[t] then
	if checkpointertypes(s,t,hard) then
		p^.mode:=t
		return p
	fi

elsif ttconst[s] then
	s:=ttconsttype[s]
	goto retry
elsif ttconst[t] then
	t:=ttconsttype[t]
	goto retry
!elsif ttisref[t] and (s>=tfirstint and s<=tlastint) and p^.tag=j_const and p^.value=0 then
elsif ttisref[t] and isintcc(s) and p^.tag=j_const and p^.value=0 then
	opc:=soft_c
fi

if opc=0 then
	if not hard then
		cpl Strmode(s)
		cpl Strmode(t)

PRINTUNIT(NIL,P)

		terror_ss("Can't do conversion %s => %s",typename(s),typename(t))
	fi
	opc:=hard_c
fi

case p^.tag
when j_const then		!try and convert
	if eval_convert(p,t,opc) then
		return p
	fi
when j_funcname then
	p^.mode:=t
	return p
when j_add then
	if p^.a^.tag=j_const and p^.b^.tag=j_const then
		p^.value:=p^.a^.value+p^.b^.value
		p^.mode:=t
		p^.tag:=j_const
		return p
	fi
esac

if inplace then
	insertunit(p,j_convert)
	p^.mode:=t
	p^.opcode:=opc
	return nil
else
	q:=createunit1(j_convert,p)
	q^.opcode:=opc
	q^.mode:=t
fi
return q
end

function coercemode(unit p, int t)unit=
int s,opc
unit q

if p^.mode=t then return p fi
docast(p,t,0,1)
return p
end

proc coercemode_inplace(unit p, int t)=
int s,opc
unit q

if p^.mode=t then return fi
docast(p,t,0,inplace:1)
end

proc dostaticassert=
int x
[256]char str
	lex()
	skipsymbol(lbracksym);
	x:=readconstintexpr()
	skipsymbol(commasym)
	checksymbol(stringconstsym)
	if not x then
		memcpy(&.str,lx.svalue,lx.length)
		str[lx.length+1]:=0
		serror(&.str)
	fi
	lex()
	skipsymbol(rbracksym)
end

function createsizeofop(unit p)unit=
unit q
int t,size

!CPL "SIZEOF"
!PRINTUNIT(NIL,P)

t:=p^.mode
switch p^.tag
!when j_nameaddr then
!	size:=ttsize[p^.def^.mode]			!take account of array
when j_name then
	if p^.alength then
		size:=ttsize[p^.def^.mode]/p^.alength			!take account of array
	else
		size:=ttsize[p^.def^.mode]			!take account of array
	fi
when j_const then
	case t
	when trefchar then					!const string
!CPL "CONST STRING SIZEOF"
		size:=p^.slength+1
	when trefwchar then
		size:=(p^.wslength+1)*2
	else
		size:=ttsize[t]
	esac

when j_ptr then
	if ttisref[t] and p^.alength then		!result of array=>ptr conversion
		size:=ttsize[tttarget[t]]*p^.alength
	else
		size:=ttsize[t]
	fi

when j_addptr then
	if p^.alength then	!derived from array expr that converted to pointer
		size:=ttsize[tttarget[t]]*p^.alength
	else
		goto cad1
	fi

when j_addrof then
	if p^.a^.tag=j_name and p^.a^.alength then
		size:=ttsize[p^.a^.def^.mode]
	fi

when j_widenmem then
	return createsizeofop(p^.a)

else
cad1::
	size:=ttsize[t]
endswitch

!q:=createconstunit(size,tsint)
q:=createconstunit(size,tullong)
return q
end

function readgeneric:unit=
!read generic construct; return chosen expr according to type of control expr
!at '_Generic'
	unit pexpr,pmatch,p
	ref paramrec pm
	int m,t,def,oldingeneric,count
	ref strec d

	lex()
	checksymbol(lbracksym)
	lex()
	oldingeneric:=ingeneric
	ingeneric:=1
	pexpr:=readassignexpr()
	ingeneric:=oldingeneric

	m:=pexpr^.mode
	pmatch:=nil
	def:=0
	count:=0

	checksymbol(commasym)

	repeat						!at comma
		lex()					!skip comma
		if lx.symbol=kdefaultsym then
			if def then serror("generic/default twice") fi
			def:=1
			if count=0 then t:=-1 else t:=-2 fi
			lex()
		else
			t:=readcasttype(d,0,pm)
		fi
		checksymbol(colonsym)
		lex()
		p:=readassignexpr()

		if (t=-1 or t=m) then

			pmatch:=p
			++count
		fi
	until lx.symbol<>commasym

	checksymbol(rbracksym)
	lex()
	if not pmatch then serror("Generic: no type match") fi
	if count>1 then serror("Generic: multiple types match") fi

	return pmatch
end

proc readstructinfosym=
ref strec d,e
ref paramrec pm
int m, nfields
filehandle f
ichar name
[256]char str

lex()
m:=readcasttype(d,0,pm)

if ttbasetype[m]<>tstruct then
	serror("Struct type expected")
fi
d:=tttypedef[m]

e:=d^.deflist
nfields:=0
while e do
	++nfields
	e:=e^.nextdef
od

name:=d^.name

!sprintf(&.str,"$%s_info.h",name)
print @&.str,"$",,name,,"_info.h"

f:=fopen(&.str,"w");

!fprintf(f,"memberinfo_t $%s[] = {\n",name)
println @f,"memberinfo_t $",,name,,"[] = {"

e:=ttnamedef[m]^.deflist
nfields:=0

while e do
!	fprintf(f,"    {\"%s\", %d,%d,%d,%d,%d,%d}%s\n", e^.name,
!		int32(e^.mode), int32(ttbasetype[e^.mode]),int32(tttarget[e^.mode]),
!		int32(ttsize[e^.mode]),int32(e^.offset),int32(0),(e^.nextdef|","|""))

	println @f,"    {""#"", #,#,#,#,#,#}#", e.name,
		e.mode, ttbasetype[e.mode], tttarget[e^.mode],
		ttsize[e.mode], e.offset, 0, (e.nextdef|","|"")
	++nfields
	e:=e^.nextdef
od

!fprintf(f,"};\n")
println @f,"};"

!fprintf(f,"enum {$%s_length = %d};\n",name,int32(nfields));
println @f,"enum {$#_length = #};",name,nfields

fclose(f)
end

function getmemmode(unit p)int=
!return mode of p, but if p is a widening unit, see past that to
!the original memory mode
if p^.tag=j_widenmem then
	return p^.a^.mode
else
	return p^.mode
fi
end

function readstrinclude:unit=
	unit p
	ichar text

	lex()
	checksymbol(lbracksym)
	lex()
	p:=readexpression()
	checksymbol(rbracksym)
	lex()
	if p^.tag<>j_const or p^.mode<>trefchar then
		serror("String const expected")
	fi

	text:=cast(readfile(p^.svalue))
!CPL =RFSIZE,p.svalue
	if not text then
		serror_s("Can't read strinclude file: %s",p^.svalue)
	fi

!	return createstringconstunit(text,strlen(text))
	return createstringconstunit(text,rfsize)
end

!proc readpredefmacro(int pdmcode,int lineno)=
!	[256]char str
!	static []ichar monthnames=("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec")
!	rsystemtime tm
!	ichar s
!	int fileno
!
!	case pdmcode
!	when pdm_date then
!		os_getsystime(&tm)
!
!		fprint @&.str, "#-#-#",tm.day,monthnames[tm.month],tm.year:"4"
!
!		lx.symbol:=stringconstsym
!		lx.svalue:=pcm_copyheapstring(&.str)
!
!	when pdm_time then
!		os_getsystime(&tm)
!
!		fprint @&.str,"#:#:#",tm.hour:"2",tm.minute:"z2",tm.second:"z2"
!
!		lx.symbol:=stringconstsym
!		lx.svalue:=pcm_copyheapstring(&.str)
!!	when pdm_file then
!!		lx.symbol:=stringconstsym
!!		fileno:=getfilenox(tk)
!!		if fileno=0 then fileno:=sfileno fi
!!		if sfileno then
!!			lx.svalue:=sourcefilenames[sfileno]
!!		else
!!			lx.svalue:="(File not available)"
!!		fi
!	when pdm_func then
!		lx.symbol:=stringconstsym
!		if currproc then
!			lx.svalue:=currproc^.name
!		else
!			lx.svalue:="???"
!		fi
!	when pdm_line then
!		lx.symbol:=intconstsym
!		lx.value:=lineno
!	when pdm_stdc then
!		lx.symbol:=intconstsym
!		lx.value:=1
!	when pdm_bcc then
!		lx.symbol:=intconstsym
!		lx.value:=1
!	else
!		println pdmcode
!		serror("PDM")
!	esac
!end
!
!
=== cc_genmcl.m 58/77 ===
!M Compiler - x64 Target Code Generator 1
!import main
import msys
import mlib
import clib
import oslib

import cc_decls
import cc_support
import cc_tables
import cc_lib
import cc_libmcl
import cc_blockmcl


global function codegen_mcl(int n)int=
!generate code for module n
ref strec d,e

!if fverbose then
!	println "Generating MCL code:"
!fi
!
!CPL "GG1"

mclinit()
!CPL "GG2"

stmodule:=moduletable[n].stmodule

!do two passes: module decls first, then procs

d:=stmodule^.deflist
while d do
	case d^.nameid
	when staticid then
!CPL "GG3"
		dostaticvar(d)
!CPL "GG4"
	when procid then
		e:=d^.deflist
		while e do
			case e^.nameid
			when staticid then
!CPL "GG5"
				dostaticvar_fn(e)
!CPL "GG6"
			when frameid then
				if e^.code then
					if e^.code^.tag=j_makelist or 
					    ttbasetype[e^.mode]=tarray and e^.code^.tag=j_const then
!CPL "GG7"
						dostaticvar_fn(e)
!CPL "GG8"
					fi
				fi
			esac
			e:=e^.nextdef
		od

	esac
	d:=d^.nextdef
od
modulecode:=mccode

d:=stmodule^.deflist
while d do
	case d^.nameid
	when procid then
		if d^.code then
!CPL "GG9"
			genprocdef(d)
!CPL "GG10"
		fi
	esac
	d:=d^.nextdef
od

return 1
end

proc genprocdef (ref strec p) =	!GENPROCDEF
[256]char str
int paramoffset,nparams,m
ref strec d
int n,lab,np,offset,reg,i,xreg,ismain,structret
ref opndrec ax,bx
[4]int paramtypes

!CPL "*******************************PROCDEF",P^.NAME

setsegment('C')

initmcdest()
setalign(16)
genassem("!------------------------------------")

currproc:=p
dolabel(p)

!do local decls
frameoffset:=0
paramoffset:=retaddrbytes

nparams:=0
d:=p^.deflist
while d do
	switch d^.nameid
	when frameid then
		frameoffset-:=roundsizetg(ttsize[d^.mode])
		d^.offset:=frameoffset
	when paramid then
		d^.offset:=paramoffset
		paramoffset+:=8
		++nparams
		if nparams<=4 then
 paramtypes[nparams]:=d^.mode fi
	endswitch
	d:=d^.nextdef
od

structretoffset:=0
stacksetinstr:=nil
retbeforeblock:=0
if ttsize[p^.mode]>8 then			!when this proc returns a block
	frameoffset-:=8
	structretoffset:=frameoffset
fi
currblocksize:=0					!for when this proc calls a proc that returns a block

framebytes:=-frameoffset
parambytes:=paramoffset-retaddrbytes
iscallbackproc:=iscallbackfn(p)

n:=targetsize-1					!round to 4 or 8
while framebytes iand n do ++framebytes; --frameoffset od
while parambytes iand n do ++parambytes od

setsegment('C')
ismain:=0
if eqstring(p^.name,"main") then
	ismain:=1
	if parambytes then
		genmainprelude()
	fi
if p^.mode<>tsint then
	gerror("main needs int return type")
fi
fi

!CPL "GENPROCENTRY",P^.NAME,=FRAMEBYTES,=PARAMBYTES
genprocentry(framebytes,parambytes)

if nparams then						!1 or more params
	np:=min(4,nparams)
	if p^.paramlist^.flags=pm_variadic then
!CPL "IS VARIADIC FN"
		for i:=np+1 to 4 do
			paramtypes[i]:=tvoid
		od

		np:=4
	fi
	offset:=16

	for i:=1 to np do
		ax:=genireg(rframe,ptrsize)
		ax^.value:=offset
		ax^.valtype:=int_val
		if isrealcc(paramtypes[i]) then
			genmc(m_fmov, ax, genxreg(xr0+i-1,ttsize[paramtypes[i]]))
		else
			genmc(m_mov, ax, genreg(r10+i-1,8))
		fi
		offset+:=8
	od
fi

if structretoffset then
!genindex(int areg=0,ireg=0,scale=1,offset=0,size=0, labno=0, ref strec def=nil)ref opndrec=
	bx:=genindex(areg:rframe,offset:structretoffset)
	genmc(m_mov,bx,genreg(r9,8))
fi

!CPL "PROC ENTRY",=ISCALLBACKPROC
if iscallbackproc then
	strcpy(&.str,"m$pushcallback*")
	genmc(m_call, genname(&.str))
fi

stackaligned:=initial_stackalignment

retindex:=lab:=createfwdlabel()

gencomment("-------------------------------------------------")

enterproc(p^.name)
!genmc(m_sub,genreg(rstack,8),genint(32))
!genmc(m_mov,genreg(r10,8),genstrimm(p^.name,p^.namelen))
!genmc(m_call, genname("$showfunc*"))
!genmc(m_add,genreg(rstack,8),genint(32))


do_stmt(p^.code)

definefwdlabel(retindex)
gencomment("-------------------------------------------------")

if ismain then
!	pushstack(40)					!stack misaligned here
	pushstack(32)
	genmc(m_mov, genreg(r10,8), genint(0));
	genmc(m_call, genname("exit*"))
else
	leaveproc(p^.name)
	genreturn(framebytes,parambytes)
fi

!GENCOMMENT("PROC BODY GOES HERE")
if p^.mode<>tvoid then
	if not checkblockreturn(p^.code) then
		unless eqstring(p.name,"main") then
			gerror_s("Function needs explicit return statement: %s",p.name)
		end
	fi
fi

gencomment("")

p^.mclcode:=mccode
end

function checkblockreturn(unit p)int=
!p is any statement
!check p, or the last statement of a block, or the last statement of any
!nested block, a return, or is a unit yielding some value (as explicit return
!statement not needed)
! return 1/0 for return/not return
unit e,wt
int m,res

!CPL "CHECKBLOCK",JTAGNAMES[P.TAG]

!RETURN 1
IF not FMODERN THEN RETURN 1 FI
if p=nil then return 0 fi

m:=p.mode

case p^.tag
when j_return then			!that's an easy one...
	return 1
!when j_stop then
!	return 1
when j_if then
!	p.ifretflag:=1
	return checkblockreturn(p^.b) and checkblockreturn(p^.c)		!all branches must have a return

when j_switch then
	RETURN 1;
	return checkblockreturn(p.b)

when j_block then
	e:=p^.a
	if e then
		while e and e^.nextunit do
			e:=e^.nextunit
		od
		return checkblockreturn(e)
	fi

when j_labelstmt then
	return checkblockreturn(p.a)

when j_goto, j_while, j_dowhile then
	return 1;

!when j_case, j_switch, j_docase, j_doswitch then
!	p.ifretflag:=1
!	wt:=p^.b
!	while wt do
!		if not checkblockreturn(wt^.b) then
!			return 0
!		fi
!
!		wt:=wt^.nextunit
!	od
!
!	return checkblockreturn(p^.c)		!else

!when j_assem then						!assume yes
!	return 1
esac

!if jisexpr[p.tag] and m<>tvoid then
!	return 1							!any non-void expr allowed as return value
!else
	return 0
!fi
end

proc dolabel(ref strec d)=
[256]char str

strcpy(&.str,"`")
strcat(&.str,getfullname(d))
strcat(&.str,(isexported(d)|"::"|":"))

genmc(m_labelname,genname(&.str))
end

proc dolabel_fn(ref strec d,int dollar=0)=
[256]char str

!sprintf(&.str,"`%s%s.%s.%d:",(dollar|"$"|""),d^.owner^.name,d^.name,int32(d^.blockno))
fprint @&.str,"`##.#.#:",(dollar|"$"|""),d.owner.name,d.name,d.blockno

genmc(m_labelname,genname(&.str))
end

proc dostaticvar(ref strec d)=
int align

!CPL "DOSTATIC",D.NAME

case d^.scope
when imported_scope then
	return
esac

align:=getalignment(d^.mode)

if d^.code then
	setsegment('I',align)

	dolabel(d)
	genidata(d^.code)
else
	setsegment('Z',align)
	dolabel(d)
	genmc(m_resb,genint(ttsize[d^.mode]))
fi
end

proc dostaticvar_fn(ref strec d)=
!statics inside procs
int align

case d^.scope
when imported_scope then
	dostaticvar(d)
	return
esac

align:=getalignment(d^.mode)

if d^.code then
	setsegment('I',align)
	dolabel_fn(d,d^.nameid=frameid)
	genidata(d^.code)
else
	setsegment('Z',align)
	dolabel_fn(d,0)

	GENMC(M_RESB,GENINT(TTSIZE[D^.MODE]))
fi
end

proc genprocentry(int fbytes,pbytes)=
!proc entry code

if fbytes or pbytes then			!need frame pointer
	genmc(m_push,dframeopnd)
	genmc(m_mov,dframeopnd,dstackopnd)

!the call and the push means stack is aligned at this point, so keep
!fbytes to multiple of 16
	if fbytes then
		pushstack(roundto(fbytes,16))
!		pushstackfp(roundto(fbytes,16))
	fi
else
	pushstack(8)					!keep aligned
fi

stacksetinstr:=mccodex
end

proc genidata(unit p,int doterm=1,am=1,offset=0)=
int t,length,n,i,j,nwords,offset1,offset2,size,padding,isunion
unit q,a,b
ref strec d
real32 sx
[256]char str
[16]char str2
ref opndrec ax

t:=p^.mode
a:=p^.a
b:=p^.b

!PRINTUNIT(NIL,P)

!CPL "GENIDATA",JTAGNAMES[P^.TAG],=offset

case p^.tag
when j_makelist then
	n:=p^.count					!number of supplied params
	if ttbasetype[t]=tarray then
		length:=ttlength[t]			!actual length of array
		q:=a
		for i:=1 to n do
			genidata(q)
			q:=q^.nextunit
		od
		if n<length then			!rest will be zeros
			n:=(length-n)*ttsize[tttarget[t]]		!bytes left
			while n>=8 do
				genmc(m_dq,genint(0,8));
				n-:=8
			od
			to n do
				genmc(m_db,genint(0));
			od
		fi
	else
		isunion:=ttbasetype[t]=tunion

		d:=ttnamedef[t]^.deflist
		size:=ttsize[t]				!total bytes in struct
		offset1:=offset2:=0			!offset so far; 1/2 are in idata/in struct
		q:=a
		for i:=1 to n do
			genidata(q,0)
			if ttbasetype[q^.mode]=tref and q^.strarray then	!IMMEDIATE STRING
				offset1+:=q^.slength
			else
				offset1+:=ttsize[q^.mode]
			fi
			d:=d^.nextdef
			if d and not isunion then
				offset2:=d^.offset
			else
				offset2:=size
			fi

			padding:=offset2-offset1
			if padding>0 then
				padding:=offset2-offset1
				if padding>0 then
					genmc(m_resb,genint(padding))
				fi
				offset1:=offset2
			fi
			q:=q^.nextunit
		od
		if offset2<size then
			n:=size-offset2
			while n>=8 do
				genmc(m_dq,genint(0,8));
				n-:=8
			od
			to n do
				genmc(m_db,genint(0));
			od
		fi
	fi
	return
when j_const then
!	if t>=tfirstint and t<=tlastreal then

	if isintcc(t) or isrealcc(t) then
		if t=tfloat then
			sx:=p^.xvalue
!			genmc(m_dd,genint(int@(sx),4))
			genmc(m_dd,genint(int32@(sx),4))
		else
			genmc((ttsize[t]|m_db, m_dw, 0, m_dd, 0,0,0, m_dq|0),genint(p^.value,ttsize[t]))
		fi
	elsif ttbasetype[t]=tref then
!CPL "GENIDATA/REF",STRMODE(T)
		padding:=0
doref::
		if p^.value=0 then
			genmc(m_dq,genint(0,8))
		elsif p^.strarray then					!immediate string (char[])
!CPL "GENIDATA/STRARRAY",strmode(tttarget[t])
			if ttsize[tttarget[t]]=1 then
				genmc(m_defstr,genstrimm(p^.svalue,p^.slength))
			else
				genmc(m_defwstr,genwstrimm(p^.wsvalue,p^.wslength))
			fi
			if padding>0 then
				genmc(m_resb,genint(padding))
			fi

		elsif p^.isstrconst then
!CPL "STRING"
			genmc(m_dq, genstrimm(p^.svalue,p^.slength))
			if padding>0 then
				genmc(m_resb,genint(padding))
			fi
		elsif p^.iswstrconst then
!CPL "WSTRING"
			genmc(m_dq, genwstrimm(p^.wsvalue,p^.wslength))
			if padding>0 then
				genmc(m_resb,genint(padding))
			fi
		else
			genmc(m_dq, genint(p^.value))
		fi
	elsif ttbasetype[t]=tarray then
		padding:=(ttlength[t]-p^.slength)*ttsize[tttarget[t]]
		goto doref
	else
		CPL Strmode(t)
		GERROR("IDATA/SCALAR")
	fi
	return
when j_name, j_funcname then
	d:=p^.def
	case d^.nameid
	when staticid,procid then
		ax:=genmemaddr_d(d)
		if ax then
			ax:=applyoffset(ax,offset)
		fi
		genmc((am=0 or ttsize[p^.mode]=8|m_dq|m_dd), ax)

	else
		gerror("Idata &frame",p)
	esac	
	return
when j_add then
	if a^.tag=j_name and b^.tag=j_const then
		d:=a^.def
		case d^.nameid
		when staticid then
			strcpy(&.str,"`")
			if d^.scope=function_scope then
				strcat(&.str,currproc^.name)
				strcat(&.str,",")
			fi
			strcat(&.str,d^.name)
			strcat(&.str,"+")

!			sprintf(&.str2,"%lld",b^.value)
			getstrint(b.value, &.str2)

			strcat(&.str,&.str2)
			genmc(m_dq, genname(&.str))
		else
			gerror("Add/Idata &frame")
		esac	
	elsif a^.tag=j_const and b^.tag=j_const and ttbasetype[a^.mode]=tref then		!ASSUME REF+REF
!		sprintf(&.str,"%lld+%lld",a^.value,b^.value)
		print @&.str,a^.value,,"+",,b^.value

		genmc(m_dq,genname(&.str))

	else
		gerror("1:Runtime or unsupported expr in static data")
	fi
	return
when j_addrof then
	if a^.tag=j_ptr then
		genidata(a^.a,offset:offset)
	else
		genidata(a, am:0,offset:offset)
	fi

when j_addptr,j_subptr then
	if b^.tag<>j_const then gerror("Complex ptr expr in static data") fi
	genidata(a,offset:b^.value*p^.ptrscale+offset)

when j_convert then
	genidata(a,offset:offset)

else
PRINTUNIT(NIL,P)
	gerror("2:Runtime expr in static data",p)
esac
end

proc genmainprelude=

genassem("	sub	Dstack,152")
genassem("	sub	Dstack,8")
genassem("	lea	D0,[Dstack+8]")
genassem("	push	D0")
genassem("	sub	Dstack,32")
genassem("	lea	D0,[Dstack+196]")
genassem("	mov	[Dstack],D0")
genassem("	lea	D0,[Dstack+184]")
genassem("	mov	[Dstack+8],D0")
genassem("	lea	D0,[Dstack+176]")
genassem("	mov	[Dstack+16],D0")
genassem("	mov	A0,0")
genassem("	mov	[Dstack+24],A0")
genassem("	mov	D10,[Dstack]")
genassem("	mov	D11,[Dstack+8]")
genassem("	mov	D12,[Dstack+16]")
genassem("	mov	D13,[Dstack+24]")
genassem("	call	__getmainargs*")
genassem("	add	Dstack,48")
genassem("	sub	Dstack,32")
genassem("	mov	A0,[Dstack+180]")
genassem("	mov	[Dstack],A0")
genassem("	mov	D0,[Dstack+168]")
genassem("	mov	[Dstack+8],D0")
genassem("	mov	D10,[Dstack]")
genassem("	mov	D11,[Dstack+8]")
genassem("	call	.main")
genassem("	mov A10,A0")
genassem("	call exit*")
gencomment("")
genassem(".main::")

end

=== cc_libmcl.m 59/77 ===
!M Compiler - x64 Target Code Generator 3
!import main
import msys
import mlib
import clib
import oslib

import cc_decls
import cc_support
import cc_tables
import cc_lib

GLOBAL INT NMEMADDR
GLOBAL INT NMEM

!const fdosimple=0
const fdosimple=1

const cc1 = 1
const cc2 = 2
const cc3 = 3
global const ccmode=cc3

global const ptrsize=8
global const targetsize=8
global const retaddrbytes=targetsize*2

global int fshowfullnames=1		! show fully qualified names in output
global int fshowmsource=0

global int fabsused=0
global int fchsused=0
global int kk0used=0

global int retindex
global int stackaligned
global const initial_stackalignment = 1

!These opcodes represent a more general, orthogonal version of x64:
!Int registers R0 to Rmax (Rmax is 15 for actual x64) (8, 16, 32, 64 bits)
!Float registers X0 to Xmax (32, 64 bits)
!Fewer restrictions on:
! imm fields, and width of imm field (can be up to 64 bits if needed)
! operands that can be pushed or popped
! register needed for variable shift (need not be cl)
! Extra reg for double-with mul or div is not specified; that will need to
!  be known to code generator
! Uses irem/urem op that needs expanding to multiple ops
! Other opcodes may need expanding to multiple too

global tabledata() []ichar mclnames =

	(m_comment,			$),	! str
	(m_blank,			$),	!

	(m_label,			$),	! lab
	(m_labelname,		$),	!

	(m_mov,				$),	! R,imm; R,R; R,mem; mem,imm; mem,R
	(m_push,			$),	! imm; R; mem; X
	(m_pop,				$),	! R; mem; X
	(m_lea,				$),	! mem
	(m_cmovcc,			$),	! cc,R,R; cc,R,mem
	(m_fmov,			$),	! X,imm, X,X; X,mem, mem,X; R,X; X,R (no conversions)

	(m_iwiden,			$),	! R,R; R,mem; R (single operand: doubles existing width)
	(m_uwiden,			$),	! R,R; R,mem; R
	(m_inarrow,			$),	! R,R (truncates to dest width then widens to original width)
	(m_unarrow,			$),	! R,R

	(m_call,			$),	! imm; R; mem
	(m_ret,				$),	!
	(m_retn,			$),	! imm

	(m_jmp,				$),	! lab
	(m_jmpcc,			$),	! cond, lab
	(m_exch,			$),	! R,R; R,mem

	(m_add,				$),	! R,imm; R,R; R,mem; mem,R
	(m_sub,				$),	!
	(m_imul,			$),	!
!	(m_umul,			$),	!

	(m_idiv,			$),	! R,imm; R,R; R,mem; mem,R
	(m_udiv,			$),	!

	(m_irem,			$),	! R,imm; R,R; R,mem; mem,R
	(m_urem,			$),	!

	(m_and,				$),	! R,imm; R,R; R,mem; mem,R
	(m_or,				$),	!
	(m_xor,				$),	!
	(m_test,			$),	!

	(m_cmp,				$),	!

	(m_shl,				$),	! R,imm; R,R; R,mem; mem,R (varible count may not be CL)
	(m_ishr,			$),	!
	(m_ushr,			$),	!

	(m_neg,				$),	! R; mem
	(m_not,				$),	! R; mem

	(m_inc,				$),	! R; mem
	(m_dec,				$),	! R; mem
	(m_setcc,			$),	!

	(m_fneg,			$),	! X
	(m_fabs,			$),	! X
	(m_fsqrt,			$),	! X,X; X,mem

	(m_fadd,			$),	! X,imm; X,X; X,mem
	(m_fsub,			$),	!
	(m_fmul,			$),	!
	(m_fdiv,			$),	!

	(m_fcmp,			$),	!

	(m_ufix,			$),	! R,X; R,mem
	(m_ifix,			$),	! R,X; R,mem
	(m_ufloat,			$),	! X,R; X,mem
	(m_ifloat,			$),	! X,R; X,mem
	(m_fwiden,			$),	! X,X; X,mem
	(m_fnarrow,			$),	! X,X; X,mem

	(m_fmin,			$),	! X,X; X,mem
	(m_fmax,			$),	! X,X; X,mem

	(m_resb,			$),	! imm,...
	(m_db,				$),	! imm,...

	(m_dw,				$),	!
	(m_dd,				$),	!
	(m_dq,				$),	!
	(m_defstr,			$),	! string constant in situ, maps to eg "db 'ABC',13,10,0"
	(m_defwstr,			$),	!
	(m_align,			$),	! imm
	(m_segment,			$),	! seg
	(m_cdq,				$),	!

	(m_assem,			$),	! str
	(m_end,				$),	!			!marks end of non-specific opcodes

!The following are extra-specific opcodes for x64 target
	(mx_imul2,			$),
	(mx_sar,			$),
	(mx_shr,			$),
	(mx_div,			$),
	(mx_movzx,			$),
	(mx_movsx,			$),
	(mx_inot,			$),
	(mx_mul,			$),

	(mx_movd,			$),
	(mx_movq,			$),

	(mx_addss,			$),
	(mx_addsd,			$),
	(mx_subss,			$),
	(mx_subsd,			$),
	(mx_mulss,			$),
	(mx_mulsd,			$),
	(mx_divss,			$),
	(mx_divsd,			$),
	(mx_comiss,			$),
	(mx_comisd,			$),
	(mx_cvtsi2ss,		$),
	(mx_cvtsi2sd,		$),
	(mx_cvtss2sd,		$),
	(mx_cvtsd2ss,		$),
	(mx_cvttss2si,		$),
	(mx_cvttsd2si,		$),

	(mx_sqrtss,			$),
	(mx_sqrtsd,			$),
	(mx_minss,			$),
	(mx_maxss,			$),
	(mx_minsd,			$),
	(mx_maxsd,			$),
	(mx_xorps,			$),
	(mx_xorpd,			$),
	(mx_andps,			$),
	(mx_andpd,			$),

end

global tabledata() [0:]ichar opndnames =
	(a_none=0,	$),
	(a_reg,		$),
	(a_imm,		$),
	(a_strimm,	$),		!immediate string (for comments, m_assem etc)
	(a_mem,		$),		!all memory modes: [d], [R], [R*4+R2+d+imm] etc
	(a_code,	$),		!mcl code seq
	(a_xreg,	$),		!xmm register
end

global tabledata() [0:]ichar regnames =
	(rnone=0,	$),
	(r0,		$),
	(r1,		$),
	(r2,		$),
	(r3,		$),
	(r4,		$),
	(r5,		$),
	(r6,		$),
	(r7,		$),
	(r8,		$),
	(r9,		$),
	(r10,		$),
	(r11,		$),
	(r12,		$),
	(r13,		$),
	(rframe,	$),
	(rstack,	$),
	(rfpu,		$)
end

global const rcx=r10
global const rdx=r11
global const r14=rframe
global const r15=rstack

global tabledata() [0:]ichar xregnames =
	(xnone=0,	$),
	(xr0,		$),
	(xr1,		$),
	(xr2,		$),
	(xr3,		$),
	(xr4,		$),
	(xr5,		$),
	(xr6,		$),
	(xr7,		$),
	(xr8,		$),
	(xr9,		$),
	(xr10,		$),
	(xr11,		$),
	(xr12,		$),
	(xr13,		$),
	(xr14,		$),
	(xr15,		$)
end

global tabledata() [0:]ichar condnames, [0:]ichar asmcondnames =

	(ov_cond=0,	"ov",	"o"),
	(nov_cond=1,	"nov",	"no"),

	(ltu_cond=2,	"ltu",	"b"),
	(geu_cond=3,	"geu",	"ae"),

	(eq_cond=4,	"eq",	"z"),
	(ne_cond=5,	"ne",	"nz"),

	(leu_cond=6,	"leu",	"be"),
	(gtu_cond=7,	"gtu",	"a"),

	(s_cond=8,	"s",	"s"),
	(ns_cond=9,	"ns",	"ns"),

	(p_cond=10,	"p",	"p"),
	(np_cond=11,	"np",	"np"),

	(lt_cond=12,	"lt",	"l"),
	(ge_cond=13,	"ge",	"ge"),

	(le_cond=14,	"le",	"le"),
	(gt_cond=15,	"gt",	"g"),

	(flt_cond=16,	"flt",	"b"),		!special floating point codes
	(fge_cond=17,	"fge",	"ae"),
	(fle_cond=18,	"fle",	"be"),
	(fgt_cond=19,	"fgt",	"a"),
	(feq_cond=20,	"feq",	"z"),
	(fne_cond=21,	"fne",	"nz")
end

global tabledata() [0:]ichar valtypenames =
	(no_val=0,		$),
	(int_val,		$),
	(real_val,		$),
	(string_val,	$),
	(wstring_val,	$),
	(label_val,		$),
	(name_val,		$),
	(stringix_val,	$),
	(wstringix_val,	$),
	(intix_val,		$),
	(realix_val,	$),
end

global record opndrec = 	!32 bytes
	ref strec def		!nil, or handle of strec for var name
	union
		int64 value		!int/real/string value
		real64 xvalue
		ichar svalue
		ref word16 wsvalue
	end
	int32 size		!byte size of operand: usually 4,8, also 1,2 and N for block
	union
		int32 index		!int/real/string index
		int32 slength
		int32 wslength
	end

	byte mode		!a_reg etc, low level operand details
	byte reg			!0, or main register
	byte regix		!0, or index register
	byte valtype
	byte scale		!1, or scale factor for regix
	byte isglobal	!0/1 for labels
	byte isfloat	!used with realix_val

	byte s3		!spare

end

global record mclrec = 	!32 bytes
	ref mclrec nextmcl
	ref opndrec a,b
	byte opcode
	byte cond
	byte fileno
	byte spare
	int32 lineno
end

global ref mclrec mccode, mccodex		!genmc adds to this linked list

global ref mclrec modulecode			!mclrec linked list for module-level data

global int currsegment=0		!

global int currzdataalign=0
global int curridataalign=0

global int framebytes			!local stackframe size
global int parambytes
global int frameoffset
global int isthreadedproc
global int iscallbackproc

global int structretoffset			!0, or offset of R9 copy within struct
global ref mclrec stacksetinstr		!caller of any fn: instr that sets sp
!global int structrettemp			!caller of any fn: 0, or offset of struct area
global int currblocksize			!0, or set to largest block ret value
global int retbeforeblock			!1 when blockcall follows explicit return
!global int currblockoffset			!0, or current offset of currblocksize area

global ref opndrec dstackopnd
global ref opndrec dframeopnd


!global int labelno=0
global ref opndrec zero_opnd=nil
global unit zero_unit

strbuffer sbuffer
global ref strbuffer dest=&sbuffer

global proc mclinit=

!CPL "MCLINIT"
zero_opnd:=genint(0)
zero_unit:=createconstunit(0,tsint)
zero_unit^.mode:=tsint
dframeopnd:=genreg(rframe,8)
dstackopnd:=genreg(rstack,8)

initmcdest()

end

global function gettargetdata(int f64)int=
CPL "GETTARGETDATA"
RETURN 1
end

global proc initmcdest=
!reset mccode/mccodex
!called should have saved any values from last linked list 

mccode:=mccodex:=nil
end

global proc genmc(int opcode, ref opndrec a=nil,b=nil)=
!global proc genmc(int opcode, ref opndrec a=nil,b=cast(0x1234))=
ref mclrec m, oldm

m:=pcm_alloc(mclrec.bytes)

m^.lineno:=clineno
m^.opcode:=opcode

m^.a:=a
m^.b:=b

case opcode
when m_mov then
	if a and a^.mode=a_reg and b and b^.mode=a_mem then
		oldm:=mccodex
		if oldm and oldm^.opcode=m_mov and oldm^.a^.mode=a_mem and oldm^.b^.mode=a_reg then
			if  sameoperand(a,oldm^.b) and sameoperand(oldm^.a,b) then
				return 			!don't generate the load
			fi
		fi
	fi
when m_jmp then
	case mccodex^.opcode
	when m_ret, m_retn, m_jmp then
!CPL "SUPPRESS JMP BECAUSE PREVIOUS OP IS",MCLNAMES[MCCODEX^.OPCODE]
		return
	esac
when m_push,m_pop then
	stackaligned ixor:=1
!when m_uwiden, m_iwiden then
!	 if b^.mode=a_imm then
!	fi
esac

if mccode then
	mccodex^.nextmcl:=m
	mccodex:=m
else
	mccode:=mccodex:=m
fi
end

global proc genmc_cond(int opcode, cond, ref opndrec a=nil,b=nil)=
genmc(opcode,a,b)
mccodex^.cond:=cond
end

global function lastmc:ref mclrec=
return mccodex
end

global proc genmcstr(int opcode,ichar s)=
!as genmc but uses a single immediate string operand

genmc(opcode,genstrimm(s))
end

function newopnd:ref opndrec=
ref opndrec a
a:=pcm_allocz(opndrec.bytes)
return a
end

global function duplopnd(ref opndrec a)ref opndrec=
ref opndrec b
b:=pcm_alloc(opndrec.bytes)
b^:=a^
return b
end

global function genxreg(int xreg,size=8)ref opndrec=
ref opndrec a

a:=newopnd()

a^.mode:=a_xreg
a^.reg:=xreg
a^.size:=size
return a
end

global function genindex(int areg=0,ireg=0,scale=1,offset=0,size=0, labno=0, ref strec def=nil)ref opndrec=
!construct a mem address mode
ref opndrec a
a:=newopnd()

a^.mode:=a_mem
a^.reg:=areg

a^.regix:=ireg
a^.scale:=scale
a^.size:=(size|size|scale)

a^.value:=offset
if offset then a^.valtype:=int_val fi

a^.def:=def

if labno then		!assume label no
	a^.valtype:=label_val
	a^.value:=labno

elsif def and isframe(def) then
	if areg then gerror("gen/index/areg") fi
	a^.reg:=rframe
fi
!CPL =OFFSET,=DEF.NAME
return a
end

proc writemclblock(ref mclrec m)=
!block single block of mc code, usually belonging to one proc
!initstr=1 to initialise string o/p for single block
!initgenstr() when initstr
int i

i:=1
while m do
	writemcl(i,m)
	++i
	m:=m^.nextmcl
od
end

global function writemclcode(ichar caption,int nmodule)ref strbuffer=
!write all mcl code in system by scanning all procs
!mcl code is only stored per-proc
ref strec d

gs_init(dest)

gs_strln(dest,caption)
gs_strln(dest,"---------------------------------------------")

gs_strln(dest,"MODULE CODE")
writemclblock(modulecode)
gs_strln(dest,"---------------------------------------------")

d:=moduletable[nmodule].stmodule^.deflist

while d do
	if d^.nameid=procid and d^.mclcode then
		gs_str(dest,"PROC:")
		gs_strln(dest,d^.name)
		writemclblock(d^.mclcode)
	fi
	d:=d^.nextdef
od

gs_strln(dest,"---------------------------------------------")

return dest
end

global proc gencomment(ichar s)=
if s=nil or s^=0 then
	genmc(m_blank)
else
	genmcstr(m_comment,s)
fi
end

global function genstrimm(ichar s,int length=-1)ref opndrec=
ref opndrec a
a:=newopnd()
a^.mode:=a_imm
if length<0 then
	length:=strlen(s)
fi
a^.svalue:=pcm_alloc(length+1)
memcpy(a^.svalue,s,length+1)

a^.valtype:=string_val
a^.size:=ptrsize
a^.slength:=length
return a
end

global function genwstrimm(ref word16 s,int length=-1)ref opndrec=
ref opndrec a
a:=newopnd()
a^.mode:=a_imm
!if length<0 then
!	length:=strlen(s)
!fi
a^.wsvalue:=pcm_alloc(length*2+2)
memcpy(a^.wsvalue,s,(length+1)*2)

a^.valtype:=wstring_val
a^.size:=ptrsize
a^.slength:=length
return a
end

global function genname(ichar s)ref opndrec=
ref opndrec a
a:=newopnd()
a^.mode:=a_imm
a^.svalue:=pcm_copyheapstring(s)
a^.valtype:=name_val
a^.size:=ptrsize
return a
end

proc writemcl(int index,ref mclrec mcl)=

GS_STRLN(DEST,STRMCL(MCL))

end

global function strmcl(ref mclrec mcl)ichar=
static [512]char str
[512]char opnds
[256]char opnd2
[128]char opcname
ref opndrec a,b
int opcode,cond,sizepref

!CPL "STRMCL",MCLNAMES[MCL.OPCODE]
opcode:=mcl^.opcode
cond:=mcl^.cond
a:=mcl^.a
b:=mcl^.b

case opcode
when m_assem then
	return a^.svalue
when m_blank then
	return ""
when m_comment then
!	sprintf(&.str,";%s",a^.svalue)
	print @&.str,";",,a.svalue
	return &.str

when m_labelname then
!	sprintf(&.str,"%s",a^.svalue)
	strcpy(&.str,a^.svalue)
	return &.str

when m_label then
	if b then
		fprint @&.str,"L#:#	<#>",a.value,(a.isglobal|":"|""),b.def.name

	else
		fprint @&.str,"L#:#",a.value,(a.isglobal|":"|"")
	fi
	return &.str

esac

case opcode
when m_jmpcc then
!	sprintf(&.opcname,"j%s",asmcondnames[cond])
	print @&.opcname,"j",,asmcondnames[cond]

when m_setcc then
!	sprintf(&.opcname,"set%s",asmcondnames[cond])
	print @&.opcname,"set",,asmcondnames[cond]

when m_cmovcc then
!	sprintf(&.opcname,"cmov%s",asmcondnames[cond])
	print @&.opcname,"cmov",,asmcondnames[cond]

else
	strcpy(&.opcname,mclnames[opcode]+2)
esac

ipadstr(&.opcname,11," ")
!sprintf(&.str,"\t%s",&.opcname)
print @&.str,"\t",,&.opcname

if a and b then		!2 operands
	sizepref:=needsizeprefix(opcode,a,b)

	strcpy(&.opnd2,stropnd(b,sizepref))
!	sprintf(&.opnds,"%s,\t%s", stropnd(a,sizepref),&.opnd2)
	fprint @&.opnds,"#,\t#", stropnd(a,sizepref),&.opnd2

elsif a and a^.mode then								!1 operand
	if opcode=m_call then
		strcpy(&.opnds,stropnd(a,0))
	else
		strcpy(&.opnds,stropnd(a,1))
	fi
else
	opnds[1]:=0
fi

if opnds[1] then
	strcat(&.str,&.opnds)
fi

return &.str
end

global function stropnd(ref opndrec a,int sizeprefix=0,debug=0)ichar=
static [512]char str
[128]char str2
ichar plus,t

case a^.mode
when a_reg then
	return getregname(a^.reg,a^.size)

when a_imm then
	return strvalue(a)

when a_mem then
!	sprintf(&.str,"%s[",getsizeprefix(a^.size,sizeprefix))
	print @&.str,getsizeprefix(a^.size,sizeprefix),,"["

	plus:=""
	if a^.reg then
		strcat(&.str,getregname(a^.reg,ptrsize))
		plus:="+"
	fi
	if a^.regix then
		strcat(&.str,plus)
		strcat(&.str,getregname(a^.regix,ptrsize))
		plus:="+"
		if a^.scale>1 then
!			sprintf(&.str2,"*%d",int32(a^.scale))
			print @&.str2,"*",,a.scale
			strcat(&.str,&.str2)
		fi
	fi
	if a^.def or a^.valtype then			!.valtype should be 'I' if used
		t:=strvalue(a)
		if t^<>'-' then
			strcat(&.str,plus)
		fi
		strcat(&.str,t)
	fi
	strcat(&.str,"]")
when a_strimm then
!	sprintf(&.str,"/%s/*%d",a^.svalue,int32(a^.slength))
	fprint @&.str,"/#/*#",a.svalue,a.slength

when a_xreg then
	return fgetregname(a^.reg,a^.size)

else
	return "<BAD OPND>"
esac

return &.str
end

global function strvalue(ref opndrec a)ichar=
static [512]char str
[128]char str2
ref strec def
int64 value

def:=a^.def
value:=a^.value

if def then
	case def^.nameid
	when staticid then
		if def^.owner^.nameid=procid then
!			sprintf(&.str,"`%s.%s.%d",def^.owner^.name,def^.name,int32(def^.blockno))
			fprint @&.str,"`#.#.#",def.owner.name,def.name,def.blockno

		else
			strcpy(&.str,getfullname(def))
			if isimported(def) then
				strcat(&.str,"*")
			fi
		fi
	when frameid, paramid then
		strcpy(&.str,getfullname(def))
	else
		strcpy(&.str,getfullname(def))
		if isimported(def) then
			strcat(&.str,"*")
		fi
	esac
	if a^.valtype=int_val and value<>0 then
!		sprintf(&.str2,"%s%lld",(value>0|"+"|""),value)
		print @&.str2,(value>0|"+"|""),,value
		strcat(&.str,&.str2)
	fi
	return &.str
fi

case a^.valtype
when int_val,intix_val then
!	GETSTRINT(VALUE,&.STR)
	getstrint(value,&.str)
!str[1]:=0

when real_val,realix_val then
!	sprintf(&.str,"%f (%s)",a^.xvalue, (a^.size=8|"double"|"float"))
!	fprint @&.str,"# (#)",a.xvalue, (a^.size=8|"xxxdouble"|"float")
	print @&.str,a.xvalue

when string_val,stringix_val then
	if strlen(a^.svalue)+4<str.len then
!		sprintf(&.str,"\"%s\"*%d",a^.svalue,int32(a^.slength))
		fprint @&.str,"\"#\"*#",a.svalue,a.slength
	else
		return "<LONGSTR>"
	fi
when wstring_val,wstringix_val then
	return "<WSTRING>"
when name_val then
	return a^.svalue
when label_val then
	print @&.str,"L",,value
!	print @&.str,"L"
else
	str[1]:=0
esac

return &.str
end

global proc setsegment(int seg,align=1)=
!seg is 'D', 'Z', 'C', 'R' for data, zdata, code, rdata
if seg=currsegment then
	return
fi
case seg
when 'I' then genmc(m_segment,genname("idata"))
when 'Z' then genmc(m_segment,genname("zdata"))
when 'C' then genmc(m_segment,genname("code"))
when 'R' then genmc(m_segment,genname("rodata"))
esac
currsegment:=seg
currzdataalign:=curridataalign:=0
setalign(align)
end

global function getprocname(ref strec d)ichar=
	if eqstring(d^.name,"main") then
		return "main"
	elsif eqstring(d^.name,"start") then
		return "start"
	else
		return getdottedname(d)
	fi
	return ""
end

global function widenstr(ichar s,int w)int=
!take string s, return left-justified in field at least w wide
!extend w when s is longer, ensuring at least 2 spaces at right
!w is extended in 8-char increments, to ensure successive lines of names aren't too ragged
!return new length, not new padded string

while strlen(s)>=(w-2) do
	w+:=8
od  
return w
end

global proc genassem(ichar s)=
genmcstr(m_assem,s)
end

global function strlabel(int n)ichar=
static [16]char str
!sprintf(&.str,"L%d",int32(n))
print @&.str,"L",,n
return &.str
end

global function makeindirect(ref opndrec a,int size=0)ref opndrec =
!turn m reg operand into indirect mem version
ref opndrec b

b:=duplopnd(a)

case b^.mode
when a_reg then
	b^.mode:=a_mem
else
CPL =STROPND(B)
	gerror("makeind")
esac
if size then b^.size:=size fi
return b
end

global function applyoffset(ref opndrec a,int offset,int size=0)ref opndrec=
!astr is an asm operand
!add possible byte offset
ref opndrec b

if offset=0 and size=0 then
	return a
fi
b:=duplopnd(a)
b^.value+:=offset
b^.valtype:=int_val
if size then
	b^.size:=size
fi

return b
end

global function applysize(ref opndrec a,int size)ref opndrec=
!astr is an asm operand
!add possible byte offset

if a^.size<>size then
	a:=duplopnd(a)
	a^.size:=size
fi
return a
end

global function isframe(ref strec d)int=
!don't know how to mark non-frame temps
!might just look at enclosing proc
case d^.nameid
when frameid, paramid then
	return 1
esac
return 0
end

global proc genreturn(int fbytes,pbytes)=
!assume returning from currproc
[256]char str
int iscallback

!CPL "GENRET",CURRPROC^.NAME,FBYTES,PBYTES

iscallback:=iscallbackfn(currproc)
retbeforeblock:=1			!actually, this may be after a block, but then it doesn't matter

if fbytes or pbytes then
	if fbytes then
		popstack(roundto(fbytes,16))
	fi
	genmc(m_pop,dframeopnd)
	if iscallback then
		strcpy(&.str,"	call m$popcallback*")
		genassem(&.str)
	fi

	genmc(m_ret)
else

	if iscallback then
		strcpy(&.str,"	call m$popcallback*")
		genassem(&.str)
	fi

	popstack(8)
	genmc(m_ret)
fi
stackaligned:=initial_stackalignment		!for any following code
end

global function getsizeprefix(int size,enable=0)ichar=
if not enable then return "" fi
case size
when 1 then return "byte "
when 2 then return "word16 "
when 4 then return "word32 "
when 8 then return "word64 "
esac
return "N:"
end

global function needsizeprefix(int opcode,ref opndrec a,b)int=

case opcode
when m_uwiden,m_iwiden, mx_movsx, mx_movzx, mx_cvtsi2ss, mx_cvtsi2sd then
	return 1
when m_ifix then
	return 1
when m_shl, mx_shr, mx_sar then
	if a^.mode=a_mem then return 1 fi
	return 0
esac

if a^.mode=a_reg or a^.mode=a_xreg or b^.mode=a_reg or b^.mode=a_xreg then
	return 0
fi
return 1
end

global function changeopndsize(ref opndrec a,int size)ref opndrec=
ref opndrec b

if a^.size<>size then
	b:=duplopnd(a)
	b^.size:=size
	return b
fi
return a
end

global function genint(int64 x,int size=4)ref opndrec=
ref opndrec a

a:=newopnd()
a^.mode:=a_imm
a^.value:=x
a^.valtype:=int_val
a^.size:=size
return a
end

global function genreal(real64 x,int size=8)ref opndrec=
ref opndrec a

a:=newopnd()
a^.mode:=a_imm
a^.xvalue:=x
a^.valtype:=real_val
a^.size:=size
return a
end

global function genimm(unit p,int size=0)ref opndrec=
!assume p is a const unit, or possible a name (gives a name
ref opndrec a
int t

a:=newopnd()
a^.mode:=a_imm

!a^.value:=p^.
case p^.tag
when j_const then
	t:=p^.mode
	if isintcc(t) then
		a^.value:=p^.value
		a^.valtype:=int_val
		a^.size:=(size|size|ttsize[t])
	elsif isrealcc(t) then
		a^.xvalue:=p^.xvalue
		a^.valtype:=real_val
		a^.size:=(size|size|ttsize[t])
	else
		gerror("GENIMM/MODE?")
	fi

when j_name then
	a^.def:=p^.def
	a^.size:=ttsize[p^.def^.mode]
else
	gerror("genimm/unit")
esac

return a
end

global function genlabel(int x,isglobal=0)ref opndrec=
!x is a label index
!generate immediate operand containing label
ref opndrec a

a:=newopnd()
a^.size:=targetsize
a^.mode:=a_imm
a^.value:=x
a^.valtype:=label_val
a^.isglobal:=isglobal
return a
end

global function genmem_u(unit p,int size=0)ref opndrec=
return genmem_d(p^.def,ttsize[p^.mode])
end

global function genmem_d(ref strec d,int size=0)ref opndrec=
ref opndrec a

++NMEM

a:=newopnd()
a^.mode:=a_mem

if isframe(d) and fshowfullnames then
	a^.reg:=rframe
fi
a^.def:=d
a^.size:=(size|size|ttsize[d^.mode])

return a
end

global function genmemaddr_u(unit p)ref opndrec=
return genmemaddr_d(p^.def)
end

global function genmemaddr_d(ref strec d)ref opndrec=
ref opndrec a
++NMEMADDR

a:=newopnd()
a^.mode:=a_imm

if isframe(d) and fshowfullnames then
	a^.reg:=rframe
fi
a^.def:=d
a^.size:=ptrsize

return a
end

global function genreg(int reg,size=4)ref opndrec=
static [0:9]int isnormal=(0, 1,1,0,1,0,0,0,1)
int offset
ref opndrec a

if size<=8 and isnormal[size] then
	a:=newopnd()
	a^.mode:=a_reg
	a^.reg:=reg
	a^.size:=size
else
!	a:=newopnd()
!	a^.mode:=a_reg
!	a^.reg:=reg
!	a^.size:=8
!	offset:=getstructtemp(size)
!	genmc(m_lea,a,genindex(areg:rframe,offset:offset))
!
GERROR("GENREG/BLOCK SIZE")
!	return genblockreg(reg,size)
fi

return a
end

global function genireg(int reg,size=4)ref opndrec=
ref opndrec a

a:=newopnd()
a^.mode:=a_mem
a^.reg:=reg
a^.size:=size

return a
end

global function getopndsize_u(unit p)int=
return ttsize[p^.mode]
end

global function getopndsize_d(ref strec d)int=
return ttsize[d^.mode]
end

global function getmclcond(int opc,m)int=
int signedx

signedx:=stdtypesigned[ttbasetype[m]]		!note real types will use unsigned codes

if isrealcc(m) then
	case opc
	when j_lt then return flt_cond
	when j_le then return fle_cond
	when j_ge then return fge_cond
	when j_gt then return fgt_cond
	when j_eq then return feq_cond
	when j_ne then return fne_cond
	esac
else
	case opc
	when j_lt then return (signedx|lt_cond|ltu_cond)
	when j_le then return (signedx|le_cond|leu_cond)
	when j_ge then return (signedx|ge_cond|geu_cond)
	when j_gt then return (signedx|gt_cond|gtu_cond)
	when j_eq then return eq_cond
	when j_ne then return ne_cond
	esac
fi

return 0
end

global function getfullname(ref strec d)ichar=

return d^.name

end

global function roundsizetg(int size)int=
!make sure size is round up to next multiple of targetsize (4 or 8)
while size iand (targetsize-1) do ++size od
return size
end

global function iscallbackfn(ref strec p)int=
!return 1 if p is a function with clang atribute (needs caller stack adjust)

!RETURN 1

return p^.attribs.ax_callback
end

global function getregname(int reg,size=4)ichar=
static [1..8]ichar prefix=("B","W","","A","","","","D")
static [32]char str
[16]char str2
ichar rs

if size>8 then
	RETURN "DBIG"
FI

case reg
when rnone then return "-"
when rframe then rs:="frame"
when rstack then rs:="stack"
else
	getstrint(reg-r0,&.str2)
	rs:=&.str2
!	rs:="?"
esac

!sprintf(&.str,"%s%s",prefix[size],rs)
print @&.str,prefix[size],,rs

return &.str
end

global function getblockname(int reg,size)ichar=
static [32]char str
!sprintf(&.str,"N%d(%d)",int32(reg-1),int32(size))
fprint @&.str,"N#(#)",reg-1,size
return &.str
end

global function fgetregname(int reg,size=8)ichar=
static [32]char str

!sprintf(&.str,(size=8|"DX%d"|"SX%d"),int32(reg-xr0))
print @&.str,(size=8|"DX"|"SX"),,reg-xr0

return &.str
end

global function issimple(unit p)int=
!return 1 if p is simple: can be evaluated using no registers

if not fdosimple then return 0 fi
return issimple0(p,0)

end

function issimple0(unit p,int level)int=
!return 1 if p is simple: can be evaluated using no registers
unit a

!return 0

++level

IF LEVEL>5 THEN
!IF LEVEL>3 THEN
!	CPL =LEVEL
	return 0
FI
a:=p^.a

switch p^.tag
when j_const, j_name, j_funcname then
	return 1

when j_ptr then
	if a^.tag=j_addptr or a^.tag=j_subptr then
		if issimple0(a^.a,level) and issimple0(a^.b,level) then
			return 1
		fi
	else
		return issimple0(a,level)
	fi

!when j_add, j_sub, j_iand, j_ior, j_ixor, j_assign then
when j_add, j_sub, j_iand, j_ior, j_ixor then
dobin::
	if issimple0(a,level) and issimple0(p^.b,level) then
		return 1
	fi

when j_mul then
	if gettypecat(p)='I' then
		goto dobin
	fi

!when j_widenmem then
!CPL "ISSIMPLE/WIDEN",JTAGNAMES[A^.TAG]
!	return issimple0(a)

when j_convert then
	case p^.opcode
!	when soft_c,hard_c,swiden_c,uwiden_c,truncate_c then
	when soft_c,hard_c,swiden_c,uwiden_c then
		return issimple0(a,level)
	esac

when j_addrof then
	return issimple0(a,level)

when j_dot then
	return issimple0(a,level)

!when j_preincr, j_predecr, j_postincr, j_postdecr then
!	return issimple(a)

when j_shl, j_shr then
	if issimple0(a,level) and p^.b^.tag=j_const then
		return 1
	fi

!when j_addptr, j_subptr then
!	if issimple0(a) and issimple0(p^.b) then
!		return 1
!	fi


!ELSE
!CPL "ISSIMPLE",JTAGNAMES[P^.TAG]
end switch

return 0
end

global function issimplepm(unit p)int=
!return 1 if p is simple: can be evaluated using no registers

if not fdosimple then return 0 fi
!return 0

case p^.tag
when j_const,j_name then
	return 1
!when j_nameaddr then
!	if p^.def^.nameid=staticid then
!		return 1
!	fi

!THE FOLLOWING are dangerous, as simple params are calculated into d10..d13.
!At d13, regs may overflow into rframe.

!when j_add, j_sub, j_iand, j_ior, j_ixor then
!	if issimplepm(p^.a) and issimplepm(p^.b) then
!		return 1
!	fi

esac
return 0
end

global function getaregs(ref opndrec ax)int=
int n

case ax^.mode
when a_reg then
	return 1

when a_mem then
	n:=0
	if ax^.reg and ax^.reg<>rframe then ++n fi
	if ax^.regix then ++n fi
	return n

when a_xreg then
	return 0

else
	gerror("getaregs")
esac
return 0
end

global function getlregs(ref opndrec ax)int=
case ax^.mode
when a_reg, a_xreg then
	return 1
when a_mem then
	if (ax^.reg and ax^.reg<>rframe) or ax^.regix then
		return 1
	fi
when a_imm then
	return 0
else
CPL OPNDNAMES[AX^.MODE]
	gerror("getlregs")
esac
return 0
end

global function isintconst(unit p)int=
!if p^.tag=j_const and tfirstint<=p^.mode<=tlastint then
if p^.tag=j_const and isintcc(p^.mode) then
	return 1
fi
return 0
end

global function _getnextreg(ref opndrec ax,int reg=0)int=
!ax is an operand; if it uses any registers, then return next available register
int maxreg,r,rix

r:=ax^.reg
rix:=ax^.regix

case ax^.mode
when a_reg,a_xreg then
	if r<rframe then
		return r+1	+1
	fi
when a_mem then
	maxreg:=0

	if r>=rframe and rix>rframe then		!rframe, rstack, or pseudo reg
	elsif r>rframe then
		maxreg:=rix
	elsif rix>rframe then
		maxreg:=r
	else
		if r<>rframe then
			maxreg:=max(r,rix)
		else
			maxreg:=rix
		fi
	fi
	if maxreg then
		return maxreg+1
	fi
esac

!no registers used; nevertheless, there may be a particular register to start using,
!this must be provided by reg
if reg=0 then
REG:=R0
!	gerror("GETNEXTREG REG=0")
fi

return reg			!no registers used
end

global function getnextreg(ref opndrec ax,int r=0)int=
!ax is an operand; if it uses any registers, then return next available register
static int maxreg=0
int reg

reg:=_getnextreg(ax,r)

if reg>maxreg then
	maxreg:=reg
fi

return reg
end

global function ispoweroftwo(int64 x)int=
!when x is a power of two, and is at least 2, then return the power (ie. equiv number of shifts)
!otherwise return zero when x is negative, 0, 1 not a power of two, or more than 2**31
int64 a
int n

a:=1
n:=0
to 30 do
	++n
	a:=a<<1
	if a=x then
		return n
	fi
od
return 0
end

function sameoperand(ref opndrec a,b)int=
!check if same memory operand
if a^.mode<>b^.mode then return 0 fi
if a^.size<>b^.size then return 0 fi
if a^.value<>b^.value then return 0 fi
if a^.reg<>b^.reg then return 0 fi
if a^.regix<>b^.regix then return 0 fi
if a^.valtype<>b^.valtype then return 0 fi
if a^.scale<>b^.scale then return 0 fi

!CPL "SAME",STROPND(A),STROPND(B),A.DEF,B.DEF
if a^.def and b^.def and a^.def=b^.def and a^.value=b^.value then
	return 1
elsif a^.def=nil and b^.def=nil and a^.value=b^.value then
	return 1
fi
return 0
end

function findlastmcl:ref mclrec=
!starting from mcindex, find last executable mcl code
!will skip labels, comments, etc
GERROR("FINDLASTMCL")
!n:=imccode^.upb
!for i:=n downto 1 do
!	m:=imccode^[i]
!	if m<>m_comment then
!		return m
!	fi
!od
return nil
end

global proc genmsource(int lineno)=			!GENBSOURCE
end

global function roundto(int64 a,n)int64=
!round a to be multiple of n
!n will be a power of two
--n
while (a iand n) do ++a od
return a
end

global proc pushstack(int n)=
int nwords
	if n then
		genmc(m_sub,dstackopnd,genint(n))
		if n iand 8 then
			stackaligned ixor:=1
		fi
	fi
end

global proc pushstackfp(int n)=
int nwords
	if n then
!		genmc(m_sub,dstackopnd,genint(n))
		genmc(m_mov, genreg(r13,8),genint(0))
		to n/8 do
			genmc(m_push,genreg(r13,8))
		od

		if n iand 8 then
			stackaligned ixor:=1
		fi
	fi
end

global proc popstack(int n)=
	if n then
		genmc(m_add,dstackopnd,genint(n))
		if n iand 8 then
			stackaligned ixor:=1
		fi
	fi
end

!global proc ipadstr(ref char s,int width,ref char padchar=" ")=
!int n
!n:=strlen(s)
!to width-n do
!	strcat(s,padchar)
!od
!end

global function definelabel:int =
genmc(m_label,genlabel(++labelno))
return labelno
end

global function createfwdlabel:int =
return ++labelno
end

global proc definefwdlabel(int lab) =
genmc(m_label,genlabel(lab))
end

global proc genjumpl(int lab) =
genmc(m_jmp,genlabel(lab))
end

global proc setalign(int align)=
if align>1 then
	genmc(m_align,genint(align))
fi
end

global function gettypecat(unit a)int=
!return 'I' 'U' or 'F' (or 'P' for pointers). Other types return 0
!rough type info for the code generator

return stdtypecat[ttbasetype[a^.mode]]
end

!function getstructtemp(int size)int=
!!return frame offset of temp area for structs returned from function
!if not stacksetinstr then
!	gerror("gst: frame not used")
!fi
!while size iand 15 do ++size od		!make 16n
!
!framebytes+:=size
!frameoffset+:=size
!
!stacksetinstr^.b^.value:=framebytes
!
!return frameoffset
!end

global proc doblockcall(int size)=
ref opndrec ax

!GERROR("DOBLOCKCALL")
if retbeforeblock then
cp "RB."
!	CPL("Block call after return")
!	gerror("Block call after return")
fi
while size iand 15 do ++size od

if currblocksize=0 then
	currblocksize:=size
	frameoffset-:=size
	framebytes+:=size
!	stacksetinstr^.b^.value:=framebytes
	stacksetinstr^.b^.value:=roundto(framebytes,16)
elsif currblocksize<size then
	frameoffset-:=(size-currblocksize)
	framebytes+:=(size-currblocksize)
	currblocksize:=size
!	stacksetinstr^.b^.value:=framebytes
	stacksetinstr^.b^.value:=roundto(framebytes,16)
fi

ax:=genreg(r9,8)
genmc(m_lea,ax,genindex(areg:rframe,offset:frameoffset))

end

global function getblockreg(int size)ref opndrec=
!assume same size set by doblockcall
ref opndrec ax

while size iand 15 do ++size od
if currblocksize<size then gerror("getblockreg?") fi
genmc(m_lea,ax:=genreg(r0,8),genindex(areg:rframe,offset:frameoffset))
return ax
end

global proc copyretvalue(int size)=
!block return value is used; address is in D0
!copy to caller's pointer at [dframe+structretoffset]

!push d0
!push d0
!sub dstack,32
!mov d10,[dframe-nnn]
!mov d11,d0
!mov d12,size
!call memset*
!add dstack,32
!pop d0
!pop d0
[256]char str


genassem(";-----------")
genassem("	push d0")
genassem("	push d0")
genassem("	sub dstack,32")
!sprintf(&.str,"	mov d10,[dframe%d]",int32(structretoffset))
fprint @&.str,"	mov d10,[dframe#]",structretoffset

genassem(&.str)

genassem("	mov d11,d0")

!sprintf(&.str,"	mov d12,%d",int32(size))
print @&.str,"	mov d12,",size
genassem(&.str)
genassem("	call memcpy*")
genassem("	add dstack,32")

genassem("	pop d0")
genassem("	pop d0")
genassem(";-----------")

end

global proc enterproc(ichar name)=
RETURN
	if eqstring(name,"$showentry") or eqstring(name,"$showreturn") then
		return
	fi

	genmc(m_sub,genreg(rstack,8),genint(32))
	genmc(m_mov,genreg(r10,8),genstrimm(name))
	genmc(m_call, genname("$showentry*"))
	genmc(m_add,genreg(rstack,8),genint(32))
end

global proc leaveproc(ichar name)=
RETURN
	if eqstring(name,"$showentry") or eqstring(name,"$showreturn") then
		return
	fi
	genmc(m_sub,genreg(rstack,8),genint(32))
	genmc(m_mov,genreg(r10,8),genstrimm(name))
	genmc(m_call, genname("$showreturn*"))
	genmc(m_add,genreg(rstack,8),genint(32))
end
=== cc_blockmcl.m 60/77 ===
!M Compiler - x64 Target Code Generator 2
!import main
import mlib
import clib
import oslib

import cc_decls
import cc_support
import cc_tables
import cc_lib
import cc_libmcl

const kjumpt = 1		!pseudo ops used for conditional jump logic
const kjumpf = 0

const tintptr=tullong

GLOBAL INT NADDTO
GLOBAL INT NADDTOX

[maxnestedloops]int continuestack		!labels for continue/break
[maxnestedloops]int breakstack
int loopindex							!current level of nested loop/switch blocks

const maxparams=200

const maxswitchrange=500
const maxcases=maxswitchrange
const maxswitchdepth=20

ref[]int sw_labeltable			!set from do-switch
ref[]int sw_valuetable
int sw_lower
int sw_ncases					!1..n for serial switch; 0 for simple
byte sw_defaultseen				!starts at 0, set to 1 when default: seen
int sw_defaultlabel
int sw_breaklabel

int maxreg=0

global proc do_stmt(unit p) =
int oldclineno,value,i
unit a,b
ref opndrec rx,ax,bx,lhs,rhs
ref strec d
[256]char str

if p=nil then
	return
fi

!CPL "STMT",jtagnames[p^.tag],p^.lineno

oldclineno:=clineno
clineno:=p^.fileno<<24+p^.lineno

!CPL "DOSTMT",CLINENO

!SPRINTF(&STR,"%d",p^.lineno)
!GENCOMMENT(&STR)

a:=p^.a
b:=p^.b

!gentc(t_stmt)

switch p^.tag
when j_block then
	while a do
		do_stmt(a)
		a:=a^.nextunit
	od

when j_decl then
	do_decl(p^.def)

when j_callfn then
	dx_call(p,a,b,r0)

when j_return then
	do_return(a)

when j_assign then
	do_assign(a,b)

when j_if then
	do_if(a,b,p^.c)

when j_for then
	do_for(a,b)

when j_while then
	do_while(a,b)
!
when j_dowhile then
	do_dowhile(a,b)
!
when j_goto then
	do_goto(p^.def)

when j_labelstmt then
	do_labeldef(p^.def)
	do_stmt(a)
!
when j_casestmt then

!	sprintf(&.str,"case %d:",int32(p^.index))
	fprint @&.str,"case",p^.index,,":"

	gencomment(pcm_copyheapstring(&.str))
	if sw_ncases=0 then
!		genmc(m_label,genlabel(sw_labeltable^[p^.uindex-sw_lower+1]))
		genmc(m_label,genlabel(sw_labeltable^[p^.value-sw_lower+1]))
	else
!		value:=p^.uindex
		value:=p^.value
		for i:=1 to sw_ncases do
			if sw_valuetable^[i]=value then
				genmc(m_label,genlabel(sw_labeltable^[i]))
				exit
			fi
		else
			gerror("case: serial switch not found")
		od
	fi
	do_stmt(a)

when j_defaultstmt then
	sw_defaultseen:=1
	gencomment("default:")
	genmc(m_label,genlabel(sw_defaultlabel))
	do_stmt(a)

when j_breaksw then
	genjumpl(sw_breaklabel)

when j_break then
	genjumpl(breakstack[loopindex])

when j_continue then
	genjumpl(continuestack[loopindex])

when j_switch then
	do_switch(p,a,b)
!
when j_addto then
++NADDTO
	dx_addto(m_add,a,b,0)

when j_subto then
++NADDTO
	dx_addto(m_sub,a,b,0)

when j_multo then
++NADDTO
	dx_multo(a,b,0)
!
when j_divto,j_remto then
++NADDTO
	dx_divto(p,a,b,0)
!
when j_iandto then
++NADDTO
	dx_addto(m_and,a,b,0)

when j_iorto then
++NADDTO
	dx_addto(m_or,a,b,0)

when j_ixorto then
++NADDTO
	dx_addto(m_xor,a,b,0)

when j_shlto, j_shrto then
++NADDTO
	dx_shlto(p,a,b,0)

when j_preincr, j_postincr then
	do_preincr(a,m_add,m_inc)

when j_predecr, j_postdecr then
	do_preincr(a,m_sub,m_dec)


!
!when j_null then
!	gerror("stmt/null")
!
when j_exprlist then
	do_exprlist(a)

else
!assume standalone expression (assign/call/addto/incr done above)

!CPL "LONE",=FSHOWNAMES
	if p^.tag<>j_const or not fshownames then
		loneexpr(p)
	fi

endswitch

!clineno:=oldclineno
end

function dx_expr(unit p, int reg=r0,am=1)ref opndrec =
int oldclineno,value,i,m
unit a,b
ref opndrec rx,ax,bx,lhs,rhs,tx
[256]char str
!ref strbuffer ex
ref strec d

if p=nil then
	return nil
fi

!CPL "EXPR",jtagnames[p^.tag],p^.lineno

if reg>r8 and reg<r10 then
	CPL "DOEXPR TOO MANY REGS?"
fi

oldclineno:=clineno
clineno:=p^.fileno<<24+p^.lineno
tx:=nil
!SPRINTF(&STR,"%d",p^.lineno)
!GENCOMMENT(&STR)

a:=p^.a
b:=p^.b
m:=p^.mode

switch p^.tag
when j_const then
	return dx_const(p,reg)

when j_name then
	return dx_name(p,reg,am)

!when j_nameaddr then
!	d:=p^.def
!	if isstructunion(tttarget[m]) then				!block
!		rx:=genreg(reg,ptrsize)
!		if d^.nameid=paramid then					!pointer to block
!			genmc(m_mov,rx,genmem_u(p))
!		else										!just a block
!			genmc(m_lea,rx,genmem_u(p))
!		fi
!		return rx
!
!	else
!		return dx_nameaddr(p,d,reg)
!	fi
!
when j_widenmem then
	return dx_widen(a,m,reg)

when j_funcname then
	return genmemaddr_u(p)

when j_assign then
	return dx_assign(a,b,reg)
!
when j_andl,j_orl then
	return dx_andorl(p,reg)		!use non-short circuit versions for now

when j_notl then
	return dx_notl(a,reg)

when j_istruel then
	return dx_istruel(a,reg)

when j_exprlist then
	return dx_exprlist(a,reg)

when j_callfn then
	return dx_call(p,a,b,reg)

when j_ifx then
	return dx_ifx(a,b,p^.c,reg)

when j_eq,j_ne,j_lt,j_le,j_ge,j_gt then
	return dx_eq(p,a,b,reg)
!
when j_add then
	if ttisref[a^.mode] and ttsize[b^.mode]<=4 then
		b^.mode:=tintptr
	fi
	return dx_add(a,b,reg)

when j_sub then
	return dx_sub(a,b,reg)

when j_mul then
	return dx_mul(p,a,b,reg)
!
when j_div then
	return dx_div(p,a,b,reg)

when j_rem then
	return dx_rem(p,a,b,reg)
!
when j_iand then
	return dx_iand(m_and,a,b,reg)

when j_ior then
	return dx_iand(m_or,a,b,reg)

when j_ixor then
	return dx_iand(m_xor,a,b,reg)

when j_shl,j_shr then
	return dx_shl(p,a,b,reg)

when j_ptr then
	return dx_ptr(p,a,reg,am)

!when j_ptroffset then
!	tx:=dx_ptroffset(p,a,b,p^.c, 0, reg)

when  j_addptr then
	return dx_addptr(p,a,b, reg, am)

when  j_subptr then
	return dx_subptr(a,b, reg, am)

when j_convert then
	if m=tvoid then
		return evalexpr(a,reg)
	else
		return dx_convert(a,m, p^.opcode, reg)
	fi

when j_scale then
	return dx_scale(p,a,b,reg)

when j_neg then
    return dx_neg(a,reg)

when j_inot then
	return dx_inot(a,reg)
!
when j_preincr, j_predecr then
	return dx_preincrx(p,a,reg)

when j_postincr, j_postdecr then
	return dx_postincrx(p,a,reg)

when j_addto then
++NADDTOX
	return dx_addto(m_add,a,b,reg)

when j_subto then
++NADDTOX
	return dx_addto(m_sub,a,b,reg)

when j_multo then
++NADDTOX
	return dx_multo(a,b,reg)

when j_divto, j_remto then
++NADDTOX
	return dx_divto(p,a,b,reg)

when j_iandto then
++NADDTOX
	return dx_addto(m_and,a,b,reg)

when j_iorto then
++NADDTOX
	return dx_addto(m_or,a,b,reg)

when j_ixorto then
++NADDTOX
	return dx_addto(m_xor,a,b,reg)

when j_shlto, j_shrto then
++NADDTOX
	return dx_shlto(p,a,b,reg)
!
when j_sqrt then
	return dx_sqrt(a,reg)

when j_addrof then
	return dx_addrof(p,a,reg,am)

when j_dot then
	return dx_dot(p,a,b,reg,am)

else
	gerror_s("DX-EXPR: can't do tag: %s",jtagnames[p^.tag])
endswitch

if tx=nil then
	GERROR_S("DX-EXPR: NO RESULT: %s",JTAGNAMES[P^.TAG])
fi

clineno:=oldclineno
return tx
end

proc loneexpr(unit p)=
if p and p^.tag<>j_null then
	loadexpr(p)
fi
end

proc do_assign(unit a,b)=
ref opndrec lhs,rhs
int reg,tx

case ttsize[a^.mode]
when 1,2,4,8 then
else
!CPL "BLOCK ASS"
	do_assignblock(a,b)
	return
esac
reg:=r0

!CPL =ISSIMPLE(A)
!CPL =ISSIMPLE(B)

if issimple(a) then
	if issimple(b) then			!simple:=simple
		lhs:=getlvalueopnd(a,reg)
		if isintconst(b) then
			rhs:=evalexpr(b,getnextreg(lhs,reg))
		else
			rhs:=loadexpr(b,getnextreg(lhs,reg),isassign:1)
		fi
	else					!simple:=complex
		rhs:=loadexpr(b,reg,isassign:1)
		lhs:=getlvalueopnd(a,getnextreg(rhs,reg))
	fi
else
	if issimple(b) then			!complex:=simple
		lhs:=getlvalueopnd(a,reg)
		rhs:=loadexpr(b,getnextreg(lhs,reg	),isassign:1)
	else					!complex:=complex
!CPL "ASSIGN CX/CX"
		tx:=saveexpr(b,r0)
		lhs:=getlvalueopnd(a,r0)
!		rhs:=restoreexpr(tx,r0+getaregs(lhs))
		rhs:=restoreexpr(tx,getnextreg(lhs,reg))
	fi
fi
storeopnd(lhs,rhs)
end

function dx_assign(unit a,b,int reg)ref opndrec =
ref opndrec lhs,rhs,rx,ax,bx
int tx

!CPL "DXASSIGN"

case ttsize[a^.mode]
when 1,2,4,8 then
else
	return do_assignblock(a,b,reg)
esac

if issimple(a) then
	if issimple(b) then			!simple:=simple
		lhs:=getlvalueopnd(a,reg)
		rhs:=loadexpr(b,getnextreg(lhs,reg),isassign:1)
		storeopnd(lhs,rhs)		!might be upgraded to m_fstore
	else					!simple:=complex
		rhs:=loadexpr(b,reg,isassign:1)
		lhs:=getlvalueopnd(a,getnextreg(rhs,reg))
		storeopnd(lhs,rhs)
	fi
else
	if issimple(b) then			!complex:=simple
		lhs:=getlvalueopnd(a,reg)
		rhs:=loadexpr(b,getnextreg(lhs,reg),isassign:1)
		storeopnd(lhs,rhs)
	else					!complex:=complex
		tx:=saveexpr(b,r0)
		ax:=getlvalueopnd(a,r0)
!		bx:=restoreexpr(tx,r0+getaregs(ax))
		bx:=restoreexpr(tx,getnextreg(ax,reg))
		storeopnd(ax,bx)
		rhs:=bx
	fi
fi

case rhs^.mode
when a_reg then
	if rhs^.reg<>reg then
		rx:=genreg(reg,rhs^.size)
		genmc(m_mov,rx,rhs)
		return rx
	fi
when a_xreg then
	if rhs^.reg<>reg then
		rx:=genxreg(reg,rhs^.size)
		genmc(m_fmov,rx,rhs)
		return rx
	fi
esac
return rhs
end

function saveexpr(unit a,int reg=r0)int=
!for now, just push to stack, and return size
pushexpr(a,reg)
return ttsize[a^.mode]
end

function fsaveexpr(unit a,int reg=xr0)int=
!for now, just push to stack, and return size
fpushexpr(a,reg)
return ttsize[a^.mode]
end

function restoreexpr(int tx, reg)ref opndrec=
!for now, tx is just the size
ref opndrec rx

genmc(m_pop,rx:=genreg(reg,targetsize))		!register must be full size
rx:=duplopnd(rx)
rx^.size:=tx
return rx
end

function frestoreexpr(int tx, reg)ref opndrec=
!for now, tx is just the size
ref opndrec rx

genmc(m_pop,rx:=genxreg(reg,tx))		!register must be full size
rx:=duplopnd(rx)
rx^.size:=tx
return rx
end

function getlvalueopnd (unit a,int reg=r0)ref opndrec=
return evalexpr(a,reg)
end

proc storeopnd(ref opndrec ax,bx)=
!ax is a memory operand, bx is a register operand
!store bx to ax
!note that bx miht refer to an xmm register

if bx^.mode=a_xreg then
	genmc(m_fmov,ax,bx)
else
	case ax^.size
	when 1,2,4 then
		bx:=changeopndsize(bx,ax^.size)
	esac
	genmc(m_mov,ax,bx)
fi
end

proc pushexpr(unit a,int reg=r0)=
ref opndrec ax

if a then
	ax:=dx_expr(a,reg)
	genmc(m_push,ax)
else
	genmc(m_push,zero_opnd)
fi
end

proc fpushexpr(unit a,int reg=xr0)=
ref opndrec ax

ax:=dx_expr(a,reg)
genmc(m_push,ax)
end

function dx_const(unit p, int reg)ref opndrec=
ref opndrec ax
int t

if (t:=ttbasetype[p^.mode])>=tfirstint and t<=tlastint then
	return genint(p^.value,ttsize[p^.mode])

elsif t>=tfirstreal and t<=tlastreal then
	ax:=genreal(p^.xvalue,ttsize[p^.mode])
	return ax

elsif t=tref then
	if p^.isstrconst then
		return genstrimm(p^.svalue,p^.slength)
	elsif p^.iswstrconst then
		return genwstrimm(p^.wsvalue,p^.wslength)

	fi
	return genint(p^.value,ptrsize)
fi
gerror_s("dxconst %s",Strmode(p^.mode))

return ax
end

function dx_constant(ref strec d, int reg)ref opndrec=
ref opndrec ax
int t

if (t:=ttbasetype[d^.mode])>=tfirstint and t<=tlastint then
	return genint(d^.code^.value,ttsize[d^.mode])

elsif t>=tfirstreal and t<=tlastreal then
	ax:=genreal(d^.code^.xvalue,ttsize[d^.mode])
	return ax
fi
gerror_s("dxconstant %s",Strmode(d^.mode))

return ax
end

proc do_labeldef(ref strec d)=
genmc(m_label,genlabel(d^.index),genmemaddr_d(d))
end

proc do_goto(ref strec d)=
if d^.index=0 then
	gerror_s("Label not defined: %s",d^.name)
fi
genmc(m_jmp,genlabel(d^.index))
end

function dx_add(unit a,b,int reg)ref opndrec=
ref opndrec ax,bx
int tx

if gettypecat(a)='R' then
	return dx_fadd(m_add,a,b,reg)
fi

!GOTO SIMPLEADD

if issimple(b) then
SIMPLEADD::
!CPL "ADD SX/SX"
	ax:=loadexpr(a,reg)
!	bx:=evalexpr(b,reg+getlregs(ax))
	bx:=evalexpr(b,getnextreg(ax,reg))

elsif issimple(a) then	!reverse order

	ax:=loadexpr(b,reg)
!	bx:=evalexpr(a,reg+getlregs(ax))
	bx:=evalexpr(a,getnextreg(ax,reg))
else
!	tx:=saveexpr(b,reg)
!	ax:=loadexpr(a,reg)
!	bx:=restoreexpr(tx,getnextreg(ax))
	tx:=saveexpr(a,reg)
	ax:=loadexpr(b,reg)
	bx:=restoreexpr(tx,getnextreg(ax,reg))
fi

genmc(m_add,ax,bx)

return ax
end

function dx_fadd(int opc,unit a,b,int reg)ref opndrec=
ref opndrec ax,bx
int tx

if issimple(b) then
	ax:=floadexpr(a,reg)
	if opc=m_imul and a^.tag=j_name and b^.tag=j_name and a^.def=b^.def then
!CPL "FLOAT/SQR DETECTED"
		bx:=ax
	else
!		bx:=fevalexpr(b,reg+getlregs(ax))
		bx:=fevalexpr(b,getnextreg(ax,reg))
	fi
elsif issimple(a) and (opc=m_add or opc=m_imul) then	!reverse order
	ax:=floadexpr(b,reg)
!	bx:=fevalexpr(a,reg+getlregs(ax))
	bx:=fevalexpr(a,getnextreg(ax,reg))
else
	tx:=fsaveexpr(b,reg)
	ax:=floadexpr(a,reg)
!	bx:=frestoreexpr(tx,reg+getlregs(ax))
	bx:=frestoreexpr(tx,getnextreg(ax,reg))
fi

case opc
when m_add then
	genmc(m_fadd,ax,bx)
when m_sub then
	genmc(m_fsub,ax,bx)
when m_imul then
	genmc(m_fmul,ax,bx)
when m_idiv then
	genmc(m_fdiv,ax,bx)
esac


return ax
end

function loadexpr(unit a,int reg=r0,isassign=0)ref opndrec=
ref opndrec ax,rx

ax:=dx_expr(a,reg,1)

case ax^.size
when 1,2,4,8 then
else				!block
	case ax^.mode
	when a_mem then
		if ax^.def=nil and ax^.regix=0 and ax^.value=0 then		!assume [reg]
			return genreg(ax^.reg,ptrsize)						!return block reg
		fi
		rx:=genreg(reg+getaregs(ax),ptrsize)
!		rx:=genreg(getnextreg(ax),ptrsize)
		genmc(m_lea, rx, ax)
		return rx

	when a_reg then
		return ax
	when a_imm then
	else
		gerror("loadexpr block not mem/reg")
	esac
esac

case ax^.mode
when a_reg then			!already in register
	if ax^.reg=reg then
		return ax
	fi
	rx:=genreg(reg,ax^.size)
	genmc(m_mov,rx,ax)
	return rx
when a_xreg then
	if isassign and ax^.reg=reg then
		return ax
	fi
	rx:=genreg(reg,ax^.size)
	genmc(m_fmov,rx,ax)
	return rx
esac

rx:=genreg(reg,ax^.size)

genmc(m_mov,rx,ax)
return rx
end

function evalexpr(unit p,int reg=r0)ref opndrec=
!evaluate expression in junit  p
!return filled-in operand which can be used to access the result.
!Result is not loaded into a register unless needed.
!Any registers used will always start from R0 and XR0
ref opndrec ax,rx

ax:=dx_expr(p,reg,1)

if ax^.mode=a_xreg then
	rx:=genreg(ax^.reg,ax^.size)
	genmc(m_fmov,rx,ax)
	return rx
fi
return ax
end

function evaladdr(unit p,int reg=r0)ref opndrec=
return dx_expr(p,reg,0)
end

function evalptr(unit p,int reg=r0)ref opndrec=
return dx_expr(p,reg,2)
end

function floadexpr(unit a,int xreg=r0)ref opndrec=
ref opndrec ax,rx

ax:=dx_expr(a,xreg)
rx:=genxreg(xreg,getopndsize_u(a))

case ax^.mode
when a_xreg then				!already in register
	if ax^.reg=xreg then
		return ax
	fi
	genmc(m_fmov,rx,ax)
	return rx
when a_reg then
	rx:=genxreg(ax^.reg,ax^.size)
	genmc(m_fmov,rx,ax)
	return rx
!	GERROR("FLOADEXPR REG")
esac

genmc(m_fmov,rx,ax)
return rx
end

function fevalexpr(unit p,int xreg=xr0)ref opndrec=
ref opndrec ax,rx

ax:=dx_expr(p,xreg)
if ax^.mode=a_reg then
	rx:=genxreg(xreg,getopndsize_u(p))
	genmc(m_fmov,rx,ax)
	return rx
fi
return ax
end

proc do_if(unit a,b,c)=
int lab1,lab2

lab1:=createfwdlabel()

genjumpcond(kjumpf,a,lab1,r0)

do_stmt(b)

if c then
	lab2:=createfwdlabel()			!label past else part
	genjumpl(lab2)
	definefwdlabel(lab1)
	do_stmt(c)
	definefwdlabel(lab2)
else
	definefwdlabel(lab1)
fi
end

proc genjumpcond(int opc,unit p,int lab,reg=r0)=
!p is some conditional expression of arbitrary complexity
!opc is kjumpf or kjumpt
!evaluate and generate jumps as needed
unit q,r
int lab2
ref opndrec ax

q:=p^.a
r:=p^.b

switch p^.tag
when j_andl then
	case opc
	when kjumpf then
		genjumpcond(kjumpf,q,lab,reg)
		genjumpcond(kjumpf,r,lab,reg)
	when kjumpt then
		lab2:=createfwdlabel()
		genjumpcond(kjumpf,q,lab2,reg)
		genjumpcond(kjumpt,r,lab,reg)
		definefwdlabel(lab2)
	esac

when j_orl then
	case opc
	when kjumpf then
		lab2:=createfwdlabel()
		genjumpcond(kjumpt,q,lab2,reg)
		genjumpcond(kjumpf,r,lab,reg)
		definefwdlabel(lab2)
	when kjumpt then
		genjumpcond(kjumpt,q,lab,reg)
		genjumpcond(kjumpt,r,lab,reg)
	esac

when j_notl then
	case opc
	when kjumpf then
		genjumpcond(kjumpt,q,lab,reg)
	when kjumpt then
		genjumpcond(kjumpf,q,lab,reg)
	esac

when j_istruel then
	genjumpcond(opc,q,lab,reg)

when j_eq,j_ne,j_lt,j_le,j_ge,j_gt then

	gcomparejump(opc,p,q,r,lab,reg)

when j_exprlist then
	while q and (r:=q^.nextunit) do
		dx_expr(q,reg)
		q:=r
	od

	genjumpcond(opc,q,lab,reg)
else			!other expression
	case p^.tag
	when j_preincr then			!this already sets the flag
		do_preincr(p^.a,m_add,m_inc)
	when j_predecr then			!this already sets the flag
		do_preincr(p^.a,m_sub,m_dec)
	else
		ax:=loadexpr(p,reg)
		genmc(m_cmp,ax,genint(0))
	esac

	genmc_cond(m_jmpcc, (opc|ne_cond|eq_cond),genlabel(lab))
endswitch
end

proc gcomparejump(int jumpopc,unit p,lhs,rhs,int lab,reg)=
!jumpopc is the base cmdcode needed: kjumpt or kjumpt
!p is the eq/compare unit
!convert into jumpcc cmdcode
ref opndrec ax,bx
int mclcond,cond,tx

cond:=p^.tag				!eqop,neop, etc

if jumpopc=kjumpf then			!need to reverse condition
	cond:=reversecond(cond)		!eqop => neop, etc
fi

mclcond:=getmclcond(cond,lhs^.mode)

case mclcond
when flt_cond,fge_cond,fle_cond,fgt_cond,feq_cond, fne_cond then

	if issimple(rhs) then
		ax:=floadexpr(lhs,reg)
!		bx:=fevalexpr(rhs,reg+getlregs(ax))
		bx:=fevalexpr(rhs,getnextreg(ax,reg))
	else
		tx:=saveexpr(rhs,reg)
		ax:=floadexpr(lhs,reg)
!		bx:=frestoreexpr(tx,reg+getlregs(ax))
		bx:=frestoreexpr(tx,getnextreg(ax,reg))
	fi
	genmc(m_fcmp,ax,bx)

else
	if issimple(rhs) then
		ax:=loadexpr(lhs,reg)
!		bx:=evalexpr(rhs,reg+getlregs(ax))
		bx:=evalexpr(rhs,getnextreg(ax,reg))
		genmc(m_cmp,ax,bx)

	elsif issimple(lhs) then			!reverse test, but also modify condition
		mclcond:=reversemclcond(mclcond)
		ax:=loadexpr(rhs,reg)
!		bx:=evalexpr(lhs,reg+getlregs(ax))
		bx:=evalexpr(lhs,getnextreg(ax,reg))
		genmc(m_cmp,ax,bx)

	else
		pushexpr(rhs,reg)
		ax:=loadexpr(lhs,reg)
!		bx:=genreg(reg+getlregs(ax),ax^.size)
		bx:=genreg(getnextreg(ax,reg),ax^.size)
		genmc(m_pop,changeopndsize(bx,targetsize))
		genmc(m_cmp,ax,bx)
	fi
esac

genmc_cond(m_jmpcc, mclcond,genlabel(lab))
END

function reversecond(int op)int=
!reverse conditional operator

case op
when j_eq then return j_ne
when j_ne then return j_eq
when j_lt then return j_ge
when j_le then return j_gt
when j_ge then return j_lt
when j_gt then return j_le
esac
return 0
end

proc do_preincr(unit a,int addop,incrop)=
ref opndrec ptropnd
int size

ptropnd:=getlvalueopnd(a)

if ttbasetype[a^.mode]=tref and ttsize[tttarget[a^.mode]]<>1 then
	size:=ttsize[tttarget[a^.mode]]
	genmc(addop,ptropnd,genint(size))
else
	genmc(incrop,ptropnd)
fi
end

function reversemclcond(int cond)int=
!reverse order due to operands being switched, so that <= becomes >=
!it is NOT the opposite condition (eg. <= becomes > or <> becomes =)

switch cond
when lt_cond then cond:=gt_cond		!needs symmetric reversal: < >
when le_cond then cond:=ge_cond		!<= >=
when ge_cond then cond:=le_cond		!>= <=
when gt_cond then cond:=lt_cond		!> <
when ltu_cond then cond:=gtu_cond		!needs symmetric reversal: < >
when leu_cond then cond:=geu_cond		!<= >=
when geu_cond then cond:=leu_cond		!>= <=
when gtu_cond then cond:=ltu_cond		!> <
when flt_cond then cond:=fgt_cond		!needs symmetric reversal: < >
when fle_cond then cond:=fge_cond		!<= >=
when fge_cond then cond:=fle_cond		!>= <=
when fgt_cond then cond:=flt_cond		!> <
endswitch
return cond
end

proc do_while (unit pcond, pbody) =
int lab_b,lab_c,lab_d

if pcond^.tag=j_const and pcond^.value then
	do_while1(pbody)
	return
fi

lab_c:=createfwdlabel()
lab_d:=createfwdlabel()

stacklooplabels(lab_c, lab_d)

genjumpl(lab_c)		!direct to condition code which is at the end

lab_b:=definelabel()

do_stmt(pbody)

definefwdlabel(lab_c)

genjumpcond(kjumpt,pcond,lab_b)
definefwdlabel(lab_d)
--loopindex
end

proc do_while1 (unit pbody) =
int lab_b,lab_c,lab_d

lab_c:=createfwdlabel()
lab_d:=createfwdlabel()

stacklooplabels(lab_c, lab_d)

lab_b:=definelabel()

do_stmt(pbody)

definefwdlabel(lab_c)

genjumpl(lab_b)
definefwdlabel(lab_d)
--loopindex
end

proc stacklooplabels(int a,b)=
!don't check for loop depth as that has been done during parsing
continuestack[++loopindex]:=a
breakstack[loopindex]:=b
end

proc do_dowhile (unit pbody, pcond) =
int lab_b,lab_c,lab_d

lab_c:=createfwdlabel()
lab_d:=createfwdlabel()

stacklooplabels(lab_c, lab_d)

lab_b:=definelabel()

do_stmt(pbody)

definefwdlabel(lab_c)

genjumpcond(kjumpt,pcond,lab_b)
definefwdlabel(lab_d)
--loopindex
end

proc do_for (unit pinit, pbody) =
unit pcond,pincr
int lab_b,lab_c,lab_d,lab_cond

pcond:=pinit^.nextunit
pincr:=pcond^.nextunit

lab_c:=createfwdlabel()
lab_d:=createfwdlabel()
lab_cond:=createfwdlabel()

if pinit^.tag<>j_null then
	do_stmt(pinit)
fi

genjumpl(lab_cond)		!direct to condition code which is at the end

stacklooplabels(lab_c, lab_d)

lab_b:=definelabel()

do_stmt(pbody)

definefwdlabel(lab_c)

do_stmt(pincr)
definefwdlabel(lab_cond)

if pcond^.tag<>j_null then
	genjumpcond(kjumpt,pcond,lab_b)
else
	genjumpl(lab_b)
fi
definefwdlabel(lab_d)
--loopindex
end

function pushffparams(unit p,int variadic=0)int=
!p is a list of units representing params for a foreign function
!return number params allocated on stack
!return 1 if extra 8 bytes pushed for alignment, otherwise 0
ref opndrec rx,fx
[4]byte iscomplex
int i,m,n,dummypush,size,popbytes,ncomplex
unit q
[maxparams]unit paramlist


n:=0
while p do
	if n>=maxparams then gerror("TOO MANY PARAMS") fi
	++n
	paramlist[n]:=p
	p:=p^.nextunit
od

m:=max(n,4)			!number of params on stack (always at least 4 including shadow space)
dummypush:=0

if (m iand 1) and stackaligned or (m iand 1)=0 and not stackaligned then
	dummypush:=1
	if n>4 then
		pushstack(8)
	fi
	popbytes:=(m+1)*8
else
	popbytes:=m*8
fi

for i:=n downto 5 do
	q:=paramlist[i]
	if variadic and ttbasetype[q^.mode]=tfloat then		!need to convert to double
		pushfloatparam(q)
	else
		pushexpr(q)
	fi
od

if dummypush and n<=4 then
	pushstack(40)
else
	pushstack(32)
fi

n:=min(n,4)

if n=1 then			!simple param, just load direct
	pushoneparam(paramlist[i],variadic)
	return popbytes
fi

ncomplex:=0

!first pass, push complex params

!HAVE REVERSED ORDER OF PARAM EVALUATION: RIGHT TO LEFT FOR BOTTOM 4,
!FOR FIRST PASS, THEN LEFT TO RIGHT. Otherwise if doing param 4 first
!into r13, then can be overridden. (Perhaps need another scratch register)

!for i:=1 to n do
for i:=n downto 1 do
	q:=paramlist[i]
	if issimplepm(q) then
		iscomplex[i]:=0
	else
		pushexpr(q)
		iscomplex[i]:=1
		++ncomplex
	fi
od

!second pass, pop any complex params

!(NOTE: can be optimised when all only one complex param)
!for i:=n downto 1 do
for i:=1 to n do
	q:=paramlist[i]
	if gettypecat(q)<>'R' then
		if iscomplex[i] then
			genmc(m_pop,rx:=genreg(r10+i-1,targetsize))		!register must be full size
		else
			rx:=loadexpr(q,r10+i-1)
		fi
	else
		if variadic and ttbasetype[q^.mode]=tfloat then		!need to convert to double
			loadfloatparam(q,i-1,iscomplex[i])
		else
			size:=ttsize[q^.mode]
			if iscomplex[i] then
				genmc(m_pop,rx:=genreg(r13,targetsize))		!register must be full size
				genmc(m_fmov,fx:=genxreg(xr0+i-1,size),changeopndsize(rx,size))
			else
				fx:=floadexpr(q,xr0+i-1)
			fi

			if variadic then
				genmc(m_fmov,genreg(r10+i-1,size),fx)
			fi
		fi
	fi
od

return popbytes
end

proc pushoneparam(unit q, int variadic)=
ref opndrec fx,ax,bx

	if gettypecat(q)<>'R' then
		if issimple(q) then
			loadexpr(q,r10)
		else
			ax:=loadexpr(q,r0)
			bx:=genreg(r10,ax^.size)
			genmc(m_mov, bx,ax)
		fi
	else
		fx:=floadexpr(q,xr0)
		if variadic then
			genmc(m_fmov,genreg(r10,ttsize[q^.mode]),fx)
		fi
	fi
end

proc pushfloatparam(unit q)=
!for loading real32 to stack for variadic functions
ref opndrec ax,bx,fx

!GENCOMMENT("PUSHFLOATPARAM")

!fx:=floadexpr(q,xr15)
fx:=floadexpr(q,xr13)
genmc(m_fwiden,ax:=changeopndsize(fx,8),fx)
genmc(m_fmov,bx:=genreg(r13,8),ax)
genmc(m_push,bx)
end

proc loadfloatparam(unit q,int regoffset,iscomplex)=
!for loading real32 to regs for variadic functions
!q points to the real32 expr
!regoffset is 0..3; value needs loading in xmm0..3 and r10..r13
!iscomplex means the value exists, as real32, on the stack

ref opndrec ax,ax32,fx,fx32

fx:=genxreg(xr0+regoffset,8)
fx32:=genxreg(xr0+regoffset,4)
ax:=genreg(r10+regoffset,8)
ax32:=genreg(r10+regoffset,4)

if iscomplex then
	genmc(m_pop,ax)
	genmc(m_fmov,fx32,ax32)
	genmc(m_fwiden,fx,fx32)
	genmc(m_fmov,ax,fx)
else
	floadexpr(q,xr0+regoffset)
	genmc(m_fwiden,fx,fx32)
	genmc(m_fmov,ax,fx)
fi
end

function dx_call(unit p,a,b,int reg)ref opndrec=
ref opndrec result,cx,sx
ref paramrec pm
int isfnptr,variadic,nparams,retmode,nbytes,retsize,m,nregparams

retmode:=p^.mode
if retmode=tvoid then retmode:=tsint fi

case a^.tag
when j_ptr then
!CPL "DXCALL",STRMODE(A^.MODE)
	m:=a^.mode
	while ttbasetype[m]=tref do
		m:=tttarget[m]
	od

	pm:=ttparams[m]
	isfnptr:=1

else
	pm:=a^.def^.paramlist
	isfnptr:=0

esac

variadic:=pm^.flags=pm_variadic
nparams:=pm^.nparams

nbytes:=pushffparams(b,variadic)

retsize:=ttsize[retmode]
if retsize>8 then
	doblockcall(retsize)
fi

if not isfnptr then
	genmc(m_call,genmemaddr_u(a))
else
	if issimple(a) then
		genmc(m_call,changeopndsize(loadexpr(a^.a),ptrsize))
	else
		nregparams:=min(nparams,4)
		sx:=genireg(rstack,8)
		for i:=1 to nregparams do
			genmc(m_mov, applyoffset(sx,(i-1)*8),genreg(r10+i-1,8))
		od
		cx:=changeopndsize(loadexpr(a^.a),ptrsize)
		sx:=genireg(rstack,8)
		for i:=1 to nregparams do
			genmc(m_mov, genreg(r10+i-1,8),applyoffset(sx,(i-1)*8))
		od
		genmc(m_call,cx)
	fi

fi

popstack(nbytes)

if gettypecat(p)='R' then
	result:=genxreg(reg,retsize)
elsif retsize<=8 then
	result:=genreg(reg,retsize)
else
	result:=getblockreg(retsize)
fi
!IF TTSIZE[RETMODE]>8 THEN
!	CPL "CALL RETURNS BLOCK"
!FI

return result
end

proc do_return(unit a)=

leaveproc(currproc^.name)

if a then
	if isrealcc(a^.mode) then
		floadexpr(a)
	else
		loadexpr(a)

		if structretoffset then
			copyretvalue(ttsize[a^.mode])
		fi
	fi
fi
genreturn(framebytes,parambytes)
end

function dx_sub(unit a,b,int reg)ref opndrec=
ref opndrec ax,bx
int tx,doneg

if gettypecat(a)='R' then
	return dx_fadd(m_sub,a,b,reg)
fi
doneg:=0

!GOTO SIMPLESUB

if issimple(b) then
SIMPLESUB::
	ax:=loadexpr(a,reg)
!	bx:=evalexpr(b,reg+getlregs(ax))
	bx:=evalexpr(b,getnextreg(ax,reg))

elsif issimple(a) then		!reverse order, add neg at the end
	ax:=loadexpr(b,reg)
!	bx:=evalexpr(a,reg+getlregs(ax))
	bx:=evalexpr(a,getnextreg(ax,reg))
	doneg:=1
else
	tx:=saveexpr(b,reg)
	ax:=loadexpr(a,reg)
!	bx:=restoreexpr(tx,reg+getlregs(ax))
	bx:=restoreexpr(tx,getnextreg(ax,reg))
fi
genmc(m_sub,ax,bx)
if doneg then
	genmc(m_neg,ax)
fi

return ax
end

function dx_mul(unit p,a,b,int reg)ref opndrec=
ref opndrec ax,bx
int64 x
int n,opc,tx

case gettypecat(a)
when 'R' then
	return dx_fadd(m_imul,a,b,reg)
esac

!if b^.tag=j_const and tfirstint<=ttbasetype[b^.mode]<=tlastint then
if b^.tag=j_const and isintcc(b^.mode) then
	x:=b^.value
	if n:=ispoweroftwo(x) then
		p^.tag:=j_shl
		b^.value:=n
		return dx_shl(p,a,b,reg)
	fi
fi

if issimple(b) then

!should do special processing when a==b, but here only check for simple case of x*x
	ax:=loadexpr(a,reg)
	if a^.tag=j_name and b^.tag=j_name and a^.def=b^.def then
		bx:=ax
	else
!		bx:=evalexpr(b,reg+getlregs(ax))
		bx:=evalexpr(b,getnextreg(ax,reg))
	fi
elsif issimple(a) then	!reverse order
	ax:=loadexpr(b,reg)
!	bx:=evalexpr(a,reg+getlregs(ax))
	bx:=evalexpr(a,getnextreg(ax,reg))
else
	tx:=saveexpr(b,reg)
	ax:=loadexpr(a,reg)
!	bx:=restoreexpr(tx,reg+getlregs(ax))
	bx:=restoreexpr(tx,getnextreg(ax,reg))
fi

genmc(m_imul,ax,bx)

return ax
end

function dx_div(unit p,a,b,int reg)ref opndrec=
ref opndrec ax,bx
int opc,n,tx

case gettypecat(a)
when 'R' then
	return dx_fadd(m_idiv,a,b,reg)

when 'I' then
	opc:=m_idiv
else
	opc:=m_udiv
esac

!if b^.tag=j_const and tfirstint<=ttbasetype[b^.mode]<=tlastint then
if b^.tag=j_const and isintcc(b^.mode) then
	if n:=ispoweroftwo(b^.value) then
		p^.tag:=j_shr
		b^.value:=n
		return dx_shl(p,a,b,reg)
	fi
fi

if reg<>r0 then
	gerror("DIV REG NOT ZERO")
fi

if issimple(b) then
	ax:=loadexpr(a,reg)
	if b^.tag=j_const then
!		bx:=loadexpr(b,reg+getlregs(ax))
		bx:=loadexpr(b,getnextreg(ax,reg))
	else
!		bx:=evalexpr(b,reg+getlregs(ax))
		bx:=evalexpr(b,getnextreg(ax,reg))
	fi
else
	tx:=saveexpr(b,reg)
	ax:=loadexpr(a,reg)
!	bx:=restoreexpr(tx,reg+getlregs(ax))
	bx:=restoreexpr(tx,getnextreg(ax,reg))
fi

genmc(opc,bx)

return ax
end


function dx_shl(unit p,a,b,int reg)ref opndrec=
!shl/shr
ref opndrec ax,bx
int opc,tx

if p^.tag=j_shl then
	opc:=m_shl
else
	case gettypecat(p)
	when 'I' then
		opc:=m_ishr
	else
		opc:=m_ushr
	esac
fi

if issimple(b) and reg<>r10 then
	ax:=loadexpr(a,reg)
	if b^.tag=j_const then
		bx:=evalexpr(b,r10)
	else
		bx:=loadexpr(b,r10)
	fi
else
	tx:=saveexpr(b,reg)
	ax:=loadexpr(a,reg)
!	bx:=restoreexpr(tx,reg+getlregs(ax))
	bx:=restoreexpr(tx,getnextreg(ax,reg))
fi

genmc(opc,ax,bx)

return ax
end

function dx_iand(int opc,unit a,b,int reg)ref opndrec=
!iand/ior/ixor
!I think also and/or
ref opndrec ax,bx
int tx

if issimple(b) then
	ax:=loadexpr(a,reg)
!	bx:=evalexpr(b,reg+getlregs(ax))
	bx:=evalexpr(b,getnextreg(ax,reg))

elsif issimple(a) then	!reverse order
	ax:=loadexpr(b,reg)
!	bx:=evalexpr(a,reg+getlregs(ax))
	bx:=evalexpr(a,getnextreg(ax,reg))

else
	tx:=saveexpr(b,reg)
	ax:=loadexpr(a,reg)
!	bx:=restoreexpr(tx,reg+getlregs(ax))
	bx:=restoreexpr(tx,getnextreg(ax,reg))
fi
genmc(opc,ax,bx)

return ax
end

function dx_preincrx(unit p,a,int reg)ref opndrec=
int opc,size
ref opndrec ptropnd, result

ptropnd:=getlvalueopnd(a,reg)

opc:=m_mov

result:=genreg(getnextreg(ptropnd,reg),getopndsize_u(p))
if result^.size>ptropnd^.size then
GERROR("PREINCRX WIDENING NEEDED")
!	opc:=getwidencode(a^.mode,p^.mode)
fi

genmc(opc,result,ptropnd)

!if p^.a^.mode.basetypeno=t_ref and p^.a^.mode.target.size<>1 then
if ttbasetype[a^.mode]=tref and ttsize[tttarget[a^.mode]]<>1 then
	size:=ttsize[tttarget[a^.mode]]
	if p^.tag= j_preincr then
		opc:=m_add
	else
		opc:=m_sub
	fi
	genmc(opc,result,genint(size))
else
	genmc((p^.tag=j_preincr|m_inc|m_dec),result)
fi
storeopnd(ptropnd,result)

return result
end

function dx_postincrx(unit p,a,int reg)ref opndrec=
int opc,size,convop
ref opndrec ptropnd, result, rr1

result:=genreg(reg,getopndsize_u(p))
ptropnd:=getlvalueopnd(a,reg+1)

opc:=m_mov

if result^.size>ptropnd^.size then
GERROR("POSTINCRX WIDENING NEEDED")
!	convop:=conversionops(ttbasetype[a^.mode],ttbasetype[p^.mode])
!	if 
!	opc:=getwidencode(a^.mode,p^.mode)
fi

!genmc(opc,rr1:=genreg(reg+1+getaregs(ptropnd),getopndsize_u(p)),ptropnd)
genmc(opc,rr1:=genreg(getnextreg(ptropnd,reg)+1,getopndsize_u(p)),ptropnd)
genmc(m_mov,result,rr1)

!if p^.a^.mode.basetypeno=t_ref and p^.a^.mode.target.size<>1 then
!	size:=p^.a^.mode.target.size
if ttbasetype[a^.mode]=tref and ttsize[tttarget[a^.mode]]<>1 then
	size:=ttsize[tttarget[a^.mode]]
	if p^.tag= j_postincr then
		opc:=m_add
	else
		opc:=m_sub
	fi
	genmc(opc,rr1,genint(size))
else
	genmc((p^.tag=j_postincr|m_inc|m_dec),rr1)
fi
storeopnd(ptropnd,rr1)
return result
end

function makeindexopnd(unit a,index=nil, int scale=1,size,offset=0,reg=r0)ref opndrec=
! General routine to deal with pointers, pointers+offsets, records+offsets,
! array access with indices+offsets
! a, index are units
! index is optional, so can be nil
! index can also be a const unit, in which case it's added onto the fixed offset
! scale is the size of the object being fetched, used as scale factor for pointer+offset
!  or for index ops
! offset is a fixed byte-offset (0 if not needed)
! For extra offsets associated with array lower-bound adjustments, the caller adds
! the necessary byte-offset into offset
! Returns a memory access operand, but does not load the value
! If the address is of interest, the caller uses LEA on the result
! to load the results, a load operation (eg. m_mov) can be used
int mulfactor, tx, reg2
ref opndrec ax,ix,m
ref strec d

!GENCOMMENT("MAKINDEX")

if index and index^.tag=j_const then
	offset+:=index^.value*scale
	index:=nil
fi
!size:=scale

if index then
	case scale
	when 1,2,4,8 then
		mulfactor:=1
	else								!do the multiply here
		mulfactor:=scale
		scale:=1
	esac
fi

if a^.tag=j_name then
	d:=a^.def
	if d^.nameid=paramid and isstructunion(d^.mode) then
GOTO MX2
	fi

!CPL "HERE6"
	if index then							!name/(simple-complex)
		if mulfactor=1 then					!using scale factor
			ix:=loadexpr(index,reg)
			m:=genindex(ireg:ix^.reg, scale:scale,def:d,offset:offset,size:size)
		else
			loadexpr(index,reg)
			mulreg(reg,mulfactor)
			m:=genindex(ireg:reg, scale:scale,def:d,offset:offset,size:size)
		fi
	else								!name/const
		m:=genindex(def:d,offset:offset,size:size)
	fi
else
mx2::
	if index then
		if issimple(a) then				!simple/(simple-complex)
!CPL "HERE3",MULFACTOR
			if mulfactor=1 then
!GENCOMMENT("HERE3")
!CPL =JTAGNAMES[INDEX^.TAG]
				ix:=loadexpr(index,reg)
				ax:=loadexpr(a,reg+1)
!CPL "HERE4"
!GENCOMMENT("HERE4")
!				ax:=loadexpr(a,getnextreg(ix))
				m:=genindex(areg:ax^.reg, ireg:ix^.reg, scale:scale,offset:offset,size:size)
			else
				loadexpr(index,reg)
				mulreg(reg,mulfactor)
				loadexpr(a,reg+1)
				m:=genindex(areg:reg+1, ireg:reg, scale:scale,offset:offset,size:size)
			fi
		elsif issimple(index) then			!complex/simple
!CPL "HERE4"
			loadexpr(a,reg)
			loadexpr(index,reg+1)
			mulreg(reg+1,mulfactor)
			m:=genindex(areg:reg, ireg:reg+1, scale:scale,offset:offset,size:size)
		else							!complex/complex
!CPL "HERE5"
			tx:=saveexpr(a,reg)
			ix:=loadexpr(index,reg)
			mulreg(reg,mulfactor)
!			ax:=restoreexpr(tx,reg2:=reg+getlregs(ix))
			ax:=restoreexpr(tx,reg2:=getnextreg(ix,reg))
			m:=genindex(areg:reg2, ireg:reg, scale:scale,offset:offset,size:size)
		fi
	else								!(simple-complex)/const
		ax:=loadexpr(a,reg)
		m:=genindex(areg:ax^.reg, scale:scale,offset:offset,size:size)
	fi
fi

return m
end

proc mulreg(int reg,int64 x)=
!multiply value in register by factor x
int n

if x>1 then
	if n:=ispoweroftwo(x) then
		genmc(m_shl,genreg(reg,8),genint(n))
	else
		genmc(m_imul,genreg(reg,8),genint(x))
	fi
fi
end

function dx_ptr(unit p,a,int reg,am=1)ref opndrec=
ref opndrec ax,bx

if am=0 then
	return loadexpr(a,reg)
fi

if ttbasetype[p^.mode]=tproc then gerror("deref/proc") fi

ax:=evalptr(a,reg)
case a^.tag
when j_addptr, j_subptr then
	if ax^.mode<>a_reg then			!ax represents access to actual pointer target
		ax:=applysize(ax,ttsize[p^.mode])
!CPL "DXPTR1",STROPND(AX)
		return ax
	fi

when j_addrof then
	return dx_expr(a^.a,reg,am)
esac

if ax^.mode<>a_reg then
	genmc(m_mov,bx:=genreg(reg,ptrsize),ax)
	ax:=bx
fi
ax:=makeindirect(ax,ttsize[p^.mode])

!CPL "DXPTR3",STROPND(AX)
return ax
end

function dx_addptr(unit p,a,b,int reg,am=1)ref opndrec=
!works out

!addptr differs from add in that b needs to scaled, usually by 2,4,8 but could
!be anything
int size,scale,mulfactor,reg1,tx,offset
ref opndrec m,ax,bx,rx
unit pname

!RETURN GENINT(999)

!CPL "ADDPTR"
!PRINTUNIT(NIL,A); CPL
!PRINTUNIT(NIL,B)

!AX:=EVALEXPR(A,REG)
!AX:=EVALADDR(A,REG)
!CPL =STROPND(AX)

!CPL "ADDPTR",=STRMODE(A^.MODE)
size:=scale:=ttsize[tttarget[a^.mode]]
if p^.ptrscale=0 then scale:=1 fi			!addptr from dot op: offset in bytes

!return genint(12345)

offset:=0
if b^.tag=j_const then
!CPL =SCALE
	b^.value*:=scale
	offset:=b^.value
	scale:=1
fi

case scale
when 2,4,8 then
	mulfactor:=1
else
	mulfactor:=scale
	scale:=1
esac

reg1:=reg+1

!GOTO CXCX

!if b^.tag=j_const then
!	loadexpr(a,reg)
!	m:=genindex(areg:reg, scale:scale,size:size, offset:b^.value)

if b^.tag=j_const then					!any+const
	case a^.tag
	when j_addrof then
		pname:=a^.a
!CPL "ADDROF/NAME"
		if pname^.tag<>j_name then goto other fi
		m:=genindex(def:pname^.def,offset:offset,size:size)
!	when j_addptr, j_subptr then
!		ax:=evalptr(a,reg)
!CPL "ADDPTR/ADDPTR+CONST",=STROPND(AX)
!		if ax^.mode=a_reg then
!			ax:=makeindirect(ax)
!		fi
!		m:=applyoffset(ax,offset,size)
!	when j_const then
	else
other::
		loadexpr(a,reg)
		m:=genindex(areg:reg, scale:scale,size:size, offset:b^.value)
!		goto cxcx
	esac

elsif a^.tag=j_addrof and a^.a^.tag=j_name then		!&a+const
!CPL "&NAME+ANY",MULFACTOR
!IF MULFACTOR>=8 THEN
!GOTO CXCX
!	PRINTUNIT(NIL,A)
!FI
	pname:=a^.a
	bx:=loadexpr(b,reg)				!R
	mulreg(bx^.reg,mulfactor)
	bx:=makeindirect(bx,size)		![R]
	bx^.regix:=bx^.reg
	bx^.reg:=0

	bx^.scale:=scale
	bx^.def:=pname^.def				![R+d]
	if isframe(pname^.def) then
		bx^.reg:=rframe
	fi
	m:=bx

elsif issimple(b) then
!CPL "CX/SX"
	loadexpr(a,reg)
	loadexpr(b,reg1)
	mulreg(reg1,mulfactor)
	m:=genindex(areg:reg, ireg:reg1, scale:scale,size:size)
elsif issimple(a) then
!CPL "SX/CX"
	loadexpr(b,reg)
	mulreg(reg,mulfactor)
	loadexpr(a,reg1)
	m:=genindex(areg:reg1, ireg:reg, scale:scale,size:size)
else
cxcx::
!CPL "CX/CX"

	tx:=saveexpr(b,reg)
	ax:=loadexpr(a,reg)
	bx:=restoreexpr(tx,getnextreg(ax,reg))
	mulreg(bx^.reg,mulfactor)
	m:=genindex(areg:reg, ireg:bx^.reg, scale:scale,size:size)
fi

case am
when 1 then
	genmc(m_lea,rx:=genreg(reg,ptrsize),m)
	return rx
esac
return m
end

function dx_subptr(unit a,b,int reg,am)ref opndrec=
int size,scale,mulfactor,reg1,tx,offset
ref opndrec m,ax,bx,rx,ix
ref strec d

!CPL "SUBPTR",=AM

size:=scale:=ttsize[tttarget[a^.mode]]

if ttbasetype[b^.mode]=tref then		!ptr-ptr
	ax:=dx_sub(a,b,reg)
	divreg(ax^.reg,scale)
	return ax
fi

!if am='L' then
!	if scale=1 then
!		return dx_sub(a,b,reg)
!	fi
!	if b^.tag=j_const then
!		b^.value*:=scale
!		return dx_sub(a,b,reg)
!	fi
!fi

offset:=0
if b^.tag=j_const then
	b^.value:=b^.value*scale
	offset:=-b^.value
	scale:=1
fi

mulfactor:=scale
scale:=1

reg1:=reg+1

!CPL "SUBPTR2",=SIZE,=SCALE,=MULFACTOR,=OFFSET

if a^.tag=j_addrof and a^.a^.tag=j_name then
!CPL "SUBPTR3"
	a:=a^.a
fi

!GOTO CXCX

if b^.tag=j_const then
!CPL "SUB/CONST"
!GOTO CXCX
!if b^.tag=j_const then
	loadexpr(a,reg)
	m:=genindex(areg:reg, scale:scale,size:size, offset:offset)
!subptr1::
	if am=2 then
		return m
	fi
	genmc(m_lea,rx:=genreg(reg,ptrsize),m)

	return rx

elsif issimple(b) then
!CPL "SUB/CX/SX"
!GOTO CXCX
	ax:=loadexpr(a,reg)
	bx:=loadexpr(b,reg1)
	mulreg(reg1,mulfactor)
!	m:=genindex(areg:reg, ireg:reg1, scale:scale,size:size)
elsif issimple(a) then
!CPL "SUB/SX/CX"
!GOTO CXCX
	bx:=loadexpr(b,reg)
	mulreg(reg,mulfactor)
	ax:=loadexpr(a,reg1)
!	m:=genindex(areg:reg1, ireg:reg, scale:scale,size:size)
else
CXCX::
	tx:=saveexpr(b,reg)
	ax:=loadexpr(a,reg)
!	bx:=restoreexpr(tx,reg+getlregs(ax))
	bx:=restoreexpr(tx,getnextreg(ax,reg))
	mulreg(bx^.reg,mulfactor)
fi
m:=genindex(areg:reg, ireg:bx^.reg, scale:scale,size:size)

genmc(m_sub,ax,bx)

return ax
end

function dx_convert(unit a, int t,opc, reg)ref opndrec=
!convert unit a to type t, using conversion opc (uwiden_c etc)
ref opndrec ax,rx
int ssize,tsize

ssize:=ttsize[a^.mode]
tsize:=ttsize[t]

case opc
when sfix_c,ufix_c, fnarrow_c,fwiden_c then
	ax:=fevalexpr(a,reg)
else
	ax:=evalexpr(a,reg)			!may need feval for some ops
esac

case opc
when soft_c then
dosoft::
	return ax

when hard_c then

	rx:=genreg(reg,tsize)
	if tsize<ssize then				!narrow
		genmc(m_unarrow,rx,ax)

	elsif tsize>ssize then			!widen
		genmc(m_uwiden,rx,ax)

	else							!same size just different type
		return ax
	fi

when swiden_c, uwiden_c then
if ax^.mode=a_imm then
	ax^.size:=tsize
	return ax
fi
	if ssize=tsize then return ax fi
	rx:=genreg(reg,tsize)
	genmc((opc=swiden_c|m_iwiden|m_uwiden),rx,ax)

when sfloat_c,ufloat_c then
	rx:=genxreg(reg,tsize)	
	genmc((opc=sfloat_c|m_ifloat|m_ufloat),rx,ax)

when sfix_c,ufix_c then
	rx:=genreg(reg,tsize)	
	genmc((opc=sfix_c|m_ifix|m_ufix),rx,ax)

when fnarrow_c,fwiden_c then
	rx:=genxreg(reg,tsize)	
	genmc((opc=fnarrow_c|m_fnarrow|m_fwiden),rx,ax)

when narrow_c,truncate_c then
	rx:=genreg(reg,tsize)	
	genmc(m_unarrow,rx,ax)

else
	gerror_s("Convert op not implem: %s",convnames[opc])
esac
return rx
end

proc do_decl(ref strec d)=
ref opndrec ax
unit a,dest
[256]char str
int nbytes

!CPL "DODECL",D.NAME

a:=d^.code

!case ttbasetype[d^.mode]
!when tunion,tstruct then
!	if a^.tag<>j_makelist then
!CPL "HERE1"
!!		gerror("Dynamic struct init")
!	fi
!esac

if a^.tag<>j_makelist then
	if ttbasetype[d^.mode]=tarray and a^.tag=j_const then	!probably string lit
		goto copyl
	fi
	if gettypecat(a)='R' then
		ax:=floadexpr(a,xr0)
		genmc(m_fmov,genmem_d(d),ax)
	elsif a^.tag<>j_const then
		case ttsize[a^.mode]
		when 1,2,4,8 then
			ax:=loadexpr(a,r0)
			genmc(m_mov,genmem_d(d),ax)
		else
			dest:=createname(d)
			dest^.mode:=d^.mode
			do_assignblock(dest,a,r0)
		esac
	else
		genmc(m_mov,genmem_d(d),evalexpr(a))
	fi
	return
fi

copyl::

nbytes:=ttsize[d^.mode]
pushstack(32)

genmc(m_lea, genreg(r10,ptrsize),genmem_d(d))

!sprintf(&.str,"`$%s.%s.%d",currproc^.name,d^.name,int32(d^.blockno))
fprint @&.str,"`$#.#.#",currproc.name,d.name,d.blockno

genmc(m_mov, genreg(r11,ptrsize), genname(&.str))

genmc(m_mov,genreg(r12,ptrsize),genint(nbytes))

genmc(m_call,genname("memcpy*"))

popstack(32)

end

function do_assignblock (unit a,b, int regx=0)ref opndrec =
!special optimised code for blocks; specifically 16-byte ones
!return operand for one the block just copied, or 0 if it could not be done here
ref opndrec ax,bx,rx,rs,rd,rcount,bx2,rsa,rda
int rev,workreg,nwords,lab, regcount,regsource, regdest, offset, n, oddbytes, reg

reg:=(regx|regx|xr0)

rev:=0
if issimple(b) then
!CPL "SSB"
	ax:=getlvalueopnd(a,reg)
!	bx:=getlvalueopnd(b,reg+getaregs(ax))
	bx:=getlvalueopnd(b,getnextreg(ax,reg))

elsif issimple(a) then
!CPL "SSA"
	rev:=1
	ax:=getlvalueopnd(b,reg)
!	bx:=getlvalueopnd(a,reg+getaregs(ax))
	bx:=getlvalueopnd(a,getnextreg(ax,reg))

else
!CPL "CXAB"
	bx:=getlvalueopnd(b,reg)
	if bx^.mode<>a_reg then
		genmc(m_lea,bx2:=genreg(reg,ptrsize),bx)
	else
		bx2:=bx
	fi
	genmc(m_push,bx2)
	ax:=getlvalueopnd(a,reg)

!	genmc(m_pop,genreg(reg:=reg+getaregs(ax),ptrsize))
	genmc(m_pop,bx:=genreg(getnextreg(ax,reg),ptrsize))
	bx:=genireg(bx^.reg)

fi

if ax^.mode=a_reg then ax:=genireg(ax^.reg) fi
if bx^.mode=a_reg then bx:=genireg(bx^.reg) fi

if rev then
	swap(ax,bx)
fi

!ax is the access operand for the dest, and bx for the source

!CPL "BLOCK ASSIGN:",=GETNEXTREG(AX),GETNEXTREG(BX)
!CPL "BLOCK ASSIGN:",=STROPND(AX),=STROPND(BX)

IF GETNEXTREG(AX)>R4 OR GETNEXTREG(BX)>R4 THEN GERROR("ASSIGNBLOCK/REG") fi

workreg:=r4

!n:=ax^.size
n:=ttsize[a^.mode]

oddbytes:=n rem 8		!will be zero, or 1..7
n-:=oddbytes			!n will always be a multiple of 8; n can be zero too
nwords:=n/8			!number of dwords (ie. octobytes)

if 1<=nwords<=4 then		!use unrolled code (no loop)
	offset:=0
	ax:=changeopndsize(ax,targetsize)
	bx:=changeopndsize(bx,targetsize)
	rx:=genreg(workreg,targetsize)
	to nwords do
		genmc(m_mov,rx,applyoffset(bx,offset))

		genmc(m_mov,applyoffset(ax,offset),rx)
		offset+:=8
	od
	rs:=bx
	rd:=ax

elsif nwords<>0 then		!use a loop
	lab:=++labelno
	regcount:=workreg+1
	regsource:=regcount+1
	regdest:=regsource+1
	genmc(m_lea,rsa:=genreg(regsource,ptrsize),bx)
	genmc(m_lea,rda:=genreg(regdest,ptrsize),ax)
	rs:=genireg(regsource,ptrsize)
	rd:=genireg(regdest,ptrsize)
	rx:=genreg(workreg,targetsize)
	rcount:=genreg(regcount,4)

	genmc(m_mov,rcount,genint(nwords))
	genmc(m_label,genlabel(lab))
	genmc(m_mov,rx,rs)
	genmc(m_mov,rd,rx)
	genmc(m_add,rsa,genint(targetsize))
	genmc(m_add,rda,genint(targetsize))
	genmc(m_dec,rcount)
	genmc_cond(m_jmpcc,ne_cond,genlabel(lab))
	offset:=0
else
	rd:=changeopndsize(ax,targetsize)
	rs:=changeopndsize(bx,targetsize)
	offset:=0
fi

if oddbytes then
	n:=oddbytes						!1..7

	if n>=4 then
		rx:=genreg(workreg,4)
		genmc(m_mov,rx,applyoffset(rs,offset))
		genmc(m_mov,applyoffset(rd,offset),rx)
		n-:=4
		offset+:=4
	fi
	if n>=2 then
		rx:=genreg(workreg,2)
		genmc(m_mov,rx,applyoffset(rs,offset))
		genmc(m_mov,applyoffset(rd,offset),rx)
		n-:=2
		offset+:=2
	fi
	if n=1 then
		rx:=genreg(workreg,1)
		genmc(m_mov,rx,applyoffset(rs,offset))
		genmc(m_mov,applyoffset(rd,offset),rx)
	fi
fi
!GENCOMMENT("------DONE BLOCK COPY")

if regx then
	return getlvalueopnd(a,reg)
fi
return genint(0)
end

function dx_widen(unit a, int m, reg)ref opndrec=
ref opndrec ax,bx
int opc

opc:=(gettypecat(a)='I'|m_iwiden|m_uwiden)

ax:=evalexpr(a,reg)

if ttsize[m]=ax^.size then
	return ax
fi
bx:=genreg(reg,ttsize[m])
genmc(opc,bx,ax)

return bx
end

function dx_neg(unit a,int reg)ref opndrec=
ref opndrec ax

if gettypecat(a)='R' then
	return dx_fneg(a,reg)
fi
ax:=loadexpr(a,reg)
genmc(m_neg,ax)
return ax
end

function dx_fneg(unit a,int reg)ref opndrec=
ref opndrec fx

fx:=floadexpr(a,reg)
genmc(m_fneg,fx)
return fx
end

function dx_inot(unit a,int reg)ref opndrec=
ref opndrec ax

ax:=loadexpr(a,reg)
genmc(m_not,ax)
return ax
end

proc do_switch(unit p,a,b)=
!need to create switch levels, as they can be nested; nested case labels
!belong to the top switch level
[maxswitchrange]int labeltable				!sw_length+1 labels
[maxcases]int valuetable					!sw_length+1 labels
[maxswitchrange]byte flags					!flags to check dupl values
int defaultlabel							!index of fwd default label
int breakswlabel							!index of fwd break label
int switchlabel								!index of fwd break label
int lower, upper							!ower/upper ranges of switch case values
int length,value,ncases
byte serialsw
int i,index
!int sw_index
ref caserec pcase
ref opndrec ax,bx

!store current set of global values for outer switch
ref[]int old_labeltable
ref[]int old_valuetable
int old_ncases,old_lower
byte old_defaultseen
int old_defaultlabel
int old_breaklabel

pcase:=p^.nextcase
ncases:=length:=0

while pcase do
	++ncases
	if ncases>maxcases then
		gerror("Too many cases on one switch")
	fi
	valuetable[ncases]:=value:=pcase^.value

	if ncases=1 then
		lower:=upper:=value
	else
		lower:=min(lower,value)
		upper:=max(upper,value)
	fi
	pcase:=pcase^.nextcase
od

if p^.nextcase then
	length:=upper-lower+1
else
	length:=0
fi 

!allocate fwd labels
defaultlabel:=createfwdlabel()		!(when no default:, same as breakswlabel)
breakswlabel:=createfwdlabel()

if length>maxswitchrange then

!NOTES: SERIAL switch needs a way of checking duplicate case values.
!Better if not an n-squared search
!Short length switches should also be done serially (length<=8)
!Then a dupl check is simpler

	serialsw:=1

	ax:=loadexpr(a)
	for i:=1 to ncases do
		labeltable[i]:=createfwdlabel()
		genmc(m_cmp,ax,genint(valuetable[i]))
		genmc_cond(m_jmpcc,eq_cond,genlabel(labeltable[i]))
	od
	genmc(m_jmp,genlabel(defaultlabel))

elsif length=0 then
!GERROR("L=0")
	genmc(m_jmp,genlabel(defaultlabel))

else
	serialsw:=0
	memset(&flags,0,length)				!clear value flags

!fill table with defaults first
	for i:=1 to length do
		labeltable[i]:=defaultlabel
	od

!now, do labels for each case value
	for i:=1 to ncases do
		value:=valuetable[i]
		index:=value-lower+1			!index of value within label table
		labeltable[index]:=createfwdlabel()

		if flags[index] then
			gerror_s("Dupl case value: %d",cast(value))
		fi
		flags[index]:=1
	od

!need a label for the switchtable itself
	switchlabel:=createfwdlabel()

	ax:=loadexpr(a)
	genmc(m_sub,ax,genint(lower))
	genmc(m_cmp,ax,genint(length))
	genmc_cond(m_jmpcc, geu_cond, genlabel(defaultlabel))

	genmc(m_jmp, genindex(ireg:r0,scale:8,labno:switchlabel))

	setsegment('I',8)
	definefwdlabel(switchlabel)

	for i:=1 to length do
		genmc(m_dq,genlabel(labeltable[i]))
	od
	setsegment('C')
fi

!generate code for the switch body
!I need to make available essential tables, offsets etc necessary for j-case
!to be mappable to a label
!note: if already in an outer switch, then must save those earlier vars
!save outer switch vars
old_labeltable:=sw_labeltable
old_valuetable:=sw_valuetable
old_lower:=sw_lower
old_ncases:=sw_ncases
old_defaultseen:=sw_defaultseen
old_defaultlabel:=sw_defaultlabel
old_breaklabel:=sw_breaklabel

!set globals
sw_labeltable:=&labeltable
sw_valuetable:=&valuetable		!NEEDED ONLY FOR COMPLEX SWITCH
sw_lower:=lower

sw_ncases:=(serialsw|ncases|0)
sw_defaultseen:=0
sw_defaultlabel:=defaultlabel
sw_breaklabel:=breakswlabel

do_stmt(b)						!switch body

!need to note whether a default label has been generated; if not, define
!default label here
if not sw_defaultseen then
	definefwdlabel(defaultlabel)
fi
!define breakswlabel here
definefwdlabel(breakswlabel)

!restore any values of outer switch statement
sw_labeltable:=old_labeltable
sw_valuetable:=old_valuetable
sw_lower:=old_lower
sw_ncases:=old_ncases
sw_defaultseen:=old_defaultseen
sw_defaultlabel:=old_defaultlabel
sw_breaklabel:=old_breaklabel
end

function dx_rem(unit p,a,b,int reg)ref opndrec=
ref opndrec ax,bx
int tx,n
int opc

case gettypecat(a)
when 'I' then
	opc:=m_irem
else
	opc:=m_urem
!	if b^.tag=j_const and tfirstint<=ttbasetype[b^.mode]<=tlastint then
	if b^.tag=j_const and isintcc(b^.mode) then
		if n:=ispoweroftwo(b^.value) then
			p^.tag:=j_shr
			b^.value:=b^.value-1
			return dx_iand(m_and,a,b,reg)
		fi
	fi
esac

if reg<>r0 then
	gerror("REM REG NOT ZERO")
fi
if issimple(b) then
	ax:=loadexpr(a,reg)
	if b^.tag=j_const then
!		bx:=loadexpr(b,reg+getlregs(ax))
		bx:=loadexpr(b,getnextreg(ax,reg))
	else
!		bx:=evalexpr(b,reg+getlregs(ax))
		bx:=evalexpr(b,getnextreg(ax,reg))
	fi
else
	tx:=saveexpr(b,reg)
	ax:=loadexpr(a,reg)
!	bx:=restoreexpr(tx,reg+getlregs(ax))
	bx:=restoreexpr(tx,getnextreg(ax,reg))
fi
genmc(opc,bx)
return ax
end

function dx_ifx(unit a,b,c,int reg)ref opndrec=
ref opndrec bx,result
int lab1, lab2,isreal

lab1:=createfwdlabel()				!dest label of main condition (to end of if, or start if else)
lab2:=createfwdlabel()

isreal:=gettypecat(b)='R'

genjumpcond(kjumpf,a,lab1,reg)
if isreal then
	result:=floadexpr(b,reg)
else
	result:=loadexpr(b,reg)
fi

genjumpl(lab2)
definefwdlabel(lab1)

if isreal then
	bx:=floadexpr(c,reg)
else
	bx:=loadexpr(c,reg)
fi

definefwdlabel(lab2)
return result
end

function dx_addto(int opc,unit a,b,int regx=0)ref opndrec=
ref opndrec lhs, rhs, ptropnd,rr2
int reg,tx

if gettypecat(b)='R' then
	return dx_faddto(opc,a,b,regx)
fi

reg:=(regx|regx|xr0)

if issimple(b) then
	ptropnd:=getlvalueopnd(a,reg)
	if b^.tag=j_const and b^.mode=tsint then
!		rhs:=evalexpr(b,reg+getaregs(ptropnd))
		rhs:=evalexpr(b,getnextreg(ptropnd,reg))
	else
!		rhs:=loadexpr(b,reg+getaregs(ptropnd))
		rhs:=loadexpr(b,getnextreg(ptropnd,reg))
	fi
	rhs:=changeopndsize(rhs,ptropnd^.size)
	genmc(opc,ptropnd,rhs)
elsif issimple(a) then
	rhs:=loadexpr(b,reg)
!	ptropnd:=getlvalueopnd(a,reg+getlregs(rhs))
	ptropnd:=getlvalueopnd(a,getnextreg(rhs,reg))
	rhs:=changeopndsize(rhs,ptropnd^.size)
	genmc(opc,ptropnd,rhs)
else
	tx:=saveexpr(b,reg)
	ptropnd:=getlvalueopnd(a,reg)
!	rr2:=restoreexpr(tx,reg+getaregs(ptropnd))
	rr2:=restoreexpr(tx,getnextreg(ptropnd,reg))
	rr2:=changeopndsize(rr2,ptropnd^.size)
	genmc(opc,ptropnd,rr2)
fi

return ptropnd

end

function dx_faddto(int opc,unit a,b,int regx=0)ref opndrec=
ref opndrec work, rhs, ptropnd
int reg,tx,tempreg

reg:=(regx|regx|xr0)

if issimple(b) then
	ptropnd:=getlvalueopnd(a,reg)
!	reg+:=getaregs(ptropnd)
	reg:=getnextreg(ptropnd,reg)
	rhs:=fevalexpr(b,reg)
!	reg+:=getlregs(rhs)
	reg:=getnextreg(rhs,reg)

elsif issimple(a) then
	rhs:=fevalexpr(b,reg)
!	reg+:=getlregs(rhs)
	reg:=getnextreg(rhs,reg)
	ptropnd:=getlvalueopnd(a,reg)
!	reg+:=getaregs(ptropnd)
	reg:=getnextreg(ptropnd,reg)
else
	tx:=saveexpr(b,reg)
	ptropnd:=getlvalueopnd(a,reg)
	reg:=getnextreg(ptropnd,reg)
	rhs:=frestoreexpr(tx,reg)
	++reg
fi

work:=genxreg(reg,getopndsize_u(b))

genmc(m_fmov,work,ptropnd)

case opc
when m_add then opc:=m_fadd
when m_sub then opc:=m_fsub
when m_imul then opc:=m_fmul
when m_idiv then opc:=m_fdiv
esac

genmc(opc,work,rhs)
genmc(m_fmov,ptropnd,work)

return ptropnd
end

function dx_eq(unit p,a,b,int reg)ref opndrec=
!apply =, <= etc between a and b, and get a logical result 1 or 0
ref opndrec ax,bx,rx,rxb
int mclcond,tx

mclcond:=getmclcond(p^.tag,a^.mode)

case mclcond
when feq_cond, fne_cond,flt_cond,fge_cond,fle_cond,fgt_cond then
	if issimple(b) then
		ax:=floadexpr(a,reg)
!		bx:=fevalexpr(b,reg+getlregs(ax))
		bx:=fevalexpr(b,getnextreg(ax,reg))

	elsif issimple(a) then	!reverse order
		mclcond:=reversemclcond(mclcond)
		ax:=floadexpr(b,reg)
!		bx:=fevalexpr(a,reg+getlregs(ax))
		bx:=fevalexpr(a,getnextreg(ax,reg))
	else
		tx:=saveexpr(b,reg)
		ax:=floadexpr(a,reg)
!		bx:=frestoreexpr(tx,reg+getlregs(ax))
		bx:=frestoreexpr(tx,getnextreg(ax,reg))
	fi
	genmc(m_fcmp,ax,bx)
else
	if issimple(b) then
		ax:=loadexpr(a,reg)
!		bx:=evalexpr(b,reg+getlregs(ax))
		bx:=evalexpr(b,getnextreg(ax,reg))
	elsif issimple(a) then			!reverse order
		mclcond:=reversemclcond(mclcond)
		ax:=loadexpr(b,reg)
		bx:=evalexpr(a,reg)
	else
		tx:=saveexpr(b,reg)
		ax:=loadexpr(a,reg)
!		bx:=restoreexpr(tx,reg+getlregs(ax))
		bx:=restoreexpr(tx,getnextreg(ax,reg))
	fi
	genmc(m_cmp,ax,bx)
esac
rx:=genreg(reg,4)
rxb:=genreg(reg,1)

genmc_cond(m_setcc,mclcond,rxb)
genmc(m_uwiden,rx,rxb)
return rx
end

proc do_exprlist(unit a)=

while a do
	do_stmt(a)
	a:=a^.nextunit
od
end

function dx_exprlist(unit a,int reg)ref opndrec=
ref opndrec ax

while a do
	ax:=dx_expr(a,reg)
	a:=a^.nextunit
od
return ax
end

function dx_shlto(unit p,a,b,int regx=0)ref opndrec=
ref opndrec lhs, rhs, ptropnd,rr2
int reg,tx,opc

if p^.tag=j_shlto then
	opc:=m_shl
else
	case gettypecat(p)
	when 'I' then
		opc:=m_ishr
	else
		opc:=m_ushr
	esac
fi

reg:=(regx|regx|xr0)

if issimple(b) then
	ptropnd:=getlvalueopnd(a,reg)
	if b^.tag=j_const and b^.mode=tsint then
!		rhs:=evalexpr(b,reg+getaregs(ptropnd))
		rhs:=evalexpr(b,getnextreg(ptropnd,reg))
	else
!		rhs:=loadexpr(b,reg+getaregs(ptropnd))
		rhs:=loadexpr(b,getnextreg(ptropnd,reg))
	fi
	rhs:=changeopndsize(rhs,ptropnd^.size)
	genmc(opc,ptropnd,rhs)
elsif issimple(a) then
	rhs:=loadexpr(b,reg)
!	ptropnd:=getlvalueopnd(a,reg+getlregs(rhs))
	ptropnd:=getlvalueopnd(a,getnextreg(rhs,reg))
	rhs:=changeopndsize(rhs,ptropnd^.size)
	genmc(opc,ptropnd,rhs)
else
	tx:=saveexpr(b,reg)
	ptropnd:=getlvalueopnd(a,reg)
!	rr2:=restoreexpr(tx,reg+getaregs(ptropnd))
	rr2:=restoreexpr(tx,getnextreg(ptropnd,reg))
	rr2:=changeopndsize(rr2,ptropnd^.size)
	genmc(opc,ptropnd,rr2)
fi

return ptropnd

end

function dx_multo(unit a,b,int regx)ref opndrec=
ref opndrec work, rhs, ptropnd
int reg,tx,sgned

case gettypecat(b)
when 'R' then
	return dx_faddto(m_imul,a,b,regx)
when 'I' then
	sgned:=1
else
	sgned:=0
esac

reg:=(regx|regx|r0)

work:=genreg(reg,getopndsize_u(b))
++reg

if issimple(b) then
	ptropnd:=getlvalueopnd(a,reg)
!	reg+:=getaregs(ptropnd)
	reg:=getnextreg(ptropnd,reg)
	rhs:=evalexpr(b,reg)
!	reg+:=getlregs(rhs)
	reg:=getnextreg(rhs,reg)

elsif issimple(a) then
	rhs:=evalexpr(b,reg)
!	reg+:=getlregs(rhs)
	reg:=getnextreg(rhs,reg)
	ptropnd:=getlvalueopnd(a,reg)
!	reg+:=getaregs(ptropnd)
	reg:=getnextreg(ptropnd,reg)
else
	tx:=saveexpr(b,reg)
	ptropnd:=getlvalueopnd(a,reg)
	reg:=getnextreg(ptropnd,reg)
	rhs:=restoreexpr(tx,reg)
	++reg
fi

loadviaptr(work,ptropnd,sgned)
!genmc(m_mov,work,ptropnd)

genmc(m_imul,work,rhs)

!genmc(m_mov,ptropnd,work)
genmc(m_mov,ptropnd,changeopndsize(work,ptropnd^.size))

return ptropnd
end

function dx_notl(unit a,int reg)ref opndrec=
ref opndrec ax,rx,rxb

if a^.tag=j_notl then
	return dx_istruel(a^.a,reg)
fi

ax:=loadexpr(a,reg)
genmc(m_and,ax,ax)
rx:=genreg(reg,4)
rxb:=genreg(reg,1)
genmc_cond(m_setcc,eq_cond,rxb)
genmc(m_uwiden,rx,rxb)
return rx
end

function dx_istruel(unit a, int reg)ref opndrec=
ref opndrec ax,rx,rxb

ax:=loadexpr(a,reg)
genmc(m_and,ax,ax)
rx:=genreg(reg,4)
rxb:=genreg(reg,1)
genmc_cond(m_setcc,ne_cond,rxb)
genmc(m_uwiden,rx,rxb)
return rx
end

function dx_andorl(unit p, int reg)ref opndrec =
!do short-circuit evaluation of a&&b or a||b
!return operand containing 1 or 0
int lab1,lab2
ref opndrec rx

lab1:=createfwdlabel()			!dest label of main condition (to end of if, or start if else)

genjumpcond(kjumpf,p,lab1)

rx:=genreg(reg,4)

lab2:=createfwdlabel()			!label past else part
genmc(m_mov,rx,genint(1))

genjumpl(lab2)
definefwdlabel(lab1)
genmc(m_mov,rx,genint(0))

definefwdlabel(lab2)
return rx
end

function dx_sqrt(unit a,int reg)ref opndrec=
ref opndrec fx
fx:=floadexpr(a,reg)
genmc(m_fsqrt,fx,fx)
return fx
end

function dx_scale(unit p,a,b, int reg)ref opndrec=
ref opndrec ax,bx,cx
int opc,scale,n

ax:=loadexpr(a,reg)

scale:=p^.scale
opc:=m_imul
if scale<0 then
	scale:=-scale
	opc:=m_idiv
fi

!CPL "SCALE",SCALE

n:=ispoweroftwo(scale)

if n=0 then
	bx:=genint(scale)
	if opc=m_imul then
		genmc(m_imul,ax,bx)
	else
		if ax^.reg<>r0 then
!CPL =SCALE
			gerror("scale/div by non-power-of-two/not r0")
		fi
		genmc(m_mov,cx:=genreg(reg+1,ax^.size),bx)
		genmc(m_idiv,cx)
	fi
else

	bx:=genint(n)

	if opc=m_imul then
		genmc(m_shl,ax,bx)
	else
		genmc(m_ishr,ax,bx)
	fi
fi
return ax
end

function dx_divto(unit p,a,b, int regx)ref opndrec=
ref opndrec work, rhs, ptropnd, ax
int reg,tx,opc,sgned

case gettypecat(b)
when 'R' then
	return dx_faddto(m_idiv,a,b,regx)
when 'I' then
	opc:=(p^.tag=j_divto|m_idiv|m_irem)
	sgned:=1
else
	opc:=(p^.tag=j_divto|m_udiv|m_urem)
	sgned:=0
esac

reg:=(regx|regx|xr0)

if reg<>r0 then
	GERROR("DIVTO: not R0")
fi
work:=genreg(reg,getopndsize_u(b))
++reg

if issimple(b) then
!CPL "A"
	ptropnd:=getlvalueopnd(a,reg)
!	reg+:=getaregs(ptropnd)
	reg:=getnextreg(ptropnd,reg)
	rhs:=evalexpr(b,reg)
!	reg+:=getlregs(rhs)
	reg:=getnextreg(rhs,reg)

elsif issimple(a) then
	rhs:=evalexpr(b,reg)
!	reg+:=getlregs(rhs)
	reg:=getnextreg(rhs,reg)
	ptropnd:=getlvalueopnd(a,reg)
!	reg+:=getaregs(ptropnd)
	reg:=getnextreg(ptropnd,reg)
else
!CPL "C"
	tx:=saveexpr(b,reg)
	ptropnd:=getlvalueopnd(a,reg)
!	reg+:=getaregs(ptropnd)
	reg:=getnextreg(ptropnd,reg)
	rhs:=restoreexpr(tx,reg)
	++reg
fi

loadviaptr(work,ptropnd,sgned)
genmc(opc,rhs)
genmc(m_mov,ptropnd,changeopndsize(work,ptropnd^.size))

return ptropnd
end

function dx_name(unit p,int reg,am)ref opndrec=
ref opndrec ax,bx

!CPL "DXNAME:",=AM,P^.DEF^.NAME,NAMENAMES[P^.DEF^.NAMEID],P^.DEF^.NAME
case p^.def^.nameid
when procid then
	return genmemaddr_u(p)
!when paramid then
!!CPL "HERE"
!	if isstructunion(p^.mode) then
!		ax:=genreg(reg,ptrsize)
!		genmc(m_mov,ax,genmem_u(p))
!		return genireg(ax^.reg,ttsize[p^.mode])
!	fi
esac

ax:=genmem_u(p)

return ax
end

proc divreg(int reg,int64 x)=
!divide value in register by factor x
ref opndrec rr2
int n

if x>1 then
	if n:=ispoweroftwo(x) then
!		genmc(m_shr,genreg(reg,4),n)
		genmc(m_ishr,genreg(reg,8),genint(n))
	else
		if reg<>r0 then
			GERROR("DIVREG NOT R0")
		fi
		genmc(m_cdq)
		genmc(m_mov,rr2:=genreg(r2,8),genint(x))
		genmc(m_idiv,rr2)
	fi
fi
end

function dx_addrof(unit p,a,int reg,am=1)ref opndrec=
ref opndrec ax,bx
!CPL "DXADDROF"

if a^.tag=j_name then
	ax:=genmem_u(a)
else
	ax:=evaladdr(a,reg)
fi

if am<>0 and ax^.mode<>a_reg then
	genmc(m_lea, bx:=genreg(reg,ptrsize),ax)
	return bx
fi

return ax
end

function dx_dot(unit p,a,b, int reg,am)ref opndrec=
!return from here is always a memory address mode, whatever am is
!(when am=0, then caller might do lea rather than mov)
ref opndrec ax,rx
!
!CPL "DXDOT",AM,B

!CPL "DOT0"
ax:=evalexpr(a,reg)
!CPL "DOT1",=STROPND(AX),AX^.SIZE

!ax:=applyoffset(ax,offset,ttsize[b^.def^.mode])
ax:=applyoffset(ax,p^.offset,ttsize[p^.mode])
!CPL "DOT2",=STROPND(AX),AX^.SIZE

return ax
end

proc loadviaptr(ref opndrec w, ptropnd, int sgned)=
!load @ptropnd to reg opnd w
!if size of w and ptropnd is same, or w is smaller, then
!load into return w via move
!when widening is needed, then create a narrower w2, and use movsx/movzx
ref opndrec w2

if w^.size<=ptropnd^.size then
	genmc(m_mov,w, ptropnd)
	return
fi

!w2:=changeopndsize(w,ptropnd^.size)

genmc((sgned|m_iwiden|m_uwiden),w,ptropnd)

!return w2
end
=== cc_genasm.m 61/77 ===
!M Compiler - x64 Target Code Generator 2
!import main
import msys
import mlib
import clib
import oslib

import cc_decls
import cc_support
import cc_tables
import cc_lib
import cc_libmcl
!import mx_asm

ref mclrec currmcl

const initstringsize	= 1024
const initrealsize		= 16
const initdintsize		= 16

const wstringtablesize=1024
[wstringtablesize]ref word16 wstringtable
[wstringtablesize]int wstringlentable

ref []ichar stringtable
ref []int   stringlentable
ref []real	realtable
ref []int64 dinttable

int stringtablesize
int realtablesize
int dinttablesize

global int nwstrings=0
global int nstrings=0
global int nreals=0
global int ndints=0

const asmlinelength=20000
ref char asmstart
ref char asmptr
ref char asmend
[asmlinelength]char asmbuffer

global function codegen_writeasm(int moduleno,ichar outfile)int=
!take mc code, and write it as asm source into ttdeststr
ref strec d

gs_init(dest)

inita64()

stmodule:=moduletable[moduleno].stmodule

gs_str(dest,"!x64 output for ")
gs_str(dest,stmodule^.name)
gs_strln(dest,".c")

!CPL "MODULE",STMODULE^.NAME
writetoasm(modulecode)

d:=stmodule^.deflist
while d do
	case d^.nameid
	when procid then
		currproc:=d
		writetoasm(d^.mclcode)
	esac
	d:=d^.nextdef
od

writefabs()

genstringtable()
genwstringtable()
genrealtable()
gendinttable()

terma64()


if fastasm then
!	assemsource:=dest^.strptr
!	assemsources[:=dest^.strptr
else
	if fverbose then
		println "Writing",outfile,,":"
	fi
	writefile(outfile,cast(dest^.strptr),dest^.length)
!	moduletable[1].asmstr:=dest^.strptr
fi
moduletable[moduleno].asmstr:=dest^.strptr

return 1
end

global proc inita64=
initasmline()

stringtable:=pcm_alloc(ref void.bytes*initstringsize)
stringlentable:=pcm_alloc(int.bytes*initstringsize)
realtable:=pcm_alloc(real.bytes*initrealsize)
dinttable:=pcm_alloc(int64.bytes*initdintsize)

stringtablesize:=initstringsize
realtablesize:=initrealsize
dinttablesize:=initdintsize

end

global proc terma64=
!gs_strln(dest,"!TERMA64")
end

proc writetoasm(ref mclrec m)=
while m do
	mcltoa64(m)
	m:=m^.nextmcl
od
end

global proc mcltoa64(ref mclrec m)=
int opcode,cond
ref opndrec a,b

!CPL MCLNAMES[M^.OPCODE]

currmcl:=m

opcode:=m^.opcode
cond:=m^.cond

a:=m^.a
b:=m^.b

switch opcode
when m_comment then
	do_comment(a,b)

when m_blank then
	do_blank(a,b)

when m_end then
	do_end(a,b)

when m_label then
	do_label(a,b)

when m_labelname then
	do_labelname(a,b)

when m_mov then
	do_mov(a,b)

when m_push then
	do_push(a)

when m_pop then
	do_pop(a)

when m_lea then
	do_lea(a,b)

when m_cmovcc then
	do_cmovcc(a,b,cond)

when m_fmov then
	do_fmov(a,b)

when m_iwiden then
	do_changeop(mx_movsx)
!	do_iwiden(a,b)

when m_uwiden then
	do_changeop(mx_movzx)
!	do_uwiden(a,b)

when m_inarrow then
	do_inarrow(a,b)

when m_unarrow then
	do_unarrow(a,b)

when m_call then
	do_call(a,b)

when m_ret then
	do_ret(a,b)

when m_retn then
	do_retn(a,b)

when m_jmp then
	do_jmp(a,b)

when m_jmpcc then
	do_jmpcc(a,b,cond)

when m_exch then
	do_exch(a,b)

when m_add then
	do_add(a,b)

when m_sub then
	do_sub(a,b)

when m_imul then
	do_imul(a,b)

!when m_umul then
!	do_umul(a,b)

when m_idiv,m_udiv then
	do_idiv(a)

!when m_udiv then
!	do_udiv(a)

when m_irem then
	do_irem(a)

when m_urem then
	do_urem(a)

when m_and then
	do_and(a,b)

when m_or then
	do_or(a,b)

when m_xor then
	do_xor(a,b)

when m_test then
	do_test(a,b)

when m_cmp then
	do_cmp(a,b)

when m_shl then
	do_shl(m_shl,a,b)

when m_ishr then
	do_shl(mx_sar,a,b)

when m_ushr then
	do_shl(mx_shr,a,b)

when m_neg then
	do_neg(a,b)

when m_not then
	do_not(a,b)

when m_inc then
	do_inc(a,b)

when m_dec then
	do_dec(a,b)

when m_setcc then
	do_setcc(a,b,cond)

when m_fneg then
	do_fneg(a)

when m_fabs then
	do_fabs(a)

when m_fsqrt then
	do_changeop((a^.size=4|mx_sqrtss|mx_sqrtsd))

when m_fadd then
	if b^.mode=a_imm then
		convertimm(b,1)
	fi
	do_changeop((a^.size=4|mx_addss|mx_addsd))

when m_fsub then
	if b^.mode=a_imm then
		convertimm(b,1)
	fi
	do_changeop((a^.size=4|mx_subss|mx_subsd))

when m_fmul then
	if b^.mode=a_imm then
		convertimm(b,1)
	fi
	do_changeop((a^.size=4|mx_mulss|mx_mulsd))

when m_fdiv then
	if b^.mode=a_imm then
		convertimm(b,1)
	fi
	do_changeop((a^.size=4|mx_divss|mx_divsd))

when m_fcmp then
	if b^.mode=a_imm then
		convertimm(b,1)
	fi
	do_changeop((a^.size=4|mx_comiss|mx_comisd))

when m_ufix then
	do_ufix(a,b)

when m_ifix then
	do_ifix(a,b)

when m_ufloat then
	do_ufloat(a,b)

when m_ifloat then
	do_ifloat(a,b)

when m_fwiden then
	convertimm(b)
	do_changeop(mx_cvtss2sd)

when m_fnarrow then
	do_changeop(mx_cvtsd2ss)

when m_fmin then
	do_changeop((a^.size=4|mx_minss|mx_minsd))

when m_fmax then
	do_changeop((a^.size=4|mx_maxss|mx_maxsd))

when m_db then
	do_db(a,b)

when m_dw then
	do_dw(a,b)

when m_dd then
	do_dd(a,b)

when m_dq then
	do_dq(a,b)

when m_defstr then
	do_defstr(a^.svalue,a^.slength)

when m_defwstr then
	do_defwstr(a^.wsvalue,a^.wslength)

when m_align then
	do_align(a,b)

when m_segment then
	do_segment(a,b)

when m_assem then
	do_assem(a,b)

when m_resb then
	convmcl()

else
	gerror_s("a64:UNKNOWN MCL OP: %s",MCLNAMES[OPCODE])
endswitch

end

proc passthru(int opc)=
ichar s

strmclx(currmcl)
gs_strn(dest,asmstart,asmptr-asmstart)
end

proc convmcl=
ichar s

strmclx(currmcl)
gs_strn(dest,asmstart,asmptr-asmstart)
end

proc do_changeop(int opc)=
currmcl^.opcode:=opc
convmcl()
end

proc do_comment(ref opndrec a,b) =
	gs_str(dest,"! ")
	gs_strln(dest,a^.svalue)
end

proc do_blank(ref opndrec a,b) =
	gs_line(dest)
end

proc do_end(ref opndrec a,b) =
	passthru(m_end)
end

proc do_label(ref opndrec a,b) =
	passthru(m_label)
end

proc do_labelname(ref opndrec a,b) =
	passthru(m_labelname)
end

proc do_mov(ref opndrec a,b) =
ref mclrec m

	if a^.mode=a_reg and b^.mode=a_imm then
		convertimm(b,0)		!note might also be real, string etc
	elsif a^.mode=a_mem and b^.mode=a_imm then
		if b^.size=8 then		!assume mem dest
			convertimm(b,0)
			m:=currmcl
			initmcdest()
			genmc(m_mov,genreg(r13,8),b)
			domclseq(mccode)
			currmcl:=m
			m^.b:=genreg(r13,8)
		else
			if a^.size=8 then
				convertimm(b,-1)		!must fit in signed imm32
			else
				convertimm(b,0)		!unsigned
			fi
		fi
	fi
	convmcl()
end

proc do_push(ref opndrec a) =
ref opndrec rx

case a^.mode
when a_reg then
	if a^.size<>8 then
		a^.size:=8
	fi
!CPL "DOPUSH",=A,=A^.SIZE

when a_imm then
	convertimm(a,sx:1)
!CPL "PUSHIMM",VALTYPENAMES[A^.VALTYPE]

	if a^.size<>8 then
		a^.size:=8
	fi

when a_mem then
	if a^.size<>8 then
		initmcdest()
CASE A^.SIZE
WHEN 1,2,4,8 THEN
		genmc(m_mov,genreg(r13,a^.size),a)
ELSE
		genmc(m_lea,genreg(r13,8),a)
ESAC

		genmc(m_push,genreg(r13,8))
		domclseq(mccode)
		return
	fi
when a_xreg then
	if a^.size=4 then
		gs_str(dest,"	movd A13, ")
		gs_strln(dest,fgetregnamex(a^.reg))
	else
		gs_str(dest,"	movq D13, ")
		gs_strln(dest,fgetregnamex(a^.reg))
	fi
	gs_strln(dest,"	push D13")
	return

esac

convmcl()
end

proc do_pop(ref opndrec a) =
case a^.mode
when a_xreg then
	gs_strln(dest,"	pop D13")
	if a^.size=4 then
		gs_str(dest,"	movd ")
		gs_str(dest,fgetregnamex(a^.reg))
		gs_strln(dest,", A13")
	else
		gs_str(dest,"	movq ")
		gs_str(dest,fgetregnamex(a^.reg))
		gs_strln(dest,", D13")
	fi
	return

esac
convmcl()
end

proc do_lea(ref opndrec a,b) =
	passthru(m_lea)
end

proc do_cmovcc(ref opndrec a,b, int cond) =
	passthru(m_cmovcc)
end

proc do_fmov(ref opndrec a,b) =
	if b^.mode=a_imm then
		convertimm(b,1)
	fi
	do_changeop((a^.size=4|mx_movd|mx_movq))
end

proc do_iwiden(ref opndrec a,b) =
	passthru(m_iwiden)
end

proc do_uwiden(ref opndrec a,b) =
	passthru(m_uwiden)
end

proc do_inarrow(ref opndrec a,b) =
	passthru(m_inarrow)
end

proc do_unarrow(ref opndrec a,b) =
!ref opndrec a2,b2

int asize
	asize:=a^.size
	if asize=4 then
		currmcl^.b:=changeopndsize(b,4)
		do_changeop(m_mov)
	else
		if b^.mode=a_reg and a^.reg=b^.reg then		!don't need to move
		else
			initmcdest()
			genmc(m_mov,changeopndsize(a,b^.size),b)
			domclseq(mccode)
		fi
		initmcdest()
		if asize>2 then gerror("unarrow 4->8?") fi
		genmc(m_and,a, genint((asize|0xFF,0xFFFF|0)))
		domclseq(mccode)
	fi
end

proc do_call(ref opndrec a,b) =
	passthru(m_call)
end

proc do_ret(ref opndrec a,b) =
	passthru(m_ret)
end

proc do_retn(ref opndrec a,b) =
	passthru(m_retn)
end

proc do_jmp(ref opndrec a,b) =
	passthru(m_jmp)
end

proc do_jmpcc(ref opndrec a,b,int cond) =
	passthru(m_jmpcc)
end

proc do_exch(ref opndrec a,b) =
	passthru(m_exch)
end

proc do_add(ref opndrec a,b) =
	if b^.mode=a_imm then
		convertimm(b,1)
	fi
	passthru(m_add)
end

proc do_sub(ref opndrec a,b) =
	if b^.mode=a_imm then
		convertimm(b,1)
	fi
	passthru(m_sub)
end

proc do_imul(ref opndrec a,b) =
	if b and b^.mode then
		currmcl^.opcode:=mx_imul2
	fi
	if b^.mode=a_imm then
		convertimm(b,1)
	fi

	convmcl()
end

proc do_idiv(ref opndrec a) =
ref opndrec dx
ref mclrec m
	if a^.mode=a_imm then
		m:=currmcl
		initmcdest()
		genmc(m_mov,dx:=genreg(r13,a^.size), a)
		domclseq(mccode)
		currmcl:=m
		currmcl^.a:=dx
	fi
	if a^.reg=r11 then
		gerror("asm/div/dividing by edx")
	fi
	if currmcl^.opcode=m_idiv then
		gs_strln(dest,(a^.size<=4|"	cdq"|"	cqo"))
		convmcl()
	else
		gs_strln(dest,"	xor rdx,rdx")
		do_changeop(mx_div)
	fi
end

proc do_irem(ref opndrec a) =
	currmcl^.opcode:=m_idiv
	do_idiv(a)
	gs_strln(dest,"	xchg rax,rdx")
end

proc do_urem(ref opndrec a) =
	currmcl^.opcode:=m_udiv
	do_idiv(a)
	gs_strln(dest,"	xchg rax,rdx")
end

proc do_and(ref opndrec a,b) =
	if b^.mode=a_imm then
		if a^.size<=4 then
!			b^.value iand:=0xFFFF'FFFF
			b^.value :=b^.value iand 0xFFFF'FFFF
			convertimm(b,0)
		else
			convertimm(b,1)
		fi
	fi
	passthru(m_and)
end

proc do_or(ref opndrec a,b) =
	if b^.mode=a_imm then
		if a^.size<=4 then
!			b^.value iand:=0xFFFF'FFFF
			b^.value :=b^.value iand 0xFFFF'FFFF
			convertimm(b,0)
		else
			convertimm(b,1)
		fi
	fi
	passthru(m_or)
end

proc do_xor(ref opndrec a,b) =
	if b^.mode=a_imm then
		if a^.size<=4 then
!			b^.value iand:=0xFFFF'FFFF
			b^.value :=b^.value iand 0xFFFF'FFFF
			convertimm(b,0)
		else
			convertimm(b,1)
		fi
	fi
	passthru(m_xor)
end

proc do_test(ref opndrec a,b) =
	if b^.mode=a_imm then
		convertimm(b,1)
	fi
	passthru(m_test)
end

proc do_cmp(ref opndrec a,b) =
	if b^.mode=a_imm then
		convertimm(b,1)
	fi
	passthru(m_cmp)
end

proc do_shl(int opc, ref opndrec a,b) =
int exchreg,breg

	currmcl^.opcode:=opc
	case b^.mode
	when a_reg then
		breg:=b^.reg

		if a^.mode=a_reg and a^.reg=r10 then		!shifting r10; assume breg not r10
			gs_str(dest,"	xchg D10,")
			gs_strln(dest,getregnamex(breg,8))

			currmcl^.a:=genreg(breg,a^.size)
			currmcl^.b:=genreg(r10,1)
			convmcl()

			gs_str(dest,"	xchg D10,")
			gs_strln(dest,getregnamex(breg,8))

		else
			b^.size:=1
			exchreg:=0
			if b^.reg<>r10 then
				gs_str(dest,"	xchg D10,")
				gs_strln(dest,getregnamex(b^.reg,8))
				exchreg:=b^.reg
				b^.reg:=r10
			fi
			convmcl()
			if exchreg then
				gs_str(dest,"	xchg D10,")
				gs_strln(dest,getregnamex(exchreg,8))
			fi
		fi
		return
	when a_imm then
	when a_mem then
		gerror("SHL/MEM")
	esac

	convmcl()
end

proc do_neg(ref opndrec a,b) =
	passthru(m_neg)
end

proc do_not(ref opndrec a,b) =
	passthru(m_not)
end

proc do_inc(ref opndrec a,b) =
	passthru(m_inc)
end

proc do_dec(ref opndrec a,b) =
	passthru(m_dec)
end

proc do_setcc(ref opndrec a,b,int cond) =
	passthru(m_setcc)
end

proc do_fneg(ref opndrec a) =
	if a^.size=4 then
		currmcl^.opcode:=mx_xorps
		currmcl^.b:=genname("[fchsmask_ps]")
	else
		currmcl^.opcode:=mx_xorpd
		currmcl^.b:=genname("[fchsmask_pd]")
	fi
	fchsused:=1
	convmcl()
end

proc do_fabs(ref opndrec a) =
	if a^.size=4 then
		currmcl^.opcode:=mx_andps
		currmcl^.b:=genname("[fabsmask_ps]")
	else
		currmcl^.opcode:=mx_andpd
		currmcl^.b:=genname("[fabsmask_pd]")
	fi
	fabsused:=1
	convmcl()
end

proc do_fsqrt(ref opndrec a,b) =
	passthru(m_fsqrt)
end

proc do_ufix(ref opndrec a,b) =
!for now, same code as unsigned
!note that word(-1.0) cannot be converted anyway
	do_ifix(a,b)
end

proc do_ifix(ref opndrec a,b) =
	do_changeop((b^.size=4|mx_cvttss2si|mx_cvttsd2si))
end

proc do_ufloat(ref opndrec a,b) =
ref opndrec rx,fx
ichar name

	rx:=genreg(r10,b^.size)
	fx:=genxreg(xr15,a^.size)

	if a^.size=4 then
		if b^.size=4 then
			name:="m$ufloat_r32u32*"
		else
			name:="m$ufloat_r32u64*"
		fi
	else
		if b^.size=4 then
			name:="m$ufloat_r64u32*"
		else
			name:="m$ufloat_r64u64*"
		fi
	fi

	initmcdest()
	genmc(m_mov,rx,b)
	genmc(m_call,genname(name))
	genmc(m_fmov,a,fx)

	domclseq(mccode)
end

proc do_ifloat(ref opndrec a,b) =
	do_changeop((a^.size=4|mx_cvtsi2ss|mx_cvtsi2sd))
end

proc do_db(ref opndrec a,b) =
	passthru(m_db)
end

proc do_dw(ref opndrec a,b) =
	passthru(m_dw)
end

proc do_dd(ref opndrec a,b) =
	convertimm(a)
	passthru(m_dd)
end

proc do_dq(ref opndrec a,b) =
	convertimm(a)
	passthru(m_dq)
end

proc do_align(ref opndrec a,b) =
	passthru(m_align)
end

proc do_segment(ref opndrec a,b) =
	passthru(m_segment)
end

proc do_assem(ref opndrec a,b) =
	gs_strln(dest,a^.svalue)
end

proc strmclasm(ref mclrec mcl)=
static [512]char str
[512]char opnds
[256]char opnd2
[128]char opcname
ref opndrec a,b
int opcode,cond,sizepref,n

initasmline()

opcode:=mcl^.opcode
cond:=mcl^.cond
a:=mcl^.a
b:=mcl^.b

case opcode
when m_assem then
	asmstr(a^.svalue)
	return

when m_blank then
	return

when m_comment then
	asmchar('!')
	asmstr(a^.svalue)
	return

when m_labelname then
	asmstr(a^.svalue)
	return

when m_label then
	asmchar('L')
!	asmchar('M')
	asmint(a^.value)
	asmchar(':')
	if a^.isglobal then
		asmchar(':')
	fi
	if b then
		asmstr("	!<")
		asmstr(b^.def^.name)
		asmchar('>')
	fi
	return

esac

asmchar('\t')

case opcode
when m_jmpcc then
	asmchar('j')
	asmstr(asmcondnames[cond])

when m_setcc then
	asmstr("set")
	asmstr(asmcondnames[cond])

when m_cmovcc then
	asmstr("cmov")
	asmstr(asmcondnames[cond])

else
	asmstr(mclnames[opcode]+(opcode<=m_end|2|3))
esac

n:=asmptr-asmstart
!while n<10 do
while n<11 do
	asmchar(' ')
	++n
od

if a and b then		!2 operands
	sizepref:=needsizeprefix(opcode,a,b)

	stropndx(a,sizepref)
	asmstr(",\t")
	stropndx(b,sizepref)

elsif a and a^.mode then								!1 operand
	if opcode=m_call then
		stropndx(a,0)
	else
		stropndx(a,1)
	fi
fi
end

global proc stropndx(ref opndrec a,int sizeprefix=0,debug=0)=
static [512]char str
[128]char str2
ichar t, plus
ref char p,q

case a^.mode
when a_reg then
!	asmstr(getregnamex(a^.reg,a^.size))
	asmstr(getregname(a^.reg,a^.size))

when a_imm then
	strvaluex(a)

when a_mem then
	if sizeprefix then
		asmstr(getsizeprefix(a^.size,1))
	fi
	asmchar('[')

	plus:=""
	if a^.reg then
!IF A^.REG=RFRAME THEN CPL "FRAMEREG" FI

IF FSHOWNAMES AND A^.DEF AND A^.REG=RFRAME THEN
ELSE

		asmstr(getregnamex(a^.reg,ptrsize))
		plus:="+"
FI
	fi
	if a^.regix then
		asmstr(plus)
		asmstr(getregnamex(a^.regix,ptrsize))
		plus:="+"
		if a^.scale>1 then
			asmchar('*')
			asmint(a^.scale)
		fi
	fi
	if a^.def or a^.valtype then			!.valtype should be 'I' if used
		p:=asmptr
		asmchar(' ')
		q:=asmptr
		strvaluex(a)
		if q^<>'-' and plus^='+' then
			p^:='+'
		fi
		if p^=' ' then
			to asmptr-p-1 do
				p^:=(p+1)^
				++p
			od
			--asmptr
		fi

	fi
	asmchar(']')

when a_strimm then
	asmchar('/')
	asmstr(a^.svalue)
	asmchar('/')

when a_xreg then
	asmstr(fgetregnamex(a^.reg))

else
	asmstr("<BAD OPND>")
esac
end

proc strmclx(ref mclrec mcl)=
strmclasm(mcl)
asmptr++^:=10
asmptr^:=0
end

function fgetregnamex(int reg)ichar =
static [16]char str

!sprintf(&.str,"XMM%d",int32(reg-r0))
print @&.str,"XMM",,reg-r0
return &.str
end

global function getstringname(int n)ichar=
static [16]char str
if n=0 then kk0used:=1 fi

print @&.str,"KK",,n
!print @&.str,"KK"

return &.str
end

global function getwstringname(int n)ichar=
static [16]char str
!if n=0 then kk0used:=1 fi

!sprintf(&.str,"WW%d",int32(n))
print @&.str,"WW",,n
return &.str
end

global function getrealname(int n)ichar=
static [16]char str

!sprintf(&.str,"R.%d",int32(n))
print @&.str,"R.",,n
return &.str
end

global function getsrealname(int n)ichar=
static [16]char str

!sprintf(&.str,"SR.%d",int32(n))
print @&.str,"SR.",,n
return &.str
end

global function getdintname(int n)ichar=
static [16]char str

!sprintf(&.str,"DD.%d",int32(n))
print @&.str,"DD.",,n
return &.str
end

global function getstringindex(ichar s,int length)int=

if s=nil or length=0 then			!assume nil
	kk0used:=1
	return 0
fi

if nstrings>=stringtablesize then
	extendstringtable()
fi

stringtable^[++nstrings]:=s
stringlentable^[nstrings]:=length

return nstrings
end

global function getwstringindex(ref word16 s,int length)int=

if nwstrings>=wstringtablesize then
	gerror("Too many wide strings")
fi

wstringtable[++nwstrings]:=s
wstringlentable[nwstrings]:=length

return nwstrings
end

function getrealindex(real x)int=

!if nreals>0 and x=realtable^[nreals] then return nreals fi

if nreals>=realtablesize then
	extendrealtable()
fi

realtable^[++nreals]:=x
return nreals
end

function getdintindex(int64 x)int=
if ndints>=dinttablesize then
	extenddinttable()
fi

dinttable^[++ndints]:=x
return ndints
end

proc strvaluex(ref opndrec a)=
ref strec d
static [256]char str
[256]char str2
int64 value

d:=a^.def
value:=a^.value

if d then
	case d^.nameid
	when staticid then
		if d^.owner^.nameid=procid then
			asmchar('`')
			asmstr(d^.owner^.name)
			asmchar('.')
			asmstr(d^.name)
			asmchar('.')
			asmint(d^.blockno)
		else
			asmchar('`')
			asmstr(getfullname(d))
			if isimported(d) then
				asmchar('*')
			fi
		fi
	when frameid, paramid then
		if fshownames then
			asmstr(d^.name)
		else
			asmint(d^.offset)
		fi
	else
		asmchar('`')
		asmstr(getfullname(d))
		if isimported(d) then
			asmchar('*')
		fi
	esac
	if a^.valtype=int_val and value<>0 then
		if value>0 then
			asmchar('+')
		fi
		asmint(value)
	fi
	return
fi

case a^.valtype
when intix_val then
	asmstr(getdintname(a^.index))
	return
when realix_val then
	if a^.isfloat then
		asmstr(getsrealname(a^.index))
	else
		asmstr(getrealname(a^.index))
	fi
	return
when stringix_val then
	asmstr(getstringname(a^.index))
	return
when wstringix_val then
	asmstr(getwstringname(a^.index))
	return
esac

!CPL "HERE",STRVALUE(A),VALTYPENAMES[A^.VALTYPE]
asmstr(strvalue(a))
end

proc convertimm(ref opndrec a,int sx=0)=
!a is an immediate operand
!convert if needed as follows:
!'I'	To int64 memory index
!'R'	To real64 memory index (or real32)
!'S'	To string memory index
!sx says how immediate ints are to be processed:
! 0		No restrictions; imm64 is OK (caller might need to generate extra steps)
! -1/1		limited to signed imm32
! -2/2		limited to unsigned imm32
! For 1/2, will convert to mem64 if out of range
! For -1/-2, will raise error
int64 value

if a^.def then return fi			!named label; will only have offset, assumed to be OK
value:=a^.value

case a^.valtype
when int_val then
!CPL =VALUE
	case abs(sx)
	when 1 then

		if int32.minvalue<=value<=int32.maxvalue then
		else
			if sx<0 then gerror("conv/imm1") fi
			a^.index:=getdintindex(value)
			a^.valtype:=intix_val
			a^.mode:=a_mem
		fi
	when 2 then
		if word32.minvalue<=value<=word32.maxvalue then
		else
			if sx<0 then gerror("conv/imm2") fi
			a^.index:=getdintindex(value)
			a^.valtype:=intix_val
			a^.mode:=a_mem
		fi
	esac
when real_val then
	a^.index:=getrealindex(a^.xvalue)
	a^.valtype:=realix_val
	a^.mode:=a_mem
	a^.isfloat:=a^.size=4
when string_val then
	a^.index:=getstringindex(a^.svalue,a^.slength)
	a^.valtype:=stringix_val
when Wstring_val then
	a^.index:=getwstringindex(a^.wsvalue,a^.wslength)
	a^.valtype:=wstringix_val
esac

end

proc genstringtable=				!GENSTRINGTABLE
!string table generated in ax pass, so is just text
!this is target-specific, so should really be moved
int i, col

return unless nstrings or kk0used

gs_strln(dest,"!String Table")
gs_strln(dest,"	segment idata")
gs_str(dest,"	align ")
gs_strint(dest,targetsize)
gs_line(dest)

if kk0used then
	gs_strln(dest,"kk0:    db 0")
fi

for i to nstrings do
	col:=dest^.length
	gs_str(dest,getstringname(i))
	gs_str(dest,":")

	gs_padto(dest,8)

	genstring(stringtable^[i],stringlentable^[i])
od
gs_line(dest)
end

proc genwstringtable=
!string table generated in ax pass, so is just text
!this is target-specific, so should really be moved
int i, col

return unless nwstrings

gs_strln(dest,"!Wide String Table")
gs_strln(dest,"	segment idata")
gs_str(dest,"	align ")
gs_strint(dest,targetsize)
gs_line(dest)

!if kk0used then
!	gs_strln(dest,"kk0:    db 0")
!fi

for i to nwstrings do
	col:=dest^.length
	gs_str(dest,getwstringname(i))
	gs_str(dest,":")

	gs_padto(dest,8)

	genwstring(wstringtable[i],wstringlentable[i])
od
gs_line(dest)
end

proc do_defstr(ichar s,int length)=
!string table generated in ax pass, so is just text
!this is target-specific, so should really be moved
int i, state, c, a,col

gs_str(dest,"	")
genstring(s,length)

end

proc do_defwstr(ref word16 s,int length)=
!string table generated in ax pass, so is just text
!this is target-specific, so should really be moved
int i, state, c, a,col

gs_str(dest,"	")
genwstring(s,length)

end

proc genrealtable=				!GENREALTABLE
	record fprec=
		union
			real64 x64
			int64 ix64
		end
		union
			real32 x32
			int32 ix32
		end
	end
	fprec fp
	real x
	int i
	[1282]char str

	return unless nreals

	gs_strln(dest,"!Real64 Table")
	gs_strln(dest,"	segment idata")
	gs_str(dest,"	align ")
	gs_strint(dest,targetsize)
	gs_line(dest)

	for i to nreals do
		x:=realtable^[i]
		fp.x64:=x

		gs_str(dest,getrealname(i))
		gs_str(dest,":")
		gs_padto(dest,10,' ')
		gs_str(dest,"dq ")
		gs_strint(dest,fp.ix64)
		gs_str(dest,"	; ")
!		sprintf(&.str," %016llX ",fp.ix64)
		strcpy(&.str, strint(fp.ix64,"z16H"))
		gs_str(dest,&.str)

!		sprintf(&.str,"%.30g",x)
		strcpy(&.str,strreal(x,".30g"))
		gs_strln(dest,&.str)

	od
	gs_line(dest)
	gs_strln(dest,"!Real32 Table")

	for i to nreals do
		x:=realtable^[i]
		fp.x32:=x

		gs_str(dest,getsrealname(i))
		gs_str(dest,":")
		gs_padto(dest,10,' ')
		gs_str(dest,"dd ")
		gs_strint(dest,fp.ix32)
		gs_str(dest,"	; ")
!		sprintf(&.str,"%.30g",real(fp.x32))
		print @&.str,real(fp.x32):".30g"
		gs_strln(dest,&.str)

!	gs_strln(dest,leftstr(getrealname(i)+":",10)+"dq "+tostr(fp.ix64)+"	; "+tostr(x,".30g"))
	od
	gs_line(dest)
end

proc gendinttable=				!GENDINTTABLE
int i
int64 x

return unless ndints
gs_strln(dest,"!Int64 Table")
gs_strln(dest,"	segment idata")
gs_str(dest,"	align ")
gs_strint(dest,targetsize)
gs_line(dest)

for i to ndints do
	x:=dinttable^[i]
	gs_str(dest,getdintname(i))
	gs_str(dest,":")
	gs_str(dest,"dq ")
	gs_strint(dest,x)
	gs_line(dest)
od
gs_line(dest)
end

proc writefabs=
if fabsused or fchsused then
	gs_strln(dest,"	segment idata")
	gs_strln(dest,"	align 16")

	if fchsused then
		gs_strln(dest,"fchsmask_ps:	dq 0x80000000'80000000, 0x80000000'80000000")
		gs_strln(dest,"fchsmask_pd:	dq 0x80000000'00000000, 0x80000000'00000000")
	fi

	if fabsused then
		gs_strln(dest,"fabsmask_ps:	dq 0x7fffffff'7fffffff, 0x7fffffff'7fffffff")
		gs_strln(dest,"fabsmask_pd:	dq 0x7fffffff'ffffffff, 0x7fffffff'ffffffff")
	fi
fi

end

proc domclseq(ref mclrec m)=
!convert short mcl code sequence that might have been generated here
while m do
	mcltoa64(m)
	m:=m^.nextmcl
od
end

proc asmstr(ichar s)=
while (s^) do asmptr++^:=s++^ od
end

proc asmstrln(ichar s)=
char c
while c:=s^ do
	asmptr^:=c
	++asmptr
	++s
od
asmptr^:=10
++asmptr
end

proc asmline=
asmptr^:=10
++asmptr
end

proc asmln=
asmline()
end

proc asmint(int64 a)=
ichar s
int n

!RETURN

!ASMSTR("XXX")

s:=asmptr
getstrint(a,s)
!GETSTRINT(A,S)

!!if a<10 then
!!	++asmptr
!!elsif a<100 then
!!	asmptr+:=2
!!else
	asmptr+:=strlen(s)
!!fi

!n:=sprintf(asmptr,"%lld",a)
!asmptr+:=n
end

proc asmchar(int c)=
asmptr^:=c
++asmptr
end

proc asmterm=
asmptr^:=0
end

proc initasmline=

asmptr:=asmstart:=&.asmbuffer
asmend:=&.asmbuffer+asmlinelength
end

function getregnamex(int reg,size=4)ichar=
static [1..8,0..r15]ichar regnames = (
	("-","B0","B1","B2","B3","B4","B5","B6","B7","B8","B9","B10","B11","B12","B13","B14","B15"),
	("-","W0","W1","W2","W3","W4","W5","W6","W7","W8","W9","W10","W11","W12","W13","W14","W15"),
	(nil, nil,nil,nil,nil, nil,nil,nil,nil, nil,nil,nil,nil, nil,nil,nil,nil),
	("-","A0","A1","A2","A3","A4","A5","A6","A7","A8","A9","A10","A11","A12","A13","Aframe","Astack"),
	(nil, nil,nil,nil,nil, nil,nil,nil,nil, nil,nil,nil,nil, nil,nil,nil,nil),
	(nil, nil,nil,nil,nil, nil,nil,nil,nil, nil,nil,nil,nil, nil,nil,nil,nil),
	(nil, nil,nil,nil,nil, nil,nil,nil,nil, nil,nil,nil,nil, nil,nil,nil,nil),
	("-","D0","D1","D2","D3","D4","D5","D6","D7","D8","D9","D10","D11","D12","D13","Dframe","Dstack"))

!return "RR"


return regnames[size,reg]
end

proc genstring(ichar s, int length)=
!string table generated in ax pass, so is just text
!this is target-specific, so should really be moved
int i, state, c, a,col

gs_str(dest,"db ")
if length=0 then
	gs_strln(dest,"0")
	return
fi

state:=0
to length do
	a:=s++^
	if a<32 or a>=127 or a='\"' then
		if state=1 then
			gs_str(dest,""",")
			state:=0
		fi
		gs_strint(dest,a)
		gs_str(dest,",")
	else
		if state=0 then
			gs_str(dest,"""")
			state:=1
		fi
		gs_char(dest,a)
	fi
od
if state=1 then
	gs_str(dest,""",")
fi
gs_str(dest,"0")

gs_line(dest)
end

proc genwstring(ref word16 s, int length)=
!string table generated in ax pass, so is just text
!this is target-specific, so should really be moved
int i, state, c, a,col

gs_str(dest,"dw ")
if length=0 then
	gs_strln(dest,"0")
	return
fi

state:=0
for i to length do
	gs_strint(dest,s++^)
!	if i<length then
		gs_str(dest,",")
!	fi
od
gs_str(dest,"0")

gs_line(dest)
end

proc extendrealtable=
	ref[]real oldrealtable
	int oldrealtablesize

	oldrealtablesize:=realtablesize
	oldrealtable:=realtable

	realtablesize*:=2
!CPL "EXTENDING REAL TABLE TO",REALTABLESIZE

	realtable:=pcm_alloc(real.bytes*realtablesize)

	for i:=1 to nreals do
		realtable^[i]:=oldrealtable^[i]
	od

	pcm_free(oldrealtable,real.bytes*oldrealtablesize)
end

proc extenddinttable=
	ref[]int64 olddinttable
	int olddinttablesize

	olddinttablesize:=dinttablesize
	olddinttable:=dinttable

	dinttablesize*:=2
!CPL "EXTENDING DINT TABLE TO",DINTTABLESIZE

	dinttable:=pcm_alloc(int64.bytes*dinttablesize)

	for i:=1 to ndints do
		dinttable^[i]:=olddinttable^[i]
	od

	pcm_free(olddinttable,int64.bytes*olddinttablesize)
end

proc extendstringtable=
	ref[]ichar oldstringtable
	ref[]int oldstringlentable
	int oldstringtablesize

	oldstringtablesize:=stringtablesize
	oldstringtable:=stringtable
	oldstringlentable:=stringlentable

	stringtablesize*:=2
!CPL "EXTENDING STRING TABLE TO",STRINGTABLESIZE

	stringtable:=pcm_alloc(ichar.bytes*stringtablesize)
	stringlentable:=pcm_alloc(int.bytes*stringtablesize)

	for i:=1 to nstrings do
		stringtable^[i]:=oldstringtable^[i]
		stringlentable^[i]:=oldstringlentable^[i]
	od

	pcm_free(oldstringtable,ichar.bytes*oldstringtablesize)
	pcm_free(oldstringlentable,int.bytes*oldstringtablesize)
end
=== cc_export.m 62/77 ===
import msys
import mlib
import clib
import oslib

import cc_decls
import cc_support
import cc_tables
import cc_lib
import cc_headers
!import cc_headersx
import cc_lex

INT NALLPROCS
INT NALLRECS

strbuffer mmbuffer
ref strbuffer mm=&mmbuffer

global proc writemheader(ichar infile)=
[300]char mfile
ref strec d,e
int m

strcpy(&.mfile,pcm_copyheapstring(changeext(infile,".m")))

gs_init(mm)

mmstr("importdll ")
!mmstr(changeext(infile,""))
mmstr(extractbasefile(infile))
mmstrln(" =")

stmodule:=moduletable[1].stmodule


d:=stmodule^.deflist

while d do
!CPL D^.NAME,D^.LINENO
	if isheaderfile(sourcefilenames[d^.lineno>>24]) then
		d:=d^.nextdef
		next
	fi
	case d^.nameid
	when staticid then
!GS_STR(MM,"STATIC "); GS_STRLN(MM,D^.NAME)
!		mmstr("    ")
		mmstr("    ")
		mmmode(d^.mode)
!		mmstr(" """)
		mmstr(" ")
		mmstr(fixname(d^.name))
!		mmstr("""")
		if d^.code then
!CPL "STATIC INIT VAR"
			mmstr(" =")
			mmstr(strexpr(d^.code)^.strptr)
		fi
		mmline()

	when procid then
++NALLPROCS
		writefunction(d)
	when typeid then
!		m:=d^.mode
!		case ttbasetype[m]
!		when tstruct then
!			writerecord(m)
!		esac
	when enumid then
!		mmstr("ENUM ")
!		mmstrln(d^.name)
!		mmstr("    const """)
		mmstr("    const ")
		mmleftstr(fixname(d^.name),34)
!		mmstr(""" = ")
		mmstr(" = ")
		mmint(d^.index)
		mmline()

	when macroid then
		mmstr("MACRO ")
		mmstrln(fixname(d^.name))
	when structtagid then
++NALLRECS

		writerecord(d^.mode)
!		mmstr("STRUCT TAG")
!		mmstrln(d^.name)

	esac
	d:=d^.nextdef
od


for i:=0 to hstmask do
	e:=hashtable^[i]
	if e^.name and e^.symbol=namesym and e^.nameid=macroid then
		if not isheaderfile(sourcefilenames[e^.lineno>>24]) then
			if e^.tokenlist then
				mmstr("    const ")
				mmleftstr(fixname(e^.name),34)
				mmstr(" = ")
				showmacroseq(e^.tokenlist)
				mmstrln("    ! macro")
			fi
		fi

	fi
od
mmstrln("end")

CPL "DONE"
CPL =NALLPROCS
CPL =NALLRECS

!CPL MM^.STRPTR
moduletable[1].mhdrstr:=mm^.strptr

if logdest then
	println @logdev,"M HEADERS\N========="
	println @logdev,mm^.strptr
fi

CPL "Writing M Header:",&.mfile
writefile(&.mfile,cast(mm^.strptr),mm^.length)

end

proc showmacroseq(ref tokenrec tk)=
while tk do
	emittoken(tk,mm)
	tk:=tk^.nexttoken
od
end

proc mmstr(ichar s)=
gs_str(mm,s)
end

proc mmleftstr(ichar s,int n)=
gs_leftstr(mm,s,n)
end

proc mmstrln(ichar s)=
gs_strln(mm,s)
end

proc mmint(int a)=
[32]char str
!sprintf(&.str,"%lld",a)
getstrint(a,&.str)
gs_str(mm,&.str)
end

proc mmline()=
gs_line(mm)
end

proc writefunction(ref strec d)=
ichar file
ref paramrec pm
int n,isvar

!file:=sourcefilenames[d^.lineno>>24]
!if isheaderfile(file) then
!!	CPL "IS IN HEADER:",D^.NAME
!	return
!fi

if d^.mode=tvoid then
	mmstr("    clang proc     ")
else
	mmstr("    clang function ")
fi
mmstr("""")
!mmstr(fixname(d^.name))

mmstr(d^.name)

!mmstr(""" (")
mmstr("""")
!mmleftstr(" ",34-strlen(fixname(d^.name)))
mmleftstr(" ",34-strlen(d^.name))
mmstr("(")

!CPL D^.NAME,=D^.PARAMLIST

pm:=d^.paramlist
n:=pm^.nparams
isvar:=pm^.flags=pm_variadic
for i to n do
	mmmode(pm^.mode)
	if i<>n or isvar then
!		if i<>n then
		mmstr(",")
	fi
	pm:=pm^.nextparam
od
if isvar then
	mmstr("...")
fi

mmstr(")")

if d^.mode<>tvoid then
	mmmode(d^.mode)
fi

mmline()
!CPL "END FN"
end

proc mmmode(int m,expand=1) =
int t,u

t:=ttbasetype[m]
case t
when tref then
	mmstr("ref ")
	u:=tttarget[m]
	if ttbasetype[u]=tproc then
		writefnptr(u)
	else
		mmmode(tttarget[m])
	fi

when tarray then
	mmstr("[")
	if ttlength[m] then
		mmint(ttlength[m])
	fi
	mmstr("]")
	mmmode(tttarget[m])

when tenum then
	mmstr("int")

when tstruct,tunion then
	mmstr(fixname(ttnamedef[m]^.name))
!	MMSTR("<STRUCT/UNION>")

when tproc then
	MMSTR("<PROC>")
!	strcpy(dest,"proc[PM](")
!	pm:=ttparams[m]
!	n:=pm^.nparams
!	for i to n do
!		istrmode(pm^.mode,0,dest+strlen(dest))
!		if i<>n then
!			strcat(dest,",")
!		fi
!		pm:=pm^.nextparam
!	od
!	strcat(dest,")")
!	istrmode(tttarget[m],0,dest+strlen(dest))

else
	mmstr(stdtypemnames[t])
esac
end

proc writerecord(int m, rectype='R', level=1)=
ref strec d,e
int emode

!mmline()

to level do
	mmstr("    ")
od
++level

d:=ttnamedef[m]
if rectype='R' then
	mmstr("record ")
	mmstr(fixname(d^.name))
	mmstrln(" =")
else
	mmstrln((rectype='S'|"struct"|"union"))
fi

e:=d^.deflist
if e=nil then
	to level do
		mmstr("    ")
	od
	mmstrln("var int dummy    !empty record")
fi

while e do
	emode:=e^.mode
	to level do
		mmstr("    ")
	od

	if strchr(e^.name,'$') then
		case ttbasetype[emode]
		when tunion then
			writerecord(emode,'U',level)
		when tstruct then
			writerecord(emode,'S',level)
		esac
	else
		mmstr("var ")
		mmmode(e^.mode)
		mmstr(" ")
		mmstrln(fixname(e^.name))
	fi
	e:=e^.nextdef
od
to level-1 do
	mmstr("    ")
od
mmstrln("end")
mmline()
end

proc writefnptr(int m)=
ref paramrec pm
int isvar,n,target


target:=tttarget[m]


if target=tvoid then
	mmstr("clang proc(")
else
	mmstr("clang function(")
fi

pm:=ttparams[m]
n:=pm^.nparams
isvar:=pm^.flags=pm_variadic
for i to n do
	mmmode(pm^.mode)
	if i<>n or isvar then
!		if i<>n then
		mmstr(",")
	fi
	pm:=pm^.nextparam
od
if isvar then
	mmstr("...")
fi

mmstr(")")

if target<>tvoid then
	mmmode(target)
fi

end

function fixname(ichar name)ichar=
static []ichar reservedwords = (
	"function",
	"read",
	"type",
	"next",
	"stop",
	"callback",
	"len",
	"$dummy"
)
[128]char str

for i to reservedwords.len do
	if eqstring(reservedwords[i],name) then
		strcpy(&.str,name)
		strcat(&.str,"$")
!		return &.str
		return pcm_copyheapstring(&.str)
	fi
od

!strcpy(&.str,name)
!convlcstring(&.str)
!return pcm_copyheapstring(&.str)

return name
end
=== cc_assembler.m 63/77 ===
import clib
import mlib
import oslib

importpath "c:/ax/"
import aa_tables
import aa_decls
import aa_lex
import aa_parse
import aa_lib
import aa_genss
import aa_writeexe
import aa_writeobj

global function assembler(ichar outputfile, ref[]ichar asmfiles,dllfiles,
!		int nasmfiles,ndllfiles,fobj,fcaption,ichar assemsource=nil)int=
		int nasmfiles,ndllfiles,fobj,fcaption,ref[]ichar assemsources=nil,
		ichar entrypointname)int=
ref strbuffer ss
int ntokens,t,i

!CPL "INTERNAL ASSEMBLER", =ENTRYPOINTNAME

initall()

for i to nasmfiles do
	addmodule(asmfiles^[i])

!CPL I,ASMFILES^[I]

od
!CPL =NASMFILES,=NMODULES

!if nsearchlibs=0 then
nsearchlibs:=0

searchlibs[++nsearchlibs]:="msvcrt"
searchlibs[++nsearchlibs]:="gdi32"
searchlibs[++nsearchlibs]:="user32"
searchlibs[++nsearchlibs]:="kernel32"
!searchlibs[++nsearchlibs]:="ucrtbase"
!fi

for i to ndllfiles do
	addsearchlib(dllfiles^[i])
od

!if nsearchlibs=0 then
!	searchlibs[1]:="msvcrt"
!	searchlibs[2]:="gdi32"
!	searchlibs[3]:="user32"
!	searchlibs[4]:="kernel32"
!	nsearchlibs:=4	
!fi
!FOR I TO NSEARCHLIBS DO
!	CPL I,":",SEARCHLIBS[I]
!OD

if nmodules=0 then
	loaderror("No input files specified")
fi

if fcaption then
	println "Assembling to",outputfile
fi

loadsourcefiles(assemsources)

parsemodules()

if fobj then
	genss()
	writess(outputfile)
else
	genss()
	initsectiontable()
	genexe(entrypointname,"",0)
	writeexe(outputfile,0)
fi
return 1
end

proc loadsourcefiles(ref[]ichar assemsources)=
	int i
	ichar source

!CPL "LOADSOURCEFILES",=REF VOID(ASSEMSOURCE)

	for i to nmodules do
!		if assemsources and i<nmodules then	!NOTE LAST MODULE IS ALWAYS BCCLIB
		if assemsources then
			source:=assemsources^[i]
		else
			source:=cast(readfile(moduletable[i].filename))
			if source=nil then
				loaderror_s("Can't load file: %s",moduletable[i].filename)
			fi
		fi
		moduletable[i].source:=source
	od
end

proc parsemodules=
	int i
	ichar source

	for i to nmodules do
		currmoduleno:=i
		modulenamelist:=nil
		readmodule(i)

		checkundefined()
		if nundefined then
			println "Couldn't assemble - press key"
!			os_getch()
			stop 1
		fi

		scanglobals()			!fixup any globals and imports
		resethashtable()

	od

!Try scanning all mclcode to fix imports/exports. That is, all operands
!point to the same st entry
ref mclrec m

m:=mccode

while m do
	fixopnd(m^.a)
	fixopnd(m^.b)
	m:=m^.nextmcl
od

end

proc fixopnd(ref opndrec a)=
ref strec d
if a=nil then return fi
if a^.labeldef then
	d:=a^.labeldef
	if d^.basedef then
		a^.labeldef:=d^.basedef
	fi
fi
end

proc initall=
!pcm_init()
initlex()
initlib()
end

proc loaderror(ichar mess)=
println "Error:",mess
stop 1
end

proc loaderror_s(ichar mess,s)=
[256]char str
strcpy(&.str,mess)
strcat(&.str,mess)

!sprintf(&.str,mess,s)
loaderror(&.str)
end

proc addmodule(ichar name)=
if nmodules>=maxmodules then
	loaderror("Too many modules")
fi
++nmodules
moduletable[nmodules].filename:=pcm_copyheapstring(name)
moduletable[nmodules].name:=pcm_copyheapstring(extractfile(name))
moduletable[nmodules].source:="<empty>"

end

proc addsearchlib(ichar name)=
[300]char str
if nsearchlibs>=maxsearchlibs then
	loaderror("Too many libraries")
fi
++nsearchlibs
strcpy(&.str,name)
str[strlen(name)-3]:=0			!get rid of .dll extension
searchlibs[nsearchlibs]:=pcm_copyheapstring(&.str)
end

function getemptyst(ref strec d)ref strec=
!d is an existing strec
!create an new empty strec if needed (when d is also keyword name,
! and/or e is not nil), and return a pointer to that
!otherwise just return nil
ref strec dnew

if d^.ksymbol then					!need a replacement strec
	dnew:=pcm_allocz(strec.bytes)
	dnew^.name:=d^.name
	dnew^.namelen:=d^.namelen
	dnew^.ksymbol:=d^.ksymbol
	dnew^.subcode:=d^.subcode
	dnew^.regsize:=d^.regsize
	return dnew
fi
return nil
end

function findduplname(ref strec d)ref strec=
!look for any dupl global/export name to d

ref strec e
if d^.basedef then
	return d^.basedef
fi

e:=dupltable[d^.htfirstindex]

while e do
	if d^.namelen=e^.namelen and memcmp(d^.name,e^.name,d^.namelen)=0 then
		d^.basedef:=e
		return e
	fi
	e:=e^.nextdupl
od
return nil
end

proc adddupl(ref strec d)=
!add the first dupl entry for d in dupltable
!the linked list is in reverse order, and generally ends up containing
!one element unless there are two or more names that share the same default
!hash table entry

d^.nextdupl:=dupltable[d^.htfirstindex]
dupltable[d^.htfirstindex]:=d
end

proc scanglobals=
!have just finished parsing a module
!scan the symbols defined there to:
! * find any new imports/globals
! * find new imports/globals to merge with existing ones
!Then the entries in the hashtable must be purged, by substituting with
!either nil, or an empty value if keyword data or .basedef must be remembered

ref strec d,e

d:=modulenamelist

while d do
	case d^.symbol
	when importedsym then
		e:=findduplname(d)
		if e then
			case e^.symbol
			when importedsym then			!no change
			when exportedsym then
				d^.symbol:=exportedsym		!set both global
				d^.reftype:=e^.reftype:=fwd_ref
			esac
		else
			addimport(d)
			adddupl(d)
		fi
	when exportedsym then
		e:=findduplname(d)
		if e then
			case e^.symbol
			when importedsym then
				e^.symbol:=exportedsym		!set both global
				d^.reftype:=e^.reftype:=fwd_ref
			when exportedsym then			!error?
CPL MODULETABLE[D^.MODULENO].NAME,D^.NAME,D^.HTINDEX
CPL MODULETABLE[E^.MODULENO].NAME,E^.NAME,E^.HTINDEX
				serror_s("Multiply-defined global: %s",d^.name)
			esac
		else
			e:=d
			addimport(d)
			adddupl(d)
		fi
	esac

	d:=d^.nextdef
od
end

proc resethashtable=
!have just finished parsing a module
!scan the symbols defined there to:
! * find any new imports/globals
! * find new imports/globals to merge with existing ones
!Then the entries in the hashtable must be purged, by substituting with
!either nil, or an empty value if keyword data or .basedef must be remembered

ref strec d,e

d:=modulenamelist

while d do
	lexhashtable[d^.htindex]:=getemptyst(d)
	d:=d^.nextdef
od

modulenamelist:=nil

end
=== aa_tables.m 64/77 ===
!Assembler Tables

global tabledata() []ichar symbolnames=
	(errorsym,			$),		! Lex error
	(commasym,			$),		! ","
	(colonsym,			$),		! ":"
	(dcolonsym,			$),		! "::"
	(lsqsym,			$),		! [
	(rsqsym,			$),		! ]

	(addsym,			$),		! +
	(subsym,			$),		! -
	(mulsym,			$),		! *

	(eqsym,				$),		! =

	(eolsym,			$),		! End of line
	(eofsym,			$),		! Eof seen

	(hashsym,			$),		! #

	(intconstsym,		$),		! 123 64 bits signed
	(realconstsym,		$),		! 123.4 64 bits
	(stringconstsym,	$),		! "ABC"

	(namesym,			$),		! raw name
	(namedconstsym,		$),		! name = expr
	(fwdlocalsym,		$),		! name
	(localsym,			$),		! name::
	(importedsym,		$),		! name*
	(exportedsym,		$),		! name:::

	(kopcodesym,		$),		! mov etc
	(kregsym,			$),		! d0, r5, eax etc
	(kxregsym,			$),		! xmm0 etc
	(kfregsym,			$),		! st0 etc
	(kmregsym,			$),		! mmx1 etc
	(kjmpccsym,			$),		! jz etc
	(ksetccsym,			$),		! setz etc
	(kmovccsym,			$),		! cmovz etc
	(kprefixsym,		$),		! dword etc
	(ksegnamesym,		$),		! idata etc

	(kdummysym,			$)		!
end

global tabledata() []ichar mclnames, []byte mclnopnds, []byte mclcodes =

	(m_comment,			$,		0,		0),		!
	(m_blank,			$,		0,		0),		!
	(m_end,				$,		0,		0),		!

	(m_label,			$,		1,		0),		!
	(m_nop,				$,		0,		0x90),		!
	(m_param,			$,		1,		0),		!
	(m_assem,			$,		1,		0),		!
	(m_proc,			$,		1,		0),		!

	(m_mov,				$,		2,		0),		!
	(m_push,			$,		1,		0),		!
	(m_pop,				$,		1,		0),		!
	(m_lea,				$,		2,		0),		!
	(m_cmovcc,			$,		2,		0),		!

	(m_movd,			$,		2,		0),		!
	(m_movq,			$,		2,		0),		!

	(m_movsx,			$,		2,		0),		!
	(m_movzx,			$,		2,		0),		!
	(m_movsxd,			$,		2,		0),		!

	(m_call,			$,		1,		0xE8),		!
	(m_ret,				$,		0,		0xC3),	!
	(m_retn,			$,		1,		0),		!
	(m_leave,			$,		0,		0xC9),		!

	(m_jmp,				$,		1,		0xE9),	!
	(m_jmpcc,			$,		2,		0),		!
	(m_xchg,			$,		2,		0),		!

	(m_add,				$,		2,		0),		!
	(m_sub,				$,		2,		5),		!
	(m_adc,				$,		2,		2),		!
	(m_sbb,				$,		2,		3),		!
	(m_imul,			$,		1,		5),		!
	(m_mul,				$,		1,		4),		!
	(m_imul2,			$,		2,		0),		!
	(m_imul3,			$,		3,		0),		!

	(m_idiv,			$,		1,		7),		!
	(m_div,				$,		1,		6),		!

	(m_and,				$,		2,		0x04),	!
	(m_or,				$,		2,		0x01),	!
	(m_xor,				$,		2,		0x06),	!
	(m_test,			$,		2,		0),		!

	(m_cmp,				$,		2,		0x07),	!

	(m_shl,				$,		2,		0x04),	!
	(m_sar,				$,		2,		0x07),	!
	(m_shr,				$,		2,		0x05),	!
	(m_rol,				$,		2,		0x00),	!
	(m_ror,				$,		2,		0x01),	!
	(m_rcl,				$,		2,		0x02),	!
	(m_rcr,				$,		2,		0x03),	!

	(m_neg,				$,		1,		3),		!
	(m_not,				$,		1,		2),		!

	(m_inc,				$,		1,		0),		!
	(m_dec,				$,		1,		1),		!

	(m_cbw,				$,		0,		0),	!
	(m_cwd,				$,		0,		0),	!
	(m_cdq,				$,		0,		0),		!
	(m_cqo,				$,		0,		0),		!
	(m_setcc,			$,		2,		0),		!

	(m_bsf,				$,		2,		0xBC),	!
	(m_bsr,				$,		2,		0xBD),	!

	(m_sqrtsd,			$,		2,		0x51),	!
	(m_sqrtss,			$,		2,		0x51),	!
	(m_addss,			$,		2,		0x58),	!
	(m_subss,			$,		2,		0x5C),	!
	(m_mulss,			$,		2,		0x59),	!
	(m_divss,			$,		2,		0x5E),	!

	(m_addsd,			$,		2,		0x58),	!
	(m_subsd,			$,		2,		0x5C),	!
	(m_mulsd,			$,		2,		0x59),	!
	(m_divsd,			$,		2,		0x5E),	!

	(m_comiss,			$,		2,		0),		!
	(m_comisd,			$,		2,		0),		!
	(m_xorpd,			$,		2,		0x57),	!
	(m_xorps,			$,		2,		0x57),	!
	(m_andpd,			$,		2,		0x54),	!
	(m_andps,			$,		2,		0x54),	!
	(m_pxor,			$,		2,		0xEF),	!
	(m_pand,			$,		2,		0xDB),	!
	(m_cvtss2si,		$,		2,		0),		!
	(m_cvtsd2si,		$,		2,		0),		!
	(m_cvttss2si,		$,		2,		0),		!
	(m_cvttsd2si,		$,		2,		0),		!

	(m_cvtsi2ss,		$,		2,		0),		!
	(m_cvtsi2sd,		$,		2,		0),		!

	(m_cvtsd2ss,		$,		2,		0),		!
	(m_cvtss2sd,		$,		2,		0),		!

	(m_movdqa,			$,		2,		0x66),	!
	(m_movdqu,			$,		2,		0xF3),	!

	(m_pcmpistri,		$,		3,		0x63),		!
	(m_pcmpistrm,		$,		3,		0x62),		!

	(m_fld,				$,		1,		0),		!
	(m_fst,				$,		1,		2),		!
	(m_fstp,			$,		1,		3),		!

	(m_fild,			$,		1,		0),		!
	(m_fist,			$,		1,		2),		!
	(m_fistp,			$,		1,		3),		!

	(m_fadd,			$,		0,		0xC1),	!
	(m_fsub,			$,		0,		0xE9),	!
	(m_fmul,			$,		0,		0xC9),	!
	(m_fdiv,			$,		0,		0xF9),	!
	(m_fsqrt,			$,		0,		0xFA),	!
	(m_fsin,			$,		0,		0xFE),	!
	(m_fcos,			$,		0,		0xFF),	!
	(m_fsincos,			$,		0,		0xFB),	!
	(m_fptan,			$,		0,		0xF2),	!
	(m_fpatan,			$,		0,		0xF3),	!
	(m_fabs,			$,		0,		0xE1),	!
	(m_fchs,			$,		0,		0xE0),	!

	(m_minss,			$,		2,		0x5D),	!
	(m_maxss,			$,		2,		0x5F),	!
	(m_minsd,			$,		2,		0x5D),	!
	(m_maxsd,			$,		2,		0x5F),	!

	(m_db,				$,		1,		0),		!
	(m_dw,				$,		1,		0),		!
	(m_dd,				$,		1,		0),		!
	(m_dq,				$,		1,		0),		!
	(m_ddoffset,		$,		1,		0),		!

	(m_segment,			$,		1,		0),		!
	(m_isegment,		$,		0,		0),		!
	(m_zsegment,		$,		0,		0),		!
	(m_csegment,		$,		0,		0),		!

	(m_align,			$,		1,		0),		!
	(m_resb,			$,		1,		1),		!
	(m_resw,			$,		1,		2),		!
	(m_resd,			$,		1,		4),		!
	(m_resq,			$,		1,		8),		!

	(m_xlat,			$,		0,		0xD7),	!
	(m_loopnz,			$,		1,		0xE0),	!
	(m_loopz,			$,		1,		0xE1),	!
	(m_loopcx,			$,		1,		0xE2),	!
	(m_jecxz,			$,		1,		0xE3),	!
	(m_jrcxz,			$,		1,		0xE3),	!

	(m_cmpsb,			$,		0,		0),		!
	(m_cmpsw,			$,		0,		0),		!
	(m_cmpsd,			$,		0,		0),		!
	(m_cmpsq,			$,		0,		0),		!

	(m_rdtsc,			$,		0,		0x31),	!
	(m_popcnt,			$,		2,		0),		!

	(m_finit,			$,		0,		0),		!

	(m_fldz,			$,		0,		0xEE),	!
	(m_fld1,			$,		0,		0xE8),	!
	(m_fldpi,			$,		0,		0xEB),	!
	(m_fld2t,			$,		0,		0xE9),	!
	(m_fld2e,			$,		0,		0xEA),	!
	(m_fldlg2,			$,		0,		0xEC),	!
	(m_fldln2,			$,		0,		0xED),	!

	(m_halt,			$,		0,		0xF4),	!
end

global tabledata() [0:]ichar regnames, [0:]byte regcodes =
	(rnone=0,	$,	0),			!
	(r0,		$,	0),			!d0 rax
	(r1,		$,	10),		!d1 r10
	(r2,		$,	11),		!d2 r11
	(r3,		$,	7),			!d3 rdi
	(r4,		$,	3),			!d4 rbx
	(r5,		$,	6),			!d5 rsi
	(r6,		$,	12),		!d6 r12
	(r7,		$,	13),		!d7 r13
	(r8,		$,	14),		!d8 r14
	(r9,		$,	15),		!d9 r15
	(r10,		$,	1),			!d10 rcx
	(r11,		$,	2),			!d11 rdx
	(r12,		$,	8),			!d12 r8
	(r13,		$,	9),			!d13 r9
	(r14,		$,	5),			!d14 rbp
	(r15,		$,	4),			!d15 rsp

	(r16,		$,	4),			!b0h ah
	(r17,		$,	7),			!b1h bh
	(r18,		$,	5),			!b10h ch
	(r19,		$,	6),			!b11h dh
end

global const rframe = r14
global const rstack = r15


!I use my own register designations Dn, An, Wn, Bn (8,4,2,1 bytes),
!which have a more sensible order than the official ones.
!The mapping is shown against Dn. Some (not all) of the official register
!names are used too

!Regindex is the ordinal value used to represent the register: 1..16
!This table is intended for initialising the global symbol table

global tabledata []ichar dregnames, []byte regsizes, []byte regindices =
	("d0",		8,	r0),		!rax	d0..d9 are for general use
	("d1",		8,	r1),		!r10	d0..d2 are volatile in ABI
	("d2",		8,	r2),		!r11

	("d3",		8,	r3),		!rdi	d3..d9 are preserved across funcs in ABI
	("d4",		8,	r4),		!rbx
	("d5",		8,	r5),		!rsi
	("d6",		8,	r6),		!r12
	("d7",		8,	r7),		!r13
	("d8",		8,	r8),		!r14
	("d9",		8,	r9),		!r15

	("d10",		8,	r10),		!rcx	d10..d13 are win64 ABI register passing regs
	("d11",		8,	r11),		!rdx	..
	("d12",		8,	r12),		!r8		..
	("d13",		8,	r13),		!r9		..

	("d14",		8,	r14),		!rbp	frame pointer
	("d15",		8,  r15),		!rsp	stack pointer

	("a0",		4,	r0),
	("a1",		4,	r1),
	("a2",		4,	r2),
	("a3",		4,	r3),
	("a4",		4,	r4),
	("a5",		4,	r5),
	("a6",		4,	r6),
	("a7",		4,	r7),
	("a8",		4,	r8),
	("a9",		4,	r9),
	("a10",		4,	r10),
	("a11",		4,	r11),
	("a12",		4,	r12),
	("a13",		4,	r13),
	("a14",		4,	r14),
	("a15",		4,  r15),

	("w0",		2,	r0),
	("w1",		2,	r1),
	("w2",		2,	r2),
	("w3",		2,	r3),
	("w4",		2,	r4),
	("w5",		2,	r5),
	("w6",		2,	r6),
	("w7",		2,	r7),
	("w8",		2,	r8),
	("w9",		2,	r9),
	("w10",		2,	r10),
	("w11",		2,	r11),
	("w12",		2,	r12),
	("w13",		2,	r13),
	("w14",		2,	r14),
	("w15",		2,  r15),


	("b0",		1,	r0),
	("b1",		1,	r1),
	("b2",		1,	r2),
	("b3",		1,	r3),
	("b4",		1,	r4),
	("b5",		1,	r5),
	("b6",		1,	r6),
	("b7",		1,	r7),
	("b8",		1,	r8),
	("b9",		1,	r9),
	("b10",		1,	r10),
	("b11",		1,	r11),
	("b12",		1,	r12),
	("b13",		1,	r13),
	("b14",		1,	r14),
	("b15",		1,  r15),
	("b16",		1,  r16),
	("b17",		1,  r17),
	("b18",		1,  r18),
	("b19",		1,  r19),

	("rax",		8,	r0),
	("rbx",		8,	r4),
	("rcx",		8,	r10),
	("rdx",		8,	r11),
	("rsi",		8,	r5),
	("rdi",		8,	r3),
	("rbp",		8,	r14),
	("rsp",		8,	r15),
	("r8",		8,	r12),
	("r9",		8,	r13),
	("r10",		8,	r1),
	("r11",		8,	r2),
	("r12",		8,	r6),
	("r13",		8,	r7),
	("r14",		8,	r8),
	("r15",		8,	r9),

	("eax",		4,	r0),
	("ebx",		4,	r4),
	("ecx",		4,	r10),
	("edx",		4,	r11),
	("esi",		4,	r5),
	("edi",		4,	r3),
	("ebp",		4,	r14),
	("esp",		4,	r15),
	("r8d",		4,	r12),
	("r9d",		4,	r13),
	("r10d",	4,	r1),
	("r11d",	4,	r2),
	("r12d",	4,	r6),
	("r13d",	4,	r7),
	("r14d",	4,	r8),
	("r15d",	4,	r9),

	("ax",		2,	r0),
	("bx",		2,	r4),
	("cx",		2,	r10),
	("dx",		2,	r11),
	("si",		2,	r5),
	("di",		2,	r3),
	("bp",		2,	r14),
	("sp",		2,	r15),
	("r8w",		2,	r12),
	("r9w",		2,	r13),
	("r10w",	2,	r1),
	("r11w",	2,	r2),
	("r12w",	2,	r6),
	("r13w",	2,	r7),
	("r14w",	2,	r8),
	("r15w",	2,	r9),


	("al",		1,	r0),
	("bl",		1,	r4),
	("cl",		1,	r10),
	("dl",		1,	r11),

	("ah",		1,	r16),
	("bh",		1,	r17),
	("ch",		1,	r18),
	("dh",		1,	r19),

	("sil",		1,	r5),
	("dil",		1,	r3),
	("bpl",		1,	r14),
	("spl",		1,	r15),

	("r8b",		1,	r12),
	("r9b",		1,	r13),
	("r10b",	1,	r1),
	("r11b",	1,	r2),
	("r12b",	1,	r6),
	("r13b",	1,	r7),
	("r14b",	1,	r8),
	("r15b",	1,	r9),

end

global []ichar xregnames = (
	"xmm0",				! x0..x3 are used for parameter passing in ABI
	"xmm1",
	"xmm2",
	"xmm3",

	"xmm4",				! x4..x5 are volatile
	"xmm5",

	"xmm6",				! x6..x15 are preserved across functions in ABI
	"xmm7",
	"xmm8",
	"xmm9",
	"xmm10",
	"xmm11",
	"xmm12",
	"xmm13",
	"xmm14",
	"xmm15")

global []ichar fregnames = (
	"st0",
	"st1",
	"st2",
	"st3",
	"st4",
	"st5",
	"st6",
	"st7")

global []ichar mregnames = (
	"mmx0",
	"mmx1",
	"mmx2",
	"mmx3",
	"mmx4",
	"mmx5",
	"mmx6",
	"mmx7")

global tabledata() [0:]ichar condnames =

	(ov_cond	= 0,	"o"),
	(nov_cond	= 1,	"no"),

	(ltu_cond	= 2,	"b"),
	(geu_cond	= 3,	"ae"),

	(eq_cond	= 4,	"z"),
	(ne_cond	= 5,	"nz"),

	(leu_cond	= 6,	"be"),
	(gtu_cond	= 7,	"a"),

	(s_cond		= 8,	"s"),
	(ns_cond	= 9,	"ns"),

	(p_cond		= 10,	"p"),
	(np_cond	= 11,	"np"),

	(lt_cond	= 12,	"l"),
	(ge_cond	= 13,	"ge"),

	(le_cond	= 14,	"le"),
	(gt_cond	= 15,	"g"),
end

global tabledata []ichar jmpccnames, []byte jmpcccodes =
	("jo",		ov_cond),
	("jno",		nov_cond),
	("jb",		ltu_cond),
	("jae",		geu_cond),
	("jz",		eq_cond),
	("jnz",		ne_cond),
	("jbe",		leu_cond),
	("ja",		gtu_cond),
	("js",		s_cond),
	("jns",		ns_cond),
	("jp",		p_cond),
	("jnp",		np_cond),
	("jl",		lt_cond),
	("jge",		ge_cond),
	("jle",		le_cond),
	("jg",		gt_cond),
	("jc",		ltu_cond),
	("jnc",		geu_cond),
end

global tabledata []ichar setccnames, []byte setcccodes =
	("seto",	ov_cond),
	("setno",	nov_cond),
	("setb",	ltu_cond),
	("setae",	geu_cond),
	("setz",	eq_cond),
	("setnz",	ne_cond),
	("setbe",	leu_cond),
	("seta",	gtu_cond),
	("sets",	s_cond),
	("setns",	ns_cond),
	("setp",	p_cond),
	("setnp",	np_cond),
	("setl",	lt_cond),
	("setge",	ge_cond),
	("setle",	le_cond),
	("setg",	gt_cond),
	("setc",	ltu_cond),
	("setnc",	geu_cond),
end

global tabledata []ichar cmovccnames, []byte cmovcccodes =
	("cmovo",	ov_cond),
	("cmovno",	nov_cond),
	("cmovb",	ltu_cond),
	("cmovae",	geu_cond),
	("cmovz",	eq_cond),
	("cmovnz",	ne_cond),
	("cmovbe",	leu_cond),
	("cmova",	gtu_cond),
	("cmovs",	s_cond),
	("cmovns",	ns_cond),
	("cmovp",	p_cond),
	("cmovnp",	np_cond),
	("cmovl",	lt_cond),
	("cmovge",	ge_cond),
	("cmovle",	le_cond),
	("cmovg",	gt_cond),
	("cmovc",	ltu_cond),
	("cmovnc",	geu_cond),
end

global tabledata []ichar prefixnames, []byte prefixsizes =
	("byte",	1),		
	("word",	2),
	("word16",	2),
	("word32",	4),
	("dword",	4),
	("word64",	8),
	("qword",	8),
	("word128",	16)
end

global tabledata() [0:]ichar reftypenames =	!use during pass2
	(extern_ref=0,		$),		!is external
	(fwd_ref,			$),		!not yet reached
	(back_ref,			$),		!has been reached
end

global tabledata() []ichar segmentnames =
	(code_seg,		$),
	(idata_seg,		$),
	(zdata_seg,		$),
	(rodata_seg,	$),
	(impdata_seg,	$),
end
=== aa_decls.m 65/77 ===
!MXA Assembler Global Decls

global const compilerversion="2018.1.22"

!STREC usage::

!symbol=
! namesym			name, truename=""
! namedconstsym		name, value=(labeldef,value)
! labelsym			name, labdefined, value, segment, scope, lineno, stindex, offset

! kdirectivesym		// not done yet
! kopcodesym		name="mov" etc, subcode=m_mov etc
! kregsym			name="r0" etc, subcode=r0/etc, regsize=1/2/4/8
! kxregsym			name="xmm0" etc, subcode=r0/etc
! kfregsym			name="st0" etc, subcode=t0/etc
! kmregsym			name="mmx0" etc, subcode=r0/etc
! kjmpccsym			name="jz"/etc, subcode=z_cond/etc
! ksetccsym			name="setz"/etc, subcode=z_cond/etc
! kmovccsym			name="cmovz"/etc, subcode=z_cond/etc
! ksegnamesym,		name="code" etc, subcode=code_seg/etc

global record fwdrec =
	ref fwdrec nextfwd
	int32 offset
	int16 reltype
	int16 seg
end

global record opndrec = !24 bytes
	ref strec labeldef	!nil, or handle of strec for label
	union
		int64 value		!const value/extra offset/cond code/string for comments
		real64 xvalue	!floating point value
		ref char svalue
	end
	byte mode		!a_reg etc, low level operand details
	byte size		!byte size of operand: 1,2,4,8
	byte reg		!0, or main register
	byte regix		!0, or index register

	byte scale		!0, or scale factor for regix
	byte addrsize	!4 or 8 for a_mem when regs are involved
	byte valtype	!0 (no value or int) or 'R'/'S'
	byte spare2
end

global record strec =
	ichar name			!name of symbol (named token/keyword or identifier)
	ref fwdrec fwdrefs	!fwd ref chain
!	union
!		ref valuerec value	!named constants: valuerec([label],[value])
		ref opndrec expr	!named constants: valuerec([label],[value])
!		struct
			int32 offset		!label (pass 2): offset of label when encountered
			int32 stindex		!label pass 2: 0, or 1-based index within coff symboltable
			int32 importindex	!genexe: index into import table
!		end
!	end

	byte symbol			!type of token, eg. namesym
	byte ksymbol		!type of keyword, eg. opcodesym
	byte subcode		!when used as keyword
	byte regsize		!for reg keywords

	byte scope			!label pass 1: fwd/extern/local/global
	byte reftype		!label pass 2: extern/back/fwd
	byte segment		!label pass 2: code_seg etc or 0
	byte namelen

	ref strec basedef		!nil, or global/import def using this name
	ref strec nextdef		!in module name list
	ref strec nextdupl		!when part of in global import list

	int32 moduleno
!	word16 htindex				!index into hashtable
!	word16 htfirstindex			!initial index before stepping to avoid clashes
	word32 htindex				!index into hashtable
	word32 htfirstindex			!initial index before stepping to avoid clashes
	[48]BYTE SPARE
end

global record relocrec =			!informal version
	ref relocrec nextreloc
	int reloctype
	int offset
	int stindex
end

!record used for expanding buffers. Expansion is not automatic: buffercheck(n)
!is needed at strategic points to ensure that are at least n bytes left
global record dbuffer =
	ref byte pstart
	union
		ref byte pcurr
		ref word16 pcurr16
		ref word32 pcurr32
		ref word64 pcurr64
	end
	ref byte pend
	int alloc
end

global record modulerec =
	ichar filename
	ichar name
	ichar source
end

global record stlistrec =
	ref strec def
	ref stlistrec nextitem
end

global int lxfileno=0	!*@ current source file number
global int lxlineno=0	!*@ current source line number

global int nsourcefiles=0	!no. of linear file names

global const maxmodules=200
global const maxsearchlibs=30
global [maxmodules]modulerec moduletable
global [maxsearchlibs]ichar searchlibs
global int nmodules
global int nsearchlibs

!global const hstsize=65536
!global const hstsize=65536*4
!global const hstsize=1048576
!global const hstsize=1048576*4
global const hstsize=1048576*8

global const hstmask=hstsize-1
global [0:hstsize]ref strec lexhashtable
global [0:hstsize]ref strec dupltable		!link dupl names

global ref void logdev		!dest for diagnostics and output of tables

global int fverbose=0		!whether to display message for each pass
global int fquiet=0

global int LINECOUNT=0

global int nundefined=0
global int alineno=0

global int ss_zdatalen
global ref dbuffer ss_zdata			!used for error checking only (should be empty at end)
global ref dbuffer ss_idata
global ref dbuffer ss_code
global ref relocrec ss_idatarelocs
global ref relocrec ss_coderelocs
global int ss_nidatarelocs
global int ss_ncoderelocs

global const init_ss_symbols=16384
global ref []ref strec ss_symboltable
global int ss_nsymbols
global int ss_symboltablesize

global ref stlistrec globalimportlist		!all global vars and imports across all moduls

global ref strec modulenamelist			!all defs defined in last module
global int currmoduleno

GLOBAL INT NMCLASM
GLOBAL INT NMCLOPNDSASM
=== aa_lex.m 66/77 ===
!Tokeniser Module
import* aa_common

macro testmode=0

const etx = 26
const cr  = 13
const lf  = 10

!the following returned by updated by lexreadtoken()

global int lxsymbol		!* main symbol kind
global int lxsubcode	!* for some symbols, which specific keyword

global int64 lxvalue
global real64 lxxvalue
global ichar lxsvalue
global int lxlength
int lxhashvalue

global ref byte lxsptr		!@ points to next char in source
ref byte lxstart		!@ start of source code for this file
global ref strec lxsymptr		!set by lookuplex()

[0..255]char alphamap
[0..255]char digitmap
[0..255]char commentmap

global proc lex=
!lowest level lex() function, reads names, numbers etc but does no lookups or translations
!returns results in lx-vars. Current source pointer should be in lxsptr
int i, c, d, hsum, length
ref byte pstart

lxsubcode:=0

doswitch c:=lxsptr++^
when 'a'..'z','$','_','.' then
	pstart:=lxsptr-1		!point to start of name in source buffer
doname::
	hsum:=pstart^

	doswitch c:=lxsptr++^
	when 'a'..'z','0'..'9','_','$','.' then
		hsum:=hsum<<4-hsum+c
	when 'A'..'Z' then
		(lxsptr-1)^:=c+32
		hsum:=hsum<<4-hsum+c+' '
	else
		--lxsptr
		exit
	end

	lxlength:=lxsptr-pstart
	lxhashvalue:=hsum<<5 -hsum

	if lookuplex(cast(pstart),lxlength) then
		if lxsymptr^.ksymbol then			!keywords take priority here
			lxsymbol:=lxsymptr^.ksymbol
			lxsubcode:=lxsymptr^.subcode
		else
			lxsymbol:=lxsymptr^.symbol
		fi
	else
		lxsymbol:=namesym
	fi

	return

when 'A'..'Z' then
	pstart:=lxsptr-1
	c:=pstart^:=pstart^+32
	goto doname

when '0'..'9' then
	readnumber(c)
	return

when '`' then
	pstart:=lxsptr		!point to start of name in source buffer
	hsum:=0

	doswitch c:=lxsptr^
	when 'A'..'Z','a'..'z','0'..'9','_','$','.' then
		++lxsptr
		hsum:=hsum<<4-hsum+c
	else
		exit
	end

	lxsymbol:=namesym
	if pstart=lxsptr then
		lxerror("NULL ` name")
	fi
	lxlength:=lxsptr-pstart
	lxhashvalue:=hsum<<5-hsum

	if lookuplex(cast(pstart),lxlength) then
		lxsymbol:=lxsymptr^.symbol			!can't be a keyword
		if lxsymbol=0 then					!assume was a keyword; use as name
			lxsymbol:=lxsymptr^.symbol:=namesym
		fi
	fi
	return

when '!',';','#' then			!comment to eol

	while commentmap[lxsptr++^] do od

	if (lxsptr-1)^=0 then --lxsptr fi
!
	++lxlineno

	lxsymbol:=eolsym
	return

when ',' then
	lxsymbol:=commasym
	return

when ':' then
	if lxsptr^=':' then
		lxsymbol:=dcolonsym
		++lxsptr
	else
		lxsymbol:=colonsym
	fi
	return

when '[' then
	lxsymbol:=lsqsym
	return

when ']' then
	lxsymbol:=rsqsym
	return

when '+' then
	lxsymbol:=addsym
	return

when '-' then
	lxsymbol:=subsym
	return

when '*' then
	lxsymbol:=mulsym
	return

when '=' then
	lxsymbol:=eqsym
	return

when '\'' then
	pstart:=lxsptr

	do
		switch lxsptr++^
		when '\'' then
			exit
		when cr,lf then
			lxerror("String not terminated")
		endswitch
	od
	length:=lxsptr-pstart-1
	lxvalue:=0
	for i:=length downto 1 do
		lxvalue:=lxvalue<<8+(pstart+i-1)^
	od
	lxsymbol:=intconstsym
	return

when '"' then
	pstart:=lxsptr

	do
		switch lxsptr++^
		when '"' then
			lxsvalue:=cast(pstart)
			lxlength:=lxsptr-pstart-1
			(lxsvalue+lxlength)^:=0
			lxsymbol:=stringconstsym
			return
		when cr,lf,etx,0 then
			lxerror("String not terminated")
		endswitch
	od

when ' ',9 then

when cr then			!lf expected to follow

when lf then
	++lxlineno
	lxsymbol:=eolsym
	return

when 0,etx then
	lxsymbol:=eofsym
	--lxsptr
	return
else
	lxsymbol:=errorsym
	lxvalue:=c
	return

end doswitch
end

global proc initlex=
lxsubcode:=0
lxsymbol:=errorsym

lxlineno:=0

int i
for i:=0 to 255 do
	switch i
	when 'A'..'Z','a'..'z','$','_','0'..'9' then
		alphamap[i]:=1
	end
	switch i
	when '0'..'9' then
		digitmap[i]:=1
	end
	commentmap[i]:=1
od

commentmap[0]:=0
commentmap[lf]:=0

inithashtable()

!CPL "INITLEX",HSTSIZE

end

proc readreal(ref[]char s,int slen, intlen,exponseen)=
!intstr is a string containing all digits, before and after decimal point
!intlen=0:  no decimal point, so fractional part is empty
!intlen<>0: length of integer part
!expon=1:   e/E was last char, so need to read exponent first
!expon=0:   No e/E seen, so no exponent
int i,fractlen,expon,exponsign,c,digs
int64 x

if intlen=0 or intlen=slen then
	fractlen:=0
else
	fractlen:=slen-intlen
fi

expon:=0
exponsign:=0

if exponseen then
	case c:=lxsptr++^
	when '+' then
	when '-' then
		exponsign:=1
	else
		--lxsptr
	esac

	digs:=0
	doswitch c:=lxsptr++^
	when '0'..'9' then
		expon:=expon*10+c-'0'
		++digs
	else
		--lxsptr
		exit
	end
	if digs=0 then
		lxerror("Exponent error")
	fi
	if exponsign then expon:=-expon fi
fi

expon:=expon-fractlen

lxxvalue:=0.0

for i:=1 to slen do
	c:=s^[i]
	lxxvalue:=lxxvalue*10.0+(c-'0')
od

if expon>0 then
	to expon do
		lxxvalue:=lxxvalue*10.0
	od
elsif expon<0 then
	to -expon do
		lxxvalue:=lxxvalue/10.0
	od
fi

lxsymbol:=realconstsym
end

proc readnumber(int c)=
!A digit c 0..9 has just been read. Numeric formats are::
!1234
!0x1234
!2x1101
!Nx....		possible
[256]char str
int i,d,intlen,slen

d:=lxsptr^
case d
when 'x','X' then			!other base
	case c
	when '0' then			!hex
		++lxsptr
		readhex()
		return
	when '2' then			!binary
		++lxsptr
		readbinary()
		return
	else
		cpl c
		lxerror("Base not supported")
	esac
esac

!assume decimal
str[1]:=c
slen:=1
intlen:=0

doswitch c:=lxsptr++^
when '0'..'9' then
	str[++slen]:=c
when '_','\'','`' then
when '.' then
	intlen:=slen
when 'e','E' then
	readreal(&str,slen,intlen,1)
	return
else
	--lxsptr
	exit
end

if intlen then
	readreal(&str,slen,intlen,0)
	return
fi

if slen>20 or slen=20 and cmpstring(&.str,"18446744073709551615")>0 then
	lxerror("Overflow in 64-bit value")
fi

lxsymbol:=intconstsym

lxvalue:=0
for i:=1 to slen do
	lxvalue:=lxvalue*10+str[i]-'0'
od
end

proc readbinary=
!positioned at start of binary seq; 0 chars read yet
int ndigs

ndigs:=0
lxvalue:=0
doswitch lxsptr++^
when '0' then
	lxvalue:=lxvalue*2
	++ndigs
when '1' then
	lxvalue:=lxvalue*2+1
	++ndigs
when '2'..'9' then
	lxerror("Bad binary digit")
when '_','\'','`' then
else
	--lxsptr
	exit
end

if ndigs=0 then
	lxerror("No bin digits")
elsif ndigs>64 then
	lxerror("Overflow in binary number")
fi
lxsymbol:=intconstsym
end

proc readhex=
!positioned at start of hex seq; 0 chars read yet
int ndigs,c

ndigs:=0
lxvalue:=0
doswitch c:=lxsptr++^
when '0'..'9' then
	lxvalue:=lxvalue*16+c-'0'
	++ndigs
when 'A'..'F' then
	lxvalue:=lxvalue*16+(c-'A'+10)
	++ndigs
when 'a'..'f' then
	lxvalue:=lxvalue*16+(c-'a'+10)
	++ndigs
when '_','\'','`' then
else
	--lxsptr
	exit
end

if ndigs=0 then
	lxerror("No hex digits")
elsif ndigs>16 then
	lxerror("Overflow in hex number")
fi
lxsymbol:=intconstsym
end

global proc ps(ichar caption)=
PRINT CAPTION,":"
PRINTSYMBOL()
end

global proc printsymbol(filehandle dev=nil)=
[256]char str

strcpy(&.str,symbolnames[lxsymbol])
str[strlen(&.str)-2]:=0
!convucstring(&str)

print @dev,&.str
to 14-strlen(&.str) do print @dev," " od

case lxsymbol
when namesym then

	print @dev,lxsymptr^.name

when intconstsym then
	print @dev, lxvalue
when realconstsym then
	print @dev, lxxvalue
when stringconstsym then
	print @dev,"""",,lxsvalue,,""""!,,"end"
when errorsym then
	print @dev,lxvalue
else
	print @dev,symbolnames[lxsymbol]
	if lxsubcode then
		print " ",,lxsubcode
	fi

end

println @dev
end

proc clearhashtable=
!if defined in zdata, then will already be all zeros
!for i:=1 to hashtable.upb do
!	lexhashtable[i]:=void
!od
end

proc inithashtable=
!initialise hash table from kwddata
[32]char str
int i

if hstsize>65536 then
!limit in place because of 16-bit-wide strec fields like .htindex
!	lxerror("hash table limited to 64K entries")
fi

clearhashtable()

for i to mclnames.len do
	addreservedword(mclnames[i]+2,kopcodesym,i)
od

for i to dregnames.len do
	addreservedword(dregnames[i],kregsym,regindices[i])
	lxsymptr^.regsize:=regsizes[i]
od

for i to xregnames.len do
	addreservedword(xregnames[i],kxregsym,i)
od

for i to fregnames.len do
	addreservedword(fregnames[i],kfregsym,i)
od

for i to mregnames.len do
	addreservedword(mregnames[i],kmregsym,i)
od

for i to jmpccnames.len do
	addreservedword(jmpccnames[i],kjmpccsym,jmpcccodes[i])
od

for i to setccnames.len do
	addreservedword(setccnames[i],ksetccsym,setcccodes[i])
od

for i to cmovccnames.len do
	addreservedword(cmovccnames[i],kmovccsym,cmovcccodes[i])
od

for i to prefixnames.len do
	addreservedword(prefixnames[i],kprefixsym,prefixsizes[i])
od

for i to segmentnames.len do
	strcpy(&.str,segmentnames[i])
	str[strlen(&.str)-3]:=0
	addreservedword(pcm_copyheapstring(&.str),ksegnamesym,i)
od

addreservedword("aframe",kregsym,r14); lxsymptr^.regsize:=4
addreservedword("dframe",kregsym,r14); lxsymptr^.regsize:=8
addreservedword("astack",kregsym,r15); lxsymptr^.regsize:=4
addreservedword("dstack",kregsym,r15); lxsymptr^.regsize:=8
addreservedword("dprog",kregsym,r8); lxsymptr^.regsize:=8
addreservedword("dsptr",kregsym,r9); lxsymptr^.regsize:=8
end

proc addreservedword(ichar name,int symbol,subcode)=
lxhashvalue:=gethashvalue(name)
if lookuplex(name,0) then
	cpl =name
	lxerror("DUPL NAME")
fi

lxsymptr^.symbol:=0
lxsymptr^.ksymbol:=symbol
lxsymptr^.subcode:=subcode
end

global proc printhashtable(filehandle devx,ichar caption)=
ref strec r
int count,i

println @devx,caption,":"
count:=0
for i:=0 to lexhashtable.upb do
	r:=lexhashtable[i]
!	r:=lexhashtable[i]
	if R AND r^.name then
		count+:=1

	fi
od
println @devx,count," items in table",hstsize
end

function lookuplex(ichar name,int length=0)int=
!name is either in an existing table (for reserved words; length=0)
!or is in the source code (so is not zero-terminated; length is actual length)
!look for name in lexhashtable
!sets lxsymptr to entry in table, either of existing entry, or a new one
!returns 1/0 if found/not found (ie. old or new name)
ref strec e

int j,wrapped,insource,firstj

!++NLOOKUPS

insource:=length
if length=0 then
	length:=strlen(name)
fi

firstj:=j:=(lxhashvalue iand hstmask)		!j=initial hash index

wrapped:=0

do
	lxsymptr:=lexhashtable[j]
	if lxsymptr=nil then				!unused entry, not found
		exit
	fi

	if lxsymptr^.namelen=length and memcmp(lxsymptr^.name,name,length)=0 then			!match
		return 1
	fi
!++NCLASHES

	if ++j>hstsize then		!wraparound
		if wrapped then
			println "???????HASHTABLE FULL",hstsize,lxlineno
			stop 1
		fi
		wrapped:=1
		j:=1
	fi
od

!name not found
if insource then
	name:=makestring(name,length)
fi

if lxsymptr=nil then
	lxsymptr:=pcm_allocz(strec.bytes)
	lexhashtable[j]:=lxsymptr
fi

!++NNAMES

lxsymptr^.name:=name
lxsymptr^.namelen:=length
lxsymptr^.symbol:=namesym
lxsymptr^.ksymbol:=0
lxsymptr^.htindex:=j
lxsymptr^.htfirstindex:=firstj
lxsymptr^.moduleno:=currmoduleno
return 0
end

global proc initsourcefile(ichar source)=
lxstart:=lxsptr:=cast(source)
lxlineno:=1
end

global function addnamestr(ichar name)ref strec=
!add a new name to the symbol table
!return symptr to new (or existing) generic name
lxhashvalue:=gethashvalue(name)
lookuplex(pcm_copyheapstring(name),0)
return lxsymptr
end

global proc lxerror(ichar m)=			!LXERROR

fprintln "\w\w Lexical Error\n*** # *** on line #",m,lxlineno

stop 1
end

!function gethashvalue(ref char s)int=
!int hsum, csum, c
!
!hsum:=
!
!while c:=s++^ do
!	csum+:=c
!	hsum:=hsum<<4-hsum + csum
!od
!return hsum<<5 ixor csum
!end

global function gethashvalue(ichar s)int=
!get identical hash function to that calculated by lexreadtoken
!but for a zero-terminated string
!ASSUMES S is lower-case, as conversion not done
int c,hsum

if s^=0 then return 0 fi

hsum:=s++^

do
	c:=s++^
	exit when c=0
	hsum:=hsum<<4-hsum+c
od
return hsum<<5-hsum
end

global proc skiptoeol=
!read lex tokens until eol and consume it
!return entire line as string
!note, exit with lxsptr pointing at the cr (or lf) char
repeat
	lex()
until lxsymbol=eolsym or lxsymbol=eofsym
END

function makestring(ichar p,int length)ref char=
!turn counted/non-terminated string from any source, into independent heap string
ref char s

s:=pcm_alloc(length+1)
memcpy(s,p,length)
(s+length)^:=0
return s
end
=== aa_common.m 67/77 ===
import msys
import clib
import mlib
import oslib

import aa_decls
import aa_tables
import aa_objdecls
import aa
import aa_lex
import aa_parse
import aa_writeobj
import aa_writeexe
import aa_writess
import aa_disasm
import aa_genss
import aa_lib
=== aa_objdecls.m 68/77 ===
import aa_decls

global record imagefileheader =
	word16	machine
	word16	nsections
	word32	timedatestamp
	word32	symtaboffset
	word32	nsymbols
	word16	optheadersize
	word16	characteristics
end

global record imagedir =
	word32	virtualaddr
	word32	size
end

global record optionalheader =			!exe/dll only
	word16  magic
	byte     majorlv
	byte     minorlv
	word32 codesize
	word32 idatasize
	word32 zdatasize
	word32 entrypoint
	word32 codebase
!	word32 datebase		!32-bit exe files only
	word64	imagebase
	word32 sectionalignment
	word32 filealignment
	word16  majorosv
	word16  minorosv
	word16  majorimagev
	word16  minorimagev
	word16  majorssv
	word16  minorssv
	word32 win32version
	word32 imagesize
	word32 headerssize
	word32 checksum
	word16  subsystem
	word16  dllcharacteristics
	word64   stackreserve
	word64   stackcommit
	word64   heapreserve
	word64   heapcommit
	word32 loaderflags
	word32 rvadims
	imagedir exporttable
	imagedir importtable
	imagedir resourcetable
	imagedir exceptiontable
	imagedir certtable
	imagedir basereloctable
	imagedir debug
	imagedir architecture
	imagedir globalptr
	imagedir tlstable
	imagedir loadconfigtable
	imagedir boundimport
	imagedir iat
	imagedir delayimportdescr
	imagedir clrheader
	imagedir reserved
end

global record imagesectionheader =
	[8]char name
	union
		word32	physical_address
		word32	virtual_size
	end
	word32	virtual_address
	word32	rawdata_size
	word32	rawdata_offset
	word32	relocations_ptr
	word32	linenos_offset
	word16	nrelocs
	word16	nlinenos
	word32	characteristics
end

global record imagesymbol =
	union
		[8]char shortname
		struct
			word32	shortx
			word32	longx
		end
		word64 longname
	end
	word32	value
	int16	sectionno
	word16	symtype
	byte	storageclass
	byte	nauxsymbols
end

global record importdirrec =
	word32	implookuprva
	word32	timedatestamp
	word32	fwdchain
	word32	namerva
	word32	impaddressrva
end

global record coffrelocrec =
	int32	virtualaddr
	int32	stindex
	int16	reloctype
end

global tabledata() [0:]ichar relocnames =
	(abs_rel = 0,	$),
	(addr64_rel,	$),
	(addr32_rel,	$),
	(addr32nb_rel,	$),
	(rel32_rel,		$),
	(rel321_rel,	$),
	(rel8_rel,		$),				!used within assembler only, not in coff format
end

global tabledata() [0:]ichar coffscopenames =
	(cofflocal_scope=0,	$),
	(export_scope,		$),
	(import_scope,		$),
end

global record auxsectionrec = 
	int32 length
	int16 nrelocs
	int16 nlines
	int32 checksum
	int16 sectionno
	int32 dummy
end

global record sectionrec =
	union
		ref dbuffer data		!copy of ss_zdata etc
		ref byte bytedata		!added later, eg, import dir block
	end
	ichar name					!name like ".bss" as it will be in obj/exe file
	int segtype					!code_seg etc
	int rawsize					!in file
	int rawoffset				!offset in exe file
	int virtsize				!in image
	int virtoffset				!offset from imagebase
	ref relocrec relocs			!for idata/code: reloc info needs to be processed
	int nrelocs					!
end

global record importrec = 		!details about all imported symbols
	ref strec def				!full st entry
	int libno					!which dll lib this belongs to
	ichar name					!name of symbol (extracted from lib.name if needed)
	int hintnameoffset			!voffset of hint/name entry in impdir section
	int iatoffset				!voffset of IAT entry
	int thunkoffset				!offset within code section of thunk entry
end

global record exportrec = 		!details about all exported symbols
	ref strec def				!full st entry
	ichar name					!name of symbol (extracted from lib.name if needed)
end

global record dllrec =			!all imported libraries
	ichar name					!name of library, including .dll
	int nprocs					!no. of imports which use this library
	int nametableoffset			!start of name table in impdir
	int addrtableoffset			!start of addr table (IAT)
	int dllnameoffset			!offset of name within impdir
	int dllextraoffset			!offset of mysterious region just before the name
end

global record exportdirrec =
	word32 exportflags
	word32 timedatestamp
	word16 majorversion
	word16 minorversion
	word32 namerva
	word32 ordinalbase
	word32 naddrtable
	word32 nnamepointers
	word32 expaddressrva
	word32 namepointerrva
	word32 ordtablerva
end

=== aa.m 69/77 ===
!mapmodule ax_writeexe=>ax_writeexe_dummy
!mapmodule ax_writeexe=>ax_writedll

!import msys
import* aa_common
!import msys
!import clib
!import mlib
!import oslib
!
!import aa_decls
!import aa_tables
!import aa_objdecls
!import aa
!import aa_lex
!import aa_parse
!import aa_writeobj
!import aa_writeexe
!import aa_writess
!import aa_disasm
!import aa_genss
!import aa_lib

global int logdest=0			!no diagnostic output

byte fshowmcl
byte fshowss
byte fshowsx
byte fshowtiming

tabledata() []ichar optionnames=
	(lex_sw,		"lex"),		!first four must be in this order
	(parse_sw,		"parse"),
	(gen_sw,		"gen"),
	(obj_sw,		"obj"),
	(dll_sw,		"dll"),
	(exe_sw,		"exe"),

	(mcl_sw,		"mcl"),
	(ss_sw,			"ss"),
	(sx_sw,			"sx"),
	(time_sw,		"time"),
	(s_sw,			"s"),
	(d_sw,			"d"),
	(v_sw,			"v"),
	(q_sw,			"q"),
	(help_sw,		"help"),
	(out_sw,		"out"),
	(main_sw,		"main"),
	(start_sw,		"start"),
end

int axlevel = exe_sw

const logfile = "mx.log"

ichar inputfile
ichar outputfile

proc start=
ref strbuffer ss
int ntokens,t,i,U,j
CPL =MCLREC.BYTES


!for i:=r0 to r19 do
!!	j:=regcodes[i]
!	for size:=1 to 8 when size in [1,2,4,8] do
!		if i>r15 and size>1 then next fi
!!		print strreg(j,size):"5"
!		print getregname(i,size):"5"
!	od
!	println
!od
!STOP


T:=CLOCK()
initall()

getinputoptions()

inputfile:=moduletable[1].filename

initlogfile()

if axlevel=lex_sw then
	if nmodules>1 then loaderror("lex test/multi files") fi
	lextest(inputfile)
else
	if outputfile=nil then
		outputfile:=pcm_copyheapstring(changeext(inputfile,
			(axlevel=exe_sw|"exe"|(axlevel=dll_sw|"dll"|"obj"))))
	fi

	if not fquiet then
		if axlevel=obj_sw then
			println "Assembling",inputfile,"to",outputfile
		else
			println "Assembling/linking to",outputfile
		fi
	fi

	if fverbose then
		showcaption()
		println
	fi
!CPL "LOADING"
	loadsourcefiles()
!CPL "PARSING"
	parsemodules()

!CPL "GENSS"
!CPL "AX1"
	genss()
!CPL "AX2"
	case axlevel
	when obj_sw then
		if fshowss or fshowsx then
			initsectiontable()					!need for display
			ss:=writessdata(0)
			gs_println(ss,logdev)
		fi

		writess(outputfile)
	when exe_sw, dll_sw then
!CPL "MAKE EXE/DLL"
		initsectiontable()
		if fshowss then
			ss:=writessdata(0)
			gs_println(ss,logdev)
		fi

!CPL "AX1"
		genexe(nil,outputfile, axlevel=dll_sw)
!CPL "AX2"
		if fshowsx then
			ss:=writessdata(1)
			gs_println(ss,logdev)
		fi
!CPL "AX3"

		writeexe(outputfile, axlevel=dll_sw)
!CPL "AX4"
!	when dll_sw then
!CPL "AX3"
!		initsectiontable_dll()
!CPL "AX4"
!		if fshowss then
!			ss:=writessdata(0)
!			gs_println(ss,logdev)
!		fi
!CPL "AX5"
!
!		gendll(nil)
!CPL "AX6"
!		if fshowsx then
!			ss:=writessdata(1)
!			gs_println(ss,logdev)
!		fi
!CPL "AX7"
!
!		writeexe(outputfile)
!CPL "AX8"
	esac

	if fshowmcl then
		ss:=writemclblock()
		gs_println(ss,logdev)
	fi
fi

if fshowtiming then
	T:=CLOCK()-T
	CPL "Time",T
fi

closelogfile()
stop 0
end

proc loadsourcefiles=
	int i
	ichar source

	for i to nmodules do
		source:=cast(readfile(moduletable[i].filename))
		if source=nil then
			loaderror_s("Can't load file: %s",moduletable[i].filename)
		fi
		moduletable[i].source:=source
	od
end

proc parsemodules=
	int i
	ichar source

	for i to nmodules do
		currmoduleno:=i
		modulenamelist:=nil
		readmodule(i)

		checkundefined()
		if nundefined then
			println "Couldn't assemble - press key"
			os_getch()
			stop 1
		fi

		scanglobals()			!fixup any globals and imports
		if fshowsx then
!			printmodulesymbols(logdev)
		fi
if i<>nmodules then
		resethashtable()
fi
	od

if fshowsx then
!	printimportsymbols(logdev)
!	printdupltable(logdev)
fi

!Try scanning all mclcode to fix imports/exports. That is, all operands
!point to the same st entry
ref mclrec m

m:=mccode

while m do
	fixopnd(m^.a)
	fixopnd(m^.b)
	m:=m^.nextmcl
od

end

proc fixopnd(ref opndrec a)=
ref strec d
if a=nil then return fi
if a^.labeldef then
	d:=a^.labeldef
	if d^.basedef then
		a^.labeldef:=d^.basedef
	fi
fi
end

proc initlogfile=
case logdest
when 2 then
	remove(logfile)
	logdev:=cast(fopen(logfile,"w"))
when 0,1 then
	logdev:=nil
esac

end

proc closelogfile=			!CLOSELOGFILE
[512]char str

if logdest=2 then
	fclose(logdev)

	print @&.str,f"\m\ed.bat",logfile

	os_execwait(&.str,1,nil)
fi
end

proc initall=
pcm_init()
initlex()
initlib()
end

proc lextest(ichar file)=
!STATIC [0..SYMBOLNAMES.LEN]INT HIST


	loadsourcefiles()
	initsourcefile(moduletable[1].source)

	lxsymbol:=eolsym
!CPL "LEXTEST"
!INT NSYMBOLS
	while lxsymbol<>eofsym do
!++NSYMBOLS
!++HIST[LXSYMBOL]
!
		lex()
	od

!CPL =NSYMBOLS
!FOR I IN HIST.BOUNDS WHEN HIST[I] DO
!	CPL SYMBOLNAMES[I],":",HIST[I]
!OD 
end

proc getinputoptions=
const slash='-'
int i,j,k
int paramno,pmtype,sw
ichar name,value,ext

paramno:=2

while pmtype:=nextcmdparam(paramno,name,value,".asm") do
	case pmtype
	when pm_option then
		convlcstring(name)
		for sw to optionnames.len do
			if eqstring(name,optionnames[sw]) then
				do_option(sw,value)
				exit
			fi
		else
			println "Unknown option:",name
			stop 1
		od
	when pm_sourcefile then
		addmodule(name)
	when pm_libfile then
		addsearchlib(name)
	esac
od

if nmodules=0 and nsearchlibs=0 then
	showcaption()
	println
	println "Usage:"
	println "	",,sysparams[1],"filename[.asm]           # Assemble filename.asm to filename.exe"
	println "	",,sysparams[1],"-help                    # Show other options"
	stop 1
fi

if fshowss or fshowsx or fshowmcl then
	if logdest=0 then logdest:=2 fi
fi


!if nsearchlibs=0 then
!	searchlibs[1]:="msvcrt"
!	searchlibs[2]:="gdi32"
!	searchlibs[3]:="user32"
!	searchlibs[4]:="kernel32"
!	nsearchlibs:=4	
!fi
addsearchlib("msvcrt")
addsearchlib("gdi32")
addsearchlib("user32")
addsearchlib("kernel32")

!
!FOR I TO NSEARCHLIBS DO
!	CPL I,SEARCHLIBS[I]
!OD


if nmodules=0 then
	loaderror("No input files specified")
fi
end

proc do_option(int sw, ichar value)=

case sw
when lex_sw, parse_sw, gen_sw, obj_sw, exe_sw, dll_sw then
	axlevel:=sw
when mcl_sw then
	fshowmcl:=1
when ss_sw then
	fshowss:=1
when sx_sw then
	fshowsx:=1
when time_sw then
	fshowtiming:=1
when s_sw then
	logdest:=1
when d_sw then
	logdest:=2
when v_sw then
	fverbose:=1
when q_sw then
	fquiet:=1
when help_sw then
	showhelp()
when out_sw then
	outputfile:=pcm_copyheapstring(value)
when main_sw then
when start_sw then
!	entrypointname:="start"
esac

end

proc showhelp=
showcaption()
println
println strinclude "help.txt"
stop 1
end

proc showcaption=
print "AX Assembler/Linker",$date
end

proc loaderror(ichar mess)=
println "Error:",mess
stop 1
end

proc loaderror_s(ichar mess,s)=
[256]char str
sprintf(&.str,mess,s)
loaderror(&.str)
end

proc addmodule(ichar name)=
if nmodules>=maxmodules then
	loaderror("Too many modules")
fi
++nmodules
moduletable[nmodules].filename:=pcm_copyheapstring(name)
moduletable[nmodules].name:=pcm_copyheapstring(extractfile(name))
moduletable[nmodules].source:="<empty>"

end

proc addsearchlib(ichar name)=
[300]char str

name:=changeext(name,"")

for i to nsearchlibs do
	if eqstring(searchlibs[i],name) then return fi
od

if nsearchlibs>=maxsearchlibs then
	loaderror("Too many libraries")
fi
++nsearchlibs
searchlibs[nsearchlibs]:=pcm_copyheapstring(name)
end

proc showmodules=
	int i
	println "Modules:",nmodules
	for i:=1 to nmodules do
		println "  ",i,,":",
			padstr(moduletable[i].name,13),
			padstr(moduletable[i].filename,25),
			strlen(moduletable[i].source)
	od
	println
	println "Search Libs:",nsearchlibs
	for i:=1 to nsearchlibs do
		println "  ",i,,":",searchlibs[i]
	od
	println
end

function getemptyst(ref strec d)ref strec=
!d is an existing strec
!create an new empty strec if needed (when d is also keyword name,
! and/or e is not nil), and return a pointer to that
!otherwise just return nil
ref strec dnew

if d^.ksymbol then					!need a replacement strec
	dnew:=pcm_allocz(strec.bytes)
	dnew^.name:=d^.name
	dnew^.namelen:=d^.namelen
	dnew^.ksymbol:=d^.ksymbol
	dnew^.subcode:=d^.subcode
	dnew^.regsize:=d^.regsize
	return dnew
fi
return nil
end

function findduplname(ref strec d)ref strec=
!look for any dupl global/export name to d

ref strec e
if d^.basedef then
	return d^.basedef
fi

e:=dupltable[d^.htfirstindex]

while e do
	if d^.namelen=e^.namelen and memcmp(d^.name,e^.name,d^.namelen)=0 then
		d^.basedef:=e
		return e
	fi
	e:=e^.nextdupl
od
return nil
end

proc adddupl(ref strec d)=
!add the first dupl entry for d in dupltable
!the linked list is in reverse order, and generally ends up containing
!one element unless there are two or more names that share the same default
!hash table entry

d^.nextdupl:=dupltable[d^.htfirstindex]
dupltable[d^.htfirstindex]:=d
end

proc scanglobals=
!have just finished parsing a module
!scan the symbols defined there to:
! * find any new imports/globals
! * find new imports/globals to merge with existing ones
!Then the entries in the hashtable must be purged, by substituting with
!either nil, or an empty value if keyword data or .basedef must be remembered

ref strec d,e

d:=modulenamelist

while d do
	case d^.symbol
	when importedsym then
		e:=findduplname(d)
		if e then
			case e^.symbol
			when importedsym then			!no change
			when exportedsym then
				d^.symbol:=exportedsym		!set both global
				d^.reftype:=e^.reftype:=fwd_ref
			esac
		else
			addimport(d)
			adddupl(d)
		fi
	when exportedsym then
		e:=findduplname(d)
		if e then
			case e^.symbol
			when importedsym then
				e^.symbol:=exportedsym		!set both global
				d^.reftype:=e^.reftype:=fwd_ref
			when exportedsym then			!error?
CPL MODULETABLE[D^.MODULENO].NAME,D^.NAME,D^.HTINDEX
CPL MODULETABLE[E^.MODULENO].NAME,E^.NAME,E^.HTINDEX
				serror_s("Multiply-defined global: %s",d^.name)
			esac
		else
			e:=d
			addimport(d)
			adddupl(d)
		fi
	esac

	d:=d^.nextdef
od
end

proc resethashtable=
!have just finished parsing a module
!scan the symbols defined there to:
! * find any new imports/globals
! * find new imports/globals to merge with existing ones
!Then the entries in the hashtable must be purged, by substituting with
!either nil, or an empty value if keyword data or .basedef must be remembered

ref strec d,e

d:=modulenamelist

while d do
	lexhashtable[d^.htindex]:=getemptyst(d)
	d:=d^.nextdef
od

modulenamelist:=nil

end
=== help.txt 70/77 ===
'AA' Assembler-Linker for Win64

Assembles ASM files written in a special syntax to OBJ or EXE or DLL format.

Usage:

	aa prog            Assemble prog.asm to prog.exe
	aa prog -dll       Assemble prog.asm to prog.dll
	aa prog -obj       Assemble prog.asm to prog.obj (needs ext. linker)

	aa a b c           Assemble&link modules a.asm, b.asm, c.asm into a.exe

Options:

	-out:file          Name output file (default is .exe applied to 1st module)
	-out:exe           Generate executable (default)
	-out:obj           Generate object file (one .obj file for multiple i/p files)
	file.dll           Include library in list of DLLs to search

	@file              Read options and files from @ file

Can only link to external DLL libraries; not other .o/.obj/.lib/.a files.

DLLs msvcrt.dll, user32.dll, gdi32.dll, user32.dll are automatically included.
=== aa_parse.m 71/77 ===
import* aa_common

ref strec exprlabeldef
int64 exprvalue
int exprtype

global proc readmodule(int moduleno)=
ref strec symptr
int sym

initsourcefile(moduletable[moduleno].source)

lxsymbol:=eolsym

genmc(m_segment,genint(code_seg))

while lxsymbol=eolsym do

	lex()

	switch lxsymbol
	when kopcodesym then
!CPL "OPCODE"
		readinstr()

	when namesym then
		symptr:=lxsymptr
		lex()
		sym:=lxsymbol
		case sym
		when eqsym then
			lex()
!PS("AFTER EQ")
			case lxsymbol
			when kregsym then
				createregalias(symptr,lxsymptr.subcode, lxsymptr.regsize)
				lex()
			when kxregsym then
				createxregalias(symptr,lxsymptr.subcode)
				lex()
			else
				createnamedconst(symptr,readexpression())
			esac

		when colonsym,dcolonsym then
			createlabel(symptr,(sym=colonsym|localsym|exportedsym))
			genmc(m_label, genlab(symptr))
			symptr^.reftype:=fwd_ref
			lxsymbol:=eolsym
			redo
		else
			println symptr^.name
			serror("colon expected after label")
		esac

	when fwdlocalsym then
		symptr:=lxsymptr
		lex()
		case lxsymbol
		when eqsym then
			serror_s("Redefining label as const: %s",symptr^.name)
		when colonsym,dcolonsym then
			symptr^.fwdrefs:=nil
			genmc(m_label, genlab(symptr))
			symptr^.symbol:=(lxsymbol=colonsym|localsym|exportedsym)
			symptr^.reftype:=fwd_ref
			lxsymbol:=eolsym
			redo
		else
			serror("Instruction expected")
		esac

	when importedsym then
		serror_s("Defining imported name: %s",symptr^.name)
	when localsym, exportedsym then
		serror_s("Redefining symbol: %s",symptr^.name)
	when namedconstsym then
		serror_s("2:Const redefined: %s",symptr^.name)

	when kjmpccsym then
		readcondinstr(m_jmpcc)

	when ksetccsym then
		readcondinstr(m_setcc)

	when kmovccsym then
		readcondinstr(m_cmovcc)

	when eolsym then			!blank or comment line
	when eofsym then
!		println "EOF"
		return
	else
		println "Unknown symbol:",symbolnames[lxsymbol]
	end switch
od
serror("EOL expected")
end

global proc checkundefined=
int i
ref strec d

d:=modulenamelist
while d do
	if d^.symbol=fwdlocalsym then
		println "Undefined:",padstr(d^.name,20)
		++nundefined
	fi
	d:=d^.nextdef
od
end

proc checksymbol(int symbol)=
[265]char str

if lxsymbol<>symbol then
	fprint @&.str,"# expected not #",symbolnames[symbol],symbolnames[lxsymbol]

	serror(&.str)
fi
end

proc readinstr=
!deal with opcode symbol
int opcode
ref opndrec a,b,c

	opcode:=lxsubcode

!CPL "READINSTR"

	lex()

	switch opcode
	when m_db, m_dw, m_dd, m_dq, m_ddoffset then
		do
			if lxsymbol=stringconstsym then
				a:=genstrimm(lxsvalue)
				lex()
				genmc(opcode,a)
			else
				a:=readoperand()
				genmc(opcode,a)
			fi
			if lxsymbol=commasym then
				lex()
			else
				exit
			fi
		od
	when m_segment then
		checksymbol(ksegnamesym)
		genmc(m_segment,genint(lxsubcode))
!		currseg:=lxsubcode					!used to assign segments to labels
		lex()

	when m_isegment then
		genmc(m_segment, genint(idata_seg))
	when m_zsegment then
		genmc(m_segment, genint(zdata_seg))
	when m_csegment then
		genmc(m_segment, genint(code_seg))

	when m_imul3 then
		a:=readoperand()
		checksymbol(commasym)
		lex()
		b:=readoperand()
		checksymbol(commasym)
		lex()
		c:=readoperand()
		SERROR("IMUL3 CAN'T DO 3 OPNDS")

	when m_pcmpistri,m_pcmpistrm then
		a:=readoperand()
		checksymbol(commasym)
		lex()
		b:=readoperand()
		checksymbol(commasym)
		lex()
		c:=readoperand()
		if c.mode<>a_imm then serror("pcmpistr/not int") fi
!		genmc(opcode,a,b,c)
!		SERROR("PCMPISTRI??")
		genmc(opcode,a,b)
		mccodex.c:=c.value

	when m_proc then
		repeat
			lex()
		until lxsymbol=eolsym

!	when m_call then
!		a:=readoperand()
!		if a.mode=a_imm then
!			genmc(opcode,a)
!		else
!			genmc(m_call2,a)
!		fi
	else
!CPL "HERE"
		a:=b:=nil
		if lxsymbol<>eolsym then
			a:=readoperand()
!CPL "DONE READ OPND",a
!PS("KKK")
			if lxsymbol=commasym then
!CPL "TRY 2ND OPND"
				lex()
				b:=readoperand()
			fi
		fi 

		genmc(opcode,a,b)
!cpl "DONE OPCODE"
	end

end

proc readcondinstr(int opc)=
ref opndrec a,b

a:=genint(lxsubcode)
lex()
b:=readoperand()

if lxsymbol=commasym and opc=m_cmovcc then		!ignore dest
	genmc(m_param,b)							!store extra param as separate instr

	lex()
	b:=readoperand()
fi

genmc(opc,a,b)
end

function readoperand:ref opndrec=
!position at start of operand
!read reg, expression or complex operand, and return an opndrec
ref opndrec p
int size

	switch lxsymbol
	when kregsym then
!CPL "READOPND REG",LXSYMPTR.NAME, =LXSYMPTR, LXSUBCODE, =LXSYMPTR.SUBCODE, LXSYMPTR.REGSIZE
		p:=regtable[lxsubcode, lxsymptr^.regsize]
		lex()
!CPL "DONE",=P
		return p
	when lsqsym then
		lex()
		return readaddrmode(0)
	when kxregsym then
		p:=genxreg(lxsubcode)
		lex()
		return p
	when kprefixsym then
		size:=lxsubcode
		lex()
		checksymbol(lsqsym)
		lex()
		return readaddrmode(size)

	else
		return readexpression()
	end
	return nil
end

function readexpression:ref opndrec=
ref strec labelx
int64 valuex
int typex

	readterm()

	docase lxsymbol
	when addsym then
		labelx:=exprlabeldef
		valuex:=exprvalue
		typex:=exprtype
		lex()
		readterm()
		if exprlabeldef then serror("+label?") fi
		exprlabeldef:=labelx
		if typex or exprtype then serror("add real") fi
		exprvalue+:=valuex

	when subsym then
		labelx:=exprlabeldef
		valuex:=exprvalue
		typex:=exprtype
		lex()
		readterm()
		if exprlabeldef then serror("+label?") fi
		exprlabeldef:=labelx
		if typex or exprtype then serror("sub real") fi
		exprvalue:=valuex-exprvalue
	else
		exit
	end

	return genimm_expr(exprlabeldef,exprvalue,exprtype)
end

proc readterm=
!read term into exprlabeldef/exprvalue
ref strec symptr
real x
	exprlabeldef:=nil
	exprvalue:=0
	exprtype:=0

	switch lxsymbol
	when fwdlocalsym, localsym, exportedsym then
		exprlabeldef:=lxsymptr
		lex()
		if lxsymbol=mulsym then		!is extern name
			serror("* applied to non-extern label or applied inconsistently")
		fi

	when importedsym then
		exprlabeldef:=lxsymptr
		lex()
		if lxsymbol<>mulsym then		!is extern name
			serror("* missing or applied inconsistently")
		fi
		lex()

	when namedconstsym then
		exprlabeldef:=lxsymptr^.expr^.labeldef
		exprvalue:=lxsymptr^.expr^.value
		exprtype:=lxsymptr^.expr^.valtype

!		p:=lxsymptr^.value
		lex()
	when namesym then
		symptr:=lxsymptr
		exprlabeldef:=symptr
		lex()
		if lxsymbol=mulsym then		!is extern name
			createlabel(symptr,importedsym)
			lex()
		else
			createlabel(symptr,fwdlocalsym)
		fi

	when intconstsym then
		exprvalue:=lxvalue
		lex()
	when realconstsym then
		exprvalue:=int64@(lxxvalue)
		exprtype:='R'
		lex()

	when subsym then
		lex()
		readterm()
		if not exprlabeldef then
			if not exprtype then
				exprvalue:=-exprvalue
			else
				x:=-(real@(exprvalue))
				exprvalue:=int64@(x)
			fi
		else
			serror("neg/label")
		fi
	when addsym then
		lex()
		readterm()

	else
		serror("READTERM")
	end
end

proc readreg(int &reg,&regsize,&scale)=
!positioned at reg symbol
!read R or R*n for address mode
!return (reg, regsize, scale); scale is 0 when no *n

reg:=lxsubcode
regsize:=lxsymptr^.regsize
lex()
if lxsymbol=mulsym then
	lex()
	checksymbol(intconstsym)
	case lxvalue
	when 1,2,4,8 then
	else
		serror("*n must be 1,2,4,8")
	esac
	scale:=lxvalue
	lex()
else
	scale:=0
fi
end

function readaddrmode(int size)ref opndrec=
![" just seen, positioned at next symbol
!syntax: [Reg+Reg*scale+expr], all items optional, but at least one must be present
!read optional reg, index reg, scale factor, label, and offset
!size is 0, or is 1,2,4,8 when an override was used
int reg,regsize,scale,regix, addrsize, regixsize, scaleix
ref opndrec x
ref opndrec p

reg:=regix:=0
regsize:=regixsize:=0
scale:=scaleix:=0
x:=nil

if lxsymbol=kregsym then
	readreg(reg,regsize,scale)	
!	n:=1
	case lxsymbol
	when addsym then
		lex()
		if lxsymbol=kregsym then
			readreg(regix,regixsize,scaleix)	

			case lxsymbol
			when addsym,subsym then
				x:=readexpression()
			esac

		else
			x:=readexpression()
		fi
	when subsym then
		x:=readexpression()
	esac
else
	x:=readexpression()
fi

if scale and scaleix then serror("Two *N scales") fi
!if reg=0 and regix=0 and 0 then	serror("Empty address mode") fi
checksymbol(rsqsym)
lex()

if scale and not scaleix then
	swap(reg,regix)
	swap(regsize,regixsize)
	swap(scale,scaleix)
fi
if scaleix=0 then scaleix:=1 fi

if regsize and regixsize and regsize<>regixsize then serror("Addr reg size mismatch") fi

p:=genindex(areg:reg, ireg:regix, scale:scaleix, x:x, size:size,
	addrsize:(regsize=4 or regixsize=4|4|8))
return p
end
=== aa_writeobj.m 72/77 ===
!NEEDS REVISING TO MATCH UNLIMITED SS_SYMBOLTABLE size used for EXE
!and also unlimited strings

import* aa_common
int symtaboffset

ref byte datastart
ref byte dataptr

[0..10'000]imagesymbol symboltable

int nsymbols

int stoffset=0				!usually +7 to convert ss_symboltable indices to symboltable

const maxstring=5000
[maxstring]ichar stringtable
[maxstring]int stringlengths
int nextstringoffset=0
int nstrings=0

global proc writess(ichar outfile)=
	writecoff(outfile)
end

proc writerecord(ref void r, int length)=
	memcpy(dataptr,r,length)
	dataptr+:=length
end

proc writerelocs(ref relocrec r,int nrelocs)=
	static coffrelocrec s
	ref strec d

	return when nrelocs=0

	while r do
		case r^.reloctype
		when addr32_rel, addr64_rel then		!change to section entry
			d:=ss_symboltable^[r^.stindex]

			case d^.segment
			when zdata_seg then s.stindex:=2
			when idata_seg then s.stindex:=4
			when code_seg then s.stindex:=6
			when 0 then							!external; leave stindex pointing to symbol
				s.stindex:=r^.stindex+stoffset
			else
				gerror("wrelocs/bad seg")
			esac

		else
			s.stindex:=r^.stindex+stoffset
		esac

		s.reloctype:=r^.reloctype
		s.virtualaddr:=r^.offset


		memcpy(dataptr,&s,s.bytes)
		dataptr+:=s.bytes

		r:=r^.nextreloc
	od
end

proc writedata(ref dbuffer data)=
	memcpy(dataptr, bufferelemptr(data,0), bufferlength(data))
	dataptr+:=bufferlength(data)
end

proc writesymboltable=
	int i
	for i:=1 to nsymbols do
		writerecord(&symboltable[i],imagesymbol.bytes)
	od
end

proc writestringtable=
!should immediately follow symboltable
	ref int32 p
	int i,n

	p:=cast(dataptr)
	p^:=nextstringoffset
	dataptr+:=4

	for i to nstrings do
		n:=stringlengths[i]+1
		memcpy(dataptr,stringtable[i],n)
		dataptr+:=n
	od
end

function makesymbol(ichar name,int namelen=0, value=0, sectionno=0,symtype=0,storage=0,naux=0)ref imagesymbol=
	static imagesymbol r
	int length

	if namelen=0 then namelen:=strlen(name) fi

	if namelen<8 then
		strcpy(&r.shortname[1],name)
	elsif namelen=8 then
		memcpy(&r.shortname[1],name,namelen)
	else
		r.shortx:=0
		r.longx:=addstringentry(name,namelen)
	fi
	r.value:=value
	r.sectionno:=sectionno
	r.symtype:=symtype
	r.storageclass:=storage
	r.nauxsymbols:=naux
	return &r
end

proc addsymbol(ref imagesymbol r)=
	if nsymbols>=symboltable.len then
		gerror("as:Too many symbols")
	fi
	memcpy(&symboltable[++nsymbols],r,r^.bytes)
end

proc initsymboltable(ichar filename)=
!add first few special symbols to coff symboltable
	nsymbols:=0

	addsymbol(makesymbol(".file",storage:103, sectionno:-2,naux:1))
	addsymbol(strtoaux(filename))

	addsymbol(makesymbol(".bss", storage:3, sectionno:1, naux:1))
	addsymbol(cast(sectiontoaux(nil, 0)))

	addsymbol(makesymbol(".data", storage:3, sectionno:2, naux:1))
	addsymbol(cast(sectiontoaux(ss_idata, ss_nidatarelocs)))

	addsymbol(makesymbol(".text", storage:3, sectionno:3, naux:1))
	addsymbol(cast(sectiontoaux(ss_code, ss_ncoderelocs)))
end

function strtoaux(ref char s)ref imagesymbol=
!turn string s into 18-byte imagesymbol record
	static imagesymbol r
	ref byte p:=cast(&r)
	int n

	memset(p,0,r.bytes)
!	clear p^

	n:=0
	while s^<>0 and n<r.bytes do
		p++^:=s++^
		++n
	od

	return &r
end

function sectiontoaux(ref dbuffer data, int nrelocs)ref auxsectionrec=
!!turn segment into into aux section/reloc entry for symboltable
	static auxsectionrec r

	memset(&r,0,r.bytes)
!	clear r

	if data=nil then			!zdata
		r.length:=ss_zdatalen
	else
		r.length:=bufferlength(data)

	fi
	r.nrelocs:=nrelocs
	return &r
end

function addstringentry(ichar s, int length)int=
!assume s is longer than 8 chars
!add string table entry, return offset to string, as it would be in the coff string table
!assume s in stable memory so doesn't need copying
	int offset

	offset:=nextstringoffset
	if nstrings>maxstring then
		gerror("W:too many strings")
	fi
	stringtable[++nstrings]:=s
	stringlengths[nstrings]:=length

	nextstringoffset+:=length+1

	return offset
end

proc convertsymboltable=
!scan ss_symboltable and generate coff symboltable equivalents
	ref strec s
	ichar name
	int i,sect, scope

	stoffset:=nsymbols-1

	nstrings:=0
	nextstringoffset:=4

	for i to ss_nsymbols do
		s:=ss_symboltable^[i]

		name:=s^.name

		case s^.segment
		when zdata_seg then sect:=1
		when idata_seg then sect:=2
		when code_seg then sect:=3
		else sect:=0
		esac

		case s^.symbol
		when fwdlocalsym,localsym then
			scope:=3
		when importedsym,exportedsym then
			scope:=2
		else
			scope:=0
		esac

		addsymbol(makesymbol(s^.name,s^.namelen,sectionno:sect, storage:scope, value:s^.offset))

	od
end

proc writecoff(ichar outfile)=
	imagefileheader header
	imagesectionheader zsection, isection, csection
	int offset
	int64 aa

	memset(&header,0,header.bytes)
	memset(&zsection,0,imagesectionheader.bytes)
	memset(&isection,0,imagesectionheader.bytes)
	memset(&csection,0,imagesectionheader.bytes)

!	clear header
!	clear zsection
!	clear isection
!	clear csection


	header.machine:=0x8664
	header.nsections:=3

	strcpy(&zsection.name[1],".bss")
	zsection.rawdata_size:=ss_zdatalen

	zsection.characteristics:=0xC040'0080

	if ss_nidatarelocs>=65536 or ss_ncoderelocs>=65536 then
		gerror("Too many relocs (exceeds 16-bit field)")
	fi

	strcpy(&isection.name[1],".data")
	isection.rawdata_size:=bufferlength(ss_idata)
	isection.nrelocs:=ss_nidatarelocs

	isection.characteristics:=0xC050'0040

	strcpy(&csection.name[1],".text")
	csection.rawdata_size:=bufferlength(ss_code)
	csection.nrelocs:=ss_ncoderelocs

	csection.characteristics:=0x6050'0020

	initsymboltable(outfile)

	convertsymboltable()

	offset:=imagefileheader.bytes

	offset+:=imagesectionheader.bytes*3

	if isection.nrelocs then
		isection.relocations_ptr:=offset
		offset+:=isection.nrelocs*coffrelocrec.bytes
	fi

	if csection.nrelocs then
		csection.relocations_ptr:=offset
		offset+:=csection.nrelocs*coffrelocrec.bytes
	fi

	isection.rawdata_offset:=offset
	offset+:=isection.rawdata_size

	csection.rawdata_offset:=offset
	offset+:=csection.rawdata_size

!create symbol table and string table

	header.symtaboffset:=offset
	offset+:=nsymbols*imagesymbol.bytes
	header.nsymbols:=nsymbols

	offset+:=nextstringoffset

!Allocate data block in memory for coff image
	datastart:=dataptr:=malloc(offset)

	writerecord(&header,header.bytes)
	writerecord(&zsection,zsection.bytes)

	writerecord(&isection,isection.bytes)
	writerecord(&csection,csection.bytes)
	writerelocs(ss_idatarelocs,ss_nidatarelocs)
	writerelocs(ss_coderelocs,ss_ncoderelocs)

	writedata(ss_idata)
	writedata(ss_code)

	writesymboltable()
	writestringtable()

	if fverbose then
		println "Writing file:",outfile
	fi
	writefile(outfile,datastart,dataptr-datastart)

end

=== aa_writeexe.m 73/77 ===
!Create .exe file from SS-data (code, data, reloc and symbol tables)
!Call order::
! initsectiontable()
! genexe()
! writeexe(filename)

import* aa_common

[maxsearchlibs]int64 libinsttable
[maxsearchlibs]ichar libinstnames
[maxsearchlibs]int libnotable			!index into dlltable

global const zsect=3
global const dsect=2
global const csect=1
global const isect=4

record basereloc =
	ref basereloc nextitem
	word32 address				!virtual address
	int32 reloctype
end

ref basereloc basereloclist
int nbaserelocs
int maxrelocaddr
const maxbaseblock=500
[maxbaseblock]int blockbases
[maxbaseblock]int32 blockcounts
[maxbaseblock]int32 blockbytes
[maxbaseblock]byte blockpadding
int nbaseblocks
int basetablesize

const filealign = 512
const sectionalign = 4096
const exe_imagebase = 0x40'0000
!const dll_imagebase = 0x1000'0000
const dll_imagebase = 0x6624'0000
!global int imagebase
global word imagebase

int imagesize
int filesize
ref[]int64 thunktable				!point into code segment
int fileiatoffset
int fileiatsize
ref strec stentrypoint				!symbol to be the entry point
ref strec stentrypoint2
ref strec stentrypoint3

const maxsection = 10
global [maxsection]sectionrec sectiontable
global int nsections

ref byte importdir				!allowed section data for import directort in .idata

global const maximports = 3000
global [maximports]importrec importtable
global int nimports

!global const maxexports = 3000
global const maxexports = 12000
global [maxexports]exportrec exporttable
global int nexports
ichar dllfilename
int isdll

global const maxlibs = 50
global [maxlibs]dllrec dlltable
global int ndlls

global ref byte datastart
global ref byte dataptr
global ichar userentrypoint

int exportdirvirtaddr
int exportdirvirtsize
int exportdiroffset				!from start of imp dir

int blockdirvirtaddr
int blockdirvirtsize
int blockdiroffset


global proc writeexe(ichar outfile, int dodll)=
	imagefileheader header
	optionalheader optheader
	int offset,i
	int64 aa

	dllfilename:=outfile
	isdll:=dodll

	datastart:=dataptr:=pcm_allocz(filesize)

	writedosstub()
	writepesig()
	writefileheader()
	writeoptheader()
	for i to nsections do
		writesectionheader(&sectiontable[i])
	od
	writepadding(sectiontable[1].rawoffset)
	for i to nsections do
		writesectiondata(&sectiontable[i])
	od

!println =filesize, =dataptr-datastart			!these should match

	if fverbose then
		CPL "Writing file:",outfile
	fi

	if writefile(outfile,datastart,dataptr-datastart)=0 then
		println "Error writing exe file (possibly still running)"
		stop 1
	fi
end

global proc genexe(ichar entrypoint, outfile, int dodll)=
!manipulate the ss data to fill in all the details needed for exe format

	dllfilename:=outfile
	isdll:=dodll

	imagebase:=(isdll|dll_imagebase|exe_imagebase)

	userentrypoint:=entrypoint
	loadlibs()
	scanst()				!build dll/import tables

	getoffsets()
	relocdata(&sectiontable[csect])
	relocdata(&sectiontable[dsect])
end

proc loadlibs=
!load library instances
	int i
	int64 hinst
	ichar file
	[300]char filename

	for i to nsearchlibs do
		strcpy(&.filename,searchlibs[i])
		strcat(&.filename,".dll")
		hinst:=os_getdllinst(&.filename)
		if hinst=0 then
			cpl searchlibs[i]
			cpl &.FILENAME
			gerror("Can't load search lib")
		fi
		libinsttable[i]:=hinst
		libinstnames[i]:=pcm_copyheapstring(&.filename)
	od
end

global proc initsectiontable=
!set up the section table

	sectiontable[csect].name:=".text"
	sectiontable[csect].segtype:=code_seg
	sectiontable[csect].data:=ss_code
	sectiontable[csect].virtsize:=bufferlength(ss_code)

	if bufferlength(ss_idata)=0 then
		addqword (ss_idata,0)
	fi

	sectiontable[dsect].name:=".data"
	sectiontable[dsect].segtype:=idata_seg
	sectiontable[dsect].data:=ss_idata

	sectiontable[dsect].virtsize:=bufferlength(ss_idata)
	sectiontable[dsect].rawsize:=roundtoblock(sectiontable[dsect].virtsize,filealign)
	sectiontable[dsect].nrelocs:=ss_nidatarelocs
	sectiontable[dsect].relocs:=ss_idatarelocs

	if ss_zdatalen=0 then
		ss_zdatalen:=16
	fi

	sectiontable[zsect].name:=".bss"
	sectiontable[zsect].segtype:=zdata_seg
	sectiontable[zsect].virtsize:=ss_zdatalen

!note: rawsize will be recalculated later after thunk table is added
	sectiontable[csect].rawsize:=roundtoblock(sectiontable[csect].virtsize,filealign)
	sectiontable[csect].nrelocs:=ss_ncoderelocs
	sectiontable[csect].relocs:=ss_coderelocs

	sectiontable[isect].name:=".idata"
	sectiontable[isect].segtype:=impdata_seg
	sectiontable[isect].virtsize:=0
	sectiontable[isect].rawsize:=0

	nsections:=4
end

function roundtoblock(int n,align)int=
!round up n until it is a multiple of filealign (which is a power of two)
!return aligned value. Returns original if already aligned
	if n iand (align-1)=0 then return n fi

	return n+(align-(n iand (align-1)))
end

function extractlibname(ichar name, int &libno,moduleno)ichar=
!if name contains a dot, eg lib.abc, then set libno to index of "lib", and return "abc"
!otherwise return original name
	ref char s,name2
	[256]char str
	[256]char str2
	int i

	name2:=nil

	reenter::
	s:=name
	libno:=0

	while s^ do
		if s^='.' then			!assume lib.name
			memcpy(&.str,name,s-name)
			str[s-name+1]:=0
			strcat(&.str,".dll")

			for i:=1 to ndlls do
				if eqstring(&.str,dlltable[i].name) then
					libno:=i
					++dlltable[libno].nprocs
					return (name2|name2|s+1)
				fi
			od
			if ndlls>=maxlibs then gerror("Too many libs") fi
			libno:=++ndlls

			dlltable[libno].name:=pcm_copyheapstring(&.str)
			dlltable[libno].nprocs:=1
			return (name2|name2|s+1)
!		return s+1
		fi

		++s
	od

!do explicit search
	int n

	for i:=1 to nsearchlibs do
		if os_getdllprocaddr(libinsttable[i],name) then
			n:=i
			exit				!don't need the actual address; just whether it exists
		fi
	else
		println name,moduletable[moduleno].name
		gerror("Can't find external function")
	od

!found in search lib n
	if libno:=libnotable[n] then			!already added this library
		++dlltable[libno].nprocs
		return name
	fi

!first use of this lib
	strcpy(&.str,searchlibs[n])
	strcat(&.str,".dll")
	if ndlls>=maxlibs then gerror("2:Too many libs") fi
	libno:=++ndlls

	dlltable[libno].name:=pcm_copyheapstring(&.str)
	dlltable[libno].nprocs:=1
	libnotable[n]:=libno

	return name
end

proc scanst=
!scan symbol table and build dll and imports list
!this version assumes dlls are encoded into the name of each import
!(otherwise, it means requiring a list of dlls and loading/searching for
!the names: doing real linker work.)

	int i,libno
	ref strec d
	ichar name, libname

	for i:=1 to ss_nsymbols do

		d:=ss_symboltable^[i]
		case d^.symbol
		when importedsym then
			if nimports>=maximports then gerror("genexe: Too many imports") fi
			++nimports

			name:=extractlibname(d^.name,libno,d^.moduleno)

			importtable[nimports].libno:=libno			!0 if no lib
			importtable[nimports].name:=name				!original, or 2nd part of lib.name
			importtable[nimports].def:=d

			d^.importindex:=nimports
		when exportedsym then
			if userentrypoint then
				if eqstring(d^.name,userentrypoint) then
					stentrypoint:=d
				fi
			else
				if eqstring(d^.name,"main") and not isdll then
					stentrypoint:=d
				elsif eqstring(d^.name,"start") and not isdll then
					stentrypoint2:=d
				elsif eqstring(d^.name,"dllmain") and isdll then
					stentrypoint:=d
				fi
			fi

			if nexports>=maxexports then gerror("gendll: Too many exports") fi
			++nexports

			exporttable[nexports].def:=d
			exporttable[nexports].name:=d.name

		esac
	od
end

proc relocdata(ref sectionrec s)=
	ref sectionrec u
	ref relocrec r
	ref byte p
	ref word32 p32
	ref word64 p64
	ref strec d
	word thunkoffset
	int offset,index,iatoffset

	p:=bufferelemptr(s^.data,0)
	r:=s^.relocs

	while r do
		d:=ss_symboltable^[r^.stindex]
		index:=d^.importindex				!into importtable
		thunkoffset:=importtable[index].thunkoffset

		case r^.reloctype
		when rel32_rel then
			if d^.symbol<>importedsym then
				gerror("rel32/not imported")
			fi
			(ref word32(p+r^.offset)^:=int(thunkoffset)-r^.offset-4)

		when addr32_rel, addr64_rel then				!for addr64, just leave top half zero
			if d^.symbol=importedsym then

				(ref word32(p+r^.offset)^:=imagebase+thunkoffset+sectiontable[csect].virtoffset)
			else
				case d^.segment
				when zdata_seg then u:=&sectiontable[zsect]
				when idata_seg then u:=&sectiontable[dsect]
				when code_seg then u:=&sectiontable[csect]
				esac

				p32:=cast(p+r^.offset)
IF R.RELOCTYPE=ADDR32_REL THEN

				p32^:=p32^+u^.virtoffset+imagebase
ELSE
				P64:=cast(P32)
				p64^:=p64^+u^.virtoffset+imagebase
fi
			fi
		else
			cpl relocnames[r^.reloctype]
			gerror("Can't do this rel type")
		esac

		r:=r^.nextreloc
	od

end

proc getbaserelocs(ref sectionrec s)=
	ref sectionrec u
	ref relocrec r
	ref byte p
	ref strec d
	int index

	p:=bufferelemptr(s^.data,0)
	r:=s^.relocs

	while r do
		d:=ss_symboltable^[r^.stindex]

		case r^.reloctype
		when addr32_rel, addr64_rel then				!for addr64, just leave top half zero
			if d^.symbol=importedsym then
			else
				case d^.segment
				when zdata_seg then u:=&sectiontable[zsect]
				when idata_seg then u:=&sectiontable[dsect]
				when code_seg then u:=&sectiontable[csect]
				esac

				newbasereloc(u.virtoffset+r.offset, r.reloctype)

			fi
		esac

		r:=r^.nextreloc
	od

end

proc writerecordx(ref void r, int length)=
	memcpy(dataptr,r,length)
	dataptr+:=length
end

proc writedosstub=
!write 128-byte dos stub to dataptr
	static []byte stubdata = (
		0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00, 
		0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 
		0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
		0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD, 
		0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68, 
		0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 
		0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F, 
		0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E, 
		0x20, 0x69, 0x6E, 0x20, 0x44, 0x4F, 0x53, 0x20, 
		0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A, 
		0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)

	writerecordx(&stubdata,stubdata.bytes)
end

proc writepesig=
	dataptr++^:='P'
	dataptr++^:='E'
	dataptr++^:=0
	dataptr++^:=0
end

proc writepadding(int offset)=
!offset is the next desired offset in the file
	dataptr:=datastart+offset			!data will have been cleared
end

proc writefileheader=
	imagefileheader header

	memset(&header,0,header.bytes)
!	clear header

	header.machine:=0x8664
	header.nsections:=nsections
	header.optheadersize:=optionalheader.bytes
	header.characteristics:=0x22F
	if isdll then
		header.characteristics:=0x22E ior 0x2000
	fi

	writerecordx(&header,header.bytes)
end

proc writeoptheader=
	optionalheader header

	memset(&header,0,header.bytes)
!	clear header

	header.magic:=0x20B
	header.majorlv:=1
	header.minorlv:=0
	header.codesize:=sectiontable[csect].rawsize
	header.idatasize:=sectiontable[dsect].rawsize+sectiontable[isect].rawsize
	header.zdatasize:=roundtoblock(sectiontable[zsect].virtsize,filealign)

	if stentrypoint=nil then
		stentrypoint:=stentrypoint2
		if stentrypoint=nil then
			stentrypoint:=stentrypoint3
			if stentrypoint then
				println "Using tertiary 'WinMain' entry point"
			fi
		fi
	fi
	if stentrypoint=nil then
		if userentrypoint then
			cpl userentrypoint
			gerror("User entry point not found")
		else
			if not isdll then
				gerror("Entry point not found: main or start")
			fi
		fi
	else
		header.entrypoint:=sectiontable[csect].virtoffset+stentrypoint^.offset
	fi

	header.codebase:=sectionalign
	header.imagebase:=imagebase
	header.sectionalignment:=sectionalign
	header.filealignment:=filealign
	header.majorosv:=4
	header.minorosv:=0
	header.majorssv:=5
	header.minorssv:=2
	header.imagesize:=imagesize
	header.headerssize:=sectiontable[1].rawoffset
	header.subsystem:=3

	header.stackreserve:=4194304
	header.stackcommit:=2097152

	header.heapreserve:=1048576
	header.heapcommit:=4096
	header.rvadims:=16

	header.importtable.virtualaddr:=sectiontable[isect].virtoffset
	header.importtable.size:=sectiontable[isect].virtsize-exportdirvirtsize-blockdirvirtsize

	if isdll then
		header.dllcharacteristics:=0x40		!relocatable
		header.exporttable.virtualaddr:=exportdirvirtaddr
		header.exporttable.size:=exportdirvirtsize

		header.basereloctable.virtualaddr:=blockdirvirtaddr
		header.basereloctable.size:=blockdirvirtsize
	fi

	header.iat.virtualaddr:=fileiatoffset
	header.iat.size:=fileiatsize

	writerecordx(&header,header.bytes)

end

proc writesectionheader(ref sectionrec s)=
	imagesectionheader sheader

	memset(&sheader,0,sheader.bytes)
!	clear sheader

	strcpy(&sheader.name[1],s^.name)
	sheader.virtual_size:=s^.virtsize
	sheader.virtual_address:=s^.virtoffset
	sheader.rawdata_offset:=s^.rawoffset
	sheader.rawdata_size:=s^.rawsize

	int64 aa
	case s^.segtype
	when zdata_seg then
		sheader.characteristics:=0xC050'0080
	when idata_seg then
		sheader.characteristics:=0xC050'0040
	when code_seg then
		sheader.characteristics:=0x6050'0020
	when impdata_seg then
!		sheader.characteristics:=0xC030'0040
		sheader.characteristics:=0x4030'0040
	esac
	writerecordx(&sheader,sheader.bytes)
end

proc writesectiondata(ref sectionrec s)=

	case s^.segtype
	when impdata_seg then
		writerecordx(s^.bytedata,s^.virtsize)		!rest of section will be zeros
		if s^.rawsize>s^.virtsize then
			dataptr+:=(s^.rawsize-s^.virtsize)
		fi

	when zdata_seg then					!nothing goes to disk
!		dataptr+:=s^.rawsize
	else
		writerecordx(bufferelemptr(s^.data,0),s^.rawsize)
	esac
end

proc getoffsets=
!apply file/image offsets to sectiontable
	int fileoffset, imageoffset,i,diroffset,impdirno,hinttableoffset,j,n
	int codesize,length,thunkoffset,offset,dirstartoffset

	fileoffset:=128+4+imagefileheader.bytes+optionalheader.bytes	!dosstub+sig
	fileoffset+:=imagesectionheader.bytes*nsections

	fileoffset:=roundtoblock(fileoffset,filealign)
	imageoffset:=4096

!Need to increase size of code segment to incorporate the thunk table
	ref byte pcode
	codesize:=sectiontable[csect].virtsize
	pcode:=bufferelemptr(ss_code,codesize)
	while codesize iand 7 do pcode++^:=0x90; ++codesize od
	thunkoffset:=codesize
	codesize+:=nimports*8

	sectiontable[csect].virtsize:=codesize
	sectiontable[csect].rawsize:=roundtoblock(codesize,filealign)

!have to actually add the extra memory now.
	buffercheck(ss_code, codesize-thunkoffset+16)		!just ensure it's there for now

	for i:=1 to nsections do
		if sectiontable[i].segtype<>zdata_seg then
			sectiontable[i].rawoffset:=fileoffset
		fi
		if sectiontable[i].segtype<>zdata_seg then
			fileoffset:=roundtoblock(fileoffset+sectiontable[i].virtsize,filealign)
		fi
		sectiontable[i].virtoffset:=imageoffset

		if sectiontable[i].segtype=impdata_seg then
			diroffset:=imageoffset
			impdirno:=i
		fi

		imageoffset:=roundtoblock(imageoffset+sectiontable[i].virtsize,sectionalign)
	od

	if isdll then
		getbaserelocs(&sectiontable[csect])
		getbaserelocs(&sectiontable[dsect])
	fi

!Work out offsets within import directory
!assume dll/imports have been set up
!diroffset starts off as virtual offset of start of impdata section

	diroffset+:=(ndlls+1)*importdirrec.bytes			!need blank entry as terminator

!diroffset now points to import name table
!usual arrangements is for all import name table, followed by all import addr tables

	for i to ndlls do
		dlltable[i].nametableoffset:=diroffset				!data will be filled in later
		diroffset+:=(dlltable[i].nprocs+1)*8
	od
	fileiatoffset:=diroffset
	for i to ndlls do
		dlltable[i].addrtableoffset:=diroffset				!data will be filled in later
		diroffset+:=(dlltable[i].nprocs+1)*8
	od
	fileiatsize:=diroffset-fileiatoffset

!diroffset now points to hint/name table, which is shared by all libs
!At this point, I need to write into an actual impdata segment, which doesn't
!exist yet. So I need to do a first pass over the import names to work out the size
	hinttableoffset:=diroffset
	for i to nimports do
		length:=strlen(importtable[i].name)+3
		if length iand 1 then ++length fi		!keep even
		importtable[i].hintnameoffset:=diroffset
		diroffset+:=length
	od

!need also space for the names of the libs

!need I think to get to next multiple of four
	diroffset:=roundtoblock(diroffset,4)

	for i to ndlls do
		length:=strlen(dlltable[i].name)+1
		if length iand 1 then ++length fi		!keep even
		dlltable[i].dllextraoffset:=diroffset
		diroffset+:=dlltable[i].nprocs*4		!space for back-links to dir entry
		dlltable[i].dllnameoffset:=diroffset
		diroffset+:=length
	od

	dirstartoffset:=sectiontable[impdirno].virtoffset

	if isdll then

		exportdirvirtaddr:=diroffset
		exportdiroffset:=diroffset-dirstartoffset
		exportdirvirtsize:=getexporttablesize()
		diroffset+:=exportdirvirtsize

		scanbaserelocs()

		blockdirvirtaddr:=diroffset
		blockdiroffset:=diroffset-dirstartoffset
		blockdirvirtsize:=basetablesize
		diroffset+:=blockdirvirtsize
	fi

	offset:=diroffset-dirstartoffset
!CPL =OFFSET:"H"
!offset contains now the overall size of the import directory
!diroffset contains is the overall size of the image

!finish off last section data, and compute final file and image sizes
	sectiontable[impdirno].virtsize:=offset
	sectiontable[impdirno].rawsize:=roundtoblock(offset,filealign)
	filesize:=roundtoblock(fileoffset+offset,filealign)

	imagesize:=roundtoblock(imageoffset+(diroffset-dirstartoffset),sectionalign)

	ref byte pimpdir

	pimpdir:=sectiontable[impdirno].bytedata:=pcm_allocz(offset)

!prepare the thunk area in the code segment
	ref importdirrec pdir
	ref int64 paddr,pname
	int iatoffset
	pdir:=cast(pimpdir)

!start fill in details within the import directory section
	for i:=1 to ndlls do
		pdir^.implookuprva:=dlltable[i].nametableoffset
		pdir^.impaddressrva:=dlltable[i].addrtableoffset
		pdir^.namerva:=dlltable[i].dllnameoffset
		++pdir

		iatoffset:=dlltable[i].addrtableoffset
		paddr:=cast(pimpdir+iatoffset-dirstartoffset)
		pname:=cast(pimpdir+dlltable[i].nametableoffset-dirstartoffset)
		for j to nimports when importtable[j].libno=i do
			pname^:=paddr^:=importtable[j].hintnameoffset
			importtable[j].iatoffset:=iatoffset
			iatoffset+:=8
			++pname
			++paddr
		od
	od

!Fill in the hint/name table
	ref byte phint
	ref word32 pextra

	for i to nimports do
		phint:=pimpdir+importtable[i].hintnameoffset-dirstartoffset
		phint+:=2					!leave hint as 0
		strcpy(cast(phint),importtable[i].name)
	od
!same for lib names (no hint here, but re-use phint anyway)
	int xxx
	xxx:=dirstartoffset
	for i to ndlls do
		pextra:=cast(pimpdir+dlltable[i].dllextraoffset-dirstartoffset)
		for j to dlltable[i].nprocs do
			pextra^:=xxx
			++pextra
		od
		xxx+:=importdirrec.bytes
		phint:=pimpdir+dlltable[i].dllnameoffset-dirstartoffset
		strcpy(cast(phint),dlltable[i].name)
	od

!CPL "HERE",ISDLL

	if isdll then
		writeexporttable(ref byte(pimpdir)+exportdiroffset)
		writebasereloctable(ref byte(pimpdir)+blockdiroffset)
	fi

!write the thunk table
	ref byte thunkptr,codebase
	int thunkaddr
	thunkptr:=bufferelemptr(ss_code,thunkoffset)
	codebase:=bufferelemptr(ss_code,0)

	for i to nimports do
		importtable[i].thunkoffset:=thunkptr-codebase
		thunkptr++^:=0x48
		thunkptr++^:=0xFF
		thunkptr++^:=0x24
		thunkptr++^:=0x25
		thunkaddr:=imagebase+importtable[i].iatoffset
		(ref int32(thunkptr)^:=thunkaddr)

		thunkptr+:=4
	od
end

function getsectionno(int segment)int=
	case segment
	when zdata_seg then zsect
	when idata_seg then dsect
	when code_seg then csect
	else gerror("GSN"); 0
	esac
end

proc writeexporttable(ref byte pstart)=
!	const maxexports=2000
	[maxexports]int sortindex
	ref exportdirrec phdr := cast(pstart)
	ref word32 paddrtable
	ref word32 pnametable
	ref word16 pordtable
	ref char pdllname
	ref char pnames
	int addrtableoffset
	int nametableoffset
	int ordtableoffset
	int dllnameoffset
	int namesoffset
	int virtoffset
	int sectionno
	ref strec d

!CPL "WRITEEXPORTABLE",PHDR
!RETURN
	phdr.timedatestamp:=0x5f89f4f8

	phdr.ordinalbase:=1
	phdr.naddrtable:=nexports
	phdr.nnamepointers:=nexports

!these are offsets from the start of the export data, from the start of the export dir
	addrtableoffset:=exportdirrec.bytes
	nametableoffset:=addrtableoffset+nexports*4
	ordtableoffset:=nametableoffset+nexports*4
	dllnameoffset:=ordtableoffset+nexports*2
	namesoffset:=dllnameoffset+strlen(dllfilename)+1

!virtoffset must be added to all above basic offsets, before being written to the file 
	virtoffset:=sectiontable[isect].virtoffset+exportdiroffset

!work out pointers into memory to receive the data
	paddrtable:=cast(pstart+addrtableoffset)
	pnametable:=cast(pstart+nametableoffset)
	pordtable:=cast(pstart+ordtableoffset)
	pdllname:=cast(pstart+dllnameoffset)
	pnames:=cast(pstart+namesoffset)

!fill in rest of export dir
	phdr.namerva:=dllnameoffset+virtoffset
	phdr.expaddressrva:=addrtableoffset+virtoffset
	phdr.namepointerrva:=nametableoffset+virtoffset
	phdr.ordtablerva:=ordtableoffset+virtoffset

	strcpy(pdllname,dllfilename)

!address table
	if nexports>maxexports then
		gerror("Too many exports - can't sort")
	fi

	sortexports(sortindex)

	for i to nexports do
!		d:=exporttable[i].def
		d:=exporttable[sortindex[i]].def
		sectionno:=getsectionno(d.segment)

		strcpy(pnames,d.name)
		pnametable^:=namesoffset+virtoffset
		++pnametable
		namesoffset+:=strlen(d.name)+1
		pnames+:=strlen(d.name)+1

		paddrtable^:=d.offset+sectiontable[sectionno].virtoffset
		++paddrtable
		pordtable^:=i-1
		++pordtable
	od


!PHDR.MAJORVERSION:=1
!PHDR.MINORVERSION:=2
!
!CPL =PHDR.NAMERVA:"H"
end

function getexporttablesize:int=
!CPL "GETEXPORT SIZE",=NEXPORTS
	int size

	size:=exportdirrec.bytes
	size+:=nexports*4			!address table entries
	size+:=nexports*4			!name pointers
	size+:=nexports*2			!ordinal table

	size+:=strlen(dllfilename)+1
	for i to nexports do
		size+:=strlen(exporttable[i].def.name)+1
	od

	return size
end

proc newbasereloc(int addr, reltype)=
	ref basereloc p

	p:=pcm_allocz(basereloc.bytes)
	p.address:=addr
	p.reloctype:=reltype

	p.nextitem:=basereloclist

	basereloclist:=p
	++nbaserelocs
	maxrelocaddr max:=addr

end

proc scanbaserelocs=
!go through all the relocs and build the block tables, and work out overall size
!	int maxaddr:=maxrelocaddr+4096
	int baseaddr,addr,nextblock
	ref basereloc p

	baseaddr:=0x1000
	nbaseblocks:=0

	repeat
		nextblock:=baseaddr+0x1000
		if nbaseblocks>=maxbaseblock then gerror("Too many blocks") fi
		++nbaseblocks
		blockbases[nbaseblocks]:=baseaddr
		blockcounts[nbaseblocks]:=0


		p:=basereloclist
		while p do
			addr:=p.address
			if addr>=baseaddr and addr<nextblock then
!				println "	",addr:"h",addr-baseaddr:"h", relocnames[p.reloctype]
				++blockcounts[nbaseblocks]
			fi

			p:=p.nextitem
		od

		baseaddr:=nextblock
	until baseaddr>maxrelocaddr

	for i to nbaseblocks when blockcounts[i] do
!		if blockcounts[i].odd then
		if blockcounts[i] iand 1 then
			++blockcounts[i]
			++blockpadding[i]
		fi
		blockbytes[i]:=blockcounts[i]*2+8
		basetablesize+:=blockbytes[i]
	od
end

proc writebasereloctable(ref byte pstart)=
	
	ref word32 p32
	ref word16 p16
	int baseaddr,addr,nextblock
	ref basereloc q

	p32:=cast(pstart)

	for i to nbaseblocks when blockcounts[i] do
		p32^:=blockbases[i]
		++p32
		p32^:=blockbytes[i]
		++p32
		p16:=cast(p32)

		q:=basereloclist
		baseaddr:=blockbases[i]
		nextblock:=baseaddr+4096

		while q do
			addr:=q.address
			if addr>=baseaddr and addr<nextblock then
				p16^:=addr-baseaddr+(q.reloctype=addr32_rel|3|10)<<12
				++p16
			fi
!
			q:=q.nextitem
		od
		if blockpadding[i] then p16++^:=0 fi

		p32:=cast(p16)

	od
end

proc sortexports([]int &sortindex)=
!sort exporttable by name. This is done by building a set of sorted indices into
!sortindex
	ref strec d,e
!First, store 1..nexports into sortindex
	for i to nexports do
		sortindex[i]:=i
	od

!do bubble sort for now
	int swapped

	repeat
		swapped:=0
		for i:=1 to nexports-1 do

			d:=exporttable[sortindex[i]].def
			e:=exporttable[sortindex[i+1]].def

			if strcmp(d.name, e.name)>0 then
				swapped:=1
				swap(sortindex[i], sortindex[i+1])
			fi
		od
	until not swapped

end
=== aa_writess.m 74/77 ===
import* aa_common

global function writessdata(int fexe)ref strbuffer=
	gs_init(dest)
	showssdata(fexe)

	gs_line(dest)
	return dest
end

proc showssdata(int fexe)=
gs_strln(dest,(fexe|"EXE FORMAT"|"AFTER GENSS"))

	showsections()

	gs_line(dest)

	showsectionrelocs2("Idata",ss_idatarelocs,ss_nidatarelocs)
	showsectionrelocs2("Code",ss_coderelocs,ss_ncoderelocs)

	gs_str(dest,"proc Section Zdata: ")
	gs_strint(dest,ss_zdatalen)
	gs_line(dest)

	showsectiondata(&sectiontable[dsect])
	showsectioncode(&sectiontable[csect])
	if fexe then
		showsectiondata(&sectiontable[isect])
	fi

	showsymboltable2()
	showimporttable()
	gs_strln(dest,"END OF GENSS")

end

proc showsectiondata(ref sectionrec d)=
int i,k,length,bb
	[128]char str,str2
	ref byte p

	gs_str(dest,"proc Section ")
	gs_str(dest,d^.name)
	gs_str(dest," Size:")
	gs_strint(dest,d^.virtsize)
	gs_line(dest)
	gs_line(dest)

	k:=0
	if d^.segtype<>impdata_seg then
		p:=bufferelemptr(d^.data,0)
	else
		p:=d^.bytedata
	fi
	length:=d^.virtsize

	str[1]:=0

	ref byte baseaddr:=cast(imagebase+d^.virtoffset)

	print @&.str2,baseaddr:"Z8H",,": "

	gs_str(dest,&.str2)

	for i:=1 to length do
		bb:=p++^
		print @&.str2,bb:"z2H",," "
		gs_str(dest,&.str2)

		if 32<=bb<=127 then
			str2[1]:=bb
			str2[2]:=0
			strcat(&.str,&.str2)
		else
			strcat(&.str,".")
		fi
		if ++k=16 or i=length then
			if k<16 then
				to 16-k do
					gs_str(dest,"   ")
					strcat(&.str," ")
				od
			fi
			gs_str(dest,"	[")
			gs_str(dest,&.str)
			gs_strln(dest,"]")
			k:=0
			str[1]:=0
			baseaddr+:=16
			print @&.str2,baseaddr:"z8h",,": "
			gs_str(dest,&.str2)
		fi
	od
	if k=0 then
		gs_line(dest)
	fi

	gs_line(dest)
	if k then gs_line(dest) fi
end

proc showsectioncode(ref sectionrec p)=
ref byte codeptr,codeend,codestart
	int length,offset
	ichar s
	[16]char str

	gs_strln(dest, "proc Section Code")

	length:=p^.virtsize
	codestart:=codeptr:=bufferelemptr(p^.data,0)
	codeend:=codeptr+length

	ref byte baseaddr:=cast(imagebase+p^.virtoffset)

	while codeptr<codeend do
		offset:=codeptr-codestart
!S:=NIL
		s:=decodeinstr(codeptr,baseaddr+offset)
		exit when s=nil

		print @&.str,offset:"4",," "
		gs_str(dest,&.str)

		gs_strln(dest,s)
	od

	gs_line(dest)
end

proc showsectionrelocs2(ichar caption,ref relocrec relocs, int nrelocs)=
	ref relocrec r

	gs_str(dest,"proc Section Relocs: ")
	gs_str(dest,caption)
	gs_str(dest," ")
	gs_strint(dest,nrelocs)
	gs_line(dest)

	r:=relocs

	while r do

		gs_str(dest,"Reloc: ")
		gs_str(dest,relocnames[r^.reloctype])
		gs_str(dest," Offset: ")
		gs_strint(dest,r^.offset)
		gs_str(dest," ST Index: ")
		gs_strint(dest,r^.stindex)
		gs_str(dest," ")
		gs_str(dest,ss_symboltable^[r^.stindex]^.name)
		gs_line(dest)

		r:=r^.nextreloc
	od
	gs_line(dest)

end

proc gs_value(ichar caption, int64 value)=
	[256]char str

	strcpy(&.str,caption)
	strcat(&.str,":")
	ipadstr(&.str,20)
	gs_str(dest,&.str)

	fprint @&.str,"0x# #",value:"H",value
	gs_strln(dest,&.str)
end

proc showsymboltable2=

	gs_strln(dest,"Proc Symbol Table")
	int i
	for i:=1 to ss_nsymbols do
		gs_strint(dest,i)
		gs_str(dest,": ")
		gs_strln(dest,ss_symboltable^[i]^.name)
	od
	gs_line(dest)
end

proc showimporttable=
	[256]char str
	dllrec d
	importrec p


	gs_strln(dest,"Proc Dll List")
	int i
	for i:=1 to ndlls do
		gs_strint(dest,i)
		gs_str(dest,": ")
		gs_str(dest,dlltable[i].name)
		gs_str(dest," ")
		gs_strint(dest,dlltable[i].nprocs)
		gs_line(dest)
		gs_value("		Name Table Offset",dlltable[i].nametableoffset)
		gs_value("		Addr Table Offset",dlltable[i].addrtableoffset)
		gs_value("		DLL Name Offset  ",dlltable[i].dllnameoffset)
	od
	gs_line(dest)
	gs_strln(dest,"Proc Import List")

	for i:=1 to nimports do
		p:=importtable[i]

		gs_strint(dest,i)
		gs_str(dest,": ")
		if p.libno then
			strcpy(&.str,p.name)
			ipadstr(&.str,16)
			gs_str(dest,&.str)
			gs_str(dest," (")
			gs_str(dest,dlltable[p.libno].name)
			gs_strln(dest,")")

			gs_value("	IAT Offset        ",p.iatoffset)
			gs_value("	Thunk Offset      ",p.thunkoffset)
			gs_value("	Hint/Name Offset  ",p.hintnameoffset)

		else
			strcpy(&.str,p.name)
			ipadstr(&.str,20)
			gs_str(dest,&.str)
			gs_strln(dest," (---)")
		fi
	od
	gs_line(dest)
end

proc showsections=
	sectionrec s
	int i

	gs_strln(dest,"proc Section Headersxxx")
	gs_line(dest)

	for i:=1 to nsections do
		s:=sectiontable[i]

		gs_str(dest,"Section ")
		gs_strint(dest,i)
		gs_str(dest,": ")
		gs_str(dest,s.name)
		gs_str(dest,"  (")
		gs_str(dest,segmentnames[s.segtype])
		gs_strln(dest,")")

		gs_value("    Raw Offset",s.rawoffset)
		gs_value("    Raw Size",s.rawsize)
		gs_value("    Virtual Offset",s.virtoffset)
		gs_value("    Virtual Size",s.virtsize)
		gs_value("    Nrelocs",s.nrelocs)
		gs_value("    Data",int(s.data))
		gs_line(dest)

	od
end

=== aa_disasm.m 75/77 ===
import clib
import msys
import oslib

!const showmregs=1
const showmregs=0

const halt=0xF4

int nmodules
int xfchsmask_pd

tabledata() [0:]ichar opnames =
	(add_op=0,	"add"),
	(or_op,		"or"),
	(adc_op,	"adc"),
	(sbb_op,	"sbb"),
	(and_op,	"and"),
	(sub_op,	"sub"),
	(xor_op,	"xor"),
	(cmp_op,	"cmp")
end

[0:]ichar condnames = 
("o", "no", "b","ae","z","nz","be","a","s","ns","p","np",
 "l","ge","le","g")

tabledata() []ichar addrmodenames=		! rm modes
	(amreg,			$),				! R
	(ammem,			$),				! [R+d]
	(amrel,			$)				! [RIP+d]
end

const wmask = 2x1000
const rmask = 2x0100
const xmask = 2x0010
const bmask = 2x0001

const rstack=5						!1-base register codes
const rframe=6

int rex

int addrmode						!amreg/ammem/amrel
int rmreg							!0, or 1..16; adjusted middle value of modrm byte
int rmopc							!0 to 7; middle value of modrm byte 
int basereg							!0, or 1..16
int indexreg						!0, or 1..16
int scale							!1,2,4
int opsize							!1,2,4,8
int offset
int offsetsize						!1 or 4
int sizeoverride					!32=>16 switch
int addroverride					!32=>16 switch
int f2override						!xmm regs
int f3override						!xmm regs

[256]char deststr
ichar destptr

ref byte codeptr

global function decodeinstr(ref byte &cptr,baseaddr=nil)ichar=
!decode next instruction at codeptr
!return 1 if decoded, with codeptr stepped to start of next instruction
!return 0 when end-of-code seen (nop or 0x90)
	int n,w
	int opc,reg,op,xxx,oldopsize,dispsize
	ref byte pstart
	static [256]char str
	[128]char str2
	const maxinstrlen=14
	ichar s

	deststr[1]:=0

	pstart:=codeptr:=cptr

	rex:=0
	opsize:=1
	f2override:=f3override:=sizeoverride:=addroverride:=0
	basereg:=indexreg:=offset:=0

	retry::						!back here after prefix byte seen

	switch opc:=codeptr++^
	when 0x00,0x1, 0x08,0x9, 0x10,0x11, 0x18,0x19,
						0x20,0x21, 0x28,0x29, 0x30,0x31, 0x38,0x39 then	!arith R/M, R
		op:=opc>>3
		decodeaddr(opc iand 1)
		getsilx(basereg)
		getsil(rmreg)
		genstr(opnames[op])
		printaddrmode()
		genstr(", ")
		genstr(strreg(rmreg,opsize))

	when 0x02,0x3, 0x0A,0xB, 0x12,0x13, 0x1A,0x1B,
						0x22,0x23, 0x2A,0x2B, 0x32,0x33, 0x3A,0x3B then	!arith R,R/M
		op:=opc>>3
		decodeaddr(opc iand 1)
		genstr(opnames[op])
		genstr(" ")
		getsil(rmreg)
		genstr(strreg(rmreg,opsize))
		genstr(", ")
		printaddrmode()

	when 0x04,0x5, 0x0C,0xD, 0x14,0x15, 0x1C,0x1D,
						0x24,0x25, 0x2C,0x2D, 0x34,0x35, 0x3C,0x3D then	!arith rAX,imm
		genstr(opnames[opc>>3])
		genstr(" ")
		if opc iand 1 then
			opsize:=4
			if sizeoverride then opsize:=2 fi
			if rex iand wmask then opsize:=8 fi
		fi
		genstr(strreg(1,opsize))
		genstr(", ")
		genintd(readimm())

	when 0x0F then
		decodetwobyteinstr()

	when 0x40 .. 0x4F then
		rex:=opc
!	if rex iand wmask then wopsize:=8 fi

		goto retry

	when 0x50 .. 0x57 then
		reg:=getreg(opc iand 7,rex iand bmask)
		genstr("push ")
		genstr(strreg(reg,8))

	when 0x58 .. 0x5F then
		reg:=getreg(opc iand 7,rex iand bmask)
		genstr("pop ")
		genstr(strreg(reg,8))

	when 0x63 then
		decodeaddr(1)
		genstr("movsxd ")
		genstr(strreg(rmreg,opsize))
		genstr(", ")
		opsize:=4
		printaddrmode()

	when 0x66 then
		sizeoverride:=1
		goto retry

	when 0x67 then
		addroverride:=1
		goto retry

	when 0x68 then
		genstr("push ")
		genintd(readint32())

	when 0x6A then
		genstr("push ")
		genintd(readsbyte())

	when 0x69, 0x6B then
		decodeaddr(1)
		if basereg<>rmreg then
			genstr("imul3")
			genstr(" ")
			genstr(strreg(rmreg,opsize))
			genstr(", ")
		else
			genstr("imul2")
		fi
		printaddrmode()
		genstr(", ")
		opsize:=(opc iand 2|1|opsize)
		genintd(readimm())

	when 0x70..0x7F then
		genstr("j")
		genstr(condnames[opc iand 15])
		genstr(" ")
		genintd(readsbyte())

	when 0x80..0x83 then			!arith r/m,imm
		decodeaddr(opc iand 1)
		genstr(opnames[rmopc])
		getsilx(basereg)
		printaddrmode()
		genstr(", ")
		if opc<>0x83 then
			genintd(readimm())
		else
			genintd(readsbyte())
		fi

	when 0x84, 0x85 then			!test reg,reg/mem
		decodeaddr(opc iand 1)
		getsilx(basereg)
		getsil(rmreg)
		genstr("test ")
		printaddrmode()
		genstr(", ")
		genstr(strreg(rmreg,opsize))

	when 0x86,0x87 then				!complex excg
		decodeaddr(opc iand 1)
		genstr("exch2 ")
		getsilx(basereg)
		getsil(rmreg)
		genstr(strreg(rmreg,opsize))
		genstr(",")
		printaddrmode()

	when 0x88, 0x89 then			!mov r/m,reg
		decodeaddr(opc iand 1)
		genstr("mov")
		getsilx(basereg)
		getsil(rmreg)

		printaddrmode()
		genstr(", ")
		genstr(strreg(rmreg,opsize))

	when 0x8A, 0x8B then			!mov reg,r/m
		decodeaddr(opc iand 1)
		genstr("mov ")
		getsilx(basereg)
		getsil(rmreg)
		genstr(strreg(rmreg,opsize))
		genstr(", ")
		printaddrmode()

	when 0x8D then
		decodeaddr(1)
		genstr("lea ")
		genstr(strreg(rmreg,opsize))
		genstr(", ")
		printaddrmode()

	when 0x8F then
		decodeaddr(1)
		opsize:=1
		genstr("pop")
		printaddrmode()

	when 0x90 then
		if rex then goto doexch fi
		genstr("nop")

	when 0x91..0x97 then			!exch eax/reg
	doexch::
		reg:=(opc iand 7)+1
		if rex iand bmask then reg+:=8 fi
		opsize:=(sizeoverride|2|4)
		if rex iand wmask then opsize:=8 fi
		genstr("xchg ")
		genstr(strreg(1,opsize))
		genstr(", ")
		genstr(strreg(reg,opsize))

	when 0x98 then
		if sizeoverride then
			genstr("cbw")
		else
			genstr("cbw???")
		fi
	when 0x99 then
		if sizeoverride then
			genstr("cwd")
		elsif rex iand wmask then
			genstr("cqo")
		else
			genstr("cdq")
		fi
	when 0x9B then genstr("wait")

	when 0x9C then genstr("pushf")
	when 0x9D then genstr("popf")
	when 0x9E then genstr("sahf")
	when 0x9F then genstr("lahf")

	when 0xA4..0xA7, 0xAA..0xAF then
		genstr((opc>>1 iand 7|"?","movs","cmps","?","stos","lods","scas"|"?"))
		if opc iand 1=0 then
			genstr("b")
		else
			if rex iand wmask then
				genstr("q")
			elsif sizeoverride then
				genstr("w")
			else
				genstr("d")
			fi
		fi

	when 0xA8, 0xA9 then				!test r0,imm
		genstr("test ")
		if opc iand 1 then
			opsize:=(sizeoverride |2|4)
			if rex iand wmask then opsize:=8 fi
		fi
		genstr(strreg(1,opsize))
		genstr(", ")
		genintd(readimm())

	when 0xB0..0xBF then			!mov reg,imm
		reg:=(opc iand 7)+1
		if rex iand bmask then reg+:=8 fi
		if (opc iand 2x1000) then
			opsize:=(sizeoverride |2|4)
			if rex iand wmask then opsize:=8 fi
		fi
		genstr("mov ")
		getsil(reg)

		genstr(strreg(reg,opsize))
		genstr(", ")
		genintd(readimm8())

	when 0xC0, 0xC1, 0xD0..0xD3 then
		decodeaddr(opc iand 1)
		getsilx(basereg)
		genstr((rmopc+1|"rol","ror","rcl","rcr","shl","shr","?","sar"|"?"))
		printaddrmode()
		if opc<=0xC1 then
			genstr(", ")
			genintd(readbyte())
		else
			genstr((opc iand 2|", cl"|", 1"))
		fi

	when 0xC2 then
		genstr("retn ")
		genintd(readword16())

	when 0xC3 then
		genstr("ret")

	when 0xC6,0xC7 then
		decodeaddr(opc iand 1)
		genstr("mov")
		printaddrmode()
		genstr(", ")
		genintd(readimm())

	when 0xD7 then genstr("xlat")

	when 0xD8..0xDF then
		decode8087(opc iand 7)

	when 0xE0 then genstr("loopnz "); genintd(readsbyte())
	when 0xE1 then genstr("loopz "); genintd(readsbyte())
	when 0xE2 then genstr("loop "); genintd(readsbyte())

	when 0xE3 then
		if addroverride then
			genstr("jecxz ")
		else
			genstr("jrcxz ")
		fi
		genintd(readsbyte())

	when 0xE8 then
		genstr("call ")
		genintd(readint32())

	when 0xE9 then
		genstr("[4] jmp ")
		genintd(readint32())

	when 0xEB then
		genstr("jmp ")
		genintd(readsbyte())

	when 0xF2 then
		if codeptr^<>0x0F and (codeptr^<0x40 and codeptr^>0x4F) then
			genstr("repne")
		else
			f2override:=1
			goto retry
		fi
	when 0xF3 then
		if codeptr^<>0x0F and (codeptr^<0x40 and codeptr^>0x4F) then
			genstr("repe")
		else
			f3override:=1
			goto retry
		fi

	when 0xF4 then
!	println "	end of code [halt]"
		return nil

	when 0xF6,0xF7 then
		decodeaddr(opc iand 1)
		getsilx(basereg)
		genstr((rmopc+1|"test","?","not","neg","mul","imul","div","idiv"|"?"))
		printaddrmode()
		if rmopc=0 then
			if opsize=8 then opsize:=4 fi
			genstr(", ")
			genintd(readimm())
		fi

	when 0xFE then
		w:=0
		goto doff

	when 0xFF then			!various
		w:=1
	doff::
		decodeaddr(w)
		case rmopc
		when 2x_000 then	!inc
			getsilx(basereg)
			genstr("inc")
		when 2x_001 then	!dec
			getsilx(basereg)
			genstr("dec")
		when 2x_010 then	!call
			opsize:=8
			genstr("icall")
		when 2x_100 then	!jmp
			opsize:=8
			genstr("jmp")
		when 2x_110 then	!push
			opsize:=8
			genstr("push")
		else
			println "FFxx?"
		esac
		printaddrmode()

	else
		genstr("Unknown opcode: ")
    genhex(opc)
	endswitch

!at this point, deststr contains the decoded instruction
!need to put in address, bytes etc

	if baseaddr then
		print @&.str,baseaddr:"z6h",,": "
	else
		print @&.str,pstart:"z6h",,": "
	fi

	n:=codeptr-pstart
	to n do
		print @&.str2,int(pstart++^):"z2H",," "

		strcat(&.str,&.str2)
	od
	to maxinstrlen-n do
		strcat(&.str,"-- ")
	od
	strcat(&.str,&.deststr)

	cptr:=codeptr

	return &.str
end

proc decodetwobyteinstr=
!0F has been decoded
	int opc,rhssize,third,imm
	ichar opcstr

	switch opc:=codeptr++^
	when 0x2A then					!cvtsi2ss/sd XMM, REG/MEM
		decodeaddr(1)
		if f3override then
			genstr("cvtsi2ss ")
		else
			genstr("cvtsi2sd ")
		fi
		genstr(strxmm(rmreg))
		genstr(", ")
		printaddrmode(0)
		
	when 0x2C then					!cvt2ss/sd2si XMM, REG/MEM
		decodeaddr(1)
		if f3override then
			genstr("cvttss2si ")
			rhssize:=4
		else
			genstr("cvttsd2si ")
			rhssize:=8
		fi
		if rex iand wmask then
			genstr(strreg(rmreg,8))
		else
			genstr(strreg(rmreg,4))
		fi
		genstr(", ")
		opsize:=rhssize
		printaddrmode(1)

	when 0x2D then					!cvt2ss/sd2si XMM, REG/MEM
		decodeaddr(1)
		if f3override then
			genstr("cvtss2si ")
			rhssize:=4
		else
			genstr("cvtsd2si ")
			rhssize:=8
		fi
		if rex iand wmask then
			genstr(strreg(rmreg,8))
		else
			genstr(strreg(rmreg,4))
		fi
		genstr(", ")
		opsize:=rhssize
		printaddrmode(1)

	when 0x2F then					!comiss/comisd XMM, REG/MEM
		decodeaddr(1)
		if sizeoverride then
			opsize:=8
			genstr("comisd ")
		else
			opsize:=4
			genstr("comiss ")
		fi
		genstr(strxmm(rmreg))
		genstr(", ")
		printaddrmode(1)

	when 0x3A then					!possible pcmpistri
		third:=codeptr++^

		case third
		when 0x63 then
			genstr("pcmpistri ")
		when 0x62 then
			genstr("pcmpistrm ")
		else
			genstr("Unknown opcode 2-byte opcode: 0F ")
		    genhex(opc)
			return
		esac

		decodeaddr(1)
		genstr(strxmm(rmreg))
		genstr(", ")
		printaddrmode(1)
		genstr(", ")
		imm:=codeptr++^
		genintd(imm)

	when 0x40..0x4F then
		decodeaddr(1)
		genstr("cmov")
		genstr(condnames[opc iand 15])
		genstr(" ")
		genstr(strreg(rmreg,opsize))
		genstr(", ")
		printaddrmode()

	when 0x51 then					!sqrtss/sd
		decodeaddr(1)
		opsize:=(f3override|4|8)
		genstr((opsize=4|"sqrtss "|"sqrtsd "))
		genstr(strxmm(rmreg))
		genstr(", ")
		printaddrmode(1)

	when 0x54 then					!ANDPD
		decodeaddr(1)
		genstr((sizeoverride|"andpd "|"andps "))
		genstr(strxmm(rmreg))
		genstr(", ")
		opsize:=(sizeoverride|8|4)
		printaddrmode(1)

	when 0x57 then					!XORPD
		decodeaddr(1)
		genstr((sizeoverride|"xorpd "|"xorps "))
		genstr(strxmm(rmreg))
		genstr(", ")
		opsize:=(sizeoverride|8|4)
		printaddrmode(1)

	when 0x58 then					!addss/addsd
		opcstr:="adds"
	doarith::
		genstr(opcstr)
		decodeaddr(1)
		if f2override then
			opsize:=8
			genstr("d ")
		else
			opsize:=4
			genstr("s ")
		fi
		genstr(strxmm(rmreg))
		genstr(", ")
		printaddrmode(1)

	when 0x59 then					!mulss/mulsd
		opcstr:="muls"
		goto doarith

	when 0x5A then					!cvtss2sd/cvtsd2ss
		decodeaddr(1)
		if f3override then
			genstr("cvtss2sd ")
			rhssize:=4
		else
			genstr("cvtsd2ss ")
			rhssize:=8
		fi
		genstr(strxmm(rmreg))
		genstr(", ")
		opsize:=rhssize
		printaddrmode(1)

	when 0x5C then					!subss/subsd
		opcstr:="subs"
		goto doarith

	when 0x5D then
		opcstr:="mins"
		goto doarith

	when 0x5E then					!divss/divsd
		opcstr:="divs"
		goto doarith

	when 0x5F then
		opcstr:="maxs"
		goto doarith


	when 0x6E then					!mov X/MM, REG/MEM
		decodeaddr(1)
		opsize:=(rex iand wmask|8|4)
		genstr((opsize=4|"movd "|"movq "))
		if sizeoverride then		!xmm
			genstr(strxmm(rmreg))
		else
			genstr(strmmx(rmreg))
		fi
		genstr(", ")
		printaddrmode()

	when 0x6F then					!movdqa/dqu, X/MEM, X/X
		decodeaddr(1)
		opsize:=16
		if sizeoverride then		!66
			genstr("movdqa ")
		elsif f3override then		!F3
			genstr("movdqu ")
		else
			genstr("No 66/F3 ")
		fi
		genstr(strxmm(rmreg))
		genstr(", ")
		printaddrmode(1)

	when 0x7E then					!mov REG/MEM, X/MM
		decodeaddr(1)
		if f3override then
			opsize:=8
			genstr("movq ")
			genstr(strxmm(rmreg))
			genstr(", ")
			printaddrmode(1)
		elsif rex iand wmask then
			opsize:=8
			genstr("movq ")
			printaddrmode()
			genstr(", ")
			genstr(strxmm(rmreg))
		else
			opsize:=4
			genstr("movd ")
			printaddrmode()
			genstr(", ")
			if sizeoverride then		!xmm
				genstr(strxmm(rmreg))
			else
				genstr(strmmx(rmreg))
			fi
		fi

	when 0x7F then					!movdqa/dqu, MEM/X
		decodeaddr(1)
		opsize:=16
		if sizeoverride then		!66
			genstr("movdqa ")
		elsif f3override then		!F3
			genstr("movdqu ")
		else
			genstr("No 66/F3 ")
		fi
		printaddrmode(1)
		genstr(", ")
		genstr(strxmm(rmreg))

	when 0x80..0x8F then			!long rel jumps
		genstr("[long] j")
		genstr(condnames[opc iand 15])
		genstr(" ")
		if sizeoverride then
			genintd(readint16())
		else
			genintd(readint32())
		fi

	when 0x90..0x9F then
		decodeaddr(0)
		genstr("set")
		genstr(condnames[opc iand 15])
		genstr(" ")
		getsilx(basereg)
		printaddrmode()

	when 0xAF then
		decodeaddr(1)
		genstr("imul ")
		genstr(strreg(rmreg,opsize))
		genstr(", ")
		printaddrmode()

	when 0xB6, 0xB7, 0xBE, 0xBF then
		decodeaddr(1)
!	opsize:=4
		genstr((opc<0xBE|"movzx "|"movsx "))
		genstr(strreg(rmreg,opsize))
		genstr(", ")
		opsize:=(opc iand 1|2|1)
		printaddrmode()

	when 0xB8 then
		decodeaddr(1)
		genstr("popcnt ")
		genstr(strreg(rmreg,opsize))
		genstr(", ")
		printaddrmode()

	when 0xBC, 0xBD then
		decodeaddr(1)
		genstr((opc=0xBC|"bsf "|"bsr "))
		genstr(strreg(rmreg,opsize))
		genstr(", ")
		printaddrmode()

	when 0xD6 then
		decodeaddr(1)
		opsize:=8
		genstr("movq ")
		printaddrmode(1)
		genstr(",")
		genstr(strxmm(rmreg))	

	when 0xDB then					!PAND
		decodeaddr(1)
		genstr("pand ")
		genstr(strxmm(rmreg))
		genstr(", ")
		opsize:=8	!(sizeoverride|8|4)
		printaddrmode(1)

	when 0xEF then					!PXOR
		decodeaddr(1)
		genstr("pxor ")
		genstr(strxmm(rmreg))
		genstr(", ")
		opsize:=8	!(sizeoverride|8|4)
		printaddrmode(1)


	else
	error::
		genstr("Unknown opcode 2-byte opcode: 0F ")
    genhex(opc)
	endswitch
end

proc decodeaddr(int w=0)=
!codeptr points to modrm byte, with possible sib and/or disp following
!decode modrm, sib and disp
!store result in amode::
! basereg		0 when not used
! indexreg
! scale			1,2,4,8 factor for indexreg
! offset		0, or any offset or abs address
! addrmode		rm-code
!the function returns the xxx value (middle part of modrm byte)
	int modrm,xxx,mode,sib,rm

	basereg:=indexreg:=0
	scale:=1
	offset:=0
	if w then
		opsize:=(sizeoverride|2|4)
		if rex iand wmask then opsize:=8 fi
	else
		opsize:=1
	fi

	modrm:=codeptr++^

	mode:=modrm>>6
	xxx:=(modrm>>3) iand 7
	rm:=modrm iand 7

	if mode=3 then		!plain register access
		basereg:=rm+1
		addrmode:=amreg
	elsif rm<>4 then				!not esp; no sib
		if mode=0 and rm=5 then		![ebp] is actually [rip+disp]
			offset:=readint32()		!
			addrmode:=ammem

		else
			basereg:=rm+1
			addrmode:=ammem
			case mode
			when 1 then
				offset:=readsbyte()
			when 2 then
				offset:=readint32()
			esac
		fi
	else			!sib follows
		addrmode:=ammem
		sib:=readbyte()
		indexreg:=((sib>>3) iand 7)+1
		basereg:=(sib iand 7)+1
		scale:=(sib>>6+1|1,2,4,8|0)

		if mode=0 and basereg=rframe and indexreg=rstack then	!no base/index regs, only d32 disp
			indexreg:=basereg:=0
			offset:=readint32()

		elsif mode=0 and basereg=rframe  then	!no base/index regs, only d32 disp
			basereg:=0
			offset:=readint32()

		elsif mode=0 and indexreg=rstack then	!no index register, only base; no disp
			indexreg:=0

		else
			case mode
			when 1 then
				offset:=readsbyte()
			when 2 then
				offset:=readint32()
			esac
			if indexreg=rstack then				!stack means no index reg
				indexreg:=0
			fi
		fi

	fi

	if basereg and rex iand bmask then basereg+:=8 fi
	if indexreg and rex iand xmask then indexreg+:=8 fi

	rmreg:=xxx+1
	if rex iand rmask then rmreg+:=8 fi
	rmopc:=xxx
end

function readbyte:int=
	return codeptr++^
end

function readsbyte:int=
	return (ref int8(codeptr++))^
end

function readword16:word=
	word a
	a:=ref word16(codeptr)^
	codeptr+:=2
	return a
end

function readint16:int=
	int a
	a:=ref int16(codeptr)^
	codeptr+:=2
	return a
end

function readword32:word=
	word a
	a:=ref word32(codeptr)^
	codeptr+:=4
	return a
END

function readint32:int=
	int a
	a:=ref int32(codeptr)^
	codeptr+:=4
	return a
END

function readint64:int64=
	int64 a
	a:=ref int64(codeptr)^
	codeptr+:=8
	return a
END

function getreg(int regcode,upper)int=
	if upper then
		return regcode+8+1
	fi
	return regcode+1
end

global function strreg(int reg,opsize)ichar=
static []ichar regnames8=("al","cl","dl","bl","spl","bpl","sil","dil",
						"r8b","r9b","r10b","r11b","r12b","r13b","r14b","r15b",
				"ah","bh","ch","dh")

static []ichar regnames16=("ax","cx","dx","bx","sp","bp","si","di",
						"r8w","r9w","r10w","r11w","r12w","r13w","r14w","r15w")

static []ichar regnames32=("eax","ecx","edx","ebx","esp","ebp","esi","edi",
						"r8d","r9d","r10d","r11d","r12d","r13d","r14d","r15d")

static []ichar regnames64=("rax","rcx","rdx","rbx","rsp","rbp","rsi","rdi",
						"r8","r9","r10","r11","r12","r13","r14","r15")

static []ichar mregnames8=("B0","B10","B11","B4","B15","B14","B5","B3",
						"B12","B13","B1","B2","B6","B7","B8","B9",
					"B16","B18","B19","B17")

static []ichar mregnames16=("W0","W10","W11","W4","Wsp","Wbp","W5","W3",
						"W12","W13","W1","W2","W6","W7","W8","W9")

static []ichar mregnames32=("A0","A10","A11","A4","Astack","Aframe","A5","A3",
						"A12","A13","A1","A2","A6","A7","A8","A9")

static []ichar mregnames64=("D0","D10","D11","D4","Dstack","Dframe","D5","D3",
						"D12","D13","D1","D2","D6","D7","D8","D9")

	if reg=0 then return "<>" fi

	if showmregs then
		case opsize
		when 1 then return mregnames8[reg]
		when 2 then return mregnames16[reg]
		when 4 then return mregnames32[reg]
		when 8 then return mregnames64[reg]
		esac
	else
		case opsize
		when 1 then return regnames8[reg]
		when 2 then return regnames16[reg]
		when 4 then return regnames32[reg]
		when 8 then return regnames64[reg]
		esac
	fi
	return ""
end

function strfreg(int freg)ichar=
!freg is 0-based
	static []ichar fregnames=("st0","st1","st2","st3","st4","st5","st6","st7")
	return fregnames[freg]
end

proc printaddrmode(int xmm=0)=
	static [100]char str
	ichar plus
	int addrsize

	genstr(" ")

	case addrmode
	when amreg then
		if xmm then
			genstr(strxmm(basereg))
		else
			getsilx(basereg)
			genstr(strreg(basereg,opsize))
		fi
		return
	esac

	case opsize
	when 1 then genstr("byte ")
	when 2 then genstr("word ")
	when 4 then genstr("dword ")
	when 8 then genstr("qword ")
	when 10 then genstr("tword ")
	when 16 then genstr("oword ")
	else
	CPL "///OPSIZE",opsize
	esac

	genstr("[")
	plus:=""
	addrsize:=(addroverride|4|8)

	if basereg then
		genstr(strreg(basereg,addrsize))
		plus:="+"
	fi
	if indexreg then
		genstr(plus)
		genstr(strreg(indexreg,addrsize))
		if scale>1 then
			genstr("*")
			genintd(scale)
		fi
		plus:="+"
	fi

	if offset or (basereg=0 and indexreg=0) then
!	print plus,,offset,"<",ref void(offset),,">"
		if basereg=0 and indexreg=0 then
			genhex(offset)
		else
			if offset>0 then genstr(plus) fi
			genintd(offset)
		fi
	fi
	genstr("]")
	if addrmode=amrel then genstr("+RIP") fi
end

proc genstr(ichar s)=
	strcat(&.deststr,s)
end

proc genintd(int64 a)=
	genstr(strint(a))
end

proc genhex(int64 a)=
	genstr(strint(a,"h"))
end

function readimm:int=
!read signed offset according to opsize

	case opsize
	when 1 then return readsbyte()
	when 2 then return readint16()
	when 4,8 then return readint32()			!64-bit uses 32-bit immediate
	esac
	return 0
end

function readimm8:int64=
!like readimm but can 8 bytes too
	if opsize<8 then return readimm() fi
	return readint64()
end

function strxmm(int reg)ichar=
	static [32]char str
	print @&.str,"xmm",,reg-1
	return &.str
end

function strmmx(int reg)ichar=
	static [32]char str

	print @&.str,"mmx",,reg-1
	return &.str
end

proc decode8087(int ttt)=
	byte bb
	int longopc,freg,shortopc,code

	bb:=codeptr++^			!following byte

	longopc:=ttt<<8+bb		!bottom 11 bits of 2-bytes opcode
	freg:=(bb iand 7)+1		!where bb specifies a register in bottom 3 bits

!first look at all dedicated opcodes before treating bb as modrm byte

	case longopc
	when 2x'110'1101'1001 then genstr("fcompp")
	when 2x'001'1110'0100 then genstr("ftst")
	when 2x'001'1110'0101 then genstr("fxam")
	when 2x'001'1110'1110 then genstr("fldz")
	when 2x'001'1110'1000 then genstr("fld1")
	when 2x'001'1110'1011 then genstr("fldpi")
	when 2x'001'1110'1001 then genstr("fldl2t")
	when 2x'001'1110'1010 then genstr("fldl2e")
	when 2x'001'1110'1100 then genstr("fldlg2")
	when 2x'001'1110'1101 then genstr("fldln2")

	when 2x'001'1111'1010 then genstr("fsqrt")
	when 2x'001'1111'1110 then genstr("fsin")
	when 2x'001'1111'1111 then genstr("fcos")
	when 2x'001'1111'1011 then genstr("fsincos")
	when 2x'001'1111'1101 then genstr("fscale")
	when 2x'001'1111'1000 then genstr("fprem")
	when 2x'001'1111'1100 then genstr("frndint")
	when 2x'001'1111'0100 then genstr("fxtract")
	when 2x'001'1110'0001 then genstr("fabs")
	when 2x'001'1110'0000 then genstr("fchs")

	when 2x'001'1111'0010 then genstr("fptan")
	when 2x'001'1111'0011 then genstr("fpatan")
	when 2x'001'1111'0000 then genstr("f2xm1")
	when 2x'001'1111'0001 then genstr("fyl2x")
	when 2x'001'1111'1001 then genstr("fyl2xp1")

	when 2x'011'1110'0011 then genstr("finit")
	when 2x'011'1110'0000 then genstr("feni")
	when 2x'011'1110'0001 then genstr("fdisi")

	when 2x'011'1110'0010 then genstr("fclex")

	when 2x'001'1111'0111 then genstr("fincstp")
	when 2x'001'1111'0110 then genstr("fdecstp")
	when 2x'001'1101'0000 then genstr("fnop")

	elsecase longopc iand 2x'111'11111'000			!ignore bottom 3 bits

	when 2x'001'11000'000 then genstr("fld "); genstr(strfreg(freg))
	when 2x'101'11010'000 then genstr("fst "); genstr(strfreg(freg))
	when 2x'101'11011'000 then genstr("fstp "); genstr(strfreg(freg))
	when 2x'001'11001'000 then genstr("fxch "); genstr(strfreg(freg))
	when 2x'000'11010'000 then genstr("fcom "); genstr(strfreg(freg))
	when 2x'000'11011'000 then genstr("fcomp "); genstr(strfreg(freg))
	when 2x'101'11000'000 then genstr("ffree "); genstr(strfreg(freg))

	elsecase longopc iand 2x'001'11111'000			!ignore bottom 3 bits and top 2

	when 2x'000'11000'000 then do87arith("fadd",ttt,freg)

	when 2x'000'11100'000 then do87arith("fsub",ttt,freg)
	when 2x'000'11101'000 then do87arith("fsubr",ttt,freg)

	when 2x'000'11001'000 then do87arith("fmul",ttt,freg)

	when 2x'000'11110'000 then do87arith("fdiv",ttt,freg)
	when 2x'000'11111'000 then do87arith("fdivr",ttt,freg)

	else	!finally, have to deal with modrm etc
		--codeptr					!put back modrm byte
		decodeaddr(0)			!code is middle bits
		shortopc:=ttt<<3 + rmopc

		case shortopc				!look at combination of ttt and code (middle bits of modrm)
		when 2x'111'101 then do87mem("fld",4)
		when 2x'011'101 then do87mem("fld",5)
		when 2x'111'100 then do87mem("fldbcd")

		when 2x'111'111 then do87mem("fstp",4)
		when 2x'011'111 then do87mem("fstp",5)
		when 2x'111'110 then do87mem("fstpbcd")

		when 2x'001'101 then do87mem("fldcw")
		when 2x'001'111 then do87mem("fstcw")
		when 2x'101'111 then do87mem("fstsw")

		when 2x'001'110 then do87mem("fstenv")
		when 2x'001'100 then do87mem("fldenv")
		when 2x'101'110 then do87mem("fsave")
		when 2x'101'100 then do87mem("frstor")

		elsecase shortopc iand 2x001'111		!ignore top two bits (mf code)

		when 2x'001'000 then do87mem("fld",ttt>>1)
		when 2x'001'010 then do87mem("fst",ttt>>1)
		when 2x'001'011 then do87mem("fstp",ttt>>1)
		when 2x'000'010 then do87mem("fcom",ttt>>1)
		when 2x'000'011 then do87mem("fcomp",ttt>>1)
		when 2x'000'000 then do87mem("fadd",ttt>>1)
		when 2x'000'100 then do87mem("fsub",ttt>>1)
		when 2x'000'101 then do87mem("fsubr",ttt>>1)
		when 2x'000'001 then do87mem("fmul",ttt>>1)
		when 2x'000'110 then do87mem("fdiv",ttt>>1)
		when 2x'000'111 then do87mem("fdivr",ttt>>1)

		else
			genstr("UNKNOWN x87 OPCODE")
		esac
	esac

end

proc do87arith(ichar opcstr, int ttt,freg)=
	int d, p

	d:=ttt iand 2x100		!d=0:  to st0; d<>0: to freg
	p:=ttt iand 2x010		!p<>0: pop after operation

	genstr(opcstr)
	if p then
		genstr("p")
	fi
	genstr(" ")

	if d=0 then
		genstr("st0, ")
    genstr(strfreg(freg))
	else
    genstr(strfreg(freg))
		genstr(", st0")
	fi
end

proc do87mem(ichar opcstr,int mf=-1)=
!mf has values 0,1,2,4 for type and width, when used; but also 4 for i64
	genstr("f")

	case mf
	when 2x'00 then opsize:=4
	when 2x'01 then genstr("i"); opsize:=4
	when 2x'10 then opsize:=8
	when 2x'11 then genstr("i"); opsize:=2
	when 4 then genstr("i"); opsize:=8
	when 5 then opsize:=10
	esac
	genstr(opcstr+1)

	genstr(" ")
	printaddrmode()
end

proc getsil(int &reg)=
!for certain byte-reg combinations, convert regs ah,ch,dh,bh to spl,bpl,sil,dil
	if opsize=1 and not rex and reg>=5 and reg<=8 then
		reg+:=12				!5..8 => 17..20
	fi
end

proc getsilx(int &reg)=
!as getsil but used for basereg, which must have addrmode=amreg
	if addrmode=amreg and opsize=1 and rex=0 and reg>=5 and reg<=8 then
		reg+:=12				!5..8 => 17..20
	fi
end
=== aa_genss.m 76/77 ===
import* aa_common

const wmask = 2x1000				!1 means 64-bit operand size
const rmask = 2x0100				!extends mod/rm reg field
const xmask = 2x0010				!extends sib index field
const bmask = 2x0001				!extends mod/rm r/m field, also sib base field

int rex
int sizeoverride					!32=>16 switch
int addroverride					!32=>16 switch
int f2override						!xmm regs
int f3override						!xmm regs

ref opndrec extraparam

int currseg=0
ref dbuffer currdata				!copy of ss_idata or ss_code
ref relocrec currrelocs
int nrelocs

ref mclrec currmcl


global proc genss=
int index
ref mclrec m

ss_zdatalen:=0
ss_zdata:=buffercreate()
ss_idata:=buffercreate()
ss_code:=buffercreate()
ss_idatarelocs:=nil
ss_coderelocs:=nil
ss_nsymbols:=0

switchseg(code_seg)

alineno:=9999
extraparam:=nil

m:=mccode
index:=0

while m do
	alineno:=m^.lineno

	doinstr(m,++index)
	m:=m^.nextmcl
od

switchseg(0)					!update ss_currrelocs etc

if bufferlength(ss_zdata) then
	gerror("Zdata contains code or data")
fi

end

proc doinstr(ref mclrec m,int index)=
ref opndrec a,b
ref strec d,e
int x,offset,shortjmp,n

CURRMCL:=M
buffercheck(currdata)

rex:=sizeoverride:=addroverride:=f2override:=f3override:=0

!CPL "DOINST",MCLNAMES[M.OPCODE], M.LINENO,=CURRDATA.ALLOC

a:=m^.a
b:=m^.b

switch m^.opcode
when m_label then
	d:=a^.labeldef

	d^.reftype:=back_ref
	d^.segment:=currseg
	d^.offset:=getcurrdatalen(6)

	if d^.symbol=exportedsym then
		getstindex(d)
	fi

	dofwdrefs(d)

when m_call then
	do_call(a)

when m_jmp then
	do_jmp(a,m)

when m_jmpcc then
	offset:=getrel32(b^.labeldef,getcurrdatalen(7)+1)

	if offset<0 then			!backjump
		if offset<-126 then
			genbyte(0x0F)
			genbyte(0x80+a^.value)
			gendword(offset-4)
		else
			genbyte(0x70+m^.a^.value)
			genbyte(offset)
		fi
	else
		shortjmp:=checkshortjump(m,b^.labeldef)
		if not shortjmp then
			genbyte(0x0F)
			genbyte(0x80+a^.value)
			genrel32(b)
		else
			genbyte(0x70+a^.value)
			genrel8(b)
		fi
	fi

when m_db then
	genopnd(a,1)
when m_dw then
	genopnd(a,2)
when m_dd then
	genopnd(a,4)
when m_dq then
	genopnd(a,8)

when m_ddoffset then
	genrel32(a)

when m_segment then
	switchseg(a^.value)
when m_nop, m_halt then
	genbyte(mclcodes[m^.opcode])

when m_cbw then
	genbyte(0x66)
	genbyte(0x98)

when m_cwd then
	genbyte(0x66)
	genbyte(0x99)

when m_cdq then
	genbyte(0x99)

when m_cqo then
	genbyte(0x48)
	genbyte(0x99)

when m_ret then
	genbyte(0xC3)

when m_leave then
	genbyte(0xC9)

when m_retn then
	if a^.mode<>a_imm then gerror("retn?") fi
	genbyte(0xC2)
	genword(a^.value)

when m_push then
	do_push(a)

when m_pop then
	do_pop(a)

when m_inc, m_dec then
!CPL "INC/DEC"
	do_inc(a,mclcodes[m^.opcode])

when m_neg, m_not, m_mul, m_imul, m_div, m_idiv then
	do_neg(a,mclcodes[m^.opcode])

when m_add, m_sub, m_and, m_or, m_xor, m_adc, m_sbb, m_cmp then
	do_arith(a,b, mclcodes[m^.opcode])

when m_mov then
	do_mov(a,b)

when m_lea then
	do_lea(a,b)

when m_movsx then
	do_movsx(a,b,0xBE)

when m_movzx then
	do_movsx(a,b,0xB6)

when m_movsxd then
	do_movsxd(a,b)

when m_xchg then
	do_exch(a,b)

when m_imul2 then
	do_imul2(a,b)

!when m_imul3 then
!	do_imul3(a,b[1],b[2])

when m_resb, m_resw, m_resd, m_resq then
	if a^.mode=a_imm then
		n:=a^.value*mclcodes[m^.opcode]
		buffercheck(currdata,n)
		case currseg
		when code_seg then
			to n do genbyte(0x90) od
		when idata_seg then
			to n do genbyte(0) od
		else
			ss_zdatalen+:=n
		esac
	
	else
		gerror("resb?")
	fi

when m_align then
	if a^.mode=a_imm then
		x:=a^.value
!		if x not in 1..16384 then gerror("align2") fi
		if x<1 or x>16384 then gerror("align2") fi
		if currseg<>zdata_seg then
			while bufferlength(currdata) rem x do genbyte((currseg=code_seg|0x90|0)) od
		else
			while ss_zdatalen rem x do	++ss_zdatalen od
		fi
	else
		gerror("align?")
	fi

when m_shl,m_shr,m_sar,m_rol,m_ror,m_rcl,m_rcr then
	do_shift(a,b,mclcodes[m^.opcode])

when m_test then
	do_test(a,b)

when m_loopcx, m_loopz, m_loopnz then
	do_loop(a,mclcodes[m^.opcode])

when m_jecxz then
	do_jcxz(a,4)

when m_jrcxz then
	do_jcxz(a,8)

when m_xlat then
	genbyte(0xD7)

when m_setcc then
	do_setcc(a,b)

when m_movd then
	do_movxmm(a,b,4)

when m_movq then
	do_movxmm(a,b,8)

when m_addss, m_subss, m_mulss, m_divss, m_sqrtss, m_minss, m_maxss then
	do_arithxmm(a,b,0xF3,mclcodes[m^.opcode])

when m_addsd, m_subsd, m_mulsd, m_divsd, m_sqrtsd, m_minsd, m_maxsd then
	do_arithxmm(a,b,0xF2,mclcodes[m^.opcode])

when m_andps,m_xorps then
	do_logicxmm(a,b,mclcodes[m^.opcode],4)

when m_andpd,m_xorpd, m_pand, m_pxor then
	do_logicxmm(a,b,mclcodes[m^.opcode],8)

when m_pcmpistri,m_pcmpistrm then
	do_pcmpistri(a,b,m.c,mclcodes[m.opcode])

when m_comiss then
	do_arithxmm(a,b,0,0x2F)

when m_comisd then
	do_arithxmm(a,b,0x66,0x2F)

when m_cvtss2sd then
	do_convertfloat(a,b,0xF3)

when m_cvtsd2ss then
	do_convertfloat(a,b,0xF2)

when m_cvtss2si then
	do_fix(a,b,0xF3,0x2D)

when m_cvtsd2si then
	do_fix(a,b,0xF2,0x2D)

when m_cvttss2si then
	do_fix(a,b,0xF3,0x2C)

when m_cvttsd2si then
	do_fix(a,b,0xF2,0x2C)

when m_cvtsi2ss then
	do_float(a,b,0xF3)

when m_cvtsi2sd then
	do_float(a,b,0xF2)

when m_param then
	extraparam:=a

when m_cmovcc then
	do_cmovcc(a,extraparam,b)

when m_fsqrt,m_fsin,m_fcos,m_fsincos,m_fptan, m_fpatan,m_fabs,m_fchs then
	genbyte(0xD9)
	genbyte(mclcodes[m^.opcode])

when m_fld, m_fst, m_fstp then
	do_fmem(a,1,mclcodes[m^.opcode])

when m_fild, m_fist, m_fistp then
	do_fmem(a,0,mclcodes[m^.opcode])

when m_fadd, m_fsub, m_fmul, m_fdiv then
	genbyte(0xDE)
	genbyte(mclcodes[m^.opcode])

when m_cmpsb then
	genbyte(0xA6)

when m_cmpsw then
	genbyte(0x66)
	genbyte(0xA7)
when m_cmpsd then
	genbyte(0xA7)
when m_cmpsq then
	genbyte(0x48)
	genbyte(0xA7)

when m_rdtsc then		!single opcodes that need a 0x0F prefix
	genbyte(0x0F)
	genbyte(mclcodes[m^.opcode])

when m_movdqa, m_movdqu then
	do_movdqx(a,b,mclcodes[m^.opcode])

when m_finit then
	genbyte(0xDB)
	genbyte(0xE3)

when m_fldz, m_fld1, m_fldpi, m_fld2t, m_fld2e, m_fldlg2, m_fldln2 then
	genbyte(0xD9)
	genbyte(mclcodes[m^.opcode])

when m_popcnt then
	do_popcnt(a,b)

when m_bsf, m_bsr then
	do_bsf(a,b,mclcodes[m.opcode])

else
	println "*** CAN'T DO OPCODE",mclnames[m^.opcode],"line",alineno
endswitch

end

proc genbyte(int x)=
currdata^.pcurr++^:=x
end

proc genword(int x)=
addword(currdata,x)
end

proc gendword(int x)=
adddword(currdata,x)
end

proc genqword(int64 x)=
addqword(currdata,x)
end

proc genopnd(ref opndrec a,int size=0)=
!generate any label/offset/label+offset/immstring part
!ignore reg etc
!any labels, assume abs addresses of 32 or 64 bits
ref char s
int64 x
int length

if size=0 then size:=a^.size fi

switch a^.mode
when a_imm,a_mem then
when a_string then
	s:=a^.svalue
	length:=strlen(s)
	if length>100 then
		buffercheck(currdata,max(1024,length+1))
	fi
	while s^ do
		genbyte(s++^)
	od
	return
else
	gerror("GENOPND/bad opnd")
endswitch

if a^.labeldef and size<=2 then
	gerror("8/16-BIT RELOC")
fi

case size
when 1 then
	genbyte(a^.value)
when 2 then
	genword(a^.value)
when 4 then
	if a^.labeldef then
		genabs32(a)
	else
		if a^.valtype then		!was real
			gendword(getr32bits(a.xvalue))
		else
			gendword(a.value)
		fi
	fi
when 8 then
	if a^.labeldef then
		genabs64(a)
	else
		x:=a^.value
		if a^.valtype then
			genqword(int64@(x))
		else
			genqword(x)
		fi
	fi
esac
end

proc addrelocitem(int reloctype, ref strec d)=
ref relocrec r
int stindex, adjust

stindex:=getstindex(d)

adjust:=4
if reloctype=addr64_rel then adjust:=8 fi

r:=pcm_alloc(relocrec.bytes)
r^.nextreloc:=currrelocs
r^.reloctype:=reloctype
r^.offset:=getcurrdatalen(1)-adjust
r^.stindex:=stindex

++nrelocs
currrelocs:=r
end

function getstindex(ref strec d)int=
!retrieve existing obj st index, or create new one
if d^.stindex=0 then
	if ss_nsymbols>=ss_symboltablesize then
		extendsymboltable()
!		cpl ss_nsymbols
!		gerror("genss: too many symbols")
	fi
	d^.stindex:=++ss_nsymbols
	ss_symboltable^[d^.stindex]:=d
fi
return d^.stindex
end

proc genrel32(ref opndrec a)=
!used by call/longjmp/ddoffset
ref strec d

d:=a^.labeldef

if d=nil then				!constant
	gendword(a^.value)
	return
fi

case d^.reftype
when back_ref then
	if d^.segment<>currseg then
		gerror("Rel label across segments")			!might be Ok if treated as external?
	fi
	gendword(d^.offset-(getcurrdatalen(2)+4))
when fwd_ref then
	d^.fwdrefs:=addfwdref(d^.fwdrefs,getcurrdatalen(3),rel32_rel)
	gendword(0)
else								!external symbol
	gendword(a^.value)				!this is probably just zero
	addrelocitem(rel32_rel,d)
esac
end

proc genabs32(ref opndrec a)=
!absolute refs to labels
ref strec d

d:=a^.labeldef

!CPL "GENABS32",D.NAME,REFTYPENAMES[D.REFTYPE]

case d^.reftype
when back_ref then
	gendword(d^.offset+a^.value)
	addrelocitem(addr32_rel,d)

when fwd_ref then
	d^.fwdrefs:=addfwdref(d^.fwdrefs,getcurrdatalen(4),addr32_rel,currseg)
	gendword(a^.value)
	addrelocitem(addr32_rel,d)

else								!external symbol
	gendword(a^.value)				!this is probably just zero
	addrelocitem(addr32_rel,d)
esac
end

proc genabs64(ref opndrec a)=
!absolute refs to labels
ref strec d

d:=a^.labeldef

!CPL "GENABS64",=D.OFFSET, A.VALUE
!CPL "GENABS64",=D.OFFSET+A.VALUE

case d^.reftype
when back_ref then
	genqword(d^.offset+a^.value)
	addrelocitem(addr64_rel,d)

when fwd_ref then
	d^.fwdrefs:=addfwdref(d^.fwdrefs,getcurrdatalen(5),addr32_rel,currseg)
	genqword(a^.value)
	addrelocitem(addr64_rel,d)

else								!external symbol
	genqword(a^.value)				!this is probably just zero
	addrelocitem(addr64_rel,d)
esac
end

function getrel32(ref strec d,int offset)int=
!get rel difference between offset in this segment, and label d

if d^.reftype=back_ref then					!defined earlier in this segment
	if d^.segment<>currseg then
		gerror("Rel label across segments2")
	fi
	return d^.offset-(offset+1)
else
	return int32.maxvalue
fi
end

proc dofwdrefs(ref strec d)=
!label d has been encountered
!update any fwd refs
!assume inside same offset, at least for rel-32 which only works in text segment
!	d^.fwdrefs append:=(getcurrdatalen(),rel32_rel)
ref fwdrec f
int offset, seg
ref byte p8
ref int32 p32
ref int64 p64
ref dbuffer data

if d^.fwdrefs=nil then return fi

f:=d^.fwdrefs

while f do
	offset:=f^.offset

	case f^.reltype
	when rel32_rel then
		p32:=bufferelemptr(currdata,offset)

		p32^:=d^.offset-offset-4

	when addr32_rel,addr64_rel then
		case f^.seg
		when code_seg then data:=ss_code
		when zdata_seg then gerror("Fwd ref in zdata")
		when idata_seg then data:=ss_idata
		esac

		p32:=bufferelemptr(data,offset)
		if f^.reltype=addr32_rel then
			p32^:=p32^+d^.offset
		else
			p64:=cast(p32)
			p64^:=p64^+d^.offset
		fi
	when rel8_rel then
		p8:=bufferelemptr(currdata,offset)
		p8^:=d^.offset-offset-1
	else
CPL RELOCNAMES[F^.RELTYPE]
		GERROR("DOFWDREFS/CAN'T DO RELTYPE")
	esac

	f:=f^.nextfwd

od
end

proc genrex=
	if sizeoverride then
		genbyte(0x66)
	fi
	if addroverride then
		genbyte(0x67)
	fi
	if rex then
		if rex<0x40 then
			genbyte(0x40+rex)
		else
			genbyte(rex)
		fi
	fi
end

function isbytesized(int64 x)int=
return -128<=x<=127
end

function isdwordsized(int64 x)int=
return int32.minvalue<=x<=int32.maxvalue
end

proc do_push(ref opndrec a)=
int code,am

	case a^.mode
	when a_reg then
		if a^.size<>8 then gerror("pushreg not 64-bit") fi
		code:=regcodes[a^.reg]
		if code>=8 then
			rex :=bmask
			code iand:=7
		fi
		genrex()
		genbyte(0x50+code)

	when a_imm then
		if a^.labeldef then
			genbyte(0x68)
			genopnd(a,4)
		elsif isbytesized(a^.value) then
			genbyte(0x6A)
			genbyte(a^.value)
		elsif isdwordsized(a^.value) then
			genbyte(0x68)
			gendword(a^.value)
		else
			gerror("push imm value too large")
		fi

	when a_mem then
		if a^.size<>8 then gerror("push not 64-bit") fi
		am:=genrm(a,6)
		genrex()
		genbyte(0xFF)
		genamode(a,am)
	else
		gerror("push opnd?")
	esac
end

proc do_pop(ref opndrec a)=
int code, am

	case a^.mode
	when a_reg then
		if a^.size<>8 then gerror("popreg not 64-bit") fi
		code:=regcodes[a^.reg]
		if code>=8 then
			rex :=bmask
			code iand:=7
		fi
		genrex()
		genbyte(0x58+code)

	when a_mem then
		if a^.size<>8 then gerror("pop not 64-bit") fi
		am:=genrm(a,0)
		genrex()
		genbyte(0x8F)
		genamode(a,am)
	else
		gerror("pop opnd?")
	esac
end

proc do_inc(ref opndrec a,int code)=
!inc/dec
int opc, am

	opc:=(a^.size=1|0xFE|0xFF)

	case a^.mode
	when a_reg, a_mem then
		am:=genrm(a,code)
		checkhighreg(a)
		setopsize(a)
		genrex()
		genbyte(opc)
		genamode(a,am)

	else
		gerror("inc/opnd?")
	esac
end

proc do_neg(ref opndrec a,int code)=
!neg/not/mul/imul/div/idiv
int opc, am

	opc:=(a^.size=1|0xF6|0xF7)

	case a^.mode
	when a_reg, a_mem then
		am:=genrm(a,code)
		checkhighreg(a)
		setopsize(a)
		genrex()
		genbyte(opc)
		genamode(a,am)

	else
		gerror("neg/div/etc opnd?")
	esac
end

proc genamode(ref opndrec a,int am)=
int sib,mode,dispsize

sib:=am>>16

mode:=(am>>8)iand 255
dispsize:=am iand 255

genbyte(mode)			!modrm byte

if sib>=0 then		!sib byte
	genbyte(sib)
fi
case dispsize			!disp bytes
when 0 then
when 1 then
	genbyte(a^.value)
when 4 then
	if a^.labeldef then
		genabs32(a)
	else
		gendword(a^.value)
	fi
else
	gerror("genamode size 2/8")
esac
end

function makemodrm(int mode,opc,rm)int=
	return mode<<6+opc<<3+rm
end

proc setopsize(ref opndrec a)=
case a^.size
when 1 then			!assume set via specific opcodes
when 2 then			!override default 4 bytes
	sizeoverride:=1
when 8 then			!override default 4 bytes
    rex ior:=wmask
when 4 then			!assume 4 bytes is default
else
	gerror("Operand size not set")
esac
end

proc setaddrsize(ref opndrec a)=
if a^.mode=a_mem and a^.addrsize=4 then
	addroverride:=1
fi
end

function getdispsize(ref opndrec a,int mand=1)int=
!look at imm/mem displacement, and return 0,1 or 4
!0 is returned when no disp is needed (no labeldef and offset is zero)
!unless mand=1 then 1 is returned

if a^.labeldef then return 4 fi
if a^.value or mand then
	return (isbytesized(a^.value)|1|4)
else
	return 0
fi
end

function genrm(ref opndrec a,int opc)int=
!work out modrm, and possible sib and address offset sequence from
!operand a (a_mem) and middle bits x (0..7) of the modrm byte
!returns: (modrm, sib, dispsize)
! sib = -1 means no sib byte
! dispsize is 0 (no disp), 1 (8-bit), or 4 (32-bit)
!will also set rex bits as needed
!!                         0  1  2  3  4  5  6  7
!static var scaletable=(0: 0, 0, 1, 0, 2, 0, 0, 3)
!                       1  2  3  4  5  6  7  8
	static []int scaletable=( 0, 1, 0, 2, 0, 0, 0, 3)
	int mode, rm, scale, dispsize, needsib, sib, index, base
	int reg, regix, code

	mode:=rm:=0				!modrm is (mode, x, rm), of (2,3,3) bits
	scale:=0				!0=modrm only; 1/2/4/8 means sib used
	dispsize:=0
	needsib:=0
	sib:=-1

	if a^.mode=a_mem and a^.addrsize=4 then
		addroverride:=1
	fi

	case a^.mode
	when a_reg then			!modrm can only ref to a single register
		code:=getregcodeb(a^.reg)
!CPL "GENRM/REG",=A.REG,=CODE, =MAKEMODRM(3,OPC,CODE):"H",
! =WORD(MAKEAM(MAKEMODRM(3,OPC,CODE),-1,0)):"H"
		return makeam(makemodrm(3,opc,code), sib, dispsize)

	when a_mem then

	when a_xreg then
		code:=getregcodebx(a^.reg)
		return makeam(makemodrm(3,opc,code), sib, dispsize)		!NEW

	else
		gerror("genrm not mem")
	esac

	reg:=a^.reg
	regix:=a^.regix

	if reg=regix=0 then						!address only
		mode:=0
		rm:=4
		scale:=1
		index:=4
		base:=5
		dispsize:=4

	elsif a^.scale<=1 and regix=0 then			!simple address mode (no sib)
		dispsize:=getdispsize(a,0)
		if dispsize then
			mode:=(dispsize=1|1|2)
		fi

		rm:=regcodes[reg]

		if rm<>4 and rm<>12 then
			base:=rm
			if (rm=5 or rm=13) and dispsize=0 then
				mode:=1; dispsize:=1
			fi
			index:=0
		else
			index:=4				!means no index
			base:=rm
			scale:=1				!force sib

		fi
	elsif regix and reg=0 then
		dispsize:=4
		mode:=0
		rm:=4
		scale:=(a^.scale|a^.scale|1)
		base:=5
		index:=regcodes[regix]
		if regix=rstack then gerror("Scaled rstack?") fi

	else									!assume regix used; optional reg and disp
!CPL "HERE",=REG,=REGIX,=REGCODES[REG],=REGCODES[REGIX]
		dispsize:=getdispsize(a,0)
		if dispsize then
			mode:=(dispsize=1|1|2)
		fi
		rm:=4

		scale:=(a^.scale|a^.scale|1)
		if reg=0 then
			base:=5
		else
!CPL =REG, =REGCODES[REG]
!			if reg=rframe and dispsize=0 then
			if reg in [rframe,r7] and dispsize=0 then
!CPL "SPECIAL/FRAME/R13"
				mode:=1; dispsize:=1
			fi
			base:=regcodes[reg]
		fi

		if regix=0 then
			index:=4
		else
			index:=regcodes[regix]
		fi

		if regix and not reg then
			dispsize:=4
		fi

		if regix=rstack and scale>1 then gerror("Can't scale rstack") fi

	fi

	if index>=8 then rex ior:= xmask; index iand:=7 fi
	if base>=8  then rex ior:= bmask; base  iand:=7 fi

	if scale then
		sib:=scaletable[scale]<<6 + index<<3 + base
	fi
	rm iand:=7

	return makeam(makemodrm(mode:mode,opc:opc,rm:rm), sib, dispsize)
end

proc genrmbyte(int mode,opc,rm)=
	genbyte(mode<<6+opc<<3+rm)
end

function makeam(int m,s,d)int=
!convert mode, sib, dispsize into 32-bit value::
! ssssssss ssssssss mmmmmmmm dddddddd
!return m<<16+s<<8+d
!note: s can be -1, so allow to extend into sign bit::
return s<<16+m<<8+d
end

proc do_arith(ref opndrec a,b,int code)=
!code is 3-bit 0..7 value indicating which of add, sub, and, or, xor, adc, sbb, cmp
!ops is being done
int am, regcode, opc, dispsize
int64 x

case a^.mode
when a_reg then
	case b^.mode
	when a_reg,a_mem then
		regcode:=getregcoder(a^.reg)
		am:=genrm(b,regcode)
		checkhighreg(a)
		checkhighreg(b)
!		genrex()
		setopsize(a)
		opc:=code<<3 ior (a^.size=1|0x02|0x03)
		genrex()
		genbyte(opc)
		genamode(b,am)

	when a_imm then
doregimm::
		if b^.labeldef then
!			if code not in [0..7] then gerror("non-add arith/label") fi
			if code<0 or code>7 then gerror("non-add arith/label") fi
			if a^.size<4 then gerror("add imm/size") fi
			am:=genrm(a,code)
			setopsize(a)
			genrex()
			genbyte(0x81)
			genamode(a,am)
			genopnd(b,4)
			return

		fi

		x:=b^.value
		dispsize:=1
		if a^.size=1 then
			opc:=0x80
		elsif -128<=x<=127 then
			opc:=0x83
		else
			unless -0x8000'0000 <= x <= 0xFFFF'FFFF then gerror("3:exceeding word32 value") end
			opc:=0x81
			dispsize:=(a^.size=2|2|4)
		fi

		am:=genrm(a,code)
		checkhighreg(a)
		setopsize(a)
		genrex()
		genbyte(opc)
		genamode(a,am)
		case dispsize
		when 1 then genbyte(x)
		when 2 then genword(x)
		when 4 then gendword(x)
		esac

	else
		gerror("ADD reg,???")
	esac

when a_mem then
	case b^.mode
	when a_reg then
		regcode:=getregcoder(b^.reg)
		am:=genrm(a,regcode)
		checkhighreg(b)
		setopsize(b)
		opc:=code<<3 ior (b^.size=1|0x00|0x01)
		genrex()
		genbyte(opc)
		genamode(a,am)

	when a_imm then
		go to doregimm
	else
		gerror("ADD mem,???")
	esac

else
	gerror("Can't add to this opnd")
esac
end

proc do_mov(ref opndrec a,b)=
int regcode, am
int64 value

case a^.mode
when a_reg then
	case b^.mode
	when a_reg, a_mem then
		if a^.size<>b^.size and b^.size then
			gerror("Opnd size mismatch")
		fi
		checkhighreg(a)
		checkhighreg(b)

		regcode:=getregcoder(a^.reg)
		am:=genrm(b,regcode)

		setopsize(a)
		genrex()
		genbyte((a^.size=1|0x8A|0x8B))
		genamode(b,am)

	when a_imm then
		value:=b^.value
		regcode:=getregcodeb(a^.reg)
		if b^.labeldef and a^.size<=2 then gerror("mov imm?") fi
		case a^.size
		when 1 then
			checkhighreg(a)
			case a^.reg
!			when r2,r3,r14,r15 then
			when r5,r3,r14,r15 then
				rex ior:=0x40
			esac
			unless -128<=value<=255 then gerror("exceeding byte value") end
			genrex()
			genbyte(0xB0+regcode)
			genbyte(value)

		when 2 then
!			if value not in -32768..65535 then gerror("exceeding word16 value") fi
			unless -32768<=value<=65535 then gerror("exceeding word16 value") end
			genbyte(0x66)
			genrex()
			genbyte(0xB8+regcode)
			genword(value)
		when 4 then
			if b^.labeldef then
				genrex()
				genbyte(0xB8+regcode)
				genopnd(b,4)
			else
!				unless -0x8000'0000<=value<=0xFFFF'FFFFu then
				unless -0x8000'0000<=value<=u32(0xFFFF'FFFF) then
CPL value,ref void(value)
					gerror("1:exceeding word32 value")
				end
doreg32::
				genrex()
				genbyte(0xB8+regcode)
				gendword(value)
			fi

		else							!assum 8 bytes
			if b^.labeldef then
				rex ior:=wmask
				genrex()
				genbyte(0xB8+regcode)
				genopnd(b,8)
			else
				if value>=0 and value<=0xFFFF'FFFF then
					goto doreg32			!load 32-bit value which is zero-extended to 64
				fi
!there might be short form for negative values that fit into 32 bits, using other opcs
!but ignore that for now
				rex ior:=wmask
				genrex()
				genbyte(0xB8+regcode)
				genqword(value)
			fi

		esac

	else
		gerror("MOV REG/??")
	esac
when a_mem then
	case b^.mode
	when a_reg then
		if a^.size<>b^.size and a^.size then
			gerror("Opnd size mismatch")
		fi
		regcode:=getregcoder(b^.reg)
		checkhighreg(b)
		am:=genrm(a,regcode)
		setopsize(b)
		genrex()
		genbyte((b^.size=1|0x88|0x89))
		genamode(a,am)

	when a_imm then
		value:=b^.value
		am:=genrm(a,0)
		if b^.labeldef and a^.size<=2 then gerror("mov imm?") fi

		if a^.size=0 then a^.size:=1 fi

		case a^.size
		when 0,1 then
			unless -128<=value<=255 then gerror("exceeding byte value") end

			setopsize(a)
			genrex()
			genbyte(0xC6)
			genamode(a,am)
			genbyte(value)

		when 2 then
			unless -32768<=value<=65535 then gerror("exceeding word16 value") end
			setopsize(a)
			genrex()
			genbyte(0xC7)
			genamode(a,am)
			genword(value)
		when 4,8 then
			if not b^.labeldef then
				unless -0x8000'0000<=value<=0xFFFF'FFFF then gerror("2:exceeding word32 value") end
!				unless -0x7FFF'FFFF<=value<=0xFFFF'FFFF then gerror("2:exceeding word32 value") end
			fi
			setopsize(a)
			genrex()
			genbyte(0xC7)
			genamode(a,am)
			genopnd(b,4)
!			gendword(value)
		esac

	else
		gerror("MOV MEM/?")
	esac
else
	gerror("MOV ?/..")
esac
end

function getregcoder(int reg)int=
int regcode

regcode:=regcodes[reg]
if regcode>=8 then
	regcode-:=8
	rex ior:=rmask
fi
return regcode
end

function getregcodeb(int reg)int=
int regcode

regcode:=regcodes[reg]
if regcode>=8 then
	regcode-:=8
	rex ior:=bmask
fi
return regcode
end

function getregcodebx(int reg)int=
!do not translate reg code (I think, when xmm reg code etc)

int regcode

regcode:=reg-1
if regcode>=8 then
	regcode-:=8
	rex ior:=bmask
fi
return regcode
end

function getregcoderx(int reg)int=
!do not translate reg code (I think, when xmm reg code etc)
int regcode

regcode:=reg-1
if regcode>=8 then
	regcode-:=8
	rex ior:=rmask
fi
return regcode
end


proc do_lea(ref opndrec a,b)=
int regcode, am

unless a^.mode=a_reg and b^.mode=a_mem then
	gerror("LEA not reg/mem")
end

if a^.size<4 then gerror("LEA size error") fi
regcode:=getregcoder(a^.reg)

am:=genrm(b,regcode)
setopsize(a)
genrex()
genbyte(0x8D)
genamode(b,am)

end

proc do_movsx(ref opndrec a,b,int opc)=
!opc=B6 for movzx, and BE for movsx
	int am, regcode

	if a^.mode<>a_reg then gerror("movsx not reg") fi

	if a^.size=8 and b^.size=4 then
		if opc=0xBE then
			do_movsxd(a,b)
		else						!movsx 4->8 bytes, do normal move 4->4
			a:=regtable[a^.reg,4]
			do_mov(a,b)
		fi
		return
	fi

	if a^.size=1 or a^.size<=b^.size then gerror("movsx size error") fi

	if opc=0xB6 and b^.size=4 then gerror("movsx 4=>8 bytes?") fi

	case b^.mode
	when a_reg then
	when a_mem then
		if b^.size=0 then gerror("movsx need size prefix") fi
		if b^.size=8 then gerror("movsx size 8") fi
	else
		gerror("movsx not reg/mem")
	esac

	regcode:=getregcoder(a^.reg)

	am:=genrm(b,regcode)
	setopsize(a)
	checkhighreg(b)
	genrex()
	genbyte(0x0F)
	genbyte((b^.size=1|opc|opc+1))
	genamode(b,am)
end

proc checkhighreg(ref opndrec a)=
if a^.mode=a_reg then
	case a^.reg
!	when r2,r3,r14,r15 then
	when r5,r3,r14,r15 then
		rex ior:=0x40
	esac
fi
end

proc do_exch(ref opndrec a,b)=
int regcode, am

if a^.mode=a_reg and b^.mode=a_reg and (a^.reg=r0 or b^.reg=r0) and a^.size<>1 then		!simple r0/reg
	if a^.reg<>r0 then				!get a to be r0
		swap(a,b)
	fi
	if a^.size<>b^.size then gerror("exch size") fi

	setopsize(a)
	regcode:=getregcodeb(b^.reg)
	genrex()
	genbyte(0x90+regcode)
	return
fi

if a^.mode=a_mem then swap(a,b) fi

unless a^.mode=a_reg and (b^.mode=a_reg or b^.mode=a_mem) then gerror("exch opnds") end
if b^.size=0 and b^.mode=a_mem then b^.size:=a^.size fi
if a^.size<>b^.size then gerror("exch size") fi

if a^.size=1 then
	checkhighreg(a)
	checkhighreg(b)
fi

regcode:=getregcoder(a^.reg)

am:=genrm(b,regcode)
setopsize(a)
genrex()
genbyte((a^.size=1|0x86|0x87))
genamode(b,am)

end

proc do_movsxd(ref opndrec a,b)=
int regcode, am

if b^.mode=a_mem and b^.size=0 then b^.size:=4 fi

if a^.size<>8 or b^.size>4 then gerror("movsxd size") fi

!if a^.mode<>a_reg or b^.mode not in [a_reg,a_mem] then
if a^.mode<>a_reg or (b^.mode<>a_reg and b^.mode<>a_mem) then
	gerror("movsxd opnds")
fi

regcode:=getregcoder(a^.reg)
am:=genrm(b,regcode)

setopsize(a)
genrex()
genbyte(0x63)
genamode(b,am)

end

proc do_imul2(ref opndrec a,b)=
int regcode, am, opc
int64 value

if a^.mode<>a_reg then
	gerror("imul2 opnds")
fi
if b^.size=0 then b^.size:=a^.size fi
if a^.size=1 then gerror("imul2 byte") fi

case b^.mode
when a_reg,a_mem then
	if a^.size<>b^.size then gerror("imul2 size") fi
	regcode:=getregcoder(a^.reg)
	am:=genrm(b,regcode)

	setopsize(a)
	genrex()
	genbyte(0x0F)
	genbyte(0xAF)
	genamode(b,am)

when a_imm then						!imul reg1,reg2,imm but implemented as imul reg,imm
	if b^.labeldef then gerror("mul/label") fi
	value:=b^.value
	regcode:=getregcoder(a^.reg)		!same reg used in two places
	regcode:=getregcodeb(a^.reg)
	opc:=0xC0+regcode<<3+regcode
	setopsize(a)
	genrex()

	if -128<=value<=127 then
		genbyte(0x6B)
		genbyte(opc)
		genbyte(value)
	elsif a^.size=2 then
		genbyte(0x69)
		genbyte(opc)
		genword(value)
	else
		genbyte(0x69)
		genbyte(opc)
		gendword(value)
	fi
else
	gerror("imul2 opnds")
esac
end

proc do_imul3(ref opndrec a,b,c)=
int64 value
int regcode1, regcode2, opc

if a^.mode<>a_reg or b^.mode<>a_reg then
	gerror("imul3 opnds")
fi
if a^.size=1 then gerror("imul3 byte") fi
if c^.mode<>a_imm then gerror("imul3 not imm") fi

value:=c^.value
regcode1:=getregcoder(a^.reg)
regcode2:=getregcodeb(b^.reg)
opc:=0xC0+regcode1<<3+regcode2
setopsize(a)
genrex()

if -128<=value<=127 then
	genbyte(0x6B)
	genbyte(opc)
	genbyte(value)
elsif a^.size=2 then
	genbyte(0x69)
	genbyte(opc)
	genword(value)
else
	genbyte(0x69)
	genbyte(opc)
	gendword(value)
fi
end

proc do_shift(ref opndrec a,b,int opc)=
int am, w

if a^.mode<>a_reg and a^.mode<>a_mem then gerror("shift opnds1?") fi

am:=genrm(a,opc)
checkhighreg(a)
setopsize(a)
genrex()
w:=(a^.size=1|0|1)

case b^.mode
when a_imm then
	if b^.labeldef then gerror("shift/label") fi
	if b^.value=1 then
		genbyte(0xD0+w)
		genamode(a,am)
	else
		genbyte(0xC0+w)
		genamode(a,am)
		genbyte(b^.value)
	fi
when a_reg then
	if b^.reg<>r10 or b^.size<>1 then gerror("cl or b10 needed") fi
	genbyte(0xD2+w)
	genamode(a,am)

else
	gerror("shift opnds2?")
esac
end

proc do_test(ref opndrec a,b)=
int64 value
int opc, am, regcode

if a^.mode=a_reg and a^.reg=r0 and b^.mode=a_imm then
	value:=b^.value
	case a^.size
	when 1 then
		genbyte(0xA8)
		genbyte(value)
	when 2 then
		genbyte(0x66)
		genbyte(0xA9)
		genword(value)
	when 4 then
		genbyte(0xA9)
		gendword(value)
	else
		genbyte(0x48)
		genbyte(0xA9)
		gendword(value)
	esac

elsif (a^.mode=a_reg or a^.mode=a_mem) and b^.mode=a_imm then
	opc:=(a^.size=1|0xF6|0xF7)
	value:=b^.value

	am:=genrm(a,0)
	checkhighreg(a)
	setopsize(a)
	genrex()
	genbyte(opc)
	genamode(a,am)
	case a^.size
	when 1 then
		genbyte(value)
	when 2 then
		genword(value)
	else
		gendword(value)
	esac

elsif a^.mode=a_reg and (b^.mode=a_reg or b^.mode=a_mem) then
doregmem::
	regcode:=getregcoder(a^.reg)
	am:=genrm(b,regcode)
	checkhighreg(a)
	checkhighreg(b)
!	genrex()
	setopsize(a)
	genrex()
	genbyte((a^.size=1|0x84|0x85))
	genamode(b,am)

elsif a^.mode=a_mem and b^.mode=a_reg then
	swap(a,b)
	goto doregmem
else
	gerror("test opnds")
fi

end

proc do_loop(ref opndrec a,int opc)=
int offset

offset:=getrel32(a^.labeldef,getcurrdatalen(9)+1)
if offset<0 then			!backjump
	if offset<-126 then
		gerror("loop jmp out of range")
	fi
	genbyte(opc)
	genbyte(offset)
else
	gerror("Can't do loopxx fwd jump")
fi
end

proc do_jcxz(ref opndrec a,int opsize)=
int offset

offset:=getrel32(a^.labeldef,getcurrdatalen(10)+1)
if offset<0 then			!backjump
	if offset<-126 then
		gerror("jcxz jmp out of range")
	fi
	if opsize=4 then genbyte(0x67) fi
	genbyte(0xE3)
	genbyte(offset)
else
	gerror("Can't do jcxz fwd jump")
fi
end

proc do_setcc(ref opndrec a,b)=
!a is cond
!b is byte reg/mem
int am

if (b^.mode<>a_reg and b^.reg<>a_mem) or b^.size>1 then gerror("setcc opnd/size") fi

am:=genrm(b,0)
checkhighreg(b)
!CPL "CHECKHIGH/SETCC",REX:"H"
!genrex()
!setopsize(1)
genrex()
genbyte(0x0F)
genbyte(0x90+a^.value)
genamode(b,am)
end

proc do_movxmm(ref opndrec a,b,int size)=
!do movd/movq depending on size being 4 or 8
int am, regcode, regcode1, regcode2

case a^.mode
when a_reg then
	case b^.mode
	when a_xreg then
		if a^.size<>size then gerror("1:movdq size") fi
		regcode:=getregcoderx(b^.reg)
		am:=genrm(a,regcode)
		setopsize(a)
		genbyte(0x66)
		genrex()
		genbyte(0x0F)
		genbyte(0x7E)
		genamode(b,am)

	else
		gerror("movdq reg,?")
	esac
when a_xreg then
	case b^.mode
	when a_reg then
		if b^.size<>size then gerror("3:movdq size") fi
		regcode:=getregcoderx(a^.reg)
		am:=genrm(b,regcode)
		setopsize(b)
		genbyte(0x66)
		genrex()
		genbyte(0x0F)
		genbyte(0x6E)
		genamode(a,am)

	when a_xreg then
		regcode1:=getregcoderx(a^.reg)
		regcode2:=getregcodebx(b^.reg)
		genbyte(0xF3)
		genrex()
		genbyte(0x0F)
		genbyte(0x7E)
		genbyte(0xC0+regcode1<<3+regcode2)

	when a_mem then
		if b^.size and b^.size<>size then gerror("4:movdq size") fi
		regcode:=getregcoderx(a^.reg)
		am:=genrm(b,regcode)
		if size=4 then
			genbyte(0x66)
			genrex()
			genbyte(0x0F)
			genbyte(0x6E)
		else
			genbyte(0xF3)
			genrex()
			genbyte(0x0F)
			genbyte(0x7E)
		fi
		genamode(b,am)

	else
		gerror("movdq xreg,?")
	esac
when a_mem then
	case b^.mode
	when a_xreg then
		if a^.size and a^.size<>size then gerror("5:movdq size") fi
		regcode:=getregcoderx(b^.reg)
		am:=genrm(a,regcode)
		if size=4 then
			genbyte(0x66)
			genrex()
			genbyte(0x0F)
			genbyte(0x7E)
		else
			genbyte(0x66)
			genrex()
			genbyte(0x0F)
			genbyte(0xD6)
		fi
		genamode(a,am)

	else
		gerror("movdq mem,?")
	esac
else
	gerror("movdq opnds")
esac

end

proc do_arithxmm(ref opndrec a,b,int prefix,opc)=
int am, regcode

!if a^.mode<>a_xreg or b^.mode not in [a_xreg, a_mem] then
if a^.mode<>a_xreg or (b^.mode<>a_xreg and b^.mode<>a_mem) then
	gerror("arithxmm opnds")
fi

if b^.mode=a_xreg then

	regcode:=getregcoderx(a^.reg)
	am:=genrm(b,regcode)
	if prefix then genbyte(prefix) fi
	genrex()
	genbyte(0x0F)
	genbyte(opc)
	genamode(a,am)
else
	regcode:=getregcoderx(a^.reg)
	am:=genrm(b,regcode)
	if prefix then genbyte(prefix) fi
	genrex()
	genbyte(0x0F)
	genbyte(opc)
	genamode(b,am)
fi
end

proc do_logicxmm(ref opndrec a,b,int opc,size)=
int am, regcode

if a^.mode<>a_xreg or (b^.mode<>a_xreg and b^.mode<>a_mem) then
	gerror("logicxmm opnds")
fi

if size=8 then
	genbyte(0x66)
fi

if b^.mode=a_xreg then
	regcode:=getregcoderx(a.reg)
	am:=genrm(b,regcode)
	genrex()
	genbyte(0x0F)
	genbyte(opc)
	genamode(b,am)
else
	regcode:=getregcoderx(a^.reg)
	am:=genrm(b,regcode)
	genrex()
	genbyte(0x0F)
	genbyte(opc)
	genamode(b,am)
fi
end

proc do_convertfloat(ref opndrec a,b,int prefix)=
!cvtss2sd and cvtsd2ss
int am, regcode

if a^.mode<>a_xreg or (b^.mode<>a_xreg and b^.mode<>a_mem) then
	gerror("convertfloat opnds")
fi

genbyte(prefix)

if a^.mode=a_xreg then
	regcode:=getregcodeRx(a^.reg)
	am:=genrm(b,regcode)
	genrex()
	genbyte(0x0F)
	genbyte(0x5A)
	genamode(b,am)
else
	regcode:=getregcoderx(b^.reg)
	am:=genrm(a,regcode)
	genrex()
	genbyte(0x0F)
	genbyte(0x5A)
	genamode(b,am)
fi
end

proc do_fix(ref opndrec a,b,int prefix,opc)=
int am, regcode

if a^.mode<>a_reg or (b^.mode<>a_xreg and b^.mode<>a_mem) then
	gerror("fix opnds")
fi

genbyte(prefix)

if b^.mode=a_xreg then
	regcode:=getregcoder(a^.reg)
	am:=genrm(b,regcode)
	setopsize(a)
else
	regcode:=getregcoder(a^.reg)
	am:=genrm(b,regcode)
	setopsize(a)
fi

genrex()
genbyte(0x0F)
genbyte(opc)
genamode(b,am)
end

proc do_float(ref opndrec a,b,int prefix)=
!cvtss2si and cvtsd2si
int am, regcode

if a^.mode<>a_xreg or (b^.mode<>a_reg and b^.mode<>a_mem) then
	gerror("float opnds")
fi

if b^.mode=a_mem then
	if b^.size=0 then b^.size:=4 fi
	if b^.size<>4 and b^.size<>8 then gerror("float size") fi
fi

genbyte(prefix)

regcode:=getregcoderx(a^.reg)
am:=genrm(b,regcode)
setopsize(b)
genrex()
genbyte(0x0F)
genbyte(0x2A)
genamode(b,am)
end

proc do_call(ref opndrec a)=
int am, regcode
	case a^.mode
	when a_imm then
		genbyte(0xE8)
		genrel32(a)
	else				!indirect call
		case a^.size
		when 0 then a^.size:=8
		when 1,2,4 then
			gerror("call[]size")
		esac
		am:=genrm(a,2)
		setopsize(a)
		setaddrsize(a)
		genrex()
		genbyte(0xFF)
		genamode(a,am)

	esac
end

proc do_jmp(ref opndrec a,ref mclrec m)=
int am, regcode, offset, shortjmp

	case a^.mode
	when a_imm then
		offset:=getrel32(a^.labeldef,getcurrdatalen(11)+1)
		if offset<0 and offset>-126 then
			genbyte(0xEB)
			genbyte(offset)
		else
			shortjmp:=0
			if offset>0 then				!fwd jump
!check if destlabel occurs within next 8 instrs, then likely to need short disp
				shortjmp:=checkshortjump(m,a^.labeldef)
			fi

			if not shortjmp then
				genbyte(0xE9)
				genrel32(a)
			else
				genbyte(0xEB)
				genrel8(a)
			fi
		fi
	else				!indirect jump
		case a^.size
		when 0 then a^.size:=8
		when 1,2,4 then
			gerror("jmp[]size")
		esac
		am:=genrm(a,4)
		setopsize(a)
		setaddrsize(a)
		genrex()
		genbyte(0xFF)
		genamode(a,am)
	esac

end

function getcurrdatalen(int id)int=
!I think that zdata-seg is only likely when id=6

if currseg=zdata_seg then
	return ss_zdatalen
fi
return bufferlength(currdata)
end

proc do_cmovcc(ref opndrec c,a,b)=
int am, regcode
	if a^.size<>b^.size and b^.size then
		gerror("Opnd size mismatch")
	fi
	if a^.size=1 then gerror("cmov/byte") fi
	regcode:=getregcoder(a^.reg)
	am:=genrm(b,regcode)

	setopsize(a)
	genrex()
	genbyte(0x0F)
	genbyte(0x40+c^.value)
	genamode(b,am)
end

proc do_fmem(ref opndrec a, int freal, code)=
!do fld/fild/fst/fstp/fist,fistp
!freal=1 for fld/etc, 0 for fild etc
!code is middle 3 bits of 2nd byte: 0=load, 2=store, 3=store+pop
int am, regcode, mf

if a^.mode<>a_mem then
	gerror("fmem/not mem")
fi

if freal then
	case a^.size
	when 4 then mf:=0
	when 8 then mf:=2
	when 16 then
		mf:=1
		case code
		when 0 then code:=5
		when 3 then code:=7
		else
			gerror("r80 not allowed")
		esac
	else
CPL "SIZE=",A^.SIZE
		gerror("fmem size")
	esac
else
	case a^.size
	when 2 then mf:=3
	when 4 then mf:=1
	when 8 then
		mf:=3
		case code
		when 0 then code:=5
		when 3 then code:=7
		else
			gerror("fst i64?")
		esac
	else
		gerror("fmem int size")
	esac
fi

am:=genrm(a,code)
genrex()
genbyte(0xD9+mf<<1)
genamode(a,am)
!CPL "DONE FMEM"
end

function getr32bits(real x)int=
!when x is real, convert to real32 then return 32-bit bit pattern
real32 sx:=x
return int32@(sx)
end

proc genrel8(ref opndrec a)=
!a is a known fwd reference, and expected to be <=127 bytes
ref strec d

d:=a^.labeldef

if d^.reftype=fwd_ref then
	d^.fwdrefs:=addfwdref(d^.fwdrefs,getcurrdatalen(3),rel8_rel)
	genbyte(0)
else								!external symbol
	gerror("genrel8")
fi
end

function checkshortjump(ref mclrec m,ref strec d)int=
!at mccode[index] which should contain a jmp/jmpcc instruction
!d is the labeldef being jumped to
!return 1 if this is certain to be a short jump (8-bit disp) otherwise 0 
!return 0
int n

!RETURN 0

n:=0
m:=m^.nextmcl
while m and n<=8 do
	++n
	if m^.opcode=m_label and m^.a^.labeldef=d then
		return 1
	fi

	m:=m^.nextmcl
od

return 0
end

function addfwdref(ref fwdrec p, int offset, reltype, seg=0)ref fwdrec=
ref fwdrec q

q:=pcm_alloc(fwdrec.bytes)
q^.nextfwd:=p
q^.offset:=offset
q^.reltype:=reltype
q^.seg:=seg
return q
end

proc switchseg(int newseg)=
	if newseg=currseg then return fi

	case currseg						!reloc linked list roots must be updated
	when code_seg then
		ss_coderelocs:=currrelocs
		ss_ncoderelocs:=nrelocs
	when idata_seg then
		ss_idatarelocs:=currrelocs
		ss_nidatarelocs:=nrelocs
	esac

	currseg:=newseg

	case currseg
	when code_seg then
		currdata:=ss_code
		currrelocs:=ss_coderelocs
		nrelocs:=ss_ncoderelocs
	when idata_seg then
		currdata:=ss_idata
		currrelocs:=ss_idatarelocs
		nrelocs:=ss_nidatarelocs
	when zdata_seg then
		currdata:=ss_zdata
	esac							!else 0, done at end to update linked lists

end

proc do_movdqx(ref opndrec a,b, int opc)=
int am,regcode

case a^.mode
when a_xreg then
	case b^.mode
	when a_xreg then
		regcode:=getregcodebx(b^.reg)
		am:=genrm(a,regcode)
		genbyte(opc)
		genrex()
		genbyte(0x0F)
		genbyte(0x6F)
		genamode(a,am)

	when a_mem then
		regcode:=getregcoderx(a^.reg)
		am:=genrm(b,regcode)
		genbyte(opc)
		genrex()
		genbyte(0x0F)
		genbyte(0x6F)
		genamode(b,am)

	else
		gerror("movdqx?")
	esac
when a_mem then
	case b^.mode
	when a_xreg then
		regcode:=getregcoderx(b^.reg)
		am:=genrm(a,regcode)
		genbyte(opc)
		genrex()
		genbyte(0x0F)
		genbyte(0x7F)
		genamode(a,am)

	else
		gerror("movdqx")
	esac
else
	gerror("movdqx")
esac

end

proc do_popcnt(ref opndrec a,b)=
int am, regcode

if b^.mode=a_mem then
	if b^.size=0 then b^.size:=8 fi
fi

genbyte(0xF3)

!regcode:=getregcoderx(a^.reg)
regcode:=getregcodebx(a^.reg)
am:=genrm(b,regcode)
setopsize(a)
genrex()
genbyte(0x0F)
genbyte(0xB8)
genamode(b,am)
end

proc do_bsf(ref opndrec a,b, int opc)=
int am, regcode

if b^.mode=a_mem then
	if b^.size=0 then b^.size:=8 fi
fi
if a.size<>b.size then gerror("bsf size") fi

!regcode:=getregcoderx(a^.reg)
regcode:=getregcodebx(a^.reg)
am:=genrm(b,regcode)
setopsize(a)
genrex()
genbyte(0x0F)
genbyte(opc)
genamode(b,am)
end

proc extendsymboltable=
	ref[]ref strec oldsymboltable
	int oldsymboltablesize

	oldsymboltablesize:=ss_symboltablesize
	oldsymboltable:=ss_symboltable

	ss_symboltablesize*:=2
CPL "EXTENDING SYMBOL TABLE TO",SS_SYMBOLTABLESIZE

	ss_symboltable:=pcm_alloc(ref void.bytes*ss_symboltablesize)

	for i:=1 to ss_nsymbols do
		ss_symboltable^[i]:=oldsymboltable^[i]
	od

	pcm_free(oldsymboltable,ref void.bytes*oldsymboltablesize)
end

proc do_pcmpistri(ref opndrec a,b,int c,opc)=
int am, regcode

if a^.mode<>a_xreg or (b^.mode<>a_xreg and b^.mode<>a_mem) then
	gerror("pcmpistrx opnds")
fi

genbyte(0x66)

if b^.mode=a_xreg then
	swap(a,b)
	regcode:=getregcoderx(b^.reg)
	am:=genrm(a,regcode)
	genrex()
	genbyte(0x0F)
	genbyte(0x3A)
	genbyte(opc)
	genamode(a,am)
else
	regcode:=getregcoderx(a^.reg)
	am:=genrm(b,regcode)
	genrex()
	genbyte(0x0F)
	genbyte(0x3A)
	genbyte(opc)
	genamode(b,am)
fi

genbyte(c)

end

=== aa_lib.m 77/77 ===
import* aa_common

const ptrsize=8

fwdrec dummy1
!valuerec dummy2

global tabledata() [0:]ichar opndnames =
	(a_none=0,	$),
	(a_reg,		$),
	(a_imm,		$),
 	(a_mem,		$),		!any memory modes: [d], [R], [R*4+R2+d+imm] etc
 	(a_cond,	$),		!a condition code for jcc/setcc
	(a_xreg,	$),		!xmm register
	(a_string,	$),		!immediate string (for comments)
end

!global type opndrec = record			!24 bytes
!	ref strec labeldef	!nil, or handle of strec for label
!	union
!		int64 value		!const value/extra offset/cond code/string for comments
!		real64 xvalue	!floating point value
!		ref char svalue
!	end
!	byte mode		!a_reg etc, low level operand details
!	byte size		!byte size of operand: 1,2,4,8
!	byte reg		!0, or main register
!	byte regix		!0, or index register
!
!	byte scale		!0, or scale factor for regix
!	byte addrsize	!4 or 8 for a_mem when regs are involved
!	byte valtype	!0 (no value or int) or 'R'/'S'
!	byte spare2
!end

global record mclrec =
    ref mclrec nextmcl
    ref opndrec a,b
    u16 opcode
    u16 c
    u32 lineno
end

!!record used for expanding buffers. Expansion is not automatic: buffercheck(n)
!!is needed at strategic points to ensure that are at least n bytes left
!global type dbuffer = record
!	ref byte pstart
!	union
!		ref byte pcurr
!		ref word16 pcurr16
!		ref word32 pcurr32
!		ref word64 pcurr64
!	end
!	ref byte pend
!	int alloc
!end

global int currsegment=0		!

global opndrec dstackopnd
global opndrec dframeopnd

global int labelno=0
global ref opndrec zero_opnd=nil

global ref mclrec mccode, mccodex

strbuffer destv
global ref strbuffer dest=&destv

global [r0..r19, 1..8]ref opndrec regtable

global proc initlib=
zero_opnd:=genint(0)

int reg,size

for reg:=r0 to r15 do
	for size:=1 to 8 do
		case size
		when 1,2,4,8 then
			regtable[reg,size]:=genreg0(reg,size)
		esac
	od
od	
for reg:=r16 to r19 do
	regtable[reg,1]:=genreg0(reg,1)
od	

ss_symboltable:=pcm_alloc(init_ss_symbols*ref void.bytes)
ss_symboltablesize:=init_ss_symbols
ss_nsymbols:=0

end

global proc genmc(int opcode,ref opndrec a=nil,b=nil)=	!GENMC
ref mclrec m
int nopnds

!	m:=pcm_allocz(mclrec.bytes)
!	m:=pcm_allocz(mclrec.bytes)
	m:=pcm_alloc(mclrec.bytes)
++NMCLASM

	m^.nextmcl:=nil

!CPL "SET MLINENO",symbolnames[lxsymbol],mclnames[opcode]
	if lxsymbol=eolsym then
		m^.lineno:=lxlineno-1
	else
		m^.lineno:=lxlineno
	fi

	m^.opcode:=opcode

	nopnds:=(a=nil|0|(b=nil|1|2))
	if nopnds=2 and opcode in [m_pcmpistri,m_pcmpistrm] then nopnds:=3 fi

	if nopnds<mclnopnds[opcode] then
		serror("Too few operands")
	elsif nopnds>mclnopnds[opcode] then
		serror("Too many operands")
	fi

	m^.a:=a
	m^.b:=b

	if mccode then
		mccodex^.nextmcl:=m
		mccodex:=m
	else
		mccode:=mccodex:=m
	fi
end

global proc genmcstr(int opcode,ichar s)=	!GENMCSTR
!as genmc but uses a single immediate string operand

genmc(opcode,genstrimm(s))
end

function newopnd(int mode)ref opndrec=
ref opndrec a

++NMCLOPNDSASM

!a:=pcm_allocz(opndrec.bytes)
a:=pcm_allocz(opndrec.bytes)
a^.mode:=mode
return a
end

global function genxreg(int xreg)ref opndrec=		!GENXREG
ref opndrec a

a:=newopnd(a_xreg)
a^.reg:=xreg
a^.size:=16
return a
end

global function genindex(int areg=0,ireg=0,scale=1,ref opndrec x=nil,int size=0,addrsize=8)ref opndrec=		!GENINDEX
!construct a mem address mode
ref opndrec a

if x then							!existing operand filled in with value
!	a:=genmem_expr(x)				!fill in label and/or offset
	a:=x
	x^.mode:=a_mem
else
	a:=newopnd(a_mem)
fi

a^.reg:=areg
a^.regix:=ireg
a^.scale:=scale
a^.size:=size
a^.addrsize:=addrsize
return a
end

global function writemclblock:ref strbuffer=		!WRITEMCLBLOCK
int i
ref mclrec m

gs_init(dest)

gs_strln(dest,"MC CODE")

m:=mccode
i:=1

while m do
	writemcl(i,m)
	m:=m^.nextmcl
	++i
od
return dest			!only used when initstr=1, otherwise caller ignores
end

global proc gencomment(ichar s=nil)=			!GENCOMMENT
if s=nil then
	genmc(m_blank)
else
	genmcstr(m_comment,s)
fi
end

global function genstrimm(ichar s)ref opndrec=			!GENSTRIMM
ref opndrec a
a:=newopnd(a_string)
a^.svalue:=s
return a
end

function getsizetag(int size)ichar=			!GETSIZETAG
case size
when 1 then return "b"
when 2 then return "h"
when 4 then return "w"
when 8 then return "d"
esac
GERROR("GETSIZETAG?")
!return tostr(size)
return nil
end

proc writemcl(int index,ref mclrec mcl)=			!WRITEMCL
[512]char mclstr
[512]char str
ichar semi

strcpy(&.mclstr,strmcl(mcl))
if mclstr[1]=0 then return fi

case mcl^.opcode
when m_comment then
	semi:=";"
else
	semi:=" "
esac

!sprintf(&.str,"%03d %04d ",semi,index, mcl^.lineno)
print @&.str,semi:"z3",index:"z4",," "!, mcl^.lineno

gs_str(dest,&.str)
gs_strln(dest,&.mclstr)
end

global function strmcl(ref mclrec mcl)ichar=			!STRMCL
static [512]char str
[128]char str2
int opcode,sizepref

opcode:=mcl^.opcode

case opcode
when m_assem then
	return mcl^.a^.svalue
when m_blank then
	return ""
when m_comment then
!	if fshowcomments then
		strcpy(&.str,";")
		strcat(&.str,mcl^.a^.svalue)
		return &.str
!	fi
!when m_bsource then
!	strcpy(&str,";")
!	strcat(&str,mcl^.a.svalue)

!when m_labelname then
!	strcpy(&str,mcl^.a.svalue)
!	strcat(&str,":")
!	return &str

when m_label then
	strcpy(&.str,mcl^.a^.labeldef^.name)
	strcat(&.str,":")
	return &.str

esac

strcpy(&.str,"		")

case opcode
when m_jmpcc then
	strcat(&.str,"j")
	strcat(&.str,condnames[mcl^.a^.value])

when m_setcc then
	strcat(&.str,"set")
	strcat(&.str,condnames[mcl^.a^.value])
when m_cmovcc then
	strcat(&.str,"cmov")
	strcat(&.str,condnames[mcl^.a^.value])
else
	strcat(&.str,mclnames[opcode]+2)
esac

ipadstr(&.str,12)

!s+:=tab+tab+leftstr(opcname,10)

if mcl^.a and mcl^.b then		!2 operands
	sizepref:=needsizeprefix(mcl^.opcode,mcl^.a,mcl^.b)

	strcat(&.str,stropnd(mcl^.a,sizepref))
	strcat(&.str,",	")
	strcat(&.str,stropnd(mcl^.b,sizepref))

elsif mcl^.a then								!1 operand
	if mcl^.opcode=m_call then
		strcat(&.str,stropnd(mcl^.a,0))
	else
		strcat(&.str,stropnd(mcl^.a,1))
	fi
!else
!	opnds:=""
fi

case opcode
when m_pcmpistri,m_pcmpistrm then
	fprint @&.str2,", #",mcl.c
	strcat(&.str,&.str2)
esac

!s+:=opnds

return &.str
end

global function stropnd(ref opndrec a,int sizeprefix=0)ichar=			!STROPND
static [256]char str
ichar plus,s
int64 value
ref strec d

case a^.mode
when a_reg then
	return getregname(a^.reg,a^.size)
when a_imm then
!	return STRVALUE(A^.LABELDEF,A^.VALUE)
	d:=a^.labeldef
	value:=a^.value
	if d then
		if d^.symbol=namedconstsym then
			return inttostr(d^.expr^.value)
		fi

!		s:=d^.name
		s:=GETFULLNAME(d)

		if value then
			if value>0 then
				strcpy(&.str,s)
				strcat(&.str,"+")
				strcat(&.str,inttostr(value))
			else
				strcpy(&.str,s)
				strcat(&.str,inttostr(value))
			fi
			return &.str
		else
			strcpy(&.str,s)
			return &.str
!			return s
		fi
	fi
	if a^.valtype=0 then
		return inttostr(value)
	else
		return realtostr(real@(value))
	fi

when a_mem then
	str[1]:=0
	strcat(&.str,getsizeprefix(a^.size,sizeprefix))
	strcat(&.str,"[")
	plus:=""

	if a^.reg then
		strcat(&.str,getregname(a^.reg,a^.addrsize))
		plus:="+"
	fi

	if a^.regix then
		strcat(&.str,plus)
		strcat(&.str,getregname(a^.regix,a^.addrsize))
		plus:="+"
		if a^.scale>1 then
			strcat(&.str,"*")
			strcat(&.str,inttostr(a^.scale))
		fi
	fi

	if a^.labeldef then
		strcat(&.str,plus)
		strcat(&.str,strdef(a^.labeldef))
		plus:="+"
	fi

	if a^.value>0 then
		strcat(&.str,plus)
		strcat(&.str,inttostr(a^.value))
	elsif a^.value<0 then
		strcat(&.str,inttostr(a^.value))
	fi

	strcat(&.str,"]")
when a_string then
	if strlen(a^.svalue)>=str.len then
!		sprintf(&.str,"\"%s\"","<Long string>")
		print @&.str,"""<Long string>"""
	else
!		sprintf(&.str,"\"%s\"",a^.svalue)
		print @&.str,"""",,a.svalue,,""""
	fi

when a_cond then
	return opndnames[a^.value]

when a_xreg then
	return xgetregname(a^.reg)

else
	return "<BAD OPND>"
esac

return &.str
end

function strdef(ref strec def)ichar=			!STRDEF
if def^.symbol=namedconstsym then
	return inttostr(def^.expr^.value)
fi
return getfullname(def)
end

global proc setsegment(int seg)=		!SETSEGMENT
!seg is 'D', 'Z', 'C', 'R' for data, zdata, code, rdata
if seg=currsegment then
	return
fi
case seg
when 'D' then genmcstr(m_segment,".data")
when 'Z' then genmcstr(m_segment,".bss")
when 'C' then genmcstr(m_segment,".text")
when 'R' then genmcstr(m_segment,".rodata")
esac
currsegment:=seg
!currzdataalign:=curridataalign:=0
end

function getsizeprefix(int size,enable=0)ichar=		!GETSIZEPREFIX
if not enable then return "" fi
case size
when 1 then return "byte "
when 2 then return "word "
when 4 then return "dword "
when 8 then return "qword "
!when 0 then return "<no size> "
when 0 then return ""
esac
return "N:"
end

function needsizeprefix(int opcode,ref opndrec a,b)int=		!NEEDSIZEPREFIX

case opcode
when m_movsx,m_movzx then
	return 1
when m_cvtsi2ss,m_cvtsi2sd then
	return 1
esac

if a^.mode=a_reg or a^.mode=a_xreg or b^.mode=a_reg or b^.mode=a_xreg then
	return 0
fi
return 1
end

global function genimm_expr(ref strec d, int64 value, int t, size=4)ref opndrec=
!generate immediate operand
!x is valuerec from an expression, or direct strec (for label) or int
ref opndrec a

a:=newopnd(a_imm)
a^.size:=size

a^.labeldef:=d
a^.value:=value
a^.valtype:=t

return a
end

global function genint(int64 x,int size=4)ref opndrec=
!generate immediate operand
!x is valuerec from an expression, or direct strec (for label) or int
ref opndrec a

!IF X=0 THEN ++NZEROS FI

a:=newopnd(a_imm)
a^.size:=size
a^.value:=x

return a
end

global function genlab(ref strec d,int size=4)ref opndrec=
!generate immediate operand
!x is valuerec from an expression, or direct strec (for label) or int
ref opndrec a

a:=newopnd(a_imm)
a^.size:=size
a^.labeldef:=d

return a
end

global function genmem(ref strec d,int size=4)ref opndrec=
!simple memory operand without registers
ref opndrec a

a:=genlab(d,size)
a^.mode:=a_mem
return a
end

global function genreg0(int reg,size=4)ref opndrec=	!GENREG

ref opndrec a
a:=newopnd(a_reg)
a^.reg:=reg
a^.size:=size
return a
end

global function getfullname(ref strec d)ichar=
static [256]char str
ichar ms

ms:=""
if d^.basedef then
	ms:=d^.basedef^.name
fi

!sprintf(&.str,"<%s : #%d &:%8p SYM:%.*s M:%s>",
!	d^.name,d^.moduleno,d,
!	strlen(symbolnames[d^.symbol])-3,symbolnames[d^.symbol],
!	ms)

fprint @&.str,"<# : ## &:# SYM:## M:#>",
	d^.name,"#",d^.moduleno,d:"8",
	strlen(symbolnames[d^.symbol])-3:"v",symbolnames[d^.symbol]:".*", ms

return &.str
return d^.name
end

global function getregname(int reg,size=4)ichar=
ichar prefix,rs
static [32]char str

case reg
when rnone then return "-"
when rframe then rs:="frame"
when rstack then rs:="stack"
!when r16..r19 then
!	rs:=(reg-r15|"0H","1H","10H","11H"|"?")

else
	rs:=inttostr(reg-r0)
esac

case size
when 1 then prefix:="B"
when 2 then prefix:="W"
when 4 then prefix:="A"
else prefix:="D"
esac

strcpy(&.str,prefix)
strcat(&.str,rs)
return &.str
end

global function xgetregname(int reg)ichar=
static [16]char str

!sprintf(&.str,"xmm%d",reg-r0)
print @&.str,"xmm",,reg-r0

return &.str
end

global proc printst(filehandle f)=
ref strec r
int count,i

r:=modulenamelist
while r do
	printstrec(f,r)
	r:=r^.nextdef
od

end

global proc printstrec(filehandle f,ref strec d)=
const w=16

case d^.symbol
when fwdlocalsym, localsym, exportedsym then
	println @f,"Label:       ",padstr(d^.name,w),(d^.scope=fwd_ref|"U"|"-"),
		symbolnames[d^.symbol],,"\T",,
	padstr((d^.segment|segmentnames[d^.segment]|"no seg"),12),
		d^.offset, d^.fwdrefs
when importedsym then
	println @f,"Label:       ",padstr(d^.name,w),"EXTERN"

when namedconstsym then
	println @f,"Named const: ",padstr(d^.name,w),"=",stropnd(d^.expr)
else
	println @f,"??"
esac
end

global proc adddef(ref strec d)=
d^.nextdef:=modulenamelist
modulenamelist:=d
end

global proc addimport(ref strec d)=
ref stlistrec p

p:=pcm_alloc(stlistrec.bytes)
p^.def:=d
p^.nextitem:=globalimportlist
globalimportlist:=p
end

global proc createlabel(ref strec symptr,int symbol)=
!symptr is a generic st entry
symptr^.symbol:=symbol
symptr^.stindex:=0
symptr^.moduleno:=currmoduleno
adddef(symptr)
end

global proc createnamedconst(ref strec symptr,ref opndrec expr)=
symptr^.symbol:=namedconstsym
symptr^.expr:=expr
adddef(symptr)
end

global proc createregalias(ref strec symptr,int regindex, regsize)=
symptr.symbol:=kregsym
symptr.ksymbol:=kregsym
symptr.subcode:=regindex
symptr.regsize:=regsize

adddef(symptr)
end

global proc createxregalias(ref strec symptr,int regindex)=
symptr.symbol:=kxregsym
symptr.ksymbol:=kxregsym
symptr.subcode:=regindex

adddef(symptr)
end

global proc gerror(ichar mess)=
println "SS code gen error:",mess
println "On line:", alineno
println
stop 1
end

global proc serror(ichar mess)=
println "Syntax error: '",,mess,,"' on line",lxlineno,moduletable[currmoduleno].name
stop 1
end

global proc serror_s(ichar mess, param)=
[256]char str
sprintf(&.str,mess, param)
serror(&.str)
end

function inttostr(int64 a)ichar=
static [64]char str

!sprintf(&.str,"%lld",a)
getstrint(a,&.str)
return &.str
end

function realtostr(real a)ichar=
static [64]char str
!sprintf(&.str,"%f",a)
strcpy(&.str,strreal(a))
return &.str
end

global function buffercreate(int size=1024)ref dbuffer=
ref dbuffer a

a:=pcm_alloc(dbuffer.bytes)

a^.alloc:=size
a^.pstart:=a^.pcurr:=pcm_alloc(a^.alloc)
a^.pend:=a^.pstart+a^.alloc
return a
end

proc bufferexpand(ref dbuffer a)=
int newalloc,usedbytes
ref byte p

newalloc:=a^.alloc*2
usedbytes:=a^.pcurr-a^.pstart

if usedbytes>a^.alloc then
	println "dbuffer error"
	cpl
	cpl
	cpl
	stop
fi

p:=pcm_alloc(newalloc)
memcpy(p,a^.pstart,usedbytes)
a^.pstart:=p
a^.pcurr:=p+usedbytes
a^.alloc:=newalloc
a^.pend:=p+newalloc
end

!global proc buffercheck(ref dbuffer a,int n=1024)=
global proc buffercheck(ref dbuffer a,int n=1024)=
while a^.pend-a^.pcurr<n do
	bufferexpand(a)
od
end

global function bufferlength(ref dbuffer a)int=
return a^.pcurr-a^.pstart
end

global function bufferelemptr(ref dbuffer a, int offset)ref void=
!IF OFFSET>=BUFFERLENGTH(A) THEN
!	GERROR("BUFFERELEMPTE/OVERFLOW")
!FI

return a^.pstart+offset
end

global proc addbyte(ref dbuffer a, int x)=
a^.pcurr^:=x
++a^.pcurr
end

global proc addword(ref dbuffer a, int x)=
a^.pcurr16^:=x
++a^.pcurr16
end

global proc adddword(ref dbuffer a, int x)=
a^.pcurr32^:=x
++a^.pcurr32
end

global proc addqword(ref dbuffer a, int64 x)=
a^.pcurr64^:=x
++a^.pcurr64
end

global proc printmodulesymbols(filehandle f)=
[256]char str
ref strec d,e

	println @f,"MODULE SYMBOLS IN",moduletable[currmoduleno].name

	d:=modulenamelist

	while d do
		print @f,"   ",,padstr(d^.name,14),padstr(symbolnames[d^.symbol],12)

!		sprintf(&.str,"|| %6d %6d %8X",d^.htfirstindex,d^.htindex,d)

!		fprint @&.str,"|| # # #",d.htfirstindex:"6",d^.htindex:"6",d:"8H"
!		print @f,&.str

		fprint @f,"|| # # #",d.htfirstindex:"6",d^.htindex:"6",d:"8H"

		e:=dupltable[d^.htfirstindex]
		if e then
			print @f,"||"
			while e do
				print @f,"(",,e^.name,,")"
				e:=e^.nextdupl
			od
		fi
		println @f," BASE:",(d^.basedef|d^.basedef^.name|""),d^.basedef
		d:=d^.nextdef
	od
	println @f
end

global proc printimportsymbols(filehandle f)=
ref strec d,e
ref stlistrec p

	println @f,"GLOBAL IMPORT TABLE",globalimportlist

	p:=globalimportlist

	while p do
		d:=p^.def
		print @f,"   ",,padstr(d^.name,14),padstr(symbolnames[d^.symbol],12)
		println @f,=d^.offset,reftypenames[d^.reftype],ref void(d)
		p:=p^.nextitem
	od
	println @f
end

global proc printdupltable(filehandle f)=
[256]char str
ref strec d,e
ref stlistrec p
int i

println @f,"DUPL TABLE"

for i:=0 to dupltable.upb when dupltable[i] do
	d:=dupltable[i]

	print @f,"	",d^.htfirstindex,,":"
	while d do
!		sprintf(&.str,"(%6d %s (%s) %8X) ",d^.htindex,d^.name,
!				moduletable[d^.moduleno].name,d)
!		print @f,&.str

		fprint @&.str,"(# # (#) #) ",d.htindex:"6",d.name,
				moduletable[d.moduleno].name,d:"8H"

		d:=d^.nextdupl
	od
	println @f
od
println @f
end

=== end ===
