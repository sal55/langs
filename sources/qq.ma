mafile 56
  1 qq.m                3773     2438   0
  2 msyslib.m          34947     6235   0
  3 mclib.m             3432    41204   0
  4 mlibnew.m          26089    44660   0
  5 mwindows.m         12837    70774   0
  6 pci.m              20194    83631   0
  7 ccm_fn.             2968   103847   1
  8 pc_types.m          2773   106840   0
  9 pc_decls.m         19807   109638   0
 10 pq_common.m        18170   129472   0
 11 pc_support.m       13434   147670   0
 12 pc_misc.m           1671   161129   0
 13 pc_pcfns.m         47054   162826   0
 14 pc_objlib.m         8003   209907   0
 15 pc_bignum.m         3201   217937   0
 16 mbignum.m          30252   221163   0
 17 pc_print.m         46342   251441   0
 18 pc_jhandlers.m     53797   297813   0
 19 pc_oslayer.m        5593   351638   0
 20 mwindll.m           2115   357256   0
 21 pc_host.m          32225   359396   0
 22 ccm_host.           1215   391646   1
 23 pc_dxfns.m          7368   392887   0
 24 pc_khandlers.m     59610   400285   0
 25 pc_assembb.m      100397   459923   0
 26 ccasm_fn.           4518   560345   1
 27 var_decls.m        10113   564890   0
 28 var_types.m         2791   575030   0
 29 qc_tables.m        28303   577848   0
 30 qci.m              21059   606172   0
 31 qc_support.m        9259   627259   0
 32 qc_lex.m           29206   636542   0
 33 qc_parse.m         81925   665774   0
 34 qc_lib.m           36095   747723   0
 35 qc_name.m          27189   783843   0
 36 qc_pclgen.m        71211   811059   0
 37 qc_pcllib.m         9036   882297   0
 38 q_libs.m            1140   891357   0
 39 wincon.q            9211   892521   1
 40 sys.q              14463   901753   1
 41 files.q             5671   916239   1
 42 clib.q              1618   921932   1
 43 oslib.q             8214   923573   1
 44 oslibsw.q           1310   931812   1
 45 winlib.q            2200   933146   1
 46 linlib.q            2143   935370   1
 47 console.q          14099   937538   1
 48 consolesw.q         2869   951664   1
 49 lincon.q            7765   954557   1
 50 winapi.q           19873   962346   1
 51 winconsts.q        31648   982246   1
 52 wingxlib.q          8361  1013920   1
 53 winmessages.q      15410  1022310   1
 54 gxlib.q           113321  1037743   1
 55 gxmisc.q             705  1151088   1
 56 bmlib.q            34312  1151816   1
=== qq.m 1/56 ===

import msys
import mlib

import pci
import var_decls
import pc_decls
import pc_support
import qci

tabledata() []ichar optionnames =
	(fn_sw,			"fn"),
	(asm_sw,		"asm"),
	(debug_sw,		"debug"),
	(fdebug_sw,		"fdebug"),
	(verbose_sw,	"v"),
	(help_sw,		"help"),
	(ext_sw,		"ext"),
	(qa_sw,			"qa"),
	(compile_sw,	"c"),
end

ichar inputfile
int fcompile

proc start=
	int stopcode
	int filetype
	ichar outputfile

	getinputoptions(filetype)


	if filetype=q_file then
		outputfile:=pcm_copyheapstring(changeext(inputfile,"pc"))
		qcompiler_prod(inputfile,outputfile,dointlibs,0)
		inputfile:=outputfile
		if fcompile then
			CPL "STOPPING AFTER COMPILING"
			STOP
		FI

		filetype:=pc_file

	fi

	if fverbose then showcaption() fi

	stopcode:=runpcl(inputfile,filetype)


	if stopcode<0 then
		qci.loaderror(errorcodenames[stopcode],inputfile)
	fi

	stop stopcode
end

proc getinputoptions(int &filetype)=
	int paramno,pmtype
	ichar ext,name,value,newfile

	paramno:=2

	while pmtype:=nextcmdparam(paramno,name,value,"") do

		case pmtype
		when pm_option then
			convlcstring(name)
			for sw to optionnames.len do
				if eqstring(name,optionnames[sw]) then
					do_option(sw,value)
					exit
				fi
			else
				println "Unknown option:",name
				stop 99
			od
		when pm_sourcefile then
			if inputfile then
				qci.loaderror("Only one input file allowed")
			fi
			inputfile:=pcm_copyheapstring(name)
			exit					!ignore rest which are used by user program
		else
			println "Bad command param"
			stop 9
		esac

	od

	if inputfile=nil then
		showcaption()
		println "Usage:"
		println "	",,sysparams[1],"filename[.pc]"
		println "	",,sysparams[1],"filename.q"
		println "	",,sysparams[1],"-help"
		stop 1
	fi

	ext:=extractext(inputfile)

	if eqstring(ext,"") then
		if checkfile(newfile:=changeext(inputfile,"q")) then
			inputfile:=pcm_copyheapstring(changeext(inputfile,"q"))
			ext:="q"
		else
			ext:="pc"
			inputfile:=pcm_copyheapstring(newfile)
		fi
	fi

	if eqstring(ext,"pc") then
		filetype:=pc_file
	elsif eqstring(ext,"q") then
		filetype:=q_file
	else						!also also source files
		filetype:=q_file
	fi

	getsyscmdline(paramno-1)	!copy to cmdparams starting from this inputfile

end

proc do_option(int sw, ichar value)=
	int length

	case sw
	when fn_sw then
		dispatch_type:=fn_dispatch

	when asm_sw then
		dispatch_type:=asm_dispatch

	when debug_sw then
		dispatch_type:=deb1_dispatch

	when fdebug_sw then
		dispatch_type:=deb2_dispatch

	when help_sw then
		showhelp()

	when verbose_sw then
		fverbose:=2

	when ext_sw then
		dointlibs:=0

	when qa_sw then
		fwriteqa:=1

	when compile_sw then
		fcompile:=1

	esac
end

proc getsyscmdline(int n)=

	setcmdparam(0,sysparams[1])

	for i:=n to nsysparams do
		setcmdparam(i-n+1,sysparams[i])
	od
end

proc showcaption=
	println "PCL Interpreter",$date,"(",,dispatchnames[dispatch_type],$targetcode,,")"
end

proc showhelp=
	println "General usage:"
	println "	",,sysparams[1],"[options] filename[.pc]"
	println "	",,sysparams[1],"[options] filename.q"
	println
	println "	Options:"
	println "		-fn           Function table dispatcher (default)"
	println "		-asm          Fast ASM dispatcher"
	println "		-debug        Tracing dispatcher"
	println "		-fdebug       Tracing dispatcher starts on $setdebug(1)"
	stop 0
end
=== msyslib.m 2/56 ===
import clib
import mlib

global record procinforec=
	word16		fnindex
	byte		rettype
	byte		nparams
	[12]byte	paramlist
end

record fmtrec=	! (default)
	byte	minwidth	! n (0)   min field width (0 if not used or don't care)
	i8		precision	! .n (0)   number of decimals/significant figures/max width
	byte	base		! B,H or Xn (10)  2 to 16

	char	quotechar	! Qc (0)   0 or '"' or c
	char	padchar		! Pc, Z (' ')
	char	realfmt		! E,F,G ('f') 'e' or 'f' or 'g'

	char	plus		! (0)   0 or '+'
	char	sepchar		! Sc (0)   0 or ',' or c placed every 3 (base=10) or 4 digits
	char	lettercase	! A,a ('A') 'A' or 'a'
	char	justify		! JL, JR, JC ('R') 'L' or 'R' or 'C'?
	char	suffix		! Tc (0)   0 or 'B' or 'H' or c
	char	usigned		! W (0)   0 or 'W' force unsigned o/p for ints (eg. for hex display)
	char	charmode	! C,D (0)  0 or 'C' or 'D'	o/p int as int or single char or double/multi-char
	char	heapmode	! M (0)  'M' for str-functions, return ptr tp heap string
	char	param		! Use int value for <fmtparam>
	byte	spare
end

int fmtparam			!as set with :'V'

enum (std_io,file_io,str_io)

const comma = ','

global int needgap			= 0
int outdev			= std_io
filehandle outchan	= nil
ref char fmtstr 	= nil

const maxiostack=10
[maxiostack]filehandle	outchan_stack
[maxiostack]int			outdev_stack
[maxiostack]ref char	fmtstr_stack
[maxiostack]byte		needgap_stack

[maxiostack]ref char	ptr_stack		!this one doesn't need pushing, as each is pointed to from outchan
int niostack=0

[0:]char digits=A"0123456789ABCDEF"
const onesixty=360
fmtrec defaultfmt = (0,0, 10, 0,' ','f', 0,0,0,'R',0,0, 0,0,0,0)

const rd_buffersize = 16384	!total capacity of line buffer

ref char rd_buffer		! point to start of read buffer
int rd_length			! length of this line (as read by readln)
ref char rd_pos			! current position it's up to (next read starts here)
ref char rd_lastpos		! set by sread() just before reading used for reread()
int termchar			! terminator char set by readxxx()
int itemerror			!	set by some read functions, eg for reals


const maxparam=128
global int nsysparams
global [maxparam]ichar sysparams

const maxcallback=8
[0..maxcallback,8]word64 callbackstack
int ncallbacks=0

word64 mask63	= 0x7FFF'FFFF'FFFF'FFFF
real offset64	= 9223372036854775808.0		! 2**63 as r64
real offset32	= 9223372036854775808.0		! 2**63 as r32

global proc m$init=
int32 nargs
int nargs64
ref[]ichar args
ref[]ichar env
static [128]byte startupinfo			! 68 or 104 bytes
int res
ichar s


res:=__getmainargs(&nargs,cast(&args),cast(&env),0,cast(&startupinfo))

nsysparams:=nargs

if nsysparams>maxparam then
	printf("Too many params\n")
	stop 50
fi

nargs64:=nargs			!bug when using 32-bit limit when compild with mm
for i:=1 to nargs64 do
	sysparams[i]:=args^[i]
od

m$print_startcon()		!allow most print stmts without startcon/end

end

global proc m$stop(int n)=
	`exit(n)
end

global function m$lenstr_stringz(ref char s)int=
	strlen(s)
end



proc pushio=
	if niostack>=maxiostack then
		printf("Too many io levels\n")
		stop 53
	fi
	++niostack
	outchan_stack[niostack]	:= outchan
	outdev_stack[niostack]	:= outdev
	fmtstr_stack[niostack]	:= fmtstr
	needgap_stack[niostack]	:= needgap
	needgap:=0
	fmtstr:=nil
	outchan:=nil
end

global proc m$print_startfile(ref void dev)=
	pushio()
	outchan:=cast(dev)
	if dev then
		outdev:=file_io
	else
		outdev:=std_io
	fi
end

global proc m$print_startstr(ref char s)=
	ref ref char p
	pushio()

	ptr_stack[niostack]:=s
	p:=&ptr_stack[niostack]

	outchan:=cast(p)
	outdev:=str_io
end

global proc m$print_startptr(ref ref char p)=
	pushio()

	outchan:=cast(p)
	outdev:=str_io
end

global proc m$print_startcon=
	pushio()
	outdev:=std_io
end

global proc m$print_setfmt(ref char format)=
	fmtstr:=format
end

global proc m$print_end=
	needgap:=0
	nextfmtchars(1)
	if niostack=0 then return fi
	outchan	:= outchan_stack[niostack]
	outdev	:= outdev_stack[niostack]
	fmtstr	:= fmtstr_stack[niostack]
	needgap	:= needgap_stack[niostack]
	--niostack
end

global proc m$print_ptr(u64 a,ichar fmtstyle=nil)=
	[20]char s

	if fmtstyle=nil then
		fmtstyle:="z8H"
	fi
	m$print_u64(a,fmtstyle)
end

global proc m$print_ptr_nf(u64 a)=
	m$print_ptr(a)
end

global proc m$print_i64(int64 a,ichar fmtstyle=nil)=
	[40]char s
	fmtrec fmt
	int n

	nextfmtchars()
	if fmtstyle=nil then
		if a>=0 then
			n:=u64tostr(a,&.s,10,0)
		else
			s[1]:='-'
			n:=u64tostr(-a,&s[2],10,0)+1
		fi
		printstr_n(&.s,n)

	else

		strtofmt(fmtstyle,-1,&fmt)
		if fmt.param='V' then
			fmtparam:=a
			needgap:=0
		else
			tostr_i64(a,&fmt)
		fi
	fi
	needgap:=1
end

global proc m$print_i64_nf(int64 a)=
	m$print_i64(a)
end

global proc m$print_u64(word64 a,ichar fmtstyle=nil)=
	[40]char s
	fmtrec fmt

	nextfmtchars()
	if fmtstyle=nil then
		sprintf(&.s,"%llu",a)
		printstr(&.s)
	else
		strtofmt(fmtstyle,-1,&fmt)
		tostr_u64(a,&fmt)
	fi
	needgap:=1
end

global proc m$print_i128(int128 a,ichar fmtstyle=nil)=
	[40]char s
	fmtrec fmt

	nextfmtchars()
	strtofmt(fmtstyle,-1,&fmt)
	if a>=0 then
		tostr_u128(a,&fmt,0)
	else
		tostr_u128(-a,&fmt,1)
	fi

	needgap:=1
end

global proc m$print_u128(word128 a,ichar fmtstyle=nil)=
	[40]char s
	fmtrec fmt

	nextfmtchars()
	strtofmt(fmtstyle,-1,&fmt)
	tostr_u128(a,&fmt,0)
	needgap:=1
end

global proc m$print_r64(real x,ichar fmtstyle=nil)=
	[360]char s
	fmtrec fmt

	nextfmtchars()
	if fmtstyle=nil then
		sprintf(&.s,"%f",x)
		printstr(&.s)
	else
		strtofmt(fmtstyle,-1,&fmt)
		tostr_r64(x,&fmt)
	fi

	needgap:=1
end

global proc m$print_r32(real32 x,ichar fmtstyle=nil)=
	m$print_r64(x,fmtstyle)
end

global proc m$print_c8(int64 a,ichar fmtstyle=nil)=
	[40]char s
	fmtrec fmt
	int n

	nextfmtchars()

	s[1]:=a
	s[2]:=0
	printstr(&.s)
	needgap:=1
end

global proc m$print_str(ichar s, fmtstyle=nil)=
	nextfmtchars()

	if s=nil then
		printstr("<null>")
		return
	fi


	fmtrec fmt
	if fmtstyle=nil then
		printstr(s)
	else
		strtofmt(fmtstyle,-1,&fmt)
		tostr_str(s,&fmt)
	fi
	needgap:=1
end

global proc m$print_str_nf(ichar s)=
	m$print_str(s)
end

global proc m$print_strsl(slice[]char s, ichar fmtstyle=nil)=
	nextfmtchars()
	fmtrec fmt
	if fmtstyle=nil then
		printstr_n(cast(s.sliceptr),s.len)
	else
		abortprogram("FORMATED PRINT SLICE NOT READY")
	fi
	needgap:=1
end

global proc m$print_newline=
	needgap:=0
	nextfmtchars(1)
	printstr("\w")
end

global proc m$print_nogap=
	needgap:=0
end

global proc printstr(ichar s)=
	int n
	ref ref char p

	case outdev
	when std_io then
		printf("%s",s)
	when file_io then
		fprintf(outchan,"%s",s)
	when str_io then
		p:=cast(outchan)
		strcpy(p^,s)
		p^+:=strlen(s)
		p^^:=0
	esac
end

global proc printstr_n(ichar s,int n=-1)=
	ref ref char p

	case n
	when -1 then n:=strlen(s)
	when 0 then return
	esac

	case outdev
	when std_io then
		printf("%.*s",n,s)
	when file_io then
		fprintf(outchan,"%.*s",n,s)
	when str_io then
		p:=cast(outchan)
		memcpy(p^,s,n)
		p^+:=n
		p^^:=0
	esac
end

global proc printstrn_app(ichar s, int length, filehandle f=nil)=
if length then
	if f=nil then
		printf("%.*s",length,s)
	else
		fprintf(f,"%.*s",length,s)
	fi
fi
end

proc printchar(int ch)=
	ref ref char p
	case outdev
	when std_io then
		printf("%c",ch)
	when file_io then
		fprintf(outchan,"%c",ch)
	when str_io then
		p:=cast(outchan)
		p^^:=ch
		p^+:=1
		p^^:=0
	esac
end

global proc nextfmtchars(int lastx=0)=
	char c
	ref char pstart
	int n
	if not fmtstr then			!format not in use
		if needgap then
			printchar(' ')
		fi
		needgap:=0
		return
	fi

	pstart:=fmtstr
	n:=0

	do
		c:=fmtstr^
		switch c
		when '#' then
			if lastx then
				goto skip
			fi
			++fmtstr
			if n then
				printstr_n(pstart,n)
			fi
			return
		when 0 then
			if n then
				printstr_n(pstart,n)
			elsif not lastx then
				printstr_n("|",1)
			fi
			return
		when '~' then
			if n then
				printstr_n(pstart,n)
				n:=0
			fi
			++fmtstr
			c:=fmtstr^
			if c then
				++fmtstr
				printchar(c)
			fi
			pstart:=fmtstr
		else
	skip::
			++n
			++fmtstr
		endswitch
	od
end

global proc strtofmt(ref char s,int slen,ref fmtrec fmt) =		!PC_STRTOFMT

	int c
	byte wset
	int n
	[0:100]char str

	fmt^:=defaultfmt

	if s=nil then return fi

	if slen=-1 then slen:=strlen(s) fi

	memcpy(&.str,s,slen)		!convert s/slen to zero-terminated string
	str[slen]:=0
	s:=&.str

	wset:=0
	while s^ do
		c:=s^
		++s
		switch c
		when 'B', 'b' then fmt^.base:=2
		when 'H', 'h' then fmt^.base:=16
		when 'O', 'o' then fmt^.base:=8
		when 'X', 'x' then
			c:=s^
			if c then
				switch c
				when '0'..'9' then c:=c-'0'
				when 'A'..'F' then c:=c-'A'+10
				when 'a'..'f' then c:=c-'a'+10
				else
					c:=10
				end
				fmt^.base:=c
				++s
			fi
		when 'Q', 'q' then fmt^.quotechar:='"'
		when '~' then fmt^.quotechar:='~'
		when 'J', 'j' then
			fmt^.justify:=toupper(s^)
			if s^ then
				++s
			fi
		when 'A' then fmt^.lettercase:='A'
		when 'a' then fmt^.lettercase:='a'
		when 'Z', 'z' then fmt^.padchar:='0'
		when 'S', 's' then
			fmt^.sepchar:=s^
			if s^ then
				++s
			fi
		when 'P', 'p' then
			fmt^.padchar:=s^
			if s^ then
				++s
			fi
		when 'T', 't' then
			fmt^.suffix:=s^
			if s^ then
				++s
			fi
		when 'W', 'w' then fmt^.usigned:='W'
		when 'E', 'e' then fmt^.realfmt:='e'
		when 'F', 'f' then fmt^.realfmt:='f'
		when 'G', 'g' then fmt^.realfmt:='g'
		when '.' then
			wset:=1
		when comma,'_' then fmt^.sepchar:=c
		when '+' then fmt^.plus:='+'
		when 'D', 'd' then fmt^.charmode:='D'
		when 'C', 'c' then fmt^.charmode:='C'
		when 'M', 'm' then fmt^.heapmode:='M'
		when 'V','v' then fmt.param:='V'
		when '*' then
			n:=fmtparam
			goto gotwidth
		else
			if c>='0' and c<='9' then
				n:=c-'0'
				do
					c:=s^
					if s^=0 then
						exit
					fi
					if c>='0' and c<='9' then
						++s
						n:=n*10+c-'0'
					else
						exit
					fi
				od
gotwidth::
				if not wset then
					fmt^.minwidth:=n
					wset:=1
				else
					fmt^.precision:=n
				fi
			fi
		endswitch
	od
end

function domultichar (ref char p,int n,ref char dest,ref fmtrec fmt)int =
	[0:20]char str
	ref char q
	int i,nchars

	q:=&.str

	nchars:=n

	to n do
		if p^=0 then exit fi
		q^:=p^
		++q
		++p
	od
	q^:=0

	return expandstr(&.str,dest,strlen(&.str),fmt)
end

function expandstr(ref char s,ref char t,int n,ref fmtrec fmt)int =		!EXPANDSTR

	int i,w,m

	w:=fmt^.minwidth
	if w=0 or w<=n then		! allow str to be longer than minwidth
		strncpy(t,s,n)
		(t+n)^:=0
		return n
	fi

	if fmt^.justify='L' then	! left-justify
		strncpy(t,s,n)
		t+:=n
		for i:=1 to w-n do
			t^:=fmt^.padchar
			++t
		od
		t^:=0
	elsif fmt^.justify='R' then
		if fmt^.padchar='0' and fmt^.base and (s^='-' or s^='+') then ! need to move sign outside 
			t^:=s^
			++t
			to w-n do
				t^:=fmt^.padchar
				++t
			od
			strncpy(t,s+1,n-1)
			(t+n-1)^:=0
		else
			to w-n do
				t^:=fmt^.padchar
				++t
			od
			strncpy(t,s,n)
			(t+n)^:=0
		fi

	else				! centre-justify?

		m:=(w-n+1)/2
		to m do
			t^:=fmt^.padchar
			++t
		od
		strncpy(t,s,n)
		t+:=n
		to w-n-m do
			t^:=fmt^.padchar
			++t
		od
		t^:=0

	fi
	return w
end


function u64tostr(u64 aa,ref char s,word base,int sep)int =		!U64TOSTR
	[0:onesixty]char t
	u64 dd
	int i,j,k,g
	int cc
	int dummy
	ref char s0

	i:=0
	k:=0
	g:=(base=10|3|4)

	repeat
		dd:=aa rem base
		aa:=aa/base

		t[++i]:=digits[dd]

		++k
		if sep and aa<>0 and k=g then
			t[++i]:=sep
			k:=0
		fi
	until aa=0

	j:=i
	s0:=s
	while i do
		s^:=t[i--]
		++s
	od
	s^:=0

	return j
end

function u128tostr(u128 aa,ref char s,word base,int sep)int =
	[0:160]char t
	u64 dd
	int i,j,k,g
	int dummy
	ref char s0

	i:=0
	k:=0
	g:=(base=10|3|4)

	repeat
		aa:=xdivrem128(aa,base,dd)
		t[++i]:=digits[dd]


		++k
		if sep and aa<>0 and k=g then
			t[++i]:=sep
			k:=0
		fi
	until aa=0

	j:=i
	s0:=s
	while i do
		s^:=t[i--]
		++s
	od
	s^:=0

	return j
end

function xdivrem128(word128 a, word64 b, &remainder)word128=
	word128 d,e,r
	word rlow

	d:=a/b
	r:=a-d*b

	assem
		mov d0,[r]
		mov [rlow],d0
	end
	remainder:=rlow
	return d
end

function i64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int =
	[0:onesixty]char str				! allow for binary with separators!
	int i,j,k,n,w,usigned
	const i64 mindint=0x8000'0000'0000'0000

	usigned:=0
	if fmt^.usigned then
		usigned:=1
	fi

	if aa=mindint and not usigned then		! minint

		str[0]:='-'
		n:=i64mintostr(&str[1],fmt^.base,fmt^.sepchar)+1
	else
		if (not usigned and aa<-0) or fmt^.plus then
			if aa<0 then
				aa:=-aa
				str[0]:='-'
			else
				str[0]:='+'
			fi
			n:=u64tostr(aa,&str[1],fmt^.base,fmt^.sepchar)+1
		else
			n:=u64tostr(aa,&.str,fmt^.base,fmt^.sepchar)
		fi
	fi

	if fmt^.suffix then
		str[n]:=fmt^.suffix
		str[++n]:=0
	fi

	if (fmt^.base>10 or fmt^.suffix) and fmt^.lettercase='a'	then	! need lower when
		convlcstring(&.str)
	fi

	return expandstr(&.str,s,n,fmt)
end

function u64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int =		!U64TOSTRFMT
	[0:onesixty]char str				! allow for binary with separators!
	int i,j,k,n,w

	n:=u64tostr(aa,&.str,fmt^.base,fmt^.sepchar)

	if fmt^.suffix then
		str[n]:=fmt^.suffix
		str[++n]:=0
	fi

	if fmt^.base>10 or fmt^.suffix and fmt^.lettercase='a'	then	! need lower when
	fi

	return expandstr(&.str,s,n,fmt)
end

function u128tostrfmt(i128 aa,ref char s,ref fmtrec fmt)int =		!U64TOSTRFMT
	[0:onesixty]char str				! allow for binary with separators!
	int i,j,k,n,w

	n:=u128tostr(aa,&.str,fmt^.base,fmt^.sepchar)

	if fmt^.suffix then
		str[n]:=fmt^.suffix
		str[++n]:=0
	fi

	if fmt^.base>10 or fmt^.suffix and fmt^.lettercase='a'	then	! need lower when
		convlcstring(&.str)
	fi

	return expandstr(&.str,s,n,fmt)
end

function i64mintostr(ref char s,int base,int sep)int =		!I64MINTOSTR
	[0:onesixty]char t
	int i,j,k,g,neg

	switch base
	when 10 then
		strcpy(&t[0],"9223372036854775808")
		j:=3
	when 16 then
		strcpy(&t[0],"8000000000000000")
		j:=1
	when 2 then
		strcpy(&t[0],"1000000000000000000000000000000000000000000000000000000000000000")
		j:=7
	else
		strcpy(&t[0],"<mindint>")
	endswitch

	i:=strlen(&t[0])
	s+:=i
	if sep then
		s+:=j
	fi
	s^:=0

	k:=0
	g:=(base=10|3|4)

	while i do
		--s
		s^:=t[i-- -1]
		if sep and i and ++k=g then
			--s
			s^:=sep
			k:=0
		fi
	od
	return strlen(s)
end

function strtostrfmt(ref char s,ref char t,int n,ref fmtrec fmt)int =
	ref char u,v
	[256]char str
	int w,nheap		! whether any heap storage is used  bytes allocated

	nheap:=0

	if fmt^.quotechar or fmt^.lettercase then		! need local copy
		if n<256 then
			u:=&.str
		else
			nheap:=n+3					! allow for quotes+terminator
			u:=pcm_alloc(nheap)
		fi
		if fmt^.quotechar then
			v:=u
			v^:=fmt^.quotechar
			++v
			if n then
				strcpy(v,s)
				v+:=n
			fi
			v^:=fmt^.quotechar
			++v
			v^:=0
			n+:=2
		else
			memcpy(u,s,n)
		fi
		switch fmt^.lettercase
		when 'a' then	! need lower when
			convlcstring(u)
		when 'A' then
			convucstring(u)
		endswitch
		s:=u
	fi

	w:=fmt^.minwidth
	if w>n then
		n:=expandstr(s,t,n,fmt)
	else
		memcpy(t,s,n)
	fi
	if nheap then
		pcm_free(u,nheap)
	fi
	return n
end

proc tostr_i64(int64 a, ref fmtrec fmt)=
	[360]char str
	int n

	case fmt^.charmode
	when 0 then
		n:=i64tostrfmt(a,&.str,fmt)
	when 'D','d' then
		n:=domultichar(ref char(&a),8,&.str,fmt)

	else						!assume 'C'
		printchar(a)			!no other formatting allowed
		return
	esac

	printstr_n(&.str,n)
end

proc tostr_u64(word64 a, ref fmtrec fmt)=
	[360]char str
	int n

	case fmt^.charmode
	when 'D','d' then
		n:=domultichar(ref char(&a),8,&.str,fmt)

	when 'C','c' then
		printchar(a)			!no other formatting allowed
		return

	else
		n:=u64tostrfmt(a,&.str,fmt)
	esac

	printstr_n(&.str,n)
end

proc tostr_u128(word128 a, ref fmtrec fmt,int neg)=
	[360]char str
	int n

	case fmt^.charmode
	when 'D','d' then
		n:=domultichar(ref char(&a),8,&.str,fmt)

	when 'C','c' then
		printchar(a)			!no other formatting allowed
		return

	else
		if neg then
			str[1]:='-'
			n:=u128tostrfmt(a,&str[2],fmt)+1
		else
			n:=u128tostrfmt(a,&.str,fmt)
		fi
	esac

	printstr_n(&.str,n)
end

proc tostr_r64(real x,ref fmtrec fmt) =
	[360]char str,str2
	[0:10]char cfmt
	int n

	cfmt[0]:='%'

	if fmt^.precision then
		cfmt[1]:='.'
		cfmt[2]:='*'
		cfmt[3]:=fmt^.realfmt
		cfmt[4]:=0
		sprintf(&.str,&.cfmt,fmt^.precision,x)
	else
		cfmt[1]:=fmt^.realfmt
		cfmt[2]:=0
		sprintf(&.str,&.cfmt,x)
	fi


	n:=strlen(&.str)		! current length

	if n<fmt^.minwidth then
		n:=expandstr(&.str,&.str2,n,fmt)
		strcpy(&.str,&.str2)
	fi

	printstr_n(&.str,n)
end

proc tostr_str(ref char s, ref fmtrec fmt) =
	int oldlen,newlen,n
	ref char t

	oldlen:=strlen(s)
	newlen:=oldlen

	if fmt^.quotechar or fmt^.minwidth>newlen or fmt^.lettercase or fmt.precision then
		if fmt^.quotechar then
			newlen+:=2
		fi
		if fmt^.minwidth>newlen then
			newlen:=fmt^.minwidth
		fi
		t:=pcm_alloc(newlen+1)
		n:=strtostrfmt(s,t,oldlen,fmt)
		if fmt.precision then
			n min:=fmt.precision
		fi

		printstr_n(t,n)
		pcm_free(t,newlen+1)
	else
		printstr_n(s,oldlen)
	fi
end

global function getfmt(ichar fmtstyle)ref fmtrec=
	static fmtrec fmt
	if fmtstyle then
		strtofmt(fmtstyle,-1,&fmt)
		return &fmt
	else
		return &defaultfmt
	fi
end

global function strint(int64 a, ichar fmtstyle=nil)ichar=
	static [100]char str
	ref fmtrec fmt

	m$print_startstr(&.str)
	tostr_i64(a,fmt:=getfmt(fmtstyle))
	m$print_end()
	return getstr(&.str,fmt)
end

global proc getstrint(int64 a, ichar dest)=
	m$print_startstr(dest)
	tostr_i64(a,getfmt(nil))
	m$print_end()
end

global function strword(word64 a, ichar fmtstyle=nil)ichar=
	static [100]char str
	ref fmtrec fmt

	m$print_startstr(&.str)
	tostr_u64(a,fmt:=getfmt(fmtstyle))
	m$print_end()
	return getstr(&.str,fmt)
end

global function strreal(real a, ichar fmtstyle=nil)ichar=
	static [320]char str
	ref fmtrec fmt

	m$print_startstr(&.str)
	tostr_r64(a,fmt:=getfmt(fmtstyle))
	m$print_end()
	return getstr(&.str,fmt)
end

function getstr(ichar s, ref fmtrec fmt)ichar=
	if fmt^.heapmode then
		return pcm_copyheapstring(s)
	else
		return s
	fi
end

proc initreadbuffer=
	if rd_buffer then return fi
	rd_buffer:=pcm_alloc(rd_buffersize)
	rd_buffer^:=0
	rd_pos:=rd_lastpos:=rd_buffer
end

global proc m$read_conline=
	initreadbuffer()

	readlinen(nil,rd_buffer,rd_buffersize)

	rd_length:=strlen(rd_buffer)
	rd_pos:=rd_buffer
	rd_lastpos:=nil
end

global proc m$read_fileline(filehandle f)=
	initreadbuffer()
	readlinen(f,rd_buffer,rd_buffersize)

	rd_length:=strlen(rd_buffer)
	rd_pos:=rd_buffer
	rd_lastpos:=nil
end

global proc m$read_strline(ichar s)=
	int n

	initreadbuffer()
	n:=strlen(s)

	if n<rd_buffersize then
		strcpy(rd_buffer,s)
	else
		memcpy(rd_buffer,s,rd_buffersize-1)
		(rd_buffer+rd_buffersize-1)^:=0
	fi
	rd_length:=n
	rd_pos:=rd_buffer
	rd_lastpos:=nil
end

function readitem(int &itemlength)ref char =
	ref char p,s,itemstr
	char quotechar, c

	unless rd_buffer then 
		initreadbuffer()
	end unless


	s:=rd_pos

	while s^=' ' or s^=9 do
		++s
	od

	itemstr:=s				!assume starts here
	rd_lastpos:=rd_pos:=s

	if s^=0 then			! No more chars left to read return null string
		termchar:=0
		itemlength:=0
		return s
	fi

	quotechar:=0			! Allow possible enclosing single or double quotes
	if s^='"' then
		quotechar:='"'
		++s
	elsif s^='\'' then
		quotechar:='\''
		++s
	fi

	p:=itemstr:=s

	while s^ do
		c:=s++^
		switch c
		when ' ', 9, comma, '=' then		! separator
			if quotechar or p=s then			!can be considered part of name if inside quotes, or is only char
				goto normalchar
			fi
			termchar:=c
			exit
		else
	normalchar::
			if c=quotechar then
				if s^=quotechar then	! embedded quote
					p^:=c
					++s
					++p
				else					! end of name
					termchar:=s^
					if termchar=',' or termchar='=' then
						++s
						termchar:=s^
					fi
					exit
				fi
			else
				p^:=c
				++p
			fi
		endswitch
	od

	if s^=0 then
		termchar:=0
	fi
	itemlength:=p-itemstr				! actual length of token
	rd_pos:=s

	return itemstr
end

global function strtoint(ichar s,int length=-1, word base=10)int64=
	byte signd
	word64 aa
	word c,d

	itemerror:=0

	if length=-1 then
		length:=strlen(s)
	fi
	signd:=0
	if length and s^='-' then
		signd:=1; ++s; --length
	elsif length and s^='+' then
		++s; --length
	fi

	aa:=0
	while length do
		c:=s++^
		--length
		switch c
		when 'A'..'F' then d:=c-'A'+10
		when 'a'..'f' then d:=c-'a'+10
		when '0'..'9' then d:=c-'0'
		when '_', '\'' then
			next
		else
			itemerror:=1
			exit
		endswitch

		if d>=base then
			itemerror:=1
			exit
		fi
		aa:=aa*base+d
	od

	if signd then
		return -aa
	else
		return aa
	fi
end

global function m$read_i64(int fmt=0)int64=
	ref char s
	int length,c
	int64 aa

	case fmt
	when 'C','c' then
		rd_lastpos:=rd_pos
		if rd_pos^ then
			return rd_pos++^
		else
			return 0
		fi
	when 'T','t' then
		return termchar
	when 'E','e' then
		return itemerror
	esac

	s:=readitem(length)

	case fmt
	when 0,'I','i' then
		return strtoint(s,length)
	when 'B','b' then
		return strtoint(s,length,2)
	when 'H','h' then
		return strtoint(s,length,16)
	esac
	return 0
end

global function m$read_r64(int fmt=0)real=
	[512]char str
	ref char s
	int length
	int32 numlength
	real x

	s:=readitem(length)

	if length=0 or length>=str.len then		!assume not a real
		return 0.0
	fi
	memcpy(&.str,s,length)
	str[length+1]:=0

	itemerror:=0

	if sscanf(&.str,"%lf%n", &x, &numlength)=0 or numlength<>length then
		x:=0.0
		itemerror:=1
	fi

	return x
end

global proc m$read_str(ref char dest, int destlen=0,fmt=0)=
	ref char s
	int length,numlength
	real x

	itemerror:=0
	if fmt='L' or fmt='l' then
		s:=rd_pos
		length:=rd_buffer+rd_length-rd_pos

	else
		s:=readitem(length)

		if fmt='N' or fmt='n' then
			iconvlcn(s,length)
		fi
	fi

	if destlen>0 then
		if length>=destlen then
			length:=destlen-1
			itemerror:=1
		fi
	fi
	memcpy(dest,s,length)
	(dest+length)^:=0
end

global proc readstr(ref char dest, int fmt=0,destlen=0)=
	m$read_str(dest,destlen,fmt)
end

global proc rereadln=
	rd_pos:=rd_buffer
	rd_lastpos:=rd_pos
end

global proc reread=
	rd_pos:=rd_lastpos
end

global function valint(ichar s, int fmt=0)int64=
ref char old_pos, old_lastpos
int64 aa

initreadbuffer()
old_pos:=rd_pos
old_lastpos:=rd_lastpos

rd_pos:=s
aa:=m$read_i64(fmt)
rd_pos:=old_pos
rd_lastpos:=old_lastpos
return aa
end

global function valreal(ichar s)real=
ref char old_pos, old_lastpos
real x

initreadbuffer()
old_pos:=rd_pos
old_lastpos:=rd_lastpos

rd_pos:=s
x:=m$read_r64()
rd_pos:=old_pos
rd_lastpos:=old_lastpos
return x
end

proc iconvlcn(ref char s,int n) =		!ICONVLCN
to n do
	s^:=tolower(s^)
	++s
od
end

proc iconvucn(ref char s,int n) =		!ICONVUCN
to n do
	s^:=toupper(s^)
	++s
od
end

proc convlcstring(ref char s)=		!CONVLCSTRING
while (s^) do
	s^:=tolower(s^)
	++s
od
end

proc convucstring(ref char s)=		!CONVUCSTRING
while (s^) do
	s^:=toupper(s^)
	++s
od
end

global proc m$float_u64_r64(word a)=
	assem
		cmp D10,0
		jl fl1
		cvtsi2sd XMM0,D10
		jmp flx
fl1:						!negative value
		and D10,[mask63]		!clear top bit (subtract 2**63)
		cvtsi2sd XMM0,D10
		addsd XMM0,[offset64]	!(add 2**63 back to result)
flx:
	end
end

global function m$power_i64(int64 a,n)int64=
	if n<0 then
		return 0
	elsif n=0 then
		return 1
	elsif n=1 then
		return a
	elsif n.even then
		return m$power_i64(sqr a, n/2)
	else			!assume odd
		return m$power_i64(sqr a, (n-1)/2)*a
	fi
end


global proc m$mul_i128(word128 aa,bb)=
	assem
		push d3
		push d4
		push d5
		mov d2,[aa]			!a1
		mov d3,[aa+8]		!a2
		mov d4,[bb]			!b1
		mov d5,[bb+8]		!b2


		mov d0,d2			!a1
		imul2 d0,d5			!*b2	
		mov d6,d0			!=>d6

		mov d0,d3			!a2
		imul2 d0,d4			!*b1
		mov d7,d0			!=>d7

		mov d0,d2			!a1
		mul d4				!*b1
		add d11,d6			! + a1*b2<<64
		add d11,d7			! + a2*b1<<64
		mov d1,d11
		pop d5
		pop d4
		pop d3
	end
end

global proc m$idiv_i128(word128 aa,bb)=
charlie::
	assem
		push d3
		push d4
		push d6


		mov d2,[aa]
		mov d3,[aa+8]

		mov d4,[bb]
		or d4,d4
		jz divbyzero

		mov d0,d3		!a2
		xor d11,d11
		div d4			!a2/b
		mov d6,d0		! => c2
		mul d4			!c2*b
		sub d3,d0		!a2-:=c2*b

		mov d0,d2
		mov d11,d3		!a2:a1
		div d4			!/b
		mov d1,d6
		pop d6
		pop d4
		pop d3

	end
	return

asm divbyzero:
CPL "DIV BY ZERO"
	stop 1
end

global proc m$dotindex(word i,a)=
end

global proc m$dotslice(word j,i,a)=
end

global proc m$popdotindex(word i,ref word p,word x)=
end

global proc m$popdotslice(word j,i, ref word p, word x)=
end



global proc mclunimpl(ichar mess)=
	printf("MCL-UNIMPL: %s\n",mess)
	stop 1
end
=== mclib.m 3/56 ===
global type filehandle=ref void

importlib $cstd=
	clang function malloc	(word64)ref void
	clang function realloc	(ref void, wordm)ref void
	clang proc     free		(ref void)
	clang proc     memset	(ref void, int32, wordm)
	clang proc     memcpy	(ref void, ref void, wordm)
	clang function clock	:int32
	clang function ftell	(filehandle)int32
	clang function fseek	(filehandle, int32, int32)int32
	clang function fread	(ref void, wordm, wordm, filehandle)wordm
	clang function fwrite	(ref void, wordm, wordm, filehandle)wordm
	clang function getc		(filehandle)int32
	clang function ungetc	(int32, filehandle)int32
	clang function fopen	(ichar,ichar="rb")filehandle
	clang function fclose	(filehandle)int32
	clang function fgets	(ichar, int, filehandle)ichar
	clang function remove	(ichar)int32
	clang function rename	(ichar, ichar)int32
	clang function getchar	:int32
	clang proc     putchar	(int32)
	clang proc     setbuf	(filehandle, ref byte)

	clang function strlen	(ichar)int
	clang function strcpy	(ichar, ichar)ichar
	clang function strcmp	(ichar, ichar)int32
	clang function strncmp	(ichar, ichar, wordm)int32
	clang function strncpy	(ichar, ichar, wordm)wordm
	clang function memcmp	(ref void, ref void, wordm)int32
	clang function strcat	(ichar, ichar)ichar
	clang function tolower	(int32)int32
	clang function toupper	(int32)int32
	clang function isalpha	(int32)int32
	clang function isupper	(int32)int32
	clang function islower	(int32)int32
	clang function isalnum	(int32)int32
	clang function isspace	(int32)int32
	clang function strstr	(ichar, ichar)ichar
	clang function atol		(ichar)intm
	clang function atoi		(ichar)int32
	clang function strtod	(ichar,ref ref char)real64

	clang function puts		(ichar)int32
	clang function puts99	(ichar)int32
	clang function printf	(ichar, ...)int32

	clang function sprintf	(ichar, ichar, ...)int32

	clang function sscanf	(ichar, ichar, ...)int32
	clang function scanf	(ichar, ...)int32

	clang function rand		:int32
	clang proc     srand	(word32)
	clang function system	(ichar)int32

	clang function fgetc	(filehandle)int32
	clang function fputc	(int32,  filehandle)int32
	clang function fprintf	(filehandle, ichar, ...)int32
	clang function fputs	(ichar,  filehandle)int32
	clang function feof		(filehandle)int32
	clang function getch	:int32
	clang function kbhit	:int32
	clang function _mkdir	(ichar)int32
	clang function mkdir	(ichar)int32
	clang function dummy	(real)real
	clang function strchr	(ichar,int32)ichar

	clang proc     _exit	(int32)
	clang proc     "exit"	(int32)
	clang function	pow		(real,real)real

	clang function	`sin	(real)real
	clang function	`cos	(real)real
	clang function	`tan	(real)real
	clang function	`asin	(real)real
	clang function	`acos	(real)real
	clang function	`atan	(real)real
	clang function	`log	(real)real
	clang function	`log10	(real)real
	clang function	`exp	(real)real
	clang function	`floor	(real)real
	clang function	`ceil	(real)real

	clang proc      qsort   (ref void, word64, word64, ref proc)

end

importlib $cstdextra=
	clang function __getmainargs(ref int32, ref void, ref void, int, ref void)int32
end

global const c_eof		=-1
global const seek_set	= 0
global const seek_curr	= 1
global const seek_end	= 2
=== mlibnew.m 4/56 ===
import msys
import clib
import oslib

const mem_check=0

GLOBAL INT MDEBUG
GLOBAL INT NPCMALLOC


global [0..300]u64 allocupper
global int alloccode				!set by heapalloc
global int allocbytes				!set by heapalloc
global int fdebug=0
global int rfsize

const threshold=1<<25
const alloc_step=1<<25
word maxmemory
int  maxalloccode

byte pcm_setup=0

int show=0

global int memtotal=0
global int64 smallmemtotal=0
global int smallmemobjs=0
global int maxmemtotal=0

const int maxmemalloc=(mem_check|500000|2)
[maxmemalloc+1]ref int32 memalloctable
[maxmemalloc+1]int32 memallocsize

const pcheapsize=1048576*2
ref byte pcheapstart
ref byte pcheapend			!points to first address past heap
ref byte pcheapptr

const int maxblockindex = 8 		!2048
global const int maxblocksize = 2048

[0:maxblocksize+1]byte sizeindextable	!convert byte size to block index 1..maxblockindex

const int size16   = 1			!the various index codes
const int size32   = 2
const int size64   = 3
const int size128  = 4
const int size256  = 5
const int size512  = 6
const int size1024 = 7
const int size2048 = 8

GLOBAL [0:9]ref wordp freelist

global record strbuffer =
	ichar strptr
	int32 length
	int32 allocated
end

global tabledata() [0:]ichar pmnames=
	(pm_end=0,		$),
	(pm_option,		$),
	(pm_sourcefile,	$),
	(pm_libfile,	$),
	(pm_colon,		$),
	(pm_extra,		$),
end

[2]word seed = (0x2989'8811'1111'1272',0x1673'2673'7335'8264)

global function pcm_alloc(int n)ref void =		!PCM_ALLOC
ref byte p

if not pcm_setup then
	pcm_init()
fi

if n>maxblocksize then			!large block allocation

	alloccode:=pcm_getac(n)
	allocbytes:=allocupper[alloccode]

	p:=allocmem(allocbytes)
	if not p then
		abortprogram("pcm_alloc failure")
	fi

	if mem_check then addtomemalloc(ref int32(p),allocbytes) fi

	return p
fi

alloccode:=sizeindextable[n]		!Size code := 0,1,2 etc for 0, 16, 32 etc

allocbytes:=allocupper[alloccode]

if p:=ref byte(freelist[alloccode]) then		!Items of this block size available
if mem_check then addtomemalloc(ref int32(p),allocbytes) fi
	freelist[alloccode]:=ref wordp(int((freelist[alloccode])^))

	return p
fi

p:=pcheapptr				!Create item at start of remaining pool in heap block
pcheapptr+:=allocbytes			!Shrink remaining pool

if pcheapptr>=pcheapend then		!Overflows?
	p:=pcm_newblock(allocbytes)		!Create new heap block, and allocate from start of that
	return p
fi
if mem_check then addtomemalloc(ref int32(p),allocbytes) fi

return p
end

global proc pcm_free(ref void p,int n) =		!PCM_FREE
int acode

if n=0 then return fi

if n>maxblocksize then		!large block
	if mem_check then removefrommemalloc(p,n) fi

	free(p)
	return
fi

if p then
	acode:=sizeindextable[n]		!Size code := 0,1,2 etc for 0, 16, 32 etc

	smallmemtotal-:=allocupper[acode]

	if mem_check then removefrommemalloc(p,allocupper[acode]) fi

	cast(p,ref wordp)^:=wordp(int(freelist[acode]))
	freelist[acode]:=p
fi
end

global proc pcm_freeac(ref void p,int alloc) =		!PCM_FREEAC
pcm_free(p,allocupper[alloc])
end

global proc pcm_copymem4(ref void p,q,int n) =	!PCM_COPYMEM4

memcpy(p,q,n)
end

global proc pcm_clearmem(ref void p,int n) =		!PCM_CLEARMEM
memset(p,0,n)
end

global proc pcm_init =		!PCM_INIT
int j,k,k1,k2
int64 size
const limit=1<<33

if pcm_setup then
	return
fi

pcm_newblock(0)

for i to maxblocksize do	!table converts eg. 78 to 4 (4th of 16,32,64,128)
	j:=1
	k:=16
	while i>k do
		k:=k<<1
		++j
	od
	sizeindextable[i]:=j
od

allocupper[1]:=16
size:=16

for i:=2 to 27 do
	size*:=2
	allocupper[i]:=size
	if size>=threshold then
			k:=i
		exit
	fi
od

for i:=k+1 to allocupper.upb do
	size+:=alloc_step
	if size<limit then
		allocupper[i]:=size
		maxmemory:=size
	else
		maxalloccode:=i-1
		exit
	fi
		
od
pcm_setup:=1
end

global function pcm_getac(int size)int =		!PCM_GETAC


if size<=maxblocksize then
	return sizeindextable[size]		!size 0 to 2KB
fi

size:=(size+255)>>8					!scale by 256


if size<=maxblocksize then
	return sizeindextable[size]+8
fi

size:=(size+63)>>6					!scale by 256

if size<=maxblocksize then
	return sizeindextable[size]+14
fi



size:=(size-2048+2047)/2048+22
return size
end

global function pcm_newblock(int itemsize)ref void=
static int totalheapsize
ref byte p

totalheapsize+:=pcheapsize
alloccode:=0
p:=allocmem(pcheapsize)	!can't free this block until appl terminates
if p=nil then
	abortprogram("Can't alloc pc heap")
fi

pcheapptr:=p
pcheapend:=p+pcheapsize

if pcheapstart=nil then		!this is first block
	pcheapstart:=p
fi
pcheapptr+:=itemsize
return ref u32(p)
end

global function pcm_round(int n)int =		!PCM_ROUND
static [0:maxblockindex+1]int32 allocbytes=(0,16,32,64,128,256,512,1024,2048)

if n>maxblocksize then
	return n
else
	return allocbytes[sizeindextable[n]]
fi
end

global function pcm_array(int n)int =		!PCM_ARRAY
int m

if n<=maxblocksize then	!automatic rounding up used for small heap
	return pcm_round(n)
else				!devise some strategy probably doubling up.
	m:=2048
	while n>m do
		m<<:=1
	od
	return m
fi

end

global proc pcm_printfreelist(int size,ref wordp p) =		!PCM_PRINTFREELIST
println "Size: ",size
while p do
	print " ",,p:"h"
	p:=ref wordp(int(p^))
od
puts("")
end

global proc pcm_diags(ref char caption) =		!PCM_DIAGS
int m

println "HEAP FREELISTS:",caption

m:=16
for i:=1 to 8 do
	pcm_printfreelist(m,freelist[i])
	m<<:=1
od
end

global function pcm_allocz(int n)ref void =		!PCM_ALLOCZ
ref void p
p:=pcm_alloc(n)

memset(p,0,n)
return p
end

global function pcm_copyheapstring(ref char s)ref char =
ref char q
int n
if s=nil then return nil fi

n:=strlen(s)+1
q:=pcm_alloc(n)
memcpy(q,s,n)
return q
end

global function pcm_copyheapstringn(ref char s,int n)ref char =
ref char q
if s=nil then return nil fi

q:=pcm_alloc(n+1)
memcpy(q,s,n)
(q+n)^:=0
return q
end

global function pcm_copyheapblock(ref char s, int length)ref char =
	ref char q
	if length=0 then return nil fi

	q:=pcm_alloc(length)
	memcpy(q,s,length)
	return q
end

proc addtomemalloc(ref int32 ptr,int size)=


for i to maxmemalloc do
	if memalloctable[i]=ptr then
		CPL "ALLOC ERROR:",ptr,"ALREADY ALLOCATED\n\n\n"
CPL
CPL
		stop 2
	fi

	if memalloctable[i]=nil then		!unused entry
		memalloctable[i]:=ptr
		memallocsize[i]:=size
		return
	fi
od
CPL "MEMALLOCTABLE FULL\n\n\n\n"; os_getch()
stop 3
end

proc removefrommemalloc(ref int32 ptr,int size)=


for i to maxmemalloc do
	if memalloctable[i]=ptr then

if memallocsize[i]<>size then
	CPL "REMOVE:FOUND",ptr,"IN MEMALLOCTABLE, FREESIZE=",size,", BUT STORED AS BLOCK SIZE:",memallocsize[i]
CPL
CPL
	abortprogram("MEMSIZE")
fi

		memalloctable[i]:=nil
		return
	fi
od
CPL "CAN'T FIND",ptr,"IN MEMALLOCTABLE",size
CPL
CPL
abortprogram("MEM")
stop 4
end

global function allocmem(int n)ref void =		!ALLOCMEM
ref void p

p:=malloc(n)
if (p) then
	return p
fi
println n,memtotal
abortprogram("Alloc mem failure")
return nil
end

global function reallocmem(ref void p,int n)ref void =		!REALLOCMEM
p:=realloc(p,n)
return p when p
println n
abortprogram("Realloc mem failure")
return nil
end

global proc abortprogram(ref char s) =		!ABORTPROGRAM
println s
print   "ABORTING: Press key..."
os_getch()
stop 5
end

global function getfilesize(filehandle handlex)int=		!GETFILESIZE
	word32 p,size

	p:=ftell(handlex)		!current position
	fseek(handlex,0,2)		!get to eof
	size:=ftell(handlex)		!size in bytes
	fseek(handlex,p,seek_set)	!restore position
	return size
end

global proc readrandom(filehandle handlex, ref byte mem, int offset, size) =		!READRANDOM
	int a
	fseek(handlex,offset,seek_set)
	a:=fread(mem,1,size,handlex)			!assign so as to remove gcc warning
end

global function writerandom(filehandle handlex, ref byte mem, int offset,size)int =		!WRITERANDOM
	fseek(handlex,offset,seek_set)
	return fwrite(mem,1,size,handlex)
end

global function setfilepos(filehandle file,int offset)int=
	return fseek(file,offset,0)
end

global function getfilepos(filehandle file)int=
	return ftell(file)
end

global function readfile(ref char filename)ref byte =		!READFILE
filehandle f
int size
ref byte m,p

f:=fopen(filename,"rb")
if f=nil then
	return nil
fi
rfsize:=size:=getfilesize(f)

m:=malloc(size+4)		!allow space for etx/zeof etc

if m=nil then
	return nil
fi

readrandom(f,m,0,size)
p:=m+size			!point to following byte
p^:=0
(p+1)^:=26
(p+2)^:=0			!allow use as string

fclose(f)
return m
end

global function writefile(ref char filename,ref byte data,int size)int =
filehandle f
int n

f:=fopen(filename,"wb")
if f=nil then
	return 0
fi

n:=writerandom(f,data,0,size)
fclose(f)
return n
end

global function checkfile(ref char file)int=		!CHECKFILE
filehandle f
if f:=fopen(file,"rb") then
	fclose(f)
	return 1
fi
return 0
end

global proc readlinen(filehandle handlex,ref char buffer,int size) =		!READLINEN
int ch
ref char p
int n
[0:100]char buff
byte crseen

if handlex=nil then
	handlex:=filehandle(os_getstdin())
fi
if handlex=nil then
	n:=0
	p:=buffer
	do
		ch:=getchar()
		if ch=13 or ch=10 or ch=-1 then
			p^:=0
			return
		fi
		p++^:=ch
		++n
		if n>=(size-2) then
			p^:=0
			return
		fi
	od
fi

buffer^:=0
if fgets(buffer,size-2,handlex)=nil then
	return
fi

n:=strlen(buffer)
if n=0 then
	return
fi

p:=buffer+n-1		!point to last char
crseen:=0
while (p>=buffer and (p^=13 or p^=10)) do
	if p^=13 or p^=10 then crseen:=1 fi
	p--^ :=0
od


if not crseen and (n+4>size) then
	cpl size,n
	abortprogram("line too long")
fi
end

global proc iconvlcn(ref char s,int n) =		!ICONVLCN
to n do
	s^:=tolower(s^)
	++s
od
end

global proc iconvucn(ref char s,int n) =		!ICONVUCN
to n do
	s^:=toupper(s^)
	++s
od
end

global proc convlcstring(ref char s)=		!CONVLCSTRING
while (s^) do
	s^:=tolower(s^)
	++s
od
end

global proc convucstring(ref char s)=		!CONVUCSTRING
while (s^) do
	s^:=toupper(s^)
	++s
od
end

global function changeext(ref char s,newext)ichar=		!CHANGEEXT
static [260]char newfile
[32]char newext2
ref char sext
int n

strcpy(&newfile[1],s)

case newext^
when 0 then
	newext2[1]:=0
	newext2[2]:=0
when '.' then
	strcpy(&newext2[1],newext)
else
	strcpy(&newext2[1],".")
	strcat(&newext2[1],newext)
esac


sext:=extractext(s,1)			!include "." when it is only extension

case sext^
when 0 then						!no extension not even "."
	strcat(&newfile[1],&newext2[1])
when '.' then						!no extension not even "."
	strcat(&newfile[1],&newext2[2])
else							!has extension
	n:=sext-s-2			!n is number of chars before the "."
	strcpy(&newfile[1]+n+1,&newext2[1])
esac

return &newfile[1]
end

global function extractext(ref char s,int period=0)ichar=		!EXTRACTEXT
ref char t,u

t:=extractfile(s)

if t^=0 then			!s contains no filename
	return ""
fi

u:=t+strlen(t)-1		!u points to last char of t

while u>=t do
	if u^='.' then		!start extension found
		if (u+1)^=0 then		!null extension
			return (period|"."|"")
		fi
		return u+1			!return last part of filename as extension exclude the dot
	fi
	--u
od
return ""			!no extension seen
end

global function extractpath(ref char s)ichar=		!EXTRACTPATH
static [0:260]char str
ref char t
int n

t:=s+strlen(s)-1		!t points to last char

while (t>=s) do
	switch t^
	when '\\','/',':' then		!path separator or drive letter terminator assume no extension
		n:=t-s+1			!n is number of chars in path, which includes rightmost / or \ or :
		memcpy(&.str,s,n)
		str[n]:=0
		return &.str
	endswitch
	--t
od
return ""			!no path found
end

global function extractfile(ref char s)ichar=		!EXTRACTFILE
ref char t

t:=extractpath(s)

if t^=0 then			!s contains no path
	return s
fi

return s+strlen(t)		!point to last part of s that contains the file
end

global function extractbasefile(ref char s)ichar=		!EXTRACTBASEFILE
static [0:100]char str
ref char f,e
int n,flen

f:=extractfile(s)
flen:=strlen(f)
if flen=0 then		!s contains no path
	return ""
fi
e:=extractext(f,0)

if e^ then			!not null extension
	n:=flen-strlen(e)-1
	memcpy(&str,f,n)
	str[n]:=0
	return &.str
fi
if (f+flen-1)^='.' then
	memcpy(&str,f,flen-1)
	str[flen-1]:=0
	return &.str
fi
return f
end

global function addext(ref char s,ref char newext)ichar=		!ADDEXT
ref char sext

sext:=extractext(s,1)

if sext^=0 then						!no extension not even "."
	return changeext(s,newext)
fi

return s							!has own extension; use that
end

global function alloctable(int n, size)ref void =		!ALLOCTABLE
ref void p

p:=malloc((n+1)*size)

if not p then
	abortprogram("Alloctable failure")
fi
return p
end

global function zalloctable(int n, size)ref void =		!ALLOCTABLE
ref int p

p:=alloctable(n,size)

pcm_clearmem(p,(n+1)*size)
return p
end

global proc checkfreelists(ichar s)=
ref wordp p,q
int64 aa

for i:=2 to 2 do
	p:=freelist[i]

	while p do
		aa:=int64(p)
		if aa>0xffff'FFFF or aa<100 then
			CPL s,"FREE LIST ERROR",i,p,q
		fi
		q:=p
		p:=ref wordp(int(p^))
	od

od
end


global function pcm_alloc32:ref void =		!PCM_ALLOC
ref byte p

allocbytes:=32


return pcm_alloc(32)
end

global proc pcm_free32(ref void p) =

smallmemtotal-:=32
if mem_check then removefrommemalloc(p,32) fi

cast(p,ref wordp)^:=wordp(int(freelist[2]))
freelist[2]:=p
end

global proc outbyte(filehandle f,int x)=
fwrite(&x,1,1,f)
end

global proc outword16(filehandle f,word x)=
fwrite(&x,2,1,f)
end

global proc outword(filehandle f,word x)=
fwrite(&x,4,1,f)
end

global proc outword64(filehandle f,word64 x)=
fwrite(&x,8,1,f)
end

global function myeof(filehandle f)int=
int c

c:=fgetc(f)
if c=c_eof then return 1 fi
ungetc(c,f)
return 0;
end

global function pcm_smallallocz(int n)ref void =
ref byte p

allocbytes:=allocupper[alloccode:=sizeindextable[n]]

p:=pcheapptr				!Create item at start of remaining pool in heap block
pcheapptr+:=allocbytes			!Shrink remaining pool

if pcheapptr>=pcheapend then		!Overflows?
	p:=pcm_newblock(allocbytes)		!Create new heap block, and allocate from start of that
	memset(p,0,n)
	return p
fi

memset(p,0,n)

return p
end

global function pcm_smallalloc(int n)ref void =
ref byte p

allocbytes:=allocupper[alloccode:=sizeindextable[n]]

p:=pcheapptr				!Create item at start of remaining pool in heap block
pcheapptr+:=allocbytes			!Shrink remaining pool

if pcheapptr>=pcheapend then		!Overflows?
	p:=pcm_newblock(allocbytes)		!Create new heap block, and allocate from start of that
	return p
fi

return p
end

global proc strbuffer_add(ref strbuffer dest, ichar s, int n=-1)=
int newlen,oldlen
ichar newptr

IF N=0 THEN CPL "N=0" FI

if n=-1 then
	n:=strlen(s)
fi

oldlen:=dest^.length

if oldlen=0 then				!first string
	dest^.strptr:=pcm_alloc(n+1)
	dest^.allocated:=allocbytes
	dest^.length:=n				!length always excludes terminator
	memcpy(dest^.strptr,s,n)
	(dest^.strptr+n)^:=0
	return
fi

newlen:=oldlen+n
if newlen+1>dest^.allocated then
	newptr:=pcm_alloc(newlen+1)
	memcpy(newptr,dest^.strptr,oldlen)
	dest^.strptr:=newptr
	dest^.allocated:=allocbytes
fi

memcpy(dest^.strptr+oldlen,s,n)
(dest^.strptr+newlen)^:=0

dest^.length:=newlen
end

global proc gs_init(ref strbuffer dest)=			!INITGENSTR
pcm_clearmem(dest,strbuffer.bytes)
end

global proc gs_free(ref strbuffer dest)=
if dest^.allocated then
	pcm_free(dest^.strptr,dest^.allocated)
fi
end

global proc gs_str(ref strbuffer dest,ichar s)=			!GENSTR
strbuffer_add(dest,s)
end

global proc gs_char(ref strbuffer dest,int c)=
[16]char s

s[1]:=c
s[2]:=0

strbuffer_add(dest,&.s,1)
end

global proc gs_strn(ref strbuffer dest,ichar s,int length)=
strbuffer_add(dest,s,length)
end

global proc gs_strvar(ref strbuffer dest,s)=			!GENSTR
strbuffer_add(dest,s^.strptr)
end

global proc gs_strint(ref strbuffer dest,int64 a)=
strbuffer_add(dest,strint(a))
end

global proc gs_strln(ref strbuffer dest,ichar s)=		!GENSTRLN
gs_str(dest,s)
gs_line(dest)
end

global proc gs_strsp(ref strbuffer dest,ichar s)=
gs_str(dest,s)
gs_str(dest," ")
end

global proc gs_line(ref strbuffer dest)=
strbuffer_add(dest,"\w")
end

global function gs_getcol(ref strbuffer dest)int=
return dest^.length
end

global proc gs_leftstr(ref strbuffer dest, ichar s, int w, padch=' ')=
int col,i,n,slen
[2560]char str
col:=dest^.length
strcpy(&.str,s)
slen:=strlen(s)
n:=w-slen
if n>0 then
	for i:=1 to n do
		str[slen+i]:=padch
	od
	str[slen+n+1]:=0
fi
gs_str(dest,&.str)
end

global proc gs_leftint(ref strbuffer dest, int a, int w, padch=' ')=
gs_leftstr(dest,strint(a),w,padch)
end

global proc gs_padto(ref strbuffer dest,int col, ch=' ')=
int n
[2560]char str

n:=col-dest^.length
if n<=0 then return fi
for i:=1 to n do
	str[i]:=ch
od
str[n+1]:=0
gs_str(dest,&.str)
end

global proc gs_println(ref strbuffer dest,filehandle f=nil)=
(dest.strptr+dest.length)^:=0

if f=nil then
	println dest.strptr,,"\c"
else
	println @f,dest.strptr,,"\c"
fi
end

global function nextcmdparam(int &paramno, ichar &name, &value, ichar defext=nil)int=
static int infile=0
static ichar filestart=nil
static ichar fileptr=nil
static byte colonseen=0
ref char q
ichar item,fileext
ichar rest
int length
static [300]char str

reenter::
value:=nil
name:=nil

if infile then
	if readnextfileitem(fileptr,item)=0 then		!eof
		free(filestart)								!file allocated via malloc
		infile:=0
		goto reenter
	fi
else
	if paramno>nsysparams then
		return pm_end
	fi
	item:=sysparams[paramno]
	++paramno

	length:=strlen(item)

	if item^='@' then		!@ file
		filestart:=fileptr:=cast(readfile(item+1))
		if filestart=nil then
			println "Can't open",item
			stop 7
		fi
		infile:=1
		goto reenter
	fi

	if item^=':' then
		colonseen:=1
		return pm_colon
	fi
fi

value:=nil
if item^='-' then
	name:=item+(colonseen|0|1)
	q:=strchr(item,':')
	if not q then
		q:=strchr(item,'=')
	fi
	if q then
		value:=q+1
		q^:=0
	fi
	return (colonseen|pm_extra|pm_option)
fi

fileext:=extractext(item,0)
name:=item

if fileext^=0 then							!no extension
	strcpy(&.str,name)
	if defext and not colonseen then
		name:=addext(&.str,defext)				!try .c
	fi
elsif eqstring(fileext,"dll") then
	return (colonseen|pm_extra|pm_libfile)
fi
return (colonseen|pm_extra|pm_sourcefile)
end

function readnextfileitem(ichar &fileptr,&item)int=
ref char p,pstart,pend
int n
static [256]char str

p:=fileptr

reenter::
do
	case p^
	when ' ','\t',13,10 then	!skip white space
		++p
	when 26,0 then				!eof
		return 0
	else
		exit
	esac
od

case p^
when '!', '#' then			!comment
	++p
	docase p++^
	when 10 then
		goto reenter
	when 26,0 then
		fileptr:=p-1
		return 0
	else

	enddocase
esac


case p^
when '"' then				!read until closing "
	pstart:=++p
	do
		case p^
		when 0,26 then
			println "Unexpected EOF in @file"
			stop 8
		when '"' then
			pend:=p++
			if p^=',' then ++p fi
			exit
		esac
		++p
	od
else
	pstart:=p
	do
		case p^
		when 0,26 then
			pend:=p
			exit
		when ' ','\t',',',13,10 then
			pend:=p++
			exit
		esac
		++p
	od
esac

n:=pend-pstart
if n>=str.len then
	println "@file item too long"
	stop 9
fi
memcpy(&.str,pstart,n)
str[n+1]:=0
item:=&.str
fileptr:=p

return 1
end

global proc ipadstr(ref char s,int width,ref char padchar=" ")=
int n

n:=strlen(s)
to width-n do
	strcat(s,padchar)
od
end

global function padstr(ref char s,int width,ref char padchar=" ")ichar=
static [256]char str

strcpy(&.str,s)
ipadstr(&.str,width,padchar)
return &.str
end

global function chr(int c)ichar=
static [8]char str

str[1]:=c
str[2]:=0
return &.str
end

global function cmpstring(ichar s,t)int=
	int res
	if (res:=strcmp(s,t))<0 then
		return -1
	elsif res>0 then
		return 1
	else
		return 0
	fi
end

global function cmpstringn(ichar s,t,int n)int=
	int res
	if (res:=strncmp(s,t,n))<0 then
		return -1
	elsif res>0 then
		return 1
	else
		return 0
	fi
end

global function eqstring(ichar s,t)int=
	return strcmp(s,t)=0
end

global function cmpbytes(ref void p,q,int n)int=
	int res
	if (res:=memcmp(p,q,n))<0 then
		return -1
	elsif res>0 then
		return 1
	else
		return 0
	fi
end

global function eqbytes(ref void p,q,int n)int=
	return memcmp(p,q,n)=0
end

global proc mseed(word64 a,b=0)=
seed[1]:=a
if b then
	seed[2]:=b
else
	seed[2] ixor:=a
fi
end

global function mrandom:word =
	word64 x,y
	x:=seed[1]
	y:=seed[2]
	seed[1]:=y
	x ixor:=(x<<23)
	seed[2]:= x ixor y ixor (x>>17) ixor (y>>26)
	return seed[2]+y
end

global function mrandomp:int =
	return mrandom() iand 0x7FFF'FFFF'FFFF'FFFF
end

global function mrandomint(int n)int=
	return mrandomp() rem n
end

global function mrandomrange(int a,b)int=
	int span
	span:=b-a+1
	if span<=0 then
		return 0
	fi
	return (mrandomp() rem span)+a
end

global function mrandomreal:real x=
	repeat x:=mrandomp()/9223372036854775808.0 until x<>1.0
	return x
end

global function mrandomreal1:real=
	return mrandomp()/9223372036854775807
end

global function checkpackfile:ref byte=

int a,offset,i,size
[100]char name
[300]char exefile
ref byte packexeptr			!for embedded pack files, contains pointer to in-memory version of this .exe file plus extras; else nil
int packexesize				!byte size
ref char packfilename
int packfilesize
ref byte packfileptr

macro getfileint(data,offset)=cast(data+offset,ref int32)^

strcpy(&exefile[1],os_gethostname())
println "Attempting to open",&exefile
packexeptr:=readfile(&exefile[1])

if not packexeptr then
	cpl "Can't open",&exefile,&packexeptr
	stop
fi

packexesize:=rfsize
cpl "File read OK. Size",packexesize

a:=getfileint(packexeptr,packexesize-int32.bytes)
if a<>'PCAK' then
	free(packexeptr)
	packfileptr:=nil
	return nil
fi

offset:=getfileint(packexeptr,packexesize-int32.bytes*2)

packfilename:=cast(packexeptr+offset)
offset+:=strlen(packfilename)+1
packfilesize:=getfileint(packexeptr,offset)
packfileptr:=packexeptr+offset+int32.bytes

return packfileptr
end

global function pcm_allocx:ref void =
const n=32
ref word p

allocbytes:=32

if p:=ref word(freelist[2]) then		!Items of this block size available
	freelist[2]:=ref wordp(int((freelist[2])^))

else

	p:=cast(pcheapptr)				!Create item at start of remaining pool in heap block
	pcheapptr+:=32			!Shrink remaining pool

	if pcheapptr>=pcheapend then		!Overflows?
		p:=pcm_newblock(32)		!Create new heap block, and allocate from start of that
	fi

	p^:=0
	(p+1)^:=0
	(p+2)^:=0
	(p+3)^:=0

	return p
fi
end

=== mwindows.m 5/56 ===
import clib
import mlib

const wm_destroy=2

type wt_word	= word16
type wt_wordpm	= word32
type wt_bool	= word32
type wt_dword	= word32
type wt_wchar	= word16
type wt_wcharpm	= word32
type wt_char	= byte
type wt_ichar	= ref char
type wt_ptr		= ref void
type wt_wndproc	= ref proc
type wt_handle	= ref void
type wt_int		= int32
type wt_uint	= word32
type wt_long	= int32
type wt_wparam	= wordm
type wt_lparam	= wordm
type wt_point	= rpoint

global record rsystemtime =
	wt_word year
	wt_word month
	wt_word dayofweek
	wt_word day
	wt_word hour
	wt_word minute
	wt_word second
	wt_word milliseconds
end

importdll $windowsdlls=
	windows function "GetStdHandle"(wt_dword)wt_handle
	windows function "GetConsoleScreenBufferInfo"(wt_handle,wt_ptr)int
	windows function "SetConsoleCtrlHandler"(wt_wndproc,int)int
	windows function "SetConsoleMode"(wt_handle,wt_dword)int
	windows function "CreateProcessA"(wt_ichar,wt_ichar,wt_ptr,wt_ptr, int,
						wt_dword, wt_ptr,wt_ichar,wt_ptr,wt_ptr)int
	windows function "GetLastError":wt_dword
	windows function "WaitForSingleObject"(wt_handle,wt_dword)wt_dword
	windows function "GetExitCodeProcess"(wt_handle,wt_ptr)int
	windows function "CloseHandle"(wt_handle)int
	windows function "GetNumberOfConsoleInputEvents"(wt_handle,wt_ptr)int
	windows function "FlushConsoleInputBuffer"(wt_handle)int
	windows function "LoadLibraryA"(wt_ichar)wt_handle
	windows function "GetProcAddress"(wt_handle,wt_ichar)ref void
	windows function "LoadCursorA"(wt_handle,wt_ichar)wt_handle
	windows function "RegisterClassExA"(wt_ptr)wt_wordpm
	windows function "DefWindowProcA"(wt_handle,wt_uint,wt_wparam,wt_lparam)intm
	windows function "ReadConsoleInputA"(wt_handle,wt_ptr,wt_dword,wt_ptr)int
	windows proc     "Sleep"(wt_dword)
	windows function "GetModuleFileNameA"(wt_handle,wt_ichar,wt_dword)wt_dword

	windows proc     "ExitProcess"(wt_uint)
	windows proc	 "PostQuitMessage"(wt_int)


	windows proc	 "MessageBoxA"(wt_int x=0,wt_ichar message, caption="Caption",wt_int y=0)

	windows function "QueryPerformanceCounter"(ref int64)wt_bool
	windows function "QueryPerformanceFrequency"(ref int64)wt_bool

	windows function "CreateFileA"(wt_ichar,wt_dword,wt_dword,wt_ptr,wt_dword,wt_dword,wt_handle)wt_handle
	windows function "GetFileTime"(wt_handle,wt_ptr,wt_ptr,wt_ptr)wt_bool

	windows proc     "GetSystemTime"(ref rsystemtime)
	windows proc     "GetLocalTime"(ref rsystemtime)

	windows function "GetTickCount":wt_dword
	windows function "PeekMessageA"		(ref void, ref wt_handle, wt_uint,wt_uint,wt_uint)wt_bool

end

record input_record =
	wt_word	eventtype
	word16	padding
		wt_bool	keydown			!key event record (was inside 'Event' union in win32)
		wt_word	repeatcount
		wt_word	virtualkeycode
		wt_word	virtualscancode
		union
			wt_word unicodechar
			wt_char asciichar
		end
		wt_dword controlkeystate
end

record rspoint=(int16 x,y)

record rsrect=
	int16 leftx,top,rightx,bottom
end

global record rpoint =
	wt_long x,y
end

record rconsole=
	rspoint size,pos
	word16 attributes
	rsrect window
	rspoint maxwindowsize
end

record rstartupinfo =
	wt_dword	size
	word32 dummy1
	wt_ichar	reserved
	wt_ichar	desktop
	wt_ichar	title
	wt_dword	x
	wt_dword	y
	wt_dword	xsize
	wt_dword	ysize
	wt_dword	xcountchars
	wt_dword	ycountchars
	wt_dword	fillattribute
	wt_dword	flags
	wt_word		showwindow
	wt_word		reserved2
	word32 dummy2
	wt_ptr		reserved4
	wt_handle	stdinput
	wt_handle	stdoutput
	wt_handle	stderror
end

record rprocess_information =
	wt_handle process
	wt_handle thread
	wt_dword processid
	wt_dword threadid
end

record rwndclassex =
	wt_uint		size
	wt_uint		style
	wt_wndproc	wndproc
	wt_int		clsextra
	wt_int		wndextra
	wt_handle	instance
	wt_handle	icon
	wt_handle	cursor
	wt_handle	background
	wt_ichar	menuname
	wt_ichar	classname
	wt_handle	iconsm
end

global record rmsg =
	wt_handle	hwnd
	wt_uint		message
	word32		dummy1
	wt_wparam	wParam
	wt_lparam	lParam
	wt_dword	time
	word32		dummy2
	wt_point	pt
end

const NORMAL_PRIORITY_CLASS=32
const CREATE_NEW_CONSOLE=16
const DETACHED_PROCESS=16

wt_handle hconsole, hconsolein

input_record lastkey, pendkey
int keypending			!whether pendkey contains a new key event detected by flushkbd

ref function(ref void)int wndproc_callbackfn=nil	!windows call-back: address of handler

int init_flag=0

global proc os_init=
int i,count
rconsole info

hconsole:=GetStdHandle(u32(-11))
hconsolein:=GetStdHandle(u32(-10))

lastkey.repeatcount:=0
keypending:=0

SetConsoleCtrlHandler(nil,1)

SetConsoleMode(hconsole,1 ior 2)

init_flag:=1

end

global function os_execwait(ichar cmdline,int newconsole=0,ichar workdir=nil)int =
wt_dword exitcode
int status
int cflags:=0

rstartupinfo si
rprocess_information xpi

memset(&si,0,si.bytes)
memset(&xpi,0,xpi.bytes)

switch newconsole
when 0 then cflags := NORMAL_PRIORITY_CLASS
when 1 then cflags := NORMAL_PRIORITY_CLASS ior CREATE_NEW_CONSOLE
when 2 then cflags := NORMAL_PRIORITY_CLASS ior DETACHED_PROCESS
endswitch

si.size := rstartupinfo.bytes

status:=CreateProcessA(
	nil,
	cmdline,
	nil,

	nil,
	1,
	cflags,

	nil,
	nil,
	&si,
	&xpi )

if status=0 then		!fails
	status:=GetLastError()
	println "Winexec error:",status
	return -1
end

WaitForSingleObject(xpi.process, 0xFFFF'FFFF)
GetExitCodeProcess(xpi.process,&exitcode)

CloseHandle(xpi.process)
CloseHandle(xpi.thread)

return exitcode
end

global function os_execcmd(ichar cmdline, int newconsole=0)int =
wt_dword exitcode
int i,j,k

rstartupinfo si
rprocess_information xpi

memset(&si,0,si.bytes)
memset(&xpi,0,xpi.bytes)

si.size := rstartupinfo.bytes

CreateProcessA( nil,
	cmdline,
	nil,
	nil,
	1,
	NORMAL_PRIORITY_CLASS ior (newconsole|CREATE_NEW_CONSOLE|0),
	nil,
	nil,
	&si,
	&xpi )

CloseHandle(xpi.process)
CloseHandle(xpi.thread)

return 1
end

global function os_getch:int=
int k

k:=os_getchx() iand 255

return k
end

global function os_kbhit:int=
wt_dword count

unless init_flag then os_init() end

GetNumberOfConsoleInputEvents(hconsolein,&count)
return count>1
end

global proc os_flushkeys=
FlushConsoleInputBuffer(hconsolein)
end

global function os_getconsolein:ref void=
return ref void(hconsolein)
end

global function os_getconsoleout:ref void=
return ref void(hconsole)
end

global function os_proginstance:ref void=
abortprogram("PROGINST")
return nil
end

global function os_getdllinst(ichar name)u64=
wt_handle hinst

hinst:=LoadLibraryA(name)
return cast(hinst)
end

global function os_getdllprocaddr(int hinst,ichar name)ref void=

return GetProcAddress(cast(int(hinst)),name)
end

global proc os_initwindows=
os_init()
os_gxregisterclass("pcc001")
end

global proc os_gxregisterclass(ichar classname)=
const idcarrow=32512
rwndclassex r
static byte registered

if registered then
	return
fi


memset(&r,0,r.bytes)
r.size:=r.bytes
r.style:=8 ior 32		!CS_DBLCLKS | CS_OWNDC
r.wndproc:=cast(&mainwndproc)
r.instance:=nil

r.icon:=nil		!loadicon(proginstance,"SCW32")
r.cursor:=LoadCursorA(nil,ref void(idcarrow))		!IDC_ARROW)
r.background:=cast(15+1)					!COLOR_BTNFACE+1
r.menuname:=nil
r.classname:=classname
r.iconsm:=nil	!loadicon(proginstance,"SCW32")

if RegisterClassExA(&r)=0 then
	println classname,GetLastError
	abortprogram("Registerclass error")
end
registered:=1
end

global callback function mainwndproc (
		wt_handle hwnd, wt_uint message, wt_wparam wParam, wt_lparam lParam)intm=
rmsg m
int i,result
intm l
static int count=0


m.hwnd:=hwnd
m.message:=message
m.wParam:=wParam
m.lParam:=lParam
m.pt.x:=0
m.pt.y:=0

if (wndproc_callbackfn) then
	result:=(wndproc_callbackfn^)(&m)
else
	result:=0
fi

if m.message=wm_destroy then
	return 0
fi

if not result then
	return DefWindowProcA(hwnd,message,wParam,lParam)
else
	return 0
fi
end

proc timerproc(wt_handle hwnd, int msg, id, time)=
println "TIMERPROC"
end

global proc os_setmesshandler(ref void addr)=
wndproc_callbackfn:=addr
end

global function os_getchx:int=
const rightaltmask	= 1
const leftaltmask	= 2
const leftctrlmask	= 8
const rightctrlmask	= 4
const shiftmask		= 16
const capsmask		= 128
const scrollmask	= 64
int count
int charcode,keyshift,keycode
int altdown,ctrldown,shiftdown,capslock

unless init_flag then os_init() end

if keypending then
	lastkey:=pendkey
	keypending:=0
else
	if lastkey.repeatcount=0 then
		repeat
			count:=0
			ReadConsoleInputA(hconsolein,&lastkey,1,&count)
		until (lastkey.eventtype=1 and lastkey.keydown=1)
	fi
fi


altdown		:= ((lastkey.controlkeystate iand (leftaltmask ior rightaltmask))|1|0)
ctrldown	:= ((lastkey.controlkeystate iand (leftctrlmask ior rightctrlmask))|1|0)
shiftdown	:= ((lastkey.controlkeystate iand shiftmask)|1|0)
capslock	:= ((lastkey.controlkeystate iand capsmask)|1|0)

--lastkey.repeatcount		!count this key out

charcode:=lastkey.asciichar
keycode:=lastkey.virtualkeycode iand 255

if charcode<0 then
	if charcode<-128 then
		charcode:=0
	else
		charcode+:=256
	fi
fi


if altdown and ctrldown and charcode=166 then
	altdown:=ctrldown:=0
else
	if altdown or ctrldown then
		charcode:=0
		if keycode>='A' and keycode<= 'Z' then
			charcode:=keycode-'@'
		fi
	fi
fi

keyshift:=capslock<<3 ior altdown<<2 ior ctrldown<<1 ior shiftdown

return keyshift<<24 ior keycode<<16 ior charcode
end

global function os_getos=>ichar=
if $targetbits=32 then
	return "W32"
else
	return "W64"
fi
end

global function os_gethostsize=>int=
return $targetbits
end

global function os_shellexec(ichar opc, file)int=
return system(file)
end

global proc  os_sleep(int a)=
Sleep(a)
end

global function os_getstdin:filehandle =
return fopen("con","rb")
end

global function os_getstdout:filehandle =
return fopen("con","wb")
end

global function os_gethostname:ichar=
static [300]char name
static int n

GetModuleFileNameA(nil,&.name,name.bytes)
strcat(&.name,"/")
return &.name
end

global function os_getmpath:ichar=
return F"C:\m\"
end

global proc os_exitprocess(int x)=
stop x
end

global function os_clock:int64=
return clock()
end

global function os_getclockspersec:int64=
return 1000
end

global function os_iswindows:int=
return 1
end

global function os_filelastwritetime(ichar filename)int64=
wt_handle f;
int64 ctime,atime,wtime;

if filename=nil then				!used to test whether supported
	return 1
fi

f:=CreateFileA(filename,0x80000000,1,nil, 3,3,nil);
if int64(f)=-1 then
	return 0
fi

GetFileTime(f,&ctime,&atime,&wtime);
CloseHandle(f);

return wtime;
end

global proc os_getsystime(ref rsystemtime tm)=
GetLocalTime(tm)
end

global proc os_messagebox(ichar s,t)=
messageboxa(0,s,t,0)
end

global function os_hpcounter:int64=
int64 a

queryperformancecounter(&a)
return a

end

global function os_hpfrequency:int64=
int64 a

queryperformancefrequency(&a)
return a

end

global proc os_peek=
int ticks
static int lastticks
[100]byte m
	ticks:=GetTickCount()
	if ticks-lastticks>=1000 then
		lastticks:=ticks
		PeekMessageA(&m,nil,0,0,0)
	fi
end
=== pci.m 6/56 ===
import msys

import mlib
import clib
import oslib

import pc_types
import pc_decls
import pc_support as pcs
import pc_print
import pc_jhandlers
import pc_khandlers
import pc_oslayer

mapmodule pc_assem => pc_assemc when ctarget
mapmodule pc_assem => pc_assembb when bb

import pc_assem
import pq_common
import pc_pcfns

global int dispatch_type = asm_dispatch

global tabledata() []ichar filetypenames=
	(pc_file,		$),
	(q_file,		$),		!one-time compilation (.pc file persistent)
	(qq_file,		$),		!always compile (.pc file temporary)
	(mem_file,		$),
end

global tabledata() [-4:]ichar errorcodenames =
	(runtime_error=-4,		"Runtime error"),
	(load_error,			"General load error:"),
	(compile_error,			"Couldn't compile:"),
	(filenotfound_error,	"File not found:"),
	(normal_exit,			$),
end

include "CCM_FN."

global function runpcl(ichar filename, int filetype=pc_file)int=

	ref byte pcfile			!in-memory pc file
	int stopcode
	ichar pcfilename





	if dispatch_type=asm_dispatch and not asmavailable() then
		dispatch_type:=fn_dispatch
	fi

	run_initdata()

	case filetype
	when pc_file then
		pcfile:=readfile(filename)
		if pcfile=nil then
			return filenotfound_error
		fi


	when mem_file then
		pcfile:=cast(filename)
	esac

	if not loadpcfile(pcfile) then
		return load_error
	fi

	if filetype=qq_file then			!remove .pc file created above
		remove(pcfilename)
	fi

	stopcode:=runpcprogram()


	return stopcode
end

global proc run_initdata=
	static int initialised=0

	if initialised then
		return
	fi

	if ncmdparams=0 then
		cmdparamtable[0]:=sysparams[1]
	fi

	pcm_init()
	inittypetables()
	initpcldata()
	initcalltables()
end

global function runpcprogram:int =

int i,j,cmd,fmt
ref int lab
int exitcode
int64 progticks

initbytecode()

varstack:=malloc(stacksize*varrec.bytes)
if not varstack then
	abortprogram("varstack?")
fi

sptr:=&varstack^[stacksize]

--sptr

stacklimit:=&varstack^[1000]


frameptr:=cast(sptr)

pcptr:=&moduletable[0].pccode^[1]
pccode:=cast(&moduletable[0].pccode^[0])

stopped:=0				!for use  fn table dispatch only

disploop()				!ENTER DISPATCHER LOOP



if sptr^.tagx=tvoid then
	return 0
else
	return sptr^.value
fi
end

proc initbytecode=

os_initwindows()

allocatestrings()
pclinit()

pcl_initusertypes()

fixup_all_pc()		!expand ci/cr/etc, convert proc refs etc

end

proc disploop=			!DISPLOOP
int i,k

case dispatch_type

when fn_dispatch then
	disploop_fn(0)

when deb1_dispatch,deb2_dispatch then
	disploop_deb()

when asm_dispatch then
	k:=os_clock()
	disploop_asm()
	k:=os_clock()-k
esac
end

proc pclinit =

int i


for i:=1 to klastcmd do
	case dispatch_type
	when fn_dispatch then
		cmdmap[i]:=disploop_fn(i)
	when deb1_dispatch, deb2_dispatch then
		cmdmap[i]:=cast(i)
	when asm_dispatch then
		cmdmap[i]:=cast(i)
	esac
od
end

proc fixup_all_pc =
int i,j,cmd,lab,a,index,startindex,recordtype,fieldtype,mx
int pp
int64 a64
genfielddatarec gd
ref intpc p

for mx:=1 to nmodules do
	fixup_module_pc(mx)
od
fixup_module_pc(0)

end

proc fixup_module_pc(int mx) =
int i,cmd,lab,index,startindex,recordtype,fieldtype
int pp,m
int64 a
genfielddatarec gd
ref intpc p,pccode
ref strec d,owner
static int 	SCOUNT=0
variant v

pccode:=p:=cast(moduletable[mx].pccode)

do
	cmd:=p^

	if mx=0 then
		if cmd=kstop and stopseq=nil then
			stopseq:=p-2
		elsif cmd=kraise and raiseseq=nil then
			raiseseq:=p
		fi
	fi
	p++^:=cast(cmdmap[cmd])			!convert cmd index to labeladdr/functionaddr/same index

	for i:=1 to cmdnopnds[cmd] do
		switch cmdfmt[cmd,i]
		when clabel then
			p^:=cast(pccode+p^-1)
		when cproc then
			d:=&pcsymboltable^[p^]
			if d^.address=nil then
				owner:=d^.owner
				while owner^.nameid=typeid do
					owner:=owner^.owner
				od
				m:=owner^.ax_moduleno
				d^.address:=cast(&(moduletable[m].pccode^[d^.index]))
			fi
			p^:=cast(d^.address)
		when cmemory then
			d:=&pcsymboltable^[p^]
			if d^.address=nil then
				v:=pcm_alloc(varsize)
				v^.tagx:=tvoid
				d^.address:=v
			fi
			p^:=cast(d^.address)
		when cstring then
			p^:=cast(&stringobjtable^[p^])
		endswitch
		++p
	od
	if cmd=kendmodule or cmd=0 then
		exit
	fi
od
if dispatch_type=asm_dispatch then
	fixup_asm(mx)
fi
end

function disploop_fn(int n)ref int =			!DISPLOOP_FN
int64 count
const intervalcount=1

type fnptr=ref ref function: ref intpc

word lastticks,ticks

if n then		! return jumptable item
	return ref int(handlertable[n])
fi

count:=intervalcount
lastticks:=os_clock()

repeat
	pcptr:=ref ref function:ref intpc(pcptr)^^()
	pcptr:=ref ref function:ref intpc(pcptr)^^()
	pcptr:=ref ref function:ref intpc(pcptr)^^()
	pcptr:=ref ref function:ref intpc(pcptr)^^()
	pcptr:=ref ref function:ref intpc(pcptr)^^()
	pcptr:=ref ref function:ref intpc(pcptr)^^()
until stopped

ticks:=os_clock()-lastticks

return nil
end

proc disploop_deb=
int a,b,i,j,k,totalcounts,lastcmd,cmd,t,u
int index,file,line,moduleno
variant p
int count
const intervalcount=1

type fnptr2=ref ref function: ref intm
type fnptr=ref function: ref intm
fnptr fn

word lastticks,ticks

count:=intervalcount
lastticks:=os_clock()

lastcmd:=knop

repeat
	cmd:=pcptr^

	if dispatch_type=deb1_dispatch or fdebug then
		ichar filename
		findlinenumber(pcptr, line, moduleno)
		index:=&varstack^[stacksize]-sptr
		cpl PCPTR,"<",,cmdnames[cmd],,">",=line,=sptr,=index
SHOWLINENUMBER()

	fi

	pcptr:=cast(fnptr(handlertable[pcptr^])^())

until stopped

CPL "DEB STOPPED"
end

global proc runproc(ref void fnptr,variant a,b,dest) =			!RUNPROC

variant oldsptr
ref byte oldframeptr
ref intpc oldpcptr
byte oldstopped
int nparams

dest^.tagx:=ti32
dest^.value:=0

oldstopped:=stopped		!not really need, as it can be assumed stopped=0
oldpcptr:=pcptr
oldsptr:=sptr
oldframeptr:=frameptr

(--sptr)^.tagx:=999				!put in marker (this location might be checked later)

if b and b^.tag then			!must stack in reverse order: (b,a) or (a)
	nparams:=2
	(--sptr)^:=b^
	(--sptr)^:=a^
elsif a and a^.tag then
	nparams:=1
	(--sptr)^:=a^
else
	nparams:=0
fi
(--sptr)^.tagx:=tretaddr

sptr^.uret.retaddr:=stopseq

sptr^.uret.frameptr_low:=int32@(frameptr)
sptr^.uret.stackadj:=nparams*varsize
frameptr:=cast(sptr)
pcptr:=fnptr

disploop()

if (sptr+1)^.tag=tretaddr then		!probably stop used
	CPL "RUNPROC: STOP used"
	dest^:=sptr^
else								!assume normal return used
++SPTR
	dest^:=sptr^					!pick up return value

	if dest^.tag=tvoid then		!no value; return 0
		dest^.tagx:=ti32
		dest^.value:=0
	fi
fi

pcptr:=oldpcptr
stopped:=oldstopped

sptr:=oldsptr			!need to reset these, as stop could have been executed anywhere
frameptr:=oldframeptr	! and these could have arbitrary values
stopped:=oldstopped
end

proc allocatestrings=

object p
int i
ref char s

stringobjtable:=ref void(zalloctable(nstrings,objrec.bytes))

for i:=1 to nstrings do
	s:=stringtable^[i]

	p:=&stringobjtable^[i]
	p^.refcount:=5
	p^.ustr.strptr:=s				!does not reallocate to heap
	p^.ustr.length:=stringlentable^[i]
	p^.ustr.objtype:=extslice_obj
od

end

global function compileq(ichar qfilename)ichar pcfilename=
	[300]char cmdstr
	int status

ABORTPROGRAM("PCI:COMPILEQ NEEDS REVISING")
RETURN ""

end

function loadpcfile(ref byte s)int=

[100]char modulename
[100]char name
ichar str,str2
modulerec m
int i,j,a,b,dir,symtype,x,id,t,modno,n,cmd,recordtype,length
ref strec d
ref [0:]word16 linetable
ref intpc pccode
real xvalue

pcm_clearmem(&moduletable[0],modulerec.bytes)
moduletable[0].name:="PROGRAM"
moduletable[0].filename:="<->"
moduletable[0].sourcecode:="<program>"
moduletable[0].sourcelen:=strlen(moduletable[0].sourcecode)




a:=s++^						!read PCL
b:=s++^
if a<>'P' or b<>'C' then
	cpl "PC: bad sig"
	return 0
fi
s+:=2						!skip etx and 0

do
	dir:=readzint(&s)
	switch dir
	when kkpclversion then
		strpclversion:=readzstring(&s,nil)

	when kkmoduletable then
		nmodules:=readzint(&s)
		for i:=1 to nmodules do
			memset(&m,0,m.bytes)
			m.name:=pcm_copyheapstring(readzstring(&s,nil))
			m.filename:=m.name
			m.sourcecode:="<no source>"
			m.sourcelen:=0
			moduletable[i]:=m
		od

	when kkdlltable then
		ndlltable:=readzint(&s)
		for i:=1 to ndlltable do
			dlltable[i]:=pcm_copyheapstring(readzstring(&s,nil))
			dllinsttable[i]:=0
		od

	when kkdllproctable then
		ndllproctable:=readzint(&s)
		for i:=1 to ndllproctable do
			dllproctable[i].name:=pcm_copyheapstring(readzstring(&s,nil))
			dllproctable[i].dllindex:=readzint(&s)
		od

	when kkapplproctable then
		napplproctable:=readzint(&s)
		for i:=1 to napplproctable do
			applproctable[i].name:=pcm_copyheapstring(readzstring(&s,nil))
		od

	when kksymboltable then
		nsymbols:=readzint(&s)
		pcsymboltable:=zalloctable(nsymbols,strec.bytes)

		for i:=1 to nsymbols do
			symtype:=readzint(&s)			!'P' etc but stored as int
			case symtype
			when 'P' then id:=procid
			when 'S' then id:=staticid
			when 'M' then id:=moduleid
			when 'T' then id:=typeid
			esac
			str:=pcm_copyheapstring(readzstring(&s,nil))
			x:=readzint(&s)				!d is owner index
			a:=readzint(&s)				!general params
			b:=readzint(&s)				!general params
			d:=createstentry(i,str,x,id)
			d^.index:=a
			case id
			when moduleid then
				d^.ax_moduleno:=a
			when procid then
				str:=readzstring(&s,nil)
				if str^ then
					d^.metadata:=pcm_copyheapstring(str)
				fi
			esac
		od

	when kktypetable then
		n:=readzint(&s)
		ntypes:=n+tlast-1
		for i:=1 to n do
			t:=readzint(&s)
			ttname[t]:=pcm_copyheapstring(readzstring(&s,nil))
			ttnamedef[t]:=&pcsymboltable^[readzint(&s)]
			ttbasetype[t]:=readzint(&s)
			tttarget[t]:=readzint(&s)
			ttlower[t]:=readzint(&s)
			ttlength[t]:=readzint(&s)
			ttsize[t]:=readzint(&s)
		od

	when kkgenfieldnames then
		ngenfieldnames:=readzint(&s)
		for i:=1 to ngenfieldnames do
			genfieldnames[i].name:=pcm_copyheapstring(readzstring(&s,nil))
			genfieldnames[i].dataindex:=readzint(&s)
			genfieldnames[i].datalength:=readzint(&s)
		od

	when kkgenfielddata then
		ngenfielddata:=readzint(&s)
		if ngenfielddata>maxgenfields then
			pcs.loaderror("Too many genfields")
		fi
		for i:=1 to ngenfielddata do
			genfielddata[i].fieldindex:=readzint(&s)
			genfielddata[i].recordtype:=readzint(&s)
			genfielddata[i].fieldtype:=readzint(&s)
			a:=readzint(&s)
			if genfielddata[i].fieldtype=trefproc then
				genfieldpcaddress[i]:=getprocaddr(a)
			else
				genfielddata[i].offset:=a
			fi
		od

	when kknewstringtable then
		nstrings:=readzint(&s)
		stringtable:=alloctable(nstrings,ichar.bytes)
		stringlentable:=alloctable(nstrings,int.bytes)

		for i:=1 to nstrings do
			length:=readzint(&s)
			str:=cast(readzblock(&s,length))
			stringlentable^[i]:=length
			str2:=pcm_alloc(length+1)
			memcpy(str2,str,length)
			(str2+length)^:=0				!keep zero-terminated for now

			stringtable^[i]:=str2

		od

	when kkstructtable then
		nstructfields:=readzint(&s)
		pcfieldtable:=zalloctable(nstructfields,strec.bytes)

		t:=0
		n:=0
		for i:=1 to nstructfields do
			recordtype:=readzint(&s)				!field owner struct type
			if recordtype<>t then					!new struct
				if t then
					ttstructfields[t]:=n
				fi
				t:=recordtype
				ttstartfield[t]:=i
				n:=0
			fi
			++n
			pcfieldtable^[i].recordtype:=recordtype
			pcfieldtable^[i].name:=pcm_copyheapstring(readzstring(&s,nil))
			pcfieldtable^[i].fieldtype:=readzint(&s)
			pcfieldtable^[i].fieldoffset:=readzint(&s)
		od
		if t then
			ttstructfields[t]:=n
		fi

	when kkpccode then
		modno:=readzint(&s)
		n:=readzint(&s)
		moduletable[modno].linetable:=linetable:=zalloctable(n,int16.bytes)

		moduletable[modno].pccode:=zalloctable(n,intpc.bytes)
		pccode:=cast(moduletable[modno].pccode)
		moduletable[modno].pcindex:=n
		moduletable[modno].npccode:=n
		i:=0
		while ++i<=n do
			linetable^[i]:=readzint(&s)
			cmd:=readzint(&s)
			pccode++^:=cmd

			for j to cmdnopnds[cmd] do
				++i
				case cmdfmt[cmd,j]
				when creal then
					xvalue:=readzreal(&s)
					pccode++^:=intpc@(xvalue)
				else
					pccode++^:=readzint(&s)
				esac
			od
		od

	when kkend then
		exit
	else
		pcs.loaderror("PCDIR?")
	endswitch
od


return 1
end

global proc initpcldata=
int i,j,nn
for i:=1 to klastcmd do
	nn:=0
	for j:=1 to 4 do
		if cmdfmt[i,j]=0 then exit fi
		++nn
	od
	cmdnopnds[i]:=nn
od
end

function createstentry(int index,ichar name, int owner, id)ref strec=
ref strec p

if index then					!part of linear symbol table
	p:=&pcsymboltable^[index]
else							!ad hoc
	p:=pcm_allocz(strec.bytes)
fi

p^.name:=name
p^.nameid:=id
if owner then
	p^.owner:=&pcsymboltable^[owner]
else
	p^.owner:=stprogram
fi
return p
end

function getprocaddr(int n)ref intpc=
ref strec d,owner
int m

d:=&pcsymboltable^[n]
if d^.address=nil then
	owner:=d^.owner
	while owner^.nameid=typeid do
		owner:=owner^.owner
	od
	m:=owner^.ax_moduleno
	d^.address:=cast(&(moduletable[m].pccode^[d^.index]))
fi
return cast(d^.address)
end

global proc pcl_initusertypes =			!PCL_INITUSERTYPES
int t,sig,basesig

for t:=tlast to ntypes do
	case ttbasetype[t]
	when trecord then
		free_table[t]:=cast(&j_free_m)
		dupl_table[t]:=cast(&j_dupl_l_m_d)
		tostr_table[t]:=cast(&j_tostr_l_m)
		len_table[t]:=len_table[trecord]
		lwb_table[t]:=lwb_table[trecord]
		upb_table[t]:=upb_table[trecord]
		bounds_table[t]:=bounds_table[trecord]

		basesig:=gettypesig(trecord,tint)
		sig:=gettypesig(t,tint)
		pushix_dtable[sig]:=pushix_dtable[basesig]
		pushdotix_dtable[sig]:=pushdotix_dtable[basesig]
		pushdotixref_dtable[sig]:=pushdotixref_dtable[basesig]

	when tstruct then
		free_table[t]:=free_table[tstruct]
		dupl_table[t]:=dupl_table[tstruct]
		tostr_table[t]:=tostr_table[tstruct]

	when tarray then
		free_table[t]:=free_table[tarray]
		dupl_table[t]:=dupl_table[tarray]
		tostr_table[t]:=tostr_table[tarray]
		len_table[t]:=len_table[tarray]
		lwb_table[t]:=lwb_table[tarray]
		upb_table[t]:=upb_table[tarray]

		basesig:=gettypesig(tarray,tint)
		sig:=gettypesig(t,tint)
		pushix_dtable[sig]:=pushix_dtable[basesig]
		pushixref_dtable[sig]:=pushixref_dtable[basesig]
	esac

od
end

global proc setcmdparam(int index, ichar s)=
	if s=nil then
		ncmdparams:=index
	elsif index<=maxcmdparam then
		cmdparamtable[index]:=pcm_copyheapstring(s)
		ncmdparams max:=index
	fi
end
=== ccm_fn. 7/56 ===
mut [0:]ref void handlertable = (nil,
 &k_nop,
 &k_procstart,
 &k_procend,
 &k_endmodule,
 &k_push_m,
 &k_push_f,
 &k_push_am,
 &k_push_af,
 &k_push_ap,
 &k_push_al,
 &k_push_ci,
 &k_push_cw,
 &k_push_cr,
 &k_push_cn,
 &k_push_cs,
 &k_push_t,
 &k_push_op,
 &k_pushz,
 &k_pushz_void,
 &k_pushz_str,
 &k_pushz_list,
 &k_pushz_listl,
 &k_pushz_set,
 &k_pushz_arrayl,
 &k_pop_m,
 &k_pop_f,
 &k_store_m,
 &k_store_f,
 &k_pushptr,
 &k_popptr,
 &k_storeptr,
 &k_zpop_m,
 &k_zpop_f,
 &k_zstore_m,
 &k_zstore_f,
 &k_copy,
 &k_swap,
 &k_convptr,
 &k_jump,
 &k_jumpptr,
 &k_jumptrue,
 &k_jumpfalse,
 &k_jumpdef,
 &k_jumpvoid,
 &k_jumpeq,
 &k_jumpne,
 &k_jumplt,
 &k_jumple,
 &k_jumpge,
 &k_jumpgt,
 &k_jumptesteq,
 &k_jumptestne,
 &k_jumplabel,
 &k_jumpclabel,
 &k_switch,
 &k_cswitch,
 &k_new,
 &k_to_f,
 &k_for_fci,
 &k_for_ff,
 &k_ford_fci,
 &k_ford_ff,
 &k_call,
 &k_callptr,
 &k_return,
 &k_startdll,
 &k_pushdll,
 &k_calldll,
 &k_callhost,
 &k_stackframe,
 &k_free,
 &k_addsp,
 &k_stop,
 &k_test,
 &k_makelist,
 &k_makerecord,
 &k_makearray,
 &k_makestruct,
 &k_makeset,
 &k_makerange,
 &k_makedict,
 &k_pushdot,
 &k_pushdotref,
 &k_softconv,
 &k_hardconv,
 &k_mixed,
 &k_incrptr,
 &k_incrto_m,
 &k_incrto_f,
 &k_loadincr,
 &k_incrload,
 &k_decrptr,
 &k_decrto_m,
 &k_decrto_f,
 &k_loaddecr,
 &k_decrload,
 &k_incr,
 &k_decr,
 &k_neg,
 &k_abs,
 &k_not,
 &k_inot,
 &k_istrue,
 &k_asc,
 &k_chr,
 &k_sqrt,
 &k_sqr,
 &k_cube,
 &k_sin,
 &k_cos,
 &k_tan,
 &k_asin,
 &k_acos,
 &k_atan,
 &k_sign,
 &k_ln,
 &k_log,
 &k_lg,
 &k_exp,
 &k_round,
 &k_floor,
 &k_ceil,
 &k_fract,
 &k_negto,
 &k_absto,
 &k_notto,
 &k_inotto,
 &k_len,
 &k_lwb,
 &k_upb,
 &k_bounds,
 &k_bits,
 &k_bytes,
 &k_type,
 &k_elemtype,
 &k_basetype,
 &k_minval,
 &k_maxval,
 &k_isint,
 &k_isreal,
 &k_isstring,
 &k_isrange,
 &k_isnumber,
 &k_isarray,
 &k_isrecord,
 &k_ispointer,
 &k_ismutable,
 &k_isset,
 &k_isvoid,
 &k_isdef,
 &k_tostr,
 &k_isequal,
 &k_add,
 &k_sub,
 &k_mul,
 &k_div,
 &k_idiv,
 &k_rem,
 &k_divrem,
 &k_iand,
 &k_ior,
 &k_ixor,
 &k_shl,
 &k_shr,
 &k_in,
 &k_notin,
 &k_inrev,
 &k_eq,
 &k_ne,
 &k_lt,
 &k_le,
 &k_ge,
 &k_gt,
 &k_min,
 &k_max,
 &k_concat,
 &k_append,
 &k_power,
 &k_atan2,
 &k_addto,
 &k_subto,
 &k_multo,
 &k_divto,
 &k_idivto,
 &k_iandto,
 &k_iorto,
 &k_ixorto,
 &k_shlto,
 &k_shrto,
 &k_minto,
 &k_maxto,
 &k_concatto,
 &k_appendto,
 &k_pushix,
 &k_pushdotix,
 &k_pushkeyix,
 &k_pushkeyixd,
 &k_pushixref,
 &k_pushdotixref,
 &k_pushkeyixref,
 &k_pushbyteix,
 &k_pushbyteixref,
 &k_appendset,
 &k_pushdotm,
 &k_pushdott,
 &k_push_ad,
 &k_push_try,
 &k_raise,
 &k_applyop,
 &k_makeiter,
 &k_forall,
 &k_forallx,
 &k_foreach,
 &k_foreachx,
 &k_expandrange,
 &k_callappl,
 nil)
=== pc_types.m 8/56 ===
global tabledata() [0:]ichar stdtypenames, [0:]int stdtypewidths =
	(tvoid=0,		$,		128),	! means variant is unassigned

	(tint,			$,		64),	! 64-bit signed int
	(tword,			$,		64),	! 64-bit unsigned int
	(treal,			$,		64),	! 64-bit float
	(trange,		$,		64),	! 32+32-bit int:int

	(tstring,		$,		0),		! 8-bit string, flex and mutable
	(twstring,		$,		0),		! 16/32-bit string, flex and mutable
	(tbignum,		$,		0),		! Arbitrary precision integer
	(trational,		$,		0),		! Rational number, made of two longints
	(tset,			$,		0),		! Pascal-like bit-set
	(tdict,			$,		0),		! Dictionary of X:Y keys and values
	(tword128,		$,		0),		! 128-bit unsigned int

	(tenum,			$,		0),		! (Used in compiler, not at runtime)
	(ttype,			$,		64),	! Represents a type-code
	(toperator,		$,		64),	! Represents an operator (as a bytecode op)
	(tsymbol,		$,		64),	! Reference to a symbol: module, proc, class, etc
	(tretaddr,		$,		0),		! Return address descriptor, only on stack 
	(texception,	$,		0),		! Exception descriptor, only on stack
	(trefproc,		$,		64),	! Pointer to Q proc
	(trefdllproc,	$,		64),	! Pointer to foreign function
	(treflabel,		$,		64),	! Pointer to label
	(tstringz,		$,		64),	! C-style zero-terminated 8-bit string within struct field

	(trefvar,		$,		64),	! Pointer/slice to Variant
	(trefpacked,	$,		0),		! Pointer/slice to Packed (uses target tag)
	(trefbit,		$,		0),		! Pointer/slice to Bits
	(trecordlink,	$,		0),		! Link to record object

	(treflist,		$,		0),		! Pointer to list slice
	(trefarray,		$,		0),		! Pointer to array slice
	(trefbits,		$,		0),		! Pointer to bits slice

	(tlist,			$,		0),		! Sequence of variants
	(tarray,		$,		0),		! Sequence of packed
	(tbits,			$,		0),		! Sequence of bits

	(trecord,		$,		0),		! Record of shorts and longs
	(tstruct,		$,		0),		! Record of packed and flat arrays/structs

	(tuser,			$,		0),		! used for anonymous user types during exportspass
	(tvariant,		$,		128),	!marks transition to packed types

	(tc8,			$,		8),		! 8-bit character
	(ti8,			$,		8),		! 8-bit signed int
	(ti16,			$,		16),	! etc 
	(ti32,			$,		32),	! 
	(ti64,			$,		64),	! 
	(tbit,			$,		1),		! 1-bit unsigned
	(tbit2,			$,		2),		! 2-bit
	(tbit4,			$,		4),		! 4-bit
	(tu8,			$,		8),		! 8-bit unsigned int etc
	(tu16,			$,		16),	! 
	(tu32,			$,		32),	! 
	(tu64,			$,		64),	! 
	(tr32,			$,		32),	! 32-bit float
	(tr64,			$,		64),	! 
	(tintm,			$,		32),	! 32 or 64-bit host signed int 
	(twordm,		$,		32),	! 32 or 64-bit host unsigned int 
	(trefm,			$,		64),	! 32 or 64-bit host pointer

	(tlast,			$,		0)		! 	!

end
=== pc_decls.m 9/56 ===
import msys
import clib
import pc_types
import pq_common

global macro getopnda = (pcptr+1)^
global macro getopndb = (pcptr+2)^
global macro getopndc = (pcptr+3)^
global macro getopndd = (pcptr+4)^

global macro ttelemtype = tttarget

global macro tu1 = tbit
global macro tu2 = tbit2
global macro tu4 = tbit4

global type variant = ref varrec
global type object  = ref objrec
global type intpc	= int64

global const maxmodule=50

global tabledata() [0:]ichar usercatnames =
	(std_cat=0,	$),
	(anon_cat,	$),
	(user_cat,	$)
end

global record uflagsrec =
	[7]byte	codes
	byte	ulength
end

global record fieldrec =
	ichar name
	int16 recordtype
	int16 fieldtype
	int32 fieldoffset
end

global record strec =
	ichar name
	ref strec owner
	ref strec deflist
	ref strec nextdef
	ichar metadata

	byte symbol
	byte nameid
	int16 subcode

	int16 mode
	byte ax_at					!0 or 1 if @ used (fields only)
	byte ax_moduleno

	int32 index					!needs to hold pcindex (also indices for all symbols or .bc files)

	union
		ref void address
		int32 offset
		ref intpc pcaddress
	end
end

record listrec =
	word32		refcount
	word16		tag
	struct
		byte	objtype
		byte	mutable
	end

	union
		variant		vptr
		word64		padding1
	end

	word32		length
	int32		lower

	union
		object	objptr2
		word32	allocated
		word64	padding2
	end
end

record stringrec =
	word32		refcount
	word16		tag
	struct
		byte	objtype
		byte	mutable
	end

	union
		ichar		strptr
		word64		padding1
	end

	int32		length
	int32		spare3

	union
		object	objptr2
		word32	allocated
	end
end

record recordrec =
	word32		refcount
	word16		tag
	struct
		byte	spare
		byte	mutable
	end

	union
		variant		vptr
		ref byte	ptr
		word64		padding1
	end

	word32		length		!make is easier to index like a list
	int32		lower

	int			spare2
end

record decimalrec =
	word32		refcount
	word16		tag
	byte		spare1
	byte		spare2

	union
		ref void	bnptr
		word64		padding1
	end

	int			spare3
	int			spare4
end

record setrec =
	word32		refcount
	word16		tag
	struct
		byte	spare
		byte	mutable
	end

	union
		ref byte	ptr
		word64		padding1
	end

	word32		length
	int16		lower
	int16		elemtag

	word64		allocated64
end

record dictrec =
	word32		refcount
	word16		tag
	struct
		byte	spare
		byte	mutable
	end

	union
		variant		vptr
		word64		padding1
	end

	word32		length
	int32		lower

	union
		struct
			word32		allocated
			word32		dictitems
		end
		object			objptr2
	end
end

record arrayrec =
	word32		refcount
	word16		tag
	struct
		byte	objtype
		byte	mutable
	end

	union
		ref byte	ptr
		word64		padding1
	end

	word32		length
	int16		lower
	int16		elemtag

	union
		object	objptr2
		word32	allocated
	end
end

record bitsrec =
	word32		refcount
	word16		tag
	struct
		byte	objtype
		byte	mutable
	end

	union
		ref byte	ptr
		word64		padding1
	end

	word32		length
	int16		lower
	byte		elemtag
	byte		bitoffset

	union
		object	objptr2
		word64	allocated64
	end
end

record structrec =
	word32		refcount
	word16		tag
	struct
		byte	spare
		byte	mutable
	end

	union
		ref byte	ptr
		word64		padding1
	end

	word32		length
	int16		lower
	int16		elemtag

	union
		object	objptr2
		word32	allocated
	end
end

global record objrec =				!32 bytes
	union
		struct
			word32		refcount
			word16		tag
			byte		objtype		!normal/slice/ext for string/list/array/struct
			byte		spare1

			word64		spare2
			word64		spare3
			union
				object	objptr2		!share with string/list/array/struct?
				word64	dummy4
			end
		end

		listrec				ulist
		stringrec			ustr
		recordrec			urec
		decimalrec			udec
		setrec				uset
		dictrec				udict
		arrayrec			uarray
		bitsrec				ubits
		structrec			ustruct
	end
end


record exceptionrec =
	union
		struct
			word16	tag
			byte	hasref
			byte	exceptiontype
		end
	end
	struct
		int16 		frameoffset
		int16 		nexceptions
	end

	ref byte		ptr
end

record returnrec =
	union
		struct
			word16	tag
			byte	hasref
			byte	stackadj
		end
	end
	int32			frameptr_low

	ref intpc		retaddr
end

record refrec =
	union
		struct
			word16	tag
			byte	hasref
			byte	spare1
		end
	end
	struct
		word16		elemtag
		byte		bitoffset
		byte		bitlength		!for refbit/tbit: 0=1 bit, N=bitfield
	end

	union
		ref byte		ptr
		ref int64		ptr64
	end
end

record operatorrec =
	union
		struct
			word16	tag
			byte	hasref
			byte	opdims
		end
	end
	word32 			spare2

	int				opcode
end

record iterrec =
	union
		struct
			word16	tag
			byte	hasref
			byte	opdims
		end
	end
	word32 			itcount

	byte			ittype
	[3]byte			spare3
end

global record varrec =
	union
		struct
			union
				struct
					word16	tag
					byte	hasref
					byte	spare1
				end
				word32		tagx
			end
			word32 			spare2
			union
				int64		value
				real64		xvalue
				word64		uvalue
				struct
					int32	range_lower			!short range
					int32	range_upper
				end
				object		objptr				!objects where hasref=1
				variant		varptr				!for refvar
				ref byte	refptr				!for refproc etc
			end
		end

		exceptionrec			uexcept
		returnrec				uret
		refrec					uref
		operatorrec				uop
		iterrec					uiter

	end
end

global record genfieldnamerec =
	ichar name					!after bc load
	int32 dataindex
	union
		int32 datalength
		int32 datalast
	end
end

global record genfielddatarec =
	int32 fieldindex
	int32 recordtype
	int32 fieldtype			!-procid, -constid, -staticid, -typeid are special codes
	union
		int32 offset			!or const value
		word32 index			!into proctable, statictable, or type code
		word32 procoffset
	end
end

global record modulerec =
	ichar name
	ichar filename
	ichar sourcecode
	ref[]intpc pccode
	ref[0:]word16 linetable
	int32 sourcelen
	int32 npccode				!current allocated size of pccode
	int32 pcindex				!index of last entry in pccode
	int32 level
	int32 exported			!imported within export/endexport
	[maxmodule]byte importmap

end

global record dllprocrec =
	ichar name
	ref proc address
	int32 dllindex
end

global record applprocrec =
	ichar name
	ref proc address
	ref procinforec info
end


global record procrec =
	ref strec def
	ref procrec nextproc
end

global record fmtrec=
	byte	minwidth	! (0)   min field width (0 if not used or don't care)
	i8	precision	! (0)   number of decimals/significant figures/max width
	byte	base		! (10)  2,8,10,16

	char	quotechar	! (0)   0/'"'/c
	char	padchar		! (' ') ' '/'0'/c
	char	realfmt		! ('f') 'e'/'f'/'g'

	char	plus		! (0)   0/'+'
	char	sepchar		! (0)   0/','/c placed every 3 (base=10) or 4 digits
	char	lettercase	! ('A') 'A'/'a'
	char	justify		! ('R') 'L'/'R'/'C'?
	char	suffix		! (0)   0/'B'/'H'/c
	char	usigned		! (0)   0/'U' force unsigned o/p for ints (eg. for hex display)
	char	charmode	! (0)  0/'U'/'M'	o/p int as int/single char/multi-char
	char	showtype	! (0) 0/'Y'	Show type
	[2]byte	spare
end

global const int maxtype=300

global int ntypes
global [0:maxtype]int32 ttmodule		!module number
global [0:maxtype]ref strec ttnamedef
global [0:maxtype]int32 ttbasetype	!basetype
global [0:maxtype]ichar ttname 	!name of type
global [0:maxtype]int32 ttbitwidth

global [0:maxtype]int64 ttsize 		!.size in bytes
global [0:maxtype]int32 ttlower 		!.lbound (default 1 or case unused)
global [0:maxtype]word32 ttlength 		!elements in array/record (actual fields) (/string
global [0:maxtype]int32 ttstartfield 		!start index in pcfieldtable^[]
global [0:maxtype]int32 ttstructfields	!entries in pcfieldtable^[]

global [0:maxtype]int32 tttarget 		!for array/ref types
global [0:maxtype]byte ttusercat

global [0:maxtype]byte typestarterset

global const hasrefmask = 0x10000		!1st bit of 3rd byte, when writing to .tagx

global tabledata() [0:]ichar objtypenames =
	(normal_obj=0,	$),
	(slice_obj,		$),
	(extslice_obj,	$)
end

global const int varsize=varrec.bytes
global const int objsize=objrec.bytes

global [0..255]object chrtable		!remember single-character objects

global [0..maxmodule]modulerec moduletable
global int nmodules
global [maxmodule]ichar pendingmodules
global int npendingmodules
global int currmoduleno				!used when compiling modules
global ref modulerec currmodule

global const maxsearchdirs=6
global [maxsearchdirs]ichar searchdirs
global int nsearchdirs=0

global ref strec stprogram		!root into the symbol table

global int optflag=0		!1=stdoptimise; 0=disabled

global const maxgenfields=1000
global [maxgenfields]genfieldnamerec genfieldnames
global [maxgenfields]genfielddatarec genfielddata
global [maxgenfields]ref intpc genfieldpcaddress
global int ngenfieldnames
global int ngenfielddata

global const sourceext="q"
global const arraylbound=1

global const maxlibpaths=10
global [maxlibpaths]ichar libpaths
global int nlibpaths

global int ftrace=0			!whether to line trace
global int fdtrace=0		!whether to line trace, enabled by $setdebug(1)
global int foptimise=0		!whether to generate optimised j-codes

global int mlineno=0		!set in pclgen dispatcher

global int exportsprepass=0		!1 for preparse scan only

global int debug=0

global int NNAMES, NCHECKS

global int FORCHECK
global int NCLASHES
global int NLOOKUPS

global int ALLNAMES
global int ALLFOUNDNAMES
global int ALLNOTFOUNDNAMES

global varrec ttdeststrv
global variant ttdeststr = &ttdeststrv

global int totalstrings=0


global tabledata() []ichar dispatchnames=
	(lab_dispatch,	"-lab"),
	(fn_dispatch,	"-fn"),
	(deb1_dispatch,	"-deb1"),
	(deb2_dispatch,	"-deb2"),
	(asm_dispatch,	"-asm")
end


global const int stacksize=65536
global const int maxdllindex=30

global variant sptr
global variant stacklimit
global ref byte frameptr
global ref intpc pcptr

global ref[0:]varrec varstack
global ref[0:]objrec		stringobjtable

global int dllindex
global int dllcallindex
global [maxdllindex]int64 dllparams
global [maxdllindex]int64 dllcallstack
global [maxdllindex]int16 dlltypes

global const maxdlllib=50
global const maxdllproc=2000

global int ndlltable
global int ndllproctable
global [maxdlllib]ichar dlltable
global [maxdlllib]word64 dllinsttable
global [maxdllproc]dllprocrec dllproctable

global const maxapplproc=500
global int napplproctable
global [maxapplproc]applprocrec applproctable

global ref clang proc fprintf_ptr
global ref clang proc fgets_ptr

global ref proc pcl_callbackfn=nil	!address of *PCL* function (pcdata address)

global ichar pcerror_mess=nil		!custom message for pcerror()

global varrec emptystringvar

global const int maxcmdparam=32
global int ncmdparams
global [0..maxcmdparam]ichar cmdparamtable

global ref procrec proclist			!linked list of all procs
global int nproclist

global int nstrings=0
global int nsymbols=0
global int nstructfields=0

global ref[]ichar stringtable
global ref[]int stringlentable

global ref[]strec pcsymboltable			!controlled with nsymbols

global ref[]fieldrec pcfieldtable		!controlled with nstructfields


global const int maxextra=10
global [maxextra]ichar extrafiles,extratext
global [maxextra]int extrasizes
global int nextra

global ichar err_message
global varrec err_var1, err_var2
global ref intpc err_pcptr

global ref intpc stopseq		!point to a 'stop 0' sequence
global ref intpc raiseseq		!point to a sequence of several 'raise' cmdcodes

global ref[]intpc pccode
global int npccode=0				!current allocated size of pccode
global int pcindex					!index of last entry in pccode
global ref[0:]word16 linetable		!copy of table from moduletable

global [0..cmdnames.upb]int cmdnopnds

global int lastticks=0

global [0:maxtype+1]ref function:ref intpc neg_table
global [0:maxtype+1]ref function:ref intpc abs_table
global [0:maxtype+1]ref function:ref intpc inot_table
global [0:maxtype+1]ref function:ref intpc istrue_table
global [0:maxtype+1]ref function:ref intpc jumpf_table
global [0:maxtype+1]ref function:ref intpc jumpt_table
global [0:maxtype+1]ref function:ref intpc len_table
global [0:maxtype+1]ref function:ref intpc lwb_table
global [0:maxtype+1]ref function:ref intpc upb_table
global [0:maxtype+1]ref function:ref intpc bounds_table
global [0:maxtype+1]ref function:ref intpc incr_table
global [0:maxtype+1]ref function:ref intpc decr_table

global [0:maxtype+1]ref function:ref intpc add_table
global [0:maxtype+1]ref function:ref intpc sub_table
global [0:maxtype+1]ref function:ref intpc mul_table
global [0:maxtype+1]ref function:ref intpc div_table
global [0:maxtype+1]ref function:ref intpc idiv_table
global [0:maxtype+1]ref function:ref intpc rem_table
global [0:maxtype+1]ref function:ref intpc iand_table
global [0:maxtype+1]ref function:ref intpc ior_table
global [0:maxtype+1]ref function:ref intpc ixor_table
global [0:maxtype+1]ref function:ref intpc shl_table
global [0:maxtype+1]ref function:ref intpc shr_table
global [0:maxtype+1]ref function:ref intpc min_table
global [0:maxtype+1]ref function:ref intpc max_table
global [0:maxtype+1]ref function:ref intpc jumpeq_table
global [0:maxtype+1]ref function:ref intpc jumpne_table
global [0:maxtype+1]ref function:ref intpc jumplt_table
global [0:maxtype+1]ref function:ref intpc jumpgt_table
global [0:maxtype+1]ref function:ref intpc jumple_table
global [0:maxtype+1]ref function:ref intpc jumpge_table
global [0:maxtype+1]ref function:ref intpc jumptesteq_table
global [0:maxtype+1]ref function:ref intpc jumptestne_table
global [0:maxtype+1]ref function:ref intpc jumpfalse_table
global [0:maxtype+1]ref function:ref intpc jumptrue_table
global [0:maxtype+1]ref function:ref intpc eq_table
global [0:maxtype+1]ref function:ref intpc lt_table
global [0:maxtype+1]ref function:ref intpc le_table
global [0:maxtype+1]ref function:ref intpc concat_table
global [0:maxtype+1]ref function:ref intpc append_table

global [0:maxtype+1]ref function:ref intpc addto_table
global [0:maxtype+1]ref function:ref intpc subto_table
global [0:maxtype+1]ref function:ref intpc multo_table
global [0:maxtype+1]ref function:ref intpc divto_table
global [0:maxtype+1]ref function:ref intpc idivto_table
global [0:maxtype+1]ref function:ref intpc iandto_table
global [0:maxtype+1]ref function:ref intpc iorto_table
global [0:maxtype+1]ref function:ref intpc ixorto_table
global [0:maxtype+1]ref function:ref intpc shlto_table
global [0:maxtype+1]ref function:ref intpc shrto_table
global [0:maxtype+1]ref function:ref intpc minto_table
global [0:maxtype+1]ref function:ref intpc maxto_table
global [0:maxtype+1]ref function:ref intpc concatto_table
global [0:maxtype+1]ref function:ref intpc appendto_table

global ref[0:maxtype+1]ref function:ref intpc opc_tableptr

global [0:maxtype+1]ref proc (variant a,b,c,d) new_table
global [0:maxtype+1]ref proc(variant a) free_table
global [0:maxtype+1]ref proc(variant a) dupl_table
global [0:maxtype+1]ref proc(variant a,b,ref fmtrec fmt,object p) tostr_table

global const maxdualtype=maxtype
global [0:maxdualtype+1]ref function(int)ref intpc in_dtable
global [0:maxdualtype+1]ref function(int)ref intpc inrev_dtable
global [0:maxdualtype+1]ref function:ref intpc pushix_dtable
global [0:maxdualtype+1]ref function:ref intpc pushixref_dtable
global [0:maxdualtype+1]ref function:ref intpc pushdotix_dtable
global [0:maxdualtype+1]ref function:ref intpc pushdotixref_dtable

global [0:maxdualtype+1]ref function:ref intpc mixed_dtable

global [0:maxdualtype+1]ref function(int)ref intpc convert_dtable

global [0:maxdualtype+1]ref function:ref intpc mulx_dtable

global [0:maxdualtype+1]ref function:ref intpc add_dtable
global [0:maxdualtype+1]ref function:ref intpc sub_dtable
global [0:maxdualtype+1]ref function:ref intpc mul_dtable
global [0:maxdualtype+1]ref function:ref intpc div_dtable
global [0:maxdualtype+1]ref function:ref intpc idiv_dtable
global [0:maxdualtype+1]ref function:ref intpc rem_dtable
global [0:maxdualtype+1]ref function:ref intpc iand_dtable
global [0:maxdualtype+1]ref function:ref intpc ior_dtable
global [0:maxdualtype+1]ref function:ref intpc ixor_dtable
global [0:maxdualtype+1]ref function:ref intpc shl_dtable
global [0:maxdualtype+1]ref function:ref intpc shr_dtable
global [0:maxdualtype+1]ref function:ref intpc min_dtable
global [0:maxdualtype+1]ref function:ref intpc max_dtable

global [0:maxdualtype+1]ref function:ref intpc jumpeq_dtable
global [0:maxdualtype+1]ref function:ref intpc jumpne_dtable
global [0:maxdualtype+1]ref function:ref intpc jumplt_dtable
global [0:maxdualtype+1]ref function:ref intpc jumple_dtable
global [0:maxdualtype+1]ref function:ref intpc jumpge_dtable
global [0:maxdualtype+1]ref function:ref intpc jumpgt_dtable

global [0:maxdualtype+1]ref function:ref intpc addto_dtable
global [0:maxdualtype+1]ref function:ref intpc subto_dtable
global [0:maxdualtype+1]ref function:ref intpc multo_dtable
global [0:maxdualtype+1]ref function:ref intpc divto_dtable
global [0:maxdualtype+1]ref function:ref intpc idivto_dtable
global [0:maxdualtype+1]ref function:ref intpc iandto_dtable
global [0:maxdualtype+1]ref function:ref intpc iorto_dtable
global [0:maxdualtype+1]ref function:ref intpc ixorto_dtable
global [0:maxdualtype+1]ref function:ref intpc shlto_dtable
global [0:maxdualtype+1]ref function:ref intpc shrto_dtable
global [0:maxdualtype+1]ref function:ref intpc minto_dtable
global [0:maxdualtype+1]ref function:ref intpc maxto_dtable

global int nexttypesig=0
global [0:256,0:256]byte sigmap			!map two types to a single tt-code

global int overloadtype=0

global const int maxobjlength = 4 billion
global ichar strpclversion

global [-1000..+1000]int intcounts
global int nallints
global int nsmallints

global int NALLPOPS
global int NCHANGES
global int NOBJECTS

=== pq_common.m 10/56 ===
global const pclversion="404"

global type qd=[4]byte

global tabledata() [0:]ichar opndnames=
	(cnone=0,	$),

	(cmemory,	$),
	(cframe,	$),
	(cproc,		$),
	(cdllproc,	$),
	(cdllvar,	$),

	(cfield,	$),
	(cgenfield,	$),

	(clabel,	$),
	(cint,		$),
	(cword,		$),
	(creal,		$),
	(crange,	$),
	(cstring,	$),
	(ctype,		$),
	(coperator,	$),
	(capplproc,	$),

	(clast,		"?")
end

const m = cmemory
const f = cframe
const p = cproc
const x = cdllproc
const v = cdllvar
const g = cgenfield
const l = clabel
const i = cint
const u = cword
const r = creal
const n = crange
const s = cstring
const t = ctype
const o = coperator
const a = capplproc


global tabledata()  [0:]ichar cmdnames, [0:]qd cmdfmt =
	(kzero=0,		$,	qd(0,0,0,0)),
	(knop,			$,	qd(0,0,0,0)),

	(kprocstart,	$,	qd(p,i,0,0)),		!Start of function def; m is address, n is param count
	(kprocend,		$,	qd(0,0,0,0)),
	(kendmodule,	$,	qd(0,0,0,0)),		!Last 'executable' opcode

	(kpush_m,		$,	qd(m,0,0,0)),		!Push static at address m
	(kpush_f,		$,	qd(f,0,0,0)),		!Push frame/param with offset m
	(kpush_am,		$,	qd(m,0,0,0)),		!Push address of static as refvar
	(kpush_af,		$,	qd(f,0,0,0)),		!Push address of frame/param as refvar
	(kpush_ap,		$,	qd(p,0,0,0)),		!push ^proc
	(kpush_al,		$,	qd(l,0,0,0)),		!push ^label

	(kpush_ci,		$,	qd(i,0,0,0)),		!Push constant signed int
	(kpush_cw,		$,	qd(u,0,0,0)),		!Push constant unsigned int
	(kpush_cr,		$,	qd(r,0,0,0)),		!Push constant real
	(kpush_cn,		$,	qd(n,0,0,0)),		!Push range
	(kpush_cs,		$,	qd(s,0,0,0)),		!Push constant string
	(kpush_t,		$,	qd(t,0,0,0)),		!Push type constant
	(kpush_op,		$,	qd(o,i,0,0)),		!Push operator constant; i is 1 or 2 operands expected
	(kpushz,		$,	qd(t,0,0,0)),		!Push Zero(A); push a 'zero' of type A; (void, int/dint/real, range, string, set, but not list/array)
	(kpushz_void,	$,	qd(0,0,0,0)),		!Push void
	(kpushz_str,	$,	qd(0,0,0,0)),		!Push "" empty string (not writable)
	(kpushz_list,	$,	qd(0,0,0,0)),		!Push () empty list with lwb 1
	(kpushz_listl,	$,	qd(i,0,0,0)),		!Push (i:) empty with lwb i
	(kpushz_set,	$,	qd(0,0,0,0)),		!Push [] empty set
	(kpushz_arrayl,	$,	qd(t,i,0,0)),		!Push an empty [bit]array with elemtype A, and lwb B

	(kpop_m,		$,	qd(m,0,0,0)),		!Pop to A
	(kpop_f,		$,	qd(f,0,0,0)),		!
	(kstore_m,		$,	qd(m,0,0,0)),		!Store A; store Xa in A; keep on stack
	(kstore_f,		$,	qd(f,0,0,0)),		!

	(kpushptr,		$,	qd(0,0,0,0)),		!Push Xa^
	(kpopptr,		$,	qd(0,0,0,0)),		!Ya^:=Xb; then pop both
	(kstoreptr,		$,	qd(0,0,0,0)),		!Ya^:=Xb; keep Xb on stack (as Xa)

	(kzpop_m,		$,	qd(m,0,0,0)),		!Pop A; do not free A first
	(kzpop_f,		$,	qd(f,0,0,0)),		!

	(kzstore_m,		$,	qd(m,0,0,0)),		!Store A; do not free A first
	(kzstore_f,		$,	qd(f,0,0,0)),		!

	(kcopy,			$,	qd(0,0,0,0)),		!Xa:=deepcopy(Xa)
	(kswap,			$,	qd(0,0,0,0)),		!Yb^:=:Xa^; Xa^:=:A; A:=:B

	(kconvptr,		$,	qd(0,0,0,0)),		!Change refvar in X to ref

	(kjump,			$,	qd(l,0,0,0)),		!Jump to L
	(kjumpptr,		$,	qd(0,0,0,0)),		!Jump to Xa^

	(kjumptrue,		$,	qd(l,0,0,0)),		!Jump to L when Xa is true
	(kjumpfalse,	$,	qd(l,0,0,0)),		!Jump to L when Xa is false

	(kjumpdef,		$,	qd(l,0,0,0)),		!Jump to L when Xa defined (X popped)
	(kjumpvoid,		$,	qd(l,0,0,0)),		!Jump to L when Xa is void

	(kjumpeq,		$,	qd(l,0,0,0)),		!Jump to L when Xb=Ya, Xa=A, A=B; (X,Y popped)
	(kjumpne,		$,	qd(l,0,0,0)),		!Jump to L when Xb<>Ya
	(kjumplt,		$,	qd(l,0,0,0)),		!Jump to L when Xb<Ya
	(kjumple,		$,	qd(l,0,0,0)),		!Jump to L when Xb<=Ya
	(kjumpge,		$,	qd(l,0,0,0)),		!Jump to L when Xb>=Ya
	(kjumpgt,		$,	qd(l,0,0,0)),		!Jump to L when Xb>Ya

	(kjumptesteq,	$,	qd(l,0,0,0)),		!Jump to L when Xb=Ya (Ya popped), or Xa=A; int/set and int/range use 'in' to compare
	(kjumptestne,	$,	qd(l,0,0,0)),		!Jump to L when Xb<>Ya (Ya popped?)

	(kjumplabel,	$,	qd(l,0,0,0)),		!Jumptable entry
	(kjumpclabel,	$,	qd(l,i,0,0)),		!Jumptable entry with value P (a cint)

	(kswitch,		$,	qd(i,i,0,0)),		!Jumptable has n entries, ci is lower bound. Jump indexed by Xa

	(kcswitch,		$,	qd(i,i,i,0)),		!Jumptable has n (label,value) entries, plus 'else' entry. Search for Xa value and jump to label

	(knew,			$,	qd(0,0,0,0)),		!To (L,P); --A and jump to L if not zero
	(kto_f,			$,	qd(l,f,0,0)),		!
	(kfor_fci,		$,	qd(l,f,i,0)),		!
	(kfor_ff,		$,	qd(l,f,f,0)),		!
	(kford_fci,		$,	qd(l,f,i,0)),		!
	(kford_ff,		$,	qd(l,f,f,0)),		!

	(kcall,			$,	qd(p,i,0,0)),		!Call &A; A is cmemoryref; B is stack adjust
	(kcallptr,		$,	qd(i,i,0,0)),		!Call X^; A is no. of params supplied; B is stack adjust
	(kreturn,		$,	qd(0,0,0,0)),		!Return from function, with optional value in caller's 	$retval

	(kstartdll,		$,	qd(0,0,0,0)),		!Start sequence of pushdll cmds
	(kpushdll,		$,	qd(t,0,0,0)),		!Set X as next param which shoud be of type B
	(kcalldll,		$,	qd(x,i,t,0)),		!Call dll function m; i=0/1=c/windows; t=result type (void for procs)

	(kcallhost,		$,	qd(i,0,0,0)),		!Call fixed host function &A, with B var-params; B has +128 added when a function

	(kstackframe,	$,	qd(i,0,0,0)),		!Allocate A vars on the stack, and initialise to void

	(kfree,			$,	qd(i,0,0,0)),		!Free and pop A values on stack
	(kaddsp,		$,	qd(i,0,0,0)),		!SP+:=A; note: positive A will push, negative will pop (reverse of the hardware)

	(kstop,			$,	qd(0,0,0,0)),		!Stop program and return value X to any calling program
	(ktest,			$,	qd(i,0,0,0)),		!Various tests on X etc

	(kmakelist,		$,	qd(i,i,0,0)),		!A items on stack; make list with lwb B
	(kmakerecord,	$,	qd(i,t,0,0)),		!A items on stack; make record of type B
	(kmakearray,	$,	qd(i,i,t,t)),		!A items on stack; make array with lwb B, type C and elemtype D
	(kmakestruct,	$,	qd(i,t,0,0)),		!A items on stack; make struct with type B
	(kmakeset,		$,	qd(i,0,0,0)),		!A items on stack; make set
	(kmakerange,	$,	qd(0,0,0,0)),		!2 items on stack; make range
	(kmakedict,		$,	qd(i,0,0,0)),		!A*2 items on stack (A key:val items); make dict

	(kpushdot,		$,	qd(g,0,0,0)),		!T:=Xa.A; T:=A.B; LHS must be a record, RHS is a generic field index
	(kpushdotref,	$,	qd(g,0,0,0)),		!T:=&Xa.A; T:=&A.B

	(ksoftconv,		$,	qd(t,0,0,0)),		!T:=A(Xa); T:=B(A); Type conversion; can only be a basic conversion (usually implicit)
	(khardconv,		$,	qd(t,0,0,0)),		!T:=A(Xa); T:=B(A); Type conversion; any conversion can be done provided it's possible (usually explicit)

	(kmixed,		$,	qd(0,0,0,0)),		!++Xa
	(kincrptr,		$,	qd(0,0,0,0)),		!++Xa^
	(kincrto_m,		$,	qd(m,0,0,0)),		!++A
	(kincrto_f,		$,	qd(f,0,0,0)),		!++A
	(kloadincr,		$,	qd(0,0,0,0)),		!T:=Xa^++
	(kincrload,		$,	qd(0,0,0,0)),		!T:=--Xa^

	(kdecrptr,		$,	qd(0,0,0,0)),		!--Xa^; pop X
	(kdecrto_m,		$,	qd(m,0,0,0)),		!--A
	(kdecrto_f,		$,	qd(f,0,0,0)),		!--A
	(kloaddecr,		$,	qd(0,0,0,0)),		!T:=Xa^--
	(kdecrload,		$,	qd(0,0,0,0)),		!T:=--Xa^

	(kincr,			$,	qd(0,0,0,0)),		!T:=++T
	(kdecr,			$,	qd(0,0,0,0)),		!T:=--T

	(kneg,			$,	qd(0,0,0,0)),		!T:=-Xa; T:=-A
	(kabs,			$,	qd(0,0,0,0)),		!abs Xa
	(knot,			$,	qd(0,0,0,0)),		!not Xa
	(kinot,			$,	qd(0,0,0,0)),		!inot Xa
	(kistrue,		$,	qd(0,0,0,0)),		!istrue Xa
	(kasc,			$,	qd(0,0,0,0)),		!asc Xa
	(kchr,			$,	qd(0,0,0,0)),		!chr Xa

	(ksqrt,			$,	qd(0,0,0,0)),		!sqrt Xa
	(ksqr,			$,	qd(0,0,0,0)),		!sqr Xa
	(kcube,			$,	qd(0,0,0,0)),		!cube Xa
	(ksin,			$,	qd(0,0,0,0)),		!sin Xa
	(kcos,			$,	qd(0,0,0,0)),		!cos Xa
	(ktan,			$,	qd(0,0,0,0)),		!tan Xa
	(kasin,			$,	qd(0,0,0,0)),		!asin Xa
	(kacos,			$,	qd(0,0,0,0)),		!acos Xa
	(katan,			$,	qd(0,0,0,0)),		!atan Xa
	(ksign,			$,	qd(0,0,0,0)),		!sign Xa
	(kln,			$,	qd(0,0,0,0)),		!ln Xa
	(klog,			$,	qd(0,0,0,0)),		!log Xa
	(klg,			$,	qd(0,0,0,0)),		!lg Xa
	(kexp,			$,	qd(0,0,0,0)),		!exp Xa
	(kround,		$,	qd(0,0,0,0)),		!round Xa
	(kfloor,		$,	qd(0,0,0,0)),		!floor Xa
	(kceil,			$,	qd(0,0,0,0)),		!ceil Xa
	(kfract,		$,	qd(0,0,0,0)),		!fract Xa

	(knegto,		$,	qd(0,0,0,0)),		!-:=Xa^; -:=A
	(kabsto,		$,	qd(0,0,0,0)),		!abs:=^Xa; pop Xa
	(knotto,		$,	qd(0,0,0,0)),		!not:=Xa^; pop Xa
	(kinotto,		$,	qd(0,0,0,0)),		!inot:=Xa^; pop Xa

	(klen,			$,	qd(0,0,0,0)),		!T:=Xa.len
	(klwb,			$,	qd(0,0,0,0)),		!Xa.lwb
	(kupb,			$,	qd(0,0,0,0)),		!Xa.upb
	(kbounds,		$,	qd(0,0,0,0)),		!Xa.bounds
	(kbits,			$,	qd(0,0,0,0)),		!Xa.bits
	(kbytes,		$,	qd(0,0,0,0)),		!Xa.bytes
	(ktype,			$,	qd(0,0,0,0)),		!Xa.type
	(kelemtype,		$,	qd(0,0,0,0)),		!Xa.elemtype
	(kbasetype,		$,	qd(0,0,0,0)),		!Xa.basetype
	(kminval,		$,	qd(0,0,0,0)),		!Xa.minval
	(kmaxval,		$,	qd(0,0,0,0)),		!Xa.maxval
	(kisint,		$,	qd(0,0,0,0)),		!Xa.isint
	(kisreal,		$,	qd(0,0,0,0)),		!Xa.isreal
	(kisstring,		$,	qd(0,0,0,0)),		!Xa.isstring
	(kisrange,		$,	qd(0,0,0,0)),		!Xa.isrange
	(kisnumber,		$,	qd(0,0,0,0)),		!Xa.isnumber
	(kisarray,		$,	qd(0,0,0,0)),		!Xa.isarray
	(kisrecord,		$,	qd(0,0,0,0)),		!Xa.isrecord
	(kispointer,	$,	qd(0,0,0,0)),		!Xa.ispointer
	(kismutable,	$,	qd(0,0,0,0)),		!Xa.ismutable
	(kisset,		$,	qd(0,0,0,0)),		!Xa.isset
	(kisvoid,		$,	qd(0,0,0,0)),		!Xa.isvoid
	(kisdef,		$,	qd(0,0,0,0)),		!Xa.isdef
	(ktostr,		$,	qd(0,0,0,0)),		!Xa.isnoneComment (may be suppressed from pcb file)
	(kisequal,		$,	qd(0,0,0,0)),		!Xb==Ya

	(kadd,			$,	qd(0,0,0,0)),		!T:=Xb+Ya
	(ksub,			$,	qd(0,0,0,0)),		!Xb-Ya
	(kmul,			$,	qd(0,0,0,0)),		!Xb*Ya
	(kdiv,			$,	qd(0,0,0,0)),		!Xb/Ya
	(kidiv,			$,	qd(0,0,0,0)),		!Xb%Ya
	(krem,			$,	qd(0,0,0,0)),		!Xb rem Ya
	(kdivrem,		$,	qd(0,0,0,0)),		!Xb divrem Ya
	(kiand,			$,	qd(0,0,0,0)),		!Xb iand Ya
	(kior,			$,	qd(0,0,0,0)),		!Xb ior Ya
	(kixor,			$,	qd(0,0,0,0)),		!Xb ixor Ya
	(kshl,			$,	qd(0,0,0,0)),		!Xb shl Ya
	(kshr,			$,	qd(0,0,0,0)),		!Xb shr Ya
	(kin,			$,	qd(0,0,0,0)),		!Xb in Ya
	(knotin,		$,	qd(0,0,0,0)),		!Xb notin Ya
	(kinrev,		$,	qd(0,0,0,0)),		!Xb inrev Ya
	(keq,			$,	qd(0,0,0,0)),		!Xb=Ya
	(kne,			$,	qd(0,0,0,0)),		!Xb<>Ya
	(klt,			$,	qd(0,0,0,0)),		!Xb<Ya
	(kle,			$,	qd(0,0,0,0)),		!Xb<=Ya
	(kge,			$,	qd(0,0,0,0)),		!Xb>=Ya
	(kgt,			$,	qd(0,0,0,0)),		!Xb>Ya
	(kmin,			$,	qd(0,0,0,0)),		!Xb min Ya
	(kmax,			$,	qd(0,0,0,0)),		!Xb max Ya
	(kconcat,		$,	qd(0,0,0,0)),		!Xb concat Ya
	(kappend,		$,	qd(0,0,0,0)),		!Xb append Ya

	(kpower,		$,	qd(0,0,0,0)),		!Xb power Ya
	(katan2,		$,	qd(0,0,0,0)),		!Xb atan2 Ya

	(kaddto,		$,	qd(0,0,0,0)),		!Xb^+:=Y or Xa^+:=A or A+:=B
	(ksubto,		$,	qd(0,0,0,0)),		!Xb^-:=Ya
	(kmulto,		$,	qd(0,0,0,0)),		!Xb^*:=Ya
	(kdivto,		$,	qd(0,0,0,0)),		!Xb^/:=Ya
	(kidivto,		$,	qd(0,0,0,0)),		!Xb^%:=Ya

	(kiandto,		$,	qd(0,0,0,0)),		!Xb^ iand:=Ya
	(kiorto,		$,	qd(0,0,0,0)),		!Xb^ ior:=Ya
	(kixorto,		$,	qd(0,0,0,0)),		!Xb^ ixor:=Ya
	(kshlto,		$,	qd(0,0,0,0)),		!Xb^ shl:=Ya
	(kshrto,		$,	qd(0,0,0,0)),		!Xb^ shr:=Ya
	(kminto,		$,	qd(0,0,0,0)),		!Xb^ min:=Ya
	(kmaxto,		$,	qd(0,0,0,0)),		!Xb^ max:=Ya
	(kconcatto,		$,	qd(0,0,0,0)),		!Xb^ concat:=Ya
	(kappendto,		$,	qd(0,0,0,0)),		!Xb^ concat:=Ya

	(kpushix,		$,	qd(0,0,0,0)),		!T:=Xb[Ya]
	(kpushdotix,	$,	qd(0,0,0,0)),		!T:=Xb.[Ya]
	(kpushkeyix,	$,	qd(0,0,0,0)),		!T:=Xb{Ya}
	(kpushkeyixd,	$,	qd(0,0,0,0)),		!T:=Xc{Yb,Za} Za is default value

	(kpushixref,	$,	qd(0,0,0,0)),		!^Xb[Ya]
	(kpushdotixref,	$,	qd(0,0,0,0)),		!^Xb.[Ya]
	(kpushkeyixref,	$,	qd(0,0,0,0)),		!^Xb{Ya}

	(kpushbyteix,	$,	qd(t,0,0,0)),		!Xb.A[Ya]
	(kpushbyteixref,$,	qd(t,0,0,0)),		!^Xb.A[Ya]

	(kappendset,	$,	qd(0,0,0,0)),		!Xb[Ya]:=1; pop Y, keep X on stack; Xa[A]:=1

	(kpushdotm,		$,	qd(t,p,0,0)),		!A=0 (module) or owner type; B=proc; check X has type A if A is a type
	(kpushdott,		$,	qd(t,t,0,0)),		!A=owner type; B=.type; check X has type A
	(kpush_ad,		$,	qd(x,0,0,0)),		!push index of dll proc
	(kpush_try,		$,	qd(l,i,i,0)),		!Push try/except into; label/except code/no. exceptions
	(kraise,		$,	qd(0,0,0,0)),		!Raise exception Xa
	(kapplyop,		$,	qd(i,0,0,0)),		!applyop(Ya,Xb); i is 1 or 2, number of operands provided

	(kmakeiter,		$,	qd(i,0,0,0)),		!Turn Xa inter iterate object; A=0/1=fwd/rev
	(kforall,		$,	qd(l,f,f,0)),		!A=label; B=iter var; C=primary index var
	(kforallx,		$,	qd(l,f,f,f)),		!A=label; B=iter var; C=primary index var, D=secondary indat var

	(kforeach,		$,	qd(l,f,f,0)),		!A=label; B=iter var; C=primary index var
	(kforeachx,		$,	qd(l,f,f,f)),		!A=label; B=iter var; C=primary index var, D=secondary indat var

	(kexpandrange,	$,	qd(0,0,0,0)),		!expand range value to two ints
	(kcallappl,		$,	qd(a,i,0,0)),		!Call named host function &A, with B var-params

	(klastcmd,		$,	qd(0,0,0,0))

end

global [0..klastcmd]ref void cmdmap			!map cmd index to possible fn/label address

global tabledata()	[]ichar bcdirnames =
	(kkpclversion,		$),	!s	PCL version string
	(kkmoduletable,		$),	!n	Names of all modules
	(kkdlltable,		$),	!n	DLL imported libraries
	(kkdllproctable,	$),	!n	DLL proc table
	(kksymboltable,		$),	!n	Proc, Type, Static symbols
	(kktypetable,		$),	!n	Type table (user types only)
	(kkgenfieldnames,	$),	!n	Genfield names
	(kkgenfielddata,	$),	!n	Genfield data
	(kkstringtable,		$),	!n	
	(kkstructtable,		$),	!n	Struct field table
	(kkpccode,			$),	!n	PCL bytecode data
	(kkend,				$),	!-	End of file
	(kknewstringtable,	$),	!n	Counted blocks
	(kkapplproctable,	$),	!n	Host proc table
end

global tabledata() [0:]ichar hostfnnames, [0:]int hostnparams, [0:]int hostisfn =
	(host_dummy=0,			$,	0,	0),

	(host_startprint,		$,	1,	0),	!startprint(x)	Set o/p dev for following print items
	(host_startprintcon,	$,	0,	0),	!startprintcon()	Set console dev for following print items
	(host_strstartprint,	$,	0,	0),	!strstartprint()	Set o/p dev for internal string
	(host_setformat,		$,	1,	0),	!setformat(x)	Set up format string for following print items up to str/endprint
	(host_endprint,			$,	0,	0),	!endprint()	Restore o/p dev
	(host_strendprint,		$,	0,	1),	!strendprint()	Restore o/p dev, and return result as string
	(host_print,			$,	2,	0),		!print(x,[y])	Print x, using default format code or y

	(host_dprint,			$,	2,	0),	!dprint(x,[y])	As print, but with extra debug stuff
	(host_println,			$,	0,	0),	!println()	Print newline
	(host_printnogap,		$,	0,	0),	!printnogap()	Suppress any gap before next print item

	(host_readln,			$,	1,	0),	!sreadln(x)	Read line from console or device x, into read buffer
	(host_sreadln,			$,	1,	1),	!sreadln(x)	Read line from console or device x, into read buffer
	(host_sread,			$,	1,	1),	!sread([x])	Read item from read buffer, with/without format code
	(host_rereadln,			$,	0,	0),	!sread([x])	Read item from read buffer, with/without format code
	(host_reread,			$,	0,	0),	!sread([x])	Read item from read buffer, with/without format code

	(host_strtoval,			$,	2,	1),	!
	(host_tostr,			$,	2,	1),	!

	(host_leftstr,			$,	3,	1),
	(host_rightstr,			$,	3,	1),
	(host_convlc,			$,	2,	1),
	(host_convuc,			$,	2,	1),
	(host_iconvlc,			$,	2,	0),		!&
	(host_iconvuc,			$,	2,	0),		!&

	(host_stop,				$,	0,	0),	!stop(x)	Stop execution
	(host_stopx,			$,	1,	0),	!stopx(x)	Stop, with given return value
	(host_ismain,			$,	1,	1),	!ismain(x)	Return 1 when module name x is main module
	(host_waitkey,			$,	0,	1),
	(host_testkey,			$,	0,	1),
	(host_execwait,			$,	3,	1),
	(host_execcmd,			$,	3,	1),
	(host_shellexec,		$,	2,	1),
	(host_system,			$,	1,	1),

	(host_makestr,			$,	2,	1),
	(host_makestrslice,		$,	2,	1),
	(host_makeref,			$,	2,	1),

	(host_new,				$,	4,	1),
	(host_newheap,			$,	4,	1),
	(host_readlines,		$,	1,	1),
	(host_heapvar,			$,	1,	1),
	(host_dictitems,		$,	1,	1),
	(host_freeheap,			$,	1,	0),
	(host_setoverload,		$,	3,	0),

	(host_getcmdparam,		$,	1,	1),
	(host_gethostname,		$,	0,	1),

	(host_setpcerror,		$,	1,	0),
	(host_setdebug,			$,	1,	0),
	(host_test,				$,	2,	1),

	(host_ticks,			$,	0,	1),
	(host_sleep,			$,	1,	0),
	(host_random,			$,	1,	1),
	(host_findmetafunction,	$,	1,	1),
	(host_gethash,			$,	1,	1),
	(host_getos,			$,	0,	1),
	(host_gethostsize,		$,	0,	1),
	(host_iswindows,		$,	0,	1),
	(host_setmesshandler,	$,	1,	0),
	(host_setfprintf,		$,	2,	0),

	(host_loadpcl,			$,	2,	1),
	(host_runpcl,			$,	2,	1),
	(host_runtask,			$,	2,	1),
	(host_callext,			$,	3,	0),
	(host_pcldata,			$,	2,	1),
	(host_getcstring,		$,	1,	1),
	(host_getparam,			$,	1,	1),
	(host_clearlist,		$,	1,	0),
	(host_makelink,			$,	1,	1),
	(host_allparams,		$,	1,	1),
	(host_stackvars,		$,	0,	1),
	(host_makeempty,		$,	1,	1),
	(host_errorinfo,		$,	1,	1),
	(host_strrepl,			$,	3,	1),

	(host_last,				$,	0,	0)
end

global tabledata() [0:]ichar namenames =
	(nullid=0,		$),		!Not assigned (sometimes converted to genfieldid)
	(programid,		$),		!Main root
	(moduleid,		$),		!Current or imported module
	(dllmoduleid,	$),		!
	(typeid,		$),		!Type name in type, proc or module
	(procid,		$),		!Proc/method/function/op name
	(dllprocid,		$),		!Dll Proc/function name
	(dllvarid,		$),		!Dll variable name
	(applprocid,	$),		!Host proc/function name
	(constid,		$),		!Named constant in type, proc or module
	(staticid,		$),		!Static in type or proc or module
	(frameid,		$),		!Local var
	(paramid,		$),		!Local param
	(fieldid,		$),		!Field of Record or Class
	(genfieldid,	$),		!Generic Field of Record or Class
	(enumid,		$),		!Enum name, part of enum type only
	(labelid,		$),		!Label name in proc only
	(blockid,		$),		!Codeblock label name in proc only
	(aliasid,		$),		!Alias to another name
	(linkid,		$)		!Name in class defined in a base class
end

global tabledata() []ichar errornames =
	(pc_error,			$),
	(user_error,		$),
	(type_error,		$),
	(mixedtype_error,	$),
	(divide_error,		$),
	(stopmodule_error,	$),
	(bounds_error,		$)
end

=== pc_support.m 11/56 ===
import msys
import clib
import mlib
import oslib

import pc_types
import pc_decls
import pq_common
import pc_misc

global [0:]byte bytemasks=(1,2,4,8,16,32,64,128)



const zmax=239             !maximum value in one byte

const zint240=245          !next byte is value 240 to 479
const zint480=246          !next byte is value 480 to 719
const zint720=247          !next byte is value 720 to 959

const zint1=248            !Int is neg of next byte value (mainly for small neg values)
const zint2=249            !Int in next 2 sign extended bytes
const zint4=250            !Int in next 4 bytes
const zint8=251            !Dint in next 8 bytes
const zreal4=252           !Real in next 4 bytes (add 32-bit zero lsw)
const zreal8=253           !Real in next 8 bytes
const zstring=254          !String
const zbytes=244          	!General data: count follows (in zint format) then data bytes
const zeof=255          	!eof marker

global proc prterror(ichar mess)=
println "Print error:",mess
os_getch()
stop 1
end

global function testelem(ref[0:]byte p,int n)int =		!TESTELEM
return ((p^[n>>3] iand bytemasks[n iand 7])|1|0)
end

global proc setelem(ref[0:]byte p,int n) =		!SETELEM

p^[n>>3] ior:= bytemasks[n iand 7]
end

global proc pcustype_def(ichar mess, variant x) =		!PCUSTYPE
int t

t:=x^.tag

showlinenumber()
println "USTYPE:Type not supported: ",mess,":",ttname[t]
abortprogram("Stopping")
end

global function pcustype(ichar mess, variant x)ref intpc =		!PCUSTYPE
err_message:=mess
err_var1:=x^

err_pcptr:=pcptr
pcustype_def(mess,x)
return pcptr
end

global function pcustypet(ichar mess, int t)ref intpc =
static varrec v
v.tagx:=t
return pcustype(mess,&v)
end

global proc pcmxtypes_def(ichar mess, variant x,y) =		!PCMXTYPES
int s,t

s:=x^.tag
t:=y^.tag

showlinenumber()

println "MXTYPES:Mixed Types not supported:/",mess,"/:",ttname[s],":",ttname[t]
abortprogram("Stopping")
end

global function pcmxtypes(ichar mess, variant x,y)ref intpc =		!PCMXTYPES
err_message:=mess
err_var1:=x^
err_var2:=y^
err_pcptr:=pcptr

pcmxtypes_def(mess,x,y)

return pcptr
end

global function pcmxtypestt(ichar mess, int s,t)ref intpc=
static varrec u,v

u.tagx:=s
v.tagx:=t
return pcmxtypes(mess,&u,&v)
end

global function gettypename(int t)ichar=
return ttname[t]
end

global proc inittypetables=
int i,size,bitsize


for i:=0 to tlast-1 do

	ttname[i]:=stdtypenames[i]
	ttbasetype[i]:=i

	case i
	when tintm, twordm, trefm then
		bitsize:=$targetbits
	else
		bitsize:=stdtypewidths[i]
	esac

	switch bitsize
	when 0 then
	when 1,2,4 then
		size:=1
	else
		size:=bitsize/8
	endswitch

	ttsize[i]:=size
	ttbitwidth[i]:=bitsize

	ttlower[i]:=1
od
ntypes:=tlast-1

tttarget[trefvar]:=tvariant
end

global function pcerror(ichar mess)ref intpc=
showlinenumber()
println "PCERROR:",mess
os_getch()
stop 1
return nil
end

global proc vxunimpl(ichar mess)=
showlinenumber()
println "Unimplemented VX op:",mess
os_getch()
stop 1
end

global proc pclunimpl(int cmd) =		!PCLUNIMPL
showlinenumber()
if cmd<>klastcmd then
	println "Unimplemented cmd:",cmdnames[cmd]
else
	println "J-opcode not allowed with -LAB or -FN"
fi
abortprogram("Stopping")
end

global function convCstring(ref char svalue,int length)ref char =		!CONVCSTRING

enum (strbufflen=2000)
static [0:strbufflen]char strbuffer1
static [0:strbufflen]char strbuffer2
static [0:strbufflen]char strbuffer3
static [0:strbufflen]char strbuffer4
static [0:strbufflen]char strbuffer5
static [0:strbufflen]char strbuffer6
static int strindex=0		!index of current buffer: cycles between 0,1,2
static [0:]ref [0:]char table=(
	&strbuffer1,&strbuffer2,&strbuffer3,
	&strbuffer4,&strbuffer5,&strbuffer6)
ref[0:]char p

if length>=strbufflen then
	pcerror("ConvCstring>=2000")
fi

if svalue=nil then
	return ""
fi

if ++strindex=table.len then
	strindex:=0
fi
p:=table[strindex]
memcpy(p,svalue,length)
p^[length]:=0
return cast(p)
end

global function getintvalue(variant p)int =		!GETINTVALUE
switch p^.tag
when tint,ttype then
	return p^.value
when treal then
	return p^.xvalue
else
	pcustype("getintvalue",p)
endswitch
return 0
end

global function nextpoweroftwo(int x)int=

if x=0 then return 0 fi

int a:=1
while a<x do
	a<<:=1
od
return a
end

GLOBAL proc showlinenumber =		!SHOWLINENUMBER
int lineno,moduleno,count
ref intpc ptr
variant s,send

findlinenumber(pcptr,lineno,moduleno)

printlinenumber(lineno,moduleno)

s:=sptr
send:=&varstack^[stacksize]
count:=0
while s<=send and count<15 do
	if s^.tag=tretaddr then
		ptr:=s^.uret.retaddr-3		!go back three to get to start of kcall/kcallptr instr
		findlinenumber(ptr,lineno,moduleno)
		printlinenumber(lineno,moduleno,"Called from:")
		++count
	fi
	++s
od
end

proc printlinenumber(int lineno,moduleno,ichar calledfrom="")=
println calledfrom,"LINE:",lineno,"in FILE:",moduletable[moduleno].filename
end

global proc findlinenumber(ref intpc ptr, int &lineno, &moduleno)=
int pcindex,i
modulerec m

lineno:=0
pcindex:=findpcindex(ptr,moduleno)


if pcindex then
	m:=moduletable[moduleno]
	for i:=pcindex downto 1 do
		lineno:=m.linetable^[i]
		if lineno then return fi
	od
fi
end

global function findpcindex(ref intpc ptr, int &moduleno)int=
int i,j
ref intpc p,q

for i:=0 to nmodules do
	p:=cast(moduletable[i].pccode)
	q:=p+moduletable[i].pcindex

	if ptr>=p and ptr<q then
		moduleno:=i
		return (ptr-p)+1
	fi
od
return 0
end

global proc showlinetable(ichar caption,int i)=
int j
CPL "MODULE",i,moduletable[i].pcindex,caption
for j:=7 to 12 do
	cpl "	LINE",j,moduletable[i].linetable^[j]
od
end

global proc writezstring(filehandle f,ichar s)=
int i,n

outbyte(f,zstring)
n:=strlen(s)

to n do
	outbyte(f,s++^)
od
outbyte(f,0)
end

global proc writezint(filehandle f,int64 x)=
ref byte p

if x>=0 and x<=zmax then
	outbyte(f,x)
elsif x>=240 and x<480 then
	outbyte(f,zint240)
	outbyte(f,x-240)
elsif x>=480 and x<720 then
	outbyte(f,zint480)
	outbyte(f,x-480)
elsif x>=720 and x<960 then
	outbyte(f,zint720)
	outbyte(f,x-720)
elsif x>=-127 and x<0 then
	outbyte(f,zint1)
	outbyte(f,-x)
elsif x>=-32768 and x<=32767 then
	outbyte(f,zint2)
	outword16(f,x)
elsif x>-0x8000'0000 and x<=0x7fff'ffff then
	outbyte(f,zint4)
	outword(f,x)
else
	p:=cast(&x)
	outbyte(f,zint8)
	to 8 do
		outbyte(f,p++^)
	od
fi
end

global proc writezint4(filehandle f,int x)=

outbyte(f,zint4)
outword(f,x)
end

global proc writezrange(filehandle f,ref byte p)=
outbyte(f,zint8)
to 8 do
	outbyte(f,p++^)
od
end

global proc writezreal(filehandle f,real x)=
ref byte p
ref int q

p:=cast(&x)
q:=cast(&x)

if q<>nil then
	outbyte(f,zreal8)
	to 8 do
		outbyte(f,p++^)
	od
else
	outbyte(f,zreal4)
	p+:=4
	to 4 do
		outbyte(f,p++^)
	od
fi
end

global proc writezeof(filehandle f)=
	outbyte(f,zeof)
end

proc zerror(ichar mess)=
println "Z error:",mess
stop 1
end

global function readzvalue(ref ref byte pp,ref int32 dest,dest2)int =		!READZVALUE

ref byte p
ref i8 sp
ref i64 destint
ref r64 destreal
ref ref void destptr
int t
u8 bb,c
i32 length,dummy

p:=pp^

bb:=p++^		!format byte, or small int
t:=1			!assume int result
if dest2=nil then
	dest2:=&dummy
fi

switch bb
when zint240 then
	dest^:=p++^ +240

when zint480 then
	dest^:=p++^ +480

when zint720 then
	dest^:=p++^ +720

when zint1 then
	dest^:=-ref i8(p)^

	++p

when zint2 then
	dest^:=ref i16(p)^
	p+:=2

when zint4 then
	dest^:=ref i32(p)^
	p+:=4

when zint8 then
	destint:=ref i64(dest)
	destint^:=ref i64(p)^

	p+:=8
	t:=2

when zreal4 then
	dest++^ := 0		!low 32 bits are zero
	dest^ := ref i32(p)^	!top 32 bits of double
	p+:=4
	t:=3

when zreal8 then
	destint:=ref i64(dest)
	destint^:=ref i64(p)^
	p+:=8
	t:=3

when zstring then
	destptr:=ref ref void(dest)
	destptr^:=cast(intpc(p))			!result is pointer to start of string
	length:=0

	repeat
		c:=p++^
		++length
	until not c
	dest2^:=--length
	t:=4

when zbytes then
	zerror("Can't deal with ZBYTES yet")
	stop 1

when zeof then
	return 0

else		!assume int 0..zmax
	dest^:=bb
endswitch

pp^:=p			!Update caller's ptr

return t
end

global function readzint(ref ref byte p)int64 =		!READZINT

i64 aa
int status

aa:=0
status:=readzvalue(p,ref int32(&aa),nil)
case status
when 1 then
	if int32(aa)<0 then
		aa ior:=0xFFFFFFFF00000000
	fi
when 2 then
else
	zerror("Z:Int32 Expected")
esac
return aa
end

global function readzdint(ref ref byte p)i64=		!READZDINT
i64 aa
int status

aa:=0
if (status:=readzvalue(p,ref int32(&aa),nil))<>2 then
	if status=1 then			!widen int to 64 bits
		if aa>0x7FFFFFFF then		!-ve int32
			aa ior:= 0xFFFFFFFF80000000		!sign-extend
		fi
	else
		zerror("ZformatD")
	fi
fi
return aa
end

global function readzreal(ref ref byte p)r64=		!READZREAL
r64 x
int status

if (status:=readzvalue(p,ref int32(&x),nil))<>3 then
	zerror("ZformatR")
fi
return x
end

global function readzstring(ref ref byte p,ref int ilength)ichar=		!READZSTRING
i64 aa
int32 length,status

if (status:=readzvalue(p,ref int32(&aa),&length))<>4 then
CPL =STATUS

	zerror("ZformatS")
fi
if ilength then
	ilength^:=length
fi
return ref char(aa)
end

global function readzblock(ref ref byte pp, int length)ref byte=		!READZSTRING
ref byte pdata

pdata:=pp^

pp^:=pdata+length

return pdata
end

global proc checkmt(int id)=
CPL "CHECKMT",id,":",moduletable[1].pccode
end

global function ipower(i64 a,int n)i64=		!IPOWER

if n<=0 then
	return 0
elsif n=0 then
	return 1
elsif n=1 then
	return a
elsif (n iand 1)=0 then
	return ipower(a*a,n/2)
else			!assume odd
	return a*ipower(a*a,(n-1)/2)
fi
end

global proc loaderror(ichar mess,mess2="")=
println "Load Error:",mess,mess2
stop 1
end

global function gettypesig(int s,t)int=
int typesig

typesig:=sigmap[s,t]

if typesig=0 then			! need to creat a new typesig
	typesig:=++nexttypesig
	sigmap[s,t]:=typesig
fi
return typesig
end

GLOBAL FUNCTION GETFNNAME(ref void fnaddr)ichar=
int i,n


n:=$get_nprocs()

for i to n do
	if $get_procaddr(i)=fnaddr then
		return $get_procname(i)
	fi
od
RETURN "<FUNCTION NOT FOUND>"
END

global proc junimpl(ichar s) =
[100]char mess
strcpy(&.mess,"J handler unimpl: ")
strcat(&.mess,s)
pcerror(&.mess)
end

=== pc_misc.m 12/56 ===
import clib
import mlib

import pq_common
import pc_types
import pc_decls
import pc_support
import pc_pcfns

global function raiseexception(int exceptno)ref intpc =
variant stackend,oldsptr

stackend:=&varstack^[stacksize]
oldsptr:=sptr
do
	if sptr>=stackend then
		sptr:=oldsptr
		default_exception(exceptno)
	fi
	if sptr^.tag=texception and (exceptno=0 or sptr^.uexcept.exceptiontype=exceptno) then
		exit
	fi
	pc_unshare(sptr) when sptr^.hasref
	++sptr
od

frameptr:=ref byte(sptr)+sptr^.uexcept.frameoffset
return cast(sptr^.refptr)
end

global proc raise_error(int error_no)=

(--sptr)^.tagx:=tint
sptr^.value:=error_no

err_pcptr:=pcptr

pcptr:=raiseseq
end

proc default_exception(int exceptno)=
CPL "DEFAULT EXCEPTION HANDLER"

case exceptno
when pc_error then
	pcerror("PC/ERROR")
when user_error then
	pcerror("USER/ERROR")
when type_error then
	pcptr:=err_pcptr
	pcustype_def(err_message,&err_var1)

when mixedtype_error then
	pcptr:=err_pcptr
	pcmxtypes_def(err_message,&err_var1,&err_var2)

when divide_error then
	pcptr:=err_pcptr

	pcerror("EXCEPTION/DIVIDE BY ZERO")

when stopmodule_error then
CPL "STOPMODULEERROR"
when bounds_error then
CPL "BOUNDSERROR"
else
	cpl "Exception:",errornames[exceptno]
esac


stop 1
end
=== pc_pcfns.m 13/56 ===
import msys
import mlib
import clib
import oslib

import pc_types
import pc_decls
import pq_common
import pc_support
import pc_objlib
import pc_bignum
import pc_misc

import PC_PRINT

GLOBAL INT LOOKUPS
GLOBAL INT CLASHES
GLOBAL [65536]INT HIST

global proc pc_unshare(variant p)=

IF P.OBJPTR.REFCOUNT<=0 THEN
	PCERROR("UNSHARE/REF COUNT ERROR")
FI

	if --(p.objptr.refcount)=0 then
		pc_free(p)
	fi
end

global proc pc_free(variant p)=
	varrec v
	object pa



	pa:=p.objptr
IF PA.REFCOUNT>0 THEN
PCERROR("FREE: REFCOUNT NOT ZERO")
FI

	switch pa.objtype
	when normal_obj then
		free_table[pa.tag]^(p)
	when slice_obj then
		v.tagx:=pa.tag
		v.objptr:=pa.objptr2
		pc_unshare(&v)
	else
		freeobject(pa)
	end
	p.tag:=tvoid
end

global function pc_share(variant p)variant=
	++p^.objptr^.refcount
	return p
end

global proc pc_dupl(variant p)=
	varrec v

	if p^.hasref then
		v:=p^
		dupl_table[v.tag]^(p)
		pc_unshare(&v)				!original
	fi
end

global proc j_free_s(variant p) =
	object pa
	pa:=p.objptr

	if pa.ustr.length then
		pcm_free(pa.ustr.strptr,pa.ustr.allocated)
	fi

	freeobject(pa)
end

global proc j_free_m(variant p) =
	int i,n
	object r
	variant q

	r:=p^.objptr

	n:=ttlength[p.tag]
	q:=r.urec.vptr

	to n do
		if q.hasref then
			pc_unshare(q)
		fi
		++q
	od
	if n then
		record_free(r)
	fi

	freeobject(r)
end

global proc j_free_l_d(variant p) =
	int i,n
	object r
	variant q

	r:=p^.objptr

	n:=r^.ulist.length
	q:=r^.ulist.vptr

	to n do
		if q^.hasref then
			pc_unshare(q)
		fi
		++q
	od
	if n then
		list_free(r)
	fi

	freeobject(r)
end

global proc j_free_k(variant p) =
object r
variant q

r:=p^.objptr

array_free(r)
freeobject(r)
end

global proc j_free_a(variant p) =
	object r

	r:=p^.objptr

	array_free(r)

	freeobject(r)
end

global proc j_free_j(variant p) =
object r
variant q

bx_free(p)
end

global proc j_free_b_e(variant p) =
object r
variant q

r:=p.objptr
bits_free(r)
freeobject(r)
end

global proc j_dupl_s(variant p) =
	int n
	object pa, newp

	pa:=p.objptr
	pc_makestring(pa.ustr.strptr,pa.ustr.length,p)

end

global proc j_dupl_l_m_d(variant p)=
	int i,j,n,nbytes
	variant q,r
	variant e
	object oldp
	object newp

	oldp:=p.objptr

	if oldp.refcount<0 then
	CPL "CIRC"
		pcerror("DUPL/LIST CIRC")
		RETURN
	fi

	if ttbasetype[p.tag]=trecord then
		n:=ttlength[p.tag]
		newp:=record_new(p.tag)
	else
		n:=oldp^.ulist.length
		newp:=list_new(n,oldp.ulist.lower,nil)
	fi


	p.objptr:=newp

	oldp.refcount:=-oldp.refcount

	if n then
		r:=newp.ulist.vptr
		pcm_copymem4(r,oldp.ulist.vptr,n*varsize)	!Copy top-level vars as a single block

		to n do
			if r^.hasref then
				if ttbasetype[r.tag]<>trecord then
					++r^.objptr^.refcount
					pc_dupl(r)
				else
					++r^.objptr^.refcount
				fi
			fi
			++r
		od
	fi

	oldp.refcount:=-oldp.refcount
end

global proc j_dupl_a(variant p) =

int i,j,n,nbytes
variant q,r
variant e
object oldp
object newp

oldp:=p^.objptr

n:=oldp.uarray.length

newp:=array_new(p.tag,oldp.uarray.elemtag,n,oldp.uarray.lower)

p.objptr:=newp

if n then
	pcm_copymem4(newp.uarray.ptr,oldp.uarray.ptr,n*ttsize[oldp.uarray.elemtag])
fi
end

global proc j_dupl_j(variant p) =
	bx_dupl(p)
end

global proc j_dupl_b(variant p) =

int i,j,n,nbytes
variant q,r
variant e
object oldp
object newp

oldp:=p.objptr

n:=oldp.ubits.length
newp:=bits_new(oldp.ubits.elemtag,n,oldp.ubits.lower)

p.objptr:=newp

if n then
	pcm_copymem4(newp.ubits.ptr,oldp.ubits.ptr,bits_bytesize(oldp))
fi
end

global proc j_dupl_e(variant p) =
int i,j,nbytes
int64 n
variant q,r
variant e
object oldp
object newp

oldp:=p.objptr

n:=oldp.uset.allocated64					!just duplicate all allocated bytes

newp:=set_new(oldp.uset.length,oldp.uset.lower)


p.objptr:=newp

if n then
	pcm_copymem4(newp.uset.ptr,oldp.uset.ptr,bits_bytesize(oldp))
fi
end

global proc j_dupl_k(variant p) =
int i,j,n,nbytes
object oldp
object newp

oldp:=p^.objptr

nbytes:=ttsize[p^.tag]

newp:=struct_new(p.tag)


p.objptr:=newp

pcm_copymem4(newp.ustruct.ptr,oldp.ustruct.ptr,nbytes)
end

global proc pc_makelist(int n, variant a,b, int lower)=

	variant p,q
	int i
	object l

	a+:=(n-1)		!point to last data elements, which is really the first...

	l:=list_new(n,lower,nil)

	l.ulist.mutable:=0

	p:=l.ulist.vptr

	q:=p+l.ulist.allocated-1	!point to last complete (unaligned) in allocation

	to n do				!copy vars one by one to the new list and duplicate each
		p^:=a--^
		pc_share(p) when p^.hasref
		++p
	od

	while (p<=q) do
		p^.tagx:=tvoid
		++p
	od

	objtovar(l,b)
end

global proc pc_makerecord(int n, t, variant a,b)=

	variant p,q
	int i
	object r

	a+:=(n-1)		!point to last data elements, which is really the first...

	r:=record_new(t)
	p:=r.urec.vptr

	to n do				!copy vars one by one to the new list and duplicate each
		p^:=a--^
		pc_share(p) when p^.hasref
		++p
	od

	objtovar(r,b)
end

global proc pc_makearray(int n, arraytype, elemtype, lower, variant a,b)=
	ref byte p,q
	int i,esize,nbytes,basetag
	object l

	a+:=(n-1)			!point to last data elements, which is really the first...

	if elemtype=tvoid then	!use type of first element
		elemtype:=a^.tag
		basetag:=ttbasetype[elemtype]
		case basetag
		when tarray,tstruct then
		elsif basetag>tvariant then
		else
			pcerror("makearray elem")
		esac
	fi

	l:=array_new(arraytype,elemtype,n,lower)

	p:=l.uarray.ptr

	esize:=ttsize[elemtype]

	to n do		!copy vars one by one to the new list and duplicate each
		pc_storepacked(p,a,elemtype)
		p+:=esize
		--a
	od

	objtovar(l,b)
end

global proc pc_makerange(variant x,y,z)=
	if x^.tag=tint and y^.tag=tint then
		z^.tagx:=trange
		z^.range_upper:=y^.value
		z^.range_lower:=x^.value
	else
		pcmxtypes("vxmakerange",x,y)
	fi
end

global proc pc_makeset(int n, variant data,dest)=

	variant q
	ref byte p
	int top,a,b,i,j,t,size
	byte alloc
	object s
	static int count=0


	top:=0
	q:=data

	to n do
		switch (q^.tag)		!scan items, which should be ranges or integers
		when trange then

			a:=q^.range_lower
			b:=q^.range_upper

		when tint then
			a:=q^.value
			b:=a
		

		else			!assume numeric value of some sort
			b:=a:=getintvalue(q)
		endswitch
		if a<0 or b<0 then
			pcerror("Neg set element")
		fi
		if a>top then
			top:=a
		fi
		if b>top then
			top:=b
		fi
		++q
	od

	s:=set_new(top+1,0)

	q:=data
	to n do
		switch q^.tag
		when trange then
			a:=q^.range_lower
			b:=q^.range_upper
			if a>b then
				t:=a; a:=b; b:=t
			fi

		when tint then
			b:=a:=q^.value

		else
			b:=a:=getintvalue(q)
		endswitch

		for j:=a to b do
			setelem(cast(s.uset.ptr),j)
		od
		++q
	od

	objtovar(s,dest)
end

global proc pc_makestruct(int n,t,variant a,b) =		!VX_MAKESTRUCT

	ref byte p,q
	int i,nfields,index
	object l
	ref strec d,f


	l:=struct_new(t)

	p:=l.ustruct.ptr

		index:=ttstartfield[t]			!into pcfieldtable[]
		nfields:=ttstructfields[t]
		if nfields<>n then
			pcerror("makestruct: wrong # fields")
		fi
		for i:=nfields downto 1 do
			pc_storepacked(p+pcfieldtable^[index+i-1].fieldoffset,a,pcfieldtable^[index+i-1].fieldtype)
			++a
		od

	objtovar(l,b)
end

global proc pc_makedict(int n, variant a,b)=

	varrec v
	variant p,q
	int i,m
	object l

	m:=n*2		!m is number of vars
	a+:=m-1		!point to last data element item (reall first), which is key of first pair

	l:=dict_new(n)

	v.tagx:=tdict+hasrefmask
	v.objptr:=l

	p:=l.udict.vptr
	q:=p+l.udict.allocated-1			!point to last complete (unaligned) in each allocation

	to n do		!copy vars one by one to the new list and duplicate each
		adddictitem(&v,a,a-1)
		a-:=2
	od

	b^:=v
end

global proc pc_storepacked(ref byte p,variant q,int t) =		!PC_STOREPACKED

	int plength,qlength
	int s,sbase,tbase
	object qa

	sbase:=ttbasetype[s:=q^.tag]		!storing coercible sbase type to fixed type tbase
	tbase:=ttbasetype[t]

	switch (sbase)
	when tint,tword then
		switch (tbase)
		when ti8,tu8 then
			(ref byte(p)^):=q^.value
			return
		when ti16,tu16 then
			(ref u16(p)^):=q^.value
			return
		when ti32,tu32 then
			(ref int32(p)^):=q^.value
			return
		when ti64,tu64,tint,tword then
			(ref i64(p)^):=q^.value
			return
		when tr32 then
			(ref r32(p)^):=q^.value
			return
		when tr64 then
			(ref r64(p)^):=q^.value
			return
		endswitch

	when treal then
		switch (tbase)
		when ti32,tu32 then
			(ref int32(p)^):=q^.xvalue
			return
		when tr32 then
		(ref r32(p)^):=q^.xvalue
			return
		when tr64 then
			(ref r64(p)^):=q^.xvalue
			return
		when ti16,tu16 then
			(ref int16(p)^):=q^.xvalue
			return
		endswitch

	when tstring then
		qa:=q^.objptr
		plength:=ttlength[t]
		qlength:=qa.ustr.length
		switch tbase
		when tstring then			!ref string assumed here to mean special 1-char string
			if t=tbase then			!if basetype, then means special 1-char string
				if qlength<>1 then
					pcerror("Str not len 1")
				fi
				(ref char(p)^):=ref char(qa.ustr.strptr)^
				return
			fi
			if qlength>plength then		!truncate
				qlength:=plength
			fi
			memcpy(p,qa.ustr.strptr,qlength)		!copy the number of chars provided
			setfslength(cast(p),plength,qlength)
			return

		when tstringz then
			if qlength>=plength then			!truncate as needed; no teminator to allow space for terminator
				memcpy(p,qa.ustr.strptr,plength)		!copy the number of chars provided
				(ref byte(p)+plength-1)^:=0			!zero terminator

			else
				memcpy(p,qa.ustr.strptr,qlength)		!copy the number of chars provided
				(ref byte(p)+qlength)^:=0			!zero terminator
			fi

			return

		endswitch

	when tstruct then
		if s<>t then
			pcmxtypestt("spack struct",s,t)
		fi
		memcpy(p,q.objptr.ustruct.ptr,ttsize[t])
		return

	when tarray then
		if s<>t then				!not direct match: check whether compatible
				pcmxtypestt("spack array",s,t)
		fi
		memcpy(p,q.objptr.uarray.ptr,ttsize[t])
		return

	endswitch

	pcmxtypestt("storepacked (source->dest)",s,t)
end

proc adddictitem(variant d, p, q)=
	object da
	variant r

	da:=d^.objptr

	if da.udict.length=0 then				!cannot be empty
		pcerror("NULL DICT")
	fi

	r:=finddictitem(d,p,1)

	pc_unshare(r) when r^.hasref			!overwrite any existing value
	r^:=q^
	pc_share(r) when r^.hasref
end

global function gethashvalue(variant p)int=
int hsum,csum,c,n,i,result
ref char s,s0

switch p^.tag
when tstring then
	n:=p.objptr.ustr.length
	if not n then return 0 fi
	hsum:=0
	s:=p.objptr.ustr.strptr
	to n do
		c:=s++^
		hsum:=(hsum<<4-hsum) +c
	od


	result:=hsum<<5-hsum

	return result iand 0x7FFF'FFFF'FFFF'FFFF		!keep positive

when tint,tword,treal,trange then
	return p^.value
else
CPL (p^.tag)
	pcustype("Can't hash:",p)
endswitch
return 0
end

global function finddictitem(variant vd, variant p,int doins)variant=

int hash,index,size,keytag,wrapped,limit
int64 keyvalue
variant q
object pa,qa,d

retry::
d:=vd.objptr

size:=d.udict.length/2


index:=(gethashvalue(p) iand (size-1))		!0-based index

q:=d^.udict.vptr+index*2							!point to key of key/value pair
wrapped:=0
keytag:=p^.tag
keyvalue:=p^.value							!when int
pa:=p^.objptr								!when string


do
	if q^.tag=tvoid then					!unused entry; not found
		exit

	elsif q^.tag=keytag then
		case keytag
		when tint,treal,tword,trange then
			if q.value=keyvalue then
				++q
				pc_share(q) when q^.hasref
				return q
			fi
		when tstring then
			qa:=q.objptr
			if pa.ustr.length=qa.ustr.length then	!match on length at least
				if memcmp(pa.ustr.strptr,qa.ustr.strptr,pa.ustr.length)=0 then
					++q
					pc_share(q) when q.hasref
					return q
				fi
			fi
		esac
	fi

++CLASHES
	++index
	q+:=2
	if index>=size then
		if wrapped then					!shouldn't happen if dict was properly expanded


			pcerror("DICT FULL?")
		fi
		wrapped:=1
		index:=0
		q:=d.udict.vptr
	fi
od

if doins then
	limit:=size*3/4
	if d.udict.dictitems>=limit then
		expanddict(vd)
		goto retry
	fi
	q^:=p^
	pc_share(q) when q^.hasref
	++(d.udict.dictitems)
	return q+1							!point to entry; leave value as void
else
	return nil
fi
end

proc expanddict(variant vd)=
	int n,m,i,j,k
	object d,e
	variant p,q,r
	varrec ev

	d:=vd.objptr

	n:=d.udict.allocated			!nos of keys and values (all slots)
	m:=n/2					!number of dict slots


	p:=d.udict.vptr							!old data


	e:=dict_new(m*2)
	objtovar(e,&ev)

	q:=p

	for i:=1 to m do
		if q^.tag<>tvoid then
			r:=finddictitem(&ev,q,1)
			pc_unshare(q) when q^.hasref
			++q
			r^:=q++^					!transfer ownership of data
		else
			q+:=2
		fi
	od

	dict_free(d)
	vd.objptr:=e
end

proc setfslength(ref char s,int m,n) =		!SETFSLENGTH


if m=n then		!no length needed (x,y)
elsif n=m-1 then	!n=m-1, use (x,0)
	(s+m-1)^:=0
else			!n<=m-2, so encode length at end of string (0,0) or (0,n)
	(s+m-2)^:=0		!
	(s+m-1)^:=n		!store count n (n can be zero)
fi
end

global function getfslength(ref char s,int m)int =		!GETFSLENGTH
s+:=m-1			!point to last char

if (s-1)^=0 then		!(0,n) length is n
	return s^
elsif s^=0 then		!(x,0) length is m-1
	return m-1
else				!(x,y) length is m
	return m
fi
end

global proc pc_storeptr(variant p,q)=
variant dest
variant pptr,qptr
varrec v
int i,n,etag
u32 ii,jj,mask
int poffset,qoffset,bitwidthx
ref byte pp,qq
int aa,bb

switch p^.tag
when trefvar then
	dest:=p^.varptr			!dest var
	pc_unshare(dest) when dest^.hasref
	pc_share(q) when q^.hasref
	dest^:=q^

when trefpacked then
	pc_storepacked(ref byte(p^.uref.ptr),q,p^.uref.elemtag)
	pc_unshare(q) when q^.hasref

when trefbit then

	pc_storebit(p^.uref.ptr,p^.uref.bitoffset,q,p^.uref.elemtag,p^.uref.bitlength)

when tlist then
	pc_popptrlist(p,q)

	pc_unshare(p) when p^.hasref
	pc_unshare(q) when q^.hasref

else
	pcustype("pc_popptr",p)
endswitch
end

global proc pc_storebit(ref byte p,int shift,variant q,int t,bitlength) =		!PC_STOREBIT
ref word pd
byte bb
word mask1,mask2,newvalue

if q^.tag<>tint then
	pcerror("storebit not int")
fi

switch (t)
when tu1 then
	if bitlength=0 then
		p^:=(p^ iand inot(1<<shift)) ior ((q^.value iand 1)<<shift)
	else
		pd:=cast(p)
		mask1:=0xFFFF'FFFF'FFFF'FFFE

		case bitlength
		when 1 then
		when 64 then
			mask1:=0
		else
			mask1<<:=bitlength-1
		esac

		mask1 :=inot mask1


		if shift then
			mask1<<:=shift
		fi

		mask2:=inot mask1
		newvalue:=q^.value
		if shift then
			newvalue<<:=shift
		fi
		pd^:=(pd^ iand mask2) ior (newvalue iand mask1)
	fi

when tu2 then
	p^:=(p^ iand inot(3<<shift)) ior ((q^.value iand 3)<<shift)
when tu4 then
	p^:=(p^ iand inot(15<<shift)) ior ((q^.value iand 15)<<shift)
else
	pcustypet("storebit",t)
endswitch
end

global proc pc_popptrlist(variant p, q) =

int i,nleft,nright
varrec v
variant pdata,qdata
object pp,qq

pp:=p.objptr

nleft:=pp.ulist.length
pdata:=pp.ulist.vptr

v.tagx:=tvoid

switch ttbasetype[q.tag]
when tlist then
	qq:=q.objptr
	nright:=qq.ulist.length
dolist::
	qdata:=qq.ulist.vptr
	for i to nleft do
		if i<=nright then
			pc_storeptr(pdata,qdata++)	!still some values on rhs
		else
			pc_storeptr(pdata,&v)		!fill with void
		fi
		++pdata  
	od

when trange then			!expand to two ints
	for i to nleft do
		if i<=2 then
			v.tagx:=tint
			v.value:=(i=1|q.range_lower|q.range_upper)
			pc_storeptr(pdata,&v)
		else
			v.tagx:=tvoid
			pc_storeptr(pdata,&v)
		fi
		++pdata
	od

when trecord then
	qq:=q.objptr
	nright:=ttlength[q.tag]
	goto dolist

when tarray then
	pcerror("POPPTRLIST ARRAY")

else
	pcustype("popptrlist",q)
endswitch

end

global proc pc_loadpacked(ref void p,int t,variant dest, object ownerobj) =		!PC_LOADPACKED
int length
variant q,r
ref int pp
object s
ref char ss

switch (ttbasetype[t])
when ti8 then
	dest^.tagx:=tint
	dest^.value:=ref i8(p)^

when ti16 then
	dest^.tagx:=tint
	dest^.value:=ref i16(p)^

when ti32 then
	dest^.tagx:=tint
	dest^.value:=ref int32(p)^

when ti64,tint then
	dest^.tagx:=tint
	dest^.value:=ref i64(p)^

when tu8 then
	dest^.tagx:=tint
	dest^.value:=ref byte(p)^

when tu16 then
	dest^.tagx:=tint
	dest^.value:=ref u16(p)^

when tu32 then
	dest^.tagx:=tint		!BETTER I64
	dest^.value:=ref u32(p)^

when tu64 then
	dest^.tagx:=tword		!BETTER I64
	dest^.value:=ref u32(p)^

when tr64 then
	dest^.tagx:=treal
	dest^.xvalue:=ref r64(p)^

when tr32 then
	dest^.tagx:=treal
	dest^.xvalue:=ref r32(p)^

when tstring then
	dest^.tagx:=tstring ior hasrefmask
	length:=ttlength[t]
	if length>=2 then		!normal fixed string
		length:=getfslength(p,length)
	else				!assume string basetype: char target (length can be 0)
		length:=1
	fi
	s:=make_strslicexobj(p,length)
	dest^.objptr:=s

when tstringz then		!zero-terminated string
	dest^.tagx:=tstring ior hasrefmask
	ss:=p
	to ttlength[t] do
		exit when ss^=0
		++ss
	od

	s:=make_strslicexobj(p,ss-ref char(p))
	dest^.objptr:=s

when trefpacked then
	dest^.tagx:=trefpacked
	dest^.uref.ptr:=cast(ref ref int32(p)^)
	dest^.uref.elemtag:=ttelemtype[t]

when tstruct then
	s:=obj_new(t)
	s.ustruct.mutable:=1
	s.ustruct.ptr:=p
dostruct::
	dest.objptr:=s
	dest.tagx:=t ior hasrefmask
	if ownerobj then
		s.objtype:=slice_obj
		s.ustruct.objptr2:=ownerobj
		++ownerobj^.refcount
	else
		s.objtype:=extslice_obj
	fi
when tarray then
	s:=array_new(t,ttelemtype[t],ttlength[t],ttlower[t])
	s.uarray.mutable:=1
	s.uarray.lower:=ttlower[t]
	s.uarray.ptr:=p
	s.uarray.length:=ttlength[t]
	s.uarray.elemtag:=ttelemtype[t]
	goto dostruct

else
CPL =t,ttbasetype[t]
	pcmxtypestt("loadpacked",t,ttbasetype[t])
endswitch
end

global proc pc_loadbit(ref byte p,int shift,t,bitlength,variant dest) =		!PC_LOADBIT
ref word pd
word mask

dest^.tagx:=tint
switch (t)
when tu1 then
	if bitlength=0 then
		dest^.value:=not not (p^ iand (1<<shift))
	else
		pd:=cast(p)
		mask:=0xFFFF'FFFF'FFFF'FFFE
CPL "PD=",PD^:"Z64BS,"
CPL =MASK
CPL =SHIFT
CPL =BITLENGTH
		case bitlength
		when 1 then
		when 64 then
			mask:=0
		else
			mask<<:=bitlength-1
		esac

CPL "MASK",MASK:"Z64BS,"
CPL "INOT MASK",INOT MASK:"Z64BS,"

		dest^.value:=(pd^>>shift) iand (inot mask)
	fi

when tu2 then
	dest^.value:=(p^ iand (3<<shift))>>shift
when tu4 then
	dest^.value:=(p^ iand (15<<shift))>>shift
else
	pcustypet("loadbit",t)
endswitch

end

global proc pc_loadptr(variant x,y)=

switch x^.tag
when trefvar then
	y^:=(x^.varptr)^
	if y^.hasref then
		++y^.objptr^.refcount
	fi

when trefpacked then
	pc_loadpacked(x.uref.ptr,x.uref.elemtag,y,nil)

else
	pcustype("pc_loadptr",x)
endswitch
end

global proc pc_storestring(variant p, q)=
object pp,qq

pp:=p^.objptr
qq:=q^.objptr

if pp^.objtype=normal_obj then
	pcerror("popstr not slice")
fi
if q^.tag<>tstring then
	pcerror("popstr not str")
fi
if pp.ustr.length<>qq.ustr.length then
	pcerror("popstr diff lengths")
fi
if not pp.ustr.mutable then
	pcerror("popstr not mut")
fi
if pp.ustr.length then
	memcpy(pp.ustr.strptr,qq.ustr.strptr,pp.ustr.length)
fi
pc_unshare(p)
pc_unshare(q)
end

global proc pc_iconvert(int t, variant x)=
int s,tbase
i64 aa
varrec bn

s:=x^.tag
if s=t and s<tlist then		!same type
	return 							!Note: heap types such as arrays must match on elemtypes too
fi
tbase:=ttbasetype[t]

x^.tag:=t			!assume works, so pre-set tag

switch ttbasetype[s]
when tint then
	switch tbase
	when tint then			!no changes needed
	when treal then
		x^.xvalue:=x^.value
	when tword then
	when tbignum then
		bx_makeint(sptr^.value,sptr)
	else
		pcustypet("conv dint=>",t)
	endswitch

when tword then
	switch tbase
	when tint then
	when tword then
	when treal then
	else
		pcustypet("conv dint=>",t);
	endswitch

when treal then
	switch (tbase)
	when tint then
		x^.value:=x^.xvalue
	else
		pcustypet("conv real=>",t)
	endswitch

when trefpacked,trefvar,trefbit,trefproc then
	switch tbase
	when tint,tword then
	else
		pcustypet("conv ptr=>",t)
	endswitch
when tstring then
	switch tbase
	when tbignum then
		bx_makestr(x^.objptr.ustr.strptr,x^.objptr.ustr.length,&bn)
		x^.tagx:=tstring ior hasrefmask		!set it back in order to free
		pc_unshare(x)
		x^:=bn
	when tstring then
	else
		pcustypet("string=>",t)
	endswitch

when ttype then
	if tbase<>tint then
		pcustypet("type=>",t)
	fi

when tbignum then
	switch (tbase)
	when tint then
		aa:=bx_int(x)
		x^.tagx:=tbignum ior hasrefmask		!set it back in order to free
		pc_unshare(x)
		x^.tagx:=tint
		x^.value:=aa
		x^.tagx:=t
	else
		pcustypet("bignum=>",t)
	endswitch

else
	pcmxtypestt("HARDCONV s^.t",s,t)
endswitch

end

global proc pc_iconvcase(variant a,b,int upper)=
int i,n
ref char s
object pa

pa:=a^.objptr

if b^.tag>tvoid then		!allow void param to be regarded as missing one
	n:=getintvalue(b)
else
	n:=pa.ustr.length			!default is the whole length of the string
fi

if a.tag<>tstring then
	pcerror("convcase/notstr")
fi

if n<0 then
	pcerror("CONVCASE N<0")
fi

if n=0 then
	return
fi

if n>pa.ustr.length then
cpl =n,pa.ustr.length
	pcerror("convcase/N?")
fi
s:=pa.ustr.strptr

if upper then
	to n do
		s^:=toupper(s^)
		++s
	od
else
	to n do
		s^:=tolower(s^)
		++s
	od
fi
end

global function pc_eqstring_nf(variant x,y)int =
int n
object px,py

px:=x.objptr
py:=y.objptr

n:=px.ustr.length

if n<>py.ustr.length then
	return 0					!unequal lengths
fi
if n=0 then
	return 1					!same zero length
fi

return cmpstringn(px.ustr.strptr,py.ustr.strptr,n)=0
end

global function pc_equal_nf(variant x,y,int shallow)int =

int xt,yt,xbase,ybase
int xval,yval,i,nbits,nbytes,n
variant p,q
object px,py

xbase:=ttbasetype[xt:=x^.tag]
ybase:=ttbasetype[yt:=y^.tag]

if ybase=tvoid then
	pcerror("pcequal/void")
fi
px:=x^.objptr
py:=y^.objptr

switch (xbase)
when tint then
	switch (ybase)
	when tint,tword then
		return (x^.value=y^.value|1|0)
	when treal then
		return (x^.value=y^.xvalue|1|0)
	endswitch

when tword then
	switch (ybase)
	when tu32 then
		return (x^.uvalue=y^.uvalue|1|0)
	endswitch

when treal then
	switch (ybase)
	when tint then
		return (x^.xvalue=y^.value|1|0)
	when treal then
		return (x^.xvalue=y^.xvalue|1|0)
	endswitch

when trange then
	if ybase=trange then			!compare all 64-bits using i64 type
		return (x^.value=y^.value|1|0)
	fi

when trefvar then
	switch (ybase)
	when trefvar,tint then
		return x^.value=y^.value
	endswitch

when trefpacked then
	switch (ybase)
	when trefpacked,tint then
		return x^.value=y^.value
	endswitch

when trefproc then
	switch (ybase)
	when trefproc,tint then
		return x^.value=y^.value
	endswitch

when tlist then
	if ybase=tlist then
		if shallow then
			return px=py
		fi

		if px.ulist.length<>py.ulist.length then
			return 0
		fi
		p:=px.ulist.vptr
		q:=py.ulist.vptr
		to px.ulist.length do			!compare all elements
			if pc_equal_nf(p++,q++,shallow)=0 then	!mismatched elements, so whole thing can't match
				return 0
			fi
		od
		return 1				!no mismatches (or both empty)
	fi

when tstring then
	switch (ybase)
	when tstring then			!ref string assumed here to mean special 1-char string
		return pc_eqstring_nf(x,y)
	endswitch

when tstruct then
	if xt<>yt then
		return 0
	fi
	return comparebytes(px.ustruct.ptr,py.ustruct.ptr,ttsize[xt])

when tset then
	if ybase<>tset then
		return 0
	fi
	if px.uset.length<>py.uset.length then
		return 0
	fi
	nbytes:=(px.uset.length-1)/64+1
	return comparebytes(px.uset.ptr,py.uset.ptr,nbytes)

when tvoid then
	pcerror("Comparing void types")

when tbignum then
	if ybase<>tbignum then
		return 0
	fi
	return bx_equal(x,y)=1

when trecord then
	if xt<>yt then
		return 0
	fi 
	if shallow then
		return px=py
	fi
	p:=px.urec.vptr
	q:=py.urec.vptr
	n:=ttlength[xt]
	to n do				!compare all elements
		if pc_equal_nf(p++,q++,shallow)=0 then	!mismatched elements, so whole thing can't match
			return 0
		fi
	od
	return 1				!no mismatches (or both empty)
when tarray then
	if xt<>yt or xbase<>ybase or px.uarray.elemtag<>py.uarray.elemtag then
		return 0
	fi
	if px.uarray.length<>py.uarray.length then
		return 0
	fi
	return comparebytes(px.uarray.ptr,py.uarray.ptr,px.uarray.length*ttsize[px.uarray.elemtag])

when ttype then
	if ybase=ttype and x^.value=y^.value then
		return 1
	fi

else
CPL "DIFF TYPES"
	return 0

endswitch

return 0
end

global function comparebytes(ref byte p,q,int n)int =		!PC_COMPAREBYTES
return memcmp(p,q,n)=0
end

global function pc_compare_nf(variant x,y)int =
int xt,yt,xbase,ybase
int xval,yval,i,nbits,nbytes
variant p,q
object px,py

ybase:=ttbasetype[yt:=y^.tag]
xbase:=ttbasetype[xt:=x^.tag]

switch (xbase)
when tint then
	switch (ybase)
	when tint then
		return (x^.value < y^.value | -1 | (x^.value > y^.value | 1 | 0))
	when treal then
		return (x^.value < y^.xvalue | -1 | (x^.value > y^.xvalue | 1 | 0))
	else
		goto badcmp
	endswitch

when tword then

	switch (ybase)
	when tword then
		return (x^.uvalue < y^.uvalue | -1 | (x^.uvalue > y^.uvalue | 1 | 0))
	else
		goto badcmp
	endswitch

when treal then
	switch (ybase)
	when tint then
		return (x^.xvalue < y^.value | -1 | (x^.xvalue > y^.value | 1 | 0))
	when treal then
		return (x^.xvalue < y^.xvalue | -1 | (x^.xvalue > y^.xvalue | 1 | 0))
	else
		goto badcmp
	endswitch

when trefpacked then
	switch (ybase)
	when trefpacked,tint then
		return (x^.value < y^.value | -1 | (x^.value > y^.value | 1 | 0))
	else
		goto badcmp
	endswitch

when trefvar then
	switch (ybase)
	when trefvar,tint then
		return (x^.value < y^.value | -1 | (x^.value > y^.value | 1 | 0))
	else
		goto badcmp
	endswitch

when tstring then
	switch (ybase)
	when tstring then			!ref string assumed here to mean special 1-char string
		px:=x.objptr
		py:=y.objptr
		return cmpstring_len(px.ustr.strptr,py.ustr.strptr,px.ustr.length,py.ustr.length)
	else
		goto badcmp
	endswitch

when tbignum then
	if ybase=tbignum then
		return bx_cmp(x,y)
	else
		goto badcmp
	fi

else
badcmp::
	pcmxtypes("pc_compare",x,y)

endswitch

return 0
end

global function cmpstring_len(ref char s,t,int slen,tlen)int =

if slen=0 then
	if tlen=0 then
		return 0		!empty:empty
	else
		return -1		!empty:str
	fi
elsif tlen=0 then	!str:empty
	return 1
else
	if slen=tlen then
		if slen=1 then
			if s^<t^ then return -1
			elsif s^>t^ then return 1
			else
				return 0
			fi
		fi
		return cmpstringn(s,t,slen)
	else
		return cmpstring(convCstring(s,slen),convCstring(t,tlen))
	fi
fi
end

global function pc_eqstring(variant x,y)int=
object px,py
int res,n

res:=pc_eqstring_nf(x,y)
px:=x^.objptr
py:=y^.objptr

pc_unshare(x) when x^.hasref
pc_unshare(y) when y^.hasref
return res
end

global function pc_equal(variant x,y,int shallow=0)int=
int res,n

if x.tag<>y.tag and (x.tag=tbignum or y.tag=tbignum) then
	pcerror("pcequal/mixed bignum")
fi

res:=pc_equal_nf(x,y,shallow)


pc_unshare(x) when x^.hasref
pc_unshare(y) when y^.hasref
return res
end

global function pc_compare(variant x,y)int=
int res,n

res:=pc_compare_nf(x,y)
pc_unshare(x) when x^.hasref
pc_unshare(y) when y^.hasref
return res
end

global function u8inarray(byte a,object p)int=
int i
ref byte q

i:=p.uarray.lower
q:=p.uarray.ptr

to p.uarray.length do
	if q^=a then
		return i
	fi
	++q
	++i
od
return p.uarray.lower-1
end

global function u16inarray(word16 a,object p)int=
int i
ref word16 q

i:=p.uarray.lower
q:=cast(p.uarray.ptr)

to p.uarray.length do
	if q^=a then
		return i
	fi
	++q
	++i
od
return p.uarray.lower-1
end

global function u32inarray(word32 a,object p)int=
int i
ref word32 q

i:=p.uarray.lower
q:=cast(p.uarray.ptr)

to p.uarray.length do
	if q^=a then
		return i
	fi
	++q
	++i
od
return p.uarray.lower-1
end

global function u64inarray(word64 a,object p)int=
int i
ref word64 q

i:=p.uarray.lower
q:=cast(p.uarray.ptr)

to p.uarray.length do
	if q^=a then
		return i
	fi
	++q
	++i
od
return p.uarray.lower-1
end

global function bitinbits(byte a,object p)int=
int i,offset,mask
ref byte q

i:=p.ubits.lower
q:=p.ubits.ptr
offset:=p.ubits.bitoffset-1
mask:=1
if offset then
	mask :=mask << offset
fi

to p.ubits.length do
CPL =q^, q^ iand mask,=mask,i,=a
	if q^ iand mask then			!1 stored
		if a then return i fi
	elsif a=0 then return i
	fi
	++i
	mask<<:=1
	if mask>=256 then
		mask:=1
		++q
	fi
od
return p.ubits.lower-1
end

global function pc_strinstr(variant x,y)int =
int xlen,ylen,result,i,j,k
ref char sx, sy
object px,py

px:=x.objptr
py:=y.objptr

xlen:=px.ustr.length
ylen:=py.ustr.length

if xlen=0 or ylen=0 then		!at least one is empty
	return 0
fi

k:=ylen-xlen
for i:=0 to k do			!all start positions
	sx:=px.ustr.strptr
	sy:=py.ustr.strptr+i
	for j:=1 to xlen do			!all chars in y
		if sx^<>sy^  then
			goto nextpos
		fi
		++sx; ++sy
	od
	return i+1
nextpos::
od
return 0
end

global function getbitoffset(ref byte p, int offset, index, t, byte &newoffset)ref byte=


switch t
when tu1 then
	index+:=offset				!adjust index to be from start of byte
	p+:=index>>3				!add number of whole bytes
	newoffset:=index iand 7
when tu2 then
	index+:=offset>>1
	p+:=index>>2
	newoffset:=(index iand 3)*2
when tu4 then
	index+:=offset>>2
	p+:=index>>1
	newoffset:=(index iand 1)*4
end

return p
end

global proc pc_iappendlist(variant a,b)=
int n,lower
variant q
object p

p:=a.objptr

if p^.objtype<>normal_obj then
	pcerror("Can't extend slice")
fi

if not p.ulist.mutable then
	p:=copyonwrite(p,tlist)
fi

n:=p.ulist.length+1			!new length

if n>p.ulist.allocated then		!need more space
	list_resize(p,n)
else
	p.ulist.length:=n
fi

(p.ulist.vptr+n-1)^.tagx:=tvoid		!set new element to void

a.objptr:=p

q:=p.ulist.vptr+p.ulist.length-1
if b then
	q^:=b^						!xfer reference
else
	q.tagx:=tvoid
fi
end

global proc pc_iappendarray(variant a,b)=
int n,lower
ref byte q
object p

p:=a^.objptr

if p^.objtype<>normal_obj then
	pcerror("Can't extend slice")
fi

if not p.uarray.mutable then
	p:=copyonwrite(p,a^.tag)
fi

n:=p.uarray.length+1			!new length

if n>p.uarray.allocated then		!need more space
	array_resize(p,n)
else
	p.uarray.length:=n
fi

a.objptr:=p

q:=p.uarray.ptr+(p.uarray.length-1)*ttsize[p.uarray.elemtag]

if b then
	pc_storepacked(cast(q),b,p.uarray.elemtag)
fi

end

global proc pc_mul_listi(variant a,b,c) =		!PC_MUL_LISTI
variant newptr,oldptr,q
int newlength,newalloc,oldlength,k
int i,newtag,lwr
i64 dvalue
varrec d
object pa,pc

d:=a^

pa:=d.objptr

oldlength:=pa.ulist.length
newlength:=oldlength*b.value
oldptr:=pa.ulist.vptr			!point to first element of array to be duplicated

if not oldlength then		!duplicating b times has no effect (leave c=a)
	return
fi

if newlength<0 then
	pcerror("mullist 0")
elsif newlength=0 then
	pc_unshare(a) when a.hasref
	c.tagx:=tlist
	c.objptr:=emptylist
	++emptylist^.refcount
	return
fi


if oldlength=1 then
	pc:=list_new(newlength,pa.ulist.lower)
	newptr:=pc.ulist.vptr

	c.tagx:=d.tagx
	c.objptr:=pc

	q:=d.objptr.ulist.vptr
	to newlength do
		newptr^:=q^
		if newptr.hasref then
			++newptr^.objptr^.refcount
			pc_dupl(newptr)
		fi
		++newptr
	od

	pc_unshare(&d) when d.hasref

else
	pcerror("MULLISTINT/COMPLEX")
fi
end

global proc pc_mul_stri(variant a,b,c) =		!PC_MUL_STRI

int i,m,oldlen,newlen
ref char newptr,p
varrec v
object pa,s

m:=getintvalue(b)

if m<0 then
	pcerror("neg str mul")
elsif m=0 then		!result is empty str
	pc_emptystring(c)
	return
elsif m=1 then		!leave a unchanged
	if a<>c then
		c^:=a^
		pc_share(c) when c^.hasref
	fi
	return
else				!multiple non-null string by m
	pa:=a.objptr
	oldlen:=pa.ustr.length
	if oldlen then			!not empty string
		newlen:=oldlen*m

		pc_makestringn(newlen,&v)
		p:=v.objptr.ustr.strptr
		to m do
			memcpy(p,pa.ustr.strptr,oldlen)
			p+:=oldlen
		od
		pc_unshare(a)
		c^:=v
	else				!was empty string: copy to v
		c^:=a^
		pc_share(a)
		return
	fi
fi
end

global proc pc_duplvar(variant p)=
if p^.hasref then
	dupl_table[p^.tag]^(p)
fi
end

global proc pc_iconcatlist(variant a,b)=
variant newptr,c,d
int n,alen,blen,newlen,oldbytes,newbytes
variant v
object pa,pb

pa:=a^.objptr

if not pa.ulist.mutable then
	pa:=copyonwrite(pa,a^.tag)
	a.objptr:=pa
fi

pb:=b.objptr

alen:=pa.ulist.length
blen:=pb.ulist.length

if alen=0 then					!concat to empty list
	if blen then				!copy b to a (else leave a as empty)
		list_resize(pa,blen)
		d:=pa.ulist.vptr
		memcpy(d,pb.ulist.vptr,blen*varsize)
		to blen do
			pc_share(d) when d.hasref
			++d
		od
	fi
elsif blen then					!neither list is empty (else leave a unchanged)
	newlen:=alen+blen
	list_resize(pa,newlen)
	d:=pa.ulist.vptr+alen
	memcpy(d,pb.ulist.vptr,blen*varsize)
	to blen do
		pc_share(d) when d.hasref
		++d
	od
fi
end

global proc pc_iappendbits(variant a,b)=
int lower,elemtype,index
int64 n
byte bitoffset
ref byte q
object p

p:=a^.objptr

if not p.ubits.mutable then
	a^.objptr:=p:=copyonwrite(p,a^.tag)
fi

n:=p.ubits.length+1			!new length

if word(n)>p.ubits.allocated64 then		!need more space
	bits_resize(p,n)
else
	p.ubits.length:=n
fi

elemtype:=p.ubits.elemtag

q:=getbitoffset(cast(p.ubits.ptr),p.ubits.bitoffset-1,p.ubits.length-1, elemtype, bitoffset)

if b then
	pc_storebit(q,bitoffset,b,elemtype,0)
fi
end

global proc pc_makestring(ichar s, int length, variant dest)=
ref char t

if s=nil then
	pc_makestringx(nil,0,0,dest)
	return
fi

if length=-1 then
	length:=strlen(s)
fi

if length=0 then
	pc_makestringx(t,0,0,dest)
else
	t:=pcm_alloc(length)

	memcpy(t,s,length)

	pc_makestringx(t,length,allocbytes,dest)
fi
end

global proc pc_makestringx(ichar s, int length,allocated, variant dest)=
ref char t
object p

if length=-1 then
	length:=strlen(s)
fi

dest.tagx:=tstring+hasrefmask

dest.objptr:=p:=obj_new(tstring)

if length=0 then
	p.ustr.strptr:=nil
else
	p.ustr.strptr:=s
	p.ustr.length:=length
	p.ustr.allocated:=allocated
fi
p.ustr.mutable:=1

end

global proc pc_makestringn(int length, variant dest)=
object p

dest.tagx:=tstring+hasrefmask
dest.objptr:=p:=obj_new(tstring)

if length>maxobjlength then
	pcerror("String*n too long")
fi

p.ustr.strptr:=pcm_alloc(length)
p.ustr.mutable:=1
p.ustr.length:=length
p.ustr.allocated:=allocbytes
end

global proc pc_emptystring(variant dest)=
dest.tagx:=tstring ior hasrefmask
dest.objptr:=emptystring
++emptystring^.refcount
end

global proc pc_makechar(int ch,variant dest)=
varrec v

[10]char str
object p

dest.tagx:=tstring ior hasrefmask

p:=chrtable[ch]
if p=nil then			!create single-char constant
	str[1]:=ch
	str[2]:=0
	pc_makestring(&.str,1,&v)
	p:=v.objptr
	p.ustr.mutable:=0
	chrtable[ch]:=p
fi
++p^.refcount
dest.objptr:=p
end

=== pc_objlib.m 14/56 ===
import clib
import msys
import mlib
import oslib

import pc_decls
import pc_types
import pc_pcfns
import pc_support



global object zeroobj
global object emptylist
global object emptystring
global object emptyset

proc $init=
	zeroobj:=pcm_allocz(objrec.bytes)
	zeroobj.refcount:=1

	emptylist:=obj_new(tlist)
	emptylist.ulist.lower:=1
	emptylist.objtype:=normal_obj

	emptystring:=obj_new(tstring)
	emptystring.objtype:=normal_obj

	emptyset:=obj_new(tset)
	emptyset.objtype:=normal_obj


end

global function obj_new(int tag)object p=

	p:=pcm_alloc32()

	p^:=zeroobj^			!includes refcount=1
	p.tag:=tag
	return p
end

global proc freeobject(object p)=
		pcm_free32(p)
end

global function array_new(int ta, elemtype, length,lower)object p=

	ref byte q
	int elemsize

	elemsize:=ttsize[elemtype]

	p:=obj_new(ta)
	p.uarray.mutable:=1
	p.uarray.lower:=lower
	p.uarray.length:=length
	p.uarray.objtype:=normal_obj
	p.uarray.elemtag:=elemtype

	if length then
		q:=p.uarray.ptr:=pcm_allocz(length*elemsize)
		p.uarray.allocated:=allocbytes/elemsize
	fi

	return p
end

global function list_new(int length,lower=1, variant defval=nil)object p=
	variant q

	p:=obj_new(tlist)
	p.ulist.mutable:=1
	p.ulist.lower:=lower
	p.ulist.length:=length
	p.ulist.objtype:=normal_obj

	if length then
		q:=p.ulist.vptr:=pcm_alloc(length*varrec.bytes)
		p.ulist.allocated:=allocbytes/varrec.bytes
		to length do
			if defval then
				q^:=pc_share(defval)^
			else
				q.tagx:=tvoid
			fi
			++q
		od
	fi

	return p
end

global proc objtovar(object p, variant q)=
	q.tagx:=p.tag ior hasrefmask
	q.objptr:=p
end

global function set_new(int length,lower)object p=

	p:=bits_new(tu1,length,lower)
	p.tag:=tset

	return p
end

global function bits_new(int elemtype,length,lower)object p=

	ref byte q
	int bitwidthx,nbits,nbytes

	p:=obj_new(tbits)
	p.ubits.mutable:=1
	p.ubits.lower:=lower
	p.ubits.length:=length
	p.ubits.objtype:=normal_obj
	p.ubits.elemtag:=elemtype

	bitwidthx:=ttbitwidth[elemtype]		!should be 1, 2 or 4 bits
	nbits:=length*bitwidthx				!total bits needed

	nbytes := ((nbits-1)/64+1)*8		!bytes required in 64-bit blocks



	if length then
		p.ubits.ptr := pcm_alloc(nbytes)              !(turns total allocated in 'allocbytes')


		p.ubits.allocated64 := word64(allocbytes)*(8/bitwidthx)

		pcm_clearmem(p.ubits.ptr,allocbytes)
	else
		p.ubits.ptr:=nil
	fi

	return p
end

global function struct_new(int t)object p=
	p:=obj_new(t)
	p.ustruct.mutable:=1

	p.ustruct.ptr:=pcm_allocz(ttsize[t])
	p.ustruct.allocated:=allocbytes

	return p
end

global function dict_new(int n)object p=
	int m

	m:=max(16,nextpoweroftwo(n*2))		!list has 2n entries, min 16, rounded up to 2**x


	p:=list_new(m,1,nil)
	p.tag:=tdict
	p.udict.dictitems:=0
	return p

end

global function record_new(int rectype)object p=
	variant q

	p:=obj_new(rectype)
	p.urec.mutable:=1

	p.urec.vptr:=pcm_allocz(ttlength[rectype]*varsize)
	return p
end

global proc list_free(object p)=
	if p.ulist.length then
		pcm_free(p.ulist.vptr,p.ulist.allocated*varrec.bytes)
	fi
end

global proc record_free(object p)=
	pcm_free(p.urec.vptr,ttlength[p.tag]*varsize)
end

global proc array_free(object p)=
	if p.ulist.length then
		pcm_free(p.uarray.ptr,p.uarray.allocated*ttsize[p.uarray.elemtag])
	fi
end

global proc bits_free(object p)=
	if p.ulist.length then
		pcm_free(p.ubits.ptr,bits_bytesize(p))
	fi
end

global proc dict_free(object p)=

	if p.udict.length then
		pcm_free(p.udict.vptr,p.udict.allocated*varrec.bytes)
	fi

end

global function bits_bytesize(object p)int=
	int elemtype,nbits

	elemtype:=p.ubits.elemtag

	case elemtype
	when tu1,tu2,tu4 then
		nbits:=ttbitwidth[elemtype]*p.ubits.length
		if nbits iand 7 then			!fractional number of bytes
			return nbits/8+1
		else
			return nbits/8
		fi
	esac
	return ttsize[elemtype]*p.uarray.length		!array?
end

global proc list_resize(object p,int n)=
	variant q

	if n<=p.ulist.allocated then
		p.ulist.length:=n
	else
		q:=pcm_alloc(n*varsize)
		if p.ulist.length then
			memcpy(q,p.ulist.vptr,p.ulist.length*varsize)
			pcm_free(p.ulist.vptr,p.ulist.allocated*varsize)
		fi
		p.ulist.vptr:=q
		p.ulist.length:=n
		p.ulist.allocated:=allocbytes/varsize
	fi
end

global proc array_resize(object p,int n)=
	ref byte q
	int elemsize

	elemsize:=ttsize[p.uarray.elemtag]

	if n<=p.uarray.allocated then
		p.uarray.length:=n
	else
		q:=pcm_alloc(n*elemsize)
		if p.uarray.length then
			memcpy(q,p.uarray.ptr,p.uarray.length*elemsize)
			pcm_free(p.uarray.ptr,p.uarray.allocated*elemsize)
		fi
		p.uarray.ptr:=q
		p.uarray.length:=n
		p.uarray.allocated:=allocbytes/elemsize
	fi
end

global proc bits_resize(object p,int n)=
	object pnew
	ref byte q
	int elemsize,oldrefcount

	if word(n)<=p.ubits.allocated64 then
		p.ubits.length:=n
		return
	fi

	pnew:=bits_new(p.ubits.elemtag,p.ubits.length,p.ubits.lower)

	memcpy(pnew.ubits.ptr, p.ubits.ptr, bits_bytesize(p))

	oldrefcount:=p.ubits.refcount
	bits_free(p)
	p^:=pnew^
	p.refcount:=oldrefcount
end

global proc string_resize(object p,int n)=
	ref char q
	int elemsize

	if n<=p.ustr.allocated then
		p.ustr.length:=n
	else
		q:=pcm_alloc(n)
		if p.ustr.length then
			memcpy(q,p.ustr.strptr,p.ustr.length)
			pcm_free(p.ustr.strptr,p.ustr.allocated)
		fi

		p.ustr.strptr:=q
		p.ustr.length:=n
		p.ustr.allocated:=allocbytes
	fi
end

global function copyonwrite(object p,int tag)object=
object q
varrec v

if p.ulist.mutable then return p fi


v.tagx:=tag+hasrefmask
v.objptr:=p

pc_dupl(&v)

q:=v.objptr
q.ulist.mutable:=1
return q
end

global function make_strslicexobj(ichar s, int length)object=
	object p

	if length=0 then s:=nil fi

	p:=obj_new(tstring)
	p.ustr.strptr:=s
	p.ustr.mutable:=1
	p.ustr.length:=length
	p.objtype:=extslice_obj		!.objptr2 will be zero
	return p
end

global function bignum_make(ref void bn)object p=

	p:=obj_new(tbignum)
	p.udec.bnptr:=bn

	return p
end

=== pc_bignum.m 15/56 ===

import clib
import mlib
import oslib

import pc_types
import pc_decls
import pc_support
import pc_objlib
import mbignum

global proc bx_makestr(ref char s, int length, variant p)=
makebnvar(p,bn_makestr(s,length))
end

global function bx_tostring(variant a,int fmt)ichar=
return bn_tostring(a^.objptr^.udec.bnptr,fmt)
end

global proc bx_dupl(variant p)=
bignum a

a:=bn_init()
bn_dupl(a,p^.objptr^.udec.bnptr)

makebnvar(p,a)
end

global proc bx_negto(variant p)=
bn_negto(p^.objptr^.udec.bnptr)
end

global proc bx_absto(variant p)=
bn_absto(p^.objptr^.udec.bnptr)
end

function makebnvar(variant dest,bignum bn=nil)bignum=
dest^.tagx:=tbignum ior hasrefmask

if bn=nil then
	bn:=bn_init()
fi

dest^.objptr:=bignum_make(bn)
return bn
end

global proc bx_free(variant a)=
bn_free(a^.objptr^.udec.bnptr)
freeobject(a^.objptr)
end

global proc bx_makeint(i64 aa, variant dest)=
makebnvar(dest,bn_makeint(aa))
end

global proc bx_add(variant a,b,c)=
varrec v
bn_add(makebnvar(&v),a^.objptr^.udec.bnptr,b^.objptr^.udec.bnptr)
c^:=v
end

global proc bx_sub(variant a,b,c)=
varrec v
bn_sub(makebnvar(&v),a^.objptr^.udec.bnptr,b^.objptr^.udec.bnptr)
c^:=v
end

global proc bx_mul(variant a,b,c)=
varrec v
bn_mulp(makebnvar(&v),a^.objptr^.udec.bnptr,b^.objptr^.udec.bnptr,1000)
c^:=v
end

global proc bx_div(variant a,b,c)=
varrec v
bn_div(makebnvar(&v),a^.objptr^.udec.bnptr,b^.objptr^.udec.bnptr,1000)
c^:=v
end

global proc bx_idiv(variant a,b,c)=
varrec v
bn_idiv(makebnvar(&v),a^.objptr^.udec.bnptr,b^.objptr^.udec.bnptr)
c^:=v
end

global proc bx_irem(variant a,b,c)=
varrec v
bn_irem(makebnvar(&v),a^.objptr^.udec.bnptr,b^.objptr^.udec.bnptr)
c^:=v
end

global function bx_equal(variant a,b)int=
return bn_equal(a^.objptr^.udec.bnptr, b^.objptr^.udec.bnptr)
end

global function bx_cmp(variant a,b)int=
return bn_cmp(a^.objptr^.udec.bnptr, b^.objptr^.udec.bnptr)
end

global function bx_int(variant p)i64=
bignum a,b
int64 x

a:=p^.objptr^.udec.bnptr

if bn_isint(a) then
	return bn_toint(a)
fi
b:=bn_init()
bn_fix(b,a)
x:=bn_toint(b)
bn_free(b)
return x
end

global proc bx_power(variant a,int64 n,variant dest)=
varrec e

bn_ipower(makebnvar(&e),a^.objptr^.udec.bnptr,n)
dest^:=e
end

global proc bx_reduce(variant bn)=
PCERROR("BX_REDUCE")
end

global function bx_length(variant bn)int=
return bn_digits(bn^.objptr^.udec.bnptr)
end
=== mbignum.m 16/56 ===

import clib
import mlib
import oslib

const digitwidth   = 9
const digitbase	= 1000000000
const digitfmt	 = "%09d"
const mdigitfmt	 = "z9"

INT NMAKE
INT NFREE

const digitmax	 = digitbase-1

export type bignum  = ref bignumrec
type elemtype = int32
const elemsize = elemtype.bytes

export record bignumrec =
	ref[0:]elemtype num
	int length
	int expon
	int32 neg
	int32 numtype
end

record constrec =
	int64 value
	bignum bnvalue
	ref constrec nextconst
end

tabledata() [0:]ichar fpnames =
	(zero_type = 0,	 $),
	(normal_type,	   $),
	(inf_type,	 	 $),
	(nan_type,	 	 $),
end

enum (
	nn_types,	 	  ! both numbers (non-zero)
	zz_types,	 	  ! both zero
	ii_types,	 	  ! both infinity
	xx_types,	 	  ! one or both is nan

	nz_types,	 	  ! number/zero
	ni_types,	 	  ! number/infinity

	zn_types,	 	  ! zero/number
	in_types,	 	  ! infinity/number

	zi_types,	 	  ! zero/infinity
	iz_types)	 	  ! infinity/zero

const maxprec	  = 10 million
int currprec	   = 300/digitwidth

int stblz	 	 	 !global set by smalltobig

ref constrec constlist=nil	  !use linked list of constant values

global function bn_init()bignum=
	bignum a

	a:=makebignum(0)
	return a
end

function readexpon(ichar s)int=
	int neg, expon
	neg:=expon:=0

	case s^
	when '+' then ++s
	when '-' then neg:=1; ++s
	esac

	doswitch s^
	when '0'..'9' then
		expon:=expon*10+(s^-'0')
		++s
	when '_', '\'', '`', ' ' then
		++s
	when 0 then
		exit
	else
		bn_error("make expon?")
	end doswitch

	return (neg|-expon|expon)
end

export proc bn_print(bignum a,int format=0)=
	ichar s

	s:=bn_tostring(a,format)
	print s
end

export proc bn_println(bignum a, int format=0)=
	bn_print(a,format)
	println
end

function getbintype(bignum a,b)int=
	int atype:=a^.numtype, btype:=b^.numtype

	if atype=nan_type or btype=nan_type then
		return xx_types
	fi

	case atype
	when normal_type then
		case btype
		when normal_type then
	 	   return nn_types
		when zero_type then
	 	   return nz_types
		else
	 	   return ni_types
		esac
	when zero_type then
		case btype
		when normal_type then
	 	   return zn_types
		when zero_type then
	 	   return zz_types
		else
	 	   return zi_types
		esac
	else
		case btype
		when normal_type then
	 	   return in_types
		when zero_type then
	 	   return iz_types
		else
	 	   return ii_types
		esac
	esac

end

function makebignum(int length)bignum=
	bignum a

	a:=bn_alloc(bignumrec.bytes)
	if length then
		a^.num:=bn_alloc(length*elemsize)
		a^.numtype:=normal_type
	else
		a^.num:=nil
		a^.numtype:=zero_type
	fi
	a^.length:=length
	a^.expon:=0
	a^.neg:=0

	return a
end

function makesmallnum(int length)ref elemtype=
	return bn_alloc(length*elemsize)
end

function smalltobig(bignum c, ref elemtype a, int length,alloc,offset=0)bignum =

	ref elemtype p
	int leadingzeros, trailingzeros, nonzeros, newlength

	bn_setzero(c)

	p:=a
	leadingzeros:=trailingzeros:=nonzeros:=0
	to length do
		if p++^ then
	 	   nonzeros:=1
	 	   trailingzeros:=0
		else
	 	   if nonzeros then
	 	 	  ++trailingzeros
	 	   else
	 	 	  ++leadingzeros
	 	   fi
		fi
	od

	stblz:=leadingzeros

	if nonzeros then

		newlength:=length-trailingzeros-leadingzeros

		if newlength=length=alloc then	 	 !can use data in a directly
	 	   c^.num:=cast(a)
		else
	 	   c^.num:=cast(makesmallnum(newlength))
	 	   memcpy(c^.num,a+leadingzeros,newlength*elemsize)
	 	   freesmall(a+offset,alloc)
		fi
		c^.length:=newlength
		c^.numtype:=normal_type
		c^.expon:=length-1-leadingzeros	 		!include trailing zeros, but not leading ones?
	elsif alloc then	 	 	 	 	 	 	  !result stays at zero
		freesmall(a+offset,alloc)
	fi

	return c
end

proc freesmall(ref elemtype p, int length)=
	freemem(p,length*elemsize)
end

export function bn_alloc(int size)ref void=
	ref void p

	p:=pcm_alloc(size)
	if p=nil then
		abortprogram("bignum:out of memory")
	fi

	return p
end

export function checkedmalloc(int size)ref void=
	ref void p

	p:=malloc(size)
	if p=nil then
		abortprogram("CM:Out of memory")
	fi

	return p
end

export proc bn_free(bignum a)=
	if a then
		bn_setzero(a)
		freemem(a,bignumrec.bytes)
	fi
end

proc freemem(ref void p, int size)=
	pcm_free(p,size)
end

export proc bn_setzero(bignum a)=
	if a then
		if a^.num then
	 	   freesmall(cast(a^.num),a^.length)
		fi
		a^.num:=nil
		a^.length:=0
		a^.neg:=0
		a^.expon:=0
		a^.numtype:=zero_type
	fi
end

export proc bn_move(bignum a,b)=

bn_setzero(a)
a^:=b^
memset(b,0,bignumrec.bytes)
end

export proc bn_dupl(bignum a,b)=
	bignum c
	int size

		c:=bn_init()
		c^:=b^
		if c^.length then
			c^.num:=cast(makesmallnum(size:=c^.length))
			memcpy(c^.num,b^.num, size*elemsize)
		fi
		bn_move(a,c)
		bn_free(c)

end

export proc bn_setinf(bignum dest) =
	bn_setzero(dest)
	dest^.numtype:=inf_type
end

export proc bn_setnan(bignum dest) =
	bn_setzero(dest)
	dest^.numtype:=nan_type
end

proc bn_error(ichar mess) =
	print "BN:"
	abortprogram(mess)
end

export function bn_iszero(bignum a)int=
	return a^.numtype=zero_type
end

export proc bn_negto(bignum a)=
	if not bn_iszero(a) then
		a^.neg:=not a^.neg
	fi
end

export proc bn_absto(bignum a)=
	a^.neg:=0
end

export function bn_isint(bignum a)int =
	return a^.length<=a^.expon+1
end

export function bn_getprec(bignum a)int=
	return a^.length*digitwidth
end

export proc bn_setprec(bignum a,int prec)=
	int oldlength,newlength
	bignum c

	if a^.numtype<>normal_type then
		return
	fi

	if prec<1 or prec>maxprec then
		return
	fi

	prec:=((prec-1)/digitwidth+1)*digitwidth		!must be multiple of digitwidth

	newlength:=prec/digitwidth	 	 	 	   !no. words

	oldlength:=a^.length

	if oldlength<=newlength then
		return
	fi

	c:=makebignum(newlength)
	c^.neg:=a^.neg
	c^.expon:=a^.expon

	for i:=0 to newlength-1 do
		if i<oldlength then
	 	   c^.num^[i]:=a^.num^[i]
		else
	 	   c^.num^[i]:=0
		fi
	od

	bn_move(a,c)
	bn_free(c)
end

export function bn_getglobalprec:int=
	return currprec*digitwidth
end

export proc bn_setglobalprec(int prec)=
	currprec:=((prec-1)/digitwidth+1)
end

export function bn_makeint(int x)bignum =
	bignum a
	[256]char str

	if x=0 then
		a:=makebignum(0)
	elsif x in 0..digitmax then
		a:=makebignum(1)
		a^.num^[0]:=x
	elsif -x in 0..digitmax then
		a:=makebignum(1)
		a^.num^[0]:=-x
		a^.neg:=1
	else
		sprintf(&.str,"%lld",x)
		a:=bn_makestr(&.str)
	fi

	return a
end

export function bn_makefloat(real64 x)bignum =
	bignum a
	[2048]char str

	sprintf(&.str,"%.30g",x)

CPL =&.STR

	return bn_makestr(&.str)
end

export proc bn_ipower(bignum d, a,int64 n)=
	bignum e,f

	if n<0 then
		bn_setzero(d)

	elsif n=0 then
		bn_move(d,bn_makeint(1))

	elsif n=1 then
		bn_dupl(d,a)
	elsif (n iand 1)=0 then
		e:=bn_init()
		bn_mulu(e,a,a)
		bn_ipower(d,e,n/2)
		bn_free(e)	  

	else	 	   !assume odd
		e:=bn_init()
		f:=bn_init()
		bn_mulu(e,a,a)
		bn_ipower(f,e,(n-1)/2)
		bn_mulu(d,a,f)
		bn_free(e)
		bn_free(f)

	fi
end

function smallsubto(ref elemtype p,q, int plen, qlen)int=
	ref elemtype pp,qq
	int carry,diff,z

	pp:=p+plen-1
	qq:=q+qlen-1
	carry:=0
	z:=0	 	 	 	 !leading zeros

	to plen do
		if qq>=q then
	 	   diff:=pp^-qq^-carry
	 	   --qq
		else
	 	   diff:=pp^-carry
		fi

		if diff<0 then
	 	   carry:=1
	 	   pp^:=diff+digitbase
		else
	 	   pp^:=diff
	 	   carry:=0
		fi
		if pp^ then
	 	   z:=0
		else
	 	   ++z
		fi
		--pp
	od
	if carry then bn_error("SSUBTO/CARRY?") fi

	if z=plen then --z fi	 	  !result is zero, needs at least one digit

	if z then
		plen-:=z
		pp:=p
		qq:=p+z
		to plen do
	 	   pp++^:=qq++^
		od
	fi

	return plen
end

function smallmulto(ref elemtype p,q, int plen, m)int=

	ref elemtype pp,qq
	int carry,d

	case m
	when 0 then
		p^:=0
		return 1
	when 1 then
		memcpy(p,q,plen*elemsize)
		return plen
	esac

	pp:=p+plen-1
	qq:=q+plen-1
	carry:=0

	to plen do
		d:=int64(qq^)*m+carry
		pp^:=d rem digitbase
		carry:=d/digitbase
		--qq
		--pp
	od

	if carry then	 	 	 !need extra digit
		pp:=p+plen
		to plen do
	 	   pp^:=(pp-1)^
	 	   --pp
		od
		pp^:=carry
		++plen
	fi

	return plen
end

export function bn_equal(bignum a,b)int=
	if a^.length<>b^.length or 
	   a^.numtype<>b^.numtype or 
	   a^.neg<>b^.neg or 
	   a^.expon<>b^.expon then
		return 0
	fi

	if a^.length=0 then return 1 fi

	return eqbytes(a^.num,b^.num,a^.length*elemsize)
end

export proc bn_addu(bignum dest,a,b)=
	int preca, precb, precc
	int uppera,upperb,upperc, offset, carry,expona,exponb
	int dc
	word j
	ref[0:]elemtype pa,pb
	ref elemtype pax,pbx
	ref elemtype c,c2

	if a^.expon<b^.expon then	   !A has definite smaller magnitude
		swap(a,b)	 	 	 	!make sure A is always bigger or (approx) equal
	fi

	expona:=a^.expon
	exponb:=b^.expon
	preca:=a^.length
	precb:=b^.length

	offset:=expona-exponb	 	  !for indexing B elements shift to match A
	uppera:=preca-1
	upperb:=precb-1

	if uppera>(upperb+offset) then  !A defines overall precision; B contained within A
		upperc:=uppera
	else	 	 	 	 		!B extends overall precision
		upperc:=upperb+offset
	fi
	precc:=upperc+1

	c:=makesmallnum(precc)	 	 !no space for carry
	carry:=0
	pa:=a^.num
	pb:=b^.num

	for i:=upperc downto 0 do	 	  !do the add, starting from ls digit

		j:=i-offset	 	 	 	  !index of A/C in terms of B
		if i<=uppera and j<=word(upperb) then
	 	   dc:=pa^[i]+pb^[j]+carry
		elsif i<=uppera then
	 	   dc:=pa^[i]+carry
		elsif j<=word(upperb) then
	 	   dc:=pb^[j]+carry
		else
	 	   dc:=carry
		fi

		if dc>=digitbase then
	 	   carry:=1
	 	   (c+i)^:=dc-digitbase
		else
	 	   (c+i)^:=dc
	 	   carry:=0
		fi
	od

	if carry then
		c2:=makesmallnum(precc+1)
		c2^:=carry
		memcpy(c2+1,c,precc*elemsize)
		freesmall(c,precc)
		c:=c2
		++precc
	fi

	smalltobig(dest,c,precc,precc)

	dest^.expon:=expona+carry
end

proc bn_subu(bignum dest,a,b)=
	int preca, precb, precc
	int uppera,upperb,upperc, offset, carry, expona
	int da,db,dc, isneg, z, newprec,diff
	word j
	ref[0:]elemtype pa,pb
	ref elemtype c

	isneg:=0
	if a^.expon<b^.expon then	   !A has definite smaller magnitude
		swap(a,b)	 	 	 	!make sure A is always bigger or (approx) equal
		isneg:=1
	fi

retry::
	expona:=a^.expon
	preca:=a^.length
	precb:=b^.length

	offset:=expona-b^.expon	 	!for indexing B elements shift to match A
	uppera:=preca-1
	upperb:=precb-1

	if uppera>(upperb+offset) then  !A defines overall precision; B contained within A
		upperc:=uppera
	else	 	 	 	 		!B extends overall precision
		upperc:=upperb+offset
	fi
	precc:=upperc+1

	c:=makesmallnum(precc)
	carry:=0
	pa:=a^.num
	pb:=b^.num

	for i:=upperc downto 0 do	 	  !do the add, starting from ls digit
		j:=i-offset	 	 	 	  !index of A/C in terms of B
		if i<=uppera and j<=word(upperb) then

	 	   diff:=pa^[i]-pb^[j]-carry
		elsif i<=uppera then
	 	   diff:=pa^[i]-carry
		elsif j<=word(upperb) then
	 	   diff:=-pb^[j]-carry
		else
	 	   diff:=-carry
		fi

		if diff<0 then
	 	   carry:=1
	 	   (c+i)^:=diff+digitbase
		else
	 	   (c+i)^:=diff
	 	   carry:=0
		fi
		
	od

	if carry then
		if isneg then	 	  !already swapped
	 	   bn_error("SUBU/CARRY")
		fi
		swap(a,b)
		isneg:=1
		freesmall(c,precc)
		goto retry
	fi

	smalltobig(dest,c,precc,precc)
	dest^.neg:=isneg
	dest^.expon:=expona-stblz

end

proc bn_mulu(bignum dest, a,b) =


	int uppera, upperb, upperc
	int precc,expona,exponb
	int ax,bx,cx		!indices within a,b,c
	int i,cx1, nc2
	i64 p,carry,x
	bignum d
	ref elemtype c
	i64 pdquot,pdrem

	expona:=a^.expon
	exponb:=b^.expon
	uppera:=a^.length-1
	upperb:=b^.length-1

	precc:=uppera+upperb+2
	nc2:=precc

	c:=makesmallnum(nc2)
	memset(c,0,precc*elemsize)
	cx:=precc-1

	for bx:=upperb downto 0 do
		carry:=0

		cx1:=cx
		for ax:=uppera downto 0 do
	 	   p:=i64((a^.num^[ax]))*i64((b^.num^[bx]))+carry
	 	   pdquot:=p/digitbase
	 	   x:=int64((c+cx1)^)+p rem digitbase
	 	   if x>digitmax then
	 	 	  carry:=pdquot+x/digitbase
	 	 	  (c+cx1--)^:=x rem digitbase
	 	   else
	 	 	  carry:=pdquot
	 	 	  (c+cx1--)^:=x
	 	   fi

		od
		(c+cx1)^:=carry
		--cx	 	 	  !for next row, start at next column in dest
	od

	smalltobig(dest,c,precc,nc2)
	dest^.expon:=expona+exponb+1-stblz

end

function smalldiv(ref elemtype x, b, int &xlen, nb)int =

	int k,count
	int64 xx,y
	elemtype xi,bi
	ref elemtype e
	int esize,ne,nx

	nx:=xlen
	k:=0
	count:=0
	e:=makesmallnum(esize:=(nb+1))

	do
		if nx<nb then	 	 	 !completed this k
	 	   exit
		elsif nx>nb then	 	   !x will be at most 1 digit wider than b
	 	   xx:=int64(x^)*digitbase+int64((x+1)^)
	 	   y:=xx/(b^+1)
		else	 	 	 	 	 	   !x,b are same length
	 	   if x^>=(b^+1) then
	 	 	  y:=x^/(b^+1)
	 	   else
	 	 	  y:=1
	 	 	  for i:=0 to nb-1 do
	 	 	 	 xi:=(x+i)^
	 	 	 	 bi:=(b+i)^
	 	 	 	 if xi<bi then
	 	 	 	 	y:=0
	 	 	 	 	exit all
	 	 	 	 elsif xi>bi then
	 	 	 	 	exit
	 	 	 	 fi
	 	 	  od

	 	   fi
		fi
		k+:=y
		if y>1 then
	 	   ne:=smallmulto(e,b,nb,y)
	 	   nx:=smallsubto(x,e,nx,ne)
		elsif y then
	 	   nx:=smallsubto(x,b,nx,nb)
		else
	 	   BN_ERROR("smalldiv:Y=0")
		fi
	od

	freesmall(e,esize)
	xlen:=nx	 	 	 	 !return modified x, and new length of x
	return k
end

export proc bn_idivu(bignum dest,a,b,rm=nil)=

	ref elemtype c,x,e
	int expona, exponb, badjust, exponc
	int na,nb,nc,nx,ne,nx2,ne2, cx,nupper
	int uppera, upperb, upperc
	int n, k, nexta
	int64 xx,y
	ref elemtype pa,pb

	na:=a^.length
	nb:=b^.length
	expona:=a^.expon
	exponb:=b^.expon
	badjust:=exponb+1-nb

	if na>expona+1 or nb>exponb+1 then
		bn_error("idivu:a or b not int")
	fi
	nc:=expona+1

	if expona<exponb then
		bn_setzero(dest)
		if  rm then
	 	   bn_dupl(rm,a)
		fi
		return
	fi

	uppera:=na-1
	upperb:=nb-1
	upperc:=nc-1
	pa:=cast(a^.num)
	pb:=cast(b^.num)	 	   !p is not zero, and all digits of interest are present

	n:=nb	 	 	 	!n is also how many digits of a we're into so far
	x:=makesmallnum(nx2:=n+1)	   !allow one extra digit
	nx:=n	 	 	 	 	   !current x size
	nupper:=nc-badjust

	for i:=0 to upperb do
		if i<=uppera then
	 	   (x+i)^:=(pa+i)^
		else
	 	   (x+i)^:=0
		fi
	od

	c:=makesmallnum(nc)
	cx:=0

	do
		k:=smalldiv(x,pb,nx,nb)

		(c+cx++)^:=k
		if n>=nupper then	 	 	 	!finished with A 
	 	   exit
		fi

		nexta:=(n>uppera|0|(pa+n)^)
		++n
		if nx=1 and x^=0 then
	 	   x^:=nexta	 	 	 !x is 1 digit long
		else
	 	   (x+nx)^:=nexta	 	 !next digit from a
	 	   ++nx
		fi
	od

	if rm and exponb<nb then		!no trailing zeros in b
		smalltobig(rm,x,nx,nx2)
	else
		freesmall(x,nx2)
	fi

	if cx=1 and c^=0 then
		freesmall(c,nc)
		bn_setzero(dest)
		if rm then
	 	   bn_dupl(rm,a)
		fi
		return
	fi

	if c^=0 and cx>=2 then	 	 	!leading zero (may not need cx check)
		smalltobig(dest,c+1,cx-1,nc,-1)
	else
		smalltobig(dest,c,cx,nc)
	fi

	if rm and exponb>=nb then	 	  !has trailing zeros so natural rem doesn't work
		bignum d
		d:=bn_init()
		bn_mulu(d,b,dest)
		bn_subu(rm,a,d)
		bn_free(d)
	fi

end

function strvaln(ref char s,int n)int=	  !STRVALN
	int a

	a:=0
	to n do
		if s^<>'_' then
	 	   a:=a*10+s^-'0'
		fi
		++s
	od
	return a
end

export function bn_makestr(ichar s, int length=0)bignum=
	ichar t,u
	int neg,dpindex,expon,nonzeros,talloc,dpseen
	int leadingzeros, trailingzeros,zerosafterdp
	int d,n,wd,dp,wdp,w,d2,na,nb
	bignum a

	if length=0 then
		length:=strlen(s)
	fi
	if length<=0 then
		return badnumber()
	fi
	talloc:=length+1+10	 	!allow for extending last wdigit group

	neg:=0
	case s^
	when '+' then ++s
	when '-' then neg:=1; ++s
	esac

	t:=u:=bn_alloc(talloc)	  !accummulate sig digits into t
	dpindex:=-1
	dpseen:=zerosafterdp:=0
	nonzeros:=0
	leadingzeros:=trailingzeros:=0
	expon:=0

	doswitch s^
	when '1'..'9' then
		u++^:=s++^
		trailingzeros:=0
		nonzeros:=1
	when '0' then
		if nonzeros then
	 	   ++trailingzeros
	 	   u++^:=s++^
		else
	 	   ++leadingzeros
	 	   if dpseen then
	 	 	  ++zerosafterdp
	 	   fi
	 	   ++s
		fi
	when '_', '\'', '`', ' ',13,10 then
		++s
	when '.' then
		if dpseen or dpindex>=0 then return badnumber() fi
		if nonzeros then
	 	   dpindex:=u-t
		else
	 	   dpseen:=1
		fi
		++s
	when 0 then
		exit
	when 'e','E' then
		expon:=readexpon(s+1)
		exit
	else
		return badnumber()
	end doswitch

	u^:=0
	length:=u-t	 	 	   !new length of extracted digits
	if dpindex<0 then
		if dpseen then
	 	   dpindex:=-zerosafterdp
		else
	 	   dpindex:=length
		fi
	fi
	length-:=trailingzeros	  !adjust precision to ignore trailing zeros
	(t+length)^:=0

	if length=0 then
		return bn_makeint(0)
	fi

	d:=dpindex-1+expon
	n:=length
	dp:=0
	na:=1
	nb:=n-na

	w:=digitwidth

	if d>=0 then
		wd:=d/w
		wdp:=d rem w
	else
		d2:=abs(d+1)
		wd:=-(d2/w+1)
		wdp:=w-1-(d2 rem w)
	fi

	na:=wdp+1
	nb:=max(n-na,0)
	while nb rem w do ++nb od
	length:=nb/w+1
	u:=t+n
	to na+nb-n do
		u++^:='0'
	od
	n:=na+nb
	(t+n)^:=0

	a:=makebignum(length)
	a^.neg:=neg
	a^.expon:=wd
	u:=t
	a^.num^[0]:=strvaln(u,na)
	u+:=na
	
	for i:=1 to length-1 do
		a^.num^[i]:=strvaln(u,w)
		u+:=w
	od

	freemem(t,talloc)

	return a
end

proc bn_fdivu(bignum dest,a,b,int precision)=

	ref elemtype c,x,e
	int expona, exponb, badjust, exponc
	int na,nb,nc,nx,ne,nx2,ne2, cx,nupper,nc2
	int uppera, upperb, upperc
	int n, k, nexta
	int64 xx,y
	ref elemtype pa,pb

	na:=a^.length
	nb:=b^.length
	expona:=a^.expon
	exponb:=b^.expon

	if precision then
		precision:=((precision-1)/digitwidth+1)	 	!must be multiple of digitwidth
	else
		precision:=currprec
	fi
	nc:=precision

	uppera:=na-1
	upperb:=nb-1
	upperc:=nc-1
	pa:=cast(a^.num)
	pb:=cast(b^.num)	 	   !p is not zero, and all digits of interest are present

	n:=nb	 	 	 	!n is also how many digits of a we're into so far
	x:=makesmallnum(nx2:=n+1)	   !allow one extra digit
	nx:=n	 	 	 	 	   !current x size

	for i:=0 to upperb do
		if i<=uppera then
	 	   (x+i)^:=(pa+i)^
		else
	 	   (x+i)^:=0
		fi
	od

	c:=makesmallnum(nc2:=nc+1)
	cx:=0

	do
		k:=smalldiv(x,pb,nx,nb)

		(c+cx++)^:=k

		if cx>nc then	 	 	 !reached given precision
	 	   exit
		fi

		nexta:=(n>uppera|0|(pa+n)^)
		++n
		if nx=1 and x^=0 then
	 	   x^:=nexta	 	 	 !x is 1 digit long
		else
	 	   (x+nx)^:=nexta	 	 !next digit from a
	 	   ++nx
		fi
	od

	freesmall(x,nx2)

	if cx=1 and c^=0 then
		freesmall(c,nc2)
		bn_setzero(dest)
		return
	fi

	if c^=0 and cx>=2 then	 	 	!leading zero (may not need cx check)
		smalltobig(dest,c+1,cx-1,nc2,-1)
		dest^.expon:=expona-exponb-1
	else
		smalltobig(dest,c,cx,nc2)
		dest^.expon:=expona-exponb
	fi
end

function tostring_float(bignum a,int fmt)ichar=
	int expon,upper,nchars,w,prel,n,showdot
	ichar s,t

	expon:=a^.expon
	upper:=a^.length-1

	if fmt='I' and bn_isint(a) then
		showdot:=0
	else
		showdot:=1
	fi

	w:=digitwidth
	nchars:=3	 	 	 !sign and trailing .0
	if expon<0 then
		nchars+:=abs(expon-1)*w
	fi
	nchars+:=a^.length*w
	if expon-upper>0 then
		nchars+:=(expon-upper)*w
	fi
	nchars+:=8	 	 		!margin

	s:=t:=checkedmalloc(nchars)
	
	if a^.neg then
		t++^:='-'
	fi

	prel:=0
	if expon<0 then
		prel:=1
		t++^:='0'
		t++^:='.'
		to abs(expon)-1 do
	 	   to digitwidth do
	 	 	  t++^:='0'
	 	   od
		od
	fi

	for i:=0 to upper do
		n:=sprintf(t,(i>0 or prel|digitfmt|"%d"),a^.num^[i])
		t+:=n
		if expon=i and i<upper and showdot then
	 	   t++^:='.'
		fi
	od

	to expon-upper do
		to digitwidth do
	 	   t++^:='0'
		od
	od
	if expon>=upper and showdot then
		t++^:='.'
		t++^:='0'
	fi

	t^:=0
	return s
end

export function bn_tostring(bignum a,int fmt=0)ichar=
	int expon,upper
	ichar s,t

	t:=nil
	if a=nil then
		t:="<void>"
	else
		case a^.numtype
		when zero_type then t:=(fmt='E' or fmt='F'|"0.0"|"0")
		when inf_type then t:="<inf>"
		when nan_type then t:="<nan>"
		esac
	fi

	if t then
		s:=checkedmalloc(strlen(t)+1)
		strcpy(s,t)
		return s
	fi

	if fmt=0 or fmt='A' then
		if bn_isint(a) and (a^.expon-a^.length)*digitwidth<60 then
	 	   fmt:='I'
		elsif abs(a^.expon*digitwidth)<60 then
	 	   fmt:='F'
		else
	 	   fmt:='E'
		fi
	fi

	if fmt='E' then
		s:=tostring_scient(a)
	else
		s:=tostring_float(a,fmt)
	fi
	return s
end

function tostring_scient(bignum a)ichar=
	ichar s,t
	int expon,nchars,n,shift
	int64 x,scale

	nchars:=3

	expon:=a^.expon*digitwidth

	x:=a^.num^[0]
	scale:=1
	shift:=0
	while x>=10 do
		x:=x/10
		scale*:=10
		++expon
		++shift
	od

	nchars:=a^.length*digitwidth+16	 !allow for 1., and exponent

	s:=t:=checkedmalloc(nchars)

	if a^.neg then
		t++^:='-'
	fi

	print @t,x,,"."
	t+:=strlen(t)

	if shift then
		print @t, shift:"v",,a^.num^[0]-x*scale:"z*"
		t+:=strlen(t)
	fi

	for i to a^.length-1 do
		print @t,a^.num^[i]:mdigitfmt
		t+:=strlen(t)
	od

	while (t-1)^='0' and (t-2)^<>'.' do
		--t
	od

	print @t,"e",,expon
	t+:=strlen(t)
	t^:=0

	return s
end

export function bn_add(bignum dest,a,b)int=
	int nega,negb

	switch getbintype(a,b)
	when nn_types then
	when zz_types then
		bn_setzero(dest)
		return 1
	when nz_types then
		bn_dupl(dest,a)
		return 1
	when zn_types then
		bn_dupl(dest,b)
		return 1
	else
		bn_setnan(dest)
		return 0
	end switch

	nega:=a^.neg
	negb:=b^.neg

	if not nega and not negb then	   !both positive
		bn_addu(dest,a,b)
	elsif nega and negb then	 	   !both negative
		bn_addu(dest,a,b)
		bn_negto(dest)
	elsif not nega and negb then		!a positive, b negative
		bn_subu(dest,a,b)
	else
		bn_subu(dest,b,a)	 	 	 !a negative, b positive
	fi

	return 1
end

export function bn_sub(bignum dest,a,b)int=
	int nega,negb

	switch getbintype(a,b)
	when nn_types then
	when zz_types then
		bn_setzero(dest)
		return 1
	when nz_types then
		bn_dupl(dest,a)
		return 1
	when zn_types then
		bn_dupl(dest,b)
		bn_negto(dest)
		return 1
	else
		bn_setnan(dest)
		return 0
	end switch

	nega:=a^.neg
	negb:=b^.neg

	if not nega and not negb then	   !both positive
		bn_subu(dest,a,b)
	elsif nega and negb then	 	   !both negative
		bn_subu(dest,b,a)
	elsif not nega and negb then		!a positive, b negative
		bn_addu(dest,a,b)
	else	 	 	 	 	 	   !a negative, b positive
		bn_subu(dest,b,a)
	fi

	return 1
end

export function bn_mul(bignum dest,a,b)int=
	int neg

	switch getbintype(a,b)
	when nn_types then
	when zz_types,nz_types,zn_types then
		bn_setzero(dest)
		return 1
	else
		bn_setnan(dest)
		return 0
	end switch

	neg:=a^.neg<>b^.neg
	bn_mulu(dest,a,b)
	if neg then	 !different signs
		bn_negto(dest)
	fi
	return 1
end

export function bn_mulp(bignum dest,a,b, int prec)int=
	int res:=bn_mul(dest,a,b)
	if res then
		bn_setprec(dest,(prec=0|currprec|prec))
	fi
	return res
end

export function bn_div(bignum dest,a,b,int prec=0)int=
	int neg

	switch getbintype(a,b)
	when nn_types then
	when zn_types then
		bn_setzero(dest)
		return 1
	when zz_types,nz_types then
		bn_setinf(dest)
		return 0
	else
		bn_setnan(dest)
		return 0
	end switch

	neg:=a^.neg<>b^.neg

	bn_fdivu(dest,a,b,prec)

	if neg then
		bn_negto(dest)
	fi
	return 1
end

export function bn_idiv(bignum dest,a,b)int=
	int neg
	switch getbintype(a,b)
	when nn_types then
	when zn_types then
		bn_setzero(dest)
		return 1
	when zz_types,nz_types then
		bn_setinf(dest)
		return 0
	else
		bn_setnan(dest)
		return 0
	end switch

	neg:=a^.neg<>b^.neg
	bn_idivu(dest,a,b)
	if neg then
		bn_negto(dest)
	fi
	return 1
end

export function bn_idivrem(bignum dest,rm,a,b)int=
	int nega,negb

	switch getbintype(a,b)
	when nn_types then
	when zn_types then
		bn_setzero(dest)
		bn_setzero(rm)
		return 1
	when zz_types,nz_types then
		bn_setinf(dest)
		bn_setzero(rm)
		return 0
	else
		bn_setnan(dest)
		return 0
	end switch

	nega:=a^.neg
	negb:=b^.neg
	bn_idivu(dest,a,b,rm)
	if nega<>negb then	  !different signs
		bn_negto(dest)
	fi
	if nega then bn_negto(rm) fi
	return 1
end

export function bn_irem(bignum dest,a,b)int=
	bignum rm,d
	int nega

	switch getbintype(a,b)
	when nn_types then
	when zn_types then
		bn_dupl(dest,b)
		return 1
	when zz_types,nz_types then
		bn_setinf(dest)
		bn_setzero(dest)
		return 0
	else
		bn_setnan(dest)
		return 0
	end switch

	nega:=a^.neg
	d:=bn_init()
	bn_idivu(d,a,b,dest)
	if nega then bn_negto(dest) fi
	bn_free(d)
	return 1
end

export function bn_cmp(bignum a,b)int=
	bignum d
	int neg

	if bn_equal(a,b) then
		return 0
	fi

	d:=bn_init()
	bn_sub(d,a,b)
	neg:=d^.neg
	bn_free(d)
	return (neg|-1|1)
end

export function bn_const(int value)bignum =
	ref constrec p
	bignum c

	p:=constlist

	while p do
		if p^.value=value then
	 	   return p^.bnvalue
		fi
		p:=p^.nextconst
	od

	p:=bn_alloc(constrec.bytes)
	p^.bnvalue:=bn_makeint(value)
	p^.value:=value
	p^.nextconst:=constlist
	constlist:=p
	return p^.bnvalue
end

export function bn_sign(bignum a)int=
	if bn_iszero(a) then
		return 0
	elsif a^.neg then
		return -1
	else
		return 0
	fi
end

function badnumber:bignum=
	bignum c
	c:=makebignum(0)
	c^.numtype:=nan_type
	return c
end

export function bn_digits(bignum a)int=
	int n
	[32]char str

	if not bn_isint(a) then
		return 0
	fi
	if bn_iszero(a) then
		return 1
	fi

	n:=sprintf(&.str,"%d",a^.num^[0])
	return n+a^.expon*digitwidth
end

export function bn_toint(bignum a)int64=
	int64 x
	if not bn_isint(a) then
		return 0
	fi
	if bn_iszero(a) then
		return 0
	fi

	x:=0
	for i:=0 to a^.length-1 do
		x:=x*digitbase+a^.num^[i]
	od

	if a^.neg then
		return -x
	else
		return x
	fi
end

export function bn_tofloat(bignum a)real64=
	real64 x
	ichar s

	if bn_iszero(a) then
		return 0.0
	fi

	s:=bn_tostring(a,'E')

	sscanf(s,"%lf", &x)
	return x
end

export proc bn_fix(bignum c, a) =
	if bn_iszero(a) or a^.expon<0 then
		bn_setzero(c)
		return
	fi

	bn_dupl(c,a)
	if not bn_isint(c) then
		bn_setprec(c,(c^.expon+1))
	fi
end
=== pc_print.m 17/56 ===
import clib
import msys
import mlib
import oslib

import pc_types
import pc_decls
import pq_common
import pc_support
import pc_objlib
import pc_bignum
import pc_pcfns

global  int mindev		!one of stdio/fileio/strio/windio
global  int moutdev
global  ref int minchan		!actual file handles
global  filehandle moutchan
global  varrec minvar		!strio: vars to be used as source or dest
global  varrec moutvar		!str: used for sprint(=string) and @&.string (=refvar)
global  ichar mfmtstr		!used for format string is nil (no fmt string) or points to fmt string
global  ichar mfmtcurr	!point to next char to use in fmtstr
global  fmtrec defaultfmt = (0,0, 10, 0,' ','f', 0,0,0,'R',0,0, 0,0,(0,0))
global  filehandle testfilech	!non-zero means contains handle for test file o/p

global const std_io	= 0		!console i/o
global const file_io	= 1		!uses file channel inchan or outchan
global const str_io	= 2		!uses string instr^ or outstr^
global const wind_io	= 3		!uses window inwind^ or outwind^
global const istr_io	= 4		!used by pcx interpreter

const maxstrlen=256

const onesixty=1024
const comma=','

const maxoclevel=6
[0:maxoclevel]int32	moutdevstack
[0:maxoclevel]filehandle	moutchanstack
[0:maxoclevel]varrec	moutvarstack
[0:maxoclevel]byte	mgapstack
[0:maxoclevel]ref char	mfmtstrstack
[0:maxoclevel]ref char	mfmtcurrstack
int noclevels
byte mgapneeded

const maxlistdepth=4
int listdepth=0		!recursive nesting levels for lists/records

[0:]char digits=('0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F')

const minkb_size=262144		! start size of kb buffer
ref char kb_start		! point to start of read buffer
ref char kb_pos			! current position it's up to (next read starts here)
ref char kb_lastpos		! set by sread() just before reading used for reread()
int kb_size			! total available length of entire read buffer (which is not zero-terminated)
int kb_linelength		! length of this current line (set by readln)
int kb_length			! length of current contents of buffer (can be zero)
				! use kb_length-(kb_pos-kb_start) for length starting from kb_pos
int kb_lastlength		! used with kb_lastpos to remember start of last read item
char termchar		! terminator char set by readxxx()
int itemerror			!	set by some read functions, eg for reals

global proc pch_print(variant p,fmt=nil) =		!PC_PRINT
[0:onesixty]char str
varrec v
varrec emptyfmt


if fmt=nil then
	fmt:=&emptyfmt
	emptyfmt.tagx:=tvoid
fi

if mfmtstr=nil then
	if mgapneeded then
		printstr_n(" ",1)
	else
		mgapneeded:=1
	fi
else
	printnextfmtchars(0)
fi

switch ttbasetype[p^.tag]
when tstring then
	if fmt=nil or fmt^.tag=tvoid then
		printstr_n(cast(p.objptr.ustr.strptr),p.objptr.ustr.length)
		return
	fi
when tint, treal, trange, tword then	! small numeric types: use local string
	pch_tostr(p,fmt,&v)
	printstr_n(v.objptr.ustr.strptr,v.objptr.ustr.length)
	pc_unshare(&v)
	return
endswitch

pch_tostr(p,fmt,&v)

printstr_n(v.objptr.ustr.strptr,v.objptr.ustr.length)

pc_unshare(&v)

end

global proc pch_println =		!PC_PRINTLN
	if mfmtstr then
		printnextfmtchars(1)
	fi
	printstrz("\r\n")
end

global proc pch_startprintcon =		!PC_STARTPRINTCON
	varrec v

	v.tagx:=tint
	v.value:=0
	pch_startprint(&v)
end

global proc pch_startprint(variant p) =
object s

switch ++noclevels
when 0, 1 then		! no action needed

when maxoclevel+1 then		! overflow
	printerror("print #x overflow")
else
	moutdevstack[noclevels-1]:=moutdev
	moutchanstack[noclevels-1]:=cast(moutchan)
	moutvarstack[noclevels-1]:=moutvar
	mfmtstrstack[noclevels-1]:=mfmtstr
	mfmtcurrstack[noclevels-1]:=mfmtcurr
	mgapstack[noclevels-1]:=mgapneeded
endswitch

mfmtstr:=nil
mfmtcurr:=nil

if p=nil then
	goto doconsole
fi
switch p^.tag
when tint then
	switch p^.value
	when 0 then
doconsole::
		moutdev:=std_io
		moutchan:=nil
	
	when 1 then			! special sprint string
		moutdev:=str_io
		moutchan:=nil
		moutvar.tagx:=tstring ior hasrefmask

		s:=obj_new(tstring)
		s.ustr.mutable:=1
		moutvar.objptr:=s

	when 2 then
		if testfilech=nil then
			prterror("@2: file not open")
		fi
		moutdev:=file_io
		moutchan:=testfilech
	
	else
		moutdev:=file_io
		moutchan:=cast(filehandle(p^.value))
	endswitch

when trefvar then
	p:=p^.varptr
	switch p^.tag
	when tstring then
		moutdev:=istr_io
		moutchan:=nil
		moutvar.tagx:=trefvar
		moutvar.varptr:=p
	
	else
	PRINTLN ttname[p^.tag]
		prterror("Print@^?")
	endswitch

else
	switch ttbasetype[p^.tag]
	when trecord, tstruct then		! check for specific records
		moutdev:=std_io
	else
	PRINTLN ttname[p^.tag]
		printerror("Can't do startprint...")
	endswitch
endswitch

mgapneeded:=0

end

global proc pch_endprint =		!PC_ENDPRINT
variant p

if mfmtstr then
	printnextfmtchars(1)
fi
switch moutdev
when istr_io then
	p:=moutvar.varptr
endswitch

if mfmtstr<>nil then
	pcm_free(mfmtstr,strlen(mfmtstr)+1)
fi

if --noclevels=-1 then
	printerror("resetoc??")
fi

if noclevels=0 then
	moutdev:=std_io

else			! exit from higher nesting level
	moutdev:=moutdevstack[noclevels]
	moutchan:=cast(moutchanstack[noclevels])
	moutvar:=moutvarstack[noclevels]
	mgapneeded:=mgapstack[noclevels]
	mfmtstr:=mfmtstrstack[noclevels]
	mfmtcurr:=mfmtcurrstack[noclevels]
fi
end

global proc pch_strstartprint =		!PC_STRSTARTPRINT
varrec p

p.tagx:=tint
p.value:=1
pch_startprint(&p)		! do equivalent of @1
end

global proc pch_strendprint(variant dest) =		!PC_STRENDPRINT
if mfmtstr then
	printnextfmtchars(1)
fi
if moutdev<>str_io then
	prterror("STRendPRT/NOT STR")
fi

dest^:=moutvar						!transfer ownership
moutvar.tagx:=tvoid

pch_endprint()
end

global proc pch_setformat(variant p) =		!PC_SETFORMAT
int n
ref char s

if p.tag<>tstring then
	prterror("(str)")
fi
if mfmtstr then
	prterror("Setfmt?")
fi
n:=p.objptr.ustr.length
mfmtstr:=pcm_alloc(n+1)
if n then
	memcpy(mfmtstr,p.objptr.ustr.strptr,n)
fi
s:=mfmtstr+n
s^:=0
mfmtcurr:=mfmtstr
end

global proc pch_setformat2(variant p) =		!PC_SETFORMAT2
CPL "PC/SETFORMAT2"
end

global proc pch_dprint(variant p, fmt) =		!PC_DPRINT

pch_print(p,fmt)

switch p^.tag
when tint then printstrz("d")
when tword then printstrz("u")
endswitch
end

global proc pch_printnogap =		!PC_PRINTNOGAP
mgapneeded:=0
end

proc initfmtcode(ref fmtrec f) =		!INITFMTCODE
f^:=defaultfmt
end

function i64mintostr(ref char s,int base,int sep)int =		!I64MINTOSTR
[0:onesixty]char t
int i,j,k,g,neg

switch base
when 10 then
	strcpy(&t[0],"9223372036854775808")
	j:=3
when 16 then
	strcpy(&t[0],"8000000000000000")
	j:=1
when 2 then
	strcpy(&t[0],"1000000000000000000000000000000000000000000000000000000000000000")
	j:=7
else
	strcpy(&t[0],"<mindint>")
endswitch

i:=strlen(&t[0])
s+:=i
if sep then
	s+:=j
fi
s^:=0

k:=0
g:=(base=10|3|4)

while i do
	--s
	s^:=t[i-- -1]
	if sep and i and ++k=g then
		--s
		s^:=sep
		k:=0
	fi
od
return strlen(s)
end

function u64tostr(u64 aa,ref char s,word base,int sep)int =		!U64TOSTR
[0:onesixty]char t
int i,j,k,g
int dummy
ref char s0

i:=0
k:=0
g:=(base=10|3|4)

repeat
	t[++i]:=digits[word(aa rem base)]


	aa:=aa/base
	if sep and aa<>0 and ++k=g then
		t[++i]:=sep
		k:=0
	fi
until aa=0

j:=i
s0:=s
while i do
	s^:=t[i--]
	++s
od
s^:=0

return j
end

function i64tostrfmt(i64 aa,ref char s,ref fmtrec fmt,int usigned)int =		!I64TOSTRFMT
[0:onesixty]char str				! allow for binary with separators!
int i,j,k,n,w
static u64 mindint=0x8000'0000'0000'0000

if fmt^.usigned then
	usigned:=1
fi

if aa=mindint and not usigned then		! minint

	str[0]:='-'
	n:=i64mintostr(&str[1],fmt^.base,fmt^.sepchar)+1
else
	if (not usigned and aa<-0) or fmt^.plus then
		if aa<0 then
			aa:=-aa
			str[0]:='-'
		else
			str[0]:='+'
		fi
		n:=u64tostr(aa,&str[1],fmt^.base,fmt^.sepchar)+1
	else
		n:=u64tostr(aa,&.str,fmt^.base,fmt^.sepchar)
	fi
fi

if fmt^.suffix then
	str[n]:=fmt^.suffix
	str[++n]:=0
fi

if fmt^.base>10 or fmt^.suffix and fmt^.lettercase='a'	then	! need lower when
	convlcstring(&.str)
fi

return expandstr(&.str,s,n,fmt)
end

function u64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int =		!U64TOSTRFMT
[0:onesixty]char str				! allow for binary with separators!
int i,j,k,n,w

n:=u64tostr(aa,&.str,fmt^.base,fmt^.sepchar)

if fmt^.suffix then
	str[n]:=fmt^.suffix
	str[++n]:=0
fi

if fmt^.base>10 or fmt^.suffix and fmt^.lettercase='a'	then	! need lower when
	convlcstring(&.str)
fi

return expandstr(&.str,s,n,fmt)
end

function strtostrfmt(ref char s,ref char t,int n,ref fmtrec fmt)int =		!STRTOSTRFMT
ref char u,v
[256]char str
int w,nheap		! whether any heap storage is used # bytes allocated

nheap:=0

if fmt^.quotechar or fmt^.lettercase then		! need local copy
	if n<256 then
		u:=&.str
	else
		nheap:=n+3					! allow for quotes+terminator
		u:=pcm_alloc(nheap)
	fi
	if fmt^.quotechar then
		v:=u
		v^:=fmt^.quotechar
		++v
		if n then
			strcpy(v,s)
			v+:=n
		fi
		v^:=fmt^.quotechar
		++v
		v^:=0
		n+:=2
	else
		memcpy(u,s,n)
	fi
	switch fmt^.lettercase
	when 'a' then	! need lower when
		convlcstring(u)
	when 'A' then
		convucstring(u)
	endswitch
	s:=u
fi

w:=fmt^.minwidth
if w>n then
	n:=expandstr(s,t,n,fmt)
else
	memcpy(t,s,n)
fi
if nheap then
	pcm_free(u,nheap)
fi
return n
end

function expandstr(ref char s,ref char t,int n,ref fmtrec fmt)int =		!EXPANDSTR

int i,w,m

w:=fmt^.minwidth
if w=0 or w<=n then		! allow str to be longer than minwidth
	strncpy(t,s,n)
	(t+n)^:=0
	return n
fi

if fmt^.justify='L' then	! left-justify
	strncpy(t,s,n)
	t+:=n
	for i:=1 to w-n do
		t^:=fmt^.padchar
		++t
	od
	t^:=0
elsif fmt^.justify='R' then
	if fmt^.padchar='0' and fmt^.base and (s^='-' or s^='+') then ! need to move sign outside 
		t^:=s^
		++t
		to w-n do
			t^:=fmt^.padchar
			++t
		od
		strncpy(t,s+1,n-1)
		(t+n-1)^:=0
	else
		to w-n do
			t^:=fmt^.padchar
			++t
		od
		strncpy(t,s,n)
		(t+n)^:=0
	fi

else				! centre-justify?

	m:=(w-n+1)/2
	to m do
		t^:=fmt^.padchar
		++t
	od
	strncpy(t,s,n)
	t+:=n
	to w-n-m do
		t^:=fmt^.padchar
		++t
	od
	t^:=0

fi
return w
end

global proc pc_strtofmt(ref char s,int slen,ref fmtrec fmt) =		!PC_STRTOFMT

int c
byte wset
int n
[0:100]char str

initfmtcode(fmt)

memcpy(&.str,s,slen)		!convert s/slen to zero-terminated string
str[slen]:=0
s:=&.str

wset:=0
while s^ do
	c:=s^
	++s
	switch c
	when 'B', 'b' then fmt^.base:=2
	when 'H', 'h' then fmt^.base:=16
	when 'O', 'o' then fmt^.base:=8
	when 'X', 'x' then
		c:=s^
		if c then
			switch c
			when '2'..'9' then c:=c-'0'
			when '1' then
				++s
				c:=s^
				if c in '0'..'6' then
					c:=c-'0'+10
				fi
			else
				c:=10
			end
			fmt^.base:=c
			++s
		fi

	when 'Q', 'q' then fmt^.quotechar:='"'
	when '~' then fmt^.quotechar:='~'
	when 'J', 'j' then
		fmt^.justify:=toupper(s^)
		if s^ then
			++s
		fi
	when 'A' then fmt^.lettercase:='A'
	when 'a' then fmt^.lettercase:='a'
	when 'Z', 'z' then fmt^.padchar:='0'
	when 'S', 's' then
		fmt^.sepchar:=s^
		if s^ then
			++s
		fi
	when 'P', 'p' then
		fmt^.padchar:=s^
		if s^ then
			++s
		fi
	when 'T', 't' then
		fmt^.suffix:=s^
		if s^ then
			++s
		fi
	when 'U', 'u' then fmt^.usigned:='U'
	when 'E', 'e' then fmt^.realfmt:='e'
	when 'F', 'f' then fmt^.realfmt:='f'
	when 'G', 'g' then fmt^.realfmt:='g'
	when '.' then
		wset:=1
	when comma,'_' then fmt^.sepchar:=c
	when '+' then fmt^.plus:='+'
	when 'M', 'm' then fmt^.charmode:='M'
	when 'C', 'c' then fmt^.charmode:='C'
	when 'Y', 'y' then fmt^.showtype:='Y'
	else
		if c>='0' and c<='9' then
			n:=c-'0'
			do
				c:=s^
				if s^=0 then
					exit
				fi
				if c>='0' and c<='9' then
					++s
					n:=n*10+c-'0'
				else
					exit
				fi
			od
			if not wset then
				fmt^.minwidth:=min(n,onesixty-1)
				wset:=1
			else
				fmt^.precision:=min(n,100)
			fi
		fi
	endswitch
od
end

proc printstrz(ref char s) =		!PRINTSTRZ
type fntype= ref clang function (filehandle f, ichar s,t)int
int x

switch moutdev
when std_io then
	printf("%s",s)

when file_io then
	fprintf(cast(moutchan),"%s",s)

when str_io then
	addstring(moutvar.objptr,s,-1)

when istr_io then
	printstr_n(s,strlen(s))

when wind_io then 

endswitch
end

proc printstr_n(ref char s,int n) =		!PRINTSTRN
variant  p
int x
type fntype= ref clang function (filehandle f, ichar s, int i, ichar t)int

if n=-1 then		! was stringz
	n:=strlen(s)
fi

if n=0 then
	return
fi

switch moutdev
when std_io then

	printstrn_app(s,n,nil)

when file_io then
	printstrn_app(s,n,cast(moutchan))

when str_io then
	addstring(moutvar.objptr,s,n)

when istr_io then
	p:=moutvar.varptr
	if p^.tag<>tstring then
		prterror("prtstrn1")
	fi
	addstring(moutvar.objptr,s,n)

when wind_io then
	
endswitch
end

global proc printerror(ref char s) =		!PRINTERROR
prterror(s)
end

global proc addstring(object p,ref char t,int n) =		!ADDSTRING
int oldlen,newlen,oldbytes,newbytes
ref char newptr

if n=0 or t^=0 then
	return
fi
if n<0 then
	n:=strlen(t)
fi

oldlen:=p.ustr.length

if p.refcount=0 then	! assume a fixed buffer
	if oldlen=0 then		! first string
		memcpy(p.ustr.strptr,t,n)
		p.ustr.length:=n
	else				! append to existing string
		memcpy(p.ustr.strptr+oldlen,t,n)
		p.ustr.length:=oldlen+n
	fi
	return
fi

if oldlen=0 then		! first or only string
	p.ustr.strptr:=pcm_alloc(n)
	p.ustr.length:=n
	p.ustr.allocated:=allocbytes
	memcpy(p.ustr.strptr,t,n)

else				! append to existing string
	newlen:=oldlen+n
	oldbytes:=p.ustr.allocated
	newbytes:=oldlen+n
	if newbytes<=oldbytes then 		! fits in current allocation
		memcpy(p.ustr.strptr+oldlen,t,n)
	else					! need new allocation
		newptr:=pcm_alloc(newbytes)
		memcpy(newptr,p.ustr.strptr,oldlen)	! existing chars
		memcpy(newptr+oldlen,t,n)		! add new chars
		p.ustr.allocated:=allocbytes
		pcm_free(p.ustr.strptr,oldbytes)
		p.ustr.strptr:=newptr
	fi
	p.ustr.length:=newlen
fi
end

global proc j_tostr_i (variant p,fmtstr,ref fmtrec fmt,object dest) =		!PCOP_TOSTR_I
[0:onesixty]char str

switch fmt^.charmode
when 'M' then
	domultichar(ref char(&p^.value),8,&.str,fmt)

when 'C' then
	str[1]:=p^.value
	str[2]:=0

else
	i64tostrfmt(p^.value,&.str,fmt,0)
endswitch

if fmt^.showtype then
	addstring(dest,"I:",2)
fi

addstring(dest,&.str,strlen(&.str))
end

global proc j_tostr_r (variant p,fmtstr,ref fmtrec fmt,object dest) =		!PCOP_TOSTR_R
[0:onesixty]char str,str2
[0:10]char cfmt
int n

cfmt[0]:='%'

if fmt^.precision then
	cfmt[1]:='.'
	cfmt[2]:='*'
	cfmt[3]:=fmt^.realfmt
	cfmt[4]:=0
	sprintf(&.str,&.cfmt,fmt^.precision,p^.xvalue)
else
	cfmt[1]:=fmt^.realfmt
	cfmt[2]:=0
	sprintf(&.str,&.cfmt,p^.xvalue)
fi

n:=strlen(&.str)		! current length
if n<fmt^.minwidth then
	expandstr(&.str,&.str2,n,fmt)
	strcpy(&.str,&.str2)
fi

addstring(dest,&.str,strlen(&.str))
end

global proc j_tostr_w (variant p,fmtstr,ref fmtrec fmt,object dest) =		!PCOP_TOSTR_U
[0:onesixty]char str

switch fmt^.charmode
when 'M' then
	domultichar(ref char(&p^.uvalue),8,&.str,fmt)

when 'C' then
	str[1]:=p^.uvalue
	str[2]:=0

else
	u64tostrfmt(p^.value,&.str,fmt)
endswitch

if fmt^.showtype then
	addstring(dest,"W:",2)
fi

addstring(dest,&.str,strlen(&.str))
end

global proc j_tostr_n (variant p,fmtstr,ref fmtrec fmt,object dest) =		!PCOP_TOSTR_RANGE
[0:onesixty]char str,str2
[0:10]char cfmt
int n
i64tostrfmt(p^.range_lower,&.str,fmt,0)
strcat(&.str,"..")
addstring(dest,&.str,-1)
i64tostrfmt(p^.range_upper,&.str,fmt,0)
addstring(dest,&.str,-1)
end

global proc j_tostr_s (variant p,fmtstr,ref fmtrec fmt,object dest) =		!PCOP_TOSTR_S
int oldlen,newlen
ref char s
[0:100]char str
object q

q:=p.objptr
oldlen:=q.ustr.length
newlen:=oldlen

if fmt.quotechar or fmt.minwidth>newlen then
	if fmt.quotechar then
		newlen+:=2
	fi
	if fmt.minwidth>newlen then
		newlen:=fmt^.minwidth
	fi
	s:=pcm_alloc(newlen+1)
	strtostrfmt(q.ustr.strptr,s,oldlen,fmt)
	addstring(dest,s,newlen)
	pcm_free(s,newlen+1)
else
	addstring(dest,q.ustr.strptr,oldlen)
fi
end

global proc j_tostr_l_m (variant p,fmtstr,ref fmtrec fmt,object dest) =		!PCOP_TOSTR_LIST
variant q
int i,n
char c
object r

++listdepth

r:=p.objptr
if r.refcount<0 or listdepth>maxlistdepth then
	addstring(dest,"...",3)
	--listdepth
	return
fi

addstring(dest,"(",1)

r.refcount:=-r.refcount
q:=r.ulist.vptr

if p.tag=tlist then
	n:=p.objptr.ulist.length
else
	n:=ttlength[p.tag]
fi

for i:=n downto 1 do
	calltostrtable(q,fmtstr,fmt,dest)
	++q
	if i<>1 then
		addstring(dest,",",1)
	fi
od
addstring(dest,")",1)
r.refcount:=-r.refcount
--listdepth
end

global proc j_tostr_a (variant p,fmtstr,ref fmtrec fmt,object dest) =		!PCOP_TOSTR_AX
[0:onesixty]char str
ref byte q
int i,m,elemtype,a,b
varrec v
object pa
ref byte ptr

if fmt=nil then
	fmt:=&defaultfmt
fi

m:=p.tag
pa:=p.objptr

a:=pa.uarray.lower
elemtype:=pa.uarray.elemtag
b:=pa.uarray.length+a-1

q:=pa.uarray.ptr

fprint @&.str,"#[#:#]",ttname[m],pa.uarray.lower,ttname[elemtype]
addstring(dest,&.str,-1)
addstring(dest,"A(",-1)

for i:=a to b do

	pc_loadpacked(q,elemtype,&v,nil)
	q+:=ttsize[elemtype]
	calltostrtable(&v,fmtstr,fmt,dest)
	if i<b then
		addstring(dest,",",1)
	fi
od
addstring(dest,")",1)
end

global proc j_tostr_b (variant p,fmtstr,ref fmtrec fmt,object dest) =		!PCOP_TOSTR_BITS
[0:onesixty]char str
ref char q
int i,m,elemtype,a,b,offset,bitwidthx,n
varrec v
ref byte pbyte
object pa

if fmt=nil then
	fmt:=&defaultfmt
fi

m:=p.tag
pa:=p.objptr

a:=pa.ubits.lower
elemtype:=pa.ubits.elemtag


offset:=pa.ubits.bitoffset

b:=pa.ubits.length+a-1
bitwidthx:=ttbitwidth[elemtype]


addstring(dest,"(",-1)

q:=ref char(pa.ubits.ptr)

for i:=a to b do
	pc_loadbit(cast(q),offset,elemtype,0,&v)
	offset+:=bitwidthx
	if offset>=8 then
		offset:=0
		++q
	fi
	calltostrtable(&v,fmtstr,fmt,dest)
	if i<b then
		addstring(dest,",",1)
	fi
od
addstring(dest,")",1)
end

global proc j_tostr_e (variant p,fmtstr,ref fmtrec fmt,object dest) =		!PCOP_TOSTR_SET
[0:onesixty]char str
variant q
int i,j,first
varrec v
object s

if fmt=nil then
	fmt:=&defaultfmt
fi

addstring(dest,"[",1)

s:=p.objptr

first:=1

i:=0
while (i<s.uset.length) do
	if testelem(cast(s.uset.ptr),i) then	! element i included
		j:=i+1				! now search for end of this '1' block
		while (j<s.uset.length and testelem(cast(s.uset.ptr),j)) do
			++j
		od
		--j				! last '1' in group
		if not first then
			addstring(dest,",",1)
		fi
		first:=0
		if i=j then
			v.tagx:=tint
			v.value:=i
		else
			v.tagx:=trange
			v.range_lower:=i
			v.range_upper:=j
		fi
		calltostrtable(&v,fmtstr,fmt,dest)
		i:=j+1
	else
		++i
	fi
od
addstring(dest,"]",1)
end

global proc j_tostr_k(variant p,fmtstr,ref fmtrec fmt,object dest) =		!POPC_TOSTR_STRUCT
[0:onesixty]char str
byte needcomma
int i,j
int stag,ftype,offset,index
ref byte ptr
varrec v
object pa
ref strec d,f
const int maxfields=100
[maxfields]int fieldtypes
[maxfields]int fieldoffsets
int nfields

if fmt=nil then
	fmt:=&defaultfmt
fi

stag:=p^.tag

	index:=ttstartfield[stag]			!into pcfieldtable[]
	nfields:=ttstructfields[stag]
	for i:=1 to nfields do
		fieldtypes[nfields-i+1]  :=pcfieldtable^[index+i-1].fieldtype
		fieldoffsets[nfields-i+1]:=pcfieldtable^[index+i-1].fieldoffset
	od

pa:=p.objptr

ptr:=pa.ustruct.ptr
addstring(dest,"(",-1)

needcomma:=0

for i:=nfields downto 1 do
	ftype:=fieldtypes[i]
	offset:=fieldoffsets[i]

	pc_loadpacked(ptr+offset,ftype,&v,nil)
	if needcomma then
		addstring(dest,",",1)
	fi
	needcomma:=1

	calltostrtable(&v,fmtstr,fmt,dest)
od
addstring(dest,")",1)
end

global proc j_tostr_j (variant p,fmtstr,ref fmtrec fmt,object dest) =		!PCOP_TOSTR_LONG
int i,w,length,n,onheap,g,k
[0:onesixty+1]char str
[0:onesixty*2+1]char str2
[100]char strtemp
object pp
ref char s,t,u


s:=bx_tostring(P,0)
addstring(dest,s,-1)
free(s)
end

global proc j_tostr_d (variant p,fmtstr,ref fmtrec fmt,object dest) =		!PCOP_TOSTR_DICT
[0:onesixty]char str
variant q
int i,length,needcomma:=0
object pa

if fmt=nil then
	fmt:=&defaultfmt
fi
addstring(dest,"[",-1)

pa:=p.objptr
q:=pa.udict.vptr		!keys/value pairs

length:=pa.udict.length/2				!number of pairs

for i:=length downto 1 do
	if q.tag=tvoid then
		q+:=2
		next
	fi
	if needcomma then
		addstring(dest,",",1)
	fi
	needcomma:=1
	calltostrtable(q,fmtstr,fmt,dest)
	q++
	addstring(dest,":",1)
	calltostrtable(q,fmtstr,fmt,dest)
	q++
od
addstring(dest,"]",1)
end

global proc j_tostr_z (variant a,fmtstr,ref fmtrec fmt,object dest) =		!PCOP_TOSTR_DICT
int i,n,t,u
int cmd
[0:onesixty]char str
variant q
static int nest

switch a^.tag
when tvoid then
	addstring(dest,"<Void>",-1)

when trefpacked then
	fprint @&.str,"Ref #:#",ttname[a^.uref.elemtag],a^.uref.ptr
	addstring(dest,&.str,-1)

when trefbit then
	fprint @&.str,"Refbit #:# @# [*#]",ttname[a^.uref.elemtag],a^.uref.ptr,a^.uref.bitoffset,a^.uref.bitlength
	addstring(dest,&.str,-1)

when trefvar then
	print @&.str,"Refvar:",,a^.varptr
	addstring(dest,&.str,-1)
	if a^.varptr then
		fprint @&.str," <#>",ttname[a^.varptr^.tag]
		addstring(dest,&.str,-1)
	fi

when trecordlink then
	fprint @&.str,"Link:<#>",ttname[a^.uref.elemtag]
	addstring(dest,&.str,-1)

when trefproc then
	print @&.str,"Refproc:",,a.refptr
	addstring(dest,&.str,-1)

when treflabel then
	print @&.str,"Reflabel:",,a^.refptr
	addstring(dest,&.str,-1)

when ttype then
	addstring(dest,"<",1)
	addstring(dest,ttname[a^.value],-1)
	addstring(dest,">",1)

when toperator then
	addstring(dest,"<OP:",-1)
	cmd:=a^.value

	addstring(dest,cmdnames[cmd]+1,-1)
	addstring(dest,(a^.uop.opdims=1|":1"|":2"),2)
	addstring(dest,">",1)

else

	pcustype("tostr_def",a)
endswitch
end

proc printnextfmtchars(int lastx) =		!PRINTNEXTFMTCHARS
char c
ref char pstart
int n

pstart:=mfmtcurr
n:=0

do
	c:=mfmtcurr^
	switch c
	when '#' then
		if lastx then
			goto skip
		fi
		++mfmtcurr
		if n then
			printstr_n(pstart,n)
		fi
		return
	when 0 then
		if n then
			printstr_n(pstart,n)
		elsif not lastx then
			printstr_n("|",1)
		fi
		return
	when '~' then
		if n then
			printstr_n(pstart,n)
			n:=0
		fi
		++mfmtcurr
		c:=mfmtcurr^
		if c then
			++mfmtcurr
			printstr_n(&c,1)
		fi
		pstart:=mfmtcurr
	else
skip::
		++n
		++mfmtcurr
	endswitch
od
end

function getreadfmtcode(variant p)int =		!GETREADFMTCODE
char c

if p=nil or p^.tag=tvoid then
	return 'A'
fi
if p.tag<>tstring then
CPL "P=%s",ttname[p^.tag]
	prterror("Readfmt?")
fi
if p.objptr.ustr.length=0 then
	return 'A'
fi

c:=toupper(p.objptr.ustr.strptr^)

switch c
when 'I', 'R', 'N', 'S', 'F', 'T', 'Z', 'C', 'L', 'H','B','A','E' then
	return c
endswitch

prterror("Readfmt2?")
return 0
end

global proc pch_sreadln(variant dev, variant dest) =		!PC_SREADLN
pch_readln(dev)

pc_makestring(kb_start,kb_length,dest)
end

global proc pch_strtoval(variant p,variant fmt,variant dest) =		!PC_STRVAL
int fmtcode,length
byte oldmutable
object q
[1024]char str
ref char s:=&.str

q:=p.objptr

if q.ustr.length<str.len then
	memcpy(s,q.ustr.strptr,q.ustr.length)
	str[q.ustr.length+1]:=0
else
	pcerror("STRTOVAL/string too long")
fi

fmtcode:=getreadfmtcode(fmt)
if p.tag<>tstring then
	prterror("strval")
fi
length:=p.objptr.ustr.length

switch fmtcode
when 'I' then
	readint(s,length,dest)
when 'R' then
	readreal(s,length,dest)
when 'N' then
	readname(s,length,dest)
when 'S' then
	readstring(s,length,dest)
when 'H' then
	readhex(s,length,dest)
when 'B' then
	readbin(s,length,dest)
when 'A' then
	readany(s,length,dest)
else
	prterror("strval:fmt?")
endswitch
end

global proc pch_reread =		!PC_REREAD
kb_pos:=kb_lastpos
kb_length:=kb_lastlength
end

global proc pch_rereadln =		!PC_REREADLN
kb_pos:=kb_start
kb_length:=kb_linelength
end

function readname(ref char s,int length,variant dest)ref char =		!READNAME
ref char send
ref char itemstr
int itemlength
send:=readitem(s,length,itemstr,itemlength)
pc_makestring(itemstr,itemlength,dest)

iconvlcn(dest.objptr.ustr.strptr,dest.objptr.ustr.length)
return send
end

function readstring(ref char s,int length,variant dest)ref char =		!READSTRING
ref char send
ref char itemstr
int itemlength
send:=readitem(s,length,itemstr,itemlength)
pc_makestring(itemstr,itemlength,dest)
return send
end

function readint(ref char sold,int length,variant dest)ref char =		!READINT
ref char p,s				! s points to ^str
ref char send
ref char itemstr
int itemlength,numlength

send:=readitem(sold,length,s,itemlength)

strtoint(s,itemlength,dest)

return send
end

function readhex(ref char sold,int length,variant dest)ref char =		!READHEX
[0:maxstrlen]char str		! local copy
ref char p,s			! s points to ^str
byte res
i64 aa
int a,t,nalloc
char c

if length=0 then
	dest^.tagx:=tint
	dest^.value:=0
	termchar:=0
	return sold
fi

while (length and (sold^=' ' or sold^=9)) do
	++sold; --length
od

if length<=maxstrlen then	! use local buffer
	s:=&.str
	nalloc:=0
else
	nalloc:=length+1
	s:=pcm_alloc(nalloc)
fi

p:=s				! p points to next char available
while (length) do
	c:=toupper(sold^); ++sold; --length
	if c>='0' and c<='9' then
		p^:=c
		++p
	elsif c>='A' and c<='F' then
		p^:=c
		++p
	elsif c='_' then
	else
		termchar:=c
		exit
	fi
od
p^:=0				! use zero terminator for local string
length:=p-s			! length of s

if length<=16 then
	t:=tint
else
	t:=tbignum
fi
p:=s
switch t
when tint then
	aa:=0
	do
		c:=p^; ++p
		if c=0 then
			exit
		fi
		if c<'A' then			! assume digit '0'..'9'
			aa:=aa*16+c-'0'
		else				! assume letter 'A'..'F'
			aa:=aa*16+(c-'A')+10
		fi
	od
	dest^.tagx:=tint
	dest^.value:=aa
else
	prterror("Readhex/long")
endswitch

if nalloc then
	pcm_free(s,nalloc)
fi

return sold
end

function readbin(ref char sold,int length,variant dest)ref char =		!READBIN
[0:maxstrlen]char str		! local copy
ref char p,s			! s points to ^str
byte res
i64 aa
int a,t,nalloc
char c

if length=0 then
	dest^.tagx:=tint
	dest^.value:=0
	termchar:=0
	return sold
fi

while (length and (sold^=' ' or sold^=9)) do
	++sold; --length
od

if length<=maxstrlen then	! use local buffer
	s:=&.str
	nalloc:=0
else
	nalloc:=length+1
	s:=pcm_alloc(nalloc)
fi

p:=s				! p points to next char available
while (length) do
	c:=toupper(sold^); ++sold; --length
	if c>='0' and c<='1' then
		p^:=c
		++p
	elsif c='_' then
	else
		termchar:=c
		exit
	fi
od
p^:=0				! use zero terminator for local string
length:=p-s			! length of s

if length<=64 then
	t:=tint
else
	t:=tbignum
fi

p:=s
switch t
when tint then
	aa:=0
	do
		c:=p^; ++p
		if c=0 then
			exit
		fi
		aa:=aa*2+c-'0'
	od
	dest^.tagx:=tint
	dest^.value:=aa

else
	prterror("Readbin/long")
endswitch

if nalloc then
	pcm_free(s,nalloc)
fi
return sold
end

function readreal(ref char sold,int length,variant dest)ref char =
[512]char str		! local copy
real x
ref char send
ref char itemstr
int itemlength,numlength

send:=readitem(sold,length,itemstr,itemlength)
strtoreal(itemstr,itemlength,dest)

return send
end

global proc pch_readln(variant dev) =		!PC_READLN
filehandle ch
int length
object pdev

if kb_start=nil then
	kb_start:=pcm_alloc(minkb_size)
	kb_size:=minkb_size
	kb_lastpos:=kb_start
	kb_pos:=kb_start
	kb_length:=0
	kb_lastlength:=0
	kb_linelength:=0
fi

switch dev^.tag
when tvoid then
doconsole::
	readlinen(nil,kb_start,kb_size)	! reads as zero-terminated
	kb_length:=strlen(kb_start)

when tint then
	switch dev^.value
	when 0 then
		goto doconsole
	when 1 then
		if testfilech=nil then
			prterror("R@2: file not open")
		fi
		ch:=cast(testfilech)

	else
		ch:=filehandle(dev^.value)
	endswitch
	pc_readlinen(cast(ch),kb_start,kb_size)			! reads as zero-terminated
	kb_length:=strlen(kb_start)

when tstring then
	pdev:=dev.objptr
	length:=pdev.ustr.length
	if length=0 then
		kb_length:=0
		kb_start^:=0
	elsif length>=kb_size then
		prterror("KB overflow")
	else
		kb_length:=length
		memcpy(kb_start,pdev.ustr.strptr,length)
	fi
else
CPL gettypename(dev.tag)
	prterror("readln@")
endswitch

kb_pos:=kb_start
kb_lastpos:=kb_pos
kb_linelength:=kb_length
end

proc stepkbpos(ref char s) =		!STEPKBPOS
int newlen

newlen:=s-kb_pos

if newlen=0 then		! nothing read probably was at end of buffer
	return
fi
if newlen>=kb_length then	! at end of buffer
	kb_pos:=kb_pos+kb_length	! point to just past buffer (but should never be accessed when kb_length=0)
	kb_length:=0
else
	kb_pos:=kb_pos+newlen
	kb_length-:=newlen
fi
end

global proc pch_sread(variant fmt,variant dest) =		!PC_SREAD
int fmtcode
char c

fmtcode:=getreadfmtcode(fmt)
kb_lastpos:=kb_pos
kb_lastlength:=kb_length

switch fmtcode
when 'I' then
	stepkbpos(readint(kb_pos,kb_length,dest))

when 'R' then
	stepkbpos(readreal(kb_pos,kb_length,dest))

when 'N' then
	stepkbpos(readname(kb_pos,kb_length,dest))

when 'S' then
	stepkbpos(readstring(kb_pos,kb_length,dest))

when 'H' then
	stepkbpos(readhex(kb_pos,kb_length,dest))

when 'B' then
	stepkbpos(readbin(kb_pos,kb_length,dest))

when 'A' then
	stepkbpos(readany(kb_pos,kb_length,dest))

when 'L' then
	if kb_length=0 then
		pc_emptystring(dest)
	else
		pc_makestring(kb_pos,kb_length,dest)
		kb_pos+:=kb_length
		kb_length:=0
	fi

when 'C' then
	if kb_length=0 then
		pc_emptystring(dest)
	else
		termchar:=kb_pos^
dochar::
		dest^.tagx:=tint
		dest^.value:=termchar
		++kb_pos
		--kb_length
	fi

when 'Z' then			! last terminator!
	goto dochar
when 'E' then
	dest^.tagx:=tint
	dest^.value:=itemerror

else
	prterror("SREAD/FMT?")
endswitch
end

proc domultichar (ref char p,int n,ref char dest,ref fmtrec fmt) =		!DOMULTICHAR
[0:20]char str
ref char q
int i,nchars

q:=&.str

nchars:=n

to n do
	if p^=0 then exit fi
	q^:=p^
	++q
	++p
od
q^:=0

expandstr(&.str,dest,nchars,fmt)
end

global proc pch_tostr(variant a, b, result)=
fmtrec fmt
ref fmtrec ifmt
object p

ifmt:=pc_getfmt(b,&fmt)

p:=obj_new(tstring)
p.ustr.mutable:=1

listdepth:=0

calltostrtable(a,b,ifmt,p)

result^.tagx:=tstring ior hasrefmask
result^.objptr:=p
end

global function pc_getfmt(variant p,ref fmtrec fmt)ref fmtrec=

if p=nil or p^.tag=tvoid then
	return &defaultfmt
else
	if p^.tag<>tstring then
		prterror("pc_getfmt/not str?")
	fi
	if p.objptr.ustr.strptr=nil then
		return &defaultfmt
	else
		pc_strtofmt(p.objptr.ustr.strptr,p.objptr.ustr.length,fmt)
		return fmt
	fi
fi
end

proc pc_readlinen(filehandle handlex,ref char buffer,int size) =		!PC_READLINEN
ref char p
int n,x
[0:100]char buff
byte crseen
type fntype=ref clang function (ichar,int32,filehandle)int
int oldpos


buffer^:=0

fgets(buffer,size-2,handlex)

n:=strlen(buffer)
if n=0 then
	return
fi

p:=buffer+n-1		!point to last char
crseen:=0
while (p>=buffer and (p^=13 or p^=10)) do
	if p^=13 or p^=10 then crseen:=1 fi
	p--^ :=0
od


if not crseen and (n+4>size) then
	cpl size,n
	abortprogram("line too long")
    fi
end

function readitem(ref char s,int length,ref char &itemstr,int &itemlength)ref char =		!READSTRING
ref char p
char quotechar, c

while (length and (s^=' ' or s^=9)) do
	++s; --length
od

itemstr:=s				!assume starts here

if length=0 then		! No more chars left to read return null string
	termchar:=0
	itemlength:=0
	return s
fi

quotechar:=0			! Allow possible enclosing single or double quotes
if s^='"' then
	quotechar:='"'
	++s
	--length
elsif s^='\'' then
	quotechar:='\''
	++s
	--length
fi

p:=itemstr:=s

while length do
	c:=s++^; --length
	switch c
	when ' ', 9, comma, '=' then		! separator
		if quotechar or p=s then			!can be considered part of name if inside quotes, or is only char
			goto normalchar
		fi
		termchar:=c
		exit
	else
normalchar::
		if c=quotechar then
			if length and s^=quotechar then	! embedded quote
				p^:=c
				++s
				++p
			else					! end of name
				termchar:=s^
				if termchar=',' or termchar='=' then
					++s
					termchar:=s^
				fi
				exit
			fi
		else
			p^:=c
			++p
		fi
	endswitch
od

if length=0 then
	termchar:=0
fi
itemlength:=p-itemstr				! actual length of token

return s
end

function readany(ref char sold,int length,variant dest)ref char =		!READINT
[0:maxstrlen]char str			! local copy
ref char p,s				! s points to ^str
byte signd,res
i64 aa
int digits,expon,other
int t,nalloc
char c

ref char send
ref char itemstr
int itemlength,numlength

itemerror:=0

send:=readitem(sold,length,s,itemlength)


p:=s
digits:=expon:=other:=0

to itemlength do
	switch p++^
	when '0'..'9','+','-','_' then digits:=1
	when 'E','e','.' then expon:=1
	else other:=1
	end
od

dest^.tagx:=tint

if other or itemlength=0 then
	dest^.value:='STR'
	pc_makestring(s,itemlength,dest)
elsif expon then
	strtoreal(s,itemlength,dest)
else
	strtoint(s,itemlength,dest)
fi

return send
end

proc strtoreal(ichar s,int length,variant dest)=
[512]char str		! local copy
real x
int32 numlength

dest^.tagx:=treal

if length>=str.bytes or length=0 then		!assume not a real
	dest^.xvalue:=0.0
	return
fi
memcpy(&.str,s,length)
str[length+1]:=0

itemerror:=0

if sscanf(&.str,"%lf%n", &x, &numlength)=0 or numlength<>length then
	if numlength=length then x:=0.0 fi
	itemerror:=1
fi

dest^.xvalue:=x
end

proc strtoint(ichar s,int length, variant dest)=
[0:maxstrlen]char str			! local copy
ref char p,q
byte signd
i64 aa
int a,res,cat
int t,nalloc
char c

itemerror:=0

if length=0 then
	dest^.tagx:=tint
	dest^.value:=0
	return
fi

signd:=0
if length and s^='-' then
	signd:=1; ++s; --length
elsif length and s^='+' then
	++s; --length
fi

while s^='0' and length>1 do
	++s; --length
od

p:=q:=s				! p points to next char available

while length do
	c:=q++^
	--length
	if c>='0' and c<='9' then
		p^:=c
		++p
	else
		if c='_' then
		else
			itemerror:=1
			exit
		fi
	fi
od
p^:=0				! use zero terminator for local string
length:=p-s			! length of s


if length<=18 then
	cat:='A'
elsif length=19 then
	case cmpstring(s,"9223372036854775808")
	when -1 then cat:='A'
	when 0 then cat:='B'
	else cat:='C'
	esac
elsif length=20 then
	if cmpstring(s,"18446744073709551615")<=0 then
		cat:='C'
	else
		cat:='D'
	fi
else
	cat:='D'
fi

if signd then
	case cat
	when 'B' then cat:='A'		!-922...808 can be int64
	when 'C' then cat:='D'		!needs longint
	esac
fi


case cat
when 'A' then t:=tint
when 'B','C' then t:=tword
else t:=tbignum
esac

p:=s
if t<>tbignum then
	aa:=0
	do
		c:=p^; ++p
		if c=0 then
			exit
		fi
		aa:=aa*10+(c-'0')
	od
	if signd then
		aa:=-aa
	fi
	dest^.tagx:=t
	dest^.value:=aa

else
	bx_makestr(s,length,dest)
fi
end

proc calltostrtable(variant q, fmtstr,ref fmtrec fmt, object dest)=
varrec v

overloadtype:=q^.tag

if fmtstr^.tag=tvoid then		!replace with ""; force 2 params to be pushed
	pc_emptystring(&v)
	fmtstr:=&v
fi



tostr_table[overloadtype]^(q,fmtstr,fmt,dest)
end

function printbn(variant a0, ref fmtrec fmt,int &length)ichar=
static strbuffer destx
static ref strbuffer dest=&destx
varrec a,b,b10,vbase
int d,base, alen,b10len,n
ref char s

PCERROR("PRINTBN")

RETURN "XXX"
end
=== pc_jhandlers.m 18/56 ===
import msys
import clib
import mlib
import pc_types
import pc_decls
import pq_common
import pc_support
import pc_oslayer
import pc_host
import pc_print
import pc_bignum
import oslib
import pc_objlib
import pc_pcfns
import pc_dxfns

['a'..'z']int32 typemap = (
	tarray,		!'a'
	tbits,		!'b'
	0,			!'c'
	tdict,		!'d'
	tset,		!'e'
	trefproc,	!'f'
	trefdllproc,!'g'
	trecordlink,!'h'
	tint,		!'i'
	tbignum,	!'j'
	tstruct,	!'k'
	tlist,		!'l'
	trecord,	!'m'
	trange,		!'n'
	toperator,	!'o'
	trefpacked,	!'p'
	0,			!'q'
	treal,		!'r'
	tstring,	!'s'
	ttype,		!'t'
	0,			!'u'
	trefvar,	!'v'
	tword,		!'w'
	0,			!'x'
	0,			!'y'
	tvariant)	!'z'

tabledata []ichar tabnames, []ref void singletable, []ref void doubletable =
	("add",			&add_table,			&add_dtable),
	("sub",			&sub_table,			&sub_dtable),
	("mul",			&mul_table,			&mul_dtable),
	("div",			&div_table,			&div_dtable),
	("idiv",		&idiv_table,		&idiv_dtable),
	("rem",			&rem_table,			&rem_dtable),
	("iand",		&iand_table,		&iand_dtable),
	("ior",			&ior_table,			&ior_dtable),
	("ixor",		&ixor_table,		&ixor_dtable),
	("shl",			&shl_table,			&shl_dtable),
	("shr",			&shr_table,			&shr_dtable),
	("min",			&min_table,			&min_dtable),
	("max",			&max_table,			&max_dtable),

	("jumpeq",		&jumpeq_table,		&jumpeq_dtable),
	("jumpne",		&jumpne_table,		&jumpne_dtable),
	("jumplt",		&jumplt_table,		&jumplt_dtable),
	("jumple",		&jumple_table,		&jumple_dtable),
	("jumpge",		&jumpge_table,		&jumpge_dtable),
	("jumpgt",		&jumpgt_table,		&jumpgt_dtable),

	("jumptesteq",	&jumptesteq_table,	nil),
	("jumptestne",	&jumptestne_table,	nil),

	("jumpfalse",	&jumpfalse_table,	nil),
	("jumptrue",	&jumptrue_table,	nil),

	("eq",			&eq_table,			nil),
	("lt",			&lt_table,			nil),
	("le",			&le_table,			nil),

	("concat",		&concat_table,		nil),
	("append",		&append_table,		nil),

	("addto",		&addto_table,		&addto_dtable),
	("subto",		&subto_table,		&subto_dtable),
	("multo",		&multo_table,		&multo_dtable),
	("divto",		&divto_table,		&divto_dtable),
	("idivto",		&idivto_table,		&idivto_dtable),
	("iandto",		&iandto_table,		&iandto_dtable),
	("iorto",		&iorto_table,		&iorto_dtable),
	("ixorto",		&ixorto_table,		&ixorto_dtable),
	("shlto",		&shlto_table,		&shlto_dtable),
	("shrto",		&shrto_table,		&shrto_dtable),
	("minto",		&minto_table,		&minto_dtable),
	("maxto",		&maxto_table,		&maxto_dtable),
	("concatto",	&concatto_table,	nil),
	("appendto",	&appendto_table,	nil),

	("neg",			&neg_table,			nil),
	("abs",			&abs_table,			nil),
	("inot",		&inot_table,		nil),
	("istrue",		&istrue_table,		nil),
	("jumpf",		&jumpf_table,		nil),
	("jumpt",		&jumpt_table,		nil),
	("len",			&len_table,			nil),
	("lwb",			&lwb_table,			nil),
	("upb",			&upb_table,			nil),
	("bounds",		&bounds_table,		nil),

	("incr",		&incr_table,		nil),
	("decr",		&decr_table,		nil),

	("decr",		&decr_table,		nil),
	("free",		&free_table,		nil),
	("dupl",		&dupl_table,		nil),
	("tostr",		&tostr_table,		nil),

	("in",			nil,				&in_dtable),
	("inrev",		nil,				&inrev_dtable),
	("pushix",		nil,				&pushix_dtable),
	("pushixref",	nil,				&pushixref_dtable),
	("pushdotix",	nil,				&pushdotix_dtable),
	("pushdotixref",nil,				&pushdotixref_dtable),

	("convert",		nil,				&convert_dtable),

	("mixed",		nil,				&mixed_dtable)
end

ref[0:]byte mixedmap

global proc initcalltables=
int n,i,j,ttdefault,slen
ref char name
ref void fnaddr
ref[0:]ref void stable, dtable
[0..maxdualtype]byte localmixedmap

mixedmap:=&localmixedmap
memset(mixedmap,0,localmixedmap.bytes)

n:=$get_nprocs()

for i to n do
	name:=$get_procname(i)
	if name^='j' and (name+1)^='_' then		!j_ prefix: assume handler
		initjhandler(name,$get_procaddr(i))
	fi
od

for i to tabnames.len do
	stable:=singletable[i]
	dtable:=doubletable[i]

	if stable then
	    fnaddr:=stable^[0]
		if fnaddr=nil then fnaddr:=&def_handler fi
		for j:=0 to maxtype do
			if stable^[j]=nil then
				stable^[j]:=fnaddr
			fi
		od
	fi
	if dtable then
		fnaddr:=dtable^[0]
		if fnaddr=nil then fnaddr:=&ddef_handler fi
		for j:=0 to maxdualtype do
			if dtable^[j]=nil then
				if localmixedmap[j] then			!generic mixed handler exists
					name:=tabnames[i]
					slen:=strlen(name)
					if eqstring(name+slen-2,"to") then
						goto donormal			!mixed can't deal with ref lhs, andd anyway it can't convert lhs
					fi
					dtable^[j]:=mixed_dtable[j]
				else
donormal::
					dtable^[j]:=fnaddr
				fi
			fi
		od
	fi
od
end

proc initjhandler(ref char p, ref void fnaddr)=
[32]char opname
ref char q
char c,d
int t,u,i
ref[0:]ref void stable, dtable

p+:=2			!skip j_ prefix
q:=p
while q^<>'_' and q^<>0 do
	++q
od
memcpy(&.opname, p, q-p)
opname[q-p+1]:=0

if q^=0 then return fi			!don't report as error; just ignore

for i to tabnames.len do
	if eqstring(tabnames[i],&.opname) then
		stable:=singletable[i]
		dtable:=doubletable[i]
		exit
	fi
else
	loaderror("Init: Can't find Jhandler op:",&.opname)
	stop
od

while q^='_' do
	c:=(++q)^
	if c<'a' or c>'z' then return fi
	d:=(++q)^
	if d>='a' and d<='z' then		!double-dispatch
		++q
	else
		d:=0
	fi

	t:=typemap[c]
	if d then
		u:=typemap[d]
	else
		u:=tvoid
	fi

	if d then

		if dtable=nil then
			loaderror("No d-calltable for:",p-2)
		fi
		add_dtable_entry(cast(dtable),t,u,fnaddr)
	else
		if stable=nil then
			loaderror("No s-calltable for:",p-2)
		fi
		add_stable_entry(stable,t,fnaddr)
	fi
od
end

proc add_stable_entry(ref[0:]ref void table, int t, ref void fnaddr)=
int i
if t=tvariant then t:=0 fi
table^[t]:=fnaddr
end

proc add_dtable_entry(ref[0:]ref function:ref word table, int s,t, ref void fnaddr)=
int i,j,typesig

if s=tvariant then
	typesig:=0
else
	typesig:=gettypesig(s,t)

	if int(table)=int(&mixed_dtable) then			!remember a generic mixed handler exists
		mixedmap^[typesig]:=1
	fi
fi

table^[typesig]:=fnaddr
end

proc def_handler=
pcerror("Single disp: no handler")
end

proc ddef_handler=
pcerror("Double disp: no handler")
end

global function j_add_i_w:ref intpc =
variant y

y:=sptr++
sptr^.value+:=y^.value
return pcptr+1
end

global function j_add_r:ref intpc =
variant y

y:=sptr++
sptr^.xvalue+:=y^.xvalue
return pcptr+1
end

global function j_add_s:ref intpc =
variant x,y
object z
int xlen,ylen,newlen
ref char s

y:=sptr
x:=++sptr

xlen:=x.objptr.ustr.length
ylen:=y.objptr.ustr.length

if xlen=0 then

	if ylen then		!y to top of stack
		sptr^:=y^
	fi					!else use empty y unchanged

elsif ylen=0 then		!x+"" use x unchanged

else 				!x+y: need to do some actual work!
	newlen:=xlen+ylen
	s:=pcm_alloc(newlen)
	memcpy(s,x.objptr.ustr.strptr,xlen)
	memcpy(s+xlen,y.objptr.ustr.strptr,ylen)
	pc_unshare(x)
	pc_unshare(y)
	pc_makestringx(s,newlen,allocbytes,sptr)

fi

return pcptr+1
end

global function j_add_j:ref intpc =  !****************************
variant x,y
varrec result

y:=sptr++
x:=sptr

bx_add(x,y,&result)
pc_unshare(x)
pc_unshare(y)
sptr^:=result
return pcptr+1
end

global function j_add_e:ref intpc =  !********************************
variant x,y

y:=sptr
x:=++sptr
dx_iorset(x,y)
return pcptr+1
end

global function j_add_z:ref intpc =
pcmxtypes("add_def",sptr+1,sptr)
return pcptr+1
end

global function j_add_iw_wi:ref intpc =
variant y

y:=sptr++
sptr^.value+:=y^.value
sptr^.tag:=tint
return pcptr+1
end

global function j_add_zz:ref intpc =
variant y
int yt

y:=sptr++
yt:=y^.tag

switch sptr^.tag
when trefpacked then
	switch (yt)
	when tint then
		sptr^.uref.ptr:=sptr^.uref.ptr+y^.value*ttsize[sptr^.uref.elemtag]
		return pcptr+1
	endswitch
when trefvar then
	switch (yt)
	when tint then
		sptr^.varptr:=sptr^.varptr+y^.value
		return pcptr+1
	endswitch
endswitch

pcmxtypes("add/mixed_def",sptr,y)
return pcptr+1
end

global function j_sub_i_w:ref intpc =
variant y

y:=sptr++
sptr^.value-:=y^.value
return pcptr+1
end

global function j_sub_r:ref intpc =
variant y

y:=sptr++
sptr^.xvalue-:=y^.xvalue
return pcptr+1
end

global function j_sub_p:ref intpc =
variant y
ref byte p,q
int elemsize

y:=sptr++
p:=sptr^.uref.ptr
q:=y^.uref.ptr

case elemsize:=ttsize[sptr^.uref.elemtag]
when 1 then sptr^.value:=p-q
when 2 then sptr^.value:=(p-q)>>1
when 4 then sptr^.value:=(p-q)>>2
else sptr^.value:=(p-q)/elemsize
esac

sptr^.tagx:=tint
return pcptr+1
end

global function j_sub_j:ref intpc =
ref  varrec x,y
varrec result

y:=sptr++
x:=sptr

bx_sub(x,y,&result)
pc_unshare(x)
pc_unshare(y)
sptr^:=result
return pcptr+1
end

global function j_sub_e:ref intpc =
ref varrec x,y
y:=sptr
x:=++sptr
dx_subset(x,y)
return pcptr+1
end

global function j_sub_z:ref intpc =
pcmxtypes("sub_def",sptr+1,sptr)
return pcptr+1
end

global function j_sub_zz:ref intpc =
variant y
int yt

y:=sptr++
yt:=y^.tag

switch sptr^.tag
when trefpacked then
	switch (yt)
	when tint then
		sptr^.uref.ptr:=sptr^.uref.ptr-y^.value*ttsize[sptr^.uref.elemtag]
		return pcptr+1
	endswitch
when trefvar then
	switch (yt)
	when tint then
		sptr^.varptr:=sptr^.varptr-y^.value
		return pcptr+1
	endswitch
endswitch


pcmxtypes("sub/mixed_def",sptr,y)
return pcptr+1
end

function j_mixed_iw_wi:ref intpc=
sptr^.tag:=tint

return opc_tableptr^[tint]^()
end

function j_mixed_ir:ref intpc=
variant x

x:=sptr+1
x^.tag:=treal
x^.xvalue:=x^.value
return opc_tableptr^[treal]^()
end

function j_mixed_ri:ref intpc=
sptr^.tag:=treal
sptr^.xvalue:=sptr^.value
return opc_tableptr^[treal]^()
end

function j_mixed_ij:ref intpc=
bx_makeint((sptr+1)^.value,sptr+1)
return opc_tableptr^[tbignum]^()
end

function j_mixed_ji:ref intpc=
bx_makeint(sptr^.value,sptr)
return opc_tableptr^[tbignum]^()
end

global function j_mul_i_w:ref intpc =
variant y

y:=sptr++
sptr^.value:=sptr^.value*y^.value
return pcptr+1
end

global function j_mul_r:ref intpc =
variant y

y:=sptr++
sptr^.xvalue*:=y^.xvalue
return pcptr+1
end

global function j_mul_j:ref intpc =
ref  varrec x,y
varrec result

y:=sptr++
x:=sptr

bx_mul(x,y,&result)
pc_unshare(x)
pc_unshare(y)
sptr^:=result
return pcptr+1
end

global function j_mul_z:ref intpc =
pcmxtypes("mul_def",sptr+1,sptr)
return pcptr+1
end

global function j_mul_li:ref intpc=
variant x,y
y:=sptr
x:=++sptr

pc_mul_listi(x,y,sptr)

return pcptr+1
end

global function j_mul_si:ref intpc=
variant x,y
y:=sptr
x:=++sptr

pc_mul_stri(x,y,sptr)
return pcptr+1
end

global function j_mul_e:ref intpc =
return j_iand_e()
end

global function j_mul_zz:ref intpc=
pcmxtypes("mul/zz",sptr+1,sptr)
return pcptr+1
end

global function j_div_i:ref intpc =
variant y

y:=sptr++
sptr^.xvalue:=real(sptr^.value)/real(y^.value)
sptr^.tagx:=treal
return pcptr+1
end

global function j_div_r:ref intpc =
variant y

y:=sptr++
sptr^.xvalue:=sptr^.xvalue/y^.xvalue
sptr^.tagx:=treal
return pcptr+1
end

global function j_div_j:ref intpc =
ref  varrec x,y
varrec result

y:=sptr++
x:=sptr

bx_div(x,y,&result)
pc_unshare(x)
pc_unshare(y)

sptr^:=result

return pcptr+1
end

global function j_div_z:ref intpc =
pcmxtypes("div_def",sptr+1,sptr)
return pcptr+1
end

global function j_jumple_i:ref intpc =
if (sptr+1)^.value<=sptr^.value then
	sptr+:=2
	return ref intpc(getopnda)
fi 
sptr+:=2
return pcptr+2
end

global function j_jumple_r:ref intpc =
if (sptr+1)^.xvalue<=sptr^.xvalue then
	sptr+:=2
	return ref intpc(getopnda)
fi 
sptr+:=2
return pcptr+2
end


global function j_jumple_s:ref intpc =
variant x,y
int res
object px,py

y:=sptr++
x:=sptr++

px:=x^.objptr
py:=y^.objptr

res:=cmpstring_len(px.ustr.strptr,py.ustr.strptr,px.ustr.length,py.ustr.length)

pc_unshare(x)
pc_unshare(y)

if res<=0 then
	return ref intpc(getopnda)
fi 
return pcptr+2
end

global function j_jumple_z:ref intpc =
variant x,y
int res

y:=sptr++
x:=sptr++

res:=pc_compare(x,y)
if res<=0 then
	return ref intpc(getopnda)
fi 
return pcptr+2
end

global function j_jumpeq_i_r_t_o:ref intpc =  !************************
if (sptr+1)^.value=sptr^.value then
	sptr+:=2
	return ref intpc(getopnda)
fi 
sptr+:=2
return pcptr+2
end

global function j_jumpeq_v_p_f_g:ref intpc =  !*************************
if (sptr+1)^.refptr=sptr^.refptr then
	sptr+:=2
	return ref intpc(getopnda)
fi 
sptr+:=2
return pcptr+2
end

global function j_jumpeq_s:ref intpc =  !**************************
variant x,y
int res

y:=sptr++
x:=sptr++

res:=pc_eqstring(x,y)
if res then
	return ref intpc(getopnda)
fi
return pcptr+2
end

global function j_jumpeq_z:ref intpc =  !*****************************
int res
variant x,y

y:=sptr++
x:=sptr++

res:=pc_equal(x,y,0)
if res then
	return ref intpc(getopnda)
fi
return pcptr+2
end

global function j_jumpeq_zz:ref intpc =
int res
variant x,y
return j_jumpeq_z()
end

global function j_jumpne_i_r_t_o:ref intpc =
if (sptr+1)^.value<>sptr^.value then
	sptr+:=2
	return ref intpc(getopnda)
fi 
sptr+:=2
return pcptr+2
end

global function j_jumpne_v_p_f_g:ref intpc =
if (sptr+1)^.refptr<>sptr^.refptr then
	sptr+:=2
	return ref intpc(getopnda)
fi 
sptr+:=2
return pcptr+2
end

global function j_jumpne_s:ref intpc =
variant x,y
object px,py
int res,n

y:=sptr++
x:=sptr++
px:=x^.objptr
py:=y^.objptr

res:=0						!assume different

	n:=px.ustr.length

	if n<>py.ustr.length then
	elsif n=0 then
		res:=1					!same zero length
	else
		if cmpstringn(px.ustr.strptr,py.ustr.strptr,n)=0 then
			res:=1
		fi
	fi

pc_unshare(x)
pc_unshare(y)

if res=0 then
	return ref intpc(getopnda)
fi
return pcptr+2
end

global function j_jumpne_z:ref intpc =
int res
variant x,y

y:=sptr++
x:=sptr++

res:=pc_equal(x,y,0)

if not res then
	return ref intpc(getopnda)
fi

return pcptr+2
end

global function j_jumpne_zz:ref intpc =
int res
variant x,y
return j_jumpne_z()
end

global function j_jumpge_i:ref intpc =
if (sptr+1)^.value>=sptr^.value then
	sptr+:=2
	return ref intpc(getopnda)
fi 
sptr+:=2
return pcptr+2
end

global function j_jumpge_w:ref intpc =
if (sptr+1)^.uvalue>=sptr^.uvalue then
	sptr+:=2
	return ref intpc(getopnda)
fi 
sptr+:=2
return pcptr+2
end

global function j_jumpge_r:ref intpc =
if (sptr+1)^.xvalue>=sptr^.xvalue then
	sptr+:=2
	return ref intpc(getopnda)
fi 
sptr+:=2
return pcptr+2
end

global function j_jumpge_z:ref intpc =
variant x,y
int res

y:=sptr++
x:=sptr++

res:=pc_compare(x,y)
if res>=0 then
	return ref intpc(getopnda)
fi 
return pcptr+2
end

global function j_jumpgt_i:ref intpc =
if (sptr+1)^.value>sptr^.value then
	sptr+:=2
	return ref intpc(getopnda)
fi 
sptr+:=2
return pcptr+2
end

global function j_jumpgt_w:ref intpc =
if (sptr+1)^.uvalue>sptr^.uvalue then
	sptr+:=2
	return ref intpc(getopnda)
fi 
sptr+:=2
return pcptr+2
end

global function j_jumpgt_r:ref intpc =
if (sptr+1)^.xvalue>sptr^.xvalue then
	sptr+:=2
	return ref intpc(getopnda)
fi 
sptr+:=2
return pcptr+2
end

global function j_jumpgt_z:ref intpc =
variant x,y
int res

y:=sptr++
x:=sptr++

res:=pc_compare(x,y)
if res>0 then
	return ref intpc(getopnda)
fi 
return pcptr+2
end

global function j_jumplt_i:ref intpc =  !*****************************
if (sptr+1)^.value<sptr^.value then
	sptr+:=2
	return ref intpc(getopnda)
fi 
sptr+:=2
return pcptr+2
end

global function j_jumplt_v_p:ref intpc =  !*****************************
if (sptr+1)^.refptr<sptr^.refptr then
	sptr+:=2
	return ref intpc(getopnda)
fi 
sptr+:=2
return pcptr+2
end

global function j_jumplt_r:ref intpc =  !****************************
if (sptr+1)^.xvalue<sptr^.xvalue then
	sptr+:=2
	return ref intpc(getopnda)
fi 
sptr+:=2
return pcptr+2
end

global function j_jumplt_z:ref intpc =  !*****************************
variant x,y
int res

y:=sptr++
x:=sptr++

res:=pc_compare(x,y)
if res<0 then
	return ref intpc(getopnda)
fi 
return pcptr+2
end

global function j_pushix_li:ref intpc =
object p
varrec va
int index,length,acopy

va:=(sptr+1)^
p:=va.objptr
index:=sptr.value-p.ulist.lower

if u32(index)>=u32(p.ulist.length) then		!bounds error
	pcerror("list[int] bounds")
fi

(++sptr)^:=(p.ulist.vptr+index)^
if sptr^.hasref then
	++(sptr^.objptr.ulist.refcount)
fi
pc_unshare(&va) when va.hasref

return pcptr+1
end

global function j_pushix_mi:ref intpc =
object p
varrec va
int index,length,acopy

va:=(sptr+1)^
p:=va.objptr
index:=sptr.value-1

if u32(index)>=u32(ttlength[va.tag]) then		!bounds error
	pcerror("rec[int] bounds")
fi

(++sptr)^:=(p.urec.vptr+index)^
if sptr^.hasref then
	++(sptr^.objptr.refcount)
fi
pc_unshare(&va) !when va.hasref

return pcptr+1
end

global function j_pushix_vi:ref intpc =
object p
int index,length

index:=sptr^.value
++sptr

(sptr)^:=(sptr^.varptr+index)^

return pcptr+1
end

global function j_pushix_ln:ref intpc =
varrec v

variant a,x
int i,j,alower,ahasref
object p,q

x:=sptr++			!x is the range
a:=sptr				!a is the list
p:=a^.objptr

i:=x.range_lower
j:=x.range_upper

alower:=p.ulist.lower

if i<alower or j>p.ulist.length+alower-1 or i>j then
	pcerror("list/slice bounds")
fi

sptr^.tagx:=tlist ior hasrefmask

q:=obj_new(tlist)
sptr.objptr:=q

q.objtype:=slice_obj
q.ulist.mutable:=p.ulist.mutable
q.ulist.lower:=1

case p.objtype
when slice_obj then				!slice of a slice!
	q.ulist.objptr2:=p.ulist.objptr2		!link to original
	++(q.objptr2.ulist.refcount)
	q.ulist.vptr:=p.ulist.vptr+i-alower
	v.tagx:=tlist ior hasrefmask
	v.objptr:=p
	pc_unshare(&v)
when extslice_obj then
	q.objptr2:=nil
	q.objtype:=extslice_obj
	q.ulist.vptr:=p.ulist.vptr+i-alower
else
	q.ulist.objptr2:=p				!link to original
	q.ulist.vptr:=p.ulist.vptr+i-alower
esac
q.ulist.length:=j-i+1

return pcptr+1
end

global function j_pushix_ll:ref intpc =
junimpl("pushix_listlist")
return pcptr+1
end

global function j_pushix_le:ref intpc =
junimpl("pushix_list_set")
return pcptr+1
end

global function j_pushix_ai:ref intpc =
object p
variant a
int index,length,elemtype
ref byte q
varrec va

va:=(sptr+1)^
p:=va.objptr
index:=sptr.value-p.uarray.lower

if u32(index)>=u32(p.uarray.length) then		!bounds error
	pcerror("ax[int] bounds")
fi

if (elemtype:=p.uarray.elemtag)=tu8 then
	++sptr
	sptr.value:=(p.uarray.ptr+index)^
	sptr^.tagx:=tint
else
	pc_loadpacked(p.uarray.ptr+index*ttsize[elemtype],elemtype,++sptr,p)
fi

pc_unshare(&va) when va.hasref

return pcptr+1
end

global function j_pushix_bi_ei:ref intpc =
object p
variant a
int index,length,elemtype,offset,shift
ref byte q
varrec va

va:=(sptr+1)^
p:=va.objptr
index:=sptr^.value-p.ubits.lower
offset:=p.ubits.bitoffset
q:=p.ubits.ptr

if u32(index)>=u32(p.ubits.length) then		!bounds error
	pcerror("bits[int] bounds")
fi

++sptr
sptr.tagx:=tint

switch p.ubits.elemtag
when tu1 then
	index+:=offset
	sptr.value:=not not ((q+index>>3)^ iand (1<<(index iand 7)))
when tu2 then
	index+:=offset>>1
	shift:=(index iand 3)*2
	sptr.value:=((q+index>>2)^ iand (3<<shift))>>shift
when tu4 then
	index+:=offset>>2
	shift:=(index iand 1)*4
	sptr.value:=((q+index>>1)^ iand (15<<shift))>>shift
else
	pcustypet("bitix",p.ubits.elemtag)
end

pc_unshare(&va) when va.hasref

return pcptr+1
end

global function j_pushix_an:ref intpc =
varrec v
variant a,x
int i,j,value,offset
object p,q

x:=sptr++
a:=sptr
p:=a.objptr

i:=x.range_lower
j:=x.range_upper

if i<p.uarray.lower or j>p.uarray.length or i>j then
	pcerror("ax[slice] bounds")
fi

sptr.tagx:=a.tagx

q:=obj_new(a.tagx)
sptr.objptr:=q

q.objtype:=slice_obj
q.uarray.mutable:=p.uarray.mutable
q.uarray.elemtag:=p.uarray.elemtag
q.uarray.lower:=p.uarray.lower

offset:=(i-p.uarray.lower)*ttsize[p.uarray.elemtag]

case p.objtype
when slice_obj then				!slice of a slice!
	q.uarray.objptr2:=p.uarray.objptr2		!link to original
	++(q.objptr2.refcount)
	q.uarray.ptr:=p.uarray.ptr+offset
	v.tagx:=tstring ior hasrefmask
	v.objptr:=p
	pc_unshare(&v)
when extslice_obj then
	q.uarray.objptr2:=nil
	q.objtype:=extslice_obj
	q.uarray.ptr:=p.uarray.ptr+offset
else
	q.uarray.objptr2:=p				!link to original
	q.uarray.ptr:=p.uarray.ptr+offset
esac

q.uarray.length:=j-i+1

return pcptr+1
end

global function j_pushix_si:ref intpc =
varrec v
variant a,x
int index,length,i
object p,q

x:=sptr++
a:=sptr
p:=a.objptr

i:=x.value-1

if u32(i)>=u32(p.ustr.length) then
	pcerror("string[int] bounds")
fi

sptr.tagx:=tstring ior hasrefmask

q:=obj_new(tstring)
sptr.objptr:=q

q.objtype:=slice_obj
q.ustr.mutable:=p.ustr.mutable

case p^.objtype
when slice_obj then				!slice of a slice!
	q.ustr.objptr2:=p.ustr.objptr2		!link to original
	++(q.objptr2.refcount)
	q.ustr.strptr:=p.ustr.strptr+i
	v.tagx:=tstring ior hasrefmask
	v.objptr:=p
	pc_unshare(&v)
when extslice_obj then
	q.ustr.objptr2:=nil
	q.objtype:=extslice_obj
	q.ustr.strptr:=p.ustr.strptr+i
else
	q.ustr.objptr2:=p				!link to original
	q.ustr.strptr:=p.ustr.strptr+i
esac

q.ustr.length:=1

return pcptr+1
end

global function j_pushix_sn:ref intpc =
return j_pushdotix_sn()
end

global function j_pushix_bn:ref intpc =
varrec v
variant a,x
int i,j,value,bitoffset
object p,q
ref byte pbits

x:=sptr++
a:=sptr
p:=a.objptr

i:=x.range_lower
j:=x.range_upper

if i<p.ubits.lower or j>p.ubits.length or i>j then
	pcerror("bits[slice] bounds")
fi

sptr.tagx:=a.tagx

q:=obj_new(tbits)

sptr.objptr:=q

q.objtype:=slice_obj
q.ubits.mutable:=p.ubits.mutable
q.ubits.elemtag:=p.ubits.elemtag
q.ubits.lower:=p.ubits.lower

q.ubits.ptr:=cast(getbitoffset(p.ubits.ptr,p.ubits.bitoffset,(i-p.ubits.lower),
		 p.ubits.elemtag, q.ubits.bitoffset))

++q.ubits.bitoffset					!is 1-based

case p.objtype
when slice_obj then				!slice of a slice!
	q.ubits.objptr2:=p.ubits.objptr2		!link to original
	++(q.objptr2.refcount)
	v.tagx:=tstring ior hasrefmask
	v.objptr:=p
	pc_unshare(&v)
when extslice_obj then
	q.ubits.objptr2:=nil
	q^.objtype:=extslice_obj
else
	q.ubits.objptr2:=p				!link to original
esac

q.ubits.length:=j-i+1

return pcptr+1
end

global function j_pushix_di:ref intpc =
varrec v

variant a,x
int i,j,alower,ahasref
object p,q

x:=sptr++			!x is the index
a:=sptr				!a is the dict
p:=a.objptr

i:=x.value
j:=x.range_upper

alower:=p.udict.lower

if i<1 or j>p.udict.allocated then
	pcerror("dict[] bounds")
fi

sptr^.tagx:=tlist ior hasrefmask

q:=obj_new(tdict)
sptr.objptr:=q

q.objtype:=slice_obj
q.udict.lower:=1
q.udict.length:=2

q.udict.objptr2:=p				!link to original
q.udict.vptr:=p.udict.vptr+(i-1)*2

return pcptr+1
end

global function j_pushix_zz:ref intpc =
variant sptr1
pcmxtypes("pushix/def",sptr+1,sptr)
return nil
end

global function j_pushixref_li:ref intpc =
	object p
	variant a
	int index

	a:=(sptr+1)^.varptr
	p:=a^.objptr

	unless p.ulist.mutable then
		p:=a^.objptr:=copyonwrite(p,tlist)
	end

	index:=sptr.value-p.ulist.lower

	if u32(index)>=u32(p.ulist.length) then				!outside current bounds
		if index<0 then
			PCERROR("LWB")
		else
			if u32(index)=u32(p.ulist.length) and a.tag=tlist then
				pc_iappendlist(a,nil)
				p:=a.objptr
			else
				pcerror("&pushix list[i] bounds")
			fi
		fi
	fi

	(++sptr)^.tagx:=trefvar
	sptr.varptr:=p.ulist.vptr+index

	return pcptr+1
end

global function j_pushixref_ln:ref intpc =
junimpl("pushixref_list_range")
return pcptr+1
end

global function j_pushixref_ai:ref intpc =
int index,elemtype,elemsize
object p
variant a

a:=(sptr+1)^.varptr
p:=a.objptr
index:=sptr.value-p.uarray.lower

if u32(index)>=u32(p.uarray.length) then				!outside current bounds
	if index<0 then
		PCERROR("&AXLWB")
	else
		if u32(index)=u32(p.uarray.length) then
			pc_iappendarray(a,nil)
			p:=a.objptr
		else
			PCERROR("&AXBOUNDS")
		fi
	fi
fi

elemtype:=p.uarray.elemtag

++sptr

sptr.tagx:=trefpacked
sptr.uref.elemtag:=elemtype
sptr.uref.ptr:=p.uarray.ptr+index*ttsize[elemtype]
return pcptr+1
end

global function j_pushixref_si:ref intpc =
variant a
int index,newlength,newbytes
object pa

a:=(sptr+1)^.varptr
pa:=a.objptr
index:=sptr.value-1
if not pa.ustr.mutable then
	a^.objptr:=pa:=copyonwrite(pa,tstring)
fi

if u32(index)>=u32(pa.ustr.length) then				!outside current bounds
	pcerror("&str[int] bounds")
fi

(++sptr)^.tagx:=trefpacked
sptr^.uref.elemtag:=tstring
sptr^.uref.ptr:=ref byte(pa.ustr.strptr)+index

return pcptr+1
end

global function j_pushixref_bi:ref intpc =
int index,elemtype,elemsize,offset
object p
variant a

a:=(sptr+1)^.varptr
p:=a.objptr
index:=sptr.value-p.ubits.lower

if u32(index)>=u32(p.ubits.length) then				!outside current bounds
	if index<0 then
		PCERROR("&BITSLWB")
	else
		if u32(index)=u32(p.ubits.length) then
			pc_iappendbits(a,nil)
			p:=a.objptr
		else
			PCERROR("&BITSBOUNDS")
		fi
	fi
fi

elemtype:=p.ubits.elemtag

++sptr

sptr.tagx:=trefbit
sptr.uref.elemtag:=elemtype
sptr.uref.ptr:=cast(getbitoffset(cast(p.ubits.ptr),p.ubits.bitoffset,index, elemtype,
		 sptr.uref.bitoffset))
sptr.uref.bitlength:=0

return pcptr+1
end

global function j_pushixref_zz:ref intpc =
variant p,sptr1
PCERROR("JPUSHIXREF/DEF")

return nil
end

global function j_pushdotix_si:ref intpc =  !*******************
variant a,x
int index,value
object p

x:=sptr++
a:=sptr
p:=a^.objptr
index:=x^.value-1

if u32(index)>=u32(p.ustr.length) then	!bounds error
cpl =index,=p.ustr.length
	pcerror("string.[int] bounds")
fi
value:=(p.ustr.strptr+index)^

pc_unshare(a) when a.hasref

sptr.tagx:=tint
sptr.value:=value
return pcptr+1
end

global function j_pushdotix_sn:ref intpc =  !*******************
varrec v
variant a,x
int i,j,value
object p,q

x:=sptr++
a:=sptr
p:=a.objptr

i:=x.range_lower
j:=x.range_upper

if i<1 or j>p.ustr.length or i>j then
	if i=j+1 then
		sptr^.objptr:=emptystring
		sptr^.tagx:=tstring ior hasrefmask
		++emptystring^.refcount
		return pcptr+1

	fi
	pcerror("string[slice] bounds")
fi

sptr^.tagx:=tstring ior hasrefmask

q:=obj_new(tstring)
sptr.objptr:=q

q.objtype:=slice_obj
q.ustr.mutable:=p.ustr.mutable

case p^.objtype
when slice_obj then				!slice of a slice!
	q.ustr.objptr2:=p.ustr.objptr2		!link to original
	++(q.objptr2.refcount)
	q.ustr.strptr:=p.ustr.strptr+i-1
	v.tagx:=tstring ior hasrefmask
	v.objptr:=p
	pc_unshare(&v)
when extslice_obj then
	q.ustr.objptr2:=nil
	q.objtype:=extslice_obj
	q.ustr.strptr:=p.ustr.strptr+i-1
else
	q.ustr.objptr2:=p				!link to original
	q.ustr.strptr:=p.ustr.strptr+i-1
esac

q.ustr.length:=j-i+1

return pcptr+1
end

global function j_pushdotix_ii:ref intpc =  !**********************
int index

index:=sptr^.value
++sptr
if index<0 or index>=64 then
	pcerror("int.[int] bounds")
fi

sptr^.value:=(sptr^.value>>index) iand 1
return pcptr+1
end

global function j_pushdotix_in:ref intpc =  !**********************
int i,j

i:=sptr^.range_lower
j:=sptr^.range_upper
++sptr

if j<i then
	swap(i,j)
fi

if i>=64 or j>=64 then
	pcerror("int.[slice] bounds")
fi

sptr^.value:=(sptr^.value>>i)  iand  inot(0xFFFF'FFFF'FFFF'FFFF<<(j-i+1))
return pcptr+1
end

global function j_pushdotix_ei:ref intpc =  !**********************
return j_pushix_bi_ei()
end

global function j_pushdotix_mi:ref intpc =  !**********************
return j_pushix_mi()
end

global function j_pushdotix_zz:ref intpc =  !**********************
pcmxtypes("pushdotix/def",sptr+1,sptr)
return nil
end

global function j_pushdotixref_si:ref intpc =  !********************
variant a
int index,newlength,newbytes
object pa

a:=(sptr+1)^.varptr
pa:=a^.objptr
index:=sptr^.value-1

if u32(index)>=u32(pa.ustr.length) then				!outside current bounds
	pcerror("&str.[int] bounds")
fi

(++sptr)^.tagx:=trefpacked
sptr.uref.elemtag:=tu8
sptr.uref.ptr:=ref byte(pa.ustr.strptr)+index

return pcptr+1
end

global function j_pushdotixref_sn:ref intpc =  !********************
variant a,x
ichar p				!string data
int i,j,length
PCERROR("JPUSHDOTIXREF/SRANGE")

return pcptr+1
end

global function j_pushdotixref_ii:ref intpc =  !***********************
int index
ref byte p

index:=sptr^.value
++sptr
if index<0 or index>=64 then
	pcerror("int.[int] bounds")
fi

p:=sptr^.uref.ptr		!point to start of int var

sptr^.tagx:=trefbit
sptr^.uref.elemtag:=tu1
sptr^.uref.bitoffset:=index iand 7
sptr^.uref.ptr:=p+8+index>>3
sptr^.uref.bitlength:=0

return pcptr+1
end

global function j_pushdotixref_in_wn:ref intpc =  !***********************
int i,j

i:=sptr^.range_lower
j:=sptr^.range_upper
if i>j then swap(i,j) fi


++sptr
if i<0 or j>=64 then
	pcerror("int.[slice] bounds")
fi


sptr^.tagx:=trefbit
sptr^.uref.bitlength:=j-i+1
sptr^.uref.elemtag:=tu1
sptr^.uref.bitoffset:=i
++sptr^.uref.ptr64				!step 8 bytes past start of var

return pcptr+1
end

global function j_pushdotixref_ei:ref intpc =  !***********************
PCERROR("PUSHDOTIXREF/SET")
end

global function j_pushdotixref_zz:ref intpc =  !**********************
pcmxtypes("ZZpushdotixref/def",sptr+1,sptr)
return nil
end

global function j_addto_i:ref intpc =  !********************************
variant x,y
y:=sptr++
x:=sptr^.varptr
++sptr
x^.value+:=y^.value
return pcptr+1
end

global function j_addto_r:ref intpc =  !********************************
variant x,y
y:=sptr++
x:=sptr^.varptr
++sptr
x^.xvalue+:=y^.xvalue
return pcptr+1
end

global function j_addto_s:ref intpc =  !********************************
int xlen,ylen,newlen
object px,py
variant x,y

y:=sptr++
x:=sptr^.varptr

++sptr

px:=x.objptr
py:=y.objptr

if not px.ustr.mutable then
	x.objptr:=px:=copyonwrite(px,tstring)
fi
if px.objtype<>normal_obj then
	pcerror("extending string slice")
fi

xlen:=px.ustr.length
ylen:=py.ustr.length

if xlen=0 then
	if ylen then		!copy y to x (else x is unchanged)
		px.ustr.strptr:=pcm_alloc(ylen)
		px.ustr.allocated:=allocbytes
		px.ustr.length:=ylen
		memcpy(px.ustr.strptr,py.ustr.strptr,ylen)
	fi
elsif ylen=1 then			!x+:=y when y is a single character
	if ++xlen>px.ustr.allocated then
		string_resize(px,xlen)
	fi
	px.ustr.length:=xlen
	(px.ustr.strptr+xlen-1)^:=py.ustr.strptr^
elsif ylen then			!x+:=y; ylen>1 neither are empty (else leave x alone)
	newlen:=xlen+ylen
	if newlen>px.ustr.allocated then
		string_resize(px,newlen)
	fi
	px.ustr.length:=newlen
	memcpy(px.ustr.strptr+xlen,py.ustr.strptr,ylen)
fi

pc_unshare(y)

return pcptr+1
end

global function j_addto_p:ref intpc =  !********************************
variant x,y

PCERROR("ADDTO REF PACK")

return pcptr+1
end

global function j_addto_z:ref intpc =  !********************************
int xlen,ylen,newlen
object px,py
variant x,y
varrec result
 
y:=sptr++
x:=sptr^.varptr

++sptr

px:=x.objptr
py:=y.objptr

case y^.tag
when tbignum then
	bx_add(x,y,&result)
	pc_unshare(x)
	pc_unshare(y)
	x^:=result
else
	pcmxtypes("addto_def",x,y)
esac
return pcptr+1
end

global function j_addto_si:ref intpc =  !********************************
int ch
variant x,y
int xlen
object px

y:=sptr++
x:=sptr.varptr
++sptr
ch:=y.value

px:=x.objptr

if not px.ustr.mutable then

	x^.objptr:=px:=copyonwrite(px,tstring)
fi

xlen:=px.ustr.length

if xlen=0 then
	px.ustr.strptr:=pcm_alloc(1)
	px.ustr.allocated:=allocbytes
	px.ustr.length:=1
	px.ustr.strptr^:=ch
else
	if ++xlen>px.ustr.allocated then
		string_resize(px,xlen)
	fi
	px.ustr.length:=xlen
	(px.ustr.strptr+xlen-1)^:=ch
fi


return pcptr+1
end

global function j_addto_ir:ref intpc =  !********************************
variant x,y
static int oldreg,newreg

y:=sptr++
x:=sptr^.varptr
++sptr
x^.value+:=y^.xvalue

return pcptr+1
end

global function j_addto_ri:ref intpc =  !********************************
variant x,y

y:=sptr++
x:=sptr^.varptr
++sptr
x^.xvalue+:=y^.value
return pcptr+1
end

global function j_addto_zz:ref intpc =  !********************************
pcmxtypes("addto_zz",(sptr+1)^.varptr,sptr)
return pcptr+1
end

global function j_subto_i:ref intpc =  !********************************
variant x,y
y:=sptr++
x:=sptr^.varptr
++sptr
x^.value-:=y^.value
return pcptr+1
end

global function j_subto_r:ref intpc =  !********************************
variant x,y
y:=sptr++
x:=sptr^.varptr
++sptr
x^.xvalue-:=y^.xvalue
return pcptr+1
end

global function j_subto_z:ref intpc =  !********************************
pcmxtypes("subto_def",(sptr+1)^.varptr,sptr)
return pcptr+1
end

global function j_subto_ir:ref intpc =  !********************************
variant x,y

y:=sptr++
x:=sptr^.varptr
++sptr
x^.value-:=y^.xvalue
return pcptr+1
end

global function j_subto_ri:ref intpc =  !********************************
variant x,y

y:=sptr++
x:=sptr^.varptr
++sptr
x^.xvalue-:=y^.value
return pcptr+1
end

global function j_subto_zz:ref intpc =  !********************************
pcmxtypes("subto_zz",(sptr+1)^.varptr,sptr)
return pcptr+1
end

global function j_multo_i_w:ref intpc =  !********************************
variant x,y
y:=sptr++
x:=sptr^.varptr
++sptr
x^.value*:=y^.value
return pcptr+1
end

global function j_multo_r:ref intpc =  !********************************
variant x,y
y:=sptr++
x:=sptr^.varptr
++sptr
x^.xvalue*:=y^.xvalue
return pcptr+1
end

global function j_multo_z:ref intpc =  !********************************
pcmxtypes("multo_def",(sptr+1)^.varptr,sptr)
return pcptr+1
end

global function j_divto_i_w:ref intpc =  !********************************
variant x,y
pcerror("divto int?")
return pcptr+1
end

global function j_divto_r:ref intpc =  !********************************
variant x,y
y:=sptr++
x:=sptr^.varptr
++sptr
x^.xvalue/:=y^.xvalue
return pcptr+1
end

global function j_divto_z:ref intpc =  !********************************
pcmxtypes("divto_def",(sptr+1)^.varptr,sptr)
return pcptr+1
end

global function j_idivto_i:ref intpc =  !********************************
variant y
pcustype("idivto",sptr)
return pcptr+1
end

global function j_idivto_z:ref intpc =  !********************************
pcmxtypes("idivto_def",(sptr+1)^.varptr,sptr)
return pcptr+1
end

global function j_iand_i_w:ref intpc =  !*******************************
variant y

y:=sptr++
sptr^.value iand:=y^.value
return pcptr+1
end

global function j_iand_e:ref intpc =  !*******************************
variant x,y

y:=sptr
x:=++sptr
dx_iandset(x,y)
return pcptr+1
end

global function j_iand_z:ref intpc =  !*******************************
pcmxtypes("iand_def",sptr+1,sptr)
return pcptr+1
end

global function j_ior_i_w:ref intpc =  !********************************
variant y

y:=sptr++
sptr^.value ior:=y^.value
return pcptr+1
end

global function j_ior_e:ref intpc =  !********************************
variant x,y

return j_add_e()
end

global function j_ior_z:ref intpc =  !********************************
pcmxtypes("ior_def",sptr+1,sptr)
return pcptr+1
end

global function j_ixor_i_w:ref intpc =  !*******************************
variant y

y:=sptr++
sptr^.value ixor:=y^.value
return pcptr+1
end

global function j_ixor_e:ref intpc =  !*******************************
variant x,y

y:=sptr++
x:=sptr

dx_ixorset(x,y)
return pcptr+1
end

global function j_ixor_z:ref intpc =  !*******************************
pcmxtypes("ixor_def",sptr+1,sptr)
return pcptr+1
end

global function j_iandto_i_w:ref intpc =  !********************************
variant x,y
y:=sptr++
x:=sptr^.varptr
++sptr
x^.value iand:=y^.value
return pcptr+1
end

global function j_iandto_z:ref intpc =  !********************************
pcmxtypes("iandto_def",(sptr+1)^.varptr,sptr)
return pcptr+1
end

global function j_iorto_i_w:ref intpc =  !********************************
variant x,y
y:=sptr++
x:=sptr^.varptr
++sptr
x^.value ior:=y^.value
return pcptr+1
end

global function j_iorto_z:ref intpc =  !********************************
pcmxtypes("iorto_def",(sptr+1)^.varptr,sptr)
return pcptr+1
end

global function j_ixorto_i_w:ref intpc =  !********************************
variant x,y
y:=sptr++
x:=sptr^.varptr
++sptr
x^.value ixor:=y^.value
return pcptr+1
return pcptr+1
end

global function j_ixorto_z:ref intpc =  !********************************
pcmxtypes("ixorto_def",(sptr+1)^.varptr,sptr)
return pcptr+1
end

global function j_shlto_i:ref intpc =  !********************************
variant x,y
y:=sptr++
x:=sptr^.varptr
++sptr
x^.value:=x^.value<<y^.value
return pcptr+1
end

global function j_shlto_z:ref intpc =  !********************************
pcmxtypes("shlto_def",(sptr+1)^.varptr,sptr)
return pcptr+1
end

global function j_shrto_i:ref intpc =  !********************************
variant x,y
y:=sptr++
x:=sptr^.varptr
++sptr
x^.value:=x^.value>>y^.value
return pcptr+1
end

global function j_shrto_z:ref intpc =  !********************************
pcmxtypes("shrto_def",(sptr+1)^.varptr,sptr)
return pcptr+1
end

global function j_concat_s:ref intpc =  !**************************
return j_add_s()
end

global function j_concat_l:ref intpc =  !**************************
variant x,y
y:=sptr
x:=++sptr

pc_duplvar(x)				!x needs to be owner of list
pc_iconcatlist(x,y)

pc_unshare(y) when y^.hasref

return pcptr+1
end

global function j_concat_z:ref intpc =  !*****************************
pcmxtypes("concat_def",sptr+1,sptr)
return pcptr+1
end

global function j_concatto_s:ref intpc =  !**************************
junimpl("concatto_string")
return pcptr+1
end

global function j_concatto_l:ref intpc =  !**************************
variant x,y
y:=sptr++
x:=sptr^.varptr
++sptr

pc_iconcatlist(x,y)
pc_unshare(y) when y^.hasref

return pcptr+1
end

global function j_concatto_z:ref intpc =  !*****************************
pcmxtypes("concatto_def",sptr+1,sptr)
return pcptr+1
end

global function j_append_s:ref intpc =  !**************************
if sptr^.tag<>tstring then
	pcustype("append/s",sptr)
fi
return j_add_s()
end

global function j_append_l:ref intpc =  !****************************
variant x,y
y:=sptr
x:=++sptr

pc_duplvar(x)				!x needs to be owner of list

pc_iappendlist(x,y)

pc_unshare(y) when y^.hasref

return pcptr+1
end

global function j_append_a:ref intpc =  !***************************
variant x,y
y:=sptr
x:=++sptr

pc_duplvar(x)				!x needs to be owner of list

pc_iappendarray(x,y)

pc_unshare(y) when y^.hasref

return pcptr+1
end

global function j_append_b:ref intpc =  !***************************
variant x,y
y:=sptr
x:=++sptr

pc_duplvar(x)				!x needs to be owner of list

pc_iappendbits(x,y)

return pcptr+1
end

global function j_append_z:ref intpc =  !*****************************
pcmxtypes("append_def",sptr+1,sptr)
return pcptr+1
end

global function j_appendto_s:ref intpc =  !**************************
return j_addto_s()
end

global function j_appendto_l:ref intpc =  !****************************
variant x,y
y:=sptr++
x:=sptr^.varptr
++sptr

pc_iappendlist(x,y)

return pcptr+1
end

global function j_appendto_a:ref intpc =  !***************************
variant x,y
y:=sptr++
x:=sptr^.varptr
++sptr

pc_iappendarray(x,y)

return pcptr+1
end

global function j_appendto_b_e:ref intpc =  !***************************
variant x,y
y:=sptr++
x:=sptr^.varptr
++sptr

pc_iappendbits(x,y)

return pcptr+1
end

global function j_appendto_z:ref intpc =  !*****************************
pcmxtypes("appendto_def",sptr+1,sptr)
return pcptr+1
end

global function j_max_i:ref intpc =
variant y

y:=sptr++
sptr^.value max:=y^.value
return pcptr+1
end

global function j_max_r:ref intpc =
variant y


y:=sptr++
sptr^.xvalue max:=y^.xvalue
return pcptr+1
end

global function j_max_z:ref intpc =
int res
variant y

y:=sptr++

res:=pc_compare_nf(sptr,y)

if res>=0 then			!keep x
	pc_unshare(y) when y.hasref
else					!use y
	pc_unshare(sptr) when sptr.hasref
	sptr^:=y^
fi

return pcptr+1
end

global function j_min_z:ref intpc =
int res
variant y

y:=sptr++
res:=pc_compare_nf(sptr,y)

if res<=0 then			!keep x
	pc_unshare(y) when y.hasref
else					!use y
	pc_unshare(sptr) when sptr.hasref
	sptr^:=y^
fi

return pcptr+1
end

global function j_len_l_a_e_s_b_d:ref intpc =		!*****************************
int length

length:=sptr.objptr.ulist.length
pc_unshare(sptr)	! when sptr^.hasref

sptr^.tagx:=tint
sptr^.value:=length
return pcptr+1
end

global function j_len_m_k:ref intpc =		!*****************************
int length

length:=ttlength[sptr.tag]
pc_unshare(sptr)	!when sptr^.hasref

sptr^.tagx:=tint
sptr^.value:=length
return pcptr+1
end

global function j_len_n:ref intpc =  !******************************
sptr^.tagx:=tint
sptr^.value:=sptr^.range_upper-sptr^.range_lower+1
return pcptr+1
end

global function j_len_z:ref intpc =  !********************************
case sptr^.tag
when tbignum then
	sptr^.value:=bx_length(sptr)
when tdict then
	sptr^.value:=sptr^.objptr.udict.allocated/2
when tint then
	sptr^.value:=64
	sptr^.tagx:=tint
else
	pcustype("len_def",sptr)
esac
sptr^.tagx:=tint
return pcptr+1
end

global function j_lwb_l:ref intpc =  !*********************
int n
object p

p:=sptr.objptr
n:=p.ulist.lower
pc_unshare(sptr)

sptr.tagx:=tint
sptr.value:=n

return pcptr+1
end

global function j_lwb_a_b:ref intpc =  !*********************
int n
object p

p:=sptr.objptr
n:=p.uarray.lower
pc_unshare(sptr)

sptr.tagx:=tint
sptr.value:=n

return pcptr+1
end

global function j_lwb_s_m_k_d:ref intpc =  !*********************
pc_unshare(sptr)

sptr.tagx:=tint
sptr.value:=1

return pcptr+1
end

global function j_lwb_e:ref intpc =  !*********************
object p

pc_unshare(sptr)

sptr^.tagx:=tint
sptr^.value:=0

return pcptr+1
end

global function j_lwb_n:ref intpc =  !******************************
sptr^.value:=sptr^.range_lower
sptr^.tagx:=tint
return pcptr+1
end

global function j_lwb_z:ref intpc =  !********************************
case sptr^.tag
when tint then
	sptr^.value:=0
	sptr^.tagx:=tint
else
	pcustype("lwb_def",sptr)
esac
return pcptr+1
end

global function j_upb_l:ref intpc =  !*********************
int n
object p

p:=sptr^.objptr
n:=word32(p.ulist.length+p.ulist.lower-1)
pc_unshare(sptr)

sptr^.tagx:=tint
sptr^.value:=n

return pcptr+1
end

global function j_upb_a_b:ref intpc =  !*********************
int n
object p

p:=sptr^.objptr
n:=word32(p.uarray.length+p.uarray.lower-1)
pc_unshare(sptr)

sptr^.tagx:=tint
sptr^.value:=n

return pcptr+1
end

global function j_upb_s_d:ref intpc =  !*********************
int n

n:=sptr^.objptr.ustr.length
pc_unshare(sptr)

sptr^.tagx:=tint
sptr^.value:=n

return pcptr+1
end

global function j_upb_m_k:ref intpc =  !*********************
int n
n:=ttlength[sptr.tag]
pc_unshare(sptr)

sptr^.tagx:=tint
sptr^.value:=n

return pcptr+1
end

global function j_upb_e:ref intpc =  !*********************
int n

n:=sptr.objptr.uset.length-1
pc_unshare(sptr)

sptr^.tagx:=tint
sptr^.value:=n

return pcptr+1
end

global function j_upb_n:ref intpc =  !******************************
sptr^.value:=sptr^.range_upper
sptr^.tagx:=tint
return pcptr+1
end

global function j_upb_z:ref intpc =  !********************************
case sptr^.tag
when tdict then
	sptr^.value:=sptr.objptr.udict.allocated/2
when tint then
	sptr^.value:=63
else
	pcustype("upb_def",sptr)
esac
sptr^.tagx:=tint
return pcptr+1
end

global function j_bounds_l_a_b_s_e:ref intpc =  !**************************
int a,b
object r

r:=sptr^.objptr

case ttbasetype[sptr^.tag]
when tstring,trecord,tstruct then
	a:=1
when tset then
	a:=0
when tarray,tbits then
	a:=r.uarray.lower

else
	a:=r.ulist.lower
esac
b:=r.ulist.length+a-1

pc_unshare(sptr) when sptr^.hasref

sptr^.tagx:=trange
sptr^.range_lower:=a
sptr^.range_upper:=b
return pcptr+1
end

global function j_bounds_m_k:ref intpc =  !**************************
int b

b:=ttlength[sptr.tag]
pc_unshare(sptr)

sptr^.tagx:=trange
sptr^.range_lower:=1
sptr^.range_upper:=b
return pcptr+1
end

global function j_bounds_n:ref intpc =  !***************************
return pcptr+1
end

global function j_bounds_z:ref intpc =  !*****************************
case sptr^.tag
when tint then
	sptr^.tagx:=trange
	sptr^.range_lower:=0
	sptr^.range_upper:=63
else
	pcustype("bounds_def",sptr)
esac
return pcptr+1
end

global function j_minto_i:ref intpc =  !********************************
variant x,y
y:=sptr++
x:=sptr^.varptr
++sptr
x^.value min:=y^.value
return pcptr+1
end

global function j_minto_r:ref intpc =  !********************************
variant x,y
y:=sptr++
x:=sptr^.varptr
++sptr
x^.xvalue min:=y^.xvalue
return pcptr+1
end

global function j_minto_z:ref intpc =  !********************************
pcmxtypes("minto_def",(sptr+1)^.varptr,sptr)
return pcptr+1
end

global function j_maxto_i:ref intpc =  !********************************
variant x,y
y:=sptr++
x:=sptr^.varptr
++sptr
x^.value max:=y^.value
return pcptr+1
end

global function j_maxto_r:ref intpc =  !********************************
variant x,y
y:=sptr++
x:=sptr^.varptr
++sptr
x^.xvalue max:=y^.xvalue
return pcptr+1
end

global function j_maxto_z:ref intpc =  !********************************
pcmxtypes("maxto_def",(sptr+1)^.varptr,sptr)
return pcptr+1
end

global function j_neg_i_w:ref intpc =  !********************************
sptr^.value:=-sptr^.value
return pcptr+1
end

global function j_neg_r:ref intpc =  !*******************************
sptr^.xvalue:=-sptr^.xvalue
return pcptr+1
end

global function j_neg_j:ref intpc =  !****************************
pc_duplvar(sptr)
bx_negto(sptr)
return pcptr+1
end

global function j_neg_e:ref intpc =  !****************************
dx_inotset(sptr)
return pcptr+1
end

global function j_neg_z:ref intpc =  !********************************
pcustype("neg_def",sptr)
return pcptr+1
end

global function j_abs_i_w:ref intpc =  !********************************
sptr^.value:=abs sptr^.value
return pcptr+1
end

global function j_abs_r:ref intpc =  !*******************************
sptr^.xvalue:=abs sptr^.xvalue
return pcptr+1
end

global function j_abs_j:ref intpc =  !****************************
pc_duplvar(sptr)
bx_absto(sptr)
return pcptr+1
end

global function j_abs_z:ref intpc =  !********************************
pcustype("abs_def",sptr)
return pcptr+1
end

global function j_inot_i_w:ref intpc =  !*******************************
sptr^.value:=inot sptr^.value
return pcptr+1
end

global function j_inot_e:ref intpc =  !*******************************
dx_inotset(sptr)
return pcptr+1
end

global function j_inot_z:ref intpc =  !*******************************
pcustype("inot_def",sptr)
return pcptr+1
end

global function j_istrue_i_w_r:ref intpc =  !************************
sptr^.tag:=tint
sptr^.value:=not not sptr^.value
return pcptr+1
end

global function j_istrue_l_a_e_s_b:ref intpc =  !************************
int res

res:=sptr^.objptr.ulist.length<>0
pc_unshare(sptr)
sptr^.tagx:=tint
sptr^.value:=res
return pcptr+1
end

global function j_istrue_k_m_h:ref intpc =  !************************
pc_unshare(sptr) when sptr.hasref
sptr^.tagx:=tint
sptr^.value:=1
return pcptr+1
end

global function j_istrue_j:ref intpc =  !*************************
junimpl("istrue_longint")
return pcptr+1
end

global function j_istrue_z:ref intpc =  !*****************************
pcustype("istrue_def",sptr)
return pcptr+1
end

global function j_jumpfalse_i_w_r_v_p_f:ref intpc=
if not sptr^.value then
	++sptr
	return ref intpc(getopnda)
fi
++sptr
return pcptr+2
end

global function j_jumpfalse_s_l_e_a_b:ref intpc =  !************
int n

n:=sptr^.objptr.ulist.length
pc_unshare(sptr)
++sptr
if n=0 then
	return ref intpc(getopnda)
fi
return pcptr+2
end

global function j_jumpfalse_z:ref intpc =  !******************************
switch ttbasetype[sptr^.tag]
when trecord,tstruct,trecordlink then			!always false (sometimes can be nil or record)
	++sptr
	return pcptr+2
end
pcustype("jumpfalse_def",sptr)
return pcptr+2
end

global function j_jumptrue_i_r_w_v_p_f:ref intpc =  !*************************
if sptr^.value then
	++sptr
	return ref intpc(getopnda)
fi
++sptr
return pcptr+2
end

global function j_jumptrue_s_l_e_a_b:ref intpc =  !************
int n

n:=sptr^.objptr.ulist.length
pc_unshare(sptr)
++sptr
if n then
	return ref intpc(getopnda)
fi
return pcptr+2
end

global function j_jumptrue_z:ref intpc =  !******************************
switch ttbasetype[sptr^.tag]
when trecord,tstruct,trecordlink then			!always true (sometimes can be nil or record)
	++sptr
	return ref intpc(getopnda)
end

pcustype("jumptrue_def",sptr)
return pcptr+2
end

global function j_shl_i_w:ref intpc =  !********************************
variant y

y:=sptr++
sptr^.value :=sptr^.value<<y^.value
return pcptr+1
end

global function j_shl_z:ref intpc =  !********************************
pcmxtypes("shl_def",sptr+1,sptr)
return pcptr+1
end

global function j_shr_i_w:ref intpc =  !********************************
variant y

y:=sptr++
sptr^.value :=sptr^.value>>y^.value
return pcptr+1
end

global function j_shr_j_i:ref intpc =  !********************************
variant y

PCERROR("SHR/J/I")

return pcptr+1
end

global function j_shr_z:ref intpc =  !********************************
pcmxtypes("shr_def",sptr+1,sptr)
return pcptr+1
end

global function j_shr_wi:ref intpc =  !********************************
variant y

y:=sptr++
sptr^.uvalue :=sptr^.uvalue>>y^.value
return pcptr+1
end

global function j_shr_zz:ref intpc =  !********************************
variant y

return pcmxtypes("shr_zz",sptr+1,sptr)
end

global function j_idiv_w:ref intpc =
variant y

y:=sptr++
sptr^.uvalue:=sptr^.uvalue/y^.uvalue
return pcptr+1
end

global function j_idiv_j:ref intpc =
ref  varrec x,y
varrec result

y:=sptr++
x:=sptr

bx_idiv(x,y,&result)
pc_unshare(x) when x^.hasref
pc_unshare(y) when y^.hasref
sptr^:=result
return pcptr+1
end

global function j_idiv_z:ref intpc =
pcmxtypes("idiv_def",sptr+1,sptr)
return pcptr+1
end

global function j_rem_w:ref intpc =
variant y

y:=sptr++
sptr^.uvalue:=sptr^.uvalue rem y^.uvalue
return pcptr+1
end

global function j_rem_j:ref intpc =
ref  varrec x,y
varrec result


y:=sptr++
x:=sptr

bx_irem(x,y,&result)
pc_unshare(x) when x^.hasref
pc_unshare(y) when y^.hasref
sptr^:=result
return pcptr+1
end

global function j_remz:ref intpc =
pcmxtypes("rem_def",sptr+1,sptr)
return pcptr+1
end

=== pc_oslayer.m 19/56 ===
import clib
import mlib
import oslib
import osdll

import pc_types
import pc_decls
import pc_support
import pc_pcfns
import pci

global function runproc_m(ref void amsg)int=
varrec a,b,dest
static int rmsg_typeno
int i,result
objrec obj



if rmsg_typeno=0 then
	for i to ntypes do
		if eqstring(ttname[i],($targetbits=32|"ws_msg32"|"ws_msg64")) then
			rmsg_typeno:=i
			exit
		fi
	od
fi
if rmsg_typeno=0 then
	abortprogram("mainwndproc: can't find rmsg")
fi

memset(&obj,0,objrec.bytes)
obj.refcount:=99
obj.ustruct.ptr:=ref byte(amsg)

a.tagx:=rmsg_typeno ior hasrefmask
a.objptr:=&obj

runproc(pcl_callbackfn,&a,nil,&dest)
result:=dest.value

result:=0			!WTF? BUT QX HAS THIS TOO, AND IT WORKS!

return result
end

global proc os_getconsize(variant result)=
u64 aa
pcerror("GETCONSIZE")
end

global proc pch_setmesshandler(variant fn)=
if fn^.tag<>trefproc then
	pcerror("Not refproc")
fi
pcl_callbackfn:=cast(fn^.refptr)
os_setmesshandler(&runproc_m)
end

global proc pch_gethostname(variant result) =
static [0:256]char name

strcpy(&.name,os_gethostname())

pc_makestring(&.name,-1,result)
end

global proc os_initdllmodules =
int i
intm hinst
ichar dllname

for i:=1 to ndlltable do
	dllname:=dlltable[i]

	hinst:=os_loaddllmodule(dllname)
	if hinst=0 then
	fi
	dllinsttable[i]:=hinst;
od
end

global function os_loaddllmodule(ichar dllname)intm =
intm hinst

if eqstring(dllname,"jpeglib") then
	dllname:="jpeglib64"
elsif eqstring(dllname,"jpeglibc") then
	dllname:="jpeglibc64"
fi

hinst:=os_getdllinst(dllname)
return hinst
end

global proc os_initdllfunctions =
ref proc fnaddr
intm hinst
int i,dllmodno

for i:=1 to ndllproctable do
	dllmodno:=dllproctable[i].dllindex;
	hinst:=dllinsttable[dllmodno];

	fnaddr:=os_getdllprocaddr(hinst,dllproctable[i].name)
	if fnaddr=nil then
		if hinst=0 then
			next
		fi


		println "dllfns: fnaddr=0:",dllproctable[i].name,"from",dlltable[dllmodno]
	fi
	dllproctable[i].address:=cast(fnaddr)
od
end

global function os_loaddllfunction(int fnindex)ref void=
int dllmodno
intm hinst
ref proc fnaddr


dllmodno:=dllproctable[fnindex].dllindex
hinst:=dllinsttable[dllmodno]
if not hinst then
	hinst:=os_loaddllmodule(dlltable[dllmodno])
	if not hinst then
	else
		dllinsttable[dllmodno]:=hinst
	fi
fi

fnaddr:=os_getdllprocaddr(hinst,dllproctable[fnindex].name)


if not fnaddr then
	cpl dllproctable[fnindex].name
	pcerror("Can't find DLL function")
	stop 1
else
	dllproctable[fnindex].address:=cast(fnaddr)
fi
return fnaddr
end

global proc pch_getos(variant result)=
pc_makestring(os_getos(),-1,result)
end

global proc pch_gethostsize(variant result)=
result^.tagx:=tint
result^.value:=os_gethostsize()
end

global proc pch_iswindows(variant result)=
result^.tagx:=tint
result^.value:=os_iswindows()
end

global proc os_calldll(int calltype,fnindex,offset,nparams,restype,variant dest)=

int baserestype
ref proc fnaddr
i64 retval,retcode
r64 fretval
ref[]i64 iparams
ref[]i16 iparamtypes
[100]byte paramcodes

fnaddr:=cast(dllproctable[fnindex].address)





if not fnaddr then
	fnaddr:=os_loaddllfunction(fnindex)
	if fnaddr then
		dllproctable[fnindex].address:=cast(fnaddr)
	else
		cpl dllproctable[fnindex].name
		pcerror("Calldll nil fn:")
	fi
fi


iparams:=cast(&dllparams[offset+1])
iparamtypes:=cast(&dlltypes[offset+1])

for i to nparams do
	if ttbasetype[iparamtypes^[i]]=treal then
		paramcodes[i]:='R'
	else
		paramcodes[i]:='I'
	fi
od

baserestype:=ttbasetype[restype]
retcode:=(baserestype=tr64|'R'|'I')

retval:=os_calldllfunction(fnaddr, retcode, nparams, iparams, &paramcodes)


switch baserestype
when tvoid then
when treal, tr64 then
	dest.tagx:=treal
	dest.xvalue:=real@(retval)
when tr32 then
PCERROR("dll/r32ret")
when ti64,tu64,tintm,twordm,trefm then
	dest.tagx:=tint
	dest.value:=retval
when ti32 then
	dest.tagx:=tint
	dest.value:=int32(retval)
when tu32 then
	dest.tagx:=tint
	dest.value:=word32(retval)
when ti16 then
	dest.tagx:=tint
	dest.value:=int16(retval)
when tu16 then
	dest.tagx:=tint
	dest.value:=word16(retval)
when trefpacked then
	dest.tagx:=trefpacked
	dest.uref.ptr:=cast(retval)
	dest.uref.elemtag:=ttelemtype[restype]

else
 	cpl ttname[baserestype]
	pcerror("Rettype not supported")
endswitch
end
=== mwindll.m 20/56 ===
import clib
import mlib


global function os_calldllfunction(ref proc fnaddr,
		int retcode, nargs, ref[]i64 args, ref[]byte argcodes)word64 =
	word64 a
	real64 x
	int oddstack, nextra, pushedbytes


	oddstack:=nextra:=0

	assem
		test astack,8
		jz L100
		mov byte [oddstack],1
L100:
	end

	if oddstack then
		if nargs<5 then
			nextra:=5-nargs
		elsif nargs.even then
			nextra:=1
		fi

	else
		if nargs<4 then
			nextra:=4-nargs
		elsif nargs.odd then
			nextra:=1
		fi
	fi

	pushedbytes:=(nextra+nargs)*8


	to nextra do
		assem
			push 0
		end
	od

	for i:=nargs downto 1 do
		a:=args^[i]					!get generic 64-bit value to push
		assem
			push word64 [a]
		end
	od


	assem
		mov D10,[Dstack]
		movq XMM0,[Dstack]
		mov D11,[Dstack+8]
		movq XMM1,[Dstack+8]
		mov D12,[Dstack+16]
		movq XMM2,[Dstack+16]
		mov D13,[Dstack+24]
		movq XMM3,[Dstack+24]
	end

	if retcode='I' then
		a:=((ref function:int64(fnaddr))^())
		asm add Dstack,[pushedbytes]
		return a
	else
		x:=((ref function:real64(fnaddr))^())
		asm add Dstack,[pushedbytes]
		return word64@(x)
	fi
end	

global function os_pushargs(ref[]word64 args, int nargs, nextra,
					ref proc fnaddr, int isfloat)word64=
	word64 a
	real64 x

CPL "PUSH ARGS",NARGS, NEXTRA

	to nextra do
		asm	push 0
	end

CPL "PUSH ARGS2"
	for i to nargs do
		a:=args[i]
		asm push word64 [a]
	od
CPL "PUSH ARGS3"

	if isfloat then
		x:=((ref function:real64(fnaddr))^())
		a:=int64@(x)
	else
		a:=((ref function:int64(fnaddr))^())
	fi

	return a
end
=== pc_host.m 21/56 ===
import msys
import clib
import mlib
import oslib
import osdll

import pc_types
import pc_decls
import pc_support
import pc_objlib
import pc_print
import pq_common
import pc_oslayer
import pc_pcfns
import pci
import pc_print


importdll $dummy=
	clang function imgload_bgr(ichar filename, ref int x,y,channels,int needchannels)ref byte
end

record dimrec=(mut int lbound, upper, length)

type hostproc0=ref proc
type hostproc1=ref proc(variant a)
type hostproc2=ref proc(variant a,b)
type hostproc3=ref proc(variant a,b,c)
type hostproc4=ref proc(variant a,b,c,d)

type hostfn0=ref proc(variant a)
type hostfn1=ref proc(variant a,b)
type hostfn2=ref proc(variant a,b,c)
type hostfn3=ref proc(variant a,b,c,d)
type hostfn4=ref proc(variant a,b,c,d,e)

record overloadrec=
	int optype, optype2
	ref intpc pchandler
	ref overloadrec nextrec
end

global tabledata() [0:]ichar packtypenames, [0:]int packtypewidths, [0:]int packconvtypes =
	(tp_void=0,		$,	0,		tvoid),
	(tp_i64,		$,	64,		tint),
	(tp_u64,		$,	64,		tword),
	(tp_r64,		$,	64,		treal),

	(tp_pvoid,		$,	64,		trefpacked),	!here to trp64, must be same order as tvoid..tr64
	(tp_pi8,		$,	64,		trefpacked), 
	(tp_pi16,		$,	64,		trefpacked),
	(tp_pi32,		$,	64,		trefpacked),
	(tp_pi64,		$,	64,		trefpacked),
	(tp_pi128,		$,	64,		trefpacked),
	(tp_pu8,		$,	64,		trefpacked),
	(tp_pu16,		$,	64,		trefpacked),
	(tp_pu32,		$,	64,		trefpacked),
	(tp_pu64,		$,	64,		trefpacked),
	(tp_pu128,		$,	64,		trefpacked),
	(tp_pr32,		$,	64,		trefpacked),
	(tp_pr64,		$,	64,		trefpacked),

	(tp_pstruct,	$,	64,		trefpacked),	
	(tp_stringz,	$,	64,		tstringz),
	(tp_variant,	$,	64,		tvariant),
end

ref overloadrec tostr_list			!list of user overloads for tostr
ref overloadrec convert_list

const noparamtag=tvoid
const nodefault=-999999

ref procrec proclistptr
varrec applresult

include "CCM_HOST."

global proc callhostfunction(int hostfn, calledasfn) =		!CALLHOSTFN
ref proc fnaddr
int nparams,isfn
object p

fnaddr:=hosttable[hostfn]
nparams:=hostnparams[hostfn]
isfn:=hostisfn[hostfn]


if isfn then		!functions

	switch nparams
	when 0 then
		hostfn0(fnaddr)^(sptr)
	when 1 then
		hostfn1(fnaddr)^(sptr,sptr+1)
	when 2 then
		hostfn2(fnaddr)^(sptr,sptr+1,sptr+2)
	when 3 then
		hostfn3(fnaddr)^(sptr,sptr+1,sptr+2,sptr+3)
	when 4 then
		hostfn4(fnaddr)^(sptr,sptr+1,sptr+2,sptr+3,sptr+4)
	else
		pcerror("callhost/fn")
	endswitch
else					!procs

	switch nparams
	when 0 then
		hostproc0(fnaddr)^()
	when 1 then
		hostproc1(fnaddr)^(sptr)
	when 2 then
		hostproc2(fnaddr)^(sptr,sptr+1)
	when 3 then
		hostproc3(fnaddr)^(sptr,sptr+1,sptr+2)
	when 4 then
		hostproc4(fnaddr)^(sptr,sptr+1,sptr+2,sptr+3)
	else
		pcerror("callhost/proc")
	endswitch
fi

to nparams do
	pc_unshare(sptr) when sptr^.hasref
	++sptr
od
end

proc pch_leftstr(variant a, b, c, result)=
int n,length,padchar
ref char s
object pa

padchar:=' '
case c^.tag
when tvoid then
when tstring then
	if c.objptr.ustr.length=1 then
		padchar:=c.objptr.ustr.strptr^
	else
		pcerror("left/padx")
	fi
when tint then
	padchar:=c^.value
else
	pcerror("left/pad?")
esac

case b^.tag
when tvoid then
	n:=1
when tint then
	n:=b^.value
else
	pcerror("left:bad n")
esac
if a^.tag<>tstring then
	pcerror("left:not str")
fi

pa:=a.objptr
length:=pa.ustr.length
s:=pa.ustr.strptr


if n=0 then
	pc_emptystring(result)
	return
fi

result.tagx:=tstring ior hasrefmask
if n>0 then			!leftmost n chars
	if n<=length then
		leftstring(a,n,result)
	else				!n>length
		padstring_right(a,n,padchar,result)
	fi
else					!left chars chars excluding rightmost n
	n:=-n
	if n<length then
		leftstring(a,length-n,result)
	else
		pc_emptystring(result)
	fi
fi
end

proc pch_rightstr(variant a, b, c, result)=
int n,length,padchar
ref char s
object pa

padchar:=' '
case c^.tag
when tvoid then
when tstring then
	if c.objptr.ustr.length=1 then
		padchar:=c.objptr.ustr.strptr^
	else
		pcerror("right/padx")
	fi
when tint then
	padchar:=c.value
else
	pcerror("right/pad?")
esac

case b.tag
when tvoid then
	n:=1
when tint then
	n:=b.value
else
	pcerror("right:bad n")
esac

pa:=a.objptr
if a.tag<>tstring then
	pcerror("right:not str")
fi

length:=pa.ustr.length
s:=pa.ustr.strptr

result.tagx:=tstring ior hasrefmask

if n=0 then
	pc_emptystring(result)
	return
fi

if n>0 then			!rightmost n chars
	if n<=length then
		rightstring(a,n,result)
	else				!n>length
		padstring_left(a,n,padchar,result)
	fi
else					!right chars chars excluding leftmost n
	n:=-n
	if n<length then
		rightstring(a,length-n,result)
	else
		pc_emptystring(result)
	fi
fi
end

proc pch_convlc(variant a, b, result)=
checkparam(a,tstring)
result^:=a^
++result^.objptr^.refcount
pc_dupl(result) when result^.hasref
pc_iconvcase(result,b,0)
end

proc pch_convuc(variant a, b, result)=
checkparam(a,tstring)
result^:=a^
++result^.objptr^.refcount
pc_dupl(result) when result^.hasref
pc_iconvcase(result,b,1)
end

proc pch_iconvlc(variant a, b)=
checkparam(a,trefvar)
pc_iconvcase(a^.varptr,b,0)
end

proc pch_iconvuc(variant a, b)=
checkparam(a,trefvar)
pc_iconvcase(a^.varptr,b,1)
end

proc pch_stop=
pcerror("host_stop not impl")
end

proc pch_stopx(variant a)=
pcerror("host_stopx not impl")
end

proc pch_ismain(variant a, result)=
int mainmod,ismain

checkparam(a,tstring)
result^.tagx:=tint

if eqstring(strpclversion,"404") then
	mainmod:=1
else
	mainmod:=nmodules
fi

ismain:=cmpstring_len(a.objptr.ustr.strptr,moduletable[mainmod].name,
							a.objptr.ustr.length,strlen(moduletable[mainmod].name))=0
result^.value:=ismain
end

proc pch_waitkey(variant result)=
result^.tagx:=tint
result^.value:=os_getch()
end

proc pch_testkey(variant result)=
result^.tagx:=tint
result^.value:=os_kbhit()
end

proc pch_execwait(variant a, b, c, result)=
ref char workdir
int flag
object pa

checkparam(a,tstring)
pa:=a^.objptr

flag:=checkparam(b,tint,0)

if c^.tag=tvoid then
	workdir:=nil
else
	checkparam(c,tstring)
	workdir:=convCstring(c.objptr.ustr.strptr,c.objptr.ustr.length)
fi
result^.tagx:=tint
result^.value:=os_execwait(convCstring(pa.ustr.strptr,pa.ustr.length),flag,workdir)
end

proc pch_execcmd(variant a, b, c, result)=
ref char workdir
int flag
object pa

checkparam(a,tstring)
pa:=a.objptr

flag:=checkparam(b,tint,0)

if c^.tag=tvoid then
	workdir:=nil
else
	checkparam(c,tstring)
	workdir:=convCstring(c.objptr.ustr.strptr,c.objptr.ustr.length)
fi
result.tagx:=tint
result.value:=os_execcmd(convCstring(pa.ustr.strptr,pa.ustr.length),flag)
end

proc pch_makestr(variant a, b, result)=
	int n
	object s

	switch a^.tag
	when trefpacked then
	when tint then
	else
		pcerror("makestr")
	endswitch

	n:=getintvalue(b)
	result^.tagx:=tstring ior hasrefmask

	s:=make_strslicexobj(cast(a^.uref.ptr),n)
	result^.objptr:=s
end

proc pch_makestrslice(variant a, b, result)=
pcerror("MAKESTRSLICE")
end

proc pch_makeref(variant a,b,result) =		!PCH_MAKEREF
ref byte ptr

switch (ttbasetype[a^.tag])
when trefvar,trefpacked,tint then
	ptr:=a.uref.ptr
when tstring,tarray,tlist,tset then
	ptr:=a.objptr.uarray.ptr
else
	pcerror("makeref")
endswitch

result^.tagx:=trefpacked
result^.uref.ptr:=ptr
result^.uref.elemtag:=getintvalue(b)

case result^.uref.elemtag
when tbit,tbit2,tbit4 then
	result^.tag:=trefbit
	result^.uref.bitoffset:=0
	result^.uref.bitlength:=0
esac

end

proc pch_new(variant a, b, c, d, result)=
varrec v
int i,t,nbytes,ival,nwords,nbits,offset,elemtype,n
dimrec dims
variant qvar
ref int64 qint
ref byte qbyte
ref byte ptr
object p

t:=getintvalue(a)

if t<0 or t>ntypes then
	pcustypet("New:bad type",t)
fi
v.tagx:=t ior hasrefmask

switch ttbasetype[t]
when tlist then
	getbounds(b,&dims,1)
	p:=list_new(dims.length,dims.lbound)

	v.objptr:=p

	if dims.length then
		if c and c^.tag<>tvoid then		!init value provided
			qvar:=p.ulist.vptr
			to dims.length do
				qvar^:=c^
				pc_share(qvar) when qvar^.hasref
				++qvar
			od
		fi
	fi

when tarray then
	if ttlength[t] then			!length defined must be an array usertype
		elemtype:=ttelemtype[t]
		dims.length:=ttlength[t]
		dims.lbound:=ttlower[t]
		dims.upper:=dims.length+dims.lbound-1

		d:=b					!any init value: move to d
		goto doarray2
	fi

	elemtype:=getintvalue(b)
	getbounds(c,&dims,1)
	if elemtype>=tu1 and elemtype<=tu4 then
		v.tag:=t:=tbits
		goto dobits2
	fi

doarray2::
	p:=array_new(t, elemtype, dims.length,dims.lbound)

	v.objptr:=p

	if dims.length then
		if d and d^.tag<>tvoid then		!initial value supplied
			qbyte:=p.uarray.ptr
			to dims.length do
				pc_storepacked(qbyte,d,elemtype)
				qbyte+:=ttsize[elemtype]
			od
		fi
	fi

when tbits then
	if ttlength[t] then			!length defined must be a bits usertype
		elemtype:=ttelemtype[t]
		dims.length:=ttlength[t]
		dims.lbound:=ttlower[t]
		dims.upper:=dims.length+dims.lbound-1

		d:=b					!any init value: move to d
		goto dobits2
	fi

	elemtype:=getintvalue(b)

	if elemtype<tu1 or elemtype>tu4 then
		pcerror("new: bad bits elem")
	fi
	getbounds(c,&dims,1)
dobits2::				!entry point from arrays, when element is bit type

	p:=bits_new(elemtype,dims.length,dims.lbound)
	v.objptr:=p

	if dims.length then
		if d and d^.tag<>tvoid then		!initial value supplied
			qbyte:=p.ubits.ptr

			offset:=0
			to dims.length do
				pc_storebit(qbyte,offset,d,elemtype,0)
				offset+:=ttbitwidth[elemtype]
				if offset>=8 then
					offset:=0
					++qbyte
				fi
			od
		fi
	fi

when tset then
	getbounds(b,&dims,0)

	if dims.lbound<0 then
		pcerror("new:set:lwb")
	fi
	if dims.lbound<>0 then
		dims.lbound:=0
		dims.length:=dims.upper+1
	fi

	p:=set_new(dims.length,0)
	v.objptr:=p

when trecord then
	p:=record_new(t)
	objtovar(p,&v)

	if b and b.tag<>tvoid then
		qvar:=p.urec.vptr
		to ttlength[t] do
			qvar^:=b^
			pc_share(qvar) when qvar^.hasref
			++qvar
		od
	fi

when tstruct then

	p:=struct_new(t)

	objtovar(p,&v)

	if b and b^.tag<>tvoid then
		pcerror("New: struct init")
	fi

when tint,tword,treal,trefproc,trefvar then
	v.value:=0
	v.hasref:=0
	if b and b^.tag<>tvoid then
		pcerror("NEW(int/value)")
	fi


when tstring then
	getbounds(b,&dims,0)
	pc_makestringn(dims.length,&v)

when tdict then
	getbounds(b,&dims,1)
	n:=nextpoweroftwo(dims.length)

	p:=dict_new(n)
	p.udict.dictitems:=0
	v.objptr:=p

else
	pcustypet("new",t)
endswitch
finish::

result^:=v

end

proc pch_newheap(variant a, b, c, d, result)=
variant p

p:=pcm_alloc(varsize)
pch_new(a,b,c,d,p)
result^.tagx:=trefvar
result^.varptr:=p
end

proc pch_heapvar(variant a, result)=
variant p
result.tagx:=tint
result.value:=12345678

end

proc pch_freeheap(variant a)=
pcerror("FREEHEAP")
end

proc pch_getcmdparam(variant a, result)=
int n
ref char s

if a^.tag=noparamtag then		!return number of cmds
	result^.tagx:=tint
	result^.value:=ncmdparams+1
	return
fi

n:=getintvalue(a)

pc_makestring(cmdparamtable[n],-1,result)
end

proc pch_setpcerror(variant a)=
object pa
checkparam(a,tstring)
pa:=a^.objptr

if pcerror_mess then
	free(pcerror_mess)
	pcerror_mess:=nil
fi

if pa.ustr.length then
	pcerror_mess:=malloc(pa.ustr.length+1)
	memcpy(pcerror_mess,pa.ustr.strptr,pa.ustr.length)
	(pcerror_mess+pa.ustr.length)^:=0
fi
end

proc pch_setdebug(variant a)=
checkparam(a,tint)

CPL "SETDEBUG................."
fdebug:=a^.value
end

proc pch_setfprintf(variant a, b)=
checkparam(a,trefdllproc)
checkparam(b,trefdllproc)
fprintf_ptr:=cast(a^.refptr)
fgets_ptr:=cast(b^.refptr)
end

proc pch_ticks(variant result)=
result^.tagx:=tint
result^.value:=os_clock()
end

proc pch_sleep(variant a)=
checkparam(a,tint)
os_sleep(a^.value)
end

proc pch_random(variant a, result)=

int n,x

result^.tagx:=tint			!assume int result (can be real too)

if a^.tag=trange then
	x:=mrandomrange(a^.range_lower, a^.range_upper)
else
	checkparam(a,tint)
	n:=a^.value
	if n>1 then					!0 to n-1
		x:=mrandomint(n)
	elsif n=0 then				!pure rand
		x:=mrandom()
	elsif n=1 then				!0.0 to 0.99999999
		result^.tagx:=treal
		result^.xvalue:=mrandomreal()
		return
	else
	fi
fi
result^.value:=x
end

proc pch_findmetafunction(variant a, result)=
int i
ref char sdata
object pa
ref procrec pp
ref strec d

checkparam(a,tstring)
pa:=a.objptr
result.tagx:=trefproc
result.value:=0

if pa.ustr.length then
	sdata:=convCstring(pa.ustr.strptr,pa.ustr.length)
else
	return
fi 

	d:=&pcsymboltable^[1]
	to nsymbols do
		if d^.nameid=procid then
			if d^.metadata and strstr(d^.metadata,sdata)<>nil then
				result.refptr:=d^.address
				return
			fi
		fi
		++d
	od
end

proc pch_loadpcl(variant a, b, result)=
pcerror("host_loadpcl not impl")
end

proc pch_runpcl(variant a, b, result)=
pcerror("host_runpcl not impl")
end

proc pch_runtask(variant a, b, result)=
pcerror("host_runtask not impl")
end

proc pch_callext(variant a, b, c)=
pcerror("host_callext not impl")
end

proc pch_system(variant a,result) =		!PCH_SYSTEM
checkparam(a,tstring)
result^.tagx:=tint
result^.value:=system(convCstring(a.objptr.ustr.strptr,a.objptr.ustr.length))
end

proc pch_shellexec(variant a,b,result) =		!PCH_SHELLEXEC
object pa,pb

checkparam(a,tstring)
checkparam(b,tstring)
pa:=a.objptr
pb:=b.objptr

result.tagx:=tint
result.value:=os_shellexec(convCstring(pa.ustr.strptr,pa.ustr.length),
		convCstring(pb.ustr.strptr,pb.ustr.length))
end

proc pch_gethash(variant a,result) =		!PCH_GETHASH
result^.tagx:=tint
result^.value:=gethashvalue(a)
end

proc pch_test(variant a,b,result) =		!PCH_TEST
object p,q
int i
REF BYTE PP
STATIC INT LASTALLOC=0
REAL X,Y

p:=a.objptr

CPL "TEST>>>",=P.UARRAY.LENGTH, P.UARRAY.ALLOCATED






result^.tagx:=tint
end

proc pch_pcldata(variant a, b, result)=
int res,length,i
ref strec d
checkparam(a,tint)

res:=0

case a^.value
when 'PROCINIT' then
	if proclist=nil then			!build proclist
		d:=&pcsymboltable^[1]
		to nsymbols do
			if d^.nameid=procid then
				addtoproclist(d)
			fi
			++d
		od
	fi
	proclistptr:=proclist

when 'PROC' then
	if proclistptr then
		getproctabledata(proclistptr,result)
		proclistptr:=proclistptr^.nextproc
		return
	fi

when 'MODULE' then
	CPL "MODULE"

when 'CMDNAME' then
	pc_makestring(cmdnames[b^.value],-1,result)
	return

when 'CMDCODE' then
	for i:=1 to klastcmd do
		length:=strlen(cmdnames[i])
		if b.objptr.ustr.length=length and memcmp(b.objptr.ustr.strptr,
				cmdnames[i],length)=0 then
			res:=i
			exit
		fi
	od
when 'NOPNDS' then
	res:=cmdnopnds[b^.value]
else
	pcerror("pcldata/bad table")
esac

result^.tagx:=tint
result^.value:=res
end

proc pch_getcstring(variant a, result)=
pcerror("PCH/GETCSTRING")
end

proc pch_getparam(variant a, result)=
checkparam(a,tint)


result^:=variant(frameptr+a^.value*varsize)^		!param 1/2/3... = offset 16/32/48... (varsize=16)
if result^.hasref then
	++result^.objptr^.refcount
fi
end

proc pch_clearlist(variant a)=
int n
pcerror("PCH CLEARLIST")
end

proc pch_makelink(variant a, result)=

case ttbasetype[a^.tag]
when trecord then
	result^.tagx:=trecordlink
	result^.uref.elemtag:=a^.tag
	result^.objptr:=a^.objptr

when tint then				!makelink(0) is allowed, it just returns nil
	if a^.value then
		pcerror("makelink/int")
	fi
	result^.tagx:=tint
	result^.value:=0
when trecordlink then		!already link
else
CPL ttname[a^.tag]
CPL ttname[ttbasetype[a^.tag]]
	pcerror("makelink: not record/list")
esac
end

proc pch_allparams(variant a,result)=
object p
int nparams,isfn,i
variant q
ref intpc fnptr

checkparam(a,trefproc)
fnptr:=cast(a^.refptr)
nparams:=(fnptr-1)^

p:=obj_new(tlist)
p.objtype:=extslice_obj
p.ulist.length:=nparams
p.ulist.lower:=1
p.ulist.vptr:=variant(frameptr)+1

result.tagx:=tlist ior hasrefmask
result.objptr:=p
end

proc pch_stackvars(variant result)=
pcerror("STACKVARS")
end

proc pch_makeempty(variant a,result)=
object p
int t

t:=ttbasetype[a^.tag]
if t=ttype then
	t:=a^.value
fi

case t
when tlist then
	p:=emptylist
	++p.refcount
when tstring then
	pc_emptystring(result)
	return
when tarray then
	p:=array_new(tarray,a.objptr.uarray.elemtag,0,1)
else
	pcustypet("makeempty?",t)
esac

result.tagx:=t ior hasrefmask
result.objptr:=p
end

proc pch_readlines(variant a,result)=
ref byte p,q,pstart
varrec v
variant r
object l
int nlines,n

checkparam(a,tstring)
if a^.objptr.ustr.length=0 then
error::
	result.tagx:=tint
	result.value:=0
	return
fi

p:=readfile(a.objptr.ustr.strptr)
if p=nil then goto error fi


q:=p
nlines:=0
doswitch q++^
when 26 then
	exit
when 13 then
	++nlines
	if q^=10 then
		++q
	fi

when 10 then
	++nlines

end doswitch

v.tagx:=tlist ior hasrefmask

l:=list_new(nlines)
v.objptr:=l
r:=v.objptr.ulist.vptr

q:=p
pstart:=q
doswitch q++^
when 26 then
	exit
when 13 then
	n:=q-pstart-1
	if q^=10 then
		++q
	fi
addline::
	pc_makestring(cast(pstart),n,r)
	++r
	pstart:=q

when 10 then
	n:=q-pstart-1
	goto addline

end doswitch

result^:=v

free(p)
end

proc pch_dictitems(variant a,result)=
if a^.hasref then
	result.tagx:=tint
	result.value:=a.objptr.udict.dictitems
else
	pcerror(".alloclen/not heap")
fi
end

proc pch_setoverload(variant a,b,c)=

ref[0:]ref void tableptr
ref proc handlerptr
ref ref overloadrec ovptr
[256]char str
int i,t,cmd
u64 fnptr,oldfnptr
record rec =
	int cmd
	ref void tableptr
	ref void handleptr
	ref ref overloadrec ovlist
end

static []rec table = (
	(ktostr,		&tostr_table,	&tostr_handler,			&tostr_list),
	(khardconv,		&convert_dtable,	&convert_handler,	&convert_list),
)

checkparam(a,toperator)
checkparam(b,ttype)
checkparam(c,trefproc)
cmd:=a^.value

for i to table.len do
	if table[i].cmd=cmd then
		tableptr:=table[i].tableptr
		handlerptr:=table[i].handleptr
		ovptr:=table[i].ovlist
		exit
	fi
else
	print @&.str,"Setoverload: can't find calltable:",cmdnames[cmd]+1
	pcerror(&.str)
od

t:=b^.value

tableptr^[t]:=cast(handlerptr)

addovrecord(ovptr, t, cast(c^.refptr))
end

proc pch_errorinfo(variant a,result)=
checkparam(a,tint)
result^.tagx:=tint
result^.value:=int64(err_pcptr)
end


proc getbounds(variant p,ref dimrec dims,int lower) =		!GETBOUNDS
int n

if not p then
	pcerror("New: no bounds")
fi

switch p^.tag
when noparamtag then
	dims^.lbound:=lower
	dims^.upper:=0
	dims^.length:=0
when trange then
	dims^.lbound:=p^.range_lower
	dims^.upper:=p^.range_upper
	dims^.length:=p^.range_upper-p^.range_lower+1
	if dims^.length<0 then
		dims^.length:=0
		dims^.upper:=dims^.lbound-1
	fi
else
	n:=getintvalue(p)
	dims^.lbound:=lower
	dims^.upper:=dims^.length:=n
endswitch
end

function checkparam(variant p,int tag,defaultx=nodefault)int64=

case p^.tag
when tvoid then
	if defaultx=nodefault then
		pcerror("Missing host param")
	fi
	return defaultx
when tag then
	return p^.value
esac

if tag=tint then
	case p^.tag
	when treal then
		return p^.xvalue
	esac
fi
cpl ttname[p^.tag]
pcerror("Host param wrong type")
return 0
end

proc leftstring(variant a, int n, variant result)=
object p


pc_makestring(a.objptr.ustr.strptr,n,result)
end

proc rightstring(variant a, int n, variant result)=
object p

pc_makestring(a.objptr.ustr.strptr+(a.objptr.ustr.length-n),n,result)
end

proc padstring_right(variant a,int n, fillchar, variant result)=
ref char s
int length

length:=a.objptr.ustr.length

pc_makestringn(n,result)
s:=result.objptr.ustr.strptr

if length then
	memcpy(s,a.objptr.ustr.strptr,length)
	s+:=length
fi
to n-length do
	s^:=fillchar
	++s
od
end

proc padstring_left(variant a,int n, fillchar, variant result)=
ref char s
int length,padlen

length:=a.objptr.ustr.length
padlen:=n-length

pc_makestringn(n,result)

s:=result.objptr.ustr.strptr
s+:=padlen

if length then
	memcpy(s,a.objptr.ustr.strptr,length)
fi
to padlen do
	--s
	s^:=fillchar
od
end

proc pcld_makevint(variant p,int64 a)=

p^.tagx:=tint
p^.value:=a
end

proc pcld_makelist(variant p,result,int n)=
variant q
object r

result^.tagx:=tlist ior hasrefmask


r:=list_new(n,1)

result.objptr:=r
q:=r.ulist.vptr

to n do
	q^:=p^
	pc_dupl(q)
	++q
	++p
od

end

proc getproctabledata(ref procrec p,variant result)=
[4]varrec table
varrec l
ref strec d
int moduleno

d:=p^.def

pc_makestring(d^.name,-1,&table[1])
pc_makestring(d^.metadata,-1,&table[2])

moduleno:=d^.ax_moduleno
pcld_makevint(&table[3],moduleno)

table[4].tagx:=trefproc
table[4].refptr:=cast(d^.pcaddress)

pcld_makelist(&table[1],result,4)
end

function convert_handler(int)ref intpc=
return nil
end

proc addtoproclist(ref strec d)=
	ref procrec pp
	++nproclist
	pp:=pcm_alloc(procrec.bytes)
	pp^.nextproc:=proclist
	proclist:=pp
	pp^.def:=d
end

function tostr_handler(variant p,FMTSTR,ref fmtrec fmt,object dest)ref intpc =
ref overloadrec q
varrec vdest
object vp

q:=tostr_list

q:=tostr_list
while q do
	if q^.optype=overloadtype then
		exit
	fi
	q:=q^.nextrec
od

if q=nil then
	cpl ttname[p^.tag]
	pcerror("tostr/overload")
fi

vdest.tagx:=tvoid
runproc(q^.pchandler,p,fmtstr,&vdest)
if vdest.tag<>tstring then
	PCERROR("custom tostr needs string result")
fi

vp:=vdest.objptr

if vp.ustr.length then
	addstring(dest,vp.ustr.strptr,vp.ustr.length)
fi
pc_unshare(&vdest)

return nil
end

function add_handler(variant p,FMTSTR,ref fmtrec fmt,object dest)ref intpc =
ref overloadrec q
varrec vdest
object vp

q:=tostr_list

q:=tostr_list
while q do
	if q^.optype=overloadtype then
		exit
	fi
	q:=q^.nextrec
od

if q=nil then
	cpl ttname[p^.tag]
	pcerror("tostr/overload")
fi

vdest.tagx:=tvoid
runproc(q^.pchandler,p,fmtstr,&vdest)
if vdest.tag<>tstring then
	PCERROR("custom tostr needs string result")
fi

vp:=vdest.objptr

if vp.ustr.length then
	addstring(dest,vp.ustr.strptr,vp.ustr.length)
fi
pc_unshare(&vdest)

return nil
end

proc addovrecord(ref ref overloadrec p, int t, ref intpc fnptr)=
ref overloadrec q

q:=pcm_allocz(overloadrec.bytes)
q^.optype:=t
q^.pchandler:=fnptr

q^.nextrec:=p^
p^:=q
end

function findapplproc(int fnindex)ref proc =
	ichar name
	int n,tp,OPT
	ref procinforec p

PCERROR("EXPORTS NOT DONE")

	return nil
end

global proc do_callapplproc(int fnindex, nargs, variant result)=
	ref proc fnaddr
	ref[12]byte paramlist
	int nparams, rettype, nextra, tag,na
	word64 a
	[100]word64 wordargs
	real64 x
	variant args, retv
	ref procinforec info

	fnaddr:=applproctable[fnindex].address
	if fnaddr=nil then
		fnaddr:=findapplproc(fnindex)
	fi
	info:=applproctable[fnindex].info

	rettype:=info.rettype
	nparams:=info.nparams
	paramlist:=&info^.paramlist

	args:=result-1				!point to first argument (increments downwards)

	nextra:=0
	if nparams>nargs then
		for i:=nargs+1 to nparams do
			unless paramlist[i] iand 0x40 then		!optional flag
				pcerror("callappl: too few args or not optional")
			end unless
		od
		nextra:=nparams-nargs

	elsif nparams<nargs then
		pcerror("callappl: too many args")
	fi

	na:=0
	for i:=nargs downto 1 do
		wordargs[++na]:=vartopack(args, paramlist[i] iand 63)		!get generic 64-bit value to push
		--args
	od

	a:=os_pushargs(&wordargs, na, nextra, fnaddr, rettype=tp_r64)
A:=0

	result.tagx:=packconvtypes[rettype]
	result.value:=a


	switch rettype
	when tp_pi8..tp_pi64 then result.uref.elemtag:=rettype-tp_pi8+ti8
	when tp_pu8..tp_pu64 then result.uref.elemtag:=rettype-tp_pu8+tu8
	when tp_variant then
		retv:=cast(a)
		result^:=retv^
	end
end

function vartopack(variant p, int tp)int64=
	int tag:=p.tag
	int64 a:=p.value
	ichar ss
	real xx

	switch tp
	when tp_variant then
		return cast(p)

	when tp_i64 then
		case tag
		when tint,tword then return a
		when treal then return int(p.xvalue)
		esac

	when tp_r64 then
		case tag
		when tint,tword then
			xx:=a
			return int@(xx)
		when treal then return int@(p.xvalue)
		esac

	when tp_stringz then
		case p.tag
		when tstring then
			ss:=convcstring(p.objptr.ustr.strptr,p.objptr.ustr.length)
			return word64@(ss)
		esac

	when tp_pi8..tp_pr64 then
		case ttbasetype[p.tag]
		when tarray then
			return int(p.objptr.uarray.ptr)
		when trefpacked then
			return a
		esac

	when tvoid then
		return 0
	endswitch

	println ttname[tag],"=>", packtypenames[tp]
	pcerror("vartopack?")
	return 0
end

export function dummyfn(int a,b,c)int=
CPL "DUMMY FN",a,b,c
	return a+b+c
end

export function pythag(int n)int=
	int count:=0
	for a:=1 to n do
		for b:=a to n do
			for c:=b to n*2 do
				if sqr a +sqr b= sqr c then
					++count
				fi
			od
		od
	od
	return count
end

export function new_random(variant a)variant result=
    int n,x

    result:=&applresult
    result.tagx:=tint          !assume int result (can be real too)
    result.value:=0
	RETURN RESULT

    if a.tag=trange then
        x:=mrandomrange(a.range_lower, a.range_upper)
    else
        checkparam(a,tint)
        n:=a.value
        if n>1 then                 !0 to n-1
            x:=mrandomint(n)
        elsif n=0 then              !pure rand
            x:=mrandom()
        elsif n=1 then              !0.0 to 0.99999999
            result.tagx:=treal
            result.xvalue:=mrandomreal()
            return result
        else
            pcerror("new_rand?")
        fi
    fi
    result.value:=x
    return result
end

export function new_heapvar(variant a)variant result=
variant p
	result:=&applresult
	result.tagx:=tint
	result.value:=12345679
	return result
end

export function mfib(int n)int=
	if n<3 then
		return 1
	else 
		return mfib(n-1)+mfib(n-2)
	fi
end

=== ccm_host. 22/56 ===
mut []ref void hosttable=(
	&pch_startprint,
	&pch_startprintcon,
	&pch_strstartprint,
	&pch_setformat,
	&pch_endprint,
	&pch_strendprint,
	&pch_print,
	&pch_dprint,
	&pch_println,
	&pch_printnogap,
	&pch_readln,
	&pch_sreadln,
	&pch_sread,
	&pch_rereadln,
	&pch_reread,
	&pch_strtoval,
	&pch_tostr,
	&pch_leftstr,
	&pch_rightstr,
	&pch_convlc,
	&pch_convuc,
	&pch_iconvlc,
	&pch_iconvuc,
	&pch_stop,
	&pch_stopx,
	&pch_ismain,
	&pch_waitkey,
	&pch_testkey,
	&pch_execwait,
	&pch_execcmd,
	&pch_shellexec,
	&pch_system,
	&pch_makestr,
	&pch_makestrslice,
	&pch_makeref,
	&pch_new,
	&pch_newheap,
	&pch_readlines,
	&pch_heapvar,
	&pch_dictitems,
	&pch_freeheap,
	&pch_setoverload,
	&pch_getcmdparam,
	&pch_gethostname,
	&pch_setpcerror,
	&pch_setdebug,
	&pch_test,
	&pch_ticks,
	&pch_sleep,
	&pch_random,
	&pch_findmetafunction,
	&pch_gethash,
	&pch_getos,
	&pch_gethostsize,
	&pch_iswindows,
	&pch_setmesshandler,
	&pch_setfprintf,
	&pch_loadpcl,
	&pch_runpcl,
	&pch_runtask,
	&pch_callext,
	&pch_pcldata,
	&pch_getcstring,
	&pch_getparam,
	&pch_clearlist,
	&pch_makelink,
	&pch_allparams,
	&pch_stackvars,
	&pch_makeempty,
	&pch_errorinfo,
)
=== pc_dxfns.m 23/56 ===
import mlib
import clib

import pc_types
import pc_decls
import pq_common
import pc_support
import pc_objlib
import pc_bignum
import pc_misc
import pc_pcfns

global proc dx_iorset(variant x,y) =
int xlen,ylen
int n,i
ref int p
object px,py
ref byte pp

px:=x.objptr
py:=y.objptr

xlen:=px.uset.length
ylen:=py.uset.length

if ylen=0 then		!x/[] + [] return X unchanged
elsif xlen=0 then		![] + y set x to y
	x^:=y^			!y won't be used again so x takes over copy bits
else				!x + y

	pc_duplvar(x)				!make independent copy if needed (note: can be inefficient if resize needed anyway)
	px:=x.objptr

	iresizeset(x,ylen)		!make sure x is at least as big as y

	iorsetbits(cast(px.uset.ptr),cast(py.uset.ptr),ylen)

	pc_unshare(y)
fi
end

global proc dx_iandset(variant x,y) =
int xlen,ylen
int n,i
ref int p
object px,py
ref byte pp

px:=x.objptr
py:=y.objptr

xlen:=px.uset.length
ylen:=py.uset.length

if ylen=0 then		!x/[] + [] return X unchanged
elsif xlen=0 then		![] + y set x to y
	x^:=y^			!y won't be used again so x takes over copy bits
else				!x + y

	pc_duplvar(x)				!make independent copy if needed (note: can be inefficient if resize needed anyway)
	px:=x.objptr
	iresizeset(x,ylen)		!make sure x is at least as big as y

	iandsetbits(cast(px.uset.ptr),cast(py.uset.ptr),ylen)

	pc_unshare(y)
fi
end

global proc dx_ixorset(variant x,y) =
int xlen,ylen
int n,i
ref int p
object px,py
ref byte pp

px:=x.objptr
py:=y.objptr

xlen:=px.uset.length
ylen:=py.uset.length

if ylen=0 then		!x/[] + [] return X unchanged
elsif xlen=0 then		![] + y set x to y
	x^:=y^			!y won't be used again so x takes over copy bits
else				!x + y

	pc_duplvar(x)				!make independent copy if needed (note: can be inefficient if resize needed anyway)
	px:=x.objptr
	iresizeset(x,ylen)		!make sure x is at least as big as y

	ixorsetbits(cast(px.uset.ptr),cast(py.uset.ptr),ylen)

	pc_unshare(y)
fi
end

global proc dx_inotset(variant x) =
object px

px:=x.objptr

if px.uset.length then
	pc_duplvar(x)				!make independent copy if needed (note: can be inefficient if resize needed anyway)
	px:=x.objptr
	inotsetbits(cast(px.uset.ptr),px.uset.length)
fi
end

global proc dx_subset(variant x,y)=
int xlen,ylen
object px,py

px:=x.objptr
py:=y.objptr

xlen:=px.uset.length
ylen:=py.uset.length

if xlen and ylen then		!x-y
	pc_dupl(x)
	px:=x.objptr
	iresizeset(x,ylen)		!make sure x is at least as big as y
	subsetbits(cast(px.uset.ptr),cast(py.uset.ptr),ylen)
fi				!else: []-y, x-[], []-[] all have x as result, so leave unchanged
pc_unshare(y)
end

global proc inotsetbits(ref int p,int n)=
int i
to (n-1)/64+1 do
	p^ :=inot p^
	++p
od
end

global proc iorsetbits(ref int p,q,int n)=
int i
to (n-1)/64+1 do
	p++^ ior:= q++^
od
end

global proc iandsetbits(ref int p,q,int n)=		!PC_IANDSETBITS
int i
to (n-1)/64+1 do
	p++^ iand:= q++^
od
end

global proc ixorsetbits(ref int p,q,int n)=		!PC_IXORSETBITS
int i
to (n-1)/64+1 do
	p++^ ixor:= q++^
od
end

global proc subsetbits(ref int p,q,int n)=		!PC_SUBSETBITS
int i
to (n-1)/64+1 do
	p^ ior:= q^
	p^ ixor:= q^
	++p
	++q
od
end

global proc iresizeset(variant p,int n)=
object pp

pp:=p.objptr

if pp.uset.length>=n then		!already large enough
	return
fi

bits_resize(pp,n)
end

global function dx_varinvar(variant x, y)int =		!DX_VARINVAR
int i,xt,yt,n,a
int64 nn,aa
variant p,q
object px,py

xt:=x.tag
yt:=ttbasetype[y.tag]

px:=x.objptr
py:=y.objptr

switch xt
when tint then
doi64invar::
	switch (yt)
	when tset then
		n:=x^.value
doi64inset::
		if u32(n)>=u32(py.uset.length) then	!out of bounds so not in set
			pc_unshare(y) when y.hasref
			return 0
		fi
		n:=testelem(cast(py.uset.ptr),n)
		pc_unshare(y)
		return n
	when tlist then
		a:=x.value
		n:=py.ulist.length
		p:=py.ulist.vptr
		for i to n do
			if p.tag=tint and p.value=a then
				pc_unshare(y) when y.hasref
				return i
			fi
			++p
		od
		pc_unshare(y)
		return 0
	when tarray then
		case py.uarray.elemtag
		when ti8,tu8 then
			n:=u8inarray(x.value,py)
		when ti16,tu16 then
			n:=u16inarray(x.value,py)
		when ti32,tu32 then
			n:=u32inarray(x.value,py)
		when ti64,tu64 then
			n:=u64inarray(x.value,py)
		else
			pcustypet("x in array",py.uarray.elemtag)
		esac
		pc_unshare(y)
		return n
	when tbits then
		case py.ubits.elemtag
		when tu1 then
			n:=bitinbits(x.value,py)
		else
			pcustypet("x in bits",py.ubits.elemtag)
		esac
		pc_unshare(y)
		return n
	when trange then
		n:=x^.value
		return n>=y.range_lower and n<=y.range_upper
	endswitch

when tstring then
	switch (yt)
	when tstring then
		n:=pc_strinstr(x,y)
		pc_unshare(x) when x.hasref
		pc_unshare(y) when y.hasref
		return n
	when tlist then
		n:=py.ulist.length
		p:=py.ulist.vptr
		i:=py.ulist.lower
		to n do
			if p.tag=tstring then
				if pc_eqstring_nf(x,p) then
					pc_unshare(x) when x.hasref
					pc_unshare(y) when y.hasref
					return i!-py^.lower
				fi 
			fi
			++p
			++i
		od
		pc_unshare(x) when x.hasref
		pc_unshare(y) when y.hasref
		return 0
	endswitch

else
	switch(yt)
	when tlist then		!x can be anything
		n:=py.ulist.length
		p:=py.ulist.vptr
		for i to n do
			if pc_equal_nf(x,p,1)=1 then
				pc_unshare(x) when x.hasref
				pc_unshare(y) when y.hasref
				return i
			fi
			++p
		od
		pc_unshare(x) when x.hasref
		pc_unshare(y) when y.hasref
		return 0
	endswitch
endswitch
pcmxtypes("varinvar:",x,y)
return 0
end

global function dx_mixed (variant x, y)int =		!DX_MIXED

switch x^.tag
when tint then
	switch y^.tag
	when treal then
		x^.xvalue:=x^.value
		x^.tagx:=treal
		return treal
	when tword then
		return tint
	when tbignum then
		bx_makeint(x^.value,x)
		return tbignum

	when tvoid then
		goto dxvoid

	else
		return 0
	endswitch
when treal then
	switch y^.tag
	when tint then
		y^.xvalue:=y^.value
		y^.tagx:=treal
		return treal
	when tvoid then
		goto dxvoid

	else
		return 0
	endswitch
when tword then
	switch y^.tag
	when tint then
		return tword
	when tvoid then
		goto dxvoid

	else
		return 0
	endswitch

when tbignum then
	switch y^.tag
	when tint then
		bx_makeint(y^.value,y)
		return tbignum
	else
		return 0
	endswitch

when tvoid then
dxvoid::
	pcerror("dxmix/void")

else
	if y^.tag=tvoid then
		goto dxvoid
	fi
	return 0
endswitch
return 0
end
=== pc_khandlers.m 24/56 ===
import clib
import mlib
import oslib

import pc_types
import pc_decls
import pc_support
import pc_objlib
import pc_print
import pq_common
import pc_host
import pc_oslayer
import pc_misc
import pc_bignum
import pc_jhandlers
import pc_pcfns
import pc_dxfns

global object zerostringobj

global byte stopped

global function k_zero:ref void =	! K_ZERO
	pclunimpl(kzero)
	return pcptr+1
end

global function k_nop:ref void =	! K_NOP
	return pcptr+1
end

global function k_procstart:ref void =	! K_PROCSTART
	pclunimpl(kprocstart)
	return pcptr+3
end

global function k_procend:ref void =	! K_PROCEND
	pclunimpl(kprocend)
	return pcptr+1
end

global function k_endmodule:ref void =	! K_ENDMODULE
	pclunimpl(kendmodule)
	return pcptr+1
end

global function k_push_m:ref void =	! K_PUSH_M
	--sptr
	sptr^:= variant(getopnda)^

	if sptr.hasref then
		++sptr^.objptr^.refcount
	fi
	return pcptr + 2
end

global function k_push_f:ref void =	! K_PUSH_F
	--sptr
	sptr^:=variant(frameptr+getopnda)^

	if sptr.hasref then
		++(sptr.objptr.refcount)
	fi
	return pcptr + 2
end

global function k_push_am:ref void =	! K_PUSH_AM
	--sptr
	sptr^.tagx:=trefvar
	sptr^.varptr:=variant(getopnda)
	return pcptr + 2
end

global function k_push_af:ref void =	! K_PUSH_AF
	--sptr
	sptr^.tagx:=trefvar
	sptr^.varptr:=variant(frameptr+getopnda)

	return pcptr + 2
end

global function k_push_ap:ref void =	! K_PUSH_AP
	--sptr
	sptr.tagx:=trefproc
	sptr.refptr:=ref byte(getopnda)
	return pcptr + 2
end

global function k_push_al:ref void =	! K_PUSH_AL
	--sptr
	sptr.tagx:=treflabel
	sptr.refptr:=ref byte(getopnda)
	return pcptr + 2
end

global function k_push_ci:ref void =	! K_PUSH_CI
	--sptr
	sptr.tagx:=tint
	sptr.value:=getopnda

	return pcptr + 2
end

global function k_push_cw:ref void =	! K_PUSH_CW
	--sptr
	sptr^.tagx:=tword
	sptr^.uvalue:=getopnda
	return pcptr + 2
end

global function k_push_cr:ref void =	! K_PUSH_CR
	--sptr
	sptr^.tagx:=treal
	sptr^.uvalue:=getopnda

	return pcptr + 2
end

global function k_push_cn:ref void =	! K_PUSH_CN
	--sptr
	sptr^.tagx:=trange
	sptr^.uvalue:=getopnda

	return pcptr + 2
end

global function k_push_cs:ref void =	! K_PUSH_CS
	--sptr
	sptr^.tagx:=tstring ior hasrefmask

	sptr^.objptr:=object(getopnda)
	++sptr^.objptr^.refcount

	return pcptr+2
end

global function k_push_t:ref void =	! K_PUSH_T
	--sptr
	sptr^.tagx:=ttype
	sptr^.value:=getopnda
	return pcptr + 2
end

global function k_push_op:ref void =	! K_PUSH_OP
	--sptr
	sptr^.tagx:=toperator
	sptr^.value:=getopnda			!operator code (is a pcl cmd index)
	sptr^.uop.opdims:=getopndb			!number of operands expected, 1 or 2
	return pcptr + 3
end

global function k_pushz:ref void =	! K_PUSHZ
--sptr
sptr^.tagx:=getopnda
sptr^.value:=0
return pcptr + 2
end

global function k_pushz_void:ref void =	! K_PUSHZ_VOID
--sptr
sptr^.tagx:=tvoid
return pcptr + 1
end

global function k_pushz_str:ref void =	! K_PUSHZ_STR
ref proc f

--sptr

sptr^.objptr:=emptystring
sptr^.tagx:=tstring ior hasrefmask
++emptystring^.refcount

return pcptr+1
end

global function k_pushz_list:ref void =	! K_PUSHZ_LIST
ref proc f
--sptr
sptr^.tagx:=tlist ior hasrefmask
sptr^.objptr:=emptylist
++emptylist^.refcount

return pcptr+1
end

global function k_pushz_listl:ref void =	! K_PUSHZ_LISTL
object p

--sptr
sptr^.tagx:=tlist ior hasrefmask
sptr.objptr:=list_new(0,getopnda)

return pcptr+2
end

global function k_pushz_set:ref void =	! K_PUSHZ_SET
--sptr
sptr^.tagx:=tset ior hasrefmask
sptr^.objptr:=emptyset
++emptyset^.refcount
return pcptr+1
end

global function k_pushz_arrayl:ref void =	! K_PUSHZ_ARRAYL
pclunimpl(kpushz_arrayl)
return pcptr+3
end

global function k_pop_m:ref void =	! K_POP_M
variant a

a:=variant(getopnda)
pc_unshare(a) when a^.hasref
a^:=sptr++^
return pcptr + 2
end

global function k_pop_f:ref void =	! K_POP_F
variant a

a:=variant(frameptr+getopnda)

pc_unshare(a) when a^.hasref

a^:=sptr++^					!transfer reference to a

return pcptr + 2
end

global function k_store_m:ref void =	! K_STORE_M
variant a

a:=variant(getopnda)

pc_share(sptr) when sptr.hasref
pc_unshare(a) when a^.hasref
a^:=sptr^
return pcptr + 2
end

global function k_store_f:ref void =	! K_STORE_F
variant a

a:=variant(frameptr+getopnda)
pc_share(sptr) when sptr.hasref
pc_unshare(a) when a^.hasref
a^:=sptr^
return pcptr + 2
end

global function k_pushptr:ref void =	! K_PUSHPTR
switch sptr^.tag
when trefvar then
	sptr^:=(sptr^.varptr)^
	if sptr.hasref then
		++sptr^.objptr^.refcount
	fi

when trecordlink then				!convert trecordlink to record
	sptr^.tagx:=sptr^.uref.elemtag ior hasrefmask
	++sptr^.objptr^.refcount

when trefpacked then
	pc_loadpacked(sptr^.uref.ptr,sptr^.uref.elemtag,sptr,nil)
when trefbit then
	pc_loadbit(sptr^.uref.ptr,sptr^.uref.bitoffset,sptr^.uref.elemtag,sptr^.uref.bitlength,sptr)
else
	pcustype("pushptr",sptr)
endswitch

return pcptr+1
end

global function k_popptr:ref void =	! K_POPPTR
variant p,q

p:=sptr++			!p is pointer p^:=sptr


switch p^.tag
when trefvar then		!
	q:=p^.varptr			!dest var
	pc_unshare(q) when q^.hasref
	q^:=sptr++^
when tstring then
	pc_storestring(p,sptr)
	++sptr
else
	pc_storeptr(p,sptr)		!pop to p^
	++sptr
end
return pcptr + 1
end

global function k_storeptr:ref void =	! K_STOREPTR
variant p,q

p:=sptr++			!p is pointer p^:=sptr

if p^.tag=trefvar then
	q:=p^.varptr			!dest var
	pc_share(sptr) when sptr.hasref
	pc_unshare(q) when q^.hasref
	q^:=sptr^
else
	pc_storeptr(p,sptr)		!pop to p^
	pc_unshare(sptr) when sptr.hasref
fi
return pcptr + 1
end

global function k_zpop_m:ref void =	! K_ZPOP_M
variant a

a:=variant(getopnda)
a^:=sptr++^					!transfer reference

return pcptr + 2
end

global function k_zpop_f:ref void =	! K_ZPOP_F
variant a

a:=variant(frameptr+getopnda)
a^:=sptr++^					!transfer reference

return pcptr + 2
end

global function k_zstore_m:ref void =	! K_ZSTORE_M
pclunimpl(kzstore_m)
return pcptr+2
end

global function k_zstore_f:ref void =	! K_ZSTORE_F
variant a

a:=variant(frameptr+getopnda)
a^:=sptr^
pc_share(a) when a^.hasref
if sptr.hasref then
	++sptr^.objptr^.refcount
fi
return pcptr + 2
end

global function k_copy:ref void =	! K_COPY
if not sptr.hasref then
	return pcptr+1
fi

pc_dupl(sptr)

return pcptr+1
end

global function k_swap:ref void =	! K_SWAP
[1024]byte tempbuffer
variant x,y
varrec v
int xt,yt,s,t,n
ref byte p,q
int a

x:=sptr++
y:=sptr++
xt:=x^.tag
yt:=y^.tag

if xt=trefvar and yt=trefvar then
	v:=(x^.varptr)^
	(x^.varptr)^:=(y^.varptr)^
	(y^.varptr)^:=v
elsif xt=trefpacked and yt=trefpacked then
	s:=x^.uref.elemtag
	t:=y^.uref.elemtag
	if s<>t then goto swaperror fi
	n:=ttsize[s]
	case n
	when 1 then
		p:=x^.uref.ptr
		q:=y^.uref.ptr
		a:=p^
		p^:=q^
		q^:=a
	elsif ttsize[s]<=tempbuffer.bytes then
		memcpy(&tempbuffer,x^.uref.ptr,n)
		memcpy(x^.uref.ptr,y^.uref.ptr,n)
		memcpy(y^.uref.ptr,&tempbuffer,n)
	else
		goto swaperror
	esac

else
swaperror::
	pcmxtypes("SWAP",x,y)
fi
return pcptr + 1
end

global function k_convptr:ref void =	! K_CONVPTR
variant a
int tag,elemtype
ref void p
object pa

switch sptr^.tag
when trefvar then
	a:=sptr^.varptr
	pa:=a^.objptr
	switch ttbasetype[a^.tag]
	when tint,tword then
		p:=&a^.value
		elemtype:=ti64
	when treal then
		p:=&a^.value
		elemtype:=tr64
	when tarray then
		p:=pa.uarray.ptr
		elemtype:=a.objptr.uarray.elemtag
	when tstring then
		p:=pa.ustr.strptr
		elemtype:=tu8
		if p=nil then
			p:=""
		fi
	when tstruct then
		p:=pa.ustruct.ptr
		elemtype:=a^.tag
	else
		if a^.hasref then
			p:=pa
			elemtype:=tvoid
			goto done
		fi
		CPL gettypename(ttbasetype[a^.tag])
		pcustype("Getrefpack1",a)
		return pcptr
	end switch
when trefpacked,trefbit then
	return pcptr+1

else
	pcustype("Getrefpack2",sptr)
	return pcptr
endswitch
done::

sptr^.tagx:=trefpacked
sptr^.uref.ptr:=p
sptr^.uref.elemtag:=elemtype

return pcptr + 1
end

global function k_jump:ref void =	! K_JUMP
return ref int(getopnda)
end

global function k_jumpptr:ref void =	! K_JUMPPTR
if sptr^.tag<>treflabel then
	pcerror("Bad label ptr")
fi
pcptr:=ref intpc(sptr^.refptr)
++sptr
return pcptr
end

global function k_jumptrue:ref void =	! K_JUMPTRUE
return jumptrue_table[sptr^.tag]^()
end

global function k_jumpfalse:ref void =	! K_JUMPFALSE
return jumpfalse_table[sptr^.tag]^()
end

global function k_jumpdef:ref void =	! K_JUMPDEF
if sptr^.tag<>tvoid then
	pc_unshare(sptr) when sptr.hasref
	++sptr
	return ref intpc(getopnda)
fi
pc_unshare(sptr) when sptr.hasref
++sptr

return pcptr + 2
end

global function k_jumpvoid:ref void =	! K_JUMPVOID
if sptr^.tag=tvoid then		!for now, allow tnone as void
	pc_unshare(sptr) when sptr.hasref
	++sptr
	return ref intpc(getopnda)
fi
pc_unshare(sptr) when sptr.hasref
++sptr

return pcptr + 2
end

global function k_jumpeq:ref void =	! K_JUMPEQ
int yt

yt:=sptr^.tag

if (sptr+1)^.tag=yt then
	return jumpeq_table[yt]^()
fi

opc_tableptr:=&jumpeq_table
return jumpeq_dtable[sigmap[(sptr+1)^.tag,yt]]^()
end

global function k_jumpne:ref void =	! K_JUMPNE
int yt

yt:=sptr^.tag


if (sptr+1)^.tag=yt then
	return jumpne_table[yt]^()
fi

opc_tableptr:=&jumpne_table
return jumpne_dtable[sigmap[(sptr+1)^.tag,yt]]^()
end

global function k_jumplt:ref void =	! K_JUMPLT
int yt

yt:=sptr^.tag

if (sptr+1)^.tag=yt then
	return jumplt_table[yt]^()
fi

opc_tableptr:=&jumplt_table
return jumplt_dtable[sigmap[(sptr+1)^.tag,yt]]^()
end

global function k_jumple:ref void =	! K_JUMPLE
int yt

yt:=sptr^.tag

if (sptr+1)^.tag=yt then
	return jumple_table[yt]^()
fi

opc_tableptr:=&jumple_table
return jumple_dtable[sigmap[(sptr+1)^.tag,yt]]^()
end

global function k_jumpge:ref void =	! K_JUMPGE
variant y
int yt

yt:=sptr^.tag

if (sptr+1)^.tag=yt then
	switch yt
	when tint then
		y:=sptr++
		if sptr^.value>=y^.value then
			++sptr
			return ref intpc(getopnda)
		fi
		++sptr
		return pcptr+2
	else
		return jumpge_table[yt]^()
	end
fi

opc_tableptr:=&jumpge_table
return jumpge_dtable[sigmap[(sptr+1)^.tag,yt]]^()
end

global function k_jumpgt:ref void =	! K_JUMPGT
variant y
int yt

yt:=sptr^.tag

if (sptr+1)^.tag=yt then
	switch yt
	when tint then
		y:=sptr++
		if sptr^.value>y^.value then
			++sptr
			return ref intpc(getopnda)
		fi
		++sptr
		return pcptr+2
	else
		return jumpgt_table[yt]^()
	end
fi

opc_tableptr:=&jumpgt_table
return jumpgt_dtable[sigmap[(sptr+1)^.tag,yt]]^()
end

global function k_jumptesteq:ref void =	! K_JUMPTESTEQ
variant x,y
int xt,yt,res
object py

y:=sptr++
x:=sptr
xt:=x^.tag
yt:=y^.tag

if xt<>yt then
	if xt:=dx_mixed(x,y) then
		goto retry
	fi
	xt:=x^.tag
	yt:=y^.tag
	switch xt
	when tint then
		switch (yt)
		when trange then
			if x^.value<y^.range_lower or x^.value>y^.range_upper then	!out of range, so false
				return pcptr + 2					!x<>y don't jump, just skip
			fi
		when tset then
			py:=y^.objptr
			if py.uset.length=0 or x.value>=py.uset.length or 
				not testelem(cast(py.uset.ptr),x.value) then 	!not in set, so false
				return pcptr + 2					!x<>y skip
			fi
		else						!type mismatch assume x<>y, so skip
			return pcptr + 2					!x<>y skip
		endswitch
	else							!other types assume x<>y as can't match
		return pcptr + 2					!x<>y skip
	endswitch
	++sptr
	return ref intpc(getopnda)
fi
retry::

switch xt
when tint,ttype then
	if x^.value=y^.value then
		++sptr		!pop x
		return ref intpc(getopnda)
	fi

when treal then
	if x^.xvalue=y^.xvalue then
		++sptr		!pop x
		return ref intpc(getopnda)
	fi
when trange then
	if x^.value=y^.value then
		++sptr		!pop x
		return ref intpc(getopnda)
	fi
when tstring then
	res:=pc_eqstring_nf(x,y)
	pc_unshare(y) when y^.hasref
	if res then
		pc_unshare(x) when x^.hasref
		++sptr
		return ref intpc(getopnda)
	fi
else
	res:=pc_equal_nf(x,y,0)
	pc_unshare(x) when x^.hasref
	pc_unshare(y) when y^.hasref
	if res then
		++sptr		!pop x
		return ref intpc(getopnda)
	fi
endswitch
return pcptr + 2
end

global function k_jumptestne:ref void =	! K_JUMPTESTNE
variant x,y
int xt,yt,res
object px,py


y:=sptr++
x:=sptr
xt:=x^.tag
yt:=y^.tag

if xt<>yt then
	if xt:=dx_mixed(x,y) then
		goto retry
	fi
	xt:=x^.tag			!will be unequal
	yt:=y^.tag
	switch (xt)
	when tint then
		switch (yt)
		when trange then
			if x^.value>=y^.range_lower and x^.value<=y^.range_upper then	!in range, so false
				++sptr
				return pcptr + 2
			fi
		when tset then
			py:=y^.objptr
			if x.value<py.uset.length and testelem(cast(py.uset.ptr),x.value) then 	!in set, so false
				++sptr
				return pcptr + 2
			fi
		endswitch
	endswitch
		return ref intpc(getopnda)
fi
retry::

switch xt
when tint,ttype then
	if x^.value<>y^.value then
		return ref intpc(getopnda)
	fi
	++sptr
when treal then
	if x^.xvalue<>y^.xvalue then
		return ref intpc(getopnda)
	fi
	++sptr
when trange then
	if x^.value<>y^.value then
		return ref intpc(getopnda)
	fi
	++sptr
when tstring then
	res:=pc_eqstring_nf(x,y)
	pc_unshare(y) when y^.hasref
	if not res then
		return ref intpc(getopnda)
	fi
	pc_unshare(x) when x^.hasref
	++sptr 
else
	res:=pc_equal_nf(x,y,0)
	pc_unshare(y) when y^.hasref
	if not res then
		return ref intpc(getopnda)
	fi
	pc_unshare(x) when x^.hasref
	++sptr
endswitch
return pcptr + 2
end

global function k_jumplabel:ref void =	! K_JUMPLABEL
pclunimpl(kjumplabel)
return pcptr+2
end

global function k_jumpclabel:ref void =	! K_JUMPCLABEL
pclunimpl(kjumpclabel)
return pcptr+3
end

global function k_switch:ref void =	! K_SWITCH
int index,n,lower

n:=getopnda
lower:=getopndb

case sptr^.tag
when tint,ttype then
else
CPL ttname[sptr^.tag]
	pcerror("switch not int")
esac
index:=(sptr++)^.value-lower		!now 0-based index

if u32(index)>=u32(n) then			!out of range
	return ref int((pcptr+n*2+4)^)
else					!in range
	return ref int((pcptr+index*2+4)^)	!+3 for sw cmd + 1 to label part of (kjumptable,label) pair
fi
end

global function k_cswitch:ref void =	! K_CSWITCH
pclunimpl(kcswitch)
return pcptr+4
end

global function k_new:ref void =	! K_NEW
pclunimpl(knew)
return pcptr + 1
end

global function k_to_f:ref void =	! K_TO_F
if --(variant(frameptr+getopndb))^.value then
	return ref intpc(getopnda)
else
	return pcptr + 3
fi
end

global function k_for_fci:ref void =	! K_FOR_FCI
if ++((variant(frameptr+getopndb))^.value)<=getopndc then
	return ref intpc(getopnda)
else
	return pcptr + 4
fi
end

global function k_for_ff:ref void =	! K_FOR_FF
if ++((variant(frameptr+getopndb))^.value)<=((variant(frameptr+getopndc))^.value) then
	return ref int(getopnda)
else
	return pcptr + 4
fi
end

global function k_ford_fci:ref void =	! K_FORD_FCI
if --((variant(frameptr+getopndb))^.value)>=getopndc then
	return ref intpc(getopnda)
else
	return pcptr + 4
fi
end

global function k_ford_ff:ref void =	! K_FORD_FF
if --((variant(frameptr+getopndb))^.value)>=((variant(frameptr+getopndc))^.value) then
	return ref intpc(getopnda)
else
	return pcptr + 4
fi
end

global function k_call:ref void =	! K_CALL
const countinterval=10
static int count=countinterval
static ref byte dummyfp
int  ticks

if --count=0 then
	count:=countinterval
	os_peek()
fi

if sptr<=stacklimit then
	PCERROR("STACK OVERFLOW")
fi


(--sptr)^.tagx:=tretaddr

sptr^.uret.retaddr:=pcptr+3

sptr^.uret.frameptr_low:=int32@(frameptr)
sptr^.uret.stackadj:=getopndb
frameptr:=cast(sptr)

return ref intpc(getopnda)
end

global function k_callptr:ref void =	! K_CALLPTR
ref intpc newpc

if sptr^.tag<>trefproc then
	cpl ttname[sptr^.tag]
	pcerror("callptr: not refproc")
fi
newpc:=ref intpc(sptr^.value)

if getopnda<>(newpc-1)^ then
	cpl getopnda,(newpc-1)^
	pcerror("callptr wrong # params")
fi

sptr^.tagx:=tretaddr
sptr^.uret.retaddr:=pcptr+3

sptr^.uret.frameptr_low:=int32@(frameptr)
sptr^.uret.stackadj:=getopndb
frameptr:=cast(sptr)

return newpc
end

global function k_return:ref void =	! K_RETURN
if sptr^.tag<>tretaddr then
	cpl ttname[sptr^.tag]
	pcerror("Return error")
fi
sptr^.tag:=0
pcptr:=sptr^.uret.retaddr
(ref int32(&frameptr))^:=sptr^.uret.frameptr_low

sptr:=variant((ref byte(sptr)+sptr^.uret.stackadj))
++sptr

return pcptr
end

global function k_startdll:ref void =	! K_STARTDLL
if ++dllcallindex>maxdllindex then
	pcerror("nested dll max")
fi
dllcallstack[dllcallindex]:=dllindex	!remember dllindex just before params are pushed
return pcptr + 1
end

global function k_pushdll:ref void =	! K_PUSHDLL
int s,t,u
object p

if ++dllindex>(maxdllindex-1) then	!allow 1-elem margin in case this is a double
	pcerror("dll params")
fi

s:=sptr^.tag

if s=tvoid then
	pcerror("pushdll void arg")
fi

t:=ttbasetype[getopnda]
u:=tword


switch t
when tvoid then				!used in variadic params; type is not known
	t:=s

	switch s
	when tstring then
		dllparams[dllindex]:=cast(convCstring(sptr^.objptr.ustr.strptr,
			sptr.objptr.ustr.length))
	else
		dllparams[dllindex]:=sptr^.value
	endswitch

	if s=treal then u:=treal fi

when ti64,tu64,ti32,tu32 then
	if $targetbits=32 then
	fi
	case s
	when tint,tword then
	when treal then
		sptr^.value:=sptr^.xvalue
	when trefpacked then
		sptr^.value:=int64(sptr^.uref.ptr)
	else
error::
		cpl ttname[s],"should be",ttname[t]
		pcerror("DLL: param wrong type")
	esac
	dllparams[dllindex]:=sptr^.value

when tr64 then
	if $targetbits=32 then
	fi
	case s
	when tint,tword then
		sptr^.xvalue:=sptr^.value
	when treal then
	else
		goto error
	esac
	u:=treal
	dllparams[dllindex]:=sptr^.value

when tstring then
	case s
	when tstring then
		p:=sptr^.objptr
		dllparams[dllindex]:=cast(convCstring(p.ustr.strptr,p.ustr.length))
	when tint then
		if sptr^.value<>0 then
			goto error
		fi
		dllparams[dllindex]:=0
	else
		goto error
	esac

when trefpacked then
	if sptr.hasref then
		dllparams[dllindex]:=int64(sptr.objptr.uarray.ptr)
	else
		dllparams[dllindex]:=int64(sptr.refptr)
	fi
when trefm,tintm,twordm,tu16 then
	dllparams[dllindex]:=sptr^.value
else
CPL TTNAME[T]
pcerror("OTHER DLL PARAM")
	dllparams[dllindex]:=sptr^.value
endswitch


dlltypes[dllindex]:=u

if sptr^.tag=tstring then
	pc_unshare(sptr) when sptr.hasref
fi

++sptr					!pop stack

return pcptr + 2
end

global function k_calldll:ref void =	! K_CALLDLL
int nparams,offset

if dllcallindex<=0 then
	pcerror("calldll??")
fi
offset:=dllcallstack[dllcallindex]		!dll param index just before the first param
nparams:=dllindex-offset

os_calldll(getopndb,getopnda,offset,nparams,getopndc,sptr)

dllindex:=dllcallstack[dllcallindex]
--dllcallindex

return pcptr + 4
end

global function k_callhost:ref void =	! K_CALLHOST
callhostfunction(getopnda,0)
return pcptr+2
end

global function k_stackframe:ref void =	! K_STACKFRAME
int i,n

n:=getopnda

to n do
	(--sptr)^.tagx:=tvoid
	sptr^.value:=0
od

return pcptr + 2
end

global function k_free:ref void =	! K_FREE
int i,n
object p

n:=getopnda
to n do

	pc_unshare(sptr) when sptr.hasref
	++sptr
od
return pcptr + 2
end

global function k_addsp:ref void =	! K_ADDSP
sptr:=variant((ref byte(sptr)+getopnda))
return pcptr+2
end

global function k_stop:ref void =	! K_STOP
stopped:=1
return pcptr			!return same instruction allow loop unfolding
end

global function k_test:ref void =	! K_TEST
pclunimpl(ktest)
return pcptr+2
end

global function k_makelist:ref void =	! K_MAKELIST
int n,lower

n:=getopnda
lower:=getopndb

pc_makelist(n,sptr,sptr+n-1,lower)
sptr+:=(n-1)

return pcptr + 3
end

global function k_makerecord:ref void =	! K_MAKERECORD
int n,t

n:=getopnda
t:=getopndb

pc_makerecord(n,t,sptr,sptr+n-1)
sptr+:=(n-1)

return pcptr + 3
end

global function k_makearray:ref void =	! K_MAKEARRAY
int n,lower,t

n:=getopnda
lower:=getopndb
t:=getopndc
if ttbasetype[t]=tarray then
	pc_makearray(n,t,getopndd,lower,sptr,sptr+n-1)
else
PCERROR("MAKEBITS")
fi
sptr+:=(n-1)

return pcptr + 5
end

global function k_makestruct:ref void =	! K_MAKESTRUCT
int n,t

n:=getopnda
t:=getopndb

pc_makestruct(n,t,sptr,sptr+n-1)
sptr+:=(n-1)

return pcptr + 3
end

global function k_makeset:ref void =	! K_MAKESET
int n

n:=getopnda
pc_makeset(n,sptr,sptr+n-1)
sptr+:=(n-1)

return pcptr + 2
end

global function k_makerange:ref void =	! K_MAKERANGE
variant x,y
y:=sptr++
pc_makerange(sptr,y,sptr)

return pcptr + 1
end

global function k_makedict:ref void =	! K_MAKEDICT
int n

n:=getopnda

pc_makedict(n,sptr,sptr+n*2-1)
sptr+:=(n*2-1)
return pcptr + 2
end

global function k_pushdot:ref void =	! K_PUSHDOT
variant x,p
int index,j,k,n,fieldtype,needfree
ref byte xptr
int i,dx,ix
ref genfielddatarec gd,gd0
varrec v

v:=sptr^

case v.tag
when trecordlink then
	v.tagx:=v.uref.elemtag
elsif not v.hasref then
	pcerror("pushdot/not record")
esac

xptr:=cast(v.objptr.urec.vptr)

gd0:=gd:=&genfielddata[ix:=genfieldnames[getopnda].dataindex]
n:=genfieldnames[getopnda].datalength

to n do
	if gd.recordtype=v.tag then	!find matching entry in field data
		fieldtype:=gd.fieldtype
		if fieldtype=tvariant then			!record type
			sptr^:=variant((xptr+gd^.offset))^
			if sptr.hasref then
				++(sptr.objptr.refcount)
			fi
			pc_unshare(&v) when v.hasref
			return pcptr + 2

		elsif fieldtype=trefproc then		!method name
			dx:=gd-gd0
			sptr^.tagx:=trefproc
			sptr^.refptr:=cast(genfieldpcaddress[ix+(gd-gd0)])
			pc_unshare(&v) when v.hasref
			return pcptr + 2
		else						!struct type
			pc_loadpacked(xptr+gd^.offset,fieldtype,sptr,nil)
			pc_unshare(&v) when v.hasref
			return pcptr + 2
		fi
	fi
	++gd
od

cpl "Field:",ngenfieldnames,genfieldnames[getopnda].name
pcustypet("Dotg: wrong record type",v.tag)
return pcptr
end

global function k_pushdotref:ref void =	! K_PUSHDOTREF
varrec v
variant p
int index,n,xtag,fieldtype,isrefvar,rectype,offset
ref genfielddatarec gd

v:=sptr^

case v.tag
when trefvar then
	p:=v.varptr				!point to ref target
	isrefvar:=1
	rectype:=p^.tag		!record/struct type pointed to

	if rectype=trecordlink then
		rectype:=p^.uref.elemtag
	fi
	unless p.objptr.urec.mutable then
		p^.objptr:=copyonwrite(p^.objptr,p^.tag)
	end

when trefpacked then
	isrefvar:=0
	rectype:=v.uref.elemtag		!struct type pointed to

else
	pcustype("&dotg not ref",&v)
	return pcptr
esac


gd:=&genfielddata[genfieldnames[getopnda].dataindex]
n:=genfieldnames[getopnda].datalength

to n do
	if gd^.recordtype=rectype then	!find matching entry in field data
		fieldtype:=gd^.fieldtype
		offset:=gd^.offset
		if isrefvar then			!assume fieldtype will be variant
			if fieldtype=tvariant then		!p points to record var
				sptr.refptr:=ref byte(p^.objptr.urec.vptr)+offset	!modify refvar to point to field

			else					!refvar points to struct
				sptr^.tagx:=trefpacked
				sptr^.refptr:=p.objptr.uarray.ptr+offset	!modify refvar to point to field
				sptr^.uref.elemtag:=fieldtype
			fi
		else					!was ref, presumably to a packed struct
			sptr^.uref.ptr +:= offset
			sptr^.uref.elemtag:=fieldtype
		fi
		return pcptr+2
	fi
	++gd
od

pcustypet("&Dotg: wrong record type",rectype)

return pcptr + 2
end

global function k_softconv:ref void =	! K_SOFTCONV
int t

t:=getopnda
sptr^.tagx:=t
return pcptr + 2
end

global function k_hardconv:ref void =	! K_HARDCONV
int s,t

s:=sptr^.tag
t:=getopnda

if sptr^.tag<>t then
	pc_iconvert(t,sptr)
fi
return pcptr+2
end

global function k_mixed:ref void =	! K_MIXED
pclunimpl(kmixed)
return pcptr+1
end

global function k_incrptr:ref void =	! K_INCRPTR
variant p
varrec v

p:=sptr++

switch ttbasetype[p^.tag]
when trefvar then			!increment what ptr points to
	p:=p^.varptr
	switch p^.tag
	when tint then
		++p^.value
	when trefvar then			!incr the pointer
		++p^.varptr
	when trefpacked then			!incr the pointer
		p^.uref.ptr+:=ttsize[p^.uref.elemtag]
	else
		pcustype("incrptr/refvar",p)
	endswitch
when trefpacked then			!incr the packed type pointed to
	switch p^.uref.elemtag
	when tu8,ti8 then

		++(p^.uref.ptr)^
	else
		pcustypet("incrptr/ref",p^.uref.elemtag)
	endswitch

else
	pcustype("incrptr",p)
endswitch
return pcptr + 1
end

global function k_incrto_m:ref void =	! K_INCRTO_M
variant a

a:=variant(getopnda)

switch ttbasetype[a^.tag]
when tint  then
	++a^.value
when trefvar then
	++a^.varptr
when trefpacked then
	a^.uref.ptr+:=ttsize[a^.uref.elemtag]
else
	pcustype("INCRTO_M",a)
endswitch

return pcptr + 2
end

global function k_incrto_f:ref void =	! K_INCRTO_F
variant a
int offset

a:=variant(frameptr+getopnda)

switch a^.tag
when tint then
	++a^.value
	return pcptr+2
when trefvar then
	++a^.varptr

when trefpacked then
	a^.uref.ptr+:=ttsize[a^.uref.elemtag]
when trefbit then
	if a^.uref.bitlength then
PCERROR("INCR/BITFIELD")
	fi
	offset:=a^.uref.bitoffset+stdtypewidths[a^.uref.elemtag]
	if offset>=8 then
		offset:=0
		++a^.uref.ptr
	fi
	a^.uref.bitoffset:=offset
else
	pcustype("INCRTO_F",a)
endswitch

return pcptr + 2
end

global function k_loadincr:ref void =	! K_LOADINCR
varrec ptr

ptr:=sptr^				!copy of pointer

pc_loadptr(sptr,sptr)			

--sptr
sptr^:=ptr

return k_incrptr()				!increment the target looks after pcptr too
end

global function k_incrload:ref void =	! K_INCRLOAD
ref int pc
varrec ptr

ptr:=sptr^				!copy of pointer
pc:=k_incrptr()				!increment the target looks after pcptr too
pc_loadptr(&ptr,--sptr)			
return pc
end

global function k_decrptr:ref void =	! K_DECRPTR
variant p
varrec v

p:=sptr++

switch ttbasetype[p^.tag]
when trefvar then			!decrement what ptr points to
	p:=p^.varptr
	switch p^.tag
	when tint then
		--p^.value
	when trefvar then			!decr the pointer
		--p^.varptr
	when trefpacked then			!decr the pointer
		p^.uref.ptr-:=ttsize[p^.uref.elemtag]
	else
		pcustype("decrptr/refvar",p)
	endswitch
when trefpacked then			!decr the packed type pointed to
	switch (p^.uref.elemtag)
	when ti32 then
		--(p^.uref.ptr64)^
	when tu8,ti8 then
		--(p^.uref.ptr)^
	else
		pcustypet("decrptr/ref",p^.uref.elemtag)
	endswitch

else
	pcustype("decrptr",p)
endswitch
return pcptr + 1
end

global function k_decrto_m:ref void =	! K_DECRTO_M
variant a

a:=variant(getopnda)

switch a^.tag
when tint then
	--a^.value
when trefvar then
	--a^.varptr
when trefpacked then
	a^.uref.ptr-:=ttsize[a^.uref.elemtag]
else
	pcustype("DECRTO_M",a)
endswitch

return pcptr + 2
end

global function k_decrto_f:ref void =	! K_DECRTO_F
variant a

a:=variant(frameptr+getopnda)

switch a^.tag
when tint then
	--a^.value
when trefvar then
	--a^.varptr
when trefpacked then
	a^.uref.ptr-:=ttsize[a^.uref.elemtag]
else
	pcustype("DECRTO_F",a)
endswitch

return pcptr + 2
end

global function k_loaddecr:ref void =	! K_LOADDECR
varrec ptr

ptr:=sptr^				!copy of pointer

pc_loadptr(sptr,sptr)			
(--sptr)^:=ptr
return k_decrptr()				!decrement the target looks after pcptr too
end

global function k_decrload:ref void =	! K_DECRLOAD
ref int pc
varrec ptr

ptr:=sptr^				!copy of pointer
pc:=k_decrptr()				!increment the target looks after pcptr too
pc_loadptr(&ptr,--sptr)			
return pc
end

global function k_incr:ref void =	! K_INCR
pclunimpl(kincr)
return pcptr+1
end

global function k_decr:ref void =	! K_DECR
case sptr^.tag
when tint then
	--sptr^.value
else
	pcustype("decr",sptr)
esac
return pcptr+1
end

global function k_neg:ref void =	! K_NEG
return neg_table[sptr^.tag]^()
end

global function k_abs:ref void =	! K_ABS
return abs_table[sptr^.tag]^()
end

global function k_not:ref void =	! K_NOT
sptr^.value:=not sptr^.value
return pcptr+1
end

global function k_inot:ref void =	! K_INOT
return inot_table[sptr^.tag]^()
end

global function k_istrue:ref void =	! K_ISTRUE
return istrue_table[sptr^.tag]^()
end

global function k_asc:ref void =	! K_ASC
int a
object s

switch sptr^.tag
when tstring then
	s:=sptr.objptr
	if s.ustr.length=0 then
		a:=0
	else
		a:=(s.ustr.strptr)^
		pc_unshare(sptr) when sptr.hasref
	fi
	sptr^.tagx:=tint
	sptr^.value:=a
else
	pcustype("ASC",sptr)
endswitch
return pcptr + 1
end

global function k_chr:ref void =	! K_CHR

switch sptr^.tag
when tint then
	if sptr^.uvalue>255 then
		pcerror("chr>255")
	fi

	pc_makechar(sptr^.value,sptr)
else
	pcustype("CHR",sptr)
endswitch
return pcptr + 1
end

global function k_sqrt:ref void =	! K_SQRT
pcptr +:= 1
switch sptr^.tag
when tint then
	sptr^.tagx:=treal
	sptr^.xvalue:=sqrt(sptr^.value)
when treal then
	sptr^.xvalue:=sqrt(sptr^.xvalue)
else
	pcustype("SQRT",sptr)
endswitch
return pcptr
end

global function k_sqr:ref void =	! K_SQR
variant x
varrec result
x:=sptr

switch x^.tag
when tint then
	sptr^.value:=x^.value*x^.value
when treal then
	sptr^.xvalue:=x^.xvalue*x^.xvalue
when tbignum then
	bx_mul(x,x,&result)
	pc_unshare(x)
	sptr^:=result

else
	pcustype("SQR",x)
endswitch

return pcptr + 1
end

global function k_cube:ref void =	! K_CUBE
pclunimpl(kcube)
return pcptr+1
end

global function k_sin:ref void =	! K_SIN
variant x
x:=sptr

switch x^.tag
when treal then
	sptr^.xvalue:=sin(x^.xvalue)
else
	pcustype("SIN",x)
endswitch

return pcptr + 1
end

global function k_cos:ref void =	! K_COS
variant x
x:=sptr

switch x^.tag
when treal then
	sptr^.xvalue:=cos(x^.xvalue)
else
	pcustype("COS",x)
endswitch

return pcptr + 1
end

global function k_tan:ref void =	! K_TAN
pclunimpl(ktan)
return pcptr+1
end

global function k_asin:ref void =	! K_ASIN
pclunimpl(kasin)
return pcptr+1
end

global function k_acos:ref void =	! K_ACOS
pclunimpl(kacos)
return pcptr+1
end

global function k_atan:ref void =	! K_ATAN
variant x
x:=sptr

switch x^.tag
when tint then
	sptr^.xvalue:=atan(x^.value)
	sptr^.tagx:=treal
when treal then
	sptr^.xvalue:=atan(x^.xvalue)
else
	pcustype("ATAN",x)
endswitch

return pcptr+1
end

global function k_sign:ref void =	! K_SIGN
pclunimpl(ksign)
return pcptr+1
end

global function k_ln:ref void =	! K_LN
real x

switch sptr^.tag
when treal then
	sptr^.xvalue:=ln(sptr^.xvalue)
when tint then
	sptr^.xvalue:=ln(sptr.value)
	sptr.tag:=treal
else
	pcustype("LN",sptr)
endswitch

return pcptr + 1
end

global function k_log:ref void =	! K_LOG
pclunimpl(klog)
return pcptr+1
end

global function k_lg:ref void =	! K_LG
pclunimpl(klg)
return pcptr+1
end

global function k_exp:ref void =	! K_EXP
real x

switch sptr^.tag
when treal then
	sptr^.xvalue:=exp(sptr^.xvalue)
when tint then
	sptr^.xvalue:=exp(sptr.value)
	sptr.tag:=treal
else
	pcustype("EXP",sptr)
endswitch

return pcptr + 1
end

global function k_round:ref void =	! K_ROUND
variant x
x:=sptr

switch x^.tag
when treal then
	if x^.xvalue>=0.0 then
		sptr^.xvalue:=floor(x^.xvalue+0.5)
	else
		sptr^.xvalue:=ceil(x^.xvalue-0.5)
	fi
when tint then
else
	pcustype("ROUND",x)
endswitch

return pcptr + 1
end

global function k_floor:ref void =	! K_FLOOR
variant x
x:=sptr

switch x^.tag
when treal then
	if x^.xvalue>=0.0 then
		sptr^.xvalue:=floor(x^.xvalue)
	else
		sptr^.xvalue:=ceil(x^.xvalue)
	fi
else
	pcustype("ROUND",x)
endswitch

return pcptr + 1
end

global function k_ceil:ref void =	! K_CEIL
pclunimpl(kceil)
return pcptr+1
end

global function k_fract:ref void =	! K_FRACT
pclunimpl(kfract)
return pcptr+1
end

global function k_negto:ref void =	! K_NEGTO
pclunimpl(knegto)
return pcptr+1
end

global function k_absto:ref void =	! K_ABSTO
pclunimpl(kabsto)
return pcptr+1
end

global function k_notto:ref void =	! K_NOTTO
pclunimpl(knotto)
return pcptr+1
end

global function k_inotto:ref void =	! K_INOTTO
pclunimpl(kinotto)
return pcptr+1
end

global function k_len:ref void =	! K_LEN
return len_table[sptr^.tag]^()
end

global function k_lwb:ref void =	! K_LWB
return lwb_table[sptr^.tag]^()
end

global function k_upb:ref void =	! K_UPB
return upb_table[sptr^.tag]^()
end

global function k_bounds:ref void =	! K_BOUNDS
return bounds_table[sptr^.tag]^()
end

global function k_bits:ref void =	! K_BITS
case sptr^.tag
when ttype then
	sptr^.value:=ttbitwidth[sptr^.value]
else
	sptr^.value:=ttbitwidth[sptr^.tag]
esac

sptr^.tagx:=tint
return pcptr+1
end

global function k_bytes:ref void =	! K_BYTES
int m,n
object p

m:=sptr^.tag
if m=ttype then
	m:=sptr^.value
fi
p:=sptr^.objptr

case ttbasetype[m]
when tstring then
	n:=p.ustr.length
when tarray then
	n:=p.uarray.length*ttsize[p.uarray.elemtag]
when tset then
	n:=p.uset.length/8
when tbits then
	case p.ubits.elemtag
	when tbit then n:=p.ubits.length/8
	when tbit2 then n:=p.ubits.length/4
	when tbit4 then n:=p.ubits.length/2
	esac
when tlist then
	n:=p.ulist.length*varsize
else
	n:=ttsize[m]
esac

pc_unshare(sptr) when sptr.hasref

sptr^.tagx:=tint
sptr^.value:=n
return pcptr+1
end

global function k_type:ref void =	! K_TYPE
int res
res:=sptr^.tag
pc_unshare(sptr) when sptr.hasref

sptr^.tagx:=ttype
sptr^.value:=res

return pcptr + 1
end

global function k_elemtype:ref void =	! K_ELEMTYPE
int res

case ttbasetype[sptr^.tag]
when tarray then
	res:=sptr.objptr.uarray.elemtag
	pc_unshare(sptr)
when tbits then
	res:=sptr.objptr.ubits.elemtag
	pc_unshare(sptr)
when trefpacked,trefbit then
	res:=sptr.uref.elemtag
else
	pcerror("elemtype")
esac

sptr^.tagx:=ttype
sptr^.value:=res
return pcptr+1
end

global function k_basetype:ref void =	! K_BASETYPE
int res

if sptr^.tag=ttype then
	res:=ttbasetype[sptr^.value]
else
	res:=ttbasetype[sptr^.tag]
fi
pc_unshare(sptr) when sptr.hasref
sptr^.tagx:=ttype
sptr^.value:=res

return pcptr + 1
end

global function k_minval:ref void =	! K_MINVAL
int t
int64 a

switch (sptr^.tag)
when tint then
	t:=ti64
when treal then
	t:=tr64
when ttype then
	t:=sptr^.value
when tbignum then
	t:=tbignum
else
	pcustype("Maxval",sptr)
endswitch

case t
when tu8,tu16,tu32,tu64 then a:=0
when ti8 then a:=-128
when ti16 then a:=-32768
when ti32 then a:=-0x8000'0000
when ti64 then a:=-0x8000'0000'0000'0000
when tbignum then
 a:=-0x8000'0000'0000'0000
else
cpl gettypename(t)
	pcerror("MINVALUE")
esac
sptr^.tagx:=tint
sptr^.value:=a

return pcptr + 1
end

global function k_maxval:ref void =	! K_MAXVAL
int t
int64 a

switch (sptr^.tag)
when tint then
	t:=ti64
when treal then
	t:=tr64
when ttype then
	t:=sptr^.value
else
	pcustype("Maxval",sptr)
endswitch

case t
when tu8 then a:=255
when tu16 then a:=65536
when tu32 then a:=0xFFFF'FFFF
when tu64 then a:=0xFFFF'FFFF'FFFF'FFFF
when ti8 then a:=127
when ti16 then a:=32767
when ti32 then a:=0x7FFF'FFFF
when ti64 then a:=0x7FFF'FFFF'FFFF'FFFF
else
cpl gettypename(t)
	pcerror("MAXVALUE")
esac
sptr^.tagx:=tint
sptr^.value:=a

return pcptr + 1
end

global function k_isint:ref void =	! K_ISINT
if sptr^.tag=tint or sptr^.tag=tword then
	sptr^.value:=1
else
	pc_unshare(sptr) when sptr.hasref
	sptr^.value:=0
fi
sptr^.tagx:=tint
return pcptr + 1
end

global function k_isreal:ref void =	! K_ISREAL
if sptr^.tag=treal then
	sptr^.value:=1
else
	pc_unshare(sptr) when sptr.hasref
	sptr^.value:=0
fi
sptr^.tagx:=tint
return pcptr + 1
end

global function k_isstring:ref void =	! K_ISSTRING
int n

n:=(sptr^.tag=tstring)
pc_unshare(sptr) when sptr.hasref
sptr^.tagx:=tint
sptr^.value:=n
return pcptr + 1
end

global function k_isrange:ref void =	! K_ISRANGE
int n

n:=(sptr^.tag=trange)
pc_unshare(sptr) when sptr.hasref
sptr^.tagx:=tint
sptr^.value:=n
return pcptr + 1
end

global function k_isnumber:ref void =	! K_ISNUMBER
pclunimpl(kisnumber)
return pcptr+1
end

global function k_isarray:ref void =	! K_ISARRAY
int n
switch ttbasetype[sptr^.tag]
when tlist,tarray,tbits then
	n:=1
else
	n:=0
endswitch
pc_unshare(sptr) when sptr.hasref
sptr^.tagx:=tint
sptr^.value:=n
return pcptr + 1
end

global function k_isrecord:ref void =	! K_ISRECORD
int n
n:=0
switch ttbasetype[sptr^.tag]
when trecord,tstruct then
	n:=1
endswitch
pc_unshare(sptr) when sptr.hasref
sptr^.tagx:=tint
sptr^.value:=n
return pcptr + 1
end

global function k_ispointer:ref void =	! K_ISPOINTER
int n
switch ttbasetype[sptr^.tag]
when trefpacked,trefvar,trefbit,trefproc,treflabel then
	n:=1
else n:=0
endswitch
sptr^.tagx:=tint
sptr^.value:=n
return pcptr + 1
end

global function k_ismutable:ref void =	! K_ISMUTABLE
pclunimpl(kismutable)
return pcptr+1
end

global function k_isset:ref void =	! K_ISSET
int n
n:=ttbasetype[sptr^.tag]=tset
pc_unshare(sptr) when sptr.hasref
sptr^.tagx:=tint
sptr^.value:=n
return pcptr + 1
end

global function k_isvoid:ref void =	! K_ISVOID
if sptr^.tag=tvoid then
	sptr^.tagx:=tint
	sptr^.value:=1
else
	pc_unshare(sptr) when sptr.hasref
	sptr^.tagx:=tint
	sptr^.value:=0
fi
return pcptr + 1
end

global function k_isdef:ref void =	! K_ISDEF
if sptr^.tag<>tvoid then
	sptr^.tagx:=tint
	sptr^.value:=1
else
	pc_unshare(sptr) when sptr.hasref
	sptr^.tagx:=tint
	sptr^.value:=0
fi
return pcptr + 1
end

global function k_tostr:ref void =	! K_TOSTR
pclunimpl(ktostr)
return pcptr+1
end

global function k_isequal:ref void =	! K_ISEQUAL

variant x,y
int xt,yt

y:=sptr
x:=++sptr
xt:=x^.tag
yt:=y^.tag
if xt=trecordlink then
	xt:=x^.uref.elemtag
	x^.hasref:=1
fi
if yt=trecordlink then
	yt:=y^.uref.elemtag
fi

if xt=yt and x^.hasref then
	sptr^.tagx:=tint
	sptr^.value:=x^.objptr=y^.objptr
	return pcptr+1
fi

if (xt=tint and x^.value=0 and y^.hasref) or
   (yt=tint and y^.value=0 and x^.hasref) or
   (xt=tint and yt=tint and x^.value=0 and y^.value) then
	sptr^.tagx:=tint
	sptr^.value:=0
	return pcptr+1
fi
pcmxtypes("ISEQUAL",x,y)
return nil
end

global function k_add:ref void =	! K_ADD
variant y
int yt

yt:=sptr^.tag

if (sptr+1)^.tag=yt then
	switch yt
	when tint then
		y:=sptr++
		sptr^.value+:=y^.value
		return pcptr+1
	when treal then
		y:=sptr++
		sptr^.xvalue+:=y^.xvalue
		return pcptr+1
	else
		return add_table[yt]^()
	end
fi

opc_tableptr:=&add_table
return add_dtable[sigmap[(sptr+1)^.tag,yt]]^()
end

global function k_sub:ref void =
variant y
int yt

yt:=sptr^.tag

if (sptr+1)^.tag=yt then
	switch yt
	when tint then
		y:=sptr++
		sptr^.value-:=y^.value
		return pcptr+1
	when treal then
		y:=sptr++
		sptr^.xvalue-:=y^.xvalue
		return pcptr+1
	else
		return sub_table[yt]^()
	end
fi

opc_tableptr:=&sub_table
return sub_dtable[sigmap[(sptr+1)^.tag,yt]]^()
end

global function k_mul:ref void =	! K_MUL
variant y
int yt

yt:=sptr^.tag

if (sptr+1)^.tag=yt then
	switch yt
	when tint then
		y:=sptr++
		sptr^.value*:=y^.value
		return pcptr+1
	when treal then
		y:=sptr++
		sptr^.xvalue*:=y^.xvalue
		return pcptr+1
	else
		return mul_table[yt]^()
	end
fi

opc_tableptr:=&mul_table
return mul_dtable[sigmap[(sptr+1)^.tag,yt]]^()
end

global function k_div:ref void =	! K_DIV
variant y
int yt

yt:=sptr^.tag

if (sptr+1)^.tag=yt then
	switch yt
	when tint then
		y:=sptr++
		sptr^.xvalue:=real(sptr^.value)/real(y^.value)
		sptr^.tag:=treal
		return pcptr+1
	when treal then
		y:=sptr++
		sptr^.xvalue/:=y^.xvalue
		return pcptr+1
	else
		return div_table[yt]^()
	end
fi

opc_tableptr:=&div_table
return div_dtable[sigmap[(sptr+1)^.tag,yt]]^()
end

global function k_idiv:ref void =	! K_IDIV
variant y
int yt

yt:=sptr^.tag

if (sptr+1)^.tag=yt then
	switch yt
	when tint then
		y:=sptr++
		sptr^.value:=sptr^.value/y^.value
		return pcptr+1
	else
		return idiv_table[yt]^()
	end
fi

opc_tableptr:=&idiv_table
return idiv_dtable[sigmap[(sptr+1)^.tag,yt]]^()
end

global function k_rem:ref void =	! K_REM
variant y
int yt

yt:=sptr^.tag

if (sptr+1)^.tag=yt then
	switch yt
	when tint then
		y:=sptr++
		sptr^.value:=sptr^.value rem y^.value
		return pcptr+1
	else
		return rem_table[yt]^()
	end
fi

opc_tableptr:=&rem_table
return rem_dtable[sigmap[(sptr+1)^.tag,yt]]^()
end

global function k_divrem:ref void =	! K_DIVREM
variant x,y
int d
word div,remainder

y:=sptr
x:=++sptr
d:=x.value

if x.tag=y.tag=tint then
	x.range_lower:=d/y.value
	x.range_upper:=d rem y.value

	x.tagx:=trange

else
	pcmxtypes("DIVREM",x,y)
fi
return pcptr+1
end


global function k_iand:ref void =	! K_IAND
variant y
int yt

yt:=sptr^.tag

if (sptr+1)^.tag=yt then
	switch yt
	when tint then
		y:=sptr++
		sptr^.value iand:=y^.value
		return pcptr+1
	else
		return iand_table[yt]^()
	end
fi

opc_tableptr:=&iand_table
return iand_dtable[sigmap[(sptr+1)^.tag,yt]]^()
end

global function k_ior:ref void =	! K_IOR
variant y
int yt

yt:=sptr^.tag

if (sptr+1)^.tag=yt then
	switch yt
	when tint then
		y:=sptr++
		sptr^.value ior:=y^.value
		return pcptr+1
	else
		return ior_table[yt]^()
	end
fi

opc_tableptr:=&ior_table
return ior_dtable[sigmap[(sptr+1)^.tag,yt]]^()
end

global function k_ixor:ref void =	! K_IXOR
variant y
int yt

yt:=sptr^.tag

if (sptr+1)^.tag=yt then
	switch yt
	when tint then
		y:=sptr++
		sptr^.value ixor:=y^.value
		return pcptr+1
	else
		return ixor_table[yt]^()
	end
fi

opc_tableptr:=&ixor_table
return ixor_dtable[sigmap[(sptr+1)^.tag,yt]]^()
end

global function k_shl:ref void =	! K_SHL
variant y
int yt

yt:=sptr^.tag

if (sptr+1)^.tag=yt then
	switch yt
	when tint then
		y:=sptr++
		sptr^.value <<:=y^.value
		return pcptr+1
	else
		return shl_table[yt]^()
	end
fi

opc_tableptr:=&shl_table
return shl_dtable[sigmap[(sptr+1)^.tag,yt]]^()
end

global function k_shr:ref void =	! K_SHR
variant y
int yt

yt:=sptr^.tag

if (sptr+1)^.tag=yt then
	switch yt
	when tint then
		y:=sptr++
		sptr^.value >>:=y^.value
		return pcptr+1
	else
		return shr_table[yt]^()
	end
fi

opc_tableptr:=&shr_table
return shr_dtable[sigmap[(sptr+1)^.tag,yt]]^()
end

global function k_in:ref void =	! K_IN
variant x,y
int n

y:=sptr
x:=++sptr

n:=dx_varinvar(x,y)
sptr^.tagx:=tint
sptr^.value:=n

return pcptr + 1
end

global function k_notin:ref void =	! K_NOTIN
variant x,y
int n

y:=sptr
x:=++sptr

n:=dx_varinvar(x,y)
sptr^.tagx:=tint

sptr^.value:=not n

return pcptr + 1
end

global function k_inrev:ref void =	! K_INREV
pclunimpl(kinrev)
return pcptr+1
end

global function k_eq:ref void =	! K_EQ
variant x,y
int res

y:=sptr
x:=++sptr

res:=pc_equal(x,y,0)
sptr^.tagx:=tint
sptr^.value:=res
return pcptr + 1
end

global function k_ne:ref void =	! K_NE
variant x,y
int res

y:=sptr
x:=++sptr

res:=pc_equal(x,y,0)
sptr^.tagx:=tint
sptr^.value:=not res
return pcptr + 1
end

global function k_lt:ref void =	! K_LT
variant x,y
int res

y:=sptr
x:=++sptr

res:=pc_compare(x,y)
sptr^.tagx:=tint
sptr^.value:=res<0
return pcptr + 1
end

global function k_le:ref void =	! K_LE
variant x,y
int res

y:=sptr
x:=++sptr

res:=pc_compare(x,y)
sptr^.tagx:=tint
sptr^.value:=res<=0
return pcptr + 1
end

global function k_ge:ref void =	! K_GE
variant x,y
int res

y:=sptr
x:=++sptr

res:=pc_compare(x,y)
sptr^.tagx:=tint
sptr^.value:=res>=0
return pcptr + 1
end

global function k_gt:ref void =	! K_GT
variant x,y
int res

y:=sptr
x:=++sptr

res:=pc_compare(x,y)
sptr^.tagx:=tint
sptr^.value:=res>0
return pcptr + 1
end

global function k_min:ref void =	! K_MIN
variant y
int yt

yt:=sptr^.tag

if (sptr+1)^.tag=yt then
	switch yt
	when tint then
		y:=sptr++
		sptr^.value min:=y^.value
		return pcptr+1
	when treal then
		y:=sptr++
		sptr^.xvalue min:=y^.xvalue
		return pcptr+1
	else
		return min_table[yt]^()
	end
fi

opc_tableptr:=&min_table
return min_dtable[sigmap[(sptr+1)^.tag,yt]]^()
end

global function k_max:ref void =	! K_MAX
variant y
int yt

yt:=sptr^.tag

if (sptr+1)^.tag=yt then
	switch yt
	when tint then
		y:=sptr++
		sptr^.value max:=y^.value
		return pcptr+1
	when treal then
		y:=sptr++
		sptr^.xvalue max:=y^.xvalue
		return pcptr+1
	else
		return max_table[yt]^()
	end
fi

opc_tableptr:=&max_table
return max_dtable[sigmap[(sptr+1)^.tag,yt]]^()
end

global function k_concat:ref void =	! K_CONCAT
variant y
int yt

yt:=sptr^.tag

if (sptr+1)^.tag=yt then
	return concat_table[yt]^()
fi
pcmxtypes("CONCAT",sptr,sptr)
return pcptr+1
end

global function k_append:ref void =	! K_APPEND
return append_table[(sptr+1)^.tag]^()
end

global function k_power:ref void =	! K_POWER
variant x,y
int xt,yt
varrec result

y:=sptr
x:=++sptr
xt:=x^.tag
yt:=y^.tag


if xt<>yt then		!types are mixed
	if (xt:=dx_mixed(x,y))=0 then	!couldn't find a common type
		pcmxtypes("**MIXED",x,y)
	fi
fi

switch (xt)
when tint then
	sptr^.value:=ipower(x^.value,y^.value)
when treal then
	sptr^.xvalue:=pow(x^.xvalue,y^.xvalue)
when tbignum then
	bx_power(x,bx_int(y),&result)
	pc_unshare(x)
	pc_unshare(y) when y^.hasref
	sptr^:=result

else
	pcustype("**",x)
endswitch
return pcptr+1
end

global function k_atan2:ref void =	! K_ATAN2
pclunimpl(katan2)
return pcptr+1
end

global function k_addto:ref void =	! K_ADDTO
variant x
int yt
yt:=sptr^.tag

if (sptr+1)^.tag=trefvar then
	x:=(sptr+1)^.varptr
	if x^.tag=yt then
		return addto_table[yt]^()
	fi

	opc_tableptr:=&addto_table
	return addto_dtable[sigmap[x^.tag,yt]]^()

else
	pcerror("addto not ptr")
fi

pcmxtypes("addto",x,sptr)
return pcptr+1
end

global function k_subto:ref void =	! K_SUBTO
variant x
int yt
yt:=sptr^.tag

if (sptr+1)^.tag=trefvar then
	x:=(sptr+1)^.varptr
	if x^.tag=yt then
		return subto_table[yt]^()
	fi

	opc_tableptr:=&subto_table
	return subto_dtable[sigmap[x^.tag,yt]]^()

else
	pcerror("subto not ptr")
fi

pcmxtypes("subto",x,sptr)
return pcptr+1
end

global function k_multo:ref void =	! K_MULTO
variant x
int yt
yt:=sptr^.tag

if (sptr+1)^.tag=trefvar then
	x:=(sptr+1)^.varptr
	if x^.tag=yt then
		return multo_table[yt]^()
	fi
else
	pcerror("multo not ptr")
fi

pcmxtypes("multo",x,sptr)
return pcptr+1
end

global function k_divto:ref void =	! K_DIVTO
variant x
int yt
yt:=sptr^.tag

if (sptr+1)^.tag=trefvar then
	x:=(sptr+1)^.varptr
	if x^.tag=yt then
		return divto_table[yt]^()
	fi
else
	pcerror("divto not ptr")
fi

pcmxtypes("divto",x,sptr)
return pcptr+1
end

global function k_idivto:ref void =	! K_IDIVTO
variant x
int yt
yt:=sptr^.tag

if (sptr+1)^.tag=trefvar then
	x:=(sptr+1)^.varptr
	if x^.tag=yt then
		return idivto_table[yt]^()
	fi
else
	pcerror("idivto not ptr")
fi

pcmxtypes("idivto",x,sptr)
return pcptr+1
end

global function k_iandto:ref void =	! K_IANDTO
variant x,p
varrec ptr
int yt
ref intpc pc

yt:=sptr^.tag
p:=sptr+1

if p^.tag=trefvar then
	x:=p^.varptr
	if x^.tag=yt then
		return iandto_table[yt]^()
	fi
	pcmxtypes("iandto",x,sptr)
else
	ptr:=p^
	pc_loadptr(p,p)
	pc:=k_iand()
	pc_storeptr(&ptr,sptr++)
	return pc
fi

return pcptr+1
end

global function k_iorto:ref void =	! K_IORTO
variant x,p
varrec ptr
int yt
ref intpc pc

yt:=sptr^.tag
p:=sptr+1

if p^.tag=trefvar then
	x:=p^.varptr
	if x^.tag=yt then
		return iorto_table[yt]^()
	fi
	pcmxtypes("iorto",x,sptr)
else
	ptr:=p^
	pc_loadptr(p,p)
	pc:=k_ior()
	pc_storeptr(&ptr,sptr++)
	return pc
fi

return pcptr+1
end

global function k_ixorto:ref void =	! K_IXORTO
variant x,p
varrec ptr
int yt
ref intpc pc

yt:=sptr^.tag
p:=sptr+1

if p^.tag=trefvar then
	x:=p^.varptr
	if x^.tag=yt then
		return ixorto_table[yt]^()
	fi
	pcmxtypes("ixorto",x,sptr)
else
	ptr:=p^
	pc_loadptr(p,p)
	pc:=k_ixor()
	pc_storeptr(&ptr,sptr++)
	return pc
fi

return pcptr+1
end

global function k_shlto:ref void =	! K_SHLTO
variant x
int yt
yt:=sptr^.tag

if (sptr+1)^.tag=trefvar then
	x:=(sptr+1)^.varptr
	if x^.tag=yt then
		return shlto_table[yt]^()
	fi
else
	pcerror("Shlto not ptr")
fi

pcmxtypes("Shlto",x,sptr)
return pcptr+1
end

global function k_shrto:ref void =	! K_SHRTO
variant x
int yt
yt:=sptr^.tag

if (sptr+1)^.tag=trefvar then
	x:=(sptr+1)^.varptr
	if x^.tag=yt then
		return shrto_table[yt]^()
	fi
else
	pcerror("Shrto not ptr")
fi

pcmxtypes("Shrto",x,sptr)
return pcptr+1
end

global function k_minto:ref void =	! K_MINTO
variant x
int yt
yt:=sptr^.tag

if (sptr+1)^.tag=trefvar then
	x:=(sptr+1)^.varptr
	if x^.tag=yt then
		return minto_table[yt]^()
	fi
else
	pcerror("minto not ptr")
fi

pcmxtypes("minto",x,sptr)
return pcptr+1
end

global function k_maxto:ref void =	! K_MAXTO
variant x
int yt
yt:=sptr^.tag

if (sptr+1)^.tag=trefvar then
	x:=(sptr+1)^.varptr
	if x^.tag=yt then
		return maxto_table[yt]^()
	fi
else
	pcerror("maxto not ptr")
fi

pcmxtypes("maxto",x,sptr)
return pcptr+1
end

global function k_concatto:ref void =	! K_CONCATTO
if (sptr+1)^.tag=trefvar then
	return concatto_table[(sptr+1)^.varptr^.tag]^()
fi
pcerror("Concatto not ptr")
return pcptr+1
end

global function k_appendto:ref void =	! K_APPENDTO
if (sptr+1)^.tag=trefvar then
	return appendto_table[(sptr+1)^.varptr^.tag]^()
fi
pcerror("Appendto not ptr")
return pcptr+1
end

global function k_pushix:ref void =	! K_PUSHIX


return pushix_dtable[sigmap[(sptr+1)^.tag,sptr^.tag]]^()
end

global function k_pushdotix:ref void =	! K_PUSHDOTIX
return pushdotix_dtable[sigmap[(sptr+1)^.tag,sptr^.tag]]^()
end

global function k_pushkeyix:ref void =	! K_PUSHKEYIX
variant d,k,p

d:=sptr++			!d is the dict
k:=sptr			!k is the key

if d^.tag<>tdict then
	pcustype("keyix",d)
fi

p:=finddictitem(d,k,0)

pc_unshare(d)
pc_unshare(k) when k^.hasref

if p then			!found
	sptr^:=p^
	return pcptr+1
fi
sptr^.tagx:=tvoid		!return none when not found
return pcptr+1
end

global function k_pushkeyixd:ref void =	! K_PUSHKEYIXD
variant d,k,p,def

def:=sptr++			!def is any default value to be used
d:=sptr++			!d is the dict
k:=sptr			!k is the key
if d^.tag<>tdict then
	pcustype("keyix",d)
fi

p:=finddictitem(d,k,0)
pc_unshare(d)
pc_unshare(k) when k^.hasref

if p then			!found
	sptr^:=p^
	pc_unshare(def) when def^.hasref
	return pcptr+1
fi
sptr^:=def^			!use given default value when not found
return pcptr+1
end

global function k_pushixref:ref void =	! K_PUSHIXREF
variant p
ref int qq

p:=sptr+1

if p^.tag=trefvar then
	return pushixref_dtable[sigmap[p^.varptr^.tag,sptr^.tag]]^()
fi
return pcerror("pushixref/not ptr")
end

global function k_pushdotixref:ref void =	! K_PUSHDOTIXREF
variant p

p:=sptr+1

if p^.tag=trefvar then
	return pushdotixref_dtable[sigmap[p^.varptr^.tag,sptr^.tag]]^()
fi
pcerror("pushdotixref/not ptr")
return pcptr+1
end

global function k_pushkeyixref:ref void =	! K_PUSHKEYIXREF
variant d,k,p,pd

d:=sptr^.varptr			!d is the dict
k:=++sptr				!k is the key

if d^.tag<>tdict then
	pcustype("keyixref",d)
fi

p:=finddictitem(d,k,1)
pc_unshare(k) when k^.hasref

sptr^.tagx:=trefvar
sptr^.varptr:=p
return pcptr+1
end

global function k_pushbyteix:ref void =	! K_PUSHBYTEIX
int64 a
word index
variant x

if sptr^.tag<>tint then
	pcerror("byteix/bad index")
fi
index:=sptr^.value
++sptr
if sptr^.tag<>tint then
	pcerror("byteix/not int")
fi
a:=sptr^.value

case getopnda
when tu8 then
	if index>=8 then
		if index>=12 then
			pcerror("byteix bounds")
		fi
		a:=sptr^.uret.frameptr_low
		sptr^.value:=(a>>((index-8)*8)) iand 255

	else
		sptr^.value:=(a>>(index*8)) iand 255
	fi
else
	pcerror("byteix/bad type")
esac
return pcptr+2
end

global function k_pushbyteixref:ref void =	! K_PUSHBYTEIXREF
ref byte a
word index
variant p

if sptr^.tag<>tint then
	pcerror("&byteix/bad index")
fi
index:=sptr^.value
++sptr
if sptr^.tag<>trefvar then
	pcerror("&byteix/not ptr")
fi
p:=sptr^.varptr
if p^.tag<>tint then
	pcerror("&bytix/not int")
fi
sptr^.tagx:=trefpacked

case getopnda
when tu8 then
	if index>=8 then
		if index>=12 then
			pcerror("&byteix bounds")
		fi
		sptr^.uref.ptr:=ref byte(p)+index-4
	else
		sptr^.uref.ptr:=ref byte(p)+8+index
	fi
	sptr^.uref.elemtag:=tu8
else
	pcerror("&byteix/bad type")
esac
return pcptr+2
end

global function k_appendset:ref void =	! K_APPENDSET
pclunimpl(kappendset)
return pcptr+1
end

global function k_pushdotm:ref void =	! K_PUSHDOTM
pclunimpl(kpushdotm)
return pcptr+3
end

global function k_pushdott:ref void =	! K_PUSHDOTT
pclunimpl(kpushdott)
return pcptr+3
end

global function k_push_ad:ref void =	! K_PUSH_AD
(--sptr)^.tagx:=trefdllproc
sptr^.refptr:=ref void(dllproctable[getopnda].address)
return pcptr+2
end

global function k_push_try:ref void =	! K_PUSH_TRY
(--sptr)^.tagx:=texception
sptr^.refptr:=ref byte(getopnda)
sptr^.uexcept.frameoffset:=frameptr-ref byte(sptr)		!byte offset
sptr^.uexcept.exceptiontype:=getopndb
sptr^.uexcept.nexceptions:=getopndc
return pcptr+4
end

global function k_raise:ref void =	! K_RAISE

if sptr^.tag<>tint then
		pcerror("Raise: not Int on stack [not proceeding direct to RAISE]")
fi
return raiseexception(sptr^.value)				!will unwind stack and set pcptr to address of exception code
end

global function k_applyop:ref void =	! K_APPLYOP
static [10]intpc codeseq

codeseq[1]:=cast(cmdmap[sptr^.value])
if sptr^.tag<>toperator then
	pcerror("Apply:no op")
fi
if sptr^.uop.opdims<>getopnda then
cpl getopnda,sptr^.uop.opdims
	pcerror("Apply:wrong #opnds")
fi

++sptr
codeseq[2]:=(pcptr+2)^			!copy jump lab which follows the applyop
codeseq[3]:=(pcptr+3)^			!include the dest label
return &codeseq[1]				!pass control this short sequence
end

global function k_makeiter:ref void =	! K_MAKEITER
object p
p:=sptr^.objptr
sptr^.uiter.itcount:=p.ulist.length+1			!pre-increment

case sptr^.tag
when tlist then							!list keeps it's +refcount during loop
	sptr.varptr:=p.ulist.vptr				!point to first element (ptr can be nil for empty list)
	sptr.tagx:=trefvar
	sptr.uiter.ittype:=tlist
when tstring then
	sptr.uref.ptr:=cast(p.ustr.strptr)			!point to first char
	sptr.tagx:=trefpacked				!doesn't make use of refelemtag
	sptr.uiter.ittype:=tstring
else
	pcustype("makeiter",sptr)
esac

return pcptr+2
end

global function k_forall:ref void =	! K_FORALL
variant pit, ploopvar, pelem

pit:=variant(frameptr+getopndb)		!p should point to refvar used as iterator
ploopvar:=variant(frameptr+getopndc)

if --pit^.uiter.itcount<=0 then			!end reached
	return pcptr+4
fi
if ploopvar^.hasref then			!assume won't get to zero as copy as in list
	--ploopvar^.objptr^.refcount
fi

case pit^.uiter.ittype
when tlist then
	pelem:=pit^.varptr
	ploopvar^:=pelem^
	if ploopvar^.hasref then ++ploopvar^.objptr^.refcount fi
	++pit^.varptr
when tstring then
	pc_makechar(pit^.uref.ptr^,ploopvar)
	++pit^.uref.ptr
else
	pcerror("forall/type?")
esac
return ref intpc(getopnda)
end

global function k_forallx:ref void =	! K_FORALLX
pclunimpl(kforallx)
return pcptr+5
end

global function k_foreach:ref void =	! K_FOREACH
pclunimpl(kforeach)
return pcptr+4
end

global function k_foreachx:ref void =	! K_FOREACHX
pclunimpl(kforeachx)
return pcptr+5
end

global function k_expandrange:ref void =	! K_EXPANDRANGE
variant x

x:=sptr--
sptr^.tagx:=tint
sptr^.value:=x^.range_upper
x^.value:=x^.range_lower
x^.tagx:=tint

return pcptr+1
end

global function k_callappl:ref void =
	int index, nargs

	index:=getopnda
	nargs:=getopndb


	do_callapplproc(index, nargs, sptr+nargs)

	to nargs do
		pc_unshare(sptr) when sptr.hasref
		++sptr
	od

	return pcptr+3
end
=== pc_assembb.m 25/56 ===


import clib
import Mlib
import oslib

import pc_types
import pc_decls
import pc_support
import pc_khandlers
import pq_common
import pc_pcfns

const dooptimise=1

const cc_copy=0
const cc_copy16=cc_copy<<16

const kopnda	= 8
const kopndb	= 16
const kopndc	= 24
const kopndd	= 32
const varsize	= 16
const varshift	= 4
const intpsize	= 8

const intpsize2	= intpsize*2
const intpsize4	= intpsize*4
const intpsize6	= intpsize*6

const copymask	= 0x10000
const hasrefmask= 0x10000
const xa		= 0
const xb		= varsize
const xc		= varsize*2
const ya		= 0
const yb		= varsize
const za		= 0

const kdataindex	= 8
const kdatalength	= 12

const krecordtype	= 4
const kfieldtype	= 8
const kfieldoffset	= 12

const ktag			= 0
const khasref		= 2
const kstackadj		= 3
const kopdims		= 3
const kittype		= 3
const krefelemtag	= 4
const kitcount		= 4
const kbndigits		= 4
const kvarptr		= 8
const kobjptr		= 8
const kpackptr		= 8
const kvalue		= 8
const kretaddr		= 8
const kframeptr_low	= 4
const krange_lower	= 8
const krange_upper	= 12

const jrefcount		= 0
const jelemtag		= 22
const jobjtype		= 6
const jmutable		= 7
const jptr			= 8
const jstrptr		= 8
const jvptr			= 8

const jlength		= 16
const jlower		= 20
const jallocated	= 24
const jobjptr2		= 24


macro cloadregs  =
	assem
		mov Dprog,[pcptr]
		mov Dsptr,[sptr]
		mov Dframe,[frameptr]
	end

macro csaveregs  =
	assem
		mov [pcptr],Dprog
		mov [sptr],Dsptr
		mov [frameptr],Dframe
	end

macro jumpnext   =
	assem
		mov D0,[Dprog]
		jmp D0
	end


macro saveregs   =
	assem
		mov [pcptr],Dprog
		mov [sptr],Dsptr
		mov [frameptr],Dframe
	end

macro loadregs   =
	assem
		mov Dprog,D0; mov Dsptr,[sptr]; mov Dframe,[frameptr]
	end

macro bjumpnext  =
	assem
		mov D0,[Dprog]; jmp D0
	end

macro pushvar    = asm sub Dsptr, varsize

macro popvar     = asm add Dsptr, varsize

macro pushvar2   = asm sub Dsptr, varsize+varsize

macro popvar2    = asm add Dsptr, varsize+varsize

macro pushvar3   = asm sub Dsptr, varsize+varsize+varsize

macro jumpskip1  =
	assem
		add Dprog,8
		*jumpnext
	end

macro jumpskip2  =
	assem
		add Dprog,16
		*jumpnext
	end

macro jumpskip3  =
	assem
		add Dprog,24
		*jumpnext
	end

macro jumpskip4  =
	assem
		add Dprog,32
		*jumpnext
	end

macro jumpskip5  =
	assem
		add Dprog,40
		*jumpnext
	end

macro loadskip1  =
	assem
		mov Dsptr,[sptr]
		mov Dframe,[frameptr]
		mov Dprog,[pcptr]
		add Dprog,8
		*jumpnext
	end

macro loadskip2  =
	assem
		mov Dsptr,[sptr]
		mov Dframe,[frameptr]
		mov Dprog,[pcptr]
		add Dprog,16
		*jumpnext
	end

macro callvxufree_d4    =
	assem
		mov D10,D4
		*csaveregs
		call pc_unshare
		*cloadregs
	end

macro callvxufree_dsptr =
	assem
		mov D10, Dsptr
		*csaveregs
		call pc_unshare
		*cloadregs
	end

macro callfreex_dsptr   =
	assem
		mov D10,Dsptr
		*csaveregs
		call pc_free
		*cloadregs
	end

macro callfreex      =
	assem
		*csaveregs
		call pc_free
		*cloadregs
	end


macro callm(fn) =
	assem
		sub dstack,32
		call fn
		add dstack,32
	end

include "CCASM_FN."

function optimise_asm(ref intpc p, int cmd)ref intpc=
ref intpc q
int64 a,b
int n

q:=p+cmdnopnds[cmd]+1			!point to following bytecode
if not dooptimise then
	return q
fi

case cmd
when kpush_f then
	case (p+2)^
	when kpush_f then			!push_f, push_f
		case (p+4)^
		when kpush_f then		!=> jx_push_fff
			p^:=intpc(&jx_push_fff)
			(p+2)^:=(p+3)^
			(p+3)^:=(p+5)^
			return p+6
		when kadd then			!=> jx_add_ff
			p^:=intpc(&jx_add_ff)
			(p+2)^:=(p+3)^
			return p+5
		when ksub then			!=> jx_sub_ff
			p^:=intpc(&jx_sub_ff)
			(p+2)^:=(p+3)^
			return p+5
		when kjumpeq then
			p^:=intpc(&jx_jumpeq_ff)
			(p+2)^:=(p+3)^
			(p+3)^:=(p+5)^
			return p+6
		when kjumpne then
			p^:=intpc(&jx_jumpne_ff)
			(p+2)^:=(p+3)^
			(p+3)^:=(p+5)^
			return p+6
		when kjumplt then
			p^:=intpc(&jx_jumplt_ff)
			(p+2)^:=(p+3)^
			(p+3)^:=(p+5)^
			return p+6
		when kjumple then
			p^:=intpc(&jx_jumple_ff)
			(p+2)^:=(p+3)^
			(p+3)^:=(p+5)^
			return p+6
		when kjumpge then
			p^:=intpc(&jx_jumpge_ff)
			(p+2)^:=(p+3)^
			(p+3)^:=(p+5)^
			return p+6
		when kjumpgt then
			p^:=intpc(&jx_jumpgt_ff)
			(p+2)^:=(p+3)^
			(p+3)^:=(p+5)^
			return p+6
		when kpushix then
			p^:=intpc(&jx_pushix_ff)
			(p+2)^:=(p+3)^
			return p+5
		else					!=> jx_push_ff
			p^:=intpc(&jx_push_ff)
			(p+2)^:=(p+3)^
			return p+4
		esac

	when kpush_m then			!=> jx_push_fm
		p^:=intpc(&jx_push_fm)
		(p+2)^:=(p+3)^
		return p+4

	when kpush_ci then			!push_f, push_ci
		case (p+4)^
		when kadd then			!=> jx_add_fci
			p^:=intpc(&jx_add_fci)
			(p+2)^:=(p+3)^
			return p+5
		when ksub then			!=> jx_sub_fci
			p^:=intpc(&jx_sub_fci)
			(p+2)^:=(p+3)^
			return p+5
		when kjumpeq then
			p^:=intpc(&jx_jumpeq_fci)
			(p+2)^:=(p+3)^
			(p+3)^:=(p+5)^
			return p+6
		when kjumpne then
			p^:=intpc(&jx_jumpne_fci)
			(p+2)^:=(p+3)^
			(p+3)^:=(p+5)^
			return p+6
		when kjumplt then
			p^:=intpc(&jx_jumplt_fci)
			(p+2)^:=(p+3)^
			(p+3)^:=(p+5)^
			return p+6
		when kjumple then
			p^:=intpc(&jx_jumple_fci)
			(p+2)^:=(p+3)^
			(p+3)^:=(p+5)^
			return p+6
		when kjumpge then
			p^:=intpc(&jx_jumpge_fci)
			(p+2)^:=(p+3)^
			(p+3)^:=(p+5)^
			return p+6
		when kjumpgt then
			p^:=intpc(&jx_jumpgt_fci)
			(p+2)^:=(p+3)^
			(p+3)^:=(p+5)^
			return p+6
		else					!=> jx_push_fci
			p^:=intpc(&jx_push_fci)
			(p+2)^:=(p+3)^
			return p+4
		esac

	when kpop_m then			!=> jx_move_mf
		p^:=intpc(&jx_move_mf)
		a:=(p+1)^
		b:=(p+3)^
		(p+1)^:=b
		(p+2)^:=a
		return p+4

	when kpop_f then			!=> jx_move_ff
		p^:=intpc(&jx_move_ff)
		a:=(p+1)^
		b:=(p+3)^
		(p+1)^:=b
		(p+2)^:=a
		return p+4
	when kzpop_f then			!=> jx_zmove_ff
		p^:=intpc(&jx_zmove_ff)
		a:=(p+1)^
		b:=(p+3)^
		(p+1)^:=b
		(p+2)^:=a
		return p+4
	when kswitch then
		p^:=intpc(&jx_switch_f)
		(p+2)^:=(p+3)^
		(p+3)^:=(p+4)^
		return p+5


	when klen then
		p^:=intpc(&jx_len_f)
		return p+3
	when kjumpdef then
		p^:=intpc(&jx_jumpdef_f)
		(p+2)^:=(p+3)^
		return p+4

	when kjumpvoid then
		p^:=intpc(&jx_jumpvoid_f)
		(p+2)^:=(p+3)^
		return p+4
	when kpushptr then
		p^:=intpc(&jx_pushptr_f)
		return p+3
	esac

when kpush_m then
	case (p+2)^
	when kpush_m then			!=> jx_push_mm
		p^:=intpc(&jx_push_mm)
		(p+2)^:=(p+3)^
		return p+4

	when kpush_ci then			!=> jx_push_mci
		p^:=intpc(&jx_push_mci)
		(p+2)^:=(p+3)^
		return p+4
	when kpop_m then			!=> jx_move_mm
		p^:=intpc(&jx_move_mm)
		a:=(p+1)^
		b:=(p+3)^
		(p+1)^:=b
		(p+2)^:=a
		return p+4
	when kpop_f then			!=> jx_move_fm
		p^:=intpc(&jx_move_fm)
		a:=(p+1)^
		b:=(p+3)^
		(p+1)^:=b
		(p+2)^:=a
		return p+4
	esac

when kpush_ci then
	case (p+2)^
	when kpop_m then			!=> jx_move_mci
		p^:=intpc(&jx_move_mci)
		a:=(p+1)^
		b:=(p+3)^
		(p+1)^:=b
		(p+2)^:=a
		return p+4
	when kpop_f then			!=> jx_move_fci
		p^:=intpc(&jx_move_fci)
		a:=(p+1)^
		b:=(p+3)^
		(p+1)^:=b
		(p+2)^:=a
		return p+4
	when kzpop_f then			!=> jx_zmove_fci
		p^:=intpc(&jx_zmove_fci)
		a:=(p+1)^
		b:=(p+3)^
		(p+1)^:=b
		(p+2)^:=a
		return p+4
	esac

when kpushz_void then
	case (p+1)^
	when kpushz_void then
		if (p+2)^=kpushz_void then
			p^:=intpc(jx_pushz_void3)
			return p+3
		fi
		p^:=intpc(jx_pushz_void2)
		return p+2
	esac

when kpush_af then
	case (p+2)^
	when kpush_f then
		if (p+4)^=kpushixref and (p+5)^=kpopptr then
			p^:=intpc(jx_popix_ff)
			(p+2)^:=(p+3)^
			return p+5					!start processing from popptr as that could be used
		elsif (p+4)^=kaddto then
			p^:=intpc(&jx_addto_ff)
			(p+2)^:=(p+3)^
			return p+5
		fi
	when kpush_ci then
		if (p+4)^=kaddto then
			p^:=intpc(&jx_addto_fci)
			(p+2)^:=(p+3)^
			return p+5
		fi
	when kloadincr then
		case (p+3)^
		when kpushptr then
			p^:=intpc(&jx_pushincrptr_f)
			return (p+3)				!takes 4, but do the pushptr as it might be needed
		when kpopptr then
			p^:=intpc(&jx_popincrptr_f)
			return (p+3)				!takes 4, but do the pushptr as it might be needed
		esac

	esac

when kpush_am then
	case (p+2)^
	when kloadincr then
		case (p+3)^
		when kpushptr then
			p^:=intpc(&jx_pushincrptr_m)
			return (p+3)				!takes 4, but do the pushptr as it might be needed
		when kpopptr then
			p^:=intpc(&jx_popincrptr_m)
			return (p+3)				!takes 4, but do the pushptr as it might be needed
		esac
	esac

when kfree then
	n:=(p+1)^
	if n>=1 and n<=10 then
		p^:=getfreelabel(n)
		return p+2
	fi
when kisint,kisreal,kisstring,kisrange,kisnumber,kisarray,kisrecord,
	kispointer,kisset,kisequal then
	case (p+1)^
	when kjumptrue then
		(p+1)^:=intpc(&jx_jumptrue_i)
		return p+3
	when kjumpfalse then
		(p+1)^:=intpc(&jx_jumpfalse_i)
		return p+3
	esac

esac

return q
end

global proc fixup_asm(int mx) =			!ASM PCFIXUP
int cmd,j,a,b,n,cmd2
ref intpc lab
ref intpc p

p:=cast(moduletable[mx].pccode)

do
	cmd:=p^
	lab:=asmhandlertable[cmd]
	p^:=intpc(lab)

	case cmd
	when kendmodule, 0 then
		exit

	else
		p:=optimise_asm(p,cmd)

	esac
od

return
end

global function asmavailable:int= return 1 end

function getfreelabel(int n)intp=
static [2]intpc p
assem
	mov A0,[n]
	mov D0,[D0*8+freetable]	!get &ka_free_1, etc
	mov [p],D0
end
return	p[1]
assem
freetable:
	dq 0
	dq jx_free_10xx.jx_free_1
	dq jx_free_10xx.jx_free_2
	dq jx_free_10xx.jx_free_3
	dq jx_free_10xx.jx_free_4
	dq jx_free_10xx.jx_free_5
	dq jx_free_10xx.jx_free_6
	dq jx_free_10xx.jx_free_7
	dq jx_free_10xx.jx_free_8
	dq jx_free_10xx.jx_free_9
	dq jx_free_10xx.jx_free_10

end
end

function findcmd(ref void cmd)int =
int i
assem
	mov D3,asmhandlertable
	mov D4,[cmd]
	mov D2,0
L1:
	cmp D2,klastcmd
	jge L2
	cmp D4,[D3]
	jz L3
	add D3,8
	inc D2
	jmp L1
L2:
	mov word64 [i],0
	jmp L4
L3:
	mov [i],D2
L4:
end

return i
end

global proc showasmcmd =
int i
int cmd


cmd:=pcptr^

CPL "SHOWASMCMD",CMDNAMES[FINDCMD(CAST(PCPTR^))]
RETURN


end

global function disploop_asm:ref int =				!ASM DISPATCHER

disploop()

return nil
end

proc dummyproc=
end

threadedproc disploop=
STATIC REF VOID STACKPTR



	assem

		push D9
		push D8
		push D7
		push D6

		push D5
		push D4
		push D3
		push Dframe

		sub dstack,40

		*cloadregs
		*jumpnext
	end

	stoplabel::


	assem
		add dstack, 40

		pop Dframe
		pop D3
		pop D4
		pop D5

		pop D6
		pop D7
		pop D8
		pop D9

	end
end


threadedproc ka_procstart =	! KA_PROCSTART
assem
	*saveregs
	*callm k_procstart
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_procend =	! KA_PROCEND
assem
	*saveregs
	*callm k_procend
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_nop =	! KA_NOP
assem
	*saveregs
	*callm k_nop
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_endmodule =	! KA_ENDMODULE
assem
	*saveregs
	*callm k_endmodule
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_push_m =	! KA_PUSH_M
assem
	mov D4,[Dprog+kopnda]
	*pushvar
	mov D0,[D4+ktag]
	mov [Dsptr+ktag],D0
	mov D1,[D4+kvalue]
	mov [Dsptr+kvalue],D1
	and A0,hasrefmask
	jz L2
	inc word32 [D1+jrefcount]
L2:
	*jumpskip2

endassem endproc

threadedproc ka_push_f =	! KA_PUSH_F
assem
	mov D4,[Dprog+kopnda]
	*pushvar
	mov D0,[Dframe+D4+ktag]
	mov [Dsptr+ktag],D0
	mov D1,[Dframe+D4+kvalue]
	mov [Dsptr+kvalue],D1
	and A0,hasrefmask
	jz L2
	inc word32 [D1+jrefcount]
L2:
	*jumpskip2

endassem endproc

threadedproc ka_push_am =	! KA_PUSH_AM
assem
	*pushvar
	mov word32 [Dsptr+ktag],trefvar
	mov D4,[Dprog+kopnda]
	mov [Dsptr+kvarptr],D4
	*jumpskip2

endassem endproc

threadedproc ka_push_af =	! KA_PUSH_AF
assem
	*pushvar
	mov word32 [Dsptr+ktag],trefvar
	mov D4,[Dprog+kopnda]
	lea D0,[D4+Dframe]
	mov [Dsptr+kvarptr],D0
	*jumpskip2

endassem endproc

threadedproc ka_push_ap =	! KA_PUSH_AP
assem
	*saveregs
	*callm k_push_ap
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_push_al =	! KA_PUSH_AL
assem
	*saveregs
	*callm k_push_al
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_push_ci =	! KA_PUSH_CI
assem
	*pushvar
	mov word32 [Dsptr+ktag],tint
	mov D0,[Dprog+kopnda]
	mov [Dsptr+kvalue],D0
	*jumpskip2

endassem endproc

threadedproc ka_push_cw =	! KA_PUSH_CW
assem
	*saveregs
	*callm k_push_cw
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_push_cr =	! KA_PUSH_CR
assem

	*saveregs
	*callm k_push_cr
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_push_cn =	! KA_PUSH_CN
assem
	*pushvar
	mov word32 [Dsptr+ktag],trange
	mov D0,[Dprog+kopnda]
	mov [Dsptr+kvalue],D0
	*jumpskip2

endassem endproc

threadedproc ka_push_cs =	! KA_PUSH_CS
assem
	*pushvar
	mov word32 [Dsptr+ktag],tstring+hasrefmask
	mov D0,[Dprog+kopnda]
	mov [Dsptr+kobjptr],D0
	inc word32 [D0+jrefcount]
	*jumpskip2

endassem endproc

threadedproc ka_push_t =	! KA_PUSH_T
assem
	*pushvar
	mov A0,[Dprog+kopnda]
	mov word32 [Dsptr+ktag],ttype
	mov [Dsptr+kvalue],D0
	*jumpskip2

endassem endproc

threadedproc ka_push_op =	! KA_PUSH_OP
assem
	*pushvar
	mov A0,[Dprog+kopnda]
	mov word32 [Dsptr+ktag],toperator
	mov [Dsptr+kvalue],D0
	mov A0,[Dprog+kopndb]
	mov [Dsptr+kopdims],B0
	*jumpskip3

endassem endproc

threadedproc ka_pushz =	! KA_PUSHZ
assem
	*pushvar
	mov A0,[Dprog+kopnda]
	mov [Dsptr+ktag],A0
	mov word64 [Dsptr+kvalue],0
	*jumpskip2

endassem endproc

threadedproc ka_pushz_void =	! KA_PUSHZ_VOID
assem
	*pushvar
	mov word32 [Dsptr+ktag],tvoid
	*jumpskip1

endassem endproc

threadedproc ka_pushz_str =	! KA_PUSHZ_STR
assem
	*saveregs
	*callm k_pushz_str
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_pushz_list =	! KA_PUSHZ_LIST
assem
	*saveregs
	*callm k_pushz_list
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_pushz_listl =	! KA_PUSHZ_LISTL
assem
	*saveregs
	*callm k_pushz_listl
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_pushz_set =	! KA_PUSHZ_SET
assem
	*saveregs
	*callm k_pushz_set
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_pushz_arrayl =	! KA_PUSHZ_ARRAYL
assem
	*saveregs
	*callm k_pushz_arrayl
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_pop_m =	! KA_POP_M
assem
	mov D4,[Dprog+kopnda]

	cmp byte [D4+khasref],1
	jnz L2
	*callvxufree_d4
	mov D4,[Dprog+kopnda]
L2:
	mov D0,[Dsptr+ktag]
	mov [D4+ktag],D0
	mov D1,[Dsptr+kvalue]
	mov [D4+kvalue],D1
	*popvar
	*jumpskip2

endassem endproc

threadedproc ka_pop_f =	! KA_POP_F
assem
	mov D4,[Dprog+kopnda]

	cmp byte [Dframe+D4+khasref],1
	jnz L2

	lea D4,[Dframe+D4]
	*callvxufree_d4
	mov D4,[Dprog+kopnda]

L2:
	mov D0,[Dsptr+ktag]
	mov [Dframe+D4+ktag],D0
	mov D1,[Dsptr+kvalue]
	mov [Dframe+D4+kvalue],D1

	*popvar
	*jumpskip2

	*saveregs
	*callm k_pop_f
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_store_m =	! KA_STORE_M
assem
	cmp byte[Dsptr+khasref],1
	jnz L1
	mov D1,[Dsptr+kobjptr]
	inc word32 [D1+jrefcount]
L1:
	mov D4,[Dprog+kopnda]
	cmp byte[D4+khasref],1
	jnz L2
	*callvxufree_d4
L2:
	mov D0,[Dsptr+ktag]
	mov [D4+ktag],D0
	mov D1,[Dsptr+kvalue]
	mov [D4+kvalue],D1
	*jumpskip2

	*saveregs
	*callm k_store_m
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_store_f =	! KA_STORE_F
assem

	cmp byte[Dsptr+khasref],1
	jnz L1
	mov D1,[Dsptr+kobjptr]
	inc word32 [D1+jrefcount]
L1:
	mov D4,[Dprog+kopnda]
	add D4,Dframe
	cmp byte[D4+khasref],1
	jnz L2
	*callvxufree_d4
L2:
	mov D0,[Dsptr+ktag]
	mov [D4+ktag],D0
	mov D1,[Dsptr+kvalue]
	mov [D4+kvalue],D1
	*jumpskip2

endassem endproc

threadedproc ka_pushptr =	! KA_PUSHPTR
assem
	cmp word16 [Dsptr+ktag],trefvar
	jnz L1
	mov D4,[Dsptr+kvarptr]

	mov D0,[D4+ktag]
	mov [Dsptr+ktag],D0
	mov D1,[D4+kvalue]
	mov [Dsptr+kvalue],D1
	and A0,hasrefmask
	jz L12
	inc word32 [D1+jrefcount]

L12:
	*jumpskip1

L1:
	cmp word16 [Dsptr+ktag],trefpacked
	jnz L2
	mov D4,[Dsptr+kpackptr]
	movzx A0,word16 [Dsptr+krefelemtag]
	cmp A0,ti32
	jnz L10
	mov word32 [Dsptr+ktag],tint
	mov A0,[D4]
	movsxd D0,A0
	mov [Dsptr+kvalue],D0
	*jumpskip1
L10:
	cmp A0,tu8
	jnz L11
	mov word32 [Dsptr+ktag],tint
	movzx A0,byte [D4]
	mov [Dsptr+kvalue],D0
	*jumpskip1
L11:

L2:
L99:
	*saveregs
	*callm k_pushptr
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_popptr =	! KA_POPPTR
assem
	cmp word16 [Dsptr+ya+ktag],trefvar
	jnz L2

	mov D4,[Dsptr+ya+kvarptr]
	cmp byte [D4+khasref],1
	jnz L1
	*callvxufree_d4

L1:
	mov D0,[Dsptr+xb+ktag]
	mov [D4+ktag],D0
	mov D1,[Dsptr+xb+kvalue]
	mov [D4+kvalue],D1
	*popvar2
	*jumpskip1

L2:
	cmp word16 [Dsptr+ya+ktag],trefpacked
	jnz L3
	cmp word16 [Dsptr+xb+ktag],tint		!storing i32 to pack dest?
	jnz L3
	mov D1,[Dsptr+xb+kvalue]		!int value to be stored
	mov D4,[Dsptr+ya+kpackptr]			!dest address
	movzx A0,word16 [Dsptr+ya+krefelemtag]

	cmp A0,tu8
	jnz L20
	mov [D4],B1
	*popvar2
	*jumpskip1

L20:
	cmp A0,ti16
	jnz L21
	mov [D4],W1
	*popvar2
	*jumpskip1
L21:
	cmp A0,ti32
	jnz L22
	mov [D4],A1
	*popvar2
	*jumpskip1

L22:
	cmp A0,ti64
	jnz L23
	mov [D4],D1
	*popvar2
	*jumpskip1
L23:
L3:
L99:
	*saveregs
	*callm k_popptr
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_storeptr =	! KA_STOREPTR
assem
	*saveregs
	*callm k_storeptr
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_zpop_m =	! KA_ZPOP_M
assem
	*saveregs
	*callm k_zpop_m
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_zpop_f =	! KA_ZPOP_F
assem
	mov D4,[Dprog+kopnda]
	mov D0,[Dsptr+ktag]
	mov [Dframe+D4+ktag],D0
	mov D1,[Dsptr+kvalue]
	mov [Dframe+D4+kvalue],D1
	*popvar
	*jumpskip2
L99:
endassem endproc

threadedproc ka_zstore_m =	! KA_ZSTORE_M
assem
	*saveregs
	*callm k_zstore_m
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_zstore_f =	! KA_ZSTORE_F
assem
	mov D4,[Dprog+kopnda]
	add D4,Dframe
L2:
	mov D0,[Dsptr+ktag]
	mov [D4+ktag],D0
	mov D1,[Dsptr+kvalue]
	mov [D4+kvalue],D1

	and A0,hasrefmask
	jz L3
	inc word32 [D1+jrefcount]
L3:

	*jumpskip2
L99:
endassem endproc

threadedproc ka_copy =	! KA_COPY
assem
	*saveregs
	*callm k_copy
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_swap =	! KA_SWAP
assem
	cmp word16 [Dsptr+xb+ktag],trefvar
	jnz L2
	cmp word16 [Dsptr+ya+ktag],trefvar
	jnz L2
	mov D4,[Dsptr+xb+kvarptr]
	mov D5,[Dsptr+ya+kvarptr]

	mov D0,[D4]
	mov D1,[D5]
	mov [D4],D1
	mov [D5],D0

	mov D0,[D4+kvalue]
	mov D1,[D5+kvalue]
	mov [D4+kvalue],D1
	mov [D5+kvalue],D0

	*popvar2
	*jumpskip1

L2:
	cmp word16 [Dsptr+xb+ktag],trefpacked
	jnz L3
	cmp word16 [Dsptr+ya+ktag],trefpacked
	jnz L3
	cmp word16 [Dsptr+xb+krefelemtag],tu8
	jnz L3
	cmp word16 [Dsptr+ya+krefelemtag],tu8
	jnz L3
	mov D4,[Dsptr+xb+kpackptr]
	mov D5,[Dsptr+ya+kpackptr]
	mov B0,[D4]
	mov B1,[D5]
	mov [D4],B1
	mov [D5],B0
	*popvar2
	*jumpskip1

L3:
L99:
	*saveregs
	*callm k_swap
	*loadregs
	*bjumpnext	! size= 1
endassem endproc

threadedproc ka_convptr =	! KA_CONVPTR
assem
	*saveregs
	*callm k_convptr
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_jump =	! KA_JUMP
assem
	mov Dprog,[Dprog+kopnda]
	*bjumpnext

endassem endproc

threadedproc ka_jumpptr =	! KA_JUMPPTR
assem
	*saveregs
	*callm k_jumpptr
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_jumptrue =	! KA_JUMPTRUE
assem
	cmp word16 [Dsptr+xa+ktag],tint
	jnz L1

	mov D0,[Dsptr+xa+kvalue]
	and D0,D0
	jz L2
	mov Dprog,[Dprog+kopnda]
	*popvar
	*jumpnext

L2:
	*popvar
	*jumpskip2
L1:
	*saveregs
	*callm k_jumptrue
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_jumpfalse =	! KA_JUMPFALSE
assem
	cmp word16 [Dsptr+xa+ktag],tint
	jnz L1

	mov D0,[Dsptr+xa+kvalue]
	and D0,D0
	jnz L2
	mov Dprog,[Dprog+kopnda]
	*popvar
	*jumpnext

L2:
	*popvar
	*jumpskip2

L1:
	*saveregs
	*callm k_jumpfalse
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_jumpdef =	! KA_JUMPDEF
assem
	cmp word16 [Dsptr+ktag],tvoid
	jg Lisdef1
	*popvar
	*jumpskip2

Lisdef1:
	*popvar
	mov Dprog,[Dprog+kopnda]
	*jumpnext

endassem endproc

threadedproc ka_jumpvoid =	! KA_JUMPVOID
assem
	cmp word16 [Dsptr+ktag],tvoid
	jbe L1
	*popvar
	*jumpskip2

L1:
	*popvar
	mov Dprog,[Dprog+kopnda]
	*bjumpnext

endassem endproc

threadedproc ka_jumpeq =	! KA_JUMPEQ
assem
	cmp word16 [Dsptr+xb+ktag],tint
	jnz L1
	cmp word16 [Dsptr+ya+ktag],tint
	jnz L1

	mov D0,[Dsptr+xb+kvalue]
	cmp D0,[Dsptr+ya+kvalue]
	jz L2
	*popvar2
	*jumpskip2

L2:
	*popvar2
	mov Dprog,[Dprog+kopnda]
	*jumpnext
L1:
	*saveregs
	*callm k_jumpeq
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_jumpne =	! KA_JUMPNE
assem
	movzx A0,word16 [Dsptr+xb+ktag]
	movzx A1,word16 [Dsptr+ya+ktag]
	cmp A0,A1
	jnz L99					!unequal types

	cmp A0,tint
	jnz L2

	mov D0,[Dsptr+xb+kvalue]
	cmp D0,[Dsptr+ya+kvalue]
	jnz L1
L0:
	*popvar2						!same
	*jumpskip2

L1:
	*popvar2						!different
	mov Dprog,[Dprog+kopnda]
	*jumpnext

L2:

L3:

L99:
	*saveregs
	*callm k_jumpne
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_jumplt =	! KA_JUMPLT
assem
	cmp word16 [Dsptr+xb+ktag],tint
	jnz L1
	cmp word16 [Dsptr+ya+ktag],tint
	jnz L1

	mov D0,[Dsptr+xb+kvalue]
	cmp D0,[Dsptr+ya+kvalue]
	jl L2
	*popvar2
	*jumpskip2

L2:
	*popvar2
	mov Dprog,[Dprog+kopnda]
	*jumpnext
L1:
	*saveregs
	*callm k_jumplt
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_jumple =	! KA_JUMPLE
assem
	cmp word16 [Dsptr+xb+ktag],tint
	jnz L1
	cmp word16 [Dsptr+ya+ktag],tint
	jnz L1

	mov D0,[Dsptr+xb+kvalue]
	cmp D0,[Dsptr+ya+kvalue]
	jle L2
	*popvar2
	*jumpskip2

L2:
	*popvar2
	mov Dprog,[Dprog+kopnda]
	*jumpnext
L1:
	*saveregs
	*callm k_jumple
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_jumpge =	! KA_JUMPGE
assem
	cmp word16 [Dsptr+xb+ktag],tint
	jnz L1
	cmp word16 [Dsptr+ya+ktag],tint
	jnz L1

	mov D0,[Dsptr+xb+kvalue]
	cmp D0,[Dsptr+ya+kvalue]
	jge L2
	*popvar2
	*jumpskip2

L2:
	*popvar2
	mov Dprog,[Dprog+kopnda]
	*jumpnext
L1:
	*saveregs
	*callm k_jumpge
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_jumpgt =	! KA_JUMPGT
assem
	cmp word16 [Dsptr+xb+ktag],tint
	jnz L1
	cmp word16 [Dsptr+ya+ktag],tint
	jnz L1

	mov D0,[Dsptr+xb+kvalue]
	cmp D0,[Dsptr+ya+kvalue]
	jg L2
	*popvar2
	*jumpskip2

L2:
	*popvar2
	mov Dprog,[Dprog+kopnda]
	*jumpnext
L1:
	*saveregs
	*callm k_jumpgt
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_jumptesteq =	! KA_JUMPTESTEQ
assem
	cmp word16 [Dsptr+ya+ktag],tint
	jnz L99
	cmp word16 [Dsptr+xb+ktag],tint
	jnz L99
	mov D0,[Dsptr+ya+kvalue]
	cmp D0,[Dsptr+xb+kvalue]
	jnz L2
	*popvar2
	mov Dprog,[Dprog+kopnda]
	*jumpnext
L2:
	*popvar
	*jumpskip2

L99:
	*saveregs
	*callm k_jumptesteq
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_jumptestne =	! KA_JUMPTESTNE
assem
	cmp word16 [Dsptr+ya+ktag],tint
	jnz L1
	cmp word16 [Dsptr+xb+ktag],tint
	jnz L1
	mov D0,[Dsptr+ya+kvalue]
	cmp D0,[Dsptr+xb+kvalue]
	jz L2
	*popvar
	mov Dprog,[Dprog+kopnda]
	*jumpnext
L2:
	*popvar2
	*jumpskip2

L1:
	*saveregs
	*callm k_jumptestne
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_jumplabel =	! KA_JUMPLABEL
assem
	*saveregs
	*callm k_jumplabel
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_jumpclabel =	! KA_JUMPCLABEL
assem
	*saveregs
	*callm k_jumpclabel
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_switch =	! KA_SWITCH
assem
	cmp word16 [Dsptr+ktag],tint
	jnz L1				!get C deal with errors
	mov D4,[Dsptr+kvalue]		!switch index
	*popvar
	sub D4,[Dprog+kopndb]		!index-lower! now 0-based index
	cmp D4,[Dprog+kopnda]		!index0>=n?
	jae L2				!out of range
	shl D4,1
	mov Dprog,[Dprog+D4*8+intpsize4]
	*jumpnext
L2:
	mov D5,[Dprog+kopnda]
	shl D5,1
	mov Dprog,[Dprog+D5*8+intpsize4]
	*jumpnext

L1:
	*saveregs
	*callm k_switch
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_cswitch =	! KA_CSWITCH
assem
	*saveregs
	*callm k_cswitch
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_new =	! KA_NEW
assem
	*saveregs
	*callm k_new
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_to_f =
assem
	mov D4,[Dprog+kopnda]
	mov D5,[Dprog+kopndb]
	dec word64 [Dframe+D5+kvalue]
	jz L1
	mov Dprog,D4
	*jumpnext
L1:
	*jumpskip3

endassem endproc

threadedproc ka_for_fci =	! KA_FOR_FCI
assem
	mov D4,[Dprog+kopnda]		!label
	mov D0,[Dprog+kopndb]		!a
	inc word64 [Dframe+D0+kvalue]	!++a
	mov D0,[Dframe+D0+kvalue]
	cmp A0,[Dprog+kopndc]
	jg L1
	mov Dprog,D4
	*jumpnext
L1:
	*jumpskip4

endassem endproc

threadedproc ka_for_ff =	! KA_FOR_FF
assem
	mov D4,[Dprog+kopnda]		!label
	mov D0,[Dprog+kopndb]		!b
	mov D5,[Dprog+kopndc]		!c
	inc word64 [Dframe+D0+kvalue]
	mov D0,[Dframe+D0+kvalue]
	cmp D0,[Dframe+D5+kvalue]
	jg L1
	mov Dprog,D4
	*jumpnext
L1:
	*jumpskip4

endassem endproc

threadedproc ka_ford_fci =	! KA_FORD_FCI
assem
	mov D4,[Dprog+kopnda]		!label
	mov D0,[Dprog+kopndb]		!a
	dec word64 [Dframe+D0+kvalue]	!++a
	mov D0,[Dframe+D0+kvalue]
	cmp A0,[Dprog+kopndc]
	jl L1
	mov Dprog,D4
	*jumpnext
L1:
	*jumpskip4

endassem endproc

threadedproc ka_ford_ff =	! KA_FORD_FF
assem
	*saveregs
	*callm k_ford_ff
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_call =	! KA_CALL
const countinterval=10
static int count=countinterval


assem
	dec word32 [count]
	jz L99
end

assem

	*pushvar
	mov word32 [Dsptr+ktag],tretaddr
	lea D0,[Dprog+24]		! return address
	mov [Dsptr+kretaddr],D0
	mov [Dsptr+kframeptr_low],Aframe
	mov D0,[Dprog+kopndb]		! stack adjust count
	mov [Dsptr+kstackadj],B0
	mov Dframe,Dsptr
	mov [frameptr],Dframe
	mov Dprog,[Dprog+kopnda]
	*jumpnext

L99:

	mov word32 [count],countinterval
	*saveregs
	*callm k_call
	*loadregs
	*bjumpnext	! size= 3
endassem endproc

threadedproc ka_callptr =	! KA_CALLPTR
assem
	cmp word16 [Dsptr+ktag],trefproc
	jnz L99
	mov D5,[Dsptr+kvalue]		!newpc

	mov A0,[Dprog+kopnda]
	cmp A0,[A5-intpsize]			!check L params
	jnz L99

	mov word16 [Dsptr+ktag],tretaddr
	lea D0,[Dprog+24]
	mov [Dsptr+kvalue],D0
	mov [Dsptr+kframeptr_low],Aframe
	mov A0,[Dprog+kopndb]
	mov byte [Dsptr+kstackadj],B0
	mov Dframe,Dsptr
	mov [frameptr],Dframe
	mov Dprog,D5
	*jumpnext

L99:
	*saveregs
	*callm k_callptr
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_return =	! KA_RETURN

assem
	mov word16 [Dsptr+ktag],0
	mov Dprog,[Dsptr+kretaddr]
	mov Aframe,[Dsptr+kframeptr_low]
	mov [frameptr],Dframe

	movzx A0,byte [Dsptr+kstackadj]
	add Dsptr,D0
	*popvar
	*jumpnext


L99:
	*saveregs
	*callm k_return
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_startdll =	! KA_STARTDLL
assem
	*saveregs
	*callm k_startdll
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_pushdll =	! KA_PUSHDLL
assem
	*saveregs
	*callm k_pushdll
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_calldll =	! KA_CALLDLL
assem
	*saveregs
	*callm k_calldll
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_callhost =	! KA_CALLHOST
assem
	*saveregs
	*callm k_callhost
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_stackframe =	! KA_STACKFRAME
assem
	mov A3,[Dprog+kopnda]
Lloop1:
	*pushvar
	mov word32 [Dsptr+ktag],tvoid
	mov word64 [Dsptr+kvalue],0
	dec A3
	jnz Lloop1
	*jumpskip2

endassem endproc

threadedproc ka_allocvars =	! KA_ALLOCVARS
assem
	mov D0,[Dprog+kopnda]
	shl D0,varshift
	sub Dsptr,D0
	*jumpskip2

endassem endproc

threadedproc ka_free =	! KA_FREE
assem
	mov A3,[Dprog+kopnda]		!n
	cmp A3,1
	jnz Lloop1
	cmp byte [Dsptr+khasref],1
	jnz L0
	*callvxufree_dsptr

L0:
	*popvar
	*jumpskip2

Lloop1:
	cmp byte [Dsptr+khasref],1
	jnz L1
	*callvxufree_dsptr

L1:
	*popvar
	dec D3
	jnz Lloop1
	*jumpskip2

L99:


	*saveregs
	*callm k_free
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_addsp =	! KA_ADDSP
assem
	add Dsptr,[Dprog+kopnda]
	*jumpskip2

endassem endproc

threadedproc ka_stop =	! KA_STOP
assem
	*csaveregs
	jmp disploop.stoplabel

endassem endproc

threadedproc ka_test =	! KA_TEST
assem
	*saveregs
	*callm k_test
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_makelist =	! KA_MAKELIST
assem
	*saveregs
	*callm k_makelist
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_makerecord =	! KA_MAKERECORD
assem
	*saveregs
	*callm k_makerecord
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_makearray =	! KA_MAKEARRAY
assem
	*saveregs
	*callm k_makearray
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_makestruct =	! KA_MAKESTRUCT
assem
	*saveregs
	*callm k_makestruct
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_makeset =	! KA_MAKESET
assem
	*saveregs
	*callm k_makeset
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_makerange =	! KA_MAKERANGE
assem
	*saveregs
	*callm k_makerange
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_makedict =	! KA_MAKEDICT
assem
	*saveregs
	*callm k_makedict
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_pushdot =	! KA_PUSHDOT
static int fieldtype,offset,xtag
static varrec v
static variant xptr

assem

	mov D0,[Dsptr]			!v:=sptr^
	mov [v],D0
	mov D1,[Dsptr+8]
	mov [v+8],D1

	cmp W0,trecordlink		!W0 is v.tag Is it in fact a recordlink?
	jnz L50
	mov W1,[v+krefelemtag]	!leave hasref at zero
	mov [v+ktag],W1
	jmp L51
L50:
	cmp byte [v+khasref],0
	jz L99					!error
L51:


L1:

	mov D7,[Dprog+kopnda]
	shl A7,4						!D7 is getopnda*16
	lea D0,[D7+genfieldnames-16]
	mov A0,[A0+kdataindex]
	shl A0,4
	lea D6,[A0+genfielddata-16]		!D6 is gd = &genfielddata[...]

	lea D0,[D7+genfieldnames-16]
	mov A5,[D0+kdatalength]			!D5 is n = genfieldnames[genopnda].datalength

	mov W4,word16 [v+ktag]			!W5 is v.tag
	mov D0,[v+kobjptr]				!A5 is v.tag
	mov D0,[D0+jvptr]				!xptr:=v.objptr^.vptr
	mov [xptr],D0

L70:
	mov W0,[D6+krecordtype]				!gd^.recordtype
	cmp W0,W4							!=v.tag
	jz Lfound
	add D6,16							!++gd
	dec A5
	jnz L70
	jmp Lnotfound

Lfound:
	mov A0,[D6+kfieldtype]		!fieldtype:=gd^.fieldtype
	mov A3,[D6+kfieldoffset]	!offset:=gd^.offset
	cmp A0,tvariant
	jnz L4

	mov D4,[xptr]
	mov D0,[D4+D3]				!(xptr+gd^.offset)^
	mov [Dsptr+ktag],D0
	mov D1,[D4+D3+kvalue]
	mov [Dsptr+kvalue],D1

	and A0,hasrefmask			!sptr^.tagx iand hasrefmask
	jz L31
	mov D2,[Dsptr+kobjptr]
	inc word32 [D2+jrefcount]	!++sptr^.objptr^.refcount
L31:
	cmp byte [v+khasref],1		!might have been a recordlink
	jnz L32
	mov D4,[v+kobjptr]
	dec word32 [D4+jrefcount]	!original record
	jnz L32
	lea D10,[v]
	*callfreex

L32:
	*jumpskip2


L4:
JMP L99
	cmp A0,trefproc
	jnz ispacked

	mov D4,[D6+kpackptr]			!x^.ptr
end assem
pcerror("ASM/REFPROC")
assem

	lea D0,[A2+A1*8]			!&pcdata^[genfielddata^[k].proc
	mov [Dsptr+kvalue],D0

	mov word32 [Dsptr+ktag],trefproc

	lea D4,[v]
	*callvxufree_d4
	*jumpskip2

ispacked:

	mov [fieldtype],A0			!fieldtype:=
	mov [offset],A1				!offset:=
end
	assem
		*saveregs
	end
	pc_loadpacked(v.objptr.urec.ptr+offset,fieldtype,sptr,nil)
	if --v.objptr^.refcount=0 then
		pc_unshare(&v)
	fi

assem
	*loadskip2
end

asm Lnotfound:

xtag:=tint
asm jmp L99

assem
	*saveregs
end
pcustypet("Dotg: wrong record type",xtag)

asm Lnotcopy:
assem
L99:
	*saveregs
	*callm k_pushdot
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_pushdotref =	! KA_PUSHDOTREF
assem
	*saveregs
	*callm k_pushdotref
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_softconv =	! KA_SOFTCONV
assem
	*saveregs
	*callm k_softconv
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_hardconv =	! KA_HARDCONV
assem
	*saveregs
	*callm k_hardconv
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_mixed =	! KA_MIXED
assem
	*saveregs
	*callm k_mixed
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_incr =	! KA_PUSH_INCR
assem
	*saveregs
	*callm k_incr
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_decr =	! KA_PUSH_DECR
assem
	*saveregs
	*callm k_decr
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_incrptr =	! KA_INCRPTR
assem
	*saveregs
	*callm k_incrptr
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_incrto_m =	! KA_INCRTO_M
assem
	mov D4,[Dprog+kopnda]
	cmp word16 [D4+ktag],tint
	jnz L1
	inc word64 [D4+kvalue]
	*jumpskip2

L1:
	cmp word16 [D4+ktag],trefpacked
	jnz L2
	movzx A0,word16 [D4+krefelemtag]
	mov A0,[D0*8+ttsize]
	add [D4+kvarptr],D0
	*jumpskip2

L2:
	*saveregs
	*callm k_incrto_m
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_incrto_f =	! KA_INCRTO_F
assem
	mov D4,[Dprog+kopnda]
	cmp word16 [Dframe+D4+ktag],tint
	jnz L1
	inc word64 [Dframe+D4+kvalue]
	*jumpskip2

L1:
	cmp word16 [Dframe+D4+ktag],trefpacked
	jnz L2
	movzx A0,word16 [Dframe+D4+krefelemtag]
	mov A0,[D0*8+ttsize]
	add [Dframe+D4+kvarptr],D0
	*jumpskip2

L2:
	*saveregs
	*callm k_incrto_f
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_loadincr =	! KA_LOADINCR
assem
	*saveregs
	*callm k_loadincr
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_incrload =	! KA_INCRLOAD
assem
	*saveregs
	*callm k_incrload
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_decrptr =	! KA_DECRPTR
assem
	*saveregs
	*callm k_decrptr
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_decrto_m =	! KA_DECRTO_M
assem
	*saveregs
	*callm k_decrto_m
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_decrto_f =	! KA_DECRTO_F
assem
	mov D4,[Dprog+kopnda]
	cmp word16 [Dframe+D4+ktag],tint
	jnz L1
	dec word64 [Dframe+D4+kvalue]
	*jumpskip2

L1:
	cmp word16 [Dframe+D4+ktag],trefpacked
	jnz L2
	movzx A0,word16 [Dframe+D4+krefelemtag]
	mov A0,[D0*8+ttsize]
	sub [Dframe+D4+kpackptr],D0
	*jumpskip2

L2:
	*saveregs
	*callm k_decrto_f
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_loaddecr =	! KA_LOADDECR
assem
	*saveregs
	*callm k_loaddecr
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_decrload =	! KA_DECRLOAD
assem
	*saveregs
	*callm k_decrload
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_neg =	! KA_NEG
assem
	*saveregs
	*callm k_neg
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_abs =	! KA_ABS
assem
	*saveregs
	*callm k_abs
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_not =	! KA_NOT
assem
	mov al,[dsptr+kvalue]
	xor al,1
	mov [dsptr+kvalue],al
	*jumpskip1

	*saveregs
	*callm k_not
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_inot =	! KA_INOT
assem
	*saveregs
	*callm k_inot
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_istrue =	! KA_ISTRUE
assem
	*saveregs
	*callm k_istrue
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_asc =	! KA_ASC
assem
	*saveregs
	*callm k_asc
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_chr =	! KA_CHR
assem
	cmp word16 [Dsptr+ktag],tint
	jnz L99						!not int; B deals with the error
	mov D0,[Dsptr+kvalue]
	cmp D0,255
	ja L99						!not in range
	mov D0,[D0*8+chrtable]
	and D0,D0
	jz L99						!value not cached; B will fill it in
	mov word32 [Dsptr+ktag],tstring+hasrefmask
	mov [Dsptr+kvalue],D0				!point to object
	inc word32 [D0+jrefcount]
	*jumpskip1

L99:
	*saveregs
	*callm k_chr
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_sqrt =	! KA_SQRT
assem
	cmp word16 [Dsptr+ktag],tint
	jnz L1
	fild word32 [Dsptr+kvalue]
	fsqrt
	mov word32 [Dsptr+ktag],treal
	fstp word64 [Dsptr+kvalue]
	*jumpskip1
L1:
	cmp word16 [Dsptr+ktag],treal
	jnz L2


	movq xmm0,[Dsptr+kvalue]
	sqrtsd xmm0,xmm0
	movq [Dsptr+kvalue],xmm0

	*jumpskip1
L2:
	*saveregs
	*callm k_sqrt
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_sqr =	! KA_SQR
assem
	cmp word16 [Dsptr+ktag],tint
	jnz L1
	mov D0,[Dsptr+kvalue]
	imul word64 [Dsptr+kvalue]
	mov [Dsptr+kvalue],D0
	*jumpskip1
L1:
	cmp word16 [Dsptr+ktag],treal
	jnz L2


	movq xmm0,[Dsptr+kvalue]
	mulsd xmm0,xmm0
	movq [Dsptr+kvalue],xmm0

	*jumpskip1
L2:
	*saveregs
	*callm k_sqr
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_cube =	! KA_CUBE
assem
	*saveregs
	*callm k_cube
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_sin =	! KA_SIN
assem
	fld word64 [Dsptr+kvalue]
	fsin
	fstp word64 [Dsptr+kvalue]
	*jumpskip1

	*saveregs
	*callm k_sin
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_cos =	! KA_COS
assem
	*saveregs
	*callm k_cos
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_tan =	! KA_TAN
assem
	*saveregs
	*callm k_tan
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_asin =	! KA_ASIN
assem
	*saveregs
	*callm k_asin
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_acos =	! KA_ACOS
assem
	*saveregs
	*callm k_acos
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_atan =	! KA_ATAN
assem
	*saveregs
	*callm k_atan
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_sign =	! KA_SIGN
assem
	*saveregs
	*callm k_sign
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_ln =	! KA_LN
assem
	*saveregs
	*callm k_ln
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_log =	! KA_LOG
assem
	*saveregs
	*callm k_log
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_lg =	! KA_LG
assem
	*saveregs
	*callm k_lg
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_exp =	! KA_EXP
assem
	*saveregs
	*callm k_exp
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_round =	! KA_ROUND
assem
	*saveregs
	*callm k_round
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_floor =	! KA_FLOOR
assem
	*saveregs
	*callm k_floor
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_ceil =	! KA_CEIL
assem
	*saveregs
	*callm k_ceil
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_fract =	! KA_FRACT
assem
	*saveregs
	*callm k_fract
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_negto =	! KA_NEGTO
assem
	*saveregs
	*callm k_negto
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_absto =	! KA_ABSTO
assem
	*saveregs
	*callm k_absto
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_notto =	! KA_NOTTO
assem
	*saveregs
	*callm k_notto
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_inotto =	! KA_INOTTO
assem
	*saveregs
	*callm k_inotto
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_len =	! KA_LEN
static varrec v

assem
	cmp byte [Dsptr+khasref],1
	jnz L2
	movzx A2,word16 [Dsptr+ktag]
cmp A2,tbignum
jz L2
	mov D4,[Dsptr+kobjptr]			!assume this is an object
	mov word32 [Dsptr+ktag],tint
	mov A0,[D4+jlength]
	mov [Dsptr+kvalue],D0

	dec word32 [D4+jrefcount]
	jnz L1
	mov word32 [v+ktag],A2
	mov word64 [v+kobjptr],D4
	lea D10,[v]
	*callfreex
L1:

	*jumpskip1

L2:

	*saveregs
	*callm k_len
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_lwb =	! KA_LWB
assem
	*saveregs
	*callm k_lwb
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_upb =	! KA_UPB
static varrec v

assem
	cmp byte [Dsptr+khasref],1
	jnz L2
	movzx A2,word16 [Dsptr+ktag]
	cmp A2,tlist
	jz L3
	cmp A2,tarray
	jnz L2

L3:
	mov D4,[Dsptr+kobjptr]			!assume this is an object

	mov word32 [Dsptr+ktag],tint
	mov A0,[D4+jlength]
	movsx A1,word16 [D4+jlower]		!could be array; uses 16 bits for all lwbs
	add A0,A1
	dec A0
	mov [Dsptr+kvalue],D0

	dec word32 [D4+jrefcount]
	jnz L1
	mov word32 [v+ktag],A2
	mov word64 [v+kobjptr],D4
	lea D10,[v]
	*callfreex
L1:

	*jumpskip1

L2:
	*saveregs
	*callm k_upb
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_bounds =	! KA_BOUNDS
assem
	*saveregs
	*callm k_bounds
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_bits =	! KA_BITS
assem
	*saveregs
	*callm k_bits
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_bytes =	! KA_BYTES
assem
	*saveregs
	*callm k_bytes
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_type =	! KA_TYPE
assem
	*saveregs
	*callm k_type
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_elemtype =	! KA_ELEMTYPE
assem
	*saveregs
	*callm k_elemtype
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_basetype =	! KA_BASETYPE
assem
	*saveregs
	*callm k_basetype
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_minval =	! KA_MINVAL
assem
	*saveregs
	*callm k_minval
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_maxval =	! KA_MAXVAL
assem
	*saveregs
	*callm k_maxval
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_isint =	! KA_ISINT
assem
	movzx A0,word16 [Dsptr+ktag]
	cmp A0,tint
	jz L1
	cmp A0,tword
	jnz L2
L1:
	mov word64 [Dsptr+kvalue],1
	mov word32 [Dsptr+ktag],tint
	*jumpskip1
L2:
	cmp byte [Dsptr+khasref],1
	jnz L3
	*callvxufree_dsptr
L3:
	mov word64 [Dsptr+kvalue],0
	mov word32 [Dsptr+ktag],tint
	*jumpskip1

endassem endproc

threadedproc ka_isreal =	! KA_ISREAL
assem
	*saveregs
	*callm k_isreal
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_isstring =	! KA_ISSTRING
assem
	*saveregs
	*callm k_isstring
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_isrange =	! KA_ISRANGE
assem
	*saveregs
	*callm k_isrange
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_isnumber =	! KA_ISNUMBER
assem
	*saveregs
	*callm k_isnumber
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_isarray =	! KA_ISARRAY
assem
	movzx A0,word16 [Dsptr+ktag]
	mov D0,[D0*4+ttbasetype]
	cmp A0,tlist
	jz L1
	cmp A0,tarray
	jnz L2
L1:
	mov D5,1
	jmp L3
L2:
	mov D5,0
L3:
	cmp byte [Dsptr+khasref],1
	jnz L4
	*callvxufree_dsptr
L4:
	mov [Dsptr+kvalue],D5
	mov word32 [Dsptr+ktag],tint
	*jumpskip1

endassem endproc

threadedproc ka_isrecord =	! KA_ISRECORD
assem
	*saveregs
	*callm k_isrecord
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_ispointer =	! KA_ISPOINTER
assem
	*saveregs
	*callm k_ispointer
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_ismutable =	! KA_ISMUTABLE
assem
	*saveregs
	*callm k_ismutable
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_isset =	! KA_ISSET
assem
	*saveregs
	*callm k_isset
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_isvoid =	! KA_ISVOID
assem
	*saveregs
	*callm k_isvoid
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_isdef =	! KA_ISDEF
assem
	*saveregs
	*callm k_isdef
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_tostr =	! KA_TOSTR
assem
	*saveregs
	*callm k_tostr
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_isequal =	! KA_ISEQUAL
assem
	movzx A0,word16 [Dsptr+xb+ktag]
	cmp W0, [Dsptr+ya+ktag]
	jnz L2
	cmp byte [Dsptr+xb+khasref],1
	jl L2

	mov D0,[Dsptr+xb+kobjptr]
	cmp D0,[Dsptr+ya+kobjptr]
	setz B0
	movzx A0,B0
	*popvar
	mov [Dsptr+xa+kvalue],D0
	mov word32 [Dsptr+xa+ktag],tint
	*jumpskip1

L2:

L99:
	*saveregs
	*callm k_isequal
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_add =	! KA_ADD
assem

	movzx A0,word16 [Dsptr+xb+ktag]
	movzx A1,word16 [Dsptr+ya+ktag]
	cmp A0,A1
	jnz L99
	cmp W0,tint
	jnz L1
	mov D0,[Dsptr+ya+kvalue]
	add [Dsptr+xb+kvalue],D0



	*popvar
	*jumpskip1

L1:
	cmp W0,treal
	jnz L2


	fld word64 [Dsptr+xb+kvalue]
	fld word64 [Dsptr+ya+kvalue]
	fadd
	fstp word64 [Dsptr+xb+kvalue]



	*popvar
	*jumpskip1

L999:
end
	PCERROR("ADDI64/OVERFLOW")
assem

L2:
L99:
	*saveregs
	*callm k_add
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_sub =	! KA_SUB
assem
	movzx A0,word16 [Dsptr+xb+ktag]
	movzx A1,word16 [Dsptr+ya+ktag]
	cmp A0,A1
	jnz L99
	cmp W0,tint
	jnz L1
	mov D0,[Dsptr+ya+kvalue]
	sub [Dsptr+xb+kvalue],D0
	*popvar
	*jumpskip1
L1:
	cmp W0,treal
	jnz L2
L2:
L99:
	*saveregs
	*callm k_sub
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_mul =	! KA_MUL
assem
	cmp word16 [Dsptr+ya+ktag],tint
	jnz L1
	cmp word16 [Dsptr+xb+ktag],tint
	jnz L1

	mov D0,[Dsptr+xb+kvalue]
	imul word64 [Dsptr+ya+kvalue]
	mov [Dsptr+xb+kvalue],D0
	*popvar
	*jumpskip1
L1:
	cmp word16 [Dsptr+xb+ktag],treal
	jnz L2
	cmp word16 [Dsptr+ya+ktag],treal
	jnz L2


	fld word64 [Dsptr+xb+kvalue]
	fld word64 [Dsptr+ya+kvalue]
	fmul
	fstp word64 [Dsptr+xb+kvalue]

	*popvar
	*jumpskip1

L2:
	*saveregs
	*callm k_mul
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_div =	! KA_DIV
assem
	cmp word16 [Dsptr+xb+ktag],treal
	jnz L1
	cmp word16 [Dsptr+ya+ktag],treal
	jnz L1

	fld word64 [Dsptr+xb+kvalue]
	fld word64 [Dsptr+ya+kvalue]
	fdiv
	fstp word64 [Dsptr+xb+kvalue]

	*popvar
	*jumpskip1

L1:
	*saveregs
	*callm k_div
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_idiv =	! KA_IDIV
assem
	cmp word16 [Dsptr+xb+ktag],tint
	jnz L1
	cmp word16 [Dsptr+ya+ktag],tint
	jnz L1
	mov D0,[Dsptr+xb+kvalue]
	cqo
	idiv word64 [Dsptr+ya+kvalue]
	mov [Dsptr+xb+kvalue],D0
	*popvar
	*jumpskip1
L1:
	*saveregs
	*callm k_idiv
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_rem =	! KA_REM
assem
	*saveregs
	*callm k_rem
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_divrem =	! KA_DIVREM
assem
	*saveregs
	*callm k_divrem
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_iand =	! KA_IAND
assem
	cmp word16 [Dsptr+xb+ktag],tint
	jnz L1
	cmp word16 [Dsptr+ya+ktag],tint
	jnz L1
	mov D0,[Dsptr+ya+kvalue]
	and [Dsptr+xb+kvalue],D0
	*popvar
	*jumpskip1
L1:
	*saveregs
	*callm k_iand
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_ior =	! KA_IOR
assem
	cmp word16 [Dsptr+xb+ktag],tint
	jnz L1
	cmp word16 [Dsptr+ya+ktag],tint
	jnz L1
	mov D0,[Dsptr+ya+kvalue]
	or [Dsptr+xb+kvalue],D0
	*popvar
	*jumpskip1
L1:
	*saveregs
	*callm k_ior
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_ixor =	! KA_IXOR
assem
	cmp word16 [Dsptr+xb+ktag],tint
	jnz L1
	cmp word16 [Dsptr+ya+ktag],tint
	jnz L1
	mov D0,[Dsptr+ya+kvalue]
	xor [Dsptr+xb+kvalue],D0
	*popvar
	*jumpskip1
L1:
	cmp word16 [Dsptr+xb+ktag],tword
	jnz L2
	cmp word16 [Dsptr+ya+ktag],tword
	jnz L2
	mov D0,[Dsptr+ya+kvalue]
	xor [Dsptr+xb+kvalue],D0
	*popvar
	*jumpskip1
L2:
	*saveregs
	*callm k_ixor
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_shl =	! KA_SHL
assem
	cmp word16 [Dsptr+xb+ktag],tint
	jnz L1
	cmp word16 [Dsptr+ya+ktag],tint
	jnz L1
L3:
	mov rdx,Dsptr
	mov cl,[Dsptr+ya+kvalue]
	shl word64 [rdx+xb+kvalue],cl
	mov Dsptr,rdx
	*popvar
	*jumpskip1
L1:
L2:
	*saveregs
	*callm k_shl
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_shr =	! KA_SHR
assem
	cmp word16 [Dsptr+xb+ktag],tint
	jnz L1
	cmp word16 [Dsptr+ya+ktag],tint
	jnz L1
	mov rdx,Dsptr
	mov cl,[Dsptr+ya+kvalue]
	sar word64 [rdx+xb+kvalue],cl
	mov Dsptr,rdx
	*popvar
	*jumpskip1
L1:
	*saveregs
	*callm k_shr
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_in =	! KA_IN
assem
	*saveregs
	*callm k_in
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_notin =	! KA_NOTIN
assem
	*saveregs
	*callm k_notin
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_inrev =	! KA_INREV
assem
	*saveregs
	*callm k_inrev
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_eq =	! KA_EQ
assem
	*saveregs
	*callm k_eq
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_ne =	! KA_NE
assem
	*saveregs
	*callm k_ne
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_lt =	! KA_LT
assem
	*saveregs
	*callm k_lt
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_le =	! KA_LE
assem
	*saveregs
	*callm k_le
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_ge =	! KA_GE
assem
	*saveregs
	*callm k_ge
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_gt =	! KA_GT
assem
	*saveregs
	*callm k_gt
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_min =	! KA_MIN
assem
	*saveregs
	*callm k_min
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_max =	! KA_MAX
assem
	*saveregs
	*callm k_max
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_concat =	! KA_CONCAT
assem
	*saveregs
	*callm k_concat
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_append =	! KA_APPEND
assem
	*saveregs
	*callm k_append
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_power =	! KA_POWER
assem
	*saveregs
	*callm k_power
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_atan2 =	! KA_ATAN2
assem
	*saveregs
	*callm k_atan2
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_addto =	! KA_ADDTO
assem
	mov D4,[Dsptr+xb+kvarptr]
	cmp word16 [Dsptr+xb+ktag],trefvar	!lhs is ref var?
	jnz L99

	cmp word16 [D4+ktag],tint				!lhs is ref var:int?
	jnz L1								!mixed
	cmp word16 [Dsptr+ya+ktag],tint		!rhs is int
	jnz L99
	mov D0,[Dsptr+kvalue]
	add [D4+kvalue],D0
	*popvar2
	*jumpskip1

L1:
	cmp word16 [Dsptr+ya+ktag],treal		!rhs is real
	jnz L2
	cmp word16 [D4+ktag],treal			!lhs is ref var:real?
	jnz L99								!mixed


	movq xmm0,[D4+kvalue]
	addsd xmm0,[Dsptr+kvalue]
	movq [D4+kvalue],xmm0
	*popvar2
	*jumpskip1
L2:
	cmp word16 [D4+ktag],tstring				!lhs is ref var:string?
	jnz L3									!mixed
	cmp word32 [Dsptr+ya+ktag],tstring+cc_copy16		!rhs is string?
	jnz L25
	mov D5,[Dsptr+ya+kobjptr]				!D5 points to rhs object descr
	cmp word32 [D5+jlength],1
	jnz L99									!only deal with 1-char strings on rhs
	mov D5,[D5+jstrptr]						!point to rhs string data
	mov B1,[D5]								!char in rhs string

	mov D5,[D4+kobjptr]						!point to lhs string descr
	cmp byte [D5+jmutable],0
	jz L99									!lhs not mutable
	mov A2,[D5+jlength]
	inc A2									!add extra char
	cmp A2,[D5+jallocated]
	jg L99									!need extra allocation
	mov [D5+jlength],A2						!update length
	mov D3,[D5+jstrptr]
	mov [D3+D2-1],B1						!store new char
	*popvar2
	*jumpskip1

L25:
	cmp word16 [Dsptr+ya+ktag],tint			!rhs is int?
	jnz L3
	mov B1,[Dsptr+ya+kvalue]				!B1 is int char value (should be checked reall)

	mov D5,[D4+kobjptr]						!point to lhs string descr
	cmp byte [D5+jmutable],0
	jz L99									!lhs not mutable
	mov A2,[D5+jlength]
	inc A2									!add extra char
	cmp A2,[D5+jallocated]
	jg L99									!need extra allocation
	mov [D5+jlength],A2						!update length
	mov D3,[D5+jstrptr]
	mov [D3+D2-1],B1						!store new char
	*popvar2
	*jumpskip1

L3:

L99:
	*saveregs
	*callm k_addto
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_subto =	! KA_SUBTO
assem
	cmp word16 [Dsptr+xb+ktag],trefvar	!lhs is ref var?
	jnz L1
	cmp word16 [Dsptr+ya+ktag],tint		!rhs is int
	jnz L1
	mov D4,[Dsptr+xb+kvarptr]
	cmp word16 [D4+ktag],tint			!lhs is ref var:int?
	jnz L1
	mov D0,[Dsptr+kvalue]
	sub [D4+kvalue],D0
	*popvar2
	*jumpskip1

L1:
	*saveregs
	*callm k_subto
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_multo =	! KA_MULTO
assem
	mov D4,[Dsptr+xb+kvarptr]
	cmp word16 [Dsptr+xb+ktag],trefvar	!lhs is ref var?
	jnz L99

	cmp word16 [D4+ktag],tint				!lhs is ref var:int?
	jnz L1								!mixed
	cmp word16 [Dsptr+ya+ktag],tint		!rhs is int
	jnz L99
	mov D0,[D4+kvalue]
	imul word64 [Dsptr+kvalue]
	mov [D4+kvalue],D0
	*popvar2
	*jumpskip1

L1:

L2:
L99:
	*saveregs
	*callm k_multo
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_divto =	! KA_DIVTO
assem
	*saveregs
	*callm k_divto
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_idivto =	! KA_IDIVTO
assem
	*saveregs
	*callm k_idivto
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_iandto =	! KA_IANDTO
assem
	*saveregs
	*callm k_iandto
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_iorto =	! KA_IORTO
assem
	*saveregs
	*callm k_iorto
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_ixorto =	! KA_IXORTO
assem
	*saveregs
	*callm k_ixorto
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_shlto =	! KA_SHLTO
assem
	cmp word16 [Dsptr+xb+ktag],trefvar	!lhs is ref var?
	jnz L1
	cmp word16 [Dsptr+ya+ktag],tint		!rhs is int
	jnz L1
	mov D4,[Dsptr+xb+kvarptr]
	cmp word16 [D4+ktag],tint			!lhs is ref var:int?
	jnz L1
	mov cl,[Dsptr+kvalue]
	mov D0,[D4+kvalue]
	shl D0,cl
	mov [D4+kvalue],D0
	*popvar2
	*jumpskip1
L1:
	*saveregs
	*callm k_shlto
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_shrto =	! KA_SHRTO
assem
	cmp word16 [Dsptr+xb+ktag],trefvar	!lhs is ref var?
	jnz L1
	cmp word16 [Dsptr+ya+ktag],tint		!rhs is int
	jnz L1
	mov D4,[Dsptr+xb+kvarptr]
	cmp word16 [D4+ktag],tint			!lhs is ref var:int?
	jnz L1
	mov cl,[Dsptr+kvalue]
	sar word64 [D4+kvalue],cl
	*popvar2
	*jumpskip1
L1:

	*saveregs
	*callm k_shrto
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_minto =	! KA_MINTO
assem
	*saveregs
	*callm k_minto
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_maxto =	! KA_MAXTO
assem
	*saveregs
	*callm k_maxto
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_concatto =	! KA_CONCATTO
assem
	*saveregs
	*callm k_concatto
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_appendto =	! KA_APPENDTO
assem
	*saveregs
	*callm k_appendto
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_pushix =	! KA_PUSHIX
static varrec v
assem
	cmp word16 [Dsptr+ya+ktag],tint
	jnz L99

	mov D6,[Dsptr+xb+ktag]
	cmp W6,tlist
	jnz L2

	mov D5,[Dsptr+xb+kobjptr]

	mov A4,[Dsptr+ya+kvalue]		!index
	sub A4,[D5+jlower]		!0-base
	cmp A4,[D5+jlength]
	jae L99					!bounds error: let C deal with it

	shl A4,varshift				!index*varsize
	add D4,[D5+jptr]			!point to element

	*popvar					!pop list, stack contains list descriptor

	mov D0,[D4+ktag]
	mov [Dsptr+ktag],D0			!replace index by list element

	mov D1,[D4+kvalue]
	mov [Dsptr+kvalue],D1

	and A0,hasrefmask
	jz L11
	inc word32 [D1+jrefcount]
L11:
	dec word32 [D5+jrefcount]	!dec count of original list
	jnz L12
	mov [v+ktag],D6
	mov [v+kobjptr],D5
	lea D10,[v]
	*callfreex
L12:
	*jumpskip1

L2:
L3:
L99:
	*saveregs
	*callm k_pushix
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_pushdotix =	! KA_PUSHDOTIX
assem
	*saveregs
	*callm k_pushdotix
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_pushkeyix =	! KA_PUSHKEYIX
assem
	*saveregs
	*callm k_pushkeyix
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_pushkeyixd =	! KA_PUSHKEYIXD
assem
	*saveregs
	*callm k_pushkeyixd
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_pushixref =	! KA_PUSHIXREF
assem
jmp L99
	cmp word16 [Dsptr+xb+ktag],trefvar
	jnz L3
	cmp word16 [Dsptr+ya+ktag],tint
	jnz L3
	mov D4,[Dsptr+xb+kvarptr]		!A4 points to array etc
	cmp word16 [D4+ktag],tlist
	jnz L2

JMP L99

	mov A5,[Dsptr+ya+kvalue]	!index
	sub A5,[D6+jlower]		!index=lower = 0-based index
	cmp A5,[D6+jlength]
	jae L3				!bounds overflow
	*popvar				!lose list ptr
	mov word32 [Dsptr+ktag],trefvar	!create new ref
	shl A5,varshift
	add D5,[D6+jptr]		!A5 points to element
	mov [Dsptr+kvarptr],D5
	*jumpskip1

L2:

L3:
L99:
	*saveregs
	*callm k_pushixref
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_pushdotixref =	! KA_PUSHDOTIXREF
assem
	*saveregs
	*callm k_pushdotixref
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_pushkeyixref =	! KA_PUSHKEYIXREF
assem
	*saveregs
	*callm k_pushkeyixref
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_pushbyteix =	! KA_PUSHBYTEIX
assem
	*saveregs
	*callm k_pushbyteix
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_pushbyteixref =	! KA_PUSHBYTEIXREF
assem
	*saveregs
	*callm k_pushbyteixref
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_appendset =	! KA_APPENDSET
assem
	*saveregs
	*callm k_appendset
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_pushdotm =	! KA_PUSHDOTM
assem
	*saveregs
	*callm k_pushdotm
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_pushdott =	! KA_PUSHDOTT
assem
	*saveregs
	*callm k_pushdott
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_push_ad =	! KA_PUSH_AD
assem
	*saveregs
	*callm k_push_ad
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_push_try =	! KA_PUSH_TRY
assem
	*saveregs
	*callm k_push_try
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_raise =	! KA_RAISE
assem
	*saveregs
	*callm k_raise
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_applyop =	! KA_APPLYOP
static [10]intpc codeseq
assem
	*saveregs
end
pcerror("APPLY OP NEEDS REVISING")
codeseq[1]:=sptr^.value			!copy jump lab which follows the applyop
++sptr
codeseq[2]:=(pcptr+1)^			!copy jump lab which follows the applyop
codeseq[3]:=(pcptr+2)^			!include the dest label
pcptr:=&codeseq[1]
assem
	mov D0,[pcptr]
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_makeiter =	! KA_MAKEITER
assem
	*saveregs
	*callm k_makeiter
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_forall =	! KA_FORALL
assem
	mov D3,[Dprog+kopndb]		!D3=pit
	mov D4,[Dprog+kopndc]		!D4=poolvar
	add D3,Dframe
	add D4,Dframe
	dec word32 [D3+kitcount]
	jz L30						!reached end of loop
	cmp byte [D3+kittype],tlist
	jnz L3
	mov D5,[D3+kvarptr]			!pelem
	mov A0,[D4+ktag]

L21:
	mov A0,[D5+ktag]
	mov [D4+ktag],A0
	mov A1,[D5+kvalue]
	mov [D4+kvalue],A1


L22:
	add D5,varsize
	mov [D3+kvarptr],D5
L29:
	mov Dprog,[Dprog+kopnda]
	*jumpnext


L3:
	jmp L99

L30:
	*jumpskip4

L99:
	*saveregs
	*callm k_forall
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_forallx =	! KA_FORALLX
assem
	*saveregs
	*callm k_forallx
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_foreach =	! KA_FOREACH
assem
	*saveregs
	*callm k_foreach
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_foreachx =	! KA_FOREACHX
assem
	*saveregs
	*callm k_foreachx
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_expandrange =	! KA_EXPANDRANGE
assem
	*saveregs
	*callm k_expandrange
	*loadregs
	*bjumpnext
endassem endproc

threadedproc ka_callappl =
assem
	*saveregs
	*callm k_callappl
	*loadregs
	*bjumpnext
endassem endproc


threadedproc jx_push_fff= 	! JX_PUSH_FFF
assem
	*pushvar3
	mov D4,[Dprog+kopnda]
	mov D0,[Dframe+D4+ktag]
	mov [Dsptr+xc+ktag],D0
	mov D1,[Dframe+D4+kvalue]
	mov [Dsptr+xc+kvalue],D1
	and A0,hasrefmask
	jz L1
	inc word32 [D1+jrefcount]
L1:

	mov D4,[Dprog+kopndb]
	mov D0,[Dframe+D4+ktag]
	mov [Dsptr+yb+ktag],D0
	mov D1,[Dframe+D4+kvalue]
	mov [Dsptr+yb+kvalue],D1
	and A0,hasrefmask
	jz L2
	inc word32 [D1+jrefcount]
L2:

	mov D4,[Dprog+kopndc]
	mov D0,[Dframe+D4+ktag]
	mov [Dsptr+za+ktag],D0
	mov D1,[Dframe+D4+kvalue]
	mov [Dsptr+za+kvalue],D1
	and A0,hasrefmask
	jz L3
	inc word32 [D1+jrefcount]
L3:
	add Dprog,intpsize6
	*jumpnext

endassem endproc

threadedproc jx_push_ff= 	! JX_PUSH_FF
assem
	*pushvar2
	mov D4,[Dprog+kopnda]
	mov D0,[Dframe+D4+ktag]
	mov [Dsptr+xb+ktag],D0
	mov D1,[Dframe+D4+kvalue]
	mov [Dsptr+xb+kvalue],D1
	and A0,hasrefmask
	jz L1
	inc word32 [D1+jrefcount]
L1:
	mov D4,[Dprog+kopndb]
	mov D0,[Dframe+D4+ktag]
	mov [Dsptr+ya+ktag],D0
	mov D1,[Dframe+D4+kvalue]
	mov [Dsptr+ya+kvalue],D1
	and A0,hasrefmask
	jz L2
	inc word32 [D1+jrefcount]
L2:
	*jumpskip4
endassem endproc

threadedproc jx_push_mm= 	! JX_PUSH_MM
assem
	*pushvar2
	mov D4,[Dprog+kopnda]
	mov D0,[D4+ktag]
	mov [Dsptr+xb+ktag],D0
	mov D1,[D4+kvalue]
	mov [Dsptr+xb+kvalue],D1
	and A0,hasrefmask
	jz L1
	inc word32 [D1+jrefcount]
L1:

	mov D4,[Dprog+kopndb]
	mov D0,[D4+ktag]
	mov [Dsptr+ya+ktag],D0
	mov D1,[D4+kvalue]
	mov [Dsptr+ya+kvalue],D1
	and A0,hasrefmask
	jz L2
	inc word32 [D1+jrefcount]
L2:

	*jumpskip4
endassem endproc

threadedproc jx_push_fm= 	! JX_PUSH_FM
assem
	*pushvar2
	mov D4,[Dprog+kopnda]
	mov D0,[Dframe+D4+ktag]
	mov [Dsptr+xb+ktag],D0
	mov D1,[Dframe+D4+kvalue]
	mov [Dsptr+xb+kvalue],D1
	and A0,hasrefmask
	jz L1
	inc word32 [D1+jrefcount]
L1:

	mov D4,[Dprog+kopndb]
	mov D0,[D4+ktag]
	mov [Dsptr+ya+ktag],D0
	mov D1,[D4+kvalue]
	mov [Dsptr+ya+kvalue],D1
	and A0,hasrefmask
	jz L2
	inc word32 [D1+jrefcount]
L2:

	*jumpskip4
endassem endproc

threadedproc jx_push_fci= 	! JX_PUSH_FCI
assem
	mov D4,[Dprog+kopnda]
	*pushvar2
	mov D0,[Dframe+D4+ktag]
	mov [Dsptr+xb+ktag],D0
	mov D1,[Dframe+D4+kvalue]
	mov [Dsptr+xb+kvalue],D1
	and A0,hasrefmask
	jz L1
	inc word32 [D1+jrefcount]
L1:

	mov word32 [Dsptr+ya+ktag],tint
	mov D0,[Dprog+kopndb]
	mov [Dsptr+ya+kvalue],D0

	*jumpskip4
endassem endproc

threadedproc jx_push_mci= 	! JX_PUSH_MCI
assem
	mov D4,[Dprog+kopnda]
	*pushvar2
	mov D0,[D4+ktag]
	mov [Dsptr+xb+ktag],D0
	mov D1,[D4+kvalue]
	mov [Dsptr+xb+kvalue],D1
	and A0,hasrefmask
	jz L1
	inc word32 [D1+jrefcount]
L1:

	mov word32 [Dsptr+ya+ktag],tint
	mov D0,[Dprog+kopndb]
	mov [Dsptr+ya+kvalue],D0

	*jumpskip4
endassem endproc

threadedproc jx_move_ff= 	! JX_MOVE_FF
assem
	mov D5,[Dprog+kopndb]
	cmp byte [Dframe+D5+khasref],1
	jnz L1
	mov D1,[Dframe+D5+kobjptr]
	inc word32 [D1+jrefcount]		!increment before freeing (in case of a:=a)
L1:
	mov D4,[Dprog+kopnda]
	add D4,Dframe
	cmp byte [D4+khasref],1
	jnz L2
	*callvxufree_d4
L2:
	mov D5,[Dprog+kopndb]
	mov D0,[Dframe+D5+ktag]
	mov [D4+ktag],D0
	mov D1,[Dframe+D5+kvalue]
	mov [D4+kvalue],D1

	*jumpskip4
endassem endproc


threadedproc jx_zmove_ff= 	! JX_ZMOVE_FF
assem
	mov D4,[Dprog+kopnda]
	add D4,Dframe

	mov D5,[Dprog+kopndb]
	mov D0,[D5+Dframe+ktag]
	mov [D4+ktag],D0
	mov D1,[D5+Dframe+kvalue]
	mov [D4+kvalue],D1
	cmp byte [D4+khasref],1
	jnz L2
	inc word32 [D1+jrefcount]
L2:
	*jumpskip4
endassem endproc


threadedproc jx_move_mf= 	! JX_MOVE_MF
assem
	mov D5,[Dprog+kopndb]
	cmp byte [Dframe+D5+khasref],1
	jnz L1
	mov D1,[Dframe+D5+kobjptr]
	inc word32 [D1+jrefcount]		!increment before freeing (in case of a:=a)
L1:
	mov D4,[Dprog+kopnda]
	cmp byte [D4+khasref],1
	jnz L2
	*callvxufree_d4
L2:
	mov D5,[Dprog+kopndb]
	mov D0,[Dframe+D5+ktag]
	mov [D4+ktag],D0
	mov D1,[Dframe+D5+kvalue]
	mov [D4+kvalue],D1

	*jumpskip4
endassem endproc



threadedproc jx_move_fm= 	! JX_MOVE_FM
assem
	mov D5,[Dprog+kopndb]
	cmp byte [D5+khasref],1
	jnz L1
	mov D1,[D5+kobjptr]
	inc word32 [D1+jrefcount]		!increment before freeing (in case of a:=a)
L1:
	mov D4,[Dprog+kopnda]
	add D4,Dframe
	cmp byte [D4+khasref],1
	jnz L2
	*callvxufree_d4
L2:
	mov D5,[Dprog+kopndb]
	mov D0,[D5+ktag]
	mov [D4+ktag],D0
	mov D1,[D5+kvalue]
	mov [D4+kvalue],D1

	*jumpskip4
endassem endproc


threadedproc jx_move_mm= 	! JX_MOVE_MM
assem
	mov D5,[Dprog+kopndb]
	cmp byte [D5+khasref],1
	jnz L1
	mov D1,[D5+kobjptr]
	inc word32 [D1+jrefcount]		!increment before freeing (in case of a:=a)
L1:
	mov D4,[Dprog+kopnda]
	cmp byte [D4+khasref],1
	jnz L2
	*callvxufree_d4
L2:
	mov D5,[Dprog+kopndb]
	mov D0,[D5+ktag]
	mov [D4+ktag],D0
	mov D1,[D5+kvalue]
	mov [D4+kvalue],D1

	*jumpskip4
endassem endproc


threadedproc jx_move_mci= 	! JX_MOVE_MCI
assem
	mov D4,[Dprog+kopnda]
	cmp byte [D4+khasref],1
	jnz L1
	*callvxufree_d4
L1:
	mov word32 [D4+ktag],tint
	mov D0,[Dprog+kopndb]
	mov [D4+kvalue],D0
	*jumpskip4
endassem endproc

threadedproc jx_move_fci= 	! JX_MOVE_FCI
assem
	mov D4,[Dprog+kopnda]
	add D4,Dframe
	cmp byte [D4+khasref],1
	jnz L1
	*callvxufree_d4
L1:
	mov word32 [D4+ktag],tint
	mov D0,[Dprog+kopndb]
	mov [D4+kvalue],D0
	*jumpskip4
endassem endproc

threadedproc jx_zmove_fci= 	! JX_ZMOVE_FCI
assem
	mov D4,[Dprog+kopnda]
	mov word32 [Dframe+D4+ktag],tint
	mov D0,[Dprog+kopndb]
	mov [Dframe+D4+kvalue],D0
	*jumpskip4
endassem endproc

threadedproc jx_pushz_void2 =	! JX_PUSHZ_VOID2
assem
	*pushvar2
	mov word32 [Dsptr+xb+ktag],tvoid
	mov word32 [Dsptr+ya+ktag],tvoid
	*jumpskip2
endassem endproc

threadedproc jx_pushz_void3 =	! JX_PUSHZ_VOID3
assem
	*pushvar3
	mov word32 [Dsptr+xc+ktag],tvoid
	mov word32 [Dsptr+yb+ktag],tvoid
	mov word32 [Dsptr+za+ktag],tvoid
	*jumpskip3
endassem endproc

threadedproc jx_switch_f =	! JX_SWITCH
assem
	mov D3,[Dprog+kopnda]
	cmp word16 [D3+Dframe+ktag],tint
	jnz L99				!get C deal with errors
	mov D4,[D3+Dframe+kvalue]		!switch index
	sub D4,[Dprog+kopndc]		!index-lower! now 0-based index
	cmp D4,[Dprog+kopndb]		!index0>=n?
	jae L2				!out of range
	shl D4,1
	mov Dprog,[Dprog+D4*8+intpsize6]
	*jumpnext
L2:
	mov D5,[Dprog+kopndb]
	shl D5,1
	mov Dprog,[Dprog+D5*8+intpsize6]
	*jumpnext

L99:
end
pcerror("jxswitchf/not int")
end

threadedproc jx_upb_f =	! JX_UPB_F
assem
	mov D3,[Dprog+kopnda]
	cmp byte [D3+Dframe+khasref],1
	jnz L2
	mov D4,[D3+Dframe+kobjptr]			!assume this is an object
	*pushvar
	mov word32 [Dsptr+ktag],tint
	mov A0,[D4+jlength]
	movsx A1,word16 [D4+jlower]
	add A0,A1
	dec A0
	mov [Dsptr+kvalue],D0
	*jumpskip3
L2:
	cmp word16 [D3+Dframe+ktag],trange
	jnz L99
	*pushvar
	mov word32 [Dsptr+ktag],tint
	mov A0,[D3+Dframe+krange_upper]
	mov [Dsptr+kvalue],D0
	*jumpskip3

L99:
	*csaveregs
end
pcerror("jxupb/not obj")
end

threadedproc jx_len_f =	! JX_LEN_F
static variant p

assem
	mov D3,[Dprog+kopnda]
	mov [p],D3
	cmp word16 [D3+Dframe+ktag],tbignum
	jz L3

	cmp byte [D3+Dframe+khasref],1
	jnz L2
	mov D4,[D3+Dframe+kobjptr]			!assume this is an object
	*pushvar
	mov word32 [Dsptr+ktag],tint
	mov A0,[D4+jlength]
	mov [Dsptr+kvalue],D0
	*jumpskip3
L2:
	cmp word16 [D3+Dframe+ktag],trange
	jnz L99
	*pushvar
	mov word32 [Dsptr+ktag],tint
	mov A0,[D3+Dframe+krange_upper]
	sub A0,[D3+Dframe+krange_lower]
	inc A0
	mov [Dsptr+kvalue],D0
	*jumpskip3

L3:
	*pushvar
	mov word32 [Dsptr+ktag],tint
	mov A0,[D3+Dframe+kbndigits]
	imul2 A0,6
	mov [Dsptr+kvalue],D0
	*jumpskip3

L99:
	*csaveregs
end
p:=cast(frameptr+getopnda)
CPL gettypename(p^.tag),p^.hasref
pcerror("jxlen/not obj")
end

threadedproc jx_jumpdef_f =	! JX_JUMPDEF_F
assem
	mov D3,[Dprog+kopnda]
	cmp word16 [D3+Dframe+ktag],tvoid
	jg Lisdef1
	*jumpskip4

Lisdef1:
	mov Dprog,[Dprog+kopndb]
	*jumpnext
endassem endproc

threadedproc jx_jumpvoid_f =	! JX_JUMPVOID_F
assem
	mov D3,[Dprog+kopnda]
	cmp word16 [D3+Dframe+ktag],tvoid
	jbe L1
	*jumpskip4

L1:
	mov Dprog,[Dprog+kopndb]
	*jumpnext
endassem endproc

threadedproc jx_free_10xx= 	! JX_FREE_10
assem
jx_free_10:
	cmp byte [Dsptr+khasref],1
	jnz L1
	mov D1,[Dsptr+kobjptr]
	dec word32 [D1+jrefcount]
	jnz L1
	*callfreex_dsptr
L1:
	*popvar

jx_free_9:
	cmp byte [Dsptr+khasref],1
	jnz L2
	mov D1,[Dsptr+kobjptr]
	dec word32 [D1+jrefcount]
	jnz L2
	*callfreex_dsptr
L2:
	*popvar

jx_free_8:
	cmp byte [Dsptr+khasref],1
	jnz L3
	mov D1,[Dsptr+kobjptr]
	dec word32 [D1+jrefcount]
	jnz L3
	*callfreex_dsptr
L3:
	*popvar

jx_free_7:
	cmp byte [Dsptr+khasref],1
	jnz L4
	mov D1,[Dsptr+kobjptr]
	dec word32 [D1+jrefcount]
	jnz L4
	*callfreex_dsptr
L4:
	*popvar

jx_free_6:
	cmp byte [Dsptr+khasref],1
	jnz L5
	mov D1,[Dsptr+kobjptr]
	dec word32 [D1+jrefcount]
	jnz L5
	*callfreex_dsptr
L5:
	*popvar

jx_free_5:
	cmp byte [Dsptr+khasref],1
	jnz L6
	mov D1,[Dsptr+kobjptr]
	dec word32 [D1+jrefcount]
	jnz L6
	*callfreex_dsptr
L6:
	*popvar

jx_free_4:
	cmp byte [Dsptr+khasref],1
	jnz L7
	mov D1,[Dsptr+kobjptr]
	dec word32 [D1+jrefcount]
	jnz L7
	*callfreex_dsptr
L7:
	*popvar

jx_free_3:
	cmp byte [Dsptr+khasref],1
	jnz L8
	mov D1,[Dsptr+kobjptr]
	dec word32 [D1+jrefcount]
	jnz L8
	*callfreex_dsptr
L8:
	*popvar

jx_free_2:
	cmp byte [Dsptr+khasref],1
	jnz L9
	mov D1,[Dsptr+kobjptr]
	dec word32 [D1+jrefcount]
	jnz L9
	*callfreex_dsptr
L9:
	*popvar

jx_free_1:
	cmp byte [Dsptr+khasref],1
	jnz L10
	mov D1,[Dsptr+kobjptr]
	dec word32 [D1+jrefcount]
	jnz L10
	*callfreex_dsptr
L10:
	*popvar

	*jumpskip2
endassem endproc

threadedproc jx_jumptrue_i =	! JX_JUMPTRUE_I
assem
	mov D0,[Dsptr+xa+kvalue]
	and D0,D0
	jz L2
	mov Dprog,[Dprog+kopnda]
	*popvar
	*jumpnext

L2:
	*popvar
	*jumpskip2
endassem endproc

threadedproc jx_jumpfalse_i =	! JX_JUMPFALSE_I
assem
	mov D0,[Dsptr+xa+kvalue]
	and D0,D0
	jnz L2
	mov Dprog,[Dprog+kopnda]
	*popvar
	*jumpnext

L2:
	*popvar
	*jumpskip2
endassem endproc

threadedproc jx_add_ff= 	! JX_ADD_FF
assem
	mov D4,[Dprog+kopnda]
	mov D5,[Dprog+kopndb]
	cmp word16 [D4+Dframe+ktag],tint
	jnz L1
	cmp word16 [D5+Dframe+ktag],tint
	jnz L1
	*pushvar
	mov word32 [Dsptr+xa+ktag],tint
	mov D0,[Dframe+D4+kvalue]
	add D0,[Dframe+D5+kvalue]
	mov [Dsptr+kvalue],D0
	*jumpskip5
L1:
	*pushvar2

	mov D0,[Dframe+D4+ktag]
	mov [Dsptr+xb+ktag],D0
	mov D1,[Dframe+D4+kvalue]
	mov [Dsptr+xb+kvalue],D1
	and A0,hasrefmask
	jz L2
	inc word32 [D1+jrefcount]
L2:
	mov D0,[Dframe+D5+ktag]
	mov [Dsptr+ya+ktag],D0
	mov D1,[Dframe+D5+kvalue]
	mov [Dsptr+ya+kvalue],D1
	and A0,hasrefmask
	jz L3
	inc word32 [D1+jrefcount]
L3:

	add Dprog,intpsize4

	*saveregs
	*callm k_add
	*loadregs
	*bjumpnext
endassem endproc

threadedproc jx_add_fci= 	! JX_ADD_FCI
assem
	mov D4,[Dprog+kopnda]
	mov D5,[Dprog+kopndb]
	cmp word16 [D4+Dframe+ktag],tint
	jnz L1
	*pushvar
	mov word32 [Dsptr+ktag],tint
	mov D0,[Dframe+D4+kvalue]
	add D0,D5
	mov [Dsptr+kvalue],D0
	*jumpskip5
L1:
	*pushvar2

	mov D0,[Dframe+D4+ktag]
	mov [Dsptr+xb+ktag],D0
	mov D1,[Dframe+D4+kvalue]
	mov [Dsptr+xb+kvalue],D1
	and A0,hasrefmask
	jz L2
	inc word32 [D1+jrefcount]
L2:

	mov word32 [Dsptr+ya+ktag],tint
	mov [Dsptr+ya+kvalue],D5
	add Dprog,intpsize4

	*saveregs
	*callm k_add
	*loadregs
	*bjumpnext
endassem endproc

threadedproc jx_sub_ff= 	! JX_SUB_FF
assem
	mov D4,[Dprog+kopnda]
	mov D5,[Dprog+kopndb]
	cmp word16 [D4+Dframe+ktag],tint
	jnz L1
	cmp word16 [D5+Dframe+ktag],tint
	jnz L1
	*pushvar
	mov word32 [Dsptr+xa+ktag],tint
	mov D0,[Dframe+D4+kvalue]
	sub D0,[Dframe+D5+kvalue]
	mov [Dsptr+kvalue],D0
	*jumpskip5
L1:
	*pushvar2
	mov D0,[Dframe+D4+ktag]
	mov [Dsptr+xb+ktag],D0
	mov D1,[Dframe+D4+kvalue]
	mov [Dsptr+xb+kvalue],D1
	and A0,hasrefmask
	jz L2
	inc word32 [D1+jrefcount]
L2:
	mov D0,[Dframe+D5+ktag]
	mov [Dsptr+ya+ktag],D0
	mov D1,[Dframe+D5+kvalue]
	mov [Dsptr+ya+kvalue],D1
	and A0,hasrefmask
	jz L3
	inc word32 [D1+jrefcount]
L3:
	add Dprog,intpsize4
	*saveregs
	*callm k_sub
	*loadregs
	*bjumpnext
endassem endproc

threadedproc jx_sub_fci= 	! JX_SUB_FCI
assem
	mov D4,[Dprog+kopnda]
	mov D5,[Dprog+kopndb]
	cmp word16 [D4+Dframe+ktag],tint
	jnz L1
	*pushvar
	mov word32 [Dsptr+ktag],tint
	mov D0,[Dframe+D4+kvalue]
	sub D0,D5
	mov [Dsptr+kvalue],D0
	*jumpskip5
L1:
	*pushvar2
	mov D0,[Dframe+D4+ktag]
	mov [Dsptr+xb+ktag],D0
	mov D1,[Dframe+D4+kvalue]
	mov [Dsptr+xb+kvalue],D1
	and A0,hasrefmask
	jz L2
	inc word32 [D1+jrefcount]
L2:
	mov word32 [Dsptr+ya+ktag],tint
	mov [Dsptr+ya+kvalue],D5
	add Dprog,intpsize4
	*saveregs
	*callm k_sub
	*loadregs
	*bjumpnext
endassem endproc

threadedproc jx_jumpeq_ff= 	! JX_JUMPEQ_FF
assem
	mov D4,[Dprog+kopnda]
	mov D5,[Dprog+kopndb]
	cmp word16 [D4+Dframe+ktag],tint
	jnz L99
	cmp word16 [D5+Dframe+ktag],tint
	jnz L99

	mov D0,[Dframe+D4+kvalue]
	cmp D0,[Dframe+D5+kvalue]
	jnz Lfalse
	mov Dprog,[Dprog+kopndc]
	*jumpnext
Lfalse:
	add Dprog,intpsize6
	*jumpnext

L99:
	*pushvar2
	mov D0,[Dframe+D4+ktag]
	mov [Dsptr+xb+ktag],D0
	mov D1,[Dframe+D4+kvalue]
	mov [Dsptr+xb+kvalue],D1
	and A0,hasrefmask
	jz L2
	inc word32 [D1+jrefcount]
L2:
	mov D0,[Dframe+D5+ktag]
	mov [Dsptr+ya+ktag],D0
	mov D1,[Dframe+D5+kvalue]
	mov [Dsptr+ya+kvalue],D1
	and A0,hasrefmask
	jz L3
	inc word32 [D1+jrefcount]
L3:

	add Dprog,intpsize4

	*saveregs
	*callm k_jumpeq
	*loadregs
	*bjumpnext
endassem endproc

threadedproc jx_jumpeq_fci= 	! JX_JUMPEQ_FCI
assem
	mov D4,[Dprog+kopnda]
	mov D5,[Dprog+kopndb]
	cmp word16 [D4+Dframe+ktag],tint
	jnz L99

	mov D0,[Dframe+D4+kvalue]
	cmp D0,[Dprog+kopndb]
	jnz Lfalse
	mov Dprog,[Dprog+kopndc]
	*jumpnext
Lfalse:
	add Dprog,intpsize6
	*jumpnext

L99:
	*pushvar2
	mov D0,[Dframe+D4+ktag]
	mov [Dsptr+xb+ktag],D0
	mov D1,[Dframe+D4+kvalue]
	mov [Dsptr+xb+kvalue],D1
	and A0,hasrefmask
	jz L2
	inc word32 [D1+jrefcount]
L2:
	mov word32 [Dsptr+ya+ktag],tint
	mov [Dsptr+ya+kvalue],D5

	add Dprog,intpsize4

	*saveregs
	*callm k_jumpeq
	*loadregs
	*bjumpnext
endassem endproc

threadedproc jx_jumpne_ff= 	! JX_JUMPNE_FF
assem
	mov D4,[Dprog+kopnda]
	mov D5,[Dprog+kopndb]
	cmp word16 [D4+Dframe+ktag],tint
	jnz L99
	cmp word16 [D5+Dframe+ktag],tint
	jnz L99

	mov D0,[Dframe+D4+kvalue]
	cmp D0,[Dframe+D5+kvalue]
	jz Lfalse
	mov Dprog,[Dprog+kopndc]
	*jumpnext
Lfalse:
	add Dprog,intpsize6
	*jumpnext

L99:
	*pushvar2
	mov D0,[Dframe+D4+ktag]
	mov [Dsptr+xb+ktag],D0
	mov D1,[Dframe+D4+kvalue]
	mov [Dsptr+xb+kvalue],D1
	and A0,hasrefmask
	jz L2
	inc word32 [D1+jrefcount]
L2:
	mov D0,[Dframe+D5+ktag]
	mov [Dsptr+ya+ktag],D0
	mov D1,[Dframe+D5+kvalue]
	mov [Dsptr+ya+kvalue],D1
	and A0,hasrefmask
	jz L3
	inc word32 [D1+jrefcount]
L3:
	add Dprog,intpsize4

	*saveregs
	*callm k_jumpne
	*loadregs
	*bjumpnext
endassem endproc

threadedproc jx_jumpne_fci= 	! JX_JUMPNE_FCI
assem
	mov D4,[Dprog+kopnda]
	mov D5,[Dprog+kopndb]
	cmp word16 [D4+Dframe+ktag],tint
	jnz L99

	mov D0,[Dframe+D4+kvalue]
	cmp D0,[Dprog+kopndb]
	jz Lfalse
	mov Dprog,[Dprog+kopndc]
	*jumpnext
Lfalse:
	add Dprog,intpsize6
	*jumpnext

L99:
	*pushvar2
	mov D0,[Dframe+D4+ktag]
	mov [Dsptr+xb+ktag],D0
	mov D1,[Dframe+D4+kvalue]
	mov [Dsptr+xb+kvalue],D1
	and A0,hasrefmask
	jz L2
	inc word32 [D1+jrefcount]
L2:
	mov word32 [Dsptr+ya+ktag],tint
	mov [Dsptr+ya+kvalue],D5

	add Dprog,intpsize4

	*saveregs
	*callm k_jumpne
	*loadregs
	*bjumpnext
endassem endproc

threadedproc jx_jumplt_ff= 	! JX_JUMPLT_FF
assem
	mov D4,[Dprog+kopnda]
	mov D5,[Dprog+kopndb]
	cmp word16 [D4+Dframe+ktag],tint
	jnz L99
	cmp word16 [D5+Dframe+ktag],tint
	jnz L99

	mov D0,[Dframe+D4+kvalue]
	cmp D0,[Dframe+D5+kvalue]
	jge Lfalse
	mov Dprog,[Dprog+kopndc]
	*jumpnext
Lfalse:
	add Dprog,intpsize6
	*jumpnext

L99:
	*pushvar2
	mov D0,[Dframe+D4+ktag]
	mov [Dsptr+xb+ktag],D0
	mov D1,[Dframe+D4+kvalue]
	mov [Dsptr+xb+kvalue],D1
	and A0,hasrefmask
	jz L2
	inc word32 [D1+jrefcount]
L2:
	mov D0,[Dframe+D5+ktag]
	mov [Dsptr+ya+ktag],D0
	mov D1,[Dframe+D5+kvalue]
	mov [Dsptr+ya+kvalue],D1
	and A0,hasrefmask
	jz L3
	inc word32 [D1+jrefcount]
L3:

	add Dprog,intpsize4

	*saveregs
	*callm k_jumplt
	*loadregs
	*bjumpnext
endassem endproc

threadedproc jx_jumplt_fci= 	! JX_JUMPLT_FCI
assem
	mov D4,[Dprog+kopnda]
	mov D5,[Dprog+kopndb]
	cmp word16 [D4+Dframe+ktag],tint
	jnz L99

	mov D0,[Dframe+D4+kvalue]
	cmp D0,[Dprog+kopndb]
	jge Lfalse
	mov Dprog,[Dprog+kopndc]
	*jumpnext
Lfalse:
	add Dprog,intpsize6
	*jumpnext

L99:
	*pushvar2
	mov D0,[Dframe+D4+ktag]
	mov [Dsptr+xb+ktag],D0
	mov D1,[Dframe+D4+kvalue]
	mov [Dsptr+xb+kvalue],D1
	and A0,hasrefmask
	jz L2
	inc word32 [D1+jrefcount]
L2:
	mov word32 [Dsptr+ya+ktag],tint
	mov [Dsptr+ya+kvalue],D5

	add Dprog,intpsize4

	*saveregs
	*callm k_jumplt
	*loadregs
	*bjumpnext
endassem endproc

threadedproc jx_jumple_ff= 	! JX_JUMPLE_FF
assem
	mov D4,[Dprog+kopnda]
	mov D5,[Dprog+kopndb]
	cmp word16 [D4+Dframe+ktag],tint
	jnz L99
	cmp word16 [D5+Dframe+ktag],tint
	jnz L99

	mov D0,[Dframe+D4+kvalue]
	cmp D0,[Dframe+D5+kvalue]
	jg Lfalse
	mov Dprog,[Dprog+kopndc]
	*jumpnext
Lfalse:
	add Dprog,intpsize6
	*jumpnext

L99:
	*pushvar2
	mov D0,[Dframe+D4+ktag]
	mov [Dsptr+xb+ktag],D0
	mov D1,[Dframe+D4+kvalue]
	mov [Dsptr+xb+kvalue],D1
	and A0,hasrefmask
	jz L2
	inc word32 [D1+jrefcount]
L2:
	mov D0,[Dframe+D5+ktag]
	mov [Dsptr+ya+ktag],D0
	mov D1,[Dframe+D5+kvalue]
	mov [Dsptr+ya+kvalue],D1
	and A0,hasrefmask
	jz L3
	inc word32 [D1+jrefcount]
L3:

	add Dprog,intpsize4

	*saveregs
	*callm k_jumple
	*loadregs
	*bjumpnext
endassem endproc

threadedproc jx_jumple_fci= 	! JX_JUMPLE_FCI
assem
	mov D4,[Dprog+kopnda]
	mov D5,[Dprog+kopndb]
	cmp word16 [D4+Dframe+ktag],tint
	jnz L99

	mov D0,[Dframe+D4+kvalue]
	cmp D0,[Dprog+kopndb]
	jg Lfalse
	mov Dprog,[Dprog+kopndc]
	*jumpnext
Lfalse:
	add Dprog,intpsize6
	*jumpnext

L99:
	*pushvar2
	mov D0,[Dframe+D4+ktag]
	mov [Dsptr+xb+ktag],D0
	mov D1,[Dframe+D4+kvalue]
	mov [Dsptr+xb+kvalue],D1
	and A0,hasrefmask
	jz L2
	inc word32 [D1+jrefcount]
L2:
	mov word32 [Dsptr+ya+ktag],tint
	mov [Dsptr+ya+kvalue],D5

	add Dprog,intpsize4

	*saveregs
	*callm k_jumple
	*loadregs
	*bjumpnext
endassem endproc

threadedproc jx_jumpge_ff= 	! JX_JUMPGE_FF
assem
	mov D4,[Dprog+kopnda]
	mov D5,[Dprog+kopndb]
	cmp word16 [D4+Dframe+ktag],tint
	jnz L99
	cmp word16 [D5+Dframe+ktag],tint
	jnz L99

	mov D0,[Dframe+D4+kvalue]
	cmp D0,[Dframe+D5+kvalue]
	jl Lfalse
	mov Dprog,[Dprog+kopndc]
	*jumpnext
Lfalse:
	add Dprog,intpsize6
	*jumpnext

L99:
	*pushvar2
	mov D0,[Dframe+D4+ktag]
	mov [Dsptr+xb+ktag],D0
	mov D1,[Dframe+D4+kvalue]
	mov [Dsptr+xb+kvalue],D1
	and A0,hasrefmask
	jz L2
	inc word32 [D1+jrefcount]
L2:
	mov D0,[Dframe+D5+ktag]
	mov [Dsptr+ya+ktag],D0
	mov D1,[Dframe+D5+kvalue]
	mov [Dsptr+ya+kvalue],D1
	and A0,hasrefmask
	jz L3
	inc word32 [D1+jrefcount]
L3:

	add Dprog,intpsize4

	*saveregs
	*callm k_jumpge
	*loadregs
	*bjumpnext
endassem endproc

threadedproc jx_jumpge_fci= 	! JX_JUMPGE_FCI
assem
	mov D4,[Dprog+kopnda]
	mov D5,[Dprog+kopndb]
	cmp word16 [D4+Dframe+ktag],tint
	jnz L99

	mov D0,[Dframe+D4+kvalue]
	cmp D0,[Dprog+kopndb]
	jl Lfalse
	mov Dprog,[Dprog+kopndc]
	*jumpnext
Lfalse:
	add Dprog,intpsize6
	*jumpnext

L99:
	*pushvar2
	mov D0,[Dframe+D4+ktag]
	mov [Dsptr+xb+ktag],D0
	mov D1,[Dframe+D4+kvalue]
	mov [Dsptr+xb+kvalue],D1
	and A0,hasrefmask
	jz L2
	inc word32 [D1+jrefcount]
L2:
	mov word32 [Dsptr+ya+ktag],tint
	mov [Dsptr+ya+kvalue],D5

	add Dprog,intpsize4

	*saveregs
	*callm k_jumpge
	*loadregs
	*bjumpnext
endassem endproc

threadedproc jx_jumpgt_ff= 	! JX_JUMPGT_FF
assem
	mov D4,[Dprog+kopnda]
	mov D5,[Dprog+kopndb]
	cmp word16 [D4+Dframe+ktag],tint
	jnz L99
	cmp word16 [D5+Dframe+ktag],tint
	jnz L99

	mov D0,[Dframe+D4+kvalue]
	cmp D0,[Dframe+D5+kvalue]
	jle Lfalse
	mov Dprog,[Dprog+kopndc]
	*jumpnext
Lfalse:
	add Dprog,intpsize6
	*jumpnext

L99:
	*pushvar2
	mov D0,[Dframe+D4+ktag]
	mov [Dsptr+xb+ktag],D0
	mov D1,[Dframe+D4+kvalue]
	mov [Dsptr+xb+kvalue],D1
	and A0,hasrefmask
	jz L2
	inc word32 [D1+jrefcount]
L2:
	mov D0,[Dframe+D5+ktag]
	mov [Dsptr+ya+ktag],D0
	mov D1,[Dframe+D5+kvalue]
	mov [Dsptr+ya+kvalue],D1
	and A0,hasrefmask
	jz L3
	inc word32 [D1+jrefcount]
L3:

	add Dprog,intpsize4

	*saveregs
	*callm k_jumpgt
	*loadregs
	*bjumpnext
endassem endproc

threadedproc jx_jumpgt_fci= 	! JX_JUMPGT_FCI
assem
	mov D4,[Dprog+kopnda]
	mov D5,[Dprog+kopndb]
	cmp word16 [D4+Dframe+ktag],tint
	jnz L99

	mov D0,[Dframe+D4+kvalue]
	cmp D0,[Dprog+kopndb]
	jle Lfalse
	mov Dprog,[Dprog+kopndc]
	*jumpnext
Lfalse:
	add Dprog,intpsize6
	*jumpnext

L99:
	*pushvar2
	mov D0,[Dframe+D4+ktag]
	mov [Dsptr+xb+ktag],D0
	mov D1,[Dframe+D4+kvalue]
	mov [Dsptr+xb+kvalue],D1
	and A0,hasrefmask
	jz L2
	inc word32 [D1+jrefcount]
L2:
	mov word32 [Dsptr+ya+ktag],tint
	mov [Dsptr+ya+kvalue],D5

	add Dprog,intpsize4

	*saveregs
	*callm k_jumpgt
	*loadregs
	*bjumpnext
endassem endproc

threadedproc jx_pushix_ff =	! JX_PUSHIX_FF
static varrec vvv

assem
	mov D2,[Dprog+kopnda]
	mov D3,[Dprog+kopndb]
	cmp word16 [D2+Dframe+ktag],tlist
	jnz L99
	cmp word16 [D3+Dframe+ktag],tint
	jnz L99

	mov D6,[D2+Dframe+ktag]

	mov D5,[D2+Dframe+kobjptr]
	mov D4,[D3+Dframe+kvalue]		!index
	sub A4,[D5+jlower]		!0-base
	cmp A4,[D5+jlength]
	jae L99					!bounds error: let B deal with it

	shl A4,varshift				!index*varsize
	add D4,[D5+jptr]			!point to element

	*pushvar
	mov D0,[D4+ktag]
	mov [Dsptr+ktag],D0			!replace index by list element
	mov D1,[D4+kvalue]
	mov [Dsptr+kvalue],D1
	and A0,hasrefmask
	jz L1
	inc word32 [D1+jrefcount]
L1:
	*jumpskip5

L99:
	*pushvar2
	mov D0,[Dframe+D2+ktag]
	mov [Dsptr+xb+ktag],D0
	mov D1,[Dframe+D2+kvalue]
	mov [Dsptr+xb+kvalue],D1
	and A0,hasrefmask
	jz L12
	inc word32 [D1+jrefcount]
L12:
	mov D0,[Dframe+D3+ktag]
	mov [Dsptr+ya+ktag],D0
	mov D1,[Dframe+D3+kvalue]
	mov [Dsptr+ya+kvalue],D1
	and A0,hasrefmask
	jz L13
	inc word32 [D1+jrefcount]
L13:

	add Dprog,intpsize4
	jmp ka_pushix

	*saveregs
	*callm k_pushix
	*loadregs
	*bjumpnext
endassem endproc

threadedproc jx_popix_ff =	! JX_POPIX_FF
assem
	mov D2,[Dprog+kopnda]
	mov D3,[Dprog+kopndb]
	cmp word16 [D2+Dframe+ktag],tlist
	jnz L99
	cmp word16 [D3+Dframe+ktag],tint
	jnz L99

	mov D5,[D2+Dframe+kobjptr]

	cmp byte[D5+jmutable],0
	jz L99


	mov D4,[D3+Dframe+kvalue]		!index
	sub A4,[D5+jlower]		!0-base
	cmp A4,[D5+jlength]
	jae L99					!bounds error: let B deal with it (might be extending too)

	shl A4,varshift				!index*varsize
	add D4,[D5+jptr]			!point to element


	cmp byte [Dsptr+khasref],1
	jnz L1
	mov D1,[Dsptr+kobjptr]
	inc word32 [D1+jrefcount]
L1:
	cmp byte [D4+khasref],1
	jnz L2
	*callvxufree_d4
L2:
	mov D0,[Dsptr+ktag]
	mov [D4+ktag],D0
	mov D1,[Dsptr+kvalue]
	mov [D4+kvalue],D1
	*popvar

	add Dprog,intpsize6
	*jumpnext

L99:
	*pushvar2

	mov word32 [Dsptr+xb+ktag],trefvar
	lea D0,[D2+Dframe]
	mov [Dsptr+xb+kvarptr],D0

	mov D0,[Dframe+D3+ktag]
	mov [Dsptr+ya+ktag],D0
	mov D1,[Dframe+D3+kvalue]
	mov [Dsptr+ya+kvalue],D1
	and D0,hasrefmask
	jz L100
	inc word32 [D1+jrefcount]
L100:
	add Dprog,intpsize4		!pushixref followed by popptr next

	*saveregs
	*callm k_pushixref
	*loadregs
	*bjumpnext
endassem endproc

threadedproc jx_pushptr_f =	! JX_PUSHPTR_F
assem
	*pushvar
	mov D2,[Dprog+kopnda]
	add D2,Dframe
	cmp word16 [D2+ktag],trefvar
	jnz L1
	mov D4,[D2+kvarptr]

	mov D0,[D4+ktag]
	mov [Dsptr+ktag],D0
	mov D1,[D4+kvalue]
	mov [Dsptr+kvalue],D1
	and A0,hasrefmask
	jz L0
	inc word32 [D1+jrefcount]
L0:
	*jumpskip3

L1:
	cmp word16 [D2+ktag],trefpacked
	jnz L2

	mov D4,[D2+kpackptr]
	movzx A0,word16 [D2+krefelemtag]
	cmp A0,ti32
	jnz L10
	mov word32 [Dsptr+ktag],tint
	mov A0,[D4]
	movsxd D0,A0
	mov [Dsptr+kvalue],D0
	*jumpskip3
L10:
	cmp A0,tu8
	jnz L11
	mov word32 [Dsptr+ktag],tint
	movzx A0,byte [D4]
	mov [Dsptr+kvalue],D0
	*jumpskip3
L11:

L2:
L99:
	mov D0,[D2+ktag]
	mov [Dsptr+xa+ktag],D0
	mov D1,[D2+kvalue]
	mov [Dsptr+xa+kvalue],D1			!assume pointer is not a heap object
	add Dprog, intpsize2
	jmp ka_pushptr

	*saveregs
	*callm k_pushptr
	*loadregs
	*bjumpnext
endassem endproc

threadedproc jx_pushincrptr_m =	! JX_PUSHINCRPTR_M

assem
	mov D2,[Dprog+kopnda]
jx_pushipm1:
	cmp word16 [D2+ktag],trefpacked
	jnz L99							!not pointer to packed type
	cmp word16 [D2+krefelemtag],tu8
	jnz L99

	mov D5,[D2+kpackptr]
	inc word64 [D2+kpackptr]
	movzx A0,byte [D5]

	*pushvar
	mov word32 [Dsptr+ktag],tint
	mov [Dsptr+kvalue],D0
	*jumpskip4

L99:
	*pushvar

	mov word32 [Dsptr+ktag],trefvar
	lea D0,[D2]
	mov [Dsptr+kvarptr],D0
	add Dprog,intpsize2			!point at loadincr (with pushptr next)

	*saveregs
	*callm k_loadincr
	*loadregs
	*bjumpnext
endassem endproc

threadedproc jx_pushincrptr_f =	! JX_PUSHINCRPTR_F

assem
	mov D2,[Dprog+kopnda]
	add D2,Dframe
	jmp jx_pushincrptr_m.jx_pushipm1
endassem endproc

threadedproc jx_popincrptr_m =	! JX_POPINCRPTR_M

assem
	mov D2,[Dprog+kopnda]
jx_popipm1:
	cmp word16 [D2+ktag],trefpacked
	jnz L99							!not pointer to packed type
	cmp word16 [Dsptr+ktag],tint
	jnz L99							!let B deal with conversions or errors

	cmp word16 [D2+krefelemtag],tu8
	jnz L2

	mov D5,[D2+kpackptr]
	inc word64 [D2+kpackptr]

	mov D0,[Dsptr+kvalue]
	mov [D5],B0
	*popvar
	*jumpskip4

L2:
	cmp word16 [D2+krefelemtag],ti32
	jnz L3

	mov D5,[D2+kpackptr]
	add word64 [D2+kpackptr],4

	mov D0,[Dsptr+kvalue]
	mov [D5],A0
	*popvar
	*jumpskip4

L3:

L99:
	*pushvar

	mov word32 [Dsptr+ktag],trefvar
	lea D0,[D2]
	mov [Dsptr+kvarptr],D0
	add Dprog,intpsize2			!point at loadincr (with pushptr next)

	*saveregs
	*callm k_loadincr
	*loadregs
	*bjumpnext
endassem endproc

threadedproc jx_popincrptr_f =	! JX_POPINCRPTR_F
assem
	mov D2,[Dprog+kopnda]
	add D2,Dframe
	jmp jx_popincrptr_m.jx_popipm1
endassem endproc

threadedproc jx_addto_ff =	! JX_ADDTO_FF
assem
	mov D2,[Dprog+kopnda]
	mov D3,[Dprog+kopndb]
	cmp word16 [D2+Dframe+ktag],tint
	jnz L1
	cmp word16 [D3+Dframe+ktag],tint
	jnz L1

	mov D0,[D3+Dframe+kvalue]
	add [D2+Dframe+kvalue],D0
	*jumpskip5

L1:

L2:
L99:
	*pushvar2

	mov word32 [Dsptr+xb+ktag],trefvar
	lea D0,[D2+Dframe]
	mov [Dsptr+xb+kvarptr],D0

	mov D0,[Dframe+D3+ktag]
	mov [Dsptr+ya+ktag],D0
	mov D1,[Dframe+D3+kvalue]
	mov [Dsptr+ya+kvalue],D1
	and A0,hasrefmask
	jz L100
	inc word32 [D1+jrefcount]
L100:

	add Dprog,intpsize4		!push_af then push_f
	jmp ka_addto

	*saveregs
	*callm k_addto
	*loadregs
	*bjumpnext
endassem endproc

threadedproc jx_addto_fci =	! JX_ADDTO_FCI
assem
	mov D2,[Dprog+kopnda]
	cmp word16 [D2+Dframe+ktag],tint
	jnz L1

	mov D0,[Dprog+kopndb]
	add [D2+Dframe+kvalue],D0
	*jumpskip5
L1:
L99:
	*pushvar2

	mov word32 [Dsptr+xb+ktag],trefvar
	lea D0,[D2+Dframe]
	mov [Dsptr+xb+kvarptr],D0

	mov word32 [Dsptr+ya+ktag],tint
	mov D0,[Dprog+kopndb]
	mov [Dsptr+ya+kvalue],D0

	add Dprog,intpsize4
	jmp ka_addto

	*saveregs
	*callm k_addto
	*loadregs
	*bjumpnext
endassem endproc

proc calltest=
assem
	*pushvar
	mov word32 [Dsptr+ktag],tretaddr
	lea D0,[Dprog+24]		! return address
	mov [Dsptr+kretaddr],D0
	mov [Dsptr+kframeptr_low],Aframe
	mov [Dsptr+kstackadj],B4
	mov Dframe,Dsptr
	mov [frameptr],Dframe
	mov Dprog,D5
	ret
end
end

=== ccasm_fn. 26/56 ===
mut [0:]ref void asmhandlertable = (nil,
 cast(&ka_nop),
 cast(&ka_procstart),
 cast(&ka_procend),
 cast(&ka_endmodule),
 cast(&ka_push_m),
 cast(&ka_push_f),
 cast(&ka_push_am),
 cast(&ka_push_af),
 cast(&ka_push_ap),
 cast(&ka_push_al),
 cast(&ka_push_ci),
 cast(&ka_push_cw),
 cast(&ka_push_cr),
 cast(&ka_push_cn),
 cast(&ka_push_cs),
 cast(&ka_push_t),
 cast(&ka_push_op),
 cast(&ka_pushz),
 cast(&ka_pushz_void),
 cast(&ka_pushz_str),
 cast(&ka_pushz_list),
 cast(&ka_pushz_listl),
 cast(&ka_pushz_set),
 cast(&ka_pushz_arrayl),
 cast(&ka_pop_m),
 cast(&ka_pop_f),
 cast(&ka_store_m),
 cast(&ka_store_f),
 cast(&ka_pushptr),
 cast(&ka_popptr),
 cast(&ka_storeptr),
 cast(&ka_zpop_m),
 cast(&ka_zpop_f),
 cast(&ka_zstore_m),
 cast(&ka_zstore_f),
 cast(&ka_copy),
 cast(&ka_swap),
 cast(&ka_convptr),
 cast(&ka_jump),
 cast(&ka_jumpptr),
 cast(&ka_jumptrue),
 cast(&ka_jumpfalse),
 cast(&ka_jumpdef),
 cast(&ka_jumpvoid),
 cast(&ka_jumpeq),
 cast(&ka_jumpne),
 cast(&ka_jumplt),
 cast(&ka_jumple),
 cast(&ka_jumpge),
 cast(&ka_jumpgt),
 cast(&ka_jumptesteq),
 cast(&ka_jumptestne),
 cast(&ka_jumplabel),
 cast(&ka_jumpclabel),
 cast(&ka_switch),
 cast(&ka_cswitch),
 cast(&ka_new),
 cast(&ka_to_f),
 cast(&ka_for_fci),
 cast(&ka_for_ff),
 cast(&ka_ford_fci),
 cast(&ka_ford_ff),
 cast(&ka_call),
 cast(&ka_callptr),
 cast(&ka_return),
 cast(&ka_startdll),
 cast(&ka_pushdll),
 cast(&ka_calldll),
 cast(&ka_callhost),
 cast(&ka_stackframe),
 cast(&ka_free),
 cast(&ka_addsp),
 cast(&ka_stop),
 cast(&ka_test),
 cast(&ka_makelist),
 cast(&ka_makerecord),
 cast(&ka_makearray),
 cast(&ka_makestruct),
 cast(&ka_makeset),
 cast(&ka_makerange),
 cast(&ka_makedict),
 cast(&ka_pushdot),
 cast(&ka_pushdotref),
 cast(&ka_softconv),
 cast(&ka_hardconv),
 cast(&ka_mixed),
 cast(&ka_incrptr),
 cast(&ka_incrto_m),
 cast(&ka_incrto_f),
 cast(&ka_loadincr),
 cast(&ka_incrload),
 cast(&ka_decrptr),
 cast(&ka_decrto_m),
 cast(&ka_decrto_f),
 cast(&ka_loaddecr),
 cast(&ka_decrload),
 cast(&ka_incr),
 cast(&ka_decr),
 cast(&ka_neg),
 cast(&ka_abs),
 cast(&ka_not),
 cast(&ka_inot),
 cast(&ka_istrue),
 cast(&ka_asc),
 cast(&ka_chr),
 cast(&ka_sqrt),
 cast(&ka_sqr),
 cast(&ka_cube),
 cast(&ka_sin),
 cast(&ka_cos),
 cast(&ka_tan),
 cast(&ka_asin),
 cast(&ka_acos),
 cast(&ka_atan),
 cast(&ka_sign),
 cast(&ka_ln),
 cast(&ka_log),
 cast(&ka_lg),
 cast(&ka_exp),
 cast(&ka_round),
 cast(&ka_floor),
 cast(&ka_ceil),
 cast(&ka_fract),
 cast(&ka_negto),
 cast(&ka_absto),
 cast(&ka_notto),
 cast(&ka_inotto),
 cast(&ka_len),
 cast(&ka_lwb),
 cast(&ka_upb),
 cast(&ka_bounds),
 cast(&ka_bits),
 cast(&ka_bytes),
 cast(&ka_type),
 cast(&ka_elemtype),
 cast(&ka_basetype),
 cast(&ka_minval),
 cast(&ka_maxval),
 cast(&ka_isint),
 cast(&ka_isreal),
 cast(&ka_isstring),
 cast(&ka_isrange),
 cast(&ka_isnumber),
 cast(&ka_isarray),
 cast(&ka_isrecord),
 cast(&ka_ispointer),
 cast(&ka_ismutable),
 cast(&ka_isset),
 cast(&ka_isvoid),
 cast(&ka_isdef),
 cast(&ka_tostr),
 cast(&ka_isequal),
 cast(&ka_add),
 cast(&ka_sub),
 cast(&ka_mul),
 cast(&ka_div),
 cast(&ka_idiv),
 cast(&ka_rem),
 cast(&ka_divrem),
 cast(&ka_iand),
 cast(&ka_ior),
 cast(&ka_ixor),
 cast(&ka_shl),
 cast(&ka_shr),
 cast(&ka_in),
 cast(&ka_notin),
 cast(&ka_inrev),
 cast(&ka_eq),
 cast(&ka_ne),
 cast(&ka_lt),
 cast(&ka_le),
 cast(&ka_ge),
 cast(&ka_gt),
 cast(&ka_min),
 cast(&ka_max),
 cast(&ka_concat),
 cast(&ka_append),
 cast(&ka_power),
 cast(&ka_atan2),
 cast(&ka_addto),
 cast(&ka_subto),
 cast(&ka_multo),
 cast(&ka_divto),
 cast(&ka_idivto),
 cast(&ka_iandto),
 cast(&ka_iorto),
 cast(&ka_ixorto),
 cast(&ka_shlto),
 cast(&ka_shrto),
 cast(&ka_minto),
 cast(&ka_maxto),
 cast(&ka_concatto),
 cast(&ka_appendto),
 cast(&ka_pushix),
 cast(&ka_pushdotix),
 cast(&ka_pushkeyix),
 cast(&ka_pushkeyixd),
 cast(&ka_pushixref),
 cast(&ka_pushdotixref),
 cast(&ka_pushkeyixref),
 cast(&ka_pushbyteix),
 cast(&ka_pushbyteixref),
 cast(&ka_appendset),
 cast(&ka_pushdotm),
 cast(&ka_pushdott),
 cast(&ka_push_ad),
 cast(&ka_push_try),
 cast(&ka_raise),
 cast(&ka_applyop),
 cast(&ka_makeiter),
 cast(&ka_forall),
 cast(&ka_forallx),
 cast(&ka_foreach),
 cast(&ka_foreachx),
 cast(&ka_expandrange),
 cast(&ka_callappl),
 nil)
=== var_decls.m 27/56 ===
import clib
import mlib
import var_types
import qc_tables

global const tu1=tbit
global const tu2=tbit2
global const tu4=tbit4

global type intpc = int64
global type unit = ref unitrec

global const maxmodule=50

global tabledata() [0:]ichar usercatnames =
	(std_cat=0,	$),
	(anon_cat,	$),
	(user_cat,	$)
end

global record attribrec = !keep this 16 bytes
	byte ax_global				!1=global module-level name; 0=local or not module-level
	byte ax_static				!0 or 1
	byte ax_equals					!0 or 1 if @ used (static/frame vars only)
	byte ax_at					!0 or 1 if @ used (fields only)
	byte ax_byrefmode				!0 or 1 if & used
	byte ax_optional				!0 or 1	
	byte ax_varparams				!0 or 1	
	byte ax_used				!0 or 1	
	byte ax_forward				!0 or 1: 1 means forward decl of label or function
	byte ax_frame				!0 or 1: 1 when frameid/paramid
	byte ax_autovar				!0 or 1: 1 when an autovar with "$" in the name
	byte ax_nparams				!no. formal params for procid/dllprocid

	byte ax_fflang				!0 windowsff. etc.
	byte ax_moduleno
	byte ax_baseclass			!type of owner class (limited up to type 255 only)
	union
		byte ax_align				!0, 2, 4, 8, 16 or 255 (auto-align)
		byte ax_dllindex		!for dllproc: which dll in dlltable
		byte ax_extmodno		!for proc call chains: module no of proc owner
	end
end

global record uflagsrec =
	[7]byte	codes
	byte	ulength
end

global record fieldrec =
	ichar name
	int16 recordtype
	int16 fieldtype
	int fieldoffset
end

global record strec =
	ichar name
	ref strec owner
	ref strec deflist
	ref strec nextdef
	ref strec nextdupl
	ref strec prevdupl

	ref strec firstdupl

	union
		ref strec nextparam
		ref unitrec callchain
	end
	ref unitrec code
	union
		ref strec paramlist
		uflagsrec uflags
	end
	union
		ref strec equiv		!for aliasid/linkid only; or .attribs.ax-at=1
		ichar docstring		!for procid only
	end
	union
		ichar truename
		ichar metadata
		ichar macrovalue
	end

	byte namelen
	byte symbol
	byte nameid
	byte SPAREBYTE

	int16 subcode

	int16 mode
	int32 index					!needs to hold pcindex (also indices for all symbols or .bc files)


	union
		ref void address
		int32 offset
		ref intpc pcaddress
		int32 base_class
		int32 bcindex
	end
	int32 lineno
	attribrec attribs
end

global record unitrec =
	int32 tag			!kcode tag number
	int32 lineno			!source lineno associated with item; fileno is in top byte

	ref unitrec a	!single items, or linked lists
	ref unitrec b
	ref unitrec c
	ref unitrec nextunit

	union
		ref strec def
		int64 value
		word64 uvalue
		real xvalue
		ichar svalue
		ref strec labeldef
		struct
			int32 range_lower
			int32 range_upper
		end
	end
	union
		int32 opcode
		int32 index
		int32 trylevel
		int32 slength
		int32 length
		byte dottedname		!for j_name: 1=resolved from fully qualified dotted seq
	end

	int16 mode
	int16 moduleno
end

global record genfieldnamerec =
	union
		ref strec def				!when compiling
		ichar name					!after bc load
	end
	int32 dataindex
	union
		int32 datalength
		int32 datalast
	end
end

global record genfielddatarec =
	int32 fieldindex
	int32 recordtype
	int32 fieldtype			!-procid, -constid, -staticid, -typeid are special codes
	union
		int32 offset			!or const value
		word32 index			!into proctable, statictable, or type code
		word32 procoffset
	end
end

global record modulerec =
	ichar name
	ichar filename
	ichar sourcecode
	ichar qafilestr
	ref strec stmodule
	ref[]intpc pccode
	ref[0:]word16 linetable
	int32 sourcelen
	int32 npccode				!current allocated size of pccode
	int32 pcindex				!index of last entry in pccode
	int32 level
	int32 exported			!imported within export/endexport
	[maxmodule]byte importmap

end

global record dllprocrec =
	ichar name
	int32 dllindex				!dll module index
end

global record procrec =
	ref strec def
	ref procrec nextproc
end

global record userxrec =
	ref strec owner
	ref int16 pmode
	ref userxrec nextmode
end

global const int maxtype=500
global const int maxuserxtype=5000

global int ntypes
global int nuserxtypes
global int userxtypebase			!first index (growing downwards) of userxtypes in current module
global ref userxrec userxmodelist	!list of all references to userx modes

global [0:maxtype]int32 ttmodule		!module number
global [0:maxtype]ref strec ttnamedef
global [0:maxtype]int32 ttbasetype	!basetype
global [0:maxtype]ichar ttname 	!name of type
global [0:maxtype]int32 ttbitwidth

global [0:maxtype]int32 ttsize 		!.size in bytes
global [0:maxtype]int32 ttlower 		!.lbound (default 1 or case unused)
global [0:maxtype]int32 ttlength 		!elements in array/record (actual fields) (/string

global [0:maxtype]unit ttlowerexpr		!these are processed later to lower/length
global [0:maxtype]unit ttlengthexpr
global [0:maxtype]ref strec ttowner		!for ttlowerexpr/rtlengthexpr

global [0:maxtype]int32 ttstartfield 		!start index in pcfieldtable^[]
global [0:maxtype]int32 ttstructfields	!entries in pcfieldtable^[]

global [0:maxtype]int16 tttarget 		!for array/ref types
global [0:maxtype]byte ttusercat

global [0:maxtype]byte typestarterset
global [0:maxtype]int ttlineno
global [0:maxtype]byte ttmoduleno

global [0:maxuserxtype]ref strec ttnamedefx
global [0:maxuserxtype]ref strec ttnamedefx2
global [0:maxuserxtype]int ttlinenox
global [0:maxuserxtype]int ttxmap
global [0:maxuserxtype]byte ttxmoduleno

global [0:256]int16 baseclasstable
global [0:256]ref strec baseclassdef
global int nbaseclasses

global const hasrefmask = 0x10000		!1st bit of 3rd byte, when writing to .tagx


global tabledata() [0:]ichar objtypenames =
	(normal_obj=0,	$),
	(slice_obj,		$),
	(extslice_obj,	$)
end

global [0:symbolnames.len]byte exprstarterset

global const int varsize=16

global [0..maxmodule]modulerec moduletable
global int nmodules
global int currmoduleno				!used when compiling modules
global ref modulerec currmodule
global [maxmodule]int moduleinitorder
global int ninitmodules

global [0..maxmodule]ichar inputfiles
global int ninputfiles

global const maxsearchdirs=6
global [maxsearchdirs]ichar searchdirs
global int nsearchdirs=0

global ref strec stprogram		!root into the symbol table
global ref strec stmodule		!main module
global ref strec stsysmodule	!optional sys module (needed for name resolving)
global ref strec alldeflist		!link together all (user) symbols

global int optflag=0		!1=stdoptimise; 0=disabled

global const maxgenfields=1000
global [maxgenfields]genfieldnamerec genfieldnames
global [maxgenfields]genfielddatarec genfielddata
global int ngenfieldnames
global int ngenfielddata

global const sourceext="b"
global const arraylbound=1
global ref unitrec nullunit

global const maxlibpaths=10
global [maxlibpaths]ichar libpaths
global int nlibpaths

global int fverbose=0		!whether to display message for each pass
global int ftrace=0			!whether to line trace
global int fdtrace=0		!whether to line trace, enabled by $setdebug(1)
global int foptimise=0		!whether to generate optimised j-codes

global int mlineno=0		!set in pclgen dispatcher

global int dointlibs=1		!whether to use internal libraries

global int exportsprepass=0		!1 for preparse scan only

global int debug=0

global int totalstrings=0


global const maxdlllib=50
global const maxdllproc=2000

global int ndlltable
global [maxdlllib]ref strec dllsttable
global int ndllproctable
global [maxdlllib]ichar dlltable
global [maxdllproc]dllprocrec dllproctable

global const maxapplproc=500
global int napplproctable
global [maxapplproc]ref strec applproctable


global const int maxcmdparam=32
global int ncmdparams
global [0..maxcmdparam]ichar cmdparamtable

global ref procrec proclist			!linked list of all procs
global int nproclist

global int nstrings=0
global int nsymbols=0

global const int maxpcstrings=150000
global ref[]ichar stringtable
global ref[]int stringlentable

global ref[]fieldrec pcfieldtable		!controlled with nstructfields


global ichar err_message
global ref intpc stopseq		!point to a 'stop 0' sequence
global ref intpc raiseseq		!point to a sequence of several 'raise' cmdcodes

global ref byte PPP
global int prescanmode			!1 when reading import info only

global int progstart,progend
global int loadstart,loadend
global int parsestart,parseend
global int namesstart,namesend
global int genstart,genend

strbuffer docstrx
global ref strbuffer docstring=&docstrx

global ref strec currproc

global int ALLLINES

global const maxqafiles=maxmodule+50
global [0..maxqafiles]ichar qafilenames
global [0..maxqafiles]int qafilesizes
global [0..maxqafiles]int qafileoffsets
global [0..maxqafiles]ichar qafiletext
global [0..maxqafiles]byte qafilefileno			!0 or index into sourcefile tables
global [0..maxqafiles]byte qafilemult			!1 means could be parsed multiple times
global int nqafiles
global ichar qafilesource

global int fbundled=0		!set to 1 when compiling .qa
global int fwriteqa
=== var_types.m 28/56 ===
global tabledata() [0:]ichar stdtypenames, [0:]int stdtypewidths =
	(tvoid=0,		$,		128),	! means variant is unassigned

	(tint,			$,		64),	! 64-bit signed int
	(tword,			$,		64),	! 64-bit unsigned int
	(treal,			$,		64),	! 64-bit float
	(trange,		$,		64),	! 32+32-bit int:int

	(tstring,		$,		0),		! 8-bit string, flex and mutable
	(twstring,		$,		0),		! 16/32-bit string, flex and mutable
	(tlongint,		$,		0),		! Arbitrary precision integer
	(trational,		$,		0),		! Rational number, made of two longints
	(tset,			$,		0),		! Pascal-like bit-set
	(tdict,			$,		0),		! Dictionary of V:V keys and values
	(tword128,		$,		0),		! 128-bit unsigned int

	(tenum,			$,		0),		! (Used in compiler, not at runtime)
	(ttype,			$,		64),	! Represents a type-code
	(toperator,		$,		64),	! Represents an operator (as a bytecode op)
	(tsymbol,		$,		64),	! Reference to a symbol: module, proc, class, etc
	(tretaddr,		$,		0),		! Return address descriptor, only on stack 
	(texception,	$,		0),		! Exception descriptor, only on stack
	(trefproc,		$,		64),	! Pointer to Q proc
	(trefdllproc,	$,		64),	! Pointer to foreign function
	(treflabel,		$,		64),	! Pointer to label
	(tstringz,		$,		64),	! C-style zero-terminated 8-bit string within struct field

	(trefvar,		$,		64),	! Pointer/slice to Variant
	(trefpacked,	$,		0),		! Pointer/slice to Packed (uses target tag)
	(trefbit,		$,		0),		! Pointer/slice to Bits
	(trecordlink,	$,		0),		! Link to record object

	(treflist,		$,		0),		! Pointer to list slice
	(trefarray,		$,		0),		! Pointer to array slice
	(trefbits,		$,		0),		! Pointer to bits slice

	(tlist,			$,		0),		! Sequence of variants
	(tarray,		$,		0),		! Sequence of packed
	(tbits,			$,		0),		! Sequence of bits

	(trecord,		$,		0),		! Record of shorts and longs
	(tstruct,		$,		0),		! Record of packed and flat arrays/structs

	(tuser,			$,		0),		! used for anonymous user types during exportspass
	(tvariant,		$,		128),	!marks transition to packed types

	(tc8,			$,		8),		! 8-bit character
	(ti8,			$,		8),		! 8-bit signed int
	(ti16,			$,		16),	! etc 
	(ti32,			$,		32),	! 
	(ti64,			$,		64),	! 
	(tbit,			"tbit",		1),		! 1-bit unsigned
	(tbit2,			"tbit2",		2),		! 2-bit
	(tbit4,			"tbit4",		4),		! 4-bit
	(tu8,			$,		8),		! 8-bit unsigned int etc
	(tu16,			$,		16),	! 
	(tu32,			$,		32),	! 
	(tu64,			$,		64),	! 
	(tr32,			$,		32),	! 32-bit float
	(tr64,			$,		64),	! 
	(tintm,			$,		32),	! 32 or 64-bit host signed int 
	(twordm,		$,		32),	! 32 or 64-bit host unsigned int 
	(trefm,			$,		64),	! 32 or 64-bit host pointer

	(tlast,			$,		0)		! 	!

end
=== qc_tables.m 29/56 ===
import var_types
import pq_common

global tabledata() [0:]ichar jtagnames=


	(j_none=0,		$), ! For tagname lookups when tag is zero
	(j_const,		$), ! value/etc=value, typeno=type code
	(j_null,		$), ! Place holder unit: means 'param no present' when used where a param is expected
	(j_name,		$), ! def=nameptr
	(j_block,		$), ! a=L			List of statements
	(j_codeblock,	$), ! a=L,labeldef=label, def, def=autovar		L=List of statements
	(j_blockdef,	$), ! a=L,labeldef=label, def=autovar		L=List of statements
	(j_doblock,		$), ! a=x
	(j_typeval,		$), ! typeno=T			T=t_void or t_none; value of void or none
	(j_longint,		$), ! svalue=str			Longint constructor



	(j_whenthen,	$), ! a=L b=u
	(j_elsif,		$), ! condcode, a=u.
	(j_fmtitem,		$), ! a=x b=fmtstr
	(j_nogap,		$), ! 


	(j_callproc,	$), ! a=x b=L
	(j_callmproc,	$), ! a=x b=L
	(j_return,		$), ! a=x or nil

	(j_assign,		$), ! a b
	(j_shallowcopy,	$), ! a b
	(j_deepcopy,	$), ! a b
	(j_to,			$), ! a=x b=u [def=nameptr]		c is optional temp name
	(j_if,			$), ! condcode a=then b=else
	(j_longif,		$), ! a=(elsif ...) b=else		L is series of kelsif pairs
	(j_forup,		$), ! a=x b=x c=x d=Body [e=Else]		Body is single item or list
	(j_fordown,		$), ! a=x b=x c=x d=Body [e=Else]
	(j_forstep,		$), ! a=x b=x c=x d=Body [e=Else] [f=Step]
	(j_forall,		$), ! a=L b=L     d=Body [e=Else]	a is list of vars, b is list of values
	(j_forallrev,	$), ! a=x b=x     d=Body [e=Else]
	(j_foreach,		$), ! a=L b=L     d=Body [e=Else]	a is list of vars, b is list of values
	(j_foreachrev,	$), ! a=x b=x     d=Body [e=Else]
	(j_cfor,		$), ! a=x b=x     d=Body [e=Else]
	(j_while,		$), ! a=x b=u
	(j_repeat,		$), ! a=u b=x
	(j_goto,		$), ! a=x
	(j_gotoblock,	$), ! a=x
	(j_labeldef,	$), ! def=nameptr
	(j_restart,		$), ! [a=x]
	(j_redo,		$), ! [a=x]
	(j_next,		$), ! [a=x]
	(j_exit,		$), ! [a=x]
	(j_break,		$), ! [a=x]
	(j_do,			$), ! [a=u
	(j_case,		$), ! a=x b=L [c=else]		L is series of whenthen pairs
	(j_docase,		$), ! a=x b=L [c=else]
	(j_switch,		$), ! a=x b=L [c=else]
	(j_doswitch,	$), ! a=x b=L [c=else]
	(j_swap,		$), ! a b
	(j_select,		$), ! Not implemented

	(j_print,		$), ! [a=dev] b=L
	(j_println,		$), ! [a=dev] b=L
	(j_fprint,		$), ! [a=dev] b=fmtstr c=L
	(j_fprintln,	$), ! [a=dev] b=fmtstr c=L
	(j_cprint,		$), ! [a=dev] b=fmtstr c=L
	(j_cprintln,	$), ! [a=dev] b=fmtstr c=L
	(j_sprint,		$), !         b=L 
	(j_sfprint,		$), !         b=L
	(j_scprint,		$), !         b=L
	(j_read,		$), ! [a=dev] b=L
	(j_readln,		$), ! [a=dev] b=L
	(j_sread,		$), ! [a=dev] b=L
	(j_sreadln,		$), ! [a=dev] b=L
	(j_stop,		$), ! [a=x]
	(j_try,			$), ! a=try block; b=except list
	(j_except,		$), ! a=except block; b=exception code list (constants)
	(j_yield,		$), ! "
	(j_raise,		$), ! "
	(j_callhostproc,$), ! "
	(j_callapplproc,$), ! "
	(j_callapplfn,	$), ! "
	(j_eval,		$), ! "

	(j_listcomp,	$), ! a=for typeno=T	Start listcomp evaluation
	(j_appendlc,	$), ! a	typeno=T		Add a to current listcomp

	(j_startiter,	$), ! a typeno=T		Add a to current listcomp
	(j_nextiter,	$), ! a	typeno=T		Add a to current listcomp



	(j_andl,		$), ! a b	This group are for conditional expressions (no result)
	(j_orl,			$), ! a b
	(j_xorl,		$), ! a b
	(j_notl,		$), ! a
	(j_istruel,		$), ! a


	(j_makelist,	$), ! a=L [lower=Lwb]
	(j_makeconstr,	$), ! a=L	Like makelist, but elements intended for a construction (avoid const reduction)
	(j_makesetlist,	$), ! a=L
	(j_makerange,	$), ! a b		Range
	(j_makedict,	$), ! a L	
	(j_exprlist,	$), ! a=u...	List of expressions, as (a;b;c), rather than (a,b,c)
	(j_multexpr,	$), !

	(j_keyword,		$), ! def=nameptr a
	(j_keyvalue,	$), ! a b
	(j_assignx,		$), ! a b
	(j_deepcopyx,	$), ! a b
	(j_callfn,		$), ! a b
	(j_callmfn,		$), ! a b
	(j_ifx,			$), ! a b c
	(j_selectx,		$), ! a L c
	(j_callhostfn,	$), ! a L c
	(j_applyop,		$), ! opcode b c
	(j_applyopx,	$), ! opcode b c


	(j_andand,		$), ! a b

	(j_eq,			$), ! a b		int
	(j_ne,			$), ! a b
	(j_lt,			$), ! a b
	(j_le,			$), ! a b
	(j_gt,			$), ! a b
	(j_ge,			$), ! a b

	(j_isequal,		$), ! a b		int

	(j_add,			$), ! a b
	(j_sub,			$), ! a b
	(j_mul,			$), ! a b
	(j_div,			$), ! a b
	(j_idiv,		$), ! a b
	(j_fdiv,		$), ! a b
	(j_ddiv,		$), ! a b
	(j_rem,			$), ! a b
	(j_divrem,		$), ! a b
	(j_iand,		$), ! a b
	(j_ior,			$), ! a b
	(j_ixor,		$), ! a b
	(j_shl,			$), ! a b		int?
	(j_shr,			$), ! a b
	(j_in,			$), ! a b		int
	(j_notin,		$), ! a b		int
	(j_inrev,		$), ! a b
	(j_min,			$), ! a b
	(j_max,			$), ! a b
	(j_addptr,		$), ! a b
	(j_subptr,		$), ! a b
	(j_concat,		$), ! a b
	(j_append,		$), ! a b
	(j_clamp,		$), ! a b

	(j_index,		$), ! a b		a[b]
	(j_indexref,	$), ! a b		a[b]
	(j_slice,		$), ! a b		a[b] (b is a range)
	(j_keyindex,	$), ! a b		a{b}

	(j_dotindex,	$), ! a b		a.[b]
	(j_dotleft,		$), ! a b		a.[b:]
	(j_dotright,	$), ! a b		a.[:b]
	(j_dotslice,	$), ! a b		a.[b] (b is a range)
	(j_dotkeyindex,	$), ! a b		a.{b}
	(j_anddotindex,	$), ! a b		a&.[b]
	(j_anddotslice,	$), ! a b		a&.[b] (b is a range)
	(j_byteindex,	$), ! a b		a.c[b] (c is a type)

	(j_dot,			$), ! a b opcode	a.b; opcode=0/1/2 used for signalling in rx pass
	(j_dotref,		$), ! a b opcode	a.b; opcode=0/1/2 used for signalling in rx pass
	(j_dotattr,		$), ! a b		a.&b
	(j_atan2,		$), ! a b	atan2(a,b)			real
	(j_power,		$), ! a b	a**b				int/real

	(j_ptr,			$), ! a		a^
	(j_ptrto,		$), ! a		^a
	(j_addrof,		$), ! a		&a
	(j_convert,		$), ! typeno=T a		T(a)			T
	(j_typepun,		$), ! typeno=T a		T@(a)			T
	(j_typeconst,	$), ! typeno=T			typeconst(T)
	(j_operator,	$), ! opcode=opc
	(j_packtypeconst,
					$), ! typeno=T		typeconst(T)
	(j_classconst,	$), ! typeno=T	dummy unit used in rx-processing
	(j_upper,		$), ! a		$					T


	(j_neg,			$), ! a		-a
	(j_abs,			$), ! a		abs a
	(j_inot,		$), ! a
	(j_chr,			$), ! a
	(j_asc,			$), ! a

	(j_sqrt,		$), ! a
	(j_sqr,			$), ! a
	(j_cube,		$), ! a
	(j_sign,		$), ! a
	(j_sin,			$), ! a
	(j_cos,			$), ! a
	(j_tan,			$), ! a
	(j_asin,		$), ! a
	(j_acos,		$), ! a
	(j_atan,		$), ! a
	(j_ln,			$), ! a
	(j_lg,			$), ! a
	(j_log,			$), ! a
	(j_exp,			$), ! a
	(j_round,		$), ! a
	(j_floor,		$), ! a
	(j_ceil,		$), ! a
	(j_fract,		$), ! a
	(j_fmod,		$), ! a

	(j_lwb,			$), ! a		a.lwb				int
	(j_upb,			$), ! a							int
	(j_len,			$), ! a							int
	(j_bounds,		$), ! a							Range
	(j_bitwidth,	$), ! a
	(j_bytesize,	$), ! a
	(j_dictitems,	$), ! a

	(j_gettype,		$), ! a
	(j_getbasetype,	$), ! a
	(j_getelemtype,	$), ! a
	(j_isvoid,		$), ! a
	(j_isnone,		$), ! a
	(j_isdef,		$), ! a
	(j_isint,		$), ! a
	(j_isreal,		$), ! a
	(j_isstring,	$), ! a
	(j_isrange,		$), ! a
	(j_islist,		$), ! a
	(j_isrecord,	$), ! a
	(j_isclass,		$), ! a
	(j_isarray,		$), ! a
	(j_isset,		$), ! a
	(j_istype,		$), ! a
	(j_ispointer,	$), ! a
	(j_ismutable,	$), ! a

	(j_minvalue,	$), ! a
	(j_maxvalue,	$), ! a
	(j_min1,		$), ! a
	(j_max1,		$), ! a


	(j_preincrx,	$), ! a	++a
	(j_predecrx,	$), ! a	--a
	(j_postincrx,	$), ! a	a++
	(j_postdecrx,	$), ! a	a--


	(j_addto,		$), ! a b	a+:=b
	(j_subto,		$), ! a b
	(j_multo,		$), ! a b
	(j_divto,		$), ! a b
	(j_idivto,		$), ! a b
	(j_fdivto,		$), ! a b
	(j_iandto,		$), ! a b
	(j_iorto,		$), ! a b
	(j_ixorto,		$), ! a b
	(j_shlto,		$), ! a b
	(j_shrto,		$), ! a b
	(j_minto,		$), ! a b
	(j_maxto,		$), ! a b
	(j_concatto,	$), ! a b
	(j_appendto,	$), ! a b

	(j_negto,		$), ! a		-:=a
	(j_absto,		$), ! a
	(j_inotto,		$), ! a

	(j_preincr,		$), ! a	++a
	(j_predecr,		$), ! a	--a
	(j_postincr,	$), ! a	a++
	(j_postdecr,	$), ! a	a--


	(j_cvlineno,	$), ! 
	(j_cvstrlineno,	$), ! 
	(j_cvmodulename,$), ! 
	(j_cvfilename,	$), ! 
	(j_cvfunction,	$), ! 
	(j_cvdate,		$), ! 
	(j_cvtime,		$), ! 
	(j_cvversion,	$), ! 
	(j_cvpclversion,$), ! 

	(j_new,			$),	!
	(j_mixed,		$),	!
	(j_tostr,		$),	!
	(j_free,		$),	!
	(j_dupl,		$),	!

	(j_dummy,		$)
end


global tabledata() [0:]ichar scopenames=
	(noscope=0,		$), ! 
	(localscope,	$), ! 
	(importscope,	$), ! 
	(exportscope,	$)
end

global tabledata() [0:]ichar fflangnames=

	(windowsff,	"WL"), ! 
	(clangff,	"CL"), ! 
	(qlangff,	"QL"), ! 
	(mlangff,	"ML"), ! 

	(dummyff,	$) ! 
end

global const linuxff=clangff

global tabledata() []ichar symbolnames=
	(errorsym,			$),		! Lex error
	(dotsym,			$),		! "."
	(lexdotsym,			$),		! ".", used at bol to prefix lexical 
	(anddotsym,			$),		! "&."
	(commasym,			$),		! ","
	(semisym,			$),		! ";"
	(colonsym,			$),		! ":"
	(dcolonsym,			$),		! "::"
	(assignsym,			$),		! :=
	(deepcopysym,		$),		! :== or ::= ?
	(sendtosym,			$),		! =>
	(lbracksym,			$),		! (
	(rbracksym,			$),		! )
	(lsqsym,			$),		! [
	(rsqsym,			$),		! ]
	(lcurlysym,			$),		! {
	(rcurlysym,			$),		! }
	(ptrsym,			$),		! ^
	(barsym,			$),		! |
	(dbarsym,			$),		! ||
	(atsym,				$),		! @
	(datsym,			$),		! @@
	(questionsym,		$),		! ?
	(addrsym,			$),		! &
	(daddrsym,			$),		! &&
	(poundsym,			$),		!  Hmm, should be Pound A+156
	(curlsym,			$),		! ~
	(gatesym,			$),		! 
	(rangesym,			$),		! ..
	(ellipsissym,		$),		! ...
	(opsym,				$),		! Any operator or property tag (use sets to distinguish)
	(eolsym,			$),		! End of line
	(eofsym,			$),		! Eof seen
	(rawnamesym,		$),		! unassigned name before lookup
	(docstringsym,		$),		! ! #comment used as documentation string
	(incrsym,			$),		! 1/2 = ++/--; later may add +2 for x++/x--
	(intconstsym,		$),		! 123 32 bits signed
	(longintconstsym,	$),		! 123 longint (always signed)
	(realconstsym,		$),		! 123.4 64 bits
	(charconstsym,		$),		! 'A' or 'ABCD'
	(wcharconstsym,		$),		! 'A'W or 'ABCD'W (but don't have a syntax yet)
	(stringconstsym,	$),		! "ABC"
	(wstringconstsym,	$),		! "ABC"W

	(unitnamesym,		$),		! 
	(namesym,			$),		! identifier symbol
	(ksourcedirsym,		$),		! 
	(lexmacronamesym,	$),		! 

	(stdtypesym,		$),		! INT, CHAR etc
	(packtypesym,		$),		! Byte etc
	(kifsym,			$),		! 
	(kthensym,			$),		! 
	(kelsifsym,			$),		! 
	(kelsesym,			$),		! 
	(kelsecasesym,		$),		! 
	(kelseswitchsym,	$),		! 
	(kelseselectsym,	$),		! 
	(kendsym,			$),		! 
	(kunlesssym,		$),		! 
	(kcasesym,			$),		! CASE
	(kdocasesym,		$),		! DOCASE
	(kwhensym,			$),		! 
	(kforsym,			$),		! 
	(kforallsym,		$),		! FORALL
	(ktosym,			$),		! TO/DOWNTO
	(kbysym,			$),		! 
	(kdosym,			$),		! 
	(kwhilesym,			$),		! 
	(krepeatsym,		$),		! 
	(kuntilsym,			$),		! 
	(kreturnsym,		$),		! 
	(kstopsym,			$),		! 
	(kloopsym,			$),		! EXIT/NEXT/LOOP/REDO/RESTART
	(kbreaksym,			$),		! BREAK
	(kgotosym,			$),		! GO/GOTO
	(kswitchsym,		$),		! SWITCH
	(kdoswitchsym,		$),		! DOSWITCH
	(kprintsym,			$),		! PRINT/PRINTLN/FPRINT/FPRINTLN
	(ksprintsym,		$),		! SPRINT/SFPRINT
	(kreadsym,			$),		! READ/READLN
	(ksreadsym,			$),		! SREAD
	(ksreadlnsym,		$),		! SREADLN
	(khostfnsym,		$),		! LEFT, CONVLC etc
	(kprocsym,			$),		! PROC
	(kfunctionsym,		$),		! FUNCTION
	(kmethodsym,		$),		! METHOD
	(krecordsym,		$),		! RECORD
	(kstructsym,		$),		! STRUCT
	(kunionsym,		$),		! UNION
	(kimportsym,		$),		! IMPORT
	(kimportmodulesym,	$),		! IMPORTDLL/IMPORTMODULE
	(kimportpathsym,	$),		! IMPORTPATH
	(kmodulesym,		$),		! 
	(kapplprocsym,		$),		! HOSTPROC
	(kapplsym,			$),		! HOST
	(ktypesym,			$),		! TYPE
	(ktypeattrsym,		$),		! COMPACT/DERIVED
	(krefsym,			$),		! REF
	(kmacrosym,			$),		! MACRO/DEFINE
	(kconstsym,			$),		! 
	(kvarsym,			$),		! 
	(klocalssym,		$),		! LOCALS
	(klabelsym,			$),		! 
	(kenumsym,			$),		! 
	(knewsym,			$),		! NEW/HEAP
	(kclasssym,			$),		! CLASS
	(kdoblocksym,		$),		! DOBLOCK
	(kblockdefsym,		$),		! BLOCKDEF
	(kdirectivesym,		$),		! TARGET/MODULE
	(kfflangsym,		$),		! JLANG CLANG WINDOWS HOST
	(kglobalsym,		$),		! global
	(kstaticsym,		$),		! STATIC

	(kbeginsym,			$),		! 
	(ktrysym,			$),		! 
	(kexceptsym,		$),		! 
	(kfinallysym,		$),		! 
	(kraisesym,			$),		! 
	(kyieldsym,			$),		! 
	(kextendsym,		$),		!
	(kblocksym,			$),		!
	(kcastsym,			$),		! CAST
	(ktypeconstsym,		$),		! TYPECONST
	(compilervarsym,	$),		! $lineno etc
	(dollarsym,			$),		! to be used for current array upperbound; also tabledata names
	(kevalsym,			$),		! EVAL
	(ktabledatasym,		$),		! tabledata
	(kmapsym,			$),		! MAP/MAPL/MAPR/MAPLR
	(kapplyopsym,		$),		! APPLYOP
	(kstacksym,			$),		! STACK/UNSTACK
	(kforwardsym,		$),		! FORWARD
	(kclampsym,			$),			! CLAMP
	(kswapsym,			$),		! SWAP
	(kcondcompsym,		$),		! $WHEN
	(kerrorsym,			$),		! PC_ERROR etc
	(sysconstsym,		$),		! nil, etc
	(kdummysym,			$)		!
end

global tabledata() []ichar sourcedirnames =
	(definedir,	$),
	(emitdir,	$),
	(ifdir,		$),
	(elsifdir,	$),
	(elsedir,	$),
	(endifdir,	$),
	(debuglinedir,	$),
	(includedir,	$),
	(endincludedir,	$),
	(exportdir,	$),
	(endexportdir,	$),
	(commentdir,	$),
	(endcommentdir,	$),
	(strincludedir,	$),

	(modulenamedir,	$),	!these codes are used for parser-level directives
	(targetlangdir,	$),
	(cincludedir,	$),
	(pyimportdir,	$),
	(enddir,	$)
end

global tabledata() =
	(nil_const),
	(pi_const),
	(tab_const),
	(con_const)
end

global tabledata() =
	(thousand_unit),
	(million_unit),
	(billion_unit),
	(kilo_unit),
	(mega_unit),
	(giga_unit)

end

global tabledata []ichar stnames, []int stsymbols, []int stsubcodes=

	("if",			kifsym,			j_if),
	("then",		kthensym,		0),
	("elsif",		kelsifsym,		j_if),
	("else",		kelsesym,		0),
	("elsecase",	kelsecasesym,	j_case),
	("elseswitch",	kelseswitchsym,	j_switch),
	("case",		kcasesym,		j_case),
	("docase",		kdocasesym,		j_docase),
	("when",		kwhensym,		0),
	("for",			kforsym,		0),
	("forall",		kforallsym,		j_forall),
	("foreach",		kforallsym,		j_foreach),
	("to",			ktosym,			0),
	("downto",		ktosym,			1),
	("by",			kbysym,			0),
	("do",			kdosym,			0),
	("end",			kendsym,		0),
	("while",		kwhilesym,		0),
	("repeat",		krepeatsym,		0),
	("until",		kuntilsym,		0),
	("always",		kuntilsym,		1),
	("return",		kreturnsym,		0),
	("yield",		kyieldsym,		0),
	("stop",		kstopsym,		0),
	("restart",		kloopsym,		j_restart),
	("redo",		kloopsym,		j_redo),
	("loop",		kloopsym,		j_next),
	("next",		kloopsym,		j_next),
	("exit",		kloopsym,		j_exit),
	("break",		kbreaksym,		j_break),
	("goto",		kgotosym,		0),
	("go",			kgotosym,		1),
	("switch",		kswitchsym,		j_switch),
	("doswitch",	kdoswitchsym,	j_doswitch),
	("tabledata",	ktabledatasym,	0),
	("applyop",		kapplyopsym,	0),
	("clamp",		kclampsym,		0),
	("eval",		kevalsym,		0),
	("$windows",	kcondcompsym,	windowsff),
	("$linux",		kcondcompsym,	linuxff),

	("print",		kprintsym,		j_print),
	("println",		kprintsym,		j_println),
	("fprint",		kprintsym,		j_fprint),
	("fprintln",	kprintsym,		j_fprintln),
	("cprint",		kprintsym,		j_cprint),
	("cprintln",	kprintsym,		j_cprintln),
	("sprint",		ksprintsym,		j_sprint),
	("sfprint",		ksprintsym,		j_sfprint),
	("scprint",		ksprintsym,		j_scprint),

	("cp",			kprintsym,		j_print),
	("cpl",			kprintsym,		j_println),

	("read",		kreadsym,		j_read),
	("readln",		kreadsym,		j_readln),
	("cast",		kcastsym,		j_convert),
	("typeconst",	ktypeconstsym,	j_typeconst),

	("proc",		kprocsym,		0),
	("function",	kfunctionsym,	0),
	("method",		kmethodsym,		0),

	("type",		ktypesym,		0),
	("class",		kclasssym,		0),
	("doblock",		kdoblocksym,	0),
	("blockdef",	kblockdefsym,	0),

	("record",		krecordsym,		trecord),
	("struct",		kstructsym,		tstruct),
	("union",		kunionsym,		0),
	("ref",			krefsym,		0),

	("module",		kdirectivesym,	modulenamedir),
	("cinclude",	kdirectivesym,	cincludedir),
	("pyimport",	kdirectivesym,	pyimportdir),

	("include",		ksourcedirsym,	includedir),
	("strinclude",	ksourcedirsym,	strincludedir),
	("define",		ksourcedirsym,	definedir),
	("macro",		ksourcedirsym,	definedir),
	("export",		ksourcedirsym,	exportdir),
	("endexport",	ksourcedirsym,	endexportdir),

	("static",		kstaticsym,		0),
	
	("const",		kconstsym,		0),
	("var",			kvarsym,		0),
	("variant",		kvarsym,		0),
	("enum",		kenumsym,		0),

	("importdll",	kimportmodulesym,	0),
	("import",		kimportsym,		0),
	("importpath",	kimportpathsym,	0),
	("hostproc",	kapplprocsym,	0),
	("applproc",	kapplprocsym,	0),
	("host",		kapplsym,		0),
	("appl",		kapplsym,		0),

	("begin",		kbeginsym,		0),
	("unless",		kunlesssym,		0),

	("try",			ktrysym,		0),
	("except",		kexceptsym,		0),
	("finally",		kfinallysym,	0),
	("raise",		kraisesym,		0),

	("global",		kglobalsym,		0),

	("qlang",		kfflangsym,		qlangff),
	("clang",		kfflangsym,		clangff),
	("mlang",		kfflangsym,		mlangff),
	("windows",		kfflangsym,		windowsff),

	("swap",		kswapsym,		0),

	("void",		stdtypesym,		tvoid),

	("int",			stdtypesym,		tint),
	("word",		stdtypesym,		tword),
	("real",		stdtypesym,		treal),

	("refvar",		stdtypesym,		trefvar),
	("pointer",		stdtypesym,		trefvar),
	("range",		stdtypesym,		trange),
	("longint",		stdtypesym,		tlongint),
	("bignum",		stdtypesym,		tlongint),
	("string",		stdtypesym,		tstring),
	("set",			stdtypesym,		tset),
	("list",		stdtypesym,		tlist),
	("dict",		stdtypesym,		tdict),

	("array",		stdtypesym,		tarray),
	("bits",		stdtypesym,		tbits),
	("recordtype",	stdtypesym,		trecord),
	("structtype",	stdtypesym,		tstruct),

	("int8",		stdtypesym,		ti8),
	("int16",		stdtypesym,		ti16),
	("int32",		stdtypesym,		ti32),
	("int64",		stdtypesym,		ti64),

	("i8",			stdtypesym,		ti8),
	("i16",			stdtypesym,		ti16),
	("i32",			stdtypesym,		ti32),
	("i64",			stdtypesym,		ti64),

	("real32",		stdtypesym,		tr32),
	("real64",		stdtypesym,		tr64),
	("r32",			stdtypesym,		tr32),
	("r64",			stdtypesym,		tr64),
	("sreal",		stdtypesym,		tr32),

	("bit",			stdtypesym,		tbit),
	("bit2",		stdtypesym,		tbit2),
	("bit4",		stdtypesym,		tbit4),
	("byte",		stdtypesym,		tu8),
	("u8",			stdtypesym,		tu8),
	("u16",			stdtypesym,		tu16),
	("u32",			stdtypesym,		tu32),
	("u64",			stdtypesym,		tu64),

	("word8",		stdtypesym,		tu8),
	("word16",		stdtypesym,		tu16),
	("word32",		stdtypesym,		tu32),
	("word64",		stdtypesym,		tu64),

	("stringz",		stdtypesym,		tstringz),

	("intm",		stdtypesym,		tintm),
	("wordm",		stdtypesym,		twordm),
	("refm",		stdtypesym,		trefm),

	("million",		unitnamesym,	million_unit),
	("billion",		unitnamesym,	billion_unit),
	("thousand",	unitnamesym,	thousand_unit),
	("kb",			unitnamesym,	kilo_unit),
	("mb",			unitnamesym,	mega_unit),
	("gb",			unitnamesym,	giga_unit),


	("$lineno",		compilervarsym,	j_cvlineno),
	("$strlineno",	compilervarsym,	j_cvstrlineno),
	("$filename",	compilervarsym,	j_cvfilename),
	("$modulename",	compilervarsym,	j_cvmodulename),
	("$function",	compilervarsym,	j_cvfunction),
	("$date",		compilervarsym,	j_cvdate),
	("$time",		compilervarsym,	j_cvtime),
	("$version",	compilervarsym,	j_cvversion),
	("$pclversion",	compilervarsym,	j_cvpclversion),
	("$",			dollarsym,		0),

	("and",			opsym,			j_andl),
	("or",			opsym,			j_orl),
	("xor",			opsym,			j_xorl),
	("iand",		opsym,			j_iand),
	("ior",			opsym,			j_ior),
	("ixor",		opsym,			j_ixor),
	("in",			opsym,			j_in),
	("notin",		opsym,			j_notin),
	("inrev",		opsym,			j_inrev),
	("rem",			opsym,			j_rem),
	("divrem",		opsym,			j_divrem),
	("min",			opsym,			j_min),
	("max",			opsym,			j_max),

	("not",			opsym,			j_notl),
	("inot",		opsym,			j_inot),
	("istrue",		opsym,			j_istruel),
	("abs",			opsym,			j_abs),
	("$neg",		opsym,			j_neg),
	("asc",			opsym,			j_asc),
	("chr",			opsym,			j_chr),
	("sqrt",		opsym,			j_sqrt),
	("sqr",			opsym,			j_sqr),
	("cube",		opsym,			j_cube),
	("cos",			opsym,			j_cos),
	("sin",			opsym,			j_sin),
	("tan",			opsym,			j_tan),
	("asin",		opsym,			j_asin),
	("acos",		opsym,			j_acos),
	("atan",		opsym,			j_atan),
	("atan2",		opsym,			j_atan2),
	("sign",		opsym,			j_sign),
	("ln",			opsym,			j_ln),
	("log",			opsym,			j_log),
	("lg",			opsym,			j_lg),
	("exp",			opsym,			j_exp),
	("round",		opsym,			j_round),
	("floor",		opsym,			j_floor),
	("ceil",		opsym,			j_ceil),
	("fract",		opsym,			j_fract),
	("fmod",		opsym,			j_fmod),

	("len",			opsym,			j_len),
	("lwb",			opsym,			j_lwb),
	("upb",			opsym,			j_upb),
	("bounds",		opsym,			j_bounds),
	("bitwidth",	opsym,			j_bitwidth),
	("bytes",		opsym,			j_bytesize),
	("basetype",	opsym,			j_getbasetype),
	("dictitems",	opsym,			j_dictitems),
	("elemtype",	opsym,			j_getelemtype),
	("defined",		opsym,			j_isdef),
	("isdef",		opsym,			j_isdef),
	("isvoid",		opsym,			j_isvoid),
	("isnone",		opsym,			j_isnone),
	("isint",		opsym,			j_isint),
	("isreal",		opsym,			j_isreal),
	("isarray",		opsym,			j_isarray),
	("isset",		opsym,			j_isset),
	("islist",		opsym,			j_isarray),
	("isrecord",	opsym,			j_isrecord),
	("isrange",		opsym,			j_isrange),
	("isstring",	opsym,			j_isstring),
	("ispointer",	opsym,			j_ispointer),
	("ismutable",	opsym,			j_ismutable),
	("minvalue",	opsym,			j_minvalue),
	("maxvalue",	opsym,			j_maxvalue),

	("concat",		opsym,			j_concat),
	("append",		opsym,			j_append),

	("$free",		opsym,			j_free),
	("$dupl",		opsym,			j_dupl),
	("$mixed",		opsym,			j_mixed),
	("$index",		opsym,			j_index),
	("$dotindex",	opsym,			j_dotindex),
	("$convert",	opsym,			j_convert),
	("$new",		opsym,			j_new),
	("$tostr",		opsym,			j_tostr),
	("$dot",		opsym,			j_dot),
	("$dotref",		opsym,			j_dotref),

	("endif",		kendsym,	kifsym),
	("fi",			kendsym,	kifsym),
	("endcase",		kendsym,	kcasesym),
	("esac",		kendsym,	kcasesym),
	("enddocase",	kendsym,	kdocasesym),
	("endswitch",	kendsym,	kswitchsym),
	("enddoswitch",	kendsym,	kdoswitchsym),
	("endfor",		kendsym,	kforsym),
	("endforall",	kendsym,	kforallsym),
	("od",			kendsym,	kdosym),
	("endproc",		kendsym,	kprocsym),
	("endfunction",	kendsym,	kfunctionsym),
	("endmethod",	kendsym,	kmethodsym),
	("endwhile",	kendsym,	kwhilesym),
	("endto",		kendsym,	ktosym),
	("enddo",		kendsym,	kdosym),
	("endunless",	kendsym,	kunlesssym),
	("endmodule",	kendsym,	kmodulesym),
	("endimportmodule",	kendsym,kimportmodulesym),
	("endtry",		kendsym,	ktrysym),
	("endrecord",	kendsym,	krecordsym),
	("endclass",	kendsym,	kclasssym),
	("endblock",	kendsym,	kblocksym),

	("nil",			sysconstsym,	nil_const),
	("con",			sysconstsym,	con_const),
	("tab",			sysconstsym,	tab_const),
	("pi",			sysconstsym,	pi_const),
	("sreadln",			khostfnsym,		host_sreadln),
	("sread",			khostfnsym,		host_sread),
	("rereadln",		khostfnsym,		host_rereadln),
	("reread",			khostfnsym,		host_reread),

	("strtoval",		khostfnsym,		host_strtoval),
	("tostr",			khostfnsym,		host_tostr),

	("leftstr",			khostfnsym,		host_leftstr),
	("rightstr",		khostfnsym,		host_rightstr),
	("convlc",			khostfnsym,		host_convlc),
	("convuc",			khostfnsym,		host_convuc),
	("iconvlc",			khostfnsym,		host_iconvlc),
	("iconvuc",			khostfnsym,		host_iconvuc),

	("ismain",			khostfnsym,		host_ismain),
	("waitkey",			khostfnsym,		host_waitkey),
	("testkey",			khostfnsym,		host_testkey),
	("execwait",		khostfnsym,		host_execwait),
	("execcmd",			khostfnsym,		host_execcmd),
	("shellexec",		khostfnsym,		host_shellexec),
	("system",			khostfnsym,		host_system),

	("makestr",			khostfnsym,		host_makestr),
	("makestrslice",	khostfnsym,		host_makestrslice),
	("makeref",			khostfnsym,		host_makeref),

	("new",				khostfnsym,		host_new),
	("newheap",			khostfnsym,		host_newheap),
	("readlines",		khostfnsym,		host_readlines),
	("heapvar",			khostfnsym,		host_heapvar),
	("freeheap",		khostfnsym,		host_freeheap),

	("getcmdparam",		khostfnsym,		host_getcmdparam),
	("gethostname",		khostfnsym,		host_gethostname),

	("$setpcerror",		khostfnsym,		host_setpcerror),
	("$setdebug",		khostfnsym,		host_setdebug),
	("$test",			khostfnsym,		host_test),

	("ticks",			khostfnsym,		host_ticks),
	("sleep",			khostfnsym,		host_sleep),
	("random",			khostfnsym,		host_random),
	("findmetafunction",khostfnsym,		host_findmetafunction),
	("gethash",			khostfnsym,		host_gethash),
	("getos",			khostfnsym,		host_getos),
	("gethostsize",		khostfnsym,		host_gethostsize),
	("iswindows",		khostfnsym,		host_iswindows),
	("setmesshandler",	khostfnsym,		host_setmesshandler),
	("$setfprintf",		khostfnsym,		host_setfprintf),
	("clearlist",		khostfnsym,		host_clearlist),

	("loadpcl",			khostfnsym,		host_loadpcl),
	("runpcl",			khostfnsym,		host_runpcl),
	("runtask",			khostfnsym,		host_runtask),
	("callext",			khostfnsym,		host_callext),
	("$pcldata",		khostfnsym,		host_pcldata),
	("getcstring",		khostfnsym,		host_getcstring),
	("$getparam",		khostfnsym,		host_getparam),
	("makelink",		khostfnsym,		host_makelink),
	("allparams",		khostfnsym,		host_allparams),
	("stackvars",		khostfnsym,		host_stackvars),
	("makeempty",		khostfnsym,		host_makeempty),
	("$errorinfo",		khostfnsym,		host_errorinfo),
	("$setoverload",	khostfnsym,		host_setoverload),

	("pc_error",		kerrorsym,		pc_error),
	("user_error",		kerrorsym,		user_error),
	("mixedtype_error",	kerrorsym,		mixedtype_error),
	("divide_error",	kerrorsym,		divide_error),
	("stopmodule_error",kerrorsym,		stopmodule_error),
	("bounds_error",	kerrorsym,		bounds_error)

end

global tabledata []int oplist,[]int oppriolist =
	(j_add,			4),
	(j_sub,			4),
	(j_mul,			3),
	(j_div,			3),
	(j_idiv,		3),
	(j_rem,			3),
	(j_divrem,		3),
	!(j_ddiv,		3),
	(j_andl,		7),
	(j_orl,			8),
	(j_xorl,		6),
	(j_iand,		4),
	(j_ior,			4),
	(j_ixor,		4),
	(j_shl,			3),
	(j_shr,			3),
	!(j_rol,		3),
	!(j_ror,		3),
	(j_in,			6),
	(j_notin,		6),
	(j_inrev,		6),
	(j_eq,			6),
	(j_ne,			6),
	(j_lt,			6),
	(j_ge,			6),
	(j_le,			6),
	(j_gt,			6),
	(j_isequal,		6),
	!(j_testeq,		6),
	(j_min,			4),
	(j_max,			4),
	(j_power,		2),
	(j_atan2,		3),
	(j_addptr,		4),
	(j_subptr,		4),
	(j_concat,		4),
	(j_append,		4),
	(j_assignx,		1),
	(j_deepcopyx,	1),
	(j_makerange,	5)
end

global [0:jtagnames.len]byte jtagpriotable		!set up from the above
global []int D_exprstarterset= (lbracksym,lsqsym,ptrsym,addrsym,opsym,namesym,
	incrsym,intconstsym,longintconstsym,realconstsym,charconstsym,stringconstsym,stdtypesym,
	ksprintsym,ksreadsym,ksreadlnsym,knewsym,dollarsym,compilervarsym, kclampsym,
	khostfnsym,kapplyopsym,kerrorsym,kapplsym)

global []int D_typestarterset= (stdtypesym,lsqsym,kvarsym,krefsym,kenumsym,krecordsym)

global [0..host_last]byte hostlvset

global [0..jtagnames.upb]byte condopset			!contains 1 for j_eq/ne/lt/le/gt/ge

=== qci.m 30/56 ===
import msys
import mlib
import clib
import oslib


import var_types
import var_decls
import qc_support
import qc_lex
import qc_tables
import qc_parse
import qc_lib
import qc_pclgen
import qc_pcllib
import pq_common

import q_libs

import qc_name

int totalpclopcodes=0

int totallines=0
int nstringobjects=0


global function qcompiler_prod(ichar locinfile,locoutfile,int intlibs, fdocs=0)int=
ichar ext, infile, outfile


initdata()

inputfiles[1]:=infile:=locinfile
ninputfiles:=1
outfile:=locoutfile


ext:=extractext(infile)

convlcstring(ext)

if not eqstring(ext,"q") then
	loaderror("Unknown file extension:",infile)
fi

dointlibs:=intlibs

println "Compiling",infile,"to",outfile


do_loadmodules(infile)
do_parse()
do_writeqa(outfile)
do_name()
do_pclgen()
do_writepcfile()



if fdocs then
	writedocs()
fi
return 1
end

global proc do_loadmodules(ichar infile)=

if fverbose then
	CPL "Loading:",infile
fi

loadmainmodule(infile)
end

function loadmainmodule(ichar filespec)int=
	[100]char modulename
	[300]char path
	ref char source
	int status
	modulerec m
	int i,flag

	pcm_clearmem(&moduletable[0],modulerec.bytes)
	moduletable[0].name:="PROGRAM"
	moduletable[0].filename:="<->"
	moduletable[0].sourcecode:="<program>"
	moduletable[0].sourcelen:=strlen(moduletable[0].sourcecode)

	stprogram:=getduplnameptr(nil,addnamestr("$prog"),programid)
	moduletable[0].stmodule:=stprogram

	source:=cast(readfile(filespec))
	if source=nil then
		loaderror("Can't load main file:",filespec)
		return 0
	fi

	strcpy(&.modulename,extractbasefile(filespec))
	strcpy(&.path,extractpath(filespec))
	if path[1] then
		++nsearchdirs
		for i:=nsearchdirs downto 2 do
			searchdirs[i]:=searchdirs[i-1]
		od
		searchdirs[1]:=ref char(pcm_copyheapstring(&.path))
	fi

	addmodule(&.modulename,filespec,source,rfsize,moduleid,flag)

return 1
end

function addmodule(ichar modulename,filespec, source, int length,id,&exportflag)int=

modulerec m
const maximports=maxmodule
[maximports]ichar importnames
[0..maximports]byte importflags
[maximports]int importmoduleno
int nimports,i,status,k,flag,j,newmodno
ref modulerec pmodule

pcm_clearmem(&m,m.bytes)

m.name:=pcm_copyheapstring(modulename)

m.filename:=pcm_copyheapstring(filespec)
m.sourcecode:=source
m.sourcelen:=length
if fwriteqa then
	addqafile(m.filename,m.sourcecode, m.sourcelen)
fi

stmodule:=getduplnameptr(stprogram,addnamestr(m.name),id)
adddef(stprogram,stmodule)
m.stmodule:=stmodule

if nmodules>=maxmodule then
	loaderror("Too many modules",modulename)
fi

pmodule:=&moduletable[newmodno:=++nmodules]

pmodule^:=m
pmodule^.importmap[newmodno]:=1
m.stmodule^.attribs.ax_moduleno:=newmodno

memset(&importflags,0,importflags.bytes)

nimports:=readimportlist(&m,&importnames,&importflags,maximports)

for i to nimports do

	flag:=0
	if fverbose=2 then
		cpl "Load import for",modulename
	fi
	k:=loadimport(importnames[i],flag,modulename)
	if flag then
		importflags[i]:=1
	fi
	pmodule^.importmap[k]:=1
	importmoduleno[i]:=k
od

for i:=1 to nimports when importflags[i] do
	k:=importmoduleno[i]
	for j:=1 to nmodules do
		if moduletable[k].importmap[j] then		!add that to this module
			pmodule^.importmap[j]:=1
		fi
	od
od

exportflag:=importflags[0]

moduleinitorder[++ninitmodules]:=newmodno

return newmodno
end

function loadimport(ichar modulename,int &exportflag, ichar ownername)int=

int i
ichar ifilespec
[300]char filespec
ref char source
ichar newname

newname:=modulename

for i:=1 to nmodules do
	if eqstring(moduletable[i].name,newname) then		!already loaded
		return i
	fi
od

source:=getmodulestr(modulename,&.filespec)

return addmodule(newname,&.filespec,source,rfsize,moduleid, exportflag)
end

function readimportlist(ref modulerec m, ref[]ichar importnames,
							ref[0:]byte importflags, int maximports)int=
int n,flag,exportflag
ichar s
[100]char name,libname

startlex("IMPORTS",m^.sourcecode)

exportflag:=0

n:=0
do
	lexreadtoken()
	case nextlx.symbol
	when eofsym then
		exit
	when semisym,eolsym then

	when rawnamesym then
		flag:=0
		if checkname("import") then
			lexreadtoken()
			if nextlx.symbol=opsym and nextlx.subcode=j_mul then
				flag:=1
				lexreadtoken()
			fi

			if nextlx.symbol<>rawnamesym then
				abortprogram("import: modulename expected")
			fi
			if ++n>maximports then
				abortprogram("too many imports")
			fi

			strcpy(&.name,convertzstring(nextlx.svalue,nextlx.length))
			importnames^[n]:=pcm_copyheapstring(&.name)
			importflags^[n]:=flag

		elsif checkname("importpath") then
			prescanmode:=1
			lexreadtoken()
			prescanmode:=0
			if nextlx.symbol=stringconstsym then
				strcpy(&.name,convertzstring(nextlx.svalue,nextlx.length))
				addsearchdir(&.name)
				lexreadtoken()
			else
				abortprogram("string path expected")
			fi
		elsif checkname("export") or checkname("endexport") then
			exportflag:=1
			next
		elsif checkname("$windows") then
			if os_iswindows() then		!proceed with rest of line
				next
			else
skipthisline::
				repeat
					lexreadtoken()
				until nextlx.symbol=eolsym or nextlx.symbol=eofsym
			fi
		elsif checkname("$linux") then
			if not os_iswindows() then		!proceed with rest of line
				next
			else
				goto skipthisline
			fi

		else
			exit
		fi
	else
		exit
	esac
od
importflags^[0]:=exportflag

return n
end

global proc initdata=
	pcm_init()
	lexsetup()
	inittypetables()
	initsearchdirs()
	initqclib()
	initpclgen()
	initpcldata()
end

global proc initsearchdirs=
[300]char str1,str2
int i

searchdirs[++nsearchdirs]:=""
strcpy(&.str1,os_gethostname())
if str1[1] then
	strcpy(&.str2,extractpath(&.str1))

	searchdirs[++nsearchdirs]:=ref char(pcm_copyheapstring(&.str2))
fi

strcpy(&.str1,os_getmpath())
if str1[1] then
	searchdirs[++nsearchdirs]:=ref char(pcm_copyheapstring(&.str1))
fi
searchdirs[++nsearchdirs]:=pcm_copyheapstring("c:/qx/")

end

proc addsearchdir(ichar path)=
	for i to nsearchdirs do
		if eqstring(searchdirs[i],path) then return fi
	od
CPL "ADD SEARCH",PATH
	searchdirs[++nsearchdirs]:=pcm_copyheapstring(path)
end

function getmodulestr(ichar modulename, filespec)ichar=
ichar ifile
ref byte source

if dointlibs then		!internal libs are used first
	source:=cast(getintlib(modulename))
	if source then
		strcpy(filespec,"<Internal>")
		return cast(source)
	fi
fi

ifile:=findmodule(modulename)
if ifile=nil then
	if not dointlibs then
		source:=cast(getintlib(modulename))
		if source then
			if fverbose=2 then
			fi
			strcpy(filespec,"<Internal>")
			return cast(source)
		fi
	fi
	loaderror("Can't locate import module:",modulename)
fi

strcpy(filespec,ifile)

source:=readfile(filespec)

if source=nil then				!unlikely as already checked above
	loaderror("?Read file error:",filespec)
fi
return cast(source)
end

function findmodule(ichar modulename)ichar=
[300]char file
static [300]char filespec
ichar s
int i

strcpy(&.file,modulename)
strcpy(&.file,addext(&.file,".q"))

if fverbose=2 then
	println "Locating:",&.file
fi
for i to nsearchdirs do
	strcpy(&.filespec,searchdirs[i])
	strcat(&.filespec,&.file)
	if fverbose=2 then
		println "	",,i,,": Checking File",&.filespec,"in <",,searchdirs[i],,">"
	fi
	if checkfile(&.filespec) then
		if fverbose=2 then
			println "	Found:",&.filespec
		fi
		return &.filespec
	fi
od

return nil
end

function checkname(ichar name,int length=0)int=

if length=0 then
	length:=strlen(name)
fi
if nextlx.length=length and memcmp(nextlx.svalue,name,length)=0 then
	return 1
fi
return 0
end

global proc do_parse=
int m

for i:=1 to nmodules do
	m:=i

	currmoduleno:=m
	currmodule:=&moduletable[m]
	parsemodule(m)
od

fixusertypes()
end

global proc do_name=
	tx_typetable()

	for i:=2 to nmodules do
		rx_module(i)
	od
	rx_module(1)
end

global proc do_pclgen =
int status
for i to nmodules do
	codegen(i)
od
end

global proc loaderror(ichar mess,mess2="")=
println "Load Error:",mess,mess2
println "Stopping"
stop
end

proc getsyscmdline=			!GETSYSCMDLINE
int i

for i:=1 to nsysparams do
	if i<=maxcmdparam then
		cmdparamtable[i-1]:=pcm_copyheapstring(sysparams[i])
	fi
od
ncmdparams:=nsysparams-1
end

proc checkkeyword(ichar kwd)=
int length

lexreadtoken()

length:=strlen(kwd)

unless nextlx.symbol=rawnamesym and nextlx.length=length and memcmp(nextlx.svalue,kwd,length)=0 then
	loaderror("BA: expected:",kwd)
endunless

end

function readinttoken:int=
lexreadtoken()
if nextlx.symbol<>intconstsym then
	loaderror("Int expected")
fi
return nextlx.value
end

global proc do_writepcfile=
filehandle f
int i,length, symbolpos,currpos
modulerec m
[300]char filename
ichar file, s,t

strcpy(&.filename,moduletable[1].filename)
strcpy(&.filename,changeext(&.filename,".pc"))

initpcdest()

doprogramstartup()

writezint('P')
writezint('C')
writezint(26)
writezint(0)

writezint(kkpclversion)
writezstring(pclversion)

writezint(kkmoduletable)
writezint(nmodules)

for i:=1 to nmodules do
	writezstring(moduletable[i].name)
od

writezint(kkdlltable)
writezint(ndlltable)
for i:=1 to ndlltable do
	writezstring(dlltable[i])
od

writezint(kkdllproctable)
writezint(ndllproctable)
for i:=1 to ndllproctable do
	writezstring(dllproctable[i].name)
	writezint(dllproctable[i].dllindex)
od

writezint(kkapplproctable)
writezint(napplproctable)
for i:=1 to napplproctable do
	writezstring(applproctable[i].name)
od

writezint(kksymboltable)
symbolpos:=getpcpos()
writezint4(0)

for i:=1 to nmodules do
	showpcsymbol(moduletable[i].stmodule)
od

for i:=tlast to ntypes do
	showpcsymbol(ttnamedef[i])
od

for i:=0 to nmodules do
	writesymbols(i)
od

currpos:=getpcpos()
setpcpos(symbolpos)
writezint4(nsymbols)
setpcpos(currpos)

writezint(kktypetable)
writezint(ntypes-tlast+1)
for i:=tlast to ntypes do
	writezint(i)
	writezstring(ttname[i])
	writezint(ttnamedef[i]^.bcindex)
	writezint(ttbasetype[i])
	writezint(tttarget[i])

	writezint(ttlower[i])
	writezint(ttlength[i])
	writezint(ttsize[i])
od
fixup_genfields()

writezint(kknewstringtable)
writezint(nstrings)
for i:=1 to nstrings do
	writezint(stringlentable^[i])
	writezblock(cast(stringtable^[i]),stringlentable^[i])
od


writestructfields()

for i:=0 to nmodules do
	writepccode2pc(i)
od

writezint(kkgenfieldnames)
writezint(ngenfieldnames)
for i:=1 to ngenfieldnames do
	writezstring(genfieldnames[i].def^.name)
	writezint(genfieldnames[i].dataindex)
	writezint(genfieldnames[i].datalength)
od

writezint(kkgenfielddata)
writezint(ngenfielddata)
for i:=1 to ngenfielddata do
	writezint(genfielddata[i].fieldindex)
	writezint(genfielddata[i].recordtype)
	writezint(genfielddata[i].fieldtype)
	writezint(genfielddata[i].offset)
od

writezint(kkend)
writezeof()

length:=getpcpos()

writepcdata(&.filename)

if fverbose then
	println "Finished writing",&.filename,length,"bytes"
fi
end

proc writesymbols(int mx)=
ref intpc p,pccode
ref strec d
int cmd,i,index

pccode:=p:=cast(moduletable[mx].pccode)

do
	cmd:=p++^

	for i:=1 to cmdnopnds[cmd] do
		switch cmdfmt[cmd,i]
		when cproc then
			d:=ref strec(int(p^))
			showpcsymbol(d)
			p^:=d^.bcindex

		when cdllproc then
			d:=ref strec(int(p^))
			p^:=d^.index

		when cmemory then
			d:=ref strec(int(p^))
			showpcsymbol(d)
			p^:=d^.bcindex
		when cframe then
			d:=ref strec(int(p^))
			p^:=d^.index*varsize

		when cint then
			if cmd=kcall and i=2 then
				p^:=p^*varsize		!var offsets to byte offsets
			elsif cmd=kcallptr and i=2 then
				p^:=p^*varsize
			elsif cmd=kaddsp and i=1 then
				p^:=p^*varsize
			fi
		endswitch
		++p
	od
	if cmd=kendmodule or cmd=0 then
		exit
	fi
od
end

proc showpcsymbol(ref strec d)=
	int a,b
	char c

	a:=b:=0

	if d^.bcindex=0 then
		d^.bcindex:=++nsymbols
		case d^.nameid
		when procid then
			c:='P'
			a:=d^.index
		when staticid then
			c:='S'
		when moduleid then
			c:='M'
			a:=d^.attribs.ax_moduleno

		when typeid then
			c:='T'
			a:=d^.mode
		when programid then
			return
		else
			loaderror("SHOWPCSYM?")
		esac

		writezint(c)
		writezstring(d^.name)
		writezint(d^.owner^.bcindex)
		writezint(a)
		writezint(b)

		if c='P' then
			if d^.metadata then
				writezstring(d^.metadata)
			else
				writezstring("")
			fi
		fi
	fi
end

proc writepccode2pc(int mx)=
ref intpc p,pccode
ref[0:]word16 linetable
ref strec d
int cmd,i,index,pcindex,startindex

writezint(kkpccode)
writezint(mx)
writezint(moduletable[mx].pcindex)

pccode:=p:=cast(moduletable[mx].pccode)
linetable:=moduletable[mx].linetable
pcindex:=1

do
	cmd:=p++^

	writezint(linetable^[pcindex])
	writezint(cmd)

	startindex:=pcindex++

	for i:=1 to cmdnopnds[cmd] do
		switch cmdfmt[cmd,i]
		when clabel, cproc, cdllproc, cmemory, cframe,
			 cint,cword, cstring, ctype, cgenfield, coperator, capplproc then
			writezint(p^)
		when creal then
			writezreal(real@(p^))
		when crange then
			writezrange(cast(p))
		else
cpl opndnames[cmdfmt[cmd,i]]
			loaderror("writepc2bc/opnd?")
		endswitch
		++pcindex
		++p
	od

	if cmd=kendmodule or cmd=0 then
		exit
	fi
od

end

proc writestructfields=
int structpos,currpos
int nstructfields,i,j,t
ref strec d,e
const maxfields=100
[maxfields]ref strec fieldlist
[maxfields]byte ignore
int nfields

writezint(kkstructtable)
structpos:=getpcpos()
writezint4(0)

nstructfields:=0

for t:=tlast to ntypes when ttbasetype[t]=tstruct do
	d:=ttnamedef[t]^.deflist
	nfields:=0

	while d do
		if d^.nameid=fieldid and not d^.attribs.ax_at then
			++nfields
			if nfields>maxfields then
				loaderror("wsf: too many fields in struct")
			fi
			fieldlist[nfields]:=d
			ignore[nfields]:=0
		fi
		d:=d^.nextdef
	od
	for i:=1 to nfields do
		d:=fieldlist[i]
		for j:=i+1 to nfields when i<>j do
			e:=fieldlist[j]
			if d^.offset=e^.offset then
				ignore[i]:=1
			fi
		od
	od

	for i:=nfields downto 1 when not ignore[i] do
		d:=fieldlist[i]
		++nstructfields
		writezint(t)
		writezstring(d^.name)
		writezint(d^.mode)
		writezint(d^.offset)
	od

od

currpos:=getpcpos()
setpcpos(structpos)
writezint4(nstructfields)
setpcpos(currpos)
end

proc fixup_genfields=
int recordtype,fieldtype,i,offset
ref strec d,p,q

ngenfielddata:=0

for i:=1 to ngenfieldnames do
	d:=genfieldnames[i].def
	genfieldnames[i].dataindex:=ngenfielddata+1

	p:=d^.nextdupl
	while p do
		offset:=p^.offset
		if p^.nameid=fieldid then
			recordtype:=p^.owner^.mode
			fieldtype:=p^.mode

		elsif p^.nameid=procid then
			recordtype:=p^.owner^.mode
			fieldtype:=trefproc

		elsif p^.nameid=linkid and p^.owner^.nameid<>moduleid then
			q:=p
			repeat
				q:=q^.equiv
			until q^.nameid<>linkid
			recordtype:=p^.owner^.mode
			fieldtype:=trefproc
			offset:=q^.offset
		else
			goto skip
		fi
		if ngenfielddata>=maxgenfields then
			loaderror("GENFIELDDATA OVERFLOW")
		fi

		++ngenfielddata
		genfielddata[ngenfielddata].fieldindex:=i
		genfielddata[ngenfielddata].recordtype:=recordtype
		genfielddata[ngenfielddata].fieldtype:=fieldtype
		genfielddata[ngenfielddata].offset:=offset
skip::
		p:=p^.nextdupl
	od
	genfieldnames[i].datalength:=ngenfielddata-(genfieldnames[i].dataindex)+1
od
end

proc showhelp=
static ichar helptext="THIS IS THE HELP TEXT"

println helptext

stop
end

global function NEXTCMD(int &paramno, ichar &name, &value, ichar defext=nil)int=
static int infile=0
static ichar filestart=nil
static ichar fileptr=nil
static byte colonnext=0
ref char q
ichar item,fileext
int length
static [300]char str

RETURN 0
end

global proc writedocs=
[300]char filename
[50]ref strec params
int nparams
filehandle f
ref strec def,e
ref procrec p

strcpy(&.filename,moduletable[nmodules].filename)
strcpy(&.filename,changeext(&.filename,".txt"))

f:=fopen(&.filename,"w")
println "Writing Docstring file",&.filename

p:=proclist
while p do

	def:=p^.def
	if def^.docstring and not def^.attribs.ax_at then

		e:=def^.deflist
		nparams:=0
		while e do
			if e^.nameid=paramid and e^.name^<>'$' then
				params[++nparams]:=e
			fi
			e:=e^.nextdef
		od

		println @f,"================================================"
		print   @f,(def^.mode=tvoid|"Proc "|"Function ")
		print   @f,def^.owner^.name,,".",,def^.name,,"("
		for i:=nparams downto 1 do
			e:=params[i]
			if e^.attribs.ax_byrefmode then
				print @f,"&"
			fi
			print @f,e^.name
			if e^.code then
				print @f," =",strexpr(e^.code)^.strptr
			fi
			if i<>1 then print @f,"," fi
		od
		println @f,")"
		println @f,"================================================"
	    println @f,def^.docstring
	fi
	p:=p^.nextproc
od

fclose(f)
end

proc do_writeqa(ichar outfile)=
	[300]char newoutfile


	if fwriteqa then
		if fbundled then
			loaderror("-qa used with .qa input")
		fi
		strcpy(&.newoutfile, changeext(outfile,"qa"))


		writeqafile(&.newoutfile)
		stop
	fi
end
=== qc_support.m 31/56 ===
import clib
import mlib
import oslib

import var_types
import var_decls
import qc_lex
import pq_common
import qc_tables
import qci

global [0:]byte bytemasks=(1,2,4,8,16,32,64,128)



const zmax=239             !maximum value in one byte

const zint240=245          !next byte is value 240 to 479
const zint480=246          !next byte is value 480 to 719
const zint720=247          !next byte is value 720 to 959

const zint1=248            !Int is neg of next byte value (mainly for small neg values)
const zint2=249            !Int in next 2 sign extended bytes
const zint4=250            !Int in next 4 bytes
const zint8=251            !Dint in next 8 bytes
const zreal4=252           !Real in next 4 bytes (add 32-bit zero lsw)
const zreal8=253           !Real in next 8 bytes
const zstring=254          !String
const zbytes=244          	!General data: count follows (in zint format) then data bytes
const zeof=255          	!eof marker

ref byte pcstart,pcdest,pcend
int pcalloc


global proc prterror(ichar mess)=
println "Print error:",mess
os_getch()
stop 1
end

global proc serror_gen(ichar mess)=
if currproc and currproc^.nameid=procid then
	print "In function",currproc^.name,," "
fi

println "On line",lx.lineno,"in file",currmodule^.filename

println
println "**** Syntax Error:",mess,"****"
println
println
println
stop 1
end

global proc serror(ichar mess)=
serror_gen(mess)
end

global proc serror_ss(ichar mess,a,b)=
[256]char str
fprint @&.str,mess,a,b
serror_gen(&.str)
end

global proc serror_s(ichar mess,a)=
[256]char str
fprint @&.str,mess,a
serror_gen(&.str)
end

global proc error_gen(int pass,ichar mess,unit p=nil)=
int lineno,fileno
ichar poss

if p then
	lineno:=p^.lineno
	fileno:=p^.moduleno
	poss:=""
else
	fileno:=currmoduleno
	poss:="?"
	lineno:=mlineno iand 16777215
fi

if currproc and currproc^.nameid=procid then
	print "In function",currproc^.name,," "
fi

println "On line",lineno iand 16777215,"in file",moduletable[fileno].filename,poss
println
case pass
when 'R' then print "**** RX Name Error: "
when 'T' then print "**** TX Type Error: "
when 'G' then print "**** GX Code Gen Error: "
esac
println mess
println
println


os_getch()

stop 1
end

global proc rxerror(ichar mess,unit p=nil)=
error_gen('R',mess,p)
end

global proc gerror(ichar mess,unit p=nil)=
error_gen('G',mess,p)
end

global proc rxerror_s(ichar mess,a,unit p=nil)=
[256]char str
fprint @&.str,mess,a
error_gen('N',&.str,p)
end

global function testelem(ref[0:]byte p,int n)int =		!TESTELEM
return ((p^[n>>3] iand bytemasks[n iand 7])|1|0)
end

global proc setelem(ref[0:]byte p,int n) =		!SETELEM
p^[n>>3] ior:= bytemasks[n iand 7]
end

global proc inittypetables=
int i,size,bitsize


for i:=0 to tlast-1 do

	ttname[i]:=stdtypenames[i]
	ttbasetype[i]:=i

	case i
	when tintm, twordm, trefm then
		bitsize:=$targetbits
	else
		bitsize:=stdtypewidths[i]
	esac

	switch bitsize
	when 0 then
	when 1,2,4 then
		size:=1
	else
		size:=bitsize/8
	endswitch

	ttsize[i]:=size
	ttbitwidth[i]:=bitsize

	ttlower[i]:=1
od
ntypes:=tlast-1

tttarget[trefvar]:=tvariant
end

global function nextpoweroftwo(int x)int=

if x=0 then return 0 fi

int a:=1
while a<x do
	a<<:=1
od
return a
end

global proc initpcdest=
pcalloc:=16384

pcstart:=pcm_alloc(pcalloc)
pcend:=pcstart+pcalloc
pcdest:=pcstart
end

global function getpcpos:int=
return pcdest-pcstart
end

global proc setpcpos(int pos)=
pcdest:=pcstart+pos
end

global function writepcdata(ichar filename)int=
int nbytes
filehandle f

f:=fopen(filename,"wb");
if f=nil then
	println "Couldn't create",filename
	stop 1
fi

fwrite(pcstart,pcdest-pcstart,1,f)
fclose(f)

return 1
end

global proc writezstring(ichar s)=
int i,n

outpcbyte(zstring)
n:=strlen(s)

to n do
	outpcbyte(s++^)
od
outpcbyte(0)
end

global proc writezblock(ref byte s, int length)=
int i

to length do
	outpcbyte(s++^)
od
end

global proc writezint(int64 x)=
ref byte p

if x>=0 and x<=zmax then
	outpcbyte(x)
elsif x>=240 and x<480 then
	outpcbyte(zint240)
	outpcbyte(x-240)
elsif x>=480 and x<720 then
	outpcbyte(zint480)
	outpcbyte(x-480)
elsif x>=720 and x<960 then
	outpcbyte(zint720)
	outpcbyte(x-720)
elsif x>=-127 and x<0 then
	outpcbyte(zint1)
	outpcbyte(-x)
elsif x>=-32768 and x<=32767 then
	outpcbyte(zint2)
	outpcword16(x)
elsif x>-0x8000'0000 and x<=0x7fff'ffff then
	outpcbyte(zint4)
	outpcword(x)
else
	p:=cast(&x)
	outpcbyte(zint8)
	to 8 do
		outpcbyte(p++^)
	od
fi
end

global proc writezint4(int x)=

outpcbyte(zint4)
outpcword(x)
end

global proc writezrange(ref byte p)=
outpcbyte(zint8)
to 8 do
	outpcbyte(p++^)
od
end

global proc writezreal(real x)=
ref byte p
ref int32 q

p:=cast(&x)
q:=cast(&x)

if q<>nil then
	outpcbyte(zreal8)
	to 8 do
		outpcbyte(p++^)
	od
else
	outpcbyte(zreal4)
	p+:=4
	to 4 do
		outpcbyte(p++^)
	od
fi
end

global proc writezeof=
	outpcbyte(zeof)
end

global function ipower(i64 a,int n)i64=		!IPOWER

if n<=0 then
	return 0
elsif n=0 then
	return 1
elsif n=1 then
	return a
elsif (n iand 1)=0 then
	return ipower(a*a,n/2)
else			!assume odd
	return a*ipower(a*a,(n-1)/2)
fi
end

global proc gs_additem(ref strbuffer dest,ichar s)=		!GENITEM
ichar d
int lastchar,nextchar

d:=dest^.strptr

if dest^.length then
	lastchar:=(d+dest^.length-1)^
	nextchar:=s^
	if isalphanum(lastchar) and isalphanum(nextchar) then
		strbuffer_add(dest," ")
	fi
fi
strbuffer_add(dest,s)
end

function isalphanum(int c)int=
if c>='A' and c<='Z' or c>='a' and c<='z' or c>='0' and c<='9' then
	return 1
fi
return 0
end

proc outpcbyte(int x)=
int newalloc,oldbytes
ref byte pcnew

if pcdest>=pcend then			!need new allocatiob
	newalloc:=pcalloc*2
	pcnew:=pcm_alloc(newalloc)
	oldbytes:=pcdest-pcstart
	memcpy(pcnew,pcstart,oldbytes)
	pcstart:=pcnew
	pcend:=pcstart+newalloc
	pcdest:=pcstart+oldbytes
	pcalloc:=newalloc
fi
pcdest++^:=x
end

proc outpcword(int x)=
ref byte p:=cast(&x)
outpcbyte(p++^)
outpcbyte(p++^)
outpcbyte(p++^)
outpcbyte(p^)
end

proc outpcword16(int x)=
ref byte p:=cast(&x)
outpcbyte(p++^)
outpcbyte(p^)
end

global proc writeqafile(ichar destfile)=
	filehandle f
	[maxqafiles]int fileoffsets, headeroffsets
	int offset,nn,NEWOFFSET

	println "Writing QA File",destfile

	f:=fopen(destfile,"wb")
	if not f then loaderror("Can't create qa file #",destfile) fi

CPL "WRITEQAFILE"


	println @f,"qafile",nqafiles

	for i to nqafiles do
		print @f,i:"3",qafilenames[i]:"16jl"
		print @f, qafilesizes[i]:"8"
		headeroffsets[i]:=getfilepos(f)+1
		println @f,"         "
	od

	for i to nqafiles do
		fprintln @f,"=== # #/# ===",qafilenames[i],i,nqafiles

		offset:=getfilepos(f)
		fileoffsets[i]:=offset
		nn:=writerandom(f,cast(qafiletext[i]),offset,qafilesizes[i])
	od

	println @f,"=== end ==="

	for i to nqafiles do
		setfilepos(f,headeroffsets[i])
		print @f,fileoffsets[i]:"8"
	od

	fclose(f)
end

global proc addqafile(ichar filespec, source, int length) =

	if nqafiles>=maxqafiles then
		loaderror("Too many qa files")
	fi
	++nqafiles
	qafilenames[nqafiles]:=pcm_copyheapstring(extractfile(filespec))
	qafiletext[nqafiles]:=pcm_copyheapstring(source)
	qafilesizes[nqafiles]:=length
end

=== qc_lex.m 32/56 ===
import msys
import mlib
import clib
import oslib

import var_types
import var_decls
import qc_tables
import qc_support

GLOBAL INT NLOOKUPS, NCLASHES

global record lexrec =		!should be 32-byte record
	union
		int64 value				!64-bit int
		real64 xvalue			!64-bit float
		word64 uvalue			!64-bit word
		ref char svalue			!pointer to string or charconst (not terminated)
		ref strec symptr		!pointer to symbol table entry for name
	end
	int32 symbol
	int32 subcode
	int32 length				!length of name/string/char
	int32 lineno
	int32 fileno
	word32 hashvalue
end

global lexrec lx				!provides access to current token data
global lexrec nextlx

const maxmacrodepth=10
[maxmacrodepth]ref byte macrostack
int macrolevel=0

const etx	= 26
const cr	= 13
const lf	= 10
const tab	= 9

ref byte lxstart
ref byte lxsptr
ref strec lxsymptr

const hstsize	= 32768
const hstmask	= hstsize-1

global [0:hstsize]strec hashtable

[]ichar maxnumlist=(
	"",					!1
	"1111111111111111111111111111111111111111111111111111111111111111",   	!2
	"11112220022122120101211020120210210211220",                          	!3
	"33333333333333333333333333333333",                                   	!4
	"2214220303114400424121122430",                                       	!5
	"3520522010102100444244423",                                          	!6
	"45012021522523134134601",                                            	!7
	"1777777777777777777777",                                             	!8
	"145808576354216723756",                                              	!9
	"18446744073709551615",                                               	!10
	"335500516A429071284",                                                	!11
	"839365134A2A240713",                                                 	!12
	"219505A9511A867B72",                                                 	!13
	"8681049ADB03DB171",                                                  	!14
	"2C1D56B648C6CD110",                                                  	!15
	"FFFFFFFFFFFFFFFF")                                                   	!16
[maxnumlist.len]int maxnumlen

global proc lexreadtoken=
int c,hsum,commentseen
ref byte pstart,pnext,p

nextlx.subcode:=0

doswitch lxsptr++^
when 'a'..'z','$','_' then
	nextlx.svalue:=cast(lxsptr-1)
doname::
	hsum:=nextlx.svalue^
	nextlx.hashvalue:=0

	doswitch c:=lxsptr++^
	when 'A'..'Z' then
		(lxsptr-1)^:=c+' '
		hsum:=hsum<<4-hsum+c+' '
	when 'a'..'z','0'..'9','_','$' then
		hsum:=hsum<<4-hsum+c
	when '"' then
		--lxsptr
		if nextlx.svalue+1=ref char(lxsptr) and (nextlx.svalue^='F' or nextlx.svalue^='f') then
			readrawstring()
			return
		fi
		exit
	else
		--lxsptr
		exit
	end doswitch

	nextlx.symbol:=rawnamesym
	nextlx.length:=lxsptr-ref byte(nextlx.svalue)

	nextlx.hashvalue:=hsum<<5-hsum
	return

when 'A'..'Z' then
	nextlx.svalue:=cast(lxsptr-1)
	nextlx.svalue^+:=int(' ')
	goto doname

when '0'..'9' then
	c:=(lxsptr-1)^
	case lxsptr^
	when ' ',')',cr,',','|' then		!assume single digit decimal
		nextlx.symbol:=intconstsym
		nextlx.subcode:=tint
		nextlx.value:=c-'0'
	when 'x','X' then
		case c
		when '0' then		!0x
			++lxsptr
			readnumber(16)
		when '1' then
			lxerror("Bad base")
		else				!other base 2..9
			++lxsptr
			readnumber(c-'0')
		esac
	else
		--lxsptr
		readnumber(10)
	esac
	return

when '!' then			!comment to eol
docomment::
	doswitch c:=lxsptr++^
	when 13 then
		++lxsptr
		exit
	when 10 then
		exit
	when etx,0 then
		--lxsptr
		exit
	end
	++nextlx.lineno

	nextlx.symbol:=eolsym
	return

when '#' then			!docstring to eol

	nextlx.svalue:=cast(lxsptr)

	doswitch c:=lxsptr++^
	when 13,10,etx,0 then			!leave eol for next symbol
		--lxsptr
		exit
	end

	nextlx.length:=lxsptr-ref byte(nextlx.svalue)
	nextlx.symbol:=docstringsym
	return

when '\\' then			!line continuation

	commentseen:=0
	doswitch lxsptr++^			!read until end of this line
	when cr then
		++nextlx.lineno
		++lxsptr				!skip lf
		exit
	when lf then
		++nextlx.lineno
		exit
	when etx,0 then
		nextlx.symbol:=eofsym
		--lxsptr
		return
	when ' ',tab then
	when '!' then
		commentseen:=1
	else
		if not commentseen then
			lxerror("\\ not followed by eol")
		fi
enddoswitch

	doswitch lxsptr++^
	when cr then
		++nextlx.lineno
		++lxsptr				!skip lf
	when lf then
		++nextlx.lineno
	when ' ',tab then
	else
		--lxsptr
		exit
	enddoswitch

when '{' then
	nextlx.symbol:=lcurlysym
	return

when '}' then
	nextlx.symbol:=rcurlysym
	return

when '.' then
	switch lxsptr^
	when '.' then				!.. or ...
		++lxsptr
		if lxsptr^='.' then
			++lxsptr
			nextlx.symbol:=ellipsissym
		else
			nextlx.symbol:=rangesym
			nextlx.subcode:=j_makerange		!helps treat as opsym which all have k-code as subcode
		fi
		return
	when '0'..'9' then			!real const: deal with this after the switch
		--lxsptr
		readrealnumber(nil,0,10)
		return
	else
		p:=lxsptr-2
		if p<lxstart or p^=cr or p^=lf then
			nextlx.symbol:=lexdotsym
		else
			nextlx.symbol:=dotsym
		fi
		return
	endswitch

when ',' then
	nextlx.symbol:=commasym
	return

when ';' then
	nextlx.symbol:=semisym
	return

when ':' then
	switch lxsptr^
	when '=' then
		++lxsptr
		case lxsptr^
		when '=' then
			++lxsptr
			nextlx.symbol:=deepcopysym
			nextlx.subcode:=j_deepcopyx
		else
			nextlx.symbol:=assignsym
			nextlx.subcode:=j_assignx		!helps treat as opsym which all have k-code as subcode
		esac
	when ':' then
		++lxsptr
		case lxsptr^
		when '=' then
			++lxsptr
			nextlx.symbol:=deepcopysym
			nextlx.subcode:=j_deepcopyx
		else
			nextlx.symbol:=dcolonsym
		esac
	else
		nextlx.symbol:=colonsym
	endswitch
	return

when '(' then
	nextlx.symbol:=lbracksym
	return

when ')' then
	nextlx.symbol:=rbracksym
	return

when '[' then
	nextlx.symbol:=lsqsym
	return

when ']' then
	nextlx.symbol:=rsqsym
	return

when '|' then
	if lxsptr^='|' then
		++lxsptr
		nextlx.symbol:=dbarsym
	else
		nextlx.symbol:=barsym
	fi
	return

when '^' then
	nextlx.symbol:=ptrsym
	nextlx.subcode:=j_ptrto
	return

when '@' then
	if lxsptr^='@' then
		++lxsptr
		nextlx.symbol:=datsym
	else
		nextlx.symbol:=atsym
	fi
	return

when '?' then
	nextlx.symbol:=questionsym
	return

when 178 then
	nextlx.symbol:=opsym
	nextlx.subcode:=j_sqr
	return
		!'' in ansi font or whatever

when '~' then
	nextlx.symbol:=curlsym
	return


when '+' then
	nextlx.symbol:=opsym
	if lxsptr^='+' then
		++lxsptr
		nextlx.symbol:=incrsym
		nextlx.subcode:=j_preincrx
		return
	else
		nextlx.subcode:=j_add
	fi
	return

when '-' then
	nextlx.symbol:=opsym
	if lxsptr^='-' then
		++lxsptr
		nextlx.symbol:=incrsym
		nextlx.subcode:=j_predecrx
		return
	else
		nextlx.subcode:=j_sub
	fi
	return

when '*' then
	nextlx.symbol:=opsym
	if lxsptr^='*' then
		++lxsptr
		nextlx.subcode:=j_power
	else
		nextlx.subcode:=j_mul
	fi
	return

when '/' then
	nextlx.symbol:=opsym
	case lxsptr^
	when '/' then
		++lxsptr
		nextlx.subcode:=j_ddiv
	else
		nextlx.subcode:=j_div
	esac
	return

when '%' then
	nextlx.symbol:=opsym
	nextlx.subcode:=j_idiv
	return

when '=' then
	case lxsptr^
	when '>' then
		nextlx.symbol:=sendtosym
		++lxsptr
	when '=' then
		nextlx.symbol:=opsym
		nextlx.subcode:=j_isequal
		++lxsptr
	else
		nextlx.symbol:=opsym
		nextlx.subcode:=j_eq
	esac
	return

when '<' then
	nextlx.symbol:=opsym
	switch lxsptr^
	when '=' then
		++lxsptr
		nextlx.subcode:=j_le
	when '>' then
		++lxsptr
		nextlx.subcode:=j_ne
	when '<' then
		++lxsptr
		nextlx.subcode:=j_shl
	else
		nextlx.subcode:=j_lt
	endswitch
	return

when '>' then
	nextlx.symbol:=opsym
	switch lxsptr^
	when '=' then
		++lxsptr
		nextlx.subcode:=j_ge
	when '>' then
		++lxsptr
		nextlx.subcode:=j_shr
	else
		nextlx.subcode:=j_gt
	endswitch
	return

when '&' then
	case lxsptr^
	when '&' then
		++lxsptr
		nextlx.symbol:=opsym
		nextlx.subcode:=j_andand
	when '.' then
		++lxsptr
		nextlx.symbol:=anddotsym
		nextlx.subcode:=0
	else
		nextlx.symbol:=addrsym
		nextlx.subcode:=j_addrof
	esac
	return

when '\'','`' then
	lxreadstring('\'')
	return

when '"' then
	lxreadstring('"')
	return

when ' ',tab then

when cr then
	++lxsptr				!skip lf
	++nextlx.lineno
	nextlx.symbol:=eolsym
	return
when lf then			!only lfs not preceded by cr
	++nextlx.lineno
	nextlx.symbol:=eolsym
	return

when etx,0 then
	if macrolevel then
		unstackmacro()
	else
		nextlx.symbol:=eofsym
		--lxsptr
		return
	fi

when 0xEF then
	lxsptr+:=2


else
	nextlx.symbol:=errorsym
	nextlx.value:=c
	return

end doswitch

end

proc lxreadstring(int termchar)=
static [256]char psname
ichar dest
int c,d

if termchar='"' then
	nextlx.symbol:=stringconstsym
	nextlx.subcode:=tstring
else
	nextlx.symbol:=charconstsym
	nextlx.subcode:=tint
fi


if not prescanmode then
	dest:=cast(lxsptr)				!form string into same buffer
else								!put strings into local space
	dest:=&.psname					!must not overflow 255 characters
fi
nextlx.svalue:=dest

do
	switch c:=lxsptr++^
	when '\\' then			!escape char
		c:=lxsptr^
		if c>='A'  and c<='Z' then c+:=' ' fi
		++lxsptr
		switch c
		when 'a' then			!bell ('alert')
			c:=7
		when 'b' then			!backspace
			c:=8
		when 'c','r' then		!carriage return
				c:=cr
		when 'e' then			!end-of-text
			c:=26
		when 'f' then			!formfeed
			c:=12
		when 'l','n' then		!linefeed, or linux/c-style newline
			c:=lf
		when 's' then			!eScape
			c:=27
		when 't' then			!tab
			c:=9
		when 'v' then			!vertical tab
			c:=11
		when 'w' then			!windows-style cr-lf
			dest++^:=cr
			c:=lf
		when 'x' then	!2-digit hex code follows
			c:=0
			to 2 do
				case d:=lxsptr++^
				when 'A','B','C','D','E','F' then
					c:=c*16+d-'A'+10
				when 'a','b','c','d','e','f' then
					c:=c*16+d-'a'+10
				when '0','1','2','3','4','5','6','7','8','9' then
					c:=c*16+d-'0'
				else
					lxerror("Bad \\x code")
				esac
			od
		when 'y' then			!CCI/SM backwards tab
			c:=16
		when 'z','0' then		!null (not fully supported in code)
			c:=0
		when '"','Q' then		!embedded double quote
			c:='"'
		when '\\' then
			c:='\\'
		when '\'' then			!embedded single quote
			c:='\''
		else
			println c,char(c),=nextlx.lineno
			lxerror("Unknown string escape")
		end
	when '"','\'' then		!possible terminators
		if c=termchar then		!terminator char
			if lxsptr^=c then		!repeated, assume embedded term char
				++lxsptr
			else			!was end of string
				exit
			fi
		fi
	when cr,lf,etx,0 then
		cpl =nextlx.lineno
		lxerror("String not terminated")
	endswitch

	if not prescanmode then
		dest++^:=c
	else
		if dest-nextlx.svalue<(psname.len-5) then
			dest++^:=c
		fi
	fi
od
nextlx.length:=dest-nextlx.svalue
(nextlx.svalue+nextlx.length)^:=0
end

proc readnumber(int base)=
ref byte pstart,dest
int numtype,c
ref char p

dest:=pstart:=lxsptr

if base=10 then
	doswitch c:=lxsptr++^
	when '0'..'9' then
		dest++^:=c
	when '_','\'','`' then
	else
		--lxsptr
		exit
	end doswitch
else
	dest:=scannumber(base)
	c:=lxsptr^
fi

numtype:=0

switch c			!terminator character
when '.' then		!possible real number
	if (lxsptr+1)^<>'.' then

		readrealnumber(cast(pstart),dest-pstart,base)
		return
	fi
when 'e','E' then
	if base<=10 then
		readrealnumber(cast(pstart),dest-pstart,base)
		return
	fi
when 'p','P' then
	if base=16 then
		readrealnumber(cast(pstart),dest-pstart,base)
		return
	fi
when 'i','I' then
	++lxsptr
	numtype:=tint
when 'w','W','u','U' then
	++lxsptr
	numtype:=tword
when 'L','l' then
	++lxsptr
	numtype:=tlongint
end switch

stringtonumber(cast(pstart),dest-pstart,base, numtype)
end

proc readrealnumber(ichar intstart, int intlen, base)=
ref byte fractstart
int fractlen,expon,i,c
real basex,x
const maxrealdigits=500
[maxrealdigits]char realstr


fractstart:=nil
fractlen:=0
expon:=0

if lxsptr^='.' then		!read
	fractstart:=++lxsptr
	fractlen:=scannumber(base)-fractstart
fi

case lxsptr^
when 'e','E' then
	if base<>16 then
		++lxsptr
		expon:=readexponent(base)
	fi
when 'p','P' then
	if base=16 then
		++lxsptr
		expon:=readexponent(base)
	fi
esac

if intlen+fractlen>maxrealdigits then
	lxerror("Real too long")
fi
if intlen then
	memcpy(&realstr,intstart,intlen)
fi
if fractlen then
	memcpy(&realstr[1]+intlen,fractstart,fractlen)
fi

basex:=base
expon-:=fractlen
x:=0.0

for i:=1 to intlen+fractlen do		!digits already range-checked
	c:=realstr[i]
	if c>='0' and c<='9' then
		x:=x*basex+c-int('0')
	elsif c>'a' then
		x:=x*basex+c-'a'+10
	else
		x:=x*basex+c-'A'+10
	fi
od

if expon>=0 then
	to expon do
		x*:=basex
	od
else
	to -expon do
		x/:=basex
	od
fi

nextlx.symbol:=realconstsym
nextlx.subcode:=treal
nextlx.xvalue:=x
end

function readexponent(int base)int=
ref byte numstart,numend
int expon,length,neg

neg:=0
case lxsptr^
when '+' then ++lxsptr
when '-' then ++lxsptr; neg:=1
esac

numstart:=lxsptr
length:=scannumber(base)-numstart

if length=0 then
	lxerror("Bad expon")
fi

stringtonumber(cast(numstart), length, base, 0)
return (neg|-nextlx.value|nextlx.value)
end

proc lxerror(ichar mess)=
CPL nextlx.lineno,"LEX ERROR",mess,"in",stmodule^.name
abortprogram("Stopping")
end

global proc printsymbol(ref lexrec lp)=
lexrec l
l:=lp^

printf("%-18s",symbolnames[l.symbol])

case l.symbol
when rawnamesym then
	printstrn_app(l.svalue,l.length)
	print " (",,l.hashvalue,,")"
when namesym then
	printstrn_app(l.symptr^.name,l.symptr^.namelen)
when intconstsym then
	case l.subcode
	when tint then print l.value,"int"
	when tword then print l.uvalue,"word"
	else print l.value
	esac

when realconstsym then
	print l.xvalue


when stringconstsym then
	print """"
	printstrn_app(l.svalue,l.length)
	print """"
when charconstsym then
	print "'"
	printstrn_app(l.svalue,l.length)
	print "'"
when longintconstsym then
	printstrn_app(l.svalue,l.length)
	print "L"
when opsym,assignsym,addrsym,ptrsym,deepcopysym,rangesym then
	print jtagnames[l.subcode]
elsif l.subcode then
	print "#",l.subcode
end

println

end

proc stringtonumber(ichar s, int length, base,numtype)=
int64 a
word64 b
int c
ref char t

while length>=2 and s^='0' do		!trim leading zeros
	++s
	--length
od

if numtype=tlongint or length>maxnumlen[base] or 
		(length=maxnumlen[base] and strncmp(s,maxnumlist[base],length)>0) then
	nextlx.symbol:=longintconstsym
	nextlx.svalue:=s
	nextlx.length:=length
	switch base
	when 10 then
	when 16 then
		t:=pcm_alloc(2+length+1)
		strcpy(t,"0x")
		strcat(t,s)
		nextlx.svalue:=t
		nextlx.length+:=2
	when 2..9 then
		t:=pcm_alloc(2+length+1)
		nextlx.svalue:=t
		t++^:=base+'0'
		t++^:='x'
		strcat(t,s)
		nextlx.length+:=2

	else
		lxerror("longint/base?")
	endswitch

	if numtype and numtype<>tlongint then		!can't narrow result
		lxerror("Can't apply width override to longint")
	fi
	return
fi

a:=0

if base<=10 then
	to length do
		a:=a*base+s++^-'0'
	od
else
	to length do
		c:=s++^
		if c>='a' then
			a:=a*base+c-'a'+10
		elsif c>='A' then
			a:=a*base+c-'A'+10
		else
			a:=a*base+c-'0'
		fi
	od
fi

nextlx.symbol:=intconstsym
nextlx.value:=a

if numtype then
	nextlx.subcode:=numtype
	return
fi

b:=word64(a)

if b<word64(0x7FFF'FFFF'FFFF'FFFF) then
	nextlx.subcode:=tint
else						!needs 1 more bit
	nextlx.subcode:=tword
fi
end

global proc lexsetup=
int i!,n
static int n

for i to maxnumlist.len do
	maxnumlen[i]:=strlen(maxnumlist[i])
od

inithashtable()
n:=0
for i:=0 to hstmask do
	if hashtable[i].name then
		++n
	fi
od
end


function scannumber(int base)ref byte=
ref byte dest
int c

dest:=lxsptr

doswitch c:=lxsptr++^
when '0'..'9' then
	dest++^:=c
	if c>='0'+base then
		lxerror("Digit out of range")
	fi
when 'A'..'F','a'..'f' then
	if base=16 then
		dest++^:=c
	else
		--lxsptr
		exit
	fi
when '_','\'','`' then
else
	--lxsptr
	exit
end doswitch
return dest
end

proc readrawstring=
ichar dest
int c

nextlx.symbol:=stringconstsym
nextlx.subcode:=tstring
nextlx.svalue:=cast(++lxsptr)

dest:=cast(lxsptr)				!form string into same buffer

doswitch c:=lxsptr++^
when '"' then
	if lxsptr^='"' then		!repeated, assume embedded term char
		dest++^:='"'
		++lxsptr
	else			!was end of string
		(lxsptr-1)^:=0
		exit
	fi
when cr,lf,etx,0 then
	lxerror("Raw string not terminated")
	--lxsptr
	exit
else
	dest++^:=c
enddoswitch
nextlx.length:=dest-nextlx.svalue
end

function lookup:int=
int j, wrapped

++NLOOKUPS

j:=nextlx.hashvalue iand hstmask
lxsymptr:=&hashtable[j]
wrapped:=0

do
	if lxsymptr^.name=nil then			!unused entry; finish
		exit
	fi
	if lxsymptr^.namelen=nextlx.length then	!match on length
		if memcmp(lxsymptr^.name,nextlx.svalue,nextlx.length)=0 then	!match
			return 1
		fi
	fi

++NCLASHES

	++lxsymptr
	if ++j>=hstsize then
		if wrapped then
			abortprogram("HASHTABLE FULL")
		fi
		wrapped:=1
		lxsymptr:=&hashtable[0]
		j:=0
	fi
od


lxsymptr^.name:=nextlx.svalue
lxsymptr^.namelen:=nextlx.length
lxsymptr^.symbol:=rawnamesym

return 0
end

function gethashvaluez(ichar s)word=
word c,hsum

if s^=0 then return 0 fi

hsum:=s++^

do
	c:=s++^
	exit when c=0
	hsum:=hsum<<4-hsum + c
od
return hsum<<5-hsum
end

proc inithashtable=
int i
memset(&hashtable,0,hashtable.bytes)

for i:=1 to stnames.len do
	nextlx.svalue:=stnames[i]
	nextlx.length:=strlen(nextlx.svalue)
	nextlx.hashvalue:=gethashvaluez(nextlx.svalue)

	if lookup() then
		println stnames[i]
		abortprogram("Duplicate symbol table entry")
	fi

	lxsymptr^.symbol:=stsymbols[i]

	case stsymbols[i]
	when unitnamesym then
		lxsymptr^.index:=stsubcodes[i]
		lxsymptr^.subcode:=unitnamesym
		lxsymptr^.symbol:=rawnamesym		!masquerades as normal identifier
		else
		lxsymptr^.subcode:=stsubcodes[i]
	esac
od
end

function dolexdirective(int index)int=
ref strec symptr
ref byte p
ichar file
int i

case index
when definedir then
	lexreadtoken()
	if nextlx.symbol<>rawnamesym then lxerror("define: name expected") fi

	if lookup() and lxsymptr^.symbol=lexmacronamesym then
		printstrn_app(nextlx.svalue,nextlx.length)
		lxerror("Macro already defined")
	fi
	symptr:=lxsymptr

	lexreadtoken()

	unless nextlx.symbol=opsym and nextlx.subcode=j_eq then
		lxerror("""="" expected")
	end unless
	
	p:=lxsptr
	lexreadline()

	addmacro(symptr,cast(p),lxsptr-p)
	lexreadtoken()			!should be eol
	if nextlx.symbol<>eolsym then
		lxerror("Bad define")
	fi
	return 0

when strincludedir then
	lexreadtoken()
	if nextlx.symbol<>stringconstsym then lxerror("strincl: string expected") fi
	file:=nextlx.svalue
	nextlx.svalue:=cast(readfile(file))
	if nextlx.svalue=nil then
		cpl file
		lxerror("Can't find strinclude file")
	fi
	nextlx.symbol:=stringconstsym
	nextlx.subcode:=tstring
	nextlx.length:=rfsize

	if fwriteqa then
		addqafile(file,cast(nextlx.value), rfsize)
	fi


	(nextlx.svalue+rfsize)^:=0			!sometimes .length is not used (eg. in newstringobj())
	return 1							!so get it right. Don't need the etx

else
	cpl sourcedirnames[index]
	lxerror("Directive not implemented")
esac
return 0
END

proc lexreadline=

doswitch lxsptr^
when cr,lf then
	return
when etx,0 then
	--lxsptr
	return
else
	++lxsptr
enddoswitch
END

global proc startlex(ichar caption,sourcecode)=

lxsptr:=cast(sourcecode)
nextlx.lineno:=1

nextlx.symbol:=semisym
nextlx.subcode:=0
end

global function convertzstring(ichar s, int length)ichar=
static [300]char str

if length>str.len then
	abortprogram("convertzstr")
fi
memcpy(&str,s,length)
str[length+1]:=0
return &.str
end

global function addnamestr(ichar name)ref strec=
lexrec oldlx

oldlx:=nextlx
nextlx.hashvalue:=gethashvaluez(name)

nextlx.length:=strlen(name)
nextlx.svalue:=pcm_alloc(nextlx.length+1)
memcpy(nextlx.svalue,name,nextlx.length+1)
lookup()

nextlx:=oldlx

return lxsymptr
end

global proc PS1(ichar caption)=
print caption,,":::"
printsymbol(&lx)
end

global proc PS2(ichar caption)=
print "	",,caption,,":##"
printsymbol(&nextlx)
end

global proc PS(ichar caption)=
PS1(caption)
PS2(caption)
end

global proc lex=
int lineno,n
ref char p

lx:=nextlx				!grab that already read basic token

reenter::

lexreadtoken()			!read new token for next time around

if lx.symbol=namesym then			!zero-terminate identifiers
	(lx.symptr^.name+lx.length)^:=0		!can only do so after next symbol is read
fi


switch nextlx.symbol

when eolsym then
	case lx.symbol
	when commasym, lsqsym, lbracksym then		!ignore eol
		goto reenter
	when semisym then							!don't need ;;
		goto reenter
	else										!convert to semicolon
		nextlx.symbol:=semisym
	esac

when rawnamesym then
	if not lookup() then					!name not found
		nextlx.symbol:=namesym				!convert to actual identifier
		nextlx.symptr:=lxsymptr				
		return
	fi

	nextlx.symbol:=lxsymptr^.symbol			!convert to reserved word, type, op etc
	nextlx.subcode:=lxsymptr^.subcode

	switch nextlx.symbol
	when lexmacronamesym then
		stackmacro(lxsymptr^.macrovalue)
		goto reenter

	when ksourcedirsym then
		if not dolexdirective(nextlx.subcode) then
			goto reenter
		fi
	when rawnamesym then					!might be user identifier (points to generic entry)
		if nextlx.subcode=unitnamesym and
				(lx.symbol=intconstsym or lx.symbol=realconstsym) then
			case lx.symbol
			when intconstsym then
				case lxsymptr^.index
				when million_unit then lx.value *:= 1 million
				when billion_unit then lx.value *:= 1 billion
				when thousand_unit then lx.value *:= 1 thousand
				when kilo_unit then lx.value *:= 1024
				when mega_unit then lx.value *:= 1048576
				when giga_unit then lx.value *:= (1048576*1024)
				else
					lxerror("Can't do this unit index")
				esac
			else
				lxerror("Unit suffix after float not implem")
			esac
			goto reenter
		else
			nextlx.symbol:=namesym
			nextlx.symptr:=lxsymptr
		fi
	when namesym then						!matches existing name
		lxerror("NEXT NAME!!!")

	when kifsym,kcasesym,kswitchsym,kdocasesym,kdoswitchsym,kforsym,kforallsym,
			kdosym,ktosym,kprocsym,kfunctionsym,kmethodsym,kimportmodulesym,kunlesssym,
			krecordsym,kstructsym,kunionsym,ktypesym,kwhilesym,kclasssym,
			ktrysym,ktabledatasym then
		if lx.symbol=kendsym then
			lx.subcode:=nextlx.symbol			!turn end if to single end/if tokeb
			goto reenter
		fi
	when opsym then
		goto doopsym
	when sysconstsym then					!ST ENTRY LIMITED TO 16 bits signed
		case nextlx.subcode
		when nil_const, con_const then
			nextlx.symbol:=intconstsym
			nextlx.value:=0
			nextlx.subcode:=tint
		when pi_const then
			nextlx.symbol:=realconstsym
			nextlx.xvalue:=3.1415926535897932384626
			nextlx.subcode:=treal
		when tab_const then
			nextlx.symbol:=stringconstsym
			nextlx.subcode:=tstring
			nextlx.svalue:="\t"
			nextlx.length:=1
		else
			lxerror("sysconst?")
		esac
	end switch

when lexdotsym then
	goto reenter

when eofsym then

when stringconstsym then
	if lx.symbol=stringconstsym then
		n:=nextlx.length+lx.length
		p:=pcm_alloc(n+1)
		memcpy(p,lx.svalue,lx.length)
		memcpy(p+lx.length,nextlx.svalue,nextlx.length)
		(p+n)^:=0
		lx.svalue:=p
		lx.length:=n
		goto reenter
	fi


when opsym then
doopsym::
	if nextlx.subcode=j_in and lx.symbol=opsym and lx.subcode=j_notl then
		lx.subcode:=j_notin
		goto reenter
	fi
endswitch

end

global proc showhashtablesize=
int i,n

n:=0
for i:=0 to hstmask do
	if hashtable[i].name then
		++n
	fi
od

CPL "FINAL HASHTABLE",n,hstsize
end

proc addmacro(ref strec symptr, ichar value, int length)=
ichar s
int i

s:=value
for i to length do
	case s^
	when '"' then		!contains string, abandon the idea; comments not allowed
	when '#','!' then	!assume start of comment
		length:=i-1
		if length=0 then lxerror("Null macro") fi
		exit
	esac
	++s
od

symptr^.symbol:=lexmacronamesym

(symptr^.name+symptr^.namelen)^:=0

s:=pcm_alloc(length+2)
memcpy(s,value,length)
(s+length+1)^:=etx
(s+length+2)^:=0
symptr^.macrovalue:=s
END

proc stackmacro(ichar s)=
if macrolevel>=maxmacrodepth then
	lxerror("Too many nested macros")
fi

++macrolevel
macrostack[macrolevel]:=lxsptr

lxsptr:=cast(pcm_copyheapstring(s))
end

proc unstackmacro=
if macrolevel<=0 then lxerror("unstack macro?") fi
lxsptr:=macrostack[macrolevel--]
end

=== qc_parse.m 33/56 ===
import msys
import mlib
import clib
import oslib

import var_types
import var_decls
import qc_support
import pq_common
import qc_tables
import qc_lex
import qc_lib
import qc_name

int intabledata=0		!1 means reading table data line; $ gives tabledataname
int inreadprint=0
int inparamlist=0
int inrecordbody=0
int inimportmodule=0
int labelseen=0
ichar tabledataname=nil

uflagsrec unionstring, unionpend
ref strec unionlastvar=nil

int try_level=0
int varattribs=0

const maxdollarstack=10
[maxdollarstack]ref unitrec dollarstack		!used for a[$]
int ndollar=0
int inmultexpr=0

ref strec currimport

global function parsemodule(int n)int=
modulerec m
ref strec p, owner
int globalflag,status

initparser()

m:=moduletable[n]

if fverbose then
	println "Parsing::",m.name,N
fi

stmodule:=moduletable[n].stmodule

startlex("PARSEMODULE",m.sourcecode)

owner:=stmodule
lex()


status:=readmoduledefs(owner)
if not status then
	return 0
fi

ALLLINES+:=LX.LINENO

return status
end

global function readmoduledefs(ref strec owner)int=
ref strec p
int globalflag,i,found

globalflag:=0

do
	switch lx.symbol
	when kglobalsym then
		if globalflag then serror("global global?") fi
		globalflag:=1
		lex()

	when kprocsym,kfunctionsym,kmethodsym then	!todo
		readprocdef(owner,globalflag)

		globalflag:=0

	when kvarsym then
		readvardef(owner,globalflag,0,staticid)
		globalflag:=0

	when kimportmodulesym then
		readimportmodule(owner)

	when ktypesym then
		readtypedef(owner,globalflag)
		globalflag:=0

	when kconstsym then
		readconstdef(owner,globalflag)
		globalflag:=0

	when kclasssym,krecordsym then
		readclassdef(owner,globalflag)
		globalflag:=0

	when kenumsym then
		lex()
		readenumtype(owner,0)

	when ktabledatasym then
		readtabledef(owner,globalflag)
		globalflag:=0

	when docstringsym then
		gs_strn(docstring,lx.svalue,lx.length)
		gs_line(docstring)
		lex()

	when kimportsym then
		if globalflag then serror("glob/import?") fi
		lex()
		if lx.symbol=opsym and lx.subcode=j_mul then
			lex()
		fi
		checksymbol(namesym)

		found:=0
		for i:=1 to nmodules do
			if eqstring(lx.symptr^.name, moduletable[i].name) then
				found:=1
				exit
			fi
		od
		if not found then
			CPL lx.symptr^.name
			serror("Import stmt out of position?")
		fi

		lex()

	when kimportpathsym then
		lex()
		checksymbol(stringconstsym)
		lex()

	when kapplprocsym then
		readapplprocs(owner)

	when kcondcompsym then
		case lx.subcode
		when windowsff then
			if os_iswindows() then
				lex()
			else
skiptoeol::
				repeat lex() until lx.symbol=semisym or lx.symbol=eofsym

			fi
		when linuxff then
			if not os_iswindows() then
				lex()
			else
				goto skiptoeol
			fi
		else
			serror("condcomp")
		esac

	when semisym then
		lex()

	when eofsym then
		exit

	else
		PS1("symbol")
		serror("Not allowed at module level")
	endswitch
od

return 1
end

proc initparser=

unless nullunit then
	nullunit:=createunit0(j_null)
end unless

try_level:=0
currproc:=nil
varattribs:=0

intabledata:=0		!1 means reading table data line; $ gives tabledataname
inreadprint:=0
inparamlist:=0
inrecordbody:=0
inimportmodule:=0
ichar tabledataname:=""
labelseen:=0
currimport:=nil

ndollar:=0

gs_init(docstring)

end

proc skipsemi=
while lx.symbol=semisym do lex() od
end

proc addalias(ref strec stold,stnew)=			!ADDALIAS
stnew:=getduplnameptr(stold^.owner,stnew,aliasid)
adddef(stold^.owner,stnew)
stnew^.equiv:=stold
end

function makeblock(ref unitrec p)ref unitrec=
return createunit1(j_block,p)
end

proc checkequals=			!CHECKEQUALS
if not (lx.symbol=opsym and lx.subcode=j_eq) then
	serror("""="" expected")
fi
end

function getcurrline:int=
return lx.lineno
end

function checkbegin(int fbrack)int=				!CHECKBEGIN
int closesym

skipsemi()

if lx.symbol=lbracksym and fbrack then
	closesym:=rbracksym
	lex()
elsif lx.symbol=kbeginsym then
	closesym:=kendsym
	lex()
elsif lx.symbol=lcurlysym then
	closesym:=rcurlysym
	lex()
else
	closesym:=kendsym
fi
return closesym
end

proc checkbeginend(int closesym,kwd,startline=0)=		!CHECKBEGINEND
skipsemi()
if closesym=rbracksym or closesym=rcurlysym then
	checksymbol(closesym)
else
	checkend(closesym,kwd,startline)
fi
lex()
end

proc checkend(int endsym,endkwd1, endkwd2=0,startline=0)=		!CHECKEND
[100]char str

if endsym=lx.symbol=rbracksym then
	return
fi

if lx.symbol<>kendsym then
	strcpy(&.str,"Bad 'end' ")
error::

	if startline then
		fprint @&.str+strlen(&.str)," (from line #)",startline
	fi
	serror(&.str)
fi

if lx.subcode=0 then					!plain end; for now, that always matches
	return
fi

unless (endkwd1 and endkwd1=lx.subcode) or (endkwd2 and endkwd2=lx.subcode) then
	strcpy(&.str,"Mismatched 'end'")
	goto error
end unless
end

proc addgenfield(ref strec d)=

if d^.nameid=genfieldid then return fi
if ngenfieldnames>=maxgenfields then
	serror("Too many genfields")
fi

d^.nameid:=genfieldid		!convert base/nullid name to genfield
genfieldnames[++ngenfieldnames].def:=d
d^.offset:=ngenfieldnames	!use instead of .index, which might be needed for some nullid names (unitsuffixes for example?)
end

proc readvardef(ref strec owner,int isglobal=0,isstatic=0,varid=staticid)=
int nvars,m
ref strec stname

lex()
m:=tvariant

nvars:=0
while lx.symbol=namesym do
	++nvars
	stname:=getduplnameptr(owner,lx.symptr,varid)
	stname^.mode:=m
	stname^.attribs.ax_global:=isglobal
	stname^.attribs.ax_static:=isstatic

	adddef(owner,stname)

	lex()

	if lx.symbol=assignsym or lx.symbol=opsym and lx.subcode=j_eq then
		if lx.symbol=assignsym then
			if varid=staticid then
				serror("Need = on static not :=")
			fi
		else
			if varid=frameid then
				stname^.nameid:=staticid
				stname^.attribs.ax_frame:=0
			fi
		fi
		lex()
		stname^.code:=readexpression()
		stname^.attribs.ax_equals:=1
	fi

	if lx.symbol<>commasym then
		exit
	fi
	lex()
od

if nvars=0 then
	serror("No vars declared")
fi
end

proc readconstdef(ref strec owner,int isglobal=0)=
int nconsts,deft,t
ref strec stname

lex()
deft:=tvoid

nconsts:=0

while lx.symbol=namesym do
	stname:=getduplnameptr(owner,lx.symptr,constid)

	lex()

	checkequals()
	lex()
	stname^.code:=readconstexpr(owner,1)
	if deft=tvoid then
		t:=stname^.code^.mode
	else
		t:=deft
	fi
	stname^.mode:=t
	++nconsts

	stname^.attribs.ax_global:=isglobal

	adddef(owner,stname)

	if lx.symbol<>commasym then
		exit
	fi
	lex()
od

if nconsts=0 then
	serror("No consts declared")
fi

end

function readexpression:ref unitrec=	!READEXPRESSION
return readfactor(8)
end

function readfactor(int level)ref unitrec=			!READFACTOR
ref unitrec p,q,r
int opc,opprio,lineno


if level<=1 then		!level might be 0
	p:=readterm()
else
	p:=readfactor(level-1)
fi

doswitch lx.symbol
when opsym, assignsym, rangesym, addrsym, deepcopysym then

	opc:=lx.subcode				!will be kadd, kassign, etc
	opprio:=jtagpriotable[opc]
	lineno:=lx.lineno
	if opprio<>level then exit fi


	lex()
	if opc=j_assignx or opc=j_deepcopyx then			!assign is right-to-left but also special
		q:=readexpression()
	elsif opc=j_power then			!power is right-to-left
		q:=readfactor(level)
	else
		q:=readfactor(level-1)
	fi
	p:=createunit2(opc,r:=p,q)
	p^.lineno:=lineno

else
	exit
enddoswitch
return p
end

function readterm:ref unitrec=		!READTERM
ref unitrec p,q,r
ref char pbyte
word64 a
int oldipl,opc,oldinrp,lineno,shift

lineno:=lx.lineno


switch lx.symbol
when namesym then
	p:=createname(lx.symptr)
	p^.lineno:=lx.lineno
	if nextlx.symbol=lbracksym then
		p^.def:=lx.symptr
	fi
	lex()

when intconstsym,realconstsym then
	p:=createconstunit(lx.value,lx.subcode)
	lex()

when stringconstsym then
	p:=createstringconstunit(lx.svalue,lx.length)
    p^.slength:=lx.length
	lex()

when longintconstsym then
	(lx.svalue+lx.length)^:=0
	p:=createunit0(j_longint)
	p^.svalue:=lx.svalue
	p^.slength:=lx.length
	lex()

when charconstsym then
	a:=0
	shift:=0
	pbyte:=lx.svalue
	to lx.length do
		a:=a ior word64(pbyte^)<<shift
		shift+:=8
		++pbyte
	od
	p:=createconstunit(a,tint)
	lex()

when lbracksym then
	p:=readlbrack()

when lsqsym then
	oldipl:=inparamlist
	inparamlist:=0
	p:=readlsqbrack()
	inparamlist:=oldipl

when stdtypesym,krefsym then
	p:=readcast()

when opsym then
	p:=readopc()

when incrsym then
	opc:=lx.subcode
	lex()
	p:=createunit1(opc,readterm())

when ksprintsym then
	p:=readsprint()

when ksreadsym,ksreadlnsym then
	p:=readsread()

when ptrsym,addrsym then
	opc:=lx.subcode
	lex()
	p:=createunit1(opc,readterm())
	if p^.a^.tag=j_callfn then
		if p^.a^.b then
			serror("Params not allowed")
		fi
		p^.a:=p^.a^.a			!lose the call
	fi

when compilervarsym then
	p:=readcompilervar()
	lex()

when kerrorsym then
	p:= createconstunit(lx.subcode,tint)
	lex()

when dollarsym then
	if intabledata then
		p:=createstringconstunit(tabledataname,-1)
	else
		if ndollar<=0 then
			serror("[$] No array")
		fi
		p:=createunit1(j_upb,dollarstack[ndollar])
	fi
	lex()

when kapplyopsym then
	p:=readapplyop(1)

when kcastsym then
	p:=readcastx()

when ktypeconstsym then
	lex()
	checksymbol(lbracksym)
	lex()
	p:=createunit0(j_typeconst)
	p^.mode:=readtypespec(nil,0)
	checksymbol(rbracksym)
	lex()

when kclampsym then
	lex()
	checksymbol(lbracksym)
	lex()
	p:=readexpression()
	checksymbol(commasym)
	lex()
	q:=readexpression()
	if lx.symbol=rbracksym and q^.tag=j_makerange then
		r:=q^.b
		q:=q^.a
	else
		checksymbol(commasym)
		lex()
		r:=readexpression()
		checksymbol(rbracksym)
	fi
	lex()
	p:=createunit3(j_clamp,p,q,r)

when khostfnsym then
	p:=readhostparams(nil,1)

when kapplsym then
	p:=readapplcall()

else
	cpl symbolnames[lx.symbol]
	serror("readterm?")
endswitch

doswitch lx.symbol
when lbracksym then
	lex()
	oldinrp:=inreadprint
	inreadprint:=0
	q:=readslist(1,1)
	checksymbol(rbracksym)
	lex()
	if p.tag=j_callapplfn then
		p.b:=q
	else
		p:=createunit2(j_callfn,p,q)
		p:=testconstruct(p)
	fi
	inreadprint:=oldinrp

when ptrsym then
	p:=createunit1(j_ptr,p)
	lex()

when lsqsym then
	p:=readindex(p,0)

when lcurlysym then
	p:=readkeyindex(p,0)

when dotsym then
	p:=readdotsuffix(p)

when colonsym then
	if inreadprint then exit fi
	lex()
	q:=readexpression()
	p:=createunit2((inparamlist|j_keyword|j_keyvalue),p,q)

when incrsym then
	case lx.subcode
	when j_preincrx then opc:=j_postincrx	!1
	when j_predecrx then opc:=j_postdecrx	!1
	esac
	lex()
	p:=createunit1(opc,p)

when anddotsym then
	lex()
	checksymbol(lsqsym)
	lex()
	q:=readexpression()
	if q^.tag=j_makerange then
		p:=createunit2(j_anddotslice,p,q)
	else
		p:=createunit2(j_anddotindex,p,q)
	fi
	checksymbol(rsqsym)
	lex()
when opsym then
	case lx.subcode
	when j_sqr then
		p:=createunit1(j_sqr,p)
		lex()

	else
		exit
	esac

else
	exit
enddoswitch

p^.lineno:=lineno

return p

end

function readlbrack:ref unitrec=

ref unitrec plower, ulist,ulistx, p,q,r
int lcmode,oldirp

lex()					!first symbol of first expression
plower:=nil
lcmode:=tlist
ulist:=ulistx:=nil

if lx.symbol=atsym then			!lwb override
	lex()
	oldirp:=inreadprint
	inreadprint:=1
	plower:=readexpression()
	inreadprint:=oldirp
	checksymbol(colonsym)
	lex()
elsif lx.symbol=intconstsym and nextlx.symbol=colonsym then
	plower:=createconstunit(lx.value,lx.subcode)
	lex()
	lex()
elsif lx.symbol=opsym and nextlx.symbol=rbracksym then	!operator constant
	p:=createunit0(j_operator)
	p^.opcode:=lx.subcode
	lex()
	lex()
	return p
elsif lx.symbol=opsym and nextlx.symbol=assignsym then	!operator:= constant
	p:=createunit0(j_operator)
	p^.opcode:=getoptocode(lx.subcode)
	lex()			!read :=
	lex()			!read )
	checksymbol(rbracksym)
	lex()
	return p
elsif lx.symbol=ktypesym and nextlx.symbol=rbracksym then
	p:=createunit0(j_operator)
	p^.opcode:=j_gettype
	lex()
	lex()
	return p
fi


case lx.symbol
when rbracksym then			!empty list
	lex()
	p:=createunit0(j_makelist)
	if plower<>nil then
		p^.b:=plower
	fi
	return p
else					!assume normal expression follows
	p:=readexpression()
esac

case lx.symbol
when rbracksym then			!simple (x) expression
	lex()

	if plower then				!pattern is (y:x), so read as key:value pair
		return createunit2(j_keyvalue,plower,p)
	else
		return p
	fi
when semisym then			!multiple expression
	ulist:=ulistx:=p
	repeat
		lex()					!skip comma
		addlistunit(&ulist,&ulistx,readexpression())
	until lx.symbol<>semisym
	checksymbol(rbracksym)
	lex()

	p:=ulist
	while p do
		case p^.tag
		when j_assignx then p^.tag:=j_assign
		when j_deepcopyx then p^.tag:=j_deepcopy
		when j_preincrx then p^.tag:=j_preincr
		when j_predecrx then p^.tag:=j_predecr
		when j_postincrx then p^.tag:=j_postincr
		when j_postdecrx then p^.tag:=j_postdecr
		when j_callfn then p^.tag:=j_callproc
		when j_callapplfn then p^.tag:=j_callapplproc
		when j_callmfn then p^.tag:=j_callmproc
		esac
		p:=p^.nextunit
	od
	return createunit1(j_exprlist,ulist)

when commasym then
	if nextlx.symbol=rbracksym then		!means one-element list
		lex()
		lex()
		return createunit2(j_makelist,p,plower)
	fi

	ulist:=ulistx:=p
	repeat
		lex()							!skip comma
		if lx.symbol=rbracksym then		!allow ,) to end list
			exit
		fi
		if lx.symbol=commasym then
			serror(",, null expr not allowed")
		fi
		addlistunit(&ulist,&ulistx,readexpression())
		skipsemi()						!allow a,b,c;) (works better with a,b,c\ followed by comment on next line followed by ")")
	until lx.symbol<>commasym
	checksymbol(rbracksym)
	lex()
	return createunit2(j_makelist,ulist,plower)

when barsym then			!ifx/selectx expression; p is selector expression
	lex()
	q:=readexpression()
	if lx.symbol=barsym then		!(a|b|c)
		lex()
		r:=readexpression()
		checksymbol(rbracksym)
		lex()
		return createunit3(j_ifx,p,q,r)
	fi

	addlistunit(&ulist,&ulistx,q)	!start with one-element list
	checksymbol(commasym)
	if nextlx.symbol<>barsym then		!(n|a,| using one-element list; not useful but allow it...
		repeat
			lex()				!skip comma
			addlistunit(&ulist,&ulistx,readexpression())
		until lx.symbol<>commasym
		checksymbol(barsym)
	else
		lex()					!skip |
	fi
	lex()
	r:=readexpression()
	checksymbol(rbracksym)
	lex()
	return createunit3(j_selectx,p,ulist,r)

when dbarsym,kforsym,kforallsym then
serror("READLISTCOMP")
else
	serror("(x ...")
esac
return nil
end

proc addlistunit(ref ref unitrec ulist,ulistx,unit p)=
if ulist^=nil then		!first
	ulist^:=ulistx^:=p
else
	ulistx^^.nextunit:=p
fi
ulistx^:=p			!update end-of-list pointer
end

proc addlistparam(ref ref strec ulist,ulistx,ref strec p)=
if ulist^=nil then		!first
	ulist^:=ulistx^:=p
else
	ulistx^^.nextparam:=p
fi
ulistx^:=p			!update end-of-list pointer
end

function readlsqbrack:ref unitrec=			!READLSQBRACK
ref unitrec ulist,ulistx, p,q

lex()
ulist:=ulistx:=nil

case lx.symbol
when rsqsym then			!empty set
	lex()
	p:=createunit1(j_makesetlist,nil)
	if not checkdict(p) then
		checkconstlist(p)
	fi
	return p
when colonsym then			!empty dict
	lex()
	checksymbol(rsqsym)
	lex()
	p:=createunit1(j_makedict,nil)
	return p

esac

do
	addlistunit(&ulist,&ulistx,readexpression())
	skipsemi()
	exit when lx.symbol<>commasym
	lex()
	if lx.symbol=rsqsym then			!allow ,] ending
		exit
	fi
od
checksymbol(rsqsym)
lex()
p:=createunit1(j_makesetlist,ulist)
if not checkdict(p) then
	checkconstlist(p)
fi
return p
end

function readcast:ref unitrec=			!READCAST
ref unitrec p
int t,opc

t:=readtypespec(nil,0)

case lx.symbol
when atsym,lbracksym then
else						!convert to typeconst
	if t=tvoid then
		p:=createunit0(j_typeval)
	else
		p:=createunit0(j_typeconst)
	fi
	p^.mode:=t
	return p
esac

checkunpackedtype(t)

if lx.symbol=atsym then
	lex()
	opc:=j_typepun
else
	opc:=j_convert
fi
checksymbol(lbracksym)
p:=readlbrack()

if p^.tag=j_makelist then p^.tag:=j_makeconstr fi

p:=createunit1(opc,p)
p^.mode:=t
return p
end

function readopc:ref unitrec=			!READOPC
ref unitrec p,q
int opc,opc2

opc:=lx.subcode
lex()
case opc
when j_add then			!ignore +
	return readterm()
when j_sub then			!convert minus to negate
	opc:=j_neg
when j_min,j_max,j_atan2,j_concat,j_append then	!allow some binary ops to have function format

	checksymbol(lbracksym)
	lex()
	p:=readexpression()
	if lx.symbol=commasym then
		lex()
		q:=readexpression()
		checksymbol(rbracksym)
		lex()
		return createunit2(opc,p,q)
	else
		checksymbol(rbracksym)
		lex()
		case opc
		when j_min then opc2:=j_min1
		when j_max then opc2:=j_max1
		else serror("readopc")
		esac
		return createunit1(opc,p)
	fi
esac

if lx.symbol=assignsym then	!op:=, not normally allowed inside expressions
	serror("op:= not allowed")
fi

p:=createunit1(opc,readterm())
return p
end

function readsprint:ref unitrec=			!READSPRINT
int oldinreadprint,opc,isfprint
ref unitrec pformat, pdev, printlist, printlistx, p

oldinreadprint:=inreadprint
inreadprint:=1
opc:=lx.subcode
lex()
checksymbol(lbracksym)
lex()

case opc
when j_sfprint,j_cprint then
	isfprint:=1
else
	isfprint:=0
esac

printlist:=printlistx:=nil
pformat:=pdev:=nullunit

if lx.symbol=atsym then
	lex()
	pdev:=readexpression()
	if lx.symbol=commasym then lex() else goto finish fi
fi
if isfprint then
	pformat:=readexpression()
	if lx.symbol=commasym then lex() else goto finish fi
fi

if lx.symbol=rbracksym then
	goto finish
fi

do
	if lx.symbol=commasym then		!assume extra comma, meaning nogap
		addlistunit(&printlist,&printlistx,createunit0(j_nogap))
	else
		p:=readexpression()
		if lx.symbol=colonsym then
			lex()
			p:=createunit2(j_fmtitem,p,readexpression())
		fi
		addlistunit(&printlist,&printlistx,p)
	fi
	if lx.symbol<>commasym then exit fi
	lex()
od

checksymbol(rbracksym)

finish::
lex()
inreadprint:=oldinreadprint
if (opc=j_print or opc=j_fprint) and printlist=nil then
	serror("No print items")
fi

if isfprint then
	if pformat^.tag=j_null then
		serror("No fmt str")
	fi
	return createunit3(opc,pdev,pformat,printlist)
else
	return createunit2(opc,pdev,printlist)
fi
end

function readsread:ref unitrec=		!READSREAD
int oldinreadprint,opc
ref unitrec pformat,pdev,p, readlist,readlistx

oldinreadprint:=inreadprint
inreadprint:=1
opc:=lx.subcode
lex()
checksymbol(lbracksym)
lex()

readlist:=readlistx:=nil
pformat:=pdev:=nullunit

if lx.symbol=atsym then
	if opc=j_read then
		serror("@ on read")
	fi
	lex()
	pdev:=readexpression()
	if lx.symbol=commasym then lex() else goto finish fi
fi

if lx.symbol=rbracksym then
	goto finish
fi

do
	p:=readexpression()
	if lx.symbol=colonsym then
		lex()
		p:=createunit2(j_fmtitem,p,readexpression())
	fi
	addlistunit(&readlist,&readlistx,p)
	if lx.symbol<>commasym then exit fi
	lex()
od

checksymbol(rbracksym)

finish::
lex()
inreadprint:=oldinreadprint
if opc=j_read and readlist=nil then
	serror("No read items")
fi

return createunit2(opc,pdev,readlist)
end

function readcompilervar:ref unitrec=		!READCOMPILERVAR
[100]char str
rsystemtime tm
static []ichar monthnames=("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec")

case lx.subcode
when j_cvlineno then
	return createconstunit(lx.lineno,tint)
when j_cvstrlineno then
	getstrint(lx.lineno,&.str)

when j_cvmodulename then
	strcpy(&.str,moduletable[currmoduleno].name)

when j_cvfilename then
	strcpy(&.str,moduletable[currmoduleno].filename)
when j_cvfunction then
	strcpy(&.str,(currproc|currproc^.name|"<none>"))
when j_cvdate then
	os_getsystime(&tm)

	fprint @&.str,"#-#-%#",tm.day,monthnames[tm.month],tm.year:"4"

when j_cvtime then
	os_getsystime(&tm)
	fprint @&.str,"#:#:#",tm.hour:"2",tm.minute:"z2",tm.second:"z2"

else
	serror("compiler not impl")
esac

return createstringconstunit(pcm_copyheapstring(&.str),-1)
end

function readcastx:ref unitrec=			!READCASTX
int opc
ref unitrec pexpr,p
int ptype

lex()
if lx.symbol=atsym then
	lex()
	opc:=j_typepun
else
	opc:=j_convert
fi
checksymbol(lbracksym)
lex()
pexpr:=readexpression()
checksymbol(commasym)
lex()
ptype:=readtypespec(nil,0)
checksymbol(rbracksym)
lex()
p:=createunit1(opc,pexpr)
p^.mode:=ptype
return p
end

global proc checksymbol(int symbol)=
[100]char str

if lx.symbol<>symbol then
	fprint @&.str,"# expected, not #",symbolnames[symbol],symbolnames[lx.symbol]

	serror(&.str)
fi
end

function readtypespec(ref strec owner,int typedefx)int=			!READTYPESPEC

ref strec d
int t,kwd
unit x, lowerx,upperx,lengthx
int p
const maxdim=10
[maxdim]unit lowerdims,lengthdims
int ndims,i,n

case lx.symbol
when lsqsym then		!array bounds
arraybounds::
	lex()
	ndims:=0
	inreadprint:=1
	do
		lowerx:=lengthx:=nil
		if lx.symbol=rsqsym or lx.symbol=commasym then		![]
		else
			x:=readconstexpr(owner,0)			!reduce if possible
			if x^.tag=j_makerange then			![a..b] variable
				lowerx:=x^.a
				upperx:=x^.b
				if lowerx^.tag=j_const and upperx^.tag=j_const then
					lengthx:=createconstunit(upperx^.value-lowerx^.value+1,tint)
				else
					lengthx:=createunit2(j_sub,upperx,lowerx)
					lengthx:=createunit2(j_add,lengthx,createconstunit(1,tint))
				fi
			else
				case lx.symbol
				when rsqsym,commasym then			![n]
					lengthx:=x
				when colonsym then				!a:n
					lowerx:=x
					lex()
					if not (lx.symbol=commasym or lx.symbol=rsqsym) then
						lengthx:=readconstexpr(owner)
					fi
				esac
			fi
		fi
		lowerdims[++ndims]:=lowerx
		lengthdims[ndims]:=lengthx
		exit when lx.symbol<>commasym
		lex()
	od
	inreadprint:=0
	checksymbol(rsqsym)
	lex()
	t:=readtypespec(owner,0)
	checkpackedtype(t)
	for i:=ndims downto 1 do
		t:=createarraymode(owner,t,lowerdims[i],lengthdims[i],(i=1|typedefx|0))
	od
	return t

when stdtypesym then
	t:=lx.subcode
	lex()
	case t
	when tstring,tset,tstringz then
		if lx.symbol=opsym and lx.subcode=j_mul then
			lex()
			p:=createstringmode(owner,t,readconstexpr(owner),typedefx)
		else
			p:=t
		fi
	else
		p:=t	!createtype(t)	!use code as it is
	esac

when namesym then
	d:=lx.symptr
	lex()
	if lx.symbol=dotsym then
		lex()
		checksymbol(namesym)
		p:=newusertypex(d,lx.symptr)
		lex()
	else
		p:=newusertypex(d)
	fi

when kvarsym then		!'var' or 'variant' used as typespec, rather than decl keyword
	p:=tvariant
	lex()

when kenumsym then		!enum
	lex()
	p:=readenumtype(owner,typedefx)

when lbracksym then
	p:=readenumtype(owner,typedefx)

when krecordsym then
	serror("Use 'record name=', not 'type name=record'")

when kstructsym then
	kwd:=lx.symbol
	lex()
	if lx.symbol=datsym then
		if owner=nil then serror("record@@") fi
		lex()
		checksymbol(intconstsym)
		case lx.value
		when 1,2,4,8,16 then
		else
			serror("record@@ bad align")
		esac
		owner^.attribs.ax_align:=lx.value
		lex()
	fi
	p:=readstructdef(owner,typedefx,kwd)

when kunionsym then
	serror("Top-level union not allowed")

when krefsym then		!ref T
	lex()
	case lx.symbol
	when kprocsym,kfunctionsym,kmethodsym then	!function pointer being created
		serror("CAN'T DO REF PROC")
	else						!assume normal type
		t:=readtypespec(owner,0)
	esac
	p:=createrefpackmode(owner,t,typedefx)

else
	serror("Bad type starter")
esac
return p
end

function readhostparams(ref unitrec lhs,int isfn)ref unitrec=		!READHOSTPARAMS
int fnindex,oldinrp
ref unitrec p,q

fnindex:=lx.subcode
lex()
checksymbol(lbracksym)
lex()
oldinrp:=inreadprint
inreadprint:=0
q:=readslist(1,1)

checksymbol(rbracksym)
lex()
inreadprint:=oldinrp

if lhs then
	lhs^.nextunit:=q
	q:=lhs
fi

p:=createunit1((isfn|j_callhostfn|j_callhostproc),q)
p^.opcode:=fnindex

return p
end

function readslist(int iscall=0,donulls)ref unitrec=		!READSLIST
ref unitrec ulist,ulistx
int oldinparamlist

ulist:=ulistx:=nil

skipsemi()
if lx.symbol=rbracksym then		!empty list
	return ulist
fi

oldinparamlist:=inparamlist
inparamlist:=iscall

do
	skipsemi()
	case lx.symbol
	when commasym then
		if donulls then
			addlistunit(&ulist,&ulistx,createunit0(j_null))
		else
			serror("null comma expr not allowed")
		fi
		lex()
	when rbracksym then
		if donulls then
			addlistunit(&ulist,&ulistx,nullunit)
		fi
		exit
	else
		addlistunit(&ulist,&ulistx,readexpression())
		if lx.symbol=commasym then
			lex()
			if lx.symbol=rbracksym then
				exit
			fi
		else
			if lx.symbol=semisym and nextlx.symbol=rbracksym then
				lex()
			fi
			exit
		fi
	esac
od
inparamlist:=oldinparamlist

return ulist
end

function readindex(ref unitrec p,int dot)ref unitrec=		!READINDEX
ref unitrec q

lex()

do
	if ndollar>=maxdollarstack then
		serror("Too many nested a[$]")
	fi
	dollarstack[++ndollar]:=p
	q:=readexpression()
	--ndollar

	if q^.tag=j_makerange then		!convert into a discrete slice
		p:=createunit2((dot|j_dotslice|j_slice),p,q)
	else
		p:=createunit2((dot|j_dotindex|j_index),p,q)
	fi
	exit when lx.symbol<>commasym
	lex()
od
checksymbol(rsqsym)
lex()
return p
end

function readkeyindex(ref unitrec p,int dot)ref unitrec =		!READKEYINDEX
ref unitrec q,r

lex()

q:=readexpression()
r:=nil
if lx.symbol=commasym then		!default value follows
	lex()
	r:=readexpression()
fi
checksymbol(rcurlysym)
lex()
return p:=createunit3((dot|j_dotkeyindex|j_keyindex),p,q,r)
end

function readdotsuffix(ref unitrec p)ref unitrec=		!READDOTSUFFIX
ref unitrec q
int t

while lx.symbol=dotsym do
	lex()
	switch lx.symbol
	when lsqsym then
		p:=readindex(p,1)
	when lcurlysym then
		p:=readkeyindex(p,1)
	when namesym then
		p:=createunit2(j_dot,p,createname(lx.symptr))
		lex()
	when opsym then			!ought to check whether op is allowed in this form
		p:=createunit1(lx.subcode,p)
		lex()
	when lbracksym then			!use for variable attributes
		lex()
		p:=createunit2(j_dotattr,p,readexpression())
		checksymbol(rbracksym)
		lex()
	when ktypesym then			!.type, convert to .gettype
		case p^.tag
		when j_typeconst then			!int.type=>int

		when j_typeval then			!void/none.type => void/none
			p^.tag:=j_typeconst
		else
			p:=createunit1(j_gettype,p)
		esac
		lex()
	when khostfnsym then
		p:=readhostparams(p,1)

	when stdtypesym then
		t:=lx.subcode
		lex()
		checksymbol(lsqsym)
		lex()
		q:=readexpression()
		checksymbol(rsqsym)
		lex()
		case t
		when tu8,tu16,tu32 then
		else
			serror("Bad .type[]")
		esac
		p:=createunit2(j_byteindex,p,q)
		p^.mode:=t
	else
		serror("Unknown dot suffix")
	endswitch
od
return p
end

global function isconstexpr(ref unitrec p)int=		!ISCONSTEXPR
return p^.tag=j_const
end

function readconstexpr(ref strec owner,int needconst=1)ref unitrec=
ref unitrec p

p:=readexpression()
return p
end

function readconstexprvalue(ref strec owner)int64=
unit p
p:=readexpression()

if p^.tag<>j_const then
	serror("RCEV:Not const expr")
fi
return getconstvalue(p)
end

function readconstint:int=		!READCONSTINT
int64 x

if lx.symbol=intconstsym then
	x:=lx.value
	lex()
	return x
fi
serror("Can't do complex expr")
return 0
end

proc readprocdef(ref strec procowner,int isglobal,fflang=0)=
int kwd,startline,closesym
ref strec stproc,q

kwd:=lx.symbol
stproc:=readprocdecl(procowner,isglobal,fflang)

checkequals()
lex()

startline:=getcurrline()
closesym:=checkbegin(0)

currproc:=stproc
nextavindex:=0

stproc^.code:=readblock(stproc)

if docstring^.length then
	currproc^.docstring:=docstring^.strptr
	gs_init(docstring)
fi

checkbeginend(closesym,kwd,startline)
stproc^.attribs.ax_equals:=1

currproc:=nil
end

global function readprocdecl(ref strec procowner,int isglobal,fflang)ref strec=

int kwd,varparams,try_level, prettype, nparams
ichar metadata, truename
ref strec pequiv, stproc, owner, paramlist,nameptr

kwd:=lx.symbol				!remember keyword
pequiv:=nil
metadata:=""
truename:=nil
varparams:=0
try_level:=0

lex()

if lx.symbol=stringconstsym then		!assume dll truename
	truename:=pcm_copyheapstring(lx.svalue)
	convlcstring(lx.svalue)
	lx.symptr:=addnamestr(lx.svalue)
else
	checksymbol(namesym)
fi

nameptr:=lx.symptr

stproc:=createprocdef(procowner,nameptr,(currimport|dllprocid|procid),truename)

if getscope(procowner)<>importscope and procowner^.nameid=typeid then
	addgenfield(nameptr)				!defining a method in a class
fi

owner:=stproc
currproc:=stproc

lex()
if lx.symbol=namesym and eqstring(lx.symptr^.name,"as") then
	lex()
	checksymbol(namesym)
	addalias(stproc,lx.symptr)
	lex()
fi

paramlist:=nil
prettype:=tvoid
nparams:=0

if lx.symbol=opsym and lx.subcode=j_lt then			!look for metadata
	if stproc^.nameid=dllprocid then
		serror("Metadata on dllproc")
	fi
	lex()
	checksymbol(stringconstsym)
	stproc^.metadata:=lx.svalue

	lex()
	unless lx.symbol=opsym and (lx.subcode=j_gt or lx.subcode=j_ge) then
		serror(""">"" expected")
	end
	if lx.symbol=opsym and lx.subcode=j_ge then	!>= must become just =
		lx.subcode:=j_eq
	else
		lex()
	fi
fi

if lx.symbol=lbracksym then		!possible params
	lex()
	if lx.symbol<>rbracksym then
		if fflang=0 or fflang=qlangff then
			varparams:=0
			paramlist:=readparams(stproc,nparams)
		else
			paramlist:=readparamsff(procowner,stproc,varparams,nparams)
		fi
		checksymbol(rbracksym)
	fi
	lex()
	if lx.symbol=colonsym or lx.symbol=sendtosym then
		lex()
		prettype:=readtypespec(owner,0)
	elsif typestarterset[lx.symbol] or lx.symbol=namesym then
		prettype:=readtypespec(owner,0)
	fi
elsif lx.symbol=colonsym or lx.symbol=sendtosym then
	lex()
	prettype:=readtypespec(owner,0)
fi

unless prettype<>tvoid or (kwd<>kfunctionsym and kwd<>kmethodsym) then		!function: no result given
	prettype:=tvariant
endunless

if prettype<>tvoid and (kwd<>kfunctionsym and kwd<>kmethodsym) then		!proc: result given
	serror("Proc can't return value")
fi

if prettype<>tvoid and fflang<>0 and fflang<>qlangff then
	checkdlltype(prettype)
elsif prettype<>tvoid and (fflang=0 or fflang=qlangff) then
	checkunpackedtype(prettype)
fi

stproc^.paramlist:=paramlist

stproc^.attribs.ax_nparams:=nparams

stproc^.mode:=prettype

if lx.symbol=atsym then			!equivalence
	lex()
	checksymbol(namesym)
	lex()
	stproc^.attribs.ax_at:=1
fi

stproc^.code:=nil

case fflang
when clangff,windowsff,mlangff then
	if currimport=nil then
		cpl stproc^.name
		serror("FF should be in dll import")
	fi
else			!assume this language
	case procowner^.nameid
	when moduleid then
	when dllmoduleid then
		serror("Need FF specifier")
	esac
esac

if currimport then isglobal:=1 fi

stproc^.attribs.ax_global:=isglobal


stproc^.attribs.ax_varparams:=varparams
stproc^.attribs.ax_fflang:=fflang

if procowner=stmodule and
	(stproc^.namelen=5 and eqstring(stproc^.name,"start")) or
	(stproc^.namelen=4 and eqstring(stproc^.name,"main")) then
	stproc^.attribs.ax_global:=1
fi

return stproc
end

function readparams(ref strec owner,int &nparams)ref strec=
ref strec stlist, stlistx, stname, d
int foptional, fbyref

[30]char str
stlist:=stlistx:=nil
foptional:=0
fbyref:=0
stname:=nil
nparams:=0

do
	switch lx.symbol
	when questionsym then
		if foptional then serror("??") fi
		lex()
		foptional:=1
	when addrsym then
		if fbyref then serror("& &") fi
		lex()
		fbyref:=1
	when namesym then
		++nparams
		stname:=getduplnameptr(owner,lx.symptr,paramid)
		adddef(owner,stname)
		stname^.mode:=tvariant
		addlistparam(&stlist,&stlistx,stname)

		lex()
		case lx.symbol
		when assignsym then
			lex()
			stname^.code:=readexpression()
			stname^.attribs.ax_equals:=1

		when opsym then
			if lx.subcode<>j_eq then
				serror("param op?")
			fi
			lex()
			foptional:=1
			stname^.code:=readexpression()
		esac
		if fbyref then stname^.attribs.ax_byrefmode:=1 fi
		if foptional then stname^.attribs.ax_optional:=1 fi

	when rbracksym then
		exit
	when commasym then
		fbyref:=foptional:=0
		lex()

	else
		cpl symbolnames[lx.symbol]
		serror("param")
	end switch
od

return stlist
end

function readparamsff(ref strec procowner,owner,int &varparams,&nparams)ref strec=

int pmode

if typestarterset[lx.symbol] then
	pmode:=readtypespec(procowner,0)
elsif lx.symbol=namesym then			!user type
	pmode:=readtypespec(procowner,0)
else
	serror("Readparams/type expected")
fi

if lx.symbol in [namesym,addrsym] then			!type+names
	return readparamsff_names(pmode,procowner,owner, varparams,nparams)
else
	return readparamsff_types(pmode,procowner,owner, varparams,nparams)
fi
end

function readparamsff_types(int pmode,ref strec procowner,owner,int &varparams,&nparams)ref strec=
ref strec stlist, stlistx, stname
[30]char str

stlist:=stlistx:=nil
varparams:=0
goto gottype

do
	if typestarterset[lx.symbol] then
		pmode:=readtypespec(procowner,0)
	elsif lx.symbol=namesym then			!user type
		pmode:=readtypespec(procowner,0)
	else
		serror("Readparams/type expected")
	fi

gottype::
	checkdlltype(pmode)
	++nparams
	print @&.str,"$",,nparams
	stname:=getduplnameptr(owner,addnamestr(&.str),paramid)
	adddef(owner,stname)
	storemode(owner,pmode,&stname^.mode)
	addlistparam(&stlist,&stlistx,stname)

	case lx.symbol
	when commasym then
		lex()					!prepare for next type
		if lx.symbol=ellipsissym then
			varparams:=1
			lex()
			checksymbol(rbracksym)
			exit
		fi
	when rbracksym then
		exit
	else
		serror("ffparams/types")
	esac
od
return stlist
end

function readparamsff_names(int pmode,ref strec procowner,owner,int &varparams,&nparams)ref strec=
ref strec stlist, stlistx, stname
int m,fbyref

stlist:=stlistx:=nil
varparams:=0

do
	checkdlltype(pmode)

	do									!loop on names
		fbyref:=0
		if lx.symbol=addrsym then
			lex()
			fbyref:=1
		fi

		if lx.symbol<>namesym then serror("Params: name expected") fi
		++nparams
		stname:=getduplnameptr(owner,lx.symptr,paramid)
		adddef(owner,stname)
		if fbyref then
			m:=createrefpackmode(procowner,pmode,0)
			stname^.attribs.ax_byrefmode:=1
		else
			m:=pmode
		fi
		storemode(owner,m,&stname^.mode)
		addlistparam(&stlist,&stlistx,stname)
		lex()

		case lx.symbol
		when assignsym then
doexpr::
			lex()
			stname^.code:=readexpression()
			stname^.attribs.ax_equals:=1
			stname^.attribs.ax_optional:=1
		when opsym then
			if lx.subcode<>j_eq then serror("param op?") fi
			goto doexpr
		esac

		case lx.symbol
		when commasym then
			lex()					!prepare for next type or name
		when rbracksym then
			exit all
		esac

		case lx.symbol
		when addrsym then			!param name next
		when ellipsissym then
			if lx.symbol=ellipsissym then
				varparams:=1
				lex()
				checksymbol(rbracksym)
				exit all
			fi
		when namesym then			!param name or type
			if nextlx.symbol in [namesym, addrsym] then		!assume usertype
				pmode:=readtypespec(procowner,0)
			fi
		elsif typestarterset[lx.symbol] then
			pmode:=readtypespec(procowner,0)
			exit
		else
			serror("ffparams/types")
		esac
	od
od
return stlist
end

function readblock(ref strec owner)ref unitrec=
int lineno,globalflag
ref unitrec ulist,ulistx,p

skipsemi()

lineno:=lx.lineno
ulist:=ulistx:=nil

do
	switch lx.symbol
	when kstaticsym then
		lex()
		checksymbol(kvarsym)
		readvardef(owner,0,1,staticid)

	when kprocsym,kfunctionsym,kmethodsym then	!todo
		readprocdef(owner,0)
		globalflag:=0

	when kvarsym then
		readvardef(owner,0,0,frameid)

	when ktypesym then
		readtypedef(owner,0)

	when kconstsym then
		readconstdef(owner,0)

	when kclasssym,krecordsym then
		readclassdef(owner,globalflag)
		globalflag:=0

	when docstringsym then
		gs_strn(docstring,lx.svalue,lx.length)
		gs_line(docstring)
		lex()

	when kenumsym then		!enum
		lex()
		readenumtype(owner,0)

	when eofsym then
		cpl owner^.name
		serror("Unexpected EOF in proc")

	when rbracksym,kelsifsym,kelsesym,kuntilsym,kwhensym,
			kelsecasesym,kelseswitchsym,kexceptsym,kendsym,rcurlysym then
		exit

	when semisym then
		lex()

	else							!assume a statement
		p:=readexecstmt(owner)
		if int64(p)=1 or p=nil then
			serror("READEXEC RETURNED 1 OR NIL")
		fi
		addlistunit(&ulist,&ulistx,p)
	endswitch
od

return createunit1(j_block,ulist)
end

function readexecstmt(ref strec owner)ref unitrec=
ref unitrec p,q
ref strec stname

switch lx.symbol
when namesym then
	case nextlx.symbol
	when colonsym then
		stname:=getduplnameptr(currproc,lx.symptr,labelid)
		adddef(currproc,stname)


		p:=createunit0(j_labeldef)
		p^.def:=stname
		p^.trylevel:=try_level
		stname^.offset:=try_level
		setnameptr(p)
		lex()
		lx.symbol:=semisym

	else
		p:=readstmtexpr(owner)
	esac
when kgotosym then
	p:=readgoto(owner)

when kifsym then
	p:=readif(owner)

when kunlesssym then
	p:=readunless(owner)

when kcasesym,kswitchsym then
	p:=readswitchcase(owner)

when kdocasesym,kdoswitchsym then
	p:=readswitchcase(owner)

when kforsym then
	p:=readfor(owner)

when kforallsym then
	p:=readforall(owner)

when ktosym then
	p:=readto(owner)

when kdosym then
	p:=readdo(owner)

when kwhilesym then
	p:=readwhile(owner)

when krepeatsym then
	p:=readrepeat(owner)

when kloopsym then
	p:=readloopcontrol(owner)

when kreturnsym then
	p:=readreturn(owner)

when kstopsym then
	p:=readstop(owner)

when kprintsym then
	p:=readprint(owner)

when kreadsym then
	p:=readread(owner)

when ktrysym then	!todo
	p:=readtry(owner)

when kraisesym then	!todo
	p:=readraise(owner)

when opsym then
	if lx.subcode=j_mul and nextlx.symbol=lbracksym then
		serror("KTERM?")
	else
		p:=readstmtexpr(owner)
	fi

when kswapsym then			!swap using function syntax
	lex()
	checksymbol(lbracksym)
	lex()
	p:=readexpression()
	checksymbol(commasym)
	lex()
	q:=readexpression()
	checksymbol(rbracksym)
	lex()
	p:=createunit2(j_swap,p,q)

when lbracksym,incrsym,ksreadsym,ksreadlnsym,kapplsym then
	p:=readstmtexpr(owner)

when khostfnsym then
	p:=readhostparams(nil,0)

when kevalsym then
	lex()
	p:=createunit1(j_eval,readexpression())


else
	cpl symbolnames[lx.symbol]
	serror("Stmt error")
endswitch

return p
end

function readstmtexpr(ref strec owner)ref unitrec=
int opc
ref unitrec p,q,ulist,ulistx

if lx.symbol=opsym and nextlx.symbol=assignsym then		!negto combination
	opc:=lx.subcode
	case opc
	when j_sub then opc:=j_neg
	esac

	lex()				!skip :=
	lex()
	return createunit1(getoptocode(opc),readterm())			!op:=term
fi

p:=readterm()

	case p^.tag
	when j_preincrx then p^.tag:=j_preincr
	when j_predecrx then p^.tag:=j_predecr
	when j_postincrx then p^.tag:=j_postincr
	when j_postdecrx then p^.tag:=j_postdecr
	esac

case lx.symbol
when assignsym then
	lex()				!skip :=
	q:=readexpression()
	p:=createunit2(j_assign,p,q)			!term:=expr
	return readcondsuffix(p)

when deepcopysym then
	lex()				!skip ::=
	q:=readexpression()
	p:=createunit2(j_deepcopy,p,q)			!term::=expr
	return readcondsuffix(p)
when opsym then
	if nextlx.symbol=assignsym then					!term op:=expr
		opc:=getoptocode(lx.subcode)
		lex()				!skip :=
		lex()				!first part of rhs expr
		return createunit2(opc,p,readexpression())			!term op:=expr
	else
		serror("op expr not allowed as statement")			!presumably a full expression;
	fi								! not allowed in this context
when kswapsym then
	lex()
	return createunit2(j_swap,p,readterm())			!term swap term
when commasym then
	ulist:=ulistx:=p
	inmultexpr:=1
	repeat
		lex()					!skip comma
		addlistunit(&ulist,&ulistx,readexpression())
	until lx.symbol<>commasym
	inmultexpr:=0

	p:=createunit1(j_multexpr,ulist)
	checksymbol(assignsym)
	lex()
	q:=readexpression()
	if lx.symbol<>commasym then
		serror("mult-expr expected after :=")
	fi
	ulist:=ulistx:=q
	repeat
		lex()					!skip comma
		addlistunit(&ulist,&ulistx,readexpression())
	until lx.symbol<>commasym
	q:=createunit1(j_multexpr,ulist)
	p:=createunit2(j_assign,p,q)
	return p
esac

case p^.tag
when j_assignx then
	p^.tag:=j_assign
when j_deepcopyx then
	p^.tag:=j_deepcopy
when j_callfn then
	p^.tag:=j_callproc
	p:=readcondsuffix(p)
when j_callapplfn then
	p^.tag:=j_callapplproc
	p:=readcondsuffix(p)
when j_callmfn then
	p^.tag:=j_callmproc
	p:=readcondsuffix(p)
else
	case p^.tag
	when j_preincr,j_predecr,j_postincr,j_postdecr,j_callproc,j_callapplproc,
		  j_sread,j_sreadln then
	else
		cpl jtagnames[p^.tag]
		serror("Expression not allowed as statement")
	esac
esac

return p			!assume p is a bona fide term
end

function readcondsuffix(ref unitrec p)ref unitrec=			!READCONDSUFFIX

case lx.symbol
when kifsym,kwhensym then
	lex()
	return createunit2(j_if,readexpression(),createunit1(j_block,p))
when kunlesssym then
	lex()
	return createunit2(j_if, createunit1(j_notl,readexpression()),createunit1(j_block,p))
else
	return p
esac
return nil
end

function readif(ref strec owner)ref unitrec=	!READIF
int line, kwd, lineno
ref unitrec pthen,pcond, plist,plistx, pelse, p, pelsif

line:=lx.lineno

kwd:=lx.symbol			!in case coming from elsecase etc

lex()
pcond:=readexpression()
skipsemi(); checksymbol(kthensym)
lex()

pthen:=readblock(owner)

if lx.symbol=kelsifsym then
	lineno:=lx.lineno
	plist:=plistx:=createunit2(j_elsif,pcond,pthen)

	while lx.symbol=kelsifsym do
		lineno:=lx.lineno
		lex()
		pcond:=readexpression()
		checksymbol(kthensym)
		lex()
		pthen:=readblock(owner)
		pelsif:=createunit2(j_elsif,pcond,pthen)
		pelsif^.lineno:=lineno
		addlistunit(&plist,&plistx,pelsif)

	od

	case lx.symbol
	when kelsesym then		!get r=any else stmt or nil
		lex()
		pelse:=readblock(owner)
		checkend(kendsym,kwd,0)
		lex()
	when kelsecasesym,kelseswitchsym then
		lx.symbol:=kwd
		pelse:=makeblock(readswitchcase(owner))
	else
		pelse:=createunit0(j_block)
		checkend(kendsym,kwd,0)
		lex()
	esac

	p:=createunit2(j_longif,plist,pelse)
	p^.lineno:=line
	return p
fi

case lx.symbol
when kelsesym then		!get r=any else stmt or nil
	lex()
	pelse:=readblock(owner)
	checkend(kendsym,kwd)
	lex()
else
	pelse:=createunit0(j_block)
	checkend(kendsym,kwd)
	lex()
esac

p:=createunit3(j_if,pcond,pthen,pelse)
p^.lineno:=line
return p
end

function readgoto(ref strec owner,int gototag=j_goto)ref unitrec=	!READGOTO
ref strec d
ref unitrec p

if lx.subcode=1 then		!go used
	lex()
	checksymbol(ktosym)
fi
lex()

p:=readexpression()

return readcondsuffix(createunit1(gototag,p))
end

function readunless(ref strec owner)ref unitrec=	!READUNLESS
int line
ref unitrec pcond, pthen, pelse, p
line:=lx.lineno
lex()
pcond:=readexpression()
checksymbol(kthensym)
lex()

pthen:=readblock(owner)

if lx.symbol=kelsesym then
	lex()
	pelse:=readblock(owner)
else			!assume simple if-then
	pelse:=createunit0(j_block)
fi
checkend(kendsym,kunlesssym)
lex()
p:=createunit3(j_if,createunit1(j_notl,pcond),pthen,pelse)
p^.lineno:=line
return p
end

function readswitchcase(ref strec owner)ref unitrec=	!READSWITCHCASE
int line, kwd, opc, lineno
ref unitrec pexpr,pwhenlist,pwhenlistx,pwhen,pwhenx,pelse,p,pthen,pwhenthen,q

line:=lx.lineno
kwd:=lx.symbol			!remember kcasesym etc
opc:=lx.subcode			!pick up tag: kcase etc

lex()
pexpr:=readexpression()		!index expression

pwhenlist:=pwhenlistx:=nil

skipsemi()
while lx.symbol=kwhensym do	!read list of when-then pairs
	lineno:=lx.lineno
	lex()
	pwhen:=pwhenx:=nil
	do
		p:=readexpression()
		p^.lineno:=lineno
		addlistunit(&pwhen,&pwhenx,p)
		if lx.symbol<>commasym then exit fi
		lex()
	od
	checksymbol(kthensym)
	lex()
	pthen:=readblock(owner)
	pwhenthen:=createunit2(j_whenthen,pwhen,pthen)
	pwhenthen^.lineno:=lineno
	addlistunit(&pwhenlist,&pwhenlistx,pwhenthen)
od

case lx.symbol
when kelsesym then		!get r=any else stmt or nil
	lex()
	pelse:=readblock(owner)

	checkend(kendsym,kwd)
	lex()
when kelsifsym then
	lx.symbol:=kwd
	pelse:=makeblock(readif(owner))
when kelsecasesym, kelseswitchsym then
	lx.symbol:=kwd
	pelse:=makeblock(readswitchcase(owner))
else
	pelse:=makeblock(nil)
	checkend(kendsym,kwd)
	lex()
esac

p:=createunit3(opc,pexpr,pwhenlist,pelse)
p^.lineno:=line
return p
end

function readstop(ref strec owner)ref unitrec=	!READSTOP
ref unitrec p
int i
lex()
if exprstarterset[lx.symbol] then
	p:=createunit1(j_stop,readexpression())
else
	p:=createunit0(j_stop)
fi
return readcondsuffix(p)
end

function readreturn(ref strec owner)ref unitrec=	!READRETURN
ref unitrec p

lex()
if exprstarterset[lx.symbol] then
	p:=createunit1(j_return,readexpression())
else
	p:=createunit0(j_return)
fi

return readcondsuffix(p)
end

function readdo(ref strec owner)ref unitrec=	!READDO
ref unitrec p
int line

line:=lx.lineno
lex()
p:=readblock(owner)
checkend(kendsym,kdosym)
lex()
p:=createunit1(j_do,p)
p^.lineno:=line
return p
end

function readto(ref strec owner)ref unitrec=	!READTO
int line,id
ref unitrec p, pcount, pbody

line:=lx.lineno
lex()
pcount:=readexpression()
checksymbol(kdosym)
lex()
pbody:=readblock(owner)
checkend(kendsym,ktosym,kdosym)
lex()
id:=frameid
if owner^.nameid<>procid then id:=staticid fi

p:=createunit3(j_to,pcount,pbody,createname(getavname(owner,id)))
p^.lineno:=line
return p
end

function readwhile(ref strec owner)ref unitrec=	!READWHILE
int line,id
ref unitrec pcond, pa, pb, pc, pbody, p

line:=lx.lineno
lex()
pcond:=readexpression()

checksymbol(kdosym)
lex()
pbody:=readblock(owner)
checkend(kendsym,kwhilesym,kdosym)
lex()

p:=createunit2(j_while,pcond,pbody)
p^.lineno:=line
return p
end

function readrepeat(ref strec owner)ref unitrec=	!READREPEAT
int line
ref unitrec pbody, pcond, p

line:=lx.lineno
lex()
pbody:=readblock(owner)
checksymbol(kuntilsym)
lex()
pcond:=readexpression()
p:=createunit2(j_repeat,pbody,pcond)
p^.lineno:=line
return p
end

function readloopcontrol(ref strec owner)ref unitrec=	!READLOOPCONTROL
int opc
ref unitrec p

opc:=lx.subcode
lex()
if lx.symbol=namesym and eqstring(lx.symptr^.name,"all") then
	lex()
	p:=createunit1(opc,createconstunit(0,tint))

elsif exprstarterset[lx.symbol] then
	p:=createunit1(opc,readconstexpr(owner,1))
else
	p:=createunit0(opc)
fi
return readcondsuffix(p)
end

function readprint(ref strec owner)ref unitrec=	!READPRINT
int oldinreadprint, opc, isfprint, fshowname, length
ref unitrec pformat, pdev, printlist,printlistx, p,q
ref strbuffer expr

ichar s

oldinreadprint:=inreadprint
inreadprint:=1
opc:=lx.subcode

case opc
when j_fprint,j_fprintln,j_cprint,j_cprintln then
	isfprint:=1
else
	isfprint:=0
esac

lex()

printlist:=printlistx:=nil
pformat:=pdev:=nil

if lx.symbol=atsym then
	lex()
	pdev:=readexpression()
	if lx.symbol=commasym then lex() else goto finish fi
fi
if isfprint then
	if not exprstarterset[lx.symbol] and opc=j_cprintln then
		goto finish
	fi
	pformat:=readexpression()
	if lx.symbol=commasym then lex() else goto finish fi
fi

if not exprstarterset[lx.symbol] then
	goto finish
fi

do
	if lx.symbol=commasym then		!assume extra comma, meaning nogap
		addlistunit(&printlist,&printlistx, createunit0(j_nogap))
	else

		fshowname:=0
		if lx.symbol=opsym and lx.subcode=j_eq then
			fshowname:=1
			lex()
		fi

		p:=readexpression()
		if lx.symbol=colonsym then
			lex()
			p:=createunit2(j_fmtitem,p,readexpression())
		fi
		if fshowname then
			expr:=strexpr(p)
			length:=expr^.length
			strbuffer_add(expr,"=?",-1)
			s:=expr^.strptr
			iconvucn(s,length)
			(s+length+1)^:=0					!? => terminator

			addlistunit(&printlist,&printlistx,q:=createstringconstunit(s,-1))
		fi
		addlistunit(&printlist,&printlistx,p)
	fi
	if lx.symbol<>commasym then exit fi
	lex()
od

finish::
inreadprint:=oldinreadprint
if opc=j_print and printlist=nil then
	serror("No print items")
fi
if opc=j_fprint and printlist=nil and pformat=nil then
	serror("No print items")
fi
if opc=j_cprint and printlist=nil and pformat=nil then
	serror("No cprint items")
fi

if isfprint then
	if pformat=nil and opc<>j_cprintln then
		serror("No fmt str")
	fi
	return createunit3(opc,pdev,pformat,printlist)
else
	return createunit2(opc,pdev,printlist)
fi
end

function readread(ref strec owner)ref unitrec=	!READREAD
int oldinreadprint,opc
ref unitrec pformat, pdev, readlist, readlistx, p

oldinreadprint:=inreadprint
inreadprint:=1
opc:=lx.subcode
lex()

readlist:=readlistx:=nil
pformat:=pdev:=nil

if lx.symbol=atsym then
	if opc=j_read then
		serror("@ on read")
	fi
	lex()
	pdev:=readexpression()
	if lx.symbol=commasym then lex() else goto finish fi
fi

if not exprstarterset[lx.symbol] then
	goto finish
fi

do
	p:=readexpression()
	if lx.symbol=colonsym then
		lex()
		p:=createunit2(j_fmtitem,p,readexpression())
	fi
	addlistunit(&readlist,&readlistx,p)
	if lx.symbol<>commasym then exit fi
	lex()
od

finish::
inreadprint:=oldinreadprint
if opc=j_read and readlist=nil then
	serror("No read items")
fi

return createunit2(opc,pdev,readlist)
end

function readtry(ref strec owner)ref unitrec=	!READTRY
ref unitrec ptry, pexceptlist, pexceptlistx, px, q, exlist,exlistx

++try_level
lex()

ptry:=readblock(owner)
pexceptlist:=pexceptlistx:=nil			!list of j_except items

while lx.symbol=kexceptsym do
	lex()
	exlist:=exlistx:=nil				!list of exception codes for this 'except'
	do
		addlistunit(&exlist,&exlistx,readconstexpr(owner))
		if lx.symbol<>commasym then exit fi
		lex()
	od
	checksymbol(kthensym)
	lex()
	px:=readblock(owner)
	addlistunit(&pexceptlist,&pexceptlistx,createunit2(j_except,exlist,px))
od
checkend(kendsym,ktrysym)
lex()

--try_level

return createunit2(j_try,ptry,pexceptlist)
end

function readraise(ref strec owner)ref unitrec=	!READRAISE
ref unitrec p

lex()
p:=readexpression()
return createunit1(j_raise,p)
end

function readfor(ref strec owner)ref unitrec=	!READFOR

int line, opc, down
ref unitrec pstep, pvar, pcond, pfrom, pto, pelse, prange, prangex, pautovar, pbody, p
ref strbuffer S

line:=lx.lineno
lex()			!skip 'for'
pvar:=readterm()

if pvar^.tag<>j_name then
	serror("For: name expected")
fi

opc:=j_forup
pstep:=nil
pcond:=nil

if lx.symbol=opsym then	!assume in/inrev
	if lx.subcode=j_inrev then
		down:=j_fordown
	elsif lx.subcode<>j_in then
		serror("in/inrev expected")
	fi
	lex()
	prange:=readexpression()

	pfrom:=getrangelwbunit(prange)
	pto:=getrangeupbunit(prange)

else
	if lx.symbol=assignsym then
		lex()
		pfrom:=readexpression()
	else
		pfrom:=createconstunit(1,tint)
	fi
	checksymbol(ktosym)
	opc:=(lx.subcode=1|j_fordown|j_forup)
	lex()
	pto:=readexpression()

	if lx.symbol=kbysym then
		if opc=j_fordown then
			serror("downto/by")
		fi
		opc:=j_forstep
		lex()
		pstep:=readconstexpr(owner,0)
		if pstep^.tag=j_const and pstep^.value=1 then		!by 1
			opc:=j_forup
			pstep:=nil
		elsif pstep^.tag=j_const and pstep^.value=-1 then	!by -1
			opc:=j_fordown
			pstep:=nil
		fi

	else
		pstep:=nil
	fi
fi

if lx.symbol=kwhensym then
	lex()
	pcond:=readexpression()
fi
checksymbol(kdosym)
lex()
pbody:=readblock(owner)

if lx.symbol=kelsesym then
	lex()
	pelse:=readblock(owner)
else
	pelse:=nil
fi
checkend(kendsym,kforsym,kdosym)
lex()

if pcond<>nil then
	pbody:=makeblock(createunit2(j_if,pcond,pbody))
fi

pautovar:=nil
unless pto^.tag=j_const or (pto^.tag=j_name and pto^.def^.attribs.ax_frame) then
	if opc=j_forstep then
		serror("for: 'by' uses complex limit")
	fi
	pautovar:=createname(getavname(owner))
end




pvar^.nextunit:=pfrom
pfrom^.nextunit:=pto
pto^.nextunit:=pstep
pbody^.nextunit:=pelse

p:=createunit3(opc,pvar,pbody,pautovar)
p^.lineno:=line
return p
end

function readforall(ref strec owner)ref unitrec=	!READFORALL
int opc, line, isforall
ref unitrec pindex, pvar, pcond, plist, pbody, pelse,p, pfor, pautovar

line:=lx.lineno
opc:=lx.subcode
isforall:=opc=j_forall

lex()			!skip 'forall'
pvar:=readterm()
pindex:=nil

if lx.symbol=commasym then
	lex()
	pindex:=pvar
	pvar:=readterm()
fi

if pvar^.tag<>j_name then
	serror("forall not name")
fi

pcond:=nil

if lx.symbol=opsym and (lx.subcode=j_in or lx.subcode=j_inrev) then
	if lx.subcode=j_inrev then opc:=(opc=j_forall|j_forallrev|j_foreachrev) fi
	lex()
	plist:=readexpression()
else
	serror("in/inrev expected")
fi

if lx.symbol=kwhensym then
	lex()
	pcond:=readexpression()
fi
checksymbol(kdosym)
lex()
pbody:=readblock(owner)

if lx.symbol=kelsesym then
	lex()
	pelse:=readblock(owner)
else
	pelse:=nil
fi
checkend(kendsym,kforallsym,kdosym)
lex()

if pindex=nil then		!need to add auto-var
	pindex:=createname(getavname(owner))
fi

if pcond<>nil then
	pbody:=createunit2(j_if,pcond,pbody)
	pbody^.lineno:=line
fi

pautovar:=createname(getavname(currproc))		!stores limit



pindex^.nextunit:=pvar
pvar^.nextunit:=plist
pbody^.nextunit:=pelse

pfor:=createunit3(opc, pindex, pbody, pautovar)
pfor^.lineno:=line
return pfor
end

global proc readtypedef(ref strec owner,int isglobal=0)=
ref strec sttype,stname
int t,m

lex()
checksymbol(namesym)
stname:=lx.symptr

lex()
checkequals()
lex()

sttype:=nil

if sttype=nil then
	sttype:=getduplnameptr(owner,stname,typeid)
	adddef(owner,sttype)
	m:=createusertype(sttype)
else
	m:=sttype^.mode
fi

t:=readtypespec(sttype,m)		!should return filled-in version of m

sttype^.attribs.ax_global:=isglobal

sttype^.mode:=t
end

function readstructdef(ref strec owner,int typedefx, kwd)int=
int m,startline,closesym, t
ref strec recordowner, d

recordowner:=owner
if not typedefx then			!informal declaration
	if lx.symbol=namesym then		!name provided
		owner:=getduplnameptr(owner,lx.symptr,typeid)
		lex()
		checkequals()
		lex()
	else
		owner:=getduplnameptr(stmodule,addnamestr(nextautotype()),typeid)
	fi
	adddef(recordowner,owner)
	checksymbol(lbracksym)
	lex()
else
	owner:=ttnamedef[typedefx]
	startline:=getcurrline()
	closesym:=checkbegin(1)
fi

m:=createrecordmode(owner,tstruct,typedefx)
owner^.mode:=m

unionstr_clear(&unionstring)
unionstr_clear(&unionpend)

do
	case lx.symbol
	when kstructsym,kunionsym then
		unionstr_append(&unionpend,(lx.symbol=kstructsym|'S'|'U'))
		unionlastvar:=nil
		lex()
	when kendsym then
		if unionstring.ulength then
			checkend(kendsym,(unionstr_last(&unionstring)='S'|kstructsym|kunionsym))
			lex()
			if unionlastvar=nil or unionpend.ulength then
				serror("Empty union group")
			fi
			case unionstr_last(&unionlastvar^.uflags)
			when 'E','*' then
			else
				unionstr_append(&unionlastvar^.uflags,'*')
			esac
			unionstr_append(&unionlastvar^.uflags,'E')
			unionstring.ulength--
		else
			exit
		fi
	when semisym then
		lex()
	else
		if typestarterset[lx.symbol] or lx.symbol=namesym then
			t:=readtypespec(owner,0)
			readstructfields(owner,t)
		else
			exit
		fi
	esac
od

if not typedefx then
	checksymbol(rbracksym)
	lex()
else
	checkbeginend(closesym,kwd,startline)
fi

return m
end

global proc readstructfields(ref strec owner,int m)=
int nvars
ref strec stname

nvars:=0
while lx.symbol=namesym do

	stname:=getduplnameptr(owner,lx.symptr,fieldid)
	storemode(owner,m,&stname^.mode)
	++nvars

	if unionpend.ulength then
		unionstr_copy(&stname^.uflags,&unionpend)
		unionstr_concat(&unionstring,&unionpend)
		unionstr_clear(&unionpend)
	else
		unionstr_clear(&stname^.uflags)
	fi
	unionlastvar:=stname			!filled in from outside with 'E' codes
	if getscope(owner)<>importscope then
		addgenfield(lx.symptr)
	fi

	adddef(owner,stname)

	lex()

	if lx.symbol=atsym then
		lex()
		stname^.attribs.ax_at:=1
		stname^.equiv:=readequivfield(owner)

	elsif lx.symbol=datsym then
		lex()
		checksymbol(intconstsym)
		case lx.value
		when 1,2,4,8 then
			stname^.attribs.ax_align:=lx.value
		when 0 then
			stname^.attribs.ax_align:=255
		else
			serror("@@ bad align")
		esac
		lex()	
	fi

	if lx.symbol<>commasym then
		exit
	fi
	lex()
od

if nvars=0 then
	serror("No fields declared")
fi
end

global proc readtabledef(ref strec owner,int isglobal=0)=
int i,ncols,nrows,enums,nextenumvalue,firstval,lastval,startline,closesym,vartype
ref unitrec plower
ichar enumtypename
ref strec stvar,stenum,stgen
const maxcols=20
[maxcols]ref strec varnameptrs
[maxcols]unit plist,plistx
const maxrows=500
[maxrows]int enumvalues

lex()
enums:=0						!whether there is an enums column
enumtypename:=nil

if lx.symbol=lbracksym then		!tabledate(...) read enum type
	enums:=1
	lex()
	if lx.symbol=namesym then		!named type
		enumtypename:=lx.symptr^.name
		lex()
	fi					!else unnamed type (just named constants)
	checksymbol(rbracksym)
	lex()
fi

nextenumvalue:=1
nrows:=0			!number of data rows appearing
ncols:=0			!number of data columns (varnames appearing)

while lx.symbol=namesym do
	if ++ncols>maxcols then
		serror("tabledata/too many columns")
	fi
	varnameptrs[ncols]:=lx.symptr

	lex()
	if lx.symbol=commasym then
		lex()
	else
		exit
	fi
od

checkequals()
lex()					!skip =

skipsemi()
startline:=getcurrline()
closesym:=checkbegin(0)

skipsemi()
firstval:=lastval:=0

for i:=1 to ncols do
	plist[i]:=plistx[i]:=nil
od

intabledata:=1
do			!loop per row
	skipsemi()
	checksymbol(lbracksym)
	lex()
	if ++nrows>maxrows then
		serror("tabledata:too many rows")
	fi

	if enums then
		checksymbol(namesym)
		stgen:=lx.symptr				!generic symbol entry
		tabledataname:=stgen^.name		!allow to be picked up by $ lx.symbol
		lex()
		if lx.symbol=opsym and lx.subcode=j_eq then
			lex()
			nextenumvalue:=readconstint()
		fi
		enumvalues[nrows]:=nextenumvalue

		stenum:=getduplnameptr(owner,stgen,constid)
		stenum^.mode:=tint
		stenum^.code:=createconstunit(nextenumvalue,tint)
		stenum^.attribs.ax_global:=isglobal
		adddef(owner,stenum)

		if nrows=1 then firstval:=nextenumvalue fi
		lastval:=nextenumvalue

		++nextenumvalue
		if ncols then				!comma always expected
			checksymbol(commasym)		!check it
		fi
		lex()
	fi

	for i:=1 to ncols do
		addlistunit(&plist[i],&plistx[i],readexpression())
		if i=ncols then
			checksymbol(rbracksym)
		else
			checksymbol(commasym)
		fi
		lex()
	od

	if lx.symbol<>commasym then exit fi
	lex()					!should be ( for next entry
	if lx.symbol=closesym then exit fi		!allow trailing comma on last entry
od

intabledata:=0

skipsemi()
checkbeginend(closesym,ktabledatasym,startline)





if nrows=0 then serror("No table data") fi

vartype:=tvariant

for i:=1 to ncols do

	stvar:=getduplnameptr(owner,varnameptrs[i],staticid)
	if enums then
		plower:=createconstunit(enumvalues[1],tint)
	else
		plower:=nil
	fi

	stvar^.code:=createunit2(j_makelist,plist[i],plower)

	stvar^.attribs.ax_global:=isglobal

	adddef(owner,stvar)
od
end

global proc readclassdef(ref strec owner,int isglobal)=
int kwd, baseclass, m, startline, closesym, mrec, normalexit
ref strec nameptr, sttype, newd, d,e

kwd:=lx.symbol

lex()
checksymbol(namesym)
nameptr:=lx.symptr

lex()
baseclass:=0
if lx.symbol=lbracksym then
	lex()
	baseclass:=readtypespec(owner,0)
	checksymbol(rbracksym)
	lex()
fi

checkequals()
lex()

sttype:=getduplnameptr(owner,nameptr,typeid)

adddef(owner,sttype)
m:=createusertype(sttype)

mrec:=createrecordmode(owner,trecord,m)
sttype^.mode:=mrec

if baseclass then
	if baseclass>0 then serror("baseclass?") fi
	if nbaseclasses>=255 then
			serror("Too many base classes")
	fi
	++nbaseclasses
	storemode(owner,baseclass,&baseclasstable[nbaseclasses])
	sttype^.attribs.ax_baseclass:=nbaseclasses
	baseclassdef[nbaseclasses]:=sttype
fi

closesym:=checkbegin(1)

startline:=getcurrline()

readclassbody(sttype,kwd)

checkbeginend(closesym,kwd,startline)

sttype^.attribs.ax_global:=isglobal
end

proc readclassbody(ref strec owner,int classkwd)=

doswitch lx.symbol
when kconstsym then
	readconstdef(owner,0)
when kvarsym then
	readrecordfields(owner)
when kmethodsym,kfunctionsym,kprocsym then
	readprocdef(owner,0)

when kclasssym then
	lex()
	serror("CLASS CLASS")
when krecordsym then
	lex()
	serror("CLASS RECORD")
when ktypesym then
	lex()
	serror("CLASS TYPE")
when kendsym,rbracksym,rcurlysym then
	exit
when eofsym then
	serror("Class eof?")
	exit
when semisym then
	lex()
else
	if typestarterset[lx.symbol] then
		serror("Packed types not allowed in class")
	else
		serror("Unknown class decl")
	fi
enddoswitch
end

function readenumtype(ref strec owner,int typedefx,isglobal=0)int=		!READENUMTYPE
ref strec enumowner, stname, nameptr
int isanon, index, startline, closesym

enumowner:=owner			!owner of enum typeid
isanon:=0
if not typedefx then			!informal declaration
	if lx.symbol=namesym then		!name provided
		stname:=getduplnameptr(owner,lx.symptr,typeid)
		owner:=stname
		lex()
		checkequals()
		lex()
		adddef(enumowner,owner)
	else
		isanon:=1
	fi
	checksymbol(lbracksym)
	lex()
else
	owner:=ttnamedef[typedefx]
	startline:=getcurrline()
	closesym:=checkbegin(1)
fi

index:=1

while lx.symbol=namesym do
	nameptr:=lx.symptr
	lex()
	if lx.symbol=opsym and lx.subcode=j_eq then	!= follows
		lex()
		index:=readconstint()
	fi

	if not isanon then
		stname:=getduplnameptr(owner,nameptr,enumid)
		stname^.index:=index
		stname^.mode:=tint

		adddef(owner,stname)
	else
		stname:=getduplnameptr(enumowner,nameptr,constid)
		stname^.code:=createconstunit(index,tint)
		stname^.mode:=tint
		adddef(enumowner,stname)
	fi
	++index

	stname^.attribs.ax_global:=isglobal

	if lx.symbol<>commasym then exit fi
	lex()
od

if not typedefx then
	checksymbol(rbracksym)
	lex()
else
	checkbeginend(closesym,kenumsym,startline)
fi

if not isanon then
	return createenummode(owner,typedefx)
else
	return tvoid
fi
end

global proc readrecordfields(ref strec owner)=
int m, nvars
ref strec stname

lex()
m:=tvariant

nvars:=0
while lx.symbol=namesym do

	stname:=getduplnameptr(owner,lx.symptr,fieldid)
	stname^.mode:=m
	++nvars
	if getscope(owner)<>importscope then
		addgenfield(lx.symptr)
	fi

	adddef(owner,stname)

	lex()

	if lx.symbol=atsym then
		lex()
		stname^.attribs.ax_at:=1
		stname^.equiv:=readequivfield(owner)
	fi

	if lx.symbol<>commasym then
		exit
	fi
	lex()
od

if nvars=0 then
	serror("No fields declared")
fi
end

proc readimportmodule(ref strec owner)=
int isnew,startline,closesym
ref strec d,stname,stname0

lex()
if lx.symbol=stringconstsym then
	stname:=addnamestr(lx.svalue)
else
	checksymbol(namesym)
	stname:=lx.symptr
fi

lex()
checkequals()
lex()


isnew:=1
d:=stname^.nextdupl
while d do
	if d^.nameid=dllmoduleid then
		stname:=d
		isnew:=0
		exit
	fi
	d:=d^.nextdupl
od

if isnew then			!new
	stname:=getduplnameptr(stprogram,stname,dllmoduleid)
	if eqstring(stname^.name,"sys") then
		stsysmodule:=stname
	fi
	adddef(stprogram,stname)
	if ndlltable>=maxdlllib then
		serror("Too many DLL libs")
	fi
	dlltable[++ndlltable]:=stname^.name
	dllsttable[ndlltable]:=stname
	stname^.attribs.ax_dllindex:=ndlltable

fi

startline:=getcurrline()
closesym:=checkbegin(0)

currimport:=stname

readimportbody(stmodule)
currimport:=nil

checkbeginend(closesym,kimportmodulesym,startline)
end

proc readimportbody(ref strec owner)=
int lineno,fflang

lineno:=lx.lineno

do
	skipsemi()

	switch lx.symbol
	when kfflangsym then
		fflang:=lx.subcode
		lex()
		case lx.symbol
		when kprocsym,kfunctionsym,kmethodsym then
			readprocdecl(owner,0,fflang)
		esac	

	when kprocsym,kfunctionsym,kmethodsym then
		readprocdecl(owner,0,0)

	when kvarsym then
		readvardef(owner,0,0,staticid)

	when ktypesym then
		readtypedef(owner,0)

	when kconstsym then
		readconstdef(owner,0)

	when kclasssym,krecordsym then
		readclassdef(owner,0)

	when eofsym then
		exit

	when kendsym then
		exit
	else
		PS1("symbol")
		serror("Not allowed in importmodule")
	endswitch
od
end

function createprocdef(ref strec owner, stname,int id,ichar truename=nil)ref strec=
ref strec d,e
ref procrec pp
ref unitrec u

	d:=getduplnameptr(owner,stname,id)
	adddef(owner,d)
	addtoproclist(d)

	d^.index:=0

	if id=dllprocid then
		if ndllproctable>=maxdllproc then
			serror("Too many DLL procs")
		fi
		++ndllproctable
		if not truename then
			truename:=d^.name
		fi
		d^.truename:=truename
		dllproctable[ndllproctable].name:=truename

		dllproctable[ndllproctable].dllindex:=currimport^.attribs.ax_dllindex
		d^.index:=ndllproctable
	else					!scan for ext-proc chains
		e:=stname^.nextdupl
		while e do
			if e^.nameid=procid and e^.callchain then
				u:=e^.callchain
				repeat
					if u^.tag<>j_name then serror("CPD1") fi
					u^.def:=d
					u:=u^.c
				until u=nil


			fi
			e:=e^.nextdupl
		od
	fi

return d
end

function readequivfield(ref strec owner)ref strec=
ref strec p,d

checksymbol(namesym)
d:=lx.symptr
lex()

p:=owner^.deflist
while p do
	if eqstring(p^.name,d^.name) then
		return p
	fi

	p:=p^.nextdef
od
cpl d^.name
serror("Can't find @ field")
return nil
end

function testconstruct(ref unitrec p)ref unitrec=
ref unitrec q,paramlist,r
ref strec d
int mode

q:=p^.a
d:=q^.def
unless q^.tag=j_name and d^.nameid=typeid then
	return p
end unless

paramlist:=p^.b

mode:=d^.mode
p^.tag:=j_makeconstr		!turn the original call to a makeconstr
p^.a:=paramlist
p^.b:=nil

r:=createunit1(j_convert,p)
r^.mode:=mode

return r
end

function readapplyop(int inexpr)ref unitrec=
ref unitrec p,a,b

lex()
checksymbol(lbracksym)
lex()
p:=readexpression()
checksymbol(commasym)
lex()
a:=readexpression()
b:=nil

if lx.symbol=commasym then
	lex()
	b:=readexpression()
fi
checksymbol(rbracksym)
lex()

return createunit3((inexpr|j_applyopx|j_applyop),p,a,b)
end

proc readapplprocs(ref strec owner)=

	int nprocs,n
	ref strec stname

	lex()

	nprocs:=0
	while lx.symbol=namesym do
		++nprocs

		stname:=findapplproc(lx.symptr.name)
		if stname=nil then
			stname:=getduplnameptr(owner,lx.symptr,applprocid)
			stname^.attribs.ax_global:=1
			adddef(owner,stname)
			addapplproc(stname)
		fi

		lex()

		if lx.symbol<>commasym then
			exit
		fi
		lex()
	od

	if nprocs=0 then
		serror("No procs declared")
	fi
end

function defineapplproc:ref strec d=

	if currproc=nil then
		serror("appl. outside of proc")
	fi

	d:=findapplproc(lx.symptr.name)
	if d then return d fi

	d:=getduplnameptr(currproc,lx.symptr,applprocid)
	adddef(currproc,d)
	addapplproc(d)

	return d
end

function findapplproc(ichar name)ref strec=
	for i to napplproctable do
		if eqstring(applproctable[i].name,name) then
			return applproctable[i]
		fi
	od
	return nil
end

proc addapplproc(ref strec d)=
	if napplproctable>=maxapplproc then
		serror("Too many appl procs")
	fi

	applproctable[++napplproctable]:=d
	d.index:=napplproctable
end

function readapplcall:unit p=
	ref strec d

	lex()
	checksymbol(dotsym)
	lex()
	checksymbol(namesym)

	d:=defineapplproc()

	p:=createname(d)
	p.lineno:=lx.lineno
	if nextlx.symbol=lbracksym then
		p^.def:=d
	fi
	p:=createunit1(j_callapplfn, p)
	lex()
	checksymbol(lbracksym)
	return p
end
=== qc_lib.m 34/56 ===
import msys
import mlib
import clib
import oslib

import var_types
import var_decls
import qc_support
import pq_common
import qc_tables
import qc_lex

int autotypeno=0
int currlineno
global int nextavindex=0
int nextsvindex=0

strbuffer exprstrvar
ref strbuffer exprstr=&exprstrvar

tabledata []int opc_codes, []ichar opc_names =
	(j_add,		"+"),
	(j_sub,		"-"),
	(j_mul,		"*"),
	(j_div,		"/"),
	(j_idiv,	"%"),
	(j_neg,		"-"),
	(j_eq,		"="),
	(j_ne,		"<>"),
	(j_lt,		"<"),
	(j_le,		"<="),
	(j_gt,		">"),
	(j_ge,		">="),
	(j_iand,	"iand"),
	(j_ior,		"ior"),
	(j_ixor,	"ixor"),
	(j_inot,	"inot"),
	(j_shl,		"<<"),
	(j_shr,		">>"),
	(j_andl,	"and"),
	(j_orl,		"or"),

	(j_notl,	"not"),
	(j_min1,	"min"),
	(j_max1,	"max"),

	(j_addto,	"+:="),
	(j_subto,	"-:="),
	(j_multo,	"*:="),
	(j_divto,	"/:="),
	(j_negto,	"-:="),
	(j_shlto,	"<<:="),
	(j_shrto,	">>:="),

	(j_preincrx,	"++"),
	(j_postincrx,	"++"),
	(j_predecrx,	"--"),
	(j_postdecrx,	"--"),
	(j_power,		"**"),

	(0,		"")
end

function newstrec:ref strec=
ref strec p
p:=pcm_alloc(strec.bytes)
memset(p,0,strec.bytes)


p^.lineno:=lx.lineno
p^.attribs.ax_moduleno:=currmoduleno
return p
end

global proc initqclib=
int i

for i:=1 to oplist.len do
	jtagpriotable[oplist[i]]:=oppriolist[i]
od


for i:=1 to D_exprstarterset.len do exprstarterset[D_exprstarterset[i]]:=1 od
for i:=1 to D_typestarterset.len do typestarterset[D_typestarterset[i]]:=1 od

hostlvset[host_iconvlc]:=1
hostlvset[host_iconvuc]:=1

condopset[j_eq]:=1
condopset[j_ne]:=1
condopset[j_lt]:=1
condopset[j_le]:=1
condopset[j_ge]:=1
condopset[j_gt]:=1

end

global function getduplnameptr(ref strec owner,symptr,int id)ref strec=
ref strec p,q

p:=newstrec()

p^.name:=symptr^.name
p^.namelen:=symptr^.namelen
p^.symbol:=namesym
p^.owner:=owner
p^.nameid:=id
if id=frameid or id=paramid then
	p^.attribs.ax_frame:=1
fi

if q:=symptr^.nextdupl then			!1st in dupl list
	q^.prevdupl:=p
fi
p^.nextdupl:=q
p^.prevdupl:=symptr
p.firstdupl:=symptr

symptr^.nextdupl:=p

return p
end

global proc adddef(ref strec owner,p)=
ref strec q


if q:=p^.nextdupl then
	if q^.owner=owner then
		cpl q^.name,"in",owner^.name
		serror("Duplicate name")
	fi
fi

p^.nextdef:=owner^.deflist
owner^.deflist:=p

end

global proc adddef_nodupl(ref strec owner,p)=

p^.nextdef:=owner^.deflist
owner^.deflist:=p
end

global proc printst(filehandle f,ref strec p,int level=0)=	!PRINTST
ref strec q

if p^.symbol<>namesym then
	CPL("PRINTST not name\n\n\n")
	stop
fi

printstrec(f,p,level)

q:=p^.deflist

while q<>nil do
	printst(f,q,level+1)
	q:=q^.nextdef
od
end

proc printstrec(filehandle f,ref strec p,int level)=		!PRINTSTREC
attribrec attrs
ref byte q
strbuffer v
ref strbuffer d:=&v
int col,offset,t
const tabstr="    "
[2560]char str

gs_init(d)

offset:=0
to level do
	gs_str(d,tabstr)
	offset+:=4
od
gs_str(d,":")

gs_leftstr(d,p^.name,23-offset,'-')
gs_leftstr(d,namenames[p^.nameid],12,'.')

col:=gs_getcol(d)
attrs:=p^.attribs

strcpy(&.str,"[")

case getscope(p)
when localscope then 
	strcat(&.str," L")
when exportscope then
	strcat(&.str," G")
when importscope then
	strcat(&.str," E")
esac
if attrs.ax_static then
	strcat(&.str," S")
fi
if attrs.ax_fflang then
	strcat(&.str," ")
	strcat(&.str,fflangnames[attrs.ax_fflang])
fi
if attrs.ax_byrefmode then
	strcat(&.str," BR")
fi
if attrs.ax_align then
	strcat(&.str," @@")
	strcat(&.str,strint(attrs.ax_align))
	strcat(&.str," ")
fi
if attrs.ax_optional then
	strcat(&.str," Opt")
fi
if attrs.ax_varparams then
	strcat(&.str," VP")
fi
if attrs.ax_used then
	strcat(&.str," Used")
fi
if attrs.ax_frame then
	strcat(&.str," F")
fi
if attrs.ax_autovar then
	strcat(&.str," A")
fi
if attrs.ax_nparams then
	strcat(&.str," Pm:")
	strcat(&.str,strint(attrs.ax_nparams))
fi
if attrs.ax_moduleno then
	strcat(&.str," M:")
	strcat(&.str,strint(attrs.ax_moduleno))
fi
strcat(&.str,"]")
if str[2]=' ' then
	str[2]:='['
	gs_leftstr(d,&str[2],16)
else
	gs_leftstr(d,&.str,16)
fi

case p^.mode
when tvoid then
	gs_str(d," Vd") 
when tvariant then
	gs_str(d," Va") 
else
	gs_str(d," ")
	strcpy(&.str,strmode(p^.mode))
	gs_leftstr(d,&.str,12)
esac

case p^.nameid
when fieldid,paramid then
	gs_str(d," Off:")
	gs_strint(d,p^.offset)

	print @&.str,p.uflags.ulength:"v",ref char(&p^.uflags.codes):".*"

	if p^.code then
		gs_str(d," DEFAULT:")
		gs_strvar(d,strexpr(p^.code))
	fi

when genfieldid then
	gs_str(d," Ind:")
	gs_strint(d,p^.offset)

when procid then
	gs_str(d," Ind:")
	gs_strint(d,p^.index)
	gs_str(d," Addr:")
	print @&.str,p^.address:"H"
	gs_str(d,&.str)

	if p^.docstring then
		GS_STR(D,"{")
		GS_STR(D,P^.DOCSTRING)
		GS_STR(D,"}")
	fi

when dllprocid then
	gs_str(d," DLLProc#:")
	gs_strint(d,p^.index)
	if p^.truename then
		gs_str(d," Truename:")
		gs_str(d,p^.truename)
	fi

when applprocid then
	gs_str(d," APPLProc#:")
	gs_strint(d,p^.index)

when constid then
	gs_str(d," Const:")
	gs_strvar(d,strexpr(p^.code))

when typeid then
	if t:=p^.attribs.ax_baseclass then
		gs_str(d," Baseclass:")
		if t<255 then
			gs_str(d,ttname[t])
		else
			gs_str(d,"(Unavailable,>=255)")
		fi
	fi
when enumid then
	gs_str(d," Enum:")
	gs_strint(d,p^.index)

when dllmoduleid then
	gs_str(d," DLL#:")
	gs_strint(d,p^.attribs.ax_dllindex)

when labelid then
	gs_str(d," L")
	gs_strint(d,p^.index)

esac

if p^.equiv then
	case p^.nameid
	when aliasid then
		gs_str(d," Alias for:")
		gs_str(d,p^.equiv^.name)
	when linkid then
		gs_str(d," Link to:")
		gs_str(d,getdottedname(p^.equiv))
	else
		if p^.attribs.ax_at then
			gs_str(d," @")
			gs_str(d,p^.equiv^.name)
		fi
	esac
	gs_str(d," ")
fi

gs_str(d," Lineno:")
gs_strint(d,p^.lineno)

gs_println(d,f)
end

global proc printstflat(filehandle f)=
int i
ref strec p
ref lexrec lx
println @f,"GLOBAL SYMBOL TABLE:"

for i:=0 to hashtable.upb-1 do
	p:=&hashtable[i]
	if p^.name then
		case p^.symbol
		when rawnamesym,lexmacronamesym then
			println @f,i,p,":",p^.name,symbolnames[p^.symbol],namenames[p^.nameid]
			if p^.symbol=lexmacronamesym then
				println @f,"			",p^.macrovalue
			fi
			p:=p^.nextdupl
			while p do
				println @f,"	",p,p^.name,symbolnames[p^.symbol],namenames[p^.nameid],
					p^.prevdupl,"(From",(p^.owner|p^.owner^.name|"-"),,")"
				p:=p^.nextdupl
			od
		esac
	fi
od
end

function newunitrec:ref unitrec=
ref unitrec p
p:=pcm_alloc(unitrec.bytes)
memset(p,0,unitrec.bytes)
p^.lineno:=lx.lineno
p^.moduleno:=currmoduleno
return p
end

global function createname(ref strec p)ref unitrec=
ref unitrec u

u:=newunitrec()
u^.tag:=j_name
u^.def:=p

return u
end

global function createunit0(int tag)ref unitrec=
ref unitrec u

u:=newunitrec()
u^.tag:=tag
return u
end

global function createunit1(int tag, ref unitrec p)ref unitrec=
ref unitrec u

u:=newunitrec()
u^.tag:=tag
u^.a:=p
return u
end

global function createunit2(int tag, ref unitrec p,q)ref unitrec=
ref unitrec u

u:=newunitrec()
u^.tag:=tag
u^.a:=p
u^.b:=q
return u
end

global function createunit3(int tag, ref unitrec p,q,r)ref unitrec=
ref unitrec u

u:=newunitrec()
u^.tag:=tag
u^.a:=p
u^.b:=q
u^.c:=r
return u
end

global function createconstunit(word64 a, int t)ref unitrec=
ref unitrec u
u:=newunitrec()
u^.tag:=j_const
u^.value:=a
u^.mode:=t
return u
end

global function createstringconstunit(ichar s, int length)ref unitrec=
ref unitrec u
u:=newunitrec()
u^.tag:=j_const
u^.svalue:=s
u^.mode:=tstring
if length=-1 then
	u^.slength:=strlen(s)
else
	u^.slength:=length
fi
return u
end

global function getoptocode(int opc)int=		!GETOPTOCODE
static [0:jtagnames.len]int16 opctotable
int n,opcto,i
[20]char str

opcto:=opctotable[opc]
if opcto then return opcto fi				!find


strcpy(&.str,jtagnames[opc])					!"add" etc
strcat(&.str,"to")							!"addto" etc

for i:=0 to jtagnames.upb do
	if eqstring(jtagnames[i],&.str) then
		opctotable[opc]:=i
		return i
	fi
od

cpl jtagnames[opc]
serror("Can't find -to version")
return 0
end

global function checkpackedtype(int m)int=

switch ttbasetype[m]
when ti8,ti16,ti32,ti64,
	tu8,tu16,tu32,tu64,
	tr32,tr64,
	trefpacked,tstring,tstruct,tstringz,tarray,trefm,tintm,twordm then
	return 1
endswitch
cpl strmode(m),strmode(ttbasetype[m]),m
serror("Invalid Packed type")
return 0
end

global proc checkunpackedtype(int t)=

if ttbasetype[t]>tvariant then
	serror("Pack type not allowed")
fi
end

global function checkdlltype(int m)int=

if m<0 then			!user type: not resolved yet; assume OK
	return 1
fi

switch ttbasetype[m]
when ti8,ti16,ti32,ti64,
	tu8,tu16,tu32,tu64,
	tr32,tr64,
	tintm,twordm,trefm,
	trefpacked,tstring,tstruct,tstringz then
	return 1
endswitch
cpl ttname[m]
serror("Invalid DLL param/ret type")
return 0
end

global function createtype(ref strec d)int=			!CREATETYPE

if d^.nameid=typeid then	!has already been resolved as type
	return d^.mode
fi
return createusertype(d)
end

global function createusertype(ref strec stname)int=		!CREATEUSERTYPE
++ntypes
ttname[ntypes]:=stname^.name
ttnamedef[ntypes]:=stname
ttbasetype[ntypes]:=tvoid
ttusercat[ntypes]:=user_cat
ttlineno[ntypes]:=lx.lineno
ttmoduleno[ntypes]:=currmoduleno

return ntypes
end

global function createusertypefromstr(ichar name)int=		!CREATEUSERTYPE
ref strec stname
stname:=getduplnameptr(stmodule,addnamestr(name),typeid)
adddef(stmodule,stname)
return createusertype(stname)
end

global function getconstvalue(ref unitrec p,int ID=0)int64=	!GETCONSTVALUE
if p and p^.tag=j_const then
	return p^.value
fi
CPL =ID
CPL =ID
CPL =ID
CPL =ID
serror("GCV Not constant")
return 0
end

global function getrangelwb(ref unitrec p)int=				!GETRANGELWB
if p^.tag=j_makerange then
	return p^.range_lower
else
	serror("getrangelwb")
fi
return 0
end

global function getrangeupb(ref unitrec p)int=				!GETRANGEUPB
if p^.tag=j_makerange then
	return p^.range_upper
else
	serror("getrangeupb")
fi
return 0
end

global function getrangelwbunit(ref unitrec p)ref unitrec=				!GETRANGELWB
if p^.tag=j_makerange then
	return p^.a
else
	return createunit1(j_lwb,p)
fi
end

global function getrangeupbunit(ref unitrec p)ref unitrec=				!GETRANGEUPB
if p^.tag=j_makerange then
	return p^.b
else
	return createunit1(j_upb,p)
fi
end

global function createarraymode(ref strec owner,int target,unit lower,length, int typedefx)int=		!CREATEARRAYMODE
int atype,k,m

case target
when tu1,tu2,tu4 then
	atype:=tbits
else
	atype:=tarray
esac

if typedefx=0 then		!anon type
	m:=createusertypefromstr(nextautotype())
else
	m:=typedefx
fi

ttbasetype[m]:=atype
ttlowerexpr[m]:=lower
ttlengthexpr[m]:=length
tttarget[m]:=target
ttowner[m]:=owner

return m
end

global function nextautotype:ichar=
static [32]char str

fprint @&.str,"$T#",++autotypeno
return &.str
end

global function createstringmode(ref strec owner,int t,unit lengthx, int typedefx)int=		!CREATESTRINGMODE
int k,m

if typedefx=0 then			!typedefx=1 means creating usertype; can't share
	m:=createusertypefromstr(nextautotype())
else
	m:=typedefx
fi

ttbasetype[m]:=t
ttlower[m]:=(t=tstring|1|0)
ttsize[m]:=0
ttlengthexpr[m]:=lengthx
ttowner[m]:=owner

return m
end

global function createrefpackmode(ref strec owner,int target,typedefx)int=
int k,m

case target
when tvariant then
	return trefvar
when tu1,tu2,tu4 then
	serror("CREATEREFBIT")
esac

if typedefx=0 then		!anon type
	for k:=tlast to ntypes do
		if ttusercat[k]=anon_cat and ttbasetype[k]=trefpacked and tttarget[k]=target then
			return k
		fi
	od
	m:=createusertypefromstr(nextautotype())
else
	m:=typedefx
fi

storemode(owner,target,&tttarget[m])
ttbasetype[m]:=trefpacked

return m
end

global function getscope(ref strec p)int=		!GETSCOPE
ref strec owner

if p=nil then return localscope fi
case p^.nameid
when moduleid,programid then return exportscope
when dllmoduleid then return importscope
esac

do
	owner:=p^.owner
	case owner^.nameid
	when moduleid, dllmoduleid then
		exit
	esac
	p:=owner
od

case owner^.nameid
when moduleid then
	return (p^.attribs.ax_global|exportscope|localscope)
else
	return importscope
esac
return 0
end

global proc setnameptr(ref unitrec p)=		!SETNAMEPTR

p^.def^.code:=p
end

global proc printcode(filehandle f,ichar caption)=
int i
ref strec p,m

m:=stprogram^.deflist

println @f, caption, "PROGRAM"

while m do
	p:=m^.deflist
	println @f,"Module:",m^.name:"A12P*JC","=":"50p="
	while p do
		case p^.nameid
		when procid then
			println @f,p^.name,,"=",(p^.attribs.ax_global|"Global"|"Local")
			printunit(p^.code,,"1",dev:f)
			println @f
		esac
		p:=p^.nextdef
	od
	m:=m^.nextdef
od
end

global proc printunit(ref unitrec p,int level=0,ichar prefix="*",filehandle dev=nil)=		!PRINTUNIT
ref unitrec q
ref strec d
int t
ichar idname

if p=nil then
	return
fi

if p^.lineno then
	currlineno:=p^.lineno
fi


print @dev,p,": "

print @dev,getprefix(level,prefix,p)
idname:=jtagnames[p^.tag]
print @dev,idname,,": "

if fdebug then
CPL =idname
fi

case p^.tag
when j_name then
	d:=p^.def

	print @dev,d^.name,namenames[d^.nameid]

	if d^.code then
		print @dev," {",,jtagnames[d^.code^.tag],,"}"
	fi

	print @dev," ",,getdottedname(d)!,q
	print @dev,(p^.dottedname|" {Dotted}"|"")

	if p^.c then
		print @dev," Lastcall:",p^.c
	fi

	print @dev," ",d:"z8h"

when j_labeldef then
	println @dev,p^.def^.name

when j_const then
	t:=p^.mode
	case t
	when tstring then
		if p^.slength>256 then
			print @dev,"""",,"(LONGSTR)",""" *",,p^.slength
		else
			print @dev,"""",,p^.svalue,,""" *",,p^.slength
		fi
	when tint then
		print @dev,p^.value
	when tword then
		print @dev,p^.uvalue
	when treal then
		print @dev,p^.xvalue
	when trange then
		print @dev,p^.range_lower,,"..",,p^.range_upper
	else
		cpl ttname[t]
		serror("PRINTUNIT BAD CONST")
	esac
	print @dev," ",,stdtypenames[t]

when j_longint then
	print @dev,p^.svalue,"Len:",p^.slength

when j_callhostfn,j_callhostproc then
	print @dev,hostfnnames[p^.opcode]

when j_typeconst then
	print @dev,ttname[p^.mode]

when j_operator then
	print @dev,jtagnames[p^.opcode]+2

when j_convert then
	print @dev,ttname[p^.mode]

esac

println @dev
printunitlist(dev,p^.a,level+1,"1")
printunitlist(dev,p^.b,level+1,"2")
printunitlist(dev,p^.c,level+1,"3")
end

proc printunitlist(filehandle dev,ref unitrec p,int level=0,ichar prefix="*")=		!PRINTUNIT
if p=nil then return fi

while p do
	printunit(p,level,prefix,dev:dev)
	p:=p^.nextunit
od
end

function getprefix(int level,ichar prefix,ref unitrec p)ichar=		!GETPREFIX
static [512]char str
[512]char indentstr


indentstr[1]:=0
if level>10 then level:=10 fi

to level do
	strcat(&.indentstr,"- - ")
od

strcpy(&.str,getlineinfok())
strcat(&.str,&.indentstr)
strcat(&.str,prefix)
if prefix^ then
	strcat(&.str," ")
fi

return &.str
end

global function getdottedname(ref strec p)ichar=		!GETDOTTEDNAME
static [256]char str
[256]char str2
ref strec owner

strcpy(&.str,p^.name)
owner:=p^.owner
while owner and owner^.nameid<>programid do
	strcpy(&.str2,&.str)
	strcpy(&.str,owner^.name)
	strcat(&.str,".")
	strcat(&.str,&.str2)
	owner:=owner^.owner
od
return &.str
end

function getlineinfok:ichar=			!GETLINEINFO
static [40]char str

fprint @&.str,"# ",currlineno:"z4"
return &.str
end

global function getavname(ref strec owner,int id=frameid)ref strec=
ref strec p
[32]char str
ichar name

if id=frameid and owner^.nameid<>procid then
	serror("Auto frame not in proc")
fi

if id=frameid then
	print @&.str,"av$",,++nextavindex
else
	print @&.str,"sv$",,++nextsvindex
fi

name:=pcm_copyheapstring(&.str)
addnamestr(name)

p:=getduplnameptr(owner,addnamestr(name),id)

p^.mode:=tint
p^.attribs.ax_autovar:=1

adddef(owner,p)
return p
end

global proc unionstr_clear(ref uflagsrec u)=
u^.ulength:=0
end

global proc unionstr_append(ref uflagsrec u, int c)=
if u^.ulength=u^.codes.len then
	serror("Uflags overflow/a")
fi
++u^.ulength
u^.codes[u^.ulength]:=c
end

global proc unionstr_concat(ref uflagsrec u, v)=
int ulen,vlen,i

ulen:=u^.ulength
vlen:=v^.ulength
if ulen+vlen>u^.codes.len then
	serror("Uflags overflow/c")
fi
for i:=1 to vlen do
	u^.codes[i+ulen]:=v^.codes[i]
od
u^.ulength:=ulen+vlen
end

global function unionstr_last(ref uflagsrec u)int=
if u^.ulength then
	return u^.codes[u^.ulength]
fi
return 0 
end

global proc unionstr_copy(ref uflagsrec u,v)=
memcpy(u,v,uflagsrec.bytes)
end

global proc unionstr_print(ref uflagsrec u)=
printstrn_app(cast(&u^.codes),u^.ulength)
end

global function createrecordmode(ref strec owner,int t,typedefx)int=	!CREATERECORDMODE
int m

if typedefx=0 then
	m:=createusertype(owner)
else
	m:=typedefx
fi
ttbasetype[m]:=t			!record/struct/union

return m
end

global function createenummode(ref strec owner,int typedefx)int=		!CREATEENUMMODE
int m

if typedefx=0 then
	m:=createusertype(owner)
else
	m:=typedefx
fi
ttbasetype[m]:=tenum

return m
end

global proc convertstring(ichar s, t)=		!CONVERTSTRING
int c

while c:=s++^ do
	switch c
	when '"' then
		t++^:='\\'
		t++^:='"'
	when 10 then
		t++^:='\\'
		t++^:='n'
	when 13 then
		t++^:='\\'
		t++^:='c'
	when 9 then
		t++^:='\\'
		t++^:='t'
	when '\\' then
		t++^:='\\'
		t++^:='\\'
	when 7,8,26,27 then
		t++^:='<'
		t++^:=c/10+'0'
		t++^:=(c rem 10)+'0'
		t++^:='>'
	else
		t++^:=c
	endswitch
od
t^:=0
end

global function strexpr(ref unitrec p)ref strbuffer=		!STREXPR
gs_init(exprstr)
jeval(exprstr,p)
return exprstr
end

proc jeval(ref strbuffer dest, ref unitrec p)=			!JEVAL
ref unitrec q
[500]char str


case p^.tag
when j_const then
	case p^.mode
	when tstring then
dostring::
		if p^.slength>str.len/2 then
			strcpy(&.str,"LONGSTR)")
		else
			convertstring(p^.svalue,&.str)
		fi
		gs_additem(dest,"""")
		gs_additem(dest,&.str)
		gs_additem(dest,"""")
		return
	when tint then
		print @&.str,p.value
	when tword then
		print @&.str,p.uvalue
	when treal then
		print @&.str,p.xvalue
	when trange then
		fprint @&.str,"#..#",p^.range_lower,p^.range_upper
	else
		CPL ttname[p^.mode]
		rxerror("EVAL/CONST",p)
	esac
	gs_additem(dest,&.str)

when j_name then
	gs_additem(dest,p^.def^.name)

when j_andl,j_orl,j_andand,j_eq,j_ne,j_lt,j_le,j_gt,j_ge,j_add,j_sub,j_mul,j_div,
	j_idiv,j_fdiv,j_ddiv,j_rem,j_iand,j_ior,j_ixor,j_shl,j_shr,j_in,j_notin,j_inrev,j_min,j_max,j_addptr,j_subptr,
	j_concat,j_atan2,j_power, j_xorl, j_isequal, j_divrem, j_append then
	strcpy(&.str,getopcjname(p^.tag))
	gs_additem(dest,"(")
	jeval(dest,p^.a)
	gs_additem(dest,&.str)
	jeval(dest,p^.b)
	gs_additem(dest,")")

when j_neg,j_abs,j_inot,j_chr,j_asc,j_sqrt,j_sqr,j_cube,j_sign,j_sin,j_cos,j_tan,j_asin,
	j_acos,j_atan,j_ln,j_lg,j_log,j_exp,j_round,j_floor,j_ceil,j_fract,j_fmod, j_lwb,j_upb,j_len,j_bounds,
	j_bitwidth,j_bytesize,j_gettype,j_getbasetype,j_getelemtype,j_isvoid,j_isdef,j_isint,j_isreal,j_isstring,
	j_isrange,j_islist,j_isrecord,j_isarray,j_isset,j_ispointer,j_minvalue,j_maxvalue,j_min1,j_max1,
	j_notl,j_istruel, j_isnone, j_ismutable then

	strcpy(&.str,getopcjname(p^.tag))
	gs_additem(dest,&.str)
	gs_additem(dest,"(")
	jeval(dest,p^.a)
	gs_additem(dest,")")

when j_callfn,j_callproc then
	jeval(dest,p^.a)
	gs_additem(dest,"(")

	q:=p^.b
	while q do
		jeval(dest,q)
		q:=q^.nextunit
		if q then gs_additem(dest,",") fi
	od
	gs_additem(dest,")")

when j_callhostfn then
	gs_additem(dest,"Host<")
	gs_additem(dest,hostfnnames[p^.opcode]+5)
	gs_additem(dest,">(")

	q:=p^.b
	while q do
		jeval(dest,q)
		q:=q^.nextunit
		if q then gs_additem(dest,",") fi
	od
	gs_additem(dest,")")

when j_index,j_dotindex,j_slice,j_dotslice then
	jeval(dest,p^.a)
	if p^.tag=j_dotindex or p^.tag=j_dotslice then
		gs_additem(dest,".")
	fi
	gs_additem(dest,"[")
	jeval(dest,p^.b)
	gs_additem(dest,"]")

when j_keyindex,j_dotkeyindex then
	jeval(dest,p^.a)
	if p^.tag=j_dotkeyindex then
		gs_additem(dest,".")
	fi
	gs_additem(dest,"{")
	jeval(dest,p^.b)
	gs_additem(dest,"}")

when j_dot then
	jeval(dest,p^.a)
	gs_additem(dest,".")
	jeval(dest,p^.b)

when j_makelist,j_makesetlist,j_makeconstr,j_makedict then
	gs_additem(dest,(p^.tag=j_makelist or p^.tag=j_makeconstr|"("|"["))

	q:=p^.a
	while q do
		jeval(dest,q)
		q:=q^.nextunit
		if q then gs_additem(dest,",") fi
	od
	gs_additem(dest,(p^.tag=j_makelist|")"|"]"))

when j_makerange then
	gs_additem(dest,"(")
	jeval(dest,p^.a)
	gs_additem(dest,"..")
	jeval(dest,p^.b)
	gs_additem(dest,")")

when j_assignx then
	jeval(dest,p^.a)
	gs_additem(dest,":=")
	jeval(dest,p^.b)

when j_ifx then
	gs_additem(dest,"(")
	jeval(dest,p^.a)
	gs_additem(dest,"|")
	jeval(dest,p^.b)
	gs_additem(dest,"|")
	jeval(dest,p^.c)
	gs_additem(dest,")")

when j_typeconst then
	gs_additem(dest,strmode(p^.mode))
when j_classconst then
	gs_additem(dest,p^.def^.name)
	gs_additem(dest,">")

when j_convert then

	gs_additem(dest,"(")
	jeval(dest,p^.a)
	gs_additem(dest,")")
when j_keyvalue then
	jeval(dest,p^.a)
	gs_additem(dest,":")
	jeval(dest,p^.b)

when j_longint then
	gs_str(dest,"Longint:")
	goto dostring

when j_ptr then
	jeval(dest,p^.a)
	gs_additem(dest,"^")

when j_addrof then
	gs_additem(dest,"&")
	jeval(dest,p^.a)

when j_ptrto then
	jeval(dest,p^.a)

when j_clamp then
	gs_additem(dest,"(")
	jeval(dest,p^.a)
	gs_additem(dest,",")
	jeval(dest,p^.b)
	gs_additem(dest,",")
	jeval(dest,p^.c)
	gs_additem(dest,")")

when j_block then
	gs_additem(dest,"<JBLOCK>")

when j_multexpr then
	gs_additem(dest,"MULTEXPR(")
	q:=p^.a
	while q do
		jeval(dest,q)
		q:=q^.nextunit
		if q then gs_additem(dest,",") fi
	od
	
	gs_additem(dest,")")


else
	CPL jtagnames[p^.tag]
	gerror("CAN'T DO JEVAL",p)
end
end

global function getopcjname(int opc)ichar=		!GETOPCJNAME
int i
[20]char str

for i:=1 to opc_codes.len do		!look for dedicated op name
	if opc=opc_codes[i] then
		return opc_names[i]
	fi
od

return jtagnames[opc]+2				!return standard jtag name
end

global function strmode(int m,expand=1)ichar=		!STRMODE
static [4096]char str
istrmode(m,expand,&.str)
return &.str
end

global proc istrmode(int m,expand=1,ichar dest)=		!ISTRMODE
ref strec d,q
int value,needcomma,x,i

if m<0 then
	strcpy(dest,"*")
	strcat(dest,ttnamedefx[-m]^.name)
	if ttnamedefx2[-m] then
		strcat(dest,".")
		strcat(dest,ttnamedefx2[-m]^.name)
	fi
	return
fi

if m<tlast then
	strcpy(dest,ttname[m])
	return
fi

case ttbasetype[m]
when trefvar,trefpacked then
	strcpy(dest,"ref ")
	if ttbasetype[tttarget[m]]=tstruct then
		strcat(dest,ttname[tttarget[m]])
	else
		istrmode(tttarget[m],0,dest+strlen(dest))
	fi

when tstring then
	strcpy(dest,"string*")
	print @dest+strlen(dest),ttlength[m]

when tstringz then
	strcpy(dest,"stringz*")
	print @dest+strlen(dest),ttlength[m]

when tset then
	strcpy(dest,"set*")
	print @dest+strlen(dest),ttlength[m]

when tarray then
	if ttlength[m] then
		fprint @dest,"[#..#]",ttlower[m],ttlength[m]+ttlower[m]-1
	else
		fprint @dest,"[#:]",ttlower[m]
	fi
	istrmode(tttarget[m],0,dest+strlen(dest))

when tenum then
	strcpy(dest,"enum(")
	d:=ttnamedef[m]

	value:=1
	needcomma:=0
	q:=d^.deflist
	while q do
		if needcomma then strcat(dest,",") fi
		needcomma:=1
		strcat(dest,q^.name)
		x:=q^.index
		if x<>value then
			value:=x
			print @dest+strlen(dest),value
		fi
		++value
		q:=q^.nextdef
	od

	strcat(dest,")")

when trecord,tstruct then
	if not expand then
		strcpy(dest,ttname[m])
		return
	fi
	strcat(dest,ttname[ttbasetype[m]])
	strcat(dest,"(")
	d:=ttnamedef[m]
	needcomma:=0

	q:=d^.deflist
	while q do
		if needcomma then strcat(dest,",") fi
		needcomma:=1
		istrmode(q^.mode,0,dest+strlen(dest))
		strcat(dest," ")
		strcat(dest,q^.name)
		q:=q^.nextdef
	od
	strcat(dest,")")

when tvoid then			!must be a usertype that is not defined (as normal voids checked above)
	strcpy(dest,ttname[m])

when tuser then
	strcpy(dest,ttname[m])
else
	serror("NEWSTRMODE")
esac
end

global function countunits(ref unitrec p)int=
int n
n:=0
while p do
	++n
	p:=p^.nextunit
od
return n
end

global function finddefstr(ref strec owner,ichar name)ref strec=	!FINDDEFSTRING
ref strec d

d:=owner^.deflist
while d do
	if eqstring(d^.name,name) then
		return d
	fi
	d:=d^.nextdef
od

return nil
end

proc purgesymbol(ref strec p,prev,int del)=
ref strec q

case p^.nameid
when fieldid then			!needed for genfieldtables
	return
esac

purgesymbollist(p^.deflist,0,del)

if prev then
	prev^.nextdef:=p^.nextdef
else
	p^.owner^.deflist:=p^.nextdef
fi


q:=p^.prevdupl
q^.nextdupl:=p^.nextdupl

if del then
	pcm_free(p,strec.bytes)
fi
end

global proc purgesymbollist(ref strec p,int ismodule, del)=

ref strec q,prev

prev:=nil
while p do
	q:=p^.nextdef			!pick up next before q ceases to exist
	if ismodule=0 or not p^.attribs.ax_global then
		purgesymbol(p,prev,del)
	else
		prev:=p				!when deleted, prev stays unchanged
	fi
	p:=q
od
end

global proc purgeprocs(ref strec p, int del)=


while p do
	if p^.nameid=procid then
		purgeproc(p,del)
	fi
	p:=p^.nextdef
od
end

global proc purgeproc(ref strec p, int del)=
ref strec q,prev,r


q:=p^.deflist
prev:=nil
while q do
	r:=q^.nextdef
	if q^.nameid=frameid then
		purgesymbol(q,prev,del)
	else
		prev:=q
	fi
	q:=r
od
end

global proc printmodelist(filehandle f)=		!PRINTMODELIST
const wtypeno	= 4
const wname		= 13
const wbasetype	= 13
const wbitsize	= 3
const wtarget	= 12
const wnamedef	= 4
const wlower	= 3
const wupper	= 3
const wlength	= 4
const wsize		= 5
const wusercat	= 4
const wused		= 4
const wmode		= 32
[256]char str
ichar mstr
strbuffer destv
ref strbuffer dest := &destv
int m

gs_init(dest)

gs_leftstr(dest,"#",wtypeno)
gs_leftstr(dest,"Name",wname)
gs_leftstr(dest,"Base",wbasetype)
gs_leftstr(dest,"Bit",wbitsize)
gs_leftstr(dest,"Target",wtarget)
gs_leftstr(dest,"Def",wnamedef)
gs_leftstr(dest,"Lwb",wlower)
gs_leftstr(dest,"Upb",wupper)
gs_leftstr(dest,"Len",wlength)
gs_leftstr(dest,"Size",wsize)
gs_leftstr(dest,"Cat",wusercat)
gs_leftstr(dest,"Used",wused)
gs_leftstr(dest,"Mode",wmode)
gs_println(dest,f)

for m:=0 to ntypes do
	gs_init(dest)

	gs_leftint(dest,m,wtypeno)
	gs_leftstr(dest,ttname[m],wname)
	gs_leftstr(dest,ttname[ttbasetype[m]],wbasetype)
	gs_leftint(dest,ttbitwidth[m],wbitsize)
	if tttarget[m] then
		gs_leftstr(dest,ttname[tttarget[m]],wtarget)
	else
		gs_leftstr(dest,"-",wtarget)
	fi
	if ttnamedef[m] then
		gs_leftstr(dest,"+",wnamedef)
	else
		gs_leftstr(dest,"-",wnamedef)
	fi


	case ttbasetype[m]
	when tstring,tset,tarray,trecord,tstruct,tenum then
		gs_leftint(dest,ttlower[m],wlower)
		gs_leftint(dest,ttlower[m]+ttlength[m]-1,wlower)
			gs_leftint(dest,ttlength[m],wlength)
	else
		gs_leftstr(dest,"",wlower)
		gs_leftstr(dest,"",wlower)
		gs_leftstr(dest,"",wlength)
	esac

	gs_leftint(dest,ttsize[m],wsize)
	gs_leftint(dest,ttusercat[m],wusercat)

	mstr:=strmode(m)
	if strlen(mstr)<16 then
		gs_str(dest,mstr)
	else
		gs_println(dest,f)
		gs_init(dest)
		gs_str(dest,mstr)
	fi
	gs_println(dest,f)
od

println @f
end

global proc printgenfieldtable(filehandle f, ichar caption)=
int i
println @f,caption,ngenfieldnames
for i to ngenfieldnames do
	println @f,i,genfieldnames[i].def^.name,genfieldnames[i].dataindex,
		genfieldnames[i].datalength
od
println @f
println @f,"Genfielddata:",ngenfielddata
for i to ngenfielddata do
	println @f,genfielddata[i].fieldindex,
		ttname[genfielddata[i].recordtype],ttname[genfielddata[i].fieldtype],
		genfielddata[i].offset
od
println @f
end

global proc addtoproclist(ref strec d)=
	ref procrec pp
	++nproclist
	pp:=pcm_alloc(procrec.bytes)
	pp^.nextproc:=proclist
	proclist:=pp
	pp^.def:=d
end

global function newusertypex(ref strec d,e=nil)int=
int i

if nuserxtypes>=maxuserxtype then
	serror("Too many external user types")
fi
++nuserxtypes
ttnamedefx[nuserxtypes]:=d
ttnamedefx2[nuserxtypes]:=e
ttxmoduleno[nuserxtypes]:=currmoduleno
ttlinenox[nuserxtypes]:=lx.lineno iand 16777215
return -nuserxtypes

end

global proc storemode(ref strec owner, int m, ref int16 p)=
ref userxrec q
p^:=m
if m>=0 then return fi

q:=pcm_alloc(userxrec.bytes)
q^.owner:=owner

IF OWNER=NIL THEN
SERROR("STOREMODE/OWNER=0")
FI

q^.pmode:=p
q^.nextmode:=userxmodelist
userxmodelist:=q
end

global function duplunit(unit p)unit=
unit q
if p=nil then return nil fi

q:=createunit0(p^.tag)

q^.a:=duplunit(p^.a)
q^.b:=duplunit(p^.b)
q^.c:=duplunit(p^.c)
q^.lineno:=p^.lineno
q^.value:=p^.value			!copy main field of each union
q^.opcode:=p^.opcode
q^.mode:=p^.mode
q^.moduleno:=p^.moduleno

return q
end


=== qc_name.m 35/56 ===
import mlib
import clib
import oslib

import var_types
import var_decls
import qc_support
import pq_common
import qc_tables
import qc_lex
import qc_lib

ref strec currstproc
int allowmodname=0

int nfields,nallfields		!set up during converttype

global proc rx_unit(ref strec owner, unit p)=
ref strec d
unit a,b
int n

a:=p^.a
b:=p^.b
mlineno:=p^.lineno

switch p^.tag
when j_name then
	resolvename(owner,p)

when j_keyword then
	rx_unit(owner,b)		!do param value only

when j_dot then
	resolvedot(owner,p)

when j_callproc, j_callfn then
	rx_unit(owner,a)
	rx_unitlist(owner,b)
	if a^.tag=j_typeconst then
		p^.tag:=j_convert
		p^.a:=b
		p^.b:=nil
		p^.mode:=a^.mode
		if b^.nextunit then
			p^.a:=createunit1(j_makelist,b)
			n:=0
			while b do
				++n
				b:=b^.nextunit
			od
			p^.a^.length:=n
		fi
	fi

when j_goto then
	if a^.tag<>j_name then rxerror("Not simple label") fi
	resolvename(owner,a)
	if a^.def^.nameid<>labelid then rxerror_s("Not a label or not found: #",a^.def^.name) fi

when j_add, j_sub, j_mul, j_div, j_idiv, j_rem, j_iand, j_ior, j_ixor,
	j_shl, j_shr, j_makerange then
	rx_unitlist(owner,a)
	if not b then rxerror("Binop missing opnd") fi
	rx_unitlist(owner,b)
	evalbinop(p,a,b)


when j_eq,j_ne, j_lt,j_le,j_ge,j_gt then

	case p^.a^.tag
	when j_eq,j_ne, j_lt,j_le,j_ge,j_gt then

		converteqeq(owner,p)
	else
		go to doabc
	esac
	goto doabc

when j_neg, j_abs,j_len, j_bytesize,j_sqrt then
	rx_unitlist(owner,a)
	evalmonop(p)


when j_forup,j_fordown then			!a will be j_name unit
	resolvename(owner,a,ti64)
	a:=a^.nextunit
	goto doabc

when j_convert then
	rx_unit(owner,a)
	if a^.tag=j_const then
		evalmonop(p)
	fi

else
doabc::
	rx_unitlist(owner,a)
	if b then rx_unitlist(owner,b) fi
	if p^.c then rx_unitlist(owner,p^.c) fi
endswitch
end

global function rx_module(int n)int=
modulerec m
ref strec stmodule, d
int globalflag,status

currmoduleno:=n

rx_passdef(stprogram,moduletable[n].stmodule)

return 1
end

global proc rx_deflist(ref strec owner,p)=
	while p do
		rx_passdef(owner,p)
		p:=p^.nextdef
	od
end

global proc rx_passdef(ref strec owner,p)=
ref strec d

case p^.nameid
when moduleid,dllmoduleid then
	rx_deflist(p,p^.deflist)

when procid then
	fixmode(owner,p)
	rx_deflist(p,p^.deflist)
	currstproc:=p
	rx_unit(p,p^.code)
	currstproc:=nil

when dllprocid then
	fixmode(owner,p)
	rx_deflist(p,p^.deflist)

when constid,staticid,frameid,paramid then
	fixmode(owner,p)
	if p^.code then
		rx_unit(owner,p^.code)
	fi
when typeid then
	fixmode(owner,p)
	rx_deflist(p,p^.deflist)

else

esac
end

proc rx_unitlist(ref strec owner, unit p)=
while p do
	rx_unit(owner,p)
	p:=p^.nextunit
od
end

global function resolvetopname(ref strec owner,stnewname,int moduleno,fmodule)ref strec=

int i,m,extcount,modno
ref strec p,q,powner,d,e,dlldef,extdef,moddef,extmod
[10]ref strec ambiglist
INT DEB
STATIC INT MAXDUPL
INT NDUPL

if owner.nameid=procid then
	q:=owner.deflist
	while q do
		if q.firstdupl=stnewname then		!use that match
			return q
		fi
		q:=q.nextdef
	od
fi

p:=stnewname^.nextdupl

extcount:=0
extmod:=dlldef:=extdef:=moddef:=nil
NDUPL:=0


while p do						!for each possibe st entry of the same name
++NDUPL

	powner:=p^.owner			!the owner of that entry

	switch powner^.nameid
	when procid then
		if powner=owner then			!immediate match
			return p
		fi
	when moduleid then			!p is file-scope item
		if powner^.attribs.ax_moduleno=moduleno then		!same module
			if owner^.nameid=moduleid then	!immediate match
				return p
			fi
			moddef:=p			!take note, but continue searching (in case proc etc)
		elsif moduletable[moduleno].importmap[powner^.attribs.ax_moduleno] then
			if p^.attribs.ax_global then
								!matches an external module imported by this name's module
				++extcount			!if an ext match is closest, there can only be one
				extdef:=p
storeextdef::
				if extcount<ambiglist.len then
					ambiglist[extcount]:=extdef
				fi

			elsif p^.nameid=aliasid and p^.equiv^.attribs.ax_global then
				++extcount
				extdef:=p^.equiv
				goto storeextdef
			fi
		fi
	when dllmoduleid then

		modno:=powner^.attribs.ax_moduleno
		if modno=moduleno or moduletable[moduleno].importmap[modno] then
			dlldef:=p
		fi

	when typeid then
		if powner=owner then			!immediate match
			return p
		fi
	when programid then					!p is a module
		if p^.nameid=moduleid then		!match a module name
			if fmodule then
				return p			!immediate match (unless proc but that would have
			fi						!matched by now
		fi
	endswitch

	p:=p^.nextdupl
od


if moddef then				!go with that first
	return moddef
fi
if extdef then
	if extcount>1 then
		for i:=1 to extcount do
			extdef:=ambiglist[i]
			println i,extdef^.owner^.name,namenames[extdef^.owner^.nameid]
		od
		rxerror_s("Ambiguous ext name: #",extdef^.name)
	fi
	return extdef
fi
if extmod then return extmod fi


return dlldef				!will be nil when no match
end

global proc resolvename(ref strec owner, unit p, int mode=tvoid)=

	ref strec d,e
	unit q
	int moduleno

	d:=p^.def
	moduleno:=p^.moduleno

	if d^.nameid not in [nullid,genfieldid] then			!assume already resolved
		return
	fi

	e:=resolvetopname(owner,d,moduleno,allowmodname)
	if not e then
		if owner^.nameid=procid then	!add as framevar
			e:=p^.def:=getduplnameptr(owner,p^.def,frameid)
			adddef(owner,e)				!note: no vardef exists
			e^.mode:=tvariant
		else
			cpl d^.name,p^.lineno,jtagnames[p^.tag]
			rxerror_s("Undefined: #",d^.name,p)
		fi
	else
retry::
		p^.def:=e			!update link in kcode

		case e^.nameid
		when constid then		!convert namedconst to const
			q:=e^.code			!q is knamedconst unit; q^.c is value
			rx_unit(owner,q)
			if q^.tag<>j_const then
				rxerror_s("Not const expr: #",jtagnames[q^.tag])
			fi

			e^.mode:=q^.mode
			p^.tag:=j_const
			p^.value:=q^.value
			p^.mode:=q^.mode
			p^.slength:=q^.slength
		when enumid then
			rxerror("FOUND ENUMID",p)
		when staticid then		!deal with python global accesses ?? WTF ???
		when typeid then
			p^.tag:=j_typeconst
			p^.mode:=p^.def^.mode
		when aliasid then		!replace by what it is shadowing
				!may never get here, if the substitution is done by resolvetopname()
			e:=e^.equiv
			goto retry

		when linkid then
			rxerror("FOUND LINK",p)
		esac
	fi
end

global function finddupl(ref strec d, pdupl)ref strec=

if pdupl^.nameid not in [nullid,genfieldid] then		!assume already resolved
	return pdupl
fi
pdupl:=pdupl^.nextdupl

while pdupl do
	if pdupl^.owner=d then
		if pdupl^.nameid in [aliasid,linkid] then
			return d^.equiv
		fi

		return pdupl
	fi
	pdupl:=pdupl^.nextdupl
od

return nil
end

proc resolvedot(ref strec owner,unit p)=
ref strec qdef,rdef,d,newd,e,fielddef
ref unitrec q,r
int nfields,oldallowmod

q:=p^.a			!lhs
r:=p^.b			!rhs
rdef:=r^.def							!st entry for the field

oldallowmod:=allowmodname
allowmodname:=q^.tag=j_name
rx_unit(owner,q)
allowmodname:=oldallowmod

case q^.tag
when j_name then		!continue below

	d:=q^.def
when j_typeconst then	!was type
	d:=q^.def
	goto dotype
else					!assume expression
	rdef:=r^.def
	goto doexprdot
esac

switch d^.nameid
when dllmoduleid,moduleid,typeid,procid,dllprocid then	!M./T./P./C. non-var lhs
dotype::
	newd:=finddupl(d, rdef)

	if newd then					!found
		switch newd^.nameid
		when enumid then			!convert whole thing to constant
			p^.tag:=j_const
			p^.value:=newd^.index
			p^.mode:=tint
		when constid then
			q:=newd^.code			!q is knamedconst unit; q^.c is value
			case q^.tag
			when j_const then
				p^.tag:=j_const
				p^.value:=q^.value
				p^.mode:=newd^.mode
				p^.a:=p^.b:=nil
			else
				rxerror("Rxdot:const?",p)
			esac
		when typeid then
			p^.tag:=j_typeconst
			p^.mode:=newd^.mode
			p^.def:=newd
		when staticid then
			p^.tag:=j_name
			p^.def:=newd

		when procid,dllprocid then
			p^.tag:=j_name
			p^.def:=newd
			p^.a:=p^.b:=nil
			p^.dottedname:=1
		when linkid then
			repeat
				newd:=newd^.equiv
			until newd^.nameid<>linkid
			p^.tag:=j_name
			p^.def:=newd
		else
			cpl namenames[newd^.nameid],,".",,newd^.name
			rxerror("Rxdot:.name not allowed here",p)
		endswitch

	else
		cpl d^.name,,".",,rdef^.name
		rxerror("Can't resolve",p)
	fi

when frameid, staticid, paramid, fieldid, genfieldid then	!X. normal lhs
doexprdot::
	nfields:=0
	fielddef:=nil
	e:=rdef^.nextdupl
	while e do
		case e^.nameid
		when fieldid, constid, procid, typeid, staticid, dllprocid, linkid then
			++nfields
			fielddef:=e				!use this when unique
		esac
		e:=e^.nextdupl
	od

	case nfields
	when 0 then				!no field exists with this name
		cpl rdef^.name
		rxerror("Can't find field",p)
	else					!dupl field
		if rdef^.nameid<>genfieldid then		!mcc converted nullid of generic name to genfield
			rdef^.nameid:=genfieldid			!convert base/nullid name to genfield
			genfieldnames[++ngenfieldnames].def:=rdef
			rdef^.offset:=ngenfieldnames
		fi
	esac

else
	cpl namenames[d^.nameid]
	rxerror("RXDOT:Unknown nameid",p)
endswitch
end

proc fixmode(ref strec owner, p)=
ref strec d,e
int m

m:=p^.mode

if m>=0 then return fi
m:=-m

if ttxmap[m] then				!already fixed
	p^.mode:=ttxmap[m]
	return
fi

if ttnamedefx2[m] then
	rxerror("Can't resolve a:b tentative types yet")
fi

d:=ttnamedefx[m]

e:=resolvetopname(owner,d,ttxmoduleno[m],0)

if e then
	ttxmap[m]:=e^.mode
	p^.mode:=e^.mode

else
	rxerror_s("Can't resolve tentative type: #",d^.name)
fi

end

function fixmode2(ref strec owner, int m)int=
ref strec d,e
[256]char str

if m>=0 then return m fi
m:=-m

if ttxmap[m] then				!already fixed
	return ttxmap[m]
fi

if ttnamedefx2[m] then
	rxerror("2:Can't resolve a:b tentative types yet")
fi

d:=ttnamedefx[m]

IF OWNER=NIL THEN
CPL D^.NAME
RXERROR("FIXMODE2 OWNER=0")
FI

e:=resolvetopname(owner,d,ttxmoduleno[m],0)

if e then
	ttxmap[m]:=e^.mode
	return e^.mode
else
	fprint @&.str,"# in module #, line:#",d^.name,moduletable[ttxmoduleno[m]].name,ttlinenox[m]

	rxerror_s("2:Can't resolve tentative type: #",&.str)
fi
return 0
end

global proc fixusertypes=
ref userxrec p
ref int pmode
int m, rescan,i


for i:=1 to 2 do
	p:=userxmodelist
	rescan:=0

	while p do
		m:=p^.pmode^
		if m<0 then
			m:=fixmode2(p^.owner,m)
			if m<0 and i=2 and ttxmap[abs m] then
				m:=ttxmap[abs m]
			fi
			if m<0 then
				rescan:=1
			else
				p^.pmode^:=m


IF TTTARGET[M]=M THEN
	CPL =TTNAME[M]
	RXERROR("RECURSIVE TYPE?")
FI
			fi
		fi

		p:=p^.nextmode
	od
	if not rescan then exit fi

od
if rescan then
	RXERROR("FIXUSERTYPES PHASE ERROR")
fi

for i to nbaseclasses do
	dobaseclass(i)
od

end

global function resolve_equiv_name(ref strec owner,p)ref strec=
if p^.nameid=fieldid then
	return p
fi

RXERROR("RESOLVE EQUIV FIELD/COMPLEX")

return nil
end

function addframevar(ref strec owner, d, int moduleno, mode)ref strec=
	ref strec e
	e:=getduplnameptr(owner,d,frameid)
	storemode(owner,mode,&e^.mode)
	adddef(owner,e)
	return e
end

proc converteqeq(ref strec owner,ref unitrec p)=
int leftop,rightop
ref unitrec w,y1,y2,z

w:=p^.a				!w is the x=y branch
y1:=w^.b				!split y into two
y2:=duplunit(y1)
z:=p^.b

leftop:=w^.tag
rightop:=p^.tag
p^.tag:=j_andl
p^.b:=createunit2(rightop,y2,z)
rx_unitlist(owner,w)
rx_unitlist(owner,y2)
rx_unitlist(owner,z)
end

global proc evalbinop(ref unitrec p,a,b)=		!EVALBINOP
int64 x,y,z
int xt,yt

unless a^.tag=b^.tag=j_const then
	return
end

xt:=a^.mode
yt:=b^.mode



if xt=yt=treal then
	evalbinop_real(p,a,b)
	return
fi
unless xt=yt=tint then
	return
end unless

x:=a^.value
y:=b^.value

switch p^.tag
when j_add then
	z:=x+y
when j_sub then
	z:=x-y
when j_mul then
	z:=x*y
when j_idiv then
	z:=x/y

when j_makerange then
	z:=y<<32 ior (x iand 0xffff'ffff)
	makenewconst(p,z,trange)

	return
else
	return
end

makenewconst(p,z,tint)
end

proc evalbinop_real(ref unitrec p,a,b)=
real x,y,z

x:=a^.xvalue
y:=b^.xvalue

switch p^.tag
when j_add then
	z:=x+y
when j_sub then
	z:=x-y
when j_mul then
	z:=x*y
when j_div then
	z:=x/y
else
	return
end

makenewconst(p,int64@(z),treal)
end

proc makenewconst(ref unitrec p,int64 value, int t)=	! MAKENEWCONST
int a,b
p^.tag:=j_const
p^.value:=value
p^.mode:=t
p^.a:=nil
p^.b:=nil
end

global proc evalmonop(ref unitrec p)=			!EVALMONOP
int64 a,c
real64 x,z
unit pa

pa:=p^.a

case pa^.tag
when j_const then
when j_typeconst then
	case p^.tag
	when j_bytesize then
		makenewconst(p,ttsize[pa^.mode],tint)
		return			!AT PRESENT, TYPES ARE ONLY PROPERLY RESOLVED AFTER NX PASS???
	when j_len then
		return
	esac
else
	return
esac

a:=pa^.value
x:=pa^.xvalue

case p^.a^.mode
when tint then
	switch p^.tag
	when j_neg then
		c:=-a
	when j_abs then
		c:=abs a
	when j_convert then
		case ttbasetype[p^.mode]
		when treal then

			x:=real(a)
			makenewconst(p,int64@(x),treal)
			return
		else
			return
		esac
	when j_sqrt then
		z:=sqrt(a)
		makenewconst(p,int64@(z),treal)
		return

	else
		return
	end
when treal then
	switch p^.tag
	when j_neg then
		z:=-x
	when j_abs then
		z:=abs x
	when j_convert then
		case ttbasetype[p^.mode]
		when tint then
			makenewconst(p,int64(x),tint)
			return
		else
			return
		esac
	when j_sqrt then
		z:=sqrt(x)

	else
		return
	end
	makenewconst(p,int64@(z),treal)
	return

when tstring then
	switch p^.tag
	when j_len then
		c:=pa^.slength
	else
		return
	end

else
	return
esac

makenewconst(p,c,tint)
end

global proc tx_typetable=
	int i,u

	for i:=tuser to ntypes do
		converttype(i)
	od
end

proc checkconstexpr(unit a)=
if a^.tag=j_const then return fi

rxerror_s("Not const expr: %s",jtagnames[a^.tag])
end

global proc converttype(int m)=			!CONVERTTYPE
ref strec d,owner
int first,a,b,nbits,recordsize,index,length,lower
const int maxfield=256
[maxfield]ref strec fieldlist
int nofields,oldmodno
unit plength, plower


if ttsize[m] then return fi			!assume already done
owner:=ttowner[m]
plower:=ttlowerexpr[m]
plength:=ttlengthexpr[m]
mlineno:=ttlineno[m]

oldmodno:=currmoduleno
currmoduleno:=ttmoduleno[m]

case ttbasetype[m]
when tstring,tstringz then
	ttsize[m]:=ttlength[m]:=getconstint(owner,plength)

when tset then
	ttlength[m]:=getconstint(owner,plength)
	ttsize[m]:=((ttlength[m]-1)/64+1)*8			!in bytes

when tarray then
	if plower then
		ttlower[m]:=getconstint(owner,plower)
	else
		ttlower[m]:=1
	fi
	ttlength[m]:=getconstint(owner,plength)

	case ttbasetype[m]
	when tu1,tu2,tu4 then
		nbits:=ttlength[m]*ttbitwidth[tttarget[m]]
		ttsize[m]:=(nbits-1)/8+1
	else
		converttype(tttarget[m])
		ttsize[m]:=ttlength[m]*ttsize[tttarget[m]]
	esac

when tenum then
	first:=1
	a:=b:=0
	d:=ttnamedef[m]^.deflist
	while d do
		if d^.nameid=enumid then
			if first then
				first:=0
				a:=b:=d^.index
			else
				a := a min d^.index
				b := b max d^.index
			fi
		fi
		d:=d^.nextdef
	od
	ttlower[m]:=a
	ttlength[m]:=b-a+1

when trefpacked then
	converttype(tttarget[m])
	ttsize[m]:=($targetbits=64|8|4)

when trecord then
	nofields:=0

	d:=ttnamedef[m]^.deflist
	while d do
		if d^.nameid=fieldid then
			if ttbasetype[d^.mode]>tvariant then
				cpl ttname[m]
				gerror("Packtype in record")
			fi
			if nofields>=maxfield then
				gerror("CT: too many fields")
			fi
			fieldlist[++nofields]:=d
			converttype(d^.mode)
		fi
		d:=d^.nextdef
	od

	nallfields:=nfields:=0			!should be recursive, provided nested modes processed above
	recordsize:=scanrecord(&fieldlist,nofields)

	ttlower[m]:=1
	ttsize[m]:=recordsize
	ttlength[m]:=nfields

when tstruct then
	nofields:=0
	d:=ttnamedef[m]^.deflist
	while d do
		if d^.nameid=fieldid then

			if ttbasetype[m]=tstruct then
				case ttbasetype[d^.mode]
				when tvariant  then
					cpl ttname[m]
					gerror("Var in struct")
				when tintm,twordm,trefm then
					cpl ttname[m]
					gerror("Intm/etc in struct")
				esac
			else
				if ttbasetype[d^.mode]<>tvariant then
					cpl ttname[m]
					gerror("Packtype in record")
				fi
			fi
			if nofields>=maxfield then
				gerror("CT: too many fields")
			fi
			fieldlist[++nofields]:=d
			converttype(d^.mode)
		fi
		d:=d^.nextdef
	od

	nallfields:=nfields:=0			!should be recursive, provided nested modes processed above
	index:=nofields
	recordsize:=scanstruct(1,&fieldlist,nofields,index,0,2)

    d:=ttnamedef[m]
    case d^.attribs.ax_align
    when 2 then while recordsize iand 1 do ++recordsize od
    when 4 then while recordsize iand 3 do ++recordsize od
    when 8 then while recordsize iand 7 do ++recordsize od
	esac

	ttlower[m]:=1
	ttsize[m]:=recordsize
	ttlength[m]:=nfields

esac
currmoduleno:=oldmodno
end

function scanstruct(int fstruct,ref[]ref strec flist,
					int flistlen,&index,nextoffset,countmode)int=		!SCANSTRUCT
int startoffset,maxsize,exitflag,size,star,alignment
ref strec d,e
uflagsrec flags

startoffset:=nextoffset
maxsize:=0
exitflag:=0

while not exitflag and index>=1 do
	d:=flist^[index]

	flags:=d^.uflags
	case flags.codes[1]
	when 'S' then
		shiftflagsleft(&d^.uflags)
		size:=scanstruct(1,flist,flistlen,index,nextoffset,countmode)

	when 'U' then
		shiftflagsleft(&d^.uflags)
		size:=scanstruct(0,flist,flistlen,index,nextoffset,(countmode|1|0))

	when 'E' then
		shiftflagsleft(&d^.uflags)
		if d^.uflags.ulength=0 then --index fi
		exitflag:=1
		size:=0

	when '*' then				!normal file where E flags follow
		shiftflagsleft(&d^.uflags)
		star:=1
		goto dofield

	else					!an actual field
		star:=0
dofield::
		if d^.attribs.ax_at then
			e:=d^.equiv
			d^.offset:=e^.offset

			size:=0
		elsif d^.attribs.ax_equals then
			gerror("Can't init a field")
		else
			size:=ttsize[d^.mode]
			alignment:=d^.attribs.ax_align
			if alignment=255 then
				alignment:=max(size,8)
			fi
			case alignment
			when 2 then while nextoffset iand 1 do ++nextoffset od
			when 4 then while nextoffset iand 3 do ++nextoffset od
			when 8 then while nextoffset iand 7 do ++nextoffset od
			esac

			d^.offset:=nextoffset
			if countmode then
				++nfields
			fi
		fi
		if not star then --index fi
		++nallfields
	esac

	if fstruct then
		nextoffset+:=size
	else
		maxsize :=max(maxsize,size)
		countmode:=0
	fi
od

return (fstruct|nextoffset-startoffset|maxsize)
end

function scanrecord(ref[]ref strec flist,int flistlen)int=

int size,index,nextoffset
ref strec d,e

nextoffset:=0

for index:=flistlen downto 1 do
	d:=flist^[index]
	if d^.attribs.ax_at then
		e:=d^.equiv
		d^.offset:=e^.offset
		size:=0
	elsif d^.attribs.ax_equals then
		gerror("Can't init a field")
	else
		size:=varsize

		d^.offset:=nextoffset
		++nfields
	fi
	++nallfields

	nextoffset+:=size
od

return nextoffset
end

proc shiftflagsleft(ref uflagsrec flags)=
int i

if flags^.ulength then
	for i:=1 to flags^.ulength-1 do
		flags^.codes[i]:=flags^.codes[i+1]
	od
	flags^.codes[flags^.ulength]:=0
	--flags^.ulength
fi
end

function getconstint(ref strec owner,ref unitrec a)int=

if a=nil then
	rxerror("GETCONSTINT A=NIL")
fi

rx_unit(owner, a)

checkconstexpr(a)

case a^.mode
when tint,tword then
	if ttsize[a^.mode]=16 then
		RXERROR("GETCONSTINT/128")
	fi
	return a^.value
when treal then
	return a^.xvalue
else
	cpl strmode(a^.mode)
	rxerror("Getconstint: not int32/64")
esac
return 0
end

global function checkdict(ref unitrec p)int=
int nkeywords, isconst
ref unitrec q
int n

if p^.tag<>j_makesetlist then
	return 0
fi

n:=nkeywords:=0
isconst:=1


q:=p^.a
while q do
	++n
	case q^.tag
	when j_keyvalue then
		++nkeywords
	esac
	q:=q^.nextunit
od

if nkeywords=0 then return 0 fi

if nkeywords<>n then
	rxerror("Dict: not all key:values")
fi
p^.tag:=j_makedict


return 1
end

global proc checkconstlist(ref unitrec p)=
ref unitrec q
ref strec stname
int n

q:=p^.a
n:=0

while q do
	++n
	case q^.tag
	when j_const then		!add nested autovars later
	when j_name then
		if not q^.def^.attribs.ax_autovar then
			return
		fi
	when j_makerange then
		if q^.a^.tag<>j_const or q^.b^.tag<>j_const then
			return
		fi
	else				!non-const; have to evaluate whole thing on each access
		return
	esac
	q:=q^.nextunit
od

if n=0 then			!()/[] don't need pre-evaluation
	return
fi

stname:=getavname(stmodule,staticid)
stname^.mode:=tvariant
stname^.code:=createunit2(p^.tag,p^.a,p^.b)		!j_makelist/makesetlist

stname^.attribs.ax_equals:=1

p^.tag:=j_name
p^.def:=stname
end

proc duplfield(ref strec p,q)=

if p^.code then
	serror("DUPLFIELD")
fi
q^.attribs:=p^.attribs
q^.address:=p^.address
q^.uflags:=p^.uflags		!for ^.uflags
q^.mode:=p^.mode
end

proc dobaseclass(int baseclassindex)=
ref strec sttype,d,e,newd
int baseclass,normalexit

baseclass:=baseclasstable[baseclassindex]
sttype:=baseclassdef[baseclassindex]

	d:=ttnamedef[baseclass]^.deflist
	while d do
		e:=sttype^.deflist
		normalexit:=1
		while e do
			if eqstring(d^.name,e^.name) then
				normalexit:=0
				exit
			fi
			e:=e^.nextdef
		od
		if normalexit then
			case d^.nameid
			when procid,linkid then
				newd:=getduplnameptr(sttype,d,linkid)
				newd^.equiv:=d
			else
				newd:=getduplnameptr(sttype,d,d^.nameid)
				duplfield(d,newd)
			esac
			adddef(sttype,newd)
		fi
		d:=d^.nextdef
	od
end
=== qc_pclgen.m 36/56 ===
import mlib
import clib
import oslib

import var_types
import var_decls
import qc_support
import qc_tables
import qc_lib
import qc_lex
import pq_common
import qc_pcllib

const kjumpt = 1
const kjumpf = 0

const maxswitchrange=512

int nprocframevars		!set up at procentry
ref strec stretval			!set up at procentry
int retindex
int nprocparamvars		!needed for $getparam(0); excludes $retval

const maxloopindex=20
[maxloopindex,4]ref int loopstack
[maxloopindex]int trylevelstack
int loopindex=0
int looptrylevel			!return by findlooplabel

int trylevel=0

const int maxparams=64
const int maxlocals=256

ref strec st_startproc			!strec of s$startproc(), or nil
const $startprocname="$startproc"

tabledata []int pcl_jcodes, []byte pcl_nopnds, []int pcl_kcodes=
	(j_add,			2,	kadd),
	(j_sub,			2,	ksub),
	(j_mul,			2,	kmul),
	(j_div,			2,	kdiv),
	(j_idiv,		2,	kidiv),
	(j_rem,			2,	krem),
	(j_divrem,		2,	kdivrem),
	(j_eq,			2,	keq),
	(j_ne,			2,	kne),
	(j_lt,			2,	klt),
	(j_le,			2,	kle),
	(j_gt,			2,	kgt),
	(j_ge,			2,	kge),
	(j_isequal,		2,	kisequal),
	(j_iand,		2,	kiand),
	(j_ior,			2,	kior),
	(j_ixor,		2,	kixor),
	(j_inot,		2,	kinot),
	(j_shl,			2,	kshl),
	(j_shr,			2,	kshr),
	(j_in,			2,	kin),
	(j_notin,		2,	knotin),
	(j_inrev,		2,	kinrev),
	(j_min,			2,	kmin),
	(j_max,			2,	kmax),
	(j_power,		2,	kpower),
	(j_atan2,		2,	katan2),
	(j_concat,		2,	kconcat),
	(j_append,		2,	kappend),

	(j_neg,			1,	kneg),
	(j_abs,			1,	kabs),
	(j_notl,		1,	knot),
	(j_istruel,		1,	kistrue),
	(j_lwb,			1,	klwb),
	(j_upb,			1,	kupb),
	(j_len,			1,	klen),
	(j_bounds,		1,	kbounds),
	(j_isvoid,		1,	kisvoid),
	(j_isdef,		1,	kisdef),

	(j_isint,		1,	kisint),
	(j_isreal,		1,	kisreal),
	(j_isarray,		1,	kisarray),
	(j_isrange,		1,	kisrange),
	(j_isstring,	1,	kisstring),
	(j_isrecord,	1,	kisrecord),
	(j_isset,		1,	kisset),
	(j_ispointer,	1,	kispointer),
	(j_ismutable,	1,	kismutable),
	(j_gettype,		1,	ktype),
	(j_getbasetype,	1,	kbasetype),
	(j_getelemtype,	1,	kelemtype),
	(j_bitwidth,	1,	kbits),
	(j_bytesize,	1,	kbytes),
	(j_minvalue,	1,	kminval),
	(j_maxvalue,	1,	kmaxval),

	(j_chr,			1,	kchr),
	(j_asc,			1,	kasc),
	(j_sqr,			1,	ksqr),
	(j_cube,		1,	kcube),
	(j_sqrt,		1,	ksqrt),
	(j_sign,		1,	ksign),
	(j_sin,			1,	ksin),
	(j_cos,			1,	kcos),
	(j_tan,			1,	ktan),
	(j_asin,		1,	kasin),
	(j_acos,		1,	kacos),
	(j_atan,		1,	katan),
	(j_ln,			1,	kln),
	(j_lg,			1,	klg),
	(j_log,			1,	klog),
	(j_exp,			1,	kexp),
	(j_round,		1,	kround),
	(j_ceil,		1,	kceil),
	(j_fract,		1,	kfract),
	(j_floor,		1,	kfloor),

	(j_addto,		2,	kaddto),
	(j_subto,		2,	ksubto),
	(j_multo,		2,	kmulto),
	(j_divto,		2,	kdivto),
	(j_negto,		2,	knegto),
	(j_iandto,		2,	kiandto),
	(j_iorto,		2,	kiorto),
	(j_ixorto,		2,	kixorto),
	(j_shlto,		2,	kshlto),
	(j_shrto,		2,	kshrto),
	(j_minto,		2,	kminto),
	(j_maxto,		2,	kmaxto),
	(j_concatto,	2,	kconcatto),
	(j_appendto,	2,	kappendto),

	(j_preincrx,	1,	kincrload),
	(j_postincrx,	1,	kloadincr),
	(j_predecrx,	1,	kdecrload),
	(j_postdecrx,	1,	kloaddecr),

	(j_tostr,		1,	ktostr),
	(j_mixed,		1,	kmixed),
	(j_new,			1,	knew),
	(j_convert,		1,	khardconv),
	(j_index,		2,	kpushix),
	(j_dotindex,	2,	kpushdotix),

	(0,				0,	0)
end
int noperands			!set by getpclop()
int64 dummyop=0			!target for lastopc

proc evalexpr(ref unitrec p)=
int oldmlineno,opc,n,m,t,lowerx,lab1,lab2,oldmodno
ref unitrec a,b,c
ref strec d,owner
int64 x,aa
ichar s
real fsize
[50]ref unitrec mlist
int i,nmult

a:=p^.a
b:=p^.b
c:=p^.c

oldmlineno:=mlineno
oldmodno:=currmoduleno
mlineno:=p^.lineno
currmoduleno:=p^.moduleno


switch p^.tag
when j_print, j_println then
	do_print(p,a,b)

when j_fprint,j_fprintln then
	do_fprint(p,a,b,c)

when j_read, j_readln then
	do_read(p,a,b)
when j_assign, j_deepcopy then
	do_assign(p,a,b)

when j_to then
	do_to(p,a,b,c)

when j_while then
	do_while(p,a,b,c)

when j_repeat then
	do_repeat(p,a,b)

when j_forstep, j_forup, j_fordown then
	do_forstep(p,a,b,c)

when j_forall, j_foreach, j_forallrev, j_foreachrev then
	do_forall(p,a,b,c)

when j_do then
	do_do(p,a)

when j_cfor then
	do_cfor(p,a,b)

when j_if then
	do_if(p,a,b,c)

when j_longif then
	do_longif(p,a,b)

when j_callproc then
	do_callproc(p,a,b)

when j_callhostproc, j_callhostfn then
	do_callhostproc(p,a)

when j_callapplproc then
	do_callappl(p,a,b,0)

when j_callapplfn then
	do_callappl(p,a,b,1)

when j_return then
	do_return(p,a)

when j_preincr, j_predecr, j_postincr, j_postdecr then
	do_preincr(p,a)

when j_swap then
	evalref(a)
	evalref(b)
	genpc(kswap)

when j_exit, j_restart, j_redo, j_next then
	do_exit(p,a)

when j_labeldef then
	lastopc:=cast(&dummyop)
	d:=p^.def
	if d^.index=0 then
		d^.index:=pcindex+1
	else
		lab1:=d^.index			!.index is 16-bit field; definefwdlabel uses ref int
		definefwdlabel(lab1)
	fi


when j_goto then
	do_goto(p,a)

when j_stop then
	if a then
		evalexpr(a)
	else
		genpc(kpushz_void)
	fi
	genpc(kstop)

when j_switch, j_doswitch then
	do_switch(p,a,b,c)

when j_case, j_docase then
	do_case(p,a,b,c)

when j_try then
	do_try(p,a,b)

when j_raise then
	evalexpr(a)
	genpc(kraise)

when j_applyop then
	do_applyop(p,a,b,c)

when j_callmproc then
	do_callmproc(p,a,b,0)

when j_eval then
	evalexpr(a)
	genpc_int(kfree,1)

when j_const then
	x:=p^.value
	switch p^.mode
	when tstring then
		s:=p^.svalue
		if p^.slength=0 then
			genpc(kpushz_str)
		else
			genpc_str(kpush_cs,s,p^.slength)
		fi

	when tint,ti64 then
		genpc_int(kpush_ci,p^.value)

	when treal,tr64 then
		if p^.xvalue=0.0 then
			genpc_int(kpushz,treal)
		else
			genpc_int(kpush_cr,p^.value)
		fi
	when tword,tu64 then
		genpc_int(kpush_cw,p^.value)

	when trange then
		genpc_int(kpush_cn,p^.value)

	else
		cpl ttname[p^.mode]
		gerror("CONST: Can't push this type",p)
	endswitch

when j_name then
	d:=p^.def
	switch d^.nameid
	when procid then
		genpc_s(kpush_ap,d)

	when staticid then
		genpc_s(kpush_m,d)

	when frameid then
		genpc_s(kpush_f,d)

	when paramid then
		genpc_s(kpush_f,d)
		if d^.attribs.ax_byrefmode then	!insert extra dereference
			genpc(kpushptr)
		fi

	when labelid then
		if d^.index=0 then
			d^.index:=createfwdlabel()
		fi
		genpc_lab(kpush_al,d^.index)

	when dllprocid then
		genpc_s(kpush_ad,d)

	else
		println namenames[d^.nameid],d^.name
		gerror("Name?",p)
	endswitch

when j_andand,j_add,j_sub,j_mul,j_div,j_fdiv,j_ddiv,
					j_rem,j_iand,j_ior,j_ixor,j_shl,j_shr,j_in,j_notin,j_inrev,j_min,j_max,j_addptr,j_subptr,
					j_concat,j_append,j_atan2,j_power,j_isequal,j_divrem then
dobinop::
	if b=nil then
		gerror("Binop: opnd missing",p)
	fi

	opc:=getpclop(p^.tag)
	evalexpr(a)
	evalexpr(b)
	genpc(opc)

when j_eq,j_ne,j_lt,j_le,j_gt,j_ge then
	if b=nil then
		gerror("Binop: opnd missing",p)
	fi


	opc:=getpclop(p^.tag)
	evalexpr(p^.a)
	evalexpr(p^.b)
	genpc(opc)

when j_addto,j_subto,j_multo,j_divto,j_idivto,j_fdivto,j_iandto,j_iorto,j_ixorto,
	 j_shlto,j_shrto,j_minto,j_maxto,j_appendto,j_concatto then
	opc:=getpclop(p^.tag)
	evalref(a)
	evalexpr(b)
	genpc(opc)

when j_idiv then
	do_idiv(a,b)

when j_andl then
	do_and(a,b)

when j_orl then
	do_or(a,b)

when j_xorl then
	evalexpr(a)
	if not islogical(a) then
		genpc(kistrue)
	fi
	evalexpr(b)
	if not islogical(a) then
		genpc(kistrue)
	fi
	genpc(kixor)

when j_ptr then			!de-ref
	if a^.tag=j_const then
		gerror("pushptr/const")
	fi
	evalexpr(a)
	genpc(kpushptr)

when j_notl then
	evalexpr(a)
	if not islogical(a) then
		genpc(kistrue)
	fi
	genpc(knot)

when j_bytesize then
	if a^.tag=j_typeconst then
		m:=a^.mode
		if ttbasetype[m]>=tu1 and ttbasetype[m]<=tu4 then
			fsize:=ttbitwidth[m]/8.0
			genpc_int(kpush_cr,int64@(fsize))
		else
			genpushint(ttsize[m])
		fi
	else
		evalexpr(a)
		genpc(getpclop(j_bytesize))
	fi
when j_bitwidth then

	if a^.tag=j_typeconst then
		m:=a^.mode
		genpushint(ttbitwidth[m])
	else
		evalexpr(a)
		genpc(getpclop(j_bitwidth))
	fi

when j_minvalue then

	if a^.tag=j_typeconst then
		case ttbasetype[a^.mode]
		when tword,tu1,tu4,tu8,tu16,tu32,tu64 then
			aa:=0
		when ti8 then aa:=-128
		when ti16 then aa:=-32768
		when ti32 then aa:=-0x8000'0000
		when ti64,tint then aa:=0x8000'0000'0000'0000
		else
			goto dominval
		esac
	else
dominval::
		evalexpr(a)
		genpc(getpclop(j_minvalue))
	fi

when j_maxvalue then
	if a^.tag=j_typeconst then
		opc:=kpush_ci
		case ttbasetype[a^.mode]
		when tu1 then aa:=1
		when tu2 then aa:=3
		when tu4 then aa:=15
		when tu8 then aa:=255
		when tu16 then aa:=65535
		when tu32 then aa:=0xFFFF'FFFF
		when tu64,tword then aa:=0xFFFF'FFFF'FFFF'FFFF; opc:=kpush_cw
		when ti8 then aa:=127
		when ti16 then aa:=32767
		when ti32 then aa:=0x7FFF'FFFF
		when ti64,tint then aa:=0x7FFF'FFFF'FFFF'FFFF
		when twordm then
			aa:=($targetbits=32|0xFFFF'FFFF|0xFFFF'FFFF'FFFF'FFFF)
		else
			goto domaxval
		esac
		if opc=kpush_ci then
			genpushint(aa)
		else
			genpc_int(opc,aa)
		fi
	else
domaxval::
		evalexpr(a)
		genpc(getpclop(j_maxvalue))
	fi

when j_neg,j_abs,j_inot,j_chr,j_asc,j_sqrt,j_sqr,j_cube,j_sign,j_sin,j_cos,j_tan,j_asin,
					j_acos,j_atan,j_ln,j_lg,j_log,j_exp,j_round,j_floor,j_ceil,j_fract,j_fmod, j_lwb,
					j_upb,j_len,j_bounds, j_gettype,j_getbasetype,j_getelemtype,
					j_isvoid,j_isdef,j_isint,j_isreal,j_isstring,j_isrange,j_islist,j_isrecord,j_isarray,
					j_isset,j_ispointer,j_min1,j_max1,j_istruel, j_isnone,
					j_ismutable then
	opc:=getpclop(p^.tag)
	evalexpr(a)
	genpc(opc)

when j_dictitems then
	genpc(kpushz_void)
	evalexpr(a)
	callhostfn(host_dictitems,1)

when j_callfn then
	if a^.tag=j_name then
		d:=a^.def
		if d^.mode=tvoid and d.nameid<>applprocid then
			cpl d^.name
			gerror("Proc return value")
		end
	fi
	do_callproc(p,a,b)

when j_callmfn then
	do_callmproc(p,a,b,1)
when j_preincrx then
	evalref(a)
	genpc(kincrload)

when j_postincrx then
	evalref(a)
	genpc(kloadincr)

when j_predecrx then
	evalref(a)
	genpc(kdecrload)

when j_postdecrx then
	evalref(a)
	genpc(kloaddecr)


when j_index,j_slice then			!p.a[p.b]
	evalexpr(a)
	evalexpr(b)
	genpc(kpushix)

when j_dotindex,j_dotslice then		!p.a.[p.b]
	evalexpr(a)
	evalexpr(b)
	genpc(kpushdotix)

when j_byteindex then			!p.a.<type>[p.b]
	evalexpr(a)
	evalexpr(b)
	genpc_int(kpushbyteix,p^.mode)

when j_keyindex,j_dotkeyindex then		!p.a{p.b}
	evalexpr(b)
	evalexpr(a)
	if c then					!default value
		evalexpr(c)
		genpc(kpushkeyixd)
	else
		genpc(kpushkeyix)
	fi

when j_dot then
	evalexpr(a)		!lhs, should be a record
	d:=b^.def		!d should be field name
	case d^.nameid
	when procid, dllprocid then
		owner:=d^.owner
		case owner^.nameid
		when moduleid,dllmoduleid then		!set owner type to 0
			t:=0	!(won't be able to distinguish between different modules, but can't
					!specify the module in the source anyway
		else
			t:=owner^.mode
		esac
		genpc_int(kpushdotm,t)
		genopnd_s(d)
	when typeid then
		genpc_int2(kpushdott,d^.owner^.mode,d^.mode)
	else					!assume genfieldid
		genpc_int(kpushdot,d^.offset)
	esac

when j_makelist,j_makeconstr then
	if b then
		lowerx:=getconstvalue(b,100)
	else
		lowerx:=1
	fi
	if a=nil then
		if lowerx=1 then
			genpc(kpushz_list)
		else
			genpc_int(kpushz_listl,lowerx)
		fi
	else
		n:=0
		while a do
			++n
			evalexpr(a)
			a:=a^.nextunit
		od
		genpc_int2(kmakelist,n,lowerx)
	fi

when j_makesetlist then
	if a=nil then
		genpc(kpushz_set)
	else
		n:=0
		while a do
			++n
			evalexpr(a)
			a:=a^.nextunit
		od
		genpc_int(kmakeset,n)
	fi

when j_makedict then
	n:=0
	while a do
		++n
		evalexpr(a)
		a:=a^.nextunit
	od
	genpc_int(kmakedict,n)

when j_makerange then
	evalexpr(a)
	evalexpr(b)
	genpc(kmakerange)

when j_assignx,j_deepcopyx then
	do_assign(p,a,b)

when j_ifx then
	lab1:=createfwdlabel()				!dest label of main condition (to end of if, or start if else)
	lab2:=createfwdlabel()

	genjumpcond(kjumpf,a,lab1)
	evalexpr(b)
	genjumpl(lab2)
	definefwdlabel(lab1)
	evalexpr(c)
	genpc(knop)
	definefwdlabel(lab2)

when j_convert then
	do_convert(p^.mode,a)

when j_typepun then
	evalexpr(a)
	genpc_int(ksoftconv,p^.mode)

when j_ptrto then
	if a^.tag=j_ptr then			!^a^ cancel out (a might be byref param)
		evalexpr(a^.a)
	else
		evalref(a)
	fi

when j_addrof then
	evalref(a)
	genpc(kconvptr)

when j_typeconst then
	genpc_int(kpush_t,p^.mode)

when j_selectx then
	do_selectx(a,b,c)

when j_exprlist then
	while a and a^.nextunit do
		do_stmt(a)
		a:=a^.nextunit
	od
	evalexpr(a)

when j_listcomp then
	genpc(kpushz_list)
	do_stmt(a)

when j_typeval then
	genpc_int(kpushz,p^.mode)

when j_keyvalue then		!push values as pairs, to be dealt with by makedict
	evalexpr(a)
	evalexpr(b)

when j_longint then
	genpc_str(kpush_cs,p^.svalue,p^.slength)
	genpc_int(khardconv,tlongint)

when j_sprint then
	do_print(p,a,b)

when j_sfprint then
	do_fprint(p,a,b,c)

when j_clamp then
	do_clamp(a,b,c)

when j_applyopx then
	do_applyopx(a,b,c)

when j_operator then
	opc:=getpclop(p^.opcode)

	genpc_int2(kpush_op,opc,noperands)

when j_multexpr then
	nmult:=0
	while a do
		if nmult>=mlist.len then gerror("Too many mult elems") fi
		mlist[++nmult]:=a
		a:=a^.nextunit
	od
	for i:=nmult downto 1 do
		do_stmt(mlist[i])
	od

else
	cpl jtagnames[p^.tag]
	gerror("E:CAN'T EVALUATE",p)
end
mlineno:=oldmlineno
currmoduleno:=oldmodno
end

proc do_stmt(unit p)=evalexpr(p) end

global function codegen(int n)int=
static modulerec m
ref strec d,e

m:=moduletable[n]
stmodule:=m.stmodule
linetable:=m.linetable

initgenpcl(m.sourcelen)

d:=m.stmodule^.deflist

while d do
	if d^.nameid=procid then
		do_procdef(d)

		e:=d^.deflist
		while e do
			if e^.nameid=procid then
				do_procdef(e)
			fi
			e:=e^.nextdef
		od

	elsif d^.nameid=typeid then
		e:=d^.deflist
		while e do
			if e^.nameid=procid then
				do_procdef(e)
			fi
			e:=e^.nextdef
		od
	fi
	d:=d^.nextdef
od

genstartproc(m.stmodule)
genpc(kendmodule)

m.pccode:=pccode
m.npccode:=npccode
m.pcindex:=pcindex
m.linetable:=linetable

moduletable[n]:=m

return 1
end

proc scanidata(ref strec p)=			!SCANIDATA
ref strec d
const maxidata=30000
[maxidata]ref strec defs
int i,ndefs

genidata(p)

d:=p^.deflist
if not d then return fi
ndefs:=0

while d do
	++ndefs
	if ndefs>maxidata then
		gerror("Too many idata defs")
	fi
	defs[ndefs]:=d
	d:=d^.nextdef
od

for i:=ndefs downto 1 do
	d:=defs[i]
	if d^.attribs.ax_autovar then
		scanidata(d)
	fi
od

for i:=ndefs downto 1 do
	d:=defs[i]
	if not d^.attribs.ax_autovar then
		scanidata(d)
	fi
od
end

proc genidata(ref strec p)=			!GENIDATA
ref unitrec e

if p^.nameid=moduleid then return fi		!done in header

if getscope(p)=importscope then			!no idata, EXCEPT MAYBE CONSTANTS?
	return
fi

if p^.nameid=staticid then
	e:=p^.code
	if e=nil then
		return
	fi
	evalexpr(e)
	genpc_s(kzpop_m+p^.attribs.ax_frame,p)
fi

end

proc initgenpcl(int sourcelen)=			!INITGENPCL
ref strec dgen

initpcl(max(sourcelen/2,1000))

loopindex:=0
stcurrproc:=nil

st_startproc:=getduplnameptr(stmodule,addnamestr($startprocname),procid)
st_startproc^.attribs.ax_global:=1
st_startproc^.mode:=tvoid
adddef_nodupl(stmodule,st_startproc)

end

global proc doprogramstartup=
int i,m
ref strec d

initpcl(1000)

for i:=1 to nmodules do
	m:=moduleinitorder[i]

	d:=finddefstr(moduletable[m].stmodule,$startprocname)
	if d=nil then
		cpl moduletable[m].name
		gerror("Can't find $startproc")
	fi
	genpc_s(kcall,d)
	genopnd_int(0)
od

stopseq:=&pccode^[pcindex+1]				!used as dest for runproc()

genpushint(0)
genpc(kstop)

raiseseq:=&pccode^[pcindex+1]		!used by raise_error()
genpc(kraise)						!bytecode handler step pcptr+n but it is not known
genpc(kraise)						!what n will be, so make sure it will point here!
genpc(kraise)
genpc(kraise)

genpc(kendmodule)
moduletable[0].pccode:=pccode
moduletable[0].npccode:=npccode
moduletable[0].pcindex:=pcindex
moduletable[0].linetable:=linetable

end

proc do_block(ref unitrec p)=			!DO_BLOCK
ref unitrec q

q:=p^.a
while q do
	do_stmt(q)
	q:=q^.nextunit
od
end

proc do_print(ref unitrec p,a,b)=		!DO_PRINT
int issprint
ref unitrec x

issprint:=p^.tag=j_sprint

if issprint then
	callhostfn(host_strstartprint)
else
	if a then
		evalexpr(a)
		callhostfn(host_startprint)
	else
		callhostfn(host_startprintcon)
	fi
fi

x:=b

while x do
	case x^.tag
	when j_fmtitem then
		evalexpr(x^.b)
		evalexpr(x^.a)
		callhostfn(host_print)
	when j_nogap then
		callhostfn(host_printnogap)
	else
		genpc(kpushz_void)
		evalexpr(x)
		callhostfn(host_print)
	esac
	x:=x^.nextunit
od

if p^.tag=j_println then
	callhostfn(host_println)
fi
if issprint then
	genpc(kpushz_void)
	callhostfn(host_strendprint,1)
else
	callhostfn(host_endprint)
fi
end

proc do_fprint (ref unitrec p,a,b,c)=		!DO_FPRINT
int issfprint
ref unitrec x

issfprint:=p^.tag=j_sfprint

if issfprint then
	callhostfn(host_strstartprint)
else
	if a then
		evalexpr(a)
		callhostfn(host_startprint)
	else
		callhostfn(host_startprintcon)
	fi
fi

evalexpr(b)					!format string
callhostfn(host_setformat)

x:=c
while x do
	case x^.tag
	when j_fmtitem then
		evalexpr(x^.b)
		evalexpr(x^.a)
		callhostfn(host_print)
	when j_nogap then
		callhostfn(host_printnogap)
	else
		genpc(kpushz_void)
		evalexpr(x)
		callhostfn(host_print)
	esac
	x:=x^.nextunit
od

if p^.tag=j_fprintln then
	callhostfn(host_println)
fi
if issfprint then
	genpc(kpushz_void)
	callhostfn(host_strendprint,1)
else
	callhostfn(host_endprint)
fi
end

proc do_read (ref unitrec p,a,b)=		!DO_READ
ref unitrec x,xloop

if p^.tag=j_readln then
	if a then
		evalexpr(a)
		callhostfn(host_readln)
	else
		genpc(kpushz_void)
		callhostfn(host_readln)
	fi
fi

xloop:=b
while xloop do
	x:=xloop
	genpc(kpushz_void)
	if x^.tag=j_fmtitem then
		evalexpr(x^.b)
		callhostfn(host_sread,1)
		x:=x^.a
	else
		genpc(kpushz_void)
		callhostfn(host_sread,1)
	fi
	if x^.tag=j_name then
		genpc_s(kpop_m+x^.def^.attribs.ax_frame,x^.def)
		x^.def^.attribs.ax_used:=1
	else
		evalref(x)
		genpc(kpopptr)
	fi
	xloop:=xloop^.nextunit
od
end

proc do_assign (ref unitrec p,a,b)=		!DO_ASSIGN
int fstore,n,mult
ref unitrec q
ref strec d

fstore:=(p^.tag=j_assignx) ior (p^.tag=j_deepcopyx)		!also called for in-expression assignments

evalexpr(b)		!rhs to stack

case p^.tag
when j_deepcopy, j_deepcopyx then
	genpc(kcopy)
esac

if a^.tag=j_multexpr then
	a:=a^.a
	mult:=1
else
	mult:=0
fi

while a do
switch a^.tag
when j_name then
	d:=a^.def
	case d^.nameid
	when frameid then
		d^.attribs.ax_used:=1
	when staticid then
	when paramid then
		if d^.attribs.ax_byrefmode then
			genpc_s(kpush_f,d)
			genpc((fstore|kstoreptr|kpopptr))
			return
		fi
	else
		cpl namenames[d^.nameid],d^.name
		gerror("Can't assign to")
	esac

	genpc_s((fstore|kstore_m|kpop_m)+d^.attribs.ax_frame,d)

when j_index,j_dotindex,j_slice,j_dotslice,j_keyindex,j_dotkeyindex,j_byteindex then
	evalref(a)
	genpc((fstore|kstoreptr|kpopptr))

when j_makelist then			!assign to multiple destinations
	q:=a^.a
	if q=nil then
		gerror("assign to ()?")
	else
		n:=0
		while q do
			++n
			evalref(q)
			q:=q^.nextunit
		od
		genpc_int2(kmakelist,n,1)
	fi
	genpc((fstore|kstoreptr|kpopptr))	!(storeptr unlikely to work with multiple destinations)

when j_dot then
	evalref(a^.a)		!lhs, should be a record
	d:=a^.b^.def		!d should be field name
	genpc_int(kpushdotref,d^.offset)
	genpc((fstore|kstoreptr|kpopptr))	!(storeptr unlikely to work with multiple destinations)

when j_ptr then
	evalref(a)
	genpc((fstore|kstoreptr|kpopptr))	!(storeptr unlikely to work with multiple destinations)

when j_ifx then
	evalref(a)
	genpc((fstore|kstoreptr|kpopptr))	!(storeptr unlikely to work with multiple destinations)

else
	cpl jtagnames[a^.tag]
	gerror("DOASSIGN?",p)
endswitch
if mult then
	a:=a^.nextunit
else
	exit
fi
od

end

proc do_to (ref unitrec p,a,b,c)=		!DO_TO
int lab_a,lab_b,lab_c,lab_d
ref strec temp


lab_a:=definelabel()
temp:=c^.def
evalexpr(a)
genpc_s(kzpop_f,temp)

lab_b:=createfwdlabel()
lab_c:=createfwdlabel()
lab_d:=createfwdlabel()
stacklooplabels(&lab_a,&lab_b,&lab_c,&lab_d)

if a^.tag<>j_const then			!assume const limit is non-zero
	genpc_s(kpush_f,temp)
	genpc_int(kpush_ci,0)
	genpc_lab(kjumple,lab_d)

elsif a^.value<=0 then		!const <=0, skip body
	genpc_lab(kjump,lab_d)
fi

definefwdlabel(lab_b)
do_block(b)			!main body
definefwdlabel(lab_c)

genpc_lab(kto_f,lab_b)
genopnd_s(temp)

definefwdlabel(lab_d)
unstacklooplabels()
end

proc do_while (ref unitrec p,a,b,c)=		!DO_WHILE
int lab_ab,lab_c,lab_d

lab_ab:=createfwdlabel()
lab_c:=createfwdlabel()
lab_d:=createfwdlabel()

stacklooplabels(&lab_ab, &lab_ab, &lab_c, &lab_d)

genjumpl(lab_c)		!direct to condition code which is at the end

definefwdlabel(lab_ab)

do_block(b)		!body
definefwdlabel(lab_c)

genjumpcond(kjumpt,a,lab_ab)

if c then
	do_block(c)		!optional else part
fi

definefwdlabel(lab_d)
unstacklooplabels()
end

proc do_repeat (ref unitrec p,a,b)=		!DO_REPEAT
int lab_ab,lab_c,lab_d

lab_ab:=definelabel()
lab_c:=createfwdlabel()
lab_d:=createfwdlabel()
stacklooplabels(&lab_ab, &lab_ab, &lab_c, &lab_d)

do_block(a)

definefwdlabel(lab_c)

genjumpcond(kjumpf,b,lab_ab)
definefwdlabel(lab_d)
unstacklooplabels()
end

proc do_forstep (ref unitrec p,pvar,pbody,pautovar)=		!DO_FORSTEP
ref unitrec pfrom, pto, pstep, pelse,plimit
ref strec dvar, limitvar
int lab_a,lab_b,lab_c,lab_d,lab_e,opc
int step, fromval, limit, jumpinto

pfrom:=pvar^.nextunit
pto:=pfrom^.nextunit
pstep:=pto^.nextunit

pelse:=pbody^.nextunit
dvar:=pvar^.def
dvar^.attribs.ax_used:=1


case p^.tag
when j_forup then
	step:=1

when j_fordown then
	step:=-1
else
	step:=getconstvalue(pstep,101)
	if step<>1 and step<>-1 then
		gerror("Can't do for with odd step")
	fi
esac

jumpinto:=1			!assume jumping straight into increment

lab_a:=definelabel()
lab_b:=createfwdlabel()
lab_c:=createfwdlabel()
lab_d:=createfwdlabel()
lab_e:=(pelse|createfwdlabel()|lab_d)
stacklooplabels(&lab_a,&lab_b,&lab_c,&lab_d)

if pfrom^.tag=j_const then		!can incr/decr directly
	fromval:=pfrom^.value
	if pto^.tag=j_const then
		limit:=pto^.value
		pto^.mode:=tint
		if (step=-1 and fromval>=limit) or (step=1 and fromval<=limit) then 	!at least 1 iteration
			jumpinto:=0
		fi
	fi
	if jumpinto then
		if step<0 then
			++fromval
		else
			--fromval
		fi
		pfrom^.value:=fromval
	fi
	genpushint(pfrom^.value)

	genpc_s(kpop_m+dvar^.attribs.ax_frame,dvar)
else
	evalexpr(pfrom)
	genpc_s(kpop_m+dvar^.attribs.ax_frame,dvar)

	genpc_s((step<0|kincrto_m|kdecrto_m)+dvar^.attribs.ax_frame,dvar)
fi

if pautovar then
	if pto^.tag=j_name and pto^.def^.attribs.ax_frame then		!don't use autovar for frame limit
		pautovar:=nil									!(parser doesn't know if
	fi
fi

if pautovar then
	evalexpr(pto)
	limitvar:=pautovar^.def
	genpc_s(kzpop_f,limitvar)
	pto:=pautovar
else
	limitvar:=pto^.def
fi

if jumpinto then
	genjumpl(lab_c)			!jump straight into incr/jump Kfor cmdcode at C::
fi
definefwdlabel(lab_b)

do_block(pbody)				!do loop body

definefwdlabel(lab_c)

if pto^.tag=j_const then
	opc:=(step<0|kford_fci|kfor_fci)
else
	opc:=(step<0|kford_ff|kfor_ff)
fi

genpc_lab(opc,lab_b)
genopnd_s(dvar)
genopnd_s(limitvar)

if pelse then
	definefwdlabel(lab_e)
	do_block(pelse)			!any else part
fi

definefwdlabel(lab_d)
unstacklooplabels()
end

proc do_forall (ref unitrec p,pindex,pbody,pautovar)=		!DO_FORALL

int lab_a,lab_b,lab_c,lab_d,lab_e,step
ref unitrec pvar, plist, pelse, q
ref strec indexvar,vardef,autodef

pvar:=pindex^.nextunit
vardef:=pvar^.def
plist:=pvar^.nextunit
pelse:=pbody^.nextunit
indexvar:=pindex^.def

step:=(p^.tag=j_forall or p^.tag=j_foreach|1|-1)

lab_a:=definelabel()
lab_b:=createfwdlabel()
lab_c:=createfwdlabel()
lab_d:=createfwdlabel()
lab_e:=(pelse|createfwdlabel()|lab_d)
stacklooplabels(&lab_a,&lab_b,&lab_c,&lab_d)

evalexpr(plist)			!load the list
genpc(kbounds)			!extract bounds as a range
genpc(kexpandrange)		!expand to two ints, lower then upper

autodef:=pautovar^.def

if step=1 then					!counting upwards
	genpc_s(kzpop_f,autodef)		!limit=upb
	genpc(kdecr)				!index starts at lwb-1 (as goes straight to incr)
	genpc_s((indexvar^.attribs.ax_autovar|kzpop_f|kpop_f),indexvar)
else							!counting in reverse
	genpc(kincr)				!index starts at upb+1
	genpc_s((indexvar^.attribs.ax_autovar|kzpop_f|kpop_f),indexvar)
	genpc_s(kzpop_f,autodef)		!limit=lwb
fi

genjumpl(lab_c)			!jump straight into incr/jump Kfor cmdcode at C::

definefwdlabel(lab_b)

evalexpr(plist)
evalexpr(pindex)
if p^.tag=j_forall or p^.tag=j_forallrev then
	genpc(kpushix)
else
	genpc(kpushdotix)
fi
genpc_s(kpop_f,vardef)

if pbody^.tag=j_block then		!normal block body
	do_block(pbody)			!do loop body
else					!might be single if-statement
	do_stmt(pbody)
fi

definefwdlabel(lab_c)

genpc_lab((step=1|kfor_ff|kford_ff),lab_b)
genopnd_s(indexvar)
genopnd_s(autodef)

if pelse then
	definefwdlabel(lab_e)
	do_block(pelse)			!any else part
fi

definefwdlabel(lab_d)
unstacklooplabels()
end

proc do_do (ref unitrec p,a)=		!DO_DO
int lab_abc,lab_d,lab_test
lab_abc:=definelabel()
lab_d:=createfwdlabel()

stacklooplabels(&lab_abc, &lab_abc, &lab_abc, &lab_d)

do_block(a)

genjumpl(lab_abc)
definefwdlabel(lab_d)
unstacklooplabels()
end

proc do_cfor (ref unitrec p,a,b)=		!DO_CFOR

int lab_a,lab_b,lab_c,lab_d,lab_test
ref unitrec pinit, pcond, pstep

lab_a:=definelabel()
lab_b:=createfwdlabel()
lab_c:=createfwdlabel()
lab_d:=createfwdlabel()
lab_test:=createfwdlabel()

stacklooplabels(&lab_a, &lab_b, &lab_c, &lab_d)
pinit:=a
pcond:=pinit^.nextunit
pstep:=pcond^.nextunit

do_stmt(pinit)

genjumpl(lab_test)		!direct to condition code which is at the end

definefwdlabel(lab_b)

do_block(b)		!body

definefwdlabel(lab_c)
do_stmt(pstep)
definefwdlabel(lab_test)
genjumpcond(kjumpt,pcond,lab_b)

definefwdlabel(lab_d)
unstacklooplabels()
end

proc do_if (ref unitrec p,a,b,pelse) =	!DO_IF
int lab1,lab2

lab1:=createfwdlabel()				!dest label of main condition (to end of if, or start if else)

if pelse then lab2:=createfwdlabel() fi	!label past else part

genjumpcond(kjumpf,a,lab1)

do_block(b)
if pelse then
	genjumpl(lab2)
	definefwdlabel(lab1)
	do_block(pelse)
	definefwdlabel(lab2)
else
	definefwdlabel(lab1)
fi
end

proc do_longif (ref unitrec p,a,b) =	!DO_LONGIF
ref unitrec q
int labend,lab2
labend:=createfwdlabel()

q:=a
while q do					!each q is an elsif pair
	lab2:=createfwdlabel()
	genjumpcond(kjumpf,q^.a,lab2)
	do_block(q^.b)
	q:=q^.nextunit
	if q or b then
		genjumpl(labend)
	fi
	definefwdlabel(lab2)
od
if b then		!do else part
	do_block(b)
fi
definefwdlabel(labend)

end

proc do_callproc (ref unitrec p,a,b) =	!DO_CALLPROC
ref strec d,pm
ref unitrec pbody,q,x,r
int naparams,fkeyword,nparams,i,j,k,ffcode,isfn,fbyref

[maxparams]ref unitrec cparams
[maxparams]ref strec dparams
int dparamsdone:=0
ichar name
ref intpc pc

case a^.tag
when j_name then
when j_dot then
	do_callmproc(p,a,b,(p^.tag=j_callfn))
	return
else
	do_callptr(p,a,b)
	return
esac

d:=a^.def
case d^.nameid
when procid,dllprocid then
when applprocid then
	do_callappl(p,a,b,p.tag=j_callfn)
	return
else
	cpl d^.name,NAMENAMES[D^.NAMEID]
	gerror("Callproc: not proc",p)
esac

pbody:=d^.code

case ffcode:=d^.attribs.ax_fflang
when windowsff,clangff,mlangff then
	do_calldll(p,a,b)
	return
esac

isfn:=d^.mode<>tvoid

if isfn then
	genpc(kpushz_void)			!needed even for statement call
fi

nparams:=d^.attribs.ax_nparams

memset(&cparams,0,cparams[1].bytes*nparams)

fkeyword:=0			!whether keywords used
x:=b						!scan actual params
naparams:=0
while x do
	++naparams
	if naparams>nparams then
		cpl d^.name,naparams,nparams
		gerror("Too many params",p)
	fi

	if fkeyword and x^.tag<>j_keyword then
		gerror("Normal param follows keyword param",p)
	fi
	case x^.tag
	when j_keyword then
		unless x^.a^.tag=j_name then
			gerror("Kwd: not name")
		end

		fkeyword:=1
		name:=x^.a^.def^.name
		if not dparamsdone then
			extractparams(d,&dparams)
			dparamsdone:=1
		fi
		j:=0
		k:=0
		for j:=1 to nparams do
			if eqstring(dparams[j]^.name,name) then
				k:=j
				exit
			fi
		od
		if k=0 then
			cpl name,"in",d^.name
			gerror("Can't find keyword param")
		fi
		if cparams[k] then
			cpl name
			gerror("Param already set")
		fi
		cparams[k]:=x^.b

	when j_null then		!missing paramater
	else
		cparams[naparams]:=x
	esac
	x:=x^.nextunit
od

for i:=1 to nparams do
	x:=cparams[i]
	if x=nil then		!param not set
		if not dparamsdone then
			extractparams(d,&dparams)
			dparamsdone:=1
		fi
		pm:=dparams[i]
		if pm^.code then	!use default code
			cparams[i]:=pm^.code
		elsif not pm^.attribs.ax_optional then	!error
			cpl pm^.name,"in",d^.name
			gerror("Param not optional")
		fi				!else leave as null (will push void value)
	fi
od

for i:=nparams downto 1 do
	x:=cparams[i]
	if not dparamsdone then
		extractparams(d,&dparams)
		dparamsdone:=1
	fi
	fbyref:=dparams[i]^.attribs.ax_byrefmode

	if x=nil then			!official missing parameter; substitute with void
		if fbyref then
			gerror("&void param")
		fi
		genpc(kpushz_void)
	else
		if fbyref then
			evalref(x)
		else
			evalexpr(x)
		fi
	fi
od  

genpc_s(kcall,d)
genopnd_int(0)

for i:=1 to nparams do			!analyse pushed params in normal order
	r:=cparams[i]
	if r=nil or issimpleparam(r) then
		case lastopc^
		when kaddsp then
			++((lastopc+1)^)			!augment current addsp
		when kcall then
			if (lastopc+2)^<8 then		!stack adj field might be 8-bits and expressed in bytes
				++((lastopc+2)^)		!So limited to 15 vars, or 8 (32-bit varrec)
			else
				genpc_int(kaddsp,1)
			fi
		else
			genpc_int(kaddsp,1)
		esac
	else
		case lastopc^
		when kfree then
			++((lastopc+1)^)			!augment current addsp
		else
			genfree(1)
		esac
	fi
od

if isfn and p^.tag=j_callproc then	!get rid of result
	genfree(1)
fi
end

proc do_callhostproc (ref unitrec p,a) =	!DO_CALLHOSTPROC
int calledasfn,isfn,index,nap,i,nparams,fparams
[10]ref unitrec plist
ref unitrec q

calledasfn:=p^.tag=j_callhostfn

index:=p^.opcode

isfn:=hostisfn[index]
if calledasfn and not isfn then
	gerror("Host proc is not function")
fi

if isfn and index=host_getparam and 
	(a and a^.nextunit=nil and a^.tag=j_const and a^.value=0) then
	genpushint(nprocparamvars)
	return
fi

if isfn then					!callasfn might be 0, but func returns value anyway
	genpc(kpushz_void)
fi


q:=a

nap:=0				!number actual params
while q do
	if nap>=plist.upb then
		gerror("far too many host params")
	fi
	++nap

	plist[nap]:=q
	q:=q^.nextunit
od

if index=host_allparams and a=nil then
	nparams:=1
else
	nparams:=nap
fi

if nparams=0 and hostlvset[index] then
	gerror("LV hostfn: needs 1+ params")
fi
fparams:=hostnparams[index]
if nparams>fparams then
	gerror("Hostfn too many params")
fi
to fparams-nparams do
	genpc(kpushz_void)
od

for i:=nparams downto 1 do
	if i=1 and hostlvset[index] then
		evalref(plist[i])
	elsif i=1 and index=host_allparams and nap=0 then
		isfn:=stcurrproc^.mode<>tvoid
		genpc_s(kpush_ap,stcurrproc)
	else
		evalexpr(plist[i])
	fi
od  

callhostfn(index,calledasfn)
end

proc do_return (ref unitrec p,a) =	!DO_RETURN
int isfn

isfn:=stcurrproc^.mode<>tvoid

if a=nil then				!return from proc, or should be
	if isfn then				!probably picked up by TX anyway
		gerror("Fn needs return value",p)
	fi
	if trylevel then
		genpc_int(kaddsp,trylevel)
	fi
	if nprocframevars then
		genjumpl(retindex)
	else
		genpc(kreturn)
	fi
	return
fi

if not isfn then
	cpl stcurrproc^.name
	gerror("Can't return value from proc")
fi

evalexpr(a)				!ret value to stack

genpc_s(kzpop_f,stretval)

if trylevel then
	genpc_int(kaddsp,trylevel)
fi

if nprocframevars then		!need to do cleanup at end
	genjumpl(retindex)
else
	genpc(kreturn)
fi
end

proc genstartproc(ref strec dmodule)=			!GENSTARTPROC
int retadjust,lab1,lab2
ref strec stmain, ststart

if st_startproc=nil then
	gerror("$startproc not present")
fi
retadjust:=0

genpc_s(kprocstart,st_startproc)
genopnd_int(0)

st_startproc^.index:=pcindex+1

scanidata(dmodule)

stmain:=finddefstr(stmodule,"main")
ststart:=finddefstr(stmodule,"start")

if stmain and ststart then		!start/main both provided
	lab1:=createfwdlabel()
	lab2:=createfwdlabel()
	genpc(kpushz_void)
	genpc_str(kpush_cs,stmodule^.name,stmodule^.namelen)
	callhostfn(host_ismain,1)
	genpc_lab(kjumpfalse,lab1)
	genpc_s(kcall,stmain)
		genopnd_int(0)
	genpc_lab(kjump,lab2)
	definefwdlabel(lab1)
	genpc_s(kcall,ststart)
		genopnd_int(0)
	definefwdlabel(lab2)
elsif stmain then			!main only
	lab1:=createfwdlabel()
	genpc(kpushz_void)
	genpc_str(kpush_cs,stmodule^.name,stmodule^.namelen)
	callhostfn(host_ismain,1)
	genpc_lab(kjumpfalse,lab1)
	genpc_s(kcall,stmain)
		genopnd_int(0)
	definefwdlabel(lab1)
elsif ststart then			!start only
	genpc_s(kcall,ststart)
		genopnd_int(0)
fi

genpc(kreturn)

genpc(kprocend)
END

proc do_procdef (ref strec p) =		!DO_PROCDEF
int nfreevars,nnofreevars

if p=st_startproc then
	return
fi

stcurrproc:=p

retindex:=createfwdlabel()

genprocentry(p,nfreevars,nnofreevars)

if p^.code=nil then
	CPL "EMPTY PROC BODY",p^.name,scopenames[getscope(p)]
else
	do_block(p^.code)
fi

if p^.mode<>tvoid then			!is a function
	if p^.owner^.nameid<>typeid then		!not a method
		if not checkblockreturn(p^.code) then
			cpl p^.name
			gerror("Function needs explicit return statement",p^.code)
		fi
	fi
fi

definefwdlabel(retindex)			!common return point
genprocexit(nfreevars,nnofreevars)
genpc(kprocend)
end

proc genprocentry (ref strec p, int &nfreevars,&nnofreevars) =		!GENPROCENTRY
int nparamvars,nframevars,isfn,hasretval,fv,nallocvars,ninitvars
int i,j,nextoffset
ref strec d
[maxparams]ref strec varlist
[maxparams]int fvlist
ref unitrec expr
[maxlocals]ref strec locals
int nlocals

d:=p^.deflist			!list of names in proc
isfn:=p^.mode<>tvoid

if isfn then
	stretval:=getduplnameptr(p,addnamestr("$retval"),paramid)
	stretval^.mode:=p^.mode
	stretval^.attribs.ax_autovar:=1
	adddef_nodupl(p,stretval)
else
	stretval:=nil
fi

nparamvars:=nframevars:=0
hasretval:=0

d:=p^.deflist
nlocals:=0
while d do
	if nlocals>=maxlocals then
		gerror("Too many locals")
	fi
	locals[++nlocals]:=d
	d:=d^.nextdef
od

for i:=nlocals downto 1 do
	d:=locals[i]
	case d^.nameid
	when frameid then
		if nframevars>=maxparams then
			mlineno:=d^.lineno
			cpl p^.name,d^.name,nframevars
			gerror("Too many frame vars")
		fi
		++nframevars
		varlist[nframevars]:=d
		fvlist[nframevars]:=0

	when paramid then
		d^.index:=++nparamvars
		if d^.attribs.ax_autovar then		!assume $retval
			hasretval:=1
		fi
	esac
od

nprocframevars:=nframevars		!used elsewhere, in do_return for example
nprocparamvars:=nparamvars-isfn	!don't include $retval
nallocvars:=ninitvars:=0
nfreevars:=nnofreevars:=0

for i:=1 to nframevars do
	d:=varlist[i]
	expr:=nil
	if d^.code then
		expr:=d^.code			!init value
	fi
	if d^.attribs.ax_autovar then	!no init needed; always initialised once in the code
		fv:=0						!also, don't need freeing (always ints)
		++nallocvars
		++nnofreevars				!av$ don't need freeing
	elsif expr then					!no init needed as initialised immediately; but needs freeing
		fv:=1
		++nallocvars
		++nfreevars
	else							!init to void needed; need freeing
		fv:=2
		++ninitvars
		++nfreevars
	fi
	fvlist[i]:=fv
od


nextoffset:=0
for i:=2 downto 0 do			!have normal vars at top, init vars next, then av$ at bottom
	for j:=1 to nframevars do
		if fvlist[j]=i then
			nextoffset-:=1
			varlist[j]^.index:=nextoffset
		fi
	od
od

genpc_s(kprocstart,p)
genopnd_int(nparamvars-hasretval)
p^.index:=pcindex+1

if ninitvars+nallocvars then
	genpc_int(kstackframe,ninitvars+nallocvars)
fi

for i:=1 to nframevars do
	d:=varlist[i]
	if d^.code then
		evalexpr(d^.code)
		d^.attribs.ax_used:=1
		genpc_s(kzpop_f,d)
	fi
od
end

proc genprocexit(int nfree,nnofree)=		!GENPROCEXIT
if nnofree then
	genpc_int(kaddsp,nnofree)
fi
if nfree then
	genfree(nfree)
fi
genpc(kreturn)
end

proc do_preincr (ref unitrec p,a) =	!DO_PREINCR
int isincr

isincr:=(p^.tag=j_preincr) ior (p^.tag=j_postincr)

if a^.tag=j_name and a^.def^.nameid<>paramid then		!params might be byref
	genpc_s((isincr|kincrto_m|kdecrto_m)+a^.def^.attribs.ax_frame,a^.def)
else
	evalref(a)
	genpc((isincr|kincrptr|kdecrptr))
fi
end

proc do_exit (ref unitrec p,a) =		!DO_EXIT
int k,index,n

case p^.tag
when j_restart then k:=1
when j_redo then k:=2
when j_next then k:=3
when j_exit then k:=4
esac

if a then
	index:=a^.value
else
	index:=1
fi

n:=findlooplabel(k,index)
if n=0 then
	gerror("Bad exit/loop index",p)
else

	if trylevel>looptrylevel then
		genpc_int(kaddsp,trylevel-looptrylevel)
	fi
	genjumpl(n)
fi
end

proc do_goto (ref unitrec p,a) =	!DO_GOTO
ref strec d
int ntries,lab

case a^.tag
when j_name then
	d:=a^.def
	if d^.index=0 then
		d^.index:=createfwdlabel()
	fi
	case d^.nameid
	when labelid then
		ntries:=trylevel-d^.offset
		if ntries<0 then
			gerror("Jumping into try block")
		elsif ntries then
			genpc_int(kaddsp,ntries)
		fi
		genpc_lab(kjump,d^.index)
	else
		cpl d^.name
		gerror("Not label name")
	esac
else
	gerror("GOTO PTR")
esac
end

proc do_switch (ref unitrec p,pindex,pwhenthen,pelse) =	!DO_SWITCH
int minlab,maxlab,x,y,i,n
ref unitrec w,wt

minlab:=1000000
maxlab:=-1000000			!highest index seen

n:=0				!no. different values
wt:=pwhenthen

while wt do
	w:=wt^.a
	while w do
		case w^.tag
		when j_const then
			case w^.mode
			when trange then
				x:=w^.range_lower
				y:=w^.range_upper
dorange::
				for i:=x to y do
					minlab :=min(minlab,i)
					maxlab :=max(maxlab,i)

				od
			when tint then
				x:=y:=w^.value
				goto dorange
			else
				gerror("Switch when1: not const int",w)
			esac
		when j_typeconst then
			x:=y:=w^.mode
			goto dorange
		else
			cpl =strexpr(w),jtagnames[w^.tag]
			gerror("Switch when2: not const",w)
		esac
		w:=w^.nextunit
	od
	wt:=wt^.nextunit
od

if maxlab-minlab<=maxswitchrange then
	do_simpleswitch(p,pindex,pwhenthen,pelse, minlab,maxlab)
	return
fi

gerror("COMPLEX SWITCH/NOT COMPLETE")
end

proc do_simpleswitch(ref unitrec p,pindex,pwhenthen,pelse, int a,b) =		!DO_SIMPLESWITCH

ref unitrec w,wt,q
int loopsw,n,offset,x,y,x0,i,labstmt,elselab
[1..maxswitchrange+1]int labels
int lab_a,lab_b,lab_c,lab_d

loopsw:=p^.tag=j_doswitch

n:=b-a+1
offset:=a-1		!a..b becomes 1..n

if loopsw then
	lab_a:=definelabel()
	lab_d:=createfwdlabel()
	stacklooplabels(&lab_a,&lab_a,&lab_a,&lab_d)
else
	lab_d:=createfwdlabel()
fi

evalexpr(pindex)				!switch index

genpc_int2(kswitch,n,a)

for i:=1 to n do
	genpc_lab(kjumplabel,0)
	labels[i]:=pcindex			!for now, store destination code index
od

genpc_lab(kjumplabel,0)			!else label
labels[n+1]:=pcindex


wt:=pwhenthen
while wt do
	labstmt:=definelabel()
	w:=wt^.a
	while w do
		case w^.tag
		when j_const then
			if w^.mode=trange then
				x0:=w^.range_lower
				y:=w^.range_upper
			else				!assume int (as already checked)
				x0:=y:=w^.value
			fi
		when j_typeconst then
			x0:=y:=w^.mode
		esac
		for x:=x0 to y do
			i:=x-offset
			if pccode^[labels[i]] then			!should have been zero
				cpl x,char(x)
				gerror("Dupl switch value")
			fi
			pccode^[labels[i]]:=labstmt
		od
		w:=w^.nextunit
	od

	do_block(wt^.b)

	if not loopsw then
		genjumpl(lab_d)
	else
		genjumpl(lab_a)
	fi
	wt:=wt^.nextunit
od

if pelse then
	if pelse^.nextunit=nil then
		q:=pelse			!q is the only statement of the else
	else
		q:=nil
	fi
	if loopsw and q and q^.tag=j_exit and (q^.a=nil or getconstvalue(q^.a,102)=1) then	!one stmt consisting of exit/1
		elselab:=lab_d
		pelse:=nil
	else
		elselab:=createfwdlabel()
	fi
else
	elselab:=(loopsw|lab_a|lab_d)
fi

if pelse then		!do else part
	definefwdlabel(elselab)
	do_block(pelse)
fi
for i:=1 to n do
	if pccode^[labels[i]]=0 then
		pccode^[labels[i]]:=elselab
	fi
od
pccode^[labels[n+1]]:=elselab

if loopsw then
	genjumpl(lab_a)
	definefwdlabel(lab_d)
	unstacklooplabels()
else
	definefwdlabel(lab_d)
fi
end

proc do_case (ref unitrec p,pindex,pwhenthen,pelse) =	!DO_CASE
int lab_a,lab_d

int loopsw,fmult,labnextwhen,labstmtstart
ref unitrec w,wt

loopsw:=p^.tag=j_docase

if loopsw then
	lab_a:=definelabel()
	lab_d:=createfwdlabel()
	stacklooplabels(&lab_a,&lab_a,&lab_a,&lab_d)
else
	lab_d:=createfwdlabel()
fi

evalexpr(pindex)			!load test expr p to t

wt:=pwhenthen
while wt do
	w:=wt^.a
	fmult:=w^.nextunit<>nil
	labnextwhen:=createfwdlabel()

	if fmult then
		labstmtstart:=createfwdlabel()
	fi

	while w do
		evalexpr(w)
		w:=w^.nextunit
		if w then					!not last
			genpc_lab(kjumptesteq,labstmtstart)
		else
			genpc_lab(kjumptestne,labnextwhen)
		fi
	od
	if fmult then
		definefwdlabel(labstmtstart)
	fi
	do_block(wt^.b)

	if not loopsw then
		genjumpl(lab_d)
	else
		genjumpl(lab_a)
	fi
	definefwdlabel(labnextwhen)
	wt:=wt^.nextunit
od

genfree(1)

if pelse then
	do_block(pelse)
fi
if loopsw then
	genjumpl(lab_a)
	definefwdlabel(lab_d)
	unstacklooplabels()
else
	definefwdlabel(lab_d)
fi
end

proc do_try (ref unitrec p,a,b) =	!DO_TRY
int labend,labx
ref unitrec ptry,x,pexcept,pexcode

++trylevel
labend:=createfwdlabel()
ptry:=a
labx:=createfwdlabel()

pexcept:=b

if pexcept=nil then
	gerror("try: no except")
elsif pexcept^.nextunit then
	gerror("Try:multiple except block not implemented")
fi

while pexcept do
	pexcode:=pexcept^.a
	if pexcode=nil or pexcode^.nextunit then
		gerror("Try:multiple except codes not implemented")
	fi
	genpc_lab(kpush_try,labx)
	genopnd_int(getconstvalue(pexcode,103))
	genopnd_int(1)
	do_block(ptry)
	genjumpl(labend)
	definefwdlabel(labx)
	do_block(pexcept^.b)
	definefwdlabel(labend)
	pexcept:=pexcept^.nextunit
od

genpc_int(kaddsp,1)
--trylevel
end

proc do_applyop (ref unitrec p,a,b,c) =	!DO_APPLYOP
int lab

if c then
	evalref(b)
	evalexpr(c)
	evalexpr(a)
	genpc_int(kapplyop,2)
else
	evalref(b)
	evalexpr(a)
	genpc_int(kapplyop,1)
fi
lab:=createfwdlabel()
genpc_lab(kjump,lab)		!dummy jump to be moved to runtime-generated code
genpc(knop)					!stop jump being optimised out
definefwdlabel(lab)
end

proc evalref(ref unitrec p)=		!EVALREF
ref strec d
int lab1,lab2

switch p^.tag
when j_const then
	gerror("ref on const")

when j_name then
	d:=p^.def
	case d^.nameid
	when procid then
		genpc_s(kpush_ap,d)
	when staticid then
		genpc_s(kpush_am,d)
	when frameid then
		genpc_s(kpush_af,d)
		d^.attribs.ax_used:=1
	when paramid then
		if d^.attribs.ax_byrefmode then	!insert extra dereference
			genpc_s(kpush_f,d)
		else
			genpc_s(kpush_af,d)
	fi
	when labelid then
		if d^.index=0 then
			d^.index:=createfwdlabel()
		fi
		genpc_lab(kpush_al,d^.index)
	when dllprocid then
		genpc_s(kpush_ad,d)
	else
		cpl namenames[d^.nameid]
		gerror("&name")
	esac

when j_index,j_slice then
	evalref(p^.a)
	evalexpr(p^.b)
	genpc(kpushixref)

when j_dotindex then
	evalref(p^.a)
	evalexpr(p^.b)
	genpc(kpushdotixref)

when j_dotslice then


	evalexpr(p^.a)
	evalexpr(p^.b)
	genpc(kpushdotix)

when j_byteindex then
	evalref(p^.a)
	evalexpr(p^.b)
	genpc_int(kpushbyteixref,p^.mode)

when j_keyindex,j_dotkeyindex then
	evalexpr(p^.b)
	evalref(p^.a)
	genpc(kpushkeyixref)

when j_ptr then
	evalexpr(p^.a)

when j_dot then
	evalref(p^.a)		!lhs, should be a record
	d:=p^.b^.def		!d should be field name
	genpc_int(kpushdotref,d^.offset)
when j_ifx then
	lab1:=createfwdlabel()				!dest label of main condition (to end of if, or start if else)
	lab2:=createfwdlabel()

	genjumpcond(kjumpf,p^.a,lab1)
	evalref(p^.b)
	genjumpl(lab2)
	definefwdlabel(lab1)
	evalref(p^.c)
	genpc(knop)
	definefwdlabel(lab2)
else
	cpl jtagnames[p^.tag],=mlineno
	gerror("EVALREF: Can't do tag")
endswitch
end

function getpclop(int opc)int=		!GETOPCNAMEC
int i

for i:=1 to pcl_jcodes.len do
	if pcl_jcodes[i]=opc then
		noperands:=pcl_nopnds[i]
		return pcl_kcodes[i]
	fi
od

cpl jtagnames[opc]
gerror("PCL:GETOPC No Op")
return 0
end

proc genjumpl(int lab)=		!GENJUMPL
genpc_lab(kjump,lab)
end

function definelabel:int=		!DEFINELABEL
int lab:=pcindex+1

lastopc:=cast(&dummyop)


return lab
end

function createfwdlabel:int=	!CREATEFWDLABEL
int lab
if nextfreelabel=0 then
	cpl maxlabels
	gerror("Too many labels")
fi
lab:=nextfreelabel
nextfreelabel:=labeltable[lab]
labeltable[lab]:=0

return -lab						!special fwd label identified by being negative
end

proc definefwdlabel(int &oldlab)=
int pc,nextpc,newlab,index

lastopc:=cast(&dummyop)

index:=oldlab

if index>=0 then gerror("deffwdlabel?") fi
index:=-index

newlab:=pcindex+1

pc:=labeltable[index]			!start of fwd ref chain
while pc do						!pc is next pc-index of last label ref
	nextpc:=pccode^[pc]
	pccode^[pc]:=newlab
	pc:=nextpc
od

labeltable[index]:=nextfreelabel
nextfreelabel:=index

oldlab:=newlab
end

proc stacklooplabels(ref int a,b,c,d)=	!STACKLOOPLABELS
if loopindex>=maxloopindex then
	gerror("Too many nested loops")
fi
++loopindex
loopstack[loopindex,1]:=a
loopstack[loopindex,2]:=b
loopstack[loopindex,3]:=c
loopstack[loopindex,4]:=d
trylevelstack[loopindex]:=trylevel
end

proc unstacklooplabels=	!UNSTACKLOOPLABELS
--loopindex
end

function findlooplabel(int k,n)int=	!FINDLOOPLABEL
int i

if n=0 then			!outermost loop
	i:=1
else
	i:=loopindex-(n-1)		!point to entry
fi

if i<1 or i>loopindex then
	gerror("Bad loop index")
fi

looptrylevel:=trylevelstack[i]
return loopstack[i,k]^
end

function issimpleparam(ref unitrec p)int=		!ISSIMPLEPARAM
switch p^.tag
when j_const then		!will always be copies
	return 1


when j_len,j_lwb,j_upb,j_eq,j_ne,j_lt,j_le,j_ge,j_gt,j_inot,j_predecrx,j_preincrx,
					j_postdecrx,j_postincrx then
	return 1
else

endswitch
return 0
END

proc genjumpcond(int opc,ref unitrec p, int lab)=		!GENJUMPCOND
int oldmlineno,lab2
ref unitrec q,r
int64 x

oldmlineno:=mlineno
mlineno:=p^.lineno
q:=p^.a
r:=p^.b

switch p^.tag
when j_andl then
	case opc
	when kjumpf then
		genjumpcond(kjumpf,q,lab)
		genjumpcond(kjumpf,r,lab)
	when kjumpt then
		lab2:=createfwdlabel()
		genjumpcond(kjumpf,q,lab2)
		genjumpcond(kjumpt,r,lab)
		definefwdlabel(lab2)
	esac

when j_orl then
	case opc
	when kjumpf then
		lab2:=createfwdlabel()
		genjumpcond(kjumpt,q,lab2)
		genjumpcond(kjumpf,r,lab)
		definefwdlabel(lab2)
	when kjumpt then
		genjumpcond(kjumpt,q,lab)
		genjumpcond(kjumpt,r,lab)
	esac

when j_notl then

	case opc
	when kjumpf then
		genjumpcond(kjumpt,q,lab)
	when kjumpt then
		genjumpcond(kjumpf,q,lab)
	esac

when j_istruel then
	genjumpcond(opc,q,lab)

when j_eq,j_ne,j_lt,j_le,j_ge,j_gt then

	gcomparejump(opc,p,q,r,lab)

when j_name then
	evalexpr(p)
	genpc_lab((opc|kjumptrue|kjumpfalse),lab)

when j_const then
	x:=p^.value

	if p^.mode=tint then goto doelse fi
	if (x<>0 and opc=kjumpt) or (x=0 and opc=kjumpf) then
		genjumpl(lab)
	fi

else				!other expression
doelse::
	case p^.tag
	when j_isdef, j_isvoid then
		evalexpr(q)
		if opc=kjumpt then
			genpc_lab((p^.tag=j_isdef|kjumpdef|kjumpvoid),lab)
		else
			genpc_lab((p^.tag=j_isdef|kjumpvoid|kjumpdef),lab)
		fi
	else
		evalexpr(p)
		genpc_lab((opc|kjumptrue|kjumpfalse),lab)
	esac
endswitch
mlineno:=oldmlineno
end

proc gcomparejump(int jumpopc,ref unitrec p,lhs,rhs, int lab)=	!GCOMPAREJUMP
int cond,opc

cond:=p^.tag				!j_eq etc
if jumpopc=kjumpf then			!need to reverse condition
	cond:=reversecond(cond)		!eqop => neop, etc
fi

case cond
when j_eq then opc:=kjumpeq
when j_ne then opc:=kjumpne
when j_lt then opc:=kjumplt
when j_le then opc:=kjumple
when j_ge then opc:=kjumpge
when j_gt then opc:=kjumpgt
esac

evalexpr(lhs)
evalexpr(rhs)
genpc_lab(opc,lab)
end

function reversecond(int op)int=			!REVERSECOND

case op
when j_eq then return j_ne
when j_ne then return j_eq
when j_lt then return j_ge
when j_le then return j_gt
when j_ge then return j_lt
when j_gt then return j_le
esac
return 0
end

proc do_convert(int m,ref unitrec p)=			!DO_CONVERT
int n,elemmode,i,lowerx,lbound
const maxunits=50
[maxunits]ref unitrec plist

if p^.tag<>j_makelist and p^.tag<>j_makeconstr then		!assume regular type conversion

	if ttbasetype[m]=trecord then
		p:=createunit2(j_makelist,p,nil)
		goto skip
	fi

doconv::
	evalexpr(p)
	genpc_int(khardconv,m)
	return
fi

skip::
n:=unitstoarray(p^.a,&plist,maxunits)

case ttbasetype[m]
when trecord,tstruct then
	if n<ttlength[m] then
		cpl ttname[m]
		gerror("Too few fields",p)
	elsif n>ttlength[m] then
		cpl ttname[m]
		gerror("Too many fields",p)
	fi
	for i:=1 to n do
		evalexpr(plist[i])
	od
	genpc_int2((ttbasetype[m]=trecord|kmakerecord|kmakestruct),n,m)

when tlist then		!probably just a list prefix used
	if p^.b then
		lowerx:=getconstvalue(p^.b,104)
	else
		lowerx:=1
	fi
	if n=0 then
		genpc_int(kpushz_listl,lowerx)
	else
		for i:=1 to n do
			evalexpr(plist[i])
		od
		genpc_int2(kmakelist,n,lowerx)
	fi

when tarray then
	for i:=1 to n do		!any elements need to be pushed
		evalexpr(plist[i])
	od

	if m=tarray then	!generic array, not a user type; assume int elemtype
		if p^.b then
			lbound:=getconstvalue(p^.b,105)
		else
			lbound:=1
		fi
		if n=0 then
			genpc_int2(kpushz_arrayl,ti32,lbound)
		else
			genpc_int4(kmakearray,n,lbound,tarray,ti32)
		fi

	else						!assume user type
		elemmode:=tttarget[m]
		if p^.b then
			gerror("2:Can't override lwb")
		fi
		lbound:=ttlower[m]

		if ttlength[m] then				!need specific number of elements
			if n<ttlength[m] then
				cpl ttname[m]
				gerror("Too few elements",p)
			elsif n>ttlength[m] then
				cpl ttname[m]
				gerror("Too many elements",p)
			fi
			if n=0 then
				genpc_int2(kpushz_arrayl,elemmode,lbound)
			else
				genpc_int4(kmakearray,n,lbound,m,elemmode)
			fi
		else						!no length: can be anything
			if n=0 then
				genpc_int2(kpushz_arrayl,elemmode,lbound)
			else
				genpc_int4(kmakearray,n,lbound,m,elemmode)
			fi
		fi
	fi

else
	evalexpr(p)
	genpc_int(khardconv,m)
esac
end

proc do_selectx(ref unitrec pindex,pplist,pelse)=		!DO_SELECTX
int n,labend,i,lab,elselab
ref unitrec x

[maxswitchrange]ref unitrec plist
[maxswitchrange+1]int labels

n:=unitstoarray(pplist,&plist,maxswitchrange)

if n>maxswitchrange then
	gerror("Selectx too complex")
fi

labend:=createfwdlabel()

evalexpr(pindex)
genpc_int2(kswitch,n,1)

for i:=1 to n do
	genpc_lab(kjumplabel,0)
	labels[i]:=pcindex		!for now, store destination code index
od
genpc_lab(kjumplabel,0)
labels[n+1]:=pcindex

i:=1
for i:=1 to n do
	x:=plist[i]
	lab:=definelabel()

	pccode^[labels[i]]:=lab
	evalexpr(x)

	genjumpl(labend)	!break to end of statement
od

elselab:=definelabel()

pccode^[labels[n+1]]:=elselab

evalexpr(pelse)
genpc(knop)

definefwdlabel(labend)
end

proc do_calldll (ref unitrec p,a,b) =	!DO_CALLDLL
ref strec d,pm
ref unitrec pbody,q,x
int naparams,fkeyword,nparams,i,j,k,resmode,m,varparams,isfn,fbyref,langcode
[maxparams]ref unitrec cparams
[maxparams]ref strec dparams
int dparamsdone:=0
ichar name

d:=a^.def

if varparams:=d^.attribs.ax_varparams then
	do_calldllvar(p,a,b)
	return
fi

resmode:=d^.mode


isfn:=resmode<>tvoid

if p^.tag=j_callfn and not isfn then
	gerror("DLL: needs function")
fi 
if p^.tag=j_callproc then		!result not needed
	isfn:=0
	resmode:=tvoid
fi

if isfn then
	genpc(kpushz_void)			!needed even for statement call
fi


fkeyword:=0			!whether keywords used
naparams:=0
nparams:=d^.attribs.ax_nparams
memset(&cparams,0,cparams[1].bytes*nparams)

x:=b
while x do
	++naparams
	cparams[naparams]:=nil

	if naparams>nparams then
		cpl d^.name,naparams,nparams
		gerror("Too many params",p)
	fi

	if fkeyword and x^.tag<>j_keyword then
		gerror("Normal param follows keyword param",p)
	fi
	case x^.tag
	when j_keyword then
		fkeyword:=1
		name:=x^.a^.def^.name
		if not dparamsdone then
			extractparams(d,&dparams)
			dparamsdone:=1
		fi
		k:=0
		for j:=1 to nparams do
			if eqstring(dparams[j]^.name,name) then		!found
				k:=j	!d.paramlist[j]
				exit
			fi
		od
		if k=0 then
			cpl name,"in",d^.name
			gerror("Can't find keyword param")
		fi
		if cparams[k] then
			cpl name
			gerror("Param already set")
		fi
		cparams[k]:=x^.b

	when j_null then		!missing paramater
	else
		cparams[naparams]:=x
	esac
	x:=x^.nextunit
od

for i:=1 to nparams do
	x:=cparams[i]

	if x=nil then		!param not set
		if not dparamsdone then
			extractparams(d,&dparams)
			dparamsdone:=1
		fi
		pm:=dparams[i]
		if pm^.code then	!use default code
			cparams[i]:=pm^.code
		elsif not pm^.attribs.ax_optional then	!error
			cpl pm^.name,"in",d^.name
			gerror("Param not optional")
		fi				!else leave as null (will push void value)
	fi
od

genpc(kstartdll)

for i:=1 to nparams do
	x:=cparams[i]
	if not dparamsdone then
		extractparams(d,&dparams)
		dparamsdone:=1
	fi
	m:=dparams[i]^.mode
	fbyref:=dparams[i]^.attribs.ax_byrefmode
	if fbyref then
		gerror("Byref on dll call")
	fi

	if x=nil then			!official missing parameter; substitute with void
		gerror("Dll missing param - no default")
	else
		evalexpr(x)				!load to normal stack
		genpc_int(kpushdll,m)		!push to dll stack
	fi
od  


case d^.attribs.ax_fflang
when windowsff then
	langcode:='W'
when clangff then
	langcode:='C'
when mlangff then
	langcode:='M'
else
 gerror("Bad FF?")
esac

genpc_s(kcalldll,d)
genopnd_int(langcode)
genopnd_int(resmode)
end

function islogical(ref unitrec p)int=			!ISLOGICAL
case p^.tag
when j_istruel,j_notl,j_andl,j_orl,j_xorl then
	return 1
esac
return 0
end

proc do_and(ref unitrec x,y)=		!DO_AND
int a,b

	a:=createfwdlabel()
	b:=createfwdlabel()

	genjumpcond(kjumpf,x,a)
	genjumpcond(kjumpf,y,a)

	genpc_int(kpush_ci,1)
	genjumpl(b)
	definefwdlabel(a)
	genpc_int(kpush_ci,0)
	genpc(knop)
	definefwdlabel(b)
end

proc do_or(ref unitrec x,y)=		!DO_OR
int a,b
	a:=createfwdlabel()
	b:=createfwdlabel()

	genjumpcond(kjumpt,x,a)
	genjumpcond(kjumpt,y,a)
	genpc_int(kpush_ci,0)
	genjumpl(b)
	definefwdlabel(a)
	genpc_int(kpush_ci,1)
	genpc(knop)
	definefwdlabel(b)
end

proc do_callptr (ref unitrec p,pproc,pparams) =	!DO_CALLPTR
int n,i,j
[maxparams]ref unitrec params
ref unitrec x,q

genpc(kpushz_void)

n:=0
q:=pparams
while q do
	params[++n]:=q
	q:=q^.nextunit
od

for i:=n downto 1 do
	x:=params[i]
	if x^.tag=j_null then			!official missing parameter; substitute with void
		genpc_int(kpushz,tvoid)
	else
		evalexpr(x)				!load to normal stack
	fi
od  

if pproc^.tag<>j_ptr then		!lhs should be a pointer op
	gerror("Callptr?")
fi
evalexpr(pproc^.a)				!push lhs, should be a function ptr

genpc_int2(kcallptr,n,0)			!call the function

if n then
	genfree(n)
fi

if p^.tag=j_callproc then	!get rid of result
	genfree(1)
fi

end

proc do_callmproc (ref unitrec p,pproc,pparams,int calledasfn) =	!DO_CALLMPROC
int n,isfn,i
[maxparams]ref unitrec params
ref unitrec x,pleft

isfn:=1

if isfn then
	genpc(kpushz_void)
fi

n:=unitstoarray(pparams,&params,maxparams)

for i:=n downto 1 do
	x:=params[i]
	if x^.tag=j_null then			!official missing parameter; substitute with void
		genpc(kpushz_void)
	else
		evalexpr(x)				!load to normal stack
	fi
od  

if pproc^.tag<>j_dot then		!lhs should be a pointer op
	gerror("Callmproc/not dot")
fi
pleft:=pproc^.a

evalref(pleft)					!use part of dotted seq as expression
evalexpr(pproc)				!use all of it as proc address (should yield ref proc)

genpc_int2(kcallptr,n+1,0)			!call the function

genfree(n+1)

if not calledasfn then
	genfree(1)
fi
end

function checkblockreturn(ref unitrec p)int=		!CHECKBLOCKRETURN
ref unitrec q,r

if p=nil then return 0 fi
if p^.tag<>j_block then gerror("CBR?") fi

q:=p^.a
if q=nil then return 0 fi		!empty block

while r:=q^.nextunit do			!get q=last stmt in block
	q:=r
od

case q^.tag
when j_return then			!that's an easy one...
	return 1

when j_if then
	return checkblockreturn(q^.b) and checkblockreturn(q^.c)		!all branches must have a return
when j_longif then
	r:=q^.a						!list of elsif units
	while r do
		if not checkblockreturn(r^.b) then
			return 0
		fi
		r:=r^.nextunit
	od
	return checkblockreturn(q^.b)		!else must have return too
esac
return 0
end

proc genfree(int n)=
genpc_int(kfree,n)
end

proc do_clamp(ref unitrec x,a,b)=
	evalexpr(x)
	evalexpr(a)
	genpc(kmax)
	evalexpr(b)
	genpc(kmin)
end

proc do_applyopx(ref unitrec x,a,b)=
int lab

if b then
	evalexpr(a)
	evalexpr(b)
	evalexpr(x)
	genpc_int(kapplyop,2)
else
	evalexpr(a)
	evalexpr(x)
	genpc_int(kapplyop,1)
fi
lab:=createfwdlabel()
genpc_lab(kjump,lab)		!dummy jump to be moved to runtime-generated code
genpc(knop)					!stop jump being optimised out
definefwdlabel(lab)
end

proc do_calldllvar (ref unitrec p,a,b) =	!DO_CALLDLL
ref strec d,pm
ref unitrec pbody,q,x
int naparams,fkeyword,nparams,i,j,k,resmode,m,isfn,t,langcode
[maxparams]ref unitrec cparams
[maxparams]ref strec dparams
int dparamsdone:=0
ichar name


d:=a^.def


resmode:=d^.mode
isfn:=resmode<>tvoid

if p^.tag=j_callfn and not isfn then
	gerror("DLL: needs function")
fi 
if p^.tag=j_callproc then		!result not needed
	isfn:=0
	resmode:=tvoid
fi

if isfn then
	genpc(kpushz_void)			!needed even for statement call
fi


nparams:=d^.attribs.ax_nparams
extractparams(d,&dparams)

genpc(kstartdll)

x:=b
naparams:=0
i:=1

while x do
	++naparams
	evalexpr(x)			!load to normal stack
	if i<=nparams then
		t:=dparams[i]^.mode
	else
		t:=tvoid					!type not known
	fi

	genpc_int(kpushdll,t)			!push to dll stack

	x:=x^.nextunit
	++i
od  


case d^.attribs.ax_fflang
when windowsff then
	langcode:='W'
when clangff then
	langcode:='C'
when mlangff then
	langcode:='M'
else
 gerror("Bad FF?")
esac

genpc_s(kcalldll,d)
genopnd_int(langcode)
genopnd_int(resmode)
end

proc callhostfn(int fnindex,calledasfn=0)=

genpc_int(kcallhost,fnindex)

if hostisfn[fnindex] and not calledasfn then
	genfree(1)
fi
end


proc extractparams(ref strec d, ref[]ref strec params)=
ref strec p
int i

p:=d^.paramlist
i:=0
while p do
	params^[++i]:=p
	p:=p^.nextparam
od
end

function unitstoarray(ref unitrec p, ref[]ref unitrec plist, int maxunits)int=
int n

n:=0
while p do
	if n>=maxunits then
		gerror("UTO Too many units")
	fi
	plist^[++n]:=p
	p:=p^.nextunit
od
	
return n
end

proc do_idiv(unit a,b)=
int64 x
int n

if b=nil then gerror("Idiv?") fi
evalexpr(a)

if b^.tag=j_const and b^.mode=tint then
	case x:=b^.value
	when 0 then
		gerror("div 0")
	when 1 then
		return
	esac
fi

evalexpr(b)
genpc(kidiv)

end

function ispoweroftwo(int x)int=		!ISPOWEROFTO
int a,n

a:=1
n:=0
to 30 do
	++n
	a:=a<<1
	if a=x then
		return n
	fi
od
return 0
end

proc genpushint(word64 a)=
genpc_int(kpush_ci,a)
end


proc do_callappl (ref unitrec p,a,b, int callasfn) =
ref strec d,pm
ref unitrec pbody,q,x,r
int naparams,fkeyword,nparams,i,j,k,ffcode,isfn,fbyref

[maxparams]ref unitrec params
[maxparams]ref strec dparams
int dparamsdone:=0, index
ichar name
ref intpc pc

d:=a.def
index:=d.index


pbody:=d^.code

genpc(kpushz_void)			!assume every proc is a function

nparams:=0

r:=b
while r do
	params[++nparams]:=r
	r:=r.nextunit
od

for i:=nparams downto 1 do
	evalexpr(params[i])
od

genpc_int2(kcallappl,index,nparams)


if not callasfn then	!get rid of result
	genfree(1)
fi
end

=== qc_pcllib.m 37/56 ===

import mlib
import clib
import oslib

import var_types
import var_decls
import qc_support
import qc_tables
import qc_lib
import pq_common
import qc_lex

const combineloads=0
const genlinenos=0

global ref[]intpc pccode
global int npccode=0				!current allocated size of pccode
global int pcindex					!index of last entry in pccode
global ref[0:]word16 linetable		!copy of table from moduletable
ref[]byte labelmap
global ref intpc lastopc			!points to start of last pcl instruction in pccode

global [0..cmdnames.upb]int32 cmdnopnds

global const maxlabels=1000
global [maxlabels]int32 labeltable
global int nextfreelabel

int nfields,nallfields		!set up during converttype

global int nconvertedtypes=tlast-1		!maximum type processed by converttype

global ref strec stcurrproc

strbuffer pclv
global ref strbuffer pcl = &pclv

global proc initpcl(int size)=		!INITPCL
int i,j,nn

npccode:=size*2			!used fixed size to start off with

pccode:=pcm_alloc((npccode+16)*intpc.bytes)
linetable:=pcm_allocz(npccode*word16.bytes)
pcindex:=0

mlineno:=0

for i:=1 to klastcmd do
	nn:=0
	for j:=1 to 4 do
		if cmdfmt[i,j]=0 then exit fi
		++nn
	od
	cmdnopnds[i]:=nn
od
end

global proc initpcldata=
int i,j,nn
for i:=1 to klastcmd do
	nn:=0
	for j:=1 to 4 do
		if cmdfmt[i,j]=0 then exit fi
		++nn
	od
	cmdnopnds[i]:=nn
od
stringtable:=alloctable(maxpcstrings,ichar.bytes)
stringlentable:=alloctable(maxpcstrings,int.bytes)
end

global proc initpclgen=
int i

for i:=1 to maxlabels-1 do
	labeltable[i]:=i+1
od
labeltable[maxlabels]:=0
nextfreelabel:=1

end

proc writepcl3(int pc)=		!WRITEPCL
[512]char str
qd fmt
int cmdcode,a,needcomma,i,lineno
ref intpc ptr
ref strec d

ptr:=&pccode^[pc]

cmdcode:=ptr++^

memcpy(&fmt,&cmdfmt[cmdcode],fmt.bytes)

lineno:=linetable^[pc]

fprint @&.str,"#: # ",lineno:"5",pc:"z5"

gs_str(pcl,&.str)

case cmdcode
when kprocstart then
	gs_str(pcl,"PROC:")
	d:=ref strec(int(ptr^))
	gs_str(pcl,d^.name)
GS_STR(PCL," ")
GS_STRINT(PCL,(PTR+1)^)
	gs_strln(pcl,":")
	return
when kprocend then
	gs_line(pcl)
	return
esac

if labelmap^[pc] then
	fprint @&.str,"L#:",pc
	gs_strln(pcl,&.str)
	gs_str(pcl,"             ")
fi

strcpy(&.str,cmdnames[cmdcode]+1)

a:=1
case cmdcode
when kcallhost then
	a:=2			!skip 1st operand which is the hostfn code already shown
	strcat(&.str,".")
	strcat(&.str,hostfnnames[ptr++^]+5)
esac

gs_leftstr(pcl," ",11,'-')
gs_leftstr(pcl,&.str,23)
gs_str(pcl,"     ")

needcomma:=0

for i:=a to 4 do
	case fmt[i]
	when cnone then
		exit
	else
		if needcomma then gs_str(pcl,", ") fi

		strcpy(&.str,writepclopnd3(fmt[i],ptr++^,i,cmdcode))
		gs_str(pcl,&.str)
		needcomma:=1
	esac
od

gs_line(pcl)
end

function writepclopnd3(int fmt,int64 x,int n,cmdcode)ichar=		!WRITEPCLOPND

static [512]char str,str2
ref strec d
ichar suffix
int slen

d:=ref strec(x)

case fmt
when cnone then
	return "None"

when cint,cword then

	case fmt
	when cint then suffix:="i"
	when cword then suffix:="w"
	else
		suffix:=""
	esac
	print @&.str,x,,suffix

when creal then
	print @&.str,x,real@(x)

when crange then
	fprint @&.str,"#..#",x iand 0xFFFF'FFFF,x>>32

when cstring then
	slen:=stringlentable^[x]
	if slen>=255 then slen:=255 fi
	memcpy(&.str,stringtable^[x],slen)			!truncate too-long strings
	str[slen+1]:=0
	convertstring(&.str,&.str2)
	fprint @&.str,"\"#\"",&.str2

when cmemory then
	strcpy(&.str,"[")
	strcat(&.str,getdottedname(d))
	strcat(&.str,"]")

when cframe then
	fprint @&.str,"[#:#]",getdottedname(d),d^.index

when cproc then
	fprint @&.str,"[&#] #",getdottedname(d),d^.index

when cdllproc then
	fprint @&.str,"[DLL:#]",getdottedname(d)

when cgenfield then
	print @&.str,"GENFIELD:",,x

when cfield then
	print @&.str,".",,d^.name

when ctype then
	fprint @&.str,"T:# <#>",ttname[x],x

when clabel then
	print @&.str,"L",,x

when coperator then
	print @&.str,"OP:",,cmdnames[x]

when capplproc then
	fprint @&.str,"[Applproc:#:#]",x,applproctable[x].name

else
	fprint @&.str,"<# #>",fmt,opndnames[fmt]
esac
return &.str
end

global function writepccode(ichar caption,int n)ref strbuffer=
int cmd,pc,i,lastline,line,lab

gs_init(pcl)

gs_str(pcl,"PROC ")
gs_str(pcl,caption)
gs_str(pcl,"/MODULE:")
gs_str(pcl,moduletable[n].name)
gs_str(pcl,"/")
gs_strint(pcl,n)
gs_str(pcl,"/")
gs_strint(pcl,moduletable[n].pcindex)

gs_strln(pcl,":")
gs_line(pcl)

pccode:=moduletable[n].pccode
pcindex:=moduletable[n].pcindex
pc:=1
linetable:=moduletable[n].linetable

labelmap:=zalloctable(pcindex,labelmap^[1].bytes)

while pc<=pcindex do
	cmd:=pccode^[pc]
	if cmdfmt[cmd,1]=clabel then
		lab:=pccode^[pc+1]
		labelmap^[lab]:=1
	fi
	pc+:=cmdnopnds[cmd]+1
od

pc:=1

while pc<=pcindex do
	cmd:=pccode^[pc]
	writepcl3(pc)
	pc+:=cmdnopnds[cmd]+1
od
gs_line(pcl)
return pcl
end

global proc genpc(int opc)=
if pcindex>=npccode then
	cpl =pcindex,npccode
	gerror("pccode overflow")
fi
pccode^[++pcindex]:=opc
lastopc:=&pccode^[pcindex]

linetable^[pcindex]:=mlineno
end

global proc genopnd_int(int64 x)=
pccode^[++pcindex]:=x
end

global proc genopnd_s(ref strec d)=
pccode^[++pcindex]:=int64(d)
end

global proc genpc_int(int opc, int64 a)=
genpc(opc)
pccode^[++pcindex]:=a
end

global proc genpc_int2(int opc, int64 a,b)=
genpc(opc)
pccode^[++pcindex]:=a
pccode^[++pcindex]:=b
end

global proc genpc_int4(int opc, int64 a,b,c,d)=
genpc(opc)
genopnd_int(a)
genopnd_int(b)
genopnd_int(c)
genopnd_int(d)
end

global proc genpc_s(int opc, ref strec d)=

if opc=kpush_f and lastopc and lastopc^=kpop_f or opc=kpush_m and lastopc^=kpop_m then
	if int64(d)=pccode^[pcindex] then
		lastopc^:=(opc=kpush_f|kstore_f|kstore_m)
		return
	fi
fi

genpc(opc)
pccode^[++pcindex]:=int64(d)
end

global proc genpc_str(int opc, ichar s, int length)=
genpc(opc)
genopnd_str(s,length)
end

global proc genopnd_str(ichar s, int length)=
genopnd_int(addstringtotable(s,length))
end

global proc genpc_lab(int opc, int a)=
int lastpc
genpc(opc)

if a>=0 then
	pccode^[++pcindex]:=a
	return
fi


a:=-a					!make positive
lastpc:=labeltable[a]		!will be 0 (if first ref) or pc index of last ref
pccode^[++pcindex]:=lastpc
labeltable[a]:=pcindex		!extend chain
end

global function isframe_s(ref strec p)int=		!ISFRAME

return p^.attribs.ax_frame
end

global function addstringtotable(ichar s,int length)int=
int i


if nstrings>=maxpcstrings then
	gerror("Too many strings")
fi

++nstrings

stringtable^[nstrings]:=s
stringlentable^[nstrings]:=length
return nstrings
end

=== q_libs.m 38/56 ===
import mlib
import clib

tabledata []ichar libnames,[]ichar libtext =
	("wincon",		strinclude "wincon.q"),
	("sys",			strinclude "sys.q"),
	("files",		strinclude "files.q"),
	("clib",		strinclude "clib.q"),
	("oslib",		strinclude "oslib.q"),
	("oslibsw",		strinclude "oslibsw.q"),
	("winlib",		strinclude "winlib.q"),
	("linlib",		strinclude "linlib.q"),
	("console",		strinclude "console.q"),
	("consolesw",	strinclude "consolesw.q"),
	("lincon",		strinclude "lincon.q"),
	("winapi",		strinclude "winapi.q"),
	("winconsts",	strinclude "winconsts.q"),
	("wingxlib",	strinclude "wingxlib.q"),
	("winmessages",	strinclude "winmessages.q"),
	("gxlib",		strinclude "gxlib.q"),
	("gxmisc",		strinclude "gxmisc.q"),
	("bmlib",		strinclude "bmlib.q"),
end

global function getintlib(ichar name)ichar=
int i
ichar source,newsource

for i:=1 to libnames.len do
	if eqstring(name,libnames[i]) then

		source:=libtext[i]
		rfsize:=strlen(source)
		newsource:=pcm_alloc(rfsize+4)
		memcpy(newsource,source,rfsize)
		(newsource+rfsize)^:=26
		(newsource+rfsize+1)^:=0
		return newsource
	fi
od
return nil
end

=== wincon.q 39/56 ===
import sys
import clib
import oslib

import winconsts
import winapi

global VAR SUPPRESS=0

var keypending=0
var lastkey
var pendkey
global var hconsole, hconsolein
var colourpalette

global var wscreencols,wscreenrows
global var currbgnd=-1,currfgnd=-1

global var screencolour=con_dkred..con_grey


VAR ALLCHARS

proc START=
CPL "WINCON INIT"
end

proc main=
init()
settitle("New Title")

end

global function makerspoint(x,y)=
return y<<16 ior x
end

global proc setpos(col,row)=
setconsolecursorposition(hconsole,makerspoint(col-1,row-1))
end

global function getpos=
info:=new(ws_console)
getconsolescreenbufferinfo(hconsole,&info)
return (info.pos.x+1,info.pos.y+1)
end

global proc init(cols=100)=

hconsole:=getstdhandle(-11)
hconsolein:=getstdhandle(-10)
lastkey:=new(ws_keyevent)
lastkey.repeatcount:=0
pendkey:=new(ws_keyevent)

setdims(cols,60)

getdims()


colourpalette:=new(ws_palette16)

setstdpalette()
end

global function setcursor(?visible)=
cursor:=new(ws_cursor)
getconsolecursorinfo(hconsole,&cursor)

if visible.defined then
	cursor.visible:=visible
	setconsolecursorinfo(hconsole,&cursor)
fi
return cursor.visible
end

global proc setcolour(fgnd,bgnd)=

if fgnd=currfgnd and bgnd=currbgnd then
	return
fi

currfgnd:=fgnd
currbgnd:=bgnd

setconsoletextattribute(hconsole,(bgnd*16+fgnd))
end

global proc settitle(caption)=
setconsoletitle(caption)
end

global function getkeychar=
return waitkey()
end

global function getkey2=

return getchx()

k:=getchx()			!get keyrec, encoded as int

key:=new(rkey)			!convert to proper keyrec
key.charcode:=k iand 65535
key.shift:=k>>24
key.keycode:=k.[23..16]

return key
end

global function getkey=
do
	k:=getkey2()
	case k.keycode
	when vkshift,vkctrl,vkalt,vkcapslock then
	else
		exit
	esac
od
return k
end

global function keyready=
return testkey()
end

global proc showtext(s)=
if s then
	count:=0
	if not suppress then
		writeconsole(hconsole,s,s.len,&count,0)
	fi
fi
end

proc setwindowsize(cols,rows)=
r:=new(ws_srect)
r.leftx:=0
r.rightx:=cols-1
r.top:=0
r.bottom:=rows-1
if not setconsolewindowinfo(hconsole,1,&r) then
CPL "WINDOW ERROR 1"
fi
end

global proc setdims(cols,rows)=

maxcol:=cols
maxrow:=rows

info:=new(ws_console)
oldscreenattributes:=info.attributes
oldscreensize:=info.size

oldcols:=info.window.rightx-info.window.leftx+1
oldrows:=info.window.bottom-info.window.top+1

IF OLDSCREENSIZE.X>COLS OR OLDSCREENSIZE.Y>ROWS THEN	!need to reduce window size first
	setwindowsize(oldscreensize.x min cols, oldscreensize.y min rows)
fi

if setconsolescreenbuffersize(hconsole,rows<<16+cols)=0 then
fi

setwindowsize(cols,rows)

wscreencols:=cols
wscreenrows:=rows

cursor:=new(ws_cursor)
cursor.size:=10
cursor.visible:=1
end

global proc setpalette(index,colour)=
colourpalette[index]:=colour
end

global proc writepalette=
r:=new(ws_consoleex)
r.recsize:=ws_consoleex.bytes
X:=getconsolescreenbufferinfoex(hconsole,&r)

r.palette:=colourpalette

R.WINDOW.RIGHTX:=R.WINDOW.RIGHTX+1		!workaround off-by-one bug
R.WINDOW.BOTTOM:=R.WINDOW.BOTTOM+1

X:=setconsolescreenbufferinfoex(hconsole,&r)
end


proc setstdpalette=

cols:=(
(0,		0,		0),			!black
(0,		0,		128),		!dk blue
(128,	0,		0),			!dk red
(128,	0,		128),		!dk magenta
(0,		128,	0),			!dk green
(0,		128,	128),		!dk cyan
(128,	128,	0),			!dk yellow
(128,	128,	128),		!dk grey
(192,	192,	192),		!grey
(0,		0,		192),		!blue
(192,	0,		0),			!red
(192,	0,		192),		!magenta
(0,		192,	0),			!green
(0,		192,	192),		!cyan
(192,	192,	0),			!yellow
(255,	255,	255))		!white

forall i,c in cols do
	setpalette(i-1,c[3]<<16+c[2]<<8+c[1])
od
writepalette()
end

proc getdims=
info:=new(ws_console)
getconsolescreenbufferinfo(hconsole,&info)

wscreencols:=info.window.rightx-info.window.leftx+1
wscreenrows:=info.window.bottom-info.window.top+1
end

global function getchx=
const rightaltmask	= 1				!masks used by .controlkeystate
const leftaltmask	= 2
const leftctrlmask	= 8
const rightctrlmask	= 4
const shiftmask		= 16
const capsmask		= 128
const scrollmask	= 64

const leftctrlbit	= 3		!for c.l.p
const rightctrlbit	= 2

if keypending then
	lastkey:=pendkey
	keypending:=0
else
	if lastkey.repeatcount=0 then
		repeat
			count:=0
			readconsoleinput(hconsolein,&lastkey,1,&count)
		until lastkey.eventtype=1 and lastkey.keydown=1
	fi
fi

altdown		:= (lastkey.controlkeystate iand (leftaltmask ior rightaltmask)|1|0)
ctrldown	:= (lastkey.controlkeystate iand (leftctrlmask ior rightctrlmask)|1|0)
shiftdown	:= (lastkey.controlkeystate iand shiftmask|1|0)
capslock	:= (lastkey.controlkeystate iand capsmask|1|0)

lastkey.repeatcount:=lastkey.repeatcount-1

charcode:=lastkey.asciichar
keycode:=lastkey.virtualkeycode iand 255

if altdown and ctrldown and charcode=166 then
	altdown:=ctrldown:=0;
else
	if altdown or ctrldown then
		charcode:=0;
		if keycode>='A' and keycode<= 'Z' then
			charcode:=keycode-'@'
		fi
	fi
fi

keyshift:=capslock<<3 ior altdown<<2 ior ctrldown<<1 ior shiftdown

keyshift.[4]:=lastkey.controlkeystate.[leftctrlbit]		!for c.l.p
keyshift.[5]:=lastkey.controlkeystate.[rightctrlbit]


switch charcode
when 'A'..'Z','a'..'z','0'..'9' then
when 8,9,13,27,' ','`' then
when 0 then				!already key-only event
else
	keycode:=0
endswitch

return rkey(charcode,keycode,keyshift)

end

global proc flushkeyboard=
flushconsoleinputbuffer(hconsolein)
end

global proc w_writeconsolerow(text, attributes, length, row)=
buffersize:=1<<16+length
coord:=0

box:=ws_srect(0,row-1,length-1,row-1)

buffer:=new(array,ws_charinfo,length)

for i:=1 to length do
	x:=new(ws_charinfo)
	x.asciichar  := text.[i]
	x.attributes := attributes.[i]
	buffer[i]:=x
od

writeconsoleoutputa(hconsole, &buffer,buffersize,coord,&box)
end

global function setclipboard(s)=
const ghnd=2 + 0x40

if openclipboard(0)=0 then
	return 0
fi

emptyclipboard()

if s<>"" then
	h:=globalalloc(ghnd,s.len+1)
	p:=globallock(h)

	memcpy(p,&s,s.len+1)
	globalunlock(h)
	setclipboarddata(cf_text,h)
fi

closeclipboard()

return 1
end

global function getclipboard=

if openclipboard(0)=0 then
	return ""
fi

htext:=getclipboarddata(cf_text)

if not htext then
	return ""
fi

size:=globalsize(htext)		!should include zero terminator

p:=globallock(htext)
s:=makestr(p,size-1)		!assignment should copy the string data

globalunlock(htext)

closeclipboard()
return s
end

=== sys.q 40/56 ===
global type rkey=struct	!key info as it's used locally
	word16	charcode
	byte	keycode
	byte	shift
end

global var ncmdparams
global var cmdparams
global var stclock=0

proc start=

	ncmdparams:=getcmdparam()-1
	cmdparams:=new(list,0..ncmdparams)

	for i:=0 to ncmdparams do
		cmdparams[i]:=getcmdparam(i)
	od

	cmdparams[0]:=gethostname()
end

proc main=
	start()

	files:=cmd_getparams()
	switches:=cmd_getswitches()

	println =files
	println =switches

end

global proc reporterror(m)=		!REPORTERROR
	println "Error:",m
end

global function splitstring(s,sep)=		!SPLITSTRING

	a:=()
	ns:=0
	if s="" or sep="" then return (s,) fi
	do
		n:=sep in s
		if n=0 then
			a[++ns]:=s
			return a
		fi
		t:=leftstr(s,n-1)
		a[++ns]:=t
		s:=rightstr(s,-(n+sep.len-1))
	od
	return ""
end

global function joinstrings(a,sep)=		!JOINSTRINGS
	if a.upb=0 then return "" fi
	s:=a[1]
	for i:=2 to a.upb do
		s:=s+sep+a[i]
	od
	return s
end

global proc abort(s)=		!ABORT
	println "Abort:",s,"Error"
	waitkey()
	stop 1
end

global function extractpath(fs)=		!EXTRACTPATH
	l:=fs.len
	for i:=l downto 1 do
		if chr(fs.[i]) in "\\/:" then
			return leftstr(fs,i)
		fi
	od
	return ""
end

global function extractfile(fs)=		!EXTRACTFILE
	p:=extractpath(fs)
	if p="" then return fs fi
	return rightstr(fs,-p.len)
end

global function extractbasefile(fs)=		!EXTRACTBASEFILE
	f:=extractfile(fs)
	if f="" then return "" fi
	e:=extractext(f)
	if e.len then
		f:=leftstr(f,-e.len)
	fi
	if rightstr(f)="." then
		f:=leftstr(f,-1)
	fi
	return f
end

global function extractext(fs,?period)=		!EXTRACTEXT

	f:=extractfile(fs)
	if f="" then return "" fi
	e:=""
	do
		n:="." in f
		if n then
			e:=rightstr(f,-n)
			if e="" then		!. ending
				return (period.defined and period|"."|"")
			fi

			f:=e
		else
			exit
		fi
	od

	return e
end

global function changeext(file,newext,soft=0)=		!CHANGEEXT

	ext:=extractext(file)

	p:=extractpath(file)
	bf:=extractbasefile(file)
	ep:=extractext(file,1)

	if soft and ep<>"" then return file fi		!has extension, don't change!

	if newext="" then
		return p+bf
	elsif leftstr(newext)="." then
		return p+bf+newext
	else
		return p+bf+"."+newext
	fi
end

global function addpath(path,file)=		!ADDPATH

	if leftstr(file) in "/\\." or file.len>=2 and file.[2]=":" then
		return file
	fi
	return path+file
end

global function addext(file,ext)=		!ADDEXT

	if extractext(file,1)="" then
		return changeext(file,ext)
	fi
	return file
end

global function replacestr (s,a,b)=		!REPLACESTR
	do
		n:=a in s
		if not n then return s fi
		s:=leftstr(s,n-1)+b+rightstr(s,1-n-a.len)
	od
	return ""
end

global function parsecmdparams(cmd)=		!PARSECMDPARAMS

const dash="-"

	if cmd.isarray then
		blocks:=cmd
	else
		sreadln(cmd)
		blocks:=()
		do
			read a:"s"
			if a="" then exit fi
			blocks append:=a
		od
	fi

	params:=()
	switches:=()

	forall x in blocks do
		n:=dash in x
		if n=0 then		!pure param
			params append:=x
		elsif n=1 then		!pure switches
			switches concat:=splitstring(convlc(rightstr(x,-1)),"/")
		else			!param followed by switches
			params append:=leftstr(x,n-1)
			switches concat:=splitstring(convlc(rightstr(x,-n)),"/")
		fi
	od

	return (params,switches)
end

global proc waitsec(secs)=		!WAITSEC
	sleep(int(secs*1000))
end

global function cmd_getswitches=		!CMD_GETSWITCHES

	switches:=()
	for i:=2 to cmdparams.upb do		!use 1..len in case called on <cmdparams> which has lwb 0
		s:=cmdparams[i]
		if leftstr(s) in "-/" then
			switches append:=convlc(rightstr(s,-1))
		fi
	od
	return switches
end

global function cmd_getparams=		!CMD_GETPARAMS

	cmds:=()


	for i:=2 to cmdparams.upb do
		pm:=cmdparams[i]
		if leftstr(pm) in "-" then
			next
		fi
			cmds append:=pm
	od
	return cmds
end

global function starttimer=		!STARTTIMER
	return stclock:=ticks()
end

global function stoptimer=		!STOPTIMER
	return ticks()-stclock
end

global function bnfact(n)=		!BNFACT

	if n<=2 then
		return longint(n)
	fi

	f:=1L
	g:=2L
	to n-1 do
		f:=f*g
		g:=g+1L

	od
	return f
end

global proc isort(a,?ll,?rr)=

	if ll.isvoid then
		ll:=a.lwb
		rr:=a.upb
	fi

	i:=ll
	j:=rr

	pivot:=a[(ll+rr)%2]

	repeat
		while pivot>a[i] and i<rr do ++i od
		while pivot<a[j] and j>ll do --j od
		if i<=j then
			swap(a[i],a[j])
			++i
			--j
		fi
	until i>j
	if ll<j then isort(a,ll,j) fi
	if i<rr then isort(a,i,rr) fi
end

global function sort(a)=
	b::=a
	isort(b)
	return b
end

global function pcerror(m)=
	println "Internal error:",m
	a:=b+c
	return 0
end

global proc insert(&a, b, c)=		!INSERT
	n:=a.upb
	a[n+1]:=c
	for i:=n downto b do
		swap(a[i+1],a[i])
	od
end

global proc isort2(a,b,?ll,?rr)=


	if ll.isvoid then
		ll:=a.lwb
		rr:=a.upb
	fi

	i:=ll
	j:=rr

	pivot:=a[(ll+rr)%2]

	repeat
		while pivot>a[i] and i<rr do ++i od
		while pivot<a[j] and j>ll do --j od
		if i<=j then
			swap(a[i],a[j])
			swap(b[i],b[j])
			++i
			--j
		fi
	until i>j
	if ll<j then isort2(a,b,ll,j) fi
	if i<rr then isort2(a,b,i,rr) fi
end

global function left(a,n=1)=
#return leftmost n elements of a (default left element)
#when n is negative, all except rightmost -n

	if n>=0 then
		return take(a,n)
	else
		return take(a,a.len+n)
	fi
end

global function right(a,n=1)=
#return rightmost n elements of a (default right element)
#when n is negative, all except leftmost -n

	if n>=0 then
		return drop(a,a.len-n)
	else
		return drop(a,-n)
	fi
end

global function reverse(a)=
#return reversed version of a
#when 0, returns empty
#when 1 element, returns a distinct, writeable copy

	if a.len=0 then
		return makeempty(a)
	fi
	b::=a
	if a then
		for i in a do
			b[a.upb-i+a.lwb]:=a[i]
		od
	fi
	return b
end

proc rotate(&a,middle)=

	first:=a.lwb
	lastx:=a.upb+1
	nxt:=middle

	while first<>nxt do
		swap(a[first++],a[nxt++])
		if nxt=lastx then
			nxt:=middle
		elsif first=middle then
			middle:=nxt
		fi
	od
end

function rotate2(a,middle)=
	return right(a,-middle) concat left(a,middle)
end

global function expandrange(a,step=1)=

	x:=()
	i:=a.lwb
	while i<=a.upb do
		x append:=i
		i+:=step
	od
	return x
end

global function head(a)=
#return first element, or empty when empty

	if a.len then
		return a[a.lwb]
	else
		return makeempty(a)
	fi
end

global function tail(a)=
#return all except the first element
#returns empty when only 0 or 1 elements

	case a.len
	when 0,1 then
		return makeempty(a)
	esac
	return a[2..$]
end

global function init(a)=
#return all except last element
#returns empty when only 0 or 1 elements
	case a.len
	when 0,1 then
		return makeempty(a)
	esac
	return a[a.lwb..$-1]
end

global function last(a)=
#return last element, or empty
	if a.len then
		return a[$]
	else
		return makeempty(a)
	fi
end

global function take(a,n)=
#return first n elements from list/string a
#returns () or "" when a is empty
#n > 0 (n<=0 returns empty)

	if a.len=0 or n<=0 then
		return makeempty(a)
	fi
	if n>=a.len then
		return a
	fi
	return a[a.lwb..a.lwb+n-1]
end

global function drop(a,n)=
#skips first n elements of a then returns the rest
#returns () when empty, or skipping the whole list
#n >= 0

	if a.len=0 or n>=a.len then
		return makeempty(a)
	fi
	if n<=0 then
		return a
	fi
	return a[a.lwb+n..$]
end

global function zip(a,b)=
#return a list consisting of alternate elements from a and b
#uses smaller of the two dimensions

	n:=min(a.len,b.len)
	c:=()

	(j, k) := (a.lwb, b.lwb)

	to n do
		c append:=a[j++]
		c append:=b[k++]
	od
	return c
end

global function repeatlist(a,n)=
#duplicate a n times, and return the result
#this ought to be built-in as a*n, but that's only implemented for a.len=1

	b:=makeempty(a)
	to n do
		b concat:=a
	od
	return b
end

global function minimum(a)=
	if not a then
		return void
	fi
	x:=head(a)
	forall y in tail(a) do
		x min:=y
	od
	return x
end

global function maximum(a)=
	if not a then
		return void
	fi
	x:=head(a)
	forall y in tail(a) do
		x max:=y
	od
	return x
end

global function sumlist(a)=
# apply "+" between all elements of a, and return result
# all elements must be compatble (all strings or all numbers for example)
# returns void then a is empty, or head(a) when just one element

	if not a then
		return void
	fi
	x:=head(a)
	forall y in tail(a) do
		x +:=y
	od
	return x
end

global function prepend(x,a)=
#return a but with x inserted as the first element
	return (x,) concat a
end

global proc delete(&a,?b)=		!DELETE
	n:=a.upb
	if b.isvoid then b:=n fi

	if n=b=1 then
		a:=()
		return
	fi

	if b>n then return fi
	if b<a.lwb then return fi
	for i:=b to n-1 do
		swap(a[i],a[i+1])			!swap is faster for complex elements
	od

	resize(a,n-1)
end

global proc resize(&a,n)=

	if n<a.lwb then
		a:=makeempty(a)
		return
	fi

	a::=a[a.lwb..n]			!duplication forces original to be freed
end
 
global function makebits(data,t=bit)=


	a:=new(bits,t,data.bounds)
	for i:=data.lwb to data.upb do
		a[i]:=data[i]
	od

	return a
end

global function makearray(data,t=int32)=

	a:=new(array,t,data.bounds)
	for i:=data.lwb to data.upb do
		a[i]:=data[i]
	od
	return a
end

global function tolist(a)=
	case a.basetype
	when array,string,bits then
		b:=new(list,a.bounds)
		forall i,x in a do
			b[i]:=x
		od
		return b

	when list then
		return a
	else
		pcerror("tolist:"+tostr(a.type))
	esac
	return 0
end

global function toarray(a,?t)=
	case a.basetype
	when list then
		if t.isvoid then
			if a then
				t:=a[a.lwb].type
			else
				t:=int32
			fi
		fi

	when bits then
		if t.isvoid then
			t:=byte
		fi

	when string then
		if t.isvoid then t:=byte fi
		b:=new(array,t,a.len)
		foreach i,x in a do
			b[i]:=x
		od
		return b
	when array then
		if t.isvoid then
			return a
		fi
		u:=e.elemtype
		if t=u then return a fi
	else
		pcerror("toarray:"+tostr(a.type))
	esac
	b:=new(array,t,a.bounds)

	forall i,x in a do
		b[i]:=x
	od
	return b
end

global function tobits(a,t=bit)=
	case a.basetype
	when list,array then

	when bits then
		if a.elemtype=t then
			return a
		fi

	else
		pcerror("tobits:"+tostr(a.type))
	esac
	b:=new(bits,t,a.bounds)
	forall i,x in a do
		b[i]:=x
	od
	return b
end

global function listtostring(a)=
	s:=""
	forall x in a do
		s+:=x
	od
	return s
end

global function qversion=
	return "3.0"
end

global proc issort(a,?ll,?rr)=

	if ll.isvoid then
		ll:=a.lwb
		rr:=a.upb
	fi

	i:=ll
	j:=rr

	pivot:=a.[(ll+rr)%2]

	repeat
		while pivot>a.[i] and i<rr do ++i od
		while pivot<a.[j] and j>ll do --j od
		if i<=j then
			swap(a.[i],a.[j])
			++i
			--j
		fi
	until i>j
	if ll<j then issort(a,ll,j) fi
	if i<rr then issort(a,i,rr) fi
end

global function ssort(a)=
	b::=a
	issort(b)
	return b
end

global function mapop(op,a)=
	b:=()
	if op.ispointer then

		forall i,x in a do
			b[i]:=op^(x)
		od
	else
		forall i,x in a do
			b[i]:=applyop(op,x)
		od
	fi
	return b
end

global function mapop2(op,a,b)=
	c:=()
	forall i,x in a do
		c[i]:=applyop(op,x,b[i])
	od
	return c
end

global function mapopvs(op,a,y)=
	c:=()
	forall i,x in a do
		c[i]:=applyop(op,x,y)
	od
	return c
end

global function mapopvv(op,a,b)=
	c:=()
	forall i,x in a do
		c[i]:=applyop(op,x,b[i])
	od
	return c
end

=== files.q 41/56 ===
import sys
import clib

global var readfilesize

proc start=				!START
end

proc main=

cpl "FILES TESTING"
S:=READSTRFILE("KKK1")

CPL S

end

global function openfile(name,option="rb")=
if not name.isstring or name="" then
	return 0
fi
return fopen(name,option)
end

global function createfile(name,options="wb")=		!CREATEFILE
if not options.defined then options:="wb" fi
if not name.isstring or name="" then return 0 fi

return fopen(name,options)
end

global function closefile(file)=		!CLOSEFILE
return fclose(file)=0
end

global function checkfile(name)=		!CHECKFILE
file:=fopen(name,"rb")
if file=0 then return 0 fi
fclose(file)
return 1
end

global function eof(file)=		!EOF
c:=fgetc(file)
if c=-1 then return 1 fi

ungetc(c,file)
return 0
end

global function getfilesize(file)=		!GETFILESIZE
p:=ftell(file)		!p=current position
fseek(file,0,2)		!get eof position
size:=ftell(file)		!size in bytes
fseek(file,p,0)		!restore file position
return size
end

global function setfilepos(file,offset)=		!SETFILEPOS
return fseek(file,offset,0)
end

global function getfilepos(file)=		!GETFILEPOS
return ftell(file)
end

global function readrandom(file,mem,offset,size)=		!READRANDOM
fseek(file,offset,0)
return fread(mem,1,size,file)
end

global function writerandom(file,mem,offset,size)=		!WRITERANDOM
fseek(file,offset,0)
return fwrite(mem,1,size,file)
end

global function readbytes(file,mem,size)=		!READBYTES
return fread(mem,1,size,file)
end

global function writebytes(file,mem,size)=		!WRITEBYTES
return fwrite(mem,1,size,file)
end

global function inbyte(file)=		!INBYTE
return fgetc(file)
end

global function inword(file)=		!INWORD
bb:=fgetc(file)
return fgetc(file)<<8+bb
end

global function inlong(file)=		!INLONG
ww:=inword(file)
return inword(file)<<16+ww
end

global proc outbyte(file,x)=		!OUTBYTE
fputc(x,file)
end

global proc outword(file,x)=		!OUTWORD
outbyte(file,x iand 255)
outbyte(file,x.[15..8])
end

global proc outlong(file,x)=		!OUTLONG
outword(file,x iand 65535)
outword(file,x>>16)
end

global function instring(file)=		!INSTRING
s:=""
do
	c:=inbyte(file)
	if c=0 then return s fi
	s+:=c
od
return s
end

global function appendfile(a,b)=		!APPENDFILE

f:=openfile(a)
if f=0 then return 0 fi

h:=openfile(b,"ab")
if h=0 then return 0 fi

while not eof(f) do
	readln @f,x:"l"
	println @h,x
od

closefile(f)
closefile(h)
return 1
end

global function readblockfile(filename,doetx=0)=		!READBLOCKFILE

f:=openfile(filename)
if f=0 then return 0 fi

n:=getfilesize(f)
readfilesize:=n

s:=malloc(n+doetx)
if s=0 then abort("Readfile/Malloc fails") fi
sptr:=makeref(s,byte)

readrandom(f,s,0,n)

if doetx then
	(sptr+n)^:=26
fi

closefile(f)
return sptr
end

global function readstrfile(filename,doetx=0)=		!READSTRFILE

f:=openfile(filename)
if f=0 then return 0 fi

n:=getfilesize(f)
readfilesize:=n

ptr:=malloc(n+1+doetx)
if ptr=0 then abort("Readfile/Malloc fails") fi

readrandom(f,ptr,0,n)
if doetx then
	(makeref(ptr,byte)+n)^:=26
fi

closefile(f)
s::=makestr(ptr,n+doetx)

free(ptr)
return s
end

global function writestrfile(filename,s)=		!WRITESTRFILE

f:=createfile(filename)
if f=0 then return 0 fi

writerandom(f,makeref(s,byte),0,s.len)

return closefile(f)
end

global function readbinfile(filename)=		!READBINFILE

f:=openfile(filename)
if f=0 then return 0 fi

n:=getfilesize(f)
readfilesize:=n

a:=new(array,byte,n)
readrandom(f,&a,0,n)

closefile(f)
return a
end

global function writebinfile(filename,a)=		!WRITEBINFILE

f:=createfile(filename)
if f=0 then return 0 fi

writerandom(f,(&a),0,a.len)

closefile(f)
return 1
end

global function writeblockfile(filename,p,length)=

f:=createfile(filename)
if f=0 then return 0 fi

writerandom(f,p,0,length)

closefile(f)
return 1
end

global function erasefile(filename)=		!ERASEFILE
return remove(filename)
end

global function renamefile(oldfilename,newfilename)=		!RENAMEFILE
return rename(oldfilename,newfilename)
end

global function readtextfile(file)=
f:=openfile(file)
if not f then
	return 0 
fi

readfilesize:=getfilesize(f)
a::=()

while not eof(f) do
	a append:= sreadln(f)
od
closefile(f)
return a
end

global function writetextfile(file,a)=		!WRITETEXTFILE
f:=createfile(file)
if not f then return 0 fi

for i:=a.lwb to a.upb do
	println @f,a[i]
od
closefile(f)
return 1
end

global function readbinaryfile(filename,t)=		!READBINFILE

	f:=openfile(filename)
	if f=0 then return () fi

	n:=getfilesize(f)
	readfilesize:=n
	elems:=n%t.bytes

	a:=new(array,t,elems)
	readrandom(f,&a,0,n)

	closefile(f)
	return a
end

global proc writebinaryfile(filename,data)=
	writeblockfile(filename,&data,data.bytes)
end

=== clib.q 42/56 ===
importdll msvcrt=
	clang function	malloc		(int32)intm
	clang function	realloc		(intm, int32)intm
	clang proc		free		(intm)
	clang proc		memset		(ref int32, int32, int32)
	clang proc		memcpy		(ref int32, ref int32, int32)
	clang function	clock		:int32
	clang function	ftell		(intm)int32
	clang function	fseek		(intm, int32, int32)int32
	clang function	fread		(ref int32, int32, int32, intm)int32
	clang function	fwrite		(ref int32, int32, int32, intm)int32
	clang function	getc		(intm)int32
	clang function	ungetc		(int32, intm)int32
	clang function	fopen		(string, string)intm
	clang function	fclose		(intm)int32
	clang function	fgets		(ref byte, int32, intm)ref byte
	clang function	remove		(string)int32
	clang function	rename		(string, string)int32
	clang function	getchar		:int32
	clang proc		putchar		(int32)
	clang proc		setbuf		(intm, intm)

	clang function	rand		:int32
	clang proc		srand		(int32)

	clang function	puts		(string)int32
	clang function	printf		(string, ...)int32

	clang function	sprintf		(string, string, ...)int32

	clang function	sscanf		(string, string, ...)int32
	clang function	isalpha		(int32)int32
	clang function	tolower		(int32)int32
	clang function	strlen		(ref byte)int32


	clang function	fgetc		(intm)int32
	clang function	fputc		(int32,  intm)int32
	clang function	fprintf		(intm, string, ...)int32
	clang function	fputs		(string,  intm)int32
	clang function	feof		(intm)int32
	clang function	getch		:int32

	const c_eof		= -1
	const seek_set	= 0
	const seek_curr	= 1
	const seek_end	= 2
end
=== oslib.q 43/56 ===
import sys

import oslibsw

global var daynames=("Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday")

global var Monthnames=("January","February","March","April","May","June","July",
		"August","September","October","November","December")

global var days=(31,28,31, 30,31,30, 31,31,30, 31,30,31)

global class rdate=
	var day,month,year
end

global class rdatetime = 
	var	day
	var	month
	var	year
	var	hour
	var	minute
	var	second
	var	milliseconds
	var	dayofweek
end

global const vklbutton=1		!note these are physical not logical buttons
global const vkrbutton=2
global const vkmbutton=4		!middle button is correct
global const vkbackspace=8
global const vktab=9
global const vkclear=12
global const vkenter=13
global const vkshift=16
global const vkctrl=17
global const vkalt=18
global const vkbreak=19
global const vkcapslock=20
global const vkrctrl=22
global const vkinslock=24
global const vkescape=27
global const vkspace=32
global const vkpageup=33
global const vkpagedown=34
global const vkend=35
global const vkhome=36
global const vkleft=37
global const vkup=38
global const vkright=39
global const vkdown=40
global const vkinsert=45
global const vkdelete=46
global const vkhelp=47
global const vk0='0'
global const vka='A'
global const vkwindows=91
global const vkrightbutton=93
global const vknumpad0=96		!96..105 = '0'..'9'
global const vkmul=106
global const vkadd=107
global const vksub=109
global const vkdecimal=110
global const vkdiv=111
global const vkf1=112
global const vkf2=113
global const vkf3=114
global const vkf4=115
global const vkf5=116
global const vkf6=117
global const vkf7=118
global const vkf8=119
global const vkf9=120
global const vkf10=121
global const vkf11=122
global const vkf12=123
global const vklshift=160
global const vkrshift=161
global const vklcontrol=162
global const vkrcontrol=163
global const vklalt=164
global const vkralt=165

global const vkminus=189
global const vkequals=187
global const vklsq=219
global const vkrsq=221
global const vksemi=186
global const vkquote=192
global const vkhash=222
global const vkcomma=188
global const vkperiod=190
global const vkslash=191
global const vkbackslash=220
global const vkbackquote=223

global const con_black=0
global const con_dkblue=1
global const con_dkred=2
global const con_dkmagenta=3
global const con_dkgreen=4
global const con_dkcyan=5
global const con_dkyellow=6
global const con_dkgrey=7
global const con_grey=8
global const con_blue=9
global const con_red=10
global const con_magenta=11
global const con_green=12
global const con_cyan=13
global const con_yellow=14
global const con_white=15

proc start=
end

proc main=
end

global function makedatetime(d,m,y, h=0, minute=0, s=0)=

d:=rdatetime(d,m,y, h,minute,s,0,0)
d.dayofweek:=getdow(d)
return d
end

global proc setdow(&d)=
d.dayofweek:=getdow(d)
end

global function strdate(d,sep="-")=
return tostr(d.day)+sep+leftstr(monthnames[d.month],3)+sep+tostr(d.year)
end

global function strtime(d,sep=":")=
return tostr(d.hour)+sep+tostr(d.minute,"z2")+sep+tostr(d.second,"z2")
end

global function strdow(d,n=0)=
if n then
	return leftstr(daynames[d.dayofweek],n)
else
	return daynames[d.dayofweek]
fi
end

global function strdatetime(d,dsep="-",tsep=":")=
return strdate(d,dsep)+" "+strtime(d,tsep)
end

global function confirm(m,?caption,?default)=		!CONFIRM

flags:=0x20000+0x20	!foreground window/question mark icon
flags ior:=3		!yes/no/cancel

if default.isvoid then default:=1 fi
flags ior:=(default|0,0x100,0x200|0)

status:=messagebox(0,m,(caption.defined|caption|"Confirm"),flags)
return status=6
end

global function parsedate(s,defdate)=

day:=defdate.day
month:=defdate.month
year:=defdate.year
if s.[1]=" " then s:=rightstr(s,-1) fi

sepset:=[' ', '-', '/', '.']

seppos:=0
for i:=1 to s.len do if s.[i] in sepset then seppos:=i; exit fi od

if not seppos then		!day only
	day:=strtoval(s)
	goto gotday
fi
day:=strtoval(leftstr(s,seppos-1))

s:=rightstr(s,-seppos)		!month and possible year
seppos:=0
for i:=1 to s.len do if s.[i] in sepset then seppos:=i; exit fi od

if seppos then
	monthstr:=leftstr(s,seppos-1)
	yearstr:=rightstr(s,s.len-seppos)
else
	monthstr:=s
	yearstr:=""
fi

if asc(leftstr(monthstr)) in ['0'..'9'] then	!numeric month
	month:=strtoval(monthstr)
	if month<1 or month>12 then
		return 0
	fi
else
	month:=0
	for i:=1 to 12 do
		if convlc(leftstr(monthnames[i],3))=convlc(leftstr(monthstr,3)) then
			month:=i
			exit
		fi
	od
	if not month then
		return 0
	fi
fi

if yearstr<>"" then
	year:=strtoval(yearstr)
	if year<200 then
		if year in [00..89] then
			year+:=2000
		else
			year+:=1900
		fi
	fi
fi

gotday:
dd:=days[month] 
if leapyear(year) and month=2 then dd+:=1 fi
if day<1 or day>dd then return 0 fi
if year<1990 or year>2089 then return 0 fi
return makedatetime(day,month,year)
end

global function leapyear(y)=
return (y-1900) rem 4=0
end

global function getdow(d)=
return ((getday(d)-1) rem 7)+1
end

global function getday(d)=
day:=0
for i:=1990 to d.year-1 do
	day+:=(leapyear(i)|366|365)
od

for i:=1 to d.month-1 do
	day+:=(i=2|(leapyear(d.year)|29|28)|days[i])
od
day+:=d.day
return day
end

global function getdays(m,y)=
if leapyear(y) and m=2 then return 29 fi
return days[m]
end

global function getmonthname(m,?n)=
if not m.isint then
	m:=m.month
fi
m:=monthnames[m]
if n.defined then m:=leftstr(m,n) fi
return m
end

global function getdayname(d,?n)=
if not d.isint then
	d:=getdow(d)
fi
d:=daynames[d]
if n.defined then d:=leftstr(d,n) fi
return d
end

global function addday(d0,i)=
d:=d0
if i>0 then
	to i do
		++d.day
		if d.day>getdays(d.month,d.year) then
			d.day:=1
			++d.month
			if d.month>12 then
				d.month:=1
				++d.year
			fi
		fi
	od
else
	to -i do
		--d.day
		if d.day<1 then
			--d.month
			if d.month<1 then
				d.month:=12
				--d.year
			fi
			d.day:=getdays(d.month,d.year)
		fi
	od
fi

if d.year<1990 then d:=makedatetime(1,1,1990) fi
if d.year>2089 then d:=makedatetime(31,12,2089) fi

dd:=getdays(d.month,d.year)
if leapyear(d.year) and d.month=2 then dd+:=1 fi
if d.day<1 then d.day:=1 fi
if d.day>dd then d.day:=dd fi
setdow(d)
return d
end

global function getdatetime=
tm:=getsystime()

return rdatetime(tm.day,tm.month,tm.year,
		tm.hour, tm.minute, tm.second, tm.milliseconds,tm.dayofweek)
end

global function messagebox(a,mess,caption,d)=
return oslibsw.messagebox(a,mess,caption,d)
end

global function dirlist(s,?t)=		!DIRLIST
if t.isvoid then t:=1 fi			!files only
return oslibsw.dirlist(s,t)
end

global function setcurrdir(newdir)=		!SETCURRDIR
return oslibsw.setcurrdir(newdir)
end

global function getcurrdir=		!GETCURRDIR
return oslibsw.getcurrdir()
end

global function createdir(name)=
return oslibsw.createdir(name)
end

global function direxists(path)=
return oslibsw.direxists(path)
end

global function getsystime=
return oslibsw.getsystime()
end

global proc beep1=
oslibsw.beep1()
end
=== oslibsw.q 44/56 ===

import sys
import winlib
import linlib


global function messagebox(a,mess,caption,d)=
if iswindows() then
	return winlib.messagebox(a,mess,caption,d)
else
	return linlib.messagebox(a,mess,caption,d)
fi
end

global function dirlist(s,?t)=		!DIRLIST
if t.isvoid then t:=1 fi			!files only

if iswindows() then
	return winlib.dirlist(s,t)
else
	return linlib.dirlist(s,t)
fi
end

global function setcurrdir(newdir)=		!SETCURRDIR
if iswindows() then
	return winlib.setcurrdir(newdir)
else
	return linlib.setcurrdir(newdir)
fi
end

global function getcurrdir=		!GETCURRDIR
if iswindows() then
	return winlib.getcurrdir()
else
	return linlib.getcurrdir()
fi
end

global function createdir(name)=
if iswindows() then
	return winlib.createdir(name)
else
	return linlib.createdir(name)
fi
end

global function direxists(path)=
if iswindows() then
	return winlib.direxists(path)
else
	return linlib.direxists(path)
fi
end

global function getsystime=
if iswindows() then
	return winlib.getsystime()
else
	return linlib.getsystime()
fi
end

global proc beep1=
if iswindows() then
	winlib.beep1()
else
	linlib.beep1()
fi
end
=== winlib.q 45/56 ===

import sys
import winapi

global function messagebox(a,mess,caption,d)=
return messageboxa(a,mess,caption,d)
end

global function dirlist(s,t=1)=		!DIRLIST


if t.isvoid then t:=1 fi			!files only

nfiles:=0
data::=()
file:=new(ws_finddata)

if (hfind:=findfirstfile(s,&file))<>-1 then	!at least one file
	repeat
		if (file.fileattributes iand 16) then		!this is a directory
			if (t iand 2)=0 then goto skip fi		!no directories
		else						!this is a file
			if (t iand 1)=0 then goto skip fi
		fi
		++nfiles
		if (t iand 4) then				!to lower case
			data[nfiles]:=convlc(file.filename)
		else
			data[nfiles]::=file.filename
		fi
skip:
	until not findnextfile(hfind,&file)
	findclose(hfind)
fi
return data
end

global function setcurrdir(newdir)=		!SETCURRDIR
return setcurrentdirectory(newdir)
end

global function getcurrdir=		!GETCURRDIR
a:=new(array,byte,256)
n:=getcurrentdirectory(a.len,&a[1])

if n then
	dir::=makestr(&a[1],n)
else
	dir:=""
fi

if not (rightstr(dir) in "\\/") then dir +:= "\\" fi
return dir
end

global function createdir(name)=
return createdirectory(name,0)
end

global function direxists(path)=
const file_attribute_directory=16
const invalid_file_attributes=-1

attrib := getfileattributesa(path)

return attrib<>invalid_file_attributes and (attrib iand file_attribute_directory)
end

global function getsystime=
tm:=new(ws_systemtime)
getsystemtime(&tm)

if tm.dayofweek=0 then
	tm.dayofweek:=7
fi

return tm
end

global proc beep1=
messagebeep(0)
end
=== linlib.q 46/56 ===

import sys
import clib

importdll msvcrt=
	clang function 	opendir(string)ref byte
	clang function 	closedir(ref byte)ref byte
	clang function 	getcwd(ref byte,int32)ref byte
	clang function 	chdir(string)int32
	clang function 	mkdir(string,int32)int32
	clang function 	readdir(ref byte)ref byte
	clang function 	fnmatch(string,string,int32)int32
end

type dirent32 = struct
	[10]byte d32_filler
	byte d_type
	stringz*256 d_name
end

type dirent64 = struct
	[18]byte d64_filler
	byte d_type
	stringz*256 d_name
end

global function messagebox(a,mess,caption,d)=
RETURN PCERROR("LINUX MESSAGEBOX")
end

global function dirlist(filespec,?t)=
if t.isvoid then t:=1 fi			!files only


path:=extractpath(filespec)
filepattern:=extractfile(filespec)

if path="" then path:="." fi

d:=opendir(path)
if not d then
	return ()
fi

nfiles:=0
data:=()

while dir:=readdir(d) do
	if gethostsize()=32 then
		dir:=makeref(dir,dirent32)
	else
		dir:=makeref(dir,dirent64)
	fi
	if dir^.d_type=4 then		!DIR
	elsif fnmatch(filepattern,dir^.d_name,16)=0 then
		++nfiles
		if (t iand 4) then				!to lower case
			data[nfiles]:=convlc(dir^.d_name)
		else
			data[nfiles]::=dir^.d_name
		fi
	fi
od

closedir(d)

return data
end

global function setcurrdir(newdir)=		!SETCURRDIR
return chdir(newdir)<>0
end

global function getcurrdir=		!GETCURRDIR
a:=new(array,byte,256)
p:=&a[1]

s:=getcwd(p,a.len)

if s then
	dir::=makestr(&a[1],strlen(p))
else
	dir:=""
fi

if rightstr(dir)<>"/" then dir +:= "/" fi
return dir
end

global function createdir(name)=
return system("mkdir "+name)=0
end

global function direxists(path)=
d:=opendir(path)
if d then
	closedir(d)
	return 1
fi
return 0
end

global function getsystime=
RETURN PCERROR("LINUX GETSYSTIME")
end

global proc beep1=
PCERROR("LINUX BEEP1")
end
=== console.q 47/56 ===
import sys
import oslib
import consolesw

VAR CCC=0

global record winrec =
	var posx,posy
	var cols,rows
	var fgnd,bgnd			!default text/background colour

	var columns			!used when divided into columns
	var itemcols			!width of each column
	var pagesize			!columns*rows

	var name

	var hdata			!pointer to data record, or is nil
end

global var wscreen
global var screencols,screenrows

global var chardata			!string these two represent row of the console
global var attrdata			!string

global var defscreenfgnd=con_black
global var defscreenbgnd=con_grey
global var rlkey=0		!set by readline, when special key has been input
global var rlbuffer			!contents of readline buffer when special key pressed

var cmdindex,ncmds
var cmdhistory

global const capsmask  = 0x8		!shift states as they are in .keyshift
global const altmask   = 0x4
global const ctrlmask  = 0x2
global const shiftmask = 0x1

global const capsbit=3
global const altbit=2
global const ctrlbit=1
global const shiftbit=0

PROC START=
CPL "YYYCONSOLE START INIT",=ISWINDOWS()
init()
initcmds()
END

PROC MAIN=
init()

initcmds()

END

proc keyscreentest=
(cols,rows):=(screencols, screenrows)

row:=rows%2
col:=cols%2
ch:="X"

setcolour(6,1)

do
	setpos(col,row)
	cp ch
	setpos(col,row)
	k:=getkey().keycode
	case k
	when 27 then
		exit
	when vkleft then col:=max(1,col-1)
	when vkright then col:=min(cols,col+1)
	when vkup then row:=max(1,row-1)
	when vkdown then row:=min(rows,row+1)
	esac
od


end

global proc setpos(col,row)=
consolesw.setpos(col,row)
end

global function getpos=
return consolesw.getpos()
end

global function getdims=
return (screencols,screenrows)
end

global proc init(cols=100)=


consolesw.init(cols)
cmdhistory::=()	!"one","two","three","four")
ncmds:=cmdhistory.upb
cmdindex:=0

screencols:=consolesw.wscreencols
screenrows:=consolesw.wscreenrows


wscreen:=makewin((1,1),(screencols,screenrows),defscreencolour)

chardata:=" "*screencols
attrdata:=chr(0xf0)*screencols
end

global proc setcolour(fgnd,bgnd)=
consolesw.setcolour(fgnd,bgnd)
end

global proc settitle(caption)=
consolesw.settitle(caption)
end

global function getkey=
return consolesw.getkey()
end

global function keyready=
return consolesw.keyready()
end

global proc flushkbd=
consolesw.flushkeyboard()
end

global function readline(?cmdline,donewline=1)=


buffer:=""
nchars:=0

(startx,starty):=(getpos())

pos:=0		!with nchars shown, pos can be 0 to nchars

reenter:
if cmdline.defined and cmdline<>"" then
	buffer:=cmdline
reenter2:
	pos:=nchars:=buffer.len
fi

do
	rlkey:=0			!normal input starts with "*" will expect rlkey to be a keyrec
	setpos(startx,starty)
	print buffer
	setpos(startx+pos,starty)

	key:=getkey()
	keycode:=key.keycode
	keyshift:=key.shift

	case keycode
	when vkpageup,vkpagedown,vkup,vkdown,vkinsert,vkf1..vkf12 then

dospecial:
	rlbuffer:=buffer
		oldbufferlen:=buffer.len		!to help erase old buffer
		buffer:=getkeyname(key)
		rlkey:=key				!allow caller to use key code rather than name
		exit

	when vkleft then
		if buffer="" then goto dospecial fi
		if (keyshift iand 7) then goto dospecial fi

		if pos>0 then
			--pos
		fi

	when vkhome then
		if buffer="" then goto dospecial fi
		if (keyshift iand 7) then goto dospecial fi
		pos:=0

	when vkend then
		if buffer="" then goto dospecial fi
		if (keyshift iand 7) then goto dospecial fi
		pos:=nchars

	when vkright then
		if buffer="" then goto dospecial fi
		if (keyshift iand 7) then goto dospecial fi
		if pos<nchars then
			++pos
		fi

	when vkenter then

		exit

	when vkbackspace then

		if (keyshift iand 7) then goto dospecial fi
		if nchars then
			setpos(startx,starty)
			print " "*buffer.len

			case pos
			when 0 then			!not allowed
			when nchars then		!at end
				buffer:=leftstr(buffer,-1)
				--nchars
				--pos
			else				!in middle
				buffer:=leftstr(buffer,pos-1)+rightstr(buffer,-(pos))
				--nchars
				--pos
			esac

		fi

	when vkdelete then
		if (keyshift iand 7) then goto dospecial fi
		if nchars and nchars=pos then
			goto delline
		fi
		if nchars=0 then
			goto dospecial
		fi
		if nchars then
			setpos(startx,starty)
			print " "*buffer.len

			case pos
			when nchars then		!not allowed
			else				!in middle
				buffer:=leftstr(buffer,pos)+rightstr(buffer,-(pos+1))
				--nchars
			esac

		fi

	when vkescape then
		if nchars=0 then
			goto dospecial
		fi
delline:
		setpos(startx,starty)
		print " "*buffer.len

		buffer:=""
		nchars:=pos:=0

	when vktab then
		goto normalkey

	else
normalkey:
		if (key.charcode>=' ' or key.charcode=9) then
			if pos=0 then
				buffer:=chr(key.charcode)+buffer
			elsif pos=nchars then
				buffer:=buffer+chr(key.charcode)
			else
				buffer:=leftstr(buffer,pos)+chr(key.charcode)+rightstr(buffer,-(pos))
			fi
			++nchars
			++pos
		else
			GOTO DOSPECIAL
			print "<",keycode,key.charcode,">"
		fi

	esac
od

case buffer
when "*cup","*cdown" then
	if ncmds then
		setpos(startx,starty)
		print " "*oldbufferlen

		if cmdindex=0 then		!get started on last
			cmdline:=cmdhistory[ncmds]
			cmdindex:=ncmds
			goto reenter
		fi

		if buffer="*cup" and cmdindex>1 then
			--cmdindex
		elsif buffer="*cdown" and cmdindex<ncmds then
			++cmdindex
		fi
		cmdline:=cmdhistory[cmdindex]
		goto reenter
	fi
	buffer:=""
	goto reenter2
esac

if buffer.len>1 and leftstr(buffer)<>"*" then
	if ncmds=0 or cmdhistory[ncmds]<>buffer then
		cmdhistory[++ncmds]:=buffer
	fi
	cmdindex:=0
fi

if donewline then println fi

return sreadln(buffer)
end

global proc showtext(s,?x,?y)=

if x.defined then
	consolesw.setpos(x,y)
fi
count:=0
if s then
	consolesw.showtext(s)
fi
end

global proc setdims(cols,rows)=
consolesw.setdims(cols,rows)
end

global function setcursor(?visible)=
return consolesw.setcursor(visible)
end

proc initcmds=
cmdhistory::=()
ncmds:=cmdhistory.upb
cmdindex:=0
end

global proc clearscreen(?bgnd,?fgnd)=

if bgnd.isvoid then bgnd:=defscreenbgnd fi
if fgnd.isvoid then fgnd:=defscreenfgnd fi
setcolour(fgnd,bgnd)

for i:=1 to screenrows do
	consolesw.setpos(1,i)
	consolesw.showtext(" "*screencols)
od
setpos(1,1)
end

global proc clearwin(w)=
spaces:=" "*w.cols

setcolour(w.fgnd,w.bgnd)
for i:=1 to w.rows do
	showtext(spaces,w.posx,w.posy+i-1)
od
setpos(w.posx,w.posy)
end

global function getkeyname(key)=
case key.keycode
when vkleft then name:="left"
when vkright then name:="right"
when vkup then name:="up"
when vkdown then name:="down"
when vkpageup then name:="pageup"
when vkpagedown then name:="pagedown"
when vkhome then name:="home"
when vkend then name:="end"
when vkinsert then name:="insert"
when vkdelete then name:="delete"
when vktab then name:="tab"
when vkescape then name:="escape"
when vkbackspace then name:="backspace"
when vkenter then name:="enter"
when vkf1..vkf12 then name:="f"+tostr(key.keycode-vkf1+1)
when vkspace then name:="space"
else
	if key.charcode in [1..26] then	!ctrl code
		name:=chr(key.charcode+'a'-1)
	elsif key.charcode in ['!','"','','$','%','^','&','*','(',')','-','_','+','=','[',']',
	'{','}',':',';','\'','@','~','#','<','>',',','.','/','','','|','\\','?'] then
		name:=chr(key.charcode)
		key.shift iand:=inot shiftmask		!ignore any shift press needed to get char

	elsif key.keycode in ['A'..'Z','0'..'9'] then
		if (key.shift iand (ctrlmask ior altmask))=0 then
			name:=chr(key.charcode)
			key.shift iand:=inot shiftmask
		else
			name:=convlc(chr(key.keycode))
		fi
	elsif key.keycode in (186..223) then
		case key.keycode
		when vkminus then name:="-"
		when vkequals then name:="="
		when vklsq then name:="["
		when vkrsq then name:="]"
		when vksemi then name:=";"
		when vkquote then name:="'"
		when vkhash then name:="#"
		when vkcomma then name:=","
		when vkperiod then name:="."
		when vkslash then name:="/"
		when vkbackslash then name:="\\"
		when vkbackquote then name:="`"
		else
			return "?"
		esac
	else
		return "?"
	fi
esac

prefix:="*"
if key.shift iand shiftmask then prefix+:="s" fi
if key.shift iand ctrlmask then prefix+:="c" fi
if key.shift iand altmask then prefix+:="a" fi
return prefix+name

end

global function keynametokey(name)=
charcode:=shift:=keycode:=0

name:=rightstr(name,-1)		!get rid of "*"

if name.len=1 then		!simple printable key, no shifts
	charcode:=asc(name)
	goto simplekey

else				!any letters s,c,a on left indicate a modifier
	while name.len>1 do
		case leftstr(name)
		when "s" then
			shift ior:=shiftmask
			name:=rightstr(name,-1)
		when "c" then
			shift ior:=ctrlmask
			name:=rightstr(name,-1)
		when "a" then
			shift ior:=altmask
			name:=rightstr(name,-1)
		else
			exit
		esac
	od

	case name
	when "left" then keycode:=vkleft
	when "right" then keycode:=vkright
	when "up" then keycode:=vkup
	when "down" then keycode:=vkdown
	when "pageup" then keycode:=vkpageup
	when "pagedown" then keycode:=vkpagedown
	when "home" then keycode:=vkhome
	when "end" then keycode:=vkend
	when "insert" then keycode:=vkinsert
	when "delete" then keycode:=vkdelete
	when "tab" then keycode:=charcode:=vktab
	when "escape" then keycode:=vkescape
	when "backspace" then keycode:=charcode:=vkbackspace
	when "enter" then keycode:=charcode:=vkenter
	when "space" then keycode:=charcode:=vkspace
	else
		if name.len>=2 and leftstr(name)="f" then	!function key
			keycode:=vkf1+strtoval(rightstr(name,-1))-1
		elsif name.len=1 then				!ordinary key, but with shifts
simplekey:
			c:=asc(name)
			case c
			when ['A'..'Z'] then
				keycode:=c
			when ['a'..'z'] then
				keycode:=c-' '
			when ['0'..'9'] then
				keycode:=c
			when '-','_' then keycode:=vkminus
			when '=','+' then keycode:=vkequals
			when '[','{' then keycode:=vklsq
			when ']','}' then keycode:=vkrsq
			when ';',':' then keycode:=vksemi
			when '\'','@' then keycode:=vkquote
			when ',','<' then keycode:=vkcomma
			when '.','>' then keycode:=vkperiod
			when '/','?' then keycode:=vkslash
			when '\\','|' then keycode:=vkbackslash
			when '`','' then keycode:=vkbackquote
			when '#','~' then keycode:=vkhash
			when '!' then keycode:='1'
			when '"' then keycode:='2'
			when '' then keycode:='3'
			when '$' then keycode:='4'
			when '%' then keycode:='5'
			when '^' then keycode:='6'
			when '&' then keycode:='7'
			when '*' then keycode:='8'
			when '(' then keycode:='9'
			when ')' then keycode:='0'
			else
				pcerror("keynametokey")
			end
		fi
	esac
fi

if shift iand (altmask ior ctrlmask) then
	charcode:=0
	if keycode in 'A'..'Z' then
		charcode:=keycode-'@'
	fi
fi

key:=new(rkey)			!convert to proper keyrec
key.charcode:=charcode
key.shift:=shift
key.keycode:=keycode
return key
end

global function makewin(pos, dims, ?fgnd,?bgnd,name="Anon")=

w:=new(winrec)
w.posx:=pos[1]
w.posy:=pos[2]
w.cols:=dims[1]
w.rows:=dims[2]
w.columns:=1
if dims.len>=3 then
	w.columns:=dims[3]
fi


w.itemcols:=w.cols%w.columns
w.pagesize:=w.rows*w.columns
w.hdata:=nil

w.fgnd:=fgnd
w.bgnd:=bgnd
w.name:=name

return w
end

global proc wsetpos(w,col,row)=
setpos(w.posx+col-1,w.posy+row-1)
end

global proc wshowtext(w,s,?col,?row)=
if col.defined then
	showtext(s,w.posx+col-1,w.posy+row-1)
else
	showtext(s)
fi
end

global function wgetpos(w)=
pos:=consolesw.getpos()
return (w.posx+pos.lwb-1)..(w.posy+pos.upb-1)
end

global proc wsetcolour(w,?fgnd,?bgnd)=
if fgnd.defined then
	setcolour(fgnd,bgnd)
else
	setcolour(w.fgnd,w.bgnd)
fi
end

global proc wsetcolumns(w,columns)=
w.columns:=columns
w.itemcols:=w.cols%w.columns
w.pagesize:=w.rows*w.columns
end

global proc wshowtext_b(w,s,col,fgnd,bgnd)=

length:=s.len
offset:=w.posx-1	!hoz offset

chardata.[(col+offset)..(col-1+length+offset)]:=s

attr:=bgnd<<4+fgnd

attrdata.[(col+offset)..(col-1+length+offset)]:=chr(attr)*length
end

global proc updateconsolerow(row)=
consolesw.w_writeconsolerow(chardata,attrdata,screencols,row)
end

global function setclipboard(s)=
return consolesw.setclipboard(s)
end

global function getclipboard=
return consolesw.getclipboard()
end
=== consolesw.q 48/56 ===
import sys

import wincon
import lincon

global var wscreencols,wscreenrows


global var colourmap

var iswin=iswindows()

proc start=

if iswin then
	wscreencols:=wincon.wscreencols
	wscreenrows:=wincon.wscreenrows
else
	wscreencols:=lincon.wscreencols
	wscreenrows:=lincon.wscreenrows
fi
end

global proc init(?cols)=

if iswin then
	wincon.init(cols)
else
	lincon.init(cols)
fi
if iswin then
	wscreencols:=wincon.wscreencols
	wscreenrows:=wincon.wscreenrows
else
	wscreencols:=lincon.wscreencols
	wscreenrows:=lincon.wscreenrows
fi
end

global proc setpos(col,row)=
if iswin then
	wincon.setpos(col,row)
else
	lincon.setpos(col,row)
fi
end

global function getpos=
if iswin then
	return wincon.getpos()
else
	return lincon.getpos()
fi
end

global function setcursor(?visible)=
if iswin then
	return wincon.setcursor(visible)
else
	return lincon.setcursor(visible)
fi
end

global proc setcolour(fgnd,bgnd)=
if iswin then
	wincon.setcolour(fgnd,bgnd)
else
	lincon.setcolour(fgnd,bgnd)
fi
end

global proc settitle(caption)=
if iswin then
	wincon.settitle(caption)
else
	lincon.settitle(caption)
fi
end


global function getkey2=
return PCERROR("SW/GETKEY2")
end

global function getkey=
if iswin then
	return wincon.getkey()
else
	return lincon.getkey()
fi
end

global function keyready=
if iswin then
	return wincon.keyready()
else
	return lincon.keyready()
fi
end

global proc showtext(s)=
if iswin then
	wincon.showtext(s)
else
	lincon.showtext(s)
fi
end

global proc setdims(cols,rows)=
PCERROR("SW/SETDIMS")
end

global proc setpalette(index,colour)=
if iswin then
	wincon.setpalette(index,colour)
else
	lincon.setpalette(index,colour)
fi
end

global proc writepalette=
pcerror("SW/WRITEPALETTE")
end

global proc flushkeyboard=
if iswin then
	wincon.flushkeyboard()
else
	lincon.flushkeyboard()
fi
end

global proc w_writeconsolerow(text, attributes, length, row)=
if iswin then
	wincon.w_writeconsolerow(text,attributes,length,row)
else
	lincon.w_writeconsolerow(text,attributes,length,row)
fi
end

global function setclipboard(s)=
if iswin then
	return wincon.setclipboard(s)
else
	return lincon.setclipboard(s)
fi
end

global function getclipboard=
if iswin then
	return wincon.getclipboard()
else
	return lincon.getclipboard()
fi
end
=== lincon.q 49/56 ===
import sys
import oslib

var digits=['0'..'9']
var navkeys=['A':vkup, 'B':vkdown, 'C': vkright, 'D':vkleft, 'H':vkhome, 'F':vkend,
				'P':vkf1, 'Q':vkf2, 'R': vkf3, 'S':vkf4]

var fnkeys= [15:vkf5, 17:vkf6, 18:vkf7, 19:vkf8, 20:vkf9, 21:vkf10, 23:vkf11, 24:vkf12]

const capsmask  = 0x8		!shift states as they are in .keyshift
const altmask   = 0x4
const ctrlmask  = 0x2
const shiftmask = 0x1

const capsbit=3
const altbit=2
const ctrlbit=1
const shiftbit=0

var shiftcodes = [5:ctrlmask, 2:shiftmask, 3:altmask, 4:shiftmask+altmask, 7:ctrlmask+altmask]

global var wscreencols,wscreenrows
global var currbgnd=-1,currfgnd=-1

global var colourmap
var colourxref

global proc init(cols=100)=



getdims()

colourmap:=(@0: \
	0,	!black	dk versions
	1,	!blue
	4,	!red
	5,	!magenta
	2,	!green
	3,	!cyan
	6,	!yellow
	7,	!green

	8,	!dkgrey
	9,	!blue	bright versions
	12,
	13,
	10,
	11,
	14,
	15)

colourxref:=(0:\		!windows colour numbers to linux (or nearest equiv)
	0,
	4,
	1,
	5,
	2,
	14,
	3,
	7,
	8,
	12,
	9,
	13,
	10,
	14,
	5,
	15)




end

proc getdims=
(wscreencols,wscreenrows):=getscreensize()


end

global proc setpos(column,row)=
fprint "\s[#;#H",row,column
end

proc setfgndcol(colour)=
fprint "\s[#m",colour+30
end

proc setbgndcol(colour)=
fprint "\s[#m",colour+40
end

global proc setbold(bold)=
fprint "\s[#m",(bold|1|21)
end

global proc setitalic(italic)=
fprint "\s[#m",(italic|3|23)
end

global function getpos=
print "\s[6n"
readkey()		!escape
readkey()		![

(row,column,c):=readkbdsequence()
return (column,row)
end

global function setcursor(?visible)=
return 1
end

global proc setcolour(fgnd,bgnd)=

if fgnd=currfgnd and bgnd=currbgnd then
	return
fi

currfgnd:=fgnd
currbgnd:=bgnd

fgnd:=colourxref[fgnd]
bgnd:=colourxref[bgnd]

setbold(fgnd>7)
setfgndcol(fgnd iand 7)
setbgndcol(bgnd iand 7)
end

global proc settitle(caption)=
end

global function keyready=
return pcerror("Linux/keyready")
end

global proc showtext(s)=
if s then
	print s
fi
end

global proc setdims(cols,rows)=
pcerror("linux/setdims")
end

global proc setpalette(index,colour)=
pcerror("linux/setpallete")
end

function getscreensize=
savepos()
setpos(999,999)
(cols,rows):=getpos()

restorepos()
return (cols,rows)
end

proc savepos=
print "\s[s"
end

proc restorepos=
print "\s[u"
end

function readkey=
return waitkey()
end

function readintseq(c)=
x:=c-'0'
do
	c:=readkey()
	if c in digits then
		x:=x*10+c-'0'
	else
		exit
	fi
od
return (x,c)
end

function readkbdsequence=

x:=y:=0

c:=readkey()

if c in digits then
	(x,c):=readintseq(c)
	if c=';' then
		c:=readkey()
		if c not in digits then return -1 fi

		(y,c):=readintseq(c)
	fi
fi

if c='~' then
	return (x,y,0)
fi
return (x,y,c)				!assume A-Z
end


global function getkey=

k:=readkey()				!LINUX ONLY

case k
when 10 then
	return rkey(13,vkenter,0)
when 8,127 then
	return rkey(127,vkbackspace,0)
when 9 then
CPL "TAB1"
	return rkey(vktab,vktab,0)
when 'A'..'Z','0'..'9' then
	return rkey(k,k,0)
when 'a'..'z' then
	return rkey(k,k-' ',0)
when 27 then
when 1..31 then
	return rkey(k,0,ctrlmask)
else
	c:=k
	case k
	when '[','{' then k:=vklsq
	when ']','}' then k:=vkrsq
	else
		k:=0
	esac

	return rkey(c,k,0)
esac


k:=readkey()

case k
when 27 then			!esc/esc => single escape
	return rkey(0,k,0)

when 10 then			!esc/10 => alt enter
	return rkey(0,vkenter,altmask)

when 8,127 then			!esc/bs => alt bs
	return rkey(0,vkbackspace,altmask)

when 'O' then			!short set of function keys
	(x,y,c):=readkbdsequence()

CPL "O",x,y,chr(c)
	return rkey(0,navkeys{c},shiftcodes{y,0})

when '[' then
	(x,y,c):=readkbdsequence()
	case c
	when 'Z' then						!shift+tab
		return rkey(9,9,shiftmask)
	when 'A','B','C','D','H','F','P','Q','R','S' then		!cursor keys, fn1..4; assume x=1
		return rkey(0,navkeys{c},shiftcodes{y,0})
	esac

	case x
	when 2,3,5,6 then
		shift:=0
		case y
		when 5 then shift:=ctrlmask
		when 3 then shift:=altmask
		when 7 then shift:=altmask+ctrlmask
		esac
		return rkey(0,(x|0,vkinsert,vkdelete,0,vkpageup|vkpagedown),shift)
	when 15..24 then
		return rkey(0,fnkeys{x},shiftcodes{y,0})
	esac

when 'A'..'Z' then			!must have been alt version (some esc letter codes above)
	return rkey(k-64,0,altmask) 

when 'a'..'z' then			!must have been alt version (some esc letter codes above)
	return rkey(k-96,0,altmask) 

when '0'..'9' then
	return rkey(0,k,altmask) 

esac
CPL "ESC 91"

return rkey(0,'?',0)
end

proc screentest=

savepos()
setpos(10,10)
setfgndcol(5)
setbgndcol(3)
setbold(1)
setitalic(1)
println "	HELLO	"
setbold(0)
setitalic(0)
restorepos()
println "	Goodbye	"

(cols,rows):=getscreensize()
cpl =rows,=cols
waitkey()
end


proc keyscreentest=
(cols,rows):=getscreensize()
CPL =COLS,=ROWS

row:=rows%2
col:=cols%2
ch:="X"

setfgndcol(6)
setbgndcol(1)

do
	setpos(col,row)
	cp ch
	setpos(col,row)
	k:=getkey().keycode
	case k
	when 27 then
		exit
	when vkleft then col:=max(1,col-1)
	when vkright then col:=min(cols,col+1)
	when vkup then row:=max(1,row-1)
	when vkdown then row:=min(rows,row+1)
	esac
od


end

proc main=

keyscreentest()
end

proc start=
end

global proc w_writeconsolerow(text, attributes, length, row)=


setpos(1,row)
for i:=1 to length-1 do
	attrs:=attributes.[i]
	c:=text.[i]
	setcolour(attrs iand 15, attrs>>4)
	print chr(c)
od
return

end

global proc flushkeyboard=
end

global function setclipboard(s)=
abort("linux/setclipboard")
return 0
end

global function getclipboard=
abort("linux/getclipboard")
return ""
end

=== winapi.q 50/56 ===
global type wt_word		= word16
global type wt_bool		= word32
global type wt_dword	= word32
global type wt_wchar	= word16
global type wt_char		= byte
global type wt_ichar	= string
global type wt_string	= string
global type wt_ptr		= ref byte
global type wt_wndproc	= wordm

global type wt_handle	= refm
global type wt_int		= int32
global type wt_uint		= word32
global type wt_long		= int32
global type wt_wparam	= wordm
global type wt_lparam	= wordm
global type wt_size		= wordm

global type wt_wparam32	= word32
global type wt_lparam32	= word32
global type wt_handle32	= word32
global type wt_ptr32	= word32
global type wt_string32	= word32
global type wt_wndproc32	= word32

global type wt_wparam64	= word64
global type wt_lparam64	= word64
global type wt_handle64	= word64
global type wt_ptr64	= word64
global type wt_string64	= word64
global type wt_wndproc64= word64

global type wt_result	= wordm
global type wt_intptr	= wordm
global type wt_coord	= word32

global type ws_spoint= struct
	int16 x,y
end

global type ws_srect=struct		!rect record occupying 8 bytes
	int16 leftx,top, rightx,bottom
end

global type ws_charinfo=struct
	union
		wt_word	unicodechar
		wt_char	asciichar
	end union
	wt_word		attributes
end

global type ws_palette16=[0..15]int32

global type ws_console=struct
	ws_spoint size,pos
	wt_word attributes
	ws_srect window
	ws_spoint maxwindowsize
end

global type ws_consoleex=struct
	int32 recsize
	ws_spoint size,pos
	wt_word attributes
	ws_srect window
	ws_spoint maxwindowsize
	wt_word wpopup
	int32 fullscreen
	ws_palette16 palette
end

global type ws_keyevent = struct
	wt_word	eventtype
		wt_bool	keydown			@@4	!key event record (was inside 'Event' union in win32)
		wt_word	repeatcount
		wt_word	virtualkeycode
		wt_word	virtualscancode
		union
			wt_word unicodechar
			wt_char asciichar
		end
		wt_dword controlkeystate
end

global type ws_cursor=struct(int32 size,visible)

global var hconsole, hconsolein

global const stdoutputhandle=0xffff_fff5i
global const stdinputhandle=0xfffffff6i
global const stderrorputhandle=0xfffffff4i
global const invalidhandlevalue=0xffffffffi

global const maxpathlen=260

type spath=stringz*maxpathlen
type sshort=stringz*14
global type ws_filetime=struct
	int32 ftlow
	int32 fthigh
end

global type ws_finddata=struct
	int32		fileattributes
	ws_filetime	creationtime
	ws_filetime	lastaccesstime
	ws_filetime	lastwritetime
	int32		filesizehigh
	int32		filesizelow
	int32		reserved0
	int32		reserved1
	spath		filename
	sshort		shortfilename
end

global type ws_systemtime = struct
	word16	year
	word16	month
	word16	dayofweek
	word16	day
	word16	hour
	word16	minute
	word16	second
	word16	milliseconds
end

global type ws_msg32 = struct
	int32	hwnd
	int32	message
	int32	wparam
	int32	lparam
	int32	time
	int32	ptx
	int32	pty
end

global type ws_msg64 = struct@@8
	int64	hwnd
	int32	message
	int64	wparam@@0
	int64	lparam
	int32	time
	int32	ptx	@@8
	int32	pty
end

global type ws_point = struct
	int32 x, y
end

global type ws_rect=struct		!rect record occupying 16 bytes
	int32 leftx,top, rightx,bottom
	int32	x@leftx
	int32	y@top
	int32	x2@rightx
	int32	y2@bottom
	int32	x1@leftx
	int32	y1@top
end

global type ws_logbrush = struct
	int32 lbstyle
	int32 lbcolour
	int32 lbhatch
end

global type ws_textmetrics = struct
	int32	height
	int32	ascent
	int32	descent
	int32	int32ernalleading
	int32	externalleading
	int32	avecharwidth
	int32	maxcharwidth
	int32	weight
	int32	overhang
	int32	digitizedaspectx
	int32	digitizedaspecty
	byte	firstchar
	byte	lastchar
	byte	defaultchar
	byte	breakchar
	byte	italic
	byte	underlined
	byte	struckout
	byte	pitchandfamily
	byte	charset
end

global type ws_bitmapv5header = struct
	int32	size
	int32	width
	int32	height
	word16	planes
	word16	bitcount
	int32	compression
	int32	sizeimage
	int32	xpelspermeter
	int32	ypelspermeter
	int32	clrused
	int32	clrimportant
	int32	redmask
	int32	greenmask
	int32	bluemask
	int32	alphamask
	int32	cstype
	[1..9]int32 endpoints
	int32	redgamma
	int32	greengamma
	int32	bluegamma
	int32	intent
	int32	profiledata
	int32	profilesize
	int32	reserved
end

global type ws_bitmapfileheader = struct
	wt_word		typex
	wt_dword	size
	wt_word		res1, res2
	wt_dword	offbits
end

global type ws_bitmapinfoheader = struct
	wt_dword 	size
	wt_long		width
	wt_long		height
	wt_word		planes
	wt_word		bitcount
	wt_dword	compression
	wt_dword	sizeimage
	wt_long		xpelspermetre
	wt_long		ypelspermetre
	wt_dword	clrused
	wt_dword	clrimportant
end

global type ws_paintstruct = struct
	int64		hdc
	int32		erase
	ws_rect		paintrect
	int32		restore
	int32		incupdate
	[32]byte	rgbreserved
end

global type ws_openfilename32 = struct
	wt_dword		structsize
	wt_handle32		owner
	wt_handle32		instance
	wt_string32		filter
	wt_string32		customfilter
	wt_dword		maxcustfilter
	wt_dword		filterindex
	wt_string32		file
	wt_dword		maxfile
	wt_string32		filetitle
	wt_dword		maxfiletitle
	wt_string32		initialdir
	wt_string32		title
	wt_dword		flags
	wt_word			fileoffset
	wt_word			fileextension
	wt_string32		defext
	wt_lparam32		custdata
	wt_wndproc32	hook
	wt_string32		templatename
	wt_ptr32		reserved1
	wt_dword		reserved2
	wt_dword		flagsex
end

global type ws_openfilename64 = struct @@8
	wt_dword		structsize
	wt_handle64		owner@@0
	wt_handle64		instance
	wt_string64		filter
	wt_string64		customfilter
	wt_dword		maxcustfilter
	wt_dword		filterindex
	wt_string64		file@@0
	wt_dword		maxfile
	wt_string64		filetitle@@0
	wt_dword		maxfiletitle
	wt_string64		initialdir@@0
	wt_string64		title
	wt_dword		flags
	wt_word			fileoffset
	wt_word			fileextension
	wt_string64		defext@@0
	wt_lparam64		custdata
	wt_wndproc64	hook
	wt_string64		templatename
	wt_ptr64		reserved1
	wt_dword		reserved2
	wt_dword		flagsex
end

importdll kernel32=
	windows function	"GetLastError"					:wt_dword
	windows function	"GetStdHandle"					(wt_dword)wt_handle
	windows function	"WriteConsoleA" as writeconsole				(wt_handle,wt_ptr,wt_dword,wt_ptr,wt_ptr)wt_bool
	windows function	"SetConsoleCursorPosition"		(wt_handle,wt_coord)wt_bool
	windows function	"GetConsoleScreenBufferInfo"	(wt_handle,wt_ptr)wt_bool
	windows function	"SetConsoleMode"				(wt_handle,wt_dword)wt_bool
	windows function	"WriteConsoleOutputA" as writeconsoleoutput			(wt_handle,wt_ptr,wt_coord,wt_coord,wt_ptr)wt_bool

	windows function	"GetConsoleScreenBufferInfoEx"	(wt_handle,wt_ptr)wt_bool
	windows function	"SetConsoleScreenBufferInfoEx"	(wt_handle,wt_ptr)wt_bool

	windows function	"SetConsoleTextAttribute"		(wt_handle,wt_word)wt_bool
	windows function	"SetConsoleTitleA" as setconsoletitle				(wt_string)wt_bool
	windows function	"ReadConsoleInputA" as readconsoleinput			(wt_handle,wt_ptr,wt_dword,wt_ptr)wt_bool
	windows function	"PeekConsoleInputA"			(wt_handle,wt_ptr,wt_dword,wt_ptr)wt_bool
	windows function	"FlushConsoleInputBuffer"		(wt_handle)wt_bool
	windows function	"SetConsoleWindowInfo"			(wt_handle,wt_bool,wt_ptr)wt_bool
	windows function	"SetConsoleScreenBufferSize"	(wt_handle,wt_coord)wt_bool
	windows function	"GetConsoleCursorInfo"			(wt_handle,wt_ptr)wt_bool
	windows function	"SetConsoleCursorInfo"			(wt_handle,wt_ptr)wt_bool
	windows function	"GetNumberOfConsoleInputEvents"(wt_handle,wt_ptr)wt_bool
	windows function    	"GetConsoleWindow":wt_handle

	windows function	"FindFirstFileA" as findfirstfile		(string,ref int32)int32
	windows function	"FindNextFileA"  as findnextfile			(int32,ref int32)int32
	windows function	"FindClose"					(int32)int32
	windows function	"SetCurrentDirectoryA" as setcurrentdirectory	(string)int32
	windows function	"GetCurrentDirectoryA" as getcurrentdirectory	(int32,int32)int32
	windows function	"CreateDirectoryA" as createdirectory		(string,int32)int32
	windows function	"GetFileAttributesA"			(string)int32
	windows function	"GetModuleHandleA" as getmodulehandle		(wt_string)wt_handle
	windows function	"GetTickCount"								:wt_dword
	windows function	"GlobalAlloc"									(wt_uint,wt_size)wt_handle
	windows function	"GlobalLock"									(wt_handle)wt_ptr
	windows function	"GlobalUnlock"								(wt_handle)wt_bool
	windows function	"GlobalSize"									(wt_handle)wt_size

	windows function	"GetSystemTime"(ref byte)int32
	windows function	"Beep"							(wt_dword, wt_dword)wt_bool
	windows function	"SetConsoleCP"								(wt_uint)wt_bool
end

importdll user32=
	windows function	"CreateWindowExA" as createwindowex		(wt_dword, wt_string, wt_string, wt_dword, wt_int,wt_int,wt_int,wt_int,
													 wt_handle, wt_handle, wt_handle, wt_ptr)wt_handle

	windows function	"GetMessageA" as getmessage				(wt_ptr, wt_handle, wt_uint, wt_uint)wt_bool
	windows function	"TranslateMessage"						(wt_ptr)wt_bool
	windows function	"DispatchMessageA" as dispatchmessage		(wt_ptr)wt_result
	windows function	"SetTimer"								(wt_handle,wt_intptr,wt_uint,wt_ptr)wt_intptr
	windows function	"KillTimer"								(wt_handle,wt_intptr)wt_bool
	windows function	"SystemParametersInfoA"					(wt_uint,wt_uint,wt_ptr,wt_uint)wt_bool
	windows function	"GetSystemMetrics"						(wt_int)wt_int
	windows function	"AppendMenuA" as appendmenu				(wt_handle,wt_uint,wt_intptr,wt_string)wt_bool
	windows function	"GetDC"									(wt_handle)wt_handle
	windows function	"ReleaseDC"								(wt_handle,wt_handle)wt_int

	windows function	"SendMessageA" as sendmessage				(wt_handle,wt_uint,wt_wparam,wt_lparam)wt_result
	windows function	"PostMessageA" as postmessage				(wt_handle,wt_uint,wt_wparam,wt_lparam)wt_bool
	windows function	"PeekMessageA" as peekmessage				(wt_ptr,wt_handle,wt_uint,wt_uint,wt_uint)wt_bool
	windows function	"BeginPaint"								(wt_handle,wt_ptr)wt_handle
	windows function	"EndPaint"								(wt_handle,wt_ptr)wt_bool
	windows proc	"PostQuitMessage"					(wt_int)
	windows function	"LoadIconA" as loadicon					(wt_handle,wt_string)wt_handle
	windows function	"LoadCursorA" as loadcursor				(wt_handle,wt_string)wt_handle
	windows function	"SetCursor"								(wt_handle)wt_handle
	windows function	"DrawMenuBar"								(wt_handle)wt_bool
	windows function	"GetSystemMenu"							(wt_handle,wt_bool)wt_handle
	windows function	"CreateMenu"								:wt_handle
	windows function	"CreatePopupMenu"							:wt_handle
	windows function	"DestroyMenu"								(wt_handle)wt_bool
	windows function	"CheckMenuItem"							(wt_handle,wt_uint,wt_uint)wt_dword
	windows function	"EnableMenuItem"							(wt_handle,wt_uint,wt_uint)wt_bool
	windows function	"GetSubMenu"								(wt_handle,wt_int)wt_handle
	windows function	"GetMenuItemID"							(wt_handle,wt_int)wt_uint
	windows function	"GetMenuItemCount"						(wt_handle)wt_int
	windows function	"InsertMenuA" as insertmenu				(wt_handle,wt_uint,wt_uint,wt_intptr,wt_string)wt_bool
	windows function	"ModifyMenuA" as modifymenu				(wt_handle,wt_uint,wt_uint,wt_intptr,wt_string)wt_bool
	windows function	"RemoveMenu"								(wt_handle,wt_uint,wt_uint)wt_bool
	windows function	"DeleteMenu"								(wt_handle,wt_uint,wt_uint)wt_bool

	windows function	"DestroyWindow"							(wt_handle)wt_bool
	windows function	"InvalidateRect"							(wt_handle,wt_ptr,wt_bool)wt_bool
	windows function	"ValidateRect"							(wt_handle,wt_ptr)wt_bool
	windows function	"ShowWindow"								(wt_handle,wt_int)wt_bool
	windows function	"GetClassLongA" as getclassint			(wt_handle,wt_int)wt_word
	windows function	"SetClassLongA" as setclasslong			(wt_handle,wt_int,wt_dword)wt_word
	windows function	"SetWindowTextA" as setwindowtext			(wt_handle,wt_string)wt_bool
	windows function	"GetWindowTextA" as getwindowtext			(wt_handle,wt_string,wt_int)wt_int
	windows function	"GetWindowTextLengthA" as getwindowtextlength	(wt_handle)wt_int
	windows function	"GetKeyState"								(wt_int)wt_word

	windows function	"GetWindowLongA" as getwindowlongptr		(wt_handle,wt_int)intm
	windows function	"SetWindowLongA" as setwindowlongptr		(wt_handle,wt_int,intm)intm

	windows function	"GetClientRect"							(wt_handle,wt_ptr)wt_bool
	windows function	"ClientToScreen"							(wt_handle,wt_ptr)wt_bool
	windows function	"ScreenToClient"							(wt_handle,wt_ptr)wt_bool
	windows function	"GetWindowRect"							(wt_handle,wt_ptr)wt_bool
	windows function	"GetSysColor" as getsyscolour				(wt_int)wt_dword
	windows function	"GetScrollInfo"							(wt_handle,wt_int,wt_ptr)wt_bool
	windows function	"GetMenu"									(wt_handle)wt_handle
	windows function	"SetMenu"									(wt_handle,wt_handle)wt_ptr
	windows function	"TrackPopupMenu"							(wt_handle,wt_uint,wt_int,wt_int,wt_int,wt_handle,wt_ptr)wt_bool
	windows function	"GetMenuState"							(wt_handle,wt_uint,wt_uint)wt_uint
	windows function	"MessageBoxA" \
								(wt_handle a=0,wt_string message, wt_string caption, wt_uint b=0)wt_int
	windows function	"OpenClipboard"							(wt_handle)wt_bool
	windows function	"CloseClipboard"							:wt_bool
	windows function	"EmptyClipboard"							:wt_bool
	windows function	"GetClipboardData"						(wt_uint)wt_handle
	windows function	"SetClipboardData"						(wt_uint,wt_handle)wt_handle
	windows function	"MessageBeep"							(wt_uint x=0)wt_bool
end

importdll gdi32=
	windows function	"Rectangle"								(wt_handle,wt_int,wt_int,wt_int,wt_int)wt_bool
	windows function	"RoundRect"								(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int)wt_bool
	windows function	"Ellipse"									(wt_handle,wt_int,wt_int,wt_int,wt_int)wt_bool
	windows function	"Arc"										(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int)wt_bool
	windows function	"Chord"									(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int)wt_bool
	windows function	"Pie"										(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int)wt_bool
	windows function	"Polygon"									(wt_handle,wt_handle,wt_int)wt_bool
	windows function	"TextOutA" as textout						(wt_handle,wt_int,wt_int,wt_string,wt_int)wt_bool
	windows function	"TextOutW" 						(wt_handle,wt_int,wt_int,wt_ptr,wt_int)wt_bool
	windows function	"GetStockObject"							(wt_int)wt_handle
	windows function	"SelectObject"							(wt_handle,wt_handle)wt_handle
	windows function	"CreateDCA" as createdc					(wt_string,wt_string,wt_string,wt_ptr)wt_handle
	windows function	"MoveToEx"						(wt_handle a,wt_int b,wt_int c,wt_ptr d=nil)wt_bool
	windows function	"CreatePen"								(wt_int,wt_int,wt_dword)wt_handle
	windows function	"CreateSolidBrush"						(wt_dword)wt_handle
	windows function	"CreateBrushIndirect"						(wt_ptr)wt_handle
	windows function	"LineTo"									(wt_handle,wt_int,wt_int)wt_bool
	windows function	"GetPixel"								(wt_handle,wt_int,wt_int)wt_dword
	windows function	"SetPixel"								(wt_handle,wt_int,wt_int,wt_dword)wt_dword
	windows function	"SetGraphicsMode"							(wt_handle,wt_int)wt_int
	windows function	"CreateFontIndirectA" as createfontindirect	(wt_ptr)wt_handle
	windows function	"CreateFontA" as createfont \
			(wt_int height, wt_int width=0, wt_int escapement=0, wt_int orientation=0, wt_int bold=0,
			 wt_dword italic=0, wt_dword underline=0, wt_dword strikeout=0, wt_dword charset=0,
			 wt_dword outprec=0, wt_dword clipprec=0, wt_dword quality=0, wt_dword pitch=0, wt_string facename)wt_handle
	windows function	"SaveDC"									(wt_handle)wt_int
	windows function	"GetTextMetricsA" as gettextmetrics		(wt_handle,wt_ptr)wt_bool
	windows function	"DeleteObject"							(wt_handle)wt_bool
	windows function	"RestoreDC"								(wt_handle,wt_int)wt_bool
	windows function	"GetTextExtentPoint32A" as gettextextentpoint32	(wt_handle,wt_ptr,wt_int,wt_ptr)wt_bool
	windows function	"GetObjectA" as getobject					(wt_handle,wt_int,wt_ptr)wt_int
	windows function	"CreatePalette"							(wt_ptr)wt_handle
	windows function	"GetWindowExtEx"							(wt_handle,wt_ptr)wt_bool
	windows function	"CreateCompatibleBitmap"					(wt_handle,wt_int,wt_int)wt_handle
	windows function	"SetBitmapBits"							(wt_handle,wt_dword,wt_ptr)wt_long
	windows function	"SelectPalette"							(wt_handle,wt_handle,wt_bool)wt_handle
	windows function	"RealizePalette"							(wt_handle)wt_uint
	windows function	"SetDIBitsToDevice"						(wt_handle,wt_int,wt_int,wt_dword,wt_dword,wt_int,wt_int,wt_uint,wt_uint,wt_ptr,wt_ptr,wt_uint)wt_int
	windows function	"StretchDIBits"							(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_ptr,wt_ptr,wt_uint,wt_dword)wt_int
	windows function	"SetStretchBltMode"						(wt_handle,wt_int)wt_int
	windows function	"PatBlt"									(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_dword)wt_bool
	windows function	"BitBlt"									(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_handle,wt_int,wt_int,wt_dword)wt_bool
	windows function	"SetROP2"									(wt_handle,wt_int)wt_int
	windows function	"CreateCompatibleDC"						(wt_handle)wt_handle
	windows function	"DeleteDC"								(wt_handle)wt_bool
	windows function	"CreateBitmap"							(wt_int,wt_int,wt_uint,wt_uint,wt_ptr)wt_handle
	windows function	"CreateBitmapIndirect"					(wt_ptr)wt_handle
	windows function	"CreateDIBitmap"							(wt_handle,wt_ptr,wt_dword,wt_ptr,wt_ptr,wt_uint)wt_handle
	windows function	"CreateDIBSection"						(wt_handle,wt_ptr,wt_uint,wt_ptr,wt_handle,wt_dword)wt_handle
	windows function	"StretchBlt"								(wt_handle,wt_int,wt_int, wt_int,wt_int,wt_handle, wt_int,wt_int,wt_int, wt_int,wt_dword)wt_bool
	windows function	"PlgBlt"								(wt_handle,wt_ptr,wt_handle, wt_int,wt_int,wt_int,wt_int, wt_handle, wt_int,wt_int)wt_bool
	windows function	"SetTextColor"  as settextcolour			(wt_handle,wt_dword)wt_dword
	windows function	"SetTextAlign"							(wt_handle,wt_uint)wt_uint
	windows function	"SetTextJustification"					(wt_handle,wt_int,wt_int)wt_bool
	windows function	"SetBkColor"  as setbkcolour				(wt_handle,wt_dword)wt_dword
	windows function	"SetBkMode"								(wt_handle,wt_int)wt_int
	windows function	"GetBkColor"  as getbkcolour				(wt_handle)wt_dword
	windows function	"GetBkMode"								(wt_handle)wt_int
	windows function	"StartDocA" as startdoc					(wt_handle,wt_ptr)wt_int
	windows function	"StartPage"								(wt_handle)wt_int
	windows function	"EndPage"									(wt_handle)wt_int
	windows function	"EndDoc"									(wt_handle)wt_int
	windows function	"AbortDoc"								(wt_handle)wt_int
	windows function	"GetViewportOrgEx"						(wt_handle,wt_ptr)wt_bool
	windows function	"GetDIBits"								(wt_handle,wt_handle,wt_uint,wt_uint,wt_ptr,wt_ptr,wt_uint)wt_int
	windows function	"GetDIBColorTable" as getdibcolourtable	(wt_handle,wt_uint,wt_uint,wt_ptr)wt_uint
	windows function	"SetDIBColorTable" as setdibcolourtable	(wt_handle,wt_uint,wt_uint,wt_ptr)wt_uint
	windows function	"GetTextAlign"							(wt_handle)wt_uint
end

importdll comdlg32=
	windows function	"GetOpenFileNameA"						(wt_ptr)wt_bool
	windows function	"GetSaveFileNameA"						(wt_ptr)wt_bool
end

proc start=
end

proc main=
end
=== winconsts.q 51/56 ===

global const driverversion =  0
global const technology =  2
global const horzsize =  4
global const vertsize =  6
global const horzres =  8
global const vertres =  10
global const bitspixel =  12
global const bitplanes =  14
global const numbrushes =  16
global const numpens =  18
global const nummarkers =  20
global const numfonts =  22
global const numcolours =  24
global const pdevicesize =  26
global const curvecaps =  28
global const linecaps =  30
global const polygonalcaps =  32
global const textcaps =  34
global const clipcaps =  36
global const rastercaps =  38
global const aspectx =  40
global const aspecty =  42
global const aspectxy =  44
global const logpixelsx =  88
global const logpixelsy =  90
global const sizepalette =  104
global const numreserved =  106
global const colourres =  108
global const physicalwidth =  110
global const physicalheight =  111
global const physicaloffsetx =  112
global const physicaloffsety =  113
global const scalingfactorx =  114
global const scalingfactory =  115
global const fw_dontcare =  0
global const fw_thin =  100
global const fw_extralight =  200
global const fw_ultralight =  200
global const fw_light =  300
global const fw_normal =  400
global const fw_regular =  400
global const fw_medium =  500
global const fw_semibold =  600
global const fw_demibold =  600
global const fw_bold =  700
global const fw_extrabold =  800
global const fw_ultrabold =  800
global const fw_heavy =  900
global const fw_black =  900
global const cs_vredraw =  1
global const cs_hredraw =  2
global const cs_keycvtwindow =  4
global const cs_dblclks =  8
global const cs_owndc =  32
global const cs_classdc =  64
global const cs_parentdc =  128
global const cs_nokeycvt =  256
global const cs_noclose =  512
global const cs_savebits =  2048
global const cs_bytealignclient =  4096
global const cs_bytealignwindow =  8192
global const cs_publicclass =  16384
global const sw_hide =  0
global const sw_shownormal =  1
global const sw_normal =  1
global const sw_showminimized =  2
global const sw_showmaximized =  3
global const sw_maximize =  3
global const sw_shownoactivate =  4
global const sw_show =  5
global const sw_minimize =  6
global const sw_showminnoactive =  7
global const sw_showna =  8
global const sw_restore =  9
global const sw_showdefault =  10
global const sw_max =  10
global const pm_noremove =  0
global const pm_remove =  1
global const pm_noyield =  2
global const wm_null =  0
global const wm_create =  1
global const wm_destroy =  2
global const wm_move =  3
global const wm_size =  5
global const wm_activate =  6
global const wa_inactive =  0
global const wa_active =  1
global const wa_clickactive =  2
global const wm_setfocus =  7
global const wm_killfocus =  8
global const wm_enable =  10
global const wm_setredraw =  11
global const wm_settext =  12
global const wm_gettext =  13
global const wm_gettextlength =  14
global const wm_paint =  15
global const wm_close =  16
global const wm_queryendsession =  17
global const wm_quit =  18
global const wm_queryopen =  19
global const wm_erasebkgnd =  20
global const wm_syscolourchange =  21
global const wm_endsession =  22
global const wm_showwindow =  24
global const wm_wininichange =  26
global const wm_devmodechange =  27
global const wm_activateapp =  28
global const wm_fontchange =  29
global const wm_timechange =  30
global const wm_cancelmode =  31
global const wm_setcursor =  32
global const wm_mouseactivate =  33
global const wm_childactivate =  34
global const wm_queuesync =  35
global const wm_getminmaxinfo =  36
global const wm_drawitem =  43
global const wm_notify =  78
global const wm_contextmenu =  123
global const wm_geticon =  127
global const wm_seticon =  128
global const wm_nchittest =  132

global const wm_nclbuttondown	= 161
global const wm_nclbuttonup	= 162
global const wm_nclbuttondblclick	= 163

global const wm_menurbuttonup	= 290

global const wm_parentnotify =  528
global const wm_dropfiles =  563
global const wm_enteridle =  289
global const wm_user =  1024
global const wm_mdicreate =  544
global const wm_mdidestroy =  545
global const wm_mdiactivate =  546
global const wm_mdirestore =  547
global const wm_mdinext =  548
global const wm_mdimaximize =  549
global const wm_mditile =  550
global const wm_mdicascade =  551
global const wm_mdiiconarange =  552
global const wm_mdigetactive =  553
global const wm_mdisetmenu =  560
global const wm_entersizemove =  561
global const wm_exitsizemove =  562
global const wm_mdirefrshmenu =  564
global const wm_lbuttondblclk =  515
global const wm_rbuttondblclk =  518
global const wm_lbuttondown =  513
global const wm_rbuttondown =  516
global const wm_mbuttondown =  519
global const wm_mousemove =  512
global const wm_lbuttonup =  514
global const wm_rbuttonup =  517
global const wm_mbuttonup =  520
global const wm_mbuttondblclk =  521
global const wm_mousewheel =  522
global const snd_filename =  131072
global const snd_async =  1
global const dt_singleline =  32
global const dt_centre =  1
global const dt_vcentre =  4
global const ws_overlapped =  0
global const ws_popup =  2147483648
global const ws_child =  1073741824
global const ws_minimize =  536870912
global const ws_visible =  268435456
global const ws_disabled =  134217728
global const ws_clipsiblings =  67108864
global const ws_clipchildren =  33554432
global const ws_maximize =  16777216
global const ws_caption =  12582912
global const ws_border =  8388608
global const ws_dlgframe =  4194304
global const ws_hscroll =  1048576
global const ws_vscroll =  2097152
global const ws_sysmenu =  524288
global const ws_thickframe =  262144
global const ws_group =  131072
global const ws_tabstop =  0
global const ws_scrollbars =  3145728
global const ws_minimizebox =  131072
global const ws_maximizebox =  65536
global const ws_tiled =  0
global const ws_iconic =  536870912
global const ws_sizebox =  262144
global const ws_overlappedwindow =  13565952
global const ws_tiledwindow =  13565952
global const ws_popupwindow =  -2138570752
global const ws_childwindow =  1073741824
global const ws_ex_acceptfiles =  16
global const ws_ex_appwindow =  262144
global const ws_ex_clientedge =  512
global const ws_ex_contexthelp =  1024
global const ws_ex_controlparent =  65536
global const ws_ex_dlgmodalframe =  1
global const ws_ex_left =  0
global const ws_ex_leftscrollbar =  16384
global const ws_ex_ltrreading =  0
global const ws_ex_mdichild =  64
global const ws_ex_noparentnotify =  4
global const ws_ex_overlappedwindow =  768
global const ws_ex_palettewindow =  392
global const ws_ex_right =  4096
global const ws_ex_rightscrollbar =  0
global const ws_ex_rtlreading =  8192
global const ws_ex_staticedge =  131072
global const ws_ex_toolwindow =  128
global const ws_ex_topmost =  8
global const ws_ex_transparent =  32
global const ws_ex_windowedge =  256

global const gw_hwndfirst =  0
global const gw_hwndlast =  1
global const gw_hwndnext =  2
global const gw_hwndprev =  3
global const gw_owner =  4
global const gw_child =  5
global const gw_enabledpopup =  6
global const cb_geteditsel =  320
global const cb_limittext =  321
global const cb_seteditsel =  322
global const cb_addstring =  323
global const cb_deletestring =  324
global const cb_dir =  325
global const cb_getcount =  326
global const cb_getcursel =  327
global const cb_getlbtext =  328
global const cb_getlbtextlen =  329
global const cb_insertstring =  330
global const cb_resetcontent =  331
global const cb_findstring =  332
global const cb_findstringexact =  344
global const cb_selectstring =  333
global const cb_setcursel =  334
global const cb_showdropdown =  335
global const cb_getitemdata =  336
global const cb_setitemdata =  337
global const cb_getdroppedcontrolrect =  338
global const cb_setitemheight =  339
global const cb_getitemheight =  340
global const cb_setextendedui =  341
global const cb_getextendedui =  342
global const cb_getdroppedstate =  343
global const cb_setlocale =  345
global const cb_getlocale =  346
global const cb_gettopindex =  347
global const cb_settopindex =  348
global const cb_gethorizontalextent =  349
global const cb_sethorizontalextent =  350
global const cb_getdroppedwidth =  351
global const cb_setdroppedwidth =  352
global const cb_initstorage =  353
global const cb_multipleaddstring =  355
global const bm_click =  245
global const bm_getcheck =  240
global const bm_getimage =  246
global const bm_getstate =  242
global const bm_setcheck =  241
global const bm_setimage =  247
global const bm_setstate =  243
global const bm_setstyle =  244
global const cf_bitmap =  2
global const cf_dib =  8
global const cf_palette =  9
global const cf_enhmetafile =  14
global const cf_metafilepict =  3
global const cf_oemtext =  7
global const cf_text =  1			!used in sys
global const cf_unicodetext =  13
global const cf_dif =  5
global const cf_dspbitmap =  130
global const cf_dspenhmetafile =  142
global const cf_dspmetafilepict =  131
global const cf_dsptext =  129
global const cf_gdiobjfirst =  768
global const cf_gdiobjlast =  1023
global const cf_hdrop =  15
global const cf_locale =  16
global const cf_ownerdisplay =  128
global const cf_pendata =  10
global const cf_privatefirst =  512
global const cf_privatelast =  767
global const cf_riff =  11
global const cf_sylk =  4
global const cf_wave =  12
global const cf_tiff =  6

global const tcif_text =  1
global const tcif_image =  2
global const tcif_param =  8
global const tcif_rtlreading =  4

global const wm_keydown =  256
global const wm_keyup =  257
global const wm_char =  258
global const wm_syschar =  262
global const wm_sysdeadchar =  263
global const wm_syskeydown =  260
global const wm_syskeyup =  261
global const mf_insert =  0
global const mf_change =  128
global const mf_append =  256
global const mf_delete =  512
global const mf_remove =  4096
global const mf_bycommand =  0
global const mf_byposition =  1024
global const mf_separator =  2048
global const mf_enabled =  0
global const mf_grayed =  1
global const mf_greyed =  1
global const mf_disabled =  2
global const mf_unchecked =  0
global const mf_checked =  8
global const mf_usecheckbitmaps =  512
global const mf_string =  0
global const mf_bitmap =  4
global const mf_ownerdraw =  256
global const mf_popup =  16
global const mf_menubarbreak =  32
global const mf_menubreak =  64
global const mf_unhilite =  0
global const mf_hilite =  128
global const mf_sysmenu =  8192
global const mf_help =  16384
global const mf_mouseselect =  32768


global const wm_command =  273
global const wm_menuselect =  287
global const wm_cut =  768
global const wm_copy =  769
global const wm_paste =  770
global const wm_clear =  771
global const wm_undo =  772
global const em_getsel =  176
global const em_setsel =  177
global const em_scroll =  181
global const em_linescroll =  182
global const em_scrollcaret =  183
global const em_getmodify =  184
global const em_setmodify =  185
global const em_getlinecount =  186
global const em_lineindex =  187
global const em_sethandle =  188
global const em_gethandle =  189
global const em_getthumb =  190
global const em_linelength =  193
global const em_replacesel =  194
global const em_getline =  196
global const em_limittext =  197
global const em_canundo =  198
global const em_undo =  199
global const em_fmtlines =  200
global const em_linefromchar =  201
global const em_settabstops =  203
global const em_setpasswordchar =  204
global const em_emptyundobuffer =  205
global const em_getfirstvisibleline =  206
global const em_setreadonly =  207
global const em_setwordbreakproc =  208
global const em_getwordbreakproc =  209
global const em_getpasswordchar =  210
global const em_setlimittext =  197
global const em_getseltext =  1086
global const em_setcharformat =  1092
global const em_getcharformat =  1082
global const em_settextmode =  1113
global const em_gettextmode =  1114
global const em_gettextex =  1118
global const em_gettextlengthex =  1119
global const tm_plaintext =  1
global const tm_richtext =  2
global const tm_singlelevelundo =  4
global const tm_multilevelundo =  8
global const tm_singlecodepage =  16
global const tm_multicodepage =  32
global const scf_word =  2
global const scf_selection =  1
global const sb_getborders =  1031
global const sb_getparts =  1030
global const sb_getrect =  1034
global const sb_gettextw =  1037
global const sb_gettextlengthw =  1036
global const sb_settextw =  1035
global const sb_gettexta =  1026
global const sb_gettextlengtha =  1027
global const sb_settexta =  1025
global const sb_gettext =  1026
global const sb_gettextlength =  1027
global const sb_settext =  1025
global const sb_setminheight =  1032
global const sb_setparts =  1028
global const sb_simple =  1033
global const wm_setfont =  48
global const wm_getfont =  49
global const gm_advanced =  2
global const transparent =  1
global const opaque =  2
global const mwt_identity =  1
global const cw_usedefault =  0x8000'0000
global const idc_arrow =  32512
global const idc_ibeam =  32513
global const idc_wait =  32514
global const idc_cross =  32515
global const idc_uparrow =  32516
global const idc_sizenwse =  32642
global const idc_sizenesw =  32643
global const idc_sizewe =  32644
global const idc_sizens =  32645
global const idc_sizeall =  32646
global const idc_no =  32648
global const idc_appstarting =  32650
global const idc_help =  32651
global const idi_application =  32512
global const idi_hand =  32513
global const idi_question =  32514
global const idi_exclamation =  32515
global const idi_asterisk =  32516
global const idi_winlogo =  32517
global const idc_size =  32640
global const idc_icon =  32641
global const arrowpointer =  32512
global const ibeampointer =  32513
global const waitpointer =  32514
global const crosspointer =  32515
global const uparrowpointer =  32516
global const sizenwsepointer =  32642
global const sizeneswpointer =  32643
global const sizewepointer =  32644
global const sizenspointer =  32645
global const sizeallpointer =  32646
global const nopointer =  32648
global const appstartingpointer =  32650
global const helpicon =  32651
global const applicationicon =  32512
global const handicon =  32513
global const questionicon =  32514
global const exclamationicon =  32515
global const asteriskicon =  32516
global const winlogoicon =  32517
global const sizepointer =  32640
global const iconicon =  32641
global const sm_cymin =  29
global const sm_cxmin =  28
global const sm_arrange =  56
global const sm_cleanboot =  67
global const sm_cmetrics =  76
global const sm_cmousebuttons =  43
global const sm_cxborder =  5
global const sm_cyborder =  6
global const sm_cxcursor =  13
global const sm_cycursor =  14
global const sm_cxdlgframe =  7
global const sm_cydlgframe =  8
global const sm_cxdoubleclk =  36
global const sm_cydoubleclk =  37
global const sm_cxdrag =  68
global const sm_cydrag =  69
global const sm_cxedge =  45
global const sm_cyedge =  46
global const sm_cxfixedframe =  7
global const sm_cyfixedframe =  8
global const sm_cxframe =  32
global const sm_cyframe =  33
global const sm_cxfullscreen =  16
global const sm_cyfullscreen =  17
global const sm_cxhscroll =  21
global const sm_cyhscroll =  3
global const sm_cxhthumb =  10
global const sm_cxicon =  11
global const sm_cyicon =  12
global const sm_cxiconspacing =  38
global const sm_cyiconspacing =  39
global const sm_cxmaximized =  61
global const sm_cymaximized =  62
global const sm_cxmaxtrack =  59
global const sm_cymaxtrack =  60
global const sm_cxmenucheck =  71
global const sm_cymenucheck =  72
global const sm_cxmenusize =  54
global const sm_cymenusize =  55
global const sm_cxminimized =  57
global const sm_cyminimized =  58
global const sm_cxminspacing =  47
global const sm_cyminspacing =  48
global const sm_cxmintrack =  34
global const sm_cymintrack =  35
global const sm_cxscreen =  0
global const sm_cyscreen =  1
global const sm_cxsize =  30
global const sm_cysize =  31
global const sm_cxsizeframe =  32
global const sm_cysizeframe =  33
global const sm_cxsmicon =  49
global const sm_cysmicon =  50
global const sm_cxsmsize =  52
global const sm_cysmsize =  53
global const sm_cxvscroll =  2
global const sm_cyvscroll =  20
global const sm_cyvthumb =  9
global const sm_cycaption =  4
global const sm_cykanjiwindow =  18
global const sm_cymenu =  15
global const sm_cysmcaption =  51
global const sm_dbcsenabled =  42
global const sm_debug =  22
global const sm_menudropalignment =  40
global const sm_mideastenabled =  74
global const sm_mousepresent =  19
global const sm_mousewheelpresent =  75
global const sm_network =  63
global const sm_penwindows =  41
global const sm_reserved1 =  24
global const sm_reserved2 =  25
global const sm_reserved3 =  26
global const sm_reserved4 =  27
global const sm_secure =  44
global const sm_showsounds =  70
global const sm_slowmachine =  73
global const sm_swapbutton =  23
global const arw_bottomleft =  0
global const arw_bottomright =  1
global const arw_hide =  8
global const arw_topleft =  2
global const arw_topright =  3
global const arw_down =  4
global const arw_left =  0
global const arw_right =  0
global const arw_up =  4
global const white_brush =  0
global const ltgray_brush =  1
global const gray_brush =  2
global const dkgray_brush =  3
global const black_brush =  4
global const null_brush =  5
global const hollow_brush =  5
global const white_pen =  6
global const black_pen =  7
global const null_pen =  8
global const oem_fixed_font =  10
global const ansi_fixed_font =  11
global const ansi_var_font =  12
global const system_font =  13
global const device_default_font =  14
global const default_palette =  15
global const system_fixed_font =  16
global const stock_last =  16


global const wm_hscroll =  276
global const wm_vscroll =  277


global const wm_ctlcolourmsgbox =  306
global const wm_ctlcolouredit =  307
global const wm_ctlcolourlistbox =  308
global const wm_ctlcolourbtn =  309
global const wm_ctlcolourdlg =  310
global const wm_ctlcolourscrollbar =  311
global const wm_ctlcolourstatic =  312
global const wm_timer =  275

global const srccopy =  13369376
global const srcpaint =  15597702
global const srcand =  8913094
global const srcinvert =  6684742
global const srcerase =  4457256

global const notsrccopy =  3342344
global const notsrcerase =  1114278
global const mergecopy =  12583114
global const mergepaint =  12255782
global const patcopy =  15728673
global const patpaint =  16452105
global const patinvert =  5898313
global const dstinvert =  5570569
global const blackness =  66
global const whiteness =  16711778

global const r2_black =  1
global const r2_notmergepen =  2
global const r2_masknotpen =  3
global const r2_notcopypen =  4
global const r2_maskpennot =  5
global const r2_not =  6
global const r2_xorpen =  7
global const r2_notmaskpen =  8
global const r2_maskpen =  9
global const r2_notxorpen =  10
global const r2_nop =  11
global const r2_mergenotpen =  12
global const r2_copypen =  13
global const r2_mergepennot =  14
global const r2_mergepen =  15
global const r2_white =  16
global const r2_last =  16

global const gdi_error =  4294967295
global const hgdi_error =  4294967295
global const clr_invalid =  4278190080
global const clr_default =  4278190080
global const clr_none =  4294967295
global const ofn_readonly =  1
global const ofn_overwriteprompt =  2
global const ofn_hidereadonly =  4
global const ofn_nochangedir =  8
global const ofn_showhelp =  16
global const ofn_enablehook =  32
global const ofn_enabletemplate =  64
global const ofn_enabletemplatehandle =  128
global const ofn_novalidate =  256
global const ofn_allowmultiselect =  512
global const ofn_extensiondifferent =  1024
global const ofn_pathmustexist =  2048
global const ofn_filemustexist =  4096
global const ofn_createprompt =  8192
global const ofn_shareaware =  16384
global const ofn_noreadonlyreturn =  32768
global const ofn_notestfilecreate =  65536
global const ofn_nonetworkbutton =  131072
global const ofn_nolongnames =  262144
global const ofn_explorer =  524288
global const ofn_nodereferencelinks =  1048576
global const ofn_longnames =  2097152
global const ofn_sharefallthrough =  2
global const ofn_sharenowarn =  1
global const ofn_sharewarn =  0
global const dib_rgb_colours =  0
global const dib_pal_colours =  1
global const dib_pal_indices =  2
global const dib_pal_physindices =  2
global const dib_pal_logindices =  4
global const stm_seticon =  368
global const stm_setimage =  370
global const lr_loadfromfile =  16
global const image_bitmap =  0
global const image_icon =  1
global const lr_copydeleteorg =  8
global const lr_copyreturnorg =  4
global const lr_monochrome =  1
global const lr_createdibsection =  8192
global const lr_defaultsize =  64
global const ss_icon =  3
global const ss_bitmap =  14
global const gcl_menuname =  -8
global const gcl_hbrbackground =  -10
global const gcl_hcursor =  -12
global const gcl_hicon =  -14
global const gcl_hmodule =  -16
global const gcl_cbwndextra =  -18
global const gcl_cbclsextra =  -20
global const gcl_wndproc =  -24
global const gcl_style =  -26
global const gcw_atom =  -32
global const colour_scrollbar =  0
global const colour_background =  1
global const colour_desktop =  1
global const colour_activecaption =  2
global const colour_inactivecaption =  3
global const colour_menu =  4
global const colour_window =  5
global const colour_windowframe =  6
global const colour_menutext =  7
global const colour_windowtext =  8
global const colour_captiontext =  9
global const colour_activeborder =  10
global const colour_inactiveborder =  11
global const colour_appworkspace =  12
global const colour_highlight =  13
global const colour_highlighttext =  14
global const colour_btnface =  15
global const colour_3dface =  15
global const colour_btnshadow =  16
global const colour_3dshadow =  16
global const colour_graytext =  17
global const colour_btntext =  18
global const colour_inactivecaptiontext =  19
global const colour_btnhighlight =  20
global const colour_3dhilight =  20
global const colour_3ddkshadow =  21
global const colour_3dlight =  22
global const colour_infotext =  23
global const colour_infobk =  24
global const colour_tooltipbk =  24
global const mk_lbutton =  1
global const mk_rbutton =  2
global const mk_shift =  4
global const mk_control =  8
global const mk_mbutton =  16
global const cbm_createdib =  2
global const cbm_init =  4
global const cc_enablehook =  16
global const cc_enabletemplate =  32
global const cc_enabletemplatehandle =  64
global const cc_fullopen =  2
global const cc_preventfullopen =  4
global const cc_rgbinit =  1
global const cc_showhelp =  8
global const cc_solidcolour =  128
global const cf_screenfonts =  1
global const cf_printerfonts =  2
global const cf_effects =  256
global const size_restored =  0
global const size_minimized =  1
global const size_maximized =  2
global const size_maxshow =  3
global const size_maxhide =  4
global const gwl_userdata =  -21
global const gwl_id =  -12
global const ta_top =  0
global const ta_left =  0
global const ta_noupdatecp =  0
global const ta_updatecp =  1
global const ta_right =  2
global const ta_centre =  6
global const vta_centre =  6
global const ta_bottom =  8
global const ta_baseline =  24
global const vta_baseline =  24
global const ta_rtlreading =  256
global const aligntop =  0
global const alignbottom =  8
global const alignbaseline =  24
global const aligncentre =  6
global const alignleft =  0
global const alignright =  2

global const em_exgetsel =  1076
global const em_exlimittext =  1077
global const em_exlinefromchar =  1078
global const em_exsetsel =  1079
global const em_getparaformat =  1085
global const em_setparaformat =  1095
global const em_streamin =  1097
global const em_streamout =  1098
global const em_gettextrange =  1099
global const em_findtext =  1080
global const em_findtextex =  1103


global const hwnd_top =  0
global const hwnd_bottom =  1
global const hwnd_topmost =  -1
global const hwnd_notopmost =  -2

global const normalwind =  0
global const modalwind =  -1
global const dialogwind =  -2
global const minimize =  2
global const maximize =  3
global const shiftmask =  1
global const controlmask =  2
global const altmask =  4
global const windowcolour =  15
global const ps_geometric =  65536
global const ps_cosmetic =  0
global const ps_alternate =  8
global const ps_solid =  0
global const ps_dash =  1
global const ps_dot =  2
global const ps_dashdot =  3
global const ps_dashdotdot =  4
global const ps_null =  5
global const ps_insideframe =  6
global const ps_userstyle =  7
global const ps_endcap_round =  0
global const ps_endcap_square =  256
global const ps_endcap_flat =  512
global const ps_join_bevel =  4096
global const ps_join_miter =  8192
global const ps_join_round =  0
global const ps_style_mask =  15
global const ps_endcap_mask =  3840
global const ps_type_mask =  983040
global const bs_solid =  0
global const bs_hollow =  1
global const bs_null =  1
global const bs_hatched =  2
global const bs_pattern =  3
global const bs_dibpattern =  5
global const bs_dibpatternpt =  6
global const bs_pattern8x8 =  7
global const bs_dibpattern8x8 =  8
global const hs_horizontal =  0
global const hs_vertical =  1
global const hs_fdiagonal =  2
global const hs_bdiagonal =  3
global const hs_cross =  4
global const hs_diagcross =  5


global const spi_getworkarea =  48

proc start=
end

=== wingxlib.q 52/56 ===
import sys

import winmessages
import winconsts
import gxmisc
import winapi


global var hwapplic=nil
global var hwchild=nil
global var iswin32
global var screendc

global var nglobalfonts=0
global var fonttable=()			![]font handles
global var fontdimtable=()		![]rpoint (width,total line height)
global var fontvdimtable=()		![]rpoint (ascenders, descenders) 

proc start	=		!START

initdata()
end

proc main=			!MAIN
start()
end

proc initdata=						!INITDATA
iswin32:=(getos()="W32")
screendc:=getdc(0)

fonttable:=(0,)*20
fontdimtable:=(0,)*20
fontvdimtable:=(0,)*20

fonttable[1]:=getstockobject(17)	!default gui
fonttable[2]:=getstockobject(13)	!system font
fonttable[3]:=getstockobject(16)	!system fixed
fonttable[4]:=getstockobject(10)	!oem fixed
for i:=1 to 4 do
 fontdimtable[i]:=ws_point(0,0)
 fontvdimtable[i]:=ws_point(0,0)
od
nglobalfonts:=4


end

function checkoption(optionnames,optionvalues,name,default=-1)=		!CHECKOPTION

n:=name in optionnames
if not n then return default fi
return optionvalues[n]
end

global proc wx_waitmess=				!WAITMESS
windmsg:=new((iswin32|ws_msg32|ws_msg64))

do
	if getmessage(&windmsg,0,0,0)<>0 then
		w:=windmsg.hwnd
CPL "WM2 GOT MESSAGE",windmsg.message,WINMESSAGENAMES{WINDMSG.MESSAGE}
		if windmsg.message=wm_keydown and windmsg.wparam=27 then exit fi
		if windmsg.message=wm_timer then CPL "TIMER!!" fi
		translatemessage(&windmsg)
	!	if not processmessage(windmsg) then
		dispatchmessage(&windmsg)
	!	fi
		if windmsg.message=wm_close then exit fi
	else
		CPL "EXITING WAITMESS"
		exit
	fi
od
end

global function wx_getw(hwnd)=

n:=getwindowlongptr(hwnd, gwl_userdata)
return n
end

global proc wx_setw(hwnd,index)=
setwindowlongptr(hwnd, gwl_userdata, index)
end

global function wx_gettextwidth(hdc,s)=
size:=new(ws_point)
gettextextentpoint32(hdc,s,s.len,&size)
return size.x
end

global function wx_createpopup(?caption,?pos,?dim,?options,owner=nil)=	!CREATEPOPUP
const gap=40
const smallestwidth=150

if options.isvoid then
 options:=[wf_caption:1,wf_border:wbs_resize]
fi

posx:=posy:=-1
dimx:=640
dimy:=480
fcentre:=0
fautopos:=0
fmax:=fdesktop:=0

if caption.isvoid then caption:="<No Caption>" fi

if dim.defined then
	if dim.isstring and dim="max" then
		fmax:=1
	elsif dim.isstring and dim="desktop" then
		fdesktop:=1
	else
		dimx:=dim[1]
		dimy:=dim[2]
	fi
fi

if pos.isvoid or pos="cent" then
	fcentre:=1
elsif pos="auto" then
	fautopos:=1
elsif pos.defined and not pos.isstring then
	posx:=pos[1]
	posy:=pos[2]
else				!check options?
	abort("gxcw bad pos")
fi

bstyle:=bxstyle:=0
nocap:=0			!whether to suppress caption

framex:=framey:=0


case options{wf_border,wbs_resize}
when wbs_none then		!no border
	nocap:=1
	framex:=0
	framey:=0
when wbs_simple then		!single line
	nocap:=1
	bstyle:=ws_border
	framex:=1
	framey:=1
when wbs_thick then		!thick line
	bstyle:=ws_dlgframe
	fixedframe:=0
	framex:=getsystemmetrics(sm_cxfixedframe)
	framey:=getsystemmetrics(sm_cyfixedframe)
when wbs_resize then
	bstyle:=ws_sizebox
	framex:=getsystemmetrics(sm_cxsizeframe)
	framey:=getsystemmetrics(sm_cysizeframe)
when wbs_sunken,wbs_sunken2 then		!sunken
	bstyle:=ws_dlgframe
	bxstyle:=ws_ex_clientedge
	framex:=5
	framey:=5
when wbs_sunkenrs then
	bstyle:=ws_sizebox
	bxstyle:=ws_ex_clientedge
	framex:=6
	framey:=6
esac

capheight:=getsystemmetrics(sm_cycaption)
mbheight:=getsystemmetrics(sm_cymenu)

style:=0
exstyle:=0

if options{wf_show,1} then
	style ior:=ws_visible
fi

mxleft:=framex
mxright:=framey
mytop:=framey+capheight
mybottom:=framey
showstyle:=sw_shownormal

hcwmenu:=0
if options{wf_menu,0}=1 then
	mytop+:=mbheight
	hcwmenu:=createmenu()
	appendmenu(hcwmenu,0,998,"fred")
fi

style ior:=ws_clipchildren


if nocap or options{wf_caption,1}=0 then
	mytop-:=capheight
	style ior:=ws_popup
fi


if options{wf_iframe,0}=0 then
	if not fautopos then
		posx-:=mxleft
		posy-:=mytop
	fi
	dimx+:=mxleft+mxright
	dimy+:=mytop+mybottom
fi

if fcentre or options{wf_cent,0}=1 then
	fautopos:=0
	box:=new(ws_rect)
	systemparametersinfoa(spi_getworkarea,0,&box,0)
	posx:=box.rightx%2-dimx%2
	posy:=(box.bottom-box.top)%2-dimy%2+box.top
fi

if fmax or options{wf_max,0} then
	showstyle:=sw_maximize
	style ior:=ws_maximize
fi


if options{wf_minmax,1}=1 then
	style ior:=(ws_maximizebox ior ws_minimizebox)

fi

if options{wf_sysmenu,1}=1 then
	style ior:=ws_sysmenu
fi

if fautopos=0 and options{wf_clip,0}=1 then
	box:=new(ws_rect)
	systemparametersinfoa(spi_getworkarea,0,&box,0)

	if posx<box.leftx+gap then posx:=box.leftx+gap fi

	if posy<box.top+gap then posy:=box.top+gap fi
	dimxmin:=dimx max smallestwidth
	if posx+dimxmin>=box.rightx+gap then posx:=box.rightx-gap-dimxmin fi
	if posy+dimy>=box.bottom+gap then posy:=box.bottom-gap-dimy fi
elsif fautopos then
	posx:=posy:=cw_usedefault
fi

if fdesktop or options{wf_desktop,0}=1 then
	box:=new(ws_rect)
	systemparametersinfoa(spi_getworkarea,0,&box,0)
	posx:=box.leftx
	posy:=box.top
	dimx:=box.rightx-box.leftx
	dimy:=box.bottom-box.top
fi

if options{wf_toolwind,0}=1 then
	exstyle ior:=ws_ex_toolwindow
fi

classname:="pcc001"

STYLE IOR:=WS_VISIBLE

style ior:=bstyle
exstyle ior:=bxstyle

hwnd:=createwindowex(
	exstyle,
	classname,
	caption,
	style,
	posx,posy,			!initial position and size
	dimx,dimy,
	owner,			!will be 0 for 1st window, other popups use hwapplic as owner
	hcwmenu,			!menu handle
	0,	!proginstance,		!instance handle
	nil)			!creation params

if hwnd=0 then
	e:=getlasterror()
	abort("wx:Can't create popup window "+tostr(e))
fi
return hwnd
end

global function wx_createcontrol(?pos,?dim,border=wbs_simple,owner)=	!CREATECONTROL
const gap=40
const smallestwidth=150

posx:=posy:=0
dimx:=160
dimy:=120

if dim.defined then
	dimx:=dim[1]
	dimy:=dim[2]
fi

if pos.defined then
	posx:=pos[1]
	posy:=pos[2]
fi

bstyle:=bxstyle:=0

case border
when wbs_none then		!no border
when wbs_simple then		!single line
	bstyle:=ws_border
else
	pcerror("createcontrol/bad border "+wbsnames[border])
esac

style:=0
exstyle:=0




style ior:=ws_clipchildren

classname:="pcc001"

style ior:=ws_child
style ior:=ws_visible

style ior:=bstyle
exstyle ior:=bxstyle

hwnd:=createwindowex(
	exstyle,
	classname,
	0,
	style,
	posx,posy,			!initial position and size
	dimx,dimy,
	owner,			!will be 0 for 1st window, other popups use hwapplic as owner
	0,				!menu handle
	0,	!proginstance,		!instance handle
	nil)			!creation params

if hwnd=0 then
	e:=getlasterror()
	abort("wx:Can't create child window "+tostr(e))
fi

return hwnd
end

=== winmessages.q 53/56 ===
global var winmessagenames=[
	(0:"wm_null"),
	(1:"wm_create"),
	(2:"wm_destroy"),
	(3:"wm_move"),
	(4:"pgk_menu"),
	(5:"wm_size"),
	(6:"wm_activate"),
	(7:"wm_setfocus"),
	(8:"wm_killfocus"),
	(9:"cbn_selendok"),
	(10:"wm_enable"),
	(11:"wm_setredraw"),
	(12:"wm_settext"),
	(13:"wm_gettext"),
	(14:"wm_gettextlength"),
	(15:"wm_paint"),
	(16:"wm_close"),
	(17:"wm_queryendsession"),
	(18:"wm_quit"),
	(19:"wm_queryopen"),
	(20:"wm_erasebkgnd"),
	(21:"wm_syscolorchange"),
	(22:"wm_endsession"),
	(24:"wm_showwindow"),
	(26:"wm_wininichange"),
	(27:"wm_devmodechange"),
	(28:"wm_activateapp"),
	(29:"wm_fontchange"),
	(30:"wm_timechange"),
	(31:"wm_cancelmode"),
	(32:"wm_setcursor"),
	(33:"wm_mouseactivate"),
	(34:"wm_childactivate"),
	(35:"wm_queuesync"),
	(36:"wm_getminmaxinfo"),
	(38:"wm_painticon"),
	(39:"wm_iconerasebkgnd"),
	(40:"wm_nextdlgctl"),
	(42:"wm_spoolerstatus"),
	(43:"wm_drawitem"),
	(44:"wm_measureitem"),
	(45:"wm_deleteitem"),
	(46:"wm_vkeytoitem"),
	(47:"wm_chartoitem"),
	(48:"wm_setfont"),
	(49:"wm_getfont"),
	(50:"wm_sethotkey"),
	(51:"wm_gethotkey"),
	(55:"wm_querydragicon"),
	(57:"wm_compareitem"),
	(64:"tbif_size"),
	(65:"wm_compacting"),
	(70:"wm_windowposchanging"),
	(71:"wm_windowposchanged"),
	(72:"wm_power"),
	(74:"wm_copydata"),
	(75:"wm_canceljournal"),
	(78:"wm_notify"),
	(80:"wm_inputlangchangerequest"),
	(81:"wm_inputlangchange"),
	(82:"wm_tcard"),
	(83:"wm_help"),
	(84:"wm_userchanged"),
	(85:"wm_notifyformat"),
	(123:"wm_contextmenu"),
	(124:"wm_stylechanging"),
	(125:"wm_stylechanged"),
	(126:"wm_displaychange"),
	(127:"wm_geticon"),
	(128:"wm_seticon"),
	(129:"wm_nccreate"),
	(130:"wm_ncdestroy"),
	(131:"wm_nccalcsize"),
	(132:"wm_nchittest"),
	(133:"wm_ncpaint"),
	(134:"wm_ncactivate"),
	(135:"wm_getdlgcode"),
	(160:"wm_ncmousemove"),
	(161:"wm_nclbuttondown"),
	(162:"wm_nclbuttonup"),
	(163:"wm_nclbuttondblclk"),
	(164:"wm_ncrbuttondown"),
	(165:"wm_ncrbuttonup"),
	(166:"wm_ncrbuttondblclk"),
	(167:"wm_ncmbuttondown"),
	(168:"wm_ncmbuttonup"),
	(169:"wm_ncmbuttondblclk"),
	(176:"em_getsel"),
	(177:"em_setsel"),
	(178:"em_getrect"),
	(179:"em_setrect"),
	(180:"em_setrectnp"),
	(181:"em_scroll"),
	(182:"em_linescroll"),
	(183:"em_scrollcaret"),
	(184:"em_getmodify"),
	(185:"em_setmodify"),
	(186:"em_getlinecount"),
	(187:"em_lineindex"),
	(188:"em_sethandle"),
	(189:"em_gethandle"),
	(190:"em_getthumb"),
	(193:"em_linelength"),
	(194:"em_replacesel"),
	(196:"em_getline"),
	(197:"em_setlimittext"),
	(198:"em_canundo"),
	(199:"em_undo"),
	(200:"em_fmtlines"),
	(201:"em_linefromchar"),
	(203:"em_settabstops"),
	(204:"em_setpasswordchar"),
	(205:"em_emptyundobuffer"),
	(206:"em_getfirstvisibleline"),
	(207:"em_setreadonly"),
	(208:"em_setwordbreakproc"),
	(209:"em_getwordbreakproc"),
	(210:"em_getpasswordchar"),
	(211:"em_setmargins"),
	(212:"em_getmargins"),
	(213:"em_getlimittext"),
	(214:"em_posfromchar"),
	(215:"em_charfrompos"),
	(224:"sbm_setpos"),
	(225:"sbm_getpos"),
	(226:"sbm_setrange"),
	(227:"sbm_getrange"),
	(228:"sbm_enable_arrows"),
	(230:"sbm_setrangeredraw"),
	(233:"sbm_setscrollinfo"),
	(234:"sbm_getscrollinfo"),
	(240:"bm_getcheck"),
	(241:"bm_setcheck"),
	(242:"bm_getstate"),
	(243:"bm_setstate"),
	(244:"bm_setstyle"),
	(245:"bm_click"),
	(246:"bm_getimage"),
	(247:"bm_setimage"),
	(255:"wm_input"),
	(256:"wm_keydown"),
	(257:"wm_keyup"),
	(258:"wm_char"),
	(259:"wm_deadchar"),
	(260:"wm_syskeydown"),
	(261:"wm_syskeyup"),
	(262:"wm_syschar"),
	(263:"wm_sysdeadchar"),
	(269:"wm_ime_startcomposition"),
	(270:"wm_ime_endcomposition"),
	(271:"wm_ime_composition"),
	(272:"wm_initdialog"),
	(273:"wm_command"),
	(274:"wm_syscommand"),
	(275:"wm_timer"),
	(276:"wm_hscroll"),
	(277:"wm_vscroll"),
	(278:"wm_initmenu"),
	(279:"wm_initmenupopup"),
	(287:"wm_menuselect"),
	(288:"wm_menuchar"),
	(289:"wm_enteridle"),
	(290:"wm_menurbuttonup"),
	(295:"wm_changeuistate"),
	(296:"wm_updateuistate"),
	(297:"wm_queryuistate"),
	(306:"wm_ctlcolormsgbox"),
	(307:"wm_ctlcoloredit"),
	(308:"wm_ctlcolorlistbox"),
	(309:"wm_ctlcolorbtn"),
	(310:"wm_ctlcolordlg"),
	(311:"wm_ctlcolorscrollbar"),
	(312:"wm_ctlcolorstatic"),
	(320:"cb_geteditsel"),
	(321:"cb_limittext"),
	(322:"cb_seteditsel"),
	(323:"cb_addstring"),
	(324:"cbem_deleteitem"),
	(325:"cb_dir"),
	(326:"cb_getcount"),
	(327:"cb_getcursel"),
	(328:"cb_getlbtext"),
	(329:"cb_getlbtextlen"),
	(330:"cb_insertstring"),
	(331:"cb_resetcontent"),
	(332:"cb_findstring"),
	(333:"cb_selectstring"),
	(334:"cb_setcursel"),
	(335:"cb_showdropdown"),
	(336:"cb_getitemdata"),
	(337:"cb_setitemdata"),
	(338:"cb_getdroppedcontrolrect"),
	(339:"cb_setitemheight"),
	(340:"cb_getitemheight"),
	(341:"cb_setextendedui"),
	(342:"cb_getextendedui"),
	(343:"cb_getdroppedstate"),
	(344:"cb_findstringexact"),
	(345:"cb_setlocale"),
	(346:"cb_getlocale"),
	(347:"cb_gettopindex"),
	(348:"cb_settopindex"),
	(349:"cb_gethorizontalextent"),
	(350:"cb_sethorizontalextent"),
	(351:"cb_getdroppedwidth"),
	(352:"cb_setdroppedwidth"),
	(353:"cb_initstorage"),
	(368:"stm_seticon"),
	(369:"stm_geticon"),
	(370:"stm_setimage"),
	(371:"stm_getimage"),
	(384:"lb_addstring"),
	(385:"lb_insertstring"),
	(386:"lb_deletestring"),
	(387:"lb_selitemrangeex"),
	(388:"lb_resetcontent"),
	(389:"lb_setsel"),
	(390:"lb_setcursel"),
	(391:"lb_getsel"),
	(392:"lb_getcursel"),
	(393:"lb_gettext"),
	(394:"lb_gettextlen"),
	(395:"lb_getcount"),
	(396:"lb_selectstring"),
	(397:"lb_dir"),
	(398:"lb_gettopindex"),
	(399:"lb_findstring"),
	(400:"lb_getselcount"),
	(401:"lb_getselitems"),
	(402:"lb_settabstops"),
	(403:"lb_gethorizontalextent"),
	(404:"lb_sethorizontalextent"),
	(405:"lb_setcolumnwidth"),
	(406:"lb_addfile"),
	(407:"lb_settopindex"),
	(408:"lb_getitemrect"),
	(409:"lb_getitemdata"),
	(410:"lb_setitemdata"),
	(411:"lb_selitemrange"),
	(412:"lb_setanchorindex"),
	(413:"lb_getanchorindex"),
	(414:"lb_setcaretindex"),
	(415:"lb_getcaretindex"),
	(416:"lb_setitemheight"),
	(417:"lb_getitemheight"),
	(418:"lb_findstringexact"),
	(421:"lb_setlocale"),
	(422:"lb_getlocale"),
	(423:"lb_setcount"),
	(424:"lb_initstorage"),
	(425:"lb_itemfrompoint"),
	(512:"wm_mousemove"),
	(513:"wm_lbuttondown"),
	(514:"wm_lbuttonup"),
	(515:"wm_lbuttondblclk"),
	(516:"wm_rbuttondown"),
	(517:"wm_rbuttonup"),
	(518:"wm_rbuttondblclk"),
	(519:"wm_mbuttondown"),
	(520:"wm_mbuttonup"),
	(521:"wm_mbuttondblclk"),
	(522:"wm_mousewheel"),
	(523:"wm_xbuttondown"),
	(524:"wm_xbuttonup"),
	(525:"wm_xbuttondblclk"),
	(528:"wm_parentnotify"),
	(529:"wm_entermenuloop"),
	(530:"wm_exitmenuloop"),
	(531:"wm_nextmenu"),
	(532:"wm_sizing"),
	(533:"wm_capturechanged"),
	(534:"wm_moving"),
	(536:"wm_powerbroadcast"),
	(537:"wm_devicechange"),
	(544:"wm_mdicreate"),
	(545:"wm_mdidestroy"),
	(546:"wm_mdiactivate"),
	(547:"wm_mdirestore"),
	(548:"wm_mdinext"),
	(549:"wm_mdimaximize"),
	(550:"wm_mditile"),
	(551:"wm_mdicascade"),
	(552:"wm_mdiiconarrange"),
	(553:"wm_mdigetactive"),
	(560:"wm_mdisetmenu"),
	(561:"wm_entersizemove"),
	(562:"wm_exitsizemove"),
	(563:"wm_dropfiles"),
	(564:"wm_mdirefreshmenu"),
	(641:"wm_ime_setcontext"),
	(642:"wm_ime_notify"),
	(643:"wm_ime_control"),
	(644:"wm_ime_compositionfull"),
	(645:"wm_ime_select"),
	(646:"wm_ime_char"),
	(656:"wm_ime_keydown"),
	(657:"wm_ime_keyup"),
	(673:"wm_mousehover"),
	(675:"wm_mouseleave"),
	(689:"wm_wtssession_change"),
	(768:"wm_cut"),
	(769:"wm_copy"),
	(770:"wm_paste"),
	(771:"wm_clear"),
	(772:"wm_undo"),
	(773:"wm_renderformat"),
	(774:"wm_renderallformats"),
	(775:"wm_destroyclipboard"),
	(776:"wm_drawclipboard"),
	(777:"wm_paintclipboard"),
	(778:"wm_vscrollclipboard"),
	(779:"wm_sizeclipboard"),
	(780:"wm_askcbformatname"),
	(781:"wm_changecbchain"),
	(782:"wm_hscrollclipboard"),
	(783:"wm_querynewpalette"),
	(784:"wm_paletteischanging"),
	(785:"wm_palettechanged"),
	(786:"wm_hotkey"),
	(791:"wm_print"),
	(792:"wm_printclient"),
	(896:"wm_penwinirst"),
	(911:"wm_penwinlast"),
	(1024:"infotipsize"),
	(1025:"cbem_insertitema"),
	(1026:"cbem_setimagelist"),
	(1027:"cbem_getimagelist"),
	(1028:"cbem_getitema"),
	(1029:"cbem_setitema"),
	(1030:"cbem_getcombocontrol"),
	(1031:"cbem_geteditcontrol"),
	(1032:"cbem_setexstyle"),
	(1033:"cbem_getextendedstyle"),
	(1034:"cbem_haseditchanged"),
	(1035:"cbem_insertitemw"),
	(1036:"cbem_setitemw"),
	(1037:"cbem_getitemw"),
	(1038:"cbem_setextendedstyle"),
	(1039:"ttm_getcurrenttoola"),
	(1040:"ttm_windowfrompoint"),
	(1041:"ttm_trackactivate"),
	(1042:"ttm_trackposition"),
	(1043:"ttm_settipbkcolor"),
	(1044:"ttm_settiptextcolor"),
	(1045:"ttm_getdelaytime"),
	(1046:"ttm_gettipbkcolor"),
	(1047:"ttm_gettiptextcolor"),
	(1048:"ttm_setmaxtipwidth"),
	(1049:"ttm_getmaxtipwidth"),
	(1050:"ttm_setmargin"),
	(1051:"ttm_getmargin"),
	(1052:"ttm_pop"),
	(1053:"tb_getitemrect"),
	(1054:"tb_buttonstructsize"),
	(1055:"tb_setbuttonsize"),
	(1056:"tb_setbitmapsize"),
	(1057:"tb_autosize"),
	(1059:"tb_gettooltips"),
	(1060:"tb_settooltips"),
	(1061:"tb_setparent"),
	(1063:"tb_setrows"),
	(1064:"tb_getrows"),
	(1065:"tb_getbitmapflags"),
	(1066:"tb_setcmdid"),
	(1067:"tb_changebitmap"),
	(1068:"tb_getbitmap"),
	(1069:"tb_getbuttontexta"),
	(1070:"tb_replacebitmap"),
	(1071:"tb_setindent"),
	(1072:"tb_setimagelist"),
	(1073:"tb_getimagelist"),
	(1074:"ttm_addtoolw"),
	(1075:"ttm_deltoolw"),
	(1076:"ttm_newtoolrectw"),
	(1077:"ttm_gettoolinfow"),
	(1078:"ttm_settoolinfow"),
	(1079:"ttm_hittestw"),
	(1080:"ttm_gettextw"),
	(1081:"ttm_updatetiptextw"),
	(1082:"ttm_enumtoolsw"),
	(1083:"ttm_getcurrenttoolw"),
	(1084:"tb_setmaxtextrows"),
	(1085:"tb_gettextrows"),
	(1086:"em_getseltext"),
	(1087:"em_hideselection"),
	(1088:"em_pastespecial"),
	(1089:"em_requestresize"),
	(1090:"em_selectiontype"),
	(1091:"tb_insertbuttonw"),
	(1092:"tb_addbuttonsw"),
	(1093:"tb_hittest"),
	(1094:"em_setolecallback"),
	(1095:"em_setparaformat"),
	(1096:"em_settargetdevice"),
	(1097:"em_streamin"),
	(1098:"em_streamout"),
	(1099:"tb_getbuttontextw"),
	(1100:"tb_saverestorew"),
	(1101:"tb_addstringw"),
	(1102:"em_getoptions"),
	(1103:"tb_getinsertmark"),
	(1104:"tb_setinsertmark"),
	(1105:"tb_insertmarkhittest"),
	(1106:"tb_movebutton"),
	(1107:"tb_getmaxsize"),
	(1108:"tb_setextendedstyle"),
	(1109:"tb_getextendedstyle"),
	(1110:"tb_getpadding"),
	(1111:"tb_setpadding"),
	(1112:"tb_setinsertmarkcolor"),
	(1113:"tb_getinsertmarkcolor"),
	(1114:"tb_mapacceleratorw"),
	(1124:"em_setpunctuation"),
	(1125:"wm_choosefont_setlogfont"),
	(1126:"wm_choosefont_setflags"),
	(1127:"udm_setpos"),
	(1128:"udm_getpos"),
	(1129:"udm_setbuddy"),
	(1130:"udm_getbuddy"),
	(1131:"udm_setaccel"),
	(1132:"udm_getaccel"),
	(1133:"udm_setbase"),
	(1134:"udm_getbase"),
	(1135:"psm_settitlea"),
	(1136:"psm_setwizbuttons"),
	(1137:"psm_pressbutton"),
	(1138:"psm_setcurselid"),
	(1139:"psm_setfinishtexta"),
	(1140:"psm_gettabcontrol"),
	(1141:"psm_isdialogmessage"),
	(1142:"psm_getcurrentpagehwnd"),
	(1144:"psm_settitlew"),
	(1145:"psm_setfinishtextw"),
	(1157:"dl_begindrag"),
	(1158:"dl_dragging"),
	(1159:"dl_dropped"),
	(1160:"dl_canceldrag"),
	(1280:"en_errspace"),
	(1281:"en_maxtext"),
	(1537:"en_hscroll"),
	(1538:"en_vscroll"),
	(1792:"en_msgfilter"),
	(1793:"en_requestresize"),
	(1794:"en_selchange"),
	(1795:"en_dropfiles"),
	(1796:"en_protected"),
	(1797:"en_correcttext"),
	(1798:"en_stopnoundo"),
	(1799:"en_imechange"),
	(1800:"en_saveclipboard"),
	(1801:"en_oleopfailed"),
	(4096:"lvm_getbkcolor"),
	(4097:"lvm_setbkcolor"),
	(4098:"lvm_getimagelist"),
	(4099:"lvm_setimagelist"),
	(4100:"lvm_getitemcount"),
	(4101:"lvm_getitema"),
	(4102:"lvm_setitema"),
	(4103:"lvm_insertitema"),
	(4104:"lvm_deleteitem"),
	(4105:"lvm_deleteallitems"),
	(4106:"lvm_getcallbackmask"),
	(4107:"lvm_setcallbackmask"),
	(4108:"lvm_getnextitem"),
	(4109:"lvm_finditema"),
	(4110:"lvm_getitemrect"),
	(4111:"lvm_setitemposition"),
	(4112:"lvm_getitemposition"),
	(4113:"lvm_getstringwidtha"),
	(4114:"lvm_hittest"),
	(4115:"lvm_ensurevisible"),
	(4116:"lvm_scroll"),
	(4117:"lvm_redrawitems"),
	(4118:"lvm_arrange"),
	(4119:"lvm_editlabela"),
	(4120:"lvm_geteditcontrol"),
	(4121:"lvm_getcolumna"),
	(4122:"lvm_setcolumna"),
	(4123:"lvm_insertcolumna"),
	(4124:"lvm_deletecolumn"),
	(4125:"lvm_getcolumnwidth"),
	(4126:"lvm_setcolumnwidth"),
	(4129:"lvm_createdragimage"),
	(4130:"lvm_getviewrect"),
	(4131:"lvm_gettextcolor"),
	(4132:"lvm_settextcolor"),
	(4133:"lvm_gettextbkcolor"),
	(4134:"lvm_settextbkcolor"),
	(4135:"lvm_gettopindex"),
	(4136:"lvm_getcountperpage"),
	(4137:"lvm_getorigin"),
	(4138:"lvm_update"),
	(4139:"lvm_setitemstate"),
	(4140:"lvm_getitemstate"),
	(4141:"lvm_getitemtexta"),
	(4142:"lvm_setitemtexta"),
	(4143:"lvm_setitemcount"),
	(4144:"lvm_sortitems"),
	(4145:"lvm_setitemposition32"),
	(4146:"lvm_getselectedcount"),
	(4147:"lvm_getitemspacing"),
	(4148:"lvm_getisearchstringa"),
	(4171:"lvm_getitemw"),
	(4172:"lvm_setitemw"),
	(4173:"lvm_insertitemw"),
	(4179:"lvm_finditemw"),
	(4183:"lvm_getstringwidthw"),
	(4191:"lvm_getcolumnw"),
	(4192:"lvm_setcolumnw"),
	(4193:"lvm_insertcolumnw"),
	(4211:"lvm_getitemtextw"),
	(4212:"lvm_setitemtextw"),
	(4213:"lvm_getisearchstringw"),
	(4214:"lvm_editlabelw"),
	(4352:"tvm_insertitema"),
	(4353:"tvm_deleteitem"),
	(4354:"tvm_expand"),
	(4356:"tvm_getitemrect"),
	(4357:"tvm_getcount"),
	(4358:"tvm_getindent"),
	(4359:"tvm_setindent"),
	(4360:"tvm_getimagelist"),
	(4361:"tvm_setimagelist"),
	(4362:"tvm_getnextitem"),
	(4363:"tvm_selectitem"),
	(4364:"tvm_getitema"),
	(4365:"tvm_setitema"),
	(4366:"tvm_editlabela"),
	(4367:"tvm_geteditcontrol"),
	(4368:"tvm_getvisiblecount"),
	(4369:"tvm_hittest"),
	(4370:"tvm_createdragimage"),
	(4371:"tvm_sortchildren"),
	(4372:"tvm_ensurevisible"),
	(4373:"tvm_sortchildrencb"),
	(4374:"tvm_endeditlabelnow"),
	(4375:"tvm_getisearchstringa"),
	(4402:"tvm_insertitemw"),
	(4414:"tvm_getitemw"),
	(4415:"tvm_setitemw"),
	(4416:"tvm_getisearchstringw"),
	(4417:"tvm_editlabelw"),
	(4608:"hdm_getitemcount"),
	(4609:"hdm_insertitema"),
	(4610:"hdm_deleteitem"),
	(4611:"hdm_getitema"),
	(4612:"hdm_setitema"),
	(4613:"hdm_layout"),
	(4614:"hdm_hittest"),
	(4618:"hdm_insertitemw"),
	(4619:"hdm_getitemw"),
	(4620:"hdm_setitemw"),
	(4864:"tcm_first"),
	(4866:"tcm_getimagelist"),
	(4867:"tcm_setimagelist"),
	(4868:"tcm_getitemcount"),
	(4869:"tcm_getitema"),
	(4870:"tcm_setitema"),
	(4871:"tcm_insertitema"),
	(4872:"tcm_deleteitem"),
	(4873:"tcm_deleteallitems"),
	(4874:"tcm_getitemrect"),
	(4875:"tcm_getcursel"),
	(4876:"tcm_setcursel"),
	(4877:"tcm_hittest"),
	(4878:"tcm_setitemextra"),
	(4904:"tcm_adjustrect"),
	(4905:"tcm_setitemsize"),
	(4906:"tcm_removeimage"),
	(4907:"tcm_setpadding"),
	(4908:"tcm_getrowcount"),
	(4909:"tcm_gettooltips"),
	(4910:"tcm_settooltips"),
	(4911:"tcm_getcurfocus"),
	(4912:"tcm_setcurfocus"),
	(4924:"tcm_getitemw"),
	(4925:"tcm_setitemw"),
	(4926:"tcm_insertitemw"),
	(5120:"pgm_first"),
	(8192:"ccm_first")]

proc start=
end
=== gxlib.q 54/56 ===
import sys
import files
import clib
import oslib

import winconsts
import winapi
import wingxlib
import winmessages

import gxmisc

global var debug=0

global var messhandlertable=9000	!message by windowclass table of message handlers

global var chx,chy		!default text sizes for menus
global var cha,chd		!ascender/descender heights
global const smx=3		!margins around button text in pixels (both sides)
global const smy=4
global var arrowdim
global var markdim
global var buttonheight
global var listrowheight
global const labelfont=1

global var tabstops=(8,)*20

global var wmouse=0
global var wfocus=0
global var wprinter=0
global var lastmousepos=0
global var lastmousewindow=0
global var currmousewindow=0

global var mousepos
global var mousesw
global var quitmess=0
global var dragmode=0
global var lastbuttontime=0

global var buttonstate=0
global var wmessagetable		!see initdata
global var buttontable		!see initdata

const maxqueuesize=100
global var messagequeue=()
global var nmessages=()

const dragtol=1

global var copymode=4

GLOBAL var vktomesstable

global record rwindow =

	var windclass					! type of window (popup, control, etc)
	var flags						! general purpose flags
	var style						! stylerec entry
	var name						! Optional debugging name

	var owner						! owner when this is a child window
	var index						! index 1..n when part of a list (eg. .childlist of owner)
	var childlist					! list of child windows

	var frameposx, frameposy		! top left of frame, in screen or owner window client coords
	var framedimx, framedimy		! pixels dims including frame and caption

	var	posx, posy					! Pixel pos client area as seen by application
	var	dimx, dimy					! Pixel dims of client area as seen by application

	var gdi							! (rgdistate)	gdi state record

	var enable						! 1 to enable toggle/button/arrow etc, 0 to disable and show greyed out
	var id							! button/et al: command code associated with control
	var text						! caption or label or primary data
		var data 	@text
	var linkvar						! pointer to linked var for toggle/select/scroll
	var gindex						! window global index

	var attrs						! general purpose attributes, depends on window class

	var pixelbits					! 1, 4, 16, 24, 32 bits per pixel
	var pixelptr					! pointer to image data
	var pixelbytes					!bytes/pixel (round up to next whole byte)
	var linebytes					!bytes/per row, also pitch
	var framebytes
	var paltype						!0, or palette type
end


global tabledata() paltypenames =
	(no_pal=0,		$),
	(greyscale_pal,	$),
	(tinted_pal,	$),
	(colour_pal,	$),
	(uv_pal,		$),
end

global type rgdistate = struct
	int64 hwnd				! win32 handle (hwnd)
	int64 hdc				! 0 or device context handle for hwnd
	int64 hwnd2				! secondary window/memory backup
	int64 hdc2				! 0 or hwnd3 DC screen or memory hdc
	int64 originalwndproc	! win32 control handling proc
	int64 menuhandle			! win32 handle to any menubar
		int64 oldbmobj @menuhandle		!used for bitmaps
	int32 drawmode			! see dm- drawcodes
	int32 updated				! 1 when pixels have changed

	int32 posx,posy			!current drawing position
	int32 pencolour			! current line colour (rgb)
	int32 penwidth			! current line width

	int32 penstyle			! current line dotted style

	int32 xormode				! 0=normal, 1=xor
	int32 brushcolour			! current brush colour
	int32 brushstyle			! current brush style (bs_solid/etc)
	int32 brushpattern		! current brush hatch/bitmap pattern

	int32 font				! current font number
end

global tabledata() marktypenames =
	(no_mark=0,			$),
	(radio_mark,		$),
	(tick_mark,			$),
	(check_mark,		$),
	(invert_mark,		$),
	(outline_mark,		$),
	(bold_mark,			$),
end

global tabledata() hilitetypenames =
	(no_hilite=0,		$),
	(invert_hilite,		$),
	(outline_hilite,	$),
end

global record togglerec=		!for toggle and select
	var textoffset
	var onvalue
end

global record scrollbarrec=		!scroll bars
	var limits						!range
	var span						!portion of limits represented by visible data (0 means not relevant)
	var thumbsize					!pixel length of thumb (vert or hoz extent along scrollbar)
	var thumbspan					!pixels that the thumb can move
	var thumbpos					!current thumb position in pixels from start of scrollbar
	var currpos						!current position, will be in limits range
	var dragmode					!1 if thum currently being dragged
end

global record editboxrec=		!edit boxes
	var currpos						!cursor position, 1 to N+1 (N=chars in edit text)
	var caretpos					!current pixel position of any caret
	var textpos						!start x,y pixel position of text, set by gxjust_text
end

global record listboxrec=
	var rows						!number of displayed rows
	var pagepos						!data position corresponding to row 1 of display
	var length						!all data items, same as linkvar^.len
	var currpos						!cursor position within the data, 1 to N (can be 0 when N=0)
	var pitch, offset				!pixel dims of each row
end

global class rmessage=
	var		wind		!main window/button associated with message
	var		menuwind	!top-level window owning button
	var		message		!message number
	var		state		!button/shift key state at time of message
	var		a,b			!general purpose data, depends on message
	var		x,y			!current mouse position
end


global type stylerec = struct
	byte	border				!bs_ code
	byte	justify				!'L', 'R', 'C'
	byte	vjustify			!'T', 'B', 'M'
	byte	windbgnd			!colour index for window background
	byte	textfgnd			!colour index
	byte	textbgnd			!
	byte	bgndmode			!
	byte	textfont			!font index
	byte	textsize			!pixel size
	byte	textbold			!1 if bold
	byte	textitalic			!1 if italic
	byte	ispassword			!1 when edit field is a password
	byte	fieldwidth			!edit field maximum char width
	byte	dir					!'L','R','U','D'
	byte	marktype			!xxx_mark style, or:
	byte	hilitetype			!xxx_hilite style
	byte	iframe				!1: pos/dim include frame
	byte	imark				!1: pos/dim include mark for toggle/select
	byte	hscroll				!1: include windows-drawn hoz scroll bar
	byte	vscroll				!1: include windows-drawn vert scroll bar
	byte	lbchange			!1: return mm_change on list boxes when row has changed
	byte	returnmess			!1: return id code when clicking toggle/select/editbox
	byte	noupdate			!1: don't change or allow editing on toggle/select/editbox
end

global record rpoint = var x,y end
global record rrect  = (var pos,dim)
global record rframe = (var x1,y1,x2,y2)

global class getrec=
	method getbounds(&self)=
		return 0
	end method
	method getitem(&self,n)=
		return 0
	end method
	method getstritem(&self,n)= return "" end method
end

global tabledata() stylenames =	! (default)
	(ss_border,			$),		! Border style (wbs_simple)
	(ss_justify,		$),		! 'L' 'C' 'R'	Horizontal text justify ('L')
	(ss_vjustify,		$),		! 'T' 'M' 'B'	Vertical text justify ('M' for buttons)
	(ss_textfgnd,		$),		! Text colour index (black)
	(ss_textbgnd,		$),		! Text background colour index (if opaque mode) (0)
	(ss_bgndmode,		$),		! 0
	(ss_textfont,		$),		! Text font number (1)
	(ss_textsize,		$),		! (0)
	(ss_textbold,		$),		! (0)
	(ss_textitalic,		$),		! (0)
	(ss_ispassword,		$),		! (0)
	(ss_marktype,		$),		! Toggle/select mark style (radio_mark)
	(ss_hilitetype,		$),		! Toggle/select hilite style (no_hilite)
	(ss_iframe,			$),		! Whether pos and dim include frame width (also caption bar/menu for windows)
	(ss_windbgnd,		$),		! Background colour of window or button (ltgrey)
	(ss_imark,			$),		! Background colour of window or button (ltgrey)
	(ss_hscroll,		$),		! (0)
	(ss_vscroll,		$),		! (0)
	(ss_lbchange,		$),		! (0)
	(ss_returnmess,		$),		! (0) Toggle/select/editbox, return id when clicked
	(ss_noupdate,		$),		! (0) Toggle/select/editbox, don't change or allow edit
end

global tabledata() drawmodenames =
								!HDC	HDC2	Restore
	(dm_screen=0,		$),		!screen	--		Custom routine	Draw directly to screen; no mem backup
	(dm_memory,			$),		!memory	--		NA				Draw to memory only; no screen hdc (eg. bitmap)
	(dm_screenmemory,	$),		!screen	memory	Blit mem->scr	Draw to both screen and memory at same time
	(dm_memoryscreen,	$),		!memory	screen	Blit mem->scr	Draw to memory; update screen periodically
end


global tabledata() wfnames = begin
	(wa_rightclick=0,	$),		!allow right click
	(wa_middleclick,	$),		!allow middle click
	(wa_leftdbl,		$),		!allow left double click
	(wa_rightdbl,		$),		!allow right double click
	(wa_middledbl,		$),		!allow middle double click
	(wa_leftdrag,		$),		!allow left drag
	(wa_rightdrag,		$),		!etc
	(wa_middledrag,		$),
	(wa_autoupdate,		$),		!auto update screen for toggles/etc
	(wa_tab,			$), 	!allow tab to switch to next button which has watab
	(wa_strvar,			$), 	!1 for listbox linkvar to use string not index
	(wa_retmess,		$), 	!1 for button to return .value as mess not qmcommand
	(wa_retsel,			$), 	!1 for button to return .value as mess not qmcommand
	(wa_memory,			$), 	!1 when hdc/hdcmem have been switched, hdc points to memory dev
	(wa_maximised,		$),		!1 when maximised, 0 when normal/minimised
	(wa_param1,			$), 	!general purpose control-specific flags
	(wa_param2,			$), 
	(wa_useenter,		$),
	(wa_closed,			$),		!whether window has been closed

	(wa_$last,			$)
end

const wa_needdbl	= wa_param1	!1 requires double-click on listbox to return wmcommand
const wa_editdd		= wa_param2	!1 means editable dropdown box

global tabledata() bsnames, bscat, bswidths=
	(bs_none=0,		$,	0,	ws_rect(0,0,0,0)),			!no border
	(bs_simplew,	$,	'W',	ws_rect(1,1,1,1)),			!single 1-pixel black line, windows drawn
	(bs_simple,		$,	'X',	ws_rect(1,1,1,1)),			!single 1-pixel black line
	(bs_thick,		$,	'X',	ws_rect(2,2,2,2)),			!2-pixel border
	(bs_panel,		$,	'X',	ws_rect(1,1,1,1)),			!raised panel, 1-pixel
	(bs_inset,		$,	'X',	ws_rect(1,1,1,1)),			!inset panel, 1-pixel
	(bs_ownsimple,	$,	'I',	ws_rect(0,0,0,0)),			!included inset panel, 1-pixel (drawn as part of client area)
	(bs_ownpanel,	$,	'I',	ws_rect(0,0,0,0)),			!included inset panel, 1-pixel (drawn as part of client area)
	(bs_owninset,	$,	'I',	ws_rect(0,0,0,0)),			!included inset panel, 1-pixel
	(bs_testext,	$,	'X',	ws_rect(10,10,10,10)),
	(bs_testint,	$,	'I',	ws_rect(8,8,8,8)),
	(bs_dummy,		$,	0,	ws_rect(0,0,0,0))
end

global tabledata() windowclassnames, defaultborderstyles = begin
	(no_class=0,		$,	bs_none),			!Unassigned
	(window_class,		$,	wbs_resize),		!Main window
	(memwindow_class,	$,	wbs_none),			!memory backup to any window
	(popup_class,		$,	wbs_thick),			!Pop-up window (forms a stack)
	(float_class,		$,	bs_thick),			!Independent window
	(bitmap_class,		$,	bs_none),			!(image handling)
	(screen_class,		$,	bs_none),			!Describes the desktop screen (not owned by my app)
	(printer_class,		$,	bs_none),			!Used for printing

	(group_class,		$,	bs_inset),			!Used mainly for grouping other buttons (eg. for Smdefblock)
	(panel_class,		$,	bs_inset),			!General purpose panel for drawing in etc
	(button_class,		$,	bs_simplew),		!Click button
	(toggle_class,		$,	bs_none),			!Toggle button (can be composite, eg mark and label)
	(select_class,		$,	bs_none),			!Select from several choices
	(editbox_class,		$,	bs_simplew),		!Single-line edit control
	(scrollbar_class,	$,	bs_simplew),		!Hoz or vert scroll bar (Some windows can also have Windows-drawn scroll bars)
	(listbox_class,		$,	bs_simplew),		!List of options (scrollable usually)
	(dropdown_class,	$,	bs_none),			!Button revealing attached listbox when clicked
	(framebar_class,	$,	bs_panel),			!Left or right full-height panel used for toolboxes etc
	(statusbar_class,	$,	bs_panel),			!Top or bottom full-width panel used for scrollbars
	(tooltip_class,		$,	bs_simplew),		!Tooltops displayed when hovering over enabled buttons
	(arrow_class,		$,	bs_ownpanel),		!Click button normally displaying an error in one of 4 orientations
	(mark_class,		$,	bs_none),			!Toggle or select mark
	(label_class,		$,	bs_none),			!Contains unclickable text usually
	(dummy_class,		$,	bs_none)
end

global tabledata() actionnames, actionhandlertable=
	(draw_w,		$,		()),
	(update_w,		$,		()),
	(last_w,		$,		()),
end


global tabledata() messagenames= begin

	(mm_null=0,			$),		! empty message

	(mm_activate,		$),		! (w,a) a=1/0 activate/deactivate window
	(mm_close,			$),		! (w) close window (X button clicked)
	(mm_sizewindow,		$),		! (w...) resize window
	(mm_movewindow,		$),		! (w...) move window
	(mm_restore,		$),		! (w...) repaint window

	(mm_setcursor,		$),		! (w...) update cursor type
	(mm_setfocus,		$),		! (w...) set focus to w
	(mm_killfocus,		$),		! (w...) lose focus from w

	(mm_move,			$),		! (w,x,y,b) mouse move, btns up/down (also drag messages when down)
	(mm_click,			$),		! (w,x,y) left btn click, can be promoted to mm_command etc depending on context
	(mm_dblclick,		$),		! (w,x,y) left btn dbl click, usu promoted
	(mm_clickup,		$),		! (w,x,y) left btn released
	(mm_rclick,			$),		! (w,x,y) right click in window, these usu. promoted
	(mm_rdblclick,		$),		! (w,x,y) right double click
	(mm_rclickup,		$),		! (w,x,y) right button released
	(mm_mclick,			$),		! (w,x,y) middle button versions of above
	(mm_mdblclick,		$),		! (w,x,y)
	(mm_mclickup,		$),		! (w,x,y)
	(mm_hover,			$),		! (w,x,y) paused over button

	(mm_onwindow,		$),		! (w,x,y) newly over a window
	(mm_offwindow,		$),		! (w,x,y) just came off window
	(mm_draw,			$),		! (w,x,y) redraw window
	(mm_update,			$),		! (w,x,y) update window (change of pos etc)

	(mm_startdrag,		$),		! (w) start mouse movement with some btns down
	(mm_rstartdrag,		$),		! (w)
	(mm_mstartdrag,		$),		! (w)
	(mm_drag,			$),		! (w,x,y) moving mouse with buttons down (also qmmove sent)
	(mm_enddrag,		$),		! (w,x,y) all buttons up after drag

	(mm_command,		$),		! (w,id) button clicked, id and sub-event given
	(mm_dblcommand,		$),		! (w,id) button double clicked

	(mm_rcommand,		$),		! (w,id) right click button
	(mm_rdblcommand,	$),		! (w,id) right double click button

	(mm_mcommand,		$),		! (w,id)
	(mm_mdblcommand,	$),		! (w,id)

	(mm_char,			$),		! (w,ch)
	(mm_key,			$),		! (w,k,shift)
	(mm_keyup,			$),		! (w,k,shift)

	(mm_sethozpos,		$),		! (w,pos)		New logical position set by hoz scrollbar
	(mm_setvertpos,		$),		! (w,pos)		from vertical scrollbar
	(mm_select,			$),		! (w,n)			Set nth item as current/highlighted/selected item
	(mm_pick,			$),		! (w,n)			Pick and return item n
	(mm_wheel,			$),		! (w,delta)		Move log pos etc but depends on context
	(mm_lbchange,		$),		! (w,n)			A listbox position has changed

	(mm_timer,			$),		! (w)

	(mm_cancel,			$),		! (w)
	(mm_ok,				$),		! (w)
	(mm_help,			$),		! (w,id)
	(mm_cmdline,		$),		! (w,s)

	(mm_leftkey ,		$),		! (w,shift)
	(mm_rightkey,		$),		! (w,shift)
	(mm_upkey,			$),		! (w,shift)
	(mm_downkey,		$),		! (w,shift)
	(mm_pageupkey,		$),		! (w,shift)
	(mm_pagedownkey,	$),		! (w,shift)
	(mm_homekey,		$),		! (w,shift)
	(mm_endkey,			$),		! (w,shift)
	(mm_tabkey,			$),		! (w,shift)
	(mm_bskey,			$),		! (w,shift)
	(mm_deletekey,		$),		! (w,shift)
	(mm_enterkey,		$),		! (w,shift)
	(mm_insertkey,		$),		! (w,shift)
	(mm_functionkey,	$),		! (w,shift)

	(mm_up,				$),		! (w,id) Arrow up/etc
	(mm_down,			$),		! (w,id)
	(mm_right,			$),		! (w,id)
	(mm_left,			$),		! (w,id)
	(mm_edit,			$),		! (w,id)	Update of edit box
	(mm_edited,			$),		! (w,id)	Finished edit box entry (tab etc)
	(mm_last,			$)
end


global const mm_user	= 200

global const kb_lbutton	= 0x1	!used in buttonstate
global const kb_rbutton	= 0x2
global const kb_mbutton	= 0x4

global const kb_shift	= 0x8	!used in shiftstate
global const kb_ctrl	= 0x10
global const kb_alt		= 0x20
global const kb_capslock	= 0x40
global const kb_dblclick	= 0x80	!used for some messages that don't have dblclick versions,

global const kb_rshift	= 0x100
global const kb_rctrl	= 0x200
global const kb_ralt	= 0x400

global tabledata() colournames, colourvalues = begin
	(black,		$,	0x_00'00'00),
	(red,		$,	0x_00'00'C0),
	(dkred,		$,	0x_00'00'90),
	(red3,		$,	0x_00'00'70),
	(green,		$,	0x_00'C0'00),
	(dkgreen,	$,	0x_00'90'00),
	(green3,	$,	0x_00'70'00),
	
	(blue,		$,	0x_C0'00'00),
	(dkblue,	$,	0x_90'00'00),
	(blue3,		$,	0x_70'00'00),

	(cyan,		$,	0x_c0'c0'00),
	(dkcyan,	$,	0x_90'90'00),
	(cyan3,		$,	0x_70'70'00),

	(magenta,	$,	0x_c0'00'c0),
	(dkmagenta,	$,	0x_90'00'90),
	(magenta3,	$,	0x_70'00'70),

	(yellow,	$,	0x_00'C0'C0),
	(dkyellow,	$,	0x_00'90'90),
	(yellow3,	$,	0x_00'70'70),
	(yellow4,	$,	0x_00'50'50),

	(white,		$,	0x_FF'FF'FF),
	(ltgrey,	$,	0x_C0'C0'C0),
	(grey,		$,	0x_90'90'90),
	(dkgrey,	$,	0x_70'70'70),

	(ltorange,	$,	0x_00'A0'FF),
	(orange,	$,	0x_00'60'FF),
	(flesh,		$,	0x_70'85'EE),
	(pink,		$,	0x_9A'32'DB),
	(dkpink,	$,	0x_72'24'A9),
	(brown,		$,	0x_46'43'7D),
	(blue4,		$,	0x_B7'1C'5E),
	(blue5,		$,	0x_6F'3D'0D),
	(olive,		$,	0x_05'A0'88),
	(ltbrown,	$,	0x_00'70'B0),

	(blue6,		$,	0x_9C'63'1C),
	(green4,	$,	0x_12'51'11),
	(purple,	$,	0x_5E'0D'73),
	(blue7,		$,	0x_E6'27'1C),
	(crimson,	$,	0x_15'2A'D3),
	(violet,	$,	0x_54'16'A0),
	(blue8,		$,	0x_86'68'1E),
	(dkorange,	$,	0x_25'6A'D4),
	(green5,	$,	0x_09'46'41),
	(blue9,		$,	0x_65'0A'1D),

	(ltred,		$,	0x_00'00'FF),
	(ltgreen,	$,	0x_00'FF'00),
	(ltblue,	$,	0x_FF'00'00),
	(ltcyan,	$,	0x_FF'FF'00),
	(ltmagenta,	$,	0x_FF'00'FF),
	(ltyellow,	$,	0x_00'FF'FF),

	(button_col,	$,	0),		!button colour
	(window_col,	$,	0),		!window colour
	(text_col,		$,	0),		!text in windows
end

global const skipmess = 1		!message has been processed; caller must wait for another message
global const thismess = 0		!caller should deal with this message (it has not been processed, or has been but caller can process it too)

global var bmbgnd
global var defstyle			!set initdata
global var currmess

global var wapplic=0
global var wscreen=0

var data,ndata
var tabstack,ntab
var breakflag

macro k_menu=30000
macro kdivide=30001
macro kcolumn=30002
macro kfilehistory=30003

var caretdrawn=0
var dkcolour=0x000000
var ltcolour=0xFFFFFF
var thumbdragmode=0
var thumbstartpos=0

var dirtomess=['L':mm_left,'R':mm_right,'U':mm_up,'D':mm_down]

global proc setupgdi(w,hwnd)=			!SETUPGDI


if w.gdi then
	return			!assume already done
fi

gdi:=new(rgdistate)
gdi.hwnd:=hwnd


if w.type=rwindow then
	gdi.hdc:=getdc(hwnd)
	gdi.drawmode:=dm_screen
else						!assume bitmap
	gdi.hdc:=createcompatibledc(nil)
	gdi.drawmode:=dm_memory
fi

gdi.posx:=gdi.posy:=0
gdi.updated:=0
gdi.font:=0
gdi.pencolour:=getsyscolour(colour_windowtext)
gdi.penwidth:=0
gdi.penstyle:=ps_solid
gdi.xormode:=0
gdi.brushcolour:=0xff'ff'ff
gdi.brushstyle:=bs_solid
gdi.brushpattern:=0
w.gdi:=gdi
end

global const arleft = "<"
global const arright = ">"
global const arup = "^"
global const ardown = "V"

global var allwindows=()			!list of all windows and controls

global function ctrlpressed = return (currmess.state iand kb_ctrl) end
global function shiftpressed = return (currmess.state iand kb_shift) end

proc start=
initdata()
mxinit()
initmenuhandlers()
end

proc initdata=
messagequeue:=new(list,100)
nmessages:=0

colourvalues[button_col]:=getsyscolour(colour_btnface)

colourvalues[window_col]:=getsyscolour(colour_window)
colourvalues[text_col]:=getsyscolour(colour_windowtext)

defstyle:=new(stylerec)
defstyle.border		:= bs_simplew
defstyle.justify	:= 'L'
defstyle.vjustify	:= 'M'
defstyle.textfgnd	:= black
defstyle.marktype	:= check_mark
defstyle.hilitetype	:= no_hilite
defstyle.windbgnd	:= button_col
defstyle.imark		:= 1

init_handlertables()
d:=gxchardim(labelfont)
chx:=d.x
chy:=d.y

d:=gxchardim(0,1)
cha:=d.x
chd:=d.y
arrowdim:=chy+2
markdim:=arrowdim-2

buttonheight:=chy+smy*2
listrowheight:=chy+smy*2
end

global function gxcreatewindow(?caption,?pos,?dim,?options,owner=nil)=		!CREATEWINDOW
#create a popup window which is not a child window.
#(nevertheless, it can have an owner window, such as the main window of the
#application)
#returns an rwindow handle
#caption	optional caption txt
#pos		(x,y) is pixel pos of top left corner in screen coordinates (of frame?)
#		"cent" to place centrally
#		omitted: use default placement
#dim		(width,height) overall pixel size
#		"max" maximised
#		"desktop" fill desktop screen
#		omitted: use (640,480)
#owner	optional owner window (default nil)
#options	option dict, default is [wf_caption:1, wf_border:wbs_resize]

hwnd:=wx_createpopup(caption,pos,dim,options,(owner|owner.gdi.hwnd|nil))


w:=newwindow(hwnd,0,no_class,bs_windows)

if wapplic=nil then
	wapplic:=w
fi

W.STYLE:=NEW(STYLEREC)
W.STYLE.BORDER:=0
W.WINDCLASS:=WINDOW_CLASS
W.STYLE.WINDBGND:=WINDOW_COL
W.ENABLE:=1
W.FLAGS.[WA_LEFTDRAG]:=1
W.FLAGS.[WA_LEFTDBL]:=1

setwindowdims_w(w,hwnd)
setupgdi(w,hwnd)
gxfont(w,1)

GXDRAWMODE(W,DM_SCREENMEMORY)
GXCLEAR(W)

return w
end

proc setwindowdims_w(w,hwnd)=			!SETWINDOWDIMS

box:=new(ws_rect)
getwindowrect(hwnd,&box)
w.frameposx:=box.x
w.frameposy:=box.y
w.framedimx:=box.x2-box.x
w.framedimy:=box.y2-box.y

getclientrect(hwnd,&box)
w.dimx:=box.x2-box.x
w.dimy:=box.y2-box.y

pt:=ws_point(0,0)
clienttoscreen(hwnd,&pt)		!pos starts at 0,0
w.posx:=pt.x
w.posy:=pt.y
end

proc setwindowdims_c(w,hwnd)=			!SETWINDOWDIMS


box:=new(ws_rect)
getwindowrect(hwnd,&box)			!client dims also Windows frame dims as has no Windows border
w.posx:=box.x-w.owner.posx
w.posy:=box.y-w.owner.posy
w.dimx:=box.x2-box.x
w.dimy:=box.y2-box.y

widths:=bswidths[w.style.border]
if bscat[w.style.border]='I' then widths:=ws_rect(0,0,0,0) fi

w.frameposx:=w.posx-widths.x1
w.frameposy:=w.posy-widths.y1
w.framedimx:=w.dimx+widths.x1+widths.x2
w.framedimy:=w.dimy+widths.y1+widths.y2
end

global proc gxclear(w,?colour)=			!GXCLEAR
#fill window w with <colour>, or with current background if omitted

gdi:=w.gdi
gdi.updated:=1

gxcolour(w,getrgb(black))
gxstyle(w,0)

if colour.isvoid then
	colour:=getrgb(w.style.windbgnd)
fi

oldpenstyle:=gdi.penstyle
oldbrushstyle:=gdi.brushstyle

gxbrushstyle(w,bs_solid)
gxstyle(w,ps_null)

gxfillrect(w,0,0,w.dimx,w.dimy,colour)
gxbrushstyle(w,oldbrushstyle)
gxstyle(w,oldpenstyle)
end

global function gxstyle(w,?style)=			!GXSTYLE
#style omitted: get pen current pen style
#style supplied: set pen style for subsequent line drawing
#Style is a char code or int refering to a small variety of Windows dotted styles:
#	0 S |		Solid
#	Space		Null (pen up?)
#	-			Dotted
#	:			Dashdotdot
#	!			Dashdotd
#	F			Inside frame

gdi:=w.gdi

if style.isdef and gdi.penstyle<>style then
	case style
	when '!' then style:=ps_dashdot
	when ':' then style:=ps_dashdotdot
	when '-' then style:=ps_dot
	when ' ' then style:=ps_null
	when 'D' then style:=ps_alternate
	when '|','S',0 then style:=ps_solid
	when 'F' then style:=ps_insideframe
	esac

	gdi.penstyle:=style
	if style>=10 then style:=ps_dot fi
	deleteobject(selectobject(gdi.hdc,createpen(style,gdi.penwidth,gdi.pencolour)))
	if gdi.drawmode=dm_screenmemory then
		deleteobject(selectobject(gdi.hdc2,createpen(style,gdi.penwidth,gdi.pencolour)))
	fi
fi
return gdi.penstyle
end

global proc gxbrushstyle(w,?style,?pattern)=		!GXBRUSHSTYLE
#Set Windows brush style and pattern
#Style supplied:	set style
#pattern supplied:	set style
#style is:		S, H, Space, B for Solid, Hatched, Null, DIB
#pattern is:	- | \ / + x/X for Hoz, Vert, Diag, Fwd Diag, Cross, Diag Cross

gdi:=w.gdi
brush:=new(ws_logbrush)

if style.isdef then
	if style<>gdi.brushstyle then
		case style
		when 'S' then style:=bs_solid
		when 'H' then style:=bs_hatched
		when ' ' then style:=bs_null
		when 'B' then style:=bs_dibpattern
		esac

		gdi.brushstyle:=style
	fi
	gdi.brushpattern:=0		!default to no pattern, will be changed by pattern if supplied
fi

if pattern.isdef and pattern<>gdi.brushpattern then
	case pattern
	when '-' then pattern:=hs_horizontal
	when '|' then pattern:=hs_vertical
	when '\\' then pattern:=hs_fdiagonal
	when '/' then pattern:=hs_bdiagonal
	when '+' then pattern:=hs_cross
	when 'x','X' then pattern:=hs_diagcross
	esac
	gdi.brushpattern:=pattern
fi

brush.lbstyle:=gdi.brushstyle
brush.lbcolour:=gdi.brushcolour
brush.lbhatch:=gdi.brushpattern

deleteobject(selectobject(gdi.hdc,createbrushindirect(&brush)))
if gdi.drawmode=dm_screenmemory then
	deleteobject(x:=selectobject(gdi.hdc2,createbrushindirect(&brush)))
fi
end

global function gxbrushcolour(w,?colour)=			!GXBRUSHCOLOUR
#colour supplied:	set current fill colour
#colour omitted:	return current fill colour

gdi:=w.gdi

if colour.isdef and colour<>gdi.brushcolour then
	gdi.brushcolour:=colour
	brush:=new(ws_logbrush)
	brush.lbstyle:=gdi.brushstyle
	brush.lbcolour:=colour
	brush.lbhatch:=gdi.brushpattern

	deleteobject(selectobject(gdi.hdc,createbrushindirect(&brush)))
	if gdi.drawmode=dm_screenmemory then
		deleteobject(selectobject(gdi.hdc2,createbrushindirect(&brush)))
	fi
fi
return gdi.brushcolour
end

global proc gxfillrect(w,x,y,width,height,?colour,mode=0)=		!GXFILLRECT
#Draw filled rectangle with optional outline
#x,y are top-left coordinates
#width, height are overall pixel dimensions, inclusive; they include any outline
#(When the outline is drawn, the filled region is 1 pixel smaller all round)
#colour is the colour of the filled region (current brush colour when omitted)
#mode=1 to draw the outline, or mode=0 (default) to omit it
#The outline is drawn in the current pen colour

gdi:=w.gdi
gdi.updated:=1

oldbrushcolour:=gdi.brushcolour
if colour.isdef then
	gxbrushcolour(w,colour)
fi

oldpenstyle:=gdi.penstyle
if mode=0 then		!inside only
	gxstyle(w,ps_null)
fi

if height<0 then y:=y+height+1; height:=-height fi
if width<0 then x:=x+w+1; width:=-width fi

if mode=0 then		!inside only, needs extra pixel width
	rectangle(gdi.hdc,x, y,x+width+1,y+height+1)
	if gdi.drawmode=dm_screenmemory then
		rectangle(gdi.hdc2,x,y,x+width+1,y+height+1)
	fi
else			!inside and outside
	rectangle(gdi.hdc,x, y, x+width, y+height)
	if gdi.drawmode=dm_screenmemory then
		rectangle(gdi.hdc2,x,y,x+width,y+height)
	fi
fi
gxstyle(w,oldpenstyle)
gxbrushcolour(w,oldbrushcolour)
end

global function gxcolour(w,?colour)=		!GXCOLOUR
# colour supplied:	set current outline colour for subsequent line drawing
# colour omitted:	return current outline colour

gdi:=w.gdi

if colour.isdef and gdi.pencolour<>colour then
	gdi.pencolour:=colour
	gdi.xormode:=0
	deleteobject(selectobject(gdi.hdc,createpen(gdi.penstyle,gdi.penwidth,gdi.pencolour)))
	setrop2(gdi.hdc,r2_copypen)
	if gdi.drawmode=dm_screenmemory then
		deleteobject(selectobject(gdi.hdc2,createpen(gdi.penstyle,gdi.penwidth,gdi.pencolour)))
		setrop2(gdi.hdc2,r2_copypen)
	fi

fi

return gdi.pencolour
end

global proc gxsetpen(w,pen)=
gxcolour(w,getrgb(pen))
end

global proc gxline(w,x,y,?x2,?y2)=		!GXLINE
#gxline(w,x,y)			Draw line from current position to x,y
#gxline(w,x,y,x2,y2)	Draw line from x,y to x2,y2

gdi:=w.gdi

if x2.isvoid then		!assume 2 params
	x2:=x
	y2:=y

	movetoex(gdi.hdc,gdi.posx, gdi.posy)
	if gdi.drawmode=dm_screenmemory then
		movetoex(gdi.hdc2,gdi.posx, gdi.posy)
	fi
else
	movetoex(gdi.hdc,x, y)
	if gdi.drawmode=dm_screenmemory then
		movetoex(gdi.hdc2,x, y)
	fi
	gdi.posx:=x
	gdi.posy:=y
fi
lineto(gdi.hdc,x2,y2)
if gdi.drawmode=dm_screenmemory then
	lineto(gdi.hdc2,x2,y2)
fi
gdi.posx:=x2
gdi.posy:=y2
end

global function gxwidth(w,width)=
gdi:=w.gdi
if width.isvoid then
	return gdi.penwidth
fi

if gdi.penwidth<>width then
	gdi.penwidth:=width
	deleteobject(selectobject(gdi.hdc,createpen(gdi.penstyle,gdi.penwidth,gdi.pencolour)))
	if gdi.drawmode=dm_screenmemory then
		deleteobject(selectobject(gdi.hdc2,createpen(gdi.penstyle,gdi.penwidth,gdi.pencolour)))
	fi

fi
return width
END

global proc gxlinerel(w,dx,dy)=		!GXLINEREL
#Draw line from current position, to current position + (dx,dy)

gdi:=w.gdi
movetoex(gdi.hdc, gdi.posx, gdi.posy)
if gdi.drawmode=dm_screenmemory then
	movetoex(gdi.hdc2, gdi.posx, gdi.posy)
fi
x:=gdi.posx+dx
y:=gdi.posy+dy
gxline(w,x,y)
gdi.posx:=x
gdi.posy:=y
end

global proc gxmove(w,x2,y2)=		!GXMOVE
#Set current position to x2,y2

gdi:=w.gdi

movetoex(gdi.hdc, x2, y2)
if gdi.drawmode=dm_screenmemory then
	movetoex(gdi.hdc2,x2, y2)
fi
gdi.posx:=x2
gdi.posy:=y2
end

global proc gxmoverel(w,dx,dy)=		!GXMOVEREL
#	Set current position to current position+(dx,dy)
gdi:=w.gdi

gdi.posx+:=dx
gdi.posy+:=dy

movetoex(gdi.hdc,gdi.posx, gdi.posy)
if gdi.drawmode=dm_screenmemory then
	movetoex(gdi.hdc2,gdi.posx, gdi.posy)
fi
end

global proc gxrect(w,x,y,width,height)=		!GXRECT
#draw outline rectangle starting from x,y at top left, in current pen colour
#overall size is width by height pixels inclusive (x,y to x+width+1,y+height-1)
#outline is 1 pixel wide

gdi:=w.gdi
gdi.updated:=1
if height<0 then y:=y+height+1; height:=-height fi
if width<0 then x:=x+width+1; width:=-width fi

oldbrushstyle:=gdi.brushstyle
gxbrushstyle(w,bs_hollow)

rectangle(gdi.hdc,x, y, x+width, y+height)
if gdi.drawmode=dm_screenmemory then
	rectangle(gdi.hdc2,x, y, x+width,y+height)
fi
gxbrushstyle(w,oldbrushstyle)
end

global proc gxcircle(w,x,y,r)=		!GXCIRCLE
#draw circle at centre x,y in window w, of radius r, using current pen colour
#outline is 1 pixel wide

gdi:=w.gdi
gdi.updated:=1
oldbrushstyle:=gdi.brushstyle
gxbrushstyle(w,bs_hollow)

ellipse(gdi.hdc,x-r, y-r, x+r-1, y+r-1)
if gdi.drawmode=dm_screenmemory then
	ellipse(gdi.hdc2,x-r, y-r, x+r-1, y+r-1)
fi
gxbrushstyle(w,oldbrushstyle)
end

global proc gxellipse(w,x,y,r,r2)=

gdi:=w.gdi
gdi.updated:=1
oldbrushstyle:=gdi.brushstyle
gxbrushstyle(w,bs_hollow)

ellipse(gdi.hdc,x-r, y-r2, x+r-1, y+r2-1)
if gdi.drawmode=dm_screenmemory then
	ellipse(gdi.hdc2,x-r, y-r2, x+r2-1, y+r2-1)
fi
gxbrushstyle(w,oldbrushstyle)
end

global proc gxfillcircle(w,x,y,r,?colour,mode=0)=		!GXFILLCIRCLE
#Draw filled circle with optional outline
#x,y is the centre, r is the radius
#(When the outline is drawn, the filled region is 1 pixel smaller all round)
#colour is the colour of the filled region (current brush colour when omitted)
#mode=1 to draw the outline, or mode=0 (default) to omit it
#The outline is drawn in the current pen colour
gdi:=w.gdi

gdi.updated:=1
oldbrushcolour:=gdi.brushcolour
if colour.isdef then
	gxbrushcolour(w,colour)
fi

oldpenstyle:=gdi.penstyle
if mode=0 then		!inside only
	gxstyle(w,ps_null)
fi

ellipse(gdi.hdc,x-r, y-r, x+r-1, y+r-1)
if gdi.drawmode=dm_screenmemory then
	ellipse(gdi.hdc2,x-r, y-r, x+r-1, y+r-1)
fi

gxstyle(w,oldpenstyle)
gxbrushcolour(w,oldbrushcolour)
end

global function gxpixel(w,x,y,?colour)=		!GXPIXEL
#colour provided: set pixel at point x,y of window w to colour
#colour omitted: return pixel colour from point x,y
w.gdi.updated:=1

if colour.isvoid then		!get pixel
	res:=getpixel(w.gdi.hdc, x, y)
	if w.gdi.drawmode=dm_screenmemory then
		getpixel(w.gdi.hdc2, x, y)
	fi
	return res
else
	setpixel(w.gdi.hdc,x, y, colour)
	if w.gdi.drawmode=dm_screenmemory then
		setpixel(w.gdi.hdc2,x,y,colour)
	fi
	return colour
fi
end

global function gxcaption(w,?caption)=		!GXCAPTION
#caption omitted:  return current window caption text
#caption provided: set new window caption text

case w.windclass
when window_class,popup_class then

	if caption.isdef then		!set text
		setwindowtext(w.gdi.hwnd,caption)
		return caption
	else
		buffer:=new(array,byte,512)
		n:=getwindowtext(w.gdi.hwnd,int(&buffer),buffer.len)
		if n then
			s:=makestr(&buffer,n)		!needs assigment to ensure a copy is made befor buffer
										!is freed (assignment of return value might do the same)
		else
			s:=""
		fi
		return s
	fi
esac

if caption.isdef then		!set text
	w.text:=caption
	gxdraw(w)
fi

return w.text
end

global proc gxtext(w,s,?x,?y)=		!GXTEXT
#Display text s
#Text is drawn starting at (x,y) when provided, otherwise at current position
#insertion point refers either to base line, or to top left of cell (not sure)
#Text is drawn in current font, size, style and mode
#Text typically contains no control codes, but can also contain cr and lf (also
#tabs, but currently position isn't changed). However, text with control codes is
#drawn a character at a time
#Finishes with current position set to the end of the text


return when s=""

gdi:=w.gdi

if x.isvoid then x:=gdi.posx fi
if y.isvoid then y:=gdi.posy fi
gdi.updated:=1

startpos:=lengths:=()
ngroups:=0

foreach i,c in s do
	if c<32 then
		++ngroups
		startpos[ngroups]:=i
		lengths[ngroups]:=0
	else
		if ngroups and lengths[ngroups] then		!extend this group
			++lengths[ngroups]
		else										!start new substring group
			++ngroups
			startpos[ngroups]:=i
			lengths[ngroups]:=1
		fi
	fi
od

forall i,l in lengths do
	pos:=startpos[i]
	if l then
		slice:=pos..pos+l-1
		textout(gdi.hdc,x, y,s.[slice],l)

		if gdi.drawmode=dm_screenmemory then
			textout(gdi.hdc2,x,y,s.[slice],l)
		fi
		x +:= gxtextwidth(w,s.[slice])

	else				!Deal with control codes
		case s.[pos]
		when 13 then
			x:=0
		when 10 then
			y+:=20				!NEEDS TO PICK CURRENT FONT DIMS

		when 9,16 then			!16 will be used as reverse tab
			currx:=x
			x:=0
			forall t in tabstops do
				x+:=t*chx				!MUST BE CURRENT FONT NOT CHX
				if x>currx then exit fi
			od
			while x<=currx do x+:=chx*8 od

			if s.[pos]=16 and i<ngroups and lengths[i+1] then	!reverse offset for next substring
				pos:=startpos[i+1]
				x -:= gxtextwidth(w,s.[pos..pos+lengths[i+1]-1])+1
			fi

		esac	
	fi
od

gdi.posx:=x
gdi.posy:=y
end

global function gxtextcolour(w,?colour,?bgndcolour)=		!GXTEXTCOLOUR
#Set either text foreground colour or background colour, or both, or neither,
#depending on which are supplied
#Text colours will be colour indices, not rgb
#Always returned current or new foreground

gdi:=w.gdi

if colour.isdef and colour<>w.style.textfgnd then
	w.style.textfgnd:=colour
	settextcolour(gdi.hdc,getrgb(colour))
	if gdi.drawmode=dm_screenmemory then
		settextcolour(gdi.hdc2,getrgb(colour))
	fi
fi
if bgndcolour.isdef and bgndcolour<>w.style.textbgnd then
	gxbgndcolour(w,bgndcolour)
fi

return w.style.textfgnd
end

global function gxtextwidth(font,?s)=		!GXTEXTWIDTH
# font is a window, or a font number within fonttable
# font can be zero (then uses font 1)
# return total pixel width of string s, using given font

if s="" then return 0 fi

if not font.isint then			!aasume font is window
	font:=font.gdi.font
fi
if font=0 then font:=1 fi

selectobject(screendc,fonttable[font])
widthheight:=new(ws_point)

gettextextentpoint32(screendc,s,s.len,&widthheight)

return widthheight.x
end

global function gxloadfont(n,facename,?style,height=0,width=0)=		!GXLOADFONT
#define new font
#N is index into fonttable
#facename is the name of the font
#Style is optional font style, a string containing any of:
#	B,b		Bold
#	I,i		Italic
#	U,u		Underline
#	S,s		Strikeout
#Height is height of text (default 0, gives default height?)
#Weight is width; defautl 0 normally used for normal aspect of text

if n<=0 then return 0 fi

if style.isvoid then style:="" fi

if n<=nglobalfonts and fonttable[n] then			!remove existing font
	igxremovefont(n)
fi

p:=style
bold:=400
italic:=0
underline:=0
strikeout:=0
forall c in style do
	case asc(convuc(c))
	when 'B' then bold:=700
	when 'I' then italic:=1
	when 'U' then underline:=1
	when 'S' then strikeout:=1
	esac
od

hfont:=createfont(
	facename:	facename,
	height:		height,
	width:		width,
	bold:		bold,
	italic:		italic,
	underline:	underline,
	charset:	0,
	quality:	2,
	escapement:	0,
	orientation:0)

if hfont=0 then
	hfont:=getstockobject(system_font)
fi

fonttable[n]:=hfont
nglobalfonts:=max(n,nglobalfonts)

selectobject(screendc,fonttable[n])

tm:=new(ws_textmetrics)

gettextmetrics(screendc,&tm)
fontdimtable[n]:=ws_point(tm.avecharwidth, tm.height+tm.externalleading)

fontvdimtable[n]:=ws_point(tm.ascent, tm.descent)

selectobject(screendc,getstockobject(system_font))

return n
end

proc igxremovefont(n)=

unless n in 1..nglobalfonts then return end
if fonttable[n]=0 then return fi	!already freed


deleteobject(fonttable[n])		!get rid of this font
fonttable[n]:=0
end

global function gxfont(w,font=1)=		!GXFONT
# select font from font table for subsequent text display; default is font 1

if not w then w:=wapplic fi
if not w then w:=wscreen fi
gdi:=w.gdi

if font.isdef and font<>gdi.font then
	if font not in 1..nglobalfonts then
		abort("Bad font number "+tostr(font))
	fi
	gdi.font:=font
	if fonttable[font]=0 then
		abort("Font not in use "+tostr(font))
	fi

	oldhfont:=selectobject(gdi.hdc,fonttable[font])
	sendmessage(gdi.hwnd,wm_setfont,fonttable[font],0)

	if gdi.drawmode=dm_screenmemory then
		oldhfont:=selectobject(gdi.hdc2,fonttable[font])
		sendmessage(gdi.hwnd2,wm_setfont,fonttable[font],0)
	fi
	if fontdimtable[font].x=0 then		!set up dims
		gxchardim(font,0)
	fi
fi
return gdi.font
end

function hascontrolchars(s)=		!TESTCTRLCHAR

foreach c in s do
	if c<32 then return 1 fi
od
return 0
end

global function gxchardim(font,vert=0)=			!GXCHARDIM
#return font char average width/height info as a point rec
#wfont is a font number, or hwindow when the current font in that window is used
#vert=1 means get ascent/descent pair instead of (vert=0) average width/height

if not font.isint then
	font:=font.gdi.font
fi
if font=0 then font:=1 fi

if fontdimtable[font].x=0 then		!probably stock fonts not setup with gxloadfont
	selectobject(screendc,fonttable[font])
	tm:=new(ws_textmetrics)
	gettextmetrics(screendc,&tm)

	fontdimtable[font]:=ws_point(tm.avecharwidth, tm.height+tm.externalleading)
	fontvdimtable[font]:=ws_point(tm.ascent, fontvdimtable[font].y:=tm.descent)

	selectobject(screendc,getstockobject(ansi_var_font))
fi

if vert then
	return fontvdimtable[font]
fi

return fontdimtable[font]
END

global function gxbgndcolour(w,?colour)=		!GXBGNDCOLOUR
#Set background colour (for text mainly)
#colour will be a colour index
#return current colour when omitted
gdi:=w.gdi

if colour.isdef then

	if colour<>w.style.textbgnd then
		w.style.textbgnd:=colour
W.STYLE.WINDBGND:=COLOUR
		setbkcolour(gdi.hdc,getrgb(colour))
		if gdi.drawmode=dm_screenmemory then
			setbkcolour(gdi.hdc2,getrgb(colour))
		fi
	fi
	gxbgndmode(w,(colour<>w.style.windbgnd|1|0))
fi
return w.style.textbgnd
end

global function gxbgndmode(w,?mode)=		!GXBGNDMODE
#	mode supplied: set new background mode:
#		1 y Y T		Set opaque (T for True? Looks like Transparent)
#		0 n N F		Set Transparent

gdi:=w.gdi

if mode.isdef  then
	case mode
	when 1,'y','Y','T' then
		w.style.bgndmode:=opaque
	else
		w.style.bgndmode:=transparent
	esac

	setbkmode(gdi.hdc,mode+1)
	if gdi.drawmode=dm_screenmemory then
		setbkmode(gdi.hdc2,mode+1)
	fi
fi
return w.style.bgndmode
end

global proc gxhighlight(w,x,y,width,height)=		!GXHIGHLIGHT
#Invert rectangular region
const dstinvert=0x00550009	!patblt
gdi:=w.gdi

gdi.updated:=1
patblt(gdi.hdc, x, y, width,height,dstinvert)
if gdi.drawmode=dm_screenmemory then
	patblt(gdi.hdc2, x,y, width,height,dstinvert)
fi
end

global proc gxbitblt(w,x2,y2,width,height,x,y)=			!GXBITBLT
#Copy rectangular region of window to another location
gdi:=w.gdi
gdi.updated:=1
bitblt(gdi.hdc, x2, y2, width,height,
			gdi.hdc,x,y,srccopy)

if gdi.drawmode=dm_screenmemory then
	bitblt(gdi.hdc2,x2,y2,width,height,gdi.hdc2,x,y,srccopy)
fi
end

global function gxaskmess(mode=0)=
#wait for next message and return message number
#return 0 if close or quit message seen
#some messages will be ignored here (processsed via procmess) and will wait for next
#mode=0		Return currmess.message
#mode=1		Return currmess.message, but if a mm_command message, then return
#			the command id. This means message numbers and command ids share the
#			same space. This should work because messages are below 200, and ids above 200

repeat
	if mxwait_mm_message()=0 then
		return 0
	fi
	if quitmess then return 0 fi
	x:=process_message(currmess)

	if currmess.message=mm_key and currmess.a=27 then
		return 0
	fi

until x=thismess					!message ready to return

if mode=1 and currmess.message=mm_command then
	return currmess.a
fi

return currmess.message
end

function process_message(mess)=
#user or default event processing for mm message
#will call event handler if there is one
#returns 1 (skipmess) if message has been processed here; caller must wait for another message
#returns 0 (thismess) caller should deal with this message (it has not been processed, or has beenbut caller can process it too)

if mess.wind=nil then
	return thismess
fi

case mess.message
when mm_close then
	return thismess
esac

status:=domessage(mess)

return status
end

global proc docs=
#Option dicts: used as args to gccreatewindow/gxcreatechildwindow:
#	wf_border		Border style; see wbs_ enums
#	wf_resize		1 for resizable border (for top-level windows)
# wf_hscroll		1 for horizontal scrollbar
# wf_vscroll		1 for vertical scrollbar
# wf_menu			1 for a menubar
# wf_caption		1 for a caption bar (needs to be the right kind of border too)
# wf_max			1 for a max button
# wf_minmax		1 for a min/max buttons
# wf_sysmenu		1 for a system menu (right-click on top left I think)
# wf_desktop		1 to fill desktop
# wf_clip			1 to clip windows to desktop
# wf_show			1 to show window after creating
# wf_iframe		1 for pos/dim to refer to frame rather than client area
# wf_cent			1 to centre window
# wf_toolwind		1 for tool window (not sure what this means)

end

function newwindow(hwnd,index,windclass,borderstyle)=

w:=new(rwindow,0)
w.windclass:=windclass
w.index:=index
w.childlist:=()

addwindow(w)
wx_setw(hwnd,w.gindex)
return w
end

global function getrgb(index)=
if index=0 then return 0 fi
return colourvalues[index]
end

function readstyle(owner,windclass,options)=

if options.type=stylerec then			!already a stylerec
	return options
fi

ss:=new(stylerec)
if options.isvoid then				!use bunch of defaults
	d::=defstyle
	d.border:=defaultborderstyles[windclass]
	return d
fi

ss.border	:=options{ss_border,defaultborderstyles[windclass]}
ss.justify	:=options{ss_justify,defstyle.justify}
ss.vjustify	:=options{ss_vjustify,defstyle.vjustify}
ss.textfgnd	:=options{ss_textfgnd,defstyle.textfgnd}
ss.textbgnd	:=options{ss_textbgnd,defstyle.textbgnd}
ss.bgndmode	:=options{ss_bgndmode,defstyle.bgndmode}

ss.iframe	:=options{ss_iframe,0}
ss.hilitetype	:=options{ss_hilitetype,defstyle.hilitetype}
ss.marktype	:=options{ss_marktype,(ss.hilitetype|0|defstyle.marktype)}
ss.imark	:=options{ss_imark,defstyle.imark}

if windclass in [toggle_class, select_class,mark_class] and ss.marktype then
	def:=owner.style.windbgnd
else
	def:=defstyle.windbgnd
fi

ss.windbgnd	:=options{ss_windbgnd,def}
ss.hscroll	:=options{ss_hscroll,0}
ss.vscroll	:=options{ss_vscroll,0}
ss.lbchange	:=options{ss_lbchange,0}
ss.returnmess	:=options{ss_returnmess,0}
ss.noupdate	:=options{ss_noupdate,0}

return ss
end

global function gxpanel(owner,pos,dim,?style)=
ss:=readstyle(owner,panel_class,style)

w:=gxcontrol(owner,panel_class,pos,dim,ss)

gxdraw(w)

return w
end

global function gxstatusbar(owner,pos,dim,?style)=

ss:=readstyle(owner,statusbar_class,style)

if ss.iframe=0 then					!frame not included, but can't have it leaking outside owner
	bs:=ss.border
	if bscat[bs]<>'I' then			!do adjustments
		dim+:=bswidths[bs].y1+bswidths[bs].y2
	fi
	ss.iframe:=1					!stop gxcontrol expanding dims
fi

(ecapos,ecadim):=gxclientarea(owner)

if pos.isint then pos:=chr(pos) fi
if convuc(pos) in "T TOP" then			!along the top
	pos:=ecapos
	dir:='T'
else									!along the bottom
	pos:=(ecapos[1],ecadim[2]-dim+ecapos[2])
	dir:='B'
fi
dim:=(ecadim[1],dim)

ss.dir:=dir

w:=gxcontrol(owner,statusbar_class,pos,dim,ss)

gxdraw(w)

return w
end

global function gxframebar(owner,pos,dim,?style)=

ss:=readstyle(owner,framebar_class,style)
if ss.iframe=0 then					!frame not included, but can't have it leaking outside owner
	bs:=ss.border
	if bscat[bs]<>'I' then			!do adjustments
		dim+:=bswidths[bs].y1+bswidths[bs].y2
	fi
	ss.iframe:=1					!stop gxcontrol expanding dims
fi

(ecapos,ecadim):=gxclientarea(owner)

if pos.isint then pos:=chr(pos) fi
if convuc(pos) in "L LEFT" then			!along the left
	pos:=ecapos
	dir:='L'
else									!along the right
	pos:=(ecadim[1]-dim+ecapos[1],ecapos[2])
	dir:='R'
fi
dim:=(dim,ecadim[2])

ss.dir:=dir

w:=gxcontrol(owner,	framebar_class,pos,dim,ss)

gxdraw(w)

return w
end

global function gxbutton(owner,pos,dim,caption,?style,id=201,enable=1)=
#create clickable button
#returns rwindow

ss:=readstyle(owner,button_class,style)

w:=gxcontrol(owner,button_class,pos,dim,ss)
w.id:=id

w.text:=caption
w.enable:=enable
gxdraw(w)

return w
end

global function gxlabel(owner,pos,dim,caption,?style)=
#create static label button
#returns rwindow

ss:=readstyle(owner,label_class,style)

w:=gxcontrol(owner,label_class,pos,dim,ss)

w.text:=caption
gxdraw(w)

return w
end

global function gxgroup(owner,pos,dim,?style)=
#create group window that encapsulates a set of controls
#returns rwindow

ss:=readstyle(owner,group_class,style)

w:=gxcontrol(owner,group_class,pos,dim,ss)

gxdraw(w)

return w
end

function gxcontrol(owner,windclass=button_class,pos,dim,?ss)=

if ss.type=dict or ss.isvoid then
	ss:=readstyle(owner,windclass,ss)
fi
wb:=wbs_none
case ss.border			!find wbs- version of windows-drawn borders
when bs_simplew then
	wb:=wbs_simple
esac

if ss.iframe and bscat[ss.border]<>'I' then
	widths:=bswidths[ss.border]
	pos[1]+:=widths.x1
	pos[2]+:=widths.y1
	dim[1]-:=widths.x1+widths.x2
	dim[2]-:=widths.y1+widths.y2
FI

hwnd:=wx_createcontrol(pos:pos,dim:dim,border:wb,owner:owner.gdi.hwnd)

if hwnd=0 then
	abort("Can't create control window")
fi

w:=newwindow(hwnd,0,no_class,ss.border)
w.windclass:=windclass
w.style:=ss
w.owner:=owner
w.enable:=1

setwindowdims_c(w,hwnd)
setupgdi(w,hwnd)

gxdrawmode(w,dm_screenmemory)

gxfont(w,labelfont)

gxtextcolour(w,w.style.textfgnd,w.style.textbgnd)

gxbgndmode(w,w.style.bgndmode)

w.owner.childlist append:=w
w.index:=w.owner.childlist.upb

return w
end

global function gxtoggle(owner,pos,dim,caption="",linkvar,?style,id=201,enable=1)=

(posx,posy):=pos
(dimx,dimy):=dim
textoffset:=0

ss:=readstyle(owner,toggle_class,style)


if ss.marktype then
	if ss.imark=0 then			!dims don't include the mark
		posx-:=markdim
		dimx+:=markdim
		textoffset:=markdim
	fi
fi

w:=gxcontrol(owner,toggle_class,(posx,posy),(dimx,dimy),ss)
w.linkvar:=linkvar
w.id:=id
w.text:=caption
w.attrs:=togglerec(textoffset,1)
w.enable:=enable

if w.style.marktype then
	gxmark(owner:w,pos:(0,(w.dimy-markdim)%2),id:id, style:ss)
fi

gxdraw(w)
return w
end

global function gxselect(owner,pos,dim,caption="",linkvar,onvalue,?style,id=201,enable=1)=

(posx,posy):=pos
(dimx,dimy):=dim
textoffset:=0

ss:=readstyle(owner,select_class,style)

if ss.marktype and ss.imark=0 then			!dims don't include the mark
	posx-:=markdim
	dimx+:=markdim
	textoffset:=markdim
fi

w:=gxcontrol(owner,select_class,(posx,posy),(dimx,dimy),ss)

w.linkvar:=linkvar
w.id:=id
w.text:=caption
w.attrs:=togglerec(textoffset,onvalue)
w.enable:=enable
if w.style.marktype then
	gxmark(owner:w,pos:(0,(w.dimy-markdim)%2),id:id, style:style)
fi

gxdraw(w)
return w
end

global proc showmessage(mess)=
CPL MESS.MESSAGE
cp "Message:",leftstr(messagenames[mess.message],20)
cp "A:",,mess.a,"B:",,mess.b
cp " (X:",,mess.x,"Y:",,mess.y,,") Buttons:",mess.state:"b"

cpl "	Window:",mess.wind.name
end

function domessage(mess)=

m:=mess.message
w:=mess.wind

IF W.GDI=0 THEN PCERROR("DOM/GDI=0") FI

case m
when mm_move,mm_setcursor then
	return skipmess
when mm_timer then
	return thismess
esac

x:=messhandlertable[m,w.windclass]^(mess,w)

return x
end

proc init_handlertables=

messhandlertable::=new(list,mm_null..mm_last,new(list,no_class..dummy_class,0))

$pcldata('PROCINIT')
messalltable:=new(list,mm_null..mm_last,0)		!for all mess_mess_all handlers
fnallall:=nil									!for single mess_all_all handler
fnfixups:=nil

actionalltable:=new(list,1..last_w,0)
for i:=1 to last_w do
	actionhandlertable[i]:=(0:0,)*(dummy_class-no_class+1)
od

while data:=$pcldata('PROC') do
	if not data[2] then
		next
	fi
	fnptr:=data[4]
	(name,messname,windname):=splitstring(data[1],"_")			!split function name

	case leftstr(data[2],2)
	when "mx" then

		if messname="all" and windname="all" then
			fnallall:=fnptr
		else
			message:=("mm_"+messname) in messagenames
			if not message then
				ABORT("CAN'T FIND MESSAGE "+messname)
			fi
			if windname="all" then				!assume <mess> all
				messalltable[message]:=fnptr
			else
				btnnames:=splitstring(data[2]," ")	!(mx) or (mx,alt1,alt2 etc)
				btnnames[1]:=windname				!replace mx by name of primary window class
				forall wname in btnnames do
					windclass:=wname+"_class" in windowclassnames
					if windclass=0 then
						ABORT("CAN'T FIND WINDOW "+wname)
					fi
					messhandlertable[message,windclass]:=fnptr
				od
			fi
		fi

	when "wx" then
		action:=messname+"_w" in actionnames
		if not action then
			ABORT("CAN'T FIND ACTION "+MESSNAME)
		fi
		if windname="all" then
			actionalltable[action]:=fnptr
		else
			btnnames:=splitstring(data[2]," ")	!(mx) or (mx,alt1,alt2 etc)
			btnnames[1]:=windname				!replace mx by name of primary window class
			forall wname in btnnames do
				windclass:=wname+"_class" in windowclassnames
				if windclass=0 then
					ABORT("AX:CAN'T FIND WINDOW "+wname)
				fi
				actionhandlertable[action,windclass]:=fnptr
			od
		fi
	when "fx" then
		fnfixups:=fnptr
	esac
od

if fnfixups then
	fnfixups^()
fi

for mx:=0 to mm_last do
	for wx:=0 to dummy_class do
		if not messhandlertable[mx,wx] then
			messhandlertable[mx,wx]:=(messalltable[mx]|messalltable[mx]|fnallall)
		fi
	od
od

if not fnallall then
	pcerror("Can't find all/all mess handler")
fi

for ax:=1 to last_w do
	for wx:=0 to dummy_class do
		if not actionhandlertable[ax,wx] then
			if not actionalltable then
				pcerror("No DO/ALL handler for:"+actionnames[ax])
			fi
			actionhandlertable[ax,wx]:=actionalltable[ax]
		fi
	od
od

end

global proc gxdraw(w)=
fnptr:=actionhandlertable[draw_w,w.windclass]
if fnptr then
	fnptr^(w)
else
	cpl "NO DRAW HANDLER",windowclassnames[w.windclass],w.name
	waitsec(1)
	stop
fi
end

global proc gxupdate(w)=
fnptr:=actionhandlertable[update_w,w.windclass]
if fnptr then
	fnptr^(w)
else
	gxdraw(w)
fi
end

global proc eventloop=
do
	m:=gxaskmess()

	SHOWMESSAGE(CURRMESS)

	case m
	when 0,mm_cancel then
		return
	esac

od
end

global function gxeditbox(owner,pos,dim,linkvar,?style,id=201,enable=1)=

ss:=readstyle(owner,editbox_class,style)

w:=gxcontrol(owner,editbox_class,pos,dim,ss)

w.linkvar:=linkvar
w.id:=id
w.attrs:=new(editboxrec)
w.attrs.currpos:=linkvar^.len+1
w.enable:=enable
gxdraw(w)
return w
end

global proc gxebchange(w,?linkvar,charpos=-1)=

if linkvar.isdef then
	w.linkvar:=linkvar
fi

if charpos=-1 then
	w.attrs.currpos:=w.linkvar^.len+1
else
	w.attrs.currpos:=charpos
fi
gxupdate(w)
end

global proc gxsetlbdata(w,linkvar,?pos)=
w.linkvar:=linkvar
if pos.isvoid then
	pos:=(linkvar^|1|0)
fi
w.attrs.currpos:=pos

if w.childlist[1] then
	gxsetscrolllimits(ws,getlvbounds(linkvar),w.attrs.rows)
	gxscrollpos(ws,pos)
fi
end

global proc gxsetlbpos(w,pos)=
w.attrs.currpos:=pos

if pos then
	oldpagepos:=w.attrs.pagepos
	if pos<oldpagepos then
		w.attrs.pagepos:=pos
	elsif pos>oldpagepos+w.attrs.rows-1 then
		w.attrs.pagepos:=pos-w.attrs.rows+1
	fi
	if w.attrs.pagepos<>oldpagepos then
		if w.childlist then
			gxscrollpos(w.childlist[1],w.attrs.pagepos)
		fi
		m:=mm_draw
	else
		m:=mm_update
	fi
else
	m:=mm_draw
fi

postmess(w,m)
if w.style.lbchange then
	postmess(w,mm_lbchange,w.attrs.currpos)
fi
end

global proc gxsetlbpage(w,pagepos)=
w.attrs.pagepos:=pagepos

oldpos:=w.attrs.currpos
if oldpos<pagepos then
	w.attrs.currpos:=pagepos
elsif oldpos>=pagepos+w.attrs.rows then
	w.attrs.currpos:=pagepos+w.attrs.rows-1
fi

if w.childlist then
	gxscrollpos(w.childlist[1],pagepos)
fi

postmess(w,mm_draw)
if w.style.lbchange and oldpos<>w.attrs.currpos then
	postmess(w,mm_lbchange,w.attrs.currpos)
fi
end

global function gxlistbox(owner,pos,dim,linkvar,?style,id=201,rows=0,pitch=0,offset=0)=

ss:=readstyle(owner,listbox_class,style)

(dimx,dimy):=dim
if ss_vscroll and ss_imark=0 then			!dims don't include the scrollbar
	dimx+:=arrowdim
fi

w:=gxcontrol(owner,listbox_class,pos,(dimx,dimy),ss)
w.linkvar:=linkvar
w.id:=id
w.attrs:=new(listboxrec)

if pitch=0 then								!calculate all these here
	pitch:=listrowheight
	offset:=0
	rows:=w.dimy%pitch
fi
w.attrs.rows:=rows
w.attrs.pitch:=pitch
w.attrs.offset:=offset

w.attrs.pagepos:=1
w.attrs.currpos:=(getlvbounds(linkvar).len|1|0)

if w.style.vscroll then
	ws:=gxvertscrollbar(owner:w,pos:(w.dimx-arrowdim,0),dim:w.dimy,id:id,style:style)
	gxsetscrolllimits(ws,getlvbounds(linkvar),w.attrs.rows)

	gxscrollpos(ws,getlvbounds(linkvar).lwb)
fi

gxdraw(w)
return w
end

global function gxarrow(owner,pos,?dim,dir,?style,id=201)=

ss:=readstyle(owner,arrow_class,style)
if dim.isvoid then
	dim:=(arrowdim,arrowdim)
fi

w:=gxcontrol(owner,arrow_class,pos,dim,ss)
w.id:=id
if dir.isstring then dir:=asc(dir) fi
case dir					!allow compass bearings too, but convert to UDLR
when 'N' then dir:='U'
when 'E' then dir:='R'
when 'S' then dir:='D'
when 'W' then dir:='L'
esac

w.style.dir:=dir			!don't dir allow via style options
gxdraw(w)

return w
end

global proc gxsetscrolllimits(w,limits,span=0)=

w.attrs.span:=span
if w.style.dir='H' then
	width:=w.dimx
else
	width:=w.dimy
fi
m:=width-arrowdim*2				!number of pixels movement between arrows

if span=0 then						!pure scrolling control
	w.attrs.limits:=limits
	w.attrs.currpos:=limits.lwb
	w.attrs.thumbsize:=arrowdim
	enable:=limits.len>1
	w.attrs.thumbsize:=arrowdim*enable
else
	if limits.isrange then
		length:=limits.len
	else
		length:=limits
	fi
	if length<=span then
		enable:=0
		w.attrs.limits:=1..1
		w.attrs.thumbsize:=0
	else
		w.attrs.limits:=1..length-span+1
		enable:=1
		w.attrs.thumbsize:=max(10,int(m*(span/length)))
	fi
fi

w.attrs.currpos:=w.attrs.limits.lwb
w.enable:=enable

w.attrs.thumbspan:=m-w.attrs.thumbsize		!movement available to thumb
w.attrs.thumbpos:=arrowdim
postmess(w,mm_draw)
end

global function gxscrollpos(w,pos,u=0)=
if pos.isvoid then
	return w.attrs.currpos
fi

w.attrs.currpos:=pos
if pos not in w.attrs.limits then
	pcerror("Bad scroll pos")
fi

tpos:=int(w.attrs.thumbspan*((pos-w.attrs.limits.lwb)/(w.attrs.limits.len-1)))
w.attrs.thumbpos:=arrowdim+tpos

w.childlist[1].enable:=pos>w.attrs.limits.lwb
w.childlist[2].enable:=pos<w.attrs.limits.upb

if u then
	postmess(w,mm_update)
fi
return 0
end

global function gxhozscrollbar(owner,pos,dim,?style,id=201)=

ss:=readstyle(owner,scrollbar_class,style)
width:=arrowdim
if dim.isint then
	dim:=(dim,width)
else
	width:=dim[1]
fi

w:=gxcontrol(owner,scrollbar_class,pos,dim,ss)
w.id:=id
w.style.dir:='H'

w.attrs:=new(scrollbarrec)
w.flags.[wa_leftdrag]:=1

wa:=gxarrow(owner:w, pos:(0,0), dim:(width,width),dir:'L')
wb:=gxarrow(owner:w, pos:(dim[1]-width,0), dim:(width,width),dir:'R')

gxsetscrolllimits(w,1..200,20)
gxscrollpos(w,1)

gxdraw(w)

return w
end

global function gxvertscrollbar(owner,pos,dim,?style,id=201)=
ss:=readstyle(owner,scrollbar_class,style)
width:=arrowdim
if dim.isint then
	dim:=(width,dim)
else
	width:=dim[2]
fi

w:=gxcontrol(owner,scrollbar_class,pos,dim,ss)
w.id:=id
w.style.dir:='V'

w.attrs:=new(scrollbarrec)
w.flags.[wa_leftdrag]:=1

wa:=gxarrow(owner:w, pos:(0,0), dim:(width,width),dir:'U')
wb:=gxarrow(owner:w, pos:(0,dim[2]-width), dim:(width,width),dir:'D')
gxsetscrolllimits(w,100..200,2)

gxscrollpos(w,100)

gxdraw(w)

return w
end

global function gxmark(owner,pos,?dim,?style,id=201)=

ss:=readstyle(owner,mark_class,style)
if dim.isvoid then
	dim:=(markdim,markdim)
fi

w:=gxcontrol(owner,mark_class,pos,dim,style)
w.id:=id
gxdraw(w)

return w
end

global proc gxfocus(w)=
if wfocus==w then
	return
fi

if wfocus then
	domessage(makemess(wfocus,mm_killfocus))
fi
caretdrawn:=0
domessage(makemess(w,mm_setfocus))
end

global proc gxkillfocus=
if wfocus then
	drawcaret(0)
fi
wfocus:=nil
end

global function gxcopy(w,?bm,x=0,y=0,scalex=1.0,scaley=0,sx=0,sy=0,dimx=0,dimy=0)=		!GXCOPY

if bm.isvoid then
	bm:=w
	w:=nil
fi
if bm.isvoid then
	return nil
fi

if dimx=0 then dimx:=bm.dimx-sx fi
if dimy=0 then dimy:=bm.dimy-sy fi

if scalex=0 then scalex:=1.0 fi
if scaley=0 then scaley:=scalex fi

if w=nil then		!create appropriate window
	w:=gxcreatewindow(caption:"Bitmap "+tostr(bm.pixelbits)+" bit",pos:(500,500),
			dim:(bm.dimx*scalex,bm.dimy*scaley))
	w.gdi.drawmode:=dm_screenmemory			!default when using auto-window
fi

gdi:=w.gdi
gdi.updated:=1


mode:=copymode


setstretchbltmode(gdi.hdc,mode)
stretchblt(gdi.hdc, x, y,int(dimx*scalex),int(dimy*scaley),
											bm.gdi.hdc,sx,sy,dimx,dimy, srccopy)
if gdi.drawmode=dm_screenmemory then
	setstretchbltmode(gdi.hdc2,mode)
	stretchblt(gdi.hdc2,x,y,int(dimx*scalex),int(dimy*scaley),
											bm.gdi.hdc,sx,sy,dimx,dimy, srccopy)
fi
return w
end

global proc gxrestore(w,?r)=

if r.isvoid then
	x1:=y1:=0
	width:=w.dimx
	height:=w.dimy
else
	x1:=r.x1
	y1:=r.x2
	width:=r.x2-x1+1
	height:=r.y2-y1+1
fi

case w.gdi.drawmode
when dm_screen then			!can't restore; need to call gx_draw
	gxdraw(w)
when dm_screenmemory then
	destdc:=w.gdi.hdc
	sourcedc:=w.gdi.hdc2
when dm_memoryscreen then
	destdc:=w.gdi.hdc2
	sourcedc:=w.gdi.hdc
else
	abort("gxrest/?")
esac

bitblt(destdc,x1,y1, width,height, sourcedc, x1,y1, srccopy)

end

global function gxdrawmode(w,?drawmode)=

olddrawmode:=w.gdi.drawmode
if w.isvoid then
	return olddrawmode
fi

if olddrawmode=drawmode then		!already set
	return drawmode
elsif olddrawmode<>dm_screen then	!can only change screen => screenmemory/memoryscreen
	abort("gxdrawmode2")			!not memory to anything else
fi

memhwnd:=createcompatiblebitmap(screendc,w.dimx,w.dimy)
memhdc:=createcompatibledc(nil)
selectobject(memhdc,memhwnd)

case drawmode
when dm_screenmemory then
	w.gdi.hwnd2:=memhwnd
	w.gdi.hdc2:=memhdc
when dm_memoryscreen then
	w.gdi.hwnd2:=w.gdi.hwnd			!screen becomes secondary
	w.gdi.hdc2:=w.gdi.hdc
	w.gdi.hwnd:=memhwnd
	w.gdi.hdc:=memhdc
else
	abort("gxdrawmode?")
esac

w.gdi.drawmode:=drawmode
return drawmode
end

global proc switchdest(w)=
gdi:=w.gdi

case gdi.drawmode
when dm_screenmemory then
	t:=gdi.hwnd; gdi.hwnd:=gdi.hwnd2; gdi.hwnd2:=t
	t:=gdi.hdc; gdi.hdc:=gdi.hdc2; gdi.hdc2:=t
	gdi.drawmode:=dm_memory
when dm_memory then
	t:=gdi.hwnd; gdi.hwnd:=gdi.hwnd2; gdi.hwnd2:=t
	t:=gdi.hdc; gdi.hdc:=gdi.hdc2; gdi.hdc2:=t
	gdi.drawmode:=dm_screenmemory
esac
end

global proc gxclose(w)=

case w.windclass
when bitmap_class then
else
	if issubwindow(w,wfocus) then
		wfocus:=nil
	fi

	if issubwindow(w,wmouse) then	
		lastmousewindow:=nil
		wmouse:=nil
	fi

	destroywindow(w.gdi.hwnd)
	gxfreewindow(w)
esac
end

proc gxfreewindow(w)=
forall wc in w.childlist do
	gxfreewindow(wc)
od

removewindow(w)

w.gdi:=0
w:=0
end

global function gxmsgbox(message,caption="",options="")=

const mb_abortretryignore	= 0x02
const mb_applmodal			= 0x00
const mb_defbutton1			= 0x00
const mb_defbutton2			= 100
const mb_defbutton3			= 200
const mb_defbutton4			= 300
const mb_help				= 4000
const mb_iconasterisk		= 40
const mb_iconerror			= 10
const mb_iconexclamation	= 30
const mb_iconhand			= mb_iconerror
const mb_iconinformation	= mb_iconasterisk
const mb_iconquestion		= 20
const mb_iconstop			= mb_iconhand
const mb_iconwarning		= mb_iconexclamation
const mb_ok					= 0x00
const mb_okcancel			= 0x01
const mb_retrycancel		= 0x05
const mb_right				= 80000
const mb_setforeground		= 10000
const mb_systemmodal 		= 1000
const mb_taskmodal			= 2000
const mb_yesno				= 0x04
const mb_yesnocancel		= 0x03
const mb_topmost			= 0x040000

const idfail	= 0
const idok		= 1
const idcancel	= 2
const idabort	= 3
const idretry	= 4
const idignore	= 5
const idyes		= 6
const idno		= 7

static var rettable=(0:"fail","ok","cancel","abort","retry","ignore","yes","no",
		"","","tryagain","continue")

static var styletable=(
("bari",mb_abortretryignore),
("bo",mb_ok),
("boc",mb_okcancel),
("brc",mb_retrycancel),
("byn",mb_yesno),
("bync",mb_yesnocancel),
("ix",mb_iconexclamation),
("iw",mb_iconwarning),
("ii",mb_iconinformation),
("iq",mb_iconquestion),
("is",mb_iconstop),
("ie",mb_iconerror),
("ih",mb_iconhand),
("d1",mb_defbutton1),
("d2",mb_defbutton2),
("d3",mb_defbutton3),
("d4",mb_defbutton4),
("h",mb_help),
("rj",mb_right),
("sm",mb_systemmodal))

hwnd:=0

style:=0
optioncodes:=splitstring(options," ")

forall opt in optioncodes do
	for i to styletable.len do
		if styletable[i,1]=opt then style ior:=styletable[i,2] fi
	od
od

style ior:=0x10000

x:=messageboxa(hwnd,message,caption,style)
return rettable[x]
END


global proc gxhandler(windclass,mess,fnptr)=

if not windclass.isint then
	windclass:=windclass.windclass
fi

messhandlertable[mess,windclass]:=fnptr
end

global function gxaskfile(caption="File",filespec="*.*",deffile="",startdir="")=

save:=0
if caption='*' then
	save:=1
	caption:=rightstr(caption,-1)
fi

filters:=array(filespec+"@@@")		!turn into a byte-array

forall i,bb in filters do			!convert all @ into embedded zeros
	if bb='@' then filters[i]:=0 fi
od


ofn:=new((iswin32|ws_openfilename32|ws_openfilename64))

ofn.structsize:=ofn.bytes
ofn.owner:=wapplic.gdi.hwnd
ofn.instance:=getmodulehandle(0)
ofn.filter:=int(&filters)
ofn.flags:=ofn_explorer ior ofn_nochangedir ior ofn_hidereadonly !IOR OFN_NOVALIDATE

ofn.initialdir:=getcstring(startdir)

ofn.defext:=getcstring("")

result:=new(array,byte,300)

result[1]:=0
if deffile<>"" then
	memcpy(&result,&deffile,deffile.len)
fi

ofn.file:=int(&result)

ofn.maxfile:=256
ofn.title:=getcstring(caption)

if not (not save | getopenfilenamea(&ofn) | getsavefilenamea(&ofn)) then
	result[1]:=0		!return "" on error
fi

return string(result)
END

global function gxcurrpos(w)=
return w.attrs.currpos
end

global function gxtabstops(?tabs,signed=0)=
if tabs.isdef then
	tabstops:=tabs
	if signed then
		forall i,x in tabstops do
			tabstops[i]:=abs(x)
		od
	fi
fi
return tabstops

end

global function getlvbounds(linkvar)=
if linkvar.ispointer and linkvar^.islist then
	return linkvar^.bounds
else
	return linkvar.getbounds()
fi
return 0
end

global function getlvitem(linkvar,n)=
if linkvar.ispointer and linkvar^.islist then
	return linkvar^[n]
else
	PCERROR("GETLVITEM")
fi
return 0
end

global function getlvstritem(linkvar,n)=
if linkvar.ispointer and linkvar^.islist then
	return tostr(linkvar^[n])
else
	return linkvar.getstritem(n)
fi
return 0
end

global proc gxtext16(w,s,n,x=0,y=0)=		!GXTEXT
	gdi:=w.gdi

	textoutw(gdi.hdc,x, y,&s,n)
	if gdi.drawmode=dm_screenmemory then
		textoutw(gdi.hdc2,x,y,&s,n)
	fi
end

global function gxenable(w,flag)=
if flag.isdef then
	w.enable:=flag
	gxupdate(w)
fi
return w.enable
end

global function gxclientarea(w)=

aposx:=aposy:=0

adimx:=w.dimx
adimy:=w.dimy

centx:=(aposx+adimx)%2
centy:=(aposy+adimy)%2

forall cw in w.childlist do

	(posx,posy):=(cw.frameposx,cw.frameposy)
	(dimx,dimy):=(cw.framedimx,cw.framedimy)

	case cw.style.dir
	when 'B' then				!bottom
		if posy<(aposy+adimy) then
			adimy-:=dimy
		fi

	when 'T' then				!top
		if (posy+dimy)>aposy then		!
			aposy+:=(posy+dimy)
			adimy-:=(posy+dimy)
		fi

	when 'R' then				!right
		if posx<(aposx+adimx) then
			adimx-:=dimx
		fi

	when 'L' then				!LEFT
		if (posx+dimx)>aposx then		!
			aposx+:=(posx+dimx)
			adimx-:=(posx+dimx)
		fi
	else

		if dimx>dimy then			!assume hoz
			if posy>centy then			!assume bottom
				if posy<(aposy+adimy) then
					adimy-:=dimy
				fi

			else					!top
				if (posy+dimy)>aposy then		!
					aposy+:=(posy+dimy)
					adimy-:=(posy+dimy)
				fi
			fi
		else					!assume vert
			if posx>centx then			!assume right

				if posx<(aposx+adimx) then
					adimx-:=dimx
				fi

			else					!left

				if (posx+dimx)>aposx then		!
					aposx+:=(posx+dimx)
					adimx-:=(posx+dimx)
				fi

			fi
		fi
	esac
od

return ((aposx,aposy), (adimx,adimy))
END

global function addwindow(w)=
n:=nil in allwindows
if not n then
	n:=allwindows.len+1
fi

allwindows[n]:=w
w.gindex:=n
return n
end

global proc removewindow(w)=
n:=w in allwindows
if n then
	allwindows[n]:=nil
fi
end

function get_function_name(fnptr)=
n:=$pcldata('PROC',0)
for i:=1 to n do
	data:=$pcldata('PROC',i)
	if fnptr=data[4] then
		return data[1]
	fi
od
return "NOT FOUND "+tostr(fnptr)
end

function process_wmmessage(msg)=


hwnd:=msg.hwnd
w:=getwindow(hwnd)

message:=msg.message
wparam:=msg.wparam
lparam:=msg.lparam

case msg.message
when wm_command then
	w:=getwindow(lparam)			!w was owner, use control window
	i:=wparam iand 0xffff			!id
	j:=wparam>>16				!notify code
	m:=mm_command

	if not w then
		w:=wapplic
	fi

	postmess(w,m,i,j,0)

	return 0

when wm_activate then
	if wparam then				!being activated
	fi

when wm_syskeydown,wm_syskeyup,wm_keydown,wm_keyup then
	if dokeymessage(hwnd,message,wparam,lparam) then
		return 0
	fi

when wm_char then
	postmess((wfocus|wfocus|w),mm_char,wparam,lparam,0)

when wm_close then
	if w==wapplic then
		postmess(w,mm_close,0,0,0)
		return 0
	else
		postmess(w,mm_cancel,0,0,0)
		return 0
	fi

when wm_timer then
	w:=getwindow(lparam)			!w was owner, use control window
	if not w then
		w:=wapplic
	fi

	postmess(w,mm_timer,0,0,0)
	return 0

when wm_destroy then
	if w and wapplic and w==wapplic then
		killtimer(hwnd,1)
		postquitmessage(0)			!mm_quit message
		return 0
	else
		return 1
	fi


when wm_mousemove then

	buttonstate:=wparam iand (kb_lbutton ior kb_rbutton ior kb_mbutton)
	mousepos.x:=lparam iand 65535
	mousepos.y:=lparam>>16

domousemove:
	xyvalid:=1				!known again
	setnewmousewindow(w)

	wmouse:=w
	postmess(wmouse,mm_move)

	lastxy::=getscreencoords(wmouse,mousepos)
	lastxytime:=gettickcount
	stationary:=0


	if buttonstate<>0 and lastmousewindow<>nil then		!switch pressed
		pt:=getscreencoords(lastmousewindow,lastmousepos)
		dx:=lastxy.x-pt.x
		dy:=lastxy.y-pt.y

		if dragmode then		!1st drag message already generated
			postmess(lastmousewindow,mm_drag,dx,dy,-1)			!send latest drag coords

		else				!test for drag enabling
			if ((mousesw=1 and lastmousewindow.flags.[wa_leftdrag]<>0) or \
							(mousesw=2 and lastmousewindow.flags.[wa_rightdrag]<>0) or \
							(mousesw=3 and lastmousewindow.flags.[wa_middledrag]<>0)) and \
						(abs(dx)>dragtol or abs(dy)>dragtol) then
				dragmode:=mousesw
				postmess(lastmousewindow,mm_startdrag,dx,dy,-1)		!send latest drag coords
			fi

		fi
	else
		if dragmode then
			postmess(lastmousewindow,mm_enddrag,dx,dy,-1)	!send latest drag coords
			dragmode:=0
		fi
	fi

	return 0

when wm_enteridle then		!enter idle
	idlemode:=1
	return 0

when wm_paint then

	if w<>nil then
		ps:=new(ws_paintstruct)
		rect:=new(ws_rect)
		beginpaint(hwnd,&ps)
		postmess(w,mm_restore,0,0,0)
		endpaint(hwnd,^ps)
		return 0
	fi

when wm_erasebkgnd then

when wm_move then
	if w<>nil then
	fi

when wm_size then
	x:=lparam iand 0xffff
	y:=lparam>>16
	if w<>nil  and (w.dimx<>x or w.dimy<>y) then
		return 0
	fi


when wm_contextmenu then
	sendmess(w,mm_rclick,wparam>>16,wparam iand 0xffff,0)
	return 0

when wm_mousewheel then
	if not wmouse then wmouse:=w fi
	postmess(wmouse,mm_wheel,int(wparam>>16),wparam iand 0xffff,0)
	return 0

when wm_nclbuttondown,wm_nclbuttondblclick then

when wm_activateapp then
	if wparam then
		postmess(w,mm_activate,1,0,0)
	fi

else
btnmessages:
	if message>=wm_lbuttondown and message<=wm_mbuttondblclk then
		buttonmessages(hwnd,message,wparam,lparam)
		return 0
	fi
esac
return 1	!defwindowproc(hwnd,imsg,wparam,lparam)
end

global proc mxinit=
wmessagetable := [\
	wm_lbuttondown:		mm_click,
	wm_lbuttonup:		mm_clickup,
	wm_lbuttondblclk:	mm_dblclick,

	wm_rbuttondown:		mm_rclick,
	wm_rbuttonup:		mm_rclickup,
	wm_rbuttondblclk:	mm_rdblclick,

	wm_mbuttondown:		mm_mclick,
	wm_mbuttonup:		mm_mclickup,
	wm_mbuttondblclk:	mm_mdblclick]

buttontable	:= [\
	wm_lbuttondown:		1,
	wm_lbuttonup:		0,
	wm_lbuttondblclk:	1,

	wm_rbuttondown:		2,
	wm_rbuttonup:		0,
	wm_rbuttondblclk:	2,

	wm_mbuttondown:		3,
	wm_mbuttonup:		0,
	wm_mbuttondblclk:	3]

mousepos:=new(ws_point)

setmesshandler(^process_wmmessage)

vktomesstable:=[\
	vkleft:		mm_leftkey,
	vkright:	mm_rightkey,
	vkup:		mm_upkey,
	vkdown:		mm_downkey,
	vkpageup:	mm_pageupkey,
	vkpagedown:	mm_pagedownkey,
	vkhome:		mm_homekey,
	vkend:		mm_endkey,
	vktab:		mm_tabkey,
	vkbackspace:	mm_bskey,
	vkdelete:	mm_deletekey,
	vkenter:	mm_enterkey,
	vkinsert:	mm_insertkey,
	vkescape:	mm_cancel
]

end

global function postmess(w,mess,a=0,b=0,c=0)=

if w=nil then w:=wapplic fi
if w=nil then
 return 0 fi

if w.flags.[wa_closed] then

 return 0 fi

if mess>=1000 then
	headx:=1; mess-:=1000
else
	headx:=0
fi

case mess
when mm_sethozpos,mm_setvertpos,mm_draw,mm_restore,mm_update then
	for i:=1 to nmessages do
		m:=messagequeue[i].message
		if m=mess and w==messagequeue[i].wind then				!use the old message but update any params
			messagequeue[i].a:=a
			messagequeue[i].b:=b
			return 0
		elsif mess=mm_draw and m=mm_update then		!convert update to draw
			messagequeue[i].message:=mm_draw
			return 0
		fi
	od
esac

if quitmess or nmessages>=maxqueuesize then
	return 0
fi

postmsg(makemess(w,mess,a,b,c))

return 0					!return zero for use in mainwndproc
end

global function postmsg(msg,headx=0)=

if quitmess or nmessages>=maxqueuesize then
	return 0
fi

if msg.wind.flags.[wa_closed] then return 0 fi

if headx then


	++nmessages
	for i:=nmessages downto 2 do
		messagequeue[i]:=messagequeue[i-1]
	od
	messagequeue[1]:=msg

else
	++nmessages
	messagequeue[nmessages]:=msg
fi

return 0					!return zero for use in mainwndproc
end

global proc sendmess(w,mess,a=0,b=0,c=0)=

if w=nil then return fi
if w.flags.[wa_closed] then return fi

sendmsg(makemess(w,mess,a,b,c))
end

proc sendmsg(msg)=
if msg.wind.flags.[wa_closed] then return fi
postmsg(msg,1)
end

global function makemess(w,mess,a=0,b=0,state=-1)=

if w=nil then w:=wapplic fi

m:=new(rmessage,0)

m.wind:=w

m.message:=mess
m.a:=a
m.b:=b
m.state:=state

m.x:=mousepos.x
m.y:=mousepos.y

if m.state=-1 then m.state:=getshiftstate() fi

return m
end

function dokeymessage(hwnd,msg,wparam,lparam)=
case msg
when wm_syskeydown then

	if wparam=vkf10 then msg:=wm_keydown; goto dokey fi

when wm_syskeyup then
	if wparam=vkf10 then msg:=wm_keyup; goto dokey fi

when wm_keydown,wm_keyup then
dokey:
	case wparam
	when vkshift,vkctrl,vkalt,vkcapslock then
	else
		w:=wfocus
		if not w then w:=getwindow(hwnd) fi
		postmess(w,(msg=wm_keydown|mm_key|mm_keyup),wparam,lparam,-1)
		return 1
	esac
esac
return 0
end

function getshiftstate=
state:=0

if getkeystate(vklshift) iand 0x8000 then state ior:=kb_shift fi
if getkeystate(vklcontrol) iand 0x8000 then state ior:=kb_ctrl fi
if getkeystate(vklalt) iand 0x8000 then state ior:=kb_alt fi

if getkeystate(vkrshift) iand 0x8000 then state ior:=kb_rshift fi
if getkeystate(vkrcontrol) iand 0x8000 then state ior:=kb_rctrl fi
if getkeystate(vkralt) iand 0x8000 then
	state ior:=kb_ralt
	state iand:=(inot kb_ctrl)			!AltGr gives Lctrl+Ralt; return Ralt only
fi
if getkeystate(vkcapslock) iand 1 then state ior:=kb_capslock fi

return state ior buttonstate
END

proc buttonmessages(hwnd,msg,wp,lp)=

buttonstate:=wp iand (kb_lbutton ior kb_rbutton ior kb_mbutton)

mousepos.x:=lp iand 0xffff
mousepos.y:=int(lp)>>16
wmouse:=getwindow(hwnd)

mousesw:=buttontable{msg}

if mousesw then			!down up on click or dblclick
	lastbuttontime:=gettickcount
	lastmousepos::=mousepos
	lastmousewindow:=wmouse
else
	mousesw:=0

	if dragmode then
		postmess(lastmousewindow,mm_enddrag,0,0,-1)
		dragmode:=0
	fi

	lastbuttontime:=0
	lastmousewindow:=nil
fi

newmess:=wmessagetable{msg}

case newmess
when mm_dblclick then unless wmouse.flags.[wa_leftdbl] then newmess:=mm_click end
when mm_rdblclick then unless wmouse.flags.[wa_rightdbl] then newmess:=mm_click end
esac

postmess(wmouse,newmess,wmouse.id,0,-1)
END

proc setnewmousewindow(w)=
return when not currmousewindow
unless w==currmousewindow then		!changed
	if currmousewindow<>nil then
		postmess(currmousewindow,mm_offwindow,0,0,0)
	fi

	currmousewindow:=w
	postmess(w,mm_onwindow,0,0,0)
end unless
end

proc frame2rect(f,r)=
r^.x:=f^.x
r^.y:=f^.y

r^.dimx:=f^.x2-f^.x1+1
r^.dimy:=f^.y2-f^.y1+1
end

global function mxwait_mm_message=
#do windows dispatch loop
#calling dispatchmessage() results in mainwndproc being called in interpreter,
#which passes the Windows message params on to process_wmmessage() in this module
#process_wmmessage() converts wm-messages to mpl mm-messages
#return when at least one mm message is ready; (will return immediately if there
#is already one in the queue)
#return value is normall 1, or 0 when quitmess has been encountered

if quitmess then				!quit message already seen
	return 0
fi

windmsg:=new((iswin32|ws_msg32|ws_msg64))

while nmessages<=0 do
	if x:=getmessage(&windmsg,0,0,0)<>0 then
		w:=windmsg.hwnd

		translatemessage(&windmsg)
		dispatchmessage(&windmsg)
	else
		quitmess:=1
		exit
	fi
od

if not nmessages then			!assume quit message seen
	return 0
fi	

currmess:=messagequeue[1]
--nmessages

xlatkeyboard()

for i:=1 to nmessages do
	messagequeue[i]:=messagequeue[i+1]
od
return 1
end

proc xlatkeyboard=
m:=currmess.message

if m=mm_key then

	k:=currmess.a
	if k>=vkf1 and k<=vkf12 then
		newmsg:=currmess
		currmess.message:=mm_functionkey
		currmess.a:=k-vkf1+1
	else
		keymess:=vktomesstable{k,0}
		if keymess then
			currmess.message:=keymess
		fi
	fi
fi
end

function getscreencoords(w,pos)=
pt::=pos
if not w then
	PCERROR("GSC/W=0")
fi

clienttoscreen(w.gdi.hwnd,&pt)		!pos starts at 0,0
return pt
end

global function getwindow(hwnd)=
if hwnd=0 then
	return nil
fi

index:=wx_getw(hwnd)
if index then
	return allwindows[index]
fi
return nil
end

proc initmenuhandlers=
ltcolour:=getrgb(ltgrey)
dkcolour:=getrgb(dkgrey)
end

proc gxhandler_fixups <"fx">=
messhandlertable[mm_startdrag,scrollbar_class]:=^mess_drag_scrollbar()
messhandlertable[mm_enddrag,scrollbar_class]:=^mess_drag_scrollbar()
messhandlertable[mm_leftkey,scrollbar_class]:=^mess_upkey_scrollbar()
end

function mess_all_all			<"mx">			(mess,w)=
case mess.message
when mm_startdrag,mm_drag,mm_enddrag then
when mm_command then
when mm_ok,mm_cancel then
when mm_click then
	case w.windclass
	when label_class, group_class then
		return skipmess
	esac
when mm_key then
when mm_sethozpos,mm_setvertpos then
when mm_pick,mm_lbchange then
when mm_leftkey,mm_rightkey,mm_upkey,mm_downkey,mm_enterkey,mm_tabkey then
when mm_pageupkey,mm_pagedownkey then
when mm_homekey, mm_endkey then
when mm_functionkey then
when mm_wheel then
else
	return skipmess
esac

return thismess
end

function mess_restore_all			<"mx">		(mess,w)=
gxrestore(W)

return skipmess
end

function mess_killfocus_all				<"mx">		(mess,w)=

drawcaret(0)
wfocus:=nil

return skipmess
end

function mess_setfocus_all				<"mx">		(mess,w)=
if wfocus then
	mess_killfocus_all(mess,wfocus)
fi

wfocus:=w
drawcaret(1)
return skipmess
end

function mess_update_all	<"mx">			(mess,w)=
gxupdate(w)
return skipmess
end

function mess_draw_all		<"mx">			(mess,w)=
gxdraw(w)
return skipmess
end

function mess_click_select		<"mx">	(mess,w)=
if w.enable then
	if not w.style.noupdate then
		p:=w.linkvar
		p^:=w.attrs.onvalue
		forall wc in w.owner.childlist do
			if wc.windclass=select_class and wc.linkvar=p then
				gxdraw(wc)
			fi
		od
	fi
	if w.style.returnmess then
		postmess(w,mm_command,w.id)
	fi
fi
return skipmess
end

function mess_click_toggle		<"mx">	(mess,w)=
if w.enable then
	if not w.style.noupdate then
		w.linkvar^:=not w.linkvar^
		gxdraw(w)
	fi
	if w.style.returnmess then
		postmess(w,mm_command,w.id)
	fi
fi
return skipmess
end

function mess_click_button		<"mx">	(mess,w)=

if w.enable=0 then
	beep1()
	return skipmess
fi

if w.id in 0..199 then				!speficies an actual message number (but no params)
	postmess(w,w.id)
else
	postmess(w,mm_command,w.id)
fi
return skipmess
end

function mess_click_editbox		<"mx">	(mess,w)=
if w.enable then
	if not w.style.noupdate then
		unless w==wfocus then
			gxfocus(w)
		end
	fi
	if w.style.returnmess then
		postmess(w,mm_command,w.id)
	fi
fi

return skipmess
end

function mess_click_arrow		<"mx">	(mess,w)=

case w.owner.windclass
when scrollbar_class then
	postmess(w.owner,dirtomess{w.style.dir},w.id,0,-1)
else
	mess.message:=dirtomess{w.style.dir}
	mess.a:=w.id
	return thismess
esac
return skipmess
end

function mess_click_mark		<"mx">	(mess,w)=

case w.owner.windclass
when toggle_class,select_class then
	postmess(w.owner,mess.message,w.id,0,-1)
esac
return skipmess
end

function mess_click_listbox		<"mx">	(mess,w)=
gxfocus(w)

y:=max(w.attrs.offset,mess.y)

pos:=(y-w.attrs.offset)%w.attrs.pitch+w.attrs.pagepos
if pos<=getlvbounds(w.linkvar).len then
	gxsetlbpos(w,pos)
	postmess(w,mm_pick,pos)
fi

return skipmess
end

function mess_click_scrollbar		<"mx">	(mess,w)=
onthumb:=isonthumb(w,(w.style.dir='H'|mess.x|mess.y))
step:=w.attrs.span
a:=w.attrs.currpos

case w.owner.windclass
when listbox_class then
	case onthumb
	when -1 then
		if a>w.attrs.limits.lwb then
			a:=max(a-step,w.attrs.limits.lwb)
			gxsetlbpage(w.owner,a)
		fi
	when 1 then
		if a<w.attrs.limits.upb then
			a:=min(a+step,w.attrs.limits.upb)
			gxsetlbpage(w.owner,a)
		fi
	esac
else
	if not step then step:=10 fi

	case onthumb
	when -1 then
		if a>w.attrs.limits.lwb then
			a:=max(a-step,w.attrs.limits.lwb)
			gxscrollpos(w,a,1)
			postmess(w,mm_sethozpos,a)
		fi
	when 1 then
		if a<w.attrs.limits.upb then
			a:=min(a+step,w.attrs.limits.upb)
			gxscrollpos(w,a,1)
			postmess(w,mm_sethozpos,a)
		fi
	esac
esac
return skipmess
end

function mess_wheel_scrollbar		<"mx listbox">	(mess,w)=
delta:=currmess.a
n:=abs(currmess.a%120)
to n do
	case w.windclass
	when scrollbar_class then
doscroll:
		postmess(w,(delta>0|mm_up|mm_down))
	when listbox_class then
		if w.childlist then
			w:=w.childlist[1]
			goto doscroll
		fi
		postmess(w,(delta>0|mm_upkey|mm_downkey))
	esac
od
return skipmess
end

function mess_up_scrollbar		<"mx">	(mess,w)=
a:=w.attrs.currpos
if a<=w.attrs.limits.lwb then
	return skipmess
fi
case w.owner.windclass
when listbox_class then
	gxsetlbpage(w.owner,a-1)
	return skipmess
else
	--a
	gxscrollpos(w,a,1)
	postmess(w,mm_setvertpos,a)
esac
return skipmess
end

function mess_left_scrollbar		<"mx">	(mess,w)=

case w.owner.windclass
when listbox_class then
	return skipmess
else
	a:=w.attrs.currpos
	if a>w.attrs.limits.lwb then
		--a
		gxscrollpos(w,a,1)
		postmess(w,mm_sethozpos,a)
	fi
esac
return skipmess
end

function mess_right_scrollbar		<"mx">	(mess,w)=

case w.owner.windclass
when listbox_class then
	return skipmess
else
	a:=w.attrs.currpos
	if a<w.attrs.limits.upb then
		++a
		gxscrollpos(w,a,1)
		postmess(w,mm_sethozpos,a)
	fi

esac
return skipmess
end

function mess_down_scrollbar		<"mx">	(mess,w)=

a:=w.attrs.currpos
if a>=w.attrs.limits.upb then
	return thismess
fi
case w.owner.windclass
when listbox_class then
	gxsetlbpage(w.owner,a+1)
	return skipmess
else
	++a
	gxscrollpos(w,a,1)
	postmess(w,mm_setvertpos,a)

esac
return skipmess
end

function mess_drag_scrollbar		<"mx">	(mess,w)=
case mess.message
when mm_startdrag then
	if isonthumb(w,(w.style.dir='H'|mess.x|mess.y))=0 then
		thumbdragmode:=1			!then treat as mm_drag
		thumbstartpos:=w.attrs.thumbpos-arrowdim		!use thumb pos at start of drag
	else							!dragging other part of scrollbar
		return skipmess
	fi
when mm_enddrag then
	thumbdragmode:=0
	return skipmess
elsif not thumbdragmode then
	return skipmess
esac

offset:=(w.style.dir='H'|mess.a|mess.b)		!pixel offset from initial drag start pos
newpos:=thumbstartpos+offset						!could outside thumb span range

pos:=int(round((newpos/w.attrs.thumbspan)*(w.attrs.limits.len-1)+w.attrs.limits.lwb))
pos:=clamp(pos,w.attrs.limits.lwb,w.attrs.limits.upb)

case w.owner.windclass
when listbox_class then
	gxsetlbpage(w.owner,pos)
else
	gxscrollpos(w,pos,1)
	postmess(w,(w.style.dir='H'|mm_sethozpos|mm_setvertpos),pos)
esac
return skipmess
end

function mess_move_button		<"mx">			(mess,w)=
return skipmess
end

function mess_move_all			<"mx">			(mess,w)=
return skipmess
end

function mess_char_editbox		<"mx">			(mess,w)=
if mess.a not in 32..255 then
	if wapplic then
 postmess(wapplic,mm_key,mess.a,mess.b,mess.state) fi
 return skipmess fi
if not w.enable or w.style.noupdate then return skipmess fi
s:=w.linkvar^
n:=w.attrs.currpos
c:=chr(mess.a)

if n>s.len then				!at end
	s+:=c
elsif n=1 then				!at start
	s:=c+s
else						!in middle
	s:=leftstr(s,n-1)+c+rightstr(s,-(n-1))
fi
w.linkvar^:=s
++w.attrs.currpos
gxdraw(w)

return skipmess
end

function mess_key_editbox		<"mx">			(mess,w)=

postmess(wapplic,mm_key,mess.a,mess.b,mess.state)

return skipmess
end

function mess_leftkey_editbox		<"mx">		(mess,w)=
if ctrlpressed() then
	postmess(wapplic,mm_leftkey,mess.a,mess.b,mess.state)
	return skipmess
fi

if w.attrs.currpos>1 then
	drawcaret(0)
	--w.attrs.currpos
	drawcaret(1)
fi
return skipmess
end

function mess_rightkey_editbox		<"mx">		(mess,w)=
if ctrlpressed() then
	postmess(wapplic,mm_rightkey,mess.a,mess.b,mess.state)
	return skipmess
fi

if w.attrs.currpos<=w.linkvar^.len then
	drawcaret(0)
	++w.attrs.currpos
	drawcaret(1)
fi
return skipmess
end

function mess_bskey_editbox		<"mx">		(mess,w)=
s:=w.linkvar^
if not s then return skipmess fi
n:=w.attrs.currpos
if n=1 then return skipmess fi

if n>s.len then				!at end
	s:=leftstr(s,-1)
else						!in middle
	s:=leftstr(s,n-2)+rightstr(s,-(n-1))
fi
w.linkvar^:=s
--w.attrs.currpos
gxdraw(w)

return skipmess
end

function mess_deletekey_editbox		<"mx">		(mess,w)=
s:=w.linkvar^
if not s then return skipmess fi
n:=w.attrs.currpos
if n>s.len then return skipmess fi

if n=1 then				!at start
	s:=rightstr(s,-1)
else						!in middle
	s:=leftstr(s,n-1)+rightstr(s,-n)
fi
w.linkvar^:=s
gxdraw(w)

return skipmess
end

function mess_homekey_editbox		<"mx">		(mess,w)=
if ctrlpressed() then
	postmess(wapplic,mm_homekey,mess.a,mess.b,mess.state)
	return skipmess
fi

drawcaret(0)
w.attrs.currpos:=1
drawcaret(1)

return skipmess
end

function mess_homekey_listbox		<"mx">		(mess,w)=
if w.attrs.currpos>1 then
	gxsetlbpos(w,1)
fi

return skipmess
end

function mess_endkey_editbox		<"mx">		(mess,w)=
if ctrlpressed() then
	postmess(wapplic,mm_endkey,mess.a,mess.b,mess.state)
	return skipmess
fi

drawcaret(0)
w.attrs.currpos:=w.linkvar^.len+1
drawcaret(1)

return skipmess
end

function mess_endkey_listbox		<"mx">		(mess,w)=
if w.attrs.currpos<getlvbounds(w.linkvar).len then
	gxsetlbpos(w,getlvbounds(w.linkvar).len)
fi

return skipmess
end

function mess_upkey_listbox		<"mx">		(mess,w)=
if w.attrs.currpos>1 then
	gxsetlbpos(w,w.attrs.currpos-1)
fi

return skipmess
end

function mess_upkey_scrollbar		<"mx">		(mess,w)=

a:=w.attrs.currpos
if a>w.attrs.limits.lwb then
	--a
	gxscrollpos(w,a,1)
	postmess(w,mm_setvertpos,a)
fi
return skipmess
end

function mess_downkey_listbox		<"mx">		(mess,w)=
if w.attrs.currpos<getlvbounds(w.linkvar).len then
	gxsetlbpos(w,w.attrs.currpos+1)
fi

return skipmess
end

function mess_pageupkey_listbox		<"mx">		(mess,w)=
if (a:=w.attrs.currpos)>1 then
	a:=max(a-w.attrs.rows,1)
	gxsetlbpos(w,a)
fi

return skipmess
end

function mess_pagedownkey_listbox		<"mx">		(mess,w)=
if (a:=w.attrs.currpos)<getlvbounds(w.linkvar).len then
	a:=min(a+w.attrs.rows,getlvbounds(w.linkvar).len)
	gxsetlbpos(w,a)
fi

return skipmess
end

function mess_enterkey_listbox		<"mx">		(mess,w)=
if w.attrs.currpos then
	postmess(w,mm_pick,w.attrs.currpos)
fi

return skipmess
end

proc do_draw_all			<"wx">			(w)=
gxclear(w)
drawborder(w)
drawchildborders(w)
end

proc do_draw_button			<"wx label">			(w)=
gxclear(w)

gxtext_just(w,w.text,,w.enable)

drawborder(w)

end

proc do_draw_toggle			<"wx">	(w)=
gxclear(w)

VALSTR:=""

turnedon:=istrue w.linkvar^

if w.style.marktype then
	drawmark(w.childlist[1],turnedon,w.enable)

	gxtext_just(w,w.text+valstr,markdim,w.enable)
else
		if turnedon then
			gxclear(w,getrgb(green))
		fi

	gxtext_just(w,w.text+valstr)
fi
end

proc do_draw_select			<"wx">	(w)=
gxclear(w)

turnedon:=w.linkvar^=w.attrs.onvalue

if w.style.marktype then
	drawmark(w.childlist[1],turnedon,w.enable)
	gxtext_just(w,w.text,markdim,w.enable)
else
	case w.style.hilitetype
	when invert_hilite then
		if turnedon then
			gxclear(w,getrgb(white))
		fi
	esac
		gxtext_just(w,w.text)
fi
end

proc do_draw_editbox			<"wx">	(w)=
gxclear(w)

gxtext_just(w,w.linkvar^,enable:w.enable)

unless wfocus==w then			!only draw it when this window has the focus
	return
end

caretdrawn:=0

drawcaret(1)
end

proc do_draw_arrow			<"wx">	(w)=
gxclear(w)

drawborder(w)
drawarrow(w,w.enable)
end

proc do_draw_mark			<"wx">	(w)=

case w.owner.windclass
when toggle_class, select_class then
	return					!mark drawn by owner
esac

gxclear(w,getrgb(w.owner.style.windbgnd))

drawborder(w)
end

proc do_draw_scrollbar			<"wx">	(w)=
gxclear(w)
drawborder(w)
gxdraw(w.childlist[1])			!arrows
gxdraw(w.childlist[2])

if w.attrs.thumbsize then
	if w.style.dir='H' then
		x:=w.attrs.thumbpos
		dx:=w.attrs.thumbsize
		drawthumb(w,x,0,dx,w.dimy)
	else
		y:=w.attrs.thumbpos
		dy:=w.attrs.thumbsize
		drawthumb(w,0,y,w.dimx,dy)
	fi
fi
end

proc do_draw_listbox			<"wx">	(w)=
gxclear(w)
drawborder(w)
if w.childlist then			!scrollbar
	gxdraw(w.childlist[1])
fi

for i:=1 to w.attrs.rows do
	k:=i+w.attrs.pagepos-1
	if k<=getlvbounds(w.linkvar).len then
		drawlbtext(w,i,getlvstritem(w.linkvar,k),0,k=w.attrs.currpos)
	fi
od
end

proc do_update_all				<"wx">	(w)=
gxdraw(w)
end

proc do_update_listbox			<"wx">	(w)=
gxdraw(w)
end

proc drawcaret(x)=

if wfocus=nil then		!no window has focus
	caretdrawn:=0
	return
fi

case wfocus.windclass
when editbox_class then
	if x then			!new caret
		if caretdrawn then return fi	!already drawn
		xpos:=getcaretpos(wfocus.linkvar^,wfocus.attrs.currpos,0)
		wfocus.attrs.caretpos:=xpos			!record position
	else			!delete caret
		if not caretdrawn then return fi	!already deleted
		xpos:=wfocus.attrs.caretpos		!use stored value
	fi

	caretwidth:=2

	gxhighlight(wfocus,xpos+wfocus.attrs.textpos[1],wfocus.attrs.textpos[2]-chd,caretwidth,20)

	caretdrawn:=x
esac
end

function getcaretpos(s,pos,offset)=
if pos=1 then return 0 fi

return wx_gettextwidth(wfocus.gdi.hdc, leftstr(s,pos-1))
end

proc drawborder(w)=

case bscat[w.style.border]
when 0 then					!no border
	return
when 'W' then				!windows-drawn
	return
when 'X' then				!external (drawn in owner's client space
	posx:=w.frameposx
	posy:=w.frameposy
	dimx:=w.framedimx
	dimy:=w.framedimy
	bs:=w.style.border

	bs:=w.style.border
	wo:=w.owner
	case bs
	when bs_simple then			!USUALLY BS_SIMPLE converts to BS_WINDOWS; must be override
		gxcolour(wo,0)
		gxrect(wo,posx,posy,dimx,dimy)
	when bs_thick then
	when bs_panel then
		gxcolour(wo,ltcolour)
		gxline(wo,posx+dimx-1,posy, posx,posy)
		gxline(wo,posx,posy+dimy-1)
		gxcolour(wo,dkcolour)
		gxline(wo,posx+dimx-1,posy+dimy-1)
		gxline(wo,posx+dimx-1,posy)
	when bs_inset then
		gxcolour(wo,dkcolour)
		gxline(wo,posx+dimx-1,posy, posx,posy)
		gxline(wo,posx,posy+dimy-1)
		gxcolour(wo,ltcolour)
		gxline(wo,posx+dimx-1,posy+dimy-1)
		gxline(wo,posx+dimx-1,posy)
	when bs_testext then
		gxcolour(wo,0)
		gxrect(wo,posx,posy,dimx,dimy)
		gxrect(wo,posx+9,posy+9,dimx-18,dimy-18)

	esac
when 'I' then				!internal (drawn within window's client space
	posx:=w.frameposx
	posy:=w.frameposy
	dimx:=w.dimx
	dimy:=w.dimy

	case w.style.border
	when bs_ownpanel then
		gxcolour(w,ltcolour)
		gxline(w,w.framedimx-1,0,0,0)
		gxline(w,0,w.framedimy-1)
		gxcolour(w,dkcolour)
		gxline(w,w.framedimx-1,w.framedimy-1)
		gxline(w,w.framedimx-1,0)

	when bs_owninset then
		gxcolour(w,dkcolour)
		gxline(w,w.framedimx-1,0,0,0)
		gxline(w,0,w.framedimy-1)
		gxcolour(w,ltcolour)
		gxline(w,w.framedimx-1,w.framedimy-1)
		gxline(w,w.framedimx-1,0)
	when bs_ownsimple then
		gxcolour(w,0)
		gxrect(w,0,0,w.framedimx,w.framedimy)
	when bs_testint then
		gxcolour(w,0)
		gxrect(w,0,0,dimx,dimy)
		gxrect(w,7,7,dimx-14,dimy-14)
	esac
esac
end

proc drawchildborders(w)=
if not w.childlist then
	return
fi
forall wc in w.childlist do
	if wc.style.border in [bs_simple,bs_thick,bs_panel,bs_inset] then
		drawborder(wc)
	fi
od
end

proc drawarrow(w,enable)=
const factor=0.3

gxsetpen(w,(enable|black|dkgrey))

width:=w.dimx
height:=w.dimy

case w.style.dir
when 'D' then
	x:=int(round(width/2)-1)

	wd:=0

	h:=int(round(min(height,width)*factor))
	if h<3 then h:=3 fi
	y:=int((height+h)*0.5)-1

	to h do
		gxline(w,x,y,x+wd,y)
		x-:=1
		y-:=1
		wd+:=2
	od

when 'U' then
	x:=int(round(width/2)-1)
	wd:=0

	h:=int(round(min(height,width)*factor))
	if h<3 then h:=3 fi
	y:=int(round((height-h)*0.5))
	to h do
		gxline(w,x,y,x+wd,y)
		x-:=1
		y+:=1
		wd+:=2
	od

when 'L' then
	y:=height%2

	ht:=0
	wd:=y

	wd:=int(round(min(height,width)*factor))
	if wd<3 then wd:=3 fi
	x:=int(round((width-wd)*0.5)-1)

	to wd do
		gxline(w,x,y,x,y+ht)
		y-:=1
		x+:=1
		ht+:=2
	od

when 'R' then
	y:=height%2
	ht:=0

	wd:=int(round(min(height,width)*factor))
	if wd<3 then wd:=3 fi
	x:=int(round((width+wd)*0.5)-1)

	to wd do
		gxline(w,x,y,x,y+ht)
		y-:=1
		x-:=1
		ht+:=2
	od
esac
end

global proc gxtext_just(w,s,offset=0,enable=1)=
dimx:=w.dimx
dimy:=w.dimy
width:=wx_gettextwidth(w.gdi.hdc, s)
height:=chy				!assume basic font

case w.style.justify
when 'L' then	x:=smx
when 'R' then	x:=dimx-width-smx
else
			x:=(dimx-width)%2
esac

case w.style.vjustify
when 'T' then	y:=smy
when 'B' then	y:=dimy-height-smy
else
			y:=(dimy-height)%2!		-smy%2
esac

if not enable then
	oldtextfgnd:=w.style.textfgnd
	gxtextcolour(w,grey)
fi

gxtext(w,s,x+offset,y)

if not enable then
	gxtextcolour(w,oldtextfgnd)
fi
if w.windclass=editbox_class then
	w.attrs.textpos:=(x+offset,y)
fi
end

proc drawthumb(w,x,y,dx,dy)=

gxcolour(w,0)
gxrect(w,x,y,dx,dy)
gxfillrect(w,x+1,y+1,dx-2,dy-2,getrgb(grey))
end

function isonthumb(w,d)=

a:=w.attrs.thumbpos
b:=w.attrs.thumbsize

if d<a then
	return -1
elsif d>(a+b) then
	return 1
else
	return 0
fi
end

proc drawmark(w,turnedon,enable)=

gxclear(w,getrgb(w.owner.style.windbgnd))
gxsetpen(w,(enable|black|red))

width:=w.dimx
height:=w.dimy
x:=y:=1
wd:=width-2
ht:=height-2
gxrect(w,x,y,wd,ht)
if not turnedon then return fi

case w.style.marktype
when radio_mark then

	gxfillrect(w,x+3,y+3,wd-6,ht-6,getrgb(red))

when check_mark then

	gxline(w,x,y,x+wd-1,y+ht-1)
	gxline(w,x+wd-1,y,x,y+ht-1)

when tick_mark then

	gxline(w,x+3,y+ht%2,x+wd%2,y+ht-4)
	gxline(w,x+wd-3,y+2)

esac
end

proc drawlbtext(w,row,text,clr=0,hilite=0)=

x:=0
y:=(row-1)*w.attrs.pitch+w.attrs.offset

if clr or hilite then
	gxfillrect(w,x,y,w.dimx,w.attrs.pitch,(hilite|getrgb(grey)|getrgb(w.style.windbgnd)))
fi

if hilite then
	oldtextcolour:=gxtextcolour(w)
	gxtextcolour(w,white)
fi

gxtext(w,text,x+smx,y+smy)
if hilite then
	gxtextcolour(w,oldtextcolour)
fi
end

function readnextitem(a)=

if a="" then return list(0,0,0,0) fi

level:=1
tabs:=0
options:=""

while asc(a) in [9,' '] do tabs+:=1; a:=rightstr(a,-1) od

if a="" then return list(0,0,0,0) fi

case asc(a)
when '!' then
	return list(0,0,0,0)
esac

if tabs then
	j:=0
	for i:=1 to ntab do
		if tabs=tabstack[i] then j:=i; exit fi
	od

	if j=0 then
		if tabs>tabstack[ntab] then
			ntab+:=1
			tabstack[ntab]:=tabs
		fi
		level:=ntab
	else
		level:=j
		if j<ntab then ntab:=j fi
	fi
fi

if asc(a) in ['0'..'9'] then
	value:=strtoval(a)
	n:=" " in a
	if not n then
		n:=chr(9) in a
	fi
	if n then
		labelx:=rightstr(a,-n)
	else
		labelx:="?"
	fi

else			!no preceding number, maybe top-level menu

	if "=" in a then	!command def for mpl
		return (0,0,0,0)
	fi

	value:=k_menu
	labelx:=a
	case convlc(labelx)
	when "hozbreak","divider" then
		value:=kdivide
	when "vertbreak" then
		value:=kcolumn
	when "filehistory" then
		value:=kfilehistory
	else
		if leftstr(labelx)="-" then value:=kdivide fi
	esac
fi

if labelx="" then			!maybe [cmd] only
	return list(0,0,0,0)
fi

return (level,value,(labelx),options)
end

function readmenu(m,n,level)=

for i:=n to ndata do
	(l,value,labelx,options):=data[i]

	if l<=level then		!end of this submenu
		return i
	fi

	flags:=breakflag
	enable:=1
	if rightstr(labelx)="?" then
		enable:=0
		labelx:=leftstr(labelx,-1)
	fi

	if options<>"" then
		if "H" in options then flags+:="h" fi
		if "C" in options then flags+:="c" fi
	fi

	case value
	when kdivide then
		gxaddmb(m,,,"d")
	when kcolumn then
		breakflag:="v"
	when k_menu then		!submenu
		newm:=gxcreatemb()
		n:=readmenu(newm,i+1,l)
		gxaddmb(m,labelx,newm,"p"+flags,enable)
		breakflag:=""
		restart
	when kfilehistory then
		nfiles:=8
		gxaddmb(m,"filehistory",1060,breakflag)
	else				!ordinary command
normalcmd:
		gxaddmb(m,labelx,value,flags,enable)
		breakflag:=""
	esac

skip:
od

return ndata+1			!eod reached
end

function mbreaddata(a)=

tabstack:=(0,)
ntab:=1
data:=()
ndata:=0
breakflag:=""

if a.isstring then		!read from file
	a:=readtextfile(a)
	if a=0 then
		a:=("CANTOPENFILE",)
	fi
fi

for i:=1 to a.upb do
	x:=readnextitem(a[i])

	if x[1] then
		++ndata
		data[ndata]:=x
	fi
od

m:=gxcreatemb()
readmenu(m,1,0)
return m
end

global function gxmenubar(w,?a)=

if a.defined then		!w,m: read menu into window w
	m:=mbreaddata(a)

	if not w.isint then
		while w.owner<>nil do
			w:=w.owner
		od
	fi

	gxsetmb(w,m)
	return 0
else				!create standalone menu, return handle
	return mbreaddata(w)
fi
end

function gxcreatemb(?s)=

if s.defined and s in "Pp" then
	return createpopupmenu()
else
	return createmenu()
fi
end

proc gxsetmb(w,m)=

hwnd:=w.gdi.hwnd
a:=getmenu(hwnd)
s:=setmenu(hwnd,m)
if a then destroymenu(a) fi
end

function gxaddmb(wm,caption="X",id=0,style="",enable=0)=

if wm.isint then				!assume handle
	hmenu:=wm
	wm:=nil
else
	hmenu:=getmenu(wm.gdi.hwnd)
fi


flags:=mf_string ior mf_unchecked

if not enable then flags ior:=mf_greyed fi

foreach c in convuc(style) do
	case c
	when 0 then exit
	when 'P' then flags ior:=mf_popup
	when 'D' then flags ior:=mf_separator
	when 'B' then flags ior:=mf_menubreak
	when 'V' then flags ior:=mf_menubarbreak
	when 'H' then flags ior:=mf_help
	when 'C' then flags ior:=mf_checked
	esac
od

if appendmenu(hmenu,flags,id,caption) then
	if wm<>nil then drawmenubar(wm.gdi.hwnd) fi
	return hmenu
fi
return 0
end

proc gxshowmb(wm,w,x,y)=
if wm.isint then

	if not y.defined then
		x:=w
		y:=x
		w:=nil
		hwnd:=wapplic.gdi.hwnd
	else
		hwnd:=w.gdi.hwnd
	fi

	pos:=ws_point(x,y)

	if w<>nil then
		clienttoscreen(w.gdi.hwnd,&pos)
	fi

	trackpopupmenu(wm,0,pos.x,pos.y,0,hwnd,0)
else
	drawmenubar(wm.gdi.hwnd)
fi
end

function gxenablemb(wm,id,enable)=

if wm.isint then				!assume handle
	hmenu:=wm
else
	hmenu:=getmenu(wm.gdi.hwnd)
fi

if enable.defined then
	return enablemenuitem(hmenu,id,(enable|0|mf_greyed)+mf_bycommand)
else
	return (getmenustate(hmenu,id,mf_bycommand) iand mf_greyed|0|1)
fi
end

function gxcheckmb(wm,id,check)=
if wm.isint then				!assume handle
	hmenu:=wm
else
	hmenu:=getmenu(wm.gdi.hwnd)
fi

if check.defined then
	return checkmenuitem(hmenu,id,(check|mf_checked|mf_unchecked)+mf_bycommand)
else
	return (getmenustate(hmenu,id,mf_bycommand) iand mf_checked|1|0)
fi
end

proc gxclosemb(m)=
destroymenu(m)
end

global function gxconfirm(m)=
x:=gxmsgbox(m,"Confirm","byn")
CPL =x
return x="yes"
end

function issubwindow(w,w2)=
while w2 do
	if w2==w then return 1 fi
	w2:=w2.owner
od
return 0
end

global proc flushmessages=

end
=== gxmisc.q 55/56 ===
global tabledata() optionnames =
	(wf_border,		$),		! wbs_simple
	(wf_resize,		$),		! 0
	(wf_hscroll,	$),		! 0
	(wf_vscroll,	$),		! 0
	(wf_menu,		$),		! 0
	(wf_caption,	$),		! 1
	(wf_max,		$),		! 0
	(wf_minmax,		$),		! 1
	(wf_sysmenu,	$),		! 1
	(wf_desktop,	$),		! 0
	(wf_clip,		$),		! 0
	(wf_show,		$),		!
	(wf_iframe,		$),		! 1
	(wf_cent,		$),		!
	(wf_toolwind,	$)		!
end

global tabledata() wbsnames=
	(wbs_none=0,$),
	(wbs_simple,$),
	(wbs_thick,$),
	(wbs_resize,$),
	(wbs_sunken,$),
	(wbs_sunken2,$),
	(wbs_sunkenrs,$),
	(wbs_dummy,$)
end

proc start=
end

PROC MAIN=
END
=== bmlib.q 56/56 ===

import sys
import clib
import files
import winapi
import winconsts
import gxlib

VAR DEBUG=0




importdll imglib =
    clang function imgload_rgb		(string, ref byte, ref byte, ref byte, int32)ref byte
    clang function imgload_bgr		(string, ref byte, ref byte, ref byte, int32)ref byte
    clang proc     imgload_free		(ref byte)
    clang function imgsave_jpeg_rgb	(string, ref byte, int32, int32, int32)int32
    clang function imgsave_jpeg_bgr	(string, ref byte, int32, int32, int32)int32
end

type bmpheader = struct
	ws_bitmapfileheader fh
	ws_bitmapinfoheader bh
end

var	shifts=[2:1, 4:2, 8:3, 16:4, 32:5, 64:6]

proc start=
end

proc main=



CPL "TESTING BMMAIN"
FILE:="C:/JPEG/GIRL.JPG"


BM:=BMLOAD(FILE)
IF NOT BM THEN STOP FI

w:=GXCREATEWINDOW(DIM:(960,540),caption:"HI THERE")
gxcopy(w,bm,scalex:0.5)
eventloop()

end

global function bmcreate(pixelbits,width,height)=

	bminfo:=new(ws_bitmapv5header)
	bminfo.size:=ws_bitmapv5header.bytes
	bminfo.width:=width
	bminfo.height:=-height
	bminfo.planes:=1
	bminfo.bitcount:=pixelbits

	pixelptr:=nil

	if pixelbits not in [8,24,32] then
		abort("bmcreate pixel size not supported:"+tostr(pixelbits))
	fi

	hwnd:=createdibsection(nil,&bminfo,0,&pixelptr,0,0)

	pixelptr:=makeref(pixelptr,byte)

	if hwnd=0 then
		error:=getlasterror()
		abort("bmcreate:CreateDIB failed:"+tostr(error))
	fi


	bm:=new(rwindow,0)
	bm.windclass:=bitmap_class

	bm.dimx:=width
	bm.dimy:=abs(height)		!neg height used for top-down bitmaps

	bm.style:=defstyle

	bm.pixelbits:=pixelbits
	bm.pixelptr:=pixelptr


	bm.pixelbytes:=pixelbits%8

	n:=bm.pixelbytes*width

	if (n iand 3)<>0 then	!make bytes a multiple of 4
		n:=(n+4) iand 0xfffc
	fi
	bm.linebytes:=n
	bm.framebytes:=bm.linebytes*bm.dimy

	if pixelbits=8 then
		palette:=new(array,int32,0..255)
		bm.paltype:=greyscale_pal
		colour:=0
		for i:=0 to 255 do
			palette[i]:=colour
			colour+:=0x10101
		od
	fi

	setupgdi(bm,hwnd)

	bm.gdi.hdc:=createcompatibledc(nil)
	bm.gdi.drawmode:=dm_memory
	bm.gdi.oldbmobj:=selectobject(bm.gdi.hdc,hwnd)	!should store original bitmap
	setstretchbltmode(bm.gdi.hdc,4)			!average pixels for best result

	bmputpalette(bm,palette)

	return bm
end

global function bmgetpalette(bm)=
	if bm.paltype then
		palette:=new(array,int32,0..256)
		getdibcolortable(bm.gdi.hdc,0,256,&palette)
		palette[256]:=bm.paltype
		reversepalette(palette)
	else
		palette:=()
	fi
	return palette
end

global proc bmputpalette(bm,p,reverse=1)=
	if bm.paltype then
		if reverse then reversepalette(p) fi		!fix colours
		setdibcolortable(bm.gdi.hdc,0,256,&p)	!store
		if reverse then reversepalette(p) fi			!restore orignal palette
		if p.upb=256 then
			bm.paltype:=p[256]
		fi
	fi
end

global function bmcolour(bm,n,?colour)=

	if colour.isdef then		!set colour
		colour:=revpixel(colour)
		setdibcolortable(bm.gdi.hdc,n,1,&colour)
		return colour
	else				!get colour
		colour:=0
		getdibcolortable(bm.gdi.hdc,n,1,&colour)
		return revpixel(colour)
	fi
end

global proc reversepalette(&p)=
	for i:=0 to 255 do
		p[i]:=revpixel(p[i])
	od
end

global function revpixel(a)=
return (a iand 0x00ff00) ior (a>>16 iand 255) ior ((a iand 255)<<16)
end

global proc bmshow(bm)=
	gxcopy(bm)
	waitkey()
end

global proc bmfree(bm)=
	return if bm=nil
	if not deletedc(bm.gdi.hdc) then
		pcerror("ERROR DELETING BM/HDC")
	fi

	if not deleteobject(bm.gdi.hwnd) then
		pcerror("ERROR DELETING DIB")
	fi
end

global function bmdupl(bm)=
	newbm:=bmcreate(bm.pixelbits, bm.dimx, bm.dimy)
	memcpy(newbm.pixelptr, bm.pixelptr, bm.linebytes*bm.dimy)

	bmduplpalette(newbm,bm)

	return newbm
end

global proc bmduplpalette(newbm,bm)=
	if bm.paltype then
		pal:=bmgetpalette(bm)
		bmputpalette(newbm,pal)
		newbm.paltype:=bm.paltype
	fi
end

global function bmduplz(bm)=
	newbm:=bmcreate(bm.pixelbits, bm.dimx, bm.dimy)
	return newbm
end

global function bmgetptr(bm,x,y)=
	return bm.pixelptr+(bm.linebytes*y+x*bm.pixelbytes)
end

global function bmgetrowptr(bm,y)=
	return bm.pixelptr+y*bm.linebytes
end

function getcbbitmap(hwnd)=

	p:=globallock(hwnd)
	hsize:=ws_bitmapinfoheader.bytes
	bm:=nil

	if p then
		p:=makeref(p,ws_bitmapinfoheader)
		pb:=makeref(p,byte)

		bm:=bmcreate(p^.bitcount,p^.width,p^.height)
		offset:=(bm.paltype|1024|0)		!offset due to palette table

		if offset then
			setdibcolortable(bm.gdi.hdc,0,256,pb+hsize)
		fi

		pb:=pb+hsize+offset
		for y:=0 to bm.dimy-1 do
			q:=bmgetrowptr(bm,bm.dimy-y-1)
			memcpy(q,pb,bm.linebytes)
			pb:=pb+bm.linebytes
		od

	fi

	globalunlock(hwnd)

	return bm
end

global function bmgetclipboard=
	if openclipboard(0)=0 then
		return nil
	fi

	hwnd:=getclipboarddata(cf_dib)

	bm:=nil
	if hwnd then
		bm:=getcbbitmap(hwnd)
	fi

	closeclipboard()

	return bm
end

global function bmputclipboard(bm)=
	if openclipboard(0)=0 then
		return nil
	fi

	emptyclipboard()

	hwnd:=putcbbitmap(bm)
	if hwnd then
		setclipboarddata(cf_dib,hwnd)
	fi

	closeclipboard()
	return 1
end

function putcbbitmap(bm)=
	hsize:=ws_bitmapinfoheader.bytes
	psize:=(bm.paltype|1024|0)
	fsize:=bm.linebytes*bm.dimy

	hmem:=globalalloc(0,hsize+psize+fsize)
	mem:=makeref(globallock(hmem),byte)

	hdr:=new(ws_bitmapinfoheader)
	hdr.size:=hsize
	hdr.width:=bm.dimx
	hdr.height:=bm.dimy
	hdr.bitcount:=bm.pixelbits
	hdr.planes:=1
	hdr.xpelspermetre:=11811
	hdr.ypelspermetre:=11811
	hdr.clrused:=0

	memcpy(mem,&hdr,hsize)

	if psize then
		pal:=bmgetpalette(bm)
		memcpy(mem+hsize,&pal,psize)
	fi

	mem:=mem+hsize+psize
	for y:=0 to bm.dimy-1 do
		p:=bmgetrowptr(bm,bm.dimy-1-y)
		memcpy(mem, p, bm.linebytes)
		mem:=mem+bm.linebytes
	od
	globalunlock(hmem)

	return hmem
end

proc copy24to8(newbm,oldbm)=
	for y:=0 to oldbm.dimy-1 do
		p:=bmgetrowptr(newbm,y)
		q:=bmgetrowptr(oldbm,y)
		to oldbm.dimx do
			p++^:=q^
			q:=q+3
		od
	od
end


global proc bmresetpalette(bm)=
# set palette back to greyscale
	pal:=new(array,int32,0..256)
	colour:=0
	for i:=0 to 255 do
		pal[i]:=colour
		colour+:=0x010101
	od
	bmputpalette(bm,pal)
	bm.paltype:=greyscale_pal
end

function makescalemap(x)=
	map:=new(list,0..255)
	for i:=0 to 255 do
		map[i]:=clamp(int(round(i*x)),0,255)
	od
	return map
end

function bmunimpl(mess)=
PRINTLN "UNIMPLEMENTED:",MESS
PRINTLN "ABORTING"
STOP
return 0
end


global function bmload(filename)=
	case e:=convlc(extractext(filename))
	when "jpg","jpeg" then
		return bmloadjpg(filename)
	when "bmp" then
		return bmloadbmp(filename)
	when "pgm" then
		return bmloadpgm_p2p5(filename)
	when "ppm" then
		return bmloadppm_p3p6(filename)
	when "pbm" then
		return bmloadpbm_p1p4(filename)
	when "png" then
		return bmloadpng(filename)
	when "" then				!try all
		exts:=("jpg","bmp","pgm","ppm","png")
		forall ext in exts do
			bm:=bmload(addext(filename,ext))
			if bm then
				return bm
			fi
		od
		return nil
	else
		println "CAN'T LOAD",E,"IMAGE"
		return nil
	esac
	return nil
end

function bmloadbmp(filename)=
	f:=openfile(filename)
	if not f then return nil fi

	fileheader:=new(bmpheader)

	readrandom(f,&fileheader,0,bmpheader.bytes)
	filedimx:=fileheader.bh.width
	filedimy:=fileheader.bh.height
	invert:=1
	if filedimy<0 then
		filedimy:=abs(filedimy)
		invert:=0
	fi

	if fileheader.fh.typex<>'BM' then
		closefile(f)
		return nil
	fi

	if fileheader.bh.compression<>0 then
		closefile(f)
		return nil
	fi

	bm:=bmcreate(fileheader.bh.bitcount,filedimx,filedimy)
	framebytes:=bm.linebytes*filedimy

	if bm.paltype then
		palette:=new(array,int32,0..255)
		readrandom(f,&palette,bmpheader.bytes,1024)
		bmputpalette(bm,palette,0)
		colour:=0
		for i:=0 to 255 do
			if palette[i]<>colour then
				bm.paltype:=colour_pal
				exit
			fi
			colour+:=0x010101
		od

	fi

	readrandom(f,bm.pixelptr,fileheader.fh.offbits,framebytes)
	closefile(f)


	if invert then
		n:=bm.linebytes
		buffer:=makeref(malloc(n),byte)

		for y:=0 to filedimy%2 do
			p:=bmgetrowptr(bm,y)
			q:=bmgetrowptr(bm,filedimy-1-y)
			memcpy(buffer,p,n)
			memcpy(p,q,n)
			memcpy(q,buffer,n)
		od
		free(buffer)
	fi

	return bm
end

function bmloadjpg(filename)=
	w:=h:=n:=0


	p:=imgload_bgr(filename,&w,&h,&n,0)

	pixelbits:=n*8

	if p=nil then
		return nil
	fi

	q:=makeref(p,byte)

	bm:=bmcreate(pixelbits,w,h)

	nbytes:=w*h*n
	dest:=makeref(bm.pixelptr,byte)

	to h do
		memcpy(dest,q,w*n)
		dest:=dest+bm.linebytes
		q:=q+w*n
	od

	imgload_free(p)

	return bm
end

function bmloadpbm_p1p4(filename)=
CPL "CAN'T LOAD PBM"
RETURN NIL
end

function bmloadpgm_p2p5(filename)=
CPL "CAN'T LOAD PGM"
RETURN NIL

end

function bmloadppm_p3p6(filename)=

	f:=openfile(filename,"rb")
	if f=0 then return nil fi

	readln @f, sig:"s"

	case sig
	when "P6" then
		binary:=1
	when "P3" then
		binary:=0
	when "P5","P2" then
		return bmloadpgm_p2p5(file)
	when "P4","P1" then
		return bmloadpbm_p1p4(file)
	else
		abort("Can't read ppm/P3")
		return nil
	esac	


	width:=readnextint(f)
	height:=readnextint(f)
	maxpix:=readnextint(f)

	bm:=bmcreate(24,width,height)

	linebytes:=width*3
	dest:=makeref(bm.pixelptr,byte)

	to height do
		if binary then
			readbytes(f,dest,linebytes)			!will be bgr
		else
			p:=dest
			to linebytes do
				p++^:=readffint(f)
			od
		fi

		p:=dest								!convert to rgb
		to width do
			swap(p^,(p+2)^)
			p:=p+3
		od

		dest:=dest+bm.linebytes
	od

	closefile(f)

	return bm
end

function readnextint(f)=
	read x
	while not x.isint and not eof(f) do
		readln @f,x
	od
	if not x.isint then return 0 fi
	return x
end

function readffint(f)=
	repeat
		c:=inbyte(f)
	until c in '0'..'9'

	a:=c-'0'
	do
		c:=inbyte(f)
		if c in '0'..'9' then
			a:=a*10+c-'0'
		else
			exit
		fi
	od

	return a
end

function bmloadpng(filename)=
RETURN BMLOADJPG(FILENAME)
end

global function bmsave(filename,bm,binary=1)=
	case e:=convlc(extractext(filename))
	when "jpg","jpeg" then
		return bmsavejpg(filename,bm)
	when "bmp" then
		return bmsavebmp(filename,bm)
	when "ppm" then
		return bmsaveppm_p3p6(filename,bm,binary)
	when "pgm" then
		return bmsavepgm_p2p5(filename,bm,binary)
	when "pbm" then
		return bmsavepbm_p1p4(filename,bm,binary)
	else
		println "CAN'T SAVE",E,"IMAGE"
		return nil
	esac
	return nil
end

function bmsavebmp(filename,bm)=
	w:=bm.dimx
	h:=bm.dimy
	pixelbytes:=bm.pixelbytes
	framebytes:=bm.linebytes*h
	palettebytes:=(pixelbytes=1|1024|0)

	bmfile:=createfile(filename)
	if bmfile=nil then
		return 0
	fi

	fileheader:=new(bmpheader)

	fileheader.fh.typex:='BM'
	fileheader.fh.offbits:=bmpheader.bytes+palettebytes
	fileheader.fh.size:=fileheader.fh.offbits+framebytes
	fileheader.bh.size:=ws_bitmapinfoheader.bytes
	fileheader.bh.width:=bm.dimx
	fileheader.bh.height:=-bm.dimy
	fileheader.bh.bitcount:=bm.pixelbits
	fileheader.bh.planes:=1
	fileheader.bh.xpelspermetre:=11811		!300 dpi
	fileheader.bh.ypelspermetre:=11811
	fileheader.bh.clrused:=0

	writerandom(bmfile,&fileheader,0,bmpheader.bytes)

	if palettebytes then
		palette:=bmgetpalette(bm)
		reversepalette(palette)
		writerandom(bmfile,&palette,bmpheader.bytes,palettebytes)
	fi

	writerandom(bmfile,bm.pixelptr,fileheader.fh.offbits,framebytes)

	return closefile(bmfile)
end

function bmsavejpg(filename,bm)=
	w:=bm.dimx
	h:=bm.dimy
	pixelbytes:=bm.pixelbytes
	linebytes:=bm.linebytes

	p:=q:=malloc(pixelbytes*w*h)

	s:=makeref(bm.pixelptr,byte)

	to h do
		memcpy(q,s,w*pixelbytes)
		q:=q+bm.linebytes
		s:=s+w*pixelbytes
	od

	status:=imgsave_jpeg_bgr(filename,p,w,h,pixelbytes)

	free(p)

	return status
end

function bmsavepbm_p1p4(filename,bm,binary)=
return bmunimpl("bmsaveppm")
end

function bmsavepgm_p2p5(filename,bm,binary)=
return bmunimpl("bmsavepgm")
end

function bmsaveppm_p3p6(filename,bm,binary)=

	width:=bm.dimx
	height:=bm.dimy

	case bm.pixelbits
	when 24 then
	when 8 then
		return bmsavepgm_p2p5(filename,bm,binary)
	else
		return 0
	esac

	f:=createfile(changeext(filename,"ppm"))

	CPL "WRITEPPM",CHANGEEXT(FILENAME,"PPM")

	if not f then return 0 fi

	println @f,(binary|"P6"|"P3")
	println @f,width
	println @f,height
	println @f,"255"
	buffer:=data

	buffer:=malloc(bm.linebytes)
	if buffer=nil then return 0 fi
	buffer:=makeref(buffer,byte)

	linebytes:=width*3			!also number of values per line when in text mode

	for y:=0 to height-1 do
		memcpy(buffer,bmgetrowptr(bm,y),linebytes)
		p:=buffer					!convert to bgr
		to width do
			swap(p^,(p+2)^)
			p:=p+3
		od
		if binary then
			writebytes(f,buffer,linebytes)
		else
			p:=buffer
			to linebytes do
				print @f,p++^,," "
			od
			println @f
		fi
	od
	closefile(f)
	return 1
end

global function bmrotate(bm, angle)=
	case angle
	when 0 then return bmdupl(bm)
	when -90 then return bmrotleft90(bm)
	when +90 then return bmrotright90(bm)
	when 180 then return rot180(bm)
	esac
	return bmunimpl("bmrotate by "+tostr(angle))
end

global function bmrotleft90(bm)=
	case bm.pixelbits
	when 8 then return rotleft90_8(bm)
	when 24 then return rotleft90_24(bm)
	when 32 then return bmunimpl("ROTLEFT90/32")
	esac
	return nil
end

global function bmrotright90(bm)=
	case bm.pixelbits
	when 8 then return rotright90_8(bm)
	when 24 then return rotright90_24(bm)
	when 32 then return bmunimpl("ROTRIGHT90/32")
	esac
	return nil
end

global function rot180(bm)=
	newbm1:=bmfliphoz(bm)
	newbm2:=bmflipvert(newbm1)
	bmfree(newbm1)
	return newbm2
end

function rotleft90_8(bm)=
	w:=bm.dimx
	h:=bm.dimy
	linebytes:=bm.linebytes

	newbm:=bmcreate(8,h,w)

	for y:=0 to w-1 do
		q:=bmgetptr(bm,w-y-1,0)
		p:=bmgetrowptr(newbm,y)

		to h do
			p++^:=q^
			q:=q+linebytes
		od
	od

	bmduplpalette(newbm,bm)
	return newbm
end

function rotright90_8(bm)=
	w:=bm.dimx
	h:=bm.dimy
	linebytes:=bm.linebytes

	newbm:=bmcreate(8,h,w)

	for y:=0 to w-1 do
		q:=bmgetptr(bm,y,h-1)
		p:=bmgetrowptr(newbm,y)

		to h do
			p++^:=q^
			q:=q-linebytes
		od
	od

	bmduplpalette(newbm,bm)
	return newbm
end


function rotleft90_24(bm)=
	w:=bm.dimx
	h:=bm.dimy

	newbm:=bmcreate(24,h,w)

	for y:=0 to w-1 do
		q:=bmgetptr(bm,w-y-1,0)
		p:=bmgetrowptr(newbm,y)

		to h do
			p++^:=q^
			p++^:=(q+1)^
			p++^:=(q+2)^
			q:=q+bm.linebytes
		od
	od

	return newbm
end


function rotright90_24(bm)=
	w:=bm.dimx
	h:=bm.dimy

	newbm:=bmcreate(24,h,w)

	for y:=0 to w-1 do
		q:=bmgetptr(bm,y,h-1)
		p:=bmgetrowptr(newbm,y)

		to h do
			p++^:=q^
			p++^:=(q+1)^
			p++^:=(q+2)^
			q:=q-bm.linebytes
		od
	od

	return newbm
end

function rotate8(bm,angle)=
return bmunimpl("rotate8")
end

global function bmfliphoz(bm)=
	case bm.pixelbytes
    when 1 then return fliphoz8(bm)
    when 3 then return fliphoz24(bm)
    when 4 then return fliphoz32(bm)
	esac
	return nil
end

function fliphoz8(bm)=
	newbm:=bmdupl(bm)

	w:=newbm.dimx
	h:=newbm.dimy
	buffer:=makeref(malloc(bm.linebytes),byte)

	for y:=0 to h-1 do
		p:=bmgetrowptr(newbm,y)
		q:=p+w-1
		for x:=0 to w%2 do
			t:=p^
			p^:=q^
			q^:=t
			++p; --q
		od
	od

	return newbm
end

function fliphoz24(bm)=
	newbm:=bmdupl(bm)

	w:=newbm.dimx
	h:=newbm.dimy
	buffer:=makeref(malloc(bm.linebytes),byte)

	for y:=0 to h-1 do
		p:=bmgetrowptr(newbm,y)
		memcpy(buffer,p,bm.linebytes)
		q:=buffer+(w-1)*3

		to w do
			p++^:=q++^
			p++^:=q++^
			p++^:=q^

			q:=q-5
		od
	od

	return newbm
end

function fliphoz32(bm)=
return bmunimpl("fliphoz_32")
end

global function bmflipvert(bm)=
	newbm:=bmdupl(bm)

	w:=newbm.dimx
	h:=newbm.dimy
	n:=bm.linebytes
	buffer:=makeref(malloc(n),byte)

	for y:=0 to h%2 do
		p:=bmgetrowptr(newbm,y)
		q:=bmgetrowptr(newbm,h-1-y)
		memcpy(buffer,p,n)
		memcpy(p,q,n)
		memcpy(q,buffer,n)
	od
	free(buffer)

	return newbm
end

global function bmrepeat(bm,cols,rows)=
	w:=bm.dimx
	h:=bm.dimy
	newbm:=bmcreate(bm.pixelbits, w*cols, h*rows)
	linebytes:=bm.linebytes

	for y:=0 to h-1 do
		s:=bmgetrowptr(bm,y)
		for r:=0 to rows-1 do
			for c:=0 to cols-1 do
				memcpy(bmgetptr(newbm,c*w,r*h+y),s,linebytes)
			od
		od
	od

	if bm.pixelbits=8 then
		bmduplpalette(newbm,bm)
	fi

	return newbm
end

global function bmscale(bm, sx,?sy)=
	if sy.isvoid then sy:=sx fi
	case bm.pixelbits
	when 8 then return scalex8(bm,sx,sy)
	when 24,32 then return scalex24(bm,sx,sy)
	esac
	return nil
end

function scalex8(bm,sx,sy)=
	w:=bm.dimx
	h:=bm.dimy

	neww:=int(round(w*sx))
	newh:=int(round(h*sy))

	newbm:=bmcreate(24, neww,newh)
	return nil when not newbm

	bm24:=bmtorgb(bm,24)

	stretchblt(newbm.gdi.hdc,0,0,neww,newh,bm24.gdi.hdc,0,0,w,h, srccopy)

	if bm.paltype=greyscale_pal then
		newbm8:=bmgetplane(newbm,"R")
	else
		newbm8:=bmtopal(newbm)
	fi
	bmfree(newbm)
	
	return newbm8
end

function scalex24(bm,sx,sy)=
	w:=bm.dimx
	h:=bm.dimy

	neww:=int(round(w*sx))
	newh:=int(round(h*sy))

	if neww<8 or newh<8 then return nil fi

	newbm:=bmcreate(bm.pixelbits, neww,newh)
	if newbm then
		stretchblt(newbm.gdi.hdc,0,0,neww,newh,bm.gdi.hdc,0,0,w,h, srccopy)
	fi

	return newbm
end

function bmscaleupi8(bm,sx,sy)=
return bmunimpl("bmscaleupi8")
end

function bmscaleupi24(bm,sx,sy)=
return bmunimpl("bmscaleupi24")
end

function bmscaleupi32(bm,sx,sy)=
return bmunimpl("bmscaleupi32")
end

function bmscaledowni8(bm,sx,sy)=
return bmunimpl("bmscaledowni8")
end

function bmscaledowni24(bm,sx,sy)=
return bmunimpl("bmscaledowni24")
end

function bmscaledowni32(bm,sx,sy)=
return bmunimpl("bmscaledowni32")
end

global function bmneg(bm)=
	newbm:=bmdupl(bm)

	dx:=newbm.dimx-1
	dy:=newbm.dimy-1
	n:=newbm.linebytes
	do32:=0
	if n rem 4=0 then
		do32:=1
		n:=n%4
	fi

	for y:=0 to dy do
		if do32 then
			p:=makeref(bmgetrowptr(newbm,y),int32)
			to n do
				p++^ := p^ ixor 0xFFFFFFFF
			od
		else
			p:= bmgetrowptr(newbm,y)
			to n do
				p++^ := p^ ixor 255
			od
		fi
	od
	return newbm
end

global function bmmap(bm,map, channels="RGB")=
	if channels="" then channels:="RGB" fi

	case bm.pixelbits
	when 8 then
		return mapall(bm,map)
	when 24 then
		if channels="RGB" then
			return mapall(bm,map)
		fi
		return mapchan_24(bm,map,channels,0)
	when 32 then
		if channels="RGBA" then
			return mapall(bm,map)
		fi
		return mapchan_24(bm,map,channels,1)
	esac

	return nil
end

function mapall(bm,map)=
	newbm:=bmdupl(bm)
	p:=newbm.pixelptr
	to newbm.framebytes do
		p^:=map[p^]
		++p
	od
	return newbm
end

function mapchan_24(bm,map,channels,alpha=0)=
	dored:="R" in channels
	dogreen:="G" in channels
	doblue:="B" in channels
	doalpha:="A" in channels

	newbm:=bmdupl(bm)

	for y:=0 to newbm.dimy-1 do
		p:=bmgetrowptr(newbm,y)
		to newbm.dimx do
			if doblue then p^:=map[p^] fi
			++p
			if dogreen then p^:=map[p^] fi
			++p
			if dored then p^:=map[p^] fi
			++p
			if alpha then
				if doalpha then p^:=map[p^] fi
				++p
			fi
		od
	od

	return newbm
end


global function bmbright(bm,dx,channels="RGB")=
return bmunimpl("bmbright")
end

global function bmcont(bm,x,channels="RGB")=
return bmunimpl("bmcont")
end

global function bmgamma(bm,x,channels="RGB")=
return bmunimpl("bmgamma")
end

global function bmtogrey(bm,destbits=24)=
	if destbits=0 then destbits:=bm.pixelbits fi
	case bm.pixelbits
	when 8 then
		case destbits
		when 8 then
			return pal8togrey8(bm)
		when 24 then
			cm:=pal8togrey8(bm)
			newbm:=grey8torgb24(cm)
			bmfree(cm)
			return newbm
		esac
	when 24,32 then
		case destbits
		when 8 then
			return rgb24togrey8(bm)
		when 24 then
			cm:=rgb24togrey8(bm)
			newbm:=grey8torgb24(cm)
			bmfree(cm)
			return newbm
		esac
	esac
CPL =BM.PIXELBITS, =DESTBITS
	return bmunimpl("bmtogrey bad combos")

end

function pal8togrey8(bm)=
	w:=bm.dimx
	h:=bm.dimy

	(rmap, gmap, bmap):=getlumtables()

	newbm:=bmcreate(8,w,h)
	pal:=bmgetpalette(bm)

	for y:=0 to h-1 do
		p:=bmgetrowptr(newbm,y)
		q:=bmgetrowptr(bm,y)

		to w do
			colour:=pal[q++^]
			r:=colour.[0..7]
			g:=colour.[8..15]
			b:=colour.[16..23]
			p++^:=rmap[r]+gmap[g]+bmap[b]
		od
	od

	return newbm
end

function pal8togrey24(bm)=
return bmunimpl("pal8togrey24")
end

function rgb24togrey8(bm)=
	qincr:=(bm.pixelbits=32)
	w:=bm.dimx
	h:=bm.dimy

	(rmap, gmap, bmap):=getlumtables()

	newbm:=bmcreate(8,w,h)

	for y:=0 to h-1 do
		p:=bmgetrowptr(newbm,y)
		q:=bmgetrowptr(bm,y)

		to w do
			b:=q++^; g:=q++^; r:=q++^
			p++^:=rmap[r]+gmap[g]+bmap[b]
			q:=q+qincr
		od
	od

	return newbm
end

function rgb24togrey24(bm)=
return bmunimpl("rgb24togrey24")
end

global function bmtorgb(bm,destbits=24)=
	if destbits=0 then destbits:=24 fi
	case bm.pixelbits
	when destbits then
		return bmdupl(bm)

	when 8 then
		case destbits
		when 8 then
			bmunimpl("8 to 8 bits rgb")
		when 24 then
			if bm.paltype=greyscale_pal then
				return grey8torgb24(bm)
			else
				return paltorgb24(bm)
			fi
		esac
	when 24 then
		if destbits=32 then
			return bmrgb24torgb32(bm)
		fi
	when 32 then
		if destbits=24 then
			return bmrgb32torgb24(bm)
		fi
	esac
CPL =BM.PIXELBITS, =DESTBITS
	return bmunimpl("bmtorgb bad combos")
end

function paltorgb24(bm)=
	w:=bm.dimx
	h:=bm.dimy

	newbm:=bmcreate(24,w,h)
	pal:=bmgetpalette(bm)

	for y:=0 to h-1 do
		p:=bmgetrowptr(newbm,y)
		q:=bmgetrowptr(bm,y)

		to w do
			colour:=pal[q++^]
			r:=colour.[0..7]
			g:=colour.[8..15]
			b:=colour.[16..23]

			p++^:=b
			p++^:=g
			p++^:=r
		od
	od

	return newbm
end

function grey8torgb24(bm)=
	w:=bm.dimx
	h:=bm.dimy

	newbm:=bmcreate(24,w,h)

	for y:=0 to h-1 do
		p:=bmgetrowptr(newbm,y)
		q:=bmgetrowptr(bm,y)

		to w do
			lum:=q++^
			p++^:=lum
			p++^:=lum
			p++^:=lum
		od
	od

	return newbm
end

global function bmrgb24torgb32(bm)=
	w:=bm.dimx
	h:=bm.dimy
	newbm:=bmcreate(32,w,h)

	for y:=0 to h-1 do
		q:=bmgetrowptr(bm,y)
		p:=bmgetrowptr(newbm,y)
		to w do
			p++^:=q++^
			p++^:=q++^
			p++^:=q++^
			p++^:=128
		od
	od
	return newbm
end

global function bmrgb32torgb24(bm)=
	w:=bm.dimx
	h:=bm.dimy
	newbm:=bmcreate(24,w,h)

	for y:=0 to h-1 do
		q:=bmgetrowptr(bm,y)
		p:=bmgetrowptr(newbm,y)
		to w do
			p++^:=q++^
			p++^:=q++^
			p++^:=q++^
			q++
		od
	od
	return newbm
end

global function bmtopal(bm)=
	if bm.pixelbits=8 then return bmdupl(bm) fi
	qincr:=(bm.pixelbits=32)
	w:=bm.dimx
	h:=bm.dimy

	newbm:=bmcreate(8,w,h)

	pal:=new(array,int32,0..255)

	for r:=0 to 7 do
		for g:=0 to 7 do
			for b:=0 to 3 do
				index:=r<<5+g<<2+b
				pal[index]:=r<<5+g<<13+b<<22
			od
		od
	od
	bmputpalette(newbm,pal)
	bm.paltype:=colour_pal

	for y:=0 to h-1 do
		p:=bmgetrowptr(newbm,y)
		q:=bmgetrowptr(bm,y)


		to w do
			b:=q++^; g:=q++^; r:=q++^

			p++^:=r>>5<<5 + g>>5<<2 + b>>6
			q:=q+qincr
		od
	od

	return newbm

end

global function bmsplittorgb(bm,greydest=1)=
# split 24-bit bitmap into three separate 8-bit planes
# return 3 new bitmaps in the order red, green, blue
# return () on error
# dogreyscale=1 for each image to have a greyscale palette. Otherwise
# the red image will be shades of red, etc

	if bm.pixelbits<24 then
		return ()
	fi
	channels:=bm.pixelbytes

	w:=bm.dimx
	h:=bm.dimy

	pal:=new(array,int32,0..255)
	images:=()

	for offset:=channels-1 downto 0 do

		newbm:=bmcreate(8,w,h)

		for y:=0 to h-1 do
			q:=bmgetrowptr(bm,y)+offset
			p:=bmgetrowptr(newbm,y)
			to w do
				p++^:=q^
				q:=q+channels
			od
		od

		if not greydest then
			colour:=0
			incr:=(3-offset|0x00'00'01,0x00'01'00,0x01'00'00|0x01'01'01)
			for i:=0 to 255 do
				pal[i]:=colour
				colour+:=incr
			od
			bmputpalette(newbm,pal)
			newbm.paltype:=tinted_pal
		fi

		images append:=newbm
	od

	if images.len=4 then
		return (images[2],images[3],images[4],images[1])
	else
		return images
	fi
end

global function bmsplittoyuv(bm)=
# split 24-bit bitmap into three separate 8-bit planes
# return 3 new bitmaps in the order y, u, v
# return () on error

	needfree:=0
	case bm.pixelbits
	when 24 then
	when 32 then
		bm:=bmtorgb(bm,24)
		needfree:=1
	else
		return nil
	esac

	greybm:=bmtogrey(bm,8)

	w:=bm.dimx
	h:=bm.dimy


	umap:=new(list,-255..255)
	vmap:=new(list,-255..255)
	for i:=-255 to 255 do
		umap[i]:=int(round(0.492*(i)+128))
		vmap[i]:=int(round(0.702*(i)+128))
	od

	ubm:=bmcreate(8,w,h)
	vbm:=bmcreate(8,w,h)
	for c:=1 to 2 do
		if c=1 then
			offset:=0
			map:=umap
		else
			offset:=2
			map:=vmap
		fi

		for yy:=0 to h-1 do
			py:=bmgetrowptr(greybm,yy)
			p:=bmgetrowptr(bm,yy)			!point to bgr pixels in original

			pu:=bmgetrowptr(ubm,yy)
			pv:=bmgetrowptr(vbm,yy)
			to w do
				y:=py++^
				r:=(p+2)^
				b:=p^
				pu++^:=umap[b-y]
				pv++^:=vmap[r-y]

				p:=p+3
			od
		od
	od

	pal:=new(array,int32,0..256)
	colour:=0
	pal[128]:=0
	for i:=1 to 127 do
		colour+:=0x020202
		pal [i+128]:=colour
		pal [128-i]:=colour
	od
	pal[256]:=uv_pal
	bmputpalette(ubm,pal)
	bmputpalette(vbm,pal)

	if needfree then
		bmfree(bm)
	fi

	return (greybm,ubm,vbm)
end

global function bmgetplane(bm,plane)=
# plane is one of "R","G","B"
# extract given plane of a 24-bit bitmaps into a single 8-bit greyscale image
# Return new image

	incr:=bm.pixelbytes
	if plane.len<>1 or bm.pixelbytes<3 then
		return nil
	fi

	case asc(plane)
	when 'R' then offset:=2
	when 'G' then offset:=1
	when 'B' then offset:=0
	when 'A' then offset:=3
	else return nil
	esac

	w:=bm.dimx
	h:=bm.dimy
	newbm:=bmcreate(8,w,h)

	for y:=0 to h-1 do
		q:=bmgetrowptr(bm,y)+offset
		p:=bmgetrowptr(newbm,y)
		to w do
			p++^:=q^
			q:=q+incr
		od
	od

	return newbm
end

global function bmjoinrgb(redbm,greenbm,bluebm,alphabm=nil)=

	w:=redbm.dimx
	h:=redbm.dimy

	newbm:=bmcreate((alphabm|32|24),w,h)

	for y:=0 to h-1 do
		p:=bmgetrowptr(newbm,y)

		r:=bmgetrowptr(redbm,y)
		g:=bmgetrowptr(greenbm,y)
		b:=bmgetrowptr(bluebm,y)

		if alphabm then
			a:=bmgetrowptr(alphabm,y)
			to w do
				p++^:=b++^
				p++^:=g++^
				p++^:=r++^
				p++^:=a++^
			od
		else
			to w do
				p++^:=b++^
				p++^:=g++^
				p++^:=r++^
			od
		fi
	od

	return newbm
end

global function bmjoinyuv(ybm,ubm,vbm)=
# combine y, u, v separations into a single rgb image
# return new bitmap, or nil

	if ybm.pixelbits<>8 then
		return nil
	fi

	w:=ybm.dimx
	h:=ybm.dimy

	v1425map:=new(list,0..255)
	v726map:=new(list,0..255)
	u395map:=new(list,0..255)
	u2032map:=new(list,0..255)

	for i:=0 to 255 do
		v1425map[i]:=int(round(1.425*(i-128)))
		v726map[i]:=int(round(0.726*(i-128)))
		u395map[i]:=int(round(0.395*(i-128)))
		u2032map[i]:=int(round(2.032*(i-128)))
	od

	newbm:=bmcreate(24,w,h)

	for yy:=0 to h-1 do
		p:=bmgetrowptr(newbm,yy)
		qy:=bmgetrowptr(ybm,yy)
		qu:=bmgetrowptr(ubm,yy)
		qv:=bmgetrowptr(vbm,yy)

		FOR X:=0 TO W-1 DO
			y:=qy++^
			r:=y+v1425map[qv^]
			g:=y-u395map[qu^]-v726map[qv^]
			b:=y+u2032map[qu^]
			++qu
			++qv
			p++^:=clamp(b,0,255)
			p++^:=clamp(g,0,255)
			p++^:=clamp(r,0,255)
		od
	od
	return newbm
end

global function bmblur(bm,n)=
	case bm.pixelbits
	when 8 then
		return blur8(bm,n)
	when 24 then
		return blur24(bm,n)
	when 32 then
		return blur32(bm,n)
	esac
	return nil
end

function blur8(bm,n)=
	shift:=shifts{n,1}

	newbm:=bmdupl(bm)
	iblurhoz8(newbm,n)

	newbm2:=rotleft90_8(newbm)
	iblurhoz8(newbm2,n)

	newbm3:=rotright90_8(newbm2)
	bmfree(newbm)
	bmfree(newbm2)

	bmduplpalette(newbm3,bm)
	return newbm3
end

function blur24(bm,n)=
	(r,g,b):=bmsplittorgb(bm)

	r2:=bmblur(r,n)
	g2:=bmblur(g,n)
	b2:=bmblur(b,n)

	newbm:=bmjoinrgb(r2,g2,b2)
	bmfree(r2)
	bmfree(g2)
	bmfree(b2)

	return newbm
end

function blur32(bm,n)=
return bmunimpl("blur32")
end

proc iblurhoz8(bm,n)=
	shift:=shifts{n,1}

	w:=bm.dimx
	h:=bm.dimy

	for y:=0 to h-1 do
		p:=bmgetrowptr(bm,y)
		to w-n-1 do
			sum:=0
			q:=p
			to n do
				sum+:=q++^
			od
			p++^:=sum>>shift
		od
	od
end

function blurhoz24(bm,n)=
return bmunimpl("blurhoz24")
end

function blurhoz32(bm,n)=
return bmunimpl("blurhoz32")
end

global function bmsharpen(bm,n=0)=
	case bm.pixelbits
	when 8 then
		return sharpen8(bm,n)
	when 24 then
		return sharpen24(bm,n)
	when 32 then
		return sharpen32(bm,n)
	esac
	return nil
end

global function sharpen8(bm,n)=

	w:=bm.dimx
	h:=bm.dimy

	newbm:=bmdupl(bm)

	for y:=1 to h-2 do
		p:=bmgetptr(newbm,1,y)

		q:=bmgetptr(bm,1,y-1)
		r:=bmgetptr(bm,1,y)
		s:=bmgetptr(bm,1,y+1)

		to w-2 do
			a:=(q-1)^
			b:=q^
			c:=(q+1)^
			d:=(r-1)^
			e:=r^
			f:=(r+1)^
			g:=(s-1)^
			h:=s^
			i:=(s+1)^


			sum:=e*8-a-b-c-d-f-g-h-i
			p^:=clamp(p^+sum%8,0,255)


			++p
			++q
			++r
			++s
		od
	od

	return newbm

end

global function sharpen24(bm,n)=
	(r,g,b):=bmsplittorgb(bm)

	r2:=bmsharpen(r,n)
	g2:=bmsharpen(g,n)
	b2:=bmsharpen(b,n)

	newbm:=bmjoinrgb(r2,g2,b2)
	bmfree(r2)
	bmfree(g2)
	bmfree(b2)

	return newbm
end

global function sharpen32(bm,n)=
return bmunimpl("bmsharpen32")
end

function getlumtables=
	rmap:=makescalemap(0.299)
	gmap:=makescalemap(0.587)
	bmap:=makescalemap(0.111)
	return (rmap, gmap, bmap)
end
=== end ===
