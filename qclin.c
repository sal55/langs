// Generated C
#pragma GCC diagnostic ignored "-Wbuiltin-declaration-mismatch"

extern double sqrt(double);
extern double sin(double);
extern double cos(double);
extern double tan(double);
extern double asin(double);
extern double acos(double);
extern double atan(double);
extern double log(double);
extern double log10(double);
extern double exp(double);
extern double floor(double);
extern double ceil(double);
extern double atan2(double, double);
extern double fmod(double, double);
extern double pow(double, double);

typedef signed char		i8;
typedef short			i16;
typedef int				i32;
typedef long long int	i64;
typedef unsigned char			u8;
typedef unsigned short			u16;
typedef unsigned int			u32;
typedef unsigned long long int	u64;

typedef unsigned char byte;

typedef float r32;
typedef double r64;

extern void exit(i32);
extern void memset(u64, i32, u64);

#define asi8(x)  *(i8*)&x
#define asi16(x) *(i16*)&x
#define asi32(x) *(i32*)&x
#define asi64(x) *(i64*)&x

#define asu8(x)  *(u8*)&x
#define asu16(x) *(u16*)&x
#define asu32(x) *(u32*)&x
#define asu64(x) *(u64*)&x

#define asr32(x) *(r32*)&x
#define asr64(x) *(r64*)&x


#define toi8(x)  (i8)x
#define toi16(x) (i16)x
#define toi32(x) (i32)x
#define toi64(x) (i64)x

#define tou8(x)  (u8)x
#define tou16(x) (u16)x
#define tou32(x) (u32)x
#define tou64(x) (u64)x

#define tor32(x) (r32)x
#define tor64(x) (r64)x


#define toi8p(x)  (i8*)x
#define toi16p(x) (i16*)x
#define toi32p(x) (i32*)x
#define toi64p(x) (i64*)x

#define tou8p(x)  (u8*)x
#define tou16p(x) (u16*)x
#define tou32p(x) (u32*)x
#define tou64p(x) (u64*)x

#define tor32p(x) (r32*)x
#define tor64p(x) (r64*)x


i64 Getdotindex(u64 a, int i);
u64 Setdotindex(u64 a, i64 i, i64 x);
i64 Getdotslice(u64 a, i64 i, i64 j);
u64 Setdotslice(u64 a, i64 i, i64 j, u64 x);
i64 Poweri64(i64 a, i64 n);

#define Min(x, y) (x<=y ? x : y)
#define Max(x, y) (x>=y ? x : y)

i64 ncmdparams;
i64 nenvstrings;
char* (*cmdparams)[];
i64 $cmdskip;

/*
PROC START
*/
void qq_cli_main();
void (*entrypoint)(void) = qq_cli_main;

// ***** Types *****
struct $B1 {u64 a[10];};   // mem:80;
struct $B2 {u16 a[5];};   // mem:10;
struct $B3 {u64 a[2];};   // mem:16;
struct $B4 {u64 a[512];};   // mem:4096;
struct $B5 {u32 a[25];};   // mem:100;
struct $B6 {u64 a[40];};   // mem:320;
struct $B7 {u64 a[301];};   // mem:2408;
struct $B8 {u64 a[3];};   // mem:24;
struct $B9 {u32 a[3];};   // mem:12;
struct $B10 {u8 a[2049];};   // mem:2049;
struct $B11 {u64 a[9];};   // mem:72;
struct $B12 {u64 a[6];};   // mem:48;
struct $B13 {u32 a[9];};   // mem:36;
struct $B14 {u32 a[65];};   // mem:260;
struct $B15 {u32 a[75];};   // mem:300;
struct $B16 {u64 a[32];};   // mem:256;
struct $B17 {u64 a[140000];};   // mem:1120000;
struct $B18 {u64 a[1000];};   // mem:8000;
struct $B19 {u64 a[50];};   // mem:400;
struct $B20 {u16 a[25];};   // mem:50;
struct $B21 {u64 a[2000];};   // mem:16000;
struct $B22 {u64 a[250];};   // mem:2000;
struct $B23 {u64 a[256];};   // mem:2048;
struct $B24 {u64 a[64];};   // mem:512;
struct $B25 {u64 a[201];};   // mem:1608;
struct $B26 {u64 a[30];};   // mem:240;
struct $B27 {u64 a[100];};   // mem:800;
struct $B28 {u64 a[23];};   // mem:184;
struct $B29 {u8 a[23];};   // mem:23;
struct $B30 {u64 a[202];};   // mem:1616;
struct $B31 {u64 a[4];};   // mem:32;
struct $B32 {u64 a[524288];};   // mem:4194304;
struct $B33 {u64 a[1];};   // mem:8;
struct $B34 {u64 a[20];};   // mem:160;
struct $B35 {u64 a[12];};   // mem:96;
struct $B36 {u64 a[18];};   // mem:144;
struct $B37 {u16 a[101];};   // mem:202;
struct $B38 {u64 a[101];};   // mem:808;
struct $B39 {u64 a[33];};   // mem:264;
struct $B40 {u64 a[80];};   // mem:640;
struct $B41 {u16 a[3];};   // mem:6;
struct $B42 {u64 a[17];};   // mem:136;
struct $B43 {u64 a[41];};   // mem:328;
struct $B44 {u8 a[41];};   // mem:41;
struct $B45 {u64 a[92];};   // mem:736;
struct $B46 {u32 a[23];};   // mem:92;
struct $B47 {u64 a[132];};   // mem:1056;
struct $B48 {u64 a[27];};   // mem:216;
struct $B49 {u64 a[188];};   // mem:1504;
struct $B50 {u32 a[47];};   // mem:188;
struct $B51 {u64 a[61];};   // mem:488;
struct $B52 {u8 a[61];};   // mem:61;
struct $B53 {u8 a[27];};   // mem:27;
struct $B54 {u8 a[133];};   // mem:133;
struct $B55 {u8 a[7];};   // mem:7;
struct $B56 {u64 a[26];};   // mem:208;
struct $B57 {u32 a[33];};   // mem:132;
struct $B58 {u64 a[251];};   // mem:2008;
struct $B59 {u16 a[251];};   // mem:502;
struct $B60 {u8 a[251];};   // mem:251;
struct $B61 {u64 a[5000];};   // mem:40000;
struct $B62 {u64 a[625];};   // mem:5000;
struct $B63 {u64 a[7];};   // mem:56;
struct $B64 {u64 a[128];};   // mem:1024;
struct $B65 {u64 a[5];};   // mem:40;
struct $B66 {u32 a[15];};   // mem:60;
struct $B67 {u64 a[16];};   // mem:128;
struct $B68 {u8 a[1];};   // mem:0;
struct $B69 {u64 a[2048];};   // mem:16384;
struct $B70 {u64 a[45];};   // mem:360;
struct $B71 {u32 a[5];};   // mem:20;
struct $B72 {u64 a[320];};   // mem:2560;
struct $B73 {u64 a[200];};   // mem:1600;
struct $B74 {u32 a[125];};   // mem:500;
struct $B75 {u64 a[513];};   // mem:4104;
struct $B76 {u64 a[400];};   // mem:3200;
struct $B77 {u64 a[25];};   // mem:200;
struct $B78 {u64 a[257];};   // mem:2056;

// Function Ptr Types:
typedef i64 (*F1)();
typedef i64 (*F2)(i64);
typedef i64 (*F3)(i64, i64);
typedef i64 (*F4)(i64, i64, i64);
typedef i64 (*F5)(i64, i64, i64, i64);
typedef i64 (*F6)(i64, i64, i64, i64, i64);
typedef i64 (*F7)(i64, i64, i64, i64, i64, i64);
typedef i64 (*F8)(i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F9)(i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F10)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F11)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F12)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef r64 (*F13)();
typedef r64 (*F14)(i64);
typedef r64 (*F15)(i64, i64);
typedef u64 (*F16)();
typedef void (*F17)();
typedef void (*F18)(u64);
typedef void (*F19)(u64, u64);
typedef void (*F20)(u64, u64, u64);
typedef void (*F21)(u64, u64, u64, u64);
typedef void (*F22)(u64, u64, u64, u64, u64);

// ***** Variables *****
static i64 msysc_fmtparam;
i64 msysc_$cmdskip;
static i64 msysc_needgap;
static i64 msysc_outdev;
static u64 msysc_outchan;
static u64 msysc_fmtstr;
static struct $B1 msysc_outchan_stack;
static struct $B1 msysc_outdev_stack;
static struct $B1 msysc_fmtstr_stack;
static struct $B2 msysc_needgap_stack;
static struct $B1 msysc_ptr_stack;
static i64 msysc_niostack;
static struct $B3 msysc_digits;
static struct $B3 msysc_defaultfmt;
static u64 msysc_rd_buffer;
static i64 msysc_rd_length;
static u64 msysc_rd_pos;
static u64 msysc_rd_lastpos;
static i64 msysc_termchar;
static i64 msysc_itemerror;
static struct $B4 msysc_printbuffer;
static u64 msysc_printptr;
static i64 msysc_printlen;
static i64 msysc_ncmdparams;
static u64 msysc_cmdparams;
static struct $B3 msysc_getfmt_fmt;
static struct $B5 msysc_strint_str;
static struct $B5 msysc_strword_str;
static struct $B6 msysc_strreal_str;
static struct $B7 mlib_allocupper;
static i64 mlib_alloccode;
static i64 mlib_allocbytes;
static i64 mlib_fdebug;
static i64 mlib_rfsize;
static u64 mlib_maxmemory;
static i64 mlib_maxalloccode;
static u8 mlib_pcm_setup;
static i64 mlib_show;
static i64 mlib_memtotal;
static i64 mlib_smallmemtotal;
static i64 mlib_smallmemobjs;
static i64 mlib_maxmemtotal;
static struct $B8 mlib_memalloctable;
static struct $B9 mlib_memallocsize;
static u64 mlib_pcheapstart;
static u64 mlib_pcheapend;
static u64 mlib_pcheapptr;
static struct $B10 mlib_sizeindextable;
static struct $B11 mlib_freelist;
static struct $B12 mlib_pmnames;
static struct $B3 mlib_seed;
static i64 mlib_pcm_newblock_totalheapsize;
static struct $B14 mlib_changeext_newfile;
static struct $B14 mlib_extractpath_str;
static struct $B5 mlib_extractbasefile_str;
static struct $B15 mlib_nextcmdparamnew_str;
static struct $B16 mlib_readnextfileitem_str;
static struct $B16 mlib_padstr_str;
static u64 mlib_chr_str;
static i64 mlinux_init_flag;
static i64 qq_cli_nalldot;
static i64 qq_cli_nalldot1field;
static u64 qq_cli_syslibname;
static struct $B12 qq_cli_runnames;
static u8 qq_cli_fshowpcl1;
static u8 qq_cli_fshowpcl2;
static u8 qq_cli_fshowast1;
static u8 qq_cli_fshowast2;
static u8 qq_cli_fshowst;
static u8 qq_cli_fshowstflat;
static u8 qq_cli_fshowtypes;
static u8 qq_cli_foptimise;
static u8 qq_cli_fwriteqa;
static u8 qq_cli_fshowmodules;
static u8 qq_cli_fallsp;
static u8 qq_cli_runcode;
static u64 qq_cli_sourcestr;
static u64 qq_cli_inputfile;
static u64 qq_cli_allprocdefs;
static u64 qq_cli_allstaticdefs;
static u64 qq_cli_pclstr;
static i64 qq_cli_cmdstartindex;
static struct $B3 qq_decls_nextlx;
static struct $B3 qq_decls_lx;
static i64 qq_decls_qpos;
static i64 qq_decls_pcerrorpos;
static u64 qq_decls_pcerrormodule;
static struct $B17 qq_decls_varstack;
static u64 qq_decls_sptr;
static u64 qq_decls_stacklimit;
static u64 qq_decls_frameptr;
static u64 qq_decls_pcptr;
static i64 qq_decls_stopped;
static u64 qq_decls_stprogram;
static u64 qq_decls_stmodule;
static u64 qq_decls_stsubprog;
static u64 qq_decls_stcurrmodule;
static u64 qq_decls_stcurrproc;
static u64 qq_decls_currmodule;
static i64 qq_decls_debug;
static i64 qq_decls_inproc;
static struct $B18 qq_decls_genfieldtable;
static i64 qq_decls_ngenfields;
static i64 qq_decls_nlibfiles;
static struct $B19 qq_decls_libtable;
static struct $B20 qq_decls_libtypes;
static struct $B19 qq_decls_dllinsttable;
static i64 qq_decls_ndllprocs;
static struct $B21 qq_decls_dllproctable;
static struct $B22 qq_decls_dllproclibindex;
static struct $B21 qq_decls_dllprocaddr;
static u8 qq_decls_usebundled;
static struct $B12 qq_decls_dispatchnames;
static i64 qq_decls_nqparams;
static struct $B16 qq_decls_qparamtable;
static u64 qq_decls_proclist;
static u64 qq_decls_proclistx;
static i64 qq_decls_nproclist;
static u64 qq_decls_pcl_callbackfn;
static struct $B23 qq_decls_chrtable;
static u8 qq_decls_fnosys;
static u8 qq_decls_fverbose;
static struct $B24 qq_decls_baseclasstable;
static struct $B23 qq_decls_baseclassdef;
static i64 qq_decls_nbaseclasses;
static i64 qq_decls_lastretindex;
static struct $B25 qq_decls_modules;
static struct $B26 qq_decls_subprogs;
static i64 qq_decls_nmodules;
static i64 qq_decls_nsubprogs;
static i64 qq_decls_nalllines;
static struct $B27 qq_decls_qafilenames;
static struct $B27 qq_decls_qatext;
static struct $B27 qq_decls_qasize;
static i64 qq_decls_nqafiles;
static struct $B28 qq_decls_optionnames;
static struct $B28 qq_decls_optionvars;
static struct $B29 qq_decls_optionvalues;
static u64 qq_decls_stopseq;
static u64 qq_decls_raiseseq;
static i64 qq_decls_nproclocals;
static u64 qq_decls_pproclocals;
static struct $B30 qq_decls_pclcounts;
static i64 qq_decls_nallpcl;
static struct $B31 qq_decimal_fpnames;
static i64 qq_decimal_currprec;
static i64 qq_decimal_stblz;
static u64 qq_decimal_constlist;
static i64 qq_decimal_decstrsize;
static struct $B3 qq_decimal_vtemp;
static u8 qq_dicts_expanddict_inuse;
static u64 qq_host_procrefs;
static struct $B16 qq_host_pch_gethostname_name;
static struct $B16 qq_host_pch_getprogname_name;
static i64 qq_host_initprocrefs_oldnprocs;
static u64 qq_lex_lxsource;
static u64 qq_lex_lxstart;
static u64 qq_lex_lxsptr;
static i64 qq_lex_lxifcond;
static i64 qq_lex_longsuffix;
static i64 qq_lex_lxlineno;
static i64 qq_lex_nextlxlength;
static i64 qq_lex_lxlength;
static struct $B32 qq_lex_hashtable;
static u64 qq_lex_hashtablelast;
static u64 qq_lex_u64maxstr;
static struct $B16 qq_lex_namemap;
static i64 qq_lex_lexinit_n;
static i64 qq_lib_currlineno;
static i64 qq_lib_nextavindex;
static struct $B3 qq_lib_exprstrvar;
static u64 qq_lib_exprstr;
static i64 qq_lib_nlocalunits;
static u64 qq_lib_errormess;
static u64 qq_lib_bytemasks;
static struct $B22 qq_lib_convtostringz_strbuffer1;
static struct $B22 qq_lib_convtostringz_strbuffer2;
static struct $B22 qq_lib_convtostringz_strbuffer3;
static struct $B22 qq_lib_convtostringz_strbuffer4;
static struct $B22 qq_lib_convtostringz_strbuffer5;
static struct $B22 qq_lib_convtostringz_strbuffer6;
static u64 qq_lists_emptylist;
static struct $B15 qq_modules_getmodulefilename_str;
static i64 qq_names_sdsize;
static i64 qq_names_sdoffset;
static i64 qq_names_sdaligned;
static i64 qq_names_sdlevel;
static i64 qq_names_sdmode;
static i64 qq_names_sdnfields;
static i64 qq_names_sdmaxalign;
static struct $B2 qq_names_sdunion;
static struct $B1 qq_names_sdmaxsize;
static i64 qq_parse_intabledata;
static u64 qq_parse_tabledataname;
static struct $B1 qq_parse_dollarstack;
static i64 qq_parse_ndollar;
static u8 qq_parse_yieldseen;
static i64 qq_parse_currdllindex;
static i64 qq_parse_nextlambdaindex;
static struct $B34 qq_parse_listtypestack;
static i64 qq_parse_nlisttype;
static i64 qq_parse_listtype;
static i64 qq_parse_addstructflag_structseqno;
static struct $B36 qq_pcltabs_opndnames;
static struct $B30 qq_pcltabs_pclnames;
static struct $B37 qq_pcltabs_pclopnd;
static struct $B38 qq_pcltabs_pclattrs;
static struct $B39 qq_pcltabs_bintotable;
static struct $B40 qq_pclgen_loopstack;
static struct $B34 qq_pclgen_trylevelstack;
static i64 qq_pclgen_loopindex;
static i64 qq_pclgen_looptrylevel;
static i64 qq_pclgen_trylevel;
static i64 qq_pclgen_retindex;
static i64 qq_pclgen_retvaloffset;
static i64 qq_pclgen_nprocparams;
static u64 qq_pclgen_pprocentry;
static i64 qq_pclgen_procskiplabel;
static u64 qq_pcllib_pcstart;
static u64 qq_pcllib_pccurr;
static u64 qq_pcllib_pcend;
static i64 qq_pcllib_pcalloc;
static u64 qq_pcllib_pcsourcestart;
static u64 qq_pcllib_pcsourcecurr;
static i64 qq_pcllib_pclcurrlineno;
static u64 qq_pcllib_labelpctable;
static i64 qq_pcllib_labelalloc;
static i64 qq_pcllib_nextlabelno;
static i64 qq_print_mindev;
static i64 qq_print_moutdev;
static u64 qq_print_minchan;
static u64 qq_print_moutchan;
static struct $B3 qq_print_minvar;
static struct $B3 qq_print_moutvar;
static struct $B8 qq_print_moutdevstack;
static struct $B12 qq_print_moutchanstack;
static struct $B35 qq_print_moutvarstack;
static struct $B41 qq_print_mgapstack;
static struct $B12 qq_print_mfmtstrstack;
static struct $B12 qq_print_mfmtcurrstack;
static i64 qq_print_noclevels;
static u64 qq_print_mfmtstr;
static u64 qq_print_mfmtcurr;
static struct $B3 qq_print_defaultfmt;
static u8 qq_print_mgapneeded;
static u64 qq_print_kb_start;
static u64 qq_print_kb_pos;
static u64 qq_print_kb_lastpos;
static i64 qq_print_kb_size;
static i64 qq_print_kb_linelength;
static i64 qq_print_kb_length;
static i64 qq_print_kb_lastlength;
static u8 qq_print_termchar;
static i64 qq_print_itemerror;
static u64 qq_print_testfilech;
static i64 qq_print_listdepth;
static i64 qq_resolve_nprocs;
static i64 qq_resolve_noexpand;
static i64 qq_resolve_symbolmode;
static i64 qq_resolve_macrolevels;
static i64 qq_resolve_allowmodname;
static struct $B19 qq_resolve_macroparams;
static struct $B19 qq_resolve_macroparamsgen;
static struct $B19 qq_resolve_macroargs;
static i64 qq_resolve_nmacroparams;
static i64 qq_resolve_nmacroargs;
static struct $B27 qq_resolve_structfields;
static i64 qq_resolve_ntopfields;
static i64 qq_resolve_nallfields;
static u64 qq_runx_jumptable;
static u8 qq_runx_getjt;
static i64 qq_runaux_runproc_m_rmsg_typeno;
static struct $B6 qq_runaux_k_map_codeseq;
static u64 qq_strings_emptystring;
static struct $B42 qq_syslibs_syslibnames;
static struct $B42 qq_syslibs_libtext;
static struct $B43 qq_tables_stdtypenames;
static struct $B44 qq_tables_stdtypewidths;
static struct $B45 qq_tables_jtagnames;
static struct $B46 qq_tables_jflags;
static struct $B46 qq_tables_jhasvalue;
static struct $B47 qq_tables_symbolnames;
static struct $B48 qq_tables_namenames;
static struct $B8 qq_tables_objtypenames;
static struct $B8 qq_tables_scopenames;
static struct $B49 qq_tables_stnames;
static struct $B50 qq_tables_stsymbols;
static struct $B50 qq_tables_stsubcodes;
static struct $B51 qq_tables_hostfnnames;
static struct $B52 qq_tables_hostnparams;
static struct $B52 qq_tables_hostisfn;
static struct $B52 qq_tables_hostinternal;
static struct $B51 qq_tables_hosthandlers;
static struct $B53 qq_tables_d_binopset;
static struct $B54 qq_tables_binopset;
static struct $B55 qq_tables_d_unaryopset;
static struct $B54 qq_tables_unaryopset;
static struct $B2 qq_tables_d_addopset;
static struct $B41 qq_tables_d_cmpopset;
static struct $B55 qq_tables_d_mulopset;
static struct $B54 qq_tables_addopset;
static struct $B54 qq_tables_cmpopset;
static struct $B54 qq_tables_mulopset;
static struct $B54 qq_tables_exprendset;
static struct $B56 qq_tables_d_exprstarterset;
static struct $B57 qq_tables_exprstarterset;
static struct $B58 qq_tables_ttname;
static struct $B58 qq_tables_ttnamedef;
static struct $B59 qq_tables_ttbasetype;
static struct $B59 qq_tables_tttarget;
static struct $B58 qq_tables_ttlower;
static struct $B58 qq_tables_ttlength;
static struct $B58 qq_tables_ttlowerexpr;
static struct $B58 qq_tables_ttlengthexpr;
static struct $B58 qq_tables_ttsize;
static struct $B60 qq_tables_ttbitwidth;
static struct $B58 qq_tables_ttfields;
static struct $B60 qq_tables_ttcaligned;
static struct $B58 qq_tables_ttowner;
static i64 qq_tables_ntypes;
static i64 qq_tables_firstusertype;
static i64 qq_tables_nuserxtypes;
static i64 qq_tables_userxtypebase;
static u64 qq_tables_userxmodelist;
static struct $B61 qq_tables_ttnamedefx;
static struct $B61 qq_tables_ttxmap;
static struct $B62 qq_tables_ttxmoduleno;
static struct $B52 qq_tables_hostlvset;
static struct $B63 qq_tables_cvnames;
static struct $B8 qq_tables_loopnames;
static struct $B36 qq_tables_mathsnames;
static struct $B12 qq_tables_condnames;
static struct $B41 qq_tables_revconds;
static u64 qq_show_labelmap;
static i64 qq_show_currlineno;
static u64 qq_show_currpclproc;
static struct $B3 qq_show_pclv;
static u64 qq_show_pcldest;
static struct $B64 qq_show_getprefix_str;
static struct $B65 qq_show_getlineinfok_str;
static struct $B23 qq_show_strmode_str;
static struct $B23 qq_show_istrmode_str;
static i64 qq_showpcl_currlineno;
static u64 qq_showpcl_currpclproc;
static struct $B24 qq_showpcl_writepclopnd_str;
static struct $B24 qq_showpcl_writepclopnd_str2;
static struct $B31 qq_vars_zeroobj;
static i64 $nprocs;
static struct $B33 $procname;
static struct $B33 $procaddr;

// ***** Imported Functions *****
extern u64 malloc(u64 $1);
extern u64 realloc(u64 $1, u64 $2);
extern void free(u64 $1);
extern void memset(u64 $1, i32 $2, u64 $3);
extern void memcpy(u64 $1, u64 $2, u64 $3);
extern void memmove(u64 $1, u64 $2, u64 $3);
extern i32 clock();
extern i32 ftell(u64 $1);
extern i32 fseek(u64 $1, i32 $2, i32 $3);
extern u64 fread(u64 $1, u64 $2, u64 $3, u64 $4);
extern u64 fwrite(u64 $1, u64 $2, u64 $3, u64 $4);
extern i32 getc(u64 $1);
extern i32 ungetc(i32 $1, u64 $2);
extern u64 fopen(u64 a, u64 b);
extern i32 fclose(u64 $1);
extern u64 fgets(u64 $1, i64 $2, u64 $3);
extern i32 remove(u64 $1);
extern i32 rename(u64 $1, u64 $2);
extern i32 getchar();
extern void putchar(i32 $1);
extern void setbuf(u64 $1, u64 $2);
extern i64 strlen(u64 $1);
extern u64 strcpy(u64 $1, u64 $2);
extern i32 strcmp(u64 $1, u64 $2);
extern i32 strncmp(u64 $1, u64 $2, u64 $3);
extern u64 strncpy(u64 $1, u64 $2, u64 $3);
extern i32 memcmp(u64 $1, u64 $2, u64 $3);
extern u64 strcat(u64 $1, u64 $2);
extern i32 tolower(i32 $1);
extern i32 toupper(i32 $1);
extern i32 isalpha(i32 $1);
extern i32 isupper(i32 $1);
extern i32 islower(i32 $1);
extern i32 isalnum(i32 $1);
extern i32 isspace(i32 $1);
extern u64 strstr(u64 $1, u64 $2);
extern i64 atol(u64 $1);
extern i32 atoi(u64 $1);
extern r64 strtod(u64 $1, u64 $2);
extern u64 _strdup(u64 $1);
extern i32 puts(u64 $1);
extern i32 printf(u64 $1, ...);
extern i32 sprintf(u64 $1, u64 $2, ...);
extern i32 sscanf(u64 $1, u64 $2, ...);
extern i32 scanf(u64 $1, ...);
extern i32 rand();
extern void srand(u32 $1);
extern i32 system(u64 $1);
extern i32 fgetc(u64 $1);
extern i32 fputc(i32 $1, u64 $2);
extern i32 fprintf(u64 $1, u64 $2, ...);
extern i32 fputs(u64 $1, u64 $2);
extern i32 feof(u64 $1);
extern i32 getch();
extern i32 _getch();
extern i32 kbhit();
extern i32 _mkdir(u64 $1);
extern i32 mkdir(u64 $1);
extern u64 strchr(u64 $1, i32 $2);
extern i32 _setmode(i32 $1, i32 $2);
extern void _exit(i32 $1);
extern void exit(i32 $1);
extern r64 pow(r64 $1, r64 $2);
extern r64 sin(r64 $1);
extern r64 cos(r64 $1);
extern r64 tan(r64 $1);
extern r64 asin(r64 $1);
extern r64 acos(r64 $1);
extern r64 atan(r64 $1);
extern r64 log(r64 $1);
extern r64 log10(r64 $1);
extern r64 exp(r64 $1);
extern r64 floor(r64 $1);
extern r64 ceil(r64 $1);
extern void qsort(u64 $1, u64 $2, u64 $3, u64 $4);
extern i32 __getmainargs(u64 $1, u64 $2, u64 $3, i64 $4, u64 $5);
extern u64 dlopen(u64 $1, i32 $2);
extern u64 dlsym(u64 $1, u64 $2);
extern i32 tcgetattr(i32 $1, u64 $2);
extern i32 tcsetattr(i32 $1, i32 $2, u64 $3);
extern i32 gettimeofday(u64 $1, u64 $2);
extern u64 gmtime_r(u64 $1, u64 $2);
extern void stdin();
extern void stdout();

// ***** Function Declarations *****
static u64 msysc_getfmt(u64 fmtstyle);
static u64 msysc_strint(i64 a, u64 fmtstyle);
static u64 msysc_strword(u64 a, u64 fmtstyle);
static u64 msysc_strreal(r64 a, u64 fmtstyle);
static u64 mlib_pcm_newblock(i64 itemsize);
static i64 mlib_pcm_round(i64 n);
static u64 mlib_changeext(u64 s, u64 newext);
static u64 mlib_extractpath(u64 s);
static u64 mlib_extractbasefile(u64 s);
static i64 mlib_nextcmdparamnew(u64 paramno, u64 name, u64 value, u64 defext);
static i64 mlib_readnextfileitem(u64 fileptr, u64 item);
static u64 mlib_padstr(u64 s, i64 width, u64 padchar);
static u64 mlib_chr(i64 c);
static void qq_dicts_expanddict(u64 vd);
static void qq_host_pch_gethostname(u64 result);
static void qq_host_pch_getprogname(u64 result);
static void qq_host_initprocrefs();
static void qq_lex_lexinit();
static u64 qq_lib_convtostringz(u64 svalue, i64 length);
static u64 qq_modules_getmodulefilename(u64 path, u64 name);
static u64 qq_modules_loadstring(u64 name, u64 source);
static void qq_parse_addstructflag(u64 owner, i64 id);
static u64 qq_parse_readcompilervar();
static void qq_vars_var_add(u64 a, u64 b);
static void qq_vars_var_addmixed(u64 a, u64 b);
static void qq_vars_var_sub(u64 a, u64 b);
static void qq_vars_var_submixed(u64 a, u64 b);
static void qq_vars_var_mul(u64 a, u64 b);
static void qq_vars_var_mulmixed(u64 a, u64 b);
static void qq_vars_var_div(u64 a, u64 b);
static void qq_vars_var_divmixed(u64 a, u64 b);
static void qq_vars_var_iand(u64 a, u64 b);
static void qq_vars_var_ior(u64 a, u64 b);
static void qq_vars_var_ixor(u64 a, u64 b);
static void qq_vars_var_min(u64 a, u64 b);
static void qq_vars_var_max(u64 a, u64 b);
static void qq_vars_var_shl(u64 a, u64 b);
static void qq_vars_var_shr(u64 a, u64 b);
static void qq_runx_disploop();
static i64 qq_runaux_runproc_m(u64 amsg);
static u64 qq_runaux_k_map(u64 sp, u64 pc, u64 newsp);
static void qq_sets_var_make_set(u64 data, u64 dest, i64 n);
static i64 qq_sets_var_in_set(u64 a, u64 b);
static void qq_print_pch_startprint(u64 p);
static void qq_print_pch_startprintcon();
static void qq_print_pch_strstartprint();
static void qq_print_pch_setformat(u64 p);
static void qq_print_pch_endprint();
static void qq_print_pch_strendprint(u64 dest);
static void qq_print_pch_print(u64 p, u64 fmt);
static void qq_print_pch_print_nf(u64 p);
static void qq_print_pch_println();
static void qq_print_pch_printnogap();
static void qq_print_pch_printspace();
static void qq_print_pch_readln(u64 dev);
static void qq_print_pch_sreadln(u64 dev, u64 dest);
static void qq_print_pch_sread(u64 fmt, u64 dest);
static void qq_print_pch_rereadln();
static void qq_print_pch_reread();
static void qq_print_pch_strtoval(u64 p, u64 fmt, u64 dest);
static void qq_print_pch_tostr(u64 a, u64 b, u64 result);
static void qq_host_pch_leftstr(u64 a, u64 b, u64 c, u64 result);
static void qq_host_pch_rightstr(u64 a, u64 b, u64 c, u64 result);
static void qq_host_pch_convlc(u64 a, u64 b, u64 result);
static void qq_host_pch_convuc(u64 a, u64 b, u64 result);
static void qq_host_pch_waitkey(u64 result);
static void qq_host_pch_testkey(u64 result);
static void qq_host_pch_execwait(u64 a, u64 b, u64 c, u64 result);
static void qq_host_pch_execcmd(u64 a, u64 b, u64 c, u64 result);
static void qq_host_pch_system(u64 a, u64 result);
static void qq_host_pch_makestr(u64 a, u64 b, u64 result);
static void qq_host_pch_makeref(u64 a, u64 b, u64 result);
static void qq_host_pch_new(u64 a, u64 b, u64 c, u64 d, u64 result);
static void qq_host_pch_getcmdparam(u64 a, u64 result);
static void qq_host_pch_$setdebug(u64 a);
static void qq_host_pch_$test2(u64 a, u64 result);
static void qq_host_pch_$test(u64 a, u64 b, u64 c, u64 result);
static void qq_host_pch_$refcount(u64 a, u64 result);
static void qq_host_pch_ticks(u64 result);
static void qq_host_pch_clock(u64 result);
static void qq_host_pch_sleep(u64 a);
static void qq_host_pch_random(u64 a, u64 result);
static void qq_host_pch_gethash(u64 a, u64 result);
static void qq_host_pch_getos(u64 result);
static void qq_host_pch_iswindows(u64 result);
static void qq_host_pch_setmesshandler(u64 fn);
static void qq_host_pch_$getstdinout(u64 a, u64 result);
static void qq_host_pch_$getparam(u64 a, u64 result);
static void qq_host_pch_makeempty(u64 a, u64 result);
static void qq_host_pch_$smallmemtotal(u64 result);
static void qq_host_pch_$id(u64 a, u64 result);
static void qq_host_pch_copy(u64 a, u64 dest);
static void qq_host_pch_$nan(u64 dest);
static void qq_host_pch_$infinity(u64 dest);
static void qq_host_pch_$nprocs(u64 result);
static void qq_host_pch_$procname(u64 a, u64 result);
static void qq_host_pch_$procref(u64 a, u64 result);
static void qq_host_pch_allocexec(u64 a, u64 result);
static void qq_host_pch_runnative(u64 a, u64 b, u64 result);
static void qq_host_pch_setlwb(u64 a, u64 b);
static u64 qq_show_getprefix(i64 level, u64 prefix, u64 p);
static u64 qq_show_getlineinfok();
static void qq_show_showmoduleinfo(u64 dev);
static u64 qq_show_strmode(i64 t, i64 expand);
static void qq_show_istrmode(i64 t, u64 dest, i64 expand);
static u64 qq_showpcl_writepclopnd(u64 pcstart, u64 pc, i64 pass);
static void msysc_$getcommands(i64 ncmd, u64 cmds, i64 cmdskipl);
static void msysc_pushio();
static void msysc_m$print_startfile(u64 dev);
static void msysc_resetprintbuffer();
static void msysc_m$print_startstr(u64 s);
static void msysc_m$print_startptr(u64 p);
static void msysc_m$print_startcon();
static void msysc_m$print_setfmt(u64 format);
static void msysc_m$print_end();
static void msysc_nextfmtchars(i64 lastx);
static void msysc_dumpprintbuffer();
static void msysc_m$print_ptr(u64 a, u64 fmtstyle);
static void msysc_m$print_u64(u64 a, u64 fmtstyle);
static void msysc_m$print_ptr_nf(u64 a);
static void msysc_m$print_i64(i64 a, u64 fmtstyle);
static i64 msysc_u64tostr(u64 aa, u64 s, u64 base, i64 sep);
static void msysc_printstr_n(u64 s, i64 n);
static void msysc_strtofmt(u64 s, i64 slen, u64 fmt);
static void msysc_tostr_i64(i64 a, u64 fmt);
static void msysc_m$print_i64_nf(i64 a);
static void msysc_m$print_bool(i64 a, u64 fmtstyle);
static void msysc_m$print_str(u64 s, u64 fmtstyle);
static void msysc_printstr(u64 s);
static void msysc_tostr_u64(u64 a, u64 fmt);
static void msysc_m$print_r64(r64 x, u64 fmtstyle);
static void msysc_tostr_r64(r64 x, u64 fmt);
static void msysc_m$print_r32(r32 x, u64 fmtstyle);
static void msysc_m$print_c8(i64 a, u64 fmtstyle);
static i64 msysc_domultichar(u64 p, i64 n, u64 dest, u64 fmt);
static i64 msysc_getutfsize(u64 s);
static void msysc_tostr_str(u64 s, i64 oldlen, u64 fmt);
static void msysc_m$print_strn(u64 s, i64 length, u64 fmtstyle);
static void msysc_m$print_str_nf(u64 s);
static void msysc_m$print_strsl(struct $B3 s, u64 fmtstyle);
static void mlib_abortprogram(u64 s);
static void msysc_m$print_newline();
static void msysc_m$print_nogap();
static void msysc_m$print_space();
static void msysc_dumpstr(u64 s, i64 n, i64 fbuffer);
static void msysc_printstrn_app(u64 s, i64 length, u64 f);
static void msysc_printchar(i64 ch);
static i64 msysc_expandstr(u64 s, u64 t, i64 n, u64 fmt);
static i64 msysc_i64tostrfmt(i64 aa, u64 s, u64 fmt);
static i64 msysc_i64mintostr(u64 s, i64 base, i64 sep);
static u64 mlib_convlcstring(u64 s);
static i64 msysc_u64tostrfmt(i64 aa, u64 s, u64 fmt);
static i64 msysc_strtostrfmt(u64 s, u64 t, i64 n, u64 fmt);
static u64 mlib_pcm_alloc(i64 n);
static u64 mlib_convucstring(u64 s);
static void mlib_pcm_free(u64 p, i64 n);
static u64 msysc_getstr(u64 s, u64 fmt);
static void msysc_getstrint(i64 a, u64 dest);
static u64 mlib_pcm_copyheapstring(u64 s);
static void msysc_initreadbuffer();
static void msysc_m$read_conline();
static void mlib_readlinen(u64 handlex, u64 buffer, i64 size);
static void msysc_m$read_fileline(u64 f);
static void msysc_m$read_strline(u64 s);
static u64 msysc_readitem(u64 itemlength);
static i64 msysc_strtoint(u64 s, i64 length, u64 base);
static i64 msysc_m$read_i64(i64 fmt);
static r64 msysc_m$read_r64(i64 fmt);
static void msysc_m$read_str(u64 dest, i64 destlen, i64 fmt);
static void mlib_iconvlcn(u64 s, i64 n);
static void msysc_readstr(u64 dest, i64 fmt, i64 destlen);
static void msysc_rereadln();
static void msysc_reread();
static i64 msysc_valint(u64 s, i64 fmt);
static r64 msysc_valreal(u64 s);
static void msysc_mclunimpl(u64 mess);
static void msysc_addtobuffer(u64 s, i64 n);
static i64 msysc_m$sign_i64(i64 a);
static r64 msysc_m$sign_r64(r64 x);
static void mlib_pcm_init();
static i64 mlib_pcm_getac(i64 size);
static u64 mlib_allocmem(i64 n);
static void mlib_pcm_freeac(u64 p, i64 alloc);
static void mlib_pcm_clearmem(u64 p, i64 n);
static u64 mlib_pcm_allocz(i64 n);
static u64 mlib_pcm_copyheapstringn(u64 s, i64 n);
static u64 mlib_pcm_copyheapblock(u64 s, i64 length);
static u64 mlib_reallocmem(u64 p, i64 n);
static i64 mlib_getfilesize(u64 handlex);
static void mlib_readrandom(u64 handlex, u64 memx, i64 offset, i64 size);
static i64 mlib_writerandom(u64 handlex, u64 memx, i64 offset, i64 size);
static i64 mlib_setfilepos(u64 file, i64 offset);
static i64 mlib_getfilepos(u64 file);
static u64 mlib_readfile(u64 filename);
static i64 mlib_writefile(u64 filename, u64 data, i64 size);
static i64 mlib_checkfile(u64 file);
static u64 mlinux_os_getstdin();
static void mlib_iconvucn(u64 s, i64 n);
static u64 mlib_extractext(u64 s, i64 period);
static u64 mlib_extractfile(u64 s);
static u64 mlib_addext(u64 s, u64 newext);
static u64 mlib_pcm_alloc32();
static void mlib_pcm_free32(u64 p);
static void mlib_outbyte(u64 f, i64 x);
static void mlib_outu16(u64 f, u64 x);
static void mlib_outu32(u64 f, u64 x);
static void mlib_outu64(u64 f, u64 x);
static void mlib_outstring(u64 f, u64 s);
static void mlib_outblock(u64 f, u64 p, i64 n);
static i64 mlib_myeof(u64 f);
static void mlib_strbuffer_add(u64 dest, u64 s, i64 n);
static void mlib_gs_init(u64 dest);
static void mlib_gs_free(u64 dest);
static void mlib_gs_str(u64 dest, u64 s);
static void mlib_gs_char(u64 dest, i64 c);
static void mlib_gs_strn(u64 dest, u64 s, i64 length);
static void mlib_gs_strvar(u64 dest, u64 s);
static void mlib_gs_strint(u64 dest, i64 a);
static void mlib_gs_strln(u64 dest, u64 s);
static void mlib_gs_line(u64 dest);
static void mlib_gs_strsp(u64 dest, u64 s);
static i64 mlib_gs_getcol(u64 dest);
static void mlib_gs_leftstr(u64 dest, u64 s, i64 w, i64 padch);
static void mlib_gs_leftint(u64 dest, i64 a, i64 w, i64 padch);
static void mlib_gs_padto(u64 dest, i64 col, i64 ch);
static void mlib_gs_println(u64 dest, u64 f);
static i64 mlib_eqstring(u64 s, u64 t);
static void mlib_ipadstr(u64 s, i64 width, u64 padchar);
static i64 mlib_cmpstring(u64 s, u64 t);
static i64 mlib_cmpstringn(u64 s, u64 t, i64 n);
static i64 mlib_cmpbytes(u64 p, u64 q, i64 n);
static i64 mlib_eqbytes(u64 p, u64 q, i64 n);
static void mlib_mseed(u64 a, u64 b);
static u64 mlib_mrandom();
static i64 mlib_mrandomp();
static i64 mlib_mrandomint(i64 n);
static i64 mlib_mrandomrange(i64 a, i64 b);
static r64 mlib_mrandomreal();
static r64 mlib_mrandomreal1();
static u64 mlib_readline();
static u64 mlib_findfunction(u64 name);
static i64 mlib_roundtoblock(i64 n, i64 align);
static u64 mlib_pcm_allocnfz(i64 n);
static void mlinux_os_init();
static i64 mlinux_os_execwait(u64 cmdline, i64 newconsole, u64 workdir);
static i64 mlinux_os_execcmd(u64 cmdline, i64 newconsole);
static i64 mlinux_os_getch();
static i64 mlinux_os_kbhit();
static void mlinux_os_flushkeys();
static u64 mlinux_os_getconsolein();
static u64 mlinux_os_getconsoleout();
static u64 mlinux_os_proginstance();
static u64 mlinux_os_getdllinst(u64 name);
static u64 mlinux_os_getdllprocaddr(i64 hlib, u64 name);
static void mlinux_os_initwindows();
static i64 mlinux_os_getchx();
static u64 mlinux_os_getos();
static i64 mlinux_os_gethostsize();
static i64 mlinux_os_iswindows();
static i64 mlinux_os_shellexec(u64 opc, u64 file);
static void mlinux_os_sleep(i64 a);
static u64 mlinux_os_getstdout();
static u64 mlinux_os_gethostname();
static u64 mlinux_os_getmpath();
static void mlinux_os_exitprocess(i64 x);
static i64 mlinux_os_clock();
static i64 mlinux_os_ticks();
static i64 mlinux_os_getclockspersec();
static void mlinux_os_setmesshandler(u64 addr);
static i64 mlinux_os_hpcounter();
static i64 mlinux_os_hpfrequency();
static i64 mlinux_os_filelastwritetime(u64 filename);
static void mlinux_os_getsystime(u64 tm);
static void mlinux_os_peek();
static u64 mlinux_os_allocexecmem(i64 n);
static i64 mlinux_dirlist(u64 filespec, u64 dest, i64 capacity, i64 t);
static u64 mwindllc_os_calldllfunction(u64 fnaddr, i64 retcode, i64 nargs, u64 args, u64 argcodes);
static i64 mwindllc_calldll_cint(u64 fnaddr, u64 params, i64 nparams);
static i64 mwindllc_calldll_creal(u64 fnaddr, u64 params, i64 nparams);
static u64 mwindllc_os_pushargs(u64 args, i64 nargs, i64 nextra, u64 fnaddr, i64 isfloat);
static void mwindllc_os_dummycall(r64 a, r64 b, r64 c, r64 d);
void qq_cli_main();
static void qq_cli_start();
static void qq_cli_initdata();
static void qq_cli_getinputoptions();
static void qq_modules_readqabundle();
static void qq_cli_loadsyslib();
static void qq_cli_compile_sp(u64 filename, u64 source);
static void qq_show_showast(u64 sp, u64 file);
static void qq_cli_writeqafile();
static i64 qq_runx_runqprogram(u64 sp, i64 ismain);
static void qq_show_showlogfile();
static void qq_cli_do_option(i64 sw, u64 value);
static void qq_lib_loaderror(u64 mess, u64 mess2);
static void qq_cli_setcli(u64 cmds, i64 ncmds);
static u64 qq_modules_loadsp(u64 filename, u64 source);
static void qq_parse_parsemodule(u64 pm);
static void qq_resolve_fixusertypes();
static void qq_resolve_tx_typetable();
static void qq_resolve_rx_module(u64 pm);
static void qq_pclgen_gencodemodule(u64 sp, i64 moduleno);
static void qq_showpcl_showpcl(u64 sp, i64 pass);
static void qq_cli_fixup_sp(u64 sp);
static void qq_cli_resetcompiler();
static void qq_cli_setcmdparam(i64 index, u64 s);
static u64 qq_lex_addnamestr(u64 name);
static u64 qq_names_createdupldef(u64 owner, u64 symptr, i64 id);
static void qq_show_deletetempfiles();
static void qq_cli_fixupmodule(u64 pm);
static void qq_cli_optimise_module(u64 pm);
static void qq_runx_fixupcode(u64 pm);
static void qq_cli_fixproc(u64 d);
static u64 qq_strings_obj_make_string(u64 s, i64 mutable);
static u64 qq_cli_optim(u64 pc);
static void qq_arrays_var_empty_array(i64 tag, i64 elemtype, i64 lower, u64 dest);
static u64 qq_arrays_obj_newarray(i64 elemtype, i64 lower, i64 length);
static void qq_arrays_obj_free_array(u64 p);
static void qq_arrays_obj_free_vector(u64 p);
static void qq_arrays_var_make_array(u64 a, u64 dest, i64 lower, i64 n, i64 axtype, i64 elemtype);
static void qq_runaux_pcerror(u64 mess, u64 param);
static void qq_packed_var_storepacked(u64 p, u64 q, i64 t);
static u64 qq_vars_obj_new();
static u64 qq_arrays_obj_newarray_u(i64 usertag);
static void qq_arrays_var_getix_array(u64 a, i64 index);
static void qq_packed_var_loadpacked(u64 p, i64 t, u64 dest, u64 ownerobj);
static void qq_arrays_var_putix_array(u64 a, i64 index, u64 x);
static void qq_arrays_obj_append_array(u64 a, u64 x);
static void qq_arrays_var_getixref_array(u64 a, i64 index);
static void qq_lib_pcnotmut();
static void qq_arrays_obj_resize_array(u64 p, i64 n);
static void qq_arrays_var_appendto_array(u64 a, u64 x);
static void qq_arrays_var_dupl_array(u64 a);
static void qq_arrays_var_dupl_vector(u64 a);
static i64 qq_arrays_var_equal_array(u64 a, u64 b);
static void qq_arrays_var_concatto_array(u64 a, u64 b);
static void qq_arrays_var_getslice_array(u64 a, i64 i, i64 j);
static void qq_vars_obj_shareu(u64 p);
static i64 qq_arrays_u8inarray(u8 a, u64 p);
static i64 qq_arrays_u16inarray(u16 a, u64 p);
static i64 qq_arrays_u32inarray(u32 a, u64 p);
static i64 qq_arrays_u64inarray(u64 a, u64 p);
static i64 qq_arrays_var_inx_array(u64 a, u64 b, i64 usertag);
static void qq_runaux_pcustype(u64 mess, u64 x);
static void qq_arrays_var_expand_array(u64 p, u64 dest, i64 m);
static void qq_bits_obj_free_bits(u64 p, i64 tag);
static i64 qq_bits_getbitssize(i64 n, i64 t);
static void qq_bits_var_make_bits(u64 a, u64 dest, i64 lower, i64 n, i64 bxtype, i64 elemtype);
static u64 qq_bits_obj_newbits(i64 elemtype, i64 lower, i64 length);
static void qq_vars_var_storebit(u64 p, i64 shift, u64 q, i64 t, i64 bitlength);
static void qq_bits_var_getix_bits(u64 a, i64 index);
static void qq_runaux_pcustype_t(u64 mess, i64 t);
static void qq_bits_var_putix_bits(u64 a, i64 index, u64 x);
static void qq_bits_obj_append_bits(u64 a, u64 x);
static u64 qq_bits_getindexoffset(u64 p, i64 offset, i64 index, i64 t, u64 newoffset);
static void qq_bits_var_getixref_bits(u64 a, i64 index);
static void qq_bits_obj_resize_bits(u64 p, i64 n);
static void qq_bits_var_appendto_bits(u64 a, u64 x);
static i64 qq_bits_bits_bytesize(u64 p);
static void qq_bits_var_dupl_bits(u64 a);
static i64 qq_bits_var_equal_bits(u64 a, u64 b);
static void qq_bits_var_concatto_bits(u64 a, u64 b);
static void qq_bits_var_getslice_bits(u64 a, i64 i, i64 j);
static void qq_calldll_calldll(u64 d, u64 args, u64 result, i64 nargs);
static u64 qq_calldll_vartopacked(u64 p, u64 d);
static u64 qq_calldll_getlibprocaddr(u64 d);
static void qq_calldll_packedtovar(u64 retval, i64 t, u64 dest);
static u64 qq_calldll_loaddllfunction(u64 d);
static void qq_runaux_pcmxtypestt(u64 mess, i64 t, i64 u);
static void qq_strings_var_make_string(u64 s, u64 dest, i64 mutable);
static void qq_decimal_obj_free_dec(u64 p);
static void qq_decimal_var_dupl_dec(u64 a);
static void qq_decimal_var_empty_dec(u64 dest);
static u64 qq_decimal_makebignum(i64 length);
static void qq_decimal_var_make_dec_str(u64 s, i64 length, u64 dest);
static u64 qq_decimal_bn_makestr(u64 s, i64 length);
static void qq_decimal_var_make_dec_int(i64 a, u64 dest);
static u64 qq_decimal_bn_makeint(i64 x);
static u64 qq_decimal_badnumber();
static i64 qq_decimal_readexpon(u64 s);
static i64 qq_decimal_strvaln(u64 s, i64 n);
static u64 qq_decimal_var_tostr_dec(u64 a, i64 fmt);
static u64 qq_decimal_obj_tostr_dec(u64 a, i64 fmt);
static i64 qq_decimal_bn_isint(u64 a);
static u64 qq_decimal_tostring_scient(u64 a);
static u64 qq_decimal_tostring_float(u64 a, i64 fmt);
static i64 qq_decimal_obj_len_dec(u64 a);
static i64 qq_decimal_bn_getprec(u64 a);
static i64 qq_decimal_bn_iszero(u64 a);
static i64 qq_decimal_var_equal_dec(u64 a, u64 b);
static i64 qq_decimal_bn_equal(u64 a, u64 b);
static void qq_decimal_var_add_dec(u64 a, u64 b);
static u64 qq_decimal_bn_init();
static i64 qq_decimal_bn_add(u64 dest, u64 a, u64 b);
static void qq_decimal_var_sub_dec(u64 a, u64 b);
static i64 qq_decimal_bn_sub(u64 dest, u64 a, u64 b);
static void qq_decimal_var_mul_dec(u64 a, u64 b);
static i64 qq_decimal_bn_mul(u64 dest, u64 a, u64 b);
static void qq_decimal_var_div_dec(u64 a, u64 b);
static i64 qq_decimal_bn_div(u64 dest, u64 a, u64 b, i64 prec);
static void qq_decimal_var_idiv_dec(u64 a, u64 b);
static i64 qq_decimal_bn_idiv(u64 dest, u64 a, u64 b);
static void qq_decimal_var_irem_dec(u64 a, u64 b);
static i64 qq_decimal_bn_irem(u64 dest, u64 a, u64 b);
static void qq_decimal_var_neg_dec(u64 a);
static void qq_decimal_bn_negto(u64 a);
static void qq_decimal_var_abs_dec(u64 a);
static void qq_decimal_bn_absto(u64 a);
static i64 qq_decimal_var_compare_dec(u64 a, u64 b);
static i64 qq_decimal_bn_cmp(u64 a, u64 b);
static i64 qq_decimal_getbintype(u64 a, u64 b);
static void qq_decimal_bn_setzero(u64 a);
static void qq_decimal_bn_dupl(u64 a, u64 b);
static void qq_decimal_bn_setnan(u64 dest);
static void qq_decimal_bn_addu(u64 dest, u64 a, u64 b);
static void qq_decimal_bn_subu(u64 dest, u64 a, u64 b);
static u64 qq_decimal_makesmallnum(i64 length);
static void qq_decimal_freesmall(u64 p, i64 length);
static u64 qq_decimal_smalltobig(u64 c, u64 a, i64 length, i64 alloc, i64 offset);
static void qq_decimal_bn_move(u64 a, u64 b);
static void qq_decimal_bn_setinf(u64 dest);
static void qq_decimal_var_setnan(u64 dest);
static void qq_decimal_var_setinf(u64 dest);
static void qq_decimal_bn_mulu(u64 dest, u64 a, u64 b);
static i64 qq_decimal_bn_mulp(u64 dest, u64 a, u64 b, i64 prec);
static void qq_decimal_bn_setprec(u64 a, i64 prec);
static i64 qq_decimal_smallmulto(u64 p, u64 q, i64 plen, i64 m);
static void qq_decimal_bn_fdivu(u64 dest, u64 a, u64 b, i64 precision);
static void qq_decimal_bn_idivu(u64 dest, u64 a, u64 b, u64 rm);
static i64 qq_decimal_bn_idivrem(u64 dest, u64 rm, u64 a, u64 b);
static i64 qq_decimal_smalldiv(u64 x, u64 b, u64 xlen, i64 nb);
static i64 qq_decimal_smallsubto(u64 p, u64 q, i64 plen, i64 qlen);
static i64 qq_decimal_bn_getglobalprec();
static void qq_decimal_bn_setglobalprec(i64 prec);
static u64 qq_decimal_bn_makefloat(r64 x);
static u64 qq_decimal_dectemp(u64 a);
static void qq_decimal_freedectemp();
static void qq_decimal_bn_ipower(u64 d, u64 a, i64 n);
static void qq_decimal_var_power_dec(u64 a, i64 n);
static i64 qq_decimal_var_convert_dec_int(u64 a);
static i64 qq_decimal_bn_toint(u64 a);
static void qq_dicts_var_make_dict(u64 a, u64 dest, i64 n);
static u64 qq_dicts_obj_new_dict(i64 n);
static void qq_dicts_adddictitem(u64 d, u64 p, u64 q);
static i64 qq_lib_nextpoweroftwo(i64 x);
static u64 qq_lists_obj_newlist(i64 n, i64 lower, u64 defval);
static void qq_dicts_obj_free_dict(u64 p, i64 internal);
static void qq_vars_var_unshareu(u64 p);
static void qq_dicts_var_dupl_dict(u64 a);
static void qq_vars_var_duplu(u64 a);
static i64 qq_dicts_var_equal_dict(u64 x, u64 y);
static u64 qq_dicts_var_finddictitem(u64 vd, u64 p, i64 doins);
static i64 qq_vars_var_gethashvalue(u64 p);
static i64 qq_records_var_equal_record(u64 x, u64 y);
static void qq_vars_var_objtovar(i64 tag, u64 p, u64 q);
static u64 qq_host_callhostfunction(i64 hostfn, u64 sp);
static void qq_strings_var_empty_string(u64 dest, i64 mutable);
static void qq_host_leftstring(u64 a, i64 n, u64 result);
static void qq_host_padstring_right(u64 a, i64 n, i64 fillchar, u64 result);
static void qq_host_rightstring(u64 a, i64 n, u64 result);
static void qq_host_padstring_left(u64 a, i64 n, i64 fillchar, u64 result);
static i64 qq_host_checkparam(u64 p, i64 tag, i64 defaultx);
static void qq_strings_var_iconvcase(u64 a, u64 b, i64 upper);
static i64 qq_vars_var_getintvalue(u64 p);
static u64 qq_strings_obj_make_strslicexobj(u64 s, i64 length);
static void qq_strings_var_make_stringn(u64 s, i64 length, u64 dest, i64 mutable);
static void qq_strings_var_new_stringn(i64 length, u64 dest);
static void qq_host_getbounds(u64 p, u64 dims, i64 lower);
static void qq_strings_var_new_string(u64 a, u64 b, u64 dest);
static u64 qq_sets_obj_newset(i64 length);
static u64 qq_records_obj_new_record(i64 m, u64 defval);
static void qq_vars_var_fromobj(i64 tag, u64 p, u64 dest);
static u64 qq_packed_obj_new_struct(i64 m);
static void qq_lists_var_empty_list(i64 lower, u64 dest);
static void qq_host_setcmdparam(i64 index, u64 s);
static void qq_lex_lexreadtoken();
static i64 qq_lex_lookup(u64 name, i64 length, i64 hashindex);
static void qq_lex_readrawstring();
static void qq_lex_readhex();
static void qq_lex_readbin();
static void qq_lib_lxerror(u64 mess);
static void qq_lex_readdec();
static void qq_lex_readreal();
static void qq_lex_lxreadstring(i64 termchar);
static void qq_lex_readrawxname();
static i64 qq_lex_readhexcode(u64 s, i64 n, i64 sp);
static i64 qq_lex_getutf8(i64 c, u64 s);
static void qq_lex_lxerror_s(u64 mess, u64 a);
static void qq_lex_inithashtable();
static i64 qq_lex_gethashvaluez(u64 s);
static void qq_lex_start();
static void qq_lex_addstname(u64 name, i64 symbol, i64 subcode);
static void qq_lex_startlex(u64 pm);
static void qq_lex_ps(u64 caption);
static void qq_show_printsymbol(u64 lp);
static void qq_lex_psnext(u64 caption);
static void qq_lex_lex();
static void qq_lex_makedecimal(u64 s, i64 length, i64 base);
static void qq_lib_reportcterror(u64 errortype, u64 mess, i64 pos, u64 currproc);
static struct $B12 qq_lib_geterrorinfo(u64 pos, u64 currproc);
static void qq_lib_showerrorsource(struct $B12 loc);
static void qq_lib_stopcompiler(struct $B12 loc);
static void qq_lib_gerror(u64 mess, u64 p);
static void qq_lib_gerror_s(u64 mess, u64 param, u64 p);
static void qq_lib_serror(u64 mess);
static void qq_lib_serror_s(u64 mess, u64 param);
static void qq_lib_rxerror(u64 mess, u64 p);
static void qq_lib_rxerror_s(u64 mess, u64 param, u64 p);
static void qq_lib_prterror(u64 mess);
static u64 qq_lib_allocunitrec();
static u64 qq_lib_createintunit(i64 a);
static u64 qq_lib_createrealunit(r64 x);
static u64 qq_lib_createstringunit(u64 s, i64 slength);
static u64 qq_lib_createunit0(i64 tag);
static u64 qq_lib_createunit1(i64 tag, u64 p);
static u64 qq_lib_createunit2(i64 tag, u64 p, u64 q);
static u64 qq_lib_createname(u64 p);
static void qq_lib_addlistunit(u64 ulist, u64 ulistx, u64 p);
static u64 qq_lib_createavname();
static u64 qq_lib_findprocname(u64 fnptr);
static u64 qq_lib_strexpr(u64 p);
static void qq_lib_jeval(u64 p);
static u64 qq_lib_strexpr_s(u64 p);
static void qq_lib_additem(u64 s);
static void qq_lib_convertstring(u64 s, u64 t);
static u64 qq_lib_getopcname(i64 opc);
static void qq_lib_jevallist(u64 p);
static i64 qq_lib_isalphanum(i64 c);
static u64 qq_lib_createavnamex(u64 owner);
static void qq_resolve_resolvename(u64 owner, u64 p, i64 mode);
static void qq_lib_storemode(u64 owner, i64 m, u64 p);
static i64 qq_lib_testelem(u64 p, i64 n);
static void qq_lib_setelem(u64 p, i64 n);
static void qq_lib_setelemblock(u64 p, i64 a, i64 b);
static i64 qq_lib_ispoweroftwo(i64 x);
static void qq_lib_deleteunit(u64 p, u64 q);
static void qq_lib_skipsemi();
static void qq_lib_checksymbol(i64 symbol);
static void qq_lib_skipsymbol(i64 symbol);
static i64 qq_lib_getpcloffset(u64 p, u64 q);
static void qq_lists_start();
static void qq_lists_var_make_list(u64 a, u64 dest, i64 n, i64 lower);
static void qq_lists_obj_free_list(u64 p);
static void qq_lists_var_getix_list(u64 a, i64 index);
static void qq_lists_var_getslice_list(u64 a, i64 i, i64 j);
static void qq_lists_var_getixref_list(u64 a, i64 index);
static void qq_lists_obj_append_list(u64 a, u64 x);
static void qq_lists_var_putix_list(u64 a, i64 index, u64 x);
static void qq_lists_var_putslice_list(u64 a, i64 i, i64 j, u64 x);
static void qq_lists_obj_resize_list(u64 p, i64 n);
static void qq_lists_var_appendto_list(u64 a, u64 x);
static void qq_lists_var_dupl_list(u64 a);
static void qq_lists_var_mul_list(u64 p, i64 m);
static i64 qq_lists_var_equal_list(u64 x, u64 y);
static i64 qq_vars_var_equal(u64 a, u64 b);
static void qq_lists_var_concatto_list(u64 a, u64 b);
static i64 qq_lists_var_inx_list(u64 a, u64 b);
static u64 qq_modules_loadsourcefile(u64 filespec, i64 issyslib);
static i64 qq_modules_loadqafile(u64 pm);
static i64 qq_syslibs_loadsysmodule(u64 pm);
static u64 qq_modules_readfileline(u64 s);
static u64 qq_modules_findnextlineheader(u64 s);
static u64 qq_names_addglobalname(u64 name);
static u64 qq_names_newstrec();
static u64 qq_names_addsymbol(u64 owner, u64 d, i64 id, i64 isglobal);
static void qq_names_addproc(u64 d);
static i64 qq_names_newusertypex(u64 d, u64 e);
static u64 qq_names_resolvedottedname(u64 owner, u64 d);
static void qq_names_addgenfield(u64 d);
static i64 qq_names_makereftype(i64 target, u64 owner);
static i64 qq_names_addanontype();
static i64 qq_names_makeaxtype(i64 target, u64 plower, u64 plength);
static i64 qq_names_makestrtype(i64 m, u64 pwidth);
static void qq_names_createusertype(u64 d, i64 m);
static i64 qq_names_getalignment(i64 m);
static void qq_names_duplfield(u64 p, u64 q);
static void qq_names_writesig(u64 d, u64 dev);
static i64 qq_packed_getfslength(u64 s, i64 m);
static void qq_packed_setfslength(u64 s, i64 m, i64 n);
static void qq_packed_var_make_struct(u64 a, u64 dest, i64 n, i64 rectype);
static void qq_packed_var_dupl_struct(u64 a);
static void qq_packed_obj_free_struct(u64 p);
static i64 qq_packed_var_equal_struct(u64 x, u64 y);
static void qq_packed_var_getix_struct(u64 a, i64 index);
static u64 qq_parse_readsunit(i64 inwhile);
static u64 qq_parse_readexpression();
static u64 qq_parse_readterm2();
static u64 qq_parse_readassignment(u64 p);
static u64 qq_parse_readorterms(u64 p);
static u64 qq_parse_readandterms(u64 p);
static u64 qq_parse_readcmpterms(u64 p);
static u64 qq_parse_readinterms(u64 p);
static u64 qq_parse_readrangeterm(u64 p);
static u64 qq_parse_readaddterms(u64 p);
static u64 qq_parse_readmulterms(u64 p);
static u64 qq_parse_readpowerterms(u64 p);
static u64 qq_parse_readterm();
static u64 qq_parse_readtermsuffix(u64 p, i64 pos);
static u64 qq_parse_readslist(u64 nparams, i64 ftrailing);
static u64 qq_parse_readcondsuffix(u64 p);
static u64 qq_parse_readindex(u64 p, i64 dot);
static u64 qq_parse_readdotsuffix(u64 p);
static u64 qq_parse_readkeyindex(u64 p);
static u64 qq_parse_readlbrack();
static u64 qq_parse_readcast();
static u64 qq_parse_checkoperator();
static u64 qq_parse_readset();
static u64 qq_parse_readpair(i64 tag, i64 pclop);
static u64 qq_parse_readsprint();
static void qq_parse_lexchecksymbol(i64 symbol);
static u64 qq_parse_readgoto();
static u64 qq_parse_readif();
static u64 qq_parse_readunless();
static u64 qq_parse_readswitchcase();
static u64 qq_parse_readfor();
static u64 qq_parse_readto();
static u64 qq_parse_readdo();
static u64 qq_parse_readwhile();
static u64 qq_parse_readrepeat();
static u64 qq_parse_readloopcontrol();
static u64 qq_parse_readreturn();
static u64 qq_parse_readstop();
static u64 qq_parse_readprint();
static u64 qq_parse_readread();
static u64 qq_parse_readtry();
static u64 qq_parse_readhostparams(u64 lhs, i64 isfn);
static u64 qq_parse_readlambda();
static void qq_parse_readprocdef(i64 isglobal);
static u64 qq_parse_readvardef(i64 isglobal, i64 isstatic);
static void qq_parse_readconstdef(i64 isglobal);
static void qq_parse_readtypedef(i64 isglobal);
static void qq_parse_readrecorddef(i64 isglobal, u64 d);
static void qq_parse_readtabledef(i64 isglobal);
static void qq_parse_readimportdll();
static void qq_parse_readmacrodef(i64 isglobal);
static void qq_parse_checkequals();
static void qq_parse_pushlisttype(i64 ltype);
static void qq_parse_poplisttype();
static u64 qq_parse_makeblock(u64 p);
static void qq_parse_checkend(i64 endkwd1, i64 endkwd2, i64 startline);
static u64 qq_parse_readintunit();
static u64 qq_parse_readsread();
static void qq_parse_readffiparams(u64 stproc);
static void qq_parse_readpackvars(u64 owner, i64 id);
static i64 qq_parse_readtypespec(i64 allowvar, u64 owner);
static void qq_parse_readtypeparams(u64 stproc, i64 ptype);
static void qq_parse_readtypenameparams(u64 stproc, i64 ptype);
static i64 qq_parse_istypestarter();
static i64 qq_parse_readrecordbody(u64 owner);
static i64 qq_parse_readstructbody(u64 owner, i64 caligned);
static void qq_parse_readrecordfields(u64 owner);
static u64 qq_parse_readatfield();
static void qq_parse_readparams(u64 stproc);
static void qq_pclgen_evalunit(u64 p, i64 res);
static void qq_pcllib_genpc_int(i64 opc, i64 a);
static void qq_pcllib_genpc_real(i64 opc, r64 x);
static void qq_pclgen_pushstring(u64 s);
static void qq_pcllib_genpc_name(i64 opc, u64 d);
static void qq_pcllib_genpc(i64 opc);
static i64 qq_pcllib_createfwdlabel();
static void qq_pcllib_genpc_lab(i64 opc, i64 lab);
static void qq_pclgen_do_call(u64 p, u64 a, u64 b, i64 res, u64 procflag);
static void qq_pclgen_do_return(u64 p, u64 a, i64 res);
static void qq_pclgen_do_callhost(u64 p, u64 a, i64 res);
static void qq_pclgen_do_assign(u64 a, u64 b, i64 res, i64 deepcopy);
static void qq_pclgen_do_to(u64 p, u64 pcount, u64 pbody);
static void qq_pclgen_do_if(u64 p, u64 a, u64 b, u64 pelse, i64 res);
static void qq_pclgen_do_for(u64 p, u64 pvar, u64 pbody);
static void qq_pclgen_do_forx(u64 p, u64 pvar, u64 pbody);
static void qq_pclgen_do_forall(u64 p, u64 pindex, u64 pbody);
static void qq_pclgen_do_while(u64 p, u64 pcond, u64 pbody);
static void qq_pclgen_do_repeat(u64 p, u64 a, u64 b);
static void qq_pcllib_gencomment(u64 s);
static i64 qq_pcllib_definelabel();
static void qq_pcllib_definefwdlabel(i64 lab);
static void qq_pclgen_do_loop(u64 p);
static void qq_pclgen_do_do(u64 p, u64 a);
static void qq_pclgen_do_case(u64 p, u64 pindex, u64 pwhenthen, i64 res);
static void qq_pclgen_do_switch(u64 p, u64 pindex, u64 pwhenthen, i64 res);
static void qq_pclgen_evalref(u64 p);
static void qq_pclgen_do_select(u64 pindex, u64 pplist, i64 res);
static void qq_pclgen_do_print(u64 p, u64 a, u64 b);
static void qq_pclgen_do_fprint(u64 p, u64 a, u64 b, u64 c);
static void qq_pclgen_do_read(u64 p, u64 a, u64 b);
static void qq_pclgen_do_try(u64 p, u64 a, u64 b);
static void qq_pclgen_do_andl(u64 x, u64 y);
static void qq_pclgen_do_orl(u64 x, u64 y);
static void qq_pclgen_do_pushlist(u64 a, i64 n);
static void qq_pcllib_genpc_xy(i64 opc, i64 x, i64 y);
static void qq_pclgen_do_makedict(u64 a, i64 n);
static void qq_pclgen_do_map(u64 p, u64 popcode, u64 x);
static void qq_pclgen_do_idiv(u64 a, u64 b);
static void qq_pclgen_do_irem(u64 a, u64 b);
static void qq_pclgen_do_bin(u64 a, u64 b, i64 opc);
static void qq_pclgen_do_convert(u64 pconv);
static void qq_pclgen_do_incr(u64 p, u64 a, i64 res);
static void qq_pcllib_genpc_n(i64 opc, i64 n);
static void qq_pcllib_resetpcl(i64 sourcesize);
static void qq_pclgen_do_procdef(u64 p);
static void qq_pclgen_genprocentry(u64 p, u64 nfreevars, u64 nnofreevars);
static i64 qq_pclgen_checkblockreturn(u64 p);
static void qq_pclgen_genprocexit(i64 nfree, i64 nnofree, i64 isfunc);
static void qq_pclgen_genjumpcond(i64 opc, u64 p, i64 lab);
static void qq_pclgen_genjumpl(i64 lab);
static void qq_pclgen_gcomparejump(i64 opc, i64 cond, i64 lab);
static void qq_pclgen_stacklooplabels(i64 a, i64 b, i64 c);
static void qq_pclgen_unstacklooplabels();
static i64 qq_pclgen_findlooplabel(i64 k, i64 n);
static void qq_pclgen_do_multassign(u64 a, u64 b, i64 deepcopy, i64 res);
static void qq_pclgen_do_store(u64 a, i64 res);
static void qq_pclgen_do_binref(u64 a, u64 b, i64 opc);
static void qq_pclgen_do_unary(u64 a, i64 opc);
static void qq_pclgen_do_unaryref(u64 a, i64 opc);
static i64 qq_pclgen_pushparams(u64 d, u64 arglist, i64 nargs, i64 kwdindex);
static void qq_pclgen_pushkwdparams(u64 d, u64 arglist, i64 nargs, i64 kwdindex);
static void qq_pclgen_evalparam(u64 a, i64 byref);
static void qq_pclgen_callhostfn(i64 fnindex, i64 calledasfn);
static void qq_pclgen_do_case_nc(u64 p, u64 pindex, u64 pwhenthen, i64 res);
static i64 qq_pclgen_getconstvalue(u64 p);
static void qq_pcllib_genxy(i64 x, i64 y);
static i64 qq_pclgen_unitstoarray(u64 p, u64 plist, i64 maxunits);
static void qq_pclgen_genfree(i64 n);
static void qq_pclgen_do_makerecordkv(i64 m, i64 nkeyvals, u64 kvlist);
static void qq_pclgen_checkelems(i64 n, i64 length, u64 p);
static void qq_pclgen_do_simpleswitch(u64 p, u64 pindex, u64 pwhenthen, u64 pelse, i64 a, i64 b, i64 res);
static void qq_pcllib_genopnd_strz(u64 s);
static void qq_pcllib_start();
static void qq_pcllib_extendpcldata();
static void qq_pcllib_genopnd_str(u64 s);
static void qq_pcllib_genopnd_obj(u64 p);
static void qq_pcllib_extendlabeltable();
static void qq_print_printstr_n(u64 s, i64 n);
static void qq_print_printnextfmtchars(i64 lastx);
static i64 qq_print_getreadfmtcode(u64 p);
static u64 qq_print_readint(u64 sold, i64 length, u64 dest, i64 dodec);
static void qq_print_stepkbpos(u64 s);
static u64 qq_print_readreal(u64 sold, i64 length, u64 dest);
static u64 qq_print_readname(u64 s, i64 length, u64 dest);
static u64 qq_print_readstring(u64 s, i64 length, u64 dest);
static u64 qq_print_readhex(u64 sold, i64 length, u64 dest);
static u64 qq_print_readbin(u64 sold, i64 length, u64 dest);
static u64 qq_print_readany(u64 sold, i64 length, u64 dest);
static u64 qq_print_readitem(u64 s, i64 length, u64 itemstr, u64 itemlength);
static void qq_print_strtoint(u64 s, i64 length, u64 dest, i64 dodec);
static void qq_print_strtoreal(u64 s, i64 length, u64 dest);
static u64 qq_print_pc_getfmt(u64 p, u64 fmt);
static void qq_print_addstring(u64 p, u64 t, i64 n);
static void qq_print_domultichar(u64 p, i64 n, u64 dest, u64 fmt);
static void qq_print_tostr_int(u64 p, u64 fmt, u64 dest);
static void qq_print_tostr_real(u64 p, u64 fmt, u64 dest);
static void qq_print_tostr_str(u64 p, u64 fmt, u64 dest);
static u64 qq_strings_obj_new_string(i64 n);
static void qq_print_tostr(u64 p, u64 fmt, u64 dest);
static void qq_print_tostr_range(u64 p, u64 fmt, u64 dest);
static void qq_print_tostr_array(u64 p, u64 fmt, u64 dest);
static void qq_print_tostr_bits(u64 p, u64 fmt, u64 dest);
static void qq_vars_var_loadbit(u64 p, i64 shift, i64 t, i64 bitlength, u64 dest);
static void qq_print_tostr_struct(u64 p, u64 fmt, u64 dest);
static void qq_print_tostr_set(u64 p, u64 fmt, u64 dest);
static void qq_print_tostr_dict(u64 p, u64 fmt, u64 dest);
static void qq_print_tostr_decimal(u64 p, u64 fmt, u64 dest);
static void qq_print_tostr_list(u64 p, u64 fmt, u64 dest);
static void qq_records_var_make_record(u64 a, u64 dest, i64 n, i64 rectype);
static void qq_records_obj_free_record(u64 p);
static void qq_records_var_dupl_record(u64 a);
static void qq_records_var_getix_record(u64 a, i64 index);
static void qq_records_var_putix_record(u64 a, i64 index, u64 x);
static void qq_records_var_getixref_record(u64 a, i64 index, u64 dest);
static void qq_resolve_rx_passdef(u64 owner, u64 p);
static void qq_resolve_rx_unit(u64 owner, u64 p);
static void qq_resolve_rx_deflist(u64 owner, u64 p, i64 doanon);
static void qq_resolve_fixmode(u64 owner, u64 p);
static void qq_resolve_expandmacro(u64 p, u64 a, u64 b);
static void qq_resolve_resolvedot(u64 owner, u64 p);
static void qq_resolve_rx_unitlist(u64 owner, u64 p);
static void qq_resolve_evalbinop(u64 p, u64 lhs, u64 rhs);
static void qq_resolve_evalmonop(u64 p);
static void qq_show_printunit(u64 p, i64 level, u64 prefix, u64 dev);
static void qq_resolve_makeintconst(u64 p, i64 value);
static void qq_resolve_makerealconst(u64 p, r64 xvalue);
static u64 qq_resolve_resolvetopname(u64 owner, u64 stnewname, i64 moduleno, i64 allowmod);
static void qq_resolve_resolvedot_sym(u64 owner, u64 p);
static u64 qq_resolve_finddupl(u64 d, u64 pdupl);
static u64 qq_resolve_copyunit(u64 p);
static void qq_resolve_replaceunit(u64 p, u64 q);
static u64 qq_resolve_copylistunit(u64 p);
static i64 qq_resolve_fixmode2(u64 owner, i64 m);
static void qq_resolve_dobaseclass(i64 baseclassindex);
static void qq_resolve_converttype(i64 m);
static i64 qq_resolve_getconstint(u64 owner, u64 a, i64 ownerid);
static void qq_resolve_scanstruct(i64 smode, u64 fields, u64 index, u64 isize, i64 offset, i64 calign, u64 maxalign, i64 countmode);
static void qq_runaux_k_swap(u64 x, u64 y);
static void qq_runaux_k_convrefpack(u64 sp);
static i64 qq_vars_var_istruel(u64 a);
static i64 qq_vars_var_compare(u64 a, u64 b);
static i64 qq_runaux_k_when(u64 x, u64 y);
static u64 qq_runaux_k_makelist(u64 sp, i64 lower, i64 n);
static void qq_runaux_k_incrptr(u64 p, i64 step);
static void qq_vars_var_loadptr(u64 x, u64 y);
static void qq_vars_var_neg(u64 a);
static void qq_vars_var_abs(u64 a);
static void qq_vars_var_inot(u64 a);
static void qq_strings_var_makechar(i64 ch, u64 dest);
static void qq_runaux_k_maths(u64 sp, i64 opc);
static void qq_runaux_k_maths2(u64 x, u64 y, i64 opc);
static void qq_runaux_k_len(u64 sp);
static void qq_runaux_k_lwb(u64 sp);
static void qq_runaux_k_upb(u64 sp);
static void qq_runaux_k_bounds(u64 sp, u64 lower, u64 upper);
static i64 qq_runaux_k_bytesize(u64 sp);
static i64 qq_runaux_k_type(u64 sp, i64 n);
static void qq_runaux_k_minval(u64 sp);
static void qq_runaux_k_maxval(u64 sp);
static void qq_vars_var_convert(u64 x, i64 t, u64 dest);
static void qq_vars_var_idiv(u64 a, u64 b);
static void qq_vars_var_irem(u64 a, u64 b);
static i64 qq_vars_var_in(u64 a, u64 b);
static i64 qq_vars_var_inx(u64 a, u64 b);
static i64 qq_runaux_k_cmp(i64 cc, u64 x, u64 y);
static void qq_vars_var_concat(u64 a, u64 b);
static void qq_vars_var_append(u64 a, u64 b);
static void qq_vars_var_power(u64 a, u64 b);
static void qq_vars_var_inplace(i64 index, u64 px, u64 y);
static i64 qq_vars_var_appendto(u64 a, u64 b);
static i64 qq_vars_var_concatto(u64 a, u64 b);
static void qq_runaux_k_dot(u64 sp, u64 g);
static u64 qq_runaux_k_popdot(u64 sp, u64 g);
static void qq_runaux_k_dotref(u64 sp, u64 g);
static void qq_vars_var_getix(u64 a, i64 index);
static void qq_vars_var_getslice(u64 a, i64 i, i64 j);
static void qq_runaux_pcmxtypes(u64 mess, u64 x, u64 y);
static void qq_vars_var_putix(u64 a, i64 index, u64 x);
static void qq_vars_var_putslice(u64 a, i64 i, i64 j, u64 x);
static void qq_vars_var_getixref(u64 a, i64 index);
static u64 qq_runaux_k_keyindex(u64 sp);
static u64 qq_runaux_k_popkeyindex(u64 sp);
static u64 qq_runaux_k_keyindexref(u64 sp);
static void qq_vars_var_getdotix(u64 a, i64 index);
static void qq_vars_var_getdotslice(u64 a, i64 i, i64 j);
static void qq_vars_var_putdotix(u64 p, i64 index, u64 x);
static void qq_vars_var_putdotslice(u64 p, i64 i, i64 j, u64 x);
static void qq_vars_var_getdotixref(u64 p, i64 index);
static void qq_vars_var_getdotsliceref(u64 p, i64 i, i64 j);
static void qq_vars_var_expand(u64 a, u64 dest, i64 m);
static u64 qq_runaux_raiseexception(i64 exceptno);
static void qq_runx_start();
static void qq_runaux_reportpcerror(u64 pcptr, u64 mess, u64 param);
static struct $B12 qq_runaux_getpcerrorpos(u64 pc);
static i64 qq_runaux_findmodulefrompc(u64 pc);
static u64 qq_runaux_resolvefield(u64 g, i64 rectype);
static void qq_runaux_runproc(u64 fnptr, u64 a, u64 b, u64 dest);
static void qq_sets_obj_free_set(u64 p);
static void qq_sets_var_dupl_set(u64 a);
static i64 qq_sets_var_equal_set(u64 x, u64 y);
static i64 qq_sets_getsetbytes(u64 x);
static void qq_sets_var_emptyset(u64 dest);
static void qq_sets_var_getix_set(u64 a, i64 index);
static void qq_sets_var_putix_set(u64 a, i64 index, u64 x);
static u64 qq_sets_getoffset(u64 p, i64 index, u64 newoffset);
static void qq_sets_var_getixref_set(u64 a, i64 index);
static void qq_sets_iresizeset(u64 p, i64 n);
static void qq_sets_obj_resize_set(u64 p, i64 n);
static void qq_sets_iorsetbits(u64 p, u64 q, i64 n);
static void qq_sets_ixorsetbits(u64 p, u64 q, i64 n);
static void qq_sets_iandsetbits(u64 p, u64 q, i64 n);
static void qq_sets_inotsetbits(u64 p, i64 n);
static void qq_sets_var_iorto_set(u64 x, u64 y);
static void qq_sets_var_iandto_set(u64 x, u64 y);
static void qq_sets_var_ixorto_set(u64 x, u64 y);
static void qq_sets_var_inotto_set(u64 x);
static void qq_strings_start();
static u64 qq_strings_obj_make_stringn(u64 s, i64 length, i64 mutable);
static void qq_strings_obj_free_string(u64 p);
static void qq_strings_var_dupl_string(u64 a);
static void qq_strings_var_getix_string(u64 a, i64 index);
static void qq_strings_stringslice(u64 a, i64 i, i64 j, u64 dest);
static void qq_strings_var_getixref_string(u64 a, i64 index);
static void qq_strings_var_getdotix_string(u64 a, i64 index);
static void qq_strings_var_getdotixref_string(u64 a, i64 index, u64 dest);
static void qq_strings_var_getslice_string(u64 a, i64 i, i64 j);
static void qq_strings_var_putix_string(u64 a, i64 index, u64 x);
static void qq_strings_var_addto_string(u64 a, u64 b);
static void qq_strings_var_putslice_string(u64 a, i64 i, i64 j, u64 x);
static void qq_strings_var_putdotix_string(u64 a, i64 index, u64 x);
static void qq_strings_var_addto_string_ch(u64 a, i64 ch);
static void qq_strings_obj_resize_string(u64 p, i64 n);
static void qq_strings_var_add_string(u64 a, u64 b);
static i64 qq_strings_var_equal_string(u64 x, u64 y);
static i64 qq_strings_var_compare_string(u64 x, u64 y);
static i64 qq_strings_cmpstring_len(u64 s, u64 t, i64 slen, i64 tlen);
static i64 qq_strings_var_inx_string(u64 x, u64 y);
static void qq_strings_var_makestrslicexobj(u64 s, i64 length, u64 dest);
static i64 qq_strings_var_asc(u64 a);
static void qq_strings_var_mul_string(u64 a, i64 m);
static void qq_strings_var_convert_string_list(u64 a, i64 t, u64 dest);
static void qq_strings_var_expand_string(u64 a, u64 dest, i64 m);
static u64 qq_syslibs_findsyslib(u64 filename);
static void qq_tables_start();
static void qq_show_printunitlist(u64 dev, u64 p, i64 level, u64 prefix);
static void qq_show_printglobalsymbols(u64 f);
static void qq_show_printst(u64 f, u64 p, i64 level);
static void qq_show_printstrec(u64 f, u64 p, i64 level);
static void qq_show_printtypetables(u64 f);
static void qq_show_showsttree();
static void qq_show_showtypes();
static void qq_show_showast2(u64 f, u64 sp);
static void qq_show_showstflat();
static void qq_show_addtolog(u64 filename, u64 logdest);
static void qq_showpcl_writepcl(u64 pcstart, u64 pc, u64 pclsource, i64 pass, u64 sourcecode);
static void qq_showpcl_gstr(u64 s);
static void qq_showpcl_gline();
static void qq_showpcl_gstrln(u64 s);
static void qq_showpcl_glabeldef(u64 pcstart, u64 pc);
static void qq_showpcl_gstrint(i64 a);
static void qq_showpcl_writeallpcl(u64 pm, i64 pass);
static void qq_showpcl_showpcl2(u64 sp, i64 pass);
static void qq_vars_var_free(u64 a);
static u64 qq_vars_void_new();
static i64 qq_vars_var_addto(u64 p, u64 b);
static i64 qq_vars_var_equalmixed(u64 a, u64 b);
static i64 qq_vars_var_comparemixed(u64 a, u64 b);
static void qq_vars_var_storeptr(u64 p, u64 q);
static void qq_vars_var_inplace_unary(u64 px, u64 fnneg);
static void qq_vars_var_putdotix_intint(u64 a, i64 index, u64 b);
static void qq_vars_var_powermixed(u64 a, u64 b);


int main(int nargs, char** args) {
    msysc_$getcommands(nargs, (u64)args, 0);
    qq_cli_main();
}

// **************************************************
static i64 msysc_fmtparam;
i64 msysc_$cmdskip;
static i64 msysc_needgap = 0;

static i64 msysc_outdev = 1;

static u64 msysc_outchan = 0;

static u64 msysc_fmtstr = 0;

static struct $B1 msysc_outchan_stack;
static struct $B1 msysc_outdev_stack;
static struct $B1 msysc_fmtstr_stack;
static struct $B2 msysc_needgap_stack;
static struct $B1 msysc_ptr_stack;
static i64 msysc_niostack = 0;

static struct $B3 msysc_digits = {{
3978425819141910832,
5063528411713059128}};

static struct $B3 msysc_defaultfmt = {{
112287625641984,
20992}};

static u64 msysc_rd_buffer;
static i64 msysc_rd_length;
static u64 msysc_rd_pos;
static u64 msysc_rd_lastpos;
static i64 msysc_termchar;
static i64 msysc_itemerror;
static struct $B4 msysc_printbuffer;
static u64 msysc_printptr;
static i64 msysc_printlen;
static i64 msysc_ncmdparams;
static u64 msysc_cmdparams;
static struct $B3 msysc_getfmt_fmt;
static struct $B5 msysc_strint_str;
static struct $B5 msysc_strword_str;
static struct $B6 msysc_strreal_str;
static struct $B7 mlib_allocupper;
static i64 mlib_alloccode;
static i64 mlib_allocbytes;
static i64 mlib_fdebug = 0;

static i64 mlib_rfsize;
static u64 mlib_maxmemory;
static i64 mlib_maxalloccode;
static u8 mlib_pcm_setup = 0;

static i64 mlib_show = 0;

static i64 mlib_memtotal = 0;

static i64 mlib_smallmemtotal = 0;

static i64 mlib_smallmemobjs = 0;

static i64 mlib_maxmemtotal = 0;

static struct $B8 mlib_memalloctable;
static struct $B9 mlib_memallocsize;
static u64 mlib_pcheapstart;
static u64 mlib_pcheapend;
static u64 mlib_pcheapptr;
static struct $B10 mlib_sizeindextable;
static struct $B11 mlib_freelist;
static struct $B12 mlib_pmnames = {{
(u64)"pm_end",
(u64)"pm_option",
(u64)"pm_sourcefile",
(u64)"pm_libfile",
(u64)"pm_colon",
(u64)"pm_extra"}};

static struct $B3 mlib_seed = {{
2993073034246558322,
1617678968452121188}};

static i64 mlib_pcm_newblock_totalheapsize;
// Istatic skipped:mlib.pcm_round.allocbytes

static struct $B14 mlib_changeext_newfile;
static struct $B14 mlib_extractpath_str;
static struct $B5 mlib_extractbasefile_str;
// Istatic skipped:mlib.nextcmdparamnew.infile

// Istatic skipped:mlib.nextcmdparamnew.filestart

// Istatic skipped:mlib.nextcmdparamnew.fileptr

// Istatic skipped:mlib.nextcmdparamnew.colonseen

static struct $B15 mlib_nextcmdparamnew_str;
static struct $B16 mlib_readnextfileitem_str;
static struct $B16 mlib_padstr_str;
static u64 mlib_chr_str;
static i64 mlinux_init_flag = 0;

static i64 qq_cli_nalldot;
static i64 qq_cli_nalldot1field;
static u64 qq_cli_syslibname;
static struct $B12 qq_cli_runnames = {{
(u64)"load_cc",
(u64)"parse_cc",
(u64)"names_cc",
(u64)"gencode_cc",
(u64)"fixup_cc",
(u64)"run_cc"}};

static u8 qq_cli_fshowpcl1;
static u8 qq_cli_fshowpcl2;
static u8 qq_cli_fshowast1;
static u8 qq_cli_fshowast2;
static u8 qq_cli_fshowst;
static u8 qq_cli_fshowstflat;
static u8 qq_cli_fshowtypes;
static u8 qq_cli_foptimise = 1;

static u8 qq_cli_fwriteqa;
static u8 qq_cli_fshowmodules;
static u8 qq_cli_fallsp;
static u8 qq_cli_runcode = 6;

static u64 qq_cli_sourcestr;
static u64 qq_cli_inputfile;
static u64 qq_cli_allprocdefs;
static u64 qq_cli_allstaticdefs;
static u64 qq_cli_pclstr;
static i64 qq_cli_cmdstartindex;
static struct $B3 qq_decls_nextlx;
static struct $B3 qq_decls_lx;
static i64 qq_decls_qpos;
static i64 qq_decls_pcerrorpos;
static u64 qq_decls_pcerrormodule;
static struct $B17 qq_decls_varstack;
static u64 qq_decls_sptr;
static u64 qq_decls_stacklimit;
static u64 qq_decls_frameptr;
static u64 qq_decls_pcptr;
static i64 qq_decls_stopped;
static u64 qq_decls_stprogram;
static u64 qq_decls_stmodule;
static u64 qq_decls_stsubprog;
static u64 qq_decls_stcurrmodule;
static u64 qq_decls_stcurrproc;
static u64 qq_decls_currmodule;
static i64 qq_decls_debug;
static i64 qq_decls_inproc;
static struct $B18 qq_decls_genfieldtable;
static i64 qq_decls_ngenfields;
static i64 qq_decls_nlibfiles;
static struct $B19 qq_decls_libtable;
static struct $B20 qq_decls_libtypes;
static struct $B19 qq_decls_dllinsttable;
static i64 qq_decls_ndllprocs;
static struct $B21 qq_decls_dllproctable;
static struct $B22 qq_decls_dllproclibindex;
static struct $B21 qq_decls_dllprocaddr;
static u8 qq_decls_usebundled = 1;

static struct $B12 qq_decls_dispatchnames = {{
(u64)"-lab",
(u64)"-sw",
(u64)"-fn",
(u64)"-debug",
(u64)"-fdebug",
(u64)"-asm"}};

static i64 qq_decls_nqparams;
static struct $B16 qq_decls_qparamtable;
static u64 qq_decls_proclist;
static u64 qq_decls_proclistx;
static i64 qq_decls_nproclist;
static u64 qq_decls_pcl_callbackfn = 0;

static struct $B23 qq_decls_chrtable;
static u8 qq_decls_fnosys;
static u8 qq_decls_fverbose;
static struct $B24 qq_decls_baseclasstable;
static struct $B23 qq_decls_baseclassdef;
static i64 qq_decls_nbaseclasses;
static i64 qq_decls_lastretindex;
static struct $B25 qq_decls_modules;
static struct $B26 qq_decls_subprogs;
static i64 qq_decls_nmodules;
static i64 qq_decls_nsubprogs;
static i64 qq_decls_nalllines;
static struct $B27 qq_decls_qafilenames;
static struct $B27 qq_decls_qatext;
static struct $B27 qq_decls_qasize;
static i64 qq_decls_nqafiles;
static struct $B28 qq_decls_optionnames = {{
(u64)"load",
(u64)"parse",
(u64)"names",
(u64)"gen",
(u64)"fixup",
(u64)"run",
(u64)"ast1",
(u64)"ast2",
(u64)"pcl1",
(u64)"pcl2",
(u64)"allsp",
(u64)"st",
(u64)"stflat",
(u64)"types",
(u64)"modules",
(u64)"opt",
(u64)"no",
(u64)"ext",
(u64)"qa",
(u64)"qas",
(u64)"v",
(u64)"nosys",
(u64)"sys"}};

static struct $B28 qq_decls_optionvars = {{
(u64)&qq_cli_runcode,
(u64)&qq_cli_runcode,
(u64)&qq_cli_runcode,
(u64)&qq_cli_runcode,
(u64)&qq_cli_runcode,
(u64)&qq_cli_runcode,
(u64)&qq_cli_fshowast1,
(u64)&qq_cli_fshowast2,
(u64)&qq_cli_fshowpcl1,
(u64)&qq_cli_fshowpcl2,
(u64)&qq_cli_fallsp,
(u64)&qq_cli_fshowst,
(u64)&qq_cli_fshowstflat,
(u64)&qq_cli_fshowtypes,
(u64)&qq_cli_fshowmodules,
(u64)&qq_cli_foptimise,
(u64)&qq_cli_foptimise,
(u64)&qq_decls_usebundled,
(u64)&qq_cli_fwriteqa,
(u64)&qq_cli_fwriteqa,
(u64)&qq_decls_fverbose,
(u64)&qq_decls_fnosys,
(u64)&qq_decls_fnosys}};

static struct $B29 qq_decls_optionvalues = {{
1,
2,
3,
4,
5,
6,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
0,
1,
2,
1,
1,
0}};

static u64 qq_decls_stopseq;
static u64 qq_decls_raiseseq;
static i64 qq_decls_nproclocals;
static u64 qq_decls_pproclocals;
static struct $B30 qq_decls_pclcounts;
static i64 qq_decls_nallpcl;
static struct $B31 qq_decimal_fpnames = {{
(u64)"zero_type",
(u64)"normal_type",
(u64)"inf_type",
(u64)"nan_type"}};

static i64 qq_decimal_currprec = 55;

static i64 qq_decimal_stblz;
static u64 qq_decimal_constlist = 0;

static i64 qq_decimal_decstrsize;
static struct $B3 qq_decimal_vtemp;
static u8 qq_dicts_expanddict_inuse;
static u64 qq_host_procrefs;
static struct $B16 qq_host_pch_gethostname_name;
static struct $B16 qq_host_pch_getprogname_name;
static i64 qq_host_initprocrefs_oldnprocs;
static u64 qq_lex_lxsource;
static u64 qq_lex_lxstart;
static u64 qq_lex_lxsptr;
static i64 qq_lex_lxifcond;
static i64 qq_lex_longsuffix;
static i64 qq_lex_lxlineno;
static i64 qq_lex_nextlxlength;
static i64 qq_lex_lxlength;
static struct $B32 qq_lex_hashtable;
static u64 qq_lex_hashtablelast;
static u64 qq_lex_u64maxstr = (u64)"18446744073709551615";

static struct $B16 qq_lex_namemap;
static i64 qq_lex_lexinit_n;
static i64 qq_lib_currlineno;
static i64 qq_lib_nextavindex = 0;

static struct $B3 qq_lib_exprstrvar;
static u64 qq_lib_exprstr = (u64)&qq_lib_exprstrvar;

static i64 qq_lib_nlocalunits;
static u64 qq_lib_errormess;
static u64 qq_lib_bytemasks = -9205322385119247871;

static struct $B22 qq_lib_convtostringz_strbuffer1;
static struct $B22 qq_lib_convtostringz_strbuffer2;
static struct $B22 qq_lib_convtostringz_strbuffer3;
static struct $B22 qq_lib_convtostringz_strbuffer4;
static struct $B22 qq_lib_convtostringz_strbuffer5;
static struct $B22 qq_lib_convtostringz_strbuffer6;
// Istatic skipped:qq_lib.convtostringz.strindex

// Istatic skipped:qq_lib.convtostringz.table

// Istatic skipped:qq_lib.convtostringz.longstr

static u64 qq_lists_emptylist;
static struct $B15 qq_modules_getmodulefilename_str;
// Istatic skipped:qq_modules.loadstring.nextstrname

static i64 qq_names_sdsize;
static i64 qq_names_sdoffset;
static i64 qq_names_sdaligned;
static i64 qq_names_sdlevel;
static i64 qq_names_sdmode;
static i64 qq_names_sdnfields;
static i64 qq_names_sdmaxalign;
static struct $B2 qq_names_sdunion;
static struct $B1 qq_names_sdmaxsize;
static i64 qq_parse_intabledata;
static u64 qq_parse_tabledataname = 0;

static struct $B1 qq_parse_dollarstack;
static i64 qq_parse_ndollar = 0;

static u8 qq_parse_yieldseen;
static i64 qq_parse_currdllindex;
static i64 qq_parse_nextlambdaindex;
static struct $B34 qq_parse_listtypestack;
static i64 qq_parse_nlisttype;
static i64 qq_parse_listtype;
static i64 qq_parse_addstructflag_structseqno;
// Istatic skipped:qq_parse.readcompilervar.monthnames

static struct $B36 qq_pcltabs_opndnames = {{
(u64)"cnone",
(u64)"cstatic",
(u64)"cframe",
(u64)"cproc",
(u64)"cdllproc",
(u64)"cgenfield",
(u64)"clabel",
(u64)"cint",
(u64)"creal",
(u64)"cstring",
(u64)"cstringz",
(u64)"ctype",
(u64)"csymbol",
(u64)"coperator",
(u64)"cmaths",
(u64)"chost",
(u64)"cbinto",
(u64)"?"}};

static struct $B30 qq_pcltabs_pclnames = {{
(u64)"knop",
(u64)"kskip",
(u64)"kprocdef",
(u64)"kprocent",
(u64)"kprocend",
(u64)"kendmod",
(u64)"kcomment",
(u64)"kpushm",
(u64)"kpushf",
(u64)"kpushmref",
(u64)"kpushfref",
(u64)"kpushlab",
(u64)"kpopm",
(u64)"kpopf",
(u64)"kpushci",
(u64)"kpushvoid",
(u64)"kpushnil",
(u64)"kpushcr",
(u64)"kpushcs",
(u64)"kpushtype",
(u64)"kpushopc",
(u64)"kpushsym",
(u64)"kpushptr",
(u64)"kpopptr",
(u64)"kzpopm",
(u64)"kzpopf",
(u64)"kdupl",
(u64)"kcopy",
(u64)"kswap",
(u64)"kconvrefp",
(u64)"kjump",
(u64)"kjumpptr",
(u64)"kjumpt",
(u64)"kjumpf",
(u64)"kjumpeq",
(u64)"kjumpne",
(u64)"kjumplt",
(u64)"kjumple",
(u64)"kjumpge",
(u64)"kjumpgt",
(u64)"kwheneq",
(u64)"kwhenne",
(u64)"kjumplab",
(u64)"kswitch",
(u64)"ktom",
(u64)"ktof",
(u64)"kformci",
(u64)"kforfci",
(u64)"kformm",
(u64)"kforff",
(u64)"kcallproc",
(u64)"kcallptr",
(u64)"kretproc",
(u64)"kretfn",
(u64)"kmodcall",
(u64)"kmodret",
(u64)"kcalldll",
(u64)"kcallhost",
(u64)"kunshare",
(u64)"kaddsp",
(u64)"kstop",
(u64)"kmakelist",
(u64)"kmakevrec",
(u64)"kmakeax",
(u64)"kmakebits",
(u64)"kmaketrec",
(u64)"kmakeset",
(u64)"kmakerang",
(u64)"kmakedict",
(u64)"kmakedec",
(u64)"kincrptr",
(u64)"kincrtom",
(u64)"kincrtof",
(u64)"kloadincr",
(u64)"kincrload",
(u64)"kneg",
(u64)"kabs",
(u64)"knotl",
(u64)"kinot",
(u64)"kistruel",
(u64)"kasc",
(u64)"kchr",
(u64)"ksqr",
(u64)"kmaths",
(u64)"kmaths2",
(u64)"kunaryto",
(u64)"knotlto",
(u64)"klen",
(u64)"klwb",
(u64)"kupb",
(u64)"kbounds",
(u64)"kbytesize",
(u64)"ktype",
(u64)"kdictsize",
(u64)"kisfound",
(u64)"kminval",
(u64)"kmaxval",
(u64)"kistype",
(u64)"kisvoid",
(u64)"kconvert",
(u64)"ktypepun",
(u64)"kadd",
(u64)"ksub",
(u64)"kmul",
(u64)"kdiv",
(u64)"kidiv",
(u64)"kirem",
(u64)"kidivrem",
(u64)"kiand",
(u64)"kior",
(u64)"kixor",
(u64)"kshl",
(u64)"kshr",
(u64)"kin",
(u64)"kinx",
(u64)"kcmp",
(u64)"kmin",
(u64)"kmax",
(u64)"kconcat",
(u64)"kappend",
(u64)"ksame",
(u64)"kpower",
(u64)"kbinto",
(u64)"kandlto",
(u64)"korlto",
(u64)"kconcatto",
(u64)"kappendto",
(u64)"kdot",
(u64)"kpopdot",
(u64)"kdotref",
(u64)"kindex",
(u64)"kpopix",
(u64)"kindexref",
(u64)"kkeyindex",
(u64)"kpopkeyix",
(u64)"kkeyixref",
(u64)"kdotix",
(u64)"kpopdotix",
(u64)"kdotixref",
(u64)"kexpand",
(u64)"kpushtry",
(u64)"kraise",
(u64)"kmap",
(u64)"kpushfff",
(u64)"kpushff",
(u64)"kpushmm",
(u64)"kpushfm",
(u64)"kpushmf",
(u64)"kpushmci",
(u64)"kpushfci",
(u64)"kmoveff",
(u64)"kmovemm",
(u64)"kmovefm",
(u64)"kmovemf",
(u64)"kzmoveff",
(u64)"kmovefci",
(u64)"kmovemci",
(u64)"kzmovefci",
(u64)"kpushv2",
(u64)"kpushv3",
(u64)"kjmpeqfci",
(u64)"kjmpnefci",
(u64)"kjmpltfci",
(u64)"kjmplefci",
(u64)"kjmpgefci",
(u64)"kjmpgtfci",
(u64)"kjmpeqff",
(u64)"kjmpneff",
(u64)"kjmpltff",
(u64)"kjmpleff",
(u64)"kjmpgeff",
(u64)"kjmpgtff",
(u64)"kaddfci",
(u64)"ksubfci",
(u64)"kaddff",
(u64)"ksubff",
(u64)"kaddci",
(u64)"ksubci",
(u64)"kiandci",
(u64)"kshlci",
(u64)"kshrci",
(u64)"kbintof",
(u64)"kaddtof",
(u64)"kaddtofci",
(u64)"ksubtofci",
(u64)"kshltofci",
(u64)"kshrtofci",
(u64)"kindexmf",
(u64)"kindexff",
(u64)"kswitchf",
(u64)"kpushptrf",
(u64)"kpushipm",
(u64)"kpushipf",
(u64)"kpopipm",
(u64)"kpopipf",
(u64)"kupbm",
(u64)"kupbf",
(u64)"klenf",
(u64)"kstoref",
(u64)"kwheneqci",
(u64)"kwhenneci",
(u64)"klastpcl"}};

static struct $B37 qq_pcltabs_pclopnd = {{
0,
12,
0,
256,
258,
1538,
513,
7,
2048,
2825,
3085,
0,
513,
0,
0,
6,
1542,
1542,
1542,
1542,
1542,
6,
1542,
1542,
1542,
3,
0,
12,
3844,
0,
0,
0,
0,
0,
0,
256,
2,
0,
0,
0,
0,
3584,
3342,
0,
0,
0,
0,
0,
2816,
2816,
11,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
16,
0,
1280,
1285,
0,
0,
0,
0,
0,
6,
512,
2,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
0,
1792,
519,
514,
514,
2,
0,
0,
0,
0,
0,
1792,
7}};

static struct $B38 qq_pcltabs_pclattrs = {{
2314885530818453536,
2314885865825902624,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314983765310447648,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885865825902702,
2340033895776417902,
2314885530818453536,
2314885530818453614,
2314885865825902702,
2314983765310447726,
8535862225592677752,
2314979368712370552,
2314885530818453624,
2314885530818453624,
2314885908775575672,
2314885908775575672,
2314885530818453624,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453614,
2314885530818453614,
2314885530818453536,
2314885530818453536,
2314885530818453614,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885865825902624,
2314885818581262368,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885865825902624,
2314885908775598456,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536}};

static struct $B39 qq_pcltabs_bintotable = {{
101,
(u64)&qq_vars_var_add,
(u64)&qq_vars_var_addmixed,
102,
(u64)&qq_vars_var_sub,
(u64)&qq_vars_var_submixed,
103,
(u64)&qq_vars_var_mul,
(u64)&qq_vars_var_mulmixed,
104,
(u64)&qq_vars_var_div,
(u64)&qq_vars_var_divmixed,
108,
(u64)&qq_vars_var_iand,
0,
109,
(u64)&qq_vars_var_ior,
0,
110,
(u64)&qq_vars_var_ixor,
0,
116,
(u64)&qq_vars_var_min,
0,
117,
(u64)&qq_vars_var_max,
0,
111,
(u64)&qq_vars_var_shl,
0,
112,
(u64)&qq_vars_var_shr,
0}};

static struct $B40 qq_pclgen_loopstack;
static struct $B34 qq_pclgen_trylevelstack;
static i64 qq_pclgen_loopindex = 0;

static i64 qq_pclgen_looptrylevel;
static i64 qq_pclgen_trylevel = 0;

static i64 qq_pclgen_retindex;
static i64 qq_pclgen_retvaloffset;
static i64 qq_pclgen_nprocparams;
static u64 qq_pclgen_pprocentry;
static i64 qq_pclgen_procskiplabel;
static u64 qq_pcllib_pcstart;
static u64 qq_pcllib_pccurr;
static u64 qq_pcllib_pcend;
static i64 qq_pcllib_pcalloc;
static u64 qq_pcllib_pcsourcestart;
static u64 qq_pcllib_pcsourcecurr;
static i64 qq_pcllib_pclcurrlineno;
static u64 qq_pcllib_labelpctable;
static i64 qq_pcllib_labelalloc;
static i64 qq_pcllib_nextlabelno;
static i64 qq_print_mindev;
static i64 qq_print_moutdev;
static u64 qq_print_minchan;
static u64 qq_print_moutchan;
static struct $B3 qq_print_minvar;
static struct $B3 qq_print_moutvar;
static struct $B8 qq_print_moutdevstack;
static struct $B12 qq_print_moutchanstack;
static struct $B35 qq_print_moutvarstack;
static struct $B41 qq_print_mgapstack;
static struct $B12 qq_print_mfmtstrstack;
static struct $B12 qq_print_mfmtcurrstack;
static i64 qq_print_noclevels;
static u64 qq_print_mfmtstr;
static u64 qq_print_mfmtcurr;
static struct $B3 qq_print_defaultfmt = {{
112287625641984,
20992}};

static u8 qq_print_mgapneeded;
static u64 qq_print_kb_start;
static u64 qq_print_kb_pos;
static u64 qq_print_kb_lastpos;
static i64 qq_print_kb_size;
static i64 qq_print_kb_linelength;
static i64 qq_print_kb_length;
static i64 qq_print_kb_lastlength;
static u8 qq_print_termchar;
static i64 qq_print_itemerror;
static u64 qq_print_testfilech;
static i64 qq_print_listdepth = 0;

static i64 qq_resolve_nprocs;
static i64 qq_resolve_noexpand;
static i64 qq_resolve_symbolmode;
static i64 qq_resolve_macrolevels;
static i64 qq_resolve_allowmodname;
static struct $B19 qq_resolve_macroparams;
static struct $B19 qq_resolve_macroparamsgen;
static struct $B19 qq_resolve_macroargs;
static i64 qq_resolve_nmacroparams;
static i64 qq_resolve_nmacroargs;
static struct $B27 qq_resolve_structfields;
static i64 qq_resolve_ntopfields;
static i64 qq_resolve_nallfields;
static u64 qq_runx_jumptable;
static u8 qq_runx_getjt;
// Istatic skipped:qq_runx.disploop.count

static i64 qq_runaux_runproc_m_rmsg_typeno;
static struct $B6 qq_runaux_k_map_codeseq;
// Istatic skipped:qq_sets.var_make_set.count

// Istatic skipped:qq_sets.var_in_set.masks

static u64 qq_strings_emptystring;
static struct $B42 qq_syslibs_syslibnames = {{
(u64)"syswin.q",
(u64)"syslin.q",
(u64)"sysp.q",
(u64)"windows.q",
(u64)"linux.q",
(u64)"clibp.q",
(u64)"smlib.q",
(u64)"winapi.q",
(u64)"gxlib.q",
(u64)"bmlib.q",
(u64)"console.q",
(u64)"lincon.q",
(u64)"winconsts.q",
(u64)"wingxlib.q",
(u64)"winmessages.q",
(u64)"gxmisc.q",
(u64)"dates.q"}};

static struct $B42 qq_syslibs_libtext = {{
(u64)"!Q standard library - Windows\n\n!===============================\nmodule sysp\nmodule clibp\nmodule winapi\nmodule windows\n\nmodule gxlib\nmodule bmlib\nmodule console\nmodule winconsts\nmodule wingxlib\nmodule winmessages\nmodule gxmisc\nmodule dates\nmodule smlib\n!===============================\n\n",
(u64)"!Q standard library - Linux\n\n!===============================\nmodule sysp\nmodule clibp\nmodule linux\n!module winapi\n\n!module gxlib\n!module bmlib\n!module console\nmodule lincon\n!module winconsts\n!module wingxlib\n!module winmessages\n!module gxmisc\n!module dates\n!module smlib\n!===============================\n\nexport macro console = lincon\n",
(u64)"!Q Main Library\n\nexport type rkey=struct\t!key info as it's used locally\n\tu16\tcharcode\n\tbyte\tkeycode\n\tbyte\tshift\nend\n\nexport var ncmdparams\nexport var cmdparams\nexport var stclock=0\n\nexport const tab=\"\\t\"\n\nexport var readfilesize\n\nexport var infinity=$infinity()\nexport var nan=$nan()\n\nproc start=\n\n\tncmdparams:=getcmdparam()\n\n\tcmdparams:=new(list,1..ncmdparams)\n\n\ts::=\"\"\n\tfor i:=1 to ncmdparams do\n\t\tcmdparams[i]:=getcmdparam(i)\n\t\ts+:=cmdparams[i]+\" \"\n    od\n\n\tsreadln(s)\nend\n\nexport proc reporterror(m)=\n#print \"Error:\" followed by message m. Is that it? Count as being deprecated\n\n\tprintln \"Error:\",m\nend\n\nexport func splitstring(s,?sep)=\n#split up the string s into strings separated by the sep sequence\n#return a list of all the individual strings, excluding the sep seq\n\n\tif s=\"\" or sep=\"\" then return (s,) fi\n\n\ta::=()\n\tns:=0\n\n\tif sep.isvoid then\t\t\t!use any white space of variable width\n\n\t\twhitespace:=(' ','\\t',13,10)\n\n\t\ts:=s+chr(0)\n\t\tp:=&s\n\t\tt::=\"\"\n\t\tinstr:=0\n\n\t\twhile c:=p++^ do\n\t\t\tif c in whitespace then\n\t\t\t\tif instr then\n\t\t\t\t\ta[++ns]:=t\n\t\t\t\t\tt::=\"\"\n\t\t\t\t\tinstr:=0\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tinstr:=1\n\t\t\t\tt+:=c\n\t\t\tfi\n\t\tod\n\t\n\t\tif t then\n\t\t\ta[++ns]:=t\n\t\tfi\n\n\t\treturn a\n\n\telse\n\t\tdo\n\t\t\tn:=sep inx s\n\t\t\tif not n.isfound then\n\t\t\t\ta[++ns]:=s\n\t\t\t\treturn a\n\t\t\tfi\n\t\t\tt:=leftstr(s,n-1)\n\t\t\ta[++ns]:=t\n\t\t\ts:=rightstr(s,-(n+sep.len-1))\n\t\tod\n\tfi\n\treturn \"\"\nend\n\nexport func joinstrings(a,sep)=\n#join the strings in list, using the given separator string\n#return new single string\n\tif a.upb=0 then return \"\" fi\n\ts:=a[1]\n\tfor i:=2 to a.upb do\n\t\ts:=s+sep+a[i]\n\tod\n\treturn s\nend\n\nexport proc abort(s)=\n#Print message, pause for keypress, then stop the interpreter with stopcode 1\n\n\tprintln \"Abort:\",s,\"Error\"\n\twaitkey()\n\tstop 1\nend\n\nexport func extractpath(fs)=\n#fs is a full filespec string\n#extract any path from it and return that; ie, strip the filename\n#otherwise return \"\"\n\tl:=fs.len\n\tfor i:=l downto 1 do\n\t\tif chr(fs.[i]) in \"\\\\/:\" then\n\t\t\treturn leftstr(fs,i)\n\t\tfi\n\tod\n\treturn \"\"\nend\n\nexport func extractfile(fs)=\n#return filename portion of path fs\n\tp:=extractpath(fs)\n\tif p=\"\" then return fs fi\n\treturn rightstr(fs,-p.len)\nend\n\nexport func extractbasefile(fs)=\n#return filename portion of path fs\n\tf:=extractfile(fs)\n\tif f=\"\" then return \"\" fi\n\te:=extractext(f)\n\tif e.len then\n\t\tf:=leftstr(f,-e.len)\n\tfi\n\tif rightstr(f)=\".\" then\n\t\tf:=leftstr(f,-1)\n\tfi\n\treturn f\nend\n\nexport func extractext(fs,period=0)=\n#extract extension part of filespec fs\n#endings of \"xxx\" (no extension) and \"xxx.\" both return \"\"\n#with period=1, then \"xxx\" returns \"\" and \"xxx.\" returns . (so can be used to\n#override default extensions)\n\n\tf:=extractfile(fs)\n\tif f=\"\" then return \"\" fi\n\te:=\"\"\n\tdo\n\t\tn:=\".\" inx f\n\t\tif n.isfound then\n\t\t\te:=rightstr(f,-n)\n\t\t\tif e=\"\" then\t\t!. ending\n\t\t\t\treturn (period.defined and period|\".\"|\"\")\n\t\t\tfi\n\n\t\t\tf:=e\n\t\telse\n\t\t\texit\n\t\tfi\n\tod\n\n\treturn e\nend\n\nexport func changeext(file,newext,soft=0)=\n#normally face a change of extension to the file spec\n#use soft=1 to only change extension if no extension is present (a \".\" ending is an extension)\n\text:=extractext(file)\n\n\tp:=extractpath(file)\n\tbf:=extractbasefile(file)\n\tep:=extractext(file,1)\n\n\tif soft and ep<>\"\" then return file fi\t\t!has extension, don't change!\n\n\tif newext=\"\" then\n\t\treturn p+bf\n\telsif leftstr(newext)=\".\" then\n\t\treturn p+bf+newext\n\telse\n\t\treturn p+bf+\".\"+newext\n\tfi\nend\n\nexport func addpath(path,file)=\n#If file doesn't already have an absolute path (here, starting with \\ / or ?:)\n#then prepend 'path', which must end with \\ or /\n\tif leftstr(file) in \"/\\\\.\" or file.len>=2 and file.[2]=\":\" then\n\t\treturn file\n\tfi\n\treturn path+file\nend\n\nexport func addext(file,ext)=\n#add extension to filename, if it doesn't already have it's own extenstion\n\n\tif extractext(file,1)=\"\" then\n\t\treturn changeext(file,ext)\n\tfi\n\treturn file\nend\n\nexport func replacestr (s,a,b)=\n#if string a exists in s, then replace with b\n#return original or modified s\n\tdo\n\t\tn:=a inx s\n\t\tif not n.isfound then return s fi\n\t\ts:=leftstr(s,n-1)+b+rightstr(s,1-n-a.len)\n\tod\n\treturn \"\"\nend\n\nexport func parsecmdparams(cmd)=\n#cmd consists of:\n#blocks of text separated by whitespace or commas\n#each block is one of these formats\n# ...\t\tparam only\n# /...\t\tconsists of switches only\n# .../...\tparam followed by switches\n#return of (params,switches), where each is a list of strings\n#note that any correspondence between params and switches is lost; all switches assumed\n#to be global, but can appear anywhere\n#NOTE: cmd can also already be a list of blocks\n\n\tconst dash=\"-\"\n\n\tif cmd.islist then\n\t\tblocks:=cmd\n\telse\n\t\tsreadln(cmd)\n\t\tblocks::=()\n\t\tdo\n\t\t\tread a:\"s\"\n\t\t\tif a=\"\" then exit fi\n\t\t\tblocks append:=a\n\t\tod\n\tfi\n\n\tparams::=()\n\tswitches::=()\n\n\tfor x in blocks do\n\t\tn:=dash inx x\n!\t\tif n=0 then\t\t!pure param\n!\t\t\tparams append:=x\n\t\tif n=1 then\t\t!pure switches\n\t\t\tswitches concat:=splitstring(convlc(rightstr(x,-1)),\"/\")\n\t\telse\t\t\t!param followed by switches\n\t\t\tparams append:=x\n!\t\t\tparams append:=leftstr(x,n-1)\n!\t\t\tswitches concat:=splitstring(convlc(rightstr(x,-n)),\"/\")\n\t\tfi\n\tod\n\n\treturn (params,switches)\nend\n\nexport proc waitsec(secs)=\n#wait for given number of seconds, which can be a float. Call sleep()\n\tsleep(int(secs*1000))\nend\n\nexport func cmd_getswitches=\n#params is a list of strings, which\n#read all switches, and return a list of switch names (minus the \"/\")\n#each string can have more than one switch\n#some switches can follow a name in a string\n\n\tswitches::=()\n\tfor i:=1 to cmdparams.upb do\t\t!use 1..len in case called on <cmdparams> which has lwb 0\n\t\ts:=cmdparams[i]\n\t\tif leftstr(s) in \"-/\" then\n\t\t\tswitches append:=convlc(rightstr(s,-1))\n\t\tfi\n\tod\n\treturn switches\nend\n\nexport func cmd_getparams=\n#params is a list of strings\n#return list of actual params, not including any switches\n#switches are read separately using cmd_getswitches, but are not associated with\n#specific params. That would need to be done here (when / is detected in the middle\n#of a param, then make use readswitches. But to return that info, may be best to\n#create a parallel function)\n\n\tcmds::=()\n\n\tfor i:=1 to cmdparams.upb do\n\t\tpm:=cmdparams[i]\n!for pm in params do\n\t\tif leftstr(pm) in \"/-\" then\n\t\t\tnextloop\n\t\tfi\n!\tn:=\"/\" in pm\n!\tif n=0 then\n\t\t\tcmds append:=pm\n!\telse\n!\t\tcmds append:=leftstr(pm,n-1)\n!\tfi\n\tod\n\treturn cmds\nend\n\nexport func starttimer=\n#Start timer and remember ticks at this point\n\treturn stclock:=ticks()\nend\n\nexport func stoptimer=\n#Return number of ticks since starttimer was called, or last stoptimer\n#as the count is reset\n\n \td:=ticks()-stclock\n\tstclock:=ticks()\n\treturn d\nend\n\nexport func bnfact(n)=\n#n is limited to 9 million million million\n\n\tif n<=2 then\n\t\treturn longint(n)\n\tfi\n\n\tf:=1L\n\tg:=2L\n\tto n-1 do\n\t\tf:=f*g\n\t\tg:=g+1L\n\n\tod\n\treturn f\nend\n\nexport proc isort(a,?ll,?rr)=\n#inplace quicksort of a, which is anything that is indexable\n#ll rr are used for recursive calls\n\tif ll.isvoid then\n\t\tll:=a.lwb\n\t\trr:=a.upb\n\tfi\n\n\ti:=ll\n\tj:=rr\n\n\tpivot:=a[(ll+rr)%2]\n\n\trepeat\n\t\twhile pivot>a[i] and i<rr do ++i od\n\t\twhile pivot<a[j] and j>ll do --j od\n\t\tif i<=j then\n\t\t\tswap(a[i],a[j])\n\t\t\t++i\n\t\t\t--j\n\t\tfi\n\tuntil i>j\n\tif ll<j then isort(a,ll,j) fi\n\tif i<rr then isort(a,i,rr) fi\nend\n\nexport func sort(a)=\n#quicksort a and return newly sorted list. Duplicates a then uses isort\n\tb::=a\n\tisort(b)\n\treturn b\nend\n\nexport func pcerror(m)=\n#Force an interpreter error; advantage is that source location is reported.\n\n\tprintln \"Internal error:\",m\n\ta:=b+c\n\treturn 0\nend\n\n\n\n!=========================================\nexport proc insert(&a, b, c)=\n#insert value c just before index b\n#c is always a single value; to insert a sequence c, use insertn()\n\tn:=a.upb\n\ta[n+1]:=c\n\tfor i:=n downto b do\n\t\tswap(a[i+1],a[i])\n\tod\nend\n\nexport proc isort2(a,b,?ll,?rr)=\n#Like isort but also sorts b in parallel; sort order is determined by a however\n\tif ll.isvoid then\n\t\tll:=a.lwb\n\t\trr:=a.upb\n\tfi\n\n\ti:=ll\n\tj:=rr\n\n\tpivot:=a[(ll+rr)%2]\n\n\trepeat\n\t\twhile pivot>a[i] and i<rr do ++i od\n\t\twhile pivot<a[j] and j>ll do --j od\n\t\tif i<=j then\n\t\t\tswap(a[i],a[j])\n\t\t\tswap(b[i],b[j])\n\t\t\t++i\n\t\t\t--j\n\t\tfi\n\tuntil i>j\n\tif ll<j then isort2(a,b,ll,j) fi\n\tif i<rr then isort2(a,b,i,rr) fi\nend\n\nexport func left(a,n=1)=\n#return leftmost n elements of a (default left element)\n#when n is negative, all except rightmost -n\n\n\tif n>=0 then\n\t\treturn take(a,n)\n\telse\n\t\treturn take(a,a.len+n)\n\tfi\nend\n\nexport func right(a,n=1)=\n#return rightmost n elements of a (default right element)\n#when n is negative, all except leftmost -n\n\n\tif n>=0 then\n\t\treturn drop(a,a.len-n)\n\telse\n\t\treturn drop(a,-n)\n\tfi\nend\n\nexport func reverse(a)=\n#return reversed version of a\n#when 0, returns empty\n#when 1 element, returns a distinct, writeable copy\n\n\tif a.len=0 then\n\t\treturn makeempty(a)\n\tfi\n\tb::=a\n\n\tif a then\n\t\tfor i in a.bounds do\n\t\t\tb[a.upb-i+a.lwb]:=a[i]\n\t\tod\n\tfi\n\treturn b\nend\n\nexport func expandrange(a,step=1)=\n#Turn range a into a list of inclusive values\n\tx::=()\n\ti:=a.lwb\n\twhile i<=a.upb do\n\t\tx append:=i\n\t\ti+:=step\n\tod\n\treturn x\nend\n\nexport func head(a)=\n#return first element, or empty when empty\n\n\tif a.len then\n\t\treturn a[a.lwb]\n\telse\n\t\treturn makeempty(a)\n\tfi\nend\n\nexport func tail(a)=\n#return all except the first element\n#returns empty when only 0 or 1 elements\n\n\tcase a.len\n\twhen 0,1 then\n\t\treturn makeempty(a)\n\tesac\n\treturn a[2..$]\nend\n\nexport func init(a)=\n#return all except last element\n#returns empty when only 0 or 1 elements\n\tcase a.len\n\twhen 0,1 then\n\t\treturn makeempty(a)\n\tesac\n\treturn a[a.lwb..$-1]\nend\n\nexport func last(a)=\n#return last element, or empty\n\tif a.len then\n\t\treturn a[$]\n\telse\n\t\treturn makeempty(a)\n\tfi\nend\n\nexport func take(a,n)=\n#return first n elements from list/string a\n#returns () or \"\" when a is empty\n#n > 0 (n<=0 returns empty)\n\n\tif a.len=0 or n<=0 then\n\t\treturn makeempty(a)\n\tfi\n\tif n>=a.len then\n\t\treturn a\n\tfi\n\treturn a[a.lwb..a.lwb+n-1]\nend\n\nexport func drop(a,n)=\n#skips first n elements of a then returns the rest\n#returns () when empty, or skipping the whole list\n#n >= 0\n\n\tif a.len=0 or n>=a.len then\n\t\treturn makeempty(a)\n\tfi\n\tif n<=0 then\n\t\treturn a\n\tfi\n\treturn a[a.lwb+n..$]\nend\n\nexport func zip(a,b)=\n#return a list consisting of alternate elements from a and b\n#uses smaller of the two dimensions\n\n\tn:=min(a.len,b.len)\n\tc::=()\n\n!\tj:=a.lwb; k:=b.lwb\n\t(j, k) := (a.lwb, b.lwb)\n\n\tto n do\n\t\tc append:=a[j++]\n\t\tc append:=b[k++]\n\tod\n\treturn c\nend\n\nexport func repeatlist(a,n)=\n#duplicate a n times, and return the result\n#this ought to be built-in as a*n, but that's only implemented for a.len=1\n\n\tb:=makeempty(a)\n\tto n do\n\t\tb concat:=a\n\tod\n\treturn b\nend\n\n!export func minimum(a)=\n!#return minimum value of elements in a\n!\tif not a then\n!\t\treturn void\n!\tfi\n!\tx:=head(a)\n!\tfor y in tail(a) do\n!\t\tx min:=y\n!\tod\n!\treturn x\n!end\n!\n!export func maximum(a)=\n!#return maximum value of elements in a\n!\tif not a then\n!\t\treturn void\n!\tfi\n!\tx:=head(a)\n!\tfor y in tail(a) do\n!\t\tx max:=y\n!\tod\n!\treturn x\n!end\n!\n!export func sumlist(a)=\n!# apply \"+\" between all elements of a, and return result\n!# all elements must be compatble (all strings or all numbers for example)\n!# returns void then a is empty, or head(a) when just one element\n!\n!\tif not a then\n!\t\treturn void\n!\tfi\n!\tx:=head(a)\n!\tfor y in tail(a) do\n!\t\tx +:=y\n!\tod\n!\treturn x\n!end\n\nexport proc delete(&a,?b)=\n#delete element b\n\tn:=a.upb\n\tif b.isvoid then b:=n fi\n\n\tif n=b=1 then\n\t\ta::=()\n\t\treturn\n\tfi\n\n\tif b>n then return fi\n\tif b<a.lwb then return fi\n\tfor i:=b to n-1 do\n\t\tswap(a[i],a[i+1])\t\t\t!swap is faster for complex elements\n\tod\n!a[n]:=0\t\t!don't leave any heap data beyond new end of list\n\n\tresize(a,n-1)\nend\n\nexport proc resize(&a,n)=\n#hange the upper bound of a to n\n\n\tif n<a.lwb then\n\t\ta:=makeempty(a)\n\t\treturn\n\tfi\n\n\ta::=a[a.lwb..n]\t\t\t!duplication forces original to be freed\nend\n \nexport func makebits(data,t=bit)=\n#turn data (list, array, or bit array of different type) into a bit array\n\n\ta:=new(bits,t,data.bounds)\n\tfor i:=data.lwb to data.upb do\n\t\ta[i]:=data[i]\n\tod\n\treturn a\nend\n\nexport func makearray(data,t=i64)=\n#turn data (list, array of different type, or bit array) into an array of \n#given element type\n\n\ta:=new(array,t,data.bounds)\n\tfor i:=data.lwb to data.upb do\n\t\ta[i]:=data[i]\n\tod\n\treturn a\nend\n\nexport func tolist(a)=\n#convert a, a string, array or bits, to a list, and return that list\n\n\tcase a.basetype\n\twhen array,string,bits then\n\t\tb:=new(list,a.bounds)\n\t\tfor i,x in a do\n\t\t\tb[i]:=x\n\t\tod\n\t\treturn b\n!\twhen string then\n!\t\tb:=new(list,a.len)\n!\t\ti:=1\n!\t\tfor i,x in a do\n!\t\t\tb[i++]:=x\n!\t\tod\n!\t\treturn b\n\n\twhen list then\n\t\treturn a\n\telse\n\t\tpcerror(\"tolist:\"+tostr(a.type))\n\tesac\n\treturn 0\nend\n\nexport func toarray(a,?t)=\n#convert a, a list, string, array or bits, to an array, and return that array\n#can be used to turn one array type into another\n\tcase a.basetype\n\twhen list then\n\t\tif t.isvoid then\n\t\t\tif a then\n\t\t\t\tt:=a[a.lwb].type\n\t\t\telse\n\t\t\t\tt:=i32\n\t\t\tfi\n\t\tfi\n\n\twhen bits then\n\t\tif t.isvoid then\n\t\t\tt:=byte\n\t\tfi\n\n\twhen string then\n\t\tif t.isvoid then t:=byte fi\n\t\tb:=new(array,t,a.len)\n\t\tforeach i,x in a do\n\t\t\tb[i]:=x\n\t\tod\n\t\treturn b\n\twhen array then\n\t\tif t.isvoid then\n\t\t\treturn a\n\t\tfi\n\t\tu:=e.elemtype\n\t\tif t=u then return a fi\n\telse\n\t\tpcerror(\"toarray:\"+tostr(a.type))\n\tesac\n\tb:=new(array,t,a.bounds)\n\n\tfor i,x in a do\n\t\tb[i]:=x\n\tod\n\treturn b\nend\n\nexport func tobits(a,t=bit)=\n#convert a, a list, array or other bit array, into a bit array\n\n\tcase a.basetype\n\twhen list,array then\n\n\twhen bits then\n\t\tif a.elemtype=t then\n\t\t\treturn a\n\t\tfi\n\n\telse\n\t\tpcerror(\"tobits:\"+tostr(a.type))\n\tesac\n\tb:=new(bits,t,a.bounds)\n\tfor i,x in a do\n\t\tb[i]:=x\n\tod\n\treturn b\nend\n\nexport func listtostring(a)=\n#a should be a list or array\n#interpreter elements as characters and form a single string\n\ts:=\"\"\n\tfor x in a do\n\t\ts+:=chr(x)\n\tod\n\treturn s\nend\n\nexport func qversion=\n\treturn \"4.0\"\nend\n\nexport proc issort(a,?ll,?rr)=\n#Version of isort that works with dot-indexing\n\n\tif ll.isvoid then\n\t\tll:=a.lwb\n\t\trr:=a.upb\n\tfi\n\n\ti:=ll\n\tj:=rr\n\n\tpivot:=a.[(ll+rr)%2]\n\n\trepeat\n\t\twhile pivot>a.[i] and i<rr do ++i od\n\t\twhile pivot<a.[j] and j>ll do --j od\n\t\tif i<=j then\n\t\t\tswap(a.[i],a.[j])\n\t\t\t++i\n\t\t\t--j\n\t\tfi\n\tuntil i>j\n\tif ll<j then issort(a,ll,j) fi\n\tif i<rr then issort(a,i,rr) fi\nend\n\nexport func ssort(a)=\n#Version of sort() with dot-indexing, eg. strings, or int bits\n\n\tb::=a\n\tissort(b)\n\treturn b\nend\n\nexport func maketable(rows, cols, initval=0)=\n#Create a table: a rectangular list, set to either 0 or to initval\n#Each rows/cols is a range, or length\n\n\trow:=new(list,cols,initval)\n\n\ttable::=new(list,rows)\n\tif rows.isint then rows:=1..rows fi\n\n\tfor i in rows do\n\t\ttable[i]::=row\n\tod\n\n\treturn table\nend\n\nexport func mapv(op,a)=\n#Apply operator or suitable unary func to all elements of vector a,\n#and return new list \n\tb::=makeempty(a)\n\tfor i,x in a do\n\t\t\tb[i]:=mapss(op,x)\n\tod\n\treturn b\nend\n\nexport func mapvv(op,a,b)=\n#Apply op or func between corresponding elements of vectors a and b\n\tc::=makeempty(a)\n\tfor i,x in a do\n\t\tc[i]:=mapss(op,x,b[i])\n\tod\n\treturn c\nend\n\nexport func mapvs(op,a,bs)=\n#Apply op or func between elements of vector a and single value bs\n\tc::=makeempty(a)\n\tfor i,x in a do\n\t\tc[i]:=mapss(op,x,bs)\n\tod\n\treturn c\nend\n\nexport func mapsv(op,as,b)=\n#Apply op or func between elements of single value as and vector b\n!\tc::=makeempty(b)\n\tc::=()\n\tfor i,x in b do\n\t\tc[i]:=mapss(op,as,x)\n\tod\n\treturn c\nend\n\nexport func openfile(name,option=\"rb\")=\n#Open a file for reading. Uses C's fopen and default option is for binary mode\n#Return a valid file handle, which is an i64 value, or 0 when not found\n\tif not name.isstring or name=\"\" then\n\t\treturn 0\n\tfi\n\treturn fopen(name,option)\nend\n\nexport func createfile(name,options=\"wb\")=\n#Create a new file and return its handle, or 0 if there was an error\n\tif not name.isstring or name=\"\" then return 0 fi\n\treturn fopen(name,options)\nend\n\nexport func closefile(f)=\n#close the file associated with handle f\n\treturn fclose(f)=0\nend\n\nexport func checkfile(name)=\n#return 1 if file name exists, otherwise 0\n\tfile:=fopen(name,\"rb\")\n\tif file=0 then return 0 fi\n\tfclose(file)\n\treturn 1\nend\n\nexport func eof(f)=\n#return 1 if at eof on currently open file handle f\n\tc:=fgetc(f)\n\tif c=-1 then return 1 fi\n\n\tungetc(c,f)\n\treturn 0\nend\n\nexport func getfilesize(f)=\n#return size of bytes of currently open file f\n\tp:=ftell(f)\t\t\t!p=current position\n\tfseek(f,0,2)\t\t!get eof position\n\tsize:=ftell(f)\t\t!size in bytes\n\tfseek(f,p,0)\t\t!restore file position\n\treturn size\nend\n\nexport func getfilesize64(f)=\n#return size of bytes of currently open file f\n\tp:=_ftelli64(f)\t\t\t!p=current position\n\t_fseeki64(f,0,2)\t\t!get eof position\n\tsize:=_ftelli64(f)\t\t!size in bytes\n\t_fseeki64(f,p,0)\t\t!restore file position\n\treturn size\nend\n\nexport func setfilepos(f,offset)=\n#set position in file f to given byte offset\n\treturn fseek(f,offset,0)\nend\n\nexport func getfilepos(f)=\n#return current file position\n\treturn ftell(f)\nend\n\nexport func readrandom(f,mem,offset,size)=\n#read size bytes from file f, to memory at mem, from given offset\n#returns number of bytes read\n#mem needs to be a pointer\n#new file offset will be offset+size (or offset+byte read if smaller)\n\tfseek(f,offset,0)\n\treturn fread(mem,1,size,f)\nend\n\nexport func writerandom(f,mem,offset,size)=\n#write size bytes from memory at mem, to current file f from given offset\n#returns bytes written\n\tfseek(f,offset,0)\n\treturn fwrite(mem,1,size,f)\nend\n\nexport func readbytes(f,mem,size)=\n#read size bytes from current position in file f to mem\n\treturn fread(mem,1,size,f)\nend\n\nexport func writebytes(f,mem,size)=\n#write size bytes from mem to current position in f\n\treturn fwrite(mem,1,size,f)\nend\n\nexport func inbyte(file)=\t\t!INBYTE\n\treturn fgetc(file)\nend\n\nexport func inword(file)=\t\t!INWORD\n\tbb:=fgetc(file)\n\treturn fgetc(file)<<8+bb\nend\n\nexport func inlong(file)=\t\t!INLONG\n\tww:=inword(file)\n\treturn inword(file)<<16+ww\nend\n\nexport proc outbyte(file,x)=\t\t!OUTBYTE\n!writerandom(file,&x,getfilepos(file),1)\n\tfputc(x,file)\nend\n\nexport proc outword(file,x)=\t\t!OUTWORD\n\toutbyte(file,x iand 255)\n\toutbyte(file,x.[15..8])\nend\n\nexport proc outlong(file,x)=\t\t!OUTLONG\n\toutword(file,x iand 65535)\n\toutword(file,x>>16)\nend\n\nexport func instring(file)=\t\t!INSTRING\n\ts::=\"\"\n\tdo\n\t\tc:=inbyte(file)\n\t\tif c=0 then return s fi\n\t\ts+:=c\n\tod\n\treturn s\nend\n\nexport func appendfile(a,b)=\n#append line-based text file a to file b\n\n\tf:=openfile(a)\n\tif f=0 then return 0 fi\n\n\th:=openfile(b,\"ab\")\n\tif h=0 then return 0 fi\n\n\twhile not eof(f) do\n\t\treadln @f,x:\"l\"\n\t\tprintln @h,x\n\tod\n\n\tclosefile(f)\n\tclosefile(h)\n\treturn 1\nend\n\nexport func readblockfile(filename,doetx=0)=\n#read text file into a memory block\n#block is allocated here\n#return byte pointer to start of block, or nil\n#doetx=1 to add etx byte to end\n\n\tf:=openfile(filename)\n\tif f=0 then return nil fi\n\n\tn:=getfilesize(f)\n\treadfilesize:=n\n\n\ts:=malloc(n+doetx)\n\tif s=0 then abort(\"Readfile/Malloc fails\") fi\n\tsptr:=makeref(s,byte)\n\n!\treadrandom(f,&s,0,n)\n\treadrandom(f,s,0,n)\n\n\tif doetx then\n\t\t(sptr+n)^:=26\n\tfi\n\n\tclosefile(f)\n\treturn sptr\nend\n\nexport func readstrfile(filename,doetx=0)=\n#read text file into a single string\n#return string, or 0 if there was an error\n\n\tf:=openfile(filename)\n\tif f=0 then return 0 fi\n\n\tn:=getfilesize(f)\n\treadfilesize:=n\n\n\tptr:=malloc(n+1+doetx)\n\tif ptr=0 then abort(\"Readfile/Malloc fails\") fi\n\n\treadrandom(f,ptr,0,n)\n\tif doetx then\n\t\t(makeref(ptr,byte)+n)^:=26\n\tfi\n\n\tclosefile(f)\n\n\ts::=makestr(ptr,n+doetx)\n\n\tfree(ptr)\n\treturn s\nend\n\nexport func writestrfile(filename,s)=\n#read text file from a single string\n#return status\n\n\tf:=createfile(filename)\n\tif f=0 then return 0 fi\n\n\twriterandom(f,makeref(s,byte),0,s.len)\n\n\treturn closefile(f)\nend\n\nexport func readbinfile(filename)=\n#read binary file into byte array\n#return () (empty list not array) on error\n\n\tf:=openfile(filename)\n\tif f=0 then return 0 fi\n\n\tn:=getfilesize(f)\n\treadfilesize:=n\n\n\ta:=new(array,byte,n)\n\treadrandom(f,&a,0,n)\n\n\tclosefile(f)\n\treturn a\nend\n\nexport func writebinfile(filename,a)=\n#write binary file from byte array a\n#return status 1/0\n\n\tf:=createfile(filename)\n\tif f=0 then return 0 fi\n\n\twriterandom(f,(&a),0,a.len)\n\n\tclosefile(f)\n\treturn 1\nend\n\nexport func writeblockfile(filename,p,length)=\n#return status 1/0\n\n\tf:=createfile(filename)\n\tif f=0 then return 0 fi\n\n\tif not writerandom(f,p,0,length) then return 0 fi\n\n\tclosefile(f)\n\treturn 1\nend\n\nexport func erasefile(filename)=\n#delete given file, return status (check msdn)\n\treturn remove(filename)\nend\n\nexport func renamefile(oldfilename,newfilename)=\n#rename file, return status (check msnd)\n\treturn rename(oldfilename,newfilename)\nend\n\nexport func readtextfile(file)=\n#read text file into a list of strings; one per line\n#return list, or 0 on error\n\tf:=openfile(file)\n\tif not f then\n\t\treturn 0 \n\tfi\n\n\treadfilesize:=getfilesize(f)\n\ta::=()\n\n\twhile not eof(f) do\n\t\ta append:= sreadln(f)\n\tod\n\tclosefile(f)\n\treturn a\nend\n\nexport func writetextfile(file,a)=\n#write list of strings <a> as a text file <file>\n\tf:=createfile(file)\n\tif not f then return 0 fi\n\n\tfor i:=a.lwb to a.upb do\n\t\tprintln @f,a[i]\n\tod\n\tclosefile(f)\n\treturn 1\nend\n\nexport func readbinaryfile(filename,t)=\n#read binary file consisting of an array of type t values, into array of t\n#return () (empty list not array) on error\n\n\tf:=openfile(filename)\n\tif f=0 then return () fi\n\n\tn:=getfilesize(f)\n\treadfilesize:=n\n\telems:=n%t.bytes\n\n\ta:=new(array,t,elems)\n\treadrandom(f,&a,0,n)\n\n\tclosefile(f)\n\treturn a\nend\n\nexport func writebinaryfile(filename,data)=\n#write binary file from array of a fixed type to a file\n#return 1/0 status\n\treturn writeblockfile(filename,&data,data.bytes)\nend\n\nexport func confirm(m,caption=\"Confirm\",default=1)=\n#Pop-up box to ask for confirmationdefault=1/2/3 for yes/no/cancel button\n#Return 1 or 0\n\n\tflags:=0x20000+0x20\t!foreground window/question mark icon\n\tflags ior:=3\t\t!yes/no/cancel\n\n\tflags ior:=(default|0,0x100,0x200|0)\n\n\tstatus:=messagebox(nil,m,caption,flags)\n\treturn status=6\nend\n\nexport func messagebox(a=nil,mess,caption=\"Caption\",d=0)=\n#Standard Windows' Messagebox\n\treturn messageboxa(nil,mess,caption,d)\nend\n\nexport proc beep1=\n#Standard beep\n\tmessagebeep(0)\nend\n\nexport proc mem(mess)=\n\tstatic var startmem\n\tif startmem.isvoid then\n\t\tstartmem:=$smallmemtotal()\n\tfi\n\tprintln mess,,\":\",$smallmemtotal()-startmem\nend\n\nexport func reduce(op, a)=\n\tx:=head(a)\n\tfor y in tail(a) do\n\t\tx:=mapss(op,x,y)\n\tod\n\tx\nend\n",
(u64)"export func dirlist(s,t=1)=\n#s is a export filename (eg. \"*.dwg\") with possible drive/path; scan\n#directory for all matching files and return as a list of names\n#also returns total no. of files so far\n#t= +1\tInclude normal files, no sub-directory names\n#t= +2  Include directories\n#t= +3  Include all files including directories\n#t= +4  Convert to lower case\n#t=  0  Defaults to +1\n\n!CPL \"DIRLIST/WINLIB\"\n\n\tif t.isvoid then t:=1 fi\t\t\t!files only\n\n\tnfiles:=0\n\tdata::=()\n\tfile:=new(ws_finddata)\n\n\tif (hfind:=findfirstfile(s,&file))<>-1 then\t!at least one file\n\t\trepeat\n\t\t\tif (file.fileattributes iand 16) then\t\t!this is a directory\n\t\t\t\tif (t iand 2)=0 then goto skip fi\t\t!no directories\n\t\t\telse\t\t\t\t\t\t!this is a file\n\t\t\t\tif (t iand 1)=0 then goto skip fi\n\t\t\tfi\n\t\t\t++nfiles\n\t\t\tif (t iand 4) then\t\t\t\t!to lower case\n\t\t\t\tdata[nfiles]:=convlc(file.filename)\n\t\t\telse\n\t\t\t\tdata[nfiles]::=file.filename\n\t\t\tfi\n\tskip:\n\t\tuntil not findnextfile(hfind,&file)\n\t\tfindclose(hfind)\n\tfi\n\treturn data\nend\n\nexport func setcurrdir(newdir)=\n#Set current directory; return Windows' status code\n\treturn setcurrentdirectory(newdir)\nend\n\nexport func getcurrdir=\n#Return current directory name, always ends with \\ or /\n\ta:=new(array,byte,256)\n\tn:=getcurrentdirectory(a.len,&a[1])\n\n\tif n then\n\t\tdir::=makestr(&a[1],n)\n\telse\n\t\tdir:=\"\"\n\tfi\n\n\tif not (rightstr(dir) in \"\\\\/\") then dir +:= \"\\\\\" fi\n\treturn dir\nend\n\nexport func createdir(name)=\n#Create a new directory\n\treturn createdirectory(name,0)\nend\n\nexport func direxists(path)=\n#Return 1 if directory path exists\n\tconst file_attribute_directory=16\n\tconst invalid_file_attributes=-1\n\n\tattrib := getfileattributesa(path)\n\n\treturn attrib<>invalid_file_attributes and (attrib iand file_attribute_directory)\nend\n\n",
(u64)"export func dirlist(s,t=1)=\nABORT(\"DIRLIST\")\n0\nend\n\nexport func setcurrdir(newdir)=\n#Set current directory; return Windows' status code\n\tsystem(\"cd \"+newdir)=0\nend\n\nexport func getcurrdir=\n#Return current directory name, always ends with \\ or /\nABORT(\"GETCURRDIR\")\n0\nend\n\nexport func createdir(name)=\n#Create a new directory\n\tif not direxists(name) then\n\t\tsystem(\"mkdir \"+name)=0\n\telse\n\t\t1\n\tfi\nend\n\nexport func direxists(path)=\n#Return 1 if directory path exists\n\tcheckfile(path+\"/.\")\n\nend\n\n",
(u64)"importdll msvcrt=\n!importdll msvcr100=\n!importdll msvcr120=\n\tfunc \"malloc\"        (i64)ref byte\n\tfunc realloc(i64, i32)i64\n\tproc free        (i64)\n\tproc memset      (ref byte, i32, i32)\n\tproc memcpy      (ref byte, ref byte, i32)\n\tfunc memcmp      (ref byte, ref byte, i32)i32\n!\tfunc clock       :i32\n\tfunc ftell       (i64)i32\n\tfunc _ftelli64   (i64)i64\n\tfunc fseek       (i64, i32, i32)i32\n\tfunc _fseeki64   (i64, i32, i32)i64\n\tfunc fread       (ref byte, i32, i32, i64)i32\n\tfunc fwrite      (ref byte, i32, i32, i64)i32\n\tfunc getc   (i64)i32\n\tfunc ungetc (i32, i64)i32\n\tfunc fopen       (stringz, stringz)i64\n\tfunc fclose      (i64)i32\n\tfunc fgets       (ref byte, i32, i64)ref byte\n\tfunc remove      (stringz)i32\n\tfunc rename      (stringz, stringz)i32\n\tfunc getchar     :i32\n\tproc putchar     (i32)\n\tproc setbuf      (i64, i64)\n\n\tfunc rand        :i32\n\tproc srand       (i32)\n\n\tfunc puts        (stringz)i32\n\tfunc printf      (stringz, ...)i32\n\n\tfunc sprintf     (stringz, stringz, ...)i32\n\n\tfunc sscanf      (stringz, stringz, ...)i32\n\tfunc isalpha     (i32)i32\n\tfunc tolower     (i32)i32\n\tfunc strlen      (ref byte)i32\n\tfunc atoi        (stringz)i32\n\n!   clang func system      (stringz)i32\n\n\tfunc fgetc  (i64)i32\n\tfunc fputc  (i32,  i64)i32\n\tfunc fprintf     (i64, stringz, ...)i32\n\tfunc fputs       (stringz,  i64)i32\n\tfunc feof        (i64)i32\n!   clang func getch       :i32\n\tfunc _getch      :i32\n\tproc fflush      (ref void)\n\tproc tcflush     (int, int)\n\nend\n\nglobal const c_eof     = -1\nglobal const seek_set  = 0\nglobal const seek_curr = 1\nglobal const seek_end  = 2\n\n",
(u64)"\nexport var popuplist::=()\nexport var focuslist::=()\nexport var npopups=0\nexport var message\nexport var messw, messa, messb\nexport var wpopup=nil\n\nrecord blockrec=\n\tvar posx, posy\t\t\t\t!pixel position of top left of block: relative to other\n\t\t\t\t\t\t\t\t!blocks, later within client area of containing window\n\tvar dimx,dimy\t\t\t\t!'client' area of block, including margins, cells and gaps\n\tvar celldimx, celldimy\t\t!size of each cell, in pixels\n\tvar cellsx, cellsy\t\t\t!number of identically-svert hoz and vertical controls\n\tvar gapx, gapy\t\t\t\t!gap between cells, in pixels\n\tvar marginx, marginy\t\t!margins around all cells\n\tvar labelwidth\t\t\t\t!for edit boxes, how many pixels on left are for label\n\tvar cellposx,cellposy\t\t!position of top left cell within block\n\tvar pitchx,pitchy\t\t\t!1st cell is at for edit boxes, how many pixels on left are for label\n\tvar blockstyle\t\t\t\t!style record for blocks\n\tvar name\t\t\t\t\t!name for debugging\n\tvar dir\t\t\t\t\t\t!'H' or 'V' for stepping direction\n\nend\n\nvar blocklist::=()\nvar nblocks=0\nvar\tcurrblock =nil\t\t\t\t!current blockrec\nvar\tcurrgroup =nil\t\t\t\t!rwindow corresponding to currblock\nvar\tcurrpopup =nil\t\t\t\t!rwindow for menu to contain current set of blocks\nvar cellx, celly\t\t\t\t!current cell within current block\nvar slposx,slposy,sldir\t\t\t!set by smcreate in case sl-functions are used\n\n!proc showblockinfo(block)=\n!println \"Block:      \",(block.name.isdef|block.name|\"\")\n!println \"Pos:        \",block.posx,block.posy\n!println \"Dim:        \",block.dimx,block.dimy\n!println \"CellDim:    \",block.celldimx,block.celldimy\n!println \"Gap:        \",block.gapx,block.gapy\n!println \"Cells:      \",block.cellsx,block.cellsy\n!println \"Gaps:       \",block.gapx,block.gapy\n!println \"Margins:    \",block.marginx,block.marginy\n!println \"Labelwidth: \",block.labelwidth\n!println \"Cellpos:    \",block.cellposx,block.cellposy\n!println \"Pitch:      \",block.pitchx,block.pitchy\n!println \"Dir:        \",block.dir\n!println\n!end\n\nexport proc sminit=\n\tblocklist::=()\n\tnblocks:=0\nend\n\nexport func smdefblock(?dim,cells=1,style=\"\",gap=0,labeldim=\"\",margin=0,dir='V')=\n!define a matrix of cells, all the same size, to be used as controls\n!dim\tis a the size of each cell, as pixel dims, or as a sample string\n!cells\tis a the hoz and vert cell count. Or it can be an int for vert column only\n!gap\tis the inter-cell gap, specified in pixels. Default is to use chx or chy.\n!\t\tgap can be (x,y), or just n for the same gap in hoz and vert\n!style\tCurrently, a string containing various styles and options. Will be\n!\tcompatible with old uses of these functions. Or can be replaced with a dict\n!label\tWhen specified, is a sample string givibg the length of the label on the left\n!\t\tof edit boxes; can also be a pixel width\n!return handle to block\n!also add block to export blocklist\n\n\tblock:=new(blockrec,0)\n\tblock.dir:=dir\n!block.dir:='H'\n\n\tif dim.isstring then\n\t\tblock.celldimx:=gxtextwidth(labelfont,dim)+smx*2\n\t\tblock.celldimy:=chy+smy*2\n\telse\n\t\t(block.celldimx,block.celldimy):=dim\n\tfi\n\n\tif cells.isint then\n\t\tblock.cellsx:=1\n\t\tblock.cellsy:=cells\n\telse\n\t\t(block.cellsx,block.cellsy):=cells\n\tfi\n\n\tif gap.isint then\n\t\tblock.gapx:=gap\n\t\tblock.gapy:=gap\n\telse\n\t\t(block.gapx,block.gapy):=gap\n\tfi\n\n\tif margin.isint then\n\t\tblock.marginx:=margin\n\t\tblock.marginy:=margin\n\telse\n\t\t(block.marginx,block.marginy):=margin\n\tfi\n\n\tif labeldim then\n\t\tif labeldim.isstring then\n\t\t\tblock.labelwidth:=gxtextwidth(labelfont,labeldim)+smx*2\n\t\telse\n\t\t\tblock.labelwidth:=labeldim\n\t\tfi\n\t\tblock.celldimx+:=block.labelwidth\n\tfi\n\n\tblock.blockstyle:=readstylestr(style)\n\n!CPL \"BLOCKSTYLE\",STYLE,BLOCK.BLOCKSTYLE\n\n!now work out overall size of the block, and the pitch between cells\n!this needs to take account of the frame size of each cell, which depends on\n!its border style\n!block position is done at a higher level using smorder\n\n\tbdx:=bdy:=1\t\t\t\t!use border widths of 0 for now (and assume same all round)\n\n\tblock.pitchx:=block.celldimx+bdx*2+block.gapx\t\t!hoz pitch\n\tblock.pitchy:=block.celldimy+bdy*2+block.gapy\t\t!vert\n\n!CPL \"PITCHY\",BLOCK.PITCHY,=BDY,=BLOCK.GAPY\n!CPL \"MARGINY\",BLOCK.MARGINY\n\n\tblock.cellposx:=block.marginx+bdx\t\t\t\t\t!position of client area of 1st cell\n\tblock.cellposy:=block.marginy+bdy\n\n\tblock.dimx:=block.pitchx*block.cellsx-block.gapx+block.marginx*2\n\tblock.dimy:=block.pitchy*block.cellsy-block.gapy+block.marginy*2\n\n\tblocklist[++nblocks]:=block\n\n\treturn block\nend\n\nexport func smmenusize(margin=chy)=\n!work out overall bounding box for all blocks, and relocate blocks (or set their\n!pos values) so that each is positioned within to the bounding box rectangle\n!return (dimx,dimy)\n\n!get bounding box in (x1,y1), (x2,y2)\n\tfor i,block in blocklist do\n\t\tif i=1 then\t\t\t\t!first block\n\t\t\tx1:=block.posx\n\t\t\ty1:=block.posy\n\t\t\tx2:=x1+block.dimx-1\n\t\t\ty2:=y1+block.dimy-1\n\t\telse\n\t\t\tx1 min:=block.posx\n\t\t\ty1 min:=block.posy\n\t\t\tx2 max:=block.posx+block.dimx-1\n\t\t\ty2 max:=block.posy+block.dimy-1\n\t\tfi\n\tod\n\n!now, need to relocate each block so they stay at the same position relative to\n!each other, but are positioned within the client area of an owner window\n!this effectively relocates (x1,y1) to (0,0), so the offset to be applied to\n!each block is -(x1,y1), plus (margin,margin)\n\n\tfor block in blocklist do\n\t\tblock.posx+:=margin-x1\n\t\tblock.posy+:=margin-y1\n\tod\n\n!return (x1-margin,y1-margin,x2-y1+margin*2+1,y2-y1+margin*2+1)\n\treturn (x2-x1+margin*2+1,y2-y1+margin*2+1)\nend\n\nexport proc smorder(blocks,dir='D')=\n!take a blocks, and arrange all in a line, relative to the first\n!dir is one of \"U\", \"D\", \"L\", \"R\" (or can be char codes or in lower case)\n!some block elements can be an integer specifing a gap between the blocks.\n!the gap is specified in pixels. The default gap is chx for hoz and chy for vertical\n!(***I THINK that the gap override is only between two blocks, so needs the reset to\n!default after. That mean also that the first list item must be a block***)\n\n\tif dir.isstring then\n\t\tdir:=asc(convuc(dir))\t\t\t!\"r\",\"R\" or 'R' possible, but not 'r'\n\tfi\n\n\tbdx:=bdy:=1\t\t\t\t\t\t!border widths for the blocks\n\n\tdx:=chx+bdx\n\tdy:=chy+bdy\n\tfirstblock:=1\n\n\tfor block in blocks do\n\t\tif block.isint then\t\t\t!is a gap\n\t\t\tdx:=block+bdx*2\n\t\t\tdy:=block+bdy*2\n\t\t\tnextloop\n\t\tfi\n\t\tif firstblock then\n\t\t\tlastblock:=block\n\t\t\tfirstblock:=0\n\t\t\tnextloop\n\t\tfi\n\t\tcase dir\n\t\twhen 'D' then\t\t\t!add below\n\t\t\tblock.posx:=lastblock.posx\n\t\t\tblock.posy:=lastblock.posy+lastblock.dimy+dy\n\t\twhen 'R' then\n\t\t\tblock.posx:=lastblock.posx+lastblock.dimx+dx\n\t\t\tblock.posy:=lastblock.posy\n\t\twhen 'U' then\t\t\t!add above\n\t\t\tblock.posx:=lastblock.posx\n\t\t\tblock.posy:=lastblock.posy-block.dimy-dy\n\t\twhen 'L' then\n\t\t\tblock.posx:=lastblock.posx-block.dimx-dx\n\t\t\tblock.posy:=lastblock.posy\n\t\tesac\n\t\tlastblock:=block\n\tod\nend\n\nproc showtestmenu(dim)=\n\twapplic:=gxcreatewindow(dim:dim,caption:\"test\")\n\n\tfor block in blocklist do\n\t\tgxbutton(pos:(block.posx,block.posy),dim:(block.dimx,block.dimy),caption:block.name,\n\t\towner:wapplic,style:[ss_border:bs_simplew])\n\tod\n\n\teventloop()\nend\n\nexport func smcreate(caption=\"\",?dim,?pos)=\n!create a pop-up menu window\n!dim ix (x,y) client area size in pixels\n!?pos is optional position, but can also existing button, then menu is placed nearby\n!Normally used after after series of smdefblock etc calls to setup a menu layout\n!Dim usually is a call to smmenusize which exactly contains the blocks\n!return handle to window\n\n\tif dim.isvoid then dim:=smmenusize() fi\n\n\tw:=gxcreatewindow(caption:caption, dim:dim, options:[wf_minmax:0],pos:pos)\n!\tw:=gxcreatewindow(caption:caption, dim:dim)\n\tw.windclass:=popup_class\n\tcurrpopup:=w\n\tsetforegroundwindow(w.gdi.hwnd)\n\n\tslposx:=chx\n\tslposy:=chy\n\tsldir:=(dim[1]>dim[2]|'H'|'V')\n\n\twpopup:=w\n\n\toldfocus:=wfocus\n\tif wfocus then\n\t\tgxkillfocus()\n\tfi\n\n\tpopuplist[++npopups]:=w\n\tfocuslist[npopups]:=oldfocus\t\t!of underlying window\n\n\treturn w\nend\n\nexport func smblock(block,border=0)=\n!set block as the current block for subsequent \n!unlike old versions of the library, an actual window is created for the block,\n!and a handle to that is returned. That is a child group control.\n\n\twblock:=gxpanel(pos:(block.posx,block.posy),dim:(block.dimx,block.dimy),\n\t\towner:currpopup, style:[ss_border:border])\n\tcurrblock:=block\n\tcurrgroup:=wblock\n\tcellx:=celly:=1\n\n\treturn wblock\nend\n\n!export func smpanel=\n!!set block as the current block for subsequent \n!!unlike old versions of the library, an actual window is created for the block,\n!!and a handle to that is returned. That is a child group control.\n!\n!\treturn gxpanel(pos:getsmpos(),dim:getsmdim(),\n!\t\towner:currgroup, style:[ss_border:border])\n!end\n!\nexport proc smclose=\n!NOTE: for nested menus, ie. invoking another popup menu while one is still\n!on the screen, requires:\n! * blocklist needs to be moved elsewhere, eg. to data field of current popup rwindow\n! * Then smclose can close blocks in that list, not the export one\n! * Global blocklist can be reused\n! * It might require that the owner window is disabled from being clicked on, but\n!   that will be awkward to do without disabling each control within it. Or perhaps\n!   this is a check that can be done within process_wmmessage, to see if click-window\n!   has an owner that has been disabled.\n!    Disabling is one with smcreate, and re-enableing here in smclose\n\n\tgxclose(wpopup)\n!\tfor block in blocklist do\n!\t\tblock:=0\n!!\t\tfreehandle(block)\n!\tod\n\n\toldfocus:=focuslist[npopups]\n\t--npopups\n\tif npopups then\n\t\twpopup:=popuplist[npopups]\n\t\tif oldfocus then\n\t\t\tgxfocus(oldfocus)\n\t\tfi\n\telse\n\t\twpopup:=nil\n\tfi\nend\n\n!export proc smoff=\n!\tsmclose()\n!end\n\nproc nextcell=\n!step cellx,y to next cell within current block\n\tif currblock.dir='V' then\n\t\t++celly\n\t\tif celly>currblock.cellsy then\n\t\t\tcelly:=1\n\t\t\t++cellx\n\t\tfi\n\telse\t\t\t\t\t!hoz\n\t\t++cellx\n\t\tif cellx>currblock.cellsx then\n\t\t\tcellx:=1\n\t\t\t++celly\n\t\tfi\n\tfi\nend\n\nfunc getsmpos=\n\treturn ((cellx-1)*currblock.pitchx+currblock.cellposx,\n        (celly-1)*currblock.pitchy+currblock.cellposy)\nend\n\nfunc getsmdim=\n\treturn (currblock.celldimx,currblock.celldimy)\nend\n\nfunc getslpos=\n\treturn (slposx,slposy)\nend\n\nfunc getsldim(s)=\n\tif s.isint then\n\t\treturn (s*chx+chx*2,chy+smy*2)\n\telse\n\t\treturn (gxtextwidth(labelfont,s)+smx*2,chy+smy*2)\n\tfi\nend\n\nproc nextslcell(dim)=\n\tif sldir='H' then\n\t\tslposx+:=dim[1]+chx\n\telse\n\t\tslposy+:=dim[2]+chy\n\tfi\nend\n\nexport func smcmd(caption,id=0,enable=1)=\n!create button within current block\n!caption can also be an integer code:\n! 0\t\tskip this cell (just leave a blank space)\n! -1\tinsert divider line\n!when id is omitted or is zero, then creates a static label instead\n\n\tif caption.isint then\n\t\tcase caption\n\t\twhen 0 then\n\t\twhen -1 then\n\t\tesac\n\t\tnextcell()\n\t\treturn nil\n\tfi\n\n\tif id=0 then\n\t\treturn smlabel(caption)\n\tfi\n\n\tss:=[ss_border:bs_ownpanel]\n\n\tw:=gxbutton(pos:getsmpos(), dim:getsmdim(), caption:caption, id:id,\n\t\towner:currgroup, style:ss, enable:enable)\n\tnextcell()\n\treturn w\nend\n\nexport func smhozscrollbar(id=0)=\n\tw:=gxhozscrollbar(owner:currgroup, pos:getsmpos(), dim:getsmdim(), id:id,\n\tstyle:[ss_border:bs_simplew])\n\n\tnextcell()\n\treturn w\nend\n\nexport func smvertscrollbar(id=0)=\n\tw:=gxvertscrollbar(owner:currgroup, pos:getsmpos(), dim:getsmdim(), id:id,\n\tstyle:[ss_border:bs_simplew])\n\n\tnextcell()\n\treturn w\nend\n\nexport func smlabel(caption)=\n\tpos:=getsmpos()\n\tdim:=(currblock.celldimx,currblock.celldimy)\n\n\tw:=gxlabel(pos:pos,dim:dim,caption:caption,owner:currgroup)\n\tnextcell()\n\treturn w\nend\n\nexport func smarrow(dir,id)=\n\tpos:=getsmpos()\n\tdim:=(currblock.celldimx,currblock.celldimy)\n\n\tw:=gxarrow(pos:pos,dim:dim,dir:dir,owner:currgroup)\n\tnextcell()\n\treturn w\nend\n\nexport func smtoggle(caption,linkvar,id=0,enable=1)=\n!create toggle control within current block\n\n\tw:=gxtoggle(pos:getsmpos(), dim:getsmdim(), caption:caption,\n\t\t\t\tlinkvar:linkvar,id:id,owner:currgroup, enable:enable,\n\t\t\t\tstyle:currblock.blockstyle)\n\n\tnextcell()\n\treturn w\nend\n\nexport func smselect(caption,linkvar,onvalue=1,id=0,enable=1)=\n!create toggle control within current block\n\n\tw:=gxselect(pos:getsmpos(), dim:getsmdim(), caption:caption,\n\t\t\tlinkvar:linkvar,onvalue:onvalue,\n\t\t\tid:id,owner:currgroup, enable:enable, style:currblock.blockstyle)\n\n\tnextcell()\n\treturn w\nend\n\nexport func smeditbox(?caption,linkvar,id=0,enable=1,?style)=\n!create toggle control within current block\n!CPL \"SMED\",CURRBLOCK\n\tpos:=getsmpos()\n\tdim:=getsmdim()\n\n!CPL =DIM\n\n\tif caption.isdef then\n\t\tgxlabel(pos:pos, dim:(currblock.labelwidth-chx,dim[2]), caption:caption,\n\t\t owner:currgroup)\n\t\tpos[1]+:=currblock.labelwidth\n\t\tdim[1]-:=currblock.labelwidth\n\tfi\n\n\tw:=gxeditbox(pos:pos, dim:dim,\n\t\tlinkvar:linkvar,\n\t\tid:id,owner:currgroup, enable:enable, style:getstyle(style))\n!\tgxdrawmode(w,dm_screenmemory)\n\n\tnextcell()\n\treturn w\nend\n\nexport func smlistbox(linkvar,id=0,enable=1)=\n\n!CPL =CURRBLOCK.CELLSY,\"(ROWS)\"\n!CPL =CURRBLOCK.PITCHY,\"(PITCH)\"\n!CPL =CURRBLOCK.CELLDIMY,\"(CELLDIMY)\"\n!CPL =CURRBLOCK.CELLPOSY,\"(OFFSET)\"\n!CPL =CURRBLOCK.GAPY,\"(GAPY)\"\n!CPL =CURRBLOCK.DIMY,\"(DIMY)\"\n!CPL \"LBDIMY=\",CURRBLOCK.DIMY-CURRBLOCK.MARGINY*2\n!CPL =CURRBLOCK.MARGINY\n\n!$SETDEBUG(1)\n\tw:=gxlistbox(pos:getsmpos(),\n\t\tdim:(currblock.dimx-currblock.marginx*2,currblock.dimy-currblock.marginy*2),\n\t\tlinkvar:linkvar,\n\t\tstyle:[ss_vscroll:1,\n\t\tss_border:bs_simplew],\n\t\trows:currblock.cellsy,\n\t\tpitch:currblock.pitchy,\n\t!\toffset:currblock.cellposy,\n\t\tid:id,owner:currgroup)\n!CPL \"SMLB2\"\n\treturn w\nend\n\nexport func sllabel(caption)=\n\tpos:=getslpos()\n\tdim:=getsldim(caption)\n\n\tw:=gxlabel(pos:pos,dim:dim,caption:caption,owner:currpopup)\n\tnextslcell(dim)\n\treturn w\nend\n\nexport func slcmd(caption,id=201,enable=1)=\n!create button within current block\n!caption can also be an integer code:\n! 0\t\tskip this cell (just leave a blank space)\n! -1\tinsert divider line\n!when id is omitted or is zero, then creates a static label instead\n\n\tpos:=getslpos()\n\tdim:=getsldim(caption)\n\tss:=[ss_border:bs_simplew]\n\n\tw:=gxbutton(pos:pos,dim:dim,caption:caption,id:id,owner:currpopup, \n\t\tstyle:ss)\n\tnextslcell(dim)\n\treturn w\nend\n\nexport func sleditbox(linkvar,width=30,id=0,enable=1)=\n\tpos:=getslpos()\n\tdim:=getsldim(width)\n\n\tw:=gxeditbox(pos:pos, dim:dim,\n\t\tlinkvar:linkvar,\n\t\tid:id,owner:currpopup)\n\n\tnextslcell(dim)\n\treturn w\nend\n\nexport func smok(caption=\"OK\",enable=1)=\n\treturn smcmd(caption,mm_ok,enable)\nend\n\nexport func smcancel(caption=\"Cancel\",enable=1)=\n\treturn smcmd(caption,mm_cancel,enable)\nend\n\nexport func slok(caption=\"OK\")=\n\treturn slcmd(caption,mm_ok)\nend\n\nexport func slcancel(caption=\"Cancel\")=\n\treturn slcmd(caption,mm_cancel)\nend\n\nexport proc smokcancel=\n\tsmok()\n\tsmcancel()\nend\n\nexport proc slinit(w)=\n\tcurrpopup:=w\n\tslposx:=chx\n\tslposy:=0\n\tsldir:=(w.dimx>w.dimy|'H'|'V')\nend\n\nexport proc settab(?a,?b,?c,?d,?e,?f,?g,?h,?i)=\n\tstatic var oldtabs\n\n\tif not a.defined then\n\t\tgxtabstops(oldtabs)\n\t\treturn\n\tfi\n\n\toldtabs:=gxtabstops()\n\tparams::=allparams()\n\n!\tgxtabstops(allparams())\n\tgxtabstops(param)\nend\n\nexport proc smupdatevalue(w)=\n\tgxupdate(w)\nend\n\nexport proc setfocus(w,?b)=\n\tgxfocus(w)\nend\n\nexport proc askmenu(a)=\n\tmessage:=gxaskmess(1)\n\tmessw:=currmess.wind\nend\n\nfunc readstylestr(s)=\n!read cell style string s, and return option dict\n\td:=new(dict)\n\tif s=\"\" then return d fi\n\n\ts:=convuc(s)\n\n\tforeach c in s do\n\t\tcase c\n\t\twhen 'X' then d{ss_marktype}:=check_mark\n\t\twhen 'M' then d{ss_marktype}:=radio_mark\n\t\twhen 'I' then d{ss_marktype}:=invert_mark\n\t\twhen 'R' then d{ss_returnmess}:=1\n\t\twhen 'N' then d{ss_noupdate}:=1\n\t\tesac\n\tod\n\treturn d\nend\n\nfunc getstyle(style)=\n\tif style.defined then\n\t\treturn readstylestr(style)\n\telse\n\t\treturn currblock.blockstyle\n\tfi\nend\n",
(u64)"\nexport type wt_word\t\t= u16\nexport type wt_bool\t\t= u32\nexport type wt_dword\t= u32\nexport type wt_wchar\t= u16\nexport type wt_char\t\t= byte\nexport type wt_ichar\t= stringz\nexport type wt_string\t= stringz\nexport type wt_ptr\t\t= ref byte\nexport type wt_wndproc\t= u64\n\nexport type wt_handle\t= ref void\nexport type wt_int\t\t= i32\nexport type wt_uint\t\t= u32\nexport type wt_long\t\t= i32\nexport type wt_wparam\t= u64\nexport type wt_lparam\t= u64\nexport type wt_size\t\t= u64\n\nexport type wt_wparam32\t= u32\nexport type wt_lparam32\t= u32\nexport type wt_handle32\t= u32\nexport type wt_ptr32\t= u32\nexport type wt_string32\t= u32\nexport type wt_wndproc32\t= u32\n\nexport type wt_wparam64\t= u64\nexport type wt_lparam64\t= u64\nexport type wt_handle64\t= u64\nexport type wt_ptr64\t= u64\nexport type wt_string64\t= u64\nexport type wt_wndproc64= u64\n\nexport type wt_result\t= u64\nexport type wt_intptr\t= u64\nexport type wt_coord\t= u32\n\nexport type ws_spoint= struct\n\ti16 x,y\nend\n\nexport type ws_srect=struct\n\ti16 leftx,top, rightx,bottom\nend\n\nexport type ws_charinfo=struct\n\tunion\n\t\twt_word\tunicodechar\n\t\twt_char\tasciichar\n\tend union\n\twt_word\t\tattributes\nend\n\nexport type ws_palette16=[0..15]i32\n\nexport type ws_console=struct\n\tws_spoint size,pos\n\twt_word attributes\n\tws_srect window\n\tws_spoint maxwindowsize\nend\n\nexport type ws_consoleex=struct\n\ti32 recsize\n\tws_spoint size,pos\n\twt_word attributes\n\tws_srect window\n\tws_spoint maxwindowsize\n\twt_word wpopup\n\ti32 fullscreen\n\tws_palette16 palette\nend\n\nexport type ws_keyevent = struct $caligned\n\twt_word\teventtype\n\t\twt_bool\tkeydown\n\t\twt_word\trepeatcount\n\t\twt_word\tvirtualkeycode\n\t\twt_word\tvirtualscancode\n\t\tunion\n\t\t\twt_word unicodechar\n\t\t\twt_char asciichar\n\t\tend\n\t\twt_dword controlkeystate\nend\n\nexport type ws_cursor=struct\n\ti32 size,visible\nend\n\nexport var hconsole, hconsolein\n\nexport const stdoutputhandle=0xffff_fff5\nexport const stdinputhandle=0xfffffff6\nexport const stderrorputhandle=0xfffffff4\nexport const invalidhandlevalue=0xffffffff\n\nexport const maxpathlen=260\n\ntype spath=stringz*maxpathlen\ntype sshort=stringz*14\n!\nexport type ws_filetime=struct\n\ti32 ftlow\n\ti32 fthigh\nend\n\nexport type ws_finddata=struct\n\ti32\t\tfileattributes\n\tws_filetime\tcreationtime\n\tws_filetime\tlastaccesstime\n\tws_filetime\tlastwritetime\n\ti32\t\tfilesizehigh\n\ti32\t\tfilesizelow\n\ti32\t\treserved0\n\ti32\t\treserved1\n\tspath\t\tfilename\n\tsshort\t\tshortfilename\nend\n\nexport type ws_systemtime = struct\n\tu16\tyear\n\tu16\tmonth\n\tu16\tdayofweek\n\tu16\tday\n\tu16\thour\n\tu16\tminute\n\tu16\tsecond\n\tu16\tmilliseconds\nend\n\nexport type ws_msg64 = struct $caligned\n\tref void\thwnd\n\ti32\t\tmessage\n\ti64\t\twparam\n\ti64\t\tlparam\n\ti32\t\ttime\n\ti32\t\tptx\n\ti32\t\tpty\nend\n\nexport type ws_point = struct\n\ti32 x, y\nend\n\nexport type ws_rect=struct\t\t!rect record occupying 16 bytes\n\tunion\n\t\tstruct\n\t\t\ti32 leftx,top, rightx,bottom\n\t\tend\n\t\tstruct\n\t\t\tunion i32 x,x1 end\n\t\t\tunion i32 y,y1 end\n\t\t\ti32 x2,y2\n\t\tend\n\tend\nend\n\nexport type ws_logbrush = struct\n\ti32 lbstyle\n\ti32 lbcolour\n\ti32 lbhatch\nend\n\nexport type ws_textmetrics = struct\n\ti32\theight\n\ti32\tascent\n\ti32\tdescent\n\ti32\ti32ernalleading\n\ti32\texternalleading\n\ti32\tavecharwidth\n\ti32\tmaxcharwidth\n\ti32\tweight\n\ti32\toverhang\n\ti32\tdigitizedaspectx\n\ti32\tdigitizedaspecty\n\tbyte\tfirstchar\n\tbyte\tlastchar\n\tbyte\tdefaultchar\n\tbyte\tbreakchar\n\tbyte\titalic\n\tbyte\tunderlined\n\tbyte\tstruckout\n\tbyte\tpitchandfamily\n\tbyte\tcharset\nend\n!=========================================\n\nexport type ws_bitmapv5header = struct\n\ti32\tsize\n\ti32\twidth\n\ti32\theight\n\tu16\tplanes\n\tu16\tbitcount\n\ti32\tcompression\n\ti32\tsizeimage\n\ti32\txpelspermeter\n\ti32\typelspermeter\n\ti32\tclrused\n\ti32\tclrimportant\n\ti32\tredmask\n\ti32\tgreenmask\n\ti32\tbluemask\n\ti32\talphamask\n\ti32\tcstype\n\t[1..9]i32 endpoints\n\ti32\tredgamma\n\ti32\tgreengamma\n\ti32\tbluegamma\n\ti32\tintent\n\ti32\tprofiledata\n\ti32\tprofilesize\n\ti32\treserved\nend\n\nexport type ws_bitmapfileheader = struct\n\twt_word\t\ttypex\n\twt_dword\tsize\n\twt_word\t\tres1, res2\n\twt_dword\toffbits\nend\n\nexport type ws_bitmapinfoheader = struct\n\twt_dword \tsize\n\twt_long\t\twidth\n\twt_long\t\theight\n\twt_word\t\tplanes\n\twt_word\t\tbitcount\n\twt_dword\tcompression\n\twt_dword\tsizeimage\n\twt_long\t\txpelspermetre\n\twt_long\t\typelspermetre\n\twt_dword\tclrused\n\twt_dword\tclrimportant\nend\n\nexport type ws_paintstruct = struct\n!\ti64\t\thdc\n\ti64\t\thdc\n\ti32\t\terase\n\tws_rect\t\tpaintrect\n\ti32\t\trestore\n\ti32\t\tincupdate\n\t[32]byte\trgbreserved\nend\n\n!32-BIT VERSION\nexport type ws_openfilename32 = struct\n\twt_dword\t\tstructsize\n\twt_handle32\t\towner\n\twt_handle32\t\tinstance\n\twt_string32\t\tfilter\n\twt_string32\t\tcustomfilter\n\twt_dword\t\tmaxcustfilter\n\twt_dword\t\tfilterindex\n\twt_string32\t\tfile\n\twt_dword\t\tmaxfile\n\twt_string32\t\tfiletitle\n\twt_dword\t\tmaxfiletitle\n\twt_string32\t\tinitialdir\n\twt_string32\t\ttitle\n\twt_dword\t\tflags\n\twt_word\t\t\tfileoffset\n\twt_word\t\t\tfileextension\n\twt_string32\t\tdefext\n\twt_lparam32\t\tcustdata\n\twt_wndproc32\thook\n\twt_string32\t\ttemplatename\n\twt_ptr32\t\treserved1\n\twt_dword\t\treserved2\n\twt_dword\t\tflagsex\nend\n\n!64-BIT VERSION\nexport type ws_openfilename64 = struct $caligned\n\twt_dword\t\tstructsize\n\twt_handle64\t\towner\n\twt_handle64\t\tinstance\n\twt_string64\t\tfilter\n\twt_string64\t\tcustomfilter\n\twt_dword\t\tmaxcustfilter\n\twt_dword\t\tfilterindex\n\twt_string64\t\tfile\n\twt_dword\t\tmaxfile\n\twt_string64\t\tfiletitle\n\twt_dword\t\tmaxfiletitle\n\twt_string64\t\tinitialdir\n\twt_string64\t\ttitle\n\twt_dword\t\tflags\n\twt_word\t\t\tfileoffset\n\twt_word\t\t\tfileextension\n\twt_string64\t\tdefext\n\twt_lparam64\t\tcustdata\n\twt_wndproc64\thook\n\twt_string64\t\ttemplatename\n\twt_ptr64\t\treserved1\n\twt_dword\t\treserved2\n\twt_dword\t\tflagsex\nend\n\nimportdll kernel32=\n\tfunc\t\"GetLastError\"\t\t\t\t\t:wt_dword\n\tfunc\t\"GetStdHandle\"\t\t\t\t\t(wt_dword)wt_handle\n\tfunc\t\"WriteConsoleA\" as writeconsole\t\t\t\t(wt_handle,wt_string,wt_dword,wt_ptr,wt_ptr)wt_bool\n\tfunc\t\"SetConsoleCursorPosition\"\t\t(wt_handle,wt_coord)wt_bool\n\tfunc\t\"GetConsoleScreenBufferInfo\"\t(wt_handle,wt_ptr)wt_bool\n\tfunc\t\"SetConsoleMode\"\t\t\t\t(wt_handle,wt_dword)wt_bool\n\tfunc\t\"WriteConsoleOutputA\" as writeconsoleoutput\t\t\t(wt_handle,wt_ptr,wt_coord,wt_coord,wt_ptr)wt_bool\n\n\tfunc\t\"GetConsoleScreenBufferInfoEx\"\t(wt_handle,wt_ptr)wt_bool\n\tfunc\t\"SetConsoleScreenBufferInfoEx\"\t(wt_handle,wt_ptr)wt_bool\n\tfunc\t\"GetConsoleWindow\"\t\t\t\t:wt_handle\n\n\tfunc\t\"SetConsoleTextAttribute\"\t\t(wt_handle,wt_word)wt_bool\n\tfunc\t\"SetConsoleTitleA\" as setconsoletitle\t\t\t\t(wt_string)wt_bool\n\tfunc\t\"ReadConsoleInputA\" as readconsoleinput\t\t\t(wt_handle,wt_ptr,wt_dword,wt_ptr)wt_bool\n\tfunc\t\"PeekConsoleInputA\"\t\t\t(wt_handle,wt_ptr,wt_dword,wt_ptr)wt_bool\n\tfunc\t\"FlushConsoleInputBuffer\"\t\t(wt_handle)wt_bool\n\tfunc\t\"SetConsoleWindowInfo\"\t\t\t(wt_handle,wt_bool,wt_ptr)wt_bool\n\tfunc\t\"SetConsoleScreenBufferSize\"\t(wt_handle,wt_coord)wt_bool\n\tfunc\t\"GetConsoleCursorInfo\"\t\t\t(wt_handle,wt_ptr)wt_bool\n\tfunc\t\"SetConsoleCursorInfo\"\t\t\t(wt_handle,wt_ptr)wt_bool\n\tfunc\t\"GetNumberOfConsoleInputEvents\"(wt_handle,wt_ptr)wt_bool\n\n\tfunc\t\"FindFirstFileA\" as findfirstfile\t\t(stringz,ref i32)i32\n\tfunc\t\"FindNextFileA\"  as findnextfile\t\t\t(i32,ref i32)i32\n\tfunc\t\"FindClose\"\t\t\t\t\t(i32)i32\n\tfunc\t\"SetCurrentDirectoryA\" as setcurrentdirectory\t(stringz)i32\n\tfunc\t\"GetCurrentDirectoryA\" as getcurrentdirectory\t(i32,i32)i32\n\tfunc\t\"CreateDirectoryA\" as createdirectory\t\t(stringz,i32)i32\n\tfunc\t\"GetFileAttributesA\"\t\t\t(stringz)i32\n\tfunc\t\"GetModuleHandleA\" as getmodulehandle\t\t(wt_string)wt_handle\n\tfunc\t\"GetTickCount\"\t\t\t\t\t\t\t\t:wt_dword\n\tfunc\t\"GlobalAlloc\"\t\t\t\t\t\t\t\t\t(wt_uint,wt_size)wt_handle\n\tfunc\t\"GlobalLock\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_ptr\n\tfunc\t\"GlobalUnlock\"\t\t\t\t\t\t\t\t(wt_handle)wt_bool\n\tfunc\t\"GlobalSize\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_size\n\n\tfunc\t\"GetSystemTime\"(ref byte)i32\n\tfunc\t\"Beep\"\t\t\t\t\t\t\t(wt_dword, wt_dword)wt_bool\n\tfunc\t\"SetConsoleCP\"\t\t\t\t\t\t\t\t(wt_uint)wt_bool\n\tfunc\t\"GetCommandLineA\" : stringz\nend\n\nimportdll user32=\n\tfunc\t\"CreateWindowExA\" as createwindowex\t\t(wt_dword, wt_string, wt_string, wt_dword, wt_int,wt_int,wt_int,wt_int,\n\t\t\t\t\t\t\t\t\t\t\t\t\t wt_handle, wt_handle, wt_handle, wt_ptr)wt_handle\n\n\tfunc \"GetMessageA\" as getmessage\t\t\t\t(wt_ptr, wt_handle, wt_uint, wt_uint)wt_bool\n\tfunc \"TranslateMessage\"\t\t\t\t\t\t\t(wt_ptr)wt_bool\n\tfunc \"DispatchMessageA\" as dispatchmessage\t\t(wt_ptr)wt_result\n\tfunc \"SetTimer\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_intptr,wt_uint,wt_ptr)wt_intptr\n\tfunc \"KillTimer\"\t\t\t\t\t\t\t\t(wt_handle,wt_intptr)wt_bool\n\tfunc \"SystemParametersInfoA\"\t\t\t\t\t(wt_uint,wt_uint,wt_ptr,wt_uint)wt_bool\n\tfunc \"GetSystemMetrics\"\t\t\t\t\t\t\t(wt_int)wt_int\n!\tfunc \"CreateMenu\"\t\t\t\t\t\t\t\t:int\n\tfunc \"AppendMenuA\" as appendmenu\t\t\t\t(wt_handle,wt_uint,wt_intptr,wt_string)wt_bool\n\tfunc \"GetDC\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_handle\n\tfunc \"ReleaseDC\"\t\t\t\t\t\t\t\t(wt_handle,wt_handle)wt_int\n\n\tfunc \"SendMessageA\" as sendmessage\t\t\t\t(wt_handle,wt_uint,wt_wparam,wt_lparam)wt_result\n\tfunc \"PostMessageA\" as postmessage\t\t\t\t(wt_handle,wt_uint,wt_wparam,wt_lparam)wt_bool\n\tfunc \"PeekMessageA\" as peekmessage\t\t\t\t(wt_ptr,wt_handle,wt_uint,wt_uint,wt_uint)wt_bool\n\tfunc \"BeginPaint\"\t\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_handle\n\tfunc \"EndPaint\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\tproc \"PostQuitMessage\"\t\t\t\t\t\t\t(wt_int)\n\tfunc \"LoadIconA\" as loadicon\t\t\t\t\t(wt_handle,wt_string)wt_handle\n\tfunc \"LoadCursorA\" as loadcursor\t\t\t\t(wt_handle,wt_string)wt_handle\n\tfunc \"SetCursor\"\t\t\t\t\t\t\t\t(wt_handle)wt_handle\n\tfunc \"DrawMenuBar\"\t\t\t\t\t\t\t\t(wt_handle)wt_bool\n\tfunc \"GetSystemMenu\"\t\t\t\t\t\t\t(wt_handle,wt_bool)wt_handle\n\tfunc \"CreateMenu\"\t\t\t\t\t\t\t\t:wt_handle\n\tfunc \"CreatePopupMenu\"\t\t\t\t\t\t\t:wt_handle\n\tfunc \"DestroyMenu\"\t\t\t\t\t\t\t\t(wt_handle)wt_bool\n\tfunc \"CheckMenuItem\"\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_uint)wt_dword\n\tfunc \"EnableMenuItem\"\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_uint)wt_bool\n\tfunc \"GetSubMenu\"\t\t\t\t\t\t\t\t(wt_handle,wt_int)wt_handle\n\tfunc \"GetMenuItemID\"\t\t\t\t\t\t\t(wt_handle,wt_int)wt_uint\n\tfunc \"GetMenuItemCount\"\t\t\t\t\t\t\t(wt_handle)wt_int\n\tfunc \"InsertMenuA\" as insertmenu\t\t\t\t(wt_handle,wt_uint,wt_uint,wt_intptr,wt_string)wt_bool\n\tfunc \"ModifyMenuA\" as modifymenu\t\t\t\t(wt_handle,wt_uint,wt_uint,wt_intptr,wt_string)wt_bool\n\tfunc \"RemoveMenu\"\t\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_uint)wt_bool\n\tfunc \"DeleteMenu\"\t\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_uint)wt_bool\n\n\tfunc \"DestroyWindow\"\t\t\t\t\t\t\t(wt_handle)wt_bool\n\tfunc \"InvalidateRect\"\t\t\t\t\t\t\t(wt_handle,wt_ptr,wt_bool)wt_bool\n\tfunc \"ValidateRect\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\tfunc \"ShowWindow\"\t\t\t\t\t\t\t\t(wt_handle,wt_int)wt_bool\n\tfunc \"GetClassLongA\" as getclassint\t\t\t(wt_handle,wt_int)wt_word\n\tfunc \"SetClassLongA\" as setclasslong\t\t\t(wt_handle,wt_int,wt_dword)wt_word\n\tfunc \"SetWindowTextA\" as setwindowtext\t\t\t(wt_handle,wt_string)wt_bool\n\tfunc \"GetWindowTextA\" as getwindowtext\t\t\t(wt_handle,wt_string,wt_int)wt_int\n\tfunc \"GetWindowTextLengthA\" as getwindowtextlength\t(wt_handle)wt_int\n\tfunc \"GetKeyState\"\t\t\t\t\t\t\t\t(wt_int)wt_word\n\n!\tfunc \"GetWindowLongPtrA\" as getwindowlongptr\t(wt_handle,wt_int)i64\n!\tfunc \"SetWindowLongPtrA\" as setwindowlongptr\t(wt_handle,wt_int,wt_int)i64\n\tfunc \"GetWindowLongA\" as getwindowlongptr\t\t(wt_handle,wt_int)i64\n\tfunc \"SetWindowLongA\" as setwindowlongptr\t\t(wt_handle,wt_int,i64)i64\n\n\tfunc \"GetClientRect\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\tfunc \"ClientToScreen\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\tfunc \"ScreenToClient\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\tfunc \"GetWindowRect\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\tfunc \"GetSysColor\" as getsyscolour\t\t\t\t(wt_int)wt_dword\n\tfunc \"GetScrollInfo\"\t\t\t\t\t\t\t(wt_handle,wt_int,wt_ptr)wt_bool\n\tfunc \"GetMenu\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_handle\n\tfunc \"SetMenu\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_handle)wt_ptr\n\tfunc \"TrackPopupMenu\"\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_int,wt_int,wt_int,wt_handle,wt_ptr)wt_bool\n\tfunc \"GetMenuState\"\t\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_uint)wt_uint\n\tfunc \"MessageBoxA\" \t\t\t\t\t\t\t\t(wt_handle a=nil,wt_string message, wt_string caption=\"Caption\", wt_uint b=0)wt_int\n\tfunc \"OpenClipboard\"\t\t\t\t\t\t\t(wt_handle)wt_bool\n\tfunc \"CloseClipboard\"\t\t\t\t\t\t\t:wt_bool\n\tfunc \"EmptyClipboard\"\t\t\t\t\t\t\t:wt_bool\n\tfunc \"GetClipboardData\"\t\t\t\t\t\t\t(wt_uint)wt_handle\n\tfunc \"SetClipboardData\"\t\t\t\t\t\t\t(wt_uint,wt_handle)wt_handle\n\tfunc \"MessageBeep\"\t\t\t\t\t\t\t\t(wt_uint x=0)wt_bool\n\tfunc \"SetActiveWindow\"\t\t\t\t\t\t\t(wt_handle)wt_handle\n\tfunc \"SetForegroundWindow\"\t\t\t\t\t\t(wt_handle)wt_bool\nend\n\nimportdll gdi32=\n\tfunc \"Rectangle\"\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int)wt_bool\n\tfunc \"RoundRect\"\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int)wt_bool\n\tfunc \"Ellipse\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int)wt_bool\n\tfunc \"Arc\"\t\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int)wt_bool\n\tfunc \"Chord\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int)wt_bool\n\tfunc \"Pie\"\t\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int)wt_bool\n\tfunc \"Polygon\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_handle,wt_int)wt_bool\n\tfunc \"TextOutA\" as textout\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_string,wt_int)wt_bool\n\tfunc \"TextOutW\" \t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_ptr,wt_int)wt_bool\n\tfunc \"GetStockObject\"\t\t\t\t\t\t\t(wt_int)wt_handle\n\tfunc \"SelectObject\"\t\t\t\t\t\t\t\t(wt_handle,wt_handle)wt_handle\n\tfunc \"CreateDCA\" as createdc\t\t\t\t\t(wt_string,wt_string,wt_string,wt_ptr)wt_handle\n\tfunc \"MoveToEx\"\t\t\t\t\t\t\t\t\t(wt_handle a,wt_int b,wt_int c,wt_ptr d=nil)wt_bool\n\tfunc \"CreatePen\"\t\t\t\t\t\t\t\t(wt_int,wt_int,wt_dword)wt_handle\n\tfunc \"CreateSolidBrush\"\t\t\t\t\t\t\t(wt_dword)wt_handle\n\tfunc \"CreateBrushIndirect\"\t\t\t\t\t\t(wt_ptr)wt_handle\n\tfunc \"LineTo\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int)wt_bool\n\tfunc \"GetPixel\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int)wt_dword\n\tfunc \"SetPixel\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_dword)wt_dword\n\tfunc \"SetGraphicsMode\"\t\t\t\t\t\t\t(wt_handle,wt_int)wt_int\n\tfunc \"CreateFontIndirectA\" as createfontindirect\t(wt_ptr)wt_handle\n\tfunc \"CreateFontA\" as createfont \\\n\t\t\t(wt_int height, wt_int width=0, wt_int escapement=0, wt_int orientation=0, wt_int bold=0,\n\t\t\t wt_dword italic=0, wt_dword underline=0, wt_dword strikeout=0, wt_dword charset=0,\n\t\t\t wt_dword outprec=0, wt_dword clipprec=0, wt_dword quality=0, wt_dword pitch=0, wt_string facename)wt_handle\n\tfunc \"SaveDC\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_int\n\tfunc \"GetTextMetricsA\" as gettextmetrics\t\t(wt_handle,wt_ptr)wt_bool\n\tfunc \"DeleteObject\"\t\t\t\t\t\t\t\t(wt_handle)wt_bool\n\tfunc \"RestoreDC\"\t\t\t\t\t\t\t\t(wt_handle,wt_int)wt_bool\n\tfunc \"GetTextExtentPoint32A\" as gettextextentpoint32\t(wt_handle,wt_string,wt_int,wt_ptr)wt_bool\n\tfunc \"GetObjectA\" as getobject\t\t\t\t\t(wt_handle,wt_int,wt_ptr)wt_int\n\tfunc \"CreatePalette\"\t\t\t\t\t\t\t(wt_ptr)wt_handle\n\tfunc \"GetWindowExtEx\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\tfunc \"CreateCompatibleBitmap\"\t\t\t\t\t(wt_handle,wt_int,wt_int)wt_handle\n\tfunc \"SetBitmapBits\"\t\t\t\t\t\t\t(wt_handle,wt_dword,wt_ptr)wt_long\n\tfunc \"SelectPalette\"\t\t\t\t\t\t\t(wt_handle,wt_handle,wt_bool)wt_handle\n\tfunc \"RealizePalette\"\t\t\t\t\t\t\t(wt_handle)wt_uint\n\tfunc \"SetDIBitsToDevice\"\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_dword,wt_dword,wt_int,wt_int,wt_uint,wt_uint,wt_ptr,wt_ptr,wt_uint)wt_int\n\tfunc \"StretchDIBits\"\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_ptr,wt_ptr,wt_uint,wt_dword)wt_int\n\tfunc \"SetStretchBltMode\"\t\t\t\t\t\t(wt_handle,wt_int)wt_int\n\tfunc \"PatBlt\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_dword)wt_bool\n\tfunc \"BitBlt\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_handle,wt_int,wt_int,wt_dword)wt_bool\n\tfunc \"SetROP2\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int)wt_int\n\tfunc \"CreateCompatibleDC\"\t\t\t\t\t\t(wt_handle)wt_handle\n\tfunc \"DeleteDC\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_bool\n\tfunc \"CreateBitmap\"\t\t\t\t\t\t\t\t(wt_int,wt_int,wt_uint,wt_uint,wt_ptr)wt_handle\n\tfunc \"CreateBitmapIndirect\"\t\t\t\t\t\t(wt_ptr)wt_handle\n\tfunc \"CreateDIBitmap\"\t\t\t\t\t\t\t(wt_handle,wt_ptr,wt_dword,wt_ptr,wt_ptr,wt_uint)wt_handle\n\tfunc \"CreateDIBSection\"\t\t\t\t\t\t\t(wt_handle,wt_ptr,wt_uint,wt_ptr,wt_handle,wt_dword)wt_handle\n\tfunc \"StretchBlt\"\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int, wt_int,wt_int,wt_handle, wt_int,wt_int,wt_int, wt_int,wt_dword)wt_bool\n\tfunc \"PlgBlt\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_ptr,wt_handle, wt_int,wt_int,wt_int,wt_int, wt_handle, wt_int,wt_int)wt_bool\n\tfunc \"SetTextColor\"  as settextcolour\t\t\t(wt_handle,wt_dword)wt_dword\n\tfunc \"SetTextAlign\"\t\t\t\t\t\t\t\t(wt_handle,wt_uint)wt_uint\n\tfunc \"SetTextJustification\"\t\t\t\t\t\t(wt_handle,wt_int,wt_int)wt_bool\n\tfunc \"SetBkColor\"  as setbkcolour\t\t\t\t(wt_handle,wt_dword)wt_dword\n\tfunc \"SetBkMode\"\t\t\t\t\t\t\t\t(wt_handle,wt_int)wt_int\n\tfunc \"GetBkColor\"  as getbkcolour\t\t\t\t(wt_handle)wt_dword\n\tfunc \"GetBkMode\"\t\t\t\t\t\t\t\t(wt_handle)wt_int\n\tfunc \"StartDocA\" as startdoc\t\t\t\t\t(wt_handle,wt_ptr)wt_int\n\tfunc \"StartPage\"\t\t\t\t\t\t\t\t(wt_handle)wt_int\n\tfunc \"EndPage\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_int\n\tfunc \"EndDoc\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_int\n\tfunc \"AbortDoc\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_int\n\tfunc \"GetViewportOrgEx\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\tfunc \"GetDIBits\"\t\t\t\t\t\t\t\t(wt_handle,wt_handle,wt_uint,wt_uint,wt_ptr,wt_ptr,wt_uint)wt_int\n\tfunc \"GetDIBColorTable\" as getdibcolourtable\t(wt_handle,wt_uint,wt_uint,wt_ptr)wt_uint\n\tfunc \"SetDIBColorTable\" as setdibcolourtable\t(wt_handle,wt_uint,wt_uint,wt_ptr)wt_uint\n\tfunc \"GetTextAlign\"\t\t\t\t\t\t\t\t(wt_handle)wt_uint\nend\n\nimportdll comdlg32=\n\tfunc \"GetOpenFileNameA\"\t\t\t\t\t\t\t(wt_ptr)wt_bool\n\tfunc \"GetSaveFileNameA\"\t\t\t\t\t\t\t(wt_ptr)wt_bool\nend\n",
(u64)"!MODULE winmessages\nmodule sysp\n\nmodule winconsts\nmodule winapi\nmodule wingxlib\nmodule gxmisc\n\nVAR GGDI\n\nexport var debug=0\n\nexport var messhandlertable=9000\t!message by windowclass table of message handlers\nexport var actionhandlertable\n\nexport var chx,chy\t\t!default text sizes for menus\nexport var cha,chd\t\t!ascender/descender heights\nexport const smx=3\t\t!margins around button text in pixels (both sides)\nexport const smy=4\nexport var arrowdim\nexport var markdim\nexport var buttonheight\nexport var listrowheight\nexport const labelfont=1\n\nexport var tabstops=(8,)*20\n\nexport var wmouse=nil\nexport var wfocus=nil\nexport var wprinter=nil\nexport var lastmousepos=nil\nexport var lastmousewindow=nil\nexport var currmousewindow=nil\n\nexport var mousepos\nexport var mousesw\nexport var quitmess=0\nexport var dragmode=0\nexport var lastbuttontime=0\n\nexport var buttonstate=0\nexport var wmessagetable\t\t!see initdata\nexport var buttontable\t\t!see initdata\n\nconst maxqueuesize=100\nexport var messagequeue=()\nexport var nmessages=()\n\nconst dragtol=1\n\nexport var copymode=4\n\nvar vktomesstable\n\n!Describe gx window (also bitmap, control or child window)\nexport record rwindow =\n\n\tvar windclass\t\t\t\t\t! type of window (popup, control, etc)\n\tvar flags\t\t\t\t\t\t! general purpose flags\n\tvar style\t\t\t\t\t\t! stylerec entry\n\tvar name\t\t\t\t\t\t! Optional debugging name\n\n\tvar owner\t\t\t\t\t\t! owner when this is a child window\n\tvar index\t\t\t\t\t\t! index 1..n when part of a list (eg. .childlist of owner)\n\tvar childlist\t\t\t\t\t! list of child windows\n\n!framepos/dim describe the overall window size including Windows or gx-drawn borders,\n\tvar frameposx, frameposy\t\t! top left of frame, in screen or owner window client coords\n\tvar framedimx, framedimy\t\t! pixels dims including frame and caption\n\n\tvar\tposx, posy\t\t\t\t\t! Pixel pos client area as seen by application\n\tvar\tdimx, dimy\t\t\t\t\t! Pixel dims of client area as seen by application\n\n\tvar gdi\t\t\t\t\t\t\t! (rgdistate)\tgdi state record\n\n\tvar enable\t\t\t\t\t\t! 1 to enable toggle/button/arrow etc, 0 to disable and show greyed out\n\tvar id\t\t\t\t\t\t\t! button/et al: command code associated with control\n\tvar text\t\t\t\t\t\t! caption or label or primary data\n!\t\tvar data \t@text\n\tvar linkvar\t\t\t\t\t\t! pointer to linked var for toggle/select/scroll\n\tvar gindex\t\t\t\t\t\t! window export index\n\n\tvar attrs\t\t\t\t\t\t! general purpose attributes, depends on window class\n\n!bitmap data\n\tvar pixelbits\t\t\t\t\t! 1, 4, 16, 24, 32 bits per pixel\n\tvar pixelptr\t\t\t\t\t! pointer to image data\n\tvar pixelbytes\t\t\t\t\t!bytes/pixel (round up to next whole byte)\n\tvar linebytes\t\t\t\t\t!bytes/per row, also pitch\n\tvar framebytes\n\tvar paltype\t\t\t\t\t\t!0, or palette type\n\n\tvar closed\nend\n\nexport enumdata paltypenames =\n\t(no_pal=0,\t\t$),\n\t(greyscale_pal,\t$),\n\t(tinted_pal,\t$),\n\t(colour_pal,\t$),\n\t(uv_pal,\t\t$),\nend\n\nexport type rgdistate = struct\n\tref void hwnd\t\t\t\t! win32 handle (hwnd)\n\tref void hdc\t\t\t\t! 0 or device context handle for hwnd\n\tref void hwnd2\t\t\t\t! secondary window/memory backup\n\tref void hdc2\t\t\t\t! 0 or hwnd3 DC screen or memory hdc\n\ti64 originalwndproc\t! win32 control handling proc\n\tunion\n\t\ti64 menuhandle\t\t! win32 handle to any menubar\n\t\ti64 oldbmobj\t\t\t!used for bitmaps\n\tend\n\ti32 drawmode\t\t\t! see dm- drawcodes\n\ti32 updated\t\t\t\t! 1 when pixels have changed\n\n\ti32 posx,posy\t\t\t!current drawing position\n\ti32 pencolour\t\t\t! current line colour (rgb)\n\ti32 penwidth\t\t\t! current line width\n\n\ti32 penstyle\t\t\t! current line dotted style\n\n\ti32 xormode\t\t\t\t! 0=normal, 1=xor\n\ti32 brushcolour\t\t\t! current brush colour\n\ti32 brushstyle\t\t\t! current brush style (bs_solid/etc)\n\ti32 brushpattern\t\t! current brush hatch/bitmap pattern\n\n\ti32 font\t\t\t\t! current font number\nend\n\nexport enumdata marktypenames =\n\t(no_mark=0,\t\t\t$),\n\t(radio_mark,\t\t$),\n\t(tick_mark,\t\t\t$),\n\t(check_mark,\t\t$),\n\t(invert_mark,\t\t$),\n\t(outline_mark,\t\t$),\n\t(bold_mark,\t\t\t$),\nend\n\nexport enumdata hilitetypenames =\n\t(no_hilite=0,\t\t$),\n\t(invert_hilite,\t\t$),\n\t(outline_hilite,\t$),\nend\n\nexport record togglerec=\t\t!for toggle and select\n\tvar textoffset\n\tvar onvalue\nend\n\nexport record scrollbarrec=\t\t!scroll bars\n\tvar limits\t\t\t\t\t\t!range\n\tvar span\t\t\t\t\t\t!portion of limits represented by visible data (0 means not relevant)\n\tvar thumbsize\t\t\t\t\t!pixel length of thumb (vert or hoz extent along scrollbar)\n\tvar thumbspan\t\t\t\t\t!pixels that the thumb can move\n\tvar thumbpos\t\t\t\t\t!current thumb position in pixels from start of scrollbar\n\tvar currpos\t\t\t\t\t\t!current position, will be in limits range\n\tvar dragmode\t\t\t\t\t!1 if thum currently being dragged\nend\n\nexport record editboxrec=\t\t!edit boxes\n!current char position within edit text\n!if text has N characters, then position will be 1..N+1\n!The position is just /before/ the stated character\n!This matches column position within the MED text editor\n\tvar currpos\t\t\t\t\t\t!cursor position, 1 to N+1 (N=chars in edit text)\n\tvar caretpos\t\t\t\t\t!current pixel position of any caret\n\tvar textpos\t\t\t\t\t\t!start x,y pixel position of text, set by gxjust_text\nend\n\nexport record listboxrec=\n\tvar rows\t\t\t\t\t\t!number of displayed rows\n\tvar pagepos\t\t\t\t\t\t!data position corresponding to row 1 of display\n\tvar length\t\t\t\t\t\t!all data items, same as linkvar^.len\n\tvar currpos\t\t\t\t\t\t!cursor position within the data, 1 to N (can be 0 when N=0)\n\tvar pitch, offset\t\t\t\t!pixel dims of each row\nend\n\nexport record rmessage=\n\tvar\t\twind\t\t!main window/button associated with message\n\tvar\t\tmenuwind\t!top-level window owning button\n\tvar\t\tmessage\t\t!message number\n\tvar\t\tstate\t\t!button/shift key state at time of message\n\tvar\t\ta,b\t\t\t!general purpose data, depends on message\n\tvar\t\tx,y\t\t\t!current mouse position\nend\n\n!contains many different flags and style codes for assorted controls\n!But at one mostly byte each, is very low overhead (32 values is same as two vars)\n\nexport type stylerec = struct\n\tbyte\tborder\t\t\t\t!bs_ code\n\tbyte\tjustify\t\t\t\t!'L', 'R', 'C'\n\tbyte\tvjustify\t\t\t!'T', 'B', 'M'\n\tbyte\twindbgnd\t\t\t!colour index for window background\n\tbyte\ttextfgnd\t\t\t!colour index\n\tbyte\ttextbgnd\t\t\t!\n\tbyte\tbgndmode\t\t\t!\n\tbyte\ttextfont\t\t\t!font index\n\tbyte\ttextsize\t\t\t!pixel size\n\tbyte\ttextbold\t\t\t!1 if bold\n\tbyte\ttextitalic\t\t\t!1 if italic\n\tbyte\tispassword\t\t\t!1 when edit field is a password\n\tbyte\tfieldwidth\t\t\t!edit field maximum char width\n\tbyte\tdir\t\t\t\t\t!'L','R','U','D'\n\tbyte\tmarktype\t\t\t!xxx_mark style, or:\n\tbyte\thilitetype\t\t\t!xxx_hilite style\n\tbyte\tiframe\t\t\t\t!1: pos/dim include frame\n\tbyte\timark\t\t\t\t!1: pos/dim include mark for toggle/select\n\tbyte\thscroll\t\t\t\t!1: include windows-drawn hoz scroll bar\n\tbyte\tvscroll\t\t\t\t!1: include windows-drawn vert scroll bar\n\tbyte\tlbchange\t\t\t!1: return mm_change on list boxes when row has changed\n\tbyte\treturnmess\t\t\t!1: return id code when clicking toggle/select/editbox\n\tbyte\tnoupdate\t\t\t!1: don't change or allow editing on toggle/select/editbox\nend\n\nexport record rpoint = var x,y end\nexport record rrect  =\n\tvar pos,dim\nend\n\nexport record rframe =\n\tvar x1,y1,x2,y2\nend\n\nexport record getrec=\n\tfun getbounds(&self)= 0\n\tfun getitem(&self,n)= 0\n\tfun getstritem(&self,n)= \"\"\nend\n\nexport enumdata stylenames =\t! (default)\n\t(ss_border,\t\t\t$),\t\t! Border style (wbs_simple)\n\t(ss_justify,\t\t$),\t\t! 'L' 'C' 'R'\tHorizontal text justify ('L')\n\t(ss_vjustify,\t\t$),\t\t! 'T' 'M' 'B'\tVertical text justify ('M' for buttons)\n\t(ss_textfgnd,\t\t$),\t\t! Text colour index (black)\n\t(ss_textbgnd,\t\t$),\t\t! Text background colour index (if opaque mode) (0)\n\t(ss_bgndmode,\t\t$),\t\t! 0\n\t(ss_textfont,\t\t$),\t\t! Text font number (1)\n\t(ss_textsize,\t\t$),\t\t! (0)\n\t(ss_textbold,\t\t$),\t\t! (0)\n\t(ss_textitalic,\t\t$),\t\t! (0)\n\t(ss_ispassword,\t\t$),\t\t! (0)\n\t(ss_marktype,\t\t$),\t\t! Toggle/select mark style (radio_mark)\n\t(ss_hilitetype,\t\t$),\t\t! Toggle/select hilite style (no_hilite)\n\t(ss_iframe,\t\t\t$),\t\t! Whether pos and dim include frame width (also caption bar/menu for windows)\n\t(ss_windbgnd,\t\t$),\t\t! Background colour of window or button (ltgrey)\n\t(ss_imark,\t\t\t$),\t\t! Background colour of window or button (ltgrey)\n\t(ss_hscroll,\t\t$),\t\t! (0)\n\t(ss_vscroll,\t\t$),\t\t! (0)\n\t(ss_lbchange,\t\t$),\t\t! (0)\n\t(ss_returnmess,\t\t$),\t\t! (0) Toggle/select/editbox, return id when clicked\n\t(ss_noupdate,\t\t$),\t\t! (0) Toggle/select/editbox, don't change or allow edit\nend\n\nexport enumdata drawmodenames =\n\t\t\t\t\t\t\t\t!HDC\tHDC2\tRestore\n\t(dm_screen=0,\t\t$),\t\t!screen\t--\t\tCustom routine\tDraw directly to screen; no mem backup\n\t(dm_memory,\t\t\t$),\t\t!memory\t--\t\tNA\t\t\t\tDraw to memory only; no screen hdc (eg. bitmap)\n\t(dm_screenmemory,\t$),\t\t!screen\tmemory\tBlit mem->scr\tDraw to both screen and memory at same time\n\t(dm_memoryscreen,\t$),\t\t!memory\tscreen\tBlit mem->scr\tDraw to memory; update screen periodically\nend\n\n!var windowlist=nil\n\nexport enumdata wfnames =\n\t(wa_rightclick=0,\t$),\t\t!allow right click\n\t(wa_middleclick,\t$),\t\t!allow middle click\n\t(wa_leftdbl,\t\t$),\t\t!allow left double click\n\t(wa_rightdbl,\t\t$),\t\t!allow right double click\n\t(wa_middledbl,\t\t$),\t\t!allow middle double click\n\t(wa_leftdrag,\t\t$),\t\t!allow left drag\n\t(wa_rightdrag,\t\t$),\t\t!etc\n\t(wa_middledrag,\t\t$),\n\t(wa_autoupdate,\t\t$),\t\t!auto update screen for toggles/etc\n\t(wa_tab,\t\t\t$), \t!allow tab to switch to next button which has watab\n\t(wa_strvar,\t\t\t$), \t!1 for listbox linkvar to use string not index\n\t(wa_retmess,\t\t$), \t!1 for button to return .value as mess not qmcommand\n\t(wa_retsel,\t\t\t$), \t!1 for button to return .value as mess not qmcommand\n\t(wa_memory,\t\t\t$), \t!1 when hdc/hdcmem have been switched, hdc points to memory dev\n\t(wa_maximised,\t\t$),\t\t!1 when maximised, 0 when normal/minimised\n\t(wa_param1,\t\t\t$), \t!general purpose control-specific flags\n\t(wa_param2,\t\t\t$), \n\t(wa_useenter,\t\t$),\n\t(wa_closed,\t\t\t$),\t\t!whether window has been closed\n\n\t(wa_$last,\t\t\t$)\nend\n\nconst wa_needdbl\t= wa_param1\t!1 requires double-click on listbox to return wmcommand\nconst wa_editdd\t\t= wa_param2\t!1 means editable dropdown box\n\n!GX border styles, used for child windows.\n!some child windows\nexport enumdata bsnames, bscat, bswidths=\n\t(bs_none=0,\t\t$,\t0,\tws_rect(0,0,0,0)),\t\t\t!no border\n!\t(bs_windows,\t$,\t'W',\tws_rect(0,0,0,0)),\t\t\t!windows-drawn, but no own-drawn border\n\t(bs_simplew,\t$,\t'W',\tws_rect(1,1,1,1)),\t\t\t!single 1-pixel black line, windows drawn\n\t(bs_simple,\t\t$,\t'X',\tws_rect(1,1,1,1)),\t\t\t!single 1-pixel black line\n\t(bs_thick,\t\t$,\t'X',\tws_rect(2,2,2,2)),\t\t\t!2-pixel border\n\t(bs_panel,\t\t$,\t'X',\tws_rect(1,1,1,1)),\t\t\t!raised panel, 1-pixel\n\t(bs_inset,\t\t$,\t'X',\tws_rect(1,1,1,1)),\t\t\t!inset panel, 1-pixel\n\t(bs_ownsimple,\t$,\t'I',\tws_rect(0,0,0,0)),\t\t\t!included inset panel, 1-pixel (drawn as part of client area)\n\t(bs_ownpanel,\t$,\t'I',\tws_rect(0,0,0,0)),\t\t\t!included inset panel, 1-pixel (drawn as part of client area)\n\t(bs_owninset,\t$,\t'I',\tws_rect(0,0,0,0)),\t\t\t!included inset panel, 1-pixel\n\t(bs_testext,\t$,\t'X',\tws_rect(10,10,10,10)),\n\t(bs_testint,\t$,\t'I',\tws_rect(8,8,8,8)),\n\t(bs_dummy,\t\t$,\t0,\tws_rect(0,0,0,0))\nend\n\nexport enumdata windowclassnames, defaultborderstyles =\n\t(no_class=0,\t\t$,\tbs_none),\t\t\t!Unassigned\n\t(window_class,\t\t$,\twbs_resize),\t\t!Main window\n\t(memwindow_class,\t$,\twbs_none),\t\t\t!memory backup to any window\n\t(popup_class,\t\t$,\twbs_thick),\t\t\t!Pop-up window (forms a stack)\n\t(float_class,\t\t$,\tbs_thick),\t\t\t!Independent window\n\t(bitmap_class,\t\t$,\tbs_none),\t\t\t!(image handling)\n\t(screen_class,\t\t$,\tbs_none),\t\t\t!Describes the desktop screen (not owned by my app)\n\t(printer_class,\t\t$,\tbs_none),\t\t\t!Used for printing\n\n\t(group_class,\t\t$,\tbs_inset),\t\t\t!Used mainly for grouping other buttons (eg. for Smdefblock)\n\t(panel_class,\t\t$,\tbs_inset),\t\t\t!General purpose panel for drawing in etc\n!\t(button_class,\t\t$,\tbs_panel),\t\t\t!Click button\n\t(button_class,\t\t$,\tbs_simplew),\t\t!Click button\n\t(toggle_class,\t\t$,\tbs_none),\t\t\t!Toggle button (can be composite, eg mark and label)\n\t(select_class,\t\t$,\tbs_none),\t\t\t!Select from several choices\n\t(editbox_class,\t\t$,\tbs_simplew),\t\t!Single-line edit control\n\t(scrollbar_class,\t$,\tbs_simplew),\t\t!Hoz or vert scroll bar (Some windows can also have Windows-drawn scroll bars)\n\t(listbox_class,\t\t$,\tbs_simplew),\t\t!List of options (scrollable usually)\n\t(dropdown_class,\t$,\tbs_none),\t\t\t!Button revealing attached listbox when clicked\n\t(framebar_class,\t$,\tbs_panel),\t\t\t!Left or right full-height panel used for toolboxes etc\n\t(statusbar_class,\t$,\tbs_panel),\t\t\t!Top or bottom full-width panel used for scrollbars\n\t(tooltip_class,\t\t$,\tbs_simplew),\t\t!Tooltops displayed when hovering over enabled buttons\n\t(arrow_class,\t\t$,\tbs_ownpanel),\t\t!Click button normally displaying an error in one of 4 orientations\n\t(mark_class,\t\t$,\tbs_none),\t\t\t!Toggle or select mark\n\t(label_class,\t\t$,\tbs_none),\t\t\t!Contains unclickable text usually\n\t(dummy_class,\t\t$,\tbs_none)\nend\n\nexport enumdata actionnames=\n\t(draw_w,\t\t$),\n\t(update_w,\t\t$),\n\t(last_w,\t\t$),\nend\n\n!MM Message Numbers\n\nexport enumdata messagenames=\n\n!all messages have x,y coord relative to top most window or child window\n!\n\t(mm_null=0,\t\t\t$),\t\t! empty message\n\n!window messages\n\t(mm_activate,\t\t$),\t\t! (w,a) a=1/0 activate/deactivate window\n\t(mm_close,\t\t\t$),\t\t! (w) close window (X button clicked)\n\t(mm_sizewindow,\t\t$),\t\t! (w...) resize window\n\t(mm_movewindow,\t\t$),\t\t! (w...) move window\n\t(mm_restore,\t\t$),\t\t! (w...) repaint window\n\n!cursor/focus messages\n\t(mm_setcursor,\t\t$),\t\t! (w...) update cursor type\n\t(mm_setfocus,\t\t$),\t\t! (w...) set focus to w\n\t(mm_killfocus,\t\t$),\t\t! (w...) lose focus from w\n\n!basic mouse messages (click messages can be promoted to other messages eg mm_command)\n\t(mm_move,\t\t\t$),\t\t! (w,x,y,b) mouse move, btns up/down (also drag messages when down)\n\t(mm_click,\t\t\t$),\t\t! (w,x,y) left btn click, can be promoted to mm_command etc depending on context\n\t(mm_dblclick,\t\t$),\t\t! (w,x,y) left btn dbl click, usu promoted\n\t(mm_clickup,\t\t$),\t\t! (w,x,y) left btn released\n\t(mm_rclick,\t\t\t$),\t\t! (w,x,y) right click in window, these usu. promoted\n\t(mm_rdblclick,\t\t$),\t\t! (w,x,y) right double click\n\t(mm_rclickup,\t\t$),\t\t! (w,x,y) right button released\n\t(mm_mclick,\t\t\t$),\t\t! (w,x,y) middle button versions of above\n\t(mm_mdblclick,\t\t$),\t\t! (w,x,y)\n\t(mm_mclickup,\t\t$),\t\t! (w,x,y)\n\t(mm_hover,\t\t\t$),\t\t! (w,x,y) paused over button\n\n\t(mm_onwindow,\t\t$),\t\t! (w,x,y) newly over a window\n\t(mm_offwindow,\t\t$),\t\t! (w,x,y) just came off window\n\t(mm_draw,\t\t\t$),\t\t! (w,x,y) redraw window\n\t(mm_update,\t\t\t$),\t\t! (w,x,y) update window (change of pos etc)\n\n!drag messages\n\t(mm_startdrag,\t\t$),\t\t! (w) start mouse movement with some btns down\n\t(mm_rstartdrag,\t\t$),\t\t! (w)\n\t(mm_mstartdrag,\t\t$),\t\t! (w)\n\t(mm_drag,\t\t\t$),\t\t! (w,x,y) moving mouse with buttons down (also qmmove sent)\n\t(mm_enddrag,\t\t$),\t\t! (w,x,y) all buttons up after drag\n\n!left command\n\t(mm_command,\t\t$),\t\t! (w,id) button clicked, id and sub-event given\n\t(mm_dblcommand,\t\t$),\t\t! (w,id) button double clicked\n\n!right command\n\t(mm_rcommand,\t\t$),\t\t! (w,id) right click button\n\t(mm_rdblcommand,\t$),\t\t! (w,id) right double click button\n\n!middle command\n\t(mm_mcommand,\t\t$),\t\t! (w,id)\n\t(mm_mdblcommand,\t$),\t\t! (w,id)\n\n!general key messages\n\t(mm_char,\t\t\t$),\t\t! (w,ch)\n\t(mm_key,\t\t\t$),\t\t! (w,k,shift)\n\t(mm_keyup,\t\t\t$),\t\t! (w,k,shift)\n\n!scroll/select/wheel messages\n\t(mm_sethozpos,\t\t$),\t\t! (w,pos)\t\tNew logical position set by hoz scrollbar\n\t(mm_setvertpos,\t\t$),\t\t! (w,pos)\t\tfrom vertical scrollbar\n\t(mm_select,\t\t\t$),\t\t! (w,n)\t\t\tSet nth item as current/highlighted/selected item\n\t(mm_pick,\t\t\t$),\t\t! (w,n)\t\t\tPick and return item n\n\t(mm_wheel,\t\t\t$),\t\t! (w,delta)\t\tMove log pos etc but depends on context\n\t(mm_lbchange,\t\t$),\t\t! (w,n)\t\t\tA listbox position has changed\n\n!misc messages\n\t(mm_timer,\t\t\t$),\t\t! (w)\n\n!high level window messages\n\t(mm_cancel,\t\t\t$),\t\t! (w)\n\t(mm_ok,\t\t\t\t$),\t\t! (w)\n\t(mm_help,\t\t\t$),\t\t! (w,id)\n\t(mm_cmdline,\t\t$),\t\t! (w,s)\n\n!specific key messages\n\t(mm_leftkey ,\t\t$),\t\t! (w,shift)\n\t(mm_rightkey,\t\t$),\t\t! (w,shift)\n\t(mm_upkey,\t\t\t$),\t\t! (w,shift)\n\t(mm_downkey,\t\t$),\t\t! (w,shift)\n\t(mm_pageupkey,\t\t$),\t\t! (w,shift)\n\t(mm_pagedownkey,\t$),\t\t! (w,shift)\n\t(mm_homekey,\t\t$),\t\t! (w,shift)\n\t(mm_endkey,\t\t\t$),\t\t! (w,shift)\n\t(mm_tabkey,\t\t\t$),\t\t! (w,shift)\n\t(mm_bskey,\t\t\t$),\t\t! (w,shift)\n\t(mm_deletekey,\t\t$),\t\t! (w,shift)\n\t(mm_enterkey,\t\t$),\t\t! (w,shift)\n\t(mm_insertkey,\t\t$),\t\t! (w,shift)\n\t(mm_functionkey,\t$),\t\t! (w,shift)\n\n!Other messages for controls, mainly for attached arrow buttons\n\t(mm_up,\t\t\t\t$),\t\t! (w,id) Arrow up/etc\n\t(mm_down,\t\t\t$),\t\t! (w,id)\n\t(mm_right,\t\t\t$),\t\t! (w,id)\n\t(mm_left,\t\t\t$),\t\t! (w,id)\n\t(mm_edit,\t\t\t$),\t\t! (w,id)\tUpdate of edit box\n\t(mm_edited,\t\t\t$),\t\t! (w,id)\tFinished edit box entry (tab etc)\n\t(mm_last,\t\t\t$)\nend\n\n!export const mm_scroll\t= mm_hscroll\t!general scroll independent of orientation\n\n!!other messages wmuser+ are user assigned, usually applied as\n!ids to controls. Depending on the options to Waitmess(), a wm_commmand message\n!is coverted to a direct message number. So (wm_command, 230) is covered to\n!message 230. So message ids have to start from 200 so that they occupy a different\n!number space from normal message codes.\nexport const mm_user\t= 200\n\nexport const kb_lbutton\t= 0x1\t!used in buttonstate\nexport const kb_rbutton\t= 0x2\nexport const kb_mbutton\t= 0x4\n\nexport const kb_shift\t= 0x8\t!used in shiftstate\nexport const kb_ctrl\t= 0x10\nexport const kb_alt\t\t= 0x20\nexport const kb_capslock\t= 0x40\nexport const kb_dblclick\t= 0x80\t!used for some messages that don't have dblclick versions,\n\nexport const kb_rshift\t= 0x100\nexport const kb_rctrl\t= 0x200\nexport const kb_ralt\t= 0x400\n\nexport enumdata colournames, colourvalues =\n!\t\t\t\t\t   BB'GG'RR\n\t(black,\t\t$,\t0x_00'00'00),\n\t(red,\t\t$,\t0x_00'00'C0),\n\t(dkred,\t\t$,\t0x_00'00'90),\n\t(red3,\t\t$,\t0x_00'00'70),\n\t(green,\t\t$,\t0x_00'C0'00),\n\t(dkgreen,\t$,\t0x_00'90'00),\n\t(green3,\t$,\t0x_00'70'00),\n\t\n\t(blue,\t\t$,\t0x_C0'00'00),\n\t(dkblue,\t$,\t0x_90'00'00),\n\t(blue3,\t\t$,\t0x_70'00'00),\n\n\t(cyan,\t\t$,\t0x_c0'c0'00),\n\t(dkcyan,\t$,\t0x_90'90'00),\n\t(cyan3,\t\t$,\t0x_70'70'00),\n\n\t(magenta,\t$,\t0x_c0'00'c0),\n\t(dkmagenta,\t$,\t0x_90'00'90),\n\t(magenta3,\t$,\t0x_70'00'70),\n\n\t(yellow,\t$,\t0x_00'C0'C0),\n\t(dkyellow,\t$,\t0x_00'90'90),\n\t(yellow3,\t$,\t0x_00'70'70),\n\t(yellow4,\t$,\t0x_00'50'50),\n\n\t(white,\t\t$,\t0x_FF'FF'FF),\n\t(ltgrey,\t$,\t0x_C0'C0'C0),\n\t(grey,\t\t$,\t0x_90'90'90),\n\t(dkgrey,\t$,\t0x_70'70'70),\n\n\t(ltorange,\t$,\t0x_00'A0'FF),\n\t(orange,\t$,\t0x_00'60'FF),\n\t(flesh,\t\t$,\t0x_70'85'EE),\n\t(pink,\t\t$,\t0x_9A'32'DB),\n\t(dkpink,\t$,\t0x_72'24'A9),\n\t(brown,\t\t$,\t0x_46'43'7D),\n\t(blue4,\t\t$,\t0x_B7'1C'5E),\n\t(blue5,\t\t$,\t0x_6F'3D'0D),\n\t(olive,\t\t$,\t0x_05'A0'88),\n\t(ltbrown,\t$,\t0x_00'70'B0),\n\n\t(blue6,\t\t$,\t0x_9C'63'1C),\n\t(green4,\t$,\t0x_12'51'11),\n\t(purple,\t$,\t0x_5E'0D'73),\n\t(blue7,\t\t$,\t0x_E6'27'1C),\n\t(crimson,\t$,\t0x_15'2A'D3),\n\t(violet,\t$,\t0x_54'16'A0),\n\t(blue8,\t\t$,\t0x_86'68'1E),\n\t(dkorange,\t$,\t0x_25'6A'D4),\n\t(green5,\t$,\t0x_09'46'41),\n\t(blue9,\t\t$,\t0x_65'0A'1D),\n\n\t(ltred,\t\t$,\t0x_00'00'FF),\n\t(ltgreen,\t$,\t0x_00'FF'00),\n\t(ltblue,\t$,\t0x_FF'00'00),\n\t(ltcyan,\t$,\t0x_FF'FF'00),\n\t(ltmagenta,\t$,\t0x_FF'00'FF),\n\t(ltyellow,\t$,\t0x_00'FF'FF),\n\n!The following are the Windows system colours, set up as indices\n!Init needs need to retrieve the values and set up the rgb values in this table\n\t(button_col,\t$,\t0),\t\t!button colour\n\t(window_col,\t$,\t0),\t\t!window colour\n\t(text_col,\t\t$,\t0),\t\t!text in windows\nend\n\nexport const skipmess = 1\t\t!message has been processed; caller must wait for another message\nexport const thismess = 0\t\t!caller should deal with this message (it has not been processed, or has been but caller can process it too)\n\nexport var bmbgnd\nexport var defstyle\t\t\t!set initdata\nexport var currmess=nil\n\nexport var wapplic=nil\nexport var wscreen=nil\n\nvar data,ndata\nvar tabstack,ntab\nvar breakflag\n\nconst k_menu=30000\nconst kdivide=30001\nconst kcolumn=30002\nconst kfilehistory=30003\n\nvar caretdrawn=0\nvar dkcolour=0x000000\nvar ltcolour=0xFFFFFF\nvar thumbdragmode=0\nvar thumbstartpos=0\n\nvar dirtomess=['L':mm_left,'R':mm_right,'U':mm_up,'D':mm_down]\n\nproc start=\n!CPL \"GXLIB START\"\n\n\tinitdata()\n\tmxinit()\n\tinitmenuhandlers()\nend\n\nexport proc setupgdi(w,hwnd)=\t\t\t!SETUPGDI\n!NOTE: rare care of a func within a data header. This is to allow bitmap module\n!to be higher up the hierarchy than gx, but still let it use some gx functions.\n\n!set up the default gdi descriptor for window w\n\n\tif w.gdi then\n\t\treturn\t\t\t!assume already done\n\tfi\n\n\tgdi:=new(rgdistate)\n\tgdi.hwnd:=hwnd\n\n!start with default drawmodes of dm_screen, or dm_memory for bitmaps\n!These can be converted later using gxdrawmode\n\n\tif w.type=rwindow then\n\t\tgdi.hdc:=getdc(hwnd)\n\t\tgdi.drawmode:=dm_screen\n\telse\t\t\t\t\t\t!assume bitmap\n\t\tgdi.hdc:=createcompatibledc(nil)\n\t\tgdi.drawmode:=dm_memory\n\tfi\n\n\tgdi.posx:=gdi.posy:=0\n\tgdi.updated:=0\n\tgdi.font:=0\n\tgdi.pencolour:=getsyscolour(colour_windowtext)\n\tgdi.penwidth:=0\n\tgdi.penstyle:=ps_solid\n\tgdi.xormode:=0\n\tgdi.brushcolour:=0xff'ff'ff\n\tgdi.brushstyle:=bs_solid\n\tgdi.brushpattern:=0\n\tw.gdi:=gdi\n\tend\n\nexport const arleft = \"<\"\nexport const arright = \">\"\nexport const arup = \"^\"\nexport const ardown = \"V\"\n\nexport var allwindows::=()\t\t\t!list of all windows and controls\n\nexport func ctrlpressed = return (currmess.state iand kb_ctrl) end\nexport func shiftpressed = return (currmess.state iand kb_shift) end\n\nproc initdata=\n\tmessagequeue:=new(list,100)\n\tnmessages:=0\n\n\tcolourvalues::=colourvalues\n\n\tcolourvalues[button_col]:=getsyscolour(colour_btnface)\n\n\tcolourvalues[window_col]:=getsyscolour(colour_window)\n\tcolourvalues[text_col]:=getsyscolour(colour_windowtext)\n\n\tdefstyle:=new(stylerec)\n\tdefstyle.border\t\t:= bs_simplew\n\tdefstyle.justify\t:= 'L'\n\tdefstyle.vjustify\t:= 'M'\n\tdefstyle.textfgnd\t:= black\n\tdefstyle.marktype\t:= check_mark\n\tdefstyle.hilitetype\t:= no_hilite\n\tdefstyle.windbgnd\t:= button_col\n\tdefstyle.imark\t\t:= 1\n!defstyle.windbgnd\t:= window_col\n\n\tinit_handlertables()\n\td:=gxchardim(labelfont)\n\tchx:=d.x\n\tchy:=d.y\n\n\td:=gxchardim(0,1)\n\tcha:=d.x\n\tchd:=d.y\n\tarrowdim:=chy+2\n\tmarkdim:=arrowdim-2\n\n\tbuttonheight:=chy+smy*2\n\tlistrowheight:=chy+smy*2\nend\n\nexport func gxcreatewindow(?caption,?pos,?dim,?options,owner=nil)=\t\t!CREATEWINDOW\n\t#create a popup window which is not a child window.\n\t#(nevertheless, it can have an owner window, such as the main window of the\n\t#application)\n\t#returns an rwindow handle\n\t#caption\toptional caption txt\n\t#pos\t\t(x,y) is pixel pos of top left corner in screen coordinates (of frame?)\n\t#\t\t\"cent\" to place centrally\n\t#\t\tomitted: use default placement\n\t#dim\t\t(width,height) overall pixel size\n\t#\t\t\"max\" maximised\n\t#\t\t\"desktop\" fill desktop screen\n\t#\t\tomitted: use (640,480)\n\t#owner\toptional owner window (default nil)\n\t#options\toption dict, default is [wf_caption:1, wf_border:wbs_resize]\n\n\thwnd:=wx_createpopup(caption,pos,dim,options,(owner|owner.gdi.hwnd|nil))\n\n\tw:=newwindow(hwnd,0,no_class,bs_windows)\n\n\tif wapplic=nil then\n\t\twapplic:=w\n\tfi\n\n\tW.STYLE:=NEW(STYLEREC)\n\tW.STYLE.BORDER:=0\n\tW.WINDCLASS:=WINDOW_CLASS\n\tW.STYLE.WINDBGND:=WINDOW_COL\n\tW.ENABLE:=1\n\tW.FLAGS.[WA_LEFTDRAG]:=1\n\tW.FLAGS.[WA_LEFTDBL]:=1\n\n\tsetwindowdims_w(w,hwnd)\n\n\tsetupgdi(w,hwnd)\n\tgxfont(w,1)\n\n\tGXDRAWMODE(W,DM_SCREENMEMORY)\n\tGXCLEAR(W)\n\n\treturn w\nend\n\nproc setwindowdims_w(w,hwnd)=\t\t\t!SETWINDOWDIMS\n!use windows functions to set up client and frame pos and dims of top-level window\n\n\tbox:=new(ws_rect)\n\tgetwindowrect(hwnd,&box)\n\tw.frameposx:=box.x\n\tw.frameposy:=box.y\n\tw.framedimx:=box.x2-box.x\n\tw.framedimy:=box.y2-box.y\n\n\tgetclientrect(hwnd,&box)\n\n\tw.dimx:=box.x2-box.x\n\tw.dimy:=box.y2-box.y\n\n\tpt:=ws_point(0,0)\n\tclienttoscreen(hwnd,&pt)\t\t!pos starts at 0,0\n\tw.posx:=pt.x\n\tw.posy:=pt.y\nend\n\nproc setwindowdims_c(w,hwnd)=\t\t\t!SETWINDOWDIMS\n!use windows functions to set up client and frame pos and dims of child window\n\n\n\tbox:=new(ws_rect)\n\tgetwindowrect(hwnd,&box)\t\t\t!client dims also Windows frame dims as has no Windows border\n\tw.posx:=box.x-w.owner.posx\n\tw.posy:=box.y-w.owner.posy\n\tw.dimx:=box.x2-box.x\n\tw.dimy:=box.y2-box.y\n\n\twidths:=bswidths[w.style.border]\n\tif bscat[w.style.border]='I' then widths:=ws_rect(0,0,0,0) fi\n\n\tw.frameposx:=w.posx-widths.x1\n\tw.frameposy:=w.posy-widths.y1\n\tw.framedimx:=w.dimx+widths.x1+widths.x2\n\tw.framedimy:=w.dimy+widths.y1+widths.y2\nend\n\nexport proc gxclear(w,?colour)=\t\t\t!GXCLEAR\n\t#fill window w with <colour>, or with current background if omitted\n\n!RETURN\n\tgdi:=w.gdi\n\tgdi.updated:=1\n\n\tgxcolour(w,getrgb(black))\n\tgxstyle(w,0)\n\n\tif colour.isvoid then\n\t\tcolour:=getrgb(w.style.windbgnd)\n\tfi\n\n\toldpenstyle:=gdi.penstyle\n\toldbrushstyle:=gdi.brushstyle\n\n\tgxbrushstyle(w,bs_solid)\n\tgxstyle(w,ps_null)\n\n\tgxfillrect(w,0,0,w.dimx,w.dimy,colour)\n\tgxbrushstyle(w,oldbrushstyle)\n\tgxstyle(w,oldpenstyle)\nend\n\nexport func gxstyle(w,?style)=\t\t\t!GXSTYLE\n\t#style omitted: get pen current pen style\n\t#style supplied: set pen style for subsequent line drawing\n\t#Style is a char code or int refering to a small variety of Windows dotted styles:\n\t#\t0 S |\t\tSolid\n\t#\tSpace\t\tNull (pen up?)\n\t#\t-\t\t\tDotted\n\t#\t:\t\t\tDashdotdot\n\t#\t!\t\t\tDashdotd\n\t#\tF\t\t\tInside frame\n\n\tgdi:=w.gdi\n\n\tif style.isdef and gdi.penstyle<>style then\n\t\tcase style\n\t\twhen '!' then style:=ps_dashdot\n\t\twhen ':' then style:=ps_dashdotdot\n\t\twhen '-' then style:=ps_dot\n\t\twhen ' ' then style:=ps_null\n\t\twhen 'D' then style:=ps_alternate\n\t\twhen '|','S',0 then style:=ps_solid\n\t\twhen 'F' then style:=ps_insideframe\n\t\tesac\n\n\t\tgdi.penstyle:=style\n\t\tif style>=10 then style:=ps_dot fi\n\t\tdeleteobject(selectobject(gdi.hdc,createpen(style,gdi.penwidth,gdi.pencolour)))\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\tdeleteobject(selectobject(gdi.hdc2,createpen(style,gdi.penwidth,gdi.pencolour)))\n\t\tfi\n\tfi\n\treturn gdi.penstyle\nend\n\nexport proc gxbrushstyle(w,?style,?pattern)=\t\t!GXBRUSHSTYLE\n\t#Set Windows brush style and pattern\n\t#Style supplied:\tset style\n\t#pattern supplied:\tset style\n\t#style is:\t\tS, H, Space, B for Solid, Hatched, Null, DIB\n\t#pattern is:\t- | \\ / + x/X for Hoz, Vert, Diag, Fwd Diag, Cross, Diag Cross\n\n\tgdi:=w.gdi\n\tbrush:=new(ws_logbrush)\n\n\tif style.isdef then\n\t\tif style<>gdi.brushstyle then\n\t\t\tcase style\n\t\t\twhen 'S' then style:=bs_solid\n\t\t\twhen 'H' then style:=bs_hatched\n\t\t\twhen ' ' then style:=bs_null\n\t\t\twhen 'B' then style:=bs_dibpattern\n\t\t\tesac\n\n\t\t\tgdi.brushstyle:=style\n\t\tfi\n\t\tgdi.brushpattern:=0\t\t!default to no pattern, will be changed by pattern if supplied\n\tfi\n\n\tif pattern.isdef and pattern<>gdi.brushpattern then\n\t\tcase pattern\n\t\twhen '-' then pattern:=hs_horizontal\n\t\twhen '|' then pattern:=hs_vertical\n\t\twhen '\\\\' then pattern:=hs_fdiagonal\n\t\twhen '/' then pattern:=hs_bdiagonal\n\t\twhen '+' then pattern:=hs_cross\n\t\twhen 'x','X' then pattern:=hs_diagcross\n\t\tesac\n\t\tgdi.brushpattern:=pattern\n\tfi\n\n\tbrush.lbstyle:=gdi.brushstyle\n\tbrush.lbcolour:=gdi.brushcolour\n\tbrush.lbhatch:=gdi.brushpattern\n\n\tdeleteobject(selectobject(gdi.hdc,createbrushindirect(&brush)))\n\tif gdi.drawmode=dm_screenmemory then\n\t\tdeleteobject(x:=selectobject(gdi.hdc2,createbrushindirect(&brush)))\n\tfi\nend\n\nexport func gxbrushcolour(w,?colour)=\t\t\t!GXBRUSHCOLOUR\n\t#colour supplied:\tset current fill colour\n\t#colour omitted:\treturn current fill colour\n\n\tgdi:=w.gdi\n\n\tif colour.isdef and colour<>gdi.brushcolour then\n\t\tgdi.brushcolour:=colour\n\t\tbrush:=new(ws_logbrush)\n\t\tbrush.lbstyle:=gdi.brushstyle\n\t\tbrush.lbcolour:=colour\n\t\tbrush.lbhatch:=gdi.brushpattern\n\n\t\tdeleteobject(selectobject(gdi.hdc,createbrushindirect(&brush)))\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\tdeleteobject(selectobject(gdi.hdc2,createbrushindirect(&brush)))\n\t\tfi\n\tfi\n\treturn gdi.brushcolour\nend\n\nexport proc gxfillrect(w,x,y,width,height,?colour,mode=0)=\t\t!GXFILLRECT\n\t#Draw filled rectangle with optional outline\n\t#x,y are top-left coordinates\n\t#width, height are overall pixel dimensions, inclusive; they include any outline\n\t#(When the outline is drawn, the filled region is 1 pixel smaller all round)\n\t#colour is the colour of the filled region (current brush colour when omitted)\n\t#mode=1 to draw the outline, or mode=0 (default) to omit it\n\t#The outline is drawn in the current pen colour\n\n\tgdi:=w.gdi\n\tgdi.updated:=1\n\n\toldbrushcolour:=gdi.brushcolour\n\tif colour.isdef then\n\t\tgxbrushcolour(w,colour)\n\tfi\n\n\toldpenstyle:=gdi.penstyle\n\tif mode=0 then\t\t!inside only\n\t\tgxstyle(w,ps_null)\n\tfi\n\n\tif height<0 then y:=y+height+1; height:=-height fi\n\tif width<0 then x:=x+width+1; width:=-width fi\n\n\tif mode=0 then\t\t!inside only, needs extra pixel width\n\t\trectangle(gdi.hdc,x, y,x+width+1,y+height+1)\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\trectangle(gdi.hdc2,x,y,x+width+1,y+height+1)\n\t\tfi\n\telse\t\t\t!inside and outside\n\t\trectangle(gdi.hdc,x, y, x+width, y+height)\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\trectangle(gdi.hdc2,x,y,x+width,y+height)\n\t\tfi\n\tfi\n\tgxstyle(w,oldpenstyle)\n\tgxbrushcolour(w,oldbrushcolour)\nend\n\nexport func gxcolour(w,?colour)=\t\t!GXCOLOUR\n\t# colour supplied:\tset current outline colour for subsequent line drawing\n\t# colour omitted:\treturn current outline colour\n\n\tgdi:=w.gdi\n\n\tif colour.isdef and gdi.pencolour<>colour then\n\t\tgdi.pencolour:=colour\n\t\tgdi.xormode:=0\n\t\tdeleteobject(selectobject(gdi.hdc,createpen(gdi.penstyle,gdi.penwidth,gdi.pencolour)))\n\t\tsetrop2(gdi.hdc,r2_copypen)\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\tdeleteobject(selectobject(gdi.hdc2,createpen(gdi.penstyle,gdi.penwidth,gdi.pencolour)))\n\t\t\tsetrop2(gdi.hdc2,r2_copypen)\n\t\tfi\n\n\tfi\n\n\treturn gdi.pencolour\nend\n\nexport proc gxsetpen(w,pen)=\n\tgxcolour(w,getrgb(pen))\nend\n\nexport proc gxline(w,x,y,?x2,?y2)=\t\t!GXLINE\n\t#gxline(w,x,y)\t\t\tDraw line from current position to x,y\n\t#gxline(w,x,y,x2,y2)\tDraw line from x,y to x2,y2\n\n\tgdi:=w.gdi\n\n\tif x2.isvoid then\t\t!assume 2 params\n\t\tx2:=x\n\t\ty2:=y\n\n\t\tmovetoex(gdi.hdc,gdi.posx, gdi.posy)\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\tmovetoex(gdi.hdc2,gdi.posx, gdi.posy)\n\t\tfi\n\telse\n\t\tmovetoex(gdi.hdc,x, y)\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\tmovetoex(gdi.hdc2,x, y)\n\t\tfi\n\t\tgdi.posx:=x\n\t\tgdi.posy:=y\n\tfi\n\n\tlineto(gdi.hdc,x2,y2)\n\n\tif gdi.drawmode=dm_screenmemory then\n\t\tlineto(gdi.hdc2,x2,y2)\n\tfi\n\tgdi.posx:=x2\n\tgdi.posy:=y2\nend\n\nexport func gxwidth(w,width)=\n!get/set pen width for subsequent line drawing\n\tgdi:=w.gdi\n\tif width.isvoid then\n\t\treturn gdi.penwidth\n\tfi\n\n\tif gdi.penwidth<>width then\n\t\tgdi.penwidth:=width\n\t\tdeleteobject(selectobject(gdi.hdc,createpen(gdi.penstyle,gdi.penwidth,gdi.pencolour)))\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\tdeleteobject(selectobject(gdi.hdc2,createpen(gdi.penstyle,gdi.penwidth,gdi.pencolour)))\n\t\tfi\n\n\tfi\n\treturn width\nend\n\nexport proc gxlinerel(w,dx,dy)=\t\t!GXLINEREL\n\t#Draw line from current position, to current position + (dx,dy)\n\n\tgdi:=w.gdi\n\tmovetoex(gdi.hdc, gdi.posx, gdi.posy)\n\tif gdi.drawmode=dm_screenmemory then\n\t\tmovetoex(gdi.hdc2, gdi.posx, gdi.posy)\n\tfi\n\tx:=gdi.posx+dx\n\ty:=gdi.posy+dy\n\tgxline(w,x,y)\n\tgdi.posx:=x\n\tgdi.posy:=y\nend\n\nexport proc gxmove(w,x2,y2)=\t\t!GXMOVE\n\t#Set current position to x2,y2\n\n\tgdi:=w.gdi\n\n\tmovetoex(gdi.hdc, x2, y2)\n\tif gdi.drawmode=dm_screenmemory then\n\t\tmovetoex(gdi.hdc2,x2, y2)\n\tfi\n\tgdi.posx:=x2\n\tgdi.posy:=y2\nend\n\nexport proc gxmoverel(w,dx,dy)=\t\t!GXMOVEREL\n\t#\tSet current position to current position+(dx,dy)\n\tgdi:=w.gdi\n\n\tgdi.posx+:=dx\n\tgdi.posy+:=dy\n\n\tmovetoex(gdi.hdc,gdi.posx, gdi.posy)\n\tif gdi.drawmode=dm_screenmemory then\n\t\tmovetoex(gdi.hdc2,gdi.posx, gdi.posy)\n\tfi\nend\n\nexport proc gxrect(w,x,y,width,height)=\t\t!GXRECT\n\t#draw outline rectangle starting from x,y at top left, in current pen colour\n\t#overall size is width by height pixels inclusive (x,y to x+width+1,y+height-1)\n\t#outline is 1 pixel wide\n\n\tgdi:=w.gdi\n\tgdi.updated:=1\n\tif height<0 then y:=y+height+1; height:=-height fi\n\tif width<0 then x:=x+width+1; width:=-width fi\n\n\toldbrushstyle:=gdi.brushstyle\n\tgxbrushstyle(w,bs_hollow)\n\n\trectangle(gdi.hdc,x, y, x+width, y+height)\n\tif gdi.drawmode=dm_screenmemory then\n\t\trectangle(gdi.hdc2,x, y, x+width,y+height)\n\tfi\n\tgxbrushstyle(w,oldbrushstyle)\nend\n\nexport proc gxcircle(w,x,y,r)=\t\t!GXCIRCLE\n\t#draw circle at centre x,y in window w, of radius r, using current pen colour\n\t#outline is 1 pixel wide\n\n\tgdi:=w.gdi\n\tgdi.updated:=1\n\toldbrushstyle:=gdi.brushstyle\n\tgxbrushstyle(w,bs_hollow)\n\n\tellipse(gdi.hdc,x-r, y-r, x+r-1, y+r-1)\n\tif gdi.drawmode=dm_screenmemory then\n\t\tellipse(gdi.hdc2,x-r, y-r, x+r-1, y+r-1)\n\tfi\n\tgxbrushstyle(w,oldbrushstyle)\nend\n\nexport proc gxfillcircle(w,x,y,r,?colour,mode=0)=\t\t!GXFILLCIRCLE\n\t#Draw filled circle with optional outline\n\t#x,y is the centre, r is the radius\n\t#(When the outline is drawn, the filled region is 1 pixel smaller all round)\n\t#colour is the colour of the filled region (current brush colour when omitted)\n\t#mode=1 to draw the outline, or mode=0 (default) to omit it\n\t#The outline is drawn in the current pen colour\n\tgdi:=w.gdi\n\n\tgdi.updated:=1\n\toldbrushcolour:=gdi.brushcolour\n\tif colour.isdef then\n\t\tgxbrushcolour(w,colour)\n\tfi\n\n\toldpenstyle:=gdi.penstyle\n\tif mode=0 then\t\t!inside only\n\t\tgxstyle(w,ps_null)\n\tfi\n\n\tellipse(gdi.hdc,x-r, y-r, x+r-1, y+r-1)\n\tif gdi.drawmode=dm_screenmemory then\n\t\tellipse(gdi.hdc2,x-r, y-r, x+r-1, y+r-1)\n\tfi\n\n\tgxstyle(w,oldpenstyle)\n\tgxbrushcolour(w,oldbrushcolour)\nend\n\nexport func gxpixel(w,x,y,?colour)=\t\t!GXPIXEL\n\t#colour provided: set pixel at point x,y of window w to colour\n\t#colour omitted: return pixel colour from point x,y\n!set pixel at x,y with given rgb colour, or return pixel value if omitted (-1)\n\tw.gdi.updated:=1\n\n\tif colour.isvoid then\t\t!get pixel\n\t\tres:=getpixel(w.gdi.hdc, x, y)\n\t\tif w.gdi.drawmode=dm_screenmemory then\n\t\t\tgetpixel(w.gdi.hdc2, x, y)\n\t\tfi\n\t\treturn res\n\telse\n\t\tsetpixel(w.gdi.hdc,x, y, colour)\n\t\tif w.gdi.drawmode=dm_screenmemory then\n\t\t\tsetpixel(w.gdi.hdc2,x,y,colour)\n\t\tfi\n\t\treturn colour\n\tfi\nend\n\nexport func gxcaption(w,?caption)=\t\t!GXCAPTION\n\t#caption omitted:  return current window caption text\n\t#caption provided: set new window caption text\n\n\tcase w.windclass\n\twhen window_class,popup_class then\n\n\t\tif caption.isdef then\t\t!set text\n\t\t\tsetwindowtext(w.gdi.hwnd,caption)\n\t\t\treturn caption\n\t\telse\n\t\t\tbuffer:=new(array,byte,512)\n\t\t\tn:=getwindowtext(w.gdi.hwnd,int(&buffer),buffer.len)\n\t\t\tif n then\n\t\t\t\ts:=makestr(&buffer,n)\t\t!needs assigment to ensure a copy is made befor buffer\n\t\t\t\t\t\t\t\t\t\t\t!is freed (assignment of return value might do the same)\n\t\t\telse\n\t\t\t\ts:=\"\"\n\t\t\tfi\n\t\t\treturn s\n\t\tfi\n\tesac\n\n\tif caption.isdef then\t\t!set text\n\t\tw.text:=caption\n\t\tgxdraw(w)\n\tfi\n\n\treturn w.text\nend\n\nexport proc gxtext(w,s,?x,?y)=\t\t!GXTEXT\n\t#Display text s\n\t#Text is drawn starting at (x,y) when provided, otherwise at current position\n\t#insertion point refers either to base line, or to top left of cell (not sure)\n\t#Text is drawn in current font, size, style and mode\n\t#Text typically contains no control codes, but can also contain cr and lf (also\n\t#tabs, but currently position isn't changed). However, text with control codes is\n\t#drawn a character at a time\n\t#Finishes with current position set to the end of the text\n\n!uses chr(16) for reverse tab. Reverse tabs are usually encoded as:\n!  chr(9)+chr(16), ie. normal tab then reverse tab\n!Reverse tab, after tabbing to next stop, then moves position back by width\n!of next substring\n\n\treturn when s=\"\"\n\n\tgdi:=w.gdi\n\n\tif x.isvoid then x:=gdi.posx fi\n\tif y.isvoid then y:=gdi.posy fi\n\tgdi.updated:=1\n\n!scan the string and create a table of substrings and control codes\n\tstartpos::=lengths::=()\n\tngroups:=0\n\n\tforeach i,c in s do\n\t\tif c<32 then\n\t\t\t++ngroups\n\t\t\tstartpos[ngroups]:=i\n\t\t\tlengths[ngroups]:=0\n\t\telse\n\t\t\tif ngroups and lengths[ngroups] then\t\t!extend this group\n\t\t\t\t++lengths[ngroups]\n\t\t\telse\t\t\t\t\t\t\t\t\t\t!start new substring group\n\t\t\t\t++ngroups\n\t\t\t\tstartpos[ngroups]:=i\n\t\t\t\tlengths[ngroups]:=1\n\t\t\tfi\n\t\tfi\n\tod\n\n\tfor i,l in lengths do\n\t\tpos:=startpos[i]\n\t\tif l then\n\t\t\tslicex:=pos..pos+l-1\n\t\t\ttextout(gdi.hdc,x, y,s.[slicex],l)\n\n\t\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\t\ttextout(gdi.hdc2,x,y,s.[slicex],l)\n\t\t\tfi\n\t\t\tx +:= gxtextwidth(w,s.[slicex])\n\n\t\telse\t\t\t\t!Deal with control codes\n\t\t\tcase s.[pos]\n\t\t\twhen 13 then\n\t\t\t\tx:=0\n\t\t\twhen 10 then\n\t\t\t\ty+:=20\t\t\t\t!NEEDS TO PICK CURRENT FONT DIMS\n\n\t\t\twhen 9,16 then\t\t\t!16 will be used as reverse tab\n\t\t\t\tcurrx:=x\n\t\t\t\tx:=0\n\t\t\t\tfor t in tabstops do\n\t\t\t\t\tx+:=t*chx\t\t\t\t!MUST BE CURRENT FONT NOT CHX\n\t\t\t\t\tif x>currx then exit fi\n\t\t\t\tod\n\t\t\t\twhile x<=currx do x+:=chx*8 od\n\n\t\t\t\tif s.[pos]=16 and i<ngroups and lengths[i+1] then\t!reverse offset for next substring\n\t\t\t\t\tpos:=startpos[i+1]\n\t\t\t\t\tx -:= gxtextwidth(w,s.[pos..pos+lengths[i+1]-1])+1\n\t\t\t\tfi\n\n\t\t\tesac\t\n\t\tfi\n\tod\n\n\tgdi.posx:=x\n\tgdi.posy:=y\nend\n\nexport func gxtextcolour(w,?colour,?bgndcolour)=\t\t!GXTEXTCOLOUR\n\t#Set either text foreground colour or background colour, or both, or neither,\n\t#depending on which are supplied\n\t#Text colours will be colour indices, not rgb\n\t#Always returned current or new foreground\n\n\tgdi:=w.gdi\n\n\tif colour.isdef and colour<>w.style.textfgnd then\n\t\tw.style.textfgnd:=colour\n\t\tsettextcolour(gdi.hdc,getrgb(colour))\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\tsettextcolour(gdi.hdc2,getrgb(colour))\n\t\tfi\n\tfi\n\tif bgndcolour.isdef and bgndcolour<>w.style.textbgnd then\n\t\tgxbgndcolour(w,bgndcolour)\n\tfi\n\n\treturn w.style.textfgnd\nend\n\nexport func gxtextwidth(font,?s)=\t\t!GXTEXTWIDTH\n\t# font is a window, or a font number within fonttable\n\t# font can be zero (then uses font 1)\n\t# return total pixel width of string s, using given font\n\n\tif s=\"\" then return 0 fi\n\n!if not font.isint then\t\t\t!aasume font is window\n!CPL =FONT\n!CPL =FONT.TYPE\n\n\n!if not font.ispointer then\t\t\t!aasume font is window\n\tif not font.isint then\t\t\t!aasume font is window\n\t\tfont:=font.gdi.font\n\tfi\n\tif font=0 then font:=1 fi\n\n\tselectobject(screendc,fonttable[font])\n\twidthheight:=new(ws_point)\n\n!CPL =S\n\n\tgettextextentpoint32(screendc,s,s.len,&widthheight)\n\n\treturn widthheight.x\nend\n\nexport func gxloadfont(n,facename,?style,height=0,width=0)=\t\t!GXLOADFONT\n\t#define new font\n\t#N is index into fonttable\n\t#facename is the name of the font\n\t#Style is optional font style, a string containing any of:\n\t#\tB,b\t\tBold\n\t#\tI,i\t\tItalic\n\t#\tU,u\t\tUnderline\n\t#\tS,s\t\tStrikeout\n\t#Height is height of text (default 0, gives default height?)\n\t#Weight is width; defautl 0 normally used for normal aspect of text\n\n\tCPL \"GXLOADFONT\"\n\n\tif n<=0 then return 0 fi\n!n:=min(n,nglobalfonts)\n\n\tif style.isvoid then style:=\"\" fi\n\n\tif n<=nglobalfonts and fonttable[n] then\t\t\t!remove existing font\n\t\tigxremovefont(n)\n\tfi\n\n\tp:=style\n\tbold:=400\n\titalic:=0\n\tunderline:=0\n\tstrikeout:=0\n\tfor c in style do\n\t\tcase asc(convuc(c))\n\t\twhen 'B' then bold:=700\n\t\twhen 'I' then italic:=1\n\t\twhen 'U' then underline:=1\n\t\twhen 'S' then strikeout:=1\n\t\tesac\n\tod\n\n\thfont:=createfont(\n\t\tfacename:\tfacename,\n\t\theight:\t\theight,\n\t\twidth:\t\twidth,\n\t\tbold:\t\tbold,\n\t\titalic:\t\titalic,\n\t\tunderline:\tunderline,\n\t\tcharset:\t0,\n\t\tquality:\t2,\n\t\tescapement:\t0,\n\t\torientation:0)\n\n\tif hfont=0 then\n\t\thfont:=getstockobject(system_font)\n\tfi\n\n\tfonttable[n]:=hfont\n\tnglobalfonts:=max(n,nglobalfonts)\n\n\tselectobject(screendc,fonttable[n])\n\n\ttm:=new(ws_textmetrics)\n\n\tgettextmetrics(screendc,&tm)\n\n\tfontdimtable[n]::=ws_point(tm.avecharwidth, tm.height+tm.externalleading)\n\tfontvdimtable[n]::=ws_point(tm.ascent, tm.descent)\n\n\tselectobject(screendc,getstockobject(system_font))\n\n\treturn n\nend\n\nproc igxremovefont(n)=\n!unload font n, free table entry\n\n\tunless n in 1..nglobalfonts then return end\n\tif fonttable[n]=0 then return fi\t!already freed\n\n!w:=windowlist\n!while w<>nil do\n!\tif w.gdi.hdc and w.gdi.font>0 then\t\t!font was in use, set as undefined\n!\t\tw.gdi.font:=1\n!\t\tselectobject(w.gdi.hdc,fonttable[w.gdi.font])\n!\t\tif w.gdi.hdc2 then\n!\t\t\tselectobject(w.gdi.hdc2,fonttable[w.gdi.font])\n!\t\tfi\n!\tfi\n!\tw:=w.nextwind\n!od\n\n\tdeleteobject(fonttable[n])\t\t!get rid of this font\n\tfonttable[n]:=0\nend\n\nexport func gxfont(w,font=1)=\t\t!GXFONT\n\t# select font from font table for subsequent text display; default is font 1\n\n\tif not w then w:=wapplic fi\n\tif not w then w:=wscreen fi\n\n\tgdi:=w.gdi\n\n\tif font.isdef and font<>gdi.font then\n\t\tif font not in 1..nglobalfonts then\n\t\t\tabort(\"Bad font number \"+tostr(font))\n\t\tfi\n\t\tgdi.font:=font\n\t\tif fonttable[font]=0 then\n\t\t\tabort(\"Font not in use \"+tostr(font))\n\t\tfi\n\n\t\toldhfont:=selectobject(gdi.hdc,fonttable[font])\n\t\tsendmessage(gdi.hwnd,wm_setfont,fonttable[font],0)\n\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\toldhfont:=selectobject(gdi.hdc2,fonttable[font])\n\t\t\tsendmessage(gdi.hwnd2,wm_setfont,fonttable[font],0)\n\t\tfi\n\t\tif fontdimtable[font].x=0 then\t\t!set up dims\n\t\t\tgxchardim(font,0)\n\t\tfi\n\tfi\n\treturn gdi.font\nend\n\nfunc hascontrolchars(s)=\t\t!TESTCTRLCHAR\n!scan string s looking for control chars\n!return 1 if control chars (<20H) are present\n\n\tforeach c in s do\n\t\tif c<32 then return 1 fi\n\tod\n\treturn 0\nend\n\nexport func gxchardim(font,vert=0)=\t\t\t!GXCHARDIM\n\t#return font char average width/height info as a point rec\n\t#wfont is a font number, or hwindow when the current font in that window is used\n\t#vert=1 means get ascent/descent pair instead of (vert=0) average width/height\n\n\tif not font.isint then\n\t\tfont:=font.gdi.font\n\tfi\n\tif font=0 then font:=1 fi\n\n!CPL =FONTDIMTABLE,=FONT\n\n\tif fontdimtable[font].x=0 then\t\t!probably stock fonts not setup with gxloadfont\n\t\tselectobject(screendc,fonttable[font])\n\t\ttm:=new(ws_textmetrics)\n\t\tgettextmetrics(screendc,&tm)\n\n\t\tfontdimtable[font]::=ws_point(tm.avecharwidth, tm.height+tm.externalleading)\n\n\t\tfontvdimtable[font]::=ws_point(tm.ascent, fontvdimtable[font].y:=tm.descent)\n\n\t\tselectobject(screendc,getstockobject(ansi_var_font))\n\tfi\n\n\tif vert then\n\t\treturn fontvdimtable[font]\n\tfi\n\n\treturn fontdimtable[font]\nend\n\nexport func gxbgndcolour(w,?colour)=\t\t!GXBGNDCOLOUR\n\t#Set background colour (for text mainly)\n\t#colour will be a colour index\n\t#return current colour when omitted\n\tgdi:=w.gdi\n\n\tif colour.isdef then\n\n\t\tif colour<>w.style.textbgnd then\n\t\t\tw.style.textbgnd:=colour\n\t\t\tsetbkcolour(gdi.hdc,getrgb(colour))\n\t\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\t\tsetbkcolour(gdi.hdc2,getrgb(colour))\n\t\t\tfi\n\t\tfi\n\t\tgxbgndmode(w,(colour<>w.style.windbgnd|1|0))\n\tfi\n\treturn w.style.textbgnd\nend\n\nexport func gxbgndmode(w,?mode)=\t\t!GXBGNDMODE\n\t#\tmode supplied: set new background mode:\n\t#\t\t1 y Y T\t\tSet opaque (T for True? Looks like Transparent)\n\t#\t\t0 n N F\t\tSet Transparent\n\n\tgdi:=w.gdi\n\n\tif mode.isdef  then\n\t\tcase mode\n\t\twhen 1,'y','Y','T' then\n\t\t\tw.style.bgndmode:=opaque\n\t\telse\n\t\t\tw.style.bgndmode:=transparent\n\t\tesac\n\n\t\tsetbkmode(gdi.hdc,mode+1)\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\tsetbkmode(gdi.hdc2,mode+1)\n\t\tfi\n\tfi\n\treturn w.style.bgndmode\nend\n\nexport proc gxhighlight(w,x,y,width,height)=\t\t!GXHIGHLIGHT\n\t#Invert rectangular region\n\tconst dstinvert=0x00550009\t!patblt\n\tgdi:=w.gdi\n\n\tgdi.updated:=1\n\tpatblt(gdi.hdc, x, y, width,height,dstinvert)\n\tif gdi.drawmode=dm_screenmemory then\n\t\tpatblt(gdi.hdc2, x,y, width,height,dstinvert)\n\tfi\nend\n\nexport proc gxbitblt(w,x2,y2,width,height,x,y)=\t\t\t!GXBITBLT\n\t#Copy rectangular region of window to another location\n\tgdi:=w.gdi\n\tgdi.updated:=1\n\tbitblt(gdi.hdc, x2, y2, width,height,\n\t\t\t\tgdi.hdc,x,y,srccopy)\n\n\tif gdi.drawmode=dm_screenmemory then\n\t\tbitblt(gdi.hdc2,x2,y2,width,height,gdi.hdc2,x,y,srccopy)\n\tfi\nend\n\nexport func gxaskmess(mode=0)=\n\t#wait for next message and return message number\n\t#return 0 if close or quit message seen\n\t#some messages will be ignored here (processsed via procmess) and will wait for next\n\t#mode=0\t\tReturn currmess.message\n\t#mode=1\t\tReturn currmess.message, but if a mm_command message, then return\n\t#\t\t\tthe command id. This means message numbers and command ids share the\n\t#\t\t\tsame space. This should work because messages are below 200, and ids above 200\n\n!CPL \"AM1\",$REFCOUNT(WAPPLIC)\n\trepeat\n\t\tif mxwait_mm_message()=0 then\nCPL \"GXAM MAXWAIT =0\"\n\t\t\treturn mm_cancel\n\t\tfi\n\t\tif quitmess then return mm_cancel fi\n\t\tx:=process_message(currmess)\n\n\t\tif currmess.message=mm_key and currmess.a=27 then\n\t\t\treturn mm_cancel\n\t\tfi\n\n\tuntil x=thismess\t\t\t\t\t!message ready to return\n\n\tif mode=1 and currmess.message=mm_command then\n\t\treturn currmess.a\n\tfi\n\n\treturn currmess.message\nend\n\nfunc process_message(mess)=\n\t#user or default event processing for mm message\n\t#will call event handler if there is one\n\t#returns 1 (skipmess) if message has been processed here; caller must wait for another message\n\t#returns 0 (thismess) caller should deal with this message (it has not been processed, or has beenbut caller can process it too)\n\n!\tCP \"\t\";SHOWMESSAGE(\"PROCMESS\",MESS)\n\n\n\tif mess.wind=nil then\n\t\treturn thismess\n\tfi\n\n\tcase mess.message\n\twhen mm_close then\n\t\treturn thismess\n\tesac\n\n!CPL \"PROCESS MESSAGE\"\n\n\tstatus:=domessage(mess)\n!CPL =STATUS,\"AFTER DOMESS\"\n\n\treturn status\nend\n\nexport proc docs=\n!export proc where dostringzs for entire lib can go\n\t#Option dicts: used as args to gccreatewindow/gxcreatechildwindow:\n\t#\twf_border\t\tBorder style; see wbs_ enums\n\t#\twf_resize\t\t1 for resizable border (for top-level windows)\n\t# wf_hscroll\t\t1 for horizontal scrollbar\n\t# wf_vscroll\t\t1 for vertical scrollbar\n\t# wf_menu\t\t\t1 for a menubar\n\t# wf_caption\t\t1 for a caption bar (needs to be the right kind of border too)\n\t# wf_max\t\t\t1 for a max button\n\t# wf_minmax\t\t1 for a min/max buttons\n\t# wf_sysmenu\t\t1 for a system menu (right-click on top left I think)\n\t# wf_desktop\t\t1 to fill desktop\n\t# wf_clip\t\t\t1 to clip windows to desktop\n\t# wf_show\t\t\t1 to show window after creating\n\t# wf_iframe\t\t1 for pos/dim to refer to frame rather than client area\n\t# wf_cent\t\t\t1 to centre window\n\t# wf_toolwind\t\t1 for tool window (not sure what this means)\n\nend\n\nfunc newwindow(hwnd,index,windclass,borderstyle)=\n\n\tw:=new(rwindow,0)\n\tw.windclass:=windclass\n!w.style.borderstyle:=borderstyle\n\tw.index:=index\n\tw.childlist::=()\n\tw.owner:=nil\n\tw.closed:=0\n\n\taddwindow(w)\n\twx_setw(hwnd,w.gindex)\n\treturn w\nend\n\nexport func getrgb(index)=\n\tif index=0 then return 0 fi\n\treturn colourvalues[index]\nend\n\nfunc readstyle(owner,windclass,options)=\n!process gx options stored in the given dict type\n!return a stylerec all filled in\n\n\tif options.type=stylerec then\t\t\t!already a stylerec\n\t\treturn options\n\tfi\n\n\tss:=new(stylerec)\n\tif options.isvoid then\t\t\t\t!use bunch of defaults\n\t\td::=defstyle\n\t\td.border:=defaultborderstyles[windclass]\n\t\treturn d\n\tfi\n\n\tss.border\t:=options{ss_border,defaultborderstyles[windclass]}\n\tss.justify\t:=options{ss_justify,defstyle.justify}\n\tss.vjustify\t:=options{ss_vjustify,defstyle.vjustify}\n\tss.textfgnd\t:=options{ss_textfgnd,defstyle.textfgnd}\n\tss.textbgnd\t:=options{ss_textbgnd,defstyle.textbgnd}\n\tss.bgndmode\t:=options{ss_bgndmode,defstyle.bgndmode}\n\n\tss.iframe\t:=options{ss_iframe,0}\n\n\tss.hilitetype\t:=options{ss_hilitetype,defstyle.hilitetype}\n\tss.marktype\t:=options{ss_marktype,(ss.hilitetype|0|defstyle.marktype)}\n\tss.imark\t:=options{ss_imark,defstyle.imark}\n\n\tif windclass in [toggle_class, select_class,mark_class] and ss.marktype then\n\t\tdef:=owner.style.windbgnd\n\telse\n\t\tdef:=defstyle.windbgnd\n\tfi\n\n\tss.windbgnd\t:=options{ss_windbgnd,def}\n\tss.hscroll\t:=options{ss_hscroll,0}\n\tss.vscroll\t:=options{ss_vscroll,0}\n\tss.lbchange\t:=options{ss_lbchange,0}\n\tss.returnmess\t:=options{ss_returnmess,0}\n\tss.noupdate\t:=options{ss_noupdate,0}\n\n\treturn ss\nend\n\nexport func gxpanel(owner,pos,dim,?style)=\n\tss:=readstyle(owner,panel_class,style)\n\tw:=gxcontrol(owner,panel_class,pos,dim,ss)\n\tgxdraw(w)\n\n\treturn w\nend\n\nexport func gxgroup(owner,pos,dim,?style)=\n\tss:=readstyle(owner,group_class,style)\n\tw:=gxcontrol(owner,group_class,pos,dim,ss)\n\tgxdraw(w)\n\n\treturn w\nend\n\nexport func gxstatusbar(owner,pos,dim,?style)=\n\n\tss:=readstyle(owner,statusbar_class,style)\n\n\tif ss.iframe=0 then\t\t\t\t\t!frame not included, but can't have it leaking outside owner\n\t\tbs:=ss.border\n\t\tif bscat[bs]<>'I' then\t\t\t!do adjustments\n\t\t\tdim+:=bswidths[bs].y1+bswidths[bs].y2\n\t\tfi\n\t\tss.iframe:=1\t\t\t\t\t!stop gxcontrol expanding dims\n\tfi\n\n\t(ecapos,ecadim):=gxclientarea(owner)\n\n\tif pos.isint then pos:=chr(pos) fi\n!if pos.ispointer then pos:=chr(pos) fi\n\tif convuc(pos) in \"T TOP\" then\t\t\t!along the top\n\t\tpos:=ecapos\n\t\tdir:='T'\n\telse\t\t\t\t\t\t\t\t\t!along the bottom\n\t\tpos:=(ecapos[1],ecadim[2]-dim+ecapos[2])\n\t\tdir:='B'\n\tfi\n\tdim:=(ecadim[1],dim)\n\n\tss.dir:=dir\n\n\tw:=gxcontrol(owner,statusbar_class,pos,dim,ss)\n\n\tgxdraw(w)\n\n\treturn w\nend\n\nexport func gxframebar(owner,pos,dim,?style)=\n\n\tss:=readstyle(owner,framebar_class,style)\n\tif ss.iframe=0 then\t\t\t\t\t!frame not included, but can't have it leaking outside owner\n\t\tbs:=ss.border\n\t\tif bscat[bs]<>'I' then\t\t\t!do adjustments\n\t\t\tdim+:=bswidths[bs].y1+bswidths[bs].y2\n\t\tfi\n\t\tss.iframe:=1\t\t\t\t\t!stop gxcontrol expanding dims\n\tfi\n\n\t(ecapos,ecadim):=gxclientarea(owner)\n\n!if pos.isint then pos:=chr(pos) fi\n\tif pos.ispointer then pos:=chr(pos) fi\n\tif convuc(pos) in \"L LEFT\" then\t\t\t!along the left\n\t\tpos:=ecapos\n\t\tdir:='L'\n\telse\t\t\t\t\t\t\t\t\t!along the right\n\t\tpos:=(ecadim[1]-dim+ecapos[1],ecapos[2])\n\t\tdir:='R'\n\tfi\n\tdim:=(dim,ecadim[2])\n\n\tss.dir:=dir\n\n\tw:=gxcontrol(owner,\tframebar_class,pos,dim,ss)\n\n\tgxdraw(w)\n\n\treturn w\nend\n\nexport func gxbutton(owner,pos,dim,caption,?style,id=201,enable=1)=\n\t#create clickable button\n\t#returns rwindow\n\n\tss:=readstyle(owner,button_class,style)\n\n\tw:=gxcontrol(owner,button_class,pos,dim,ss)\n\tw.id:=id\n\n\tw.text:=caption\n\tw.enable:=enable\n\tgxdraw(w)\n\n\treturn w\nend\n\nexport func gxlabel(owner,pos,dim,caption,?style)=\n\t#create static label button\n\t#returns rwindow\n\n\tss:=readstyle(owner,label_class,style)\n\n\tw:=gxcontrol(owner,label_class,pos,dim,ss)\n\n\tw.text:=caption\n\tgxdraw(w)\n\n\treturn w\nend\n\nfunc gxcontrol(owner,windclass=button_class,pos,dim,?ss)=\n\n\tif ss.type=dict or ss.isvoid then\n\t\tss:=readstyle(owner,windclass,ss)\n\tfi\n\twb:=wbs_none\n\tcase ss.border\t\t\t!find wbs- version of windows-drawn borders\n\twhen bs_simplew then\n\t\twb:=wbs_simple\n\tesac\n\n\tif ss.iframe and bscat[ss.border]<>'I' then\n\t\twidths:=bswidths[ss.border]\n\t\tpos[1]+:=widths.x1\n\t\tpos[2]+:=widths.y1\n\t\tdim[1]-:=widths.x1+widths.x2\n\t\tdim[2]-:=widths.y1+widths.y2\n\tFI\n\n\thwnd:=wx_createcontrol(pos:pos,dim:dim,border:wb,owner:owner.gdi.hwnd)\n\n\tif hwnd=0 then\n\t\tabort(\"Can't create control window\")\n\tfi\n\n\tw:=newwindow(hwnd,0,no_class,ss.border)\n\tw.windclass:=windclass\n\tw.style:=ss\n\tw.owner:=owner\n\tw.enable:=1\n\n\tsetwindowdims_c(w,hwnd)\n\tsetupgdi(w,hwnd)\n\n\tgxdrawmode(w,dm_screenmemory)\n\n\tgxfont(w,labelfont)\n\n\tgxtextcolour(w,w.style.textfgnd,w.style.textbgnd)\n\n\tgxbgndmode(w,w.style.bgndmode)\n\n!link into owner\n\tw.owner.childlist append:=w\n\tw.index:=w.owner.childlist.upb\n\n\treturn w\nend\n\nexport func gxtoggle(owner,pos,dim,caption=\"\",linkvar,?style,id=201,enable=1)=\n\n\t(posx,posy):=pos\n\t(dimx,dimy):=dim\n\ttextoffset:=0\n\n\n\tss:=readstyle(owner,toggle_class,style)\n\n!work out whether an auxiliary window is needed\n\n\tif ss.marktype then\n\t\tif ss.imark=0 then\t\t\t!dims don't include the mark\n\t\t\tposx-:=markdim\n\t\t\tdimx+:=markdim\n\t\t\ttextoffset:=markdim\n\t\tfi\n\tfi\n\n\tw:=gxcontrol(owner,toggle_class,(posx,posy),(dimx,dimy),ss)\n!RETURN 0\n\tw.linkvar:=linkvar\n\tw.id:=id\n\tw.text:=caption\n\tw.attrs:=togglerec(textoffset,1)\n\tw.enable:=enable\n\n\tif w.style.marktype then\n!\tgxmark(owner:w,pos:(0,(w.dimy-markdim)%2),id:id,style:style)\n\t\tgxmark(owner:w,pos:(0,(w.dimy-markdim)%2),id:id, style:ss)\n\tfi\n\n\tgxdraw(w)\n\treturn w\nend\n\nexport func gxselect(owner,pos,dim,caption=\"\",linkvar,onvalue,?style,id=201,enable=1)=\n\n\t(posx,posy):=pos\n\t(dimx,dimy):=dim\n\ttextoffset:=0\n\n\tss:=readstyle(owner,select_class,style)\n\n!work out whether an auxiliary window is needed\n\tif ss.marktype and ss.imark=0 then\t\t\t!dims don't include the mark\n\t\tposx-:=markdim\n\t\tdimx+:=markdim\n\t\ttextoffset:=markdim\n\tfi\n\n\tw:=gxcontrol(owner,select_class,(posx,posy),(dimx,dimy),ss)\n\n\tw.linkvar:=linkvar\n\tw.id:=id\n\tw.text:=caption\n\tw.attrs:=togglerec(textoffset,onvalue)\n\tw.enable:=enable\n\tif w.style.marktype then\n\t\tgxmark(owner:w,pos:(0,(w.dimy-markdim)%2),id:id, style:style)\n\tfi\n\n\tgxdraw(w)\n\treturn w\nend\n\nexport proc showmessage(caption,mess)=\n!RETURN\n!\tCPL MESS.MESSAGE\n\tcp caption,,\":\",leftstr(messagenames[mess.message],14)\n\tcp \"A:\",,mess.a,\"B:\",,mess.b\n\tcp \" (X:\",,mess.x,\"Y:\",,mess.y,,\") Buttons:\",mess.state:\"b\"\n\n\tif mess.wind then\n\t\tcpl \"\tWindow:\",mess.wind.name\n\telse\n\t\tcpl\n\tfi\nend\n\nfunc domessage(mess)=\n\n\tm:=mess.message\n\tw:=mess.wind\n\n\tcase m\n\twhen mm_move,mm_setcursor then\n\t\treturn skipmess\n\tesac\n\n!CPL \"DOMESSAGE\",MESSAGENAMES[M]\n\n!\tCPL messhandlertable[m,w.windclass]\n\tx:=messhandlertable[m,w.windclass](mess,w)\n\n\treturn x\nend\n\nproc init_handlertables=\n\tmesshandlertable:=maketable(mm_null..mm_last, no_class..dummy_class, nil)\n\tactionhandlertable:=maketable(actionnames.bounds, no_class..dummy_class, nil)\n\n\tmessalltable:=new(list,mm_null..mm_last,0)\t\t!for all mess_mess_all handlers\n\tfnallall:=nil\t\t\t\t\t\t\t\t\t!for single mess_all_all handler\n\tfnfixups:=nil\n\n\tactionalltable:=new(list,actionnames.bounds,0)\n\n\tfor d to $nprocs() do\n\t\tfnptr:=$procref(d)\n\t\tfnname:=$procname(d)\n\n\t\t(name,messname,windname):=splitstring(fnname,\"_\")\t\t\t!split func name\n\n\t\tif fnname=\"gxhandler_fixups\" then\n\t\t\tfnfixups:=fnptr\n\t\telsif leftstr(fnname,5)=\"mess_\" then\n\t\t\tif messname=\"all\" and windname=\"all\" then\n\t\t\t\tfnallall:=fnptr\n\t\t\telse\n\t\t\t\tmessage:=(\"mm_\"+messname) inx messagenames\n\t\t\t\tif not message.isfound then\n\t\t\t\t\tABORT(\"CAN'T FIND MESSAGE <\"+messname+\">\")\n\t\t\t\tfi\n\n\t\t\t\tif windname=\"all\" then\t\t\t\t!assume <mess> all\n\t\t\t\t\tmessalltable[message]:=fnptr\n\t\t\t\telse\n\t\t\t\t\tmesshandlertable[message,WX:=findwindclass(windname)]:=fnptr\n\t\t\t\tfi\n\t\t\tfi\n\n\t\telsif leftstr(fnname,8)=\"do_draw_\" or leftstr(fnname,10)=\"do_update_\" then\n\t\t\taction:=messname+\"_w\" inx actionnames\n\t\t\tif not action.isfound then\n\t\t\t\tABORT(\"CAN'T FIND ACTION \"+MESSNAME)\n\t\t\tfi\n\t\t\tif windname=\"all\" then\n\t\t\t\tactionalltable[action]:=fnptr\n\t\t\telse\n\t\t\t\twindclass:=findwindclass(windname)\n\t\t\t\tactionhandlertable[action,windclass]:=fnptr\n\t\t\tfi\n\t\tfi\n\tod\n\n!!do some manual fixups\n\tif fnfixups then\n\t\tfnfixups()\n\tfi\n\n\tfor mx:=0 to mm_last do\n\t\tfor wx:=0 to dummy_class do\n\t\t\tif not messhandlertable[mx,wx] then\n\t\t\t\tmesshandlertable[mx,wx]:=(messalltable[mx]|messalltable[mx]|fnallall)\n\t\t\tfi\n\t\tod\n\tod\n\n\tif not fnallall then\n\t\tpcerror(\"Can't find all/all mess handler\")\n\tfi\n\n\tfor ax:=1 to DRAW_w do\n\t\tfor wx:=0 to dummy_class do\n\t\t\tif not actionhandlertable[ax,wx] then\n\t\t\t\tif not actionalltable then\n\t\t\t\t\tpcerror(\"No DO/ALL handler for:\"+actionnames[ax])\n\t\t\t\tfi\n\t\t\t\tactionhandlertable[ax,wx]:=actionalltable[ax]\n\t\t\tfi\n\t\tod\n\tod\nend\n\nfunc findwindclass(name)=\n\t\twindclass:=name+\"_class\" inx windowclassnames\n\t\tunless windclass.isfound then\n\t\t\tABORT(\"CAN'T FIND WINDOW \"+windname)\n\t\tend\n\t\treturn windclass\nend\n\nexport proc gxdraw(w)=\n\tfnptr:=actionhandlertable[draw_w,w.windclass]\n\n\tif fnptr then\n\t\tfnptr(w)\n\telse\n\t\tcpl \"NO DRAW HANDLER\",windowclassnames[w.windclass],w.name\n\t\twaitkey()\n\t\tstop\n\tfi\nend\n\nexport proc gxupdate(w)=\n\tfnptr:=actionhandlertable[update_w,w.windclass]\n\tif fnptr then\n\t\tfnptr(w)\n\telse\n\t\tgxdraw(w)\n\tfi\nend\n\nexport proc eventloop=\n\tdo\n\t\tm:=gxaskmess()\n\n\t\tSHOWMESSAGE(\"EVENTLOOP\",CURRMESS)\n\n\t\tcase m\n\t\twhen 0,mm_cancel then\n\t\t\treturn\n\t\tesac\n\n\tod\nend\n\nexport func gxeditbox(owner,pos,dim,linkvar,?style,id=201,enable=1)=\n\n\tss:=readstyle(owner,editbox_class,style)\n\n\tw:=gxcontrol(owner,editbox_class,pos,dim,ss)\n\n\tw.linkvar:=linkvar\n\tw.id:=id\n\tw.attrs:=new(editboxrec)\n\tw.attrs.currpos:=linkvar^.len+1\n\tw.enable:=enable\n\n\tgxdraw(w)\n\treturn w\nend\n\nexport proc gxebchange(w,?linkvar,charpos=-1)=\n\n\tif linkvar.isdef then\n\t\tw.linkvar:=linkvar\n\tfi\n\n\tif charpos=-1 then\n\t\tw.attrs.currpos:=w.linkvar^.len+1\n\telse\n\t\tw.attrs.currpos:=charpos\n\tfi\n\tgxupdate(w)\nend\n\nexport proc gxsetlbdata(w,linkvar,?pos)=\n\tw.linkvar:=linkvar\n\tif pos.isvoid then\n\t\tpos:=(linkvar^|1|0)\n\tfi\n\tw.attrs.currpos:=pos\n\n\tif w.childlist[1] then\n!\tgxsetscrolllimits(ws,linkvar^.bounds,w.attrs.rows)\n\t\tgxsetscrolllimits(ws,getlvbounds(linkvar),w.attrs.rows)\n\t\tgxscrollpos(ws,pos)\n\tfi\nend\n\nexport proc gxsetlbpos(w,pos)=\n!change in pos\n\tw.attrs.currpos:=pos\n\n!work out screen row\n\tif pos then\n\t\toldpagepos:=w.attrs.pagepos\n\t\tif pos<oldpagepos then\n\t\t\tw.attrs.pagepos:=pos\n\t\telsif pos>oldpagepos+w.attrs.rows-1 then\n\t\t\tw.attrs.pagepos:=pos-w.attrs.rows+1\n\t\tfi\n\t\tif w.attrs.pagepos<>oldpagepos then\n\t\t\tif w.childlist then\n\t\t\t\tgxscrollpos(w.childlist[1],w.attrs.pagepos)\n\t\t\tfi\n\t\t\tm:=mm_draw\n\t\telse\n\t\t\tm:=mm_update\n\t\tfi\n\telse\n\t\tm:=mm_draw\n\tfi\n\n\tpostmess(w,m)\n\tif w.style.lbchange then\n\t\tpostmess(w,mm_lbchange,w.attrs.currpos)\n\tfi\nend\n\nexport proc gxsetlbpage(w,pagepos)=\n!change in pagepos (originates from scrollbar message)\n\tw.attrs.pagepos:=pagepos\n\n\toldpos:=w.attrs.currpos\n\tif oldpos<pagepos then\n\t\tw.attrs.currpos:=pagepos\n\telsif oldpos>=pagepos+w.attrs.rows then\n\t\tw.attrs.currpos:=pagepos+w.attrs.rows-1\n\tfi\n\n\tif w.childlist then\n\t\tgxscrollpos(w.childlist[1],pagepos)\n\tfi\n\n\tpostmess(w,mm_draw)\n\tif w.style.lbchange and oldpos<>w.attrs.currpos then\n\t\tpostmess(w,mm_lbchange,w.attrs.currpos)\n\tfi\nend\n\nexport func gxlistbox(owner,pos,dim,linkvar,?style,id=201,rows=0,pitch=0,offset=0)=\n\n\tss:=readstyle(owner,listbox_class,style)\n\n\t(dimx,dimy):=dim\n\tif ss_vscroll and ss_imark=0 then\t\t\t!dims don't include the scrollbar\n\t\tdimx+:=arrowdim\n\tfi\n\n\tw:=gxcontrol(owner,listbox_class,pos,(dimx,dimy),ss)\n\tw.linkvar:=linkvar\n\tw.id:=id\n\tw.attrs:=new(listboxrec)\n\n\tif pitch=0 then\t\t\t\t\t\t\t\t!calculate all these here\n\t\tpitch:=listrowheight\n\t\toffset:=0\n\t\trows:=w.dimy%pitch\n\tfi\n\tw.attrs.rows:=rows\n\tw.attrs.pitch:=pitch\n\tw.attrs.offset:=offset\n\n\tw.attrs.pagepos:=1\n\tw.attrs.currpos:=(getlvbounds(linkvar).len|1|0)\n\n\tif w.style.vscroll then\n\t\tws:=gxvertscrollbar(owner:w,pos:(w.dimx-arrowdim,0),dim:w.dimy,id:id,style:style)\n\t\tgxsetscrolllimits(ws,getlvbounds(linkvar),w.attrs.rows)\n\n\t\tgxscrollpos(ws,getlvbounds(linkvar).lwb)\n\tfi\n\n\tgxdraw(w)\n\treturn w\nend\n\nexport func gxarrow(owner,pos,?dim,dir,?style,id=201)=\n\n\tss:=readstyle(owner,arrow_class,style)\n\tif dim.isvoid then\n\t\tdim:=(arrowdim,arrowdim)\n\tfi\n\n\tw:=gxcontrol(owner,arrow_class,pos,dim,ss)\n\tw.id:=id\n\tif dir.isstring then dir:=asc(dir) fi\n\tcase dir\t\t\t\t\t!allow compass bearings too, but convert to UDLR\n\twhen 'N' then dir:='U'\n\twhen 'E' then dir:='R'\n\twhen 'S' then dir:='D'\n\twhen 'W' then dir:='L'\n\tesac\n\n\tw.style.dir:=dir\t\t\t!don't dir allow via style options\n\tgxdraw(w)\n\n\treturn w\nend\n\nexport proc gxsetscrolllimits(w,limits,span=0)=\n!set up or change scrollbar limits\n!span=0:\n!\tPure ranging control. Limits are actual range of the thumb.\n!\tThumb is drawn at a fixed, nominal size. Might be suppressed when limits are <=1\n!\tInitial position set to limits.lwb\n!span=M:\n!\tPaging control, such as used on a listbox or text editor.\n!\tSpan can be the number of rows display at one time.\n!\tLimit can be single number N, or range 1..N.\n!\tActual scroll bar range will be 1..N-M+1. When upper limit<1 then\n!\tlimit will be 1..1, and thumb might not be drawn\n!\tData position will: actually there /is/ not data position, except for the\n!\tdata position represented by the top row, which will be the same as the scroll\n!\tposition.\n!Arrows should be disabled (and perhaps thumb suppressed) when scroll range if 1..1,\n!or data range is nor larger than a span\n\n\tw.attrs.span:=span\n\tif w.style.dir='H' then\n\t\twidth:=w.dimx\n\telse\n\t\twidth:=w.dimy\n\tfi\n\tm:=width-arrowdim*2\t\t\t\t!number of pixels movement between arrows\n\n\tif span=0 then\t\t\t\t\t\t!pure scrolling control\n\t\tw.attrs.limits:=limits\n\t\tw.attrs.currpos:=limits.lwb\n\t\tw.attrs.thumbsize:=arrowdim\n\t\tenable:=limits.len>1\n\t\tw.attrs.thumbsize:=arrowdim*enable\n\telse\n\t\tif limits.isrange then\n\t\t\tlength:=limits.len\n\t\telse\n\t\t\tlength:=limits\n\t\tfi\n\t\tif length<=span then\n\t\t\tenable:=0\n\t\t\tw.attrs.limits:=1..1\n\t\t\tw.attrs.thumbsize:=0\n\t\telse\n\t\t\tw.attrs.limits:=1..length-span+1\n\t\t\tenable:=1\n\t\t\tw.attrs.thumbsize:=max(10,int(m*(span/length)))\n\t\tfi\n\tfi\n\n\tw.attrs.currpos:=w.attrs.limits.lwb\n\tw.enable:=enable\n\n\tw.attrs.thumbspan:=m-w.attrs.thumbsize\t\t!movement available to thumb\n\tw.attrs.thumbpos:=arrowdim\n\tpostmess(w,mm_draw)\nend\n\nexport func gxscrollpos(w,pos,u=0)=\n!\n\tif pos.isvoid then\n\t\treturn w.attrs.currpos\n\tfi\n\n\tCPL =POS\n\tCPL =W.ATTRS.CURRPOS\n\tCPL =W.ATTRS.LIMITS\n\n\tw.attrs.currpos:=pos\n\tif pos not in w.attrs.limits then\n\t\tpcerror(\"Bad scroll pos\")\n\tfi\n\n\ttpos:=int(w.attrs.thumbspan*((pos-w.attrs.limits.lwb)/(w.attrs.limits.len-1)))\n\tw.attrs.thumbpos:=arrowdim+tpos\n\n\tw.childlist[1].enable:=pos>w.attrs.limits.lwb\n\tw.childlist[2].enable:=pos<w.attrs.limits.upb\n\n\tif u then\n\t\tpostmess(w,mm_update)\n\tfi\n\treturn 0\nend\n\nexport func gxhozscrollbar(owner,pos,dim,?style,id=201)=\n\n\tss:=readstyle(owner,scrollbar_class,style)\n\twidth:=arrowdim\n\tif dim.isint then\n!if dim.ispointer then\n\t\tdim:=(dim,width)\n\telse\n\t\twidth:=dim[1]\n\tfi\n\n\tw:=gxcontrol(owner,scrollbar_class,pos,dim,ss)\n\tw.id:=id\n\tw.style.dir:='H'\n\n\tw.attrs:=new(scrollbarrec)\n\tw.flags.[wa_leftdrag]:=1\n\n!Now, create the arrows at each end. The thumbbar is not an explicit control,\n!it's just a drawn box\n\twa:=gxarrow(owner:w, pos:(0,0), dim:(width,width),dir:'L')\n\twb:=gxarrow(owner:w, pos:(dim[1]-width,0), dim:(width,width),dir:'R')\n\n\tgxsetscrolllimits(w,1..200,20)\n\tgxscrollpos(w,1)\n\n\tgxdraw(w)\n\n\treturn w\nend\n\nexport func gxvertscrollbar(owner,pos,dim,?style,id=201)=\n\tss:=readstyle(owner,scrollbar_class,style)\n\twidth:=arrowdim\n\tif dim.isint then\n!if dim.ispointer then\n\t\tdim:=(width,dim)\n\telse\n\t\twidth:=dim[2]\n\tfi\n\n\tw:=gxcontrol(owner,scrollbar_class,pos,dim,ss)\n\tw.id:=id\n\tw.style.dir:='V'\n\n\tw.attrs:=new(scrollbarrec)\n\tw.flags.[wa_leftdrag]:=1\n\n!Now, create the arrows at each end. The thumbbar is not an explicit control,\n!it's just a drawn box\n\twa:=gxarrow(owner:w, pos:(0,0), dim:(width,width),dir:'U')\n\twb:=gxarrow(owner:w, pos:(0,dim[2]-width), dim:(width,width),dir:'D')\n\tgxsetscrolllimits(w,100..200,2)\n\n\tgxscrollpos(w,100)\n\n\tgxdraw(w)\n\n\treturn w\nend\n\nexport func gxmark(owner,pos,?dim,?style,id=201)=\n\n\tss:=readstyle(owner,mark_class,style)\n\tif dim.isvoid then\n\t\tdim:=(markdim,markdim)\n\tfi\n\n\tw:=gxcontrol(owner,mark_class,pos,dim,style)\n\tw.id:=id\n\tgxdraw(w)\n\n\treturn w\nend\n\nexport proc gxfocus(w)=\n!switch focus to window w\n\tif wfocus==w then\n\t\treturn\n\tfi\n\n\tif wfocus then\n\t\tdomessage(makemess(wfocus,mm_killfocus))\n\tfi\n\tcaretdrawn:=0\n\tdomessage(makemess(w,mm_setfocus))\nend\n\nexport proc gxkillfocus=\n\tif wfocus then\n\t\tdrawcaret(0)\n\tfi\n\twfocus:=nil\nend\n\nexport func gxcopy(w,?bm,x=0,y=0,scalex=1.0,scaley=0,sx=0,sy=0,dimx=0,dimy=0)=\t\t!GXCOPY\n!copy bitmap bm to window w, at position x,y in w. Scalex/y can be 0 for 1:1,\n!or Scalex/y can be any real value for unequal x/y scaling\n!For equal x/y scaling, Scaley can be 0\n!Entire bitmap is copied (sx,sy,w,h all 0); for portion, set sx,sy to top left of rect\n!and w,h to size to be copied\n![1..100]char str\n\n\tif bm.isvoid then\n\t\tbm:=w\n\t\tw:=nil\n\tfi\n\tif bm.isvoid then\n\t\treturn nil\n\tfi\n\n\tif dimx=0 then dimx:=bm.dimx-sx fi\n\tif dimy=0 then dimy:=bm.dimy-sy fi\n\n\tif scalex=0 then scalex:=1.0 fi\n\tif scaley=0 then scaley:=scalex fi\n\n\tif w=nil then\t\t!create appropriate window\n\t\tw:=gxcreatewindow(caption:\"Bitmap \"+tostr(bm.pixelbits)+\" bit\",pos:(500,500),\n\t\t\t\tdim:(bm.dimx*scalex,bm.dimy*scaley))\n\t\tw.gdi.drawmode:=dm_screenmemory\t\t\t!default when using auto-window\n\tfi\n\n\tgdi:=w.gdi\n\tgdi.updated:=1\n\n\tmode:=copymode\n\n\tsetstretchbltmode(gdi.hdc,mode)\n\tstretchblt(gdi.hdc, x, y,int(dimx*scalex),int(dimy*scaley),\n\t\t\t\t\t\t\t\t\t\t\t\tbm.gdi.hdc,sx,sy,dimx,dimy, srccopy)\n\tif gdi.drawmode=dm_screenmemory then\n\t\tsetstretchbltmode(gdi.hdc2,mode)\n\t\tstretchblt(gdi.hdc2,x,y,int(dimx*scalex),int(dimy*scaley),\n\t\t\t\t\t\t\t\t\t\t\t\tbm.gdi.hdc,sx,sy,dimx,dimy, srccopy)\n\tfi\n\n\treturn w\nend\n\nexport proc gxrestore(w,?r)=\n!repaint window w\n!only called when repaint can be done from a backup\n!r is the region to restore within w; or restore all if omitted\n\n\tif r.isvoid then\n\t\tx1:=y1:=0\n\n\t\twidth:=w.dimx\n\t\theight:=w.dimy\n\telse\n\t\tx1:=r.x1\n\t\ty1:=r.x2\n\t\twidth:=r.x2-x1+1\n\t\theight:=r.y2-y1+1\n\tfi\n\n\tcase w.gdi.drawmode\n\twhen dm_screen then\t\t\t!can't restore; need to call gx_draw\n\t\tgxdraw(w)\n\twhen dm_screenmemory then\n\t\tdestdc:=w.gdi.hdc\n\t\tsourcedc:=w.gdi.hdc2\n\twhen dm_memoryscreen then\n\t\tdestdc:=w.gdi.hdc2\n\t\tsourcedc:=w.gdi.hdc\n\telse\n\t\tabort(\"gxrest/?\")\n\tesac\n\n\tbitblt(destdc,x1,y1, width,height, sourcedc, x1,y1, srccopy)\n\nend\n\nexport func gxdrawmode(w,?drawmode)=\n!set or get drawmode\n!really requires window to be cleared afterwards.\n\n\tolddrawmode:=w.gdi.drawmode\n\tif drawmode.isvoid then\n\t\treturn olddrawmode\n\tfi\n\n\tif olddrawmode=drawmode then\t\t!already set\n\t\treturn drawmode\n\telsif olddrawmode<>dm_screen then\t!can only change screen => screenmemory/memoryscreen\n\t\tabort(\"gxdrawmode2\")\t\t\t!not memory to anything else\n\tfi\n\n!assuming currently on screen, will need extra compatible bitmap\n\tmemhwnd:=createcompatiblebitmap(screendc,w.dimx,w.dimy)\n\tmemhdc:=createcompatibledc(nil)\n\tselectobject(memhdc,memhwnd)\n\n!need to change draw mode\n\tcase drawmode\n\twhen dm_screenmemory then\n\t\tw.gdi.hwnd2:=memhwnd\n\t\tw.gdi.hdc2:=memhdc\n\twhen dm_memoryscreen then\n\t\tw.gdi.hwnd2:=w.gdi.hwnd\t\t\t!screen becomes secondary\n\t\tw.gdi.hdc2:=w.gdi.hdc\n\t\tw.gdi.hwnd:=memhwnd\n\t\tw.gdi.hdc:=memhdc\n\telse\n\t\tabort(\"gxdrawmode?\")\n\tesac\n\n\tw.gdi.drawmode:=drawmode\n\treturn drawmode\nend\n\nexport proc switchdest(w)=\n!for a window with screenmemory drawmode, switch things around so that\n!it's drawing into the memory area only\n\tgdi:=w.gdi\n\n\tcase gdi.drawmode\n\twhen dm_screenmemory then\n\t\tt:=gdi.hwnd; gdi.hwnd:=gdi.hwnd2; gdi.hwnd2:=t\n\t\tt:=gdi.hdc; gdi.hdc:=gdi.hdc2; gdi.hdc2:=t\n\t\tgdi.drawmode:=dm_memory\n\twhen dm_memory then\n\t\tt:=gdi.hwnd; gdi.hwnd:=gdi.hwnd2; gdi.hwnd2:=t\n\t\tt:=gdi.hdc; gdi.hdc:=gdi.hdc2; gdi.hdc2:=t\n\t\tgdi.drawmode:=dm_screenmemory\n\tesac\nend\n\nexport proc gxclose(w)=\n\n!CPL \"GXCLOSE1\",$REFCOUNT(W)\n\n\tcase w.windclass\n\twhen bitmap_class then\n\telse\n!ID:=$ID(W)\n\t\tif issubwindow(w,wfocus) then\n\t\t\twfocus:=nil\n\t\tfi\n\n\t\tif issubwindow(w,wmouse) then\t\n\t\t\tlastmousewindow:=nil\n\t\t\twmouse:=nil\n\t\tfi\n\n\t\tdestroywindow(w.gdi.hwnd)\n\n!IF $ID(CURRMESS.WIND)=ID THEN\n!CPL \"-------CLOSED CURRMESS.WIND\"\n!CURRMESS.WIND:=NIL\n!FI\n!CPL \"GXCLOSE2\",$REFCOUNT(W)\n\n\t\tgxfreewindow(w)\n!CPL \"GXCLOSE3\",$REFCOUNT(W)\n\n\tIF W=WAPPLIC THEN WAPPLIC:=NIL FI\n\n\tesac\nend\n\nproc gxfreewindow(w)=\n!recover memory used by this window and all childwindows\n\tfor wc in w.childlist do\n\t\tgxfreewindow(wc)\n\tod\n\n\tremovewindow(w)\n\n!CPL \"FREEING2\",$ID(W),$ID(W.GDI), $REFCOUNT(W), $REFCOUNT(W.GDI)\n\tw.gdi:=0\n\n!\tw:=0\nend\n\nexport func gxmsgbox(message,caption=\"\",options=\"\")=\n\n\tconst mb_abortretryignore\t= 0x02\n\tconst mb_applmodal\t\t\t= 0x00\n\tconst mb_defbutton1\t\t\t= 0x00\n\tconst mb_defbutton2\t\t\t= 100\n\tconst mb_defbutton3\t\t\t= 200\n\tconst mb_defbutton4\t\t\t= 300\n\tconst mb_help\t\t\t\t= 4000\n\tconst mb_iconasterisk\t\t= 40\n\tconst mb_iconerror\t\t\t= 10\n\tconst mb_iconexclamation\t= 30\n\tconst mb_iconhand\t\t\t= mb_iconerror\n\tconst mb_iconinformation\t= mb_iconasterisk\n\tconst mb_iconquestion\t\t= 20\n\tconst mb_iconstop\t\t\t= mb_iconhand\n\tconst mb_iconwarning\t\t= mb_iconexclamation\n\tconst mb_ok\t\t\t\t\t= 0x00\n\tconst mb_okcancel\t\t\t= 0x01\n\tconst mb_retrycancel\t\t= 0x05\n\tconst mb_right\t\t\t\t= 80000\n\tconst mb_setforeground\t\t= 10000\n\tconst mb_systemmodal \t\t= 1000\n\tconst mb_taskmodal\t\t\t= 2000\n\tconst mb_yesno\t\t\t\t= 0x04\n\tconst mb_yesnocancel\t\t= 0x03\n\tconst mb_topmost\t\t\t= 0x040000\n\n!return values\n\tconst idfail\t= 0\n\tconst idok\t\t= 1\n\tconst idcancel\t= 2\n\tconst idabort\t= 3\n\tconst idretry\t= 4\n\tconst idignore\t= 5\n\tconst idyes\t\t= 6\n\tconst idno\t\t= 7\n\n\tstatic var rettable=(0:\"fail\",\"ok\",\"cancel\",\"abort\",\"retry\",\"ignore\",\"yes\",\"no\",\n\t\t\t\"\",\"\",\"tryagain\",\"continue\")\n\n\tstatic var styletable=(\n\t(\"bari\",mb_abortretryignore),\n\t(\"bo\",mb_ok),\n\t(\"boc\",mb_okcancel),\n\t(\"brc\",mb_retrycancel),\n\t(\"byn\",mb_yesno),\n\t(\"bync\",mb_yesnocancel),\n\t(\"ix\",mb_iconexclamation),\n\t(\"iw\",mb_iconwarning),\n\t(\"ii\",mb_iconinformation),\n\t(\"iq\",mb_iconquestion),\n\t(\"is\",mb_iconstop),\n\t(\"ie\",mb_iconerror),\n\t(\"ih\",mb_iconhand),\n\t(\"d1\",mb_defbutton1),\n\t(\"d2\",mb_defbutton2),\n\t(\"d3\",mb_defbutton3),\n\t(\"d4\",mb_defbutton4),\n\t(\"h\",mb_help),\n\t(\"rj\",mb_right),\n\t(\"sm\",mb_systemmodal))\n\n\thwnd:=nil\n\n\tstyle:=0\n\toptioncodes:=splitstring(options,\" \")\n\n\tfor opt in optioncodes do\n\t\tfor i to styletable.len do\n\t\t\tif styletable[i,1]=opt then style ior:=styletable[i,2] fi\n\t\tod\n\tod\n\n\tstyle ior:=0x10000\n\n\tx:=messageboxa(hwnd,message,caption,style)\n\treturn rettable[x]\nend\n\n\nexport proc gxhandler(windclass,mess,fnptr)=\n!windclass is a window, or a window class\n!override the current message handler for w's window class, and fo message mess\n\n!if not windclass.isint then\n\tif not windclass.ispointer then\n\t\twindclass:=windclass.windclass\n\tfi\n\n!CPL \"SETTING GXHANDLER\",MESS,WINDCLASS,FNPTR\n\tmesshandlertable[mess,windclass]:=fnptr\nend\n\nexport func gxaskfile(caption=\"File\",filespec=\"*.*\",deffile=\"\",startdir=\"\")=\n\n\tsave:=0\n\tif caption='*' then\n\t\tsave:=1\n\t\tcaption:=rightstr(caption,-1)\n\tfi\n\n\tfilters:=array(filespec+\"@@@\")\t\t!turn into a byte-array\n\n\tfor i,bb in filters do\t\t\t!convert all @ into embedded zeros\n\t\tif bb='@' then filters[i]:=0 fi\n\tod\n\n\tofn:=new((iswin32|ws_openfilename32|ws_openfilename64))\n\n\tofn.structsize:=ofn.bytes\n\tofn.owner:=wapplic.gdi.hwnd\n\tofn.instance:=getmodulehandle(0)\n\tofn.filter:=int(&filters)\n\tofn.flags:=ofn_explorer ior ofn_nochangedir ior ofn_hidereadonly !IOR OFN_NOVALIDATE\n\n\tofn.initialdir:=getstringz(startdir)\n\n\tofn.defext:=getstringz(\"\")\n\n\tresult:=new(array,byte,300)\n\n\tresult[1]:=0\n\tif deffile<>\"\" then\n\t\tmemcpy(&result,&deffile,deffile.len)\n\tfi\n\n\tofn.file:=int(&result)\n\n\tofn.maxfile:=256\n\tofn.title:=getstringz(caption)\n\n\tif not (not save | getopenfilenamea(&ofn) | getsavefilenamea(&ofn)) then\n\t\tresult[1]:=0\t\t!return \"\" on error\n\tfi\n\n\treturn string(result)\nend\n\nexport func gxcurrpos(w)=\n\treturn w.attrs.currpos\nend\n\nexport func gxtabstops(?tabs,signed=0)=\n\tif tabs.isdef then\n\t\ttabstops::=tabs\n\t\tif signed then\n\t\t\tfor i,x in tabstops do\n\t\t\t\ttabstops[i]:=abs(x)\n\t\t\tod\n\t\tfi\n\tfi\n\treturn tabstops\n\nend\n\nexport func getlvbounds(linkvar)=\n\tif linkvar.ispointer and linkvar^.islist then\n\t\treturn linkvar^.bounds\n\telse\n\t\treturn linkvar.getbounds()\n\tfi\n\treturn 0\nend\n\nexport func getlvitem(linkvar,n)=\n\tif linkvar.ispointer and linkvar^.islist then\n\t\treturn linkvar^[n]\n\telse\n\t\tPCERROR(\"GETLVITEM\")\n\tfi\n\treturn 0\nend\n\nexport func getlvstritem(linkvar,n)=\n\tif linkvar.ispointer and linkvar^.islist then\n\t\treturn tostr(linkvar^[n])\n\telse\n\t\treturn linkvar.getstritem(n)\n\tfi\n\treturn 0\nend\n\nexport proc gxtext16(w,s,n,x=0,y=0)=\t\t!GXTEXT\n\t\tgdi:=w.gdi\n\n\t\ttextoutw(gdi.hdc,x, y,&s,n)\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\ttextoutw(gdi.hdc2,x,y,&s,n)\n\t\tfi\nend\n\nexport func gxenable(w,flag)=\n\tif flag.isdef then\n\t\tw.enable:=flag\n\t\tgxupdate(w)\n\tfi\n\treturn w.enable\nend\n\nexport func gxclientarea(w)=\n!scan child windows of w, work out remaining client area after taking account of\n!framebars etc\n!return (pos, dim), each being a 2-element list\n\n\taposx:=aposy:=0\n\n\tadimx:=w.dimx\n\tadimy:=w.dimy\n\n\tcentx:=(aposx+adimx)%2\n\tcenty:=(aposy+adimy)%2\n\n!for cw in w.childlist when cw.windclass in [statusbar_class,framebar_class] do\n\tfor cw in w.childlist do\n\n\t\t(posx,posy):=(cw.frameposx,cw.frameposy)\n\t\t(dimx,dimy):=(cw.framedimx,cw.framedimy)\n\n!need to find out which of the four sides the bar is against, and set up side= L R T B\n\t\tcase cw.style.dir\n\t\twhen 'B' then\t\t\t\t!bottom\n\t\t\tif posy<(aposy+adimy) then\n\t\t\t\tadimy-:=dimy\n\t\t\tfi\n\n\t\twhen 'T' then\t\t\t\t!top\n\t\t\tif (posy+dimy)>aposy then\t\t!\n\t\t\t\taposy+:=(posy+dimy)\n\t\t\t\tadimy-:=(posy+dimy)\n\t\t\tfi\n\n\t\twhen 'R' then\t\t\t\t!right\n\t\t\tif posx<(aposx+adimx) then\n\t\t\t\tadimx-:=dimx\n\t\t\tfi\n\n\t\twhen 'L' then\t\t\t\t!LEFT\n\t\t\tif (posx+dimx)>aposx then\t\t!\n\t\t\t\taposx+:=(posx+dimx)\n\t\t\t\tadimx-:=(posx+dimx)\n\t\t\tfi\n\t\telse\n\n\t\t\tif dimx>dimy then\t\t\t!assume hoz\n\t\t\t\tif posy>centy then\t\t\t!assume bottom\n\t\t\t\t\tif posy<(aposy+adimy) then\n\t\t\t\t\t\tadimy-:=dimy\n\t\t\t\t\tfi\n\n\t\t\t\telse\t\t\t\t\t!top\n\t\t\t\t\tif (posy+dimy)>aposy then\t\t!\n\t\t\t\t\t\taposy+:=(posy+dimy)\n\t\t\t\t\t\tadimy-:=(posy+dimy)\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\telse\t\t\t\t\t!assume vert\n\t\t\t\tif posx>centx then\t\t\t!assume right\n\n\t\t\t\t\tif posx<(aposx+adimx) then\n\t\t\t\t\t\tadimx-:=dimx\n\t\t\t\t\tfi\n\n\t\t\t\telse\t\t\t\t\t!left\n\n\t\t\t\t\tif (posx+dimx)>aposx then\t\t!\n\t\t\t\t\t\taposx+:=(posx+dimx)\n\t\t\t\t\t\tadimx-:=(posx+dimx)\n\t\t\t\t\tfi\n\n\t\t\t\tfi\n\t\t\tfi\n\t\tesac\n\tod\n\n\treturn ((aposx,aposy), (adimx,adimy))\nend\n\nexport func addwindow(w)=\n!w is a newly created window\n!add it to all windows\n\tn:=nil inx allwindows\n\tif not n.isfound then\n\t\tn:=allwindows.len+1\n\tfi\n\n\tallwindows[n]:=w\n\tw.gindex:=n\n\treturn n\nend\n\nexport proc removewindow(w)=\n!remove w from all windows\n\tn:=w inx allwindows\n\tif n.isfound then\n\t\tallwindows[n]:=nil\n\tfi\n\n\tfor i to nmessages do\n\t\tm:=messagequeue[i]\n\t\tif m.wind==w then\n\t\t\tm.wind:=nil\n\t\tfi\n\tod\n\n!\tif currmess.wind==w then\n!\t\tcurrmess.wind:=nil\n!\tfi\n\nend\n\nfunc process_wmmessage(msg)=\n!STATIC VAR CC=0\n!CPL \"PROCESS/WMMESSAGE\",++CC\n!CPL \"PROC/WM1\",MSG, MSG.HWND\n\t\tx:=process_wmmessage2(msg)\n!CPL \"RETURN X:\",X\n!$SETDEBUG(1)\n\t\treturn x\nend\n\nfunc process_wmmessage2(msg)=\n!msg is a windows rmsg record\n!Called from MainWndProc callback func (via mechanisms for B code to call into MPL code)\n!this func processes some wm_ Windows messages and converts them\n!into mm_ messages as necessary\n!It returns:\n!\t0 The wm_ message has been processed\n!\t1 The wm_ message has not been processed, and the caller should call DefWindowProc.\n!\t  Or, the DefWindowProc should also be called anyway.\n\n!CPL \"PROCESSWMM2\",MSG.MESSAGE, WINMESSAGENAMES{MSG.MESSAGE}\n\n\thwnd:=msg.hwnd\n!CPL \"PM2\",=HWND,MSG.HWND\n\tw:=getwindow(hwnd)\n!CPL \"AFTER GW1\"\n\n\tmessage:=msg.message\n\twparam:=msg.wparam\n\tlparam:=msg.lparam\n\n\tcase msg.message\n\twhen wm_command then\n\t\tw:=getwindow(lparam)\t\t\t!w was owner, use control window\n!CPL \"AFTER GW2\"\n\t\ti:=wparam iand 0xffff\t\t\t!id\n\t\tj:=wparam>>16\t\t\t\t!notify code\n\t\tm:=mm_command\n\n\t\tif not w then\n\t\t\tw:=wapplic\n\t\tfi\n\n\t\tpostmess(w,m,i,j,0)\n\n\t\treturn 0\n\n\twhen wm_activate then\n\t\tif wparam then\t\t\t\t!being activated\n\t\tfi\n\n\twhen wm_syskeydown,wm_syskeyup,wm_keydown,wm_keyup then\n!\n!\tSTATIC VAR COUNT=0\n!\n!\tIF MSG.MESSAGE=WM_KEYDOWN THEN\n!\tCPL \"KEY\",++COUNT\n!\tFI\n\n\t\tif dokeymessage(hwnd,message,wparam,lparam) then\n\t\t\treturn 0\n\t\tfi\n\n\twhen wm_char then\n\t\tpostmess((wfocus|wfocus|w),mm_char,wparam,lparam,0)\n\n\twhen wm_close then\n\t\tif w==wapplic then\n\t\t\tpostmess(w,mm_close,0,0,0)\n\t\t\treturn 0\n\t\telse\n\t\t\tpostmess(w,mm_cancel,0,0,0)\n\t\t\treturn 0\n\t\tfi\n\n\twhen wm_timer then\n\t\tif not background and not stationary then\t\t!test for pausing of mouse\n\t\t\tif gettickcount()-lastxytime>pausetime then\n\t\t\t\tstationary:=1\n\t\t\tfi\n\t\tfi\n\n\twhen wm_destroy then\n\t\tif w and wapplic and w==wapplic then\n\t\t\tkilltimer(hwnd,1)\n!*\t\tif tick then killtimer(hwnd,1) fi\n!CPL \"**********************POSTING QUIT WM\",WAPPLIC\n\n\n!\t\t\tpostquitmessage(0)\t\t\t!mm_quit message\n\t\t\treturn 0\n\t\telse\n\t\t\treturn 1\n\t\tfi\n\n!when wm_setcursor then\n!\tpostmess(w,mm_setcursor,wparam,lparam,0)\n\n\twhen wm_mousemove then\n\n\t\tbuttonstate:=wparam iand (kb_lbutton ior kb_rbutton ior kb_mbutton)\n\t\tmousepos.x:=lparam iand 65535\n\t\tmousepos.y:=lparam>>16\n\n\tdomousemove:\n\t\txyvalid:=1\t\t\t\t!known again\n\t\tsetnewmousewindow(w)\n\n\t\twmouse:=w\n\t\tpostmess(wmouse,mm_move)\n\n\t\tlastxy::=getscreencoords(wmouse,mousepos)\n\t\tlastxytime:=gettickcount()\n\t\tstationary:=0\n\n!do drag processing; states are:\n!pen up/recent pen down/first drag/subsequent drag\n!any drag messages are sent as well as mm_move messages\n!dragmode=1/2/3 indicates drag has started (reset by buttonswitching)\n\n\t\tif buttonstate<>0 and lastmousewindow<>nil then\t\t!switch pressed\n\t\t\tpt:=getscreencoords(lastmousewindow,lastmousepos)\n\t\t\tdx:=lastxy.x-pt.x\n\t\t\tdy:=lastxy.y-pt.y\n\n\t\t\tif dragmode then\t\t!1st drag message already generated\n\t\t\t\tpostmess(lastmousewindow,mm_drag,dx,dy,-1)\t\t\t!send latest drag coords\n\n\t\t\telse\t\t\t\t!test for drag enabling\n\t\t\t\tif ((mousesw=1 and lastmousewindow.flags.[wa_leftdrag]<>0) or \\\n\t\t\t\t\t\t\t\t(mousesw=2 and lastmousewindow.flags.[wa_rightdrag]<>0) or \\\n\t\t\t\t\t\t\t\t(mousesw=3 and lastmousewindow.flags.[wa_middledrag]<>0)) and \\\n\t\t\t\t\t\t\t(abs(dx)>dragtol or abs(dy)>dragtol) then\n\t\t\t\t\tdragmode:=mousesw\n\t\t\t\t\tpostmess(lastmousewindow,mm_startdrag,dx,dy,-1)\t\t!send latest drag coords\n\t\t\t\tfi\n\n\t\t\tfi\n\t\telse\n\t\t\tif dragmode then\n\t\t\t\tpostmess(lastmousewindow,mm_enddrag,dx,dy,-1)\t!send latest drag coords\n\t\t\t\tdragmode:=0\n\t\t\tfi\n\t\tfi\n\n\t\treturn 0\n\n\twhen wm_enteridle then\t\t!enter idle\n\t\tidlemode:=1\n\t\treturn 0\n\n\twhen wm_paint then\n\n\t\tif w<>nil then\n\t\t\tps:=new(ws_paintstruct)\n\t\t\trect:=new(ws_rect)\n\t\t\tbeginpaint(hwnd,&ps)\n\t\t\tpostmess(w,mm_restore,0,0,0)\n\t\t\tendpaint(hwnd,&ps)\n\t\t\treturn 0\n\t\tfi\n\n\twhen wm_erasebkgnd then\n\n\twhen wm_move then\n\t\tif w<>nil then\n!*!\t\tgxmovewindow(w,lparam iand 65535,lparam>>16)\n\t\tfi\n\n\twhen wm_size then\n\t\tx:=lparam iand 0xffff\n\t\ty:=lparam>>16\n\t\tif w<>nil  and (w.dimx<>x or w.dimy<>y) then\n!*!\t\tgxmplresize(w,x,y,wparam)\n\t\t\treturn 0\n\t\tfi\n\n!when wm_killfocus,wm_setfocus then\n\n\twhen wm_contextmenu then\n\t\tsendmess(w,mm_rclick,wparam>>16,wparam iand 0xffff,0)\n\t\treturn 0\n\n\twhen wm_mousewheel then\n\t\tif not wmouse then wmouse:=w fi\n\t\tpostmess(wmouse,mm_wheel,int(wparam>>16),wparam iand 0xffff,0)\n\t\treturn 0\n\n\twhen wm_nclbuttondown,wm_nclbuttondblclick then\n\n\twhen wm_activateapp then\n\t\tif wparam then\n\t\t\tpostmess(w,mm_activate,1,0,0)\n\t\tfi\n\n\telse\n\tbtnmessages:\n!check for sequential messages\n!CPL \"FALLTHROUGH\"\n\t\tif message>=wm_lbuttondown and message<=wm_mbuttondblclk then\n\t\t\tbuttonmessages(hwnd,message,wparam,lparam)\n\t\t\treturn 0\n\t\tfi\n\tesac\n!end\n!fall-through here to do default message processing instead of/in addition to local processing\n\treturn 1\t!defwindowproc(hwnd,imsg,wparam,lparam)\nend\n\nexport proc mxinit=\n\twmessagetable := [\\\n\t\twm_lbuttondown:\t\tmm_click,\n\t\twm_lbuttonup:\t\tmm_clickup,\n\t\twm_lbuttondblclk:\tmm_dblclick,\n\n\t\twm_rbuttondown:\t\tmm_rclick,\n\t\twm_rbuttonup:\t\tmm_rclickup,\n\t\twm_rbuttondblclk:\tmm_rdblclick,\n\n\t\twm_mbuttondown:\t\tmm_mclick,\n\t\twm_mbuttonup:\t\tmm_mclickup,\n\t\twm_mbuttondblclk:\tmm_mdblclick]\n\n!table gives button number 1,2,3 for Windows button message (always 0 for button up)\n\tbuttontable\t:= [\\\n\t\twm_lbuttondown:\t\t1,\n\t\twm_lbuttonup:\t\t0,\n\t\twm_lbuttondblclk:\t1,\n\n\t\twm_rbuttondown:\t\t2,\n\t\twm_rbuttonup:\t\t0,\n\t\twm_rbuttondblclk:\t2,\n\n\t\twm_mbuttondown:\t\t3,\n\t\twm_mbuttonup:\t\t0,\n\t\twm_mbuttondblclk:\t3]\n\n\tmousepos:=new(ws_point)\n\n\tsetmesshandler(process_wmmessage)\n!CPL =PROCESS_WMMESSAGE\n!setmesshandler(bill)\n\n\tvktomesstable:=[\\\n\t\tvkleft:\t\tmm_leftkey,\n\t\tvkright:\tmm_rightkey,\n\t\tvkup:\t\tmm_upkey,\n\t\tvkdown:\t\tmm_downkey,\n\t\tvkpageup:\tmm_pageupkey,\n\t\tvkpagedown:\tmm_pagedownkey,\n\t\tvkhome:\t\tmm_homekey,\n\t\tvkend:\t\tmm_endkey,\n\t\tvktab:\t\tmm_tabkey,\n\t\tvkbackspace:\tmm_bskey,\n\t\tvkdelete:\tmm_deletekey,\n\t\tvkenter:\tmm_enterkey,\n\t\tvkinsert:\tmm_insertkey,\n\t\tvkescape:\tmm_cancel\n\t]\nend\n\nexport func postmess(w,mess,a=0,b=0,c=0)=\n!add message m to end of message queue\n!use mess+1000 to add message to start of queue rather than the end\n\n\tif w=nil then w:=wapplic fi\n\tif w=nil then\n return 0 fi\n\n\tif w.flags.[wa_closed] then\n\n return 0 fi\n\n\tif mess>=1000 then\n\t\theadx:=1; mess-:=1000\n\telse\n\t\theadx:=0\n\tfi\n\n!check if new message can be combined with an old message\n\tcase mess\n\twhen mm_sethozpos,mm_setvertpos,mm_draw,mm_restore,mm_update then\n\t\tfor i:=1 to nmessages do\n\t\t\tm:=messagequeue[i].message\n\t\t\tif m=mess and w==messagequeue[i].wind then\t\t\t\t!use the old message but update any params\n\t\t\t\tmessagequeue[i].a:=a\n\t\t\t\tmessagequeue[i].b:=b\n\t\t\t\treturn 0\n\t\t\telsif mess=mm_draw and m=mm_update then\t\t!convert update to draw\n\t\t\t\tmessagequeue[i].message:=mm_draw\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tod\n\tesac\n\n\tif quitmess or nmessages>=maxqueuesize then\n\t\treturn 0\n\tfi\n\n\tpostmsg(makemess(w,mess,a,b,c))\n\n\treturn 0\t\t\t\t\t!return zero for use in mainwndproc\nend\n\nexport func postmsg(msg,headx=0)=\n!add complete message msg to end of message queue\n!use head=1 to add to start of queue rather than the end\n\n\tif quitmess or nmessages>=maxqueuesize then\n\t\treturn 0\n\tfi\n\n\tif msg.wind.flags.[wa_closed] then return 0 fi\n\n\tif headx then\n\n!avoid dupl paint messages\n\t\t++nmessages\n\t\tfor i:=nmessages downto 2 do\n\t\t\tmessagequeue[i]:=messagequeue[i-1]\n\t\tod\n\t\tmessagequeue[1]:=msg\n\n\telse\n\t\t++nmessages\n\t\tmessagequeue[nmessages]:=msg\n\tfi\n\n\treturn 0\t\t\t\t\t!return zero for use in mainwndproc\nend\n\nexport proc sendmess(w,mess,a=0,b=0,c=0)=\n!add message m to head of message queue\n!(may be 100% handled in q smlib)\n\n\tif w=nil then return fi\n\tif w.flags.[wa_closed] then return fi\n\n\tsendmsg(makemess(w,mess,a,b,c))\nend\n\nproc sendmsg(msg)=\n!call event handler for msg or add to head of queue\n\tif msg.wind.flags.[wa_closed] then return fi\n\tpostmsg(msg,1)\nend\n\nexport func makemess(w,mess,a=0,b=0,state=-1)=\n!turn params into a new messrec @nemm_ess\n!the q version makemess also accepts makemess(w,msg)\n\n\tif w=nil then w:=wapplic fi\n\n\tm:=new(rmessage,0)\n\n\tm.wind:=w\n\n\tm.message:=mess\n\tm.a:=a\n\tm.b:=b\n\tm.state:=state\n\n\tm.x:=mousepos.x\n\tm.y:=mousepos.y\n\n\tif m.state=-1 then m.state:=getshiftstate() fi\n\n\treturn m\nend\n\nfunc dokeymessage(hwnd,msg,wparam,lparam)=\n!return 1 if message has been dealt with\n\n\tcase msg\n\twhen wm_syskeydown then\n\t\tif wparam=vkf10 then msg:=wm_keydown; goto dokey fi\n\n\twhen wm_syskeyup then\n\t\tif wparam=vkf10 then msg:=wm_keyup; goto dokey fi\n\n\twhen wm_keydown,wm_keyup then\n\tdokey:\n\t\tcase wparam\n\t\twhen vkshift,vkctrl,vkalt,vkcapslock then\n\t\telse\n\t\t\tw:=wfocus\n!\t\tif not w then w:=wx_getw(hwnd) fi\n!CPL \"XXXXX\"\n\t\t\tif not w then w:=getwindow(hwnd)\n!CPL \"AFTER GW3\"\n fi\n!CPL =GETSHIFTSTATE()\n!\t\tpostmess(w,(msg=wm_keydown|mm_key|mm_keyup),wparam,getshiftstate(),lparam)\n\t\t\tpostmess(w,(msg=wm_keydown|mm_key|mm_keyup),wparam,lparam,-1)\n\t\t\treturn 1\n\t\tesac\n\tesac\n\treturn 0\nend\n\nfunc getshiftstate=\n\tstate:=0\n\n\tif getkeystate(vklshift) iand 0x8000 then state ior:=kb_shift fi\n\tif getkeystate(vklcontrol) iand 0x8000 then state ior:=kb_ctrl fi\n\tif getkeystate(vklalt) iand 0x8000 then state ior:=kb_alt fi\n\n\tif getkeystate(vkrshift) iand 0x8000 then state ior:=kb_rshift fi\n\tif getkeystate(vkrcontrol) iand 0x8000 then state ior:=kb_rctrl fi\n\tif getkeystate(vkralt) iand 0x8000 then\n\t\tstate ior:=kb_ralt\n\t\tstate iand:=(inot kb_ctrl)\t\t\t!AltGr gives Lctrl+Ralt; return Ralt only\n\tfi\n\tif getkeystate(vkcapslock) iand 1 then state ior:=kb_capslock fi\n\n\treturn state ior buttonstate\nend\n\nproc buttonmessages(hwnd,msg,wp,lp)=\n!process Windows mouse message <msg>\n\n!update button from wparam, excluding ctrl/shift (which are updated from key msgs)\n\tbuttonstate:=wp iand (kb_lbutton ior kb_rbutton ior kb_mbutton)\n\n!update mouse position\n\tmousepos.x:=lp iand 0xffff\n\tmousepos.y:=int(lp)>>16\n\twmouse:=getwindow(hwnd)\n!CPL \"AFTER GW4\"\n\n!set mousesw to last pressed button (1,2,3) or 0 if one just released\n!(note other buttons may still be down, used for drag processing)\n\tmousesw:=buttontable{msg}\n\n\tif mousesw then\t\t\t!down up on click or dblclick\n\t\tlastbuttontime:=gettickcount()\n\t\tlastmousepos::=mousepos\n\t\tlastmousewindow:=wmouse\n\telse\n\t\tmousesw:=0\n\n\t\tif dragmode then\n\t\t\tpostmess(lastmousewindow,mm_enddrag,0,0,-1)\n\t\t\tdragmode:=0\n\t\tfi\n\n\t\tlastbuttontime:=0\n\t\tlastmousewindow:=nil\n\tfi\n\n\tnewmess:=wmessagetable{msg}\n\n!filter double-click messages and convert to repeated click if not enabled\n\tcase newmess\n\twhen mm_dblclick then unless wmouse.flags.[wa_leftdbl] then newmess:=mm_click end\n\twhen mm_rdblclick then unless wmouse.flags.[wa_rightdbl] then newmess:=mm_click end\n\tesac\n\n\tpostmess(wmouse,newmess,wmouse.id,0,-1)\nend\n\nproc setnewmousewindow(w)=\n\treturn when not currmousewindow\n\tunless w==currmousewindow then\t\t!changed\n\t\tif currmousewindow<>nil then\n\t\t\tpostmess(currmousewindow,mm_offwindow,0,0,0)\n\t\tfi\n\n\t\tcurrmousewindow:=w\n\t\tpostmess(w,mm_onwindow,0,0,0)\n\tend unless\nend\n\nproc frame2rect(f,r)=\n\tr^.x:=f^.x\n\tr^.y:=f^.y\n\n\tr^.dimx:=f^.x2-f^.x1+1\n\tr^.dimy:=f^.y2-f^.y1+1\nend\n\nexport func mxwait_mm_message=\n\t#do windows dispatch loop\n\t#calling dispatchmessage() results in mainwndproc being called in interpreter,\n\t#which passes the Windows message params on to process_wmmessage() in this module\n\t#process_wmmessage() converts wm-messages to mpl mm-messages\n\t#return when at least one mm message is ready; (will return immediately if there\n\t#is already one in the queue)\n\t#return value is normall 1, or 0 when quitmess has been encountered\n\n\tif quitmess then\t\t\t\t!quit message already seen\nCPL \"-----------------QUITMESS SEEN\"\n\t\treturn 0\n\tfi\n\n\twindmsg:=new((iswin32|ws_msg32|ws_msg64))\n\n\twhile nmessages<=0 do\n\t\tif x:=getmessage(&windmsg,nil,0,0)<>0 then\n\t\t\tw:=windmsg.hwnd\n\t\t\ttranslatemessage(&windmsg)\n\t\t\tdispatchmessage(&windmsg)\n\t\telse\nCPL \"----GETMESSAGE RETURMS 0\"\n\t\t\tquitmess:=1\n\t\t\texit\n\t\tfi\n\tod\n\n\tif not nmessages then\t\t\t!assume quit message seen\nCPL \"----------NO MESSAGES\"\n\t\treturn 0\n\tfi\t\n\n\tcurrmess:=messagequeue[1]\n\t--nmessages\n\n\txlatkeyboard()\n\n\tfor i:=1 to nmessages do\n\t\tmessagequeue[i]:=messagequeue[i+1]\n\tod\n\treturn 1\nend\n\nproc xlatkeyboard=\n!expand any mm_key messages to special key messages\n!uses and modified currmess\n\tm:=currmess.message\n\n\tif m=mm_key then\n\n\t\tk:=currmess.a\n\t\tif k>=vkf1 and k<=vkf12 then\n\t\t\tnewmsg:=currmess\n\t\t\tcurrmess.message:=mm_functionkey\n\t\t\tcurrmess.a:=k-vkf1+1\n\t\telse\n\t\t\tkeymess:=vktomesstable{k,0}\n\t\t\tif keymess then\n\t\t\t\tcurrmess.message:=keymess\n\t\t\tfi\n\t\tfi\n\tfi\nend\n\nfunc getscreencoords(w,pos)=\n\tpt::=pos\n\tif not w then\n\t\tPCERROR(\"GSC/W=0\")\n\tfi\n\n\tclienttoscreen(w.gdi.hwnd,&pt)\t\t!pos starts at 0,0\n\treturn pt\nend\n\nexport func getwindow(hwnd)=\n!convert hwnd to window\n!return nil if any problem\n\tif hwnd=0 then\n\t\treturn nil\n\tfi\n\n\tindex:=wx_getw(hwnd)\n\tif index then\n\t\treturn allwindows[index]\n\tfi\n\treturn nil\nend\n\nproc initmenuhandlers=\n\tltcolour:=getrgb(ltgrey)\n\tdkcolour:=getrgb(dkgrey)\nend\n\nproc gxhandler_fixups=\n!do some manual fixups for various shared handlers\n!(the automatic fixup routine allows multiple window classes per message, but not\n! multiple message per window class)\n\tmesshandlertable[mm_startdrag,scrollbar_class]:=mess_drag_scrollbar\n\tmesshandlertable[mm_enddrag,scrollbar_class]:=mess_drag_scrollbar\n\tmesshandlertable[mm_leftkey,scrollbar_class]:=mess_upkey_scrollbar\nend\n\nfunc mess_all_all(mess,w)=\n!CPL \"MESSAA1\"\n\tcase mess.message\n\twhen mm_startdrag,mm_drag,mm_enddrag then\n\twhen mm_command then\n\twhen mm_ok,mm_cancel then\n\twhen mm_click then\n\t\tcase w.windclass\n\t\twhen label_class, group_class then\n\t\t\treturn skipmess\n\t\tesac\n\twhen mm_key then\n\twhen mm_sethozpos,mm_setvertpos then\n\twhen mm_pick,mm_lbchange then\n\twhen mm_leftkey,mm_rightkey,mm_upkey,mm_downkey,mm_enterkey,mm_tabkey then\n\twhen mm_pageupkey,mm_pagedownkey then\n\twhen mm_homekey, mm_endkey then\n\twhen mm_functionkey then\n\twhen mm_wheel then\n\twhen mm_edited then\n\telse\n!CPL \"MESSAA2\"\n\t\treturn skipmess\n\tesac\n!CPL \"MESSAA3\"\n\n\treturn thismess\nend\n\nfunc mess_restore_all(mess,w)=\n\tgxrestore(W)\n\n\treturn skipmess\nend\n\nfunc mess_killfocus_all(mess,w)=\n!note: can be called from mess_setfocus_all, with a different mess, but correct w\n!assume w is same as wfocus\n\n\tdrawcaret(0)\n\twfocus:=nil\n\n\treturn skipmess\nend\n\nfunc mess_setfocus_all(mess,w)=\n\tif wfocus then\n\t\tmess_killfocus_all(mess,wfocus)\n\tfi\n\n\twfocus:=w\n\tdrawcaret(1)\n\treturn skipmess\nend\n\nfunc mess_update_all(mess,w)=\n\tgxupdate(w)\n\treturn skipmess\nend\n\nfunc mess_draw_all(mess,w)=\n\tgxdraw(w)\n\treturn skipmess\nend\n\nfunc mess_click_select(mess,w)=\n\tif w.enable then\n\t\tif not w.style.noupdate then\n\t\t\tp:=w.linkvar\n\t\t\tp^:=w.attrs.onvalue\n\t\t\tfor wc in w.owner.childlist do\n\t\t\t\tif wc.windclass=select_class and wc.linkvar=p then\n\t\t\t\t\tgxdraw(wc)\n\t\t\t\tfi\n\t\t\tod\n\t\tfi\n\t\tif w.style.returnmess then\n\t\t\tpostmess(w,mm_command,w.id)\n\t\tfi\n\tfi\n\treturn skipmess\nend\n\nfunc mess_click_toggle(mess,w)=\n\tif w.enable then\n\t\tif not w.style.noupdate then\n\t\t\tw.linkvar^:=not w.linkvar^\n\t\t\tgxdraw(w)\n\t\tfi\n\t\tif w.style.returnmess then\n\t\t\tpostmess(w,mm_command,w.id)\n\t\tfi\n\tfi\n\treturn skipmess\nend\n\nfunc mess_click_button(mess,w)=\n\n\tif w.enable=0 then\n\t\tbeep1()\n\t\treturn skipmess\n\tfi\n\n\tif w.id in 0..199 then\t\t\t\t!speficies an actual message number (but no params)\n\t\tpostmess(w,w.id)\n\telse\n\t\tpostmess(w,mm_command,w.id)\n\tfi\n\treturn skipmess\nend\n\nfunc mess_click_editbox(mess,w)=\n\tif w.enable then\n\t\tif not w.style.noupdate then\n\t\t\tunless w==wfocus then\n\t\t\t\tgxfocus(w)\n\t\t\tend\n\t\tfi\n\t\tif w.style.returnmess then\n\t\t\tpostmess(w,mm_command,w.id)\n\t\tfi\n\tfi\n\n\treturn skipmess\nend\n\nfunc mess_click_arrow(mess,w)=\n\n\tcase w.owner.windclass\n\twhen scrollbar_class then\n\t\tpostmess(w.owner,dirtomess{w.style.dir},w.id,0,-1)\n\telse\n\t\tmess.message:=dirtomess{w.style.dir}\n\t\tmess.a:=w.id\n\t\treturn thismess\n\tesac\n\treturn skipmess\nend\n\nfunc mess_click_mark(mess,w)=\n\n\tcase w.owner.windclass\n\twhen toggle_class,select_class then\n\t\tpostmess(w.owner,mess.message,w.id,0,-1)\n\tesac\n\treturn skipmess\nend\n\nfunc mess_click_listbox(mess,w)=\n\tgxfocus(w)\n\n\ty:=max(w.attrs.offset,mess.y)\n\n\tpos:=(y-w.attrs.offset)%w.attrs.pitch+w.attrs.pagepos\n\tif pos<=getlvbounds(w.linkvar).len then\n\t\tgxsetlbpos(w,pos)\n\t\tpostmess(w,mm_pick,pos)\n\tfi\n\n\treturn skipmess\nend\n\nfunc mess_click_scrollbar(mess,w)=\n\tonthumb:=isonthumb(w,(w.style.dir='H'|mess.x|mess.y))\n\tstep:=w.attrs.span\n\ta:=w.attrs.currpos\n\n\tcase w.owner.windclass\n\twhen listbox_class then\n\t\tcase onthumb\n\t\twhen -1 then\n\t\t\tif a>w.attrs.limits.lwb then\n\t\t\t\ta:=max(a-step,w.attrs.limits.lwb)\n\t\t\t\tgxsetlbpage(w.owner,a)\n\t\t\tfi\n\t\twhen 1 then\n\t\t\tif a<w.attrs.limits.upb then\n\t\t\t\ta:=min(a+step,w.attrs.limits.upb)\n\t\t\t\tgxsetlbpage(w.owner,a)\n\t\t\tfi\n\t\tesac\n\telse\n\t\tif not step then step:=10 fi\n\n\t\tcase onthumb\n\t\twhen -1 then\n\t\t\tif a>w.attrs.limits.lwb then\n\t\t\t\ta:=max(a-step,w.attrs.limits.lwb)\n\t\t\t\tgxscrollpos(w,a,1)\n\t\t\t\tpostmess(w,mm_sethozpos,a)\n\t\t\tfi\n\t\twhen 1 then\n\t\t\tif a<w.attrs.limits.upb then\n\t\t\t\ta:=min(a+step,w.attrs.limits.upb)\n\t\t\t\tgxscrollpos(w,a,1)\n\t\t\t\tpostmess(w,mm_sethozpos,a)\n\t\t\tfi\n\t\tesac\n\tesac\n\treturn skipmess\nend\n\nfunc mess_wheel_scrollbar(mess,w)=\n\tdelta:=currmess.a\n\tn:=abs(currmess.a%120)\n\tto n do\n\t\tcase w.windclass\n\t\twhen scrollbar_class then\n\tdoscroll:\n\t\t\tpostmess(w,(delta>0|mm_up|mm_down))\n\t\twhen listbox_class then\n\t\t\tif w.childlist then\n\t\t\t\tw:=w.childlist[1]\n\t\t\t\tgoto doscroll\n\t\t\tfi\n\t\t\tpostmess(w,(delta>0|mm_upkey|mm_downkey))\n\t\tesac\n\tod\n\treturn skipmess\nend\n\nfunc mess_up_scrollbar(mess,w)=\n\ta:=w.attrs.currpos\n\tif a<=w.attrs.limits.lwb then\n\t\treturn skipmess\n\tfi\n\tcase w.owner.windclass\n\twhen listbox_class then\n\t\tgxsetlbpage(w.owner,a-1)\n\t\treturn skipmess\n\telse\n\t\t--a\n\t\tgxscrollpos(w,a,1)\n\t\tpostmess(w,mm_setvertpos,a)\n\tesac\n\treturn skipmess\nend\n\nfunc mess_left_scrollbar(mess,w)=\n\n\tcase w.owner.windclass\n\twhen listbox_class then\n\t\treturn skipmess\n\telse\n\t\ta:=w.attrs.currpos\n\t\tif a>w.attrs.limits.lwb then\n\t\t\t--a\n\t\t\tgxscrollpos(w,a,1)\n\t\t\tpostmess(w,mm_sethozpos,a)\n\t\tfi\n\tesac\n\treturn skipmess\nend\n\nfunc mess_right_scrollbar(mess,w)=\n\n\tcase w.owner.windclass\n\twhen listbox_class then\n\t\treturn skipmess\n\telse\n\t\ta:=w.attrs.currpos\n\t\tif a<w.attrs.limits.upb then\n\t\t\t++a\n\t\t\tgxscrollpos(w,a,1)\n\t\t\tpostmess(w,mm_sethozpos,a)\n\t\tfi\n\n\tesac\n\treturn skipmess\nend\n\nfunc mess_down_scrollbar(mess,w)=\n\n\ta:=w.attrs.currpos\n\tif a>=w.attrs.limits.upb then\n\t\treturn thismess\n\tfi\n\tcase w.owner.windclass\n\twhen listbox_class then\n\t\tgxsetlbpage(w.owner,a+1)\n\t\treturn skipmess\n\telse\n\t\t++a\n\t\tgxscrollpos(w,a,1)\n\t\tpostmess(w,mm_setvertpos,a)\n\n\tesac\n\treturn skipmess\nend\n\nfunc mess_drag_scrollbar(mess,w)=\n\tcase mess.message\n\twhen mm_startdrag then\n\t\tif isonthumb(w,(w.style.dir='H'|mess.x|mess.y))=0 then\n\t\t\tthumbdragmode:=1\t\t\t!then treat as mm_drag\n\t\t\tthumbstartpos:=w.attrs.thumbpos-arrowdim\t\t!use thumb pos at start of drag\n\t\telse\t\t\t\t\t\t\t!dragging other part of scrollbar\n\t\t\treturn skipmess\n\t\tfi\n\twhen mm_enddrag then\n\t\tthumbdragmode:=0\n\t\treturn skipmess\n\telsif not thumbdragmode then\n\t\treturn skipmess\n\tesac\n\n\toffset:=(w.style.dir='H'|mess.a|mess.b)\t\t!pixel offset from initial drag start pos\n\tnewpos:=thumbstartpos+offset\t\t\t\t\t\t!could outside thumb span range\n\n\tpos:=int(round((newpos/w.attrs.thumbspan)*(w.attrs.limits.len-1)+w.attrs.limits.lwb))\n\tpos:=clamp(pos,w.attrs.limits.lwb,w.attrs.limits.upb)\n\n\tcase w.owner.windclass\n\twhen listbox_class then\n\t\tgxsetlbpage(w.owner,pos)\n\telse\n\t\tgxscrollpos(w,pos,1)\n\t\tpostmess(w,(w.style.dir='H'|mm_sethozpos|mm_setvertpos),pos)\n\tesac\n\treturn skipmess\nend\n\nfunc mess_move_button(mess,w)=\n\treturn skipmess\nend\n\nfunc mess_move_all(mess,w)=\n\treturn skipmess\nend\n\nfunc mess_char_editbox(mess,w)=\n!\tSHOWMESSAGE(\"CHAREDIT\",MESS)\n\n\t\tif mess.a not in 32..255 then\n!\tcpl \"CHAR/EDIT2\",MESS.A,VKENTER\n\t\t\tcase mess.a\n\t\t\twhen vkenter then\n\t\t\t\tCPL \"ENTER\"\n\t\t\t\tm:=mm_edited\n\t\t\telse\n\t\t\t\tm:=mm_key\n\t\t\tesac\n\n\t\t\tif wapplic then\n!\tCPL \"CHAR/EDIT CONTROL\",=MESS.A,MESS.B\n\t\t\t\tpostmess(wapplic,m, mess.a,mess.b,mess.state)\n\t\t\tfi\n\t\t\treturn skipmess\n\t\tfi\n\t\tif not w.enable or w.style.noupdate then return skipmess fi\n\t\ts:=w.linkvar^\n\t\tn:=w.attrs.currpos\n\t\tc:=chr(mess.a)\n\n\t\tif n>s.len then\t\t\t\t!at end\n\t\t\ts+:=c\n\t\telsif n=1 then\t\t\t\t!at start\n\t\t\ts:=c+s\n\t\telse\t\t\t\t\t\t!in middle\n\t\t\ts:=leftstr(s,n-1)+c+rightstr(s,-(n-1))\n\t\tfi\n\n\t\tw.linkvar^:=s\n\t\t++w.attrs.currpos\n\t\tgxdraw(w)\n\n\t\treturn skipmess\nend\n\nfunc mess_key_editbox(mess,w)=\n!\tCPL \"KEY/EDITBOX\"\n\n\tpostmess(wapplic,mm_key,mess.a,mess.b,mess.state)\n\n\treturn skipmess\nend\n\nfunc mess_leftkey_editbox(mess,w)=\n\tif ctrlpressed() then\n\t\tpostmess(wapplic,mm_leftkey,mess.a,mess.b,mess.state)\n\t\treturn skipmess\n\tfi\n\n\tif w.attrs.currpos>1 then\n\t\tdrawcaret(0)\n\t\t--w.attrs.currpos\n\t\tdrawcaret(1)\n\tfi\n\treturn skipmess\nend\n\nfunc mess_rightkey_editbox(mess,w)=\n\tif ctrlpressed() then\n\t\tpostmess(wapplic,mm_rightkey,mess.a,mess.b,mess.state)\n\t\treturn skipmess\n\tfi\n\n\tif w.attrs.currpos<=w.linkvar^.len then\n\t\tdrawcaret(0)\n\t\t++w.attrs.currpos\n\t\tdrawcaret(1)\n\tfi\n\treturn skipmess\nend\n\nfunc mess_bskey_editbox(mess,w)=\n\ts:=w.linkvar^\n\tif not s then return skipmess fi\n\tn:=w.attrs.currpos\n\tif n=1 then return skipmess fi\n\n\tif n>s.len then\t\t\t\t!at end\n\t\ts:=leftstr(s,-1)\n\telse\t\t\t\t\t\t!in middle\n\t\ts:=leftstr(s,n-2)+rightstr(s,-(n-1))\n\tfi\n\n\tw.linkvar^:=s\n\t--w.attrs.currpos\n\tgxdraw(w)\n\n\treturn skipmess\nend\n\nfunc mess_deletekey_editbox(mess,w)=\n\ts:=w.linkvar^\n\tif not s then return skipmess fi\n\tn:=w.attrs.currpos\n\tif n>s.len then return skipmess fi\n\n\tif n=1 then\t\t\t\t!at start\n\t\ts:=rightstr(s,-1)\n\telse\t\t\t\t\t\t!in middle\n\t\ts:=leftstr(s,n-1)+rightstr(s,-n)\n\tfi\n\tw.linkvar^:=s\n\tgxdraw(w)\n\n\treturn skipmess\nend\n\nfunc mess_homekey_editbox(mess,w)=\n\tif ctrlpressed() then\n\t\tpostmess(wapplic,mm_homekey,mess.a,mess.b,mess.state)\n\t\treturn skipmess\n\tfi\n\n\tdrawcaret(0)\n\tw.attrs.currpos:=1\n\tdrawcaret(1)\n\n\treturn skipmess\nend\n\nfunc mess_homekey_listbox(mess,w)=\n\tif w.attrs.currpos>1 then\n\t\tgxsetlbpos(w,1)\n\tfi\n\n\treturn skipmess\nend\n\nfunc mess_endkey_editbox(mess,w)=\n\tif ctrlpressed() then\n\t\tpostmess(wapplic,mm_endkey,mess.a,mess.b,mess.state)\n\t\treturn skipmess\n\tfi\n\n\tdrawcaret(0)\n\tw.attrs.currpos:=w.linkvar^.len+1\n\tdrawcaret(1)\n\n\treturn skipmess\nend\n\nfunc mess_endkey_listbox(mess,w)=\n!if w.attrs.currpos<w.linkvar^.len then\n\tif w.attrs.currpos<getlvbounds(w.linkvar).len then\n!\tgxsetlbpos(w,w.linkvar^.len)\n\t\tgxsetlbpos(w,getlvbounds(w.linkvar).len)\n\tfi\n\n\treturn skipmess\nend\n\nfunc mess_upkey_listbox(mess,w)=\n\tif w.attrs.currpos>1 then\n\t\tgxsetlbpos(w,w.attrs.currpos-1)\n\tfi\n\n\treturn skipmess\nend\n\nfunc mess_upkey_scrollbar(mess,w)=\n!assume that this is independent scrollbar\n!(linked scrollbar wouldn't get the focus)\n\n\ta:=w.attrs.currpos\n\tif a>w.attrs.limits.lwb then\n\t\t--a\n\t\tgxscrollpos(w,a,1)\n\t\tpostmess(w,mm_setvertpos,a)\n\tfi\n\treturn skipmess\nend\n\nfunc mess_downkey_listbox(mess,w)=\n!if w.attrs.currpos<w.linkvar^.len then\n\tif w.attrs.currpos<getlvbounds(w.linkvar).len then\n\t\tgxsetlbpos(w,w.attrs.currpos+1)\n\tfi\n\n\treturn skipmess\nend\n\nfunc mess_pageupkey_listbox(mess,w)=\n\tif (a:=w.attrs.currpos)>1 then\n\t\ta:=max(a-w.attrs.rows,1)\n\t\tgxsetlbpos(w,a)\n\tfi\n\n\treturn skipmess\nend\n\nfunc mess_pagedownkey_listbox(mess,w)=\n\tif (a:=w.attrs.currpos)<getlvbounds(w.linkvar).len then\n\t\ta:=min(a+w.attrs.rows,getlvbounds(w.linkvar).len)\n\t\tgxsetlbpos(w,a)\n\tfi\n\n\treturn skipmess\nend\n\nfunc mess_enterkey_listbox(mess,w)=\n\tif w.attrs.currpos then\n\t\tpostmess(w,mm_pick,w.attrs.currpos)\n\tfi\n\n\treturn skipmess\nend\n\nproc do_draw_all(w)=\n\tgxclear(w)\n\tdrawborder(w)\n\tdrawchildborders(w)\nend\n\nproc do_draw_button(w)=\n\tgxclear(w)\n\n\tgxtext_just(w,w.text,0,w.enable)\n\n\tdrawborder(w)\n\nend\n\nproc do_draw_label(w)=\n\tdo_draw_button(w)\nend\n\nproc do_draw_toggle(w)=\n\tgxclear(w)\n\n\tVALSTR:=\"\"\n\n\tturnedon:=istrue w.linkvar^\n\n\tif w.style.marktype then\n\t\tdrawmark(w.childlist[1],turnedon,w.enable)\n\n\t\tgxtext_just(w,w.text+valstr,markdim,w.enable)\n\telse\n!\tcase w.style.hilitetype\n!\twhen invert_hilite then\n\t\t\tif turnedon then\n\t\t\t\tgxclear(w,getrgb(green))\n\t\t\tfi\n!\tesac\n\n\t\tgxtext_just(w,w.text+valstr)\n\tfi\nend\n\nproc do_draw_select(w)=\n\tgxclear(w)\n\n\tturnedon:=w.linkvar^=w.attrs.onvalue\n\n\tif w.style.marktype then\n\t\tdrawmark(w.childlist[1],turnedon,w.enable)\n\t\tgxtext_just(w,w.text,markdim,w.enable)\n\telse\n\t\tcase w.style.hilitetype\n\t\twhen invert_hilite then\n\t\t\tif turnedon then\n\t\t\t\tgxclear(w,getrgb(white))\n\t\t\tfi\n\t\tesac\n\t\t\tgxtext_just(w,w.text)\n\tfi\nend\n\nproc do_draw_editbox(w)=\n\tgxclear(w)\n\n\tgxtext_just(w,w.linkvar^,enable:w.enable)\n\n!Now, have to draw the cursor\n\tunless wfocus==w then\t\t\t!only draw it when this window has the focus\n\t\treturn\n\tend\n\n\tcaretdrawn:=0\n\n\tdrawcaret(1)\nend\n\nproc do_draw_arrow(w)=\n\tgxclear(w)\n\n\tdrawborder(w)\n\tdrawarrow(w,w.enable)\nend\n\nproc do_draw_mark(w)=\n\n\tcase w.owner.windclass\n\twhen toggle_class, select_class then\n\t\treturn\t\t\t\t\t!mark drawn by owner\n\tesac\n\n\tgxclear(w,getrgb(w.owner.style.windbgnd))\n\n\tdrawborder(w)\nend\n\nproc do_draw_scrollbar(w)=\n\tgxclear(w)\n\tdrawborder(w)\n\tgxdraw(w.childlist[1])\t\t\t!arrows\n\tgxdraw(w.childlist[2])\n\n!now draw the thumb\n\tif w.attrs.thumbsize then\n\t\tif w.style.dir='H' then\n\t\t\tx:=w.attrs.thumbpos\n\t\t\tdx:=w.attrs.thumbsize\n\t\t\tdrawthumb(w,x,0,dx,w.dimy)\n\t\telse\n\t\t\ty:=w.attrs.thumbpos\n\t\t\tdy:=w.attrs.thumbsize\n\t\t\tdrawthumb(w,0,y,w.dimx,dy)\n\t\tfi\n\tfi\nend\n\nproc do_draw_listbox(w)=\n\tgxclear(w)\n\tdrawborder(w)\n\tif w.childlist then\t\t\t!scrollbar\n\t\tgxdraw(w.childlist[1])\n\tfi\n\n\tfor i:=1 to w.attrs.rows do\n\t\tk:=i+w.attrs.pagepos-1\n\t\tif k<=getlvbounds(w.linkvar).len then\n\t\t\tdrawlbtext(w,i,getlvstritem(w.linkvar,k),0,k=w.attrs.currpos)\n\t\tfi\n\tod\nend\n\nproc do_update_all(w)=\n\tgxdraw(w)\nend\n\nproc do_update_listbox(w)=\n\tgxdraw(w)\nend\n\nproc drawcaret(x)=\n!x=1: draw caret in wfocus window at current position\n!x=0: delete caret in wsfocus window\n!returns x-pixel position of caret\n\n\tif wfocus=nil then\t\t!no window has focus\n\t\tcaretdrawn:=0\n\t\treturn\n\tfi\n\n\tcase wfocus.windclass\n\twhen editbox_class then\n\t\tif x then\t\t\t!new caret\n\t\t\tif caretdrawn then return fi\t!already drawn\n\t\t\txpos:=getcaretpos(wfocus.linkvar^,wfocus.attrs.currpos,0)\n\t\t\twfocus.attrs.caretpos:=xpos\t\t\t!record position\n\t\telse\t\t\t!delete caret\n\t\t\tif not caretdrawn then return fi\t!already deleted\n\t\t\txpos:=wfocus.attrs.caretpos\t\t!use stored value\n\t\tfi\n\n\t\tcaretwidth:=2\n\n\t\tgxhighlight(wfocus,xpos+wfocus.attrs.textpos[1],wfocus.attrs.textpos[2]-chd,caretwidth,20)\n\n\t\tcaretdrawn:=x\n\tesac\nend\n\nfunc getcaretpos(s,pos,offset)=\n!return pixel position of in front of pos'th character in string s\n!offset is no. of chars not shown, to left of string\n\tif pos=1 then return 0 fi\n\n\treturn wx_gettextwidth(wfocus.gdi.hdc, leftstr(s,pos-1))\nend\n\nproc drawborder(w)=\n!do own-drawn borders\n!other kinds of borders are windows-drawn, no-border, and the main bs- style\n!borders which exist in the owner's client area\n!for own-drawn borders, the window should have been cleared first\n\n\tcase bscat[w.style.border]\n\twhen 0 then\t\t\t\t\t!no border\n\t\treturn\n\twhen 'W' then\t\t\t\t!windows-drawn\n\t\treturn\n\twhen 'X' then\t\t\t\t!external (drawn in owner's client space\n\t\tposx:=w.frameposx\n\t\tposy:=w.frameposy\n\t\tdimx:=w.framedimx\n\t\tdimy:=w.framedimy\n\t\tbs:=w.style.border\n\n\t\tbs:=w.style.border\n\t\two:=w.owner\n\t\tcase bs\n\t\twhen bs_simple then\t\t\t!USUALLY BS_SIMPLE converts to BS_WINDOWS; must be override\n\t\t\tgxcolour(wo,0)\n\t\t\tgxrect(wo,posx,posy,dimx,dimy)\n\t\twhen bs_thick then\n\t\twhen bs_panel then\n\t\t\tgxcolour(wo,ltcolour)\n\t\t\tgxline(wo,posx+dimx-1,posy, posx,posy)\n\t\t\tgxline(wo,posx,posy+dimy-1)\n\t\t\tgxcolour(wo,dkcolour)\n\t\t\tgxline(wo,posx+dimx-1,posy+dimy-1)\n\t\t\tgxline(wo,posx+dimx-1,posy)\n\t\twhen bs_inset then\n\t\t\tgxcolour(wo,dkcolour)\n\t\t\tgxline(wo,posx+dimx-1,posy, posx,posy)\n\t\t\tgxline(wo,posx,posy+dimy-1)\n\t\t\tgxcolour(wo,ltcolour)\n\t\t\tgxline(wo,posx+dimx-1,posy+dimy-1)\n\t\t\tgxline(wo,posx+dimx-1,posy)\n\t\twhen bs_testext then\n\t\t\tgxcolour(wo,0)\n\t\t\tgxrect(wo,posx,posy,dimx,dimy)\n\t\t\tgxrect(wo,posx+9,posy+9,dimx-18,dimy-18)\n\t\tesac\n\twhen 'I' then\t\t\t\t!internal (drawn within window's client space\n\t\tposx:=w.frameposx\n\t\tposy:=w.frameposy\n\t\tdimx:=w.dimx\n\t\tdimy:=w.dimy\n\n\t\tcase w.style.border\n\t\twhen bs_ownpanel then\n\t\t\tgxcolour(w,ltcolour)\n\t\t\tgxline(w,w.framedimx-1,0,0,0)\n\t\t\tgxline(w,0,w.framedimy-1)\n\t\t\tgxcolour(w,dkcolour)\n\t\t\tgxline(w,w.framedimx-1,w.framedimy-1)\n\t\t\tgxline(w,w.framedimx-1,0)\n\n\t\twhen bs_owninset then\n\t\t\tgxcolour(w,dkcolour)\n\t\t\tgxline(w,w.framedimx-1,0,0,0)\n\t\t\tgxline(w,0,w.framedimy-1)\n\t\t\tgxcolour(w,ltcolour)\n\t\t\tgxline(w,w.framedimx-1,w.framedimy-1)\n\t\t\tgxline(w,w.framedimx-1,0)\n\t\twhen bs_ownsimple then\n\t\t\tgxcolour(w,0)\n\t\t\tgxrect(w,0,0,w.framedimx,w.framedimy)\n\t\twhen bs_testint then\n\t\t\tgxcolour(w,0)\n\t\t\tgxrect(w,0,0,dimx,dimy)\n\t\t\tgxrect(w,7,7,dimx-14,dimy-14)\n\t\tesac\n\tesac\nend\n\nproc drawchildborders(w)=\n\tif not w.childlist then\n\t\treturn\n\tfi\n\tfor wc in w.childlist do\n\t\tif wc.style.border in [bs_simple,bs_thick,bs_panel,bs_inset] then\n\t\t\tdrawborder(wc)\n\t\tfi\n\tod\nend\n\nproc drawarrow(w,enable)=\n!w has already been cleared\n!e=1/omitted to enable, 0 to disable (shown grey)\n\tconst factor=0.3\n\n\tgxsetpen(w,(enable|black|dkgrey))\n\n\twidth:=w.dimx\n\theight:=w.dimy\n\n\tcase w.style.dir\n\twhen 'D' then\n\t\tx:=int(round(width/2)-1)\n\n\t\twd:=0\n\n\t\th:=int(round(min(height,width)*factor))\n\t\tif h<3 then h:=3 fi\n\t\ty:=int((height+h)*0.5)-1\n\n\t\tto h do\n\t\t\tgxline(w,x,y,x+wd,y)\n\t\t\tx-:=1\n\t\t\ty-:=1\n\t\t\twd+:=2\n\t\tod\n\n\twhen 'U' then\n\t\tx:=int(round(width/2)-1)\n\t\twd:=0\n\n\t\th:=int(round(min(height,width)*factor))\n\t\tif h<3 then h:=3 fi\n\t\ty:=int(round((height-h)*0.5))\n\t\tto h do\n\t\t\tgxline(w,x,y,x+wd,y)\n\t\t\tx-:=1\n\t\t\ty+:=1\n\t\t\twd+:=2\n\t\tod\n\n\twhen 'L' then\n\t\ty:=height%2\n\n\t\tht:=0\n\t\twd:=y\n\n\t\twd:=int(round(min(height,width)*factor))\n\t\tif wd<3 then wd:=3 fi\n\t\tx:=int(round((width-wd)*0.5)-1)\n\n\t\tto wd do\n\t\t\tgxline(w,x,y,x,y+ht)\n\t\t\ty-:=1\n\t\t\tx+:=1\n\t\t\tht+:=2\n\t\tod\n\n\twhen 'R' then\n\t\ty:=height%2\n\t\tht:=0\n\n\t\twd:=int(round(min(height,width)*factor))\n\t\tif wd<3 then wd:=3 fi\n\t\tx:=int(round((width+wd)*0.5)-1)\n\n\t\tto wd do\n\t\t\tgxline(w,x,y,x,y+ht)\n\t\t\ty-:=1\n\t\t\tx-:=1\n\t\t\tht+:=2\n\t\tod\n\tesac\nend\n\nexport proc gxtext_just(w,s,offset=0,enable=1)=\n\t\tdimx:=w.dimx\n\t\tdimy:=w.dimy\n\t\twidth:=wx_gettextwidth(w.gdi.hdc, s)\n\t\theight:=chy\t\t\t\t!assume basic font\n\n\t\tcase w.style.justify\n\t\twhen 'L' then\tx:=smx\n\t\twhen 'R' then\tx:=dimx-width-smx\n\t\telse\n\t\t\t\t\tx:=(dimx-width)%2\n\t\tesac\n\n\t\tcase w.style.vjustify\n\t\twhen 'T' then\ty:=smy\n\t\twhen 'B' then\ty:=dimy-height-smy\n\t\telse\n\t\t\t\t\ty:=(dimy-height)%2!\t\t-smy%2\n\t\tesac\n\n\t\tif not enable then\n\t\t\toldtextfgnd:=w.style.textfgnd\n\t\t\tgxtextcolour(w,grey)\n\t\tfi\n\n\t\tgxtext(w,s,x+offset,y)\n\n\t\tif not enable then\n\t\t\tgxtextcolour(w,oldtextfgnd)\n\t\tfi\n\t\tif w.windclass=editbox_class then\n\t\t\tw.attrs.textpos:=(x+offset,y)\n\t\tfi\nend\n\nproc drawthumb(w,x,y,dx,dy)=\n!w is a scrollbar, vert or hoz\n!draw thumb within w, as a simple rectangle starting at x,y at top left of size dx,dy\n\n\tgxcolour(w,0)\n\tgxrect(w,x,y,dx,dy)\n\tgxfillrect(w,x+1,y+1,dx-2,dy-2,getrgb(grey))\nend\n\nfunc isonthumb(w,d)=\n!w is a scrollbar, d is a pixel position along it (0 being at left or top)\n!return:\n! -1\tis before the thumb\n!  0\tis on the thumb\n! +1\tif after the thumb\n!d can specify a spot off the thumbar if being dragged\n\n\ta:=w.attrs.thumbpos\n\tb:=w.attrs.thumbsize\n\n\tif d<a then\n\t\treturn -1\n\telsif d>(a+b) then\n\t\treturn 1\n\telse\n\t\treturn 0\n\tfi\nend\n\nproc drawmark(w,turnedon,enable)=\n!!w has already been cleared\n!draw checked check mark, tick, or radio button, according to whether\n!turnedon is 1 or 0\n!e=1 to enable, 0 to disable (shown grey)\n\n\tgxclear(w,getrgb(w.owner.style.windbgnd))\n\tgxsetpen(w,(enable|black|red))\n\n\twidth:=w.dimx\n\theight:=w.dimy\n\tx:=y:=1\n\twd:=width-2\n\tht:=height-2\n\tgxrect(w,x,y,wd,ht)\n\tif not turnedon then return fi\n\n\tcase w.style.marktype\n\twhen radio_mark then\n\n\t\tgxfillrect(w,x+3,y+3,wd-6,ht-6,getrgb(red))\n\n\twhen check_mark then\n\n\t\tgxline(w,x,y,x+wd-1,y+ht-1)\n\t\tgxline(w,x+wd-1,y,x,y+ht-1)\n\n\twhen tick_mark then\n\n\t\tgxline(w,x+3,y+ht%2,x+wd%2,y+ht-4)\n\t\tgxline(w,x+wd-3,y+2)\n\n\tesac\nend\n\nproc drawlbtext(w,row,text,clr=0,hilite=0)=\n!draw text inside given row of listbox w\n!clr=1 to clear the background first (not needed when entired lb has been cleared)\n!hilite=1 to highlight this row\n\n\tx:=0\n\ty:=(row-1)*w.attrs.pitch+w.attrs.offset\n\n\tif clr or hilite then\n\t\tgxfillrect(w,x,y,w.dimx,w.attrs.pitch,(hilite|getrgb(grey)|getrgb(w.style.windbgnd)))\n\tfi\n\n\tif hilite then\n\t\toldtextcolour:=gxtextcolour(w)\n\t\tgxtextcolour(w,white)\n\tfi\n!RETURN\n\n\tgxtext(w,text,x+smx,y+smy)\n\tif hilite then\n\t\tgxtextcolour(w,oldtextcolour)\n\tfi\nend\n\nfunc readnextitem(a)=\n!return (level,value,labelx,options)\n!special values used for divider, new column, new menu\n!next line of file should already have been read\n\n\tif a=\"\" then return list(0,0,0,0) fi\n\n\tlevel:=1\n\ttabs:=0\n\toptions:=\"\"\n\n\twhile asc(a) in [9,' '] do tabs+:=1; a:=rightstr(a,-1) od\n\n\tif a=\"\" then return list(0,0,0,0) fi\n\n\tcase asc(a)\n\twhen '!' then\n\t\treturn list(0,0,0,0)\n\tesac\n\n\tif tabs then\n\t\tj:=0\n\t\tfor i:=1 to ntab do\n\t\t\tif tabs=tabstack[i] then j:=i; exit fi\n\t\tod\n\n\t\tif j=0 then\n\t\t\tif tabs>tabstack[ntab] then\n\t\t\t\tntab+:=1\n\t\t\t\ttabstack[ntab]:=tabs\n\t\t\tfi\n\t\t\tlevel:=ntab\n\t\telse\n\t\t\tlevel:=j\n\t\t\tif j<ntab then ntab:=j fi\n\t\tfi\n\tfi\n\n\tif asc(a) in ['0'..'9'] then\n\t\tvalue:=strtoval(a)\n\t\tn:=\" \" inx a\n\t\tif not n.isfound then\n\t\t\tn:=chr(9) in a\n\t\tfi\n\t\tif n.isfound then\n\t\t\tlabelx:=rightstr(a,-n)\n\t\telse\n\t\t\tlabelx:=\"?\"\n\t\tfi\n\n\telse\t\t\t!no preceding number, maybe top-level menu\n\n\t\tif \"=\" in a then\t!command def for mpl\n\t\t\treturn (0,0,0,0)\n\t\tfi\n\n\t\tvalue:=k_menu\n\t\tlabelx:=a\n\t\tcase convlc(labelx)\n\t\twhen \"hozbreak\",\"divider\" then\n\t\t\tvalue:=kdivide\n\t\twhen \"vertbreak\" then\n\t\t\tvalue:=kcolumn\n\t\twhen \"filehistory\" then\n\t\t\tvalue:=kfilehistory\n\t\telse\n\t\t\tif leftstr(labelx)=\"-\" then value:=kdivide fi\n\t\tesac\n\tfi\n\n\tif labelx=\"\" then\t\t\t!maybe [cmd] only\n\t\treturn list(0,0,0,0)\n\tfi\n\n\treturn (level,value,(labelx),options)\nend\n\nfunc readmenu(m,n,level)=\n!starting at index n in data, read all following items that are\n!at lower level (ie. higher level number) than given level\n!insert items into menu handle m\n!return index of next item in data, which is at <level> or higher\n!will stop at end of data, and return ndata+1\n\n\trestartx:\n\tfor i:=n to ndata do\n\t\t(l,value,labelx,options):=data[i]\n\n\t\tif l<=level then\t\t!end of this submenu\n\t\t\treturn i\n\t\tfi\n\n\t\tflags:=breakflag\n\t\tenable:=1\n\t\tif rightstr(labelx)=\"?\" then\n\t\t\tenable:=0\n\t\t\tlabelx:=leftstr(labelx,-1)\n\t\tfi\n\n\t\tif options<>\"\" then\n\t\t\tif \"H\" in options then flags+:=\"h\" fi\n\t\t\tif \"C\" in options then flags+:=\"c\" fi\n\t\tfi\n\n\t\tcase value\n\t\twhen kdivide then\n\t\t\tgxaddmb(m,style:\"d\")\n\t\twhen kcolumn then\n\t\t\tbreakflag:=\"v\"\n\t\twhen k_menu then\t\t!submenu\n\t\t\tnewm:=gxcreatemb()\n\t\t\tn:=readmenu(newm,i+1,l)\n\t\t\tgxaddmb(m,labelx,newm,\"p\"+flags,enable)\n\t\t\tbreakflag:=\"\"\n\t\t\tgoto restartx\n\t\twhen kfilehistory then\n\t\t\tnfiles:=8\n\t\t\tgxaddmb(m,\"filehistory\",1060,breakflag)\n\t\telse\t\t\t\t!ordinary command\n\tnormalcmd:\n\t\t\tgxaddmb(m,labelx,value,flags,enable)\n\t\t\tbreakflag:=\"\"\n\t\tesac\n\n\tskip:\n\tod\n\n\treturn ndata+1\t\t\t!eod reached\nend\n\nfunc mbreaddata(a)=\n!a is a list of tab-indented strings for a menu bar\n!a can also be a text file containing the strings\n\n\ttabstack::=(0,)\n\tntab:=1\n\tdata::=()\n\tndata:=0\n\tbreakflag:=\"\"\n\n\tif a.isstring then\t\t!read from file\n\t\ta:=readtextfile(a)\n\t\tif a=0 then\n\t\t\ta:=(\"CANTOPENFILE\",)\n\t\tfi\n\tfi\n\n\tfor i:=1 to a.upb do\n\t\tx:=readnextitem(a[i])\n\n\t\tif x[1] then\n\t\t\t++ndata\n\t\t\tdata[ndata]:=x\n\t\tfi\n\tod\n\n\tm:=gxcreatemb()\n\treadmenu(m,1,0)\n\treturn m\nend\n\nexport func gxmenubar(w,?a)=\n!called as:\n!\tgxmenubar(a):\tcreate standalone menu; return handle\n!\tgxmenubar(w,a):\tadd menu to windows w (returns 0)\n!a:\n!\tstring:\t\t\tassume this is a filename containing menubar tabbed layout\n!\tlist:\t\t\ta list of strings containing the data\n\n\tif a.defined then\t\t!w,m: read menu into window w\n\t\tm:=mbreaddata(a)\n\n\t\tif not w.ispointer then\n\t\t\twhile w.owner<>nil do\n\t\t\t\tw:=w.owner\n\t\t\tod\n\t\tfi\n\n\t\tgxsetmb(w,m)\n\t\treturn 0\n\telse\t\t\t\t!create standalone menu, return handle\n\t\treturn mbreaddata(w)\n\tfi\nend\n\nfunc gxcreatemb(?s)=\n\tif s.defined and s in \"Pp\" then\n\t\treturn createpopupmenu()\n\telse\n\t\treturn createmenu()\n\tfi\nend\n\nproc gxsetmb(w,m)=\n\n\thwnd:=w.gdi.hwnd\n\ta:=getmenu(hwnd)\n\ts:=setmenu(hwnd,m)\n\tif a then destroymenu(a) fi\nend\n\nfunc gxaddmb(wm,caption=\"X\",id=0,style=\"\",enable=0)=\n\n\tif wm.ispointer then\t\t\t\t!assume handle\n\t\thmenu:=wm\n\t\twm:=nil\n\telse\n\t\thmenu:=getmenu(wm.gdi.hwnd)\n\tfi\n\n\tflags:=mf_string ior mf_unchecked\n\n\tif not enable then flags ior:=mf_greyed fi\n\n\tforeach c in convuc(style) do\n\t\tcase c\n\t\twhen 0 then exit\n\t\twhen 'P' then flags ior:=mf_popup\n\t\twhen 'D' then flags ior:=mf_separator\n\t\twhen 'B' then flags ior:=mf_menubreak\n\t\twhen 'V' then flags ior:=mf_menubarbreak\n\t\twhen 'H' then flags ior:=mf_help\n\t\twhen 'C' then flags ior:=mf_checked\n\t\tesac\n\tod\n\n\tif appendmenu(hmenu,flags,id,caption) then\n\t\tif wm<>nil then drawmenubar(wm.gdi.hwnd) fi\n\t\treturn hmenu\n\tfi\n\treturn 0\nend\n\nproc gxshowmb(wm,w,x,y)=\n!update menu associated with window; call this func if it has been updated\n!when wm is a menu handle, draw the popup on the screen at x,y\n!if wm.isint then\n\tif wm.ispointer then\n\n\t\tif not y.defined then\n\t\t\tx:=w\n\t\t\ty:=x\n\t\t\tw:=nil\n\t\t\thwnd:=wapplic.gdi.hwnd\n\t\telse\n\t\t\thwnd:=w.gdi.hwnd\n\t\tfi\n\n\t\tpos:=ws_point(x,y)\n\n\t\tif w<>nil then\n\t\t\tclienttoscreen(w.gdi.hwnd,&pos)\n\t\tfi\n\n\t\ttrackpopupmenu(wm,0,pos.x,pos.y,0,hwnd,0)\n\telse\n\t\tdrawmenubar(wm.gdi.hwnd)\n\tfi\nend\n\nfunc gxenablemb(wm,id,enable)=\n\n\tif wm.ispointer then\t\t\t\t!assume handle\n\t\thmenu:=wm\n\telse\n\t\thmenu:=getmenu(wm.gdi.hwnd)\n\tfi\n\n\tif enable.defined then\n\t\treturn enablemenuitem(hmenu,id,(enable|0|mf_greyed)+mf_bycommand)\n\telse\n\t\treturn (getmenustate(hmenu,id,mf_bycommand) iand mf_greyed|0|1)\n\tfi\nend\n\nfunc gxcheckmb(wm,id,check)=\n\tif wm.ispointer then\t\t\t\t!assume handle\n\t\thmenu:=wm\n\telse\n\t\thmenu:=getmenu(wm.gdi.hwnd)\n\tfi\n\n\tif check.defined then\n\t\treturn checkmenuitem(hmenu,id,(check|mf_checked|mf_unchecked)+mf_bycommand)\n\telse\n\t\treturn (getmenustate(hmenu,id,mf_bycommand) iand mf_checked|1|0)\n\tfi\nend\n\nproc gxclosemb(m)=\n\tdestroymenu(m)\nend\n\nexport func gxconfirm(m)=\n\tx:=gxmsgbox(m,\"Confirm\",\"byn\")\n\treturn x=\"yes\"\nend\n\nfunc issubwindow(w,w2)=\n\twhile w2 do\n\t\tif w2==w then return 1 fi\n\t\tw2:=w2.owner\n\tod\n\treturn 0\nend\n\nexport proc flushmessages=\n\nend\n\nPROC CHECKWIND(W, NAME)=\n\tIF W=NIL THEN RETURN FI\n\tIF W.NAME=NAME THEN\n\t\tCPL \"CHECKWIND MATCHES****************\"\n\tFI\nEND\n\nEXPORT PROC CHECKCLOSED(NAME)=\n!CPL \"CC:\",=NAME\n!CPL \"CC:\",=CURRMESS.WIND\n\n\tCHECKWIND(CURRMESS.WIND,NAME)\n\tCHECKWIND(WFOCUS,NAME)\n\n\tfor w in allwindows do\n\t\tcheckwind(w, name)\n!CPL =W\n!CPL =W.CHILDLIST.TYPE\n\t\tif w then\n\t\tfor wc in w.childlist do\n\t\t\tcheckwind(wc, name)\n\t\tod\n\t\tfi\n\tod\n\n\tfor i to nmessages do\n\t\tm:=messagequeue[i]\n\t\tcheckwind(m.wind,name)\n\tod\n\n\tCPL \"CC: OK*****\"\nEND\n",
(u64)"VAR DEBUG=0\n\nimportdll imglib =\n    func imgload_rgb\t\t(stringz, ref byte, ref byte, ref byte, i32)ref byte\n\n    func imgload_bgr\t\t(stringz, ref i32, ref i32, ref i32, i32)ref byte\n\n!    func nanoloadjpeg\t\t(stringz, ref i32, ref i32, ref i32)ref byte\n!    func loadjpegm\t\t\t(stringz, ref i64, ref i64, ref i64)ref byte\n\n    proc          imgload_free\t\t(ref byte)\n    func imgsave_jpeg_rgb\t(stringz, ref byte, i32, i32, i32)i32\n    func imgsave_jpeg_bgr\t(stringz, ref byte, i32, i32, i32)i32\nend\n\nimportdll jpeg =\n    func loadjpegm\t\t\t(stringz, ref i64, ref i64, ref i64)ref byte\nend\n\ntype bmpheader = struct\n\tws_bitmapfileheader fh\n\tws_bitmapinfoheader bh\nend\n\nvar\tshifts=[2:1, 4:2, 8:3, 16:4, 32:5, 64:6]\n\nproc main=\n\n!\tCPL \"TESTING BMMAIN NEW\"\n!\tFILE:=\"C:/JPEG/girl.jpg\"\n!\tFILE:=\"C:/JPEG/girl.png\"\n!\tFILE:=\"C:/JPEG/fifteen.png\"\n\tFILE:=\"C:/JPEG/CARD2.jpg\"\n!\tFILE:=\"C:/JPEG/MONA.jpg\"\n!\n\tBM:=BMLOAD(FILE)\n!\tCPL =BM.TYPE\n!\tCPL =BM\n!\tIF NOT BM THEN STOP FI\n!\n!\tBMSAVE(\"freddy.jpg\", BM)\n!\n\n!\tw:=640\n!\th:=480\n!\tw:=640\n!\th:=48\n!\n!\tbm:=bmcreate(8,w,h)\n!!\tgxclear(bm, 0xFF7FFF)\n!\n!\tgxtext(bm,\"Hello, World\")\n!\tfor y:=0 to h-1 do\n!\t\tfor x:=0 to w-1 do\n!\t\t\tc:=0x00'FF'00\n!!\t\t\tgxpixel(bm,x,y,c<<16+c<<8+c)\n!\t\t\tgxpixel(bm,x,y,c)\n!\t\tod\n!\tod\n!\t\n\n!\tbm2:=bmtopal(bm)\n!\tbm2:=bmrgb24torgb32(bm)\n!\tbm2:=bmtogrey(bm,8)\n!\tbm2:=bmtogrey(bm,24)\n!\tbm2:=bmdupl(bm)\n\n!BM2.PALTYPE:=COLOUR_PAL\n!BMRESETPALETTE(BM2)\n!CPL =BM2.PIXELBITS\n!\tBMSAVE(\"PALA.PPM\",BM2)\n!\tBMSAVE(\"FRED.bmp\",BM2)\n!\tBMSAVE(\"PALB.PPM\",BM2,1)\n\n\n!\tCPL \"LOADED\"\n!\tSTOP\n\n\tw:=GXCREATEWINDOW(DIM:(1800,700),caption:\"HI THERE\")\n\tgxcopy(w,bm)\n!\tgxcopy(w,bm,scalex:0.5)\n!\tgxcopy(w,bm,scalex:5.0, x:100)\n!\tgxcopy(w,bm,scalex:2.0, x:100)\n!\tgxcopy(w,bm)\n!T:=clock()\n!to 100 do\n!\tgxcopy(w,bm)\n!od\nglobal const srccopy =  13369376\n\n!CPL =SRCCOPY\n\tbitblt(w.gdi.hdc, 0, 0, 500,300,\n\t\t\t\tw.gdi.hdc,0,0,srccopy)\n\n\n!\tgxcopy(w,bm)\n!\tgxcopy(w,bm)\n!\tgxcopy(w,bm)\n!\tgxcopy(w,bm)\n!cpl =clock()-t\n!WAITKEY()\n\teventloop()\n\nend\n\nexport func bmcreate(pixelbits,width,height)=\n!create new bitmap with given specs, return handle to bitmap (=rwindow ref)\n!when maskptr<>nil, set up mask values\n\n\tbminfo:=new(ws_bitmapv5header)\n\tbminfo.size:=ws_bitmapv5header.bytes\n\tbminfo.width:=width\n\tbminfo.height:=-height\n\tbminfo.planes:=1\n\tbminfo.bitcount:=pixelbits\n\n\tpixelptr:=nil\n\n\tif pixelbits not in [8,24,32] then\n\t\tabort(\"bmcreate pixel size not supported:\"+tostr(pixelbits))\n\tfi\n\n!\thwnd:=createdibsection(screendc,&bminfo,0,&pixelptr,0,0)\n\n!CPL =BMINFO.BYTES\n!CPL =WS_BITMAPV5HEADER.BYTES\n!CPL =BMINFO.SIZE\n!CPL =BMINFO.WIDTH\n!CPL =BMINFO.HEIGHT\n!CPL =BMINFO.PLANES\n!CPL =BMINFO.BITCOUNT\n\n\thwnd:=createdibsection(nil,&bminfo,0,&pixelptr,nil,0)\n\n\tpixelptr:=makeref(pixelptr,byte)\n\n\tif hwnd=0 then\n\t\terror:=getlasterror()\n\t\tabort(\"bmcreate:CreateDIB failed:\"+tostr(error))\n\tfi\n\n!now create a bm record based around this handle\n\n\tbm:=new(rwindow,0)\n\tbm.windclass:=bitmap_class\n\n\tbm.dimx:=width\n\tbm.dimy:=abs(height)\t\t!neg height used for top-down bitmaps\n\n\tbm.style:=defstyle\n\n\tbm.pixelbits:=pixelbits\n\tbm.pixelptr:=pixelptr\n\n!set bytes per pixel\n\tbm.pixelbytes:=pixelbits%8\n\n!set bytes per scanline\n\tn:=bm.pixelbytes*width\n\n!n must be a multiple of 4 bytes\n\tif (n iand 3)<>0 then\t!make bytes a multiple of 4\n\t\tn:=(n+4) iand 0xfffc\n\tfi\n\tbm.linebytes:=n\n!CPL \"XXX\",=BM.TYPE\n!CPL =BM.BASETYPE\n\n\tbm.framebytes:=bm.linebytes*bm.dimy\n\n!set palette colours, using winrgb order\n\tif pixelbits=8 then\n\t\tpalette:=new(array,i32,0..255)\n\t\tbm.paltype:=greyscale_pal\n\t\tcolour:=0\n\t\tfor i:=0 to 255 do\n\t\t\tpalette[i]:=colour\n\t\t\tcolour+:=0x10101\n\t\tod\n\tfi\n\n\tsetupgdi(bm,hwnd)\n\n\tbm.gdi.hdc:=createcompatibledc(nil)\n\tbm.gdi.drawmode:=dm_memory\n\tbm.gdi.oldbmobj:=selectobject(bm.gdi.hdc,hwnd)\t!should store original bitmap\n\tsetstretchbltmode(bm.gdi.hdc,4)\t\t\t!average pixels for best result\n\n\tbmputpalette(bm,palette)\n\n\treturn bm\nend\n\nexport func bmgetpalette(bm)=\n!extract entire palette to p, in bmrgb order\n\tif bm.paltype then\n\t\tpalette:=new(array,i32,0..256)\n\t\tgetdibcolortable(bm.gdi.hdc,0,256,&palette)\n\t\tpalette[256]:=bm.paltype\n\t\treversepalette(palette)\n\telse\n\t\tpalette:=()\n\tfi\n\treturn palette\nend\n\nexport proc bmputpalette(bm,p,reverse=1)=\n!update entire palette from p, in bmrgb order\n\tif bm.paltype then\n\t\tif reverse then reversepalette(p) fi\t\t!fix colours\n\t\tsetdibcolortable(bm.gdi.hdc,0,256,&p)\t!store\n\t\tif reverse then reversepalette(p) fi\t\t\t!restore orignal palette\n\t\tif p.upb=256 then\n\t\t\tbm.paltype:=p[256]\n\t\tfi\n\tfi\nend\n\nexport func bmcolour(bm,n,?colour)=\n!get/set palette info:\n!n=given:\n! colour given: update colour entry\n! colour omitted(-1): return colour value\n\n\tif colour.isdef then\t\t!set colour\n\t\tcolour:=revpixel(colour)\n\t\tsetdibcolortable(bm.gdi.hdc,n,1,&colour)\n\t\treturn colour\n\telse\t\t\t\t!get colour\n\t\tcolour:=0\n\t\tgetdibcolortable(bm.gdi.hdc,n,1,&colour)\n\t\treturn revpixel(colour)\n\tfi\nend\n\nexport proc reversepalette(&p)=\n!reverse values of 32-bit colour data at p\n\tfor i:=0 to 255 do\n\t\tp[i]:=revpixel(p[i])\n\tod\nend\n\nexport func revpixel(a)=\n!change rgb to bgr\n!windows colours use red in lsb, bitmaps use blue in lsb, in 24-bit pixels and palette colours\nreturn (a iand 0x00ff00) ior (a>>16 iand 255) ior ((a iand 255)<<16)\nend\n\nexport proc bmshow(bm)=\n\tgxcopy(bm)\nend\n\nexport proc bmfree(bm)=\n\treturn when bm=nil\n\tif not deletedc(bm.gdi.hdc) then\n\t\tpcerror(\"ERROR DELETING BM/HDC\")\n\tfi\n\n\tif not deleteobject(bm.gdi.hwnd) then\n\t\tpcerror(\"ERROR DELETING DIB\")\n\tfi\nend\n\nexport func bmdupl(bm)=\n\tnewbm:=bmcreate(bm.pixelbits, bm.dimx, bm.dimy)\n\tmemcpy(newbm.pixelptr, bm.pixelptr, bm.linebytes*bm.dimy)\n\n\tbmduplpalette(newbm,bm)\n\n\treturn newbm\nend\n\nexport proc bmduplpalette(newbm,bm)=\n\tif bm.paltype then\n\t\tpal:=bmgetpalette(bm)\n\t\tbmputpalette(newbm,pal)\n\t\tnewbm.paltype:=bm.paltype\n\tfi\nend\n\nexport func bmduplz(bm)=\n\tnewbm:=bmcreate(bm.pixelbits, bm.dimx, bm.dimy)\n\treturn newbm\nend\n\nexport func bmgetptr(bm,x,y)=\n!return byte pointer to given pixel\n\treturn bm.pixelptr+(bm.linebytes*y+x*bm.pixelbytes)\nend\n\nexport func bmgetrowptr(bm,y)=\n\treturn bm.pixelptr+y*bm.linebytes\nend\n\n!export func bmgetpixel(bm,y)=\n!\treturn bm.pixelptr+y*bm.linebytes\n!end\n\nfunc getcbbitmap(hwnd)=\n\n\tp:=globallock(hwnd)\n\thsize:=ws_bitmapinfoheader.bytes\n\tbm:=nil\n\n\tif p then\n\t\tp:=makeref(p,ws_bitmapinfoheader)\n\t\tpb:=makeref(p,byte)\n\n\t\tbm:=bmcreate(p^.bitcount,p^.width,p^.height)\n\t\toffset:=(bm.paltype|1024|0)\t\t!offset due to palette table\n\n\t\tif offset then\n\t\t\tsetdibcolortable(bm.gdi.hdc,0,256,pb+hsize)\n\t\tfi\n\n\t\tpb:=pb+hsize+offset\n\t\tfor y:=0 to bm.dimy-1 do\n\t\t\tq:=bmgetrowptr(bm,bm.dimy-y-1)\n\t\t\tmemcpy(q,pb,bm.linebytes)\n\t\t\tpb:=pb+bm.linebytes\n\t\tod\n\n\tfi\n\n\tglobalunlock(hwnd)\n\n\treturn bm\nend\n\nexport func bmgetclipboard=\n!get image from clipboard if one is there, otherwise return nil\n\tif openclipboard(nil)=0 then\n\t\treturn nil\n\tfi\n\n\thwnd:=getclipboarddata(cf_dib)\n\n\tbm:=nil\n\tif hwnd then\n\t\tbm:=getcbbitmap(hwnd)\n\tfi\n\n\tcloseclipboard()\n\n\treturn bm\nend\n\nexport func bmputclipboard(bm)=\n\tif openclipboard(0)=0 then\n\t\treturn nil\n\tfi\n\n\temptyclipboard()\n\n\thwnd:=putcbbitmap(bm)\n\tif hwnd then\n\t\tsetclipboarddata(cf_dib,hwnd)\n\tfi\n\n\tcloseclipboard()\n\treturn 1\nend\n\nfunc putcbbitmap(bm)=\n\tvar mem\n\n\thsize:=ws_bitmapinfoheader.bytes\n\tpsize:=(bm.paltype|1024|0)\n\tfsize:=bm.linebytes*bm.dimy\n\n\thmem:=globalalloc(0,hsize+psize+fsize)\n\tmem:=makeref(globallock(hmem),byte)\n\tmem:=0!makeref(globallock(hmem),byte)\n\n\thdr:=new(ws_bitmapinfoheader)\n\thdr.size:=hsize\n\thdr.width:=bm.dimx\n\thdr.height:=bm.dimy\n\thdr.bitcount:=bm.pixelbits\n\thdr.planes:=1\n\thdr.xpelspermetre:=11811\n\thdr.ypelspermetre:=11811\n\thdr.clrused:=0\n\n\tmemcpy(mem,&hdr,hsize)\n\n\tif psize then\n\t\tpal:=bmgetpalette(bm)\n\t\tmemcpy(mem+hsize,&pal,psize)\n\tfi\n\n\tmem:=mem+hsize+psize\n\tfor y:=0 to bm.dimy-1 do\n\t\tp:=bmgetrowptr(bm,bm.dimy-1-y)\n\t\tmemcpy(mem, p, bm.linebytes)\n\t\tmem:=mem+bm.linebytes\n\tod\n\tglobalunlock(hmem)\n\n\treturn hmem\nend\n\nproc copy24to8(newbm,oldbm)=\n!both images are same size. Copy 1st plane of 24-bit oldbm to 8-bit newbm\n\tfor y:=0 to oldbm.dimy-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(oldbm,y)\n\t\tto oldbm.dimx do\n\t\t\tp++^:=q^\n\t\t\tq:=q+3\n\t\tod\n\tod\nend\n\n!proc copy8to24(newbm,oldbm)=\n!!both images are same size. Copy only plane of 8-bit oldbm to all planes of 24-bit newbm\n!\tfor y:=0 to oldbm.dimy-1 do\n!\t\tp:=bmgetrowptr(newbm,y)\n!\t\tq:=bmgetrowptr(oldbm,y)\n!\t\tto oldbm.dimx do\n!\t\t\tp++^:=q^\n!\t\t\tq:=q+3\n!\t\tod\n!\tod\n!end\n\nexport proc bmresetpalette(bm)=\n# set palette back to greyscale\n\tpal:=new(array,i32,0..256)\n\tcolour:=0\n\tfor i:=0 to 255 do\n\t\tpal[i]:=colour\n\t\tcolour+:=0x010101\n\tod\n\tbmputpalette(bm,pal)\n\tbm.paltype:=greyscale_pal\nend\n\nfunc makescalemap(x)=\n!x=0..1; create 256-element lookup table to multiply 0..255 by x\n\tmap:=new(list,0..255)\n\tfor i:=0 to 255 do\n\t\tmap[i]:=clamp(int(round(i*x)),0,255)\n\tod\n\treturn map\nend\n\nfunc bmunimpl(mess)=\n!ABORT(\"UNIMPLEMENTED: \"+MESS)\nPRINTLN \"UNIMPLEMENTED:\",MESS\nPRINTLN \"ABORTING\"\nSTOP\nreturn 0\nend\n\n!===========================================================================\n!========= HANDLERS\n!===========================================================================\n\nexport func bmload(filename)=\n!CPL \"BMLOAD:\",FILENAME\n\tcase e:=convlc(extractext(filename))\n\twhen \"jpg\",\"jpeg\" then\n\t\treturn bmloadjpg(filename)\n\twhen \"bmp\" then\n\t\treturn bmloadbmp(filename)\n!\twhen \"pgm\" then\n!\t\treturn bmloadpgm_p2p5(filename)\n\twhen \"ppm\",\"pgm\" then\n\t\treturn bmloadppm_p3p6(filename)\n\twhen \"png\" then\n\t\treturn bmloadpng(filename)\n\twhen \"\" then\t\t\t\t!try all\n\t\texts:=(\"jpg\",\"bmp\",\"pgm\",\"ppm\",\"png\")\n\t\tfor ext in exts do\n\t\t\tbm:=bmload(addext(filename,ext))\n\t\t\tif bm then\n\t\t\t\treturn bm\n\t\t\tfi\n\t\tod\n\t\treturn nil\n\telse\n\t\tprintln \"CAN'T LOAD\",E,\"IMAGE\"\n\t\treturn nil\n\tesac\n\treturn nil\nend\n\nfunc bmloadbmp(filename)=\n\tf:=openfile(filename)\n\tif not f then return nil fi\n\n\tfileheader:=new(bmpheader)\n\n\treadrandom(f,&fileheader,0,bmpheader.bytes)\n\tfiledimx:=fileheader.bh.width\n\tfiledimy:=fileheader.bh.height\n\tinvert:=1\n\tif filedimy<0 then\n\t\tfiledimy:=abs(filedimy)\n\t\tinvert:=0\n\tfi\n\n\tif fileheader.fh.typex<>'BM' then\n\t\tclosefile(f)\n\t\treturn nil\n\tfi\n\n\tif fileheader.bh.compression<>0 then\n\t\tclosefile(f)\n\t\treturn nil\n\tfi\n\n\tbm:=bmcreate(fileheader.bh.bitcount,filedimx,filedimy)\n\tframebytes:=bm.linebytes*filedimy\n\n\tif bm.paltype then\n\t\tpalette:=new(array,i32,0..255)\n\t\treadrandom(f,&palette,bmpheader.bytes,1024)\n\t\tbmputpalette(bm,palette,0)\n\t\tcolour:=0\n\t\tfor i:=0 to 255 do\n\t\t\tif palette[i]<>colour then\n\t\t\t\tbm.paltype:=colour_pal\n\t\t\t\texit\n\t\t\tfi\n\t\t\tcolour+:=0x010101\n\t\tod\n\n\tfi\n\n\treadrandom(f,bm.pixelptr,fileheader.fh.offbits,framebytes)\n\tclosefile(f)\n\n\n\tif invert then\n\t\tn:=bm.linebytes\n\t\tbuffer:=makeref(malloc(n),byte)\n\n\t\tfor y:=0 to filedimy%2 do\n\t\t\tp:=bmgetrowptr(bm,y)\n\t\t\tq:=bmgetrowptr(bm,filedimy-1-y)\n!\n\t\t\tmemcpy(buffer,p,n)\n\t\t\tmemcpy(p,q,n)\n\t\t\tmemcpy(q,buffer,n)\n\t\tod\n\t\tfree(buffer)\n\tfi\n\n\treturn bm\nend\n\nexport func bmloadjpg(filename)=\n\tw:=h:=n:=0\n\nCPL \"LOADJ1\"\n!\tp:=imgload_bgr(filename,&w,&h,&n,3)\n\n!\tp:=imgload_bgr(filename,&w,&h,&n,3)\n\tp:=loadjpegm(filename,&w,&h,&n);\n!\tp:=nanoloadjpeg(filename,&w,&h,&n)\n\n\n!\tp:=imgload_bgr(filename,&w,&h,&n)\nCPL \"LOADJ2\",=P, W,H,N\n\tIF P=NIL THEN PCERROR(\"CAN'T LOAD JPG\") FI\n\n\tpixelbits:=n*8\n\n\tif p=nil then\n\t\treturn nil\n\tfi\n\n\tq:=makeref(p,byte)\n\n\tbm:=bmcreate(pixelbits,w,h)\n\n\tnbytes:=w*h*n\n\tdest:=makeref(bm.pixelptr,byte)\n\n\tto h do\n\t\tmemcpy(dest,q,w*n)\n\t\tdest:=dest+bm.linebytes\n\t\tq:=q+w*n\n\tod\n\n!\timgload_free(p)\n\n\treturn bm\nend\n\nfunc bmloadpbm_p1p4(filename)=\nCPL \"CAN'T LOAD PBM\"\nRETURN NIL\n!return bmunimpl(\"bmloadpbm\")\nend\n\nfunc bmloadpgm_p2p5(filename)=\n\nCPL \"LOAD PGM P25\",FILENAME\n\tf:=openfile(filename,\"rb\")\n\tif f=0 then return nil fi\n\n\treadln @f, sig:\"s\"\n\n!CPL =SIG\n\tcase sig\n\twhen \"P5\" then\n\t\tbinary:=1\n\twhen \"P2\" then\n\t\tbinary:=0\n\telse\n\t\tabort(\"Can't read pgm\")\n\t\treturn nil\n\tesac\t\n\n\twidth:=readnextint(f)\n\theight:=readnextint(f)\n\tmaxpix:=readnextint(f)\n\n\tbm:=bmcreate(8,width,height)\n\n\tlinebytes:=width\n\tdest:=makeref(bm.pixelptr,byte)\n\nCPL =WIDTH,=HEIGHT, LINEBYTES,=BM\n\tto height do\n\t\tif binary then\n\t\t\treadbytes(f,dest,width)\t\t\t!will be bgr\n\t\telse\n\t\t\tp:=dest\n\t\t\tto linebytes do\n\t\t\t\tp++^:=readffint(f)\n\t\t\tod\n\t\tfi\n\n\t\tdest:=dest+bm.linebytes\n\tod\n\n\tclosefile(f)\n\n\treturn bm\nend\n\nfunc bmloadppm_p3p6(filename)=\n!read p6 ppm which is binary 24-bit, but will also recognise other formats\n\n!CPL \"P3P6\"\n\tf:=openfile(filename,\"rb\")\n\tif f=0 then return nil fi\n\n\treadln @f, sig:\"s\"\n\n!CPL =SIG\n\tcase sig\n\twhen \"P6\" then\n\t\tbinary:=1\n\twhen \"P3\" then\n\t\tbinary:=0\n\twhen \"P5\",\"P2\" then\n\t\tclosefile(f)\n\t\treturn bmloadpgm_p2p5(filename)\n!\twhen \"P4\",\"P1\" then\n!\t\tclosefile(f)\n!\t\treturn bmloadpbm_p1p4(filename)\n\telse\n\t\tabort(\"Can't read ppm:\"+sig)\n\t\treturn nil\n\tesac\t\n\n!CPL \"READING P6/P3 PPM\"\n\n\twidth:=readnextint(f)\n\theight:=readnextint(f)\n\tmaxpix:=readnextint(f)\n\n\tbm:=bmcreate(24,width,height)\n\n\tlinebytes:=width*3\n\tdest:=makeref(bm.pixelptr,byte)\n\n\tto height do\n\t\tif binary then\n\t\t\treadbytes(f,dest,linebytes)\t\t\t!will be bgr\n\t\telse\n\t\t\tp:=dest\n\t\t\tto linebytes do\n\t\t\t\tp++^:=readffint(f)\n\t\t\tod\n\t\tfi\n\n\t\tp:=dest\t\t\t\t\t\t\t\t!convert to rgb\n\t\tto width do\n\t\t\tswap(p^,(p+2)^)\n\t\t\tp:=p+3\n\t\tod\n\n\t\tdest:=dest+bm.linebytes\n\tod\n\n\tclosefile(f)\n\n\treturn bm\nend\n\nfunc readnextint(f)=\n\tread x\n\twhile not x.isint and not eof(f) do\n\t\treadln @f,x\n\tod\n\tif not x.isint then return 0 fi\n\treturn x\nend\n\nfunc readffint(f)=\n!read next free-format int from f\n\trepeat\n\t\tc:=inbyte(f)\n\tuntil c in '0'..'9'\n\n\ta:=c-'0'\n\tdo\n\t\tc:=inbyte(f)\n\t\tif c in '0'..'9' then\n\t\t\ta:=a*10+c-'0'\n\t\telse\n\t\t\texit\n\t\tfi\n\tod\n\n\treturn a\nend\n\nfunc bmloadpng(filename)=\n\tw:=h:=n:=0\n\nCPL \"LOADP1\"\n!\tp:=imgload_bgr(filename,&w,&h,&n,3)\n\n\tp:=imgload_bgr(filename,&w,&h,&n,0)\n\n!\tp:=nanoloadjpeg(filename,&w,&h,&n)\n\n\n\n!\tp:=imgload_bgr(filename,&w,&h,&n)\nCPL \"LOADP2\",=P, W,H,N\n\n\tpixelbits:=n*8\n\n\tif p=nil then\n\t\treturn nil\n\tfi\n\n\tq:=makeref(p,byte)\n\n\tbm:=bmcreate(pixelbits,w,h)\n\n\tnbytes:=w*h*n\n\tdest:=makeref(bm.pixelptr,byte)\n\n\tto h do\n\t\tmemcpy(dest,q,w*n)\n\t\tdest:=dest+bm.linebytes\n\t\tq:=q+w*n\n\tod\n\n\timgload_free(p)\n\n\treturn bm\nend\n\nexport func bmsave(filename,bm,binary=0)=\n\tcase e:=convlc(extractext(filename))\n\twhen \"jpg\",\"jpeg\" then\n\t\treturn bmsavejpg(filename,bm)\n\twhen \"bmp\" then\n\t\treturn bmsavebmp(filename,bm)\n\twhen \"ppm\",\"pgm\" then\n\t\treturn bmsaveppm_p3p6(filename,bm,binary)\n\telse\n\t\tprintln \"CAN'T SAVE\",E,\"IMAGE\"\n\t\treturn nil\n\tesac\n\treturn nil\nend\n\nfunc bmsavebmp(filename,bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tpixelbytes:=bm.pixelbytes\n\tframebytes:=bm.linebytes*h\n\tpalettebytes:=(pixelbytes=1|1024|0)\n\n\tbmfile:=createfile(filename)\n\tif bmfile=nil then\n\t\treturn 0\n\tfi\n\n\tfileheader:=new(bmpheader)\n\n\tfileheader.fh.typex:='BM'\n\tfileheader.fh.offbits:=bmpheader.bytes+palettebytes\n\tfileheader.fh.size:=fileheader.fh.offbits+framebytes\n\tfileheader.bh.size:=ws_bitmapinfoheader.bytes\n\tfileheader.bh.width:=bm.dimx\n\tfileheader.bh.height:=-bm.dimy\n\tfileheader.bh.bitcount:=bm.pixelbits\n\tfileheader.bh.planes:=1\n\tfileheader.bh.xpelspermetre:=11811\t\t!300 dpi\n\tfileheader.bh.ypelspermetre:=11811\n\tfileheader.bh.clrused:=0\n\n\twriterandom(bmfile,&fileheader,0,bmpheader.bytes)\n\n\tif palettebytes then\n\t\tpalette:=bmgetpalette(bm)\n\t\treversepalette(palette)\n\t\twriterandom(bmfile,&palette,bmpheader.bytes,palettebytes)\n\tfi\n\n\twriterandom(bmfile,bm.pixelptr,fileheader.fh.offbits,framebytes)\n\n\treturn closefile(bmfile)\nend\n\nfunc bmsavejpg(filename,bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tpixelbytes:=bm.pixelbytes\n\tlinebytes:=bm.linebytes\n\n\tp:=q:=malloc(pixelbytes*w*h)\n\n\ts:=makeref(bm.pixelptr,byte)\n\n\tto h do\n\t\tmemcpy(q,s,w*pixelbytes)\n\t\tq:=q+bm.linebytes\n\t\ts:=s+w*pixelbytes\n\tod\n\n\tstatus:=imgsave_jpeg_bgr(filename,p,w,h,pixelbytes)\n\n\tfree(p)\n\n\treturn status\nend\n\nfunc bmsavepbm_p1p4(filename,bm,binary)=\nreturn bmunimpl(\"bmsaveppm-1bit\")\nend\n\nfunc bmsavepgm_p2p5(filename,bm,binary)=\n\twidth:=bm.dimx\n\theight:=bm.dimy\n\n\tf:=createfile(filename)\n\n\tCPL \"WRITEPGM\",filename\n\n\tif not f then return 0 fi\n\n\tprintln @f,(binary|\"P5\"|\"P2\")\n\tprintln @f,width,height\n\tprintln @f,\"255\"\n\n\tbuffer:=data\n\n\tbuffer:=malloc(bm.linebytes)\n\tif buffer=nil then return 0 fi\n\tbuffer:=makeref(buffer,byte)\n\n\tlinebytes:=width\t\t\t!also number of values per line when in text mode\n\n\tfor y:=0 to height-1 do\n\t\tmemcpy(buffer,bmgetrowptr(bm,y),linebytes)\n\t\tif binary then\n\t\t\twritebytes(f,buffer,linebytes)\n\t\telse\n\t\t\tp:=buffer\n\t\t\tto linebytes do\n\t\t\t\tprint @f,p++^,,\" \"\n\t\t\tod\n\t\t\tprintln @f\n\t\tfi\n\tod\n\tclosefile(f)\n\treturn 1\nend\n\nfunc bmsaveppm_p3p6(filename,bm,binary)=\n!\treturn bmunimpl(\"bmsaveppm\")\n\n\tcase bm.pixelbits\n\twhen 24 then\n\twhen 8 then\n\t\treturn bmsavepgm_p2p5(filename,bm,binary)\n\telse\n\t\treturn 0\n\tesac\n\n\twidth:=bm.dimx\n\theight:=bm.dimy\n\n\tf:=createfile(filename)\n\n\tCPL \"WRITEPPM\",filename\n\n\tif not f then return 0 fi\n\n\tprintln @f,(binary|\"P6\"|\"P3\")\n\tprintln @f,width\n\tprintln @f,height\n\tprintln @f,\"255\"\n\n\tbuffer:=data\n\n\tbuffer:=malloc(bm.linebytes)\n\tif buffer=nil then return 0 fi\n\tbuffer:=makeref(buffer,byte)\n\n\tlinebytes:=width*3\t\t\t!also number of values per line when in text mode\n\n\tfor y:=0 to height-1 do\n\t\tmemcpy(buffer,bmgetrowptr(bm,y),linebytes)\n\t\tp:=buffer\t\t\t\t\t!convert to bgr\n\t\tto width do\n\t\t\tswap(p^,(p+2)^)\n\t\t\tp:=p+3\n\t\tod\n\t\tif binary then\n\t\t\twritebytes(f,buffer,linebytes)\n\t\telse\n\t\t\tp:=buffer\n\t\t\tto linebytes do\n\t\t\t\tprint @f,p++^,,\" \"\n\t\t\tod\n\t\t\tprintln @f\n\t\tfi\n\tod\n\tclosefile(f)\n\treturn 1\nend\n\nexport func bmrotate(bm, angle)=\n\tcase angle\n\twhen 0 then return bmdupl(bm)\n\twhen -90 then return bmrotleft90(bm)\n\twhen +90 then return bmrotright90(bm)\n\twhen 180 then return rot180(bm)\n\tesac\n\treturn bmunimpl(\"bmrotate by \"+tostr(angle))\nend\n\nexport func bmrotleft90(bm)=\n\tcase bm.pixelbits\n\twhen 8 then return rotleft90_8(bm)\n\twhen 24 then return rotleft90_24(bm)\n\twhen 32 then return bmunimpl(\"ROTLEFT90/32\")\n\tesac\n\treturn nil\nend\n\nexport func bmrotright90(bm)=\n\tcase bm.pixelbits\n\twhen 8 then return rotright90_8(bm)\n\twhen 24 then return rotright90_24(bm)\n\twhen 32 then return bmunimpl(\"ROTRIGHT90/32\")\n\tesac\n\treturn nil\nend\n\nexport func rot180(bm)=\n\tnewbm1:=bmfliphoz(bm)\n\tnewbm2:=bmflipvert(newbm1)\n\tbmfree(newbm1)\n\treturn newbm2\nend\n\nfunc rotleft90_8(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tlinebytes:=bm.linebytes\n\n\tnewbm:=bmcreate(8,h,w)\n\n\tfor y:=0 to w-1 do\n\t\tq:=bmgetptr(bm,w-y-1,0)\n\t\tp:=bmgetrowptr(newbm,y)\n\n\t\tto h do\n\t\t\tp++^:=q^\n!\t\t\tq:=q+w\n\t\t\tq:=q+linebytes\n\t\tod\n\tod\n\n\tbmduplpalette(newbm,bm)\n\treturn newbm\nend\n\nfunc rotright90_8(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tlinebytes:=bm.linebytes\n\n\tnewbm:=bmcreate(8,h,w)\n\n\tfor y:=0 to w-1 do\n\t\tq:=bmgetptr(bm,y,h-1)\n\t\tp:=bmgetrowptr(newbm,y)\n\n\t\tto h do\n\t\t\tp++^:=q^\n\t\t\tq:=q-linebytes\n\t\tod\n\tod\n\n\tbmduplpalette(newbm,bm)\n\treturn newbm\nend\n\n!function rotleft90_24(bm)=\n!\tnewbm:=bmcreate(24,bm.dimy,bm.dimx)\n!\n!\txform:=new(array,ws_point,3)\n!\txform[1].y:=bm.dimx\n!\txform[3].x:=bm.dimy\n!\txform[3].y:=bm.dimx\n!\n!\tplgblt(newbm.gdi.hdc,&xform, bm.gdi.hdc,0,0,bm.dimx,bm.dimy, nil,0,0)\n!\n!\treturn newbm\n!end\n\nfunc rotleft90_24(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tnewbm:=bmcreate(24,h,w)\n\n\tfor y:=0 to w-1 do\n\t\tq:=bmgetptr(bm,w-y-1,0)\n\t\tp:=bmgetrowptr(newbm,y)\n\n\t\tto h do\n\t\t\tp++^:=q^\n\t\t\tp++^:=(q+1)^\n\t\t\tp++^:=(q+2)^\n\t\t\tq:=q+bm.linebytes\n\t\tod\n\tod\n\n\treturn newbm\nend\n\n!function rotright90_24(bm)=\n!\tnewbm:=bmcreate(24,bm.dimy,bm.dimx)\n!\n!\txform:=new(array,ws_point,3)\n!\txform[1].X:=bm.dimy\n!\txform[2].x:=bm.dimy\n!\txform[2].y:=bm.dimx\n!\n!\tplgblt(newbm.gdi.hdc,&xform, bm.gdi.hdc,0,0,bm.dimx,bm.dimy, nil,0,0)\n!\n!\treturn newbm\n!end\n\nfunc rotright90_24(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tnewbm:=bmcreate(24,h,w)\n\n\tfor y:=0 to w-1 do\n\t\tq:=bmgetptr(bm,y,h-1)\n\t\tp:=bmgetrowptr(newbm,y)\n\n\t\tto h do\n\t\t\tp++^:=q^\n\t\t\tp++^:=(q+1)^\n\t\t\tp++^:=(q+2)^\n\t\t\tq:=q-bm.linebytes\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nfunc rotate8(bm,angle)=\nreturn bmunimpl(\"rotate8\")\nend\n\nexport func bmfliphoz(bm)=\n\tcase bm.pixelbytes\n    when 1 then return fliphoz8(bm)\n    when 3 then return fliphoz24(bm)\n    when 4 then return fliphoz32(bm)\n\tesac\n\treturn nil\nend\n\nfunc fliphoz8(bm)=\n\tnewbm:=bmdupl(bm)\n\n\tw:=newbm.dimx\n\th:=newbm.dimy\n\tbuffer:=makeref(malloc(bm.linebytes),byte)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=p+w-1\n\t\tfor x:=0 to w%2 do\n\t\t\tt:=p^\n\t\t\tp^:=q^\n\t\t\tq^:=t\n\t\t\t++p; --q\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nfunc fliphoz24(bm)=\n\tnewbm:=bmdupl(bm)\n\n\tw:=newbm.dimx\n\th:=newbm.dimy\n\tbuffer:=makeref(malloc(bm.linebytes),byte)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tmemcpy(buffer,p,bm.linebytes)\n\t\tq:=buffer+(w-1)*3\n\n\t\tto w do\n\t\t\tp++^:=q++^\n\t\t\tp++^:=q++^\n\t\t\tp++^:=q^\n\n\t\t\tq:=q-5\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nfunc fliphoz32(bm)=\nreturn bmunimpl(\"fliphoz_32\")\nend\n\nexport func bmflipvert(bm)=\n\tnewbm:=bmdupl(bm)\n\n\tw:=newbm.dimx\n\th:=newbm.dimy\n\tn:=bm.linebytes\n\tbuffer:=makeref(malloc(n),byte)\n\n\tfor y:=0 to h%2 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(newbm,h-1-y)\n!\n\t\tmemcpy(buffer,p,n)\n\t\tmemcpy(p,q,n)\n\t\tmemcpy(q,buffer,n)\n\tod\n\tfree(buffer)\n\n\treturn newbm\nend\n\nexport func bmrepeat(bm,cols,rows)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tnewbm:=bmcreate(bm.pixelbits, w*cols, h*rows)\n\tlinebytes:=bm.linebytes\n\n\tfor y:=0 to h-1 do\n\t\ts:=bmgetrowptr(bm,y)\n\t\tfor r:=0 to rows-1 do\n\t\t\tfor c:=0 to cols-1 do\n\t\t\t\tmemcpy(bmgetptr(newbm,c*w,r*h+y),s,linebytes)\n\t\t\tod\n\t\tod\n\tod\n\n\tif bm.pixelbits=8 then\n\t\tbmduplpalette(newbm,bm)\n\tfi\n\n\treturn newbm\nend\n\nexport func bmscale(bm, sx,?sy)=\n\tif sy.isvoid then sy:=sx fi\n\tcase bm.pixelbits\n\twhen 8 then return scalex8(bm,sx,sy)\n\twhen 24,32 then return scalex24(bm,sx,sy)\n\tesac\n\treturn nil\nend\n\nfunc scalex8(bm,sx,sy)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tneww:=int(round(w*sx))\n\tnewh:=int(round(h*sy))\n\n\tnewbm:=bmcreate(24, neww,newh)\n\treturn nil when not newbm\n\n\tbm24:=bmtorgb(bm,24)\n\n\tstretchblt(newbm.gdi.hdc,0,0,neww,newh,bm24.gdi.hdc,0,0,w,h, srccopy)\n\n\tif bm.paltype=greyscale_pal then\n\t\tnewbm8:=bmgetplane(newbm,\"R\")\n\telse\n\t\tnewbm8:=bmtopal(newbm)\n\tfi\n\tbmfree(newbm)\n\n\treturn newbm8\nend\n\nfunc scalex24(bm,sx,sy)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tneww:=int(round(w*sx))\n\tnewh:=int(round(h*sy))\n\n\tif neww<8 or newh<8 then return nil fi\n\n\tnewbm:=bmcreate(bm.pixelbits, neww,newh)\n\tif newbm then\n\t\tstretchblt(newbm.gdi.hdc,0,0,neww,newh,bm.gdi.hdc,0,0,w,h, srccopy)\n\tfi\n\n\treturn newbm\nend\n\nfunc bmscaleupi8(bm,sx,sy)=\nreturn bmunimpl(\"bmscaleupi8\")\nend\n\nfunc bmscaleupi24(bm,sx,sy)=\nreturn bmunimpl(\"bmscaleupi24\")\nend\n\nfunc bmscaleupi32(bm,sx,sy)=\nreturn bmunimpl(\"bmscaleupi32\")\nend\n\nfunc bmscaledowni8(bm,sx,sy)=\nreturn bmunimpl(\"bmscaledowni8\")\nend\n\nfunc bmscaledowni24(bm,sx,sy)=\nreturn bmunimpl(\"bmscaledowni24\")\nend\n\nfunc bmscaledowni32(bm,sx,sy)=\nreturn bmunimpl(\"bmscaledowni32\")\nend\n\nexport func bmneg(bm)=\n\tnewbm:=bmdupl(bm)\n\n\tdx:=newbm.dimx-1\n\tdy:=newbm.dimy-1\n\tn:=newbm.linebytes\n\tdo32:=0\n\tif n rem 4=0 then\n\t\tdo32:=1\n\t\tn:=n%4\n\tfi\n\n\tfor y:=0 to dy do\n\t\tif do32 then\n\t\t\tp:=makeref(bmgetrowptr(newbm,y),i32)\n\t\t\tto n do\n\t\t\t\tp++^ := p^ ixor 0xFFFFFFFF\n\t\t\tod\n\t\telse\n\t\t\tp:= bmgetrowptr(newbm,y)\n\t\t\tto n do\n\t\t\t\tp++^ := p^ ixor 255\n\t\t\tod\n\t\tfi\n\tod\n\treturn newbm\nend\n\nexport func bmmap(bm,map, channels=\"RGB\")=\n\tif channels=\"\" then channels:=\"RGB\" fi\n\n\tcase bm.pixelbits\n\twhen 8 then\n\t\treturn mapall(bm,map)\n\twhen 24 then\n\t\tif channels=\"RGB\" then\n\t\t\treturn mapall(bm,map)\n\t\tfi\n\t\treturn mapchan_24(bm,map,channels,0)\n\twhen 32 then\n\t\tif channels=\"RGBA\" then\n\t\t\treturn mapall(bm,map)\n\t\tfi\n\t\treturn mapchan_24(bm,map,channels,1)\n\tesac\n\n\treturn nil\nend\n\nfunc mapall(bm,map)=\n\tnewbm:=bmdupl(bm)\n\tp:=newbm.pixelptr\n\tto newbm.framebytes do\n\t\tp^:=map[p^]\n\t\t++p\n\tod\n\treturn newbm\nend\n\nfunc mapchan_24(bm,map,channels,alpha=0)=\n\tdored:=\"R\" in channels\n\tdogreen:=\"G\" in channels\n\tdoblue:=\"B\" in channels\n\tdoalpha:=\"A\" in channels\n\n\tnewbm:=bmdupl(bm)\n\n\tfor y:=0 to newbm.dimy-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tto newbm.dimx do\n\t\t\tif doblue then p^:=map[p^] fi\n\t\t\t++p\n\t\t\tif dogreen then p^:=map[p^] fi\n\t\t\t++p\n\t\t\tif dored then p^:=map[p^] fi\n\t\t\t++p\n\t\t\tif alpha then\n\t\t\t\tif doalpha then p^:=map[p^] fi\n\t\t\t\t++p\n\t\t\tfi\n\t\tod\n\tod\n\n\treturn newbm\nend\n\n!function mapchan_32(bm,map,channels)=\n!return bmunimpl(\"mapchan_32\")\n!end\n\nexport func bmbright(bm,dx,channels=\"RGB\")=\n\treturn bmunimpl(\"bmbright\")\nend\n\nexport func bmcont(bm,x,channels=\"RGB\")=\n\treturn bmunimpl(\"bmcont\")\nend\n\nexport func bmgamma(bm,x,channels=\"RGB\")=\nreturn bmunimpl(\"bmgamma\")\nend\n\nexport func bmtogrey(bm,destbits=24)=\n\tif destbits=0 then destbits:=bm.pixelbits fi\n\tcase bm.pixelbits\n\twhen 8 then\n\t\tcase destbits\n\t\twhen 8 then\n\t\t\treturn pal8togrey8(bm)\n\t\twhen 24 then\n\t\t\tcm:=pal8togrey8(bm)\n\t\t\tnewbm:=grey8torgb24(cm)\n\t\t\tbmfree(cm)\n\t\t\treturn newbm\n\t\tesac\n\twhen 24,32 then\n\t\tcase destbits\n\t\twhen 8 then\n\t\t\treturn rgb24togrey8(bm)\n\t\twhen 24 then\n\t\t\tcm:=rgb24togrey8(bm)\n\t\t\tnewbm:=grey8torgb24(cm)\n\t\t\tbmfree(cm)\n\t\t\treturn newbm\n\t\tesac\n\tesac\nCPL =BM.PIXELBITS, =DESTBITS\n\treturn bmunimpl(\"bmtogrey bad combos\")\n\nend\n\nfunc pal8togrey8(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\t(rmap, gmap, bmap):=getlumtables()\n\n\tnewbm:=bmcreate(8,w,h)\n\tpal:=bmgetpalette(bm)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(bm,y)\n\n\t\tto w do\n\t\t\tcolour:=pal[q++^]\n\t\t\tr:=colour.[0..7]\n\t\t\tg:=colour.[8..15]\n\t\t\tb:=colour.[16..23]\n\t\t\tp++^:=rmap[r]+gmap[g]+bmap[b]\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nfunc pal8togrey24(bm)=\nreturn bmunimpl(\"pal8togrey24\")\nend\n\nfunc rgb24togrey8(bm)=\n!does 24/32 bits\n\tqincr:=(bm.pixelbits=32|1|0)\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\t(rmap, gmap, bmap):=getlumtables()\n\n\tnewbm:=bmcreate(8,w,h)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(bm,y)\n\n\t\tto w do\n\t\t\tb:=q++^; g:=q++^; r:=q++^\n\t\t\tp++^:=rmap[r]+gmap[g]+bmap[b]\n\t\t\tq:=q+qincr\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nfunc rgb24togrey24(bm)=\nreturn bmunimpl(\"rgb24togrey24\")\nend\n\nexport func bmtorgb(bm,destbits=24)=\n\tif destbits=0 then destbits:=24 fi\n\tcase bm.pixelbits\n\twhen destbits then\n\t\treturn bmdupl(bm)\n\n\twhen 8 then\n\t\tcase destbits\n\t\twhen 8 then\n\t\t\tbmunimpl(\"8 to 8 bits rgb\")\n\t\twhen 24 then\n\t\t\tif bm.paltype=greyscale_pal then\n\t\t\t\treturn grey8torgb24(bm)\n\t\t\telse\n\t\t\t\treturn paltorgb24(bm)\n\t\t\tfi\n\t\tesac\n\twhen 24 then\n\t\tif destbits=32 then\n\t\t\treturn bmrgb24torgb32(bm)\n\t\tfi\n\twhen 32 then\n\t\tif destbits=24 then\n\t\t\treturn bmrgb32torgb24(bm)\n\t\tfi\n\tesac\nCPL =BM.PIXELBITS, =DESTBITS\n\treturn bmunimpl(\"bmtorgb bad combos\")\nend\n\nfunc paltorgb24(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tnewbm:=bmcreate(24,w,h)\n\tpal:=bmgetpalette(bm)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(bm,y)\n\n\t\tto w do\n\t\t\tcolour:=pal[q++^]\n\t\t\tr:=colour.[0..7]\n\t\t\tg:=colour.[8..15]\n\t\t\tb:=colour.[16..23]\n\n\t\t\tp++^:=b\n\t\t\tp++^:=g\n\t\t\tp++^:=r\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nfunc grey8torgb24(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tnewbm:=bmcreate(24,w,h)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(bm,y)\n\n\t\tto w do\n\t\t\tlum:=q++^\n\t\t\tp++^:=lum\n\t\t\tp++^:=lum\n\t\t\tp++^:=lum\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nexport func bmrgb24torgb32(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tnewbm:=bmcreate(32,w,h)\n\n\tfor y:=0 to h-1 do\n\t\tq:=bmgetrowptr(bm,y)\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tto w do\n\t\t\tp++^:=q++^\n\t\t\tp++^:=q++^\n\t\t\tp++^:=q++^\n\t\t\tp++^:=128\n\t\tod\n\tod\n\treturn newbm\nend\n\nexport func bmrgb32torgb24(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tnewbm:=bmcreate(24,w,h)\n\n\tfor y:=0 to h-1 do\n\t\tq:=bmgetrowptr(bm,y)\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tto w do\n\t\t\tp++^:=q++^\n\t\t\tp++^:=q++^\n\t\t\tp++^:=q++^\n\t\t\tq++\n\t\tod\n\tod\n\treturn newbm\nend\n\nexport func bmtopal(bm)=\n\tif bm.pixelbits=8 then return bmdupl(bm) fi\n\tqincr:=(bm.pixelbits=32)\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tnewbm:=bmcreate(8,w,h)\n\n\tpal:=new(array,i32,0..255)\n\n!create special palette mapping for rrrgggbb\n\tfor r:=0 to 7 do\n\t\tfor g:=0 to 7 do\n\t\t\tfor b:=0 to 3 do\n\t\t\t\tindex:=r<<5+g<<2+b\n!\t\t\t\tpal[index]:=r<<5+g<<13+b<<18\n\t\t\t\tpal[index]:=r<<5+g<<13+b<<22\n\t\t\tod\n\t\tod\n\tod\n\tbmputpalette(newbm,pal)\n\tbm.paltype:=colour_pal\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(bm,y)\n\n!noise:=-16..16\n!noise:=-8..8\n\n\t\tto w do\n\t\t\tb:=q++^; g:=q++^; r:=q++^\n\n!\t\t\tr+:=clamp(random(noise),0,255)\n!\t\t\tg+:=clamp(random(noise),0,255)\n!\t\t\tb+:=clamp(random(noise),0,255)\n!\n\t\t\tp++^:=r>>5<<5 + g>>5<<2 + b>>6\n\t\t\tq:=q+qincr\n\t\tod\n\tod\n\n\treturn newbm\n\nend\n\nexport func bmsplittorgb(bm,greydest=1)=\n# split 24-bit bitmap into three separate 8-bit planes\n# return 3 new bitmaps in the order red, green, blue\n# return () on error\n# dogreyscale=1 for each image to have a greyscale palette. Otherwise\n# the red image will be shades of red, etc\n\n\tif bm.pixelbits<24 then\n\t\treturn ()\n\tfi\n\tchannels:=bm.pixelbytes\n\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tpal:=new(array,i32,0..255)\n\timages::=()\n\n\tfor offset:=channels-1 downto 0 do\n\n\t\tnewbm:=bmcreate(8,w,h)\n\n\t\tfor y:=0 to h-1 do\n\t\t\tq:=bmgetrowptr(bm,y)+offset\n\t\t\tp:=bmgetrowptr(newbm,y)\n\t\t\tto w do\n\t\t\t\tp++^:=q^\n\t\t\t\tq:=q+channels\n\t\t\tod\n\t\tod\n\n\t\tif not greydest then\n\t\t\tcolour:=0\n\t\t\tincr:=(3-offset|0x00'00'01,0x00'01'00,0x01'00'00|0x01'01'01)\n\t\t\tfor i:=0 to 255 do\n\t\t\t\tpal[i]:=colour\n\t\t\t\tcolour+:=incr\n\t\t\tod\n\t\t\tbmputpalette(newbm,pal)\n\t\t\tnewbm.paltype:=tinted_pal\n\t\tfi\n\n\t\timages append:=newbm\n\tod\n\n!image order is r,g,b, or a,r,g,b\n\tif images.len=4 then\n\t\treturn (images[2],images[3],images[4],images[1])\n\telse\n\t\treturn images\n\tfi\nend\n\nexport func bmsplittoyuv(bm)=\n# split 24-bit bitmap into three separate 8-bit planes\n# return 3 new bitmaps in the order y, u, v\n# return () on error\n\n\tneedfree:=0\n\tcase bm.pixelbits\n\twhen 24 then\n\twhen 32 then\n\t\tbm:=bmtorgb(bm,24)\n\t\tneedfree:=1\n\telse\n\t\treturn nil\n\tesac\n\n!get y plane first with existing routine\n\tgreybm:=bmtogrey(bm,8)\n\n\tw:=bm.dimx\n\th:=bm.dimy\n\n!equations used are:\n! u:=int(round(0.492*(b-y)+128)\n! v:=int(round(0.702*(r-y)+128)\n!b-y and r-y will be in range +/- 255\n\n\tumap:=new(list,-255..255)\n\tvmap:=new(list,-255..255)\n\tfor i:=-255 to 255 do\n\t\tumap[i]:=int(round(0.492*(i)+128))\n\t\tvmap[i]:=int(round(0.702*(i)+128))\n\tod\n\n\tubm:=bmcreate(8,w,h)\n\tvbm:=bmcreate(8,w,h)\n\tfor c:=1 to 2 do\n\t\tif c=1 then\n\t\t\toffset:=0\n\t\t\tmap:=umap\n\t\telse\n\t\t\toffset:=2\n\t\t\tmap:=vmap\n\t\tfi\n\n\t\tfor yy:=0 to h-1 do\n\t\t\tpy:=bmgetrowptr(greybm,yy)\n\t\t\tp:=bmgetrowptr(bm,yy)\t\t\t!point to bgr pixels in original\n\n\t\t\tpu:=bmgetrowptr(ubm,yy)\n\t\t\tpv:=bmgetrowptr(vbm,yy)\n\t\t\tto w do\n\t\t\t\ty:=py++^\n\t\t\t\tr:=(p+2)^\n\t\t\t\tb:=p^\n\t\t\t\tpu++^:=umap[b-y]\n!CPL =B,=Y,=PV,=VMAP.TYPE\n\t\t\t\tpv++^:=vmap[r-y]\n\n\t\t\t\tp:=p+3\n\t\t\tod\n\t\tod\n\tod\n\n!create special greyscale for u/v images, since point of zero colour\n!info has been offset to +128\n\tpal:=new(array,i32,0..256)\n\tcolour:=0\n\tpal[128]:=0\n\tfor i:=1 to 127 do\n\t\tcolour+:=0x020202\n\t\tpal [i+128]:=colour\n\t\tpal [128-i]:=colour\n\tod\n\tpal[256]:=uv_pal\n\tbmputpalette(ubm,pal)\n\tbmputpalette(vbm,pal)\n\n\tif needfree then\n\t\tbmfree(bm)\n\tfi\n\n\treturn (greybm,ubm,vbm)\nend\n\nexport func bmgetplane(bm,plane)=\n# plane is one of \"R\",\"G\",\"B\"\n# extract given plane of a 24-bit bitmaps into a single 8-bit greyscale image\n# Return new image\n\n\tincr:=bm.pixelbytes\n\tif plane.len<>1 or bm.pixelbytes<3 then\n\t\treturn nil\n\tfi\n\n\tcase asc(plane)\n\twhen 'R' then offset:=2\n\twhen 'G' then offset:=1\n\twhen 'B' then offset:=0\n\twhen 'A' then offset:=3\n\telse return nil\n\tesac\n\n\tw:=bm.dimx\n\th:=bm.dimy\n\tnewbm:=bmcreate(8,w,h)\n\n\tfor y:=0 to h-1 do\n\t\tq:=bmgetrowptr(bm,y)+offset\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tto w do\n\t\t\tp++^:=q^\n\t\t\tq:=q+incr\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nexport func bmjoinrgb(redbm,greenbm,bluebm,alphabm=nil)=\n\n\tw:=redbm.dimx\n\th:=redbm.dimy\n\n\tnewbm:=bmcreate((alphabm|32|24),w,h)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\n\t\tr:=bmgetrowptr(redbm,y)\n\t\tg:=bmgetrowptr(greenbm,y)\n\t\tb:=bmgetrowptr(bluebm,y)\n\n\t\tif alphabm then\n\t\t\ta:=bmgetrowptr(alphabm,y)\n\t\t\tto w do\n\t\t\t\tp++^:=b++^\n\t\t\t\tp++^:=g++^\n\t\t\t\tp++^:=r++^\n\t\t\t\tp++^:=a++^\n\t\t\tod\n\t\telse\n\t\t\tto w do\n\t\t\t\tp++^:=b++^\n\t\t\t\tp++^:=g++^\n\t\t\t\tp++^:=r++^\n\t\t\tod\n\t\tfi\n\tod\n\n\treturn newbm\nend\n\nexport func bmjoinyuv(ybm,ubm,vbm)=\n# combine y, u, v separations into a single rgb image\n# return new bitmap, or nil\n\n\tif ybm.pixelbits<>8 then\n\t\treturn nil\n\tfi\n\n\tw:=ybm.dimx\n\th:=ybm.dimy\n\n\tv1425map:=new(list,0..255)\n\tv726map:=new(list,0..255)\n\tu395map:=new(list,0..255)\n\tu2032map:=new(list,0..255)\n\n\tfor i:=0 to 255 do\n\t\tv1425map[i]:=int(round(1.425*(i-128)))\n\t\tv726map[i]:=int(round(0.726*(i-128)))\n\t\tu395map[i]:=int(round(0.395*(i-128)))\n\t\tu2032map[i]:=int(round(2.032*(i-128)))\n\tod\n\n\tnewbm:=bmcreate(24,w,h)\n\n\tfor yy:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,yy)\n\t\tqy:=bmgetrowptr(ybm,yy)\n\t\tqu:=bmgetrowptr(ubm,yy)\n\t\tqv:=bmgetrowptr(vbm,yy)\n\n!\t\tto w do\n\t\tFOR X:=0 TO W-1 DO\n\t\t\ty:=qy++^\n\t\t\tr:=y+v1425map[qv^]\n\t\t\tg:=y-u395map[qu^]-v726map[qv^]\n\t\t\tb:=y+u2032map[qu^]\n\t\t\t++qu\n\t\t\t++qv\n\t\t\tp++^:=clamp(b,0,255)\n\t\t\tp++^:=clamp(g,0,255)\n\t\t\tp++^:=clamp(r,0,255)\n\t\tod\n\tod\n\treturn newbm\nend\n\nexport func bmblur(bm,n)=\n\tcase bm.pixelbits\n\twhen 8 then\n\t\treturn blur8(bm,n)\n\twhen 24 then\n\t\treturn blur24(bm,n)\n\twhen 32 then\n\t\treturn blur32(bm,n)\n\tesac\n\treturn nil\nend\n\nfunc blur8(bm,n)=\n\tshift:=shifts{n,1}\n\n\tnewbm:=bmdupl(bm)\n\tiblurhoz8(newbm,n)\n\n\tnewbm2:=rotleft90_8(newbm)\n\tiblurhoz8(newbm2,n)\n\n\tnewbm3:=rotright90_8(newbm2)\n\tbmfree(newbm)\n\tbmfree(newbm2)\n\n\tbmduplpalette(newbm3,bm)\n\treturn newbm3\nend\n\nfunc blur24(bm,n)=\n\t(r,g,b):=bmsplittorgb(bm)\n\n\tr2:=bmblur(r,n)\n\tg2:=bmblur(g,n)\n\tb2:=bmblur(b,n)\n\n\tnewbm:=bmjoinrgb(r2,g2,b2)\n\tbmfree(r2)\n\tbmfree(g2)\n\tbmfree(b2)\n\n\treturn newbm\nend\n\nfunc blur32(bm,n)=\nreturn bmunimpl(\"blur32\")\nend\n\nproc iblurhoz8(bm,n)=\n\tshift:=shifts{n,1}\n\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(bm,y)\n!\t\tblurhelper(w-n-1, n, shift, p)\n\n\t\tto w-n-1 do\n\t\t\tsum:=0\n\t\t\tq:=p\n\t\t\tto n do\n\t\t\t\tsum+:=q++^\n\t\t\tod\n\t\t\tp++^:=sum>>shift\n\t\tod\n\tod\nend\n\nproc blurhelper(m, n, shift, p)=\n\tvar sum\n\tvar q\n\n\tto m do\n\t\tsum:=0\n\t\tq:=p\n\t\tto n do\n\t\t\tsum+:=q++^\n\t\tod\n\t\tp++^:=sum>>shift\n\tod\nend\n\nfunc blurhoz24(bm,n)=\nreturn bmunimpl(\"blurhoz24\")\nend\n\nfunc blurhoz32(bm,n)=\nreturn bmunimpl(\"blurhoz32\")\nend\n\nexport func bmsharpen(bm,n=0)=\n\tcase bm.pixelbits\n\twhen 8 then\n\t\treturn sharpen8(bm,n)\n\twhen 24 then\n\t\treturn sharpen24(bm,n)\n\twhen 32 then\n\t\treturn sharpen32(bm,n)\n\tesac\n\treturn nil\nend\n\nexport func sharpen8(bm,n)=\n!blur in-place horizontally by averaging each set of n pixels\n!n must be multiple of 2 from 2 to 64\n!return new modified image\n\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tnewbm:=bmdupl(bm)\n\n\tfor y:=1 to h-2 do\n\t\tp:=bmgetptr(newbm,1,y)\n\n\t\tq:=bmgetptr(bm,1,y-1)\n\t\tr:=bmgetptr(bm,1,y)\n\t\ts:=bmgetptr(bm,1,y+1)\n\n\t\tto w-2 do\n!\t\t\tabcdefghij\n\t\t\ta:=(q-1)^\n\t\t\tb:=q^\n\t\t\tc:=(q+1)^\n\t\t\td:=(r-1)^\n\t\t\te:=r^\n\t\t\tf:=(r+1)^\n\t\t\tg:=(s-1)^\n\t\t\th:=s^\n\t\t\ti:=(s+1)^\n\n! a b c\n! d e f\n! g h i\n!\t\t\tsum:=e*4-b-d-f-h\n!\t\t\tp^:=clamp(p^+sum%4,0,255)\n\n\t\t\tsum:=e*8-a-b-c-d-f-g-h-i\n\t\t\tp^:=clamp(p^+sum%8,0,255)\n\n!\t\t\tsum:=e*4+c+g+i-2*(b+d+f+h)\n!\t\t\tp^:=clamp(p^+sum%4,0,255)\n\n\t\t\t++p\n\t\t\t++q\n\t\t\t++r\n\t\t\t++s\n\t\tod\n\tod\n\n\treturn newbm\n\nend\n\nexport func sharpen24(bm,n)=\n\t(r,g,b):=bmsplittorgb(bm)\n\n\tr2:=bmsharpen(r,n)\n\tg2:=bmsharpen(g,n)\n\tb2:=bmsharpen(b,n)\n\n\tnewbm:=bmjoinrgb(r2,g2,b2)\n\tbmfree(r2)\n\tbmfree(g2)\n\tbmfree(b2)\n\n\treturn newbm\nend\n\nexport func sharpen32(bm,n)=\nreturn bmunimpl(\"bmsharpen32\")\nend\n\nfunc getlumtables=\n\trmap:=makescalemap(0.299)\n\tgmap:=makescalemap(0.587)\n\tbmap:=makescalemap(0.111)\n\treturn (rmap, gmap, bmap)\nend\n",
(u64)"!!Virtual keycodes\nexport const vklbutton=1\t\t!note these are physical not logical buttons\nexport const vkrbutton=2\nexport const vkmbutton=4\t\t!middle button is correct\nexport const vkbackspace=8\nexport const vktab=9\nexport const vkclear=12\nexport const vkenter=13\nexport const vkshift=16\nexport const vkctrl=17\nexport const vkalt=18\nexport const vkbreak=19\nexport const vkcapslock=20\n!export const vkrshift=21\nexport const vkrctrl=22\n!export const vkralt=23\nexport const vkinslock=24\nexport const vkescape=27\nexport const vkspace=32\nexport const vkpageup=33\nexport const vkpagedown=34\nexport const vkend=35\nexport const vkhome=36\nexport const vkleft=37\nexport const vkup=38\nexport const vkright=39\nexport const vkdown=40\nexport const vkinsert=45\nexport const vkdelete=46\nexport const vkhelp=47\nexport const vk0='0'\nexport const vka='A'\nexport const vkwindows=91\nexport const vkrightbutton=93\nexport const vknumpad0=96\t\t!96..105 = '0'..'9'\nexport const vkmul=106\nexport const vkadd=107\nexport const vksub=109\nexport const vkdecimal=110\nexport const vkdiv=111\nexport const vkf1=112\nexport const vkf2=113\nexport const vkf3=114\nexport const vkf4=115\nexport const vkf5=116\nexport const vkf6=117\nexport const vkf7=118\nexport const vkf8=119\nexport const vkf9=120\nexport const vkf10=121\nexport const vkf11=122\nexport const vkf12=123\n!export const vklsq=128\n!export const vkrsq=129\n!export const vksemi=130\n!export const vkquote=131\n!export const vkstroke=132\n!export const vkdot=133\n!export const vkcomma=134\n!export const vkbackslash=135\n!export const vkquote2=136\n!export const vkequals=137\n!export const vkminus=138\n!export const vkhash=139\nexport const vklshift=160\nexport const vkrshift=161\nexport const vklcontrol=162\nexport const vkrcontrol=163\nexport const vklalt=164\nexport const vkralt=165\n\n!oem codes\nexport const vkminus=189\nexport const vkequals=187\nexport const vklsq=219\nexport const vkrsq=221\nexport const vksemi=186\nexport const vkquote=192\nexport const vkhash=222\nexport const vkcomma=188\nexport const vkperiod=190\nexport const vkslash=191\nexport const vkbackslash=220\nexport const vkbackquote=223\n\nexport const con_black=0\nexport const con_dkblue=1\nexport const con_dkred=2\nexport const con_dkmagenta=3\nexport const con_dkgreen=4\nexport const con_dkcyan=5\nexport const con_dkyellow=6\nexport const con_dkgrey=7\nexport const con_grey=8\nexport const con_blue=9\nexport const con_red=10\nexport const con_magenta=11\nexport const con_green=12\nexport const con_cyan=13\nexport const con_yellow=14\nexport const con_white=15\n\n\nexport record winrec =\n\tvar posx,posy\n\tvar cols,rows\n\tvar fgnd,bgnd\t\t\t!default text/background colour\n\n\tvar columns\t\t\t!used when divided into columns\n\tvar itemcols\t\t\t!width of each column\n\tvar pagesize\t\t\t!columns*rows\n\n\tvar name\n\n\tvar hdata\t\t\t!pointer to data record, or is nil\nend\n\nexport var wconscreen\nexport var screencols,screenrows\n\nexport var chardata\t\t\t!string these two represent row of the console\nexport var attrdata\t\t\t!string\n\nexport var defscreenfgnd=con_black\nexport var defscreenbgnd=con_grey\nexport var rlkey=0\t\t!set by readline, when special key has been input\nexport var rlbuffer\t\t\t!contents of readline buffer when special key pressed\n\nvar cmdindex,ncmds\nvar cmdhistory\n\nexport const capsmask  = 0x8\t\t!shift states as they are in .keyshift\nexport const altmask   = 0x4\nexport const ctrlmask  = 0x2\nexport const shiftmask = 0x1\n\nexport const capsbit=3\nexport const altbit=2\nexport const ctrlbit=1\nexport const shiftbit=0\n\nvar keypending=0\nvar lastkey\nvar pendkey\nexport var hconsole, hconsolein\nvar colourpalette\n\n!export var wscreencols,wscreenrows\n!export var currbgnd=-1,currfgnd=-1\nexport var currbgnd=con_grey, currfgnd=con_black\n\n!export var screencolour=con_dkred..con_grey\n\n!export var colourmap\nexport VAR SUPPRESS=0\n\nVAR ALLCHARS\n\nproc START=\n!if iswindows() then\n!\tCPL \"WINCON INIT\"\n\t\tinit()\n!fi\n\tend\n\nproc main=\n\tinit()\n\tsettitle(\"New Title\")\n\n!keyscreentest()\n\n!W:=MAKEWIN((1,20),(20,20))\n!CLEARWIN(W)\n\n!SHOWTEXT(\"^^^^^^^^^^^^^^^^^\")\n\na:=rkey(10,20,30)\n!\tsetpos(12, 10)\n!\tprint \"***********hello\"\n!\twaitkey()\nend\n\nproc keyscreentest=\n\t(cols,rows):=(screencols, screenrows)\n\tCPL =COLS,=ROWS\n\n\trow:=rows%2\n\tcol:=cols%2\n\tch:=\"X\"\n\n\tsetcolour(6,1)\n\n\tdo\n\t\tsetpos(col,row)\n\t\tcp ch\n\t\tsetpos(col,row)\n\t\tk:=getkey().keycode\n\t\tcase k\n\t\twhen 27 then\n\t\t\texit\n\t\twhen vkleft then col:=max(1,col-1)\n\t\twhen vkright then col:=min(cols,col+1)\n\t\twhen vkup then row:=max(1,row-1)\n\t\twhen vkdown then row:=min(rows,row+1)\n\t\tesac\n\tod\n\n!waitkey()\n\nend\n\nexport func makerspoint(x,y)=\n!combine x,y into 32-bit value (rspoint)\n\treturn y<<16 ior x\nend\n\nexport proc setpos(col,row)=\n\n!!ROW+:=10\n!fprint \"\\s[{#};{#}H\",row,col\n\n\tsetconsolecursorposition(hconsole,makerspoint(col-1,row-1))\nend\n\nexport func getpos=\n\tinfo:=new(ws_console)\n\tgetconsolescreenbufferinfo(hconsole,&info)\n\treturn (info.pos.x+1,info.pos.y+1)\nend\n\nexport proc init(cols=100)=\n!static var setdimdone=0\n\n!CPL \"CONSOLE INIT-----------\"\n\n\n!\tconsolesw.init(cols)\n\tcmdhistory::=()\t!\"one\",\"two\",\"three\",\"four\")\n\tncmds:=cmdhistory.upb\n\tcmdindex:=0\n\n!screencols:=consolesw.wscreencols\n!screenrows:=consolesw.wscreenrows\n!\n\n\thconsole:=getstdhandle(-11)\n\thconsolein:=getstdhandle(-10)\n\tlastkey:=new(ws_keyevent)\n\tlastkey.repeatcount:=0\n\tpendkey:=new(ws_keyevent)\n\n\tsetdims(cols,60)\n!\tsetdims(50,20)\n\n\tgetdims()\n\n!CPL =SCREENCOLS\n\n\twconscreen:=makewin((1,1),(screencols,screenrows),defscreencolour)\n\n\tcolourpalette:=new(ws_palette16)\n\n\tsetstdpalette()\nend\n\nexport func setcursor(?visible)=\n\tcursor:=new(ws_cursor)\n\tgetconsolecursorinfo(hconsole,&cursor)\n\n\tif visible.defined then\n\t\tcursor.visible:=visible\n\t\tsetconsolecursorinfo(hconsole,&cursor)\n\tfi\n\treturn cursor.visible\nend\n\nexport proc setcolour(fgnd, ?bgnd)=\n!call with as (fgnd,bgnd) or as (fgnd..bgnd)\n\n\tif bgnd.isvoid then bgnd:=currbgnd fi\n\n\tif fgnd=currfgnd and bgnd=currbgnd then\n!\t\treturn\n\tfi\n\n\tcurrfgnd:=fgnd\n\tcurrbgnd:=bgnd\n\n\tsetconsoletextattribute(hconsole,(bgnd*16+fgnd))\nend\n\nexport proc settitle(caption)=\n\tsetconsoletitle(caption)\nend\n\nexport func getkeychar=\n!wait for any key, return single char code; as returned by C's getch()\n\treturn waitkey()\nend\n\nexport func getkey2=\n!wait for any key, return keyrec\n!includes shift key presses as discrete keys\n!use getkey() to ignore these\n\n\treturn getchx()\n\n\tk:=getchx()\t\t\t!get keyrec, encoded as int\n\n\tkey:=new(rkey)\t\t\t!convert to proper keyrec\n\tkey.charcode:=k iand 65535\n\tkey.shift:=k>>24\n\tkey.keycode:=k.[23..16]\n!CPL \"GK2:\",KEY\n\n\treturn key\nend\n\nexport func getkey=\n!calls igetkey but doesn't return shift keys as discrete key presses\n\tdo\n\t\tk:=getkey2()\n\t\tcase k.keycode\n\t\twhen vkshift,vkctrl,vkalt,vkcapslock then\n\t\telse\n\t\t\texit\n\t\tesac\n\tod\n\treturn k\nend\n\nexport func keyready=\n\treturn testkey()\nend\n\nexport proc showtext(s,?x,?y)=\n\n\tif x.defined then\n\t\tsetpos(x,y)\n\tfi\n\n\tcount:=0\n\tif s then\n\t\tif not suppress then\n\t\t\twriteconsole(hconsole,s,s.len,&count,nil)\n\t\tfi\n\tfi\nend\n\nproc setwindowsize(cols,rows)=\n\tr:=new(ws_srect)\n\tr.leftx:=0\n\tr.rightx:=cols-1\n\tr.top:=0\n\tr.bottom:=rows-1\n\tif not setconsolewindowinfo(hconsole,1,&r) then\n!\tCPL \"WINDOW ERROR 1\"\n!\tabort(\"Window error 1\")\n\tfi\nend\n\nexport proc setdims(cols,rows)=\n!set new size for console, by reinitialising\n\n\tmaxcol:=cols\n\tmaxrow:=rows\n\n\tinfo:=new(ws_console)\n\toldscreenattributes:=info.attributes\n\toldscreensize:=info.size\n\n\toldcols:=info.window.rightx-info.window.leftx+1\n\toldrows:=info.window.bottom-info.window.top+1\n\n\tIF OLDSCREENSIZE.X>COLS OR OLDSCREENSIZE.Y>ROWS THEN\t!need to reduce window size first\n\t\tsetwindowsize(oldscreensize.x min cols, oldscreensize.y min rows)\n\tfi\n\n!Set the new size of the entire (virtual) console window\n\tif setconsolescreenbuffersize(hconsole,rows<<16+cols)=0 then\n!\tabort(\"Buffer size error\")\n\tfi\n\n!now set the size of the displayed portion of it; in this case exactly the same\n!size as the buffer, with no scrollbars\n\tsetwindowsize(cols,rows)\n\n\twscreencols:=cols\n\twscreenrows:=rows\n\n!hide blinking cursor\n\tcursor:=new(ws_cursor)\n\tcursor.size:=10\n\tcursor.visible:=1\nend\n\nexport proc setpalette(index,colour)=\n!index is 0..15; colour is an rgb value bbggrr\n!updates local palette array\n!to update actual console, use writepalette\n\tcolourpalette[index]:=colour\nend\n\nexport proc writepalette=\n\tr:=new(ws_consoleex)\n\tr.recsize:=ws_consoleex.bytes\n\tX:=getconsolescreenbufferinfoex(hconsole,&r)\n\n\tr.palette:=colourpalette\n\n\tR.WINDOW.RIGHTX:=R.WINDOW.RIGHTX+1\t\t!workaround off-by-one bug\n\tR.WINDOW.BOTTOM:=R.WINDOW.BOTTOM+1\n\n\tX:=setconsolescreenbufferinfoex(hconsole,&r)\n\n!export proc READPALETTE=\n!r:=new(rconsoleex)\n!r.recsize:=rconsoleex.bytes\n!x:=getconsolescreenbufferinfoex(hconsole,&r)\n!\n!CPL \"GCSBI X=\",X\n!FOR I:=0 TO 15 DO\n! CPL I,\":\",R.PALETTE[I]:\"H\"\n!OD\n!\nend\n\nproc setstdpalette=\n!export const con_black=0\n!export const con_dkblue=1\n!export const con_dkred=2\n!export const con_dkmagenta=3\n!export const con_dkgreen=4\n!export const con_dkcyan=5\n!export const con_dkyellow=6\n!export const con_grey=7\n!export const con_dkgrey=8\n!export const con_blue=9\n!export const con_red=10\n!export const con_magenta=11\n!export const con_green=12\n!export const con_cyan=13\n!export const con_yellow=14\n!export const con_white=15\n\n!R G B\n\tcols:=(\n\t(0,\t\t0,\t\t0),\t\t\t!black\n\t(0,\t\t0,\t\t128),\t\t!dk blue\n\t(128,\t0,\t\t0),\t\t\t!dk red\n\t(128,\t0,\t\t128),\t\t!dk magenta\n\t(0,\t\t128,\t0),\t\t\t!dk green\n\t(0,\t\t128,\t128),\t\t!dk cyan\n\t(128,\t128,\t0),\t\t\t!dk yellow\n\t(128,\t128,\t128),\t\t!dk grey\n\t(192,\t192,\t192),\t\t!grey\n\t(0,\t\t0,\t\t192),\t\t!blue\n\t(192,\t0,\t\t0),\t\t\t!red\n\t(192,\t0,\t\t192),\t\t!magenta\n\t(0,\t\t192,\t0),\t\t\t!green\n\t(0,\t\t192,\t192),\t\t!cyan\n\t(192,\t192,\t0),\t\t\t!yellow\n\t(255,\t255,\t255))\t\t!white\n\n\tfor i,c in cols do\n\t\tsetpalette(i-1,c[3]<<16+c[2]<<8+c[1])\n\tod\n!CPL \"WRITEPAL\"; WAITKEY()\n\twritepalette()\nend\n\nproc getdims=\n\tinfo:=new(ws_console)\n\tgetconsolescreenbufferinfo(hconsole,&info)\n\n\tscreencols:=info.window.rightx-info.window.leftx+1\n\tscreenrows:=info.window.bottom-info.window.top+1\nend\n\nexport func getchx=\n\tconst rightaltmask\t= 1\t\t\t\t!masks used by .controlkeystate\n\tconst leftaltmask\t= 2\n\tconst leftctrlmask\t= 8\n\tconst rightctrlmask\t= 4\n\tconst shiftmask\t\t= 16\n\tconst capsmask\t\t= 128\n\tconst scrollmask\t= 64\n\n\tconst leftctrlbit\t= 3\t\t!for c.l.p\n\tconst rightctrlbit\t= 2\n\n\tif keypending then\n\t\tlastkey:=pendkey\n\t\tkeypending:=0\n\telse\n\t\tif lastkey.repeatcount=0 then\n\t\t\trepeat\n\t\t\t\tcount:=0\n\t\t\t\treadconsoleinput(hconsolein,&lastkey,1,&count)\n\t\t\tuntil lastkey.eventtype=1 and lastkey.keydown=1\n\t\tfi\n\tfi\n\n\taltdown\t\t:= (lastkey.controlkeystate iand (leftaltmask ior rightaltmask)|1|0)\n\tctrldown\t:= (lastkey.controlkeystate iand (leftctrlmask ior rightctrlmask)|1|0)\n\tshiftdown\t:= (lastkey.controlkeystate iand shiftmask|1|0)\n\tcapslock\t:= (lastkey.controlkeystate iand capsmask|1|0)\n\n\tlastkey.repeatcount:=lastkey.repeatcount-1\n\n\tcharcode:=lastkey.asciichar\n\tkeycode:=lastkey.virtualkeycode iand 255\n\n!for keycodes in range 186 to 223, which are all stand-alone punctuation keys, I might\n!wish to set charcode to the appropriate printed char code (currently charcode will be\n!zero, and keyboard handlers need to detect keycodes such as vkequals)\n!\n\tif altdown and ctrldown and charcode=166 then\n\t\taltdown:=ctrldown:=0;\n\telse\n\t\tif altdown or ctrldown then\n\t\t\tcharcode:=0;\n\t\t\tif keycode>='A' and keycode<= 'Z' then\n\t\t\t\tcharcode:=keycode-'@'\n\t\t\tfi\n\t\tfi\n\tfi\n\n\tkeyshift:=capslock<<3 ior altdown<<2 ior ctrldown<<1 ior shiftdown\n\n\tkeyshift.[4]:=lastkey.controlkeystate.[leftctrlbit]\t\t!for c.l.p\n\tkeyshift.[5]:=lastkey.controlkeystate.[rightctrlbit]\n\n!need to be more ruthless with how keycoded and charcodes are combined.\n!More combinations need to have only charcode or keycode set, and the other zero\n\n\tswitch charcode\n\twhen 'A'..'Z','a'..'z','0'..'9' then\n\twhen 8,9,13,27,' ','`' then\n\twhen 0 then\t\t\t\t!already key-only event\n\telse\n\t\tkeycode:=0\n\tend switch\n\n\treturn rkey(charcode,keycode,keyshift)\n\nend\n\nexport proc flushkeyboard=\n\tflushconsoleinputbuffer(hconsolein)\nend\n\nexport proc w_writeconsolerow(text, attributes, length, row)=\n\tbuffersize:=1<<16+length\n\tcoord:=0\n\n\tbox:=ws_srect(0,row-1,length-1,row-1)\n\n\tbuffer:=new(array,ws_charinfo,length)\n\n\tfor i:=1 to length do\n\t\tx:=new(ws_charinfo)\n\t\tx.asciichar  := text.[i]\n\t\tx.attributes := attributes.[i]\n!\tx.attributes := attributes.[1]\n\t\tbuffer[i]:=x\n\tod\n!CPL \"HELLO\",text; WAITKEY()\n\n\twriteconsoleoutputa(hconsole, &buffer,buffersize,coord,&box)\nend\n\nexport func setclipboard(s)=\n!copy text to the Windows clipboard\n!return status 0 if no clipboard o/p was possible\n\tconst ghnd=2 + 0x40\n\n\tif openclipboard(nil)=0 then\n\t\treturn 0\n\tfi\n\n\temptyclipboard()\n\n\tif s<>\"\" then\n\t\th:=globalalloc(ghnd,s.len+1)\n\t\tp:=globallock(h)\n\n\t\tmemcpy(p,&s,s.len+1)\n\tglobalunlock(h)\n\t\tsetclipboarddata(cf_text,h)\n\tfi\n\n\tcloseclipboard()\n\n\treturn 1\nend\n\nexport func getclipboard=\n!copy text from Windows clipboard\n!return clipboard text, or \"\" when error or not text data available\n\n\tif openclipboard(nil)=0 then\n\t\treturn \"\"\n\tfi\n\n\thtext:=getclipboarddata(cf_text)\n\n\tif not htext then\n\t\treturn \"\"\n\tfi\n\n\tsize:=globalsize(htext)\t\t!should include zero terminator\n\n\tp:=globallock(htext)\n\ts:=makestr(p,size-1)\t\t!assignment should copy the string data\n\n\tglobalunlock(htext)\n\n\tcloseclipboard()\n\treturn s\nend\n\nexport func makewin(pos, dims, fgnd=con_black,bgnd=con_grey,name=\"Anon\")=\n!export func makewin(pos, dims, ?colour)=\n\n\tw:=new(winrec)\n\tw.posx:=pos[1]\n\tw.posy:=pos[2]\n\tw.cols:=dims[1]\n\tw.rows:=dims[2]\n\tw.columns:=1\n\tif dims.len>=3 then\n\t\tw.columns:=dims[3]\n\tfi\n\n!CPL =POS,=DIMS,=W.COLUMNS\n\n\tw.itemcols:=w.cols%w.columns\n\tw.pagesize:=w.rows*w.columns\n\tw.hdata:=nil\n\n\tw.fgnd:=fgnd\n\tw.bgnd:=bgnd\n\tw.name:=name\n\n\treturn w\nend\n\nexport proc clearwin(w)=\n!clear region used by listbox\n!can clear multi-columns at once\n\tspaces:=\" \"*w.cols\n\n\tsetcolour(w.fgnd,w.bgnd)\n\tfor i:=1 to w.rows do\n\t\tshowtext(spaces,w.posx,w.posy+i-1)\n\tod\n\tsetpos(w.posx,w.posy)\nend\n\nexport proc wsetpos(w,col,row)=\n\tsetpos(w.posx+col-1,w.posy+row-1)\nend\n\nexport proc wshowtext(w,s,?col,?row)=\n\tif col.defined then\n\t\tshowtext(s,w.posx+col-1,w.posy+row-1)\n\telse\n\t\tshowtext(s)\n\tfi\nend\n\nexport proc wshowtext_b(w,s, colrow, fgnd,bgnd)=\n!version of wshowtext that dumps into char/attr buffer.\n!w is used for absolute column number\n\n\tif colrow.islist then\n\t\tcol:=colrow[1]\n\telse\n\t\tcol:=colrow\n\tfi\n\n\n\tlength:=s.len\n\toffset:=w.posx-1\t!hoz offset\n\n\tchardata.[(col+offset)..(col-1+length+offset)]:=s\n\n!\tattr:=consolesw.colourmap[bgnd]<<4+consolesw.colourmap[fgnd]\n\tattr:=bgnd<<4+fgnd\n\n\tattrdata.[(col+offset)..(col-1+length+offset)]:=chr(attr)*length\nend\n\nexport proc updateconsolerow(w, row)=\n!write out latest contents to chardata/attrdata to console\n!this represents an entire composite wlineno+wvgap+wedit row, for given row within wedit\n!etc\n\tw_writeconsolerow(chardata,attrdata,screencols,w.posy+row-1)\nend\n\nexport func getkeyname(key)=\n\tcase key.keycode\n\twhen vkleft then name:=\"left\"\n\twhen vkright then name:=\"right\"\n\twhen vkup then name:=\"up\"\n\twhen vkdown then name:=\"down\"\n\twhen vkpageup then name:=\"pageup\"\n\twhen vkpagedown then name:=\"pagedown\"\n\twhen vkhome then name:=\"home\"\n\twhen vkend then name:=\"end\"\n\twhen vkinsert then name:=\"insert\"\n\twhen vkdelete then name:=\"delete\"\n\twhen vktab then name:=\"tab\"\n\twhen vkescape then name:=\"escape\"\n\twhen vkbackspace then name:=\"backspace\"\n\twhen vkenter then name:=\"enter\"\n\twhen vkf1..vkf12 then name:=\"f\"+tostr(key.keycode-vkf1+1)\n\twhen vkspace then name:=\"space\"\n\telse\n\t\tif key.charcode in [1..26] then\t!ctrl code\n\t\t\tname:=chr(key.charcode+'a'-1)\n\t\telsif key.charcode in ['!','\"','\xA3','$','%','^','&','*','(',')','-','_','+','=','[',']',\n\t\t'{','}',':',';','\\'','@','~','#','<','>',',','.','/','\xAC','\xA6','|','\\\\','?'] then\n\t\t\tname:=chr(key.charcode)\n\t\t\tkey.shift iand:=inot shiftmask\t\t!ignore any shift press needed to get char\n\n\t\telsif key.keycode in ['A'..'Z','0'..'9'] then\n\t\t\tif (key.shift iand (ctrlmask ior altmask))=0 then\n\t\t\t\tname:=chr(key.charcode)\n\t\t\t\tkey.shift iand:=inot shiftmask\n\t\t\telse\n\t\t\t\tname:=convlc(chr(key.keycode))\n\t\t\tfi\n\t\telsif key.keycode in (186..223) then\n\t\t\tcase key.keycode\n\t\t\twhen vkminus then name:=\"-\"\n\t\t\twhen vkequals then name:=\"=\"\n\t\t\twhen vklsq then name:=\"[\"\n\t\t\twhen vkrsq then name:=\"]\"\n\t\t\twhen vksemi then name:=\";\"\n\t\t\twhen vkquote then name:=\"'\"\n\t\t\twhen vkhash then name:=\"#\"\n\t\t\twhen vkcomma then name:=\",\"\n\t\t\twhen vkperiod then name:=\".\"\n\t\t\twhen vkslash then name:=\"/\"\n\t\t\twhen vkbackslash then name:=\"\\\\\"\n\t\t\twhen vkbackquote then name:=\"`\"\n\t\t\telse\n\t\t\t\treturn \"?\"\n\t\t\tesac\n\t\telse\n\t\t\treturn \"?\"\n\t\tfi\n\tesac\n\n\tprefix::=\"*\"\n\tif key.shift iand shiftmask then prefix+:=\"s\" fi\n\tif key.shift iand ctrlmask then prefix+:=\"c\" fi\n\tif key.shift iand altmask then prefix+:=\"a\" fi\n\treturn prefix+name\n\nend\n\nexport func keynametokey(name)=\n!given a key name in the format \"*...\", reconstruct an rkey record, and return that\n\tcharcode:=shift:=keycode:=0\n\n\tname:=rightstr(name,-1)\t\t!get rid of \"*\"\n\n\tif name.len=1 then\t\t!simple printable key, no shifts\n\t\tcharcode:=asc(name)\n\t\tgoto simplekey\n\n\telse\t\t\t\t!any letters s,c,a on left indicate a modifier\n\t\twhile name.len>1 do\n\t\t\tcase leftstr(name)\n\t\t\twhen \"s\" then\n\t\t\t\tshift ior:=shiftmask\n\t\t\t\tname:=rightstr(name,-1)\n\t\t\twhen \"c\" then\n\t\t\t\tshift ior:=ctrlmask\n\t\t\t\tname:=rightstr(name,-1)\n\t\t\twhen \"a\" then\n\t\t\t\tshift ior:=altmask\n\t\t\t\tname:=rightstr(name,-1)\n\t\t\telse\n\t\t\t\texit\n\t\t\tesac\n\t\tod\n\n\t\tcase name\n\t\twhen \"left\" then keycode:=vkleft\n\t\twhen \"right\" then keycode:=vkright\n\t\twhen \"up\" then keycode:=vkup\n\t\twhen \"down\" then keycode:=vkdown\n\t\twhen \"pageup\" then keycode:=vkpageup\n\t\twhen \"pagedown\" then keycode:=vkpagedown\n\t\twhen \"home\" then keycode:=vkhome\n\t\twhen \"end\" then keycode:=vkend\n\t\twhen \"insert\" then keycode:=vkinsert\n\t\twhen \"delete\" then keycode:=vkdelete\n\t\twhen \"tab\" then keycode:=charcode:=vktab\n\t\twhen \"escape\" then keycode:=vkescape\n\t\twhen \"backspace\" then keycode:=charcode:=vkbackspace\n\t\twhen \"enter\" then keycode:=charcode:=vkenter\n\t\twhen \"space\" then keycode:=charcode:=vkspace\n\t\telse\n\t\t\tif name.len>=2 and leftstr(name)=\"f\" then\t!function key\n\t\t\t\tkeycode:=vkf1+strtoval(rightstr(name,-1))-1\n\t\t\telsif name.len=1 then\t\t\t\t!ordinary key, but with shifts\n\tsimplekey:\n\t\t\t\tc:=asc(name)\n\t\t\t\tcase c\n\t\t\t\twhen ['A'..'Z'] then\n\t\t\t\t\tkeycode:=c\n\t\t\t\twhen ['a'..'z'] then\n\t\t\t\t\tkeycode:=c-' '\n\t\t\t\twhen ['0'..'9'] then\n\t\t\t\t\tkeycode:=c\n\t\t\t\twhen '-','_' then keycode:=vkminus\n\t\t\t\twhen '=','+' then keycode:=vkequals\n\t\t\t\twhen '[','{' then keycode:=vklsq\n\t\t\t\twhen ']','}' then keycode:=vkrsq\n\t\t\t\twhen ';',':' then keycode:=vksemi\n\t\t\t\twhen '\\'','@' then keycode:=vkquote\n\t\t\t\twhen ',','<' then keycode:=vkcomma\n\t\t\t\twhen '.','>' then keycode:=vkperiod\n\t\t\t\twhen '/','?' then keycode:=vkslash\n\t\t\t\twhen '\\\\','|' then keycode:=vkbackslash\n\t\t\t\twhen '`','\xAC' then keycode:=vkbackquote\n\t\t\t\twhen '#','~' then keycode:=vkhash\n\t\t\t\twhen '!' then keycode:='1'\n\t\t\t\twhen '\"' then keycode:='2'\n\t\t\t\twhen '\xA3' then keycode:='3'\n\t\t\t\twhen '$' then keycode:='4'\n\t\t\t\twhen '%' then keycode:='5'\n\t\t\t\twhen '^' then keycode:='6'\n\t\t\t\twhen '&' then keycode:='7'\n\t\t\t\twhen '*' then keycode:='8'\n\t\t\t\twhen '(' then keycode:='9'\n\t\t\t\twhen ')' then keycode:='0'\n\t\t\t\telse\n\t\t\t\t\tpcerror(\"keynametokey\")\n\t\t\t\tend\n\t\t\tfi\n\t\tesac\n\tfi\n\n\tif shift iand (altmask ior ctrlmask) then\n\t\tcharcode:=0\n\t\tif keycode in 'A'..'Z' then\n\t\t\tcharcode:=keycode-'@'\n\t\tfi\n\tfi\n\n\tkey:=new(rkey)\t\t\t!convert to proper keyrec\n\tkey.charcode:=charcode\n\tkey.shift:=shift\n\tkey.keycode:=keycode\n\treturn key\nend\n\nexport proc clearscreen(?bgnd,?fgnd)=\n\nif bgnd.isvoid then bgnd:=defscreenbgnd fi\nif fgnd.isvoid then fgnd:=defscreenfgnd fi\nsetcolour(fgnd,bgnd)\n\nfor i:=1 to screenrows do\n\tsetpos(1,i)\n\tshowtext(\" \"*screencols)\n!\tshowtext(\"*\"*screencols)\nod\nsetpos(1,1)\nend\n\nexport func readline(?cmdline,donewline=1)=\n!this func doesn't handle tabs properly\n!would need to maintain 2 buffers, one with tabs translated to spaces\n!or convert tabs to another char which is translated back to tabs on exit\n!return with input buffer set to the line, but also returns the complete line\n!newline=1 to end with a newline, 0 to leave it\n\n!readln\n!return\n\n\tbuffer:=\"\"\n\tnchars:=0\n!congetpos()\n\n!NOTE: getpos is dodgy using TERMCON; MAY NEED CALLER TO SPECIFY START POINT\n\t(startx,starty):=(getpos())\n\n\tpos:=0\t\t!with nchars shown, pos can be 0 to nchars\n\n\treenter:\n\tif cmdline.defined and cmdline<>\"\" then\n\t\tbuffer:=cmdline\n\treenter2:\n\t\tpos:=nchars:=buffer.len\n\tfi\n\n\tdo\n! print \"_\"\n\t\trlkey:=0\t\t\t!normal input starts with \"*\" will expect rlkey to be a keyrec\n\t\tsetpos(startx,starty)\n\t\tprint buffer\n\t\tsetpos(startx+pos,starty)\n\n\t\tkey:=getkey()\n\t\tkeycode:=key.keycode\n\t\tkeyshift:=key.shift\n\n\t\tcase keycode\n\t\twhen vkpageup,vkpagedown,vkup,vkdown,vkinsert,vkf1..vkf12 then\n\n\tdospecial:\n\t\trlbuffer:=buffer\n\t\t\toldbufferlen:=buffer.len\t\t!to help erase old buffer\n\t\t\tbuffer:=getkeyname(key)\n\t\t\trlkey:=key\t\t\t\t!allow caller to use key code rather than name\n\t\t\texit\n\n\t\twhen vkleft then\n\t\t\tif buffer=\"\" then goto dospecial fi\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\n\t\t\tif pos>0 then\n\t\t\t\t--pos\n\t\t\tfi\n\n\t\twhen vkhome then\n\t\t\tif buffer=\"\" then goto dospecial fi\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\t\t\tpos:=0\n\n\t\twhen vkend then\n\t\t\tif buffer=\"\" then goto dospecial fi\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\t\t\tpos:=nchars\n\n\t\twhen vkright then\n\t\t\tif buffer=\"\" then goto dospecial fi\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\t\t\tif pos<nchars then\n\t\t\t\t++pos\n\t\t\tfi\n\n\t\twhen vkenter then\n\n!  println\n\t\t\texit\n\n\t\twhen vkbackspace then\n\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\t\t\tif nchars then\n\t\t\t\tsetpos(startx,starty)\n\t\t\t\tprint \" \"*buffer.len\n\n\t\t\t\tcase pos\n\t\t\t\twhen 0 then\t\t\t!not allowed\n\t\t\t\twhen nchars then\t\t!at end\n\t\t\t\t\tbuffer:=leftstr(buffer,-1)\n\t\t\t\t\t--nchars\n\t\t\t\t\t--pos\n\t\t\t\telse\t\t\t\t!in middle\n\t\t\t\t\tbuffer:=leftstr(buffer,pos-1)+rightstr(buffer,-(pos))\n\t\t\t\t\t--nchars\n\t\t\t\t\t--pos\n\t\t\t\tesac\n\n\t\t\tfi\n\n\t\twhen vkdelete then\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\t\t\tif nchars and nchars=pos then\n\t\t\t\tgoto delline\n\t\t\tfi\n\t\t\tif nchars=0 then\n\t\t\t\tgoto dospecial\n\t\t\tfi\n\t\t\tif nchars then\n!CPL \"\\NNCHARS\",=NCHARS,++CCC,=POS,\"\\N\"\n\t\t\t\tsetpos(startx,starty)\n\t\t\t\tprint \" \"*buffer.len\n\n\t\t\t\tcase pos\n\t\t\t\twhen nchars then\t\t!not allowed\n!\t\t\twhen 0 then\t\t\t!at start\n!\t\t\t\tbuffer:=leftstr(buffer,-1)\n!\t\t\t\t--nchars\n\t\t\t\telse\t\t\t\t!in middle\n\t\t\t\t\tbuffer:=leftstr(buffer,pos)+rightstr(buffer,-(pos+1))\n\t\t\t\t\t--nchars\n!    --pos\n\t\t\t\tesac\n\n\t\t\tfi\n\n\t\twhen vkescape then\n\t\t\tif nchars=0 then\n\t\t\t\tgoto dospecial\n!   oldbufferlen:=buffer.len\n!   buffer:=\"*esc\"\n!   exit\n\t\t\tfi\n\tdelline:\n\t\t\tsetpos(startx,starty)\n\t\t\tprint \" \"*buffer.len\n\n\t\t\tbuffer:=\"\"\n\t\t\tnchars:=pos:=0\n\n\t\twhen vktab then\n\t\t\tgoto normalkey\n\n\t\telse\n\tnormalkey:\n\t\t\tif (key.charcode>=' ' or key.charcode=9) then\n\t\t\t\tif pos=0 then\n\t\t\t\t\tbuffer:=chr(key.charcode)+buffer\n\t\t\t\telsif pos=nchars then\n\t\t\t\t\tbuffer:=buffer+chr(key.charcode)\n\t\t\t\telse\n\t\t\t\t\tbuffer:=leftstr(buffer,pos)+chr(key.charcode)+rightstr(buffer,-(pos))\n\t\t\t\tfi\n\t\t\t\t++nchars\n\t\t\t\t++pos\n\t\t\telse\n\t\t\t\tGOTO DOSPECIAL\n\t\t\t\tprint \"<\",keycode,key.charcode,\">\"\n\t\t\tfi\n\n\t\tesac\n\tod\n\n\tcase buffer\n\twhen \"*cup\",\"*cdown\" then\n\t\tif ncmds then\n\t\t\tsetpos(startx,starty)\n\t\t\tprint \" \"*oldbufferlen\n\n\t\t\tif cmdindex=0 then\t\t!get started on last\n\t\t\t\tcmdline:=cmdhistory[ncmds]\n\t\t\t\tcmdindex:=ncmds\n\t\t\t\tgoto reenter\n\t\t\tfi\n\n\t\t\tif buffer=\"*cup\" and cmdindex>1 then\n\t\t\t\t--cmdindex\n\t\t\telsif buffer=\"*cdown\" and cmdindex<ncmds then\n\t\t\t\t++cmdindex\n\t\t\tfi\n\t\t\tcmdline:=cmdhistory[cmdindex]\n\t\t\tgoto reenter\n\t\tfi\n\t\tbuffer:=\"\"\n\t\tgoto reenter2\n\tesac\n\n\tif buffer.len>1 and leftstr(buffer)<>\"*\" then\n\t\tif ncmds=0 or cmdhistory[ncmds]<>buffer then\n\t\t\tcmdhistory[++ncmds]:=buffer\n\t\tfi\n\t\tcmdindex:=0\n\tfi\n\n\tif donewline then println fi\n\n\treturn sreadln(buffer)\nend\n\nexport proc wsetcolumns(w,columns)=\n\tw.columns:=columns\n\tw.itemcols:=w.cols%w.columns\n\tw.pagesize:=w.rows*w.columns\nend\n\n",
(u64)"!!Virtual keycodes\nexport const vklbutton=1\t\t!note these are physical not logical buttons\nexport const vkrbutton=2\nexport const vkmbutton=4\t\t!middle button is correct\nexport const vkbackspace=8\nexport const vktab=9\nexport const vkclear=12\nexport const vkenter=13\nexport const vkshift=16\nexport const vkctrl=17\nexport const vkalt=18\nexport const vkbreak=19\nexport const vkcapslock=20\n!export const vkrshift=21\nexport const vkrctrl=22\n!export const vkralt=23\nexport const vkinslock=24\nexport const vkescape=27\nexport const vkspace=32\nexport const vkpageup=33\nexport const vkpagedown=34\nexport const vkend=35\nexport const vkhome=36\nexport const vkleft=37\nexport const vkup=38\nexport const vkright=39\nexport const vkdown=40\nexport const vkinsert=45\nexport const vkdelete=46\nexport const vkhelp=47\nexport const vk0='0'\nexport const vka='A'\nexport const vkwindows=91\nexport const vkrightbutton=93\nexport const vknumpad0=96\t\t!96..105 = '0'..'9'\nexport const vkmul=106\nexport const vkadd=107\nexport const vksub=109\nexport const vkdecimal=110\nexport const vkdiv=111\nexport const vkf1=112\nexport const vkf2=113\nexport const vkf3=114\nexport const vkf4=115\nexport const vkf5=116\nexport const vkf6=117\nexport const vkf7=118\nexport const vkf8=119\nexport const vkf9=120\nexport const vkf10=121\nexport const vkf11=122\nexport const vkf12=123\n!export const vklsq=128\n!export const vkrsq=129\n!export const vksemi=130\n!export const vkquote=131\n!export const vkstroke=132\n!export const vkdot=133\n!export const vkcomma=134\n!export const vkbackslash=135\n!export const vkquote2=136\n!export const vkequals=137\n!export const vkminus=138\n!export const vkhash=139\nexport const vklshift=160\nexport const vkrshift=161\nexport const vklcontrol=162\nexport const vkrcontrol=163\nexport const vklalt=164\nexport const vkralt=165\n\n!oem codes\nexport const vkminus=189\nexport const vkequals=187\nexport const vklsq=219\nexport const vkrsq=221\nexport const vksemi=186\nexport const vkquote=192\nexport const vkhash=222\nexport const vkcomma=188\nexport const vkperiod=190\nexport const vkslash=191\nexport const vkbackslash=220\nexport const vkbackquote=223\n\n\nexport enumdata\t\trr,     gg,     bb =\n\t(con_black=0,\t0,\t\t0,\t\t0),\n\t(con_dkblue,\t0,\t\t0,\t\t128),\n\t(con_dkred,\t\t128,\t0,\t\t0),\n\t(con_dkmagenta,\t128,\t0,\t\t128),\n\t(con_dkgreen,\t0,\t\t128,\t0),\n\t(con_dkcyan,\t0,\t\t128,\t128),\n\t(con_dkyellow,\t128,\t128,\t0),\n\t(con_dkgrey,\t128,\t128,\t128),\n\t(con_grey,\t\t192,\t192,\t192),\n\t(con_blue,\t\t0,\t\t0,\t\t255),\n\t(con_red,\t\t255,\t0,\t\t0),\n\t(con_magenta,\t255,\t0,\t\t255),\n\t(con_green,\t\t0,\t\t255,\t0),\n\t(con_cyan,\t\t0,\t\t255,\t255),\n\t(con_yellow,\t255,\t255,\t0),\n\t(con_white,\t\t255,\t255,\t255),\nend\n\n\nvar digits=['0'..'9']\nvar navkeys=['A':vkup, 'B':vkdown, 'C': vkright, 'D':vkleft, 'H':vkhome, 'F':vkend,\n\t\t\t\t'P':vkf1, 'Q':vkf2, 'R': vkf3, 'S':vkf4]\n\nvar fnkeys= [15:vkf5, 17:vkf6, 18:vkf7, 19:vkf8, 20:vkf9, 21:vkf10, 23:vkf11, 24:vkf12]\n\nconst capsmask  = 0x8\t\t!shift states as they are in .keyshift\nconst altmask   = 0x4\nconst ctrlmask  = 0x2\nconst shiftmask = 0x1\n\nconst capsbit=3\nconst altbit=2\nconst ctrlbit=1\nconst shiftbit=0\n\nvar shiftcodes = [5:ctrlmask, 2:shiftmask, 3:altmask, 4:shiftmask+altmask, 7:ctrlmask+altmask]\n\nexport var wconscreen\nexport var screencols,screenrows\nexport var currbgnd=-1,currfgnd=-1\n\nexport var chardata\t\t\t!string these two represent row of the console\nexport var attrdata\t\t\t!string\n\nexport var rlkey=0\t\t!set by readline, when special key has been input\nexport var rlbuffer\t\t\t!contents of readline buffer when special key pressed\n\nvar cmdindex,ncmds\nvar cmdhistory\n\n!export var screencolour=con_dkred..con_grey\n\nexport record winrec =\n\tvar posx,posy\n\tvar cols,rows\n\tvar fgnd,bgnd\t\t\t!default text/background colour\n\n\tvar columns\t\t\t!used when divided into columns\n\tvar itemcols\t\t\t!width of each column\n\tvar pagesize\t\t\t!columns*rows\n\n\tvar name\n\n\tvar hdata\t\t\t!pointer to data record, or is nil\nend\n\nexport proc init(cols=100)=\n\tgetdims()\n\n\tcmdhistory::=()\t!\"one\",\"two\",\"three\",\"four\")\n\tncmds:=cmdhistory.upb\n\tcmdindex:=0\n\n\twconscreen:=makewin((1,1),(screencols,screenrows),defscreencolour)\n\nend\n\nproc getdims=\n\t(screencols,screenrows):=getscreensize()\nend\n\nexport proc setpos(column,row)=\n\tfprint \"\\e[#;#H\",row,column\nend\n\nproc setfgndcol(c)=\n\tfprint \"\\e[38;2;#;#;#m\", rr[c], gg[c], bb[c]\nend\n\nproc setbgndcol(c)=\n\tfprint \"\\e[48;2;#;#;#m\", rr[c], gg[c], bb[c]\nend\n\nexport proc setbgndrgb(r,g,b)=\n\tfprint \"\\e[48;2;#;#;#m\", r,g,b\nend\n\nexport proc setbold(bold)=\n\tfprint \"\\e[#m\",(bold|1|21)\nend\n\nexport proc setitalic(italic)=\n\tfprint \"\\e[#m\",(italic|3|23)\nend\n\nexport func getpos=\n\tprint \"\\e[6n\"\n\treadkey()\t\t!escape\n\treadkey()\t\t![\n\n\t(row,column,c):=readkbdsequence()\n\treturn (column,row)\nend\n\nexport func setcursor(?visible)=\n\treturn 1\nend\n\nexport proc setcolour(fgnd, ?bgnd)=\n!call with as (fgnd,bgnd) or as (fgnd..bgnd)\n\n\tif bgnd.isvoid then bgnd:=currbgnd fi\n\n\tif fgnd<>currfgnd then\n\t\tsetfgndcol(fgnd)\n\t\tcurrfgnd:=fgnd\n\tfi\n\n\tif bgnd<>currbgnd then\n\t\tsetbgndcol(bgnd)\n\t\tcurrbgnd:=bgnd\n\tfi\nend\n\nexport proc settitle(caption)=\nend\n\nexport func keyready=\n\treturn pcerror(\"Linux/keyready\")\nend\n\n!export proc showtext(s)=\n!\tif s then\n!\t\tprint s\n!\tfi\n!end\n\nexport proc showtext(s,?x,?y)=\n\n\tif x.defined then\n\t\tsetpos(x,y)\n\tfi\n\n\tcount:=0\n\tif s then\n!\t\tif not suppress then\n\t\t\tprint s\n!\t\t\twriteconsole(hconsole,s,s.len,&count,nil)\n!\t\tfi\n\tfi\nend\n\nexport proc setdims(cols,rows)=\n\tpcerror(\"linux/setdims\")\nend\n\nexport proc setpalette(index,colour)=\n\tpcerror(\"linux/setpallete\")\nend\n\nfunc getscreensize=\n\tsavepos()\n\tsetpos(999,999)\n\t(cols,rows):=getpos()\n\trestorepos()\n\treturn (cols,rows)\nend\n\nproc savepos=\n\tprint \"\\e[s\"\nend\n\nproc restorepos=\n\tprint \"\\e[u\"\nend\n\nfunc readkey=\n\treturn waitkey()\nend\n\nfunc readintseq(c)=\n!c is '0' to '9'\n!read integer sequence up to first non-digit\n!return (number, terminator character)\n\tx:=c-'0'\n\tdo\n\t\tc:=readkey()\n\t\tif c in digits then\n\t\t\tx:=x*10+c-'0'\n\t\telse\n\t\t\texit\n\t\tfi\n\tod\n\treturn (x,c)\nend\n\nfunc readkbdsequence=\n!Some key escape sequences for control chars in Linux look like this:\n! <esc> \"[\" [x[\";\"y] c/\"~\"\n!Parts in \"...\" are actual characters\n!x and y are optional integers, c is a capital letter\n!The sequence may have 0, 1 or 2 numbers (separated with ;) and end with\n!a capital letter, or \"~\"\n!the \"[\" has already been read\n!return (X, Y, C)\n!X or Y will be zero if not present. C will 'A' etc, or 0 if it ends with \"~\"\n!-1 is returned on error\n\n\tx:=y:=0\n\n\tc:=readkey()\n\n\tif c in digits then\n\t\t(x,c):=readintseq(c)\n\t\tif c=';' then\n\t\t\tc:=readkey()\n\t\t\tif c not in digits then return -1 fi\n\t\t\t(y,c):=readintseq(c)\n\t\tfi\n\tfi\n\n\tif c='~' then\n\t\treturn (x,y,0)\n\tfi\n\treturn (x,y,c)\t\t\t\t!assume A-Z\nend\n\n!function keyname(k,shift=0)=\n!return getkeyname(rkey(0,k,shift))\n!end\n\nexport func getkey=\n!read key events via readkey()\n!convert escape sequences to Windows virtual keys\n\n\tk:=readkey()\t\t\t\t!LINUX ONLY\n\n!CPL \"<<<<<\",K,\">>>>>\"\n\n\tcase k\n\twhen 10 then\n\t\treturn rkey(13,vkenter,0)\n\twhen 8 then\n\t\treturn rkey(127, vkbackspace, ctrlmask)\n\twhen 127 then\n\t\treturn rkey(127, vkbackspace, 0)\n\twhen 9 then\n!\tCPL \"TAB1\"\n\t\treturn rkey(vktab,vktab,0)\n\twhen 'A'..'Z', '0'..'9', ' ' then\n\t\treturn rkey(k,k,0)\n\twhen 'a'..'z' then\n\t\treturn rkey(k,k-' ',0)\n\twhen 27 then\n\twhen 1..31 then\n\t\treturn rkey(k,0,ctrlmask)\n\telse\n\t\tc:=k\n\t\tcase k\n\t\twhen '[','{' then k:=vklsq\n\t\twhen ']','}' then k:=vkrsq\n\t\telse\n\t\t\tk:=0\n\t\tesac\n\n\t\treturn rkey(c,k,0)\n\tesac\n\n!CPL \"ESC SEEN\"\n\n!escape seen; look at next key\n\tk:=readkey()\n\n\tcase k\n\twhen 27 then\t\t\t!esc/esc => single escape\n\t\treturn rkey(0,k,0)\n\n\twhen 10 then\t\t\t!esc/10 => alt enter\n\t\treturn rkey(0,vkenter,altmask)\n\n\twhen 8,127 then\t\t\t!esc/bs => alt bs\n\t\treturn rkey(0,vkbackspace,altmask)\n\n\twhen 'O' then\t\t\t!short set of function keys\n\t\t(x,y,c):=readkbdsequence()\n\n!\tCPL \"O\",x,y,chr(c)\n\t\treturn rkey(0,navkeys{c},shiftcodes{y,0})\n\n\twhen '[' then\n\t\t(x,y,c):=readkbdsequence()\n\n\t\tcase c\n\t\twhen 'Z' then\t\t\t\t\t\t!shift+tab\n\t\t\treturn rkey(9,9,shiftmask)\n!\t\treturn rkey(0,9,shiftmask)\n\t\twhen 'A','B','C','D','H','F','P','Q','R','S' then\t\t!cursor keys, fn1..4; assume x=1\n\t\t\treturn rkey(0,navkeys{c},shiftcodes{y,0})\n\t\tesac\n\n\t\tcase x\n\t\twhen 2,3,5,6 then\n\t\t\tshift:=0\n\t\t\tcase y\n\t\t\twhen 5 then shift:=ctrlmask\n\t\t\twhen 3 then shift:=altmask\n\t\t\twhen 7 then shift:=altmask+ctrlmask\n\t\t\tesac\n\t\t\treturn rkey(0,(x|0,vkinsert,vkdelete,0,vkpageup|vkpagedown),shift)\n\t\twhen 15..24 then\n\t\t\treturn rkey(0,fnkeys{x},shiftcodes{y,0})\n\t\tesac\n\n\twhen 'A'..'Z' then\t\t\t!must have been alt version (some esc letter codes above)\n\t\treturn rkey(k-64,0,altmask) \n\n\twhen 'a'..'z' then\t\t\t!must have been alt version (some esc letter codes above)\n\t\treturn rkey(k-96,0,altmask) \n\n\twhen '0'..'9' then\n\t\treturn rkey(0,k,altmask) \n\n\tesac\n!\tCPL \"ESC 91\"\n\n!Code 91 SEEN\n\treturn rkey(0,'?',0)\nend\n\nproc screentest=\n\n\tsavepos()\n\tsetpos(10,10)\n\tsetfgndcol(5)\n\tsetbgndcol(3)\n\tsetbold(1)\n\tsetitalic(1)\n\tprintln \"\tHELLO\t\"\n\tsetbold(0)\n\tsetitalic(0)\n\trestorepos()\n\tprintln \"\tGoodbye\t\"\n\n\t(cols,rows):=getscreensize()\n\tcpl =rows,=cols\n\twaitkey()\nend\n\n!proc keytest=\n!\n!lastkey:=0\n!\n!!do\n!!\tk:=readkey()\n!!\tif k=27 and lastkey=27 then exit fi\n!!\tif k=27 then\n!!\t\tcpl\n!!\t\tcp \"ESC \"\n!!\telsif k in 32..126 then\n!!\t\tcp chr(k)\n!!\telse\n!!\t\tcp \"<\"+tostr(k)+\">\"\n!!\tfi\n!!\tlastkey:=k\n!!od\n!\n!do\n!\tk:=getkey()\n!\tcpl getkeyname(k),k\n!\tif k.keycode=27 then exit fi\n!od\n!\n!end\n\nproc keyscreentest=\n\t(cols,rows):=getscreensize()\n\tCPL =COLS,=ROWS\n\n\trow:=rows%2\n\tcol:=cols%2\n\tch:=\"X\"\n\n\tsetfgndcol(6)\n\tsetbgndcol(1)\n\n\tdo\n\t\tsetpos(col,row)\n\t\tcp ch\n\t\tsetpos(col,row)\n\t\tk:=getkey().keycode\n\t\tcase k\n\t\twhen 27 then\n\t\t\texit\n\t\twhen vkleft then col:=max(1,col-1)\n\t\twhen vkright then col:=min(cols,col+1)\n\t\twhen vkup then row:=max(1,row-1)\n\t\twhen vkdown then row:=min(rows,row+1)\n\t\tesac\n\tod\n\n!\twaitkey()\n\nend\n\nproc main=\n\n!\tkeytest()\n!\tscreentest()\n\tkeyscreentest()\nend\n\nproc start=\n!CPL \"LINCON START\"\n\tif not iswindows() then\n\t\tinit()\n\tfi\nend\n\nexport proc w_writeconsolerow(text, attributes, length, row)=\n!pcerror(\"lincon/writeconsolerow\")\n!buffersize:=1<<16+length\n!coord:=0\n\n!setpos(1,row)\n!print leftstr(text,length)\n\n\tsetpos(1,row)\n\tfor i:=1 to length-1 do\n\t\tattrs:=attributes.[i]\n\t\tc:=text.[i]\n\t!\tsetcolour(attrs>>4, attrs iand 15)\n\t\tsetcolour(attrs iand 15, attrs>>4)\n\t\tprint chr(c)\n\tod\nend\n\nexport proc flushkeyboard=\n\ttcflush(0, 0)\nend\n\nexport func setclipboard(s)=\n\tabort(\"linux/setclipboard\")\n\treturn 0\nend\n\nexport func getclipboard=\n\tabort(\"linux/getclipboard\")\n\treturn \"\"\nend\n\nexport proc clearscreen(?bgnd,?fgnd)=\n\n\tsystem(\"clear\")\nend\n\nexport func makewin(pos, dims, fgnd=con_black,bgnd=con_grey,name=\"Anon\")=\n!export func makewin(pos, dims, ?colour)=\n\n\tw:=new(winrec)\n\tw.posx:=pos[1]\n\tw.posy:=pos[2]\n\tw.cols:=dims[1]\n\tw.rows:=dims[2]\n\tw.columns:=1\n\tif dims.len>=3 then\n\t\tw.columns:=dims[3]\n\tfi\n\n!CPL =POS,=DIMS,=W.COLUMNS\n\n\tw.itemcols:=w.cols%w.columns\n\tw.pagesize:=w.rows*w.columns\n\tw.hdata:=nil\n\n\tw.fgnd:=fgnd\n\tw.bgnd:=bgnd\n\tw.name:=name\n\n\treturn w\nend\n\nexport proc clearwin(w)=\n!clear region used by listbox\n!can clear multi-columns at once\n\tspaces:=\" \"*w.cols\n\n\tsetcolour(w.fgnd,w.bgnd)\n\tfor i:=1 to w.rows do\n\t\tshowtext(spaces,w.posx,w.posy+i-1)\n\tod\n\tsetpos(w.posx,w.posy)\nend\n\nexport proc wshowtext(w,s,?col,?row)=\n\tif col.defined then\n\t\tshowtext(s,w.posx+col-1,w.posy+row-1)\n\telse\n\t\tshowtext(s)\n\tfi\nend\n\nexport proc wsetpos(w,col,row)=\n\tsetpos(w.posx+col-1,w.posy+row-1)\nend\n\nexport proc wshowtext_b(w,s,colrow,fgnd,bgnd)=\n!version of wshowtext that dumps into char/attr buffer.\n!w is used for absolute column number\n\n\tif colrow.islist then\n\t\t(col, row):=colrow\n\telse\n\t\tcol:=colrow\n\t\tROW:=1\n\tfi\n\n\tsetcolour(fgnd, bgnd)\n\n\twshowtext(w,s, col, row)\n!\tshowtext(s, col, row)\n\n\n!\tlength:=s.len\n!\toffset:=w.posx-1\t!hoz offset\n!\n!!CPL =CHARDATA\n!\n!\tchardata.[(col+offset)..(col-1+length+offset)]:=s\n!\n!!\tattr:=consolesw.colourmap[bgnd]<<4+consolesw.colourmap[fgnd]\n!\tattr:=bgnd<<4+fgnd\n!\n!\tattrdata.[(col+offset)..(col-1+length+offset)]:=chr(attr)*length\nend\n\nexport proc updateconsolerow(w,row)=\n!write out latest contents to chardata/attrdata to console\n!this represents an entire composite wlineno+wvgap+wedit row, for given row within wedit\n!etc\n!\tw_writeconsolerow(chardata,attrdata,screencols,row)\nend\n\nexport func getkeyname(key)=\n\tcase key.keycode\n\twhen vkleft then name:=\"left\"\n\twhen vkright then name:=\"right\"\n\twhen vkup then name:=\"up\"\n\twhen vkdown then name:=\"down\"\n\twhen vkpageup then name:=\"pageup\"\n\twhen vkpagedown then name:=\"pagedown\"\n\twhen vkhome then name:=\"home\"\n\twhen vkend then name:=\"end\"\n\twhen vkinsert then name:=\"insert\"\n\twhen vkdelete then name:=\"delete\"\n\twhen vktab then name:=\"tab\"\n\twhen vkescape then name:=\"escape\"\n\twhen vkbackspace then name:=\"backspace\"\n\twhen vkenter then name:=\"enter\"\n\twhen vkf1..vkf12 then name:=\"f\"+tostr(key.keycode-vkf1+1)\n\twhen vkspace then name:=\"space\"\n\telse\n\t\tif key.charcode in [1..26] then\t!ctrl code\n\t\t\tname:=chr(key.charcode+'a'-1)\n\t\telsif key.charcode in ['!','\"','\xA3','$','%','^','&','*','(',')','-','_','+','=','[',']',\n\t\t'{','}',':',';','\\'','@','~','#','<','>',',','.','/','\xAC','\xA6','|','\\\\','?'] then\n\t\t\tname:=chr(key.charcode)\n\t\t\tkey.shift iand:=inot shiftmask\t\t!ignore any shift press needed to get char\n\n\t\telsif key.keycode in ['A'..'Z','0'..'9'] then\n\t\t\tif (key.shift iand (ctrlmask ior altmask))=0 then\n\t\t\t\tname:=chr(key.charcode)\n\t\t\t\tkey.shift iand:=inot shiftmask\n\t\t\telse\n\t\t\t\tname:=convlc(chr(key.keycode))\n\t\t\tfi\n\t\telsif key.keycode in (186..223) then\n\t\t\tcase key.keycode\n\t\t\twhen vkminus then name:=\"-\"\n\t\t\twhen vkequals then name:=\"=\"\n\t\t\twhen vklsq then name:=\"[\"\n\t\t\twhen vkrsq then name:=\"]\"\n\t\t\twhen vksemi then name:=\";\"\n\t\t\twhen vkquote then name:=\"'\"\n\t\t\twhen vkhash then name:=\"#\"\n\t\t\twhen vkcomma then name:=\",\"\n\t\t\twhen vkperiod then name:=\".\"\n\t\t\twhen vkslash then name:=\"/\"\n\t\t\twhen vkbackslash then name:=\"\\\\\"\n\t\t\twhen vkbackquote then name:=\"`\"\n\t\t\telse\n\t\t\t\treturn \"?\"\n\t\t\tesac\n\t\telse\n\t\t\treturn \"?\"\n\t\tfi\n\tesac\n\n\tprefix::=\"*\"\n\tif key.shift iand shiftmask then prefix+:=\"s\" fi\n\tif key.shift iand ctrlmask then prefix+:=\"c\" fi\n\tif key.shift iand altmask then prefix+:=\"a\" fi\n\treturn prefix+name\n\nend\n\nexport func readline(?cmdline,donewline=1)=\n!this func doesn't handle tabs properly\n!would need to maintain 2 buffers, one with tabs translated to spaces\n!or convert tabs to another char which is translated back to tabs on exit\n!return with input buffer set to the line, but also returns the complete line\n!newline=1 to end with a newline, 0 to leave it\n\n!readln\n!return\n\n\tbuffer:=\"\"\n\tnchars:=0\n!congetpos()\n\n!NOTE: getpos is dodgy using TERMCON; MAY NEED CALLER TO SPECIFY START POINT\n\t(startx,starty):=(getpos())\n\n\tpos:=0\t\t!with nchars shown, pos can be 0 to nchars\n\n\treenter:\n\tif cmdline.defined and cmdline<>\"\" then\n\t\tbuffer:=cmdline\n\treenter2:\n\t\tpos:=nchars:=buffer.len\n\tfi\n\n\tdo\n! print \"_\"\n\t\trlkey:=0\t\t\t!normal input starts with \"*\" will expect rlkey to be a keyrec\n\t\tsetpos(startx,starty)\n\t\tprint buffer\n\t\tsetpos(startx+pos,starty)\n\n\t\tkey:=getkey()\n\t\tkeycode:=key.keycode\n\t\tkeyshift:=key.shift\n\n\t\tcase keycode\n\t\twhen vkpageup,vkpagedown,vkup,vkdown,vkinsert,vkf1..vkf12 then\n\n\tdospecial:\n\t\trlbuffer:=buffer\n\t\t\toldbufferlen:=buffer.len\t\t!to help erase old buffer\n\t\t\tbuffer:=getkeyname(key)\n\t\t\trlkey:=key\t\t\t\t!allow caller to use key code rather than name\n\t\t\texit\n\n\t\twhen vkleft then\n\t\t\tif buffer=\"\" then goto dospecial fi\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\n\t\t\tif pos>0 then\n\t\t\t\t--pos\n\t\t\tfi\n\n\t\twhen vkhome then\n\t\t\tif buffer=\"\" then goto dospecial fi\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\t\t\tpos:=0\n\n\t\twhen vkend then\n\t\t\tif buffer=\"\" then goto dospecial fi\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\t\t\tpos:=nchars\n\n\t\twhen vkright then\n\t\t\tif buffer=\"\" then goto dospecial fi\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\t\t\tif pos<nchars then\n\t\t\t\t++pos\n\t\t\tfi\n\n\t\twhen vkenter then\n\n!  println\n\t\t\texit\n\n\t\twhen vkbackspace then\n\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\t\t\tif nchars then\n\t\t\t\tsetpos(startx,starty)\n\t\t\t\tprint \" \"*buffer.len\n\n\t\t\t\tcase pos\n\t\t\t\twhen 0 then\t\t\t!not allowed\n\t\t\t\twhen nchars then\t\t!at end\n\t\t\t\t\tbuffer:=leftstr(buffer,-1)\n\t\t\t\t\t--nchars\n\t\t\t\t\t--pos\n\t\t\t\telse\t\t\t\t!in middle\n\t\t\t\t\tbuffer:=leftstr(buffer,pos-1)+rightstr(buffer,-(pos))\n\t\t\t\t\t--nchars\n\t\t\t\t\t--pos\n\t\t\t\tesac\n\n\t\t\tfi\n\n\t\twhen vkdelete then\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\t\t\tif nchars and nchars=pos then\n\t\t\t\tgoto delline\n\t\t\tfi\n\t\t\tif nchars=0 then\n\t\t\t\tgoto dospecial\n\t\t\tfi\n\t\t\tif nchars then\n!CPL \"\\NNCHARS\",=NCHARS,++CCC,=POS,\"\\N\"\n\t\t\t\tsetpos(startx,starty)\n\t\t\t\tprint \" \"*buffer.len\n\n\t\t\t\tcase pos\n\t\t\t\twhen nchars then\t\t!not allowed\n!\t\t\twhen 0 then\t\t\t!at start\n!\t\t\t\tbuffer:=leftstr(buffer,-1)\n!\t\t\t\t--nchars\n\t\t\t\telse\t\t\t\t!in middle\n\t\t\t\t\tbuffer:=leftstr(buffer,pos)+rightstr(buffer,-(pos+1))\n\t\t\t\t\t--nchars\n!    --pos\n\t\t\t\tesac\n\n\t\t\tfi\n\n\t\twhen vkescape then\n\t\t\tif nchars=0 then\n\t\t\t\tgoto dospecial\n!   oldbufferlen:=buffer.len\n!   buffer:=\"*esc\"\n!   exit\n\t\t\tfi\n\tdelline:\n\t\t\tsetpos(startx,starty)\n\t\t\tprint \" \"*buffer.len\n\n\t\t\tbuffer:=\"\"\n\t\t\tnchars:=pos:=0\n\n\t\twhen vktab then\n\t\t\tgoto normalkey\n\n\t\telse\n\tnormalkey:\n\t\t\tif (key.charcode>=' ' or key.charcode=9) then\n\t\t\t\tif pos=0 then\n\t\t\t\t\tbuffer:=chr(key.charcode)+buffer\n\t\t\t\telsif pos=nchars then\n\t\t\t\t\tbuffer:=buffer+chr(key.charcode)\n\t\t\t\telse\n\t\t\t\t\tbuffer:=leftstr(buffer,pos)+chr(key.charcode)+rightstr(buffer,-(pos))\n\t\t\t\tfi\n\t\t\t\t++nchars\n\t\t\t\t++pos\n\t\t\telse\n\t\t\t\tGOTO DOSPECIAL\n\t\t\t\tprint \"<\",keycode,key.charcode,\">\"\n\t\t\tfi\n\n\t\tesac\n\tod\n\n\tcase buffer\n\twhen \"*cup\",\"*cdown\" then\n\t\tif ncmds then\n\t\t\tsetpos(startx,starty)\n\t\t\tprint \" \"*oldbufferlen\n\n\t\t\tif cmdindex=0 then\t\t!get started on last\n\t\t\t\tcmdline:=cmdhistory[ncmds]\n\t\t\t\tcmdindex:=ncmds\n\t\t\t\tgoto reenter\n\t\t\tfi\n\n\t\t\tif buffer=\"*cup\" and cmdindex>1 then\n\t\t\t\t--cmdindex\n\t\t\telsif buffer=\"*cdown\" and cmdindex<ncmds then\n\t\t\t\t++cmdindex\n\t\t\tfi\n\t\t\tcmdline:=cmdhistory[cmdindex]\n\t\t\tgoto reenter\n\t\tfi\n\t\tbuffer:=\"\"\n\t\tgoto reenter2\n\tesac\n\n\tif buffer.len>1 and leftstr(buffer)<>\"*\" then\n\t\tif ncmds=0 or cmdhistory[ncmds]<>buffer then\n\t\t\tcmdhistory[++ncmds]:=buffer\n\t\tfi\n\t\tcmdindex:=0\n\tfi\n\n\tif donewline then println fi\n\n\treturn sreadln(buffer)\nend\n\nexport proc wsetcolumns(w,columns)=\n\tw.columns:=columns\n\tw.itemcols:=w.cols%w.columns\n\tw.pagesize:=w.rows*w.columns\nend\n\n",
(u64)"!Windows win32 constants\n\nglobal const driverversion =  0\nglobal const technology =  2\nglobal const horzsize =  4\nglobal const vertsize =  6\nglobal const horzres =  8\nglobal const vertres =  10\nglobal const bitspixel =  12\nglobal const bitplanes =  14\nglobal const numbrushes =  16\nglobal const numpens =  18\nglobal const nummarkers =  20\nglobal const numfonts =  22\nglobal const numcolours =  24\nglobal const pdevicesize =  26\nglobal const curvecaps =  28\nglobal const linecaps =  30\nglobal const polygonalcaps =  32\nglobal const textcaps =  34\nglobal const clipcaps =  36\nglobal const rastercaps =  38\nglobal const aspectx =  40\nglobal const aspecty =  42\nglobal const aspectxy =  44\nglobal const logpixelsx =  88\nglobal const logpixelsy =  90\nglobal const sizepalette =  104\nglobal const numreserved =  106\nglobal const colourres =  108\nglobal const physicalwidth =  110\nglobal const physicalheight =  111\nglobal const physicaloffsetx =  112\nglobal const physicaloffsety =  113\nglobal const scalingfactorx =  114\nglobal const scalingfactory =  115\nglobal const fw_dontcare =  0\nglobal const fw_thin =  100\nglobal const fw_extralight =  200\nglobal const fw_ultralight =  200\nglobal const fw_light =  300\nglobal const fw_normal =  400\nglobal const fw_regular =  400\nglobal const fw_medium =  500\nglobal const fw_semibold =  600\nglobal const fw_demibold =  600\nglobal const fw_bold =  700\nglobal const fw_extrabold =  800\nglobal const fw_ultrabold =  800\nglobal const fw_heavy =  900\nglobal const fw_black =  900\nglobal const cs_vredraw =  1\nglobal const cs_hredraw =  2\nglobal const cs_keycvtwindow =  4\nglobal const cs_dblclks =  8\nglobal const cs_owndc =  32\nglobal const cs_classdc =  64\nglobal const cs_parentdc =  128\nglobal const cs_nokeycvt =  256\nglobal const cs_noclose =  512\nglobal const cs_savebits =  2048\nglobal const cs_bytealignclient =  4096\nglobal const cs_bytealignwindow =  8192\nglobal const cs_publicclass =  16384\nglobal const sw_hide =  0\nglobal const sw_shownormal =  1\nglobal const sw_normal =  1\nglobal const sw_showminimized =  2\nglobal const sw_showmaximized =  3\nglobal const sw_maximize =  3\nglobal const sw_shownoactivate =  4\nglobal const sw_show =  5\nglobal const sw_minimize =  6\nglobal const sw_showminnoactive =  7\nglobal const sw_showna =  8\nglobal const sw_restore =  9\nglobal const sw_showdefault =  10\nglobal const sw_max =  10\nglobal const pm_noremove =  0\nglobal const pm_remove =  1\nglobal const pm_noyield =  2\nglobal const wm_null =  0\nglobal const wm_create =  1\nglobal const wm_destroy =  2\nglobal const wm_move =  3\nglobal const wm_size =  5\nglobal const wm_activate =  6\nglobal const wa_inactive =  0\nglobal const wa_active =  1\nglobal const wa_clickactive =  2\nglobal const wm_setfocus =  7\nglobal const wm_killfocus =  8\nglobal const wm_enable =  10\nglobal const wm_setredraw =  11\nglobal const wm_settext =  12\nglobal const wm_gettext =  13\nglobal const wm_gettextlength =  14\nglobal const wm_paint =  15\nglobal const wm_close =  16\nglobal const wm_queryendsession =  17\nglobal const wm_quit =  18\nglobal const wm_queryopen =  19\nglobal const wm_erasebkgnd =  20\nglobal const wm_syscolourchange =  21\nglobal const wm_endsession =  22\nglobal const wm_showwindow =  24\nglobal const wm_wininichange =  26\nglobal const wm_devmodechange =  27\nglobal const wm_activateapp =  28\nglobal const wm_fontchange =  29\nglobal const wm_timechange =  30\nglobal const wm_cancelmode =  31\nglobal const wm_setcursor =  32\nglobal const wm_mouseactivate =  33\nglobal const wm_childactivate =  34\nglobal const wm_queuesync =  35\nglobal const wm_getminmaxinfo =  36\nglobal const wm_drawitem =  43\nglobal const wm_notify =  78\nglobal const wm_contextmenu =  123\nglobal const wm_geticon =  127\nglobal const wm_seticon =  128\nglobal const wm_nchittest =  132\n\nglobal const wm_nclbuttondown\t= 161\nglobal const wm_nclbuttonup\t= 162\nglobal const wm_nclbuttondblclick\t= 163\n\nglobal const wm_menurbuttonup\t= 290\n\nglobal const wm_parentnotify =  528\nglobal const wm_dropfiles =  563\nglobal const wm_enteridle =  289\nglobal const wm_user =  1024\nglobal const wm_mdicreate =  544\nglobal const wm_mdidestroy =  545\nglobal const wm_mdiactivate =  546\nglobal const wm_mdirestore =  547\nglobal const wm_mdinext =  548\nglobal const wm_mdimaximize =  549\nglobal const wm_mditile =  550\nglobal const wm_mdicascade =  551\nglobal const wm_mdiiconarange =  552\nglobal const wm_mdigetactive =  553\nglobal const wm_mdisetmenu =  560\nglobal const wm_entersizemove =  561\nglobal const wm_exitsizemove =  562\nglobal const wm_mdirefrshmenu =  564\nglobal const wm_lbuttondblclk =  515\nglobal const wm_rbuttondblclk =  518\nglobal const wm_lbuttondown =  513\nglobal const wm_rbuttondown =  516\nglobal const wm_mbuttondown =  519\nglobal const wm_mousemove =  512\nglobal const wm_lbuttonup =  514\nglobal const wm_rbuttonup =  517\nglobal const wm_mbuttonup =  520\nglobal const wm_mbuttondblclk =  521\nglobal const wm_mousewheel =  522\nglobal const snd_filename =  131072\nglobal const snd_async =  1\nglobal const dt_singleline =  32\nglobal const dt_centre =  1\nglobal const dt_vcentre =  4\nglobal const ws_overlapped =  0\nglobal const ws_popup =  2147483648\nglobal const ws_child =  1073741824\nglobal const ws_minimize =  536870912\nglobal const ws_visible =  268435456\nglobal const ws_disabled =  134217728\nglobal const ws_clipsiblings =  67108864\nglobal const ws_clipchildren =  33554432\nglobal const ws_maximize =  16777216\nglobal const ws_caption =  12582912\nglobal const ws_border =  8388608\nglobal const ws_dlgframe =  4194304\nglobal const ws_hscroll =  1048576\nglobal const ws_vscroll =  2097152\nglobal const ws_sysmenu =  524288\nglobal const ws_thickframe =  262144\nglobal const ws_group =  131072\nglobal const ws_tabstop =  0\nglobal const ws_scrollbars =  3145728\nglobal const ws_minimizebox =  131072\nglobal const ws_maximizebox =  65536\nglobal const ws_tiled =  0\nglobal const ws_iconic =  536870912\nglobal const ws_sizebox =  262144\nglobal const ws_overlappedwindow =  13565952\nglobal const ws_tiledwindow =  13565952\nglobal const ws_popupwindow =  -2138570752\nglobal const ws_childwindow =  1073741824\nglobal const ws_ex_acceptfiles =  16\nglobal const ws_ex_appwindow =  262144\nglobal const ws_ex_clientedge =  512\nglobal const ws_ex_contexthelp =  1024\nglobal const ws_ex_controlparent =  65536\nglobal const ws_ex_dlgmodalframe =  1\nglobal const ws_ex_left =  0\nglobal const ws_ex_leftscrollbar =  16384\nglobal const ws_ex_ltrreading =  0\nglobal const ws_ex_mdichild =  64\nglobal const ws_ex_noparentnotify =  4\nglobal const ws_ex_overlappedwindow =  768\nglobal const ws_ex_palettewindow =  392\nglobal const ws_ex_right =  4096\nglobal const ws_ex_rightscrollbar =  0\nglobal const ws_ex_rtlreading =  8192\nglobal const ws_ex_staticedge =  131072\nglobal const ws_ex_toolwindow =  128\nglobal const ws_ex_topmost =  8\nglobal const ws_ex_transparent =  32\nglobal const ws_ex_windowedge =  256\n\nglobal const gw_hwndfirst =  0\nglobal const gw_hwndlast =  1\nglobal const gw_hwndnext =  2\nglobal const gw_hwndprev =  3\nglobal const gw_owner =  4\nglobal const gw_child =  5\nglobal const gw_enabledpopup =  6\nglobal const cb_geteditsel =  320\nglobal const cb_limittext =  321\nglobal const cb_seteditsel =  322\nglobal const cb_addstring =  323\nglobal const cb_deletestring =  324\nglobal const cb_dir =  325\nglobal const cb_getcount =  326\nglobal const cb_getcursel =  327\nglobal const cb_getlbtext =  328\nglobal const cb_getlbtextlen =  329\nglobal const cb_insertstring =  330\nglobal const cb_resetcontent =  331\nglobal const cb_findstring =  332\nglobal const cb_findstringexact =  344\nglobal const cb_selectstring =  333\nglobal const cb_setcursel =  334\nglobal const cb_showdropdown =  335\nglobal const cb_getitemdata =  336\nglobal const cb_setitemdata =  337\nglobal const cb_getdroppedcontrolrect =  338\nglobal const cb_setitemheight =  339\nglobal const cb_getitemheight =  340\nglobal const cb_setextendedui =  341\nglobal const cb_getextendedui =  342\nglobal const cb_getdroppedstate =  343\nglobal const cb_setlocale =  345\nglobal const cb_getlocale =  346\nglobal const cb_gettopindex =  347\nglobal const cb_settopindex =  348\nglobal const cb_gethorizontalextent =  349\nglobal const cb_sethorizontalextent =  350\nglobal const cb_getdroppedwidth =  351\nglobal const cb_setdroppedwidth =  352\nglobal const cb_initstorage =  353\nglobal const cb_multipleaddstring =  355\nglobal const bm_click =  245\nglobal const bm_getcheck =  240\nglobal const bm_getimage =  246\nglobal const bm_getstate =  242\nglobal const bm_setcheck =  241\nglobal const bm_setimage =  247\nglobal const bm_setstate =  243\nglobal const bm_setstyle =  244\nglobal const cf_bitmap =  2\nglobal const cf_dib =  8\nglobal const cf_palette =  9\nglobal const cf_enhmetafile =  14\nglobal const cf_metafilepict =  3\nglobal const cf_oemtext =  7\nglobal const cf_text =  1\t\t\t!used in sys\nglobal const cf_unicodetext =  13\nglobal const cf_dif =  5\nglobal const cf_dspbitmap =  130\nglobal const cf_dspenhmetafile =  142\nglobal const cf_dspmetafilepict =  131\nglobal const cf_dsptext =  129\nglobal const cf_gdiobjfirst =  768\nglobal const cf_gdiobjlast =  1023\nglobal const cf_hdrop =  15\nglobal const cf_locale =  16\nglobal const cf_ownerdisplay =  128\nglobal const cf_pendata =  10\nglobal const cf_privatefirst =  512\nglobal const cf_privatelast =  767\nglobal const cf_riff =  11\nglobal const cf_sylk =  4\nglobal const cf_wave =  12\nglobal const cf_tiff =  6\n\nglobal const tcif_text =  1\nglobal const tcif_image =  2\nglobal const tcif_param =  8\nglobal const tcif_rtlreading =  4\n\nglobal const wm_keydown =  256\nglobal const wm_keyup =  257\nglobal const wm_char =  258\nglobal const wm_syschar =  262\nglobal const wm_sysdeadchar =  263\nglobal const wm_syskeydown =  260\nglobal const wm_syskeyup =  261\nglobal const mf_insert =  0\nglobal const mf_change =  128\nglobal const mf_append =  256\nglobal const mf_delete =  512\nglobal const mf_remove =  4096\nglobal const mf_bycommand =  0\nglobal const mf_byposition =  1024\nglobal const mf_separator =  2048\nglobal const mf_enabled =  0\nglobal const mf_grayed =  1\nglobal const mf_greyed =  1\nglobal const mf_disabled =  2\nglobal const mf_unchecked =  0\nglobal const mf_checked =  8\nglobal const mf_usecheckbitmaps =  512\nglobal const mf_string =  0\nglobal const mf_bitmap =  4\nglobal const mf_ownerdraw =  256\nglobal const mf_popup =  16\nglobal const mf_menubarbreak =  32\nglobal const mf_menubreak =  64\nglobal const mf_unhilite =  0\nglobal const mf_hilite =  128\nglobal const mf_sysmenu =  8192\nglobal const mf_help =  16384\nglobal const mf_mouseselect =  32768\n\n!global const bn_clicked =  0\n!global const bn_dblclk =  5\n!global const bn_disable =  4\n!global const bn_doubleclicked =  5\n!global const bn_hilite =  2\n!global const bn_killfocus =  7\n!global const bn_paint =  1\n!global const bn_pushed =  2\n!global const bn_setfocus =  6\n!global const bn_unhilite =  3\n!global const bn_unpushed =  3\n!global const en_setfocus =  256\n!global const en_killfocus =  512\n!global const en_change =  768\n!global const en_update =  1024\n!global const en_errspace =  1280\n!global const en_maxtext =  1281\n!global const en_hscroll =  1537\n!global const en_vscroll =  1538\n!global const lbn_errspace =  -2\n!global const lbn_selchange =  1\n!global const lbn_dblclk =  2\n!global const lbn_selcancel =  3\n!global const lbn_setfocus =  4\n!global const lbn_killfocus =  5\n!global const cbn_errspace =  -1\n!global const cbn_selchange =  1\n!global const cbn_dblclk =  2\n!global const cbn_setfocus =  3\n!global const cbn_killfocus =  4\n!global const cbn_editchange =  5\n!global const cbn_editupdate =  6\n!global const cbn_dropdown =  7\n!global const cbn_closeup =  8\n!global const cbn_selendok =  9\n!global const cbn_selendcancel =  10\n!\n!global const cbs_autohscroll =  64\n!global const cbs_disablenoscroll =  2048\n!global const cbs_dropdown =  2\n!global const cbs_dropdownlist =  3\n!global const cbs_hasstrings =  512\n!global const cbs_lowercase =  16384\n!global const cbs_nointegralheight =  1024\n!global const cbs_oemconvert =  128\n!global const cbs_ownerdrawfixed =  16\n!global const cbs_ownerdrawvariable =  32\n!global const cbs_simple =  1\n!global const cbs_sort =  256\n!global const cbs_uppercase =  8192\n\nglobal const wm_command =  273\nglobal const wm_menuselect =  287\nglobal const wm_cut =  768\nglobal const wm_copy =  769\nglobal const wm_paste =  770\nglobal const wm_clear =  771\nglobal const wm_undo =  772\nglobal const em_getsel =  176\nglobal const em_setsel =  177\nglobal const em_scroll =  181\nglobal const em_linescroll =  182\nglobal const em_scrollcaret =  183\nglobal const em_getmodify =  184\nglobal const em_setmodify =  185\nglobal const em_getlinecount =  186\nglobal const em_lineindex =  187\nglobal const em_sethandle =  188\nglobal const em_gethandle =  189\nglobal const em_getthumb =  190\nglobal const em_linelength =  193\nglobal const em_replacesel =  194\nglobal const em_getline =  196\nglobal const em_limittext =  197\nglobal const em_canundo =  198\nglobal const em_undo =  199\nglobal const em_fmtlines =  200\nglobal const em_linefromchar =  201\nglobal const em_settabstops =  203\nglobal const em_setpasswordchar =  204\nglobal const em_emptyundobuffer =  205\nglobal const em_getfirstvisibleline =  206\nglobal const em_setreadonly =  207\nglobal const em_setwordbreakproc =  208\nglobal const em_getwordbreakproc =  209\nglobal const em_getpasswordchar =  210\nglobal const em_setlimittext =  197\nglobal const em_getseltext =  1086\nglobal const em_setcharformat =  1092\nglobal const em_getcharformat =  1082\nglobal const em_settextmode =  1113\nglobal const em_gettextmode =  1114\nglobal const em_gettextex =  1118\nglobal const em_gettextlengthex =  1119\nglobal const tm_plaintext =  1\nglobal const tm_richtext =  2\nglobal const tm_singlelevelundo =  4\nglobal const tm_multilevelundo =  8\nglobal const tm_singlecodepage =  16\nglobal const tm_multicodepage =  32\nglobal const scf_word =  2\nglobal const scf_selection =  1\nglobal const sb_getborders =  1031\nglobal const sb_getparts =  1030\nglobal const sb_getrect =  1034\nglobal const sb_gettextw =  1037\nglobal const sb_gettextlengthw =  1036\nglobal const sb_settextw =  1035\nglobal const sb_gettexta =  1026\nglobal const sb_gettextlengtha =  1027\nglobal const sb_settexta =  1025\nglobal const sb_gettext =  1026\nglobal const sb_gettextlength =  1027\nglobal const sb_settext =  1025\nglobal const sb_setminheight =  1032\nglobal const sb_setparts =  1028\nglobal const sb_simple =  1033\nglobal const wm_setfont =  48\nglobal const wm_getfont =  49\nglobal const gm_advanced =  2\nglobal const transparent =  1\nglobal const opaque =  2\nglobal const mwt_identity =  1\nglobal const cw_usedefault =  0x8000'0000\nglobal const idc_arrow =  32512\nglobal const idc_ibeam =  32513\nglobal const idc_wait =  32514\nglobal const idc_cross =  32515\nglobal const idc_uparrow =  32516\nglobal const idc_sizenwse =  32642\nglobal const idc_sizenesw =  32643\nglobal const idc_sizewe =  32644\nglobal const idc_sizens =  32645\nglobal const idc_sizeall =  32646\nglobal const idc_no =  32648\nglobal const idc_appstarting =  32650\nglobal const idc_help =  32651\nglobal const idi_application =  32512\nglobal const idi_hand =  32513\nglobal const idi_question =  32514\nglobal const idi_exclamation =  32515\nglobal const idi_asterisk =  32516\nglobal const idi_winlogo =  32517\nglobal const idc_size =  32640\nglobal const idc_icon =  32641\nglobal const arrowpointer =  32512\nglobal const ibeampointer =  32513\nglobal const waitpointer =  32514\nglobal const crosspointer =  32515\nglobal const uparrowpointer =  32516\nglobal const sizenwsepointer =  32642\nglobal const sizeneswpointer =  32643\nglobal const sizewepointer =  32644\nglobal const sizenspointer =  32645\nglobal const sizeallpointer =  32646\nglobal const nopointer =  32648\nglobal const appstartingpointer =  32650\nglobal const helpicon =  32651\nglobal const applicationicon =  32512\nglobal const handicon =  32513\nglobal const questionicon =  32514\nglobal const exclamationicon =  32515\nglobal const asteriskicon =  32516\nglobal const winlogoicon =  32517\nglobal const sizepointer =  32640\nglobal const iconicon =  32641\nglobal const sm_cymin =  29\nglobal const sm_cxmin =  28\nglobal const sm_arrange =  56\nglobal const sm_cleanboot =  67\nglobal const sm_cmetrics =  76\nglobal const sm_cmousebuttons =  43\nglobal const sm_cxborder =  5\nglobal const sm_cyborder =  6\nglobal const sm_cxcursor =  13\nglobal const sm_cycursor =  14\nglobal const sm_cxdlgframe =  7\nglobal const sm_cydlgframe =  8\nglobal const sm_cxdoubleclk =  36\nglobal const sm_cydoubleclk =  37\nglobal const sm_cxdrag =  68\nglobal const sm_cydrag =  69\nglobal const sm_cxedge =  45\nglobal const sm_cyedge =  46\nglobal const sm_cxfixedframe =  7\nglobal const sm_cyfixedframe =  8\nglobal const sm_cxframe =  32\nglobal const sm_cyframe =  33\nglobal const sm_cxfullscreen =  16\nglobal const sm_cyfullscreen =  17\nglobal const sm_cxhscroll =  21\nglobal const sm_cyhscroll =  3\nglobal const sm_cxhthumb =  10\nglobal const sm_cxicon =  11\nglobal const sm_cyicon =  12\nglobal const sm_cxiconspacing =  38\nglobal const sm_cyiconspacing =  39\nglobal const sm_cxmaximized =  61\nglobal const sm_cymaximized =  62\nglobal const sm_cxmaxtrack =  59\nglobal const sm_cymaxtrack =  60\nglobal const sm_cxmenucheck =  71\nglobal const sm_cymenucheck =  72\nglobal const sm_cxmenusize =  54\nglobal const sm_cymenusize =  55\nglobal const sm_cxminimized =  57\nglobal const sm_cyminimized =  58\nglobal const sm_cxminspacing =  47\nglobal const sm_cyminspacing =  48\nglobal const sm_cxmintrack =  34\nglobal const sm_cymintrack =  35\nglobal const sm_cxscreen =  0\nglobal const sm_cyscreen =  1\nglobal const sm_cxsize =  30\nglobal const sm_cysize =  31\nglobal const sm_cxsizeframe =  32\nglobal const sm_cysizeframe =  33\nglobal const sm_cxsmicon =  49\nglobal const sm_cysmicon =  50\nglobal const sm_cxsmsize =  52\nglobal const sm_cysmsize =  53\nglobal const sm_cxvscroll =  2\nglobal const sm_cyvscroll =  20\nglobal const sm_cyvthumb =  9\nglobal const sm_cycaption =  4\nglobal const sm_cykanjiwindow =  18\nglobal const sm_cymenu =  15\nglobal const sm_cysmcaption =  51\nglobal const sm_dbcsenabled =  42\nglobal const sm_debug =  22\nglobal const sm_menudropalignment =  40\nglobal const sm_mideastenabled =  74\nglobal const sm_mousepresent =  19\nglobal const sm_mousewheelpresent =  75\nglobal const sm_network =  63\nglobal const sm_penwindows =  41\nglobal const sm_reserved1 =  24\nglobal const sm_reserved2 =  25\nglobal const sm_reserved3 =  26\nglobal const sm_reserved4 =  27\nglobal const sm_secure =  44\nglobal const sm_showsounds =  70\nglobal const sm_slowmachine =  73\nglobal const sm_swapbutton =  23\nglobal const arw_bottomleft =  0\nglobal const arw_bottomright =  1\nglobal const arw_hide =  8\nglobal const arw_topleft =  2\nglobal const arw_topright =  3\nglobal const arw_down =  4\nglobal const arw_left =  0\nglobal const arw_right =  0\nglobal const arw_up =  4\nglobal const white_brush =  0\nglobal const ltgray_brush =  1\nglobal const gray_brush =  2\nglobal const dkgray_brush =  3\nglobal const black_brush =  4\nglobal const null_brush =  5\nglobal const hollow_brush =  5\nglobal const white_pen =  6\nglobal const black_pen =  7\nglobal const null_pen =  8\nglobal const oem_fixed_font =  10\nglobal const ansi_fixed_font =  11\nglobal const ansi_var_font =  12\nglobal const system_font =  13\nglobal const device_default_font =  14\nglobal const default_palette =  15\nglobal const system_fixed_font =  16\nglobal const stock_last =  16\n\n!global const sbm_setpos =  224\n!global const sbm_getpos =  225\n!global const sbm_setrange =  226\n!global const sbm_setrangeredraw =  230\n!global const sbm_getrange =  227\n!global const sbm_enable_arrows =  228\n!global const sbs_horz =  0\n!global const sbs_vert =  1\n!global const sbs_topalign =  2\n!global const sbs_leftalign =  2\n!global const sbs_bottomalign =  4\n!global const sbs_rightalign =  4\n!global const sbs_sizeboxtopleftalign =  2\n!global const sbs_sizeboxbottomrightalign =  4\n!global const sbs_sizebox =  8\n\nglobal const wm_hscroll =  276\nglobal const wm_vscroll =  277\n\n!global const sb_horz =  0\n!global const sb_hoz =  0\n!global const sb_vert =  1\n!global const sb_ctl =  2\n!global const sb_both =  3\n!global const sb_lineup =  0\n!global const sb_lineleft =  0\n!global const sb_linedown =  1\n!global const sb_lineright =  1\n!global const sb_pageup =  2\n!global const sb_pageleft =  2\n!global const sb_pagedown =  3\n!global const sb_pageright =  3\n!global const sb_thumbposition =  4\n!global const sb_thumbtrack =  5\n!global const sb_top =  6\n!global const sb_left =  6\n!global const sb_bottom =  7\n!global const sb_right =  7\n!global const sb_endscroll =  8\n!global const sif_disablenoscroll =  8\n!global const sif_page =  2\n!global const sif_pos =  4\n!global const sif_range =  1\n!global const sif_trackpos =  16\n!global const sif_all =  23\n\nglobal const wm_ctlcolourmsgbox =  306\nglobal const wm_ctlcolouredit =  307\nglobal const wm_ctlcolourlistbox =  308\nglobal const wm_ctlcolourbtn =  309\nglobal const wm_ctlcolourdlg =  310\nglobal const wm_ctlcolourscrollbar =  311\nglobal const wm_ctlcolourstatic =  312\nglobal const wm_timer =  275\n\nglobal const srccopy =  13369376\nglobal const srcpaint =  15597702\nglobal const srcand =  8913094\nglobal const srcinvert =  6684742\nglobal const srcerase =  4457256\n\nglobal const notsrccopy =  3342344\nglobal const notsrcerase =  1114278\nglobal const mergecopy =  12583114\nglobal const mergepaint =  12255782\nglobal const patcopy =  15728673\nglobal const patpaint =  16452105\nglobal const patinvert =  5898313\nglobal const dstinvert =  5570569\nglobal const blackness =  66\nglobal const whiteness =  16711778\n\nglobal const r2_black =  1\nglobal const r2_notmergepen =  2\nglobal const r2_masknotpen =  3\nglobal const r2_notcopypen =  4\nglobal const r2_maskpennot =  5\nglobal const r2_not =  6\nglobal const r2_xorpen =  7\nglobal const r2_notmaskpen =  8\nglobal const r2_maskpen =  9\nglobal const r2_notxorpen =  10\nglobal const r2_nop =  11\nglobal const r2_mergenotpen =  12\nglobal const r2_copypen =  13\nglobal const r2_mergepennot =  14\nglobal const r2_mergepen =  15\nglobal const r2_white =  16\nglobal const r2_last =  16\n\nglobal const gdi_error =  4294967295\nglobal const hgdi_error =  4294967295\nglobal const clr_invalid =  4278190080\nglobal const clr_default =  4278190080\nglobal const clr_none =  4294967295\nglobal const ofn_readonly =  1\nglobal const ofn_overwriteprompt =  2\nglobal const ofn_hidereadonly =  4\nglobal const ofn_nochangedir =  8\nglobal const ofn_showhelp =  16\nglobal const ofn_enablehook =  32\nglobal const ofn_enabletemplate =  64\nglobal const ofn_enabletemplatehandle =  128\nglobal const ofn_novalidate =  256\nglobal const ofn_allowmultiselect =  512\nglobal const ofn_extensiondifferent =  1024\nglobal const ofn_pathmustexist =  2048\nglobal const ofn_filemustexist =  4096\nglobal const ofn_createprompt =  8192\nglobal const ofn_shareaware =  16384\nglobal const ofn_noreadonlyreturn =  32768\nglobal const ofn_notestfilecreate =  65536\nglobal const ofn_nonetworkbutton =  131072\nglobal const ofn_nolongnames =  262144\nglobal const ofn_explorer =  524288\nglobal const ofn_nodereferencelinks =  1048576\nglobal const ofn_longnames =  2097152\nglobal const ofn_sharefallthrough =  2\nglobal const ofn_sharenowarn =  1\nglobal const ofn_sharewarn =  0\n!global const gmem_fixed =  0\n!global const gmem_moveable =  2\n!global const gmem_nocompact =  16\n!global const gmem_nodiscard =  32\n!global const gmem_zeroinit =  64\n!global const gmem_modify =  128\n!global const gmem_discardable =  256\n!global const gmem_not_banked =  4096\n!global const gmem_share =  8192\n!global const gmem_ddeshare =  8192\n!global const gmem_notify =  16384\n!global const gmem_lower =  4096\n!global const gmem_valid_flags =  32626\n!global const gmem_invalid_handle =  32768\n!global const gmem_clipboard =  8194\n!global const ghnd =  66\n!global const gptr =  64\n!global const pd_allpages =  0\n!global const pd_collate =  16\n!global const pd_disableprinttofile =  524288\n!global const pd_enableprinthook =  4096\n!global const pd_enableprinttemplate =  16384\n!global const pd_enableprinttemplatehandle =  65536\n!global const pd_enablesetuphook =  8192\n!global const pd_enablesetuptemplate =  32768\n!global const pd_enablesetuptemplatehandle =  131072\n!global const pd_hideprinttofile =  1048576\n!global const pd_nopagenums =  8\n!global const pd_noselection =  4\n!global const pd_nowarning =  128\n!global const pd_pagenums =  2\n!global const pd_printsetup =  64\n!global const pd_printtofile =  32\n!global const pd_returndc =  256\n!global const pd_returndefault =  1024\n!global const pd_returnic =  512\n!global const pd_selection =  1\n!global const pd_showhelp =  2048\n!global const pd_usedevmodecopies =  262144\n!global const pd_usedevmodecopiesandcollate =  262144\nglobal const dib_rgb_colours =  0\nglobal const dib_pal_colours =  1\nglobal const dib_pal_indices =  2\nglobal const dib_pal_physindices =  2\nglobal const dib_pal_logindices =  4\nglobal const stm_seticon =  368\nglobal const stm_setimage =  370\nglobal const lr_loadfromfile =  16\nglobal const image_bitmap =  0\nglobal const image_icon =  1\nglobal const lr_copydeleteorg =  8\nglobal const lr_copyreturnorg =  4\nglobal const lr_monochrome =  1\nglobal const lr_createdibsection =  8192\nglobal const lr_defaultsize =  64\nglobal const ss_icon =  3\nglobal const ss_bitmap =  14\nglobal const gcl_menuname =  -8\nglobal const gcl_hbrbackground =  -10\nglobal const gcl_hcursor =  -12\nglobal const gcl_hicon =  -14\nglobal const gcl_hmodule =  -16\nglobal const gcl_cbwndextra =  -18\nglobal const gcl_cbclsextra =  -20\nglobal const gcl_wndproc =  -24\nglobal const gcl_style =  -26\nglobal const gcw_atom =  -32\nglobal const colour_scrollbar =  0\nglobal const colour_background =  1\nglobal const colour_desktop =  1\nglobal const colour_activecaption =  2\nglobal const colour_inactivecaption =  3\nglobal const colour_menu =  4\nglobal const colour_window =  5\nglobal const colour_windowframe =  6\nglobal const colour_menutext =  7\nglobal const colour_windowtext =  8\nglobal const colour_captiontext =  9\nglobal const colour_activeborder =  10\nglobal const colour_inactiveborder =  11\nglobal const colour_appworkspace =  12\nglobal const colour_highlight =  13\nglobal const colour_highlighttext =  14\nglobal const colour_btnface =  15\nglobal const colour_3dface =  15\nglobal const colour_btnshadow =  16\nglobal const colour_3dshadow =  16\nglobal const colour_graytext =  17\nglobal const colour_btntext =  18\nglobal const colour_inactivecaptiontext =  19\nglobal const colour_btnhighlight =  20\nglobal const colour_3dhilight =  20\nglobal const colour_3ddkshadow =  21\nglobal const colour_3dlight =  22\nglobal const colour_infotext =  23\nglobal const colour_infobk =  24\nglobal const colour_tooltipbk =  24\nglobal const mk_lbutton =  1\nglobal const mk_rbutton =  2\nglobal const mk_shift =  4\nglobal const mk_control =  8\nglobal const mk_mbutton =  16\nglobal const cbm_createdib =  2\nglobal const cbm_init =  4\nglobal const cc_enablehook =  16\nglobal const cc_enabletemplate =  32\nglobal const cc_enabletemplatehandle =  64\nglobal const cc_fullopen =  2\nglobal const cc_preventfullopen =  4\nglobal const cc_rgbinit =  1\nglobal const cc_showhelp =  8\nglobal const cc_solidcolour =  128\nglobal const cf_screenfonts =  1\nglobal const cf_printerfonts =  2\nglobal const cf_effects =  256\nglobal const size_restored =  0\nglobal const size_minimized =  1\nglobal const size_maximized =  2\nglobal const size_maxshow =  3\nglobal const size_maxhide =  4\n!global const gwl_wndproc =  -4\n!global const gwl_hinstance =  -6\n!global const gwl_hwndparent =  -8\n!global const gwl_style =  -16\n!global const gwl_exstyle =  -20\nglobal const gwl_userdata =  -21\nglobal const gwl_id =  -12\nglobal const ta_top =  0\nglobal const ta_left =  0\nglobal const ta_noupdatecp =  0\nglobal const ta_updatecp =  1\nglobal const ta_right =  2\nglobal const ta_centre =  6\nglobal const vta_centre =  6\nglobal const ta_bottom =  8\nglobal const ta_baseline =  24\nglobal const vta_baseline =  24\nglobal const ta_rtlreading =  256\nglobal const aligntop =  0\nglobal const alignbottom =  8\nglobal const alignbaseline =  24\nglobal const aligncentre =  6\nglobal const alignleft =  0\nglobal const alignright =  2\n\nglobal const em_exgetsel =  1076\nglobal const em_exlimittext =  1077\nglobal const em_exlinefromchar =  1078\nglobal const em_exsetsel =  1079\nglobal const em_getparaformat =  1085\nglobal const em_setparaformat =  1095\nglobal const em_streamin =  1097\nglobal const em_streamout =  1098\nglobal const em_gettextrange =  1099\nglobal const em_findtext =  1080\nglobal const em_findtextex =  1103\n\n!global const ttf_idishwnd =  1\n!global const ttf_centretip =  2\n!global const ttf_rtlreading =  4\n!global const ttf_subclass =  16\n!global const ttf_track =  32\n!global const ttf_absolute =  128\n!global const ttf_transparent =  256\n!global const ttf_di_setitem =  32768\n\nglobal const hwnd_top =  0\nglobal const hwnd_bottom =  1\nglobal const hwnd_topmost =  -1\nglobal const hwnd_notopmost =  -2\n\nglobal const normalwind =  0\nglobal const modalwind =  -1\nglobal const dialogwind =  -2\nglobal const minimize =  2\nglobal const maximize =  3\nglobal const shiftmask =  1\nglobal const controlmask =  2\nglobal const altmask =  4\nglobal const windowcolour =  15\nglobal const ps_geometric =  65536\nglobal const ps_cosmetic =  0\nglobal const ps_alternate =  8\nglobal const ps_solid =  0\nglobal const ps_dash =  1\nglobal const ps_dot =  2\nglobal const ps_dashdot =  3\nglobal const ps_dashdotdot =  4\nglobal const ps_null =  5\nglobal const ps_insideframe =  6\nglobal const ps_userstyle =  7\nglobal const ps_endcap_round =  0\nglobal const ps_endcap_square =  256\nglobal const ps_endcap_flat =  512\nglobal const ps_join_bevel =  4096\nglobal const ps_join_miter =  8192\nglobal const ps_join_round =  0\nglobal const ps_style_mask =  15\nglobal const ps_endcap_mask =  3840\nglobal const ps_type_mask =  983040\nglobal const bs_solid =  0\nglobal const bs_hollow =  1\nglobal const bs_null =  1\nglobal const bs_hatched =  2\nglobal const bs_pattern =  3\nglobal const bs_dibpattern =  5\nglobal const bs_dibpatternpt =  6\nglobal const bs_pattern8x8 =  7\nglobal const bs_dibpattern8x8 =  8\nglobal const hs_horizontal =  0\nglobal const hs_vertical =  1\nglobal const hs_fdiagonal =  2\nglobal const hs_bdiagonal =  3\nglobal const hs_cross =  4\nglobal const hs_diagcross =  5\n\n!global const gl_points =  0\n!global const gl_lines =  1\n!global const gl_line_loop =  2\n!global const gl_line_strip =  3\n!global const gl_triangles =  4\n!global const gl_triangle_strip =  5\n!global const gl_triangle_fan =  6\n!global const gl_quads =  7\n!global const gl_quad_strip =  8\n!global const gl_polygon =  9\n\nglobal const spi_getworkarea =  48\n\nproc start=\nend\n\n",
(u64)"!import winmessages\n!import winconsts\n!import gxmisc\n!import winapi\n\n!module winapi\n\nexport var hwapplic=nil\nexport var hwchild=nil\nexport var iswin32\nexport var screendc\n\nexport var nglobalfonts=0\nexport var fonttable::=()\t\t\t![]font handles\nexport var fontdimtable::=()\t\t![]rpoint (width,total line height)\nexport var fontvdimtable::=()\t\t![]rpoint (ascenders, descenders) \n\nproc start\t=\n\tinitdata()\nend\n\nproc initdata=\n!CPL \"---------WINGXLIB\"\n\tiswin32:=(getos()=\"W32\")\n\tscreendc:=getdc(nil)\n\n\tfonttable:=(0,)*20\n\tfontdimtable:=(0,)*20\n\tfontvdimtable:=(0,)*20\n\n\tfonttable[1]:=getstockobject(17)\t!default gui\n\tfonttable[2]:=getstockobject(13)\t!system font\n\tfonttable[3]:=getstockobject(16)\t!system fixed\n\tfonttable[4]:=getstockobject(10)\t!oem fixed\n\tfor i:=1 to 4 do\n\t\tfontdimtable[i]::=ws_point(0,0)\n\t\tfontvdimtable[i]::=ws_point(0,0)\n\tod\n\tnglobalfonts:=4\nend\n\nfunc checkoption(optionnames,optionvalues,name,default=-1)=\n!search for option with given name\n!return value of option, or -1 if not present\n!options (which can be void) will be a list of (name,value) list pairs\n\n\tn:=name in optionnames\n\tif not n then return default fi\n\treturn optionvalues[n]\nend\n\nglobal proc wx_waitmess=\n\twindmsg:=new((iswin32|ws_msg32|ws_msg64))\n\n\tdo\n\t\tif getmessage(&windmsg,nil,0,0)<>0 then\n\t\t\tw:=windmsg.hwnd\n\t\t\tif windmsg.message=wm_keydown and windmsg.wparam=27 then exit fi\n\t\t\tif windmsg.message=wm_timer then CPL \"TIMER!!\" fi\n\t\t\ttranslatemessage(&windmsg)\n\t\t\tdispatchmessage(&windmsg)\n\t\t\tif windmsg.message=wm_close then exit fi\n\t\telse\n\t\t\texit\n\t\tfi\n\tod\nend\n\nglobal func wx_getw(hwnd)=\n!return allwindow-index of window that has been stored into it\n\tn:=getwindowlongptr(hwnd, gwl_userdata)\n\treturn n\nend\n\nglobal proc wx_setw(hwnd,index)=\n!store mm window handle into win32 window\n!index is .gindex (index into allwindows)\n\tsetwindowlongptr(hwnd, gwl_userdata, index)\nend\n\nglobal func wx_gettextwidth(hdc,s)=\n\tsize:=new(ws_point)\n\tgettextextentpoint32(hdc,s,s.len,&size)\n\treturn size.x\nend\n\nglobal func wx_createpopup(?caption,?pos,?dim,?options,owner=nil)=\n!wrapper around win32 createwindow\n!return win32 handle to newly created window\n\tconst gap=40\n\tconst smallestwidth=150\n\n\tif options.isvoid then\n options:=[wf_caption:1,wf_border:wbs_resize]\n\tfi\n\n\tposx:=posy:=-1\n\tdimx:=640\n\tdimy:=480\n\tfcentre:=0\n\tfautopos:=0\n\tfmax:=fdesktop:=0\n!\tfconsole:=0\n\n\tif caption.isvoid then caption:=\"<No Caption>\" fi\n\n\tif dim.defined then\n\t\tif dim.isstring and dim=\"max\" then\n\t\t\tfmax:=1\n\t\telsif dim.isstring and dim=\"desktop\" then\n\t\t\tfdesktop:=1\n!\t\telsif dim.isstring and dim=\"console\" then\n!\t\t\tfconsole:=1\n\t\telse\n\t\t\tdimx:=dim[1]\n\t\t\tdimy:=dim[2]\n\t\tfi\n\tfi\n\n\tif pos.isvoid or pos=\"cent\" then\n\t\tfcentre:=1\n\telsif pos=\"auto\" then\n\t\tfautopos:=1\n\telsif pos.defined and not pos.isstring then\n\t\tposx:=pos[1]\n\t\tposy:=pos[2]\n\telse\t\t\t\t!check options?\n\t\tabort(\"gxcw bad pos\")\n\tfi\n\n\tbstyle:=bxstyle:=0\n\tnocap:=0\t\t\t!whether to suppress caption\n\n\tframex:=framey:=0\n\n\tcase options{wf_border,wbs_resize}\n\twhen wbs_none then\t\t!no border\n\t\tnocap:=1\n\t\tframex:=0\n\t\tframey:=0\n\twhen wbs_simple then\t\t!single line\n\t\tnocap:=1\n\t\tbstyle:=ws_border\n\t\tframex:=1\n\t\tframey:=1\n\twhen wbs_thick then\t\t!thick line\n\t\tbstyle:=ws_dlgframe\n\t\tfixedframe:=0\n\t\tframex:=getsystemmetrics(sm_cxfixedframe)\n\t\tframey:=getsystemmetrics(sm_cyfixedframe)\n\twhen wbs_resize then\n\t\tbstyle:=ws_sizebox\n\t\tframex:=getsystemmetrics(sm_cxsizeframe)\n\t\tframey:=getsystemmetrics(sm_cysizeframe)\n\twhen wbs_sunken,wbs_sunken2 then\t\t!sunken\n\t\tbstyle:=ws_dlgframe\n\t\tbxstyle:=ws_ex_clientedge\n\t\tframex:=5\n\t\tframey:=5\n\twhen wbs_sunkenrs then\n\t\tbstyle:=ws_sizebox\n\t\tbxstyle:=ws_ex_clientedge\n\t\tframex:=6\n\t\tframey:=6\n\tesac\n\n\tcapheight:=getsystemmetrics(sm_cycaption)\n\tmbheight:=getsystemmetrics(sm_cymenu)\n\n\tstyle:=0\n\texstyle:=0\n\n\tif options{wf_show,1} then\n\t\tstyle ior:=ws_visible\n\tfi\n\n\tmxleft:=framex\n\tmxright:=framey\n\tmytop:=framey+capheight\n\tmybottom:=framey\n\tshowstyle:=sw_shownormal\n\n\thcwmenu:=nil\n\tif options{wf_menu,0}=1 then\n\t\tmytop+:=mbheight\n\t\thcwmenu:=createmenu()\n\t\tappendmenu(hcwmenu,0,998,\"fred\")\n\tfi\n\n\tstyle ior:=ws_clipchildren\n\n\tif nocap or options{wf_caption,1}=0 then\n\t\tmytop-:=capheight\n\t\tstyle ior:=ws_popup\n\tfi\n\n\tif options{wf_iframe,0}=0 then\n\t\tif not fautopos then\n\t\t\tposx-:=mxleft\n\t\t\tposy-:=mytop\n\t\tfi\n\t\tdimx+:=mxleft+mxright\n\t\tdimy+:=mytop+mybottom\n\tfi\n\n\tif fcentre or options{wf_cent,0}=1 then\n\t\tfautopos:=0\n\t\tbox:=new(ws_rect)\n\t\tsystemparametersinfoa(spi_getworkarea,0,&box,0)\n\t\tposx:=box.rightx%2-dimx%2\n\t\tposy:=(box.bottom-box.top)%2-dimy%2+box.top\n\tfi\n\n\tif fmax or options{wf_max,0} then\n\t\tshowstyle:=sw_maximize\n\t\tstyle ior:=ws_maximize\n\tfi\n\n\n\tif options{wf_minmax,1}=1 then\n\t\tstyle ior:=(ws_maximizebox ior ws_minimizebox)\n\n\tfi\n\n\tif options{wf_sysmenu,1}=1 then\n\t\tstyle ior:=ws_sysmenu\n\tfi\n\n\tif fautopos=0 and options{wf_clip,0}=1 then\n\t\tbox:=new(ws_rect)\n\t\tsystemparametersinfoa(spi_getworkarea,0,&box,0)\n\n\t\tif posx<box.leftx+gap then posx:=box.leftx+gap fi\n\n\t\tif posy<box.top+gap then posy:=box.top+gap fi\n\t\tdimxmin:=dimx max smallestwidth\n\t\tif posx+dimxmin>=box.rightx+gap then posx:=box.rightx-gap-dimxmin fi\n\t\tif posy+dimy>=box.bottom+gap then posy:=box.bottom-gap-dimy fi\n\telsif fautopos then\n\t\tposx:=posy:=cw_usedefault\n\tfi\n\n\tif fdesktop or options{wf_desktop,0}=1 then\n\t\tbox:=new(ws_rect)\n\t\tsystemparametersinfoa(spi_getworkarea,0,&box,0)\n\t\tposx:=box.leftx\n\t\tposy:=box.top\n\t\tdimx:=box.rightx-box.leftx\n\t\tdimy:=box.bottom-box.top\n\tfi\n\n\tif options{wf_toolwind,0}=1 then\n\t\texstyle ior:=ws_ex_toolwindow\n\tfi\n\n\tclassname:=\"pcc001\"\n\n\tSTYLE IOR:=WS_VISIBLE\n\n\tstyle ior:=bstyle\n\texstyle ior:=bxstyle\n\n!\tif fconsole then\n!\t\thwnd:=getconsolewindow()\n!CPL \"CONSOLE\", =HWND\n!STOP\n!\n!\telse\n\n\t\thwnd:=createwindowex(\n\t\t\texstyle,\n\t\t\tclassname,\n\t\t\tcaption,\n\t\t\tstyle,\n\t\t\tposx,posy,\t\t\t!initial position and size\n\t\t\tdimx,dimy,\n\t\t\towner,\t\t\t!will be 0 for 1st window, other popups use hwapplic as owner\n\t\t\thcwmenu,\t\t\t!menu handle\n\t\t\tnil,\t!proginstance,\t\t!instance handle\n\t\t\tnil)\t\t\t!creation params\n!\tfi\n\n\tif hwnd=nil then\n\t\te:=getlasterror()\n\t\tabort(\"wx:Can't create popup window \"+tostr(e))\n\tfi\n\treturn hwnd\nend\n\nglobal func wx_createcontrol(?pos,?dim,border=wbs_simple,owner)=\n!wrapper around win32 createwindow\n!return win32 handle to newly created window\n\tconst gap=40\n\tconst smallestwidth=150\n\n\tposx:=posy:=0\n\tdimx:=160\n\tdimy:=120\n\n\tif dim.defined then\n\t\tdimx:=dim[1]\n\t\tdimy:=dim[2]\n\tfi\n\n\tif pos.defined then\n\t\tposx:=pos[1]\n\t\tposy:=pos[2]\n\tfi\n\n\tbstyle:=bxstyle:=0\n\n\tcase border\n\twhen wbs_none then\t\t\t!no border\n\twhen wbs_simple then\t\t!single line\n\t\tbstyle:=ws_border\n\telse\n\t\tpcerror(\"createcontrol/bad border \"+wbsnames[border])\n\tesac\n\n\tstyle:=0\n\texstyle:=0\n\n\tstyle ior:=ws_clipchildren\n\n\tclassname:=\"pcc001\"\n\n\tstyle ior:=ws_child\n\tstyle ior:=ws_visible\n\n\tstyle ior:=bstyle\n\texstyle ior:=bxstyle\n\n\thwnd:=createwindowex(\n\t\texstyle,\n\t\tclassname,\n\t\tnil,\n\t\tstyle,\n\t\tposx,posy,\t\t\t!initial position and size\n\t\tdimx,dimy,\n\t\towner,\t\t\t\t!will be 0 for 1st window, other popups use hwapplic as owner\n\t\tnil,\t\t\t\t!menu handle\n\t\tnil,\n\t\tnil)\t\t\t\t!creation params\n\n\tif hwnd=0 then\n\t\te:=getlasterror()\n\t\tabort(\"wx:Can't create child window \"+tostr(e))\n\tfi\n\n\treturn hwnd\nend\n\n",
(u64)"export var winmessagenames=[\n\t(0:\"wm_null\"),\n\t(1:\"wm_create\"),\n\t(2:\"wm_destroy\"),\n\t(3:\"wm_move\"),\n\t(4:\"pgk_menu\"),\n\t(5:\"wm_size\"),\n\t(6:\"wm_activate\"),\n\t(7:\"wm_setfocus\"),\n\t(8:\"wm_killfocus\"),\n\t(9:\"cbn_selendok\"),\n\t(10:\"wm_enable\"),\n\t(11:\"wm_setredraw\"),\n\t(12:\"wm_settext\"),\n\t(13:\"wm_gettext\"),\n\t(14:\"wm_gettextlength\"),\n\t(15:\"wm_paint\"),\n\t(16:\"wm_close\"),\n\t(17:\"wm_queryendsession\"),\n\t(18:\"wm_quit\"),\n\t(19:\"wm_queryopen\"),\n\t(20:\"wm_erasebkgnd\"),\n\t(21:\"wm_syscolorchange\"),\n\t(22:\"wm_endsession\"),\n\t(24:\"wm_showwindow\"),\n\t(26:\"wm_wininichange\"),\n\t(27:\"wm_devmodechange\"),\n\t(28:\"wm_activateapp\"),\n\t(29:\"wm_fontchange\"),\n\t(30:\"wm_timechange\"),\n\t(31:\"wm_cancelmode\"),\n\t(32:\"wm_setcursor\"),\n\t(33:\"wm_mouseactivate\"),\n\t(34:\"wm_childactivate\"),\n\t(35:\"wm_queuesync\"),\n\t(36:\"wm_getminmaxinfo\"),\n\t(38:\"wm_painticon\"),\n\t(39:\"wm_iconerasebkgnd\"),\n\t(40:\"wm_nextdlgctl\"),\n\t(42:\"wm_spoolerstatus\"),\n\t(43:\"wm_drawitem\"),\n\t(44:\"wm_measureitem\"),\n\t(45:\"wm_deleteitem\"),\n\t(46:\"wm_vkeytoitem\"),\n\t(47:\"wm_chartoitem\"),\n\t(48:\"wm_setfont\"),\n\t(49:\"wm_getfont\"),\n\t(50:\"wm_sethotkey\"),\n\t(51:\"wm_gethotkey\"),\n\t(55:\"wm_querydragicon\"),\n\t(57:\"wm_compareitem\"),\n\t(64:\"tbif_size\"),\n\t(65:\"wm_compacting\"),\n\t(70:\"wm_windowposchanging\"),\n\t(71:\"wm_windowposchanged\"),\n\t(72:\"wm_power\"),\n\t(74:\"wm_copydata\"),\n\t(75:\"wm_canceljournal\"),\n\t(78:\"wm_notify\"),\n\t(80:\"wm_inputlangchangerequest\"),\n\t(81:\"wm_inputlangchange\"),\n\t(82:\"wm_tcard\"),\n\t(83:\"wm_help\"),\n\t(84:\"wm_userchanged\"),\n\t(85:\"wm_notifyformat\"),\n\t(123:\"wm_contextmenu\"),\n\t(124:\"wm_stylechanging\"),\n\t(125:\"wm_stylechanged\"),\n\t(126:\"wm_displaychange\"),\n\t(127:\"wm_geticon\"),\n\t(128:\"wm_seticon\"),\n\t(129:\"wm_nccreate\"),\n\t(130:\"wm_ncdestroy\"),\n\t(131:\"wm_nccalcsize\"),\n\t(132:\"wm_nchittest\"),\n\t(133:\"wm_ncpaint\"),\n\t(134:\"wm_ncactivate\"),\n\t(135:\"wm_getdlgcode\"),\n\t(160:\"wm_ncmousemove\"),\n\t(161:\"wm_nclbuttondown\"),\n\t(162:\"wm_nclbuttonup\"),\n\t(163:\"wm_nclbuttondblclk\"),\n\t(164:\"wm_ncrbuttondown\"),\n\t(165:\"wm_ncrbuttonup\"),\n\t(166:\"wm_ncrbuttondblclk\"),\n\t(167:\"wm_ncmbuttondown\"),\n\t(168:\"wm_ncmbuttonup\"),\n\t(169:\"wm_ncmbuttondblclk\"),\n\t(176:\"em_getsel\"),\n\t(177:\"em_setsel\"),\n\t(178:\"em_getrect\"),\n\t(179:\"em_setrect\"),\n\t(180:\"em_setrectnp\"),\n\t(181:\"em_scroll\"),\n\t(182:\"em_linescroll\"),\n\t(183:\"em_scrollcaret\"),\n\t(184:\"em_getmodify\"),\n\t(185:\"em_setmodify\"),\n\t(186:\"em_getlinecount\"),\n\t(187:\"em_lineindex\"),\n\t(188:\"em_sethandle\"),\n\t(189:\"em_gethandle\"),\n\t(190:\"em_getthumb\"),\n\t(193:\"em_linelength\"),\n\t(194:\"em_replacesel\"),\n\t(196:\"em_getline\"),\n\t(197:\"em_setlimittext\"),\n\t(198:\"em_canundo\"),\n\t(199:\"em_undo\"),\n\t(200:\"em_fmtlines\"),\n\t(201:\"em_linefromchar\"),\n\t(203:\"em_settabstops\"),\n\t(204:\"em_setpasswordchar\"),\n\t(205:\"em_emptyundobuffer\"),\n\t(206:\"em_getfirstvisibleline\"),\n\t(207:\"em_setreadonly\"),\n\t(208:\"em_setwordbreakproc\"),\n\t(209:\"em_getwordbreakproc\"),\n\t(210:\"em_getpasswordchar\"),\n\t(211:\"em_setmargins\"),\n\t(212:\"em_getmargins\"),\n\t(213:\"em_getlimittext\"),\n\t(214:\"em_posfromchar\"),\n\t(215:\"em_charfrompos\"),\n\t(224:\"sbm_setpos\"),\n\t(225:\"sbm_getpos\"),\n\t(226:\"sbm_setrange\"),\n\t(227:\"sbm_getrange\"),\n\t(228:\"sbm_enable_arrows\"),\n\t(230:\"sbm_setrangeredraw\"),\n\t(233:\"sbm_setscrollinfo\"),\n\t(234:\"sbm_getscrollinfo\"),\n\t(240:\"bm_getcheck\"),\n\t(241:\"bm_setcheck\"),\n\t(242:\"bm_getstate\"),\n\t(243:\"bm_setstate\"),\n\t(244:\"bm_setstyle\"),\n\t(245:\"bm_click\"),\n\t(246:\"bm_getimage\"),\n\t(247:\"bm_setimage\"),\n\t(255:\"wm_input\"),\n\t(256:\"wm_keydown\"),\n\t(257:\"wm_keyup\"),\n\t(258:\"wm_char\"),\n\t(259:\"wm_deadchar\"),\n\t(260:\"wm_syskeydown\"),\n\t(261:\"wm_syskeyup\"),\n\t(262:\"wm_syschar\"),\n\t(263:\"wm_sysdeadchar\"),\n\t(269:\"wm_ime_startcomposition\"),\n\t(270:\"wm_ime_endcomposition\"),\n\t(271:\"wm_ime_composition\"),\n\t(272:\"wm_initdialog\"),\n\t(273:\"wm_command\"),\n\t(274:\"wm_syscommand\"),\n\t(275:\"wm_timer\"),\n\t(276:\"wm_hscroll\"),\n\t(277:\"wm_vscroll\"),\n\t(278:\"wm_initmenu\"),\n\t(279:\"wm_initmenupopup\"),\n\t(287:\"wm_menuselect\"),\n\t(288:\"wm_menuchar\"),\n\t(289:\"wm_enteridle\"),\n\t(290:\"wm_menurbuttonup\"),\n\t(295:\"wm_changeuistate\"),\n\t(296:\"wm_updateuistate\"),\n\t(297:\"wm_queryuistate\"),\n\t(306:\"wm_ctlcolormsgbox\"),\n\t(307:\"wm_ctlcoloredit\"),\n\t(308:\"wm_ctlcolorlistbox\"),\n\t(309:\"wm_ctlcolorbtn\"),\n\t(310:\"wm_ctlcolordlg\"),\n\t(311:\"wm_ctlcolorscrollbar\"),\n\t(312:\"wm_ctlcolorstatic\"),\n\t(320:\"cb_geteditsel\"),\n\t(321:\"cb_limittext\"),\n\t(322:\"cb_seteditsel\"),\n\t(323:\"cb_addstring\"),\n\t(324:\"cbem_deleteitem\"),\n\t(325:\"cb_dir\"),\n\t(326:\"cb_getcount\"),\n\t(327:\"cb_getcursel\"),\n\t(328:\"cb_getlbtext\"),\n\t(329:\"cb_getlbtextlen\"),\n\t(330:\"cb_insertstring\"),\n\t(331:\"cb_resetcontent\"),\n\t(332:\"cb_findstring\"),\n\t(333:\"cb_selectstring\"),\n\t(334:\"cb_setcursel\"),\n\t(335:\"cb_showdropdown\"),\n\t(336:\"cb_getitemdata\"),\n\t(337:\"cb_setitemdata\"),\n\t(338:\"cb_getdroppedcontrolrect\"),\n\t(339:\"cb_setitemheight\"),\n\t(340:\"cb_getitemheight\"),\n\t(341:\"cb_setextendedui\"),\n\t(342:\"cb_getextendedui\"),\n\t(343:\"cb_getdroppedstate\"),\n\t(344:\"cb_findstringexact\"),\n\t(345:\"cb_setlocale\"),\n\t(346:\"cb_getlocale\"),\n\t(347:\"cb_gettopindex\"),\n\t(348:\"cb_settopindex\"),\n\t(349:\"cb_gethorizontalextent\"),\n\t(350:\"cb_sethorizontalextent\"),\n\t(351:\"cb_getdroppedwidth\"),\n\t(352:\"cb_setdroppedwidth\"),\n\t(353:\"cb_initstorage\"),\n\t(368:\"stm_seticon\"),\n\t(369:\"stm_geticon\"),\n\t(370:\"stm_setimage\"),\n\t(371:\"stm_getimage\"),\n\t(384:\"lb_addstring\"),\n\t(385:\"lb_insertstring\"),\n\t(386:\"lb_deletestring\"),\n\t(387:\"lb_selitemrangeex\"),\n\t(388:\"lb_resetcontent\"),\n\t(389:\"lb_setsel\"),\n\t(390:\"lb_setcursel\"),\n\t(391:\"lb_getsel\"),\n\t(392:\"lb_getcursel\"),\n\t(393:\"lb_gettext\"),\n\t(394:\"lb_gettextlen\"),\n\t(395:\"lb_getcount\"),\n\t(396:\"lb_selectstring\"),\n\t(397:\"lb_dir\"),\n\t(398:\"lb_gettopindex\"),\n\t(399:\"lb_findstring\"),\n\t(400:\"lb_getselcount\"),\n\t(401:\"lb_getselitems\"),\n\t(402:\"lb_settabstops\"),\n\t(403:\"lb_gethorizontalextent\"),\n\t(404:\"lb_sethorizontalextent\"),\n\t(405:\"lb_setcolumnwidth\"),\n\t(406:\"lb_addfile\"),\n\t(407:\"lb_settopindex\"),\n\t(408:\"lb_getitemrect\"),\n\t(409:\"lb_getitemdata\"),\n\t(410:\"lb_setitemdata\"),\n\t(411:\"lb_selitemrange\"),\n\t(412:\"lb_setanchorindex\"),\n\t(413:\"lb_getanchorindex\"),\n\t(414:\"lb_setcaretindex\"),\n\t(415:\"lb_getcaretindex\"),\n\t(416:\"lb_setitemheight\"),\n\t(417:\"lb_getitemheight\"),\n\t(418:\"lb_findstringexact\"),\n\t(421:\"lb_setlocale\"),\n\t(422:\"lb_getlocale\"),\n\t(423:\"lb_setcount\"),\n\t(424:\"lb_initstorage\"),\n\t(425:\"lb_itemfrompoint\"),\n\t(512:\"wm_mousemove\"),\n\t(513:\"wm_lbuttondown\"),\n\t(514:\"wm_lbuttonup\"),\n\t(515:\"wm_lbuttondblclk\"),\n\t(516:\"wm_rbuttondown\"),\n\t(517:\"wm_rbuttonup\"),\n\t(518:\"wm_rbuttondblclk\"),\n\t(519:\"wm_mbuttondown\"),\n\t(520:\"wm_mbuttonup\"),\n\t(521:\"wm_mbuttondblclk\"),\n\t(522:\"wm_mousewheel\"),\n\t(523:\"wm_xbuttondown\"),\n\t(524:\"wm_xbuttonup\"),\n\t(525:\"wm_xbuttondblclk\"),\n\t(528:\"wm_parentnotify\"),\n\t(529:\"wm_entermenuloop\"),\n\t(530:\"wm_exitmenuloop\"),\n\t(531:\"wm_nextmenu\"),\n\t(532:\"wm_sizing\"),\n\t(533:\"wm_capturechanged\"),\n\t(534:\"wm_moving\"),\n\t(536:\"wm_powerbroadcast\"),\n\t(537:\"wm_devicechange\"),\n\t(544:\"wm_mdicreate\"),\n\t(545:\"wm_mdidestroy\"),\n\t(546:\"wm_mdiactivate\"),\n\t(547:\"wm_mdirestore\"),\n\t(548:\"wm_mdinext\"),\n\t(549:\"wm_mdimaximize\"),\n\t(550:\"wm_mditile\"),\n\t(551:\"wm_mdicascade\"),\n\t(552:\"wm_mdiiconarrange\"),\n\t(553:\"wm_mdigetactive\"),\n\t(560:\"wm_mdisetmenu\"),\n\t(561:\"wm_entersizemove\"),\n\t(562:\"wm_exitsizemove\"),\n\t(563:\"wm_dropfiles\"),\n\t(564:\"wm_mdirefreshmenu\"),\n\t(641:\"wm_ime_setcontext\"),\n\t(642:\"wm_ime_notify\"),\n\t(643:\"wm_ime_control\"),\n\t(644:\"wm_ime_compositionfull\"),\n\t(645:\"wm_ime_select\"),\n\t(646:\"wm_ime_char\"),\n\t(656:\"wm_ime_keydown\"),\n\t(657:\"wm_ime_keyup\"),\n\t(673:\"wm_mousehover\"),\n\t(675:\"wm_mouseleave\"),\n\t(689:\"wm_wtssession_change\"),\n\t(768:\"wm_cut\"),\n\t(769:\"wm_copy\"),\n\t(770:\"wm_paste\"),\n\t(771:\"wm_clear\"),\n\t(772:\"wm_undo\"),\n\t(773:\"wm_renderformat\"),\n\t(774:\"wm_renderallformats\"),\n\t(775:\"wm_destroyclipboard\"),\n\t(776:\"wm_drawclipboard\"),\n\t(777:\"wm_paintclipboard\"),\n\t(778:\"wm_vscrollclipboard\"),\n\t(779:\"wm_sizeclipboard\"),\n\t(780:\"wm_askcbformatname\"),\n\t(781:\"wm_changecbchain\"),\n\t(782:\"wm_hscrollclipboard\"),\n\t(783:\"wm_querynewpalette\"),\n\t(784:\"wm_paletteischanging\"),\n\t(785:\"wm_palettechanged\"),\n\t(786:\"wm_hotkey\"),\n\t(791:\"wm_print\"),\n\t(792:\"wm_printclient\"),\n\t(896:\"wm_penwinirst\"),\n\t(911:\"wm_penwinlast\"),\n\t(1024:\"infotipsize\"),\n\t(1025:\"cbem_insertitema\"),\n\t(1026:\"cbem_setimagelist\"),\n\t(1027:\"cbem_getimagelist\"),\n\t(1028:\"cbem_getitema\"),\n\t(1029:\"cbem_setitema\"),\n\t(1030:\"cbem_getcombocontrol\"),\n\t(1031:\"cbem_geteditcontrol\"),\n\t(1032:\"cbem_setexstyle\"),\n\t(1033:\"cbem_getextendedstyle\"),\n\t(1034:\"cbem_haseditchanged\"),\n\t(1035:\"cbem_insertitemw\"),\n\t(1036:\"cbem_setitemw\"),\n\t(1037:\"cbem_getitemw\"),\n\t(1038:\"cbem_setextendedstyle\"),\n\t(1039:\"ttm_getcurrenttoola\"),\n\t(1040:\"ttm_windowfrompoint\"),\n\t(1041:\"ttm_trackactivate\"),\n\t(1042:\"ttm_trackposition\"),\n\t(1043:\"ttm_settipbkcolor\"),\n\t(1044:\"ttm_settiptextcolor\"),\n\t(1045:\"ttm_getdelaytime\"),\n\t(1046:\"ttm_gettipbkcolor\"),\n\t(1047:\"ttm_gettiptextcolor\"),\n\t(1048:\"ttm_setmaxtipwidth\"),\n\t(1049:\"ttm_getmaxtipwidth\"),\n\t(1050:\"ttm_setmargin\"),\n\t(1051:\"ttm_getmargin\"),\n\t(1052:\"ttm_pop\"),\n\t(1053:\"tb_getitemrect\"),\n\t(1054:\"tb_buttonstructsize\"),\n\t(1055:\"tb_setbuttonsize\"),\n\t(1056:\"tb_setbitmapsize\"),\n\t(1057:\"tb_autosize\"),\n\t(1059:\"tb_gettooltips\"),\n\t(1060:\"tb_settooltips\"),\n\t(1061:\"tb_setparent\"),\n\t(1063:\"tb_setrows\"),\n\t(1064:\"tb_getrows\"),\n\t(1065:\"tb_getbitmapflags\"),\n\t(1066:\"tb_setcmdid\"),\n\t(1067:\"tb_changebitmap\"),\n\t(1068:\"tb_getbitmap\"),\n\t(1069:\"tb_getbuttontexta\"),\n\t(1070:\"tb_replacebitmap\"),\n\t(1071:\"tb_setindent\"),\n\t(1072:\"tb_setimagelist\"),\n\t(1073:\"tb_getimagelist\"),\n\t(1074:\"ttm_addtoolw\"),\n\t(1075:\"ttm_deltoolw\"),\n\t(1076:\"ttm_newtoolrectw\"),\n\t(1077:\"ttm_gettoolinfow\"),\n\t(1078:\"ttm_settoolinfow\"),\n\t(1079:\"ttm_hittestw\"),\n\t(1080:\"ttm_gettextw\"),\n\t(1081:\"ttm_updatetiptextw\"),\n\t(1082:\"ttm_enumtoolsw\"),\n\t(1083:\"ttm_getcurrenttoolw\"),\n\t(1084:\"tb_setmaxtextrows\"),\n\t(1085:\"tb_gettextrows\"),\n\t(1086:\"em_getseltext\"),\n\t(1087:\"em_hideselection\"),\n\t(1088:\"em_pastespecial\"),\n\t(1089:\"em_requestresize\"),\n\t(1090:\"em_selectiontype\"),\n\t(1091:\"tb_insertbuttonw\"),\n\t(1092:\"tb_addbuttonsw\"),\n\t(1093:\"tb_hittest\"),\n\t(1094:\"em_setolecallback\"),\n\t(1095:\"em_setparaformat\"),\n\t(1096:\"em_settargetdevice\"),\n\t(1097:\"em_streamin\"),\n\t(1098:\"em_streamout\"),\n\t(1099:\"tb_getbuttontextw\"),\n\t(1100:\"tb_saverestorew\"),\n\t(1101:\"tb_addstringw\"),\n\t(1102:\"em_getoptions\"),\n\t(1103:\"tb_getinsertmark\"),\n\t(1104:\"tb_setinsertmark\"),\n\t(1105:\"tb_insertmarkhittest\"),\n\t(1106:\"tb_movebutton\"),\n\t(1107:\"tb_getmaxsize\"),\n\t(1108:\"tb_setextendedstyle\"),\n\t(1109:\"tb_getextendedstyle\"),\n\t(1110:\"tb_getpadding\"),\n\t(1111:\"tb_setpadding\"),\n\t(1112:\"tb_setinsertmarkcolor\"),\n\t(1113:\"tb_getinsertmarkcolor\"),\n\t(1114:\"tb_mapacceleratorw\"),\n\t(1124:\"em_setpunctuation\"),\n\t(1125:\"wm_choosefont_setlogfont\"),\n\t(1126:\"wm_choosefont_setflags\"),\n\t(1127:\"udm_setpos\"),\n\t(1128:\"udm_getpos\"),\n\t(1129:\"udm_setbuddy\"),\n\t(1130:\"udm_getbuddy\"),\n\t(1131:\"udm_setaccel\"),\n\t(1132:\"udm_getaccel\"),\n\t(1133:\"udm_setbase\"),\n\t(1134:\"udm_getbase\"),\n\t(1135:\"psm_settitlea\"),\n\t(1136:\"psm_setwizbuttons\"),\n\t(1137:\"psm_pressbutton\"),\n\t(1138:\"psm_setcurselid\"),\n\t(1139:\"psm_setfinishtexta\"),\n\t(1140:\"psm_gettabcontrol\"),\n\t(1141:\"psm_isdialogmessage\"),\n\t(1142:\"psm_getcurrentpagehwnd\"),\n\t(1144:\"psm_settitlew\"),\n\t(1145:\"psm_setfinishtextw\"),\n\t(1157:\"dl_begindrag\"),\n\t(1158:\"dl_dragging\"),\n\t(1159:\"dl_dropped\"),\n\t(1160:\"dl_canceldrag\"),\n\t(1280:\"en_errspace\"),\n\t(1281:\"en_maxtext\"),\n\t(1537:\"en_hscroll\"),\n\t(1538:\"en_vscroll\"),\n\t(1792:\"en_msgfilter\"),\n\t(1793:\"en_requestresize\"),\n\t(1794:\"en_selchange\"),\n\t(1795:\"en_dropfiles\"),\n\t(1796:\"en_protected\"),\n\t(1797:\"en_correcttext\"),\n\t(1798:\"en_stopnoundo\"),\n\t(1799:\"en_imechange\"),\n\t(1800:\"en_saveclipboard\"),\n\t(1801:\"en_oleopfailed\"),\n\t(4096:\"lvm_getbkcolor\"),\n\t(4097:\"lvm_setbkcolor\"),\n\t(4098:\"lvm_getimagelist\"),\n\t(4099:\"lvm_setimagelist\"),\n\t(4100:\"lvm_getitemcount\"),\n\t(4101:\"lvm_getitema\"),\n\t(4102:\"lvm_setitema\"),\n\t(4103:\"lvm_insertitema\"),\n\t(4104:\"lvm_deleteitem\"),\n\t(4105:\"lvm_deleteallitems\"),\n\t(4106:\"lvm_getcallbackmask\"),\n\t(4107:\"lvm_setcallbackmask\"),\n\t(4108:\"lvm_getnextitem\"),\n\t(4109:\"lvm_finditema\"),\n\t(4110:\"lvm_getitemrect\"),\n\t(4111:\"lvm_setitemposition\"),\n\t(4112:\"lvm_getitemposition\"),\n\t(4113:\"lvm_getstringwidtha\"),\n\t(4114:\"lvm_hittest\"),\n\t(4115:\"lvm_ensurevisible\"),\n\t(4116:\"lvm_scroll\"),\n\t(4117:\"lvm_redrawitems\"),\n\t(4118:\"lvm_arrange\"),\n\t(4119:\"lvm_editlabela\"),\n\t(4120:\"lvm_geteditcontrol\"),\n\t(4121:\"lvm_getcolumna\"),\n\t(4122:\"lvm_setcolumna\"),\n\t(4123:\"lvm_insertcolumna\"),\n\t(4124:\"lvm_deletecolumn\"),\n\t(4125:\"lvm_getcolumnwidth\"),\n\t(4126:\"lvm_setcolumnwidth\"),\n\t(4129:\"lvm_createdragimage\"),\n\t(4130:\"lvm_getviewrect\"),\n\t(4131:\"lvm_gettextcolor\"),\n\t(4132:\"lvm_settextcolor\"),\n\t(4133:\"lvm_gettextbkcolor\"),\n\t(4134:\"lvm_settextbkcolor\"),\n\t(4135:\"lvm_gettopindex\"),\n\t(4136:\"lvm_getcountperpage\"),\n\t(4137:\"lvm_getorigin\"),\n\t(4138:\"lvm_update\"),\n\t(4139:\"lvm_setitemstate\"),\n\t(4140:\"lvm_getitemstate\"),\n\t(4141:\"lvm_getitemtexta\"),\n\t(4142:\"lvm_setitemtexta\"),\n\t(4143:\"lvm_setitemcount\"),\n\t(4144:\"lvm_sortitems\"),\n\t(4145:\"lvm_setitemposition32\"),\n\t(4146:\"lvm_getselectedcount\"),\n\t(4147:\"lvm_getitemspacing\"),\n\t(4148:\"lvm_getisearchstringa\"),\n\t(4171:\"lvm_getitemw\"),\n\t(4172:\"lvm_setitemw\"),\n\t(4173:\"lvm_insertitemw\"),\n\t(4179:\"lvm_finditemw\"),\n\t(4183:\"lvm_getstringwidthw\"),\n\t(4191:\"lvm_getcolumnw\"),\n\t(4192:\"lvm_setcolumnw\"),\n\t(4193:\"lvm_insertcolumnw\"),\n\t(4211:\"lvm_getitemtextw\"),\n\t(4212:\"lvm_setitemtextw\"),\n\t(4213:\"lvm_getisearchstringw\"),\n\t(4214:\"lvm_editlabelw\"),\n\t(4352:\"tvm_insertitema\"),\n\t(4353:\"tvm_deleteitem\"),\n\t(4354:\"tvm_expand\"),\n\t(4356:\"tvm_getitemrect\"),\n\t(4357:\"tvm_getcount\"),\n\t(4358:\"tvm_getindent\"),\n\t(4359:\"tvm_setindent\"),\n\t(4360:\"tvm_getimagelist\"),\n\t(4361:\"tvm_setimagelist\"),\n\t(4362:\"tvm_getnextitem\"),\n\t(4363:\"tvm_selectitem\"),\n\t(4364:\"tvm_getitema\"),\n\t(4365:\"tvm_setitema\"),\n\t(4366:\"tvm_editlabela\"),\n\t(4367:\"tvm_geteditcontrol\"),\n\t(4368:\"tvm_getvisiblecount\"),\n\t(4369:\"tvm_hittest\"),\n\t(4370:\"tvm_createdragimage\"),\n\t(4371:\"tvm_sortchildren\"),\n\t(4372:\"tvm_ensurevisible\"),\n\t(4373:\"tvm_sortchildrencb\"),\n\t(4374:\"tvm_endeditlabelnow\"),\n\t(4375:\"tvm_getisearchstringa\"),\n\t(4402:\"tvm_insertitemw\"),\n\t(4414:\"tvm_getitemw\"),\n\t(4415:\"tvm_setitemw\"),\n\t(4416:\"tvm_getisearchstringw\"),\n\t(4417:\"tvm_editlabelw\"),\n\t(4608:\"hdm_getitemcount\"),\n\t(4609:\"hdm_insertitema\"),\n\t(4610:\"hdm_deleteitem\"),\n\t(4611:\"hdm_getitema\"),\n\t(4612:\"hdm_setitema\"),\n\t(4613:\"hdm_layout\"),\n\t(4614:\"hdm_hittest\"),\n\t(4618:\"hdm_insertitemw\"),\n\t(4619:\"hdm_getitemw\"),\n\t(4620:\"hdm_setitemw\"),\n\t(4864:\"tcm_first\"),\n\t(4866:\"tcm_getimagelist\"),\n\t(4867:\"tcm_setimagelist\"),\n\t(4868:\"tcm_getitemcount\"),\n\t(4869:\"tcm_getitema\"),\n\t(4870:\"tcm_setitema\"),\n\t(4871:\"tcm_insertitema\"),\n\t(4872:\"tcm_deleteitem\"),\n\t(4873:\"tcm_deleteallitems\"),\n\t(4874:\"tcm_getitemrect\"),\n\t(4875:\"tcm_getcursel\"),\n\t(4876:\"tcm_setcursel\"),\n\t(4877:\"tcm_hittest\"),\n\t(4878:\"tcm_setitemextra\"),\n\t(4904:\"tcm_adjustrect\"),\n\t(4905:\"tcm_setitemsize\"),\n\t(4906:\"tcm_removeimage\"),\n\t(4907:\"tcm_setpadding\"),\n\t(4908:\"tcm_getrowcount\"),\n\t(4909:\"tcm_gettooltips\"),\n\t(4910:\"tcm_settooltips\"),\n\t(4911:\"tcm_getcurfocus\"),\n\t(4912:\"tcm_setcurfocus\"),\n\t(4924:\"tcm_getitemw\"),\n\t(4925:\"tcm_setitemw\"),\n\t(4926:\"tcm_insertitemw\"),\n\t(5120:\"pgm_first\"),\n\t(8192:\"ccm_first\")]\n\nproc start=\nend\n",
(u64)"export enumdata optionnames =\n\t(wf_border,\t\t$),\t\t! wbs_simple\n\t(wf_resize,\t\t$),\t\t! 0\n\t(wf_hscroll,\t$),\t\t! 0\n\t(wf_vscroll,\t$),\t\t! 0\n\t(wf_menu,\t\t$),\t\t! 0\n\t(wf_caption,\t$),\t\t! 1\n\t(wf_max,\t\t$),\t\t! 0\n\t(wf_minmax,\t\t$),\t\t! 1\n\t(wf_sysmenu,\t$),\t\t! 1\n\t(wf_desktop,\t$),\t\t! 0\n\t(wf_clip,\t\t$),\t\t! 0\n\t(wf_show,\t\t$),\t\t!\n\t(wf_iframe,\t\t$),\t\t! 1\n\t(wf_cent,\t\t$),\t\t!\n\t(wf_toolwind,\t$)\t\t!\nend\n\n!Windows border styles, used for pop-up windows. Could also be used for\n!some child windows\nexport enumdata wbsnames=\n\t(wbs_none=0,$),\n\t(wbs_simple,$),\n\t(wbs_thick,$),\n\t(wbs_resize,$),\n\t(wbs_sunken,$),\n\t(wbs_sunken2,$),\n\t(wbs_sunkenrs,$),\n\t(wbs_dummy,$)\nend\n",
(u64)"\nexport var daynames=(\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\")\n\nexport var Monthnames=(\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\n\t\t\"August\",\"September\",\"October\",\"November\",\"December\")\n\nexport var days=(31,28,31, 30,31,30, 31,31,30, 31,30,31)\n\nexport record rdate=\n\tvar day,month,year\nend\n\nexport record rdatetime = \n\tvar\tday\n\tvar\tmonth\n\tvar\tyear\n\tvar\thour\n\tvar\tminute\n\tvar\tsecond\n\tvar\tmilliseconds\n\tvar\tdayofweek\nend\n\n!proc start=\n!end\n!\n!proc main=\n!end\n\nexport func makedatetime(d,m,y, h=0, minute=0, s=0)=\n\n\td:=rdatetime(d,m,y, h,minute,s,0,0)\n\td.dayofweek:=getdow(d)\n\treturn d\nend\n\nexport proc setdow(&d)=\n\td.dayofweek:=getdow(d)\nend\n\nexport func strdate(d,sep=\"-\")=\n!return leftstr(daynames[d.dayofweek],3)+\" \"+tostr(d.day)+sep+leftstr(monthnames[d.month],3)+sep+tostr(d.year)\n\treturn tostr(d.day)+sep+leftstr(monthnames[d.month],3)+sep+tostr(d.year)\nend\n\nexport func strtime(d,sep=\":\")=\n\treturn tostr(d.hour)+sep+tostr(d.minute,\"z2\")+sep+tostr(d.second,\"z2\")\nend\n\nexport func strdow(d,n=0)=\n\tif n then\n\t\treturn leftstr(daynames[d.dayofweek],n)\n\telse\n\t\treturn daynames[d.dayofweek]\n\tfi\nend\n\nexport func strdatetime(d,dsep=\"-\",tsep=\":\")=\n\treturn strdate(d,dsep)+\" \"+strtime(d,tsep)\nend\n\nexport func parsedate(s,defdate)=\n!parse string s into a new date record\n!def = default date to work from, eg. for missing year\n!return date record obtained, or 0 if error\n\n\tday:=defdate.day\n\tmonth:=defdate.month\n\tyear:=defdate.year\n\tif s.[1]=\" \" then s:=rightstr(s,-1) fi\n\n\tsepset:=[' ', '-', '/', '.']\n\n\tseppos:=0\n\tfor i:=1 to s.len do if s.[i] in sepset then seppos:=i; exit fi od\n\n\tif not seppos then\t\t!day only\n\t\tday:=strtoval(s)\n\t\tgoto gotday\n\tfi\n\tday:=strtoval(leftstr(s,seppos-1))\n\n\ts:=rightstr(s,-seppos)\t\t!month and possible year\n\tseppos:=0\n\tfor i:=1 to s.len do if s.[i] in sepset then seppos:=i; exit fi od\n\n\tif seppos then\n\t\tmonthstr:=leftstr(s,seppos-1)\n\t\tyearstr:=rightstr(s,s.len-seppos)\n\telse\n\t\tmonthstr:=s\n\t\tyearstr:=\"\"\n\tfi\n\n\tif asc(leftstr(monthstr)) in ['0'..'9'] then\t!numeric month\n\t\tmonth:=strtoval(monthstr)\n\t\tif month<1 or month>12 then\n\t\t\treturn 0\n\t\tfi\n\telse\n\t\tmonth:=0\n\t\tfor i:=1 to 12 do\n\t\t\tif convlc(leftstr(monthnames[i],3))=convlc(leftstr(monthstr,3)) then\n\t\t\t\tmonth:=i\n\t\t\t\texit\n\t\t\tfi\n\t\tod\n\t\tif not month then\n\t\t\treturn 0\n\t\tfi\n\tfi\n\n\tif yearstr<>\"\" then\n\t\tyear:=strtoval(yearstr)\n\t\tif year<200 then\n\t\t\tif year in [00..89] then\n\t\t\t\tyear+:=2000\n\t\t\telse\n\t\t\t\tyear+:=1900\n\t\t\tfi\n\t\tfi\n\tfi\n\ngotday:\n!check the date, rather than correct using addday(d,0)\n\tdd:=days[month] \n\tif leapyear(year) and month=2 then dd+:=1 fi\n\tif day<1 or day>dd then return 0 fi\n\tif year<1990 or year>2089 then return 0 fi\n\treturn makedatetime(day,month,year)\nend\n\nexport func leapyear(y)=\n!return true if y (eg. 1994) is a leap year\n\treturn (y-1900) rem 4=0\nend\n\nexport func getdow(d)=\n!return day of week for given date, returning 1..7 (monday..sunday)\n\treturn ((getday(d)-1) rem 7)+1\nend\n\nexport func getday(d)=\n!return day number for date d, measured from 1.1.90\n\tday:=0\n\tfor i:=1990 to d.year-1 do\n\t\tday+:=(leapyear(i)|366|365)\n\tod\n\n\tfor i:=1 to d.month-1 do\n\t\tday+:=(i=2|(leapyear(d.year)|29|28)|days[i])\n\tod\n\tday+:=d.day\n\treturn day\nend\n\nexport func getdays(m,y)=\n!return no. of days in month m, for year y\n\tif leapyear(y) and m=2 then return 29 fi\n\treturn days[m]\nend\n\nexport func getmonthname(m,?n)=\n\tif not m.isint then\n\t\tm:=m.month\n\tfi\n\tm:=monthnames[m]\n\tif n.defined then m:=leftstr(m,n) fi\n\treturn m\nend\n\nexport func getdayname(d,?n)=\n\tif not d.isint then\n\t\td:=getdow(d)\n\tfi\n\td:=daynames[d]\n\tif n.defined then d:=leftstr(d,n) fi\n\treturn d\nend\n\nexport func addday(d0,i)=\n\td:=d0\n\tif i>0 then\n\t\tto i do\n\t\t\t++d.day\n\t\t\tif d.day>getdays(d.month,d.year) then\n\t\t\t\td.day:=1\n\t\t\t\t++d.month\n\t\t\t\tif d.month>12 then\n\t\t\t\t\td.month:=1\n\t\t\t\t\t++d.year\n\t\t\t\tfi\n\t\t\tfi\n\t\tod\n\telse\n\t\tto -i do\n\t\t\t--d.day\n\t\t\tif d.day<1 then\n\t\t\t\t--d.month\n\t\t\t\tif d.month<1 then\n\t\t\t\t\td.month:=12\n\t\t\t\t\t--d.year\n\t\t\t\tfi\n\t\t\t\td.day:=getdays(d.month,d.year)\n\t\t\tfi\n\t\tod\n\tfi\n\n!do checking\n\tif d.year<1990 then d:=makedatetime(1,1,1990) fi\n\tif d.year>2089 then d:=makedatetime(31,12,2089) fi\n\n\tdd:=getdays(d.month,d.year)\n\tif leapyear(d.year) and d.month=2 then dd+:=1 fi\n\tif d.day<1 then d.day:=1 fi\n\tif d.day>dd then d.day:=dd fi\n\tsetdow(d)\n\treturn d\nend\n\nexport func getdatetime=\n\ttm:=getsystime()\n\n\treturn rdatetime(tm.day,tm.month,tm.year,\n\t\t\ttm.hour, tm.minute, tm.second, tm.milliseconds,tm.dayofweek)\nend\n\nexport func getsystime=\n\ttm:=new(ws_systemtime)\n\tgetsystemtime(&tm)\n\n\tif tm.dayofweek=0 then\n\t\ttm.dayofweek:=7\n\tfi\n\n\treturn tm\nend\n"}};

static struct $B43 qq_tables_stdtypenames = {{
(u64)"void",
(u64)"int",
(u64)"real",
(u64)"decimal",
(u64)"range",
(u64)"set",
(u64)"dict",
(u64)"vector",
(u64)"bits",
(u64)"string",
(u64)"list",
(u64)"array",
(u64)"record",
(u64)"struct",
(u64)"refvar",
(u64)"refbit",
(u64)"refpack",
(u64)"symbol",
(u64)"type",
(u64)"operator",
(u64)"retaddr",
(u64)"except",
(u64)"number",
(u64)"i8",
(u64)"i16",
(u64)"i32",
(u64)"i64",
(u64)"u8",
(u64)"u16",
(u64)"u32",
(u64)"u64",
(u64)"r32",
(u64)"r64",
(u64)"u1",
(u64)"u2",
(u64)"u4",
(u64)"packstrc",
(u64)"packstrz",
(u64)"stringz",
(u64)"refproc",
(u64)"slice"}};

static struct $B44 qq_tables_stdtypewidths = {{
0,
64,
64,
0,
64,
0,
0,
0,
0,
0,
0,
0,
0,
0,
64,
128,
64,
64,
64,
64,
0,
0,
0,
8,
16,
32,
64,
8,
16,
32,
64,
32,
64,
1,
2,
4,
0,
0,
64,
64,
0}};

static struct $B45 qq_tables_jtagnames = {{
(u64)"jnone",
(u64)"jlabeldef",
(u64)"jassign",
(u64)"jkeyword",
(u64)"jkeyvalue",
(u64)"joperator",
(u64)"jblock",
(u64)"jif",
(u64)"jselect",
(u64)"jwhenthen",
(u64)"jcase",
(u64)"jdocase",
(u64)"jswitch",
(u64)"jdoswitch",
(u64)"jrecase",
(u64)"jfor",
(u64)"jforx",
(u64)"jforall",
(u64)"jforeach",
(u64)"jdo",
(u64)"jto",
(u64)"jwhile",
(u64)"jrepeat",
(u64)"jtry",
(u64)"jexcept",
(u64)"jraise",
(u64)"jcall",
(u64)"jcallhost",
(u64)"jnil",
(u64)"jswap",
(u64)"jgoto",
(u64)"jstop",
(u64)"jreturn",
(u64)"jeval",
(u64)"jtypeconst",
(u64)"jconvert",
(u64)"jtypepun",
(u64)"jmap",
(u64)"jcmpchain",
(u64)"jname",
(u64)"jsymbol",
(u64)"jintconst",
(u64)"jrealconst",
(u64)"jstringconst",
(u64)"jdecimal",
(u64)"jstrinclude",
(u64)"jdot",
(u64)"jindex",
(u64)"jdotindex",
(u64)"jkeyindex",
(u64)"jloop",
(u64)"jptr",
(u64)"jaddrof",
(u64)"jvoid",
(u64)"jprint",
(u64)"jfprint",
(u64)"jnogap",
(u64)"jspace",
(u64)"jfmtitem",
(u64)"jread",
(u64)"jincrload",
(u64)"jloadincr",
(u64)"junary",
(u64)"jbin",
(u64)"jmaths",
(u64)"jmaths2",
(u64)"jproperty",
(u64)"jbounds",
(u64)"jgettype",
(u64)"jistype",
(u64)"jisvoid",
(u64)"jcmp",
(u64)"jandl",
(u64)"jorl",
(u64)"jnotl",
(u64)"jistruel",
(u64)"jin",
(u64)"jinx",
(u64)"junaryto",
(u64)"jbinto",
(u64)"jandlto",
(u64)"jorlto",
(u64)"jnotlto",
(u64)"jistruelto",
(u64)"jappendto",
(u64)"jconcatto",
(u64)"jidivrem",
(u64)"jmakerange",
(u64)"jmakelist",
(u64)"jmakeset",
(u64)"jmakedict",
(u64)"jcvattr"}};

static struct $B46 qq_tables_jflags = {{
33685760,
33619970,
33686018,
33620482,
16908802,
33686018,
16908546,
16843264,
16777473,
66049,
1,
33685760,
16908802,
33685505,
33685504,
33620225,
16843265,
33620225,
16843266,
33620482,
16843266,
33554946,
65793}};

static struct $B46 qq_tables_jhasvalue = {{
16908288,
33685761,
131074,
2,
0,
0,
16842752,
1,
16842754,
16843009,
16843009,
16843009,
16777473,
257,
0,
16843009,
16843009,
16843009,
16843009,
65793,
0,
16908288,
16843009}};

static struct $B47 qq_tables_symbolnames = {{
491496043109,
7630692,
418447716195,
1768777075,
474315779939,
121390429860705,
122545691846003,
1701865840,
118074580820588,
118074580820594,
7435116,
7435122,
133506683724652,
133506683724658,
7500912,
7496034,
29793,
7957695015460107633,
1919181921,
435526984050,
8316305113558576229,
6579297,
6452595,
7107949,
7760228,
1986618473,
1835364969,
30792314748757097,
1818521185,
7107183,
1684955497,
7499625,
1919907945,
7104627,
7497843,
132359843113325,
110425311047777,
127961628831587,
28265,
7892585,
491328597872,
1701667187,
29029,
25966,
29804,
25964,
25959,
29799,
1819570030,
1953459817,
30510852590564201,
7561825,
6517601,
7497827,
495673696621,
55471255085421,
1886351984,
111533748417385,
110404004377449,
1919118953,
7106405,
6713189,
8391171955410366057,
8391171955409249636,
32778015450820710,
8391171955410233443,
8391171955410236531,
7308604897319546485,
1701667182,
28552639593870451,
491260502889,
26217,
1852139636,
439855836261,
1702063205,
7310293699684166757,
131337507007589,
30510843782458469,
6581861,
126939460038261,
1702060387,
111546229548402,
1852139639,
7499622,
28532,
31074,
28516,
435610544247,
127961662514546,
465625706101,
121437875889522,
1886352499,
1886351212,
1869901671,
114776364119923,
500068610672,
128017564332147,
1684104562,
1668248176,
1668183398,
465557414252,
110442657834354,
127970521019507,
474315583093,
111516500389741,
128034844732777,
28275532515798377,
1701869940,
6710642,
7496054,
478660485485,
28783,
500152823651,
119165519096935,
109304575259763,
121390429397347,
7959156,
128026086176869,
435727982962,
1953718627,
32195308665270115,
125762756439908,
1818326629,
27431034385752436,
7364973,
482871438435,
1885435763,
8391171955410303347,
121386319441768,
7104878,
30508623351411827,
123623711273075}};

static struct $B48 qq_tables_namenames = {{
(u64)"genericid",
(u64)"programid",
(u64)"subprogid",
(u64)"moduleid",
(u64)"dllmoduleid",
(u64)"procid",
(u64)"anonprocid",
(u64)"dllprocid",
(u64)"dllvarid",
(u64)"recordid",
(u64)"typeid",
(u64)"fieldid",
(u64)"structfieldid",
(u64)"staticid",
(u64)"frameid",
(u64)"paramid",
(u64)"dllparamid",
(u64)"labelid",
(u64)"constid",
(u64)"enumid",
(u64)"aliasid",
(u64)"linkid",
(u64)"macroid",
(u64)"macroparamid",
(u64)"structblockid",
(u64)"unionblockid",
(u64)"endblockid"}};

static struct $B8 qq_tables_objtypenames = {{
(u64)"normal_obj",
(u64)"slice_obj",
(u64)"extslice_obj"}};

static struct $B8 qq_tables_scopenames = {{
(u64)"local_scope",
(u64)"global_scope",
(u64)"export_scope"}};

static struct $B49 qq_tables_stnames = {{
(u64)"if",
(u64)"then",
(u64)"elsif",
(u64)"else",
(u64)"elsecase",
(u64)"elseswitch",
(u64)"case",
(u64)"docase",
(u64)"recase",
(u64)"when",
(u64)"for",
(u64)"foreach",
(u64)"to",
(u64)"downto",
(u64)"by",
(u64)"do",
(u64)"end",
(u64)"while",
(u64)"repeat",
(u64)"until",
(u64)"always",
(u64)"return",
(u64)"stop",
(u64)"redoloop",
(u64)"nextloop",
(u64)"exit",
(u64)"goto",
(u64)"switch",
(u64)"doswitch",
(u64)"tabledata",
(u64)"enumdata",
(u64)"clamp",
(u64)"maps",
(u64)"mapss",
(u64)"eval",
(u64)"print",
(u64)"println",
(u64)"fprint",
(u64)"fprintln",
(u64)"sprint",
(u64)"sfprint",
(u64)"cp",
(u64)"cpl",
(u64)"read",
(u64)"readln",
(u64)"cast",
(u64)"proc",
(u64)"sub",
(u64)"function",
(u64)"func",
(u64)"fun",
(u64)"method",
(u64)"type",
(u64)"record",
(u64)"struct",
(u64)"union",
(u64)"ref",
(u64)"var",
(u64)"macro",
(u64)"static",
(u64)"$caligned",
(u64)"const",
(u64)"module",
(u64)"import",
(u64)"importdll",
(u64)"strinclude",
(u64)"unless",
(u64)"try",
(u64)"except",
(u64)"raise",
(u64)"global",
(u64)"export",
(u64)"swap",
(u64)"void",
(u64)"int",
(u64)"real",
(u64)"string",
(u64)"list",
(u64)"array",
(u64)"vector",
(u64)"bits",
(u64)"set",
(u64)"dict",
(u64)"decimal",
(u64)"longint",
(u64)"typetype",
(u64)"range",
(u64)"recordtype",
(u64)"cvoid",
(u64)"i8",
(u64)"i16",
(u64)"i32",
(u64)"i64",
(u64)"bit",
(u64)"u1",
(u64)"u2",
(u64)"u4",
(u64)"byte",
(u64)"u8",
(u64)"u16",
(u64)"u32",
(u64)"u64",
(u64)"r32",
(u64)"r64",
(u64)"stringc",
(u64)"stringz",
(u64)"cstring",
(u64)"ichar",
(u64)"million",
(u64)"billion",
(u64)"as",
(u64)"$lineno",
(u64)"$strlineno",
(u64)"$filename",
(u64)"$modulename",
(u64)"$function",
(u64)"$date",
(u64)"$time",
(u64)"$",
(u64)"and",
(u64)"or",
(u64)"iand",
(u64)"ior",
(u64)"ixor",
(u64)"in",
(u64)"inx",
(u64)"rem",
(u64)"divrem",
(u64)"min",
(u64)"max",
(u64)"not",
(u64)"istrue",
(u64)"inot",
(u64)"abs",
(u64)"asc",
(u64)"chr",
(u64)"sqrt",
(u64)"sqr",
(u64)"cos",
(u64)"sin",
(u64)"tan",
(u64)"asin",
(u64)"acos",
(u64)"atan",
(u64)"atan2",
(u64)"sign",
(u64)"log",
(u64)"log10",
(u64)"exp",
(u64)"round",
(u64)"floor",
(u64)"ceil",
(u64)"fract",
(u64)"fmod",
(u64)"append",
(u64)"concat",
(u64)"len",
(u64)"lwb",
(u64)"upb",
(u64)"bounds",
(u64)"bytes",
(u64)"isfound",
(u64)"dictitems",
(u64)"basetype",
(u64)"elemtype",
(u64)"isvoid",
(u64)"isdef",
(u64)"defined",
(u64)"isint",
(u64)"isreal",
(u64)"islist",
(u64)"isstring",
(u64)"isrange",
(u64)"ispointer",
(u64)"isarray",
(u64)"isrecord",
(u64)"isset",
(u64)"isnumber",
(u64)"fi",
(u64)"esac",
(u64)"od",
(u64)"nil",
(u64)"con",
(u64)"pi",
(u64)"true",
(u64)"false",
(u64)"$neg",
(u64)"$$dummy"}};

static struct $B50 qq_tables_stsymbols = {{
1263159624,
1364282700,
1414812498,
1465275733,
1515804751,
1566333786,
1600019805,
2122087519,
1618705789,
1633706080,
1650483297,
1667463266,
1684300900,
1751606892,
1936682605,
1785295220,
1968210795,
1920104310,
1179010687,
1179010630,
1179010630,
1179010630,
1179010630,
1179010630,
1179010630,
1179010630,
1179010630,
2034517060,
2038004089,
494565753,
555753246,
471541799,
858858532,
909456434,
926365495,
926365495,
926365496,
926365495,
639973431,
960051513,
993605945,
993737531,
976894522,
976894522,
1330592314,
2155905615,
8683648}};

static struct $B50 qq_tables_stsubcodes = {{
458752,
185207818,
16777230,
256,
0,
16777216,
201327362,
65549,
0,
67305985,
65542,
16780545,
65536,
0,
0,
0,
68,
33619968,
33619968,
118163977,
50726152,
201593347,
421009152,
572596506,
471538467,
538910237,
639968548,
16777986,
84148994,
1207961350,
1852664905,
1802108928,
1263170932,
1364216910,
50594305,
134678021,
185207058,
252579084,
1987514640,
1515804759,
1650286171,
1684305509,
151650817,
202051076,
1363678725,
16973911,
2950404}};

static struct $B51 qq_tables_hostfnnames = {{
(u64)"h_dummy",
(u64)"h_startprint",
(u64)"h_startprintcon",
(u64)"h_strstartprint",
(u64)"h_setformat",
(u64)"h_endprint",
(u64)"h_strendprint",
(u64)"h_print",
(u64)"h_print_nf",
(u64)"h_println",
(u64)"h_printnogap",
(u64)"h_printspace",
(u64)"h_readln",
(u64)"h_sreadln",
(u64)"h_sread",
(u64)"h_rereadln",
(u64)"h_reread",
(u64)"h_strtoval",
(u64)"h_tostr",
(u64)"h_leftstr",
(u64)"h_rightstr",
(u64)"h_convlc",
(u64)"h_convuc",
(u64)"h_waitkey",
(u64)"h_testkey",
(u64)"h_execwait",
(u64)"h_execcmd",
(u64)"h_system",
(u64)"h_makestr",
(u64)"h_makeref",
(u64)"h_new",
(u64)"h_getcmdparam",
(u64)"h_gethostname",
(u64)"h_getprogname",
(u64)"h_$setdebug",
(u64)"h_$test2",
(u64)"h_$test",
(u64)"h_$refcount",
(u64)"h_ticks",
(u64)"h_clock",
(u64)"h_sleep",
(u64)"h_random",
(u64)"h_gethash",
(u64)"h_getos",
(u64)"h_iswindows",
(u64)"h_setmesshandler",
(u64)"h_$getstdinout",
(u64)"h_$getparam",
(u64)"h_makeempty",
(u64)"h_$smallmemtotal",
(u64)"h_$id",
(u64)"h_copy",
(u64)"h_$nan",
(u64)"h_$infinity",
(u64)"h_$nprocs",
(u64)"h_$procname",
(u64)"h_$procref",
(u64)"h_allocexec",
(u64)"h_runnative",
(u64)"h_setlwb",
(u64)"h_last"}};

static struct $B52 qq_tables_hostnparams = {{
0,
1,
0,
0,
1,
0,
0,
2,
1,
0,
0,
0,
1,
1,
1,
0,
0,
2,
2,
3,
3,
2,
2,
0,
0,
3,
3,
1,
2,
2,
4,
1,
0,
0,
1,
2,
3,
1,
0,
0,
1,
1,
1,
0,
0,
1,
1,
1,
1,
0,
1,
1,
0,
0,
0,
1,
1,
1,
2,
2,
0}};

static struct $B52 qq_tables_hostisfn = {{
0,
0,
0,
0,
0,
0,
1,
0,
0,
0,
0,
0,
0,
1,
1,
0,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
0}};

static struct $B52 qq_tables_hostinternal = {{
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1}};

static struct $B51 qq_tables_hosthandlers = {{
0,
(u64)&qq_print_pch_startprint,
(u64)&qq_print_pch_startprintcon,
(u64)&qq_print_pch_strstartprint,
(u64)&qq_print_pch_setformat,
(u64)&qq_print_pch_endprint,
(u64)&qq_print_pch_strendprint,
(u64)&qq_print_pch_print,
(u64)&qq_print_pch_print_nf,
(u64)&qq_print_pch_println,
(u64)&qq_print_pch_printnogap,
(u64)&qq_print_pch_printspace,
(u64)&qq_print_pch_readln,
(u64)&qq_print_pch_sreadln,
(u64)&qq_print_pch_sread,
(u64)&qq_print_pch_rereadln,
(u64)&qq_print_pch_reread,
(u64)&qq_print_pch_strtoval,
(u64)&qq_print_pch_tostr,
(u64)&qq_host_pch_leftstr,
(u64)&qq_host_pch_rightstr,
(u64)&qq_host_pch_convlc,
(u64)&qq_host_pch_convuc,
(u64)&qq_host_pch_waitkey,
(u64)&qq_host_pch_testkey,
(u64)&qq_host_pch_execwait,
(u64)&qq_host_pch_execcmd,
(u64)&qq_host_pch_system,
(u64)&qq_host_pch_makestr,
(u64)&qq_host_pch_makeref,
(u64)&qq_host_pch_new,
(u64)&qq_host_pch_getcmdparam,
(u64)&qq_host_pch_gethostname,
(u64)&qq_host_pch_getprogname,
(u64)&qq_host_pch_$setdebug,
(u64)&qq_host_pch_$test2,
(u64)&qq_host_pch_$test,
(u64)&qq_host_pch_$refcount,
(u64)&qq_host_pch_ticks,
(u64)&qq_host_pch_clock,
(u64)&qq_host_pch_sleep,
(u64)&qq_host_pch_random,
(u64)&qq_host_pch_gethash,
(u64)&qq_host_pch_getos,
(u64)&qq_host_pch_iswindows,
(u64)&qq_host_pch_setmesshandler,
(u64)&qq_host_pch_$getstdinout,
(u64)&qq_host_pch_$getparam,
(u64)&qq_host_pch_makeempty,
(u64)&qq_host_pch_$smallmemtotal,
(u64)&qq_host_pch_$id,
(u64)&qq_host_pch_copy,
(u64)&qq_host_pch_$nan,
(u64)&qq_host_pch_$infinity,
(u64)&qq_host_pch_$nprocs,
(u64)&qq_host_pch_$procname,
(u64)&qq_host_pch_$procref,
(u64)&qq_host_pch_allocexec,
(u64)&qq_host_pch_runnative,
(u64)&qq_host_pch_setlwb,
0}};

static struct $B53 qq_tables_d_binopset = {{
29,
30,
43,
44,
45,
46,
48,
47,
22,
23,
24,
25,
26,
27,
31,
32,
33,
34,
35,
36,
38,
41,
28,
56,
37,
19,
42}};

static struct $B54 qq_tables_binopset;
static struct $B55 qq_tables_d_unaryopset = {{
49,
50,
52,
51,
53,
54,
55}};

static struct $B54 qq_tables_unaryopset;
static struct $B2 qq_tables_d_addopset = {{
5910,
8223,
9761,
9253,
10771}};

static struct $B41 qq_tables_d_cmpopset = {{
11307,
11821,
12335}};

static struct $B55 qq_tables_d_mulopset = {{
24,
25,
26,
27,
34,
35,
28}};

static struct $B54 qq_tables_addopset;
static struct $B54 qq_tables_cmpopset;
static struct $B54 qq_tables_mulopset;
static struct $B54 qq_tables_exprendset;
static struct $B56 qq_tables_d_exprstarterset = {{
9,
11,
15,
19,
69,
60,
63,
64,
65,
66,
67,
70,
125,
13,
97,
122,
121,
126,
109,
120,
21,
130,
129,
72,
102,
103}};

static struct $B57 qq_tables_exprstarterset;
static struct $B58 qq_tables_ttname;
static struct $B58 qq_tables_ttnamedef;
static struct $B59 qq_tables_ttbasetype;
static struct $B59 qq_tables_tttarget;
static struct $B58 qq_tables_ttlower;
static struct $B58 qq_tables_ttlength;
static struct $B58 qq_tables_ttlowerexpr;
static struct $B58 qq_tables_ttlengthexpr;
static struct $B58 qq_tables_ttsize;
static struct $B60 qq_tables_ttbitwidth;
static struct $B58 qq_tables_ttfields;
static struct $B60 qq_tables_ttcaligned;
static struct $B58 qq_tables_ttowner;
static i64 qq_tables_ntypes;
static i64 qq_tables_firstusertype;
static i64 qq_tables_nuserxtypes;
static i64 qq_tables_userxtypebase;
static u64 qq_tables_userxmodelist;
static struct $B61 qq_tables_ttnamedefx;
static struct $B61 qq_tables_ttxmap;
static struct $B62 qq_tables_ttxmoduleno;
static struct $B52 qq_tables_hostlvset;
static struct $B63 qq_tables_cvnames = {{
(u64)"cv_lineno",
(u64)"cv_strlineno",
(u64)"cv_filename",
(u64)"cv_modulename",
(u64)"cv_function",
(u64)"cv_date",
(u64)"cv_time"}};

static struct $B8 qq_tables_loopnames = {{
(u64)"loop_redo",
(u64)"loop_next",
(u64)"loop_exit"}};

static struct $B36 qq_tables_mathsnames = {{
(u64)"mm_sqrt",
(u64)"mm_sqr",
(u64)"mm_sin",
(u64)"mm_cos",
(u64)"mm_tan",
(u64)"mm_asin",
(u64)"mm_acos",
(u64)"mm_atan",
(u64)"mm_sign",
(u64)"mm_log",
(u64)"mm_log10",
(u64)"mm_exp",
(u64)"mm_round",
(u64)"mm_floor",
(u64)"mm_ceil",
(u64)"mm_fract",
(u64)"mm_fmod",
(u64)"mm_atan2"}};

static struct $B12 qq_tables_condnames = {{
(u64)"eq",
(u64)"ne",
(u64)"lt",
(u64)"le",
(u64)"ge",
(u64)"gt"}};

static struct $B41 qq_tables_revconds = {{
1,
1284,
770}};

static u64 qq_show_labelmap;
static i64 qq_show_currlineno;
static u64 qq_show_currpclproc;
static struct $B3 qq_show_pclv;
static u64 qq_show_pcldest = (u64)&qq_show_pclv;

static struct $B64 qq_show_getprefix_str;
static struct $B65 qq_show_getlineinfok_str;
// Istatic skipped:qq_show.showmoduleinfo.tab

static struct $B23 qq_show_strmode_str;
static struct $B23 qq_show_istrmode_str;
static i64 qq_showpcl_currlineno;
static u64 qq_showpcl_currpclproc;
static struct $B24 qq_showpcl_writepclopnd_str;
static struct $B24 qq_showpcl_writepclopnd_str2;
static struct $B31 qq_vars_zeroobj;
static void msysc_$getcommands(i64 ncmd, u64 cmds, i64 cmdskipl) {
    u64 R1, R2; 
	asi64(R1) = ncmd;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_ncmdparams = asi64(R1);
	asu64(R1) = cmds;
	msysc_cmdparams = asu64(R1);
	return;
}

static void msysc_pushio() {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_niostack;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L4;
	R1 = tou64("Too many io levels\n");
	asi32(R1) = printf(asu64(R1));
	R1 = 53;
	exit(R1);
L4:
	R1 = (u64)&msysc_niostack;
	(*toi64p(R1)) += 1;
	asu64(R1) = msysc_outchan;
	R2 = (u64)&msysc_outchan_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = msysc_outdev;
	R2 = (u64)&msysc_outdev_stack;
	asi64(R3) = msysc_niostack;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = msysc_fmtstr;
	R2 = (u64)&msysc_fmtstr_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = msysc_needgap;
	R2 = (u64)&msysc_needgap_stack;
	asi64(R3) = msysc_niostack;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 0;
	msysc_fmtstr = asu64(R1);
	R1 = 0;
	msysc_outchan = asu64(R1);
	return;
}

static void msysc_m$print_startfile(u64 dev) {
    u64 R1; 
	msysc_pushio();
	asu64(R1) = dev;
	msysc_outchan = asu64(R1);
	asu64(R1) = dev;
	if (!asu64(R1)) goto L7;
	R1 = 2;
	msysc_outdev = asi64(R1);
	goto L6;
L7:
	R1 = 1;
	msysc_outdev = asi64(R1);
L6:
	msysc_resetprintbuffer();
	return;
}

static void msysc_m$print_startstr(u64 s) {
    u64 R1, R2, R3; 
	u64 p;
	msysc_pushio();
	asu64(R1) = s;
	R2 = (u64)&msysc_ptr_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&msysc_ptr_stack;
	asi64(R2) = msysc_niostack;
	R1 += (i64)R2*8-8;
	p = asu64(R1);
	asu64(R1) = p;
	msysc_outchan = asu64(R1);
	R1 = 3;
	msysc_outdev = asi64(R1);
	return;
}

static void msysc_m$print_startptr(u64 p) {
    u64 R1; 
	msysc_pushio();
	asu64(R1) = p;
	msysc_outchan = asu64(R1);
	R1 = 3;
	msysc_outdev = asi64(R1);
	return;
}

static void msysc_m$print_startcon() {
    u64 R1; 
	msysc_pushio();
	R1 = 1;
	msysc_outdev = asi64(R1);
	msysc_resetprintbuffer();
	return;
}

static void msysc_m$print_setfmt(u64 format) {
    u64 R1; 
	asu64(R1) = format;
	msysc_fmtstr = asu64(R1);
	return;
}

static void msysc_m$print_end() {
    u64 R1, R2; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 1;
	msysc_nextfmtchars(asi64(R1));
	asi64(R1) = msysc_niostack;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L14;
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L15;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L14;
L15:
	msysc_dumpprintbuffer();
L14:
	asi64(R1) = msysc_niostack;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L17;
	goto L12;
L17:
	R1 = (u64)&msysc_outchan_stack;
	asi64(R2) = msysc_niostack;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_outchan = asu64(R1);
	R1 = (u64)&msysc_outdev_stack;
	asi64(R2) = msysc_niostack;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	msysc_outdev = asi64(R1);
	R1 = (u64)&msysc_fmtstr_stack;
	asi64(R2) = msysc_niostack;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_fmtstr = asu64(R1);
	R1 = (u64)&msysc_needgap_stack;
	asi64(R2) = msysc_niostack;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	msysc_needgap = asi64(R1);
	R1 = (u64)&msysc_niostack;
	(*toi64p(R1)) -=1;
L12:
	return;
}

static void msysc_m$print_ptr(u64 a, u64 fmtstyle) {
    u64 R1, R2; 
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L20;
	R1 = tou64("z8H");
	fmtstyle = asu64(R1);
L20:
	asu64(R1) = fmtstyle;
	asu64(R2) = a;
	msysc_m$print_u64(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_ptr_nf(u64 a) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = a;
	msysc_m$print_ptr(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_i64(i64 a, u64 fmtstyle) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	struct $B65 s;
	struct $B3 fmt;
	i64 n;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L24;
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L26;
	R1 = 0;
	R2 = 10;
	R3 = (u64)&s;
	asi64(R4) = a;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
	goto L25;
L26:
	asi64(R1) = a;
	R2 = 0x8000000000000000;
	if (asi64(R1) != asi64(R2)) goto L27;
	(R1_B3) = msysc_defaultfmt;
	fmt = (R1_B3);
	goto L28;
	goto L25;
L27:
	R1 = 45;
	R2 = (u64)&s;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = 10;
	R3 = (u64)&s;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R4) = a;
	asi64(R4) = -asi64(R4);
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
L25:
	asi64(R1) = n;
	R2 = (u64)&s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L23;
L24:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = 14;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 86;
	if (asu64(R1) != asu64(R2)) goto L30;
	asi64(R1) = a;
	msysc_fmtparam = asi64(R1);
	R1 = 0;
	msysc_needgap = asi64(R1);
	goto L29;
L30:
// msysc.m$print_i64.dofmt:
L28:
	R1 = (u64)&fmt;
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
L29:
L23:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_i64_nf(i64 a) {
    u64 R1, R2; 
	R1 = 0;
	asi64(R2) = a;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	return;
}

static void msysc_m$print_bool(i64 a, u64 fmtstyle) {
    u64 R1, R2; 
	asi64(R1) = a;
	if (!asi64(R1)) goto L34;
	asu64(R1) = fmtstyle;
	R2 = tou64("True");
	msysc_m$print_str(asu64(R2), asu64(R1));
	goto L33;
L34:
	asu64(R1) = fmtstyle;
	R2 = tou64("False");
	msysc_m$print_str(asu64(R2), asu64(R1));
L33:
	return;
}

static void msysc_m$print_u64(u64 a, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B65 s;
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L37;
	asu64(R1) = a;
	R2 = tou64("%llu");
	R3 = (u64)&s;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&s;
	msysc_printstr(asu64(R1));
	goto L36;
L37:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asu64(R2) = a;
	msysc_tostr_u64(asu64(R2), asu64(R1));
L36:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_r64(r64 x, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B70 s;
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L40;
	asr64(R1) = x;
	R2 = tou64("%f");
	R3 = (u64)&s;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asr64(R1));
	R1 = (u64)&s;
	msysc_printstr(asu64(R1));
	goto L39;
L40:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asr64(R2) = x;
	msysc_tostr_r64(asr64(R2), asu64(R1));
L39:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_r32(r32 x, u64 fmtstyle) {
    u64 R1, R2; 
	asu64(R1) = fmtstyle;
	asr32(R2) = x;
    asr64(R2) = tor64(asr32(R2));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	return;
}

static void msysc_m$print_c8(i64 a, u64 fmtstyle) {
    u64 R1, R2, R3, R4; 
	struct $B31 s;
	struct $B3 fmt;
	i64 n;
	u8 charmode;
	R1 = 0;
	charmode = asu8(R1);
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	if (!asu64(R1)) goto L44;
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	charmode = asu8(R1);
L44:
	asu8(R1) = charmode;
	R1 = toi64(tou8(R1));
	R2 = 77;
	if (asi64(R1) != asi64(R2)) goto L46;
	R1 = (u64)&fmt;
	R2 = (u64)&s;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L45;
L46:
	asi64(R1) = a;
	R2 = (u64)&s;
	*toi64p(R2) = asi64(R1);
	R1 = 0;
	R2 = (u64)&s;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&s;
	asi64(R1) = msysc_getutfsize(asu64(R1));
	n = asi64(R1);
L45:
	asi64(R1) = n;
	R2 = (u64)&s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_str(u64 s, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L49;
	R1 = tou64("<null>");
	msysc_printstr(asu64(R1));
	goto L47;
L49:
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L51;
	asu64(R1) = s;
	msysc_printstr(asu64(R1));
	goto L50;
L51:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = s;
	msysc_tostr_str(asu64(R3), asi64(R2), asu64(R1));
L50:
	R1 = 1;
	msysc_needgap = asi64(R1);
L47:
	return;
}

static void msysc_m$print_strn(u64 s, i64 length, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L54;
	R1 = tou64("<null>");
	msysc_printstr(asu64(R1));
	goto L52;
L54:
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L56;
	asi64(R1) = length;
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L55;
L56:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asi64(R2) = length;
	asu64(R3) = s;
	msysc_tostr_str(asu64(R3), asi64(R2), asu64(R1));
L55:
	R1 = 1;
	msysc_needgap = asi64(R1);
L52:
	return;
}

static void msysc_m$print_str_nf(u64 s) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = s;
	msysc_m$print_str(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_strsl(struct $B3 s, u64 fmtstyle) {
    u64 R1; 
	R1 = tou64("PRTSL");
	mlib_abortprogram(asu64(R1));
	return;
}

static void msysc_m$print_newline() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 1;
	msysc_nextfmtchars(asi64(R1));
	R1 = tou64("\r\n");
	msysc_printstr(asu64(R1));
	return;
}

static void msysc_m$print_nogap() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_space() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = tou64(" ");
	msysc_printstr(asu64(R1));
	return;
}

static void msysc_printstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_printstr_n(u64 s, i64 n) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = n;
	asu64(R3) = s;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void msysc_printstrn_app(u64 s, i64 length, u64 f) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = length;
	if (!asi64(R1)) goto L66;
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L68;
	asu64(R1) = s;
	asi64(R2) = length;
	R3 = tou64("%.*s");
	asi32(R1) = printf(asu64(R3), asi64(R2), asu64(R1));
	goto L67;
L68:
	asu64(R1) = s;
	asi64(R2) = length;
	R3 = tou64("%.*s");
	asu64(R4) = f;
	asi32(R1) = fprintf(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
L67:
L66:
	return;
}

static void msysc_printchar(i64 ch) {
    u64 R1, R2, R3; 
	u32 str;
	asi64(R1) = ch;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_nextfmtchars(i64 lastx) {
    u64 R1, R2; 
	u8 c;
	u64 pstart;
	i64 n;
	asu64(R1) = msysc_fmtstr;
	if (asu64(R1)) goto L72;
	asi64(R1) = msysc_needgap;
	if (!asi64(R1)) goto L74;
	R1 = 32;
	msysc_printchar(asi64(R1));
L74:
	R1 = 0;
	msysc_needgap = asi64(R1);
	goto L70;
L72:
	asu64(R1) = msysc_fmtstr;
	pstart = asu64(R1);
	R1 = 0;
	n = asi64(R1);
L75:
	asu64(R1) = msysc_fmtstr;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 35;
	if (asu64(R1) == asu64(R2)) goto L78;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L79;
	R2 = 126;
	if (asu64(R1) == asu64(R2)) goto L80;
	goto L81;
L78:
	asi64(R1) = lastx;
	if (!asi64(R1)) goto L83;
	goto L84;
L83:
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	if (!asi64(R1)) goto L86;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
L86:
	goto L70;
	goto L77;
L79:
	asi64(R1) = n;
	if (!asi64(R1)) goto L88;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L87;
L88:
	asi64(R1) = lastx;
	if (asi64(R1)) goto L89;
	R1 = 1;
	R2 = tou64("|");
	msysc_printstr_n(asu64(R2), asi64(R1));
L89:
L87:
	goto L70;
	goto L77;
L80:
	asi64(R1) = n;
	if (!asi64(R1)) goto L91;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
	R1 = 0;
	n = asi64(R1);
L91:
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asu64(R1) = msysc_fmtstr;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	if (!asu8(R1)) goto L93;
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	msysc_printchar(asi64(R1));
L93:
	asu64(R1) = msysc_fmtstr;
	pstart = asu64(R1);
	goto L77;
L81:
// msysc.nextfmtchars.skip:
L84:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
L77:
	goto L75;
L70:
	return;
}

static void msysc_strtofmt(u64 s, i64 slen, u64 fmt) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	i64 c;
	i64 base;
	u8 wset;
	i64 n;
	struct $B5 str;
	(R1_B3) = msysc_defaultfmt;
	asu64(R2) = fmt;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L96;
	goto L94;
L96:
	asi64(R1) = slen;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L98;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	slen = asi64(R1);
L98:
	asi64(R1) = slen;
	asu64(R2) = s;
	R3 = (u64)&str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = slen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	s = asu64(R1);
	R1 = 0;
	wset = asu8(R1);
	goto L100;
L99:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) != asi64(R2)) goto L103;
	R1 = 65;
	asu64(R2) = fmt;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L102;
L103:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) != asi64(R2)) goto L104;
	R1 = 97;
	asu64(R2) = fmt;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L102;
L104:
	asi64(R1) = c;
	asi32(R1) = toupper(asi32(R1));
	R1 = toi64(toi32(R1));
	switch (asi64(R1)) {
	case 66: goto L108;
	case 67: goto L137;
	case 68: goto L136;
	case 69: goto L133;
	case 70: goto L134;
	case 71: goto L135;
	case 72: goto L109;
	case 73: case 75: case 76: case 82: case 87: goto L107;
	case 74: goto L119;
	case 77: goto L138;
	case 78: goto L141;
	case 79: goto L110;
	case 80: goto L126;
	case 81: goto L118;
	case 83: goto L123;
	case 84: goto L129;
	case 85: goto L132;
	case 86: goto L139;
	case 88: goto L111;
	case 89: goto L140;
	case 90: goto L122;
	default: goto L107;
    };
// SWITCH
L108:
	R1 = 2;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L109:
	R1 = 16;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L110:
	R1 = 8;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L111:
	R1 = 0;
	base = asi64(R1);
L112:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L115;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L115;
	asi64(R1) = base;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	base = asi64(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L114;
L115:
	goto L113;
L114:
	goto L112;
L113:
	asi64(R1) = base;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L117;
	R2 = 16;
	if (asi64(R1) > asi64(R2)) goto L117;
	asi64(R1) = base;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L117:
	goto L105;
L118:
	R1 = 34;
	asu64(R2) = fmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L119:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = fmt;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L121;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L121:
	goto L105;
L122:
	R1 = 48;
	asu64(R2) = fmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L123:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L125;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L125:
	goto L105;
L126:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L128;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L128:
	goto L105;
L129:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L131;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L131:
	goto L105;
L132:
	R1 = 87;
	asu64(R2) = fmt;
	R3 = 11;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L133:
	R1 = 101;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L134:
	R1 = 102;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L135:
	R1 = 103;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L136:
	R1 = 68;
	asu64(R2) = fmt;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L137:
	R1 = 67;
	asu64(R2) = fmt;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L138:
	R1 = 77;
	asu64(R2) = fmt;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L139:
	R1 = 86;
	asu64(R2) = fmt;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L140:
	R1 = 1;
	asu64(R2) = fmt;
	R3 = 15;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L105;
L141:
	R1 = 1;
	asu64(R2) = fmt;
	R3 = 15;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L105;
L107:
	asi64(R1) = c;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L143;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L144;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L144;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L145;
	R2 = 126;
	if (asi64(R1) == asi64(R2)) goto L146;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L147;
	goto L148;
L143:
	R1 = 1;
	wset = asu8(R1);
	goto L142;
L144:
	asi64(R1) = c;
	asu64(R2) = fmt;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L145:
	R1 = 43;
	asu64(R2) = fmt;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L146:
	R1 = 126;
	asu64(R2) = fmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L147:
	asi64(R1) = msysc_fmtparam;
	n = asi64(R1);
	goto L149;
	goto L142;
L148:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L151;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L151;
	asi64(R1) = c;
	R2 = 48;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
L152:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L155;
	goto L153;
L155:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L157;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L157;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	goto L156;
L157:
	goto L153;
L156:
	goto L152;
L153:
// msysc.strtofmt.gotwidth:
L149:
	asu8(R1) = wset;
	if (asu8(R1)) goto L159;
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	wset = asu8(R1);
	goto L158;
L159:
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 1;
	*toi8p(((i64)R2+(i64)R3)) = asi8(R1);
L158:
L151:
L142:
L105:
L102:
L100:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L99;
L94:
	return;
}

static i64 msysc_domultichar(u64 p, i64 n, u64 dest, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B71 str;
	u64 q;
	i64 nchars;
	i64 av_1;
	R1 = (u64)&str;
	q = asu64(R1);
	asi64(R1) = n;
	nchars = asi64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L163;
L161:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L165;
	goto L163;
L165:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&q;
	(*tou64p(R1)) += 1;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L161;
L163:
	R1 = 0;
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asi64(R2) = strlen(asu64(R2));
	asu64(R3) = dest;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L160;
L160:
	return asi64(R1);
}

static i64 msysc_expandstr(u64 s, u64 t, i64 n, u64 fmt) {
    u64 R1, R2, R3; 
	i64 i;
	i64 w;
	i64 m;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 av_4;
	i64 av_5;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	w = asi64(R1);
	asi64(R1) = w;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L169;
	asi64(R1) = w;
	asi64(R2) = n;
	if (asi64(R1) > asi64(R2)) goto L168;
L169:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = n;
	goto L166;
L168:
	asu64(R1) = fmt;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 76;
	if (asu64(R1) != asu64(R2)) goto L171;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L174;
L172:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	i += 1; if (i <= av_1) goto L172;
L174:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	goto L170;
L171:
	asu64(R1) = fmt;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 82;
	if (asu64(R1) != asu64(R2)) goto L175;
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) != asu64(R2)) goto L177;
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L177;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L178;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) != asu64(R2)) goto L177;
L178:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L181;
L179:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_2)) goto L179;
L181:
	asi64(R1) = n;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	asu64(R2) = s;
	R3 = 1;
	R2 += (i64)R3;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	goto L176;
L177:
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L184;
L182:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_3)) goto L182;
L184:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L176:
	goto L170;
L175:
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 2;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	m = asi64(R1);
	asi64(R1) = m;
	av_4 = asi64(R1);
	asi64(R1) = av_4;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L187;
L185:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_4)) goto L185;
L187:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	asi64(R2) = m;
	asi64(R1) -= asi64(R2);
	av_5 = asi64(R1);
	asi64(R1) = av_5;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L190;
L188:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_5)) goto L188;
L190:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L170:
	asi64(R1) = w;
	goto L166;
L166:
	return asi64(R1);
}

static i64 msysc_u64tostr(u64 aa, u64 s, u64 base, i64 sep) {
    u64 R1, R2, R3; 
	struct $B70 t;
	u64 dd;
	i64 i;
	i64 j;
	i64 k;
	i64 g;
	u64 s0;
	R1 = 0;
	i = asi64(R1);
	R1 = 0;
	k = asi64(R1);
	asu64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L193;
	R1 = 3;
	goto L192;
L193:
	R1 = 4;
L192:
	g = asi64(R1);
L194:
	asu64(R1) = aa;
	asu64(R2) = base;
	asu64(R1) %= asu64(R2);
	dd = asu64(R1);
	asu64(R1) = aa;
	asu64(R2) = base;
   if (asu64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asu64(R1) /= asu64(R2);
	aa = asu64(R1);
	R1 = (u64)&msysc_digits;
	asu64(R2) = dd;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&t;
	R3 = (u64)&i;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&k;
	(*toi64p(R1)) += 1;
	asi64(R1) = sep;
	if (!asi64(R1)) goto L198;
	asu64(R1) = aa;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L198;
	asi64(R1) = k;
	asi64(R2) = g;
	if (asi64(R1) != asi64(R2)) goto L198;
	asi64(R1) = sep;
	R2 = (u64)&t;
	R3 = (u64)&i;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
L198:
	asu64(R1) = aa;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L194;
	asi64(R1) = i;
	j = asi64(R1);
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L200;
L199:
	R1 = (u64)&t;
	R2 = (u64)&i;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L200:
	asi64(R1) = i;
	if (asi64(R1)) goto L199;
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = j;
	goto L191;
L191:
	return asi64(R1);
}

static i64 msysc_i64tostrfmt(i64 aa, u64 s, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B70 str;
	i64 n;
	i64 usigned;
	R1 = 0;
	usigned = asi64(R1);
	asu64(R1) = fmt;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L204;
	R1 = 1;
	usigned = asi64(R1);
L204:
	asi64(R1) = aa;
	R2 = 0x8000000000000000;
	if (asi64(R1) != asi64(R2)) goto L206;
	asi64(R1) = usigned;
	if (asi64(R1)) goto L206;
	R1 = 45;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = (u64)&str;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R1) = msysc_i64mintostr(asu64(R3), asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	goto L205;
L206:
	asi64(R1) = usigned;
	if (asi64(R1)) goto L210;
	asi64(R1) = aa;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L209;
L210:
	asu64(R1) = fmt;
	R2 = 6;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L208;
L209:
	asi64(R1) = aa;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L212;
	asi64(R1) = aa;
	asi64(R1) = -asi64(R1);
	aa = asi64(R1);
	R1 = 45;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L211;
L212:
	R1 = 43;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L211:
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	goto L207;
L208:
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
L207:
L205:
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L214;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L214:
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L217;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L216;
L217:
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) != asu64(R2)) goto L216;
	R1 = (u64)&str;
	asu64(R1) = mlib_convlcstring(asu64(R1));
L216:
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = s;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L202;
L202:
	return asi64(R1);
}

static i64 msysc_u64tostrfmt(i64 aa, u64 s, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B70 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L220;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L220:
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L223;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L222;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) != asu64(R2)) goto L222;
L223:
L222:
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = s;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L218;
L218:
	return asi64(R1);
}

static i64 msysc_i64mintostr(u64 s, i64 base, i64 sep) {
    u64 R1, R2, R3; 
	struct $B70 t;
	i64 i;
	i64 j;
	i64 k;
	i64 g;
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L226;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L227;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L228;
	goto L229;
L226:
	R1 = tou64("9223372036854775808");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 3;
	j = asi64(R1);
	goto L225;
L227:
	R1 = tou64("8000000000000000");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 1;
	j = asi64(R1);
	goto L225;
L228:
	R1 = tou64("1000000000000000000000000000000000000000000000000000000000000000");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 7;
	j = asi64(R1);
	goto L225;
L229:
	R1 = tou64("<mindint>");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L225:
	R1 = (u64)&t;
	R2 = 0;
	R1 += (i64)R2;
	asi64(R1) = strlen(asu64(R1));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = sep;
	if (!asi64(R1)) goto L231;
	asi64(R1) = j;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
L231:
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L233;
	R1 = 3;
	goto L232;
L233:
	R1 = 4;
L232:
	g = asi64(R1);
	goto L235;
L234:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	R1 = (u64)&t;
	R2 = (u64)&i;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = sep;
	if (!asi64(R1)) goto L238;
	asi64(R1) = i;
	if (!asi64(R1)) goto L238;
	R1 = (u64)&k;
	asi64(R1) = *(toi64p(R1)) += 1;
	asi64(R2) = g;
	if (asi64(R1) != asi64(R2)) goto L238;
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	asi64(R1) = sep;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
L238:
L235:
	asi64(R1) = i;
	if (asi64(R1)) goto L234;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	goto L224;
L224:
	return asi64(R1);
}

static i64 msysc_strtostrfmt(u64 s, u64 t, i64 n, u64 fmt) {
    u64 R1, R2, R3, R4; 
	u64 u;
	u64 v;
	struct $B16 str;
	i64 w;
	i64 nheap;
	R1 = 0;
	nheap = asi64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L242;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L241;
L242:
	asi64(R1) = n;
	R2 = 256;
	if (asi64(R1) >= asi64(R2)) goto L244;
	R1 = (u64)&str;
	u = asu64(R1);
	goto L243;
L244:
	asi64(R1) = n;
	R2 = 3;
	asi64(R1) += asi64(R2);
	nheap = asi64(R1);
	asi64(R1) = nheap;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	u = asu64(R1);
L243:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L246;
	asu64(R1) = u;
	v = asu64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&v;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	if (!asi64(R1)) goto L248;
	asu64(R1) = s;
	asu64(R2) = v;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&v;
	*tou64p(R2) += asu64(R1);
L248:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&v;
	(*tou64p(R1)) += 1;
	R1 = 0;
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = 2;
	R2 = (u64)&n;
	*toi64p(R2) += asi64(R1);
	goto L245;
L246:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = u;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L245:
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) == asu64(R2)) goto L250;
	R2 = 65;
	if (asu64(R1) == asu64(R2)) goto L251;
	goto L252;
L250:
	asu64(R1) = u;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	goto L249;
L251:
	asu64(R1) = u;
	asu64(R1) = mlib_convucstring(asu64(R1));
	goto L249;
L252:
L249:
	asu64(R1) = u;
	s = asu64(R1);
L241:
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	w = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	if (asi64(R1) <= asi64(R2)) goto L254;
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = t;
	asu64(R4) = s;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	goto L253;
L254:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L253:
	asi64(R1) = nheap;
	if (!asi64(R1)) goto L256;
	asi64(R1) = nheap;
	asu64(R2) = u;
	mlib_pcm_free(asu64(R2), asi64(R1));
L256:
	asi64(R1) = n;
	goto L239;
L239:
	return asi64(R1);
}

static void msysc_tostr_i64(i64 a, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B70 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L259;
	R2 = 77;
	if (asu64(R1) == asu64(R2)) goto L260;
	goto L261;
L259:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asi64(R3) = a;
	asi64(R1) = msysc_i64tostrfmt(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L258;
L260:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L258;
L261:
	R1 = 0;
	asi64(R2) = a;
	msysc_m$print_c8(asi64(R2), asu64(R1));
	goto L257;
L258:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
L257:
	return;
}

static void msysc_tostr_u64(u64 a, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B70 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 77;
	if (asu64(R1) == asu64(R2)) goto L264;
	R2 = 67;
	if (asu64(R1) == asu64(R2)) goto L265;
	goto L266;
L264:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L263;
L265:
	R1 = 0;
	asu64(R2) = a;
	msysc_m$print_c8(asi64(R2), asu64(R1));
	goto L262;
	goto L263;
L266:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asu64(R3) = a;
	asi64(R1) = msysc_u64tostrfmt(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
L263:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
L262:
	return;
}

static void msysc_tostr_r64(r64 x, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B70 str;
	struct $B70 str2;
	struct $B2 cfmt;
	i64 n;
	R1 = 37;
	R2 = (u64)&cfmt;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L269;
	R1 = 46;
	R2 = (u64)&cfmt;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 42;
	R2 = (u64)&cfmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cfmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cfmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	asu64(R2) = fmt;
	R3 = 1;
	asi8(R2) = *toi8p(((i64)R2+(i64)R3));
	R2 = toi64(toi8(R2));
	R3 = (u64)&cfmt;
	R4 = (u64)&str;
	asi32(R1) = sprintf(asu64(R4), asu64(R3), asi64(R2), asr64(R1));
	goto L268;
L269:
	asu64(R1) = fmt;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cfmt;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cfmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	R2 = (u64)&cfmt;
	R3 = (u64)&str;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asr64(R1));
L268:
	R1 = (u64)&str;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) >= asi64(R2)) goto L271;
	asu64(R1) = fmt;
	asi64(R2) = n;
	R3 = (u64)&str2;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	R1 = (u64)&str2;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L271:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_tostr_str(u64 s, i64 oldlen, u64 fmt) {
    u64 R1, R2, R3, R4; 
	i64 newlen;
	i64 n;
	u64 t;
	asi64(R1) = oldlen;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L274;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	oldlen = asi64(R1);
L274:
	asi64(R1) = oldlen;
	newlen = asi64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L277;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = newlen;
	if (asi64(R1) > asi64(R2)) goto L277;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L277;
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L276;
L277:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L279;
	R1 = 2;
	R2 = (u64)&newlen;
	*toi64p(R2) += asi64(R1);
L279:
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = newlen;
	if (asi64(R1) <= asi64(R2)) goto L281;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	newlen = asi64(R1);
L281:
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	t = asu64(R1);
	asu64(R1) = fmt;
	asi64(R2) = oldlen;
	asu64(R3) = t;
	asu64(R4) = s;
	asi64(R1) = msysc_strtostrfmt(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L283;
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	R1 = toi64(toi8(R1));
	R2 = (u64)&n;
    *toi64p(R2) = Min(*toi64p(R2), asi64(R1));
L283:
	asi64(R1) = n;
	asu64(R2) = t;
	msysc_printstr_n(asu64(R2), asi64(R1));
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = t;
	mlib_pcm_free(asu64(R2), asi64(R1));
	goto L275;
L276:
	asi64(R1) = oldlen;
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
L275:
	return;
}

static u64 msysc_getfmt(u64 fmtstyle) {
    u64 R1, R2, R3; 
	asu64(R1) = fmtstyle;
	if (!asu64(R1)) goto L286;
	R1 = (u64)&msysc_getfmt_fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&msysc_getfmt_fmt;
	goto L285;
L286:
	R1 = (u64)&msysc_defaultfmt;
L285:
	goto L284;
L284:
	return asu64(R1);
}

static u64 msysc_strint(i64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strint_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strint_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L287;
L287:
	return asu64(R1);
}

static void msysc_getstrint(i64 a, u64 dest) {
    u64 R1, R2; 
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = 0;
	asu64(R1) = msysc_getfmt(asu64(R1));
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	return;
}

static u64 msysc_strword(u64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strword_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asu64(R2) = a;
	msysc_tostr_u64(asu64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strword_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L289;
L289:
	return asu64(R1);
}

static u64 msysc_strreal(r64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strreal_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asr64(R2) = a;
	msysc_tostr_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strreal_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L290;
L290:
	return asu64(R1);
}

static u64 msysc_getstr(u64 s, u64 fmt) {
    u64 R1, R2; 
	asu64(R1) = fmt;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L293;
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	goto L292;
L293:
	asu64(R1) = s;
L292:
	goto L291;
L291:
	return asu64(R1);
}

static void msysc_initreadbuffer() {
    u64 R1, R2; 
	asu64(R1) = msysc_rd_buffer;
	if (!asu64(R1)) goto L296;
	goto L294;
L296:
	R1 = 16384;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	msysc_rd_buffer = asu64(R1);
	R1 = 0;
	asu64(R2) = msysc_rd_buffer;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = msysc_rd_buffer;
	R2 = R1;
	msysc_rd_lastpos = asu64(R2);
	msysc_rd_pos = asu64(R1);
L294:
	return;
}

static void msysc_m$read_conline() {
    u64 R1, R2, R3; 
	msysc_initreadbuffer();
	R1 = 16384;
	asu64(R2) = msysc_rd_buffer;
	R3 = 0;
	mlib_readlinen(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = msysc_rd_buffer;
	asi64(R1) = strlen(asu64(R1));
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static void msysc_m$read_fileline(u64 f) {
    u64 R1, R2, R3; 
	msysc_initreadbuffer();
	asu64(R1) = f;
	R2 = 1;
	if (asu64(R1) != asu64(R2)) goto L300;
	R1 = tou64("READ CMDLINE");
	mlib_abortprogram(asu64(R1));
	goto L298;
L300:
	R1 = 16384;
	asu64(R2) = msysc_rd_buffer;
	asu64(R3) = f;
	mlib_readlinen(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = msysc_rd_buffer;
	asi64(R1) = strlen(asu64(R1));
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
L298:
	return;
}

static void msysc_m$read_strline(u64 s) {
    u64 R1, R2, R3; 
	i64 n;
	msysc_initreadbuffer();
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 16384;
	if (asi64(R1) >= asi64(R2)) goto L303;
	asu64(R1) = s;
	asu64(R2) = msysc_rd_buffer;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L302;
L303:
	R1 = 16383;
	asu64(R2) = s;
	asu64(R3) = msysc_rd_buffer;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = msysc_rd_buffer;
	R3 = 16384;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
L302:
	asi64(R1) = n;
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static u64 msysc_readitem(u64 itemlength) {
    u64 R1, R2; 
	u64 p;
	u64 s;
	u64 itemstr;
	u8 quotechar;
	u8 c;
	asu64(R1) = msysc_rd_buffer;
	if (asu64(R1)) goto L306;
	msysc_initreadbuffer();
L306:
	asu64(R1) = msysc_rd_pos;
	s = asu64(R1);
	goto L308;
L307:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L308:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L307;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L307;
	asu64(R1) = s;
	itemstr = asu64(R1);
	asu64(R1) = s;
	R2 = R1;
	msysc_rd_pos = asu64(R2);
	msysc_rd_lastpos = asu64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L311;
	R1 = 0;
	msysc_termchar = asi64(R1);
	R1 = 0;
	asu64(R2) = itemlength;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = s;
	goto L304;
L311:
	R1 = 0;
	quotechar = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) != asu64(R2)) goto L313;
	R1 = 34;
	quotechar = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L312;
L313:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 39;
	if (asu64(R1) != asu64(R2)) goto L314;
	R1 = 39;
	quotechar = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L314:
L312:
	asu64(R1) = s;
	R2 = R1;
	itemstr = asu64(R2);
	p = asu64(R1);
	goto L316;
L315:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L319;
	goto L320;
L319:
	asu8(R1) = quotechar;
	if (asu8(R1)) goto L323;
	asu64(R1) = p;
	asu64(R2) = s;
	if (asu64(R1) != asu64(R2)) goto L322;
L323:
	goto L324;
L322:
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
	goto L317;
	goto L318;
L320:
// msysc.readitem.normalchar:
L324:
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	asu8(R2) = quotechar;
	R2 = tou64(tou8(R2));
	if (asu64(R1) != asu64(R2)) goto L326;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asu8(R2) = quotechar;
	R2 = tou64(tou8(R2));
	if (asu64(R1) != asu64(R2)) goto L328;
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L327;
L328:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
	asi64(R1) = msysc_termchar;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L331;
	R2 = 61;
	if (asi64(R1) != asi64(R2)) goto L330;
L331:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
L330:
	goto L317;
L327:
	goto L325;
L326:
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L325:
L318:
L316:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L315;
L317:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L333;
	R1 = 0;
	msysc_termchar = asi64(R1);
L333:
	asu64(R1) = p;
	asu64(R2) = itemstr;
	asi64(R1) -= asi64(R2);
	asu64(R2) = itemlength;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = itemstr;
	goto L304;
L304:
	return asu64(R1);
}

static i64 msysc_strtoint(u64 s, i64 length, u64 base) {
    u64 R1, R2; 
	u8 signd;
	u64 aa;
	u64 c;
	u64 d;
	R1 = 0;
	msysc_itemerror = asi64(R1);
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L336;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L336:
	R1 = 0;
	signd = asu8(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L338;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) != asu64(R2)) goto L338;
	R1 = 1;
	signd = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	goto L337;
L338:
	asi64(R1) = length;
	if (!asi64(R1)) goto L339;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) != asu64(R2)) goto L339;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
L339:
L337:
	R1 = 0;
	aa = asu64(R1);
	goto L341;
L340:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	c = asu64(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	asu64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L344;
	R2 = 70;
	if (asi64(R1) > asi64(R2)) goto L344;
	asu64(R1) = c;
	R2 = 65;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	d = asu64(R1);
	goto L343;
L344:
	asu64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L345;
	R2 = 102;
	if (asi64(R1) > asi64(R2)) goto L345;
	asu64(R1) = c;
	R2 = 97;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	d = asu64(R1);
	goto L343;
L345:
	asu64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L346;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L346;
	asu64(R1) = c;
	R2 = 48;
	asu64(R1) -= asu64(R2);
	d = asu64(R1);
	goto L343;
L346:
	asu64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L348;
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L347;
L348:
	goto L341;
	goto L343;
L347:
	R1 = 1;
	msysc_itemerror = asi64(R1);
	goto L342;
L343:
	asu64(R1) = d;
	asu64(R2) = base;
	if (asu64(R1) < asu64(R2)) goto L350;
	R1 = 1;
	msysc_itemerror = asi64(R1);
	goto L342;
L350:
	asu64(R1) = aa;
	asu64(R2) = base;
	asu64(R1) *= asu64(R2);
	asu64(R2) = d;
	asu64(R1) += asu64(R2);
	aa = asu64(R1);
L341:
	asi64(R1) = length;
	if (asi64(R1)) goto L340;
L342:
	asu8(R1) = signd;
	if (!asu8(R1)) goto L352;
	asu64(R1) = aa;
	asu64(R1) = -asu64(R1);
	goto L351;
L352:
	asu64(R1) = aa;
L351:
	goto L334;
L334:
	return asi64(R1);
}

static i64 msysc_m$read_i64(i64 fmt) {
    u64 R1, R2, R3; 
	u64 s;
	i64 length;
	asi64(R1) = fmt;
	asi32(R1) = toupper(asi32(R1));
	R1 = toi64(toi32(R1));
	fmt = asi64(R1);
	asi64(R1) = fmt;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L355;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L356;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L357;
	goto L358;
L355:
	asu64(R1) = msysc_rd_pos;
	msysc_rd_lastpos = asu64(R1);
	asu64(R1) = msysc_rd_pos;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L360;
	R1 = (u64)&msysc_rd_pos;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	goto L353;
	goto L359;
L360:
	R1 = 0;
	goto L353;
L359:
	goto L354;
L356:
	asi64(R1) = msysc_termchar;
	goto L353;
	goto L354;
L357:
	asi64(R1) = msysc_itemerror;
	goto L353;
	goto L354;
L358:
L354:
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = fmt;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L362;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L362;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L363;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L364;
	goto L365;
L362:
	R1 = 10;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L363:
	R1 = 2;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L364:
	R1 = 16;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L365:
L361:
	R1 = 0;
	goto L353;
L353:
	return asi64(R1);
}

static r64 msysc_m$read_r64(i64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B24 str;
	u64 s;
	i64 length;
	i32 numlength;
	r64 x;
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L369;
	asi64(R1) = length;
	R2 = 512;
	if (asi64(R1) < asi64(R2)) goto L368;
L369:
	asr64(R1) = 0.000000000000000000e+000;
	goto L366;
L368:
	asi64(R1) = length;
	asu64(R2) = s;
	R3 = (u64)&str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	msysc_itemerror = asi64(R1);
	R1 = (u64)&numlength;
	R2 = (u64)&x;
	R3 = tou64("%lf%n");
	R4 = (u64)&str;
	asi32(R1) = sscanf(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L372;
	asi32(R1) = numlength;
	R1 = toi64(toi32(R1));
	asi64(R2) = length;
	if (asi64(R1) == asi64(R2)) goto L371;
L372:
	asr64(R1) = 0.000000000000000000e+000;
	x = asr64(R1);
	R1 = 1;
	msysc_itemerror = asi64(R1);
L371:
	asr64(R1) = x;
	goto L366;
L366:
	return asr64(R1);
}

static void msysc_m$read_str(u64 dest, i64 destlen, i64 fmt) {
    u64 R1, R2, R3; 
	u64 s;
	i64 length;
	R1 = 0;
	msysc_itemerror = asi64(R1);
	asi64(R1) = fmt;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L376;
	R2 = 108;
	if (asi64(R1) != asi64(R2)) goto L375;
L376:
	asu64(R1) = msysc_rd_pos;
	s = asu64(R1);
	asu64(R1) = msysc_rd_buffer;
	asi64(R2) = msysc_rd_length;
	R1 += (i64)R2;
	asu64(R2) = msysc_rd_pos;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	goto L374;
L375:
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = fmt;
	R2 = 78;
	if (asi64(R1) == asi64(R2)) goto L379;
	R2 = 110;
	if (asi64(R1) != asi64(R2)) goto L378;
L379:
	asi64(R1) = length;
	asu64(R2) = s;
	mlib_iconvlcn(asu64(R2), asi64(R1));
L378:
L374:
	asi64(R1) = destlen;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L381;
	asi64(R1) = length;
	asi64(R2) = destlen;
	if (asi64(R1) < asi64(R2)) goto L383;
	asi64(R1) = destlen;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	R1 = 1;
	msysc_itemerror = asi64(R1);
L383:
L381:
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = dest;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void msysc_readstr(u64 dest, i64 fmt, i64 destlen) {
    u64 R1, R2, R3; 
	asi64(R1) = fmt;
	asi64(R2) = destlen;
	asu64(R3) = dest;
	msysc_m$read_str(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void msysc_rereadln() {
    u64 R1; 
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = msysc_rd_pos;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static void msysc_reread() {
    u64 R1; 
	asu64(R1) = msysc_rd_lastpos;
	msysc_rd_pos = asu64(R1);
	return;
}

static i64 msysc_valint(u64 s, i64 fmt) {
    u64 R1; 
	u64 old_pos;
	u64 old_lastpos;
	i64 aa;
	msysc_initreadbuffer();
	asu64(R1) = msysc_rd_pos;
	old_pos = asu64(R1);
	asu64(R1) = msysc_rd_lastpos;
	old_lastpos = asu64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	asi64(R1) = fmt;
	asi64(R1) = msysc_m$read_i64(asi64(R1));
	aa = asi64(R1);
	asu64(R1) = old_pos;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = old_lastpos;
	msysc_rd_lastpos = asu64(R1);
	asi64(R1) = aa;
	goto L387;
L387:
	return asi64(R1);
}

static r64 msysc_valreal(u64 s) {
    u64 R1; 
	u64 old_pos;
	u64 old_lastpos;
	r64 x;
	msysc_initreadbuffer();
	asu64(R1) = msysc_rd_pos;
	old_pos = asu64(R1);
	asu64(R1) = msysc_rd_lastpos;
	old_lastpos = asu64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	asr64(R1) = msysc_m$read_r64(asi64(R1));
	x = asr64(R1);
	asu64(R1) = old_pos;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = old_lastpos;
	msysc_rd_lastpos = asu64(R1);
	asr64(R1) = x;
	goto L388;
L388:
	return asr64(R1);
}

static void msysc_mclunimpl(u64 mess) {
    u64 R1, R2; 
	asu64(R1) = mess;
	R2 = tou64("MCL-UNIMPL: %s\n");
	asi32(R1) = printf(asu64(R2), asu64(R1));
	R1 = 1;
	exit(R1);
	return;
}

static void msysc_dumpstr(u64 s, i64 n, i64 fbuffer) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asi64(R1) = msysc_outdev;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L392;
	asu64(R1) = msysc_outchan;
	p = asu64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L394;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = p;
	asu64(R3) = *tou64p(R3);
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	asu64(R2) = p;
	*tou64p(R2) += asu64(R1);
L394:
	R1 = 0;
	asu64(R2) = p;
	asu64(R2) = *tou64p(R2);
	*tou8p(R2) = asu8(R1);
	goto L390;
L392:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L396;
	goto L390;
L396:
	asi64(R1) = fbuffer;
	if (!asi64(R1)) goto L398;
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L398;
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L398;
	R1 = (u64)&msysc_printptr;
	(*tou64p(R1)) -=1;
	asu64(R1) = msysc_printptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L400;
	asu64(R1) = msysc_printptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L402;
	R1 = 0;
	asu64(R2) = msysc_printptr;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	goto L401;
L402:
	R1 = 0;
	asu64(R2) = msysc_printptr;
	*tou8p(R2) = asu8(R1);
L401:
	R1 = (u64)&msysc_printbuffer;
	asi32(R1) = puts(asu64(R1));
	goto L390;
L400:
L398:
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L404;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L405;
	goto L406;
L404:
	asu64(R1) = s;
	asi64(R2) = n;
	R3 = tou64("%.*s");
	asi32(R1) = printf(asu64(R3), asi64(R2), asu64(R1));
	goto L403;
L405:
	asu64(R1) = s;
	asi64(R2) = n;
	R3 = tou64("%.*s");
	asu64(R4) = msysc_outchan;
	asi32(R1) = fprintf(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L403;
L406:
L403:
L390:
	return;
}

static void msysc_dumpprintbuffer() {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_printlen;
	if (!asi64(R1)) goto L409;
	R1 = 1;
	asi64(R2) = msysc_printlen;
	R3 = (u64)&msysc_printbuffer;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
L409:
	msysc_resetprintbuffer();
	return;
}

static void msysc_resetprintbuffer() {
    u64 R1; 
	R1 = (u64)&msysc_printbuffer;
	msysc_printptr = asu64(R1);
	R1 = 0;
	msysc_printlen = asi64(R1);
	return;
}

static void msysc_addtobuffer(u64 s, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_printlen;
	asi64(R2) = n;
	asi64(R1) += asi64(R2);
	R2 = 4088;
	if (asi64(R1) < asi64(R2)) goto L413;
	msysc_dumpprintbuffer();
L413:
	asi64(R1) = n;
	R2 = 4096;
	if (asi64(R1) >= asi64(R2)) goto L415;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = msysc_printptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&msysc_printptr;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&msysc_printlen;
	*toi64p(R2) += asi64(R1);
	goto L411;
L415:
	R1 = 0;
	asi64(R2) = n;
	asu64(R3) = s;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
L411:
	return;
}

static i64 msysc_getutfsize(u64 s) {
    u64 R1, R2, R3; 
	i64 a;
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L418;
	R1 = 0;
	goto L417;
L418:
	asi64(R1) = a;
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L419;
	R1 = 1;
	goto L417;
L419:
	asi64(R1) = a;
	R2 = 5;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L420;
	R1 = 2;
	goto L417;
L420:
	asi64(R1) = a;
	R2 = 4;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L421;
	R1 = 3;
	goto L417;
L421:
	asi64(R1) = a;
	R2 = 3;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 30;
	if (asi64(R1) != asi64(R2)) goto L422;
	R1 = 4;
	goto L417;
L422:
	R1 = 1;
L417:
	goto L416;
L416:
	return asi64(R1);
}

static i64 msysc_m$sign_i64(i64 a) {
    u64 R1, R2; 
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L425;
	R1 = -1;
	goto L424;
L425:
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L427;
	R1 = 1;
	goto L426;
L427:
	R1 = 0;
L426:
L424:
	goto L423;
L423:
	return asi64(R1);
}

static r64 msysc_m$sign_r64(r64 x) {
    u64 R1, R2; 
	asr64(R1) = x;
	asr64(R2) = 0.000000000000000000e+000;
	if (asr64(R1) >= asr64(R2)) goto L430;
	asr64(R1) = -1.000000000000000000e+000;
	goto L428;
L430:
	asr64(R1) = x;
	asr64(R2) = 0.000000000000000000e+000;
	if (asr64(R1) <= asr64(R2)) goto L432;
	asr64(R1) = 1.000000000000000000e+000;
	goto L428;
L432:
	asr64(R1) = 0.000000000000000000e+000;
	goto L428;
L428:
	return asr64(R1);
}

static u64 mlib_pcm_alloc(i64 n) {
    u64 R1, R2, R3; 
	u64 p;
	asu8(R1) = mlib_pcm_setup;
	if (asu8(R1)) goto L435;
	mlib_pcm_init();
L435:
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L437;
	asi64(R1) = n;
	asi64(R1) = mlib_pcm_getac(asi64(R1));
	mlib_alloccode = asi64(R1);
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = mlib_alloccode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	mlib_allocbytes = asi64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R1) = mlib_allocmem(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L439;
	R1 = tou64("pcm_alloc failure");
	mlib_abortprogram(asu64(R1));
L439:
	asu64(R1) = p;
	goto L433;
L437:
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	mlib_alloccode = asi64(R1);
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = mlib_alloccode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	mlib_allocbytes = asi64(R1);
	R1 = (u64)&mlib_freelist;
	asi64(R2) = mlib_alloccode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	p = asu64(R2);
	if (!asu64(R1)) goto L441;
	R1 = (u64)&mlib_freelist;
	asi64(R2) = mlib_alloccode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_freelist;
	asi64(R3) = mlib_alloccode;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = p;
	goto L433;
L441:
	asu64(R1) = mlib_pcheapptr;
	p = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = mlib_pcheapptr;
	asu64(R2) = mlib_pcheapend;
	if (asu64(R1) < asu64(R2)) goto L443;
	asi64(R1) = mlib_allocbytes;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L433;
L443:
	asu64(R1) = p;
	goto L433;
L433:
	return asu64(R1);
}

static void mlib_pcm_free(u64 p, i64 n) {
    u64 R1, R2, R3; 
	i64 acode;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L447;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L446;
L447:
	goto L444;
L446:
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L449;
	asu64(R1) = p;
	free(asu64(R1));
	goto L448;
L449:
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	acode = asi64(R1);
	R1 = (u64)&mlib_freelist;
	asi64(R2) = acode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&mlib_freelist;
	asi64(R3) = acode;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
L448:
L444:
	return;
}

static void mlib_pcm_freeac(u64 p, i64 alloc) {
    u64 R1, R2; 
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = alloc;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static void mlib_pcm_clearmem(u64 p, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	return;
}

static void mlib_pcm_init() {
    u64 R1, R2, R3; 
	i64 j;
	i64 k;
	i64 size;
	i64 av_1;
	i64 i;
	R1 = 0;
	mlib_alloccode = asi64(R1);
	asu8(R1) = mlib_pcm_setup;
	if (!asu8(R1)) goto L454;
	goto L452;
L454:
	R1 = 0;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	R1 = 1;
	i = asi64(R1);
L455:
	R1 = 1;
	j = asi64(R1);
	R1 = 16;
	k = asi64(R1);
	goto L459;
L458:
	asi64(R1) = k;
	R2 = 1;
	asi64(R1) <<= asi64(R2);
	k = asi64(R1);
	R1 = (u64)&j;
	(*toi64p(R1)) += 1;
L459:
	asi64(R1) = i;
	asi64(R2) = k;
	if (asi64(R1) > asi64(R2)) goto L458;
	asi64(R1) = j;
	R2 = (u64)&mlib_sizeindextable;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= 2048) goto L455;
	R1 = 16;
	R2 = (u64)&mlib_allocupper;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 16;
	size = asi64(R1);
	R1 = 2;
	i = asi64(R1);
L461:
	R1 = 2;
	R2 = (u64)&size;
	*toi64p(R2) *= asi64(R1);
	asi64(R1) = size;
	R2 = (u64)&mlib_allocupper;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = size;
	R2 = 33554432;
	if (asi64(R1) < asi64(R2)) goto L465;
	asi64(R1) = i;
	k = asi64(R1);
	goto L463;
L465:
	i += 1; if (i <= 27) goto L461;
L463:
	asi64(R1) = k;
	R2 = 1;
	asi64(R1) += asi64(R2);
	i = asi64(R1);
	R1 = 300;
	av_1 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_1;
	if (asi64(R1) > asi64(R2)) goto L468;
L466:
	R1 = 33554432;
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = size;
	R2 = 8589934592;
	if (asi64(R1) >= asi64(R2)) goto L470;
	asi64(R1) = size;
	R2 = (u64)&mlib_allocupper;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = size;
	mlib_maxmemory = asu64(R1);
	goto L469;
L470:
	asi64(R1) = i;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	mlib_maxalloccode = asi64(R1);
	goto L468;
L469:
	i += 1; if (i <= av_1) goto L466;
L468:
	R1 = 1;
	mlib_pcm_setup = asu8(R1);
L452:
	return;
}

static i64 mlib_pcm_getac(i64 size) {
    u64 R1, R2; 
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L473;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	goto L471;
L473:
	asi64(R1) = size;
	R2 = 255;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) >>= asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L475;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	asi64(R1) += asi64(R2);
	goto L471;
L475:
	asi64(R1) = size;
	R2 = 63;
	asi64(R1) += asi64(R2);
	R2 = 6;
	asi64(R1) >>= asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L477;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	asi64(R1) += asi64(R2);
	goto L471;
L477:
	asi64(R1) = size;
	R2 = 2048;
	asi64(R1) -= asi64(R2);
	R2 = 2047;
	asi64(R1) += asi64(R2);
	R2 = 2048;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 22;
	asi64(R1) += asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	goto L471;
L471:
	return asi64(R1);
}

static u64 mlib_pcm_newblock(i64 itemsize) {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 2097152;
	R2 = (u64)&mlib_pcm_newblock_totalheapsize;
	*toi64p(R2) += asi64(R1);
	R1 = 0;
	mlib_alloccode = asi64(R1);
	R1 = 2097152;
	asu64(R1) = mlib_allocmem(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L480;
	R1 = tou64("Can't alloc pc heap");
	mlib_abortprogram(asu64(R1));
L480:
	R1 = 2097152;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asu64(R1) = p;
	mlib_pcheapptr = asu64(R1);
	asu64(R1) = p;
	R2 = 2097152;
	R1 += (i64)R2;
	mlib_pcheapend = asu64(R1);
	asu64(R1) = mlib_pcheapstart;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L482;
	asu64(R1) = p;
	mlib_pcheapstart = asu64(R1);
L482:
	asi64(R1) = itemsize;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = p;
	goto L478;
L478:
	return asu64(R1);
}

static i64 mlib_pcm_round(i64 n) {
    u64 R1, R2, R3; 
// PROC LOCAL STATICS GO HERE
	static struct $B13 mlib_pcm_round_allocbytes = {{
0,
	16,
	32,
	64,
	128,
	256,
	512,
	1024,
	2048    }};
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L485;
	asi64(R1) = n;
	goto L484;
L485:
	R1 = (u64)&mlib_pcm_round_allocbytes;
	R2 = (u64)&mlib_sizeindextable;
	asi64(R3) = n;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
L484:
	goto L483;
L483:
	return asi64(R1);
}

static u64 mlib_pcm_allocz(i64 n) {
    u64 R1, R2, R3; 
	u64 p;
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asu64(R1) = p;
	goto L486;
L486:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapstring(u64 s) {
    u64 R1, R2, R3; 
	u64 q;
	i64 n;
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L489;
	R1 = 0;
	goto L487;
L489:
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = q;
	goto L487;
L487:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapstringn(u64 s, i64 n) {
    u64 R1, R2, R3; 
	u64 q;
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L492;
	R1 = 0;
	goto L490;
L492:
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = q;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	goto L490;
L490:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapblock(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 q;
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L495;
	R1 = 0;
	goto L493;
L495:
	asi64(R1) = length;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = q;
	goto L493;
L493:
	return asu64(R1);
}

static u64 mlib_allocmem(i64 n) {
    u64 R1; 
	u64 p;
	asi64(R1) = n;
	asu64(R1) = malloc(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L498;
	asu64(R1) = p;
	goto L496;
L498:
	msysc_m$print_startcon();
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = mlib_memtotal;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Alloc mem failure");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L496;
L496:
	return asu64(R1);
}

static u64 mlib_reallocmem(u64 p, i64 n) {
    u64 R1, R2; 
	asi64(R1) = n;
	asu64(R2) = p;
	asu64(R1) = realloc(asu64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L501;
	asu64(R1) = p;
	goto L499;
L501:
	msysc_m$print_startcon();
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Realloc mem failure");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L499;
L499:
	return asu64(R1);
}

static void mlib_abortprogram(u64 s) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = s;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("ABORTING: Press key...");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 5;
	exit(R1);
	return;
}

static i64 mlib_getfilesize(u64 handlex) {
    u64 R1, R2, R3; 
	u32 p;
	u32 size;
	asu64(R1) = handlex;
	asi32(R1) = ftell(asu64(R1));
	p = asu32(R1);
	R1 = 2;
	R2 = 0;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi32(R1) = ftell(asu64(R1));
	size = asu32(R1);
	R1 = 0;
	asu32(R2) = p;
	R2 = toi64(tou32(R2));
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu32(R1) = size;
	R1 = toi64(tou32(R1));
	goto L503;
L503:
	return asi64(R1);
}

static void mlib_readrandom(u64 handlex, u64 memx, i64 offset, i64 size) {
    u64 R1, R2, R3, R4; 
	i64 a;
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 1;
	asu64(R4) = memx;
	asi64(R1) = fread(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	a = asi64(R1);
	return;
}

static i64 mlib_writerandom(u64 handlex, u64 memx, i64 offset, i64 size) {
    u64 R1, R2, R3, R4; 
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 1;
	asu64(R4) = memx;
	asi64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L505;
L505:
	return asi64(R1);
}

static i64 mlib_setfilepos(u64 file, i64 offset) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = file;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	R1 = toi64(toi32(R1));
	goto L506;
L506:
	return asi64(R1);
}

static i64 mlib_getfilepos(u64 file) {
    u64 R1; 
	asu64(R1) = file;
	asi32(R1) = ftell(asu64(R1));
	R1 = toi64(toi32(R1));
	goto L507;
L507:
	return asi64(R1);
}

static u64 mlib_readfile(u64 filename) {
    u64 R1, R2, R3, R4; 
	u64 f;
	i64 size;
	u64 m;
	u64 p;
	R1 = tou64("rb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L510;
	R1 = 0;
	goto L508;
L510:
	asu64(R1) = f;
	asi64(R1) = mlib_getfilesize(asu64(R1));
	R2 = R1;
	size = asi64(R2);
	mlib_rfsize = asi64(R1);
	asi64(R1) = size;
	R2 = 2;
	asu64(R1) += asu64(R2);
	asu64(R1) = malloc(asu64(R1));
	m = asu64(R1);
	asu64(R1) = m;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L512;
	R1 = 0;
	goto L508;
L512:
	asi64(R1) = size;
	R2 = 0;
	asu64(R3) = m;
	asu64(R4) = f;
	mlib_readrandom(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = m;
	asi64(R2) = size;
	R1 += (i64)R2;
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	*tou16p(R2) = asu16(R1);
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asu64(R1) = m;
	goto L508;
L508:
	return asu64(R1);
}

static i64 mlib_writefile(u64 filename, u64 data, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 f;
	i64 n;
	R1 = tou64("wb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L515;
	R1 = 0;
	goto L513;
L515:
	asi64(R1) = size;
	R2 = 0;
	asu64(R3) = data;
	asu64(R4) = f;
	asi64(R1) = mlib_writerandom(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asi64(R1) = n;
	goto L513;
L513:
	return asi64(R1);
}

static i64 mlib_checkfile(u64 file) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("rb");
	asu64(R2) = file;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	R2 = R1;
	f = asu64(R2);
	if (!asu64(R1)) goto L518;
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	R1 = 1;
	goto L516;
L518:
	R1 = 0;
	goto L516;
L516:
	return asi64(R1);
}

static void mlib_readlinen(u64 handlex, u64 buffer, i64 size) {
    u64 R1, R2, R3; 
	i64 ch;
	u64 p;
	i64 n;
	u8 crseen;
	asu64(R1) = handlex;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L521;
	asu64(R1) = mlinux_os_getstdin();
	handlex = asu64(R1);
L521:
	asu64(R1) = handlex;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L523;
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = buffer;
	p = asu64(R1);
L524:
	asi32(R1) = getchar();
	R1 = toi64(toi32(R1));
	ch = asi64(R1);
	asi64(R1) = ch;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L528;
	asi64(R1) = ch;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L528;
	asi64(R1) = ch;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L527;
L528:
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L519;
L527:
	asi64(R1) = ch;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = n;
	asi64(R2) = size;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	if (asi64(R1) < asi64(R2)) goto L530;
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L519;
L530:
	goto L524;
L523:
	R1 = 0;
	asu64(R2) = buffer;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	asu64(R3) = buffer;
	asu64(R1) = fgets(asu64(R3), asi64(R2), asu64(R1));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L532;
	goto L519;
L532:
	asu64(R1) = buffer;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L534;
	goto L519;
L534:
	asu64(R1) = buffer;
	asi64(R2) = n;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	p = asu64(R1);
	R1 = 0;
	crseen = asu8(R1);
	goto L536;
L535:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L540;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L539;
L540:
	R1 = 1;
	crseen = asu8(R1);
L539:
	R1 = 0;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) -= 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L536:
	asu64(R1) = p;
	asu64(R2) = buffer;
	if (asu64(R1) < asu64(R2)) goto L541;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L535;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L535;
L541:
	asu8(R1) = crseen;
	if (asu8(R1)) goto L543;
	asi64(R1) = n;
	R2 = 4;
	asi64(R1) += asi64(R2);
	asi64(R2) = size;
	if (asi64(R1) <= asi64(R2)) goto L543;
	msysc_m$print_startcon();
	asi64(R1) = size;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("line too long");
	mlib_abortprogram(asu64(R1));
L543:
L519:
	return;
}

static void mlib_iconvlcn(u64 s, i64 n) {
    u64 R1, R2; 
	i64 av_1;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L547;
L545:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = tolower(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L545;
L547:
	return;
}

static void mlib_iconvucn(u64 s, i64 n) {
    u64 R1, R2; 
	i64 av_1;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L551;
L549:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L549;
L551:
	return;
}

static u64 mlib_convlcstring(u64 s) {
    u64 R1, R2; 
	u64 s0;
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L554;
L553:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = tolower(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L554:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L553;
	asu64(R1) = s0;
	goto L552;
L552:
	return asu64(R1);
}

static u64 mlib_convucstring(u64 s) {
    u64 R1, R2; 
	u64 s0;
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L558;
L557:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L558:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L557;
	asu64(R1) = s0;
	goto L556;
L556:
	return asu64(R1);
}

static u64 mlib_changeext(u64 s, u64 newext) {
    u64 R1, R2, R3; 
	struct $B31 newext2;
	u64 sext;
	i64 n;
	asu64(R1) = s;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = newext;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L562;
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L563;
	goto L564;
L562:
	R1 = 0;
	R2 = (u64)&newext2;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&newext2;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L561;
L563:
	asu64(R1) = newext;
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L561;
L564:
	R1 = tou64(".");
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = newext;
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L561:
	R1 = 1;
	asu64(R2) = s;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	sext = asu64(R1);
	asu64(R1) = sext;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L566;
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L567;
	goto L568;
L566:
	R1 = (u64)&newext2;
	R2 = 0;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L565;
L567:
	R1 = (u64)&newext2;
	R2 = 1;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L565;
L568:
	asu64(R1) = sext;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	R2 = 2;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	R1 = (u64)&newext2;
	R2 = 0;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asi64(R3) = n;
	R2 += (i64)R3+1;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L565:
	R1 = (u64)&mlib_changeext_newfile;
	R2 = 0;
	R1 += (i64)R2;
	goto L560;
L560:
	return asu64(R1);
}

static u64 mlib_extractext(u64 s, i64 period) {
    u64 R1, R2; 
	u64 t;
	u64 u;
	asu64(R1) = s;
	asu64(R1) = mlib_extractfile(asu64(R1));
	t = asu64(R1);
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L571;
	R1 = tou64("");
	goto L569;
L571:
	asu64(R1) = t;
	asu64(R2) = t;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	u = asu64(R1);
	goto L573;
L572:
	asu64(R1) = u;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L576;
	asu64(R1) = u;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L578;
	asi64(R1) = period;
	if (!asi64(R1)) goto L580;
	R1 = tou64(".");
	goto L579;
L580:
	R1 = tou64("");
L579:
	goto L569;
L578:
	asu64(R1) = u;
	R2 = 1;
	R1 += (i64)R2;
	goto L569;
L576:
	R1 = (u64)&u;
	(*tou64p(R1)) -=1;
L573:
	asu64(R1) = u;
	asu64(R2) = t;
	if (asu64(R1) >= asu64(R2)) goto L572;
	R1 = tou64("");
	goto L569;
L569:
	return asu64(R1);
}

static u64 mlib_extractpath(u64 s) {
    u64 R1, R2, R3; 
	u64 t;
	i64 n;
	asu64(R1) = s;
	asu64(R2) = s;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	t = asu64(R1);
	goto L583;
L582:
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) == asu64(R2)) goto L586;
	R2 = 47;
	if (asu64(R1) == asu64(R2)) goto L586;
	R2 = 58;
	if (asu64(R1) == asu64(R2)) goto L586;
	goto L587;
L586:
	asu64(R1) = t;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	R3 = (u64)&mlib_extractpath_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractpath_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_extractpath_str;
	goto L581;
	goto L585;
L587:
L585:
	R1 = (u64)&t;
	(*tou64p(R1)) -=1;
L583:
	asu64(R1) = t;
	asu64(R2) = s;
	if (asu64(R1) >= asu64(R2)) goto L582;
	R1 = tou64("");
	goto L581;
L581:
	return asu64(R1);
}

static u64 mlib_extractfile(u64 s) {
    u64 R1, R2; 
	u64 t;
	asu64(R1) = s;
	asu64(R1) = mlib_extractpath(asu64(R1));
	t = asu64(R1);
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L590;
	asu64(R1) = s;
	goto L588;
L590:
	asu64(R1) = s;
	asu64(R2) = t;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	goto L588;
L588:
	return asu64(R1);
}

static u64 mlib_extractbasefile(u64 s) {
    u64 R1, R2, R3; 
	u64 f;
	u64 e;
	i64 n;
	i64 flen;
	asu64(R1) = s;
	asu64(R1) = mlib_extractfile(asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asi64(R1) = strlen(asu64(R1));
	flen = asi64(R1);
	asi64(R1) = flen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L593;
	R1 = tou64("");
	goto L591;
L593:
	R1 = 0;
	asu64(R2) = f;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L595;
	asi64(R1) = flen;
	asu64(R2) = e;
	asi64(R2) = strlen(asu64(R2));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = f;
	R3 = (u64)&mlib_extractbasefile_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractbasefile_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_extractbasefile_str;
	goto L591;
L595:
	asu64(R1) = f;
	asi64(R2) = flen;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L597;
	asi64(R1) = flen;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	asu64(R2) = f;
	R3 = (u64)&mlib_extractbasefile_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractbasefile_str;
	asi64(R3) = flen;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&mlib_extractbasefile_str;
	goto L591;
L597:
	asu64(R1) = f;
	goto L591;
L591:
	return asu64(R1);
}

static u64 mlib_addext(u64 s, u64 newext) {
    u64 R1, R2; 
	u64 sext;
	R1 = 1;
	asu64(R2) = s;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	sext = asu64(R1);
	asu64(R1) = sext;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L600;
	asu64(R1) = newext;
	asu64(R2) = s;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	goto L598;
L600:
	asu64(R1) = s;
	goto L598;
L598:
	return asu64(R1);
}

static u64 mlib_pcm_alloc32() {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 32;
	mlib_allocbytes = asi64(R1);
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	p = asu64(R2);
	if (!asu64(R1)) goto L603;
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_freelist;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = p;
	goto L601;
L603:
	R1 = 32;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	goto L601;
L601:
	return asu64(R1);
}

static void mlib_pcm_free32(u64 p) {
    u64 R1, R2, R3; 
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&mlib_freelist;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	return;
}

static void mlib_outbyte(u64 f, i64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 1;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu16(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 2;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu32(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 4;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu64(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 8;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outstring(u64 f, u64 s) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	asu64(R3) = s;
	asi64(R3) = strlen(asu64(R3));
	R4 = 1;
	asu64(R3) += asu64(R4);
	asu64(R4) = s;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outblock(u64 f, u64 p, i64 n) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	asi64(R3) = n;
	asu64(R4) = p;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static i64 mlib_myeof(u64 f) {
    u64 R1, R2; 
	i64 c;
	asu64(R1) = f;
	asi32(R1) = fgetc(asu64(R1));
	R1 = toi64(toi32(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L613;
	R1 = 1;
	goto L611;
L613:
	asu64(R1) = f;
	asi64(R2) = c;
	asi32(R1) = ungetc(asi32(R2), asu64(R1));
	R1 = 0;
	goto L611;
L611:
	return asi64(R1);
}

static void mlib_strbuffer_add(u64 dest, u64 s, i64 n) {
    u64 R1, R2, R3, R4; 
	i64 newlen;
	i64 oldlen;
	u64 newptr;
	asi64(R1) = n;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L616;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
L616:
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	oldlen = asi64(R1);
	asi64(R1) = oldlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L618;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = dest;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = n;
	asu64(R2) = dest;
	R3 = 8;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = dest;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L614;
L618:
	asi64(R1) = oldlen;
	asi64(R2) = n;
	asi64(R1) += asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = dest;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) <= asi64(R2)) goto L620;
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	newptr = asu64(R1);
	asi64(R1) = oldlen;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = newptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = newptr;
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = dest;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L620:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = dest;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R4) = oldlen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = newlen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = newlen;
	asu64(R2) = dest;
	R3 = 8;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L614:
	return;
}

static void mlib_gs_init(u64 dest) {
    u64 R1, R2; 
	R1 = 16;
	asu64(R2) = dest;
	mlib_pcm_clearmem(asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_free(u64 dest) {
    u64 R1, R2, R3; 
	asu64(R1) = dest;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L624;
	asu64(R1) = dest;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L624:
	return;
}

static void mlib_gs_str(u64 dest, u64 s) {
    u64 R1, R2, R3; 
	R1 = -1;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_char(u64 dest, i64 c) {
    u64 R1, R2, R3; 
	struct $B3 s;
	asi64(R1) = c;
	R2 = (u64)&s;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&s;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strn(u64 dest, u64 s, i64 length) {
    u64 R1, R2, R3; 
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strvar(u64 dest, u64 s) {
    u64 R1, R2, R3; 
	R1 = -1;
	asu64(R2) = s;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strint(u64 dest, i64 a) {
    u64 R1, R2, R3; 
	R1 = -1;
	R2 = 0;
	asi64(R3) = a;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strln(u64 dest, u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	mlib_gs_line(asu64(R1));
	return;
}

static void mlib_gs_strsp(u64 dest, u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void mlib_gs_line(u64 dest) {
    u64 R1, R2, R3; 
	R1 = -1;
	R2 = tou64("\n");
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static i64 mlib_gs_getcol(u64 dest) {
    u64 R1, R2; 
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	goto L633;
L633:
	return asi64(R1);
}

static void mlib_gs_leftstr(u64 dest, u64 s, i64 w, i64 padch) {
    u64 R1, R2, R3, R4; 
	i64 col;
	i64 i;
	i64 n;
	i64 slen;
	struct $B72 str;
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	col = asi64(R1);
	asu64(R1) = s;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	slen = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = slen;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L636;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L639;
L637:
	asi64(R1) = padch;
	R2 = (u64)&str;
	asi64(R3) = slen;
	asi64(R4) = i;
	asi64(R3) += asi64(R4);
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= n) goto L637;
L639:
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = slen;
	asi64(R4) = n;
	asi64(R3) += asi64(R4);
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L636:
	R1 = (u64)&str;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void mlib_gs_leftint(u64 dest, i64 a, i64 w, i64 padch) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = padch;
	asi64(R2) = w;
	R3 = 0;
	asi64(R4) = a;
	asu64(R3) = msysc_strint(asi64(R4), asu64(R3));
	asu64(R4) = dest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mlib_gs_padto(u64 dest, i64 col, i64 ch) {
    u64 R1, R2, R3; 
	i64 n;
	struct $B72 str;
	i64 i;
	asi64(R1) = col;
	asu64(R2) = dest;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L643;
	goto L641;
L643:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L646;
L644:
	asi64(R1) = ch;
	R2 = (u64)&str;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= n) goto L644;
L646:
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
L641:
	return;
}

static void mlib_gs_println(u64 dest, u64 f) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L649;
	goto L647;
L649:
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	R4 = 8;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L651;
	msysc_m$print_startcon();
	asu64(R1) = dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("\r");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L650;
L651:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("\r");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L650:
L647:
	return;
}

static i64 mlib_nextcmdparamnew(u64 paramno, u64 name, u64 value, u64 defext) {
    u64 R1, R2; 
	u64 q;
	u64 item;
	u64 fileext;
	i64 length;
// PROC LOCAL STATICS GO HERE
	static i64 mlib_nextcmdparamnew_infile = 0;
	static u64 mlib_nextcmdparamnew_filestart = 0;
	static u64 mlib_nextcmdparamnew_fileptr = 0;
	static u8 mlib_nextcmdparamnew_colonseen = 0;
// mlib.nextcmdparamnew.reenter:
L653:
	R1 = 0;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = mlib_nextcmdparamnew_infile;
	if (!asi64(R1)) goto L655;
	R1 = (u64)&item;
	R2 = (u64)&mlib_nextcmdparamnew_fileptr;
	asi64(R1) = mlib_readnextfileitem(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L657;
	asu64(R1) = mlib_nextcmdparamnew_filestart;
	free(asu64(R1));
	R1 = 0;
	mlib_nextcmdparamnew_infile = asi64(R1);
	goto L653;
L657:
	goto L654;
L655:
	asu64(R1) = paramno;
	asi64(R1) = *toi64p(R1);
	asi64(R2) = msysc_ncmdparams;
	if (asi64(R1) <= asi64(R2)) goto L659;
	R1 = 0;
	goto L652;
L659:
	asu64(R1) = msysc_cmdparams;
	asu64(R2) = paramno;
	asi64(R2) = *toi64p(R2);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	item = asu64(R1);
	asu64(R1) = paramno;
	(*toi64p(R1)) += 1;
	asu64(R1) = item;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 64;
	if (asu64(R1) != asu64(R2)) goto L661;
	asu64(R1) = item;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R1) = mlib_readfile(asu64(R1));
	R2 = R1;
	mlib_nextcmdparamnew_fileptr = asu64(R2);
	mlib_nextcmdparamnew_filestart = asu64(R1);
	asu64(R1) = mlib_nextcmdparamnew_filestart;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L663;
	msysc_m$print_startcon();
	R1 = tou64("Can't open");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = item;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 7;
	exit(R1);
L663:
	R1 = 1;
	mlib_nextcmdparamnew_infile = asi64(R1);
	goto L653;
L661:
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 58;
	if (asu64(R1) != asu64(R2)) goto L665;
	R1 = 1;
	mlib_nextcmdparamnew_colonseen = asu8(R1);
	R1 = 4;
	goto L652;
L665:
L654:
	R1 = 0;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) != asu64(R2)) goto L667;
	asu64(R1) = item;
	asu8(R2) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R2)) goto L669;
	R2 = 0;
	goto L668;
L669:
	R2 = 1;
L668:
	R1 += (i64)R2;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	R1 = 58;
	asu64(R2) = item;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	q = asu64(R1);
	asu64(R1) = q;
	if (asu64(R1)) goto L671;
	R1 = 61;
	asu64(R2) = item;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	q = asu64(R1);
L671:
	asu64(R1) = q;
	if (!asu64(R1)) goto L673;
	asu64(R1) = q;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
L673:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L675;
	R1 = 5;
	goto L674;
L675:
	R1 = 1;
L674:
	goto L652;
L667:
	R1 = 0;
	asu64(R2) = item;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	fileext = asu64(R1);
	asu64(R1) = item;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = fileext;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L677;
	asu64(R1) = name;
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_nextcmdparamnew_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = defext;
	if (!asu64(R1)) goto L679;
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (asu8(R1)) goto L679;
	asu64(R1) = defext;
	R2 = (u64)&mlib_nextcmdparamnew_str;
	asu64(R1) = mlib_addext(asu64(R2), asu64(R1));
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
L679:
	goto L676;
L677:
	R1 = tou64("dll");
	asu64(R2) = fileext;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L681;
	R1 = tou64("mcx");
	asu64(R2) = fileext;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L680;
L681:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L683;
	R1 = 5;
	goto L682;
L683:
	R1 = 3;
L682:
	goto L652;
L680:
L676:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L685;
	R1 = 5;
	goto L684;
L685:
	R1 = 2;
L684:
	goto L652;
L652:
	return asi64(R1);
}

static i64 mlib_readnextfileitem(u64 fileptr, u64 item) {
    u64 R1, R2, R3; 
	u64 p;
	u64 pstart;
	u64 pend;
	i64 n;
	asu64(R1) = fileptr;
	asu64(R1) = *tou64p(R1);
	p = asu64(R1);
// mlib.readnextfileitem.reenter:
L687:
L688:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L692;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L692;
	goto L693;
L691:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L690;
L692:
	R1 = 0;
	goto L686;
	goto L690;
L693:
	goto L689;
L690:
	goto L688;
L689:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 33;
	if (asu64(R1) == asu64(R2)) goto L695;
	R2 = 35;
	if (asu64(R1) == asu64(R2)) goto L695;
	goto L696;
L695:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L697:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L699;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L700;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L700;
	goto L701;
L699:
	goto L687;
	goto L697;
L700:
	asu64(R1) = p;
	R2 = 1;
	R1 -= (i64)R2;
	asu64(R2) = fileptr;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	goto L686;
	goto L697;
L701:
	goto L697;
	goto L694;
L696:
L694:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L703;
	goto L704;
L703:
	R1 = (u64)&p;
	asu64(R1) = *(tou64p(R1)) += 1;
	pstart = asu64(R1);
L705:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L708;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L708;
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L709;
	goto L710;
L708:
	msysc_m$print_startcon();
	R1 = tou64("Unexpected EOF in @file");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 8;
	exit(R1);
	goto L707;
L709:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	pend = asu64(R1);
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 44;
	if (asu64(R1) != asu64(R2)) goto L712;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L712:
	goto L706;
	goto L707;
L710:
L707:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L705;
L706:
	goto L702;
L704:
	asu64(R1) = p;
	pstart = asu64(R1);
L713:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L716;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L716;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L717;
	goto L718;
L716:
	asu64(R1) = p;
	pend = asu64(R1);
	goto L714;
	goto L715;
L717:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	pend = asu64(R1);
	goto L714;
	goto L715;
L718:
L715:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L713;
L714:
L702:
	asu64(R1) = pend;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 256;
	if (asi64(R1) < asi64(R2)) goto L720;
	msysc_m$print_startcon();
	R1 = tou64("@file item too long");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 9;
	exit(R1);
L720:
	asi64(R1) = n;
	asu64(R2) = pstart;
	R3 = (u64)&mlib_readnextfileitem_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_readnextfileitem_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_readnextfileitem_str;
	asu64(R2) = item;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = fileptr;
	*tou64p(R2) = asu64(R1);
	R1 = 1;
	goto L686;
L686:
	return asi64(R1);
}

static void mlib_ipadstr(u64 s, i64 width, u64 padchar) {
    u64 R1, R2; 
	i64 n;
	i64 av_1;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = width;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L724;
L722:
	asu64(R1) = padchar;
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	if (--asi64(av_1)) goto L722;
L724:
	return;
}

static u64 mlib_padstr(u64 s, i64 width, u64 padchar) {
    u64 R1, R2, R3; 
	asu64(R1) = s;
	R2 = (u64)&mlib_padstr_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = padchar;
	asi64(R2) = width;
	R3 = (u64)&mlib_padstr_str;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&mlib_padstr_str;
	goto L725;
L725:
	return asu64(R1);
}

static u64 mlib_chr(i64 c) {
    u64 R1, R2, R3; 
	asi64(R1) = c;
	R2 = (u64)&mlib_chr_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mlib_chr_str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&mlib_chr_str;
	goto L726;
L726:
	return asu64(R1);
}

static i64 mlib_cmpstring(u64 s, u64 t) {
    u64 R1, R2; 
	i64 res;
	asu64(R1) = t;
	asu64(R2) = s;
	asi32(R1) = strcmp(asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L729;
	R1 = -1;
	goto L728;
L729:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L730;
	R1 = 1;
	goto L728;
L730:
	R1 = 0;
L728:
	goto L727;
L727:
	return asi64(R1);
}

static i64 mlib_cmpstringn(u64 s, u64 t, i64 n) {
    u64 R1, R2, R3; 
	i64 res;
	asi64(R1) = n;
	asu64(R2) = t;
	asu64(R3) = s;
	asi32(R1) = strncmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L733;
	R1 = -1;
	goto L732;
L733:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L734;
	R1 = 1;
	goto L732;
L734:
	R1 = 0;
L732:
	goto L731;
L731:
	return asi64(R1);
}

static i64 mlib_eqstring(u64 s, u64 t) {
    u64 R1, R2; 
	asu64(R1) = t;
	asu64(R2) = s;
	asi32(R1) = strcmp(asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L735;
L735:
	return asi64(R1);
}

static i64 mlib_cmpbytes(u64 p, u64 q, i64 n) {
    u64 R1, R2, R3; 
	i64 res;
	asi64(R1) = n;
	asu64(R2) = q;
	asu64(R3) = p;
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L738;
	R1 = -1;
	goto L737;
L738:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L739;
	R1 = 1;
	goto L737;
L739:
	R1 = 0;
L737:
	goto L736;
L736:
	return asi64(R1);
}

static i64 mlib_eqbytes(u64 p, u64 q, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = q;
	asu64(R3) = p;
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L740;
L740:
	return asi64(R1);
}

static void mlib_mseed(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = (u64)&mlib_seed;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = b;
	if (!asu64(R1)) goto L743;
	asu64(R1) = b;
	R2 = (u64)&mlib_seed;
	R3 = 2;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	goto L742;
L743:
	asu64(R1) = a;
	R2 = (u64)&mlib_seed;
	R3 = 2;
	R2 += (i64)R3*8-8;
	*toi64p(R2) ^= asi64(R1);
L742:
	return;
}

static u64 mlib_mrandom() {
    u64 R1, R2, R3; 
	i64 x;
	i64 y;
	R1 = (u64)&mlib_seed;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	x = asi64(R1);
	R1 = (u64)&mlib_seed;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	y = asi64(R1);
	asi64(R1) = y;
	R2 = (u64)&mlib_seed;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = x;
	R2 = 23;
	asi64(R1) <<= asi64(R2);
	R2 = (u64)&x;
	*toi64p(R2) ^= asi64(R1);
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) ^= asi64(R2);
	asi64(R2) = x;
	R3 = 17;
	asi64(R2) >>= asi64(R3);
	asi64(R1) ^= asi64(R2);
	asi64(R2) = y;
	R3 = 26;
	asi64(R2) >>= asi64(R3);
	asi64(R1) ^= asi64(R2);
	R2 = (u64)&mlib_seed;
	R3 = 2;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&mlib_seed;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = y;
	asu64(R1) += asu64(R2);
	goto L744;
L744:
	return asu64(R1);
}

static i64 mlib_mrandomp() {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandom();
	R2 = 9223372036854775807;
	asi64(R1) &= asi64(R2);
	goto L745;
L745:
	return asi64(R1);
}

static i64 mlib_mrandomint(i64 n) {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandomp();
	asi64(R2) = n;
	asi64(R1) %= asi64(R2);
	goto L746;
L746:
	return asi64(R1);
}

static i64 mlib_mrandomrange(i64 a, i64 b) {
    u64 R1, R2; 
	i64 span;
	asi64(R1) = b;
	asi64(R2) = a;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	span = asi64(R1);
	asi64(R1) = span;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L749;
	R1 = 0;
	goto L747;
L749:
	asi64(R1) = mlib_mrandomp();
	asi64(R2) = span;
	asi64(R1) %= asi64(R2);
	asi64(R2) = a;
	asi64(R1) += asi64(R2);
	goto L747;
L747:
	return asi64(R1);
}

static r64 mlib_mrandomreal() {
    u64 R1, R2; 
	r64 x;
L751:
	asi64(R1) = mlib_mrandomp();
	asr64(R1) = tor64(asi64(R1));
	asr64(R2) = 9.223372036854775800e+018;
	asr64(R1) /= asr64(R2);
	x = asr64(R1);
	asr64(R1) = x;
	asr64(R2) = 1.000000000000000000e+000;
	if (asr64(R1) == asr64(R2)) goto L751;
	asr64(R1) = x;
	goto L750;
L750:
	return asr64(R1);
}

static r64 mlib_mrandomreal1() {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandomp();
	asr64(R1) = tor64(asi64(R1));
	asr64(R2) = 9.223372036854775800e+018;
	asr64(R1) /= asr64(R2);
	goto L754;
L754:
	return asr64(R1);
}

static u64 mlib_readline() {
    u64 R1; 
	msysc_m$read_conline();
	asu64(R1) = msysc_rd_buffer;
	goto L755;
L755:
	return asu64(R1);
}

static u64 mlib_findfunction(u64 name) {
    u64 R1, R2, R3; 
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = $nprocs;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L759;
L757:
	asu64(R1) = name;
	R2 = (u64)&$procname;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L761;
	R1 = (u64)&$procaddr;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L756;
L761:
	i += 1; if (i <= av_1) goto L757;
L759:
	R1 = 0;
	goto L756;
L756:
	return asu64(R1);
}

static i64 mlib_roundtoblock(i64 n, i64 align) {
    u64 R1, R2, R3, R4, R5; 
	asi64(R1) = n;
	asi64(R2) = align;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L764;
	asi64(R1) = n;
	goto L762;
L764:
	asi64(R1) = n;
	asi64(R2) = align;
	asi64(R3) = n;
	asi64(R4) = align;
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) &= asi64(R4);
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	goto L762;
L762:
	return asi64(R1);
}

static u64 mlib_pcm_allocnfz(i64 n) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asi64(R1) = n;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L767;
	asi64(R1) = n;
	R2 = 8;
	asi64(R3) = n;
	R4 = 7;
	asi64(R3) &= asi64(R4);
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	n = asi64(R1);
L767:
	asu64(R1) = mlib_pcheapptr;
	p = asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = mlib_pcheapptr;
	asu64(R2) = mlib_pcheapend;
	if (asu64(R1) < asu64(R2)) goto L769;
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	p = asu64(R1);
L769:
	asu64(R1) = p;
	goto L765;
L765:
	return asu64(R1);
}

static void mlinux_os_init() {
    u64 R1; 
	R1 = 1;
	mlinux_init_flag = asi64(R1);
	return;
}

static i64 mlinux_os_execwait(u64 cmdline, i64 newconsole, u64 workdir) {
    u64 R1; 
	asu64(R1) = cmdline;
	asi32(R1) = system(asu64(R1));
	R1 = toi64(toi32(R1));
	goto L771;
L771:
	return asi64(R1);
}

static i64 mlinux_os_execcmd(u64 cmdline, i64 newconsole) {
    u64 R1; 
	asu64(R1) = cmdline;
	asi32(R1) = system(asu64(R1));
	R1 = toi64(toi32(R1));
	goto L772;
L772:
	return asi64(R1);
}

static i64 mlinux_os_getch() {
    u64 R1, R2, R3; struct $B66 R1_B66; 
	struct $B66 old;
	struct $B66 new;
	u8 ch;
	R1 = (u64)&old;
	R2 = 0;
	asi32(R1) = tcgetattr(asi32(R2), asu64(R1));
	(R1_B66) = old;
	new = (R1_B66);
	R1 = -3;
	R2 = (u64)&new;
	R3 = 12;
	R2 += (i64)R3;
	*toi32p(R2) &= asi32(R1);
	R1 = -9;
	R2 = (u64)&new;
	R3 = 12;
	R2 += (i64)R3;
	*toi32p(R2) &= asi32(R1);
	R1 = -2;
	R2 = (u64)&new;
	R3 = 12;
	R2 += (i64)R3;
	*toi32p(R2) &= asi32(R1);
	R1 = (u64)&new;
	R2 = 0;
	R3 = 0;
	asi32(R1) = tcsetattr(asi32(R3), asi32(R2), asu64(R1));
	asi32(R1) = getchar();
	ch = asu8(R1);
	R1 = (u64)&old;
	R2 = 0;
	R3 = 0;
	asi32(R1) = tcsetattr(asi32(R3), asi32(R2), asu64(R1));
	asu8(R1) = ch;
	R1 = toi64(tou8(R1));
	goto L773;
L773:
	return asi64(R1);
}

static i64 mlinux_os_kbhit() {
    u64 R1; 
	R1 = tou64("kbhit");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L774;
L774:
	return asi64(R1);
}

static void mlinux_os_flushkeys() {
    u64 R1; 
	R1 = tou64("flushkeys");
	mlib_abortprogram(asu64(R1));
	return;
}

static u64 mlinux_os_getconsolein() {
    u64 R1; 
	R1 = 0;
	goto L776;
L776:
	return asu64(R1);
}

static u64 mlinux_os_getconsoleout() {
    u64 R1; 
	R1 = 0;
	goto L777;
L777:
	return asu64(R1);
}

static u64 mlinux_os_proginstance() {
    u64 R1; 
	R1 = tou64("PROGINST");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L778;
L778:
	return asu64(R1);
}

static u64 mlinux_os_getdllinst(u64 name) {
    u64 R1, R2; 
	u64 h;
	R1 = 1;
	asu64(R2) = name;
	asu64(R1) = dlopen(asu64(R2), asi32(R1));
	h = asu64(R1);
	asu64(R1) = h;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L781;
	R1 = tou64("msvcrt");
	asu64(R2) = name;
	asi32(R1) = strcmp(asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L783;
	R1 = 1;
	R2 = tou64("libc.so.6");
	asu64(R1) = dlopen(asu64(R2), asi32(R1));
	h = asu64(R1);
L783:
L781:
	asu64(R1) = h;
	goto L779;
L779:
	return asu64(R1);
}

static u64 mlinux_os_getdllprocaddr(i64 hlib, u64 name) {
    u64 R1, R2; 
	u64 fnaddr;
	asi64(R1) = hlib;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L786;
	R1 = 0;
	goto L784;
L786:
	asu64(R1) = name;
	asi64(R2) = hlib;
	asu64(R1) = dlsym(asu64(R2), asu64(R1));
	fnaddr = asu64(R1);
	asu64(R1) = fnaddr;
	goto L784;
L784:
	return asu64(R1);
}

static void mlinux_os_initwindows() {
	return;
}

static i64 mlinux_os_getchx() {
    u64 R1; 
	R1 = tou64("getchx");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L788;
L788:
	return asi64(R1);
}

static u64 mlinux_os_getos() {
    u64 R1; 
	R1 = tou64("L64");
	goto L789;
L789:
	return asu64(R1);
}

static i64 mlinux_os_gethostsize() {
    u64 R1; 
	R1 = 64;
	goto L790;
L790:
	return asi64(R1);
}

static i64 mlinux_os_iswindows() {
    u64 R1; 
	R1 = 0;
	goto L791;
L791:
	return asi64(R1);
}

static i64 mlinux_os_shellexec(u64 opc, u64 file) {
    u64 R1; 
	R1 = tou64("SHELL EXEC");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L792;
L792:
	return asi64(R1);
}

static void mlinux_os_sleep(i64 a) {
	return;
}

static u64 mlinux_os_getstdin() {
    u64 R1; 
	u64 pf;
	R1 = (u64)&stdin;
	pf = asu64(R1);
	asu64(R1) = pf;
	asu64(R1) = *tou64p(R1);
	goto L794;
L794:
	return asu64(R1);
}

static u64 mlinux_os_getstdout() {
    u64 R1; 
	u64 pf;
	R1 = (u64)&stdout;
	pf = asu64(R1);
	asu64(R1) = pf;
	asu64(R1) = *tou64p(R1);
	goto L795;
L795:
	return asu64(R1);
}

static u64 mlinux_os_gethostname() {
    u64 R1; 
	R1 = tou64("");
	goto L796;
L796:
	return asu64(R1);
}

static u64 mlinux_os_getmpath() {
    u64 R1; 
	R1 = tou64("");
	goto L797;
L797:
	return asu64(R1);
}

static void mlinux_os_exitprocess(i64 x) {
    u64 R1; 
	R1 = 0;
	exit(R1);
	return;
}

static i64 mlinux_os_clock() {
    u64 R1, R2; 
	asi64(R1) = mlinux_os_iswindows();
	if (!asi64(R1)) goto L801;
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	goto L800;
L801:
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	R2 = 1000;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
L800:
	goto L799;
L799:
	return asi64(R1);
}

static i64 mlinux_os_ticks() {
    u64 R1; 
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	goto L802;
L802:
	return asi64(R1);
}

static i64 mlinux_os_getclockspersec() {
    u64 R1; 
	asi64(R1) = mlinux_os_iswindows();
	if (!asi64(R1)) goto L805;
	R1 = 1000;
	goto L804;
L805:
	R1 = 1000000;
L804:
	goto L803;
L803:
	return asi64(R1);
}

static void mlinux_os_setmesshandler(u64 addr) {
    u64 R1; 
	R1 = tou64("SETMESSHANDLER");
	mlib_abortprogram(asu64(R1));
	return;
}

static i64 mlinux_os_hpcounter() {
    u64 R1; 
	R1 = 1;
	goto L807;
L807:
	return asi64(R1);
}

static i64 mlinux_os_hpfrequency() {
    u64 R1; 
	R1 = 1;
	goto L808;
L808:
	return asi64(R1);
}

static i64 mlinux_os_filelastwritetime(u64 filename) {
    u64 R1; 
	R1 = 0;
	goto L809;
L809:
	return asi64(R1);
}

static void mlinux_os_getsystime(u64 tm) {
    u64 R1, R2, R3; 
	struct $B3 tv;
	struct $B63 tmr;
	R1 = 0;
	R2 = (u64)&tv;
	asi32(R1) = gettimeofday(asu64(R2), asu64(R1));
	R1 = (u64)&tmr;
	R2 = (u64)&tv;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = gmtime_r(asu64(R2), asu64(R1));
	R1 = (u64)&tmr;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1900;
	asi64(R1) += asi64(R2);
	asu64(R2) = tm;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&tmr;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = tm;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&tmr;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = tm;
	R3 = 8;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&tmr;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = tm;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&tmr;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = tm;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&tmr;
	R2 = 4;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = tm;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&tmr;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = tm;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&tv;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1000;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = tm;
	R3 = 28;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = tm;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mlinux_os_peek() {
	return;
}

static u64 mlinux_os_allocexecmem(i64 n) {
    u64 R1; 
	R1 = tou64("No allocexec");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L812;
L812:
	return asu64(R1);
}

static i64 mlinux_dirlist(u64 filespec, u64 dest, i64 capacity, i64 t) {
    u64 R1; 
	R1 = 0;
	goto L813;
L813:
	return asi64(R1);
}

static u64 mwindllc_os_calldllfunction(u64 fnaddr, i64 retcode, i64 nargs, u64 args, u64 argcodes) {
    u64 R1, R2, R3; 
	u64 a;
	r64 x;
	i64 oddstack;
	i64 nextra;
	i64 pushedbytes;
	asi64(R1) = retcode;
	R2 = 73;
	if (asi64(R1) != asi64(R2)) goto L816;
	asi64(R1) = nargs;
	asu64(R2) = args;
	asu64(R3) = fnaddr;
	asu64(R1) = mwindllc_calldll_cint(asu64(R3), asu64(R2), asi64(R1));
	goto L815;
L816:
	asi64(R1) = nargs;
	asu64(R2) = args;
	asu64(R3) = fnaddr;
	asu64(R1) = mwindllc_calldll_creal(asu64(R3), asu64(R2), asi64(R1));
L815:
	goto L814;
L814:
	return asu64(R1);
}

static u64 mwindllc_os_pushargs(u64 args, i64 nargs, i64 nextra, u64 fnaddr, i64 isfloat) {
    u64 R1, R2, R3, R4, R5; 
	u64 a;
	r64 x;
	R1 = 0;
	asu64(R2) = args;
	asi64(R3) = nargs;
	asi64(R4) = isfloat;
	if (!asi64(R4)) goto L819;
	R4 = 0;
	goto L818;
L819:
	R4 = 73;
L818:
	asu64(R5) = fnaddr;
	asu64(R1) = mwindllc_os_calldllfunction(asu64(R5), asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	goto L817;
L817:
	return asu64(R1);
}

static i64 mwindllc_calldll_cint(u64 fnaddr, u64 params, i64 nparams) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13; 
	asi64(R1) = nparams;
	switch (asi64(R1)) {
	case 0: goto L824;
	case 1: goto L825;
	case 2: goto L826;
	case 3: goto L827;
	case 4: goto L828;
	case 5: goto L829;
	case 6: goto L830;
	case 7: goto L823;
	case 8: goto L831;
	case 9: goto L832;
	case 10: goto L833;
	case 11: goto L834;
	case 12: goto L835;
	default: goto L823;
    };
// SWITCH
L824:
	asu64(R1) = fnaddr;
	asi64(R1) = ((F1)R1)();
	goto L820;
	goto L821;
L825:
	asu64(R1) = params;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = fnaddr;
	asi64(R1) = ((F2)R2)(asi64(R1));
	goto L820;
	goto L821;
L826:
	asu64(R1) = params;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 1;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = fnaddr;
	asi64(R1) = ((F3)R3)(asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L827:
	asu64(R1) = params;
	R2 = 3;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 2;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 1;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = fnaddr;
	asi64(R1) = ((F4)R4)(asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L828:
	asu64(R1) = params;
	R2 = 4;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 3;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 2;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 1;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = fnaddr;
	asi64(R1) = ((F5)R5)(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L829:
	asu64(R1) = params;
	R2 = 5;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 4;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 3;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 2;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 1;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = fnaddr;
	asi64(R1) = ((F6)R6)(asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L830:
	asu64(R1) = params;
	R2 = 6;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 5;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 4;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 3;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 2;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 1;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = fnaddr;
	asi64(R1) = ((F7)R7)(asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L831:
	asu64(R1) = params;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 7;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 6;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 5;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 4;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 3;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 2;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 1;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = fnaddr;
	asi64(R1) = ((F8)R9)(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L832:
	asu64(R1) = params;
	R2 = 9;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 7;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 6;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 5;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 4;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 3;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 2;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 1;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = fnaddr;
	asi64(R1) = ((F9)R10)(asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L833:
	asu64(R1) = params;
	R2 = 10;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 9;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 8;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 7;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 6;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 5;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 4;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 3;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 2;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 1;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = fnaddr;
	asi64(R1) = ((F10)R11)(asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L834:
	asu64(R1) = params;
	R2 = 11;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 10;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 9;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 8;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 7;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 6;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 5;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 4;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 3;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 2;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = params;
	R12 = 1;
	asi64(R11) = *toi64p(((i64)R11+(i64)R12*8-8));
	asu64(R12) = fnaddr;
	asi64(R1) = ((F11)R12)(asi64(R11), asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L835:
	asu64(R1) = params;
	R2 = 12;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 11;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 10;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 9;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 8;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 7;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 6;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 5;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 4;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 3;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = params;
	R12 = 2;
	asi64(R11) = *toi64p(((i64)R11+(i64)R12*8-8));
	asu64(R12) = params;
	R13 = 1;
	asi64(R12) = *toi64p(((i64)R12+(i64)R13*8-8));
	asu64(R13) = fnaddr;
	asi64(R1) = ((F12)R13)(asi64(R12), asi64(R11), asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L820;
	goto L821;
L823:
	msysc_m$print_startcon();
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("calldll/c/int unsupported # of params");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L821:
	R1 = 0;
	goto L820;
L820:
	return asi64(R1);
}

static i64 mwindllc_calldll_creal(u64 fnaddr, u64 params, i64 nparams) {
    u64 R1, R2, R3, R4, R5; 
	r64 x;
	asi64(R1) = nparams;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L838;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L839;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L840;
	goto L841;
L838:
	asu64(R1) = fnaddr;
	asr64(R1) = ((F13)R1)();
	R1 = toi64(asr64(R1));
	goto L836;
	goto L837;
L839:
	asu64(R1) = params;
	R2 = 4;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = params;
	R3 = 3;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asr64(R2) = tor64(asi64(R2));
	asu64(R3) = params;
	R4 = 2;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asr64(R3) = tor64(asi64(R3));
	asu64(R4) = params;
	R5 = 1;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asr64(R4) = tor64(asi64(R4));
	mwindllc_os_dummycall(asr64(R4), asr64(R3), asr64(R2), asr64(R1));
	asu64(R1) = params;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = fnaddr;
	asr64(R1) = ((F14)R2)(asi64(R1));
	x = asr64(R1);
	goto L837;
L840:
	asu64(R1) = params;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 1;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = fnaddr;
	asr64(R1) = ((F15)R3)(asi64(R2), asi64(R1));
	x = asr64(R1);
	goto L837;
L841:
	msysc_m$print_startcon();
	R1 = tou64("calldll/c/real too many params");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L837:
	asr64(R1) = x;
	asi64(R1) = asi64(R1);
	goto L836;
L836:
	return asi64(R1);
}

static void mwindllc_os_dummycall(r64 a, r64 b, r64 c, r64 d) {
	return;
}

void qq_cli_main() {
    u64 R1, R2, R3; 
	u64 source;
	i64 i;
	i64 nnames;
	i64 t;
	i64 tstart;
	i64 stopcode;
	u64 p;
	qq_cli_start();
	qq_cli_initdata();
	qq_cli_getinputoptions();
	qq_modules_readqabundle();
	qq_cli_loadsyslib();
	R1 = 0;
	asu64(R2) = qq_cli_inputfile;
	qq_cli_compile_sp(asu64(R2), asu64(R1));
	asu8(R1) = qq_cli_fallsp;
	if (!asu8(R1)) goto L845;
	asu8(R1) = qq_cli_fshowast1;
	if (!asu8(R1)) goto L847;
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L847;
	R1 = tou64("AST1");
	R2 = 0;
	qq_show_showast(asu64(R2), asu64(R1));
L847:
	asu8(R1) = qq_cli_fshowast2;
	if (!asu8(R1)) goto L849;
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L849;
	R1 = tou64("AST2");
	R2 = 0;
	qq_show_showast(asu64(R2), asu64(R1));
L849:
L845:
	qq_cli_writeqafile();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nsubprogs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L852;
L850:
	asi64(R1) = i;
	asi64(R2) = qq_decls_nsubprogs;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	R2 = (u64)&qq_decls_subprogs;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = qq_runx_runqprogram(asu64(R2), asi64(R1));
	stopcode = asi64(R1);
	i += 1; if (i <= qq_decls_nsubprogs) goto L850;
L852:
	qq_show_showlogfile();
	asi64(R1) = stopcode;
	exit(R1);
	R1 = 0;
	exit(R1);
	return;
}

static void qq_cli_getinputoptions() {
    u64 R1, R2, R3, R4; 
	i64 paramno;
	i64 pmtype;
	u64 name;
	u64 value;
	u64 appstr;
	u64 appname;
	u64 fnaddr;
	i64 av_1;
	i64 sw;
	R1 = tou64("getbuiltin_app");
	asu64(R1) = mlib_findfunction(asu64(R1));
	fnaddr = asu64(R1);
	R1 = 1;
	paramno = asi64(R1);
	goto L855;
L854:
	asi64(R1) = pmtype;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L858;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L859;
	goto L860;
L858:
	asu64(R1) = name;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	R1 = 1;
	sw = asi64(R1);
	R1 = 23;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L864;
L861:
	R1 = (u64)&qq_decls_optionnames;
	asi64(R2) = sw;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L866;
	asu64(R1) = value;
	asi64(R2) = sw;
	qq_cli_do_option(asi64(R2), asu64(R1));
	goto L863;
L866:
	sw += 1; if (sw <= av_1) goto L861;
L864:
	msysc_m$print_startcon();
	R1 = tou64("Unknown option:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = name;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 99;
	exit(R1);
L863:
	goto L857;
L859:
	asu64(R1) = fnaddr;
	if (!asu64(R1)) goto L868;
	R1 = (u64)&paramno;
	(*toi64p(R1)) -=1;
	goto L856;
L868:
	asu64(R1) = name;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	qq_cli_inputfile = asu64(R1);
	goto L856;
	goto L857;
L860:
L857:
L855:
	R1 = tou64("q");
	R2 = (u64)&value;
	R3 = (u64)&name;
	R4 = (u64)&paramno;
	asi64(R1) = mlib_nextcmdparamnew(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R2 = R1;
	pmtype = asi64(R2);
	if (asi64(R1)) goto L854;
L856:
	asu64(R1) = fnaddr;
	if (!asu64(R1)) goto L870;
	asu64(R1) = fnaddr;
	asu64(R1) = ((F16)R1)();
	appstr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("DO BUILT-IN");
	qq_lib_loaderror(asu64(R2), asu64(R1));
	goto L869;
L870:
	asu64(R1) = qq_cli_inputfile;
	if (asu64(R1)) goto L871;
	msysc_m$print_startcon();
	R1 = tou64("Q7.0 Interpreter");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Usage:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = msysc_cmdparams;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("filename[.q]");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	exit(R1);
L871:
L869:
	asi64(R1) = paramno;
	qq_cli_cmdstartindex = asi64(R1);
	asi64(R1) = msysc_ncmdparams;
	asi64(R2) = qq_cli_cmdstartindex;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = msysc_cmdparams;
	asi64(R3) = qq_cli_cmdstartindex;
	R2 += (i64)R3*8;
	qq_cli_setcli(asu64(R2), asi64(R1));
	return;
}

static void qq_cli_do_option(i64 sw, u64 value) {
    u64 R1, R2; 
	u64 p;
	R1 = (u64)&qq_decls_optionvars;
	asi64(R2) = sw;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L874;
	R1 = (u64)&qq_decls_optionvalues;
	asi64(R2) = sw;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L872;
L874:
L872:
	return;
}

static void qq_cli_compile_sp(u64 filename, u64 source) {
    u64 R1, R2; 
	u64 qafile;
	u64 sp;
	i64 a;
	i64 b;
	i64 m;
	asu64(R1) = source;
	asu64(R2) = filename;
	asu64(R1) = qq_modules_loadsp(asu64(R2), asu64(R1));
	sp = asu64(R1);
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) >= asi64(R2)) goto L877;
	goto L875;
L877:
	asu64(R1) = sp;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	a = asi64(R1);
	asu64(R1) = sp;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	b = asi64(R1);
	asi64(R1) = a;
	m = asi64(R1);
	asi64(R1) = m;
	asi64(R2) = b;
	if (asi64(R1) > asi64(R2)) goto L880;
L878:
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	qq_parse_parsemodule(asu64(R1));
	m += 1; if (m <= b) goto L878;
L880:
	qq_resolve_fixusertypes();
	asu8(R1) = qq_cli_fshowast1;
	if (!asu8(R1)) goto L882;
	asu8(R1) = qq_cli_fallsp;
	if (asu8(R1)) goto L882;
	R1 = tou64("AST1");
	asu64(R2) = sp;
	qq_show_showast(asu64(R2), asu64(R1));
L882:
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) >= asi64(R2)) goto L884;
	goto L875;
L884:
	qq_resolve_tx_typetable();
	asi64(R1) = a;
	m = asi64(R1);
	asi64(R1) = m;
	asi64(R2) = b;
	if (asi64(R1) > asi64(R2)) goto L887;
L885:
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	qq_resolve_rx_module(asu64(R1));
	m += 1; if (m <= b) goto L885;
L887:
	asu8(R1) = qq_cli_fshowast2;
	if (!asu8(R1)) goto L889;
	asu8(R1) = qq_cli_fallsp;
	if (asu8(R1)) goto L889;
	R1 = tou64("AST2");
	asu64(R2) = sp;
	qq_show_showast(asu64(R2), asu64(R1));
L889:
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L891;
	goto L875;
L891:
	asi64(R1) = a;
	m = asi64(R1);
	asi64(R1) = m;
	asi64(R2) = b;
	if (asi64(R1) > asi64(R2)) goto L894;
L892:
	asi64(R1) = m;
	asu64(R2) = sp;
	qq_pclgen_gencodemodule(asu64(R2), asi64(R1));
	m += 1; if (m <= b) goto L892;
L894:
	asu8(R1) = qq_cli_fshowpcl1;
	if (!asu8(R1)) goto L896;
	asu8(R1) = qq_cli_fallsp;
	if (asu8(R1)) goto L896;
	R1 = 1;
	asu64(R2) = sp;
	qq_showpcl_showpcl(asu64(R2), asi64(R1));
L896:
	asu64(R1) = sp;
	qq_cli_fixup_sp(asu64(R1));
	asu8(R1) = qq_cli_fshowpcl2;
	if (!asu8(R1)) goto L898;
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L898;
	asu8(R1) = qq_cli_fallsp;
	if (asu8(R1)) goto L898;
	R1 = 2;
	asu64(R2) = sp;
	qq_showpcl_showpcl(asu64(R2), asi64(R1));
L898:
	qq_cli_resetcompiler();
L875:
	return;
}

static void qq_cli_setcli(u64 cmds, i64 ncmds) {
    u64 R1, R2; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncmds;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L902;
L900:
	asu64(R1) = cmds;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = i;
	qq_cli_setcmdparam(asi64(R2), asu64(R1));
	i += 1; if (i <= ncmds) goto L900;
L902:
	return;
}

static void qq_cli_writeqafile() {
    u64 R1, R2, R3, R4; 
	struct $B15 filename;
	struct $B73 sflist;
	u64 f;
	i64 offset;
	i64 nfiles;
	i64 fileno;
	u64 pm;
	i64 leadmod;
	i64 i;
	asu8(R1) = qq_cli_fwriteqa;
	if (asu8(R1)) goto L905;
	goto L903;
L905:
	R1 = tou64("qa");
	asu64(R2) = qq_cli_inputfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	R2 = (u64)&filename;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	nfiles = asi64(R1);
	R1 = (u64)&qq_decls_subprogs;
	asi64(R2) = qq_decls_nsubprogs;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	leadmod = asi64(R1);
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = leadmod;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&sflist;
	R3 = (u64)&nfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L908;
L906:
	asi64(R1) = i;
	asi64(R2) = leadmod;
	if (asi64(R1) == asi64(R2)) goto L910;
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	asu64(R1) = pm;
	R2 = 41;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L912;
	asu8(R1) = qq_cli_fwriteqa;
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L912;
	goto L907;
L912:
	asu64(R1) = pm;
	R2 = (u64)&sflist;
	R3 = (u64)&nfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L910:
L907:
	i += 1; if (i <= qq_decls_nmodules) goto L906;
L908:
	asi64(R1) = nfiles;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L914;
	R1 = tou64("");
	R2 = tou64("QA:no files");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L914:
	R1 = tou64("wb");
	R2 = (u64)&filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	if (asu64(R1)) goto L916;
	R1 = (u64)&filename;
	R2 = tou64("Can't create qa file #");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L916:
	msysc_m$print_startcon();
	R1 = tou64("Writing ");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("=== QA # ===");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = nfiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L919;
L917:
	R1 = (u64)&sflist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pm = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("=== #.q # # #/# ===");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pm;
	R2 = 41;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = pm;
	R2 = 42;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = nfiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	asi64(R1) = mlib_getfilepos(asu64(R1));
	offset = asi64(R1);
	asu64(R1) = pm;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = offset;
	asu64(R3) = pm;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = f;
	asi64(R1) = mlib_writerandom(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= nfiles) goto L917;
L919:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("=== END ===");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L922;
L920:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("# #.q");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&sflist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= nfiles) goto L920;
L922:
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	R1 = 0;
	exit(R1);
L903:
	return;
}

static void qq_cli_initdata() {
    u64 R1, R2, R3; 
	qq_lex_lexinit();
	R1 = 1;
	R2 = tou64("$prog");
	asu64(R2) = qq_lex_addnamestr(asu64(R2));
	R3 = 0;
	asu64(R1) = qq_names_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	qq_decls_stprogram = asu64(R1);
	mlinux_os_initwindows();
	R1 = 41;
	qq_tables_firstusertype = asi64(R1);
	qq_show_deletetempfiles();
	return;
}

static void qq_cli_loadsyslib() {
    u64 R1, R2; 
	struct $B15 str;
	asu8(R1) = qq_decls_fnosys;
	if (!asu8(R1)) goto L926;
	goto L924;
L926:
	asi64(R1) = mlinux_os_iswindows();
	if (!asi64(R1)) goto L928;
	R1 = tou64("syswin.q");
	qq_cli_syslibname = asu64(R1);
	goto L927;
L928:
	R1 = tou64("syslin.q");
	qq_cli_syslibname = asu64(R1);
L927:
	asu8(R1) = qq_decls_usebundled;
	if (!asu8(R1)) goto L930;
	R1 = 0;
	asu64(R2) = qq_cli_syslibname;
	qq_cli_compile_sp(asu64(R2), asu64(R1));
	goto L929;
L930:
	asi64(R1) = mlinux_os_iswindows();
	if (!asi64(R1)) goto L932;
	R1 = tou64("c:/qx/");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L931;
L932:
	R1 = tou64("./");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L931:
	asu64(R1) = qq_cli_syslibname;
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	qq_cli_compile_sp(asu64(R2), asu64(R1));
L929:
L924:
	return;
}

static void qq_cli_resetcompiler() {
    u64 R1, R2; 
	u64 userxmodelist;
	R1 = 0;
	qq_tables_nuserxtypes = asi64(R1);
	R1 = 0;
	qq_tables_userxtypebase = asi64(R1);
	R1 = 0;
	userxmodelist = asu64(R1);
	R1 = (u64)&qq_tables_ttxmap;
	memset(R1, 0, 40000);
	asi64(R1) = qq_tables_ntypes;
	R2 = 1;
	asi64(R1) += asi64(R2);
	qq_tables_firstusertype = asi64(R1);
	return;
}

static void qq_cli_setcmdparam(i64 index, u64 s) {
    u64 R1, R2, R3; 
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L936;
	asi64(R1) = index;
	qq_decls_nqparams = asi64(R1);
	goto L935;
L936:
	asi64(R1) = index;
	R2 = 32;
	if (asi64(R1) > asi64(R2)) goto L937;
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&qq_decls_qparamtable;
	asi64(R3) = index;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = index;
	R2 = (u64)&qq_decls_nqparams;
    *toi64p(R2) = Max(*toi64p(R2), asi64(R1));
L937:
L935:
	return;
}

static void qq_cli_fixup_sp(u64 sp) {
    u64 R1, R2; 
	i64 av_1;
	i64 i;
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) >= asi64(R2)) goto L940;
	goto L938;
L940:
	asu64(R1) = sp;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	i = asi64(R1);
	asu64(R1) = sp;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	av_1 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_1;
	if (asi64(R1) > asi64(R2)) goto L943;
L941:
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	qq_cli_fixupmodule(asu64(R1));
	asu8(R1) = qq_cli_foptimise;
	if (!asu8(R1)) goto L945;
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	qq_cli_optimise_module(asu64(R1));
L945:
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	qq_runx_fixupcode(asu64(R1));
	i += 1; if (i <= av_1) goto L941;
L943:
L938:
	return;
}

static void qq_cli_fixproc(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = d;
	R2 = 127;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L948;
	asu64(R1) = qq_cli_allprocdefs;
	asu64(R2) = d;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	qq_cli_allprocdefs = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 127;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L948:
	return;
}

static void qq_cli_fixupmodule(u64 pm) {
    u64 R1, R2, R3; 
	u64 pc;
	u64 pcstart;
	i64 cmd;
	i64 index;
	u64 d;
	u64 p;
	asu64(R1) = pm;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	pcstart = asu64(R2);
	pc = asu64(R1);
L950:
	asu64(R1) = pc;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cmd = asi64(R1);
	asi64(R1) = cmd;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L954;
	goto L955;
L954:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_cli_fixproc(asu64(R1));
	goto L953;
L955:
L953:
	R1 = (u64)&qq_pcltabs_pclopnd;
	asi64(R2) = cmd;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L957;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L958;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L959;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L960;
	goto L961;
L957:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	qq_cli_fixproc(asu64(R1));
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L956;
L958:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L963;
	asu64(R1) = d;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = pc;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	R2 = 8;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	goto L962;
L963:
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L965;
	asu64(R1) = qq_cli_allstaticdefs;
	asu64(R2) = d;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	qq_cli_allstaticdefs = asu64(R1);
	R1 = 16;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = d;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L965:
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L962:
	goto L956;
L959:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 104;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	index = asi64(R1);
	asi64(R1) = index;
	asu64(R2) = pc;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L956;
L960:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_strings_obj_make_string(asu64(R2), asi64(R1));
	asu64(R2) = pc;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L956;
L961:
L956:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asi64(R1) = cmd;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L950;
	return;
}

static void qq_cli_optimise_module(u64 pm) {
    u64 R1, R2, R3; 
	u64 pc;
	asu64(R1) = pm;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
L967:
	asu64(R1) = pc;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L970;
	goto L968;
L970:
	asu64(R1) = pc;
	asu64(R1) = qq_cli_optim(asu64(R1));
	pc = asu64(R1);
	goto L967;
L968:
	asu64(R1) = pm;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L974;
L971:
	R1 = (u64)&qq_decls_pclcounts;
	asu64(R2) = pc;
	R3 = 8;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R1 += (i64)R2*8;
	(*toi64p(R1)) += 1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L974:
	asu64(R1) = pc;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L971;
	return;
}

static u64 qq_cli_optim(u64 pc) {
    u64 R1, R2, R3; 
	i64 skip;
	i64 index;
	u64 g;
	u64 pcdest;
	u8 cmd;
	u8 newcmd;
	u8 abc;
	u8 aux;
	i64 i;
	asu64(R1) = pc;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	newcmd = asu8(R2);
	cmd = asu8(R1);
	R1 = 0;
	skip = asi64(R1);
	asu8(R1) = cmd;
	R1 = toi64(tou8(R1));
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L978;
	asu8(R1) = cmd;
	R1 = toi64(tou8(R1));
	R2 = 34;
	if (asi64(R1) < asi64(R2)) goto L979;
	R2 = 39;
	if (asi64(R1) <= asi64(R2)) goto L978;
L979:
	asu8(R1) = cmd;
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L980;
	R2 = 33;
	if (asi64(R1) != asi64(R2)) goto L977;
L980:
L978:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcdest = asu64(R1);
	asu64(R1) = pcdest;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 30;
	if (asi64(R1) != asi64(R2)) goto L982;
L983:
	asu64(R1) = pcdest;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcdest = asu64(R1);
	asu64(R1) = pcdest;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L983;
	asu64(R1) = pcdest;
	asu64(R2) = pc;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L982:
L977:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L987;
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	goto L975;
L987:
	R1 = 1;
	abc = asu8(R1);
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L989;
	R1 = 0;
	abc = asu8(R1);
L989:
	asu8(R1) = cmd;
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L991;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L992;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L993;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L994;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L995;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L996;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L997;
	goto L998;
L991:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1000;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1001;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L1002;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L1003;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L1004;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L1005;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L1006;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L1007;
	R2 = 89;
	if (asi64(R1) == asi64(R2)) goto L1008;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L1009;
	goto L1010;
L1000:
	asu8(R1) = abc;
	if (asu8(R1)) goto L1012;
	goto L1013;
L1012:
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1015;
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L1016;
	R2 = 102;
	if (asi64(R1) == asi64(R2)) goto L1017;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L1018;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L1019;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L1020;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L1021;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L1022;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L1023;
	R2 = 130;
	if (asi64(R1) == asi64(R2)) goto L1024;
	goto L1025;
L1015:
	R1 = 143;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1014;
L1016:
	R1 = 174;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1014;
L1017:
	R1 = 2;
	skip = asi64(R1);
	goto L1014;
L1018:
	R1 = 166;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1014;
L1019:
	R1 = 167;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1014;
L1020:
	R1 = 168;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1014;
L1021:
	R1 = 169;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1014;
L1022:
	R1 = 170;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1014;
L1023:
	R1 = 171;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1014;
L1024:
	R1 = 188;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1014;
L1025:
// qq_cli.optim.dopushff:
L1013:
	R1 = 144;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
L1014:
	goto L999;
L1001:
	goto L999;
L1002:
	asu8(R1) = abc;
	if (asu8(R1)) goto L1027;
	goto L1028;
L1027:
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L1030;
	R2 = 102;
	if (asi64(R1) == asi64(R2)) goto L1031;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L1032;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L1033;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L1034;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L1035;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L1036;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L1037;
	goto L1038;
L1030:
	R1 = 172;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1029;
L1031:
	R1 = 173;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1029;
L1032:
	R1 = 162;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1029;
L1033:
	R1 = 163;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1029;
L1034:
	R1 = 164;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1029;
L1035:
	R1 = 165;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1029;
L1036:
	R1 = 160;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1029;
L1037:
	R1 = 161;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1029;
L1038:
// qq_cli.optim.dopushfci:
L1028:
	R1 = 149;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
L1029:
	goto L999;
L1003:
	R1 = 1;
	skip = asi64(R1);
	goto L999;
L1004:
	R1 = 150;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
	goto L999;
L1005:
	R1 = 1;
	skip = asi64(R1);
	goto L999;
L1006:
	R1 = 1;
	skip = asi64(R1);
	goto L999;
L1007:
	R1 = 1;
	skip = asi64(R1);
	goto L999;
L1008:
	R1 = 1;
	skip = asi64(R1);
	goto L999;
L1009:
	R1 = 190;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
	goto L999;
L1010:
L999:
	goto L990;
L992:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1040;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L1041;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L1042;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L1043;
	goto L1044;
L1040:
	asu8(R1) = abc;
	if (!asu8(R1)) goto L1046;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 130;
	if (asi64(R1) != asi64(R2)) goto L1046;
	R1 = 187;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1045;
L1046:
	R1 = 1;
	skip = asi64(R1);
L1045:
	goto L1039;
L1041:
	R1 = 1;
	skip = asi64(R1);
	goto L1039;
L1042:
	R1 = 1;
	skip = asi64(R1);
	goto L1039;
L1043:
	R1 = 148;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
	goto L1039;
L1044:
L1039:
	goto L990;
L993:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L1048;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L1049;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L1050;
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L1051;
	R2 = 102;
	if (asi64(R1) == asi64(R2)) goto L1052;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L1053;
	R2 = 111;
	if (asi64(R1) == asi64(R2)) goto L1054;
	R2 = 112;
	if (asi64(R1) == asi64(R2)) goto L1055;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L1056;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L1057;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1058;
	goto L1059;
L1048:
	R1 = 1;
	skip = asi64(R1);
	goto L1047;
L1049:
	R1 = 155;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
	goto L1047;
L1050:
	R1 = 1;
	skip = asi64(R1);
	goto L1047;
L1051:
	R1 = 176;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
	goto L1047;
L1052:
	R1 = 177;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
	goto L1047;
L1053:
	R1 = 178;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
	goto L1047;
L1054:
	R1 = 179;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
	goto L1047;
L1055:
	R1 = 180;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
	goto L1047;
L1056:
	R1 = 199;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
	goto L1047;
L1057:
	R1 = 200;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
	goto L1047;
L1058:
	asu8(R1) = abc;
	if (!asu8(R1)) goto L1061;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 122;
	if (asi64(R1) != asi64(R2)) goto L1061;
	R1 = (u64)&qq_pcltabs_bintotable;
	asu64(R2) = pc;
	R3 = 2;
	R2 += (i64)R3*32;
	R3 = 16;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R1 += (i64)R2*24-24;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L1063;
	R2 = 102;
	if (asi64(R1) == asi64(R2)) goto L1064;
	R2 = 111;
	if (asi64(R1) == asi64(R2)) goto L1065;
	R2 = 112;
	if (asi64(R1) == asi64(R2)) goto L1066;
	goto L1067;
L1063:
	R1 = 183;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1062;
L1064:
	R1 = 184;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1062;
L1065:
	R1 = 185;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1062;
L1066:
	R1 = 186;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1062;
L1067:
L1062:
L1061:
	goto L1047;
L1059:
L1047:
	goto L990;
L994:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L1069;
	goto L1070;
L1069:
	asu8(R1) = abc;
	if (!asu8(R1)) goto L1072;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L1072;
	R1 = 2;
	skip = asi64(R1);
	goto L1071;
L1072:
	R1 = 1;
	skip = asi64(R1);
L1071:
	goto L1068;
L1070:
L1068:
	goto L990;
L995:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L1074;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1075;
	goto L1076;
L1074:
	asu8(R1) = abc;
	if (!asu8(R1)) goto L1078;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L1080;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L1081;
	goto L1082;
L1080:
	R1 = 192;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1079;
L1081:
	R1 = 194;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1079;
L1082:
L1079:
L1078:
	goto L1073;
L1075:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 16;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1084;
	R1 = 182;
	newcmd = asu8(R1);
	goto L1083;
L1084:
	R1 = 181;
	newcmd = asu8(R1);
L1083:
	R1 = 1;
	skip = asi64(R1);
	goto L1073;
L1076:
L1073:
	goto L990;
L996:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L1086;
	goto L1087;
L1086:
	asu8(R1) = abc;
	if (!asu8(R1)) goto L1089;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L1091;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L1092;
	goto L1093;
L1091:
	R1 = 191;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1090;
L1092:
	R1 = 193;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1090;
L1093:
L1090:
L1089:
	goto L1085;
L1087:
L1085:
	goto L990;
L997:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1095;
	goto L1096;
L1095:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L1098;
	R1 = 198;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
L1098:
	goto L1094;
L1096:
L1094:
	goto L990;
L998:
L990:
// qq_cli.optim.finish:
	asu8(R1) = newcmd;
	asu64(R2) = pc;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = skip;
	if (!asi64(R1)) goto L1101;
	asu8(R1) = newcmd;
	R1 = toi64(tou8(R1));
	asu8(R2) = cmd;
	R2 = toi64(tou8(R2));
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	aux = asu8(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = skip;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1104;
L1102:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu8(R1) = aux;
	R1 = tou64(tou8(R1));
	asu64(R2) = pc;
	R3 = 11;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	i += 1; if (i <= skip) goto L1102;
L1104:
L1101:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	goto L975;
L975:
	return asu64(R1);
}

static void qq_arrays_var_empty_array(i64 tag, i64 elemtype, i64 lower, u64 dest) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = lower;
	asi64(R3) = elemtype;
	asu64(R1) = qq_arrays_obj_newarray(asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = tag;
	R2 = 256;
	asi64(R1) |= asi64(R2);
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	return;
}

static void qq_arrays_obj_free_array(u64 p) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L1108;
	asu64(R1) = p;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_tables_ttsize;
	asu64(R3) = p;
	R4 = 6;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L1108:
	asu64(R1) = p;
	mlib_pcm_free32(asu64(R1));
	return;
}

static void qq_arrays_obj_free_vector(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L1111;
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L1111:
	asu64(R1) = p;
	mlib_pcm_free32(asu64(R1));
	return;
}

static void qq_arrays_var_make_array(u64 a, u64 dest, i64 lower, i64 n, i64 axtype, i64 elemtype) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	i64 m;
	i64 av_1;
	asi64(R1) = axtype;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1114;
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = axtype;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	m = asi64(R1);
	asi64(R1) = n;
	asi64(R2) = m;
	if (asi64(R1) == asi64(R2)) goto L1116;
	msysc_m$print_startcon();
	R1 = tou64("N=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("M=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = m;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("Too few/too many elements");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1116:
	goto L1113;
L1114:
	asi64(R1) = n;
	if (!asi64(R1)) goto L1117;
	asi64(R1) = elemtype;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1119;
	asu64(R1) = a;
	asi64(R2) = n;
	R1 += (i64)R2*16;
	R2 = 1;
	R1 -= (i64)R2*16;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1121;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1122;
	goto L1123;
L1121:
	R1 = 26;
	elemtype = asi64(R1);
	goto L1120;
L1122:
	R1 = 32;
	elemtype = asi64(R1);
	goto L1120;
L1123:
	R1 = 26;
	elemtype = asi64(R1);
L1120:
L1119:
	goto L1113;
L1117:
	asi64(R1) = elemtype;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1124;
	R1 = 26;
	elemtype = asi64(R1);
L1124:
L1113:
	asi64(R1) = n;
	asi64(R2) = lower;
	asi64(R3) = elemtype;
	asu64(R1) = qq_arrays_obj_newarray(asi64(R3), asi64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1127;
L1125:
	asi64(R1) = elemtype;
	asu64(R2) = a;
	asu64(R3) = q;
	qq_packed_var_storepacked(asu64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = elemtype;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&q;
	*tou64p(R2) += asu64(R1);
	R1 = (u64)&a;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L1125;
L1127:
	asi64(R1) = axtype;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1129;
	R1 = 267;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L1128;
L1129:
	R1 = 263;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = axtype;
	asu64(R2) = p;
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
L1128:
	asu64(R1) = p;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 qq_arrays_obj_newarray(i64 elemtype, i64 lower, i64 length) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	i64 elemsize;
	asu64(R1) = qq_vars_obj_new();
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = lower;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1132;
	R2 = 1;
	if (asi64(R1) > asi64(R2)) goto L1132;
	asi64(R1) = lower;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L1131;
L1132:
	R1 = tou64("");
	R2 = tou64("Lwb not 0/1");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1131:
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = elemtype;
	asu64(R2) = p;
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = elemtype;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	elemsize = asi64(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L1134;
	asi64(R1) = length;
	asi64(R2) = elemsize;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asi64(R2) = elemsize;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L1134:
	asu64(R1) = p;
	goto L1130;
L1130:
	return asu64(R1);
}

static u64 qq_arrays_obj_newarray_u(i64 usertag) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	i64 elemsize;
	asu64(R1) = qq_vars_obj_new();
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = usertag;
	asu64(R2) = p;
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = (u64)&qq_tables_ttsize;
	R2 = (u64)&qq_tables_tttarget;
	asi64(R3) = usertag;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	elemsize = asi64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = usertag;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L1137;
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = usertag;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asi64(R2) = elemsize;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L1137:
	asu64(R1) = p;
	goto L1135;
L1135:
	return asu64(R1);
}

static void qq_arrays_var_getix_array(u64 a, i64 index) {
    u64 R1, R2, R3, R4, R5, R6, R7; struct $B3 R1_B3; 
	struct $B3 v;
	u64 p;
	i64 elemtype;
	i64 length;
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	v = (R1_B3);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = (u64)&v;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L1140;
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	length = asi64(R1);
	R1 = (u64)&qq_tables_ttlower;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&index;
	*toi64p(R2) -= asi64(R1);
	R1 = (u64)&qq_tables_tttarget;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemtype = asi64(R1);
	goto L1139;
L1140:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = (u64)&index;
	*toi64p(R2) -= asi64(R1);
L1139:
	asi64(R1) = index;
	asi64(R2) = length;
	if (asu64(R1) < asu64(R2)) goto L1142;
	R1 = tou64("");
	R2 = tou64("ax[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1142:
	asi64(R1) = elemtype;
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L1144;
	R1 = 1;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = index;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L1143;
L1144:
	R1 = 0;
	asu64(R2) = a;
	asi64(R3) = elemtype;
	asu64(R4) = p;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asi64(R5) = index;
	R6 = (u64)&qq_tables_ttsize;
	asi64(R7) = elemtype;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8));
	asi64(R5) *= asi64(R6);
	R4 += (i64)R5;
	qq_packed_var_loadpacked(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
L1143:
	return;
}

static void qq_arrays_var_putix_array(u64 a, i64 index, u64 x) {
    u64 R1, R2, R3, R4, R5, R6; struct $B3 R1_B3; 
	struct $B3 v;
	u64 p;
	i64 elemtype;
	i64 length;
	i64 lower;
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	v = (R1_B3);
	R1 = (u64)&v;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = (u64)&v;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L1147;
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	length = asi64(R1);
	R1 = (u64)&qq_tables_ttlower;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	lower = asi64(R1);
	R1 = (u64)&qq_tables_tttarget;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemtype = asi64(R1);
	goto L1146;
L1147:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	lower = asi64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
L1146:
	asi64(R1) = lower;
	R2 = (u64)&index;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = index;
	asi64(R2) = length;
	if (asu64(R1) < asu64(R2)) goto L1149;
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L1151;
	R1 = tou64("");
	R2 = tou64("lwb");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L1150;
L1151:
	asi64(R1) = index;
	asi64(R2) = length;
	if (asi64(R1) != asi64(R2)) goto L1152;
	R1 = (u64)&v;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L1154;
	R1 = tou64("");
	R2 = tou64("Can't append user type");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1154:
	asu64(R1) = x;
	asu64(R2) = p;
	qq_arrays_obj_append_array(asu64(R2), asu64(R1));
	goto L1150;
L1152:
	R1 = tou64("");
	R2 = tou64("ax[i]:=x bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1150:
L1149:
	asi64(R1) = elemtype;
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L1156;
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1158;
	R1 = tou64("");
	R2 = tou64("rhs not int");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1158:
	R1 = 1;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = index;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1155;
L1156:
	asi64(R1) = elemtype;
	asu64(R2) = x;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R4) = index;
	R5 = (u64)&qq_tables_ttsize;
	asi64(R6) = elemtype;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8));
	asi64(R4) *= asi64(R5);
	R3 += (i64)R4;
	qq_packed_var_storepacked(asu64(R3), asu64(R2), asi64(R1));
L1155:
	return;
}

static void qq_arrays_var_getixref_array(u64 a, i64 index) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	struct $B3 v;
	u64 p;
	i64 elemtype;
	i64 length;
	i64 lower;
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	v = (R1_B3);
	R1 = (u64)&v;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = (u64)&v;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L1161;
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	length = asi64(R1);
	R1 = (u64)&qq_tables_ttlower;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	lower = asi64(R1);
	R1 = (u64)&qq_tables_tttarget;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemtype = asi64(R1);
	goto L1160;
L1161:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	lower = asi64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
L1160:
	asi64(R1) = lower;
	R2 = (u64)&index;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = index;
	asi64(R2) = length;
	if (asu64(R1) < asu64(R2)) goto L1163;
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L1165;
	R1 = tou64("");
	R2 = tou64("lwb");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L1164;
L1165:
	asi64(R1) = index;
	asi64(R2) = length;
	if (asu64(R1) != asu64(R2)) goto L1167;
	R1 = tou64("");
	R2 = tou64("PUTIXREF NEEDS IAPPEND");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L1166;
L1167:
	R1 = tou64("");
	R2 = tou64("ax[i]:=x bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1166:
L1164:
L1163:
	R1 = 16;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = elemtype;
	asu64(R2) = a;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = index;
	R3 = (u64)&qq_tables_ttsize;
	asi64(R4) = elemtype;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8));
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_arrays_obj_append_array(u64 a, u64 x) {
    u64 R1, R2, R3, R4, R5; 
	i64 n;
	u64 q;
	asu64(R1) = a;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1170;
	R1 = tou64("");
	R2 = tou64("Can't extend slice");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1170:
	asu64(R1) = a;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L1172;
	qq_lib_pcnotmut();
L1172:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = a;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L1174;
	asi64(R1) = n;
	asu64(R2) = a;
	qq_arrays_obj_resize_array(asu64(R2), asi64(R1));
	goto L1173;
L1174:
	asi64(R1) = n;
	asu64(R2) = a;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L1173:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = n;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	R3 = (u64)&qq_tables_ttsize;
	asu64(R4) = a;
	R5 = 6;
	asu16(R4) = *tou16p(((i64)R4+(i64)R5));
	R4 = toi64(tou16(R4));
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8));
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	q = asu64(R1);
	asu64(R1) = a;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = x;
	asu64(R3) = q;
	qq_packed_var_storepacked(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_arrays_var_appendto_array(u64 a, u64 x) {
    u64 R1, R2, R3; 
	asu64(R1) = x;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_arrays_obj_append_array(asu64(R2), asu64(R1));
	return;
}

static void qq_arrays_obj_resize_array(u64 p, i64 n) {
    u64 R1, R2, R3; 
	u64 q;
	i64 elemsize;
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	elemsize = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L1178;
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L1177;
L1178:
	asi64(R1) = n;
	asi64(R2) = elemsize;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L1180;
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = elemsize;
	asu64(R1) *= asu64(R2);
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = elemsize;
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L1180:
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mlib_allocbytes;
	asi64(R2) = elemsize;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L1177:
	return;
}

static void qq_arrays_var_dupl_array(u64 a) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	i64 elemsize;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 4;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 0;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	asu64(R3) = p;
	R4 = 6;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	asu64(R1) = qq_arrays_obj_newarray(asi64(R3), asi64(R2), asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L1183;
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_tables_ttsize;
	asu64(R3) = p;
	R4 = 6;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asu64(R1) *= asu64(R2);
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = q;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L1183:
	return;
}

static void qq_arrays_var_dupl_vector(u64 a) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	i64 elemsize;
	i64 length;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	length = asi64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R1) = qq_arrays_obj_newarray_u(asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L1186;
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = q;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L1186:
	return;
}

static i64 qq_arrays_var_equal_array(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	i64 length;
	i64 elemsize;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemsize = asi64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = q;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	if (asi64(R1) == asi64(R2)) goto L1189;
	R1 = 0;
	goto L1187;
L1189:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asi64(R1) = length;
	asu64(R2) = q;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) == asi64(R2)) goto L1191;
	R1 = 0;
	goto L1187;
L1191:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1193;
	R1 = 1;
	goto L1187;
L1193:
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asi64(R2) = length;
	asi64(R1) *= asi64(R2);
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R1) = mlib_eqbytes(asu64(R3), asu64(R2), asi64(R1));
	goto L1187;
L1187:
	return asi64(R1);
}

static void qq_arrays_var_concatto_array(u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 d;
	i64 n;
	i64 alen;
	i64 blen;
	i64 newlen;
	i64 oldbytes;
	i64 newbytes;
	i64 elemsize;
	u64 v;
	u64 pa;
	u64 pb;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pb = asu64(R1);
	asu64(R1) = pa;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L1196;
	qq_lib_pcnotmut();
L1196:
	asu64(R1) = pa;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = pb;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	if (asi64(R1) == asi64(R2)) goto L1198;
	R1 = tou64("");
	R2 = tou64("concat/not compat");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1198:
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = pa;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	elemsize = asi64(R1);
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	alen = asi64(R1);
	asu64(R1) = pb;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	blen = asi64(R1);
	asi64(R1) = alen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1200;
	asi64(R1) = blen;
	if (!asi64(R1)) goto L1202;
	asi64(R1) = blen;
	asu64(R2) = pa;
	qq_arrays_obj_resize_array(asu64(R2), asi64(R1));
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = blen;
	asi64(R2) = elemsize;
	asu64(R1) *= asu64(R2);
	asu64(R2) = pb;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = d;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L1202:
	goto L1199;
L1200:
	asi64(R1) = blen;
	if (!asi64(R1)) goto L1203;
	asi64(R1) = alen;
	asi64(R2) = blen;
	asi64(R1) += asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	asu64(R2) = pa;
	qq_arrays_obj_resize_array(asu64(R2), asi64(R1));
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = alen;
	asi64(R3) = elemsize;
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	d = asu64(R1);
	asi64(R1) = blen;
	asi64(R2) = elemsize;
	asu64(R1) *= asu64(R2);
	asu64(R2) = pb;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = d;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L1203:
L1199:
	return;
}

static void qq_arrays_var_getslice_array(u64 a, i64 i, i64 j) {
    u64 R1, R2, R3; 
	i64 alower;
	i64 elemsize;
	u64 p;
	u64 q;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	alower = asi64(R1);
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	elemsize = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = alower;
	if (asi64(R1) < asi64(R2)) goto L1207;
	asi64(R1) = j;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R3) = alower;
	asi64(R2) += asi64(R3);
	R3 = 1;
	asi64(R2) -= asi64(R3);
	if (asi64(R1) > asi64(R2)) goto L1207;
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) <= asi64(R2)) goto L1206;
L1207:
	R1 = tou64("");
	R2 = tou64("array/slice bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1206:
	asu64(R1) = qq_vars_obj_new();
	q = asu64(R1);
	R1 = 1;
	asu64(R2) = q;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = q;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 1;
	asu64(R2) = q;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asi64(R3) = alower;
	asi64(R2) -= asi64(R3);
	asi64(R3) = elemsize;
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = p;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1209;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1210;
	goto L1211;
L1209:
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_vars_obj_shareu(asu64(R1));
	goto L1208;
L1210:
	R1 = 0;
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2;
	asu64(R2) = q;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1208;
L1211:
	asu64(R1) = p;
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	(*tou32p(R1)) += 1;
L1208:
	asi64(R1) = j;
	asi64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = q;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static i64 qq_arrays_u8inarray(u8 a, u64 p) {
    u64 R1, R2; 
	i64 i;
	u64 q;
	i64 av_1;
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	i = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1215;
L1213:
	asu64(R1) = q;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	asu8(R2) = a;
	R2 = toi64(tou8(R2));
	if (asi64(R1) != asi64(R2)) goto L1217;
	asi64(R1) = i;
	goto L1212;
L1217:
	R1 = (u64)&q;
	(*tou64p(R1)) += 1;
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	if (--asi64(av_1)) goto L1213;
L1215:
	R1 = 0x8000000000000000;
	goto L1212;
L1212:
	return asi64(R1);
}

static i64 qq_arrays_u16inarray(u16 a, u64 p) {
    u64 R1, R2; 
	i64 i;
	u64 q;
	i64 av_1;
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	i = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1221;
L1219:
	asu64(R1) = q;
	asu16(R1) = *tou16p(R1);
	R1 = toi64(tou16(R1));
	asu16(R2) = a;
	R2 = toi64(tou16(R2));
	if (asi64(R1) != asi64(R2)) goto L1223;
	asi64(R1) = i;
	goto L1218;
L1223:
	R1 = (u64)&q;
	(*tou64p(R1)) += 2;
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	if (--asi64(av_1)) goto L1219;
L1221:
	R1 = 0x8000000000000000;
	goto L1218;
L1218:
	return asi64(R1);
}

static i64 qq_arrays_u32inarray(u32 a, u64 p) {
    u64 R1, R2; 
	i64 i;
	u64 q;
	i64 av_1;
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	i = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1227;
L1225:
	asu64(R1) = q;
	asu32(R1) = *tou32p(R1);
	R1 = toi64(tou32(R1));
	asu32(R2) = a;
	R2 = toi64(tou32(R2));
	if (asi64(R1) != asi64(R2)) goto L1229;
	asi64(R1) = i;
	goto L1224;
L1229:
	R1 = (u64)&q;
	(*tou64p(R1)) += 4;
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	if (--asi64(av_1)) goto L1225;
L1227:
	R1 = 0x8000000000000000;
	goto L1224;
L1224:
	return asi64(R1);
}

static i64 qq_arrays_u64inarray(u64 a, u64 p) {
    u64 R1, R2; 
	i64 i;
	u64 q;
	i64 av_1;
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	i = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1233;
L1231:
	asu64(R1) = q;
	asu64(R1) = *tou64p(R1);
	asu64(R2) = a;
	if (asu64(R1) != asu64(R2)) goto L1235;
	asi64(R1) = i;
	goto L1230;
L1235:
	R1 = (u64)&q;
	(*tou64p(R1)) += 8;
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	if (--asi64(av_1)) goto L1231;
L1233:
	R1 = 0x8000000000000000;
	goto L1230;
L1230:
	return asi64(R1);
}

static i64 qq_arrays_var_inx_array(u64 a, u64 b, i64 usertag) {
    u64 R1, R2, R3; 
	i64 n;
	u64 q;
	i64 elemtag;
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asi64(R1) = usertag;
	if (!asi64(R1)) goto L1238;
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = usertag;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemtag = asi64(R1);
	goto L1237;
L1238:
	asu64(R1) = q;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtag = asi64(R1);
L1237:
	asi64(R1) = elemtag;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L1240;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L1240;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L1241;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L1241;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L1242;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L1242;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L1243;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L1243;
	goto L1244;
L1240:
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_arrays_u8inarray(asu8(R2), asu64(R1));
	n = asi64(R1);
	goto L1239;
L1241:
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_arrays_u16inarray(asu16(R2), asu64(R1));
	n = asi64(R1);
	goto L1239;
L1242:
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_arrays_u32inarray(asu32(R2), asu64(R1));
	n = asi64(R1);
	goto L1239;
L1243:
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_arrays_u64inarray(asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L1239;
L1244:
	asu64(R1) = b;
	R2 = tou64("x in array");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L1239:
	asi64(R1) = n;
	goto L1236;
L1236:
	return asi64(R1);
}

static void qq_arrays_var_expand_array(u64 p, u64 dest, i64 m) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 i;
	i64 n;
	i64 elemtype;
	i64 length;
	u64 pa;
	i64 av_1;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1247;
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asu64(R1) = pa;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	goto L1246;
L1247:
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = pa;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	length = asi64(R1);
	R1 = (u64)&qq_tables_tttarget;
	asu64(R2) = pa;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemtype = asi64(R1);
L1246:
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = 1;
	n = asi64(R1);
	asi64(R1) = m;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1250;
L1248:
	asi64(R1) = n;
	asi64(R2) = length;
	if (asi64(R1) <= asi64(R2)) goto L1252;
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L1251;
L1252:
	R1 = 0;
	asu64(R2) = dest;
	asi64(R3) = elemtype;
	asu64(R4) = q;
	qq_packed_var_loadpacked(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = elemtype;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&q;
	*tou64p(R2) += asu64(R1);
L1251:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	R1 = (u64)&dest;
	(*tou64p(R1)) -=16;
	if (--asi64(av_1)) goto L1248;
L1250:
	return;
}

static void qq_bits_obj_free_bits(u64 p, i64 tag) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L1255;
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_bits_getbitssize(asi64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L1255:
	asu64(R1) = p;
	mlib_pcm_free32(asu64(R1));
	return;
}

static void qq_bits_var_make_bits(u64 a, u64 dest, i64 lower, i64 n, i64 bxtype, i64 elemtype) {
    u64 R1, R2, R3, R4, R5; 
	u64 p;
	u64 q;
	i64 bitwidthx;
	i64 offset;
	i64 av_1;
	asi64(R1) = n;
	asi64(R2) = lower;
	asi64(R3) = elemtype;
	asu64(R1) = qq_bits_obj_newbits(asi64(R3), asi64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = (u64)&qq_tables_ttbitwidth;
	asi64(R2) = elemtype;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	bitwidthx = asi64(R1);
	R1 = 0;
	offset = asi64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1259;
L1257:
	asi64(R1) = bitwidthx;
	asi64(R2) = elemtype;
	asu64(R3) = a;
	asi64(R4) = offset;
	asu64(R5) = q;
	qq_vars_var_storebit(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = bitwidthx;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = offset;
	R2 = 8;
	if (asi64(R1) < asi64(R2)) goto L1261;
	R1 = (u64)&q;
	(*tou64p(R1)) += 1;
	R1 = 0;
	offset = asi64(R1);
L1261:
	R1 = (u64)&a;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L1257;
L1259:
	asi64(R1) = bxtype;
	R2 = 256;
	asi64(R1) |= asi64(R2);
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 qq_bits_obj_newbits(i64 elemtype, i64 lower, i64 length) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	i64 nbits;
	i64 bitwidthx;
	i64 nbytes;
	asu64(R1) = qq_vars_obj_new();
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = lower;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = elemtype;
	asu64(R2) = p;
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L1264;
	asi64(R1) = elemtype;
	asi64(R2) = length;
	asi64(R1) = qq_bits_getbitssize(asi64(R2), asi64(R1));
	nbytes = asi64(R1);
	asi64(R1) = nbytes;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = 8;
	R3 = (u64)&qq_tables_ttbitwidth;
	asi64(R4) = elemtype;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
   if (asi64(R3) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R2) /= asi64(R3);
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L1264:
	asu64(R1) = p;
	goto L1262;
L1262:
	return asu64(R1);
}

static void qq_bits_var_getix_bits(u64 a, i64 index) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	i64 elemtype;
	i64 offset;
	i64 shift;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = (u64)&index;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = index;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L1267;
	R1 = tou64("");
	R2 = tou64("ax[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1267:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&index;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L1269;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L1270;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L1271;
	goto L1272;
L1269:
	asu64(R1) = q;
	asi64(R2) = index;
	R3 = 3;
	asi64(R2) >>= asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R3) = index;
	R4 = 7;
	asi64(R3) &= asi64(R4);
	asi64(R2) <<= asi64(R3);
	asi64(R1) &= asi64(R2);
	asi64(R1) = !!asi64(R1);
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L1268;
L1270:
	asi64(R1) = index;
	R2 = 3;
	asi64(R1) &= asi64(R2);
	R2 = 2;
	asi64(R1) *= asi64(R2);
	shift = asi64(R1);
	asu64(R1) = q;
	asi64(R2) = index;
	R3 = 2;
	asi64(R2) >>= asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R1) &= asi64(R2);
	asi64(R2) = shift;
	asi64(R1) >>= asi64(R2);
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L1268;
L1271:
	asi64(R1) = index;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	R2 = 4;
	asi64(R1) *= asi64(R2);
	shift = asi64(R1);
	asu64(R1) = q;
	asi64(R2) = index;
	R3 = 1;
	asi64(R2) >>= asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R1) &= asi64(R2);
	asi64(R2) = shift;
	asi64(R1) >>= asi64(R2);
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L1268;
L1272:
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = tou64("bitix");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L1268:
	return;
}

static void qq_bits_var_putix_bits(u64 a, i64 index, u64 x) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 p;
	u64 q;
	i64 elemtype;
	i64 newoffset;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = (u64)&index;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = index;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L1275;
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L1277;
	R1 = tou64("");
	R2 = tou64("lwb");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L1276;
L1277:
	asi64(R1) = index;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L1278;
	asu64(R1) = x;
	asu64(R2) = p;
	qq_bits_obj_append_bits(asu64(R2), asu64(R1));
	goto L1276;
L1278:
	R1 = tou64("");
	R2 = tou64("bx[i]:=x bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1276:
L1275:
	R1 = (u64)&newoffset;
	asi64(R2) = elemtype;
	asi64(R3) = index;
	asu64(R4) = p;
	R5 = 7;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R5) = p;
	R6 = 8;
	asu64(R5) = *tou64p(((i64)R5+(i64)R6));
	asu64(R1) = qq_bits_getindexoffset(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	q = asu64(R1);
	R1 = 0;
	asi64(R2) = elemtype;
	asu64(R3) = x;
	asi64(R4) = newoffset;
	R5 = (u64)&qq_tables_ttbitwidth;
	asi64(R6) = elemtype;
	asu8(R5) = *tou8p(((i64)R5+(i64)R6));
	R5 = toi64(tou8(R5));
	asi64(R4) *= asi64(R5);
	asu64(R5) = q;
	qq_vars_var_storebit(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void qq_bits_var_getixref_bits(u64 a, i64 index) {
    u64 R1, R2, R3, R4, R5, R6; 
	struct $B3 v;
	u64 p;
	u64 q;
	i64 offset;
	i64 newoffset;
	i64 elemtype;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = (u64)&index;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = index;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L1281;
	R1 = tou64("");
	R2 = tou64("&bx[i] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1281:
	R1 = (u64)&newoffset;
	asi64(R2) = elemtype;
	asi64(R3) = index;
	asu64(R4) = p;
	R5 = 7;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R5) = p;
	R6 = 8;
	asu64(R5) = *tou64p(((i64)R5+(i64)R6));
	asu64(R1) = qq_bits_getindexoffset(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	q = asu64(R1);
	R1 = 15;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = elemtype;
	asu64(R2) = a;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = newoffset;
	R2 = (u64)&qq_tables_ttbitwidth;
	asi64(R3) = elemtype;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) *= asi64(R2);
	asu64(R2) = a;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static u64 qq_bits_getindexoffset(u64 p, i64 offset, i64 index, i64 t, u64 newoffset) {
    u64 R1, R2; 
	asi64(R1) = offset;
	R2 = (u64)&index;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = t;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L1284;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L1285;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L1286;
	goto L1287;
L1284:
	asi64(R1) = index;
	R2 = 3;
	asi64(R1) >>= asi64(R2);
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = index;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	asu64(R2) = newoffset;
	*toi64p(R2) = asi64(R1);
	goto L1283;
L1285:
	asi64(R1) = index;
	R2 = 2;
	asi64(R1) >>= asi64(R2);
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = index;
	R2 = 3;
	asi64(R1) &= asi64(R2);
	asu64(R2) = newoffset;
	*toi64p(R2) = asi64(R1);
	goto L1283;
L1286:
	asi64(R1) = offset;
	R2 = 2;
	asi64(R1) >>= asi64(R2);
	R2 = (u64)&index;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = index;
	R2 = 1;
	asi64(R1) >>= asi64(R2);
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = index;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	asu64(R2) = newoffset;
	*toi64p(R2) = asi64(R1);
	goto L1283;
L1287:
L1283:
	asu64(R1) = p;
	goto L1282;
L1282:
	return asu64(R1);
}

static void qq_bits_obj_append_bits(u64 a, u64 x) {
    u64 R1, R2, R3, R4, R5, R6; 
	i64 n;
	i64 newoffset;
	i64 elemtype;
	u64 q;
	asu64(R1) = a;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1290;
	R1 = tou64("");
	R2 = tou64("Can't extend slice");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1290:
	asu64(R1) = a;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L1292;
	qq_lib_pcnotmut();
L1292:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asu64(R1) = a;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = a;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L1294;
	asi64(R1) = n;
	asu64(R2) = a;
	qq_bits_obj_resize_bits(asu64(R2), asi64(R1));
	goto L1293;
L1294:
	asi64(R1) = n;
	asu64(R2) = a;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L1293:
	R1 = (u64)&newoffset;
	asi64(R2) = elemtype;
	asi64(R3) = n;
	asu64(R4) = a;
	R5 = 4;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 0;
    asi64(R4) = Getdotindex(asu64(R4), asi64(R5));
	asi64(R3) -= asi64(R4);
	asu64(R4) = a;
	R5 = 7;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R5) = a;
	R6 = 8;
	asu64(R5) = *tou64p(((i64)R5+(i64)R6));
	asu64(R1) = qq_bits_getindexoffset(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	q = asu64(R1);
	R1 = 0;
	asi64(R2) = elemtype;
	asu64(R3) = x;
	asi64(R4) = newoffset;
	R5 = (u64)&qq_tables_ttbitwidth;
	asi64(R6) = elemtype;
	asu8(R5) = *tou8p(((i64)R5+(i64)R6));
	R5 = toi64(tou8(R5));
	asi64(R4) *= asi64(R5);
	asu64(R5) = q;
	qq_vars_var_storebit(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void qq_bits_var_appendto_bits(u64 a, u64 x) {
    u64 R1, R2, R3; 
	asu64(R1) = x;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_bits_obj_append_bits(asu64(R2), asu64(R1));
	return;
}

static void qq_bits_obj_resize_bits(u64 p, i64 n) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 newsize;
	i64 elemtype;
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L1298;
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L1297;
L1298:
	asi64(R1) = elemtype;
	asi64(R2) = n;
	asi64(R1) = qq_bits_getbitssize(asi64(R2), asi64(R1));
	newsize = asi64(R1);
	asi64(R1) = newsize;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L1300;
	asu64(R1) = p;
	asu64(R1) = qq_bits_bits_bytesize(asu64(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = elemtype;
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_bits_getbitssize(asi64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L1300:
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = 8;
	R3 = (u64)&qq_tables_ttbitwidth;
	asi64(R4) = elemtype;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
   if (asi64(R3) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R2) /= asi64(R3);
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L1297:
	return;
}

static void qq_bits_var_dupl_bits(u64 a) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	i64 elemsize;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 4;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 0;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	asu64(R3) = p;
	R4 = 6;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	asu64(R1) = qq_bits_obj_newbits(asi64(R3), asi64(R2), asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L1303;
	asu64(R1) = p;
	asu64(R1) = qq_bits_bits_bytesize(asu64(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = q;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L1303:
	return;
}

static i64 qq_bits_var_equal_bits(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	i64 length;
	i64 elemsize;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemsize = asi64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = q;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	if (asi64(R1) == asi64(R2)) goto L1306;
	R1 = 0;
	goto L1304;
L1306:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asi64(R1) = length;
	asu64(R2) = q;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) == asi64(R2)) goto L1308;
	R1 = 0;
	goto L1304;
L1308:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1310;
	R1 = 1;
	goto L1304;
L1310:
	asu64(R1) = p;
	asi64(R1) = qq_bits_bits_bytesize(asu64(R1));
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R1) = mlib_eqbytes(asu64(R3), asu64(R2), asi64(R1));
	goto L1304;
L1304:
	return asi64(R1);
}

static void qq_bits_var_concatto_bits(u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 d;
	i64 n;
	i64 alen;
	i64 blen;
	i64 newlen;
	i64 oldbytes;
	i64 newbytes;
	i64 elemsize;
	u64 v;
	u64 pa;
	u64 pb;
	R1 = tou64("var_concatto_bits");
	R2 = tou64("VAR/BITS/NOT READY");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pb = asu64(R1);
	asu64(R1) = pa;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L1313;
	qq_lib_pcnotmut();
L1313:
	asu64(R1) = pa;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = pb;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	if (asi64(R1) == asi64(R2)) goto L1315;
	R1 = tou64("");
	R2 = tou64("concat/not compat");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1315:
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = pa;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	elemsize = asi64(R1);
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	alen = asi64(R1);
	asu64(R1) = pb;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	blen = asi64(R1);
	asi64(R1) = alen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1317;
	asi64(R1) = blen;
	if (!asi64(R1)) goto L1319;
	asi64(R1) = blen;
	asu64(R2) = pa;
	qq_bits_obj_resize_bits(asu64(R2), asi64(R1));
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = blen;
	asi64(R2) = elemsize;
	asu64(R1) *= asu64(R2);
	asu64(R2) = pb;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = d;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L1319:
	goto L1316;
L1317:
	asi64(R1) = blen;
	if (!asi64(R1)) goto L1320;
	asi64(R1) = alen;
	asi64(R2) = blen;
	asi64(R1) += asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	asu64(R2) = pa;
	qq_bits_obj_resize_bits(asu64(R2), asi64(R1));
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = alen;
	asi64(R3) = elemsize;
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	d = asu64(R1);
	asi64(R1) = blen;
	asi64(R2) = elemsize;
	asu64(R1) *= asu64(R2);
	asu64(R2) = pb;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = d;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L1320:
L1316:
	return;
}

static void qq_bits_var_getslice_bits(u64 a, i64 i, i64 j) {
    u64 R1, R2, R3, R4, R5, R6; 
	i64 alower;
	i64 elemtype;
	i64 newoffset;
	u64 p;
	u64 q;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	alower = asi64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = alower;
	if (asi64(R1) < asi64(R2)) goto L1324;
	asi64(R1) = j;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R3) = alower;
	asi64(R2) += asi64(R3);
	R3 = 1;
	asi64(R2) -= asi64(R3);
	if (asi64(R1) > asi64(R2)) goto L1324;
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) <= asi64(R2)) goto L1323;
L1324:
	R1 = tou64("");
	R2 = tou64("bits/slice bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1323:
	asu64(R1) = qq_vars_obj_new();
	q = asu64(R1);
	R1 = 1;
	asu64(R2) = q;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = q;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 1;
	asu64(R2) = q;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = elemtype;
	asu64(R2) = q;
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = (u64)&newoffset;
	asi64(R2) = elemtype;
	asi64(R3) = i;
	asi64(R4) = alower;
	asi64(R3) -= asi64(R4);
	asu64(R4) = p;
	R5 = 7;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R5) = p;
	R6 = 8;
	asu64(R5) = *tou64p(((i64)R5+(i64)R6));
	asu64(R1) = qq_bits_getindexoffset(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = newoffset;
	asu64(R2) = q;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1326;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1327;
	goto L1328;
L1326:
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_vars_obj_shareu(asu64(R1));
	goto L1325;
L1327:
	R1 = 0;
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2;
	asu64(R2) = q;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1325;
L1328:
	asu64(R1) = p;
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	(*tou32p(R1)) += 1;
L1325:
	asi64(R1) = j;
	asi64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = q;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static i64 qq_bits_bits_bytesize(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_bits_getbitssize(asi64(R2), asi64(R1));
	goto L1329;
L1329:
	return asi64(R1);
}

static i64 qq_bits_getbitssize(i64 n, i64 t) {
    u64 R1, R2, R3; 
	i64 nbits;
	asi64(R1) = n;
	R2 = (u64)&qq_tables_ttbitwidth;
	asi64(R3) = t;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) *= asi64(R2);
	nbits = asi64(R1);
	asi64(R1) = nbits;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = 64;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) *= asi64(R2);
	goto L1330;
L1330:
	return asi64(R1);
}

static void qq_calldll_calldll(u64 d, u64 args, u64 result, i64 nargs) {
    u64 R1, R2, R3, R4, R5; 
	u64 e;
	struct $B27 arglist;
	i64 n;
	i64 retcode;
	i64 retval;
	i64 fnindex;
	i64 libindex;
	u64 dllinst;
	u64 fnaddr;
	u64 name;
	i64 i;
	asi64(R1) = nargs;
	R2 = 100;
	if (asi64(R1) <= asi64(R2)) goto L1333;
	R1 = tou64("");
	R2 = tou64("Too many dll args");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1333:
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nargs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1336;
L1334:
	asu64(R1) = e;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1338;
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 8;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L1340;
	R1 = 0;
	asu64(R2) = args;
	asi64(R1) = qq_calldll_vartopacked(asu64(R2), asu64(R1));
	R2 = (u64)&arglist;
	asi64(R3) = i;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&args;
	(*tou64p(R1)) += 16;
	goto L1339;
L1340:
	R1 = tou64("");
	R2 = tou64("Too many dll args");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1339:
	goto L1337;
L1338:
	asu64(R1) = e;
	asu64(R2) = args;
	asi64(R1) = qq_calldll_vartopacked(asu64(R2), asu64(R1));
	R2 = (u64)&arglist;
	asi64(R3) = i;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&args;
	(*tou64p(R1)) += 16;
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1337:
	i += 1; if (i <= nargs) goto L1334;
L1336:
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 32;
	if (asi64(R1) != asi64(R2)) goto L1342;
	R1 = 82;
	retcode = asi64(R1);
	goto L1341;
L1342:
	R1 = 73;
	retcode = asi64(R1);
L1341:
	asu64(R1) = d;
	asu64(R1) = qq_calldll_getlibprocaddr(asu64(R1));
	fnaddr = asu64(R1);
	R1 = 0;
	R2 = (u64)&arglist;
	asi64(R3) = nargs;
	asi64(R4) = retcode;
	asu64(R5) = fnaddr;
	asi64(R1) = mwindllc_os_calldllfunction(asu64(R5), asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	retval = asi64(R1);
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L1345;
	asu64(R1) = result;
	asu64(R2) = d;
	R3 = 116;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asi64(R3) = retval;
	qq_calldll_packedtovar(asu64(R3), asi64(R2), asu64(R1));
L1345:
	return;
}

static u64 qq_calldll_getlibprocaddr(u64 d) {
    u64 R1, R2, R3; 
	u64 fnaddr;
	R1 = (u64)&qq_decls_dllprocaddr;
	asu64(R2) = d;
	R3 = 96;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	fnaddr = asu64(R1);
	asu64(R1) = fnaddr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1348;
	asu64(R1) = d;
	asu64(R1) = qq_calldll_loaddllfunction(asu64(R1));
	fnaddr = asu64(R1);
L1348:
	asu64(R1) = fnaddr;
	goto L1346;
L1346:
	return asu64(R1);
}

static u64 qq_calldll_vartopacked(u64 p, u64 d) {
    u64 R1, R2, R3; 
	i64 s;
	i64 t;
	u64 a;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	s = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1351;
	asi64(R1) = s;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L1353;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1354;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1354;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L1354;
	goto L1355;
L1353:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_lib_convtostringz(asu64(R2), asi64(R1));
	goto L1349;
	goto L1352;
L1354:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L1349;
	goto L1352;
L1355:
	R1 = tou64("");
	R2 = tou64("Bad variadic param");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1352:
L1351:
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L1357;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L1357;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L1357;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L1357;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L1357;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L1357;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L1358;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L1359;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L1360;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L1361;
	goto L1362;
L1357:
	asi64(R1) = s;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1364;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L1364;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L1364;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1365;
	goto L1366;
L1364:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L1349;
	goto L1363;
L1365:
	asu64(R1) = p;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = tou64(asr64(R1));
	goto L1349;
	goto L1363;
L1366:
// qq_calldll.vartopacked.error:
L1367:
	msysc_m$print_startcon();
	R1 = tou64("'#' should be '#' (param # #)");
	msysc_m$print_setfmt(asu64(R1));
	R1 = 1;
	asi64(R2) = s;
	asu64(R1) = qq_show_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asi64(R2) = t;
	asu64(R1) = qq_show_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("DLL: wrong param type");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1363:
	goto L1356;
L1358:
	asi64(R1) = s;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1369;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1370;
	goto L1371;
L1369:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R1) = asu64(R1);
	goto L1349;
	goto L1368;
L1370:
	asu64(R1) = p;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R1) = asu64(R1);
	goto L1349;
	goto L1368;
L1371:
	goto L1367;
L1368:
	goto L1356;
L1359:
	asi64(R1) = s;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L1373;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L1374;
	goto L1375;
L1373:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_lib_convtostringz(asu64(R2), asi64(R1));
	goto L1349;
	goto L1372;
L1374:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L1349;
	goto L1372;
L1375:
	goto L1367;
L1372:
	goto L1356;
L1360:
	asi64(R1) = s;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L1377;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1378;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1378;
	goto L1379;
L1377:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L1349;
	goto L1376;
L1378:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L1349;
	goto L1376;
L1379:
	goto L1367;
L1376:
	goto L1356;
L1361:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	R1 += (i64)R2;
	goto L1349;
	goto L1356;
L1362:
	asi64(R1) = t;
	asi64(R2) = s;
	R3 = tou64("DLL params:");
	qq_runaux_pcmxtypestt(asu64(R3), asi64(R2), asi64(R1));
L1356:
	R1 = 0;
	goto L1349;
L1349:
	return asu64(R1);
}

static void qq_calldll_packedtovar(u64 retval, i64 t, u64 dest) {
    u64 R1, R2, R3; 
	i64 tbase;
	u64 a;
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	tbase = asi64(R1);
	asi64(R1) = tbase;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1382;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L1383;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L1384;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L1385;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L1385;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L1386;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L1387;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L1388;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L1389;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L1390;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L1391;
	goto L1392;
L1382:
	goto L1381;
L1383:
	R1 = 2;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = retval;
	asr64(R1) = asr64(R1);
	asu64(R2) = dest;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L1381;
L1384:
	R1 = tou64("");
	R2 = tou64("dll/r32ret");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L1381;
L1385:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = retval;
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L1381;
L1386:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = retval;
	asi64(R1) = toi64(toi32(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L1381;
L1387:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = retval;
	asi64(R1) = toi64(tou32(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L1381;
L1388:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = retval;
	asi64(R1) = toi64(toi16(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L1381;
L1389:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = retval;
	asi64(R1) = toi64(tou16(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L1381;
L1390:
	R1 = 16;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = retval;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R2) = dest;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L1381;
L1391:
	asu64(R1) = retval;
	if (!asu64(R1)) goto L1394;
	R1 = 0;
	asu64(R2) = dest;
	asu64(R3) = retval;
	qq_strings_var_make_string(asu64(R3), asu64(R2), asi64(R1));
	goto L1393;
L1394:
	R1 = 0;
	asu64(R2) = dest;
	R3 = tou64("");
	qq_strings_var_make_string(asu64(R3), asu64(R2), asi64(R1));
L1393:
	goto L1381;
L1392:
	R1 = (u64)&qq_tables_ttname;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("Rettype not supported:");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1381:
	return;
}

static u64 qq_calldll_loaddllfunction(u64 d) {
    u64 R1, R2, R3; 
	i64 fnindex;
	i64 libindex;
	u64 dllinst;
	u64 fnaddr;
	u64 name;
	asu64(R1) = d;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	fnindex = asi64(R1);
	R1 = (u64)&qq_decls_dllprocaddr;
	asi64(R2) = fnindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	fnaddr = asu64(R1);
	asu64(R1) = fnaddr;
	if (!asu64(R1)) goto L1397;
	asu64(R1) = fnaddr;
	goto L1395;
L1397:
	R1 = (u64)&qq_decls_dllproclibindex;
	asi64(R2) = fnindex;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	libindex = asi64(R1);
	R1 = (u64)&qq_decls_dllinsttable;
	asi64(R2) = libindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	dllinst = asu64(R1);
	asu64(R1) = dllinst;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1399;
	R1 = (u64)&qq_decls_libtable;
	asi64(R2) = libindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mlinux_os_getdllinst(asu64(R1));
	dllinst = asu64(R1);
	asu64(R1) = dllinst;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1401;
	R1 = (u64)&qq_decls_libtable;
	asi64(R2) = libindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't load DLL:");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1401:
	asu64(R1) = dllinst;
	R2 = (u64)&qq_decls_dllinsttable;
	asi64(R3) = libindex;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L1399:
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L1403;
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L1402;
L1403:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L1402:
	name = asu64(R1);
	asu64(R1) = name;
	asu64(R2) = dllinst;
	asu64(R1) = mlinux_os_getdllprocaddr(asi64(R2), asu64(R1));
	fnaddr = asu64(R1);
	asu64(R1) = fnaddr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1405;
	asu64(R1) = name;
	R2 = tou64("Can't find DLL func:");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1405:
	asu64(R1) = fnaddr;
	R2 = (u64)&qq_decls_dllprocaddr;
	asi64(R3) = fnindex;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = fnaddr;
	goto L1395;
L1395:
	return asu64(R1);
}

static void qq_decimal_obj_free_dec(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L1408;
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4;
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L1408:
	asu64(R1) = p;
	mlib_pcm_free32(asu64(R1));
	return;
}

static void qq_decimal_var_dupl_dec(u64 a) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	i64 size;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = qq_vars_obj_new();
	p = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = q;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = q;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 26;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4;
	asi64(R1) *= asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	if (!asi64(R1)) goto L1411;
	asi64(R1) = size;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = size;
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L1411:
	asu64(R1) = p;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_decimal_var_empty_dec(u64 dest) {
    u64 R1, R2, R3; 
	R1 = 259;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R1) = qq_decimal_makebignum(asi64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_decimal_var_make_dec_str(u64 s, i64 length, u64 dest) {
    u64 R1, R2, R3; 
	R1 = 259;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R1) = qq_decimal_bn_makestr(asu64(R2), asi64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_decimal_var_make_dec_int(i64 a, u64 dest) {
    u64 R1, R2, R3; 
	R1 = 259;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = a;
	asu64(R1) = qq_decimal_bn_makeint(asi64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 qq_decimal_badnumber() {
    u64 R1, R2, R3; 
	u64 c;
	R1 = 0;
	asu64(R1) = qq_decimal_makebignum(asi64(R1));
	c = asu64(R1);
	R1 = 3;
	asu64(R2) = c;
	R3 = 26;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = c;
	goto L1415;
L1415:
	return asu64(R1);
}

static u64 qq_decimal_bn_makestr(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 t;
	u64 u;
	u64 oldt;
	i64 tlength;
	i64 neg;
	i64 dpindex;
	i64 expon;
	i64 nonzeros;
	i64 talloc;
	i64 dpseen;
	i64 leadingzeros;
	i64 trailingzeros;
	i64 zerosafterdp;
	i64 d;
	i64 n;
	i64 wd;
	i64 dp;
	i64 wdp;
	i64 w;
	i64 d2;
	i64 na;
	i64 nb;
	i64 c;
	u64 a;
	i64 av_1;
	i64 av_2;
	i64 i;
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1418;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L1418:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L1420;
	asu64(R1) = qq_decimal_badnumber();
	goto L1416;
L1420:
	asi64(R1) = length;
	R2 = 1;
	asu64(R1) += asu64(R2);
	asu64(R1) = malloc(asu64(R1));
	t = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = t;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = t;
	oldt = asu64(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	tlength = asi64(R1);
	asu64(R1) = t;
	s = asu64(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 10;
	asi64(R1) += asi64(R2);
	talloc = asi64(R1);
	R1 = 0;
	neg = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) == asu64(R2)) goto L1422;
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L1423;
	goto L1424;
L1422:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L1421;
L1423:
	R1 = 1;
	neg = asi64(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L1421;
L1424:
L1421:
	asi64(R1) = talloc;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	u = asu64(R2);
	t = asu64(R1);
	R1 = -1;
	dpindex = asi64(R1);
	R1 = 0;
	R2 = R1;
	zerosafterdp = asi64(R2);
	dpseen = asi64(R1);
	R1 = 0;
	nonzeros = asi64(R1);
	R1 = 0;
	R2 = R1;
	trailingzeros = asi64(R2);
	leadingzeros = asi64(R1);
	R1 = 0;
	expon = asi64(R1);
L1425:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 49;
	if (asi64(R1) < asi64(R2)) goto L1428;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L1428;
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R2 = (u64)&u;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	trailingzeros = asi64(R1);
	R1 = 1;
	nonzeros = asi64(R1);
	goto L1427;
L1428:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L1430;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L1431;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L1431;
	R2 = 96;
	if (asi64(R1) == asi64(R2)) goto L1431;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L1431;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L1431;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1431;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L1432;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1433;
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L1434;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L1434;
	goto L1435;
L1430:
	asi64(R1) = nonzeros;
	if (!asi64(R1)) goto L1437;
	R1 = (u64)&trailingzeros;
	(*toi64p(R1)) += 1;
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R2 = (u64)&u;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1436;
L1437:
	R1 = (u64)&leadingzeros;
	(*toi64p(R1)) += 1;
	asi64(R1) = dpseen;
	if (!asi64(R1)) goto L1439;
	R1 = (u64)&zerosafterdp;
	(*toi64p(R1)) += 1;
L1439:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L1436:
	goto L1429;
L1431:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L1429;
L1432:
	asi64(R1) = dpseen;
	if (asi64(R1)) goto L1442;
	asi64(R1) = dpindex;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1441;
L1442:
	asu64(R1) = qq_decimal_badnumber();
	goto L1416;
L1441:
	asi64(R1) = nonzeros;
	if (!asi64(R1)) goto L1444;
	asu64(R1) = u;
	asu64(R2) = t;
	asi64(R1) -= asi64(R2);
	dpindex = asi64(R1);
	goto L1443;
L1444:
	R1 = 1;
	dpseen = asi64(R1);
L1443:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L1429;
L1433:
	goto L1426;
	goto L1429;
L1434:
	asu64(R1) = s;
	R2 = 1;
	R1 += (i64)R2;
	asi64(R1) = qq_decimal_readexpon(asu64(R1));
	expon = asi64(R1);
	goto L1426;
	goto L1429;
L1435:
	asu64(R1) = qq_decimal_badnumber();
	goto L1416;
L1429:
L1427:
	goto L1425;
L1426:
	R1 = 0;
	asu64(R2) = u;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = u;
	asu64(R2) = t;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = dpindex;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L1446;
	asi64(R1) = dpseen;
	if (!asi64(R1)) goto L1448;
	asi64(R1) = zerosafterdp;
	asi64(R1) = -asi64(R1);
	dpindex = asi64(R1);
	goto L1447;
L1448:
	asi64(R1) = length;
	dpindex = asi64(R1);
L1447:
L1446:
	asi64(R1) = trailingzeros;
	R2 = (u64)&length;
	*toi64p(R2) -= asi64(R1);
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1450;
	R1 = 0;
	asu64(R1) = qq_decimal_bn_makeint(asi64(R1));
	goto L1416;
L1450:
	asi64(R1) = dpindex;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R2) = expon;
	asi64(R1) += asi64(R2);
	d = asi64(R1);
	asi64(R1) = length;
	n = asi64(R1);
	R1 = 0;
	dp = asi64(R1);
	R1 = 1;
	na = asi64(R1);
	asi64(R1) = n;
	asi64(R2) = na;
	asi64(R1) -= asi64(R2);
	nb = asi64(R1);
	R1 = 9;
	w = asi64(R1);
	asi64(R1) = d;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1452;
	asi64(R1) = d;
	asi64(R2) = w;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	wd = asi64(R1);
	asi64(R1) = d;
	asi64(R2) = w;
	asi64(R1) %= asi64(R2);
	wdp = asi64(R1);
	goto L1451;
L1452:
	asi64(R1) = d;
	R2 = 1;
	asi64(R1) += asi64(R2);
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	d2 = asi64(R1);
	asi64(R1) = d2;
	asi64(R2) = w;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R1) = -asi64(R1);
	wd = asi64(R1);
	asi64(R1) = w;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R2) = d2;
	asi64(R3) = w;
	asi64(R2) %= asi64(R3);
	asi64(R1) -= asi64(R2);
	wdp = asi64(R1);
L1451:
	asi64(R1) = wdp;
	R2 = 1;
	asi64(R1) += asi64(R2);
	na = asi64(R1);
	asi64(R1) = n;
	asi64(R2) = na;
	asi64(R1) -= asi64(R2);
	R2 = 0;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	nb = asi64(R1);
	goto L1454;
L1453:
	R1 = (u64)&nb;
	(*toi64p(R1)) += 1;
L1454:
	asi64(R1) = nb;
	asi64(R2) = w;
	asi64(R1) %= asi64(R2);
	if (asi64(R1)) goto L1453;
	asi64(R1) = nb;
	asi64(R2) = w;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	length = asi64(R1);
	asu64(R1) = t;
	asi64(R2) = n;
	R1 += (i64)R2;
	u = asu64(R1);
	asi64(R1) = na;
	asi64(R2) = nb;
	asi64(R1) += asi64(R2);
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1458;
L1456:
	R1 = 48;
	R2 = (u64)&u;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	if (--asi64(av_1)) goto L1456;
L1458:
	asi64(R1) = na;
	asi64(R2) = nb;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = length;
	asu64(R1) = qq_decimal_makebignum(asi64(R1));
	a = asu64(R1);
	asi64(R1) = neg;
	asu64(R2) = a;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = wd;
	asu64(R2) = a;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = t;
	u = asu64(R1);
	asi64(R1) = na;
	asu64(R2) = u;
	asi64(R1) = qq_decimal_strvaln(asu64(R2), asi64(R1));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = na;
	R2 = (u64)&u;
	*tou64p(R2) += asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1461;
L1459:
	asi64(R1) = w;
	asu64(R2) = u;
	asi64(R1) = qq_decimal_strvaln(asu64(R2), asi64(R1));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = w;
	R2 = (u64)&u;
	*tou64p(R2) += asu64(R1);
	i += 1; if (i <= av_2) goto L1459;
L1461:
	asi64(R1) = talloc;
	asu64(R2) = t;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = oldt;
	free(asu64(R1));
	asu64(R1) = a;
	goto L1416;
L1416:
	return asu64(R1);
}

static i64 qq_decimal_readexpon(u64 s) {
    u64 R1, R2, R3; 
	i64 neg;
	i64 expon;
	i64 c;
	R1 = 0;
	R2 = R1;
	expon = asi64(R2);
	neg = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) == asu64(R2)) goto L1464;
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L1465;
	goto L1466;
L1464:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L1463;
L1465:
	R1 = 1;
	neg = asi64(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L1463;
L1466:
L1463:
L1467:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L1470;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L1470;
	asi64(R1) = expon;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asu64(R2) = s;
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	R3 = 48;
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	expon = asi64(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L1469;
L1470:
	asi64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L1472;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L1472;
	R2 = 96;
	if (asi64(R1) == asi64(R2)) goto L1472;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L1472;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1473;
	goto L1474;
L1472:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L1471;
L1473:
	goto L1468;
	goto L1471;
L1474:
	R1 = tou64("");
	R2 = tou64("make expon?");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1471:
L1469:
	goto L1467;
L1468:
	asi64(R1) = neg;
	if (!asi64(R1)) goto L1476;
	asi64(R1) = expon;
	asi64(R1) = -asi64(R1);
	goto L1475;
L1476:
	asi64(R1) = expon;
L1475:
	goto L1462;
L1462:
	return asi64(R1);
}

static u64 qq_decimal_bn_makeint(i64 x) {
    u64 R1, R2, R3; 
	u64 a;
	struct $B16 str;
	asi64(R1) = x;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1479;
	R1 = 0;
	asu64(R1) = qq_decimal_makebignum(asi64(R1));
	a = asu64(R1);
	goto L1478;
L1479:
	asi64(R1) = x;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1480;
	R2 = 999999999;
	if (asi64(R1) > asi64(R2)) goto L1480;
	R1 = 1;
	asu64(R1) = qq_decimal_makebignum(asi64(R1));
	a = asu64(R1);
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	goto L1478;
L1480:
	asi64(R1) = x;
	asi64(R1) = -asi64(R1);
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1481;
	R2 = 999999999;
	if (asi64(R1) > asi64(R2)) goto L1481;
	R1 = 1;
	asu64(R1) = qq_decimal_makebignum(asi64(R1));
	a = asu64(R1);
	asi64(R1) = x;
	asi64(R1) = -asi64(R1);
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L1478;
L1481:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asi64(R1) = x;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = (u64)&str;
	asu64(R1) = qq_decimal_bn_makestr(asu64(R2), asi64(R1));
	a = asu64(R1);
L1478:
	asu64(R1) = a;
	goto L1477;
L1477:
	return asu64(R1);
}

static u64 qq_decimal_var_tostr_dec(u64 a, i64 fmt) {
    u64 R1, R2, R3; 
	asi64(R1) = fmt;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_decimal_obj_tostr_dec(asu64(R2), asi64(R1));
	goto L1482;
L1482:
	return asu64(R1);
}

static u64 qq_decimal_obj_tostr_dec(u64 a, i64 fmt) {
    u64 R1, R2, R3; 
	i64 expon;
	i64 upper;
	u64 s;
	u64 t;
	R1 = 0;
	t = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1485;
	R1 = tou64("<void>");
	t = asu64(R1);
	goto L1484;
L1485:
	asu64(R1) = a;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1487;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1488;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1489;
	goto L1490;
L1487:
	asi64(R1) = fmt;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L1493;
	asi64(R1) = fmt;
	R2 = 70;
	if (asi64(R1) != asi64(R2)) goto L1492;
L1493:
	R1 = tou64("0.0");
	goto L1491;
L1492:
	R1 = tou64("0");
L1491:
	t = asu64(R1);
	goto L1486;
L1488:
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L1495;
	R1 = tou64("-Infinity");
	goto L1494;
L1495:
	R1 = tou64("Infinity");
L1494:
	t = asu64(R1);
	goto L1486;
L1489:
	R1 = tou64("<NaN>");
	t = asu64(R1);
	goto L1486;
L1490:
L1486:
L1484:
	asu64(R1) = t;
	if (!asu64(R1)) goto L1497;
	asu64(R1) = t;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = R1;
	qq_decimal_decstrsize = asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	s = asu64(R1);
	asu64(R1) = t;
	asu64(R2) = s;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = s;
	goto L1483;
L1497:
	asi64(R1) = fmt;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1500;
	asi64(R1) = fmt;
	R2 = 65;
	if (asi64(R1) != asi64(R2)) goto L1499;
L1500:
	asu64(R1) = a;
	asi64(R1) = qq_decimal_bn_isint(asu64(R1));
	if (!asi64(R1)) goto L1502;
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = 9;
	asi64(R1) *= asi64(R2);
	R2 = 60;
	if (asi64(R1) >= asi64(R2)) goto L1502;
	R1 = 73;
	fmt = asi64(R1);
	goto L1501;
L1502:
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 9;
	asi64(R1) *= asi64(R2);
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	R2 = 60;
	if (asi64(R1) >= asi64(R2)) goto L1503;
	R1 = 70;
	fmt = asi64(R1);
	goto L1501;
L1503:
	R1 = 69;
	fmt = asi64(R1);
L1501:
L1499:
	asi64(R1) = fmt;
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L1505;
	asu64(R1) = a;
	asu64(R1) = qq_decimal_tostring_scient(asu64(R1));
	s = asu64(R1);
	goto L1504;
L1505:
	asi64(R1) = fmt;
	asu64(R2) = a;
	asu64(R1) = qq_decimal_tostring_float(asu64(R2), asi64(R1));
	s = asu64(R1);
L1504:
	asu64(R1) = s;
	goto L1483;
L1483:
	return asu64(R1);
}

static u64 qq_decimal_tostring_scient(u64 a) {
    u64 R1, R2, R3, R4; 
	u64 s;
	u64 t;
	i64 expon;
	i64 nchars;
	i64 n;
	i64 shift;
	i64 x;
	i64 scale;
	i64 av_1;
	i64 i;
	R1 = 3;
	nchars = asi64(R1);
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 9;
	asi64(R1) *= asi64(R2);
	expon = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	x = asi64(R1);
	R1 = 1;
	scale = asi64(R1);
	R1 = 0;
	shift = asi64(R1);
	goto L1508;
L1507:
	asi64(R1) = x;
	R2 = 10;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	x = asi64(R1);
	R1 = 10;
	R2 = (u64)&scale;
	*toi64p(R2) *= asi64(R1);
	R1 = (u64)&expon;
	(*toi64p(R1)) += 1;
	R1 = (u64)&shift;
	(*toi64p(R1)) += 1;
L1508:
	asi64(R1) = x;
	R2 = 10;
	if (asi64(R1) >= asi64(R2)) goto L1507;
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 9;
	asi64(R1) *= asi64(R2);
	R2 = 16;
	asi64(R1) += asi64(R2);
	nchars = asi64(R1);
	asi64(R1) = nchars;
	R2 = R1;
	qq_decimal_decstrsize = asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	t = asu64(R2);
	s = asu64(R1);
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L1511;
	R1 = 45;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L1511:
	asu64(R1) = t;
	msysc_m$print_startstr(asu64(R1));
	asi64(R1) = x;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = t;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = shift;
	if (!asi64(R1)) goto L1513;
	asu64(R1) = t;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("v");
	asi64(R2) = shift;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("z*");
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R3) = x;
	asi64(R4) = scale;
	asi64(R3) *= asi64(R4);
	asi64(R2) -= asi64(R3);
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = t;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
L1513:
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1516;
L1514:
	asu64(R1) = t;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("z9");
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = t;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	i += 1; if (i <= av_1) goto L1514;
L1516:
	goto L1518;
L1517:
	R1 = (u64)&t;
	(*tou64p(R1)) -=1;
L1518:
	asu64(R1) = t;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) != asu64(R2)) goto L1520;
	asu64(R1) = t;
	R2 = 2;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L1517;
L1520:
	asu64(R1) = t;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("e");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = expon;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	asu64(R1) = t;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = s;
	goto L1506;
L1506:
	return asu64(R1);
}

static u64 qq_decimal_tostring_float(u64 a, i64 fmt) {
    u64 R1, R2, R3; 
	i64 expon;
	i64 upper;
	i64 nchars;
	i64 w;
	i64 prel;
	i64 n;
	i64 showdot;
	u64 s;
	u64 t;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 av_4;
	i64 i;
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	expon = asi64(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	upper = asi64(R1);
	asi64(R1) = fmt;
	R2 = 73;
	if (asi64(R1) != asi64(R2)) goto L1523;
	asu64(R1) = a;
	asi64(R1) = qq_decimal_bn_isint(asu64(R1));
	if (!asi64(R1)) goto L1523;
	R1 = 0;
	showdot = asi64(R1);
	goto L1522;
L1523:
	R1 = 1;
	showdot = asi64(R1);
L1522:
	R1 = 9;
	w = asi64(R1);
	R1 = 3;
	nchars = asi64(R1);
	asi64(R1) = expon;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L1525;
	asi64(R1) = expon;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	asi64(R2) = w;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&nchars;
	*toi64p(R2) += asi64(R1);
L1525:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = w;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&nchars;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = expon;
	asi64(R2) = upper;
	asi64(R1) -= asi64(R2);
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1527;
	asi64(R1) = expon;
	asi64(R2) = upper;
	asi64(R1) -= asi64(R2);
	asi64(R2) = w;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&nchars;
	*toi64p(R2) += asi64(R1);
L1527:
	R1 = 8;
	R2 = (u64)&nchars;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = nchars;
	R2 = R1;
	qq_decimal_decstrsize = asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	t = asu64(R2);
	s = asu64(R1);
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L1529;
	R1 = 45;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L1529:
	R1 = 0;
	prel = asi64(R1);
	asi64(R1) = expon;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L1531;
	R1 = 1;
	prel = asi64(R1);
	R1 = 48;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 46;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = expon;
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1534;
L1532:
	R1 = 9;
	av_1 = asi64(R1);
L1535:
	R1 = 48;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	if (--asi64(av_1)) goto L1535;
	if (--asi64(av_2)) goto L1532;
L1534:
L1531:
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = upper;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1540;
L1538:
	asu64(R1) = t;
	msysc_m$print_startstr(asu64(R1));
	asi64(R1) = i;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L1543;
	asi64(R1) = prel;
	if (!asi64(R1)) goto L1542;
L1543:
	R1 = tou64("z9");
	goto L1541;
L1542:
	R1 = tou64("");
L1541:
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = t;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = expon;
	asi64(R2) = i;
	if (asi64(R1) != asi64(R2)) goto L1545;
	asi64(R1) = i;
	asi64(R2) = upper;
	if (asi64(R1) >= asi64(R2)) goto L1545;
	asi64(R1) = showdot;
	if (!asi64(R1)) goto L1545;
	R1 = 46;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L1545:
	i += 1; if (i <= upper) goto L1538;
L1540:
	asi64(R1) = expon;
	asi64(R2) = upper;
	asi64(R1) -= asi64(R2);
	av_4 = asi64(R1);
	asi64(R1) = av_4;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1548;
L1546:
	R1 = 9;
	av_3 = asi64(R1);
L1549:
	R1 = 48;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	if (--asi64(av_3)) goto L1549;
	if (--asi64(av_4)) goto L1546;
L1548:
	asi64(R1) = expon;
	asi64(R2) = upper;
	if (asi64(R1) < asi64(R2)) goto L1553;
	asi64(R1) = showdot;
	if (!asi64(R1)) goto L1553;
	R1 = 46;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 48;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L1553:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = s;
	goto L1521;
L1521:
	return asu64(R1);
}

static i64 qq_decimal_strvaln(u64 s, i64 n) {
    u64 R1, R2; 
	i64 a;
	i64 av_1;
	R1 = 0;
	a = asi64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1557;
L1555:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 95;
	if (asu64(R1) == asu64(R2)) goto L1559;
	asi64(R1) = a;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asu64(R2) = s;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	a = asi64(R1);
L1559:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L1555;
L1557:
	asi64(R1) = a;
	goto L1554;
L1554:
	return asi64(R1);
}

static i64 qq_decimal_bn_isint(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 1;
	asi64(R2) += asi64(R3);
	asi64(R1) = asi64(R1)  <=  asi64(R2);
	goto L1560;
L1560:
	return asi64(R1);
}

static i64 qq_decimal_obj_len_dec(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	asi64(R1) = qq_decimal_bn_getprec(asu64(R1));
	goto L1561;
	asu64(R1) = a;
	asi64(R1) = qq_decimal_bn_isint(asu64(R1));
	if (asi64(R1)) goto L1563;
	R1 = 0;
	goto L1561;
L1563:
	asu64(R1) = a;
	asi64(R1) = qq_decimal_bn_iszero(asu64(R1));
	if (!asi64(R1)) goto L1565;
	R1 = 1;
	goto L1561;
L1565:
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = a;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 9;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	goto L1561;
L1561:
	return asi64(R1);
}

static i64 qq_decimal_bn_iszero(u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L1566;
L1566:
	return asi64(R1);
}

static i64 qq_decimal_var_equal_dec(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_decimal_bn_equal(asu64(R2), asu64(R1));
	goto L1567;
L1567:
	return asi64(R1);
}

static void qq_decimal_var_add_dec(u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 dest;
	asu64(R1) = qq_decimal_bn_init();
	dest = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	asi64(R1) = qq_decimal_bn_add(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = dest;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_decimal_var_sub_dec(u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 dest;
	asu64(R1) = qq_decimal_bn_init();
	dest = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	asi64(R1) = qq_decimal_bn_sub(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = dest;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_decimal_var_mul_dec(u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 dest;
	asu64(R1) = qq_decimal_bn_init();
	dest = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	asi64(R1) = qq_decimal_bn_mul(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = dest;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_decimal_var_div_dec(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	u64 dest;
	asu64(R1) = qq_decimal_bn_init();
	dest = asu64(R1);
	R1 = 0;
	asu64(R2) = b;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = a;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = dest;
	asi64(R1) = qq_decimal_bn_div(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = dest;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_decimal_var_idiv_dec(u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 dest;
	asu64(R1) = qq_decimal_bn_init();
	dest = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	asi64(R1) = qq_decimal_bn_idiv(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = dest;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_decimal_var_irem_dec(u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 dest;
	asu64(R1) = qq_decimal_bn_init();
	dest = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	asi64(R1) = qq_decimal_bn_irem(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = dest;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_decimal_var_neg_dec(u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_decimal_bn_negto(asu64(R1));
	return;
}

static void qq_decimal_var_abs_dec(u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_decimal_bn_absto(asu64(R1));
	return;
}

static i64 qq_decimal_var_compare_dec(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_decimal_bn_cmp(asu64(R2), asu64(R1));
	goto L1576;
L1576:
	return asi64(R1);
}

static i64 qq_decimal_bn_cmp(u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 d;
	i64 neg;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_decimal_bn_equal(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L1579;
	R1 = 0;
	goto L1577;
L1579:
	asu64(R1) = qq_decimal_bn_init();
	d = asu64(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = d;
	asi64(R1) = qq_decimal_bn_sub(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	neg = asi64(R1);
	asu64(R1) = d;
	qq_decimal_obj_free_dec(asu64(R1));
	asi64(R1) = neg;
	if (!asi64(R1)) goto L1581;
	R1 = -1;
	goto L1580;
L1581:
	R1 = 1;
L1580:
	goto L1577;
L1577:
	return asi64(R1);
}

static i64 qq_decimal_bn_equal(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1584;
	asu64(R1) = a;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = b;
	R3 = 26;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	if (asi64(R1) != asi64(R2)) goto L1584;
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = b;
	R3 = 24;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L1582;
L1584:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L1587;
	asu64(R1) = a;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = b;
	R3 = 26;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	if (asi64(R1) != asi64(R2)) goto L1587;
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = b;
	R3 = 24;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	if (asi64(R1) != asi64(R2)) goto L1587;
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = b;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) == asi64(R2)) goto L1586;
L1587:
	R1 = 0;
	goto L1582;
L1586:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1589;
	R1 = 1;
	goto L1582;
L1589:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4;
	asi64(R1) *= asi64(R2);
	asu64(R2) = b;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = a;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R1) = mlib_eqbytes(asu64(R3), asu64(R2), asi64(R1));
	goto L1582;
L1582:
	return asi64(R1);
}

static i64 qq_decimal_bn_add(u64 dest, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 nega;
	i64 negb;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_decimal_getbintype(asu64(R2), asu64(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1592;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1593;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1594;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1595;
	goto L1596;
L1592:
	goto L1591;
L1593:
	asu64(R1) = dest;
	qq_decimal_bn_setzero(asu64(R1));
	R1 = 1;
	goto L1590;
	goto L1591;
L1594:
	asu64(R1) = a;
	asu64(R2) = dest;
	qq_decimal_bn_dupl(asu64(R2), asu64(R1));
	R1 = 1;
	goto L1590;
	goto L1591;
L1595:
	asu64(R1) = b;
	asu64(R2) = dest;
	qq_decimal_bn_dupl(asu64(R2), asu64(R1));
	R1 = 1;
	goto L1590;
	goto L1591;
L1596:
	asu64(R1) = dest;
	qq_decimal_bn_setnan(asu64(R1));
	R1 = 0;
	goto L1590;
L1591:
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	nega = asi64(R1);
	asu64(R1) = b;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	negb = asi64(R1);
	asi64(R1) = nega;
	if (asi64(R1)) goto L1598;
	asi64(R1) = negb;
	if (asi64(R1)) goto L1598;
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = dest;
	qq_decimal_bn_addu(asu64(R3), asu64(R2), asu64(R1));
	goto L1597;
L1598:
	asi64(R1) = nega;
	if (!asi64(R1)) goto L1599;
	asi64(R1) = negb;
	if (!asi64(R1)) goto L1599;
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = dest;
	qq_decimal_bn_addu(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = dest;
	qq_decimal_bn_negto(asu64(R1));
	goto L1597;
L1599:
	asi64(R1) = nega;
	if (asi64(R1)) goto L1600;
	asi64(R1) = negb;
	if (!asi64(R1)) goto L1600;
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = dest;
	qq_decimal_bn_subu(asu64(R3), asu64(R2), asu64(R1));
	goto L1597;
L1600:
	asu64(R1) = a;
	asu64(R2) = b;
	asu64(R3) = dest;
	qq_decimal_bn_subu(asu64(R3), asu64(R2), asu64(R1));
L1597:
	R1 = 1;
	goto L1590;
L1590:
	return asi64(R1);
}

static i64 qq_decimal_bn_sub(u64 dest, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 nega;
	i64 negb;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_decimal_getbintype(asu64(R2), asu64(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1603;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1604;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1605;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1606;
	goto L1607;
L1603:
	goto L1602;
L1604:
	asu64(R1) = dest;
	qq_decimal_bn_setzero(asu64(R1));
	R1 = 1;
	goto L1601;
	goto L1602;
L1605:
	asu64(R1) = a;
	asu64(R2) = dest;
	qq_decimal_bn_dupl(asu64(R2), asu64(R1));
	R1 = 1;
	goto L1601;
	goto L1602;
L1606:
	asu64(R1) = b;
	asu64(R2) = dest;
	qq_decimal_bn_dupl(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	qq_decimal_bn_negto(asu64(R1));
	R1 = 1;
	goto L1601;
	goto L1602;
L1607:
	asu64(R1) = dest;
	qq_decimal_bn_setnan(asu64(R1));
	R1 = 0;
	goto L1601;
L1602:
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	nega = asi64(R1);
	asu64(R1) = b;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	negb = asi64(R1);
	asi64(R1) = nega;
	if (asi64(R1)) goto L1609;
	asi64(R1) = negb;
	if (asi64(R1)) goto L1609;
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = dest;
	qq_decimal_bn_subu(asu64(R3), asu64(R2), asu64(R1));
	goto L1608;
L1609:
	asi64(R1) = nega;
	if (!asi64(R1)) goto L1610;
	asi64(R1) = negb;
	if (!asi64(R1)) goto L1610;
	asu64(R1) = a;
	asu64(R2) = b;
	asu64(R3) = dest;
	qq_decimal_bn_subu(asu64(R3), asu64(R2), asu64(R1));
	goto L1608;
L1610:
	asi64(R1) = nega;
	if (asi64(R1)) goto L1611;
	asi64(R1) = negb;
	if (!asi64(R1)) goto L1611;
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = dest;
	qq_decimal_bn_addu(asu64(R3), asu64(R2), asu64(R1));
	goto L1608;
L1611:
	asu64(R1) = b;
	asu64(R2) = dest;
	qq_decimal_bn_dupl(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	qq_decimal_bn_negto(asu64(R1));
	asu64(R1) = dest;
	asu64(R2) = a;
	asu64(R3) = dest;
	asi64(R1) = qq_decimal_bn_add(asu64(R3), asu64(R2), asu64(R1));
L1608:
	R1 = 1;
	goto L1601;
L1601:
	return asi64(R1);
}

static void qq_decimal_bn_addu(u64 dest, u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	i64 preca;
	i64 precb;
	i64 precc;
	i64 uppera;
	i64 upperb;
	i64 upperc;
	i64 offset;
	i64 carry;
	i64 expona;
	i64 exponb;
	i64 dc;
	u64 j;
	u64 pa;
	u64 pb;
	u64 pax;
	u64 pbx;
	u64 c;
	u64 c2;
	i64 i;
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = b;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) >= asi64(R2)) goto L1614;
	R1 = (u64)&a;
	R2 = (u64)&b;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L1614:
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	expona = asi64(R1);
	asu64(R1) = b;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	exponb = asi64(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	preca = asi64(R1);
	asu64(R1) = b;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	precb = asi64(R1);
	asi64(R1) = expona;
	asi64(R2) = exponb;
	asi64(R1) -= asi64(R2);
	offset = asi64(R1);
	asi64(R1) = preca;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	uppera = asi64(R1);
	asi64(R1) = precb;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	upperb = asi64(R1);
	asi64(R1) = uppera;
	asi64(R2) = upperb;
	asi64(R3) = offset;
	asi64(R2) += asi64(R3);
	if (asi64(R1) <= asi64(R2)) goto L1616;
	asi64(R1) = uppera;
	upperc = asi64(R1);
	goto L1615;
L1616:
	asi64(R1) = upperb;
	asi64(R2) = offset;
	asi64(R1) += asi64(R2);
	upperc = asi64(R1);
L1615:
	asi64(R1) = upperc;
	R2 = 1;
	asi64(R1) += asi64(R2);
	precc = asi64(R1);
	asi64(R1) = precc;
	asu64(R1) = qq_decimal_makesmallnum(asi64(R1));
	c = asu64(R1);
	R1 = 0;
	carry = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pb = asu64(R1);
	asi64(R1) = upperc;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1619;
L1617:
	asi64(R1) = i;
	asi64(R2) = offset;
	asu64(R1) -= asu64(R2);
	j = asu64(R1);
	asi64(R1) = i;
	asi64(R2) = uppera;
	if (asi64(R1) > asi64(R2)) goto L1621;
	asu64(R1) = j;
	asi64(R2) = upperb;
	if (asu64(R1) > asu64(R2)) goto L1621;
	asu64(R1) = pa;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asu64(R2) = pb;
	asu64(R3) = j;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	asi64(R2) = carry;
	asi64(R1) += asi64(R2);
	dc = asi64(R1);
	goto L1620;
L1621:
	asi64(R1) = i;
	asi64(R2) = uppera;
	if (asi64(R1) > asi64(R2)) goto L1622;
	asu64(R1) = pa;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asi64(R2) = carry;
	asi64(R1) += asi64(R2);
	dc = asi64(R1);
	goto L1620;
L1622:
	asu64(R1) = j;
	asi64(R2) = upperb;
	if (asu64(R1) > asu64(R2)) goto L1623;
	asu64(R1) = pb;
	asu64(R2) = j;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asi64(R2) = carry;
	asi64(R1) += asi64(R2);
	dc = asi64(R1);
	goto L1620;
L1623:
	asi64(R1) = carry;
	dc = asi64(R1);
L1620:
	asi64(R1) = dc;
	R2 = 1000000000;
	if (asi64(R1) < asi64(R2)) goto L1625;
	R1 = 1;
	carry = asi64(R1);
	asi64(R1) = dc;
	R2 = 1000000000;
	asi64(R1) -= asi64(R2);
	asu64(R2) = c;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	goto L1624;
L1625:
	asi64(R1) = dc;
	asu64(R2) = c;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 0;
	carry = asi64(R1);
L1624:
	i += -1; if (i >= 0) goto L1617;
L1619:
	asi64(R1) = carry;
	if (!asi64(R1)) goto L1627;
	asi64(R1) = precc;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = qq_decimal_makesmallnum(asi64(R1));
	c2 = asu64(R1);
	asi64(R1) = carry;
	asu64(R2) = c2;
	*toi32p(R2) = asi32(R1);
	asi64(R1) = precc;
	R2 = 4;
	asu64(R1) *= asu64(R2);
	asu64(R2) = c;
	asu64(R3) = c2;
	R4 = 1;
	R3 += (i64)R4*4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = precc;
	asu64(R2) = c;
	qq_decimal_freesmall(asu64(R2), asi64(R1));
	asu64(R1) = c2;
	c = asu64(R1);
	R1 = (u64)&precc;
	(*toi64p(R1)) += 1;
L1627:
	R1 = 0;
	asi64(R2) = precc;
	asi64(R3) = precc;
	asu64(R4) = c;
	asu64(R5) = dest;
	asu64(R1) = qq_decimal_smalltobig(asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = expona;
	asi64(R2) = carry;
	asi64(R1) += asi64(R2);
	asu64(R2) = dest;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void qq_decimal_bn_subu(u64 dest, u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	i64 preca;
	i64 precb;
	i64 precc;
	i64 uppera;
	i64 upperb;
	i64 upperc;
	i64 offset;
	i64 carry;
	i64 expona;
	i64 da;
	i64 db;
	i64 dc;
	i64 isneg;
	i64 z;
	i64 newprec;
	i64 diff;
	u64 j;
	u64 pa;
	u64 pb;
	u64 c;
	i64 i;
	R1 = 0;
	isneg = asi64(R1);
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = b;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) >= asi64(R2)) goto L1630;
	R1 = (u64)&a;
	R2 = (u64)&b;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
	R1 = 1;
	isneg = asi64(R1);
L1630:
// qq_decimal.bn_subu.retry:
L1631:
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	expona = asi64(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	preca = asi64(R1);
	asu64(R1) = b;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	precb = asi64(R1);
	asi64(R1) = expona;
	asu64(R2) = b;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	offset = asi64(R1);
	asi64(R1) = preca;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	uppera = asi64(R1);
	asi64(R1) = precb;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	upperb = asi64(R1);
	asi64(R1) = uppera;
	asi64(R2) = upperb;
	asi64(R3) = offset;
	asi64(R2) += asi64(R3);
	if (asi64(R1) <= asi64(R2)) goto L1633;
	asi64(R1) = uppera;
	upperc = asi64(R1);
	goto L1632;
L1633:
	asi64(R1) = upperb;
	asi64(R2) = offset;
	asi64(R1) += asi64(R2);
	upperc = asi64(R1);
L1632:
	asi64(R1) = upperc;
	R2 = 1;
	asi64(R1) += asi64(R2);
	precc = asi64(R1);
	asi64(R1) = precc;
	asu64(R1) = qq_decimal_makesmallnum(asi64(R1));
	c = asu64(R1);
	R1 = 0;
	carry = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pb = asu64(R1);
	asi64(R1) = upperc;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1636;
L1634:
	asi64(R1) = i;
	asi64(R2) = offset;
	asu64(R1) -= asu64(R2);
	j = asu64(R1);
	asi64(R1) = i;
	asi64(R2) = uppera;
	if (asi64(R1) > asi64(R2)) goto L1638;
	asu64(R1) = j;
	asi64(R2) = upperb;
	if (asu64(R1) > asu64(R2)) goto L1638;
	asu64(R1) = pa;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asu64(R2) = pb;
	asu64(R3) = j;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	asi64(R2) = carry;
	asi64(R1) -= asi64(R2);
	diff = asi64(R1);
	goto L1637;
L1638:
	asi64(R1) = i;
	asi64(R2) = uppera;
	if (asi64(R1) > asi64(R2)) goto L1639;
	asu64(R1) = pa;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asi64(R2) = carry;
	asi64(R1) -= asi64(R2);
	diff = asi64(R1);
	goto L1637;
L1639:
	asu64(R1) = j;
	asi64(R2) = upperb;
	if (asu64(R1) > asu64(R2)) goto L1640;
	asu64(R1) = pb;
	asu64(R2) = j;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asi64(R1) = -asi64(R1);
	asi64(R2) = carry;
	asi64(R1) -= asi64(R2);
	diff = asi64(R1);
	goto L1637;
L1640:
	asi64(R1) = carry;
	asi64(R1) = -asi64(R1);
	diff = asi64(R1);
L1637:
	asi64(R1) = diff;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L1642;
	R1 = 1;
	carry = asi64(R1);
	asi64(R1) = diff;
	R2 = 1000000000;
	asi64(R1) += asi64(R2);
	asu64(R2) = c;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	goto L1641;
L1642:
	asi64(R1) = diff;
	asu64(R2) = c;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 0;
	carry = asi64(R1);
L1641:
	i += -1; if (i >= 0) goto L1634;
L1636:
	asi64(R1) = carry;
	if (!asi64(R1)) goto L1644;
	asi64(R1) = isneg;
	if (!asi64(R1)) goto L1646;
	R1 = tou64("");
	R2 = tou64("SUBU/CARRY");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1646:
	R1 = (u64)&a;
	R2 = (u64)&b;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
	R1 = 1;
	isneg = asi64(R1);
	asi64(R1) = precc;
	asu64(R2) = c;
	qq_decimal_freesmall(asu64(R2), asi64(R1));
	goto L1631;
L1644:
	R1 = 0;
	asi64(R2) = precc;
	asi64(R3) = precc;
	asu64(R4) = c;
	asu64(R5) = dest;
	asu64(R1) = qq_decimal_smalltobig(asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = isneg;
	asu64(R2) = dest;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = expona;
	asi64(R2) = qq_decimal_stblz;
	asi64(R1) -= asi64(R2);
	asu64(R2) = dest;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static u64 qq_decimal_makebignum(i64 length) {
    u64 R1, R2, R3; 
	u64 a;
	asu64(R1) = qq_vars_obj_new();
	a = asu64(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L1649;
	asi64(R1) = length;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 26;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L1648;
L1649:
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = a;
	R3 = 26;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L1648:
	asi64(R1) = length;
	asu64(R2) = a;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	asu64(R2) = a;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asu64(R2) = a;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = a;
	goto L1647;
L1647:
	return asu64(R1);
}

static u64 qq_decimal_makesmallnum(i64 length) {
    u64 R1, R2; 
	asi64(R1) = length;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	goto L1650;
L1650:
	return asu64(R1);
}

static u64 qq_decimal_smalltobig(u64 c, u64 a, i64 length, i64 alloc, i64 offset) {
    u64 R1, R2, R3, R4; 
	u64 p;
	i64 leadingzeros;
	i64 trailingzeros;
	i64 nonzeros;
	i64 newlength;
	i64 av_1;
	asu64(R1) = c;
	qq_decimal_bn_setzero(asu64(R1));
	asu64(R1) = a;
	p = asu64(R1);
	R1 = 0;
	R2 = R1;
	nonzeros = asi64(R2);
	R2 = R1;
	trailingzeros = asi64(R2);
	leadingzeros = asi64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1654;
L1652:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 4; asu64(R1) = asu64(R2);
	asi32(R1) = *toi32p(R1);
	if (!asi32(R1)) goto L1656;
	R1 = 1;
	nonzeros = asi64(R1);
	R1 = 0;
	trailingzeros = asi64(R1);
	goto L1655;
L1656:
	asi64(R1) = nonzeros;
	if (!asi64(R1)) goto L1658;
	R1 = (u64)&trailingzeros;
	(*toi64p(R1)) += 1;
	goto L1657;
L1658:
	R1 = (u64)&leadingzeros;
	(*toi64p(R1)) += 1;
L1657:
L1655:
	if (--asi64(av_1)) goto L1652;
L1654:
	asi64(R1) = leadingzeros;
	qq_decimal_stblz = asi64(R1);
	asi64(R1) = nonzeros;
	if (!asi64(R1)) goto L1660;
	asi64(R1) = length;
	asi64(R2) = trailingzeros;
	asi64(R1) -= asi64(R2);
	asi64(R2) = leadingzeros;
	asi64(R1) -= asi64(R2);
	newlength = asi64(R1);
	asi64(R1) = newlength;
	asi64(R2) = length;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L1662;
	asi64(R2) = alloc;
	if (asi64(R1) != asi64(R2)) goto L1662;
	asu64(R1) = a;
	asu64(R2) = c;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1661;
L1662:
	asi64(R1) = newlength;
	asu64(R1) = qq_decimal_makesmallnum(asi64(R1));
	asu64(R2) = c;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = newlength;
	R2 = 4;
	asu64(R1) *= asu64(R2);
	asu64(R2) = a;
	asi64(R3) = leadingzeros;
	R2 += (i64)R3*4;
	asu64(R3) = c;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = alloc;
	asu64(R2) = a;
	asi64(R3) = offset;
	R2 += (i64)R3*4;
	qq_decimal_freesmall(asu64(R2), asi64(R1));
L1661:
	asi64(R1) = newlength;
	asu64(R2) = c;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = c;
	R3 = 26;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R2) = leadingzeros;
	asi64(R1) -= asi64(R2);
	asu64(R2) = c;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L1659;
L1660:
	asi64(R1) = alloc;
	if (!asi64(R1)) goto L1663;
	asi64(R1) = alloc;
	asu64(R2) = a;
	asi64(R3) = offset;
	R2 += (i64)R3*4;
	qq_decimal_freesmall(asu64(R2), asi64(R1));
L1663:
L1659:
	asu64(R1) = c;
	goto L1651;
L1651:
	return asu64(R1);
}

static void qq_decimal_freesmall(u64 p, i64 length) {
    u64 R1, R2; 
	asi64(R1) = length;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static u64 qq_decimal_bn_init() {
    u64 R1; 
	u64 a;
	R1 = 0;
	asu64(R1) = qq_decimal_makebignum(asi64(R1));
	a = asu64(R1);
	asu64(R1) = a;
	goto L1665;
L1665:
	return asu64(R1);
}

static void qq_decimal_bn_setzero(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	if (!asu64(R1)) goto L1668;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L1670;
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_decimal_freesmall(asu64(R2), asi64(R1));
L1670:
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = a;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	asu64(R2) = a;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 0;
	asu64(R2) = a;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asu64(R2) = a;
	R3 = 26;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L1668:
	return;
}

static void qq_decimal_bn_move(u64 a, u64 b) {
    u64 R1, R2, R3; struct $B8 R1_B8; 
	asu64(R1) = a;
	qq_decimal_bn_setzero(asu64(R1));
	asu64(R1) = b;
	R2 = 8;
	(R1_B8) = *(struct $B8*)(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	*(struct $B8*)(((i64)R2+(i64)R3)) = (R1_B8);
	asu64(R1) = b;
	R2 = 8;
	R1 += (i64)R2;
	memset(R1, 0, 24);
	return;
}

static void qq_decimal_bn_dupl(u64 a, u64 b) {
    u64 R1, R2, R3, R4; struct $B31 R1_B31; 
	u64 c;
	i64 size;
	asu64(R1) = qq_decimal_bn_init();
	c = asu64(R1);
	asu64(R1) = b;
	(R1_B31) = *(struct $B31*)(R1);
	asu64(R2) = c;
	*(struct $B31*)(R2) = (R1_B31);
	asu64(R1) = c;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L1674;
	asu64(R1) = c;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	size = asi64(R2);
	asu64(R1) = qq_decimal_makesmallnum(asi64(R1));
	asu64(R2) = c;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = size;
	R2 = 4;
	asu64(R1) *= asu64(R2);
	asu64(R2) = b;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = c;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L1674:
	asu64(R1) = c;
	asu64(R2) = a;
	qq_decimal_bn_move(asu64(R2), asu64(R1));
	asu64(R1) = c;
	qq_decimal_obj_free_dec(asu64(R1));
	return;
}

static void qq_decimal_bn_setinf(u64 dest) {
    u64 R1, R2, R3; 
	asu64(R1) = dest;
	qq_decimal_bn_setzero(asu64(R1));
	R1 = 2;
	asu64(R2) = dest;
	R3 = 26;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	return;
}

static void qq_decimal_bn_setnan(u64 dest) {
    u64 R1, R2, R3; 
	asu64(R1) = dest;
	qq_decimal_bn_setzero(asu64(R1));
	R1 = 3;
	asu64(R2) = dest;
	R3 = 26;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	return;
}

static void qq_decimal_var_setnan(u64 dest) {
    u64 R1, R2, R3; 
	R1 = 259;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R1) = qq_decimal_makebignum(asi64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = dest;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_decimal_bn_setnan(asu64(R1));
	return;
}

static void qq_decimal_var_setinf(u64 dest) {
    u64 R1, R2, R3; 
	R1 = 259;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R1) = qq_decimal_makebignum(asi64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = dest;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_decimal_bn_setinf(asu64(R1));
	return;
}

static i64 qq_decimal_getbintype(u64 a, u64 b) {
    u64 R1, R2; 
	i64 atype;
	i64 btype;
	asu64(R1) = a;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	atype = asi64(R1);
	asu64(R1) = b;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	btype = asi64(R1);
	asi64(R1) = atype;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1682;
	asi64(R1) = btype;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1681;
L1682:
	R1 = 4;
	goto L1679;
L1681:
	asi64(R1) = atype;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1684;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1685;
	goto L1686;
L1684:
	asi64(R1) = btype;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1688;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1689;
	goto L1690;
L1688:
	R1 = 1;
	goto L1687;
L1689:
	R1 = 5;
	goto L1687;
L1690:
	R1 = 6;
L1687:
	goto L1683;
L1685:
	asi64(R1) = btype;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1692;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1693;
	goto L1694;
L1692:
	R1 = 7;
	goto L1691;
L1693:
	R1 = 2;
	goto L1691;
L1694:
	R1 = 9;
L1691:
	goto L1683;
L1686:
	asi64(R1) = btype;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1696;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1697;
	goto L1698;
L1696:
	R1 = 8;
	goto L1695;
L1697:
	R1 = 10;
	goto L1695;
L1698:
	R1 = 3;
L1695:
L1683:
	goto L1679;
L1679:
	return asi64(R1);
}

static void qq_decimal_bn_negto(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	asi64(R1) = qq_decimal_bn_iszero(asu64(R1));
	if (asi64(R1)) goto L1701;
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asi64(R1) = !asi64(R1);
	asu64(R2) = a;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L1701:
	return;
}

static void qq_decimal_bn_absto(u64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = a;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	return;
}

static i64 qq_decimal_bn_mul(u64 dest, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 neg;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_decimal_getbintype(asu64(R2), asu64(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1705;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1706;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1706;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1706;
	goto L1707;
L1705:
	goto L1704;
L1706:
	asu64(R1) = dest;
	qq_decimal_bn_setzero(asu64(R1));
	R1 = 1;
	goto L1703;
	goto L1704;
L1707:
	asu64(R1) = dest;
	qq_decimal_bn_setnan(asu64(R1));
	R1 = 0;
	goto L1703;
L1704:
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = b;
	R3 = 24;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	neg = asi64(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = dest;
	qq_decimal_bn_mulu(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = neg;
	if (!asi64(R1)) goto L1709;
	asu64(R1) = dest;
	qq_decimal_bn_negto(asu64(R1));
L1709:
	R1 = 1;
	goto L1703;
L1703:
	return asi64(R1);
}

static i64 qq_decimal_bn_mulp(u64 dest, u64 a, u64 b, i64 prec) {
    u64 R1, R2, R3; 
	i64 res;
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = dest;
	asi64(R1) = qq_decimal_bn_mul(asu64(R3), asu64(R2), asu64(R1));
	res = asi64(R1);
	asi64(R1) = res;
	if (!asi64(R1)) goto L1712;
	asi64(R1) = prec;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1714;
	asi64(R1) = qq_decimal_currprec;
	goto L1713;
L1714:
	asi64(R1) = prec;
L1713:
	asu64(R2) = dest;
	qq_decimal_bn_setprec(asu64(R2), asi64(R1));
L1712:
	asi64(R1) = res;
	goto L1710;
L1710:
	return asi64(R1);
}

static void qq_decimal_bn_mulu(u64 dest, u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	i64 uppera;
	i64 upperb;
	i64 upperc;
	i64 precc;
	i64 expona;
	i64 exponb;
	i64 ax;
	i64 bx;
	i64 cx;
	i64 i;
	i64 cx1;
	i64 nc2;
	i64 pd;
	i64 pr;
	i64 p;
	i64 carry;
	i64 x;
	u64 d;
	u64 c;
	i64 pdquot;
	i64 pdrem;
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	expona = asi64(R1);
	asu64(R1) = b;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	exponb = asi64(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	uppera = asi64(R1);
	asu64(R1) = b;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	upperb = asi64(R1);
	asi64(R1) = uppera;
	asi64(R2) = upperb;
	asi64(R1) += asi64(R2);
	R2 = 2;
	asi64(R1) += asi64(R2);
	precc = asi64(R1);
	asi64(R1) = precc;
	nc2 = asi64(R1);
	asi64(R1) = nc2;
	asu64(R1) = qq_decimal_makesmallnum(asi64(R1));
	c = asu64(R1);
	asi64(R1) = precc;
	R2 = 4;
	asu64(R1) *= asu64(R2);
	R2 = 0;
	asu64(R3) = c;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asi64(R1) = precc;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	cx = asi64(R1);
	asi64(R1) = upperb;
	bx = asi64(R1);
	asi64(R1) = bx;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1718;
L1716:
	R1 = 0;
	carry = asi64(R1);
	asi64(R1) = cx;
	cx1 = asi64(R1);
	asi64(R1) = uppera;
	ax = asi64(R1);
	asi64(R1) = ax;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1721;
L1719:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = ax;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asu64(R2) = b;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = bx;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) *= asi64(R2);
	asi64(R2) = carry;
	asi64(R1) += asi64(R2);
	p = asi64(R1);
	asi64(R1) = p;
	R2 = 1000000000;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	pd = asi64(R1);
	asi64(R1) = p;
	asi64(R2) = pd;
	R3 = 1000000000;
	asi64(R2) *= asi64(R3);
	asi64(R1) -= asi64(R2);
	pr = asi64(R1);
	asu64(R1) = c;
	asi64(R2) = cx1;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asi64(R2) = pr;
	asi64(R1) += asi64(R2);
	x = asi64(R1);
	asi64(R1) = x;
	R2 = 999999999;
	if (asi64(R1) <= asi64(R2)) goto L1723;
	asi64(R1) = pd;
	R2 = 1;
	asi64(R1) += asi64(R2);
	carry = asi64(R1);
	asi64(R1) = x;
	R2 = 1000000000;
	asi64(R1) -= asi64(R2);
	asu64(R2) = c;
	R3 = (u64)&cx1;
	asi64(R4) = *toi64p(R3); *(toi64p(R3)) -= 1; asi64(R3) = asi64(R4);
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	goto L1722;
L1723:
	asi64(R1) = pd;
	carry = asi64(R1);
	asi64(R1) = x;
	asu64(R2) = c;
	R3 = (u64)&cx1;
	asi64(R4) = *toi64p(R3); *(toi64p(R3)) -= 1; asi64(R3) = asi64(R4);
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L1722:
	ax += -1; if (ax >= 0) goto L1719;
L1721:
	asi64(R1) = carry;
	asu64(R2) = c;
	asi64(R3) = cx1;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&cx;
	(*toi64p(R1)) -=1;
	bx += -1; if (bx >= 0) goto L1716;
L1718:
	R1 = 0;
	asi64(R2) = nc2;
	asi64(R3) = precc;
	asu64(R4) = c;
	asu64(R5) = dest;
	asu64(R1) = qq_decimal_smalltobig(asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = expona;
	asi64(R2) = exponb;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R2) = qq_decimal_stblz;
	asi64(R1) -= asi64(R2);
	asu64(R2) = dest;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static i64 qq_decimal_smallmulto(u64 p, u64 q, i64 plen, i64 m) {
    u64 R1, R2, R3; 
	u64 pp;
	u64 qq;
	i64 carry;
	i64 d;
	i64 av_1;
	i64 av_2;
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1726;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1727;
	goto L1728;
L1726:
	R1 = 0;
	asu64(R2) = p;
	*toi32p(R2) = asi32(R1);
	R1 = 1;
	goto L1724;
	goto L1725;
L1727:
	asi64(R1) = plen;
	R2 = 4;
	asu64(R1) *= asu64(R2);
	asu64(R2) = q;
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = plen;
	goto L1724;
	goto L1725;
L1728:
L1725:
	asu64(R1) = p;
	asi64(R2) = plen;
	R1 += (i64)R2*4;
	R2 = 1;
	R1 -= (i64)R2*4;
	pp = asu64(R1);
	asu64(R1) = q;
	asi64(R2) = plen;
	R1 += (i64)R2*4;
	R2 = 1;
	R1 -= (i64)R2*4;
	qq = asu64(R1);
	R1 = 0;
	carry = asi64(R1);
	asi64(R1) = plen;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1731;
L1729:
	asu64(R1) = qq;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	asi64(R2) = m;
	asi64(R1) *= asi64(R2);
	asi64(R2) = carry;
	asi64(R1) += asi64(R2);
	d = asi64(R1);
	asi64(R1) = d;
	R2 = 1000000000;
	asi64(R1) %= asi64(R2);
	asu64(R2) = pp;
	*toi32p(R2) = asi32(R1);
	asi64(R1) = d;
	R2 = 1000000000;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	carry = asi64(R1);
	R1 = (u64)&qq;
	(*tou64p(R1)) -=4;
	R1 = (u64)&pp;
	(*tou64p(R1)) -=4;
	if (--asi64(av_1)) goto L1729;
L1731:
	asi64(R1) = carry;
	if (!asi64(R1)) goto L1733;
	asu64(R1) = p;
	asi64(R2) = plen;
	R1 += (i64)R2*4;
	pp = asu64(R1);
	asi64(R1) = plen;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1736;
L1734:
	asu64(R1) = pp;
	R2 = 1;
	R1 -= (i64)R2*4;
	asi32(R1) = *toi32p(R1);
	asu64(R2) = pp;
	*toi32p(R2) = asi32(R1);
	R1 = (u64)&pp;
	(*tou64p(R1)) -=4;
	if (--asi64(av_2)) goto L1734;
L1736:
	asi64(R1) = carry;
	asu64(R2) = pp;
	*toi32p(R2) = asi32(R1);
	R1 = (u64)&plen;
	(*toi64p(R1)) += 1;
L1733:
	asi64(R1) = plen;
	goto L1724;
L1724:
	return asi64(R1);
}

static i64 qq_decimal_bn_div(u64 dest, u64 a, u64 b, i64 prec) {
    u64 R1, R2, R3, R4; 
	i64 neg;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_decimal_getbintype(asu64(R2), asu64(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1739;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1740;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1741;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1741;
	goto L1742;
L1739:
	goto L1738;
L1740:
	asu64(R1) = dest;
	qq_decimal_bn_setzero(asu64(R1));
	R1 = 1;
	goto L1737;
	goto L1738;
L1741:
	asu64(R1) = dest;
	qq_decimal_bn_setinf(asu64(R1));
	R1 = 0;
	goto L1737;
	goto L1738;
L1742:
	asu64(R1) = dest;
	qq_decimal_bn_setnan(asu64(R1));
	R1 = 0;
	goto L1737;
L1738:
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = b;
	R3 = 24;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	neg = asi64(R1);
	asi64(R1) = prec;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = dest;
	qq_decimal_bn_fdivu(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = neg;
	if (!asi64(R1)) goto L1744;
	asu64(R1) = dest;
	qq_decimal_bn_negto(asu64(R1));
L1744:
	R1 = 1;
	goto L1737;
L1737:
	return asi64(R1);
}

static i64 qq_decimal_bn_idiv(u64 dest, u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	i64 neg;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_decimal_getbintype(asu64(R2), asu64(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1747;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1748;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1749;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1749;
	goto L1750;
L1747:
	goto L1746;
L1748:
	asu64(R1) = dest;
	qq_decimal_bn_setzero(asu64(R1));
	R1 = 1;
	goto L1745;
	goto L1746;
L1749:
	asu64(R1) = dest;
	qq_decimal_bn_setinf(asu64(R1));
	R1 = 0;
	goto L1745;
	goto L1746;
L1750:
	asu64(R1) = dest;
	qq_decimal_bn_setnan(asu64(R1));
	R1 = 0;
	goto L1745;
L1746:
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = b;
	R3 = 24;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	neg = asi64(R1);
	R1 = 0;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = dest;
	qq_decimal_bn_idivu(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = neg;
	if (!asi64(R1)) goto L1752;
	asu64(R1) = dest;
	qq_decimal_bn_negto(asu64(R1));
L1752:
	R1 = 1;
	goto L1745;
L1745:
	return asi64(R1);
}

static i64 qq_decimal_bn_idivrem(u64 dest, u64 rm, u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	i64 nega;
	i64 negb;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_decimal_getbintype(asu64(R2), asu64(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1755;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1756;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1757;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1757;
	goto L1758;
L1755:
	goto L1754;
L1756:
	asu64(R1) = dest;
	qq_decimal_bn_setzero(asu64(R1));
	asu64(R1) = rm;
	qq_decimal_bn_setzero(asu64(R1));
	R1 = 1;
	goto L1753;
	goto L1754;
L1757:
	asu64(R1) = dest;
	qq_decimal_bn_setinf(asu64(R1));
	asu64(R1) = rm;
	qq_decimal_bn_setzero(asu64(R1));
	R1 = 0;
	goto L1753;
	goto L1754;
L1758:
	asu64(R1) = dest;
	qq_decimal_bn_setnan(asu64(R1));
	R1 = 0;
	goto L1753;
L1754:
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	nega = asi64(R1);
	asu64(R1) = b;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	negb = asi64(R1);
	asu64(R1) = rm;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = dest;
	qq_decimal_bn_idivu(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = nega;
	asi64(R2) = negb;
	if (asi64(R1) == asi64(R2)) goto L1760;
	asu64(R1) = dest;
	qq_decimal_bn_negto(asu64(R1));
L1760:
	asi64(R1) = nega;
	if (!asi64(R1)) goto L1762;
	asu64(R1) = rm;
	qq_decimal_bn_negto(asu64(R1));
L1762:
	R1 = 1;
	goto L1753;
L1753:
	return asi64(R1);
}

static i64 qq_decimal_bn_irem(u64 dest, u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	u64 rm;
	u64 d;
	i64 nega;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_decimal_getbintype(asu64(R2), asu64(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1765;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1766;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1767;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1767;
	goto L1768;
L1765:
	goto L1764;
L1766:
	asu64(R1) = b;
	asu64(R2) = dest;
	qq_decimal_bn_dupl(asu64(R2), asu64(R1));
	R1 = 1;
	goto L1763;
	goto L1764;
L1767:
	asu64(R1) = dest;
	qq_decimal_bn_setinf(asu64(R1));
	asu64(R1) = dest;
	qq_decimal_bn_setzero(asu64(R1));
	R1 = 0;
	goto L1763;
	goto L1764;
L1768:
	asu64(R1) = dest;
	qq_decimal_bn_setnan(asu64(R1));
	R1 = 0;
	goto L1763;
L1764:
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	nega = asi64(R1);
	asu64(R1) = qq_decimal_bn_init();
	d = asu64(R1);
	asu64(R1) = dest;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = d;
	qq_decimal_bn_idivu(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = nega;
	if (!asi64(R1)) goto L1770;
	asu64(R1) = dest;
	qq_decimal_bn_negto(asu64(R1));
L1770:
	asu64(R1) = d;
	qq_decimal_obj_free_dec(asu64(R1));
	R1 = 1;
	goto L1763;
L1763:
	return asi64(R1);
}

static void qq_decimal_bn_idivu(u64 dest, u64 a, u64 b, u64 rm) {
    u64 R1, R2, R3, R4, R5; 
	u64 c;
	u64 x;
	u64 e;
	i64 expona;
	i64 exponb;
	i64 badjust;
	i64 exponc;
	i64 na;
	i64 nb;
	i64 nc;
	i64 nx;
	i64 ne;
	i64 nx2;
	i64 ne2;
	i64 cx;
	i64 nupper;
	i64 uppera;
	i64 upperb;
	i64 upperc;
	i64 n;
	i64 k;
	i64 nexta;
	i64 xx;
	i64 y;
	u64 pa;
	u64 pb;
	u64 d;
	i64 i;
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	na = asi64(R1);
	asu64(R1) = b;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	nb = asi64(R1);
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	expona = asi64(R1);
	asu64(R1) = b;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	exponb = asi64(R1);
	asi64(R1) = exponb;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R2) = nb;
	asi64(R1) -= asi64(R2);
	badjust = asi64(R1);
	asi64(R1) = na;
	asi64(R2) = expona;
	R3 = 1;
	asi64(R2) += asi64(R3);
	if (asi64(R1) > asi64(R2)) goto L1774;
	asi64(R1) = nb;
	asi64(R2) = exponb;
	R3 = 1;
	asi64(R2) += asi64(R3);
	if (asi64(R1) <= asi64(R2)) goto L1773;
L1774:
	R1 = tou64("");
	R2 = tou64("idivu:a or b not int");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1773:
	asi64(R1) = expona;
	R2 = 1;
	asi64(R1) += asi64(R2);
	nc = asi64(R1);
	asi64(R1) = expona;
	asi64(R2) = exponb;
	if (asi64(R1) >= asi64(R2)) goto L1776;
	asu64(R1) = dest;
	qq_decimal_bn_setzero(asu64(R1));
	asu64(R1) = rm;
	if (!asu64(R1)) goto L1778;
	asu64(R1) = a;
	asu64(R2) = rm;
	qq_decimal_bn_dupl(asu64(R2), asu64(R1));
L1778:
	goto L1771;
L1776:
	asi64(R1) = na;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	uppera = asi64(R1);
	asi64(R1) = nb;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	upperb = asi64(R1);
	asi64(R1) = nc;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	upperc = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pb = asu64(R1);
	asi64(R1) = nb;
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = R1;
	nx2 = asi64(R2);
	asu64(R1) = qq_decimal_makesmallnum(asi64(R1));
	x = asu64(R1);
	asi64(R1) = n;
	nx = asi64(R1);
	asi64(R1) = nc;
	asi64(R2) = badjust;
	asi64(R1) -= asi64(R2);
	nupper = asi64(R1);
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = upperb;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1781;
L1779:
	asi64(R1) = i;
	asi64(R2) = uppera;
	if (asi64(R1) > asi64(R2)) goto L1783;
	asu64(R1) = pa;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	asu64(R2) = x;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	goto L1782;
L1783:
	R1 = 0;
	asu64(R2) = x;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L1782:
	i += 1; if (i <= upperb) goto L1779;
L1781:
	asi64(R1) = nc;
	asu64(R1) = qq_decimal_makesmallnum(asi64(R1));
	c = asu64(R1);
	R1 = 0;
	cx = asi64(R1);
L1784:
	asi64(R1) = nb;
	R2 = (u64)&nx;
	asu64(R3) = pb;
	asu64(R4) = x;
	asi64(R1) = qq_decimal_smalldiv(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	k = asi64(R1);
	asi64(R1) = k;
	asu64(R2) = c;
	R3 = (u64)&cx;
	asi64(R4) = *toi64p(R3); *(toi64p(R3)) += 1; asi64(R3) = asi64(R4);
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = n;
	asi64(R2) = nupper;
	if (asi64(R1) < asi64(R2)) goto L1787;
	goto L1785;
L1787:
	asi64(R1) = n;
	asi64(R2) = uppera;
	if (asi64(R1) <= asi64(R2)) goto L1789;
	R1 = 0;
	goto L1788;
L1789:
	asu64(R1) = pa;
	asi64(R2) = n;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
L1788:
	nexta = asi64(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = nx;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1791;
	asu64(R1) = x;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1791;
	asi64(R1) = nexta;
	asu64(R2) = x;
	*toi32p(R2) = asi32(R1);
	goto L1790;
L1791:
	asi64(R1) = nexta;
	asu64(R2) = x;
	asi64(R3) = nx;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&nx;
	(*toi64p(R1)) += 1;
L1790:
	goto L1784;
L1785:
	asu64(R1) = rm;
	if (!asu64(R1)) goto L1793;
	asi64(R1) = exponb;
	asi64(R2) = nb;
	if (asi64(R1) >= asi64(R2)) goto L1793;
	R1 = 0;
	asi64(R2) = nx2;
	asi64(R3) = nx;
	asu64(R4) = x;
	asu64(R5) = rm;
	asu64(R1) = qq_decimal_smalltobig(asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L1792;
L1793:
	asi64(R1) = nx2;
	asu64(R2) = x;
	qq_decimal_freesmall(asu64(R2), asi64(R1));
L1792:
	asi64(R1) = cx;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1795;
	asu64(R1) = c;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1795;
	asi64(R1) = nc;
	asu64(R2) = c;
	qq_decimal_freesmall(asu64(R2), asi64(R1));
	asu64(R1) = dest;
	qq_decimal_bn_setzero(asu64(R1));
	asu64(R1) = rm;
	if (!asu64(R1)) goto L1797;
	asu64(R1) = a;
	asu64(R2) = rm;
	qq_decimal_bn_dupl(asu64(R2), asu64(R1));
L1797:
	goto L1771;
L1795:
	asu64(R1) = c;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1799;
	asi64(R1) = cx;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L1799;
	R1 = -1;
	asi64(R2) = nc;
	asi64(R3) = cx;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R4) = c;
	R5 = 1;
	R4 += (i64)R5*4;
	asu64(R5) = dest;
	asu64(R1) = qq_decimal_smalltobig(asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L1798;
L1799:
	R1 = 0;
	asi64(R2) = nc;
	asi64(R3) = cx;
	asu64(R4) = c;
	asu64(R5) = dest;
	asu64(R1) = qq_decimal_smalltobig(asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
L1798:
	asu64(R1) = rm;
	if (!asu64(R1)) goto L1801;
	asi64(R1) = exponb;
	asi64(R2) = nb;
	if (asi64(R1) < asi64(R2)) goto L1801;
	asu64(R1) = qq_decimal_bn_init();
	d = asu64(R1);
	asu64(R1) = dest;
	asu64(R2) = b;
	asu64(R3) = d;
	qq_decimal_bn_mulu(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = d;
	asu64(R2) = a;
	asu64(R3) = rm;
	qq_decimal_bn_subu(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = d;
	qq_decimal_obj_free_dec(asu64(R1));
L1801:
L1771:
	return;
}

static void qq_decimal_bn_fdivu(u64 dest, u64 a, u64 b, i64 precision) {
    u64 R1, R2, R3, R4, R5; 
	u64 c;
	u64 x;
	u64 e;
	i64 expona;
	i64 exponb;
	i64 badjust;
	i64 exponc;
	i64 na;
	i64 nb;
	i64 nc;
	i64 nx;
	i64 ne;
	i64 nx2;
	i64 ne2;
	i64 cx;
	i64 nupper;
	i64 nc2;
	i64 uppera;
	i64 upperb;
	i64 upperc;
	i64 n;
	i64 k;
	i64 nexta;
	i64 xx;
	i64 y;
	u64 pa;
	u64 pb;
	i64 i;
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	na = asi64(R1);
	asu64(R1) = b;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	nb = asi64(R1);
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	expona = asi64(R1);
	asu64(R1) = b;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	exponb = asi64(R1);
	asi64(R1) = precision;
	if (!asi64(R1)) goto L1804;
	asi64(R1) = precision;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = 9;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	precision = asi64(R1);
	goto L1803;
L1804:
	asi64(R1) = qq_decimal_currprec;
	precision = asi64(R1);
L1803:
	asi64(R1) = precision;
	nc = asi64(R1);
	asi64(R1) = na;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	uppera = asi64(R1);
	asi64(R1) = nb;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	upperb = asi64(R1);
	asi64(R1) = nc;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	upperc = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pb = asu64(R1);
	asi64(R1) = nb;
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = R1;
	nx2 = asi64(R2);
	asu64(R1) = qq_decimal_makesmallnum(asi64(R1));
	x = asu64(R1);
	asi64(R1) = n;
	nx = asi64(R1);
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = upperb;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1807;
L1805:
	asi64(R1) = i;
	asi64(R2) = uppera;
	if (asi64(R1) > asi64(R2)) goto L1809;
	asu64(R1) = pa;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	asu64(R2) = x;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	goto L1808;
L1809:
	R1 = 0;
	asu64(R2) = x;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L1808:
	i += 1; if (i <= upperb) goto L1805;
L1807:
	asi64(R1) = nc;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = R1;
	nc2 = asi64(R2);
	asu64(R1) = qq_decimal_makesmallnum(asi64(R1));
	c = asu64(R1);
	R1 = 0;
	cx = asi64(R1);
L1810:
	asi64(R1) = nb;
	R2 = (u64)&nx;
	asu64(R3) = pb;
	asu64(R4) = x;
	asi64(R1) = qq_decimal_smalldiv(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	k = asi64(R1);
	asi64(R1) = k;
	asu64(R2) = c;
	R3 = (u64)&cx;
	asi64(R4) = *toi64p(R3); *(toi64p(R3)) += 1; asi64(R3) = asi64(R4);
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = cx;
	asi64(R2) = nc;
	if (asi64(R1) <= asi64(R2)) goto L1813;
	goto L1811;
L1813:
	asi64(R1) = n;
	asi64(R2) = uppera;
	if (asi64(R1) <= asi64(R2)) goto L1815;
	R1 = 0;
	goto L1814;
L1815:
	asu64(R1) = pa;
	asi64(R2) = n;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
L1814:
	nexta = asi64(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = nx;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1817;
	asu64(R1) = x;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1817;
	asi64(R1) = nexta;
	asu64(R2) = x;
	*toi32p(R2) = asi32(R1);
	goto L1816;
L1817:
	asi64(R1) = nexta;
	asu64(R2) = x;
	asi64(R3) = nx;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&nx;
	(*toi64p(R1)) += 1;
L1816:
	goto L1810;
L1811:
	asi64(R1) = nx2;
	asu64(R2) = x;
	qq_decimal_freesmall(asu64(R2), asi64(R1));
	asi64(R1) = cx;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1819;
	asu64(R1) = c;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1819;
	asi64(R1) = nc2;
	asu64(R2) = c;
	qq_decimal_freesmall(asu64(R2), asi64(R1));
	asu64(R1) = dest;
	qq_decimal_bn_setzero(asu64(R1));
	goto L1802;
L1819:
	asu64(R1) = c;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1821;
	asi64(R1) = cx;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L1821;
	R1 = -1;
	asi64(R2) = nc2;
	asi64(R3) = cx;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R4) = c;
	R5 = 1;
	R4 += (i64)R5*4;
	asu64(R5) = dest;
	asu64(R1) = qq_decimal_smalltobig(asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = expona;
	asi64(R2) = exponb;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = dest;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L1820;
L1821:
	R1 = 0;
	asi64(R2) = nc2;
	asi64(R3) = cx;
	asu64(R4) = c;
	asu64(R5) = dest;
	asu64(R1) = qq_decimal_smalltobig(asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = expona;
	asi64(R2) = exponb;
	asi64(R1) -= asi64(R2);
	asu64(R2) = dest;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L1820:
L1802:
	return;
}

static i64 qq_decimal_smalldiv(u64 x, u64 b, u64 xlen, i64 nb) {
    u64 R1, R2, R3, R4; 
	i64 k;
	i64 count;
	i64 xx;
	i64 y;
	i32 xi;
	i32 bi;
	u64 e;
	i64 esize;
	i64 ne;
	i64 nx;
	i64 av_1;
	i64 i;
	asu64(R1) = xlen;
	asi64(R1) = *toi64p(R1);
	nx = asi64(R1);
	R1 = 0;
	k = asi64(R1);
	R1 = 0;
	count = asi64(R1);
	asi64(R1) = nb;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = R1;
	esize = asi64(R2);
	asu64(R1) = qq_decimal_makesmallnum(asi64(R1));
	e = asu64(R1);
L1823:
	asi64(R1) = nx;
	asi64(R2) = nb;
	if (asi64(R1) >= asi64(R2)) goto L1826;
	goto L1824;
	goto L1825;
L1826:
	asi64(R1) = nx;
	asi64(R2) = nb;
	if (asi64(R1) <= asi64(R2)) goto L1827;
	asu64(R1) = x;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	R2 = 1000000000;
	asi64(R1) *= asi64(R2);
	asu64(R2) = x;
	R3 = 1;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	xx = asi64(R1);
	asi64(R1) = xx;
	asu64(R2) = b;
	asi32(R2) = *toi32p(R2);
	R2 = toi64(toi32(R2));
	R3 = 1;
	asi64(R2) += asi64(R3);
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	y = asi64(R1);
	goto L1825;
L1827:
	asu64(R1) = x;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	asu64(R2) = b;
	asi32(R2) = *toi32p(R2);
	R2 = toi64(toi32(R2));
	R3 = 1;
	asi64(R2) += asi64(R3);
	if (asi64(R1) < asi64(R2)) goto L1829;
	asu64(R1) = x;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	asu64(R2) = b;
	asi32(R2) = *toi32p(R2);
	R2 = toi64(toi32(R2));
	R3 = 1;
	asi64(R2) += asi64(R3);
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	y = asi64(R1);
	goto L1828;
L1829:
	R1 = 1;
	y = asi64(R1);
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = nb;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1832;
L1830:
	asu64(R1) = x;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	xi = asi32(R1);
	asu64(R1) = b;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	bi = asi32(R1);
	asi32(R1) = xi;
	R1 = toi64(toi32(R1));
	asi32(R2) = bi;
	R2 = toi64(toi32(R2));
	if (asi64(R1) >= asi64(R2)) goto L1834;
	R1 = 0;
	y = asi64(R1);
	goto L1824;
	goto L1833;
L1834:
	asi32(R1) = xi;
	R1 = toi64(toi32(R1));
	asi32(R2) = bi;
	R2 = toi64(toi32(R2));
	if (asi64(R1) <= asi64(R2)) goto L1835;
	goto L1832;
L1835:
L1833:
	i += 1; if (i <= av_1) goto L1830;
L1832:
L1828:
L1825:
	asi64(R1) = y;
	R2 = (u64)&k;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = y;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L1837;
	asi64(R1) = y;
	asi64(R2) = nb;
	asu64(R3) = b;
	asu64(R4) = e;
	asi64(R1) = qq_decimal_smallmulto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	ne = asi64(R1);
	asi64(R1) = ne;
	asi64(R2) = nx;
	asu64(R3) = e;
	asu64(R4) = x;
	asi64(R1) = qq_decimal_smallsubto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	nx = asi64(R1);
	goto L1836;
L1837:
	asi64(R1) = y;
	if (!asi64(R1)) goto L1838;
	asi64(R1) = nb;
	asi64(R2) = nx;
	asu64(R3) = b;
	asu64(R4) = x;
	asi64(R1) = qq_decimal_smallsubto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	nx = asi64(R1);
	goto L1836;
L1838:
	R1 = tou64("");
	R2 = tou64("smalldiv:Y=0");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1836:
	goto L1823;
L1824:
	asi64(R1) = esize;
	asu64(R2) = e;
	qq_decimal_freesmall(asu64(R2), asi64(R1));
	asi64(R1) = nx;
	asu64(R2) = xlen;
	*toi64p(R2) = asi64(R1);
	asi64(R1) = k;
	goto L1822;
L1822:
	return asi64(R1);
}

static i64 qq_decimal_smallsubto(u64 p, u64 q, i64 plen, i64 qlen) {
    u64 R1, R2, R3; 
	u64 pp;
	u64 qq;
	i64 carry;
	i64 diff;
	i64 z;
	i64 av_1;
	i64 av_2;
	asu64(R1) = p;
	asi64(R2) = plen;
	R1 += (i64)R2*4;
	R2 = 1;
	R1 -= (i64)R2*4;
	pp = asu64(R1);
	asu64(R1) = q;
	asi64(R2) = qlen;
	R1 += (i64)R2*4;
	R2 = 1;
	R1 -= (i64)R2*4;
	qq = asu64(R1);
	R1 = 0;
	carry = asi64(R1);
	R1 = 0;
	z = asi64(R1);
	asi64(R1) = plen;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1842;
L1840:
	asu64(R1) = qq;
	asu64(R2) = q;
	if (asu64(R1) < asu64(R2)) goto L1844;
	asu64(R1) = pp;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	asu64(R2) = qq;
	asi32(R2) = *toi32p(R2);
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	asi64(R2) = carry;
	asi64(R1) -= asi64(R2);
	diff = asi64(R1);
	R1 = (u64)&qq;
	(*tou64p(R1)) -=4;
	goto L1843;
L1844:
	asu64(R1) = pp;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	asi64(R2) = carry;
	asi64(R1) -= asi64(R2);
	diff = asi64(R1);
L1843:
	asi64(R1) = diff;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L1846;
	R1 = 1;
	carry = asi64(R1);
	asi64(R1) = diff;
	R2 = 1000000000;
	asi64(R1) += asi64(R2);
	asu64(R2) = pp;
	*toi32p(R2) = asi32(R1);
	goto L1845;
L1846:
	asi64(R1) = diff;
	asu64(R2) = pp;
	*toi32p(R2) = asi32(R1);
	R1 = 0;
	carry = asi64(R1);
L1845:
	asu64(R1) = pp;
	asi32(R1) = *toi32p(R1);
	if (!asi32(R1)) goto L1848;
	R1 = 0;
	z = asi64(R1);
	goto L1847;
L1848:
	R1 = (u64)&z;
	(*toi64p(R1)) += 1;
L1847:
	R1 = (u64)&pp;
	(*tou64p(R1)) -=4;
	if (--asi64(av_1)) goto L1840;
L1842:
	asi64(R1) = carry;
	if (!asi64(R1)) goto L1850;
	R1 = tou64("");
	R2 = tou64("SSUBTO/CARRY?");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1850:
	asi64(R1) = z;
	asi64(R2) = plen;
	if (asi64(R1) != asi64(R2)) goto L1852;
	R1 = (u64)&z;
	(*toi64p(R1)) -=1;
L1852:
	asi64(R1) = z;
	if (!asi64(R1)) goto L1854;
	asi64(R1) = z;
	R2 = (u64)&plen;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = p;
	pp = asu64(R1);
	asu64(R1) = p;
	asi64(R2) = z;
	R1 += (i64)R2*4;
	qq = asu64(R1);
	asi64(R1) = plen;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1857;
L1855:
	R1 = (u64)&qq;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 4; asu64(R1) = asu64(R2);
	asi32(R1) = *toi32p(R1);
	R2 = (u64)&pp;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 4; asu64(R2) = asu64(R3);
	*toi32p(R2) = asi32(R1);
	if (--asi64(av_2)) goto L1855;
L1857:
L1854:
	asi64(R1) = plen;
	goto L1839;
L1839:
	return asi64(R1);
}

static i64 qq_decimal_bn_getprec(u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 9;
	asi64(R1) *= asi64(R2);
	goto L1858;
L1858:
	return asi64(R1);
}

static void qq_decimal_bn_setprec(u64 a, i64 prec) {
    u64 R1, R2, R3; 
	i64 oldlength;
	i64 newlength;
	u64 c;
	i64 av_1;
	i64 i;
	asu64(R1) = a;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1861;
	goto L1859;
L1861:
	asi64(R1) = prec;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1864;
	asi64(R1) = prec;
	R2 = 10000000;
	if (asi64(R1) <= asi64(R2)) goto L1863;
L1864:
	goto L1859;
L1863:
	asi64(R1) = prec;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = 9;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 9;
	asi64(R1) *= asi64(R2);
	prec = asi64(R1);
	asi64(R1) = prec;
	R2 = 9;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	newlength = asi64(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	oldlength = asi64(R1);
	asi64(R1) = oldlength;
	asi64(R2) = newlength;
	if (asi64(R1) > asi64(R2)) goto L1866;
	goto L1859;
L1866:
	asi64(R1) = newlength;
	asu64(R1) = qq_decimal_makebignum(asi64(R1));
	c = asu64(R1);
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = c;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = c;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = newlength;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1869;
L1867:
	asi64(R1) = i;
	asi64(R2) = oldlength;
	if (asi64(R1) >= asi64(R2)) goto L1871;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	asu64(R2) = c;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	goto L1870;
L1871:
	R1 = 0;
	asu64(R2) = c;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L1870:
	i += 1; if (i <= av_1) goto L1867;
L1869:
	asu64(R1) = c;
	asu64(R2) = a;
	qq_decimal_bn_move(asu64(R2), asu64(R1));
	asu64(R1) = c;
	qq_decimal_obj_free_dec(asu64(R1));
L1859:
	return;
}

static i64 qq_decimal_bn_getglobalprec() {
    u64 R1, R2; 
	asi64(R1) = qq_decimal_currprec;
	R2 = 9;
	asi64(R1) *= asi64(R2);
	goto L1872;
L1872:
	return asi64(R1);
}

static void qq_decimal_bn_setglobalprec(i64 prec) {
    u64 R1, R2; 
	asi64(R1) = prec;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = 9;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	qq_decimal_currprec = asi64(R1);
	return;
}

static u64 qq_decimal_bn_makefloat(r64 x) {
    u64 R1, R2; 
	u64 a;
	struct $B23 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64(".15g");
	asr64(R2) = x;
	msysc_m$print_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = (u64)&str;
	asu64(R1) = qq_decimal_bn_makestr(asu64(R2), asi64(R1));
	goto L1874;
L1874:
	return asu64(R1);
}

static u64 qq_decimal_dectemp(u64 a) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	R1 = 259;
	R2 = (u64)&qq_decimal_vtemp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1877;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1878;
	goto L1879;
L1877:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_decimal_bn_makeint(asi64(R1));
	R2 = (u64)&qq_decimal_vtemp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1876;
L1878:
	asu64(R1) = a;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_decimal_bn_makefloat(asr64(R1));
	R2 = (u64)&qq_decimal_vtemp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1876;
L1879:
	R1 = tou64("");
	R2 = tou64("dectemp");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1876:
	(R1_B3) = qq_decimal_vtemp;
	asu64(R2) = a;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = a;
	goto L1875;
L1875:
	return asu64(R1);
}

static void qq_decimal_freedectemp() {
    u64 R1, R2; 
	R1 = (u64)&qq_decimal_vtemp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_decimal_obj_free_dec(asu64(R1));
	return;
}

static void qq_decimal_bn_ipower(u64 d, u64 a, i64 n) {
    u64 R1, R2, R3; 
	u64 e;
	u64 f;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L1883;
	asu64(R1) = d;
	qq_decimal_bn_setzero(asu64(R1));
	goto L1882;
L1883:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1884;
	R1 = 1;
	asu64(R1) = qq_decimal_bn_makeint(asi64(R1));
	asu64(R2) = d;
	qq_decimal_bn_move(asu64(R2), asu64(R1));
	goto L1882;
L1884:
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1885;
	asu64(R1) = a;
	asu64(R2) = d;
	qq_decimal_bn_dupl(asu64(R2), asu64(R1));
	goto L1882;
L1885:
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1886;
	asu64(R1) = qq_decimal_bn_init();
	e = asu64(R1);
	asu64(R1) = a;
	asu64(R2) = a;
	asu64(R3) = e;
	qq_decimal_bn_mulu(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = 2;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = e;
	asu64(R3) = d;
	qq_decimal_bn_ipower(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = e;
	qq_decimal_obj_free_dec(asu64(R1));
	goto L1882;
L1886:
	asu64(R1) = qq_decimal_bn_init();
	e = asu64(R1);
	asu64(R1) = qq_decimal_bn_init();
	f = asu64(R1);
	asu64(R1) = a;
	asu64(R2) = a;
	asu64(R3) = e;
	qq_decimal_bn_mulu(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = 2;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = e;
	asu64(R3) = f;
	qq_decimal_bn_ipower(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = f;
	asu64(R2) = a;
	asu64(R3) = d;
	qq_decimal_bn_mulu(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = e;
	qq_decimal_obj_free_dec(asu64(R1));
	asu64(R1) = f;
	qq_decimal_obj_free_dec(asu64(R1));
L1882:
	return;
}

static void qq_decimal_var_power_dec(u64 a, i64 n) {
    u64 R1, R2, R3; 
	u64 dest;
	asu64(R1) = qq_decimal_bn_init();
	dest = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	qq_decimal_bn_ipower(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = dest;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static i64 qq_decimal_var_convert_dec_int(u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = qq_decimal_bn_toint(asu64(R1));
	goto L1888;
L1888:
	return asi64(R1);
}

static i64 qq_decimal_bn_toint(u64 a) {
    u64 R1, R2, R3; 
	i64 x;
	i64 av_1;
	i64 av_2;
	i64 i;
	asu64(R1) = a;
	asi64(R1) = qq_decimal_bn_isint(asu64(R1));
	if (asi64(R1)) goto L1891;
	R1 = tou64("");
	R2 = tou64("dec-float->int not ready");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	R1 = 0;
	goto L1889;
L1891:
	asu64(R1) = a;
	asi64(R1) = qq_decimal_bn_iszero(asu64(R1));
	if (!asi64(R1)) goto L1893;
	R1 = 0;
	goto L1889;
L1893:
	R1 = 0;
	x = asi64(R1);
	R1 = 0;
	i = asi64(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1896;
L1894:
	asi64(R1) = x;
	R2 = 1000000000;
	asi64(R1) *= asi64(R2);
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	x = asi64(R1);
	i += 1; if (i <= av_1) goto L1894;
L1896:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	i = asi64(R1);
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	av_2 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_2;
	if (asi64(R1) > asi64(R2)) goto L1899;
L1897:
	R1 = 1000000000;
	R2 = (u64)&x;
	*toi64p(R2) *= asi64(R1);
	i += 1; if (i <= av_2) goto L1897;
L1899:
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L1901;
	asi64(R1) = x;
	asi64(R1) = -asi64(R1);
	goto L1900;
L1901:
	asi64(R1) = x;
L1900:
	goto L1889;
L1889:
	return asi64(R1);
}

static void qq_dicts_var_make_dict(u64 a, u64 dest, i64 n) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 p;
	u64 b;
	struct $B3 v;
	i64 av_1;
	asi64(R1) = n;
	asu64(R1) = qq_dicts_obj_new_dict(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	R1 = 262;
	R2 = (u64)&v;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	R2 = (u64)&v;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1905;
L1903:
	asu64(R1) = a;
	R2 = 1;
	R1 += (i64)R2*16;
	asu64(R2) = a;
	R3 = (u64)&v;
	qq_dicts_adddictitem(asu64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	R2 = (u64)&a;
	*tou64p(R2) += asu64(R1)*16;
	if (--asi64(av_1)) goto L1903;
L1905:
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 28;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	(R1_B3) = v;
	asu64(R2) = dest;
	*(struct $B3*)(R2) = (R1_B3);
	return;
}

static u64 qq_dicts_obj_new_dict(i64 n) {
    u64 R1, R2, R3; 
	u64 p;
	i64 m;
	R1 = 16;
	asi64(R2) = n;
	R3 = 2;
	asi64(R2) *= asi64(R3);
	asi64(R2) = qq_lib_nextpoweroftwo(asi64(R2));
	asi64(R1) = Max(asi64(R1), asi64(R2));
	m = asi64(R1);
	R1 = 0;
	R2 = 1;
	asi64(R3) = m;
	asu64(R1) = qq_lists_obj_newlist(asi64(R3), asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L1906;
L1906:
	return asu64(R1);
}

static void qq_dicts_obj_free_dict(u64 p, i64 internal) {
    u64 R1, R2, R3; 
	u64 q;
	struct $B3 v;
	i64 av_1;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1910;
L1908:
	asu64(R1) = q;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1912;
	asu64(R1) = q;
	qq_vars_var_unshareu(asu64(R1));
L1912:
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L1908;
L1910:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L1914;
	asu64(R1) = p;
	R2 = 24;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L1914:
	asi64(R1) = internal;
	if (asi64(R1)) goto L1916;
	asu64(R1) = p;
	mlib_pcm_free32(asu64(R1));
L1916:
	return;
}

static void qq_dicts_var_dupl_dict(u64 a) {
    u64 R1, R2, R3, R4; struct $B31 R1_B31; struct $B3 R1_B3; 
	u64 p;
	u64 q;
	u64 plist;
	u64 qlist;
	i64 av_1;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 28;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R1) = qq_dicts_obj_new_dict(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	(R1_B31) = *(struct $B31*)(R1);
	asu64(R2) = q;
	*(struct $B31*)(R2) = (R1_B31);
	R1 = 1;
	asu64(R2) = q;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	asu64(R2) = q;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1919;
	goto L1917;
L1919:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	asu64(R3) = q;
	R4 = 8;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	qlist = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = 16;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = q;
	R3 = 24;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	plist = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1922;
L1920:
	asu64(R1) = plist;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = qlist;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = qlist;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1924;
	asu64(R1) = qlist;
	qq_vars_var_duplu(asu64(R1));
L1924:
	R1 = (u64)&qlist;
	(*tou64p(R1)) += 16;
	R1 = (u64)&plist;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L1920;
L1922:
L1917:
	return;
}

static i64 qq_dicts_var_equal_dict(u64 x, u64 y) {
    u64 R1, R2; 
	i64 xlen;
	i64 ylen;
	i64 res;
	u64 px;
	u64 py;
	u64 a;
	u64 b;
	R1 = tou64("");
	R2 = tou64("EQUALDICT");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	R1 = 1;
	goto L1925;
L1925:
	return asi64(R1);
}

static u64 qq_dicts_var_finddictitem(u64 vd, u64 p, i64 doins) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	i64 hash;
	i64 index;
	i64 size;
	i64 keytag;
	i64 wrapped;
	i64 limit;
	i64 keyvalue;
	u64 q;
	u64 pa;
	u64 qa;
	u64 d;
// qq_dicts.var_finddictitem.retry:
L1927:
	asu64(R1) = vd;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	size = asi64(R1);
	asu64(R1) = p;
	asi64(R1) = qq_vars_var_gethashvalue(asu64(R1));
	asi64(R2) = size;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) &= asi64(R2);
	index = asi64(R1);
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = index;
	R3 = 2;
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2*16;
	q = asu64(R1);
	R1 = 0;
	wrapped = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	keytag = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	keyvalue = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
L1928:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1931;
	goto L1929;
	goto L1930;
L1931:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = keytag;
	if (asi64(R1) != asi64(R2)) goto L1932;
	asi64(R1) = keytag;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1934;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1934;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1934;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L1935;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L1936;
	goto L1937;
L1934:
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = keyvalue;
	if (asi64(R1) != asi64(R2)) goto L1939;
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
	asu64(R1) = q;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1941;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L1941:
	asu64(R1) = q;
	goto L1926;
L1939:
	goto L1933;
L1935:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qa = asu64(R1);
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = qa;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L1943;
	asu64(R1) = pa;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = qa;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = pa;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1945;
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
	asu64(R1) = q;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1947;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L1947:
	asu64(R1) = q;
	goto L1926;
L1945:
L1943:
	goto L1933;
L1936:
	asu64(R1) = q;
	asu64(R2) = p;
	asi64(R1) = qq_records_var_equal_record(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L1949;
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
	asu64(R1) = q;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1951;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L1951:
	asu64(R1) = q;
	goto L1926;
L1949:
	goto L1933;
L1937:
L1933:
L1932:
L1930:
	R1 = (u64)&index;
	(*toi64p(R1)) += 1;
	R1 = 2;
	R2 = (u64)&q;
	*tou64p(R2) += asu64(R1)*16;
	asi64(R1) = index;
	asi64(R2) = size;
	if (asi64(R1) < asi64(R2)) goto L1953;
	asi64(R1) = wrapped;
	if (!asi64(R1)) goto L1955;
	R1 = tou64("");
	R2 = tou64("DICT FULL?");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1955:
	R1 = 1;
	wrapped = asi64(R1);
	R1 = 0;
	index = asi64(R1);
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L1953:
	goto L1928;
L1929:
	asi64(R1) = doins;
	if (!asi64(R1)) goto L1957;
	asi64(R1) = size;
	R2 = 3;
	asi64(R1) *= asi64(R2);
	R2 = 4;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	limit = asi64(R1);
	asu64(R1) = d;
	R2 = 28;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asi64(R2) = limit;
	if (asi64(R1) < asi64(R2)) goto L1959;
	asu64(R1) = vd;
	qq_dicts_expanddict(asu64(R1));
	goto L1927;
L1959:
	asu64(R1) = p;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = q;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = q;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1961;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L1961:
	asu64(R1) = d;
	R2 = 28;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	asu64(R1) = q;
	R2 = 1;
	R1 += (i64)R2*16;
	goto L1956;
L1957:
	R1 = 0;
L1956:
	goto L1926;
L1926:
	return asu64(R1);
}

static void qq_dicts_expanddict(u64 vd) {
    u64 R1, R2, R3; struct $B3 R1_B3; struct $B31 R1_B31; 
	i64 n;
	i64 m;
	i64 i;
	i64 j;
	i64 k;
	i64 oldrefcount;
	u64 d;
	u64 e;
	struct $B31 temp;
	u64 p;
	u64 q;
	u64 r;
	struct $B3 ev;
	asu8(R1) = qq_dicts_expanddict_inuse;
	if (!asu8(R1)) goto L1964;
	R1 = tou64("");
	R2 = tou64("expanddict?");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1964:
	R1 = 1;
	qq_dicts_expanddict_inuse = asu8(R1);
	asu64(R1) = vd;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 24;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 2;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	m = asi64(R1);
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asi64(R1) = m;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	asu64(R1) = qq_dicts_obj_new_dict(asi64(R1));
	e = asu64(R1);
	R1 = (u64)&ev;
	asu64(R2) = e;
	R3 = 6;
	qq_vars_var_objtovar(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	q = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = m;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1967;
L1965:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1969;
	R1 = 1;
	asu64(R2) = q;
	R3 = (u64)&ev;
	asu64(R1) = qq_dicts_var_finddictitem(asu64(R3), asu64(R2), asi64(R1));
	r = asu64(R1);
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
	R1 = (u64)&q;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 16; asu64(R1) = asu64(R2);
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = r;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = r;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1971;
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L1971:
	goto L1968;
L1969:
	R1 = 2;
	R2 = (u64)&q;
	*tou64p(R2) += asu64(R1)*16;
L1968:
	i += 1; if (i <= m) goto L1965;
L1967:
	R1 = 1;
	asu64(R2) = d;
	qq_dicts_obj_free_dict(asu64(R2), asi64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	oldrefcount = asi64(R1);
	asu64(R1) = e;
	(R1_B31) = *(struct $B31*)(R1);
	asu64(R2) = d;
	*(struct $B31*)(R2) = (R1_B31);
	R1 = 8;
	asu64(R2) = e;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asi64(R1) = oldrefcount;
	asu64(R2) = d;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	qq_dicts_expanddict_inuse = asu8(R1);
	return;
}

static void qq_dicts_adddictitem(u64 d, u64 p, u64 q) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 da;
	u64 r;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	da = asu64(R1);
	asu64(R1) = da;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1974;
	R1 = tou64("");
	R2 = tou64("NULL DICT");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1974:
	R1 = 1;
	asu64(R2) = p;
	asu64(R3) = d;
	asu64(R1) = qq_dicts_var_finddictitem(asu64(R3), asu64(R2), asi64(R1));
	r = asu64(R1);
	asu64(R1) = q;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1976;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L1976:
	asu64(R1) = r;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1978;
	asu64(R1) = r;
	qq_vars_var_unshareu(asu64(R1));
L1978:
	asu64(R1) = q;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = r;
	*(struct $B3*)(R2) = (R1_B3);
	return;
}

static u64 qq_host_callhostfunction(i64 hostfn, u64 sp) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 fnaddr;
	i64 nparams;
	i64 isfn;
	u64 p;
	i64 av_1;
	R1 = (u64)&qq_tables_hosthandlers;
	asi64(R2) = hostfn;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	fnaddr = asu64(R1);
	R1 = (u64)&qq_tables_hostnparams;
	asi64(R2) = hostfn;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	nparams = asi64(R1);
	R1 = (u64)&qq_tables_hostisfn;
	asi64(R2) = hostfn;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	isfn = asi64(R1);
	asu64(R1) = fnaddr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1981;
	R1 = (u64)&qq_tables_hostfnnames;
	asi64(R2) = hostfn;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("Hostfn not implemented:");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1981:
	asi64(R1) = nparams;
	asi64(R2) = isfn;
	asi64(R1) += asi64(R2);
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1983;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1984;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1985;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1986;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1987;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1988;
	goto L1989;
L1983:
	asu64(R1) = fnaddr;
	((F17)R1)();
	goto L1982;
L1984:
	asu64(R1) = sp;
	asu64(R2) = fnaddr;
	((F18)R2)(asu64(R1));
	goto L1982;
L1985:
	asu64(R1) = sp;
	R2 = 1;
	R1 -= (i64)R2*16;
	asu64(R2) = sp;
	asu64(R3) = fnaddr;
	((F19)R3)(asu64(R2), asu64(R1));
	goto L1982;
L1986:
	asu64(R1) = sp;
	R2 = 2;
	R1 -= (i64)R2*16;
	asu64(R2) = sp;
	R3 = 1;
	R2 -= (i64)R3*16;
	asu64(R3) = sp;
	asu64(R4) = fnaddr;
	((F20)R4)(asu64(R3), asu64(R2), asu64(R1));
	goto L1982;
L1987:
	asu64(R1) = sp;
	R2 = 3;
	R1 -= (i64)R2*16;
	asu64(R2) = sp;
	R3 = 2;
	R2 -= (i64)R3*16;
	asu64(R3) = sp;
	R4 = 1;
	R3 -= (i64)R4*16;
	asu64(R4) = sp;
	asu64(R5) = fnaddr;
	((F21)R5)(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L1982;
L1988:
	asu64(R1) = sp;
	R2 = 4;
	R1 -= (i64)R2*16;
	asu64(R2) = sp;
	R3 = 3;
	R2 -= (i64)R3*16;
	asu64(R3) = sp;
	R4 = 2;
	R3 -= (i64)R4*16;
	asu64(R4) = sp;
	R5 = 1;
	R4 -= (i64)R5*16;
	asu64(R5) = sp;
	asu64(R6) = fnaddr;
	((F22)R6)(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L1982;
L1989:
	R1 = tou64("");
	R2 = tou64("callhost/proc");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1982:
	asi64(R1) = nparams;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1992;
L1990:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1994;
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1996;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L1996:
L1994:
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	if (--asi64(av_1)) goto L1990;
L1992:
	asu64(R1) = sp;
	goto L1979;
L1979:
	return asu64(R1);
}

static void qq_host_pch_leftstr(u64 a, u64 b, u64 c, u64 result) {
    u64 R1, R2, R3, R4; 
	i64 n;
	i64 length;
	i64 padchar;
	u64 s;
	u64 pa;
	R1 = 32;
	padchar = asi64(R1);
	asu64(R1) = c;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1999;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2000;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2001;
	goto L2002;
L1999:
	goto L1998;
L2000:
	asu64(R1) = c;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2004;
	asu64(R1) = c;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	padchar = asi64(R1);
	goto L2003;
L2004:
	R1 = tou64("");
	R2 = tou64("left/padx");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2003:
	goto L1998;
L2001:
	asu64(R1) = c;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	padchar = asi64(R1);
	goto L1998;
L2002:
	R1 = tou64("");
	R2 = tou64("left/pad?");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1998:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2006;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2007;
	goto L2008;
L2006:
	R1 = 1;
	n = asi64(R1);
	goto L2005;
L2007:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	goto L2005;
L2008:
	R1 = tou64("");
	R2 = tou64("left:bad n");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2005:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2010;
	R1 = tou64("");
	R2 = tou64("left:not str");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2010:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2012;
	R1 = 1;
	asu64(R2) = result;
	qq_strings_var_empty_string(asu64(R2), asi64(R1));
	goto L1997;
L2012:
	R1 = 265;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2014;
	asi64(R1) = n;
	asi64(R2) = length;
	if (asi64(R1) > asi64(R2)) goto L2016;
	asu64(R1) = result;
	asi64(R2) = n;
	asu64(R3) = a;
	qq_host_leftstring(asu64(R3), asi64(R2), asu64(R1));
	goto L2015;
L2016:
	asu64(R1) = result;
	asi64(R2) = padchar;
	asi64(R3) = n;
	asu64(R4) = a;
	qq_host_padstring_right(asu64(R4), asi64(R3), asi64(R2), asu64(R1));
L2015:
	goto L2013;
L2014:
	asi64(R1) = n;
	asi64(R1) = -asi64(R1);
	n = asi64(R1);
	asi64(R1) = n;
	asi64(R2) = length;
	if (asi64(R1) >= asi64(R2)) goto L2018;
	asu64(R1) = result;
	asi64(R2) = length;
	asi64(R3) = n;
	asi64(R2) -= asi64(R3);
	asu64(R3) = a;
	qq_host_leftstring(asu64(R3), asi64(R2), asu64(R1));
	goto L2017;
L2018:
	R1 = 1;
	asu64(R2) = result;
	qq_strings_var_empty_string(asu64(R2), asi64(R1));
L2017:
L2013:
L1997:
	return;
}

static void qq_host_pch_rightstr(u64 a, u64 b, u64 c, u64 result) {
    u64 R1, R2, R3, R4; 
	i64 n;
	i64 length;
	i64 padchar;
	u64 s;
	u64 pa;
	R1 = 32;
	padchar = asi64(R1);
	asu64(R1) = c;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2021;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2022;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2023;
	goto L2024;
L2021:
	goto L2020;
L2022:
	asu64(R1) = c;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2026;
	asu64(R1) = c;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	padchar = asi64(R1);
	goto L2025;
L2026:
	R1 = tou64("");
	R2 = tou64("right/padx");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2025:
	goto L2020;
L2023:
	asu64(R1) = c;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	padchar = asi64(R1);
	goto L2020;
L2024:
	R1 = tou64("");
	R2 = tou64("right/pad?");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2020:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2028;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2029;
	goto L2030;
L2028:
	R1 = 1;
	n = asi64(R1);
	goto L2027;
L2029:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	goto L2027;
L2030:
	R1 = tou64("");
	R2 = tou64("right:bad n");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2027:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2032;
	R1 = tou64("");
	R2 = tou64("right:not str");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2032:
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	R1 = 265;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2034;
	R1 = 1;
	asu64(R2) = result;
	qq_strings_var_empty_string(asu64(R2), asi64(R1));
	goto L2019;
L2034:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2036;
	asi64(R1) = n;
	asi64(R2) = length;
	if (asi64(R1) > asi64(R2)) goto L2038;
	asu64(R1) = result;
	asi64(R2) = n;
	asu64(R3) = a;
	qq_host_rightstring(asu64(R3), asi64(R2), asu64(R1));
	goto L2037;
L2038:
	asu64(R1) = result;
	asi64(R2) = padchar;
	asi64(R3) = n;
	asu64(R4) = a;
	qq_host_padstring_left(asu64(R4), asi64(R3), asi64(R2), asu64(R1));
L2037:
	goto L2035;
L2036:
	asi64(R1) = n;
	asi64(R1) = -asi64(R1);
	n = asi64(R1);
	asi64(R1) = n;
	asi64(R2) = length;
	if (asi64(R1) >= asi64(R2)) goto L2040;
	asu64(R1) = result;
	asi64(R2) = length;
	asi64(R3) = n;
	asi64(R2) -= asi64(R3);
	asu64(R3) = a;
	qq_host_rightstring(asu64(R3), asi64(R2), asu64(R1));
	goto L2039;
L2040:
	R1 = 1;
	asu64(R2) = result;
	qq_strings_var_empty_string(asu64(R2), asi64(R1));
L2039:
L2035:
L2019:
	return;
}

static void qq_host_pch_convlc(u64 a, u64 b, u64 result) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	R1 = -999999;
	R2 = 9;
	asu64(R3) = a;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = result;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = result;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
	asu64(R1) = result;
	qq_vars_var_duplu(asu64(R1));
	R1 = 0;
	asu64(R2) = b;
	asu64(R3) = result;
	qq_strings_var_iconvcase(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_host_pch_convuc(u64 a, u64 b, u64 result) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	R1 = -999999;
	R2 = 9;
	asu64(R3) = a;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = result;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = result;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
	asu64(R1) = result;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2044;
	asu64(R1) = result;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2046;
	asu64(R1) = result;
	qq_vars_var_duplu(asu64(R1));
L2046:
L2044:
	R1 = 1;
	asu64(R2) = b;
	asu64(R3) = result;
	qq_strings_var_iconvcase(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_host_pch_waitkey(u64 result) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mlinux_os_getch();
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_pch_execwait(u64 a, u64 b, u64 c, u64 result) {
    u64 R1, R2, R3, R4, R5; 
	u64 workdir;
	i64 flag;
	u64 pa;
	R1 = -999999;
	R2 = 9;
	asu64(R3) = a;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	R1 = 0;
	R2 = 1;
	asu64(R3) = b;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	flag = asi64(R1);
	asu64(R1) = c;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2050;
	R1 = 0;
	workdir = asu64(R1);
	goto L2049;
L2050:
	R1 = -999999;
	R2 = 9;
	asu64(R3) = c;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = c;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = c;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_lib_convtostringz(asu64(R2), asi64(R1));
	workdir = asu64(R1);
L2049:
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = workdir;
	asi64(R2) = flag;
	asu64(R3) = pa;
	R4 = 16;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asu64(R4) = pa;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R3) = qq_lib_convtostringz(asu64(R4), asi64(R3));
	asi64(R1) = mlinux_os_execwait(asu64(R3), asi64(R2), asu64(R1));
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_pch_execcmd(u64 a, u64 b, u64 c, u64 result) {
    u64 R1, R2, R3, R4; 
	u64 workdir;
	i64 flag;
	u64 pa;
	R1 = -999999;
	R2 = 9;
	asu64(R3) = a;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	R1 = 0;
	R2 = 1;
	asu64(R3) = b;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	flag = asi64(R1);
	asu64(R1) = c;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2053;
	R1 = 0;
	workdir = asu64(R1);
	goto L2052;
L2053:
	R1 = -999999;
	R2 = 9;
	asu64(R3) = c;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = c;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = c;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_lib_convtostringz(asu64(R2), asi64(R1));
	workdir = asu64(R1);
L2052:
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = flag;
	asu64(R2) = pa;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = pa;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R2) = qq_lib_convtostringz(asu64(R3), asi64(R2));
	asi64(R1) = mlinux_os_execcmd(asu64(R2), asi64(R1));
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_pch_makestr(u64 a, u64 b, u64 result) {
    u64 R1, R2, R3; 
	i64 n;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L2056;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2057;
	goto L2058;
L2056:
	goto L2055;
L2057:
	goto L2055;
L2058:
	R1 = tou64("");
	R2 = tou64("makestr");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2055:
	asu64(R1) = b;
	asi64(R1) = qq_vars_var_getintvalue(asu64(R1));
	n = asi64(R1);
	R1 = 265;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_strings_obj_make_strslicexobj(asu64(R2), asi64(R1));
	asu64(R2) = result;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_host_pch_makeref(u64 a, u64 b, u64 result) {
    u64 R1, R2, R3; 
	u64 ptr;
	R1 = (u64)&qq_tables_ttbasetype;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L2061;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L2061;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2061;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2062;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2062;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L2062;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2062;
	goto L2063;
L2061:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ptr = asu64(R1);
	goto L2060;
L2062:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ptr = asu64(R1);
	goto L2060;
L2063:
	R1 = tou64("");
	R2 = tou64("makeref");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2060:
	R1 = 16;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = ptr;
	asu64(R2) = result;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = b;
	asi64(R1) = qq_vars_var_getintvalue(asu64(R1));
	asu64(R2) = result;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = result;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L2065;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L2065;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L2065;
	goto L2066;
L2065:
	R1 = 15;
	asu64(R2) = result;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = result;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = result;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2064;
L2066:
L2064:
	return;
}

static void qq_host_pch_getcmdparam(u64 a, u64 result) {
    u64 R1, R2, R3, R4; 
	i64 n;
	u64 s;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2069;
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = qq_decls_nqparams;
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L2067;
L2069:
	asu64(R1) = a;
	asi64(R1) = qq_vars_var_getintvalue(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2072;
	asi64(R2) = qq_decls_nqparams;
	if (asi64(R1) <= asi64(R2)) goto L2071;
L2072:
	R1 = tou64("");
	R2 = tou64("getcmdpm");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2071:
	R1 = 0;
	asu64(R2) = result;
	R3 = (u64)&qq_decls_qparamtable;
	asi64(R4) = n;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	qq_strings_var_make_string(asu64(R3), asu64(R2), asi64(R1));
L2067:
	return;
}

static void qq_host_pch_clock(u64 result) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mlinux_os_clock();
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_pch_allocexec(u64 a, u64 result) {
    u64 R1, R2, R3; 
	i64 n;
	u64 p;
	asu64(R1) = a;
	asi64(R1) = qq_vars_var_getintvalue(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R1) = mlinux_os_allocexecmem(asi64(R1));
	p = asu64(R1);
	R1 = 16;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = result;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 27;
	asu64(R2) = result;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	return;
}

static void qq_host_pch_runnative(u64 a, u64 b, u64 result) {
    u64 R1, R2, R3; 
	i64 n;
	u64 fnptr;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L2077;
	R1 = tou64("");
	R2 = tou64("runnative?");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2077:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fnptr = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = fnptr;
	asi64(R1) = ((F2)R2)(asi64(R1));
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	return;
}

static void qq_host_pch_setlwb(u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 n;
	u64 p;
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2080;
	goto L2081;
L2080:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L2083;
	qq_lib_pcnotmut();
L2083:
	R1 = -999999;
	R2 = 1;
	asu64(R3) = b;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L2085;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2086;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L2086;
	goto L2087;
L2085:
	asi64(R1) = n;
	R2 = -32768;
	if (asi64(R1) < asi64(R2)) goto L2090;
	R2 = 32767;
	if (asi64(R1) <= asi64(R2)) goto L2089;
L2090:
	R1 = tou64("");
	R2 = tou64("lwb not i16");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2089:
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 6;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L2084;
L2086:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L2093;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L2092;
L2093:
	R1 = tou64("");
	R2 = tou64("lwb not 0/1");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2092:
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L2084;
L2087:
// qq_host.pch_setlwb.error:
L2081:
	R1 = tou64("");
	R2 = tou64("Can't set lwb");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2084:
	return;
}

static void qq_host_pch_ticks(u64 result) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mlinux_os_ticks();
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_pch_sleep(u64 a) {
    u64 R1, R2, R3; 
	R1 = -999999;
	R2 = 1;
	asu64(R3) = a;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mlinux_os_sleep(asi64(R1));
	return;
}

static void qq_host_pch_random(u64 a, u64 result) {
    u64 R1, R2, R3, R4; 
	i64 n;
	i64 x;
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2098;
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 16;
	R4 = 63;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R1) = mlib_mrandomrange(asi64(R2), asi64(R1));
	x = asi64(R1);
	goto L2097;
L2098:
	R1 = -999999;
	R2 = 1;
	asu64(R3) = a;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L2100;
	asi64(R1) = n;
	asi64(R1) = mlib_mrandomint(asi64(R1));
	x = asi64(R1);
	goto L2099;
L2100:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2101;
	asi64(R1) = mlib_mrandom();
	x = asi64(R1);
	goto L2099;
L2101:
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2102;
	R1 = 2;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asr64(R1) = mlib_mrandomreal();
	asu64(R2) = result;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L2096;
	goto L2099;
L2102:
	R1 = 0;
	asi64(R2) = n;
	asi64(R2) = -asi64(R2);
	mlib_mseed(asu64(R2), asu64(R1));
	R1 = 0;
	x = asi64(R1);
L2099:
L2097:
	asi64(R1) = x;
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2096:
	return;
}

static void qq_host_pch_system(u64 a, u64 result) {
    u64 R1, R2, R3; 
	R1 = -999999;
	R2 = 9;
	asu64(R3) = a;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_lib_convtostringz(asu64(R2), asi64(R1));
	asi32(R1) = system(asu64(R1));
	R1 = toi64(toi32(R1));
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_pch_$getparam(u64 a, u64 result) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	R1 = -999999;
	R2 = 1;
	asu64(R3) = a;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = qq_decls_frameptr;
	asu64(R2) = a;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 16;
	asi64(R2) *= asi64(R3);
	R1 -= (i64)R2;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = result;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = result;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2106;
	asu64(R1) = result;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L2106:
	return;
}

static i64 qq_host_checkparam(u64 p, i64 tag, i64 defaultx) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2109;
	asi64(R2) = tag;
	if (asi64(R1) == asi64(R2)) goto L2110;
	goto L2111;
L2109:
	asi64(R1) = defaultx;
	R2 = -999999;
	if (asi64(R1) != asi64(R2)) goto L2113;
	R1 = tou64("");
	R2 = tou64("Missing host param");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2113:
	asi64(R1) = defaultx;
	goto L2107;
	goto L2108;
L2110:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L2107;
	goto L2108;
L2111:
L2108:
	asi64(R1) = tag;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2115;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2117;
	goto L2118;
L2117:
	asu64(R1) = p;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = toi64(asr64(R1));
	goto L2107;
	goto L2116;
L2118:
L2116:
L2115:
	msysc_m$print_startcon();
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("Host param wrong type");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	R1 = 0;
	goto L2107;
L2107:
	return asi64(R1);
}

static void qq_host_leftstring(u64 a, i64 n, u64 result) {
    u64 R1, R2, R3, R4, R5; 
	u64 p;
	R1 = 1;
	asu64(R2) = result;
	asi64(R3) = n;
	asu64(R4) = a;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_host_rightstring(u64 a, i64 n, u64 result) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 p;
	R1 = 1;
	asu64(R2) = result;
	asi64(R3) = n;
	asu64(R4) = a;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R5) = a;
	R6 = 8;
	asu64(R5) = *tou64p(((i64)R5+(i64)R6));
	R6 = 16;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6));
	asi64(R6) = n;
	asi64(R5) -= asi64(R6);
	R4 += (i64)R5;
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_host_padstring_right(u64 a, i64 n, i64 fillchar, u64 result) {
    u64 R1, R2, R3; 
	u64 s;
	i64 length;
	i64 av_1;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asu64(R1) = result;
	asi64(R2) = n;
	qq_strings_var_new_stringn(asi64(R2), asu64(R1));
	asu64(R1) = result;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L2123;
	asi64(R1) = length;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = length;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
L2123:
	asi64(R1) = n;
	asi64(R2) = length;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2126;
L2124:
	asi64(R1) = fillchar;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L2124;
L2126:
	return;
}

static void qq_host_padstring_left(u64 a, i64 n, i64 fillchar, u64 result) {
    u64 R1, R2, R3, R4; 
	u64 s;
	i64 length;
	i64 padlen;
	i64 av_1;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asi64(R1) = n;
	asi64(R2) = length;
	asi64(R1) -= asi64(R2);
	padlen = asi64(R1);
	R1 = 0;
	asu64(R2) = result;
	asi64(R3) = n;
	R4 = 0;
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	asu64(R1) = result;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asi64(R1) = padlen;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L2129;
	asi64(R1) = length;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L2129:
	asi64(R1) = padlen;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2132;
L2130:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	asi64(R1) = fillchar;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	if (--asi64(av_1)) goto L2130;
L2132:
	return;
}

static void qq_host_getbounds(u64 p, u64 dims, i64 lower) {
    u64 R1, R2, R3, R4; 
	i64 n;
	asu64(R1) = p;
	if (asu64(R1)) goto L2135;
	R1 = tou64("");
	R2 = tou64("New: no bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2135:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2137;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2138;
	goto L2139;
L2137:
	asi64(R1) = lower;
	asu64(R2) = dims;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	asu64(R2) = dims;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	asu64(R2) = dims;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L2136;
L2138:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	R3 = 63;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = dims;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = dims;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 16;
	R4 = 63;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = dims;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = dims;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L2141;
	R1 = 0;
	asu64(R2) = dims;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = dims;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = dims;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2141:
	goto L2136;
L2139:
	asu64(R1) = p;
	asi64(R1) = qq_vars_var_getintvalue(asu64(R1));
	n = asi64(R1);
	asi64(R1) = lower;
	asu64(R2) = dims;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = n;
	R2 = R1;
	asu64(R3) = dims;
	R4 = 16;
	*toi64p(((i64)R3+(i64)R4)) = asi64(R2);
	asu64(R2) = dims;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2136:
	return;
}

static void qq_host_pch_new(u64 a, u64 b, u64 c, u64 d, u64 result) {
    u64 R1, R2, R3, R4, R5; struct $B3 R1_B3; 
	struct $B3 v;
	i64 i;
	i64 t;
	i64 nbytes;
	i64 ival;
	i64 nwords;
	i64 nbits;
	i64 offset;
	i64 elemtype;
	i64 n;
	i64 usertag;
	struct $B8 dims;
	u64 qvar;
	u64 qint;
	u64 qbyte;
	u64 ptr;
	u64 p;
	i64 av_1;
	i64 av_2;
	asu64(R1) = a;
	asi64(R1) = qq_vars_var_getintvalue(asu64(R1));
	t = asi64(R1);
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L2145;
	asi64(R1) = t;
	asi64(R2) = qq_tables_ntypes;
	if (asi64(R1) <= asi64(R2)) goto L2144;
L2145:
	asi64(R1) = t;
	R2 = tou64("New:bad type");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L2144:
	asi64(R1) = t;
	R2 = 256;
	asi64(R1) |= asi64(R2);
	R2 = (u64)&v;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	usertag = asi64(R1);
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	switch (asi64(R1)) {
	case 1: case 2: case 14: goto L2186;
	case 3: goto L2192;
	case 4: goto L2148;
	case 5: goto L2177;
	case 6: goto L2189;
	case 7: goto L2163;
	case 8: goto L2164;
	case 9: goto L2149;
	case 10: goto L2150;
	case 11: goto L2151;
	case 12: goto L2182;
	case 13: goto L2183;
	default: goto L2148;
    };
// SWITCH
L2149:
	asu64(R1) = result;
	asu64(R2) = c;
	asu64(R3) = b;
	qq_strings_var_new_string(asu64(R3), asu64(R2), asu64(R1));
	goto L2142;
	goto L2146;
L2150:
	R1 = 1;
	R2 = (u64)&dims;
	asu64(R3) = b;
	qq_host_getbounds(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = c;
	R2 = (u64)&dims;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = (u64)&dims;
	R4 = 16;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asu64(R1) = qq_lists_obj_newlist(asi64(R3), asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&v;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L2146;
L2151:
	asu64(R1) = b;
	asi64(R1) = qq_vars_var_getintvalue(asu64(R1));
	elemtype = asi64(R1);
	R1 = 1;
	R2 = (u64)&dims;
	asu64(R3) = c;
	qq_host_getbounds(asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = elemtype;
	R2 = 33;
	if (asi64(R1) < asi64(R2)) goto L2153;
	asi64(R1) = elemtype;
	R2 = 35;
	if (asi64(R1) > asi64(R2)) goto L2153;
	R1 = 8;
	R2 = R1;
	t = asi64(R2);
	R2 = (u64)&v;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2154;
L2153:
	R1 = (u64)&dims;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&dims;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R3) = elemtype;
	asu64(R1) = qq_arrays_obj_newarray(asi64(R3), asi64(R2), asi64(R1));
	p = asu64(R1);
// qq_host.pch_new.doarray2:
L2155:
	asu64(R1) = p;
	R2 = (u64)&v;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&dims;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L2157;
	asu64(R1) = d;
	if (!asu64(R1)) goto L2159;
	asu64(R1) = d;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2159;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qbyte = asu64(R1);
	R1 = (u64)&dims;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2162;
L2160:
	asi64(R1) = elemtype;
	asu64(R2) = d;
	asu64(R3) = qbyte;
	qq_packed_var_storepacked(asu64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = elemtype;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&qbyte;
	*tou64p(R2) += asu64(R1);
	if (--asi64(av_1)) goto L2160;
L2162:
L2159:
L2157:
	goto L2146;
L2163:
	asi64(R1) = t;
	usertag = asi64(R1);
	R1 = 7;
	R2 = (u64)&v;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemtype = asi64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&dims;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&qq_tables_ttlower;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&dims;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&dims;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&dims;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&dims;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = b;
	d = asu64(R1);
	asi64(R1) = t;
	asu64(R1) = qq_arrays_obj_newarray_u(asi64(R1));
	p = asu64(R1);
	goto L2155;
	goto L2146;
L2164:
	asu64(R1) = b;
	asi64(R1) = qq_vars_var_getintvalue(asu64(R1));
	elemtype = asi64(R1);
	asi64(R1) = elemtype;
	R2 = 33;
	if (asi64(R1) < asi64(R2)) goto L2167;
	R2 = 35;
	if (asi64(R1) <= asi64(R2)) goto L2166;
L2167:
	R1 = tou64("");
	R2 = tou64("new: bad bits elem");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2166:
	R1 = 1;
	R2 = (u64)&dims;
	asu64(R3) = c;
	qq_host_getbounds(asu64(R3), asu64(R2), asi64(R1));
// qq_host.pch_new.dobits2:
L2154:
	R1 = (u64)&dims;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&dims;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R3) = elemtype;
	asu64(R1) = qq_bits_obj_newbits(asi64(R3), asi64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&v;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&dims;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L2169;
	asu64(R1) = d;
	if (!asu64(R1)) goto L2171;
	asu64(R1) = d;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2171;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qbyte = asu64(R1);
	R1 = 0;
	offset = asi64(R1);
	R1 = (u64)&dims;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2174;
L2172:
	R1 = 0;
	asi64(R2) = elemtype;
	asu64(R3) = d;
	asi64(R4) = offset;
	asu64(R5) = qbyte;
	qq_vars_var_storebit(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&qq_tables_ttbitwidth;
	asi64(R2) = elemtype;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = offset;
	R2 = 8;
	if (asi64(R1) < asi64(R2)) goto L2176;
	R1 = 0;
	offset = asi64(R1);
	R1 = (u64)&qbyte;
	(*tou64p(R1)) += 1;
L2176:
	if (--asi64(av_2)) goto L2172;
L2174:
L2171:
L2169:
	goto L2146;
L2177:
	R1 = 0;
	R2 = (u64)&dims;
	asu64(R3) = b;
	qq_host_getbounds(asu64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&dims;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L2179;
	R1 = tou64("");
	R2 = tou64("new:set:lwb");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2179:
	R1 = (u64)&dims;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2181;
	R1 = 0;
	R2 = (u64)&dims;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&dims;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&dims;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2181:
	R1 = (u64)&dims;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_sets_obj_newset(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&v;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L2146;
L2182:
	asu64(R1) = b;
	asi64(R2) = t;
	asu64(R1) = qq_records_obj_new_record(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&v;
	asu64(R2) = p;
	asi64(R3) = t;
	qq_vars_var_fromobj(asi64(R3), asu64(R2), asu64(R1));
	R1 = 12;
	R2 = (u64)&v;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = t;
	usertag = asi64(R1);
	goto L2146;
L2183:
	asi64(R1) = t;
	asu64(R1) = qq_packed_obj_new_struct(asi64(R1));
	p = asu64(R1);
	R1 = (u64)&v;
	asu64(R2) = p;
	asi64(R3) = t;
	qq_vars_var_objtovar(asi64(R3), asu64(R2), asu64(R1));
	R1 = 13;
	R2 = (u64)&v;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = t;
	usertag = asi64(R1);
	asu64(R1) = b;
	if (!asu64(R1)) goto L2185;
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2185;
	R1 = tou64("");
	R2 = tou64("New: struct init");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2185:
	goto L2146;
L2186:
	R1 = 0;
	R2 = (u64)&v;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	R2 = (u64)&v;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = b;
	if (!asu64(R1)) goto L2188;
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2188;
	R1 = tou64("");
	R2 = tou64("NEW(int/value)");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2188:
	goto L2146;
L2189:
	R1 = 1;
	R2 = (u64)&dims;
	asu64(R3) = b;
	qq_host_getbounds(asu64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&dims;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2191;
	R1 = tou64("");
	R2 = tou64("new:dict:lwb");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2191:
	R1 = (u64)&dims;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_dicts_obj_new_dict(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&v;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L2146;
L2192:
	asu64(R1) = result;
	qq_decimal_var_empty_dec(asu64(R1));
	goto L2142;
	goto L2146;
L2148:
	asi64(R1) = t;
	R2 = tou64("new");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L2146:
// qq_host.pch_new.finish:
	asi64(R1) = usertag;
	if (!asi64(R1)) goto L2195;
	asi64(R1) = usertag;
	R2 = (u64)&v;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
L2195:
	(R1_B3) = v;
	asu64(R2) = result;
	*(struct $B3*)(R2) = (R1_B3);
L2142:
	return;
}

static void qq_host_pch_gethostname(u64 result) {
    u64 R1, R2, R3; 
	asu64(R1) = mlinux_os_gethostname();
	R2 = (u64)&qq_host_pch_gethostname_name;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = result;
	R3 = (u64)&qq_host_pch_gethostname_name;
	qq_strings_var_make_string(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_host_pch_getprogname(u64 result) {
    u64 R1, R2, R3; 
	asu64(R1) = qq_cli_inputfile;
	R2 = (u64)&qq_host_pch_getprogname_name;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = result;
	R3 = (u64)&qq_host_pch_getprogname_name;
	qq_strings_var_make_string(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_host_pch_$test(u64 a, u64 b, u64 c, u64 result) {
    u64 R1, R2, R3; 
	u64 p;
	msysc_m$print_startcon();
	R1 = tou64("$TEST:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asu64(R2) = c;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_pch_$test2(u64 a, u64 result) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	return;
}

static void qq_host_pch_$refcount(u64 a, u64 result) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2202;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L2201;
L2202:
	R1 = 0;
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2201:
	return;
}

static void qq_host_pch_testkey(u64 result) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mlinux_os_kbhit();
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_pch_getos(u64 result) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = result;
	asu64(R3) = mlinux_os_getos();
	qq_strings_var_make_string(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_host_pch_setmesshandler(u64 fn) {
    u64 R1, R2; 
	asu64(R1) = fn;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L2208;
	asu64(R1) = fn;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2207;
L2208:
	R1 = tou64("");
	R2 = tou64("Not proc ref");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2207:
	asu64(R1) = fn;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_decls_pcl_callbackfn = asu64(R1);
	R1 = (u64)&qq_runaux_runproc_m;
	mlinux_os_setmesshandler(asu64(R1));
	return;
}

static void qq_host_pch_$smallmemtotal(u64 result) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mlib_smallmemtotal;
	R2 = 16;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_pch_$id(u64 a, u64 result) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_pch_iswindows(u64 result) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mlinux_os_iswindows();
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_pch_$setdebug(u64 a) {
    u64 R1, R2, R3; 
	R1 = -999999;
	R2 = 1;
	asu64(R3) = a;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	msysc_m$print_startcon();
	R1 = tou64("SETDEBUG.................");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mlib_fdebug = asi64(R1);
	return;
}

static void qq_host_pch_copy(u64 a, u64 dest) {
    u64 R1, R2; struct $B3 R1_B3; 
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = dest;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = dest;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2215;
	asu64(R1) = dest;
	qq_vars_var_duplu(asu64(R1));
L2215:
	return;
}

static void qq_host_pch_gethash(u64 a, u64 result) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	asi64(R1) = qq_vars_var_gethashvalue(asu64(R1));
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_pch_makeempty(u64 a, u64 result) {
    u64 R1, R2, R3, R4; 
	u64 p;
	i64 t;
	R1 = (u64)&qq_tables_ttbasetype;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	asi64(R1) = t;
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L2219;
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	t = asi64(R1);
L2219:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asi64(R1) = t;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L2221;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2222;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2223;
	goto L2224;
L2221:
	asu64(R1) = result;
	asu64(R2) = p;
	R3 = 6;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	qq_lists_var_empty_list(asi64(R2), asu64(R1));
	goto L2217;
	goto L2220;
L2222:
	asu64(R1) = qq_strings_emptystring;
	p = asu64(R1);
	asu64(R1) = p;
	(*tou32p(R1)) += 1;
	goto L2220;
L2223:
	asu64(R1) = result;
	asu64(R2) = p;
	R3 = 4;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 0;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	asu64(R3) = p;
	R4 = 6;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	asi64(R4) = t;
	qq_arrays_var_empty_array(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	goto L2217;
	goto L2220;
L2224:
	asi64(R1) = t;
	R2 = tou64("makeempty?");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L2220:
	asi64(R1) = t;
	R2 = 256;
	asi64(R1) |= asi64(R2);
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = result;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L2217:
	return;
}

static void qq_host_pch_$infinity(u64 dest) {
    u64 R1; 
	asu64(R1) = dest;
	qq_decimal_var_setinf(asu64(R1));
	return;
}

static void qq_host_pch_$nan(u64 dest) {
    u64 R1; 
	asu64(R1) = dest;
	qq_decimal_var_setnan(asu64(R1));
	return;
}

static void qq_host_setcmdparam(i64 index, u64 s) {
    u64 R1, R2, R3; 
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2229;
	asi64(R1) = index;
	qq_decls_nqparams = asi64(R1);
	goto L2228;
L2229:
	asi64(R1) = index;
	R2 = 32;
	if (asi64(R1) > asi64(R2)) goto L2230;
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&qq_decls_qparamtable;
	asi64(R3) = index;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = index;
	R2 = (u64)&qq_decls_nqparams;
    *toi64p(R2) = Max(*toi64p(R2), asi64(R1));
L2230:
L2228:
	return;
}

static void qq_host_pch_$nprocs(u64 result) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = qq_decls_nproclist;
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_initprocrefs() {
    u64 R1, R2, R3; 
	u64 pp;
	i64 i;
	asi64(R1) = qq_host_initprocrefs_oldnprocs;
	asi64(R2) = qq_decls_nproclist;
	if (asi64(R1) != asi64(R2)) goto L2234;
	goto L2232;
L2234:
	asi64(R1) = qq_decls_nproclist;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	qq_host_procrefs = asu64(R1);
	asu64(R1) = qq_decls_proclist;
	pp = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nproclist;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2237;
L2235:
	asu64(R1) = pp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = qq_host_procrefs;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pp = asu64(R1);
	i += 1; if (i <= qq_decls_nproclist) goto L2235;
L2237:
	asi64(R1) = qq_decls_nproclist;
	qq_host_initprocrefs_oldnprocs = asi64(R1);
L2232:
	return;
}

static void qq_host_pch_$procname(u64 a, u64 result) {
    u64 R1, R2, R3, R4; 
	i64 n;
	R1 = -999999;
	R2 = 1;
	asu64(R3) = a;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	qq_host_initprocrefs();
	R1 = 0;
	asu64(R2) = result;
	asu64(R3) = qq_host_procrefs;
	asi64(R4) = n;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_strings_var_make_string(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_host_pch_$procref(u64 a, u64 result) {
    u64 R1, R2, R3; 
	i64 n;
	u64 pp;
	R1 = -999999;
	R2 = 1;
	asu64(R3) = a;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	qq_host_initprocrefs();
	R1 = 17;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = qq_host_procrefs;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = result;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_host_pch_$getstdinout(u64 a, u64 result) {
    u64 R1, R2, R3; 
	i64 n;
	R1 = -999999;
	R2 = 1;
	asu64(R3) = a;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	R1 = 16;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2242;
	asu64(R1) = mlinux_os_getstdout();
	goto L2241;
L2242:
	asu64(R1) = mlinux_os_getstdin();
L2241:
	asu64(R2) = result;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = result;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	return;
}

static void qq_lex_lexreadtoken() {
    u64 R1, R2, R3, R4; 
	i64 c;
	i64 csum;
	i64 hsum;
	i64 commentseen;
	u64 pstart;
	u64 pnext;
	u64 p;
	u64 ss;
	R1 = 0;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2244:
	asu64(R1) = qq_lex_lxsptr;
	qq_lex_lxstart = asu64(R1);
	R1 = (u64)&qq_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 0: case 26: goto L2366;
	case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 11: case 12: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 27: case 28: case 29: case 30: case 31: goto L2247;
	case 9: case 32: goto L2363;
	case 10: goto L2365;
	case 13: goto L2364;
	case 33: case 35: goto L2273;
	case 34: goto L2361;
	case 36: case 95: case 97: case 98: case 99: case 100: case 101: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 117: case 118: case 119: case 120: case 121: case 122: goto L2248;
	case 37: goto L2339;
	case 38: goto L2356;
	case 39: goto L2360;
	case 40: goto L2319;
	case 41: goto L2320;
	case 42: goto L2335;
	case 43: goto L2327;
	case 44: goto L2308;
	case 45: goto L2330;
	case 46: goto L2300;
	case 47: goto L2338;
	case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L2264;
	case 58: goto L2310;
	case 59: goto L2309;
	case 60: goto L2345;
	case 61: goto L2340;
	case 62: goto L2351;
	case 63: goto L2326;
	case 64: goto L2325;
	case 65: case 66: case 67: case 68: case 69: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: goto L2256;
	case 70: goto L2261;
	case 91: goto L2321;
	case 92: goto L2281;
	case 93: goto L2322;
	case 94: goto L2324;
	case 96: goto L2362;
	case 102: goto L2258;
	case 123: goto L2298;
	case 124: goto L2323;
	case 125: goto L2299;
	default: goto L2247;
    };
// SWITCH
L2248:
// qq_lex.lexreadtoken.dolower:
L2249:
	asu64(R1) = qq_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
// qq_lex.lexreadtoken.doname:
L2250:
	R1 = (u64)&qq_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	hsum = asi64(R1);
L2251:
	R1 = (u64)&qq_lex_namemap;
	R2 = (u64)&qq_lex_lxsptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	R3 = R2;
	c = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2253;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2254;
	goto L2255;
L2253:
	asi64(R1) = hsum;
	R2 = 4;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	hsum = asi64(R1);
	goto L2251;
L2254:
	asi64(R1) = c;
	R2 = 32;
	asu64(R1) += asu64(R2);
	asu64(R2) = qq_lex_lxsptr;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = hsum;
	R2 = 4;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 32;
	asi64(R1) += asi64(R2);
	hsum = asi64(R1);
	goto L2251;
L2255:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2252;
	goto L2251;
L2252:
	asi64(R1) = hsum;
	R2 = 5;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	R2 = 32767;
	asi64(R1) &= asi64(R2);
	asu64(R2) = qq_lex_lxsptr;
	R3 = (u64)&qq_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R2) -= asi64(R3);
	R3 = (u64)&qq_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R1) = qq_lex_lookup(asu64(R3), asi64(R2), asi64(R1));
	goto L2243;
	goto L2244;
L2256:
// qq_lex.lexreadtoken.doupper:
L2257:
	asu64(R1) = qq_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 32;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*tou8p(R2) += asu8(R1);
	goto L2250;
	goto L2244;
L2258:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L2260;
	goto L2249;
L2260:
	qq_lex_readrawstring();
	goto L2243;
	goto L2244;
L2261:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L2263;
	goto L2257;
L2263:
	qq_lex_readrawstring();
	goto L2243;
	goto L2244;
L2264:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 41;
	if (asu64(R1) == asu64(R2)) goto L2266;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L2266;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L2266;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L2266;
	R2 = 120;
	if (asu64(R1) == asu64(R2)) goto L2267;
	R2 = 88;
	if (asu64(R1) == asu64(R2)) goto L2267;
	goto L2268;
L2266:
	R1 = 63;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = qq_lex_lxstart;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 48;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L2265;
L2267:
	asu64(R1) = qq_lex_lxstart;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) == asu64(R2)) goto L2270;
	R2 = 50;
	if (asu64(R1) == asu64(R2)) goto L2271;
	goto L2272;
L2270:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	qq_lex_readhex();
	goto L2269;
L2271:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	qq_lex_readbin();
	goto L2269;
L2272:
	R1 = tou64("Bad base");
	qq_lib_lxerror(asu64(R1));
L2269:
	goto L2265;
L2268:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	qq_lex_readdec();
L2265:
	goto L2243;
	goto L2244;
L2273:
// qq_lex.lexreadtoken.docomment:
L2275:
	R1 = (u64)&qq_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L2277;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L2278;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L2279;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2279;
	goto L2280;
L2277:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&qq_lex_lxlineno;
	(*toi64p(R1)) += 1;
	goto L2276;
	goto L2275;
L2278:
	R1 = (u64)&qq_lex_lxlineno;
	(*toi64p(R1)) += 1;
	goto L2276;
	goto L2275;
L2279:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2276;
	goto L2275;
L2280:
	goto L2275;
L2276:
	R1 = 61;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2243;
	goto L2244;
L2281:
	R1 = 0;
	commentseen = asi64(R1);
L2282:
	R1 = (u64)&qq_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L2284;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L2285;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L2286;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L2286;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L2287;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L2287;
	R2 = 33;
	if (asu64(R1) == asu64(R2)) goto L2288;
	goto L2289;
L2284:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&qq_lex_lxlineno;
	(*toi64p(R1)) += 1;
	goto L2283;
	goto L2282;
L2285:
	R1 = (u64)&qq_lex_lxlineno;
	(*toi64p(R1)) += 1;
	goto L2283;
	goto L2282;
L2286:
	R1 = 62;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2243;
	goto L2282;
L2287:
	goto L2282;
L2288:
	R1 = 1;
	commentseen = asi64(R1);
	goto L2282;
L2289:
	asi64(R1) = commentseen;
	if (asi64(R1)) goto L2291;
	R1 = tou64("\\ not followed by eol");
	qq_lib_lxerror(asu64(R1));
L2291:
	goto L2282;
L2283:
L2292:
	R1 = (u64)&qq_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L2294;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L2295;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L2296;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L2296;
	goto L2297;
L2294:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&qq_lex_lxlineno;
	(*toi64p(R1)) += 1;
	goto L2292;
L2295:
	R1 = (u64)&qq_lex_lxlineno;
	(*toi64p(R1)) += 1;
	goto L2292;
L2296:
	goto L2292;
L2297:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2293;
	goto L2292;
L2293:
	goto L2244;
L2298:
	R1 = 13;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2243;
	goto L2244;
L2299:
	R1 = 14;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2243;
	goto L2244;
L2300:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L2302;
	goto L2303;
L2302:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L2305;
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 21;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2304;
L2305:
	R1 = 20;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 87;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2304:
	goto L2243;
	goto L2301;
L2303:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L2307;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L2307;
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	qq_lex_readreal();
	goto L2243;
	goto L2306;
L2307:
	R1 = 2;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2243;
L2306:
L2301:
	goto L2244;
L2308:
	R1 = 3;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2243;
	goto L2244;
L2309:
	R1 = 4;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2243;
	goto L2244;
L2310:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L2312;
	R2 = 58;
	if (asu64(R1) == asu64(R2)) goto L2313;
	goto L2314;
L2312:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 6;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2311;
L2313:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L2316;
	goto L2317;
L2316:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 6;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2315;
L2317:
	goto L2318;
L2315:
	goto L2311;
L2314:
	R1 = 5;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2311:
	goto L2243;
	goto L2244;
L2319:
	R1 = 9;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2243;
	goto L2244;
L2320:
	R1 = 10;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2243;
	goto L2244;
L2321:
	R1 = 11;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2243;
	goto L2244;
L2322:
	R1 = 12;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2243;
	goto L2244;
L2323:
	R1 = 16;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2243;
	goto L2244;
L2324:
	R1 = 15;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2243;
	goto L2244;
L2325:
	R1 = 17;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2243;
	goto L2244;
L2326:
	R1 = 18;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2243;
	goto L2244;
L2327:
	R1 = 22;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 101;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) != asu64(R2)) goto L2329;
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 60;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2329:
	goto L2243;
	goto L2244;
L2330:
	R1 = 23;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 102;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L2332;
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L2333;
	goto L2334;
L2332:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 60;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2331;
L2333:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 8;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2331;
L2334:
L2331:
	goto L2243;
	goto L2244;
L2335:
	R1 = 24;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 103;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 42;
	if (asu64(R1) != asu64(R2)) goto L2337;
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 41;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 121;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2337:
	goto L2243;
	goto L2244;
L2338:
	R1 = 25;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 104;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2243;
	goto L2244;
L2339:
	R1 = 26;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 105;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2243;
	goto L2244;
L2340:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L2342;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L2343;
	goto L2344;
L2342:
	R1 = 7;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L2341;
L2343:
	R1 = 42;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 120;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L2341;
L2344:
	R1 = 43;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2341:
	goto L2243;
	goto L2244;
L2345:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L2347;
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L2348;
	R2 = 60;
	if (asu64(R1) == asu64(R2)) goto L2349;
	goto L2350;
L2347:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 46;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2346;
L2348:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 44;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2346;
L2349:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 34;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 111;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2346;
L2350:
	R1 = 45;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 2;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2346:
	goto L2243;
	goto L2244;
L2351:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L2353;
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L2354;
	goto L2355;
L2353:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 47;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2352;
L2354:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 35;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 112;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2352;
L2355:
	R1 = 48;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 5;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2352:
	goto L2243;
	goto L2244;
L2356:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 38;
	if (asu64(R1) == asu64(R2)) goto L2358;
	goto L2359;
L2358:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 38;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 118;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2357;
L2359:
	R1 = 19;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2357:
	goto L2243;
	goto L2244;
L2360:
	R1 = 39;
	qq_lex_lxreadstring(asi64(R1));
	goto L2243;
	goto L2244;
L2361:
	R1 = 34;
	qq_lex_lxreadstring(asi64(R1));
	goto L2243;
	goto L2244;
L2362:
	qq_lex_readrawxname();
	goto L2243;
	goto L2244;
L2363:
	goto L2244;
L2364:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&qq_lex_lxlineno;
	(*toi64p(R1)) += 1;
	R1 = 61;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2243;
	goto L2244;
L2365:
	R1 = 61;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&qq_lex_lxlineno;
	(*toi64p(R1)) += 1;
	goto L2243;
	goto L2244;
L2366:
	R1 = 62;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2243;
	goto L2244;
L2247:
	asu64(R1) = qq_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 226;
	if (asi64(R1) != asi64(R2)) goto L2368;
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 136;
	if (asi64(R1) != asi64(R2)) goto L2368;
	asu64(R1) = qq_lex_lxsptr;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 154;
	if (asi64(R1) != asi64(R2)) goto L2368;
	R1 = 2;
	R2 = (u64)&qq_lex_lxsptr;
	*tou64p(R2) += asu64(R1);
	R1 = 55;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2243;
L2368:
	asi64(R1) = c;
	R2 = 128;
	if (asi64(R1) < asi64(R2)) goto L2370;
	goto L2250;
L2370:
// qq_lex.lexreadtoken.error:
L2318:
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = c;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L2243;
	goto L2244;
L2243:
	return;
}

static void qq_lex_lxreadstring(i64 termchar) {
    u64 R1, R2, R3, R4; 
	u64 s;
	u64 t;
	i64 c;
	i64 d;
	i64 length;
	i64 hasescape;
	i64 a;
	i64 n;
	u64 str;
	i64 pass;
	asi64(R1) = termchar;
	R2 = 34;
	if (asi64(R1) != asi64(R2)) goto L2373;
	R1 = 67;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2372;
L2373:
	R1 = 66;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2372:
	R1 = 0;
	length = asi64(R1);
	R1 = 0;
	hasescape = asi64(R1);
	R1 = 0;
	t = asu64(R1);
	R1 = 1;
	pass = asi64(R1);
L2374:
	asu64(R1) = qq_lex_lxsptr;
	s = asu64(R1);
L2377:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L2380;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L2381;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L2381;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L2382;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L2382;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2382;
	goto L2383;
L2380:
	R1 = 1;
	hasescape = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L2385;
	asi64(R1) = c;
	R2 = 90;
	if (asi64(R1) > asi64(R2)) goto L2385;
	R1 = 32;
	R2 = (u64)&c;
	*toi64p(R2) += asi64(R1);
L2385:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) == asi64(R2)) goto L2387;
	R2 = 98;
	if (asi64(R1) == asi64(R2)) goto L2388;
	R2 = 99;
	if (asi64(R1) == asi64(R2)) goto L2389;
	R2 = 114;
	if (asi64(R1) == asi64(R2)) goto L2389;
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L2390;
	R2 = 102;
	if (asi64(R1) == asi64(R2)) goto L2391;
	R2 = 104;
	if (asi64(R1) == asi64(R2)) goto L2392;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L2393;
	R2 = 110;
	if (asi64(R1) == asi64(R2)) goto L2393;
	R2 = 116;
	if (asi64(R1) == asi64(R2)) goto L2394;
	R2 = 117;
	if (asi64(R1) == asi64(R2)) goto L2395;
	R2 = 118;
	if (asi64(R1) == asi64(R2)) goto L2395;
	R2 = 119;
	if (asi64(R1) == asi64(R2)) goto L2396;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L2397;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L2398;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L2399;
	goto L2400;
L2387:
	R1 = 7;
	c = asi64(R1);
	goto L2386;
L2388:
	R1 = 8;
	c = asi64(R1);
	goto L2386;
L2389:
	R1 = 13;
	c = asi64(R1);
	goto L2386;
L2390:
	R1 = 27;
	c = asi64(R1);
	goto L2386;
L2391:
	R1 = 12;
	c = asi64(R1);
	goto L2386;
L2392:
	goto L2402;
L2401:
	R1 = 1;
	R2 = 2;
	R3 = (u64)&s;
	asi64(R1) = qq_lex_readhexcode(asu64(R3), asi64(R2), asi64(R1));
	c = asi64(R1);
	asi64(R1) = pass;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2405;
	asi64(R1) = c;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L2405:
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
L2402:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) != asu64(R2)) goto L2401;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&t;
	(*tou64p(R1)) -=1;
	goto L2386;
L2393:
	R1 = 10;
	c = asi64(R1);
	goto L2386;
L2394:
	R1 = 9;
	c = asi64(R1);
	goto L2386;
L2395:
	asi64(R1) = pass;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2407;
	asu64(R1) = t;
	goto L2406;
L2407:
	R1 = 0;
L2406:
	R2 = 0;
	asi64(R3) = c;
	R4 = 117;
	if (asi64(R3) != asi64(R4)) goto L2409;
	R3 = 4;
	goto L2408;
L2409:
	R3 = 6;
L2408:
	R4 = (u64)&s;
	asi64(R2) = qq_lex_readhexcode(asu64(R4), asi64(R3), asi64(R2));
	asi64(R1) = qq_lex_getutf8(asi64(R2), asu64(R1));
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	goto L2377;
	goto L2386;
L2396:
	asi64(R1) = pass;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2411;
	R1 = 13;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L2411:
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	R1 = 10;
	c = asi64(R1);
	goto L2386;
L2397:
	R1 = 0;
	R2 = 2;
	R3 = (u64)&s;
	asi64(R1) = qq_lex_readhexcode(asu64(R3), asi64(R2), asi64(R1));
	c = asi64(R1);
	goto L2386;
L2398:
	R1 = 16;
	c = asi64(R1);
	goto L2386;
L2399:
	R1 = 0;
	c = asi64(R1);
	goto L2386;
L2400:
	asi64(R1) = c;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L2413;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L2414;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L2415;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L2416;
	goto L2417;
L2413:
	R1 = 34;
	c = asi64(R1);
	goto L2412;
L2414:
	R1 = 92;
	c = asi64(R1);
	goto L2412;
L2415:
	R1 = 39;
	c = asi64(R1);
	goto L2412;
L2416:
	R1 = 0;
	c = asi64(R1);
	goto L2412;
L2417:
	asi64(R1) = c;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&str;
	R2 = tou64("Unknown string escape: #");
	qq_lex_lxerror_s(asu64(R2), asu64(R1));
L2412:
L2386:
	goto L2379;
L2381:
	asi64(R1) = c;
	asi64(R2) = termchar;
	if (asi64(R1) != asi64(R2)) goto L2419;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	asi64(R2) = c;
	if (asi64(R1) != asi64(R2)) goto L2421;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L2420;
L2421:
	goto L2378;
L2420:
L2419:
	R1 = 1;
	hasescape = asi64(R1);
	goto L2379;
L2382:
	R1 = tou64("String not terminated");
	qq_lib_lxerror(asu64(R1));
	goto L2379;
L2383:
L2379:
	asi64(R1) = pass;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2423;
	asi64(R1) = c;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L2423:
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	goto L2377;
L2378:
	asi64(R1) = pass;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2425;
	asu64(R1) = t;
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&qq_decls_nextlx;
	R3 = 14;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = hasescape;
	if (!asi64(R1)) goto L2427;
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	t = asu64(R2);
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L2426;
L2427:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2428;
	R1 = tou64("");
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = s;
	qq_lex_lxsptr = asu64(R1);
	goto L2371;
	goto L2426;
L2428:
	asi64(R1) = length;
	asu64(R2) = qq_lex_lxsptr;
	asu64(R1) = mlib_pcm_copyheapstringn(asu64(R2), asi64(R1));
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = s;
	qq_lex_lxsptr = asu64(R1);
	goto L2371;
L2426:
	goto L2424;
L2425:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = s;
	qq_lex_lxsptr = asu64(R1);
L2424:
	pass += 1; if (pass <= 2) goto L2374;
L2371:
	return;
}

static i64 qq_lex_readhexcode(u64 s, i64 n, i64 sp) {
    u64 R1, R2; 
	i64 a;
	i64 c;
	i64 i;
	R1 = 0;
	a = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2432;
L2430:
	asi64(R1) = sp;
	if (!asi64(R1)) goto L2434;
	asi64(R1) = i;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L2434;
L2435:
	asu64(R1) = s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L2435;
	goto L2433;
L2434:
	asu64(R1) = s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
L2433:
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L2439;
	R2 = 70;
	if (asi64(R1) > asi64(R2)) goto L2439;
	asi64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 65;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asi64(R1) += asi64(R2);
	a = asi64(R1);
	goto L2438;
L2439:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L2440;
	R2 = 102;
	if (asi64(R1) > asi64(R2)) goto L2440;
	asi64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 97;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asi64(R1) += asi64(R2);
	a = asi64(R1);
	goto L2438;
L2440:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L2441;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L2441;
	asi64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	a = asi64(R1);
	goto L2438;
L2441:
	R1 = tou64("Bad hex digit");
	qq_lib_lxerror(asu64(R1));
L2438:
	i += 1; if (i <= n) goto L2430;
L2432:
	asi64(R1) = a;
	goto L2429;
L2429:
	return asi64(R1);
}

static i64 qq_lex_getutf8(i64 c, u64 s) {
    u64 R1, R2, R3, R4; 
	i64 n;
	struct $B3 str;
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2444;
	R1 = (u64)&str;
	s = asu64(R1);
L2444:
	asi64(R1) = c;
	R2 = 127;
	if (asi64(R1) > asi64(R2)) goto L2446;
	R1 = 1;
	n = asi64(R1);
	asi64(R1) = c;
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2445;
L2446:
	asi64(R1) = c;
	R2 = 2047;
	if (asi64(R1) > asi64(R2)) goto L2447;
	R1 = 2;
	n = asi64(R1);
	R1 = 192;
	asi64(R2) = c;
	R3 = 6;
	R4 = 10;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 0;
	R4 = 5;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2445;
L2447:
	asi64(R1) = c;
	R2 = 65535;
	if (asi64(R1) > asi64(R2)) goto L2448;
	R1 = 3;
	n = asi64(R1);
	R1 = 224;
	asi64(R2) = c;
	R3 = 12;
	R4 = 15;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 6;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 0;
	R4 = 5;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2445;
L2448:
	asi64(R1) = c;
	R2 = 1114111;
	if (asi64(R1) > asi64(R2)) goto L2449;
	R1 = 4;
	n = asi64(R1);
	R1 = 240;
	asi64(R2) = c;
	R3 = 18;
	R4 = 20;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 12;
	R4 = 17;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 6;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 0;
	R4 = 5;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2445;
L2449:
	R1 = 0;
	n = asi64(R1);
L2445:
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = n;
	goto L2442;
L2442:
	return asi64(R1);
}

static void qq_lex_lexinit() {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 4194304;
	R2 = 0;
	R3 = (u64)&qq_lex_hashtable;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = (u64)&qq_lex_hashtable;
	R2 = 4194176;
	R1 += (i64)R2;
	qq_lex_hashtablelast = asu64(R1);
	qq_lex_inithashtable();
	return;
}

static void qq_lex_readrawstring() {
    u64 R1, R2, R3; 
	u64 pstart;
	i64 length;
	R1 = 67;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&qq_lex_lxsptr;
	asu64(R1) = *(tou64p(R1)) += 1;
	pstart = asu64(R1);
	R1 = 0;
	length = asi64(R1);
L2452:
	R1 = (u64)&qq_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L2454;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L2455;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L2455;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L2455;
	goto L2456;
L2454:
	goto L2453;
	goto L2452;
L2455:
	R1 = tou64("Raw string not terminated");
	qq_lib_lxerror(asu64(R1));
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2453;
	goto L2452;
L2456:
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	goto L2452;
L2453:
	asi64(R1) = length;
	qq_lex_nextlxlength = asi64(R1);
	asi64(R1) = length;
	asu64(R2) = pstart;
	asu64(R1) = mlib_pcm_copyheapstringn(asu64(R2), asi64(R1));
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static i64 qq_lex_lookup(u64 name, i64 length, i64 hashindex) {
    u64 R1, R2, R3, R4; 
	i64 j;
	i64 wrapped;
	i64 n;
	u64 d;
	u64 s;
	R1 = (u64)&qq_lex_hashtable;
	asi64(R2) = hashindex;
	R1 += (i64)R2*128;
	d = asu64(R1);
	R1 = 0;
	wrapped = asi64(R1);
L2458:
	asu64(R1) = d;
	R2 = 126;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	n = asi64(R2);
	asi64(R2) = length;
	if (asi64(R1) != asi64(R2)) goto L2461;
	asi64(R1) = n;
	asu64(R2) = name;
	asu64(R3) = d;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2461;
	asu64(R1) = d;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 123;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 112;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	goto L2457;
	goto L2460;
L2461:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2462;
	goto L2459;
L2462:
L2460:
	R1 = (u64)&d;
	asu64(R1) = *(tou64p(R1)) += 128;
	asu64(R2) = qq_lex_hashtablelast;
	if (asu64(R1) <= asu64(R2)) goto L2464;
	asi64(R1) = wrapped;
	if (!asi64(R1)) goto L2466;
	R1 = tou64("HASHTABLE FULL");
	mlib_abortprogram(asu64(R1));
L2466:
	R1 = 1;
	wrapped = asi64(R1);
	R1 = (u64)&qq_lex_hashtable;
	R2 = 0;
	R1 += (i64)R2;
	d = asu64(R1);
L2464:
	goto L2458;
L2459:
	asi64(R1) = length;
	asu64(R2) = name;
	asu64(R1) = mlib_pcm_copyheapstringn(asu64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = d;
	R3 = 126;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 69;
	asu64(R2) = d;
	R3 = 123;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 123;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 112;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	goto L2457;
L2457:
	return asi64(R1);
}

static i64 qq_lex_gethashvaluez(u64 s) {
    u64 R1, R2; 
	i64 c;
	i64 hsum;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2469;
	R1 = 0;
	goto L2467;
L2469:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	hsum = asi64(R1);
L2470:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2473;
	goto L2471;
L2473:
	asi64(R1) = hsum;
	R2 = 4;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	hsum = asi64(R1);
	goto L2470;
L2471:
	asi64(R1) = hsum;
	R2 = 5;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	R2 = 32767;
	asi64(R1) &= asi64(R2);
	goto L2467;
L2467:
	return asi64(R1);
}

static void qq_lex_start() {
    u64 R1, R2, R3; 
	i64 av_1;
	i64 c;
	R1 = 0;
	c = asi64(R1);
	R1 = 255;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L2477;
L2475:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L2481;
	R2 = 122;
	if (asi64(R1) <= asi64(R2)) goto L2480;
L2481:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L2482;
	R2 = 57;
	if (asi64(R1) <= asi64(R2)) goto L2480;
L2482:
	asi64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L2480;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L2480;
	asi64(R1) = c;
	R2 = 128;
	if (asi64(R1) < asi64(R2)) goto L2479;
	R2 = 255;
	if (asi64(R1) > asi64(R2)) goto L2479;
L2480:
	R1 = 1;
	R2 = (u64)&qq_lex_namemap;
	asi64(R3) = c;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2478;
L2479:
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L2483;
	R2 = 90;
	if (asi64(R1) > asi64(R2)) goto L2483;
	R1 = 2;
	R2 = (u64)&qq_lex_namemap;
	asi64(R3) = c;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2483:
L2478:
	c += 1; if (c <= av_1) goto L2475;
L2477:
	return;
}

static void qq_lex_inithashtable() {
    u64 R1, R2, R3, R4; 
	i64 i;
	u64 name;
	i64 av_1;
	i64 av_2;
	R1 = 1;
	i = asi64(R1);
	R1 = 188;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2487;
L2485:
	R1 = (u64)&qq_tables_stsubcodes;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&qq_tables_stsymbols;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	R3 = (u64)&qq_tables_stnames;
	asi64(R4) = i;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	qq_lex_addstname(asu64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= av_1) goto L2485;
L2487:
	R1 = 1;
	i = asi64(R1);
	R1 = 60;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2490;
L2488:
	R1 = (u64)&qq_tables_hostinternal;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2492;
	R1 = (u64)&qq_tables_hostfnnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 2;
	R1 += (i64)R2;
	name = asu64(R1);
	asi64(R1) = i;
	R2 = 129;
	asu64(R3) = name;
	qq_lex_addstname(asu64(R3), asi64(R2), asi64(R1));
L2492:
	i += 1; if (i <= av_2) goto L2488;
L2490:
	return;
}

static void qq_lex_addstname(u64 name, i64 symbol, i64 subcode) {
    u64 R1, R2, R3; 
	asu64(R1) = name;
	asi64(R1) = qq_lex_gethashvaluez(asu64(R1));
	asu64(R2) = name;
	asi64(R2) = strlen(asu64(R2));
	asu64(R3) = name;
	asi64(R1) = qq_lex_lookup(asu64(R3), asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L2495;
	msysc_m$print_startcon();
	asu64(R1) = name;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Dupl ST entry");
	mlib_abortprogram(asu64(R1));
L2495:
	asi64(R1) = symbol;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 123;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = subcode;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 112;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	return;
}

static void qq_lex_startlex(u64 pm) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = pm;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = R1;
	qq_lex_lxsptr = asu64(R2);
	qq_lex_lxsource = asu64(R1);
	R1 = 4;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pm;
	R2 = 46;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = tou64(toi16(R1));
	R2 = (u64)&qq_decls_nextlx;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 24;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 1;
	qq_lex_lxlineno = asi64(R1);
	return;
}

static u64 qq_lex_addnamestr(u64 name) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	struct $B3 oldlx;
	u64 symptr;
	(R1_B3) = qq_decls_nextlx;
	oldlx = (R1_B3);
	asu64(R1) = name;
	asi64(R1) = strlen(asu64(R1));
	qq_lex_nextlxlength = asi64(R1);
	asi64(R1) = qq_lex_nextlxlength;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = qq_lex_nextlxlength;
	R2 = 1;
	asu64(R1) += asu64(R2);
	asu64(R2) = name;
	R3 = (u64)&qq_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = name;
	asi64(R1) = qq_lex_gethashvaluez(asu64(R1));
	asi64(R2) = qq_lex_nextlxlength;
	R3 = (u64)&qq_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R1) = qq_lex_lookup(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&qq_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	symptr = asu64(R1);
	(R1_B3) = oldlx;
	qq_decls_nextlx = (R1_B3);
	asu64(R1) = symptr;
	goto L2497;
L2497:
	return asu64(R1);
}

static void qq_lex_ps(u64 caption) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":::");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&qq_decls_lx;
	qq_show_printsymbol(asu64(R1));
	return;
}

static void qq_lex_psnext(u64 caption) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":##");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&qq_decls_nextlx;
	qq_show_printsymbol(asu64(R1));
	return;
}

static void qq_lex_lex() {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	i64 lineno;
	i64 n;
	i64 dir;
	i64 namelen;
	u64 p;
	u64 symptr;
	(R1_B3) = qq_decls_nextlx;
	qq_decls_lx = (R1_B3);
	asi64(R1) = qq_lex_lxlineno;
	R2 = (u64)&qq_decls_lx;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 23;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = qq_lex_nextlxlength;
	qq_lex_lxlength = asi64(R1);
// qq_lex.lex.reenter:
L2501:
	qq_lex_lexreadtoken();
// qq_lex.lex.reenter2:
L2502:
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L2504;
	R2 = 128;
	if (asi64(R1) == asi64(R2)) goto L2505;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L2506;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L2507;
	goto L2508;
L2504:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L2510;
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L2511;
	goto L2512;
L2510:
	R1 = (u64)&qq_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 112;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2514;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2515;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2516;
	goto L2517;
L2514:
	R1 = 1000000;
	R2 = (u64)&qq_decls_lx;
	*toi64p(R2) *= asi64(R1);
	goto L2513;
L2515:
	R1 = 1000000000;
	R2 = (u64)&qq_decls_lx;
	*toi64p(R2) *= asi64(R1);
	goto L2513;
L2516:
	R1 = 1000;
	R2 = (u64)&qq_decls_lx;
	*toi64p(R2) *= asi64(R1);
	goto L2513;
L2517:
	R1 = tou64("Can't do this unit index");
	qq_lib_lxerror(asu64(R1));
L2513:
	R1 = 1;
	R2 = (u64)&qq_decls_lx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2501;
	goto L2509;
L2511:
	R1 = tou64("unit symbol after float?");
	qq_lib_lxerror(asu64(R1));
	goto L2509;
L2512:
	R1 = 69;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2509:
	goto L2503;
L2505:
	R1 = (u64)&qq_decls_nextlx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2519;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2520;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2521;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2522;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2523;
	goto L2524;
L2519:
	R1 = 63;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2518;
L2520:
	R1 = 65;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = 3.141592653589793100e+000;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	R1 = 2;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2518;
L2521:
	R1 = 67;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = tou64("\t");
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	qq_lex_nextlxlength = asi64(R1);
	goto L2518;
L2522:
	R1 = 63;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2518;
L2523:
	R1 = 63;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2518;
L2524:
	R1 = tou64("sysconst?");
	qq_lib_lxerror(asu64(R1));
L2518:
	goto L2503;
L2506:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2526;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2526;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2526;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L2526;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2526;
	goto L2527;
L2526:
	qq_lex_lexreadtoken();
	goto L2502;
	goto L2501;
	goto L2525;
L2527:
	R1 = (u64)&qq_tables_binopset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2529;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L2529;
	qq_lex_lexreadtoken();
	goto L2502;
L2529:
L2525:
	R1 = 4;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2503;
L2507:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 49;
	if (asi64(R1) != asi64(R2)) goto L2531;
	R1 = 39;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_lx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2501;
L2531:
	goto L2503;
L2508:
L2503:
	return;
}

static void qq_lex_lxerror_s(u64 mess, u64 a) {
    u64 R1; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	qq_lib_lxerror(asu64(R1));
	return;
}

static void qq_lex_makedecimal(u64 s, i64 length, i64 base) {
    u64 R1, R2, R3; 
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L2535;
	R1 = tou64("MAKEDECIMAL/16/2");
	qq_lib_lxerror(asu64(R1));
L2535:
	R1 = 64;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R1) = mlib_pcm_copyheapstringn(asu64(R2), asi64(R1));
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = length;
	qq_lex_nextlxlength = asi64(R1);
	return;
}

static void qq_lex_readdec() {
    u64 R1, R2, R3; 
	i64 c;
	u64 dest;
	u64 destend;
	u64 pstart;
	i64 islong;
	i64 length;
	struct $B64 str;
	u64 a;
	i64 av_1;
	R1 = 0;
	islong = asi64(R1);
	asu64(R1) = qq_lex_lxsptr;
	pstart = asu64(R1);
	R1 = (u64)&str;
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1024;
	R1 += (i64)R2;
	R2 = 10;
	R1 -= (i64)R2;
	destend = asu64(R1);
	R1 = 0;
	a = asu64(R1);
L2537:
	R1 = (u64)&qq_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L2540;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L2540;
	asu64(R1) = a;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	a = asu64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2539;
L2540:
	asi64(R1) = c;
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L2542;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L2542;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L2543;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L2544;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L2544;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L2545;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L2545;
	R2 = 98;
	if (asi64(R1) == asi64(R2)) goto L2546;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L2546;
	goto L2547;
L2542:
	asu64(R1) = pstart;
	qq_lex_lxsptr = asu64(R1);
	qq_lex_readreal();
	goto L2536;
	goto L2541;
L2543:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L2549;
	asu64(R1) = pstart;
	qq_lex_lxsptr = asu64(R1);
	qq_lex_readreal();
	goto L2536;
L2549:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2538;
	goto L2541;
L2544:
	goto L2541;
L2545:
	R1 = 0;
	asu64(R2) = dest;
	*tou8p(R2) = asu8(R1);
	R1 = 10;
	asu64(R2) = dest;
	R3 = (u64)&str;
	asi64(R2) -= asi64(R3);
	R3 = (u64)&str;
	qq_lex_makedecimal(asu64(R3), asi64(R2), asi64(R1));
	goto L2536;
	goto L2541;
L2546:
	asu64(R1) = dest;
	R2 = (u64)&str;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 64;
	if (asi64(R1) <= asi64(R2)) goto L2551;
	R1 = tou64("bin overflow");
	qq_lib_lxerror(asu64(R1));
L2551:
	R1 = (u64)&str;
	dest = asu64(R1);
	R1 = 0;
	a = asu64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2554;
L2552:
	asu64(R1) = dest;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 50;
	if (asu64(R1) < asu64(R2)) goto L2556;
	R1 = tou64("bad bin digit");
	qq_lib_lxerror(asu64(R1));
L2556:
	asu64(R1) = a;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	a = asu64(R1);
	if (--asi64(av_1)) goto L2552;
L2554:
	goto L2557;
	goto L2541;
L2547:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2538;
L2541:
L2539:
	asu64(R1) = dest;
	asu64(R2) = destend;
	if (asu64(R1) < asu64(R2)) goto L2559;
	R1 = tou64("Numlit too long");
	qq_lib_lxerror(asu64(R1));
L2559:
	goto L2537;
L2538:
	asu64(R1) = dest;
	R2 = (u64)&str;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 20;
	if (asi64(R1) > asi64(R2)) goto L2562;
	asi64(R1) = length;
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L2561;
	R1 = 20;
	asu64(R2) = qq_lex_u64maxstr;
	R3 = (u64)&str;
	asi32(R1) = strncmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2561;
L2562:
	R1 = 10;
	asi64(R2) = length;
	R3 = (u64)&str;
	qq_lex_makedecimal(asu64(R3), asi64(R2), asi64(R1));
	goto L2536;
L2561:
// qq_lex.readdec.finish:
L2557:
	R1 = 63;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2536:
	return;
}

static void qq_lex_readhex() {
    u64 R1, R2, R3; 
	i64 c;
	u64 dest;
	u64 destend;
	u64 pstart;
	i64 length;
	struct $B64 str;
	u64 a;
	asu64(R1) = qq_lex_lxsptr;
	pstart = asu64(R1);
	R1 = (u64)&str;
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1024;
	R1 += (i64)R2;
	R2 = 10;
	R1 -= (i64)R2;
	destend = asu64(R1);
	R1 = 0;
	a = asu64(R1);
L2564:
	R1 = (u64)&qq_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L2567;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L2567;
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	a = asu64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2566;
L2567:
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L2568;
	R2 = 70;
	if (asi64(R1) > asi64(R2)) goto L2568;
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 65;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	a = asu64(R1);
	goto L2566;
L2568:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L2569;
	R2 = 102;
	if (asi64(R1) > asi64(R2)) goto L2569;
	asi64(R1) = c;
	R2 = 32;
	asu64(R1) -= asu64(R2);
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 97;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	a = asu64(R1);
	goto L2566;
L2569:
	asi64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L2571;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L2571;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L2572;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L2572;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L2573;
	goto L2574;
L2571:
	goto L2570;
L2572:
	R1 = 0;
	asu64(R2) = dest;
	*tou8p(R2) = asu8(R1);
	R1 = 16;
	asu64(R2) = dest;
	R3 = (u64)&str;
	asi64(R2) -= asi64(R3);
	R3 = (u64)&str;
	qq_lex_makedecimal(asu64(R3), asi64(R2), asi64(R1));
	goto L2563;
	goto L2570;
L2573:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2565;
	goto L2570;
L2574:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2565;
L2570:
L2566:
	asu64(R1) = dest;
	asu64(R2) = destend;
	if (asu64(R1) < asu64(R2)) goto L2576;
	R1 = tou64("Numlit too long");
	qq_lib_lxerror(asu64(R1));
L2576:
	goto L2564;
L2565:
	asu64(R1) = dest;
	R2 = (u64)&str;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 16;
	if (asi64(R1) <= asi64(R2)) goto L2578;
	R1 = 16;
	asi64(R2) = length;
	R3 = (u64)&str;
	qq_lex_makedecimal(asu64(R3), asi64(R2), asi64(R1));
	goto L2563;
L2578:
	R1 = 63;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2563:
	return;
}

static void qq_lex_readbin() {
    u64 R1, R2, R3; 
	i64 c;
	u64 dest;
	u64 destend;
	u64 pstart;
	i64 length;
	struct $B64 str;
	u64 a;
	asu64(R1) = qq_lex_lxsptr;
	pstart = asu64(R1);
	R1 = (u64)&str;
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1024;
	R1 += (i64)R2;
	R2 = 10;
	R1 -= (i64)R2;
	destend = asu64(R1);
	R1 = 0;
	a = asu64(R1);
L2580:
	R1 = (u64)&qq_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L2583;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L2583;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L2584;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L2584;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L2585;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L2585;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L2586;
	goto L2587;
L2583:
	asu64(R1) = a;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	a = asu64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2582;
L2584:
	goto L2582;
L2585:
	R1 = 0;
	asu64(R2) = dest;
	*tou8p(R2) = asu8(R1);
	R1 = 2;
	asu64(R2) = dest;
	R3 = (u64)&str;
	asi64(R2) -= asi64(R3);
	R3 = (u64)&str;
	qq_lex_makedecimal(asu64(R3), asi64(R2), asi64(R1));
	goto L2579;
	goto L2582;
L2586:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2581;
	goto L2582;
L2587:
	asi64(R1) = c;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L2589;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L2589;
	R1 = tou64("bin bad digit");
	qq_lib_lxerror(asu64(R1));
	goto L2588;
L2589:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2581;
L2588:
L2582:
	asu64(R1) = dest;
	asu64(R2) = destend;
	if (asu64(R1) < asu64(R2)) goto L2591;
	R1 = tou64("bin overflow");
	qq_lib_lxerror(asu64(R1));
L2591:
	goto L2580;
L2581:
	asu64(R1) = dest;
	R2 = (u64)&str;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 64;
	if (asi64(R1) <= asi64(R2)) goto L2593;
	R1 = 2;
	asi64(R2) = length;
	R3 = (u64)&str;
	qq_lex_makedecimal(asu64(R3), asi64(R2), asi64(R1));
	goto L2579;
L2593:
	R1 = 63;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2579:
	return;
}

static void qq_lex_readreal() {
    u64 R1, R2, R3; 
	i64 c;
	i64 n;
	i64 negexpon;
	i64 dotseen;
	i64 length;
	i64 fractlen;
	i64 expon;
	i64 expseen;
	r64 x;
	struct $B64 str;
	u64 dest;
	u64 destend;
	u64 pexpon;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 i;
	R1 = (u64)&str;
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1024;
	R1 += (i64)R2;
	R2 = 100;
	R1 -= (i64)R2;
	destend = asu64(R1);
	R1 = 0;
	R2 = R1;
	fractlen = asi64(R2);
	R2 = R1;
	expon = asi64(R2);
	R2 = R1;
	expseen = asi64(R2);
	R2 = R1;
	dotseen = asi64(R2);
	R2 = R1;
	negexpon = asi64(R2);
	length = asi64(R1);
L2595:
	R1 = (u64)&qq_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L2598;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L2598;
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	asi64(R1) = dotseen;
	if (!asi64(R1)) goto L2600;
	R1 = (u64)&fractlen;
	(*toi64p(R1)) += 1;
L2600:
	goto L2597;
L2598:
	asi64(R1) = c;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L2602;
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L2603;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L2603;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L2604;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L2604;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L2605;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L2605;
	goto L2606;
L2602:
	asi64(R1) = dotseen;
	if (!asi64(R1)) goto L2608;
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2596;
L2608:
	R1 = 1;
	dotseen = asi64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2601;
L2603:
	asi64(R1) = expseen;
	if (!asi64(R1)) goto L2610;
	R1 = tou64("double expon");
	qq_lib_lxerror(asu64(R1));
L2610:
	R1 = 1;
	expseen = asi64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2612;
L2611:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
L2612:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L2611;
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L2616;
	R2 = 45;
	if (asi64(R1) != asi64(R2)) goto L2615;
L2616:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) != asu64(R2)) goto L2618;
	R1 = 1;
	negexpon = asi64(R1);
L2618:
	R1 = (u64)&qq_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L2615:
	R1 = 0;
	expon = asi64(R1);
L2619:
	R1 = (u64)&qq_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L2622;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L2622;
	asi64(R1) = expon;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	expon = asi64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = dest;
	asu64(R2) = destend;
	if (asu64(R1) < asu64(R2)) goto L2624;
	R1 = tou64("expon?");
	qq_lib_lxerror(asu64(R1));
L2624:
	goto L2621;
L2622:
	asi64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L2626;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L2626;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L2627;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L2627;
	goto L2628;
L2626:
	goto L2625;
L2627:
	R1 = 0;
	asu64(R2) = dest;
	*tou8p(R2) = asu8(R1);
	R1 = 10;
	asu64(R2) = dest;
	R3 = (u64)&str;
	asi64(R2) -= asi64(R3);
	R3 = (u64)&str;
	qq_lex_makedecimal(asu64(R3), asi64(R2), asi64(R1));
	goto L2594;
	goto L2625;
L2628:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2596;
L2625:
L2621:
	goto L2619;
	goto L2601;
L2604:
	goto L2601;
L2605:
	R1 = 10;
	asu64(R2) = dest;
	R3 = (u64)&str;
	asi64(R2) -= asi64(R3);
	R3 = (u64)&str;
	qq_lex_makedecimal(asu64(R3), asi64(R2), asi64(R1));
	goto L2594;
	goto L2601;
L2606:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2596;
L2601:
L2597:
	asu64(R1) = dest;
	asu64(R2) = destend;
	if (asu64(R1) < asu64(R2)) goto L2630;
	R1 = tou64("r64lit too long");
	qq_lib_lxerror(asu64(R1));
L2630:
	goto L2595;
L2596:
	R1 = 0;
	asu64(R2) = dest;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = negexpon;
	if (!asi64(R1)) goto L2632;
	asi64(R1) = expon;
	asi64(R1) = -asi64(R1);
	expon = asi64(R1);
L2632:
	asi64(R1) = fractlen;
	R2 = (u64)&expon;
	*toi64p(R2) -= asi64(R1);
	asr64(R1) = 0.000000000000000000e+000;
	x = asr64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = length;
	asi64(R2) = dotseen;
	asi64(R1) += asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2635;
L2633:
	R1 = (u64)&str;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L2637;
	asr64(R1) = x;
	asr64(R2) = 1.000000000000000000e+001;
	asr64(R1) *= asr64(R2);
	asi64(R2) = c;
	asr64(R2) = tor64(asi64(R2));
	asr64(R1) += asr64(R2);
	R2 = 48;
	asr64(R2) = tor64(asu64(R2));
	asr64(R1) -= asr64(R2);
	x = asr64(R1);
L2637:
	i += 1; if (i <= av_1) goto L2633;
L2635:
	asi64(R1) = expon;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L2639;
	asi64(R1) = expon;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2642;
L2640:
	asr64(R1) = 1.000000000000000000e+001;
	R2 = (u64)&x;
	*tor64p(R2) *= asr64(R1);
	if (--asi64(av_2)) goto L2640;
L2642:
	goto L2638;
L2639:
	asi64(R1) = expon;
	asi64(R1) = -asi64(R1);
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2645;
L2643:
	asr64(R1) = 1.000000000000000000e+001;
	R2 = (u64)&x;
	*tor64p(R2) /= asr64(R1);
	if (--asi64(av_3)) goto L2643;
L2645:
L2638:
	asr64(R1) = x;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	R1 = 65;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 2;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2594:
	return;
}

static void qq_lex_readrawxname() {
    u64 R1, R2, R3, R4; 
	i64 c;
	i64 hsum;
	i64 length;
	asu64(R1) = qq_lex_lxsptr;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	hsum = asi64(R1);
	goto L2648;
L2647:
	asi64(R1) = hsum;
	R2 = 4;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	hsum = asi64(R1);
L2648:
	R1 = (u64)&qq_lex_namemap;
	R2 = (u64)&qq_lex_lxsptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	R3 = R2;
	c = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2647;
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	asi64(R1) = hsum;
	R2 = 5;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	R2 = 32767;
	asi64(R1) &= asi64(R2);
	asu64(R2) = qq_lex_lxsptr;
	R3 = (u64)&qq_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R2) -= asi64(R3);
	R3 = (u64)&qq_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R1) = qq_lex_lookup(asu64(R3), asi64(R2), asi64(R1));
	goto L2646;
L2646:
	return;
}

static void qq_lib_reportcterror(u64 errortype, u64 mess, i64 pos, u64 currproc) {
    u64 R1, R2; struct $B12 R1_B12; 
	struct $B12 loc;
	asu64(R1) = currproc;
	asi64(R2) = pos;
	(R1_B12) = qq_lib_geterrorinfo(asu64(R2), asu64(R1));
	loc = (R1_B12);
	msysc_m$print_startcon();
	asu64(R1) = errortype;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Error:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("    ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = pos;
	if (asi64(R1)) goto L2653;
	asi64(R1) = qq_decls_qpos;
	if (!asi64(R1)) goto L2652;
L2653:
	(R1_B12) = loc;
	qq_lib_showerrorsource((R1_B12));
L2652:
	(R1_B12) = loc;
	qq_lib_stopcompiler((R1_B12));
	return;
}

static struct $B12 qq_lib_geterrorinfo(u64 pos, u64 currproc) {
    u64 R1, R2, R3; struct $B12 R1_B12; 
	i64 soffset;
	i64 moduleno;
	struct $B12 loc;
	R1 = (u64)&loc;
	memset(R1, 0, 48);
	asu64(R1) = pos;
	R2 = 0;
	R3 = 23;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = (u64)&loc;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pos;
	R2 = 24;
	R3 = 31;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	moduleno = asi64(R1);
	asi64(R1) = moduleno;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2656;
	(R1_B12) = loc;
	goto L2654;
L2656:
	asu64(R1) = currproc;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2658;
	R1 = tou64("GETERRORINFO: no currproc");
	mlib_abortprogram(asu64(R1));
L2658:
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = moduleno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&loc;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&qq_decls_subprogs;
	R2 = (u64)&loc;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 44;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&loc;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = currproc;
	R2 = (u64)&loc;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	(R1_B12) = loc;
	goto L2654;
L2654:
	return (R1_B12);
}

static void qq_lib_showerrorsource(struct $B12 loc) {
    u64 R1, R2; 
	u64 s;
	R1 = (u64)&loc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L2661;
	goto L2659;
L2661:
	msysc_m$print_startcon();
	R1 = tou64("Line:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&loc;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("in Module");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&loc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".q:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&loc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L2663;
	msysc_m$print_startcon();
	R1 = tou64("In function:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&loc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L2663:
L2659:
	return;
}

static void qq_lib_stopcompiler(struct $B12 loc) {
    u64 R1, R2; 
	u64 f;
	R1 = (u64)&loc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L2666;
	R1 = tou64("w");
	R2 = tou64("$error.tmp");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = (u64)&loc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&loc;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
L2666:
	R1 = 1;
	exit(R1);
	return;
}

static void qq_lib_gerror(u64 mess, u64 p) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = qq_decls_stcurrproc;
	asu64(R2) = p;
	if (!asu64(R2)) goto L2669;
	asu64(R2) = p;
	R3 = 4;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	goto L2668;
L2669:
	asi64(R2) = qq_decls_qpos;
L2668:
	asu64(R3) = mess;
	R4 = tou64("Code Gen");
	qq_lib_reportcterror(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	return;
}

static void qq_lib_gerror_s(u64 mess, u64 param, u64 p) {
    u64 R1, R2, R3, R4; 
	struct $B15 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = qq_decls_stcurrproc;
	asu64(R2) = p;
	if (!asu64(R2)) goto L2672;
	asu64(R2) = p;
	R3 = 4;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	goto L2671;
L2672:
	asi64(R2) = qq_decls_qpos;
L2671:
	R3 = (u64)&str;
	R4 = tou64("Code Gen");
	qq_lib_reportcterror(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	return;
}

static void qq_lib_serror(u64 mess) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = qq_decls_stcurrproc;
	R2 = (u64)&qq_decls_lx;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = mess;
	R4 = tou64("Syntax");
	qq_lib_reportcterror(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	return;
}

static void qq_lib_serror_s(u64 mess, u64 param) {
    u64 R1, R2, R3, R4; 
	struct $B15 str;
	asu64(R1) = mess;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = param;
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = qq_decls_stcurrproc;
	R2 = (u64)&qq_decls_lx;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = (u64)&str;
	R4 = tou64("Syntax");
	qq_lib_reportcterror(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	return;
}

static void qq_lib_rxerror(u64 mess, u64 p) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = qq_decls_stcurrproc;
	asu64(R2) = p;
	if (!asu64(R2)) goto L2677;
	asu64(R2) = p;
	R3 = 4;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	goto L2676;
L2677:
	asi64(R2) = qq_decls_qpos;
L2676:
	asu64(R3) = mess;
	R4 = tou64("Resolve");
	qq_lib_reportcterror(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	return;
}

static void qq_lib_rxerror_s(u64 mess, u64 param, u64 p) {
    u64 R1, R2; 
	struct $B15 str;
	asu64(R1) = mess;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = param;
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = (u64)&str;
	qq_lib_rxerror(asu64(R2), asu64(R1));
	return;
}

static void qq_lib_lxerror(u64 mess) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = qq_decls_stcurrproc;
	R2 = (u64)&qq_decls_lx;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = mess;
	R4 = tou64("Lex");
	qq_lib_reportcterror(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	return;
}

static void qq_lib_loaderror(u64 mess, u64 mess2) {
    u64 R1; 
	struct $B24 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess2;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Load Error:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Stopping");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void qq_lib_prterror(u64 mess) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("Print error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = mlinux_os_getch();
	R1 = 1;
	exit(R1);
	return;
}

static u64 qq_lib_allocunitrec() {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 32;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L2682;
L2682:
	return asu64(R1);
}

static u64 qq_lib_createintunit(i64 a) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = qq_lib_allocunitrec();
	u = asu64(R1);
	R1 = 41;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = a;
	asu64(R2) = u;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = u;
	goto L2683;
L2683:
	return asu64(R1);
}

static u64 qq_lib_createrealunit(r64 x) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = qq_lib_allocunitrec();
	u = asu64(R1);
	R1 = 42;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	asu64(R2) = u;
	R3 = 16;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asu64(R1) = u;
	goto L2684;
L2684:
	return asu64(R1);
}

static u64 qq_lib_createstringunit(u64 s, i64 slength) {
    u64 R1, R2, R3, R4; 
	u64 u;
	asi64(R1) = slength;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L2687;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	slength = asi64(R1);
L2687:
	asu64(R1) = qq_lib_allocunitrec();
	u = asu64(R1);
	R1 = 43;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = slength;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = slength;
	if (!asi64(R1)) goto L2689;
	asi64(R1) = slength;
	asu64(R2) = s;
	asu64(R3) = u;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L2689:
	R1 = 0;
	asu64(R2) = u;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = slength;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = slength;
	asu64(R2) = u;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = u;
	goto L2685;
L2685:
	return asu64(R1);
}

static u64 qq_lib_createunit0(i64 tag) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = qq_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = u;
	goto L2690;
L2690:
	return asu64(R1);
}

static u64 qq_lib_createunit1(i64 tag, u64 p) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = qq_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L2691;
L2691:
	return asu64(R1);
}

static u64 qq_lib_createunit2(i64 tag, u64 p, u64 q) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = qq_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = u;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L2692;
L2692:
	return asu64(R1);
}

static u64 qq_lib_createname(u64 p) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = qq_lib_allocunitrec();
	u = asu64(R1);
	R1 = 39;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L2693;
L2693:
	return asu64(R1);
}

static void qq_lib_addlistunit(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	goto L2696;
L2695:
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2699;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L2698;
L2699:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L2698:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L2696:
	asu64(R1) = p;
	if (asu64(R1)) goto L2695;
	return;
}

static u64 qq_lib_createavname() {
    u64 R1; 
	u64 p;
	struct $B31 str;
	u64 name;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("av$");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&qq_lib_nextavindex;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	name = asu64(R1);
	asu64(R1) = name;
	asu64(R1) = qq_lex_addnamestr(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	asu64(R1) = qq_lib_createname(asu64(R1));
	goto L2700;
L2700:
	return asu64(R1);
}

static u64 qq_lib_convtostringz(u64 svalue, i64 length) {
    u64 R1, R2, R3; 
	u64 p;
// PROC LOCAL STATICS GO HERE
	static i64 qq_lib_convtostringz_strindex = 0;
	static struct $B12 qq_lib_convtostringz_table = {{
	(u64)&qq_lib_convtostringz_strbuffer1,
	(u64)&qq_lib_convtostringz_strbuffer2,
	(u64)&qq_lib_convtostringz_strbuffer3,
	(u64)&qq_lib_convtostringz_strbuffer4,
	(u64)&qq_lib_convtostringz_strbuffer5,
	(u64)&qq_lib_convtostringz_strbuffer6    }};
	static u64 qq_lib_convtostringz_longstr = 0;
	asi64(R1) = length;
	R2 = 2000;
	if (asi64(R1) < asi64(R2)) goto L2703;
	asu64(R1) = qq_lib_convtostringz_longstr;
	if (!asu64(R1)) goto L2705;
	asu64(R1) = qq_lib_convtostringz_longstr;
	free(asu64(R1));
L2705:
	asi64(R1) = length;
	R2 = 1;
	asu64(R1) += asu64(R2);
	asu64(R1) = malloc(asu64(R1));
	qq_lib_convtostringz_longstr = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = svalue;
	asu64(R3) = qq_lib_convtostringz_longstr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = qq_lib_convtostringz_longstr;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = qq_lib_convtostringz_longstr;
	goto L2701;
L2703:
	asu64(R1) = svalue;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2707;
	R1 = tou64("");
	goto L2701;
L2707:
	R1 = (u64)&qq_lib_convtostringz_strindex;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L2709;
	R1 = 0;
	qq_lib_convtostringz_strindex = asi64(R1);
L2709:
	R1 = (u64)&qq_lib_convtostringz_table;
	asi64(R2) = qq_lib_convtostringz_strindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	p = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = svalue;
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L2701;
L2701:
	return asu64(R1);
}

static u64 qq_lib_findprocname(u64 fnptr) {
    u64 R1, R2; 
	u64 name;
	i64 n;
	i64 i;
	asi64(R1) = $nprocs;
	n = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2713;
L2711:
	R1 = (u64)&$procaddr;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = fnptr;
	if (asu64(R1) != asu64(R2)) goto L2715;
	R1 = (u64)&$procname;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L2710;
L2715:
	i += 1; if (i <= n) goto L2711;
L2713:
	R1 = tou64("?");
	goto L2710;
L2710:
	return asu64(R1);
}

static u64 qq_lib_strexpr(u64 p) {
    u64 R1; 
	asu64(R1) = qq_lib_exprstr;
	mlib_gs_init(asu64(R1));
	asu64(R1) = p;
	qq_lib_jeval(asu64(R1));
	asu64(R1) = qq_lib_exprstr;
	goto L2716;
L2716:
	return asu64(R1);
}

static u64 qq_lib_strexpr_s(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2719;
	R1 = tou64("");
	goto L2717;
L2719:
	asu64(R1) = qq_lib_exprstr;
	mlib_gs_init(asu64(R1));
	asu64(R1) = p;
	qq_lib_jeval(asu64(R1));
	asu64(R1) = qq_lib_exprstr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L2717;
L2717:
	return asu64(R1);
}

static void qq_lib_jeval(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	struct $B74 str;
	i64 i;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L2722;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2722;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L2723;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L2724;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L2725;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L2726;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L2727;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L2727;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L2728;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L2729;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2730;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L2731;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L2732;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2733;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L2734;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L2735;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L2736;
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L2737;
	goto L2738;
L2722:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	qq_lib_additem(asu64(R1));
	goto L2721;
L2723:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asr64(R2) = tor64(asi64(R2));
	asu64(R1) = msysc_strreal(asr64(R2), asu64(R1));
	qq_lib_additem(asu64(R1));
	goto L2721;
L2724:
	asu64(R1) = p;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 250;
	if (asi64(R1) <= asi64(R2)) goto L2740;
	R1 = tou64("LONGSTR)");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2739;
L2740:
	R1 = (u64)&str;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_lib_convertstring(asu64(R2), asu64(R1));
L2739:
	R1 = tou64("\"");
	qq_lib_additem(asu64(R1));
	R1 = (u64)&str;
	qq_lib_additem(asu64(R1));
	R1 = tou64("\"");
	qq_lib_additem(asu64(R1));
	goto L2721;
L2725:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_additem(asu64(R1));
	goto L2721;
L2726:
	R1 = tou64("Host<");
	qq_lib_additem(asu64(R1));
	R1 = (u64)&qq_tables_hostfnnames;
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 2;
	R1 += (i64)R2;
	qq_lib_additem(asu64(R1));
	R1 = tou64(">(");
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L2742;
L2741:
	asu64(R1) = q;
	qq_lib_jeval(asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L2745;
	R1 = tou64(",");
	qq_lib_additem(asu64(R1));
L2745:
L2742:
	asu64(R1) = q;
	if (asu64(R1)) goto L2741;
	R1 = tou64(")");
	qq_lib_additem(asu64(R1));
	goto L2721;
L2727:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 48;
	if (asi64(R1) != asi64(R2)) goto L2747;
	R1 = tou64(".");
	qq_lib_additem(asu64(R1));
L2747:
	R1 = tou64("[");
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	R1 = tou64("]");
	qq_lib_additem(asu64(R1));
	goto L2721;
L2728:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	R1 = tou64("{");
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	R1 = tou64("}");
	qq_lib_additem(asu64(R1));
	goto L2721;
L2729:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	R1 = tou64(".");
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	goto L2721;
L2730:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	R1 = tou64(":=");
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	goto L2721;
L2731:
	R1 = 0;
	asu64(R2) = p;
	R3 = 24;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = qq_show_strmode(asi64(R2), asi64(R1));
	qq_lib_additem(asu64(R1));
	goto L2721;
L2732:
	R1 = 0;
	asu64(R2) = p;
	R3 = 24;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = qq_show_strmode(asi64(R2), asi64(R1));
	qq_lib_additem(asu64(R1));
	R1 = tou64("(");
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	R1 = tou64(")");
	qq_lib_additem(asu64(R1));
	goto L2721;
L2733:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	R1 = tou64(":");
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	goto L2721;
L2734:
	R1 = tou64("nil");
	qq_lib_additem(asu64(R1));
	goto L2721;
L2735:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	R1 = tou64(".$");
	qq_lib_additem(asu64(R1));
	goto L2721;
L2736:
	R1 = tou64("CMPCHAIN:");
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	qq_lib_jeval(asu64(R1));
	R1 = 1;
	i = asi64(R1);
L2748:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	R1 += (i64)R2;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2752;
	goto L2750;
L2752:
	R1 = (u64)&qq_tables_jtagnames;
	asu64(R2) = p;
	R3 = 24;
	R2 += (i64)R3;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	qq_lib_additem(asu64(R1));
	asu64(R1) = q;
	qq_lib_jeval(asu64(R1));
	i += 1; if (i <= 4) goto L2748;
L2750:
	goto L2721;
L2737:
	R1 = (u64)&qq_tables_mathsnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 3;
	R1 += (i64)R2;
	qq_lib_additem(asu64(R1));
	R1 = tou64("(");
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	R1 = tou64(")");
	qq_lib_additem(asu64(R1));
	goto L2721;
L2738:
	R1 = (u64)&qq_tables_jflags;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2754;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R1) = qq_lib_getopcname(asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("(");
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jevallist(asu64(R1));
	R1 = (u64)&str;
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jevallist(asu64(R1));
	R1 = tou64(")");
	qq_lib_additem(asu64(R1));
	goto L2753;
L2754:
	R1 = (u64)&qq_tables_jflags;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2755;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R1) = qq_lib_getopcname(asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	qq_lib_additem(asu64(R1));
	R1 = tou64("(");
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jevallist(asu64(R1));
	R1 = tou64(")");
	qq_lib_additem(asu64(R1));
	goto L2753;
L2755:
	msysc_m$print_startcon();
	R1 = (u64)&qq_tables_jtagnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&qq_tables_jtagnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("CAN'T DO JEVAL:");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L2753:
L2721:
	return;
}

static void qq_lib_jevallist(u64 p) {
    u64 R1, R2; 
	u64 q;
	asu64(R1) = p;
	if (asu64(R1)) goto L2758;
	goto L2756;
L2758:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L2760;
	R1 = tou64("(");
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	q = asu64(R1);
	goto L2762;
L2761:
	asu64(R1) = q;
	qq_lib_jeval(asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L2765;
	R1 = tou64(",");
	qq_lib_additem(asu64(R1));
L2765:
L2762:
	asu64(R1) = q;
	if (asu64(R1)) goto L2761;
	R1 = tou64(")");
	qq_lib_additem(asu64(R1));
	goto L2756;
	goto L2759;
L2760:
	asu64(R1) = p;
	qq_lib_jeval(asu64(R1));
L2759:
L2756:
	return;
}

static void qq_lib_additem(u64 s) {
    u64 R1, R2, R3; 
	u64 d;
	i64 lastchar;
	i64 nextchar;
	asu64(R1) = qq_lib_exprstr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = qq_lib_exprstr;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L2768;
	asu64(R1) = d;
	asu64(R2) = qq_lib_exprstr;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	lastchar = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	nextchar = asi64(R1);
	asi64(R1) = lastchar;
	asi64(R1) = qq_lib_isalphanum(asi64(R1));
	if (!asi64(R1)) goto L2770;
	asi64(R1) = nextchar;
	asi64(R1) = qq_lib_isalphanum(asi64(R1));
	if (!asi64(R1)) goto L2770;
	R1 = -1;
	R2 = tou64(" ");
	asu64(R3) = qq_lib_exprstr;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
L2770:
L2768:
	R1 = -1;
	asu64(R2) = s;
	asu64(R3) = qq_lib_exprstr;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static i64 qq_lib_isalphanum(i64 c) {
    u64 R1, R2; 
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L2775;
	asi64(R1) = c;
	R2 = 90;
	if (asi64(R1) <= asi64(R2)) goto L2774;
L2775:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L2776;
	asi64(R1) = c;
	R2 = 122;
	if (asi64(R1) <= asi64(R2)) goto L2774;
L2776:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L2773;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L2773;
L2774:
	R1 = 1;
	goto L2771;
L2773:
	R1 = 0;
	goto L2771;
L2771:
	return asi64(R1);
}

static u64 qq_lib_getopcname(i64 opc) {
    u64 R1, R2; 
	R1 = (u64)&qq_tables_jtagnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	goto L2777;
L2777:
	return asu64(R1);
}

static void qq_lib_convertstring(u64 s, u64 t) {
    u64 R1, R2, R3; 
	i64 c;
	goto L2780;
L2779:
	asi64(R1) = c;
	switch (asi64(R1)) {
	case 7: case 8: case 26: case 27: goto L2790;
	case 9: goto L2788;
	case 10: goto L2786;
	case 11: case 12: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 28: case 29: case 30: case 31: case 32: case 33: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: goto L2784;
	case 13: goto L2787;
	case 34: goto L2785;
	case 92: goto L2789;
	default: goto L2784;
    };
// SWITCH
L2785:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 34;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2782;
L2786:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 110;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2782;
L2787:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 99;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2782;
L2788:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 116;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2782;
L2789:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2782;
L2790:
	R1 = 60;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = c;
	R2 = 10;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 48;
	asu64(R1) += asu64(R2);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = c;
	R2 = 10;
	asi64(R1) %= asi64(R2);
	R2 = 48;
	asu64(R1) += asu64(R2);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 62;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2782;
L2784:
	asi64(R1) = c;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L2782:
L2780:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	if (asi64(R1)) goto L2779;
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	return;
}

static u64 qq_lib_createavnamex(u64 owner) {
    u64 R1, R2, R3; 
	u64 p;
	u64 d;
	asu64(R1) = qq_lib_createavname();
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	asu64(R3) = owner;
	qq_resolve_resolvename(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L2793;
	R1 = (u64)&qq_decls_nproclocals;
	(*toi64p(R1)) += 1;
	asi64(R1) = qq_decls_nproclocals;
	asu64(R2) = d;
	R3 = 96;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = qq_decls_nproclocals;
	asu64(R2) = qq_pclgen_pprocentry;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2793:
	asu64(R1) = p;
	goto L2791;
L2791:
	return asu64(R1);
}

static void qq_lib_storemode(u64 owner, i64 m, u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	asi64(R1) = m;
	asu64(R2) = p;
	*toi16p(R2) = asi16(R1);
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L2796;
	goto L2794;
L2796:
	R1 = 24;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asu64(R1) = owner;
	asu64(R2) = q;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = owner;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2798;
	R1 = tou64("STOREMODE/OWNER=0");
	qq_lib_serror(asu64(R1));
L2798:
	asu64(R1) = p;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = qq_tables_userxmodelist;
	asu64(R2) = q;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	qq_tables_userxmodelist = asu64(R1);
L2794:
	return;
}

static i64 qq_lib_nextpoweroftwo(i64 x) {
    u64 R1, R2; 
	i64 a;
	asi64(R1) = x;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2801;
	R1 = 0;
	goto L2799;
L2801:
	R1 = 1;
	a = asi64(R1);
	goto L2803;
L2802:
	R1 = 1;
	R2 = (u64)&a;
	*toi64p(R2) <<= asi64(R1);
L2803:
	asi64(R1) = a;
	asi64(R2) = x;
	if (asi64(R1) < asi64(R2)) goto L2802;
	asi64(R1) = a;
	goto L2799;
L2799:
	return asi64(R1);
}

static i64 qq_lib_testelem(u64 p, i64 n) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = p;
	asi64(R2) = n;
	R3 = 3;
	asi64(R2) >>= asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&qq_lib_bytemasks;
	asi64(R3) = n;
	R4 = 7;
	asi64(R3) &= asi64(R4);
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L2807;
	R1 = 1;
	goto L2806;
L2807:
	R1 = 0;
L2806:
	goto L2805;
L2805:
	return asi64(R1);
}

static void qq_lib_setelem(u64 p, i64 n) {
    u64 R1, R2, R3, R4; 
	R1 = (u64)&qq_lib_bytemasks;
	asi64(R2) = n;
	R3 = 7;
	asi64(R2) &= asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	asi64(R3) = n;
	R4 = 3;
	asi64(R3) >>= asi64(R4);
	R2 += (i64)R3;
	*tou8p(R2) |= asu8(R1);
	return;
}

static void qq_lib_setelemblock(u64 p, i64 a, i64 b) {
    u64 R1, R2, R3; 
	i64 ax;
	i64 bx;
	i64 nwords;
	i64 nx;
	i64 alast;
	i64 bfirst;
	u64 q;
	i64 av_1;
	i64 i;
	asi64(R1) = a;
	asi64(R2) = b;
	if (asi64(R1) <= asi64(R2)) goto L2811;
	goto L2809;
L2811:
	asi64(R1) = a;
	R2 = -64;
	asi64(R1) &= asi64(R2);
	ax = asi64(R1);
	asi64(R1) = b;
	R2 = -64;
	asi64(R1) &= asi64(R2);
	R2 = 64;
	asi64(R1) += asi64(R2);
	bx = asi64(R1);
	asi64(R1) = ax;
	nx = asi64(R1);
	R1 = -1;
	R2 = R1;
	bfirst = asi64(R2);
	alast = asi64(R1);
	asi64(R1) = bx;
	asi64(R2) = ax;
	asi64(R1) -= asi64(R2);
	R2 = 64;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nwords = asi64(R1);
	asi64(R1) = nwords;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2813;
	asi64(R1) = ax;
	asi64(R2) = a;
	if (asi64(R1) != asi64(R2)) goto L2816;
	asi64(R1) = b;
	asi64(R2) = bx;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	if (asi64(R1) == asi64(R2)) goto L2815;
L2816:
	asi64(R1) = a;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = b;
	if (asi64(R1) > asi64(R2)) goto L2819;
L2817:
	asi64(R1) = i;
	asu64(R2) = p;
	qq_lib_setelem(asu64(R2), asi64(R1));
	i += 1; if (i <= b) goto L2817;
L2819:
	goto L2809;
L2815:
	goto L2812;
L2813:
	asi64(R1) = ax;
	asi64(R2) = a;
	if (asi64(R1) == asi64(R2)) goto L2821;
	R1 = (u64)&nwords;
	(*toi64p(R1)) -=1;
	asi64(R1) = ax;
	R2 = 64;
	asi64(R1) += asi64(R2);
	nx = asi64(R1);
	asi64(R1) = nx;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	alast = asi64(R1);
L2821:
	asi64(R1) = b;
	asi64(R2) = bx;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	if (asi64(R1) == asi64(R2)) goto L2823;
	R1 = (u64)&nwords;
	(*toi64p(R1)) -=1;
	asi64(R1) = b;
	R2 = -64;
	asi64(R1) &= asi64(R2);
	bfirst = asi64(R1);
L2823:
L2812:
	asi64(R1) = alast;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L2825;
	asi64(R1) = a;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = alast;
	if (asi64(R1) > asi64(R2)) goto L2828;
L2826:
	asi64(R1) = i;
	asu64(R2) = p;
	qq_lib_setelem(asu64(R2), asi64(R1));
	i += 1; if (i <= alast) goto L2826;
L2828:
L2825:
	asu64(R1) = p;
	asi64(R2) = nx;
	R3 = 3;
	asi64(R2) >>= asi64(R3);
	R1 += (i64)R2;
	q = asu64(R1);
	asi64(R1) = nwords;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2831;
L2829:
	R1 = -1;
	asu64(R2) = q;
	*tou64p(R2) = asu64(R1);
	R1 = (u64)&q;
	(*tou64p(R1)) += 8;
	if (--asi64(av_1)) goto L2829;
L2831:
	asi64(R1) = bfirst;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L2833;
	asi64(R1) = bfirst;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = b;
	if (asi64(R1) > asi64(R2)) goto L2836;
L2834:
	asi64(R1) = i;
	asu64(R2) = p;
	qq_lib_setelem(asu64(R2), asi64(R1));
	i += 1; if (i <= b) goto L2834;
L2836:
L2833:
L2809:
	return;
}

static i64 qq_lib_ispoweroftwo(i64 x) {
    u64 R1, R2; 
	i64 a;
	i64 n;
	i64 av_1;
	R1 = 1;
	a = asi64(R1);
	R1 = 0;
	n = asi64(R1);
	R1 = 60;
	av_1 = asi64(R1);
L2838:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = a;
	R2 = 1;
	asi64(R1) <<= asi64(R2);
	a = asi64(R1);
	asi64(R1) = a;
	asi64(R2) = x;
	if (asi64(R1) != asi64(R2)) goto L2842;
	asi64(R1) = n;
	goto L2837;
L2842:
	if (--asi64(av_1)) goto L2838;
	R1 = 0;
	goto L2837;
L2837:
	return asi64(R1);
}

static void qq_lib_deleteunit(u64 p, u64 q) {
    u64 R1, R2, R3; struct $B31 R1_B31; 
	u64 r;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = q;
	(R1_B31) = *(struct $B31*)(R1);
	asu64(R2) = p;
	*(struct $B31*)(R2) = (R1_B31);
	asu64(R1) = r;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_lib_skipsemi() {
    u64 R1, R2; 
	goto L2846;
L2845:
	qq_lex_lex();
L2846:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2845;
	return;
}

static void qq_lib_checksymbol(i64 symbol) {
    u64 R1, R2, R3, R4; 
	struct $B5 str;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = symbol;
	if (asi64(R1) == asi64(R2)) goto L2850;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("# expected, not #");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("m");
	R2 = (u64)&qq_tables_symbolnames;
	asi64(R3) = symbol;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	msysc_m$print_u64(asu64(R2), asu64(R1));
	R1 = tou64("m");
	R2 = (u64)&qq_tables_symbolnames;
	R3 = (u64)&qq_decls_lx;
	R4 = 12;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	msysc_m$print_u64(asu64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	qq_lib_serror(asu64(R1));
L2850:
	return;
}

static void qq_lib_skipsymbol(i64 symbol) {
    u64 R1; 
	asi64(R1) = symbol;
	qq_lib_checksymbol(asi64(R1));
	qq_lex_lex();
	return;
}

static void qq_lib_pcnotmut() {
    u64 R1, R2; 
	R1 = tou64("");
	R2 = tou64("Not mutable");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	return;
}

static i64 qq_lib_getpcloffset(u64 p, u64 q) {
    u64 R1, R2; 
	asu64(R1) = p;
	asu64(R2) = q;
	asi64(R1) -= asi64(R2);
	R2 = 32;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	goto L2853;
L2853:
	return asi64(R1);
}

static void qq_lists_start() {
    u64 R1, R2, R3; 
	asu64(R1) = qq_vars_obj_new();
	qq_lists_emptylist = asu64(R1);
	R1 = 1;
	asu64(R2) = qq_lists_emptylist;
	R3 = 6;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 0;
	asu64(R2) = qq_lists_emptylist;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void qq_lists_var_empty_list(i64 lower, u64 dest) {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 0;
	asi64(R2) = lower;
	R3 = 0;
	asu64(R1) = qq_lists_obj_newlist(asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 266;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	return;
}

static void qq_lists_var_make_list(u64 a, u64 dest, i64 n, i64 lower) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 p;
	u64 b;
	i64 av_1;
	R1 = 0;
	asi64(R2) = lower;
	asi64(R3) = n;
	asu64(R1) = qq_lists_obj_newlist(asi64(R3), asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L2858;
	asu64(R1) = a;
	if (!asu64(R1)) goto L2858;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2861;
L2859:
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = b;
	*(struct $B3*)(R2) = (R1_B3);
	R1 = (u64)&a;
	(*tou64p(R1)) += 16;
	R1 = (u64)&b;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L2859;
L2861:
L2858:
	R1 = 266;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 qq_lists_obj_newlist(i64 n, i64 lower, u64 defval) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 p;
	u64 a;
	i64 av_1;
	i64 av_2;
	asu64(R1) = qq_vars_obj_new();
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = lower;
	R2 = -32768;
	if (asi64(R1) < asi64(R2)) goto L2865;
	R2 = 32767;
	if (asi64(R1) <= asi64(R2)) goto L2864;
L2865:
	R1 = tou64("");
	R2 = tou64("List LWB not 16-bit");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2864:
	asi64(R1) = lower;
	asu64(R2) = p;
	R3 = 6;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L2867;
	asi64(R1) = n;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	a = asu64(R2);
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = 16;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = defval;
	if (!asu64(R1)) goto L2869;
	asu64(R1) = defval;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2869;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2872;
L2870:
	asu64(R1) = defval;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2874;
	asu64(R1) = defval;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L2874:
	asu64(R1) = defval;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = a;
	*(struct $B3*)(R2) = (R1_B3);
	R1 = (u64)&a;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L2870;
L2872:
	goto L2868;
L2869:
	asi64(R1) = n;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2877;
L2875:
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&a;
	(*tou64p(R1)) += 16;
	if (--asi64(av_2)) goto L2875;
L2877:
L2868:
L2867:
	asu64(R1) = p;
	goto L2862;
L2862:
	return asu64(R1);
}

static void qq_lists_obj_free_list(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	struct $B3 v;
	i64 av_1;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2881;
L2879:
	asu64(R1) = q;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2883;
	asu64(R1) = q;
	qq_vars_var_unshareu(asu64(R1));
L2883:
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L2879;
L2881:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L2885;
	asu64(R1) = p;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L2885:
	asu64(R1) = p;
	mlib_pcm_free32(asu64(R1));
	return;
}

static void qq_lists_var_getix_list(u64 a, i64 index) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 p;
	u64 q;
	u64 offset;
	i64 lower;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 6;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	lower = asi64(R1);
	asi64(R1) = index;
	asi64(R2) = lower;
	asu64(R1) -= asu64(R2);
	offset = asu64(R1);
	asu64(R1) = offset;
	asu64(R2) = q;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L2888;
	R1 = tou64("");
	R2 = tou64("getlist[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2888:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = offset;
	R1 += (i64)R2*16;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = a;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2890;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L2890:
	return;
}

static void qq_lists_var_getslice_list(u64 a, i64 i, i64 j) {
    u64 R1, R2, R3; 
	struct $B3 v;
	struct $B3 v2;
	i64 alower;
	u64 p;
	u64 q;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 6;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	alower = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = alower;
	if (asi64(R1) < asi64(R2)) goto L2894;
	asi64(R1) = j;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R3) = alower;
	asi64(R2) += asi64(R3);
	R3 = 1;
	asi64(R2) -= asi64(R3);
	if (asi64(R1) > asi64(R2)) goto L2894;
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) <= asi64(R2)) goto L2893;
L2894:
	R1 = tou64("");
	R2 = tou64("list/slice bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2893:
	asu64(R1) = qq_vars_obj_new();
	q = asu64(R1);
	asu64(R1) = q;
	R2 = (u64)&v;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = q;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = q;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 1;
	asu64(R2) = q;
	R3 = 6;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	R1 += (i64)R2*16;
	asi64(R2) = alower;
	R1 -= (i64)R2*16;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2896;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2897;
	goto L2898;
L2896:
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_vars_obj_shareu(asu64(R1));
	goto L2895;
L2897:
	R1 = 0;
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2;
	asu64(R2) = q;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2895;
L2898:
	asu64(R1) = p;
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	(*tou32p(R1)) += 1;
L2895:
	asi64(R1) = j;
	asi64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = q;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_lists_var_getixref_list(u64 a, i64 index) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	u64 offset;
	struct $B3 v;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asi64(R1) = index;
	asu64(R2) = q;
	R3 = 6;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) -= asu64(R2);
	offset = asu64(R1);
	asu64(R1) = offset;
	asu64(R2) = q;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L2901;
	asu64(R1) = offset;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L2903;
	R1 = tou64("");
	R2 = tou64("&list[int] lwb");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L2902;
L2903:
	asu64(R1) = offset;
	asu64(R2) = q;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L2904;
	asu64(R1) = q;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2906;
	R1 = tou64("");
	R2 = tou64("Can't extend slice/ext");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2906:
	R1 = 0;
	R2 = (u64)&v;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&v;
	asu64(R2) = q;
	qq_lists_obj_append_list(asu64(R2), asu64(R1));
	goto L2902;
L2904:
	R1 = tou64("");
	R2 = tou64("putlist[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2902:
L2901:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = offset;
	R1 += (i64)R2*16;
	p = asu64(R1);
	R1 = 14;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_lists_var_putix_list(u64 a, i64 index, u64 x) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 dest;
	u64 q;
	u64 offset;
	i64 lower;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L2909;
	qq_lib_pcnotmut();
L2909:
	asi64(R1) = index;
	asu64(R2) = q;
	R3 = 6;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) -= asu64(R2);
	offset = asu64(R1);
	asu64(R1) = offset;
	asu64(R2) = q;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L2911;
	asu64(R1) = offset;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L2913;
	R1 = tou64("");
	R2 = tou64("putlist[int] lwb");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L2912;
L2913:
	asu64(R1) = offset;
	asu64(R2) = q;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L2914;
	asu64(R1) = q;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2916;
	R1 = tou64("");
	R2 = tou64("Can't extend slice/ext");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2916:
	asu64(R1) = x;
	asu64(R2) = q;
	qq_lists_obj_append_list(asu64(R2), asu64(R1));
	goto L2907;
	goto L2912;
L2914:
	R1 = tou64("");
	R2 = tou64("putlist[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2912:
L2911:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = offset;
	R1 += (i64)R2*16;
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2918;
	asu64(R1) = dest;
	qq_vars_var_unshareu(asu64(R1));
L2918:
	asu64(R1) = x;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = dest;
	*(struct $B3*)(R2) = (R1_B3);
L2907:
	return;
}

static void qq_lists_var_putslice_list(u64 a, i64 i, i64 j, u64 x) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 r;
	u64 s;
	u64 p;
	u64 q;
	i64 length;
	i64 sublength;
	i64 av_1;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L2921;
	qq_lib_pcnotmut();
L2921:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2924;
	asi64(R1) = j;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L2924;
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) <= asi64(R2)) goto L2923;
L2924:
	R1 = tou64("");
	R2 = tou64("list/slice bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2923:
	asi64(R1) = j;
	asi64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	sublength = asi64(R1);
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = sublength;
	if (asi64(R1) >= asi64(R2)) goto L2926;
	R1 = tou64("");
	R2 = tou64("substr too short");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2926:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	R1 += (i64)R2*16;
	R2 = 1;
	R1 -= (i64)R2*16;
	r = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asi64(R1) = sublength;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2929;
L2927:
	asu64(R1) = s;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = r;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = r;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2931;
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L2931:
	R1 = (u64)&r;
	(*tou64p(R1)) += 16;
	R1 = (u64)&s;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L2927;
L2929:
	return;
}

static void qq_lists_obj_append_list(u64 a, u64 x) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	i64 n;
	asu64(R1) = a;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2934;
	R1 = tou64("");
	R2 = tou64("Can't extend slice");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2934:
	asu64(R1) = a;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L2936;
	qq_lib_pcnotmut();
L2936:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = a;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L2938;
	asi64(R1) = n;
	asu64(R2) = a;
	qq_lists_obj_resize_list(asu64(R2), asi64(R1));
	goto L2937;
L2938:
	asi64(R1) = n;
	asu64(R2) = a;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2937:
	asu64(R1) = x;
	if (!asu64(R1)) goto L2940;
	asu64(R1) = x;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = n;
	R2 += (i64)R3*16;
	R3 = 1;
	R2 -= (i64)R3*16;
	*(struct $B3*)(R2) = (R1_B3);
L2940:
	return;
}

static void qq_lists_obj_resize_list(u64 p, i64 n) {
    u64 R1, R2, R3; 
	u64 q;
	u32 allocated;
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L2943;
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L2942;
L2943:
	asi64(R1) = n;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = 16;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	allocated = asu32(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L2945;
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) *= asu64(R2);
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L2945:
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu32(R1) = allocated;
	R1 = toi64(tou32(R1));
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2942:
	return;
}

static void qq_lists_var_appendto_list(u64 a, u64 x) {
    u64 R1, R2, R3; 
	asu64(R1) = x;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_lists_obj_append_list(asu64(R2), asu64(R1));
	return;
}

static void qq_lists_var_dupl_list(u64 a) {
    u64 R1, R2, R3, R4; struct $B31 R1_B31; struct $B3 R1_B3; 
	u64 p;
	u64 q;
	u64 plist;
	u64 qlist;
	i64 av_1;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = qq_vars_obj_new();
	q = asu64(R1);
	asu64(R1) = p;
	(R1_B31) = *(struct $B31*)(R1);
	asu64(R2) = q;
	*(struct $B31*)(R2) = (R1_B31);
	R1 = 1;
	asu64(R2) = q;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	asu64(R2) = q;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2949;
	goto L2947;
L2949:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	asu64(R3) = q;
	R4 = 8;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	qlist = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = 16;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = q;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	plist = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2952;
L2950:
	asu64(R1) = plist;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = qlist;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = qlist;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L2954;
	asu64(R1) = qlist;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2956;
	asu64(R1) = qlist;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L2956:
	goto L2953;
L2954:
	asu64(R1) = qlist;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2958;
	asu64(R1) = qlist;
	qq_vars_var_duplu(asu64(R1));
L2958:
L2953:
	R1 = (u64)&qlist;
	(*tou64p(R1)) += 16;
	R1 = (u64)&plist;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L2950;
L2952:
L2947:
	return;
}

static void qq_lists_var_mul_list(u64 p, i64 m) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	i64 oldlength;
	i64 newlength;
	i64 n;
	u64 q;
	u64 r;
	u64 a;
	u64 b;
	i64 av_1;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	oldlength = asi64(R1);
	asi64(R1) = oldlength;
	asi64(R2) = m;
	asi64(R1) *= asi64(R2);
	newlength = asi64(R1);
	asi64(R1) = oldlength;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2961;
	goto L2959;
L2961:
	asi64(R1) = newlength;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L2963;
	R1 = tou64("");
	R2 = tou64("list*int <0");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L2962;
L2963:
	asi64(R1) = newlength;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2964;
	R1 = 0;
	asu64(R2) = q;
	R3 = 6;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R3 = 0;
	asu64(R1) = qq_lists_obj_newlist(asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L2959;
L2964:
L2962:
	R1 = 0;
	asu64(R2) = q;
	R3 = 6;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asi64(R3) = newlength;
	asu64(R1) = qq_lists_obj_newlist(asi64(R3), asi64(R2), asu64(R1));
	r = asu64(R1);
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	asi64(R1) = newlength;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2967;
L2965:
	asu64(R1) = b;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = a;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2969;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L2969:
	R1 = (u64)&a;
	(*tou64p(R1)) += 16;
	asi64(R1) = oldlength;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L2971;
	R1 = (u64)&b;
	(*tou64p(R1)) += 16;
	R1 = (u64)&n;
	asi64(R1) = *(toi64p(R1)) += 1;
	asi64(R2) = oldlength;
	if (asi64(R1) != asi64(R2)) goto L2973;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	R1 = 0;
	n = asi64(R1);
L2973:
L2971:
	if (--asi64(av_1)) goto L2965;
L2967:
	asu64(R1) = r;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L2959:
	return;
}

static i64 qq_lists_var_equal_list(u64 x, u64 y) {
    u64 R1, R2; 
	i64 xlen;
	i64 ylen;
	i64 res;
	u64 px;
	u64 py;
	u64 a;
	u64 b;
	i64 av_1;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	py = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = py;
	if (asu64(R1) != asu64(R2)) goto L2976;
	R1 = 1;
	goto L2974;
L2976:
	asu64(R1) = px;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	xlen = asi64(R1);
	asu64(R1) = py;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	ylen = asi64(R1);
	asi64(R1) = xlen;
	asi64(R2) = ylen;
	if (asi64(R1) == asi64(R2)) goto L2978;
	R1 = 0;
	goto L2974;
L2978:
	asi64(R1) = xlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2980;
	R1 = 1;
	goto L2974;
L2980:
	asu64(R1) = px;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = py;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asi64(R1) = xlen;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2983;
L2981:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_vars_var_equal(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2985;
	R1 = 0;
	goto L2974;
L2985:
	R1 = (u64)&a;
	(*tou64p(R1)) += 16;
	R1 = (u64)&b;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L2981;
L2983:
	R1 = 1;
	goto L2974;
L2974:
	return asi64(R1);
}

static void qq_lists_var_concatto_list(u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 newptr;
	u64 c;
	u64 d;
	i64 n;
	i64 alen;
	i64 blen;
	i64 newlen;
	i64 oldbytes;
	i64 newbytes;
	u64 v;
	u64 pa;
	u64 pb;
	i64 av_1;
	i64 av_2;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = pa;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L2988;
	qq_lib_pcnotmut();
L2988:
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pb = asu64(R1);
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	alen = asi64(R1);
	asu64(R1) = pb;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	blen = asi64(R1);
	asi64(R1) = alen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2990;
	asi64(R1) = blen;
	if (!asi64(R1)) goto L2992;
	asi64(R1) = blen;
	asu64(R2) = pa;
	qq_lists_obj_resize_list(asu64(R2), asi64(R1));
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = blen;
	R2 = 16;
	asu64(R1) *= asu64(R2);
	asu64(R2) = pb;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = d;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = blen;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2995;
L2993:
	asu64(R1) = d;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2997;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L2997:
	R1 = (u64)&d;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L2993;
L2995:
L2992:
	goto L2989;
L2990:
	asi64(R1) = blen;
	if (!asi64(R1)) goto L2998;
	asi64(R1) = alen;
	asi64(R2) = blen;
	asi64(R1) += asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	asu64(R2) = pa;
	qq_lists_obj_resize_list(asu64(R2), asi64(R1));
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = alen;
	R1 += (i64)R2*16;
	d = asu64(R1);
	asi64(R1) = blen;
	R2 = 16;
	asu64(R1) *= asu64(R2);
	asu64(R2) = pb;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = d;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = blen;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3001;
L2999:
	asu64(R1) = d;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3003;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L3003:
	R1 = (u64)&d;
	(*tou64p(R1)) += 16;
	if (--asi64(av_2)) goto L2999;
L3001:
L2998:
L2989:
	return;
}

static i64 qq_lists_var_inx_list(u64 a, u64 b) {
    u64 R1, R2; 
	i64 n;
	i64 lowerm1;
	u64 x;
	i64 i;
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 6;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	lowerm1 = asi64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3007;
L3005:
	asu64(R1) = x;
	asu64(R2) = a;
	asi64(R1) = qq_vars_var_equal(asu64(R2), asu64(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3009;
	asi64(R1) = i;
	asi64(R2) = lowerm1;
	asi64(R1) += asi64(R2);
	goto L3004;
L3009:
	R1 = (u64)&x;
	(*tou64p(R1)) += 16;
	i += 1; if (i <= n) goto L3005;
L3007:
	R1 = 0x8000000000000000;
	goto L3004;
L3004:
	return asi64(R1);
}

static u64 qq_modules_loadsp(u64 filename, u64 source) {
    u64 R1, R2, R3, R4; 
	u64 sp;
	struct $B27 modnames;
	struct $B27 subnames;
	i64 nmods;
	i64 nsubs;
	i64 firstmod;
	i64 lastmod;
	i64 issyslib;
	u64 pm;
	u64 d;
	struct $B15 path;
	i64 i;
	R1 = 0;
	nmods = asi64(R1);
	R1 = 0;
	nsubs = asi64(R1);
	R1 = 0;
	issyslib = asi64(R1);
	asu64(R1) = source;
	if (!asu64(R1)) goto L3012;
	asu64(R1) = source;
	asu64(R2) = filename;
	asu64(R1) = qq_modules_loadstring(asu64(R2), asu64(R1));
	pm = asu64(R1);
	R1 = 0;
	R2 = (u64)&path;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L3011;
L3012:
	asu64(R1) = filename;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	R2 = (u64)&path;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = qq_cli_syslibname;
	if (!asu64(R1)) goto L3014;
	asu64(R1) = qq_cli_syslibname;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	R2 = (u64)&path;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3014;
	R1 = 1;
	issyslib = asi64(R1);
L3014:
	asi64(R1) = issyslib;
	asu64(R2) = filename;
	asu64(R1) = qq_modules_loadsourcefile(asu64(R2), asi64(R1));
	pm = asu64(R1);
	asu64(R1) = pm;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3016;
	asu64(R1) = filename;
	R2 = tou64("Can't load lead module: #");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3016:
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&path;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L3011:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nsubprogs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3019;
L3017:
	R1 = (u64)&qq_decls_subprogs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3021;
	asu64(R1) = sp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Subprog already loaded: #");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3021:
	i += 1; if (i <= qq_decls_nsubprogs) goto L3017;
L3019:
	asu64(R1) = pm;
	qq_lex_startlex(asu64(R1));
L3022:
	qq_lex_lex();
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 105;
	if (asi64(R1) == asi64(R2)) goto L3025;
	R2 = 106;
	if (asi64(R1) == asi64(R2)) goto L3026;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3027;
	goto L3028;
L3025:
	qq_lex_lex();
	R1 = 69;
	qq_lib_checksymbol(asi64(R1));
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L3030;
	asi64(R1) = nmods;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L3032;
	R1 = tou64("");
	R2 = tou64("Too many modules in header");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3032:
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&modnames;
	R3 = (u64)&nmods;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L3030:
	goto L3024;
L3026:
	qq_lex_lex();
	R1 = 69;
	qq_lib_checksymbol(asi64(R1));
	asi64(R1) = nsubs;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L3034;
	R1 = tou64("");
	R2 = tou64("Too many imports in header");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3034:
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&subnames;
	R3 = (u64)&nsubs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L3024;
L3027:
	goto L3024;
L3028:
	goto L3023;
L3024:
	goto L3022;
L3023:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nsubs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3037;
L3035:
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&subnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3039;
	R1 = tou64("");
	R2 = tou64("Importing self");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3039:
	R1 = 0;
	R2 = (u64)&subnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = tou64("");
	asu64(R2) = qq_modules_getmodulefilename(asu64(R3), asu64(R2));
	qq_cli_compile_sp(asu64(R2), asu64(R1));
	i += 1; if (i <= nsubs) goto L3035;
L3037:
	asi64(R1) = qq_decls_nsubprogs;
	R2 = 30;
	if (asi64(R1) < asi64(R2)) goto L3041;
	R1 = tou64("");
	R2 = tou64("Too many subprogs");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3041:
	R1 = 32;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	sp = asu64(R1);
	asu64(R1) = sp;
	R2 = (u64)&qq_decls_subprogs;
	R3 = (u64)&qq_decls_nsubprogs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = qq_decls_nsubprogs;
	asu64(R2) = sp;
	R3 = 31;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = qq_decls_nmodules;
	R2 = 1;
	asi64(R1) += asi64(R2);
	firstmod = asi64(R1);
	asi64(R1) = firstmod;
	asi64(R2) = nmods;
	asi64(R1) += asi64(R2);
	lastmod = asi64(R1);
	asi64(R1) = lastmod;
	R2 = 200;
	if (asi64(R1) <= asi64(R2)) goto L3043;
	R1 = tou64("");
	R2 = tou64("Too many modules");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3043:
	asi64(R1) = lastmod;
	qq_decls_nmodules = asi64(R1);
	asi64(R1) = qq_decls_nsubprogs;
	asu64(R2) = pm;
	R3 = 44;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = pm;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = firstmod;
	asu64(R2) = pm;
	R3 = 46;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 3;
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = qq_lex_addnamestr(asu64(R2));
	asu64(R3) = qq_decls_stprogram;
	asu64(R1) = qq_names_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	R2 = R1;
	d = asu64(R2);
	asu64(R2) = pm;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = firstmod;
	asu64(R2) = d;
	R3 = 114;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pm;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = firstmod;
	asu64(R2) = sp;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = lastmod;
	asu64(R2) = sp;
	R3 = 26;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = issyslib;
	asu64(R2) = sp;
	R3 = 30;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pm;
	R2 = (u64)&qq_decls_modules;
	asi64(R3) = firstmod;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nmods;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3046;
L3044:
	asi64(R1) = issyslib;
	R2 = (u64)&modnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = (u64)&path;
	asu64(R2) = qq_modules_getmodulefilename(asu64(R3), asu64(R2));
	asu64(R1) = qq_modules_loadsourcefile(asu64(R2), asi64(R1));
	pm = asu64(R1);
	asu64(R1) = pm;
	if (asu64(R1)) goto L3048;
	R1 = (u64)&modnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = tou64("Can't load: ##");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3048:
	asu64(R1) = pm;
	R2 = (u64)&qq_decls_modules;
	asi64(R3) = firstmod;
	asi64(R4) = i;
	asi64(R3) += asi64(R4);
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 3;
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = qq_lex_addnamestr(asu64(R2));
	asu64(R3) = qq_decls_stprogram;
	asu64(R1) = qq_names_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	R2 = R1;
	d = asu64(R2);
	asu64(R2) = pm;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = qq_decls_nsubprogs;
	asu64(R2) = pm;
	R3 = 44;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = firstmod;
	asi64(R2) = i;
	asi64(R1) += asi64(R2);
	R2 = R1;
	asu64(R3) = pm;
	R4 = 46;
	*toi16p(((i64)R3+(i64)R4)) = asi16(R2);
	asu64(R2) = d;
	R3 = 114;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= nmods) goto L3044;
L3046:
	asu64(R1) = sp;
	goto L3010;
L3010:
	return asu64(R1);
}

static u64 qq_modules_getmodulefilename(u64 path, u64 name) {
    u64 R1, R2; 
	asu64(R1) = path;
	R2 = (u64)&qq_modules_getmodulefilename_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = name;
	R2 = (u64)&qq_modules_getmodulefilename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(".q");
	R2 = (u64)&qq_modules_getmodulefilename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&qq_modules_getmodulefilename_str;
	goto L3049;
L3049:
	return asu64(R1);
}

static u64 qq_modules_loadsourcefile(u64 filespec, i64 issyslib) {
    u64 R1, R2, R3; 
	u64 pm;
	u64 s;
	u64 basefilename;
	struct $B15 str;
	R1 = 120;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	pm = asu64(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	basefilename = asu64(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = pm;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_extractpath(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = pm;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = basefilename;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = pm;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = issyslib;
	asu64(R2) = pm;
	R3 = 41;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = qq_decls_nqafiles;
	if (!asi64(R1)) goto L3052;
	asu64(R1) = pm;
	asi64(R1) = qq_modules_loadqafile(asu64(R1));
	if (!asi64(R1)) goto L3052;
	asu64(R1) = pm;
	goto L3050;
L3052:
	asi64(R1) = issyslib;
	if (!asi64(R1)) goto L3054;
	asu8(R1) = qq_decls_usebundled;
	if (!asu8(R1)) goto L3054;
	asi64(R1) = issyslib;
	asu64(R2) = pm;
	R3 = 41;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pm;
	asi64(R1) = qq_syslibs_loadsysmodule(asu64(R1));
	if (asi64(R1)) goto L3056;
	asu64(R1) = filespec;
	R2 = tou64("LS:Can't load syslib:");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3056:
	asu64(R1) = pm;
	goto L3050;
L3054:
	asu64(R1) = filespec;
	asu64(R1) = mlib_readfile(asu64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	if (asu64(R1)) goto L3058;
	R1 = tou64("c:/m/libs/");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = basefilename;
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(".q");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R1) = mlib_readfile(asu64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	if (asu64(R1)) goto L3060;
	R1 = 0;
	goto L3050;
L3060:
L3058:
	asu64(R1) = s;
	asu64(R2) = pm;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_rfsize;
	asu64(R2) = pm;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	asu64(R2) = s;
	asi64(R3) = mlib_rfsize;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pm;
	goto L3050;
L3050:
	return asu64(R1);
}

static u64 qq_modules_loadstring(u64 name, u64 source) {
    u64 R1, R2, R3; 
	u64 pm;
	struct $B3 str;
// PROC LOCAL STATICS GO HERE
	static i64 qq_modules_loadstring_nextstrname = 0;
	asu64(R1) = name;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3063;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("S$");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&qq_modules_loadstring_nextstrname;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	name = asu64(R1);
L3063:
	R1 = 120;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	pm = asu64(R1);
	R1 = tou64("<string>");
	asu64(R2) = pm;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = tou64("");
	asu64(R2) = pm;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = name;
	asu64(R2) = pm;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = source;
	asu64(R2) = pm;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = source;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = pm;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pm;
	goto L3061;
L3061:
	return asu64(R1);
}

static u64 qq_modules_readfileline(u64 s) {
    u64 R1, R2, R3; 
	struct $B23 str;
	u64 t;
	i64 n;
	i64 c;
	R1 = (u64)&str;
	t = asu64(R1);
	R1 = 0;
	n = asi64(R1);
L3065:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3067;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3068;
	goto L3069;
L3067:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	goto L3066;
	goto L3065;
L3068:
	goto L3066;
	goto L3065;
L3069:
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) >= asi64(R2)) goto L3071;
	asi64(R1) = c;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3071:
	goto L3065;
L3066:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	msysc_m$read_strline(asu64(R1));
	asu64(R1) = s;
	goto L3064;
L3064:
	return asu64(R1);
}

static u64 qq_modules_findnextlineheader(u64 s) {
    u64 R1, R2; 
	i64 c;
L3073:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3075;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3076;
	goto L3077;
L3075:
	R1 = 0;
	goto L3072;
	goto L3073;
L3076:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L3079;
	asu64(R1) = s;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L3079;
	asu64(R1) = s;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L3079;
	asu64(R1) = s;
	R2 = 3;
	R1 += (i64)R2;
	goto L3072;
L3079:
	goto L3073;
L3077:
	goto L3073;
	R1 = 0;
	goto L3072;
L3072:
	return asu64(R1);
}

static i64 qq_modules_loadqafile(u64 pm) {
    u64 R1, R2, R3; 
	u64 file;
	struct $B15 filename;
	i64 i;
	asu64(R1) = pm;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_extractfile(asu64(R1));
	R2 = (u64)&filename;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nqafiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3083;
L3081:
	R1 = (u64)&qq_decls_qafilenames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&filename;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3085;
	R1 = (u64)&qq_decls_qatext;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = pm;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&qq_decls_qasize;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = pm;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	goto L3080;
L3085:
	i += 1; if (i <= qq_decls_nqafiles) goto L3081;
L3083:
	R1 = 0;
	goto L3080;
L3080:
	return asi64(R1);
}

static void qq_modules_readqabundle() {
    u64 R1, R2, R3, R4; 
	struct $B5 name;
	u64 s;
	u64 t;
	i64 sys;
	i64 support;
	i64 i;
	R1 = 0;
	asu64(R2) = qq_cli_inputfile;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	R1 = tou64("qa");
	asu64(R2) = s;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L3088;
	goto L3086;
L3088:
	asu64(R1) = qq_cli_inputfile;
	asu64(R1) = mlib_readfile(asu64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3090;
	asu64(R1) = qq_cli_inputfile;
	R2 = tou64("Can't find QA file ##");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3090:
	R1 = tou64("q");
	asu64(R2) = qq_cli_inputfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	qq_cli_inputfile = asu64(R1);
	asu64(R1) = s;
	R2 = 3;
	R1 += (i64)R2;
	asu64(R1) = qq_modules_readfileline(asu64(R1));
	s = asu64(R1);
	R1 = 0;
	R2 = 110;
	R3 = (u64)&name;
	msysc_readstr(asu64(R3), asi64(R2), asi64(R1));
	R1 = tou64("qa");
	R2 = (u64)&name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L3092;
	R1 = tou64("");
	R2 = tou64("QA: bad header");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3092:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	asu64(R1) = s;
	asu64(R1) = qq_modules_findnextlineheader(asu64(R1));
	s = asu64(R1);
L3093:
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3096;
	R1 = tou64("");
	R2 = tou64("Unexpected EOF in QA file");
	qq_lib_loaderror(asu64(R2), asu64(R1));
	goto L3094;
L3096:
	asu64(R1) = s;
	asu64(R1) = qq_modules_readfileline(asu64(R1));
	s = asu64(R1);
	R1 = 0;
	R2 = 110;
	R3 = (u64)&name;
	msysc_readstr(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R1) = msysc_m$read_i64(asi64(R1));
	sys = asi64(R1);
	R1 = 0;
	asi64(R1) = msysc_m$read_i64(asi64(R1));
	support = asi64(R1);
	R1 = tou64("end");
	R2 = (u64)&name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3098;
	goto L3094;
L3098:
	asi64(R1) = qq_decls_nqafiles;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L3100;
	R1 = tou64("");
	R2 = tou64("Too many QA files");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3100:
	asu64(R1) = s;
	asu64(R1) = qq_modules_findnextlineheader(asu64(R1));
	t = asu64(R1);
	asu64(R1) = t;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3102;
	R1 = tou64("");
	R2 = tou64("QA error");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3102:
	R1 = (u64)&qq_decls_nqafiles;
	(*toi64p(R1)) += 1;
	R1 = (u64)&name;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&qq_decls_qafilenames;
	asi64(R3) = qq_decls_nqafiles;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = t;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	R2 = 3;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&qq_decls_qasize;
	asi64(R3) = qq_decls_nqafiles;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = s;
	R2 = (u64)&qq_decls_qatext;
	asi64(R3) = qq_decls_nqafiles;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = t;
	s = asu64(R1);
	goto L3093;
L3094:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nqafiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3105;
L3103:
	R1 = 0;
	R2 = (u64)&qq_decls_qatext;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = (u64)&qq_decls_qasize;
	asi64(R4) = i;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= qq_decls_nqafiles) goto L3103;
L3105:
L3086:
	return;
}

static u64 qq_names_addglobalname(u64 name) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	struct $B3 oldlx;
	u64 d;
	(R1_B3) = qq_decls_nextlx;
	oldlx = (R1_B3);
	asu64(R1) = name;
	asi64(R1) = qq_lex_gethashvaluez(asu64(R1));
	asu64(R2) = name;
	asi64(R2) = strlen(asu64(R2));
	asu64(R3) = name;
	asi64(R1) = qq_lex_lookup(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&qq_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	(R1_B3) = oldlx;
	qq_decls_nextlx = (R1_B3);
	asu64(R1) = d;
	goto L3106;
L3106:
	return asu64(R1);
}

static u64 qq_names_newstrec() {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 128;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	R1 = 128;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asu64(R1) = p;
	goto L3107;
L3107:
	return asu64(R1);
}

static u64 qq_names_addsymbol(u64 owner, u64 d, i64 id, i64 isglobal) {
    u64 R1, R2, R3, R4; 
	u64 e;
	u64 f;
	asu64(R1) = qq_names_newstrec();
	e = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 126;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 126;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = owner;
	asu64(R2) = e;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = id;
	asu64(R2) = e;
	R3 = 124;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = id;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L3109;
	asi64(R1) = id;
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L3110;
L3109:
	R1 = 1;
	goto L3111;
L3110:
	R1 = 0;
L3111:
	asu64(R2) = e;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 9;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = qq_decls_currmodule;
	if (!asu64(R1)) goto L3113;
	asu64(R1) = qq_decls_currmodule;
	R2 = 46;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 114;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3113:
	asu64(R1) = d;
	asu64(R2) = e;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = isglobal;
	asu64(R2) = e;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 1;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = owner;
	if (asu64(R1)) goto L3115;
	asu64(R1) = e;
	goto L3108;
L3115:
	asu64(R1) = owner;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3117;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L3117;
	asu64(R1) = d;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	asu64(R2) = d;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L3119;
	asu64(R1) = e;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) != asu64(R2)) goto L3119;
	msysc_m$print_startcon();
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("in");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = owner;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("AS:Duplicate name");
	qq_lib_serror(asu64(R1));
L3119:
	goto L3116;
L3117:
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	f = asu64(R1);
	goto L3121;
L3120:
	asu64(R1) = f;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 48;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3124;
	msysc_m$print_startcon();
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("in");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = owner;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("AS2:Duplicate name");
	qq_lib_serror(asu64(R1));
L3124:
	asu64(R1) = f;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	f = asu64(R1);
L3121:
	asu64(R1) = f;
	if (asu64(R1)) goto L3120;
L3116:
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3126;
	asu64(R1) = e;
	asu64(R2) = owner;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L3125;
L3126:
	asu64(R1) = e;
	asu64(R2) = owner;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3125:
	asu64(R1) = e;
	asu64(R2) = owner;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	goto L3108;
L3108:
	return asu64(R1);
}

static void qq_names_addproc(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = qq_decls_proclist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3129;
	asu64(R1) = p;
	qq_decls_proclist = asu64(R1);
	goto L3128;
L3129:
	asu64(R1) = p;
	asu64(R2) = qq_decls_proclistx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3128:
	asu64(R1) = p;
	qq_decls_proclistx = asu64(R1);
	R1 = (u64)&qq_decls_nproclist;
	(*toi64p(R1)) += 1;
	return;
}

static i64 qq_names_newusertypex(u64 d, u64 e) {
    u64 R1, R2, R3; 
	i64 i;
	asi64(R1) = qq_tables_nuserxtypes;
	R2 = 5000;
	if (asi64(R1) < asi64(R2)) goto L3132;
	R1 = tou64("Too many external user types");
	qq_lib_serror(asu64(R1));
L3132:
	R1 = (u64)&qq_tables_nuserxtypes;
	(*toi64p(R1)) += 1;
	asu64(R1) = d;
	R2 = (u64)&qq_tables_ttnamedefx;
	asi64(R3) = qq_tables_nuserxtypes;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = qq_decls_stcurrmodule;
	R2 = 114;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_tables_ttxmoduleno;
	asi64(R3) = qq_tables_nuserxtypes;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = qq_tables_nuserxtypes;
	asi64(R1) = -asi64(R1);
	goto L3130;
L3130:
	return asi64(R1);
}

static u64 qq_names_resolvedottedname(u64 owner, u64 d) {
    u64 R1, R2; 
	u64 e;
	asu64(R1) = d;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L3135;
L3134:
	asu64(R1) = e;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L3135:
	asu64(R1) = e;
	if (!asu64(R1)) goto L3137;
	asu64(R1) = e;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) != asu64(R2)) goto L3134;
L3137:
	asu64(R1) = e;
	goto L3133;
L3133:
	return asu64(R1);
}

static void qq_names_addgenfield(u64 d) {
    u64 R1, R2, R3; 
	i64 index;
	u64 dgen;
	u64 g;
	asu64(R1) = d;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dgen = asu64(R1);
	asu64(R1) = dgen;
	R2 = 104;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	index = asi64(R1);
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3140;
	asi64(R1) = qq_decls_ngenfields;
	R2 = 1000;
	if (asi64(R1) < asi64(R2)) goto L3142;
	R1 = 0;
	R2 = tou64("Too many genfields");
	qq_lib_gerror(asu64(R2), asu64(R1));
L3142:
	R1 = (u64)&qq_decls_ngenfields;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = R1;
	index = asi64(R2);
	asu64(R2) = dgen;
	R3 = 104;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L3140:
	R1 = 16;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	g = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = g;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&qq_decls_genfieldtable;
	asi64(R2) = index;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = g;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = g;
	R2 = (u64)&qq_decls_genfieldtable;
	asi64(R3) = index;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	return;
}

static i64 qq_names_makereftype(i64 target, u64 owner) {
    u64 R1, R2, R3; 
	i64 newtype;
	i64 i;
	asu64(R1) = owner;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3145;
	R1 = 41;
	i = asi64(R1);
	asi64(R1) = qq_tables_ntypes;
	R2 = 41;
	if (asi64(R1) < asi64(R2)) goto L3148;
L3146:
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = i;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L3150;
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = i;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asi64(R2) = target;
	if (asi64(R1) != asi64(R2)) goto L3150;
	asi64(R1) = i;
	goto L3143;
L3150:
	i += 1; if (i <= qq_tables_ntypes) goto L3146;
L3148:
L3145:
	asi64(R1) = qq_names_addanontype();
	newtype = asi64(R1);
	R1 = 16;
	R2 = (u64)&qq_tables_ttbasetype;
	asi64(R3) = newtype;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = newtype;
	R1 += (i64)R2*2;
	asi64(R2) = target;
	asu64(R3) = qq_decls_stcurrproc;
	qq_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	R1 = 8;
	R2 = (u64)&qq_tables_ttsize;
	asi64(R3) = newtype;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = 64;
	R2 = (u64)&qq_tables_ttbitwidth;
	asi64(R3) = newtype;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = newtype;
	goto L3143;
L3143:
	return asi64(R1);
}

static i64 qq_names_makeaxtype(i64 target, u64 plower, u64 plength) {
    u64 R1, R2, R3; 
	i64 newtype;
	i64 length;
	asi64(R1) = qq_names_addanontype();
	newtype = asi64(R1);
	R1 = 7;
	R2 = (u64)&qq_tables_ttbasetype;
	asi64(R3) = newtype;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = newtype;
	R1 += (i64)R2*2;
	asi64(R2) = target;
	asu64(R3) = qq_decls_stcurrproc;
	qq_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	R1 = 1;
	R2 = (u64)&qq_tables_ttlower;
	asi64(R3) = newtype;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asu64(R1) = plength;
	R2 = (u64)&qq_tables_ttlengthexpr;
	asi64(R3) = newtype;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = plower;
	R2 = (u64)&qq_tables_ttlowerexpr;
	asi64(R3) = newtype;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = newtype;
	goto L3151;
L3151:
	return asi64(R1);
}

static i64 qq_names_makestrtype(i64 m, u64 pwidth) {
    u64 R1, R2, R3; 
	i64 newtype;
	asi64(R1) = qq_names_addanontype();
	newtype = asi64(R1);
	asi64(R1) = m;
	R2 = (u64)&qq_tables_ttbasetype;
	asi64(R3) = newtype;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asu64(R1) = pwidth;
	R2 = (u64)&qq_tables_ttlengthexpr;
	asi64(R3) = newtype;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_ttlower;
	asi64(R3) = newtype;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asu64(R1) = qq_decls_stcurrproc;
	R2 = (u64)&qq_tables_ttowner;
	asi64(R3) = newtype;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = newtype;
	goto L3152;
L3152:
	return asi64(R1);
}

static i64 qq_names_addanontype() {
    u64 R1, R2, R3; 
	struct $B31 str;
	asi64(R1) = qq_tables_ntypes;
	R2 = 250;
	if (asi64(R1) < asi64(R2)) goto L3155;
	R1 = 0;
	R2 = tou64("Too many types");
	qq_lib_gerror(asu64(R2), asu64(R1));
L3155:
	R1 = (u64)&qq_tables_ntypes;
	(*toi64p(R1)) += 1;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$T");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = qq_tables_ntypes;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&qq_tables_ttname;
	asi64(R3) = qq_tables_ntypes;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = qq_decls_stcurrproc;
	R2 = (u64)&qq_tables_ttowner;
	asi64(R3) = qq_tables_ntypes;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = qq_tables_ntypes;
	goto L3153;
L3153:
	return asi64(R1);
}

static void qq_names_createusertype(u64 d, i64 m) {
    u64 R1, R2, R3; 
	asu64(R1) = d;
	R2 = 116;
	R1 += (i64)R2;
	asi64(R2) = m;
	asu64(R3) = qq_decls_stcurrproc;
	qq_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = m;
	R2 = 40;
	if (asi64(R1) <= asi64(R2)) goto L3158;
	R1 = (u64)&qq_tables_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3158;
	asu64(R1) = d;
	R2 = (u64)&qq_tables_ttnamedef;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_tables_ttname;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_tables_ttowner;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
L3158:
	return;
}

static i64 qq_names_getalignment(i64 m) {
    u64 R1, R2; 
	i64 a;
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L3161;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3162;
	goto L3163;
L3161:
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asi64(R1) = qq_names_getalignment(asi64(R1));
	goto L3159;
	goto L3160;
L3162:
	goto L3160;
L3163:
L3160:
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3165;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3165;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3165;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3165;
	goto L3166;
L3165:
	asi64(R1) = a;
	goto L3159;
	goto L3164;
L3166:
L3164:
	msysc_m$print_startcon();
	R1 = (u64)&qq_tables_ttname;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = a;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Getalign not 1248");
	qq_lib_gerror(asu64(R2), asu64(R1));
	R1 = 0;
	goto L3159;
L3159:
	return asi64(R1);
}

static void qq_names_duplfield(u64 p, u64 q) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L3169;
	R1 = tou64("DUPLFIELD");
	qq_lib_serror(asu64(R1));
L3169:
	asu64(R1) = p;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 96;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 108;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 108;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	return;
}

static void qq_names_writesig(u64 d, u64 dev) {
    u64 R1, R2, R3; 
	u64 e;
	i64 n;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("# #(");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 4;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L3172;
	R1 = tou64("function");
	goto L3171;
L3172:
	R1 = tou64("proc");
L3171:
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	goto L3176;
L3173:
	asu64(R1) = e;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L3178;
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asu64(R1) = e;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L3180;
	asu64(R1) = e;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L3180;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("#=#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = e;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_lib_strexpr(asu64(R1));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L3179;
L3180:
	asu64(R1) = e;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L3181;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("?");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L3179;
L3181:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L3179:
	asi64(R1) = n;
	asu64(R2) = d;
	R3 = 104;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	if (asi64(R1) >= asi64(R2)) goto L3183;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(", ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L3183:
L3178:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L3176:
	asu64(R1) = e;
	if (asu64(R1)) goto L3173;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(")\t[#]");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static u64 qq_names_createdupldef(u64 owner, u64 symptr, i64 id) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	asu64(R1) = qq_names_newstrec();
	p = asu64(R1);
	asu64(R1) = symptr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = symptr;
	R2 = 126;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 126;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 69;
	asu64(R2) = p;
	R3 = 123;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = owner;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = id;
	asu64(R2) = p;
	R3 = 124;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = symptr;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = symptr;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = owner;
	if (!asu64(R1)) goto L3186;
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3188;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = owner;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = owner;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L3187;
L3188:
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3187:
L3186:
	asu64(R1) = p;
	goto L3184;
L3184:
	return asu64(R1);
}

static void qq_packed_var_loadpacked(u64 p, i64 t, u64 dest, u64 ownerobj) {
    u64 R1, R2, R3, R4; 
	i64 length;
	u64 q;
	u64 r;
	u64 pp;
	u64 s;
	u64 ss;
	i64 av_1;
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	switch (asi64(R1)) {
	case 23: goto L3193;
	case 24: goto L3194;
	case 25: goto L3195;
	case 26: goto L3196;
	case 27: goto L3197;
	case 28: goto L3198;
	case 29: goto L3199;
	case 30: goto L3200;
	case 31: goto L3202;
	case 32: goto L3201;
	case 33: case 34: case 35: goto L3192;
	case 36: goto L3203;
	case 37: goto L3206;
	default: goto L3192;
    };
// SWITCH
L3193:
	asu64(R1) = p;
	asi8(R1) = *toi8p(R1);
	R1 = toi64(toi8(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L3190;
L3194:
	asu64(R1) = p;
	asi16(R1) = *toi16p(R1);
	R1 = toi64(toi16(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L3190;
L3195:
	asu64(R1) = p;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L3190;
L3196:
	asu64(R1) = p;
	asi64(R1) = *toi64p(R1);
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L3190;
L3197:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L3190;
L3198:
	asu64(R1) = p;
	asu16(R1) = *tou16p(R1);
	R1 = toi64(tou16(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L3190;
L3199:
	asu64(R1) = p;
	asu32(R1) = *tou32p(R1);
	R1 = toi64(tou32(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L3190;
L3200:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R1) = *tou64p(R1);
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L3190;
L3201:
	R1 = 2;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asr64(R1) = *tor64p(R1);
	asu64(R2) = dest;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L3190;
L3202:
	R1 = 2;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asr32(R1) = *tor32p(R1);
    asr64(R1) = tor64(asr32(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L3190;
L3203:
	R1 = 265;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L3205;
	asi64(R1) = length;
	asu64(R2) = p;
	asi64(R1) = qq_packed_getfslength(asu64(R2), asi64(R1));
	length = asi64(R1);
	goto L3204;
L3205:
	R1 = 1;
	length = asi64(R1);
L3204:
	asi64(R1) = length;
	asu64(R2) = p;
	asu64(R1) = qq_strings_obj_make_strslicexobj(asu64(R2), asi64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L3190;
L3206:
	R1 = 265;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	ss = asu64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3209;
L3207:
	asu64(R1) = ss;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3211;
	goto L3209;
L3211:
	R1 = (u64)&ss;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L3207;
L3209:
	asu64(R1) = ss;
	asu64(R2) = p;
	asi64(R1) -= asi64(R2);
	asu64(R2) = p;
	asu64(R1) = qq_strings_obj_make_strslicexobj(asu64(R2), asi64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L3190;
L3192:
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L3213;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3214;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L3215;
	goto L3216;
L3213:
	R1 = 16;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R1) = *tou64p(R1);
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R2) = dest;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L3212;
L3214:
	asu64(R1) = qq_vars_obj_new();
	s = asu64(R1);
	R1 = 1;
	asu64(R2) = s;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = p;
	asu64(R2) = s;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = s;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 269;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = t;
	asu64(R2) = s;
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = ownerobj;
	if (!asu64(R1)) goto L3218;
	R1 = 1;
	asu64(R2) = s;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = ownerobj;
	asu64(R2) = s;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = ownerobj;
	(*tou32p(R1)) += 1;
	goto L3217;
L3218:
	R1 = 2;
	asu64(R2) = s;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3217:
	goto L3212;
L3215:
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&qq_tables_ttlower;
	asi64(R3) = t;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	R3 = (u64)&qq_tables_tttarget;
	asi64(R4) = t;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	asu64(R1) = qq_arrays_obj_newarray(asi64(R3), asi64(R2), asi64(R1));
	s = asu64(R1);
	R1 = 1;
	asu64(R2) = s;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = p;
	asu64(R2) = s;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = s;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 263;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = t;
	asu64(R2) = s;
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = ownerobj;
	if (!asu64(R1)) goto L3220;
	R1 = 1;
	asu64(R2) = s;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = ownerobj;
	asu64(R2) = s;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = ownerobj;
	(*tou32p(R1)) += 1;
	goto L3219;
L3220:
	R1 = 2;
	asu64(R2) = s;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3219:
	goto L3212;
L3216:
	asi64(R1) = t;
	R2 = (u64)&qq_tables_ttbasetype;
	asi64(R3) = t;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = tou64("loadpacked");
	qq_runaux_pcmxtypestt(asu64(R3), asi64(R2), asi64(R1));
L3212:
L3190:
	return;
}

static void qq_packed_var_storepacked(u64 p, u64 q, i64 t) {
    u64 R1, R2, R3; 
	i64 plength;
	i64 qlength;
	i64 s;
	i64 sbase;
	i64 tbase;
	u64 qa;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	sbase = asi64(R2);
	s = asi64(R1);
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	tbase = asi64(R1);
	asi64(R1) = sbase;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3223;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L3223;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3224;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L3225;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3226;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L3227;
	goto L3228;
L3223:
	asi64(R1) = tbase;
	switch (asi64(R1)) {
	case 16: case 26: case 30: goto L3235;
	case 17: case 18: case 19: case 20: case 21: case 22: goto L3231;
	case 23: case 27: goto L3232;
	case 24: case 28: goto L3233;
	case 25: case 29: goto L3234;
	case 31: goto L3236;
	case 32: goto L3237;
	default: goto L3231;
    };
// SWITCH
L3232:
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L3221;
	goto L3229;
L3233:
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	*tou16p(R2) = asu16(R1);
	goto L3221;
	goto L3229;
L3234:
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	*toi32p(R2) = asi32(R1);
	goto L3221;
	goto L3229;
L3235:
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	*toi64p(R2) = asi64(R1);
	goto L3221;
	goto L3229;
L3236:
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr32(R1) = tor32(asi64(R1));
	asu64(R2) = p;
	*tor32p(R2) = asr32(R1);
	goto L3221;
	goto L3229;
L3237:
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = p;
	*tor64p(R2) = asr64(R1);
	goto L3221;
	goto L3229;
L3231:
L3229:
	goto L3222;
L3224:
	asi64(R1) = tbase;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L3239;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L3239;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L3240;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L3240;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L3241;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L3242;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L3243;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L3243;
	goto L3244;
L3239:
	asu64(R1) = q;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = toi64(asr64(R1));
	asu64(R2) = p;
	*toi32p(R2) = asi32(R1);
	goto L3221;
	goto L3238;
L3240:
	asu64(R1) = q;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = toi64(asr64(R1));
	asu64(R2) = p;
	*toi64p(R2) = asi64(R1);
	goto L3221;
	goto L3238;
L3241:
	asu64(R1) = q;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
    asr32(R1) = tor32(asr64(R1));
	asu64(R2) = p;
	*tor32p(R2) = asr32(R1);
	goto L3221;
	goto L3238;
L3242:
	asu64(R1) = q;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	*tor64p(R2) = asr64(R1);
	goto L3221;
	goto L3238;
L3243:
	asu64(R1) = q;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = toi64(asr64(R1));
	asu64(R2) = p;
	*toi16p(R2) = asi16(R1);
	goto L3221;
	goto L3238;
L3244:
L3238:
	goto L3222;
L3225:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qa = asu64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	plength = asi64(R1);
	asu64(R1) = qa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	qlength = asi64(R1);
	asi64(R1) = tbase;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L3246;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L3247;
	goto L3248;
L3246:
	asi64(R1) = t;
	asi64(R2) = tbase;
	if (asi64(R1) != asi64(R2)) goto L3250;
	asi64(R1) = qlength;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3252;
	R1 = tou64("");
	R2 = tou64("Str not len 1");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L3252:
	asu64(R1) = qa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L3221;
L3250:
	asi64(R1) = qlength;
	asi64(R2) = plength;
	if (asi64(R1) <= asi64(R2)) goto L3254;
	asi64(R1) = plength;
	qlength = asi64(R1);
L3254:
	asi64(R1) = qlength;
	asu64(R2) = qa;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = qlength;
	asi64(R2) = plength;
	asu64(R3) = p;
	qq_packed_setfslength(asu64(R3), asi64(R2), asi64(R1));
	goto L3221;
	goto L3245;
L3247:
	asi64(R1) = qlength;
	asi64(R2) = plength;
	if (asi64(R1) < asi64(R2)) goto L3256;
	asi64(R1) = plength;
	asu64(R2) = qa;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	asi64(R3) = plength;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	goto L3255;
L3256:
	asi64(R1) = qlength;
	asu64(R2) = qa;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	asi64(R3) = qlength;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3255:
	goto L3221;
	goto L3245;
L3248:
L3245:
	goto L3222;
L3226:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	s = asi64(R1);
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) == asi64(R2)) goto L3258;
	asi64(R1) = t;
	asi64(R2) = s;
	R3 = tou64("spack struct");
	qq_runaux_pcmxtypestt(asu64(R3), asi64(R2), asi64(R1));
L3258:
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L3221;
	goto L3222;
L3227:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	s = asi64(R1);
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) == asi64(R2)) goto L3260;
	asi64(R1) = t;
	asi64(R2) = s;
	R3 = tou64("spack array");
	qq_runaux_pcmxtypestt(asu64(R3), asi64(R2), asi64(R1));
L3260:
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L3221;
	goto L3222;
L3228:
L3222:
	asi64(R1) = t;
	asi64(R2) = s;
	R3 = tou64("storepacked (source->dest)");
	qq_runaux_pcmxtypestt(asu64(R3), asi64(R2), asi64(R1));
L3221:
	return;
}

static void qq_packed_setfslength(u64 s, i64 m, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = m;
	asi64(R2) = n;
	if (asi64(R1) != asi64(R2)) goto L3263;
	goto L3262;
L3263:
	asi64(R1) = n;
	asi64(R2) = m;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	if (asi64(R1) != asi64(R2)) goto L3264;
	R1 = 0;
	asu64(R2) = s;
	asi64(R3) = m;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	goto L3262;
L3264:
	R1 = 0;
	asu64(R2) = s;
	asi64(R3) = m;
	R2 += (i64)R3;
	R3 = 2;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asi64(R3) = m;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
L3262:
	return;
}

static i64 qq_packed_getfslength(u64 s, i64 m) {
    u64 R1, R2; 
	asi64(R1) = m;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = s;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3267;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	goto L3266;
L3267:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3268;
	asi64(R1) = m;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	goto L3266;
L3268:
	asi64(R1) = m;
L3266:
	goto L3265;
L3265:
	return asi64(R1);
}

static void qq_packed_var_make_struct(u64 a, u64 dest, i64 n, i64 rectype) {
    u64 R1, R2, R3; 
	u64 d;
	u64 r;
	u64 p;
	u64 b;
	i64 m;
	u64 q;
	i64 av_1;
	asi64(R1) = rectype;
	asu64(R1) = qq_packed_obj_new_struct(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = rectype;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	m = asi64(R1);
	R1 = (u64)&qq_tables_ttnamedef;
	asi64(R2) = rectype;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asi64(R1) = n;
	asi64(R2) = m;
	if (asi64(R1) >= asi64(R2)) goto L3271;
	R1 = tou64("");
	R2 = tou64("Too few elements");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L3270;
L3271:
	asi64(R1) = n;
	asi64(R2) = m;
	if (asi64(R1) <= asi64(R2)) goto L3272;
	msysc_m$print_startcon();
	R1 = tou64("N=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("M=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = m;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("Too many elements");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L3272:
L3270:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3275;
L3273:
	asu64(R1) = r;
	asu64(R1) = *tou64p(R1);
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = a;
	asu64(R3) = q;
	qq_packed_var_storepacked(asu64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = r;
	asu64(R2) = *tou64p(R2);
	R3 = 116;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&q;
	*tou64p(R2) += asu64(R1);
	R1 = (u64)&r;
	(*tou64p(R1)) += 8;
	R1 = (u64)&a;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L3273;
L3275:
	R1 = 269;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = rectype;
	asu64(R2) = p;
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = p;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 qq_packed_obj_new_struct(i64 m) {
    u64 R1, R2, R3; 
	u64 p;
	i64 size;
	asu64(R1) = qq_vars_obj_new();
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = m;
	asu64(R2) = p;
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
	asi64(R1) = size;
	if (!asi64(R1)) goto L3278;
	asi64(R1) = size;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3278:
	asu64(R1) = p;
	goto L3276;
L3276:
	return asu64(R1);
}

static void qq_packed_var_dupl_struct(u64 a) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	i64 size;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R1) = qq_packed_obj_new_struct(asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = size;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = q;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void qq_packed_obj_free_struct(u64 p) {
    u64 R1, R2, R3; 
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = p;
	mlib_pcm_free32(asu64(R1));
	return;
}

static i64 qq_packed_var_equal_struct(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = x;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = y;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = x;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R1) = mlib_eqbytes(asu64(R3), asu64(R2), asi64(R1));
	goto L3281;
L3281:
	return asi64(R1);
}

static void qq_packed_var_getix_struct(u64 a, i64 index) {
    u64 R1, R2, R3, R4, R5, R6; struct $B3 R1_B3; 
	u64 d;
	u64 r;
	struct $B3 v;
	u64 p;
	i64 elemtype;
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	v = (R1_B3);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asi64(R1) = index;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3285;
	asi64(R1) = index;
	R2 = (u64)&qq_tables_ttlength;
	asu64(R3) = a;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	if (asi64(R1) <= asi64(R2)) goto L3284;
L3285:
	R1 = tou64("");
	R2 = tou64("struct[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L3284:
	R1 = (u64)&qq_tables_ttnamedef;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = index;
	R1 += (i64)R2*8;
	R2 = 1;
	R1 -= (i64)R2*8;
	r = asu64(R1);
	R1 = 0;
	asu64(R2) = a;
	asu64(R3) = r;
	asu64(R3) = *tou64p(R3);
	R4 = 116;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	asu64(R4) = p;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R5) = r;
	asu64(R5) = *tou64p(R5);
	R6 = 108;
	asi16(R5) = *toi16p(((i64)R5+(i64)R6));
	R5 = toi64(toi16(R5));
	R4 += (i64)R5;
	qq_packed_var_loadpacked(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void qq_parse_parsemodule(u64 pm) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asu64(R1) = pm;
	R2 = 43;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3288;
	goto L3286;
L3288:
	asu64(R1) = pm;
	qq_decls_currmodule = asu64(R1);
	asu64(R1) = qq_decls_currmodule;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_decls_stcurrmodule = asu64(R1);
	asu64(R1) = qq_decls_currmodule;
	qq_lex_startlex(asu64(R1));
	qq_lex_lex();
	qq_lex_lex();
	asu64(R1) = qq_decls_stcurrmodule;
	qq_decls_stcurrproc = asu64(R1);
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = pm;
	R4 = 48;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = qq_decls_stcurrmodule;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3290;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L3291;
	goto L3292;
L3290:
	R1 = tou64("Comma seq not allowed");
	qq_lib_serror(asu64(R1));
	goto L3289;
L3291:
	goto L3289;
L3292:
	R1 = tou64("EOF");
	qq_lex_ps(asu64(R1));
	R1 = tou64("Bad symbol at eof");
	qq_lib_serror(asu64(R1));
L3289:
L3286:
	return;
}

static u64 qq_parse_readexpression() {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = qq_parse_readterm2();
	p = asu64(R1);
	R1 = (u64)&qq_tables_exprendset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3295;
	asu64(R1) = p;
	goto L3293;
L3295:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3297;
	asu64(R1) = p;
	asu64(R1) = qq_parse_readassignment(asu64(R1));
	goto L3296;
L3297:
	asu64(R1) = p;
	asu64(R1) = qq_parse_readorterms(asu64(R1));
L3296:
	goto L3293;
L3293:
	return asu64(R1);
}

static u64 qq_parse_readassignment(u64 p) {
    u64 R1, R2, R3; 
	i64 pos;
	i64 isdeep;
	u64 q;
	u64 r;
	R1 = (u64)&qq_tables_exprendset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3300;
	asu64(R1) = p;
	goto L3298;
L3300:
	asu64(R1) = p;
	asu64(R1) = qq_parse_readorterms(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3302;
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	isdeep = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	asu64(R1) = qq_parse_readassignment(asu64(R1));
	asu64(R2) = p;
	R3 = 2;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = isdeep;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L3302:
	asu64(R1) = p;
	goto L3298;
L3298:
	return asu64(R1);
}

static u64 qq_parse_readorterms(u64 p) {
    u64 R1, R2, R3; 
	i64 pos;
	u64 q;
	u64 r;
	R1 = (u64)&qq_tables_exprendset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3305;
	asu64(R1) = p;
	goto L3303;
L3305:
	asu64(R1) = p;
	asu64(R1) = qq_parse_readandterms(asu64(R1));
	p = asu64(R1);
	goto L3307;
L3306:
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3310;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = p;
	R3 = 81;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L3308;
L3310:
	asu64(R1) = qq_parse_readterm2();
	asu64(R1) = qq_parse_readandterms(asu64(R1));
	asu64(R2) = p;
	R3 = 73;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L3307:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L3306;
L3308:
	goto L3312;
L3311:
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	R2 = R1;
	r = asu64(R2);
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 26;
	if (asi64(R1) != asi64(R2)) goto L3315;
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	goto L3319;
L3316:
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L3319:
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L3316;
	asu64(R1) = p;
	asu64(R2) = r;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	p = asu64(R1);
	goto L3314;
L3315:
	asu64(R1) = p;
	asu64(R2) = q;
	R3 = 26;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L3314:
L3312:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3311;
	asu64(R1) = p;
	goto L3303;
L3303:
	return asu64(R1);
}

static u64 qq_parse_readandterms(u64 p) {
    u64 R1, R2, R3; 
	i64 pos;
	asu64(R1) = p;
	asu64(R1) = qq_parse_readcmpterms(asu64(R1));
	p = asu64(R1);
	goto L3322;
L3321:
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3325;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = p;
	R3 = 80;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L3323;
L3325:
	asu64(R1) = qq_parse_readterm2();
	asu64(R1) = qq_parse_readcmpterms(asu64(R1));
	asu64(R2) = p;
	R3 = 72;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L3322:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L3321;
L3323:
	asu64(R1) = p;
	goto L3320;
L3320:
	return asu64(R1);
}

static u64 qq_parse_readcmpterms(u64 p) {
    u64 R1, R2, R3; 
	i64 pos;
	i64 n;
	u64 px;
	u64 q;
	u32 conds;
	asu64(R1) = p;
	asu64(R1) = qq_parse_readinterms(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&qq_tables_cmpopset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3328;
	asu64(R1) = p;
	goto L3326;
L3328:
	R1 = (u64)&conds;
	memset(R1, 0, 4);
	asu64(R1) = p;
	px = asu64(R1);
	asu64(R1) = p;
	R2 = 38;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	goto L3330;
L3329:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) <= asi64(R2)) goto L3333;
	R1 = tou64("cmpchain: Too many items");
	qq_lib_serror(asu64(R1));
L3333:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&conds;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	asu64(R1) = qq_parse_readinterms(asu64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = px;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	px = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = q;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L3330:
	R1 = (u64)&qq_tables_cmpopset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3329;
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3335;
	R1 = 71;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&conds;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L3334;
L3335:
	asu32(R1) = conds;
	asu64(R2) = p;
	R3 = 24;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L3334:
	asu64(R1) = p;
	goto L3326;
L3326:
	return asu64(R1);
}

static u64 qq_parse_readinterms(u64 p) {
    u64 R1, R2, R3; 
	i64 pos;
	i64 tag;
	i64 flag;
	asu64(R1) = p;
	asu64(R1) = qq_parse_readrangeterm(asu64(R1));
	p = asu64(R1);
L3337:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L3339;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L3339;
	goto L3340;
L3339:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L3342;
	R1 = 76;
	goto L3341;
L3342:
	R1 = 77;
L3341:
	tag = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	flag = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	asu64(R1) = qq_parse_readrangeterm(asu64(R1));
	asu64(R2) = p;
	asi64(R3) = tag;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = flag;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L3337;
L3340:
	goto L3338;
	goto L3337;
L3338:
	asu64(R1) = p;
	goto L3336;
L3336:
	return asu64(R1);
}

static u64 qq_parse_readrangeterm(u64 p) {
    u64 R1, R2, R3; 
	i64 pos;
	asu64(R1) = p;
	asu64(R1) = qq_parse_readaddterms(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L3345;
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	asu64(R1) = qq_parse_readaddterms(asu64(R1));
	asu64(R2) = p;
	R3 = 87;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L3345:
	asu64(R1) = p;
	goto L3343;
L3343:
	return asu64(R1);
}

static u64 qq_parse_readaddterms(u64 p) {
    u64 R1, R2, R3; 
	i64 pos;
	i64 opc;
	i64 a;
	i64 b;
	i64 tag;
	u64 q;
	asu64(R1) = p;
	asu64(R1) = qq_parse_readmulterms(asu64(R1));
	p = asu64(R1);
	goto L3348;
L3347:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L3351;
	R1 = 119;
	opc = asi64(R1);
L3351:
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3353;
	qq_lex_lex();
	asi64(R1) = opc;
	R2 = 119;
	if (asi64(R1) != asi64(R2)) goto L3355;
	R1 = 84;
	tag = asi64(R1);
	goto L3354;
L3355:
	asi64(R1) = opc;
	R2 = 118;
	if (asi64(R1) != asi64(R2)) goto L3356;
	R1 = 85;
	tag = asi64(R1);
	goto L3354;
L3356:
	R1 = 79;
	tag = asi64(R1);
L3354:
	asu64(R1) = qq_parse_readterm2();
	asu64(R1) = qq_parse_readassignment(asu64(R1));
	asu64(R2) = p;
	asi64(R3) = tag;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L3349;
L3353:
	asu64(R1) = qq_parse_readterm2();
	asu64(R1) = qq_parse_readmulterms(asu64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 63;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L3348:
	R1 = (u64)&qq_tables_addopset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3347;
L3349:
	asu64(R1) = p;
	goto L3346;
L3346:
	return asu64(R1);
}

static u64 qq_parse_readmulterms(u64 p) {
    u64 R1, R2, R3; 
	i64 pos;
	i64 opc;
	i64 a;
	i64 b;
	u64 q;
	asu64(R1) = p;
	asu64(R1) = qq_parse_readpowerterms(asu64(R1));
	p = asu64(R1);
	goto L3359;
L3358:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3362;
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	asu64(R1) = qq_parse_readassignment(asu64(R1));
	asu64(R2) = p;
	R3 = 79;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L3360;
L3362:
	asu64(R1) = qq_parse_readterm2();
	asu64(R1) = qq_parse_readpowerterms(asu64(R1));
	asu64(R2) = p;
	R3 = 63;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L3359:
	R1 = (u64)&qq_tables_mulopset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3358;
L3360:
	asu64(R1) = p;
	goto L3357;
L3357:
	return asu64(R1);
}

static u64 qq_parse_readpowerterms(u64 p) {
    u64 R1, R2, R3; 
	i64 pos;
	goto L3365;
L3364:
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	asu64(R1) = qq_parse_readpowerterms(asu64(R1));
	asu64(R2) = p;
	R3 = 63;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 121;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L3365:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L3364;
	asu64(R1) = p;
	goto L3363;
L3363:
	return asu64(R1);
}

static u64 qq_parse_readterm2() {
    u64 R1, R2; 
	u64 p;
	i64 pos;
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	asu64(R1) = qq_parse_readterm();
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	asu64(R1) = qq_parse_readtermsuffix(asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L3367;
L3367:
	return asu64(R1);
}

static u64 qq_parse_readtermsuffix(u64 p, i64 pos) {
    u64 R1, R2, R3; 
	u64 q;
	u64 r;
	u64 pbyte;
	u64 a;
	i64 opc;
	i64 oldipl;
	i64 shift;
	i64 t;
	i64 nparams;
L3369:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L3371;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L3372;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3373;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3374;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3375;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3376;
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L3377;
	goto L3378;
L3371:
	qq_lex_lex();
	R1 = 1;
	R2 = (u64)&nparams;
	asu64(R1) = qq_parse_readslist(asu64(R2), asi64(R1));
	q = asu64(R1);
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 26;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	asu64(R1) = qq_parse_readcondsuffix(asu64(R1));
	p = asu64(R1);
	goto L3369;
L3372:
	asu64(R1) = p;
	R2 = 51;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	qq_lex_lex();
	goto L3369;
L3373:
	R1 = 0;
	asu64(R2) = p;
	asu64(R1) = qq_parse_readindex(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L3369;
L3374:
	asu64(R1) = p;
	asu64(R1) = qq_parse_readdotsuffix(asu64(R1));
	p = asu64(R1);
	goto L3369;
L3375:
	asu64(R1) = p;
	asu64(R1) = qq_parse_readkeyindex(asu64(R1));
	p = asu64(R1);
	goto L3369;
L3376:
	asi64(R1) = qq_parse_listtype;
	R2 = 331808391504;
	if (asi64(R1) == asi64(R2)) goto L3380;
	R2 = 1413695812;
	if (asi64(R1) == asi64(R2)) goto L3381;
	goto L3382;
L3380:
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = p;
	R3 = 3;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L3379;
L3381:
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = p;
	R3 = 4;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L3379;
L3382:
	goto L3370;
L3379:
	goto L3369;
L3377:
	asu64(R1) = p;
	R2 = 61;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	qq_lex_lex();
	goto L3369;
L3378:
	goto L3370;
	goto L3369;
L3370:
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L3368;
L3368:
	return asu64(R1);
}

static u64 qq_parse_readterm() {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	u64 r;
	u64 pbyte;
	u64 a;
	i64 oldipl;
	i64 opc;
	i64 oldinrp;
	i64 pos;
	i64 shift;
	i64 t;
	i64 nparams;
	i64 length;
	u8 flag;
	u64 s;
	struct $B71 ustr;
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 2: case 114: goto L3454;
	case 3: case 4: case 5: case 6: case 7: case 8: case 10: case 12: case 14: case 16: case 17: case 20: case 21: case 42: case 58: case 59: case 61: case 62: case 68: case 71: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 82: case 83: case 86: case 90: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: case 112: case 113: case 115: case 116: case 118: case 120: case 124: case 128: goto L3386;
	case 9: goto L3395;
	case 11: goto L3431;
	case 13: goto L3480;
	case 15: case 19: goto L3439;
	case 18: case 96: goto L3471;
	case 22: goto L3401;
	case 23: goto L3404;
	case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 37: case 38: case 39: case 40: case 41: case 43: case 44: case 45: case 46: case 47: case 48: case 57: case 132: goto L3428;
	case 36: goto L3432;
	case 49: case 51: goto L3417;
	case 50: case 52: case 53: case 54: goto L3412;
	case 55: goto L3427;
	case 56: goto L3435;
	case 60: goto L3424;
	case 63: goto L3388;
	case 64: goto L3391;
	case 65: goto L3389;
	case 66: goto L3392;
	case 67: goto L3390;
	case 69: goto L3387;
	case 70: goto L3396;
	case 72: goto L3460;
	case 80: goto L3461;
	case 81: case 95: goto L3462;
	case 84: goto L3463;
	case 85: goto L3464;
	case 87: goto L3465;
	case 88: goto L3466;
	case 89: goto L3467;
	case 91: goto L3469;
	case 92: goto L3470;
	case 93: goto L3468;
	case 94: goto L3459;
	case 97: goto L3438;
	case 98: goto L3472;
	case 117: goto L3473;
	case 119: goto L3474;
	case 121: goto L3444;
	case 122: goto L3445;
	case 123: goto L3479;
	case 125: goto L3455;
	case 126: goto L3456;
	case 127: goto L3475;
	case 129: goto L3476;
	case 130: goto L3477;
	case 131: goto L3478;
	default: goto L3386;
    };
// SWITCH
L3387:
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_lib_createname(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	qq_lex_lex();
	goto L3384;
L3388:
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_lib_createintunit(asi64(R1));
	p = asu64(R1);
	qq_lex_lex();
	goto L3384;
L3389:
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_lib_createrealunit(asr64(R1));
	p = asu64(R1);
	qq_lex_lex();
	goto L3384;
L3390:
	R1 = -1;
	R2 = (u64)&qq_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_lib_createstringunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	qq_lex_lex();
	goto L3384;
L3391:
	R1 = -1;
	R2 = (u64)&qq_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_lib_createstringunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	R1 = 44;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	qq_lex_lex();
	goto L3384;
L3392:
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
	R1 = 0;
	R2 = (u64)&ustr;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = length;
	R2 = 8;
	if (asi64(R1) <= asi64(R2)) goto L3394;
	R1 = tou64("char const too long");
	qq_lib_serror(asu64(R1));
L3394:
	asi64(R1) = length;
	R2 = (u64)&qq_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&ustr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&ustr;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_lib_createintunit(asi64(R1));
	p = asu64(R1);
	qq_lex_lex();
	goto L3384;
L3395:
	asu64(R1) = qq_parse_readlbrack();
	p = asu64(R1);
	goto L3384;
L3396:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3398;
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3400;
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 108;
	if (asi64(R1) != asi64(R2)) goto L3400;
	qq_lex_lex();
	qq_lex_lex();
	R1 = 34;
	asu64(R1) = qq_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L3399;
L3400:
	R1 = 53;
	asu64(R1) = qq_lib_createunit0(asi64(R1));
	p = asu64(R1);
L3399:
	goto L3397;
L3398:
	asu64(R1) = qq_parse_readcast();
	p = asu64(R1);
L3397:
	goto L3384;
L3401:
	asu64(R1) = qq_parse_checkoperator();
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L3403;
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	p = asu64(R1);
L3403:
	goto L3384;
L3404:
	asu64(R1) = qq_parse_checkoperator();
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L3406;
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3408;
	R1 = 75;
	opc = asi64(R1);
	goto L3409;
L3408:
	asu64(R1) = qq_parse_readterm2();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L3411;
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = -asi64(R1);
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L3410;
L3411:
	asu64(R1) = p;
	R2 = 62;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 75;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3410:
L3406:
	goto L3384;
L3412:
	asu64(R1) = qq_parse_checkoperator();
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L3414;
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3416;
// qq_parse.readterm.dounaryto:
L3409:
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	R2 = 78;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3415;
L3416:
	asu64(R1) = qq_parse_readterm2();
	R2 = 62;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3415:
L3414:
	goto L3384;
L3417:
	asu64(R1) = qq_parse_checkoperator();
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L3419;
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3421;
	asi64(R1) = opc;
	R2 = 74;
	if (asi64(R1) != asi64(R2)) goto L3423;
	R1 = 82;
	goto L3422;
L3423:
	R1 = 83;
L3422:
	opc = asi64(R1);
	qq_lex_lex();
L3421:
	asu64(R1) = qq_parse_readterm2();
	asi64(R2) = opc;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
L3419:
	goto L3384;
L3424:
	asu64(R1) = qq_parse_checkoperator();
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L3426;
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	R2 = 60;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3426:
	goto L3384;
L3427:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	R2 = 64;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3384;
L3428:
	asu64(R1) = qq_parse_checkoperator();
	R2 = R1;
	p = asu64(R2);
	if (asu64(R1)) goto L3430;
	R1 = tou64("Operator?");
	qq_lib_serror(asu64(R1));
L3430:
	goto L3384;
L3431:
	asu64(R1) = qq_parse_readset();
	p = asu64(R1);
	goto L3384;
L3432:
	asu64(R1) = qq_parse_checkoperator();
	R2 = R1;
	p = asu64(R2);
	if (!asu64(R1)) goto L3434;
	goto L3433;
L3434:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	asu64(R1) = qq_parse_readpair(asi64(R2), asi64(R1));
	p = asu64(R1);
L3433:
	goto L3384;
L3435:
	asu64(R1) = qq_parse_checkoperator();
	R2 = R1;
	p = asu64(R2);
	if (!asu64(R1)) goto L3437;
	goto L3436;
L3437:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 65;
	asu64(R1) = qq_parse_readpair(asi64(R2), asi64(R1));
	p = asu64(R1);
L3436:
	goto L3384;
L3438:
	asu64(R1) = qq_parse_readsprint();
	p = asu64(R1);
	goto L3384;
L3439:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	flag = asu8(R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	R2 = 52;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu8(R1) = flag;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 26;
	if (asi64(R1) != asi64(R2)) goto L3441;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L3443;
	R1 = tou64("Params not allowed");
	qq_lib_serror(asu64(R1));
L3443:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3441:
	goto L3384;
L3444:
	asu64(R1) = qq_parse_readcompilervar();
	p = asu64(R1);
	qq_lex_lex();
	goto L3384;
L3445:
	asi64(R1) = qq_parse_intabledata;
	if (!asi64(R1)) goto L3447;
	asu64(R1) = qq_parse_tabledataname;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3449;
	R1 = tou64("$:No enum");
	qq_lib_serror(asu64(R1));
L3449:
	asu64(R1) = qq_parse_tabledataname;
	s = asu64(R1);
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L3451;
	qq_lex_lex();
	qq_lex_lex();
	R1 = 63;
	qq_lib_checksymbol(asi64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
L3451:
	R1 = -1;
	asu64(R2) = s;
	asu64(R1) = qq_lib_createstringunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L3446;
L3447:
	asi64(R1) = qq_parse_ndollar;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L3453;
	R1 = tou64("[$] No array");
	qq_lib_serror(asu64(R1));
L3453:
	R1 = (u64)&qq_parse_dollarstack;
	asi64(R2) = qq_parse_ndollar;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 66;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 89;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3446:
	qq_lex_lex();
	goto L3384;
L3454:
	R1 = 69;
	qq_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_lib_createname(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	qq_lex_lex();
	goto L3384;
L3455:
	R1 = 0;
	R2 = 37;
	asu64(R1) = qq_parse_readpair(asi64(R2), asi64(R1));
	p = asu64(R1);
	goto L3384;
L3456:
	R1 = 9;
	qq_parse_lexchecksymbol(asi64(R1));
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	p = asu64(R1);
	R1 = 3;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = qq_parse_readexpression();
	q = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3458;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 87;
	if (asi64(R1) != asi64(R2)) goto L3458;
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L3457;
L3458:
	R1 = 3;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = qq_parse_readexpression();
	r = asu64(R1);
	R1 = 10;
	qq_lib_checksymbol(asi64(R1));
L3457:
	qq_lex_lex();
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 63;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	q = asu64(R1);
	R1 = 117;
	asu64(R2) = q;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = r;
	asu64(R2) = q;
	R3 = 63;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 116;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3384;
L3459:
	asu64(R1) = qq_parse_readgoto();
	p = asu64(R1);
	goto L3384;
L3460:
	asu64(R1) = qq_parse_readif();
	p = asu64(R1);
	goto L3384;
L3461:
	asu64(R1) = qq_parse_readunless();
	p = asu64(R1);
	goto L3384;
L3462:
	asu64(R1) = qq_parse_readswitchcase();
	p = asu64(R1);
	goto L3384;
L3463:
	asu64(R1) = qq_parse_readfor();
	p = asu64(R1);
	goto L3384;
L3464:
	asu64(R1) = qq_parse_readto();
	p = asu64(R1);
	goto L3384;
L3465:
	asu64(R1) = qq_parse_readdo();
	p = asu64(R1);
	goto L3384;
L3466:
	asu64(R1) = qq_parse_readwhile();
	p = asu64(R1);
	goto L3384;
L3467:
	asu64(R1) = qq_parse_readrepeat();
	p = asu64(R1);
	goto L3384;
L3468:
	asu64(R1) = qq_parse_readloopcontrol();
	p = asu64(R1);
	goto L3384;
L3469:
	asu64(R1) = qq_parse_readreturn();
	p = asu64(R1);
	goto L3384;
L3470:
	asu64(R1) = qq_parse_readstop();
	p = asu64(R1);
	goto L3384;
L3471:
	asu64(R1) = qq_parse_readprint();
	p = asu64(R1);
	goto L3384;
L3472:
	asu64(R1) = qq_parse_readread();
	p = asu64(R1);
	goto L3384;
L3473:
	asu64(R1) = qq_parse_readtry();
	p = asu64(R1);
	goto L3384;
L3474:
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	R2 = 25;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L3384;
L3475:
	R1 = 0;
	R2 = 29;
	asu64(R1) = qq_parse_readpair(asi64(R2), asi64(R1));
	p = asu64(R1);
	goto L3384;
L3476:
	R1 = 1;
	R2 = 0;
	asu64(R1) = qq_parse_readhostparams(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L3384;
L3477:
	R1 = 28;
	asu64(R1) = qq_lib_createunit0(asi64(R1));
	p = asu64(R1);
	qq_lex_lex();
	goto L3384;
L3478:
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	R2 = 45;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L3384;
L3479:
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	R2 = 33;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L3384;
L3480:
	asu64(R1) = qq_parse_readlambda();
	p = asu64(R1);
	goto L3384;
L3386:
// qq_parse.readterm.error:
	msysc_m$print_startcon();
	R1 = tou64("d");
	R2 = (u64)&qq_tables_symbolnames;
	R3 = (u64)&qq_decls_lx;
	R4 = 12;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	msysc_m$print_u64(asu64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("readterm?");
	qq_lib_serror(asu64(R1));
L3384:
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L3383;
L3383:
	return asu64(R1);
}

static u64 qq_parse_readsunit(i64 inwhile) {
    u64 R1, R2, R3, R4; 
	i64 lineno;
	i64 m;
	i64 globalflag;
	i64 staticflag;
	u64 ulist;
	u64 ulistx;
	u64 p;
	u64 q;
	u64 r;
	u64 stname;
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	lineno = asi64(R1);
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = 0;
	globalflag = asi64(R1);
	R1 = 0;
	staticflag = asi64(R1);
L3483:
	goto L3487;
L3486:
	qq_lex_lex();
L3487:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3486;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 4: goto L3523;
	case 5: case 6: case 8: case 9: case 12: case 13: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 59: case 60: case 61: case 63: case 64: case 65: case 66: case 67: case 68: case 70: case 71: case 72: case 78: case 80: case 81: case 82: case 84: case 85: case 86: case 88: case 89: case 91: case 92: case 93: case 94: case 95: case 96: case 97: case 98: case 101: case 104: case 109: case 112: case 116: case 117: case 119: case 120: case 121: case 122: case 123: goto L3491;
	case 7: case 10: case 14: case 73: case 74: case 75: case 76: case 77: case 79: case 83: case 90: case 118: goto L3510;
	case 11: goto L3524;
	case 62: goto L3509;
	case 69: goto L3511;
	case 87: goto L3516;
	case 99: case 100: goto L3496;
	case 102: case 103: goto L3505;
	case 105: case 106: goto L3519;
	case 107: goto L3507;
	case 108: goto L3504;
	case 110: goto L3497;
	case 111: goto L3508;
	case 113: goto L3501;
	case 114: goto L3493;
	case 115: goto L3492;
	case 124: goto L3506;
	default: goto L3491;
    };
// SWITCH
L3492:
	qq_lex_lex();
	R1 = 1;
	staticflag = asi64(R1);
	goto L3483;
	goto L3489;
L3493:
	asi64(R1) = globalflag;
	if (!asi64(R1)) goto L3495;
	R1 = tou64("global global?");
	qq_lib_serror(asu64(R1));
L3495:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	globalflag = asi64(R1);
	qq_lex_lex();
	goto L3483;
	goto L3489;
L3496:
	asi64(R1) = globalflag;
	qq_parse_readprocdef(asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L3489;
L3497:
	asi64(R1) = staticflag;
	asi64(R2) = globalflag;
	asu64(R1) = qq_parse_readvardef(asi64(R2), asi64(R1));
	q = asu64(R1);
	goto L3499;
L3498:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = r;
	q = asu64(R1);
L3499:
	asu64(R1) = q;
	if (asu64(R1)) goto L3498;
	R1 = 0;
	R2 = R1;
	staticflag = asi64(R2);
	globalflag = asi64(R1);
	goto L3489;
L3501:
	asi64(R1) = staticflag;
	if (!asi64(R1)) goto L3503;
	R1 = tou64("static?");
	qq_lib_serror(asu64(R1));
L3503:
	asi64(R1) = globalflag;
	qq_parse_readconstdef(asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L3489;
L3504:
	asi64(R1) = globalflag;
	qq_parse_readtypedef(asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L3489;
L3505:
	R1 = 0;
	asi64(R2) = globalflag;
	qq_parse_readrecorddef(asi64(R2), asu64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L3489;
L3506:
	asi64(R1) = globalflag;
	qq_parse_readtabledef(asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L3489;
L3507:
	qq_parse_readimportdll();
	goto L3489;
L3508:
	asi64(R1) = globalflag;
	qq_parse_readmacrodef(asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L3489;
L3509:
	goto L3485;
	goto L3489;
L3510:
	goto L3485;
	goto L3489;
L3511:
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3513;
	goto L3514;
L3513:
	R1 = 0;
	R2 = 17;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = qq_lib_createname(asu64(R1));
	R2 = 1;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	qq_lex_lex();
	R1 = 4;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	goto L3512;
L3514:
	goto L3515;
L3512:
	goto L3489;
L3516:
	asi64(R1) = inwhile;
	if (!asi64(R1)) goto L3518;
	goto L3485;
L3518:
	goto L3515;
	goto L3489;
L3519:
L3520:
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3520;
	goto L3489;
L3523:
	goto L3489;
L3524:
	goto L3515;
	goto L3489;
L3491:
// qq_parse.readsunit.doexec:
L3515:
	asu64(R1) = qq_parse_readexpression();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L3526;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L3526;
	R1 = tou64("Possibly var/let needed");
	qq_lib_serror(asu64(R1));
L3526:
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 87;
	if (asi64(R1) != asi64(R2)) goto L3528;
	goto L3485;
L3528:
L3489:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3483;
L3485:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3530;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L3530;
	R2 = 74;
	if (asi64(R1) == asi64(R2)) goto L3530;
	R2 = 75;
	if (asi64(R1) == asi64(R2)) goto L3530;
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L3530;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L3530;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L3530;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L3530;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L3530;
	R2 = 77;
	if (asi64(R1) == asi64(R2)) goto L3530;
	R2 = 118;
	if (asi64(R1) == asi64(R2)) goto L3530;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L3530;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L3530;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3530;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L3530;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L3530;
	goto L3531;
L3530:
	goto L3529;
L3531:
	R1 = tou64("Readsunit: \";\" expected, or bad unit starter");
	qq_lib_serror(asu64(R1));
L3529:
	asu64(R1) = ulist;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3534;
	asu64(R1) = ulist;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L3533;
L3534:
	asu64(R1) = ulist;
	R2 = 6;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	goto L3532;
L3533:
	asu64(R1) = ulist;
L3532:
	goto L3482;
L3482:
	return asu64(R1);
}

static void qq_parse_checkequals() {
    u64 R1, R2; 
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L3537;
	R1 = tou64("\"=\" expected");
	qq_lib_serror(asu64(R1));
L3537:
	return;
}

static u64 qq_parse_readindex(u64 p, i64 dot) {
    u64 R1, R2, R3; 
	u64 q;
	u64 plower;
	u64 pupper;
	qq_lex_lex();
L3539:
	asi64(R1) = qq_parse_ndollar;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L3542;
	R1 = tou64("Too many nested a[$]");
	qq_lib_serror(asu64(R1));
L3542:
	asu64(R1) = p;
	R2 = (u64)&qq_parse_dollarstack;
	R3 = (u64)&qq_parse_ndollar;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = qq_parse_readexpression();
	q = asu64(R1);
	R1 = (u64)&qq_parse_ndollar;
	(*toi64p(R1)) -=1;
	asu64(R1) = q;
	asu64(R2) = p;
	asi64(R3) = dot;
	if (!asi64(R3)) goto L3544;
	R3 = 48;
	goto L3543;
L3544:
	R3 = 47;
L3543:
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3546;
	goto L3540;
L3546:
	qq_lex_lex();
	goto L3539;
L3540:
	R1 = 12;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = p;
	goto L3538;
L3538:
	return asu64(R1);
}

static u64 qq_parse_readdotsuffix(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	i64 t;
	u8 flag;
	goto L3549;
L3548:
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3552;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L3553;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L3554;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L3555;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L3556;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L3557;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L3558;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L3559;
	goto L3560;
L3552:
	R1 = 1;
	asu64(R2) = p;
	asu64(R1) = qq_parse_readindex(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L3551;
L3553:
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_lib_createname(asu64(R1));
	asu64(R2) = p;
	R3 = 46;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	qq_lex_lex();
	goto L3551;
L3554:
// qq_parse.readdotsuffix.doprop:
L3561:
	asu64(R1) = p;
	R2 = 66;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	qq_lex_lex();
	goto L3551;
L3555:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L3563;
	R1 = 1;
	flag = asu8(R1);
// qq_parse.readdotsuffix.dogettype:
L3564:
	asu64(R1) = p;
	R2 = 68;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu8(R1) = flag;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3563:
	qq_lex_lex();
	goto L3551;
L3556:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 116;
	if (asi64(R1) != asi64(R2)) goto L3566;
	R1 = 95;
	goto L3565;
L3566:
	R1 = 96;
L3565:
	R2 = (u64)&qq_decls_lx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3561;
	goto L3551;
L3557:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 98;
	if (asi64(R1) == asi64(R2)) goto L3568;
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L3569;
	goto L3570;
L3568:
	R1 = 0;
	flag = asu8(R1);
	goto L3564;
	goto L3567;
L3569:
	R1 = 2;
	flag = asu8(R1);
	goto L3564;
	goto L3567;
L3570:
	asu64(R1) = p;
	R2 = 70;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 118;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	qq_lex_lex();
L3567:
	goto L3551;
L3558:
	asu64(R1) = p;
	R2 = 69;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	qq_lex_lex();
	goto L3551;
L3559:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L3572;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L3572;
	R1 = tou64("...name.$ needed");
	qq_lib_serror(asu64(R1));
L3572:
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	qq_lex_lex();
	goto L3551;
L3560:
	R1 = tou64("Unknown dot suffix");
	qq_lib_serror(asu64(R1));
L3551:
L3549:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3548;
	asu64(R1) = p;
	goto L3547;
L3547:
	return asu64(R1);
}

static u64 qq_parse_readslist(u64 nparams, i64 ftrailing) {
    u64 R1, R2, R3; 
	u64 ulist;
	u64 ulistx;
	i64 oldinparamlist;
	i64 donulls;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = 0;
	asu64(R2) = nparams;
	*toi64p(R2) = asi64(R1);
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3575;
	asu64(R1) = ulist;
	goto L3573;
L3575:
	R1 = 331808391504;
	qq_parse_pushlisttype(asi64(R1));
	R1 = 1;
	donulls = asi64(R1);
L3576:
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3579;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3580;
	goto L3581;
L3579:
	R1 = tou64("null comma expr not allowed");
	qq_lib_serror(asu64(R1));
	goto L3578;
L3580:
	goto L3577;
	goto L3578;
L3581:
	asu64(R1) = qq_parse_readexpression();
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = nparams;
	(*toi64p(R1)) += 1;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3583;
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3585;
	asu64(R1) = nparams;
	asi64(R1) = *toi64p(R1);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3588;
	asi64(R1) = ftrailing;
	if (asi64(R1)) goto L3587;
L3588:
	R1 = tou64("Trailing comma");
	qq_lib_serror(asu64(R1));
L3587:
	goto L3577;
L3585:
	goto L3582;
L3583:
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3590;
	goto L3577;
L3590:
	R1 = tou64("SLIST?");
	qq_lib_serror(asu64(R1));
L3582:
L3578:
	goto L3576;
L3577:
	qq_parse_poplisttype();
	asu64(R1) = ulist;
	goto L3573;
L3573:
	return asu64(R1);
}

static u64 qq_parse_readcondsuffix(u64 p) {
    u64 R1, R2, R3; 
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L3593;
	R2 = 80;
	if (asi64(R1) == asi64(R2)) goto L3594;
	goto L3595;
L3593:
	qq_lex_lex();
	asu64(R1) = p;
	R2 = 6;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R2) = qq_parse_readexpression();
	R3 = 7;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L3592;
L3594:
	qq_lex_lex();
	asu64(R1) = p;
	R2 = 6;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R2) = qq_parse_readexpression();
	R3 = 74;
	asu64(R2) = qq_lib_createunit1(asi64(R3), asu64(R2));
	R3 = 7;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L3592;
L3595:
	asu64(R1) = p;
L3592:
	goto L3591;
L3591:
	return asu64(R1);
}

static u64 qq_parse_readkeyindex(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	q = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3598;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3598:
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 49;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 14;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = p;
	goto L3596;
L3596:
	return asu64(R1);
}

static u64 qq_parse_readlbrack() {
    u64 R1, R2, R3; 
	u64 ulist;
	u64 ulistx;
	u64 p;
	u64 q;
	u64 r;
	i64 oldirp;
	i64 length;
	i64 lower;
	i64 lowerseen;
	i64 elemtype;
	i64 opc;
	qq_lex_lex();
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = 0;
	length = asi64(R1);
	R1 = 1;
	lower = asi64(R1);
	R1 = 0;
	lowerseen = asi64(R1);
	R1 = 0;
	elemtype = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 70;
	if (asi64(R1) != asi64(R2)) goto L3601;
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3601;
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	elemtype = asi64(R1);
	qq_lex_lex();
	qq_lex_lex();
L3601:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L3603;
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3603;
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	lower = asi64(R1);
	R1 = 1;
	lowerseen = asi64(R1);
	qq_lex_lex();
	qq_lex_lex();
L3603:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3605;
	goto L3606;
L3605:
	qq_lex_lex();
	R1 = 88;
	asu64(R1) = qq_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = lower;
	asu64(R2) = p;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = elemtype;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L3599;
	goto L3604;
L3606:
	R1 = (u64)&qq_tables_binopset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3609;
	R1 = (u64)&qq_tables_unaryopset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3609;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L3608;
L3609:
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3608;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L3611;
	R1 = 119;
	opc = asi64(R1);
	goto L3610;
L3611:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
L3610:
// qq_parse.readlbrack.doopc:
L3612:
	R1 = 5;
	asu64(R1) = qq_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	qq_lex_lex();
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = p;
	goto L3599;
	goto L3607;
L3608:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 132;
	if (asi64(R1) == asi64(R2)) goto L3614;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L3615;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L3616;
	goto L3617;
L3614:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L3619;
	R2 = 23899;
	if (asi64(R1) == asi64(R2)) goto L3620;
	goto L3621;
L3619:
	R1 = 75;
	opc = asi64(R1);
	goto L3618;
L3620:
	R1 = 130;
	opc = asi64(R1);
	goto L3618;
L3621:
	R1 = 0;
	opc = asi64(R1);
L3618:
	goto L3612;
	goto L3613;
L3615:
	R1 = 113;
	opc = asi64(R1);
	goto L3612;
	goto L3613;
L3616:
	R1 = 114;
	opc = asi64(R1);
	goto L3612;
	goto L3613;
L3617:
	asu64(R1) = qq_parse_readexpression();
	p = asu64(R1);
L3613:
L3607:
L3604:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3623;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3624;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L3625;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3626;
	goto L3627;
L3623:
	qq_lex_lex();
	asi64(R1) = lowerseen;
	if (!asi64(R1)) goto L3629;
	asu64(R1) = p;
	asi64(R2) = lower;
	asu64(R2) = qq_lib_createintunit(asi64(R2));
	R3 = 4;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L3629:
	asu64(R1) = p;
	goto L3599;
	goto L3622;
L3624:
	R1 = 1;
	length = asi64(R1);
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3631;
	qq_lex_lex();
	qq_lex_lex();
	asu64(R1) = p;
	R2 = 88;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = lower;
	asu64(R2) = p;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = elemtype;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L3599;
L3631:
	asu64(R1) = p;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L3632:
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3636;
	goto L3634;
L3636:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3638;
	R1 = tou64(", , null expr not allowed");
	qq_lib_serror(asu64(R1));
L3638:
	asu64(R1) = qq_parse_readexpression();
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3632;
L3634:
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = ulist;
	R2 = 88;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = lower;
	asu64(R2) = p;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = elemtype;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L3599;
	goto L3622;
L3625:
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	q = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L3640;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3641;
	goto L3642;
L3640:
	qq_lex_lex();
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	r = asu64(R1);
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = r;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 7;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L3599;
	goto L3639;
L3641:
	qq_lex_lex();
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 7;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L3599;
	goto L3639;
L3642:
L3639:
	asu64(R1) = q;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = 3;
	qq_lib_checksymbol(asi64(R1));
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L3644;
L3645:
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3645;
	R1 = 16;
	qq_lib_checksymbol(asi64(R1));
	goto L3643;
L3644:
	qq_lex_lex();
L3643:
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	r = asu64(R1);
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = r;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = ulist;
	asu64(R2) = p;
	R3 = 8;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L3599;
	goto L3622;
L3626:
	asu64(R1) = p;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L3648:
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3652;
	goto L3650;
L3652:
	asu64(R1) = qq_parse_readexpression();
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3648;
L3650:
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = ulist;
	asu64(R1) = qq_parse_makeblock(asu64(R1));
	goto L3599;
	goto L3622;
L3627:
	R1 = tou64("(x ...");
	qq_lib_serror(asu64(R1));
L3622:
	R1 = 0;
	goto L3599;
L3599:
	return asu64(R1);
}

static u64 qq_parse_readif() {
    u64 R1, R2, R3; 
	i64 line;
	i64 kwd;
	i64 lineno;
	u64 pthen;
	u64 pcond;
	u64 plist;
	u64 plistx;
	u64 pelse;
	u64 p;
	u64 pelsif;
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	line = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	qq_lex_lex();
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pcond = asu64(R1);
	qq_lib_skipsemi();
	R1 = 73;
	qq_lib_skipsymbol(asi64(R1));
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pthen = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 74;
	if (asi64(R1) == asi64(R2)) goto L3655;
	R2 = 75;
	if (asi64(R1) == asi64(R2)) goto L3656;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L3657;
	R2 = 77;
	if (asi64(R1) == asi64(R2)) goto L3657;
	goto L3658;
L3655:
	R1 = 72;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = qq_parse_readif();
	pelse = asu64(R1);
	goto L3654;
L3656:
	qq_lex_lex();
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pelse = asu64(R1);
	R1 = 0;
	R2 = 0;
	asi64(R3) = kwd;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	goto L3654;
L3657:
	asi64(R1) = kwd;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = qq_parse_readswitchcase();
	asu64(R1) = qq_parse_makeblock(asu64(R1));
	pelse = asu64(R1);
	goto L3654;
L3658:
	R1 = 0;
	pelse = asu64(R1);
	R1 = 0;
	R2 = 0;
	asi64(R3) = kwd;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
L3654:
	asu64(R1) = pelse;
	asu64(R2) = pthen;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pthen;
	asu64(R2) = pcond;
	R3 = 7;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = line;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L3653;
L3653:
	return asu64(R1);
}

static void qq_parse_checkend(i64 endkwd1, i64 endkwd2, i64 startline) {
    u64 R1, R2; 
	struct $B16 str;
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L3661;
	R1 = tou64("'End' expected");
	qq_lib_serror(asu64(R1));
L3661:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3663;
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = endkwd1;
	if (asi64(R1) == asi64(R2)) goto L3666;
	asi64(R2) = endkwd2;
	if (asi64(R1) != asi64(R2)) goto L3665;
L3666:
	qq_lex_lex();
	goto L3659;
	goto L3664;
L3665:
// qq_parse.checkend.error:
L3667:
	R1 = tou64("Mismatched end ");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = startline;
	if (!asi64(R1)) goto L3669;
	R1 = (u64)&str;
	R2 = (u64)&str;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64(" (from line #)");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = startline;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L3669:
	R1 = (u64)&str;
	qq_lib_serror(asu64(R1));
L3664:
L3663:
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = endkwd1;
	if (asi64(R1) == asi64(R2)) goto L3672;
	asi64(R2) = endkwd2;
	if (asi64(R1) != asi64(R2)) goto L3671;
L3672:
	qq_lex_lex();
	goto L3670;
L3671:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3673;
	goto L3667;
L3673:
L3670:
L3659:
	return;
}

static u64 qq_parse_readunless() {
    u64 R1, R2, R3; 
	i64 line;
	u64 pcond;
	u64 pthen;
	u64 pelse;
	u64 p;
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	line = asi64(R1);
	qq_lex_lex();
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pcond = asu64(R1);
	R1 = 73;
	qq_lib_skipsymbol(asi64(R1));
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pthen = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 75;
	if (asi64(R1) != asi64(R2)) goto L3676;
	qq_lex_lex();
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pelse = asu64(R1);
	goto L3675;
L3676:
	R1 = 0;
	pelse = asu64(R1);
L3675:
	R1 = 0;
	R2 = 0;
	R3 = 80;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pelse;
	asu64(R2) = pthen;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pthen;
	asu64(R2) = pcond;
	R3 = 74;
	asu64(R2) = qq_lib_createunit1(asi64(R3), asu64(R2));
	R3 = 7;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = line;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L3674;
L3674:
	return asu64(R1);
}

static u64 qq_parse_readwhile() {
    u64 R1, R2, R3; 
	i64 pos;
	u64 pcond;
	u64 pbody;
	u64 p;
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	qq_lex_lex();
	R1 = 1;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pcond = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3679;
	qq_lex_lex();
	R1 = 1;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	asu64(R2) = pcond;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3679:
	R1 = 87;
	qq_lib_skipsymbol(asi64(R1));
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pbody = asu64(R1);
	R1 = 0;
	R2 = 87;
	R3 = 88;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pbody;
	asu64(R2) = pcond;
	R3 = 21;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L3677;
L3677:
	return asu64(R1);
}

static u64 qq_parse_readrepeat() {
    u64 R1, R2, R3; 
	i64 pos;
	u64 pbody;
	u64 pcond;
	u64 p;
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	qq_lex_lex();
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pbody = asu64(R1);
	R1 = 90;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = qq_parse_readexpression();
	pcond = asu64(R1);
	asu64(R1) = pcond;
	asu64(R2) = pbody;
	R3 = 22;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L3680;
L3680:
	return asu64(R1);
}

static u64 qq_parse_readfor() {
    u64 R1, R2, R3; 
	i64 line;
	i64 opc;
	i64 down;
	i64 isforeach;
	u64 pstep;
	u64 pvar;
	u64 pcond;
	u64 pfrom;
	u64 pto;
	u64 pelse;
	u64 pbody;
	u64 p;
	u64 plist;
	u64 pvar2;
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	line = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	isforeach = asi64(R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	pvar = asu64(R1);
	asu64(R1) = pvar;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L3683;
	R1 = tou64("For: name expected");
	qq_lib_serror(asu64(R1));
	goto L3682;
L3683:
	R1 = 1;
	asu64(R2) = pvar;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 122;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3682:
	R1 = 15;
	opc = asi64(R1);
	R1 = 0;
	pstep = asu64(R1);
	R1 = 0;
	pcond = asu64(R1);
	R1 = 0;
	pvar2 = asu64(R1);
	R1 = 0;
	down = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3685;
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	pvar2 = asu64(R1);
L3685:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L3687;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	plist = asu64(R1);
	asu64(R1) = plist;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L3689;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L3690;
	goto L3691;
L3689:
	asu64(R1) = plist;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pfrom = asu64(R1);
	asu64(R1) = plist;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pto = asu64(R1);
	goto L3688;
L3690:
	R1 = 1;
	asu64(R2) = plist;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 16;
	opc = asi64(R1);
	goto L3688;
L3691:
	R1 = 17;
	opc = asi64(R1);
L3688:
	goto L3686;
L3687:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3693;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	pfrom = asu64(R1);
	goto L3692;
L3693:
	R1 = 1;
	asu64(R1) = qq_lib_createintunit(asi64(R1));
	pfrom = asu64(R1);
L3692:
	R1 = 85;
	qq_lib_checksymbol(asi64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	down = asi64(R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	pto = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 86;
	if (asi64(R1) != asi64(R2)) goto L3695;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	pstep = asu64(R1);
	asu64(R1) = pstep;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L3697;
	R1 = tou64("BY needs int constant");
	qq_lib_serror(asu64(R1));
L3697:
	asu64(R1) = pstep;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L3699;
	R1 = tou64("Step must be positive");
	qq_lib_serror(asu64(R1));
	goto L3698;
L3699:
	asu64(R1) = pstep;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3700;
	R1 = tou64("Zero step");
	qq_lib_serror(asu64(R1));
L3700:
L3698:
	asu64(R1) = pstep;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	asu64(R2) = pstep;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pstep;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3702;
	R1 = 0;
	pstep = asu64(R1);
L3702:
L3695:
L3686:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L3704;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	pcond = asu64(R1);
L3704:
	R1 = 87;
	qq_lib_skipsymbol(asi64(R1));
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pbody = asu64(R1);
	asu64(R1) = pcond;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3706;
	asu64(R1) = pbody;
	asu64(R2) = pcond;
	R3 = 7;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = qq_parse_makeblock(asu64(R1));
	pbody = asu64(R1);
L3706:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 75;
	if (asi64(R1) != asi64(R2)) goto L3708;
	qq_lex_lex();
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pelse = asu64(R1);
	asu64(R1) = pelse;
	asu64(R2) = pbody;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L3707;
L3708:
	R1 = 0;
	pelse = asu64(R1);
L3707:
	R1 = 0;
	R2 = 87;
	R3 = 84;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = opc;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L3710;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L3711;
	goto L3712;
L3710:
	asu64(R1) = plist;
	asu64(R2) = pvar;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pvar2;
	asu64(R2) = plist;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pbody;
	asu64(R2) = pvar;
	asi64(R3) = opc;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L3709;
L3711:
	asu64(R1) = plist;
	asu64(R2) = pvar;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pbody;
	asu64(R2) = pvar;
	asi64(R3) = opc;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L3709;
L3712:
	asu64(R1) = pfrom;
	asu64(R2) = pvar;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pto;
	asu64(R2) = pfrom;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pstep;
	asu64(R2) = pto;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pbody;
	asu64(R2) = pvar;
	asi64(R3) = opc;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L3709:
	asi64(R1) = down;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = isforeach;
	if (!asi64(R1)) goto L3714;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L3716;
	R1 = 18;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3715;
L3716:
	R1 = tou64("Foreach?");
	qq_lib_serror(asu64(R1));
L3715:
L3714:
	asi64(R1) = line;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = pvar2;
	if (!asu64(R1)) goto L3718;
	asi64(R1) = opc;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L3718;
	R1 = tou64("for i, j not allowed");
	qq_lib_serror(asu64(R1));
L3718:
	asu64(R1) = p;
	goto L3681;
L3681:
	return asu64(R1);
}

static u64 qq_parse_readdo() {
    u64 R1, R2, R3; 
	u64 p;
	i64 line;
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	line = asi64(R1);
	qq_lex_lex();
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	p = asu64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 87;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 19;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = line;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L3719;
L3719:
	return asu64(R1);
}

static u64 qq_parse_readto() {
    u64 R1, R2, R3; 
	i64 line;
	i64 id;
	u64 p;
	u64 pcount;
	u64 pbody;
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	line = asi64(R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	pcount = asu64(R1);
	R1 = 87;
	qq_lib_skipsymbol(asi64(R1));
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pbody = asu64(R1);
	R1 = 0;
	R2 = 87;
	R3 = 85;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = qq_lib_createavname();
	asu64(R2) = pcount;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pbody;
	asu64(R2) = pcount;
	R3 = 20;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = line;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L3720;
L3720:
	return asu64(R1);
}

static u64 qq_parse_makeblock(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 6;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	goto L3721;
L3721:
	return asu64(R1);
}

static u64 qq_parse_readvardef(i64 isglobal, i64 isstatic) {
    u64 R1, R2, R3, R4; 
	i64 nvars;
	i64 varid;
	i64 opc;
	u64 d;
	u64 ulist;
	u64 ulistx;
	u64 p;
	qq_lex_lex();
	asu64(R1) = qq_decls_stcurrproc;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3725;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3724;
L3725:
	asi64(R1) = isstatic;
	if (!asi64(R1)) goto L3727;
	R1 = 13;
	goto L3726;
L3727:
	R1 = 14;
L3726:
	varid = asi64(R1);
	goto L3723;
L3724:
	R1 = 13;
	varid = asi64(R1);
L3723:
	R1 = 0;
	nvars = asi64(R1);
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	goto L3729;
L3728:
	R1 = (u64)&nvars;
	(*toi64p(R1)) += 1;
	asi64(R1) = isglobal;
	asi64(R2) = varid;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L3732;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L3733;
	goto L3734;
L3732:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	asi64(R1) = varid;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L3736;
	asu64(R1) = qq_decls_stcurrproc;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3739;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3738;
L3739:
	R1 = tou64("Need '=' for static in proc");
	qq_lib_serror(asu64(R1));
L3738:
L3736:
	asi64(R1) = opc;
	R2 = 2;
	asu64(R1) += asu64(R2);
	asu64(R2) = d;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 11;
	R4 = 12;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = d;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = varid;
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L3741;
	asu64(R1) = d;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	asu64(R2) = qq_lib_createname(asu64(R2));
	R3 = 2;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L3741:
	goto L3731;
L3733:
	asi64(R1) = varid;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3743;
	R1 = tou64("Need ':=' for non-static");
	qq_lib_serror(asu64(R1));
L3743:
	qq_lex_lex();
	R1 = 1;
	asu64(R2) = d;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 11;
	R4 = 12;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = d;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L3731;
L3734:
L3731:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3745;
	goto L3730;
L3745:
	qq_lex_lex();
L3729:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L3728;
L3730:
	asi64(R1) = nvars;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3747;
	R1 = tou64("No vars declared");
	qq_lib_serror(asu64(R1));
L3747:
	asu64(R1) = ulist;
	goto L3722;
L3722:
	return asu64(R1);
}

static void qq_parse_readconstdef(i64 isglobal) {
    u64 R1, R2, R3, R4; 
	i64 nvars;
	u64 d;
	qq_lex_lex();
	R1 = 0;
	nvars = asi64(R1);
	goto L3750;
L3749:
	R1 = (u64)&nvars;
	(*toi64p(R1)) += 1;
	asi64(R1) = isglobal;
	R2 = 18;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 43;
	qq_parse_lexchecksymbol(asi64(R1));
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = d;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3753;
	goto L3751;
L3753:
	qq_lex_lex();
L3750:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L3749;
L3751:
	asi64(R1) = nvars;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3755;
	R1 = tou64("No consts declared");
	qq_lib_serror(asu64(R1));
L3755:
	return;
}

static u64 qq_parse_readreturn() {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	u64 r;
	qq_lex_lex();
	R1 = 0;
	q = asu64(R1);
	R1 = (u64)&qq_tables_exprstarterset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3758;
	asu64(R1) = qq_parse_readexpression();
	q = asu64(R1);
L3758:
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	asu64(R1) = qq_parse_readcondsuffix(asu64(R1));
	goto L3756;
L3756:
	return asu64(R1);
}

static u64 qq_parse_readprint() {
    u64 R1, R2, R3; 
	i64 opc;
	i64 flags;
	i64 fshowname;
	i64 length;
	u64 pformat;
	u64 pdev;
	u64 printlist;
	u64 printlistx;
	u64 p;
	u64 q;
	u64 expr;
	u64 s;
	R1 = 362090680912;
	qq_parse_pushlisttype(asi64(R1));
	R1 = 54;
	opc = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	flags = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L3761;
	R1 = 1;
	flags = asi64(R1);
	goto L3760;
L3761:
	asi64(R1) = flags;
	R2 = 2;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L3762;
	R1 = 55;
	opc = asi64(R1);
L3762:
L3760:
	qq_lex_lex();
	R1 = 0;
	R2 = R1;
	printlistx = asu64(R2);
	printlist = asu64(R1);
	R1 = 0;
	R2 = R1;
	pdev = asu64(R2);
	pformat = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L3764;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	pdev = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3766;
	qq_lex_lex();
	goto L3765;
L3766:
	goto L3767;
L3765:
L3764:
	asi64(R1) = opc;
	R2 = 55;
	if (asi64(R1) != asi64(R2)) goto L3769;
	asu64(R1) = qq_parse_readexpression();
	pformat = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3771;
	qq_lex_lex();
	goto L3770;
L3771:
	goto L3767;
L3770:
L3769:
	R1 = (u64)&qq_tables_exprstarterset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3773;
	goto L3767;
L3773:
L3774:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3777;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L3778;
	goto L3779;
L3777:
	R1 = 56;
	asu64(R1) = qq_lib_createunit0(asi64(R1));
	R2 = (u64)&printlistx;
	R3 = (u64)&printlist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	goto L3776;
L3778:
	R1 = 57;
	asu64(R1) = qq_lib_createunit0(asi64(R1));
	R2 = (u64)&printlistx;
	R3 = (u64)&printlist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	qq_lex_lex();
	goto L3776;
L3779:
	R1 = 0;
	fshowname = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) != asi64(R2)) goto L3781;
	R1 = 1;
	fshowname = asi64(R1);
	qq_lex_lex();
L3781:
	asu64(R1) = qq_parse_readexpression();
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3783;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = p;
	R3 = 58;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L3783:
	asi64(R1) = fshowname;
	if (!asi64(R1)) goto L3785;
	asu64(R1) = p;
	asu64(R1) = qq_lib_strexpr(asu64(R1));
	expr = asu64(R1);
	R1 = -1;
	R2 = tou64("=");
	asu64(R3) = expr;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = expr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asu64(R1) = expr;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = expr;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_iconvucn(asu64(R2), asi64(R1));
	asu64(R1) = expr;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = s;
	asu64(R1) = qq_lib_createstringunit(asu64(R2), asi64(R1));
	R2 = R1;
	q = asu64(R2);
	R2 = (u64)&printlistx;
	R3 = (u64)&printlist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L3785:
	asu64(R1) = p;
	R2 = (u64)&printlistx;
	R3 = (u64)&printlist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L3776:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3787;
	goto L3775;
L3787:
	qq_lex_lex();
	goto L3774;
L3775:
// qq_parse.readprint.finish:
L3767:
	asi64(R1) = flags;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L3789;
	asi64(R1) = opc;
	R2 = 54;
	if (asi64(R1) != asi64(R2)) goto L3793;
	asu64(R1) = printlist;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3792;
L3793:
	asi64(R1) = opc;
	R2 = 55;
	if (asi64(R1) != asi64(R2)) goto L3791;
	asu64(R1) = printlist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3791;
	asu64(R1) = pformat;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3791;
L3792:
	R1 = tou64("No print items");
	qq_lib_serror(asu64(R1));
L3791:
L3789:
	qq_parse_poplisttype();
	asi64(R1) = opc;
	R2 = 55;
	if (asi64(R1) != asi64(R2)) goto L3795;
	asu64(R1) = pformat;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3797;
	R1 = tou64("No fmt str");
	qq_lib_serror(asu64(R1));
L3797:
	asu64(R1) = pformat;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3799;
	asu64(R1) = pformat;
	asu64(R1) = qq_parse_makeblock(asu64(R1));
	pformat = asu64(R1);
L3799:
	asu64(R1) = printlist;
	asu64(R2) = pformat;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pformat;
	asu64(R2) = pdev;
	asi64(R3) = opc;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L3794;
L3795:
	asu64(R1) = printlist;
	asu64(R2) = pdev;
	asi64(R3) = opc;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L3794:
	asi64(R1) = flags;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L3759;
L3759:
	return asu64(R1);
}

static u64 qq_parse_readread() {
    u64 R1, R2, R3; 
	i64 opc;
	i64 flags;
	u64 pformat;
	u64 pdev;
	u64 readlist;
	u64 readlistx;
	u64 p;
	R1 = 362090680912;
	qq_parse_pushlisttype(asi64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	flags = asi64(R1);
	qq_lex_lex();
	R1 = 0;
	R2 = R1;
	readlistx = asu64(R2);
	readlist = asu64(R1);
	R1 = 0;
	R2 = R1;
	pdev = asu64(R2);
	pformat = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L3802;
	asi64(R1) = opc;
	R2 = 59;
	if (asi64(R1) != asi64(R2)) goto L3804;
	R1 = tou64("@ on read");
	qq_lib_serror(asu64(R1));
L3804:
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	pdev = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3806;
	qq_lex_lex();
	goto L3805;
L3806:
	goto L3807;
L3805:
L3802:
	R1 = (u64)&qq_tables_exprstarterset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3809;
	goto L3807;
L3809:
L3810:
	asu64(R1) = qq_parse_readexpression();
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3813;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = p;
	R3 = 58;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L3813:
	asu64(R1) = p;
	R2 = (u64)&readlistx;
	R3 = (u64)&readlist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3815;
	goto L3811;
L3815:
	qq_lex_lex();
	goto L3810;
L3811:
// qq_parse.readread.finish:
L3807:
	asi64(R1) = opc;
	R2 = 59;
	if (asi64(R1) != asi64(R2)) goto L3817;
	asu64(R1) = readlist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3817;
	R1 = tou64("No read items");
	qq_lib_serror(asu64(R1));
L3817:
	qq_parse_poplisttype();
	asu64(R1) = readlist;
	asu64(R2) = pdev;
	R3 = 59;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = flags;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L3800;
L3800:
	return asu64(R1);
}

static u64 qq_parse_readloopcontrol() {
    u64 R1, R2, R3; 
	i64 opc;
	u64 p;
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L3820;
	R1 = tou64("all");
	R2 = (u64)&qq_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3820;
	qq_lex_lex();
	R1 = 0;
	asu64(R1) = qq_lib_createintunit(asi64(R1));
	R2 = 50;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L3819;
L3820:
	R1 = (u64)&qq_tables_exprstarterset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3821;
	asu64(R1) = qq_parse_readintunit();
	R2 = 50;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L3819;
L3821:
	R1 = 1;
	asu64(R1) = qq_lib_createintunit(asi64(R1));
	R2 = 50;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
L3819:
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	asu64(R1) = qq_parse_readcondsuffix(asu64(R1));
	goto L3818;
L3818:
	return asu64(R1);
}

static u64 qq_parse_readintunit() {
    u64 R1, R2; 
	u64 p;
	asu64(R1) = qq_parse_readexpression();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L3824;
	R1 = tou64("int expr needed");
	qq_lib_serror(asu64(R1));
L3824:
	asu64(R1) = p;
	goto L3822;
L3822:
	return asu64(R1);
}

static u64 qq_parse_readswitchcase() {
    u64 R1, R2, R3; 
	i64 pos;
	i64 kwd;
	i64 opc;
	i64 lineno;
	i64 rangeused;
	i64 nwhen;
	u64 pexpr;
	u64 pwhenlist;
	u64 pwhenlistx;
	u64 pwhen;
	u64 pwhenx;
	u64 pelse;
	u64 p;
	u64 pthen;
	u64 pwhenthen;
	u64 q;
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	qq_lex_lex();
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L3827;
	asi64(R1) = kwd;
	R2 = 95;
	if (asi64(R1) != asi64(R2)) goto L3829;
	R1 = tou64("switch expr missing");
	qq_lib_serror(asu64(R1));
L3829:
	R1 = 0;
	asu64(R1) = qq_lib_createunit0(asi64(R1));
	pexpr = asu64(R1);
	goto L3826;
L3827:
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pexpr = asu64(R1);
L3826:
	R1 = 0;
	R2 = R1;
	pwhenlistx = asu64(R2);
	pwhenlist = asu64(R1);
	R1 = 0;
	rangeused = asi64(R1);
	R1 = 0;
	nwhen = asi64(R1);
	qq_lib_skipsemi();
	goto L3831;
L3830:
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	qq_lex_lex();
	R1 = 0;
	R2 = R1;
	pwhenx = asu64(R2);
	pwhen = asu64(R1);
L3833:
	asu64(R1) = qq_parse_readexpression();
	p = asu64(R1);
	R1 = (u64)&nwhen;
	(*toi64p(R1)) += 1;
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 87;
	if (asi64(R1) != asi64(R2)) goto L3836;
	R1 = 1;
	rangeused = asi64(R1);
L3836:
	asu64(R1) = p;
	R2 = (u64)&pwhenx;
	R3 = (u64)&pwhen;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3838;
	goto L3834;
L3838:
	qq_lex_lex();
	goto L3833;
L3834:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L3840;
	R1 = 7;
	qq_lib_checksymbol(asi64(R1));
L3840:
	qq_lex_lex();
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pthen = asu64(R1);
	asu64(R1) = pthen;
	asu64(R2) = pwhen;
	R3 = 9;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	pwhenthen = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = pwhenthen;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = pwhenthen;
	R2 = (u64)&pwhenlistx;
	R3 = (u64)&pwhenlist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L3831:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L3830;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 75;
	if (asi64(R1) == asi64(R2)) goto L3842;
	R2 = 74;
	if (asi64(R1) == asi64(R2)) goto L3843;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L3844;
	R2 = 77;
	if (asi64(R1) == asi64(R2)) goto L3844;
	goto L3845;
L3842:
	qq_lex_lex();
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pelse = asu64(R1);
	R1 = 0;
	R2 = 0;
	asi64(R3) = kwd;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	goto L3841;
L3843:
	asi64(R1) = kwd;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = qq_parse_readif();
	asu64(R1) = qq_parse_makeblock(asu64(R1));
	pelse = asu64(R1);
	goto L3841;
L3844:
	asi64(R1) = kwd;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = qq_parse_readswitchcase();
	pelse = asu64(R1);
	goto L3841;
L3845:
	R1 = 0;
	pelse = asu64(R1);
	R1 = 0;
	R2 = 0;
	asi64(R3) = kwd;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
L3841:
	asu64(R1) = pelse;
	asu64(R2) = pexpr;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pwhenlist;
	asu64(R2) = pexpr;
	asi64(R3) = opc;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L3825;
L3825:
	return asu64(R1);
}

static u64 qq_parse_readgoto() {
    u64 R1, R2; 
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	R2 = 30;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R1) = qq_parse_readcondsuffix(asu64(R1));
	goto L3846;
L3846:
	return asu64(R1);
}

static u64 qq_parse_readstop() {
    u64 R1, R2, R3; 
	u64 p;
	i64 i;
	qq_lex_lex();
	R1 = (u64)&qq_tables_exprstarterset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3849;
	asu64(R1) = qq_parse_readexpression();
	R2 = 31;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L3848;
L3849:
	R1 = 0;
	asu64(R1) = qq_lib_createintunit(asi64(R1));
	R2 = 31;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
L3848:
	asu64(R1) = p;
	asu64(R1) = qq_parse_readcondsuffix(asu64(R1));
	goto L3847;
L3847:
	return asu64(R1);
}

static u64 qq_parse_readcast() {
    u64 R1, R2, R3; 
	u64 p;
	i64 t;
	i64 opc;
	i64 pclop;
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	t = asi64(R1);
	qq_lex_lex();
	asi64(R1) = t;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3852;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L3852;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3855;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3854;
L3855:
	R1 = tou64("MAKERANGELEN");
	qq_lib_serror(asu64(R1));
	goto L3853;
L3854:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 87;
	if (asi64(R1) != asi64(R2)) goto L3856;
	goto L3853;
L3856:
	R1 = tou64("need a..b or a:n");
	qq_lib_serror(asu64(R1));
L3853:
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = p;
	goto L3850;
L3852:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L3858;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L3858;
	goto L3859;
L3858:
	goto L3857;
L3859:
	R1 = 34;
	asu64(R1) = qq_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = p;
	goto L3850;
L3857:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L3861;
	qq_lex_lex();
	R1 = 36;
	opc = asi64(R1);
	R1 = 100;
	pclop = asi64(R1);
	goto L3860;
L3861:
	R1 = 35;
	opc = asi64(R1);
	R1 = 99;
	pclop = asi64(R1);
L3860:
	R1 = 9;
	qq_lib_checksymbol(asi64(R1));
	asu64(R1) = qq_parse_readterm();
	p = asu64(R1);
	asu64(R1) = p;
	asi64(R2) = opc;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pclop;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 24;
	R1 += (i64)R2;
	asi64(R2) = t;
	asu64(R3) = qq_decls_stcurrproc;
	qq_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = p;
	goto L3850;
L3850:
	return asu64(R1);
}

static u64 qq_parse_readset() {
    u64 R1, R2, R3; 
	i64 length;
	i64 nkeyvalues;
	i64 oldinparamlist;
	u64 p;
	u64 ulist;
	u64 ulistx;
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L3864;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3865;
	goto L3866;
L3864:
	qq_lex_lex();
	R1 = 0;
	R2 = 89;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	goto L3862;
	goto L3863;
L3865:
	R1 = 12;
	qq_parse_lexchecksymbol(asi64(R1));
	qq_lex_lex();
	R1 = 0;
	R2 = 90;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	goto L3862;
	goto L3863;
L3866:
L3863:
	R1 = 1413695812;
	qq_parse_pushlisttype(asi64(R1));
	asu64(R1) = qq_parse_readexpression();
	p = asu64(R1);
	R1 = 1;
	length = asi64(R1);
	R1 = 0;
	nkeyvalues = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3868;
	R1 = (u64)&nkeyvalues;
	(*toi64p(R1)) += 1;
L3868:
	asu64(R1) = p;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	goto L3870;
L3869:
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L3873;
	goto L3871;
L3873:
	asu64(R1) = qq_parse_readexpression();
	R2 = R1;
	p = asu64(R2);
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3875;
	R1 = (u64)&nkeyvalues;
	(*toi64p(R1)) += 1;
L3875:
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	qq_lib_skipsemi();
L3870:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3869;
L3871:
	R1 = 12;
	qq_lib_skipsymbol(asi64(R1));
	asi64(R1) = nkeyvalues;
	if (!asi64(R1)) goto L3877;
	asi64(R1) = length;
	asi64(R2) = nkeyvalues;
	if (asi64(R1) <= asi64(R2)) goto L3879;
	R1 = tou64("dict: mixed elements");
	qq_lib_serror(asu64(R1));
L3879:
	asu64(R1) = ulist;
	R2 = 90;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L3876;
L3877:
	asu64(R1) = ulist;
	R2 = 89;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
L3876:
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	qq_parse_poplisttype();
	asu64(R1) = p;
	goto L3862;
L3862:
	return asu64(R1);
}

static void qq_parse_readtabledef(i64 isglobal) {
    u64 R1, R2, R3, R4; 
	i64 i;
	i64 ncols;
	i64 nrows;
	i64 enums;
	i64 nextenumvalue;
	i64 startline;
	i64 firstvalue;
	i64 ltype;
	i64 lower;
	u8 commas;
	u8 semis;
	u64 ulist;
	u64 ulistx;
	u64 plower;
	u64 p;
	struct $B34 varnames;
	struct $B34 plist;
	struct $B34 plistx;
	u64 d;
	u64 nameptr;
	R1 = 0;
	commas = asu8(R1);
	R1 = 0;
	semis = asu8(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	enums = asi64(R1);
	qq_lex_lex();
	R1 = 1;
	R2 = R1;
	nextenumvalue = asi64(R2);
	firstvalue = asi64(R1);
	R1 = 0;
	nrows = asi64(R1);
	R1 = 0;
	ncols = asi64(R1);
	goto L3882;
L3881:
	R1 = (u64)&ncols;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 20;
	if (asi64(R1) <= asi64(R2)) goto L3885;
	R1 = tou64("tabledata/too many columns");
	qq_lib_serror(asu64(R1));
L3885:
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&varnames;
	asi64(R3) = ncols;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3887;
	qq_lex_lex();
	goto L3886;
L3887:
	goto L3883;
L3886:
L3882:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L3881;
L3883:
	qq_parse_checkequals();
	qq_lex_lex();
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	startline = asi64(R1);
	qq_lib_skipsemi();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3890;
L3888:
	R1 = 0;
	R2 = R1;
	R3 = (u64)&plistx;
	asi64(R4) = i;
	*tou64p(((i64)R3+(i64)R4*8-8)) = asu64(R2);
	R2 = (u64)&plist;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= ncols) goto L3888;
L3890:
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = 1;
	qq_parse_intabledata = asi64(R1);
L3891:
	qq_lib_skipsemi();
	asi64(R1) = ncols;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3894;
	R1 = 9;
	qq_lib_skipsymbol(asi64(R1));
L3894:
	R1 = (u64)&nrows;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 500;
	if (asi64(R1) <= asi64(R2)) goto L3896;
	R1 = tou64("tabledata:too many rows");
	qq_lib_serror(asu64(R1));
L3896:
	asi64(R1) = enums;
	if (!asi64(R1)) goto L3898;
	R1 = 69;
	qq_lib_checksymbol(asi64(R1));
	asi64(R1) = isglobal;
	R2 = 19;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L3900;
	goto L3901;
L3900:
	asi64(R1) = nrows;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L3903;
	R1 = tou64("tabledata '=' not 1st");
	qq_lib_serror(asu64(R1));
L3903:
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L3905;
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	nextenumvalue = asi64(R2);
	firstvalue = asi64(R1);
	goto L3904;
L3905:
	R1 = tou64("TABLEDATA: COMPLEX ENUM VAL");
	qq_lib_serror(asu64(R1));
L3904:
	goto L3899;
L3901:
L3899:
	R1 = (u64)&nextenumvalue;
	asi64(R2) = *toi64p(R1); *(toi64p(R1)) += 1; asi64(R1) = asi64(R2);
	asu64(R2) = d;
	R3 = 96;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_parse_tabledataname = asu64(R1);
	asi64(R1) = ncols;
	if (!asi64(R1)) goto L3907;
	R1 = 3;
	qq_lib_skipsymbol(asi64(R1));
L3907:
L3898:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3910;
L3908:
	asu64(R1) = qq_parse_readexpression();
	R2 = (u64)&plistx;
	asi64(R3) = i;
	R2 += (i64)R3*8-8;
	R3 = (u64)&plist;
	asi64(R4) = i;
	R3 += (i64)R4*8-8;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	asi64(R2) = ncols;
	if (asi64(R1) != asi64(R2)) goto L3912;
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	goto L3911;
L3912:
	R1 = 3;
	qq_lib_skipsymbol(asi64(R1));
L3911:
	i += 1; if (i <= ncols) goto L3908;
L3910:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3914;
	goto L3915;
L3914:
	R1 = (u64)&commas;
	(*tou8p(R1)) += 1;
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 79;
	if (asi64(R1) != asi64(R2)) goto L3917;
	goto L3892;
L3917:
	goto L3913;
L3915:
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 79;
	if (asi64(R1) != asi64(R2)) goto L3919;
	goto L3892;
L3919:
	R1 = (u64)&semis;
	(*tou8p(R1)) += 1;
L3913:
	goto L3891;
L3892:
	asu8(R1) = semis;
	if (!asu8(R1)) goto L3921;
	asu8(R1) = commas;
	if (!asu8(R1)) goto L3921;
	R1 = tou64("mixed commas");
	qq_lib_serror(asu64(R1));
L3921:
	R1 = 0;
	qq_parse_intabledata = asi64(R1);
	qq_lib_skipsemi();
	asi64(R1) = startline;
	R2 = 0;
	R3 = 124;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = nrows;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3923;
	R1 = tou64("No table data");
	qq_lib_serror(asu64(R1));
L3923:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3926;
L3924:
	asi64(R1) = isglobal;
	R2 = 13;
	R3 = (u64)&varnames;
	asi64(R4) = i;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	R1 = (u64)&plist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 88;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	R2 = R1;
	asu64(R3) = d;
	R4 = 88;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	p = asu64(R1);
	asi64(R1) = nrows;
	asu64(R2) = p;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = firstvalue;
	asu64(R2) = p;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	i += 1; if (i <= ncols) goto L3924;
L3926:
	return;
}

static u64 qq_parse_readtry() {
    u64 R1, R2, R3; 
	u64 ptry;
	u64 pexceptlist;
	u64 pexceptlistx;
	u64 px;
	u64 q;
	u64 exlist;
	u64 exlistx;
	qq_lex_lex();
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	ptry = asu64(R1);
	R1 = 0;
	R2 = R1;
	pexceptlistx = asu64(R2);
	pexceptlist = asu64(R1);
	goto L3929;
L3928:
	qq_lex_lex();
	R1 = 0;
	R2 = R1;
	exlistx = asu64(R2);
	exlist = asu64(R1);
L3931:
	asu64(R1) = qq_parse_readexpression();
	R2 = (u64)&exlistx;
	R3 = (u64)&exlist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3934;
	goto L3932;
L3934:
	qq_lex_lex();
	goto L3931;
L3932:
	R1 = 73;
	qq_lib_skipsymbol(asi64(R1));
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	px = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = exlist;
	R3 = 24;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	R2 = (u64)&pexceptlistx;
	R3 = (u64)&pexceptlist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L3929:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 118;
	if (asi64(R1) == asi64(R2)) goto L3928;
	R1 = 0;
	R2 = 0;
	R3 = 117;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pexceptlist;
	asu64(R2) = ptry;
	R3 = 23;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L3927;
L3927:
	return asu64(R1);
}

static u64 qq_parse_readsprint() {
    u64 R1, R2, R3; 
	i64 opc;
	i64 flags;
	i64 isfprint;
	u64 pformat;
	u64 pdev;
	u64 printlist;
	u64 printlistx;
	u64 p;
	R1 = 362090680912;
	qq_parse_pushlisttype(asi64(R1));
	R1 = 54;
	opc = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	flags = asi64(R1);
	R1 = 9;
	qq_parse_lexchecksymbol(asi64(R1));
	qq_lex_lex();
	asi64(R1) = flags;
	R2 = 2;
	asi64(R1) &= asi64(R2);
	isfprint = asi64(R1);
	asi64(R1) = flags;
	R2 = 2;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L3937;
	R1 = 55;
	opc = asi64(R1);
L3937:
	R1 = 0;
	R2 = R1;
	printlistx = asu64(R2);
	printlist = asu64(R1);
	R1 = 0;
	R2 = R1;
	pdev = asu64(R2);
	pformat = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L3939;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	pdev = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3941;
	qq_lex_lex();
	goto L3940;
L3941:
	goto L3942;
L3940:
L3939:
	asi64(R1) = isfprint;
	if (!asi64(R1)) goto L3944;
	asu64(R1) = qq_parse_readexpression();
	pformat = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3946;
	qq_lex_lex();
	goto L3945;
L3946:
	goto L3942;
L3945:
L3944:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3948;
	goto L3942;
L3948:
L3949:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3952;
	R1 = 56;
	asu64(R1) = qq_lib_createunit0(asi64(R1));
	R2 = (u64)&printlistx;
	R3 = (u64)&printlist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	goto L3951;
L3952:
	asu64(R1) = qq_parse_readexpression();
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3954;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = p;
	R3 = 58;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L3954:
	asu64(R1) = p;
	R2 = (u64)&printlistx;
	R3 = (u64)&printlist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L3951:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3956;
	goto L3950;
L3956:
	qq_lex_lex();
	goto L3949;
L3950:
	R1 = 10;
	qq_lib_checksymbol(asi64(R1));
// qq_parse.readsprint.finish:
L3942:
	qq_lex_lex();
	asi64(R1) = opc;
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L3959;
	asi64(R1) = opc;
	R2 = 55;
	if (asi64(R1) != asi64(R2)) goto L3958;
L3959:
	asu64(R1) = printlist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3958;
	R1 = tou64("No print items");
	qq_lib_serror(asu64(R1));
L3958:
	qq_parse_poplisttype();
	asi64(R1) = isfprint;
	if (!asi64(R1)) goto L3961;
	asu64(R1) = pformat;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3963;
	R1 = tou64("No fmt str");
	qq_lib_serror(asu64(R1));
L3963:
	asu64(R1) = printlist;
	asu64(R2) = pformat;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pformat;
	asu64(R2) = pdev;
	asi64(R3) = opc;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L3960;
L3961:
	asu64(R1) = printlist;
	asu64(R2) = pdev;
	asi64(R3) = opc;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L3960:
	asi64(R1) = flags;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L3935;
L3935:
	return asu64(R1);
}

static u64 qq_parse_readsread() {
    u64 R1, R2, R3; 
	i64 opc;
	u64 pformat;
	u64 pdev;
	u64 p;
	u64 readlist;
	u64 readlistx;
	msysc_m$print_startcon();
	R1 = tou64("SREAD");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 362090680912;
	qq_parse_pushlisttype(asi64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	R1 = 9;
	qq_parse_lexchecksymbol(asi64(R1));
	qq_lex_lex();
	R1 = 0;
	R2 = R1;
	readlistx = asu64(R2);
	readlist = asu64(R1);
	R1 = 0;
	R2 = R1;
	pdev = asu64(R2);
	pformat = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L3966;
	asi64(R1) = opc;
	R2 = 59;
	if (asi64(R1) != asi64(R2)) goto L3968;
	R1 = tou64("@ on read");
	qq_lib_serror(asu64(R1));
L3968:
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	pdev = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3970;
	qq_lex_lex();
	goto L3969;
L3970:
	goto L3971;
L3969:
L3966:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3973;
	goto L3971;
L3973:
L3974:
	asu64(R1) = qq_parse_readexpression();
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3977;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = p;
	R3 = 58;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L3977:
	asu64(R1) = p;
	R2 = (u64)&readlistx;
	R3 = (u64)&readlist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3979;
	goto L3975;
L3979:
	qq_lex_lex();
	goto L3974;
L3975:
	R1 = 10;
	qq_lib_checksymbol(asi64(R1));
// qq_parse.readsread.finish:
L3971:
	qq_lex_lex();
	asi64(R1) = opc;
	R2 = 59;
	if (asi64(R1) != asi64(R2)) goto L3981;
	asu64(R1) = readlist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3981;
	R1 = tou64("No read items");
	qq_lib_serror(asu64(R1));
L3981:
	qq_parse_poplisttype();
	asu64(R1) = readlist;
	asu64(R2) = pdev;
	asi64(R3) = opc;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L3964;
L3964:
	return asu64(R1);
}

static void qq_parse_readimportdll() {
    u64 R1, R2, R3, R4, R5; 
	struct $B16 str;
	u64 stproc;
	u64 d;
	u64 stname;
	i64 startpos;
	i64 isfunc;
	i64 isnew;
	i64 libtype;
	i64 i;
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	libtype = asi64(R1);
	R1 = 69;
	qq_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	stname = asu64(R1);
	R1 = 43;
	qq_parse_lexchecksymbol(asi64(R1));
	qq_lex_lex();
	R1 = 1;
	isnew = asi64(R1);
	asu64(R1) = stname;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nlibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3985;
L3983:
	asu64(R1) = stname;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_decls_libtable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3987;
	R1 = (u64)&qq_decls_libtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	stname = asu64(R1);
	R1 = 0;
	isnew = asi64(R1);
	goto L3985;
L3987:
	i += 1; if (i <= qq_decls_nlibfiles) goto L3983;
L3985:
	asi64(R1) = isnew;
	if (!asi64(R1)) goto L3989;
	R1 = 0;
	R2 = 4;
	asu64(R3) = stname;
	R4 = 0;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	stname = asu64(R1);
	asi64(R1) = qq_decls_nlibfiles;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L3991;
	R1 = tou64("Too many DLL libs");
	qq_lib_serror(asu64(R1));
L3991:
	asu64(R1) = stname;
	R2 = (u64)&qq_decls_libtable;
	R3 = (u64)&qq_decls_nlibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = libtype;
	R2 = (u64)&qq_decls_libtypes;
	asi64(R3) = qq_decls_nlibfiles;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = qq_decls_nlibfiles;
	asu64(R2) = stname;
	R3 = 96;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L3989:
	asu64(R1) = stname;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	qq_parse_currdllindex = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	startpos = asi64(R1);
L3992:
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 99;
	if (asi64(R1) == asi64(R2)) goto L3995;
	R2 = 100;
	if (asi64(R1) == asi64(R2)) goto L3995;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L3996;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L3997;
	goto L3998;
L3995:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 100;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	isfunc = asi64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L4000;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4001;
	goto L4002;
L4000:
	R1 = 1;
	R2 = 7;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	stproc = asu64(R1);
	goto L3999;
L4001:
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	R1 = 1;
	R2 = 7;
	R3 = (u64)&str;
	asu64(R3) = qq_names_addglobalname(asu64(R3));
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	stproc = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = stproc;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L3999;
L4002:
	R1 = tou64("fn name expected");
	qq_lib_serror(asu64(R1));
L3999:
	asi64(R1) = isfunc;
	asu64(R2) = stproc;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 4;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 1;
	asu64(R2) = stproc;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = qq_decls_ndllprocs;
	R2 = 2000;
	if (asi64(R1) < asi64(R2)) goto L4004;
	R1 = tou64("Too many DLL procs");
	qq_lib_serror(asu64(R1));
L4004:
	asu64(R1) = stproc;
	R2 = (u64)&qq_decls_dllproctable;
	R3 = (u64)&qq_decls_ndllprocs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = qq_parse_currdllindex;
	R2 = (u64)&qq_decls_dllproclibindex;
	asi64(R3) = qq_decls_ndllprocs;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = qq_decls_ndllprocs;
	asu64(R2) = stproc;
	R3 = 96;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L4006;
	R1 = tou64("as");
	R2 = (u64)&qq_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4006;
	R1 = 69;
	qq_parse_lexchecksymbol(asi64(R1));
	R1 = 1;
	R2 = 20;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = stproc;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = stproc;
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	qq_lex_lex();
L4006:
	asu64(R1) = stproc;
	qq_parse_readffiparams(asu64(R1));
	goto L3994;
L3996:
	R1 = 1;
	qq_parse_readtypedef(asi64(R1));
	goto L3994;
L3997:
	goto L3993;
	goto L3994;
L3998:
	R1 = 8;
	asu64(R2) = qq_decls_stcurrproc;
	qq_parse_readpackvars(asu64(R2), asi64(R1));
L3994:
	goto L3992;
L3993:
	asi64(R1) = startpos;
	R2 = 0;
	R3 = 107;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	return;
}

static void qq_parse_readffiparams(u64 stproc) {
    u64 R1, R2, R3, R4; 
	i64 pret;
	i64 ptype;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L4009;
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L4011;
	qq_lex_lex();
	goto L4010;
L4011:
	R1 = 0;
	R2 = 0;
	asi64(R1) = qq_parse_readtypespec(asi64(R2), asu64(R1));
	ptype = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4014;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L4013;
L4014:
	asi64(R1) = ptype;
	asu64(R2) = stproc;
	qq_parse_readtypeparams(asu64(R2), asi64(R1));
	goto L4012;
L4013:
	asi64(R1) = ptype;
	asu64(R2) = stproc;
	qq_parse_readtypenameparams(asu64(R2), asi64(R1));
L4012:
L4010:
L4009:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4017;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L4016;
L4017:
	asu64(R1) = stproc;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 4;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L4019;
	R1 = tou64("Return type for proc?");
	qq_lib_serror(asu64(R1));
L4019:
	qq_lex_lex();
L4016:
	R1 = 0;
	pret = asi64(R1);
	asu64(R1) = stproc;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 4;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L4021;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L4023;
	R1 = tou64("Return type missing");
	qq_lib_serror(asu64(R1));
L4023:
	R1 = 0;
	R2 = 0;
	asi64(R1) = qq_parse_readtypespec(asi64(R2), asu64(R1));
	pret = asi64(R1);
L4021:
	asu64(R1) = stproc;
	R2 = 116;
	R1 += (i64)R2;
	asi64(R2) = pret;
	asu64(R3) = stproc;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	return;
}

static void qq_parse_readtypeparams(u64 stproc, i64 ptype) {
    u64 R1, R2, R3, R4; 
	struct $B31 str;
	i64 nparams;
	u64 stname;
	R1 = 0;
	nparams = asi64(R1);
L4025:
	R1 = (u64)&nparams;
	(*toi64p(R1)) += 1;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = 16;
	R3 = (u64)&str;
	asu64(R3) = qq_names_addglobalname(asu64(R3));
	asu64(R4) = stproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	R2 = 116;
	R1 += (i64)R2;
	asi64(R2) = ptype;
	asu64(R3) = stproc;
	qq_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = stproc;
	R2 = 104;
	R1 += (i64)R2;
	(*toi16p(R1)) += 1;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4028;
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L4030;
	R1 = 1;
	asu64(R2) = stproc;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 8;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	qq_lex_lex();
	goto L4026;
L4030:
	R1 = 0;
	R2 = 0;
	asi64(R1) = qq_parse_readtypespec(asi64(R2), asu64(R1));
	ptype = asi64(R1);
	goto L4027;
L4028:
	goto L4026;
L4027:
	goto L4025;
L4026:
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	return;
}

static void qq_parse_readtypenameparams(u64 stproc, i64 ptype) {
    u64 R1, R2, R3, R4; 
	u64 stname;
	R1 = 69;
	qq_lib_checksymbol(asi64(R1));
	R1 = 0;
	R2 = 16;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = stproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	R2 = 116;
	R1 += (i64)R2;
	asi64(R2) = ptype;
	asu64(R3) = stproc;
	qq_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = stproc;
	R2 = 104;
	R1 += (i64)R2;
	(*toi16p(R1)) += 1;
	qq_lex_lex();
L4032:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) != asi64(R2)) goto L4035;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = stname;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = stname;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 7;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L4035:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4037;
	goto L4038;
L4037:
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L4040;
	R1 = 1;
	asu64(R2) = stproc;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 8;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	qq_lex_lex();
	goto L4033;
L4040:
	asi64(R1) = qq_parse_istypestarter();
	if (!asi64(R1)) goto L4042;
	R1 = 0;
	R2 = 0;
	asi64(R1) = qq_parse_readtypespec(asi64(R2), asu64(R1));
	ptype = asi64(R1);
L4042:
	R1 = 69;
	qq_lib_checksymbol(asi64(R1));
	R1 = 0;
	R2 = 16;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = stproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	R2 = 116;
	R1 += (i64)R2;
	asi64(R2) = ptype;
	asu64(R3) = stproc;
	qq_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = stproc;
	R2 = 104;
	R1 += (i64)R2;
	(*toi16p(R1)) += 1;
	qq_lex_lex();
	goto L4036;
L4038:
	goto L4033;
L4036:
	goto L4032;
L4033:
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	return;
}

static void qq_parse_readrecorddef(i64 isglobal, u64 d) {
    u64 R1, R2, R3, R4; 
	i64 kwd;
	i64 baseclass;
	i64 m;
	i64 startline;
	i64 caligned;
	u8 lbopening;
	u64 nameptr;
	R1 = 0;
	lbopening = asu8(R1);
	R1 = 0;
	baseclass = asi64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L4045;
	R1 = 108;
	kwd = asi64(R1);
	goto L4046;
L4045:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	R1 = 69;
	qq_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	nameptr = asu64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L4048;
	qq_lex_lex();
	R1 = 0;
	R2 = 0;
	asi64(R1) = qq_parse_readtypespec(asi64(R2), asu64(R1));
	baseclass = asi64(R1);
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
L4048:
	qq_parse_checkequals();
	qq_lex_lex();
	asi64(R1) = isglobal;
	asi64(R2) = kwd;
	R3 = 102;
	if (asi64(R2) != asi64(R3)) goto L4050;
	R2 = 9;
	goto L4049;
L4050:
	R2 = 10;
L4049:
	asu64(R3) = nameptr;
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = baseclass;
	if (!asi64(R1)) goto L4052;
	asi64(R1) = baseclass;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4054;
	R1 = tou64("baseclass?");
	qq_lib_serror(asu64(R1));
L4054:
	asi64(R1) = qq_decls_nbaseclasses;
	R2 = 255;
	if (asi64(R1) < asi64(R2)) goto L4056;
	R1 = tou64("Too many base classes");
	qq_lib_serror(asu64(R1));
L4056:
	R1 = (u64)&qq_decls_nbaseclasses;
	(*toi64p(R1)) += 1;
	R1 = (u64)&qq_decls_baseclasstable;
	asi64(R2) = qq_decls_nbaseclasses;
	R1 += (i64)R2*2;
	asi64(R2) = baseclass;
	asu64(R3) = qq_decls_stcurrproc;
	qq_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = qq_decls_nbaseclasses;
	asu64(R2) = d;
	R3 = 110;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = d;
	R2 = (u64)&qq_decls_baseclassdef;
	asi64(R3) = qq_decls_nbaseclasses;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
L4052:
// qq_parse.readrecorddef.gotname:
L4046:
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	startline = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L4058;
	R1 = 1;
	lbopening = asu8(R1);
	qq_lex_lex();
L4058:
	asi64(R1) = kwd;
	R2 = 102;
	if (asi64(R1) != asi64(R2)) goto L4060;
	asu64(R1) = d;
	asi64(R1) = qq_parse_readrecordbody(asu64(R1));
	m = asi64(R1);
	goto L4059;
L4060:
	R1 = 0;
	caligned = asi64(R1);
	asi64(R1) = caligned;
	asu64(R2) = d;
	asi64(R1) = qq_parse_readstructbody(asu64(R2), asi64(R1));
	m = asi64(R1);
L4059:
	asu8(R1) = lbopening;
	if (!asu8(R1)) goto L4062;
	R1 = 10;
	qq_lib_checksymbol(asi64(R1));
	qq_lex_lex();
	goto L4061;
L4062:
	asi64(R1) = startline;
	R2 = 0;
	R3 = 102;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
L4061:
	return;
}

static i64 qq_parse_readrecordbody(u64 owner) {
    u64 R1, R2, R3; 
	u64 oldstcurrproc;
	u64 e;
	i64 m;
	i64 nfields;
	asi64(R1) = qq_names_addanontype();
	m = asi64(R1);
	asu64(R1) = qq_decls_stcurrproc;
	oldstcurrproc = asu64(R1);
	asu64(R1) = owner;
	qq_decls_stcurrproc = asu64(R1);
L4064:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 113;
	if (asi64(R1) == asi64(R2)) goto L4066;
	R2 = 110;
	if (asi64(R1) == asi64(R2)) goto L4067;
	R2 = 100;
	if (asi64(R1) == asi64(R2)) goto L4068;
	R2 = 99;
	if (asi64(R1) == asi64(R2)) goto L4068;
	R2 = 102;
	if (asi64(R1) == asi64(R2)) goto L4069;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L4070;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L4071;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4071;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4071;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L4072;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4073;
	goto L4074;
L4066:
	R1 = 0;
	qq_parse_readconstdef(asi64(R1));
	goto L4064;
L4067:
	asu64(R1) = owner;
	qq_parse_readrecordfields(asu64(R1));
	goto L4064;
L4068:
	R1 = 0;
	qq_parse_readprocdef(asi64(R1));
	goto L4064;
L4069:
	R1 = 0;
	R2 = 0;
	qq_parse_readrecorddef(asi64(R2), asu64(R1));
	goto L4064;
L4070:
	qq_lex_lex();
	R1 = tou64("CLASS TYPE");
	qq_lib_serror(asu64(R1));
	goto L4064;
L4071:
	goto L4065;
	goto L4064;
L4072:
	R1 = tou64("Class eof?");
	qq_lib_serror(asu64(R1));
	goto L4065;
	goto L4064;
L4073:
	qq_lex_lex();
	goto L4064;
L4074:
	R1 = tou64("Unknown record field decl");
	qq_lib_serror(asu64(R1));
	goto L4064;
L4065:
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	nfields = asi64(R1);
	goto L4078;
L4075:
	asu64(R1) = e;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L4080;
	asu64(R1) = e;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L4080;
	R1 = (u64)&nfields;
	(*toi64p(R1)) += 1;
L4080:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L4078:
	asu64(R1) = e;
	if (asu64(R1)) goto L4075;
	asi64(R1) = nfields;
	asu64(R2) = owner;
	R3 = 104;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_tables_ttfields;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = nfields;
	R2 = (u64)&qq_tables_ttlength;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_ttlower;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = 12;
	R2 = (u64)&qq_tables_ttbasetype;
	asi64(R3) = m;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asi64(R1) = m;
	asu64(R2) = owner;
	qq_names_createusertype(asu64(R2), asi64(R1));
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L4082;
L4081:
	asu64(R1) = e;
	qq_names_addgenfield(asu64(R1));
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L4082:
	asu64(R1) = e;
	if (asu64(R1)) goto L4081;
	R1 = 16;
	asu64(R2) = owner;
	R3 = 104;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asi64(R1) *= asi64(R2);
	R2 = (u64)&qq_tables_ttsize;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asu64(R1) = oldstcurrproc;
	qq_decls_stcurrproc = asu64(R1);
	asi64(R1) = m;
	goto L4063;
L4063:
	return asi64(R1);
}

static void qq_parse_readrecordfields(u64 owner) {
    u64 R1, R2, R3, R4; 
	i64 nvars;
	i64 offset;
	i64 index;
	u64 d;
	qq_lex_lex();
	R1 = 0;
	nvars = asi64(R1);
	asu64(R1) = owner;
	R2 = 104;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	index = asi64(R1);
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = 0;
	offset = asi64(R1);
	goto L4088;
L4085:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L4090;
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L4090;
	R1 = 16;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L4090:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L4088:
	asu64(R1) = d;
	if (asu64(R1)) goto L4085;
	goto L4092;
L4091:
	R1 = (u64)&nvars;
	(*toi64p(R1)) += 1;
	R1 = 0;
	R2 = 11;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L4095;
	qq_lex_lex();
	asu64(R1) = qq_parse_readatfield();
	asu64(R2) = d;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 108;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 108;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 96;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4094;
L4095:
	asi64(R1) = offset;
	asu64(R2) = d;
	R3 = 108;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 16;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	R1 = (u64)&index;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 96;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4094:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4097;
	goto L4093;
L4097:
	qq_lex_lex();
L4092:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L4091;
L4093:
	asi64(R1) = nvars;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4099;
	R1 = tou64("No fields");
	qq_lib_serror(asu64(R1));
L4099:
	return;
}

static i64 qq_parse_readstructbody(u64 owner, i64 caligned) {
    u64 R1, R2, R3; 
	i64 m;
	i64 ngroups;
	i64 nvars;
	i64 t;
	u64 d;
	u64 e;
	asi64(R1) = qq_names_addanontype();
	m = asi64(R1);
	R1 = 0;
	ngroups = asi64(R1);
L4101:
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 103;
	if (asi64(R1) == asi64(R2)) goto L4104;
	R2 = 104;
	if (asi64(R1) == asi64(R2)) goto L4105;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L4106;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4107;
	goto L4108;
L4104:
	R1 = (u64)&ngroups;
	(*toi64p(R1)) += 1;
	qq_lex_lex();
	R1 = 24;
	asu64(R2) = owner;
	qq_parse_addstructflag(asu64(R2), asi64(R1));
	goto L4103;
L4105:
	R1 = (u64)&ngroups;
	(*toi64p(R1)) += 1;
	qq_lex_lex();
	R1 = 25;
	asu64(R2) = owner;
	qq_parse_addstructflag(asu64(R2), asi64(R1));
	goto L4103;
L4106:
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 103;
	if (asi64(R1) == asi64(R2)) goto L4111;
	R2 = 104;
	if (asi64(R1) != asi64(R2)) goto L4110;
L4111:
	qq_lex_lex();
L4110:
// qq_parse.readstructbody.doend:
L4112:
	asi64(R1) = ngroups;
	if (!asi64(R1)) goto L4114;
	R1 = (u64)&ngroups;
	(*toi64p(R1)) -=1;
	qq_lex_lex();
	R1 = 26;
	asu64(R2) = owner;
	qq_parse_addstructflag(asu64(R2), asi64(R1));
	goto L4113;
L4114:
	goto L4102;
L4113:
	goto L4103;
L4107:
	goto L4112;
	goto L4103;
L4108:
	R1 = 12;
	asu64(R2) = owner;
	qq_parse_readpackvars(asu64(R2), asi64(R1));
L4103:
	goto L4101;
L4102:
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_tables_ttfields;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = owner;
	R2 = 104;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = (u64)&qq_tables_ttlength;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_ttlower;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asi64(R1) = caligned;
	R2 = (u64)&qq_tables_ttcaligned;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 13;
	R2 = (u64)&qq_tables_ttbasetype;
	asi64(R3) = m;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asi64(R1) = m;
	asu64(R2) = owner;
	qq_names_createusertype(asu64(R2), asi64(R1));
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L4116;
L4115:
	asu64(R1) = e;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L4119;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L4119;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L4119;
	goto L4120;
L4119:
	goto L4118;
L4120:
	asu64(R1) = e;
	qq_names_addgenfield(asu64(R1));
L4118:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L4116:
	asu64(R1) = e;
	if (asu64(R1)) goto L4115;
	asi64(R1) = m;
	goto L4100;
L4100:
	return asi64(R1);
}

static void qq_parse_addstructflag(u64 owner, i64 id) {
    u64 R1, R2, R3, R4; 
	struct $B31 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$$#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_parse_addstructflag_structseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = 0;
	asi64(R2) = id;
	R3 = (u64)&str;
	asu64(R3) = qq_names_addglobalname(asu64(R3));
	asu64(R4) = owner;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void qq_parse_readprocdef(i64 isglobal) {
    u64 R1, R2, R3, R4; 
	i64 kwd;
	i64 startline;
	i64 nparams;
	i64 shortfun;
	u64 pcode;
	u64 d;
	u64 oldstcurrproc;
	struct $B16 str;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	shortfun = asi64(R1);
	R1 = 69;
	qq_parse_lexchecksymbol(asi64(R1));
	asu64(R1) = qq_decls_stcurrproc;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4125;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L4124;
L4125:
	R1 = tou64("Nested proc");
	qq_lib_serror(asu64(R1));
L4124:
	asu64(R1) = qq_decls_stcurrproc;
	oldstcurrproc = asu64(R1);
	asi64(R1) = isglobal;
	R2 = 5;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R2 = R1;
	d = asu64(R2);
	qq_decls_stcurrproc = asu64(R1);
	asu64(R1) = d;
	qq_names_addproc(asu64(R1));
	qq_lex_lex();
	R1 = 0;
	asu64(R2) = d;
	R3 = 116;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L4127;
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4129;
	asu64(R1) = d;
	qq_parse_readparams(asu64(R1));
	goto L4128;
L4129:
	qq_lex_lex();
L4128:
L4127:
	qq_parse_checkequals();
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	startline = asi64(R1);
	asi64(R1) = shortfun;
	if (asi64(R1)) goto L4131;
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	asu64(R2) = d;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = startline;
	R2 = 0;
	asi64(R3) = kwd;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	goto L4130;
L4131:
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = d;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 4;
	qq_lib_checksymbol(asi64(R1));
L4130:
	R1 = tou64("start");
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4133;
	asu64(R1) = d;
	asu64(R2) = qq_decls_currmodule;
	R3 = 104;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4132;
L4133:
	R1 = tou64("main");
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4134;
	asu64(R1) = d;
	asu64(R2) = qq_decls_currmodule;
	R3 = 112;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4134:
L4132:
	asi64(R1) = kwd;
	R2 = 100;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	asu64(R2) = qq_decls_stcurrproc;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 4;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = oldstcurrproc;
	qq_decls_stcurrproc = asu64(R1);
	return;
}

static u64 qq_parse_readatfield() {
    u64 R1, R2, R3; 
	u64 p;
	u64 d;
	R1 = 69;
	qq_lib_checksymbol(asi64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	qq_lex_lex();
	asu64(R1) = qq_decls_stcurrproc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L4137;
L4136:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4140;
	asu64(R1) = p;
	goto L4135;
L4140:
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L4137:
	asu64(R1) = p;
	if (asu64(R1)) goto L4136;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't find @ field");
	qq_lib_serror_s(asu64(R2), asu64(R1));
	R1 = 0;
	goto L4135;
L4135:
	return asu64(R1);
}

static i64 qq_parse_istypestarter() {
    u64 R1, R2; 
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L4143;
	R2 = 109;
	if (asi64(R1) == asi64(R2)) goto L4143;
	R2 = 110;
	if (asi64(R1) == asi64(R2)) goto L4143;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L4143;
	goto L4144;
L4143:
	R1 = 1;
	goto L4141;
	goto L4142;
L4144:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L4146;
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L4148;
	R1 = 1;
	goto L4141;
L4148:
L4146:
L4142:
	R1 = 0;
	goto L4141;
L4141:
	return asi64(R1);
}

static void qq_parse_readmacrodef(i64 isglobal) {
    u64 R1, R2, R3, R4; 
	u64 stmacro;
	u64 stname;
	u64 owner;
	R1 = 69;
	qq_parse_lexchecksymbol(asi64(R1));
	asi64(R1) = isglobal;
	R2 = 22;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	stmacro = asu64(R1);
	asu64(R1) = stmacro;
	owner = asu64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L4151;
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4153;
L4154:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L4157;
	goto L4158;
L4157:
	R1 = 0;
	R2 = 23;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = owner;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	stname = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = stname;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L4160;
	goto L4155;
L4160:
	R1 = 3;
	qq_lib_skipsymbol(asi64(R1));
	goto L4156;
L4158:
	R1 = tou64("macro def params");
	qq_lib_serror(asu64(R1));
L4156:
	goto L4154;
L4155:
L4153:
	qq_lex_lex();
L4151:
	qq_parse_checkequals();
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = stmacro;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 qq_parse_readhostparams(u64 lhs, i64 isfn) {
    u64 R1, R2, R3; 
	i64 fnindex;
	i64 nargs;
	u64 p;
	u64 q;
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	fnindex = asi64(R1);
	R1 = 9;
	qq_parse_lexchecksymbol(asi64(R1));
	qq_lex_lex();
	R1 = 0;
	R2 = (u64)&nargs;
	asu64(R1) = qq_parse_readslist(asu64(R2), asi64(R1));
	q = asu64(R1);
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = lhs;
	if (!asu64(R1)) goto L4163;
	asu64(R1) = q;
	asu64(R2) = lhs;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = lhs;
	q = asu64(R1);
L4163:
	asu64(R1) = q;
	R2 = 27;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = fnindex;
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	goto L4161;
L4161:
	return asu64(R1);
}

static void qq_parse_pushlisttype(i64 ltype) {
    u64 R1, R2, R3; 
	asi64(R1) = qq_parse_nlisttype;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L4166;
	R1 = tou64("listtype overflow");
	qq_lib_serror(asu64(R1));
L4166:
	asi64(R1) = qq_parse_listtype;
	R2 = (u64)&qq_parse_listtypestack;
	R3 = (u64)&qq_parse_nlisttype;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = ltype;
	qq_parse_listtype = asi64(R1);
	return;
}

static void qq_parse_poplisttype() {
    u64 R1, R2, R3; 
	R1 = (u64)&qq_parse_listtypestack;
	R2 = (u64)&qq_parse_nlisttype;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	qq_parse_listtype = asi64(R1);
	return;
}

static u64 qq_parse_readcompilervar() {
    u64 R1, R2, R3, R4; 
	struct $B5 str;
	struct $B13 tm;
// PROC LOCAL STATICS GO HERE
	static struct $B35 qq_parse_readcompilervar_monthnames = {{
	(u64)"Jan",
	(u64)"Feb",
	(u64)"Mar",
	(u64)"Apr",
	(u64)"May",
	(u64)"Jun",
	(u64)"Jul",
	(u64)"Aug",
	(u64)"Sep",
	(u64)"Oct",
	(u64)"Nov",
	(u64)"Dec"    }};
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4170;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4171;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4172;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4173;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4174;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4175;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L4176;
	goto L4177;
L4170:
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 23;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R1) = qq_lib_createintunit(asi64(R1));
	goto L4168;
	goto L4169;
L4171:
	R1 = 0;
	R2 = (u64)&qq_decls_lx;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 23;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4169;
L4172:
	asu64(R1) = qq_decls_currmodule;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4169;
L4173:
	asu64(R1) = qq_decls_currmodule;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4169;
L4174:
	asu64(R1) = qq_decls_stcurrproc;
	if (!asu64(R1)) goto L4179;
	asu64(R1) = qq_decls_stcurrproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L4178;
L4179:
	R1 = tou64("<none>");
L4178:
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4169;
L4175:
	R1 = (u64)&tm;
	mlinux_os_getsystime(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#-#-#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&tm;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&qq_parse_readcompilervar_monthnames;
	R2 = (u64)&tm;
	R3 = 4;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("4");
	R2 = (u64)&tm;
	R3 = 0;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	goto L4169;
L4176:
	R1 = (u64)&tm;
	mlinux_os_getsystime(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#:#:#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("2");
	R2 = (u64)&tm;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("z2");
	R2 = (u64)&tm;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("z2");
	R2 = (u64)&tm;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	goto L4169;
L4177:
	R1 = tou64("compiler var not impl");
	qq_lib_serror(asu64(R1));
L4169:
	R1 = -1;
	R2 = (u64)&str;
	asu64(R2) = mlib_pcm_copyheapstring(asu64(R2));
	asu64(R1) = qq_lib_createstringunit(asu64(R2), asi64(R1));
	goto L4168;
L4168:
	return asu64(R1);
}

static u64 qq_parse_readpair(i64 tag, i64 pclop) {
    u64 R1, R2, R3; 
	u64 p;
	u64 a;
	u64 b;
	R1 = 9;
	qq_parse_lexchecksymbol(asi64(R1));
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	a = asu64(R1);
	R1 = 3;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = qq_parse_readexpression();
	b = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4182;
	asi64(R1) = tag;
	R2 = 37;
	if (asi64(R1) != asi64(R2)) goto L4182;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = b;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4182:
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R3) = tag;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pclop;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L4180;
L4180:
	return asu64(R1);
}

static void qq_parse_lexchecksymbol(i64 symbol) {
    u64 R1; 
	qq_lex_lex();
	asi64(R1) = symbol;
	qq_lib_checksymbol(asi64(R1));
	return;
}

static void qq_parse_readtypedef(i64 isglobal) {
    u64 R1, R2, R3, R4; 
	i64 ptype;
	u64 d;
	R1 = 69;
	qq_parse_lexchecksymbol(asi64(R1));
	asi64(R1) = isglobal;
	R2 = 10;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 43;
	qq_parse_lexchecksymbol(asi64(R1));
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 102;
	if (asi64(R1) != asi64(R2)) goto L4186;
	qq_lex_lex();
	R1 = 9;
	asu64(R2) = d;
	R3 = 124;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	asi64(R2) = isglobal;
	qq_parse_readrecorddef(asi64(R2), asu64(R1));
	goto L4184;
L4186:
	asu64(R1) = d;
	R2 = 0;
	asi64(R1) = qq_parse_readtypespec(asi64(R2), asu64(R1));
	ptype = asi64(R1);
	asi64(R1) = ptype;
	asu64(R2) = d;
	qq_names_createusertype(asu64(R2), asi64(R1));
L4184:
	return;
}

static i64 qq_parse_readtypespec(i64 allowvar, u64 owner) {
    u64 R1, R2, R3; 
	i64 flags;
	i64 arraycode;
	i64 oldipl;
	i64 a;
	i64 b;
	i64 t;
	i64 startline;
	i64 caligned;
	u64 d;
	struct $B1 lowerdims;
	struct $B1 lengthdims;
	i64 ndims;
	u64 x;
	u64 lowerx;
	u64 upperx;
	u64 lengthx;
	i64 i;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L4189;
	R2 = 109;
	if (asi64(R1) == asi64(R2)) goto L4190;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L4191;
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L4192;
	R2 = 102;
	if (asi64(R1) == asi64(R2)) goto L4193;
	R2 = 103;
	if (asi64(R1) == asi64(R2)) goto L4194;
	goto L4195;
L4189:
// qq_parse.readtypespec.dolsq:
L4196:
	qq_lex_lex();
	R1 = 0;
	ndims = asi64(R1);
	R1 = 0;
	qq_parse_pushlisttype(asi64(R1));
L4197:
	R1 = 0;
	R2 = R1;
	lengthx = asu64(R2);
	lowerx = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L4201;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4200;
L4201:
	goto L4199;
L4200:
	asu64(R1) = qq_parse_readexpression();
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 87;
	if (asi64(R1) != asi64(R2)) goto L4203;
	asu64(R1) = x;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	lowerx = asu64(R1);
	asu64(R1) = x;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	upperx = asu64(R1);
	asu64(R1) = lowerx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L4205;
	asu64(R1) = upperx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L4205;
	asu64(R1) = upperx;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = lowerx;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = qq_lib_createintunit(asi64(R1));
	lengthx = asu64(R1);
	goto L4204;
L4205:
	asu64(R1) = lowerx;
	asu64(R2) = upperx;
	R3 = 63;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	lengthx = asu64(R1);
	R1 = 102;
	asu64(R2) = lengthx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R1) = qq_lib_createintunit(asi64(R1));
	asu64(R2) = lengthx;
	R3 = 63;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	lengthx = asu64(R1);
	R1 = 101;
	asu64(R2) = lengthx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4204:
	goto L4202;
L4203:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L4207;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4207;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4208;
	goto L4209;
L4207:
	asu64(R1) = x;
	lengthx = asu64(R1);
	goto L4206;
L4208:
	asu64(R1) = x;
	lowerx = asu64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4211;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L4211;
	asu64(R1) = qq_parse_readexpression();
	lengthx = asu64(R1);
L4211:
	goto L4206;
L4209:
L4206:
L4202:
L4199:
	asu64(R1) = lowerx;
	R2 = (u64)&lowerdims;
	R3 = (u64)&ndims;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = lengthx;
	R2 = (u64)&lengthdims;
	asi64(R3) = ndims;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4213;
	goto L4198;
L4213:
	qq_lex_lex();
	goto L4197;
L4198:
	R1 = 12;
	qq_lib_skipsymbol(asi64(R1));
	qq_parse_poplisttype();
	R1 = 0;
	R2 = 0;
	asi64(R1) = qq_parse_readtypespec(asi64(R2), asu64(R1));
	t = asi64(R1);
	asi64(R1) = ndims;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4216;
L4214:
	R1 = (u64)&lengthdims;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&lowerdims;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R3) = t;
	asi64(R1) = qq_names_makeaxtype(asi64(R3), asu64(R2), asu64(R1));
	t = asi64(R1);
	i += -1; if (i >= 1) goto L4214;
L4216:
	asi64(R1) = t;
	goto L4187;
	goto L4188;
L4190:
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 70;
	if (asi64(R1) != asi64(R2)) goto L4218;
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4218;
	qq_lex_lex();
	asu64(R1) = owner;
	R2 = 0;
	asi64(R1) = qq_names_makereftype(asi64(R2), asu64(R1));
	goto L4187;
	goto L4217;
L4218:
	asu64(R1) = owner;
	R2 = 0;
	R3 = 0;
	asi64(R2) = qq_parse_readtypespec(asi64(R3), asu64(R2));
	asi64(R1) = qq_names_makereftype(asi64(R2), asu64(R1));
	goto L4187;
L4217:
	goto L4188;
L4191:
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4220;
	R1 = 69;
	qq_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	asi64(R1) = qq_names_newusertypex(asu64(R2), asu64(R1));
	t = asi64(R1);
	qq_lex_lex();
	asi64(R1) = t;
	goto L4187;
	goto L4219;
L4220:
	R1 = 0;
	asu64(R2) = d;
	asi64(R1) = qq_names_newusertypex(asu64(R2), asu64(R1));
	goto L4187;
L4219:
	goto L4188;
L4192:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L4222;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L4223;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L4224;
	goto L4225;
L4222:
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 24;
	if (asi64(R1) != asi64(R2)) goto L4227;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	R2 = 37;
	asi64(R1) = qq_names_makestrtype(asi64(R2), asu64(R1));
	goto L4187;
	goto L4226;
L4227:
	R1 = 38;
	goto L4187;
L4226:
	goto L4221;
L4223:
	R1 = 24;
	qq_parse_lexchecksymbol(asi64(R1));
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	R2 = 36;
	asi64(R1) = qq_names_makestrtype(asi64(R2), asu64(R1));
	goto L4187;
	goto L4221;
L4224:
	R1 = 11;
	qq_parse_lexchecksymbol(asi64(R1));
	goto L4196;
	goto L4221;
L4225:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	t = asi64(R1);
	asi64(R1) = t;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4229;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4230;
	goto L4231;
L4229:
	R1 = 26;
	t = asi64(R1);
	goto L4228;
L4230:
	R1 = 32;
	t = asi64(R1);
	goto L4228;
L4231:
L4228:
	qq_lex_lex();
	asi64(R1) = t;
	goto L4187;
L4221:
	goto L4188;
L4193:
	asu64(R1) = owner;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4233;
	R1 = tou64("anon record");
	qq_lib_serror(asu64(R1));
L4233:
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	startline = asi64(R1);
	asu64(R1) = owner;
	asi64(R1) = qq_parse_readrecordbody(asu64(R1));
	t = asi64(R1);
	asi64(R1) = startline;
	R2 = 0;
	R3 = 102;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	goto L4187;
	goto L4188;
L4194:
	asu64(R1) = owner;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4235;
	R1 = tou64("anon struct");
	qq_lib_serror(asu64(R1));
L4235:
	qq_lex_lex();
	R1 = 0;
	caligned = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 116;
	if (asi64(R1) != asi64(R2)) goto L4237;
	R1 = 1;
	caligned = asi64(R1);
	qq_lex_lex();
L4237:
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	startline = asi64(R1);
	asi64(R1) = caligned;
	asu64(R2) = owner;
	asi64(R1) = qq_parse_readstructbody(asu64(R2), asi64(R1));
	t = asi64(R1);
	asi64(R1) = startline;
	R2 = 0;
	R3 = 103;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	goto L4187;
	goto L4188;
L4195:
	R1 = tou64("Type expected");
	qq_lib_serror(asu64(R1));
L4188:
	asi64(R1) = t;
	goto L4187;
L4187:
	return asi64(R1);
}

static void qq_parse_readparams(u64 stproc) {
    u64 R1, R2, R3, R4; 
	i64 isbyref;
	i64 isoptional;
	u64 d;
	R1 = 0;
	R2 = R1;
	isoptional = asi64(R2);
	isbyref = asi64(R1);
L4239:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L4242;
	R1 = (u64)&isbyref;
	(*toi64p(R1)) += 1;
	qq_lex_lex();
L4242:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L4244;
	R1 = (u64)&isoptional;
	(*toi64p(R1)) += 1;
	qq_lex_lex();
L4244:
	R1 = 69;
	qq_lib_checksymbol(asi64(R1));
	R1 = 0;
	R2 = 15;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = stproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = stproc;
	R2 = 104;
	R1 += (i64)R2;
	(*toi16p(R1)) += 1;
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) != asi64(R2)) goto L4246;
	R1 = 1;
	isoptional = asi64(R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = d;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4246:
	asi64(R1) = isbyref;
	if (!asi64(R1)) goto L4248;
	asi64(R1) = isoptional;
	if (!asi64(R1)) goto L4248;
	R1 = tou64("Mixed byref/optional");
	qq_lib_serror(asu64(R1));
L4248:
	asi64(R1) = isbyref;
	asu64(R2) = d;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 5;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = isoptional;
	asu64(R2) = d;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 7;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 0;
	R2 = R1;
	isoptional = asi64(R2);
	isbyref = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4250;
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L4252;
	R1 = 1;
	asu64(R2) = stproc;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 8;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	qq_lex_lex();
	goto L4240;
L4252:
	goto L4249;
L4250:
	goto L4240;
L4249:
	goto L4239;
L4240:
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	return;
}

static u64 qq_parse_checkoperator() {
    u64 R1, R2, R3; 
	u64 p;
	i64 opc;
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4256;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4256;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L4255;
L4256:
	R1 = 5;
	asu64(R1) = qq_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 132;
	if (asi64(R1) != asi64(R2)) goto L4258;
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L4260;
	R2 = 23899;
	if (asi64(R1) == asi64(R2)) goto L4261;
	goto L4262;
L4260:
	R1 = 75;
	opc = asi64(R1);
	goto L4259;
L4261:
	R1 = 130;
	opc = asi64(R1);
	goto L4259;
L4262:
	R1 = 0;
	opc = asi64(R1);
L4259:
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4257;
L4258:
	R1 = (u64)&qq_tables_cmpopset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4263;
	R1 = tou64("(CMP OP) NOT READY");
	qq_lib_serror(asu64(R1));
	goto L4257;
L4263:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4257:
	qq_lex_lex();
	asu64(R1) = p;
	goto L4253;
L4255:
	R1 = 0;
	goto L4253;
L4253:
	return asu64(R1);
}

static u64 qq_parse_readlambda() {
    u64 R1, R2, R3, R4; 
	u64 p;
	struct $B27 params;
	u64 oldstcurrproc;
	u64 stproc;
	u64 d;
	struct $B71 str;
	i64 nparams;
	u8 byref;
	asu64(R1) = qq_decls_stcurrproc;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4266;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4267;
	goto L4268;
L4266:
	goto L4265;
L4267:
	R1 = tou64("Nested {}");
	qq_lib_serror(asu64(R1));
	goto L4265;
L4268:
	R1 = tou64("{} not in fn");
	qq_lib_serror(asu64(R1));
L4265:
	asu64(R1) = qq_decls_stcurrproc;
	oldstcurrproc = asu64(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$F");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&qq_parse_nextlambdaindex;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = 6;
	R3 = (u64)&str;
	asu64(R3) = qq_lex_addnamestr(asu64(R3));
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	stproc = asu64(R1);
	asu64(R1) = stproc;
	qq_decls_stcurrproc = asu64(R1);
	asu64(R1) = stproc;
	qq_names_addproc(asu64(R1));
	qq_lex_lex();
	R1 = 0;
	nparams = asi64(R1);
	R1 = 0;
	byref = asu8(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L4270;
	qq_lex_lex();
	R1 = 1;
	byref = asu8(R1);
L4270:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L4272;
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4273;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4272;
L4273:
L4274:
	R1 = 69;
	qq_lib_checksymbol(asi64(R1));
	R1 = 0;
	R2 = 15;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = stproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = (u64)&params;
	R3 = (u64)&nparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu8(R1) = byref;
	R1 = tou64(tou8(R1));
	asu64(R2) = d;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 5;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 0;
	byref = asu8(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4277;
	goto L4275;
L4277:
	qq_lex_lex();
	goto L4274;
L4275:
	R1 = 5;
	qq_lib_checksymbol(asi64(R1));
	qq_lex_lex();
L4272:
	asi64(R1) = nparams;
	asu64(R2) = stproc;
	R3 = 104;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 1;
	asu64(R2) = stproc;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 4;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	asu64(R2) = stproc;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 14;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = stproc;
	asu64(R1) = qq_lib_createname(asu64(R1));
	p = asu64(R1);
	asu64(R1) = oldstcurrproc;
	qq_decls_stcurrproc = asu64(R1);
	asu64(R1) = p;
	goto L4264;
L4264:
	return asu64(R1);
}

static void qq_parse_readpackvars(u64 owner, i64 id) {
    u64 R1, R2, R3, R4; 
	i64 t;
	i64 nvars;
	u64 d;
	R1 = 0;
	R2 = 0;
	asi64(R1) = qq_parse_readtypespec(asi64(R2), asu64(R1));
	t = asi64(R1);
	R1 = 0;
	nvars = asi64(R1);
	goto L4280;
L4279:
	R1 = (u64)&nvars;
	(*toi64p(R1)) += 1;
	R1 = 0;
	asi64(R2) = id;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = owner;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 116;
	R1 += (i64)R2;
	asi64(R2) = t;
	asu64(R3) = owner;
	qq_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4283;
	goto L4281;
L4283:
	R1 = 69;
	qq_parse_lexchecksymbol(asi64(R1));
L4280:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L4279;
L4281:
	asi64(R1) = nvars;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4285;
	R1 = tou64("bad decl?");
	qq_lib_serror(asu64(R1));
L4285:
	return;
}

static void qq_pclgen_evalunit(u64 p, i64 res) {
    u64 R1, R2, R3, R4, R5; 
	u64 a;
	u64 b;
	u64 d;
	i64 procflag;
	i64 index;
	i64 av_1;
	i64 i;
	asu64(R1) = p;
	R2 = 4;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	qq_decls_qpos = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 0: goto L4292;
	case 1: goto L4335;
	case 2: goto L4322;
	case 3: case 9: case 14: case 24: case 38: case 45: case 56: case 57: case 58: case 67: case 80: case 81: case 82: case 83: case 86: goto L4289;
	case 4: goto L4357;
	case 5: goto L4399;
	case 6: goto L4309;
	case 7: goto L4324;
	case 8: goto L4343;
	case 10: case 11: goto L4340;
	case 12: case 13: goto L4341;
	case 15: goto L4325;
	case 16: goto L4326;
	case 17: case 18: goto L4327;
	case 19: goto L4339;
	case 20: goto L4323;
	case 21: goto L4328;
	case 22: goto L4329;
	case 23: goto L4350;
	case 25: goto L4402;
	case 26: goto L4319;
	case 27: goto L4321;
	case 28: goto L4401;
	case 29: goto L4342;
	case 30: goto L4330;
	case 31: goto L4347;
	case 32: goto L4320;
	case 33: goto L4404;
	case 34: goto L4398;
	case 35: goto L4396;
	case 36: goto L4397;
	case 37: goto L4358;
	case 39: goto L4294;
	case 40: goto L4306;
	case 41: goto L4290;
	case 42: goto L4291;
	case 43: goto L4293;
	case 44: goto L4318;
	case 46: goto L4382;
	case 47: goto L4385;
	case 48: goto L4386;
	case 49: goto L4387;
	case 50: goto L4338;
	case 51: goto L4390;
	case 52: goto L4391;
	case 53: goto L4403;
	case 54: goto L4344;
	case 55: goto L4345;
	case 59: goto L4346;
	case 60: case 61: goto L4400;
	case 62: case 66: goto L4371;
	case 63: goto L4359;
	case 64: goto L4409;
	case 65: goto L4412;
	case 68: goto L4405;
	case 69: goto L4380;
	case 70: goto L4381;
	case 71: goto L4408;
	case 72: goto L4351;
	case 73: goto L4352;
	case 74: goto L4378;
	case 75: goto L4379;
	case 76: goto L4406;
	case 77: goto L4407;
	case 78: goto L4374;
	case 79: goto L4364;
	case 84: case 85: goto L4375;
	case 87: goto L4356;
	case 88: goto L4353;
	case 89: goto L4354;
	case 90: goto L4355;
	default: goto L4289;
    };
// SWITCH
L4290:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	goto L4287;
L4291:
	asu64(R1) = p;
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R2 = 17;
	qq_pcllib_genpc_real(asi64(R2), asr64(R1));
	goto L4287;
L4292:
	goto L4287;
L4293:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_pclgen_pushstring(asu64(R1));
	goto L4287;
L4294:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L4296;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4297;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L4297;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L4298;
	goto L4299;
L4296:
	asu64(R1) = d;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L4301;
	R1 = 22;
	qq_pcllib_genpc(asi64(R1));
L4301:
	goto L4295;
L4297:
	asu64(R1) = d;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L4295;
L4298:
	asu64(R1) = d;
	R2 = 80;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4303;
	asi64(R1) = qq_pcllib_createfwdlabel();
	asu64(R2) = d;
	R3 = 80;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L4303:
	asi64(R1) = res;
	if (asi64(R1)) goto L4305;
	asu64(R1) = d;
	R2 = 80;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 30;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	goto L4286;
	goto L4304;
L4305:
	asu64(R1) = d;
	R2 = 80;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 11;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
L4304:
	goto L4295;
L4299:
	asu64(R1) = d;
	R2 = 21;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
L4295:
	goto L4287;
L4306:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L4308;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 21;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L4307;
L4308:
	R1 = 0;
	R2 = tou64(".$ name expected");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4307:
	goto L4287;
L4309:
	asu64(R1) = a;
	if (!asu64(R1)) goto L4311;
	goto L4313;
L4312:
	R1 = 0;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L4313:
	asu64(R1) = a;
	if (!asu64(R1)) goto L4315;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L4312;
L4315:
	asu64(R1) = a;
	if (!asu64(R1)) goto L4317;
	asi64(R1) = res;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
L4317:
	goto L4310;
L4311:
L4310:
	goto L4287;
L4318:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_pclgen_pushstring(asu64(R1));
	R1 = 69;
	qq_pcllib_genpc(asi64(R1));
	goto L4287;
L4319:
	R1 = (u64)&procflag;
	asi64(R2) = res;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	qq_pclgen_do_call(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L4287;
L4320:
	asi64(R1) = res;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_return(asu64(R3), asu64(R2), asi64(R1));
	goto L4287;
L4321:
	asi64(R1) = res;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_callhost(asu64(R3), asu64(R2), asi64(R1));
	goto L4287;
L4322:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = res;
	asu64(R3) = b;
	asu64(R4) = a;
	qq_pclgen_do_assign(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L4287;
L4323:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_to(asu64(R3), asu64(R2), asu64(R1));
	goto L4287;
L4324:
	asi64(R1) = res;
	asu64(R2) = b;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	qq_pclgen_do_if(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L4287;
L4325:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_for(asu64(R3), asu64(R2), asu64(R1));
	goto L4287;
L4326:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_forx(asu64(R3), asu64(R2), asu64(R1));
	goto L4287;
L4327:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_forall(asu64(R3), asu64(R2), asu64(R1));
	goto L4287;
L4328:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_while(asu64(R3), asu64(R2), asu64(R1));
	goto L4287;
L4329:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_repeat(asu64(R3), asu64(R2), asu64(R1));
	goto L4287;
L4330:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L4332;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L4332;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 80;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4334;
	asi64(R1) = qq_pcllib_createfwdlabel();
	asu64(R2) = d;
	R3 = 80;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L4334:
	asu64(R1) = d;
	R2 = 80;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 30;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	goto L4331;
L4332:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 31;
	qq_pcllib_genpc(asi64(R1));
L4331:
	goto L4287;
L4335:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_pcllib_gencomment(asu64(R1));
	asu64(R1) = d;
	R2 = 80;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4337;
	asi64(R1) = qq_pcllib_definelabel();
	asu64(R2) = d;
	R3 = 80;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L4336;
L4337:
	asu64(R1) = d;
	R2 = 80;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	index = asi64(R1);
	asi64(R1) = index;
	qq_pcllib_definefwdlabel(asi64(R1));
L4336:
	goto L4287;
L4338:
	asu64(R1) = p;
	qq_pclgen_do_loop(asu64(R1));
	goto L4287;
L4339:
	asu64(R1) = a;
	asu64(R2) = p;
	qq_pclgen_do_do(asu64(R2), asu64(R1));
	goto L4287;
L4340:
	asi64(R1) = res;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	qq_pclgen_do_case(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L4287;
L4341:
	asi64(R1) = res;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	qq_pclgen_do_switch(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L4287;
L4342:
	asu64(R1) = a;
	qq_pclgen_evalref(asu64(R1));
	asu64(R1) = b;
	qq_pclgen_evalref(asu64(R1));
	R1 = 28;
	qq_pcllib_genpc(asi64(R1));
	goto L4287;
L4343:
	asi64(R1) = res;
	asu64(R2) = b;
	asu64(R3) = a;
	qq_pclgen_do_select(asu64(R3), asu64(R2), asi64(R1));
	goto L4287;
L4344:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_print(asu64(R3), asu64(R2), asu64(R1));
	goto L4287;
L4345:
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	qq_pclgen_do_fprint(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L4287;
L4346:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_read(asu64(R3), asu64(R2), asu64(R1));
	goto L4287;
L4347:
	asu64(R1) = a;
	if (!asu64(R1)) goto L4349;
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L4348;
L4349:
	R1 = 0;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
L4348:
	R1 = 60;
	qq_pcllib_genpc(asi64(R1));
	goto L4287;
L4350:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_try(asu64(R3), asu64(R2), asu64(R1));
	goto L4287;
L4351:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_pclgen_do_andl(asu64(R2), asu64(R1));
	goto L4287;
L4352:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_pclgen_do_orl(asu64(R2), asu64(R1));
	goto L4287;
L4353:
	asu64(R1) = p;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	qq_pclgen_do_pushlist(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 61;
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	goto L4287;
L4354:
	asu64(R1) = p;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	qq_pclgen_do_pushlist(asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 66;
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	goto L4287;
L4355:
	asu64(R1) = p;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	qq_pclgen_do_makedict(asu64(R2), asi64(R1));
	goto L4287;
L4356:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 67;
	qq_pcllib_genpc(asi64(R1));
	goto L4287;
L4357:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L4287;
L4358:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_map(asu64(R3), asu64(R2), asu64(R1));
	goto L4287;
L4359:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 105;
	if (asi64(R1) == asi64(R2)) goto L4361;
	R2 = 106;
	if (asi64(R1) == asi64(R2)) goto L4362;
	goto L4363;
L4361:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_pclgen_do_idiv(asu64(R2), asu64(R1));
	goto L4360;
L4362:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_pclgen_do_irem(asu64(R2), asu64(R1));
	goto L4360;
L4363:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	qq_pcllib_genpc(asi64(R1));
L4360:
	goto L4287;
L4364:
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = a;
	qq_pclgen_evalref(asu64(R1));
	R1 = 122;
	qq_pcllib_genpc(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	R1 = 11;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4368;
L4365:
	R1 = (u64)&qq_pcltabs_bintotable;
	asi64(R2) = i;
	R1 += (i64)R2*24-24;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) != asi64(R2)) goto L4370;
	asi64(R1) = i;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4367;
L4370:
	i += 1; if (i <= av_1) goto L4365;
L4368:
	R1 = 0;
	R2 = tou64("No binto entry");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4367:
	goto L4287;
L4371:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 90;
	if (asi64(R1) != asi64(R2)) goto L4373;
	R1 = 1;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4373:
	goto L4287;
L4374:
	asu64(R1) = a;
	qq_pclgen_evalref(asu64(R1));
	R1 = 85;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4287;
L4375:
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = a;
	qq_pclgen_evalref(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) != asi64(R2)) goto L4377;
	R1 = 126;
	goto L4376;
L4377:
	R1 = 125;
L4376:
	qq_pcllib_genpc(asi64(R1));
	goto L4287;
L4378:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 77;
	qq_pcllib_genpc(asi64(R1));
	goto L4287;
L4379:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 79;
	qq_pcllib_genpc(asi64(R1));
	goto L4287;
L4380:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 97;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = p;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4287;
L4381:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 98;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4287;
L4382:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 104;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4384;
	R1 = 0;
	R2 = tou64(".m?");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4384:
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 127;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L4287;
L4385:
	R1 = 130;
	asu64(R2) = b;
	asu64(R3) = a;
	qq_pclgen_do_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L4287;
L4386:
	R1 = 136;
	asu64(R2) = b;
	asu64(R3) = a;
	qq_pclgen_do_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L4287;
L4387:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4389;
	R1 = 1;
	asu64(R2) = b;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L4388;
L4389:
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
L4388:
	R1 = 133;
	qq_pcllib_genpc(asi64(R1));
	goto L4287;
L4390:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 22;
	qq_pcllib_genpc(asi64(R1));
	goto L4287;
L4391:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4393;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 51;
	if (asi64(R1) != asi64(R2)) goto L4395;
	R1 = 1;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L4394;
L4395:
	asu64(R1) = a;
	qq_pclgen_evalref(asu64(R1));
L4394:
	goto L4392;
L4393:
	asu64(R1) = a;
	qq_pclgen_evalref(asu64(R1));
	R1 = 29;
	qq_pcllib_genpc(asi64(R1));
L4392:
	goto L4287;
L4396:
	asu64(R1) = p;
	qq_pclgen_do_convert(asu64(R1));
	goto L4287;
L4397:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 100;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	goto L4287;
L4398:
	asu64(R1) = p;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 19;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	goto L4287;
L4399:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	goto L4287;
L4400:
	asi64(R1) = res;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_incr(asu64(R3), asu64(R2), asi64(R1));
	goto L4287;
L4401:
	R1 = 16;
	qq_pcllib_genpc(asi64(R1));
	goto L4287;
L4402:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 141;
	qq_pcllib_genpc(asi64(R1));
	goto L4287;
L4403:
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
	goto L4287;
L4404:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	R2 = 58;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
	goto L4287;
L4405:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 92;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
	goto L4287;
L4406:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 113;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4287;
L4407:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 114;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4287;
L4408:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 115;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
	goto L4287;
L4409:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4411;
	R1 = 82;
	qq_pcllib_genpc(asi64(R1));
	goto L4410;
L4411:
	R1 = 83;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4410:
	goto L4287;
L4412:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 84;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4287;
L4289:
	asu64(R1) = p;
	R2 = (u64)&qq_tables_jtagnames;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("UNSUPPORTED TAG:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L4287:
	R1 = (u64)&qq_tables_jhasvalue;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4414;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4415;
	goto L4416;
L4414:
	asi64(R1) = res;
	if (!asi64(R1)) goto L4418;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L4422;
	R2 = 55;
	if (asi64(R1) != asi64(R2)) goto L4421;
L4422:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L4420;
L4421:
	R1 = 0;
	R2 = (u64)&qq_tables_jtagnames;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("Value expected:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L4420:
L4418:
	goto L4413;
L4415:
	asi64(R1) = res;
	if (asi64(R1)) goto L4424;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 26;
	if (asi64(R1) != asi64(R2)) goto L4426;
	asi64(R1) = procflag;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4426;
	goto L4425;
L4426:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L4428;
	R2 = 61;
	if (asi64(R1) != asi64(R2)) goto L4427;
L4428:
	goto L4425;
L4427:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L4429;
	R1 = (u64)&qq_tables_hostisfn;
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4429;
	goto L4425;
L4429:
	R1 = 1;
	R2 = 58;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
L4425:
L4424:
	goto L4413;
L4416:
L4413:
L4286:
	return;
}

static void qq_pclgen_gencodemodule(u64 sp, i64 moduleno) {
    u64 R1, R2, R3, R4; 
	struct $B27 anonprocs;
	i64 nanonprocs;
	u64 d;
	u64 e;
	i64 lab;
	i64 a;
	i64 b;
	u64 pm;
	u64 pc;
	u64 pctarget;
	u64 labelmap;
	i64 av_1;
	i64 av_2;
	i64 i;
	R1 = 0;
	nanonprocs = asi64(R1);
	asu64(R1) = sp;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	a = asi64(R1);
	asu64(R1) = sp;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	b = asi64(R1);
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = moduleno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	asu64(R1) = pm;
	qq_decls_currmodule = asu64(R1);
	asu64(R1) = qq_decls_currmodule;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	qq_decls_stcurrmodule = asu64(R2);
	qq_decls_stcurrproc = asu64(R1);
	asu64(R1) = pm;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	qq_pcllib_resetpcl(asi64(R1));
	R1 = tou64("Module data init code:");
	qq_pcllib_gencomment(asu64(R1));
	R1 = 0;
	qq_decls_qpos = asi64(R1);
	asi64(R1) = moduleno;
	R2 = (u64)&qq_decls_qpos;
	R3 = 24;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = moduleno;
	asi64(R2) = a;
	if (asi64(R1) != asi64(R2)) goto L4432;
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab = asi64(R1);
	asi64(R1) = lab;
	R2 = 30;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	R1 = 1;
	R2 = 60;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
	asu64(R1) = qq_pcllib_pccurr;
	qq_decls_stopseq = asu64(R1);
	asu64(R1) = qq_pcllib_pccurr;
	R2 = 1;
	R1 += (i64)R2*32;
	qq_decls_raiseseq = asu64(R1);
	R1 = 0;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	R1 = 141;
	qq_pcllib_genpc(asi64(R1));
	asi64(R1) = lab;
	qq_pcllib_definefwdlabel(asi64(R1));
L4432:
	asu64(R1) = qq_decls_stcurrmodule;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L4434;
L4433:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4437;
	asu64(R1) = d;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4437;
	R1 = 1;
	asu64(R2) = d;
	R3 = 88;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
	R3 = 12;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4439;
	R1 = 27;
	qq_pcllib_genpc(asi64(R1));
L4439:
	asu64(R1) = d;
	R2 = 24;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L4436;
L4437:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4440;
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L4442;
L4441:
	asu64(R1) = e;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4445;
	asu64(R1) = e;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4445;
	R1 = 1;
	asu64(R2) = e;
	R3 = 88;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = e;
	R2 = 24;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L4444;
L4445:
	asu64(R1) = e;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L4446;
	asi64(R1) = nanonprocs;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L4448;
	R1 = 0;
	R2 = tou64("Too many anons");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4448:
	asu64(R1) = e;
	R2 = (u64)&anonprocs;
	R3 = (u64)&nanonprocs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4446:
L4444:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L4442:
	asu64(R1) = e;
	if (asu64(R1)) goto L4441;
L4440:
L4436:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L4434:
	asu64(R1) = d;
	if (asu64(R1)) goto L4433;
	asi64(R1) = moduleno;
	asi64(R2) = a;
	if (asi64(R1) != asi64(R2)) goto L4450;
	asi64(R1) = b;
	i = asi64(R1);
	asi64(R1) = a;
	R2 = 1;
	asi64(R1) += asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_1;
	if (asi64(R1) < asi64(R2)) goto L4453;
L4451:
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 54;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	i += -1; if (i >= av_1) goto L4451;
L4453:
	asi64(R1) = b;
	i = asi64(R1);
	asi64(R1) = a;
	R2 = 1;
	asi64(R1) += asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_2;
	if (asi64(R1) < asi64(R2)) goto L4456;
L4454:
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4458;
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 50;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
L4458:
	i += -1; if (i >= av_2) goto L4454;
L4456:
	asu64(R1) = qq_decls_currmodule;
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4460;
	asu64(R1) = qq_decls_currmodule;
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 50;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
L4460:
	asu64(R1) = qq_decls_currmodule;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4462;
	asu64(R1) = qq_decls_currmodule;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 50;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
L4462:
	R1 = 0;
	asu64(R2) = qq_decls_stcurrmodule;
	R3 = 88;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	R1 = 60;
	qq_pcllib_genpc(asi64(R1));
	goto L4449;
L4450:
	R1 = 0;
	asu64(R2) = qq_decls_stcurrmodule;
	R3 = 88;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 55;
	qq_pcllib_genpc(asi64(R1));
L4449:
	R1 = tou64("Procs:");
	qq_pcllib_gencomment(asu64(R1));
	asu64(R1) = qq_decls_stcurrmodule;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L4464;
L4463:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 5: case 6: goto L4469;
	case 7: goto L4482;
	case 8: goto L4485;
	case 9: goto L4471;
	case 10: goto L4481;
	case 11: case 12: case 14: case 15: case 16: case 21: goto L4468;
	case 13: goto L4470;
	case 17: goto L4480;
	case 18: goto L4478;
	case 19: goto L4479;
	case 20: goto L4483;
	case 22: goto L4484;
	default: goto L4468;
    };
// SWITCH
L4469:
	asu64(R1) = d;
	qq_pclgen_do_procdef(asu64(R1));
	goto L4466;
L4470:
	goto L4466;
L4471:
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L4475;
L4472:
	asu64(R1) = e;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4477;
	asu64(R1) = e;
	qq_pclgen_do_procdef(asu64(R1));
L4477:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L4475:
	asu64(R1) = e;
	if (asu64(R1)) goto L4472;
	goto L4466;
L4478:
	goto L4466;
L4479:
	goto L4466;
L4480:
	goto L4466;
L4481:
	goto L4466;
L4482:
	goto L4466;
L4483:
	goto L4466;
L4484:
	goto L4466;
L4485:
	goto L4466;
L4468:
	R1 = 0;
	R2 = (u64)&qq_tables_namenames;
	asu64(R3) = d;
	R4 = 124;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("?Module def:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L4466:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L4464:
	asu64(R1) = d;
	if (asu64(R1)) goto L4463;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nanonprocs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4488;
L4486:
	R1 = (u64)&anonprocs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	qq_pclgen_do_procdef(asu64(R1));
	i += 1; if (i <= nanonprocs) goto L4486;
L4488:
	R1 = 5;
	qq_pcllib_genpc(asi64(R1));
	asi64(R1) = qq_pcllib_nextlabelno;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	labelmap = asu64(R1);
	asu64(R1) = qq_pcllib_pcstart;
	pc = asu64(R1);
	goto L4492;
L4489:
	R1 = (u64)&qq_pcltabs_pclopnd;
	asu64(R2) = pc;
	R3 = 8;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L4494;
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	lab = asi64(R1);
	asu64(R1) = qq_pcllib_labelpctable;
	asi64(R2) = lab;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pctarget = asu64(R1);
	asu64(R1) = pctarget;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4496;
	R1 = 0;
	R2 = 0;
	asi64(R3) = lab;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	R3 = tou64("Lab undef:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L4496:
	R1 = 1;
	asu64(R2) = labelmap;
	asi64(R3) = lab;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = pctarget;
	asu64(R2) = pc;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4494:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L4492:
	asu64(R1) = pc;
	asu64(R2) = qq_pcllib_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L4489;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_pcllib_nextlabelno;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4499;
L4497:
	asu64(R1) = labelmap;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L4501;
	R1 = 1;
	asu64(R2) = qq_pcllib_labelpctable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 11;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L4501:
	i += 1; if (i <= qq_pcllib_nextlabelno) goto L4497;
L4499:
	asi64(R1) = qq_pcllib_nextlabelno;
	asu64(R2) = labelmap;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = qq_pcllib_pcstart;
	asu64(R2) = pm;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = qq_pcllib_pccurr;
	asu64(R2) = pm;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = qq_pcllib_pcstart;
	asu64(R2) = qq_pcllib_pccurr;
	asi64(R1) = qq_lib_getpcloffset(asu64(R2), asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = pm;
	R3 = 72;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = qq_pcllib_pcsourcestart;
	asu64(R2) = pm;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_pclgen_do_procdef(u64 p) {
    u64 R1, R2, R3; 
	i64 nfreevars;
	i64 nnofreevars;
	i64 isfunc;
	u64 oldcurrproc;
	asu64(R1) = qq_decls_stcurrproc;
	oldcurrproc = asu64(R1);
	asu64(R1) = p;
	qq_decls_stcurrproc = asu64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	qq_pclgen_retindex = asi64(R1);
	asu64(R1) = p;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 4;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	isfunc = asi64(R1);
	R1 = (u64)&nnofreevars;
	R2 = (u64)&nfreevars;
	asu64(R3) = p;
	qq_pclgen_genprocentry(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4504;
	R1 = 0;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Empty proc body");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
	goto L4503;
L4504:
	asi64(R1) = isfunc;
	asu64(R2) = p;
	R3 = 88;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = isfunc;
	if (!asi64(R1)) goto L4506;
	asu64(R1) = p;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = qq_pclgen_checkblockreturn(asu64(R1));
	if (asi64(R1)) goto L4508;
	R1 = 0;
	R2 = tou64("Func: return value missing");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4508:
L4506:
L4503:
	asi64(R1) = qq_pclgen_retindex;
	qq_pcllib_definefwdlabel(asi64(R1));
	asi64(R1) = isfunc;
	asi64(R2) = nnofreevars;
	asi64(R3) = nfreevars;
	qq_pclgen_genprocexit(asi64(R3), asi64(R2), asi64(R1));
	R1 = 4;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = qq_pclgen_pprocentry;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4510;
	R1 = (u64)&qq_pclgen_pprocentry;
	(*tou64p(R1)) += 32;
L4510:
	asu64(R1) = qq_pclgen_pprocentry;
	asu64(R2) = p;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = oldcurrproc;
	qq_decls_stcurrproc = asu64(R1);
	return;
}

static void qq_pclgen_genprocentry(u64 p, u64 nfreevars, u64 nnofreevars) {
    u64 R1, R2, R3; 
	struct $B77 str;
	i64 n;
	u64 d;
	asu64(R1) = p;
	R2 = 2;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	R1 = 0;
	R2 = R1;
	qq_decls_nproclocals = asi64(R2);
	qq_pclgen_nprocparams = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L4513;
L4512:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4516;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L4517;
	goto L4518;
L4516:
	R1 = (u64)&qq_decls_nproclocals;
	(*toi64p(R1)) += 1;
	asi64(R1) = qq_decls_nproclocals;
	asu64(R2) = d;
	R3 = 96;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4515;
L4517:
	R1 = (u64)&qq_pclgen_nprocparams;
	(*toi64p(R1)) += 1;
	goto L4515;
L4518:
L4515:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L4513:
	asu64(R1) = d;
	if (asu64(R1)) goto L4512;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = qq_pclgen_nprocparams;
	n = asi64(R1);
	goto L4522;
L4519:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L4524;
	goto L4525;
L4524:
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R1) = -asi64(R1);
	asu64(R2) = d;
	R3 = 96;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4523;
L4525:
L4523:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L4522:
	asu64(R1) = d;
	if (asu64(R1)) goto L4519;
	asi64(R1) = qq_pclgen_nprocparams;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R1) = -asi64(R1);
	qq_pclgen_retvaloffset = asi64(R1);
	asi64(R1) = qq_decls_nproclocals;
	R2 = 3;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
	asu64(R1) = qq_pcllib_pccurr;
	qq_pclgen_pprocentry = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L4527;
L4526:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4530;
	goto L4531;
L4530:
	asu64(R1) = d;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4533;
	R1 = 1;
	asu64(R2) = d;
	R3 = 88;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
	R3 = 12;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4535;
	R1 = 27;
	qq_pcllib_genpc(asi64(R1));
L4535:
	asu64(R1) = d;
	R2 = 24;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
L4533:
	goto L4529;
L4531:
L4529:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L4527:
	asu64(R1) = d;
	if (asu64(R1)) goto L4526;
	return;
}

static void qq_pclgen_genprocexit(i64 nfree, i64 nnofree, i64 isfunc) {
    u64 R1, R2, R3; 
	i64 offset;
	asi64(R1) = isfunc;
	if (!asi64(R1)) goto L4538;
	asi64(R1) = qq_pclgen_nprocparams;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R1) = -asi64(R1);
	R2 = 16;
	asi64(R1) *= asi64(R2);
	offset = asi64(R1);
	asi64(R1) = offset;
	asi64(R2) = qq_decls_nproclocals;
	R3 = 53;
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = qq_pclgen_nprocparams;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4537;
L4538:
	asi64(R1) = qq_pclgen_nprocparams;
	R2 = 52;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
	asi64(R1) = qq_decls_nproclocals;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 12;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L4537:
	return;
}

static void qq_pclgen_evalref(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 a;
	u64 b;
	u64 c;
	u64 d;
	i64 lab1;
	i64 lab2;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L4541;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L4542;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L4543;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L4544;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L4545;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L4546;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L4547;
	goto L4548;
L4541:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4551;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L4550;
L4551:
	R1 = 0;
	R2 = tou64("^ not allowed");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4550:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L4553;
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L4553;
	asu64(R1) = d;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L4552;
L4553:
	asu64(R1) = d;
	R2 = 9;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
L4552:
	goto L4540;
L4542:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 104;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4555;
	R1 = 0;
	R2 = tou64(".m2?");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4555:
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 129;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L4540;
L4543:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 132;
	qq_pcllib_genpc(asi64(R1));
	goto L4540;
L4544:
	asu64(R1) = a;
	qq_pclgen_evalref(asu64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 138;
	qq_pcllib_genpc(asi64(R1));
	goto L4540;
L4545:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4557;
	R1 = 0;
	R2 = tou64("Def val not allowed");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4557:
	R1 = 135;
	qq_pcllib_genpc(asi64(R1));
	goto L4540;
L4546:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L4540;
L4547:
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab1 = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab1;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 33;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_pclgen_evalref(asu64(R1));
	asi64(R1) = lab2;
	qq_pclgen_genjumpl(asi64(R1));
	asi64(R1) = lab1;
	qq_pcllib_definefwdlabel(asi64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_pclgen_evalref(asu64(R1));
	asi64(R1) = lab2;
	qq_pcllib_definefwdlabel(asi64(R1));
	goto L4540;
L4548:
	R1 = 0;
	R2 = (u64)&qq_tables_jtagnames;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("evalref");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L4540:
	return;
}

static void qq_pclgen_genjumpcond(i64 opc, u64 p, i64 lab) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 r;
	u64 s;
	i64 oldpos;
	i64 lab2;
	i64 i;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L4560;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L4561;
	R2 = 74;
	if (asi64(R1) == asi64(R2)) goto L4562;
	R2 = 75;
	if (asi64(R1) == asi64(R2)) goto L4563;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4564;
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L4565;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L4566;
	goto L4567;
L4560:
	asi64(R1) = opc;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L4569;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L4570;
	goto L4571;
L4569:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 33;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 33;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L4568;
L4570:
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab2;
	asu64(R2) = q;
	R3 = 33;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 32;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab2;
	qq_pcllib_definefwdlabel(asi64(R1));
	goto L4568;
L4571:
L4568:
	goto L4559;
L4561:
	asi64(R1) = opc;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L4573;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L4574;
	goto L4575;
L4573:
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab2;
	asu64(R2) = q;
	R3 = 32;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 33;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab2;
	qq_pcllib_definefwdlabel(asi64(R1));
	goto L4572;
L4574:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 32;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 32;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L4572;
L4575:
L4572:
	goto L4559;
L4562:
	asi64(R1) = opc;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L4577;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L4578;
	goto L4579;
L4577:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 32;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L4576;
L4578:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 33;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L4576;
L4579:
L4576:
	goto L4559;
L4563:
	asi64(R1) = lab;
	asu64(R2) = q;
	asi64(R3) = opc;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L4559;
L4564:
	goto L4581;
L4580:
	R1 = 1;
	asu64(R2) = q;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L4581:
	asu64(R1) = q;
	if (!asu64(R1)) goto L4583;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L4580;
L4583:
	asi64(R1) = lab;
	asu64(R2) = q;
	asi64(R3) = opc;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L4559;
L4565:
	R1 = 1;
	asu64(R2) = q;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = r;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = opc;
	qq_pclgen_gcomparejump(asi64(R3), asi64(R2), asi64(R1));
	goto L4559;
L4566:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = opc;
	R2 = 33;
	if (asi64(R1) != asi64(R2)) goto L4585;
	goto L4587;
L4586:
	R1 = 1;
	asu64(R2) = q;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = r;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = lab;
	R2 = (u64)&qq_tables_revconds;
	asu64(R3) = p;
	R4 = 24;
	R3 += (i64)R4;
	asi64(R4) = i;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 32;
	qq_pclgen_gcomparejump(asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	asu64(R1) = r;
	q = asu64(R1);
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L4587:
	asu64(R1) = r;
	if (asu64(R1)) goto L4586;
	goto L4584;
L4585:
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab2 = asi64(R1);
	goto L4590;
L4589:
	R1 = 1;
	asu64(R2) = q;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = r;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4593;
	asi64(R1) = lab2;
	R2 = (u64)&qq_tables_revconds;
	asu64(R3) = p;
	R4 = 24;
	R3 += (i64)R4;
	asi64(R4) = i;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 32;
	qq_pclgen_gcomparejump(asi64(R3), asi64(R2), asi64(R1));
	goto L4592;
L4593:
	asi64(R1) = lab;
	asu64(R2) = p;
	R3 = 24;
	R2 += (i64)R3;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	R3 = 32;
	qq_pclgen_gcomparejump(asi64(R3), asi64(R2), asi64(R1));
L4592:
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	asu64(R1) = r;
	q = asu64(R1);
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L4590:
	asu64(R1) = r;
	if (asu64(R1)) goto L4589;
	asi64(R1) = lab2;
	qq_pcllib_definefwdlabel(asi64(R1));
L4584:
	goto L4559;
L4567:
	R1 = 1;
	asu64(R2) = p;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asi64(R2) = opc;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
L4559:
	asi64(R1) = oldpos;
	qq_decls_qpos = asi64(R1);
	return;
}

static void qq_pclgen_gcomparejump(i64 opc, i64 cond, i64 lab) {
    u64 R1, R2, R3; 
	asi64(R1) = opc;
	R2 = 33;
	if (asi64(R1) != asi64(R2)) goto L4596;
	R1 = (u64)&qq_tables_revconds;
	asi64(R2) = cond;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cond = asi64(R1);
L4596:
	asi64(R1) = lab;
	R2 = 34;
	asi64(R3) = cond;
	asi64(R2) += asi64(R3);
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	return;
}

static void qq_pclgen_genjumpl(i64 lab) {
    u64 R1, R2; 
	asi64(R1) = lab;
	R2 = 30;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	return;
}

static void qq_pclgen_stacklooplabels(i64 a, i64 b, i64 c) {
    u64 R1, R2, R3; 
	asi64(R1) = qq_pclgen_loopindex;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L4600;
	R1 = 0;
	R2 = tou64("Too many nested loops");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4600:
	R1 = (u64)&qq_pclgen_loopindex;
	(*toi64p(R1)) += 1;
	asi64(R1) = a;
	R2 = (u64)&qq_pclgen_loopstack;
	asi64(R3) = qq_pclgen_loopindex;
	R2 += (i64)R3*32-32;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&qq_pclgen_loopstack;
	asi64(R3) = qq_pclgen_loopindex;
	R2 += (i64)R3*32-32;
	R3 = 2;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = c;
	R2 = (u64)&qq_pclgen_loopstack;
	asi64(R3) = qq_pclgen_loopindex;
	R2 += (i64)R3*32-32;
	R3 = 3;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	return;
}

static void qq_pclgen_unstacklooplabels() {
    u64 R1; 
	R1 = (u64)&qq_pclgen_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static i64 qq_pclgen_findlooplabel(i64 k, i64 n) {
    u64 R1, R2, R3; 
	i64 i;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4604;
	R1 = 1;
	i = asi64(R1);
	goto L4603;
L4604:
	asi64(R1) = qq_pclgen_loopindex;
	asi64(R2) = n;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) -= asi64(R2);
	i = asi64(R1);
L4603:
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4607;
	asi64(R1) = i;
	asi64(R2) = qq_pclgen_loopindex;
	if (asi64(R1) <= asi64(R2)) goto L4606;
L4607:
	R1 = 0;
	R2 = tou64("Bad loop index");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4606:
	R1 = (u64)&qq_pclgen_trylevelstack;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	qq_pclgen_looptrylevel = asi64(R1);
	R1 = (u64)&qq_pclgen_loopstack;
	asi64(R2) = i;
	R1 += (i64)R2*32-32;
	asi64(R2) = k;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L4602;
L4602:
	return asi64(R1);
}

static void qq_pclgen_do_assign(u64 a, u64 b, i64 res, i64 deepcopy) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 n;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L4610;
	R2 = 88;
	if (asi64(R1) != asi64(R2)) goto L4610;
	asi64(R1) = res;
	if (!asi64(R1)) goto L4612;
	R1 = 0;
	R2 = tou64("mult/ass::=");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4612:
	asi64(R1) = res;
	asi64(R2) = deepcopy;
	asu64(R3) = b;
	asu64(R4) = a;
	qq_pclgen_do_multassign(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L4608;
L4610:
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = deepcopy;
	if (!asi64(R1)) goto L4614;
	R1 = 27;
	qq_pcllib_genpc(asi64(R1));
L4614:
	asi64(R1) = res;
	asu64(R2) = a;
	qq_pclgen_do_store(asu64(R2), asi64(R1));
L4608:
	return;
}

static void qq_pclgen_do_bin(u64 a, u64 b, i64 opc) {
    u64 R1, R2; 
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = opc;
	qq_pcllib_genpc(asi64(R1));
	return;
}

static void qq_pclgen_do_binref(u64 a, u64 b, i64 opc) {
    u64 R1, R2; 
	asu64(R1) = a;
	qq_pclgen_evalref(asu64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = opc;
	qq_pcllib_genpc(asi64(R1));
	return;
}

static void qq_pclgen_do_unary(u64 a, i64 opc) {
    u64 R1, R2; 
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = opc;
	qq_pcllib_genpc(asi64(R1));
	return;
}

static void qq_pclgen_do_unaryref(u64 a, i64 opc) {
    u64 R1; 
	asu64(R1) = a;
	qq_pclgen_evalref(asu64(R1));
	asi64(R1) = opc;
	qq_pcllib_genpc(asi64(R1));
	return;
}

static void qq_pclgen_do_pushlist(u64 a, i64 n) {
    u64 R1, R2; 
	goto L4623;
L4620:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L4623:
	asu64(R1) = a;
	if (asu64(R1)) goto L4620;
	return;
}

static void qq_pclgen_do_makedict(u64 a, i64 n) {
    u64 R1, R2, R3; 
	i64 av_1;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4627;
L4625:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L4629;
	R1 = 1;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = a;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L4628;
L4629:
	R1 = 0;
	R2 = tou64("dict not key:val");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4628:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	if (--asi64(av_1)) goto L4625;
L4627:
	R1 = 0;
	asi64(R2) = n;
	R3 = 68;
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	return;
}

static void qq_pclgen_do_call(u64 p, u64 a, u64 b, i64 res, u64 procflag) {
    u64 R1, R2, R3, R4; 
	i64 nargs;
	i64 nsimple;
	i64 isfunc;
	i64 kwdindex;
	u64 d;
	u64 c;
	struct $B27 arglist;
	i64 i;
	R1 = 1;
	isfunc = asi64(R1);
	R1 = 0;
	R2 = R1;
	nsimple = asi64(R2);
	nargs = asi64(R1);
	R1 = 0;
	kwdindex = asi64(R1);
	asu64(R1) = b;
	c = asu64(R1);
	goto L4632;
L4631:
	asu64(R1) = c;
	R2 = (u64)&arglist;
	R3 = (u64)&nargs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = c;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L4636;
	R2 = 42;
	if (asi64(R1) != asi64(R2)) goto L4635;
L4636:
	R1 = (u64)&nsimple;
	(*toi64p(R1)) += 1;
L4635:
	asu64(R1) = c;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4638;
	asi64(R1) = kwdindex;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4640;
	asi64(R1) = nargs;
	kwdindex = asi64(R1);
L4640:
	goto L4637;
L4638:
	asi64(R1) = kwdindex;
	if (!asi64(R1)) goto L4641;
	R1 = 0;
	R2 = tou64("Non-kwd follows kwd arg");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4641:
L4637:
	asu64(R1) = c;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	c = asu64(R1);
L4632:
	asu64(R1) = c;
	if (asu64(R1)) goto L4631;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L4643;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L4644;
	goto L4645;
L4643:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
// qq_pclgen.do_call.retry:
L4646:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4648;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4648;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L4649;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L4650;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L4651;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4651;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L4651;
	goto L4652;
L4648:
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 4;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L4654;
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
	asi64(R1) = kwdindex;
	asi64(R2) = nargs;
	R3 = (u64)&arglist;
	asu64(R4) = d;
	asi64(R1) = qq_pclgen_pushparams(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	nargs = asi64(R1);
	asu64(R1) = d;
	R2 = 50;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L4653;
L4654:
	R1 = 0;
	isfunc = asi64(R1);
	asi64(R1) = kwdindex;
	asi64(R2) = nargs;
	R3 = (u64)&arglist;
	asu64(R4) = d;
	asi64(R1) = qq_pclgen_pushparams(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	nargs = asi64(R1);
	asu64(R1) = d;
	R2 = 50;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
L4653:
	asi64(R1) = nargs;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4647;
L4649:
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 4;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L4656;
	R1 = 0;
	isfunc = asi64(R1);
	goto L4655;
L4656:
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
L4655:
	asi64(R1) = kwdindex;
	asi64(R2) = nargs;
	R3 = (u64)&arglist;
	asu64(R4) = d;
	asi64(R1) = qq_pclgen_pushparams(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	nargs = asi64(R1);
	asu64(R1) = d;
	R2 = 56;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asi64(R1) = nargs;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4647;
L4650:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L4646;
	goto L4647;
L4651:
	goto L4657;
	goto L4647;
L4652:
	R1 = 0;
	R2 = (u64)&qq_tables_namenames;
	asu64(R3) = d;
	R4 = 124;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("CAN'T CALL:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L4647:
	goto L4642;
L4644:
	asi64(R1) = kwdindex;
	if (!asi64(R1)) goto L4659;
	goto L4657;
L4659:
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_pclgen_evalref(asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nargs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4662;
L4660:
	R1 = 1;
	R2 = (u64)&arglist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	i += 1; if (i <= nargs) goto L4660;
L4662:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = (u64)&nargs;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 51;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
	goto L4642;
L4645:
// qq_pclgen.do_call.docallptr:
L4657:
	asi64(R1) = kwdindex;
	if (!asi64(R1)) goto L4664;
	R1 = 0;
	R2 = tou64("Kwd params not allowed for fnptr");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4664:
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nargs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4667;
L4665:
	R1 = 1;
	R2 = (u64)&arglist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	i += 1; if (i <= nargs) goto L4665;
L4667:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = nargs;
	R2 = 51;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
L4642:
	asi64(R1) = res;
	if (!asi64(R1)) goto L4669;
	asi64(R1) = isfunc;
	if (asi64(R1)) goto L4669;
	R1 = 0;
	R2 = tou64("Func ret value expected");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4669:
	asi64(R1) = isfunc;
	asi64(R1) = !asi64(R1);
	asu64(R2) = procflag;
	*toi64p(R2) = asi64(R1);
	return;
}

static i64 qq_pclgen_pushparams(u64 d, u64 arglist, i64 nargs, i64 kwdindex) {
    u64 R1, R2, R3, R4; 
	i64 nparams;
	i64 extra;
	i64 n;
	struct $B27 paramlist;
	struct $B5 byreflist;
	u64 e;
	u64 p;
	i64 i;
	asu64(R1) = d;
	R2 = 104;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	nparams = asi64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	goto L4672;
L4671:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asu64(R1) = e;
	R2 = (u64)&paramlist;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = e;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = (u64)&byreflist;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L4672:
	asu64(R1) = e;
	if (asu64(R1)) goto L4671;
	asi64(R1) = kwdindex;
	if (!asi64(R1)) goto L4675;
	asi64(R1) = kwdindex;
	asi64(R2) = nargs;
	asu64(R3) = arglist;
	asu64(R4) = d;
	qq_pclgen_pushkwdparams(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = d;
	R2 = 104;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	goto L4670;
L4675:
	R1 = 0;
	extra = asi64(R1);
	asi64(R1) = nargs;
	asi64(R2) = nparams;
	if (asi64(R1) != asi64(R2)) goto L4677;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nargs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4680;
L4678:
	R1 = (u64)&byreflist;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = arglist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_evalparam(asu64(R2), asi64(R1));
	i += 1; if (i <= nargs) goto L4678;
L4680:
	asi64(R1) = nargs;
	goto L4676;
L4677:
	asi64(R1) = nargs;
	asi64(R2) = nparams;
	if (asi64(R1) >= asi64(R2)) goto L4681;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nargs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4684;
L4682:
	R1 = (u64)&byreflist;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = arglist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_evalparam(asu64(R2), asi64(R1));
	i += 1; if (i <= nargs) goto L4682;
L4684:
	asi64(R1) = nargs;
	R2 = 1;
	asi64(R1) += asi64(R2);
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = nparams;
	if (asi64(R1) > asi64(R2)) goto L4687;
L4685:
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L4689;
	asu64(R1) = p;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L4689;
	R1 = 0;
	R2 = 0;
	asi64(R3) = i;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	R3 = tou64("Param not optional:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L4689:
	asu64(R1) = p;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4691;
	R1 = (u64)&byreflist;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L4693;
	R1 = 0;
	R2 = tou64("byref with default val");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4693:
	R1 = 1;
	asu64(R2) = p;
	R3 = 88;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L4690;
L4691:
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
L4690:
	i += 1; if (i <= nparams) goto L4685;
L4687:
	asi64(R1) = nparams;
	goto L4676;
L4681:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4696;
L4694:
	R1 = (u64)&byreflist;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = arglist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_evalparam(asu64(R2), asi64(R1));
	i += 1; if (i <= nparams) goto L4694;
L4696:
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 8;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L4698;
	R1 = 0;
	R2 = tou64("Too many args");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4698:
	asi64(R1) = nparams;
	R2 = 1;
	asi64(R1) += asi64(R2);
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = nargs;
	if (asi64(R1) > asi64(R2)) goto L4701;
L4699:
	R1 = 1;
	asu64(R2) = arglist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	i += 1; if (i <= nargs) goto L4699;
L4701:
	asi64(R1) = nargs;
L4676:
	goto L4670;
L4670:
	return asi64(R1);
}

static void qq_pclgen_evalparam(u64 a, i64 byref) {
    u64 R1, R2; 
	asi64(R1) = byref;
	if (!asi64(R1)) goto L4704;
	asu64(R1) = a;
	qq_pclgen_evalref(asu64(R1));
	goto L4703;
L4704:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
L4703:
	return;
}

static void qq_pclgen_pushkwdparams(u64 d, u64 arglist, i64 nargs, i64 kwdindex) {
    u64 R1, R2, R3; 
	i64 nparams;
	i64 i;
	i64 j;
	i64 k;
	struct $B27 paramlist;
	struct $B5 byreflist;
	struct $B27 keyunits;
	u64 p;
	u64 q;
	u64 e;
	i64 av_1;
	asu64(R1) = d;
	R2 = 104;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	nparams = asi64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4708;
L4706:
	asu64(R1) = e;
	R2 = (u64)&paramlist;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = e;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = (u64)&byreflist;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	i += 1; if (i <= nparams) goto L4706;
L4708:
	asi64(R1) = nargs;
	asi64(R2) = nparams;
	if (asi64(R1) <= asi64(R2)) goto L4710;
	R1 = 0;
	R2 = tou64("Too many args");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4710:
	asi64(R1) = kwdindex;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = nparams;
	if (asi64(R1) > asi64(R2)) goto L4713;
L4711:
	R1 = 0;
	R2 = (u64)&keyunits;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= nparams) goto L4711;
L4713:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = kwdindex;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4716;
L4714:
	R1 = (u64)&byreflist;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = arglist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_evalparam(asu64(R2), asi64(R1));
	i += 1; if (i <= av_1) goto L4714;
L4716:
	asi64(R1) = kwdindex;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = nargs;
	if (asi64(R1) > asi64(R2)) goto L4719;
L4717:
	asu64(R1) = arglist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L4721;
	R1 = 0;
	R2 = tou64("kwd not a name");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4721:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	k = asi64(R1);
	R1 = 1;
	j = asi64(R1);
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4724;
L4722:
	R1 = (u64)&paramlist;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4726;
	asi64(R1) = j;
	k = asi64(R1);
	goto L4724;
L4726:
	j += 1; if (j <= nparams) goto L4722;
L4724:
	asi64(R1) = k;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4728;
	R1 = 0;
	asu64(R2) = e;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Can't find kwd param:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L4728:
	asi64(R1) = k;
	asi64(R2) = kwdindex;
	if (asi64(R1) >= asi64(R2)) goto L4730;
	R1 = 0;
	asu64(R2) = e;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Kwd arg already positional:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L4730:
	R1 = (u64)&keyunits;
	asi64(R2) = k;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	if (!asu64(R1)) goto L4732;
	R1 = 0;
	asu64(R2) = e;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Repeating kwd arg:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L4732:
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&keyunits;
	asi64(R3) = k;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= nargs) goto L4717;
L4719:
	asi64(R1) = kwdindex;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = nparams;
	if (asi64(R1) > asi64(R2)) goto L4735;
L4733:
	R1 = (u64)&keyunits;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4737;
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4739;
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L4739;
	R1 = 0;
	R2 = 0;
	asi64(R3) = i;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	R3 = tou64("Param not optional:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L4739:
	asu64(R1) = q;
	R2 = (u64)&keyunits;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4737:
	i += 1; if (i <= nparams) goto L4733;
L4735:
	asi64(R1) = kwdindex;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = nparams;
	if (asi64(R1) > asi64(R2)) goto L4742;
L4740:
	R1 = (u64)&keyunits;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	if (!asu64(R1)) goto L4744;
	R1 = (u64)&byreflist;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&keyunits;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_evalparam(asu64(R2), asi64(R1));
	goto L4743;
L4744:
	R1 = (u64)&byreflist;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L4745;
	R1 = 0;
	R2 = tou64("byref param not optional");
	qq_lib_gerror(asu64(R2), asu64(R1));
	goto L4743;
L4745:
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
L4743:
	i += 1; if (i <= nparams) goto L4740;
L4742:
	return;
}

static void qq_pclgen_do_if(u64 p, u64 a, u64 b, u64 pelse, i64 res) {
    u64 R1, R2, R3; 
	i64 lab1;
	i64 lab2;
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab1 = asi64(R1);
	asu64(R1) = pelse;
	if (asu64(R1)) goto L4749;
	asi64(R1) = res;
	if (!asi64(R1)) goto L4748;
L4749:
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab2 = asi64(R1);
L4748:
	asi64(R1) = lab1;
	asu64(R2) = a;
	R3 = 33;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = res;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = pelse;
	if (asu64(R1)) goto L4752;
	asi64(R1) = res;
	if (!asi64(R1)) goto L4751;
L4752:
	asi64(R1) = lab2;
	qq_pclgen_genjumpl(asi64(R1));
	asi64(R1) = lab1;
	qq_pcllib_definefwdlabel(asi64(R1));
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L4754;
	asi64(R1) = res;
	asu64(R2) = pelse;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L4753;
L4754:
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
L4753:
	asi64(R1) = lab2;
	qq_pcllib_definefwdlabel(asi64(R1));
	goto L4750;
L4751:
	asi64(R1) = lab1;
	qq_pcllib_definefwdlabel(asi64(R1));
L4750:
	return;
}

static void qq_pclgen_do_do(u64 p, u64 a) {
    u64 R1, R2, R3; 
	i64 lab_abc;
	i64 lab_d;
	i64 lab_test;
	asi64(R1) = qq_pcllib_definelabel();
	lab_abc = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_abc;
	asi64(R3) = lab_abc;
	qq_pclgen_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = lab_abc;
	qq_pclgen_genjumpl(asi64(R1));
	asi64(R1) = lab_d;
	qq_pcllib_definefwdlabel(asi64(R1));
	qq_pclgen_unstacklooplabels();
	return;
}

static void qq_pclgen_do_loop(u64 p) {
    u64 R1, R2, R3; 
	i64 n;
	i64 index;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	index = asi64(R1);
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4758;
	asi64(R1) = qq_pclgen_loopindex;
	index = asi64(R1);
L4758:
	asi64(R1) = index;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) = qq_pclgen_findlooplabel(asi64(R2), asi64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4760;
	msysc_m$print_startcon();
	R1 = tou64("BAD LOOP");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L4759;
L4760:
	asi64(R1) = n;
	qq_pclgen_genjumpl(asi64(R1));
L4759:
	return;
}

static void qq_pclgen_do_to(u64 p, u64 pcount, u64 pbody) {
    u64 R1, R2, R3, R4; 
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	u64 temp;
	u64 pav;
	asu64(R1) = pcount;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pav = asu64(R1);
	asu64(R1) = pav;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	temp = asu64(R1);
	R1 = 1;
	asu64(R2) = pcount;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = temp;
	R2 = 24;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_b = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_b;
	qq_pclgen_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pcount;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L4763;
	asu64(R1) = temp;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	R1 = 0;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	asi64(R1) = lab_d;
	R2 = 37;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	goto L4762;
L4763:
	asu64(R1) = pcount;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L4764;
	asi64(R1) = lab_d;
	R2 = 30;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
L4764:
L4762:
	asi64(R1) = lab_b;
	qq_pcllib_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R2) = pbody;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = lab_c;
	qq_pcllib_definefwdlabel(asi64(R1));
	asi64(R1) = lab_b;
	R2 = 44;
	asu64(R3) = temp;
	R4 = 120;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 9;
    asi64(R3) = Getdotindex(asu64(R3), asi64(R4));
	asi64(R2) += asi64(R3);
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	asu64(R1) = temp;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asi64(R1) = lab_d;
	qq_pcllib_definefwdlabel(asi64(R1));
	qq_pclgen_unstacklooplabels();
	return;
}

static void qq_pclgen_do_while(u64 p, u64 pcond, u64 pbody) {
    u64 R1, R2, R3; 
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	i64 lab_incr;
	u64 pincr;
	asu64(R1) = pcond;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pincr = asu64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_b = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_d = asi64(R1);
	asu64(R1) = pincr;
	if (!asu64(R1)) goto L4767;
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_incr = asi64(R1);
	goto L4766;
L4767:
	asi64(R1) = lab_c;
	lab_incr = asi64(R1);
L4766:
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_b;
	qq_pclgen_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = lab_incr;
	qq_pclgen_genjumpl(asi64(R1));
	asi64(R1) = lab_b;
	qq_pcllib_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R2) = pbody;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = lab_c;
	qq_pcllib_definefwdlabel(asi64(R1));
	asu64(R1) = pincr;
	if (!asu64(R1)) goto L4769;
	R1 = 1;
	asu64(R2) = pincr;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = lab_incr;
	qq_pcllib_definefwdlabel(asi64(R1));
L4769:
	asi64(R1) = lab_b;
	asu64(R2) = pcond;
	R3 = 32;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab_d;
	qq_pcllib_definefwdlabel(asi64(R1));
	R1 = (u64)&qq_pclgen_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void qq_pclgen_do_repeat(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	asi64(R1) = qq_pcllib_definelabel();
	lab_b = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_b;
	qq_pclgen_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = lab_c;
	qq_pcllib_definefwdlabel(asi64(R1));
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L4773;
	asu64(R1) = b;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4772;
L4773:
	asi64(R1) = lab_b;
	asu64(R2) = b;
	R3 = 33;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
L4772:
	asi64(R1) = lab_d;
	qq_pcllib_definefwdlabel(asi64(R1));
	R1 = (u64)&qq_pclgen_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void qq_pclgen_do_for(u64 p, u64 pvar, u64 pbody) {
    u64 R1, R2, R3; 
	u64 pfrom;
	u64 pto;
	u64 pstep;
	u64 pelse;
	u64 plimit;
	u64 pautovar;
	u64 dvar;
	u64 limitvar;
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	i64 lab_e;
	i64 opc;
	i64 oldqpos;
	i64 step;
	i64 fromval;
	i64 limit;
	i64 jumpinto;
	asu64(R1) = pvar;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pfrom = asu64(R1);
	asu64(R1) = pfrom;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pto = asu64(R1);
	asu64(R1) = pto;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pstep = asu64(R1);
	R1 = 0;
	pautovar = asu64(R1);
	asu64(R1) = pstep;
	if (!asu64(R1)) goto L4776;
	R1 = 0;
	R2 = tou64("By N not implem");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4776:
	asu64(R1) = pbody;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pelse = asu64(R1);
	asu64(R1) = pvar;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dvar = asu64(R1);
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L4780;
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L4779;
L4780:
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L4778;
	asu64(R1) = pto;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = dvar;
	R3 = 120;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	if (asu64(R1) == asu64(R2)) goto L4778;
L4779:
	asu64(R1) = qq_decls_stcurrproc;
	asu64(R1) = qq_lib_createavnamex(asu64(R1));
	pautovar = asu64(R1);
L4778:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4782;
	R1 = -1;
	step = asi64(R1);
	goto L4781;
L4782:
	R1 = 1;
	step = asi64(R1);
L4781:
	R1 = 1;
	jumpinto = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_b = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_d = asi64(R1);
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L4784;
	asi64(R1) = qq_pcllib_createfwdlabel();
	goto L4783;
L4784:
	asi64(R1) = lab_d;
L4783:
	lab_e = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_b;
	qq_pclgen_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pfrom;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L4786;
	asu64(R1) = pfrom;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	fromval = asi64(R1);
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L4788;
	asu64(R1) = pto;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	limit = asi64(R1);
	asi64(R1) = step;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L4792;
	asi64(R1) = fromval;
	asi64(R2) = limit;
	if (asi64(R1) >= asi64(R2)) goto L4791;
L4792:
	asi64(R1) = step;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4790;
	asi64(R1) = fromval;
	asi64(R2) = limit;
	if (asi64(R1) > asi64(R2)) goto L4790;
L4791:
	R1 = 0;
	jumpinto = asi64(R1);
L4790:
L4788:
	asi64(R1) = jumpinto;
	if (!asi64(R1)) goto L4794;
	asi64(R1) = step;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L4796;
	R1 = (u64)&fromval;
	(*toi64p(R1)) += 1;
	goto L4795;
L4796:
	R1 = (u64)&fromval;
	(*toi64p(R1)) -=1;
L4795:
	asi64(R1) = fromval;
	asu64(R2) = pfrom;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L4794:
	asu64(R1) = pfrom;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	asu64(R1) = dvar;
	R2 = 12;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L4785;
L4786:
	R1 = 1;
	asu64(R2) = pfrom;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = dvar;
	R2 = 12;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asu64(R1) = dvar;
	R2 = 71;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asi64(R1) = step;
	asi64(R1) = -asi64(R1);
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 12;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L4785:
	asu64(R1) = pautovar;
	if (!asu64(R1)) goto L4798;
	R1 = 1;
	asu64(R2) = pto;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = pautovar;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	limitvar = asu64(R1);
	asu64(R1) = limitvar;
	R2 = 24;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asu64(R1) = pautovar;
	pto = asu64(R1);
	goto L4797;
L4798:
	asu64(R1) = pto;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	limitvar = asu64(R1);
L4797:
	asi64(R1) = jumpinto;
	if (!asi64(R1)) goto L4800;
	asi64(R1) = lab_c;
	qq_pclgen_genjumpl(asi64(R1));
L4800:
	asi64(R1) = lab_b;
	qq_pcllib_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R2) = pbody;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = lab_c;
	qq_pcllib_definefwdlabel(asi64(R1));
	asi64(R1) = step;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4802;
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L4804;
	R1 = 46;
	asu64(R2) = dvar;
	R3 = 120;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	asi64(R1) += asi64(R2);
	opc = asi64(R1);
	goto L4803;
L4804:
	asu64(R1) = dvar;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = limitvar;
	R3 = 120;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	if (asu64(R1) != asu64(R2)) goto L4805;
	R1 = 48;
	asu64(R2) = dvar;
	R3 = 120;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	asi64(R1) += asi64(R2);
	opc = asi64(R1);
	goto L4803;
L4805:
	R1 = 0;
	R2 = tou64("for:mixed m/f vars");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4803:
	asi64(R1) = qq_decls_qpos;
	oldqpos = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	qq_decls_qpos = asi64(R1);
	asi64(R1) = lab_b;
	asi64(R2) = opc;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	asi64(R1) = oldqpos;
	qq_decls_qpos = asi64(R1);
	asu64(R1) = dvar;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L4807;
	asu64(R1) = pto;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	goto L4806;
L4807:
	asu64(R1) = limitvar;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
L4806:
	goto L4801;
L4802:
	asu64(R1) = dvar;
	R2 = 71;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	R1 = -1;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 12;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = dvar;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L4809;
	asu64(R1) = pto;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	goto L4808;
L4809:
	asu64(R1) = limitvar;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
L4808:
	asi64(R1) = lab_b;
	R2 = 38;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
L4801:
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L4811;
	asi64(R1) = lab_e;
	qq_pcllib_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R2) = pelse;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
L4811:
	asi64(R1) = lab_d;
	qq_pcllib_definefwdlabel(asi64(R1));
	qq_pclgen_unstacklooplabels();
	return;
}

static void qq_pclgen_do_forx(u64 p, u64 pvar, u64 pbody) {
    u64 R1, R2, R3, R4; 
	u64 pbounds;
	u64 pelse;
	u64 plimit;
	u64 pautovar;
	u64 dvar;
	u64 limitvar;
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	i64 lab_e;
	i64 opc;
	msysc_m$print_startcon();
	R1 = tou64("FORX");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = pvar;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pbounds = asu64(R1);
	asu64(R1) = qq_decls_stcurrproc;
	asu64(R1) = qq_lib_createavnamex(asu64(R1));
	pautovar = asu64(R1);
	asu64(R1) = pbody;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pelse = asu64(R1);
	asu64(R1) = pvar;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dvar = asu64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_b = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_d = asi64(R1);
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L4814;
	asi64(R1) = qq_pcllib_createfwdlabel();
	goto L4813;
L4814:
	asi64(R1) = lab_d;
L4813:
	lab_e = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_b;
	qq_pclgen_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = pbounds;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = pautovar;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	limitvar = asu64(R1);
	asu64(R1) = limitvar;
	R2 = 24;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	R1 = 1;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	R1 = 102;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = dvar;
	R2 = 12;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asi64(R1) = lab_c;
	qq_pclgen_genjumpl(asi64(R1));
	asi64(R1) = lab_b;
	qq_pcllib_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R2) = pbody;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = lab_c;
	qq_pcllib_definefwdlabel(asi64(R1));
	asu64(R1) = dvar;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = limitvar;
	R3 = 120;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	if (asu64(R1) != asu64(R2)) goto L4816;
	asi64(R1) = lab_b;
	R2 = 48;
	asu64(R3) = dvar;
	R4 = 120;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 9;
    asi64(R3) = Getdotindex(asu64(R3), asi64(R4));
	asi64(R2) += asi64(R3);
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	goto L4815;
L4816:
	R1 = 0;
	R2 = tou64("forx:mixed m/f");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4815:
	asu64(R1) = dvar;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asu64(R1) = limitvar;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L4818;
	asi64(R1) = lab_e;
	qq_pcllib_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R2) = pelse;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
L4818:
	asi64(R1) = lab_d;
	qq_pcllib_definefwdlabel(asi64(R1));
	qq_pclgen_unstacklooplabels();
	return;
}

static void qq_pclgen_do_print(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 issprint;
	u64 x;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	asi64(R1) &= asi64(R2);
	issprint = asi64(R1);
	asi64(R1) = issprint;
	if (!asi64(R1)) goto L4821;
	R1 = 0;
	R2 = 3;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	goto L4820;
L4821:
	asu64(R1) = a;
	if (!asu64(R1)) goto L4823;
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	goto L4822;
L4823:
	R1 = 0;
	R2 = 2;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
L4822:
L4820:
	asu64(R1) = b;
	x = asu64(R1);
	goto L4825;
L4824:
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L4828;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L4829;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L4830;
	goto L4831;
L4828:
	R1 = 1;
	asu64(R2) = x;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = x;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 7;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	goto L4827;
L4829:
	R1 = 0;
	R2 = 10;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	goto L4827;
L4830:
	R1 = 0;
	R2 = 11;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	goto L4827;
L4831:
	R1 = 1;
	asu64(R2) = x;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 8;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
L4827:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
L4825:
	asu64(R1) = x;
	if (asu64(R1)) goto L4824;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4833;
	R1 = 0;
	R2 = 9;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
L4833:
	asi64(R1) = issprint;
	if (!asi64(R1)) goto L4835;
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
	R1 = 0;
	R2 = 6;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	goto L4834;
L4835:
	R1 = 0;
	R2 = 5;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
L4834:
	return;
}

static void qq_pclgen_do_fprint(u64 p, u64 a, u64 b, u64 c) {
    u64 R1, R2, R3; 
	i64 issfprint;
	u64 x;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	asi64(R1) &= asi64(R2);
	issfprint = asi64(R1);
	asi64(R1) = issfprint;
	if (!asi64(R1)) goto L4838;
	R1 = 0;
	R2 = 3;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	goto L4837;
L4838:
	asu64(R1) = a;
	if (!asu64(R1)) goto L4840;
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	goto L4839;
L4840:
	R1 = 0;
	R2 = 2;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
L4839:
L4837:
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 4;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	asu64(R1) = c;
	x = asu64(R1);
	goto L4842;
L4841:
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L4845;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L4846;
	goto L4847;
L4845:
	R1 = 1;
	asu64(R2) = x;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = x;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 7;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	goto L4844;
L4846:
	R1 = 0;
	R2 = 10;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	goto L4844;
L4847:
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
	R1 = 1;
	asu64(R2) = x;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 7;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
L4844:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
L4842:
	asu64(R1) = x;
	if (asu64(R1)) goto L4841;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4849;
	R1 = 0;
	R2 = 9;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
L4849:
	asi64(R1) = issfprint;
	if (!asi64(R1)) goto L4851;
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
	R1 = 0;
	R2 = 6;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	goto L4850;
L4851:
	R1 = 0;
	R2 = 5;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
L4850:
	return;
}

static void qq_pclgen_do_read(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 x;
	u64 xloop;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4854;
	asu64(R1) = a;
	if (!asu64(R1)) goto L4856;
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 12;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	goto L4855;
L4856:
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
	R1 = 0;
	R2 = 12;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
L4855:
L4854:
	asu64(R1) = b;
	xloop = asu64(R1);
	goto L4858;
L4857:
	asu64(R1) = xloop;
	x = asu64(R1);
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 58;
	if (asi64(R1) != asi64(R2)) goto L4861;
	R1 = 1;
	asu64(R2) = x;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 14;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	asu64(R1) = x;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	goto L4860;
L4861:
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
	R1 = 0;
	R2 = 14;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
L4860:
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L4863;
	asu64(R1) = x;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 12;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L4862;
L4863:
	asu64(R1) = x;
	qq_pclgen_evalref(asu64(R1));
	R1 = 23;
	qq_pcllib_genpc(asi64(R1));
L4862:
	asu64(R1) = xloop;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	xloop = asu64(R1);
L4858:
	asu64(R1) = xloop;
	if (asu64(R1)) goto L4857;
	return;
}

static void qq_pclgen_do_forall(u64 p, u64 pindex, u64 pbody) {
    u64 R1, R2, R3, R4; 
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	i64 lab_e;
	u64 ploopvar;
	u64 plist;
	u64 pelse;
	u64 plimitvar;
	u64 plistvar;
	u64 indexvar;
	u64 limitvar;
	u64 loopvar;
	u64 listvar;
	asu64(R1) = pindex;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	plist = asu64(R1);
	asu64(R1) = plist;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ploopvar = asu64(R1);
	asu64(R1) = ploopvar;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4866;
	asu64(R1) = pindex;
	ploopvar = asu64(R1);
	asu64(R1) = qq_decls_stcurrproc;
	asu64(R1) = qq_lib_createavnamex(asu64(R1));
	pindex = asu64(R1);
L4866:
	asu64(R1) = ploopvar;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	loopvar = asu64(R1);
	asu64(R1) = qq_decls_stcurrproc;
	asu64(R1) = qq_lib_createavnamex(asu64(R1));
	plimitvar = asu64(R1);
	asu64(R1) = plimitvar;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	limitvar = asu64(R1);
	asu64(R1) = pindex;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	indexvar = asu64(R1);
	asu64(R1) = plist;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L4869;
	asu64(R1) = plist;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = loopvar;
	R3 = 120;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	if (asu64(R1) == asu64(R2)) goto L4868;
L4869:
	asu64(R1) = qq_decls_stcurrproc;
	asu64(R1) = qq_lib_createavnamex(asu64(R1));
	plistvar = asu64(R1);
	asu64(R1) = plistvar;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	listvar = asu64(R1);
	R1 = 1;
	asu64(R2) = plist;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = listvar;
	R2 = 24;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L4867;
L4868:
	asu64(R1) = plist;
	plistvar = asu64(R1);
	asu64(R1) = plistvar;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	listvar = asu64(R1);
L4867:
	asu64(R1) = indexvar;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = loopvar;
	R3 = 120;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asu64(R1) != asu64(R2)) goto L4872;
	asu64(R2) = listvar;
	R3 = 120;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	if (asu64(R1) == asu64(R2)) goto L4871;
L4872:
	R1 = 0;
	R2 = tou64("forall: mixed vars");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4871:
	asu64(R1) = pbody;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pelse = asu64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_b = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_d = asi64(R1);
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L4874;
	asi64(R1) = qq_pcllib_createfwdlabel();
	goto L4873;
L4874:
	asi64(R1) = lab_d;
L4873:
	lab_e = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_b;
	qq_pclgen_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = listvar;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	R1 = 2;
	R2 = 90;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
	asu64(R1) = limitvar;
	R2 = 24;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	R1 = 1;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	R1 = 102;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = indexvar;
	R2 = 24;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asi64(R1) = lab_c;
	qq_pclgen_genjumpl(asi64(R1));
	asi64(R1) = lab_b;
	qq_pcllib_definefwdlabel(asi64(R1));
	asu64(R1) = listvar;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = pindex;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L4876;
	R1 = 130;
	goto L4875;
L4876:
	R1 = 136;
L4875:
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = loopvar;
	R2 = 12;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = pbody;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = lab_c;
	qq_pcllib_definefwdlabel(asi64(R1));
	asu64(R1) = indexvar;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = limitvar;
	R3 = 120;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	if (asu64(R1) != asu64(R2)) goto L4878;
	asi64(R1) = lab_b;
	R2 = 48;
	asu64(R3) = indexvar;
	R4 = 120;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 9;
    asi64(R3) = Getdotindex(asu64(R3), asi64(R4));
	asi64(R2) += asi64(R3);
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	goto L4877;
L4878:
	R1 = 0;
	R2 = tou64("forall:mixed m/f");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4877:
	asu64(R1) = indexvar;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asu64(R1) = limitvar;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L4880;
	asi64(R1) = lab_e;
	qq_pcllib_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R2) = pelse;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
L4880:
	asi64(R1) = lab_d;
	qq_pcllib_definefwdlabel(asi64(R1));
	qq_pclgen_unstacklooplabels();
	return;
}

static void qq_pclgen_do_case(u64 p, u64 pindex, u64 pwhenthen, i64 res) {
    u64 R1, R2, R3, R4; 
	i64 lab_a;
	i64 lab_d;
	i64 loopsw;
	i64 labnextwhen;
	i64 labstmtstart;
	i64 fmult;
	u64 w;
	u64 wt;
	u64 pelse;
	asu64(R1) = pindex;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4883;
	asi64(R1) = res;
	asu64(R2) = pwhenthen;
	asu64(R3) = pindex;
	asu64(R4) = p;
	qq_pclgen_do_case_nc(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L4881;
L4883:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L4884;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4885;
L4884:
	R1 = 1;
	goto L4886;
L4885:
	R1 = 0;
L4886:
	loopsw = asi64(R1);
	asu64(R1) = pindex;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pelse = asu64(R1);
	asi64(R1) = loopsw;
	if (!asi64(R1)) goto L4888;
	asi64(R1) = qq_pcllib_definelabel();
	lab_a = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_a;
	asi64(R3) = lab_a;
	qq_pclgen_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	goto L4887;
L4888:
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_d = asi64(R1);
L4887:
	R1 = 1;
	asu64(R2) = pindex;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = pwhenthen;
	wt = asu64(R1);
	goto L4890;
L4889:
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = asu64(R1)  !=  asu64(R2);
	fmult = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	labnextwhen = asi64(R1);
	asi64(R1) = fmult;
	if (!asi64(R1)) goto L4893;
	asi64(R1) = qq_pcllib_createfwdlabel();
	labstmtstart = asi64(R1);
L4893:
	goto L4895;
L4894:
	R1 = 1;
	asu64(R2) = w;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	asu64(R1) = w;
	if (!asu64(R1)) goto L4898;
	asi64(R1) = labstmtstart;
	R2 = 40;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	goto L4897;
L4898:
	asi64(R1) = labnextwhen;
	R2 = 41;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
L4897:
L4895:
	asu64(R1) = w;
	if (asu64(R1)) goto L4894;
	asi64(R1) = fmult;
	if (!asi64(R1)) goto L4900;
	asi64(R1) = labstmtstart;
	qq_pcllib_definefwdlabel(asi64(R1));
L4900:
	asi64(R1) = res;
	asu64(R2) = wt;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = loopsw;
	if (asi64(R1)) goto L4902;
	asi64(R1) = lab_d;
	qq_pclgen_genjumpl(asi64(R1));
	goto L4901;
L4902:
	asi64(R1) = lab_a;
	qq_pclgen_genjumpl(asi64(R1));
L4901:
	asi64(R1) = labnextwhen;
	qq_pcllib_definefwdlabel(asi64(R1));
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L4890:
	asu64(R1) = wt;
	if (asu64(R1)) goto L4889;
	R1 = 1;
	R2 = 58;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L4904;
	asi64(R1) = res;
	asu64(R2) = pelse;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L4903;
L4904:
	asi64(R1) = res;
	if (!asi64(R1)) goto L4905;
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
L4905:
L4903:
	asi64(R1) = loopsw;
	if (!asi64(R1)) goto L4907;
	asi64(R1) = lab_a;
	qq_pclgen_genjumpl(asi64(R1));
	asi64(R1) = lab_d;
	qq_pcllib_definefwdlabel(asi64(R1));
	qq_pclgen_unstacklooplabels();
	goto L4906;
L4907:
	asi64(R1) = lab_d;
	qq_pcllib_definefwdlabel(asi64(R1));
L4906:
L4881:
	return;
}

static void qq_pclgen_do_case_nc(u64 p, u64 pindex, u64 pwhenthen, i64 res) {
    u64 R1, R2, R3; 
	i64 lab_a;
	i64 lab_d;
	i64 labnextwhen;
	i64 labstmtstart;
	i64 fmult;
	u64 w;
	u64 wt;
	u64 pelse;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4910;
	R1 = 0;
	R2 = tou64("case-nc");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4910:
	asu64(R1) = pindex;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pelse = asu64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_d = asi64(R1);
	asu64(R1) = pwhenthen;
	wt = asu64(R1);
	goto L4912;
L4911:
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = asu64(R1)  !=  asu64(R2);
	fmult = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	labnextwhen = asi64(R1);
	asi64(R1) = fmult;
	if (!asi64(R1)) goto L4915;
	asi64(R1) = qq_pcllib_createfwdlabel();
	labstmtstart = asi64(R1);
L4915:
	goto L4917;
L4916:
	R1 = 1;
	asu64(R2) = w;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	asu64(R1) = w;
	if (!asu64(R1)) goto L4920;
	asi64(R1) = labstmtstart;
	R2 = 32;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	goto L4919;
L4920:
	asi64(R1) = labnextwhen;
	R2 = 33;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
L4919:
L4917:
	asu64(R1) = w;
	if (asu64(R1)) goto L4916;
	asi64(R1) = fmult;
	if (!asi64(R1)) goto L4922;
	asi64(R1) = labstmtstart;
	qq_pcllib_definefwdlabel(asi64(R1));
L4922:
	asi64(R1) = res;
	asu64(R2) = wt;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = lab_d;
	qq_pclgen_genjumpl(asi64(R1));
	asi64(R1) = labnextwhen;
	qq_pcllib_definefwdlabel(asi64(R1));
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L4912:
	asu64(R1) = wt;
	if (asu64(R1)) goto L4911;
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L4924;
	asi64(R1) = res;
	asu64(R2) = pelse;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L4923;
L4924:
	asi64(R1) = res;
	if (!asi64(R1)) goto L4925;
	R1 = 0;
	R2 = tou64("Needs Else branch");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4925:
L4923:
	asi64(R1) = lab_d;
	qq_pcllib_definefwdlabel(asi64(R1));
	return;
}

static void qq_pclgen_do_try(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 labend;
	i64 labx;
	u64 ptry;
	u64 x;
	u64 pexcept;
	u64 pexcode;
	R1 = (u64)&qq_pclgen_trylevel;
	(*toi64p(R1)) += 1;
	asi64(R1) = qq_pcllib_createfwdlabel();
	labend = asi64(R1);
	asu64(R1) = a;
	ptry = asu64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	labx = asi64(R1);
	asu64(R1) = b;
	pexcept = asu64(R1);
	asu64(R1) = pexcept;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4928;
	R1 = 0;
	R2 = tou64("try: no except");
	qq_lib_gerror(asu64(R2), asu64(R1));
	goto L4927;
L4928:
	asu64(R1) = pexcept;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4929;
	R1 = 0;
	R2 = tou64("Try:multiple except block not implemented");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4929:
L4927:
	goto L4931;
L4930:
	asu64(R1) = pexcept;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pexcode = asu64(R1);
	asu64(R1) = pexcode;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L4935;
	asu64(R1) = pexcode;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4934;
L4935:
	R1 = 0;
	R2 = tou64("Try:multiple except codes not implemented");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4934:
	asi64(R1) = labx;
	R2 = 140;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = pexcode;
	asi64(R2) = qq_pclgen_getconstvalue(asu64(R2));
	qq_pcllib_genxy(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = ptry;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = labend;
	qq_pclgen_genjumpl(asi64(R1));
	asi64(R1) = labx;
	qq_pcllib_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R2) = pexcept;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = labend;
	qq_pcllib_definefwdlabel(asi64(R1));
	asu64(R1) = pexcept;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pexcept = asu64(R1);
L4931:
	asu64(R1) = pexcept;
	if (asu64(R1)) goto L4930;
	R1 = 1;
	R2 = 59;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
	R1 = (u64)&qq_pclgen_trylevel;
	(*toi64p(R1)) -=1;
	return;
}

static i64 qq_pclgen_unitstoarray(u64 p, u64 plist, i64 maxunits) {
    u64 R1, R2, R3; 
	i64 n;
	R1 = 0;
	n = asi64(R1);
	goto L4938;
L4937:
	asi64(R1) = n;
	asi64(R2) = maxunits;
	if (asi64(R1) < asi64(R2)) goto L4941;
	R1 = 0;
	R2 = tou64("UTA Too many units");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4941:
	asu64(R1) = p;
	asu64(R2) = plist;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L4938:
	asu64(R1) = p;
	if (asu64(R1)) goto L4937;
	asi64(R1) = n;
	goto L4936;
L4936:
	return asi64(R1);
}

static void qq_pclgen_do_select(u64 pindex, u64 pplist, i64 res) {
    u64 R1, R2, R3; 
	i64 n;
	i64 labend;
	i64 i;
	i64 lab;
	i64 elselab;
	u64 x;
	u64 pelse;
	struct $B4 plist;
	struct $B75 labels;
	asu64(R1) = pindex;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pelse = asu64(R1);
	R1 = 512;
	R2 = (u64)&plist;
	asu64(R3) = pplist;
	asi64(R1) = qq_pclgen_unitstoarray(asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 512;
	if (asi64(R1) <= asi64(R2)) goto L4944;
	R1 = 0;
	R2 = tou64("Selectx too complex");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4944:
	asi64(R1) = qq_pcllib_createfwdlabel();
	labend = asi64(R1);
	R1 = 1;
	asu64(R2) = pindex;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = n;
	R2 = 1;
	R3 = 43;
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4947;
L4945:
	R1 = 0;
	R2 = 42;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	asu64(R1) = qq_pcllib_pccurr;
	R2 = (u64)&labels;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L4945;
L4947:
	R1 = 0;
	R2 = 42;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	asu64(R1) = qq_pcllib_pccurr;
	R2 = (u64)&labels;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4950;
L4948:
	R1 = (u64)&plist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	x = asu64(R1);
	asi64(R1) = qq_pcllib_definelabel();
	lab = asi64(R1);
	asi64(R1) = lab;
	R2 = (u64)&labels;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = res;
	asu64(R2) = x;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = labend;
	qq_pclgen_genjumpl(asi64(R1));
	i += 1; if (i <= n) goto L4948;
L4950:
	asi64(R1) = qq_pcllib_definelabel();
	elselab = asi64(R1);
	asi64(R1) = elselab;
	R2 = (u64)&labels;
	asi64(R3) = n;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L4952;
	asi64(R1) = res;
	asu64(R2) = pelse;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L4951;
L4952:
	asi64(R1) = res;
	if (!asi64(R1)) goto L4953;
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
L4953:
L4951:
	R1 = 0;
	qq_pcllib_genpc(asi64(R1));
	asi64(R1) = labend;
	qq_pcllib_definefwdlabel(asi64(R1));
	return;
}

static void qq_pclgen_do_andl(u64 x, u64 y) {
    u64 R1, R2, R3; 
	i64 a;
	i64 b;
	asi64(R1) = qq_pcllib_createfwdlabel();
	a = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	b = asi64(R1);
	asi64(R1) = a;
	asu64(R2) = x;
	R3 = 33;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = a;
	asu64(R2) = y;
	R3 = 33;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	R1 = 1;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	asi64(R1) = b;
	qq_pclgen_genjumpl(asi64(R1));
	asi64(R1) = a;
	qq_pcllib_definefwdlabel(asi64(R1));
	R1 = 0;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	R1 = 0;
	qq_pcllib_genpc(asi64(R1));
	asi64(R1) = b;
	qq_pcllib_definefwdlabel(asi64(R1));
	return;
}

static void qq_pclgen_do_orl(u64 x, u64 y) {
    u64 R1, R2, R3; 
	i64 a;
	i64 b;
	asi64(R1) = qq_pcllib_createfwdlabel();
	a = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	b = asi64(R1);
	asi64(R1) = a;
	asu64(R2) = x;
	R3 = 32;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = a;
	asu64(R2) = y;
	R3 = 32;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	asi64(R1) = b;
	qq_pclgen_genjumpl(asi64(R1));
	asi64(R1) = a;
	qq_pcllib_definefwdlabel(asi64(R1));
	R1 = 1;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	R1 = 0;
	qq_pcllib_genpc(asi64(R1));
	asi64(R1) = b;
	qq_pcllib_definefwdlabel(asi64(R1));
	return;
}

static void qq_pclgen_do_incr(u64 p, u64 a, i64 res) {
    u64 R1, R2, R3; 
	u64 d;
	i64 opc;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 60;
	if (asi64(R1) != asi64(R2)) goto L4958;
	R1 = 74;
	goto L4957;
L4958:
	R1 = 73;
L4957:
	opc = asi64(R1);
	asi64(R1) = res;
	if (!asi64(R1)) goto L4960;
	asi64(R1) = opc;
	asu64(R2) = a;
	qq_pclgen_do_unaryref(asu64(R2), asi64(R1));
	goto L4959;
L4960:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L4961;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L4963;
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L4963;
	R1 = 70;
	asu64(R2) = a;
	qq_pclgen_do_unaryref(asu64(R2), asi64(R1));
	goto L4962;
L4963:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 71;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
L4962:
	goto L4959;
L4961:
	R1 = 70;
	asu64(R2) = a;
	qq_pclgen_do_unaryref(asu64(R2), asi64(R1));
L4959:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4965;
	R1 = -1;
	goto L4964;
L4965:
	R1 = 1;
L4964:
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 12;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	return;
}

static void qq_pclgen_do_callhost(u64 p, u64 a, i64 res) {
    u64 R1, R2, R3; 
	i64 index;
	i64 isfunc;
	i64 nargs;
	i64 nparams;
	i64 fparams;
	struct $B1 plist;
	u64 q;
	i64 av_1;
	i64 i;
	asu64(R1) = p;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	index = asi64(R1);
	R1 = (u64)&qq_tables_hostisfn;
	asi64(R2) = index;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	isfunc = asi64(R1);
	asi64(R1) = res;
	if (!asi64(R1)) goto L4968;
	asi64(R1) = isfunc;
	if (asi64(R1)) goto L4968;
	R1 = 0;
	R2 = tou64("Host proc not a function");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4968:
	asi64(R1) = isfunc;
	if (!asi64(R1)) goto L4970;
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
L4970:
	R1 = 0;
	nargs = asi64(R1);
	asu64(R1) = a;
	q = asu64(R1);
	goto L4972;
L4971:
	asi64(R1) = nargs;
	R2 = 10;
	if (asi64(R1) <= asi64(R2)) goto L4975;
	R1 = 0;
	R2 = tou64("Too many host args");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4975:
	asu64(R1) = q;
	R2 = (u64)&plist;
	R3 = (u64)&nargs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L4972:
	asu64(R1) = q;
	if (asu64(R1)) goto L4971;
	asi64(R1) = nargs;
	nparams = asi64(R1);
	asi64(R1) = nparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4977;
	R1 = (u64)&qq_tables_hostlvset;
	asi64(R2) = index;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4977;
	R1 = 0;
	R2 = tou64("LV hostfn: needs 1+ params");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4977:
	R1 = (u64)&qq_tables_hostnparams;
	asi64(R2) = index;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	fparams = asi64(R1);
	asi64(R1) = nparams;
	asi64(R2) = fparams;
	if (asi64(R1) <= asi64(R2)) goto L4979;
	R1 = 0;
	R2 = tou64("Hostfn too many params");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4979:
	asi64(R1) = fparams;
	asi64(R2) = nparams;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4982;
L4980:
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
	if (--asi64(av_1)) goto L4980;
L4982:
	asi64(R1) = nparams;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4985;
L4983:
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4987;
	R1 = (u64)&qq_tables_hostlvset;
	asi64(R2) = index;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4987;
	R1 = (u64)&plist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	qq_pclgen_evalref(asu64(R1));
	goto L4986;
L4987:
	R1 = 1;
	R2 = (u64)&plist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
L4986:
	i += -1; if (i >= 1) goto L4983;
L4985:
	asi64(R1) = res;
	asi64(R2) = index;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	return;
}

static void qq_pclgen_callhostfn(i64 fnindex, i64 calledasfn) {
    u64 R1, R2; 
	asi64(R1) = fnindex;
	R2 = 57;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	return;
}

static void qq_pclgen_genfree(i64 n) {
    u64 R1, R2; 
	asi64(R1) = n;
	R2 = 58;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
	return;
}

static void qq_pclgen_do_return(u64 p, u64 a, i64 res) {
    u64 R1, R2; 
	asu64(R1) = a;
	if (!asu64(R1)) goto L4992;
	asu64(R1) = qq_decls_stcurrproc;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 4;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L4994;
	R1 = 0;
	R2 = tou64("Proc can't return a value");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4994:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L4991;
L4992:
	asu64(R1) = qq_decls_stcurrproc;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 4;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L4996;
	R1 = 0;
	R2 = tou64("Func needs return value");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4996:
L4991:
	asi64(R1) = res;
	if (asi64(R1)) goto L4998;
	asi64(R1) = qq_pclgen_retindex;
	qq_pclgen_genjumpl(asi64(R1));
L4998:
	return;
}

static void qq_pclgen_do_multassign(u64 a, u64 b, i64 deepcopy, i64 res) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	struct $B27 plist;
	i64 n;
	i64 i;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	goto L5001;
L5000:
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5004;
	R1 = 0;
	R2 = tou64("Too few RHS elems");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5004:
	R1 = 1;
	asu64(R2) = q;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = n;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L5006;
	R1 = 0;
	R2 = tou64("Too many elems");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5006:
	asu64(R1) = p;
	R2 = (u64)&plist;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5001:
	asu64(R1) = p;
	if (asu64(R1)) goto L5000;
	asu64(R1) = q;
	if (!asu64(R1)) goto L5008;
	R1 = 0;
	R2 = tou64("Too few LHS elems");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5008:
	asi64(R1) = n;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5011;
L5009:
	asi64(R1) = deepcopy;
	if (!asi64(R1)) goto L5013;
	R1 = 27;
	qq_pcllib_genpc(asi64(R1));
L5013:
	R1 = 0;
	R2 = (u64)&plist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_do_store(asu64(R2), asi64(R1));
	i += -1; if (i >= 1) goto L5009;
L5011:
	return;
}

static void qq_pclgen_do_store(u64 a, i64 res) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 p;
	struct $B27 plist;
	i64 n;
	i64 i;
	asi64(R1) = res;
	if (!asi64(R1)) goto L5016;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L5016;
	R1 = 26;
	qq_pcllib_genpc(asi64(R1));
L5016:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L5018;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L5019;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L5020;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L5021;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L5022;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L5023;
	R2 = 88;
	if (asi64(R1) == asi64(R2)) goto L5024;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5025;
	goto L5026;
L5018:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L5028;
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5028;
	asi64(R1) = res;
	if (!asi64(R1)) goto L5030;
	R1 = 26;
	qq_pcllib_genpc(asi64(R1));
L5030:
	asu64(R1) = d;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	R1 = 23;
	qq_pcllib_genpc(asi64(R1));
	goto L5027;
L5028:
	asi64(R1) = res;
	if (!asi64(R1)) goto L5031;
	R1 = 26;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = d;
	R2 = 12;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L5027;
L5031:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5033;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L5032;
L5033:
	R1 = 0;
	R2 = tou64("Not lvalue");
	qq_lib_gerror(asu64(R2), asu64(R1));
	goto L5027;
L5032:
	asu64(R1) = d;
	R2 = 12;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
L5027:
	goto L5017;
L5019:
	R1 = 1;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 104;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5035;
	R1 = 0;
	R2 = tou64(".m3?");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5035:
	asu64(R1) = a;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 128;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L5017;
L5020:
	R1 = 131;
	asu64(R2) = a;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = a;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_pclgen_do_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L5017;
L5021:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_pclgen_evalref(asu64(R1));
	R1 = 1;
	asu64(R2) = a;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 137;
	qq_pcllib_genpc(asi64(R1));
	goto L5017;
L5022:
	R1 = 1;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 23;
	qq_pcllib_genpc(asi64(R1));
	goto L5017;
L5023:
	R1 = 134;
	asu64(R2) = a;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = a;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_pclgen_do_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L5017;
L5024:
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L5037;
L5036:
	asi64(R1) = n;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L5040;
	R1 = 0;
	R2 = tou64("Too many elems");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5040:
	asu64(R1) = p;
	R2 = (u64)&plist;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L5037:
	asu64(R1) = p;
	if (asu64(R1)) goto L5036;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5042;
	R1 = 0;
	R2 = tou64("Empty lhs list");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5042:
	asi64(R1) = n;
	R2 = 139;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5045;
L5043:
	R1 = 0;
	R2 = (u64)&plist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_do_store(asu64(R2), asi64(R1));
	i += 1; if (i <= n) goto L5043;
L5045:
	goto L5017;
L5025:
	asu64(R1) = a;
	qq_pclgen_evalref(asu64(R1));
	R1 = 23;
	qq_pcllib_genpc(asi64(R1));
	goto L5017;
L5026:
	asu64(R1) = a;
	R2 = (u64)&qq_tables_jtagnames;
	asu64(R3) = a;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("Can't store to this unit yet:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L5017:
	return;
}

static i64 qq_pclgen_getconstvalue(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	if (!asu64(R1)) goto L5048;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L5048;
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L5046;
L5048:
	R1 = 0;
	R2 = tou64("gcv Not const");
	qq_lib_gerror(asu64(R2), asu64(R1));
	R1 = 0;
	goto L5046;
L5046:
	return asi64(R1);
}

static void qq_pclgen_do_convert(u64 pconv) {
    u64 R1, R2, R3, R4; 
	i64 n;
	i64 elemmode;
	i64 i;
	i64 lowerx;
	i64 lbound;
	i64 m;
	i64 mbase;
	i64 nfields;
	struct $B76 plist;
	u64 p;
	i64 av_1;
	asu64(R1) = pconv;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
	asu64(R1) = pconv;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	mbase = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 88;
	if (asi64(R1) != asi64(R2)) goto L5052;
	asi64(R1) = mbase;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L5051;
L5052:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 88;
	if (asi64(R1) != asi64(R2)) goto L5054;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	qq_lib_deleteunit(asu64(R2), asu64(R1));
L5054:
	R1 = 1;
	asu64(R2) = p;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = m;
	R2 = 99;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	goto L5049;
L5051:
	R1 = 400;
	R2 = (u64)&plist;
	asu64(R3) = p;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R1) = qq_pclgen_unitstoarray(asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L5056;
	R1 = (u64)&plist;
	R2 = 1;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L5056;
	asi64(R1) = mbase;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5058;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5058;
	goto L5059;
L5058:
	R1 = (u64)&plist;
	asi64(R2) = n;
	asi64(R3) = m;
	qq_pclgen_do_makerecordkv(asi64(R3), asi64(R2), asu64(R1));
	goto L5057;
L5059:
	R1 = 0;
	R2 = tou64("key:value not allowed");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5057:
	goto L5049;
L5056:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5062;
L5060:
	R1 = 1;
	R2 = (u64)&plist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	i += 1; if (i <= n) goto L5060;
L5062:
	asi64(R1) = mbase;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5064;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5064;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5065;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5066;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5067;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5068;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5069;
	goto L5070;
L5064:
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	nfields = asi64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L5072;
	asu64(R1) = p;
	asi64(R2) = nfields;
	asi64(R3) = n;
	qq_pclgen_checkelems(asi64(R3), asi64(R2), asu64(R1));
	goto L5071;
L5072:
	asi64(R1) = nfields;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5075;
L5073:
	R1 = 0;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	if (--asi64(av_1)) goto L5073;
L5075:
	asi64(R1) = nfields;
	n = asi64(R1);
L5071:
	R1 = 0;
	asi64(R2) = n;
	asi64(R3) = mbase;
	R4 = 12;
	if (asi64(R3) != asi64(R4)) goto L5077;
	R3 = 62;
	goto L5076;
L5077:
	R3 = 65;
L5076:
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = m;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5063;
L5065:
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	lowerx = asi64(R1);
	asi64(R1) = lowerx;
	asi64(R2) = n;
	R3 = 61;
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	goto L5063;
L5066:
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = n;
	R3 = 63;
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	R1 = 11;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5063;
L5067:
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemmode = asi64(R1);
	R1 = (u64)&qq_tables_ttlower;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	lowerx = asi64(R1);
	asu64(R1) = p;
	R2 = (u64)&qq_tables_ttlength;
	asi64(R3) = m;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R3) = n;
	qq_pclgen_checkelems(asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = lowerx;
	asi64(R2) = n;
	R3 = 63;
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = m;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = elemmode;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5063;
L5068:
	asi64(R1) = m;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L5079;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = n;
	R3 = 64;
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	R1 = 8;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5081;
	R1 = 33;
	goto L5080;
L5081:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
L5080:
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5078;
L5079:
	R1 = 0;
	R2 = tou64("user-define bit array not ready");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5078:
	goto L5063;
L5069:
	R1 = 0;
	asi64(R2) = n;
	R3 = 66;
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	goto L5063;
L5070:
	R1 = 0;
	R2 = 0;
	asi64(R3) = mbase;
	asu64(R2) = qq_show_strmode(asi64(R3), asi64(R2));
	R3 = tou64("Convert list");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L5063:
L5049:
	return;
}

static void qq_pclgen_checkelems(i64 n, i64 length, u64 p) {
    u64 R1, R2; 
	asi64(R1) = n;
	asi64(R2) = length;
	if (asi64(R1) >= asi64(R2)) goto L5084;
	R1 = 0;
	R2 = tou64("Too few elements");
	qq_lib_gerror(asu64(R2), asu64(R1));
	goto L5083;
L5084:
	asi64(R1) = n;
	asi64(R2) = length;
	if (asi64(R1) <= asi64(R2)) goto L5085;
	R1 = 0;
	R2 = tou64("Too many elements");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5085:
L5083:
	return;
}

static void qq_pclgen_do_switch(u64 p, u64 pindex, u64 pwhenthen, i64 res) {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	i64 minlab;
	i64 maxlab;
	i64 x;
	i64 y;
	i64 i;
	i64 n;
	u64 w;
	u64 wt;
	u64 pelse;
	asu64(R1) = pindex;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pelse = asu64(R1);
	R1 = 1000000;
	minlab = asi64(R1);
	R1 = -1000000;
	maxlab = asi64(R1);
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = pwhenthen;
	wt = asu64(R1);
	goto L5088;
L5087:
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	goto L5091;
L5090:
	asu64(R1) = w;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L5094;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L5095;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L5096;
	goto L5097;
L5094:
	asu64(R1) = w;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = qq_pclgen_getconstvalue(asu64(R1));
	x = asi64(R1);
	asu64(R1) = w;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = qq_pclgen_getconstvalue(asu64(R1));
	y = asi64(R1);
// qq_pclgen.do_switch.dorange:
L5098:
	asi64(R1) = x;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = y;
	if (asi64(R1) > asi64(R2)) goto L5101;
L5099:
	asi64(R1) = minlab;
	asi64(R2) = i;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	minlab = asi64(R1);
	asi64(R1) = maxlab;
	asi64(R2) = i;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	maxlab = asi64(R1);
	i += 1; if (i <= y) goto L5099;
L5101:
	goto L5093;
L5095:
	asu64(R1) = w;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	y = asi64(R2);
	x = asi64(R1);
	goto L5098;
	goto L5093;
L5096:
	asu64(R1) = w;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = R1;
	y = asi64(R2);
	x = asi64(R1);
	goto L5098;
	goto L5093;
L5097:
	R1 = 0;
	asu64(R2) = w;
	asu64(R2) = qq_lib_strexpr(asu64(R2));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Switch when2: not const");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L5093:
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
L5091:
	asu64(R1) = w;
	if (asu64(R1)) goto L5090;
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L5088:
	asu64(R1) = wt;
	if (asu64(R1)) goto L5087;
	asi64(R1) = maxlab;
	asi64(R2) = minlab;
	asi64(R1) -= asi64(R2);
	R2 = 512;
	if (asi64(R1) > asi64(R2)) goto L5103;
	asi64(R1) = res;
	asi64(R2) = maxlab;
	asi64(R3) = minlab;
	asu64(R4) = pelse;
	asu64(R5) = pwhenthen;
	asu64(R6) = pindex;
	asu64(R7) = p;
	qq_pclgen_do_simpleswitch(asu64(R7), asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L5086;
L5103:
	R1 = 0;
	R2 = tou64("COMPLEX SWITCH/NOT COMPLETE");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5086:
	return;
}

static void qq_pclgen_do_simpleswitch(u64 p, u64 pindex, u64 pwhenthen, u64 pelse, i64 a, i64 b, i64 res) {
    u64 R1, R2, R3; 
	u64 w;
	u64 wt;
	u64 q;
	i64 loopsw;
	i64 n;
	i64 offset;
	i64 x;
	i64 y;
	i64 x0;
	i64 i;
	i64 labstmt;
	i64 elselab;
	struct $B75 labels;
	i64 lab_a;
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	loopsw = asi64(R1);
	asi64(R1) = b;
	asi64(R2) = a;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = a;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	offset = asi64(R1);
	asi64(R1) = loopsw;
	if (!asi64(R1)) goto L5106;
	asi64(R1) = qq_pcllib_definelabel();
	lab_a = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_a;
	asi64(R3) = lab_a;
	qq_pclgen_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	goto L5105;
L5106:
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_d = asi64(R1);
L5105:
	asi64(R1) = qq_pcllib_createfwdlabel();
	elselab = asi64(R1);
	R1 = 1;
	asu64(R2) = pindex;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = b;
	asi64(R2) = a;
	R3 = 43;
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5109;
L5107:
	R1 = 0;
	R2 = 42;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	asu64(R1) = qq_pcllib_pccurr;
	R2 = (u64)&labels;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L5107;
L5109:
	R1 = 0;
	R2 = 42;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	asu64(R1) = qq_pcllib_pccurr;
	R2 = (u64)&labels;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = pwhenthen;
	wt = asu64(R1);
	goto L5111;
L5110:
	asi64(R1) = qq_pcllib_definelabel();
	labstmt = asi64(R1);
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	goto L5114;
L5113:
	asu64(R1) = w;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L5117;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L5118;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L5119;
	goto L5120;
L5117:
	asu64(R1) = w;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = qq_pclgen_getconstvalue(asu64(R1));
	x0 = asi64(R1);
	asu64(R1) = w;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = qq_pclgen_getconstvalue(asu64(R1));
	y = asi64(R1);
	goto L5116;
L5118:
	asu64(R1) = w;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	y = asi64(R2);
	x0 = asi64(R1);
	goto L5116;
L5119:
	asu64(R1) = w;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = R1;
	y = asi64(R2);
	x0 = asi64(R1);
	goto L5116;
L5120:
L5116:
	asi64(R1) = x0;
	x = asi64(R1);
	asi64(R1) = x;
	asi64(R2) = y;
	if (asi64(R1) > asi64(R2)) goto L5123;
L5121:
	asi64(R1) = x;
	asi64(R2) = offset;
	asi64(R1) -= asi64(R2);
	i = asi64(R1);
	R1 = (u64)&labels;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L5125;
	msysc_m$print_startcon();
	asi64(R1) = x;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = 0;
	asi64(R2) = x;
	asu64(R2) = tou64(tou8(R2));
	msysc_m$print_c8(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Dupl switch value");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5125:
	asi64(R1) = labstmt;
	R2 = (u64)&labels;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	x += 1; if (x <= y) goto L5121;
L5123:
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
L5114:
	asu64(R1) = w;
	if (asu64(R1)) goto L5113;
	asi64(R1) = res;
	asu64(R2) = wt;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = loopsw;
	if (asi64(R1)) goto L5127;
	asi64(R1) = lab_d;
	qq_pclgen_genjumpl(asi64(R1));
	goto L5126;
L5127:
	asi64(R1) = lab_a;
	qq_pclgen_genjumpl(asi64(R1));
L5126:
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L5111:
	asu64(R1) = wt;
	if (asu64(R1)) goto L5110;
	asi64(R1) = elselab;
	qq_pcllib_definefwdlabel(asi64(R1));
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L5129;
	asi64(R1) = res;
	asu64(R2) = pelse;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
L5129:
	asi64(R1) = loopsw;
	if (!asi64(R1)) goto L5131;
	asi64(R1) = lab_a;
	qq_pclgen_genjumpl(asi64(R1));
	asi64(R1) = lab_d;
	qq_pcllib_definefwdlabel(asi64(R1));
	qq_pclgen_unstacklooplabels();
	goto L5130;
L5131:
	asi64(R1) = lab_d;
	qq_pcllib_definefwdlabel(asi64(R1));
L5130:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5134;
L5132:
	R1 = (u64)&labels;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5136;
	asi64(R1) = elselab;
	R2 = (u64)&labels;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L5136:
	i += 1; if (i <= n) goto L5132;
L5134:
	asi64(R1) = elselab;
	R2 = (u64)&labels;
	asi64(R3) = n;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_pclgen_do_makerecordkv(i64 m, i64 nkeyvals, u64 kvlist) {
    u64 R1, R2, R3; 
	u64 p;
	struct $B76 plist;
	i64 nfields;
	i64 index;
	u64 d;
	u64 e;
	u64 f;
	u64 k;
	i64 i;
	R1 = (u64)&qq_tables_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	nfields = asi64(R1);
	goto L5141;
L5138:
	asu64(R1) = e;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5144;
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L5143;
L5144:
	asu64(R1) = e;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5143;
	R1 = (u64)&nfields;
	(*toi64p(R1)) += 1;
	R1 = 0;
	R2 = (u64)&plist;
	asi64(R3) = nfields;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L5143:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L5141:
	asu64(R1) = e;
	if (asu64(R1)) goto L5138;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nkeyvals;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5147;
L5145:
	asu64(R1) = kvlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	k = asu64(R1);
	asu64(R1) = kvlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	f = asu64(R1);
	goto L5151;
L5148:
	asu64(R1) = e;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5154;
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L5153;
L5154:
	asu64(R1) = e;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = k;
	if (asu64(R1) != asu64(R2)) goto L5153;
	asu64(R1) = e;
	f = asu64(R1);
	goto L5150;
L5153:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L5151:
	asu64(R1) = e;
	if (asu64(R1)) goto L5148;
L5150:
	asu64(R1) = f;
	if (asu64(R1)) goto L5156;
	R1 = 0;
	asu64(R2) = k;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Can't find field:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L5156:
	asu64(R1) = f;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	index = asi64(R1);
	R1 = (u64)&plist;
	asi64(R2) = index;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	if (!asu64(R1)) goto L5158;
	R1 = 0;
	asu64(R2) = k;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Dupl key:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L5158:
	asu64(R1) = p;
	R2 = (u64)&plist;
	asi64(R3) = index;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= nkeyvals) goto L5145;
L5147:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nfields;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5161;
L5159:
	R1 = (u64)&plist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	if (!asu64(R1)) goto L5163;
	R1 = 1;
	R2 = (u64)&plist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L5162;
L5163:
	R1 = 0;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
L5162:
	i += 1; if (i <= nfields) goto L5159;
L5161:
	R1 = 0;
	asi64(R2) = nfields;
	R3 = 62;
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = m;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void qq_pclgen_do_idiv(u64 a, u64 b) {
    u64 R1, R2; 
	i64 n;
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L5166;
	asu64(R1) = b;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = qq_lib_ispoweroftwo(asi64(R1));
	R2 = R1;
	n = asi64(R2);
	if (!asi64(R1)) goto L5166;
	asi64(R1) = n;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	R1 = 112;
	qq_pcllib_genpc(asi64(R1));
	goto L5165;
L5166:
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 105;
	qq_pcllib_genpc(asi64(R1));
L5165:
	return;
}

static void qq_pclgen_do_irem(u64 a, u64 b) {
    u64 R1, R2; 
	i64 n;
	u64 m;
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L5169;
	asu64(R1) = b;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = qq_lib_ispoweroftwo(asi64(R1));
	R2 = R1;
	n = asi64(R2);
	if (!asi64(R1)) goto L5169;
	R1 = -1;
	asi64(R2) = n;
	asu64(R1) <<= asu64(R2);
	asu64(R1) = ~asu64(R1);
	m = asu64(R1);
	asu64(R1) = m;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	R1 = 108;
	qq_pcllib_genpc(asi64(R1));
	goto L5168;
L5169:
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 106;
	qq_pcllib_genpc(asi64(R1));
L5168:
	return;
}

static void qq_pclgen_do_map(u64 p, u64 popcode, u64 x) {
    u64 R1, R2, R3; 
	i64 lab;
	R1 = 1;
	asu64(R2) = x;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5172;
	R1 = 1;
	asu64(R2) = x;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
L5172:
	R1 = 1;
	asu64(R2) = popcode;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 142;
	qq_pcllib_genpc(asi64(R1));
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab = asi64(R1);
	asi64(R1) = lab;
	R2 = 30;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	R1 = 0;
	qq_pcllib_genpc(asi64(R1));
	asi64(R1) = lab;
	qq_pcllib_definefwdlabel(asi64(R1));
	return;
}

static void qq_pclgen_pushstring(u64 s) {
    u64 R1; 
	R1 = 18;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = s;
	qq_pcllib_genopnd_strz(asu64(R1));
	return;
}

static i64 qq_pclgen_checkblockreturn(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	u64 r;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5176;
	R1 = 0;
	goto L5174;
L5176:
	R1 = (u64)&qq_tables_jhasvalue;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5178;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5179;
	goto L5180;
L5178:
	R1 = 0;
	goto L5174;
	goto L5177;
L5179:
	R1 = 1;
	goto L5174;
	goto L5177;
L5180:
L5177:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5182;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5183;
	goto L5184;
L5182:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5186;
	R1 = 0;
	goto L5174;
L5186:
	goto L5188;
L5187:
	asu64(R1) = r;
	q = asu64(R1);
L5188:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	r = asu64(R2);
	if (asu64(R1)) goto L5187;
	asu64(R1) = q;
	asi64(R1) = qq_pclgen_checkblockreturn(asu64(R1));
	goto L5174;
	goto L5181;
L5183:
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = qq_pclgen_checkblockreturn(asu64(R1));
	if (!asi64(R1)) goto L5190;
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = qq_pclgen_checkblockreturn(asu64(R1));
	if (!asi64(R1)) goto L5190;
	R1 = 1;
	goto L5191;
L5190:
	R1 = 0;
L5191:
	goto L5174;
	goto L5181;
L5184:
	R1 = 1;
	goto L5174;
L5181:
	R1 = 0;
	goto L5174;
L5174:
	return asi64(R1);
}

static void qq_pcllib_start() {
    u64 R1, R2; 
	i64 nn;
	mlib_pcm_init();
	R1 = 8192;
	qq_pcllib_labelalloc = asi64(R1);
	R1 = 8;
	asi64(R2) = qq_pcllib_labelalloc;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	qq_pcllib_labelpctable = asu64(R1);
	return;
}

static void qq_pcllib_resetpcl(i64 sourcesize) {
    u64 R1, R2; 
	i64 pclsize;
	R1 = 0;
	qq_decls_qpos = asi64(R1);
	R1 = 0;
	qq_pcllib_nextlabelno = asi64(R1);
	R1 = 0;
	qq_pcllib_pclcurrlineno = asi64(R1);
	asi64(R1) = sourcesize;
	pclsize = asi64(R1);
	R1 = 1024;
	qq_pcllib_pcalloc = asi64(R1);
	goto L5195;
L5194:
	R1 = 1;
	R2 = (u64)&qq_pcllib_pcalloc;
	*toi64p(R2) <<= asi64(R1);
L5195:
	asi64(R1) = qq_pcllib_pcalloc;
	asi64(R2) = pclsize;
	if (asi64(R1) < asi64(R2)) goto L5194;
	asi64(R1) = qq_pcllib_pcalloc;
	R2 = 32;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	qq_pcllib_pcstart = asu64(R1);
	asu64(R1) = qq_pcllib_pcstart;
	R2 = 1;
	R1 -= (i64)R2*32;
	qq_pcllib_pccurr = asu64(R1);
	asu64(R1) = qq_pcllib_pcstart;
	asi64(R2) = qq_pcllib_pcalloc;
	R1 += (i64)R2*32;
	R2 = 8;
	R1 -= (i64)R2*32;
	qq_pcllib_pcend = asu64(R1);
	asi64(R1) = qq_pcllib_pcalloc;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	qq_pcllib_pcsourcestart = asu64(R1);
	asu64(R1) = qq_pcllib_pcsourcestart;
	qq_pcllib_pcsourcecurr = asu64(R1);
	R1 = 8;
	asi64(R2) = qq_pcllib_labelalloc;
	asi64(R1) *= asi64(R2);
	asu64(R2) = qq_pcllib_labelpctable;
	mlib_pcm_clearmem(asu64(R2), asi64(R1));
	return;
}

static void qq_pcllib_genpc(i64 opc) {
    u64 R1, R2, R3; 
	R1 = (u64)&qq_pcllib_pccurr;
	(*tou64p(R1)) += 32;
	asu64(R1) = qq_pcllib_pccurr;
	asu64(R2) = qq_pcllib_pcend;
	if (asu64(R1) < asu64(R2)) goto L5199;
	qq_pcllib_extendpcldata();
L5199:
	asi64(R1) = opc;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&qq_pcllib_pcsourcecurr;
	(*tou64p(R1)) += 4;
	asi64(R1) = qq_decls_qpos;
	asu64(R2) = qq_pcllib_pcsourcecurr;
	*toi32p(R2) = asi32(R1);
	return;
}

static void qq_pcllib_genpc_int(i64 opc, i64 a) {
    u64 R1, R2, R3; 
	asi64(R1) = opc;
	qq_pcllib_genpc(asi64(R1));
	asi64(R1) = a;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_pcllib_genpc_n(i64 opc, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = opc;
	qq_pcllib_genpc(asi64(R1));
	asi64(R1) = n;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void qq_pcllib_genpc_xy(i64 opc, i64 x, i64 y) {
    u64 R1, R2, R3; 
	asi64(R1) = opc;
	qq_pcllib_genpc(asi64(R1));
	asi64(R1) = x;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 12;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = y;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 14;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	return;
}

static void qq_pcllib_genpc_name(i64 opc, u64 d) {
    u64 R1, R2, R3; 
	asi64(R1) = opc;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = d;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_pcllib_genopnd_strz(u64 s) {
    u64 R1, R2, R3; 
	asu64(R1) = s;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_pcllib_genopnd_str(u64 s) {
    u64 R1, R2, R3; 
	asu64(R1) = s;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_pcllib_genopnd_obj(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_pcllib_genpc_real(i64 opc, r64 x) {
    u64 R1, R2, R3; 
	asi64(R1) = opc;
	qq_pcllib_genpc(asi64(R1));
	asr64(R1) = x;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	return;
}

static void qq_pcllib_genpc_lab(i64 opc, i64 lab) {
    u64 R1, R2, R3; 
	asi64(R1) = opc;
	qq_pcllib_genpc(asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_pcllib_gencomment(u64 s) {
    u64 R1; 
	R1 = 6;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	qq_pcllib_genopnd_strz(asu64(R1));
	return;
}

static void qq_pcllib_extendpcldata() {
    u64 R1, R2, R3; 
	i64 newpcalloc;
	u64 newpcstart;
	u64 newpcsourcestart;
	asi64(R1) = qq_pcllib_pcalloc;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	newpcalloc = asi64(R1);
	R1 = 32;
	asi64(R2) = newpcalloc;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	newpcstart = asu64(R1);
	R1 = 4;
	asi64(R2) = newpcalloc;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	newpcsourcestart = asu64(R1);
	asu64(R1) = qq_pcllib_pcstart;
	asu64(R2) = qq_pcllib_pccurr;
	asi64(R1) = qq_lib_getpcloffset(asu64(R2), asu64(R1));
	R2 = 32;
	asu64(R1) *= asu64(R2);
	asu64(R2) = qq_pcllib_pcstart;
	asu64(R3) = newpcstart;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = qq_pcllib_pcstart;
	asu64(R2) = qq_pcllib_pccurr;
	asi64(R1) = qq_lib_getpcloffset(asu64(R2), asu64(R1));
	R2 = 4;
	asu64(R1) *= asu64(R2);
	asu64(R2) = qq_pcllib_pcsourcestart;
	asu64(R3) = newpcsourcestart;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = newpcstart;
	asu64(R2) = qq_pcllib_pcstart;
	asu64(R3) = qq_pcllib_pccurr;
	asi64(R2) = qq_lib_getpcloffset(asu64(R3), asu64(R2));
	R1 += (i64)R2*32;
	qq_pcllib_pccurr = asu64(R1);
	asu64(R1) = newpcstart;
	asi64(R2) = newpcalloc;
	R1 += (i64)R2*32;
	R2 = 10;
	R1 -= (i64)R2*32;
	qq_pcllib_pcend = asu64(R1);
	asu64(R1) = newpcsourcestart;
	asu64(R2) = qq_pcllib_pcsourcecurr;
	asu64(R3) = qq_pcllib_pcsourcestart;
	asi64(R2) -= asi64(R3);
    asi64(R2) /= 4;
	R1 += (i64)R2*4;
	qq_pcllib_pcsourcecurr = asu64(R1);
	asi64(R1) = qq_pcllib_pcalloc;
	R2 = 32;
	asi64(R1) *= asi64(R2);
	asu64(R2) = qq_pcllib_pcstart;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asi64(R1) = qq_pcllib_pcalloc;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	asu64(R2) = qq_pcllib_pcsourcestart;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = newpcstart;
	qq_pcllib_pcstart = asu64(R1);
	asi64(R1) = newpcalloc;
	qq_pcllib_pcalloc = asi64(R1);
	asu64(R1) = newpcsourcestart;
	qq_pcllib_pcsourcestart = asu64(R1);
	return;
}

static void qq_pcllib_extendlabeltable() {
    u64 R1, R2, R3; 
	i64 newlabelalloc;
	u64 newlabeltable;
	asi64(R1) = qq_pcllib_labelalloc;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	newlabelalloc = asi64(R1);
	R1 = 8;
	asi64(R2) = newlabelalloc;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	newlabeltable = asu64(R1);
	asi64(R1) = qq_pcllib_labelalloc;
	R2 = 8;
	asu64(R1) *= asu64(R2);
	asu64(R2) = qq_pcllib_labelpctable;
	asu64(R3) = newlabeltable;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = qq_pcllib_labelalloc;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R2) = qq_pcllib_labelpctable;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = newlabeltable;
	qq_pcllib_labelpctable = asu64(R1);
	asi64(R1) = newlabelalloc;
	qq_pcllib_labelalloc = asi64(R1);
	return;
}

static i64 qq_pcllib_definelabel() {
    u64 R1, R2, R3; 
	asi64(R1) = qq_pcllib_nextlabelno;
	asi64(R2) = qq_pcllib_labelalloc;
	if (asi64(R1) < asi64(R2)) goto L5214;
	qq_pcllib_extendlabeltable();
L5214:
	R1 = (u64)&qq_pcllib_nextlabelno;
	(*toi64p(R1)) += 1;
	asu64(R1) = qq_pcllib_pccurr;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = qq_pcllib_labelpctable;
	asi64(R3) = qq_pcllib_nextlabelno;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = qq_pcllib_nextlabelno;
	goto L5212;
L5212:
	return asi64(R1);
}

static i64 qq_pcllib_createfwdlabel() {
    u64 R1, R2, R3; 
	asi64(R1) = qq_pcllib_nextlabelno;
	asi64(R2) = qq_pcllib_labelalloc;
	if (asi64(R1) < asi64(R2)) goto L5217;
	qq_pcllib_extendlabeltable();
L5217:
	R1 = (u64)&qq_pcllib_nextlabelno;
	(*toi64p(R1)) += 1;
	R1 = 0;
	asu64(R2) = qq_pcllib_labelpctable;
	asi64(R3) = qq_pcllib_nextlabelno;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = qq_pcllib_nextlabelno;
	goto L5215;
L5215:
	return asi64(R1);
}

static void qq_pcllib_definefwdlabel(i64 lab) {
    u64 R1, R2, R3; 
	asu64(R1) = qq_pcllib_labelpctable;
	asi64(R2) = lab;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	if (!asu64(R1)) goto L5220;
	R1 = tou64("dupl label?");
	qq_lib_serror(asu64(R1));
L5220:
	asu64(R1) = qq_pcllib_pccurr;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = qq_pcllib_labelpctable;
	asi64(R3) = lab;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	return;
}

static void qq_pcllib_genxy(i64 x, i64 y) {
    u64 R1, R2, R3; 
	asi64(R1) = x;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 12;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = y;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 14;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	return;
}

static void qq_print_pch_print(u64 p, u64 fmt) {
    u64 R1, R2, R3; 
	struct $B3 v;
	u64 q;
	u64 s;
	struct $B3 emptyfmt;
	asu64(R1) = fmt;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5224;
	R1 = (u64)&emptyfmt;
	fmt = asu64(R1);
	R1 = 0;
	R2 = (u64)&emptyfmt;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L5224:
	asu64(R1) = qq_print_mfmtstr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5226;
	asu8(R1) = qq_print_mgapneeded;
	if (!asu8(R1)) goto L5228;
	R1 = 1;
	R2 = tou64(" ");
	qq_print_printstr_n(asu64(R2), asi64(R1));
	goto L5227;
L5228:
	R1 = 1;
	qq_print_mgapneeded = asu8(R1);
L5227:
	goto L5225;
L5226:
	R1 = 0;
	qq_print_printnextfmtchars(asi64(R1));
L5225:
	R1 = 0;
	qq_print_listdepth = asi64(R1);
	R1 = (u64)&v;
	asu64(R2) = fmt;
	asu64(R3) = p;
	qq_print_pch_tostr(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&v;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&v;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_print_printstr_n(asu64(R2), asi64(R1));
	R1 = (u64)&v;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5230;
	R1 = (u64)&v;
	qq_vars_var_unshareu(asu64(R1));
L5230:
	return;
}

static void qq_print_pch_print_nf(u64 p) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = p;
	qq_print_pch_print(asu64(R2), asu64(R1));
	return;
}

static void qq_print_pch_printnogap() {
    u64 R1; 
	R1 = 0;
	qq_print_mgapneeded = asu8(R1);
	return;
}

static void qq_print_pch_println() {
    u64 R1, R2; 
	asu64(R1) = qq_print_mfmtstr;
	if (!asu64(R1)) goto L5235;
	R1 = 1;
	qq_print_printnextfmtchars(asi64(R1));
L5235:
	R1 = 0;
	qq_print_mgapneeded = asu8(R1);
	R1 = -1;
	R2 = tou64("\n");
	qq_print_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void qq_print_pch_reread() {
    u64 R1; 
	asu64(R1) = qq_print_kb_lastpos;
	qq_print_kb_pos = asu64(R1);
	asi64(R1) = qq_print_kb_lastlength;
	qq_print_kb_length = asi64(R1);
	return;
}

static void qq_print_pch_rereadln() {
    u64 R1; 
	asu64(R1) = qq_print_kb_start;
	qq_print_kb_pos = asu64(R1);
	asi64(R1) = qq_print_kb_linelength;
	qq_print_kb_length = asi64(R1);
	return;
}

static void qq_print_pch_startprint(u64 p) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 s;
	R1 = (u64)&qq_print_noclevels;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5240;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5240;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5241;
	goto L5242;
L5240:
	goto L5239;
L5241:
	R1 = tou64("print #x overflow");
	qq_lib_prterror(asu64(R1));
	goto L5239;
L5242:
	asi64(R1) = qq_print_moutdev;
	R2 = (u64)&qq_print_moutdevstack;
	asi64(R3) = qq_print_noclevels;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	asu64(R1) = qq_print_moutchan;
	R2 = (u64)&qq_print_moutchanstack;
	asi64(R3) = qq_print_noclevels;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	(R1_B3) = qq_print_moutvar;
	R2 = (u64)&qq_print_moutvarstack;
	asi64(R3) = qq_print_noclevels;
	*(struct $B3*)(((i64)R2+(i64)R3*16-16)) = (R1_B3);
	asu64(R1) = qq_print_mfmtstr;
	R2 = (u64)&qq_print_mfmtstrstack;
	asi64(R3) = qq_print_noclevels;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = qq_print_mfmtcurr;
	R2 = (u64)&qq_print_mfmtcurrstack;
	asi64(R3) = qq_print_noclevels;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu8(R1) = qq_print_mgapneeded;
	R2 = (u64)&qq_print_mgapstack;
	asi64(R3) = qq_print_noclevels;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L5239:
	R1 = 0;
	qq_print_mfmtstr = asu64(R1);
	R1 = 0;
	qq_print_mfmtcurr = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5244;
	goto L5245;
L5244:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5247;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5248;
	goto L5249;
L5247:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5251;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5252;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5253;
	goto L5254;
L5251:
// qq_print.pch_startprint.doconsole:
L5245:
	R1 = 0;
	qq_print_moutdev = asi64(R1);
	R1 = 0;
	qq_print_moutchan = asu64(R1);
	goto L5250;
L5252:
	R1 = 2;
	qq_print_moutdev = asi64(R1);
	R1 = 0;
	qq_print_moutchan = asu64(R1);
	R1 = 265;
	R2 = (u64)&qq_print_moutvar;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = qq_vars_obj_new();
	s = asu64(R1);
	R1 = 1;
	asu64(R2) = s;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = s;
	R2 = (u64)&qq_print_moutvar;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L5250;
L5253:
	asu64(R1) = qq_print_testfilech;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5256;
	R1 = tou64("@2: file not open");
	qq_lib_prterror(asu64(R1));
L5256:
	R1 = 1;
	qq_print_moutdev = asi64(R1);
	asu64(R1) = qq_print_testfilech;
	qq_print_moutchan = asu64(R1);
	goto L5250;
L5254:
	R1 = 1;
	qq_print_moutdev = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_print_moutchan = asu64(R1);
L5250:
	goto L5246;
L5248:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5258;
	goto L5259;
L5258:
	R1 = 4;
	qq_print_moutdev = asi64(R1);
	R1 = 0;
	qq_print_moutchan = asu64(R1);
	R1 = 14;
	R2 = (u64)&qq_print_moutvar;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	R2 = (u64)&qq_print_moutvar;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L5257;
L5259:
	msysc_m$print_startcon();
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Print@^?");
	qq_lib_prterror(asu64(R1));
L5257:
	goto L5246;
L5249:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5261;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5261;
	goto L5262;
L5261:
	R1 = 0;
	qq_print_moutdev = asi64(R1);
	goto L5260;
L5262:
	msysc_m$print_startcon();
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Can't do startprint...");
	qq_lib_prterror(asu64(R1));
L5260:
L5246:
	R1 = 0;
	qq_print_mgapneeded = asu8(R1);
	return;
}

static void qq_print_pch_startprintcon() {
    u64 R1, R2, R3; 
	struct $B3 v;
	R1 = 1;
	R2 = (u64)&v;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	R2 = (u64)&v;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&v;
	qq_print_pch_startprint(asu64(R1));
	return;
}

static void qq_print_pch_endprint() {
    u64 R1, R2; struct $B3 R1_B3; 
	u64 p;
	asu64(R1) = qq_print_mfmtstr;
	if (!asu64(R1)) goto L5266;
	R1 = 1;
	qq_print_printnextfmtchars(asi64(R1));
L5266:
	asi64(R1) = qq_print_moutdev;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5268;
	goto L5269;
L5268:
	R1 = (u64)&qq_print_moutvar;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L5267;
L5269:
L5267:
	asu64(R1) = qq_print_mfmtstr;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L5271;
	asu64(R1) = qq_print_mfmtstr;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = qq_print_mfmtstr;
	mlib_pcm_free(asu64(R2), asi64(R1));
L5271:
	R1 = (u64)&qq_print_noclevels;
	asi64(R1) = *(toi64p(R1)) -= 1;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L5273;
	R1 = tou64("resetoc??");
	qq_lib_prterror(asu64(R1));
L5273:
	asi64(R1) = qq_print_noclevels;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5275;
	R1 = 0;
	qq_print_moutdev = asi64(R1);
	goto L5274;
L5275:
	R1 = (u64)&qq_print_moutdevstack;
	asi64(R2) = qq_print_noclevels;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	qq_print_moutdev = asi64(R1);
	R1 = (u64)&qq_print_moutchanstack;
	asi64(R2) = qq_print_noclevels;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	qq_print_moutchan = asu64(R1);
	R1 = (u64)&qq_print_moutvarstack;
	asi64(R2) = qq_print_noclevels;
	(R1_B3) = *(struct $B3*)(((i64)R1+(i64)R2*16));
	qq_print_moutvar = (R1_B3);
	R1 = (u64)&qq_print_mgapstack;
	asi64(R2) = qq_print_noclevels;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	qq_print_mgapneeded = asu8(R1);
	R1 = (u64)&qq_print_mfmtstrstack;
	asi64(R2) = qq_print_noclevels;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	qq_print_mfmtstr = asu64(R1);
	R1 = (u64)&qq_print_mfmtcurrstack;
	asi64(R2) = qq_print_noclevels;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	qq_print_mfmtcurr = asu64(R1);
L5274:
	R1 = 0;
	qq_print_mgapneeded = asu8(R1);
	return;
}

static void qq_print_pch_strstartprint() {
    u64 R1, R2, R3; 
	struct $B3 p;
	R1 = 1;
	R2 = (u64)&p;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	R2 = (u64)&p;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&p;
	qq_print_pch_startprint(asu64(R1));
	return;
}

static void qq_print_pch_strendprint(u64 dest) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	asu64(R1) = qq_print_mfmtstr;
	if (!asu64(R1)) goto L5279;
	R1 = 1;
	qq_print_printnextfmtchars(asi64(R1));
L5279:
	asi64(R1) = qq_print_moutdev;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5281;
	R1 = tou64("STRENDPRT/NOT STR");
	qq_lib_prterror(asu64(R1));
L5281:
	(R1_B3) = qq_print_moutvar;
	asu64(R2) = dest;
	*(struct $B3*)(R2) = (R1_B3);
	R1 = 0;
	R2 = (u64)&qq_print_moutvar;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	qq_print_pch_endprint();
	return;
}

static void qq_print_pch_printspace() {
    u64 R1; 
	R1 = 0;
	qq_print_mgapneeded = asu8(R1);
	msysc_m$print_startcon();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	return;
}

static void qq_print_pch_readln(u64 dev) {
    u64 R1, R2, R3; 
	u64 ch;
	i64 length;
	u64 pdev;
	asu64(R1) = qq_print_kb_start;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5285;
	R1 = 1048576;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	qq_print_kb_start = asu64(R1);
	R1 = 1048576;
	qq_print_kb_size = asi64(R1);
	asu64(R1) = qq_print_kb_start;
	qq_print_kb_lastpos = asu64(R1);
	asu64(R1) = qq_print_kb_start;
	qq_print_kb_pos = asu64(R1);
	R1 = 0;
	qq_print_kb_length = asi64(R1);
	R1 = 0;
	qq_print_kb_lastlength = asi64(R1);
	R1 = 0;
	qq_print_kb_linelength = asi64(R1);
L5285:
	asu64(R1) = dev;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5287;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5288;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5289;
	goto L5290;
L5287:
// qq_print.pch_readln.doconsole:
L5291:
	asi64(R1) = qq_print_kb_size;
	asu64(R2) = qq_print_kb_start;
	R3 = 0;
	mlib_readlinen(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = qq_print_kb_start;
	asi64(R1) = strlen(asu64(R1));
	qq_print_kb_length = asi64(R1);
	goto L5286;
L5288:
	asu64(R1) = dev;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5293;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5294;
	goto L5295;
L5293:
	goto L5291;
	goto L5292;
L5294:
	asu64(R1) = qq_print_testfilech;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5297;
	R1 = tou64("R@2: file not open");
	qq_lib_prterror(asu64(R1));
L5297:
	asu64(R1) = qq_print_testfilech;
	ch = asu64(R1);
	goto L5292;
L5295:
	asu64(R1) = dev;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ch = asu64(R1);
L5292:
	asi64(R1) = qq_print_kb_size;
	asu64(R2) = qq_print_kb_start;
	asu64(R3) = ch;
	mlib_readlinen(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = qq_print_kb_start;
	asi64(R1) = strlen(asu64(R1));
	qq_print_kb_length = asi64(R1);
	goto L5286;
L5289:
	asu64(R1) = dev;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdev = asu64(R1);
	asu64(R1) = pdev;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5299;
	R1 = 0;
	qq_print_kb_length = asi64(R1);
	R1 = 0;
	asu64(R2) = qq_print_kb_start;
	*tou8p(R2) = asu8(R1);
	goto L5298;
L5299:
	asi64(R1) = length;
	asi64(R2) = qq_print_kb_size;
	if (asi64(R1) < asi64(R2)) goto L5300;
	R1 = tou64("KB overflow");
	qq_lib_prterror(asu64(R1));
	goto L5298;
L5300:
	asi64(R1) = length;
	qq_print_kb_length = asi64(R1);
	asi64(R1) = length;
	asu64(R2) = pdev;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = qq_print_kb_start;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L5298:
	goto L5286;
L5290:
	asu64(R1) = dev;
	R2 = tou64("readln@");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L5286:
	asu64(R1) = qq_print_kb_start;
	qq_print_kb_pos = asu64(R1);
	asu64(R1) = qq_print_kb_pos;
	qq_print_kb_lastpos = asu64(R1);
	asi64(R1) = qq_print_kb_length;
	qq_print_kb_linelength = asi64(R1);
	return;
}

static void qq_print_pch_sread(u64 fmt, u64 dest) {
    u64 R1, R2, R3, R4; 
	i64 fmtcode;
	u8 c;
	asu64(R1) = fmt;
	asi64(R1) = qq_print_getreadfmtcode(asu64(R1));
	fmtcode = asi64(R1);
	asu64(R1) = qq_print_kb_pos;
	qq_print_kb_lastpos = asu64(R1);
	asi64(R1) = qq_print_kb_length;
	qq_print_kb_lastlength = asi64(R1);
	asi64(R1) = fmtcode;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L5303;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L5304;
	R2 = 78;
	if (asi64(R1) == asi64(R2)) goto L5305;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L5306;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L5307;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L5308;
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L5309;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L5310;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5311;
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L5312;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L5313;
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L5314;
	goto L5315;
L5303:
	R1 = 0;
	asu64(R2) = dest;
	asi64(R3) = qq_print_kb_length;
	asu64(R4) = qq_print_kb_pos;
	asu64(R1) = qq_print_readint(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	qq_print_stepkbpos(asu64(R1));
	goto L5302;
L5304:
	asu64(R1) = dest;
	asi64(R2) = qq_print_kb_length;
	asu64(R3) = qq_print_kb_pos;
	asu64(R1) = qq_print_readreal(asu64(R3), asi64(R2), asu64(R1));
	qq_print_stepkbpos(asu64(R1));
	goto L5302;
L5305:
	asu64(R1) = dest;
	asi64(R2) = qq_print_kb_length;
	asu64(R3) = qq_print_kb_pos;
	asu64(R1) = qq_print_readname(asu64(R3), asi64(R2), asu64(R1));
	qq_print_stepkbpos(asu64(R1));
	goto L5302;
L5306:
	asu64(R1) = dest;
	asi64(R2) = qq_print_kb_length;
	asu64(R3) = qq_print_kb_pos;
	asu64(R1) = qq_print_readstring(asu64(R3), asi64(R2), asu64(R1));
	qq_print_stepkbpos(asu64(R1));
	goto L5302;
L5307:
	asu64(R1) = dest;
	asi64(R2) = qq_print_kb_length;
	asu64(R3) = qq_print_kb_pos;
	asu64(R1) = qq_print_readhex(asu64(R3), asi64(R2), asu64(R1));
	qq_print_stepkbpos(asu64(R1));
	goto L5302;
L5308:
	asu64(R1) = dest;
	asi64(R2) = qq_print_kb_length;
	asu64(R3) = qq_print_kb_pos;
	asu64(R1) = qq_print_readbin(asu64(R3), asi64(R2), asu64(R1));
	qq_print_stepkbpos(asu64(R1));
	goto L5302;
L5309:
	asu64(R1) = dest;
	asi64(R2) = qq_print_kb_length;
	asu64(R3) = qq_print_kb_pos;
	asu64(R1) = qq_print_readany(asu64(R3), asi64(R2), asu64(R1));
	qq_print_stepkbpos(asu64(R1));
	goto L5302;
L5310:
	asi64(R1) = qq_print_kb_length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5317;
	R1 = 0;
	asu64(R2) = dest;
	qq_strings_var_empty_string(asu64(R2), asi64(R1));
	goto L5316;
L5317:
	R1 = 1;
	asu64(R2) = dest;
	asi64(R3) = qq_print_kb_length;
	asu64(R4) = qq_print_kb_pos;
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = qq_print_kb_length;
	R2 = (u64)&qq_print_kb_pos;
	*tou64p(R2) += asu64(R1);
	R1 = 0;
	qq_print_kb_length = asi64(R1);
L5316:
	goto L5302;
L5311:
	asi64(R1) = qq_print_kb_length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5319;
	R1 = 0;
	asu64(R2) = dest;
	qq_strings_var_empty_string(asu64(R2), asi64(R1));
	goto L5318;
L5319:
	asu64(R1) = qq_print_kb_pos;
	asu8(R1) = *tou8p(R1);
	qq_print_termchar = asu8(R1);
// qq_print.pch_sread.dochar:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu8(R1) = qq_print_termchar;
	R1 = toi64(tou8(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&qq_print_kb_pos;
	(*tou64p(R1)) += 1;
	R1 = (u64)&qq_print_kb_length;
	(*toi64p(R1)) -=1;
L5318:
	goto L5302;
L5312:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu8(R1) = qq_print_termchar;
	R1 = toi64(tou8(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5302;
L5313:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = qq_print_itemerror;
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5302;
L5314:
	R1 = 1;
	asu64(R2) = dest;
	asi64(R3) = qq_print_kb_length;
	asu64(R4) = qq_print_kb_pos;
	asu64(R1) = qq_print_readint(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	qq_print_stepkbpos(asu64(R1));
	goto L5302;
L5315:
	R1 = tou64("SREAD/FMT?");
	qq_lib_prterror(asu64(R1));
L5302:
	return;
}

static void qq_print_pch_sreadln(u64 dev, u64 dest) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = dev;
	qq_print_pch_readln(asu64(R1));
	R1 = 1;
	asu64(R2) = dest;
	asi64(R3) = qq_print_kb_length;
	asu64(R4) = qq_print_kb_start;
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	return;
}

static u64 qq_print_readname(u64 s, i64 length, u64 dest) {
    u64 R1, R2, R3, R4; 
	u64 send;
	u64 itemstr;
	i64 itemlength;
	R1 = (u64)&itemlength;
	R2 = (u64)&itemstr;
	asi64(R3) = length;
	asu64(R4) = s;
	asu64(R1) = qq_print_readitem(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	send = asu64(R1);
	R1 = 1;
	asu64(R2) = dest;
	asi64(R3) = itemlength;
	asu64(R4) = itemstr;
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	asu64(R1) = dest;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_iconvlcn(asu64(R2), asi64(R1));
	asu64(R1) = send;
	goto L5322;
L5322:
	return asu64(R1);
}

static u64 qq_print_readstring(u64 s, i64 length, u64 dest) {
    u64 R1, R2, R3, R4; 
	u64 send;
	u64 itemstr;
	i64 itemlength;
	R1 = (u64)&itemlength;
	R2 = (u64)&itemstr;
	asi64(R3) = length;
	asu64(R4) = s;
	asu64(R1) = qq_print_readitem(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	send = asu64(R1);
	R1 = 1;
	asu64(R2) = dest;
	asi64(R3) = itemlength;
	asu64(R4) = itemstr;
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	asu64(R1) = send;
	goto L5323;
L5323:
	return asu64(R1);
}

static u64 qq_print_readint(u64 sold, i64 length, u64 dest, i64 dodec) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 s;
	u64 send;
	u64 itemstr;
	i64 itemlength;
	i64 numlength;
	R1 = (u64)&itemlength;
	R2 = (u64)&s;
	asi64(R3) = length;
	asu64(R4) = sold;
	asu64(R1) = qq_print_readitem(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	send = asu64(R1);
	asi64(R1) = dodec;
	asu64(R2) = dest;
	asi64(R3) = itemlength;
	asu64(R4) = s;
	qq_print_strtoint(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	asu64(R1) = send;
	goto L5324;
L5324:
	return asu64(R1);
}

static u64 qq_print_readhex(u64 sold, i64 length, u64 dest) {
    u64 R1, R2, R3; 
	struct $B16 str;
	u64 p;
	u64 s;
	u8 res;
	i64 aa;
	i64 a;
	i64 t;
	i64 nalloc;
	u8 c;
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5327;
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	qq_print_termchar = asu8(R1);
	asu64(R1) = sold;
	goto L5325;
L5327:
	goto L5329;
L5328:
	R1 = (u64)&sold;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
L5329:
	asi64(R1) = length;
	if (!asi64(R1)) goto L5331;
	asu64(R1) = sold;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L5328;
	asu64(R1) = sold;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5328;
L5331:
	asi64(R1) = length;
	R2 = 256;
	if (asi64(R1) > asi64(R2)) goto L5333;
	R1 = (u64)&str;
	s = asu64(R1);
	R1 = 0;
	nalloc = asi64(R1);
	goto L5332;
L5333:
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	nalloc = asi64(R1);
	asi64(R1) = nalloc;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	s = asu64(R1);
L5332:
	asu64(R1) = s;
	p = asu64(R1);
	goto L5335;
L5334:
	asu64(R1) = sold;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	c = asu8(R1);
	R1 = (u64)&sold;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) < asu64(R2)) goto L5338;
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 57;
	if (asu64(R1) > asu64(R2)) goto L5338;
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L5337;
L5338:
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 65;
	if (asu64(R1) < asu64(R2)) goto L5339;
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 70;
	if (asu64(R1) > asu64(R2)) goto L5339;
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L5337;
L5339:
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 95;
	if (asu64(R1) != asu64(R2)) goto L5340;
	goto L5337;
L5340:
	asu8(R1) = c;
	qq_print_termchar = asu8(R1);
	goto L5336;
L5337:
L5335:
	asi64(R1) = length;
	if (asi64(R1)) goto L5334;
L5336:
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = p;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 16;
	if (asi64(R1) > asi64(R2)) goto L5342;
	R1 = 1;
	t = asi64(R1);
	goto L5341;
L5342:
	R1 = 3;
	t = asi64(R1);
L5341:
	asu64(R1) = s;
	p = asu64(R1);
	asi64(R1) = t;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5344;
	goto L5345;
L5344:
	R1 = 0;
	aa = asi64(R1);
L5346:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5349;
	goto L5347;
L5349:
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 65;
	if (asu64(R1) >= asu64(R2)) goto L5351;
	asi64(R1) = aa;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu8(R2) = c;
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	aa = asi64(R1);
	goto L5350;
L5351:
	asi64(R1) = aa;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu8(R2) = c;
	R2 = tou64(tou8(R2));
	R3 = 65;
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	R2 = 10;
	asi64(R1) += asi64(R2);
	aa = asi64(R1);
L5350:
	goto L5346;
L5347:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = aa;
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5343;
L5345:
	R1 = tou64("Readhex/long");
	qq_lib_prterror(asu64(R1));
L5343:
	asi64(R1) = nalloc;
	if (!asi64(R1)) goto L5353;
	asi64(R1) = nalloc;
	asu64(R2) = s;
	mlib_pcm_free(asu64(R2), asi64(R1));
L5353:
	asu64(R1) = sold;
	goto L5325;
L5325:
	return asu64(R1);
}

static u64 qq_print_readbin(u64 sold, i64 length, u64 dest) {
    u64 R1, R2, R3; 
	struct $B16 str;
	u64 p;
	u64 s;
	u8 res;
	i64 aa;
	i64 a;
	i64 t;
	i64 nalloc;
	u8 c;
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5356;
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	qq_print_termchar = asu8(R1);
	asu64(R1) = sold;
	goto L5354;
L5356:
	goto L5358;
L5357:
	R1 = (u64)&sold;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
L5358:
	asi64(R1) = length;
	if (!asi64(R1)) goto L5360;
	asu64(R1) = sold;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L5357;
	asu64(R1) = sold;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5357;
L5360:
	asi64(R1) = length;
	R2 = 256;
	if (asi64(R1) > asi64(R2)) goto L5362;
	R1 = (u64)&str;
	s = asu64(R1);
	R1 = 0;
	nalloc = asi64(R1);
	goto L5361;
L5362:
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	nalloc = asi64(R1);
	asi64(R1) = nalloc;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	s = asu64(R1);
L5361:
	asu64(R1) = s;
	p = asu64(R1);
	goto L5364;
L5363:
	asu64(R1) = sold;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	c = asu8(R1);
	R1 = (u64)&sold;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) < asu64(R2)) goto L5367;
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 49;
	if (asu64(R1) > asu64(R2)) goto L5367;
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L5366;
L5367:
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 95;
	if (asu64(R1) != asu64(R2)) goto L5368;
	goto L5366;
L5368:
	asu8(R1) = c;
	qq_print_termchar = asu8(R1);
	goto L5365;
L5366:
L5364:
	asi64(R1) = length;
	if (asi64(R1)) goto L5363;
L5365:
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = p;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 64;
	if (asi64(R1) > asi64(R2)) goto L5370;
	R1 = 1;
	t = asi64(R1);
	goto L5369;
L5370:
	R1 = 3;
	t = asi64(R1);
L5369:
	asu64(R1) = s;
	p = asu64(R1);
	asi64(R1) = t;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5372;
	goto L5373;
L5372:
	R1 = 0;
	aa = asi64(R1);
L5374:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5377;
	goto L5375;
L5377:
	asi64(R1) = aa;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	asu8(R2) = c;
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	aa = asi64(R1);
	goto L5374;
L5375:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = aa;
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5371;
L5373:
	R1 = tou64("Readbin/long");
	qq_lib_prterror(asu64(R1));
L5371:
	asi64(R1) = nalloc;
	if (!asi64(R1)) goto L5379;
	asi64(R1) = nalloc;
	asu64(R2) = s;
	mlib_pcm_free(asu64(R2), asi64(R1));
L5379:
	asu64(R1) = sold;
	goto L5354;
L5354:
	return asu64(R1);
}

static u64 qq_print_readreal(u64 sold, i64 length, u64 dest) {
    u64 R1, R2, R3, R4; 
	struct $B24 str;
	r64 x;
	u64 send;
	u64 itemstr;
	i64 itemlength;
	i64 numlength;
	R1 = (u64)&itemlength;
	R2 = (u64)&itemstr;
	asi64(R3) = length;
	asu64(R4) = sold;
	asu64(R1) = qq_print_readitem(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	send = asu64(R1);
	asu64(R1) = dest;
	asi64(R2) = itemlength;
	asu64(R3) = itemstr;
	qq_print_strtoreal(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = send;
	goto L5380;
L5380:
	return asu64(R1);
}

static i64 qq_print_getreadfmtcode(u64 p) {
    u64 R1, R2, R3; 
	u8 c;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L5384;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5383;
L5384:
	R1 = 65;
	goto L5381;
L5383:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5386;
	msysc_m$print_startcon();
	R1 = tou64("P=%s");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Readfmt?");
	qq_lib_prterror(asu64(R1));
L5386:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5388;
	R1 = 65;
	goto L5381;
L5388:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	c = asu8(R1);
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 73;
	if (asu64(R1) == asu64(R2)) goto L5390;
	R2 = 82;
	if (asu64(R1) == asu64(R2)) goto L5390;
	R2 = 78;
	if (asu64(R1) == asu64(R2)) goto L5390;
	R2 = 83;
	if (asu64(R1) == asu64(R2)) goto L5390;
	R2 = 70;
	if (asu64(R1) == asu64(R2)) goto L5390;
	R2 = 84;
	if (asu64(R1) == asu64(R2)) goto L5390;
	R2 = 90;
	if (asu64(R1) == asu64(R2)) goto L5390;
	R2 = 67;
	if (asu64(R1) == asu64(R2)) goto L5390;
	R2 = 76;
	if (asu64(R1) == asu64(R2)) goto L5390;
	R2 = 72;
	if (asu64(R1) == asu64(R2)) goto L5390;
	R2 = 66;
	if (asu64(R1) == asu64(R2)) goto L5390;
	R2 = 65;
	if (asu64(R1) == asu64(R2)) goto L5390;
	R2 = 69;
	if (asu64(R1) == asu64(R2)) goto L5390;
	R2 = 68;
	if (asu64(R1) == asu64(R2)) goto L5390;
	goto L5391;
L5390:
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	goto L5381;
	goto L5389;
L5391:
L5389:
	R1 = tou64("Readfmt2?");
	qq_lib_prterror(asu64(R1));
	R1 = 0;
	goto L5381;
L5381:
	return asi64(R1);
}

static void qq_print_stepkbpos(u64 s) {
    u64 R1, R2; 
	i64 newlen;
	asu64(R1) = s;
	asu64(R2) = qq_print_kb_pos;
	asi64(R1) -= asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5394;
	goto L5392;
L5394:
	asi64(R1) = newlen;
	asi64(R2) = qq_print_kb_length;
	if (asi64(R1) < asi64(R2)) goto L5396;
	asu64(R1) = qq_print_kb_pos;
	asi64(R2) = qq_print_kb_length;
	R1 += (i64)R2;
	qq_print_kb_pos = asu64(R1);
	R1 = 0;
	qq_print_kb_length = asi64(R1);
	goto L5395;
L5396:
	asu64(R1) = qq_print_kb_pos;
	asi64(R2) = newlen;
	R1 += (i64)R2;
	qq_print_kb_pos = asu64(R1);
	asi64(R1) = newlen;
	R2 = (u64)&qq_print_kb_length;
	*toi64p(R2) -= asi64(R1);
L5395:
L5392:
	return;
}

static u64 qq_print_readany(u64 sold, i64 length, u64 dest) {
    u64 R1, R2, R3, R4; 
	struct $B16 str;
	u64 p;
	u64 s;
	u8 signd;
	u8 res;
	i64 aa;
	i64 digits;
	i64 expon;
	i64 other;
	i64 t;
	i64 nalloc;
	u8 c;
	u64 send;
	u64 itemstr;
	i64 itemlength;
	i64 numlength;
	i64 av_1;
	R1 = 0;
	qq_print_itemerror = asi64(R1);
	R1 = (u64)&itemlength;
	R2 = (u64)&s;
	asi64(R3) = length;
	asu64(R4) = sold;
	asu64(R1) = qq_print_readitem(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	send = asu64(R1);
	asu64(R1) = s;
	p = asu64(R1);
	R1 = 0;
	R2 = R1;
	other = asi64(R2);
	R2 = R1;
	expon = asi64(R2);
	digits = asi64(R1);
	asi64(R1) = itemlength;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5400;
L5398:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 43: case 45: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 95: goto L5404;
	case 44: case 47: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 68: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 96: case 97: case 98: case 99: case 100: goto L5403;
	case 46: case 69: case 101: goto L5405;
	default: goto L5403;
    };
// SWITCH
L5404:
	R1 = 1;
	digits = asi64(R1);
	goto L5401;
L5405:
	R1 = 1;
	expon = asi64(R1);
	goto L5401;
L5403:
	R1 = 1;
	other = asi64(R1);
L5401:
	if (--asi64(av_1)) goto L5398;
L5400:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = other;
	if (asi64(R1)) goto L5408;
	asi64(R1) = itemlength;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5407;
L5408:
	R1 = 5395539;
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = dest;
	asi64(R3) = itemlength;
	asu64(R4) = s;
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	goto L5406;
L5407:
	asi64(R1) = expon;
	if (!asi64(R1)) goto L5409;
	asu64(R1) = dest;
	asi64(R2) = itemlength;
	asu64(R3) = s;
	qq_print_strtoreal(asu64(R3), asi64(R2), asu64(R1));
	goto L5406;
L5409:
	R1 = 0;
	asu64(R2) = dest;
	asi64(R3) = itemlength;
	asu64(R4) = s;
	qq_print_strtoint(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
L5406:
	asu64(R1) = send;
	goto L5397;
L5397:
	return asu64(R1);
}

static u64 qq_print_readitem(u64 s, i64 length, u64 itemstr, u64 itemlength) {
    u64 R1, R2, R3; 
	u64 p;
	u8 quotechar;
	u8 c;
	goto L5412;
L5411:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
L5412:
	asi64(R1) = length;
	if (!asi64(R1)) goto L5414;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L5411;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5411;
L5414:
	asu64(R1) = s;
	asu64(R2) = itemstr;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5416;
	R1 = 0;
	qq_print_termchar = asu8(R1);
	R1 = 0;
	asu64(R2) = itemlength;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = s;
	goto L5410;
L5416:
	R1 = 0;
	quotechar = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) != asu64(R2)) goto L5418;
	R1 = 34;
	quotechar = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	goto L5417;
L5418:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 39;
	if (asu64(R1) != asu64(R2)) goto L5419;
	R1 = 39;
	quotechar = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
L5419:
L5417:
	asu64(R1) = s;
	R2 = R1;
	asu64(R3) = itemstr;
	*tou64p(R3) = asu64(R2);
	p = asu64(R1);
	goto L5421;
L5420:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L5424;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L5424;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L5424;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L5424;
	R2 = 59;
	if (asu64(R1) == asu64(R2)) goto L5424;
	goto L5425;
L5424:
	asu8(R1) = quotechar;
	if (asu8(R1)) goto L5428;
	asu64(R1) = p;
	asu64(R2) = s;
	if (asu64(R1) != asu64(R2)) goto L5427;
L5428:
	goto L5429;
L5427:
	asu8(R1) = c;
	qq_print_termchar = asu8(R1);
	goto L5422;
	goto L5423;
L5425:
// qq_print.readitem.normalchar:
L5429:
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	asu8(R2) = quotechar;
	R2 = tou64(tou8(R2));
	if (asu64(R1) != asu64(R2)) goto L5431;
	asi64(R1) = length;
	if (!asi64(R1)) goto L5433;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asu8(R2) = quotechar;
	R2 = tou64(tou8(R2));
	if (asu64(R1) != asu64(R2)) goto L5433;
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L5432;
L5433:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	qq_print_termchar = asu8(R1);
	asu8(R1) = qq_print_termchar;
	R1 = tou64(tou8(R1));
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L5436;
	asu8(R1) = qq_print_termchar;
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L5435;
L5436:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	qq_print_termchar = asu8(R1);
L5435:
	goto L5422;
L5432:
	goto L5430;
L5431:
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L5430:
L5423:
L5421:
	asi64(R1) = length;
	if (asi64(R1)) goto L5420;
L5422:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5438;
	R1 = 0;
	qq_print_termchar = asu8(R1);
L5438:
	asu64(R1) = p;
	asu64(R2) = itemstr;
	asu64(R2) = *tou64p(R2);
	asi64(R1) -= asi64(R2);
	asu64(R2) = itemlength;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = s;
	goto L5410;
L5410:
	return asu64(R1);
}

static void qq_print_strtoreal(u64 s, i64 length, u64 dest) {
    u64 R1, R2, R3, R4; 
	struct $B24 str;
	r64 x;
	i32 numlength;
	R1 = 2;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = length;
	R2 = 512;
	if (asi64(R1) >= asi64(R2)) goto L5442;
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5441;
L5442:
	asr64(R1) = 0.000000000000000000e+000;
	asu64(R2) = dest;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L5439;
L5441:
	asi64(R1) = length;
	asu64(R2) = s;
	R3 = (u64)&str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	qq_print_itemerror = asi64(R1);
	R1 = (u64)&numlength;
	R2 = (u64)&x;
	R3 = tou64("%lf%n");
	R4 = (u64)&str;
	asi32(R1) = sscanf(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5445;
	asi32(R1) = numlength;
	R1 = toi64(toi32(R1));
	asi64(R2) = length;
	if (asi64(R1) == asi64(R2)) goto L5444;
L5445:
	asi32(R1) = numlength;
	R1 = toi64(toi32(R1));
	asi64(R2) = length;
	if (asi64(R1) != asi64(R2)) goto L5447;
	asr64(R1) = 0.000000000000000000e+000;
	x = asr64(R1);
L5447:
	R1 = 1;
	qq_print_itemerror = asi64(R1);
L5444:
	asr64(R1) = x;
	asu64(R2) = dest;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
L5439:
	return;
}

static void qq_print_strtoint(u64 s, i64 length, u64 dest, i64 dodec) {
    u64 R1, R2, R3; 
	struct $B16 str;
	u64 p;
	u64 q;
	u8 signd;
	i64 aa;
	i64 a;
	i64 res;
	i64 cat;
	i64 t;
	i64 nalloc;
	u8 c;
	R1 = 0;
	qq_print_itemerror = asi64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5450;
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5448;
L5450:
	R1 = 0;
	signd = asu8(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L5452;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) != asu64(R2)) goto L5452;
	R1 = 1;
	signd = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	goto L5451;
L5452:
	asi64(R1) = length;
	if (!asi64(R1)) goto L5453;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) != asu64(R2)) goto L5453;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
L5453:
L5451:
	goto L5455;
L5454:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
L5455:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) != asu64(R2)) goto L5457;
	asi64(R1) = length;
	R2 = 1;
	if (asi64(R1) > asi64(R2)) goto L5454;
L5457:
	asu64(R1) = s;
	R2 = R1;
	q = asu64(R2);
	p = asu64(R1);
	goto L5459;
L5458:
	R1 = (u64)&q;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) < asu64(R2)) goto L5462;
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 57;
	if (asu64(R1) > asu64(R2)) goto L5462;
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L5461;
L5462:
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 95;
	if (asu64(R1) != asu64(R2)) goto L5464;
	goto L5463;
L5464:
	R1 = 1;
	qq_print_itemerror = asi64(R1);
	goto L5460;
L5463:
L5461:
L5459:
	asi64(R1) = length;
	if (asi64(R1)) goto L5458;
L5460:
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = p;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 18;
	if (asi64(R1) > asi64(R2)) goto L5466;
	R1 = 65;
	cat = asi64(R1);
	goto L5465;
L5466:
	asi64(R1) = length;
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L5467;
	R1 = tou64("9223372036854775808");
	asu64(R2) = s;
	asi64(R1) = mlib_cmpstring(asu64(R2), asu64(R1));
	R2 = -1;
	if (asi64(R1) == asi64(R2)) goto L5469;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5470;
	goto L5471;
L5469:
	R1 = 65;
	cat = asi64(R1);
	goto L5468;
L5470:
	R1 = 66;
	cat = asi64(R1);
	goto L5468;
L5471:
	R1 = 67;
	cat = asi64(R1);
L5468:
	goto L5465;
L5467:
	asi64(R1) = length;
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L5472;
	R1 = tou64("18446744073709551615");
	asu64(R2) = s;
	asi64(R1) = mlib_cmpstring(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L5474;
	R1 = 67;
	cat = asi64(R1);
	goto L5473;
L5474:
	R1 = 68;
	cat = asi64(R1);
L5473:
	goto L5465;
L5472:
	R1 = 68;
	cat = asi64(R1);
L5465:
	asi64(R1) = dodec;
	if (!asi64(R1)) goto L5476;
	R1 = 68;
	cat = asi64(R1);
L5476:
	asu8(R1) = signd;
	if (!asu8(R1)) goto L5478;
	asi64(R1) = cat;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L5480;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5481;
	goto L5482;
L5480:
	R1 = 65;
	cat = asi64(R1);
	goto L5479;
L5481:
	R1 = 68;
	cat = asi64(R1);
	goto L5479;
L5482:
L5479:
L5478:
	asi64(R1) = cat;
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L5484;
	goto L5485;
L5484:
	R1 = 1;
	t = asi64(R1);
	goto L5483;
L5485:
	R1 = 3;
	t = asi64(R1);
L5483:
	asu64(R1) = s;
	p = asu64(R1);
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5487;
	R1 = 0;
	aa = asi64(R1);
L5488:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5491;
	goto L5489;
L5491:
	asi64(R1) = aa;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asu8(R2) = c;
	R2 = tou64(tou8(R2));
	R3 = 48;
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	aa = asi64(R1);
	goto L5488;
L5489:
	asu8(R1) = signd;
	if (!asu8(R1)) goto L5493;
	asi64(R1) = aa;
	asi64(R1) = -asi64(R1);
	aa = asi64(R1);
L5493:
	asi64(R1) = t;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = aa;
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5486;
L5487:
	asu64(R1) = dest;
	asi64(R2) = length;
	asu64(R3) = s;
	qq_decimal_var_make_dec_str(asu64(R3), asi64(R2), asu64(R1));
L5486:
L5448:
	return;
}

static void qq_print_printnextfmtchars(i64 lastx) {
    u64 R1, R2; 
	u8 c;
	u64 pstart;
	i64 n;
	asu64(R1) = qq_print_mfmtcurr;
	pstart = asu64(R1);
	R1 = 0;
	n = asi64(R1);
L5495:
	asu64(R1) = qq_print_mfmtcurr;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 35;
	if (asu64(R1) == asu64(R2)) goto L5498;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L5499;
	R2 = 126;
	if (asu64(R1) == asu64(R2)) goto L5500;
	goto L5501;
L5498:
	asi64(R1) = lastx;
	if (!asi64(R1)) goto L5503;
	goto L5504;
L5503:
	R1 = (u64)&qq_print_mfmtcurr;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	if (!asi64(R1)) goto L5506;
	asi64(R1) = n;
	asu64(R2) = pstart;
	qq_print_printstr_n(asu64(R2), asi64(R1));
L5506:
	goto L5494;
	goto L5497;
L5499:
	asi64(R1) = n;
	if (!asi64(R1)) goto L5508;
	asi64(R1) = n;
	asu64(R2) = pstart;
	qq_print_printstr_n(asu64(R2), asi64(R1));
	goto L5507;
L5508:
	asi64(R1) = lastx;
	if (asi64(R1)) goto L5509;
	R1 = 1;
	R2 = tou64("|");
	qq_print_printstr_n(asu64(R2), asi64(R1));
L5509:
L5507:
	goto L5494;
	goto L5497;
L5500:
	asi64(R1) = n;
	if (!asi64(R1)) goto L5511;
	asi64(R1) = n;
	asu64(R2) = pstart;
	qq_print_printstr_n(asu64(R2), asi64(R1));
	R1 = 0;
	n = asi64(R1);
L5511:
	R1 = (u64)&qq_print_mfmtcurr;
	(*tou64p(R1)) += 1;
	asu64(R1) = qq_print_mfmtcurr;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	if (!asu8(R1)) goto L5513;
	R1 = (u64)&qq_print_mfmtcurr;
	(*tou64p(R1)) += 1;
	R1 = 1;
	R2 = (u64)&c;
	qq_print_printstr_n(asu64(R2), asi64(R1));
L5513:
	asu64(R1) = qq_print_mfmtcurr;
	pstart = asu64(R1);
	goto L5497;
L5501:
// qq_print.printnextfmtchars.skip:
L5504:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	R1 = (u64)&qq_print_mfmtcurr;
	(*tou64p(R1)) += 1;
L5497:
	goto L5495;
L5494:
	return;
}

static void qq_print_pch_setformat(u64 p) {
    u64 R1, R2, R3; 
	i64 n;
	u64 s;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5516;
	R1 = tou64("(str)");
	qq_lib_prterror(asu64(R1));
L5516:
	asu64(R1) = qq_print_mfmtstr;
	if (!asu64(R1)) goto L5518;
	R1 = tou64("Setfmt?");
	qq_lib_prterror(asu64(R1));
L5518:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	qq_print_mfmtstr = asu64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L5520;
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = qq_print_mfmtstr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L5520:
	asu64(R1) = qq_print_mfmtstr;
	asi64(R2) = n;
	R1 += (i64)R2;
	s = asu64(R1);
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = qq_print_mfmtstr;
	qq_print_mfmtcurr = asu64(R1);
	return;
}

static u64 qq_print_pc_getfmt(u64 p, u64 fmt) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L5524;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5523;
L5524:
	R1 = (u64)&qq_print_defaultfmt;
	goto L5522;
L5523:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5526;
	R1 = tou64("pc_getfmt/not str?");
	qq_lib_prterror(asu64(R1));
L5526:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5528;
	R1 = (u64)&qq_print_defaultfmt;
	goto L5527;
L5528:
	asu64(R1) = fmt;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = fmt;
L5527:
L5522:
	goto L5521;
L5521:
	return asu64(R1);
}

static void qq_print_addstring(u64 p, u64 t, i64 n) {
    u64 R1, R2, R3, R4; 
	i64 oldlen;
	i64 newlen;
	i64 oldbytes;
	i64 newbytes;
	u64 newptr;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5532;
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5531;
L5532:
	goto L5529;
L5531:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L5534;
	asu64(R1) = t;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
L5534:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	oldlen = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5536;
	asi64(R1) = oldlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5538;
	asi64(R1) = n;
	asu64(R2) = t;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5537;
L5538:
	asi64(R1) = n;
	asu64(R2) = t;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R4) = oldlen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = oldlen;
	asi64(R2) = n;
	asi64(R1) += asi64(R2);
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L5537:
	goto L5529;
L5536:
	asi64(R1) = oldlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5540;
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = t;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L5539;
L5540:
	asi64(R1) = oldlen;
	asi64(R2) = n;
	asi64(R1) += asi64(R2);
	newlen = asi64(R1);
	asu64(R1) = p;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	oldbytes = asi64(R1);
	asi64(R1) = oldlen;
	asi64(R2) = n;
	asi64(R1) += asi64(R2);
	newbytes = asi64(R1);
	asi64(R1) = newbytes;
	asi64(R2) = oldbytes;
	if (asi64(R1) > asi64(R2)) goto L5542;
	asi64(R1) = n;
	asu64(R2) = t;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R4) = oldlen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L5541;
L5542:
	asi64(R1) = newbytes;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	newptr = asu64(R1);
	asi64(R1) = oldlen;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = newptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	asu64(R2) = t;
	asu64(R3) = newptr;
	asi64(R4) = oldlen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = oldbytes;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = newptr;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5541:
	asi64(R1) = newlen;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L5539:
L5529:
	return;
}

static void qq_print_domultichar(u64 p, i64 n, u64 dest, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B71 str;
	u64 q;
	i64 i;
	i64 nchars;
	i64 av_1;
	R1 = (u64)&str;
	q = asu64(R1);
	asi64(R1) = n;
	nchars = asi64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5546;
L5544:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5548;
	goto L5546;
L5548:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&q;
	(*tou64p(R1)) += 1;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L5544;
L5546:
	R1 = 0;
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = fmt;
	asi64(R2) = nchars;
	asu64(R3) = dest;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	return;
}

static void qq_print_printstr_n(u64 s, i64 n) {
    u64 R1, R2, R3, R4; 
	u64 p;
	i64 x;
	asi64(R1) = n;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L5551;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
L5551:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5553;
	goto L5549;
L5553:
	asi64(R1) = qq_print_moutdev;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5555;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5556;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5557;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5558;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5559;
	goto L5560;
L5555:
	R1 = 0;
	asi64(R2) = n;
	asu64(R3) = s;
	msysc_printstrn_app(asu64(R3), asi64(R2), asu64(R1));
	goto L5554;
L5556:
	asu64(R1) = qq_print_moutchan;
	asi64(R2) = n;
	asu64(R3) = s;
	msysc_printstrn_app(asu64(R3), asi64(R2), asu64(R1));
	goto L5554;
L5557:
	asi64(R1) = n;
	asu64(R2) = s;
	R3 = (u64)&qq_print_moutvar;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	goto L5554;
L5558:
	R1 = (u64)&qq_print_moutvar;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5562;
	R1 = tou64("prtstrn1");
	qq_lib_prterror(asu64(R1));
L5562:
	asi64(R1) = n;
	asu64(R2) = s;
	R3 = (u64)&qq_print_moutvar;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	goto L5554;
L5559:
	goto L5554;
L5560:
L5554:
L5549:
	return;
}

static void qq_print_pch_strtoval(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3, R4; 
	i64 fmtcode;
	i64 length;
	u8 oldmutable;
	u64 q;
	struct $B64 str;
	u64 s;
	R1 = (u64)&str;
	s = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1024;
	if (asi64(R1) >= asi64(R2)) goto L5565;
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asu64(R3) = q;
	R4 = 16;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5564;
L5565:
	R1 = tou64("");
	R2 = tou64("STRTOVAL/string too long");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L5564:
	asu64(R1) = fmt;
	asi64(R1) = qq_print_getreadfmtcode(asu64(R1));
	fmtcode = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5567;
	R1 = tou64("strval");
	qq_lib_prterror(asu64(R1));
L5567:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asi64(R1) = fmtcode;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L5569;
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L5570;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L5571;
	R2 = 78;
	if (asi64(R1) == asi64(R2)) goto L5572;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L5573;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L5574;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L5575;
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L5576;
	goto L5577;
L5569:
	R1 = 0;
	asu64(R2) = dest;
	asi64(R3) = length;
	asu64(R4) = s;
	asu64(R1) = qq_print_readint(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	goto L5568;
L5570:
	R1 = 1;
	asu64(R2) = dest;
	asi64(R3) = length;
	asu64(R4) = s;
	asu64(R1) = qq_print_readint(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	goto L5568;
L5571:
	asu64(R1) = dest;
	asi64(R2) = length;
	asu64(R3) = s;
	asu64(R1) = qq_print_readreal(asu64(R3), asi64(R2), asu64(R1));
	goto L5568;
L5572:
	asu64(R1) = dest;
	asi64(R2) = length;
	asu64(R3) = s;
	asu64(R1) = qq_print_readname(asu64(R3), asi64(R2), asu64(R1));
	goto L5568;
L5573:
	asu64(R1) = dest;
	asi64(R2) = length;
	asu64(R3) = s;
	asu64(R1) = qq_print_readstring(asu64(R3), asi64(R2), asu64(R1));
	goto L5568;
L5574:
	asu64(R1) = dest;
	asi64(R2) = length;
	asu64(R3) = s;
	asu64(R1) = qq_print_readhex(asu64(R3), asi64(R2), asu64(R1));
	goto L5568;
L5575:
	asu64(R1) = dest;
	asi64(R2) = length;
	asu64(R3) = s;
	asu64(R1) = qq_print_readbin(asu64(R3), asi64(R2), asu64(R1));
	goto L5568;
L5576:
	asu64(R1) = dest;
	asi64(R2) = length;
	asu64(R3) = s;
	asu64(R1) = qq_print_readany(asu64(R3), asi64(R2), asu64(R1));
	goto L5568;
L5577:
	R1 = tou64("strval:fmt?");
	qq_lib_prterror(asu64(R1));
L5568:
	return;
}

static void qq_print_tostr_int(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3, R4, R5; 
	struct $B64 str;
	asu64(R1) = fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 77;
	if (asu64(R1) == asu64(R2)) goto L5580;
	R2 = 68;
	if (asu64(R1) == asu64(R2)) goto L5580;
	R2 = 67;
	if (asu64(R1) == asu64(R2)) goto L5581;
	goto L5582;
L5580:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	R3 = 8;
	asu64(R4) = p;
	R5 = 8;
	R4 += (i64)R5;
	qq_print_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	goto L5579;
L5581:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5579;
L5582:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asu64(R3) = p;
	R4 = 8;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asi64(R1) = msysc_i64tostrfmt(asi64(R3), asu64(R2), asu64(R1));
L5579:
	asu64(R1) = fmt;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5584;
	R1 = 2;
	R2 = tou64("I:");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5584:
	R1 = (u64)&str;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&str;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_print_tostr_real(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3, R4; 
	struct $B64 str;
	struct $B64 str2;
	struct $B2 cfmt;
	i64 n;
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L5587;
	R1 = 46;
	R2 = (u64)&cfmt;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 42;
	R2 = (u64)&cfmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cfmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cfmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("v");
	asu64(R2) = fmt;
	R3 = 1;
	asi8(R2) = *toi8p(((i64)R2+(i64)R3));
	R2 = toi64(toi8(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = (u64)&cfmt;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
	goto L5586;
L5587:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("fmt");
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
L5586:
	R1 = (u64)&str;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) >= asi64(R2)) goto L5589;
	asu64(R1) = fmt;
	asi64(R2) = n;
	R3 = (u64)&str2;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&str2;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L5589:
	R1 = (u64)&str;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&str;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_print_tostr_str(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3, R4, R5; 
	i64 oldlen;
	i64 newlen;
	u64 s;
	struct $B5 str;
	u64 q;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	oldlen = asi64(R1);
	asi64(R1) = oldlen;
	newlen = asi64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5593;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = newlen;
	if (asi64(R1) <= asi64(R2)) goto L5592;
L5593:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5595;
	R1 = 2;
	R2 = (u64)&newlen;
	*toi64p(R2) += asi64(R1);
L5595:
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = newlen;
	if (asi64(R1) <= asi64(R2)) goto L5597;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	newlen = asi64(R1);
L5597:
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	s = asu64(R1);
	asu64(R1) = fmt;
	asi64(R2) = oldlen;
	asu64(R3) = s;
	asu64(R4) = q;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asi64(R1) = msysc_strtostrfmt(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = newlen;
	asu64(R2) = s;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = s;
	mlib_pcm_free(asu64(R2), asi64(R1));
	goto L5591;
L5592:
	asi64(R1) = oldlen;
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5591:
	return;
}

static void qq_print_pch_tostr(u64 a, u64 b, u64 result) {
    u64 R1, R2, R3; 
	struct $B3 fmt;
	u64 ifmt;
	u64 p;
	R1 = (u64)&fmt;
	asu64(R2) = b;
	asu64(R1) = qq_print_pc_getfmt(asu64(R2), asu64(R1));
	ifmt = asu64(R1);
	R1 = 0;
	asu64(R1) = qq_strings_obj_new_string(asi64(R1));
	p = asu64(R1);
	R1 = 0;
	qq_print_listdepth = asi64(R1);
	asu64(R1) = p;
	asu64(R2) = ifmt;
	asu64(R3) = a;
	qq_print_tostr(asu64(R3), asu64(R2), asu64(R1));
	R1 = 265;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = result;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_print_tostr_range(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3, R4, R5; 
	struct $B64 str;
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asu64(R3) = p;
	R4 = 0;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	R4 = 16;
	R5 = 63;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	asi64(R1) = msysc_i64tostrfmt(asi64(R3), asu64(R2), asu64(R1));
	R1 = tou64("..");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = -1;
	R2 = (u64)&str;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asu64(R3) = p;
	R4 = 8;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asi64(R1) = msysc_i64tostrfmt(asi64(R3), asu64(R2), asu64(R1));
	R1 = -1;
	R2 = (u64)&str;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_print_tostr_array(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3, R4; 
	struct $B64 str;
	u64 q;
	i64 i;
	i64 m;
	i64 elemtype;
	i64 a;
	i64 b;
	i64 lower;
	i64 length;
	struct $B3 v;
	u64 pa;
	u64 ptr;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	m = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L5602;
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asu64(R1) = pa;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	lower = asi64(R1);
	asu64(R1) = pa;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	goto L5601;
L5602:
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = pa;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	length = asi64(R1);
	R1 = (u64)&qq_tables_ttlower;
	asu64(R2) = pa;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	lower = asi64(R1);
	R1 = (u64)&qq_tables_tttarget;
	asu64(R2) = pa;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemtype = asi64(R1);
L5601:
	asi64(R1) = lower;
	a = asi64(R1);
	asi64(R1) = length;
	asi64(R2) = lower;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	b = asi64(R1);
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = fmt;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5604;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#[#:#]A");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_tables_ttname;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lower;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&qq_tables_ttname;
	asi64(R2) = elemtype;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = -1;
	R2 = (u64)&str;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5604:
	R1 = -1;
	R2 = tou64("(");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = a;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = b;
	if (asi64(R1) > asi64(R2)) goto L5607;
L5605:
	R1 = 0;
	R2 = (u64)&v;
	asi64(R3) = elemtype;
	asu64(R4) = q;
	qq_packed_var_loadpacked(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = elemtype;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&q;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = dest;
	asu64(R2) = fmt;
	R3 = (u64)&v;
	qq_print_tostr(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	asi64(R2) = b;
	if (asi64(R1) >= asi64(R2)) goto L5609;
	R1 = 1;
	R2 = tou64(",");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5609:
	i += 1; if (i <= b) goto L5605;
L5607:
	R1 = 1;
	R2 = tou64(")");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_print_tostr_bits(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3, R4, R5; 
	struct $B64 str;
	u64 q;
	i64 i;
	i64 m;
	i64 elemtype;
	i64 a;
	i64 b;
	i64 bitwidthx;
	i64 offset;
	struct $B3 v;
	u64 pa;
	u64 ptr;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	m = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = pa;
	R2 = 6;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	a = asi64(R1);
	asu64(R1) = pa;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = a;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	b = asi64(R1);
	R1 = (u64)&qq_tables_ttbitwidth;
	asi64(R2) = elemtype;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	bitwidthx = asi64(R1);
	asu64(R1) = pa;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = bitwidthx;
	asi64(R1) *= asi64(R2);
	offset = asi64(R1);
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = fmt;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5612;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#[#:#]A");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_tables_ttname;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pa;
	R2 = 6;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&qq_tables_ttname;
	asi64(R2) = elemtype;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = -1;
	R2 = (u64)&str;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5612:
	R1 = -1;
	R2 = tou64("(");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = a;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = b;
	if (asi64(R1) > asi64(R2)) goto L5615;
L5613:
	R1 = (u64)&v;
	R2 = 0;
	asi64(R3) = elemtype;
	asi64(R4) = offset;
	asu64(R5) = q;
	qq_vars_var_loadbit(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = bitwidthx;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = offset;
	R2 = 8;
	if (asi64(R1) < asi64(R2)) goto L5617;
	R1 = 0;
	offset = asi64(R1);
	R1 = (u64)&q;
	(*tou64p(R1)) += 1;
L5617:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	R3 = (u64)&v;
	qq_print_tostr(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	asi64(R2) = b;
	if (asi64(R1) >= asi64(R2)) goto L5619;
	R1 = 1;
	R2 = tou64(",");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5619:
	i += 1; if (i <= b) goto L5613;
L5615:
	R1 = 1;
	R2 = tou64(")");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_print_tostr_struct(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 q;
	i64 i;
	i64 m;
	i64 nfields;
	i64 needcomma;
	struct $B3 v;
	u64 pa;
	u64 ptr;
	u64 d;
	u64 r;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = pa;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	m = asi64(R1);
	R1 = (u64)&qq_tables_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	nfields = asi64(R1);
	R1 = 0;
	needcomma = asi64(R1);
	R1 = -1;
	R2 = tou64("(");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nfields;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5623;
L5621:
	R1 = 0;
	R2 = (u64)&v;
	asu64(R3) = r;
	asu64(R3) = *tou64p(R3);
	R4 = 116;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	asu64(R4) = pa;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R5) = r;
	asu64(R5) = *tou64p(R5);
	R6 = 108;
	asi16(R5) = *toi16p(((i64)R5+(i64)R6));
	R5 = toi64(toi16(R5));
	R4 += (i64)R5;
	qq_packed_var_loadpacked(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = needcomma;
	if (!asi64(R1)) goto L5625;
	R1 = -1;
	R2 = tou64(",");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5625:
	R1 = 1;
	needcomma = asi64(R1);
	asu64(R1) = dest;
	asu64(R2) = fmt;
	R3 = (u64)&v;
	qq_print_tostr(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&r;
	(*tou64p(R1)) += 8;
	i += 1; if (i <= nfields) goto L5621;
L5623:
	R1 = -1;
	R2 = tou64(")");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_print_tostr_set(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3, R4; 
	struct $B64 str;
	u64 q;
	i64 i;
	i64 j;
	i64 first;
	struct $B3 v;
	u64 s;
	asu64(R1) = fmt;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5628;
	R1 = (u64)&qq_print_defaultfmt;
	fmt = asu64(R1);
L5628:
	R1 = 1;
	R2 = tou64("[");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	R1 = 1;
	first = asi64(R1);
	R1 = 0;
	i = asi64(R1);
	goto L5630;
L5629:
	asi64(R1) = i;
	asu64(R2) = s;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_lib_testelem(asu64(R2), asi64(R1));
	if (!asi64(R1)) goto L5633;
	asi64(R1) = i;
	R2 = 1;
	asi64(R1) += asi64(R2);
	j = asi64(R1);
	goto L5635;
L5634:
	R1 = (u64)&j;
	(*toi64p(R1)) += 1;
L5635:
	asi64(R1) = j;
	asu64(R2) = s;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) >= asi64(R2)) goto L5637;
	asi64(R1) = j;
	asu64(R2) = s;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_lib_testelem(asu64(R2), asi64(R1));
	if (asi64(R1)) goto L5634;
L5637:
	R1 = (u64)&j;
	(*toi64p(R1)) -=1;
	asi64(R1) = first;
	if (asi64(R1)) goto L5639;
	R1 = 1;
	R2 = tou64(",");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5639:
	R1 = 0;
	first = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) != asi64(R2)) goto L5641;
	R1 = 1;
	R2 = (u64)&v;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = i;
	R2 = (u64)&v;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5640;
L5641:
	R1 = 4;
	R2 = (u64)&v;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = i;
	R2 = (u64)&v;
	R3 = 16;
	R4 = 63;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = j;
	R2 = (u64)&v;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5640:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	R3 = (u64)&v;
	qq_print_tostr(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = j;
	R2 = 1;
	asi64(R1) += asi64(R2);
	i = asi64(R1);
	goto L5632;
L5633:
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
L5632:
L5630:
	asi64(R1) = i;
	asu64(R2) = s;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) < asi64(R2)) goto L5629;
	R1 = 1;
	R2 = tou64("]");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_print_tostr_dict(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3; 
	struct $B64 str;
	u64 q;
	i64 i;
	i64 length;
	i64 needcomma;
	u64 pa;
	R1 = 0;
	needcomma = asi64(R1);
	asu64(R1) = fmt;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5644;
	R1 = (u64)&qq_print_defaultfmt;
	fmt = asu64(R1);
L5644:
	R1 = -1;
	R2 = tou64("[");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5647;
L5645:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5649;
	R1 = 2;
	R2 = (u64)&q;
	*tou64p(R2) += asu64(R1)*16;
	goto L5646;
L5649:
	asi64(R1) = needcomma;
	if (!asi64(R1)) goto L5651;
	R1 = 1;
	R2 = tou64(",");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5651:
	R1 = 1;
	needcomma = asi64(R1);
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = q;
	qq_print_tostr(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
	R1 = 1;
	R2 = tou64(":");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = q;
	qq_print_tostr(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
L5646:
	i += -1; if (i >= 1) goto L5645;
L5647:
	R1 = 1;
	R2 = tou64("]");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_print_tostr_decimal(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3; 
	u64 s;
	R1 = 0;
	asu64(R2) = p;
	asu64(R1) = qq_decimal_var_tostr_dec(asu64(R2), asi64(R1));
	s = asu64(R1);
	R1 = -1;
	asu64(R2) = s;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = qq_decimal_decstrsize;
	asu64(R2) = s;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static void qq_print_tostr(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3, R4; 
	struct $B64 str;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5655;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5656;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5657;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5658;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5659;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5659;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5660;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5660;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5661;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5662;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5663;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5664;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5665;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5666;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5667;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L5668;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L5669;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L5670;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L5671;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L5672;
	goto L5673;
L5655:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = p;
	qq_print_tostr_int(asu64(R3), asu64(R2), asu64(R1));
	goto L5654;
L5656:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = p;
	qq_print_tostr_real(asu64(R3), asu64(R2), asu64(R1));
	goto L5654;
L5657:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = p;
	qq_print_tostr_str(asu64(R3), asu64(R2), asu64(R1));
	goto L5654;
L5658:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = p;
	qq_print_tostr_range(asu64(R3), asu64(R2), asu64(R1));
	goto L5654;
L5659:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = p;
	qq_print_tostr_list(asu64(R3), asu64(R2), asu64(R1));
	goto L5654;
L5660:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = p;
	qq_print_tostr_array(asu64(R3), asu64(R2), asu64(R1));
	goto L5654;
L5661:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = p;
	qq_print_tostr_bits(asu64(R3), asu64(R2), asu64(R1));
	goto L5654;
L5662:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = p;
	qq_print_tostr_set(asu64(R3), asu64(R2), asu64(R1));
	goto L5654;
L5663:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = p;
	qq_print_tostr_struct(asu64(R3), asu64(R2), asu64(R1));
	goto L5654;
L5664:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = p;
	qq_print_tostr_decimal(asu64(R3), asu64(R2), asu64(R1));
	goto L5654;
L5665:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = p;
	qq_print_tostr_dict(asu64(R3), asu64(R2), asu64(R1));
	goto L5654;
L5666:
	R1 = -1;
	R2 = tou64("<Void>");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	goto L5654;
L5667:
	asu64(R1) = fmt;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5675;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#<#>:");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5677;
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	goto L5676;
L5677:
	R1 = tou64("");
L5676:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = -1;
	R2 = (u64)&str;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5675:
// qq_print.tostr.showptr:
L5678:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5680;
	R1 = -1;
	R2 = tou64("nil");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	goto L5679;
L5680:
	R1 = -1;
	R2 = tou64("H");
	asu64(R3) = p;
	R4 = 8;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5679:
	goto L5654;
L5668:
	asu64(R1) = fmt;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5682;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#<#>:");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5684;
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	goto L5683;
L5684:
	R1 = tou64("");
L5683:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = -1;
	R2 = (u64)&str;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5682:
	goto L5678;
	goto L5654;
L5669:
	asu64(R1) = fmt;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5686;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#<#>(#,#):");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5688;
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	goto L5687;
L5688:
	R1 = tou64("");
L5687:
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = -1;
	R2 = (u64)&str;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5686:
	goto L5678;
	goto L5654;
L5670:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5690;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("<#:\"#\">");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_tables_namenames;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 124;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = -1;
	R2 = (u64)&str;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	goto L5689;
L5690:
	R1 = -1;
	R2 = tou64("<nil>");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5689:
	goto L5654;
L5671:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = -1;
	R2 = (u64)&str;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	goto L5654;
L5672:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("(#)");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_pcltabs_pclnames;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 1;
	R1 += (i64)R2;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = -1;
	R2 = (u64)&str;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	goto L5654;
L5673:
	asu64(R1) = p;
	R2 = tou64("Tostr:");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L5654:
	return;
}

static void qq_print_tostr_list(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3; 
	u64 q;
	i64 i;
	i64 n;
	u8 c;
	u64 r;
	i64 av_1;
	R1 = (u64)&qq_print_listdepth;
	(*toi64p(R1)) += 1;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = r;
	R2 = 0;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L5694;
	asi64(R1) = qq_print_listdepth;
	R2 = 4;
	if (asi64(R1) <= asi64(R2)) goto L5693;
L5694:
	R1 = 3;
	R2 = tou64("...");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&qq_print_listdepth;
	(*toi64p(R1)) -=1;
	goto L5691;
L5693:
	asu64(R1) = r;
	R2 = 0;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asi64(R1) = -asi64(R1);
	asu64(R2) = r;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5696;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	goto L5695;
L5696:
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = r;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	n = asi64(R1);
L5695:
	asu64(R1) = fmt;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5698;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5701;
L5699:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = q;
	qq_print_tostr(asu64(R3), asu64(R2), asu64(R1));
	R1 = -1;
	R2 = tou64("\n");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L5699;
L5701:
	goto L5697;
L5698:
	R1 = 1;
	R2 = tou64("(");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = n;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5704;
L5702:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = q;
	qq_print_tostr(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5706;
	R1 = 1;
	R2 = tou64(",");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5706:
	i += -1; if (i >= 1) goto L5702;
L5704:
	R1 = 1;
	R2 = tou64(")");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5697:
	asu64(R1) = r;
	R2 = 0;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asi64(R1) = -asi64(R1);
	asu64(R2) = r;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&qq_print_listdepth;
	(*toi64p(R1)) -=1;
L5691:
	return;
}

static void qq_records_var_make_record(u64 a, u64 dest, i64 n, i64 rectype) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 p;
	u64 b;
	i64 m;
	i64 av_1;
	R1 = 0;
	asi64(R2) = rectype;
	asu64(R1) = qq_records_obj_new_record(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = rectype;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	m = asi64(R1);
	asi64(R1) = n;
	asi64(R2) = m;
	if (asi64(R1) >= asi64(R2)) goto L5709;
	R1 = tou64("");
	R2 = tou64("Too few elements");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L5708;
L5709:
	asi64(R1) = n;
	asi64(R2) = m;
	if (asi64(R1) <= asi64(R2)) goto L5710;
	msysc_m$print_startcon();
	R1 = tou64("N=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("M=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = m;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("Too many elements");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L5710:
L5708:
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5713;
L5711:
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = b;
	*(struct $B3*)(R2) = (R1_B3);
	R1 = (u64)&a;
	(*tou64p(R1)) += 16;
	R1 = (u64)&b;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L5711;
L5713:
	R1 = 268;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = rectype;
	asu64(R2) = p;
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = p;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 qq_records_obj_new_record(i64 m, u64 defval) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 p;
	u64 a;
	i64 n;
	i64 av_1;
	i64 av_2;
	asu64(R1) = qq_vars_obj_new();
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	n = asi64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L5716;
	asi64(R1) = n;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	a = asu64(R2);
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = defval;
	if (!asu64(R1)) goto L5718;
	asu64(R1) = defval;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5718;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5721;
L5719:
	asu64(R1) = defval;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = a;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5723;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L5723:
	R1 = (u64)&a;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L5719;
L5721:
	goto L5717;
L5718:
	asi64(R1) = n;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5726;
L5724:
	R1 = 1;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&a;
	(*tou64p(R1)) += 16;
	if (--asi64(av_2)) goto L5724;
L5726:
L5717:
L5716:
	asu64(R1) = p;
	goto L5714;
L5714:
	return asu64(R1);
}

static void qq_records_obj_free_record(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	i64 av_1;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5730;
L5728:
	asu64(R1) = q;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5732;
	asu64(R1) = q;
	qq_vars_var_unshareu(asu64(R1));
L5732:
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L5728;
L5730:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L5734;
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L5734:
	asu64(R1) = p;
	mlib_pcm_free32(asu64(R1));
	return;
}

static void qq_records_var_dupl_record(u64 a) {
    u64 R1, R2, R3, R4; struct $B31 R1_B31; struct $B3 R1_B3; 
	u64 p;
	u64 q;
	u64 plist;
	u64 qlist;
	i64 length;
	i64 av_1;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = qq_vars_obj_new();
	q = asu64(R1);
	asu64(R1) = p;
	(R1_B31) = *(struct $B31*)(R1);
	asu64(R2) = q;
	*(struct $B31*)(R2) = (R1_B31);
	R1 = 1;
	asu64(R2) = q;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	asu64(R2) = q;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5737;
	goto L5735;
L5737:
	asi64(R1) = length;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	asu64(R3) = q;
	R4 = 8;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	qlist = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	plist = asu64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5740;
L5738:
	asu64(R1) = plist;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = qlist;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = qlist;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L5742;
	asu64(R1) = qlist;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5744;
	asu64(R1) = qlist;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L5744:
	goto L5741;
L5742:
	asu64(R1) = qlist;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5746;
	asu64(R1) = qlist;
	qq_vars_var_duplu(asu64(R1));
L5746:
L5741:
	R1 = (u64)&qlist;
	(*tou64p(R1)) += 16;
	R1 = (u64)&plist;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L5738;
L5740:
L5735:
	return;
}

static i64 qq_records_var_equal_record(u64 x, u64 y) {
    u64 R1, R2, R3; 
	i64 xlen;
	i64 ylen;
	i64 res;
	u64 px;
	u64 py;
	u64 a;
	u64 b;
	i64 av_1;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	py = asu64(R1);
	asu64(R1) = px;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = py;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	if (asi64(R1) == asi64(R2)) goto L5749;
	R1 = 0;
	goto L5747;
L5749:
	asu64(R1) = px;
	asu64(R2) = py;
	if (asu64(R1) != asu64(R2)) goto L5751;
	R1 = 1;
	goto L5747;
L5751:
	asu64(R1) = px;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = py;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = px;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5754;
L5752:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_vars_var_equal(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5756;
	R1 = 0;
	goto L5747;
L5756:
	R1 = (u64)&a;
	(*tou64p(R1)) += 16;
	R1 = (u64)&b;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L5752;
L5754:
	R1 = 1;
	goto L5747;
L5747:
	return asi64(R1);
}

static void qq_records_var_getix_record(u64 a, i64 index) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	u64 q;
	u64 offset;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asi64(R1) = index;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	offset = asu64(R1);
	asu64(R1) = offset;
	R2 = (u64)&qq_tables_ttlength;
	asu64(R3) = q;
	R4 = 6;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	if (asu64(R1) < asu64(R2)) goto L5759;
	R1 = tou64("");
	R2 = tou64("record[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L5759:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = offset;
	R1 += (i64)R2*16;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = a;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5761;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L5761:
	return;
}

static void qq_records_var_putix_record(u64 a, i64 index, u64 x) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	u64 dest;
	u64 q;
	u64 offset;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L5764;
	qq_lib_pcnotmut();
L5764:
	asi64(R1) = index;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	offset = asu64(R1);
	asu64(R1) = offset;
	R2 = (u64)&qq_tables_ttlength;
	asu64(R3) = q;
	R4 = 6;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	if (asu64(R1) < asu64(R2)) goto L5766;
	R1 = tou64("");
	R2 = tou64("rec[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L5766:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = offset;
	R1 += (i64)R2*16;
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5768;
	asu64(R1) = dest;
	qq_vars_var_unshareu(asu64(R1));
L5768:
	asu64(R1) = x;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = dest;
	*(struct $B3*)(R2) = (R1_B3);
	return;
}

static void qq_records_var_getixref_record(u64 a, i64 index, u64 dest) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	u64 offset;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asi64(R1) = index;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	offset = asu64(R1);
	asu64(R1) = offset;
	asu64(R2) = q;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L5771;
	R1 = tou64("");
	R2 = tou64("^rec[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L5771:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = offset;
	R1 += (i64)R2*16;
	p = asu64(R1);
	R1 = 14;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_resolve_rx_module(u64 pm) {
    u64 R1, R2; 
	asu64(R1) = pm;
	qq_decls_currmodule = asu64(R1);
	asu64(R1) = qq_decls_currmodule;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	qq_decls_stcurrmodule = asu64(R2);
	qq_decls_stcurrproc = asu64(R1);
	R1 = 0;
	qq_resolve_nprocs = asi64(R1);
	asu64(R1) = qq_decls_stcurrmodule;
	asu64(R2) = qq_decls_stprogram;
	qq_resolve_rx_passdef(asu64(R2), asu64(R1));
	asi64(R1) = qq_resolve_nprocs;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5774;
	asu64(R1) = qq_decls_currmodule;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = qq_decls_stcurrmodule;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	goto L5773;
L5774:
	asu64(R1) = qq_decls_currmodule;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5775;
	asu64(R1) = qq_decls_currmodule;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = qq_decls_stcurrmodule;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
L5775:
L5773:
	return;
}

static void qq_resolve_rx_passdef(u64 owner, u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = p;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5778;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5779;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5779;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5780;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L5781;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5781;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5781;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L5781;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5782;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5782;
	goto L5783;
L5778:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	qq_resolve_rx_deflist(asu64(R3), asu64(R2), asi64(R1));
	goto L5777;
L5779:
	R1 = (u64)&qq_resolve_nprocs;
	(*toi64p(R1)) += 1;
	asu64(R1) = p;
	asu64(R2) = owner;
	qq_resolve_fixmode(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	qq_resolve_rx_deflist(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = p;
	qq_decls_stcurrproc = asu64(R1);
	asu64(R1) = p;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = qq_decls_stcurrmodule;
	qq_decls_stcurrproc = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	qq_resolve_rx_deflist(asu64(R3), asu64(R2), asi64(R1));
	goto L5777;
L5780:
	asu64(R1) = p;
	asu64(R2) = owner;
	qq_resolve_fixmode(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	qq_resolve_rx_deflist(asu64(R3), asu64(R2), asi64(R1));
	goto L5777;
L5781:
	asu64(R1) = p;
	asu64(R2) = owner;
	qq_resolve_fixmode(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5785;
	asu64(R1) = p;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
L5785:
	goto L5777;
L5782:
	asu64(R1) = p;
	asu64(R2) = owner;
	qq_resolve_fixmode(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	qq_resolve_rx_deflist(asu64(R3), asu64(R2), asi64(R1));
	goto L5777;
L5783:
L5777:
	return;
}

static void qq_resolve_rx_deflist(u64 owner, u64 p, i64 doanon) {
    u64 R1, R2; 
	goto L5788;
L5787:
	asi64(R1) = doanon;
	if (!asi64(R1)) goto L5793;
	asu64(R1) = p;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5792;
L5793:
	asi64(R1) = doanon;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5791;
	asu64(R1) = p;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5791;
L5792:
	asu64(R1) = p;
	asu64(R2) = owner;
	qq_resolve_rx_passdef(asu64(R2), asu64(R1));
L5791:
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L5788:
	asu64(R1) = p;
	if (asu64(R1)) goto L5787;
	return;
}

static void qq_resolve_rx_unit(u64 owner, u64 p) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 a;
	u64 b;
	i64 n;
	i64 flags;
	i64 oldnoexpand;
	i64 oldsymbolmode;
	i64 nk;
	u64 pm;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	qq_decls_qpos = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L5796;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5797;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L5798;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L5799;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L5800;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L5800;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L5801;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L5801;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L5802;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L5803;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L5804;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L5805;
	goto L5806;
L5796:
	R1 = 0;
	asu64(R2) = p;
	asu64(R3) = owner;
	qq_resolve_resolvename(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L5808;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L5808;
	asi64(R1) = qq_resolve_noexpand;
	if (asi64(R1)) goto L5808;
	R1 = (u64)&qq_resolve_macrolevels;
	(*toi64p(R1)) += 1;
	R1 = 0;
	asu64(R2) = p;
	asu64(R3) = p;
	qq_resolve_expandmacro(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	R1 = (u64)&qq_resolve_macrolevels;
	(*toi64p(R1)) -=1;
L5808:
	goto L5795;
L5797:
	asu64(R1) = b;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	goto L5795;
L5798:
	asu64(R1) = p;
	asu64(R2) = owner;
	qq_resolve_resolvedot(asu64(R2), asu64(R1));
	goto L5795;
L5799:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L5810;
	asi64(R1) = qq_resolve_noexpand;
	oldnoexpand = asi64(R1);
	R1 = 1;
	qq_resolve_noexpand = asi64(R1);
	asu64(R1) = a;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asi64(R1) = oldnoexpand;
	qq_resolve_noexpand = asi64(R1);
	goto L5809;
L5810:
	asu64(R1) = a;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
L5809:
	asu64(R1) = b;
	asu64(R2) = owner;
	qq_resolve_rx_unitlist(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 34;
	if (asi64(R1) != asi64(R2)) goto L5812;
	R1 = 35;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 0;
	nk = asi64(R1);
	asu64(R1) = b;
	R2 = 88;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	goto L5814;
L5813:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5817;
	R1 = (u64)&nk;
	(*toi64p(R1)) += 1;
	R1 = 4;
	asu64(R2) = b;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5817:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
L5814:
	asu64(R1) = b;
	if (asu64(R1)) goto L5813;
	asi64(R1) = nk;
	if (!asi64(R1)) goto L5819;
	asi64(R1) = nk;
	asi64(R2) = n;
	if (asi64(R1) == asi64(R2)) goto L5819;
	R1 = 0;
	R2 = tou64("Mixed key:value");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L5819:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5821;
	asi64(R1) = n;
	asi64(R1) = -asi64(R1);
	n = asi64(R1);
L5821:
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5811;
L5812:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L5822;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L5822;
	R1 = (u64)&qq_resolve_macrolevels;
	(*toi64p(R1)) += 1;
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_resolve_expandmacro(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	R1 = (u64)&qq_resolve_macrolevels;
	(*toi64p(R1)) -=1;
L5822:
L5811:
	goto L5795;
L5800:
	asu64(R1) = a;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = b;
	if (asu64(R1)) goto L5824;
	R1 = 0;
	R2 = tou64("Binop missing opnd");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L5824:
	asu64(R1) = b;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_resolve_evalbinop(asu64(R3), asu64(R2), asu64(R1));
	goto L5795;
L5801:
	asu64(R1) = a;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = p;
	qq_resolve_evalmonop(asu64(R1));
	goto L5795;
L5802:
	R1 = 1;
	asu64(R2) = a;
	asu64(R3) = owner;
	qq_resolve_resolvename(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L5825;
	goto L5795;
L5803:
	asu64(R1) = a;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = p;
	qq_resolve_evalmonop(asu64(R1));
	goto L5795;
L5804:
	asi64(R1) = qq_resolve_noexpand;
	oldnoexpand = asi64(R1);
	asi64(R1) = qq_resolve_symbolmode;
	oldsymbolmode = asi64(R1);
	R1 = 1;
	qq_resolve_noexpand = asi64(R1);
	R1 = 1;
	qq_resolve_symbolmode = asi64(R1);
	asu64(R1) = a;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asi64(R1) = oldnoexpand;
	qq_resolve_noexpand = asi64(R1);
	asi64(R1) = oldsymbolmode;
	qq_resolve_symbolmode = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L5827;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L5828;
	goto L5829;
L5827:
	goto L5826;
L5828:
	R1 = (u64)&qq_tables_ttnamedef;
	asu64(R2) = a;
	R3 = 24;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L5831;
	asu64(R1) = d;
	asu64(R2) = a;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 39;
	asu64(R2) = a;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5830;
L5831:
	R1 = 0;
	R2 = tou64("T.$?");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L5830:
	goto L5826;
L5829:
	R1 = 0;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = a;
	qq_show_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = tou64(".$ not name");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L5826:
	goto L5795;
L5805:
	asu64(R1) = a;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L5833;
	R1 = 0;
	R2 = tou64("Not strconst");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L5833:
	R1 = 0;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_modules_loadsourcefile(asu64(R2), asi64(R1));
	pm = asu64(R1);
	asu64(R1) = pm;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pm;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = a;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = a;
	asu64(R2) = p;
	qq_lib_deleteunit(asu64(R2), asu64(R1));
	goto L5795;
L5806:
// qq_resolve.rx_unit.doabc:
L5825:
	R1 = (u64)&qq_tables_jflags;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	flags = asi64(R1);
	asi64(R1) = flags;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5835;
	asu64(R1) = a;
	asu64(R2) = owner;
	qq_resolve_rx_unitlist(asu64(R2), asu64(R1));
L5835:
	asi64(R1) = flags;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L5837;
	asu64(R1) = b;
	asu64(R2) = owner;
	qq_resolve_rx_unitlist(asu64(R2), asu64(R1));
L5837:
L5795:
	return;
}

static void qq_resolve_rx_unitlist(u64 owner, u64 p) {
    u64 R1, R2; 
	goto L5840;
L5839:
	asu64(R1) = p;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L5840:
	asu64(R1) = p;
	if (asu64(R1)) goto L5839;
	return;
}

static void qq_resolve_evalmonop(u64 p) {
    u64 R1, R2; 
	i64 a;
	i64 c;
	r64 x;
	r64 z;
	goto L5844;
L5844:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L5846;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L5847;
	goto L5848;
L5846:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 75;
	if (asi64(R1) == asi64(R2)) goto L5850;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L5851;
	goto L5852;
L5850:
	asi64(R1) = a;
	asi64(R1) = -asi64(R1);
	c = asi64(R1);
	goto L5849;
L5851:
	asi64(R1) = a;
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	c = asi64(R1);
	goto L5849;
L5852:
	goto L5842;
L5849:
// qq_resolve.evalmonop.newint:
	asi64(R1) = c;
	asu64(R2) = p;
	qq_resolve_makeintconst(asu64(R2), asi64(R1));
	goto L5845;
L5847:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	x = asr64(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 75;
	if (asi64(R1) == asi64(R2)) goto L5855;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L5856;
	goto L5857;
L5855:
	asr64(R1) = x;
	asr64(R1) = -asr64(R1);
	z = asr64(R1);
	goto L5854;
L5856:
	asr64(R1) = x;
	if (asr64(R1) < 0) asr64(R1) = -asr64(R1);
	z = asr64(R1);
	goto L5854;
L5857:
	goto L5842;
L5854:
	asr64(R1) = z;
	asu64(R2) = p;
	qq_resolve_makerealconst(asu64(R2), asr64(R1));
	goto L5845;
L5848:
	goto L5842;
L5845:
L5842:
	return;
}

static void qq_resolve_evalbinop(u64 p, u64 lhs, u64 rhs) {
    u64 R1, R2, R3; 
	i64 a;
	i64 b;
	i64 c;
	r64 x;
	r64 y;
	r64 z;
	asu64(R1) = lhs;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = rhs;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	R2 = 2687017;
	if (asi64(R1) == asi64(R2)) goto L5860;
	R2 = 2752554;
	if (asi64(R1) == asi64(R2)) goto L5861;
	goto L5862;
L5860:
	asu64(R1) = lhs;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asu64(R1) = rhs;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	b = asi64(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L5864;
	R2 = 102;
	if (asi64(R1) == asi64(R2)) goto L5865;
	R2 = 103;
	if (asi64(R1) == asi64(R2)) goto L5866;
	R2 = 105;
	if (asi64(R1) == asi64(R2)) goto L5867;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L5868;
	goto L5869;
L5864:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) += asi64(R2);
	c = asi64(R1);
	goto L5863;
L5865:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) -= asi64(R2);
	c = asi64(R1);
	goto L5863;
L5866:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) *= asi64(R2);
	c = asi64(R1);
	goto L5863;
L5867:
	asi64(R1) = b;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5871;
	R1 = 0;
	R2 = tou64("x/0");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L5871:
	asi64(R1) = a;
	asi64(R2) = b;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	c = asi64(R1);
	goto L5863;
L5868:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) = Poweri64(asi64(R1), asi64(R2));
	c = asi64(R1);
	goto L5863;
L5869:
	goto L5858;
L5863:
	asi64(R1) = c;
	asu64(R2) = p;
	qq_resolve_makeintconst(asu64(R2), asi64(R1));
	goto L5859;
L5861:
	asu64(R1) = lhs;
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	x = asr64(R1);
	asu64(R1) = rhs;
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	y = asr64(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L5873;
	R2 = 102;
	if (asi64(R1) == asi64(R2)) goto L5874;
	R2 = 103;
	if (asi64(R1) == asi64(R2)) goto L5875;
	R2 = 104;
	if (asi64(R1) == asi64(R2)) goto L5876;
	goto L5877;
L5873:
	asr64(R1) = x;
	asr64(R2) = y;
	asr64(R1) += asr64(R2);
	z = asr64(R1);
	goto L5872;
L5874:
	asr64(R1) = x;
	asr64(R2) = y;
	asr64(R1) -= asr64(R2);
	z = asr64(R1);
	goto L5872;
L5875:
	asr64(R1) = x;
	asr64(R2) = y;
	asr64(R1) *= asr64(R2);
	z = asr64(R1);
	goto L5872;
L5876:
	asr64(R1) = x;
	asr64(R2) = y;
	asr64(R1) /= asr64(R2);
	z = asr64(R1);
	goto L5872;
L5877:
	goto L5858;
L5872:
	asr64(R1) = z;
	asu64(R2) = p;
	qq_resolve_makerealconst(asu64(R2), asr64(R1));
	goto L5859;
L5862:
	goto L5858;
L5859:
L5858:
	return;
}

static void qq_resolve_makeintconst(u64 p, i64 value) {
    u64 R1, R2, R3, R4; 
	R1 = 41;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = value;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	return;
}

static void qq_resolve_makerealconst(u64 p, r64 xvalue) {
    u64 R1, R2, R3, R4; 
	R1 = 42;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asr64(R1) = xvalue;
	asu64(R2) = p;
	R3 = 16;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	R1 = 2;
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	return;
}

static void qq_resolve_resolvename(u64 owner, u64 p, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	u64 f;
	u64 q;
	i64 moduleno;
	i64 n;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 24;
	R3 = 31;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	moduleno = asi64(R1);
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5882;
	goto L5880;
L5882:
	asi64(R1) = qq_resolve_allowmodname;
	asi64(R2) = moduleno;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = qq_resolve_resolvetopname(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (asu64(R1)) goto L5884;
	asu64(R1) = owner;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5886;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5886;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5887;
	goto L5888;
L5886:
	R1 = 0;
	R2 = 14;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R2 = R1;
	asu64(R3) = p;
	R4 = 16;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	e = asu64(R1);
	goto L5885;
L5887:
	R1 = 0;
	R2 = 13;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R2 = R1;
	asu64(R3) = p;
	R4 = 16;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	e = asu64(R1);
	goto L5885;
L5888:
	asu64(R1) = p;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Undefined: #");
	qq_lib_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L5885:
	goto L5883;
L5884:
// qq_resolve.resolvename.$else:
// qq_resolve.resolvename.retry:
	asu64(R1) = e;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L5892;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L5893;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5894;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5895;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5895;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L5896;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5897;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L5897;
	goto L5898;
L5892:
	asi64(R1) = qq_resolve_symbolmode;
	if (!asi64(R1)) goto L5900;
	goto L5880;
L5900:
	asu64(R1) = e;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L5902;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L5902;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L5902;
	R1 = 0;
	R2 = (u64)&qq_tables_jtagnames;
	asu64(R3) = q;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("Not const expr: #");
	qq_lib_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L5902:
	asu64(R1) = q;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 116;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = q;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = q;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5891;
L5893:
	asi64(R1) = qq_resolve_symbolmode;
	if (!asi64(R1)) goto L5904;
	goto L5880;
L5904:
	R1 = 41;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = e;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L5891;
L5894:
	goto L5891;
L5895:
	R1 = 34;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L5891;
L5896:
	asu64(R1) = p;
	R2 = tou64("FOUND LINK");
	qq_lib_rxerror(asu64(R2), asu64(R1));
	goto L5891;
L5897:
	asu64(R1) = qq_decls_stcurrproc;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5906;
	asu64(R1) = e;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5906;
	R1 = 0;
	R2 = tou64("Accessing transient vars from {}");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L5906:
	goto L5891;
L5898:
L5891:
L5883:
L5880:
	return;
}

static u64 qq_resolve_resolvetopname(u64 owner, u64 stnewname, i64 moduleno, i64 allowmod) {
    u64 R1, R2, R3; 
	i64 extcount;
	i64 subprogno;
	u64 p;
	u64 q;
	u64 powner;
	u64 d;
	u64 e;
	u64 extdef;
	u64 moddef;
	struct $B1 ambiglist;
	i64 i;
	asu64(R1) = owner;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5909;
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L5913;
L5910:
	asu64(R1) = q;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = stnewname;
	if (asu64(R1) != asu64(R2)) goto L5915;
	asu64(R1) = q;
	goto L5907;
L5915:
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5913:
	asu64(R1) = q;
	if (asu64(R1)) goto L5910;
	asu64(R1) = owner;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	owner = asu64(R1);
L5909:
	asu64(R1) = owner;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L5917;
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L5921;
L5918:
	asu64(R1) = q;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = stnewname;
	if (asu64(R1) != asu64(R2)) goto L5923;
	asu64(R1) = q;
	goto L5907;
L5923:
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5921:
	asu64(R1) = q;
	if (asu64(R1)) goto L5918;
L5917:
	asu64(R1) = stnewname;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = moduleno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	subprogno = asi64(R1);
	R1 = 0;
	extcount = asi64(R1);
	R1 = 0;
	R2 = R1;
	moddef = asu64(R2);
	extdef = asu64(R1);
	goto L5927;
L5924:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	powner = asu64(R1);
	asu64(R1) = powner;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5929;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5930;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5931;
	goto L5932;
L5929:
	asu64(R1) = powner;
	R2 = 114;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = moduleno;
	if (asi64(R1) != asi64(R2)) goto L5934;
	asu64(R1) = p;
	goto L5907;
	goto L5933;
L5934:
	asu64(R1) = p;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 1;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L5935;
	R1 = (u64)&qq_decls_modules;
	asu64(R2) = powner;
	R3 = 114;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = subprogno;
	if (asi64(R1) == asi64(R2)) goto L5938;
	asu64(R1) = p;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 1;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5938;
	asu64(R1) = p;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 2;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5937;
L5938:
	R1 = (u64)&extcount;
	(*toi64p(R1)) += 1;
	asu64(R1) = p;
	extdef = asu64(R1);
	asi64(R1) = extcount;
	R2 = 10;
	if (asi64(R1) >= asi64(R2)) goto L5940;
	asu64(R1) = extdef;
	R2 = (u64)&ambiglist;
	asi64(R3) = extcount;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L5940:
L5937:
L5935:
L5933:
	goto L5928;
L5930:
	asu64(R1) = powner;
	asu64(R2) = owner;
	if (asu64(R1) == asu64(R2)) goto L5943;
	asu64(R1) = powner;
	asu64(R2) = owner;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L5942;
L5943:
	asu64(R1) = p;
	goto L5907;
L5942:
	goto L5928;
L5931:
	asu64(R1) = p;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5945;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5945;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L5946;
	goto L5947;
L5945:
	asi64(R1) = allowmod;
	if (!asi64(R1)) goto L5949;
	asu64(R1) = p;
	moddef = asu64(R1);
L5949:
	goto L5944;
L5946:
	asu64(R1) = p;
	goto L5907;
	goto L5944;
L5947:
L5944:
	goto L5928;
L5932:
L5928:
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L5927:
	asu64(R1) = p;
	if (asu64(R1)) goto L5924;
	asu64(R1) = extdef;
	if (!asu64(R1)) goto L5951;
	asi64(R1) = extcount;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L5953;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = extcount;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5956;
L5954:
	R1 = (u64)&ambiglist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	extdef = asu64(R1);
	msysc_m$print_startcon();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = extdef;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_namenames;
	asu64(R2) = extdef;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 124;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= extcount) goto L5954;
L5956:
	R1 = 0;
	asu64(R2) = extdef;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Ambiguous ext name: #");
	qq_lib_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L5953:
	asu64(R1) = extdef;
	goto L5907;
L5951:
	asu64(R1) = moddef;
	goto L5907;
L5907:
	return asu64(R1);
}

static void qq_resolve_resolvedot(u64 owner, u64 p) {
    u64 R1, R2, R3, R4; 
	u64 qdef;
	u64 rdef;
	u64 d;
	u64 newd;
	u64 e;
	u64 fielddef;
	u64 q;
	u64 r;
	i64 nfields;
	i64 oldallowmod;
	asi64(R1) = qq_resolve_symbolmode;
	if (!asi64(R1)) goto L5959;
	asu64(R1) = p;
	asu64(R2) = owner;
	qq_resolve_resolvedot_sym(asu64(R2), asu64(R1));
	goto L5957;
L5959:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = r;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	rdef = asu64(R1);
	asi64(R1) = qq_resolve_allowmodname;
	oldallowmod = asi64(R1);
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	qq_resolve_allowmodname = asi64(R1);
	asu64(R1) = q;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asi64(R1) = oldallowmod;
	qq_resolve_allowmodname = asi64(R1);
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L5961;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L5962;
	goto L5963;
L5961:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L5960;
L5962:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L5964;
	goto L5960;
L5963:
	asu64(R1) = r;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	rdef = asu64(R1);
	goto L5965;
L5960:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5967;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5967;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5967;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5967;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5968;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5968;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L5968;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5968;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5968;
	goto L5969;
L5967:
// qq_resolve.resolvedot.dotype:
L5964:
	asu64(R1) = rdef;
	asu64(R2) = d;
	asu64(R1) = qq_resolve_finddupl(asu64(R2), asu64(R1));
	newd = asu64(R1);
	asu64(R1) = newd;
	if (!asu64(R1)) goto L5971;
	asu64(R1) = newd;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L5973;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L5974;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5975;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5976;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5977;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5977;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L5978;
	goto L5979;
L5973:
	R1 = 41;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = newd;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L5972;
L5974:
	asu64(R1) = newd;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L5981;
	goto L5982;
L5981:
	R1 = 41;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = newd;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L5980;
L5982:
	asu64(R1) = p;
	R2 = tou64("Rxdot:const?");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L5980:
	goto L5972;
L5975:
	R1 = 34;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = newd;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = newd;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L5972;
L5976:
	R1 = 39;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = newd;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L5972;
L5977:
	R1 = 39;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = newd;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L5972;
L5978:
	asu64(R1) = e;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L5984;
	asi64(R1) = qq_resolve_noexpand;
	if (asi64(R1)) goto L5984;
	R1 = (u64)&qq_resolve_macrolevels;
	(*toi64p(R1)) += 1;
	R1 = 0;
	asu64(R2) = p;
	asu64(R3) = p;
	qq_resolve_expandmacro(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	R1 = (u64)&qq_resolve_macrolevels;
	(*toi64p(R1)) -=1;
L5984:
	goto L5972;
L5979:
	msysc_m$print_startcon();
	R1 = (u64)&qq_tables_namenames;
	asu64(R2) = newd;
	R3 = 124;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = newd;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = tou64("Rxdot:.name not allowed here");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L5972:
	goto L5970;
L5971:
	msysc_m$print_startcon();
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = rdef;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = tou64("Can't resolve");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L5970:
	goto L5966;
L5968:
// qq_resolve.resolvedot.doexprdot:
L5965:
	R1 = 0;
	nfields = asi64(R1);
	R1 = 0;
	fielddef = asu64(R1);
	asu64(R1) = rdef;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L5986;
L5985:
	asu64(R1) = e;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5989;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5989;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L5989;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5989;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5989;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5989;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5989;
	goto L5990;
L5989:
	R1 = (u64)&nfields;
	(*toi64p(R1)) += 1;
	asu64(R1) = e;
	fielddef = asu64(R1);
	goto L5988;
L5990:
L5988:
	asu64(R1) = e;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L5986:
	asu64(R1) = e;
	if (asu64(R1)) goto L5985;
	asi64(R1) = nfields;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5992;
	goto L5993;
L5992:
	msysc_m$print_startcon();
	asu64(R1) = rdef;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Can't find field");
	qq_lib_rxerror(asu64(R2), asu64(R1));
	goto L5991;
L5993:
	asu64(R1) = rdef;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5995;
	R1 = 0;
	R2 = tou64("Field name not generic");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L5995:
L5991:
	goto L5966;
L5969:
	msysc_m$print_startcon();
	R1 = (u64)&qq_tables_namenames;
	asu64(R2) = d;
	R3 = 124;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = tou64("RXDOT:Unknown nameid");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L5966:
L5957:
	return;
}

static void qq_resolve_resolvedot_sym(u64 owner, u64 p) {
    u64 R1, R2, R3, R4; 
	u64 qdef;
	u64 rdef;
	u64 d;
	u64 newd;
	u64 e;
	u64 fielddef;
	u64 q;
	u64 r;
	i64 nfields;
	i64 oldallowmod;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = r;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	rdef = asu64(R1);
	asi64(R1) = qq_resolve_allowmodname;
	oldallowmod = asi64(R1);
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	qq_resolve_allowmodname = asi64(R1);
	asu64(R1) = q;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asi64(R1) = oldallowmod;
	qq_resolve_allowmodname = asi64(R1);
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L5998;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L5999;
	goto L6000;
L5998:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L5997;
L5999:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = qq_resolve_symbolmode;
	if (!asi64(R1)) goto L6002;
	asu64(R1) = rdef;
	asu64(R2) = d;
	asu64(R1) = qq_resolve_finddupl(asu64(R2), asu64(R1));
	newd = asu64(R1);
	asu64(R1) = newd;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6004;
	R1 = 0;
	asu64(R2) = rdef;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Can't resolve .");
	qq_lib_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L6004:
	asu64(R1) = newd;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6006;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6006;
	goto L6007;
L6006:
	msysc_m$print_startcon();
	R1 = tou64("*******FIELD.$");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L6005;
L6007:
	R1 = 0;
	R2 = (u64)&qq_tables_namenames;
	asu64(R3) = newd;
	R4 = 124;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64(".$ ON type:");
	qq_lib_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L6005:
L6002:
	goto L6008;
	goto L5997;
L6000:
	R1 = 0;
	R2 = tou64("RXDOTSYM?");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L5997:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6010;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6010;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6010;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6010;
	goto L6011;
L6010:
// qq_resolve.resolvedot_sym.dotype:
L6008:
	asu64(R1) = rdef;
	asu64(R2) = d;
	asu64(R1) = qq_resolve_finddupl(asu64(R2), asu64(R1));
	newd = asu64(R1);
	asu64(R1) = newd;
	if (!asu64(R1)) goto L6013;
	R1 = 39;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = newd;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L6012;
L6013:
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64(".$ Can't resolve");
	qq_lib_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L6012:
	goto L6009;
L6011:
	asu64(R1) = p;
	R2 = (u64)&qq_tables_namenames;
	asu64(R3) = d;
	R4 = 124;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("RX.$: Unknown nameid:");
	qq_lib_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L6009:
	return;
}

static u64 qq_resolve_finddupl(u64 d, u64 pdupl) {
    u64 R1, R2; 
	asu64(R1) = pdupl;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6016;
	asu64(R1) = pdupl;
	goto L6014;
L6016:
	asu64(R1) = pdupl;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdupl = asu64(R1);
	goto L6018;
L6017:
	asu64(R1) = pdupl;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L6021;
	asu64(R1) = pdupl;
	goto L6014;
L6021:
	asu64(R1) = pdupl;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdupl = asu64(R1);
L6018:
	asu64(R1) = pdupl;
	if (asu64(R1)) goto L6017;
	R1 = 0;
	goto L6014;
L6014:
	return asu64(R1);
}

static void qq_resolve_expandmacro(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 d;
	u64 pm;
	u64 pnew;
	i64 ignoreargs;
	asi64(R1) = qq_resolve_macrolevels;
	R2 = 10;
	if (asi64(R1) <= asi64(R2)) goto L6024;
	R1 = 0;
	R2 = tou64("Too many macro levels (recursive macro?)");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L6024:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	R1 = 0;
	qq_resolve_nmacroparams = asi64(R1);
	goto L6026;
L6025:
	asi64(R1) = qq_resolve_nmacroparams;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L6029;
	R1 = 0;
	R2 = tou64("macro param overflow");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L6029:
	asu64(R1) = pm;
	R2 = (u64)&qq_resolve_macroparams;
	R3 = (u64)&qq_resolve_nmacroparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pm;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_resolve_macroparamsgen;
	asi64(R3) = qq_resolve_nmacroparams;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pm;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
L6026:
	asu64(R1) = pm;
	if (asu64(R1)) goto L6025;
	R1 = 0;
	qq_resolve_nmacroargs = asi64(R1);
	goto L6031;
L6030:
	asi64(R1) = qq_resolve_nmacroargs;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L6034;
	R1 = 0;
	R2 = tou64("macro arg overflow");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L6034:
	asu64(R1) = b;
	R2 = (u64)&qq_resolve_macroargs;
	R3 = (u64)&qq_resolve_nmacroargs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
L6031:
	asu64(R1) = b;
	if (asu64(R1)) goto L6030;
	asi64(R1) = qq_resolve_nmacroargs;
	asi64(R2) = qq_resolve_nmacroparams;
	if (asi64(R1) >= asi64(R2)) goto L6036;
	R1 = 0;
	R2 = tou64("Too few macro args");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L6036:
	R1 = 0;
	ignoreargs = asi64(R1);
	asi64(R1) = qq_resolve_nmacroargs;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6038;
	asi64(R1) = qq_resolve_nmacroparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6038;
	R1 = 1;
	ignoreargs = asi64(R1);
	R1 = 0;
	R2 = R1;
	qq_resolve_nmacroparams = asi64(R2);
	qq_resolve_nmacroargs = asi64(R1);
	goto L6037;
L6038:
	asi64(R1) = qq_resolve_nmacroargs;
	asi64(R2) = qq_resolve_nmacroparams;
	if (asi64(R1) <= asi64(R2)) goto L6039;
	R1 = 0;
	R2 = tou64("Too many macro args");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L6039:
L6037:
	asu64(R1) = d;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_resolve_copyunit(asu64(R1));
	pnew = asu64(R1);
	asi64(R1) = ignoreargs;
	if (asi64(R1)) goto L6041;
	asu64(R1) = pnew;
	asu64(R2) = p;
	qq_resolve_replaceunit(asu64(R2), asu64(R1));
	goto L6040;
L6041:
	asu64(R1) = pnew;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6040:
	return;
}

static u64 qq_resolve_copylistunit(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	u64 plist;
	u64 plistx;
	R1 = 0;
	R2 = R1;
	plistx = asu64(R2);
	plist = asu64(R1);
	goto L6044;
L6043:
	asu64(R1) = p;
	asu64(R1) = qq_resolve_copyunit(asu64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = (u64)&plistx;
	R3 = (u64)&plist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L6044:
	asu64(R1) = p;
	if (asu64(R1)) goto L6043;
	asu64(R1) = plist;
	goto L6042;
L6042:
	return asu64(R1);
}

static u64 qq_resolve_copyunit(u64 p) {
    u64 R1, R2, R3; struct $B31 R1_B31; 
	u64 q;
	u64 d;
	i64 i;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6048;
	R1 = 0;
	goto L6046;
L6048:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L6050;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_resolve_nmacroparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6053;
L6051:
	R1 = (u64)&qq_resolve_macroparamsgen;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L6055;
	R1 = (u64)&qq_resolve_macroargs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = qq_resolve_copyunit(asu64(R1));
	goto L6046;
	goto L6053;
L6055:
	i += 1; if (i <= qq_resolve_nmacroparams) goto L6051;
L6053:
L6050:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R1) = qq_lib_createunit0(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	(R1_B31) = *(struct $B31*)(R1);
	asu64(R2) = q;
	*(struct $B31*)(R2) = (R1_B31);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&qq_tables_jflags;
	asu64(R2) = q;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6057;
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_resolve_copylistunit(asu64(R1));
	asu64(R2) = q;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&qq_tables_jflags;
	asu64(R2) = q;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6059;
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_resolve_copylistunit(asu64(R1));
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6059:
L6057:
	asu64(R1) = q;
	goto L6046;
L6046:
	return asu64(R1);
}

static void qq_resolve_replaceunit(u64 p, u64 q) {
    u64 R1, R2, R3; struct $B31 R1_B31; 
	u64 pnext;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pnext = asu64(R1);
	asu64(R1) = q;
	(R1_B31) = *(struct $B31*)(R1);
	asu64(R2) = p;
	*(struct $B31*)(R2) = (R1_B31);
	asu64(R1) = pnext;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_resolve_fixmode(u64 owner, u64 p) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	i64 m;
	asu64(R1) = p;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6063;
	goto L6061;
L6063:
	asi64(R1) = m;
	asi64(R1) = -asi64(R1);
	m = asi64(R1);
	R1 = (u64)&qq_tables_ttxmap;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L6065;
	R1 = (u64)&qq_tables_ttxmap;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 116;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L6061;
L6065:
	R1 = (u64)&qq_tables_ttnamedefx;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	R1 = 0;
	R2 = (u64)&qq_tables_ttxmoduleno;
	asi64(R3) = m;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = qq_resolve_resolvetopname(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L6067;
	asu64(R1) = e;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = (u64)&qq_tables_ttxmap;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asu64(R1) = e;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 116;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L6066;
L6067:
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Can't resolve type: #");
	qq_lib_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L6066:
L6061:
	return;
}

static i64 qq_resolve_fixmode2(u64 owner, i64 m) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	struct $B16 str;
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6070;
	asi64(R1) = m;
	goto L6068;
L6070:
	asi64(R1) = m;
	asi64(R1) = -asi64(R1);
	m = asi64(R1);
	R1 = (u64)&qq_tables_ttxmap;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L6072;
	R1 = (u64)&qq_tables_ttxmap;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	goto L6068;
L6072:
	R1 = (u64)&qq_tables_ttnamedefx;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = owner;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6074;
	R1 = 0;
	R2 = tou64("FM2/owner");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L6074:
	R1 = 0;
	R2 = (u64)&qq_tables_ttxmoduleno;
	asi64(R3) = m;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = qq_resolve_resolvetopname(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L6076;
	asu64(R1) = e;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = (u64)&qq_tables_ttxmap;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asu64(R1) = e;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	goto L6068;
	goto L6075;
L6076:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("# in module #, line:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_decls_modules;
	R2 = (u64)&qq_tables_ttxmoduleno;
	asi64(R3) = m;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = (u64)&str;
	R3 = tou64("2:Can't resolve type: #");
	qq_lib_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L6075:
	R1 = 0;
	goto L6068;
L6068:
	return asi64(R1);
}

static void qq_resolve_fixusertypes() {
    u64 R1, R2, R3; 
	u64 p;
	u64 pmode;
	i64 m;
	i64 rescan;
	i64 i;
	R1 = 1;
	i = asi64(R1);
L6078:
	asu64(R1) = qq_tables_userxmodelist;
	p = asu64(R1);
	R1 = 0;
	rescan = asi64(R1);
	goto L6082;
L6081:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi16(R1) = *toi16p(R1);
	R1 = toi64(toi16(R1));
	m = asi64(R1);
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L6085;
	asi64(R1) = m;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_resolve_fixmode2(asu64(R2), asi64(R1));
	m = asi64(R1);
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L6087;
	asi64(R1) = i;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6087;
	R1 = (u64)&qq_tables_ttxmap;
	asi64(R2) = m;
	if (asi64(R2) < 0) asi64(R2) = -asi64(R2);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L6087;
	R1 = (u64)&qq_tables_ttxmap;
	asi64(R2) = m;
	if (asi64(R2) < 0) asi64(R2) = -asi64(R2);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	m = asi64(R1);
L6087:
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L6089;
	R1 = 1;
	rescan = asi64(R1);
	goto L6088;
L6089:
	asi64(R1) = m;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*toi16p(R2) = asi16(R1);
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asi64(R2) = m;
	if (asi64(R1) != asi64(R2)) goto L6091;
	R1 = 0;
	R2 = (u64)&qq_tables_ttname;
	asi64(R3) = m;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("recursive type?");
	qq_lib_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L6091:
L6088:
L6085:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L6082:
	asu64(R1) = p;
	if (asu64(R1)) goto L6081;
	asi64(R1) = rescan;
	if (asi64(R1)) goto L6093;
	goto L6080;
L6093:
	i += 1; if (i <= 2) goto L6078;
L6080:
	asi64(R1) = rescan;
	if (!asi64(R1)) goto L6095;
	R1 = 0;
	R2 = tou64("FUT Phase Error");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L6095:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nbaseclasses;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6098;
L6096:
	asi64(R1) = i;
	qq_resolve_dobaseclass(asi64(R1));
	i += 1; if (i <= qq_decls_nbaseclasses) goto L6096;
L6098:
	return;
}

static void qq_resolve_tx_typetable() {
    u64 R1, R2; 
	i64 i;
	R1 = 41;
	i = asi64(R1);
	asi64(R1) = qq_tables_ntypes;
	R2 = 41;
	if (asi64(R1) < asi64(R2)) goto L6102;
L6100:
	asi64(R1) = i;
	qq_resolve_converttype(asi64(R1));
	i += 1; if (i <= qq_tables_ntypes) goto L6100;
L6102:
	return;
}

static i64 qq_resolve_getconstint(u64 owner, u64 a, i64 ownerid) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L6105;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L6106;
	goto L6107;
L6105:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L6103;
	goto L6104;
L6106:
	asu64(R1) = a;
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = toi64(asr64(R1));
	goto L6103;
	goto L6104;
L6107:
	R1 = 0;
	R2 = (u64)&qq_tables_jtagnames;
	asu64(R3) = a;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("Getconstint: not int/real");
	qq_lib_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L6104:
	R1 = 0;
	goto L6103;
L6103:
	return asi64(R1);
}

static void qq_resolve_converttype(i64 m) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	u64 d;
	u64 f;
	u64 owner;
	i64 first;
	i64 a;
	i64 b;
	i64 index;
	i64 length;
	i64 lower;
	i64 elemtype;
	i64 nbits;
	struct $B78 fieldlist;
	i64 oldmodno;
	i64 pos;
	i64 ownerid;
	i64 maxalign;
	i64 nfields;
	i64 size;
	u64 plength;
	u64 plower;
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L6110;
	goto L6108;
L6110:
	R1 = (u64)&qq_tables_ttowner;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	owner = asu64(R1);
	R1 = (u64)&qq_tables_ttlowerexpr;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	plower = asu64(R1);
	R1 = (u64)&qq_tables_ttlengthexpr;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	plength = asu64(R1);
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L6112;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L6112;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6113;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6114;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6115;
	goto L6116;
L6112:
	R1 = 0;
	asu64(R2) = plength;
	asu64(R3) = owner;
	asi64(R1) = qq_resolve_getconstint(asu64(R3), asu64(R2), asi64(R1));
	R2 = R1;
	R3 = (u64)&qq_tables_ttlength;
	asi64(R4) = m;
	*toi64p(((i64)R3+(i64)R4*8)) = asi64(R2);
	R2 = (u64)&qq_tables_ttsize;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	goto L6111;
L6113:
	asi64(R1) = m;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L6118;
	msysc_m$print_startcon();
	R1 = tou64("CT:ARRAY/ARRAY");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L6118:
	R1 = (u64)&qq_tables_ttowner;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (!asu64(R1)) goto L6120;
	R1 = (u64)&qq_tables_ttowner;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	ownerid = asi64(R1);
	goto L6119;
L6120:
	R1 = 0;
	ownerid = asi64(R1);
L6119:
	asu64(R1) = plower;
	if (!asu64(R1)) goto L6122;
	asi64(R1) = ownerid;
	asu64(R2) = plower;
	asu64(R3) = owner;
	asi64(R1) = qq_resolve_getconstint(asu64(R3), asu64(R2), asi64(R1));
	R2 = (u64)&qq_tables_ttlower;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	goto L6121;
L6122:
	R1 = 1;
	R2 = (u64)&qq_tables_ttlower;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
L6121:
	asu64(R1) = plength;
	if (!asu64(R1)) goto L6124;
	asi64(R1) = ownerid;
	asu64(R2) = plength;
	asu64(R3) = owner;
	asi64(R1) = qq_resolve_getconstint(asu64(R3), asu64(R2), asi64(R1));
	R2 = (u64)&qq_tables_ttlength;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	goto L6123;
L6124:
	R1 = 0;
	R2 = (u64)&qq_tables_ttlength;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
L6123:
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemtype = asi64(R1);
	asi64(R1) = elemtype;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L6126;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L6126;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L6126;
	goto L6127;
L6126:
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&qq_tables_ttbitwidth;
	R3 = (u64)&qq_tables_tttarget;
	asi64(R4) = m;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) *= asi64(R2);
	nbits = asi64(R1);
	asi64(R1) = nbits;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&qq_tables_ttsize;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	goto L6125;
L6127:
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	qq_resolve_converttype(asi64(R1));
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&qq_tables_ttsize;
	R3 = (u64)&qq_tables_tttarget;
	asi64(R4) = m;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	R2 = (u64)&qq_tables_ttsize;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
L6125:
	goto L6111;
L6114:
	R1 = (u64)&qq_tables_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	f = asu64(R1);
	R1 = 0;
	nfields = asi64(R1);
	goto L6129;
L6128:
	asi64(R1) = nfields;
	R2 = 256;
	if (asi64(R1) < asi64(R2)) goto L6132;
	R1 = 0;
	R2 = tou64("Too many fields");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L6132:
	asu64(R1) = f;
	R2 = (u64)&fieldlist;
	R3 = (u64)&nfields;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = f;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	f = asu64(R1);
L6129:
	asu64(R1) = f;
	if (asu64(R1)) goto L6128;
	R1 = 0;
	R2 = (u64)&fieldlist;
	asi64(R3) = nfields;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 0;
	R2 = R1;
	qq_resolve_nallfields = asi64(R2);
	qq_resolve_ntopfields = asi64(R1);
	R1 = 1;
	maxalign = asi64(R1);
	R1 = 1;
	index = asi64(R1);
	R1 = 2;
	R2 = (u64)&maxalign;
	R3 = (u64)&qq_tables_ttcaligned;
	asi64(R4) = m;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	R4 = 0;
	R5 = (u64)&size;
	R6 = (u64)&index;
	R7 = (u64)&fieldlist;
	R8 = 1;
	qq_resolve_scanstruct(asi64(R8), asu64(R7), asu64(R6), asu64(R5), asi64(R4), asi64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&qq_tables_ttcaligned;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6134;
	asi64(R1) = maxalign;
	asi64(R2) = size;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	size = asi64(R1);
	asi64(R1) = maxalign;
	asu64(R2) = d;
	R3 = 106;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L6133;
L6134:
	R1 = 1;
	asu64(R2) = d;
	R3 = 106;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L6133:
	asi64(R1) = size;
	R2 = (u64)&qq_tables_ttsize;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_ttlower;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asi64(R1) = qq_resolve_ntopfields;
	R2 = (u64)&qq_tables_ttlength;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = 8;
	asi64(R2) = qq_resolve_ntopfields;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = d;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 8;
	asi64(R2) = qq_resolve_ntopfields;
	asu64(R1) *= asu64(R2);
	R2 = (u64)&qq_resolve_structfields;
	asu64(R3) = d;
	R4 = 88;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L6111;
L6115:
	goto L6111;
L6116:
	msysc_m$print_startcon();
	R1 = tou64("CAN'T DO:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asi64(R2) = m;
	asu64(R1) = qq_show_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	R2 = (u64)&qq_tables_ttbasetype;
	asi64(R3) = m;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu64(R1) = qq_show_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L6111:
L6108:
	return;
}

static void qq_resolve_scanstruct(i64 smode, u64 fields, u64 index, u64 isize, i64 offset, i64 calign, u64 maxalign, i64 countmode) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	u64 f;
	i64 newoffset;
	i64 fieldsize;
	i64 alignment;
	i64 nfields;
	i64 structmode;
	i64 ndepth;
	i64 size;
	R1 = 0;
	size = asi64(R1);
	goto L6137;
L6136:
	asu64(R1) = f;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6140;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L6141;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L6142;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L6143;
	goto L6144;
L6140:
	asu64(R1) = f;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	qq_resolve_converttype(asi64(R1));
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = f;
	R3 = 116;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	fieldsize = asi64(R1);
	asi64(R1) = calign;
	if (!asi64(R1)) goto L6146;
	asu64(R1) = f;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asi64(R1) = qq_names_getalignment(asi64(R1));
	alignment = asi64(R1);
	asi64(R1) = alignment;
	asu64(R2) = maxalign;
    *toi64p(R2) = Max(*toi64p(R2), asi64(R1));
	asi64(R1) = alignment;
	asi64(R2) = offset;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	newoffset = asi64(R1);
	asi64(R1) = newoffset;
	asi64(R2) = offset;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	goto L6145;
L6146:
	asi64(R1) = offset;
	newoffset = asi64(R1);
L6145:
	asi64(R1) = newoffset;
	asu64(R2) = f;
	R3 = 108;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = index;
	asi64(R1) = *toi64p(R1);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = f;
	R3 = 96;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = newoffset;
	offset = asi64(R1);
// qq_resolve.scanstruct.countfields:
	R1 = (u64)&qq_resolve_nallfields;
	(*toi64p(R1)) += 1;
	asi64(R1) = countmode;
	if (!asi64(R1)) goto L6149;
	asu64(R1) = f;
	R2 = (u64)&qq_resolve_structfields;
	R3 = (u64)&qq_resolve_ntopfields;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L6149:
	goto L6139;
L6141:
	asi64(R1) = countmode;
	asu64(R2) = maxalign;
	asi64(R3) = calign;
	asi64(R4) = offset;
	R5 = (u64)&fieldsize;
	asu64(R6) = index;
	asu64(R7) = fields;
	R8 = 1;
	qq_resolve_scanstruct(asi64(R8), asu64(R7), asu64(R6), asu64(R5), asi64(R4), asi64(R3), asu64(R2), asi64(R1));
	goto L6139;
L6142:
	asi64(R1) = countmode;
	if (!asi64(R1)) goto L6151;
	R1 = 1;
	goto L6150;
L6151:
	R1 = 0;
L6150:
	asu64(R2) = maxalign;
	asi64(R3) = calign;
	asi64(R4) = offset;
	R5 = (u64)&fieldsize;
	asu64(R6) = index;
	asu64(R7) = fields;
	R8 = 0;
	qq_resolve_scanstruct(asi64(R8), asu64(R7), asu64(R6), asu64(R5), asi64(R4), asi64(R3), asu64(R2), asi64(R1));
	goto L6139;
L6143:
	asi64(R1) = size;
	asu64(R2) = isize;
	*toi64p(R2) = asi64(R1);
	goto L6135;
	goto L6139;
L6144:
L6139:
	asi64(R1) = smode;
	if (!asi64(R1)) goto L6153;
	asi64(R1) = fieldsize;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = fieldsize;
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	goto L6152;
L6153:
	asi64(R1) = size;
	asi64(R2) = fieldsize;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	size = asi64(R1);
	R1 = 0;
	countmode = asi64(R1);
L6152:
L6137:
	asu64(R1) = fields;
	asu64(R2) = index;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) += 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = R1;
	f = asu64(R2);
	if (asu64(R1)) goto L6136;
	asi64(R1) = size;
	asu64(R2) = isize;
	*toi64p(R2) = asi64(R1);
L6135:
	return;
}

static void qq_resolve_dobaseclass(i64 baseclassindex) {
    u64 R1, R2, R3, R4; 
	u64 sttype;
	u64 d;
	u64 e;
	u64 newd;
	i64 baseclass;
	i64 normalexit;
	R1 = (u64)&qq_decls_baseclasstable;
	asi64(R2) = baseclassindex;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	baseclass = asi64(R1);
	R1 = (u64)&qq_decls_baseclassdef;
	asi64(R2) = baseclassindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	sttype = asu64(R1);
	R1 = (u64)&qq_tables_ttnamedef;
	asi64(R2) = baseclass;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L6156;
L6155:
	asu64(R1) = sttype;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 1;
	normalexit = asi64(R1);
	goto L6159;
L6158:
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L6162;
	R1 = 0;
	normalexit = asi64(R1);
	goto L6160;
L6162:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L6159:
	asu64(R1) = e;
	if (asu64(R1)) goto L6158;
L6160:
	asi64(R1) = normalexit;
	if (!asi64(R1)) goto L6164;
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6166;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L6166;
	goto L6167;
L6166:
	R1 = 0;
	R2 = 21;
	asu64(R3) = d;
	R4 = 48;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = sttype;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	newd = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = newd;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L6165;
L6167:
	R1 = 0;
	asu64(R2) = d;
	R3 = 124;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = d;
	R4 = 48;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = sttype;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	newd = asu64(R1);
	asu64(R1) = newd;
	asu64(R2) = d;
	qq_names_duplfield(asu64(R2), asu64(R1));
	asu64(R1) = sttype;
	R2 = 104;
	R1 += (i64)R2;
	(*toi16p(R1)) += 1;
	asu64(R1) = sttype;
	R2 = 104;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = (u64)&qq_tables_ttlength;
	asu64(R3) = sttype;
	R4 = 116;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asu64(R1) = sttype;
	R2 = 104;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = newd;
	R3 = 96;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = newd;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = newd;
	R3 = 108;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L6165:
	asu64(R1) = newd;
	qq_names_addgenfield(asu64(R1));
L6164:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L6156:
	asu64(R1) = d;
	if (asu64(R1)) goto L6155;
	return;
}

static void qq_runx_disploop() {
    u64 R1, R2, R3, R4, R5, R6; struct $B3 R1_B3; 
	u64 pc;
	u64 sp;
	u64 fp;
	u64 x;
	u64 y;
	u64 z;
	i64 n;
	i64 index;
	u64 dest;
	u64 px;
	u64 d;
	i64 nloc;
	u64 pz;
	u64 pp;
	u64 q;
	u64 g;
	i64 xt;
	i64 yt;
	i64 res;
	i64 lower;
	i64 upper;
	i64 moduleno;
	i64 offset;
	u64 newsp;
	u64 e;
	u64 localjumptable;
	struct $B3 vx;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 av_4;
// PROC LOCAL STATICS GO HERE
	static i64 qq_runx_disploop_count = 100;
    static void* $jumptable[] = {&&L6178, &&L6179, &&L6181, &&L6182, &&L6186, &&L6187, &&L6188, &&L6189, &&L6192, &&L6196, &&L6198, &&L6206, &&L6200, &&L6203, &&L6207, &&L6210, &&L6211, &&L6212, &&L6213, &&L6214, &&L6215, &&L6216, &&L6217, &&L6231, &&L6239, &&L6240, &&L6241, &&L6244, &&L6247, &&L6250, &&L6251, &&L6252, &&L6255, &&L6264, &&L6273, &&L6280, &&L6287, &&L6297, &&L6304, &&L6311, &&L6378, &&L6389, &&L6401, &&L6402, &&L6407, &&L6409, &&L6412, &&L6414, &&L6417, &&L6419, &&L6422, &&L6423, &&L6430, &&L6442, &&L6443, &&L6444, &&L6445, &&L6446, &&L6447, &&L6823, &&L6453, &&L6454, &&L6455, &&L6456, &&L6457, &&L6458, &&L6459, &&L6460, &&L6467, &&L6468, &&L6475, &&L6476, &&L6478, &&L6487, &&L6488, &&L6489, &&L6492, &&L6495, &&L6498, &&L6503, &&L6506, &&L6512, &&L6515, &&L6520, &&L6521, &&L6522, &&L6523, &&L6524, &&L6525, &&L6526, &&L6528, &&L6536, &&L6539, &&L6542, &&L6549, &&L6552, &&L6553, &&L6554, &&L6564, &&L6567, &&L6572, &&L6573, &&L6582, &&L6590, &&L6598, &&L6605, &&L6612, &&L6617, &&L6621, &&L6628, &&L6635, &&L6642, &&L6649, &&L6656, &&L6661, &&L6666, &&L6671, &&L6678, &&L6685, &&L6688, &&L6691, &&L6698, &&L6703, &&L6734, &&L6735, &&L6740, &&L6736, &&L6744, &&L6753, &&L6766, &&L6767, &&L6774, &&L6785, &&L6791, &&L6792, &&L6793, &&L6794, &&L6801, &&L6812, &&L6817, &&L6818, &&L6819, &&L6822, &&L6829, &&L6824, &&L6177, &&L6177, &&L6177, &&L6836, &&L6839, &&L6869, &&L6177, &&L6177, &&L6177, &&L6177, &&L6866, &&L6177, &&L6177, &&L6177, &&L6177, &&L6318, &&L6323, &&L6328, &&L6333, &&L6338, &&L6343, &&L6348, &&L6353, &&L6358, &&L6363, &&L6368, &&L6373, &&L6845, &&L6848, &&L6842, &&L6177, &&L6851, &&L6854, &&L6857, &&L6860, &&L6863, &&L6710, &&L6717, &&L6722, &&L6725, &&L6728, &&L6731, &&L6880, &&L6874, &&L6177, &&L6230, &&L6894, &&L6899, &&L6906, &&L6911, &&L6891, &&L6177, &&L6177, &&L6918, &&L6881, &&L6886, &&L6921};
    R1 = (u64)$jumptable;
	localjumptable = asu64(R1);
// qq_runx.disploop.freddy:
	asu8(R1) = qq_runx_getjt;
	if (!asu8(R1)) goto L6171;
	asu64(R1) = localjumptable;
	qq_runx_jumptable = asu64(R1);
	goto L6168;
L6171:
	asu64(R1) = qq_decls_sptr;
	sp = asu64(R1);
	asu64(R1) = qq_decls_pcptr;
	pc = asu64(R1);
	asu64(R1) = qq_decls_frameptr;
	fp = asu64(R1);
	asu64(R1) = qq_runx_jumptable;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6173;
	R1 = tou64("");
	R2 = tou64("JUMPTABLE NOT SET");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6173:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6176:
L6178:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6179:
	goto L6180;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6181:
	goto L6180;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6182:
	asu64(R1) = pc;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6185;
L6183:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 0;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	if (--asi64(av_1)) goto L6183;
L6185:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6186:
	goto L6180;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6187:
	goto L6180;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6188:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6189:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6191;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6191:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6192:
// qq_runx.disploop.jpushf:
L6193:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6195;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6195:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6196:
// qq_runx.disploop.jpushmref:
L6197:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 14;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6198:
// qq_runx.disploop.jpushfref:
L6199:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 14;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6200:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6202;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6202:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6203:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6205;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6205:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6206:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 16;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = sp;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6207:
// qq_runx.disploop.jpushci:
L6208:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
// qq_runx.disploop.jpushcix:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6210:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 0;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6211:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 16;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = sp;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6212:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 2;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6213:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 265;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6214:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 18;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6215:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 19;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6216:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 17;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6217:
	asu64(R1) = sp;
	x = asu64(R1);
// qq_runx.disploop.jpushptr:
L6218:
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6220;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L6221;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L6222;
	goto L6223;
L6220:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = sp;
	*(struct $B3*)(R2) = (R1_B3);
	goto L6219;
L6221:
	asu64(R1) = x;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6225;
	goto L6226;
L6225:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6227;
	goto L6224;
L6226:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	R1 = 0;
	asu64(R2) = sp;
	asu64(R3) = x;
	R4 = 4;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	asu64(R4) = x;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	qq_packed_var_loadpacked(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
L6224:
	goto L6219;
L6222:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	asu64(R2) = x;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = x;
	R4 = 4;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	asu64(R4) = x;
	R5 = 2;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R5) = x;
	R6 = 8;
	asu64(R5) = *tou64p(((i64)R5+(i64)R6));
	qq_vars_var_loadbit(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	goto L6219;
L6223:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = x;
	R2 = tou64("Pushptr");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L6219:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6229;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6229:
// qq_runx.disploop.refpackend:
L6227:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6230:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6218;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6231:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	asu64(R1) = y;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6233;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L6234;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L6235;
	goto L6236;
L6233:
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6238;
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_vars_var_unshareu(asu64(R1));
L6238:
	asu64(R1) = x;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = y;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*(struct $B3*)(R2) = (R1_B3);
	goto L6232;
L6234:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = x;
	asu64(R3) = y;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_packed_var_storepacked(asu64(R3), asu64(R2), asi64(R1));
	goto L6232;
L6235:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = x;
	asu64(R4) = y;
	R5 = 2;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R5) = y;
	R6 = 8;
	asu64(R5) = *tou64p(((i64)R5+(i64)R6));
	qq_vars_var_storebit(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6232;
L6236:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = y;
	R2 = tou64("Popptr");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L6232:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6239:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6240:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6241:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	asu64(R1) = sp;
	R2 = 1;
	R1 -= (i64)R2*16;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	R1 -= (i64)R2*16;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6243;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6243:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6244:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6246;
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	qq_vars_var_duplu(asu64(R1));
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6246:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6247:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6249;
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L6249;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&vx;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&vx;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6248;
L6249:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	qq_runaux_k_swap(asu64(R2), asu64(R1));
L6248:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6250:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	qq_runaux_k_convrefpack(asu64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6251:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6252:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L6254;
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("jumpptr?");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6254:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6255:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6257;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L6259;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6258;
L6259:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6258:
	goto L6256;
L6257:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = x;
	asi64(R1) = qq_vars_var_istruel(asu64(R1));
	if (!asi64(R1)) goto L6261;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6260;
L6261:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6260:
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6263;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6263:
L6256:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6264:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6266;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (asi64(R1)) goto L6268;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6267;
L6268:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6267:
	goto L6265;
L6266:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = x;
	asi64(R1) = qq_vars_var_istruel(asu64(R1));
	if (asi64(R1)) goto L6270;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6269;
L6270:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6269:
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6272;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6272:
L6265:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6273:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6275;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6275;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L6277;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6276;
L6277:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6276:
	goto L6274;
L6275:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_equal(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L6279;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6278;
L6279:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6278:
L6274:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6280:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6282;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6282;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) == asi64(R2)) goto L6284;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6283;
L6284:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6283:
	goto L6281;
L6282:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_equal(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L6286;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6285;
L6286:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6285:
L6281:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6287:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6289;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6289;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) >= asi64(R2)) goto L6291;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6290;
L6291:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6290:
	goto L6288;
L6289:
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6292;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6292;
	asu64(R1) = x;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	if (asr64(R1) >= asr64(R2)) goto L6294;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6293;
L6294:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6293:
	goto L6288;
L6292:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_compare(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L6296;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6295;
L6296:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6295:
L6288:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6297:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6299;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6299;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L6301;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6300;
L6301:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6300:
	goto L6298;
L6299:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_compare(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L6303;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6302;
L6303:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6302:
L6298:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6304:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6306;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6306;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) < asi64(R2)) goto L6308;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6307;
L6308:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6307:
	goto L6305;
L6306:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_compare(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6310;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6309;
L6310:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6309:
L6305:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6311:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6313;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6313;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L6315;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6314;
L6315:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6314:
	goto L6312;
L6313:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_compare(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6317;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6316;
L6317:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6316:
L6312:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6318:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6320;
	goto L6193;
L6320:
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L6322;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6321;
L6322:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6321:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6323:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6325;
	goto L6193;
L6325:
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) == asi64(R2)) goto L6327;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6326;
L6327:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6326:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6328:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6330;
	goto L6193;
L6330:
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) >= asi64(R2)) goto L6332;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6331;
L6332:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6331:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6333:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6335;
	goto L6193;
L6335:
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L6337;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6336;
L6337:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6336:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6338:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6340;
	goto L6193;
L6340:
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) < asi64(R2)) goto L6342;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6341;
L6342:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6341:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6343:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6345;
	goto L6193;
L6345:
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L6347;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6346;
L6347:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6346:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6348:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6350;
	goto L6193;
L6350:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L6352;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6351;
L6352:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6351:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6353:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6355;
	goto L6193;
L6355:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) == asi64(R2)) goto L6357;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6356;
L6357:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6356:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6358:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6360;
	goto L6193;
L6360:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) >= asi64(R2)) goto L6362;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6361;
L6362:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6361:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6363:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6365;
	goto L6193;
L6365:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L6367;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6366;
L6367:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6366:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6368:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6370;
	goto L6193;
L6370:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) < asi64(R2)) goto L6372;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6371;
L6372:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6371:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6373:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6375;
	goto L6193;
L6375:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L6377;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6376;
L6377:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6376:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6378:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6380;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6380;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L6382;
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6381;
L6382:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6381:
	goto L6379;
L6380:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_runaux_k_when(asu64(R2), asu64(R1));
	res = asi64(R1);
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6384;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6384:
	asi64(R1) = res;
	if (!asi64(R1)) goto L6386;
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6388;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6388:
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6385;
L6386:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6385:
L6379:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6389:
// qq_runx.disploop.jwhenne:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6392;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6392;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) == asi64(R2)) goto L6394;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6393;
L6394:
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6393:
	goto L6391;
L6392:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_runaux_k_when(asu64(R2), asu64(R1));
	res = asi64(R1);
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6396;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6396:
	asi64(R1) = res;
	if (asi64(R1)) goto L6398;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6397;
L6398:
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6400;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6400:
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6397:
L6391:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6401:
	goto L6180;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6402:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6404;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6404;
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = sp;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("switch not int");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6404:
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = pc;
	R3 = 12;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	if (asi64(R1) < asi64(R2)) goto L6406;
	asu64(R2) = pc;
	R3 = 14;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	if (asi64(R1) > asi64(R2)) goto L6406;
	asu64(R1) = pc;
	asi64(R2) = n;
	R1 += (i64)R2*32;
	asu64(R2) = pc;
	R3 = 12;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R1 -= (i64)R2*32;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6405;
L6406:
	asu64(R1) = pc;
	asu64(R2) = pc;
	R3 = 14;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R1 += (i64)R2*32;
	asu64(R2) = pc;
	R3 = 12;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R1 -= (i64)R2*32;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
L6405:
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6407:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	goto L6408;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6409:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
// qq_runx.disploop.doto:
L6408:
	asu64(R1) = x;
	R2 = 8;
	R1 += (i64)R2;
	asi64(R1) = *(toi64p(R1)) -= 1;
	if (!asi64(R1)) goto L6411;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6410;
L6411:
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6410:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6412:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	goto L6413;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6414:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
// qq_runx.disploop.doforfci:
L6413:
	asu64(R1) = x;
	R2 = 8;
	R1 += (i64)R2;
	(*toi64p(R1)) += 1;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 2;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L6416;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6415;
L6416:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6415:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6417:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	y = asu64(R1);
	goto L6418;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6419:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 2;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	y = asu64(R1);
// qq_runx.disploop.doforff:
L6418:
	asu64(R1) = x;
	R2 = 8;
	R1 += (i64)R2;
	(*toi64p(R1)) += 1;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L6421;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6420;
L6421:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6420:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6422:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 20;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = fp;
	asu64(R2) = sp;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = sp;
	fp = asu64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6423:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6425;
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("Probably undefined function");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6425:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L6427;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L6427:
	asu64(R1) = d;
	R2 = 104;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = pc;
	R3 = 9;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L6429;
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 104;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = tou64("Callptr: wrong # params; need:");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6429:
	R1 = 20;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = fp;
	asu64(R2) = sp;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = sp;
	fp = asu64(R1);
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6430:
// qq_runx.disploop.doretproc:
L6431:
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6434;
L6432:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6436;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6436:
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	if (--asi64(av_2)) goto L6432;
L6434:
	asu64(R1) = pc;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	n = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	asu64(R1) = fp;
	R2 = -4294967296;
	asi64(R1) &= asi64(R2);
	asu64(R2) = sp;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R1) |= asu64(R2);
	fp = asu64(R1);
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	asi64(R1) = n;
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6439;
L6437:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6441;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6441:
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	if (--asi64(av_3)) goto L6437;
L6439:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6442:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 14;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	goto L6431;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6443:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 114;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	moduleno = asi64(R1);
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 20;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = moduleno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6444:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6445:
	asu64(R1) = pc;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	n = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = sp;
	asi64(R3) = n;
	R2 -= (i64)R3*16;
	asu64(R3) = sp;
	asi64(R4) = n;
	R3 -= (i64)R4*16;
	R4 = 1;
	R3 += (i64)R4*16;
	asu64(R4) = pc;
	R5 = 16;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	qq_calldll_calldll(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = n;
	R2 = (u64)&sp;
	*tou64p(R2) -= asu64(R1)*16;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6446:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_host_callhostfunction(asi64(R2), asu64(R1));
	sp = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6447:
	asu64(R1) = pc;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	av_4 = asi64(R1);
	asi64(R1) = av_4;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6450;
L6448:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6452;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6452:
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	if (--asi64(av_4)) goto L6448;
L6450:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6453:
	R1 = 1;
	qq_decls_stopped = asi64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	goto L6175;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6454:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = pc;
	R3 = 14;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R3) = sp;
	asu64(R1) = qq_runaux_k_makelist(asu64(R3), asi64(R2), asi64(R1));
	sp = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6455:
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	n = asi64(R1);
	asu64(R1) = sp;
	asu64(R2) = pc;
	R3 = 12;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R1 -= (i64)R2*16;
	R2 = 1;
	R1 += (i64)R2*16;
	x = asu64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = pc;
	R3 = 12;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R3) = x;
	asu64(R4) = x;
	qq_records_var_make_record(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = x;
	sp = asu64(R1);
	R1 = 0;
	asu64(R2) = sp;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6456:
	asu64(R1) = sp;
	asu64(R2) = pc;
	R3 = 12;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R1 -= (i64)R2*16;
	R2 = 1;
	R1 += (i64)R2*16;
	x = asu64(R1);
	asu64(R1) = pc;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = pc;
	R4 = 12;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	asu64(R4) = pc;
	R5 = 14;
	asi16(R4) = *toi16p(((i64)R4+(i64)R5));
	R4 = toi64(toi16(R4));
	asu64(R5) = x;
	asu64(R6) = x;
	qq_arrays_var_make_array(asu64(R6), asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = x;
	sp = asu64(R1);
	R1 = 0;
	asu64(R2) = sp;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6457:
	goto L6180;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6458:
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	n = asi64(R1);
	asu64(R1) = sp;
	asi64(R2) = n;
	R1 -= (i64)R2*16;
	R2 = 1;
	R1 += (i64)R2*16;
	x = asu64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = n;
	asu64(R3) = x;
	asu64(R4) = x;
	qq_packed_var_make_struct(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = x;
	sp = asu64(R1);
	R1 = 0;
	asu64(R2) = sp;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6459:
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	n = asi64(R1);
	asu64(R1) = sp;
	asi64(R2) = n;
	R1 -= (i64)R2*16;
	R2 = 1;
	R1 += (i64)R2*16;
	x = asu64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = x;
	asu64(R3) = x;
	qq_sets_var_make_set(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = x;
	sp = asu64(R1);
	R1 = 0;
	asu64(R2) = sp;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6460:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6463;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6462;
L6463:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("makerange/not int");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6462:
	R1 = 4;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	lower = asi64(R1);
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	upper = asi64(R1);
	asi64(R1) = lower;
	R2 = -281474976710656;
	if (asi64(R1) < asi64(R2)) goto L6466;
	R2 = 281474976710655;
	if (asi64(R1) <= asi64(R2)) goto L6465;
L6466:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("Range lwb bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6465:
	asi64(R1) = upper;
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = lower;
	asu64(R2) = sp;
	R3 = 16;
	R4 = 63;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6467:
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	n = asi64(R1);
	asu64(R1) = sp;
	asi64(R2) = n;
	R3 = 2;
	asi64(R2) *= asi64(R3);
	R1 -= (i64)R2*16;
	R2 = 1;
	R1 += (i64)R2*16;
	x = asu64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = x;
	asu64(R3) = x;
	qq_dicts_var_make_dict(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = x;
	sp = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6468:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&vx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6470;
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("Not str");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6470:
	R1 = (u64)&vx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pp = asu64(R1);
	asu64(R1) = pp;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6472;
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("Null str");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6472:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	asu64(R2) = pp;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = pp;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_decimal_var_make_dec_str(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6474;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6474:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6475:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = sp;
	qq_runaux_k_incrptr(asu64(R2), asi64(R1));
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6476:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	goto L6477;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6478:
// qq_runx.disploop.jincrtof:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
// qq_runx.disploop.doincrto:
L6477:
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6481;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6482;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L6483;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6484;
	goto L6485;
L6481:
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = x;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
	goto L6480;
L6482:
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = x;
	R3 = 8;
	R2 += (i64)R3;
	*tou64p(R2) += asu64(R1)*16;
	goto L6480;
L6483:
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = x;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = pc;
	R3 = 12;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asi64(R1) *= asi64(R2);
	asu64(R2) = x;
	R3 = 8;
	R2 += (i64)R3;
	*tou64p(R2) += asu64(R1);
	goto L6480;
L6484:
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = x;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) += asr64(R1);
	goto L6480;
L6485:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = x;
	R2 = tou64("incrto");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L6480:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
// qq_runx.disploop.jincrtofx:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6487:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	asu64(R2) = sp;
	qq_vars_var_loadptr(asu64(R2), asu64(R1));
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = (u64)&vx;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&vx;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = sp;
	qq_runaux_k_incrptr(asu64(R2), asi64(R1));
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6488:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = sp;
	qq_runaux_k_incrptr(asu64(R2), asi64(R1));
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	R1 = (u64)&sp;
	asu64(R1) = *(tou64p(R1)) += 16;
	R2 = (u64)&vx;
	qq_vars_var_loadptr(asu64(R2), asu64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6489:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	qq_vars_var_neg(asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6491;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6491:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6492:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	qq_vars_var_abs(asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6494;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6494:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6495:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	asi64(R1) = qq_vars_var_istruel(asu64(R1));
	asi64(R1) = !asi64(R1);
	res = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6497;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6497:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = res;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6498:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6500;
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = ~asi64(R1);
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6499;
L6500:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	qq_vars_var_inot(asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6502;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6502:
L6499:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6503:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	asi64(R1) = qq_vars_var_istruel(asu64(R1));
	n = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6505;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6505:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6506:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6508;
	goto L6509;
L6508:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L6511;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	n = asi64(R1);
	goto L6510;
L6511:
	R1 = 0;
	n = asi64(R1);
L6510:
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6507;
L6509:
	asu64(R1) = sp;
	R2 = tou64("ASC");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L6507:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6512:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6514;
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	asu64(R2) = sp;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	qq_strings_var_makechar(asi64(R2), asu64(R1));
	goto L6513;
L6514:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	R2 = tou64("CHR");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L6513:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6515:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6517;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6518;
	goto L6519;
L6517:
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) *= asi64(R1);
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6516;
L6518:
	asu64(R1) = sp;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R1) *= asr64(R1);
	asu64(R2) = sp;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L6516;
L6519:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	R2 = tou64("sqr");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L6516:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6520:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = sp;
	qq_runaux_k_maths(asu64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6521:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = sp;
	asu64(R3) = sp;
	R4 = 1;
	R3 -= (i64)R4*16;
	qq_runaux_k_maths2(asu64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6522:
	goto L6180;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6523:
	goto L6180;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6524:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	qq_runaux_k_len(asu64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6525:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	qq_runaux_k_lwb(asu64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6526:
// qq_runx.disploop.jupb:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	qq_runaux_k_upb(asu64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6528:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	R1 = (u64)&upper;
	R2 = (u64)&lower;
	asu64(R3) = sp;
	qq_runaux_k_bounds(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = pc;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6530;
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6532;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6532:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = lower;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = upper;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6529;
L6530:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6534;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6534:
// qq_runx.disploop.billy:
	R1 = 4;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = lower;
	asu64(R2) = sp;
	R3 = 16;
	R4 = 63;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = upper;
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6529:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6536:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	asi64(R1) = qq_runaux_k_bytesize(asu64(R1));
	res = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6538;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6538:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = res;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6539:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = sp;
	asi64(R1) = qq_runaux_k_type(asu64(R2), asi64(R1));
	n = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6541;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6541:
	R1 = 18;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6542:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6544;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6545;
	goto L6546;
L6544:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 28;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	n = asi64(R1);
	goto L6543;
L6545:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	goto L6543;
L6546:
	asu64(R1) = sp;
	R2 = tou64("Dictitems/digits");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L6543:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6548;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6548:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6549:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6551;
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("isfound");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6551:
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0x8000000000000000;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6552:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	qq_runaux_k_minval(asu64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6553:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	qq_runaux_k_maxval(asu64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6554:
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L6556;
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6559;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L6559;
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L6558;
L6559:
	R1 = 1;
	n = asi64(R1);
L6558:
	goto L6555;
L6556:
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) != asi64(R2)) goto L6561;
	R1 = 1;
	n = asi64(R1);
L6561:
L6555:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6563;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6563:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6564:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	res = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6566;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6566:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = res;
	asu64(R2) = pc;
	R3 = 9;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) ^= asi64(R2);
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6567:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) == asi64(R2)) goto L6569;
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = (u64)&vx;
	qq_vars_var_convert(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6571;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6571:
L6569:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6572:
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6573:
// qq_runx.disploop.jadd:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6576;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6576;
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
	goto L6575;
L6576:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6577;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6577;
	asu64(R1) = y;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) += asr64(R1);
	goto L6575;
L6577:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_add(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6579;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6579:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6581;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6581:
L6575:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6582:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6584;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6584;
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) -= asi64(R1);
	goto L6583;
L6584:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6585;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6585;
	asu64(R1) = y;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) -= asr64(R1);
	goto L6583;
L6585:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_sub(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6587;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6587:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6589;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6589:
L6583:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6590:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6592;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6592;
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) *= asi64(R1);
	goto L6591;
L6592:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6593;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6593;
	asu64(R1) = y;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) *= asr64(R1);
	goto L6591;
L6593:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_mul(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6595;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6595:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6597;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6597:
L6591:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6598:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6600;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6600;
	asu64(R1) = y;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) /= asr64(R1);
	goto L6599;
L6600:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_div(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6602;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6602:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6604;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6604:
L6599:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6605:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6607;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6607;
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) /= asi64(R1);
	goto L6606;
L6607:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_idiv(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6609;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6609:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6611;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6611:
L6606:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6612:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_irem(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6614;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6614:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6616;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6616:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6617:
	asu64(R1) = sp;
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 1;
	R1 -= (i64)R2*16;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6620;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6619;
L6620:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("divrem");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6619:
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	lower = asi64(R1);
	msysc_m$print_startcon();
	R1 = tou64("X.VALUE=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) %= asi64(R2);
	asu64(R2) = y;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = lower;
	asu64(R2) = x;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 2;
	R2 = 1;
	asu64(R3) = sp;
	asu64(R1) = qq_runaux_k_makelist(asu64(R3), asi64(R2), asi64(R1));
	sp = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6621:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6623;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6623;
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) &= asi64(R1);
	goto L6622;
L6623:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_iand(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6625;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6625:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6627;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6627:
L6622:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6628:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6630;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6630;
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) |= asi64(R1);
	goto L6629;
L6630:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_ior(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6632;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6632:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6634;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6634:
L6629:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6635:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6637;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6637;
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) ^= asi64(R1);
	goto L6636;
L6637:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_ixor(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6639;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6639:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6641;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6641:
L6636:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6642:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6644;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6644;
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) <<= asi64(R1);
	goto L6643;
L6644:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_shl(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6646;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6646:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6648;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6648:
L6643:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6649:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6651;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6651;
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) >>= asi64(R1);
	goto L6650;
L6651:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_shr(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6653;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6653:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6655;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6655:
L6650:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6656:
	asu64(R1) = sp;
	y = asu64(R1);
	R1 = (u64)&sp;
	asu64(R1) = *(tou64p(R1)) -= 16;
	x = asu64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_in(asu64(R2), asu64(R1));
	asu64(R2) = pc;
	R3 = 9;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) ^= asi64(R2);
	n = asi64(R1);
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6658;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6658:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6660;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6660:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6661:
	asu64(R1) = sp;
	y = asu64(R1);
	R1 = (u64)&sp;
	asu64(R1) = *(tou64p(R1)) -= 16;
	x = asu64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_inx(asu64(R2), asu64(R1));
	n = asi64(R1);
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6663;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6663:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6665;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6665:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6666:
	asu64(R1) = sp;
	y = asu64(R1);
	R1 = (u64)&sp;
	asu64(R1) = *(tou64p(R1)) -= 16;
	x = asu64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asu64(R3) = pc;
	R4 = 9;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = qq_runaux_k_cmp(asi64(R3), asu64(R2), asu64(R1));
	res = asi64(R1);
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6668;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6668:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6670;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6670:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = res;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6671:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	x = asu64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_compare(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L6673;
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6675;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6675:
	goto L6672;
L6673:
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6677;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6677:
	asu64(R1) = y;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = sp;
	*(struct $B3*)(R2) = (R1_B3);
L6672:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6678:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	x = asu64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_compare(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6680;
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6682;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6682:
	goto L6679;
L6680:
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6684;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6684:
	asu64(R1) = y;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = sp;
	*(struct $B3*)(R2) = (R1_B3);
L6679:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6685:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	(R1_B3) = *(struct $B3*)(R1);
	vx = (R1_B3);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_concat(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6687;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6687:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6688:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	(R1_B3) = *(struct $B3*)(R1);
	vx = (R1_B3);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_append(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6690;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6690:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6691:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6693;
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6693;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L6693;
	R1 = 1;
	res = asi64(R1);
	goto L6692;
L6693:
	R1 = 0;
	res = asi64(R1);
L6692:
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6695;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6695:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6697;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6697:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = res;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6698:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_power(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6700;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6700:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6702;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6702:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6703:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	z = asu64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6705;
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L6705;
	asu64(R1) = z;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6706;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6706;
	R1 = 1;
	goto L6707;
L6706:
	R1 = 0;
L6707:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L6705;
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = z;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
	goto L6704;
L6705:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asu64(R3) = pc;
	R4 = 16;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	qq_vars_var_inplace(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6709;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6709:
L6704:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6710:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	z = asu64(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 16;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6712;
	asu64(R1) = z;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6713;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6713;
	R1 = 1;
	goto L6714;
L6713:
	R1 = 0;
L6714:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L6712;
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = z;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
	goto L6711;
L6712:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	R1 = 14;
	R2 = (u64)&vx;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = z;
	R2 = (u64)&vx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = y;
	R2 = (u64)&vx;
	asu64(R3) = pc;
	R4 = 1;
	R3 += (i64)R4*32;
	R4 = 16;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	qq_vars_var_inplace(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6716;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6716:
L6711:
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6717:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	z = asu64(R1);
	asu64(R1) = z;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6719;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6719;
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = z;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
	goto L6718;
L6719:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	R1 = 14;
	R2 = (u64)&vx;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = z;
	R2 = (u64)&vx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = y;
	R2 = (u64)&vx;
	asu64(R3) = pc;
	R4 = 1;
	R3 += (i64)R4*32;
	R4 = 16;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	qq_vars_var_inplace(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6721;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6721:
L6718:
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6722:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	z = asu64(R1);
	asu64(R1) = z;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6724;
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = z;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
	goto L6723;
L6724:
	goto L6208;
L6723:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6725:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	z = asu64(R1);
	asu64(R1) = z;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6727;
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = z;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) -= asi64(R1);
	goto L6726;
L6727:
	goto L6208;
L6726:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6728:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	z = asu64(R1);
	asu64(R1) = z;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6730;
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = z;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) <<= asi64(R1);
	goto L6729;
L6730:
	goto L6208;
L6729:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6731:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	z = asu64(R1);
	asu64(R1) = z;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6733;
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = z;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) >>= asi64(R1);
	goto L6732;
L6733:
	goto L6208;
L6732:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6734:
	goto L6180;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6735:
	goto L6180;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6736:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	px = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = px;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6738;
	goto L6739;
L6738:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = px;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_vars_var_appendto(asu64(R2), asu64(R1));
	goto L6737;
L6739:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = px;
	R2 = tou64("Appendto");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L6737:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6740:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	px = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = px;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6742;
	goto L6743;
L6742:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = px;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_vars_var_concatto(asu64(R2), asu64(R1));
	goto L6741;
L6743:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = px;
	R2 = tou64("Concatto");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L6741:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6744:
	R1 = (u64)&qq_decls_genfieldtable;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	g = asu64(R1);
	asu64(R1) = g;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6746;
	asu64(R1) = g;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L6746;
	R1 = (u64)&qq_decls_genfieldtable;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = d;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 116;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	if (asi64(R1) == asi64(R2)) goto L6748;
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("Dot1: wrong type");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6748:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 108;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R3 = 16;
   if (asi64(R3) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R2) /= asi64(R3);
	R1 += (i64)R2*16;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6750;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6750:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6752;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6752:
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6745;
L6746:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = g;
	asu64(R2) = sp;
	qq_runaux_k_dot(asu64(R2), asu64(R1));
L6745:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6753:
	R1 = (u64)&qq_decls_genfieldtable;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	g = asu64(R1);
	asu64(R1) = g;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6755;
	asu64(R1) = g;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L6755;
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6757;
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("Popdot1: not rec");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6757:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L6759;
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	qq_lib_pcnotmut();
L6759:
	asu64(R1) = g;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = e;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 116;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	if (asi64(R1) == asi64(R2)) goto L6761;
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("Popdot1: wrong type");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6761:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 108;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R3 = 16;
   if (asi64(R3) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R2) /= asi64(R3);
	R1 += (i64)R2*16;
	z = asu64(R1);
	asu64(R1) = z;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6763;
	asu64(R1) = z;
	qq_vars_var_unshareu(asu64(R1));
L6763:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = z;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = z;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6765;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6765:
	goto L6754;
L6755:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = g;
	asu64(R2) = sp;
	asu64(R1) = qq_runaux_k_popdot(asu64(R2), asu64(R1));
	sp = asu64(R1);
L6754:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6766:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	R1 = (u64)&qq_decls_genfieldtable;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = sp;
	qq_runaux_k_dotref(asu64(R2), asu64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6767:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6769;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6770;
	goto L6771;
L6769:
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	qq_vars_var_getix(asu64(R2), asi64(R1));
	goto L6768;
L6770:
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 16;
	R4 = 63;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R3) = sp;
	qq_vars_var_getslice(asu64(R3), asi64(R2), asi64(R1));
	goto L6768;
L6771:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = y;
	R2 = (u64)&vx;
	R3 = tou64("Index");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L6768:
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6773;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6773:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6774:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	z = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = z;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6776;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6777;
	goto L6778;
L6776:
	asu64(R1) = x;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = y;
	qq_vars_var_putix(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6780;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6780:
	goto L6775;
L6777:
	asu64(R1) = x;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = z;
	R4 = 0;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	R4 = 16;
	R5 = 63;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	asu64(R4) = y;
	qq_vars_var_putslice(asu64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6782;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6782:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6784;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6784:
	goto L6775;
L6778:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = z;
	asu64(R2) = y;
	R3 = tou64("Popix");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L6775:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6785:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6787;
	goto L6788;
L6787:
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	qq_vars_var_getixref(asu64(R2), asi64(R1));
	goto L6786;
L6788:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	R3 = tou64("Indexref");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L6786:
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6790;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6790:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6791:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	asu64(R1) = qq_runaux_k_keyindex(asu64(R1));
	sp = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6792:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	asu64(R1) = qq_runaux_k_popkeyindex(asu64(R1));
	sp = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6793:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	asu64(R1) = qq_runaux_k_keyindexref(asu64(R1));
	sp = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6794:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6796;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6797;
	goto L6798;
L6796:
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	qq_vars_var_getdotix(asu64(R2), asi64(R1));
	goto L6795;
L6797:
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 16;
	R4 = 63;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R3) = sp;
	qq_vars_var_getdotslice(asu64(R3), asi64(R2), asi64(R1));
	goto L6795;
L6798:
	asu64(R1) = y;
	R2 = (u64)&vx;
	R3 = tou64("Dotindex");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L6795:
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6800;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6800:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6801:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	z = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = z;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6803;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6804;
	goto L6805;
L6803:
	asu64(R1) = x;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = y;
	qq_vars_var_putdotix(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6807;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6807:
	goto L6802;
L6804:
	asu64(R1) = x;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = z;
	R4 = 0;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	R4 = 16;
	R5 = 63;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	asu64(R4) = y;
	qq_vars_var_putdotslice(asu64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6809;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6809:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6811;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6811:
	goto L6802;
L6805:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = z;
	asu64(R2) = y;
	R3 = tou64("Popdotindex");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L6802:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6812:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = y;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6814;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6815;
	goto L6816;
L6814:
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	qq_vars_var_getdotixref(asu64(R2), asi64(R1));
	goto L6813;
L6815:
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 16;
	R4 = 63;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R3) = sp;
	qq_vars_var_getdotsliceref(asu64(R3), asi64(R2), asi64(R1));
	goto L6813;
L6816:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	R3 = tou64("Dotindexref");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L6813:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6817:
	asu64(R1) = sp;
	asu64(R2) = pc;
	R3 = 9;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R1 += (i64)R2*16;
	R2 = 1;
	R1 -= (i64)R2*16;
	x = asu64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = x;
	asu64(R3) = sp;
	qq_vars_var_expand(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = x;
	sp = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6818:
	R1 = 21;
	R2 = (u64)&sp;
	asu64(R2) = *(tou64p(R2)) += 16;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = fp;
	asu64(R2) = sp;
	asi64(R1) -= asi64(R2);
	asu64(R2) = sp;
	R3 = 4;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc;
	R2 = 14;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 6;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6819:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6821;
	R1 = tou64("");
	R2 = tou64("Raise: not Int");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6821:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = fp;
	qq_decls_frameptr = asu64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_runaux_raiseexception(asi64(R1));
	pc = asu64(R1);
	asu64(R1) = qq_decls_sptr;
	sp = asu64(R1);
	asu64(R1) = qq_decls_frameptr;
	fp = asu64(R1);
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6822:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	R1 = (u64)&newsp;
	asu64(R2) = pc;
	asu64(R3) = sp;
	asu64(R1) = qq_runaux_k_map(asu64(R3), asu64(R2), asu64(R1));
	pc = asu64(R1);
	asu64(R1) = newsp;
	sp = asu64(R1);
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6823:
	asu64(R1) = pc;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&sp;
	*tou64p(R2) -= asu64(R1)*16;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6824:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = sp;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6826;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6826:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = sp;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6828;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6828:
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6829:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6831;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6831:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6833;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6833:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 2;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 2;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6835;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6835:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6836:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6838;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6838:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6839:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6841;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6841:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6842:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6844;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6844;
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6843;
L6844:
	goto L6193;
L6843:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6845:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6847;
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6846;
L6847:
	goto L6193;
L6846:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6848:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6850;
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6849;
L6850:
	goto L6193;
L6849:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6851:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6853;
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6852;
L6853:
	goto L6208;
L6852:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6854:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6856;
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) -= asi64(R1);
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6855;
L6856:
	goto L6208;
L6855:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6857:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6859;
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) &= asi64(R1);
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6858;
L6859:
	goto L6208;
L6858:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6860:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6862;
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) <<= asi64(R1);
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6861;
L6862:
	goto L6208;
L6861:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6863:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6865;
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) >>= asi64(R1);
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6864;
L6865:
	goto L6208;
L6864:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6866:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6868;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6868:
	R1 = 1;
	asu64(R2) = x;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6869:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	y = asu64(R1);
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6871;
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6871:
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6873;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6873:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6874:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
// qq_runx.disploop.doindexff:
L6875:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	y = asu64(R1);
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6877;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6878;
	goto L6879;
L6877:
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	qq_vars_var_getix(asu64(R2), asi64(R1));
	goto L6876;
L6878:
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 16;
	R4 = 63;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R3) = sp;
	qq_vars_var_getslice(asu64(R3), asi64(R2), asi64(R1));
	goto L6876;
L6879:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = tou64("Indexff");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L6876:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6880:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	goto L6875;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6881:
	asu64(R1) = sp;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6883;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L6885;
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6884;
L6885:
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6884:
	goto L6882;
L6883:
	goto L6208;
L6882:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6886:
	asu64(R1) = sp;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6888;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) == asi64(R2)) goto L6890;
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6889;
L6890:
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6889:
	goto L6887;
L6888:
	goto L6208;
L6887:
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6891:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6893;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6893:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	qq_runaux_k_upb(asu64(R1));
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6894:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L6897;
	asu64(R1) = x;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6896;
L6897:
	goto L6197;
L6896:
	goto L6898;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6899:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L6902;
	asu64(R1) = x;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6901;
L6902:
	goto L6199;
L6901:
// qq_runx.disploop.dopushipf:
L6898:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = x;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6904;
	goto L6905;
L6904:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = x;
	R3 = 8;
	R2 += (i64)R3;
	*tou64p(R2) += asu64(R1);
	goto L6903;
L6905:
L6903:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6906:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L6909;
	asu64(R1) = x;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L6909;
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6908;
L6909:
	goto L6197;
L6908:
	goto L6910;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6911:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L6914;
	asu64(R1) = x;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L6914;
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6913;
L6914:
	goto L6199;
L6913:
// qq_runx.disploop.dopopipf:
L6910:
	asu64(R1) = x;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6916;
	goto L6917;
L6916:
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*tou8p(R2) = asu8(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = x;
	R3 = 8;
	R2 += (i64)R3;
	*tou64p(R2) += asu64(R1);
	goto L6915;
L6917:
L6915:
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6918:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6920;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6920:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6921:
	goto L6180;
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6177:
// qq_runx.disploop.unimpl:
L6180:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = (u64)&qq_pcltabs_pclnames;
	asu64(R2) = pc;
	R3 = 8;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("Unimpl op:");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	R1 = 1;
	exit(R1);
	asu64(R1) = pc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	{void* p=(void*)R1; goto *p;}
L6175:
L6168:
	return;
}

static void qq_runx_start() {
    u64 R1; 
	R1 = 1;
	qq_runx_getjt = asu8(R1);
	qq_runx_disploop();
	R1 = 0;
	qq_runx_getjt = asu8(R1);
	return;
}

static void qq_runx_fixupcode(u64 pm) {
    u64 R1, R2, R3; 
	u64 pc;
	asu64(R1) = qq_runx_jumptable;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6925;
	goto L6923;
L6925:
	asu64(R1) = pm;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6929;
L6926:
	asu64(R1) = qq_runx_jumptable;
	asu64(R2) = pc;
	R3 = 8;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = pc;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6929:
	asu64(R1) = pc;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L6926;
L6923:
	return;
}

static i64 qq_runx_runqprogram(u64 sp, i64 ismain) {
    u64 R1, R2, R3; 
	i64 tt;
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) >= asi64(R2)) goto L6932;
	R1 = 0;
	goto L6930;
L6932:
	R1 = (u64)&qq_decls_varstack;
	R2 = 0;
	R1 += (i64)R2;
	qq_decls_sptr = asu64(R1);
	R1 = (u64)&qq_decls_varstack;
	R2 = 1118384;
	R1 += (i64)R2;
	qq_decls_stacklimit = asu64(R1);
	R1 = (u64)&qq_decls_modules;
	asu64(R2) = sp;
	R3 = 24;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_decls_pcptr = asu64(R1);
	R1 = 0;
	qq_decls_stopped = asi64(R1);
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	tt = asi64(R1);
	qq_runx_disploop();
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	tt = asi64(R1);
	asu64(R1) = qq_decls_sptr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L6930;
L6930:
	return asi64(R1);
}

static void qq_runaux_pcerror(u64 mess, u64 param) {
    u64 R1, R2, R3; 
	asu64(R1) = param;
	asu64(R2) = mess;
	asu64(R3) = qq_decls_pcptr;
	qq_runaux_reportpcerror(asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void qq_runaux_pcustype(u64 mess, u64 x) {
    u64 R1, R2; 
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = mess;
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
	return;
}

static void qq_runaux_pcustype_t(u64 mess, i64 t) {
    u64 R1, R2, R3; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("Type not supported: # : #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_ttname;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = tou64("");
	R2 = (u64)&str;
	asu64(R3) = qq_decls_pcptr;
	qq_runaux_reportpcerror(asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void qq_runaux_pcmxtypes(u64 mess, u64 x, u64 y) {
    u64 R1, R2, R3; 
	asu64(R1) = y;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = x;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = mess;
	qq_runaux_pcmxtypestt(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void qq_runaux_pcmxtypestt(u64 mess, i64 t, i64 u) {
    u64 R1, R2, R3; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("Types not supported: # : #/#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_ttname;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_ttname;
	asi64(R2) = u;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = tou64("");
	R2 = (u64)&str;
	asu64(R3) = qq_decls_pcptr;
	qq_runaux_reportpcerror(asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void qq_runaux_reportpcerror(u64 pcptr, u64 mess, u64 param) {
    u64 R1, R2; struct $B12 R1_B12; 
	u64 s;
	u64 send;
	u64 pc;
	i64 count;
	u64 pm;
	struct $B12 loc;
	struct $B12 loc2;
	asu64(R1) = pcptr;
	(R1_B12) = qq_runaux_getpcerrorpos(asu64(R1));
	loc = (R1_B12);
	R1 = (u64)&loc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("80p*");
	R2 = tou64(" ");
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("PC Error:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("    ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Line:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&loc;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("in Module");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&loc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".q:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&loc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6940;
	msysc_m$print_startcon();
	R1 = tou64("In function:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&loc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L6940:
	asu64(R1) = qq_decls_sptr;
	s = asu64(R1);
	R1 = (u64)&qq_decls_varstack;
	R2 = 0;
	R1 += (i64)R2;
	send = asu64(R1);
	R1 = 0;
	count = asi64(R1);
	goto L6942;
L6941:
	asu64(R1) = s;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L6945;
	asu64(R1) = s;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 1;
	R1 -= (i64)R2*32;
	pc = asu64(R1);
	asu64(R1) = pc;
	(R1_B12) = qq_runaux_getpcerrorpos(asu64(R1));
	loc2 = (R1_B12);
	msysc_m$print_startcon();
	R1 = tou64("Called from line");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&loc2;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("in");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&loc2;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&count;
	(*toi64p(R1)) += 1;
L6945:
	R1 = (u64)&s;
	(*tou64p(R1)) -=16;
L6942:
	asu64(R1) = s;
	asu64(R2) = send;
	if (asu64(R1) < asu64(R2)) goto L6946;
	asi64(R1) = count;
	R2 = 5;
	if (asi64(R1) < asi64(R2)) goto L6941;
L6946:
	msysc_m$print_startcon();
	R1 = tou64("PC/STOPC");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&loc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	R1 = (u64)&loc;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("LOC.PM.FILESPEC=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&loc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	(R1_B12) = loc;
	qq_lib_stopcompiler((R1_B12));
	return;
}

static struct $B12 qq_runaux_getpcerrorpos(u64 pc) {
    u64 R1, R2, R3; struct $B12 R1_B12; 
	i64 offset;
	i64 pos;
	i64 soffset;
	i64 moduleno;
	u64 pcstart;
	u64 pcsrcstart;
	u64 pm;
	struct $B12 loc;
	R1 = (u64)&loc;
	memset(R1, 0, 48);
	R1 = (u64)&qq_decls_modules;
	asu64(R2) = pc;
	asi64(R2) = qq_runaux_findmodulefrompc(asu64(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	asu64(R1) = pm;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcstart = asu64(R1);
	asu64(R1) = pm;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcsrcstart = asu64(R1);
	asu64(R1) = pcstart;
	asu64(R2) = pc;
	asi64(R1) = qq_lib_getpcloffset(asu64(R2), asu64(R1));
	offset = asi64(R1);
	asu64(R1) = pcsrcstart;
	asi64(R2) = offset;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	asi64(R1) = pos;
	R2 = 0;
	R3 = 23;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = (u64)&loc;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = pos;
	R2 = 24;
	R3 = 31;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	moduleno = asi64(R1);
	asi64(R1) = moduleno;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6949;
	R1 = 1;
	moduleno = asi64(R1);
	R1 = 0;
	soffset = asi64(R1);
L6949:
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = moduleno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&loc;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&qq_decls_subprogs;
	asu64(R2) = pm;
	R3 = 44;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&loc;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&loc;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	(R1_B12) = loc;
	goto L6947;
L6947:
	return (R1_B12);
}

static i64 qq_runaux_findmodulefrompc(u64 pc) {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6953;
L6951:
	asu64(R1) = pc;
	R2 = (u64)&qq_decls_modules;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 56;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L6955;
	asu64(R1) = pc;
	R2 = (u64)&qq_decls_modules;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 64;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) >= asu64(R2)) goto L6955;
	asi64(R1) = i;
	goto L6950;
L6955:
	i += 1; if (i <= qq_decls_nmodules) goto L6951;
L6953:
	msysc_m$print_startcon();
	R1 = tou64("Can't find pcptr module");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc;
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	R1 = 0;
	goto L6950;
L6950:
	return asi64(R1);
}

static u64 qq_runaux_k_makelist(u64 sp, i64 lower, i64 n) {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	asu64(R1) = sp;
	asi64(R2) = n;
	R1 -= (i64)R2*16;
	R2 = 1;
	R1 += (i64)R2*16;
	x = asu64(R1);
	asu64(R1) = x;
	sp = asu64(R1);
	asi64(R1) = lower;
	asi64(R2) = n;
	asu64(R3) = sp;
	asu64(R4) = x;
	qq_lists_var_make_list(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = sp;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = sp;
	goto L6956;
L6956:
	return asu64(R1);
}

static void qq_runaux_k_len(u64 sp) {
    u64 R1, R2, R3, R4; 
	u64 p;
	i64 n;
	i64 t;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6959;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6959;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6959;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6959;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6960;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6961;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6961;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6961;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6962;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6963;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6964;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6965;
	goto L6966;
L6959:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	goto L6958;
L6960:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	goto L6958;
L6961:
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	n = asi64(R1);
	goto L6958;
L6962:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	goto L6958;
L6963:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 16;
	R4 = 63;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	goto L6958;
L6964:
	asu64(R1) = p;
	asi64(R1) = qq_decimal_obj_len_dec(asu64(R1));
	n = asi64(R1);
	goto L6958;
L6965:
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	t = asi64(R1);
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6968;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6968;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6968;
	goto L6969;
L6968:
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	n = asi64(R1);
	goto L6967;
L6969:
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	n = asi64(R1);
L6967:
	goto L6958;
L6966:
	asu64(R1) = sp;
	R2 = tou64("Len");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L6958:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6971;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6971:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_runaux_k_maths(u64 sp, i64 opc) {
    u64 R1, R2, R3; 
	r64 x;
	asu64(R1) = sp;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	x = asr64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6974;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6975;
	goto L6976;
L6974:
	asi64(R1) = opc;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6978;
	goto L6979;
L6978:
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) *= asi64(R1);
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6972;
	goto L6977;
L6979:
L6977:
	R1 = 2;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	x = asr64(R1);
	goto L6973;
L6975:
	goto L6973;
L6976:
	asu64(R1) = sp;
	R2 = tou64("Maths:");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L6973:
	asi64(R1) = opc;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6981;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6982;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6983;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6984;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6985;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6986;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6987;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6988;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6989;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6990;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6991;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6992;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L6993;
	goto L6994;
L6981:
	asr64(R1) = x;
	asr64(R1) *= asr64(R1);
	x = asr64(R1);
	goto L6980;
L6982:
	asr64(R1) = x;
	asr64(R1) = sqrt(asr64(R1));
	x = asr64(R1);
	goto L6980;
L6983:
	asr64(R1) = x;
	asr64(R1) = sin(asr64(R1));
	x = asr64(R1);
	goto L6980;
L6984:
	asr64(R1) = x;
	asr64(R1) = cos(asr64(R1));
	x = asr64(R1);
	goto L6980;
L6985:
	asr64(R1) = x;
	asr64(R1) = tan(asr64(R1));
	x = asr64(R1);
	goto L6980;
L6986:
	asr64(R1) = x;
	asr64(R1) = asin(asr64(R1));
	x = asr64(R1);
	goto L6980;
L6987:
	asr64(R1) = x;
	asr64(R1) = acos(asr64(R1));
	x = asr64(R1);
	goto L6980;
L6988:
	asr64(R1) = x;
	asr64(R1) = atan(asr64(R1));
	x = asr64(R1);
	goto L6980;
L6989:
	asr64(R1) = x;
	asr64(R1) = log(asr64(R1));
	x = asr64(R1);
	goto L6980;
L6990:
	asr64(R1) = x;
	asr64(R1) = log10(asr64(R1));
	x = asr64(R1);
	goto L6980;
L6991:
	asr64(R1) = x;
	asr64(R2) = 0.000000000000000000e+000;
	if (asr64(R1) < asr64(R2)) goto L6996;
	asr64(R1) = x;
	asr64(R2) = 5.000000000000000000e-001;
	asr64(R1) += asr64(R2);
	asr64(R1) = floor(asr64(R1));
	x = asr64(R1);
	goto L6995;
L6996:
	asr64(R1) = x;
	asr64(R2) = 5.000000000000000000e-001;
	asr64(R1) -= asr64(R2);
	asr64(R1) = ceil(asr64(R1));
	x = asr64(R1);
L6995:
	goto L6980;
L6992:
	asr64(R1) = x;
	asr64(R1) = floor(asr64(R1));
	x = asr64(R1);
	goto L6980;
L6993:
	asr64(R1) = x;
	asr64(R1) = ceil(asr64(R1));
	x = asr64(R1);
	goto L6980;
L6994:
	R1 = (u64)&qq_tables_mathsnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = tou64("Maths op:");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6980:
	asr64(R1) = x;
	asu64(R2) = sp;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
L6972:
	return;
}

static void qq_runaux_k_maths2(u64 x, u64 y, i64 opc) {
    u64 R1, R2, R3; 
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L7000;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6999;
L7000:
	R1 = tou64("");
	R2 = tou64("maths2");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6999:
	goto L7002;
L7002:
	R1 = (u64)&qq_tables_mathsnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = tou64("Maths2:");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	return;
}

static void qq_runaux_k_lwb(u64 sp) {
    u64 R1, R2, R3; 
	u64 p;
	i64 n;
	i64 t;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7005;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7006;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7006;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7007;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7007;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7008;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7008;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7009;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7010;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7011;
	goto L7012;
L7005:
	asu64(R1) = p;
	R2 = 6;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	n = asi64(R1);
	goto L7004;
L7006:
	R1 = 1;
	n = asi64(R1);
	goto L7004;
L7007:
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	n = asi64(R1);
	goto L7004;
L7008:
	R1 = 1;
	n = asi64(R1);
	goto L7004;
L7009:
	R1 = (u64)&qq_tables_ttlower;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	n = asi64(R1);
	goto L7004;
L7010:
	R1 = 0;
	n = asi64(R1);
	goto L7004;
L7011:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	R3 = 63;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	n = asi64(R1);
	goto L7004;
L7012:
	asu64(R1) = sp;
	R2 = tou64("Lwb");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7004:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7014;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L7014:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_runaux_k_upb(u64 sp) {
    u64 R1, R2, R3; 
	u64 p;
	i64 n;
	i64 t;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7017;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7018;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7018;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7019;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7019;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7020;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7020;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7021;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7022;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7023;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L7024;
	goto L7025;
L7017:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 6;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	goto L7016;
L7018:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	goto L7016;
L7019:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 4;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 0;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	goto L7016;
L7020:
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	n = asi64(R1);
	goto L7016;
L7021:
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	t = asi64(R1);
	goto L7026;
	goto L7016;
L7022:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	goto L7016;
L7023:
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	goto L7016;
L7024:
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	t = asi64(R1);
// qq_runaux.k_upb.dotype:
L7026:
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7028;
	goto L7029;
L7028:
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&qq_tables_ttlower;
	asi64(R3) = t;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	goto L7027;
L7029:
	asu64(R1) = sp;
	R2 = tou64("t.upb");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7027:
	goto L7016;
L7025:
	asu64(R1) = sp;
	R2 = tou64("Upb");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7016:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7031;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L7031:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_runaux_k_swap(u64 x, u64 y) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	struct $B64 tempbuffer;
	struct $B3 v;
	i64 s;
	i64 t;
	i64 n;
	u64 p;
	u64 q;
	i64 a;
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L7034;
	R1 = tou64("");
	R2 = tou64("Swap mismatch");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7034:
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7036;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L7037;
	goto L7038;
L7036:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(R1_B3) = *(struct $B3*)(R1);
	v = (R1_B3);
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = x;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*(struct $B3*)(R2) = (R1_B3);
	(R1_B3) = v;
	asu64(R2) = y;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*(struct $B3*)(R2) = (R1_B3);
	goto L7035;
L7037:
	asu64(R1) = x;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	s = asi64(R1);
	asu64(R1) = y;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	t = asi64(R1);
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) == asi64(R2)) goto L7040;
	goto L7041;
L7040:
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = s;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7043;
	goto L7044;
L7043:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	a = asi64(R1);
	asu64(R1) = q;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = a;
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
	goto L7042;
L7044:
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = s;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 1024;
	if (asi64(R1) > asi64(R2)) goto L7046;
	asi64(R1) = n;
	asu64(R2) = x;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&tempbuffer;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	asu64(R2) = y;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = x;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&tempbuffer;
	asu64(R3) = y;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L7045;
L7046:
	goto L7041;
L7045:
L7042:
	goto L7035;
L7038:
// qq_runaux.k_swap.swaperror:
L7041:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = tou64("Swap");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L7035:
	return;
}

static void qq_runaux_k_bounds(u64 sp, u64 lower, u64 upper) {
    u64 R1, R2, R3; 
	i64 a;
	i64 b;
	i64 m;
	i64 t;
	u64 p;
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	m = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asi64(R1) = m;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7049;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7050;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7050;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7051;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7051;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7052;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7053;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7053;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7054;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7055;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L7056;
	goto L7057;
L7049:
	asu64(R1) = p;
	R2 = 6;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	a = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = a;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	b = asi64(R1);
	goto L7048;
L7050:
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	a = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = a;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	b = asi64(R1);
	goto L7048;
L7051:
	R1 = 1;
	a = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	b = asi64(R1);
	goto L7048;
L7052:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	R3 = 63;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	a = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	b = asi64(R1);
	goto L7048;
L7053:
	R1 = 1;
	a = asi64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	b = asi64(R1);
	goto L7048;
L7054:
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	t = asi64(R1);
	goto L7058;
	goto L7048;
L7055:
	R1 = 0;
	a = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	b = asi64(R1);
	goto L7048;
L7056:
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	t = asi64(R1);
// qq_runaux.k_bounds.dotype:
L7058:
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7060;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7060;
	goto L7061;
L7060:
	R1 = (u64)&qq_tables_ttlower;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	a = asi64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asi64(R2) = a;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	b = asi64(R1);
	goto L7059;
L7061:
	asu64(R1) = sp;
	R2 = tou64("t.bounds");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7059:
	goto L7048;
L7057:
	asu64(R1) = sp;
	R2 = tou64("Bounds");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7048:
	asi64(R1) = a;
	asu64(R2) = lower;
	*toi64p(R2) = asi64(R1);
	asi64(R1) = b;
	asu64(R2) = upper;
	*toi64p(R2) = asi64(R1);
	return;
}

static i64 qq_runaux_k_type(u64 sp, i64 n) {
    u64 R1, R2, R3; 
	i64 t;
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	t = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7064;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7065;
	goto L7066;
L7064:
	goto L7063;
L7065:
	asi64(R1) = t;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7068;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7068;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7068;
	goto L7069;
L7068:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	t = asi64(R1);
	goto L7067;
L7069:
L7067:
	goto L7063;
L7066:
	asi64(R1) = t;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7071;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7071;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L7072;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7072;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7072;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7073;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7074;
	goto L7075;
L7071:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	t = asi64(R1);
	goto L7070;
L7072:
	asu64(R1) = sp;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	t = asi64(R1);
	goto L7070;
L7073:
	R1 = 33;
	t = asi64(R1);
	goto L7070;
L7074:
	R1 = (u64)&qq_tables_tttarget;
	asu64(R2) = sp;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	goto L7070;
L7075:
	R1 = 0;
	t = asi64(R1);
L7070:
L7063:
	asi64(R1) = t;
	goto L7062;
L7062:
	return asi64(R1);
}

static void qq_runaux_k_dot(u64 sp, u64 g) {
    u64 R1, R2, R3, R4, R5, R6; struct $B3 R1_B3; 
	u64 d;
	u64 p;
	u64 q;
	i64 rectype;
	struct $B3 v;
// qq_runaux.k_dot.restart:
L7077:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7079;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7079;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7080;
	goto L7081;
L7079:
	goto L7078;
L7080:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	sp = asu64(R1);
	goto L7077;
	goto L7078;
L7081:
	asu64(R1) = sp;
	R2 = tou64("1:dot/not record");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7078:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	rectype = asi64(R1);
	asi64(R1) = rectype;
	asu64(R2) = g;
	asu64(R1) = qq_runaux_resolvefield(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7083;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7084;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7085;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L7086;
	goto L7087;
L7083:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 108;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R3 = 16;
   if (asi64(R3) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R2) /= asi64(R3);
	R1 += (i64)R2*16;
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7089;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L7089:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7091;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L7091:
	asu64(R1) = p;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = sp;
	*(struct $B3*)(R2) = (R1_B3);
	goto L7082;
L7084:
	R1 = 0;
	R2 = (u64)&v;
	asu64(R3) = d;
	R4 = 116;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	asu64(R4) = sp;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R5) = d;
	R6 = 108;
	asi16(R5) = *toi16p(((i64)R5+(i64)R6));
	R5 = toi64(toi16(R5));
	R4 += (i64)R5;
	qq_packed_var_loadpacked(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7093;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L7093:
	(R1_B3) = v;
	asu64(R2) = sp;
	*(struct $B3*)(R2) = (R1_B3);
	goto L7082;
L7085:
	R1 = 17;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = d;
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L7082;
L7086:
	R1 = 17;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L7082;
L7087:
	R1 = (u64)&qq_tables_namenames;
	asu64(R2) = d;
	R3 = 124;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("DOT: can't do this fieldtype:");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7082:
	return;
}

static void qq_runaux_k_dotref(u64 sp, u64 g) {
    u64 R1, R2, R3; 
	u64 d;
	u64 p;
	u64 q;
	i64 rectype;
// qq_runaux.k_dotref.restart:
L7095:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7097;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7097;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7098;
	goto L7099;
L7097:
	goto L7096;
L7098:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	sp = asu64(R1);
	goto L7095;
	goto L7096;
L7099:
	asu64(R1) = sp;
	R2 = tou64("2:dot/not record");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7096:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	rectype = asi64(R1);
	asi64(R1) = rectype;
	asu64(R2) = g;
	asu64(R1) = qq_runaux_resolvefield(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7101;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7102;
	goto L7103;
L7101:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 108;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R3 = 16;
   if (asi64(R3) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R2) /= asi64(R3);
	R1 += (i64)R2*16;
	p = asu64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7105;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L7105:
	R1 = 14;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L7100;
L7102:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 108;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R1 += (i64)R2;
	q = asu64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7107;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L7107:
	R1 = 16;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = q;
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = sp;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L7100;
L7103:
	R1 = (u64)&qq_tables_namenames;
	asu64(R2) = d;
	R3 = 124;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("DOTREF: can't do this fieldtype:");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7100:
	return;
}

static u64 qq_runaux_k_popdot(u64 sp, u64 g) {
    u64 R1, R2, R3, R4, R5; struct $B3 R1_B3; 
	u64 d;
	u64 p;
	u64 x;
	u64 y;
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7110;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7110;
	goto L7111;
L7110:
	goto L7109;
L7111:
	asu64(R1) = x;
	R2 = tou64("3:dot/not record");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7109:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = g;
	asu64(R1) = qq_runaux_resolvefield(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7113;
	R1 = tou64("");
	R2 = tou64("POPDOT");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7113:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L7115;
	qq_lib_pcnotmut();
L7115:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7117;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7118;
	goto L7119;
L7117:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 108;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R3 = 16;
   if (asi64(R3) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R2) /= asi64(R3);
	R1 += (i64)R2*16;
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7121;
	asu64(R1) = p;
	qq_vars_var_unshareu(asu64(R1));
L7121:
	asu64(R1) = y;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = p;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7123;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L7123:
	goto L7116;
L7118:
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = y;
	asu64(R3) = x;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = d;
	R5 = 108;
	asi16(R4) = *toi16p(((i64)R4+(i64)R5));
	R4 = toi64(toi16(R4));
	R3 += (i64)R4;
	qq_packed_var_storepacked(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7125;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L7125:
	goto L7116;
L7119:
	R1 = (u64)&qq_tables_namenames;
	asu64(R2) = d;
	R3 = 124;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("POPDOT: can't do this fieldtype:");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7116:
	asu64(R1) = sp;
	goto L7108;
L7108:
	return asu64(R1);
}

static u64 qq_runaux_resolvefield(u64 g, i64 rectype) {
    u64 R1, R2; 
	u64 d;
	goto L7128;
L7127:
	asu64(R1) = g;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asi64(R2) = rectype;
	if (asi64(R1) != asi64(R2)) goto L7131;
	asu64(R1) = d;
	goto L7126;
L7131:
	asu64(R1) = g;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	g = asu64(R1);
L7128:
	asu64(R1) = g;
	if (asu64(R1)) goto L7127;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't resolve field:");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	R1 = 0;
	goto L7126;
L7126:
	return asu64(R1);
}

static void qq_runaux_k_convrefpack(u64 sp) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 tag;
	i64 elemtype;
	u64 p;
	u64 pa;
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7134;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L7135;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7135;
	goto L7136;
L7134:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7138;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L7138;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7139;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7140;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7141;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7142;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7143;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7144;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7145;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7146;
	goto L7147;
L7138:
	asu64(R1) = a;
	R2 = 8;
	R1 += (i64)R2;
	p = asu64(R1);
	R1 = 26;
	elemtype = asi64(R1);
	goto L7137;
L7139:
	asu64(R1) = a;
	R2 = 8;
	R1 += (i64)R2;
	p = asu64(R1);
	R1 = 32;
	elemtype = asi64(R1);
	goto L7137;
L7140:
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = pa;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	goto L7137;
L7141:
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pa;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&qq_tables_ttbitwidth;
	asu64(R3) = pa;
	R4 = 6;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) *= asi64(R2);
	asu64(R2) = sp;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = sp;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 15;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pa;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = sp;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L7132;
	goto L7137;
L7142:
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = sp;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = sp;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 15;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 33;
	asu64(R2) = sp;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L7132;
	goto L7137;
L7143:
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = 27;
	elemtype = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7149;
	R1 = tou64("");
	p = asu64(R1);
L7149:
	goto L7137;
L7144:
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = pa;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	goto L7137;
L7145:
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = pa;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	goto L7137;
L7146:
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = 25;
	elemtype = asi64(R1);
	goto L7137;
L7147:
	asu64(R1) = a;
	R2 = tou64("Getrefpack1");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7137:
	goto L7133;
L7135:
	goto L7132;
	goto L7133;
L7136:
	asu64(R1) = sp;
	R2 = tou64("Getrefpack2");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7133:
// qq_runaux.k_convrefpack.done:
	R1 = 16;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = elemtype;
	asu64(R2) = sp;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L7132:
	return;
}

static void qq_runaux_k_incrptr(u64 p, i64 step) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7153;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L7154;
	goto L7155;
L7153:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7157;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7158;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L7159;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7160;
	goto L7161;
L7157:
	asi64(R1) = step;
	asu64(R2) = p;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
	goto L7156;
L7158:
	asi64(R1) = step;
	asu64(R2) = p;
	R3 = 8;
	R2 += (i64)R3;
	*tou64p(R2) += asu64(R1)*16;
	goto L7156;
L7159:
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asi64(R2) = step;
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 8;
	R2 += (i64)R3;
	*tou64p(R2) += asu64(R1);
	goto L7156;
L7160:
	asi64(R1) = step;
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) += asr64(R1);
	goto L7156;
L7161:
	asu64(R1) = p;
	R2 = tou64("incrptr/refvar");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7156:
	goto L7152;
L7154:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L7163;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L7163;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L7164;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L7164;
	goto L7165;
L7163:
	asi64(R1) = step;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*tou8p(R2) += asu8(R1);
	goto L7162;
L7164:
	asi64(R1) = step;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*tou16p(R2) += asu16(R1);
	goto L7162;
L7165:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = tou64("incrptr/ref");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L7162:
	goto L7152;
L7155:
	asu64(R1) = p;
	R2 = tou64("incrptr");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7152:
	return;
}

static i64 qq_runaux_k_cmp(i64 cc, u64 x, u64 y) {
    u64 R1, R2; 
	i64 res;
	asi64(R1) = cc;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7168;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7169;
	goto L7170;
L7168:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_equal(asu64(R2), asu64(R1));
	goto L7167;
L7169:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_equal(asu64(R2), asu64(R1));
	asi64(R1) = !asi64(R1);
	goto L7167;
L7170:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_compare(asu64(R2), asu64(R1));
	res = asi64(R1);
	asi64(R1) = cc;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7172;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7173;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7174;
	goto L7175;
L7172:
	asi64(R1) = res;
	R2 = 0;
	asi64(R1) = asi64(R1)  <  asi64(R2);
	goto L7171;
L7173:
	asi64(R1) = res;
	R2 = 0;
	asi64(R1) = asi64(R1)  <=  asi64(R2);
	goto L7171;
L7174:
	asi64(R1) = res;
	R2 = 0;
	asi64(R1) = asi64(R1)  >=  asi64(R2);
	goto L7171;
L7175:
	asi64(R1) = res;
	R2 = 0;
	asi64(R1) = asi64(R1)  >  asi64(R2);
L7171:
L7167:
	goto L7166;
L7166:
	return asi64(R1);
}

static i64 qq_runaux_k_bytesize(u64 sp) {
    u64 R1, R2, R3, R4; 
	i64 t;
	u64 p;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	t = asi64(R1);
	asi64(R1) = t;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L7178;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7179;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7179;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7179;
	goto L7180;
L7178:
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	t = asi64(R1);
	goto L7177;
L7179:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	t = asi64(R1);
	goto L7177;
L7180:
L7177:
	asi64(R1) = t;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7182;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7183;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7184;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7185;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7186;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7186;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7187;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7187;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7187;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7188;
	goto L7189;
L7182:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_tables_ttsize;
	asu64(R3) = p;
	R4 = 6;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	goto L7181;
L7183:
	R1 = 33;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_bits_getbitssize(asi64(R2), asi64(R1));
	goto L7181;
L7184:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L7181;
L7185:
	asu64(R1) = p;
	asi64(R1) = qq_bits_bits_bytesize(asu64(R1));
	goto L7181;
L7186:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) *= asi64(R2);
	goto L7181;
L7187:
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	goto L7181;
L7188:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4;
	asi64(R1) *= asi64(R2);
	goto L7181;
L7189:
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
L7181:
	goto L7176;
L7176:
	return asi64(R1);
}

static i64 qq_runaux_k_when(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	R2 = 65540;
	if (asi64(R1) == asi64(R2)) goto L7192;
	R2 = 65541;
	if (asi64(R1) == asi64(R2)) goto L7193;
	R2 = 1179653;
	if (asi64(R1) == asi64(R2)) goto L7193;
	goto L7194;
L7192:
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 16;
	R4 = 63;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asi64(R1) < asi64(R2)) goto L7196;
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L7196;
	R1 = 1;
	goto L7195;
L7196:
	R1 = 0;
L7195:
	goto L7191;
L7193:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_sets_var_in_set(asu64(R2), asu64(R1));
	goto L7191;
L7194:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_equal(asu64(R2), asu64(R1));
L7191:
	goto L7190;
L7190:
	return asi64(R1);
}

static u64 qq_runaux_raiseexception(i64 exceptno) {
    u64 R1, R2, R3; 
	u64 stackend;
	u64 oldsptr;
	R1 = (u64)&qq_decls_varstack;
	R2 = 0;
	R1 += (i64)R2;
	stackend = asu64(R1);
	asu64(R1) = qq_decls_sptr;
	oldsptr = asu64(R1);
L7198:
	asu64(R1) = qq_decls_sptr;
	asu64(R2) = stackend;
	if (asu64(R1) > asu64(R2)) goto L7201;
	asu64(R1) = oldsptr;
	qq_decls_sptr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("DEFAULT EXCEPTION");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7201:
	asu64(R1) = qq_decls_sptr;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L7203;
	asi64(R1) = exceptno;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7204;
	asu64(R1) = qq_decls_sptr;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = exceptno;
	if (asi64(R1) != asi64(R2)) goto L7203;
L7204:
	goto L7199;
L7203:
	asu64(R1) = qq_decls_sptr;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7206;
	asu64(R1) = qq_decls_sptr;
	qq_vars_var_unshareu(asu64(R1));
L7206:
	R1 = (u64)&qq_decls_sptr;
	(*tou64p(R1)) -=16;
	goto L7198;
L7199:
	asu64(R1) = qq_decls_sptr;
	asu64(R2) = qq_decls_sptr;
	R3 = 4;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R1 += (i64)R2;
	qq_decls_frameptr = asu64(R1);
	asu64(R1) = qq_decls_sptr;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L7197;
L7197:
	return asu64(R1);
}

static i64 qq_runaux_runproc_m(u64 amsg) {
    u64 R1, R2, R3, R4; 
	struct $B3 a;
	struct $B3 b;
	struct $B3 dest;
	i64 i;
	i64 result;
	struct $B31 obj;
	asi64(R1) = qq_runaux_runproc_m_rmsg_typeno;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7209;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_tables_ntypes;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7212;
L7210:
	R1 = tou64("ws_msg64");
	R2 = (u64)&qq_tables_ttname;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7214;
	asi64(R1) = i;
	qq_runaux_runproc_m_rmsg_typeno = asi64(R1);
	goto L7212;
L7214:
	i += 1; if (i <= qq_tables_ntypes) goto L7210;
L7212:
L7209:
	asi64(R1) = qq_runaux_runproc_m_rmsg_typeno;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7216;
	R1 = tou64("mainwndproc: can't find rmsg");
	mlib_abortprogram(asu64(R1));
L7216:
	R1 = 32;
	R2 = 0;
	R3 = (u64)&obj;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 99;
	R2 = (u64)&obj;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = amsg;
	R2 = (u64)&obj;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = qq_runaux_runproc_m_rmsg_typeno;
	R2 = (u64)&obj;
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 269;
	R2 = (u64)&a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&obj;
	R2 = (u64)&a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&dest;
	R2 = 0;
	R3 = (u64)&a;
	asu64(R4) = qq_decls_pcl_callbackfn;
	qq_runaux_runproc(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&dest;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	result = asi64(R1);
	R1 = 0;
	result = asi64(R1);
	asi64(R1) = result;
	goto L7207;
L7207:
	return asi64(R1);
}

static void qq_runaux_runproc(u64 fnptr, u64 a, u64 b, u64 dest) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 oldsptr;
	u64 oldframeptr;
	u64 oldpcptr;
	u8 oldstopped;
	i64 nparams;
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = qq_decls_stopped;
	oldstopped = asu8(R1);
	asu64(R1) = qq_decls_pcptr;
	oldpcptr = asu64(R1);
	asu64(R1) = qq_decls_sptr;
	oldsptr = asu64(R1);
	asu64(R1) = qq_decls_frameptr;
	oldframeptr = asu64(R1);
	R1 = 999;
	R2 = (u64)&qq_decls_sptr;
	asu64(R2) = *(tou64p(R2)) += 16;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = b;
	if (!asu64(R1)) goto L7219;
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7219;
	R1 = 2;
	nparams = asi64(R1);
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	R2 = (u64)&qq_decls_sptr;
	asu64(R2) = *(tou64p(R2)) += 16;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = b;
	(R1_B3) = *(struct $B3*)(R1);
	R2 = (u64)&qq_decls_sptr;
	asu64(R2) = *(tou64p(R2)) += 16;
	*(struct $B3*)(R2) = (R1_B3);
	goto L7218;
L7219:
	asu64(R1) = a;
	if (!asu64(R1)) goto L7220;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7220;
	R1 = 1;
	nparams = asi64(R1);
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	R2 = (u64)&qq_decls_sptr;
	asu64(R2) = *(tou64p(R2)) += 16;
	*(struct $B3*)(R2) = (R1_B3);
	goto L7218;
L7220:
	R1 = 0;
	nparams = asi64(R1);
L7218:
	R1 = 20;
	R2 = (u64)&qq_decls_sptr;
	asu64(R2) = *(tou64p(R2)) += 16;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = qq_decls_stopseq;
	asu64(R2) = qq_decls_sptr;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = qq_decls_frameptr;
	asu64(R2) = qq_decls_sptr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = qq_decls_sptr;
	qq_decls_frameptr = asu64(R1);
	asu64(R1) = fnptr;
	qq_decls_pcptr = asu64(R1);
	qq_runx_disploop();
	asu64(R1) = qq_decls_sptr;
	R2 = 11;
	R1 -= (i64)R2*16;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L7222;
	asu64(R1) = qq_decls_sptr;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = dest;
	*(struct $B3*)(R2) = (R1_B3);
	goto L7221;
L7222:
	R1 = (u64)&qq_decls_sptr;
	(*tou64p(R1)) -=16;
	asu64(R1) = qq_decls_sptr;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = dest;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = dest;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7224;
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L7224:
L7221:
	asu64(R1) = oldpcptr;
	qq_decls_pcptr = asu64(R1);
	asu8(R1) = oldstopped;
	R1 = toi64(tou8(R1));
	qq_decls_stopped = asi64(R1);
	asu64(R1) = oldsptr;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = oldframeptr;
	qq_decls_frameptr = asu64(R1);
	asu8(R1) = oldstopped;
	R1 = toi64(tou8(R1));
	qq_decls_stopped = asi64(R1);
	return;
}

static u64 qq_runaux_k_keyindex(u64 sp) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 d;
	u64 k;
	u64 p;
	u64 def;
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	def = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	k = asu64(R1);
	asu64(R1) = sp;
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7227;
	asu64(R1) = d;
	R2 = tou64("dict{}");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7227:
	R1 = 0;
	asu64(R2) = k;
	asu64(R3) = d;
	asu64(R1) = qq_dicts_var_finddictitem(asu64(R3), asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = d;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7229;
	asu64(R1) = d;
	qq_vars_var_unshareu(asu64(R1));
L7229:
	asu64(R1) = k;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7231;
	asu64(R1) = k;
	qq_vars_var_unshareu(asu64(R1));
L7231:
	asu64(R1) = p;
	if (!asu64(R1)) goto L7233;
	asu64(R1) = p;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = sp;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = def;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7235;
	asu64(R1) = def;
	qq_vars_var_unshareu(asu64(R1));
L7235:
	goto L7232;
L7233:
	asu64(R1) = def;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = sp;
	*(struct $B3*)(R2) = (R1_B3);
L7232:
	asu64(R1) = sp;
	goto L7225;
L7225:
	return asu64(R1);
}

static u64 qq_runaux_k_popkeyindex(u64 sp) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 d;
	u64 k;
	u64 p;
	u64 x;
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	k = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	d = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7238;
	asu64(R1) = d;
	R2 = tou64("dict{}:=");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7238:
	R1 = 1;
	asu64(R2) = k;
	asu64(R3) = d;
	asu64(R1) = qq_dicts_var_finddictitem(asu64(R3), asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7240;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7242;
	asu64(R1) = p;
	qq_vars_var_unshareu(asu64(R1));
L7242:
L7240:
	asu64(R1) = x;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = p;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = d;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7244;
	asu64(R1) = d;
	qq_vars_var_unshareu(asu64(R1));
L7244:
	asu64(R1) = k;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7246;
	asu64(R1) = k;
	qq_vars_var_unshareu(asu64(R1));
L7246:
	asu64(R1) = sp;
	goto L7236;
L7236:
	return asu64(R1);
}

static u64 qq_runaux_k_keyindexref(u64 sp) {
    u64 R1, R2, R3; 
	u64 d;
	u64 k;
	u64 p;
	u64 x;
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	k = asu64(R1);
	asu64(R1) = sp;
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7249;
	asu64(R1) = d;
	R2 = tou64("&dict{}");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7249:
	R1 = 0;
	asu64(R2) = k;
	asu64(R3) = d;
	asu64(R1) = qq_dicts_var_finddictitem(asu64(R3), asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7251;
	R1 = tou64("");
	R2 = tou64("&dict{} not found");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7251:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7253;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L7253:
	asu64(R1) = k;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7255;
	asu64(R1) = k;
	qq_vars_var_unshareu(asu64(R1));
L7255:
	asu64(R1) = d;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7257;
	asu64(R1) = d;
	qq_vars_var_unshareu(asu64(R1));
L7257:
	R1 = 14;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = sp;
	goto L7247;
L7247:
	return asu64(R1);
}

static u64 qq_runaux_k_map(u64 sp, u64 pc, u64 newsp) {
    u64 R1, R2, R3; struct $B31 R1_B31; 
	i64 nargs;
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L7260;
	goto L7261;
L7260:
	asu64(R1) = qq_runx_jumptable;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7263;
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_runaux_k_map_codeseq;
	R3 = 1;
	R2 += (i64)R3*32-32;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L7262;
L7263:
	asu64(R1) = qq_runx_jumptable;
	asu64(R2) = sp;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&qq_runaux_k_map_codeseq;
	R3 = 1;
	R2 += (i64)R3*32-32;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7262:
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	(R1_B31) = *(struct $B31*)(R1);
	R2 = (u64)&qq_runaux_k_map_codeseq;
	R3 = 2;
	*(struct $B31*)(((i64)R2+(i64)R3*32-32)) = (R1_B31);
	goto L7259;
L7261:
	R1 = tou64("");
	R2 = tou64("Apply:no op");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7259:
	asu64(R1) = sp;
	asu64(R2) = newsp;
	*tou64p(R2) = asu64(R1);
	R1 = (u64)&qq_runaux_k_map_codeseq;
	R2 = 0;
	R1 += (i64)R2;
	goto L7258;
L7258:
	return asu64(R1);
}

static void qq_runaux_k_maxval(u64 sp) {
    u64 R1, R2, R3; 
	i64 a;
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L7266;
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L7266:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L7268;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L7269;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L7270;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L7271;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L7272;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L7273;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L7274;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L7275;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7275;
	goto L7276;
L7268:
	R1 = 255;
	a = asi64(R1);
	goto L7267;
L7269:
	R1 = 65536;
	a = asi64(R1);
	goto L7267;
L7270:
	R1 = 4294967295;
	a = asi64(R1);
	goto L7267;
L7271:
	R1 = -1;
	a = asi64(R1);
	goto L7267;
L7272:
	R1 = 127;
	a = asi64(R1);
	goto L7267;
L7273:
	R1 = 32767;
	a = asi64(R1);
	goto L7267;
L7274:
	R1 = 2147483647;
	a = asi64(R1);
	goto L7267;
L7275:
	R1 = 9223372036854775807;
	a = asi64(R1);
	goto L7267;
L7276:
	asu64(R1) = sp;
	R2 = tou64("MAXVALUE");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7267:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = a;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&qq_decls_pcptr;
	(*tou64p(R1)) += 32;
	return;
}

static void qq_runaux_k_minval(u64 sp) {
    u64 R1, R2, R3; 
	i64 a;
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L7279;
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L7279:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L7281;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L7281;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L7281;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L7281;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L7282;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L7283;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L7284;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7285;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L7285;
	goto L7286;
L7281:
	R1 = 0;
	a = asi64(R1);
	goto L7280;
L7282:
	R1 = -128;
	a = asi64(R1);
	goto L7280;
L7283:
	R1 = -32768;
	a = asi64(R1);
	goto L7280;
L7284:
	R1 = -2147483648;
	a = asi64(R1);
	goto L7280;
L7285:
	R1 = 0x8000000000000000;
	a = asi64(R1);
	goto L7280;
L7286:
	asu64(R1) = sp;
	R2 = tou64("MINVALUE");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7280:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = a;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&qq_decls_pcptr;
	(*tou64p(R1)) += 32;
	return;
}

static void qq_sets_obj_free_set(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L7289;
	R1 = 33;
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_bits_getbitssize(asi64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L7289:
	asu64(R1) = p;
	mlib_pcm_free32(asu64(R1));
	return;
}

static void qq_sets_var_dupl_set(u64 a) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	i64 nbytes;
	i64 nbits;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	nbits = asi64(R1);
	asi64(R1) = nbits;
	asu64(R1) = qq_sets_obj_newset(asi64(R1));
	q = asu64(R1);
	asi64(R1) = nbits;
	if (!asi64(R1)) goto L7292;
	R1 = 33;
	asi64(R2) = nbits;
	asu64(R1) = qq_bits_getbitssize(asi64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = q;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L7292:
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static i64 qq_sets_var_equal_set(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	i64 xbytes;
	i64 ybytes;
	asu64(R1) = x;
	asi64(R1) = qq_sets_getsetbytes(asu64(R1));
	xbytes = asi64(R1);
	asu64(R1) = y;
	asi64(R1) = qq_sets_getsetbytes(asu64(R1));
	ybytes = asi64(R1);
	asi64(R1) = xbytes;
	asi64(R2) = ybytes;
	if (asi64(R1) == asi64(R2)) goto L7295;
	R1 = 0;
	goto L7293;
L7295:
	asi64(R1) = xbytes;
	asu64(R2) = y;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = x;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R1) = mlib_eqbytes(asu64(R3), asu64(R2), asi64(R1));
	goto L7293;
L7293:
	return asi64(R1);
}

static i64 qq_sets_getsetbytes(u64 x) {
    u64 R1, R2; 
	i64 nbits;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	nbits = asi64(R1);
	asi64(R1) = nbits;
	if (!asi64(R1)) goto L7298;
	asi64(R1) = nbits;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L7300;
	asi64(R1) = nbits;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	goto L7299;
L7300:
	asi64(R1) = nbits;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
L7299:
	goto L7297;
L7298:
	R1 = 0;
L7297:
	goto L7296;
L7296:
	return asi64(R1);
}

static void qq_sets_var_make_set(u64 data, u64 dest, i64 n) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 p;
	i64 top;
	i64 a;
	i64 b;
	i64 i;
	i64 j;
	i64 t;
	i64 size;
	u8 alloc;
	u64 s;
	i64 av_1;
	i64 av_2;
// PROC LOCAL STATICS GO HERE
	static i64 qq_sets_var_make_set_count = 0;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7303;
	asu64(R1) = dest;
	qq_sets_var_emptyset(asu64(R1));
	goto L7301;
L7303:
	R1 = 0;
	top = asi64(R1);
	asu64(R1) = data;
	q = asu64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7306;
L7304:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7308;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7309;
	goto L7310;
L7308:
	asu64(R1) = q;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	R3 = 63;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	a = asi64(R1);
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	b = asi64(R1);
	goto L7307;
L7309:
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7312;
	asi64(R1) = a;
	asi64(R1) = -asi64(R1);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	a = asi64(R1);
	asi64(R1) = a;
	asi64(R2) = top;
	if (asi64(R1) <= asi64(R2)) goto L7314;
	asi64(R1) = a;
	top = asi64(R1);
L7314:
	goto L7305;
L7312:
	asi64(R1) = a;
	b = asi64(R1);
	goto L7307;
L7310:
	asu64(R1) = q;
	asi64(R1) = qq_vars_var_getintvalue(asu64(R1));
	R2 = R1;
	a = asi64(R2);
	b = asi64(R1);
L7307:
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7317;
	asi64(R1) = b;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7316;
L7317:
	R1 = tou64("");
	R2 = tou64("Neg range element");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7316:
	asi64(R1) = a;
	R2 = (u64)&top;
    *toi64p(R2) = Max(*toi64p(R2), asi64(R1));
	asi64(R1) = b;
	R2 = (u64)&top;
    *toi64p(R2) = Max(*toi64p(R2), asi64(R1));
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
L7305:
	if (--asi64(av_1)) goto L7304;
L7306:
	asi64(R1) = top;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = qq_sets_obj_newset(asi64(R1));
	s = asu64(R1);
	asu64(R1) = data;
	q = asu64(R1);
	asi64(R1) = n;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7320;
L7318:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7322;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7323;
	goto L7324;
L7322:
	asu64(R1) = q;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	R3 = 63;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	a = asi64(R1);
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	b = asi64(R1);
	asi64(R1) = a;
	asi64(R2) = b;
	if (asi64(R1) <= asi64(R2)) goto L7326;
	R1 = (u64)&a;
	R2 = (u64)&b;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
L7326:
	goto L7321;
L7323:
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	a = asi64(R2);
	b = asi64(R1);
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7328;
	goto L7319;
L7328:
	goto L7321;
L7324:
	asu64(R1) = q;
	asi64(R1) = qq_vars_var_getintvalue(asu64(R1));
	R2 = R1;
	a = asi64(R2);
	b = asi64(R1);
L7321:
	asi64(R1) = b;
	asi64(R2) = a;
	asu64(R3) = s;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_lib_setelemblock(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
L7319:
	if (--asi64(av_2)) goto L7318;
L7320:
	asu64(R1) = dest;
	asu64(R2) = s;
	R3 = 5;
	qq_vars_var_objtovar(asi64(R3), asu64(R2), asu64(R1));
L7301:
	return;
}

static u64 qq_sets_obj_newset(i64 length) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	i64 nbits;
	i64 nbytes;
	asu64(R1) = qq_vars_obj_new();
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = 64;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) *= asi64(R2);
	nbytes = asi64(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L7331;
	asi64(R1) = nbytes;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_clearmem(asu64(R2), asi64(R1));
	goto L7330;
L7331:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7330:
	asu64(R1) = p;
	goto L7329;
L7329:
	return asu64(R1);
}

static void qq_sets_var_emptyset(u64 dest) {
    u64 R1, R2, R3; 
	asu64(R1) = dest;
	R2 = 0;
	asu64(R2) = qq_sets_obj_newset(asi64(R2));
	R3 = 5;
	qq_vars_var_objtovar(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void qq_sets_var_getix_set(u64 a, i64 index) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asi64(R1) = index;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L7335;
	R1 = tou64("");
	R2 = tou64("set[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7335:
	R1 = 1;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = index;
	R3 = 3;
	asi64(R2) >>= asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R3) = index;
	R4 = 7;
	asi64(R3) &= asi64(R4);
	asi64(R2) <<= asi64(R3);
	asi64(R1) &= asi64(R2);
	asi64(R1) = !!asi64(R1);
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_sets_var_putix_set(u64 a, i64 index, u64 x) {
    u64 R1, R2, R3, R4, R5; 
	u64 p;
	u64 q;
	i64 newoffset;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L7338;
	qq_lib_pcnotmut();
L7338:
	asi64(R1) = index;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L7340;
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7342;
	R1 = tou64("");
	R2 = tou64("lwb");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L7341;
L7342:
	R1 = tou64("");
	R2 = tou64("set[i]:=x bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7341:
L7340:
	R1 = (u64)&newoffset;
	asi64(R2) = index;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R1) = qq_sets_getoffset(asu64(R3), asi64(R2), asu64(R1));
	q = asu64(R1);
	R1 = 0;
	R2 = 33;
	asu64(R3) = x;
	asi64(R4) = newoffset;
	asu64(R5) = q;
	qq_vars_var_storebit(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void qq_sets_var_getixref_set(u64 a, i64 index) {
    u64 R1, R2, R3, R4; 
	struct $B3 v;
	u64 p;
	u64 q;
	i64 offset;
	i64 newoffset;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L7345;
	qq_lib_pcnotmut();
L7345:
	asi64(R1) = index;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L7347;
	R1 = tou64("");
	R2 = tou64("&set[i] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7347:
	R1 = (u64)&newoffset;
	asi64(R2) = index;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R1) = qq_sets_getoffset(asu64(R3), asi64(R2), asu64(R1));
	q = asu64(R1);
	R1 = 15;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 33;
	asu64(R2) = a;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = newoffset;
	asu64(R2) = a;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static u64 qq_sets_getoffset(u64 p, i64 index, u64 newoffset) {
    u64 R1, R2; 
	asi64(R1) = index;
	R2 = 3;
	asi64(R1) >>= asi64(R2);
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = index;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	asu64(R2) = newoffset;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = p;
	goto L7348;
L7348:
	return asu64(R1);
}

static i64 qq_sets_var_in_set(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	i64 i;
	i64 m;
	u64 p;
// PROC LOCAL STATICS GO HERE
	static u64 qq_sets_var_in_set_masks = -9205322385119247871;
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	i = asi64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asi64(R1) = i;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L7351;
	R1 = 0;
	goto L7349;
L7351:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	R3 = 3;
	asi64(R2) >>= asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&qq_sets_var_in_set_masks;
	asi64(R3) = i;
	R4 = 7;
	asi64(R3) &= asi64(R4);
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L7353;
	R1 = 1;
	goto L7352;
L7353:
	R1 = 0;
L7352:
	goto L7349;
L7349:
	return asi64(R1);
}

static void qq_sets_iresizeset(u64 p, i64 n) {
    u64 R1, R2; 
	u64 pp;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pp = asu64(R1);
	asu64(R1) = pp;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = n;
	if (asi64(R1) < asi64(R2)) goto L7356;
	goto L7354;
L7356:
	asi64(R1) = n;
	asu64(R2) = pp;
	qq_sets_obj_resize_set(asu64(R2), asi64(R1));
L7354:
	return;
}

static void qq_sets_obj_resize_set(u64 p, i64 n) {
    u64 R1, R2, R3; 
	u64 q;
	i64 newsize;
	i64 elemtype;
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L7359;
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L7358;
L7359:
	R1 = 33;
	asi64(R2) = n;
	asi64(R1) = qq_bits_getbitssize(asi64(R2), asi64(R1));
	newsize = asi64(R1);
	asi64(R1) = newsize;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L7361;
	R1 = 33;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_bits_getbitssize(asi64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 33;
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_bits_getbitssize(asi64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L7361:
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L7358:
	return;
}

static void qq_sets_iorsetbits(u64 p, u64 q, i64 n) {
    u64 R1, R2, R3; 
	i64 av_1;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = 64;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7365;
L7363:
	R1 = (u64)&q;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 8; asu64(R1) = asu64(R2);
	asi64(R1) = *toi64p(R1);
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 8; asu64(R2) = asu64(R3);
	*toi64p(R2) |= asi64(R1);
	if (--asi64(av_1)) goto L7363;
L7365:
	return;
}

static void qq_sets_ixorsetbits(u64 p, u64 q, i64 n) {
    u64 R1, R2, R3; 
	i64 av_1;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = 64;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7369;
L7367:
	R1 = (u64)&q;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 8; asu64(R1) = asu64(R2);
	asi64(R1) = *toi64p(R1);
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 8; asu64(R2) = asu64(R3);
	*toi64p(R2) ^= asi64(R1);
	if (--asi64(av_1)) goto L7367;
L7369:
	return;
}

static void qq_sets_iandsetbits(u64 p, u64 q, i64 n) {
    u64 R1, R2, R3; 
	i64 av_1;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = 64;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7373;
L7371:
	R1 = (u64)&q;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 8; asu64(R1) = asu64(R2);
	asi64(R1) = *toi64p(R1);
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 8; asu64(R2) = asu64(R3);
	*tou64p(R2) &= asu64(R1);
	if (--asi64(av_1)) goto L7371;
L7373:
	return;
}

static void qq_sets_inotsetbits(u64 p, i64 n) {
    u64 R1, R2; 
	i64 av_1;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = 64;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7377;
L7375:
	asu64(R1) = p;
	asu64(R1) = *tou64p(R1);
	asu64(R1) = ~asu64(R1);
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 8;
	if (--asi64(av_1)) goto L7375;
L7377:
	return;
}

static void qq_sets_var_iorto_set(u64 x, u64 y) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	i64 xlen;
	i64 ylen;
	i64 n;
	i64 i;
	u64 p;
	u64 px;
	u64 py;
	u64 pp;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	py = asu64(R1);
	asu64(R1) = px;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	xlen = asi64(R1);
	asu64(R1) = py;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	ylen = asi64(R1);
	asi64(R1) = ylen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7380;
	goto L7379;
L7380:
	asi64(R1) = xlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7381;
	asu64(R1) = y;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = x;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = x;
	qq_sets_var_dupl_set(asu64(R1));
	goto L7379;
L7381:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asi64(R1) = ylen;
	asu64(R2) = x;
	qq_sets_iresizeset(asu64(R2), asi64(R1));
	asi64(R1) = ylen;
	asu64(R2) = py;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = px;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_sets_iorsetbits(asu64(R3), asu64(R2), asi64(R1));
L7379:
	return;
}

static void qq_sets_var_iandto_set(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	i64 xlen;
	i64 ylen;
	i64 n;
	i64 i;
	u64 p;
	u64 px;
	u64 py;
	u64 pp;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	py = asu64(R1);
	asu64(R1) = px;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	xlen = asi64(R1);
	asu64(R1) = py;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	ylen = asi64(R1);
	asi64(R1) = ylen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7384;
	asu64(R1) = x;
	qq_sets_var_emptyset(asu64(R1));
	goto L7383;
L7384:
	asi64(R1) = xlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7385;
	goto L7383;
L7385:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asi64(R1) = ylen;
	asu64(R2) = x;
	qq_sets_iresizeset(asu64(R2), asi64(R1));
	asi64(R1) = ylen;
	asu64(R2) = py;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = px;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_sets_iandsetbits(asu64(R3), asu64(R2), asi64(R1));
L7383:
	return;
}

static void qq_sets_var_ixorto_set(u64 x, u64 y) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	i64 xlen;
	i64 ylen;
	i64 n;
	i64 i;
	u64 p;
	u64 px;
	u64 py;
	u64 pp;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	py = asu64(R1);
	asu64(R1) = px;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	xlen = asi64(R1);
	asu64(R1) = py;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	ylen = asi64(R1);
	asi64(R1) = ylen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7388;
	asu64(R1) = x;
	qq_sets_var_emptyset(asu64(R1));
	goto L7387;
L7388:
	asi64(R1) = xlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7389;
	asu64(R1) = y;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = x;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = x;
	qq_sets_var_dupl_set(asu64(R1));
	goto L7387;
L7389:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asi64(R1) = ylen;
	asu64(R2) = x;
	qq_sets_iresizeset(asu64(R2), asi64(R1));
	asi64(R1) = ylen;
	asu64(R2) = py;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = px;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_sets_ixorsetbits(asu64(R3), asu64(R2), asi64(R1));
L7387:
	return;
}

static void qq_sets_var_inotto_set(u64 x) {
    u64 R1, R2, R3; 
	i64 xlen;
	u64 px;
	u64 py;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asu64(R1) = px;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	xlen = asi64(R1);
	asi64(R1) = xlen;
	if (!asi64(R1)) goto L7392;
	asi64(R1) = xlen;
	asu64(R2) = px;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_sets_inotsetbits(asu64(R2), asi64(R1));
L7392:
	return;
}

static void qq_strings_start() {
    u64 R1, R2, R3; 
	asu64(R1) = qq_vars_obj_new();
	qq_strings_emptystring = asu64(R1);
	R1 = 1;
	asu64(R2) = qq_strings_emptystring;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = qq_strings_emptystring;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void qq_strings_var_empty_string(u64 dest, i64 mutable) {
    u64 R1, R2, R3; 
	R1 = 265;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mutable;
	if (asi64(R1)) goto L7396;
	asu64(R1) = qq_strings_emptystring;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = qq_strings_emptystring;
	(*tou32p(R1)) += 1;
	goto L7395;
L7396:
	R1 = 1;
	R2 = 0;
	R3 = 0;
	asu64(R1) = qq_strings_obj_make_stringn(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7395:
	return;
}

static void qq_strings_var_make_string(u64 s, u64 dest, i64 mutable) {
    u64 R1, R2, R3; 
	R1 = 265;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mutable;
	asu64(R2) = s;
	asu64(R1) = qq_strings_obj_make_string(asu64(R2), asi64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_strings_var_make_stringn(u64 s, i64 length, u64 dest, i64 mutable) {
    u64 R1, R2, R3; 
	R1 = 265;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mutable;
	asi64(R2) = length;
	asu64(R3) = s;
	asu64(R1) = qq_strings_obj_make_stringn(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 qq_strings_obj_new_string(i64 n) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = qq_vars_obj_new();
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L7401;
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L7401:
	asu64(R1) = p;
	goto L7399;
L7399:
	return asu64(R1);
}

static u64 qq_strings_obj_make_string(u64 s, i64 mutable) {
    u64 R1, R2, R3, R4; 
	u64 p;
	i64 n;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	asu64(R1) = qq_strings_obj_new_string(asi64(R1));
	p = asu64(R1);
	asi64(R1) = mutable;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L7404;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L7404:
	asu64(R1) = p;
	goto L7402;
L7402:
	return asu64(R1);
}

static u64 qq_strings_obj_make_stringn(u64 s, i64 length, i64 mutable) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asi64(R1) = length;
	asu64(R1) = qq_strings_obj_new_string(asi64(R1));
	p = asu64(R1);
	asi64(R1) = mutable;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L7407;
	asu64(R1) = s;
	if (!asu64(R1)) goto L7409;
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L7408;
L7409:
	asi64(R1) = length;
	R2 = 0;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memset(asu64(R3), asi32(R2), asu64(R1));
L7408:
L7407:
	asu64(R1) = p;
	goto L7405;
L7405:
	return asu64(R1);
}

static void qq_strings_obj_free_string(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L7412;
	asu64(R1) = p;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L7412:
	asu64(R1) = p;
	mlib_pcm_free32(asu64(R1));
	return;
}

static void qq_strings_var_dupl_string(u64 a) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_strings_obj_new_string(asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L7415;
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = q;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L7415:
	return;
}

static void qq_strings_var_getix_string(u64 a, i64 index) {
    u64 R1, R2, R3, R4; 
	u64 q;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asi64(R1) = index;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	asu64(R2) = q;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L7418;
	R1 = tou64("");
	R2 = tou64("getstring[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7418:
	asu64(R1) = a;
	asi64(R2) = index;
	asi64(R3) = index;
	asu64(R4) = a;
	qq_strings_stringslice(asu64(R4), asi64(R3), asi64(R2), asu64(R1));
	return;
}

static void qq_strings_var_getixref_string(u64 a, i64 index) {
    u64 R1, R2, R3; 
	u64 q;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asi64(R1) = index;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	asu64(R2) = q;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L7421;
	R1 = tou64("");
	R2 = tou64("getixref[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7421:
	R1 = 16;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 27;
	asu64(R2) = a;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = index;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_strings_var_getdotix_string(u64 a, i64 index) {
    u64 R1, R2, R3; 
	u64 q;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asi64(R1) = index;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	asu64(R2) = q;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L7424;
	R1 = tou64("");
	R2 = tou64("x.[] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7424:
	R1 = 1;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = index;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_strings_var_getdotixref_string(u64 a, i64 index, u64 dest) {
    u64 R1, R2, R3; 
	u64 q;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = (u64)&index;
	(*toi64p(R1)) -=1;
	asi64(R1) = index;
	asu64(R2) = q;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L7427;
	R1 = tou64("");
	R2 = tou64("x.[] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7427:
	R1 = 16;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 27;
	asu64(R2) = dest;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = index;
	R1 += (i64)R2;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_strings_var_getslice_string(u64 a, i64 i, i64 j) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7431;
	asi64(R1) = j;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L7431;
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) <= asi64(R2)) goto L7430;
L7431:
	R1 = tou64("");
	R2 = tou64("string/slice bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7430:
	asu64(R1) = a;
	asi64(R2) = j;
	asi64(R3) = i;
	asu64(R4) = a;
	qq_strings_stringslice(asu64(R4), asi64(R3), asi64(R2), asu64(R1));
	return;
}

static void qq_strings_stringslice(u64 a, i64 i, i64 j, u64 dest) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = qq_vars_obj_new();
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = q;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = j;
	asi64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = q;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = q;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7434;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7435;
	goto L7436;
L7434:
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
	goto L7433;
L7435:
	R1 = 0;
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2;
	asu64(R2) = q;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L7433;
L7436:
	asu64(R1) = p;
	(*tou32p(R1)) += 1;
	asu64(R1) = p;
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7433:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = q;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_strings_var_putix_string(u64 a, i64 index, u64 x) {
    u64 R1, R2, R3; 
	u64 s;
	u64 p;
	u64 q;
	i64 length;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L7439;
	qq_lib_pcnotmut();
L7439:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asi64(R1) = index;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7442;
	asi64(R2) = length;
	if (asi64(R1) <= asi64(R2)) goto L7441;
L7442:
	asi64(R1) = index;
	asi64(R2) = length;
	R3 = 1;
	asi64(R2) += asi64(R3);
	if (asi64(R1) != asi64(R2)) goto L7444;
	asu64(R1) = x;
	asu64(R2) = a;
	qq_strings_var_addto_string(asu64(R2), asu64(R1));
	goto L7437;
	goto L7443;
L7444:
	R1 = tou64("");
	R2 = tou64("putstring[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7443:
L7441:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = index;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	s = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7446;
	R1 = tou64("");
	R2 = tou64("s[i]:= not str");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7446:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7448;
	R1 = tou64("");
	R2 = tou64("s[i]:=\"\"");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7448:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
L7437:
	return;
}

static void qq_strings_var_putslice_string(u64 a, i64 i, i64 j, u64 x) {
    u64 R1, R2, R3; 
	u64 s;
	u64 p;
	u64 q;
	i64 length;
	i64 sublength;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L7451;
	qq_lib_pcnotmut();
L7451:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7454;
	asi64(R1) = j;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L7454;
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) <= asi64(R2)) goto L7453;
L7454:
	R1 = tou64("");
	R2 = tou64("string/slice bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7453:
	asi64(R1) = j;
	asi64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	sublength = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	s = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7456;
	R1 = tou64("");
	R2 = tou64("s[i..j]:= not str");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7456:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = sublength;
	if (asi64(R1) >= asi64(R2)) goto L7458;
	R1 = tou64("");
	R2 = tou64("substr too short");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7458:
	asi64(R1) = sublength;
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void qq_strings_var_putdotix_string(u64 a, i64 index, u64 x) {
    u64 R1, R2, R3; 
	u64 s;
	u64 p;
	u64 q;
	i64 length;
	i64 ch;
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7461;
	R1 = tou64("");
	R2 = tou64("s.[i]:= not int");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7461:
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	ch = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L7463;
	qq_lib_pcnotmut();
L7463:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asi64(R1) = index;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7466;
	asi64(R2) = length;
	if (asi64(R1) <= asi64(R2)) goto L7465;
L7466:
	asi64(R1) = index;
	asi64(R2) = length;
	R3 = 1;
	asi64(R2) += asi64(R3);
	if (asi64(R1) != asi64(R2)) goto L7468;
	asi64(R1) = ch;
	asu64(R2) = a;
	qq_strings_var_addto_string_ch(asu64(R2), asi64(R1));
	goto L7459;
	goto L7467;
L7468:
	R1 = tou64("");
	R2 = tou64("str.[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7467:
L7465:
	asi64(R1) = ch;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = index;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
L7459:
	return;
}

static void qq_strings_obj_resize_string(u64 p, i64 n) {
    u64 R1, R2, R3; 
	u64 s;
	i64 oldalloc;
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L7471;
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L7470;
L7471:
	asu64(R1) = p;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	oldalloc = asi64(R1);
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	s = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L7473;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = oldalloc;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L7473:
	asu64(R1) = s;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L7470:
	return;
}

static void qq_strings_var_add_string(u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	u64 p;
	u64 q;
	u64 r;
	i64 alen;
	i64 blen;
	i64 newlen;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	alen = asi64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	blen = asi64(R1);
	asi64(R1) = blen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7476;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
	goto L7474;
	goto L7475;
L7476:
	asi64(R1) = alen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7477;
	R1 = 1;
	asu64(R2) = a;
	asi64(R3) = blen;
	asu64(R4) = q;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	goto L7474;
L7477:
L7475:
	asi64(R1) = alen;
	asi64(R2) = blen;
	asi64(R1) += asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	asu64(R1) = qq_strings_obj_new_string(asi64(R1));
	r = asu64(R1);
	asi64(R1) = alen;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = r;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = blen;
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = r;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R4) = alen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = r;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7474:
	return;
}

static void qq_strings_var_addto_string(u64 a, u64 b) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	u64 p;
	u64 q;
	i64 alen;
	i64 blen;
	i64 newlen;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	alen = asi64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	blen = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L7480;
	qq_lib_pcnotmut();
L7480:
	asi64(R1) = blen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7482;
	goto L7478;
	goto L7481;
L7482:
	asi64(R1) = alen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7483;
	asu64(R1) = a;
	qq_vars_var_unshareu(asu64(R1));
	asu64(R1) = b;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = a;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = a;
	qq_vars_var_duplu(asu64(R1));
	goto L7478;
L7483:
L7481:
	asi64(R1) = alen;
	asi64(R2) = blen;
	asi64(R1) += asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	asu64(R2) = p;
	qq_strings_obj_resize_string(asu64(R2), asi64(R1));
	asi64(R1) = blen;
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R4) = alen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L7478:
	return;
}

static void qq_strings_var_addto_string_ch(u64 a, i64 ch) {
    u64 R1, R2, R3; 
	u64 p;
	i64 alen;
	i64 n;
	struct $B31 str;
	u64 s;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	alen = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L7486;
	qq_lib_pcnotmut();
L7486:
	asi64(R1) = alen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = p;
	qq_strings_obj_resize_string(asu64(R2), asi64(R1));
	asi64(R1) = ch;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = alen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static i64 qq_strings_var_equal_string(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	i64 n;
	i64 res;
	u64 px;
	u64 py;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	py = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = py;
	if (asu64(R1) != asu64(R2)) goto L7489;
	R1 = 1;
	goto L7487;
L7489:
	asu64(R1) = px;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = py;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) == asi64(R2)) goto L7491;
	R1 = 0;
	goto L7490;
L7491:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7492;
	R1 = 1;
	goto L7490;
L7492:
	asi64(R1) = n;
	asu64(R2) = py;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = px;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R1) = mlib_eqbytes(asu64(R3), asu64(R2), asi64(R1));
L7490:
	goto L7487;
L7487:
	return asi64(R1);
}

static i64 qq_strings_var_compare_string(u64 x, u64 y) {
    u64 R1, R2, R3, R4, R5; 
	i64 res;
	u64 px;
	u64 py;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	py = asu64(R1);
	asu64(R1) = py;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = px;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = py;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = px;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asi64(R1) = qq_strings_cmpstring_len(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	res = asi64(R1);
	asi64(R1) = res;
	goto L7493;
L7493:
	return asi64(R1);
}

static i64 qq_strings_cmpstring_len(u64 s, u64 t, i64 slen, i64 tlen) {
    u64 R1, R2, R3; 
	asi64(R1) = slen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7496;
	asi64(R1) = tlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7498;
	R1 = 0;
	goto L7497;
L7498:
	R1 = -1;
L7497:
	goto L7495;
L7496:
	asi64(R1) = tlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7499;
	R1 = 1;
	goto L7495;
L7499:
	asi64(R1) = slen;
	asi64(R2) = tlen;
	if (asi64(R1) != asi64(R2)) goto L7501;
	asi64(R1) = slen;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7503;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asu64(R2) = t;
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	if (asu64(R1) >= asu64(R2)) goto L7505;
	R1 = -1;
	goto L7494;
	goto L7504;
L7505:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asu64(R2) = t;
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	if (asu64(R1) <= asu64(R2)) goto L7506;
	R1 = 1;
	goto L7494;
	goto L7504;
L7506:
	R1 = 0;
	goto L7494;
L7504:
L7503:
	asi64(R1) = slen;
	asu64(R2) = t;
	asu64(R3) = s;
	asi64(R1) = mlib_cmpstringn(asu64(R3), asu64(R2), asi64(R1));
	goto L7500;
L7501:
	asi64(R1) = tlen;
	asu64(R2) = t;
	asu64(R1) = qq_lib_convtostringz(asu64(R2), asi64(R1));
	asi64(R2) = slen;
	asu64(R3) = s;
	asu64(R2) = qq_lib_convtostringz(asu64(R3), asi64(R2));
	asi64(R1) = mlib_cmpstring(asu64(R2), asu64(R1));
L7500:
L7495:
	goto L7494;
L7494:
	return asi64(R1);
}

static i64 qq_strings_var_inx_string(u64 x, u64 y) {
    u64 R1, R2; 
	i64 xlen;
	i64 ylen;
	i64 result;
	i64 i;
	i64 j;
	i64 k;
	u64 sx;
	u64 sy;
	u64 px;
	u64 py;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	py = asu64(R1);
	asu64(R1) = px;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	xlen = asi64(R1);
	asu64(R1) = py;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	ylen = asi64(R1);
	asi64(R1) = xlen;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7510;
	asi64(R1) = ylen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7509;
L7510:
	R1 = 0x8000000000000000;
	goto L7507;
L7509:
	asi64(R1) = ylen;
	asi64(R2) = xlen;
	asi64(R1) -= asi64(R2);
	k = asi64(R1);
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = k;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7513;
L7511:
	asu64(R1) = px;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	sx = asu64(R1);
	asu64(R1) = py;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	R1 += (i64)R2;
	sy = asu64(R1);
	R1 = 1;
	j = asi64(R1);
	asi64(R1) = xlen;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7516;
L7514:
	asu64(R1) = sx;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asu64(R2) = sy;
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	if (asu64(R1) == asu64(R2)) goto L7518;
	goto L7519;
L7518:
	R1 = (u64)&sx;
	(*tou64p(R1)) += 1;
	R1 = (u64)&sy;
	(*tou64p(R1)) += 1;
	j += 1; if (j <= xlen) goto L7514;
L7516:
	asi64(R1) = i;
	R2 = 1;
	asi64(R1) += asi64(R2);
	goto L7507;
// qq_strings.var_inx_string.nextpos:
L7519:
	i += 1; if (i <= k) goto L7511;
L7513:
	R1 = 0x8000000000000000;
	goto L7507;
L7507:
	return asi64(R1);
}

static void qq_strings_var_iconvcase(u64 a, u64 b, i64 upper) {
    u64 R1, R2, R3; 
	i64 i;
	i64 n;
	u64 s;
	u64 pa;
	i64 av_1;
	i64 av_2;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7522;
	asu64(R1) = b;
	asi64(R1) = qq_vars_var_getintvalue(asu64(R1));
	n = asi64(R1);
	goto L7521;
L7522:
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
L7521:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7524;
	R1 = tou64("");
	R2 = tou64("convcase/notstr");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7524:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7526;
	R1 = tou64("");
	R2 = tou64("CONVCASE N<0");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7526:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7528;
	goto L7520;
L7528:
	asi64(R1) = n;
	asu64(R2) = pa;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L7530;
	msysc_m$print_startcon();
	R1 = tou64("N=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("convcase/N?");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7530:
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asi64(R1) = upper;
	if (!asi64(R1)) goto L7532;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7535;
L7533:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L7533;
L7535:
	goto L7531;
L7532:
	asi64(R1) = n;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7538;
L7536:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = tolower(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_2)) goto L7536;
L7538:
L7531:
L7520:
	return;
}

static void qq_strings_var_makestrslicexobj(u64 s, i64 length, u64 dest) {
    u64 R1, R2, R3; 
	R1 = 265;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R1) = qq_strings_obj_make_strslicexobj(asu64(R2), asi64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 qq_strings_obj_make_strslicexobj(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 p;
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7542;
	R1 = 0;
	s = asu64(R1);
L7542:
	asu64(R1) = qq_vars_obj_new();
	p = asu64(R1);
	asu64(R1) = s;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 2;
	asu64(R2) = p;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L7540;
L7540:
	return asu64(R1);
}

static i64 qq_strings_var_asc(u64 a) {
    u64 R1, R2; 
	u64 p;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7545;
	R1 = tou64("");
	R2 = tou64("Asc:not str");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7545:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) >= asi64(R2)) goto L7547;
	R1 = tou64("");
	R2 = tou64("Asc:empty");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7547:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	goto L7543;
L7543:
	return asi64(R1);
}

static void qq_strings_var_new_string(u64 a, u64 b, u64 dest) {
    u64 R1, R2, R3, R4; 
	i64 length;
	i64 ch;
	asu64(R1) = a;
	asi64(R1) = qq_vars_var_getintvalue(asu64(R1));
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7550;
	R1 = tou64("");
	R2 = tou64("Length<0");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7550:
	R1 = 0;
	asu64(R2) = dest;
	asi64(R3) = length;
	R4 = 0;
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7552;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7553;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7554;
	goto L7555;
L7552:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	ch = asi64(R1);
	goto L7551;
L7553:
	asu64(R1) = b;
	asi64(R1) = qq_strings_var_asc(asu64(R1));
	ch = asi64(R1);
	goto L7551;
L7554:
	R1 = 32;
	ch = asi64(R1);
	goto L7551;
L7555:
	R1 = tou64("");
	R2 = tou64("Not int/str");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7551:
	asi64(R1) = length;
	if (!asi64(R1)) goto L7557;
	asi64(R1) = length;
	asi64(R2) = ch;
	asu64(R3) = dest;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memset(asu64(R3), asi32(R2), asu64(R1));
L7557:
	return;
}

static void qq_strings_var_new_stringn(i64 length, u64 dest) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7560;
	R1 = tou64("");
	R2 = tou64("Length<0");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7560:
	R1 = 0;
	asu64(R2) = dest;
	asi64(R3) = length;
	R4 = 0;
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_strings_var_mul_string(u64 a, i64 m) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	i64 i;
	i64 oldlen;
	i64 newlen;
	u64 newptr;
	u64 p;
	struct $B3 v;
	u64 pa;
	u64 s;
	i64 av_1;
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7563;
	R1 = tou64("");
	R2 = tou64("neg str mul");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L7562;
L7563:
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7564;
	R1 = 0;
	asu64(R2) = a;
	qq_strings_var_empty_string(asu64(R2), asi64(R1));
	goto L7561;
	goto L7562;
L7564:
	asi64(R1) = m;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7565;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
	goto L7561;
	goto L7562;
L7565:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	oldlen = asi64(R1);
	asi64(R1) = oldlen;
	if (!asi64(R1)) goto L7567;
	asi64(R1) = oldlen;
	asi64(R2) = m;
	asi64(R1) *= asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	asu64(R1) = qq_strings_obj_new_string(asi64(R1));
	R2 = (u64)&v;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 265;
	R2 = (u64)&v;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&v;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asi64(R1) = oldlen;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7569;
	asi64(R1) = m;
	asu64(R2) = pa;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	goto L7568;
L7569:
	asi64(R1) = m;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7572;
L7570:
	asi64(R1) = oldlen;
	asu64(R2) = pa;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = oldlen;
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	if (--asi64(av_1)) goto L7570;
L7572:
L7568:
	(R1_B3) = v;
	asu64(R2) = a;
	*(struct $B3*)(R2) = (R1_B3);
	goto L7566;
L7567:
	R1 = 0;
	asu64(R2) = a;
	qq_strings_var_empty_string(asu64(R2), asi64(R1));
	goto L7561;
L7566:
L7562:
L7561:
	return;
}

static void qq_strings_var_convert_string_list(u64 a, i64 t, u64 dest) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	i64 length;
	u64 s;
	i64 av_1;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	R1 = 1;
	asi64(R2) = length;
	asu64(R3) = dest;
	R4 = 0;
	qq_lists_var_make_list(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = dest;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7576;
L7574:
	R1 = 1;
	asu64(R2) = q;
	R3 = 1;
	asu64(R4) = s;
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L7574;
L7576:
	return;
}

static void qq_strings_var_expand_string(u64 a, u64 dest, i64 m) {
    u64 R1, R2, R3, R4; 
	u64 b;
	u64 c;
	u64 p;
	u64 s;
	i64 n;
	i64 av_1;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = dest;
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	R1 = 1;
	n = asi64(R1);
	asi64(R1) = m;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7580;
L7578:
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L7582;
	R1 = 0;
	asu64(R2) = dest;
	qq_strings_var_empty_string(asu64(R2), asi64(R1));
	goto L7581;
L7582:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 1;
	asu64(R4) = s;
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L7581:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	R1 = (u64)&dest;
	(*tou64p(R1)) -=16;
	if (--asi64(av_1)) goto L7578;
L7580:
	return;
}

static void qq_strings_var_makechar(i64 ch, u64 dest) {
    u64 R1, R2, R3, R4; 
	struct $B3 v;
	u64 str;
	u64 p;
	asi64(R1) = ch;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7586;
	R2 = 255;
	if (asi64(R1) <= asi64(R2)) goto L7585;
L7586:
	R1 = tou64("");
	R2 = tou64("chr range");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7585:
	R1 = (u64)&qq_decls_chrtable;
	asi64(R2) = ch;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7588;
	asi64(R1) = ch;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&v;
	R3 = 1;
	R4 = (u64)&str;
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&v;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	p = asu64(R2);
	R2 = (u64)&qq_decls_chrtable;
	asi64(R3) = ch;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
L7588:
	asu64(R1) = p;
	(*tou32p(R1)) += 1;
	R1 = 265;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 qq_syslibs_findsyslib(u64 filename) {
    u64 R1, R2; 
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	R1 = 17;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7592;
L7590:
	R1 = (u64)&qq_syslibs_syslibnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = filename;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7594;
	R1 = (u64)&qq_syslibs_libtext;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L7589;
L7594:
	i += 1; if (i <= av_1) goto L7590;
L7592:
	R1 = 0;
	goto L7589;
L7589:
	return asu64(R1);
}

static i64 qq_syslibs_loadsysmodule(u64 pm) {
    u64 R1, R2, R3; 
	u64 source;
	asu64(R1) = pm;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_syslibs_findsyslib(asu64(R1));
	source = asu64(R1);
	asu64(R1) = source;
	if (!asu64(R1)) goto L7597;
	asu64(R1) = source;
	asu64(R2) = pm;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = source;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = pm;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	goto L7596;
L7597:
	R1 = 0;
L7596:
	goto L7595;
L7595:
	return asi64(R1);
}

static void qq_tables_start() {
    u64 R1, R2, R3, R4; 
	i64 i;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 av_4;
	i64 av_5;
	i64 av_6;
	R1 = 1;
	i = asi64(R1);
	R1 = 27;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7601;
L7599:
	R1 = 1;
	R2 = (u64)&qq_tables_binopset;
	R3 = (u64)&qq_tables_d_binopset;
	asi64(R4) = i;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_exprstarterset;
	R3 = (u64)&qq_tables_d_binopset;
	asi64(R4) = i;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_1) goto L7599;
L7601:
	R1 = 1;
	i = asi64(R1);
	R1 = 7;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7604;
L7602:
	R1 = 1;
	R2 = (u64)&qq_tables_unaryopset;
	R3 = (u64)&qq_tables_d_unaryopset;
	asi64(R4) = i;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_exprstarterset;
	R3 = (u64)&qq_tables_d_unaryopset;
	asi64(R4) = i;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_2) goto L7602;
L7604:
	R1 = 1;
	i = asi64(R1);
	R1 = 26;
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7607;
L7605:
	R1 = 1;
	R2 = (u64)&qq_tables_exprstarterset;
	R3 = (u64)&qq_tables_d_exprstarterset;
	asi64(R4) = i;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_3) goto L7605;
L7607:
	R1 = 1;
	R2 = (u64)&qq_tables_exprendset;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_exprendset;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_exprendset;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_exprendset;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_exprendset;
	R3 = 79;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_exprendset;
	R3 = 87;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_exprendset;
	R3 = 85;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	i = asi64(R1);
	R1 = 10;
	av_4 = asi64(R1);
	asi64(R1) = av_4;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7610;
L7608:
	R1 = 1;
	R2 = (u64)&qq_tables_addopset;
	R3 = (u64)&qq_tables_d_addopset;
	asi64(R4) = i;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_4) goto L7608;
L7610:
	R1 = 1;
	i = asi64(R1);
	R1 = 7;
	av_5 = asi64(R1);
	asi64(R1) = av_5;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7613;
L7611:
	R1 = 1;
	R2 = (u64)&qq_tables_mulopset;
	R3 = (u64)&qq_tables_d_mulopset;
	asi64(R4) = i;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_5) goto L7611;
L7613:
	R1 = 1;
	i = asi64(R1);
	R1 = 6;
	av_6 = asi64(R1);
	asi64(R1) = av_6;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7616;
L7614:
	R1 = 1;
	R2 = (u64)&qq_tables_cmpopset;
	R3 = (u64)&qq_tables_d_cmpopset;
	asi64(R4) = i;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_6) goto L7614;
L7616:
	R1 = 0;
	i = asi64(R1);
L7617:
	R1 = (u64)&qq_tables_stdtypenames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&qq_tables_ttname;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = i;
	R2 = (u64)&qq_tables_ttbasetype;
	asi64(R3) = i;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_ttlower;
	asi64(R3) = i;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = (u64)&qq_tables_stdtypewidths;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_tables_ttbitwidth;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&qq_tables_stdtypewidths;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = (u64)&qq_tables_ttsize;
	asi64(R3) = i;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	i += 1; if (i <= 40) goto L7617;
	R1 = 40;
	qq_tables_ntypes = asi64(R1);
	return;
}

static void qq_show_printunit(u64 p, i64 level, u64 prefix, u64 dev) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 d;
	i64 t;
	i64 flags;
	u64 idname;
	i64 a;
	r32 x32;
	i64 i;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7622;
	goto L7620;
L7622:
	asu64(R1) = p;
	R2 = 4;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 16777215;
	asi64(R1) &= asi64(R2);
	qq_show_currlineno = asi64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	msysc_m$print_ptr_nf(asu64(R1));
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	asu64(R2) = prefix;
	asi64(R3) = level;
	asu64(R1) = qq_show_getprefix(asi64(R3), asu64(R2), asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&qq_tables_jtagnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	idname = asu64(R1);
	asu64(R1) = idname;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 106;
	if (asu64(R1) != asu64(R2)) goto L7624;
	R1 = (u64)&idname;
	(*tou64p(R1)) += 1;
L7624:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = idname;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L7626;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L7627;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L7628;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L7629;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L7630;
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L7631;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L7632;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7633;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7634;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L7634;
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L7634;
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L7634;
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L7634;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L7634;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L7634;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7634;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L7634;
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L7634;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L7634;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L7634;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L7635;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L7635;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L7635;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L7635;
	R2 = 78;
	if (asi64(R1) == asi64(R2)) goto L7635;
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L7636;
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L7636;
	R2 = 88;
	if (asi64(R1) == asi64(R2)) goto L7637;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L7638;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L7638;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L7638;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L7639;
	goto L7640;
L7626:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7642;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L7642:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_namenames;
	asu64(R2) = d;
	R3 = 124;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Module:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 4;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 24;
	R4 = 31;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_end();
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7644;
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L7644;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L7644:
	goto L7625;
L7627:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L7625;
L7628:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asi64(R1));
	msysc_m$print_end();
	goto L7625;
L7629:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\"#\"");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7625;
L7630:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("L");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7625;
L7631:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = (u64)&qq_tables_condnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7625;
L7632:
	R1 = 1;
	i = asi64(R1);
L7645:
	asu64(R1) = p;
	R2 = 24;
	R1 += (i64)R2;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7649;
	goto L7647;
L7649:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = (u64)&qq_tables_condnames;
	asu64(R2) = p;
	R3 = 24;
	R2 += (i64)R3;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	i += 1; if (i <= 4) goto L7645;
L7647:
	goto L7625;
L7633:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = (u64)&qq_pcltabs_pclnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7625;
L7634:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L7625;
L7635:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("<#>");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_pcltabs_pclnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 1;
	R1 += (i64)R2;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7625;
L7636:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("<#>");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_tables_mathsnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 3;
	R1 += (i64)R2;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7625;
L7637:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("P.LENGTH=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7625;
L7638:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 24;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7625;
L7639:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = (u64)&qq_tables_hostfnnames;
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 2;
	R1 += (i64)R2;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7625;
L7640:
L7625:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&qq_tables_jflags;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	flags = asi64(R1);
	asi64(R1) = flags;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7651;
	R1 = tou64("1");
	asi64(R2) = level;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R3) = p;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = dev;
	qq_show_printunitlist(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
L7651:
	asi64(R1) = flags;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L7653;
	R1 = tou64("2");
	asi64(R2) = level;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R3) = p;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = dev;
	qq_show_printunitlist(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
L7653:
L7620:
	return;
}

static void qq_show_printunitlist(u64 dev, u64 p, i64 level, u64 prefix) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7656;
	goto L7654;
L7656:
	goto L7658;
L7657:
	asu64(R1) = dev;
	asu64(R2) = prefix;
	asi64(R3) = level;
	asu64(R4) = p;
	qq_show_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L7658:
	asu64(R1) = p;
	if (asu64(R1)) goto L7657;
L7654:
	return;
}

static u64 qq_show_getprefix(i64 level, u64 prefix, u64 p) {
    u64 R1, R2, R3; 
	struct $B64 indentstr;
	struct $B69 modestr;
	i64 av_1;
	R1 = 0;
	R2 = (u64)&indentstr;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = level;
	R2 = 20;
	if (asi64(R1) <= asi64(R2)) goto L7662;
	R1 = 10;
	level = asi64(R1);
L7662:
	asi64(R1) = level;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7665;
L7663:
	R1 = tou64("- ");
	R2 = (u64)&indentstr;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	if (--asi64(av_1)) goto L7663;
L7665:
	asu64(R1) = qq_show_getlineinfok();
	R2 = (u64)&qq_show_getprefix_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&indentstr;
	R2 = (u64)&qq_show_getprefix_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = prefix;
	R2 = (u64)&qq_show_getprefix_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = prefix;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L7667;
	R1 = tou64(" ");
	R2 = (u64)&qq_show_getprefix_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L7667:
	R1 = (u64)&qq_show_getprefix_str;
	goto L7660;
L7660:
	return asu64(R1);
}

static u64 qq_show_getlineinfok() {
    u64 R1, R2; 
	R1 = tou64("z4");
	asi64(R2) = qq_show_currlineno;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&qq_show_getlineinfok_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&qq_show_getlineinfok_str;
	goto L7668;
L7668:
	return asu64(R1);
}

static void qq_show_printglobalsymbols(u64 f) {
    u64 R1, R2, R3; 
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC Global Symbol Table");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	asu64(R2) = qq_decls_stprogram;
	asu64(R3) = f;
	qq_show_printst(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_show_printst(u64 f, u64 p, i64 level) {
    u64 R1, R2, R3; 
	u64 q;
	asi64(R1) = level;
	asu64(R2) = p;
	asu64(R3) = f;
	qq_show_printstrec(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L7672;
L7671:
	asi64(R1) = level;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = q;
	asu64(R3) = f;
	qq_show_printst(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L7672:
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7671;
	return;
}

static void qq_show_printstrec(u64 f, u64 p, i64 level) {
    u64 R1, R2, R3, R4, R5; struct $B67 R1_B67; 
	struct $B67 dd;
	u64 q;
	struct $B3 v;
	u64 d;
	i64 col;
	i64 offset;
	i64 n;
	struct $B16 str;
	u64 s;
	i64 av_1;
	u64 tab;
	R1 = (u64)&v;
	d = asu64(R1);
	R1 = 0;
	offset = asi64(R1);
	asi64(R1) = level;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7677;
L7675:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("    ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 4;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	R1 = 4;
	R2 = (u64)&col;
	*toi64p(R2) += asi64(R1);
	if (--asi64(av_1)) goto L7675;
L7677:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("-");
	R2 = 22;
	asi64(R3) = offset;
	asi64(R2) -= asi64(R3);
	asu64(R3) = p;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R1) = mlib_padstr(asu64(R3), asi64(R2), asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(".");
	R2 = 12;
	R3 = (u64)&qq_tables_namenames;
	asu64(R4) = p;
	R5 = 124;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8));
	asu64(R1) = mlib_padstr(asu64(R3), asi64(R2), asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 40;
	col = asi64(R1);
	asu64(R1) = p;
	(R1_B67) = *(struct $B67*)(R1);
	dd = (R1_B67);
	R1 = (u64)&dd;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 2;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L7679;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Imp ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7678;
L7679:
	R1 = (u64)&dd;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 1;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L7680;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = (u64)&dd;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 1;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	switch (asi64(R1)) {
	case 1: goto L7684;
	case 2: goto L7685;
	default: goto L7683;
    };
// SWITCH
L7684:
	R1 = tou64("Glob ");
	goto L7681;
L7685:
	R1 = tou64("Exp ");
	goto L7681;
L7683:
	R1 = tou64("Local ");
L7681:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L7680:
L7678:
	R1 = (u64)&dd;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L7687;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("byref ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L7687:
	R1 = (u64)&dd;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L7689;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("opt ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L7689:
	R1 = (u64)&dd;
	R2 = 114;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7691;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Modno:#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&dd;
	R2 = 114;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L7691:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("==========");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&dd;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7693;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("(#)");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&dd;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("-");
	R2 = 18;
	R3 = (u64)&str;
	asu64(R1) = mlib_padstr(asu64(R3), asi64(R2), asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7692;
L7693:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("-");
	R2 = 18;
	R3 = tou64("()");
	asu64(R1) = mlib_padstr(asu64(R3), asi64(R2), asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L7692:
	R1 = (u64)&dd;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7695;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7695;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7695;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L7695;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7696;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7697;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7698;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7698;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7698;
	goto L7699;
L7695:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Ix:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&dd;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&dd;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L7701;
	R1 = (u64)&dd;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7701;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("@");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&dd;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
L7701:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Offset:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&dd;
	R2 = 108;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7694;
L7696:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Offset:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&dd;
	R2 = 108;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" Ix:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&dd;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	goto L7694;
L7697:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Nfields:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&dd;
	R2 = 104;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7694;
L7698:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Nparms:# ");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&dd;
	R2 = 104;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("DD.MISFUNC=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	R2 = (u64)&dd;
	R3 = 120;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 4;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_end();
	goto L7694;
L7699:
L7694:
	R1 = (u64)&dd;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7703;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7703;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L7703;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L7703;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7703;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L7703;
	goto L7704;
L7703:
	R1 = (u64)&dd;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7706;
	R1 = (u64)&dd;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
	R3 = 12;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L7708;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L7709;
	goto L7710;
L7708:
	R1 = tou64("::=");
	s = asu64(R1);
	goto L7707;
L7709:
	R1 = tou64(":=");
	s = asu64(R1);
	goto L7707;
L7710:
	R1 = tou64("=");
	s = asu64(R1);
L7707:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = s;
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&dd;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_lib_strexpr(asu64(R1));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
L7706:
	goto L7702;
L7704:
L7702:
	R1 = (u64)&dd;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L7712;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Mode:#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = 0;
	R2 = (u64)&dd;
	R3 = 116;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = qq_show_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&dd;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L7712:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("          ");
	tab = asu64(R1);
	return;
}

static void qq_show_printtypetables(u64 f) {
    u64 R1, R2, R3; 
	u64 d;
	u64 p;
	i64 m;
	i64 i;
	msysc_m$print_startcon();
	R1 = tou64("PRINT TYPE TABLES");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = qq_tables_nuserxtypes;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC TYPE TABLES");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	m = asi64(R1);
	asi64(R1) = qq_tables_ntypes;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7716;
L7714:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("#: # ");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("3");
	asi64(R2) = m;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("jl12");
	R2 = (u64)&qq_tables_ttname;
	asi64(R3) = m;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&qq_tables_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\tST=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\tLen=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("Lower");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_ttlower;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\tSize=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\tBasetype=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&qq_tables_ttname;
	R2 = (u64)&qq_tables_ttbasetype;
	asi64(R3) = m;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\tTarget=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&qq_tables_ttname;
	R2 = (u64)&qq_tables_tttarget;
	asi64(R3) = m;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\tCaligned=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_ttcaligned;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&qq_tables_ttfields;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L7718;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\tFields:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L7720;
L7719:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t\t");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L7723;
	R1 = 0;
	asu64(R2) = d;
	R3 = 116;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = qq_show_strmode(asi64(R2), asi64(R1));
	goto L7722;
L7723:
	R1 = tou64("");
L7722:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L7720:
	asu64(R1) = d;
	if (asu64(R1)) goto L7719;
L7718:
	m += 1; if (m <= qq_tables_ntypes) goto L7714;
L7716:
	asu64(R1) = qq_tables_userxmodelist;
	p = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_tables_nuserxtypes;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7726;
L7724:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = i;
	asi64(R1) = -asi64(R1);
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&qq_tables_ttnamedefx;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= qq_tables_nuserxtypes) goto L7724;
L7726:
	return;
}

static void qq_show_showsttree() {
    u64 R1, R2, R3, R4; 
	u64 f;
	u64 m;
	u64 d;
	u64 g;
	u64 p;
	i64 i;
	asu8(R1) = qq_cli_fshowst;
	if (asu8(R1)) goto L7729;
	goto L7727;
L7729:
	R1 = tou64("w");
	R2 = tou64("ST");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	qq_show_printglobalsymbols(asu64(R1));
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Modules");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = qq_decls_nmodules;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7732;
L7730:
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	m = asu64(R1);
	asu64(R1) = m;
	if (!asu64(R1)) goto L7734;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = m;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("M.COMPILED=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = m;
	R2 = 43;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("M.PCSTART=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = m;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	R1 = tou64("M.PCSIZE=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = m;
	R2 = 72;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L7733;
L7734:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("MODULE");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("MISSING");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L7733:
	i += 1; if (i <= qq_decls_nmodules) goto L7730;
L7732:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC Global GenField Table");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = qq_decls_ngenfields;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_ngenfields;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7737;
L7735:
	R1 = (u64)&qq_decls_genfieldtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	g = asu64(R1);
	asu64(R1) = g;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7739;
	goto L7736;
L7739:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("   #) #:");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = g;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L7741;
L7740:
	asu64(R1) = g;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("      ");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_namenames;
	asu64(R2) = d;
	R3 = 124;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = g;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	g = asu64(R1);
L7741:
	asu64(R1) = g;
	if (asu64(R1)) goto L7740;
L7736:
	i += 1; if (i <= qq_decls_ngenfields) goto L7735;
L7737:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("DLL Table");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = qq_decls_nlibfiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nlibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7745;
L7743:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_decls_libtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	R2 = (u64)&qq_decls_dllinsttable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	msysc_m$print_u64(asu64(R2), asi64(R1));
	R1 = tou64("c");
	R2 = (u64)&qq_decls_libtypes;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= qq_decls_nlibfiles) goto L7743;
L7745:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("DLL Proc Table");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = qq_decls_ndllprocs;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_ndllprocs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7748;
L7746:
	R1 = (u64)&qq_decls_dllproctable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_decls_dllproclibindex;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&qq_decls_dllprocaddr;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_ptr_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 8;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L7750;
	R1 = tou64("Variadic");
	goto L7749;
L7750:
	R1 = tou64("");
L7749:
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("c");
	R2 = (u64)&qq_decls_libtypes;
	R3 = (u64)&qq_decls_dllproclibindex;
	asi64(R4) = i;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("D.INDEX=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("DLLPROCTABLE[D.INDEX]=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_decls_dllproctable;
	asu64(R2) = d;
	R3 = 96;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_ptr_nf(asu64(R1));
	R1 = tou64("D=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= qq_decls_ndllprocs) goto L7746;
L7748:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("All Proc Table");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = qq_decls_nproclist;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = qq_decls_proclist;
	p = asu64(R1);
	goto L7752;
L7751:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Proc:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L7752:
	asu64(R1) = p;
	if (asu64(R1)) goto L7751;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L7727:
	return;
}

static void qq_show_showtypes() {
    u64 R1, R2; 
	u64 f;
	u64 m;
	asu8(R1) = qq_cli_fshowtypes;
	if (asu8(R1)) goto L7756;
	goto L7754;
L7756:
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L7758;
	goto L7754;
L7758:
	R1 = tou64("w");
	R2 = tou64("TYPES");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	qq_show_printtypetables(asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L7754:
	return;
}

static void qq_show_showast(u64 sp, u64 file) {
    u64 R1, R2; 
	u64 f;
	u64 pm;
	u64 d;
	i64 k;
	i64 i;
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L7761;
	goto L7759;
L7761:
	R1 = tou64("w");
	asu64(R2) = file;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	if (asu64(R1)) goto L7763;
	goto L7759;
L7763:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = file;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = sp;
	if (!asu64(R1)) goto L7765;
	asu64(R1) = sp;
	asu64(R2) = f;
	qq_show_showast2(asu64(R2), asu64(R1));
	goto L7764;
L7765:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nsubprogs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7768;
L7766:
	R1 = (u64)&qq_decls_subprogs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = f;
	qq_show_showast2(asu64(R2), asu64(R1));
	i += 1; if (i <= qq_decls_nsubprogs) goto L7766;
L7768:
L7764:
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L7759:
	return;
}

static void qq_show_showast2(u64 f, u64 sp) {
    u64 R1, R2, R3, R4, R5; 
	u64 pm;
	u64 d;
	u64 e;
	i64 k;
	i64 i;
	i64 av_1;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Proc Subprog");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = sp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": ******\n");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = sp;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	i = asi64(R1);
	asu64(R1) = sp;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	av_1 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_1;
	if (asi64(R1) > asi64(R2)) goto L7772;
L7770:
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Module:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = pm;
	R5 = 48;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	qq_show_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = pm;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L7776;
L7773:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L7778;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\n---PROC");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = d;
	R5 = 88;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	qq_show_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L7782;
L7779:
	asu64(R1) = e;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L7784;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\n---ANONPROC");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("ANON");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = e;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = e;
	R5 = 88;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	qq_show_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
L7784:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L7782:
	asu64(R1) = e;
	if (asu64(R1)) goto L7779;
L7778:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L7776:
	asu64(R1) = d;
	if (asu64(R1)) goto L7773;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= av_1) goto L7770;
L7772:
	return;
}

static void qq_show_showlogfile() {
    u64 R1, R2, R3; 
	struct $B16 str;
	u64 logdev;
	asu8(R1) = qq_cli_fshowpcl1;
	R1 = toi64(tou8(R1));
	asu8(R2) = qq_cli_fshowpcl2;
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu8(R2) = qq_cli_fshowast1;
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu8(R2) = qq_cli_fshowast2;
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu8(R2) = qq_cli_fshowst;
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu8(R2) = qq_cli_fshowtypes;
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu8(R2) = qq_cli_fshowmodules;
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu8(R2) = qq_cli_fshowstflat;
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7787;
	goto L7785;
L7787:
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L7789;
	goto L7785;
L7789:
	msysc_m$print_startcon();
	R1 = tou64("PRESS KEY");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = mlinux_os_getch();
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L7791;
	R1 = 0;
	exit(R1);
L7791:
	asu8(R1) = qq_cli_fshowst;
	if (!asu8(R1)) goto L7793;
	qq_show_showsttree();
L7793:
	asu8(R1) = qq_cli_fshowstflat;
	if (!asu8(R1)) goto L7795;
	qq_show_showstflat();
L7795:
	asu8(R1) = qq_cli_fshowtypes;
	if (!asu8(R1)) goto L7797;
	qq_show_showtypes();
L7797:
	R1 = tou64("w");
	R2 = tou64("qq.log");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	logdev = asu64(R1);
	asu8(R1) = qq_cli_fshowmodules;
	if (!asu8(R1)) goto L7799;
	asu64(R1) = logdev;
	qq_show_showmoduleinfo(asu64(R1));
L7799:
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L7801;
	asu8(R1) = qq_cli_fshowpcl2;
	if (!asu8(R1)) goto L7801;
	asu64(R1) = logdev;
	R2 = tou64("PCL2");
	qq_show_addtolog(asu64(R2), asu64(R1));
L7801:
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L7803;
	asu8(R1) = qq_cli_fshowpcl1;
	if (!asu8(R1)) goto L7803;
	asu64(R1) = logdev;
	R2 = tou64("PCL1");
	qq_show_addtolog(asu64(R2), asu64(R1));
L7803:
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) < asi64(R2)) goto L7805;
	asu8(R1) = qq_cli_fshowast2;
	if (!asu8(R1)) goto L7805;
	asu64(R1) = logdev;
	R2 = tou64("AST2");
	qq_show_addtolog(asu64(R2), asu64(R1));
L7805:
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L7807;
	asu8(R1) = qq_cli_fshowast1;
	if (!asu8(R1)) goto L7807;
	asu64(R1) = logdev;
	R2 = tou64("AST1");
	qq_show_addtolog(asu64(R2), asu64(R1));
L7807:
	asu8(R1) = qq_cli_fshowst;
	if (!asu8(R1)) goto L7809;
	asu64(R1) = logdev;
	R2 = tou64("ST");
	qq_show_addtolog(asu64(R2), asu64(R1));
L7809:
	asu8(R1) = qq_cli_fshowstflat;
	if (!asu8(R1)) goto L7811;
	asu64(R1) = logdev;
	R2 = tou64("STFLAT");
	qq_show_addtolog(asu64(R2), asu64(R1));
L7811:
	asu8(R1) = qq_cli_fshowtypes;
	if (!asu8(R1)) goto L7813;
	asu64(R1) = logdev;
	R2 = tou64("TYPES");
	qq_show_addtolog(asu64(R2), asu64(R1));
L7813:
	asu64(R1) = logdev;
	asi32(R1) = fclose(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("c:/m/scripts/med.bat #");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("qq.log");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = 0;
	R3 = (u64)&str;
	asi64(R1) = mlinux_os_execwait(asu64(R3), asi64(R2), asu64(R1));
L7785:
	return;
}

static void qq_show_addtolog(u64 filename, u64 logdest) {
    u64 R1, R2; 
	u64 f;
	i64 c;
	R1 = tou64("rb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7816;
	goto L7814;
L7816:
L7817:
	asu64(R1) = f;
	asi32(R1) = fgetc(asu64(R1));
	R1 = toi64(toi32(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L7820;
	goto L7818;
L7820:
	asu64(R1) = logdest;
	asi64(R2) = c;
	asi32(R1) = fputc(asi32(R2), asu64(R1));
	goto L7817;
L7818:
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L7814:
	return;
}

static void qq_show_showstflat() {
    u64 R1, R2, R3, R4; 
	u64 f;
	u64 p;
	i64 sym;
	i64 av_1;
	i64 i;
	asu8(R1) = qq_cli_fshowstflat;
	if (asu8(R1)) goto L7823;
	goto L7821;
L7823:
	R1 = tou64("w");
	R2 = tou64("STFLAT");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("GLOBAL FLAT SYMBOL TABLE:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	i = asi64(R1);
	R1 = 32766;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7826;
L7824:
	R1 = (u64)&qq_lex_hashtable;
	asi64(R2) = i;
	R1 += (i64)R2*128;
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7828;
	asu64(R1) = p;
	R2 = 123;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L7830;
	goto L7831;
L7830:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = p;
	msysc_m$print_ptr_nf(asu64(R1));
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("m");
	R2 = (u64)&qq_tables_symbolnames;
	asu64(R3) = p;
	R4 = 123;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	msysc_m$print_u64(asu64(R2), asu64(R1));
	R1 = (u64)&qq_tables_namenames;
	asu64(R2) = p;
	R3 = 124;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L7833;
L7832:
	asu64(R1) = p;
	R2 = 123;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	sym = asi64(R1);
	asi64(R1) = sym;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7836;
	R1 = 1;
	sym = asi64(R1);
L7836:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	msysc_m$print_ptr_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("m");
	R2 = (u64)&qq_tables_symbolnames;
	asi64(R3) = sym;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	msysc_m$print_u64(asu64(R2), asu64(R1));
	R1 = (u64)&qq_tables_namenames;
	asu64(R2) = p;
	R3 = 124;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("(From");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7838;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L7837;
L7838:
	R1 = tou64("-");
L7837:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(")");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L7833:
	asu64(R1) = p;
	if (asu64(R1)) goto L7832;
	goto L7829;
L7831:
L7829:
L7828:
	i += 1; if (i <= av_1) goto L7824;
L7826:
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L7821:
	return;
}

static void qq_show_showmoduleinfo(u64 dev) {
    u64 R1, R2, R3; 
	u64 pm;
	u64 ps;
	i64 av_1;
	u64 d;
	u64 id;
	i64 i;
	i64 j;
// PROC LOCAL STATICS GO HERE
	static u64 qq_show_showmoduleinfo_tab = (u64)"    ";
	msysc_m$print_startcon();
	R1 = tou64("SMI0");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Project Structure:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("---------------------------------------");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Modules");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = qq_decls_nmodules;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7842;
L7840:
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = qq_show_showmoduleinfo_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("2");
	asi64(R2) = i;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("16jl");
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = tou64("Lead:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pm;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("Sys:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pm;
	R2 = 41;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("Path:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Sub:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_decls_subprogs;
	asu64(R2) = pm;
	R3 = 44;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("File:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pm;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= qq_decls_nmodules) goto L7840;
L7842:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Subprograms");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = qq_decls_nsubprogs;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nsubprogs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7845;
L7843:
	R1 = (u64)&qq_decls_subprogs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ps = asu64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = qq_show_showmoduleinfo_tab;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = ps;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Sys:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = ps;
	R2 = 30;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("Path:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = ps;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Spec:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = ps;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Comp:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = ps;
	R2 = 28;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = ps;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L7847;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = qq_show_showmoduleinfo_tab;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = qq_show_showmoduleinfo_tab;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = ps;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = ps;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = ps;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	j = asi64(R1);
	asu64(R1) = ps;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	av_1 = asi64(R1);
	asi64(R1) = j;
	asi64(R2) = av_1;
	if (asi64(R1) > asi64(R2)) goto L7850;
L7848:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	j += 1; if (j <= av_1) goto L7848;
L7850:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L7847:
	i += 1; if (i <= qq_decls_nsubprogs) goto L7843;
L7845:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = qq_decls_stprogram;
	if (asu64(R1)) goto L7852;
	goto L7839;
L7852:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Symboltable:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = qq_decls_stprogram;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L7856;
L7853:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7858;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7859;
	goto L7860;
L7858:
	R1 = tou64("Mod");
	id = asu64(R1);
	goto L7857;
L7859:
	R1 = tou64("Sub");
	id = asu64(R1);
	goto L7857;
L7860:
	R1 = tou64("---");
	id = asu64(R1);
L7857:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("    # # (m#, s#)");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = id;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 114;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = d;
	R2 = 115;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L7856:
	asu64(R1) = d;
	if (asu64(R1)) goto L7853;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L7839:
	return;
}

static void qq_show_printsymbol(u64 lp) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	struct $B3 l;
	asu64(R1) = lp;
	(R1_B3) = *(struct $B3*)(R1);
	l = (R1_B3);
	msysc_m$print_startcon();
	R1 = tou64("m 18 jl");
	R2 = (u64)&qq_tables_symbolnames;
	R3 = (u64)&l;
	R4 = 12;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	msysc_m$print_u64(asu64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&l;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L7863;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L7864;
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L7865;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L7866;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L7867;
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L7868;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7869;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L7869;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7869;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L7869;
	goto L7870;
L7863:
	R1 = (u64)&l;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 126;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&l;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L7862;
L7864:
	R1 = (u64)&l;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7872;
	goto L7873;
L7872:
	msysc_m$print_startcon();
	R1 = (u64)&l;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("int");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7871;
L7873:
	msysc_m$print_startcon();
	R1 = (u64)&l;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L7871:
	goto L7862;
L7865:
	msysc_m$print_startcon();
	R1 = 0;
	R2 = (u64)&l;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asi64(R1));
	msysc_m$print_end();
	goto L7862;
L7866:
	msysc_m$print_startcon();
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	R1 = (u64)&l;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_printstr(asu64(R1));
	msysc_m$print_startcon();
	msysc_m$print_space();
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7862;
L7867:
	msysc_m$print_startcon();
	R1 = tou64("'");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	R1 = (u64)&l;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_printstr(asu64(R1));
	msysc_m$print_startcon();
	msysc_m$print_space();
	R1 = tou64("'");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7862;
L7868:
	R1 = (u64)&l;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_printstr(asu64(R1));
	msysc_m$print_startcon();
	R1 = tou64("L");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7862;
L7869:
	msysc_m$print_startcon();
	R1 = (u64)&qq_tables_jtagnames;
	R2 = (u64)&l;
	R3 = 13;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7862;
L7870:
	R1 = (u64)&l;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7875;
	msysc_m$print_startcon();
	R1 = tou64("#");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&l;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L7875:
L7862:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static u64 qq_show_strmode(i64 t, i64 expand) {
    u64 R1, R2, R3; 
	asi64(R1) = expand;
	R2 = (u64)&qq_show_strmode_str;
	asi64(R3) = t;
	qq_show_istrmode(asi64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&qq_show_strmode_str;
	goto L7876;
L7876:
	return asu64(R1);
}

static void qq_show_istrmode(i64 t, u64 dest, i64 expand) {
    u64 R1, R2, R3, R4; 
	u64 d;
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7879;
	R1 = tou64("*");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&qq_tables_ttnamedefx;
	asi64(R2) = t;
	asi64(R2) = -asi64(R2);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L7877;
L7879:
	asi64(R1) = t;
	R2 = 40;
	if (asi64(R1) >= asi64(R2)) goto L7881;
	R1 = (u64)&qq_tables_ttname;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L7877;
L7881:
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L7883;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7884;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7885;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7886;
	goto L7887;
L7883:
	R1 = tou64("ref ");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	asu64(R3) = dest;
	asi64(R3) = strlen(asu64(R3));
	R2 += (i64)R3;
	R3 = (u64)&qq_tables_tttarget;
	asi64(R4) = t;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	qq_show_istrmode(asi64(R3), asu64(R2), asi64(R1));
	goto L7882;
L7884:
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[#..#]");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_tables_ttlower;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&qq_tables_ttlower;
	asi64(R3) = t;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = 0;
	asu64(R2) = dest;
	asu64(R3) = dest;
	asi64(R3) = strlen(asu64(R3));
	R2 += (i64)R3;
	R3 = (u64)&qq_tables_tttarget;
	asi64(R4) = t;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	qq_show_istrmode(asi64(R3), asu64(R2), asi64(R1));
	goto L7882;
L7885:
	asi64(R1) = expand;
	if (asi64(R1)) goto L7889;
	goto L7890;
L7889:
	R1 = tou64("struct(");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
// qq_show.istrmode.dostruct:
L7891:
	R1 = (u64)&qq_tables_ttfields;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	goto L7895;
L7892:
	R1 = 0;
	asu64(R2) = dest;
	asu64(R3) = dest;
	asi64(R3) = strlen(asu64(R3));
	R2 += (i64)R3;
	asu64(R3) = d;
	R4 = 116;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	qq_show_istrmode(asi64(R3), asu64(R2), asi64(R1));
	R1 = tou64(" ");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7897;
	R1 = tou64(", ");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L7897:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L7895:
	asu64(R1) = d;
	if (asu64(R1)) goto L7892;
	R1 = tou64(")");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L7882;
L7886:
	asi64(R1) = expand;
	if (asi64(R1)) goto L7899;
	goto L7890;
L7899:
	R1 = tou64("record(");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L7891;
	goto L7882;
L7887:
// qq_show.istrmode.$else:
L7890:
	R1 = (u64)&qq_tables_ttname;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L7882:
L7877:
	return;
}

static void qq_show_deletetempfiles() {
    u64 R1; 
	R1 = tou64("PCL1");
	asi32(R1) = remove(asu64(R1));
	R1 = tou64("PCL2");
	asi32(R1) = remove(asu64(R1));
	R1 = tou64("PCL3");
	asi32(R1) = remove(asu64(R1));
	R1 = tou64("AST1");
	asi32(R1) = remove(asu64(R1));
	R1 = tou64("AST2");
	asi32(R1) = remove(asu64(R1));
	R1 = tou64("TYPES");
	asi32(R1) = remove(asu64(R1));
	R1 = tou64("STFLAT");
	asi32(R1) = remove(asu64(R1));
	R1 = tou64("ST");
	asi32(R1) = remove(asu64(R1));
	return;
}

static void qq_showpcl_writepcl(u64 pcstart, u64 pc, u64 pclsource, i64 pass, u64 sourcecode) {
    u64 R1, R2, R3, R4; 
	struct $B24 str;
	i64 cmdcode;
	i64 a;
	i64 soffset;
	i64 moduleno;
	i64 offset;
	i64 attrs;
	u64 d;
	i64 av_1;
	asu64(R1) = pc;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cmdcode = asi64(R1);
	asi64(R1) = cmdcode;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7903;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7904;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7905;
	goto L7906;
L7903:
	goto L7901;
	goto L7902;
L7904:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_showpcl_currpclproc = asu64(R1);
	R1 = tou64("!      ----------");
	qq_showpcl_gstr(asu64(R1));
	R1 = tou64("Procdef:");
	qq_showpcl_gstr(asu64(R1));
	asu64(R1) = qq_showpcl_currpclproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_showpcl_gstr(asu64(R1));
	qq_showpcl_gline();
	goto L7901;
	goto L7902;
L7905:
	R1 = tou64("!      ----------");
	qq_showpcl_gstr(asu64(R1));
	asu64(R1) = pc;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L7908;
	R1 = tou64("<LABEL>");
	qq_showpcl_gstr(asu64(R1));
L7908:
	R1 = tou64("End");
	qq_showpcl_gstrln(asu64(R1));
	goto L7901;
	goto L7902;
L7906:
L7902:
	asu64(R1) = pc;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L7910;
	R1 = tou64("                 ");
	qq_showpcl_gstr(asu64(R1));
	asu64(R1) = pc;
	asu64(R2) = pcstart;
	qq_showpcl_glabeldef(asu64(R2), asu64(R1));
L7910:
	asu64(R1) = pcstart;
	asu64(R2) = pc;
	asi64(R1) = qq_lib_getpcloffset(asu64(R2), asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	offset = asi64(R1);
	asu64(R1) = pclsource;
	asi64(R2) = offset;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	soffset = asi64(R1);
	asi64(R1) = soffset;
	R2 = 16777215;
	asi64(R1) &= asi64(R2);
	qq_showpcl_currlineno = asi64(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#: [#]: ");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("4");
	asu64(R2) = pcstart;
	asu64(R3) = pc;
	asi64(R2) = qq_lib_getpcloffset(asu64(R3), asu64(R2));
	R3 = 1;
	asi64(R2) += asi64(R3);
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("05jr");
	asi64(R2) = qq_showpcl_currlineno;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	qq_showpcl_gstr(asu64(R1));
	asi64(R1) = cmdcode;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7912;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7913;
	goto L7914;
L7912:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_showpcl_currpclproc = asu64(R1);
	goto L7901;
	goto L7911;
L7913:
	R1 = tou64("! ");
	qq_showpcl_gstr(asu64(R1));
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_showpcl_gstrln(asu64(R1));
	goto L7901;
	goto L7911;
L7914:
L7911:
	R1 = 0;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = pc;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L7916;
	R1 = tou64("*");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L7916:
	R1 = (u64)&qq_pcltabs_pclnames;
	asi64(R2) = cmdcode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 1;
	R1 += (i64)R2;
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 1;
	a = asi64(R1);
	R1 = 45;
	R2 = 7;
	R3 = tou64(" ");
	asu64(R4) = qq_show_pcldest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = 32;
	R2 = 11;
	R3 = (u64)&str;
	asu64(R4) = qq_show_pcldest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&qq_pcltabs_pclopnd;
	asi64(R2) = cmdcode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7918;
	asi64(R1) = pass;
	asu64(R2) = pc;
	asu64(R3) = pcstart;
	asu64(R1) = qq_showpcl_writepclopnd(asu64(R3), asu64(R2), asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	qq_showpcl_gstr(asu64(R1));
	R1 = tou64(" ");
	qq_showpcl_gstr(asu64(R1));
L7918:
	R1 = (u64)&qq_pcltabs_pclattrs;
	asi64(R2) = cmdcode;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	attrs = asi64(R1);
	asi64(R1) = attrs;
	R2 = 538976288;
	if (asi64(R1) == asi64(R2)) goto L7920;
	R1 = tou64("<");
	qq_showpcl_gstr(asu64(R1));
	R1 = 4;
	av_1 = asi64(R1);
L7921:
	asi64(R1) = attrs;
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L7925;
	R2 = 110;
	if (asu64(R1) == asu64(R2)) goto L7926;
	R2 = 98;
	if (asu64(R1) == asu64(R2)) goto L7926;
	R2 = 120;
	if (asu64(R1) == asu64(R2)) goto L7927;
	R2 = 121;
	if (asu64(R1) == asu64(R2)) goto L7928;
	R2 = 99;
	if (asu64(R1) == asu64(R2)) goto L7929;
	R2 = 117;
	if (asu64(R1) == asu64(R2)) goto L7930;
	R2 = 118;
	if (asu64(R1) == asu64(R2)) goto L7931;
	goto L7932;
L7925:
	goto L7923;
	goto L7924;
L7926:
	asu64(R1) = pc;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	qq_showpcl_gstrint(asi64(R1));
	goto L7924;
L7927:
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	qq_showpcl_gstrint(asi64(R1));
	goto L7924;
L7928:
	asu64(R1) = pc;
	R2 = 14;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	qq_showpcl_gstrint(asi64(R1));
	goto L7924;
L7929:
	R1 = (u64)&qq_tables_condnames;
	asu64(R2) = pc;
	R3 = 9;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	qq_showpcl_gstr(asu64(R1));
	goto L7924;
L7930:
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	qq_showpcl_gstr(asu64(R1));
	goto L7924;
L7931:
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	qq_showpcl_gstr(asu64(R1));
	goto L7924;
L7932:
L7924:
	R1 = 8;
	R2 = (u64)&attrs;
	*toi64p(R2) >>= asi64(R1);
	asi64(R1) = attrs;
	R2 = 255;
	asi64(R1) &= asi64(R2);
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L7934;
	R1 = tou64(" ");
	qq_showpcl_gstr(asu64(R1));
L7934:
	if (--asi64(av_1)) goto L7921;
L7923:
	R1 = tou64(">");
	qq_showpcl_gstr(asu64(R1));
L7920:
	qq_showpcl_gline();
L7901:
	return;
}

static u64 qq_showpcl_writepclopnd(u64 pcstart, u64 pc, i64 pass) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 suffix;
	u64 s;
	i64 slen;
	u64 p;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = (u64)&qq_pcltabs_pclopnd;
	asu64(R2) = pc;
	R3 = 8;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7937;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7938;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7939;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7940;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7941;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7942;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7943;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7944;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7945;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7946;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7947;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7948;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7949;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7950;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L7951;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7952;
	goto L7953;
L7937:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L7936;
L7938:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = 0;
	asu64(R2) = pc;
	R3 = 16;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asi64(R1));
	msysc_m$print_end();
	goto L7936;
L7939:
	asi64(R1) = pass;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7955;
	goto L7956;
L7955:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	slen = asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7958;
	R1 = tou64("\"");
	goto L7935;
L7958:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	goto L7959;
	goto L7936;
L7940:
// qq_showpcl.writepclopnd.docstringz:
L7956:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	slen = asi64(R1);
// qq_showpcl.writepclopnd.dostring:
L7959:
	asi64(R1) = slen;
	R2 = 255;
	if (asi64(R1) < asi64(R2)) goto L7961;
	R1 = 255;
	slen = asi64(R1);
L7961:
	asi64(R1) = slen;
	asu64(R2) = s;
	R3 = (u64)&qq_showpcl_writepclopnd_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&qq_showpcl_writepclopnd_str;
	asi64(R3) = slen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&qq_showpcl_writepclopnd_str2;
	R2 = (u64)&qq_showpcl_writepclopnd_str;
	qq_lib_convertstring(asu64(R2), asu64(R1));
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("\"#\"");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_showpcl_writepclopnd_str2;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7936;
L7941:
	asi64(R1) = pass;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7963;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_showpcl_writepclopnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L7962;
L7963:
	asu64(R1) = qq_cli_allstaticdefs;
	d = asu64(R1);
	goto L7967;
L7964:
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L7969;
	goto L7966;
L7969:
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L7967:
	asu64(R1) = d;
	if (asu64(R1)) goto L7964;
L7966:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[#] (#:#)");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("h");
	asu64(R2) = d;
	R3 = 80;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_ptr(asu64(R2), asu64(R1));
	asu64(R1) = d;
	if (!asu64(R1)) goto L7971;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L7970;
L7971:
	R1 = tou64("?");
L7970:
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	if (!asu64(R1)) goto L7973;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L7972;
L7973:
	R1 = tou64("?");
L7972:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L7962:
	goto L7936;
L7942:
	asi64(R1) = pass;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7975;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_showpcl_writepclopnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L7974;
L7975:
	asu64(R1) = qq_showpcl_currpclproc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L7977;
L7976:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7981;
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L7980;
L7981:
	asu64(R1) = d;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L7980;
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[#] (#)");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	goto L7935;
L7980:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L7977:
	asu64(R1) = d;
	if (asu64(R1)) goto L7976;
L7974:
	goto L7936;
L7943:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#.$");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7936;
L7944:
	asi64(R1) = pass;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7983;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_showpcl_writepclopnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L7982;
L7983:
	asu64(R1) = qq_cli_allprocdefs;
	d = asu64(R1);
	goto L7987;
L7984:
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L7989;
	goto L7986;
L7989:
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L7987:
	asu64(R1) = d;
	if (asu64(R1)) goto L7984;
L7986:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[#] (#:#)");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	asu64(R1) = d;
	if (!asu64(R1)) goto L7991;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L7990;
L7991:
	R1 = tou64("?");
L7990:
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	if (!asu64(R1)) goto L7993;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L7992;
L7993:
	R1 = tou64("?");
L7992:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L7982:
	goto L7936;
L7945:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[DLL:#]");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7936;
L7946:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&qq_tables_hostfnnames;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 2;
	R1 += (i64)R2;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7936;
L7947:
	asi64(R1) = pass;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7995;
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64(".#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7994;
L7995:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("## (#)");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("#");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&qq_decls_genfieldtable;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L7994:
	goto L7936;
L7948:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("T:# (#)");
	msysc_m$print_setfmt(asu64(R1));
	R1 = 0;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_show_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L7936;
L7949:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("L#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = pcstart;
	asu64(R2) = pc;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_lib_getpcloffset(asu64(R2), asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L7936;
L7950:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("(#)");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_pcltabs_pclnames;
	asu64(R2) = pc;
	R3 = 16;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7936;
L7951:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("(# #)");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = pc;
	R2 = 16;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&qq_pcltabs_pclnames;
	R2 = (u64)&qq_pcltabs_bintotable;
	asu64(R3) = pc;
	R4 = 16;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	R2 += (i64)R3*24-24;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7936;
L7952:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("<#>");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_tables_mathsnames;
	asu64(R2) = pc;
	R3 = 16;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 3;
	R1 += (i64)R2;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7936;
L7953:
// qq_showpcl.writepclopnd.other:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("<#>");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_pcltabs_opndnames;
	R2 = (u64)&qq_pcltabs_pclopnd;
	asu64(R3) = pc;
	R4 = 8;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L7936:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	goto L7935;
L7935:
	return asu64(R1);
}

static void qq_showpcl_writeallpcl(u64 pm, i64 pass) {
    u64 R1, R2, R3, R4, R5; 
	i64 cmd;
	u64 pc;
	u64 pclcode;
	u64 pclsource;
	u64 sourcecode;
	R1 = 0;
	qq_showpcl_currlineno = asi64(R1);
	R1 = tou64("PCL FOR MODULE:");
	qq_showpcl_gstr(asu64(R1));
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_showpcl_gstrln(asu64(R1));
	asu64(R1) = pm;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	pclcode = asu64(R2);
	pc = asu64(R1);
	asu64(R1) = pm;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pclsource = asu64(R1);
	asu64(R1) = pm;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	sourcecode = asu64(R1);
L7998:
	asu64(R1) = pc;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cmd = asi64(R1);
	asu64(R1) = sourcecode;
	asi64(R2) = pass;
	asu64(R3) = pclsource;
	asu64(R4) = pc;
	asu64(R5) = pclcode;
	qq_showpcl_writepcl(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asi64(R1) = cmd;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L7998;
	qq_showpcl_gline();
	return;
}

static void qq_showpcl_showpcl(u64 sp, i64 pass) {
    u64 R1, R2, R3; 
	u64 f;
	i64 i;
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8003;
	goto L8001;
L8003:
	asu64(R1) = qq_show_pcldest;
	mlib_gs_init(asu64(R1));
	R1 = tou64("PROC ALL PCL pass:");
	asu64(R2) = qq_show_pcldest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asi64(R1) = pass;
	asu64(R2) = qq_show_pcldest;
	mlib_gs_strint(asu64(R2), asi64(R1));
	asu64(R1) = qq_show_pcldest;
	mlib_gs_line(asu64(R1));
	asu64(R1) = sp;
	if (!asu64(R1)) goto L8005;
	asi64(R1) = pass;
	asu64(R2) = sp;
	qq_showpcl_showpcl2(asu64(R2), asi64(R1));
	goto L8004;
L8005:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nsubprogs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8008;
L8006:
	asi64(R1) = pass;
	R2 = (u64)&qq_decls_subprogs;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_showpcl_showpcl2(asu64(R2), asi64(R1));
	i += 1; if (i <= qq_decls_nsubprogs) goto L8006;
L8008:
L8004:
	R1 = tou64("w");
	asi64(R2) = pass;
	switch (asi64(R2)) {
	case 1: goto L8012;
	case 2: goto L8013;
	default: goto L8011;
    };
// SWITCH
L8012:
	R2 = tou64("PCL1");
	goto L8009;
L8013:
	R2 = tou64("PCL2");
	goto L8009;
L8011:
	R2 = tou64("PCL3");
L8009:
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	if (asu64(R1)) goto L8015;
	goto L8001;
L8015:
	asu64(R1) = f;
	asu64(R2) = qq_show_pcldest;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L8001:
	return;
}

static void qq_showpcl_showpcl2(u64 sp, i64 pass) {
    u64 R1, R2, R3; 
	i64 av_1;
	i64 i;
	asu64(R1) = sp;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	i = asi64(R1);
	asu64(R1) = sp;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	av_1 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_1;
	if (asi64(R1) > asi64(R2)) goto L8019;
L8017:
	asi64(R1) = pass;
	R2 = (u64)&qq_decls_modules;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	qq_showpcl_writeallpcl(asu64(R2), asi64(R1));
	i += 1; if (i <= av_1) goto L8017;
L8019:
	return;
}

static void qq_showpcl_gstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = qq_show_pcldest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void qq_showpcl_gstrln(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = qq_show_pcldest;
	mlib_gs_strln(asu64(R2), asu64(R1));
	return;
}

static void qq_showpcl_gline() {
    u64 R1; 
	asu64(R1) = qq_show_pcldest;
	mlib_gs_line(asu64(R1));
	return;
}

static void qq_showpcl_gstrint(i64 a) {
    u64 R1, R2; 
	asi64(R1) = a;
	asu64(R2) = qq_show_pcldest;
	mlib_gs_strint(asu64(R2), asi64(R1));
	return;
}

static void qq_showpcl_glabeldef(u64 pcstart, u64 pc) {
    u64 R1, R2; 
	R1 = tou64("L");
	qq_showpcl_gstr(asu64(R1));
	asu64(R1) = pcstart;
	asu64(R2) = pc;
	asi64(R1) = qq_lib_getpcloffset(asu64(R2), asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	qq_showpcl_gstrint(asi64(R1));
	R1 = tou64(": ");
	qq_showpcl_gstrln(asu64(R1));
	return;
}

static void qq_vars_var_unshareu(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu32(R1) = *(tou32p(R1)) -= 1;
	R1 = toi64(tou32(R1));
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L8027;
	asu64(R1) = p;
	qq_vars_var_free(asu64(R1));
L8027:
	return;
}

static void qq_vars_obj_shareu(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	(*tou32p(R1)) += 1;
	return;
}

static u64 qq_vars_void_new() {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 16;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8029;
L8029:
	return asu64(R1);
}

static u64 qq_vars_obj_new() {
    u64 R1, R2, R3; struct $B31 R1_B31; 
	u64 p;
	R1 = 32;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	(R1_B31) = qq_vars_zeroobj;
	asu64(R2) = p;
	*(struct $B31*)(R2) = (R1_B31);
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8030;
L8030:
	return asu64(R1);
}

static i64 qq_vars_var_getintvalue(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8033;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L8033;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8034;
	goto L8035;
L8033:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L8031;
	goto L8032;
L8034:
	asu64(R1) = p;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = toi64(asr64(R1));
	goto L8031;
	goto L8032;
L8035:
	asu64(R1) = p;
	R2 = tou64("getintvalue");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8032:
	R1 = 0;
	goto L8031;
L8031:
	return asi64(R1);
}

static void qq_vars_var_fromobj(i64 tag, u64 p, u64 dest) {
    u64 R1, R2, R3; 
	asi64(R1) = tag;
	R2 = 256;
	asi64(R1) |= asi64(R2);
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_vars_var_free(u64 a) {
    u64 R1, R2, R3; 
	struct $B3 v;
	u64 q;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L8039;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8040;
	goto L8041;
L8039:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8043;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8044;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8045;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8046;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8047;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8048;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L8049;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8050;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8051;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8052;
	goto L8053;
L8043:
	asu64(R1) = q;
	qq_lists_obj_free_list(asu64(R1));
	goto L8042;
L8044:
	asu64(R1) = q;
	qq_records_obj_free_record(asu64(R1));
	goto L8042;
L8045:
	asu64(R1) = q;
	qq_strings_obj_free_string(asu64(R1));
	goto L8042;
L8046:
	asu64(R1) = q;
	qq_arrays_obj_free_array(asu64(R1));
	goto L8042;
L8047:
	asu64(R1) = q;
	qq_arrays_obj_free_vector(asu64(R1));
	goto L8042;
L8048:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = q;
	qq_bits_obj_free_bits(asu64(R2), asi64(R1));
	goto L8042;
L8049:
	asu64(R1) = q;
	qq_packed_obj_free_struct(asu64(R1));
	goto L8042;
L8050:
	R1 = 0;
	asu64(R2) = q;
	qq_dicts_obj_free_dict(asu64(R2), asi64(R1));
	goto L8042;
L8051:
	asu64(R1) = q;
	qq_sets_obj_free_set(asu64(R1));
	goto L8042;
L8052:
	asu64(R1) = q;
	qq_decimal_obj_free_dec(asu64(R1));
	goto L8042;
L8053:
	asu64(R1) = a;
	R2 = tou64("free");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8042:
	goto L8038;
L8040:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&v;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&v;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&v;
	qq_vars_var_unshareu(asu64(R1));
	asu64(R1) = q;
	mlib_pcm_free32(asu64(R1));
	goto L8038;
L8041:
	asu64(R1) = q;
	mlib_pcm_free32(asu64(R1));
L8038:
	return;
}

static void qq_vars_var_duplu(u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8056;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8057;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8058;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8059;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8060;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8061;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8062;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8063;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L8064;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8065;
	goto L8066;
L8056:
	asu64(R1) = a;
	qq_strings_var_dupl_string(asu64(R1));
	goto L8055;
L8057:
	asu64(R1) = a;
	qq_sets_var_dupl_set(asu64(R1));
	goto L8055;
L8058:
	asu64(R1) = a;
	qq_lists_var_dupl_list(asu64(R1));
	goto L8055;
L8059:
	asu64(R1) = a;
	qq_dicts_var_dupl_dict(asu64(R1));
	goto L8055;
L8060:
	asu64(R1) = a;
	qq_arrays_var_dupl_array(asu64(R1));
	goto L8055;
L8061:
	asu64(R1) = a;
	qq_arrays_var_dupl_vector(asu64(R1));
	goto L8055;
L8062:
	asu64(R1) = a;
	qq_bits_var_dupl_bits(asu64(R1));
	goto L8055;
L8063:
	asu64(R1) = a;
	qq_records_var_dupl_record(asu64(R1));
	goto L8055;
L8064:
	asu64(R1) = a;
	qq_packed_var_dupl_struct(asu64(R1));
	goto L8055;
L8065:
	asu64(R1) = a;
	qq_decimal_var_dupl_dec(asu64(R1));
	goto L8055;
L8066:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("dupl");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8055:
	return;
}

static void qq_vars_var_neg(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8069;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8070;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8071;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8072;
	goto L8073;
L8069:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = -asi64(R1);
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8068;
L8070:
	asu64(R1) = a;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R1) = -asr64(R1);
	asu64(R2) = a;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L8068;
L8071:
	asu64(R1) = a;
	qq_decimal_var_dupl_dec(asu64(R1));
	asu64(R1) = a;
	qq_decimal_var_neg_dec(asu64(R1));
	goto L8068;
L8072:
	asu64(R1) = a;
	qq_sets_var_dupl_set(asu64(R1));
	asu64(R1) = a;
	qq_sets_var_inotto_set(asu64(R1));
	goto L8068;
L8073:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("neg");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8068:
	return;
}

static void qq_vars_var_abs(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8076;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8077;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8078;
	goto L8079;
L8076:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8075;
L8077:
	asu64(R1) = a;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	if (asr64(R1) < 0) asr64(R1) = -asr64(R1);
	asu64(R2) = a;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L8075;
L8078:
	asu64(R1) = a;
	qq_decimal_var_dupl_dec(asu64(R1));
	asu64(R1) = a;
	qq_decimal_var_abs_dec(asu64(R1));
	goto L8075;
L8079:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("abs");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8075:
	return;
}

static void qq_vars_var_inot(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8082;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8083;
	goto L8084;
L8082:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = ~asi64(R1);
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8081;
L8083:
	asu64(R1) = a;
	qq_sets_var_dupl_set(asu64(R1));
	asu64(R1) = a;
	qq_sets_var_inotto_set(asu64(R1));
	goto L8081;
L8084:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("inot");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8081:
	return;
}

static i64 qq_vars_var_istruel(u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8087;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L8087;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L8087;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L8087;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L8087;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L8087;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8088;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8089;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8089;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8089;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8089;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8089;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8090;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8091;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L8091;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8092;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L8093;
	goto L8094;
L8087:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = !!asi64(R1);
	goto L8085;
	goto L8086;
L8088:
	asu64(R1) = a;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R2) = 0.000000000000000000e+000;
	if (asr64(R1) == asr64(R2)) goto L8096;
	R1 = 1;
	goto L8095;
L8096:
	R1 = 0;
L8095:
	goto L8085;
	goto L8086;
L8089:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	goto L8085;
	goto L8086;
L8090:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	goto L8085;
	goto L8086;
L8091:
	R1 = 1;
	goto L8085;
	goto L8086;
L8092:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = qq_decimal_bn_iszero(asu64(R1));
	asi64(R1) = !asi64(R1);
	goto L8085;
	goto L8086;
L8093:
	R1 = 0;
	goto L8085;
	goto L8086;
L8094:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("istruel");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8086:
	R1 = 0;
	goto L8085;
L8085:
	return asi64(R1);
}

static void qq_vars_var_add(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8099;
	asu64(R1) = b;
	asu64(R2) = a;
	qq_vars_var_addmixed(asu64(R2), asu64(R1));
	goto L8097;
L8099:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8101;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8102;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8103;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8104;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8105;
	goto L8106;
L8101:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
	goto L8100;
L8102:
	asu64(R1) = b;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) += asr64(R1);
	goto L8100;
L8103:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_decimal_var_add_dec(asu64(R2), asu64(R1));
	goto L8100;
L8104:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_strings_var_add_string(asu64(R2), asu64(R1));
	goto L8100;
L8105:
	asu64(R1) = a;
	qq_sets_var_dupl_set(asu64(R1));
	asu64(R1) = b;
	asu64(R2) = a;
	qq_sets_var_iorto_set(asu64(R2), asu64(R1));
	goto L8100;
L8106:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("add");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8100:
L8097:
	return;
}

static void qq_vars_var_addmixed(u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 newtag;
	i64 tt;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	newtag = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	R2 = 65538;
	if (asi64(R1) == asi64(R2)) goto L8109;
	R2 = 131073;
	if (asi64(R1) == asi64(R2)) goto L8110;
	R2 = 65539;
	if (asi64(R1) == asi64(R2)) goto L8111;
	R2 = 131075;
	if (asi64(R1) == asi64(R2)) goto L8111;
	R2 = 196609;
	if (asi64(R1) == asi64(R2)) goto L8112;
	R2 = 196610;
	if (asi64(R1) == asi64(R2)) goto L8112;
	R2 = 1048577;
	if (asi64(R1) == asi64(R2)) goto L8113;
	goto L8114;
L8109:
	R1 = 2;
	newtag = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = b;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asr64(R1) += asr64(R2);
	asu64(R2) = a;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L8108;
L8110:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) += asr64(R1);
	goto L8108;
L8111:
	R1 = 3;
	newtag = asi64(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R2) = qq_decimal_dectemp(asu64(R2));
	qq_decimal_var_add_dec(asu64(R2), asu64(R1));
	qq_decimal_freedectemp();
	goto L8108;
L8112:
	asu64(R1) = b;
	asu64(R1) = qq_decimal_dectemp(asu64(R1));
	asu64(R2) = a;
	qq_decimal_var_add_dec(asu64(R2), asu64(R1));
	goto L8108;
L8113:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8116;
	R1 = tou64("");
	R2 = tou64("Nil+x");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8116:
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = a;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) *= asi64(R2);
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*tou64p(R2) += asu64(R1);
	goto L8108;
L8114:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = tou64("Addmixed");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L8108:
	asi64(R1) = newtag;
	asu64(R2) = a;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static i64 qq_vars_var_addto(u64 p, u64 b) {
    u64 R1, R2, R3; 
	u64 a;
	i64 newtag;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L8119;
	R1 = 0;
	goto L8117;
L8119:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	newtag = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8121;
	asi64(R1) = newtag;
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L8123;
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8123;
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	qq_strings_var_addto_string_ch(asu64(R2), asi64(R1));
	R1 = 1;
	goto L8117;
L8123:
	R1 = 0;
	goto L8117;
L8121:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8125;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8126;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8127;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8128;
	goto L8129;
L8125:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
	goto L8124;
L8126:
	asu64(R1) = b;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) += asr64(R1);
	goto L8124;
L8127:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_strings_var_addto_string(asu64(R2), asu64(R1));
	goto L8124;
L8128:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_sets_var_iorto_set(asu64(R2), asu64(R1));
	goto L8124;
L8129:
	R1 = 0;
	goto L8117;
L8124:
	asi64(R1) = newtag;
	asu64(R2) = a;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	goto L8117;
L8117:
	return asi64(R1);
}

static void qq_vars_var_sub(u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	i64 elemsize;
	i64 x;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8132;
	asu64(R1) = b;
	asu64(R2) = a;
	qq_vars_var_submixed(asu64(R2), asu64(R1));
	goto L8130;
L8132:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8134;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8135;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8136;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L8137;
	goto L8138;
L8134:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) -= asi64(R1);
	goto L8133;
L8135:
	asu64(R1) = b;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) -= asr64(R1);
	goto L8133;
L8136:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_decimal_var_sub_dec(asu64(R2), asu64(R1));
	goto L8133;
L8137:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = a;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	elemsize = asi64(R2);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8140;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8141;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8142;
	goto L8143;
L8140:
	asu64(R1) = p;
	asu64(R2) = q;
	asi64(R1) -= asi64(R2);
	x = asi64(R1);
	goto L8139;
L8141:
	asu64(R1) = p;
	asu64(R2) = q;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) >>= asi64(R2);
	x = asi64(R1);
	goto L8139;
L8142:
	asu64(R1) = p;
	asu64(R2) = q;
	asi64(R1) -= asi64(R2);
	R2 = 2;
	asi64(R1) >>= asi64(R2);
	x = asi64(R1);
	goto L8139;
L8143:
	asu64(R1) = p;
	asu64(R2) = q;
	asi64(R1) -= asi64(R2);
	asi64(R2) = elemsize;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	x = asi64(R1);
L8139:
	R1 = 1;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8133;
L8138:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("sub");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8133:
L8130:
	return;
}

static void qq_vars_var_submixed(u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 newtag;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	newtag = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	R2 = 65538;
	if (asi64(R1) == asi64(R2)) goto L8146;
	R2 = 131073;
	if (asi64(R1) == asi64(R2)) goto L8147;
	R2 = 65539;
	if (asi64(R1) == asi64(R2)) goto L8148;
	R2 = 131075;
	if (asi64(R1) == asi64(R2)) goto L8148;
	R2 = 196609;
	if (asi64(R1) == asi64(R2)) goto L8149;
	R2 = 196610;
	if (asi64(R1) == asi64(R2)) goto L8149;
	R2 = 1048577;
	if (asi64(R1) == asi64(R2)) goto L8150;
	goto L8151;
L8146:
	R1 = 2;
	newtag = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = b;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asr64(R1) -= asr64(R2);
	asu64(R2) = a;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L8145;
L8147:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) -= asr64(R1);
	goto L8145;
L8148:
	R1 = 3;
	newtag = asi64(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R2) = qq_decimal_dectemp(asu64(R2));
	qq_decimal_var_sub_dec(asu64(R2), asu64(R1));
	qq_decimal_freedectemp();
	goto L8145;
L8149:
	asu64(R1) = b;
	asu64(R1) = qq_decimal_dectemp(asu64(R1));
	asu64(R2) = a;
	qq_decimal_var_sub_dec(asu64(R2), asu64(R1));
	goto L8145;
L8150:
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = a;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) *= asi64(R2);
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*tou64p(R2) -= asu64(R1);
	goto L8145;
L8151:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = tou64("Submixed");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L8145:
	asi64(R1) = newtag;
	asu64(R2) = a;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void qq_vars_var_mul(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8154;
	asu64(R1) = b;
	asu64(R2) = a;
	qq_vars_var_mulmixed(asu64(R2), asu64(R1));
	goto L8152;
L8154:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8156;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8157;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8158;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8159;
	goto L8160;
L8156:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) *= asi64(R1);
	goto L8155;
L8157:
	asu64(R1) = b;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) *= asr64(R1);
	goto L8155;
L8158:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_decimal_var_mul_dec(asu64(R2), asu64(R1));
	goto L8155;
L8159:
	asu64(R1) = a;
	qq_sets_var_dupl_set(asu64(R1));
	asu64(R1) = b;
	asu64(R2) = a;
	qq_sets_var_iandto_set(asu64(R2), asu64(R1));
	goto L8155;
L8160:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("mul");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8155:
L8152:
	return;
}

static void qq_vars_var_mulmixed(u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 newtag;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	newtag = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	R2 = 65538;
	if (asi64(R1) == asi64(R2)) goto L8163;
	R2 = 131073;
	if (asi64(R1) == asi64(R2)) goto L8164;
	R2 = 65539;
	if (asi64(R1) == asi64(R2)) goto L8165;
	R2 = 131075;
	if (asi64(R1) == asi64(R2)) goto L8165;
	R2 = 196609;
	if (asi64(R1) == asi64(R2)) goto L8166;
	R2 = 196610;
	if (asi64(R1) == asi64(R2)) goto L8166;
	R2 = 589825;
	if (asi64(R1) == asi64(R2)) goto L8167;
	R2 = 655361;
	if (asi64(R1) == asi64(R2)) goto L8168;
	goto L8169;
L8163:
	R1 = 2;
	newtag = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = b;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asr64(R1) *= asr64(R2);
	asu64(R2) = a;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L8162;
L8164:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) *= asr64(R1);
	goto L8162;
L8165:
	R1 = 3;
	newtag = asi64(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R2) = qq_decimal_dectemp(asu64(R2));
	qq_decimal_var_mul_dec(asu64(R2), asu64(R1));
	qq_decimal_freedectemp();
	goto L8162;
L8166:
	asu64(R1) = b;
	asu64(R1) = qq_decimal_dectemp(asu64(R1));
	asu64(R2) = a;
	qq_decimal_var_mul_dec(asu64(R2), asu64(R1));
	goto L8162;
L8167:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	qq_strings_var_mul_string(asu64(R2), asi64(R1));
	goto L8162;
L8168:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	qq_lists_var_mul_list(asu64(R2), asi64(R1));
	goto L8162;
L8169:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = tou64("Mulmixed");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L8162:
	asi64(R1) = newtag;
	asu64(R2) = a;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void qq_vars_var_div(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8172;
	asu64(R1) = b;
	asu64(R2) = a;
	qq_vars_var_divmixed(asu64(R2), asu64(R1));
	goto L8170;
L8172:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8174;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8175;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8176;
	goto L8177;
L8174:
	R1 = 2;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asr64(R2) = tor64(asi64(R2));
	asr64(R1) /= asr64(R2);
	asu64(R2) = a;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L8173;
L8175:
	asu64(R1) = b;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) /= asr64(R1);
	goto L8173;
L8176:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_decimal_var_div_dec(asu64(R2), asu64(R1));
	goto L8173;
L8177:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("div");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8173:
L8170:
	return;
}

static void qq_vars_var_divmixed(u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 newtag;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	newtag = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	R2 = 65538;
	if (asi64(R1) == asi64(R2)) goto L8180;
	R2 = 131073;
	if (asi64(R1) == asi64(R2)) goto L8181;
	goto L8182;
L8180:
	R1 = 2;
	newtag = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = b;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asr64(R1) /= asr64(R2);
	asu64(R2) = a;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L8179;
L8181:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) /= asr64(R1);
	goto L8179;
L8182:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = tou64("Divmixed");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L8179:
	asi64(R1) = newtag;
	asu64(R2) = a;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void qq_vars_var_idiv(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8185;
	R1 = tou64("");
	R2 = tou64("idivmixed");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L8183;
L8185:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8187;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8188;
	goto L8189;
L8187:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L8191;
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8190;
L8191:
	R1 = tou64("");
	R2 = tou64("Divide by 0");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8190:
	goto L8186;
L8188:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_decimal_var_idiv_dec(asu64(R2), asu64(R1));
	goto L8186;
L8189:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("idiv");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8186:
L8183:
	return;
}

static void qq_vars_var_irem(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8194;
	R1 = tou64("");
	R2 = tou64("iremmixed");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L8192;
L8194:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8196;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8197;
	goto L8198;
L8196:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) %= asi64(R2);
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8195;
L8197:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_decimal_var_irem_dec(asu64(R2), asu64(R1));
	goto L8195;
L8198:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("irem");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8195:
L8192:
	return;
}

static void qq_vars_var_iand(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8201;
	R1 = tou64("");
	R2 = tou64("iand mixed");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L8199;
L8201:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8203;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8204;
	goto L8205;
L8203:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) &= asi64(R1);
	goto L8202;
L8204:
	asu64(R1) = a;
	qq_sets_var_dupl_set(asu64(R1));
	asu64(R1) = b;
	asu64(R2) = a;
	qq_sets_var_iandto_set(asu64(R2), asu64(R1));
	goto L8202;
L8205:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("iand");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8202:
L8199:
	return;
}

static void qq_vars_var_ior(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8208;
	R1 = tou64("");
	R2 = tou64("ior mixed");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L8206;
L8208:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8210;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8211;
	goto L8212;
L8210:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) |= asi64(R1);
	goto L8209;
L8211:
	asu64(R1) = a;
	qq_sets_var_dupl_set(asu64(R1));
	asu64(R1) = b;
	asu64(R2) = a;
	qq_sets_var_iorto_set(asu64(R2), asu64(R1));
	goto L8209;
L8212:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("ior");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8209:
L8206:
	return;
}

static void qq_vars_var_ixor(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8215;
	R1 = tou64("");
	R2 = tou64("ixor mixed");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L8213;
L8215:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8217;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8218;
	goto L8219;
L8217:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) ^= asi64(R1);
	goto L8216;
L8218:
	asu64(R1) = a;
	qq_sets_var_dupl_set(asu64(R1));
	asu64(R1) = b;
	asu64(R2) = a;
	qq_sets_var_ixorto_set(asu64(R2), asu64(R1));
	goto L8216;
L8219:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("ixor");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8216:
L8213:
	return;
}

static void qq_vars_var_shl(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8222;
	R1 = tou64("");
	R2 = tou64("ishl mixed");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L8220;
L8222:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8224;
	goto L8225;
L8224:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) <<= asi64(R1);
	goto L8223;
L8225:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("shl");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8223:
L8220:
	return;
}

static void qq_vars_var_shr(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8228;
	R1 = tou64("");
	R2 = tou64("ishr mixed");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L8226;
L8228:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8230;
	goto L8231;
L8230:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) >>= asi64(R1);
	goto L8229;
L8231:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("shr");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8229:
L8226:
	return;
}

static i64 qq_vars_var_in(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	i64 n;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	R2 = 65541;
	if (asi64(R1) == asi64(R2)) goto L8234;
	R2 = 1179653;
	if (asi64(R1) == asi64(R2)) goto L8234;
	R2 = 65540;
	if (asi64(R1) == asi64(R2)) goto L8235;
	goto L8236;
L8234:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_sets_var_in_set(asu64(R2), asu64(R1));
	goto L8232;
	goto L8233;
L8235:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 16;
	R4 = 63;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asi64(R1) < asi64(R2)) goto L8238;
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L8238;
	R1 = 1;
	goto L8237;
L8238:
	R1 = 0;
L8237:
	goto L8232;
	goto L8233;
L8236:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8240;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8240;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8240;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8240;
	goto L8241;
L8240:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_vars_var_inx(asu64(R2), asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0x8000000000000000;
	if (asi64(R1) == asi64(R2)) goto L8243;
	R1 = 1;
	goto L8242;
L8243:
	R1 = 0;
L8242:
	goto L8232;
	goto L8239;
L8241:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = tou64("in");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L8239:
L8233:
	R1 = 0;
	goto L8232;
L8232:
	return asi64(R1);
}

static i64 qq_vars_var_inx(u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 n;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	R2 = 589833;
	if (asi64(R1) == asi64(R2)) goto L8246;
	R2 = 65547;
	if (asi64(R1) == asi64(R2)) goto L8247;
	R2 = 131083;
	if (asi64(R1) == asi64(R2)) goto L8247;
	R2 = 65543;
	if (asi64(R1) == asi64(R2)) goto L8248;
	R2 = 131079;
	if (asi64(R1) == asi64(R2)) goto L8248;
	goto L8249;
L8246:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_strings_var_inx_string(asu64(R2), asu64(R1));
	goto L8244;
	goto L8245;
L8247:
	R1 = 0;
	asu64(R2) = b;
	asu64(R3) = a;
	asi64(R1) = qq_arrays_var_inx_array(asu64(R3), asu64(R2), asi64(R1));
	goto L8244;
	goto L8245;
L8248:
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = b;
	asu64(R3) = a;
	asi64(R1) = qq_arrays_var_inx_array(asu64(R3), asu64(R2), asi64(R1));
	goto L8244;
	goto L8245;
L8249:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8251;
	goto L8252;
L8251:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_lists_var_inx_list(asu64(R2), asu64(R1));
	goto L8244;
	goto L8250;
L8252:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = tou64("inx");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L8250:
L8245:
	R1 = 0;
	goto L8244;
L8244:
	return asi64(R1);
}

static i64 qq_vars_var_equal(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8255;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_vars_var_equalmixed(asu64(R2), asu64(R1));
	goto L8253;
L8255:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8257;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L8257;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L8257;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L8257;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L8257;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L8257;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8258;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8259;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8260;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8261;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8262;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8263;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8264;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8264;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8265;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8266;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L8267;
	goto L8268;
L8257:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L8253;
	goto L8256;
L8258:
	asu64(R1) = a;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	if (asr64(R1) != asr64(R2)) goto L8270;
	R1 = 1;
	goto L8269;
L8270:
	R1 = 0;
L8269:
	goto L8253;
	goto L8256;
L8259:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_decimal_var_equal_dec(asu64(R2), asu64(R1));
	goto L8253;
	goto L8256;
L8260:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_strings_var_equal_string(asu64(R2), asu64(R1));
	goto L8253;
	goto L8256;
L8261:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_sets_var_equal_set(asu64(R2), asu64(R1));
	goto L8253;
	goto L8256;
L8262:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_lists_var_equal_list(asu64(R2), asu64(R1));
	goto L8253;
	goto L8256;
L8263:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_dicts_var_equal_dict(asu64(R2), asu64(R1));
	goto L8253;
	goto L8256;
L8264:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_arrays_var_equal_array(asu64(R2), asu64(R1));
	goto L8253;
	goto L8256;
L8265:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_bits_var_equal_bits(asu64(R2), asu64(R1));
	goto L8253;
	goto L8256;
L8266:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_records_var_equal_record(asu64(R2), asu64(R1));
	goto L8253;
	goto L8256;
L8267:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_packed_var_equal_struct(asu64(R2), asu64(R1));
	goto L8253;
	goto L8256;
L8268:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("equal");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8256:
	R1 = 0;
	goto L8253;
L8253:
	return asi64(R1);
}

static i64 qq_vars_var_equalmixed(u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 result;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	R2 = 65538;
	if (asi64(R1) == asi64(R2)) goto L8273;
	R2 = 131073;
	if (asi64(R1) == asi64(R2)) goto L8274;
	R2 = 65539;
	if (asi64(R1) == asi64(R2)) goto L8275;
	R2 = 131075;
	if (asi64(R1) == asi64(R2)) goto L8275;
	R2 = 196609;
	if (asi64(R1) == asi64(R2)) goto L8276;
	R2 = 196610;
	if (asi64(R1) == asi64(R2)) goto L8276;
	goto L8277;
L8273:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = b;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	if (asr64(R1) != asr64(R2)) goto L8279;
	R1 = 1;
	goto L8278;
L8279:
	R1 = 0;
L8278:
	goto L8271;
	goto L8272;
L8274:
	asu64(R1) = a;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asr64(R2) = tor64(asi64(R2));
	if (asr64(R1) != asr64(R2)) goto L8281;
	R1 = 1;
	goto L8280;
L8281:
	R1 = 0;
L8280:
	goto L8271;
	goto L8272;
L8275:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R2) = qq_decimal_dectemp(asu64(R2));
	asi64(R1) = qq_decimal_var_equal_dec(asu64(R2), asu64(R1));
	result = asi64(R1);
	qq_decimal_freedectemp();
	asi64(R1) = result;
	goto L8271;
	goto L8272;
L8276:
	asu64(R1) = b;
	asu64(R1) = qq_decimal_dectemp(asu64(R1));
	asu64(R2) = a;
	asi64(R1) = qq_decimal_var_equal_dec(asu64(R2), asu64(R1));
	goto L8271;
	goto L8272;
L8277:
	R1 = 0;
	goto L8271;
L8272:
	R1 = 0;
	goto L8271;
L8271:
	return asi64(R1);
}

static i64 qq_vars_var_compare(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8284;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_vars_var_comparemixed(asu64(R2), asu64(R1));
	goto L8282;
L8284:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8286;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L8286;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8287;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8288;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8289;
	goto L8290;
L8286:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) >= asi64(R2)) goto L8292;
	R1 = -1;
	goto L8291;
L8292:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L8294;
	R1 = 1;
	goto L8293;
L8294:
	R1 = 0;
L8293:
L8291:
	goto L8282;
	goto L8285;
L8287:
	asu64(R1) = a;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	if (asr64(R1) >= asr64(R2)) goto L8296;
	R1 = -1;
	goto L8295;
L8296:
	asu64(R1) = a;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	if (asr64(R1) <= asr64(R2)) goto L8298;
	R1 = 1;
	goto L8297;
L8298:
	R1 = 0;
L8297:
L8295:
	goto L8282;
	goto L8285;
L8288:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_decimal_var_compare_dec(asu64(R2), asu64(R1));
	goto L8282;
	goto L8285;
L8289:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_strings_var_compare_string(asu64(R2), asu64(R1));
	goto L8282;
	goto L8285;
L8290:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("compare");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8285:
	R1 = 0;
	goto L8282;
L8282:
	return asi64(R1);
}

static i64 qq_vars_var_comparemixed(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	R2 = 65538;
	if (asi64(R1) == asi64(R2)) goto L8301;
	R2 = 131073;
	if (asi64(R1) == asi64(R2)) goto L8302;
	goto L8303;
L8301:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = b;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	if (asr64(R1) >= asr64(R2)) goto L8305;
	R1 = -1;
	goto L8304;
L8305:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = b;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	if (asr64(R1) <= asr64(R2)) goto L8307;
	R1 = 1;
	goto L8306;
L8307:
	R1 = 0;
L8306:
L8304:
	goto L8299;
	goto L8300;
L8302:
	asu64(R1) = a;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asr64(R2) = tor64(asi64(R2));
	if (asr64(R1) >= asr64(R2)) goto L8309;
	R1 = -1;
	goto L8308;
L8309:
	asu64(R1) = a;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asr64(R2) = tor64(asi64(R2));
	if (asr64(R1) <= asr64(R2)) goto L8311;
	R1 = 1;
	goto L8310;
L8311:
	R1 = 0;
L8310:
L8308:
	goto L8299;
	goto L8300;
L8303:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = tou64("comparemixed");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L8300:
	R1 = 0;
	goto L8299;
L8299:
	return asi64(R1);
}

static void qq_vars_var_concat(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8314;
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = tou64("Concat");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L8314:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8316;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8317;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8318;
	goto L8319;
L8316:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_strings_var_add_string(asu64(R2), asu64(R1));
	goto L8315;
L8317:
	asu64(R1) = a;
	qq_lists_var_dupl_list(asu64(R1));
	asu64(R1) = b;
	asu64(R2) = a;
	qq_lists_var_concatto_list(asu64(R2), asu64(R1));
	goto L8315;
L8318:
	asu64(R1) = a;
	qq_arrays_var_dupl_array(asu64(R1));
	asu64(R1) = b;
	asu64(R2) = a;
	qq_arrays_var_concatto_array(asu64(R2), asu64(R1));
	goto L8315;
L8319:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("concat");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8315:
	return;
}

static void qq_vars_var_append(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8322;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8324;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8325;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8326;
	goto L8327;
L8324:
	goto L8328;
	goto L8323;
L8325:
	goto L8329;
	goto L8323;
L8326:
	goto L8330;
	goto L8323;
L8327:
L8323:
	goto L8331;
	goto L8321;
L8322:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8333;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8334;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8335;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8336;
	goto L8337;
L8333:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_strings_var_add_string(asu64(R2), asu64(R1));
	asu64(R1) = b;
	qq_vars_var_unshareu(asu64(R1));
	goto L8332;
L8334:
// qq_vars.var_append.dolist:
L8328:
	asu64(R1) = a;
	qq_lists_var_dupl_list(asu64(R1));
	asu64(R1) = b;
	asu64(R2) = a;
	qq_lists_var_appendto_list(asu64(R2), asu64(R1));
	goto L8332;
L8335:
// qq_vars.var_append.doarray:
L8329:
	asu64(R1) = a;
	qq_arrays_var_dupl_array(asu64(R1));
	asu64(R1) = b;
	asu64(R2) = a;
	qq_arrays_var_appendto_array(asu64(R2), asu64(R1));
	goto L8332;
L8336:
// qq_vars.var_append.dobits:
L8330:
	asu64(R1) = a;
	qq_bits_var_dupl_bits(asu64(R1));
	asu64(R1) = b;
	asu64(R2) = a;
	qq_bits_var_appendto_bits(asu64(R2), asu64(R1));
	goto L8332;
L8337:
// qq_vars.var_append.error:
L8331:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("append");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8332:
L8321:
	return;
}

static void qq_vars_var_min(u64 a, u64 b) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8340;
	R1 = tou64("");
	R2 = tou64("VARMIN");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L8338;
L8340:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_vars_var_compare(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L8342;
	asu64(R1) = b;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8344;
	asu64(R1) = b;
	qq_vars_var_unshareu(asu64(R1));
L8344:
	goto L8341;
L8342:
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8346;
	asu64(R1) = a;
	qq_vars_var_unshareu(asu64(R1));
L8346:
	asu64(R1) = b;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = a;
	*(struct $B3*)(R2) = (R1_B3);
L8341:
L8338:
	return;
}

static void qq_vars_var_max(u64 a, u64 b) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8349;
	R1 = tou64("");
	R2 = tou64("VARMAX");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L8347;
L8349:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_vars_var_compare(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L8351;
	asu64(R1) = b;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8353;
	asu64(R1) = b;
	qq_vars_var_unshareu(asu64(R1));
L8353:
	goto L8350;
L8351:
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8355;
	asu64(R1) = a;
	qq_vars_var_unshareu(asu64(R1));
L8355:
	asu64(R1) = b;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = a;
	*(struct $B3*)(R2) = (R1_B3);
L8350:
L8347:
	return;
}

static i64 qq_vars_var_concatto(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8358;
	R1 = tou64("");
	R2 = tou64("concatto/mixed");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8358:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8360;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8361;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8362;
	goto L8363;
L8360:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_strings_var_addto_string(asu64(R2), asu64(R1));
	goto L8359;
L8361:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_lists_var_concatto_list(asu64(R2), asu64(R1));
	goto L8359;
L8362:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_arrays_var_concatto_array(asu64(R2), asu64(R1));
	goto L8359;
L8363:
	asu64(R1) = a;
	R2 = tou64("concat");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8359:
	R1 = 1;
	goto L8356;
L8356:
	return asi64(R1);
}

static i64 qq_vars_var_appendto(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8366;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8368;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8369;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8370;
	goto L8371;
L8368:
	goto L8372;
	goto L8367;
L8369:
	goto L8373;
	goto L8367;
L8370:
	goto L8374;
	goto L8367;
L8371:
	R1 = tou64("");
	R2 = tou64("appendto/mixed");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8367:
L8366:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8376;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8377;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8378;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8379;
	goto L8380;
L8376:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_strings_var_addto_string(asu64(R2), asu64(R1));
	asu64(R1) = b;
	qq_vars_var_unshareu(asu64(R1));
	goto L8375;
L8377:
// qq_vars.var_appendto.dolist:
L8372:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_lists_var_appendto_list(asu64(R2), asu64(R1));
	goto L8375;
L8378:
// qq_vars.var_appendto.doarray:
L8373:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_arrays_var_appendto_array(asu64(R2), asu64(R1));
	goto L8375;
L8379:
// qq_vars.var_appendto.dobits:
L8374:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_bits_var_appendto_bits(asu64(R2), asu64(R1));
	goto L8375;
L8380:
	asu64(R1) = a;
	R2 = tou64("append");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
	R1 = 0;
	goto L8364;
L8375:
	R1 = 1;
	goto L8364;
L8364:
	return asi64(R1);
}

static void qq_vars_var_getix(u64 a, i64 index) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8383;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8384;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8384;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8385;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8385;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8386;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8387;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8388;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8389;
	goto L8390;
L8383:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_strings_var_getix_string(asu64(R2), asi64(R1));
	goto L8382;
L8384:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_lists_var_getix_list(asu64(R2), asi64(R1));
	goto L8382;
L8385:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_arrays_var_getix_array(asu64(R2), asi64(R1));
	goto L8382;
L8386:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_bits_var_getix_bits(asu64(R2), asi64(R1));
	goto L8382;
L8387:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_sets_var_getix_set(asu64(R2), asi64(R1));
	goto L8382;
L8388:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_records_var_getix_record(asu64(R2), asi64(R1));
	goto L8382;
L8389:
	asi64(R1) = index;
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 16;
	R4 = 63;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asi64(R1) < asi64(R2)) goto L8392;
	asu64(R2) = a;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L8392;
	R1 = 1;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = index;
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8391;
L8392:
	R1 = tou64("");
	R2 = tou64("range/bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8391:
	goto L8382;
L8390:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("getix");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8382:
	return;
}

static void qq_vars_var_putix(u64 a, i64 index, u64 x) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8395;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8396;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8397;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8397;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8398;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8399;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8400;
	goto L8401;
L8395:
	asu64(R1) = x;
	asi64(R2) = index;
	asu64(R3) = a;
	qq_strings_var_putix_string(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
	goto L8394;
L8396:
	asu64(R1) = x;
	asi64(R2) = index;
	asu64(R3) = a;
	qq_lists_var_putix_list(asu64(R3), asi64(R2), asu64(R1));
	goto L8394;
L8397:
	asu64(R1) = x;
	asi64(R2) = index;
	asu64(R3) = a;
	qq_arrays_var_putix_array(asu64(R3), asi64(R2), asu64(R1));
	goto L8394;
L8398:
	asu64(R1) = x;
	asi64(R2) = index;
	asu64(R3) = a;
	qq_bits_var_putix_bits(asu64(R3), asi64(R2), asu64(R1));
	goto L8394;
L8399:
	asu64(R1) = x;
	asi64(R2) = index;
	asu64(R3) = a;
	qq_sets_var_putix_set(asu64(R3), asi64(R2), asu64(R1));
	goto L8394;
L8400:
	asu64(R1) = x;
	asi64(R2) = index;
	asu64(R3) = a;
	qq_records_var_putix_record(asu64(R3), asi64(R2), asu64(R1));
	goto L8394;
L8401:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("putix");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8394:
	return;
}

static void qq_vars_var_getixref(u64 a, i64 index) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8404;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8405;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8406;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8406;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8407;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8408;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8409;
	goto L8410;
L8404:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_strings_var_getixref_string(asu64(R2), asi64(R1));
	goto L8403;
L8405:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_lists_var_getixref_list(asu64(R2), asi64(R1));
	goto L8403;
L8406:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_arrays_var_getixref_array(asu64(R2), asi64(R1));
	goto L8403;
L8407:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_bits_var_getixref_bits(asu64(R2), asi64(R1));
	goto L8403;
L8408:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_sets_var_getixref_set(asu64(R2), asi64(R1));
	goto L8403;
L8409:
	asu64(R1) = a;
	asi64(R2) = index;
	asu64(R3) = a;
	qq_records_var_getixref_record(asu64(R3), asi64(R2), asu64(R1));
	goto L8403;
L8410:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("getixref");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8403:
	return;
}

static void qq_vars_var_getslice(u64 a, i64 i, i64 j) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8413;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8414;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8415;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8416;
	goto L8417;
L8413:
	asi64(R1) = j;
	asi64(R2) = i;
	asu64(R3) = a;
	qq_strings_var_getslice_string(asu64(R3), asi64(R2), asi64(R1));
	goto L8412;
L8414:
	asi64(R1) = j;
	asi64(R2) = i;
	asu64(R3) = a;
	qq_lists_var_getslice_list(asu64(R3), asi64(R2), asi64(R1));
	goto L8412;
L8415:
	asi64(R1) = j;
	asi64(R2) = i;
	asu64(R3) = a;
	qq_arrays_var_getslice_array(asu64(R3), asi64(R2), asi64(R1));
	goto L8412;
L8416:
	asi64(R1) = j;
	asi64(R2) = i;
	asu64(R3) = a;
	qq_bits_var_getslice_bits(asu64(R3), asi64(R2), asi64(R1));
	goto L8412;
L8417:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("getslice");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8412:
	return;
}

static void qq_vars_var_putslice(u64 a, i64 i, i64 j, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = x;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8420;
	R1 = tou64("");
	R2 = tou64("putslice: not compatible");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8420:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8422;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8423;
	goto L8424;
L8422:
	asu64(R1) = x;
	asi64(R2) = j;
	asi64(R3) = i;
	asu64(R4) = a;
	qq_strings_var_putslice_string(asu64(R4), asi64(R3), asi64(R2), asu64(R1));
	goto L8421;
L8423:
	asu64(R1) = x;
	asi64(R2) = j;
	asi64(R3) = i;
	asu64(R4) = a;
	qq_lists_var_putslice_list(asu64(R4), asi64(R3), asi64(R2), asu64(R1));
	goto L8421;
L8424:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("putslice");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8421:
	return;
}

static void qq_vars_var_getdotix(u64 a, i64 index) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8427;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8428;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8429;
	goto L8430;
L8427:
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L8433;
	R2 = 63;
	if (asi64(R1) <= asi64(R2)) goto L8432;
L8433:
	R1 = tou64("");
	R2 = tou64("int.[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8432:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = index;
	asi64(R1) >>= asi64(R2);
	R2 = 1;
	asi64(R1) &= asi64(R2);
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8426;
L8428:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_strings_var_getdotix_string(asu64(R2), asi64(R1));
	goto L8426;
L8429:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_records_var_getix_record(asu64(R2), asi64(R1));
	goto L8426;
L8430:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("getdotix");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8426:
	return;
}

static void qq_vars_var_putdotix(u64 p, i64 index, u64 x) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 a;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L8436;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8438;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8439;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8440;
	goto L8441;
L8438:
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L8444;
	R2 = 63;
	if (asi64(R1) <= asi64(R2)) goto L8443;
L8444:
	R1 = tou64("");
	R2 = tou64("int.[int]:= bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8443:
	R1 = 1;
	R2 = 33;
	asu64(R3) = x;
	asi64(R4) = index;
	asu64(R5) = a;
	R6 = 8;
	R5 += (i64)R6;
	qq_vars_var_storebit(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8437;
L8439:
	asu64(R1) = x;
	asi64(R2) = index;
	asu64(R3) = a;
	qq_strings_var_putdotix_string(asu64(R3), asi64(R2), asu64(R1));
	goto L8437;
L8440:
	asu64(R1) = x;
	asi64(R2) = index;
	asu64(R3) = a;
	qq_records_var_putix_record(asu64(R3), asi64(R2), asu64(R1));
	goto L8437;
L8441:
	asu64(R1) = a;
	R2 = tou64("putdotix");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8437:
	goto L8435;
L8436:
	asu64(R1) = p;
	R2 = tou64("putdotix");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8435:
	return;
}

static void qq_vars_var_getdotixref(u64 p, i64 index) {
    u64 R1, R2, R3; 
	u64 a;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L8447;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8449;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8450;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8451;
	goto L8452;
L8449:
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L8455;
	R2 = 63;
	if (asi64(R1) <= asi64(R2)) goto L8454;
L8455:
	R1 = tou64("");
	R2 = tou64("&int.[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8454:
	asu64(R1) = a;
	R2 = 8;
	R1 += (i64)R2;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 15;
	asu64(R2) = p;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 33;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = index;
	asu64(R2) = p;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L8448;
L8450:
	asu64(R1) = p;
	asi64(R2) = index;
	asu64(R3) = a;
	qq_strings_var_getdotixref_string(asu64(R3), asi64(R2), asu64(R1));
	goto L8448;
L8451:
	asu64(R1) = p;
	asi64(R2) = index;
	asu64(R3) = a;
	qq_records_var_getixref_record(asu64(R3), asi64(R2), asu64(R1));
	goto L8448;
L8452:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("getdotixref");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8448:
	goto L8446;
L8447:
	asu64(R1) = p;
	R2 = tou64("not refvar");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8446:
	return;
}

static void qq_vars_var_getdotslice(u64 a, i64 i, i64 j) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8458;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8459;
	goto L8460;
L8458:
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) <= asi64(R2)) goto L8462;
	R1 = (u64)&i;
	R2 = (u64)&j;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
L8462:
	asi64(R1) = i;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L8465;
	asi64(R1) = j;
	R2 = 63;
	if (asi64(R1) <= asi64(R2)) goto L8464;
L8465:
	R1 = tou64("");
	R2 = tou64("int.[slice] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8464:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asi64(R1) >>= asi64(R2);
	R2 = -1;
	asi64(R3) = j;
	asi64(R4) = i;
	asi64(R3) -= asi64(R4);
	R4 = 1;
	asi64(R3) += asi64(R4);
	asu64(R2) <<= asu64(R3);
	asu64(R2) = ~asu64(R2);
	asi64(R1) &= asi64(R2);
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8457;
L8459:
	asi64(R1) = j;
	asi64(R2) = i;
	asu64(R3) = a;
	qq_strings_var_getslice_string(asu64(R3), asi64(R2), asi64(R1));
	goto L8457;
L8460:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("getdotslice");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8457:
	return;
}

static void qq_vars_var_putdotslice(u64 p, i64 i, i64 j, u64 x) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 a;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L8468;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8470;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8471;
	goto L8472;
L8470:
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) <= asi64(R2)) goto L8474;
	R1 = (u64)&i;
	R2 = (u64)&j;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
L8474:
	asi64(R1) = i;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L8477;
	asi64(R1) = j;
	R2 = 63;
	if (asi64(R1) <= asi64(R2)) goto L8476;
L8477:
	R1 = tou64("");
	R2 = tou64("int.[slice]:= bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8476:
	asi64(R1) = j;
	asi64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 33;
	asu64(R3) = x;
	asi64(R4) = i;
	asu64(R5) = a;
	R6 = 8;
	R5 += (i64)R6;
	qq_vars_var_storebit(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8469;
L8471:
	asu64(R1) = x;
	asi64(R2) = j;
	asi64(R3) = i;
	asu64(R4) = a;
	qq_strings_var_putslice_string(asu64(R4), asi64(R3), asi64(R2), asu64(R1));
	goto L8469;
L8472:
	asu64(R1) = a;
	R2 = tou64("putdotslice");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8469:
	goto L8467;
L8468:
	asu64(R1) = p;
	R2 = tou64("not ref");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8467:
	return;
}

static void qq_vars_var_getdotsliceref(u64 p, i64 i, i64 j) {
    u64 R1, R2, R3; 
	u64 a;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L8480;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8482;
	goto L8483;
L8482:
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) <= asi64(R2)) goto L8485;
	R1 = (u64)&i;
	R2 = (u64)&j;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
L8485:
	asi64(R1) = i;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L8488;
	asi64(R1) = j;
	R2 = 63;
	if (asi64(R1) <= asi64(R2)) goto L8487;
L8488:
	R1 = tou64("");
	R2 = tou64("&int.[slice] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8487:
	asu64(R1) = a;
	R2 = 8;
	R1 += (i64)R2;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 15;
	asu64(R2) = p;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 33;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = i;
	asu64(R2) = p;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = j;
	asi64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = p;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L8481;
L8483:
	asu64(R1) = a;
	R2 = tou64("getdotsliceref");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8481:
	goto L8479;
L8480:
	asu64(R1) = p;
	R2 = tou64("not ref");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8479:
	return;
}

static void qq_vars_var_expand(u64 a, u64 dest, i64 m) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 b;
	u64 c;
	u64 p;
	u64 s;
	i64 n;
	i64 length;
	i64 av_1;
	i64 av_2;
	asi64(R1) = m;
	R2 = 2;
	if (asi64(R1) >= asi64(R2)) goto L8491;
	R1 = tou64("");
	R2 = tou64("Expand: LHS too few");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8491:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8493;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8494;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8495;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8496;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8497;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8497;
	goto L8498;
L8493:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
// qq_vars.var_expand.dolist:
L8499:
	asu64(R1) = dest;
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	c = asu64(R1);
	R1 = 1;
	n = asi64(R1);
	asi64(R1) = m;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L8502;
L8500:
	asi64(R1) = n;
	asi64(R2) = length;
	if (asi64(R1) <= asi64(R2)) goto L8504;
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L8503;
L8504:
	asu64(R1) = c;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = dest;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = dest;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8506;
	asu64(R1) = dest;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L8506:
	R1 = (u64)&c;
	(*tou64p(R1)) += 16;
L8503:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	R1 = (u64)&dest;
	(*tou64p(R1)) -=16;
	if (--asi64(av_1)) goto L8500;
L8502:
	goto L8492;
L8494:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	R3 = 63;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&dest;
	(*tou64p(R1)) -=16;
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = m;
	R2 = 2;
	asi64(R1) -= asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L8509;
L8507:
	R1 = (u64)&dest;
	(*tou64p(R1)) -=16;
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	if (--asi64(av_2)) goto L8507;
L8509:
	goto L8492;
L8495:
	asi64(R1) = m;
	asu64(R2) = dest;
	asu64(R3) = a;
	qq_strings_var_expand_string(asu64(R3), asu64(R2), asi64(R1));
	goto L8492;
L8496:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	length = asi64(R1);
	goto L8499;
	goto L8492;
L8497:
	asi64(R1) = m;
	asu64(R2) = dest;
	asu64(R3) = a;
	qq_arrays_var_expand_array(asu64(R3), asu64(R2), asi64(R1));
	goto L8492;
L8498:
	asu64(R1) = a;
	R2 = tou64("expand");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8492:
	return;
}

static void qq_vars_var_inplace(i64 index, u64 px, u64 y) {
    u64 R1, R2, R3; 
	u64 fnadd;
	u64 fnaddmixed;
	struct $B3 x;
	struct $B3 z;
	R1 = (u64)&qq_pcltabs_bintotable;
	asi64(R2) = index;
	R1 += (i64)R2*24-24;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 101;
	if (asi64(R1) != asi64(R2)) goto L8512;
	asu64(R1) = y;
	asu64(R2) = px;
	asi64(R1) = qq_vars_var_addto(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L8514;
	goto L8510;
L8514:
L8512:
	R1 = (u64)&qq_pcltabs_bintotable;
	asi64(R2) = index;
	R1 += (i64)R2*24-24;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fnadd = asu64(R1);
	R1 = (u64)&qq_pcltabs_bintotable;
	asi64(R2) = index;
	R1 += (i64)R2*24-24;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fnaddmixed = asu64(R1);
	R1 = (u64)&x;
	asu64(R2) = px;
	qq_vars_var_loadptr(asu64(R2), asu64(R1));
	R1 = (u64)&x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) != asi64(R2)) goto L8516;
	asu64(R1) = y;
	R2 = (u64)&x;
	asu64(R3) = fnadd;
	((F19)R3)(asu64(R2), asu64(R1));
	goto L8515;
L8516:
	asu64(R1) = fnaddmixed;
	if (!asu64(R1)) goto L8517;
	asu64(R1) = y;
	R2 = (u64)&x;
	asu64(R3) = fnaddmixed;
	((F19)R3)(asu64(R2), asu64(R1));
	goto L8515;
L8517:
	msysc_m$print_startcon();
	R1 = (u64)&qq_pcltabs_pclnames;
	R2 = (u64)&qq_pcltabs_bintotable;
	asi64(R3) = index;
	R2 += (i64)R3*24-24;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = y;
	R2 = (u64)&x;
	R3 = tou64("Inplace mixed");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L8515:
	R1 = (u64)&x;
	asu64(R2) = px;
	qq_vars_var_storeptr(asu64(R2), asu64(R1));
L8510:
	return;
}

static void qq_vars_var_inplace_unary(u64 px, u64 fnneg) {
    u64 R1, R2; 
	struct $B3 x;
	R1 = (u64)&x;
	asu64(R2) = px;
	qq_vars_var_loadptr(asu64(R2), asu64(R1));
	R1 = (u64)&x;
	asu64(R2) = fnneg;
	((F18)R2)(asu64(R1));
	R1 = (u64)&x;
	asu64(R2) = px;
	qq_vars_var_storeptr(asu64(R2), asu64(R1));
	return;
}

static void qq_vars_var_loadptr(u64 x, u64 y) {
    u64 R1, R2, R3, R4, R5, R6; struct $B3 R1_B3; 
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L8521;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L8522;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L8523;
	goto L8524;
L8521:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = y;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8526;
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L8526:
	goto L8520;
L8522:
	R1 = 0;
	asu64(R2) = y;
	asu64(R3) = x;
	R4 = 4;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	asu64(R4) = x;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	qq_packed_var_loadpacked(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	goto L8520;
L8523:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = x;
	R4 = 4;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	asu64(R4) = x;
	R5 = 2;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R5) = x;
	R6 = 8;
	asu64(R5) = *tou64p(((i64)R5+(i64)R6));
	qq_vars_var_loadbit(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	goto L8520;
L8524:
	asu64(R1) = x;
	R2 = tou64("var_loadptr");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8520:
	return;
}

static void qq_vars_var_storeptr(u64 p, u64 q) {
    u64 R1, R2, R3, R4, R5, R6; struct $B3 R1_B3; 
	u64 dest;
	u64 pptr;
	u64 qptr;
	struct $B3 v;
	i64 i;
	i64 n;
	i64 etag;
	i64 poffset;
	i64 qoffset;
	i64 bitwidthx;
	u64 pp;
	u64 qq;
	i64 aa;
	i64 bb;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L8529;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L8530;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L8531;
	goto L8532;
L8529:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8534;
	asu64(R1) = dest;
	qq_vars_var_unshareu(asu64(R1));
L8534:
	asu64(R1) = q;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = dest;
	*(struct $B3*)(R2) = (R1_B3);
	goto L8528;
L8530:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = q;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_packed_var_storepacked(asu64(R3), asu64(R2), asi64(R1));
	goto L8528;
L8531:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = q;
	asu64(R4) = p;
	R5 = 2;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R5) = p;
	R6 = 8;
	asu64(R5) = *tou64p(((i64)R5+(i64)R6));
	qq_vars_var_storebit(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8528;
L8532:
	asu64(R1) = p;
	R2 = tou64("var_popptr");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8528:
	return;
}

static void qq_vars_var_loadbit(u64 p, i64 shift, i64 t, i64 bitlength, u64 dest) {
    u64 R1, R2, R3; 
	u64 pd;
	u64 mask;
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = t;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L8537;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L8538;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L8539;
	goto L8540;
L8537:
	asi64(R1) = bitlength;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8542;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R1) &= asi64(R2);
	asi64(R1) = !!asi64(R1);
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8541;
L8542:
	asu64(R1) = p;
	pd = asu64(R1);
	R1 = -2;
	mask = asu64(R1);
	asi64(R1) = bitlength;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8544;
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L8545;
	goto L8546;
L8544:
	goto L8543;
L8545:
	R1 = 0;
	mask = asu64(R1);
	goto L8543;
L8546:
	asi64(R1) = bitlength;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&mask;
	*tou64p(R2) <<= asu64(R1);
L8543:
	asu64(R1) = pd;
	asu64(R1) = *tou64p(R1);
	asi64(R2) = shift;
	asu64(R1) >>= asu64(R2);
	asu64(R2) = mask;
	asu64(R2) = ~asu64(R2);
	asi64(R1) &= asi64(R2);
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L8541:
	goto L8536;
L8538:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 3;
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R1) &= asi64(R2);
	asi64(R2) = shift;
	asi64(R1) >>= asi64(R2);
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8536;
L8539:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 15;
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R1) &= asi64(R2);
	asi64(R2) = shift;
	asi64(R1) >>= asi64(R2);
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8536;
L8540:
	asi64(R1) = t;
	R2 = tou64("loadbit");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8536:
	return;
}

static void qq_vars_var_storebit(u64 p, i64 shift, u64 q, i64 t, i64 bitlength) {
    u64 R1, R2, R3; 
	u64 pd;
	u8 bb;
	u64 mask1;
	u64 mask2;
	u64 newvalue;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8549;
	R1 = tou64("");
	R2 = tou64("storebit not int");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8549:
	asi64(R1) = t;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L8551;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L8552;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L8553;
	goto L8554;
L8551:
	asi64(R1) = bitlength;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8556;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R2) = ~asi64(R2);
	asi64(R1) &= asi64(R2);
	asu64(R2) = q;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 1;
	asi64(R2) &= asi64(R3);
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L8555;
L8556:
	asu64(R1) = p;
	pd = asu64(R1);
	R1 = -2;
	mask1 = asu64(R1);
	asi64(R1) = bitlength;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8558;
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L8559;
	goto L8560;
L8558:
	goto L8557;
L8559:
	R1 = 0;
	mask1 = asu64(R1);
	goto L8557;
L8560:
	asi64(R1) = bitlength;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&mask1;
	*tou64p(R2) <<= asu64(R1);
L8557:
	asu64(R1) = mask1;
	asu64(R1) = ~asu64(R1);
	mask1 = asu64(R1);
	asi64(R1) = shift;
	if (!asi64(R1)) goto L8562;
	asi64(R1) = shift;
	R2 = (u64)&mask1;
	*tou64p(R2) <<= asu64(R1);
L8562:
	asu64(R1) = mask1;
	asu64(R1) = ~asu64(R1);
	mask2 = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	newvalue = asu64(R1);
	asi64(R1) = shift;
	if (!asi64(R1)) goto L8564;
	asi64(R1) = shift;
	R2 = (u64)&newvalue;
	*tou64p(R2) <<= asu64(R1);
L8564:
	asu64(R1) = pd;
	asu64(R1) = *tou64p(R1);
	asu64(R2) = mask2;
	asu64(R1) &= asu64(R2);
	asu64(R2) = newvalue;
	asu64(R3) = mask1;
	asu64(R2) &= asu64(R3);
	asu64(R1) |= asu64(R2);
	asu64(R2) = pd;
	*tou64p(R2) = asu64(R1);
L8555:
	goto L8550;
L8552:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 3;
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R2) = ~asi64(R2);
	asi64(R1) &= asi64(R2);
	asu64(R2) = q;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 3;
	asi64(R2) &= asi64(R3);
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L8550;
L8553:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 15;
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R2) = ~asi64(R2);
	asi64(R1) &= asi64(R2);
	asu64(R2) = q;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 15;
	asi64(R2) &= asi64(R3);
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L8550;
L8554:
	asi64(R1) = t;
	R2 = tou64("storebit");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8550:
	return;
}

static void qq_vars_var_convert(u64 x, i64 t, u64 dest) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	i64 s;
	i64 tbase;
	i64 aa;
	struct $B3 bn;
	asu64(R1) = x;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = dest;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	s = asi64(R1);
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L8567;
	goto L8565;
L8567:
	asi64(R1) = t;
	tbase = asi64(R1);
	asi64(R1) = t;
	asu64(R2) = dest;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = s;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8569;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8570;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L8571;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L8571;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L8571;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8572;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L8573;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8574;
	goto L8575;
L8569:
	asi64(R1) = tbase;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8577;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8578;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8579;
	goto L8580;
L8577:
	goto L8576;
L8578:
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L8576;
L8579:
	asu64(R1) = dest;
	asu64(R2) = x;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	qq_decimal_var_make_dec_int(asi64(R2), asu64(R1));
	goto L8576;
L8580:
	asi64(R1) = t;
	R2 = tou64("conv int=>");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8576:
	goto L8568;
L8570:
	asi64(R1) = tbase;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8582;
	goto L8583;
L8582:
	asu64(R1) = x;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = toi64(asr64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8581;
L8583:
	asi64(R1) = t;
	R2 = tou64("conv real=>");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8581:
	goto L8568;
L8571:
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = tbase;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8585;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L8586;
	goto L8587;
L8585:
	goto L8584;
L8586:
	R1 = 16;
	asu64(R2) = dest;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R2) = dest;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L8584;
L8587:
	asi64(R1) = t;
	R2 = tou64("conv ptr=>");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8584:
	goto L8568;
L8572:
	asi64(R1) = tbase;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8589;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8590;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8591;
	goto L8592;
L8589:
	asu64(R1) = dest;
	asi64(R2) = t;
	asu64(R3) = x;
	qq_strings_var_convert_string_list(asu64(R3), asi64(R2), asu64(R1));
	goto L8588;
L8590:
	asu64(R1) = dest;
	asu64(R2) = x;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = x;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_decimal_var_make_dec_str(asu64(R3), asi64(R2), asu64(R1));
	goto L8588;
L8591:
	goto L8588;
L8592:
	asi64(R1) = t;
	R2 = tou64("string=>");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8588:
	goto L8568;
L8573:
	asi64(R1) = tbase;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8594;
	asi64(R1) = t;
	R2 = tou64("type=>");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8594:
	goto L8568;
L8574:
	asi64(R1) = tbase;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8596;
	goto L8597;
L8596:
	asu64(R1) = x;
	asi64(R1) = qq_decimal_var_convert_dec_int(asu64(R1));
	aa = asi64(R1);
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = aa;
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8595;
L8597:
	asi64(R1) = t;
	R2 = tou64("decimal=>");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8595:
	goto L8568;
L8575:
	asi64(R1) = t;
	asi64(R2) = s;
	R3 = tou64("Convert s.t");
	qq_runaux_pcmxtypestt(asu64(R3), asi64(R2), asi64(R1));
L8568:
L8565:
	return;
}

static i64 qq_vars_var_gethashvalue(u64 p) {
    u64 R1, R2; 
	i64 hsum;
	i64 csum;
	i64 c;
	i64 n;
	i64 i;
	i64 result;
	u64 s;
	u64 s0;
	u64 q;
	i64 av_1;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8600;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8601;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8601;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8601;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8602;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8603;
	goto L8604;
L8600:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	asi64(R1) = n;
	if (asi64(R1)) goto L8606;
	R1 = 0;
	goto L8598;
L8606:
	R1 = 0;
	hsum = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L8609;
L8607:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = hsum;
	R2 = 4;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	hsum = asi64(R1);
	if (--asi64(av_1)) goto L8607;
L8609:
	asi64(R1) = hsum;
	R2 = 5;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	result = asi64(R1);
	asi64(R1) = result;
	R2 = 9223372036854775807;
	asi64(R1) &= asi64(R2);
	goto L8598;
	goto L8599;
L8601:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L8598;
	goto L8599;
L8602:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8611;
	R1 = 0;
	goto L8598;
	goto L8610;
L8611:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	goto L8598;
L8610:
	goto L8599;
L8603:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L8598;
	goto L8599;
L8604:
	asu64(R1) = p;
	R2 = tou64("Can't hash:");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8599:
	R1 = 0;
	goto L8598;
L8598:
	return asi64(R1);
}

static void qq_vars_var_objtovar(i64 tag, u64 p, u64 q) {
    u64 R1, R2, R3; 
	asi64(R1) = tag;
	R2 = 256;
	asi64(R1) |= asi64(R2);
	asu64(R2) = q;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_vars_var_putdotix_intint(u64 a, i64 index, u64 b) {
    u64 R1, R2, R3; 
	u64 x;
	u64 y;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	y = asu64(R1);
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L8616;
	R2 = 63;
	if (asi64(R1) <= asi64(R2)) goto L8615;
L8616:
	R1 = tou64("");
	R2 = tou64("int.[int]:= bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8615:
	asu64(R1) = x;
	R2 = 1;
	asi64(R3) = index;
	asi64(R2) <<= asi64(R3);
	asi64(R2) = ~asi64(R2);
	asi64(R1) &= asi64(R2);
	asu64(R2) = y;
	asi64(R3) = index;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_vars_var_power(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8619;
	asu64(R1) = b;
	asu64(R2) = a;
	qq_vars_var_powermixed(asu64(R2), asu64(R1));
	goto L8617;
L8619:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8621;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8622;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8623;
	goto L8624;
L8621:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = Poweri64(asi64(R1), asi64(R2));
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8620;
L8622:
	asu64(R1) = b;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asr64(R1) = pow(asr64(R2), asr64(R1));
	asu64(R2) = a;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L8620;
L8623:
	asu64(R1) = b;
	asi64(R1) = qq_decimal_var_convert_dec_int(asu64(R1));
	asu64(R2) = a;
	qq_decimal_var_power_dec(asu64(R2), asi64(R1));
	goto L8620;
L8624:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("power");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8620:
L8617:
	return;
}

static void qq_vars_var_powermixed(u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 newtag;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	newtag = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	R2 = 65538;
	if (asi64(R1) == asi64(R2)) goto L8627;
	R2 = 131073;
	if (asi64(R1) == asi64(R2)) goto L8628;
	R2 = 196609;
	if (asi64(R1) == asi64(R2)) goto L8629;
	goto L8630;
L8627:
	R1 = 2;
	newtag = asi64(R1);
	asu64(R1) = b;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asr64(R2) = tor64(asi64(R2));
	asr64(R1) = pow(asr64(R2), asr64(R1));
	asu64(R2) = a;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L8626;
L8628:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = a;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asr64(R1) = pow(asr64(R2), asr64(R1));
	asu64(R2) = a;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L8626;
L8629:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	qq_decimal_var_power_dec(asu64(R2), asi64(R1));
	goto L8626;
L8630:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = tou64("Powermixed");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L8626:
	asi64(R1) = newtag;
	asu64(R2) = a;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void qq_cli_start() {
	qq_lex_start();
	qq_lists_start();
	qq_pcllib_start();
	qq_runx_start();
	qq_strings_start();
	qq_tables_start();
	return;
}

static struct $B33 $procaddr = {{
(u64)&qq_print_pch_strstartprint}};

static struct $B33 $procname = {{
(u64)"pch_strstartprint"}};

static i64 $nprocs = 1;

// ***** PCL Support Library *****

i64 Getdotindex(u64 a, int i) {
	return (a & (1LL<<i))>>i;
}

u64 Setdotindex(u64 a, i64 i, i64 x) {
	return (a & ~(1LL<<i)) | ((u64)(x)<<i);
}

i64 Getdotslice(u64 a, i64 i, i64 j) {
	if (i>=j)
		return (a>>j) & ~(0xFFFFFFFFFFFFFFFF<<(i-j+1));
	else
		return (a>>i) & ~(0xFFFFFFFFFFFFFFFF<<(j-i+1));
}

u64 Setdotslice(u64 a, i64 i, i64 j, u64 x) {
	u64 mask64;
	if (i>j) {i64 t=i; i=j; j=t;}

	mask64=~((0xFFFFFFFFFFFFFFFF<<(j-i+1)))<<i;
	return (a & ~mask64) ^ (x<<i);
}

i64 Poweri64(i64 a, i64 n) {
	if (n<0)
		return 0;
	else if (n==0)
		return 1;
	else if ((n&1)==0)
		return Poweri64(a*a, n/2);
	else
		return Poweri64(a*a, (n-1)/2)*a;
}

// End of C Code

