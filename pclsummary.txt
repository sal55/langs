PCL INSTRUCTION SUMMARY
=======================

(Stack VM Intermediate Language used as target of systems compiler.)

Proc/Function/Variable Definitions

    proc             [T] M [exp]  (0-0) Define function returning T (omit for procs)
    param            T M          (0-0) Define parameter
    local            T M          (0-0) Define local variable
    end                           (0-0) End of function

    istatic          T M          (0-0) Define initialised static variable
    zstatic          T M          (0-0) Define zeroed static variable
    db               NC...        (0-0) Define u8/i8 data, usually following istatic
    dw               NC...        (0-0) Define u16/i16 data 
    dd               NC...        (0-0) Define u32/i32 data
    dq               MLNS         (0-0) Define u64/i64 data

    linkdll          MS           (0-0) Name of DLL as eg `msvcrt` or `"msvcrt"`

Load, Store and Stack Control

    load             T MLN        (0-1) X' := M (variable, label, imm^)
    loadref          T ML         (0-1) X' := &M (variable, label)
    loadimm          T NS         (0-1) X' := M (imm, &string)
    store            T ML         (1-0) M (variable, label) := X
    unload           T            (1-0) Decr operand count, unload if zero
    double                        (1-1) Create extra instance of X in same stack slot
    duplopnd                      (1-2) Duplicate operand, X':= Y' := X in two slots
    swapstk                       (2-2) Swap X, Y operands
    swapmem          T            (2-0) Swap(X^, Y^)
    clear            T            (1-0) clear X^ to zeros

Simple Pointers

    iload            T            (1-1) X' := X^
    istore           T            (2-0) Y^ := X

Pointers with Scaled Offsets (also used for Indexing and Record field access).
T is the pointer target; all address calculations are in bytes.

    iloadx           T s d        (2-1) X' := (X + Y*scale + offset)^
    istorex          T s d        (3-0) (Y + Z*scale + offset)^ := X
    addptrx          T s d        (2-1) X' := X + Y*scale + offset
    subptrx          T s d        (2-1) X' := X - Y*scale + offset
    subptr           T s          (2-1) X' := (X - Y)*scale

Call and Return

    callp            M n v        (n-0) [X' :=] M(...)
    callf            T M n v      (n-1) [X' :=] M(...)
    icallp           n v          (n-0) [X' :=] X^(...)
    icallf           T n v        (n+1-1) [X' :=] X^(...)
    return

    setret           T
    setretm          n T...       (n-n)

Jumps, Loops and Switch

    jump             L            (0-0) Goto L
    ijump                         (1-0) Goto X

    jumpeq           T L          (2-0) Goto L when X = Y
    jumpne           T L          (2-0) Goto L when X <> Y
    jumplt           T L          (2-0) Goto L when X < Y
    jumple           T L          (2-0) Goto L when X <= Y
    jumpge           T L          (2-0) Goto L when X >= Y
    jumpgt           T L          (2-0) Goto L when X > Y

    jumpt            L            (1-0) Goto L when X is true (X is always int)
    jumpf            L            (1-0) Goto L when X is false

    forup            L M MN s     (0-0) M+:=s; goto L when M<=MN
    fordown          L M MN s     (0-0) M-:=s; goto L when M>=MN
    to               L M          (0-0) --M;   goto L when M<>0

    switch           L L2 a b     (1-0) L=jumptab, L2=elselab, a/b = min/max
    swlabel          L            (0-0) Jumptable entry
    endsw                         (0-0) Mark end of jumptable (allow segment change etc)


Bit/Bitfield Operators

    loadbit          T             (2-1) X' := X.[Y]
    storebit         T             (3-0) Y^.[Z] := X
    loadbf           T             (3-1) X' := X.[Y..Z]
    storebf          T             (4-0) X^.[Y..Z] := W

Binary Operators

    add              T            (2-1) X' := X + Y (Similar for following)
    sub              T            (2-1)
    mul              T            (2-1)
    divf             F            (2-1) (Floating point divide)
    div              D            (2-1) (Integer divide)
    rem              D            (2-1) (Integer remainder)
    divrem           D            (2-2) (X', Y') := (X % Y, X rem Y) (% = int divide)
    bitand           D            (2-1) X' := X iand Y (bitwise AND)
    bitor            D            (2-1)
    bitxor           D            (2-1)
    shl              D            (2-1) (Shift left)
    shr              D            (2-1) (Shift right)
    min              T            (2-1) X' := min(X, Y)
    max              T            (2-1)
    eq               T            (2-1) X' := X = Y
    ne               T            (2-1)
    lt               T            (2-1)
    le               T            (2-1)
    ge               T            (2-1)
    gt               T            (2-1)
    power            T            (2-1) X' := X ** Y
    atan2            F            (2-1)

In-place Binary Operators

    addto            T            (2-0) X^ +:= Y (similar for following)
    subto            T            (2-0)
    multo            T            (2-0)
    divfto           F            (2-0)
    divto            D            (2-0)
    remto            D            (2-0)
    bitandto         D            (2-0)
    bitorto          D            (2-0)
    bitxorto         D            (2-0)
    shlto            D            (2-0)
    shrto            D            (2-0)
    minto            T            (2-0) X^ := min(X^, Y)
    maxto            T            (2-0)
    addpxto          T s d        (2-0) X^ +:= Y*s + d; X^ points to T; Y is i64
    subpxto          T s d        (2-0) X^ -:= Y*s + d; X^ points to T; Y is i64

Unary Operators

    neg              T            (1-1) X' := -X
    abs              T            (1-1) X' := abs(X)
    bitnot           D            (1-1) Bitwise invert
    not              T            (1-1) X' := (X=0 | 1 | 0) (Logical)
    notnot           T            (1-1) X' := (X=0 | 0 | 1)
    sqr              T            (1-1) X' := X*X
    sign             T            (1-1) X' := -1,0,1 according to X<0, X=0, X>0

Maths Operators

    sqrt             F            (1-1)
    sin              F            (1-1) X' := sin(X)
    cos              F            (1-1)
    tan              F            (1-1)
    asin             F            (1-1)
    acos             F            (1-1)
    atan             F            (1-1)
    log              F            (1-1) Natural log
    log10            F            (1-1) Base-10 log
    exp              F            (1-1)
    round            F            (1-1)
    floor            F            (1-1)
    ceil             F            (1-1)
    fract            F            (1-1)


In-Place Unary Operators

    negto            T            (1-0) X^ := -X^
    absto            T            (1-0)
    bitnotto         D            (1-0)
    notto            D            (1-0) X^ := (X^=0 | 1 | 0)
    notnotto         D            (1-0) X^ := (X^=0 | 0 | 1)

Increment/Decrement
A value of s other then +/- 1 can be used when incrementing pointers.

    incrto           D [s]        (0-0) X^ +:=s; default s is 1
    incrload         D [s]        (0-0) X^ +:=s; X' := X^
    loadincr         D [s]        (0-0) X' := X^; X^ +:= s

Type Conversions
X has type U (a primary type)

    float            T U          (1-1) X' := T(X) (convert int to float)
    fix              T U          (1-1) X' := T(X) (convert float to int)
    truncate         T U          (1-1)
    fwiden           T U          (1-1) X' := r64(x) (from r32)
    fnarrow          T U          (1-1) X' := r32(X) (from r64)
    typepun          T U          (0-0) X' := T@(X) (T/U must be same size)

Function Reflection
Programs can contain tables of function names and addresses. Only functions
defined as `proc F*`, with an asterisk, are included in the tables (to minimise
EXE files)

    nprocs                        (0-1) X' := Number of '*' designated functions in program
    procname                      (1-1) X' := functionname[X] (X is 1-based)
    procaddr                      (1-1) X' := functionaddr[X] (X is 1-based)

Slicing Ops
(Slice lower bound is not known here, it will be known by the HLL compiler
and will be fixed. To obtain `lwb` and `upb` requires some arithmetic using
that lower bound value.) 

    sliceptr         T            (1-1) Slice pointer
    slicelen         T            (1-1) Slice length

Misc: not needed for Interpreted or Stack target

    startm                        Multi-path markers
    resetm
    endm

    callargs         n            In advance of loading call arguments

    assem                         Ignored in discrete PCL code

    push             T            (1-0) Push X to hardware stack
    pop              T            (0-1) Pop hardware stack to X'
    pushany                       (0-0) Push hardware stack with anything
    popany                        (0-0) Pop hardware stack, discard value

TYPES
=====

  i8        Signed integers
  i16
  i32
  i64

  u8        Unsigned integers
  u16
  u32
  u64       Used for pointers

  r32, f32  Floats 
  r64, f64

  mem n     block of n-byte data used for records and fixed size arrays


Primary types are `i64 u64 r32 r32 mem`; these are the only ones allowed
on the stack. (mem types represented by a reference.)

Narrow types `i8 i16 i32 u8 u16 u32` are only used in relation to
memory operations, or in conversions.

STACK USAGE
===========

Each opcode description uses (a-b) to indicate how the stack is changed:

   a   is the number of relevant stack entries at the start of the op
   b   is the new number of stack entries after it's done

So (2-1) for `add` means that it consumes two stack operands, then pushes a new
value, the result.


STACK OPERANDS
==============

Input operands are designated by X, Y, Z, and sometimes W. Output operands,
the new values written, are shown as X' and Y'. How each relates to the top
of stack depends on the number of stack inputs, the `a` in `(a-b)`
in the tables:

  a = 1       Uses X            X is the last pushed
  a = 2       Uses X, Y         Y is last pushed
  a = 3       Uses X, Y, Z      Z is last pushed
  a = 4       Uses W, X, Y, Z   Z is last pushed

INLINE OPERANDS
===============

As well as the variable stack operands, there are fixed operands that are
part of the instruction.

Most instructions have a type attribute, a type name described above. This is represented in the listing by:

  T         Any type (or U for a secondary type)
  F         Float
  D         Integer

Many have a main operand shown as a capital letter:

  M         Variable (static, local, parameter) or function name
  L         Label number (written as #1234)
  S         Zero-terminated string ("ABCDEF") as a pointer to that string
  N         Numeric Constant (123 or 56.7)
  C         Immediate string or char sequence ('ABCDEF'), not zero-terminated

  MLS etc   A mix indicates any of these can be used

Small letters indicate fixed minor attributes.
