<!DOCTYPE html []>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="author" content="MarkdownViewer++" />
    <title>Modules24.md</title>
    <style type="text/css">
            
/* Avoid page breaks inside the most common attributes, especially for exports (i.e. PDF) */
td, h1, h2, h3, h4, h5, p, ul, ol, li {
    page-break-inside: avoid; 
}

        </style>
  </head>
  <body>
    <h2 id="modules-2024">Modules 2024</h2>
    <p>I created a new Modules scheme a couple of years ago. Based on my experience since, this has been simplified.</p>
    <p>This new version is in use in two languages, one lower-level systems language, one dynamic scripting language, both ahead-of-time compiled. Both are whole-program compilers. Although the comments mostly have the systems one in mind.</p>
    <p>There is quite a lot to explain, but in brief: <strong>all the modules comprising a program are listed at the top of the lead module</strong>; that's pretty much it!</p>
    <p>With this scheme, no separate build system is needed to turn a bunch of sources into an EXE or DLL file.</p>
    <h3 id="what-is-a-module">What is a Module</h3>
    <p>A 'module' in this scheme is always one source file. One module cannot be implemented across multiple source files. One source file cannot define multiple modules. Modules cannot contain other modules (those would be more like classes).</p>
    <p>The name of a module must be both a valid identifier in the language, and a valid filename.</p>
    <h1 id="example-pro">Example Pro</h1>
    <p>I will use an example program P consisting of 4 modules: P (the lead module), A, B and C. All information about the layout of project is given in the lead module. There are two ways do this:</p>
    <p>
      <strong>(1)</strong> P contains only the list of other modules (it doesn't include itself) and no other code. So it looks like this:</p>
    <pre>
      <code>module A
module B
module C
</code>
    </pre>
    <p>This is the pattern I use for most projects. This allows the lead module to be easily swapped with another, with a slightly different set of modules to provide an alternate configuration.</p>
    <p>
      <strong>(2)</strong> P can also contain code, although here you'd probably dispense with P completely, and put the module info at the start of A:</p>
    <pre>
      <code>module B
module C
.... the rest of module A ....
</code>
    </pre>
    <p>(Note that the application will now be called A, but of course you can name the modules P, B, C, or you can choose a name at compile-time.)</p>
    <p>There is no project info, no <code>module</code> or <code>import</code> statements, in any other module. Other module schemes tend to have rag-bag collections of <code>import</code> statements at the top of every module, which in my view is unnecessary micro-managing.</p>
    <h3 id="the-subprogram">The SubProgram</h3>
    <p>Modules in my scheme are grouped into SubPrograms. Within that group, any entity exported by any module (using a <code>global</code> attribute), is visible to all modules in the group. No specific <code>import</code> is needed, so long as all modules are listed in the lead module. My example program contains one subprogram.</p>
    <p>No name-qualifier is needed either: to call a global function <code>F</code> defined in <code>B</code> from <code>A</code>, I can just write <code>F()</code>. I only need to write <code>B.F()</code> if, for example, <code>C</code> also exported a function <code>F</code>.</p>
    <p>So all modules in the subprogram group are on familiar terms with each other. There is no hierarchy. There can be cycles: A can import B that can import A. (There is an ordering however; see below.)</p>
    <h3 id="multiple-subprograms">Multiple SubPrograms</h3>
    <p>Most of my current projects have one subprogram - one group of chummy modules (plus the standard library; see below). Programs can have several subprograms, but each should be a group of modules that could be compiled by themselves, either into an EXE file, or into  DLL file (when there is no <code>main</code> entry point and the subprogram is a library).</p>
    <p>Suppose there is a 3-module library Q with modules Q, X, Y. Q might contain:</p>
    <pre>
      <code>module X
module Y
</code>
    </pre>
    <p>To incorporate this into P, so that Q is statically compiled into the same EXE, P is defined like this:</p>
    <pre>
      <code>module A
module B
module C
import Q           # read further modules from Q
</code>
    </pre>
    <p>The resulting program compromises modules P, A, B, C, Q, X, Y, although P and Q contain only module info here.</p>
    <h3 id="visibility-between-subprograms">Visibility between SubPrograms</h3>
    <p>Even global entities between the modules of Q, for example, are not visible from P, unless they are specifically exported from Q. This involves using an <code>export</code> attribute instead of <code>global</code>. (It is not possible to export without also making a name global in that subprogram.)</p>
    <p>So if X exports a function <code>G</code>, it can be called from module A using <code>G()</code>, you don't need to qualify the name unless there is again a clash. But if you do it will be written as <code>Q.G()</code> not <code>X.G()</code> or <code>Q.X.G()</code>; P knows nothing of the internal modules of Q. (It is not possible to export two different <code>G</code> functions from Q.)</p>
    <p>Here there is a hierarchy of dependencies; cycles between subprograms are not allowed. The first subprogram (P in my example) is at the top of the hierarchy.</p>
    <p>Q can't call exports of P, as it needs to work standalone.</p>
    <h3 id="the-standard-library">The Standard Library</h3>
    <p>For my static language, this is a collection of 5 modules, listed in a 6th module called <code>msyslib</code>. This would normally require this line in each application:</p>
    <pre>
      <code>import msyslib
</code>
    </pre>
    <p>But this module is included automatically, unless specifically excluded. The standard library is anyway special since the source files are expected to be embedded within the compiler, not be files on disk.</p>
    <h3 id="namespaces">NameSpaces</h3>
    <p>Each module name creates a namespace within that subprogram. And each subprogram name also creates a namespace visible across the program. Mainly these are used for disambiguation when global or exported names clash. In that case, aliases can be created:</p>
    <pre>
      <code> module longmodulename as lmn
</code>
    </pre>
    <p>to keep accesses short. In the dynamic language, module names can be stored in variables and used for name resolving at runtime.</p>
    <h3 id="creating-a-library">Creating a Library</h3>
    <p>Any program can be compiled to a DLL file (Windows dynamic shared library) rather than EXE. Any names with <code>export</code> attribute in the top or only subprogram, are also exported from the DLL library. (In this case, the names are unadorned. If <code>B.F</code> is exported, it will have the name <code>F</code>, so some care needs to be taken to avoid clashes.)</p>
    <p>(Comments about EXE and DLL obviously refer to the systems language.)</p>
    <p>In principle, anything in its own subprogram can be made into a DLL, and the same functions called via the usual FFI methods. If the DLL is created with my compiler, it will automatically produce an exports file to allow its use from my language. So if Q is compiled, it will create a module called Q_LIB. Then P can be revised to be this:</p>
    <pre>
      <code>module A
module B
module C
module Q_LIB           # contains FFI module to access exported entities of Q
</code>
    </pre>
    <h3 id="library-imports">Library Imports</h3>
    <p>One other thing the scheme specifies is any external libraries that are needed to build the application. For example:</p>
    <pre>
      <code>linkdll opengl
</code>
    </pre>
    <p>This is only needed (in my language) if there isn't an import module somewhere with an FFI block that explicitly names the library.
(Often there is no clean link: an FFI block might named 100 functions which exist in three separate DLLs, or the exact DLL name depends on version which I want in one place. Sometimes multiple FFIs declare names from the same DLL.)</p>
    <p>Names imported via FFI are given a global attribute. So I can have a module (say SDL) that imports a bunch of functions from SDL2 for example, those same functions are then visible to all other modules in the group. I just need <code>module SDL</code> in the lead module.</p>
    <h3 id="the-file-system">The File System</h3>
    <p>The module scheme tries to be independent of the file system. But it can't always manage that.</p>
    <p>There is currently a weak spot: unless all input modules are in the same directory of the lead module, it needs to be told where to look. But as it's done now, that info is hardcoded within the project info, which is undesirable. (In general I will not know for sure where some arbitrary subprogram resides, or it cou;ld change.) See the real example below.</p>
    <p>So this needs a better solution. Otherwise with that first example starting module P:</p>
    <pre>
      <code>module A
module B
module C
</code>
    </pre>
    <p>This represents 4 source files, <code>P.m A.m B.m C.m</code> (assuming my systems language). The location of <code>P.m</code> depends on what path was provided to the compiler, so if invoked like this:</p>
    <pre>
      <code>mm \abc\def\p                    # note both file system and language are case-insensitive, and extensions are optional
</code>
    </pre>
    <p>Then <code>P.m</code> is in directory <code>/abc/def/</code>, and the other modules are looked for there unless the path is overwridden as shown below.</p>
    <p>In the case of the standard library modules, those source files are embedded inside the compiler. (There is an option to load them from disk, but it then looks somewhere that is only meaningful on my own machine as developer.)</p>
    <p>In this scheme, the compiler will always look in exactly one place for a source file. It will never look in a range of places (that can lead to inadvertently mixing versions, or even loading an unrelated file of the same name).</p>
    <h3 id="module-evaluation-order">Module Evaluation Order</h3>
    <p>A feature of my languages is that there is an optional special function <code>start</code> in each module. If present, this is automatically called when the program starts. (In the dynamic one, there can also be file-scope variables initialised with runtime expressions.)</p>
    <p>This can be used to initialise various data and data structures. However, behaviour may rely on the order each function/each module is invoked. With a scheme using <code>import</code> everywhere, this can be unpredictable. Here, it is strictly in the order the modules are listed in the lead module, except the module containing the entry point (which must be near the start) is done last.</p>
    <h3 id="program-entry-point">Program Entry Point</h3>
    <p>This is the function called <code>main</code> in the main subprogram, and specifically in the first module or the second. Other <code>main</code> functions in other modules are ignored.</p>
    <p>(In the dynamic language, individual modules can be run directly. If there is a <code>main</code> function in the lead module submitted, it will call it. This is sometimes used for test code for that module.)</p>
    <h3 id="real-example">Real Example</h3>
    <p>This is from a C compiler, an old one which incorporates an x64 assembler as a separate subprogram. Thus there are two subprograms plus the standard library. This is lead module <code>cc.m</code>:</p>
    <pre>
      <code>    module cc_cli
    module cc_decls
    module cc_blockmcl
    module cc_export
    module cc_genasm
    module cc_genmcl
    module cc_headers
    module cc_lex
    module cc_lib
    module cc_libmcl

    module cc_parse
    module cc_support
    module cc_tables

    $sourcepath "c:/ax/"
    import aalib
</code>
    </pre>
    <p>That subprogram has its own lead module which is this:</p>
    <pre>
      <code>    module cc_assembler
    module aa_decls
    module aa_disasm
    module aa_genss
    module aa_lex
    module aa_lib
    module aa_mcxdecls
    module aa_objdecls
    module aa_parse
    module aa_tables
    module aa_writeexe
    module aa_writeobj
</code>
    </pre>
    <p>Normally, those <code>aa_</code> modules are used with a different lead module, <code>aa.m</code>, which is built into a standalone assembler:</p>
    <pre>
      <code>    module aa_cli

    module aa_decls
    module aa_genss
    module aa_lex
    module aa_lib
    module aa_objdecls
    module aa_mcxdecls
    module aa_parse

    module aa_tables
    module aa_writeexe
    module aa_writemcx
    module aa_writeobj

#   module aa_disasm               # these two are optional; only used for development
#   module aa_writess
    module aa_writessdummy
</code>
    </pre>
    <p>The two projects are built like this:</p>
    <pre>
      <code>c:\bcx&gt;mm cc
Compiling cc.m to cc.exe

c:\ax&gt;mm aa
Compiling aa.m to aa.exe
</code>
    </pre>
    <h3 id="directives">Directives</h3>
    <p>They are:</p>
    <pre>
      <code>     module name [as name]
     import name
     $sourcepath string                  # (temporary feature until sorted)
     linkdll name
</code>
    </pre>
  </body>
</html>
