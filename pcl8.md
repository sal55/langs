## PCL v8 Intermediate Language

This documents some details of the IL I now use in my lower-level language compilers.

### Disambiguation

All my 'PCL' languages are stack-based.

* **PCL** is also the name of the bytecode language I use for my dynamic language interpreters. There is not connection other than it is also stack-based, and was an inspiration for my static ILs.
* **PCL v7** Used in my previous compiler, and also my C-subset compiler. This one had a broader scope than v8, as detailed below
* **PCL v6** (The v6 is the compiler version; before v6 I didn't use ILs.) v6 was very specific to my language and how its execution model worked. v7 was designed so that it could be used for languages with other characteristic, such as C, or also for small devices, such as 8/16-bit microprocessors.
* **TCL** This is the name of a 3AC-based IL that I have also tried to use. That has some useful characteristics, and it makes some things simpler. But in the end the stack-based version won out.

### v7 versus v8

Up to v7, an IL formed a complete representation of a program. Internally, the IL was one monolithic sequence of instructions, which included declarations for all variables, global and local; functions; and imports.

As an internal data structure, ST (symbol table) entries were linked to PCL instructions.

A v7 program could be dumped in a textual format that formed a fully independent language. A special front-end existed that could take such a source file, and 'compile' it to native code, run it, interpret etc, just like the backend of the full compiler. Or a front-end for a language could potentially write such a source-level PCL file, rather than using the API to synthesise it.

An attractive feature of v7 was that a discrete, standalone backend could be created: either as a dynamic library that provided an API to build to build a PCL program, or an application that that could read textual .pcl files. Both were well under 200KB (ie. 0.2MB), and could turn PCL programs directly into EXEs. Or into DLLs, OBJ, ASM (in two flavours). Or it could run then direct from source. Or it could interpret them.

(The original motivation for creating an IL like this was to see what LLVM would look like if I had a hand in it. Which turns to be 4 magnitudes smaller in scope, 3 magnitudes smaller size, 2 magnitudes faster in compilation speed, and several magnitudes faster in self-build time, while still offering reasonable quality of code.)

However, v7 did not support embedded native code, which could be generated by the inline assembly features of my front-end language. So discrete PCL files were not possible. It only worked when the PCL backend was integrated into the compiler.

v8 was a simplfied version with a reduced instrucion set:

### v8 IL

At first I simplied too much: PCL was only used for code within functions, while other aspects such as STs and type systems were shared between front-end and back-end. But this provided unwieldly, and confusing. A clear demarcation was needed between front-end and back-end. So eventually these where the differences:

* A PCL program is primarily representated by a symbol table that contains the variables and functions. This is distinct from the ST of the front ent
* Executable PCL code only exists for the bodies of functions: each function has its own sequence of PCL instructions
* For initialised variables, the data for each is presented by one or more PCL 'DATA' opcodes; this contains an operand only and is not executable.
* v7 had about 120 distinct opcodes; v8 has about 80. Since many of those are directives or hints, or are codes only used in the front end, that means the active opcodes have been almost halved. (My M front end uses PCL opcodes such as ADD or SQR within its AST, but ones like SQR, part of v7, are lowered to MUL before it gets to the backend. It would need some refactoring to remove those.)

### Inline Assembly and Other Special Features

### BCC C-Subset Compiler

### Z80 Compiler


#### Main IL Instructions:
````
Opcode   Inline   Type  Attrs    Function                Note

LOAD     mem      t              Z' := A                 Push variable to IL stack
         &mem     t              Z' := &A
         int      t              Z' := 123
         real     t              Z' := 123.4
         string   t              Z' := "abc"
         label    t              Z' := L
ILOAD             t              Z' := Z^                Push value at pointer  
ILOADX            t     s, d     Z' := (Y + Z*s + d)^    Complex address load

STORE    mem      t              A := Z                  Pop to variable
ISTORE            t              Z^ := Y                 Pop via pointer
ISTOREX           t     s, d     (Y + Z*s + d)^ := X     Complex address store

ADDPX             t     s, d     Z := Y + Z*s + d        Calc address only

ISWAP             t              swap(Y^, Z^)            Exchange values
CLEAR             t              clear Z^                Set object to zeroes

CALLP    &mem           n, v     &A(...)                 Call proc A with n args; v = variadic
CALLF    &mem     t     n, v     Z' := &A(...)           Call func A with nargs; v = variadic
ICALLP            t     n, v     Z(...)
ICALLF            t     n, v     Z' := Z(...)
RETP                             return                  Return from proc
RETF                    n        return Z+               Return n varues from func

JUMP     label                   goto L
IJUMP                            goto Z                  Z is a label pointer
JUMPCC   label    t     cc pop1  goto L when Y cc Z      Conditional jump
                                                         pop1=1: pop only Z when false
JUMPT    label    t              goto L when Z
JUMPF    label    t              goto L when not Z
JUMPRET  label    t              goto L                  Jump to common return point

SETCC             t              Z' := Y cc Z

ADD               t              Z' := Y + Z
SUB               t              Z' := Y - Z
MUL               t              Z' := Y * Z
DIV               t              Z' := Y / Z             Floating point divide
IDIV              t              Z' := Y % Z             Integer divide
IREM              t              Z' := Y rem Z           Integer remainder
IDIVREM           t              Y', Z' := Y%Z, Y rem Z  Div and remainder together

BITAND            t              Z' := Y iand Z
BITOR             t              Z' := Y ior Z
BITXOR            t              Z' := Y ixor Z
SHL               t              Z' := Y << Z
SHR               t              Z' := Y >> Z
MIN               t              Z' := min(Y, Z)
MAX               t              Z' := max(Y, Z)
POWER             t              Z' := Y ** Z

NEG               t              Z' := -Z
ABS               t              Z' := abs Z
BITNOT            t              Z' := inot Z
NOT               t              Z' := not Z
SQRT              t              Z' := sqrt Z

TOBOOLT           t u            Z' := istrue Z          Z is of type u; result is type t
TOBOOLF           t u            Z' := not Z             Z is of type u; result is type t

MATHS             t     op       Z' := op(Z)             op is a maths function
MATHS2            t     op       Z' := op(Y, Z)

INCRLOAD          t     n        Z' := ++(Z^)            Increment amount is n (can be < 0)
LOADINCR          t     n        Z' := (Z^)++

TYPEPUN           t u            Z' := t(u@(Z^))
FLOAT             t u            Z' := cast(Z, t)        Int (u) to float (t)
FIX               t u            Z' := cast(Z, t)        Float (u) to int (t)
WIDEN             t u            Z' := cast(Z, t)        Widen integer type from u to t
FWIDEN            t u            Z' := cast(Z, t)        Widen float type (r32 to r64)
FNARROW           t u            Z' := cast(Z, t)        Narrow float type (r64 to r32)

JUMPCC   label    t     cc pop1  goto L when Y cc Z      Conditional jump
JUMPRET  label    t              goto L                  Jump to common return point

DUPL                             Y' := Z' := Z           Duplicate top of stack
DOUBLE                           Y' := Z' := Z           Emulate 'dupl' without duplicating
UNLOAD            t              Discard Z
````
#### Data Instruction
This one is used internally to represent static data. This includes jump tables for 'switch':
````
DATA     &mem     t                                      For data only
         int      t
         real     t
         string   t
         label    t
````

#### Hints
The following are hint instructions useful when target is register-based code. Not needed when IL is interpreted, or target is also a stack machine:
````
STARTMX                                                  New resetmx/endmx sequence
RESETMX           t
ENDMX             t

SETCALL                 n                                Start of call sequence with n args
SETARG            t     n                                Mark argument n

LOADALL                                                  Ensure all pcl stack values are pushed
````
#### Directives and Miscellaneous:
````
TYPE              t                                      Auxiliary op following CALLF/ICALLF
NOP                        

COMMENT  string
EVAL
LABEL    label                   L:                       Define label
````

### The PCL API

### Deployment

### Back-End Strategies

