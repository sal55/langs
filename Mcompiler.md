    Source Files  ─┬─> AST1 ─> AST2 ─> AST3 ─┬─> PCL ─> MCL ─┬─> SS ─┬─> EXE Image ─┬─> EXE File
    Support Files ─┤                         │               │       │              │
    Ext Libs      ─┘                         │               │       │              └─> (DLL File)
                                             │               │       └─> MCU ─┬─> MCB ─┬─> ML/EXP Files
                                             │               │                │        │
                                             │               │                │        └─> MX File
                                             │               │                └─> MCX ─> Run
                                             │               └─> ASM
                                             └─> MA File


Key:

* AST1 (also Symbol Table ST, and type tables TT), generated by Parser
* AST2 has all name references resolved (language allows out of order definitions)
* AST3 has types filled in, any conversions applied, and constant expressions reduced
* PCL is the generated IL instructions
* MCL is a representation of the generated native code
* SS is a set of data structures containing binary native code and data, organised
  into code and data segments and with reloc info
* EXE Image is an internal representation of what will go into the EXE file. It will
  also match all imported symbols to a specific DLL
* MCU is the binary code/data/import/reloc info for my private executable format
* MCB is MCU rendered to a flat data block, written out as an ML/MX file
* ML is my private shared library format which takes over DLL tasks until
  real DLL works properly again
* MX is the same format used to write a complete executable. (Needs RUNMX app
  to load and run. In this form it is believed to attract less attention from AV software)
* MCX is MCU with allocations, imports and fixups done to make it ready to run
  in-memory. This allows M applications to be run from source, just like a scripting language.
* ASM is x64 assembly source code, in a syntax used by my own assembler
* An MA file is single-file amalgamation of all source and support files needed to
  build a program. It can be directly compiled by the M compile.
* DLL files are currently disabled, as generated code of this compiler only
  works in low memory, the first 2GB. DLL files can be loaded high.

Inputs:

* Either the lead module of an application, or a .ma file representating the whole app.
  This is the only input specified on the command line
* Standard library sources may be bundled inside the compiler
* Any external libraries are specified in the lead module, and are accessed
  during EXE generation to link each imported symbol to its actual DLL.

ML Files:

These can't quite be used as drop-in replacements for DLLs, as the Windows EXE loader
only automatically deals with actual DLLs. They can be used like this:

* As FFI imports to my Q interpreter, as that can deal with either DLL or ML
* When an application is compiled to .mx rather than .exe, as the special RUN
  launcher needed for MX files will do the special loading needed
* Inside a regular EXE, ML libraries can be accessed by a special API,
  similarly to how LoadLibrary/GetProcAddress are used for DLLs (or dlopen/dlsym
  for .so files)

PCL Language:

This is an internal IL. But two attempts have been made to make it into an
independent language:

* In one form, the M compiler generated a single PCL source file representing
  whole program. A special translator could turn that file into an EXE.

Basically, what LLVM does in turning a an IR program .ll file into an executable, although
that probably generates an object file requiring further tools. My product was a single
0.25MB program (if I write it now, it would be under 0.2MB).

* In another, there was an interpreter for the PCL code, of about 90KB. I think
LLVM also does an interpreter for .ll, but that is proper JIT compiler. In this case
LLVM is a bit more advanced.

But I found that these didn't add a lot to how the M compiler works, and were dropped.
They were just interesting experiments.
