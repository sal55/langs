## M Compiler Structure

The name of the compiler is `MM` or `mm.exe`.

````
    Inputs             Intermediates                                                         Outputs

    Ext Libs      ───>─────────────────────────────────────────────────┐
    Source Files  ─┬─> AST1 ─> AST2 ─┬─> AST3 ─┬─> PCL ─> MCL ─┬─> SS ─┼─> EXE Image ─┬────> EXE File
    Include Files ─┘                 │         │               │       │              │
    Strinclude    ───>───────────────┘         │               │       │              └────> (DLL File)
                                               │               │       └─> MCU ─┬─> MCB ─┬─> ML/EXP File
                                               │               │                │        │
                                               │               │                │        └─> MX File
                                               │               │                └─> MCX ───> (Run)
                                               │               └───────────────────────────> ASM File
                                               └───────────────────────────────────────────> MA File
````

#### Inputs
````
Source Files:     There is only ever one source file submitted to MM. This will usually be the lead module,
                  that also lists other modules of the project.
                  Sometimes, that one input it will be a `.ma` file that contains all source and support files.

Include Files     These are discovered only when parsing all the source files. They are handled by the lexer.

Strinclude Files: (Text files which become string constants.) These are loaded during type analysis.

External Libs:    Any DLL and ML libraries required by the program are listed in the lead module with other project info.
                  These are always dynamically linked, never statically (there is no linker anyway).
````
#### Intermediates
````
AST1          (Also Symbol Table ST, and type tables TT) is generated by the Parser

AST2          Has all name references resolved (language allows out of order definitions so needs this extra pass)

AST3          Has type info filled in, any conversions applied, and constant expressions reduced

PCL           The generated IL (sometimes called IR) instructions from the AST

MCL           A representation of the generated native code, in this case it is for x64.

SS            A set of data structures containing binary native code and data, organised into code and data segments and with reloc info

EXE Image     A an internal representation of what will go into the EXE file.

MCU           The binary code/data/import/reloc info for my private executable format

MCB           MCU rendered to a flat data block, written out as an ML/MX file

MCX           MCU with allocations, imports and fixups done to make it ready to run
              in-memory. This allows M programs be run from source
````
#### Outputs
````
EXE           The Windows executable file format (PE+)

DLL           The Windows shared library format. It is not used at present, as MM can only generate code
              that runs in low memory (first 2GB). ML files are used instead.

ML            My private shared library format which takes over DLL tasks until real DLL works properly again

MX            The same format, used to write a complete executable. (Needs RUNMX app to load and run.
              In this form it is believed to attract less attention from AV software)

EXP           Export files. These are under review, but when generating ML (it was done for DLL too), it also generated an
              import module, which I plan to do for both M and Q languages, which simplify using the library from an M or
              Q application. Just import that generated module.

ASM           x64 assembly source code, in a syntax used by my own assembler `AA`.

MA            A single-file amalgamation of all source and support files needed to build a program.
              It can be directly built by MM to make for a tidy of distributing and building M applications.

OBJ           Object files are not directly generated, only by writing ASM which can generate OBJ files.
              But the code is still limited to the low 2GB, and linkers now like to create programs with a high image base.
              So DLL/OBJ are temporarily out of commission. OBJ files allowed M code to be
              statically linked with other languages.

RUN           Not an output, the program is run immediately without generating any executable file. This allows M to be used
              like a scripting language, running programs directly from source code.

````

#### Compiler Size and Presentation

The core compiler (no diagnostic module, no built-in stdlibs. no ML/MX/RUN support) is currently 307KB. With ML/MX/RUN, it is 317KB. With also the built-in stdlibs (ie. the stardard library source modules which are statically compiled within the compile), then `mm.exe` is a self-contained 382KB solution to build M applications.

In other words, MM is a single 0.4MB blob which, working at 0.5M lines per second, turns most M programs into an executable in a fraction of second (usually, by the time you've released the Enter key). Being instant and effortless is exactly what I'm aiming for; building an app should be like flicking a light switch: it just works.

#### Optimiser

This is not shown, as there isn't a proper one. There is a simpler optimiser that allocates locals to register, and does some peep-hole optimising. This makes some benchmarks and some individual functions faster, but has little effect on real programs. Mainly it makes programs smaller.

It is applied during MCL-generation by doing a second pass on a per-function basis. Without the optimiser, the 317KB core compiler would be 336KB.

The main applications M is used for are compilers, assemblers and interpreters. With those, full optimisation (tested by transpiling to C then using gcc or clang/llvm with `-O3`), might only make them 30-50% faster (that is, 23-33% less runtime). With compilers and assemblers, typical runtimes are only 0.1 seconds anyway.

#### Number of Passes

The normal source -> EXE path has 7 intermediate representations. That sounds a lot. I looked at a 20-year-old compiler, and that had only 3: `AST1 -> AST2 -> MCL`, because there was no separate name resolve pass, and it generated ASM only. MM generating ASM would adds 2 passes.

The binary backend adds two more. But here it can't be directly compared with other compilers if they only go as far as ASM or even stop at LLVM IR.

