## M Compiler Structure

````
    Inputs             Intermediates                                                         Outputs

    Ext Libs      ───>─────────────────────────────────────────────────┐
    Source Files  ─┬─> AST1 ─> AST2 ─┬─> AST3 ─┬─> PCL ─> MCL ─┬─> SS ─┼─> EXE Image ─┬────> EXE File
    Include Files ─┘                 │         │               │       │              │
    Strinclude    ───>───────────────┘         │               │       │              └────> (DLL File)
                                               │               │       └─> MCU ─┬─> MCB ─┬─> ML/EXP File
                                               │               │                │        │
                                               │               │                │        └─> MX File
                                               │               │                └─> MCX ───> (Run)
                                               │               └───────────────────────────> ASM File
                                               └───────────────────────────────────────────> MA File
````

#### Inputs

**Source Files** There is only ever one source file submitted to compiler. This will usually be the lead module, that also contains project info that lists the modules and subprograms that make up the program. Sometimes, that one input it will be a `.ma` files that contains all source and support files.

**Include Files** These are discovered only when parsing all the source files. They are handled by the lexer.

**Strinclude Files** (Text viles which become string constants.) These are loaded using type analysis.

**External Libraries** Any DLL and ML libraries required by the program are listed in the lead module with other project info (or they can be discovered while processing `importdll/lib` FFI blocks, if the library name has a simple connection to the DLL name. They are accessed in the backend to discover which library each imported symbol lives in. This info is necessary in EXE files, but the libraries are not actually used until runtime.

External libraries are never statically linked (there is no linker involved here).

#### Intermediates

**AST1** (also Symbol Table **ST**, and type tables **TT**) is generated by the Parser
**AST2** has all name references resolved (language allows out of order definitions so needs this extra pass)
**AST3** has type info filled in, any conversions applied, and constant expressions reduced
**PCL** is the generated IL instructions from the AST
**MCL** is a representation of the generated native code
*SS** is a set of data structures containing binary native code and data, organised into code and data segments and with reloc info
**EXE Image** is an internal representation of what will go into the EXE file. It will also match all imported symbols to a specific DLL
**MCU** is the binary code/data/import/reloc info for my private executable format
**MCB** is MCU rendered to a flat data block, written out as an ML/MX file
**MCX** is MCU with allocations, imports and fixups done to make it ready to run
  in-memory. This allows M applications to be run from source, just like a scripting language.

#### Outputs

**EXE** is the normal Windows executable file format
**DLL** is Windows shared library format. It is not used at present, as the M compiler can only generate code that runs in low memory (first 2GB). ML files are used instead.
**ML** is my private shared library format which takes over DLL tasks until real DLL works properly again
* MX** is the same format, used to write a complete executable. (Needs RUNMX app to load and run. In this form it is believed to attract less attention from AV software)
**ASM** is x64 assembly source code, in a syntax used by my own assembler
**MA** An MA file is a single-file amalgamation of all source and support files needed to build a program. It can be directly built  by the M compiler.
**OBJ** Object files are not directly generated, only by writing ASM which can generate OBJ files. But the code is still limited to the low 2GB, and linkers now like to create programs with a high image base. So DLL/OBJ are temporarily out of commission. OBJ allowed M code to be statically linked with other languages.

#### ML Files

These can't quite be used as drop-in replacements for DLLs, as the Windows EXE loader
only automatically deals with actual DLLs. They can be used like this:

* As FFI imports to my Q interpreter, as that can deal with either DLL or ML
* When an application is compiled to .mx rather than .exe, as the special RUN launcher needed for MX files will do the special loading needed
* Inside a regular EXE, ML libraries can be accessed by a special API,   similarly to how `LoadLibrary/GetProcAddress` are used for DLLs (or `dlopen/dlsym`
  for .so files)

#### Compiler Size

The core compiler (no diagnostic module, no built-in stdlibs. no ML/MX/RUN support) is currently 307KB. With ML/MX/RUN, it is 317KB.

#### Optimiser

This is not shown, as there isn't one. There is a simpler optimiser allocates locals to register, and does some peep-hole optimising. This makes some benchmarks and some individual functions faster, but has little effect on real programs.

It is done during MCL-generation by doing a second pass on a per-function basis.
