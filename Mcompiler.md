## M Compiler Structure

````
    Inputs             Intermediates                                                         Outputs

    Ext Libs      ───>─────────────────────────────────────────────────┐
    Source Files  ─┬─> AST1 ─> AST2 ─┬─> AST3 ─┬─> PCL ─> MCL ─┬─> SS ─┼─> EXE Image ─┬────> EXE File
    Include Files ─┘                 │         │               │       │              │
    Strinclude    ───>───────────────┘         │               │       │              └────> (DLL File)
                                               │               │       └─> MCU ─┬─> MCB ─┬─> ML/EXP File
                                               │               │                │        │
                                               │               │                │        └─> MX File
                                               │               │                └─> MCX ───> (Run)
                                               │               └───────────────────────────> ASM File
                                               └───────────────────────────────────────────> MA File
````

#### Inputs
````
Source Files:     There is only ever one source file submitted to the compiler. This will usually be the lead module,
                  that also lists other module other modules of the project.
                  Sometimes, that one input it will be a `.ma` file that contains all source and support files.

Include Files     These are discovered only when parsing all the source files. They are handled by the lexer.

Strinclude Files: (Text files which become string constants.) These are loaded during type analysis.

External Libs:    Any DLL and ML libraries required by the program are listed in the lead module with other project info.
                  These are always dynamically linked, never statically (there is no linker anyway).
````
#### Intermediates
````
AST1          (Also Symbol Table ST, and type tables TT) is generated by the Parser

AST2          Has all name references resolved (language allows out of order definitions so needs this extra pass)

AST3          Has type info filled in, any conversions applied, and constant expressions reduced

PCL           The generated IL instructions from the AST

MCL           A representation of the generated native code

SS            A set of data structures containing binary native code and data, organised into code and data segments and with reloc info

EXE Image     A an internal representation of what will go into the EXE file.

MCU           The binary code/data/import/reloc info for my private executable format

MCB           MCU rendered to a flat data block, written out as an ML/MX file

MCX           MCU with allocations, imports and fixups done to make it ready to run
              in-memory. This allows M programs be run from source
````
#### Outputs
````
MCX           MCU with 

EXE           The Windows executable file format (PE+)

DLL           The Windows shared library format. It is not used at present, as the M
              compiler can only generate code that runs in low memory (first 2GB).
              ML files are used instead.

ML            My private shared library format which takes over DLL tasks until real DLL works properly again

MX            The same format, used to write a complete executable. (Needs RUNMX app to load and run.
              In this form it is believed to attract less attention from AV software)

ASM           x64 assembly source code, in a syntax used by my own assembler

MA            A a single-file amalgamation of all source and support files needed to build a program.
              It can be directly built  by the M compiler.

OBJ           Object files are not directly generated, only by writing ASM which can generate OBJ files.
              But the code is still limited to the low 2GB, and linkers now like to create programs with a high image base.
              So DLL/OBJ are temporarily out of commission. OBJ files allowed M code to be
              statically linked with other languages.
````

#### ML Files

These can't quite be used as drop-in replacements for DLLs, as the Windows EXE loader
only automatically deals with actual DLLs. They can be used like this:

* As FFI imports to my Q interpreter, as that can deal with either DLL or ML
* When an application is compiled to .mx rather than .exe, as the special RUN launcher needed for MX files will do the special loading needed
* Inside a regular EXE, ML libraries can be accessed by a special API,  similarly to how `LoadLibrary/GetProcAddress` are used for DLLs (or `dlopen/dlsym`
  for .so files)

#### Compiler Size

The core compiler (no diagnostic module, no built-in stdlibs. no ML/MX/RUN support) is currently 307KB. With ML/MX/RUN, it is 317KB. With also the built-in stdlibs (ie. the stardard library source modules which are statically compiled with an application), the M compiler is a self-contained 382KB solution in one file.

#### Optimiser

This is not shown, as there isn't a proper one. There is a simpler optimiser that allocates locals to register, and does some peep-hole optimising. This makes some benchmarks and some individual functions faster, but has little effect on real programs. Mainly it makes programs smaller.

It is applied during MCL-generation by doing a second pass on a per-function basis. Without the optimiser, the 317KB core compiler would be 336KB.
