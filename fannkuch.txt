# "Fannkuch" Benchmark from:
#  https://benchmarksgame-team.pages.debian.net/benchmarksgame/description/fannkuchredux.html#fannkuchredux

# ***********************************************************************************************
# M Language giving the reference algorithm. (Other versions will mostly use this same algorithm, not the
# ***********************************************************************************************
# ones in the Shootout site.)

function fannkuch(int n)int,int=
    int signx,maxflips,sum
    int i,j,k
    int q1,flips,qq,t,sx,tt
    [100]int p,q,s

    signx:=1
    maxflips:=0
    sum:=0

    for i:=1 to n do
        p[i]:=i
        q[i]:=i
        s[i]:=i
    od

    do

        q1:=p[1]
        if q1<>1 then
            for i:=2 to n do q[i]:=p[i] od
            flips:=1
            do
                qq:=q[q1]
                if qq=1 then
                    sum+:=signx*flips
                    if flips>maxflips then
                            maxflips:=flips
                    fi
                    exit
                fi
                q[q1]:=q1
                if q1>=4 then
                    i:=2; j:=q1-1
                    repeat
                        swap(q[i],q[j])
                        ++i
                        --j
                    until i>=j
                fi
                q1:=qq
                ++flips
            od
        fi

        if signx=1 then
            swap(p[2],p[1])
            signx:=-1
        else
            swap(p[2],p[3])
            signx:=1
            for i:=3 to n do
                sx:=s[i]
                if sx<>1 then s[i]:=sx-1; exit fi
                if i=n then
                    return (sum,maxflips)
                fi
                s[i]:=i
                tt:=p[1]

                for j:=1 to i do
                    p[j]:=p[j+1]
                od

                p[i+1]:=tt
            od
        fi
    od

    return (0,0)
end

proc start=
    int res,res2
    const n = 11

    (res,res2):=fannkuch(n)

    fprintln "Pfannkuchen(#) = # #", n, res, res2
end

# ***********************************************************************************************
# Go Language version
# ***********************************************************************************************

package main

import (
    "fmt"
)

var res2 int

func fann1(n int)int {
    sign:=1
    maxflips:=0
    sum:=0
    i:=0
    j:=0
    q1:=0
    flips:=0
    qq:=0
    t:=0
    sx:=0

    p     := make([]int, n+1)
    q     := make([]int, n+1)
    s     := make([]int, n+1)

    for i := 1; i<=n; i++ {
        p[i] = i
        q[i] = i
        s[i] = i
    }

    for ;; {
        q1=p[1]
        if q1!=1 {
            for i=2; i<=n; i+=1 {
                q[i]=p[i]
            }
            flips=1
            for ;; {
                qq=q[q1]
                if qq==1 {
                    sum=sum+sign*flips
                    if flips>maxflips {
                        maxflips=flips
                    }
                    break
                }
                q[q1]=q1
                if q1>=4 {
                    i=2
                    j=q1-1
                    for ;; {
                        t=q[i]
                        q[i]=q[j]
                        q[j]=t
                        i=i+1
                        j=j-1
                        if i>=j {
                            break
                        }
                    }
                }
                q1=qq
                flips=flips+1
            }
        }

        if sign==1 {
            t=p[2]
            p[2]=p[1]
            p[1]=t
            sign=-1
        } else {
            t=p[2]
            p[2]=p[3]
            p[3]=t
            sign=1
            for i=3; i<=n; i+=1 {
                sx=s[i]
                if sx!=1 {
                    s[i]=sx-1
                    break
                }
                if i==n {
                    res2=maxflips
                    return sum
                }
                s[i]=i
                t=p[1]
                for j=1; j<=i; j+=1 {
                    p[j]=p[j+1]
                }
                p[i+1]=t
            }
        }
    }

    return 0
}

func main() {

    n:=11

    fmt.Printf("Pfannkuchen(%d) = %d %d\n", n, fann1(n), res2)
}

# ***********************************************************************************************
# Lua Version - this one is from that site as it seems to use my algorith (or possibly this is what
# I derived mine from; I can't remember!)
# ***********************************************************************************************
-- The Computer Language Benchmarks Game
-- http://benchmarksgame.alioth.debian.org/
-- contributed by Mike Pall

local function fannkuch(n)
  local p, q, s, sign, maxflips, sum = {}, {}, {}, 1, 0, 0
  for i=1,n do p[i] = i; q[i] = i; s[i] = i end
  repeat
    -- Copy and flip.
    local q1 = p[1]       -- Cache 1st element.
    if q1 ~= 1 then
      for i=2,n do q[i] = p[i] end    -- Work on a copy.
      local flips = 1
      repeat
  local qq = q[q1]
  if qq == 1 then       -- ... until 1st element is 1.
    sum = sum + sign*flips
    if flips > maxflips then maxflips = flips end -- New maximum?
    break
  end
  q[q1] = q1
  if q1 >= 4 then
    local i, j = 2, q1 - 1
    repeat q[i], q[j] = q[j], q[i]; i = i + 1; j = j - 1; until i >= j
  end
  q1 = qq; flips = flips + 1
      until false
    end
    -- Permute.
    if sign == 1 then
      p[2], p[1] = p[1], p[2]; sign = -1  -- Rotate 1<-2.
    else
      p[2], p[3] = p[3], p[2]; sign = 1   -- Rotate 1<-2 and 1<-2<-3.
      for i=3,n do
  local sx = s[i]
  if sx ~= 1 then s[i] = sx-1; break end
  if i == n then return sum, maxflips end -- Out of permutations.
  s[i] = i
  -- Rotate 1<-...<-i+1.
  local t = p[1]; for j=1,i do p[j] = p[j+1] end; p[i+1] = t
      end
    end
  until false
end

local n = 11
-- local
sum, flips = fannkuch(n)
io.write(sum, "\nPfannkuchen(", n, ") = ", flips, "\n")

# ***********************************************************************************************
# Python version
# ***********************************************************************************************

def fannkuch(n):
    p=[0,]*(n+1)
    q=[0,]*(n+1)
    s=[0,]*(n+1)
    signx=1
    maxflips=0
    sum=0
    for i in range(1,n+1):
        p[i]=i
        q[i]=i
        s[i]=i
    while 1:
        q1=p[1]
        if q1!=1:
            for i in range(2,n+1):
                q[i]=p[i]
            flips=1
            while 1:
                qq=q[q1]
                if qq==1:
                    sum=sum+signx*flips
                    if flips>maxflips: maxflips=flips
                    break
                q[q1]=q1
                if q1>=4:
                    i=2
                    j=q1-1
                    while 1:
                        t=q[i]
                        q[i]=q[j]
                        q[j]=t
                        i=i+1
                        j=j-1
                        if i>=j: break
                q1=qq
                flips=flips+1

        if signx==1:
            t=p[2]
            p[2]=p[1]
            p[1]=t
            signx=-1
        else:
            t=p[2]
            p[2]=p[3]
            p[3]=t
            signx=1
            for i in range(3,n+1):
                sx=s[i]
                if sx!=1:
                    s[i]=sx-1
                    break
                if i==n: return [sum,maxflips]
                s[i]=i
                t=p[1]
                for j in range(1,i+1):
                    p[j]=p[j+1]
                p[i+1]=t


n=11
x=fannkuch(n)

print ("Pfannkuchen(",n,")=",x[0],x[1])

# ***********************************************************************************************
# Ruby version
# ***********************************************************************************************

def fannkuch(n):
    p=[0,]*(n+1)
    q=[0,]*(n+1)
    s=[0,]*(n+1)
    signx=1
    maxflips=0
    sum=0
    for i in range(1,n+1):
        p[i]=i
        q[i]=i
        s[i]=i
    while 1:
        q1=p[1]
        if q1!=1:
            for i in range(2,n+1):
                q[i]=p[i]
            flips=1
            while 1:
                qq=q[q1]
                if qq==1:
                    sum=sum+signx*flips
                    if flips>maxflips: maxflips=flips
                    break
                q[q1]=q1
                if q1>=4:
                    i=2
                    j=q1-1
                    while 1:
                        t=q[i]
                        q[i]=q[j]
                        q[j]=t
                        i=i+1
                        j=j-1
                        if i>=j: break
                q1=qq
                flips=flips+1

        if signx==1:
            t=p[2]
            p[2]=p[1]
            p[1]=t
            signx=-1
        else:
            t=p[2]
            p[2]=p[3]
            p[3]=t
            signx=1
            for i in range(3,n+1):
                sx=s[i]
                if sx!=1:
                    s[i]=sx-1
                    break
                if i==n: return [sum,maxflips]
                s[i]=i
                t=p[1]
                for j in range(1,i+1):
                    p[j]=p[j+1]
                p[i+1]=t


n=5
x=fannkuch(n)

print ("Pfannkuchen(",n,")=",x[0],x[1])

# ***********************************************************************************************
# C version (derived from machine-transpiled version)
# ***********************************************************************************************

def fannkuch(n):
    p=[0,]*(n+1)
    q=[0,]*(n+1)
    s=[0,]*(n+1)
    signx=1
    maxflips=0
    sum=0
    for i in range(1,n+1):
        p[i]=i
        q[i]=i
        s[i]=i
    while 1:
        q1=p[1]
        if q1!=1:
            for i in range(2,n+1):
                q[i]=p[i]
            flips=1
            while 1:
                qq=q[q1]
                if qq==1:
                    sum=sum+signx*flips
                    if flips>maxflips: maxflips=flips
                    break
                q[q1]=q1
                if q1>=4:
                    i=2
                    j=q1-1
                    while 1:
                        t=q[i]
                        q[i]=q[j]
                        q[j]=t
                        i=i+1
                        j=j-1
                        if i>=j: break
                q1=qq
                flips=flips+1

        if signx==1:
            t=p[2]
            p[2]=p[1]
            p[1]=t
            signx=-1
        else:
            t=p[2]
            p[2]=p[3]
            p[3]=t
            signx=1
            for i in range(3,n+1):
                sx=s[i]
                if sx!=1:
                    s[i]=sx-1
                    break
                if i==n: return [sum,maxflips]
                s[i]=i
                t=p[1]
                for j in range(1,i+1):
                    p[j]=p[j+1]
                p[i+1]=t


n=5
x=fannkuch(n)

print ("Pfannkuchen(",n,")=",x[0],x[1])
# ***********************************************************************************************


# ***********************************************************************************************
# Julia version
# ***********************************************************************************************

function fannkuch(n::Int64)
    p=[0,0,0,0,0, 0,0,0,0,0, 0]
    q=[0,0,0,0,0, 0,0,0,0,0, 0]
    s=[0,0,0,0,0, 0,0,0,0,0, 0]

    sign=1
    maxflips=0
    sum=0

    for i=1:n
        p[i]=i
        q[i]=i
        s[i]=i
    end

    while true
        q1=p[1]
        if q1!=1
            for i=2:n
                q[i]=p[i]
            end
            flips=1
            
            while true
                qq=q[q1]
                if qq==1
                    sum=sum+sign*flips
                    if flips>maxflips
                        maxflips=flips
                    end
                    break
                end
                q[q1]=q1
                if q1>=4
                    i=2
                    j=q1-1
                    while true
                        temp=q[i]
                        q[i]=q[j]
                        q[j]=temp
                        i=i+1
                        j=j-1
                        if i>=j
                            break
                        end
                    end
                end
                q1=qq
                flips=flips+1
            end
        end

        if sign==1
            temp=p[2]
            p[2]=p[1]
            p[1]=temp
            sign=-1
        else
            temp=p[2]
            p[2]=p[3]
            p[3]=temp
            sign=1
            for i=3:n
                sx=s[i]
                if sx!=1
                    s[i]=sx-1
                    break
                end
                if i==n
                    return (sum,maxflips)
                end
                s[i]=i
                tt=p[1]

                for j=1:i
                    p[j]=p[j+1]
                end

                p[i+1]=tt
            end
        end
    end

    return 0
end

println(fannkuch(11))

# ***********************************************************************************************
# Rust version
# ***********************************************************************************************
fn fannkuch(n:i32)->(i32,i32) {
    let mut sign:i32=1;
    let mut maxflips:i32=0;
    let mut sum:i32=0;
    let mut i:i32;
    let mut j:i32;
    let mut q1:i32;
    let mut qq:i32;
    let mut t:i32;
    let mut sx:i32;
    let mut flips:i32;
    let mut p:[i32;20]=[0;20];
    let mut q:[i32;20]=[0;20];
    let mut s:[i32;20]=[0;20];

    for i in 1..=n {
        p[i as usize] = i;
        q[i as usize] = i;
        s[i as usize] = i;
    }
    
    loop {
        
        q1=p[1];
        if q1!=1 {
            for i in 2..=n { q[i as usize] = p[i as usize]; }
            flips=1;
            loop {
                qq=q[q1 as usize];
                if qq==1 {
                    sum=sum+sign*flips;
                    if flips>maxflips {
                        maxflips=flips;
                    }
                    break;
                }
                q[q1 as usize]=q1;
                if q1>=4 {
                    i=2; j=q1-1;
                    loop {
                        t=q[i as usize];
                        q[i as usize]=q[j as usize];
                        q[j as usize]=t;
                        i=i+1;
                        j=j-1;
                        if i>=j {break;}
                    }
                }
                q1=qq;
                flips=flips+1;
            }
        }
        
        
        if sign==1 {
            t=p[2]; p[2]=p[1]; p[1]=t;
            sign=-1;
        } else {
            t=p[2]; p[2]=p[3]; p[3]=t;
            sign=1;
            for i in 3..=n {
                sx=s[i as usize];
                if sx!=1 {s[i as usize]=sx-1; break; }
                if i==n {
                    return (sum, maxflips);
                }
                s[i as usize]=i;
                t=p[1];
                for j in 1..=i {
                    p[j as usize] = p[(j+1) as usize];
                }
                p[(i+1) as usize]=t;
            }
        }
    }
    
}

fn main() {
    let n:i32 = 11;
    
    let (res,res2)=fannkuch(n);
    
    println!("Fannkuch({}) ={} {}", n,res, res2);
}
# ***********************************************************************************************

# ***********************************************************************************************

