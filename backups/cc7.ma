=== MA 108 ===
=== cc.m 0 0 1/108 ===
project =
    module cc_cli

!Global Data and Tables

    module cc_decls
    module cc_tables

!Lexing and Parsing
    module cc_lex
    module cc_parse

!Generate PCL
    module cc_genpcl
    module cc_blockpcl
    module cc_libpcl

!General

    module cc_lib
    module cc_support

!Bundled headers

    module cc_headers
!   module cc_headersx

!Diagnostics
    module cc_show
!    module cc_showdummy

!IL Backend
    $sourcepath "c:/mx/"
    import pcl
!   import pclint

end


=== ccgas.m 0 0 2/108 ===
project =
    module cc_cli

!Global Data and Tables

    module cc_decls
    module cc_tables

!Lexing and Parsing
    module cc_lex
    module cc_parse

!Generate PCL
    module cc_genpcl
    module cc_blockpcl
    module cc_libpcl

!General

    module cc_lib
    module cc_support

!Bundled headers

!   module cc_headers
   module cc_headersx

!Diagnostics
    module cc_show
!    module cc_showdummy

!IL Backend
    $sourcepath "c:/mx/"
!    import pcl
    import pepcl
!   import pclint

end
=== cci.m 0 0 3/108 ===
project =
    module cc_cli

!Global Data and Tables

    module cc_decls
    module cc_tables

!Lexing and Parsing
    module cc_lex
    module cc_parse

!Generate PCL
    module cc_genpcl
    module cc_blockpcl
    module cc_libpcl

!General

    module cc_lib
    module cc_support

!Bundled headers

!    module cc_headers
   module cc_headersx

!Diagnostics
!    module cc_show
    module cc_showdummy

!IL Backend
    $sourcepath "c:/mx/"
!    import pcl
   import pclint
end
=== ccp.m 0 0 4/108 ===
project =
    module cc_cli

!Global Data and Tables

    module cc_decls
    module cc_tables

!Lexing and Parsing
    module cc_lex
    module cc_parse

!Generate PCL
    module cc_genpcl
    module cc_blockpcl
    module cc_libpcl

!General

    module cc_lib
    module cc_support

!Bundled headers

    module cc_headers
!   module cc_headersx

!Diagnostics
!    module cc_show
    module cc_showdummy

!IL Backend
    $sourcepath "c:/mx/"
    import pclp
!    import pclint
end
=== cc_blockmcl.m 0 0 5/108 ===
!M Compiler - x64 Target Code Generator 2
!import main

const kjumpt = 1		!pseudo ops used for conditional jump logic
const kjumpf = 0

const tintptr=tullong

GLOBAL INT NADDTO
GLOBAL INT NADDTOX

[maxnestedloops]int continuestack		!labels for continue/break
[maxnestedloops]int breakstack
int loopindex							!current level of nested loop/switch blocks

const maxparams=200

const maxswitchrange=500
const maxcases=maxswitchrange
const maxswitchdepth=20

ref[]int sw_labeltable			!set from do-switch
ref[]int sw_valuetable
int sw_lower
int sw_ncases					!1..n for serial switch; 0 for simple
byte sw_defaultseen				!starts at 0, set to 1 when default: seen
int sw_defaultlabel
int sw_breaklabel

int maxreg=0

global proc do_stmt(unit p) =
int oldclineno,value,i
unit a,b
!ref opndrec rx,ax,bx,lhs,rhs
ref strec d
[256]char str

if p=nil then
	return
fi

!CPL "STMT",jtagnames[p.tag],p.lineno

oldclineno:=clineno
clineno:=p.fileno<<24+p.lineno

!CPL "DOSTMT",CLINENO

!SPRINTF(&STR,"%d",p.lineno)
!GENCOMMENT(&STR)

a:=p.a
b:=p.b

!gentc(t_stmt)

switch p.tag
when j_block then
	while a do
		do_stmt(a)
		a:=a.nextunit
	od

when j_decl then
	do_decl(p.def)

when j_callfn then
	dx_call(p,a,b,r0)

when j_return then
	do_return(a)

when j_assign then
	do_assign(a,b)

when j_if then
	do_if(a,b,p.c)

when j_for then
	do_for(a,b)

when j_while then
	do_while(a,b)
!
when j_dowhile then
	do_dowhile(a,b)
!
when j_goto then
	do_goto(p.def)

when j_labelstmt then
	do_labeldef(p.def)
	do_stmt(a)
!
when j_casestmt then

!	sprintf(&.str,"case %d:",int32(p.index))
	fprint @&.str,"case",p.index,,":"

	gencomment(pcm_copyheapstring(&.str))
	if sw_ncases=0 then
!		genmc(m_label,genlabel(sw_labeltable^[p.uindex-sw_lower+1]))
		genmc(m_label,genlabel(sw_labeltable^[p.value-sw_lower+1]))
	else
!		value:=p.uindex
		value:=p.value
		for i:=1 to sw_ncases do
			if sw_valuetable^[i]=value then
				genmc(m_label,genlabel(sw_labeltable^[i]))
				exit
			fi
		else
			gerror("case: serial switch not found")
		od
	fi
	do_stmt(a)

when j_defaultstmt then
	sw_defaultseen:=1
	gencomment("default:")
	genmc(m_label,genlabel(sw_defaultlabel))
	do_stmt(a)

when j_breaksw then
	genjumpl(sw_breaklabel)

when j_break then
	genjumpl(breakstack[loopindex])

when j_continue then
	genjumpl(continuestack[loopindex])

when j_switch then
	do_switch(p,a,b)
!
when j_addto then
++NADDTO
	dx_addto(m_add,a,b,0)

when j_subto then
++NADDTO
	dx_addto(m_sub,a,b,0)

when j_multo then
++NADDTO
	dx_multo(a,b,0)
!
when j_divto,j_remto then
++NADDTO
	dx_divto(p,a,b,0)
!
when j_iandto then
++NADDTO
	dx_addto(m_and,a,b,0)

when j_iorto then
++NADDTO
	dx_addto(m_or,a,b,0)

when j_ixorto then
++NADDTO
	dx_addto(m_xor,a,b,0)

when j_shlto, j_shrto then
++NADDTO
	dx_shlto(p,a,b,0)

when j_preincr, j_postincr then
	do_preincr(a,m_add,m_inc)

when j_predecr, j_postdecr then
	do_preincr(a,m_sub,m_dec)


!
!when j_null then
!	gerror("stmt/null")
!
when j_exprlist then
	do_exprlist(a)

else
!assume standalone expression (assign/call/addto/incr done above)

!CPL "LONE",=FSHOWNAMES
	if p.tag<>j_const or not fshownames then
		loneexpr(p)
	fi

end switch

!clineno:=oldclineno
end

function dx_expr(unit p, int reg=r0,am=1)ref opndrec =
int oldclineno,value,i,m
unit a,b
ref opndrec rx,ax,bx,lhs,rhs,tx
[256]char str
!ref strbuffer ex
ref strec d

if p=nil then
	return nil
fi

!CPL "EXPR",jtagnames[p.tag],p.lineno

if reg>r8 and reg<r10 then
	CPL "DOEXPR TOO MANY REGS?"
fi

oldclineno:=clineno
clineno:=p.fileno<<24+p.lineno
tx:=nil
!SPRINTF(&STR,"%d",p.lineno)
!GENCOMMENT(&STR)

a:=p.a
b:=p.b
m:=p.mode

switch p.tag
when j_const then
	return dx_const(p,reg)

when j_name then
	return dx_name(p,reg,am)

!when j_nameaddr then
!	d:=p.def
!	if isstructunion(tttarget[m]) then				!block
!		rx:=genreg(reg,ptrsize)
!		if d.nameid=paramid then					!pointer to block
!			genmc(m_mov,rx,genmem_u(p))
!		else										!just a block
!			genmc(m_lea,rx,genmem_u(p))
!		fi
!		return rx
!
!	else
!		return dx_nameaddr(p,d,reg)
!	fi
!
when j_widenmem then
	return dx_widen(a,m,reg)

when j_funcname then
	return genmemaddr_u(p)

when j_assign then
	return dx_assign(a,b,reg)
!
when j_andl,j_orl then
	return dx_andorl(p,reg)		!use non-short circuit versions for now

when j_notl then
	return dx_notl(a,reg)

when j_istruel then
	return dx_istruel(a,reg)

when j_exprlist then
	return dx_exprlist(a,reg)

when j_callfn then
	return dx_call(p,a,b,reg)

when j_ifx then
	return dx_ifx(a,b,p.c,reg)

when j_eq,j_ne,j_lt,j_le,j_ge,j_gt then
	return dx_eq(p,a,b,reg)
!
when j_add then
	if ttisref[a.mode] and ttsize[b.mode]<=4 then
		b.mode:=tintptr
	fi
	return dx_add(a,b,reg)

when j_sub then
	return dx_sub(a,b,reg)

when j_mul then
	return dx_mul(p,a,b,reg)
!
when j_div then
	return dx_div(p,a,b,reg)

when j_rem then
	return dx_rem(p,a,b,reg)
!
when j_iand then
	return dx_iand(m_and,a,b,reg)

when j_ior then
	return dx_iand(m_or,a,b,reg)

when j_ixor then
	return dx_iand(m_xor,a,b,reg)

when j_shl,j_shr then
	return dx_shl(p,a,b,reg)

when j_ptr then
	return dx_ptr(p,a,reg,am)

!when j_ptroffset then
!	tx:=dx_ptroffset(p,a,b,p.c, 0, reg)

when  j_addptr then
	return dx_addptr(p,a,b, reg, am)

when  j_subptr then
	return dx_subptr(a,b, reg, am)

when j_convert then
	if m=tvoid then
		return evalexpr(a,reg)
	else
		return dx_convert(a,m, p.opcode, reg)
	fi

when j_scale then
	return dx_scale(p,a,b,reg)

when j_neg then
    return dx_neg(a,reg)

when j_inot then
	return dx_inot(a,reg)
!
when j_preincr, j_predecr then
	return dx_preincrx(p,a,reg)

when j_postincr, j_postdecr then
	return dx_postincrx(p,a,reg)

when j_addto then
++NADDTOX
	return dx_addto(m_add,a,b,reg)

when j_subto then
++NADDTOX
	return dx_addto(m_sub,a,b,reg)

when j_multo then
++NADDTOX
	return dx_multo(a,b,reg)

when j_divto, j_remto then
++NADDTOX
	return dx_divto(p,a,b,reg)

when j_iandto then
++NADDTOX
	return dx_addto(m_and,a,b,reg)

when j_iorto then
++NADDTOX
	return dx_addto(m_or,a,b,reg)

when j_ixorto then
++NADDTOX
	return dx_addto(m_xor,a,b,reg)

when j_shlto, j_shrto then
++NADDTOX
	return dx_shlto(p,a,b,reg)
!
when j_sqrt then
	return dx_sqrt(a,reg)

when j_addrof then
	return dx_addrof(p,a,reg,am)

when j_dot then
	return dx_dot(p,a,b,reg,am)

else
	gerror_s("DX-EXPR: can't do tag: %s",jtagnames[p.tag])
end switch

if tx=nil then
	GERROR_S("DX-EXPR: NO RESULT: %s",JTAGNAMES[P.TAG])
fi

clineno:=oldclineno
return tx
end

proc loneexpr(unit p)=
if p and p.tag<>j_null then
	loadexpr(p)
fi
end

proc do_assign(unit a,b)=
ref opndrec lhs,rhs
int reg,tx

case ttsize[a.mode]
when 1,2,4,8 then
else
!CPL "BLOCK ASS"
	do_assignblock(a,b)
	return
esac
reg:=r0

!CPL =ISSIMPLE(A)
!CPL =ISSIMPLE(B)

if issimple(a) then
	if issimple(b) then			!simple:=simple
		lhs:=getlvalueopnd(a,reg)
		if isintconst(b) then
			rhs:=evalexpr(b,getnextreg(lhs,reg))
		else
			rhs:=loadexpr(b,getnextreg(lhs,reg),isassign:1)
		fi
	else					!simple:=complex
		rhs:=loadexpr(b,reg,isassign:1)
		lhs:=getlvalueopnd(a,getnextreg(rhs,reg))
	fi
else
	if issimple(b) then			!complex:=simple
		lhs:=getlvalueopnd(a,reg)
		rhs:=loadexpr(b,getnextreg(lhs,reg	),isassign:1)
	else					!complex:=complex
!CPL "ASSIGN CX/CX"
		tx:=saveexpr(b,r0)
		lhs:=getlvalueopnd(a,r0)
!		rhs:=restoreexpr(tx,r0+getaregs(lhs))
		rhs:=restoreexpr(tx,getnextreg(lhs,reg))
	fi
fi
storeopnd(lhs,rhs)
end

function dx_assign(unit a,b,int reg)ref opndrec =
ref opndrec lhs,rhs,rx,ax,bx
int tx

!CPL "DXASSIGN"

case ttsize[a.mode]
when 1,2,4,8 then
else
	return do_assignblock(a,b,reg)
esac

if issimple(a) then
	if issimple(b) then			!simple:=simple
		lhs:=getlvalueopnd(a,reg)
		rhs:=loadexpr(b,getnextreg(lhs,reg),isassign:1)
		storeopnd(lhs,rhs)		!might be upgraded to m_fstore
	else					!simple:=complex
		rhs:=loadexpr(b,reg,isassign:1)
		lhs:=getlvalueopnd(a,getnextreg(rhs,reg))
		storeopnd(lhs,rhs)
	fi
else
	if issimple(b) then			!complex:=simple
		lhs:=getlvalueopnd(a,reg)
		rhs:=loadexpr(b,getnextreg(lhs,reg),isassign:1)
		storeopnd(lhs,rhs)
	else					!complex:=complex
		tx:=saveexpr(b,r0)
		ax:=getlvalueopnd(a,r0)
!		bx:=restoreexpr(tx,r0+getaregs(ax))
		bx:=restoreexpr(tx,getnextreg(ax,reg))
		storeopnd(ax,bx)
		rhs:=bx
	fi
fi

case rhs.mode
when a_reg then
	if rhs.reg<>reg then
		rx:=genreg(reg,rhs.size)
		genmc(m_mov,rx,rhs)
		return rx
	fi
when a_xreg then
	if rhs.reg<>reg then
		rx:=genxreg(reg,rhs.size)
		genmc(m_fmov,rx,rhs)
		return rx
	fi
esac
return rhs
end

function saveexpr(unit a,int reg=r0)int=
!for now, just push to stack, and return size
pushexpr(a,reg)
return ttsize[a.mode]
end

function fsaveexpr(unit a,int reg=xr0)int=
!for now, just push to stack, and return size
fpushexpr(a,reg)
return ttsize[a.mode]
end

function restoreexpr(int tx, reg)ref opndrec=
!for now, tx is just the size
ref opndrec rx

genmc(m_pop,rx:=genreg(reg,targetsize))		!register must be full size
rx:=duplopnd(rx)
rx.size:=tx
return rx
end

function frestoreexpr(int tx, reg)ref opndrec=
!for now, tx is just the size
ref opndrec rx

genmc(m_pop,rx:=genxreg(reg,tx))		!register must be full size
rx:=duplopnd(rx)
rx.size:=tx
return rx
end

function getlvalueopnd (unit a,int reg=r0)ref opndrec=
return evalexpr(a,reg)
end

proc storeopnd(ref opndrec ax,bx)=
!ax is a memory operand, bx is a register operand
!store bx to ax
!note that bx miht refer to an xmm register

if bx.mode=a_xreg then
	genmc(m_fmov,ax,bx)
else
	case ax.size
	when 1,2,4 then
		bx:=changeopndsize(bx,ax.size)
	esac
	genmc(m_mov,ax,bx)
fi
end

proc pushexpr(unit a,int reg=r0)=
ref opndrec ax

if a then
	ax:=dx_expr(a,reg)
	genmc(m_push,ax)
else
	genmc(m_push,zero_opnd)
fi
end

proc fpushexpr(unit a,int reg=xr0)=
ref opndrec ax

ax:=dx_expr(a,reg)
genmc(m_push,ax)
end

function dx_const(unit p, int reg)ref opndrec=
ref opndrec ax
int t

if (t:=ttbasetype[p.mode])>=tfirstint and t<=tlastint then
	return genint(p.value,ttsize[p.mode])

elsif t>=tfirstreal and t<=tlastreal then
	ax:=genreal(p.xvalue,ttsize[p.mode])
	return ax

elsif t=tref then
	if p.isstrconst then
		return genstrimm(p.svalue,p.slength)
	elsif p.iswstrconst then
		return genwstrimm(p.wsvalue,p.wslength)

	fi
	return genint(p.value,ptrsize)
fi
gerror_s("dxconst %s",Strmode(p.mode))

return ax
end

function dx_constant(ref strec d, int reg)ref opndrec=
ref opndrec ax
int t

if (t:=ttbasetype[d.mode])>=tfirstint and t<=tlastint then
	return genint(d.code.value,ttsize[d.mode])

elsif t>=tfirstreal and t<=tlastreal then
	ax:=genreal(d.code.xvalue,ttsize[d.mode])
	return ax
fi
gerror_s("dxconstant %s",Strmode(d.mode))

return ax
end

proc do_labeldef(ref strec d)=
genmc(m_label,genlabel(d.index),genmemaddr_d(d))
end

proc do_goto(ref strec d)=
if d.index=0 then
	gerror_s("Label not defined: %s",d.name)
fi
genmc(m_jmp,genlabel(d.index))
end

function dx_add(unit a,b,int reg)ref opndrec=
	ref opndrec ax,bx
	int tx

	if gettypecat(a)='R' then
		return dx_fadd(m_add,a,b,reg)
	fi

	if issimple(b) then
		ax:=loadexpr(a,reg)
		bx:=evalexpr(b,getnextreg(ax,reg))

	elsif issimple(a) then	!reverse order
		ax:=loadexpr(b,reg)
		bx:=evalexpr(a,getnextreg(ax,reg))

	else
		tx:=saveexpr(a,reg)
		ax:=loadexpr(b,reg)
		bx:=restoreexpr(tx,getnextreg(ax,reg))
	fi

	genmc(m_add,ax,bx)

	return ax
end

function dx_fadd(int opc,unit a,b,int reg)ref opndrec=
ref opndrec ax,bx
int tx

if issimple(b) then
	ax:=floadexpr(a,reg)
	if opc=m_imul and a.tag=j_name and b.tag=j_name and a.def=b.def then
!CPL "FLOAT/SQR DETECTED"
		bx:=ax
	else
!		bx:=fevalexpr(b,reg+getlregs(ax))
		bx:=fevalexpr(b,getnextreg(ax,reg))
	fi
elsif issimple(a) and (opc=m_add or opc=m_imul) then	!reverse order
	ax:=floadexpr(b,reg)
!	bx:=fevalexpr(a,reg+getlregs(ax))
	bx:=fevalexpr(a,getnextreg(ax,reg))
else
	tx:=fsaveexpr(b,reg)
	ax:=floadexpr(a,reg)
!	bx:=frestoreexpr(tx,reg+getlregs(ax))
	bx:=frestoreexpr(tx,getnextreg(ax,reg))
fi

case opc
when m_add then
	genmc(m_fadd,ax,bx)
when m_sub then
	genmc(m_fsub,ax,bx)
when m_imul then
	genmc(m_fmul,ax,bx)
when m_idiv then
	genmc(m_fdiv,ax,bx)
esac


return ax
end

function loadexpr(unit a,int reg=r0,isassign=0)ref opndrec=
ref opndrec ax,rx

ax:=dx_expr(a,reg,1)

case ax.size
when 1,2,4,8 then
else				!block
	case ax.mode
	when a_mem then
		if ax.def=nil and ax.regix=0 and ax.value=0 then		!assume [reg]
			return genreg(ax.reg,ptrsize)						!return block reg
		fi
		rx:=genreg(reg+getaregs(ax),ptrsize)
!		rx:=genreg(getnextreg(ax),ptrsize)
		genmc(m_lea, rx, ax)
		return rx

	when a_reg then
		return ax
	when a_imm then
	else
		gerror("loadexpr block not mem/reg")
	esac
esac

case ax.mode
when a_reg then			!already in register
	if ax.reg=reg then
		return ax
	fi
	rx:=genreg(reg,ax.size)
	genmc(m_mov,rx,ax)
	return rx
when a_xreg then
	if isassign and ax.reg=reg then
		return ax
	fi
	rx:=genreg(reg,ax.size)
	genmc(m_fmov,rx,ax)
	return rx
esac

rx:=genreg(reg,ax.size)

genmc(m_mov,rx,ax)
return rx
end

function evalexpr(unit p,int reg=r0)ref opndrec=
!evaluate expression in junit  p
!return filled-in operand which can be used to access the result.
!Result is not loaded into a register unless needed.
!Any registers used will always start from R0 and XR0
ref opndrec ax,rx

ax:=dx_expr(p,reg,1)

if ax.mode=a_xreg then
	rx:=genreg(ax.reg,ax.size)
	genmc(m_fmov,rx,ax)
	return rx
fi
return ax
end

function evaladdr(unit p,int reg=r0)ref opndrec=
return dx_expr(p,reg,0)
end

function evalptr(unit p,int reg=r0)ref opndrec=
return dx_expr(p,reg,2)
end

function floadexpr(unit a,int xreg=r0)ref opndrec=
ref opndrec ax,rx

ax:=dx_expr(a,xreg)
rx:=genxreg(xreg,getopndsize_u(a))

case ax.mode
when a_xreg then				!already in register
	if ax.reg=xreg then
		return ax
	fi
	genmc(m_fmov,rx,ax)
	return rx
when a_reg then
	rx:=genxreg(ax.reg,ax.size)
	genmc(m_fmov,rx,ax)
	return rx
!	GERROR("FLOADEXPR REG")
esac

genmc(m_fmov,rx,ax)
return rx
end

function fevalexpr(unit p,int xreg=xr0)ref opndrec=
ref opndrec ax,rx

ax:=dx_expr(p,xreg)
if ax.mode=a_reg then
	rx:=genxreg(xreg,getopndsize_u(p))
	genmc(m_fmov,rx,ax)
	return rx
fi
return ax
end

proc do_if(unit a,b,c)=
int lab1,lab2

lab1:=createfwdlabel()

genjumpcond(kjumpf,a,lab1,r0)

do_stmt(b)

if c then
	lab2:=createfwdlabel()			!label past else part
	genjumpl(lab2)
	definefwdlabel(lab1)
	do_stmt(c)
	definefwdlabel(lab2)
else
	definefwdlabel(lab1)
fi
end

proc genjumpcond(int opc,unit p,int lab,reg=r0)=
!p is some conditional expression of arbitrary complexity
!opc is kjumpf or kjumpt
!evaluate and generate jumps as needed
unit q,r
int lab2
ref opndrec ax

q:=p.a
r:=p.b

switch p.tag
when j_andl then
	case opc
	when kjumpf then
		genjumpcond(kjumpf,q,lab,reg)
		genjumpcond(kjumpf,r,lab,reg)
	when kjumpt then
		lab2:=createfwdlabel()
		genjumpcond(kjumpf,q,lab2,reg)
		genjumpcond(kjumpt,r,lab,reg)
		definefwdlabel(lab2)
	esac

when j_orl then
	case opc
	when kjumpf then
		lab2:=createfwdlabel()
		genjumpcond(kjumpt,q,lab2,reg)
		genjumpcond(kjumpf,r,lab,reg)
		definefwdlabel(lab2)
	when kjumpt then
		genjumpcond(kjumpt,q,lab,reg)
		genjumpcond(kjumpt,r,lab,reg)
	esac

when j_notl then
	case opc
	when kjumpf then
		genjumpcond(kjumpt,q,lab,reg)
	when kjumpt then
		genjumpcond(kjumpf,q,lab,reg)
	esac

when j_istruel then
	genjumpcond(opc,q,lab,reg)

when j_eq,j_ne,j_lt,j_le,j_ge,j_gt then

	gcomparejump(opc,p,q,r,lab,reg)

when j_exprlist then
	while q and (r:=q.nextunit) do
		dx_expr(q,reg)
		q:=r
	od

	genjumpcond(opc,q,lab,reg)
else			!other expression
	case p.tag
	when j_preincr then			!this already sets the flag
		do_preincr(p.a,m_add,m_inc)
	when j_predecr then			!this already sets the flag
		do_preincr(p.a,m_sub,m_dec)
	else
		ax:=loadexpr(p,reg)
		genmc(m_cmp,ax,genint(0))
	esac

	genmc_cond(m_jmpcc, (opc|ne_cond|eq_cond),genlabel(lab))
end switch
end

proc gcomparejump(int jumpopc,unit p,lhs,rhs,int lab,reg)=
!jumpopc is the base cmdcode needed: kjumpt or kjumpt
!p is the eq/compare unit
!convert into jumpcc cmdcode
ref opndrec ax,bx
int mclcond,cond,tx

cond:=p.tag				!eqop,neop, etc

if jumpopc=kjumpf then			!need to reverse condition
	cond:=reversecond(cond)		!eqop => neop, etc
fi

mclcond:=getmclcond(cond,lhs.mode)

case mclcond
when flt_cond,fge_cond,fle_cond,fgt_cond,feq_cond, fne_cond then

	if issimple(rhs) then
		ax:=floadexpr(lhs,reg)
!		bx:=fevalexpr(rhs,reg+getlregs(ax))
		bx:=fevalexpr(rhs,getnextreg(ax,reg))
	else
		tx:=saveexpr(rhs,reg)
		ax:=floadexpr(lhs,reg)
!		bx:=frestoreexpr(tx,reg+getlregs(ax))
		bx:=frestoreexpr(tx,getnextreg(ax,reg))
	fi
	genmc(m_fcmp,ax,bx)

else
	if issimple(rhs) then
		ax:=loadexpr(lhs,reg)
!		bx:=evalexpr(rhs,reg+getlregs(ax))
		bx:=evalexpr(rhs,getnextreg(ax,reg))
		genmc(m_cmp,ax,bx)

	elsif issimple(lhs) then			!reverse test, but also modify condition
		mclcond:=reversemclcond(mclcond)
		ax:=loadexpr(rhs,reg)
!		bx:=evalexpr(lhs,reg+getlregs(ax))
		bx:=evalexpr(lhs,getnextreg(ax,reg))
		genmc(m_cmp,ax,bx)

	else
		pushexpr(rhs,reg)
		ax:=loadexpr(lhs,reg)
!		bx:=genreg(reg+getlregs(ax),ax.size)
		bx:=genreg(getnextreg(ax,reg),ax.size)
		genmc(m_pop,changeopndsize(bx,targetsize))
		genmc(m_cmp,ax,bx)
	fi
esac

genmc_cond(m_jmpcc, mclcond,genlabel(lab))
END

function reversecond(int op)int=
!reverse conditional operator

case op
when j_eq then return j_ne
when j_ne then return j_eq
when j_lt then return j_ge
when j_le then return j_gt
when j_ge then return j_lt
when j_gt then return j_le
esac
return 0
end

proc do_preincr(unit a,int addop,incrop)=
ref opndrec ptropnd
int size

ptropnd:=getlvalueopnd(a)

if ttbasetype[a.mode]=tref and ttsize[tttarget[a.mode]]<>1 then
	size:=ttsize[tttarget[a.mode]]
	genmc(addop,ptropnd,genint(size))
else
	genmc(incrop,ptropnd)
fi
end

function reversemclcond(int cond)int=
!reverse order due to operands being switched, so that <= becomes >=
!it is NOT the opposite condition (eg. <= becomes > or <> becomes =)

switch cond
when lt_cond then cond:=gt_cond		!needs symmetric reversal: < >
when le_cond then cond:=ge_cond		!<= >=
when ge_cond then cond:=le_cond		!>= <=
when gt_cond then cond:=lt_cond		!> <
when ltu_cond then cond:=gtu_cond		!needs symmetric reversal: < >
when leu_cond then cond:=geu_cond		!<= >=
when geu_cond then cond:=leu_cond		!>= <=
when gtu_cond then cond:=ltu_cond		!> <
when flt_cond then cond:=fgt_cond		!needs symmetric reversal: < >
when fle_cond then cond:=fge_cond		!<= >=
when fge_cond then cond:=fle_cond		!>= <=
when fgt_cond then cond:=flt_cond		!> <
end switch
return cond
end

proc do_while (unit pcond, pbody) =
int lab_b,lab_c,lab_d

if pcond.tag=j_const and pcond.value then
	do_while1(pbody)
	return
fi

lab_c:=createfwdlabel()
lab_d:=createfwdlabel()

stacklooplabels(lab_c, lab_d)

genjumpl(lab_c)		!direct to condition code which is at the end

lab_b:=definelabel()

do_stmt(pbody)

definefwdlabel(lab_c)

genjumpcond(kjumpt,pcond,lab_b)
definefwdlabel(lab_d)
--loopindex
end

proc do_while1 (unit pbody) =
int lab_b,lab_c,lab_d

lab_c:=createfwdlabel()
lab_d:=createfwdlabel()

stacklooplabels(lab_c, lab_d)

lab_b:=definelabel()

do_stmt(pbody)

definefwdlabel(lab_c)

genjumpl(lab_b)
definefwdlabel(lab_d)
--loopindex
end

proc stacklooplabels(int a,b)=
!don't check for loop depth as that has been done during parsing
continuestack[++loopindex]:=a
breakstack[loopindex]:=b
end

proc do_dowhile (unit pbody, pcond) =
int lab_b,lab_c,lab_d

lab_c:=createfwdlabel()
lab_d:=createfwdlabel()

stacklooplabels(lab_c, lab_d)

lab_b:=definelabel()

do_stmt(pbody)

definefwdlabel(lab_c)

genjumpcond(kjumpt,pcond,lab_b)
definefwdlabel(lab_d)
--loopindex
end

proc do_for (unit pinit, pbody) =
unit pcond,pincr
int lab_b,lab_c,lab_d,lab_cond

pcond:=pinit.nextunit
pincr:=pcond.nextunit

lab_c:=createfwdlabel()
lab_d:=createfwdlabel()
lab_cond:=createfwdlabel()

if pinit.tag<>j_null then
	do_stmt(pinit)
fi

genjumpl(lab_cond)		!direct to condition code which is at the end

stacklooplabels(lab_c, lab_d)

lab_b:=definelabel()

do_stmt(pbody)

definefwdlabel(lab_c)

do_stmt(pincr)
definefwdlabel(lab_cond)

if pcond.tag<>j_null then
	genjumpcond(kjumpt,pcond,lab_b)
else
	genjumpl(lab_b)
fi
definefwdlabel(lab_d)
--loopindex
end

function pushffparams(unit p,int variadic=0)int=
!p is a list of units representing params for a foreign function
!return number params allocated on stack
!return 1 if extra 8 bytes pushed for alignment, otherwise 0
ref opndrec rx,fx
[4]byte iscomplex
int i,m,n,dummypush,size,popbytes,ncomplex
unit q
[maxparams]unit paramlist


n:=0
while p do
	if n>=maxparams then gerror("TOO MANY PARAMS") fi
	++n
	paramlist[n]:=p
	p:=p.nextunit
od

m:=max(n,4)			!number of params on stack (always at least 4 including shadow space)
dummypush:=0

if (m iand 1) and stackaligned or (m iand 1)=0 and not stackaligned then
	dummypush:=1
	if n>4 then
		pushstack(8)
	fi
	popbytes:=(m+1)*8
else
	popbytes:=m*8
fi

for i:=n downto 5 do
	q:=paramlist[i]
	if variadic and ttbasetype[q.mode]=tfloat then		!need to convert to double
		pushfloatparam(q)
	else
		pushexpr(q)
	fi
od

if dummypush and n<=4 then
	pushstack(40)
else
	pushstack(32)
fi

n:=min(n,4)

if n=1 then			!simple param, just load direct
	pushoneparam(paramlist[i],variadic)
	return popbytes
fi

ncomplex:=0

!first pass, push complex params

!HAVE REVERSED ORDER OF PARAM EVALUATION: RIGHT TO LEFT FOR BOTTOM 4,
!FOR FIRST PASS, THEN LEFT TO RIGHT. Otherwise if doing param 4 first
!into r13, then can be overridden. (Perhaps need another scratch register)

!for i:=1 to n do
for i:=n downto 1 do
	q:=paramlist[i]
	if issimplepm(q) then
		iscomplex[i]:=0
	else
		pushexpr(q)
		iscomplex[i]:=1
		++ncomplex
	fi
od

!second pass, pop any complex params

!(NOTE: can be optimised when all only one complex param)
!for i:=n downto 1 do
for i:=1 to n do
	q:=paramlist[i]
	if gettypecat(q)<>'R' then
		if iscomplex[i] then
			genmc(m_pop,rx:=genreg(r10+i-1,targetsize))		!register must be full size
		else
			rx:=loadexpr(q,r10+i-1)
		fi
	else
		if variadic and ttbasetype[q.mode]=tfloat then		!need to convert to double
			loadfloatparam(q,i-1,iscomplex[i])
		else
			size:=ttsize[q.mode]
			if iscomplex[i] then
				genmc(m_pop,rx:=genreg(r13,targetsize))		!register must be full size
				genmc(m_fmov,fx:=genxreg(xr0+i-1,size),changeopndsize(rx,size))
			else
				fx:=floadexpr(q,xr0+i-1)
			fi

			if variadic then
				genmc(m_fmov,genreg(r10+i-1,size),fx)
			fi
		fi
	fi
od

return popbytes
end

proc pushoneparam(unit q, int variadic)=
ref opndrec fx,ax,bx

	if gettypecat(q)<>'R' then
		if issimple(q) then
			loadexpr(q,r10)
		else
			ax:=loadexpr(q,r0)
			bx:=genreg(r10,ax.size)
			genmc(m_mov, bx,ax)
		fi
	else
		fx:=floadexpr(q,xr0)
		if variadic then
			genmc(m_fmov,genreg(r10,ttsize[q.mode]),fx)
		fi
	fi
end

proc pushfloatparam(unit q)=
!for loading real32 to stack for variadic functions
ref opndrec ax,bx,fx

!GENCOMMENT("PUSHFLOATPARAM")

!fx:=floadexpr(q,xr15)
fx:=floadexpr(q,xr13)
genmc(m_fwiden,ax:=changeopndsize(fx,8),fx)
genmc(m_fmov,bx:=genreg(r13,8),ax)
genmc(m_push,bx)
end

proc loadfloatparam(unit q,int regoffset,iscomplex)=
!for loading real32 to regs for variadic functions
!q points to the real32 expr
!regoffset is 0..3; value needs loading in xmm0..3 and r10..r13
!iscomplex means the value exists, as real32, on the stack

ref opndrec ax,ax32,fx,fx32

fx:=genxreg(xr0+regoffset,8)
fx32:=genxreg(xr0+regoffset,4)
ax:=genreg(r10+regoffset,8)
ax32:=genreg(r10+regoffset,4)

if iscomplex then
	genmc(m_pop,ax)
	genmc(m_fmov,fx32,ax32)
	genmc(m_fwiden,fx,fx32)
	genmc(m_fmov,ax,fx)
else
	floadexpr(q,xr0+regoffset)
	genmc(m_fwiden,fx,fx32)
	genmc(m_fmov,ax,fx)
fi
end

function dx_call(unit p,a,b,int reg)ref opndrec=
ref opndrec result,cx,sx
ref paramrec pm
int isfnptr,variadic,nparams,retmode,nbytes,retsize,m,nregparams

retmode:=p.mode
if retmode=tvoid then retmode:=tsint fi

case a.tag
when j_ptr then
!CPL "DXCALL",STRMODE(A.MODE)
	m:=a.mode
	while ttbasetype[m]=tref do
		m:=tttarget[m]
	od

	pm:=ttparams[m]
	isfnptr:=1

else
	pm:=a.def.paramlist
	isfnptr:=0

esac

variadic:=pm.flags=pm_variadic
nparams:=pm.nparams

nbytes:=pushffparams(b,variadic)

retsize:=ttsize[retmode]
if retsize>8 then
	doblockcall(retsize)
fi

if not isfnptr then
	genmc(m_call,genmemaddr_u(a))
else
	if issimple(a) then
		genmc(m_call,changeopndsize(loadexpr(a.a),ptrsize))
	else
		nregparams:=min(nparams,4)
		sx:=genireg(rstack,8)
		for i:=1 to nregparams do
			genmc(m_mov, applyoffset(sx,(i-1)*8),genreg(r10+i-1,8))
		od
		cx:=changeopndsize(loadexpr(a.a),ptrsize)
		sx:=genireg(rstack,8)
		for i:=1 to nregparams do
			genmc(m_mov, genreg(r10+i-1,8),applyoffset(sx,(i-1)*8))
		od
		genmc(m_call,cx)
	fi

fi

popstack(nbytes)

if gettypecat(p)='R' then
	result:=genxreg(reg,retsize)
elsif retsize<=8 then
	result:=genreg(reg,retsize)
else
	result:=getblockreg(retsize)
fi
!IF TTSIZE[RETMODE]>8 THEN
!	CPL "CALL RETURNS BLOCK"
!FI

return result
end

proc do_return(unit a)=

leaveproc(currproc.name)

if a then
	if isrealcc(a.mode) then
		floadexpr(a)
	else
		loadexpr(a)

		if structretoffset then
			copyretvalue(ttsize[a.mode])
		fi
	fi
fi
genreturn(framebytes,parambytes)
end

function dx_sub(unit a,b,int reg)ref opndrec=
ref opndrec ax,bx
int tx,doneg

if gettypecat(a)='R' then
	return dx_fadd(m_sub,a,b,reg)
fi
doneg:=0

!GOTO SIMPLESUB

if issimple(b) then
SIMPLESUB:
	ax:=loadexpr(a,reg)
!	bx:=evalexpr(b,reg+getlregs(ax))
	bx:=evalexpr(b,getnextreg(ax,reg))

elsif issimple(a) then		!reverse order, add neg at the end
	ax:=loadexpr(b,reg)
!	bx:=evalexpr(a,reg+getlregs(ax))
	bx:=evalexpr(a,getnextreg(ax,reg))
	doneg:=1
else
	tx:=saveexpr(b,reg)
	ax:=loadexpr(a,reg)
!	bx:=restoreexpr(tx,reg+getlregs(ax))
	bx:=restoreexpr(tx,getnextreg(ax,reg))
fi
genmc(m_sub,ax,bx)
if doneg then
	genmc(m_neg,ax)
fi

return ax
end

function dx_mul(unit p,a,b,int reg)ref opndrec=
ref opndrec ax,bx
int64 x
int n,opc,tx

case gettypecat(a)
when 'R' then
	return dx_fadd(m_imul,a,b,reg)
esac

!if b.tag=j_const and tfirstint<=ttbasetype[b.mode]<=tlastint then
if b.tag=j_const and isintcc(b.mode) then
	x:=b.value
	if n:=ispoweroftwo(x) then
		p.tag:=j_shl
		b.value:=n
		return dx_shl(p,a,b,reg)
	fi
fi

if issimple(b) then

!should do special processing when a==b, but here only check for simple case of x*x
	ax:=loadexpr(a,reg)
	if a.tag=j_name and b.tag=j_name and a.def=b.def then
		bx:=ax
	else
!		bx:=evalexpr(b,reg+getlregs(ax))
		bx:=evalexpr(b,getnextreg(ax,reg))
	fi
elsif issimple(a) then	!reverse order
	ax:=loadexpr(b,reg)
!	bx:=evalexpr(a,reg+getlregs(ax))
	bx:=evalexpr(a,getnextreg(ax,reg))
else
	tx:=saveexpr(b,reg)
	ax:=loadexpr(a,reg)
!	bx:=restoreexpr(tx,reg+getlregs(ax))
	bx:=restoreexpr(tx,getnextreg(ax,reg))
fi

genmc(m_imul,ax,bx)

return ax
end

function dx_div(unit p,a,b,int reg)ref opndrec=
ref opndrec ax,bx
int opc,n,tx

case gettypecat(a)
when 'R' then
	return dx_fadd(m_idiv,a,b,reg)

when 'I' then
	opc:=m_idiv
else
	opc:=m_udiv
esac

!if b.tag=j_const and tfirstint<=ttbasetype[b.mode]<=tlastint then
if b.tag=j_const and isintcc(b.mode) then
	if n:=ispoweroftwo(b.value) then
		p.tag:=j_shr
		b.value:=n
		return dx_shl(p,a,b,reg)
	fi
fi

if reg<>r0 then
	gerror("DIV REG NOT ZERO")
fi

if issimple(b) then
	ax:=loadexpr(a,reg)
	if b.tag=j_const then
!		bx:=loadexpr(b,reg+getlregs(ax))
		bx:=loadexpr(b,getnextreg(ax,reg))
	else
!		bx:=evalexpr(b,reg+getlregs(ax))
		bx:=evalexpr(b,getnextreg(ax,reg))
	fi
else
	tx:=saveexpr(b,reg)
	ax:=loadexpr(a,reg)
!	bx:=restoreexpr(tx,reg+getlregs(ax))
	bx:=restoreexpr(tx,getnextreg(ax,reg))
fi

genmc(opc,bx)

return ax
end


function dx_shl(unit p,a,b,int reg)ref opndrec=
!shl/shr
ref opndrec ax,bx
int opc,tx

if p.tag=j_shl then
	opc:=m_shl
else
	case gettypecat(p)
	when 'I' then
		opc:=m_ishr
	else
		opc:=m_ushr
	esac
fi

if issimple(b) and reg<>r10 then
	ax:=loadexpr(a,reg)
	if b.tag=j_const then
		bx:=evalexpr(b,r10)
	else
		bx:=loadexpr(b,r10)
	fi
else
	tx:=saveexpr(b,reg)
	ax:=loadexpr(a,reg)
!	bx:=restoreexpr(tx,reg+getlregs(ax))
	bx:=restoreexpr(tx,getnextreg(ax,reg))
fi

genmc(opc,ax,bx)

return ax
end

function dx_iand(int opc,unit a,b,int reg)ref opndrec=
!iand/ior/ixor
!I think also and/or
ref opndrec ax,bx
int tx

if issimple(b) then
	ax:=loadexpr(a,reg)
!	bx:=evalexpr(b,reg+getlregs(ax))
	bx:=evalexpr(b,getnextreg(ax,reg))

elsif issimple(a) then	!reverse order
	ax:=loadexpr(b,reg)
!	bx:=evalexpr(a,reg+getlregs(ax))
	bx:=evalexpr(a,getnextreg(ax,reg))

else
	tx:=saveexpr(b,reg)
	ax:=loadexpr(a,reg)
!	bx:=restoreexpr(tx,reg+getlregs(ax))
	bx:=restoreexpr(tx,getnextreg(ax,reg))
fi
genmc(opc,ax,bx)

return ax
end

function dx_preincrx(unit p,a,int reg)ref opndrec=
int opc,size
ref opndrec ptropnd, result

ptropnd:=getlvalueopnd(a,reg)

opc:=m_mov

result:=genreg(getnextreg(ptropnd,reg),getopndsize_u(p))
if result.size>ptropnd.size then
GERROR("PREINCRX WIDENING NEEDED")
!	opc:=getwidencode(a.mode,p.mode)
fi

genmc(opc,result,ptropnd)

!if p.a.mode.basetypeno=t_ref and p.a.mode.target.size<>1 then
if ttbasetype[a.mode]=tref and ttsize[tttarget[a.mode]]<>1 then
	size:=ttsize[tttarget[a.mode]]
	if p.tag= j_preincr then
		opc:=m_add
	else
		opc:=m_sub
	fi
	genmc(opc,result,genint(size))
else
	genmc((p.tag=j_preincr|m_inc|m_dec),result)
fi
storeopnd(ptropnd,result)

return result
end

function dx_postincrx(unit p,a,int reg)ref opndrec=
int opc,size,convop
ref opndrec ptropnd, result, rr1

result:=genreg(reg,getopndsize_u(p))
ptropnd:=getlvalueopnd(a,reg+1)

opc:=m_mov

if result.size>ptropnd.size then
GERROR("POSTINCRX WIDENING NEEDED")
!	convop:=conversionops(ttbasetype[a.mode],ttbasetype[p.mode])
!	if 
!	opc:=getwidencode(a.mode,p.mode)
fi

!genmc(opc,rr1:=genreg(reg+1+getaregs(ptropnd),getopndsize_u(p)),ptropnd)
genmc(opc,rr1:=genreg(getnextreg(ptropnd,reg)+1,getopndsize_u(p)),ptropnd)
genmc(m_mov,result,rr1)

!if p.a.mode.basetypeno=t_ref and p.a.mode.target.size<>1 then
!	size:=p.a.mode.target.size
if ttbasetype[a.mode]=tref and ttsize[tttarget[a.mode]]<>1 then
	size:=ttsize[tttarget[a.mode]]
	if p.tag= j_postincr then
		opc:=m_add
	else
		opc:=m_sub
	fi
	genmc(opc,rr1,genint(size))
else
	genmc((p.tag=j_postincr|m_inc|m_dec),rr1)
fi
storeopnd(ptropnd,rr1)
return result
end

function makeindexopnd(unit a,index=nil, int scale=1,size,offset=0,reg=r0)ref opndrec=
! General routine to deal with pointers, pointers+offsets, records+offsets,
! array access with indices+offsets
! a, index are units
! index is optional, so can be nil
! index can also be a const unit, in which case it's added onto the fixed offset
! scale is the size of the object being fetched, used as scale factor for pointer+offset
!  or for index ops
! offset is a fixed byte-offset (0 if not needed)
! For extra offsets associated with array lower-bound adjustments, the caller adds
! the necessary byte-offset into offset
! Returns a memory access operand, but does not load the value
! If the address is of interest, the caller uses LEA on the result
! to load the results, a load operation (eg. m_mov) can be used
int mulfactor, tx, reg2
ref opndrec ax,ix,m
ref strec d

!GENCOMMENT("MAKINDEX")

if index and index.tag=j_const then
	offset+:=index.value*scale
	index:=nil
fi
!size:=scale

if index then
	case scale
	when 1,2,4,8 then
		mulfactor:=1
	else								!do the multiply here
		mulfactor:=scale
		scale:=1
	esac
fi

if a.tag=j_name then
	d:=a.def
	if d.nameid=paramid and isstructunion(d.mode) then
GOTO MX2
	fi

!CPL "HERE6"
	if index then							!name/(simple-complex)
		if mulfactor=1 then					!using scale factor
			ix:=loadexpr(index,reg)
			m:=genindex(ireg:ix.reg, scale:scale,def:d,offset:offset,size:size)
		else
			loadexpr(index,reg)
			mulreg(reg,mulfactor)
			m:=genindex(ireg:reg, scale:scale,def:d,offset:offset,size:size)
		fi
	else								!name/const
		m:=genindex(def:d,offset:offset,size:size)
	fi
else
mx2:
	if index then
		if issimple(a) then				!simple/(simple-complex)
!CPL "HERE3",MULFACTOR
			if mulfactor=1 then
!GENCOMMENT("HERE3")
!CPL =JTAGNAMES[INDEX.TAG]
				ix:=loadexpr(index,reg)
				ax:=loadexpr(a,reg+1)
!CPL "HERE4"
!GENCOMMENT("HERE4")
!				ax:=loadexpr(a,getnextreg(ix))
				m:=genindex(areg:ax.reg, ireg:ix.reg, scale:scale,offset:offset,size:size)
			else
				loadexpr(index,reg)
				mulreg(reg,mulfactor)
				loadexpr(a,reg+1)
				m:=genindex(areg:reg+1, ireg:reg, scale:scale,offset:offset,size:size)
			fi
		elsif issimple(index) then			!complex/simple
!CPL "HERE4"
			loadexpr(a,reg)
			loadexpr(index,reg+1)
			mulreg(reg+1,mulfactor)
			m:=genindex(areg:reg, ireg:reg+1, scale:scale,offset:offset,size:size)
		else							!complex/complex
!CPL "HERE5"
			tx:=saveexpr(a,reg)
			ix:=loadexpr(index,reg)
			mulreg(reg,mulfactor)
!			ax:=restoreexpr(tx,reg2:=reg+getlregs(ix))
			ax:=restoreexpr(tx,reg2:=getnextreg(ix,reg))
			m:=genindex(areg:reg2, ireg:reg, scale:scale,offset:offset,size:size)
		fi
	else								!(simple-complex)/const
		ax:=loadexpr(a,reg)
		m:=genindex(areg:ax.reg, scale:scale,offset:offset,size:size)
	fi
fi

return m
end

proc mulreg(int reg,int64 x)=
!multiply value in register by factor x
int n

if x>1 then
	if n:=ispoweroftwo(x) then
		genmc(m_shl,genreg(reg,8),genint(n))
	else
		genmc(m_imul,genreg(reg,8),genint(x))
	fi
fi
end

function dx_ptr(unit p,a,int reg,am=1)ref opndrec=
ref opndrec ax,bx

if am=0 then
	return loadexpr(a,reg)
fi

if ttbasetype[p.mode]=tproc then gerror("deref/proc") fi

ax:=evalptr(a,reg)
case a.tag
when j_addptr, j_subptr then
	if ax.mode<>a_reg then			!ax represents access to actual pointer target
		ax:=applysize(ax,ttsize[p.mode])
!CPL "DXPTR1",STROPND(AX)
		return ax
	fi

when j_addrof then
	return dx_expr(a.a,reg,am)
esac

if ax.mode<>a_reg then
	genmc(m_mov,bx:=genreg(reg,ptrsize),ax)
	ax:=bx
fi
ax:=makeindirect(ax,ttsize[p.mode])

!CPL "DXPTR3",STROPND(AX)
return ax
end

function dx_addptr(unit p,a,b,int reg,am=1)ref opndrec=
!works out

!addptr differs from add in that b needs to scaled, usually by 2,4,8 but could
!be anything
int size,scale,mulfactor,reg1,tx,offset
ref opndrec m,ax,bx,rx
unit pname

!RETURN GENINT(999)

!CPL "ADDPTR"
!PRINTUNIT(NIL,A); CPL
!PRINTUNIT(NIL,B)

!AX:=EVALEXPR(A,REG)
!AX:=EVALADDR(A,REG)
!CPL =STROPND(AX)

!CPL "ADDPTR",=STRMODE(A.MODE)
size:=scale:=ttsize[tttarget[a.mode]]
if p.ptrscale=0 then scale:=1 fi			!addptr from dot op: offset in bytes

!return genint(12345)

offset:=0
if b.tag=j_const then
!CPL =SCALE
	b.value*:=scale
	offset:=b.value
	scale:=1
fi

case scale
when 2,4,8 then
	mulfactor:=1
else
	mulfactor:=scale
	scale:=1
esac

reg1:=reg+1

!GOTO CXCX

!if b.tag=j_const then
!	loadexpr(a,reg)
!	m:=genindex(areg:reg, scale:scale,size:size, offset:b.value)

if b.tag=j_const then					!any+const
	case a.tag
	when j_addrof then
		pname:=a.a
!CPL "ADDROF/NAME"
		if pname.tag<>j_name then goto other fi
		m:=genindex(def:pname.def,offset:offset,size:size)
!	when j_addptr, j_subptr then
!		ax:=evalptr(a,reg)
!CPL "ADDPTR/ADDPTR+CONST",=STROPND(AX)
!		if ax.mode=a_reg then
!			ax:=makeindirect(ax)
!		fi
!		m:=applyoffset(ax,offset,size)
!	when j_const then
	else
other:
		loadexpr(a,reg)
		m:=genindex(areg:reg, scale:scale,size:size, offset:b.value)
!		goto cxcx
	esac

elsif a.tag=j_addrof and a.a.tag=j_name then		!&a+const
!CPL "&NAME+ANY",MULFACTOR
!IF MULFACTOR>=8 THEN
!GOTO CXCX
!	PRINTUNIT(NIL,A)
!FI
	pname:=a.a
	bx:=loadexpr(b,reg)				!R
	mulreg(bx.reg,mulfactor)
	bx:=makeindirect(bx,size)		![R]
	bx.regix:=bx.reg
	bx.reg:=0

	bx.scale:=scale
	bx.def:=pname.def				![R+d]
	if isframe(pname.def) then
		bx.reg:=rframe
	fi
	m:=bx

elsif issimple(b) then
!CPL "CX/SX"
	loadexpr(a,reg)
	loadexpr(b,reg1)
	mulreg(reg1,mulfactor)
	m:=genindex(areg:reg, ireg:reg1, scale:scale,size:size)
elsif issimple(a) then
!CPL "SX/CX"
	loadexpr(b,reg)
	mulreg(reg,mulfactor)
	loadexpr(a,reg1)
	m:=genindex(areg:reg1, ireg:reg, scale:scale,size:size)
else
cxcx:
!CPL "CX/CX"

	tx:=saveexpr(b,reg)
	ax:=loadexpr(a,reg)
	bx:=restoreexpr(tx,getnextreg(ax,reg))
	mulreg(bx.reg,mulfactor)
	m:=genindex(areg:reg, ireg:bx.reg, scale:scale,size:size)
fi

case am
when 1 then
	genmc(m_lea,rx:=genreg(reg,ptrsize),m)
	return rx
esac
return m
end

function dx_subptr(unit a,b,int reg,am)ref opndrec=
int size,scale,mulfactor,reg1,tx,offset
ref opndrec m,ax,bx,rx,ix
ref strec d

!CPL "SUBPTR",=AM

size:=scale:=ttsize[tttarget[a.mode]]

if ttbasetype[b.mode]=tref then		!ptr-ptr
	ax:=dx_sub(a,b,reg)
	divreg(ax.reg,scale)
	return ax
fi

!if am='L' then
!	if scale=1 then
!		return dx_sub(a,b,reg)
!	fi
!	if b.tag=j_const then
!		b.value*:=scale
!		return dx_sub(a,b,reg)
!	fi
!fi

offset:=0
if b.tag=j_const then
	b.value:=b.value*scale
	offset:=-b.value
	scale:=1
fi

mulfactor:=scale
scale:=1

reg1:=reg+1

!CPL "SUBPTR2",=SIZE,=SCALE,=MULFACTOR,=OFFSET

if a.tag=j_addrof and a.a.tag=j_name then
!CPL "SUBPTR3"
	a:=a.a
fi

!GOTO CXCX

if b.tag=j_const then
!CPL "SUB/CONST"
!GOTO CXCX
!if b.tag=j_const then
	loadexpr(a,reg)
	m:=genindex(areg:reg, scale:scale,size:size, offset:offset)
!subptr1:
	if am=2 then
		return m
	fi
	genmc(m_lea,rx:=genreg(reg,ptrsize),m)

	return rx

elsif issimple(b) then
!CPL "SUB/CX/SX"
!GOTO CXCX
	ax:=loadexpr(a,reg)
	bx:=loadexpr(b,reg1)
	mulreg(reg1,mulfactor)
!	m:=genindex(areg:reg, ireg:reg1, scale:scale,size:size)
elsif issimple(a) then
!CPL "SUB/SX/CX"
!GOTO CXCX
	bx:=loadexpr(b,reg)
	mulreg(reg,mulfactor)
	ax:=loadexpr(a,reg1)
!	m:=genindex(areg:reg1, ireg:reg, scale:scale,size:size)
else
CXCX:
	tx:=saveexpr(b,reg)
	ax:=loadexpr(a,reg)
!	bx:=restoreexpr(tx,reg+getlregs(ax))
	bx:=restoreexpr(tx,getnextreg(ax,reg))
	mulreg(bx.reg,mulfactor)
fi
m:=genindex(areg:reg, ireg:bx.reg, scale:scale,size:size)

genmc(m_sub,ax,bx)

return ax
end

function dx_convert(unit a, int t,opc, reg)ref opndrec=
!convert unit a to type t, using conversion opc (uwiden_c etc)
ref opndrec ax,rx
int ssize,tsize

ssize:=ttsize[a.mode]
tsize:=ttsize[t]

case opc
when sfix_c,ufix_c, fnarrow_c,fwiden_c then
	ax:=fevalexpr(a,reg)
else
	ax:=evalexpr(a,reg)			!may need feval for some ops
esac

case opc
when soft_c then
dosoft:
	return ax

when hard_c then

	rx:=genreg(reg,tsize)
	if tsize<ssize then				!narrow
		genmc(m_unarrow,rx,ax)

	elsif tsize>ssize then			!widen
		genmc(m_uwiden,rx,ax)

	else							!same size just different type
		return ax
	fi

when swiden_c, uwiden_c then
if ax.mode=a_imm then
	ax.size:=tsize
	return ax
fi
	if ssize=tsize then return ax fi
	rx:=genreg(reg,tsize)
	genmc((opc=swiden_c|m_iwiden|m_uwiden),rx,ax)

when sfloat_c,ufloat_c then
	rx:=genxreg(reg,tsize)	
	genmc((opc=sfloat_c|m_ifloat|m_ufloat),rx,ax)

when sfix_c,ufix_c then
	rx:=genreg(reg,tsize)	
	genmc((opc=sfix_c|m_ifix|m_ufix),rx,ax)

when fnarrow_c,fwiden_c then
	rx:=genxreg(reg,tsize)	
	genmc((opc=fnarrow_c|m_fnarrow|m_fwiden),rx,ax)

when narrow_c,truncate_c then
	rx:=genreg(reg,tsize)	
	genmc(m_unarrow,rx,ax)

else
	gerror_s("Convert op not implem: %s",convnames[opc])
esac
return rx
end

proc do_decl(ref strec d)=
ref opndrec ax
unit a,dest
[256]char str
int nbytes

!CPL "DODECL",D.NAME

a:=d.code

!case ttbasetype[d.mode]
!when tunion,tstruct then
!	if a.tag<>j_makelist then
!CPL "HERE1"
!!		gerror("Dynamic struct init")
!	fi
!esac

if a.tag<>j_makelist then
	if ttbasetype[d.mode]=tarray and a.tag=j_const then	!probably string lit
		goto copyl
	fi
	if gettypecat(a)='R' then
		ax:=floadexpr(a,xr0)
		genmc(m_fmov,genmem_d(d),ax)
	elsif a.tag<>j_const then
		case ttsize[a.mode]
		when 1,2,4,8 then
			ax:=loadexpr(a,r0)
			genmc(m_mov,genmem_d(d),ax)
		else
			dest:=createname(d)
			dest.mode:=d.mode
			do_assignblock(dest,a,r0)
		esac
	else
		genmc(m_mov,genmem_d(d),evalexpr(a))
	fi
	return
fi

copyl:

nbytes:=ttsize[d.mode]
pushstack(32)

genmc(m_lea, genreg(r10,ptrsize),genmem_d(d))

!sprintf(&.str,"`$%s.%s.%d",currproc.name,d.name,int32(d.blockno))
fprint @&.str,"`$#.#.#",currproc.name,d.name,d.blockno

genmc(m_mov, genreg(r11,ptrsize), genname(&.str))

genmc(m_mov,genreg(r12,ptrsize),genint(nbytes))

genmc(m_call,genname("memcpy*"))

popstack(32)

end

function do_assignblock (unit a,b, int regx=0)ref opndrec =
!special optimised code for blocks; specifically 16-byte ones
!return operand for one the block just copied, or 0 if it could not be done here
ref opndrec ax,bx,rx,rs,rd,rcount,bx2,rsa,rda
int rev,workreg,nwords,lab, regcount,regsource, regdest, offset, n, oddbytes, reg

reg:=(regx|regx|xr0)

rev:=0
if issimple(b) then
!CPL "SSB"
	ax:=getlvalueopnd(a,reg)
!	bx:=getlvalueopnd(b,reg+getaregs(ax))
	bx:=getlvalueopnd(b,getnextreg(ax,reg))

elsif issimple(a) then
!CPL "SSA"
	rev:=1
	ax:=getlvalueopnd(b,reg)
!	bx:=getlvalueopnd(a,reg+getaregs(ax))
	bx:=getlvalueopnd(a,getnextreg(ax,reg))

else
!CPL "CXAB"
	bx:=getlvalueopnd(b,reg)
	if bx.mode<>a_reg then
		genmc(m_lea,bx2:=genreg(reg,ptrsize),bx)
	else
		bx2:=bx
	fi
	genmc(m_push,bx2)
	ax:=getlvalueopnd(a,reg)

!	genmc(m_pop,genreg(reg:=reg+getaregs(ax),ptrsize))
	genmc(m_pop,bx:=genreg(getnextreg(ax,reg),ptrsize))
	bx:=genireg(bx.reg)

fi

if ax.mode=a_reg then ax:=genireg(ax.reg) fi
if bx.mode=a_reg then bx:=genireg(bx.reg) fi

if rev then
	swap(ax,bx)
fi

!ax is the access operand for the dest, and bx for the source

!CPL "BLOCK ASSIGN:",=GETNEXTREG(AX),GETNEXTREG(BX)
!CPL "BLOCK ASSIGN:",=STROPND(AX),=STROPND(BX)

IF GETNEXTREG(AX)>R4 OR GETNEXTREG(BX)>R4 THEN GERROR("ASSIGNBLOCK/REG") fi

workreg:=r4

!n:=ax.size
n:=ttsize[a.mode]

oddbytes:=n rem 8		!will be zero, or 1..7
n-:=oddbytes			!n will always be a multiple of 8; n can be zero too
nwords:=n/8			!number of dwords (ie. octobytes)

if 1<=nwords<=4 then		!use unrolled code (no loop)
	offset:=0
	ax:=changeopndsize(ax,targetsize)
	bx:=changeopndsize(bx,targetsize)
	rx:=genreg(workreg,targetsize)
	to nwords do
		genmc(m_mov,rx,applyoffset(bx,offset))

		genmc(m_mov,applyoffset(ax,offset),rx)
		offset+:=8
	od
	rs:=bx
	rd:=ax

elsif nwords<>0 then		!use a loop
	lab:=++labelno
	regcount:=workreg+1
	regsource:=regcount+1
	regdest:=regsource+1
	genmc(m_lea,rsa:=genreg(regsource,ptrsize),bx)
	genmc(m_lea,rda:=genreg(regdest,ptrsize),ax)
	rs:=genireg(regsource,ptrsize)
	rd:=genireg(regdest,ptrsize)
	rx:=genreg(workreg,targetsize)
	rcount:=genreg(regcount,4)

	genmc(m_mov,rcount,genint(nwords))
	genmc(m_label,genlabel(lab))
	genmc(m_mov,rx,rs)
	genmc(m_mov,rd,rx)
	genmc(m_add,rsa,genint(targetsize))
	genmc(m_add,rda,genint(targetsize))
	genmc(m_dec,rcount)
	genmc_cond(m_jmpcc,ne_cond,genlabel(lab))
	offset:=0
else
	rd:=changeopndsize(ax,targetsize)
	rs:=changeopndsize(bx,targetsize)
	offset:=0
fi

if oddbytes then
	n:=oddbytes						!1..7

	if n>=4 then
		rx:=genreg(workreg,4)
		genmc(m_mov,rx,applyoffset(rs,offset))
		genmc(m_mov,applyoffset(rd,offset),rx)
		n-:=4
		offset+:=4
	fi
	if n>=2 then
		rx:=genreg(workreg,2)
		genmc(m_mov,rx,applyoffset(rs,offset))
		genmc(m_mov,applyoffset(rd,offset),rx)
		n-:=2
		offset+:=2
	fi
	if n=1 then
		rx:=genreg(workreg,1)
		genmc(m_mov,rx,applyoffset(rs,offset))
		genmc(m_mov,applyoffset(rd,offset),rx)
	fi
fi
!GENCOMMENT("------DONE BLOCK COPY")

if regx then
	return getlvalueopnd(a,reg)
fi
return genint(0)
end

function dx_widen(unit a, int m, reg)ref opndrec=
ref opndrec ax,bx
int opc

opc:=(gettypecat(a)='I'|m_iwiden|m_uwiden)

ax:=evalexpr(a,reg)

if ttsize[m]=ax.size then
	return ax
fi
bx:=genreg(reg,ttsize[m])
genmc(opc,bx,ax)

return bx
end

function dx_neg(unit a,int reg)ref opndrec=
ref opndrec ax

if gettypecat(a)='R' then
	return dx_fneg(a,reg)
fi
ax:=loadexpr(a,reg)
genmc(m_neg,ax)
return ax
end

function dx_fneg(unit a,int reg)ref opndrec=
ref opndrec fx

fx:=floadexpr(a,reg)
genmc(m_fneg,fx)
return fx
end

function dx_inot(unit a,int reg)ref opndrec=
ref opndrec ax

ax:=loadexpr(a,reg)
genmc(m_not,ax)
return ax
end

proc do_switch(unit p,a,b)=
!need to create switch levels, as they can be nested; nested case labels
!belong to the top switch level
[maxswitchrange]int labeltable				!sw_length+1 labels
[maxcases]int valuetable					!sw_length+1 labels
[maxswitchrange]byte flags					!flags to check dupl values
int defaultlabel							!index of fwd default label
int breakswlabel							!index of fwd break label
int switchlabel								!index of fwd break label
int lower, upper							!ower/upper ranges of switch case values
int length,value,ncases
byte serialsw
int i,index
!int sw_index
ref caserec pcase
ref opndrec ax,bx

!store current set of global values for outer switch
ref[]int old_labeltable
ref[]int old_valuetable
int old_ncases,old_lower
byte old_defaultseen
int old_defaultlabel
int old_breaklabel

pcase:=p.nextcase
ncases:=length:=0

while pcase do
	++ncases
	if ncases>maxcases then
		gerror("Too many cases on one switch")
	fi
	valuetable[ncases]:=value:=pcase.value

	if ncases=1 then
		lower:=upper:=value
	else
		lower:=min(lower,value)
		upper:=max(upper,value)
	fi
	pcase:=pcase.nextcase
od

if p.nextcase then
	length:=upper-lower+1
else
	length:=0
fi 

!allocate fwd labels
defaultlabel:=createfwdlabel()		!(when no default:, same as breakswlabel)
breakswlabel:=createfwdlabel()

if length>maxswitchrange then

!NOTES: SERIAL switch needs a way of checking duplicate case values.
!Better if not an n-squared search
!Short length switches should also be done serially (length<=8)
!Then a dupl check is simpler

	serialsw:=1

	ax:=loadexpr(a)
	for i:=1 to ncases do
		labeltable[i]:=createfwdlabel()
		genmc(m_cmp,ax,genint(valuetable[i]))
		genmc_cond(m_jmpcc,eq_cond,genlabel(labeltable[i]))
	od
	genmc(m_jmp,genlabel(defaultlabel))

elsif length=0 then
!GERROR("L=0")
	genmc(m_jmp,genlabel(defaultlabel))

else
	serialsw:=0
	memset(&flags,0,length)				!clear value flags

!fill table with defaults first
	for i:=1 to length do
		labeltable[i]:=defaultlabel
	od

!now, do labels for each case value
	for i:=1 to ncases do
		value:=valuetable[i]
		index:=value-lower+1			!index of value within label table
		labeltable[index]:=createfwdlabel()

		if flags[index] then
			gerror_s("Dupl case value: %d",cast(value))
		fi
		flags[index]:=1
	od

!need a label for the switchtable itself
	switchlabel:=createfwdlabel()

	ax:=loadexpr(a)
	genmc(m_sub,ax,genint(lower))
	genmc(m_cmp,ax,genint(length))
	genmc_cond(m_jmpcc, geu_cond, genlabel(defaultlabel))

	genmc(m_jmp, genindex(ireg:r0,scale:8,labno:switchlabel))

	setsegment('I',8)
	definefwdlabel(switchlabel)

	for i:=1 to length do
		genmc(m_dq,genlabel(labeltable[i]))
	od
	setsegment('C')
fi

!generate code for the switch body
!I need to make available essential tables, offsets etc necessary for j-case
!to be mappable to a label
!note: if already in an outer switch, then must save those earlier vars
!save outer switch vars
old_labeltable:=sw_labeltable
old_valuetable:=sw_valuetable
old_lower:=sw_lower
old_ncases:=sw_ncases
old_defaultseen:=sw_defaultseen
old_defaultlabel:=sw_defaultlabel
old_breaklabel:=sw_breaklabel

!set globals
sw_labeltable:=&labeltable
sw_valuetable:=&valuetable		!NEEDED ONLY FOR COMPLEX SWITCH
sw_lower:=lower

sw_ncases:=(serialsw|ncases|0)
sw_defaultseen:=0
sw_defaultlabel:=defaultlabel
sw_breaklabel:=breakswlabel

do_stmt(b)						!switch body

!need to note whether a default label has been generated; if not, define
!default label here
if not sw_defaultseen then
	definefwdlabel(defaultlabel)
fi
!define breakswlabel here
definefwdlabel(breakswlabel)

!restore any values of outer switch statement
sw_labeltable:=old_labeltable
sw_valuetable:=old_valuetable
sw_lower:=old_lower
sw_ncases:=old_ncases
sw_defaultseen:=old_defaultseen
sw_defaultlabel:=old_defaultlabel
sw_breaklabel:=old_breaklabel
end

function dx_rem(unit p,a,b,int reg)ref opndrec=
ref opndrec ax,bx
int tx,n
int opc

case gettypecat(a)
when 'I' then
	opc:=m_irem
else
	opc:=m_urem
!	if b.tag=j_const and tfirstint<=ttbasetype[b.mode]<=tlastint then
	if b.tag=j_const and isintcc(b.mode) then
		if n:=ispoweroftwo(b.value) then
			p.tag:=j_shr
			b.value:=b.value-1
			return dx_iand(m_and,a,b,reg)
		fi
	fi
esac

if reg<>r0 then
	gerror("REM REG NOT ZERO")
fi
if issimple(b) then
	ax:=loadexpr(a,reg)
	if b.tag=j_const then
!		bx:=loadexpr(b,reg+getlregs(ax))
		bx:=loadexpr(b,getnextreg(ax,reg))
	else
!		bx:=evalexpr(b,reg+getlregs(ax))
		bx:=evalexpr(b,getnextreg(ax,reg))
	fi
else
	tx:=saveexpr(b,reg)
	ax:=loadexpr(a,reg)
!	bx:=restoreexpr(tx,reg+getlregs(ax))
	bx:=restoreexpr(tx,getnextreg(ax,reg))
fi
genmc(opc,bx)
return ax
end

function dx_ifx(unit a,b,c,int reg)ref opndrec=
ref opndrec bx,result
int lab1, lab2,isreal

lab1:=createfwdlabel()				!dest label of main condition (to end of if, or start if else)
lab2:=createfwdlabel()

isreal:=gettypecat(b)='R'

genjumpcond(kjumpf,a,lab1,reg)
if isreal then
	result:=floadexpr(b,reg)
else
	result:=loadexpr(b,reg)
fi

genjumpl(lab2)
definefwdlabel(lab1)

if isreal then
	bx:=floadexpr(c,reg)
else
	bx:=loadexpr(c,reg)
fi

definefwdlabel(lab2)
return result
end

function dx_addto(int opc,unit a,b,int regx=0)ref opndrec=
ref opndrec lhs, rhs, ptropnd,rr2
int reg,tx

if gettypecat(b)='R' then
	return dx_faddto(opc,a,b,regx)
fi

reg:=(regx|regx|xr0)

if issimple(b) then
	ptropnd:=getlvalueopnd(a,reg)
	if b.tag=j_const and b.mode=tsint then
!		rhs:=evalexpr(b,reg+getaregs(ptropnd))
		rhs:=evalexpr(b,getnextreg(ptropnd,reg))
	else
!		rhs:=loadexpr(b,reg+getaregs(ptropnd))
		rhs:=loadexpr(b,getnextreg(ptropnd,reg))
	fi
	rhs:=changeopndsize(rhs,ptropnd.size)
	genmc(opc,ptropnd,rhs)
elsif issimple(a) then
	rhs:=loadexpr(b,reg)
!	ptropnd:=getlvalueopnd(a,reg+getlregs(rhs))
	ptropnd:=getlvalueopnd(a,getnextreg(rhs,reg))
	rhs:=changeopndsize(rhs,ptropnd.size)
	genmc(opc,ptropnd,rhs)
else
	tx:=saveexpr(b,reg)
	ptropnd:=getlvalueopnd(a,reg)
!	rr2:=restoreexpr(tx,reg+getaregs(ptropnd))
	rr2:=restoreexpr(tx,getnextreg(ptropnd,reg))
	rr2:=changeopndsize(rr2,ptropnd.size)
	genmc(opc,ptropnd,rr2)
fi

return ptropnd

end

function dx_faddto(int opc,unit a,b,int regx=0)ref opndrec=
ref opndrec work, rhs, ptropnd
int reg,tx,tempreg

reg:=(regx|regx|xr0)

if issimple(b) then
	ptropnd:=getlvalueopnd(a,reg)
!	reg+:=getaregs(ptropnd)
	reg:=getnextreg(ptropnd,reg)
	rhs:=fevalexpr(b,reg)
!	reg+:=getlregs(rhs)
	reg:=getnextreg(rhs,reg)

elsif issimple(a) then
	rhs:=fevalexpr(b,reg)
!	reg+:=getlregs(rhs)
	reg:=getnextreg(rhs,reg)
	ptropnd:=getlvalueopnd(a,reg)
!	reg+:=getaregs(ptropnd)
	reg:=getnextreg(ptropnd,reg)
else
	tx:=saveexpr(b,reg)
	ptropnd:=getlvalueopnd(a,reg)
	reg:=getnextreg(ptropnd,reg)
	rhs:=frestoreexpr(tx,reg)
	++reg
fi

work:=genxreg(reg,getopndsize_u(b))

genmc(m_fmov,work,ptropnd)

case opc
when m_add then opc:=m_fadd
when m_sub then opc:=m_fsub
when m_imul then opc:=m_fmul
when m_idiv then opc:=m_fdiv
esac

genmc(opc,work,rhs)
genmc(m_fmov,ptropnd,work)

return ptropnd
end

function dx_eq(unit p,a,b,int reg)ref opndrec=
!apply =, <= etc between a and b, and get a logical result 1 or 0
ref opndrec ax,bx,rx,rxb
int mclcond,tx

mclcond:=getmclcond(p.tag,a.mode)

case mclcond
when feq_cond, fne_cond,flt_cond,fge_cond,fle_cond,fgt_cond then
	if issimple(b) then
		ax:=floadexpr(a,reg)
!		bx:=fevalexpr(b,reg+getlregs(ax))
		bx:=fevalexpr(b,getnextreg(ax,reg))

	elsif issimple(a) then	!reverse order
		mclcond:=reversemclcond(mclcond)
		ax:=floadexpr(b,reg)
!		bx:=fevalexpr(a,reg+getlregs(ax))
		bx:=fevalexpr(a,getnextreg(ax,reg))
	else
		tx:=saveexpr(b,reg)
		ax:=floadexpr(a,reg)
!		bx:=frestoreexpr(tx,reg+getlregs(ax))
		bx:=frestoreexpr(tx,getnextreg(ax,reg))
	fi
	genmc(m_fcmp,ax,bx)
else
	if issimple(b) then
		ax:=loadexpr(a,reg)
!		bx:=evalexpr(b,reg+getlregs(ax))
		bx:=evalexpr(b,getnextreg(ax,reg))
	elsif issimple(a) then			!reverse order
		mclcond:=reversemclcond(mclcond)
		ax:=loadexpr(b,reg)
		bx:=evalexpr(a,reg)
	else
		tx:=saveexpr(b,reg)
		ax:=loadexpr(a,reg)
!		bx:=restoreexpr(tx,reg+getlregs(ax))
		bx:=restoreexpr(tx,getnextreg(ax,reg))
	fi
	genmc(m_cmp,ax,bx)
esac
rx:=genreg(reg,4)
rxb:=genreg(reg,1)

genmc_cond(m_setcc,mclcond,rxb)
genmc(m_uwiden,rx,rxb)
return rx
end

proc do_exprlist(unit a)=

while a do
	do_stmt(a)
	a:=a.nextunit
od
end

function dx_exprlist(unit a,int reg)ref opndrec=
ref opndrec ax

while a do
	ax:=dx_expr(a,reg)
	a:=a.nextunit
od
return ax
end

function dx_shlto(unit p,a,b,int regx=0)ref opndrec=
ref opndrec lhs, rhs, ptropnd,rr2
int reg,tx,opc

if p.tag=j_shlto then
	opc:=m_shl
else
	case gettypecat(p)
	when 'I' then
		opc:=m_ishr
	else
		opc:=m_ushr
	esac
fi

reg:=(regx|regx|xr0)

if issimple(b) then
	ptropnd:=getlvalueopnd(a,reg)
	if b.tag=j_const and b.mode=tsint then
!		rhs:=evalexpr(b,reg+getaregs(ptropnd))
		rhs:=evalexpr(b,getnextreg(ptropnd,reg))
	else
!		rhs:=loadexpr(b,reg+getaregs(ptropnd))
		rhs:=loadexpr(b,getnextreg(ptropnd,reg))
	fi
	rhs:=changeopndsize(rhs,ptropnd.size)
	genmc(opc,ptropnd,rhs)
elsif issimple(a) then
	rhs:=loadexpr(b,reg)
!	ptropnd:=getlvalueopnd(a,reg+getlregs(rhs))
	ptropnd:=getlvalueopnd(a,getnextreg(rhs,reg))
	rhs:=changeopndsize(rhs,ptropnd.size)
	genmc(opc,ptropnd,rhs)
else
	tx:=saveexpr(b,reg)
	ptropnd:=getlvalueopnd(a,reg)
!	rr2:=restoreexpr(tx,reg+getaregs(ptropnd))
	rr2:=restoreexpr(tx,getnextreg(ptropnd,reg))
	rr2:=changeopndsize(rr2,ptropnd.size)
	genmc(opc,ptropnd,rr2)
fi

return ptropnd

end

function dx_multo(unit a,b,int regx)ref opndrec=
ref opndrec work, rhs, ptropnd
int reg,tx,sgned

case gettypecat(b)
when 'R' then
	return dx_faddto(m_imul,a,b,regx)
when 'I' then
	sgned:=1
else
	sgned:=0
esac

reg:=(regx|regx|r0)

work:=genreg(reg,getopndsize_u(b))
++reg

if issimple(b) then
	ptropnd:=getlvalueopnd(a,reg)
!	reg+:=getaregs(ptropnd)
	reg:=getnextreg(ptropnd,reg)
	rhs:=evalexpr(b,reg)
!	reg+:=getlregs(rhs)
	reg:=getnextreg(rhs,reg)

elsif issimple(a) then
	rhs:=evalexpr(b,reg)
!	reg+:=getlregs(rhs)
	reg:=getnextreg(rhs,reg)
	ptropnd:=getlvalueopnd(a,reg)
!	reg+:=getaregs(ptropnd)
	reg:=getnextreg(ptropnd,reg)
else
	tx:=saveexpr(b,reg)
	ptropnd:=getlvalueopnd(a,reg)
	reg:=getnextreg(ptropnd,reg)
	rhs:=restoreexpr(tx,reg)
	++reg
fi

loadviaptr(work,ptropnd,sgned)
!genmc(m_mov,work,ptropnd)

genmc(m_imul,work,rhs)

!genmc(m_mov,ptropnd,work)
genmc(m_mov,ptropnd,changeopndsize(work,ptropnd.size))

return ptropnd
end

function dx_notl(unit a,int reg)ref opndrec=
ref opndrec ax,rx,rxb

if a.tag=j_notl then
	return dx_istruel(a.a,reg)
fi

ax:=loadexpr(a,reg)
genmc(m_and,ax,ax)
rx:=genreg(reg,4)
rxb:=genreg(reg,1)
genmc_cond(m_setcc,eq_cond,rxb)
genmc(m_uwiden,rx,rxb)
return rx
end

function dx_istruel(unit a, int reg)ref opndrec=
ref opndrec ax,rx,rxb

ax:=loadexpr(a,reg)
genmc(m_and,ax,ax)
rx:=genreg(reg,4)
rxb:=genreg(reg,1)
genmc_cond(m_setcc,ne_cond,rxb)
genmc(m_uwiden,rx,rxb)
return rx
end

function dx_andorl(unit p, int reg)ref opndrec =
!do short-circuit evaluation of a&&b or a||b
!return operand containing 1 or 0
int lab1,lab2
ref opndrec rx

lab1:=createfwdlabel()			!dest label of main condition (to end of if, or start if else)

genjumpcond(kjumpf,p,lab1)

rx:=genreg(reg,4)

lab2:=createfwdlabel()			!label past else part
genmc(m_mov,rx,genint(1))

genjumpl(lab2)
definefwdlabel(lab1)
genmc(m_mov,rx,genint(0))

definefwdlabel(lab2)
return rx
end

function dx_sqrt(unit a,int reg)ref opndrec=
ref opndrec fx
fx:=floadexpr(a,reg)
genmc(m_fsqrt,fx,fx)
return fx
end

function dx_scale(unit p,a,b, int reg)ref opndrec=
ref opndrec ax,bx,cx
int opc,scale,n

ax:=loadexpr(a,reg)

scale:=p.scale
opc:=m_imul
if scale<0 then
	scale:=-scale
	opc:=m_idiv
fi

!CPL "SCALE",SCALE

n:=ispoweroftwo(scale)

if n=0 then
	bx:=genint(scale)
	if opc=m_imul then
		genmc(m_imul,ax,bx)
	else
		if ax.reg<>r0 then
!CPL =SCALE
			gerror("scale/div by non-power-of-two/not r0")
		fi
		genmc(m_mov,cx:=genreg(reg+1,ax.size),bx)
		genmc(m_idiv,cx)
	fi
else

	bx:=genint(n)

	if opc=m_imul then
		genmc(m_shl,ax,bx)
	else
		genmc(m_ishr,ax,bx)
	fi
fi
return ax
end

function dx_divto(unit p,a,b, int regx)ref opndrec=
ref opndrec work, rhs, ptropnd, ax
int reg,tx,opc,sgned

case gettypecat(b)
when 'R' then
	return dx_faddto(m_idiv,a,b,regx)
when 'I' then
	opc:=(p.tag=j_divto|m_idiv|m_irem)
	sgned:=1
else
	opc:=(p.tag=j_divto|m_udiv|m_urem)
	sgned:=0
esac

reg:=(regx|regx|xr0)

if reg<>r0 then
	GERROR("DIVTO: not R0")
fi
work:=genreg(reg,getopndsize_u(b))
++reg

if issimple(b) then
!CPL "A"
	ptropnd:=getlvalueopnd(a,reg)
!	reg+:=getaregs(ptropnd)
	reg:=getnextreg(ptropnd,reg)
	rhs:=evalexpr(b,reg)
!	reg+:=getlregs(rhs)
	reg:=getnextreg(rhs,reg)

elsif issimple(a) then
	rhs:=evalexpr(b,reg)
!	reg+:=getlregs(rhs)
	reg:=getnextreg(rhs,reg)
	ptropnd:=getlvalueopnd(a,reg)
!	reg+:=getaregs(ptropnd)
	reg:=getnextreg(ptropnd,reg)
else
!CPL "C"
	tx:=saveexpr(b,reg)
	ptropnd:=getlvalueopnd(a,reg)
!	reg+:=getaregs(ptropnd)
	reg:=getnextreg(ptropnd,reg)
	rhs:=restoreexpr(tx,reg)
	++reg
fi

loadviaptr(work,ptropnd,sgned)
genmc(opc,rhs)
genmc(m_mov,ptropnd,changeopndsize(work,ptropnd.size))

return ptropnd
end

function dx_name(unit p,int reg,am)ref opndrec=
ref opndrec ax,bx

!CPL "DXNAME:",=AM,P.DEF.NAME,NAMENAMES[P.DEF.NAMEID],P.DEF.NAME
case p.def.nameid
when procid then
	return genmemaddr_u(p)
!when paramid then
!!CPL "HERE"
!	if isstructunion(p.mode) then
!		ax:=genreg(reg,ptrsize)
!		genmc(m_mov,ax,genmem_u(p))
!		return genireg(ax.reg,ttsize[p.mode])
!	fi
esac

ax:=genmem_u(p)

return ax
end

proc divreg(int reg,int64 x)=
!divide value in register by factor x
ref opndrec rr2
int n

if x>1 then
	if n:=ispoweroftwo(x) then
!		genmc(m_shr,genreg(reg,4),n)
		genmc(m_ishr,genreg(reg,8),genint(n))
	else
		if reg<>r0 then
			GERROR("DIVREG NOT R0")
		fi
		genmc(m_cdq)
		genmc(m_mov,rr2:=genreg(r2,8),genint(x))
		genmc(m_idiv,rr2)
	fi
fi
end

function dx_addrof(unit p,a,int reg,am=1)ref opndrec=
ref opndrec ax,bx
!CPL "DXADDROF"

if a.tag=j_name then
	ax:=genmem_u(a)
else
	ax:=evaladdr(a,reg)
fi

if am<>0 and ax.mode<>a_reg then
	genmc(m_lea, bx:=genreg(reg,ptrsize),ax)
	return bx
fi

return ax
end

function dx_dot(unit p,a,b, int reg,am)ref opndrec=
!return from here is always a memory address mode, whatever am is
!(when am=0, then caller might do lea rather than mov)
ref opndrec ax,rx
!
!CPL "DXDOT",=P.OFFSET

!CPL "DOT0"
ax:=evalexpr(a,reg)
!CPL "DOT1",=STROPND(AX),AX.SIZE

!ax:=applyoffset(ax,offset,ttsize[b.def.mode])
ax:=applyoffset(ax,p.offset,ttsize[p.mode])
!CPL "DOT2",=STROPND(AX),AX.SIZE

return ax
end

proc loadviaptr(ref opndrec w, ptropnd, int sgned)=
!load @ptropnd to reg opnd w
!if size of w and ptropnd is same, or w is smaller, then
!load into return w via move
!when widening is needed, then create a narrower w2, and use movsx/movzx
ref opndrec w2

if w.size<=ptropnd.size then
	genmc(m_mov,w, ptropnd)
	return
fi

!w2:=changeopndsize(w,ptropnd.size)

genmc((sgned|m_iwiden|m_uwiden),w,ptropnd)

!return w2
end
=== cc_blockpcl.m 0 0 6/108 ===
[maxnestedloops]int continuestack		!labels for continue/break
[maxnestedloops]int breakstack
int loopindex							!current level of nested loop/switch blocks


const maxswitchrange=500
const maxcases=maxswitchrange
const maxswitchdepth=20

ref[]i32 sw_labeltable			!set from do-switch
ref[]i32 sw_valuetable
int sw_lower
int sw_ncases					!1..n for serial switch; 0 for simple
byte sw_defaultseen				!starts at 0, set to 1 when default: seen
int sw_defaultlabel
int sw_breaklabel

const maxparams=32

global proc do_stmt(unit p) =
	int oldclineno
	unit a, b
	symbol d

	return unless p

	oldclineno:=clineno
	clineno:=p.lineno
	cfileno:=p.fileno
	mmpos:=cfileno<<24+clineno

	a:=p.a
	b:=p.b

	switch p.tag
	when jblock then
		while a do
			do_stmt(a)
			a:=a.nextunit
		od

	when jdecl then
		do_decl(p.def)
!
	when jcallfn then
		dx_call(p, a, b, 0)

	when jreturn then
		do_return(p, a)

	when jassign then
		do_assign(a, b, 0)

	when jif, jifx then
		do_if(a, b, p.c)

	when jfor then
		do_for(a, b)

	when jwhile then
		do_while(a, b)

	when jdowhile then
		do_dowhile(a, b)

	when jgoto then
		do_goto(p.def)

	when jlabelstmt then
		do_labeldef(p.def)
		do_stmt(a)

	when jcasestmt then

		do_casestmt(p, a)

	when jdefaultstmt then
		sw_defaultseen:=1
		pc_gen(klabel, genlabel(sw_defaultlabel))
		do_stmt(a)

	when jbreaksw then
		genjumpl(sw_breaklabel)

	when jbreak then
		genjumpl(breakstack[loopindex])

	when jcontinue then
		genjumpl(continuestack[loopindex])

	when jswitch then
		do_switch(p, a, b)

	when jaddto then
		dx_binto(a, b, kaddto)

	when jsubto then
		dx_binto(a, b, ksubto)

	when jmulto then
		dx_binto(a, b, kmulto)

	when jdivto then
		dx_binto(a, b, (isrealcc(a.mode)|kdivto|kidivto))

	when jremto then
		dx_binto(a, b, kiremto)

	when jiandto then
		dx_binto(a, b, kbitandto)

	when jiorto then
		dx_binto(a, b, kbitorto)

	when jixorto then
		dx_binto(a, b, kbitxorto)

	when jshlto then
		dx_binto(a, b, kshlto)

	when jshrto then
		dx_binto(a, b, kshrto)

	when jpreincr, jpostincr then
		do_preincr(a, kincrto)

	when jpredecr, jpostdecr then
		do_preincr(a, kdecrto)

	when jexprlist then
		while a do
			do_stmt(a)
			a:=a.nextunit
		od

	else
!!assume standalone expression (assign/call/addto/incr done above)
		dx_expr(p)
!		pc_gen(keval)
		pc_gen(kunload)
		setmode_u((a|a|p))

	end switch

end

proc dx_expr(unit p, int am=0) =
	int oldclineno, value, m
	unit a, b
	[256]char str
	symbol d

	return unless p
!CPL "DXEXPR", JTAGNAMES[P.TAG], =am

	oldclineno:=clineno
	clineno:=p.lineno
	cfileno:=p.fileno

	a:=p.a
	b:=p.b
	m:=p.mode

	switch p.tag
	when jconst then
		dx_const(p)

	when jname then
		dx_name(p, am)
!
	when jwidenmem then
		dx_expr(a, am)

	when jfuncname then
		pc_gen(kload, genmemaddr_d(p.def))
		setmode(tu64)

	when jassign then
		do_assign(a, b, 1)
!!
	when jandl, jorl then
		dx_andorl(p)		!use non-short circuit versions for now

	when jnotl then
		if a.tag=jnotl then
			dx_expr(a.a)
			if not isboolexpr(a.a) then
				pc_gen(ktoboolt)
				setmode(tu32)
				setmode2(a.a.mode)
			fi
		else
			dx_expr(a)
			if not isboolexpr(a) then
				pc_gen(ktoboolf)
			else
				pc_gen(knot)
			fi
			setmode_u(a)
		fi

	when jistruel then
		dx_expr(a)
		unless isboolexpr(a) then
			pc_gen(ktoboolt)
			setmode(tu32)
			setmode2(a.mode)
		end

	when jexprlist then
		while a, a:=b do
			b:=a.nextunit

			if b and a.tag in [jassign, jconvert, jifx] then
				do_stmt(a)
			else
				dx_expr(a)
				if b and (a.mode<>tvoid or a.tag=jconvert) then
					pc_gen(keval)
				fi
			fi
		od

	when jcallfn then
		dx_call(p, a, b, 1)

	when jifx then
		dx_ifx(p, a, b, p.c)

	when jeq, jne, jlt, jle, jge, jgt then
		dx_eq(p, a, b)

	when jadd then
		if ttisref[a.mode] and ttsize[b.mode]<=4 then
			b.mode:=tu64
		fi
		dx_bin(a, b, kadd)
!
	when jsub then
		dx_bin(a, b, ksub)
!
	when jmul then
		dx_bin(a, b, kmul)

	when jdiv then
		dx_bin(a, b, (isrealcc(a.mode)|kdiv|kidiv))

	when jrem then
		dx_bin(a, b, kirem)

	when jiand then
		dx_bin(a, b, kbitand)

	when jior then
		dx_bin(a, b, kbitor)

	when jixor then
		dx_bin(a, b, kbitxor)

	when jshl then
		dx_bin(a, b, kshl)

	when jshr then
		dx_bin(a, b, kshr)

	when jptr then
		dx_ptr(p, a, am)

	when  jaddptr then
		dx_addptr(p, a, b, kaddpx, am)
!
	when  jsubptr then
		dx_addptr(p, a, b, ksubpx, am)
!
	when jconvert then
		if p.convmode=tvoid then
			dx_expr(a)
		else
			dx_convert(p, a, p.convmode, p.opcode)
		fi

	when jscale then
		dx_scale(p, a, b)

	when jneg then
		dx_expr(a)
		pc_gen(kneg)
		setmode_u(a)

	when jinot then
		dx_expr(a)
		pc_gen(kbitnot)
		setmode_u(a)

	when jpreincr, jpredecr then
		dx_preincrx(p, a)

	when jpostincr, jpostdecr then
		dx_postincrx(p, a)

	when jaddto then
		dx_binto(a, b, kaddto, 1)

	when jsubto then
		dx_binto(a, b, ksubto, 1)

	when jmulto then
		dx_binto(a, b, kmulto, 1)

	when jdivto then
		dx_binto(a, b, (isrealcc(a.mode)|kdivto|kidivto), 1)

	when jremto then
		dx_binto(a, b, kiremto, 1)

	when jiandto then
		dx_binto(a, b, kbitandto, 1)

	when jiorto then
		dx_binto(a, b, kbitorto, 1)

	when jixorto then
		dx_binto(a, b, kbitxorto, 1)

	when jshlto then
		dx_binto(a, b, kshlto, 1)

	when jshrto then
		dx_binto(a, b, kshrto, 1)

	when jaddrof then
		dx_addrof(p, a, am)

	when jdot then
		dx_dot(p, a, b, am)

	when jsetjmp then
		dx_expr(a)
		pc_gen(ksetjmp)

	when jlongjmp then
		dx_expr(a)
		dx_expr(b)
		pc_gen(klongjmp)

	else
		gerror_s("DX-EXPR: can't do tag: #", jtagnames[p.tag])
	end switch

	clineno:=oldclineno
end

proc dx_const(unit p)=
	int t:=ttbasetype[p.mode]


	if t in tfirstint..tlastint then
		pc_gen(kload, genint(p.value))

	elsecase t
	when tr32 then
		pc_gen(kload, genreal(p.xvalue, tpr32))

	when tr64 then
		pc_gen(kload, genreal(p.xvalue, tpr64))

	elsif t>=tfirstreal and t<=tlastreal then
		pc_gen(kload, genreal(p.xvalue, tpr64))

	elsif t=tref then
		if p.isstrconst then
			pc_gen(kload, genstring(p.svalue, p.slength))
		elsif p.iswstrconst then
			GERROR("CONST/WSTRING")
		else
			pc_gen(kload, genint(p.value))
		fi
	else
		gerror("const?")
	fi
	setmode(p.mode)
end

proc dx_name(unit p, int am)=
	symbol d:=p.def

	case d.nameid
	when staticid, frameid, paramid then
		if am then
			pc_gen(kload, genmemaddr_d(d))
			setmode(tu64)
		else
			pc_gen(kload, genmem_d(d))
			widen(p)
		fi
	else
		gerror("dxname")
	esac
end

proc dx_bin(unit a, b, int opc)=
	dx_expr(a)
	dx_expr(b)

	pc_gen(opc)
	setmode(a.mode)
end

proc dx_binto(unit a, b, int opc, res=0)=
!res=1 means value must be retained

!CPL "BINTO", MCLNAMES[OPC]
	dx_expr(b)
	dx_expr(a, 1)
IF NOT RES and opc not in [kidivto, kiremto] THEN
	do_setinplace()
FI

	if res then
		pc_gen(kdupl)
		pc_genxy(kswapstk, 2, 3)
	fi
	pc_gen(opc)
	setmode(getmemmode(a))

	if res then
		pc_gen(kiload)				!don't need genix, as previous op is only addto etc
		setmode(getmemmode(a))
	fi
!	dx_expr(b)
!	if res then pc_gen(kdupl) fi
!	dx_expr(a, 1)
!	pc_gen(getopc(opc, a))
!	setmode(getmemmode(a))
end

proc do_assign(unit a, b, int res)=

	do_fixwiden(a, b)

	dx_expr(b)

	if res then
!		pc_gen(kdupl)
		pc_gen(kdouble)
	fi

	case a.tag
	when jname then
		pc_gen(kstore, genmem_d(a.def))
		setmode(getmemmode(a))

	when jptr then
		dx_expr(a, 1)
		pc_genix(kistore)
		setmode(getmemmode(a))

	when jdot then
		dx_expr(a.a, 1)
		pc_gen(kload, genint(a.offset))
		setmode(tu64)
		pc_genix(kaddpx)
		pc_setscaleoff(1)
		setmode(getmemmode(a))

		pc_genix(kistore)
		pc_setscaleoff(1)
		setmode(getmemmode(a))

	else
		GERROR_S("DOASSIGN not ready: #", jtagnames[a.tag])
	esac
end

proc dx_ptr(unit p, a, int am)=
	dx_expr(a)
	if am=0 then				!for &, exit with pointer value
		pc_genix(kiload)
		widen(p)
	fi
end

proc dx_addptr(unit p, a, b, int opc, am)=
	dx_expr(a)
	dx_expr(b)
	pc_genix(opc)
	pc_setscaleoff(p.ptrscale)

	setmode(a.mode)
end

proc dx_addrof(unit p, a, int am)=
	dx_expr(a, 1)
end

proc dx_convert(unit p, a, int t, opc)=
!convert unit a to type t, using conversion opc (uwiden_c etc)
	int s, ssize, tsize

	s:=a.mode

	ssize:=ttsize[s]
	tsize:=ttsize[t]

	dx_expr(a)

	case opc
	when soft_c then
		return
	when hard_c then
!hard is an explicit cast for which no built-in code such as swiden_c has
!been detected. So just do a kind of type-punning, but ensure the sizes
!are correct

!		if stdcat[ttbasetype[s]]=realcat then gerror("Bad cast") fi
		if ttbasetype[s] in [tr32, tr64] then gerror("Bad cast") fi

		if tsize>ssize then			!widen
			pc_gen(kwiden)
		elsif tsize<ssize then
!			recase narrow_c
			goto dotruncate
			return
		fi

	when swiden_c, uwiden_c then
		if ssize=tsize then return fi
		pc_gen(kwiden)

	when sfloat_c, ufloat_c then
		pc_gen(kfloat)

	when sfix_c, ufix_c then
		pc_gen(kfix)

	when fwiden_c then
		pc_gen(kfwiden)

	when fnarrow_c then
		pc_gen(kfnarrow)

	when narrow_c, truncate_c then
dotruncate:
		pc_gen(ktruncate)

		setmode(ti32)
		setmode2(t)
		return

	else
		gerror_s("Convert op not implem: #", convnames[opc])
	esac

	setmode(t)
	setmode2(s)
end

proc do_if(unit a, b, c)=
	int lab1, lab2

	lab1:=createfwdlabel()

	genjumpcond(kjumpf, a, lab1)

	do_stmt(b)

	if c then
		lab2:=createfwdlabel()			!label past else part
		genjumpl(lab2)
		definefwdlabel(lab1)
		do_stmt(c)
		definefwdlabel(lab2)
	else
		definefwdlabel(lab1)
	fi
end

proc genjumpcond(int opc, unit p, int lab)=
!p is some conditional expression of arbitrary complexity
!opc is kjumpf or kjumpt
!evaluate and generate jumps as needed
	unit q, r
	int lab2

	q:=p.a
	r:=p.b

	switch p.tag
	when jandl then
		case opc
		when kjumpf then
			genjumpcond(kjumpf, q, lab)
			genjumpcond(kjumpf, r, lab)
		when kjumpt then
			lab2:=createfwdlabel()
			genjumpcond(kjumpf, q, lab2)
			genjumpcond(kjumpt, r, lab)
			definefwdlabel(lab2)
		esac

	when jorl then
		case opc
		when kjumpf then
			lab2:=createfwdlabel()
			genjumpcond(kjumpt, q, lab2)
			genjumpcond(kjumpf, r, lab)
			definefwdlabel(lab2)
		when kjumpt then
			genjumpcond(kjumpt, q, lab)
			genjumpcond(kjumpt, r, lab)
		esac

	when jnotl then
		case opc
		when kjumpf then
			genjumpcond(kjumpt, q, lab)
		when kjumpt then
			genjumpcond(kjumpf, q, lab)
		esac

	when jistruel then
		genjumpcond(opc, q, lab)

	when jeq, jne, jlt, jle, jge, jgt then

		gcomparejump(opc, p, q, r, lab)

	when jexprlist then
		while q and (r:=q.nextunit) do
			do_stmt(q)
			q:=r
		od

		genjumpcond(opc, q, lab)
	else			!other expression
		dx_expr(p)
		pc_gen(opc, genlabel(lab))
		setmode_u(p)
	end switch
end

proc gcomparejump(int jumpopc, unit p, lhs, rhs, int lab)=
!jumpopc is the base cmdcode needed: kjumpt or kjumpt
!p is the eq/compare unit
!convert into jumpcc cmdcode
	int cond

	cond:=getpclcond(p.tag)			!jeq => keq etc
	if jumpopc=kjumpf then			!need to reverse condition
		cond:=reversecond(cond)		!eqop => neop, etc
	fi

	do_fixwiden(lhs, rhs)

	dx_expr(lhs)
	dx_expr(rhs)

	pc_gen(kjumpcc, genlabel(lab))
	pccurr.condcode:=cond
	setmode_u(lhs)

end

function getpclcond(int op)int=
	case op
	when jeq then return eq_cc
	when jne then return ne_cc
	when jlt then return lt_cc
	when jle then return le_cc
	when jge then return ge_cc
	when jgt then return gt_cc
	esac
	return 0
end

global func reversecond(int cc)int=
!reverse conditional operator
	case cc
	when eq_cc then cc:=ne_cc
	when ne_cc then cc:=eq_cc
	when lt_cc then cc:=ge_cc
	when le_cc then cc:=gt_cc
	when ge_cc then cc:=lt_cc
	when gt_cc then cc:=le_cc
	esac

	return cc
end

proc genjumpl(int lab)=
!generate unconditional jump to label
	pc_gen(kjump, genlabel(lab))
end

proc do_while (unit pcond, pbody) =
	int lab_b, lab_c, lab_d

	if pcond.tag=jconst and pcond.value then
		do_while1(pbody)
		return
	fi

	lab_c:=createfwdlabel()
	lab_d:=createfwdlabel()

	stacklooplabels(lab_c, lab_d)

	genjumpl(lab_c)		!direct to condition code which is at the end

	lab_b:=definelabel()

	do_stmt(pbody)

	definefwdlabel(lab_c)

	genjumpcond(kjumpt, pcond, lab_b)
!	setmode_u(pcond)
	definefwdlabel(lab_d)
	--loopindex
end

proc do_while1 (unit pbody) =
	int lab_b, lab_c, lab_d

	lab_c:=createfwdlabel()
	lab_d:=createfwdlabel()

	stacklooplabels(lab_c, lab_d)

	lab_b:=definelabel()

	do_stmt(pbody)

	definefwdlabel(lab_c)

	genjumpl(lab_b)
	definefwdlabel(lab_d)
	--loopindex
end

proc do_dowhile (unit pbody, pcond) =
	int lab_b, lab_c, lab_d

	lab_c:=createfwdlabel()
	lab_d:=createfwdlabel()

	stacklooplabels(lab_c, lab_d)

	lab_b:=definelabel()

	do_stmt(pbody)

	definefwdlabel(lab_c)

	unless iscondfalse(pcond) then
		genjumpcond(kjumpt, pcond, lab_b)
	end


	definefwdlabel(lab_d)
	--loopindex
end

proc stacklooplabels(int a, b)=
	!don't check for loop depth as that has been done during parsing
	continuestack[++loopindex]:=a
	breakstack[loopindex]:=b
end

proc do_return(unit p, a)=
	psymbol e

	if a then

		if currproc.ismain and not pdcc then
			dx_expr(a)
			pc_gen(kstop)
		else
			dx_expr(a)
			pc_gen(kjumpret, genlabel(retindex))
			setmode_u(a)
		fi
	else
		genjumpl(retindex)
	fi
end

proc dx_call(unit p, a, b, int res)=
	ref paramrec pm
	int isfnptr, variadic, nparams, retmode, nbytes, retsize, m, nvariadics
	int nfixedparams, isfn, blockret
	[maxparams]unit paramlist
	[maxparams]byte paramconst			!1 when 'const' (up to nfixedparams only)
	[maxparams]i8 argattr
	int iparams, fparams
	symbol dblock, dtemp
	unit q

	retmode:=p.mode
	if retmode=tvoid then retmode:=ti32 fi

	isfn:=0

	case a.tag
	when jptr then
		m:=a.mode
		while ttbasetype[m]=tref do
			m:=tttarget[m]
		od

!		isfn:=tttarget[m]<>tvoid and res
		isfn:=tttarget[m]<>tvoid
		pm:=ttparams[m]
		isfnptr:=1

	else
		pm:=a.def.paramlist
		isfnptr:=0
!		isfn:=a.def.mode<>tvoid and res
		isfn:=a.def.mode<>tvoid

	esac

	variadic:=pm.flags=pm_variadic
	nfixedparams:=pm.nparams
	nparams:=nvariadics:=0

	q:=b
	while q, q:=q.nextunit do
		if nparams>=maxparams then gerror("maxparams") fi
		paramlist[++nparams]:=q
		paramconst[nparams]:=0

		if variadic and nparams>nfixedparams and nparams<=4 and nvariadics=0 then
			nvariadics:=nparams
		fi
		if nparams<=nfixedparams then
			paramconst[nparams]:=ttconst[pm.mode]
			pm:=pm.nextparam
		fi
	od

	pc_gen(ksetcall)

	setmode_u(p)
	pccurr.nargs:=nparams

	iparams:=fparams:=0

	for i to nparams do
		q:=paramlist[i]
		if q.mode in [tr32, tr64] then
			argattr[i]:=-(++fparams)
		else
			argattr[i]:=++iparams
		fi
	od

	for i:=nparams downto 1 do			!downto 
		q:=paramlist[i]
		dx_expr(q)

		if nvariadics and i>=nvariadics and pccurr.mode=tpr32 then
			pc_gen(kfwiden)
			pccurr.mode:=tpr64
			pccurr.mode2:=tpr32
		fi

		pc_gen(ksetarg)
		setmode_u(q)
		pccurr.x:=i
		pccurr.y:=argattr[i]
	od

	if not isfnptr then
		pc_gen((isfn|kcallf|kcallp), genmemaddr_d(a.def))
	else
		dx_expr(a.a)
		pc_gen((isfn|kicallf|kicallp))
	fi

	pccurr.nargs:=nparams
    pccurr.nvariadics:=nvariadics

	if isfn then
		setmode(getmemmode(p))
		if not res then
			pc_gen(kunload)
			setmode(getmemmode(p))
		else
			widen(p)
		fi
	fi

end

proc do_decl(symbol d)=
	unit a

	a:=d.code
	d.used:=1
	if d.pdef then d.pdef.used:=1 fi

	if a.tag<>jmakelist then
		if ttbasetype[d.mode]=tarray and a.tag=jconst then	!probably string lit
			goto copyl
		fi
		dx_expr(a)
		pc_gen(kstore, genmem_d(d))
		setmode(a.mode)
		return
	fi

copyl:
	pc_gen(kload, genmem(d.pdata))

	setmode(d.mode)
	pc_gen(kstore, genmem_d(d))
	setmode(d.mode)
end

proc do_for (unit pinit, pbody) =
	unit pcond, pincr
	int lab_b, lab_c, lab_d, lab_cond

	pcond:=pinit.nextunit
	pincr:=pcond.nextunit

	lab_c:=createfwdlabel()
	lab_d:=createfwdlabel()
	lab_cond:=createfwdlabel()

	if pinit.tag<>jnull then
		do_stmt(pinit)
	fi

	genjumpl(lab_cond)		!direct to condition code which is at the end

	stacklooplabels(lab_c, lab_d)

	lab_b:=definelabel()

	do_stmt(pbody)

	definefwdlabel(lab_c)

	do_stmt(pincr)
	definefwdlabel(lab_cond)

	if pcond.tag<>jnull then
		genjumpcond(kjumpt, pcond, lab_b)
	else
		genjumpl(lab_b)
	fi
	definefwdlabel(lab_d)
	--loopindex
end

proc do_preincr(unit a, int incrop)=
	dx_expr(a, 1)
	do_setinplace()
	pc_gen(incrop)
!	setmode_u(a)
	setmode(getmemmode(a))

	setincrstep(a.mode)
end

proc setincrstep(int m)=
	pc_setincr(1)

	if ttisref[m] then
		pc_setincr(ttsize[tttarget[m]])
	fi
end

proc dx_preincrx(unit p, a)=
	dx_expr(a, 1)
	do_setinplace()

	pc_gen((p.tag=jpreincr|kincrload|kdecrload))
	setincrstep(a.mode)

	WIDEN(A)

end

proc dx_postincrx(unit p, a)=
	dx_expr(a, 1)
	do_setinplace()

	pc_gen((p.tag=jpostincr|kloadincr|kloaddecr))
	setincrstep(a.mode)
	WIDEN(A)
end

proc dx_dot(unit p, a, b, int am)=
	dx_expr(a, 1)
	pc_gen(kload, genint(p.offset))
	setmode(tu64)

	if am=0 then
		pc_genix(kaddpx)
		setmode(getmemmode(p))
		pc_setscaleoff(1)

		pc_genix(kiload)
		widen(p)
	else
		pc_genix(kaddpx)
		setmode(getmemmode(p))
		pc_setscaleoff(1)

	fi

end

proc dx_eq(unit p, a, b)=
!apply =, <= etc between a and b, and get a logical result 1 or 0

	do_fixwiden(a, b)

	dx_expr(a)
	dx_expr(b)

	pc_gen(ksetcc)
	pccurr.condcode:=getpclcond(p.tag)
	setmode_u(a)
end

proc do_labeldef(symbol d)=
	if d.index<=0 then			!not already dealt with via goto
		d.index:=++mlabelno
	fi

	gencomment(d.name)
	pc_gen(klabel, genlabel(d.index))
end

proc do_goto(symbol d)=
	if d.index=0 then
		gerror_s("Label not defined: #", d.name)
	elsif d.index<0 then
		d.index:=++mlabelno	
	fi
	pc_gen(kjump, genlabel(d.index))
end

proc dx_ifx(unit p, a, b, c)=
	int lab1, lab2, ismult:=p.mode<>tvoid

	lab1:=createfwdlabel()				!dest label of main condition (to end of if, or start if else)
	lab2:=createfwdlabel()

	if ismult then pc_gen(kstartmx) fi
	genjumpcond(kjumpf, a, lab1)

	dx_expr(b)
	if ismult then pc_gen(kresetmx); setmode_u(p) fi

	genjumpl(lab2)
	definefwdlabel(lab1)

	dx_expr(c)
	if ismult then pc_gen(kendmx); setmode_u(p) fi

	definefwdlabel(lab2)
end

proc do_casestmt(unit p, a)=
	int value

	if sw_ncases=0 then
		pc_gen(klabel, genlabel(sw_labeltable[p.value-sw_lower+1]))
	else
		value:=p.value
		for i:=1 to sw_ncases do
			if sw_valuetable[i]=value then
				pc_gen(klabel, genlabel(sw_labeltable[i]))
				exit
			fi
		else
			gerror("case: serial switch not found")
		od
	fi
	do_stmt(a)
end

proc do_switch(unit p, a, b)=
!need to create switch levels, as they can be nested; nested case labels
!belong to the top switch level
	[maxswitchrange]i32 labeltable				!sw_length+1 labels
	[maxcases]i32 valuetable					!sw_length+1 labels
	[maxswitchrange]byte flags					!flags to check dupl values
	int defaultlabel							!index of fwd default label
	int breakswlabel							!index of fwd break label
	int switchlabel								!index of fwd break label
	int lower, upper							!ower/upper ranges of switch case values
	int length, value, ncases
	byte serialsw
	int i, index
!int sw_index
	ref caserec pcase

!store current set of global values for outer switch
	ref[]i32 old_labeltable
	ref[]i32 old_valuetable
	int old_ncases, old_lower
	byte old_defaultseen
	int old_defaultlabel
	int old_breaklabel

	pcase:=p.nextcase
	ncases:=length:=0

	while pcase do
		++ncases
		if ncases>maxcases then
			gerror("Too many cases on one switch")
		fi
		valuetable[ncases]:=value:=pcase.value

		if ncases=1 then
			lower:=upper:=value
		else
			lower:=min(lower, value)
			upper:=max(upper, value)
		fi
		pcase:=pcase.nextcase
	od

	if p.nextcase then
		length:=upper-lower+1
	else
		length:=0
	fi 

!allocate fwd labels
	defaultlabel:=createfwdlabel()		!(when no default:, same as breakswlabel)
	breakswlabel:=createfwdlabel()

!	if length>maxswitchrange then
	if length>maxswitchrange OR NCASES<=8 then

!NOTES: SERIAL switch needs a way of checking duplicate case values.
!Better if not an n-squared search
!Short length switches should also be done serially (length<=8)
!Then a dupl check is simpler

		serialsw:=1

!		ax:=loadexpr(a)
		dx_expr(a)

		for i:=1 to ncases do
!CPL "CASE", I, VALUETABLE[I]
			labeltable[i]:=createfwdlabel()
!			if i<ncases then
!				pc_gen(kdouble)
!			fi
			pc_gen(kload, genint(valuetable[i]))
			setmode(ti32)
			pc_gen(kjumpcc, genlabel(labeltable[i]))
			setmode(ti32)
			pccurr.condcode:=eq_cc
			if i<ncases then
				pccurr.popone:=1
			fi

		od

		genjumpl(defaultlabel)

	elsif length=0 then
		genjumpl(defaultlabel)

	else
		serialsw:=0
		memset(&flags, 0, length)				!clear value flags

!fill table with defaults first
		for i:=1 to length do
			labeltable[i]:=defaultlabel
		od

!now, do labels for each case value
		for i:=1 to ncases do
			value:=valuetable[i]
			index:=value-lower+1			!index of value within label table
			labeltable[index]:=createfwdlabel()

			if flags[index] then
				gerror_s("Dupl case value: #", strint(value))
			fi
			flags[index]:=1
		od

!need a label for the switchtable itself
		switchlabel:=createfwdlabel()

		dx_expr(a)
		pc_gen(kswitch, genlabel(switchlabel))
		setmode(ti32)
		pc_setxy(lower, lower+length-1)
		pc_gen(kopnd, genlabel(defaultlabel))
		setmode(ti32)
		definefwdlabel(switchlabel)

		for i:=1 to length do
			pc_gen(kswlabel, genlabel(labeltable[i]))
		od
		pc_gen(kendsw)
	fi

!generate code for the switch body
!I need to make available essential tables, offsets etc necessary for j-case
!to be mappable to a label
!note: if already in an outer switch, then must save those earlier vars
!save outer switch vars
	old_labeltable:=sw_labeltable
	old_valuetable:=sw_valuetable
	old_lower:=sw_lower
	old_ncases:=sw_ncases
	old_defaultseen:=sw_defaultseen
	old_defaultlabel:=sw_defaultlabel
	old_breaklabel:=sw_breaklabel

!set globals
	sw_labeltable:=&labeltable
	sw_valuetable:=&valuetable		!NEEDED ONLY FOR COMPLEX SWITCH
	sw_lower:=lower

	sw_ncases:=(serialsw|ncases|0)
	sw_defaultseen:=0
	sw_defaultlabel:=defaultlabel
	sw_breaklabel:=breakswlabel

	do_stmt(b)						!switch body

!need to note whether a default label has been generated; if not, define
!default label here
	if not sw_defaultseen then
		definefwdlabel(defaultlabel)
	fi
!define breakswlabel here
	definefwdlabel(breakswlabel)

!restore any values of outer switch statement
	sw_labeltable:=old_labeltable
	sw_valuetable:=old_valuetable
	sw_lower:=old_lower
	sw_ncases:=old_ncases
	sw_defaultseen:=old_defaultseen
	sw_defaultlabel:=old_defaultlabel
	sw_breaklabel:=old_breaklabel
end

proc dx_andorl(unit p)=
!do short-circuit evaluation of a&&b or a||b
!return operand containing 1 or 0
	int lab1, lab2

	lab1:=createfwdlabel()			!dest label of main condition (to end of if, or start if else)

	pc_gen(kstartmx)
	genjumpcond(kjumpf, p, lab1)

	lab2:=createfwdlabel()			!label past else part
	pc_gen(kload, genint(1))
	setmode(ti32)
	pc_gen(kresetmx)
	setmode_u(p.a)
	genjumpl(lab2)

	definefwdlabel(lab1)
	pc_gen(kload, genint(0))
	setmode(ti32)
	pc_gen(kendmx)
	setmode_u(p.a)

	definefwdlabel(lab2)
end

proc dx_scale(unit p, a, b)=
	int opc, scale:=p.scale, n

	dx_expr(a)
	if p.scale>=0 then
		pc_gen(kload, genint(p.scale))
		setmode(ti64)
		pc_gen(kmul)
	else
		pc_gen(kload, genint(-p.scale))
		setmode(ti64)
		pc_gen(kidiv)
	fi
	setmode_u(a)
end

proc widen(unit p) =

	if p.memmode=tvoid then
		setmode(p.mode)
		return
	fi

	int mode:=getmemmode(p)

	setmode(mode)

	if ttsize[mode]<4 and pccurr.opcode in [kload, kiload, kiloadx, 
		kincrload, kdecrload, kloadincr, kloaddecr, kcallf] then
		pc_gen(kwiden)
		setmode((mode in [ti8, ti16]|ti32|tu32))
		setmode2(mode)
	fi
end

proc do_setinplace=
	if pccurr.opcode=kload and pccurr.opndtype=memaddr_opnd then
		pccurr.inplace:=1
	fi
end

proc do_fixwiden(unit a, b)=
!if both widen to same type, then remove the widen
RETURN

!	if a.memmode and a.memmode=b.memmode and a.mode=b.mode then		!widening both
!		a.mode:=a.memmode
!		b.mode:=b.memmode
!		a.memmode:=tvoid
!		b.memmode:=tvoid
!	fi
end

func isboolexpr(unit p)int=

	case p.tag
	when jnotl, jandl, jorl, jeq, jne, jlt, jle, jge, jgt then
		1
	else
		0
	esac
end
=== cc_cli.m 0 0 7/108 ===
enumdata []ichar passnames, []ichar extnames =
	(load_pass,		$,		""),
	(pp_pass,		$,		"i"),
	(parse_pass,	$,		""),
	(type_pass,		$,		""),
	(pcl_pass,		$,		"pcl"),
	(runpcl_pass,	$,		"(int)"),
	(mcl_pass,		$,		"asm"),
	(asm_pass,		$,		"asm"),
	(mx_pass,		$,		"mx"),
	(obj_pass,		$,		"obj"),
	(dll_pass,		$,		"dll"),
	(exe_pass,		$,		"exe"),
	(run_pass,		$,		"(run)"),
end

byte cc_pass			!one of the above, default is link_pass
[20]char dummy
byte debugmode

ichar outfile			!base file
ichar outext="exe"
int cmdskip
int ttt

global byte fverbose=1			!0/1/2 = quiet/normal/extra
global byte fshowincludes=0

global byte dointheaders=1				!allow internal std headers
global byte highmem=1					!0/1/2 = normal/rip only/himem

byte fshowst
byte fshowstflat
byte fshowast
byte fshowpcl
byte fshowpst
byte fshowmcl
byte fshowss
byte fshowtypes
byte fshowfiles
byte fshowpaths
byte fshowheaders
byte fwriteheaders
byte fshowlog
byte fshowtiming
byte fgendll
byte fstdout
byte fshortnames
global byte fwriteerrors=1			!whether to writer $errors.tmp


ichar entrypointname

enumdata []ichar optionnames, []ref byte optvars, []byte optvalues =
	(load_sw,		"load",			&cc_pass,		load_pass),
	(pp_sw,			"e",			&cc_pass,		pp_pass),
	(ppi_sw,		"ei",			&cc_pass,		pp_pass),
	(parse_sw,		"parse",		&cc_pass,		parse_pass),
	(type_sw,		"type",			&cc_pass,		type_pass),
	(pcl_sw,		"p",			&cc_pass,		pcl_pass),
	(pcli_sw,		"pi",			&cc_pass,		pcl_pass),
	(runpcl_sw,		"i",			&cc_pass,		runpcl_pass),
	(mcl_sw,		"mcl",			&cc_pass,		mcl_pass),
	(asm_sw,		"s",			&cc_pass,		asm_pass),
	(asm2_sw,		"a",			&cc_pass,		asm_pass),
	(obj_sw,		"c",			&cc_pass,		obj_pass),
	(obj2_sw,		"obj",			&cc_pass,		obj_pass),
	(mx_sw,			"mx",			&cc_pass,		mx_pass),
	(dll_sw,		"dll",			&cc_pass,		dll_pass),
	(exe_sw,		"exe",			&cc_pass,		exe_pass),
	(run_sw,		"r",			&cc_pass,		run_pass),

!	(asm2_sw,		"asm",			&cc_pass,		asm_pass),

	(noregs_sw,		"noregs",		&fregoptim,		0),
	(nopeep_sw,		"nopeep",		&fpeephole,		0),
	(noopt_sw,		"no",			nil,			0),
!	(opt2_sw,		"o2",			&foptimise,		2),
!	(opt3_sw,		"o3",			&foptimise,		3),
	(noconst_sw,	"noconst",		&fnoconst,		1),

	(paths_sw,		"paths",		&fshowpaths,	1),
	(headers_sw,	"headers",		&fshowheaders,	1),

	(inclpath_sw,	"incl",			nil,			1),
	(showincl_sw,	"includes",		&fshowincludes,	1),
!	(mh1_sw,		"mheaders",		&fmheaders,		'M'),
!	(mh2_sw,		"qheaders",		&fmheaders,		'Q'),

	(showst_sw,		"showst",		&fshowst,		1),
	(showstflat_sw,	"showstflat",	&fshowstflat,	1),
	(showast_sw,	"showast",		&fshowast,		1),
	(showpcl_sw,	"showpcl",		&fshowpcl,		1),
	(showpst_sw,	"showpst",		&fshowpst,		1),
	(showmcl_sw,	"showmcl",		&fshowmcl,		1),
	(showss_sw,		"showss",		&fshowss,		1),
	(showtypes_sw,	"showtypes",	&fshowtypes,	1),
	(showfiles_sw,	"showfiles",	&fshowfiles,	1),

	(time_sw,		"time",			&fshowtiming,	1),
	(time2_sw,		"time2",		&fshowtiming,	2),
	(v_sw,			"v",			&fverbose,		2),
	(vv_sw,			"vv",			&fverbose,		3),
	(quiet_sw,		"q",			&fverbose,		0),
	(csize_sw,		"cs",			&pverbose,		1),
	(size_sw,		"ss",			&pverbose,		2),
	(help_sw,		"h",			nil,			0),
	(help2_sw,		"help",			nil,			0),
	(ext_sw,		"ext",			&dointheaders,	0),
	(writeheaders_sw,"writeheaders",&fwriteheaders,	1),
	(out_sw,		"o",			nil,			0),
	(stdout_sw,		"stdout",		&fstdout,		1),
	(shortnames_sw,	"shortnames",	&fshortnames,	1),

	(norip_sw,		"norip",		&highmem,		0),
	(himem_sw,		"himem",		&highmem,		2),

	(options_sw,	"options",		nil,			0),
	(showil_sw	,	"showil",		&fshowil,		1),
	(long64_sw	,	"long64",		&flong64,		1),
end

const logfile="mcc.log"

int totallines=0
int nstringobjects=0

![sysparams.len]ichar extraparams	!after ":"
![sysparams.len]ichar extravalues
!int nextraparams=0

int startclock, loadtime, parsetime, pcltime, compiletime
int inittime

proc main=
	ichar file

!CPL =UNITREC.BYTES

	startclock:=os_clock()
PSTARTCLOCK:=STARTCLOCK
	
	starttiming()
	initdata()
!
!FOR S IN OPTIONNAMES DO
!	CPL "-",,S
!OD

	getinputoptions()

CPL =FREGOPTIM
CPL =FPEEPHOLE

	initsearchdirs()

	if fverbose=3 then showsearchdirs() fi

	initlogfile()
	inittime:=gettiming()

	if fverbose then
		fprintln "Compiling # to #", inputfile, outfile
	fi

$PMODULENAME:=PCM_COPYHEAPSTRING(EXTRACTBASEFILE(INPUTFILE))

	do_loadmodule()

	do_preprocess()

	do_parsemodule()

	do_genpcl()

	case cc_pass
	when runpcl_pass then
		pcl_runpcl()

	when mcl_pass then
		do_genmcl()

!	when nasm_pass then
	when asm_pass then
		do_asm()

	when obj_pass then
		do_obj()
		

	when dll_pass then
		do_dll()

	when exe_pass then
		do_exe()

	when mx_pass then
		do_mx()

	when run_pass then
		do_run()

	else
		if cc_pass>=mcl_pass then
			println passnames[cc_pass],"not ready"
		fi
	esac

	if fverbose>=2 then
		println "Done."
	fi

	if fshowtiming then
		showtiming()
	fi

	closelogfile()

	stop 0
end

proc do_preprocess=
	if cc_pass=pp_pass then
		lex_preprocess_only(inputfile, outfile, fstdout)
		stop 0
	fi
end

proc do_loadmodule=
!Used for main module. Will always be first module loaded, module list
!will be empty.
!Load file as string
!extract modulename
!call compilemodile(modulename, filename, source)
	ichar modulename
	[300]char path
	int status
	int i,flag

	if fverbose=3 then
		CPL "Loading:",inputfile
	fi
	starttiming()

!set up special module to represent the whole program
	sourcefilenames[0]:="<dummy file>"
	sourcefilepaths[0]:="<dummy path>"
	sourcefiletext[0]:="<sourcefile0>"
	sourcefilesizes[0]:=strlen(sourcefiletext[0])

	stprogram:=createdupldef(nil,addnamestr("$prog"),programid)

	if not checkfile(inputfile) then					!don't use searchdirs
		loaderror("Can't load main module: #",inputfile)
	fi

	mainfileno:=loadsourcefile(inputfile,inputfile)
		
	modulename:=extractbasefile(inputfile)
	stmodule:=createdupldef(stprogram, addnamestr(modulename), moduleid)

	strcpy(path,extractpath(inputfile))
	if path[1] then
		++nsearchdirs
		for i:=nsearchdirs downto 2 do
			searchdirs[i]:=searchdirs[i-1]
		od
		searchdirs[1]:=ref char(pcm_copyheapstring(path))
	fi

	loadtime:=gettiming()
end

proc do_parsemodule=
	int tt
	starttiming()
	parsemodule()
	parsetime:=(tt:=gettiming())
!	if fshowtiming=2 then fprintln "[parse #:#]",inputfiles[m]:"15jl",tt fi

!	showast()
end

proc do_genpcl=
	return unless cc_pass >= pcl_pass

	starttiming()
	codegen_pcl()
	pcltime:=gettiming()

	pcl_reducetest() when fregoptim or fpeephole

!	if fshowpcl then
!		println @logdev, pcl_writepcl(nil)
!
	if cc_pass=pcl_pass then			!need discrete file
		pcl_writepcl(outfile)
	fi

!	if fshowpst then
!		pcl_writepst()
!	fi

end

proc do_genmcl=
	return unless cc_pass >= mcl_pass

	if cc_pass=mcl_pass then			!need discrete file
		pcl_writeasm(outfile)
	fi
end

proc do_asm=
	return unless cc_pass >= asm_pass
	pcl_writeasm(outfile)
end

proc do_obj=
	return unless cc_pass = obj_pass
	pcl_writeobj(outfile)
end

proc do_dll=
	return unless cc_pass = dll_pass
	pcl_writedll(outfile)
end

proc do_exe=
	return unless cc_pass = exe_pass
CPL "DOEXE"
	pcl_writeexe(outfile)
end

proc do_mx=
	return unless cc_pass = mx_pass
	pcl_writemx(outfile)
end

proc do_run=
	return unless cc_pass = run_pass
	pcl_exec()
end

proc initlogfile=
	if debugmode>=2 then
		remove(logfile)
		logdev:=cast(fopen(logfile,"w"))
	fi
end

proc closelogfile=
	[100]char str
	int pos

	return unless debugmode>=2


	if fshowmcl and cc_pass>=mcl_pass then
		println @logdev, "PROC ASM"
		println @logdev, pcl_writeasm(nil)
	fi

	if fshowpcl and cc_pass>=pcl_pass then
		println @logdev, "!PROC PCL"
		println @logdev, pcl_writepcl(nil)
		if fshowpst then
			pcl_writepst("PSYMTAB")

			addtolog("PSYMTAB", logdev)
		fi
	fi

	showast()

	if fshowst then
		showst("ST")
	fi

	if fshowstflat then
		showstflat("STFLAT")
	fi

	if fshowtypes then
		printmodelist(logdev)
	fi
!
	fclose(cast(logdev))

	if checkfile("cc.m") then
!CPL "2:PRESS KEY", DEBUGMODE; STOP WHEN OS_GETCH()=27
CPL "PRESS KEY"; STOP WHEN OS_GETCH()=27

		print @str,"\\m\\scripts\\med.bat ",logfile

		os_execwait(str,0,nil)
	else
		println "Diagnostic outputs written to",logfile
	fi
end

proc initdata=
	pcm_init()
	lexsetup()
	inittypetables()
	initcclib()

!init libfiles
	nlibfiles:=0
	libfiles[++nlibfiles]:="msvcrt"
	libfiles[++nlibfiles]:="gdi32"
	libfiles[++nlibfiles]:="user32"
	libfiles[++nlibfiles]:="kernel32"

	igetmsourceinfo:=cast(cgetsourceinfo)

	if pdcc then highmem:=2 fi
	if pdcc then fwriteerrors:=0 fi

end

global func cgetsourceinfo(int pos, ichar &filename, &sourceline)int=
	filename:=sourcefilenames[pos.[24..32]]
	sourceline:="<line>"
	return pos.[0..23]
end

proc initsearchdirs=
	[300]char str1,str2
	int i

	searchdirs[++nsearchdirs]:=""

!	if dointheaders=0 then
		searchdirs[++nsearchdirs]:="c:/cx/headers/"
!	fi

	searchdirs[++nsearchdirs]:=pcm_copyheapstring(extractpath(os_gethostname()))

	for i to nincludepaths when includepaths[i]^ do
		searchdirs[++nsearchdirs]:=includepaths[i]
	od


end

proc showsearchdirs=
	int i

	println "Include search paths:"
	if dointheaders then
		println "0: Internal standard headers (disable with -ext)"
	fi

	for i to nsearchdirs do
		if searchdirs[i]^ then
			println i,,":",searchdirs[i]
		else
			println i,,": ."
		fi
	od
	println
end

proc showast=

	if fshowast then
		printcode(logdev,"PROC AST")
		println @logdev
	fi
end

proc showstflat(ichar caption)=
	println @logdev,"PROC",caption
	printstflat(logdev)
	println @logdev
end

proc showst(ichar caption)=
	println @logdev,"PROC",caption
	printst(logdev, stmodule)
	println @logdev
end

proc showfiles=
	println "Sourcefiles:"

	for i:=1 to nsourcefiles do
		cpl i,":",sourcefilepaths[i],sourcefilenames[i],"Size:",sourcefilesizes[i]
	od
	println
end

proc showtime(ichar caption, int t)=
	fprintln "# # ms # %", caption:"12jl", t:"5", (t*100.0)/compiletime:"5.1jr"
end

proc showtiming=

	compiletime:=os_clock()-startclock

	showtime("Init:",		inittime)
	showtime("Load:",		loadtime)
	showtime("Parse:",		parsetime)
	showtime("PCL:",		pcltime)
	showtime("MCL:",		mcltime)
	showtime("SS:",			sstime)
	showtime("EXE:",		exetime)
	println "-----------------------------"
	showtime("Total:",		compiletime)
end

proc getinputoptions=
	const slash='-'
	int i,j,k
	int paramno,pmtype,sw,ncolons
	ichar name,value,ext

	paramno:=1
	ncolons:=0

	if pc_userunpcl then
		cc_pass:=runpcl_pass
		fverbose:=0
	fi

	if eqstring(extractfile(os_gethostname()),"ci.exe") then
		fverbose:=0
		do_option(runpcl_sw, "")
	fi

	if eqstring(extractfile(os_gethostname()),"cs.exe") then
		fverbose:=0
		do_option(run_sw, "")
	fi

	do
		pmtype:=nextcmdparamnew(paramno,name,value,".c")
		case pmtype
		when pm_option then
			convlcstring(name)
			for sw to optionnames.len do
				if eqstring(name,optionnames[sw]) then
					do_option(sw,value)
					exit
				fi
		else
			println "Unknown option:",name
			stop 1
		od
		when pm_sourcefile then
			if inputfile then
				loaderror("One input file only")
			fi
			inputfile:=pcm_copyheapstring(name)

			if cc_pass in [run_pass, runpcl_pass] then
				cmdskip:=paramno-1+$cmdskip
				pci_target:=cc_pass=runpcl_pass
				exit
			fi
		when pm_libfile then
			if nlibfiles>=maxlibfile then
				loaderror("Too many lib files")
			fi
			libfiles[++nlibfiles]:=pcm_copyheapstring(name)
!		when pm_colon then
!			if ++ncolons>1 then
!				name:=":"
!				value:=nil
!		!		recase pm_extra
!				goto doextra
!			fi
		when 0 then
			exit
		esac
	od

!CPL INPUTFILES[1]

	if cc_pass=0 then
		cc_pass:=exe_pass
		if asmonly then cc_pass:=asm_pass fi
	fi
	if cc_pass in [dll_pass, obj_pass] then
		highmem:=2
	elsif cc_pass in [mx_pass,  run_pass] then
		highmem:=0
	fi
	outext:=extnames[cc_pass]
	if cc_pass in [mcl_pass, asm_pass] then
		outext:=asmext
	fi

	if inputfile=nil and not fwriteheaders then
		showcaption()
		println "Usage:"
		println "    ",,cmdparams[0],"   prog[.c]          Compile prog.c to prog.exe"
		println "    ",,cmdparams[0],"-r prog[.c]          Compile prog.c and run"
		println "    ",,cmdparams[0],"-i prog[.c]          Compile prog.c and interpret"
		println "    ",,cmdparams[0],"-help                Show all options"
		stop 1
	fi

	if fwriteheaders then
		writeheaders()
		stop 20
	fi

	if outfile=nil then
		outfile:=pcm_copyheapstring(changeext(inputfile, outext))
	fi

	pcl_setflags(highmem:highmem, shortnames:fshortnames)
	pcl_cmdskip(cmdskip)
end

proc do_option(int sw, ichar value)=
	[300]char str
	int length
	ref byte p

	p:=optvars[sw]
	if p then
		p^:=optvalues[sw]
!
		if sw in load_sw..mcl_sw then
			debugmode ior:=1
		fi

		if sw in showst_sw..showfiles_sw then
			debugmode ior:=2
		fi

		if sw=runpcl_sw and inputfile then
			loaderror("-RUNP OUT OF ORDER")
		fi
		if sw in [ppi_sw, pcli_sw] then
			pci_target:=1
		fi

!		if sw in exe_sw..ml_sw then
!			outext:=optionnames[sw]
!		fi
		return
	fi

	case sw
	when inclpath_sw then
		if nincludepaths>maxincludepaths then
			loaderror("Too many include paths","")
		fi
		length:=strlen(value)
		case (value+length-1)^
		when '\\', '/' then
		else
			strcpy(str,value)
			strcat(str,"/")
			value:=str
		esac

		includepaths[++nincludepaths]:=pcm_copyheapstring(value)

	when help_sw,help2_sw then	showhelp()

	when out_sw then
		outfile:=pcm_copyheapstring(addext(value,outext))

	when noopt_sw then
		fregoptim:=fpeephole:=0

	when options_sw then
		for i to optionnames.len do
			println "   ",optionnames[i]
		od

	esac
end

proc showincludepaths=
	println "Include paths",nincludepaths
	for i to nincludepaths do
		println i,includepaths[i]
	od
	println
end

proc showhelp=
	showcaption()
	println strinclude "cc_help.txt"

	stop 23
end

proc showextrainfo=
	static ichar infotext=strinclude "info.txt"

	println infotext

	stop 24
end

proc showcaption=
	println "CC C Compiler 7.x"
end

proc starttiming =
	ttt:=os_clock()
end

func gettiming:int=
	os_clock()-ttt
end
=== cc_decls.m 0 0 8/108 ===
import clib
global type unit = ref unitrec
global type symbol = ref strec

global const maxmodule=200
global const maxlibfile=200
global const maxsourcefile=200

global macro pr(a,b) = a<<16+b

global record tokenrec = 		!should be 32-byte record
	union
		i64 value				!64-bit int
		real xvalue				!64-bit float
		u64 uvalue			!64-bit word
		ref char svalue			!pointer to string or charconst (not terminated)
		ref strec symptr		!pointer to symbol table entry for name
	end
	ref tokenrec nexttoken

	u32	lineno
	u8	fileno
	u8	symbol
	u8	subcode
	u8	flags

	i32 length					!length of name/string/char
	union
		i32 numberoffset			!offset of numeric token within file[fileno]
		i16 paramno				!for macro params
		i16 pasteno
	end
end

global record mparamrec =
	ref strec def
	ref mparamrec nextmparam
end

global record caserec =
	ref caserec nextcase
	int value
end

!param lists always have at least one 'parameter':
! ()				nparams=0	flags=pm_notset		mode=tnone
! (void)			nparams=0	flags=pm_empty		mode=tnone
! (...)				nparams=0	flags=pm_variadic	mode=tnone
! (t,u,v)			nparams=3	flags=0				mode=t (on 1st param)
! (t,u,v,...)		nparams=3	flags=pm_variadic	mode=t (on 1st param)

global record paramrec =
	ref strec def			!named param: st entry, otherwise nil
	ref paramrec nextparam
	i32 mode				!tnone when there are no normal params
	i16 nparams			!used on first param only
	i16 flags				!used on first param only
end

!mask bits for .flags of tokenrec; these can be combined if both are true
global const tk_macromask = 1		!is a name that is a macro def
global const tk_parammask = 2		!is a name that is a param def
global const tk_macrolit  = 4		!is an processed token that is a macro name
global const tk_pasted    = 8

global record fieldrec = 			!linear list of fields/anon fields in a struct
	ref strec def
	ref strec gendef				!generic version of def
	ref fieldrec nextfield			!list may be created in reverse order
	int offset						!offset from start of struct
end

global record strec =
	ichar name
	ref strec owner
	ref strec deflist
	ref strec deflistx
	ref strec nextdef
	ref strec nextdupl
	ref strec prevdupl
	psymbol pdef

	union
		ref paramrec nextparam
		ref unitrec callchain
		ref strec nextmacro
		ref fieldrec nextfield
	end
	union
		ref unitrec code
		ref tokenrec tokenlist
	end
	union
!		ref strec paramlist
		ref paramrec paramlist
		ref mparamrec mparamlist
		ichar macrovalue
	end
	union
		i32 index					!enum/label index
		i32 offset
		i32 labelno				!normally used as .index
		byte oldsymbol				!for #define/#undef on keyword
	end

	u32 lineno
	union
		struct
			u16 blockno
			u16 namespace				!experimental: set to namespaces[.nameid]
		end
		u32 nsblock						!combined block no and namespace
	end

	i16 subcode
	u16 mode

	u16 nrefs
	byte namelen
	byte symbol

!	byte flags:(addrof:1, varparams:1, flmacro:1, used:1, ismain:1)
	byte flags:(addrof:1, varparams:1, flmacro:1, ismain:1, exported:1)
	byte nameid
	byte scope					!linkage type
	byte nparams				!no. formal params for procid/dllprocid

	byte align					!1, 2, 4, 8; max align for struct/union
	byte fileno

	psymbol pdata				!symbol such as $mod.func.name.1 for makelist data
	byte used
	[5]byte spare
end

global record fwdrec =
	ref fwdrec nextfwd
	i32 offset
	i16 reltype
	i16 seg
end

global record unitrec =
	union
		ref strec def
		i64 value
		u64 uvalue
		real xvalue
		ichar svalue
		ref u16 wsvalue
		ref strec labeldef
		ref caserec nextcase
		i32 ptrscale			!use for derefoffset/addoffset
		i32 offset				!for jdot
	end
	ref unitrec nextunit
	ref unitrec a	!single items, or linked lists
	ref unitrec b
	ref unitrec c

	i32 tag			!kcode tag number
	u32 lineno			!source lineno associated with item; fileno is in top byte

	union
		i32 opcode			!for conversion
		i32 index				!label index
		u32 uindex			!case index
		i32 slength			!for const/string
		i32 wslength
		i32 alength			!for deref units, length of any array before conversion to ptr
		i32 scale			!for scale unit (negative means divide)
		i32 aparams			!callfn/proc: no. actual params
		i32 count			!makelist, no. items
	end

	i32 mode
	i16 memmode				!none, or memmode for name, ptr etc
	i16 convmode				!conversion dest type
	byte fileno
	byte isstrconst			!for string consts: initialised with "..."
	byte iswstrconst
	byte spare1
end

global record dllprocrec =
	ichar name
	ref proc address
	int dllindex
end

global record procrec =
	ref strec def
	ref procrec nextproc
end
!
!global const int maxtype=20'000
!global const int maxtype=60'000
global const int maxtype=80'000

global int ntypes

global [0:maxtype]ref strec	ttnamedef
global [0:maxtype]i16	ttbasetype			!basic t-code
global [0:maxtype]int	ttlength			!0, or array length
global [0:maxtype]byte	ttconst				!1 when const
global [0:maxtype]i16	tttarget			!pointer target or array elem type
global [0:maxtype]i16	ttreftype			!0, or index of type that is a pointer to this one
global [0:maxtype]i16	ttconsttype			!0, or index of type that is a const version of this oneointer to this onee
global [0:maxtype]int	ttsize				!byte size
global [0:maxtype]byte	ttisref
!global [0:maxtype]byte	ttcat
global [0:maxtype]byte	ttisblock
global [0:maxtype]byte	ttsigned			!set up in genmcl
global [0:maxtype]i32	ttshared			!no. of shared instances
global [0:maxtype]ref paramrec ttparams		!for modes involving function pointers
global [0:maxtype]ref strec tttypedef

global int trefchar							!set to to char* type
global int trefwchar						!set to to wchar* type

global ichar inputfile
global int mainfileno
global [0..maxlibfile]ichar libfiles
global [0..maxsourcefile]ichar sourcefilenames
global [0..maxsourcefile]ichar sourcefilepaths
global [0..maxsourcefile]ichar sourcefiletext
global [0..maxsourcefile]i32 sourcefilesizes

global int nsourcefiles
global int nlibfiles

global const maxsearchdirs=20
global const maxincludepaths=20

global [maxsearchdirs]ichar searchdirs
global int nsearchdirs=0
global [maxincludepaths]ichar includepaths
global int nincludepaths=0

global ref strec stprogram		!root into the symbol table
global ref strec stmodule		!main module

global filehandle logdev		!dest for diagnostics and output of tables


global const sourceext="c"
global ref unitrec nullunit

global int clineno=0		!set in codegen scanner
global int cfileno=0		!set in codegen scanner

global tokenrec lx				!provides access to current token data
global tokenrec nextlx

!global int tlex=0		!timing

global int debug=0

!global int hstsize	= 16384
global int hstsize	= 65536

global int hstmask				!filled in with hstsize-1

global ref[0:]ref strec hashtable

global const maxblock=2100,maxblockstack=100
global [0..maxblock]i32 blockowner
global [0..maxblock]i32 blockcounts
global [0..maxblockstack]i32 blockstack
global int currblockno,nextblockno,blocklevel
global ref strec currproc

global const maxnestedloops=64

global ichar dheaderfile=nil			!result of -d:file.h switch

global int structpadding=1
global int callbackflag=0

global int slineno,sfileno

global ichar oemname="MCC"

global ichar mclstr
global int mclstrlen

global int nunits

global const maxpmodule = maxmodule-1
global const maxpheader = 100
global const maxplib = 100

global [maxpmodule]ichar pmodulelist
global [maxpheader]ichar pheaderlist
global [maxplib]ichar pliblist

global int npmodules
global int npheaders
global int nplibs

global byte pci_target			!1 when using -runp

!GLOBAL INT NALLCALLS
!GLOBAL INT NUSESTACK
!GLOBAL INT NUSEMIXEDSTACK
=== cc_export.m 0 0 9/108 ===
strbuffer mmbuffer
ref strbuffer mm=&mmbuffer

global proc writemheader(ichar infile)=
	[300]char mfile
	ref strec d,e
	int m
	ref mparamrec q

	strcpy(mfile,pcm_copyheapstring(changeext(infile,(fmheaders='M'|".m"|".q"))))

	gs_init(mm)

	mmstr("importdll $")
	mmstr(extractbasefile(infile))
	mmstrln(" =")

	d:=stmodule.deflist

	while d do
		if isheaderfile(sourcefilenames[d.lineno>>24]) then
			d:=d.nextdef
			nextloop
		fi
		case d.nameid
		when staticid then
			mmstr("    ")
			mmmode(d.mode)
			mmstr(" ")
			mmstr(fixname(d.name))
			if d.code then
				mmstr(" =")
				mmstr(strexpr(d.code).strptr)
			fi
			mmline()

		when procid then
			writefunction(d)
		when typeid then
		when enumid then
			mmstr("    const ")
			mmleftstr(fixname(d.name),34)
			mmstr(" = ")
			mmint(d.index)
			mmline()

		when macroid then
			mmstr("macro ")
			mmstrln(fixname(d.name))
		when structtagid then
			writerecord(d.mode)
		esac
		d:=d.nextdef
	od
	mmstrln("end")

	for i:=0 to hstmask do
		e:=hashtable^[i]
		if e.name and e.symbol=namesym and e.nameid=macroid then
			if not isheaderfile(sourcefilenames[e.lineno>>24]) then
				if e.tokenlist then
					if e.tokenlist.nexttoken=nil and
						e.tokenlist.symbol in [intconstsym, realconstsym, namesym] then
						mmstr("global const ")
					else
						mmstr("global macro  ")
					fi
					mmstr(e.name)

					q:=e.mparamlist
					if q then
						mmstr("(")
						while q do
							mmstr(q.def.name)
							if q.nextmparam then
								mmstr(",")
							fi
							q:=q.nextmparam
						od

						mmstr(")")
					fi

					mmstr(" = ")
					showmacroseq(e.tokenlist)
					mmline()
				fi
			fi

		fi
	od

	println "Writing M Header:",mfile
	writefile(mfile,cast(mm.strptr),mm.length)

end

proc showmacroseq(ref tokenrec tk)=
	while tk do
		emittoken(tk,mm)
	tk:=tk.nexttoken
	od
end

proc mmstr(ichar s)=
	gs_str(mm,s)
end

proc mmleftstr(ichar s,int n)=
	gs_leftstr(mm,s,n)
end

proc mmstrln(ichar s)=
	gs_strln(mm,s)
end

proc mmint(int a)=
	[32]char str
	getstrint(a,str)
	gs_str(mm,str)
end

proc mmline()=
	gs_line(mm)
end

proc writefunction(ref strec d)=
	ichar file
	ref paramrec pm
	int n,isvar

	if d.mode=tvoid then
		mmstr("    proc ")
	else
		mmstr("    func ")
	fi
	mmstr("""")

	mmstr(d.name)

	mmstr("""")
	mmleftstr(" ",34-strlen(d.name))
	mmstr("(")

	pm:=d.paramlist
	n:=pm.nparams
	isvar:=pm.flags=pm_variadic
	for i to n do
		mmmode(pm.mode)
		if i<>n or isvar then
			mmstr(",")
		fi
		pm:=pm.nextparam
	od
	if isvar then
		mmstr("...")
	fi

	mmstr(")")

	if d.mode<>tvoid then
		mmmode(d.mode)
	fi

	mmline()
end

proc mmmode(int m,expand=1) =
	int t,u

	t:=ttbasetype[m]
	case t
	when tref then
		mmstr("ref ")
		u:=tttarget[m]
		if ttbasetype[u]=tproc then
			mmstr("void")
		else
			mmmode(tttarget[m])
		fi

	when tarray then
		mmstr("[")
		if ttlength[m] then
			mmint(ttlength[m])
		fi
		mmstr("]")
		mmmode(tttarget[m])

	when tenum then
		mmstr("int")

	when tstruct,tunion then
		mmstr(fixname(ttnamedef[m].name))

	when tproc then
		MMSTR("<PROC>")
	else
		mmstr(stdtypenames[t])
	esac
end

proc writerecord(int m, rectype='R', level=1)=
	ref strec d,e
	int emode

	to level do
		mmstr("    ")
	od
	++level

	d:=ttnamedef[m]
	if rectype='R' then
		if fmheaders='M' then
			mmstr("record ")
			mmstr(fixname(d.name))
			mmstrln(" = $caligned")
		else
			mmstr("type ")
			mmstr(fixname(d.name))
			mmstrln(" = struct $caligned")
		fi
	else
		mmstrln((rectype='S'|"struct"|"union"))
	fi

	e:=d.deflist
	if e=nil then
		to level do
			mmstr("    ")
		od
		mmstrln("int dummy    !empty record")
	fi

	while e do
		emode:=e.mode
		to level do
			mmstr("    ")
		od

		if strchr(e.name,'$') then
			case ttbasetype[emode]
			when tunion then
				writerecord(emode,'U',level)
			when tstruct then
				writerecord(emode,'S',level)
			esac
		else
			mmmode(e.mode)
			mmstr(" ")
			mmstrln(fixname(e.name))
		fi
		e:=e.nextdef
	od
	to level-1 do
		mmstr("    ")
	od
	mmstrln("end")
	mmline()
end

proc writefnptr(int m)=
	ref paramrec pm
	int isvar,n,target


	target:=tttarget[m]


	if target=tvoid then
		mmstr("clang proc(")
	else
		mmstr("clang func(")
	fi

	pm:=ttparams[m]
	n:=pm.nparams
	isvar:=pm.flags=pm_variadic
	for i to n do
		mmmode(pm.mode)
		if i<>n or isvar then
			mmstr(",")
		fi
		pm:=pm.nextparam
	od
	if isvar then
		mmstr("...")
	fi

	mmstr(")")

	if target<>tvoid then
		mmmode(target)
	fi
end

function fixname(ichar name)ichar=
	static []ichar reservedwords = (
		"function",
		"func",
		"read",
		"type",
		"next",
		"stop",
		"callback",
		"len",
		"$dummy"
	)
	[128]char str

	for i to reservedwords.len do
		if eqstring(reservedwords[i],name) then
			strcpy(str,name)
			strcat(str,"$")
			return pcm_copyheapstring(str)
		fi
	od

	return name
end
=== cc_genpcl.m 0 0 10/108 ===

global int retindex
global int initstaticsindex

const maxnestedloops	= 50

global [maxnestedloops,4]int loopstack
global int loopindex							!current level of nested loop/switch blocks

unitrec zero_unit
global unit pzero=&zero_unit
!symbol dcmdskip

int nvarlocals, nvarparams

macro divider = gencomment("------------------------")

global proc codegen_pcl=
!generate code for module n
	symbol d,e
	ref procrec pp

	if fverbose=3 then println "GenPCL:",inputfile fi

	pcl_start(nil, nunits)

	dolibs()

!do two passes: module decls first, then procs
	gencomment("1:Start of code")

	d:=stmodule.deflist
	while d do
		case d.nameid
		when staticid then
			dostaticvar(d)
		when procid then
			case d.scope
			when exported_scope then
				if d.code=nil then d.scope:=imported_scope fi
			when local_scope then
				if d.code=nil then gerror_s("Static fn not defined: #",d.name) fi
			esac
	
			e:=d.deflist
			while e do
				case e.nameid
				when staticid then
					dostaticvar(e)
				when frameid then
					if e.code then
						if e.code.tag=jmakelist or 
						    ttbasetype[e.mode]=tarray and e.code.tag=jconst then
							dostaticvar(e)
						fi
					fi
				esac
				e:=e.nextdef
			od

		esac
		d:=d.nextdef
	od
	gencomment("")
!	gencomment("Procs:")

	d:=stmodule.deflist
	while d do
		case d.nameid
		when procid then
			if d.code then
				genprocdef(d)
			fi
		esac
		d:=d.nextdef
	od

	pcl_end()

end

proc genprocdef (symbol p) =
	symbol d
	psymbol e
	ref paramrec pm
	int ismain:=0

	if eqstring(p.name,"main") then
		ismain:=1
		p.ismain:=1
	fi
!
	currproc:=p

	pc_defproc(e:=getpsymbol(p), isentry:ismain)
	e.variadic:=p.paramlist.flags=pm_variadic

!INT NLOC:=0, NPARAMS:=0
	d:=p.deflist
	while d, d:=d.nextdef do
		case d.nameid
		when paramid then
			pc_addparam(getpsymbol(d))

		when frameid then
			pc_addlocal(getpsymbol(d))

		esac
	od

	retindex:=createfwdlabel()

	divider()

!	do_enter(p)

	do_stmt(p.code)

	divider()

	if ismain and pdcc then
		pc_gen(kload, genint(0))
		setmode(ti32)
		pc_gen(kjumpret, genlabel(retindex))
		setmode(ti32)
	fi

	definefwdlabel(retindex)

!	do_leave(p)

	if ismain and not pdcc then
		pc_gen(kload, genint(0))
		setmode(ti32)
		pc_gen(kstop)
	fi

	pc_gen((p.mode<>tvoid|kretfn|kretproc))		!mcl checks stack is not empty for retfn
	setmode(p.mode)

	pc_endproc()
!
	gencomment("")
end

proc dostaticvar(symbol d)=
	[256]char str
	int align
	symbol e
	psymbol p

	return when d.scope=imported_scope

	align:=getalignment(d.mode)

	if d.code then
		if d.nameid=frameid then			!const init data for local var
			fprint @str,"$#.#.#",d.owner.name,d.name,d.blockno
			e:=createdupldef(nil,addnamestr(str),staticid)
			p:=getpsymbol(e)
			d.pdata:=p
			pc_gen(kistatic, genmem(p))
		else
			pc_gen(kistatic, genmem_d(d))
		fi

		setmode(d.mode)
		pc_setalign(align)
		genidata(d.code)
	else
		pc_gen(kzstatic, genmem_d(d))
		setmode(d.mode)
		pc_setalign(align)
	fi
end

proc genidata(unit p,int doterm=1,am=1,offset=0)=
	int t,length,n,i,j,nwords,offset1,offset2,size,padding,isunion
	unit q,a,b
	ref strec d
	r32 sx
	[256]char str
	[16]char str2

	t:=p.mode
	a:=p.a
	b:=p.b

	case p.tag
	when jmakelist then
		n:=p.count					!number of supplied params
		if ttbasetype[t]=tarray then
			length:=ttlength[t]			!actual length of array
			q:=a
			for i:=1 to n do
				genidata(q)
				q:=q.nextunit
			od
			if n<length then			!rest will be zeros
				doresb((length-n)*ttsize[tttarget[t]])
			fi
		else
			isunion:=ttbasetype[t]=tunion

			d:=ttnamedef[t].deflist
			size:=ttsize[t]				!total bytes in struct
			offset1:=offset2:=0			!offset so far; 1/2 are in idata/in struct
			q:=a
			for i:=1 to n do
				genidata(q,0)
				offset1+:=ttsize[q.mode]
				d:=d.nextdef
				if d and not isunion then
					offset2:=d.offset
				else
					offset2:=size
				fi

				padding:=offset2-offset1
				if padding>0 then
					doresb(offset2-offset1)
					offset1:=offset2
				fi
				q:=q.nextunit
			od
			if offset2<size then
				doresb(size-offset2)
			fi
		fi
		return
	when jconst then
		if isintcc(t) or isrealcc(t) then
			if t=tr32 then
				sx:=p.xvalue
				pc_gen(kdata,genint(ref u32(&sx)^))
			else

				pc_gen(kdata, genint(p.value))
			fi
			setmode(t)
		elsif ttbasetype[t]=tref then
			padding:=0
	doref:
			if p.value=0 then
				pc_gen(kdata, genint(0))

			elsif p.isstrconst then
				pc_gen(kdata, genstring(p.svalue, p.slength))

			elsif p.iswstrconst then
GERROR("GENIDATA/WSTRING2")
				doresb(padding)
			else
				pc_gen(kdata, genint(p.value))
			fi
			setmode(t)

		elsif ttbasetype[t]=tarray then
			padding:=(ttlength[t]-p.slength)*ttsize[tttarget[t]]
			for i to p.slength do
				pc_gen(kdata, genint((p.svalue+i-1)^))
				setmode(tu8)
			od
			doresb(padding)

		else
			CPL strmode(t)
			GERROR("IDATA/SCALAR")
		fi
		return
	when jname, jfuncname then
		d:=p.def
		case d.nameid
		when staticid,procid then
			pc_gen(kdata, genmemaddr_d(d))
			pccurr.scale:=1
			pccurr.extra:=offset
			setmode(tu64)

		else
			gerror("Idata &frame",p)
		esac	
		return

	when jadd then
		if a.tag=jname and b.tag=jconst then
			d:=a.def
			case d.nameid
			when staticid then
				strcpy(str,"`")
				if d.scope=function_scope then
					strcat(str,currproc.name)
					strcat(str,",")
				fi
				strcat(str,d.name)
				strcat(str,"+")

				getstrint(b.value, str2)

				strcat(str,str2)
				pc_gen(kdata, genname(str))
			else
				gerror("Add/Idata &frame")
			esac	
		elsif a.tag=jconst and b.tag=jconst and ttbasetype[a.mode]=tref then		!ASSUME REF+REF
			print @str,a.value,,"+",,b.value
			pc_gen(kdata, genname(str))

		else
			gerror("1:Runtime or unsupported expr in static data")
		fi
		return

	when jaddrof then
		if a.tag=jptr then
			genidata(a.a,offset:offset)
		else
			genidata(a, am:0,offset:offset)
		fi

	when jaddptr,jsubptr then
		if b.tag<>jconst then gerror("Complex ptr expr in static data") fi
		genidata(a,offset:b.value*p.ptrscale+offset)

	when jconvert then
		genidata(a,offset:offset)

	else
		PRINTUNIT(NIL,P)
		gerror("2:Runtime expr in static data",p)
	esac
end

proc doresb(int n)=
	while n>=8 do
		pc_gen(kdata, genint(0))
		n-:=8
		setmode(tu64)
	od
	to n do
		pc_gen(kdata, genint(0))
		setmode(tu8)
	od

end

proc pushint(int a)=
	pc_gen(kload, genint(a))
end

proc dolibs=
	for i to nlibfiles do
		pc_addplib(libfiles[i])
	od
end

!proc do_enter(symbol d)=
!	[256]char str
!
!	fprint @str,"Enter: #", d.name
!
!	pc_gen(kload, genstring(str))
!	setmode(tu64)
!	pc_gen(kenter)
!end
!
!proc do_leave(symbol d)=
!	[256]char str
!
!	fprint @str,"Leave: #", d.name
!
!	pc_gen(kload, genstring(str))
!	setmode(tu64)
!	pc_gen(kleave)
!end
=== cc_headers.m 0 0 11/108 ===
!Built-in standard headers

global int builtinheaders=1

ichar h_assert		=	strinclude "headers/assert.h"
ichar h_ctype		=	strinclude "headers/ctype.h"
ichar h_errno		=	strinclude "headers/errno.h"
ichar h_fenv		=	strinclude "headers/fenv.h"
ichar h_float		=	strinclude "headers/float.h"
ichar h_inttypes	=	strinclude "headers/inttypes.h"
ichar h_stdint		=	strinclude "headers/stdint.h"
ichar h_limits		=	strinclude "headers/limits.h"
ichar h_locale		=	strinclude "headers/locale.h"
ichar h__ansi		=	strinclude "headers/_ansi.h"
ichar h_math		=	strinclude "headers/math.h"
ichar h_setjmp		=	strinclude "headers/setjmp.h"
ichar h_signal		=	strinclude "headers/signal.h"
ichar h_stdarg		=	strinclude "headers/stdarg.h"
ichar h_stdbool		=	strinclude "headers/stdbool.h"
ichar h_stddef		=	strinclude "headers/stddef.h"
ichar h_stdio		=	strinclude "headers/stdio.h"
ichar h_stdlib		=	strinclude "headers/stdlib.h"
ichar h__syslist	=	strinclude "headers/_syslist.h"
ichar h_string		=	strinclude "headers/string.h"
ichar h_time		=	strinclude "headers/time.h"
ichar h_utime		=	strinclude "headers/utime.h"
ichar h_unistd		=	strinclude "headers/unistd.h"
ichar h_safelib		=	strinclude "headers/safelib.h"
ichar h_wchar		=	strinclude "headers/wchar.h"
ichar h_wctype		=	strinclude "headers/wctype.h"
ichar h_systypes	=	strinclude "headers/sys/types.h"
ichar h_sysstat		=	strinclude "headers/sys/stat.h"
ichar h_systimeb	=	strinclude "headers/sys/timeb.h"
ichar h_sysutime	=	strinclude "headers/sys/utime.h"
ichar h_memory		=	strinclude "headers/memory.h"

!ichar h_windows		=	strinclude "headers/windows.h"

ichar h_fcntl		=	strinclude "headers/fcntl.h"
ichar h_io			=	strinclude "headers/io.h"
ichar h_direct		=	strinclude "headers/direct.h"
ichar h_process		=	strinclude "headers/process.h"
ichar h_malloc		=	strinclude "headers/malloc.h"
ichar h_conio		=	strinclude "headers/conio.h"
ichar h_winsock2	=	strinclude "headers/winsock2.h"
ichar h__mingw		=	strinclude "headers/_mingw.h"
!ichar h_shellapi	=	strinclude "headers/shellapi.h"
ichar h_windowsx	=	strinclude "headers/windowsx.h"

global tabledata []ichar stdhdrnames, []ref ichar stdhdrtext =
	("assert.h",	&h_assert),
	("ctype.h",		&h_ctype),
	("errno.h",		&h_errno),
	("fenv.h",		&h_fenv),
	("float.h",		&h_float),
	("inttypes.h",	&h_inttypes),
	("stdint.h",	&h_stdint),
	("limits.h",	&h_limits),
	("locale.h",	&h_locale),
	("_ansi.h",		&h__ansi),
	("math.h",		&h_math),
	("setjmp.h",	&h_setjmp),
	("signal.h",	&h_signal),
	("stdarg.h",	&h_stdarg),
	("stdbool.h",	&h_stdbool),
	("stddef.h",	&h_stddef),
	("stdio.h",		&h_stdio),
	("stdlib.h",	&h_stdlib),
	("_syslist.h",	&h__syslist),
	("string.h",	&h_string),
	("time.h",		&h_time),
	("utime.h",		&h_utime),
	("unistd.h",	&h_unistd),
	("safelib.h",	&h_safelib),
	("wchar.h",		&h_wchar),
	("wctype.h",	&h_wctype),
	("sys/types.h",	&h_systypes),
	("sys/stat.h",	&h_sysstat),
	("sys/timeb.h",	&h_systimeb),
	("sys/utime.h",	&h_sysutime),
	("malloc.h",	&h_malloc),

!	("windows.h",	&h_windows),

	("fcntl.h",		&h_fcntl),
	("io.h",		&h_io),
	("direct.h",	&h_direct),
	("process.h",	&h_process),
	("memory.h",	&h_memory),
	("conio.h",		&h_conio),
	("winsock2.h",	&h_winsock2),
	("_mingw.h",	&h__mingw),
!	("shellapi.h",	&h_shellapi),
	("windowsx.h",	&h_windowsx)
end

global function findheader(ichar name)ichar=
	int i
	[256]char newname
	ichar s,t

	if strchr(name,'\\') then
		s:=name; t:=newname
		while s^ do
			if s^='\\' then
				t++^:='/'
			else
				t++^:=s^
			fi
			++s
		od
		t^:=0
		name:=newname
	fi

	for i:=1 to stdhdrnames.len do
		if eqstring(name,stdhdrnames[i]) then
			return stdhdrtext[i]^
		fi
	od
	return nil
end

global proc writeheaders=
	filehandle f
	ichar ifile
	int i
	for i:=1 to stdhdrnames.len do
		ifile:=changeext(stdhdrnames[i],"hdr")
		println "Writing internal",stdhdrnames[i],"as",ifile
		f:=fopen(ifile,"wb")
		fwrite(stdhdrtext[i]^,1,strlen(stdhdrtext[i]^),f)
		fclose(f)
	od
end

global function isheaderfile(ichar file)int=
	for i:=1 to stdhdrnames.len do
		if eqstring(stdhdrnames[i],file) then
			return 1
		fi
	od
	return 0
end
=== cc_headersx.m 0 0 12/108 ===
!Built-in standard headers

global int builtinheaders=0

global function findheader(ichar name)ichar=
return nil
end

global proc writeheaders=
filehandle f
ichar ifile
int i
end

global function isheaderfile(ichar file)int=
return 0
end
=== cc_headersy.m 0 0 13/108 ===
!Built-in standard headers

ichar bcclibstr = strinclude "bcclib.asm"

ichar h_bcc			=	strinclude "headers/bcc.h"

global tabledata []ichar stdhdrnames, []ref ichar stdhdrtext =
	("bcc.h",		&h_bcc),
end

global function findheader(ichar name)ichar=
	int i
	[256]char newname
	ichar s,t

	if strchr(name,'\\') then
		s:=name; t:=&.newname
		while s^ do
			if s^='\\' then
				t++^:='/'
			else
				t++^:=s^
			fi
			++s
		od
		t^:=0
		name:=&.newname
	fi

	for i:=1 to stdhdrnames.len do
		if eqstring(name,stdhdrnames[i]) then
			return stdhdrtext[i]^
		fi
	od
	return nil
end

global proc writeheaders=
filehandle f
ichar ifile
int i
for i:=1 to stdhdrnames.len do
	ifile:=changeext(stdhdrnames[i],"hdr")
	println "Writing internal",stdhdrnames[i],"as",ifile
	f:=fopen(ifile,"wb")
	fwrite(stdhdrtext[i]^,1,strlen(stdhdrtext[i]^),f)
	fclose(f)
od
end

global proc checkbcclib=
const libfile="bcclib.asm"
filehandle f

if not checkfile(libfile) then
	println "Writing",libfile
	f:=fopen(libfile,"wb")
	fwrite(bcclibstr,1,strlen(bcclibstr),f)
	fclose(f)
fi
end

global function getbcclib:ichar=
	ichar s
	int slen

	slen:=strlen(bcclibstr)
	s:=malloc(slen+1)
	memcpy(s,bcclibstr,slen+1)

	return s
end

global function isheaderfile(ichar file)int=
for i:=1 to stdhdrnames.len do
	if eqstring(stdhdrnames[i],file) then
		return 1
	fi
od
return 0
end
=== cc_lex.m 0 0 14/108 ===
! (C tokeniser module)
ref tokenrec tkptr=nil

int dowhitespace=0

GLOBAL int NINCLUDES

const mcchdr = "mcc.h"

record stackinforec =
	ref char startptr
	ref char sptr
	i32 lineno
	i32 fileno
end

const maxmacroargs=200
tokenrec normaltkx
ref tokenrec normaltk = &normaltkx			!indicates use lexm to get tokens
int noexpand=0						!inhibit macro expansion for 'defined'

const maxnesting=20
[maxnesting]stackinforec lx_stack
int lx_stackindex
int ifcondlevel=0					!counts #if levels
[maxnesting]ichar headerpathlist	!remember path at each level
[300]char headerpath				!as set up by getsource()

const cr	= 13
const lf	= 10
const tab	= 9

ref char lxstart
ref char lxsptr
int lxhashvalue
ref char lxsvalue

[0..255]char alphamap
[0..255]char digitmap
[0..255]char commentmap
[0..255]char linecommentmap
[0..255]char spacemap

ref strbuffer destcopy
!const int maxpastedtokens=7000
const int maxpastedtokens=87000
[maxpastedtokens]ichar pastedtokenlist
int npastedtokens=0
int isincludefile=0				!whether readng include file name

int firstsymbol=1
ref byte reallxsptr

global int nhstsymbols
int hstthreshold				!limit above which new hst should be generated

global proc lex_preprocess_only(ichar infile, outfile, int toconsole=0)=
	ref char psource
	int ntokens,nlines,fileno,size
	int LENGTH
	i64 nchars,t,hashtot,symtot
	real tsecs
	static strbuffer sbuffer
	static ref strbuffer dest=&sbuffer
	filehandle f

	dowhitespace:=1
	fileno:=loadsourcefile(infile,infile)

	psource:=cast(sourcefiletext[fileno])

	size:=sourcefilesizes[fileno]

	nlines:=ntokens:=0
	hashtot:=symtot:=0
	t:=os_clock()

	destcopy:=dest
	gs_init(dest)

	lxsptr:=psource
	lxstart:=lxsptr
	nextlx.lineno:=1
	setfileno(1)
	ifcondlevel:=0

	stacksourcefile(mcchdr,1)

	nextlx.symbol:=eolsym

	repeat
		lexm()
		++ntokens

!		if showtokens then
			emittoken(&nextlx,dest)
!		fi

	until nextlx.symbol=eofsym

	if ifcondlevel then
		lxerror("#endif missing")
	fi

	if showtokens then
		if toconsole then
			gs_println(dest,nil)
		else
			f:=fopen(outfile,"wb")
			gs_println(dest,f)
			fclose(f)
		fi
	fi
end

global proc lexreadtoken=
!read next token into nextlx
!	int c,csum,hsum,dodir
	word c,csum,hsum,dodir
	ref char p,ss
	ichar searchstr

	nextlx.subcode:=0
	nextlx.flags:=0

!	while lxsptr^=' ' do ++lxsptr od
	while lxsptr^ in [' ','\t'] do ++lxsptr od

	doswitch lxsptr++^
	when 'A'..'Z','a'..'z','$','_' then
doname:
		lxsvalue:=lxsptr-1
		hsum:=lxsvalue^

		while alphamap[c:=lxsptr++^] do
			hsum:=hsum<<4-hsum+c
		od
		--lxsptr
		nextlx.symbol:=namesym
		nextlx.length:=lxsptr-lxsvalue
		case c
		when '\'', '"' then
			if nextlx.length=1 then
				case lxsvalue^
				when 'l','L','u','U' then
					++lxsptr
					lxreadstring(c,1)
					return
				esac
			fi
		esac

		lxhashvalue:=hsum<<5-hsum

!		ss:=pcm_alloc(nextlx.length+1)		!zero-term in lex(), as headers may need to be
!		memcpy(ss,lxsvalue,nextlx.length)	!re-tokenised
!		(ss+nextlx.length)^:=0
!		lxsvalue:=ss

		lookup()						!clash, so do normal lookup to set lxsymptr
		return

	when '1'..'9' then					!can only be decimal
		case lxsptr^
		when ' ',')',cr,',',';' then		!assume single digit decimal
			nextlx.symbol:=intconstsym
			nextlx.subcode:=ti32
			nextlx.value:=(lxsptr-1)^-'0'
			nextlx.length:=1

			setnumberoffset(lxsptr-1-lxstart)
		else
			readdecimal(lxsptr-1)				!note: can also be real const;
		esac
		return

	when '0' then					!0, hex, binary or octal
		switch lxsptr^
		when 'x','X' then
			++lxsptr
			readhex(lxsptr-2)
			return
		when 'b','B' then
			++lxsptr
			readbinary(lxsptr-2)
			return
		when '.' then
			readrealnumber(lxsptr-1,lxsptr-1,1,10)
			return
		when 'u','U','l','L' then
			readdecimal(lxsptr-1)				!note: can also be real const;
			return
		when ',', ')', ']', '}', ';', ' ',':',cr,lf,'&','=','?' then	!assume just zero
			nextlx.symbol:=intconstsym
			nextlx.subcode:=ti32
			nextlx.value:=0
			nextlx.length:=1
			setnumberoffset(lxsptr-1-lxstart)
			return
		else

			readoctal(lxsptr-1)
			return
		end switch					!else assume just zero	

	when '#' then			!
		if nextlx.symbol=eolsym then
			nextlx.symbol:=lexhashsym

			return

		elsif lxsptr^='#' then
			++lxsptr
			nextlx.symbol:=hashhashsym
			return
		else
			nextlx.symbol:=hashsym
			return
		fi

	when '\\' then			!line continuation
		docase lxsptr^
		when cr,lf then
			exit
		when ' ',tab then
			++lxsptr
		else
			nextlx.symbol:=backslashsym
			return
		end docase

		(lxsptr-1)^:=' '	!convert \ to space
		++nextlx.lineno
		case lxsptr^
		when cr then
			++lxsptr			!point to lf
			lxsptr++^:=' '		!set lf to space (so that '#' processing works
		when lf then
			lxsptr++^:=' '
		else
		esac

	when '{' then
		nextlx.symbol:=lcurlysym
		return

	when '}' then
		nextlx.symbol:=rcurlysym
		return

	when '.' then
		switch lxsptr^
		when '.' then				!.. or ...
			++lxsptr
			if lxsptr^='.' then
				++lxsptr
				nextlx.symbol:=ellipsissym
			else
				--lxsptr
				nextlx.symbol:=dotsym
				return
			fi
			return
		when '0'..'9' then			!real const: deal with this after the switch
			--lxsptr
			readrealnumber(lxsptr,lxsptr,0,10)
			return
		else
			nextlx.symbol:=dotsym
			return
		end switch

	when ',' then
		nextlx.symbol:=commasym
		return

	when ';' then
		nextlx.symbol:=semisym
		return

	when ':' then
		case lxsptr^
		when '=' then
			++lxsptr
			nextlx.symbol:=assignsym
		else
			nextlx.symbol:=colonsym
		esac
		return

	when '(' then
		nextlx.symbol:=lbracksym
		return

	when ')' then
		nextlx.symbol:=rbracksym
		return

	when '[' then
		nextlx.symbol:=lsqsym
		return

	when ']' then
		nextlx.symbol:=rsqsym
		return

	when '|' then
		case lxsptr^
		when '|' then
			++lxsptr
			nextlx.symbol:=orlsym
		when '=' then
			++lxsptr
			nextlx.symbol:=iortosym
		else
			nextlx.symbol:=iorsym
		esac
		return

	when '^' then
		if lxsptr^='=' then
			++lxsptr
			nextlx.symbol:=ixortosym
		else
			nextlx.symbol:=ixorsym
		fi
		return

	when '?' then
		nextlx.symbol:=questionsym
		return

	when '~' then
		nextlx.symbol:=inotsym
		return

	when '+' then
		case lxsptr^
		when '+' then
			++lxsptr
			nextlx.symbol:=incrsym
		when '=' then
			++lxsptr
			nextlx.symbol:=addtosym
		else
			nextlx.symbol:=addsym
		esac
		return

	when '-' then
		case lxsptr^
		when '-' then
			++lxsptr
			nextlx.symbol:=decrsym
		when '>' then
			++lxsptr
			nextlx.symbol:=idotsym
		when '=' then
			++lxsptr
			nextlx.symbol:=subtosym
		else
			nextlx.symbol:=subsym
		esac
		return

	when '*' then
		if lxsptr^='=' then
			++lxsptr
			nextlx.symbol:=multosym
		else
			nextlx.symbol:=mulsym
		fi
		return

	when '/' then
		case lxsptr^
		when '/' then					!comment to 
			readlinecomment()
			nextlx.symbol:=eolsym
			nextlx.length:=0
			return
		when '*' then
			readblockcomment()
		when '=' then
			++lxsptr
			nextlx.symbol:=divtosym
			return
		else
			nextlx.symbol:=divsym
			return
		esac

	when '%' then
		if lxsptr^='=' then
			++lxsptr
			nextlx.symbol:=remtosym
		else
			nextlx.symbol:=remsym
		fi
		return

	when '=' then
		case lxsptr^
		when '=' then
			nextlx.symbol:=eqsym
			++lxsptr
		else
			nextlx.symbol:=assignsym
		esac
		return

	when '<' then
		switch lxsptr^
		when '=' then
			++lxsptr
			nextlx.symbol:=lesym
		when '<' then
			if (++lxsptr)^='=' then
				++lxsptr
				nextlx.symbol:=shltosym
			else
				nextlx.symbol:=shlsym
			fi
		else
			nextlx.symbol:=ltsym
		end switch
		return

	when '>' then
		switch lxsptr^
		when '=' then
			++lxsptr
			nextlx.symbol:=gesym
		when '>' then
			if (++lxsptr)^='=' then
				++lxsptr
				nextlx.symbol:=shrtosym
			else
				nextlx.symbol:=shrsym
			fi
		else
			nextlx.symbol:=gtsym
		end switch
		return

	when '&' then
		case lxsptr^
		when '&' then
			++lxsptr
			nextlx.symbol:=andlsym
		when '=' then
			++lxsptr
			nextlx.symbol:=iandtosym
		else
			nextlx.symbol:=iandsym
		esac
		return

	when '\'' then
		lxreadstring('\'',0)
		return

	when '"' then
		lxreadstring('"',0)
		return

	when ' ',tab then

	when lf then
		++nextlx.lineno
		nextlx.symbol:=eolsym
		nextlx.length:=0
		if dowhitespace then
			nextlx.svalue:=cast(lxsptr)
			doswitch (lxsptr++)^
			when ' ',tab then
			else
				--lxsptr
				exit
			end
!			while spacemap[(++lxsptr)^] do od
			nextlx.length:=lxsptr-nextlx.svalue
		fi
		return
	when cr then				!ignore; always expect lf to follow

	when '!' then
		case lxsptr^
		when '=' then
			nextlx.symbol:=nesym
			++lxsptr
		else
			nextlx.symbol:=notlsym
		esac
		return

	when '@' then
		PRINTLN "@ SEEN",nextlx.lineno,sourcefilenames[nextlx.fileno],lx_stackindex

	when 0 then
	doeof:
		--lxsptr
		if lx_stackindex then
			unstacksourcefile()
			nextlx.symbol:=eolsym
		else
			nextlx.symbol:=eofsym
		fi
		return

	when 12 then

!	when 0xEF then			!BOM
!		lxsptr+:=2

	else
		if 128<=(lxsptr-1)^<= 255then goto doname fi

		PRINTLN "ERROR CHAR",(lxsptr-1)^,int((lxsptr-1)^),lx_stackindex
		lxerror("ERROR CHAR")
		nextlx.symbol:=errorsym
		return

	end doswitch

end

proc readrealnumber(ref char pstart,intstart, int intlen, base)=
!'e' or '.' has been encountered, possibly after a string of digits
!intstart points to int prefix, (or to "." if there was no prefix, then intlen=0)
!lxsptr still points at '.', 'e' or 'E' (might be 'p' or 'P' for hex base)
!read entire numbers, convert to real value in nextlx.xvalue
	ref char fractstart
	int fractlen,expon,i,c,badexpon,n,adj
	real basex,x,expbase,f,y,y2,g
	i64 aa,cc,pref
	const maxrealdigits=500
	[maxrealdigits+12]char realstr
	ref char rs
	[32]char expstr
	u64 xx1,xx2

	if base<>10 then
		old_readrealnumber(pstart,intstart,intlen,base)
		return
	fi

	fractstart:=nil
	fractlen:=0
	expon:=0

	if lxsptr^='.' then		!read
		fractstart:=++lxsptr
		fractlen:=scannumber(base)-fractstart
	fi
	badexpon:=0

	case lxsptr^
	when 'e','E' then
		if base<>16 then
			++lxsptr
			expon:=readexponent(badexpon)
		fi
	when 'p','P' then
		if base=16 then
			++lxsptr
			expon:=readexponent(badexpon)
		fi
	esac

	if badexpon then
		--lxsptr
		readalphanumeric(pstart)
		return
	fi

	case lxsptr^
	when 'f','F','l','L' then
		++lxsptr
	else
		if alphamap[lxsptr^] then
			readalphanumeric(pstart)
			return
		fi
	esac

	if base=16 then
		realstr[1]:='0'
		realstr[2]:='x'
		rs:=&realstr[3]
		pref:=2
	else
		rs:=&realstr[1]
		pref:=0
	fi

	if intlen+fractlen>maxrealdigits then
		lxerror("Real too long")
	fi
	if intlen then
		memcpy(rs,intstart,intlen)
	fi
	if fractlen then
		memcpy(rs+intlen,fractstart,fractlen)
	fi

	expbase:=basex:=base

	if base=10 then
		expon-:=fractlen
	else
		expon-:=fractlen*4				!each hex digit is 4 binary bits
		expbase:=2.0
	fi

	realstr[pref+intlen+fractlen+1]:=0

	print @expstr,(base=10|"e"|"p"),,expon

	strcat(realstr,expstr)
	if base<>10 then
		lxerror("Non-base-10 floats temporarily unavailable")
	fi

	x:=strtod(realstr,nil)

	nextlx.symbol:=realconstsym
	nextlx.subcode:=tr64
	nextlx.xvalue:=x

	setnumberoffset(intstart-lxstart)
	nextlx.length:=lxsptr-intstart
end

function readexponent(int &badexpon)int=
!positioned just after 'e' etc
!read exponent, which can have optional + or -, and return actual exponent value
!exponent is always in base 10
	ref char numstart
	int length,neg,c
	i64 a

	neg:=0
	case lxsptr^
	when '+' then ++lxsptr
	when '-' then ++lxsptr; neg:=1
	esac

	numstart:=lxsptr
	length:=scannumber(10)-numstart

	if length=0 then
		badexpon:=1
		return 0
	fi

	a:=0

	to length do
		c:=numstart++^
		a:=a*10+c-'0'
	od

	return (neg|-a|a)
end

proc lxerror(ichar mess)=
	PRINTLN "\nLex error",mess,"in:",,sourcefilepaths[getfileno()],
	 "Line:",nextlx.lineno
	println
	println
	println
!	os_getch()
	stop 11
end

global proc printsymbol(ref tokenrec lp)=
	tokenrec l
	l:=lp^

	printf("%-18s",symbolnames[l.symbol])

	case l.symbol
	when namesym then
		printstrn(l.symptr.name,l.symptr.namelen)

	when intconstsym then
		print l.value,," "
		shownumberstr(lp)

	when realconstsym then
		print l.xvalue,," "
		shownumberstr(lp)

	when stringconstsym then
		print """"
		printstrn(l.svalue,l.length)
		print """"
	when charconstsym then
		print "'"
		printstrn(l.svalue,l.length)
		print "'"

	elsif l.subcode then
		print "#",l.subcode
	end

	println
end

global proc lexsetup=
!do one-time setup:
! clear the hash table and populated it with reserved words
! do maxnum support and such
	int i

	inithashtable()
	fillhashtable()

	for i:=0 to 255 do
		switch i
!		when 'A'..'Z','a'..'z','$','_','0'..'9' then
		when 'A'..'Z','a'..'z','$','_','0'..'9', 128..255 then
			alphamap[i]:=1
		end
		switch i
		when '0'..'9' then
			digitmap[i]:=1
		end
		commentmap[i]:=1
		linecommentmap[i]:=1
		spacemap[i]:=0
	od

	commentmap['*']:=0
	commentmap[0]:=0
	commentmap[lf]:=0

	linecommentmap[0]:=0
	linecommentmap['\\']:=0
	linecommentmap[lf]:=0

	spacemap[' ']:=1
	spacemap[tab]:=1

	normaltkx.symbol:=eolsym
	npastedtokens:=0
end

global proc printstrn(ichar s, int length,filehandle f=nil)=
	if length then
		if f=nil then
			print length:"v",,s:".*"
		else
			print @f,length:"v",,s:".*"
		fi
	fi
end

function scannumber(int base)ref char=
	ref char dest
	int c

	dest:=lxsptr

	doswitch c:=lxsptr++^
	when '0'..'9' then
		dest++^:=c
		if c>='0'+base then
			lxerror("Digit out of range")
		fi
	when 'A'..'F','a'..'f' then
			if base=16 then
			dest++^:=c
		else
			--lxsptr
			exit
		fi
	when '_','\'','`' then
	else
		--lxsptr
		exit
	end doswitch
	return dest
end

function lookup:int=
	int j, wrapped,length

	retry:
	j:=lxhashvalue iand hstmask
	wrapped:=0

	do
		nextlx.symptr:=hashtable^[j]
		length:=nextlx.symptr.namelen

		if not length then
			exit
		fi

		if length=nextlx.length then	!match on length
			if memcmp(nextlx.symptr.name,lxsvalue,length)=0 then	!match
				return 1
			fi
		fi

!++NCLASHES

		if ++j>=hstsize then
			if wrapped then
				abortprogram("HASHTABLE FULL")
			fi
			wrapped:=1
			j:=0
		fi
	od

!exit when not found; new name will go in entry pointed to by lxsymptr

	if nhstsymbols>=hstthreshold then
		newhashtable()

		lxhashvalue:=gethashvalue(lxsvalue,nextlx.length)
		goto retry
	fi

!	nextlx.symptr.name:=lxsvalue
	nextlx.symptr.name:=pcm_copyheapstringn(lxsvalue,nextlx.length)
	nextlx.symptr.namelen:=nextlx.length
	nextlx.symptr.symbol:=namesym

	++nhstsymbols

	return 0
end

global function gethashvalue(ichar s,int length=-1)word=
!get identical hash function to that calculated by lexreadtoken
!but for a zero-terminated string
!assumes s is lower-case, as conversion not done
!	int c,hsum
	word c,hsum

	if length=-1 then
		length:=strlen(s)
	fi
	hsum:=0

	to length do
		hsum:=hsum<<4-hsum+word(s++^)
	od
	return hsum<<5 -hsum
end

proc inithashtable=
	hashtable:=pcm_alloc(hstsize*(ref void.bytes))
	hstmask:=hstsize-1

	for i:=0 to hstmask do
		hashtable^[i]:=pcm_allocz(strec.bytes)
	od

	nhstsymbols:=0
	hstthreshold:=(6*hstsize)/10

end

proc fillhashtable=
!populate hashtable with standard symbols
	int i

	for i:=1 to stnames.len do
		lxsvalue:=stnames[i]

!sourcedir names can be converted to user name types, which could have a
!zero appended in lex() as the assumption is they are still in-situ within the source
!But with compilers like gcc, these names are in read-only memory.
!So copy them to the heap.

		if stsymbols[i]=ksourcedirsym then
			lxsvalue:=pcm_copyheapstring(lxsvalue)
		fi
		nextlx.length:=strlen(lxsvalue)
		lxhashvalue:=gethashvalue(lxsvalue,nextlx.length)

		if lookup() then
			println stnames[i]
			abortprogram("Duplicate symbol table entry")
		fi

		nextlx.symptr.symbol:=stsymbols[i]
		nextlx.symptr.subcode:=stsubcodes[i]
	od

end

function dolexdirective:int=
!positioned just after '#' which is first symbol on a line
!read pp directive and act on it
!return 1: returns a new symbol
!return 0: symbol has been absorbed; caller needs to read a new symbol
	ref strec symptr,d
	ref char p,pstart,s
	int i,cond,c,syshdr,dir,length, allowmacros
	[300]char filename

	pstart:=lxsptr

	dir:=getlexdirective()
	if dir=0 then
		printstrn(pstart,lxsptr-pstart); println
		lxerror("Invalid # directive")
	fi

	case dir
	when includedir then
		isincludefile:=1

		while lxsptr^=' ' or lxsptr^=tab do ++lxsptr od
		allowmacros:=lxsptr^ <> '<'

		lexm()
		isincludefile:=0

		if nextlx.symbol=ltsym then
			syshdr:=1
			p:=filename

			if allowmacros then

				do
					lexm()
					case nextlx.symbol
					when eofsym, eolsym then
						lxerror("Bad include file")
					when gtsym then
						exit
					else
						s:=strtoken(&nextlx,length)
						memcpy(p,s,length)
						p+:=length
					esac
				od
			else
				do
					c:=lxsptr++^
					case c
					when '>' then
						exit
					when lf,0 then
						lxerror("include: > expected")
					else
						p++^:=c
					esac
				od
			fi
			p^:=0

		elsif nextlx.symbol=stringconstsym then
			syshdr:=0
			strcpy(filename,nextlx.svalue)
		else
			lxerror("include?")
		fi
		lexm()

	IF FSHOWINCLUDES THEN
		PRINTLN "INCLUDE",filename,"FROM",sourcefilepaths[getfileno()],nextlx.lineno,
			=nsourcefiles
	FI
	++NINCLUDES

		stacksourcefile(filename,syshdr)

	when definedir then
		dodefine()

	when undefdir then
		lexreadtoken()
		if nextlx.symbol<>namesym then
			lxerror("undef: name expected")
		fi
		d:=nextlx.symptr
		if d.nameid<>macroid then
!			println getstname(nextlx.symptr)
!			lxerror("#undef: can't find macro")
		else
			d.nameid:=nullid
			d.symbol:=nextlx.symptr.oldsymbol
			d.mparamlist:=nil
			d.flmacro:=0
		fi

	when ifdefdir then
		cond:=getifdef()
		goto doif

	when ifndefdir then
		cond:=not getifdef()
		goto doif

	when ifdir then
		cond:=getifexpr()
	doif:

		++ifcondlevel
		if cond then			!carry on reading code as normal
			return 0
		else
	doskipcode:
			dir:=skipcode()
			case dir
			when elifdir then
				cond:=getifexpr()
				if cond then			!do this
					return 0
				fi
				goto doskipcode
			when elsedir then			!do following code
			when endifdir then
				--ifcondlevel
			esac
		fi

	when elifdir, elsedir then			!encountered after true block
		if not ifcondlevel then
			lxerror("#if missing/elif/else")
		fi
		repeat
			dir:=skipcode()
		until dir=endifdir
		--ifcondlevel

	when endifdir then
		if not ifcondlevel then
			lxerror("#if missing/endif")
		fi
		--ifcondlevel

	when blankdir then
	when linedir then
		repeat
			lexreadtoken()
		until nextlx.symbol=eolsym
	when errordir then
		lexm()
		print "#ERROR:"; showtoken(&nextlx); println
		lxerror("ABORTING")

	when pragmadir then
		dopragmadir()

	else
	skip:
		println "DIRECTIVE NOT IMPL:",sourcedirnames[dir]
		lxsptr:=pstart
		nextlx.symbol:=lexhashsym
		return 1
		lxerror("Directive not implemented")
	esac
	return 0
end

function getlexdirective:int=
!at '#'; read directive, and return index; 0 on error
	ref strec d

	lexreadtoken()

	case nextlx.symbol
	when namesym then
	when eolsym then
		return blankdir
	when intconstsym then
		repeat
			lexreadtoken()
		until nextlx.symbol=eolsym or nextlx.symbol=eofsym
		return blankdir
	else
		return 0
	esac

	case nextlx.symptr.symbol
	when ksourcedirsym then
		return nextlx.symptr.subcode
	when kifsym then
		return ifdir
	when kelsesym then
		return elsedir
	when eolsym then
		return blankdir
	esac

	d:=nextlx.symptr
	if d.nameid=macroid then			!could have redefined 'define' etc
		if d.oldsymbol=ksourcedirsym then
			return d.subcode
		fi
	fi

	return 0
end

global proc startlex(ichar caption,int fileno)=
!s is a 0-terminated source string representing perhaps
!an entire file.
!Initial lex vars so that it is possible to start reading tokens from it

	ifcondlevel:=0
	lx_stackindex:=0
	noexpand:=0

	normaltk := &normaltkx			!indicates use lexm to get tokens

	lx_stackindex:=0
	ifcondlevel:=0
	firstsymbol:=1
	npastedtokens:=0
	isincludefile:=0
	tkptr:=nil

	lxstart:=lxsptr:=sourcefiletext[fileno]
	setfileno(fileno)
	nextlx.lineno:=1
	nextlx.numberoffset:=0

	nextlx.symbol:=eolsym
	nextlx.subcode:=0
	lex()
end

global proc endlex=
	if ifcondlevel then
		println ifcondlevel
		lxerror("#endif missing")
	fi
end

global proc PS(ichar caption)=
	print caption,,":::"
	printsymbol(&lx)
end

global proc PSNEXT(ichar caption)=
	print caption,,":##"
	printsymbol(&nextlx)
end

global function gethashtablesize:int=
	int i,n

	n:=0
	for i:=0 to hstmask do
		if hashtable^[i].name then
			++n
		fi
	od

	return n
end

proc readlinecomment=
!positioned at second '/' of '//'

	do
		while linecommentmap[(++lxsptr)^] do od		!skip bulk of characters

		case lxsptr^
		when lf then
			++lxsptr
			exit
		when 0 then
			exit					!assume on last line not ending in newline char
		when '\\' then
			++lxsptr
			case lxsptr^
			when cr then			!skip following lf and loop
				lxsptr+:=2
				++nextlx.lineno
			when lf then			!loop
				++lxsptr
				++nextlx.lineno
			esac					!else ignore and loop
		esac
	od
	++nextlx.lineno
end

proc readblockcomment=
!positioned at '*' of '/*'

	do
		while commentmap[(++lxsptr)^] do od		!skip bulk of characters

		case lxsptr^
		when lf then
			++nextlx.lineno
		when 0 then
			lxerror("block comment eof")
		when '*' then
			if (lxsptr+1)^='/' then		!found end of comment
				lxsptr+:=2
				exit
			fi
		esac
	od
end

proc readhex(ref char pstart)=
!positioned at first char of hex number, after 0x/0X
	u64 aa
	word c
	int length,leading,ll,usigned
	ref char p

	aa:=0
	p:=lxsptr
	leading:=1
	ll:=usigned:=0
	length:=0

	doswitch c:=lxsptr++^
	when '1'..'9' then
		leading:=0
		aa:=aa*16+(c-'0')
		++length
	when '0' then
		if leading then
			++p			!ignore leading zeros
		else
			++length
			aa:=aa*16
		fi
	when 'A'..'F' then
		leading:=0
		++length
		aa:=aa*word(16)+(c-'A'+10)
	when 'a'..'f' then
		leading:=0
		++length
		aa:=aa*word(16)+(c-'a'+10)
	when '.','P','p' then
		--lxsptr
		readrealnumber(pstart,p,lxsptr-p,16)
		return
	when 'L','l' then
		++ll
		if ll>2 then lxerror("-LL?") fi
	when 'U','u' then
		if usigned then lxerror("-U?") fi
		usigned:=1
	else
		--lxsptr
		exit
	end doswitch

	setnumberoffset(pstart-lxstart)
	nextlx.length:=lxsptr-pstart

	if length>16 then
		lxerror("Overflow in hex number")
	fi

	nextlx.symbol:=intconstsym
	if aa>u64(0x7FFF'FFFF'FFFF'FFFF) then
		nextlx.subcode:=tu64
	elsif aa>u64(0xFFFF'FFFF) then
		nextlx.subcode:=ti64
	elsif aa>u64(0x7FFF'FFFF) then
		nextlx.subcode:=tu32
	else
		nextlx.subcode:=ti32
	fi
	nextlx.value:=aa

	if ll=2 or ll=1 and flong64 then
		case nextlx.subcode
		when tu32 then nextlx.subcode:=tu64
		when ti32 then nextlx.subcode:=ti64
		esac
	fi

	if usigned then
		case nextlx.subcode
		when ti32 then nextlx.subcode:=tu32
		when ti64 then nextlx.subcode:=tu64
		esac
	fi

	checknumbersuffix()
end

proc readbinary(ref char pstart)=
!positioned at first char of binary number, after 0b/0B
	u64 aa
	int c,length,res,leading
	ref char p

	aa:=0
	p:=lxsptr
	leading:=1

	doswitch c:=lxsptr++^
	when '1' then
		leading:=0
	when '0' then
		if leading then ++p fi					!ignore leading zeros
	when '2'..'9' then
		lxerror("Binary bad digit")
	when '.' then
		lxerror("Binary fp")

	else
		--lxsptr
		exit
	end doswitch

	length:=lxsptr-p
	setnumberoffset(pstart-lxstart)
	nextlx.length:=lxsptr-pstart

	if length>64 then
		lxerror("Overflow in binary number")
	fi

	to length do
		aa:=aa*2+p++^-'0'
	od

	nextlx.symbol:=intconstsym
	nextlx.subcode:=ti32
	if aa>=u64(0x7FFF'FFFF) then
		nextlx.subcode:=ti64
	fi
	nextlx.value:=aa

	checknumbersuffix()
end

proc readoctal(ref char pstart)=
!positioned at first char of octal number, after 0 (or at 8 or 9)
	u64 aa
	int c,length,res,leading,ll,usigned
	ref char p

	aa:=0
	p:=lxsptr
	leading:=1
	ll:=usigned:=0
	length:=0

	doswitch c:=lxsptr++^
	when '1'..'7' then
		leading:=0
		++length
	when '0' then
		if leading then
			++p				!ignore leading zeros
		else
			++length
		fi
	when '.' then
		--lxsptr
		readrealnumber(pstart,p,lxsptr-p,10)
		return
	when 'L','l' then
		++ll
		if ll>2 then lxerror("-LL?") fi
	when 'U','u' then
		if usigned then lxerror("-U?") fi
		usigned:=1
	else
		if alphamap[c] then
	doalpha:
			readalphanumeric(pstart)
			return
		fi
		--lxsptr
		exit
	end doswitch

	setnumberoffset(pstart-lxstart)
	nextlx.length:=lxsptr-pstart

	if length>22 or length=22 and (res:=cmpstringn(p,"1777777777777777777777",22))>0 then
		lxerror("Overflow in octal number")
	fi

	to length do
		aa:=aa*8+p++^-'0'
	od

	nextlx.symbol:=intconstsym
	nextlx.subcode:=ti32
	if aa>=u64(0x7FFF'FFFF) then
		nextlx.subcode:=ti64
	fi
	nextlx.value:=aa

	checknumbersuffix()
end

proc readdecimal(ref char pstart)=
!positioned at first char of decimal number
!will read integer, unless ends with any of ".eE" than assumed to be real
	u64 aa
	int c,length,res,leading
	byte ll,usigned

	ref char p

	aa:=0
	ll:=usigned:=0

	p:=--lxsptr

	while digitmap[(++lxsptr)^] do od

	while p^='0' do ++p od
	length:=lxsptr-p

	doswitch c:=lxsptr++^
	when '.','E','e' then
		--lxsptr
		readrealnumber(pstart,p,lxsptr-p,10)
		return
	when 'L','l' then
		++ll
		if ll>2 then lxerror("-LL?") fi
	when 'U','u' then
		if usigned then lxerror("-U?") fi
		usigned:=1
	else
		if alphamap[c] then
			readalphanumeric(pstart)
			return
		fi
		--lxsptr
		exit
	end doswitch

	setnumberoffset(pstart-lxstart)
	nextlx.length:=lxsptr-pstart

	if length>20 or length=20 and (res:=cmpstringn(p,"18446744073709551615",20))>0 then
		lxerror("Overflow in decimal number")
	fi

	to length do				!A..Z have been preprocessed so that they carry on from '9'
		aa:=aa*u64(10)+word(p++^-'0')
	od

	nextlx.symbol:=intconstsym

!	if aa>=i32.max then
!		nextlx.subcode:=ti64
!	else
!		nextlx.subcode:=ti32
!	fi

	case ll
	when 0 then
		if aa>=i32.max then
			nextlx.subcode:=ti64
		else
			nextlx.subcode:=ti32
		fi
		if usigned then
			if aa>=u64(0xFFFF'FFFF) then
				nextlx.subcode:=tu64
			else
				nextlx.subcode:=tu32
			fi
		else
			if aa>=u64(0x7FFF'FFFF) then
				nextlx.subcode:=ti64
			fi
		fi
	when 1 then
		if flong64 then recase 2 fi
		if usigned then
			if aa>=u64(0xFFFF'FFFF) then
				nextlx.subcode:=tu64
			else
				nextlx.subcode:=tu32
			fi
		else
			if aa>=u64(0x7FFF'FFFF) then
				nextlx.subcode:=ti64
			else
				nextlx.subcode:=ti32
			fi
		fi
	when 2 then
		if usigned then
			nextlx.subcode:=tu64
		else
			nextlx.subcode:=ti64
		fi
	esac

	nextlx.value:=aa
end

function checknumbersuffix:int=
!return type of the constant
!positioned at terminator character which might be a suffix
	char c

	doswitch c:=lxsptr++^
	when 'L','l','u','U' then
!	lxerror("Numeric SUFFIX")
	else
		if alphamap[c] then
!*!		lxerror("Bad number suffix")
		fi
		--lxsptr
		exit
	end doswitch

	return ti32			!don't bother for now
end

proc stacksourcefile(ichar file,int syshdr)=
	ref char sptr
	int fileno
	stackinforec info
	[500]char fullpath

	fileno:=getsourcefile(file,syshdr)
	if fileno=0 then
		println file,strlen(file)
		lxerror("Can't find include file")
	fi

	if lx_stackindex>=maxnesting then
		lxerror("Too many nested includes")
	fi
	++lx_stackindex

	fullpath[1]:=0
	if lx_stackindex>1 then
		strcpy(fullpath,headerpathlist[lx_stackindex-1])
	fi

	if headerpath[1] then
		strcat(fullpath,pcm_copyheapstring(headerpath))
	fi

	headerpathlist[lx_stackindex]:=pcm_copyheapstring(fullpath)

	info.startptr:=lxstart
	info.sptr:=lxsptr
	info.lineno:=nextlx.lineno
	info.fileno:=getfileno()
	lx_stack[lx_stackindex]:=info

	lxstart:=lxsptr:=sourcefiletext[fileno]
	setfileno(fileno)
	nextlx.lineno:=1
end

proc unstacksourcefile=
!called has checked that stack has >=1 entries
	ichar path
	stackinforec info

	path:=headerpathlist[lx_stackindex]
	pcm_free(path,strlen(path))

	info:=lx_stack[lx_stackindex--]
	lxstart:=info.startptr
	lxsptr:=info.sptr
	nextlx.lineno:=info.lineno
	setfileno(info.fileno)
end

function getsourcefile(ichar file,int syshdr)int=
!locate using search dirs; 
!read contents into memory, and return fileno
!returns 0 in case of error (file not found, memory problem)

	static [300]char filespec
	[300]char filespec2
	ichar hdrtext
	int i

	headerpath[1]:=0

	strcpy(filespec,file)
	convlcstring(filespec)

!check to see if already loaded
	for i:=1 to nsourcefiles do
		if eqstring(filespec,sourcefilenames[i]) then
			return i
		fi
	od

!see if a builtin header

	if dointheaders then
		hdrtext:=findheader(filespec)
		if hdrtext then
			return loadbuiltin(filespec,hdrtext)
		fi
	fi

	if eqstring(file, mcchdr) then
		return loadbuiltin(filespec, strinclude(mcchdr))
	fi

	strcpy(headerpath,extractpath(file))

	if headerpath[1] then
		if headerpath[1]='/' or headerpath[2]=':' and headerpath[3]='/' then
			if checkfile(file) then
					return loadsourcefile(file,file)
			fi
			return 0			!don't both looking anywhere else
		fi
	fi

	for i:=lx_stackindex downto 1 do
		strcpy(filespec,headerpathlist[i])
		strcat(filespec,file)

		if checkfile(filespec) then
			return loadsourcefile(filespec,file)
		fi
	od

	for i to nsearchdirs do
		strcpy(filespec,searchdirs[i])
		strcat(filespec,file)

		if checkfile(filespec) then
			strcpy(headerpath,extractpath(filespec))
			return loadsourcefile(filespec,file)
		fi
	od

	return 0
end

global proc lex=
!return next token in lx, using lexreadtoken but working a token ahead.
	reenter:

	lx:=nextlx				!grab that already read basic token

	lexm()			!read new token for next time around

	if lx.symbol=namesym and lx_stackindex=0 then
		(lx.symptr.name+lx.length)^:=0
	fi

	docase nextlx.symbol
	when namesym then
		nextlx.symbol:=nextlx.symptr.symbol			!convert to reserved word, type, op etc
		if nextlx.symbol=ksourcedirsym then
			nextlx.symbol:=namesym
		fi
		nextlx.subcode:=nextlx.symptr.subcode

		return

	when eolsym then								!lose eols
		lexm()
	else
		return	
	end docase

end

proc shownumberstr(ref tokenrec l,filehandle f=nil)=
	ref char s

	if getfilenox(l) then
		s:=sourcefiletext[getfilenox(l)]+getnumberoffsetx(l)
	else
		s:=pastedtokenlist[l.pasteno]
	fi
	printstrn(s,l.length,f)

end

global function addnamestr(ichar name)ref strec=
!look up arbitrary name and return symptr to generic st entry

	tokenrec oldlx
	ref strec symptr

	oldlx:=nextlx
	nextlx.length:=strlen(name)
	lxhashvalue:=gethashvalue(name,nextlx.length)

	lxsvalue:=pcm_alloc(nextlx.length+1)
	memcpy(lxsvalue,name,nextlx.length+1)
	lookup()
	symptr:=nextlx.symptr

	nextlx:=oldlx

	return symptr
end

proc lxreadstring(int termchar,int fwide)=
!read string inplace: new string, with expanded control characters,
!is stored on top of original string in the source
!new string is same length or shorter

	const maxlocalstr=2048
	[maxlocalstr]char str
	ref char dest,ws
	ref u16 wd,wd0
	int c,d,length,useheap

	if termchar='"' then
		nextlx.symbol:=(fwide|wstringconstsym|stringconstsym)
	else
		nextlx.symbol:=charconstsym
	fi

	nextlx.svalue:=lxsptr

	if lx_stackindex=0 and not fwide then
		dest:=lxsptr				!form string into same buffer
		ws:=dest					!for wide only
		useheap:=0
	else							!for headers that can be re-read, form string externally
		dest:=str
		ws:=dest					!for wide only
		useheap:=1
	fi
	length:=0

	do

		switch c:=lxsptr++^
		when '\\' then			!escape char
			if isincludefile then
				c:='/'
				goto normalchar
			fi
			c:=lxsptr++^
	reenter:
			switch c
			when 'a' then			!bell ('alert')
				c:=7
			when 'b' then			!backspace
				c:=8
			when 'f' then
				c:=12
			when 'n' then
				c:=lf
			when 'r' then
				c:=cr
			when 't' then			!tab
				c:=tab
			when 'v' then			!vertical tab
				c:=11
			when 'x' then	!2-digit hex code follows
				c:=0
!			to 2 do
				do
					switch d:=lxsptr++^
					when 'A','B','C','D','E','F' then
						c:=c*16+d-'A'+10
					when 'a','b','c','d','e','f' then
						c:=c*16+d-'a'+10
					when '0','1','2','3','4','5','6','7','8','9' then
						c:=c*16+d-'0'
					else
						--lxsptr
						exit
					end
				od
			when '0'..'7' then		!octal sequence
				c-:='0'				!get first digit
				to 2 do				!up to 2 more digits (some compilers will read N digits
					switch d:=lxsptr++^				!then check for overflow)
					when '0','1','2','3','4','5','6','7' then
						c:=c*8+d-'0'
					else
						--lxsptr
						exit
					end
				od

			when '"' then		!embedded double quote
				c:='"'
			when '\\' then
				c:='\\'
			when '\'' then			!embedded single quote
				c:='\''
			when cr then			!skip
				++nextlx.lineno
				if lxsptr^=lf then ++lxsptr fi
				nextloop
			when lf then
				++nextlx.lineno
				nextloop
			end						!else use the escaped character itself
		when '"','\'' then		!possible terminators
			if c=termchar then		!terminator char
				exit
			fi
		when 0 then
			println =nextlx.lineno
			lxerror("String not terminated")
		end switch
	normalchar:

		if not useheap then
			dest++^:=c
		elsif ++length<maxlocalstr then
			dest++^:=c
		else
			lxerror("Local str too long")
		fi
	od
	dest^:=0


	if fwide then			!need to put string on heap was will use 16-bit chars
		wd0:=wd:=pcm_alloc(length*2+2)
		to length do
			wd++^:=ws++^
		od
		wd^:=0
		nextlx.svalue:=cast(wd0)

	elsif useheap then
		nextlx.length:=length
		nextlx.svalue:=pcm_alloc(length+1)
		memcpy(nextlx.svalue,str,length+1)
	else
		nextlx.length:=dest-nextlx.svalue
	fi
end

proc addlisttoken(ref ref tokenrec ulist,ulistx,ref tokenrec p)=
!add strec p to end of linked list headed by ulist. ulistx^ is current end of list
	if ulist^=nil then		!first
		ulist^:=ulistx^:=p
	else
		ulistx.nexttoken:=p
	fi
	p.nexttoken:=nil

	ulistx^:=p			!update end-of-list pointer
end

proc addlisttoken_copy(ref ref tokenrec ulist,ulistx,ref tokenrec q)=
!like addlisttoken but add copy of nextlx
!(as will likely be in nextlx)
!add strec p to end of linked list headed by ulist. ulistx^ is current end of list
	ref tokenrec p

	p:=alloctoken()

	p^:=q^
	p.nexttoken:=nil

	if ulist^=nil then		!first
		ulist^:=ulistx^:=p
	else
		ulistx.nexttoken:=p
	fi
	p.nexttoken:=nil

	ulistx^:=p			!update end-of-list pointer
end

proc addlist_nextlx(ref ref tokenrec ulist,ulistx)=
!like addlisttoken but add copy of nextlx

	ref tokenrec p
	p:=alloctoken()
	p^:=nextlx
	p.nexttoken:=nil

	if ulist^=nil then		!first
		ulist^:=ulistx^:=p
	else
		ulistx.nexttoken:=p
	fi
	p.nexttoken:=nil

	ulistx^:=p			!update end-of-list pointer
end

proc addlisttoken_seq(ref ref tokenrec ulist,ulistx,ref tokenrec seq)=
	ref tokenrec tk

	while seq do
		tk:=alloctoken()
		tk^:=seq^

		if ulist^=nil then		!first
			ulist^:=ulistx^:=tk
		else
			ulistx.nexttoken:=tk
		fi
		tk.nexttoken:=nil
		ulistx^:=tk

		seq:=seq.nexttoken
	od
end

proc addlistmparam(ref ref mparamrec ulist,ulistx,ref mparamrec p)=
	if ulist^=nil then		!first
		ulist^:=ulistx^:=p
	else
		ulistx.nextmparam:=p
	fi
	ulistx^:=p			!update end-of-list pointer
end

proc dodefine=
!'define' just seen

	ref mparamrec stlist,stlistx,p,q
	ref strec stname, d
	ref tokenrec tklist,tklistx,tk
	int nparams,ntokens,paramno

	lexreadtoken()
	if nextlx.symbol<>namesym then
		lxerror("define: name expected")
	fi
	stname:=nextlx.symptr
	stname.lineno:=nextlx.lineno
	stname.fileno:=nextlx.fileno

	stname.oldsymbol:=stname.symbol

	stname.symbol:=namesym
	stname.nameid:=macroid
	nparams:=0

	if lxsptr^='(' then
		++lxsptr
		stlist:=stlistx:=nil
		stname.flmacro:=1

		lexreadtoken()
		do
			case nextlx.symbol
			when namesym then			!next param
				d:=nextlx.symptr
				p:=stlist
				while p do
					if p.def=d then
						lxerror("Dupl macro param")
					fi
					p:=p.nextmparam
				od
				q:=pcm_alloc(mparamrec.bytes)
				q.def:=d
				q.nextmparam:=nil
				addlistmparam(&stlist,&stlistx,q)
				++nparams
				lexreadtoken()
				if nextlx.symbol=commasym then
					lexreadtoken()
				fi
			when rbracksym then
				exit
			when ellipsissym then					!I need to create a special symbol name
				d:=addnamestr("__VA_ARGS__")
				stname.varparams:=1		!flag macro as having a va/args as last param
				lexreadtoken()
				if nextlx.symbol<>rbracksym then
					lxerror("')' expected")
				fi

				q:=pcm_alloc(mparamrec.bytes)
				q.def:=d
				q.nextmparam:=nil
				addlistmparam(&stlist,&stlistx,q)
				++nparams
				exit
			else
				lxerror("macro params?")
			esac
		od
		stname.mparamlist:=stlist
	fi

!Now, loop reading tokens until eol
!Store tokens in list
	tklist:=tklistx:=nil
	ntokens:=0

	do
		lexreadtoken()
		case nextlx.symbol
		when eolsym,eofsym then
			exit
		when namesym then
			p:=stname.mparamlist
			paramno:=1
			while p do
				if p.def=nextlx.symptr then
					nextlx.flags ior:=tk_parammask
					nextlx.paramno:=paramno
					exit
				fi
				p:=p.nextmparam
				++paramno
			od
			if nextlx.symptr=stname then
				nextlx.flags ior:=tk_macromask
			fi
		esac

		++ntokens
		tk:=alloctoken()
		tk^:=nextlx
		addlisttoken(&tklist,&tklistx,tk)
	od

	stname.tokenlist:=tklist
	stname.nparams:=nparams
end

proc readalphanumeric(ref char pstart)=
!part-read numeric value starting at pstart is followed by non-numeric chars
!read rest of token starting from lxsptr, and form into a name token
	while alphamap[lxsptr++^] do od
	--lxsptr
	nextlx.svalue:=pstart
	nextlx.symbol:=rawnumbersym
	nextlx.length:=lxsptr-pstart
end

function inmacrostack(ref strec d, ref tokenrec macrostack)int=
!return 1 if d is part of the macrostack
!the macrostack is a linked list of strecs, but conveniently uses a list
!of tokens although it is not really a list of tokens

	while macrostack do
		if macrostack.symptr=d then return 1 fi
		macrostack:=macrostack.nexttoken
	od
	return 0
end

proc showtokens(ichar caption,ref tokenrec tk)=
	print caption,,"<"
	while tk do
		showtoken(tk)
		tk:=tk.nexttoken
	od
	println ">"
end

proc lexa(ref tokenrec &tk)=
	if tk=normaltk then
		lexreadtoken()
		return
	fi
	if tk=nil then
		nextlx.symbol:=eofsym
		return
	fi
	nextlx:=tk^
	tk:=tk.nexttoken
end

proc lexm=
!wrapper around lexreadtoken that applies macro expansion to names
	ref strec d
	static int doreset=0
	int newlineno

	do
		if tkptr then
			nextlx:=tkptr^
			tkptr:=tkptr.nexttoken
			if tkptr=nil then

				if nextlx.symbol=namesym and nextlx.symptr.nameid=macroid and peeklb() then
!fix pp bug: macro expansion ending with fn-macro name, with (...) following
!but at normal lexical level. Pick that up here
					setfileno(sfileno)
					nextlx.lineno:=slineno
					doreset:=0
					goto TEST1
				fi
				doreset:=1

			fi
			return
		fi

		if doreset then
			setfileno(sfileno)
			nextlx.lineno:=slineno
			doreset:=0
		fi

		if firstsymbol then
			firstsymbol:=0
			dospecialinclude()
		fi	
		lexreadtoken()
	TEST1:

		case nextlx.symbol
		when lexhashsym then

			if dolexdirective() then
				return
			fi
!repeat lexreadtoken() until nextlx.symbol=eolsym

			nextloop
		when namesym then
			d:=nextlx.symptr
			case d.symbol
			when predefmacrosym then

				sfileno:=getfileno()
				slineno:=nextlx.lineno
				expandpredefmacro(d.subcode,&nextlx,slineno)
				doreset:=1					!can screw up line/file numbers
				return
			else
				if d.nameid<>macroid or noexpand then
					return
				fi
			esac
		else
			return
		esac
!have a macro. Now see whether this should be expanded
		sfileno:=getfileno()
		slineno:=nextlx.lineno
		if d.flmacro then		!function-like macro; need to peek for "("
			if not peeklb() then
				return
			fi
			tkptr:=expandfnmacro(d,nil,normaltk,1,newlineno)
			slineno:=newlineno
		else										!object-like macro: always expand
			tkptr:=expandobjmacro(d,nil,normaltk,1)
		fi

		if tkptr=nil then doreset:=1 fi			!immediately restore file/lineno

	od
end

function peeklb:int=
!look at lxsptr seqence and return 1 if the next token is a "(" left bracket
!lxsptr is left unchanged whatever the result
!only a simplistic approach is used, eg. 0 or 1 space then a "(" must be nextloop
!In theory, there could be any number and combination of spaces, tabs, newlines,
!comments, strings, #-directives between this point and the next token, or
!it could be inside the next #include or just outside this one.
	if lxsptr^='(' or (lxsptr^=' ' and (lxsptr+1)^='(') then
		return 1
	fi
	return 0
end

function peektk(ref tokenrec tk)int=
!version of peeklb that works on a token list rather than chars
!tk is the current token
	tk:=tk.nexttoken
	if tk=nil then			!nothing follows
		return 0
	fi
	if tk.symbol=lbracksym then
		return 1
	fi
	return 0
end

function expandobjmacro(ref strec m,ref tokenrec macrostack, &tksource,
		int frombaselevel)ref tokenrec=
	ref tokenrec tk,p,repl
	tokenrec newmacro
	int iscomplex,useshh,expanded
	ref strec d

	p:=tk:=m.tokenlist

	iscomplex:=useshh:=0
	while p do
		if p.symbol=namesym then
			d:=p.symptr
			if d.nameid=macroid or d.symbol=predefmacrosym then
				iscomplex:=1
				exit
			fi
		elsif p.symbol=hashhashsym then
			iscomplex:=useshh:=1
			exit
		fi

		p:=p.nexttoken
	od

	if not iscomplex then
		return tk
	fi

	newmacro.symptr:=m				!add m to macrostack
	newmacro.nexttoken:=macrostack

	if useshh then
		repl:=substituteargs(m,nil,nil,0,nil)
	else
		repl:=m.tokenlist
	fi

	tk:=scantokenseq(repl,&newmacro,expanded)
	return tk
end

function expandfnmacro(ref strec m, ref tokenrec macrostack, &tksource,
		int frombaselevel, &endlineno)ref tokenrec=
!positioned just before "(" token
!read arguments from source (need to use lexm(), reading from char-sourc or tokenlist)
!store args in special arg lists, and prepare args for expansion
!(for this version, args expanded on demand only)
!get tokenlist for m, do argument substitution, then scan it looking for new
!macros to expand
	[maxmacroargs]ref tokenrec args,expargs
	ref tokenrec repl,tk
	tokenrec newmacro
	int nargs,i,expanded

	nargs:=readmacrocall(m,&args,tksource)
	if frombaselevel then
		endlineno:=nextlx.lineno
	fi

	for i:=1 to nargs do
		expargs[i]:=nil
	od

	repl:=substituteargs(m,&args,&expargs,nargs,macrostack)

	newmacro.symptr:=m				!add m to macrostack
	newmacro.nexttoken:=macrostack

	repl:=scantokenseq(repl,&newmacro,expanded)
	return repl
end

function scantokenseq(ref tokenrec tk, macrostack,int &expanded)ref tokenrec=
!scan token sequence belonging to:
! The replacelist of an object macro
! The substituted replacement list of a function macro
! An argument of a macro
!scan object macro, but can also be an argument

!d is an object macro that may contains further macro definitions
!scan it, and produce a new tokenlist that contains expanded versions
!of nested macro calls
!macrostack is a list of active nested macro defs. This is stored as
!a linked list of tokenrec records, in reverse order. This is just for
!convenience; the .symptr field is used to refer to the macro st entry

	ref tokenrec newtk,newtkx	!new list of tokens
	ref tokenrec expandtk		!token seqence from expanding a macro
	ref tokenrec oldtk
	ref strec m
	tokenrec newmacro
	int noexpandflag,simple,dummy

	reenter:
	expanded:=0

	newtk:=newtkx:=nil
	noexpandflag:=0

	simple:=1
	oldtk:=tk

	while tk do
		case tk.symbol
		when namesym then
			if tk.symptr.nameid=macroid or tk.symptr.symbol=predefmacrosym then
				simple:=0
				exit
			fi
		esac

		if tk=nil then exit fi
		tk:=tk.nexttoken
	od

	if simple then
		return oldtk
	fi

	tk:=oldtk
	while tk do
		case tk.symbol
		when namesym then
			m:=tk.symptr
			if m.nameid=macroid and not noexpandflag then
!macro detected; check if candidate for expansion
				if tk.flags iand tk_macrolit or noexpand then
					goto simpletoken
				fi

				if inmacrostack(m,macrostack) then		!is an active macro name
					addlisttoken_copy(&newtk,&newtkx,tk)
					newtkx.flags ior:= tk_macrolit
					goto skip

				fi
	simple:=0
				if m.flmacro then
					if not peektk(tk) then goto simpletoken fi
					lexa(tk)
					expandtk:=expandfnmacro(m,macrostack,tk,1,dummy)
					addlisttoken_seq(&newtk,&newtkx,expandtk)
					expanded:=1
					nextloop
				else
					expandtk:=expandobjmacro(m,macrostack,tk,0)
					expanded:=1
					addlisttoken_seq(&newtk,&newtkx,expandtk)
				fi
			elsif m.symbol=kdefinedsym then
				noexpandflag:=1
				goto simpletoken
			elsif m.symbol=predefmacrosym then
				expandtk:=alloctokenz()
!CPL "EXPAND PDM 2"
!				expandpredefmacro(m.subcode,expandtk,nextlx.lineno)
				expandpredefmacro(m.subcode,expandtk,slineno)
				addlisttoken_copy(&newtk,&newtkx,expandtk)
				goto skip2
			else
				noexpandflag:=0
				goto simpletoken
			fi
		else
	simpletoken:
			addlisttoken_copy(&newtk,&newtkx,tk)
		esac

	skip:
		if tk=nil then exit fi
	skip2:
		tk:=tk.nexttoken
	od

	if expanded then
		tk:=newtk
		goto reenter
	fi

	return newtk
end

function readmacrocall(ref strec d, ref[]ref tokenrec args, ref tokenrec &tksource)int=
!positioned just before "(" of a macro call
!read arguments for the macro, and store into args
!return total number of arguments
!each args^[i] entry is a list of tokenrecs
!Caller has already checked that "(" is next token, and this will be a function macro
!tksource will point to an input stream of tokens, but can also be nil, meaning
!read via lexm from actual source. (tksource can't be nil because it's at the
!end of ...

	int nparams,lbcount,paramno
	int nargs,usesvargs,varg
	ref tokenrec tklist,tklistx			!form list of tokens for argument

	lexa(tksource)

	if nextlx.symbol<>lbracksym then lxerror("rmc: no '('") fi

	nparams:=d.nparams
	nargs:=0
	if nparams=0 then				!) must follow
		lexa(tksource)
		if nextlx.symbol<>rbracksym then lxerror("rmc: ')' expected") fi
		return 0					!no args
	fi

	paramno:=1
	lbcount:=1
	tklist:=tklistx:=nil
	usesvargs:=d.varparams			!whether macro contains ... va/args
	varg:=0										!whether encountered ... yet in arguments

	do
		if paramno=nparams and usesvargs then varg:=1 fi
		lexa(tksource)

		case nextlx.symbol
		when commasym then
			if lbcount=1 and not varg then
				if tklist=nil then					!empty list: create place-holder token
					tklist:=alloctokenz()
					setfilenox(tklist,getfileno())
					tklist.symbol:=placeholdersym
				fi
				args^[paramno]:=tklist				!store this list
				tklist:=tklistx:=nil
				++paramno
			else
				goto addtoken
			fi

		when eofsym then
			lxerror("EOS in macro call")
		when lbracksym then
			++lbcount
			goto addtoken
		when rbracksym then
			if lbcount>1 then
				--lbcount
				addlist_nextlx(&tklist,&tklistx)
			else
				if tklist=nil then
					tklist:=alloctokenz()
					setfilenox(tklist,getfileno())
					tklist.symbol:=placeholdersym
				fi
				args^[paramno]:=tklist				!store this list
				exit
			fi
		else
	addtoken:
			addlist_nextlx(&tklist,&tklistx)
		esac
	od

	if paramno<>nparams then
		if paramno+1=nparams and usesvargs then		!no args for ... part, needs dummy arg
			args^[nparams]:=nil
		else
			lxerror("Wrong # macro params")
		fi
	fi
	return nparams
end

function substituteargs(ref strec m,ref[]ref tokenrec args,expargs, int nargs,
ref tokenrec macrostack)ref tokenrec=
!m is a macro def
!args/expargs are arguments that will replace any parameter names encountered
!in m's replacement list
!returns new replacement list with arguments inserted
	ref mparamrec params
	ref tokenrec seq,seqstart,lasttoken
	ref tokenrec newtk,newtkx,niltk,tkexp
	tokenrec tk
	int n,i,expanded

	const maxhashhash=250
	[maxhashhash]ref tokenrec hhpoints
	int nhashhash

	params:=m.mparamlist
	seq:=seqstart:=m.tokenlist		!input token sequence

	newtk:=newtkx:=nil				!output token sequence
	nhashhash:=0
	lasttoken:=nil

	while seq do
		case seq.symbol
		when hashsym then
			if nargs then
				seq:=seq.nexttoken
				if seq=nil then lxerror("# at end") fi
				unless seq.flags iand tk_parammask then
					lxerror("# not followed by param")
				end unless
				n:=seq.paramno

				stringify(args^[n],&tk)

				addlisttoken_copy(&newtk,&newtkx,&tk)
			else
				addlisttoken(&newtk,&newtkx,seq)
				newtkx.symbol:=lithashsym				!change to #'
			fi
		when hashhashsym then
			if seq=seqstart then lxerror("## at start") fi
			if nhashhash>=maxhashhash then lxerror("Too many ##") fi
			hhpoints[++nhashhash]:=newtkx

		elsif seq.symbol=namesym and seq.flags iand tk_parammask and nargs then		!args can be () if no "(...)" followed
			n:=seq.paramno
			if seq.nexttoken and seq.nexttoken.symbol=hashhashsym or
			   lasttoken and lasttoken.symbol=hashhashsym then
				addlisttoken_seq(&newtk,&newtkx,args^[n])
			else
				tkexp:=expargs^[n]
				if tkexp=nil then
					tkexp:=expargs^[n]:=scantokenseq(args^[n],macrostack,expanded)
				fi
				addlisttoken_seq(&newtk,&newtkx,tkexp)
			fi

		else
	doother:
			addlisttoken_copy(&newtk,&newtkx,seq)
		esac

		lasttoken:=seq
		seq:=seq.nexttoken
	od

	if nhashhash then
		niltk:=nil
		for i:=1 to nhashhash do
			pastetokens(hhpoints[i],(i<nhashhash | hhpoints[i+1]| niltk))
		od
	fi

	return newtk
end

function strtoken(ref tokenrec lp,int &length)ichar=
!convert token to a string
!return pointer to the string *which is likely to be unterminated*
!return length of the string in 'length'
!(not sure yet if -1 is a possible length, meaning the string is zero-terminated)
!display token contents naturally
!note that caller should copy the string involved as no promises can be 
!made to ownership
	ichar name,s
	tokenrec l
	l:=lp^

	case l.symbol
	when namesym then
	doname:
		length:=l.symptr.namelen
		return l.symptr.name

	when intconstsym,realconstsym then
		length:=l.length


		if getfilenox(&l) then
			return sourcefiletext[getfilenox(&l)]+getnumberoffsetx(&l)
		else
			return pastedtokenlist[l.pasteno]
		fi
	when rawnumbersym then
		length:=l.length
		return l.svalue

	when stringconstsym,wstringconstsym then
		s:=strstring(l.svalue,l.length,length,'"')
		return s

	when charconstsym then
		s:=strstring(l.svalue,l.length,length,'\'')
		return s

	when eolsym then
		if dowhitespace then
			length:=l.length+1
			s:=pcm_alloc(length)
			s^:=10		!'\n'
			memcpy(s+1,l.svalue,l.length)
		else
			length:=1
			return "\n"
		fi
		return s

	when eofsym then
		length:=0
		return ""

	when ktypespecsym, ktypequalsym, klinkagesym, kfnspecsym then
		goto doname

	else
		name:=shortsymbolnames[l.symbol]
		if length:=strlen(name) then
			if name^<>'k' then
				return name
			else
				length:=strlen(symbolnames[l.symbol]+1)
				return symbolnames[l.symbol]+1
			fi
		else
			return ""
		fi
	esac
	return ""
end

function strstring(ichar s,int length,&newlength,quotechar)ichar=
!stringify the string, which means converting control codes to
!escape sequences, and adding optional quotes

	ichar t,u

	t:=u:=pcm_alloc(length*2+4)
	if quotechar then
		u^:=quotechar
		++u
	fi
	convertstringc(s,u,length)
	newlength:=strlen(t)
	if quotechar then
		(t+newlength)^:=quotechar
		++newlength
	fi
	return t
end

int lasttoken=0

global proc emittoken(ref tokenrec lp,ref strbuffer dest,int forcespace=0)=
!display token contents naturally
	int length
	ichar s

	if lp.symbol=eolsym and lasttoken=eolsym then
		return
	fi

	s:=strtoken(lp,length)

	if forcespace or needspace(lasttoken,lp.symbol) then
		gs_char(dest,' ')
	fi

	gs_strn(dest,s,length)


	lasttoken:=lp.symbol
end

global proc showtoken(ref tokenrec lp)=
	static strbuffer buffer
	static ref strbuffer dest=&buffer

	gs_init(dest)
	
	emittoken(lp,dest)
	
print dest.length:"v",,dest.strptr:".*"
end

proc stringify(ref tokenrec seq,dest)=
!stringify single or multiple token sequence, and store result as a single
!string token in dest
	ref char s
	int length,addspace
	static strbuffer buffer
	static ref strbuffer deststr=&buffer

	dest.symbol:=stringconstsym
	dest.nexttoken:=nil

	if seq.nexttoken=nil then		!single
		s:=strtoken(seq,length)
		dest.length:=length
		dest.svalue:=s
		return 
	fi

!now do multiple tokens into one string
	gs_init(deststr)
	lasttoken:=0
	addspace:=0
	while seq do
		emittoken(seq,deststr,forcespace:addspace)
		addspace:=1
		seq:=seq.nexttoken
	od

	dest.length:=length
	dest.svalue:=deststr.strptr
	dest.length:=deststr.length
end

proc pastetokens(ref tokenrec tk, &tknext)=
!tk points into a token sequence
!paste the token at tk with the one at tk.nexttoken, and replace
!tk with the new composite token; tk.nexttoken is removed
!tknext is either nil, or refers to the next pair of tokens to be pasted together;
!there is a problem when tk.nexttoken and tknext coincide, so something needs to
!be done in that case (set tknext to point to tk)

	ref tokenrec tk2
	int length1,length2
	ref char s,t,u
	tokenrec oldtoken,token
	ref char oldlxsptr
	int oldlx_stackindex

	tk2:=tk.nexttoken
	if tk2=tknext then tknext:=tk fi
	tk.nexttoken:=tk2.nexttoken				!lose second token

	if tk.symbol=placeholdersym then
		if tk2.symbol=placeholdersym then			!two placeholders; leave only first
		else										!ph/token; use second
			tk^:=tk2^								!also unlinks the tk2 token
		fi
	elsif tk2.symbol=placeholdersym then			!token/ph; leave only first
	else						!two normal tokens

		s:=strtoken(tk,length1)
		t:=strtoken(tk2,length2)

		u:=pcm_alloc(length1+length2)
		memcpy(u,s,length1)
		memcpy(u+length1,t,length2)
		(u+length1+length2)^:=0

		if npastedtokens>=maxpastedtokens then
			lxerror("Too many pasted tokens")
		fi
		pastedtokenlist[++npastedtokens]:=u

		oldtoken:=nextlx
		oldlxsptr:=lxsptr
		oldlx_stackindex:=lx_stackindex

		lxsptr:=u
		lx_stackindex:=0

		setfileno(0)
		nextlx.lineno:=0
		lexreadtoken()
		token:=nextlx
		lexreadtoken()

		if nextlx.symbol<>eofsym then
!			lxerror("token-paste error")
		fi

		nextlx:=oldtoken
		lxsptr:=oldlxsptr
		lx_stackindex:=oldlx_stackindex

		token.nexttoken:=tk.nexttoken
		setfilenox(&token,0)
		token.pasteno:=npastedtokens

	token.flags ior:=tk_pasted
		tk^:=token
	fi
end

function getifexpr:int=
	int sx
	int x

	lexm()
	x:=evalcondexpr(sx)

	if nextlx.symbol<>eolsym then
		lxerror("#if:eol expected")
	fi

	return x<>0
end

function evalcondexpr(int &sx)i64=
!Main entry point for pp expressions
!Will do conditional ?: expressions here
!Positioned at first symbol of expression, which is in nextlx (if a macro
!it will have been expanded, and this is the first token of that expansion)
	i64 x,y,z
	int sy,sz

	x:=evalorexpr(sx)

	if nextlx.symbol=questionsym then
		lexm()
		y:=evalcondexpr(sy)
		if nextlx.symbol<>colonsym then lxerror(": expected") fi
		lexm()
		z:=evalcondexpr(sz)
		if x then
			sx:=sy
			x:=y
		else
			sx:=sz
			x:=z
		fi
	fi

	return x
end

function evalorexpr(int &sx)i64=
	i64 x,y
	int sy,opc

	x:=evalandexpr(sx)
	while nextlx.symbol=orlsym do
		lexm()
		y:=evalandexpr(sy)
		x := (x or y|1|0)
	od

	return x
end

function evalandexpr(int &sx)i64=
	i64 x,y
	int sy,opc

	x:=evaliorexpr(sx)
	while nextlx.symbol=andlsym do
		lexm()
		y:=evaliorexpr(sy)
		x := (x and y|1|0)
	od

	return x
end

function evaliorexpr(int &sx)i64=
	i64 x,y
	int sy,opc

	x:=evalixorexpr(sx)
	while nextlx.symbol=iorsym do
		lexm()
		x ior:= evalixorexpr(sy)
	od

	return x
end

function evalixorexpr(int &sx)i64=
	i64 x,y
	int sy,opc

	x:=evaliandexpr(sx)
	while nextlx.symbol=ixorsym do
		lexm()
		x ixor:= evaliandexpr(sy)
	od

	return x
end

function evaliandexpr(int &sx)i64=
	i64 x,y
	int sy,opc

	x:=evaleqexpr(sx)
	while nextlx.symbol=iandsym do
		lexm()
		x iand:= evaleqexpr(sy)
	od

	return x
end

function evaleqexpr(int &sx)i64=
	i64 x,y
	int sy,opc

	x:=evalcmpexpr(sx)
	while (opc:=nextlx.symbol)=eqsym or opc=nesym do
		lexm()
		y:=evalcmpexpr(sy)
		case opc
		when eqsym then x := x = y
		when nesym then x := x <> y
		esac
	od

	return x
end

function evalcmpexpr(int &sx)i64=
	i64 x,y
	int sy,opc

	x:=evalshiftexpr(sx)
	while (opc:=nextlx.symbol)=ltsym or opc=lesym or opc=gesym or opc=gtsym do
		lexm()
		y:=evalshiftexpr(sy)
		case opc
		when ltsym then x := x < y
		when lesym then x := x <= y
		when gesym then x := x >= y
		when gtsym then x := x > y
		esac
	od

	return x
end

function evalshiftexpr(int &sx)i64=
	i64 x,y
	int sy,opc

	x:=evaladdexpr(sx)
	while (opc:=nextlx.symbol)=shlsym or opc=shrsym do
		lexm()
		y:=evaladdexpr(sy)
		case opc
		when shrsym then
			x := x>>y
		when shlsym then
			x := x<<y
		esac
	od

	return x
end

function evaladdexpr(int &sx)i64=
	i64 x,y
	int sy,opc

	x:=evalmulexpr(sx)
	while (opc:=nextlx.symbol)=addsym or opc=subsym do
		lexm()
		y:=evalmulexpr(sy)
		case opc
		when addsym then
			x +:= y
		when subsym then
			x -:= y
		esac
	od

	return x
end

function evalmulexpr(int &sx)i64=
	i64 x,y
	int sy,opc

	x:=evalunaryexpr(sx)
	while (opc:=nextlx.symbol)=mulsym or opc=divsym or opc=remsym do
		lexm()
		y:=evalunaryexpr(sy)
		if y=0 and opc<>mulsym then lxerror("#if:div by zero") fi
		case opc
		when mulsym then
			x *:= y
		when divsym then
			x := x/y
		when remsym then
			x := x rem y
		esac
	od

	return x
end

function evalunaryexpr(int &sx)i64=
	i64 x
	int opc

	case nextlx.symbol
	when addsym, subsym, notlsym, inotsym then
		opc:=nextlx.symbol
		lexm()
		x:=evalunaryexpr(sx)
		case opc
		when addsym then
			return x
		when subsym then
			return -x
		when notlsym then
			return not x
		when inotsym then
			return inot x
		esac
	esac

	return evalterm(sx)
end

function evalterm(int &sx)i64=
	i64 res
	int lb

	sx:=1
	case nextlx.symbol
	when namesym then
		case nextlx.symptr.symbol
		when kdefinedsym then
			noexpand:=1
			lb:=0
			lexm()
			if nextlx.symbol=lbracksym then
				lb:=1;
				lexm()
			fi
			if nextlx.symbol<>namesym then lxerror("defined?") fi
			res:=nextlx.symptr.nameid=macroid
			lexm()
			if lb then
				if nextlx.symbol<>rbracksym then lxerror("')' expected") fi
				lexm()
			fi
			noexpand:=0
		when ksizeofsym then
			lexm()
			if nextlx.symbol<>lbracksym then lxerror("'(' expected") fi
			lexm()
			if nextlx.symbol<>namesym then lxerror("name expected") fi
			case nextlx.symptr.symbol
			when ktypespecsym then
				res:=typespecsizes[nextlx.symptr.subcode]
			else
				lxerror("sizeof2")
			esac
			lexm()
			if nextlx.symbol<>rbracksym then lxerror("')' expected") fi
			lexm()
	
		else
!lxerror("Undefined macro name in cpp expr")
			lexm()
			return 0
		esac
	when intconstsym then
		res:=nextlx.value
		lexm()
	when charconstsym then
		if nextlx.length=0 then
			res:=0
		else
			res:=nextlx.svalue^
		fi
		lexm()
	when lbracksym then
		lexm()
		res:=evalcondexpr(sx)
		if nextlx.symbol<>rbracksym then
			lxerror(") expected")
		fi
		lexm()
	else
	printsymbol(&nextlx)
	printstrn(nextlx.svalue,nextlx.length); println
		lxerror("evalterm?")
	esac

	return res
end

function getifdef:int=
!just read ifdef/ifndef
!read following name and return 1 if name is macro, or 0 if not
	int res
	ref strec d

	noexpand:=1
	lexreadtoken()
	noexpand:=0
	if nextlx.symbol<>namesym then lxerror("Name expected") fi
	d:=nextlx.symptr
	res:=0
	if d.nameid=macroid then
		res:=1
	elsif d.symbol=predefmacrosym then
		res:=1
	fi

	lexreadtoken()
	if nextlx.symbol<>eolsym then lxerror("EOL expected") fi

	return res
end

function skipcode:int=
!skip false branch of #if etc until matching #elif/else/endif
!return dir-code of that closing directive
	int level,dir
	ref byte pp

	level:=0						!count nested #if levels

	do
		fastreadtoken()

		case nextlx.symbol
		when lexhashsym then
			dir:=getlexdirective()
			case dir
			when ifdir, ifdefdir, ifndefdir then
				++level
			when elifdir, elsedir then
				if level=0 then
					return dir
				fi
			when endifdir then
				if level=0 then
					return dir
				fi
				--level
			esac
		when eofsym then
			lxerror("#if:Unexpected eof")
		esac
	od
	return 0
end

proc freetokens(ref tokenrec tk)=
	ref tokenrec nexttk

	while tk do
		nexttk:=tk.nexttoken
		tk:=nexttk
	od
end

global proc fastreadtoken=
!read next token into nextlx
	int c,csum,hsum,commentseen,dodir,j
	ref char pstart,p
	ichar ss

!	nextlx.subcodex:=0

	doswitch c:=lxsptr++^
	when '#' then			!
		p:=lxsptr-2
		dodir:=0
		while p>=lxstart do
			case p^
			when lf then		!# is first thing on a line
				dodir:=1
				exit
			when tab,' ' then	!might have leading white space
			else
				exit			!assume different hash symbol
			esac
			--p
		od
		if dodir or p<lxstart then
			nextlx.symbol:=lexhashsym
		return

		elsif lxsptr^='#' then
			++lxsptr
		fi

	when '/' then
		case lxsptr^
		when '/' then					!comment to 
			readlinecomment()
		when '*' then
			readblockcomment()
		esac
	
	when '\'' then
		lxreadstring('\'',0)

	when '"' then
		lxreadstring('"',0)

	when cr then
		++nextlx.lineno
		nextlx.symbol:=eolsym
		nextlx.length:=0
		++lxsptr				!skip lf
	when lf then			!only lfs not preceded by cr
		++nextlx.lineno
		nextlx.symbol:=eolsym
		nextlx.length:=0

	when 0 then
		--lxsptr
		if lx_stackindex then
			unstacksourcefile()
		else
			nextlx.symbol:=eofsym
			return
		fi

	when 12 then
	else
	end doswitch
end

function alloctoken:ref tokenrec=
	ref tokenrec tk
	tk:=pcm_alloc(tokenrec.bytes)
	return tk
end

function alloctokenz:ref tokenrec=
	ref tokenrec tk
	tk:=pcm_alloc(tokenrec.bytes)
	tk.nexttoken:=nil
	return tk
end

proc expandpredefmacro(int pdmcode,ref tokenrec tk,int lineno)=
	[256]char str
	static []ichar monthnames=("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec")
	rsystemtime tm
	ichar s
	int fileno

	if noexpand then
		return
	fi

	case pdmcode
	when pdm_date then
		os_getsystime(&tm)

		fprint @str, "#-#-#",tm.day,monthnames[tm.month],tm.year:"4"

		tk.symbol:=stringconstsym
		tk.svalue:=pcm_copyheapstring(str)

	when pdm_time then
		os_getsystime(&tm)

		fprint @str,"#:#:#",tm.hour:"2",tm.minute:"z2",tm.second:"z2"

		tk.symbol:=stringconstsym
		tk.svalue:=pcm_copyheapstring(str)
	when pdm_file then
		tk.symbol:=stringconstsym
		fileno:=getfilenox(tk)
		if fileno=0 then fileno:=sfileno fi
		if sfileno then
			tk.svalue:=sourcefilenames[sfileno]
		else
			tk.svalue:="(File not available)"
		fi
	when pdm_func then
		tk.symbol:=stringconstsym
		if currproc then
			tk.svalue:=currproc.name
		else
			tk.svalue:="???"
		fi
	when pdm_line then
		tk.symbol:=intconstsym
		tk.value:=lineno
	when pdm_stdc then
		tk.symbol:=intconstsym
		tk.value:=1
	when pdm_mcc then
		tk.symbol:=intconstsym
		tk.value:=1
	when pdm_mcci then
		tk.symbol:=intconstsym
		tk.value:=pci_target
	else
		println pdmcode
		lxerror("PDM")
	esac

	if tk.symbol=stringconstsym then
		tk.length:=strlen(tk.svalue)
		tk.subcode:=trefchar
	else
		tk.subcode:=ti32
		s:=pcm_alloc(16)
		getstrint(tk.value,s)
		tk.length:=strlen(s)
		if npastedtokens>=maxpastedtokens then
			lxerror("2:Too many pasted tokens")
		fi
		pastedtokenlist[++npastedtokens]:=s
		setfilenox(tk,0)
		tk.pasteno:=npastedtokens
	fi
end

proc dopragmadir=
	lexm()
	if nextlx.symbol=namesym then
		if memcmp(nextlx.symptr.name,"pack",4)=0 then
			lexm()
			if nextlx.symbol<>lbracksym then lxerror("'(' expected") fi
			lexm()
			if nextlx.symbol=intconstsym then
				case nextlx.value
				when 1 then
					structpadding:=0
				else
					goto finish
					lxerror("Only pack(1) or () allowed")
				esac
				lexm()
			elsif nextlx.symbol=rbracksym then
				structpadding:=1
			fi
		elsif memcmp(nextlx.symptr.name,"module",6)=0 then
			addbuildinfo('M')
!		elsif memcmp(nextlx.symptr.name,"except",6)=0 then
!			addbuildinfo('X')
		elsif memcmp(nextlx.symptr.name,"header",6)=0 then
			addbuildinfo('H')
		elsif memcmp(nextlx.symptr.name,"link",4)=0 then
			addbuildinfo('L')
		fi
	fi
finish:
	while nextlx.symbol<>eolsym and nextlx.symbol<>eofsym do lexm() od
end

proc addbuildinfo(int code)=
	ichar file
	int j

	lexm()
	if nextlx.symbol<>stringconstsym then lxerror("Str expected") fi
	file:=pcm_copyheapstring(nextlx.svalue)

	case code
	when 'M' then
		if npmodules>=maxpmodule then lxerror("TMM")  fi
		pmodulelist[++npmodules]:=file

	when 'H' then
		if npheaders>=maxpheader then lxerror("TMH")  fi
		pheaderlist[++npheaders]:=file
	when 'L' then
		if nplibs>=maxplib then lxerror("TMLM") fi
		pliblist[++nplibs]:=file
	esac
	lexm()
end

function needspace(int a,b)int=
	ichar aname, bname

	if a=0 then return 0 fi			!first token

	aname:=shortsymbolnames[a]
	bname:=shortsymbolnames[b]

	case bname^
	when 'n','k' then
		case aname^
		when 'n','k' then
			return 1
		esac
	when '-','+' then
		case aname^
		when '-','+' then
			return 1
		esac
	esac

	return 0
end

global proc dospecialinclude=
	stacksourcefile(mcchdr,1)
	if dheaderfile then
		stacksourcefile(dheaderfile,1)
	fi
end

proc setnumberoffset(int offset)=
!store offset into nextlx.numberoffset
!except that top byte is msb of fileno
	nextlx.numberoffset:=(nextlx.numberoffset iand 0xFF000000) ior (offset iand 0xFFFFFF)
end

proc setfileno(int fileno)=
	nextlx.fileno:=fileno iand 255
	nextlx.numberoffset := (nextlx.numberoffset iand 0xFFFFFF) ior((fileno iand 0xFF00)<<16)
end

proc setfilenox(ref tokenrec tk,int fileno)=

	tk.fileno:=fileno iand 255
	tk.numberoffset := (tk.numberoffset iand 0xFFFFFF) ior (fileno iand 0xFF00)<<16
end

function getfileno:int=
	return (nextlx.numberoffset>>24)<<8 ior nextlx.fileno
end

function getfilenox(ref tokenrec tk)int=
	return (tk.numberoffset>>24)<<8 ior tk.fileno
end

function getnumberoffsetx(ref tokenrec tk)int=
	return tk.numberoffset iand 0xFFFFFF
end

global proc freehashtable=
!free the user name entries in the hash table
!leave reserved words etc alone
	ref strec d,e,f

	for i:=0 to hstmask do
		d:=hashtable^[i]
		if d.name and d.symbol=namesym then
			if d.nameid=macroid then
				freetokens(d.tokenlist)
			fi
			f:=d.nextdupl
			while f do
!				freestentry(f)
				e:=f.nextdupl
				pcm_free(f,strec.bytes)
				f:=e
			od
			pcm_clearmem(hashtable^[i],strec.bytes)
		elsif d.name then
			d.nextdupl:=nil
		fi
	od
end

proc regenlookup(ref strec d)=
	int j, wrapped,length
	ref strec e

	j:=gethashvalue(d.name,d.namelen) iand hstmask
	wrapped:=0

	do
		e:=hashtable^[j]
		length:=e.namelen

		if not length then
			PCM_FREE(HASHTABLE^[J],STREC.BYTes)
			hashtable^[j]:=d
			++nhstsymbols
			return
		fi

		if length=d.namelen then	!match on length
			if memcmp(e.name,d.name,length)=0 then	!match
				lxerror("regenhst dupl?")
			fi
		fi

		if ++j>=hstsize then
			if wrapped then
				abortprogram("REGENHST FULL?")
			fi
			wrapped:=1
			j:=0
		fi
	od
end

proc newhashtable=
	ref[0:]ref strec oldhashtable
	int oldhstsize
	ref strec d

!remember old hst
	oldhashtable:=hashtable
	oldhstsize:=hstsize
!generate new, blank hst
	hstsize*:=2
	hstmask:=hstsize-1
	nhstsymbols:=0
	hstthreshold:=(6*hstsize)/10

	hashtable:=pcm_alloc(hstsize*(ref void.bytes))

	for i:=0 to hstmask do
		hashtable^[i]:=pcm_allocz(strec.bytes)
	od

!now, rehash all existing hashentries
	for i:=0 to oldhstsize-1 do
		d:=oldhashtable^[i]
		if d.name then
			regenlookup(d)
		fi
	od

	pcm_free(oldhashtable,oldhstsize*(ref void.bytes))
end

proc old_readrealnumber(ref char pstart,intstart, int intlen, base)=
!'e' or '.' has been encountered, possibly after a string of digits
!intstart points to int prefix, (or to "." if there was no prefix, then intlen=0)
!lxsptr still points at '.', 'e' or 'E' (might be 'p' or 'P' for hex base)
!read entire numbers, convert to real value in nextlx.xvalue
	ref char fractstart
	int fractlen,expon,i,c,badexpon
	real basex,x,expbase
	const maxrealdigits=500
	[maxrealdigits]char realstr

	fractstart:=nil
	fractlen:=0
	expon:=0

	if lxsptr^='.' then		!read
		fractstart:=++lxsptr
		fractlen:=scannumber(base)-fractstart
	fi
	badexpon:=0

	case lxsptr^
	when 'e','E' then
		if base<>16 then
			++lxsptr
			expon:=readexponent(badexpon)
		fi
	when 'p','P' then
		if base=16 then
			++lxsptr
			expon:=readexponent(badexpon)
		fi
	esac

	if badexpon then
		--lxsptr
		readalphanumeric(pstart)
		return
	fi

	case lxsptr^
	when 'f','F','l','L' then
		++lxsptr
	else
		if alphamap[lxsptr^] then
			readalphanumeric(pstart)
			return
		fi
	esac

	if intlen+fractlen>maxrealdigits then
		lxerror("Real too long")
	fi
	if intlen then
		memcpy(&realstr,intstart,intlen)
	fi
	if fractlen then
		memcpy(&realstr[1]+intlen,fractstart,fractlen)
	fi

	expbase:=basex:=base

	if base=10 then
		expon-:=fractlen
	else
		expon-:=fractlen*4				!each hex digit is 4 binary bits
		expbase:=2.0
	fi

	x:=0.0

	for i:=1 to intlen+fractlen do		!digits already range-checked
		c:=realstr[i]
		if c>='0' and c<='9' then
			x:=x*basex+(c-'0')
		elsif c>'a' then
			x:=x*basex+c-'a'+10
		else
			x:=x*basex+c-'A'+10
		fi
	od

	if expon>=0 then
		to expon do
			x*:=expbase
		od
	else
		to -expon do
			x/:=expbase
		od
	fi

	nextlx.symbol:=realconstsym
	nextlx.subcode:=tr64
	nextlx.xvalue:=x

	setnumberoffset(intstart-lxstart)
	nextlx.length:=lxsptr-intstart
end

global function issimpleconstmacro(ref strec m)int=
!return 1 if a d is a macro defined as simple int or float
!then it will not be expanded
	ref tokenrec tk
	static []ichar specialnames=("stdin","stdout","stderr")

!don't expand special names
	for i to specialnames.len do
		if eqstring(specialnames[i],m.name) then
			return 2
		fi
	od

	tk:=m.tokenlist

	if tk and tk.nexttoken=nil then
		if tk.symbol=intconstsym or tk.symbol=realconstsym then
			return 1
		fi
	fi
	return 0
end
=== cc_lib.m 0 0 15/108 ===
global int autotypeno=0
global int nextafindex=0

const int unitheapsize=50000
ref unitrec unitheapptr=nil
int remainingunits=0

function newstrec:ref strec=
	ref strec p
	p:=pcm_alloc(strec.bytes)
!	memset(p,0,strec.bytes)
	clear p^

	p.lineno:=lx.lineno
	p.fileno:=lx.fileno

	return p
end

global proc initcclib=

end

global function createname(ref strec p)ref unitrec=
	ref unitrec u

	u:=allocunitrec()

	u.tag:=jname
	u.def:=p

	return u
end

global function createunit0(int tag)ref unitrec=
	ref unitrec u

	u:=allocunitrec()
	u.tag:=tag
	return u
end

global function createunit1(int tag, ref unitrec p)ref unitrec=
	ref unitrec u

	u:=allocunitrec()
	u.tag:=tag
	u.a:=p
	return u
end

global function createunit2(int tag, ref unitrec p,q)ref unitrec=
	ref unitrec u

	u:=allocunitrec()

	u.tag:=tag
	u.a:=p
	u.b:=q
	return u
end

global function createunit3(int tag, ref unitrec p,q,r)ref unitrec=
	ref unitrec u

	u:=allocunitrec()
	u.tag:=tag
	u.a:=p
	u.b:=q
	u.c:=r
	return u
end

global function createconstunit(u64 a, int t)ref unitrec=
	ref unitrec u
	u:=allocunitrec()
	u.tag:=jconst
	u.value:=a
	u.mode:=t
	return u
end

global function createstringconstunit(ichar s, int length)ref unitrec=
!for zero-terminated, length does not include terminator
!.slength will include it
	ref unitrec u
	u:=allocunitrec()
	u.tag:=jconst
	u.svalue:=s
	u.mode:=trefchar
	if length=-1 then
		u.slength:=strlen(s)+1
	else
		u.slength:=length+1
	fi
	u.isstrconst:=1
	return u
end

global function createwstringconstunit(ref u16 s, int length)ref unitrec=
	ref unitrec u
	u:=allocunitrec()
	u.tag:=jconst
	u.wsvalue:=s
	u.mode:=trefwchar
!if length=-1 then
!	u.slength:=strlen(s)
!else
		u.wslength:=length+1
!fi
	u.iswstrconst:=1
	return u
end

global function getoptocode(int opc)int=		!GETOPTOCODE
!opc is kadd etc
!return matching kaddto, etc
	static [0:jtagnames.len]i16 opctotable
	int n,opcto,i
	[20]char str

	opcto:=opctotable[opc]
	if opcto then return opcto fi				!find

!assume memoising table not filled in for this opc

	strcpy(str,jtagnames[opc])					!"add" etc
	strcat(str,"to")							!"addto" etc

	for i:=0 to jtagnames.upb do
		if eqstring(jtagnames[i],str) then
			opctotable[opc]:=i
			return i
		fi
	od

	cpl jtagnames[opc]
	serror("Can't find -to version")
	return 0
end

global function getconstvalue(ref unitrec p,int ID=0)i64=	!GETCONSTVALUE
!extract value from kconst
	if p and p.tag=jconst then
		return p.value
	fi
	serror("GCV Not constant")
	return 0
end

global function nextautotype:ichar=
	static [32]char str

!sprintf(str,"$T%d",i32(++autotypeno))
	print @str,"$T",,++autotypeno
	return str
end

global function createconstmode(int m)int=
!create const version of mode m
	int newm
	if ttconst[m] then return m fi
	if ttconsttype[m] then return ttconsttype[m] fi
	newm:=copymode(m)
	ttconsttype[m]:=newm
	ttconst[newm]:=1

	ttconsttype[newm]:=m			!use consttype to point back as well as forwards
!	ttcat[newm]:=ttcat[m]

	return newm
end

global function createrefmode(int m)int=
!create ref version of mode m (including when m is already a ref)
	int newm

	if ttreftype[m] then
		++ttshared[ttreftype[m]]
		return ttreftype[m]
	fi
	newm:=createnewmode(tref)
	ttreftype[m]:=newm
	tttarget[newm]:=m
	ttisref[newm]:=1
!	ttcat[newm]:=d64cat

	return newm
end

global function createprocmode(int m, ref paramrec pm)int=
!create proc mode with return type
	int newm

	newm:=createnewmode(tproc)
	ttparams[newm]:=pm
	tttarget[newm]:=m
!	ttcat[newm]:=d64cat
	return newm
end

global function createarraymode(int m, length)int=
!create array of mode m (including when m is already a ref)
	int newm

	newm:=createnewmode(tarray)
	tttarget[newm]:=m
	ttlength[newm]:=length
	ttsize[newm]:=length*ttsize[m]
!	ttcat[newm]:=blockcat
	ttisblock[newm]:=1

	return newm
end

global function createenummode(ref strec e)int=
	int newm
	newm:=createnewmode(tenum)
	ttnamedef[newm]:=e

	return newm
end

global function createstructmode(ref strec s,int smode)int=
	int newm
	newm:=createnewmode(smode)
	ttnamedef[newm]:=s
	ttisblock[newm]:=1

	return newm
end

global proc setnameptr(ref unitrec p)=		!SETNAMEPTR
!p is a just created j...def unit which has a nameptr in the .a parameter
!set up an xref from the strec back to the -def unit
!Set up a pointer in the associated strec that points back to q

	p.def.code:=p
end

global function getautofieldname:ref strec=
!create auto-field name and return pointer to st entry
	[32]char str
	ichar name

!sprintf(str,"$F%d",i32(++nextafindex))
	print @str,"$F",,++nextafindex

	name:=pcm_copyheapstring(str)
	return addnamestr(name)
end

global func convertstringc(ichar s, t,int length=-1)int=
!convert string s, that can contain control characters, into escaped form
!return new string in t, so that ABC"DEF is returned as ABC\"DEF
	int c
	[20]char str
	ichar t0

	if length=-1 then
		length:=strlen(s)
	fi

	t0:=t

	to length do
		c:=s++^
		switch c
		when '"' then
			t++^:='\\'
			t++^:='"'
		when '\'' then
			t++^:='\\'
			t++^:='\''
		when 10 then
			t++^:='\\'
			t++^:='n'
		when 13 then
			t++^:='\\'
			t++^:='r'
		when 9 then
			t++^:='\\'
			t++^:='t'
		when '\\' then
			t++^:='\\'
			t++^:='\\'
		when 7 then
			t++^:='\\'
			t++^:='a'
		when 8 then
			t++^:='\\'
			t++^:='b'
		when 12 then
			t++^:='\\'
			t++^:='f'
		when 11 then
			t++^:='\\'
			t++^:='v'
		else
			if c<32 or c>=127 then
!			sprintf(str,"\\%03o",i32(c))
				fprint @str,"\\#o",c:"z3"
				t++^:=str[1]
				t++^:=str[2]
				t++^:=str[3]
				t++^:=str[4]
			else
				t++^:=c
			fi
		end switch
	od
	t^:=0
	return t-t0
end

global function getopcjname(int opc)ichar=		!GETOPCJNAME
!op is a kcode representing an operator
!return the name as it might appear in J code
!caller must check for differences specific to the target
	static [20]char str
	ichar name,s

	name:=jtagnames[opc]
	s:=strchr(name,' ')
	if s then
		memcpy(str,name,s-name)
		str[s-name+1]:=0
		return str
	else
		return name
	fi
end

global function strmode(int m,expand=1)ichar=		!STRMODE
	static [16384]char str

	istrmode(m,expand,str)

	return str
end

global function strmode2(int m,expand=1)ichar=		!STRMODE
	static [16384]char str

	istrmode(m,expand,str)

	return str
end

global proc istrmode(int m,expand=1,ichar dest)=		!ISTRMODE
	ref strec d,q
	int value,needcomma,x,i,target,t,n
	strbuffer sxx
	ref strbuffer xx:=&sxx
	ref strbuffer sdim,slength
	[100]char strdim,strlength
	ref paramrec pm

	if m<tlast then
		strcpy(dest,typename(m))
		return
	fi

	t:=ttbasetype[m]

	case t
	when tref then
		if ttconst[m] then
			strcpy(dest,"const ref ")
		else
			strcpy(dest,"ref ")
		fi
		target:=tttarget[m]
		if target>=0 and ttbasetype[tttarget[m]]=tstruct then
			strcat(dest,typename(tttarget[m]))
		else
			istrmode(tttarget[m],0,dest+strlen(dest))
!			istrmode(tttarget[m],EXPAND,dest+strlen(dest))
		fi
	when tarray then
		if ttlength[m] then
			fprint @dest,"[#]",ttlength[m]
		else
			strcpy(dest,"[]")
		fi
		istrmode(tttarget[m],0,dest+strlen(dest))

	when tenum then
		strcpy(dest,"enum ")
		strcat(dest,typename(m))

	when tstruct,tunion then
		if not expand then
			strcpy(dest,typename(m))
			return
		fi

		strcpy(dest,typename(ttbasetype[m]))
		strcat(dest,"(")
		d:=ttnamedef[m]
		needcomma:=0

		q:=d.deflist
		while q do
			if needcomma then strcat(dest,",") fi
			needcomma:=1
			istrmode(q.mode,0,dest+strlen(dest))
			strcat(dest," ")
			strcat(dest,q.name)
			q:=q.nextdef
		od
		strcat(dest,")")

	when tvoid then			!must be a usertype that is not defined (as normal voids checked above)
		strcpy(dest,typename(m))

	when tproc then
		strcpy(dest,"proc(")
		pm:=ttparams[m]
		n:=pm.nparams
		for i to n do
			istrmode(pm.mode,0,dest+strlen(dest))
			if i<>n then
				strcat(dest,",")
			fi
			pm:=pm.nextparam
		od
		strcat(dest,")")
		istrmode(tttarget[m],0,dest+strlen(dest))

	elsif t<tlast then
		strcpy(dest,typename(m))
		return
	else
	CPL typename(m)
		mcerror("NEWSTRMODE")
	esac
end

global function typename(int m)ichar=
	int basem
	static [300]char str

	basem:=ttbasetype[m]
	case basem
	when tstruct,tunion then
		strcpy(str,(basem=tstruct|"struct "|"union "))
		if ttnamedef[m] then
			strcat(str,ttnamedef[m].name)
			strcat(str,".")
			strcat(str,strint(ttnamedef[m].blockno))
		fi
		return str
	when tarray then
		return "<array>"
	when tenum then
		if ttnamedef[m] then
			return ttnamedef[m].name
		fi
		return "<enum>"
	else
		if ttconst[m] then
			strcpy(str,"const ")
			strcat(str,stdtypenames[basem])
			return str
		fi
		return stdtypenames[basem]
	esac
	return ""
end

global function allocunitrec:ref unitrec=
	ref unitrec p
	ref i64 q
	int nwords

	++nunits

	if remainingunits-- then
		p:=unitheapptr
		++unitheapptr
		p.lineno:=lx.lineno

		if lx.fileno<=255 then
			p.fileno:=lx.fileno
		fi
		return p
	fi

!need first or new heap
	p:=unitheapptr:=pcm_alloc(unitheapsize*unitrec.bytes)

	memset(p,0,unitheapsize*unitrec.bytes)
	remainingunits:=unitheapsize-1
	++unitheapptr
	p.lineno:=lx.lineno
	if lx.fileno<=255 then
		p.fileno:=lx.fileno
	fi
	return p
end

function copymode(int m)int=
	if ntypes>=maxtype then
		serror("Too many types")
	fi
	++ntypes

!copy fields that won't already be zero
	ttnamedef[ntypes]:=ttnamedef[m]
	ttbasetype[ntypes]:=ttbasetype[m]
	ttlength[ntypes]:=ttlength[m]
	ttconst[ntypes]:=ttconst[m]
	ttsize[ntypes]:=ttsize[m]
	tttarget[ntypes]:=tttarget[m]
	ttparams[ntypes]:=ttparams[m]
	ttisref[ntypes]:=ttisref[m]
	ttisblock[ntypes]:=ttisblock[m]

	return ntypes
end

function createnewmode(int m)int=
!create new type unitialised except for given basetype m

	if ntypes>=maxtype then
		CPL =STRMODE(M)
		serror("Too many types/cnm")
	fi
	++ntypes

!leave length, const etc all zero
!copy basic size info from basetype

	ttbasetype[ntypes]:=m
	ttsize[ntypes]:=ttsize[m]

	return ntypes
end

global proc addlistunit(ref ref unitrec ulist,ulistx,ref unitrec p)=
!add strec p to end of linked list headed by ulist. ulistx^ is current end of list
	if ulist^=nil then		!first
		ulist^:=ulistx^:=p
	else
		ulistx.nextunit:=p
	fi
	p.nextunit:=nil

	ulistx^:=p			!update end-of-list pointer
end

global proc addlistdef(ref ref strec ulist,ulistx,ref strec p)=
!add strec p to end of linked list headed by ulist. ulistx^ is current end of list
	if ulist^=nil then		!first
		ulist^:=ulistx^:=p
	else
		ulistx.nextdef:=p
	fi
	p.nextdef:=nil

	ulistx^:=p			!update end-of-list pointer
end

global proc addlistparam(ref ref paramrec ulist,ulistx,ref paramrec p)=
!add paramrec p to end of linked list headed by ulist. ulistx^ is current end of list
	if ulist^=nil then		!first
		ulist^:=ulistx^:=p
	else
		ulistx.nextparam:=p
	fi
	p.nextparam:=nil

	ulistx^:=p			!update end-of-list pointer
end

global proc checksymbol(int symbol)=
	[256]char str

	if lx.symbol<>symbol then
		fprint @str,"# expected, not #",symbolnames[symbol],symbolnames[lx.symbol]

	if lx.symbol=namesym then
		strcat(str," \"")
		strcat(str,getstname(lx.symptr))
		strcat(str,"\"")
	fi
		serror(str)
	fi
end

global proc skipsymbol(int symbol)=
	if lx.symbol<>symbol then checksymbol(symbol) fi
	lex()
end

global proc inittypetables=
	int i,j,size,bitsize,s,t,u

!Initialise type tt-tables from std types first all fields initially zero

	for i:=0 to tlast-1 do
		ttbasetype[i]:=i

		bitsize:=stdtypewidths[i]
		size:=bitsize/8

		ttsize[i]:=size
!		ttcat[i]:=stdcat[i]

		if i in [tarray, tstruct] then
			ttisblock[i]:=1
		fi

	od
	ntypes:=tlast-1

	trefchar:=createrefmode(ti8)

	trefwchar:=createrefmode(tu16)

!do dominant table
	for i:=1 to dominantsetuptable.len do
		s:=dominantsetuptable[i,1]
		t:=dominantsetuptable[i,2]
		u:=dominantsetuptable[i,3]
		dominantmode[s,t]:=u
	od

!do conversion table
	for i:=1 to convsetuptable.len do
		s:=convsetuptable[i,1]
		t:=convsetuptable[i,2]
		u:=convsetuptable[i,3]
		conversionops[s,t]:=u
	od
end

global function createdupldef(ref strec owner,symptr, int id)ref strec=
!create new proc entry
!symptr is the generic st entry for proc's name
	ref strec p,q

	p:=newstrec()

	p.name:=symptr.name
	p.namelen:=symptr.namelen
	p.symbol:=namesym
	p.owner:=owner
	p.nameid:=id
	p.namespace:=namespaces[id]
	if q:=symptr.nextdupl then			!1st in dupl list
		q.prevdupl:=p
	fi
	p.nextdupl:=q
	p.prevdupl:=symptr
	symptr.nextdupl:=p

	if owner then
		if owner.deflist=nil then			!first def
			owner.deflist:=owner.deflistx:=p
		else
			owner.deflistx.nextdef:=p
			owner.deflistx:=p
		fi
	fi

	return p
end

global function createnewmoduledef(ref strec owner,symptr)ref strec=
	ref strec p,q

	p:=createdupldef(owner,symptr,moduleid)
	return p
end

global function createnewproc(ref strec owner,symptr)ref strec=
!create new proc entry
!symptr is the generic st entry for proc's name
	ref strec p,q

	p:=createdupldef(owner,symptr,procid)

	q:=p
	while q:=q.nextdupl do
		if q.owner=owner then
			cpl q.name,"in",owner.name
			serror("Dupl proc name")
		fi
!	q:=q.nextdupl
	od

	return p
end

global function resolvename(ref strec owner, symptr, int ns, blockno)ref strec=
!symptr is a generic st entry for a name
!owner is the st entry where the name has been encountered (the current
! module, or a function)
!ns is code of the namespace that is being searched
!blockno is zero, if searched at file scope, or non-zero if searching
!from inside a function. Then, it will be the current block number
!where the name has been encountered
!Search the symbol table (usually the dupl list for symptr) for
!any instance of the name which matches in owner, matches the
!namespace, and is within the blockno hierarchy
!return symptr of the st entry when resolved, or nil if not resolved
	int nsblock
	ref strec d

	if symptr.nameid>macroid then
		return symptr
	fi

	if ns=ns_labels then
		return resolvelabel(owner,symptr)
	fi

	if blockno and blockcounts[blockno]=0 then blockno:=blockowner[blockno] fi

	do							!loop for each block level
		nsblock:=ns<<16 ior blockno
		d:=symptr				!reset dupl list
		while d:=d.nextdupl do
			if owner.nameid=procid  and d.owner<>owner and d.owner.nameid=procid then
				exit
			fi
			if d.owner=owner and d.nsblock=nsblock then
!				d.used:=1
				if d.used<255 then ++d.used fi

				return d
			fi
		od

		if blockno=0 then
			case owner.nameid
			when procid then			!was in function, now search filescope
					!(THIS MIGHT BE NEEDED FOR PARAM-SCOPES where block number is zero)
				owner:=stmodule
				redoloop
			when structtagid then		!was in struct; now try owner (proc/module/other struct)
				owner:=owner.owner
				if owner=nil then		!not sure if possible, but just in case...
					return nil
				fi
			else
				return nil
			esac
		elsif (blockno:=blockowner[blockno])=0 then		!try next block level
			owner:=stmodule				!block 0 means outside outer block, so switch to module scope
		fi

	od

	return nil
end

global function resolvelabel(ref strec owner, symptr)ref strec=
		ref strec d
		d:=symptr				!reset dupl list
		while d:=d.nextdupl do
			if owner.nameid=procid  and d.owner<>owner and d.owner.nameid=procid then
				exit
			fi

			if d.owner=owner and d.namespace=ns_labels then
				return d
			fi
		od

		return nil
end

global function checkdupl(ref strec owner, symptr, int ns, blockno)ref strec=
!Same params as resolvename.
!But here, search only current scope level to see if something of the
!same name, and in the same namespace, already exists
!Returns nil, if such a name was not found, or a symptr to it
!A returned symbol might be of a different nameid, but that would
!be an error usually as you can't have two identical names in the same namespace.
!Some kinds of names can have repeated declarations in the same scope
	int nsblock
	ref strec d

	d:=symptr

	nsblock:=ns<<16 ior blockno

	while d:=d.nextdupl do
		if d.owner=owner and d.nsblock=nsblock then
			return d
		fi
	od

	return nil
end

global function checkdupl_inproc(ref strec owner, symptr, int ns, blockno)ref strec=
!special version of checkdupl
!assumes that dupl list starts at last proc

	int nsblock
	ref strec d

	d:=symptr

	nsblock:=ns<<16 ior blockno

	while (d:=d.nextdupl) and d.owner=owner do
		if d.nsblock=nsblock then
			return d
		fi
	od

	return nil
end

global function getalignment(int m)int=
!return alignment needed for type m, as 1,2,4,8
	int a

	case ttbasetype[m]
	when tarray then
		return getalignment(tttarget[m])
	when tstruct,tunion then

		a:=ttnamedef[m].align
		if a=0 then
!		CPL("GETALIGN 0")
			RETURN 16
!		SERROR("GETALIGN 0")
		fi
		return a
	esac

	a:=ttsize[m]
	case a
	when 1,2,4,8 then
		return a
	esac
	cpl strmode(m),A
	serror("GETALIGN SIZE NOT 1248")

	return 0
end

global function isexported(ref strec d)int=
	if d.nameid=procid then
		if d.code and (d.scope=imported_scope or d.scope=exported_scope) then
			return 1
		fi
	else
		if d.scope=exported_scope then
			return 1
		fi
	fi
	return 0
end

global function isimported(ref strec d)int=
	if d.nameid=procid then
		if d.code=nil and (d.scope=imported_scope or d.scope=exported_scope) then
			return 1
		fi
	else
		if d.scope=imported_scope then
			return 1
		fi
	fi
	return 0
end

global function getstname(ref strec d)ichar=
	static [256]char name
	memcpy(name,d.name,d.namelen)
	name[d.namelen+1]:=0
	return name
end

global function isrealcc(int m)int=
	m:=ttbasetype[m]
	return tfirstreal<=m<=tlastreal
!return tfirstreal<=m and m<=tlastreal
end

global function isintcc(int m)int=
	m:=ttbasetype[m]
	return tfirstint<=m<=tlastint
end

!global function ispoweroftwo(i64 x)int=
!!when x is a power of two, and is at least 2, then return the power (ie. equiv number of shifts)
!!otherwise return zero when x is negative, 0, 1, not a power of two, or more than 2**31
!	i64 a
!	int n
!
!	a:=1
!	n:=0
!	to 60 do
!		++n
!		a:=a<<1
!		if a=x then
!			return n
!		fi
!	od
!	return 0
!end

global proc writegsfile(ichar filename, ref strbuffer d)=
	filehandle f

	f:=fopen(filename,"w")
	gs_println(d,f)
	fclose(f)
end

GLOBAL PROC PAUSE(ichar mess="PAUSE")=
	CP MESS
	OS_GETCH()
	CPL
END

global func getpclmode(int t)int u=
	u:=stdpcl[ttbasetype[t]]

	if u=tpblock then
		case ttsize[t]
		when 8 then u:=tpu64
		when 4 then u:=tpu32
		when 2 then u:=tpu16
		when 1 then u:=tpu8
		esac
	fi
	return u
end

global proc addtolog(ichar filename, filehandle logdest)=
	filehandle f
	int c

	f:=fopen(filename,"rb")

	if f=nil then
 CPL "ATL ERROR",FILENAME; return fi

	do
		c:=fgetc(f)
		exit when c=c_eof
		fputc(c,logdest)
	od
	fclose(f)
end

!GLOBAL PROC SHOWSTRING(ICHAR CAPTION, STR, INT LENGTH)=
!	[1024]CHAR NEWSTR
!
!
!	CP CAPTION,,": "
!
!	IF LENGTH>=NEWSTR.LEN/3 THEN
!		PRINTLN "<LONGSTR>", LENGTH
!		RETURN
!	FI
!
!	NEWCONVERTSTRING(STR, NEWSTR, LENGTH)
!	PRINTLN """",,NEWSTR,,,,,""" *", LENGTH
!END
!
=== cc_libpcl.m 0 0 16/108 ===
global function getpsymbol(symbol d)psymbol p=
	symbol e
	ichar name
	[256]char str


	return nil when d=nil

	if d.pdef then return d.pdef fi

	name:=d.name

	if d.nameid in [frameid, paramid] then
		strcpy(str, d.name)
		if d.blockno>1 then
			strcat(str, ".")
			strcat(str, strint(d.blockno))
		fi
	elsif d.nameid=staticid and d.owner and d.owner.nameid=procid then
		strcpy(str, d.owner.name)
		strcat(str, ".")
		strcat(str, d.name)
		if d.blockno>1 then
			strcat(str, ".")
        	strcat(str, strint(d.blockno))
		fi
	else
		strcpy(str, d.name)
	fi


	d.pdef:=p:=pc_makesymbol(str, name2pid[d.nameid])

	p.mode:=getpclmode(d.mode)
	p.size:=ttsize[d.mode]

	if d.owner and d.owner.owner then
		p.owner:=getpsymbol(d.owner)
	fi

	if d.scope=exported_scope then p.exported:=1 fi
	if d.exported then p.dllexport:=1 fi
	if d.scope=imported_scope then p.imported:=1; p.id:=import_id fi
	p.used:=d.used

	p.labelno:=d.index

	if d.nameid=procid and eqstring(d.name, "main") then
		d.ismain:=p.ismain:=1
	fi

	return p
end

global proc setmode(int mode)=
	pc_setmode(getpclmode(mode), ttsize[mode])
end

global proc setmode2(int mode)=
	pc_setmode2(getpclmode(mode))
end

global proc setmode_u(unit p)=
	int mode:=p.mode

	pc_setmode(getpclmode(mode), ttsize[mode])
end

global func genmem_d(symbol d)pcl=
	return genmem(getpsymbol(d))
end

global func genmemaddr_d(symbol d)pcl=
	return genmemaddr(getpsymbol(d))
end

global func definelabel:int =
	pc_gen(klabel,genlabel(++mlabelno))
	return mlabelno
end

global func createfwdlabel:int =
	return ++mlabelno
end

global proc definefwdlabel(int lab) =
	pc_gen(klabel,genlabel(lab))
end

=== cc_parse.m 0 0 17/108 ===
!Parse C Code

!const needcompoundblock=1
const needcompoundblock=0

ref strec ist_symptr


const maxtypemods=32
[maxnestedloops]byte looptypestack		!contains either 'L' or 'S' (loop or switch)
int loopindex							!current level of nested loop/switch blocks
[maxnestedloops]ref caserec casevaluestack		!linked list of case values for current switch

byte ingeneric=0

proc readmodule=
	int linkage,m,mbase,commaseen,wasdef
	unit p
	ref strec d
	ref paramrec pm
	int t,nitems,wasenum, exported

	while lx.symbol<>eofsym do
		nitems:=0
		case lx.symbol
		when semisym then
			serror("Extra semicolon 2")
		esac
		wasenum:=lx.symbol
		exported:=0

		if lx.symbol=kdeclspecsym then
			exported:=readdllexport()
		fi

		mbase:=readdeclspec(stmodule,linkage)

		if lx.symbol=kdeclspecsym then
			exported:=readdllexport()
		fi

		commaseen:=0

		docase lx.symbol
		when namesym, mulsym, lbracksym then
			++nitems

			m:=readtype(stmodule,d,mbase,pm)

			if d=nil then
				serror("Var name expected")
			fi

			if linkage=typedef_ss then
				if pm then
					m:=createprocmode(m,pm)
				fi
				d:=createtypedef(stmodule,d,m)
	ELSIF LINKAGE=SHOW_SS THEN
				if pm then
					m:=createprocmode(m,pm)
				fi
!CPL D.NAME,"=",STRMODE(M)
CPL D.NAME,"=",STRMODE(M,1)
STOP

			elsif pm then
	readfn:
				if lx.symbol=lcurlysym and commaseen then serror("fn def after comma") fi

				d:=readfunction(d,m,linkage,pm,wasdef, exported)
				if wasdef then exit fi			!can't have comma-separate fn defs

			elsif ttbasetype[m]=tproc then
				pm:=ttparams[m]
				m:=tttarget[m]
				goto readfn

			else
				d:=readmodulevar(d,m,linkage)
			fi

			case lx.symbol
			when commasym then			!read next item
				commaseen:=1
				lex()
			else
				skipsymbol(semisym)
				exit
			esac
		else
			case ttbasetype[mbase]
			when tenum, tstruct, tunion then		!assume defining a [part]type only
				skipsymbol(semisym)
				exit
			when ti32 then				!allow for now, as it migt be an enum decl with no name
				skipsymbol(semisym)
				exit
			else
				serror_s("Decl error #",typename(mbase))
			esac
		end docase
	od
end

global function parsemodule:int=
	int size,t
	ref strec owner
	real tsecs

	if fverbose=3 then println "Parsing:",inputfile fi

	loopindex:=ingeneric:=0
	ist_symptr:=nil
	memset(&casevaluestack,0,casevaluestack.bytes)

	startlex("PARSETEST",mainfileno)
	owner:=stmodule
	currproc:=nil
	loopindex:=0

	lex()

!!=========================================
!t:=os_clock()
!int ntokens:=0
!
!!	repeat
!!		lex()
!!		++ntokens
!!	until lx.symbol=eofsym
!!
!	repeat
!		lexreadtoken()
!		++ntokens
!	until nextlx.symbol=eofsym
!
!
!
!t:=os_clock()-t
!
!CPL "LEX TIME=",t
!CPL =ntokens
!
!STOP
!!=========================================
!

	readmodule()

	endlex()
	return 1
end

function readdeclspec(ref strec owner,int &linkage)int=
!At first symbol of a declspec, or possible declspec
!read declspec and basetype
!return typecode for basetype, and linkage (static etc)
!if no declspec follows (usually eof) returns 0

	record declrec=
		i32 typeno				!not set, int, float, char, struct, union, enum etc
		byte isconst				!0, or 1 when const used (more than 1 allowed)
		byte isvolatile				!0, or 1 when volatile used
		byte isrestrict
		byte linkage				!0, or static_ss etc; only one allowed
		byte isinline				!1 when inline used
		byte isshort				!1 when short used
		byte islong					!1 when long used (not short or long long)
		byte isllong				!1 when long long used (islong set to 0)
		byte issigned				!not set, signed
		byte isunsigned				!not set, unsigned
		byte isusertype				!1 if basetype set completely from typedef
									!so isshort/long etc or other basetype not allowed
	end
	declrec d
	unit p
	int t,mod,m,fstruct
	ref paramrec pm
	ref strec e

	memset(&d,0,d.bytes)
!clear d
	d.typeno:=tnotset

	fstruct:=mod:=0

	doswitch lx.symbol
    when kstdtypesym then
        d.typeno:=lx.subcode
        lex()

    when ktypespecsym then
		switch lx.subcode
		when ts_int, ts_char, ts_float, ts_double, ts_bool, ts_void then
			if d.typeno<>tnotset then
				if fstruct then checksymbol(semisym)
				else goto tserror
				fi
			fi
			d.typeno:=typespectypes[lx.subcode]

		when ts_short then
			if d.isshort or d.islong or d.isllong then goto tserror fi
			d.isshort:=mod:=1
		when ts_long then
			if d.isllong or d.isshort then goto tserror
			elsif d.islong then
				d.islong:=0
				d.isllong:=1
			else
				d.islong:=1
			fi
			mod:=1

		when ts_signed then
			if d.issigned or d.isunsigned then goto tserror fi
			d.issigned:=mod:=1
		when ts_unsigned then
			if d.issigned or d.isunsigned then goto tserror fi
			d.isunsigned:=mod:=1
		else

	tserror:
			serror_s("declspec/ts #",typespecnames[lx.subcode])
		end switch
		lex()

	when ktypequalsym then
		case lx.subcode
		when const_qual then
			unless fnoconst then
				d.isconst:=1
			end
		when volatile_qual then d.isvolatile:=1
		when restrict_qual then d.isrestrict:=1
		esac
		lex()

	when klinkagesym then
		if d.linkage then serror("Dual storage spec") fi
		d.linkage:=lx.subcode
		lex()

	when kfnspecsym then
		case lx.subcode
		when inline_fnspec then
			d.isinline:=1
		esac
		lex()
	when kstructsym,kunionsym then
		if d.typeno<>tnotset then serror("struct?") fi
		d.typeno:=readstructdecl(owner)
		d.isusertype:=1
		fstruct:=1

	when kenumsym then
		if d.typeno<>tnotset then serror("enum?") fi
		readenumdecl(owner)
		d.typeno:=ti32			!disregard enum 'type'; just use int
		d.isusertype:=1

	when namesym then			!should resolve to see if a user-type ...
								! ... unless a basetype already seen
		if d.typeno=tnotset and (m:=isusertype(owner))<>tnotset then
			if mod then			!unsigned etc without proper base type; assume name is not part o it
				d.typeno:=ti32
				exit
			fi
			d.typeno:=m
			d.isusertype:=1
			lex()
		else
			if d.typeno=tnotset and not mod then
				serror_s("Implicit decls not allowed: #",lx.symptr.name)
			fi

			if d.typeno=tnotset then d.typeno:=ti32 fi
			exit
		fi

	else
		exit
	end doswitch

	t:=(d.typeno<>tnotset|d.typeno|ti32)

	if not d.isusertype then				!otherwise everything should be set up
		case t
		when ti32 then
			if d.isshort then
				t:=(d.isunsigned|tu16|ti16)
			elsif d.islong then
				if flong64 then
					t:=(d.isunsigned|tu64|ti64)
				else
					t:=(d.isunsigned|tu32|ti32)
				fi
			elsif d.isllong then
				t:=(d.isunsigned|tu64|ti64)
			elsif d.isunsigned then
				t:=tu32
			fi
		when ti8 then
			if d.isshort or d.islong or d.isllong then serror("char decl?") fi
			t:=(d.isunsigned|tu8|ti8)
		when tr64 then
			if d.isshort or d.isllong or d.issigned or d.isunsigned then serror("dbl decl?") fi

		else
			if mod then serror("declspec/float") fi
		esac
	fi

	if d.isconst then
		t:=createconstmode(t)
	fi

	linkage:=d.linkage
	return t
end

function istypestarter:int=
!return 1 when current symbol could start a type-spec
	ref strec d

	switch lx.symbol
	when ktypespecsym, kstdtypesym then
		return 1
	when ktypequalsym then
!	return lx.subcode=const_qual
		return 1
	when namesym then
		d:=resolvename((currproc|currproc|stmodule),lx.symptr,ns_general,currblockno)
		if d then
			lx.symptr:=d
			return d.nameid=typeid
		fi
	when kstructsym,kunionsym,kenumsym then
		return 1
	end switch
	return 0

end

function istypestarter_next:int=
!return 1 when current symbol could start a type-spec
	ref strec d

	switch nextlx.symbol
	when ktypespecsym, kstdtypesym then
		return 1
	when ktypequalsym then
!	return lx.subcode=const_qual
		return 1
	when namesym then
		d:=resolvename((currproc|currproc|stmodule),nextlx.symptr,ns_general,currblockno)
		if d then
			nextlx.symptr:=d
			return d.nameid=typeid
		fi
	when kstructsym,kunionsym,kenumsym then
		return 1
	end switch
	return 0

end

function readexpression:unit=
	unit p, ulist, ulistx
	int t

	case nextlx.symbol
	when  semisym,rbracksym then
		return readterm()
	esac

	p:=readassignexpr()

	if lx.symbol=commasym then		!
		ulist:=ulistx:=nil
		do
			addlistunit(&ulist,&ulistx,p)
			exit when lx.symbol<>commasym
			lex()
			p:=readassignexpr()
		od
		p:=createunit1(jexprlist,ulist)
		if ulistx then
			p.mode:=ulistx.mode
		fi

		return p
	fi
	return p
end

function readassignexpr:unit=
	unit p,q,r
	int opc,oldpmode

	case nextlx.symbol
	when commasym, semisym,rbracksym then
		return readterm()
	when assignsym then
		p:=readterm()
		opc:=lx.symbol
		goto gotp
	esac

	p:=readcondexpr()

	switch opc:=lx.symbol
	when assignsym, multosym, divtosym, remtosym, addtosym, subtosym,
			shltosym, shrtosym, iandtosym, ixortosym, iortosym then
	gotp:
		lex()
		oldpmode:=p.mode
		checklvalue(p,1)
		q:=readassignexpr()
		if ttisref[p.mode] then
			return createassignopref(opc,p,q)
		fi

		q:=coercemode(q,oldpmode)
		if ttconst[oldpmode] then
			terror("Modifying read-only var")
		fi

		if p.tag=jptr and p.a.tag=jconst then
			terror("Modifying constant?")
		fi


		r:=createunit2(symboltojtag[opc],p,q)

		r.mode:=oldpmode
		return r
	end switch

	return p
end

function readcondexpr:unit=
	unit x,y,pcond
	int s,t,u

	pcond:=readorlexpr()

	if lx.symbol=questionsym then
		coercecond(pcond)

		lex()
		x:=readexpression()
		skipsymbol(colonsym)
		y:=readcondexpr()

		if u:=dominantmode[s:=ttbasetype[x.mode],t:=ttbasetype[y.mode]] then			!were both numeric
			x:=coercemode(x,u)
			y:=coercemode(y,u)
			if pcond.tag=jconst and x.tag=jconst and y.tag=jconst then
				return (pcond.value|x|y)
			fi

		elsif s=tref and t=tref then
			u:=x.mode
		elsif s=tref and t=ti32 and y.tag=jconst and y.value=0 then
			u:=x.mode
			coercemode(y,u)
		elsif s=ti32 and t=tref and x.tag=jconst and x.value=0 then
			u:=y.mode
			coercemode(x,u)
		elsif s=tstruct and t=tstruct then
			u:=x.mode
		elsif s=tunion and t=tunion then
			u:=x.mode
		elsif s=t=tvoid then
			u:=tvoid
		else
	CPL strmode(x.mode),strmode(y.mode)
			terror("?: incompatible types")
		fi

		pcond:=createunit3(jifx,pcond,x,y)
		pcond.mode:=u
	fi

	return pcond
end

function readorlexpr:unit=
	unit x,y

	x:=readandlexpr()

	while lx.symbol=orlsym do
		lex()
		y:=readandlexpr()
		coercecond(x)
		coercecond(y)

		if x.tag=jconst and y.tag=jconst then
			x.value := (x.value or y.value|1|0)
			nextloop
		fi
		x:=createunit2(jorl,x,y)
		x.mode:=ti32
	od

	return x
end

function readandlexpr:unit=
	unit x,y

	x:=readiorexpr()

	while lx.symbol=andlsym do
		lex()
		y:=readiorexpr()
		coercecond(x)
		coercecond(y)

		if x.tag=jconst and y.tag=jconst then
			x.value := (x.value and y.value|1|0)
			nextloop
		fi
		x:=createunit2(jandl,x,y)
		x.mode:=ti32
	od

	return x
end

function readiorexpr:unit=
	unit x,y
	int u

	x:=readixorexpr()

	while lx.symbol=iorsym do
		lex()
		y:=readixorexpr()

		if u:=dominantmode[ttbasetype[x.mode],ttbasetype[y.mode]] then			!were both numeric
			if u>=tr32 then terror("float|float") fi
			x:=coercemode(x,u)
			y:=coercemode(y,u)
		else
			terror("invalid | operands")
		fi

		if x.tag=jconst and y.tag=jconst then
			case u
			when ti32,ti64,tu32,tu64 then
				x.value ior:= y.value
				nextloop
			esac
		fi
		x:=createunit2(jior,x,y)
		x.mode:=u
	od

	return x
end

function readixorexpr:unit=
	unit x,y
	int u

	x:=readiandexpr()

	while lx.symbol=ixorsym do
		lex()
		y:=readiandexpr()

		if u:=dominantmode[ttbasetype[x.mode],ttbasetype[y.mode]] then			!were both numeric
			if u>=tr32 then terror("float^float") fi
			x:=coercemode(x,u)
			y:=coercemode(y,u)
		else
			terror("invalid ^ operands")
		fi

		if x.tag=jconst and y.tag=jconst then
			case u
			when ti32,ti64,tu32,tu64 then
				x.value ixor:= y.value
				nextloop
			esac
		fi
		x:=createunit2(jixor,x,y)
		x.mode:=u
	od

	return x
end

function readiandexpr:unit=
	unit x,y
	int u

	x:=readeqexpr()

	while lx.symbol=iandsym do
		lex()
		y:=readeqexpr()

		if u:=dominantmode[ttbasetype[x.mode],ttbasetype[y.mode]] then			!were both numeric
			if u>=tr32 then terror("float&float") fi
			x:=coercemode(x,u)
			y:=coercemode(y,u)
		else
			cpl strmode(x.mode)
			cpl strmode(y.mode)
			terror("invalid & operands")
		fi

		if x.tag=jconst and y.tag=jconst then
			case u
			when ti32,ti64,tu32,tu64 then
				x.value iand:= y.value
				nextloop
			esac
		fi
		x:=createunit2(jiand,x,y)
		x.mode:=u
	od

	return x
end

function readeqexpr:unit=
	unit x,y
	int opc,s,t,u,ss,tt

	x:=readrelexpr()

	while (opc:=lx.symbol)=eqsym or opc=nesym do
		lex()
		y:=readrelexpr()

		if u:=dominantmode[s:=ttbasetype[x.mode],t:=ttbasetype[y.mode]] then			!were both numeric
			x:=coercemode(x,u)
			y:=coercemode(y,u)
		elsif s=tref and t=tref then
			if (ss:=tttarget[x.mode])<>(tt:=tttarget[y.mode]) then
				if ss<>tvoid and tt<>tvoid then
					if not checkpointertypes(x.mode,y.mode,1) then	!'hard'
						terror("Comparing distinct pointers/eq")
					fi
				fi
			fi
		elsif s=tref and t=ti32 then
			if y.tag<>jconst or y.value<>0 then
				terror("Can't compare pointer to int")
			fi
		elsif s=ti32 and t=tref then
			if x.tag<>jconst or x.value<>0 then
				terror("Can't compare pointer to int2")
			fi
		else
CPL =U
			terror("invalid == operands")
		fi

		if x.tag=jconst and y.tag=jconst then
			case u
			when ti32,ti64,tu32,tu64,0 then			!0 when ref/ref ref/int int/ref
				if opc=eqsym then
					x.value := x.value = y.value
				else
					x.value := x.value <> y.value
				fi
				nextloop
			esac
		fi
		x:=createunit2(symboltojtag[opc],x,y)
		x.mode:=ti32
	od

	return x
end

function readrelexpr:unit=
	unit x,y
	int opc,s,t,u
	i64 a,b,c
	u64 aa,bb,cc

	x:=readshiftexpr()

	while (opc:=lx.symbol)=ltsym or opc=lesym or opc=gesym or opc=gtsym do
		lex()
		y:=readshiftexpr()

		if u:=dominantmode[s:=ttbasetype[x.mode],t:=ttbasetype[y.mode]] then			!were both numeric

			x:=coercemode(x,u)
			y:=coercemode(y,u)
		elsif s=tref and t=tref then
			if not checkpointertypes(x.mode,y.mode,1) then		!use 'hard' mode
				terror("Comparing distinct pointers/rel")
			fi
		else
			terror("invalid rel operands")
		fi

		if x.tag=jconst and y.tag=jconst then
			a:=x.value; b:=y.value
			case u
			when ti32,ti64 then
				case opc
				when ltsym then c:=a<b
				when lesym then c:=a<=b
				when gesym then c:=a>=b
				else            c:=a>b
				esac
				x.value:=c
				nextloop
			when tu32,tu64 then
				aa:=x.value; bb:=y.value
				case opc
				when ltsym then cc:=aa<bb
				when lesym then cc:=aa<=bb
				when gesym then cc:=aa>=bb
				else            cc:=aa>bb
				esac
				x.value:=cc
				nextloop
			esac
		fi

		x:=createunit2(symboltojtag[opc],x,y)
		x.mode:=ti32
	od

	return x
end

function readshiftexpr:unit=
	unit x,y
	int opc,u

	x:=readaddexpr()

	while (opc:=lx.symbol)=shlsym or opc=shrsym do
		lex()
		y:=readaddexpr()

		coercebasetype(x)
		unless (u:=ttbasetype[x.mode])>=tfirstint and u<=tlastint then
			terror("shift:Not an int")
		end unless
		y:=coercemode(y,ti32)
!
		if x.tag=jconst and y.tag=jconst then
			case u
			when ti32,ti64 then
				if opc=shlsym then
					x.value := x.value << y.value
				else
					x.value := x.value >> y.value
				fi
				nextloop
			when tu32,tu64 then
				if opc=shlsym then
					x.uvalue := x.uvalue << y.value
				else
					x.uvalue := x.uvalue >> y.value
				fi
				nextloop
			esac
		fi
		x:=createunit2((opc=shlsym|jshl|jshr),x,y)
		x.mode:=u
	od

	return x
end

function readaddexpr:unit=
	unit p,q
	int opc

	p:=readmulexpr()

	while (opc:=lx.symbol)=addsym or opc=subsym do
		lex()
		q:=readmulexpr()

		if opc=addsym then
			p:=createaddop(p,q)
		else
			p:=createsubop(p,q)
		fi
	od

	return p
end

function readmulexpr:unit=
	unit p,q
	int opc

	p:=readterm()

	while (opc:=lx.symbol)=mulsym or opc=divsym or opc=remsym do
		lex()
		q:=readterm()
		case opc
		when mulsym then
			p:=createmulop(p,q)
		when divsym then
			p:=createdivop(p,q)
		when remsym then
			p:=createremop(p,q)
		esac
	od

	return p
end

function readterm:unit=
	unit p, q
	int t,u,opc,shift,newlen,slength,tbase,fwide,newmode, tag
	ref char pbyte
	i64 a
	ref strec d
	ichar ss,s
	ref paramrec pm

	switch lx.symbol
	when intconstsym, realconstsym then
		p:=createconstunit(lx.value,lx.subcode)

		lex()
	when namesym then
		if lx.symptr.nameid<=macroid then
			d:=resolvename((currproc|currproc|stmodule),lx.symptr,ns_general,currblockno)
			if d=nil then
				serror_s("Undefined name ""#""", getstname(lx.symptr))
			fi
		else
			d:=lx.symptr
		fi

!		d.used:=1
!		if d.used<255 then ++d.used fi
		case d.nameid
		when enumid then
			p:=createconstunit(d.index,ti32)
		when procid then
			if nextlx.symbol<>lbracksym then
				p:=createunit0(jfuncname)
				p.def:=d
				p.mode:=createrefmode(createprocmode(d.mode,d.paramlist))
!			p.mode:=createprocmode(d.mode,d.paramlist)
			else
				goto doname
			fi

		else
	doname:
			p:=createname(d)
			p.mode:=t:=d.mode
			if ttbasetype[t]=tarray then
				p.alength:=ttlength[t]
				p:=createaddrofop(p)
				p.mode:=createrefmode(tttarget[t])
			elsif d.nameid<>procid and ttsize[t]<4  then
				fixmemopnd(p)
			elsif d.nameid=paramid then
			fi
		esac
		p.lineno:=lx.lineno
		lex()

	when stringconstsym,wstringconstsym then
		fwide:=lx.symbol=wstringconstsym
		s:=lx.svalue

		slength:=lx.length
		while nextlx.symbol=stringconstsym do		!combine consecutive strings
			newlen:=slength+nextlx.length
			ss:=pcm_alloc(newlen+1)
			memcpy(ss,s,slength)
			memcpy(ss+slength,nextlx.svalue,nextlx.length)
			(ss+newlen)^:=0
			s:=ss
			slength:=newlen
			lex()
		od

		if fwide then
			p:=createwstringconstunit(cast(s),slength)
		    p.wslength:=slength
			p.mode:=trefwchar
		else
			p:=createstringconstunit(s,slength)
!		    p.slength:=slength
			p.mode:=trefchar

		fi

		lex()

	when charconstsym then
		a:=0
		shift:=0
		pbyte:=lx.svalue
		if lx.length>8 then serror("char const too long") fi

		to lx.length do
			a:=a ior u64(pbyte^)<<shift
			shift+:=8
			++pbyte
		od
		p:=createconstunit(a,(lx.length<=4|ti32|ti64))
		lex()

	when addsym then
		lex()
		p:=readterm()

	when subsym then
		lex()
		p:=createnegop(readterm())

	when notlsym then
		lex()
		p:=readterm()
		coercecond(p)
		p:=createunit1(jnotl,p)
		p.mode:=ti32

		if p.a.tag=jnotl and p.a.a.tag=jnotl then
			p.a:=p.a.a.a
		fi

	when inotsym then
		lex()
		p:=createinotop(readterm())

	when iandsym then			!&
		lex()
!&* cancel, so detect this early to avoid more complicated code, which also
!has a bug when following term is an array that decays to a pointer; it ends up
!with an incorrect number of ptrs (one too many I think). The .alength trick
!doesn't work when the array is unbounded as in (*A)[]
!However, detecting &* doesn't cover &(*X) for example
!I need to have .alength plus also an array indicator. Fortunately array pointers
!and the use of &* mainly occur in my generated code
!
		if lx.symbol=mulsym then
			lex()
			p:=readterm()
		else
			p:=createaddrofop(readterm())
		fi

	when andlsym then			!&&
		serror("rt/&&label")

	when mulsym then			!*
		lex()
		p:=createptrop(readterm())

	when incrsym, decrsym then			!*
		opc:=symboltojtag[lx.symbol]
		lex()
		p:=createincrop(opc,readterm())

	when abssym then
		lex()
		skipsymbol(lbracksym)
		p:=createabsop(readexpression())
		skipsymbol(rbracksym)

	when lbracksym then			!(
		lex()
		if istypestarter() then
			t:=readcasttype(d,0,pm)
			skipsymbol(rbracksym)
			if lx.symbol=lcurlysym then
				serror("rt/compound lit")
			else
				p:=docast(readterm(),t)
			fi
		else
			p:=readexpression()
			skipsymbol(rbracksym)
		fi
	when ksizeofsym then
		if lx.subcode then
			lex()
			if lx.symbol=lbracksym then		!possible type
				lex()
				if istypestarter() then
					t:=readcasttype(d,0,pm)
					skipsymbol(rbracksym)
					p:=createconstunit(ttlength[t],tu64)
				else
					p:=readexpression()
					skipsymbol(rbracksym)
					p:=createsizeofop(p,1)
				fi
			else
				p:=createsizeofop(readterm(),1)
			fi
		else
			lex()
			if lx.symbol=lbracksym then		!possible type
				if istypestarter_next() then
					lex()
					t:=readcasttype(d,0,pm)
					skipsymbol(rbracksym)
					p:=createconstunit(ttsize[t],tu64)
				else
					p:=readterm()
					p:=createsizeofop(p)
				fi
			else
				p:=createsizeofop(readterm())
			fi
		fi

	when kgenericsym then
		p:=readgeneric()
	when kalignofsym then
		serror("rt/alignof")

	when ksetjmpsym then
		tag:=lx.subcode
		lex()
		checksymbol(lbracksym)
		lex()
		p:=readassignexpr()
		if tag=jlongjmp then
			checksymbol(commasym)
			lex()
			q:=readassignexpr()
		else
			q:=nil
		fi
		p:=createunit2(tag,p,q)
		p.mode:=ti32
		checksymbol(rbracksym)
		lex()


	else
	PS("RT")
		serror("Readterm?")
	end switch

!look at the suffix

	doswitch lx.symbol
	when lsqsym then
		lex()
		q:=readexpression()
		skipsymbol(rsqsym)
		p:=createindexop(p,q)

	when dotsym, idotsym then
		opc:=symboltojtag[lx.symbol]
		lex()
		checksymbol(namesym)
		d:=lx.symptr
		lex()

		p:=createdotop(opc,p,d)

	when lbracksym then
		lex()
		if lx.symbol=rbracksym then			!()
			q:=nil
			lex()
		else
			q:=readexprlist(nil)
			skipsymbol(rbracksym)
		fi
		p:=createcall(p,q)

	when incrsym then
		lex()
		p:=createincrop(jpostincr,p)

	when decrsym then
		lex()
		p:=createincrop(jpostdecr,p)

	else
		exit
	end doswitch

	return p
end

function readexprlist(unit p)unit=
! read comma-separated list, and return head of list (not as jmakelist etc)
!p=nil:		at start of first expr (not ")")
!p<>nil:	p will be head of the list; comma skipped so at start of next expr
	unit ulist, ulistx

	ulist:=ulistx:=p
	do
		p:=readassignexpr()
		addlistunit(&ulist,&ulistx,p)
		if lx.symbol<>commasym then
			exit
		fi
		lex()
	od
	return ulist

end

function readmodulevar(ref strec d, int m, linkage)ref strec=
!read or function decl at module scope
	ref strec e
	int scope,emode

	e:=checkdupl(stmodule, d, ns_general, 0)

	if e then					!already exists
		if e.nameid<>staticid then
			serror_ss("var: name in use # #",e.name,namenames[e.nameid])
		fi
		emode:=e.mode
		if emode<>m then
			if not comparemode(emode,m) then
	redef:
				serror_s("var: redefining #",e.name)
			fi
			case ttbasetype[emode]
			when tarray then
				if ttlength[emode]=0 then			!replace empty array
					e.mode:=m
				elsif ttlength[m] and ttlength[emode]<>ttlength[m] then
					goto redef
				fi
			esac

		fi
		d:=e

!see how scope interacts with existing decl
		scope:=d.scope
		if scope=local_scope and linkage=none_ss or
		   scope=exported_scope and linkage=static_ss or
		   scope=imported_scope and linkage=static_ss then

!*!		serror("Linkage mismatch")

		elsif scope=imported_scope and linkage=none_ss then
			scope:=exported_scope
		fi

	else
		d:=createdupldef(stmodule,d,staticid)
		d.mode:=m
		case linkage
		when static_ss then
			scope:=local_scope
		when extern_ss then
			scope:=imported_scope
		else
			scope:=exported_scope
		esac

	fi

	if lx.symbol=assignsym then
		if d.code then
			serror_s("Can't init twice #",d.name)
		fi
		if scope=imported_scope then
			serror_s("Can't init extern #",d.name)
		fi
		lex()
		d.code:=readinitexpr(stmodule,d.mode)
	fi

	d.scope:=scope
	return d
end

function readframevar(ref strec d,int m, linkage)ref strec=
	ref paramrec pm
	ref strec e
	int scope,id

	e:=checkdupl_inproc(currproc, d, ns_general, currblockno)

	if e then					!already exists
			serror_s("var: name in use #",e.name)
		d:=e

!see how scope interacts with existing decl
		scope:=d.scope
		if scope=local_scope and linkage=none_ss or
		   scope=exported_scope and linkage=static_ss or
		   scope=imported_scope and linkage=static_ss then
!*!		serror("Linkage2 mismatch")
		elsif scope=imported_scope and linkage=none_ss then
			scope:=exported_scope
		fi
	else
		id:=frameid
		scope:=function_scope
		case linkage
		when static_ss then
			id:=staticid
		when extern_ss then
			scope:=imported_scope
			id:=staticid
		esac
		d:=createdupldef(currproc,d,id)
		d.mode:=m
		d.blockno:=currblockno
		blockcounts[currblockno]:=1
	fi

	if lx.symbol=assignsym then
		if d.code then
			serror_s("Can't init twice #",d.name)
		fi
		if scope=imported_scope then
			serror_s("Can't init extern #",d.name)
		fi
		lex()
		d.code:=readinitexpr(currproc,d.mode)
	fi

	d.scope:=scope

	return d
end

function readtype(ref strec owner, &d, int m, ref paramrec &pm)int=
	[maxtypemods]int modtype
	[maxtypemods]ref void modvalue
	ref paramrec pmx
	int nmodifiers,i
	nmodifiers:=0

	pm:=nil

	readnamedtype(owner,d, modtype,modvalue,nmodifiers)

!now apply modifiers to base type:
	for i:=nmodifiers downto 1 do
		case modtype[i]
		when 'A' then
			m:=createarraymode(m,int(modvalue[i]))
		when 'R' then
			m:=createrefmode(m)
		when 'C' then
			m:=createconstmode(m)
		when 'F' then
			pmx:=modvalue[i]

			if i=1 then				!indicate to caller that this is a normal function
				pm:=pmx
			else					!assume function pointer of some sort
				m:=createprocmode(m,pmx)
			fi
		esac
	od

	return m
end

proc readnamedtype(ref strec owner, &d, []int &modtype, []ref void &modvalue, int &nmodifiers)=
	int length
	[maxtypemods]int fconst
	int nrefs
	unit pdim

	d:=nil
	nrefs:=0

	if lx.symbol=kfnspecsym then
		lex()
	fi

	while lx.symbol=mulsym do			!pointer/qualifier loop
		++nrefs
		fconst[nrefs]:=0
		lex()
		while lx.symbol=ktypequalsym do
			case lx.subcode
			when const_qual then
				fconst[nrefs]:=1
			when volatile_qual, restrict_qual then
			else
				serror("rnt1")
			esac
			lex()
		od
	od

	case lx.symbol
	when namesym then
		d:=lx.symptr
		lex()
	when lbracksym then
		lex()
		readnamedtype(owner,d,modtype,modvalue,nmodifiers)
		skipsymbol(rbracksym)
	esac

	docase lx.symbol
	when lsqsym then
		lex()
		if lx.symbol=rsqsym then
			length:=0
		else
			pdim:=readassignexpr()
			if pdim.tag=jconst then
				length:=pdim.value
			else
				serror("Can't do VLAs")
			fi
			checksymbol(rsqsym)
IF LENGTH=0 THEN SERROR("ZERO LEN ARRAY") fi
		fi
		if length<0 then terror("Negative array dim") fi

		lex()
		modtype[++nmodifiers]:='A'
		modvalue[nmodifiers]:=ref void(length)

	when lbracksym then			!fn params
		lex()
		modtype[++nmodifiers]:='F'
		modvalue[nmodifiers]:=readparams(owner)
	else
		exit
	end docase

!now apply any pointers
	while nrefs do
		if fconst[nrefs] then
			modtype[++nmodifiers]:='C'
		fi
		modtype[++nmodifiers]:='R'
		--nrefs
	od
end

function readconstintexpr:int=
	unit p
	int val

	p:=readassignexpr()
	case p.tag
	when jconst then
		return p.value

	else
		serror_s("readconstint #",jtagnames[p.tag])
	esac
	return 0
end

function readinitexpr(ref strec owner, int m)unit=
	int count
	unit p

	p:=readinitexpr2(owner,m,1)

	return p
end

function readinitexpr2(ref strec owner, int m, istop)unit=
	unit ulist, ulistx, p
	int mbase,melem,mm
	int dim,count
	ref strec d,e
	int braces
	ichar newstr

	mbase:=ttbasetype[m]
	count:=0

	if lx.symbol=lcurlysym then
		lex()

		count:=0
		case mbase
		when tarray then
			dim:=ttlength[m]
			if not istop and dim=0 then terror("init/0-size array") fi
			melem:=tttarget[m]
!			if ttbasetype[melem]=tu8 and lx.symbol=stringconstsym then
			if ttbasetype[melem]=tchar and lx.symbol=stringconstsym then
				braces:=1
				goto doarraystring
			fi

		when tstruct,tunion then
			d:=ttnamedef[m]
			e:=d.deflist
			if e=nil then
				terror("init/Empty struct")
			fi
			melem:=e.mode
		else
			p:=readassignexpr()
			p:=coercemode(p,m)
			skipsymbol(rcurlysym)
			return p
		esac

		ulist:=ulistx:=nil
		do
			p:=readinitexpr2(owner,melem,0)
			++count

			case mbase		
			when tarray then
				if dim and count>dim then
					terror("Too many array elems")
				fi

				if ttbasetype[melem]=tarray and ttbasetype[tttarget[melem]]=tchar and p.mode=trefchar then
				else
					p:=coercemode(p,melem)
				fi
			when tstruct then

				mm:=e.mode

				if ttbasetype[mm]=tarray and ttbasetype[tttarget[mm]]=tu8 and p.mode=trefchar then
				else
					p:=coercemode(p,mm)
				fi

				e:=e.nextdef
				if e=nil then
					if lx.symbol=commasym and nextlx.symbol<>rcurlysym then
						terror("Too many struct elems")
					fi
				else
					melem:=e.mode
				fi
			when tunion then
				p:=coercemode(p,melem)
				ulist:=ulistx:=p
				goto donestruct
			esac

			addlistunit(&ulist,&ulistx,p)
			if lx.symbol<>commasym then
				exit
			fi
			if nextlx.symbol=rcurlysym then		! {10,20,30,} allowed
				lex()
				exit
			fi
			lex()
		od
		if mbase=tarray and dim=0 then
			ttlength[m]:=count
			ttsize[m]:=count*ttsize[melem]
		fi

	donestruct:
		skipsymbol(rcurlysym)
		p:=createunit1(jmakelist,ulist)
		p.count:=count

		p.mode:=m

	else
		braces:=0
		case mbase
		when tarray then
	doarraystring:
			if lx.symbol<>stringconstsym and lx.symbol<>wstringconstsym and 
				tttarget[m]<>tchar then
				terror("{} initialiser expected")
			fi

			p:=readassignexpr()
			case p.mode
			when trefchar then
			when trefwchar then
			else
				terror("Array init")
			esac
			P.MODE:=M

!CPL =P.SLENGTH, =TTLENGTH[M], =TTSIZE[M]

			if (dim:=ttlength[m])=0 then
				ttlength[m]:=ttsize[m]:=p.slength
			else
				if p.slength>dim and p.slength<>dim+1 then	!ASSUME last data char is zero
					terror("Init str too long")
				fi

				if p.slength<dim then
					newstr:=pcm_allocz(dim)
					memcpy(newstr, p.svalue, p.slength)
					p.svalue:=newstr
				fi

! terror("Init str too short") fi
				p.slength:=dim

			fi
			if braces then skipsymbol(rcurlysym) fi
			return p
		esac
		p:=readassignexpr()
		p:=coercemode(p,m)

	fi
	return p
end

proc pushblock=
	int n

	if blocklevel>=maxblockstack then
		serror("Too many block levels")
	fi
	if nextblockno>=maxblock then
		serror("Too many blocks")
	fi
	++blocklevel
	++nextblockno

	n:=currblockno

	int m:=blocklevel								!NEED TO ACCESS CONTAINING BLOCKS
													!VIA BLOCKSTACK

	while m and blockcounts[blockstack[m]]=0 do
		--m
    n:=blockstack[m]
	od

	blockowner[nextblockno]:=n

	currblockno:=blockstack[blocklevel]:=nextblockno
	blockcounts[currblockno]:=0
end

proc popblock=
	currblockno:=blockstack[--blocklevel]
end

function readcompoundstmt(int params):unit=
!read {...} statements
!positioned at first {, exit at symbol past final }
	unit ulist, ulistx, p,q

	ulist:=ulistx:=nil

	lex()			!skip {
	pushblock()
	if params then		!assume top block of function
		blockcounts[1]:=1
	fi

	while lx.symbol<>rcurlysym do
		p:=readstatement()

		if p=nil then nextloop fi				!might have been typedef etc
		if p.tag=jtempdecl then
			repeat
				q:=p.nextunit
				if p.def.code and p.def.nameid<>staticid then
					p.tag:=jdecl
					p.nextunit:=nil
					addlistunit(&ulist,&ulistx,p)
				fi
				p:=q
			until p=nil
		else
			addlistunit(&ulist,&ulistx,p)
		fi
	od
	lex()
	popblock()
	return createunit3(jblock,ulist,nil,ulistx)
end

function readblock(int ifelse=0)unit=

		if not needcompoundblock then
			return readstatement()
		fi
		if lx.symbol=kifsym and ifelse then
			return readstatement()
		fi

		if lx.symbol<>lcurlysym then
			serror("{...} statement expected")
		fi
		return readcompoundstmt(0)
end

function readstatement:unit=
	unit p,q
	ref strbuffer ss
	ref strec d
	int index

	switch lx.symbol
	when kifsym then
		return readifstmt()

	when kforsym then
		return readforstmt()

	when kwhilesym then
		return readwhilestmt()

	when kdosym then
		return readdostmt()

	when kreturnsym then
		return readreturnstmt()

	when kswitchsym then
		return readswitchstmt()

	when lcurlysym then
		return readcompoundstmt(0)

	when kgotosym then
		return readgotostmt()

	when kbreaksym then
		if loopindex then
			if looptypestack[loopindex]='L'then
				p:=createunit0(jbreak)
				lex()
			else
				p:=createunit0(jbreaksw)
				lex()
			fi
		else
			serror("break outside loop/sw")
		fi

	when kcontinuesym then
		index:=loopindex
		while index and looptypestack[index]<>'L' do --index od
		if index=0 then
			serror("continue outside loop")
		fi

		p:=createunit0(jcontinue)
		lex()

	when kcasesym then
		return readcaselabel()

	when kdefaultsym then
		lex()
		skipsymbol(colonsym)
		return createunit1(jdefaultstmt,readstatement())

	when semisym then
		lex()	
		return nil

	when namesym then
		if nextlx.symbol=colonsym then
			p:=createunit1(jlabelstmt,nil)

			d:=resolvename(currproc,lx.symptr,ns_labels,0)
			if d then
				if d.index=-1 then				!already defined
					cpl lx.symptr.name
					terror("2:Duplicate label")
				fi
			else
				d:=createdupldef(currproc,lx.symptr,labelid)
				d.mode:=tvoid
			fi
			d.index:=-1						!indicate defined

			p.def:=d
			lex()				!skip colon
			lex()
			if lx.symbol=rcurlysym then
			elsif istypestarter() or lx.symbol=klinkagesym then
			else
				p.a:=readstatement()
			fi
			return p
		else
			ist_symptr:=nil
			if isusertype(currproc)<>tnotset then
				goto doreaddecl
			fi
			if ist_symptr then lx.symptr:=ist_symptr fi		!make use of name resolve done by isusertype
			p:=readexpression()
		fi
	when ktypespecsym, kstdtypesym, ktypequalsym, klinkagesym, kfnspecsym,
		kstructsym,kunionsym,kenumsym then
	doreaddecl:
		return readlocaldecl()

	when kshowmodesym then
		lex()
		p:=readexpression()
		ss:=strexpr(p)
		println "Mode is:",ss^.strptr,":",Strmode(p^.mode, 1)

	else						!assume expression
		p:=readexpression()
	end switch

	skipsymbol(semisym)

	return p
end

function readifstmt:unit p=
	unit pcond,pbody,pelse
	int lineno

	lex()
	lineno:=lx.lineno

	pcond:=readcond()
	coercecond(pcond)

	pbody:=readblock()

	pelse:=nil

	if lx.symbol=kelsesym then
		lex()

		pelse:=readblock(1)
	fi

	p:=createunit3(jif,pcond,pbody,pelse)
	p.lineno:=lineno

	if iscondtrue(pcond) then		!branch b only
		if pbody=nil then
			pbody:=createunit0(jblock)
		fi
		deleteunit(p,pbody)
	elsif iscondfalse(pcond) then	!branch c only
		if pelse=nil then
			pelse:=createunit0(jblock)
		fi
		deleteunit(p,pelse)
	fi

	return p;
end

global func iscondtrue(unit p)int =
	p.tag=jconst and p.value<>0
end

global func iscondfalse(unit p)int =
	p.tag=jconst and p.value=0
end

global proc deleteunit(unit p,q)=
!delete p, replace by q, so that what was addressed by p now contains q
	unit r:=p.nextunit
	p^:=q^
	p.nextunit:=r
end

function readforstmt:unit=
	unit pinit, pcond, pincr, pbody, ulist,ulistx, p
	int linkage,hasblock,m,mbase
	ref paramrec pm
	ref strec d

	lex()
	skipsymbol(lbracksym)
	hasblock:=0

	if lx.symbol<>semisym then

		if istypestarter() then
			hasblock:=1
			pushblock()

			mbase:=readdeclspec(currproc,linkage)
			ulist:=ulistx:=nil

			docase lx.symbol
			when namesym, mulsym, lbracksym then

				m:=readtype(currproc,d,mbase,pm)
				if d=nil then
					serror("Var name expected")
				fi

				if linkage=typedef_ss or pm then
					serror("Not allowed in for stmt")
				fi
				d:=readframevar(d,m,linkage)

				if d.code then
					p:=createunit0(jdecl)
					p.def:=d
					addlistunit(&ulist,&ulistx,p)
				fi

				case lx.symbol
				when commasym then			!read next item
					lex()
				else
					exit
				esac
			else
				serror("For decl error")
			end docase
			pinit:=createunit3(jblock,ulist,nil,ulistx)

		else
			pinit:=readexpression()
		fi
	else
		pinit:=createunit0(jnull)
	fi
	skipsymbol(semisym)

	if lx.symbol<>semisym then
		pcond:=readexpression()
		coercecond(pcond)
	else
		pcond:=createunit0(jnull)
	fi
	skipsymbol(semisym)

	if lx.symbol<>rbracksym then
		pincr:=readexprstmt()
	else
		pincr:=nil
	fi
	skipsymbol(rbracksym)

	pushloop('L')
	pbody:=readblock()
	poploop()
	if hasblock then
		popblock()
	fi

	pinit.nextunit:=pcond			!the 3 for elements are linked together
	pcond.nextunit:=pincr

	return createunit2(jfor, pinit, pbody)
end

function readwhilestmt:unit=
	unit pcond,pbody

	lex()
	pcond:=readcond()
	coercecond(pcond)
	pushloop('L')
	pbody:=readblock()
	poploop()

	return createunit2(jwhile,pcond,pbody)
end

function readdostmt:unit=
	unit pbody,pcond
	lex()
	pushloop('L')
	pbody:=readblock()
	poploop()
	skipsymbol(kwhilesym)

	pcond:=readcond()
	coercecond(pcond)

	skipsymbol(semisym)
	return createunit2(jdowhile,pbody,pcond)
end

function readreturnstmt:unit=
	unit p
	lex()
	p:=nil

	if lx.symbol<>semisym then
		if currproc.mode=tvoid then
			terror("Can't return value in void function")
		fi

		p:=readexpression()
		p:=coercemode(p,currproc.mode)
		checksymbol(semisym)
	elsif currproc.mode<>tvoid then
		terror("Return value needed")
	fi
	lex()

	return createunit1(jreturn,p)
end

function readgotostmt:unit=
	ref strec d
	unit p

	lex()
	checksymbol(namesym)
	d:=resolvename(currproc,lx.symptr,ns_labels,0)
	if d=nil then					!assume fwd ref
		d:=createdupldef(currproc,lx.symptr,labelid)
		d.mode:=tvoid
	fi
	p:=createunit1(jgoto,nil)

	p.def:=d
	lex()				!skip colon
	skipsymbol(semisym)
	return p
end

function readswitchstmt:unit=
	unit pindex,pstmt,p

	lex()
	pindex:=readcond()			!not a condition, but it doesn't matter
	coercemode(pindex,ti32)

	pushloop('S')
	pstmt:=readblock()			!not a condition, but it doesn't matter
	p:=createunit2(jswitch, pindex, pstmt)
	p.nextcase:=casevaluestack[loopindex]

	poploop()
	return p
end

function readcaselabel:unit=
	unit p,q
	int value

	lex()					!skip case/default
	value:=readconstintexpr()
	skipsymbol(colonsym)

	p:=createunit1(jcasestmt,readstatement())

	p.value:=value

	addcasevalue(value)
	return p
end

function readexprstmt:unit=
	return readexpression()
end

function readcond:unit=
!should be at '(', read conditional expr
	unit pcond
	skipsymbol(lbracksym)
	pcond:=readexpression()
	skipsymbol(rbracksym)
	return pcond
end

function isusertype(ref strec owner)int=
!current symbol is a namesymbol
!return typeno if it resolves to a user type, otherwise tnotset
!will peek at following symbol, and returns 0 if "," or ";" follows
	ref strec d

	d:=resolvename(owner,lx.symptr,ns_general,currblockno)
	if d then
		if d.nameid=typeid then
			return d.mode
		fi
		ist_symptr:=d
	fi
	return tnotset
end

function readlocaldecl:unit=
!at typebase starter inside function or block
	int m,mbase,linkage,nitems,wasenum,wasdef
	ref strec d
	unit ulist,ulistx,p
	ref paramrec pm

	ulist:=ulistx:=nil

	wasenum:=lx.symbol
	mbase:=readdeclspec(currproc,linkage)
	nitems:=0

	docase lx.symbol
	when namesym, mulsym, lbracksym then
		++nitems

		m:=readtype(currproc,d,mbase,pm)
		if d=nil then
			serror("Var name expected")
		fi

		if linkage=typedef_ss then
			d:=createtypedef(currproc,d,m)
		elsif pm then
			if lx.symbol=lcurlysym then
				serror("Nested function")
			fi
			d:=readfunction(d,m,linkage,pm,wasdef, 0)
		else
			d:=readframevar(d,m,linkage)
			p:=createunit0(jtempdecl)
			p.def:=d
			addlistunit(&ulist,&ulistx,p)
		fi
		case lx.symbol
		when commasym then			!read next item
			lex()
		else
			skipsymbol(semisym)
			exit
		esac
	else
		case ttbasetype[mbase]
		when tenum, tstruct, tunion then		!assume defining a [part]type only
			skipsymbol(semisym)
			exit
	when ti32 then
		skipsymbol(semisym)
		exit

		else
			serror_s("Local decl error #",typename(m))
		esac
	end docase

	return ulist
end

function createtypedef(ref strec owner, symptr, int mode)ref strec=
!symptr is a generic symbol for the name
	ref strec d

	d:=checkdupl(owner,symptr,ns_general,currblockno)

	if d then			!existing name
		if d.nameid<>typeid then
			serror_s("Typedef name in use #",d.name)
		fi

		if d.mode<>mode then
			if not comparemode(d.mode, mode) then
				serror_s("Typedef redefined or can't match types #",d.name)
			fi
		fi
		return d
	fi

	d:=createdupldef(owner,symptr,typeid)

	d.mode:=mode
	tttypedef[mode]:=d

	d.blockno:=currblockno
	blockcounts[currblockno]:=1

	return d
end

function readparams(ref strec owner)ref paramrec=
	ref paramrec ulist,ulistx, pm, q
	int m,lastbasetype,nparams,variadic,flags,nnames
	ref strec d

	D:=NIL

	ulist:=ulistx:=nil
	variadic:=nparams:=nnames:=0

	lastbasetype:=tvoid

	int names:=0, nonames:=0,reported:=0

	while lx.symbol<>rbracksym do
		if lx.symbol=ellipsissym then
			variadic:=1
			lex()
			exit
		fi

		if istypestarter() then
			m:=readcasttype(d,1,pm,tvoid,&lastbasetype)
			if pm then			!was a fu nction; convert to fu nction pointer
				m:=createrefmode(createprocmode(m,pm))
			fi
		else
			if lastbasetype=tvoid then
				serror("Param type missing or misspelt")
			fi
			m:=readcasttype(d,1,pm, lastbasetype)

		fi

		case ttbasetype[m]
		when tarray then
			m:=createrefmode(tttarget[m])
		when tproc then
			m:=createrefmode(createprocmode(m,ttparams[m]))
		esac

		pm:=pcm_allocz(paramrec.bytes)
		pm.def:=d
		pm.mode:=m
		++nparams

		if d then names:=1 else nonames:=1 fi

	if names and nonames and not reported then
		reported:=1
	fi

		if d then
			++nnames
			q:=ulist
			while q do
				if q.def=d then
					serror_ss("Param name reused # #",d.name,namenames[d.nameid])
				fi
				q:=q.nextparam
			od

		fi

		addlistparam(&ulist,&ulistx,pm)
		case lx.symbol
		when commasym then
			lex()
		when ellipsissym, rbracksym then
		else
			serror("bad symbol in paramlist")
		esac
	od

	flags:=0
	skipsymbol(rbracksym)

	if variadic then
		flags:=pm_variadic
	elsif nparams=0 then
		flags:=pm_notset
	elsif nparams=1 and m=tvoid then
		flags:=pm_empty
		nparams:=0
		ulist.mode:=tvoid
	fi

	if ulist=nil then
		ulist:=pcm_allocz(paramrec.bytes)
	fi
	ulist.nparams:=nparams
	ulist.flags:=flags

	return ulist
end

function readcasttype(ref strec &d, int allowname=0,ref paramrec &pm,
	int m=tvoid, ref int mbase=nil)int=
!at first symbol of a type-spec
!ref paramrec pm
	ref strec owner
	int linkage

	owner:=(currproc|currproc|stmodule)

	linkage:=0
	d:=nil
	if m=tvoid then
		m:=readdeclspec(owner,linkage)
		if mbase then
			mbase^:=m
		fi

	fi
	pm:=nil

	case lx.symbol
	when namesym, mulsym, lbracksym, lsqsym then
		m:=readtype(owner,d, m, pm)
		if d and not allowname then
			serror_s("NAME not allowed in cast type #",d.name)
		fi
	esac

	return m
end

function readfunction(ref strec d, int m, linkage, ref paramrec pm, int &wasdef, exported)ref strec=
!have read function declaration, with ";" or "{" nextloop
!d is generic st entry for name
!m is return type
!pm is linked list of parameter types
!set up the declaration properly in symbol table, checking for duplicates etc
!read function body if {...} follows
!return wasdef=1 if {...} encountered, as looping in the caller will be affected

	ref strec f,owner
	int scope

	owner:=stmodule
	wasdef:=0

	f:=checkdupl(owner, d, ns_general, 0)

	if f then					!already exists
		if f.nameid<>procid then
			serror_s("fn: name in use #",d.name)
		fi
!COMPARE PARAM LISTS...
!	if e.paramlist<>pm then
!		serror("fn: params don't match previous")
!	fi
		d:=f

!see how scope interacts with existing decl
		scope:=d.scope
		if scope=imported_scope and linkage=none_ss then
			scope:=exported_scope
		elsif linkage=static_ss then
			scope:=local_scope
		fi


	else
		d:=createdupldef(owner,d,procid)
		d.mode:=m
		case linkage
		when static_ss then
			scope:=local_scope
		when extern_ss then
			scope:=imported_scope
		else
			scope:=exported_scope
		esac

	fi

	d.paramlist:=pm
	d.scope:=scope

	if exported then
		d.exported:=1
	fi


	if lx.symbol=lcurlysym then

!CPL "DEFINE FUNC", D.NAME, D.EXPORTED, =EXPORTED
!		if exported then
!			d.exported:=1
!		fi
		wasdef:=1
		if d.code then
			serror_s("Can't define function twice #",d.name)
		fi
		if scope=imported_scope then
			d.scope:=exported_scope
		fi

		readfunctionbody(d)
		if lx.symbol=semisym then
			serror("; after function def")
		fi

	fi

	return d
end

proc readfunctionbody(ref strec f)=
!positioned just after '{'; return at '}' (checked by caller)
	ref strec e
	unit p
	ref paramrec pm
	int pmcount

	currproc:=f
	nextblockno:=currblockno:=0
	pmcount:=0

!add named patams
	pm:=f.paramlist
	to pm.nparams do
		if pm.def=nil then
!			serror("Param name missing")
		else
			e:=createdupldef(f,pm.def,paramid)
			if e.name^='$' then			!assume block ret param
				e.used:=1
			fi

			e.blockno:=1
			e.mode:=pm.mode
		fi
		pm:=pm.nextparam
		pmcount:=1
	od

	p:=readcompoundstmt(pmcount)

	currproc.code:=p
	currproc:=nil
end

function createnegop(unit p)unit=
	unit q
	int t

	t:=p.mode

	if p.tag=jconst then
		case t
		when ti32,ti64,tu64 then
			p.value:=-p.value
			return p
		when tu32 then
			p.value:=(-p.value) iand 0xFFFF'FFFF
			return p
		when tr64 then
			p.xvalue:=-p.xvalue
			return p
		esac
	fi
	retry:
	if t>=tfirstnum and t<=tlastnum then
		coercebasetype(p)
		q:=createunit1(jneg,p)
	elsif ttconst[t] then
		t:=ttconsttype[t]
		goto retry
	else
	CPL strmode(t)
		terror("neg bad type")
	fi

	q.mode:=p.mode
	return q
end

function createabsop(unit p)unit=
	unit q
	int t

	t:=p.mode

	if p.tag=jconst then
		case t
		when ti32,ti64 then
			p.value:=abs(p.value)
			return p
		esac
	fi

	if isintcc(t) then
		coercebasetype(p)
		q:=createunit1(jabs,p)
	else
		terror("abs bad type")
	fi

	q.mode:=p.mode
	return q
end

function createinotop(unit p)unit=
	unit q
	int t

	t:=ttbasetype[p.mode]

	if p.tag=jconst then
		case t
		when ti32,ti64,tu32,tu64 then
			p.value:=inot p.value
			return p
		esac
	fi
	if isintcc(t) then
		coercebasetype(p)
		q:=createunit1(jinot,p)
	else
	cpl strmode(t)
		terror("! bad type")
	fi

	q.mode:=p.mode
	return q
end

function createptrop(unit p)unit=
	unit q
	int t,m

	if not ttisref[t:=p.mode] then
		PRINTUNIT(NIL,P)
		terror("* not pointer")
	fi
	m:=tttarget[t]

!CPL "C/PTR",STRMODE(M)
!CPL "C/PTR",STRMODE(P.MODE)
!CPL "C/PTR",STRMODE(TTTARGET[P.MODE])
!
	case p.tag
	when jaddrof then
		q:=p.a
!		if p.alength then
			q.mode:=tttarget[p.mode]
!		ELSE
!			q.mode:=tttarget[p.mode]
!		FI
!CPL "DONE", STRMODE(Q.MODE)
		fixmemopnd(q)
!CPL "DONE", STRMODE(Q.MODE)
		return q
	esac

	q:=createunit1(jptr,p)
	q.mode:=m
	q:=arraytopointer(q)
	fixmemopnd(q)

	return q
end

function createincrop(int opc,unit p)unit=
!opc is jpreincr/decr or jpostincr/decr
	unit q
	int t

	t:=p.mode

	checklvalue(p,1)

	unless isintcc(t) and t<>tbool or ttisref[t] then
		terror("++ bad type")
	end unless
	q:=createunit1(opc,p)
	q.mode:=p.mode

	return q
end

function createaddrofop(unit p)unit=
	ref strec d
	unit q
	int t,u,alength

	alength:=0

	restartx:
	t:=p.mode
	if p.memmode then t:=p.memmode fi

	switch p.tag
	when jname then
P.DEF.ADDROF:=1
		if p.alength then
			t:=p.def.mode
			alength:=p.alength
		fi

	when jaddrof then
		if p.a.tag=jname and p.a.alength then		!sounds like ANAME => &ANAME
			p.mode:=createrefmode(p.a.def.mode)
	p.alength:=p.a.alength
			return p
		fi
	when jdot then
		q:=p.a
		if q.tag=jptr and q.a.tag=jconst then
			p:=createconstunit(p.offset+q.a.value, ti32)
			return p
		fi
		goto cad1
	when jaddptr then
		if p.alength then
			p.mode:=createrefmode(createarraymode(tttarget[p.mode],p.alength))
			return p
		fi
	when jwidenmem then
		p:=p.a
		goto restartx
	when jfuncname then
		return p
	else

	cad1:
		checklvalue(p)
	end switch

	p:=createunit1(jaddrof,p)
	p.mode:=createrefmode(t)
	p.alength:=alength

	return p
end

function createaddop(unit x,y)unit=
	unit z
	int s,t,u,opc,elemsize

	s:=ttbasetype[getmemmode(x)]
	t:=ttbasetype[getmemmode(y)]
	opc:=jadd

	if u:=dominantmode[s,t] then			!were both numeric
		x:=coercemode(x,u)
		y:=coercemode(y,u)

	elsif s=tref then
	doaddref:
		u:=x.mode
		elemsize:=ttsize[tttarget[u]]
		if x.tag=jconst and y.tag=jconst then
			x.value +:=y.value*elemsize
			return x
		fi

		y:=coercemode(y,tptroffset)

		z:=createunit2(jaddptr,x,y)
		z.mode:=u
		z.ptrscale:=elemsize
		return z

	elsif t=tref then
		swap(x,y)
		goto doaddref
		terror("Sub bad types")
	fi

	if x.tag=jconst then
		if y.tag=jconst then
			return eval_add(opc,x,y,u)
		else
			swap(x,y)
		fi
		if y.value=0 then			!works for int/float
			return x				!x+0 => x
		fi
	fi
	z:=createunit2(opc,x,y)
	z.mode:=u

	return z
end

function createsubop(unit x,y)unit=
	unit z
	int s,t,u,opc,elemsize

	s:=ttbasetype[getmemmode(x)]
	t:=ttbasetype[getmemmode(y)]
	opc:=jsub

	if u:=dominantmode[s,t] then			!were both numeric
		x:=coercemode(x,u)
		y:=coercemode(y,u)
	elsif s=tref then
		if t<>tref then
			u:=x.mode
			elemsize:=ttsize[tttarget[u]]
			y:=coercemode(y,tptroffset)

			z:=createunit2(jsubptr,x,y)
			z.mode:=u
			z.ptrscale:=elemsize
			return z

		else							!ref-ref
			if x.tag=jconst and y.tag=jconst then
				x.value -:= y.value/ttsize[tttarget[x.mode]]
				x.mode:=ti32
				return x

			else
				z:=createunit2(opc,x,y)
				z.mode:=tptroffset
				z:=divunit(z,tttarget[x.mode])
				z.mode:=tptroffset
				return z
			fi
		fi
		y:=mulunit(y,tttarget[x.mode])
	else
		terror("Sub bad types")
	fi

	if x.tag=jconst and y.tag=jconst then
		return eval_sub(opc,x,y,u)
	fi
	if y.tag=jconst and y.value=0 then			!works for int/float
!		return x				!x-0 => x
	fi

	z:=createunit2(opc,x,y)
	z.mode:=u

	return z
end

function createmulop(unit x,y)unit=
	unit z
	int s,t,u,opc

	s:=ttbasetype[getmemmode(x)]
	t:=ttbasetype[getmemmode(y)]

	opc:=jmul
	if u:=dominantmode[s,t] then			!were both numeric
		x:=coercemode(x,u)
		y:=coercemode(y,u)
	else
		terror("Mul bad types")
	fi

	if x.tag=jconst then
		if y.tag=jconst then
			return eval_mul(opc,x,y,u)
		else
			swap(x,y)
		fi
	fi

	z:=createunit2(opc,x,y)
	z.mode:=u

	return z
end

function createdivop(unit x,y)unit=
	unit z
	int s,t,u,opc

	s:=ttbasetype[getmemmode(x)]
	t:=ttbasetype[getmemmode(y)]

	opc:=jdiv
	if u:=dominantmode[s,t] then			!were both numeric
		x:=coercemode(x,u)
		y:=coercemode(y,u)
	else
		terror("Div bad types")
	fi

	if x.tag=jconst and y.tag=jconst then
		return eval_div(opc,x,y,u)
	elsif y.tag=jconst and u=tr64 then
		opc:=jmul
		y.xvalue:=1.0/y.xvalue

	fi
	z:=createunit2(opc,x,y)
	z.mode:=u

	return z
end

function createremop(unit x,y)unit=
	unit z
	int s,t,u,opc

	s:=ttbasetype[x.mode]
	t:=ttbasetype[y.mode]

	opc:=jrem
	if u:=dominantmode[s,t] then			!were both numeric
		if u=tr64 or u=tr32 then
			u:=ti32
		fi
		x:=coercemode(x,u)
		y:=coercemode(y,u)
	else
		terror("Rem bad types")
	fi

	if x.tag=jconst and y.tag=jconst then
		return eval_rem(opc,x,y,u)
	fi
	z:=createunit2(opc,x,y)
	z.mode:=u

	return z
end

proc insertunit(unit p, int tag)=
!wrap extra unit around p, using given tag
	unit q
	q:=createunit0(0)			!empty unit
	q^:=p^
	p.tag:=tag
	p.a:=q
	p.b:=p.c:=nil
	p.lineno:=q.lineno
	p.nextunit:=q.nextunit
	p.memmode:=0

	q.nextunit:=nil
end

function eval_add(int opc,unit x,y,int t)unit=
	unit z

	case t
	when ti32,ti64,tu32,tu64 then
		x.value +:= y.value
		return x
	when tr64 then
		x.xvalue +:= y.xvalue
		return x
	elsif ttbasetype[t]=tref then	!assume y is const 0 int of any sub-type
		x.value +:= y.value*ttsize[tttarget[t]]
		return x			!will not change x
	esac

	z:=createunit2(opc,x,y)
	z.mode:=t
	return z
end

function eval_sub(int opc,unit x,y,int t)unit=
	unit z

	case t
	when ti32,ti64,tu32,tu64 then
		x.value -:= y.value
		return x
	when tr64 then
		x.xvalue -:= y.xvalue
		return x
	elsif ttbasetype[t]=tref then
		if ttbasetype[y.mode]=tref then
			terror("EVALSUB/REF")
		fi
		return x
	esac

	z:=createunit2(opc,x,y)
	z.mode:=t
	return z
end

function eval_mul(int opc,unit x,y,int t)unit=
	unit z

	case t
	when ti32,ti64,ti16,ti8 then
		x.value *:= y.value
		return x
	when tu32,tu64,tu16,tu8 then
		x.uvalue := x.uvalue*y.uvalue
		return x
	when tr64 then
		x.xvalue *:= y.xvalue
		return x
	esac

	z:=createunit2(opc,x,y)
	z.mode:=t
	return z
end

function eval_div(int opc,unit x,y,int t)unit=
	unit z

	case t
	when ti32,ti64 then
		if y.value=0 then serror("div 0") fi
		x.value := x.value/y.value
		return x
	when tu32,tu64 then
		if y.value=0 then serror("div 0") fi
		x.uvalue := x.uvalue/y.uvalue
		return x
	when tr64 then
		x.xvalue /:= y.xvalue
		return x
	esac

	z:=createunit2(opc,x,y)
	z.mode:=t
	return z
end

function eval_rem(int opc,unit x,y,int t)unit=
	unit z

	case t
	when ti32,ti64 then
		if y.value=0 then serror("rem 0") fi
		x.value := x.value rem y.value
		return x
	esac

	z:=createunit2(opc,x,y)
	z.mode:=t
	return z
end

function eval_convert(unit p, int t,opc)int=
!p contains a const unit, t is a target type, opc is conv op
!try and convert if possible
!return 1 if converted
	int s

	if opc=soft_c then
	dosoft:
		p.mode:=t
		return 1
	fi

!RETURN 0
	s:=p.mode
	if s=t then return 1 fi

	case s
	when ti32,ti16,ti8,ti64 then
		case t
		when tr64,tr32 then
			p.xvalue:=p.value
			p.mode:=t
			return 1
		when tu64,ti64,tu32,ti32,ti16,ti8,tu8,tu16 then
	dotrunc:
			case ttsize[t]
			when 1 then
				p.value iand:=255
				if stdsigned[t] then
					p.value:=i8(p.value)
				fi
			when 2 then
				p.value iand:=65535
				if stdsigned[t] then
					p.value:=i16(p.value)
				fi
			when 4 then
				p.value :=p.value iand 0xFFFF'FFFF
				if stdsigned[t] then
					p.value:=i32(p.value)
				fi
			esac
			goto dosoft
		esac
		if ttisref[t] then
			p.mode:=t
			return 1
		fi

	when tu32,tu8,tu16,tu64 then
		case t
		when tr64,tr32 then

			RETURN 0
			p.mode:=t
			return 1
		when tu64,ti64,ti32,tu32,tu64,tu16,ti8,tu8,ti16 then
			goto dotrunc
		esac
		if ttisref[t] then
			p.mode:=t
			return 1
		fi

	when tr64 then
		case t
		when ti32,ti64 then
			p.value:=p.xvalue
			p.mode:=t
			return 1
		when tu32,tu64 then
!		p.uvalue:=p.xvalue
			p.value:=p.xvalue
			p.mode:=t
			return 1
		when tr32 then
			p.mode:=tr32
			return 1
		esac
	elsif ttisref[p.mode] then
		if not p.isstrconst then
			case t
			when ti32,ti64,tu32,tu64 then
				p.mode:=t
				return 1
			esac
		fi
	esac

	return 0
end

proc coercecond(unit p)=
!p is an expression used as a condition
!Ensure result is i32; it doesn't need to be 0 or 1
!Anything else has istrue added

	int t
	if (t:=p.mode)=ti32 then return fi

	retry:
	case ttbasetype[t]
	when tr32,tr64,tref then
		goto doint

	elsif isintcc(t) then
	doint:
		if p.tag=jconst and p.value then			!check all types as one 64-bit field
			p.value:=1
		elsif p.tag=jconst and not p.value then			!check all types as one 64-bit field
			p.value:=0
		else
			insertunit(p,jistruel)
		fi
	elsif ttconst[t] then
		t:=ttconsttype[t]
		goto retry
	else

		serror_s("Invalid condition #",strmode(t))
	esac
	p.mode:=ti32
end

proc coercebasetype(unit p)=
	int t

	if (t:=p.mode)>=ti8 and t<=ti16 then
		p:=coercemode(p,ti32)
	elsif t>=tbool and t<=tu16 then
		p:=coercemode(p,tu32)
	fi
end

proc checklvalue(unit p, int assign=0)=

	case p.tag
	when jname then
	when jptr then

	when jfuncname then
		if assign then notlv fi

	when jwidenmem then
		case p.a.tag
		when jname,jptr,jdot then
			p^:=p.a^
		else
			terror("CHECKLV/WIDEN")
		esac

	when jdot then

	when jconst then
		if not ttisref[p.mode] then
			goto notlv
		fi
	when jconvert then
		if assign then notlv fi

	else
	notlv:
		printunit(nil,p)
		terror_s("value: #",jtagnames[p.tag])
	esac
end

function createcall(unit p,q)unit=
!p is unit on left of param list, while q is the param list as the head of a unitlist
!do type-checking on params, and construct and return callfn unit
!p can be a simple name, or an expression that should be a function po inter
	unit r,s,u
	ref strec d
	ref paramrec pm
	int i,nparams,aparams,retmode,mproc,m,c
	[1024]char str
	ichar ss,tt,uu
	ref strbuffer exprstr

	d:=nil

	case p.tag
	when jptr then
	doptr:
		mproc:=p.mode

		while ttbasetype[mproc]=tref do
			r:=createunit1(jptr,p)
			mproc:=tttarget[mproc]
			r.mode:=mproc
			p:=r
		od

		if ttbasetype[mproc]<>tproc then
			serror_s("Not function pointer: #",typename(mproc))
		fi

		pm:=ttparams[mproc]
		retmode:=tttarget[mproc]

	when jname,jfuncname then
		d:=p.def
		if d.nameid=procid then
			pm:=d.paramlist
			retmode:=d.mode
		else							!assume fnptr, but needs ptr unit
			goto doptr
		fi
	when jdot,jcallfn,jifx,jconvert,jexprlist then
		r:=createunit1(jptr,p)
		r.mode:=tttarget[p.mode]
		p:=r
		goto doptr

	else
		CPL =JTAGNAMES[P.TAG]
		PRINTUNIT(NIL,P)
		serror("ccall?")
	esac

	nparams:=pm.nparams
	aparams:=0

	s:=q
	while s do
		++aparams				!number of actual params supplied
		s:=s.nextunit
	od

	if aparams<nparams then
		terror("1:Too few args")
	elsif aparams>nparams and pm.flags<>pm_variadic and pm.flags<>pm_notset then
!elsif aparams>nparams and pm.flags<>pm_variadic then
		if pm.flags<>pm_notset then
			cpl aparams,nparams


			terror("Too many args")
		fi
	fi

	s:=q

	for i:=1 to aparams do
		if i<=nparams then
			coercemode_inplace(s,pm.mode)
			pm:=pm.nextparam
		else					!assume variadic param
			if s.mode=tvoid then
				terror("Variadic param is void")
			fi
			coercebasetype(s)
		fi
		s:=s.nextunit
	od

	r:=createunit2(jcallfn,p,q)
	r.mode:=retmode
	fixmemopnd(r)
	r.aparams:=aparams

	return r
end

function arraytopointer(unit p)unit=
	unit q
	int offset
	int t,elemmode,refmode

	t:=p.mode
	elemmode:=tttarget[t]

	if ttbasetype[t]=tarray then
		refmode:=createrefmode(elemmode)
		case p.tag
		when jptr then
			p:=p.a

		when jdot then						!about to access array field
			offset:=p.offset
			p.tag:=jaddptr
			p.ptrscale:=1	!ttsize[elemmode]
			q:=createunit1(jaddrof,p.a)
			q.mode:=refmode
			p.a:=q
			p.b:=createconstunit(offset,ti32)

		else
			CPL "ATP:"
			printunit(nil,p)
			terror("ATP?")
		esac

		p.mode:=refmode
		p.alength:=ttlength[t]

	fi
	return p
end

function createindexop(unit p,q)unit=
!do p[q]
!convert to *(p+q)
	unit a

	a:=createaddop(p,q)
	return createptrop(a)
end

function readstructdecl(ref strec owner)int=
	ref strec d,e,currrecord
	ref strec ulist,ulistx,tagowner
	int funion,linkage,mbase,m
	int offset,recsize,maxsize,maxalignment,alignment,size
	ref paramrec pm
	ref fieldrec fieldlist,fl

	funion:=(lx.symbol=kunionsym)

	lex()				!skip 'struct' etc

	tagowner:=(currproc|currproc|stmodule)

	if lx.symbol=lcurlysym then				!anonymous struct tag
		d:=addnamestr(nextautotype())
	else
		checksymbol(namesym)
		d:=lx.symptr		!should be struct tag
		lex()

		if lx.symbol<>lcurlysym then			!reading incomplete enum
			e:=resolvename(tagowner,d,ns_tags,currblockno)
			if e then
				if e.nameid<>structtagid then
					serror_s("Struct tag in use #",e.name)
				fi

				return e.mode
			fi
!create new incomplete tag
			e:=createdupldef(tagowner,d,structtagid)
			e.mode:=createstructmode(e,(funion|tunion|tstruct))
			e.blockno:=currblockno
			blockcounts[currblockno]:=1
			return e.mode
		fi
	fi

!{ seen, so defining a new struct

	e:=checkdupl(tagowner,d,ns_tags,currblockno)

	if e then			!found in this linkage
		if e.nameid<>structtagid then
			serror_s("Struct tag in use #",e.name)
		fi
		if e.deflist then					!else filling in incomplete enum
			cpl "Prev",e.lineno iand 1677215, sourcefilenames[e.lineno>>24],sourcefilepaths[e.lineno>>24]
			serror_s("Redefining struct #",e.name)
		fi
	else						
		e:=createdupldef(tagowner,d,structtagid)
		e.mode:=createstructmode(e,(funion|tunion|tstruct))
		e.blockno:=currblockno
		blockcounts[currblockno]:=1
	fi

!e points to an def which has an empty {...} list
	lex()							!skip {

	currrecord:=e
	ulist:=ulistx:=nil
	offset:=maxsize:=recsize:=0
	maxalignment:=1
	fieldlist:=nil
	m:=-1

	while lx.symbol<>rcurlysym do
		mbase:=readdeclspec(currrecord,linkage)

		docase lx.symbol
		when namesym, mulsym, lbracksym then

			m:=readtype(currrecord,d,mbase,pm)
			if d=nil then
				serror("Field name expected")
			fi

			if linkage=typedef_ss or pm then
				serror("typedef or function inside struct")
			fi

			e:=checkdupl(currrecord, d, ns_fields, 0)

			if e then					!already exists
				serror_s("member name in use #",e.name)
			fi

			if linkage<>none_ss then
				serror("Can't use ss in struct")
			fi

	addanonfield:
			d:=createdupldef(nil,d,fieldid)
			d.mode:=m
!name is not linked in to record as they must be in sequence
			addlistdef(&ulist,&ulistx,d)
			currrecord.deflist:=ulist				!needed for dupl checking
			currrecord.deflistx:=ulistx
			d.owner:=currrecord
			alignment:=getalignment(m)
			if alignment>maxalignment then maxalignment:=alignment fi

			d.offset:=roundoffset(offset,alignment)
			size:=ttsize[m]
			recsize+:=d.offset-offset
			offset:=d.offset

			addnewfield(fieldlist,d,offset)

			if funion then
				maxsize:=max(maxsize,size)
			else
				offset+:=size
				recsize+:=size
			fi

			if lx.symbol=colonsym then
				lex()
				readassignexpr()
			fi

			case lx.symbol
			when commasym then			!read next item
				lex()
			else
				skipsymbol(semisym)
				exit
			esac
		when colonsym then				!apparently int:24 is allowed, with no member name
			lex()
			readassignexpr()
			skipsymbol(semisym)
			exit
		else
			case ttbasetype[mbase]
			when tstruct, tunion then		!assume defining a [part]type only
				d:=getautofieldname()
				m:=mbase
				goto addanonfield
			else
				if m=-1 then
					serror("Struct decl error")
				else
					serror_s("Struct decl error #",typename(m))
				fi
			esac
		end docase
	od

	skipsymbol(rcurlysym)

	currrecord.nextfield:=fieldlist
	ttsize[currrecord.mode]:=roundoffset((funion|maxsize|recsize),maxalignment)
	currrecord.align:=maxalignment

	m:=currrecord.mode
	if ttconsttype[m] then
		ttsize[ttconsttype[m]]:=ttsize[m]
	fi

	if ttsize[currrecord.mode] in [1,2,4,8] then ttisblock[currrecord.mode]:=0 fi

	return currrecord.mode
end

function checkpointertypes(int s,t,hard)int=
!return 1 if pointer types s and t are compatible
!it is assumed that s is to be converted to t, or passed as a parameter expecting t
	int starget:=tttarget[s], ttarget:=tttarget[t]
	int sbase, tbase
	int sconst:=0,tconst:=0

	if ttconst[starget] then
		starget:=ttconsttype[starget]
		sconst:=1
	fi
	if ttconst[ttarget] then
		ttarget:=ttconsttype[ttarget]
		tconst:=1
	fi

	if not hard and sconst and not tconst then
		cpl strmode(s)
		cpl strmode(t)
		terror("const to non-const pointer")
	fi

	if starget=ttarget then return 1 fi

	s:=starget
	t:=ttarget
	sbase:=ttbasetype[s]
	tbase:=ttbasetype[t]

	if sbase in tfirstint..tlastint and tbase in tfirstint..tlastint then
		if ttsize[sbase]=ttsize[tbase] then		!ignore sign differences
			return 1
		fi
	fi

	if sbase=tvoid or tbase=tvoid then
		return 1
	fi

	if ttisref[s] and ttisref[t] then
		return checkpointertypes(s,t,hard)

	elsif ttbasetype[s]=tarray and ttbasetype[t]=tarray then
		if ttlength[s]<>ttlength[t] then
			if ttlength[s] and ttlength[t] then		!allow one dim to be 0
CPL "BAD REF[]"
RETURN 1
				return 0
			fi
		fi
		starget:=tttarget[s]
		ttarget:=tttarget[t]
		if starget=ttarget then return 1 fi
 
		if ttisref[starget] and ttisref[ttarget] then
			return checkpointertypes(starget,ttarget,hard)
		fi
		if ttbasetype[starget]=tarray and ttbasetype[ttarget]=tarray then
			return checkpointertypes(starget,ttarget,hard)
		fi
	elsif ttbasetype[s]=tproc and ttbasetype[t]=tproc then
		return 1				!NEED PROPER MATCH HERE
	fi

	return 0
end

function comparemode(int s,t)int=
!types s and t don't immediately match
!check further to see if they are compatible
!For example, if they are both arrays, then usually they will have different
!typenumbers. Arrays should match if they have the same element type, and
!same length, or one length is 0
!return 1 for compatible types

	if s=t then return 1 fi			!for when used recursively
	if ttbasetype[s]=tarray and ttbasetype[s]=tarray then
		if comparemode(tttarget[s],tttarget[t])=0 then
			return 0
		fi
		if ttlength[s]=0 or ttlength[t]=0 or ttlength[s]=ttlength[t] then
			return 1
		fi
	fi
	return 0
end

function readenumdecl(ref strec owner)int=
	ref strec d,e

	lex()				!skip 'enum'

	if lx.symbol=lcurlysym then				!anonymous enum tag
		readenumnames(owner)
		return tenum			!return generic enum
	fi

	checksymbol(namesym)
	d:=lx.symptr		!should be enum tag
	lex()

	if lx.symbol<>lcurlysym then			!reading incomplete enum
		e:=checkdupl(owner, d, ns_tags, currblockno)

		if e then
			if e.nameid<>enumtagid then
				serror_s("Enum tag in use #",e.name)
			fi
		fi

!create new incomplete enum tag
		e:=createdupldef(owner,d,enumtagid)
		e.mode:=createenummode(e)
		e.blockno:=currblockno
		blockcounts[currblockno]:=1
		return e.mode
	fi

!{ seen, so defining a new enum
	e:=checkdupl(owner,d,ns_tags,currblockno)

	if e then			!found in this linkage
		if e.nameid<>enumtagid then
			serror_s("Enum tag in use #",e.name)
		fi
		if e.deflist then					!else filling in incomplete enum
			serror_s("Redefining enum #",e.name)
		fi
	else						
		e:=createdupldef(owner,d,enumtagid)
		e.mode:=createenummode(e)
		e.blockno:=currblockno
		blockcounts[currblockno]:=1
	fi

!e points to an enum def which has an empty {...} list
!Now loop reading enum values

	readenumnames(owner)

	ttnamedef[e.mode]:=e
	return e.mode
end

proc readenumnames(ref strec owner)=
!at '{'; read set of enum names
	ref strec d,e
	ref strec ulist,ulistx
	int enumseq

	ulist:=ulistx:=nil
	enumseq:=0
	lex()

	case owner.nameid
	when procid,moduleid then		!fine
	else							!probably inside a struct
		owner:=(currproc|currproc|stmodule)
	esac

	while lx.symbol=namesym do
		d:=checkdupl(owner,lx.symptr,ns_general,currblockno)
		if d then
			serror_s("enum name reused #",d.name)
		fi
		d:=createdupldef(owner,lx.symptr,enumid)
		lex()
		if lx.symbol=assignsym then
			lex()
			enumseq:=readconstintexpr()
		fi
		d.index:=enumseq
		d.blockno:=currblockno
		blockcounts[currblockno]:=1
		++enumseq	
		if lx.symbol=commasym then
			lex()
		fi
	od
	skipsymbol(rcurlysym)
end

function createdotop(int opc, unit p,ref strec d)unit=
!opc is jdot or jidot
!Deal with field selection for p.d or p->d
	unit q,r,poffset,pb,pc
	ref strec e,f,prec,panon,pfield,gend
	int m,offset,scale
	ref fieldrec fl

!check that m is a proper pointer if needed, and a struct or union
	m:=p.mode
	if opc=jidot then			!
!	if ttbasetype[m]<>tref then
		if not ttisref[m] then
			serror("-> needs pointer")
		fi
		m:=tttarget[m]
	fi
	case ttbasetype[m]
	when tstruct,tunion then
	else
		serror(". -> not a struct")
	esac

!now need to resolve the field name d
	prec:=ttnamedef[m]				!r is record def

	f:=d
	while f:=f.nextdupl do
		if f.owner=prec then
			offset:=f.offset
			exit
		fi
	od

!not found; look for any anon fields
	if not f then
		gend:=d						!find generic field name version
		while gend.prevdupl do
			gend:=gend.prevdupl
		od

		fl:=prec.nextfield
		while fl do					!now search linear field list matching generic entries
			if fl.gendef=gend then
				f:=fl.def
				offset:=fl.offset
				exit
			fi
			fl:=fl.nextfield
		od
	fi

	if not f then
		terror_ss("Not a field of struct # #",d.name,strmode(m))
	fi


	poffset:=createconstunit(offset,ti32)

!will be p->field, or p.field
!p.field: *(p+offset)

	if opc=jidot then				!apply offset to lhs
		p:=createptrop(p)
	fi

	p:=createunit1(jdot,p)
	p.offset:=offset

	p.mode:=f.mode
	p:=arraytopointer(p)
	fixmemopnd(p)

	return p
end

function mulunit(unit p, int elemtype)unit=
!p is an int unit representing some offset i for *(A+i) or A[i]
!apply a scale so that is a byte offset
!t is the element type
	int elemsize

	if (elemsize:=ttsize[elemtype])<>1 then
		if p.tag=jconst then
			p.value:=p.value*elemsize
		else
			p:=createunit1(jscale,p)
			p.scale:=elemsize
			p.mode:=tptroffset
		fi
	fi
	return p
end

function divunit(unit p, int elemtype)unit=
	int elemsize

	if (elemsize:=ttsize[elemtype])<>1 then
		if p.tag=jconst then
			p.value:=p.value/elemsize
		else
			p:=createunit1(jscale,p)
			p.scale:=-elemsize
			p.mode:=tptroffset
		fi
	fi
	return p
end

function createassignopref(int opc, unit p,q)unit=
!opc is assignsym, addtosym etc
!do assign/addto when is a ref type
!return resulting unit
	int pmode,qmode,rmode,elemmode
	unit r

	pmode:=rmode:=p.mode
	elemmode:=tttarget[pmode]
	qmode:=q.mode

	case opc
	when assignsym then
		q:=coercemode(q,pmode)
		r:=createunit2(jassign,p,q)

	when addtosym then
		if ttisref[qmode] then		!ref+=ref
			serror("ptr+=ptr")
		fi

		q:=coercemode(q,tptroffset)					!ref+=int
		r:=createunit2(jaddto,p,mulunit(q,elemmode))

	when subtosym then
		if ttisref[qmode] then		!ref-=ref
			if not comparemode(pmode,qmode) then
				serror("-= refs don't match")
			fi
			r:=divunit(createunit2(jsub,p,q),elemmode)
			rmode:=ti32
		else								!ref-=int
			r:=createunit2(jsubto,p,mulunit(q,elemmode))
		fi
	else
		serror("Not allowed on ptrs")
	esac

	r.mode:=rmode
	return r
end

proc addnewfield(ref fieldrec &flist, ref strec d, int offset)=
!new field d has just been created for a record
!add it to the linear list of fields for the record
	ref strec e
	ref fieldrec f

	if d.name^<>'$' then			!normal field
		f:=pcm_allocz(f^.bytes)
		f.def:=d
		while d.prevdupl do			!look for generic entry
			d:=d.prevdupl
		od
		f.gendef:=d
		f.offset:=offset

		f.nextfield:=flist
		flist:=f

	else
		e:=ttnamedef[d.mode].deflist
		while e do
			addnewfield(flist,e,offset+e.offset)
			e:=e.nextdef
		od
	fi
end

proc pushloop(int looptype)=
!looptype is 'L' or 'S', ie a switch, so not really a loop
	if loopindex>=maxnestedloops then
		serror("Too many nested loop or switch")
	fi
	++loopindex
	looptypestack[loopindex]:=looptype
	casevaluestack[loopindex]:=nil

end

proc poploop=
	if loopindex then
		--loopindex
	else
		serror("poploop?")
	fi
end

proc addcasevalue(int value)=
	ref caserec p

	int index:=loopindex
	while index and looptypestack[index]<>'S' do
		--index
	od
	if index=0 then serror("case not inside switch stmt") fi

	p:=pcm_alloc(caserec.bytes)
	p.value:=value
	p.nextcase:=casevaluestack[index]
	casevaluestack[index]:=p
end

function roundoffset(int offset, alignment)int=
	int mask

	if structpadding then
		if alignment=1 then return offset fi
		mask:=alignment-1
		while offset iand mask do ++offset od
	fi
	return offset
end

proc fixmemopnd(unit p)=
	int t

!when p refers to a 1- 2- byte value, adjust the type
	if ingeneric then return fi

	case t:= ttbasetype[p.mode]
	when ti8,ti16,tu8,tu16,tbool then
		p.memmode:=t
		p.mode:=ti32
	esac
end

function docast(unit p,int t,hard=1,inplace=0)unit=
!apply cast to unit p
!if no cast needed, then just return p
	unit q
	int s,opc

	s:=p.mode

!CPL "DOCAST", STRMODE(S), STRMODE(T), S, T

	retry:

	if s=t then return p fi
	opc:=0

	if s<16 and t<16 then
		opc:=conversionops[s,t]

	elsif ttisref[s] and ttisref[t] then
		if checkpointertypes(s,t,hard) then
			p.mode:=t
			return p
		fi

	elsif ttconst[s] then
		s:=ttconsttype[s]
		goto retry
	elsif ttconst[t] then
		t:=ttconsttype[t]
		goto retry
!elsif ttisref[t] and (s>=tfirstint and s<=tlastint) and p.tag=jconst and p.value=0 then
	elsif ttisref[t] and isintcc(s) and p.tag=jconst and p.value=0 then
		opc:=soft_c
	fi

	if opc=0 then
		if not hard then
			cpl strmode(s)
			cpl strmode(t)

	PRINTUNIT(NIL,P)

			terror_ss("Can't do conversion # => #",typename(s),typename(t))
		fi
		opc:=hard_c
	fi

	case p.tag
	when jconst then		!try and convert
		if eval_convert(p,t,opc) then
			return p
		fi
	when jfuncname then
		p.mode:=t
		return p
	when jadd then
		if p.a.tag=jconst and p.b.tag=jconst then
			p.value:=p.a.value+p.b.value
			p.mode:=t
			p.tag:=jconst
			return p
		fi
	esac

	if inplace then
		insertunit(p,jconvert)
		p.convmode:=t
		p.mode:=getpromotedtype(t)
		p.opcode:=opc
		return nil
	else
		q:=createunit1(jconvert,p)
		q.opcode:=opc
		q.convmode:=t
		q.mode:=getpromotedtype(t)
	fi
	return q
end

function coercemode(unit p, int t)unit=
	int s,opc
	unit q

	if p.mode=t then return p fi
	docast(p,t,0,1)
	return p
end

proc coercemode_inplace(unit p, int t)=
	int s,opc
	unit q

	if p.mode=t then return fi
	docast(p,t,0,inplace:1)
end

function createsizeofop(unit p, int islength=0)unit=
	unit q
	int t,size

if islength and p.tag not in [jaddptr, jaddrof] then
printunit(nil,p)
 serror("Not array") fi

	t:=getmemmode(p)

	switch p.tag
	when jname then
		if p.alength then
			size:=ttsize[p.def.mode]/p.alength			!take account of array

		else
			size:=ttsize[p.def.mode]			!take account of array
		fi
	when jconst then
		case t
		when trefchar then					!const string
			size:=p.slength
		when trefwchar then
			size:=p.wslength*2
		else
			size:=ttsize[t]
		esac

	when jptr then
		if ttisref[t] and p.alength then		!result of array=>ptr conversion
			size:=ttsize[tttarget[t]]*p.alength
		else
			size:=ttsize[t]
		fi

	when jaddptr then
		if p.alength then	!derived from array expr that converted to pointer
			if islength then
				size:=p.alength
			else
				size:=ttsize[tttarget[t]]*p.alength
			fi

		else
			goto cad1
		fi

	when jaddrof then
		if p.a.tag=jname and p.a.alength then
			if islength then
				size:=p.a.alength
			else
				size:=ttsize[p.a.def.mode]
			fi
		else
			size:=8
		fi

	when jwidenmem then
		return createsizeofop(p.a)

	else
	cad1:
		size:=ttsize[t]
	end switch

	q:=createconstunit(size,tu64)
	return q
end

function readgeneric:unit=
!read generic construct; return chosen expr according to type of control expr
!at '_Generic'
	unit pexpr,pmatch,p
	ref paramrec pm
	int m,t,def,oldingeneric,count
	ref strec d

	lex()
	checksymbol(lbracksym)
	lex()
	oldingeneric:=ingeneric
	ingeneric:=1
	pexpr:=readassignexpr()
	ingeneric:=oldingeneric

	m:=pexpr.mode
	pmatch:=nil
	def:=0
	count:=0

	checksymbol(commasym)

	repeat						!at comma
		lex()					!skip comma
		if lx.symbol=kdefaultsym then
			if def then serror("generic/default twice") fi
			def:=1
			if count=0 then t:=-1 else t:=-2 fi
			lex()
		else
			t:=readcasttype(d,0,pm)
		fi
		checksymbol(colonsym)
		lex()
		p:=readassignexpr()

		if (t=-1 or t=m) then

			pmatch:=p
			++count
		fi
	until lx.symbol<>commasym

	checksymbol(rbracksym)
	lex()
	if not pmatch then serror("Generic: no type match") fi
	if count>1 then serror("Generic: multiple types match") fi

	return pmatch
end

global function getmemmode(unit p)int=
!return mode of p, but if p is a widening unit, see past that to
!the original memory mode
	if p.memmode then
		return p.memmode
	else
		return p.mode
	fi
end

func getpromotedtype(int t)int=
!if t is small, get promoted type
	if t=tvoid then return tvoid fi
	if ttsize[t]<4 then				!all 
		return ti32
	fi
	t
end

func readdllexport:int exported=
	exported:=0
	lex()
	checksymbol(lbracksym)
	lex()
	if lx.symbol=namesym and eqstring(lx.symptr.name, "dllexport") then
		exported:=1
	fi
	lex()
	checksymbol(rbracksym)
	lex()

	exported
end
=== cc_pcl.m 0 0 18/108 ===
global type pcl = ref pclrec

global record pclrec =
	byte opndtype
	byte opcode
	byte mode				!0/void, or primary or dest type
	byte smode				!0/void, or source type
	u32 size				!mode size (for block, size of full user mode, not pcl type)

	union
		struct
			union
				i64 value
				r64 xvalue
				r32 xvalue32
				ichar svalue
				int labelno
				symbol def
				ref void asmcode
			end
			union						!two 32-bit params used according to opcode
				struct
					i32 x				!common access to these 1/2 extra attribs
					i32 y
				end

				struct					! (x,y) pointer ops
					i32 scale			! scale factor for offset
					i32 extra			! extra constant byte offset, already scaled
				end
				struct					! (x,y) call/etc
					i32 nargs			! number of args
					i32 nvariadics	! 0, or arg # that is first variadic
				end
				struct					! (x,y) switch
					i32 minlab
					i32 maxlab
				end

!				i32 oldmode			! (x) u in tables
				i32 stepx				! (x) always +ve fixed step size for forup/fordown; also INCR
!				i32 truncmode			! (x) convert/truncate: truncated mode
				i32 align
				i32 nret				! (x) setretmult: no. of return values
				i32 popone			! (x) jumpcc: leave X on stack
				i32 strindex			! (x) any string operand: index into string table
				i32 realindex			! (x) any real operand: index into r64/real table
!				i32 realindex			! (x) any r32 operand: index into r32 table

			end
		end
	end
	u32 lineno
	u8	fileno
	u8  wide							!1 for r64 type rather than r32
	u8  cond							!keq etc for jumpcc/setcc

	byte spare

!	u16 spare2
!	u16 SEQ
end

global record pclstackrec =
	byte loc			!loc code (stack, reg, xreg usually)
	byte reg			!reg or xreg when in register
	byte cat			!void/int/real/block
	byte size			!4/8 for d32/d64 and x32/x64
	byte wide			!0/1 for 4/8; can be added to opcodes like addss to yield addsd
	byte ilabel			!1 to load contents of label type, not its address
	byte count			!instances of opnd, usually 1
	byte spare
end

global record pclvaluerec =
	union
		u64	value		!immediate value
		r64	xvalue		!
		r32	xvalue32	!
!		ichar svalue
		int strindex
		int realindex
		symbol def		!for memaddr
		struct
			i32 labno		!for labels
			i32 offset
		end
		mcloperand mopnd
	end
end

!note: the pclstack grows downwards, so that pclstack[1] varies: gets nearer
!to the start as the stack grows. pclstack[2] etc is above that, a moving window
!of operands near the top of the stack
!global ref[]pclstackrec pclstack
global pclstackrec pclstackdefault


global record constrec =
	union
		int value
		real xvalue
		ichar svalue
	end
	ref constrec nextconst
	int labelno
end

!Stack operands depend on A in (A B); the last (X/Y/Z) is pushed last and
!is top of stack:
!
! A = 1       X
! A = 2       X Y
! A = 3       X Y Z
! A = 4       X Y Z W
!
!It can be assumed that all are popped
!New stack contents are indicated by X' and sometimes X' Y' which are pushed

!Immediate operand:
!   A			(various)
!Extra info:
!   op			opindex
!   fn			fnindex
!   cc			cond code
!   t[:size]    type (:size for block types)
!   u           secondary type for some ops (convert etc)
!   n			nargs for calls
!   s x			scale and offset for ptr/offset ops
!   x y			min/max lab index for switch
!	B			Secondary operand in a following kopnd instruction
!	C			Tertiary operand in a following kopnd instruction

!Stack usage is represented by (a b):
! a is the number of stack elements that will be popped
! b is the number of new stack elements that will be pushed
! Something like (1 1) can mean the same element stays in place


export enumdata [0:]ichar pclnames, [0:]byte pclfversion =
	(knop = 0,		$,	0),	! 
	(kstop,			$,	0),	! 

	(kcomment,		$,	0),	! 
	(kistatic,		$,	0),	! 
	(kzstatic,		$,	0),	! 
	(kprocdef,		$,	0),	! 
	(kendproc,		$,	0),	! 
	(kendprogram,	$,	0),	! 
	(klabel,		$,	0),	! 

	(kloadimm,		$,	0),	! A => d32/d64
	(kfloadimm,		$,	0),	! A => r32/r64
	(kloadaddr,		$,	0),	! &A => d64

	(kload,			$,	2),	! i8/i16/i32/u8/u16/u32 => d32, i64/u64 => d64
	(kfload,		$,	0),	! r32/r64
	(kmload,		$,	0),	! &block => d64

	(kstore,		$,	2),	! d32/d64 => d8/d16/d32/d64
	(kfstore,		$,	0),	! r32/r64 => r32/r64
	(kmstore,		$,	0),	! d64^ => block

	(kloadptr,		$,	2),	! i8/i16/i32/u8/u16/u32 => d32, i64/u64 => d64
	(kfloadptr,		$,	0),	! r32/r64 => r32/d64
	(kmloadptr,		$,	0),	! <nop?

	(kstoreptr,		$,	2),	! d32/d64 => d8/d16/d32/d64
	(kfstoreptr,	$,	0),	! r32/r64 => r32/r64
	(kmstoreptr,	$,	0),	! d64^ => block

	(kdupl,			$,	0),	! 
	(kduplopnds,	$,	0),	! 

	(kswapopnds,	$,	0),	! 
	(kunload,		$,	0),	! 
	(kopnd,			$,	0),	! 

	(keval,			$,	0),	! 

	(kcall,			$,	0),	! Call A
	(kcallptr,		$,	0),	! Call X^
	(kretproc,		$,	0),	!

	(kcallf,		$,	1),	! i8/i16/d32/d64/u8/u16/ X^ := Call A
	(kfcallf,		$,	0),	! r32/r64 X^ := Call A

	(kcallfptr,		$,	1),	! "  X' := Call X^
	(kfcallfptr,	$,	0),	! r32/r64 X' := Call X^
	(kretfn,		$,	0),	! 

	(kjump,			$,	0),	! Jump to L

	(kjumpcc,		$,	1),	! i32/i64/u32/u64 Jump to L when cond
	(kfjumpcc,		$,	0),	! r32/r64 Jump to L when cond

	(kjumptrue,		$,	1),	! d32/d64 Jump to L when cond
	(kfjumptrue,	$,	0),	! r32/r64
	(kjumpfalse,	$,	1),	! d32/d64
	(kfjumpfalse,	$,	0),	! r32/r64

	(ksetcc,		$,	1),	! i32/i64/u32/u64 => 0/1 in d32
	(kfsetcc,		$,	0),	! r32/r64 => 0/1 in d32

	(kswitch,		$,	0),	! i32/i64
	(kswitchlab,	$,	0),	! 
	(kendsw,		$,	0),	! 

	(kdb,			$,	0),	! 
	(kdw,			$,	0),	! 
	(kdd,			$,	0),	! 
	(kdq,			$,	0),	! 

	(kadd,			$,	1),	! d32/d64 X' := X + Y
	(kfadd,			$,	0),	! r32/r64 X' := X + Y
	(ksub,			$,	1),	! d32/d64
	(kfsub,			$,	0),	! 
	(kmul,			$,	1),	! d32/d64
	(kfmul,			$,	0),	! 
	(kdiv,			$,	1),	! i32/i64 u32/u64
	(kfdiv,			$,	0),	! 

	(krem,			$,	0),	! i32/i64 u32/u64
	(kiand,			$,	0),	! d32/d64
	(kior,			$,	0),	! d32/d64
	(kixor,			$,	0),	! d32/d64
	(kshl,			$,	0),	! d32/d64 X' := X << Y
	(kshr,			$,	0),	! i32/i64/u32/u64	X' := X << Y

	(kaddoff,		$,	0),	! d64 => d64 X' := X + Y*scale + offset
	(ksuboff,		$,	0),	! d64 => d64 X' := X - (Y*scale + offset)
	(ksubptr,		$,	0),	! d64 => d32 X' := (X - Y)/scale

	(kneg,			$,	1),	! d32/d64
	(kfneg,			$,	0),	! r32/r64

	(kinot,			$,	0),	! d32/d64
	(knotl,			$,	1),	! d32/d64 => 0/1 in d32; mode is d32/d64
	(kfnotl,		$,	0),	! r32/r64 => 0/1 in d32
	(knotnotl,		$,	1),	! d32/d64 => 0/1 in d32
	(kfnotnotl,		$,	0),	! r32/r64 => 0/1 in d32

	(kincr,			$,	0),	! d8/d16/d32/d64
	(kdecr,			$,	0),	! 

	(kincrload,		$,	0),	! i8/i16/i32/u8/u16 => i32, u32 => u32, i64->i64, u64->u64
	(kdecrload,		$,	0),	!
	(kloadincr,		$,	0),	! 
	(kloaddecr,		$,	0),	! 

	(kaddto,		$,	1),	! d8/d16/d32/d64 X^ +:= Y; Y can be wider
	(kfaddto,		$,	0),	! r32/r64 X^ +:= Y; Y must match LHS type

	(ksubto,		$,	1),	! 
	(kfsubto,		$,	0),	! 
	(kmulto,		$,	1),	! 
	(kfmulto,		$,	0),	! 
	(kdivto,		$,	1),	! i8/i16/i32/i64/u8/u16/32/u64 X /:= Y; Y can be wider
	(kfdivto,		$,	0),	! 

	(kremto,		$,	0),	! See divto
	(kiandto,		$,	0),	! d8/d16/d32/d64 X^ iand:= Y
	(kiorto,		$,	0),	! 
	(kixorto,		$,	0),	! 
	(kshlto,		$,	0),	! d8/d16/d32/d64 X^ <<:= y
	(kshrto,		$,	0),	! i8/i16/i32/i64/u8/u16/32/u64 X /:= Y; Y can be wider

	(kaddoffto,		$,	0),	! d64 X^ +:= (Y*scale + offset)
	(ksuboffto,		$,	0),	! d64 X^ -:= (Y*scale + offset)

	(ktruncate,		$,	0),	! d32 => i8/i16/u8/u16 => i32, d64 => i32/u32, smode => mode => i32/u32
	(kwiden,		$,	0),	! i32 => i64, u32 => u64; .mode is i64 or u64

	(kfloat,		$,	0),	! i32/i64/u32/u64 => r32/r64, smode => mode
	(kfix,			$,	0),	! r32/r64 => i32/i64/u32/u64, smode => mode

	(kfwiden,		$,	0),	! r32 => r64
	(kfnarrow,		$,	0),	! r64 => r32

	(kstartmx,		$,	0),	! 
	(kresetmx,		$,	0),	! 
	(kendmx,		$,	0),	! 

	(ksetret,		$,	1),	! 
	(kfsetret,		$,	0),	!
	(ksetcall,		$,	0),	! 
	(ksetarg,		$,	0),	! 
	(kloadall,		$,	0),	! 

	(ksetjmp,		$,	0),	! X is address of buffer
	(klongjmp,		$,	0),	! Using X = buffer address, restore location, return X':=Y 

	(keq,			$,	0),	! 
	(kne,			$,	0),	! 
	(klt,			$,	0),	! 
	(kle,			$,	0),	! 
	(kge,			$,	0),	! 
	(kgt,			$,	0),	! 

	(klast,			$,	0),	!
end

global enumdata [0:]ichar opndnames =
	(no_opnd=0,			$),
	(mem_opnd,			$),
	(memaddr_opnd,		$),
	(label_opnd,		$),
	(int_opnd,			$),
	(real_opnd,			$),
	(r32_opnd,		$),
	(string_opnd,		$),
	(strimm_opnd,		$),
	(assem_opnd,		$),
	(realimm_opnd,		$),
end

!Where any active operand is located:

global enumdata [0:]ichar locnames =
	(no_loc=0,		$),			! not set
	(reg_loc,		$),			! in a d64 register
	(xreg_loc,		$),			! in an x64
	(immd64_loc,	$),			! imm: d64 immediate value
	(immx64_loc,	$),			! imm: x64 immediate value
	(immx32_loc,	$),			! imm: x32 immediate value
	(memaddr_loc,	$),			! imm: address of variable
	(label_loc,		$),			! imm: label
	(mem_loc,		$),			! mem: contents of variable
	(ilabel_loc,	$),			! mem: contents of label
	(temp_loc,		$),			! mem: contents of pcl temp slot
	(regvar_loc,	$),			! contents of register-variable 
	(xregvar_loc,	$),			! contents of xregister-variabke 

!	(stack_loc,		$),			! Deprecated
	(string_loc,	$),			! Deprecated
end

!global symbol currproc
global ref pclrec pclprocdef	!ref to kprocdef opcode of currproc

global int frameoffset
global int paramoffset
global int framebytes

global const maxparams=64
global const maxlocals=512

!these are reset at each procdef
global [maxparams]symbol paramdefs
global [maxlocals]symbol localdefs
global int nlocals				!no. of locals that are used, both int/float
global int nparams				!no. of params whether used or not, int and float

global int usedparams			!how many of pregs needed for used incoming params
global int usedxparams			!how many of pxregs needed for used incoming params

global int highreg				!highest D-reg used
global int highxreg				!highest X-reg used
global int bspill, bxspill		!no. to spill
global int bxspilloffset		!base frame offset of bxreg spill area

global byte r10used				!these may be set in pass2 when occupied by params
global byte r11used
global byte r13used

global int maxregvars			!how many locals would qualify for regvars
global int maxxregvars			!how many locals would qualify for xregvars

global int nproccalls			!number of calls including implicit ones (eg. ** and sin)
global int highargs				!max number of args (0-4) of any call
global macro leafproc =	nproccalls=0			!1 if leaf function
global byte localshadow			!1 if local, proc-wide shadow space used for a call

global byte assemused			!1 if assem used

global int passno

!global ref constrec cstringlist
!global ref constrec vstringlist
!global ref constrec creal64list
!global ref constrec creal32list

global int kk0used=0


global const maxoperands=20

global [maxoperands+10]pclstackrec pclstack
global [maxoperands+10]pclvaluerec pclvals
global int noperands				!number of pcl operands, including wide
global int mstackdepth				!hw stack size (pcl operands, + extra for wide, + padding)

global [maxoperands]byte pcltempflags
global [maxoperands]mcloperand pcltemps

global const maxblocktemps=50
global [maxblocktemps]symbol blockdefs
global int nblocktemps
global symbol blockretname

=== cc_show.m 0 0 19/108 ===
int currfileno
int currlineno

strbuffer sbuffer
global ref strbuffer dest=&sbuffer
int destlinestart

strbuffer exprstrvar
ref strbuffer exprstr=&exprstrvar


global proc printcode(filehandle f,ichar caption)=
	int i
	ref strec p

	println @f, caption

	p:=stmodule.deflist

	while p do
		case p.nameid
		when procid then
!		if p.scope<>imported_scope and p.code then
			if p.code then
				println @f,p.name,,"=",scopenames[p.scope]
				printunit(f,p.code,,"1")
				println @f
			fi
		esac
		p:=p.nextdef
	od
end

global proc printunit(filehandle dev,ref unitrec p,int level=0,ichar prefix="*")=		!PRINTUNIT
!p is a tagrec
	ref unitrec q
	ref strec d
	int t,n,lincr
	ichar idname
	ref caserec pc

	if p=nil then
		return
	fi

	if p.tag>=jdummy then
		println "print unit: bad tag",p.tag
		stop 30
	fi

	if p.lineno then
		currlineno:=p.lineno
		currfileno:=p.fileno
	fi

	lincr:=1
	if level<0 then
		lincr:=-1
		print @dev,"             "
	fi

	print @dev,getprefix(abs(level),prefix,p)
	idname:=jtagnames[p.tag]
	if idname^='j' then ++idname fi

	print @dev,idname,,": "

	case p.tag
	when jname, jfuncname then
		d:=p.def

		print @dev,d.name,namenames[d.nameid]

		if d.code then
			print @dev," {",,jtagnames[d.code.tag],,"}"
		fi

		print @dev," ",,getdottedname(d)!,q

		if p.c then
			print @dev," Lastcall:",p.c
		fi

	when jtempdecl, jdecl, jgoto then

		d:=p.def
		print @dev,d.name,namenames[d.nameid]

		println @dev
		printunit(dev,d.code,level+lincr,"1")
		return

	when jgoto then

		d:=p.def
		print @dev,d.name,namenames[d.nameid]

	when jlabelstmt then
		print @dev,p.def.name!,"+ LABELED STATEMENT"

	when jcasestmt then
		print @dev,"Value:", p.value

	when jconst then
		t:=p.mode
		if t=trefchar then
			if not p.isstrconst then
				goto doref
			fi
	dostring:
			if p.slength>256 then
				print @dev,"""",,"(LONGSTR)",""" *",,p.slength
			else
				print @dev,"""",,p.svalue,,""" *",,p.slength
			fi
		elsif t=trefwchar then
			if not p.iswstrconst then
				goto doref
			fi
			print @dev,"""",,"(WSTRING)",""" *",,p.wslength
		elsif t>=ti8 and t<=ti64 then
			print @dev,p.value
		elsif t>=tu8 and t<=tu64 then
			print @dev,p.uvalue
		elsif isrealcc(t) then
			print @dev,p.xvalue
		elsif ttbasetype[t]=tref then
			if p.isstrconst then
				goto dostring
			fi
	doref:
			print @dev,ref void(p.value)
		elsif ttbasetype[t]=tarray then
			if p.isstrconst then
				goto dostring
			fi
			serror("PRINTUNIT/CONST/aRRAY")
		else
			cpl typename(t)
			CPL("PRINTUNIT BAD CONST")
!			serror("PRINTUNIT BAD CONST")
		fi
		print @dev," ",,strmode(t)
		if p.isstrconst then print @dev,"<STRCONST>" fi
		if p.iswstrconst then print @dev,"<WSTRCONST>" fi

	when jconvert then
		print @dev,convnames[p.opcode]
		print @dev," "
		print @dev,typename(p.a.mode)
		print @dev," => "
		print @dev,typename(p.convmode)

	when jscale then
		print @dev,"Scale:",p.scale

	when jaddptr,jsubptr then
		print @dev,"Ptrscale:",p.ptrscale

	when jswitch then
		pc:=p.nextcase
		n:=0
		while pc do ++n; pc:=pc.nextcase od

		print @dev,n

	when jcallfn then
		print @dev," Aparams:",p.aparams

	when jptr then

	when jdot then
		print @dev," Offset:",p.offset

	esac

	if p.memmode then
		print @dev, " Widen from:",strmode(p.memmode)
	fi

	if p.alength then print @dev," ALENGTH=",p.alength fi

	println @dev

	printunitlist(dev,p.a,level+lincr,"1")
	printunitlist(dev,p.b,level+lincr,"2")
	if p.tag<>jblock then					!.c is used to point to last element
		printunitlist(dev,p.c,level+lincr,"3")
	fi
end

proc printunitlist(filehandle dev,ref unitrec p,int level=0,ichar prefix="*")=		!PRINTUNIT
	if p=nil then return fi

	while p do
		printunit(dev,p,level,prefix)
		p:=p.nextunit
	od
end

function getprefix(int level,ichar prefix,ref unitrec p)ichar=		!GETPREFIX
!combine any lineno info with indent string, return string to be output at start of a line
	static [512]char str
	[512]char indentstr
	ichar modestr
	int length

	indentstr[1]:=0
	if level>10 then level:=10 fi

	strcpy(indentstr,"-----------------------")

	modestr:=strmode(p.mode,0)
	length:=strlen(modestr)
	if length<strlen(indentstr) then
		memcpy(indentstr,modestr,length)
	else
		strcpy(indentstr,modestr)
	fi

	to level do
		strcat(indentstr,"|---")
	od

	strcpy(str,getlineinfok())
	strcat(str,indentstr)
	strcat(str,prefix)
	if prefix^ then
		strcat(str," ")
	fi

	return str
end

global function getdottedname(ref strec p)ichar=		!GETDOTTEDNAME
!build full dotted name for st item p
	static [256]char str
	[256]char str2
	ref strec owner

	strcpy(str,p.name)
	owner:=p.owner
	while owner and owner.nameid<>programid do
		strcpy(str2,str)
		strcpy(str,owner.name)
		strcat(str,".")
		strcat(str,str2)
		owner:=owner.owner
	od
	if p.blockno then
	!	sprintf(str2,".%d",i32(p.blockno))
		print @str2,".",,p.blockno
		strcat(str,str2)
	fi
	return str
end

function getlineinfok:ichar=			!GETLINEINFO
	static [40]char str

	fprint @str,"# ",currfileno,currlineno:"z5",$
	return str
end

global proc printst(filehandle f,ref strec p,int level=0)=
	ref strec q

	if p.symbol<>namesym then
		mcerror("PRINTST not name")
	fi

	printstrec(f,p,level)

	q:=p.deflist

	while q<>nil do
		printst(f,q,level+1)
		q:=q.nextdef
	od
end

proc printstrec(filehandle f,ref strec p,int level)=
	ref byte q
	strbuffer v
	ref strbuffer d:=&v
	int col,offset
	const tabstr="    "
	[256]char str
	int scope
	ref paramrec pm

	gs_init(d)

	offset:=0
	to level do
		gs_str(d,tabstr)
		offset+:=4
	od
	gs_str(d,":")

	if p.blockno then
!	sprintf(str,"#.%d",p.name,i32(p.blockno))
		print @str,p.name,,".",,p.blockno

		gs_leftstr(d,str,28-offset,'-')
	else
		gs_leftstr(d,p.name,28-offset,'-')
	fi
	gs_leftstr(d,namenames[p.nameid],12,'.')
	col:=gs_getcol(d)

	gs_str(d,"[")

	gs_str(d,scopenames[p.scope])
	gs_str(d," ")
	gs_str(d,strint(p.exported))
	gs_str(d," ")

	if p.align then
		gs_str(d,"@@")
		gs_strint(d,p.align)
		gs_str(d," ")
	fi
	if p.varparams then
		gs_str(d,"Var ")
	fi
	if p.used then
		gs_str(d,"Used ")
	fi
	if p.nparams then
		fprint @str,"Pm:# ",p.nparams
		gs_str(d,str)
	fi

	gs_str(d,"]")
	gs_padto(d,col+10,'=')

	if p.owner then
		fprint @str,"(#)",p.owner.name
		gs_leftstr(d,str,18,' ')
	else
		gs_leftstr(d,"()",18,' ')
	fi

	case p.mode
	when tvoid then
		gs_str(d,"Void ")
	else
		gs_strsp(d,strmode(p.mode))
	esac

	case p.nameid
	when fieldid then
		gs_str(d,"Offset:")
		gs_strint(d,p.offset)

	when frameid,paramid then
		if p.code then
			gs_str(d,"=")

			gs_strvar(d,strexpr(p.code))
		fi
		gs_str(d," Offset: ")
		gs_strint(d,p.offset)

	when procid then

		gs_str(d,"Index:")
		gs_strint(d,p.index)

	when enumid then
		gs_str(d,"Enum:")
		gs_strint(d,p.index)

	when staticid then
		if p.code then
			gs_str(d,"=")
			gs_strvar(d,strexpr(p.code))
		fi
		gs_str(d,"STATIC********")
	esac

	gs_str(d," ")

	gs_str(d,"Lineno:")
	gs_strint(d,p.lineno iand 16777215)
	gs_str(d," ")
	gs_str(d,sourcefilenames[p.lineno>>24])

	if p.nameid=procid then
		gs_line(d)
		pm:=p.paramlist
		while pm do
			gs_str(d,"		Param: ")
			gs_leftstr(d,(pm.def|pm.def.name|"Anon"),10,'-')
			gs_str(d,pmflagnames[pm.flags])
			gs_str(d," Mode:")
			gs_str(d,strmode(pm.mode))
			gs_str(d," Code:")
			gs_strint(d,cast(p.code))

			gs_line(d)
			pm:=pm.nextparam
		od
	fi

	gs_println(d,f)

	if p.code then
		case p.nameid
		when frameid,staticid then
			printunit(f,p.code,-3)
		esac
	fi
end

global proc printstflat(filehandle f)=
	int i
	ref strec p
	ref tokenrec lx
	println @f,"GLOBAL SYMBOL TABLE:"

	for i:=0 to hstsize-1 do
		p:=hashtable^[i]
		if p.name then
			case p.symbol
			when namesym,ktypespecsym, ksourcedirsym then
				println @f,i,p,":",getstname(p),symbolnames[p.symbol],namenames[p.nameid]
				p:=p.nextdupl
				while p do
					print   @f,"	",p,getstname(p),symbolnames[p.symbol],namenames[p.nameid],
						p.prevdupl
					println @f,"(From",(p.owner|getstname(p.owner)|"-"),,")"
					p:=p.nextdupl
				od
			esac
		fi
	od
end

global function strexpr(ref unitrec p)ref strbuffer=
!vx_makestring("",exprstr)
	gs_init(exprstr)

	jeval(exprstr,p)
	return exprstr
end

proc jeval(ref strbuffer dest, ref unitrec p)=
!p represents an expression. It can be a unitrec only, not a list (lists only occur inside
!kmakelist and kmakeset units, which specially dealt with here)
!dest is a destination string. Special routines such as gs_additem() are used, which take care
!of separators so that successive alphanumeric items don't touch
	ref unitrec q
	[16000]char str
	int lb,t

!CPL "JEVAL",P,JTAGNAMES[P.TAG]

	case p.tag
	when jconst then
		if (t:=p.mode)=trefchar then
			if p.slength=0 then goto doref fi		!might be initialised to something else
			if not p.isstrconst then goto doref fi		!might be initialised to something else
			if p.slength>str.len/2 then
				strcpy(str,"LONGSTR)")
			else
				convertstring(p.svalue,str)
			fi
			gs_additem(dest,"""")
			gs_additem(dest,str)
			gs_additem(dest,"""")
			return
		elsif t>=ti8 and t<=ti64 then
			getstrint(p.value, str)

		elsif t>=tu8 and t<=tu64 then
			strcpy(str,strword(p.uvalue))

		elsif t=tr64 or t=tr32 then
			strcpy(str,strreal(p.xvalue))
		else
			case ttbasetype[p.mode]
			when tref then
	doref:
				print @str,ref void(p.svalue)
			when tarray then
				strcpy(str,"ARRAY")
			else
				CPL typename(p.mode)
				ABORTPROGRAM("EVAL/C")

			esac
		fi
		gs_additem(dest,str)

	when jname then
		gs_additem(dest,p.def.name)

	when jfuncname then
		gs_str(dest,"&")
		gs_additem(dest,p.def.name)

	when jandl,jorl,jandand,jeq,jne,jlt,jle,jgt,jge,jadd,jsub,jmul,jdiv,
			jrem,jiand,jior,jixor,jshl,jshr,
			jaddto,jsubto,jmulto,jdivto,
			jremto,jiandto,jiorto,jixorto,jshlto,jshrto 	then

		strcpy(str,getopcjname(p.tag))
		gs_additem(dest,"(")
		jeval(dest,p.a)
		gs_additem(dest,str)
		jeval(dest,p.b)
		gs_additem(dest,")")

	when jneg,jabs,jinot,jnotl,jistruel then

		strcpy(str,getopcjname(p.tag))
		gs_additem(dest,str)
		gs_additem(dest,"(")
		jeval(dest,p.a)
		gs_additem(dest,")")

	when jcallfn then
		jeval(dest,p.a)
		gs_additem(dest,"(")

		q:=p.b
		while q do
			jeval(dest,q)
			q:=q.nextunit
			if q then gs_additem(dest,",") fi
		od
		gs_additem(dest,")")

	when jdot then
		jeval(dest,p.a)
		gs_additem(dest,".")
		GS_STR(DEST,"???")

	when jidot then
		jeval(dest,p.a)
		gs_additem(dest,"->")
		jeval(dest,p.b)

	when jmakelist,jexprlist then
		lb:=p.tag=jexprlist
		gs_additem(dest,(lb|"("|"{"))

		q:=p.a
		while q do
			jeval(dest,q)
			q:=q.nextunit
			if q then gs_additem(dest,",") fi
		od
		gs_additem(dest,(lb|")"|"}"))

	when jassign then
		jeval(dest,p.a)
		gs_additem(dest,"=")
		jeval(dest,p.b)

	when jifx then
		jeval(dest,p.a)
		gs_additem(dest,"?")
		jeval(dest,p.b)
		gs_additem(dest,":")
		jeval(dest,p.c)

	when jconvert then

		gs_additem(dest,strmode(p.mode))
		gs_additem(dest,"(")
		jeval(dest,p.a)
		gs_additem(dest,")")

	when jptr then
		gs_additem(dest,"*(")
		jeval(dest,p.a)
		if p.b then
			gs_additem(dest,"+")
			jeval(dest,p.b)
		fi
		gs_additem(dest,")")

	when jblock then
		gs_additem(dest,"<JBLOCK>")

	when jpreincr then
		gs_additem(dest,"++")
		jeval(dest,p.a)

	when jpredecr then
		gs_additem(dest,"--")
		jeval(dest,p.a)

	when jpostincr then
		jeval(dest,p.a)
		gs_additem(dest,"++")

	when jpostdecr then
		jeval(dest,p.a)
		gs_additem(dest,"--")


	when jnull then
		gs_str(dest,"<nullunit>")

	when jscale then
		gs_str(dest,"scale((")
		jeval(dest,p.a)
		if p.scale>0 then
			gs_str(dest,")*")
			gs_strint(dest,p.scale)
		else
			gs_str(dest,")/")
			gs_strint(dest,-p.scale)
		fi
		gs_str(dest,")")
	when jaddptr then
		gs_str(dest,"(")
		jeval(dest,p.a)
		gs_str(dest,"+")
		jeval(dest,p.b)
		gs_str(dest,")")

	when jwidenmem then
		jeval(dest,p.a)


	else
!CPL JTAGNAMES[P.TAG]
	gs_str(dest,"<CAN'T DO JEVAL>")
	end
end

global proc printfilelist(filehandle f)=
	println @f,"Source files",nsourcefiles
	for i to nsourcefiles do
		fprintln @f,"# # (#)", i, sourcefilenames[i]:"12jl", sourcefilepaths[i]
	od
	println @f,"\nInput file:",inputfile
	println @f,"\nLibfiles",nlibfiles
	for i to nlibfiles do
		println @f,i, libfiles[i]
	od

end

global proc printmodelist(filehandle f)=
	int m, mbase
	ref strec d
	const tab="\t"

	println @f,"PROC MODELIST",ntypes

	for m:=0 to ntypes do
		println @f,m:"4", strmode(m)
		mbase:=ttbasetype[m]
		if tttypedef[m] then println @f,tab,"Typedef:",tttypedef[m].name fi

		println @f,tab,"Basetype:",mbase,strmode(mbase)
		println @f,tab,"Name:",typename(m)
		d:=ttnamedef[m]
		print @f,tab,"ttnamedef:",d,$
			if d then
				print @f, d.name,,".",,d.blockno
			else
				print @f,"-"
			fi
!(ttnamedef[m]|ttnamedef[m].name|"-")

		println @f
		
		println @f,tab,"Target:",strmode(tttarget[m])
		println @f,tab,"Size:",ttsize[m]
		println @f,tab,"Length:",ttlength[m]
		println @f,tab,"Isblock:",ttisblock[m]
		println @f,tab,"Const:",ttconst[m]
		println @f,tab,"Signed:",ttsigned[m]
		println @f,tab,"Ref:",ttreftype[m]
		println @f,tab,"Constver:",strmode(ttconsttype[m])
		println @f,tab,"Shared:",ttshared[m]
		println @f
	od

	println @f
end

=== cc_showdummy.m 0 0 20/108 ===
strbuffer sbuffer
global ref strbuffer dest=&sbuffer

int currlineno

global proc printcode(filehandle f,ichar caption)=
end

global proc printunit(filehandle dev,ref unitrec p,int level=0,ichar prefix="*")=
end

global proc printmodelist(filehandle f)=
end

global function strexpr(ref unitrec p)ref strbuffer=
!CPL "STREXPR"
	nil
end

global proc printst(filehandle f,ref strec p,int level=0)=
end

global proc printstflat(filehandle f)=
end

global function writeallpcl:ref strbuffer=
!CPL "ALLPCL"
	nil
end

global function strpclstr(pcl p)ichar=
!CPL "STRPCL"
	nil
end

global function stropndstack(int indent=0)ichar=
!CPL "STROS"
	nil
end

global proc showopndstack=
!"SHOW"
end

global proc printfilelist(filehandle f)=
end
=== cc_support.m 0 0 21/108 ===
global [0:]byte bytemasks=(1,2,4,8,16,32,64,128)

global proc stopcompiler(ichar filename,int lineno)=
	if fwriteerrors then
		filehandle f
		f:=fopen("$error.tmp","w")
		println @f,filename,lineno
		fclose(f)
	fi
	println
	println
	stop 1
end

global proc mcerror(ichar mess)=
	println "\nMC Error:",mess
!os_getch()
	stop 40
end

global proc serror(ichar mess)=
	serror_gen(mess)
end

global proc serror_gen(ichar mess)=
	if currproc then
		print "\nIn function",currproc.name,," "
	ELSE
		CPL "OUTSIDE PROC"
	fi

	println "On line",lx.lineno,"in file",sourcefilepaths[lx.fileno],sourcefilenames[lx.fileno]
	showmacrolineno()

	println
	println "**** Syntax Error:",mess,"****"
	println

	stopcompiler(sourcefilepaths[lx.fileno],lx.lineno)
end

global proc serror_ss(ichar mess,a,b)=
	[256]char str
!	sprintf(str,mess,a,b)
	fprint @str, mess,a,b
	serror_gen(str)
end

global proc serror_s(ichar mess,a)=
	[256]char str
!	sprintf(str,mess,a)
	fprint @str, mess, a
	serror_gen(str)
end

global proc terror_gen(ichar mess)=

	if currproc then
		println "\nIn function",currproc.name
	fi

	println "Type error:",mess,"on line",lx.lineno,sourcefilepaths[lx.fileno]

	showmacrolineno()

	stopcompiler(sourcefilepaths[lx.fileno],lx.lineno)
end

global proc terror(ichar mess)=
	terror_gen(mess)
end

global proc terror_s(ichar mess,a)=
	[256]char str

	fprint @str, mess, a
	terror_gen(str)
end

global proc terror_ss(ichar mess,a,b)=
	[256]char str

	fprint @str, mess, a, b
	terror_gen(str)
end

global proc gerror_gen(ichar mess,ref unitrec p=nil)=
	int lineno,fileno

	if p then
		lineno:=p.lineno
		fileno:=p.fileno
	else
		lineno:=clineno
		fileno:=cfileno
	fi

	if currproc then
		print "In function",currproc.name,," "
	fi

	println "On line",lineno iand 16777215,"in file",sourcefilepaths[fileno]
	println
	println "**** Code Gen Error:",mess,"****"
	stopcompiler(sourcefilepaths[fileno],lineno)
end

global proc gerror(ichar mess,ref unitrec p=nil)=
	gerror_gen(mess,p)
end

global proc gerror_s(ichar mess,s,ref unitrec p=nil)=
	[256]char str

	fprint @str, mess, s
	gerror_gen(str,p)
end

global function nextpoweroftwo(int x)int=
!return next power of 2 >= x

	if x=0 then return 0 fi

	int a:=1
	while a<x do
		a<<:=1
	od
	return a
end

global proc loaderror(ichar mess,mess2="")=
	[512]char str

	fprint @str, mess, mess2
	println "Load Error:",str
	println "Stopping"
	stop 45
end

global function loadsourcefile(ichar file,shortfile)int=
!file is a complete file spec of a file known to exist
!shortfile is the name as it might appear in an include statement; part- or fully-qualified
!return index into sourcefile tables
	ichar s

	if nsourcefiles>maxsourcefile then
		loaderror("Too many source files")
	fi
	++nsourcefiles
	sourcefilepaths[nsourcefiles]:=pcm_copyheapstring(file)
	sourcefilenames[nsourcefiles]:=pcm_copyheapstring(shortfile)

	s:=cast(readfile(file))			!will overallocate by a few bytes
	if not s then				!unexpected error
		loaderror("LSF can't load ",file)
	fi

	sourcefiletext[nsourcefiles]:=s
	sourcefilesizes[nsourcefiles]:=rfsize
	(s+rfsize)^:=0				!replace etx,0 by 0,0 (effectively, just zero)

	return nsourcefiles
end

function splicelines(ichar s)ichar=
	ichar t,u

	t:=u:=pcm_alloc(strlen(s)+1)

	while s^ do
		if s^='\\' and (s+1)^=10 then s+:=2
		elsif s^='\\' and (s+1)^=13 and (s+2)^=10 then s+:=3
		else t++^ := s++^
		fi
		t^:=0
	od
	return u
end

global function loadbuiltin(ichar shortfile,hdrtext)int=
!loading build-in header with text at hdrtext
!Name of header is in 'file'.
	ichar s

	if nsourcefiles>maxsourcefile then
		loaderror("Too many source files")
	fi
	++nsourcefiles
	sourcefilepaths[nsourcefiles]:="<builtin>"
	sourcefilenames[nsourcefiles]:=pcm_copyheapstring(shortfile)

!source code may be written to (avoids doing that with names
!but may happen with real numbers); need to make writeable copy
!sourcefiletext[nsourcefiles]:=hdrtext
	sourcefiletext[nsourcefiles]:=pcm_copyheapstring(hdrtext)

	sourcefilesizes[nsourcefiles]:=strlen(hdrtext)
	return nsourcefiles
end

proc gs_copytostr(ref strbuffer source,ref char s)=
	if source.length then
		memcpy(s,source.strptr,source.length)
		(s+source.length)^:=0
	else
		s^:=0
	fi
end

global proc gs_additem(ref strbuffer dest,ichar s)=		!GENITEM
!like genstr, but ensure there is white space separation as needed from the last output
	ichar d
	int lastchar,nextchar

	d:=dest.strptr

	if dest.length then
		lastchar:=(d+dest.length-1)^
		nextchar:=s^
		if isalphanum(lastchar) and isalphanum(nextchar) then
			strbuffer_add(dest," ")
		fi
	fi
	strbuffer_add(dest,s)
end

function isalphanum(int c)int=
	if c>='A' and c<='Z' or c>='a' and c<='z' or c>='0' and c<='9' then
		return 1
	fi
	return 0
end

proc showmacrolineno=
	if slineno then
!	println "	(Last macro invoked near line",
!		slineno,"in file",sourcefilenames[sfileno],,")"
	fi
end
=== cc_tables.m 0 0 22/108 ===
global enumdata [0:]ichar stdtypenames, [0:]byte stdtypewidths,
		 [0:]byte stdsigned, [0:]byte stdpcl, [0:]byte stdsize =

!                              bts  si  pcl      size
	(tvoid=0,		"void",		0,	0,	tpvoid,		0),

	(ti8,			"i8",		8,	1,	tpi8,		1),		! This ordering is important
	(ti16,			"i16",		16,	1,	tpi16,		2),		!
	(ti32,			"i32",		32,	1,	tpi32,		4),		!
	(ti64,			"i64",		64,	1,	tpi64,		8),		!

	(tbool,			"bool",		8,	0,	tpu8,		1),		! As is this
	(tu8,			"u8",		8,	0,	tpu8,		1),		!
	(tu16,			"u16",		16,	0,	tpu16,		2),		!
	(tu32,			"u32",		32,	0,	tpu32,		4),		!
	(tu64,			"u64",		64,	0,	tpu64,		8),		!

	(tr32,			"r32",		32,	0,	tpr32,		4),		! And tr32 must be >= integer types
	(tr64,			"r64",		64,	0,	tpr64,		8),		!

	(tenum,			"enum",		0,	0,	tpi32,		0),		!
	(tref,			"ref",		64,	0,	tpu64,		0),		! 
	(tproc,			"proc",		64,	0,	tpvoid,		0),		!
	(tlabel,		"label",	64,	0,	tpvoid,		0),		!
	(tblock,		"block",	0,	0,	tpblock,	0),		!

	(tarray,		"array",	0,	0,	tpblock,	0),		!
	(tstruct,		"struct",	0,	0,	tpblock,	0),		!
	(tunion,		"union",	0,	0,	tpblock,	0),		!

	(tnotset,		"notset",	0,	0,	tpvoid,		0),		!

!User-defined types go here
	(tlast,			$,			0,	0,	tpvoid,		0)		! 	!

end

global const tchar=ti8
global const tfirstnum=ti8, tlastnum=tr64
global const tfirstint=ti8, tlastint=tu64
global const tfirstreal=tr32, tlastreal=tr64

global const tptroffset = ti64		!for 64-bit target

global enumdata [0:]ichar catnames =
    (voidcat=0,     $),         ! Not set

    (intcat,        $),         ! i32 i64 u32 u64
    (realcat,       $),         ! r32 r64
    (shortcat,      $),         ! i8 i16 u8 u16
    (blockcat,      $),         ! u64 pointer to block data
end


global enumdata []ichar typespecnames, []i32 typespectypes, []byte typespecsizes =
	(ts_void,		$,	tvoid,		0),
!	(ts_char,		$,	tu8,		1),
	(ts_char,		$,	ti8,		1),
	(ts_short,		$,	0,			2),
	(ts_long,		$,	0,			4),
!	(ts_long64,		$,	0,			8),
	(ts_int,		$,	ti32,		4),
	(ts_float,		$,	tr32,		4),
	(ts_double,		$,	tr64,		8),
	(ts_signed,		$,	0,			0),
	(ts_unsigned,	$,	0,			0),
	(ts_bool,		$,	tbool,		1),
	(ts_user,		$,	0,			0),
	(ts_struct,		$,	0,			0),
	(ts_union,		$,	0,			0),
	(ts_enum,		$,	0,			4),
	(ts_atomic,		$,	0,			0)
end

global enumdata [0:]ichar pmflagnames=
	(pm_normal=0,		$),		! Normal param
	(pm_notset,			$),		! ()     (applied to one dummy tnone param)
	(pm_empty,			$),		! (void) (applied to one dummy tnone param)
	(pm_variadic,		$)		! (...) or (t,u,v,...) (applied to dummy or first param)
end

!scope here refers to linkage across modules
global enumdata [0:]ichar scopenames=
	(no_scope=0,		"-"),		! 
	(function_scope,	"Fn"),		!within a function (note import/exported names can be declared in a block scope)
	(local_scope,		"Loc"),		!file-scope/not exported 
	(imported_scope,	"Imp"),		!imported from another module
	(exported_scope,	"Exp")		!file-scope/exported
end

!Call conventions
global enumdata []ichar cccnames=

	(open_cc=0,		$), ! Not set: either own or clang, depending on whether fn was defined
	(own_cc,		$), ! Internal (x86/x64)
	(clang_cc,		$), ! External (all x64; clang only x86)
	(stdcall_cc,	$), ! (x86 non-clang)
	(callback_cc,	$), ! Internal when called from External

	(dummy_cc,		$)	! 
end

global enumdata [0:]ichar linkagenames=
	(none_ss=0,		$),
	(static_ss,		$),
	(auto_ss,		$),
	(register_ss,	$),
	(extern_ss,		$),
	(typedef_ss,	$),
	(show_ss,		$)
end

global enumdata []ichar typequalnames=
	(const_qual,	$),
	(volatile_qual,	$),
	(restrict_qual,	$),
	(atomic_qual,	$)
end

global enumdata []ichar fnspecnames=
	(inline_fnspec,		$),
	(noreturn_fnspec,	$),
	(callback_fnspec,	$),
end

global enumdata =
	pdm_date,
	pdm_time,
	pdm_file,
	pdm_line,
	pdm_func,
	pdm_cdecl,
	pdm_mcc,
	pdm_mcci,
	pdm_stdc
end

global enumdata [0:]ichar jtagnames=

	(jnone=0,		$), !
	(jconst,		$), !
	(jnull,		$), !
	(jname,		$), !
!	(jnameaddr,	$), !
	(jwidenmem,	$), !
	(jfuncname,	$), !
	(jblock,		$), !
	(jtempdecl,	$), !
	(jdecl,		$), !
!	(jtypeof,		$), !
!	(jmakeref,		$), !

!Statements

	(jreturn,		$), ! 
	(jreturnx,		$), ! 

	(jassign,		$), ! 
	(jif,			$), ! 
	(jfor,			$), ! 
	(jwhile,		$), ! 
	(jdowhile,		$), ! 
	(jgoto,		$), ! 
	(jlabelstmt,	$), ! 
	(jcasestmt,	$), ! 
	(jdefaultstmt,	$), ! 
	(jbreak,		$), ! [
	(jcontinue,	$), ! [
	(jswitch,		$), ! 
	(jbreaksw,		$), ! [
!	(jeval,		$), ! 

!Expressions and Operators

!Logical Operators

	(jandl,		"&& andl"), ! 
	(jorl,			"|| orl"), ! 
	(jnotl,		"! notl"), ! 
	(jistruel,		$), ! 

!Expressions and Operators

	(jmakelist,	$), ! 
	(jexprlist,	$), ! 

!	(jassignx,		$), ! 
	(jcallfn,		$), ! 
	(jifx,			$), ! 

!Binary Ops

	(jandand,		"&&"), ! a 

	(jeq,			"=="), ! a 
	(jne,			"!="), ! a 
	(jlt,			"<"), ! a 
	(jle,			"<="), ! a 
	(jgt,			">"), ! a 
	(jge,			">="), ! a 

	(jadd,			"+ add"), ! 
	(jsub,			"- sub"), ! 
	(jmul,			"* mul"), ! 
	(jdiv,			"/ div"), ! 
	(jrem,			"% mod"), ! 
	(jiand,		"& iand"), ! 
	(jior,			"| ior"), ! 
	(jixor,		"^ ixor"), ! 
	(jshl,			"<<"), ! a 
	(jshr,			">>"), ! a 

	(jdot,			$), ! 
	(jidot,		$), ! 
!	(jdotref,		$), ! 
	(jindex,		$), ! 

	(jptr,			"ptr"), ! 
!	(jptroffset,	"ptroffset *"), ! 
	(jaddptr,		"addptr"), ! 
	(jsubptr,		"subptr"), ! 
	(jaddrof,		"addrof &"), ! 
	(jconvert,		$), ! 
	(jscale,		$), ! 

!Monadic Ops

	(jneg,			"- neg"), ! 
	(jabs,			"abs"), ! 
	(jinot,		"~ inot"), ! a

!In-place operators

	(jaddto,		"+="), ! a b	a+:=b
	(jsubto,		"-="), ! a b
	(jmulto,		"*="), ! a b
	(jdivto,		"/="), ! a b
	(jremto,		"%="), ! a b
	(jiandto,		"&="), ! a b
	(jiorto,		"|="), ! a b
	(jixorto,		"^="), ! a b
	(jshlto,		"<<="), ! a b
	(jshrto,		">>="), ! a b

	(jpreincr,		"++ preincr"), ! a	++a
	(jpredecr,		"-- preincr"), ! a	--a
	(jpostincr,	"++ postincr"), ! a	a++
	(jpostdecr,	"-- postdecr"), ! a	a--

	(jsetjmp,		"setjmp"),
	(jlongjmp,		"longjmp"),

	(jdummy,		$)
end

global enumdata []ichar symbolnames, []ichar shortsymbolnames, []byte symboltojtag=

!First half are basic tokens returned by lexreadtoken()
	(errorsym,			$,	"",		0),			! Lex error
	(dotsym,			$,	".",	jdot),		! "."
	(idotsym,			$,	"->",	jidot),	! "->"
	(lexhashsym,		$,	"#",	0),			! "#" as first symbol on line
	(hashsym,			$,	"#",	0),			! "#" within macro def
	(lithashsym,		$,	"#",	0),			! "#" literal hash (not stringify op)
	(hashhashsym,		$,	"##",	0),			! "##" within macro def
	(commasym,			$,	",",	0),			! ","
	(semisym,			$,	";",	0),			! ";"
	(colonsym,			$,	":",	0),			! ":"
	(assignsym,			$,	"=",	jassign),	! =
	(assignsym2,		$,	":=",	jassign),	! =
	(lbracksym,			$,	"(",	0),			! (
	(rbracksym,			$,	")",	0),			! )
	(lsqsym,			$,	"[",	0),			!	 [
	(rsqsym,			$,	"]",	0),			! ]
	(lcurlysym,			$,	"{",	0),			! {
	(rcurlysym,			$,	"}",	0),			! }
	(questionsym,		$,	"?",	0),			! ?
	(curlsym,			$,	"~",	0),			! ~
	(ellipsissym,		$,	"...",	0),			! ...
	(backslashsym,		$,	"\\",	0),			! \
	(addsym,			$,	"+",	jadd),		! +
	(subsym,			$,	"-",	jsub),		!
	(mulsym,			$,	"*",	jmul),		!
	(divsym,			$,	"/",	jdiv),		!
	(remsym,			$,	"%",	jrem),		!
	(iorsym,			$,	"|",	jior),		!
	(iandsym,			$,	"&",	jiand),	!
	(ixorsym,			$,	"^",	jixor),	!
	(orlsym,			$,	"||",	jorl),		!
	(andlsym,			$,	"&&",	jandl),	!
	(shlsym,			$,	"<<",	jshl),		!
	(shrsym,			$,	">>",	jshr),		!
	(inotsym,			$,	"~",	jinot),	!
	(notlsym,			$,	"!",	jnotl),	!
	(incrsym,			$,	"++",	jpreincr),	!
	(decrsym,			$,	"--",	jpredecr),	!
	(abssym,			$,	"abs",	jabs),		!

	(eqsym,				$,	"==",	jeq),		!
	(nesym,				$,	"!=",	jne),		!
	(ltsym,				$,	"<",	jlt),		!
	(lesym,				$,	"<=",	jle),		!
	(gesym,				$,	">=",	jge),		!
	(gtsym,				$,	">",	jgt),		!

	(addtosym,			$,	"+=",	jaddto),	!
	(subtosym,			$,	"-=",	jsubto),	!
	(multosym,			$,	"*=",	jmulto),	!
	(divtosym,			$,	"/=",	jdivto),	!
	(remtosym,			$,	"%=",	jremto),	!
	(iortosym,			$,	"|=",	jiorto),	!
	(iandtosym,			$,	"&=",	jiandto),	!
	(ixortosym,			$,	"^=",	jixorto),	!
	(shltosym,			$,	"<<=",	jshlto),	!
	(shrtosym,			$,	">>=",	jshrto),	!

	(eolsym,			$,	"",		0),			!
	(eofsym,			$,	"",		0),			!
	(rawnumbersym,		$,	"n",	0),			!
	(intconstsym,		$,	"n",	0),			!
	(realconstsym,		$,	"n",	0),			!
	(charconstsym,		$,	"s",	0),			!
	(wcharconstsym,		$,	"s",	0),			!
	(stringconstsym,	$,	"s",	0),			!
	(wstringconstsym,	$,	"s",	0),			!
	(whitespacesym,		$,	"w",	0),			!
!	(placeholdersym,	$,	"<PH>",	0),			!
	(placeholdersym,	$,	"",	0),			!

!Second half are tokens that can be yielded after a name lookup:
	(namesym,			$,	"k",	0),			! identifier symbol
	(ksourcedirsym,		$,	"k",	0),			! 
	(predefmacrosym,	$,	"k",	0),			! __LINE__ etc
	(kdeclspecsym,		$,	"k",	0),			! __declspec

	(ktypespecsym,		$,	"k",	0),			! INT, SHORT
	(kifsym,			$,	"k",	0),			! IF
	(kelsesym,			$,	"k",	0),			! ELSE
	(kcasesym,			$,	"k",	0),			! CASE
	(kdefaultsym,		$,	"k",	0),			! DEFAULT
	(kforsym,			$,	"k",	0),			! FOR
	(kwhilesym,			$,	"k",	0),			! WHILE
	(kdosym,			$,	"k",	0),			! DO
	(kreturnsym,		$,	"k",	0),			! RETURN
	(kbreaksym,			$,	"k",	0),			! BREAK
	(kcontinuesym,		$,	"k",	0),			! CONTINUE
	(kgotosym,			$,	"k",	0),			! GO/GOTO
	(kswitchsym,		$,	"k",	0),			! SWITCH
	(kstructsym,		$,	"k",	0),			! STRUCT
	(kunionsym	,		$,	"k",	0),			! UNION
	(klinkagesym,		$,	"k",	0),			! STATIC etc
	(ktypequalsym,		$,	"k",	0),			! CONST etc
	(kstdtypesym,		$,	"k",	0),			! ui32_t etc
	(kfnspecsym,		$,	"k",	0),			! INLINE etc
	(kalignassym,		$,	"k",	0),			! _ALIGNAS
	(kenumsym,			$,	"k",	0),			! ENUM
!	(kcallconvsym,		$,	"k",	0),			! CLANG etc
	(ksizeofsym,		$,	"k",	0),			! SIZEOF
	(kdefinedsym,		$,	"k",	0),			! DEFINED
	(kgenericsym,		$,	"k",	0),			! _GENERIC
	(kalignofsym,		$,	"k",	0),			! _ALIGNOF
	(ksetjmpsym,		$,	"k",	0),			! SETJMP etc
	(kshowmodesym,		$,	"k",	0),			! SHOWMODE
!	(kshowtypesym,		$,	"k",	0),			! SHOWTYPE

	(kdummysym,			$,	"",		0)			!
end

global enumdata []ichar sourcedirnames =
	(definedir,		$),
	(emitdir,		$),
	(ifdir,			$),
	(elifdir,		$),
	(elsedir,		$),
	(endifdir,		$),
	(includedir,	$),
	(ifdefdir,		$),
	(ifndefdir,		$),
	(undefdir,		$),
	(errordir,		$),
	(messagedir,	$),
	(blankdir,		$),
	(linedir,		$),
!	(strincludedir,	$),
	(pragmadir,		$)
end

global enumdata [0:]ichar namespacenames=
	(ns_none=0,		$),			!not set
	(ns_general,	$),			!variables, functions, typedefs, enum names
	(ns_tags,		$),			!struct, union, enum tags
	(ns_labels,		$),			!label names
	(ns_fields,		$)			!field names
end

global enumdata [0:]ichar namenames, [0:]i32 namespaces, [0:]byte name2pid=
	(nullid=0,		$,		ns_none,		0),			!Not assigned, or keyword/macro defined by .symbol
	(macroid,		$,		ns_none,		0),			!
	(programid,		$,		ns_none,		0),			!Main root
	(moduleid,		$,		ns_none,		0),			!
	(extmoduleid,	$,		ns_none,		0),			!
	(typeid,		$,		ns_general,		0),			!Type name in type, proc or module
	(procid,		$,		ns_general,		proc_id),	!Proc/method/function/op name
	(staticid,		$,		ns_general,		static_id),	!Static in type or proc or module
	(frameid,		$,		ns_general,		local_id),	!Local var
	(paramid,		$,		ns_general,		param_id),	!Local param
	(fieldid,		$,		ns_fields,		0),			!Field of Record or Class
	(enumid,		$,		ns_general,		0),			!Enum name, part of enum type only
	(enumtagid,		$,		ns_tags,		0),			!
	(structtagid,	$,		ns_tags,		0),			!
	(labelid,		$,		ns_labels,		label_id)	!Label name in proc only
end

global tabledata []ichar stnames, []i32 stsymbols, []i32 stsubcodes=

	("if",			kifsym,			jif),
	("else",		kelsesym,		0),
	("case",		kcasesym,		0),
	("default",		kdefaultsym,	0),
	("for",			kforsym,		0),
	("do",			kdosym,			0),
	("while",		kwhilesym,		0),
	("return",		kreturnsym,		0),
	("break",		kbreaksym,		0),
	("continue",	kcontinuesym,	0),
	("goto",		kgotosym,		0),
	("switch",		kswitchsym,		0),

	("struct",		kstructsym,		0),
	("union",		kunionsym,		0),

	("include",		ksourcedirsym,	includedir),
	("define",		ksourcedirsym,	definedir),
	("elif",		ksourcedirsym,	elifdir),
	("ifdef",		ksourcedirsym,	ifdefdir),
	("ifndef",		ksourcedirsym,	ifndefdir),
	("endif",		ksourcedirsym,	endifdir),
	("undef",		ksourcedirsym,	undefdir),
	("error",		ksourcedirsym,	errordir),
	("pragma",		ksourcedirsym,	pragmadir),
	("line",		ksourcedirsym,	linedir),

	("auto",		klinkagesym,		auto_ss),
	("register",	klinkagesym,		register_ss),
	("static",		klinkagesym,		static_ss),
	("extern",		klinkagesym,		extern_ss),
	("typedef",		klinkagesym,		typedef_ss),
	("$showtype",	klinkagesym,		show_ss),
	
	("const",		ktypequalsym,	const_qual),
	("volatile",	ktypequalsym,	volatile_qual),
	("restrict",	ktypequalsym,	restrict_qual),
	("_Atomic",		ktypequalsym,	atomic_qual),

	("inline",		kfnspecsym,		inline_fnspec),
	("_Noreturn",	kfnspecsym,		noreturn_fnspec),

	("_Alignas",	kalignassym,	0),

	("enum",		kenumsym,		0),

	("void",		ktypespecsym,	ts_void),
	("char",		ktypespecsym,	ts_char),
	("short",		ktypespecsym,	ts_short),
	("long",		ktypespecsym,	ts_long),
	("int",			ktypespecsym,	ts_int),
	("float",		ktypespecsym,	ts_float),
	("double",		ktypespecsym,	ts_double),
	("signed",		ktypespecsym,	ts_signed),
	("unsigned",	ktypespecsym,	ts_unsigned),

	("_Bool",		ktypespecsym,	ts_bool),

!	("int8",		kstdtypesym,	ti8),
!	("int16",		kstdtypesym,	ti16),
!	("int32",		kstdtypesym,	ti32),
!	("int64",		kstdtypesym,	ti64),
!
!	("uint8",		kstdtypesym,	tu8),
!	("uint16",		kstdtypesym,	tu16),
!	("uint32",		kstdtypesym,	tu32),
!	("uint64",		kstdtypesym,	tu64),
!
	("__DATE__",	predefmacrosym,	pdm_date),
	("__FILE__",	predefmacrosym,	pdm_file),
	("__LINE__",	predefmacrosym,	pdm_line),
!	("__STDC__",	predefmacrosym,	pdm_stdc),
	("__TIME__",	predefmacrosym,	pdm_time),
!	("__cdecl",		predefmacrosym,	pdm_cdecl),
	("__MCC__",		predefmacrosym,	pdm_mcc),
	("__MCCI__",	predefmacrosym,	pdm_mcci),
	("__func__",	predefmacrosym,	pdm_func),
	("__FUNCTION__",	predefmacrosym,	pdm_func),

	("__declspec",	kdeclspecsym,	0),

!	("not",			notlsym,		0),
	("sizeof",		ksizeofsym,		0),
	("lengthof",	ksizeofsym,		1),
	("defined",		kdefinedsym,	0),
	("_Generic",	kgenericsym,	0),
	("_Alignof",	kalignofsym,	0),

	("$setjmp",		ksetjmpsym,		jsetjmp),
	("$longjmp",	ksetjmpsym,		jlongjmp),
	("$showmode",	kshowmodesym,	0),

	("$$dummy",		0,				0)
end

global enumdata [0:]ichar convnames =

	(no_conv=0,	$),
	(soft_c,	$),			!no conversion needed, just type change
	(hard_c,	$),			!explicit conversion, done as uwiden or narrow to match sizes

	(swiden_c,	$),			!widen with sign-extension	(1/2/4 to 4/8)
	(uwiden_c,	$),			!widen with zero-extension	(1/2/4 to 4/8)
	(sfloat_c,	$),			!signed int to float		(1/2/4/8 to 4/8)
	(ufloat_c,	$),			!unsigned int to float		(1/2/4/8 to 4/8)
	(sfix_c,	$),			!float to signed int		(4/8 to 1/2/4/8)
	(ufix_c,	$),			!float to unsigned int		(4/8 to 1/2/4/8)
	(fwiden_c,	$),			!float to wider float		(4 to 8)
	(fnarrow_c,	$),			!float to narrower float	(8 to 4)
	(narrow_c,	$),			!narrow without truncation	(8/4/2 to 4/2/1)
	(truncate_c,$),			!narrow and truncate		(8/4/2 to 4/2/1)
	(bool_c,	$)			!int to bool				(1/2/4/8 to 1)
end

!take two basic numeric types and determine which is more dominant
!zeros mean not supported (error, not both numbers etc)
!(table could have been 16x16 but means checking both basic types being in-range first)

!dominantmode[s,t] returns the dominant type of s and t, widened to int/uint as needed
global [0:32,0:32]byte dominantmode

!conversionops[s,t] gives conversion op to convert numeric types s to t
global [0:16,0:16]byte conversionops

!table used to set up dominanttable[]
!3rd entry is the more dominant of the first two (wided as needed to int/unsigned int)
global [][3]byte dominantsetuptable=(
	(ti8,	ti8,		ti32),
	(ti8,	ti16,	ti32),
	(ti8,	ti32,		ti32),
	(ti8,	ti64,	ti64),
	(ti8,	tbool,		ti32),
	(ti8,	tu8,		ti32),
	(ti8,	tu16,	ti32),
	(ti8,	tu32,		ti32),
	(ti8,	tu64,	ti64),
	(ti8,	tr32,		tr32),
	(ti8,	tr64,	tr64),
	(ti16,	ti8,		ti32),
	(ti16,	ti16,	ti32),
	(ti16,	ti32,		ti32),
	(ti16,	ti64,	ti64),
	(ti16,	tbool,		ti32),
	(ti16,	tu8,		ti32),
	(ti16,	tu16,	ti32),
	(ti16,	tu32,		ti32),
	(ti16,	tu64,	ti64),
	(ti16,	tr32,		tr32),
	(ti16,	tr64,	tr64),
	(ti32,		ti8,		ti32),
	(ti32,		ti16,	ti32),
	(ti32,		ti32,		ti32),
	(ti32,		ti64,	ti64),
	(ti32,		tbool,		ti32),
	(ti32,		tu8,		ti32),
	(ti32,		tu16,	ti32),
	(ti32,		tu32,		tu32),
	(ti32,		tu64,	ti64),
	(ti32,		tr32,		tr32),
	(ti32,		tr64,	tr64),
	(ti64,	ti8,		ti64),
	(ti64,	ti16,	ti64),
	(ti64,	ti32,		ti64),
	(ti64,	ti64,	ti64),
	(ti64,	tbool,		ti64),
	(ti64,	tu8,		ti64),
	(ti64,	tu16,	ti64),
	(ti64,	tu32,		ti64),
	(ti64,	tu64,	tu64),
	(ti64,	tr32,		tr32),
	(ti64,	tr64,	tr64),
	(tbool,		ti8,		ti32),
	(tbool,		ti16,	ti32),
	(tbool,		ti32,		ti32),
	(tbool,		ti64,	ti64),
	(tbool,		tbool,		tu32),
	(tbool,		tu8,		tu32),
	(tbool,		tu16,	tu32),
	(tbool,		tu32,		tu32),
	(tbool,		tu64,	tu64),
	(tbool,		tr32,		tr32),
	(tbool,		tr64,	tr64),
	(tu8,	ti8,		ti32),
	(tu8,	ti16,	ti32),
	(tu8,	ti32,		ti32),
	(tu8,	ti64,	ti64),
	(tu8,	tbool,		tvoid),
	(tu8,	tu8,		tu32),
	(tu8,	tu16,	tu32),
	(tu8,	tu32,		tu32),
	(tu8,	tu64,	tu64),
	(tu8,	tr32,		tr32),
	(tu8,	tr64,	tr64),
	(tu16,	ti8,		ti32),
	(tu16,	ti16,	ti32),
	(tu16,	ti32,		ti32),
	(tu16,	ti64,	ti64),
	(tu16,	tbool,		tu32),
	(tu16,	tu8,		tu32),
	(tu16,	tu16,	tu32),
	(tu16,	tu32,		tu32),
	(tu16,	tu64,	tu64),
	(tu16,	tr32,		tr32),
	(tu16,	tr64,	tr64),
	(tu32,		ti8,		ti32),
	(tu32,		ti16,	ti32),
	(tu32,		ti32,		tu32),
	(tu32,		ti64,	ti64),
	(tu32,		tbool,		tu32),
	(tu32,		tu8,		tu32),
	(tu32,		tu16,	tu32),
	(tu32,		tu32,		tu32),
	(tu32,		tu64,	tu64),
	(tu32,		tr32,		tr32),
	(tu32,		tr64,	tr64),
	(tu64,	ti8,		tu64),
	(tu64,	ti16,	tu64),
	(tu64,	ti32,		tu64),
	(tu64,	ti64,	tu64),
	(tu64,	tbool,		tu64),
	(tu64,	tu8,		tu64),
	(tu64,	tu16,	tu64),
	(tu64,	tu32,		tu64),
	(tu64,	tu64,	tu64),
	(tu64,	tr32,		tr32),
	(tu64,	tr64,	tr64),
	(tr32,	ti8,		tr64),
	(tr32,	ti16,	tr64),
	(tr32,	ti32,		tr64),
	(tr32,	ti64,	tr64),
	(tr32,	tbool,		tr64),
	(tr32,	tu8,		tr64),
	(tr32,	tu16,	tr64),
	(tr32,	tu32,		tr64),
	(tr32,	tu64,	tr64),
	(tr32,	tr32,		tr32),
	(tr32,	tr64,	tr64),
	(tr64,	ti8,		tr64),
	(tr64,	ti16,	tr64),
	(tr64,	ti32,		tr64),
	(tr64,	ti64,	tr64),
	(tr64,	tbool,		tr64),
	(tr64,	tu8,		tr64),
	(tr64,	tu16,	tr64),
	(tr64,	tu32,		tr64),
	(tr64,	tu64,	tr64),
	(tr64,	tr32,		tr64),
	(tr64,	tr64,	tr64),
)

!table used to set up conversionops
global [][3]byte convsetuptable=(
	(ti8,	ti8,	swiden_c),
	(ti8,	ti16,	swiden_c),
	(ti8,	ti32,	swiden_c),
	(ti8,	ti64,	swiden_c),
	(ti8,	tbool,	bool_c),
	(ti8,	tu8,	soft_c),
	(ti8,	tu16,	swiden_c),
	(ti8,	tu32,	swiden_c),
	(ti8,	tu64,	swiden_c),
	(ti8,	tr32,	sfloat_c),
	(ti8,	tr64,	sfloat_c),

	(ti16,	ti8,	truncate_c),
	(ti16,	ti16,	no_conv),
	(ti16,	ti32,	swiden_c),
	(ti16,	ti64,	swiden_c),
	(ti16,	tbool,	bool_c),
	(ti16,	tu8,	truncate_c),
	(ti16,	tu16,	soft_c),
	(ti16,	tu32,	swiden_c),
	(ti16,	tu64,	swiden_c),
	(ti16,	tr32,	sfloat_c),
	(ti16,	tr64,	sfloat_c),
	(ti32,	ti8,	truncate_c),

	(ti32,	ti16,	truncate_c),

	(ti32,	ti32,	no_conv),
	(ti32,	ti64,	swiden_c),
	(ti32,	tbool,	bool_c),
	(ti32,	tu8,	truncate_c),
	(ti32,	tu16,	truncate_c),
	(ti32,	tu32,	soft_c),
	(ti32,	tu64,	swiden_c),
	(ti32,	tr32,	sfloat_c),
	(ti32,	tr64,	sfloat_c),

	(ti64,	ti8,	truncate_c),
!	(ti64,	ti8,	narrow_c),

	(ti64,	ti16,	truncate_c),
	(ti64,	ti32,	truncate_c),
	(ti64,	ti64,	no_conv),
	(ti64,	tbool,	bool_c),

	(ti64,	tu8,	truncate_c),
!	(ti64,	tu8,	narrow_c),

	(ti64,	tu16,	truncate_c),
	(ti64,	tu32,	truncate_c),
	(ti64,	tu64,	soft_c),
	(ti64,	tr32,	sfloat_c),
	(ti64,	tr64,	sfloat_c),
	(tbool,	ti8,	soft_c),
	(tbool,	ti16,	uwiden_c),
	(tbool,	ti32,	uwiden_c),
	(tbool,	ti64,	uwiden_c),
	(tbool,	tbool,	no_conv),
	(tbool,	tu8,	soft_c),
	(tbool,	tu16,	uwiden_c),
	(tbool,	tu32,	uwiden_c),
	(tbool,	tu64,	uwiden_c),
	(tbool,	tr32,	ufloat_c),
	(tbool,	tr64,	ufloat_c),
	(tu8,	ti8,	soft_c),
	(tu8,	ti16,	uwiden_c),
	(tu8,	ti32,	uwiden_c),
	(tu8,	ti64,	uwiden_c),
	(tu8,	tbool,	bool_c),
	(tu8,	tu8,	soft_c),
	(tu8,	tu16,	uwiden_c),
	(tu8,	tu32,	uwiden_c),
	(tu8,	tu64,	uwiden_c),
	(tu8,	tr32,	ufloat_c),
	(tu8,	tr64,	ufloat_c),

	(tu16,	ti8,	truncate_c),
	(tu16,	ti16,	soft_c),
	(tu16,	ti32,	uwiden_c),
	(tu16,	ti64,	uwiden_c),
	(tu16,	tbool,	bool_c),
	(tu16,	tu8,	truncate_c),
	(tu16,	tu16,	no_conv),
	(tu16,	tu32,	uwiden_c),
	(tu16,	tu64,	uwiden_c),
	(tu16,	tr32,	ufloat_c),
	(tu16,	tr64,	ufloat_c),

	(tu32,	ti8,	truncate_c),
	(tu32,	ti16,	truncate_c),
	(tu32,	ti32,		soft_c),
	(tu32,	ti64,	uwiden_c),
	(tu32,	tbool,	bool_c),
	(tu32,	tu8,	truncate_c),
	(tu32,	tu16,	truncate_c),
	(tu32,	tu32,	no_conv),
	(tu32,	tu64,	uwiden_c),
	(tu32,	tr32,	ufloat_c),
	(tu32,	tr64,	ufloat_c),

	(tu64,	ti8,	truncate_c),
	(tu64,	ti16,	truncate_c),
	(tu64,	ti32,	truncate_c),
	(tu64,	ti64,	soft_c),
	(tu64,	tbool,	bool_c),
	(tu64,	tu8,	truncate_c),
	(tu64,	tu16,	truncate_c),
	(tu64,	tu32,	truncate_c),
	(tu64,	tu64,	no_conv),
	(tu64,	tr32,	ufloat_c),
	(tu64,	tr64,	ufloat_c),

	(tr32,	ti8,	sfix_c),
	(tr32,	ti16,	sfix_c),
	(tr32,	ti32,	sfix_c),
	(tr32,	ti64,	sfix_c),
	(tr32,	tbool,	ufix_c),
	(tr32,	tu8,	ufix_c),
	(tr32,	tu16,	ufix_c),
	(tr32,	tu32,	ufix_c),
	(tr32,	tu64,	ufix_c),
	(tr32,	tr32,	no_conv),
	(tr32,	tr64,	fwiden_c),

	(tr64,	ti8,	sfix_c),
	(tr64,	ti16,	sfix_c),
	(tr64,	ti32,	sfix_c),
	(tr64,	ti64,	sfix_c),
	(tr64,	tbool,	ufix_c),
	(tr64,	tu8,	ufix_c),
	(tr64,	tu16,	ufix_c),
	(tr64,	tu32,	ufix_c),
	(tr64,	tu64,	ufix_c),
	(tr64,	tr32,	fnarrow_c),
	(tr64,	tr64,	no_conv),

)

global []int badexprs=(
jconst,
jname,
jifx,
jandl,
jorl,
jnotl,
jistruel,
jexprlist,
jandand,
jeq,
jne,
jlt,
jle,
jge,
jgt,
jadd,
jsub,
jmul,
jdiv,
jrem,
jiand,
jior,
jixor,
jshl,
jshr,
jdot,
jidot,
jindex,
jptr,
jaddptr,
jsubptr,
jneg,
jabs,
jinot)

=== pcl.m 0 0 23/108 ===
project =
	module pc_api
	module pc_decls

	module pc_diags
!	module pc_diags_dummy
	module pc_reduce

! Interpreter
	module pc_run
	module pc_runaux
!	module pc_run_dummy

! Tables (eg. types and IL opcodes)
	module pc_tables

	module mc_GenMCL
	module mc_AuxMCL
	module mc_LibMCL
	module mc_StackMCL
	module mc_Optim

	module mc_GenSS

	module mc_Decls as md
	module mc_OBJdecls
!	module mc_WriteASM
	module mc_WriteGAS
!	module mc_WriteNASM

	module mc_WriteEXE
!	module mc_WriteOBJ
!	module mc_WriteOBJ_dummy

!	module mc_writess
!	module mc_disasm
!	module mc_writess_dummy

	module mx_decls
	module mx_run
	module mx_lib
	module mx_write

end

export byte pc_userunpcl=0

export byte asmonly=0			!for cx/gas
export byte pdcc=0

export function writessdata(int fexe)ref strbuffer=
	nil
end

global proc writecoff(ichar outfile)=end
=== pclc.m 0 0 24/108 ===
project =
	module pc_api
	module pc_decls

	module pc_diags
!	module pc_diags_dummy

!	module pc_run_dummy
	module pc_reduce

	module pc_tables

	module mc_GenC
	module mc_AuxC
	module mc_LibC

!	module mc_GenSS_dummy
!
!	module mc_WriteEXE_dummy
!	module mc_WriteOBJ_dummy
!	module mc_WriteSS_dummy
!	module mx_run_dummy

end

global proc genss(int obj=0)=
end

export function writessdata(int fexe)ref strbuffer=
	nil
end

global proc writecoff(ichar outfile)=end

global proc writeexe(ichar outfile, int dodll)=
end

global proc runlibfile(ichar filename, int cmdskip)=
	abortprogram("No Run")
end

global proc writemcx(ichar filename)=
end

export proc pcl_runpcl=
end

export byte pc_userunpcl=0			!ask host to default to -runpcl option

=== pclcp.m 0 0 25/108 ===
project =
	module pc_api
	module pc_decls

	module pc_diags
!	module pc_diags_dummy

!	module pc_run_dummy
	module pc_reduce

	module pc_tables

	module mc_GenC
	module mc_AuxC
	module mc_LibC

!	module mc_GenSS_dummy
!	module mc_Decls as md
!	module mc_OBJdecls

!	module mc_WriteASM_dummy

!	module mc_WriteEXE_dummy
!	module mc_WriteOBJ_dummy
!	module mc_WriteSS_dummy
!	module mx_run_dummy

end

export byte pc_userunpcl=0			!ask host to default to -runpcl option

=== pclp.m 0 0 26/108 ===
project =
	module pc_api
	module pc_decls

	module pc_diags
!	module pc_diags_dummy
	module pc_reduce

! Interpreter
	module pc_run
	module pc_runaux

! Tables (eg. types and IL opcodes)
	module pc_tables

!	module pc_genc
!	module pc_auxc
!	module pc_libc

	module mc_GenMCL
	module mc_AuxMCL
	module mc_LibMCL
	module mc_StackMCL
	module mc_Optim

	module mc_GenSS

	module mc_Decls as md
	module mc_OBJdecls
	module mc_WriteASM
!	module mc_WriteASM_small
!	module mc_WriteNASM

	module mc_WriteEXE
	module mc_WriteOBJ

!	module mc_writess
!	module mc_disasm
!	module mc_writess_dummy

	module mx_decls
	module mx_run
	module mx_lib
	module mx_write

end

export byte pc_userunpcl=0
export byte asmonly=0
export byte pdcc=0

export function writessdata(int fexe)ref strbuffer=
	nil
end

=== pcl_lib.m 0 0 27/108 ===
importdll pcl =
    type psymbol = ref pstrec
    type pcl = ref pclrec
    record pclrec = 
        u8 opcode
        u8 opndtype
        u8 condcode
        u8 mode
        u32 size
        union
            struct
                union
                    i64 value
                    r64 xvalue
                    ichar svalue
                    i64 labelno
                    psymbol def
                    ref void asmcode
                end
                union
                    struct
                        i32 x
                        i32 y
                    end
                    struct
                        i32 scale
                        i32 extra
                    end
                    struct
                        i32 nargs
                        union
                            i32 nvariadics
                            i32 simple
                        end
                    end
                    struct
                        i32 minlab
                        i32 maxlab
                    end
                    struct
                        i32 paramslots
                        i32 localslots
                    end
                    i32 stepx
                    i32 align
                    i32 popone
                    i32 slicelwb
                    i32 inplace
                end
            end
        end
        u32 pos
        bitfl sourceoffset
        bitfl fileno
        i32 dummy
        bitfl mode2
        bitfl seqno
    end

    record fwdrec = 
        ref fwdrec nextfwd
        i32 offset
        i16 reltype
        i16 seg
    end

    type procinfo = ref procinforec
    record procinforec = 
        u8 pcldepth
        u8 nparams
        u8 nlocals
        u8 isleaf
        u8 nmaxargs
        u8 assemused
        u8 mcldone
        u8 hasblocks
    end

    type mclopnd = ref mclopndrec
    record mclopndrec = 
        union
            psymbol def
            i64 value
            r64 xvalue
            ichar svalue
            i64 labelno
            i64 sysfn
            i64 tempno
        end
        u16 misc
        bitfl size
        bitfl scale
        bitfl mode
        bitfl valtype
        u8 reg
        u8 regix
        i32 offset
    end

    record mclrec = 
        ref mclrec lastmcl
        ref mclrec nextmcl
        mclopnd a
        mclopnd b
        u8 c
        u8 opcode
        u8 cond
        u8 spare1
        u32 seqno
        union
            u32 mpos
            u32 lineno
        end
        u32 spare2
        union
            [16]u8 regfreed
            pair regfreedpr
        end
    end

    record relocrec = 
        ref relocrec nextreloc
        i64 reloctype
        i64 offset
        i64 stindex
    end

    record dbuffer = 
        ref u8 pstart
        union
            ref u8 pcurr
            ref u16 pcurr16
            ref u32 pcurr32
            ref u64 pcurr64
        end
        ref u8 pend
        i64 alloc
    end

    record mcxreloc = 
        u32 offset
        union
            u16 stindex
            u8 targetsegment
        end
        u8 segment
        u8 reloctype
    end

    record librec = 
        ichar version
        i64 codesize
        i64 idatasize
        i64 zdatasize
        i64 nrelocs
        i64 ndlllibs
        i64 nlibs
        i64 nimports
        i64 nexports
        ref u8 codeptr
        ref u8 idataptr
        ref []mcxreloc reloctable
        ref []ichar dllnames
        ref []ichar libnames
        ref []ichar importnames
        ref []ichar exports
        ref []u8 exportsegs
        ref []u64 exportoffsets
        u64 entryoffset
        ref u8 zdataptr
        i64 codexsize
        ref []u64 exportaddr
        ref []i16 importxreftable
        ichar filespec
        ichar libname
        ref u8 entryaddr
        i64 libno
    end

    var u8 pc_userunpcl
    var i64 pclseqno
    var pcl pcstart
    var pcl pccurr
    var pcl pcend
    var i64 mlabelno
    var u8 phighmem
    var u8 pfullsys
    var ref proc(ref void $1) idomcl_assem
    var ref proc(ref void $1)i64 icheckasmlabel
    var ref proc(i64 $1)ref pstrec igethostfn
    var i64 mmpos
    var psymbol currfunc
    var ref proc(i64 pos,ref ichar filename,ref ichar sourceline)i64 igetmsourceinfo
    var u8 pverbose
    var i64 assemtype
    var u8 fpeephole
    var u8 fregoptim
    var i64 mcltime
    var i64 sstime
    var i64 objtime
    var i64 exetime
    var ichar $pmodulename
    var [0..142]i64 pclflags
    var i64 pstartclock
    var [0..13]ichar pstdnames
    var [0..13]u8 psize
    var [0..13]u8 psigned
    var [0..13]u8 pint
    var [0..13]u8 pfloat
    var [0..13]u8 pmin
    var [0..13]u8 piwrb
    var [0..13]ichar opndnames
    var [0..142]ichar pclnames
    var [0..142]u8 pclhastype
    var [0..142]u8 pclextra
    var [0..142]u8 pclhasopnd
    var [0..142]u8 pclargs
    var [0..6]ichar ccnames
    var [0..9]ichar idnames
    var i64 mclseqno
    var i64 nmclopnd
    var [0..8]ichar valtypenames
    var [152]ichar mclnames
    var [152]u8 mclnopnds
    var [152]u8 mclcodes
    var [0..20]ichar regnames
    var [0..20]u8 regcodes
    var [0..19]ichar condnames
    var [0..19]ichar asmcondnames
    var [0..19]i64 asmrevcond
    var [137]ichar dregnames
    var [137]u8 regsizes
    var [137]u8 regindices
    var [16]ichar xmmregnames
    var [8]ichar fregnames
    var [8]ichar mregnames
    var [18]ichar jmpccnames
    var [18]u8 jmpcccodes
    var [16]ichar setccnames
    var [16]u8 setcccodes
    var [16]ichar cmovccnames
    var [16]u8 cmovcccodes
    var [0..5]ichar segmentnames
    var [0..2]ichar reftypenames
    var [0..5]ichar opndnames_ma
    var [0..16]ichar xregnames
    var ref mclrec mccode
    var ref mclrec mccodex
    var [8]u8 regmodes
    var [0..13]ichar mcxdirnames
    var [0..5]ichar mcxrelocnames
    var i64 nsymimports
    var i64 nsymexports

    const i64 tpvoid = 0
    const i64 tpr32 = 1
    const i64 tpr64 = 2
    const i64 tpu8 = 3
    const i64 tpu16 = 4
    const i64 tpu32 = 5
    const i64 tpu64 = 6
    const i64 tpi8 = 7
    const i64 tpi16 = 8
    const i64 tpi32 = 9
    const i64 tpi64 = 10
    const i64 tpblock = 11
    const i64 tpvector = 12
    const i64 tplast = 13
    const i64 no_opnd = 0
    const i64 mem_opnd = 1
    const i64 memaddr_opnd = 2
    const i64 label_opnd = 3
    const i64 int_opnd = 4
    const i64 real_opnd = 5
    const i64 r32_opnd = 6
    const i64 string_opnd = 7
    const i64 strimm_opnd = 8
    const i64 assem_opnd = 9
    const i64 realimm_opnd = 10
    const i64 realimm32_opnd = 11
    const i64 data_opnd = 12
    const i64 any_opnd = 13
    const i64 knop = 0
    const i64 kload = 1
    const i64 kiload = 2
    const i64 kiloadx = 3
    const i64 kstore = 4
    const i64 kistore = 5
    const i64 kistorex = 6
    const i64 kstorem = 7
    const i64 kdupl = 8
    const i64 kdouble = 9
    const i64 kswapstk = 10
    const i64 kunload = 11
    const i64 kopnd = 12
    const i64 ktype = 13
    const i64 kloadbit = 14
    const i64 kloadbf = 15
    const i64 kstorebit = 16
    const i64 kstorebf = 17
    const i64 kcallp = 18
    const i64 kicallp = 19
    const i64 kretproc = 20
    const i64 kcallf = 21
    const i64 kicallf = 22
    const i64 kretfn = 23
    const i64 kjump = 24
    const i64 kijump = 25
    const i64 kjumpcc = 26
    const i64 kjumpt = 27
    const i64 kjumpf = 28
    const i64 kjumpret = 29
    const i64 kjumpretm = 30
    const i64 ksetcc = 31
    const i64 kstop = 32
    const i64 kto = 33
    const i64 kforup = 34
    const i64 kfordown = 35
    const i64 kiswap = 36
    const i64 kswitch = 37
    const i64 kswitchu = 38
    const i64 kswlabel = 39
    const i64 kendsw = 40
    const i64 kclear = 41
    const i64 kassem = 42
    const i64 kadd = 43
    const i64 ksub = 44
    const i64 kmul = 45
    const i64 kdiv = 46
    const i64 kidiv = 47
    const i64 kirem = 48
    const i64 kidivrem = 49
    const i64 kbitand = 50
    const i64 kbitor = 51
    const i64 kbitxor = 52
    const i64 kshl = 53
    const i64 kshr = 54
    const i64 kmin = 55
    const i64 kmax = 56
    const i64 kaddpx = 57
    const i64 ksubpx = 58
    const i64 ksubp = 59
    const i64 kneg = 60
    const i64 kabs = 61
    const i64 kbitnot = 62
    const i64 knot = 63
    const i64 ktoboolt = 64
    const i64 ktoboolf = 65
    const i64 ksqr = 66
    const i64 ksqrt = 67
    const i64 ksin = 68
    const i64 kcos = 69
    const i64 ktan = 70
    const i64 kasin = 71
    const i64 kacos = 72
    const i64 katan = 73
    const i64 klog = 74
    const i64 klog10 = 75
    const i64 kexp = 76
    const i64 kround = 77
    const i64 kfloor = 78
    const i64 kceil = 79
    const i64 ksign = 80
    const i64 katan2 = 81
    const i64 kpower = 82
    const i64 kfmod = 83
    const i64 kincrto = 84
    const i64 kdecrto = 85
    const i64 kincrload = 86
    const i64 kdecrload = 87
    const i64 kloadincr = 88
    const i64 kloaddecr = 89
    const i64 kaddto = 90
    const i64 ksubto = 91
    const i64 kmulto = 92
    const i64 kdivto = 93
    const i64 kidivto = 94
    const i64 kiremto = 95
    const i64 kbitandto = 96
    const i64 kbitorto = 97
    const i64 kbitxorto = 98
    const i64 kshlto = 99
    const i64 kshrto = 100
    const i64 kminto = 101
    const i64 kmaxto = 102
    const i64 kaddpxto = 103
    const i64 ksubpxto = 104
    const i64 knegto = 105
    const i64 kabsto = 106
    const i64 kbitnotto = 107
    const i64 knotto = 108
    const i64 ktoboolto = 109
    const i64 ktypepun = 110
    const i64 kfloat = 111
    const i64 kfix = 112
    const i64 ktruncate = 113
    const i64 kwiden = 114
    const i64 kfwiden = 115
    const i64 kfnarrow = 116
    const i64 kstartmx = 117
    const i64 kresetmx = 118
    const i64 kendmx = 119
    const i64 kproc = 120
    const i64 ktcproc = 121
    const i64 kendproc = 122
    const i64 kistatic = 123
    const i64 kzstatic = 124
    const i64 kdata = 125
    const i64 kinitdswx = 126
    const i64 klabel = 127
    const i64 klabeldef = 128
    const i64 ksetjmp = 129
    const i64 klongjmp = 130
    const i64 ksetcall = 131
    const i64 ksetarg = 132
    const i64 kloadall = 133
    const i64 keval = 134
    const i64 kcomment = 135
    const i64 kendprog = 136
    const i64 kparam = 137
    const i64 klocal = 138
    const i64 krettype = 139
    const i64 kvariadic = 140
    const i64 kaddlib = 141
    const i64 kextproc = 142
    const i64 no_cc = 0
    const i64 eq_cc = 1
    const i64 ne_cc = 2
    const i64 lt_cc = 3
    const i64 le_cc = 4
    const i64 ge_cc = 5
    const i64 gt_cc = 6
    const i64 null_id = 0
    const i64 import_id = 1
    const i64 proc_id = 2
    const i64 static_id = 3
    const i64 local_id = 4
    const i64 param_id = 5
    const i64 label_id = 6
    const i64 export_id = 7
    const i64 misc_id = 8
    const i64 program_id = 9
    const i64 ctarget = 0
    const i64 no_val = 0
    const i64 intimm_val = 1
    const i64 realimm_val = 2
    const i64 realmem_val = 3
    const i64 stringimm_val = 4
    const i64 def_val = 5
    const i64 label_val = 6
    const i64 name_val = 7
    const i64 temp_val = 8
    const i64 m_procstart = 1
    const i64 m_procend = 2
    const i64 m_comment = 3
    const i64 m_labelname = 4
    const i64 m_define = 5
    const i64 m_definereg = 6
    const i64 m_trace = 7
    const i64 m_endx = 8
    const i64 m_labelx = 9
    const i64 m_nop = 10
    const i64 m_param = 11
    const i64 m_mov = 12
    const i64 m_push = 13
    const i64 m_pop = 14
    const i64 m_lea = 15
    const i64 m_cmovcc = 16
    const i64 m_movd = 17
    const i64 m_movq = 18
    const i64 m_movsx = 19
    const i64 m_movzx = 20
    const i64 m_movsxd = 21
    const i64 m_call = 22
    const i64 m_ret = 23
    const i64 m_leave = 24
    const i64 m_retn = 25
    const i64 m_jmp = 26
    const i64 m_jmpcc = 27
    const i64 m_xchg = 28
    const i64 m_add = 29
    const i64 m_sub = 30
    const i64 m_adc = 31
    const i64 m_sbb = 32
    const i64 m_imul = 33
    const i64 m_mul = 34
    const i64 m_imul2 = 35
    const i64 m_imul3 = 36
    const i64 m_idiv = 37
    const i64 m_div = 38
    const i64 m_andx = 39
    const i64 m_orx = 40
    const i64 m_xorx = 41
    const i64 m_test = 42
    const i64 m_cmp = 43
    const i64 m_shl = 44
    const i64 m_sar = 45
    const i64 m_shr = 46
    const i64 m_rol = 47
    const i64 m_ror = 48
    const i64 m_rcl = 49
    const i64 m_rcr = 50
    const i64 m_neg = 51
    const i64 m_notx = 52
    const i64 m_inc = 53
    const i64 m_dec = 54
    const i64 m_cbw = 55
    const i64 m_cwd = 56
    const i64 m_cdq = 57
    const i64 m_cqo = 58
    const i64 m_setcc = 59
    const i64 m_bsf = 60
    const i64 m_bsr = 61
    const i64 m_shld = 62
    const i64 m_shrd = 63
    const i64 m_sqrtss = 64
    const i64 m_sqrtsd = 65
    const i64 m_addss = 66
    const i64 m_addsd = 67
    const i64 m_subss = 68
    const i64 m_subsd = 69
    const i64 m_mulss = 70
    const i64 m_mulsd = 71
    const i64 m_divss = 72
    const i64 m_divsd = 73
    const i64 m_comiss = 74
    const i64 m_comisd = 75
    const i64 m_ucomisd = 76
    const i64 m_xorps = 77
    const i64 m_xorpd = 78
    const i64 m_andps = 79
    const i64 m_andpd = 80
    const i64 m_pxor = 81
    const i64 m_pand = 82
    const i64 m_cvtss2si = 83
    const i64 m_cvtsd2si = 84
    const i64 m_cvttss2si = 85
    const i64 m_cvttsd2si = 86
    const i64 m_cvtsi2ss = 87
    const i64 m_cvtsi2sd = 88
    const i64 m_cvtsd2ss = 89
    const i64 m_cvtss2sd = 90
    const i64 m_movdqa = 91
    const i64 m_movdqu = 92
    const i64 m_pcmpistri = 93
    const i64 m_pcmpistrm = 94
    const i64 m_fld = 95
    const i64 m_fst = 96
    const i64 m_fstp = 97
    const i64 m_fild = 98
    const i64 m_fist = 99
    const i64 m_fistp = 100
    const i64 m_fadd = 101
    const i64 m_fsub = 102
    const i64 m_fmul = 103
    const i64 m_fdiv = 104
    const i64 m_fsqrt = 105
    const i64 m_fsin = 106
    const i64 m_fcos = 107
    const i64 m_fsincos = 108
    const i64 m_fptan = 109
    const i64 m_fpatan = 110
    const i64 m_fabs = 111
    const i64 m_fchs = 112
    const i64 m_minss = 113
    const i64 m_maxss = 114
    const i64 m_minsd = 115
    const i64 m_maxsd = 116
    const i64 m_db = 117
    const i64 m_dw = 118
    const i64 m_dd = 119
    const i64 m_dq = 120
    const i64 m_isegment = 121
    const i64 m_zsegment = 122
    const i64 m_csegment = 123
    const i64 m_align = 124
    const i64 m_resb = 125
    const i64 m_resw = 126
    const i64 m_resd = 127
    const i64 m_resq = 128
    const i64 m_xlat = 129
    const i64 m_loopnz = 130
    const i64 m_loopz = 131
    const i64 m_loopcx = 132
    const i64 m_jecxz = 133
    const i64 m_jrcxz = 134
    const i64 m_cmpsb = 135
    const i64 m_cmpsw = 136
    const i64 m_cmpsd = 137
    const i64 m_cmpsq = 138
    const i64 m_rdtsc = 139
    const i64 m_popcnt = 140
    const i64 m_bswap = 141
    const i64 m_finit = 142
    const i64 m_fldz = 143
    const i64 m_fld1 = 144
    const i64 m_fldpi = 145
    const i64 m_fld2t = 146
    const i64 m_fld2e = 147
    const i64 m_fldlg2 = 148
    const i64 m_fldln2 = 149
    const i64 m_cpuid = 150
    const i64 m_xxxx = 151
    const i64 m_halt = 152
    const i64 rnone = 0
    const i64 r0 = 1
    const i64 r1 = 2
    const i64 r2 = 3
    const i64 r3 = 4
    const i64 r4 = 5
    const i64 r5 = 6
    const i64 r6 = 7
    const i64 r7 = 8
    const i64 r8 = 9
    const i64 r9 = 10
    const i64 r10 = 11
    const i64 r11 = 12
    const i64 r12 = 13
    const i64 r13 = 14
    const i64 r14 = 15
    const i64 r15 = 16
    const i64 r16 = 17
    const i64 r17 = 18
    const i64 r18 = 19
    const i64 r19 = 20
    const i64 rframe = 15
    const i64 rstack = 16
    const i64 ov_cond = 0
    const i64 nov_cond = 1
    const i64 ltu_cond = 2
    const i64 geu_cond = 3
    const i64 eq_cond = 4
    const i64 ne_cond = 5
    const i64 leu_cond = 6
    const i64 gtu_cond = 7
    const i64 s_cond = 8
    const i64 ns_cond = 9
    const i64 p_cond = 10
    const i64 np_cond = 11
    const i64 lt_cond = 12
    const i64 ge_cond = 13
    const i64 le_cond = 14
    const i64 gt_cond = 15
    const i64 flt_cond = 16
    const i64 fge_cond = 17
    const i64 fle_cond = 18
    const i64 fgt_cond = 19
    const i64 no_seg = 0
    const i64 code_seg = 1
    const i64 idata_seg = 2
    const i64 zdata_seg = 3
    const i64 rodata_seg = 4
    const i64 impdata_seg = 5
    const i64 extern_ref = 0
    const i64 fwd_ref = 1
    const i64 back_ref = 2
    const i64 a_none = 0
    const i64 a_reg = 1
    const i64 a_imm = 2
    const i64 a_mem = 3
    const i64 a_cond = 4
    const i64 a_xreg = 5
    const i64 xnone = 0
    const i64 xr0 = 1
    const i64 xr1 = 2
    const i64 xr2 = 3
    const i64 xr3 = 4
    const i64 xr4 = 5
    const i64 xr5 = 6
    const i64 xr6 = 7
    const i64 xr7 = 8
    const i64 xr8 = 9
    const i64 xr9 = 10
    const i64 xr10 = 11
    const i64 xr11 = 12
    const i64 xr12 = 13
    const i64 xr13 = 14
    const i64 xr14 = 15
    const i64 xr15 = 16
    const c64 mcxsig = M6
    const i64 pad_dir = 0
    const i64 version_dir = 1
    const i64 code_dir = 2
    const i64 idata_dir = 3
    const i64 zdata_dir = 4
    const i64 reloc_dir = 5
    const i64 dlls_dir = 6
    const i64 libs_dir = 7
    const i64 importsymbols_dir = 8
    const i64 exportsymbols_dir = 9
    const i64 exportsegs_dir = 10
    const i64 exportoffsets_dir = 11
    const i64 entry_dir = 12
    const i64 end_dir = 13
    const i64 no_rel = 0
    const i64 locabs32_rel = 1
    const i64 locabs64_rel = 2
    const i64 impabs32_rel = 3
    const i64 impabs64_rel = 4
    const i64 imprel32_rel = 5

    func pcl_start(ichar name=nil,i64 nunits=0) => psymbol
    proc pcl_end()
    func pcl_writepcl(ichar filename=nil) => ichar
    func pcl_writepst(ichar filename=nil) => ichar
    proc pcl_genmcl()
    proc pcl_genss(i64 obj=0)
    func pcl_writess(ichar filename=nil,i64 obj=0) => ichar
    func pcl_writeasm(ichar filename=nil,i64 atype=16705) => ichar
    proc pcl_writeobj(ichar filename)
    proc pcl_writedll(ichar filename)
    proc pcl_writeexe(ichar filename)
    proc pcl_writemx(ichar filename)
    proc pcl_exec()
    proc pcl_setflags(i64 highmem=-1,verbose=-1,shortnames=-1)
    proc pc_gen(i64 opcode,pcl p=nil)
    proc pc_genix(i64 opcode,scale=1,offset=0)
    proc pc_genx(i64 opcode,x,pcl p=nil)
    proc pc_genxy(i64 opcode,x,y,pcl p=nil)
    proc pc_gencond(i64 opcode,cond,pcl p=nil)
    func genint(i64 a) => pcl
    func genreal(r64 x,i64 mode=2) => pcl
    func genrealimm(r64 x,i64 mode=2) => pcl
    func genstring(ichar s) => pcl
    func genpcstrimm(ichar s) => pcl
    func genlabel(i64 a) => pcl
    func genmem(psymbol d) => pcl
    func genmemaddr(psymbol d) => pcl
    func gendata(ref u8 s,i64 length) => pcl
    proc gencomment(ichar s)
    func genname(ichar s) => pcl
    func gennameaddr(ichar s) => pcl
    func genassem(ref void code) => pcl
    func strpmode(i64 mode,size=0) => ichar
    proc pc_setmode(i64 m,size=0)
    proc pc_setmode2(i64 m)
    proc pc_setxy(i64 x,y)
    proc pc_setscaleoff(i64 scale,offset=0)
    proc pc_setoffset(i64 offset)
    proc pc_addoffset(i64 offset)
    proc pc_setincr(i64 n)
    proc pc_setnargs(i64 n)
    proc pc_setnvariadics(i64 n)
    proc pc_setalign(i64 n)
    func getbasename(ichar s) => ichar
    proc pc_addsymbol(psymbol d)
    func pc_makesymbol(ichar s,i64 id) => psymbol
    proc pc_addplib(ichar name)
    proc pc_defproc(psymbol d,i64 mode=0,isentry=0,threaded=0)
    proc pc_setimport(psymbol d)
    proc pc_addparam(psymbol d)
    proc pc_addlocal(psymbol d)
    proc pc_endproc()
    func addstr(ichar s,t) => ichar
    proc merror(ichar mess,param="")
    func pc_duplpst(psymbol d) => psymbol
    proc pcl_cmdskip(i64 cmdskip,psymbol dcmdskip=nil)
    func convertstring(ichar s,t) => i64
    proc pcl_reducetest()
    proc pcl_runpcl()
    proc mclinit(i64 bypass=0)
    proc genmc(i64 opcode,mclopnd a=nil,b=nil)
    proc genmc_cond(i64 opcode,cond,mclopnd a=nil,b=nil)
    func mgenindex(i64 areg=0,ireg=0,scale=1,offset=0,size=0,labno=0,psymbol def=nil) => mclopnd
    func mgenstring(ichar s,i64 length=-1) => mclopnd
    func mgenint(i64 x,mode=10) => mclopnd
    func mgenrealimm(r64 x,i64 mode=2) => mclopnd
    func mgenlabel(i64 x=0) => mclopnd
    func mgenmem(psymbol d,i64 mode=6) => mclopnd
    func mgenmemaddr(psymbol d) => mclopnd
    func mgenxreg(i64 xreg,size=8) => mclopnd
    func mgenreg(i64 reg,mode=10) => mclopnd
    func ispoweroftwo(i64 x) => i64
    proc callproc(ichar cpname,name,i64 lineno)
    func getassemstr() => ref strbuffer
    func writessdata(i64 fexe) => ref strbuffer
end

=== pc_api.m 0 0 28/108 ===
EXPORT INT PCLSEQNO
int STSEQNO

export pcl pcstart			!start of pcl block
export pcl pccurr			!point to current pcl op
export pcl pcend			!point to last allocated pclrec
global int pcalloc			!number of pclrecs allocated
byte pcfixed				!whether code is fixed up
int pcseqno
int pcneedfntable			!whether kgetnprocs etc are used

int initpcalloc=65536

const pcelemsize = pclrec.bytes

global ichar longstring					!used in stropnd
global int longstringlen

export int mlabelno
export byte phighmem
export byte pfullsys
global byte fpshortnames

export ref proc (ref void) idomcl_assem
export ref func (ref void)int icheckasmlabel
export ref func (int)psymbol igethostfn


!PROC START=
!!CPL "PCL API", PCLEXTRA[KSETARG]
!CPL "PCL API", PCLNAMES.LEN
!CPL "PCL API", PSTREC.BYTES
!END



export func pcl_start(ichar name=nil, int nunits=0)psymbol=
!returns a descriptor to the global tables
!at the moment little is done with the descriptor, except to have something
!tangible to pass back to the caller of the API. There is no mechanism
!to allow multiple, active sets of pcltables

!CPL =PSTREC.BYTES

	if pcldone then pclerror("PCL start?") fi

	if name then
		currprog:=pc_makesymbol(name, program_id)
	fi

	pcalloc:=initpcalloc

	if nunits then				!use approx alloc of 10% more
		nunits:=nunits*9/8		!approx expected number of pcl ops
		while pcalloc<nunits do
			pcalloc*:=2
		od
	fi

	pcstart:=pcm_allocz(pcalloc*pcelemsize)
	pcend:=pcstart+pcalloc-8

	pccurr:=pcstart-1
	pcfixed:=0
	pcseqno:=0
	pcneedfntable:=0

	mlabelno:=0

	currprog

end

export proc pcl_end=
	if pccurr>=pccurr and pccurr.opcode<>kendprog then
		pc_gen(kendprog)
	fi	
	pcldone:=1
end

export func pcl_writepcl(ichar filename=nil)ichar=
	ref strbuffer d

	d:=writeallpcl()

	if filename then
		if pverbose then println "Writing PCL", filename fi
		writefile(filename, d.strptr, d.length)
		""
!		nil
	else
		d.strptr
	fi
end

export func pcl_writepst(ichar filename=nil)ichar=
	ref strbuffer d

	d:=writepst()

	if filename then
		if pverbose then println "Writing PST", filename fi
		writefile(filename, d.strptr, d.length)
		""
	else
		d.strptr
	fi
end

export proc pcl_genmcl=
	genmcl()
end

export proc pcl_genss(int obj=0)=
	genmcl()
	genss(obj)
end

export func pcl_writess(ichar filename=nil, int obj=0)ichar =
	ref strbuffer ssstr
	filehandle f

	genmcl()
	genss(obj)

!CPL "WRITESS"


	ssstr:=writessdata(not obj)

	if filename then
		f:=fopen(filename, "w")
		gs_println(ssstr, f)
		fclose(f)

		gs_free(ssstr)
		nil
	else
		ssstr.strptr
	fi
end

export func pcl_writeasm(ichar filename=nil, int atype='AA')ichar=
	ref strbuffer asmstr
	filehandle f

!	if assemtype<>atype then
!		pclerror("Wrong ASM Module")
!	fi

	if assemtype='NASM' then
		phighmem:=2
	fi

	genmcl()

	asmstr:=getassemstr()

	if filename then
!CPL "WRITEASM/FILE"
		if pverbose then println "Writing", filename fi

		f:=fopen(filename, "w")
		gs_println(asmstr, f)
		fclose(f)

		gs_free(asmstr)
		nil
	else
!CPL "WRITEASM/STR"
		asmstr.strptr
	fi
end

export proc pcl_writeobj(ichar filename)=
!	phighmem:=2

	genmcl()
	genss(1)

	int tt:=os_clock()
	writecoff(filename)
	objtime:=os_clock()-tt
end

export proc pcl_writedll(ichar filename)=
	phighmem:=2
	genmcl()
	genss()
	int tt:=os_clock()
	writeexe(filename, 1)
	exetime:=os_clock()-tt
end

export proc pcl_writeexe(ichar filename)=

!CPL "WX", $LINENO
	genmcl()
!CPL "WX", $LINENO

	genss()

	int tt:=os_clock()
!CPL "WX", $LINENO
	writeexe(filename, 0)
!CPL "WX", $LINENO
	exetime:=os_clock()-tt
end

export proc pcl_writemx(ichar filename)=
	genmcl()
	genss()
	writemcx(filename)
end

!export proc pcl_writeclang(ichar filename)=
!	writeclang(filename)
!end

export proc pcl_exec=
!	pcmdskip:=cmdskip
	genmcl()
	genss()
	runlibfile("dummy", pcmdskip)
end

export proc pcl_setflags(int highmem=-1, verbose=-1, shortnames=-1) =

	if highmem>=0 then phighmem:=highmem fi

	if verbose>=0 then pverbose:=verbose fi
	if shortnames>=0 then fpshortnames:=shortnames fi
end

proc extendpclblock=
	int newpcalloc, lengthused
	pcl newpcstart

	newpcalloc:=pcalloc*2
	lengthused:=pccurr-pcstart+1

	newpcstart:=pcm_alloc(pcelemsize*newpcalloc)

	memcpy(newpcstart, pcstart, lengthused*pcelemsize)
	pcm_clearmem(newpcstart+lengthused, (newpcalloc-lengthused)*pcelemsize)

	pccurr:=newpcstart+(pccurr-pcstart)
	pcend:=newpcstart+newpcalloc-8

	pcm_free(pcstart, pcalloc*pcelemsize)

	pcstart:=newpcstart
	pcalloc:=newpcalloc
end

global func newpcl:pcl =
	if pccurr>=pcend then
		extendpclblock()
	fi

	++pccurr

	pccurr.pos:=mmpos
	PCCURR.SEQNO:=++PCLSEQNO

++NPCL

	return pccurr
end

export proc pc_gen(int opcode, pcl p=nil) =
	if p=nil then
		p:=newpcl()
	fi

	p.opcode:=opcode
end

export proc pc_genix(int opcode, scale=1, offset=0) =
!originally intended for combinations of ptr ops to be combined into
!previous ones, but that has now been dropped.
!Instead any such reductions will be done in a separate pass, much simpler
	pcl p

	p:=newpcl()

	p.opcode:=opcode
	p.scale:=scale
	p.extra:=offset
end

export proc pc_genx(int opcode, int x, pcl p=nil) =

	if p=nil then
		p:=newpcl()
	fi

	p.opcode:=opcode
	p.x:=x
end

export proc pc_genxy(int opcode, int x, y, pcl p=nil) =

	if p=nil then
		p:=newpcl()
	fi

	p.opcode:=opcode
	p.x:=x
	p.y:=y
end

export proc pc_gencond(int opcode, cond, pcl p=nil) =

	if p=nil then
		p:=newpcl()
	fi

	p.opcode:=opcode
	p.condcode:=cond
end

export func genint(int a)pcl p=
	p:=newpcl()
	p.value:=a
	p.opndtype:=int_opnd
	return p
end

export func genreal(real x, int mode=tpr64)pcl p=
	p:=newpcl()
	p.xvalue:=x
	p.opndtype:=(mode=tpr64|real_opnd|r32_opnd)
	return p
end

export func genrealimm(real x, int mode=tpr64)pcl p=
	p:=newpcl()
	p.xvalue:=x
	p.opndtype:=(mode=tpr64|realimm_opnd|realimm32_opnd)
!CPL "GENREALIMM", OPNDNAMES[P.OPNDTYPE], STRPMODE(MODE)
	return p
end

export func genstring(ichar s, int length=-1)pcl p=
!export func genstring(ichar s, int length)pcl p=
	p:=newpcl()

	if length<0 then
		length:=strlen(s)+1
	fi

	p.svalue:=pcm_copyheapstringn(s,length)		!will add an extra zero
	p.opndtype:=string_opnd
!	p.size:=length
	p.slength:=length
!CPL "GENSTRING",=LENGTH, P.SIZE, =P
	return p
end

export func genpcstrimm(ichar s)pcl p=
	p:=newpcl()
	p.svalue:=pcm_copyheapstring(s)
	p.opndtype:=strimm_opnd

	return p
end

export func genlabel(int a)pcl p=
	p:=newpcl()
	p.labelno:=a

	p.opndtype:=label_opnd
	return p
end

export func genmem(psymbol d)pcl p=

	p:=newpcl()

	p.def:=d

	p.opndtype:=mem_opnd
	return p
end

export func genmemaddr(psymbol d)pcl p=
	p:=newpcl()
	p.def:=d

	p.opndtype:=memaddr_opnd
	return p
end

export func gendata(ref byte s, int length)pcl p=
	p:=newpcl()
	p.svalue:=s			! assume already saved on heap
	p.opndtype:=data_opnd
	p.mode:=tpblock
	p.size:=length

	return p
end

export proc gencomment(ichar s)=
	return when fregoptim or fpeephole		!will get skipped anyway
!	RETURN WHEN DOREDUCE			!comments suppressed as they get in the way
!STATIC INT CCC
!CPL "COMMENT", ++CCC
	pc_gen(kcomment, genpcstrimm(s))
end

export func genname(ichar s)pcl=
	return genmem(pc_makesymbol(s, misc_id))
end

export func gennameaddr(ichar s)pcl=
	return genmemaddr(pc_makesymbol(s, misc_id))
end

export func genassem(ref void code)pcl p=
	p:=newpcl()
	p.asmcode:=code
	p.opndtype:=assem_opnd
	return p
end

EXPORT func strpmode(int mode, size=0)ichar=
	static [32]char str

	strcpy(str, "")

	case mode
	when tpblock then
		strcpy(str, "mem:")
		strcat(str, strint(size))
		str
	when tpvoid then
		"---"
	else
		pstdnames[mode]
	esac
end

export proc pc_setmode(int m, size=0)=
	pccurr.mode:=m

	if size then
		pccurr.size:=size
	else
		pccurr.size:=psize[pccurr.mode]
	fi

	if pclhastype[pccurr.opcode]=2 then
		pccurr.mode2:=pccurr.mode
	fi
end

export proc pc_setmode2(int m)=
	pccurr.mode2:=m
end

export proc pc_setxy(int x, y)=
	pccurr.x:=x
	pccurr.y:=y
end

export proc pc_setscaleoff(int scale, offset:=0)=
	pccurr.scale:=scale
	pccurr.extra:=offset
end

export proc pc_setoffset(int offset)=
	pccurr.extra:=offset
end

export proc pc_addoffset(int offset)=
	pccurr.extra+:=offset
end

export proc pc_setincr(int n)=
	pccurr.stepx:=n
end

export proc pc_setnargs(int n)=
	pccurr.nargs:=n
end

export proc pc_setnvariadics(int n)=
	pccurr.nvariadics:=n
end

export proc pc_setalign(int n)=
	pccurr.align:=n
end

global proc perror(ichar mess)=
	perror_s(mess, nil)
end

global proc perror_s(ichar mess, param=nil)=
	print "PCL error:", mess
	if param then
		print ":", param
	fi

	stop 1
end

export func getbasename(ichar s)ichar t=
	t:=s+strlen(s)-1
	while t>s and (t-1)^<>'.' do
		--t
	od

	return t
end

global proc pclerror(ichar mess)=
	println "PCL Error:", mess
	println
	stop 1
end

export proc pc_addsymbol(psymbol d)=
	if psymboltable=nil then
		psymboltable:=psymboltablex:=d
	else
		psymboltablex.next:=d
		psymboltablex:=d
	fi
end

export func pc_makesymbol(ichar s, int id)psymbol d=
!Create a new st entry
!local/param/null-id names are not linked to psymbol table
!all others become part of main ST
!Only local/param have .owner set to currfunc

++NPST
	d:=pcm_allocnfz(pstrec.bytes)
	d.name:=pcm_copyheapstring(s)
	d.seqno:=++stseqno

	case id
	when import_id then
		d.imported:=1
	when export_id then
		d.exported:=1
		id:=proc_id
	esac

	d.id:=id

	if id in [local_id, param_id] then
		d.owner:=currfunc
	elsif id then
		pc_addsymbol(d)
	fi

	d
end

global func getfullname(psymbol d, int backtick=0)ichar=
!create fully qualified name into caller's dest buffer
	static [256]char str
	int n:=0
	psymbol e:=d

!	if fpshortnames then return d.name fi

	str[1]:=0
	if backtick then
		strcpy(str, "`")
	fi

	if d.imported then
		if backtick then
			strcat(str, d.name)
			strcat(str, "*")
		else
			strcat(str, d.name)
		fi
		return str
	fi

	if d.id in [local_id, param_id] then
		strcat(str, d.owner.name)
		strcat(str, ".")
		strcat(str, d.name)
		return str
	fi

	if backtick then
		strcat(str, d.name)
	else
		return d.name
	fi
end

global proc pcerrorstop(ichar filename, int lineno)=
	filehandle f
	f:=fopen("$error.tmp", "w")
	println @f, filename, lineno
	println
	fclose(f)
	stop 1
end

export proc pc_addplib(ichar name)=
	if nplibfiles>=maxplibfile then perror("Too many libs") fi

!CPL "ADDPLIB", NAME

!	plibfiles[++nplibfiles]:=pcm_copyheapstring(name)
	plibfiles[++nplibfiles]:=pcm_copyheapstring(changeext(name, ""))
end

export proc pc_defproc(psymbol d, int mode=tpvoid, isentry=0, threaded=0)=
	pclerror("Nested proc") when currfunc
	pc_gen((threaded|ktcproc|kproc), genmem(d))
	if mode=tpvoid then mode:=d.mode fi
	pc_setmode(mode)

!THIS .PCADDR is a dummy value; any non-nil value shows d is already defined
!A proper .pcaddr is filled in during runp fixup
	if d.pcaddr then pclerror(addstr("Dupl proc:", d.name)) fi
	d.pcaddr:=pccurr

	if entryproc=nil and isentry then
		entryproc:=d
		d.isentry:=1
	fi

	currfunc:=d
end

export proc pc_setimport(psymbol d)=
!allow the use of pc_addlocal
!use d=nil when done

	currfunc:=d
end

export proc pc_addparam(psymbol d)=
	psymbol p:=currfunc, q

	pclerror("No proc") unless p

	q:=p.nextparam

	if q=nil then
		p.nextparam:=d
	else
		while q.nextparam do q:=q.nextparam od		!look for last
		q.nextparam:=d
	fi
	if d.owner=nil then d.owner:=currfunc fi
	++currfunc.nparams

end

export proc pc_addlocal(psymbol d)=
	psymbol p:=currfunc, q

	pclerror("No proc") unless p

	q:=p.nextlocal

	if q=nil then
		p.nextlocal:=d
	else
		while q.nextlocal do q:=q.nextlocal od		!look for last
		q.nextlocal:=d
	fi
	if d.owner=nil then d.owner:=currfunc fi
	++currfunc.nlocals
end

export proc pc_endproc=
	pclerror("No proc") unless currfunc
	pc_gen(kendproc)
	currfunc:=nil
end

export func addstr(ichar s, t)ichar=
static [256]char str
	strcpy(str, s)
	strcat(str, t)
	str
end

EXPORT proc merror(ichar mess, ichar param="")=
	int lineno
	ichar filename, sourceline

	if igetmsourceinfo then
		lineno:=igetmsourceinfo(mmpos, filename, sourceline)
		CPL =LINENO
		CPL =FILENAME
	else
		lineno:=0
		filename:="?"
	fi

	if currfunc then
		println "Proc:", currfunc.name
	fi

	fprintln "MCL Error: # (#) on Line: # in #, PCL:#", mess, param, lineno, filename, ppseqno

	pcerrorstop(filename, lineno)
end

export func pc_duplpst(psymbol d)psymbol e=
	e:=pcm_allocnfz(pstrec.bytes)
	e^:=d^
!*!	e.generic:=d			!assume d is the original
	e.seqno:=++stseqno

	e.next:=nil
	e
end

export proc pcl_cmdskip(int cmdskip, psymbol dcmdskip=nil)=
	pcmdskip:=cmdskip
end

export func convertstring(ichar s, t)int=
!convert string s, that can contain control characters, into escaped form
!return new string in t, so that ABC"DEF is returned as ABC\"DEF
!returns length of t
	int c
	ichar t0:=t
	[16]char str

	while c:=s++^ do
		case c
		when '"' then
			t++^:='\\'
			t++^:='"'
		when 10 then
			t++^:='\\'
			t++^:='n'
		when 13 then
			t++^:='\\'
			t++^:='r'
		when 9 then
			t++^:='\\'
			t++^:='t'
		when '\\' then
			t++^:='\\'
			t++^:='\\'
		when 7, 8, 26, 27 then
			t++^:='<'
			t++^:=c/10+'0'
			t++^:=(c rem 10)+'0'
			t++^:='>'
		elsif c in 32..126 then
			t++^:=c
		else
			t++^:='\\'
			t++^:='x'
			print @str, c:"z2h"
			t++^:=str[1]
			t++^:=str[2]
		esac
	od
	t^:=0

	return t-t0
end

=== pc_decls.m 0 0 29/108 ===
!decls

export type psymbol = ref pstrec

export record pstrec = $caligned
!global record pstrec = $caligned
!global record pstrec =
	ichar name
	psymbol next
	psymbol nextparam
	union
		psymbol nextlocal
		pcl pcdata				!istatics: point to first kdata op
	end
	psymbol owner
	psymbol generic				!locals/params: version in global ST

	ref procinforec info		!procs: info to help codegen	

	union
		pcl pcaddr				!for procs: entry point to function
		ref proc dlladdr		!for imported functions
		ivoid staddr			!var statics: address
		psymbol cprocowner		!C target:var statics: owner proc
	end
	ref fwdrec fwdrefs			!fwd ref chain

	byte id
	byte ksymbol				!0, or _rw code for reserved words (used by pp)
	byte opcode					!for opcode_rw
	byte subcode				!for jumpcc_rw/setcc_rw/type_rw

	i32 offset

	byte imported				!only for import_id
	byte exported				!only for proc_id/static_id
	byte mode
	byte isentry
	u32 size

	byte addrof
	byte nrefs
	byte reg
	byte atvar
	byte used					!0, or 1 to 255 (capped at 255)
	byte reftype
	byte segment
	byte hasdot

	i16 stindex
	i16 importindex
	i32 labelno

	byte flags:(asmused:1, chasstatics:1, dllexport:1)

!	byte asmused				!1 when proc contains asmcode
	byte dllindex				!for dllproc: which dll in dlltable

	byte nretvalues				!function: number of return values (0 for proc)
	byte varparams				!0 or N; variadic params

	byte isthreaded				!
	byte ishandler				!1 if a proc to be part of func tables
	byte ismain					!1 if a proc to be part of func tables
	byte SPARE

!----------------------------------

	byte nparams
	byte variadic				!local function that uses ... variadic params (for C)
	i16 nlocals
	i16 impindex
	i16 expindex
	u32 seqno

end

export type pcl = ref pclrec

EXPORT record pclrec =
!global record pclrec =
	byte opcode
	byte opndtype
	byte condcode						!for jumpcc/setcc
	byte mode

	u32 size

	union
		struct
			union
				i64	value
				r64	xvalue
				ichar	svalue			!also used for data
				int		labelno
				psymbol	def
				ivoid	asmcode
			end

			union						!two 32-bit params used according to opcode
				struct
					i32 x				!common access to these 1/2 extra attribs
					i32 y
				end

				struct					! (x,y) pointer ops
					i32 scale			! scale factor for offset
					i32 extra			! extra constant byte offset, already scaled
				end
				struct					! (x,y) call/etc
					i32 nargs			! number of args
					union
						i32 nvariadics	!call: 0, or arg # that is first variadic
						i32 nrealargs	!setcall: 1 if whole call sequence is simple
					end
				end
				struct					! (x,y) switch
					i32 minlab
					i32 maxlab
				end
				struct					! defproc/retproc/retfn
					i32 paramslots	! stack usage as 8-byte slots
					i32 localslots
				end

				i32 stepx				! (x) always +ve fixed step size for forup/fordown; also INCR
				i32 align
				i32 popone			! (x) jumpcc: leave X on stack
				i32 slicelwb			! (x) for .upb
				i32 inplace			! (x) for load, means &A operand is for inplace update
				u32 slength			! string length: includes any terminator

			end
		end
	end

	u32 pos:(sourceoffset:24, fileno:8)
	i32 dummy:(mode2:8, seqno:24)
![96]BYTE XXXX
end

export record fwdrec =
	ref fwdrec nextfwd
	i32 offset
	i16 reltype
	i16 seg
end

export type procinfo = ref procinforec

export record procinforec =
	byte pcldepth			!max pcl opnd depth (will include high-args)
	byte nparams			!copy of info in pstrec; may exclude not used?
	byte nlocals
	byte isleaf				!1 when there are no calls (explicit or implicit)
	byte nmaxargs			!0, or maxargs of any call (may be capped at 4)
	byte assemused			!1 if inline assembly used (can't optimise)
	byte mcldone			!
	byte hasblocks			!whether block modes are used (that means copyblock etc)
end

global procinfo pinfo

!global int frameoffset
!global int paramoffset
!global int framebytes

global const maxparams=32
global const maxlocals=256


!global int usedparams			!how many of pregs needed for used incoming params
!global int usedxparams			!how many of pxregs needed for used incoming params
!
!global int highreg				!highest D-reg used
!global int highxreg				!highest X-reg used
global int bspill, bxspill		!no. to spill
!global int bxspilloffset		!base frame offset of bxreg spill area

global byte r10used				!these may be set in pass2 when occupied by params
global byte r11used

!global int maxregvars			!how many locals would qualify for regvars
!global int maxxregvars			!how many locals would qualify for xregvars

global byte localshadow			!1 if local, proc-wide shadow space used for a call

export int mmpos

global psymbol psymboltable, psymboltablex

global psymbol currprog
export psymbol currfunc
global psymbol blockretname
global psymbol entryproc		!entry point function

strbuffer sbuffer
global ref strbuffer pdest=&sbuffer

global const maxplibfile=50
global [maxplibfile]ichar plibfiles
global [maxplibfile]u64 plibinst
global int nplibfiles

export ref func (int pos, ichar &filename, &sourceline)int igetmsourceinfo

global byte pcldone, mcldone, ssdone, objdone, exedone

export byte pverbose
global int pcmdskip
!global psymbol pdcmdskip			!reference to $cmdskip symbol

export int assemtype='AA'

GLOBAL INT PPSEQNO

!!GLOBAL CONST DOREDUCE=1
!GLOBAL CONST DOREDUCE=0

GLOBAL CONST REDUCELABELS=1
!GLOBAL CONST REDUCELABELS=0

export byte fpeephole = 1
export byte fregoptim = 1
export byte fnoconst  = 0
export byte fshowil   = 0
export byte flong64   = 0

export int pcltime,mcltime, sstime, objtime, exetime

EXPORT ICHAR $PMODULENAME

EXPORT [PCLNAMES.BOUNDS]INT PCLFLAGS

EXPORT INT PSTARTCLOCK

!export const ctarget=0
EXPORT INT NPCL
EXPORT INT NPST

=== pc_diags.m 0 0 30/108 ===
!const fshowppseqno=1
const fshowppseqno=0

strbuffer sbuffer
ref strbuffer dest=&sbuffer
int destlinestart

const tab1="    "
const tab2="        "

!const fshowsymbols=1
const fshowsymbols=0

global proc strpcl(pcl p)=
	[256]char str
	int opcode, n,x,y
	psymbol d, e

	const showformatted=1

	opcode:=p.opcode
!CPL "STRPCL", PCLNAMES[OPCODE], OPNDNAMES[P.OPNDTYPE], P.SIZE


!	if fshowppseqno then
!		psstr(strint(p.seqno,"z5"))
!		psstr("  ")
!	fi

!PSSTR("<PCL>")
!PSSTR(OPNDNAMES[P.OPNDTYPE])

!psstr(strint(getlineno(p.pos),"4"))
!psstr(" ")

	case opcode
	when klabel then
		strlabel(p.labelno,1)

		IF P.POPONE THEN
			PSSTR(" NOT USED")
		FI

		return
	when klabeldef then
		psstr("! ")
		psstr(p.def.name)
		psstr(":")
		return
	when kcomment then
		if p.svalue^ then
			psstr("!")
			psstr(p.svalue)
		ELSE
			PSSTR("! - - -")
		fi
		return
	when kproc, ktcproc then
		d:=p.def

!		showprocinfo(d)

		if opcode=ktcproc then
			psstr("tcproc")
		else
			psstr("proc")
		fi

		psstr(" ")
		psname(d)

		psstr((p.def.exported|"::"|":"))
		if d.isentry then psstr(":") fi

		psline()

		e:=d.nextparam

		while e, e:=e.nextparam do
			if fshowppseqno then psstr("       ") fi
			psstr(tab1+"param    ")
			psstr(strpmode(e.mode, e.size))
			psstr("       ")
			psstr(e.name)
			psline()
		od

		e:=d.nextlocal
		while e, e:=e.nextlocal do
			if fshowppseqno then psstr("       ") fi
			psstr(tab1+"local    ")
			psstr(strpmode(e.mode, e.size))
			psstr("       ")
			psstr(e.name)
			psline()
		od

		if p.mode then
			if fshowppseqno then psstr("       ") fi
			psstr(tab1+"rettype  ")
			psstr(strpmode(P.mode))
			psline()
		fi

		if d.variadic then
			psstrline(tab1+"variadic")
		fi

		return

	when kendproc then
		psstr("endproc")
		psline()
		return

	when kendprog then
		psstr("endprog")
		return

	when kdata then

		if p.mode=tpblock then
			psdata(p)
			return
		fi

	when kistatic, kzstatic then
		skiptab

	esac

	psstr(tab1)
skiptab:


	case opcode
	when kjumpcc then
		strcpy(str, "jump")
		strcat(str, ccnames[p.condcode])
!		if p.popone then
!			strcat(str, "/1")
!		fi
	when ksetcc then
		strcpy(str, "set")
		strcat(str, ccnames[p.condcode])
	else
		strcpy(str, pclnames[opcode])
	esac

	gs_leftstr(dest,str,9)

	str[1]:=0
	if p.mode then
		strcat(str, strpmode(p.mode, p.size))

		if pclhastype[opcode]=2 then
			strcat(str, "/")
			strcat(str, strpmode(p.mode2))
		fi
		STRCAT(STR, " ")
	fi
	gs_leftstr(dest,str,4)

	str[1]:=0
	n:=pclextra[opcode]
	if n then
		x:=p.x; y:=p.y
		if x or n=2 then			!don't show single 0 value
			strcat(str, "/")
			strcat(str, strint(p.x))
		fi

		if n=2 and y then
			strcat(str, "/")
			strcat(str, strint(y))
		fi
		STRCAT(STR, " ")
	fi	
	gs_leftstr(dest,str,5)

	if p.opndtype<>no_opnd then
		psstr(" ")
!		psstr(stropnd(p))
		psopnd(p)
	fi
	pstabto(40)

	if fshowppseqno then
		psstr("! ")
		psstr(strint(p.seqno,"z5"))
		psstr("  ")
	fi
end

func stropnd(pcl p)ichar=
	static[512]char str
!	static[32]char str
	int length
	psymbol d
	static ichar longstring

	if p=nil then
		return ""
	fi

	str[1]:=0

	case p.opndtype
	when int_opnd then
		return strint(p.value)
	when real_opnd, realimm_opnd, realimm32_opnd, r32_opnd then
!RETURN "<REAL>"
!CPL "HERE"
		if p.xvalue=infinity then
!CPL "INF"
!			fprint @str,"0x#",word@(p.xvalue):"h"
			fprint @str,"infinity"
		else
			print @str,p.xvalue:"e16.16"
		fi

!	when r32_opnd then
!		print @str, p.xvalue

!	when realimm_opnd, realimm32_opnd THEN
!		print @str,p.xvalue
!STRCAT(STR, OPNDNAMES[P.OPNDTYPE])


	when string_opnd then
		length:=p.slength
		if length<str.len/2 then
			strcpy(str,"""")
			convertstring(p.svalue, &str[1]+1)
			strcat(str,"""")

			STRCAT(STR, "*")
			STRCAT(STR, STRINT(P.SLENGTH))

		else

			if longstring then
				pcm_free(longstring,longstringlen)
			fi
			longstringlen:=length*2
			longstring:=pcm_alloc(longstringlen)
			longstring^:='"'
			length:=convertstring(p.svalue, longstring+1)
			(longstring+length+1)^:='"'
			(longstring+length+2)^:=0
			return longstring
		fi

	when mem_opnd then
		d:=p.def
		strcat(str, p.def.name)

		if p.opcode in [kistatic, kzstatic] then
			strcat(str,":")
			if d.exported then
				strcat(str,":")
			fi
		fi

	when memaddr_opnd then
		strcpy(str, "&")
		recase mem_opnd

	when label_opnd then
		fprint @str,"## ","#",p.labelno

	when no_opnd then
		return ""

	when assem_opnd then
		return strint(int(p.asmcode))

	when data_opnd then
		fprint @str,"<Data * # (#)>", p.size,p.svalue

	else
		println "---------",OPNDNAMES[P.OPNDTYPE]
		return "<PCLOPND?>"
	esac

	return str
end

proc psopnd(pcl p)=
	[512]char str
	int length
	psymbol d
	static ichar longstring
	ichar ss

	if p=nil then
		return
	fi

	case p.opndtype
	when int_opnd then
		psint(p.value)
	when real_opnd, realimm_opnd, realimm32_opnd, r32_opnd then
		if p.xvalue=infinity then
			fprint @str,"infinity"
		else
			print @str,p.xvalue:"e16.16"
		fi
		psstr(str)

	when string_opnd then
		length:=p.slength
		if length<str.len/2 then
			psstr("""")
			newconvertstring(p.svalue, str, length)

			psstr(str)
			psstr("""*")
			psint(p.slength)

		else

			if longstring then
				pcm_free(longstring,longstringlen)
			fi
			longstringlen:=length*2
			longstring:=pcm_alloc(longstringlen)
			longstring^:='"'
			length:=convertstring(p.svalue, longstring+1)
			(longstring+length+1)^:='"'
			(longstring+length+2)^:=0
PSSTR(LONGSTRING)
!			return longstring
		fi

	when mem_opnd then
		d:=p.def
		psstr(p.def.name)

		if p.opcode in [kistatic, kzstatic] then
			psstr(":")
			if d.exported then
				psstr(":")
			fi
		fi

	when memaddr_opnd then
		psstr("&")
		recase mem_opnd

	when label_opnd then
		fprint @str,"## ","#",p.labelno
		psstr(str)

	when no_opnd then
		return

	when assem_opnd then
		psint(int(p.asmcode))

	when data_opnd then
		fprint @str,"<Data * # (#)>", p.size,p.svalue
		psstr(str)

	else
		psstr("<PCLOPND?>")
	esac
end

global func strpclstr(pcl p, int buffsize)ichar=
	gs_free(dest)
	gs_init(dest)
	destlinestart:=0
	strpcl(p)
	gs_char(dest,0)

	if dest.length>=buffsize then return "<BIGSTR>" fi

	dest.strptr
end

global proc writepcl(pcl p)=

	strpcl(p)
	case p.opcode
	when kproc then
	else
		gs_line(dest)
	esac


end

global func writeallpcl:ref strbuffer=
!write all pcl code in system by scanning all procs
!pcl code is only stored per-proc
	pcl p
	psymbol d

	gs_init(dest)
	destlinestart:=dest.length

	gs_strln(dest, "!PROC PCL")

	for i to nplibfiles do
		psstr("addlib    """)
		psstr(plibfiles[i])
		psstr("""")
		psline()
	od
	psline() when nplibfiles

	d:=psymboltable
	while d, d:=d.next do
		if d.id=import_id then
			psstr("extproc    ")
			psstr(d.name)
			if d.variadic then
				psstr(" 1")
			fi
			psline()
		fi
	od

	p:=pcstart

	while p<=pccurr do
		writepcl(p)

		destlinestart:=dest.length
		++p
	od

	psline()

	if longstring then
		pcm_free(longstring,longstringlen)
	fi
	return dest
end

global proc psstr(ichar s)=
	gs_str(dest,s)
end

global proc psstrx(ichar s)=
	gs_str(dest,s)
end

global proc psstrline(ichar s)=
	gs_str(dest,s)
	gs_line(dest)
end

global proc psline=
	GS_STR(DEST, "\n")
end

global proc psint(int a)=
	gs_str(dest,strint(a))
end

global proc psname(psymbol d)=
	gs_str(dest, d.name)
end

global proc pstabto(int n)=
	int col:=dest.length-destlinestart
	while n>col do psstr(" "); ++col od
end

global proc strlabel(int labelno,colon=0)=
	psstr("#")
	psint(labelno)
	if colon then
		psstr(":")
	fi
	psstr(" ")
end

proc psdata(pcl p)=
	const perline = 20
	int n:=p.size, m
	ref byte q:=p.svalue

	if n=0 then return fi

	while n>0 do
		m:=n
		if m>=perline then
			m:=perline
		fi
		n-:=m
		psstr(tab1+"data mem:")
		psint(m)
		psstr("  ")
		if m<10 then psstr(" ") fi
		to m do
			psint(q^)
			psstr(" ")
			++q
		od
		if n then
			psline()
		fi
	od
end

global func writepst:ref strbuffer=
	byte localfile:=0
	int i:=0, j
	psymbol d, e

	gs_init(dest)

	psstrline("PROC PC Symbol table")
	psline()

	d:=psymboltable

	while d, d:=d.next do
!		if not d.ksymbol then
PSSTR(STRINT(INT(D),"H"))
PSSTR(" ")
			writepsymbol(d, "25jl")

!			if d.id=proc_id then
			if d.id in [proc_id, import_id] then
				e:=d.nextparam
				j:=0
				while e, e:=e.nextparam do
					psstr("    ")
					writepsymbol(e, "21jl")
				od
				e:=d.nextlocal
				j:=0
				while e, e:=e.nextlocal do
					psstr("    ")
					writepsymbol(e, "21jl")
				od
			fi
PSLINE()
!		fi
	od
	psline()

	return dest
end

proc writepsymbol(psymbol d, ichar fmt)=
	byte localfile:=0
	[256]char str

	print @str, d.seqno:"4", idnames[d.id]
	psstr(str)
	to 8-strlen(idnames[d.id]) do psstr(" ") od

	str[1]:=0

	print @str, d.name:fmt
	psstr(str)

	psstr(strpmode(d.mode, d.size))

	if d.id=proc_id then
		psstr(" Pm:")
		psint(d.nparams)
		psstr(" Loc:")
		psint(d.nlocals)
	fi

	if d.exported then psstr(" Exp") fi
	if d.imported then psstr(" Imp") fi
	if d.varparams then psstr(" Var:"); psint(d.varparams) fi
	if d.isthreaded then psstr(" TC") fi
!*!	if d.reg then psstr(" "); psstr(regnames[d.reg]) fi
	if d.hasdot then psstr(" Dot") fi
	if d.isentry then psstr(" ENTRY PT") fi

	if d.id=proc_id then psstr(" .PCADDR ="); PSSTR(STRINT(CAST(D.PCADDR),"H")) fi

	if d.owner then
		psstr(" (")
		psint(d.owner.seqno)
		psstr(" ")
		psstr(d.owner.name)
		psstr(")")
	fi	

	if ctarget and d.id=static_id and d.cprocowner then
		psstr(" (Proc:")
		psstr(d.cprocowner.name)
		psstr(") (D:")
!		psint(cast(d.pcdata))
		psstr(strint(cast(d.pcdata),"H"))
		psstr(")")
	fi
	if ctarget and d.id=proc_id and d.chasstatics then
		psstr(" Has statics")
!		psint(d.chasstatics)
	fi

	psline()
end

proc showprocinfo(psymbol d)=
	[256]char str
	procinfo p
	psymbol e

	p:=d.info
	return unless p

	fprint @str, "PROC INFO FOR: #", d.name
	psstrline(str)

	fprint @str, "  Params:   #", p.nparams
	psstrline(str)

	fprint @str, "  Locals:   #", p.nlocals
	psstrline(str)

	fprint @str, "  Leaf:     #", p.isleaf
	psstrline(str)

	fprint @str, "  Nmaxargs: #", p.nmaxargs
	psstrline(str)

	fprint @str, "  Assem:    #", p.assemused
	psstrline(str)

	fprint @str, "  MCLdone:  #", p.mcldone
	psstrline(str)

	fprint @str, "  Hasblocks:#", p.hasblocks
	psstrline(str)

	psline()
	e:=d.nextparam
	while e, e:=e.nextparam do
		fprint @str,"  Pm: # used:#, addrof:#",e.name, e.used, e.addrof
		psstrline(str)
	od
	e:=d.nextlocal
	while e, e:=e.nextlocal do
		fprint @str,"  Loc: # used:#, addrof:#",e.name, e.used, e.addrof
		psstrline(str)
	od
	psline()

end

EXPORT func newconvertstring(ichar s, t, int length)int=
!convert string s, that can contain control characters, into escaped form
!return new string in t, so that ABC"DEF is returned as ABC\"DEF
!length is that of s; final length may be up to 4 times as long

!returns actual length of t
	int c
	ichar t0:=t
	[16]char str

	to length do
		case c:=s++^
		when '"' then
			t++^:='\\'
			t++^:='"'
		when 10 then
			t++^:='\\'
			t++^:='n'
		when 13 then
			t++^:='\\'
			t++^:='r'
		when 9 then
			t++^:='\\'
			t++^:='t'
		when '\\' then
			t++^:='\\'
			t++^:='\\'
!		when 0 then
!			t++^:='\\'
!			t++^:='x'
!			t++^:='0'
!			t++^:='0'
!		when 7,8,26,27 then
!			t++^:='<'
!			t++^:=c/10+'0'
!			t++^:=(c rem 10)+'0'
!			t++^:='>'
		elsif c in 32..126 then
			t++^:=c
		else
!			t++^:='\\'			!hex
!			t++^:='x'
!			print @str,c:"z2h"
!			t++^:=str[1]
!			t++^:=str[2]

			t++^:='\\'			!octal
!			t++^:='x'
			print @str,c:"z3x8"
			t++^:=str[1]
			t++^:=str[2]
			t++^:=str[3]
		esac
	od

	t^:=0

	return t-t0
end

=== pc_reduce.m 0 0 31/108 ===
export proc pcl_reducetest=
	int nn, seqno, lab, lab2, nargs
	pcl pc, newpc, pcnext, pcnext2, pcproc
	ref[]u16 labelmap
	psymbol pdef
	[maxcalldepth]pcl callstack
	int ncall
	int nprocs:=0, nleaf:=0, nallparams:=0, nalllocals:=0, offset

	nn:=pccurr-pcstart+1

!CPL =REDUCELABELS
	goto skip unless reducelabels

	pc:=pcstart
	labelmap:=pcm_allocz(mlabelno*u16.bytes)

	while pc<=pccurr, ++pc do
		case pc.opcode
		when klabel then				!don't include these
!			labelpclmap[pc.labelno]:=pc			!map labelno to pcl instr
		when kassem then
			if icheckasmlabel then
				lab:=icheckasmlabel(pc.asmcode)		!non-zero means a label number from ast
				if lab then
					++labelmap[lab]
				fi
			fi
!
		else
			if pc.opndtype=label_opnd then
				++labelmap[pc.labelno]
			fi
		esac
	od

skip:
	pc:=pcstart
	newpc:=pcstart-1			!point to last copied instr (none to start)
	seqno:=0

	to nn do
		pcnext:=pc+1

		if nargs:=pclargs[pc.opcode] then
			if nargs=9 then			!explicit calls
				nargs:=pc.nargs
			fi
			pinfo.nmaxargs := max(pinfo.nmaxargs, nargs)
		fi

!		if pc.mode=tpblock and pinfo then pinfo.hasblocks:=1 fi
		if pc.mode=tpblock and pinfo and pc.size<>16 then pinfo.hasblocks:=1 fi

		case pc.opcode
		when kcomment then

		when klabel then
			if not reducelabels then recase else fi
			if labelmap[pc.labelno] then
				recase else
			fi			!else skipped

		when kproc,ktcproc then
			++nprocs
			pdef:=pc.def
			pdef.pcaddr:=newpc+1
			pinfo:=pcm_alloc(procinforec.bytes)
			pdef.info:=pinfo
			pinfo.isleaf:=1
			pinfo.nparams:=pdef.nparams
			pinfo.nlocals:=pdef.nlocals
			nallparams+:=pdef.nparams
			nalllocals+:=pdef.nlocals
			ncall:=0
			pcproc:=newpc+1

			recase else

		when kcallp, kcallf, kicallp, kicallf then
			pinfo.isleaf:=0
			--ncall
			recase else

		when ksetcall then
!			if ncall then
!				for i:=ncall downto 1 do
!					callstack[i].simple:=0
!				od
!			else
!				pc.simple:=1
!			fi
			++newpc
			newpc^:=pc^
			newpc.seqno:=++seqno
			callstack[++ncall]:=newpc

		when kendproc then
			if pinfo.isleaf then ++nleaf fi
			pinfo:=nil

			recase else

		when kassem then
			pinfo.assemused:=1
			recase else

		when kiload, kistore then
			if newpc^.opcode=kaddpx and pc.mode<>tpblock then
				newpc.mode:=pc.mode
				newpc.opcode:=(pc.opcode=kiload|kiloadx|kistorex)
			else
				recase else
			fi

		when kwiden then
			if pcnext.opcode=ktruncate and pc.mode2=pcnext.mode2 then
				++pc				!widen and truncate cancel out
			elsif pcnext.opcode in [kjumpf, kjumpt] then
				pcnext.mode:=pc.mode2			!widen t/u; jumpf t -> jumpf u

			else
				recase else
			fi
		
		when ktruncate then
			if newpc.opcode in [kload, kiload, kiloadx] and newpc.mode=pc.mode2 then
					!truncating to same width (widen has been removed)
			else
				recase else
			fi

		when kload then				!addpx/load imm/addpx -> single addpx
			if pc.opndtype=int_opnd and pcnext.opcode=newpc.opcode=kaddpx then
				newpc.extra +:= pc.value*pcnext.scale+pcnext.extra
				++pc					!skip this load and following addpx
			elsif pcnext.opcode=kunload then
				++pc					!skip load/unload
			else
				recase else
			fi

!		when kaddpx then
!			if newpc.opcode=kload and newpc.opndtype=int_opnd and pcnext.opcode=kload and
!				(pcnext+1).opcode=kaddpx then
!				pcnext2:=pcnext+1
!				pcnext2.extra+:=newpc.value*pc.scale+pc.extra
!				newpc^:=pcnext^				!skip loadimm and 1st addpx
!				pc:=pcnext2					!process next addpx next
!CPL "REDUCE: LOAD IMM/ADDPX/LOAD/ADDPX"
!!CPL "REDUCE: LOAD IMM/ADDPX/LOAD IMM/ADDPX"
!			fi
!
!			recase else

		else
			++newpc
			newpc^:=pc^
			newpc.seqno:=++seqno

			if newpc.opndtype=memaddr_opnd then
				unless newpc.opcode=kload and newpc.inplace then
					newpc.def.addrof:=1
				end
			fi

		esac
!skip:
		++pc
	od

	pccurr:=newpc
	pcm_free(labelmap, mlabelno) when reducelabels
end

=== pc_run.m 0 0 32/108 ===
!PCL Interpreter

!int dotrace=1
int dotrace=0


int dostep=1
!int dostep=0
int go

INT SEQNO

!INT ALLCALLS
!INT LEAFCALLS

pstrec emptyst

CONST INDENT="  "

const dostackcheck = 1
!const dostackcheck = 0

macro getopcode      = pc.opcode
macro getseqno       = pc.seqno
macro steppc         = ++pc
macro getnargs       = pc.nargs
macro getnvars       = pc.nvariadics
macro getnparams     = pc.paramslots
macro getnlocals     = pc.localslots
macro getcond        = pc.condcode
macro getlabel       = labeltable[pc.labelno]
macro getlabel2      = labeltable[(pc+1).labelno]
macro getmode        = pc.mode
macro getmode2       = pc.mode2
macro getsize        = pc.size
macro getscale       = pc.scale
macro getextra       = pc.extra
macro getincr        = pc.stepx
macro getswmin       = pc.minlab
macro getswmax       = pc.maxlab
macro isfloat        = ispfloat(getmode)
macro issigned       = psigned[getmode]

global ref[]pcl labeltable

global macro pcerror(a) = pcerrorx(pc, a)
global macro pcerror2(a,b) = pcerrorx(pc, a,b)

global func dispatch_loop(pcl pcentry, int cmain=0)int=
!	const stacksize = 10'000
	const stacksize = 70'000
	const callstacksize = 10'000
	const pcmask=15

!HEAP VERSION
	ref[]int stack
		ref [stacksize]real		xstack @stack
		ref [stacksize]word		ustack @stack
		ref [stacksize]ref void	pstack @stack

	pcl pc:=pcentry
		ref byte pcb @pc
		u64 pci @pc

	int sp:=0
	int fp:=0
	int		a
		real	x	@a
		r32	sx	@a
		word	u	@a
	ref byte ptr
		ref u8  pu8		@ptr
		ref u16 pu16	@ptr
		ref u32 pu32	@ptr
		ref u64 pu64	@ptr
		ref i8  pi8		@ptr
		ref i16 pi16	@ptr
		ref i32 pi32	@ptr
		ref i64 pi64	@ptr
		ref r32 pr32	@ptr
		pcl newpc		@ptr
		u64 newpci		@ptr

	int		b
		real	y	@b
		r32	sy	@b
		word	v	@b

!	int opc

	ref byte ptrb
	int n
	psymbol d

!STACK VERSION
!	[stacksize]int		stack
!		[stacksize]real		xstack @stack
!		[stacksize]word		ustack @stack
!		[stacksize]ref void	pstack @stack
!
	[callstacksize]u32 callstack
	[callstacksize]psymbol callstackst
	int callsp:=0
	[256]char str

	INT MAG, OLDSP

	macro zz = sp
	macro yy = sp-1
	macro xx = sp-2
	macro ww = sp-3

	stack:=pcm_alloc(stacksize*int.bytes)

	if cmain then
		INT NCMD:=NCMDPARAMS
		REF[0:]ICHAR CMD := CMDPARAMS
		NCMD:=NCMD-PCMDSKIP
		CMD:=CAST(REF BYTE(CMD)+PCMDSKIP*8)
		PSTACK[++SP]:=CMD
		STACK[++SP]:=NCMD+1
		STACK[++SP]:=0
	fi

!HEAP VERSION

	int lastpos:=0, count:=0

IF DOTRACE THEN
	IF NOT DOSTACKCHECK THEN
		ABORTPROGRAM("Need 'dostackcheck=1'")
	FI
	EMPTYST.NAME:="<Fn ptr>"
fi

!!========================================================================
!	do
!
!	if sp>(stacksize-100) then pcerror("Stack overflow") fi
!!	if callsp>(callstacksize-100) then pcerror("Call Stack overflow") fi
!
!!	IF PC.OPCODE=KCALLP AND EQSTRING(PC.DEF.NAME,"debug") THEN DOSTEP:=1;GO:=0 FI
!	goto skip when pc.opcode in [kcomment, ksetarg, klabel]
!	goto skip when not dostep
!
!
!!	ichar filename, sourceline
!!	int lineno
!
!!	if igetmsourceinfo then
!!		if pc.pos<>lastpos then
!!			lineno:=igetmsourceinfo(pc.pos, &filename, &sourceline)
!!			lastpos:=pc.pos
!!		fi
!!		CPL "Line",lineno:"4","in", filename
!!	fi
!
!++count
!	CPL count:"3",=pc, pc.seqno:"z4", PCLNAMES[GETOPCODE]:"9JL", strpmode(pc.mode, pc.size), opndnames[pc.opndtype], =SP, =FP
!
!!	CPL pc.seqno:"z4", PCLNAMES[GETOPCODE]:"9JL", strpmode(pc.mode, pc.size), opndnames[pc.opndtype], =SP, =FP
!!	if sp then
!!		for i in max(1, sp-10)..sp do
!!			print  i:"9"
!!		od
!!		println
!!		for i in max(1, sp-10)..sp do
!!!			print  stack[i]:"9"
!!!			print  "<",,stack[i]:"9",,"> "
!!			print stack[i]:"H9"
!!		od
!!		println
!!	fi
!
!!	print callsp,"Callstack:"
!!	for i in max(1,callsp-20).. callsp do
!!		fprint "#:# ", i, callstack[i]
!!	od
!!	println
!
!	if not go then
!		CASE OS_GETCH()
!		WHEN 27 THEN STOP
!		WHEN 'R','r' THEN DOSTEP:=0
!		WHEN 'G','g' THEN go:=1
!		ESAC
!	fi
!skip:
!
!	switch getopcode
!!========================================================================

!CPL "NEW PC RUN"
!
!
!	doswitch getopcode
	doswitchu getopcode
!	docase getopcode

	when knop      then
		steppc

	when kload     then
		if pc.opndtype=int_opnd then
			stack[++sp]:=pc.value
		else
			stack[++sp]:=pci_getopnd(pc, &stack[fp])
		fi
		steppc

	when kiload    then
		stack[sp]:=pci_loadptr(pstack[sp], getmode)
		steppc

	when kiloadx   then
		a:=stack[sp--]				!index
		ptr := ref byte(pstack[sp]) + a*getscale + getextra
		stack[sp]:=pci_loadptr(ptr, getmode)
		steppc

	when kstore    then
		case pc.opndtype
		when mem_opnd then

			d:=pc.def
			if d.id=static_id then
				pi64:=d.staddr
			elsif getmode=tpblock and d.id=param_id then
				pi64:=pstack[fp+d.offset]
			else
				pi64:=&stack[fp+d.offset]
			fi
			pci_storeptr(ptr, stack[sp--], getmode, getsize)

		else
			pcusopnd(pc)
		esac
		
		steppc

	when kistore   then
		ptr:=pstack[sp--]
		pci_storeptr(ptr, stack[sp--], getmode, getsize)
		steppc

	when kistorex  then
		a:=stack[sp--]				!index
		ptr := ref byte(pstack[sp--]) + a*getscale + getextra
		pci_storeptr(ptr, stack[sp--], getmode, getsize)
		steppc

	when kdupl, kdouble   then
		a:=stack[sp]
		stack[++sp]:=a
		steppc

	when kswapstk  then
		swap(stack[sp-(pc.x-1)], stack[sp-(pc.y-1)])
		steppc

	when kunload   then
		--sp
		steppc

	when kopnd     then
		unimpl
		steppc

	when ktype     then
		unimpl
		steppc

	when kloadbit  then	! Z' := Y.[Z]
		stack[sp-1]:=stack[sp-1].[stack[sp]]
		--sp
		steppc

    when kloadbf   then	! Z' := X.[Y..Z]
		a:=pci_loadbf(stack[xx], stack[yy], stack[zz])
		sp-:=2
		stack[sp]:=a
		steppc

	when kstorebit then	! Y^.[Z] := X
		ptr:=pstack[yy]
		a:=pci_loadptr(ptr, getmode)
		if stack[xx] then			!set bit
			a.[stack[zz]]:=1
		else
			a.[stack[zz]]:=0
		fi

		pci_storeptr(ptr, a, getmode)
		sp-:=3
		steppc

	when kstorebf  then	! X^.[Y..Z] := W
		ptr:=pstack[xx]
		a:=pci_loadptr(ptr, getmode)
		a:=pci_storebf(a, stack[yy], stack[zz], stack[ww])
		pci_storeptr(ptr, a, getmode)
		sp-:=4
		steppc

	when kcallp, kcallf    then
		d:=pc.def
		if dotrace then

IF DOSTACKCHECK THEN
TO CALLSP DO PRINT INDENT OD
FI
!			fprintln "# Call:   # #", ++seqno, d.name, getlineno(pc),=SP,=FP
			fprintln "# Call:   # # SP=# FP=#", ++seqno, d.name, getlineno(pc)
		fi
!++ALLCALLS
!
!IF D.INFO AND D.INFO.ISLEAF THEN
!	++LEAFCALLS
!FI

		if dostackcheck then
			if sp>(stacksize-100) then pcerror("Stack overflow") fi
		fi

		if d.imported then
			n:=getnargs
			sp-:=n-1				!point to first arg
			a:=docalldll(d, nil, cast(&stack[sp]), n, getnvars, getmode)
			if pc.opcode=kcallp then
				--sp
			else
				stack[sp]:=a
			fi
			steppc
		elsif not d.pcaddr then
			pcerror2("Proc not defined:",d.name)
		else
			if dostackcheck then
				callstack[++callsp]:=sp-getnargs+(getopcode=kcallf|1|0)
				callstackst[callsp]:=d
			fi

			stack[++sp]:=int(pc+1) ior getnargs
			pc:=d.pcaddr

		fi

	when kretproc  then

!		if dotrace AND CALLSP IN XXX then
!IF DOSTACKCHECK THEN
!TO CALLSP-1 DO PRINT INDENT OD
!FI
!			fprintln "# Return: # #", seqno, callstackst[callsp].name, getlineno(pc),=SP, =FP
!		fi
!
		n:=getnparams
		sp-:=getnlocals
		fp:=stack[sp--]

		if dostackcheck then
			newpc:=pstack[sp--]
			sp-:=newpci iand pcmask
			if callsp<1 then pcerror("retp/call underflow") fi
			oldsp:=callstack[callsp--]
			if sp<>oldsp then
				fprint @str,"RETP/SP mismatch: old=# curr=# ",oldsp, sp
				pcerror(str)
			fi

			pci:=newpci iand inot pcmask

		else
			pc:=pstack[sp--]
			sp-:=pci iand pcmask
			pci iand:=inot pcmask

		fi

	when kretfn    then

!		if dotrace AND CALLSP IN XXX then
!IF DOSTACKCHECK THEN
!TO CALLSP-1 DO PRINT INDENT OD
!FI
!			fprintln "# Return: # #", seqno, callstackst[callsp].name, getlineno(pc),=SP,=FP
!		fi
!
		a:=stack[sp]
		n:=getnparams
		sp-:=getnlocals
		fp:=stack[--sp]

		if dostackcheck then
			newpc:=cast(stack[--sp])
			sp-:=newpci iand pcmask
			stack[sp]:=a

			if callsp<1 then pcerror("ref/call underflow") fi
			oldsp:=callstack[callsp--]
			if sp<>oldsp then
				fprint @str,"RETF/SP mismatch: old=# curr=# ", oldsp, sp
				pcerror(str)
			fi
			pci:=newpci iand inot pcmask
		else
			pc:=cast(stack[--sp])
			sp-:=pci iand pcmask
			stack[sp]:=a
			pci iand:=inot pcmask
		fi

	when kicallp   then
!		if dotrace then
!			fprintln "# Call:   <fn_ptr> #", ++seqno, getlineno(pc)
!		fi

		ptr:=pstack[sp]
IF PTR=NIL THEN PCERROR("ICALLP NIL PTR") FI


		if newpc>=pcstart and newpc<=pccurr then		!assume local
icallp:
			if dostackcheck then
				callstack[++callsp]:=SP-1-GETNARGS+(GETOPCODE=KICALLF|1|0)
				CALLSTACKST[CALLSP]:=&EMPTYST
			fi
			stack[sp]:=int(pc+1) ior getnargs
			pc:=newpc
		else	
			n:=getnargs
			--sp
			sp-:=n-1
			docalldll(nil, cast(ptr), cast(&stack[sp]), n, getnvars, getmode)
			--sp
			steppc
		fi

	when kicallf   then
!		if dotrace then
!			fprintln "# Call:   <fn_ptr> #", ++seqno, getlineno(pc)
!		fi
		ptr:=pstack[sp]
IF PTR=NIL THEN PCERROR("ICALLF NIL PTR") FI

		if newpc>=pcstart and newpc<=pccurr then		!assume local
			goto icallp
		else	
			n:=getnargs
			--sp
			sp-:=n-1
			a:=docalldll(nil, cast(ptr), cast(&stack[sp]), n, getnvars, getmode)
			stack[sp]:=a
			steppc
		fi


	when kjump     then
		pc:=getlabel

	when kijump    then
		pc:=pstack[sp--]

	when kjumpcc   then
		if ispfloat(getmode) then
			n:=cmpreal(getcond, xstack[sp-1], xstack[sp])
		elsif psigned[getmode] then
			n:=cmpint(getcond, stack[sp-1], stack[sp])
		else
			n:=cmpword(getcond, stack[sp-1], stack[sp])
		fi

		if pc.popone and not n then
			--sp
		else
			sp-:=2
		fi

		if n then
			pc:=getlabel
		else
			steppc
		fi

	when kjumpt    then
		if stack[sp--] then				!ignore possibility of -0.0
			pc:=getlabel
		else
			steppc
		fi

	when kjumpf    then
		if stack[sp--]=0 then
			pc:=getlabel
		else
			steppc
		fi

	when kjumpret  then
		pc:=getlabel

	when kjumpretm then
		unimpl
		steppc

	when ksetcc    then
		case getmode
		when tpr64 then
			pcerror("setcc/r64")
		when tpr32 then
			pcerror("setcc/r32")
		elsif psigned[getmode] then
			n:=cmpint(getcond, stack[sp-1], stack[sp])
		else
			n:=cmpword(getcond, stack[sp-1], stack[sp])
		esac
		--sp
		stack[sp]:=n

		steppc

	when kstop     then
		return stack[sp--]

	when kto       then
		pi64:=pci_getopndaddr(pc+1, &stack[fp])	
		--(pi64^)
		if pi64^ then
			pc:=getlabel
		else
			pc+:=2
		fi

	when kforup    then
		ptr:=cast(pci_getopndaddr(pc+1, &stack[fp]))
		n:=pci_getopnd(pc+2, &stack[fp])
		pi64^+:=pc.stepx
		if pi64^ <= n then
			pc:=getlabel
		else
			pc+:=3
		fi

	when kfordown  then
		ptr:=cast(pci_getopndaddr(pc+1, &stack[fp]))
		n:=pci_getopnd(pc+2, &stack[fp])
		pi64^-:=pc.stepx
		if pi64^ >= n then
			pc:=getlabel
		else
			pc+:=3
		fi


	when kiswap    then
		if getmode=tpblock then pcerror("swap/block") fi
		ptr:=pstack[sp--]
		ptrb:=pstack[sp--]
		a:=pci_loadptr(ptr, getmode)
		b:=pci_loadptr(ptrb, getmode)
		pci_storeptr(ptr, b, getmode)
		pci_storeptr(ptrb, a, getmode)
		steppc

	when kswitch, kswitchu   then
		a:=stack[sp--]
		if a in getswmin..getswmax then
			pc:=getlabel+1+a-getswmin				!get to index swlabel op
			pc:=getlabel					!get dest label from there
		else
			pc:=getlabel2
		fi

	when kswlabel  then
		unimpl
		steppc

	when kendsw    then
		unimpl
		steppc

	when kclear    then
		memset(pstack[sp--], 0, pc.size)
		steppc

	when kassem    then
		unimpl
		steppc

	when kadd      then
		if ispfloat(getmode) then
			xstack[sp-1]+:=xstack[sp]
		else
			stack[sp-1]+:=stack[sp]
		fi
		--sp

		steppc

	when ksub      then
		if ispfloat(getmode) then
			xstack[sp-1]-:=xstack[sp]
		else
			stack[sp-1]-:=stack[sp]
		fi
		--sp

		steppc


	when kmul      then
		if ispfloat(getmode) then
			xstack[sp-1]*:=xstack[sp]
		else
			stack[sp-1]*:=stack[sp]
		fi
		--sp

		steppc

	when kdiv      then
		xstack[sp-1]:=xstack[sp-1]/xstack[sp]
		--sp
		steppc

	when kidiv     then
		if psigned[getmode] then
			stack[sp-1]:=stack[sp-1]/stack[sp]
		else
			ustack[sp-1]:=ustack[sp-1]/ustack[sp]
		fi
		--sp
		steppc

	when kirem     then
		if psigned[getmode] then
			stack[sp-1]:=stack[sp-1] rem stack[sp]
		else
			ustack[sp-1]:=ustack[sp-1] rem ustack[sp]
		fi
		--sp
		steppc

	when kidivrem  then
		unimpl
		steppc

	when kbitand   then
		stack[sp-1] iand:=stack[sp]
		--sp
		steppc

	when kbitor    then
		stack[sp-1] ior:=stack[sp]
		--sp
		steppc

	when kbitxor   then
		stack[sp-1] ixor:=stack[sp]
		--sp
		steppc

	when kshl      then
		ustack[sp-1] <<:= ustack[sp]
		--sp
		steppc

	when kshr      then
		if psigned[getmode] then
			stack[sp-1] >>:= stack[sp]
		else
			ustack[sp-1] >>:= ustack[sp]
		fi	
		--sp
		steppc

	when kmin      then
		if ispfloat(getmode) then
			xstack[sp-1] min:= xstack[sp]
		elsif psigned[getmode] then
			stack[sp-1] min:= stack[sp]
		else
			ustack[sp-1] min:= ustack[sp]
		fi
		--sp
		steppc

	when kmax      then
		if ispfloat(getmode) then
			xstack[sp-1] max:= xstack[sp]
		elsif psigned[getmode] then
			stack[sp-1] max:= stack[sp]
		else
			ustack[sp-1] max:= ustack[sp]
		fi
		--sp
		steppc

	when kaddpx    then
		a:=stack[sp--]				!index
		pstack[sp] := ref byte(pstack[sp]) + a*getscale + getextra
		steppc

	when ksubpx    then
		a:=stack[sp--]				!index
		pstack[sp] := ref byte(pstack[sp]) - a*getscale + getextra
		steppc

	when ksubp     then
		stack[sp-1]:=(stack[sp-1]-stack[sp])/getscale
		--sp
		steppc

	when kneg      then
		if ispfloat(getmode) then
			xstack[sp] := -xstack[sp]
		else
			stack[sp] := -stack[sp]
		fi
		steppc

	when kabs      then
		if ispfloat(getmode) then
			xstack[sp] := abs xstack[sp]
		else
			stack[sp] :=  abs stack[sp]
		fi
		steppc

	when kbitnot   then
		ustack[sp]:=inot ustack[sp]
		steppc

	when knot      then
		stack[sp] := stack[sp] ixor 1
		steppc

	when ktoboolt  then
		stack[sp]:=istrue stack[sp]
		steppc

	when ktoboolf  then
		stack[sp]:=not stack[sp]
		steppc

	when ksqr      then
		if ispfloat(getmode) then
			xstack[sp]*:=xstack[sp]
		else
			stack[sp]:=sqr stack[sp]
		fi

		steppc

	when ksqrt     then
		xstack[sp]:=sqrt(xstack[sp])
		steppc

	when ksin      then
		xstack[sp]:=sin(xstack[sp])
		steppc

	when kcos      then
		xstack[sp]:=cos(xstack[sp])
		steppc

	when ktan      then
		unimpl
		steppc

	when kasin     then
		unimpl
		steppc

	when kacos     then
		unimpl
		steppc

	when katan     then
		xstack[sp]:=atan(xstack[sp])
		steppc

	when klog      then
		xstack[sp]:=log(xstack[sp])
		steppc

	when klog10    then
		unimpl
		steppc

	when kexp      then
		xstack[sp]:=exp(xstack[sp])
		steppc

	when kround    then
		unimpl
		steppc

	when kfloor    then
		unimpl
		steppc

	when kceil     then
		unimpl
		steppc

	when ksign     then
		unimpl
		steppc

	when katan2    then
		unimpl
		steppc

	when kpower    then
		if ispfloat(getmode) then
			xstack[sp-1]:=xstack[sp-1]**xstack[sp]
		else
			stack[sp-1]:=stack[sp-1]**stack[sp]
		fi
		--sp

		steppc

	when kfmod     then
		unimpl
		steppc

	when kincrto   then
		doincr(pstack[sp--], getincr, getmode)
		steppc

	when kdecrto   then
		doincr(pstack[sp--], -getincr, getmode)
		steppc

	when kincrload then
		ptr:=pstack[sp]
		doincr(ptr, getincr, getmode)
		stack[sp]:=pci_loadptr(ptr, getmode)
		steppc

	when kdecrload then
		ptr:=pstack[sp]
		doincr(ptr, -getincr, getmode)
		stack[sp]:=pci_loadptr(ptr, getmode)
		steppc


	when kloadincr then
		ptr:=pstack[sp]
		stack[sp]:=pci_loadptr(ptr, getmode)
		doincr(ptr, getincr, getmode)
		steppc

	when kloaddecr then
		ptr:=pstack[sp]
		stack[sp]:=pci_loadptr(ptr, getmode)
		doincr(ptr, -getincr, getmode)
		steppc

	when kaddto    then		!Z^ +:= Y
		ptr:=pstack[sp--]
		a:=pci_loadptr(ptr, getmode)
		b:=stack[sp--]

		if ispfloat(getmode) then
			a:=int@(real@(a)+real@(b))
		else
			a+:=b
		fi

		pci_storeptr(ptr, a, getmode)
		steppc

	when ksubto    then
		ptr:=pstack[sp--]
		a:=pci_loadptr(ptr, getmode)
		b:=stack[sp--]

		if ispfloat(getmode) then
			a:=int@(real@(a)-real@(b))
		else
			a-:=b
		fi

		pci_storeptr(ptr, a, getmode)
		steppc

	when kmulto    then
		ptr:=pstack[sp--]
		a:=pci_loadptr(ptr, getmode)
		b:=stack[sp--]

		if ispfloat(getmode) then
			a:=int@(real@(a)*real@(b))
		else
			a*:=b
		fi

		pci_storeptr(ptr, a, getmode)
		steppc

	when kdivto, kidivto    then
		ptr:=pstack[sp--]
		a:=pci_loadptr(ptr, getmode)
		b:=stack[sp--]

		if ispfloat(getmode) then
			a:=int@(real@(a)/real@(b))
		else
			a:=a/b
		fi

		pci_storeptr(ptr, a, getmode)
		steppc


	when kiremto   then
		ptr:=pstack[sp--]
		a:=pci_loadptr(ptr, getmode)
		b:=stack[sp--]

		a:=a rem b

		pci_storeptr(ptr, a, getmode)
		steppc

	when kbitandto then
		ptr:=pstack[sp--]
		a:=pci_loadptr(ptr, getmode)
		b:=stack[sp--]
		a iand:=b
		pci_storeptr(ptr, a, getmode)
		steppc

	when kbitorto  then
		ptr:=pstack[sp--]
		a:=pci_loadptr(ptr, getmode)
		b:=stack[sp--]
		a ior:=b
		pci_storeptr(ptr, a, getmode)
		steppc

	when kbitxorto then
		ptr:=pstack[sp--]
		a:=pci_loadptr(ptr, getmode)
		b:=stack[sp--]
		a ixor:=b
		pci_storeptr(ptr, a, getmode)
		steppc

	when kshlto    then
		ptr:=pstack[sp--]
		a:=pci_loadptr(ptr, getmode)
		b:=stack[sp--]
		a<<:=b
		pci_storeptr(ptr, a, getmode)
		steppc

	when kshrto    then
		ptr:=pstack[sp--]
		a:=pci_loadptr(ptr, getmode)
		b:=stack[sp--]
		if psigned[getmode] then
			a>>:=b
		else
			u>>:=v
		fi
		pci_storeptr(ptr, a, getmode)
		steppc

	when kminto    then
		ptr:=pstack[sp--]
		a:=pci_loadptr(ptr, getmode)
		b:=stack[sp--]

		if isfloat then
			a:=int@(min(real@(a),real@(b)))
		elsif issigned then
			a min:=b
		else
			u min:=v
		fi

		pci_storeptr(ptr, a, getmode)
		steppc


	when kmaxto    then
		ptr:=pstack[sp--]
		a:=pci_loadptr(ptr, getmode)
		b:=stack[sp--]

		if isfloat then
			a:=int@(max(real@(a),real@(b)))
		elsif issigned then
			a max:=b
		else
			u max:=v
		fi

		pci_storeptr(ptr, a, getmode)
		steppc

	when kaddpxto  then
		pu64:=pstack[sp--]
		pu64^+:=stack[sp--]*getscale
		steppc

	when ksubpxto  then
		pu64:=pstack[sp--]
		pu64^-:=stack[sp--]*getscale
		steppc

	when knegto    then
		unimpl
		steppc

	when kabsto    then
		unimpl
		steppc

	when kbitnotto then
		unimpl
		steppc

	when knotto    then
		unimpl
		steppc

	when ktoboolto then
		unimpl
		steppc

	when ktypepun  then
!		unimpl
		steppc

	when kfloat    then
		if psigned[getmode2] then
			xstack[sp]:=stack[sp]
		else
			xstack[sp]:=ustack[sp]
		fi
		steppc

	when kfix      then
		stack[sp]:=xstack[sp]
		steppc

	when ktruncate then
		stack[sp]:=pci_loadptr(cast(&stack[sp]), getmode2)
		steppc

	when kwiden    then
		stack[sp]:=pci_loadptr(cast(&stack[sp]), getmode2)
		steppc

	when kfwiden   then				!no-op: value already widened
		steppc

	when kfnarrow  then				!will be narrowed on store
		steppc

	when kstartmx  then
		steppc

	when kresetmx  then
		steppc

	when kendmx    then
		steppc

	when kproc  then					!proc entry code
		stack[++sp]:=fp
		fp:=sp

		sp+:=getnlocals


		if dotrace then
IF DOSTACKCHECK THEN
TO CALLSP DO PRINT INDENT OD
FI
!			fprintln "# Enter:  #", seqno, pc.def.name
			fprintln "# Enter:  # SP=# FP=#", seqno, pc.def.name, SP,FP
		fi

!		if dostackcheck then
!			++sp
!			stack[sp]:=magic + SP-1
!		fi
		steppc

	when ktcproc   then
		unimpl
		steppc

	when kendproc  then
		unimpl
		steppc

	when kistatic  then
		unimpl
		steppc

	when kzstatic  then
		unimpl
		steppc

	when kdata     then
		unimpl
		steppc

	when klabel    then
		steppc

	when klabeldef then
!		unimpl
		steppc

	when ksetjmp   then
		ptr:=pstack[sp]
		pu64^:=cast(pc+1)				!label of next instr
		(pu64+1)^:=sp
		(pu64+2)^:=fp

		stack[sp]:=0

		steppc

	when klongjmp  then
		a:=stack[sp--]					!ret value
		ptr:=pstack[sp--]
		pc:=cast(pi64^)
		sp:=(pi64+1)^
		fp:=(pi64+2)^
		stack[++sp]:=a

	when ksetcall  then
!		IF DOTRACE THEN
!			IF PC.OPNDTYPE=MEM_OPND THEN
!				fprintln "# Call:   # #", ++seqno, pc.def.name, getlineno(pc)
!			ELSE
!				fprintln "# Call:   <FN PTR> #", ++seqno, getlineno(pc)
!			FI
!		fi
		steppc

	when ksetarg   then
!		unimpl
		steppc

	when kloadall  then
		unimpl
		steppc

	when keval     then
		--sp
		steppc

	when kcomment  then
		steppc

	when kendprog  then
		unimpl
		steppc

	when kinitdswx then

	else
unimpl:
		println
CPL =GETOPCODE
		fprintln "Unimpl: # at seq: #", pclnames[getopcode], getseqno
		println
		stop 1
!	end doswitch
	end
!	end end
	0
end

proc fixuppcl=
!allocate memory for statics
	pcl p
	psymbol d,e, dproc
	ref byte pdata
	int parambytes, framebytes
	int paramslots, localslots
	u64 a

	labeltable:=pcm_alloc((mlabelno+1)*pcl.bytes)

!do static fixups in two passes, as sometimes the ordering gets mixed up
!first pass allocates spaces, second deals with initialisation that may include
!references to static data declared later

	p:=pcstart
	while p<=pccurr, ++p do
		case p.opcode
		when kproc, ktcproc then
			p.def.pcaddr:=p
		esac
	od

	p:=pcstart
	while p<=pccurr, ++p do
		case p.opcode
		when kistatic, kzstatic then
			d:=p.def
			d.staddr:=pcm_allocz(p.size)
		esac
	od

	p:=pcstart
	while p<=pccurr, ++p do
		case p.opcode
		when kistatic, kzstatic then
			pdata:=p.def.staddr

		when kdata then
			if p.mode<>tpblock then
				case p.opndtype
				when mem_opnd then
PCERRORX(P,"FIX/DATA/MEM")
				when memaddr_opnd then
					d:=p.def
					case d.id
					when static_id then
						a:=cast(d.staddr)
					when proc_id then
						a:=cast(d.pcaddr)
					when import_id then
						a:=cast(getdllfnptr(d))
					else
						pcerrorx(p,"data &mem")
					esac
					if a=0 then
						pcerrorx(p,"data &mem = nil")
					fi
				else
					a:=p.value
				esac

				memcpy(pdata, &a, p.size)
			else
				memcpy(pdata, p.svalue, p.size)
			fi
			pdata+:=p.size

		when kproc then
			dproc:=d:=p.def
			e:=d.nextparam
			parambytes:=0
			while e, e:=e.nextparam do
				parambytes+:=8
				e.offset:=-(parambytes/8+1)
			od

			e:=d.nextlocal
			framebytes:=0
			while e, e:=e.nextlocal do
				e.offset:=framebytes/8+1
				framebytes+:=roundtoblock(E.size,8)
			od

			p.paramslots:=paramslots:=parambytes/8
			p.localslots:=localslots:=framebytes/8

		when klabel then
			labeltable[p.labelno]:=p

		when kretproc, kretfn then
			p.paramslots:=paramslots
			p.localslots:=localslots

		esac
	od

end

export proc pcl_runpcl=
!	int tt:=os_clock()
	int stopcode

	loadlibs()

	fixuppcl()

!CPL "COMPILE TO PCL:", OS_CLOCK()-PSTARTCLOCK
	if entryproc=nil then
		pcerrorx(pcstart,"No 'main' entry point")
	fi

	docmdskip()

!CPL "RUNPCL", ENTRYPROC.PCADDR
!CPL "RUNPCL", ENTRYPROC.PCADDR.SEQNO
!CPL "RUNPCL", PCLNAMES[ENTRYPROC.PCADDR.OPCODE]
!CPL "RUNPCL", ENTRYPROC.PCADDR.DEF.NAME

	if pverbose then
		println "Run PCL:"
	fi

!CPL "START DISPATCH"

	stopcode:=dispatch_loop(entryproc.pcaddr, entryproc.nparams=2)
!CPL "STOP DISPATCH


!CPL "All Calls: ",ALLCALLS:"12s,"
!CPL "Leaf Calls:",LEAFCALLS:"12s,"

	if pverbose then
		println "Stopped",stopcode
		println
	fi

	stop stopcode
end

func getlineno(pcl pc)int=
	ichar filename, sourceline

	if igetmsourceinfo then
		igetmsourceinfo(pc.pos, filename, sourceline)
	else
		0
	fi
end
=== pc_runaux.m 0 0 33/108 ===


global func pci_getopnd(pcl p, ref i64 locals)i64 a =
!return operand value
!locals is a pointer stack[fp]

	psymbol d
	ref byte         ptr
	ref u8  pu8		@ptr
	ref u16 pu16	@ptr
	ref u32 pu32	@ptr
	ref u64 pu64	@ptr
	ref i8  pi8		@ptr
	ref i16 pi16	@ptr
	ref i32 pi32	@ptr
	ref i64 pi64	@ptr
	ref r32 pr32	@ptr
	ref r64 pr64	@ptr

	case p.opndtype
	when int_opnd then
		a:=p.value

	when mem_opnd then
		d:=p.def
		case d.id
		when static_id then
			pi64:=d.staddr
		else
			pi64:=locals+d.offset
			if d.mode=tpblock and d.id=param_id then pi64:=cast(pi64^) fi
		esac

		a:=pci_loadptr(ptr, p.mode)

	when memaddr_opnd then
		d:=p.def
		case d.id
		when local_id then
			a:=cast(locals+d.offset)
		when param_id then
			a:=cast(locals+d.offset)
			if d.mode=tpblock then			!need value of param not its address
				ptr:=cast(a)				!value contains reference to block
				a:=pu64^
			fi
		when import_id then
			a:=cast(getdllfnptr(d))

		else
			a:=cast(d.staddr)		!also does proc_id/import_id
		esac

	when string_opnd then
		a:=cast(p.svalue)

	when real_opnd, r32_opnd then
		a:=int@(p.xvalue)

	when label_opnd then
		a:=cast(labeltable[p.labelno])

	else
		pcusopnd(p)
	esac

	a
end

global func pci_loadptr(ref byte p, int mode)i64 =
!p points to a primitive or block
!any scaling/offset has been applied

	ref u8  pu8		@p
	ref u16 pu16	@p
	ref u32 pu32	@p
	ref u64 pu64	@p
	ref i8  pi8		@p
	ref i16 pi16	@p
	ref i32 pi32	@p
	ref i64 pi64	@p
	ref r32 pr32	@p
	ref r64 pr64	@p
	real x

	if p=nil then pclerror("Null ptr access") fi

	switch mode
	when tpblock then
		cast(p)

	when tpr64 then
		pu64^
	when tpr32 then
		x:=pr32^				!widen to r64
		int@(x)					!typepun to i64

	when tpi64 then pi64^
	when tpi32 then pi32^
	when tpi16 then pi16^
	when tpi8  then pi8^

	when tpu64 then pu64^
	when tpu32 then pu32^
	when tpu16 then pu16^
	when tpu8  then pu8^
	else
		0
	end
end

global proc pci_storeptr(ref byte p, int a, mode, size=0) =
!p points to a primitive or block
!a represents any value including a real, or a block reference

	ref i8  pi8		@p
	ref i16 pi16	@p
	ref i32 pi32	@p
	ref i64 pi64	@p
	ref r32 pr32	@p
	real x

	if p=nil then pclerror("Null ptr access") fi

	case mode
	when tpblock then
		memcpy(p, ref byte(a), size)

	when tpr32 then
		x:=real@(a)
		pr32^:=x

	elsecase psize[mode]
	when 8 then pi64^:=a
	when 4 then pi32^:=a
	when 2 then pi16^:=a
	else        pi8^ :=a
	esac
end

global func pci_getopndaddr(pcl p, ref i64 locals)ref i64 =
	psymbol d

	if p.opndtype<>mem_opnd then pcerrorx(p,"Not mem") fi

	d:=p.def
	if d.id=static_id then
		d.staddr
	else
		locals+d.offset
	fi
end

global proc pcerrorx(pcl p, ichar mess, param="")=
	println "PC Exec error:",mess, param, "seq:", (p|p.seqno|0)
	println
	stop 1
end

global proc pcusopnd(pcl p)=
	println "Unsupported operand:", opndnames[p.opndtype],"in", pclnames[p.opcode], p.seqno
	println
	stop 1
end

global func docalldll(psymbol d, ref proc fnaddr, ref[]int revargs, int nargs, nvars, retmode)int=
!d=st entry, fnaddr=nil; or d=nil; fnaddr is fn ptr
!note: args are in reverse order
	[100]i64 args
	int retval

	if fnaddr=nil then
		fnaddr:=getdllfnptr(d)
	fi

	for i:=nargs downto 1 do
		args[nargs-i+1]:=revargs[i]
	od

	retval:=os_calldllfunction(fnaddr, (retmode in [tpr32,tpr64]|'R'|'I'), nargs, &args, nil)

	retval
end

global func getdllfnptr(psymbol d)ref proc fnaddr=
	int libindex
	word dllinst
	ichar procname, libname

	fnaddr:=d.dlladdr
	return fnaddr when fnaddr

	procname:=d.name

	for i to nplibfiles do
		fnaddr:=os_getdllprocaddr(plibinst[i],procname)
		exit when fnaddr
	else
		pcerrorx(nil,"Can't find DLL func:",procname)
	od
	d.dlladdr:=fnaddr
	return fnaddr
end

global proc loadlibs=
	for i to nplibfiles do
		plibinst[i]:=os_getdllinst(plibfiles[i])
		if not plibinst[i] then
			pcerrorx(nil, "Can't load lib:",plibfiles[i])
		fi
	od
end

global func cmpreal(int cond, real x, y)int=
	case cond
	when eq_cc then x=y
	when ne_cc then x<>y
	when lt_cc then x<y
	when le_cc then x<=y
	when ge_cc then x>=y
	else            x>y
	esac
end

global func cmpint(int cond, x, y)int=
	case cond
	when eq_cc then x=y
	when ne_cc then x<>y
	when lt_cc then x<y
	when le_cc then x<=y
	when ge_cc then x>=y
	else            x>y
	esac
end

global func cmpword(int cond, word x, y)int=
	case cond
	when eq_cc then x=y
	when ne_cc then x<>y
	when lt_cc then x<y
	when le_cc then x<=y
	when ge_cc then x>=y
	else            x>y
	esac
end

global proc doincr(ref byte pu8, int incr, mode)=
!uses negative incr for decr
	ref u16 pu16	@pu8
	ref u32 pu32	@pu8
	ref u64 pu64	@pu8

	case psize[mode]
	when 8 then	pu64^+:=incr
	when 4 then	pu32^+:=incr
	when 2 then	pu16^+:=incr
	else		pu8^+:=incr
	esac
end

global proc docmdskip=
	psymbol d

	d:=psymboltable
	while d, d:=d.next do
		if eqstring(getbasename(d.name), "$cmdskip") then
			(ref byte(d.staddr))^:=pcmdskip
			exit
		fi
	od
end

global func pci_loadbf(word a, i, j)word=
!a.[i..j]:=x; return new a
	u64 mask                    ! ...0000000111100000    i=5, j=8, n=4
	int n

	if j<i then swap(i,j) fi
	n:=j-i+1					! width of bitfield

	mask:=inot(inot(0) << n)<<i

	return (a iand mask)>>i
end

global func pci_storebf(word a, i, j, x)word =
!a.[i..j]:=x; return new a
	u64 mask                    ! ...0000000111100000    i=5, j=8, n=4
	u64 n

	if j<i then swap(i,j) fi
	n:=j-i+1					! width of bitfield

	mask:=inot(inot(0) << n)<<i

	x:=x<<i iand mask

	a iand inot(mask) ior x
end
=== pc_tables.m 0 0 34/108 ===
!type system

export enumdata \
		[0:]ichar pstdnames,
		[0:]byte psize,

		[0:]byte psigned,

		[0:]byte pint,
		[0:]byte pfloat,

		[0:]byte pmin,						!promoted type when min width applies
		[0:]byte xxpiwrb =					!int/word/real/block

	(tpvoid=0,    "void",    	0,	0, 0,0,	tpvoid,		tpvoid),

	(tpr32,       "r32",    	4,	0, 0,1,	tpr32,		tpr32),
	(tpr64,       "r64",    	8,	0, 0,1,	tpr64,		tpr64),

	(tpu8,        "u8",      	1,	0, 1,0,	tpu32,		tpu64),
	(tpu16,       "u16",    	2,	0, 1,0,	tpu32,		tpu64),
	(tpu32,       "u32",    	4,	0, 1,0,	tpu32,		tpu64),
	(tpu64,       "u64",    	8,	0, 1,0,	tpu64,		tpu64),

	(tpi8,        "i8",      	1,	1, 1,0,	tpi32,		tpi64),
	(tpi16,       "i16",    	2,	1, 1,0,	tpi32,		tpi64),
	(tpi32,       "i32",    	4,	1, 1,0,	tpi32,		tpi64),
	(tpi64,       "i64",    	8,	1, 1,0,	tpi64,		tpi64),

	(tpblock,     "mem",   		0,	0, 0,0,	tpblock,	tpvoid),
	(tpvector,    "vec",   		0,	0, 0,0,	tpvector,	tpvoid),

	(tplast,      "$last",   	0,	0, 0,0,	0,			0),


end

global const tpref = tpu64

!.opndtype in pclrec

export enumdata [0:]ichar opndnames =
	(no_opnd=0,			$),
	(mem_opnd,			$),
	(memaddr_opnd,		$),
	(label_opnd,		$),
	(int_opnd,			$),
	(real_opnd,			$),
	(r32_opnd,			$),
	(string_opnd,		$),
	(strimm_opnd,		$),
	(assem_opnd,		$),
	(realimm_opnd,		$),
	(realimm32_opnd,	$),
	(data_opnd,			$),
	(any_opnd,			$),		!(used in PCL parser)
end

!The top 4 stack operands are designated as:
!
!	- - - - - Z          1 operand used in IL instruction
!	- - - - Y Z          2 operands
!	- - - X Y Z          3 operands
!	- - W X Y Z          4 operands
!
!The stack notionally grows from left to right. Z is always top-of-stack
!
!Results may be shown as being stored in one of those same operands, eg.
!
!     Y := Y + Z            or:
!     Y +:= Z
!
!Here, Z is popped so that the Y operand becomes the new top-of-stack Z.
!But usually the new stack top is designated as Z':
!
!     Z' := Y + Z

!Immediate operand:
!   A			(various)
!Extra info:
!   op			opindex
!   fn			fnindex
!   cc			cond code
!   t[:size]    type (:size for block types)
!   u           secondary type for some ops (convert etc)
!   n			nargs for calls
!   s x			scale and offset for ptr/offset ops
!   x y			min/max lab index for switch
!	B			Secondary operand in a following kopnd instruction
!	C			Tertiary operand in a following kopnd instruction

!Stack usage is represented by (a b):
! a is the number of stack elements that will be popped
! b is the number of new stack elements that will be pushed
! Something like (1 1) can mean the same element stays in place

const MA = memaddr_opnd
const M  = mem_opnd
const L  = label_opnd
const S  = string_opnd
const A  = any_opnd

export enumdata [0:]ichar pclnames,
				[0:]byte pclhastype,
				[0:]byte pclextra,
				[0:]byte pclhasopnd,
				[0:]byte pclargs =

!                       t  x op args    (a  b)
	(knop=0,       $+1, 0, 0, 0, 0),  ! (0 - 0) (          ) ?

	(kload,        $+1, 1, 1, A, 0),  ! (0 - 1) (M L t i   ) Z' := M &M L &L 123 4.5 "abc"; i=1 for in-place ref
	(kiload,       $+1, 1, 0, 0, 0),  ! (1 - 1) (t         ) Z' := Z^
	(kiloadx,      $+1, 1, 2, 0, 0),  ! (2 - 1) (t d       ) Z' := (Y + Z*s + d)^

	(kstore,       $+1, 1, 0, M, 0),  ! (1 - 0) (M t       ) M := Z
	(kistore,      $+1, 1, 0, 0, 0),  ! (2 - 0) (t         ) Z^ := Y
	(kistorex,     $+1, 1, 2, 0, 0),  ! (3 - 0) (t s d     ) (Y + Z*s + d)^ := X
	(kstorem,      $+1, 1, 0, 0, 0),  ! (2 - 1) (t         ) Z' :=(Y, Z) for mem:16

	(kdupl,        $+1, 0, 0, 0, 0),  ! (1 - 2) (          ) Z' := Y' := Z
	(kdouble,      $+1, 0, 0, 0, 0),  ! (1 - 2) (          ) Count extra instance of Z
	(kswapstk,     $+1, 0, 2, 0, 0),  ! (2 - 2) (a b       ) Swap(stack(a, 0), stack(b)); 1/2/3/4 = Z/Y/X/W
	(kunload,      $+1, 1, 0, 0, 0),  ! (1 - 0) (t         ) Pop stack

	(kopnd,        $+1, 1, 0, A, 0),  ! (0 - 0) (M L C t   ) Define auxiliary operand M or L
	(ktype,        $+1, 1, 0, 0, 0),  ! (0 - 0) (t         ) Define auxiliary type t

	(kloadbit,     $+1, 1, 0, 0, 2),  ! (2 - 1) (t         ) Z' := Y.[Z]
	(kloadbf,      $+1, 1, 0, 0, 2),  ! (3 - 1) (t         ) Z' := X.[Y..Z]
	(kstorebit,    $+1, 1, 0, 0, 2),  ! (3 - 0) (t         ) Y^.[Z] := X
	(kstorebf,     $+1, 1, 0, 0, 2),  ! (4 - 0) (t         ) X^.[Y..Z] := W

	(kcallp,       $+1, 0, 2,MA, 9),  ! (n - 0) (M n v     ) Call &M with nargs, then pop args; v = varargs
	(kicallp,      $+1, 0, 2, 0, 9),  ! (n - 0) (n v       ) Call Z with nargs, then pop args (a=n+1)
	(kretproc,     $+1, 0, 0, 0, 0),  ! (0 - 0) (          ) Return from proc
	(kcallf,       $+1, 1, 2,MA, 9),  ! (n - 1) (M t n v   ) Call &M, then pop args, leave retval; v = varrgs
	(kicallf,      $+1, 1, 2, 0, 9),  ! (n - 1) (t n v     ) Call Z, then pops args, leave retval (a=n+1)
	(kretfn,       $+1, 1, 0, 0, 0),  ! (0 - 0) (t         ) Return from func with Z=retval

	(kjump,        $+1, 0, 0, L, 0),  ! (0 - 0) (L         ) goto L
	(kijump,       $+1, 1, 0, 0, 0),  ! (1 - 0) (          ) goto Z
	(kjumpcc,      $+1, 1, 1, L, 0),  ! (2 - n) (L t c p   ) goto L when Y c Z; p=1: Z':=Y (b=0/1)
	(kjumpt,       $+1, 1, 0, L, 0),  ! (1 - 0) (L t       ) goto L when Z is true
	(kjumpf,       $+1, 1, 0, L, 0),  ! (1 - 0) (L t       ) goto L when Z is false
	(kjumpret,     $+1, 1, 0, L, 0),  ! (1 - 0) (L t       ) goto L, common return point; deal with any ret value on stack
	(kjumpretm,    $+1, 1, 0, L, 0),  ! (a - 0) (L t n     ) goto L, common return point; deal with any ret value on stack

	(ksetcc,       $+1, 1, 0, 0, 0),  ! (2 - 1) (t c       ) Z' := Y cc Z

	(kstop,        $+1, 0, 0, 0, 0),  ! (1 - 0) (          ) Stop Z

	(kto,          $+1, 1, 0, L, 0),  ! (0 - 0) (L t       ) --B (aux); goto L when B<>0 
	(kforup,       $+1, 1, 1, L, 0),  ! (0 - 0) (L t n     ) B+:=n; goto L when B<=C
	(kfordown,     $+1, 1, 1, L, 0),  ! (0 - 0) (L t n     ) B-:=n; goto L when B>=C

	(kiswap,       $+1, 1, 0, 0, 0),  ! (2 - 0) (t         ) swap(Y^,Z^)

	(kswitch,      $+1, 1, 2, L, 0),  ! (1 - 0) (L t x y   ) L=jumptab; B=elselab; x/y=min/max values
	(kswitchu,     $+1, 0, 2, L, 0),  ! (1 - 0) (L x y     ) L=jumptab; B=elselab; x/y=min/max values
	(kswlabel,     $+1, 0, 0, L, 0),  ! (0 - 0) (L         ) jumptable entry
	(kendsw,       $+1, 0, 0, 0, 0),  ! (0 - 0) (          ) Mark end of switch jumptable

	(kclear,       $+1, 1, 0, 0, 0),  ! (1 - 0) (t         ) Clear Z^

	(kassem,       $+1, 0, 0, A, 0),  ! (0 - 0) (x         ) To be worked out....

	(kadd,         $+1, 1, 0, 0, 0),  ! (2 - 1) (t         ) Z' := Y + Z

	(ksub,         $+1, 1, 0, 0, 0),  ! (2 - 1) (t         ) Z' := Y - Z
	(kmul,         $+1, 1, 0, 0, 0),  ! (2 - 1) (t         ) Z' := Y * Z
	(kdiv,         $+1, 1, 0, 0, 0),  ! (2 - 1) (t         ) Z' := Y / Z
	(kidiv,        $+1, 1, 0, 0, 0),  ! (2 - 1) (t         ) Z' := Y % Z
	(kirem,        $+1, 1, 0, 0, 0),  ! (2 - 1) (t         ) Z' := Y rem Z
	(kidivrem,     $+1, 1, 0, 0, 0),  ! (2 - 2) (t         ) Z' := divrem(Y, Z)
	(kbitand,      $+1, 1, 0, 0, 0),  ! (2 - 1) (t         ) Z' := Y iand Z
	(kbitor,       $+1, 1, 0, 0, 0),  ! (2 - 1) (t         ) Z' := Y ior Z
	(kbitxor,      $+1, 1, 0, 0, 0),  ! (2 - 1) (t         ) Z' := Y ixor Z
	(kshl,         $+1, 1, 0, 0, 0),  ! (2 - 1) (t         ) Z' := Y << Z
	(kshr,         $+1, 1, 0, 0, 0),  ! (2 - 1) (t         ) Z' := Y >> Z
	(kmin,         $+1, 1, 0, 0, 0),  ! (2 - 1) (t         ) Z' := min(Y, Z)
	(kmax,         $+1, 1, 0, 0, 0),  ! (2 - 1) (t         ) Z' := max(Y, Z)
	(kaddpx,       $+1, 1, 2, 0, 0),  ! (2 - 1) (t s d     ) Z' := Y + Z*s + d
	(ksubpx,       $+1, 1, 2, 0, 0),  ! (2 - 1) (t s d     ) Z' := Y - Z*s + s
	(ksubp,        $+1, 1, 1, 0, 0),  ! (2 - 1) (t s       ) Z' := (Y - Z)/s

	(kneg,         $+1, 1, 0, 0, 0),  ! (1 - 1) (t         ) Z' := -Z
	(kabs,         $+1, 1, 0, 0, 0),  ! (1 - 1) (t         ) Z' := abs Z
	(kbitnot,      $+1, 1, 0, 0, 0),  ! (1 - 1) (t         ) Z' := inot Z
	(knot,         $+1, 1, 0, 0, 0),  ! (1 - 1) (t         ) Z' := not Z
	(ktoboolt,     $+1, 2, 0, 0, 0),  ! (1 - 1) (t u       ) Z' := istrue Z; u is of type u; result is type t
	(ktoboolf,     $+1, 2, 0, 0, 0),  ! (1 - 1) (t u       ) Z' := not istrue Z
	(ksqr,         $+1, 1, 0, 0, 0),  ! (1 - 1) (t         ) Z' := sqr Z

	(ksqrt,        $+1, 1, 0, 0, 0),  ! (1 - 1) (t         ) Z' := sqrt Z
	(ksin,         $+1, 1, 0, 0, 1),  ! (1 - 1) (t         ) Z' := sin Z
	(kcos,         $+1, 1, 0, 0, 1),  ! (1 - 1) (t         ) Z' := cos Z
	(ktan,         $+1, 1, 0, 0, 1),  ! (1 - 1) (t         ) Z' := tan Z
	(kasin,        $+1, 1, 0, 0, 1),  ! (1 - 1) (t         ) Z' := asin Z
	(kacos,        $+1, 1, 0, 0, 1),  ! (1 - 1) (t         ) Z' := acos Z
	(katan,        $+1, 1, 0, 0, 1),  ! (1 - 1) (t         ) Z' := atan Z
	(klog,         $+1, 1, 0, 0, 1),  ! (1 - 1) (t         ) Z' := log Z
	(klog10,       $+1, 1, 0, 0, 1),  ! (1 - 1) (t         ) Z' := log10 Z
	(kexp,         $+1, 1, 0, 0, 1),  ! (1 - 1) (t         ) Z' := round Z
	(kround,       $+1, 1, 0, 0, 1),  ! (1 - 1) (t         ) Z' := round Z
	(kfloor,       $+1, 1, 0, 0, 1),  ! (1 - 1) (t         ) Z' := floor Z
	(kceil,        $+1, 1, 0, 0, 1),  ! (1 - 1) (t         ) Z' := ceil Z
	(ksign,        $+1, 1, 0, 0, 1),  ! (1 - 1) (t         ) Z' := sign Z

	(katan2,       $+1, 1, 0, 0, 2),  ! (2 - 1) (t         ) Z' := atan2(Y, Z)
	(kpower,       $+1, 1, 0, 0, 2),  ! (2 - 1) (t         ) Z' := Y ** Z
	(kfmod,        $+1, 1, 0, 0, 2),  ! (2 - 1) (t         ) Z' := fmod(Y, Z)

	(kincrto,      $+1, 1, 1, 0, 0),  ! (1 - 0) (t n       ) Z^ +:= n
	(kdecrto,      $+1, 1, 1, 0, 0),  ! (1 - 0) (t n       ) Z^ -:= n
	(kincrload,    $+1, 1, 1, 0, 0),  ! (1 - 1) (t n       ) Z' := (Z +:= n)^
	(kdecrload,    $+1, 1, 1, 0, 0),  ! (1 - 1) (t n       ) Z' := (Z -:= n)^
	(kloadincr,    $+1, 1, 1, 0, 0),  ! (1 - 1) (t n       ) Z' := Z++^ (difficult to express step)
	(kloaddecr,    $+1, 1, 1, 0, 0),  ! (1 - 1) (t n       ) Z' := Z--^

	(kaddto,       $+1, 1, 0, 0, 0),  ! (2 - 0) (t         ) Z^ +:= Y
	(ksubto,       $+1, 1, 0, 0, 0),  ! (2 - 0) (t         ) Z^ -:= Y
	(kmulto,       $+1, 1, 0, 0, 0),  ! (2 - 0) (t         ) Z^ *:= Y
	(kdivto,       $+1, 1, 0, 0, 0),  ! (2 - 0) (t         ) Z^ /:= Y
	(kidivto,      $+1, 1, 0, 0, 0),  ! (2 - 0) (t         ) Z^ %:= Y
	(kiremto,      $+1, 1, 0, 0, 0),  ! (2 - 0) (t         ) Z^ rem:= Y
	(kbitandto,    $+1, 1, 0, 0, 0),  ! (2 - 0) (t         ) Z^ iand:= Y
	(kbitorto,     $+1, 1, 0, 0, 0),  ! (2 - 0) (t         ) Z^ ior:= Y
	(kbitxorto,    $+1, 1, 0, 0, 0),  ! (2 - 0) (t         ) Z^ ixor:= Y
	(kshlto,       $+1, 1, 0, 0, 0),  ! (2 - 0) (t         ) Z^ <<:= Y
	(kshrto,       $+1, 1, 0, 0, 0),  ! (2 - 0) (t         ) Z^ >>:= Y
	(kminto,       $+1, 1, 0, 0, 0),  ! (2 - 0) (t         ) Z^ min:= Y
	(kmaxto,       $+1, 1, 0, 0, 0),  ! (2 - 0) (t         ) Z^ max:= Y
	(kaddpxto,     $+1, 1, 1, 0, 0),  ! (2 - 0) (t s       ) Z^ +:= Y*s
	(ksubpxto,     $+1, 1, 1, 0, 0),  ! (2 - 0) (t s       ) Z^ -:= Y*s

	(knegto,       $+1, 1, 0, 0, 0),  ! (1 - 0) (t         ) -:= Z^
	(kabsto,       $+1, 1, 0, 0, 0),  ! (1 - 0) (t         ) abs:= Z^
	(kbitnotto,    $+1, 1, 0, 0, 0),  ! (1 - 0) (t         ) inot-:= Z^
	(knotto,       $+1, 1, 0, 0, 0),  ! (1 - 0) (t         ) not:= Z^
	(ktoboolto,    $+1, 1, 0, 0, 0),  ! (1 - 0) (t         ) istrue:= Z^

	(ktypepun,     $+1, 2, 0, 0, 0),  ! (1 - 1) (t u       ) Z' := t(u@(Z^))
	(kfloat,       $+1, 2, 0, 0, 0),  ! (1 - 1) (t u       ) Z' := cast(Z,t) Int   to real t
	(kfix,         $+1, 2, 0, 0, 0),  ! (1 - 1) (t u       ) Z' := cast(Z,t) Real   to int t
	(ktruncate,    $+1, 2, 0, 0, 0),  ! (1 - 1) (t u       ) Z' := cast(Z,u) Mask to width of u, but type is widened to t
	(kwiden,       $+1, 2, 0, 0, 0),  ! (1 - 1) (t u       ) Z' := cast(Z,t) Mask to width of u, but type is widened to t
	(kfwiden,      $+1, 2, 0, 0, 0),  ! (1 - 1) (t u       ) Z' := cast(Z,t) r32 to r64
	(kfnarrow,     $+1, 2, 0, 0, 0),  ! (1 - 1) (t u       ) Z' := cast(Z,t) r64 to r32

	(kstartmx,     $+1, 0, 0, 0, 0),  ! (0 - 0) (          ) -
	(kresetmx,     $+1, 1, 0, 0, 0),  ! (0 - 0) (t         ) -
	(kendmx,       $+1, 1, 0, 0, 0),  ! (0 - 0) (t         ) -

	(kproc,        $+1, 0, 0, M, 0),  ! (0 - 0) (M         ) ?
	(ktcproc,      $+1, 0, 0, M, 0),  ! (0 - 0) (M         ) ?
	(kendproc,     $+1, 0, 0, 0, 0),  ! (0 - 0) (          ) ?
	(kistatic,     $+1, 1, 0, M, 0),  ! (0 - 0) (M t       ) Define idata label (must be followed by correct DATA ops)
	(kzstatic,     $+1, 1, 0, M, 0),  ! (0 - 0) (M t       ) Define zdata label and reserve sufficient space
	(kdata,        $+1, 1, 2, A, 0),  ! (0 - 0) (M L C t   ) Constant data. For block types, there can be multiple C values
	(kinitdswx,    $+1, 0, 0, 0, 0),  ! (0 - 0) (          ) Following two ops initialise doswitchx jumptable

	(klabel,       $+1, 0, 0, L, 0),  ! (0 - 0) (          ) ?
	(klabeldef,    $+1, 0, 0,MA, 0),  ! (0 - 0) (          ) ?
	(ksetjmp,      $+1, 0, 0, 0, 0),  ! (1 - 0) (          ) For C
	(klongjmp,     $+1, 0, 0, 0, 0),  ! (1 - 1) (          ) For C

	(ksetcall,     $+1, 0, 1, 0, 0),  ! (0 - 0) (n s       ) n=args, s=1 for simple call

	(ksetarg,      $+1, 0, 2, 0, 0),  ! (0 - 0) (n1 n2     ) n1=arg no (LTR) n2=int or real arg no (maybe neg for real)
	(kloadall,     $+1, 0, 0, 0, 0),  ! (0 - 0) (          ) ?

	(keval,        $+1, 0, 0, 0, 0),  ! (1 - 0) (          ) Evaluate Z [load to an actual register], then pop
	(kcomment,     $+1, 0, 0, 0, 0),  ! (0 - 0) (C         ) Comment C (a string)
	(kendprog,     $+1, 0, 0, 0, 0),  ! (0 - 0) (          ) End-of-program marker.

!                       t  x op args    (a  b)
!	(kenter,       $+1, 0, 0, 0, 2),  ! (0 - 0) (          )
!	(kleave,       $+1, 0, 0, 0, 2),  ! (0 - 0) (          )
!------------------------- -
!these are only used in textual PCL code

	(kparam,       $+1, 1, 0, M, 0),  ! (0 - 0) (M t       ) Define param
	(klocal,       $+1, 1, 0, M, 0),  ! (0 - 0) (M t       ) Define local
	(krettype,     $+1, 1, 0, 0, 0),  ! (0 - 0) (t         ) Define return type
	(kvariadic,    $+1, 0, 0, 0, 0),  ! (0 - 0) (          ) Variadic C function
	(kaddlib,      $+1, 0, 0, S, 0),  ! (0 - 0) (S         ) Define import library
	(kextproc,     $+1, 0, 0, M, 0),  ! (0 - 0) (M         ) Define imported proc
end

global const kerror = knop

export enumdata [0:]ichar ccnames =
	(no_cc=0,	"xx"),
	(eq_cc,		"eq"),
	(ne_cc,		"ne"),
	(lt_cc,		"lt"),
	(le_cc,		"le"),
	(ge_cc,		"ge"),
	(gt_cc,		"gt"),
end

export enumdata [0:]ichar idnames
	(null_id=0,		"--"),			!Not set (used for overall program name)
	(import_id,		"Import"),		!Imported symbol (proc or static)
	(proc_id,		"Proc"),		!Local proc
	(static_id,		"Static"),		!Local static
	(local_id,		"Local"),		!Function local var
	(param_id,		"Param"),		!Function param
	(label_id,		"Label"),		!Used in assembly
	(export_id,		"Export"),		!Used by makesymbol, is converted to proc_id/.exported
	(misc_id,		"Misc"),		!?
	(program_id,	"Program"),		!?
end

=== mc_auxmcl.m 0 0 35/108 ===
!Auxially routines called by genmcl's PX handlers

INT NNN
GLOBAL INT NAUXPROCS
GLOBAL INT NAUXNOFRAME

ref mclrec mclframesetup

proc allocregvars(int skipparams, isleaf)=
!skipparams is 1 when func is main or variadic

	[4]psymbol params, xparams				!exinclude leaf procs
	[4]psymbol leafparams, xleafparams		!leaf procs only
	[4]byte leafparamno, xleafparamno			!index needed for leaf proc to get right preg
	[32]psymbol locals, xlocals
	int nparams:=0, nxparams:=0
	int nleafparams:=0, nxleafparams:=0
	int nlocals:=0, nxlocals:=0, n, reg, xreg
	int nl, np
	int nlx, npx
	psymbol d

	if maxregvars+maxxregvars=0 then		!disabled
		return
	fi

!note: only args 1-4 considered, even though some may be unsuitable, leaving a slot
!for arg 5+ to fill
	if not skipparams then
		d:=currfunc.nextparam
		n:=0
		while d, d:=d.nextparam do
			++n
			if d.used and not d.atvar and not d.addrof and n<=4 then
				if not isleaf then
					if pint[d.mode] then
						if nparams<4 then
							params[++nparams]:=d
						fi
					elsif pfloat[d.mode] then
						if nxparams<4 then
							xparams[++nxparams]:=d
						fi
					fi
				else						!leaf
					if pint[d.mode] then
						if nleafparams<4 then
							leafparams[++nleafparams]:=d
							leafparamno[nleafparams]:=n
						fi
					elsif pfloat[d.mode] then
						if nxleafparams<4 then
							xleafparams[++nxleafparams]:=d
							xleafparamno[nxleafparams]:=n
						fi
					fi
				fi
			fi
		od
	fi

	d:=currfunc.nextlocal
	while d, d:=d.nextlocal do

		if d.used and not d.atvar and not d.addrof then
			if pint[d.mode] then
				if nlocals<locals.len then
					locals[++nlocals]:=d
				fi
			elsif pfloat[d.mode] and nxlocals<xlocals.len then
				xlocals[++nxlocals]:=d
			fi
		fi
	od

!now allocate regs
	if nlocals=0 then						!params only; no locals
		np:=min(maxregvars, nparams)		!(unlikely regvars is below 4)
		nl:=0
	elsif nparams=0 then					!locals only; no params, or is leaf
		nl:=min(maxregvars, nlocals)
		np:=0
	else									!both locals and params
		nl:=nlocals
		np:=nparams
		n:=np+nl-maxregvars					!n is excess number; neg is OK
		if n>0 then							!at least one short
			--np; --n						!lose one param
			if n>0 and np>0 then			!lose 2nd param
				--np; --n
			fi
			if n>0 then						!still short; lose excess from locals
				nl-:=n
			fi
		fi
	fi

!now allocate regvars

	reg:=r3
	for i to nl do
		d:=locals[i]
		d.reg:=reg
		isregvar[reg]:=1
		++reg
	od

!CPL =NL, =NP

	for i to np do
		d:=params[i]
		d.reg:=reg
		isregvar[reg]:=1
		++reg
	od

!do regvars for leaf procs
	for i to nleafparams do
		d:=leafparams[i]
		reg:=leafparamno[i]+r10-1
		if reg=r10 then r10used:=1 fi
		if reg=r11 then r11used:=1 fi
		d.reg:=reg
		isregvar[reg]:=1
	od

!now allocate xregs
	if nxlocals=0 then						!params only; no locals
		npx:=min(maxxregvars, nxparams)		!(unlikely regvars is below 4)
		nlx:=0
	elsif nxparams=0 then					!locals only; no params, or is leaf
		nlx:=min(maxxregvars, nxlocals)
		npx:=0
	else									!both locals and params
		nlx:=nxlocals
		npx:=nxparams
		n:=npx+nlx-maxregvars					!n is excess number; neg is OK
		if n>0 then							!at least one short
			--npx; --n						!lose one param
			if n>0 and npx>0 then			!lose 2nd param
				--npx; --n
			fi
			if n>0 then						!still short; lose excess from locals
				nlx-:=n
			fi
		fi
	fi

!now allocate Xregvars

	reg:=r15
	for i to nlx do
		d:=xlocals[i]
		d.reg:=reg
		isxregvar[reg]:=1
		--reg
	od

	for i to npx do
		d:=xparams[i]
		d.reg:=reg
		isxregvar[reg]:=1
		--reg
	od

!do regvars for leaf procs
	for i to nxleafparams do
		d:=xleafparams[i]
		reg:=xleafparamno[i]+r0-1
		d.reg:=reg
		isxregvar[reg]:=1
	od
end


global proc initproc(psymbol d)=
!initialise genmcl pass through proc pcl code
	psymbol e
	ref procinforec pinfi

	clear regset
	clear xregset
	clear workregs
	clear workxregs
	clear isregvar
	clear isxregvar
	int reg, xreg, n, r, npregs

!NEW CODE REQUIRED WHICH SETS NWORK/X/REGS
!Works with INFO=NIL, then not critical, but will be some of R0-R9
!Or uses info to decide how many and where; then they will be
!a combo of R0-R2, R9 downtowards R3 (depends on maxregvars), and possibly R12/R12
	nworkregs:=3
	workregs[r0]:=1					!these are always given
	workregs[r1]:=1
	workregs[r2]:=1

	nworkxregs:=2
	workxregs[r4]:=1
	workxregs[r5]:=1
	maxregvars:=maxxregvars:=0
	npregs:=0
	pinfo:=currfunc.info

	if pinfo=nil then
!NOINFO:
!CPL "NO PINFO"

		nworkregs:=10
		nworkxregs:=12
		for r in r3..r9 do workregs[r]:=1 od
		for r in r6..r15 do workxregs[r]:=1 od
	else	
!GOTO NOINFO
		npregs:=min(4, max(currfunc.nparams, pinfo.nmaxargs))
		nworkregs:=4

		if pinfo.hasblocks then ++nworkregs fi
		nworkxregs:=5

		n:=nworkregs-3

		if npregs<=3 and n then		!use at least one preg
			workregs[r13]:=1
			--n
			if npregs<=2 and n then
				workregs[r12]:=1
				--n
			fi
		fi

		r:=r9					!do any remaining workregs from r9 downwards
		to n do					!allocate from r9 down
			workregs[r--]:=1
		od

		r:=r6
		to nworkxregs-2 do					!allocate from r6 up
			workxregs[r++]:=1
		od
	fi

	for r in r3..r9 when not workregs[r] do ++maxregvars od
	for r in r6..r15 when not workxregs[r] do ++maxxregvars od

!CPL =NWORKREGS, =MAXREGVARS
!FOR R IN R0..R15 DO
!	IF WORKREGS[R] THEN CPL "WORK:", GETREGNAME(R) FI
!OD

!	println currfunc.name,,":",=nworkregs, =nworkxregs, =npregs, =MAXREGVARS, =MAXXREGVARS
!	cp "  "; for r in r0..r13 when workregs[r] do print getregname(r),$ od; cpl
!	cp "  "; for r in r0..r15 when workxregs[r] do print getxregname(r),$ od; cpl

	clear usedregs
	clear usedxregs
	clear pcltempflags
	r10used:=r11used:=0

	mstackdepth:=0
	noperands:=0

	frameoffset:=paramoffset:=framebytes:=0
	localshadow:=0

	nblocktemps:=0

	if d.mode=tpblock then
		e:=pc_makesymbol("$1x", misc_id)
		e.mode:=d.mode
		e.used:=1
		e.id:=param_id
		e.nextparam:=currfunc.nextparam
		e.owner:=currfunc
		currfunc.nextparam:=e
		blockretname:=e
	fi

	return unless fregoptim and currfunc.info
!CPL "DOING REGALLOC"

!.info will be available here

	if currfunc.info.assemused then
		return
	fi

	allocregvars(currfunc.ismain or currfunc.variadic, currfunc.info.isleaf)
end

global proc do_procentry(pcl p)=
	int retmode, ntemps, hasequiv, offset, size, reg
	mclopnd ax
	psymbol d
	[100]char str, newname
	int rr, ff

	setmclentry(mclprocentry)

	bspill:=bxspill:=0
!	if highreg>=r3 then bspill:=highreg-r2 fi		!no of regs d3..highreg
!	if highxreg>=r6 then bxspill:=highxreg-r5 fi	!no of xregs x6..highxreg

	unless currfunc.info and currfunc.info.assemused then
		for r in r3..r9 when usedregs[r] or isregvar[r] do ++bspill od

		for r in r6..r15 when usedxregs[r] or isxregvar[r] do ++bxspill od
	end

	d:=currfunc.nextparam
	while d, d:=d.nextparam do
		IF D.ATVAR THEN MERROR("@PARAM") FI
		if not d.reg then			!not a regvar
			d.offset:=paramoffset+16+(bspill+bxspill)*8
			genmc(m_define, mgenname(getdispname(d)), mgenint(d.offset))
		else						!assume regvar
			rr:=d.reg
			ff:=usedregs[rframe]
			d.reg:=0

			genmc(m_definereg, mgenmem(d), mgenreg(rr, d.mode))
			d.reg:=rr
			usedregs[rframe]:=ff
		fi
		paramoffset+:=8
	od

	retmode:=currfunc.mode

	d:=currfunc.nextlocal
	while d, d:=d.nextlocal do
!CPL "LOCAL", CURRFUNC.NAME, D.NAME, =STRPMODE(D.MODE), =D.ATVAR, =D.REG, =D.USED
		size:=psize[d.mode]
		if d.mode=tpblock then
			size:=d.size
		fi
		nextloop unless d.used				!also skips statics added in fixmain

		if d.atvar then
			hasequiv:=1

        elsif d.reg then
			rr:=d.reg
			ff:=usedregs[rframe]
			d.reg:=0
			genmc(m_definereg, mgenmem(d), mgenreg(rr, d.mode))
			d.reg:=rr
			usedregs[rframe]:=ff

        else
			frameoffset-:=roundsizetg(size)
			d.offset:=frameoffset
			genmc(m_define, mgenname(getdispname(d)), mgenint(d.offset))

		fi
	od

	ntemps:=0
	for i to maxoperands when pcltempflags[i] do
		++ntemps
		frameoffset-:=8
		ax:=pcltempopnds[i]
		ax.offset:=frameoffset
!		genmc(m_definetemp, mgenname(gettempname(currfunc,i)), mgenint(ax.offset))
		genmc(m_define, mgenname(gettempname(currfunc,i)), mgenint(ax.offset))
	od

	if currfunc.isthreaded then
		if currfunc.nlocals or currfunc.nparams then merror("Threaded proc has locals/params") fi
		if ntemps then merror("Threaded proc has temps") fi

!*!		if bspill or bxspill then merror("Threaded proc has spill regs") fi

		resetmclentry()
		return
	fi

	framebytes:=-frameoffset

	if (bspill+bxspill).odd then				!need an even number to keep stack alighnment correct
		unless framebytes iand 8 then
			framebytes+:=8
		end
	else
		if framebytes iand 8 then
			framebytes+:=8
		fi
	fi

	if localshadow then
		framebytes+:=32				!shadow space
	fi

!spill any bregs
	if bspill then
		for r:=r3 to r9 when usedregs[r] or isregvar[r] do
			genmc(m_push, mgenreg(r, tpu64))
		od
	fi

	if bxspill then
		ax:=mgenreg(r0, tpu64)
		for r:=xr6 to xr15 when usedxregs[r] or isxregvar[r] do
!			ax:=mgenindex(areg:rframe, size:8, offset:offset)
!			offset+:=8
			genmc(m_movq, ax, mgenxreg(r))
			genmc(m_push, ax)
		od
	fi

	MGENCOMMENT("?]]")
	MCLFRAMESETUP:=MCCODEX

	spillparams()

!MCOMM("COPY PARAMS TO REGVARS?")

	MCOMM("---------------")
	RESETMCLENTRY()
end

global proc do_procexit=
	mclopnd ax
	int offset

	MCOMM("---------------")
	if currfunc.isthreaded then
		genmc(m_ret)				!in case no jump out exists
		return
	fi

	SETMCLENTRYF(mclframesetup)

!CPL "PROCENTRY/", CURRFUNC.NAME, = FRAMEBYTES, CURRFUNC.NPARAMS, USEDREGS[RFRAME]
!	if framebytes or currfunc.nparams then
!CPL =FRAMEBYTES
	if framebytes or currfunc.nparams OR USEDREGS[RFRAME] then
		if usedregs[rframe] then
			genmc(m_push, dframeopnd)
			genmc(m_mov, dframeopnd, dstackopnd)
			pushstack(framebytes)
		else
			IF FRAMEBYTES THEN
				pushstack(framebytes+8)
			FI
		fi
	fi
	RESETMCLENTRYF()

	if framebytes or currfunc.nparams OR USEDREGS[RFRAME] then
!	if framebytes or currfunc.nparams then
		if usedregs[rframe] then
			popstack(framebytes)
			genmc(m_pop, dframeopnd)
		else
			IF FRAMEBYTES THEN
				popstack(framebytes+8)
			FI
		fi
	fi

	if bxspill then
		ax:=mgenreg(r10, tpu64)
		for r:=xr15 downto xr6 when usedxregs[r] do
			genmc(m_pop, ax)
			genmc(m_movq, mgenxreg(r), ax)
		od
	fi

	if bspill then
		for r:=r9 downto r3 when usedregs[r] do
			genmc(m_pop, mgenreg(r, tpu64))
		od
	fi

	genmc(m_ret)
end

proc spillparams=
	psymbol d
	mclopnd ax
	int offset:=16, regoffset:=0, xregoffset, firstoffset

	regoffset:=0

	d:=currfunc.nextparam

	if currfunc.variadic then				!C proc def using ...
		firstoffset:=d.offset				!param offsets may be pushed up

		for i:=currfunc.nparams to 3 do				!0-based; if nparams=2, loops over 2..3 as 0..1 are normal
			ax:=mgenindex(areg:rframe, size:8, offset:i*8+firstoffset)
			genmc(m_mov, ax, mgenreg(i+r10))
		od
	fi

	while d, d:=d.nextparam do
		if regoffset>3 then exit fi

		if d.used  then
			if not d.reg then
				ax:=mgenindex(areg:rframe, size:8, offset:d.offset)
				case d.mode
				when tpr64 then
					genmc(m_movq, ax, mgenxreg(regoffset+xr0))
				when tpr32 then
					genmc(m_movd, changeopndsize(ax,4), mgenxreg(regoffset+xr0))
				else
					genmc(m_mov, ax, mgenreg(regoffset+r10))
				esac
			elsif d.reg then
				if ispfloat(d.mode) then
					if d.reg>=xr4 then				!not in-situ param
						genmc(m_movq, mgenxreg(d.reg), mgenxreg(regoffset+xr0, d.mode))
					fi
				elsif d.reg<=r9 then				!not in-situ param
					genmc(m_mov, mgenreg(d.reg, d.mode), mgenreg(regoffset+r10,d.mode))
				fi
			fi
		fi

		offset+:=8
		++regoffset
	od

end

global proc do_jumptruefalse(pcl p, int cond)=
	mclopnd ax, bx

	ax:=loadopnd(zz, pmode)

	if ispint(pmode) then
		genmc(m_test, ax,ax)

	else
		bx:=getworkregm(pmode)
		genmc(m_xorps+ispwide(pmode), bx, bx)
		genmc(m_comiss+ispwide(pmode), ax, bx)
	fi

	genmc_cond(m_jmpcc, cond, mgenlabel(p.labelno))

	poppcl()
end

global proc do_bitwise(pcl p, int opc)=
	mclopnd ax,bx

	ax:=loadopnd(yy, pmode)
	bx:=getopnd(zz, pmode)

	genmc(opc, ax, bx)

	poppcl()
end

global proc do_shift(pcl p, int opc)=
	mclopnd ax, cx
	pcl y

	ax:=loadopnd(yy, pmode)

	y:=pclopnd[zz]

	if pclloc[zz]=pcl_loc and y.opndtype=int_opnd then
		genmc(opc, ax, mgenint(y.value))
	else
		genmc(m_push, mgenreg(r10)) when r10used
		cx:=loadparam(zz, tpu8, r10)
		genmc(opc,ax, cx)
		genmc(m_pop, mgenreg(r10)) when r10used
	fi
	poppcl()
end

proc setmclentry(ref mclrec p)=
!temporarily set mcl insertion before p

	mce_oldmccodex:=mccodex
	mccodex:=p
	mce_lastmcl:=p.lastmcl
	mce_nextmcl:=p.nextmcl
end

func resetmclentry:ref mclrec pnew =
!restore mcl insertion point to normal
!restireturn mcl instruction that followed	
	mccodex.lastmcl:=mce_lastmcl
	mccodex.nextmcl:=mce_nextmcl
	pnew:=mccodex
	mccodex:=mce_oldmccodex
	pnew
end

proc setmclentryf(ref mclrec p)=
!temporarily set mcl insertion before p

	mcf_oldmccodex:=mccodex
	mccodex:=p
	mcf_lastmcl:=p.lastmcl
	mcf_nextmcl:=p.nextmcl
end

func resetmclentryf:ref mclrec pnew =
!restore mcl insertion point to normal
!restireturn mcl instruction that followed	
	mccodex.lastmcl:=mcf_lastmcl
	mccodex.nextmcl:=mcf_nextmcl
	pnew:=mccodex
	mccodex:=mcf_oldmccodex
	pnew
end

global proc do_pushlowargs(int nargs, nvariadics=0, isptr=0, pstack=0)=
!

!nargs=0 to 4 /operands/, not using more than 4 slots
!load args to D10-13/X0-3
!does not do anything with the stack at all
! Params are categorised as follows:
! Variadic:
!   float:  load to both D and X registers
!   other:  load to D register only
! Normal/non-variadic:
!   float:  load to X register
!   other:  load to D register
!PSTACK is 1, if call* data structures ate not used, eg. via CALLRTS
!Then use mode info from pclstack

	mclopnd ax
	int j,k, nextireg, nextxreg, mode, imode, blockret
	psymbol dblock

	if nargs=0 then return fi

	if pstack then
		blockret:=0
	else
		blockret:=callblockret[ncalldepth]
	fi

	nextireg:=r10
	nextxreg:=xr0

	k:=0
	for i:=noperands downto noperands-nargs+1 do
		++k						!counts params from 1

		if k=1 and blockret then
			dblock:=newblocktemp(callblocksize[ncalldepth])
			dblock.used:=1
			genmc(m_lea, mgenreg(r10), mgenmem(dblock))

		else

			j:=i-isptr+BLOCKRET

!CPL STROPNDSTACK()
			if pstack then
				mode:=pclmode[j]				!will never be a block
			else
				mode:=callargmode[ncalldepth,k]
			fi

!CPL "PUSHLOW", =STRPMODE(MODE), =STRPMODE(CALLARGMODE[NCALLDEPTH,K], CALLARGSIZE[NCALLDEPTH, K])

			case mode
			when tpblock then
!CPL "PUSHLOW/BLOCK"
				ax:=loadparam(j, mode, nextireg)
				copyblockarg(ax, callargsize[ncalldepth,k], k)

			when tpr64, tpr32 then
				loadparam(j, mode, nextxreg)
!CPL "LOADXPARAM", STRPMODE(MODE)

				if nvariadics and k>=nvariadics then			!variadic floats go to both regs

!I need to move xmm reg to int reg
					imode:=(mode=tpr32|tpu32|tpu64)
					genmc(m_mov, mgenreg(nextireg, imode), mgenreg(nextxreg, mode))
				fi
			else
doint:
				loadparam(j, mode, nextireg)
			esac
		fi

		++nextireg
		++nextxreg
	od
end

global proc do_getretvalue(pcl p)=
	int reg,xreg,i,n, m
	[10]int modes

!MERROR("DOGETRETVAL")
!MCOMM("DOGETRETVAL")
	if (p+1).opcode=ktype then
		n:=0
		while (++p).opcode=ktype do
			modes[++n]:=p.mode
		od
		currpcl:=p-1

		for i:=n downto 1 do 
			m:=modes[i]
			pushpcl_reg(m, (ispfloat(m)|multxregs[i]|multregs[i]))
		od

	elsif p.mode then
		pushpcl_reg(p.mode, r0)

	fi
end

global func ismemaddr(int n)int=
	if pclloc[n]=pcl_loc and pclopnd[n].opndtype=memaddr_opnd then return 1 fi
	return 0
end

global proc do_incr(pcl p, int incrop, addop)=
	mclopnd mx

	mx:=getopnd_ind(zz, p.mode)

	if p.stepx=1 then
		genmc(incrop, mx)
	else
		genmc(addop, mx, mgenint(p.stepx))
	fi
	poppcl()
end

global proc do_incrload(pcl p, int incrop, addop)=
	mclopnd ax, mx

	mx:=getopnd_ind(zz, pmode)
	ax:=getworkreg_rm(pclreg[zz], pmode)

	if p.stepx=1 then
		genmc(incrop, mx)
	else
		genmc(addop, mx, mgenint(p.stepx))
	fi

	genmc(m_mov, ax, mx)

!now replace ax opnd with new value
	pclloc[zz]:=reg_loc
	pclopnd[zz]:=nil
	pclreg[zz]:=ax.reg
	pclmode[zz]:=pmode

end

global proc do_loadincr(pcl p, int incrop, addop)=
	mclopnd ax,mx

	mx:=getopnd_ind(zz, pmode)

	pushpcl_reg(pmode)			!to hold loaded value
	ax:=getopnd(zz, pmode)

	genmc(m_mov, ax, mx)

	if p.stepx=1 then
		genmc(incrop, mx)
	else
		genmc(addop, mx, mgenint(p.stepx))
	fi

	swapopnds(yy,zz)
	poppcl()
end

global proc do_for(pcl p, int incop, addop, cond)=
	pcl q,r
	mclopnd ax,bx,cx,dx,mx
	int reg

	q:=p+1
	r:=currpcl:=q+1

	mx:=mgenmem(q.def, pmode)

	if q.def.reg then
		if p.stepx=1 then
			genmc(incop, mx)
		else
			genmc(addop, mx, mgenint(p.stepx))
		fi
		ax:=mx
	else
		ax:=mgenreg(getworkireg())
		genmc(m_mov, ax,mx)
		if p.stepx=1 then
			genmc(incop, ax)
		else
			genmc(addop, ax, mgenint(p.stepx))
		fi
		genmc(m_mov, mx, ax)
	fi

	if r.opndtype=int_opnd then
		bx:=mgenint(r.value)
	else
		bx:=mgenmem(r.def)
	fi

	genmc(m_cmp, ax, bx)

	genmc_cond(m_jmpcc, cond, mgenlabel(p.labelno))
end

!global proc do_for(pcl p, int incop, addop, cond)=
!THIS VERSION USES JMPEQ, so that an upper limit of i64.max/u64.max is handled.
!But behaviour changes a little:
!  loop index after normal termination will be LIMIT not LIMIT+1 or LIMIT-1
!  loop index can't be modified inside the loop, so that it has a
!  value beyond the limit

!	pcl q,r
!	mclopnd ax,bx,cx,dx,mx
!	int reg, lab
!
!	q:=p+1
!	r:=currpcl:=q+1
!
!	lab:=++mlabelno
!
!	mx:=mgenmem(q.def, pmode)
!
!	if q.def.reg then
!		ax:=mx
!	else
!		ax:=mgenreg(getworkireg())
!		genmc(m_mov, ax,mx)
!	fi
!
!	if r.opndtype=int_opnd then
!		bx:=mgenint(r.value)
!	else
!		bx:=mgenmem(r.def)
!	fi
!
!	genmc(m_cmp, ax, bx)
!	genmc_cond(m_jmpcc, z_cond, mgenlabel(lab))
!
!	if q.def.reg then
!		if p.stepx=1 then
!			genmc(incop, ax)
!		else
!			genmc(addop, ax, mgenint(p.stepx))
!		fi
!	else
!		if p.stepx=1 then
!			genmc(incop, ax)
!		else
!			genmc(addop, ax, mgenint(p.stepx))
!		fi
!		genmc(m_mov, mx, ax)
!	fi
!
!	genmc(m_jmp, mgenlabel(p.labelno))
!
!	genmc(m_labelx,mgenlabel(lab))
!
!
!end

global func scaleindex(mclopnd ax, int scale)int=
!when scale is 1/2/3/4, return scale unchanged
!anything else, scale value in ax, return 1
	int n
	if scale in [1,2,4,8] then return scale fi

	mulimm(ax,scale)
	return 1
end

global proc mulimm(mclopnd ax, int n)=
!multiply operand in ax (a simple reg) by constant n
!will try efficient method if possible, otherwise use normal multiply 
	int shifts,m
	mclopnd bx

	case n
	when 0 then
		clearreg(ax)
		return
	when 1 then
		return
	when -1 then
		genmc(m_neg, ax)
		return
	esac

	shifts:=0
	m:=n

	while m.even do
		m>>:=1
		++shifts
	od

	if shifts then
		genmc(m_shl, ax, mgenint(shifts))
	fi

	case m
	when 1 then
		return
	when 3, 5, 9 then
		genmc(m_lea, ax, mgenindex(areg: ax.reg, ireg:ax.reg, scale:m-1))
	else						!mul needed anyway; forget the shift
		if shifts then
			mccodex.opcode:=m_imul2
			mccodex.b:=mgenint(n)
		else
!			genmc(m_imul2, ax, mgenint(n))

			bx:=getworkregm((ax.size=4|tpi32|tpi64))
			genmc(m_mov, bx, mgenint(n))
			genmc(m_imul2, ax, bx)

		fi
	esac
end

global func do_addrmode*(pcl p)mclopnd px =
!Top two stack elements are an array (yy) and index (zz)
!Return a operand which provdes the address mode to access the element,
!for either reading or writing
!The address mode will use 0, 1 or 2 registers. The registers may be 1 or 2
!associated with the pcl operands, or may be regvars.
!If for reading, caller will need to make their own arrangements for a dest reg.
!When Xb has to be loaded into a register anyway, then the caller can make use
!of that

	mclopnd ax,bx
	int scale, extra,offset, reg,regix
	psymbol d
	pcl q

	scale:=p.scale
	extra:=p.extra

	q:=isimmload(zz)
	if q then
		offset:=q.value*scale+extra	!for imm offset
	fi

	px:=nil

	if pclloc[yy]=regvar_loc then
!CPL "AM1"
		if pclloc[zz]=regvar_loc then		!regvar/regvar
			reg:=pclreg[zz]
			regix:=scaleregvar(reg,scale,zz)
			px:=mgenindex(areg:pclreg[yy],ireg:regix, offset:extra, scale:scale)
!
		elsif q then						!regvar/imm
			px:=mgenindex(areg:pclreg[yy], offset:offset)
		else								!regvar/any
			scale:=scaleindex(bx:=loadopnd(zz, pclmode[zz]),scale)
			px:=mgenindex(areg:pclreg[yy], ireg:bx.reg, scale:scale, offset:extra)
		fi

	elsif ismemaddr(yy) then
!CPL "AM2"
		d:=pclopnd[yy].def
!CPL D.NAME, IDNAMES[D.ID], =PHIGHMEM, =D.ID, STATIC_ID, IMPORT_ID
!		if d.id=static_id and phighmem=2 or D.ID=PARAM_ID AND D.MODE=TPBLOCK  then skip fi
		if d.id in [static_id, import_id] and phighmem=2 or D.ID=PARAM_ID AND D.MODE=TPBLOCK  then skip fi

		if pclloc[zz]=regvar_loc then			!memaddr/regvar
			reg:=pclreg[zz]
			regix:=scaleregvar(reg,scale,zz)
			px:=mgenindex(ireg:regix, def:d, offset:extra, scale:scale)
!
		elsif q then			!memaddr/imm
			px:=mgenindex(def:d, offset:offset)
		else							!memaddr/any
			scale:=scaleindex(bx:=loadopnd(zz, tpi64),scale)
			px:=mgenindex(ireg:bx.reg, def:d, offset:extra, scale:scale)
		fi
	else								!
skip:
!CPL "AM3"
		ax:=loadopnd(yy, tpu64)

		if pclloc[zz]=reg_loc then			!any/regvar
			reg:=pclreg[zz]
			regix:=scaleregvar(reg,scale,zz)
			px:=mgenindex(areg:ax.reg, ireg:regix, offset:extra, scale:scale)

		elsif q then						!any/imm	
			px:=mgenindex(areg:ax.reg, offset:offset)
		else
			scale:=scaleindex(bx:=loadopnd(zz, tpu64),scale)
			px:=mgenindex(areg:ax.reg, ireg:bx.reg, scale:scale, offset:extra)
		fi
	fi

	px.size:=psize[p.mode]

	return px
end

function scaleregvar(int reg, &scale, n)int=
!When scale is 1/2/3/4, return reg (a regvar) and scale unchanged;
!otherwise set up a new register for operand n
!Copy reg to it, and scale. Return new reg, and set scale to 1
	int regix
	mclopnd ax

	if scale in [1,2,4,8] then return reg fi

	regix:=getworkireg()
	ax:=mgenreg(regix)

	IF SCALE=16 THEN
		genmc(m_lea, ax, mgenindex(ireg:reg, areg:reg, scale:1))
		scale:=8

	ELSE
		genmc(m_mov,ax, mgenreg(reg))
		mulimm(ax,scale)
		scale:=1
	FI

	pclloc[n]:=reg_loc
	pclreg[n]:=regix
	pclmode[n]:=tpi64
	pclopnd[n]:=nil

	return regix
end

global proc dolea(mclopnd ax, px)=
!do 'lea ax, px`, but suppress in cases like 'lea d0,[d0]'
	unless px.regix=px.valtype=px.offset=0 and px.reg=ax.reg then

		genmc(m_lea, ax, px)
	end
end

global proc do_binto(pcl p, int opc, fopc)=
	mclopnd ax,bx,rx

	if ispfloat(pmode) then
		do_binto_float(p, fopc)
		return
	fi

	ax:=getopnd_ind(zz, p.mode)
	bx:=loadopnd(yy, p.mode)

	genmc(opc,ax,bx)
	poppcl()
	poppcl()
end

global proc do_binto_float(pcl p, int opc)=
	mclopnd px,bx,cx

	pushpcl_reg(pmode)		!z^:=y => y^:=x; z is temo

	px:=getopnd_ind(yy, pmode)
	bx:=getopnd(xx, pmode)
	cx:=getopnd(zz, pmode)

	genmc(m_mov, cx, px)
	genmc(opc+ispwide(pmode), cx, bx)
	genmc(m_mov, px,cx)

	poppcl()
	poppcl()
	poppcl()
end

global proc do_shiftnto(pcl p, int opc)=
!shift opc=shl/shr/sar, when both operands are on the stack
!first operand is address of dest
	mclopnd px, cx

	px:=getopnd_ind(zz, pmode)

	if pclloc[yy]=pcl_loc and pclopnd[yy].opndtype=int_opnd then
		genmc(opc, px, mgenint(pclopnd[yy].value))

	else
		genmc(m_push, mgenreg(r10)) when r10used

		cx:=loadparam(yy, tpu8, r10)
		genmc(opc, px, cx)

		genmc(m_pop, mgenreg(r10)) when r10used

	fi

	poppcl()
	poppcl()
end

global proc do_divrem(pcl p, int issigned, isdiv)=
!isdiv = 0/1/2 = rem/div/divrem
! Z' := Y % Z
	mclopnd ax, bx, px
	pcl q
	int opc, n, shifts
	byte fdivto:=0
	int locyy:=yy, loczz:=zz

	if p.opcode in [kidivto, kiremto] then
		swap(locyy, loczz)

		ax:=loadopnd(locyy, tpu64)
		fdivto:=1
		genmc(m_push, changeopndsize(ax,8))
		px:=makeopndind(ax, pmode)
		ax:=mgenreg(ax.reg, pmode)

		genmc(m_mov, ax, px)
	else
		ax:=loadopnd(locyy, pmode)
	fi

	q:=isimmload(loczz)

	if q and isdiv=1 then
		n:=q.value
		case n
		when 0 then
			merror("Divide by zero")
		when 1 then
			poppcl()
			return
		else
			shifts:=ispoweroftwo(n)
			if shifts AND NOT FDIVTO then
				genmc((issigned|m_sar|m_shr), ax, mgenint(shifts))
				poppcl()
				return
			fi
		esac
	fi 

	bx:=loadopnd(loczz, pmode)

	saverdx()
	fixdivopnds(locyy, loczz)
	bx:=loadopnd(loczz, pmode)			!in case regs have changed

	if issigned then
		opc:=
			case psize[pmode]
			when 8 then	m_cqo
			when 4 then	m_cdq
			when 2 then	m_cwd
			else merror("div/u8"); 0
			esac
		genmc(opc)

		opc:=m_idiv
	else
!		genmc(m_xorx, mgenreg(r11),mgenreg(r11))
		clearreg(mgenreg(r11))
		opc:=m_div
	fi

	genmc(opc, bx)

	case isdiv
	when 0 then				!rem
		genmc(m_xchg, mgenreg(r0), mgenreg(r11))

	when 2 then				!divrem
		genmc(m_xchg, bx, mgenreg(r11))			!rem replace y-operand
		swapopndregs(r1)						!make sure it is in r1
		swapopnds(locyy,loczz)

	esac

	restorerdx()

	if fdivto then
		bx:=getworkregm(tpu64)
		genmc(m_pop, bx)
		genmc(m_mov, makeopndind(bx, pmode), getopnd(locyy, pmode))
		poppcl()
	fi

	if isdiv<>2 then
		poppcl()
	fi

end

proc fixdivopnds(int locyy, loczz)=
!two div operands exist as the top two operands, which will be
!in registers
!the div op requires that x is in d0, and y in any other register
!d11 also needs to be free, which will be the case is reg allocs only
!go up to d9, and d10/d11/12/13 are in use for win64 parameter passing
	int regx,regy,zop
	mclopnd bx, ax

	regx:=pclreg[locyy]
	regy:=pclreg[loczz]

	if regx=r0 then			!regy will be OK
		return
	fi

	bx:=getopnd(locyy, tpu64)
	ax:=getopnd(loczz, tpu64)

	if regy=r0 then			!need to swap then
		genmc(m_xchg, bx, ax)
		swapopnds(locyy,loczz)		!switch operands
		return
	fi

!neither x nor y in r0
	if regset[r0]=0 then	!d0 not in use
		genmc(m_xchg, mgenreg(r0), bx)
		regset[regx]:=0				!switch registers for yy

		pclreg[locyy]:=r0
		regset[r0]:=1

		return
	fi

!need to move current occupier of r0
	for zop:=noperands downto 1 do
		if pclloc[zop]=reg_loc and pclreg[zop]=r0 then exit fi
	else
		return
	od

!zop is the operand number that happens to be using r0
	genmc(m_xchg, mgenreg(r0), getopnd(locyy, tpu64))	
	swap(pclreg[locyy], pclreg[zop])		!switch registers
end

proc saverdx=
	genmc(m_push, mgenreg(r11)) when r11used
end

proc restorerdx=
	genmc(m_pop, mgenreg(r11)) when r11used
end

global proc clearblock(mclopnd ax, int n)=
!ax is the operand with the address of memory to be cleared
!generate code to clear n bytes

!CPL "CLEARBLOCK", MSTROPND(AX), N

	mclopnd rx, rcount
	int nwords,lab,oddbytes,offset,workreg, countreg

	oddbytes:=n rem 8		!will be zero, or 1..7

	n-:=oddbytes			!n will always be a multiple of 8; n can be zero too
	nwords:=n/8				!number of u64s (ie. octobytes)

	rx:=getworkregm(tpu64)
	clearreg(rx)

	offset:=0

	if 1<=nwords<=8 then		!use unrolled code (no loop)
		ax:=changeopndsize(ax,8)

		to nwords do
			genmc(m_mov,applyoffset(ax,offset),rx)
			offset+:=8
		od

	elsif nwords<>0 then		!use a loop

!SPLIT INTO xx VERSIONS:
! NWORDS IS A MULTIPLE OF 4, so can write 4 words at a time, in 1/4 of iterations
! Or do one word at a time like now.
! nword is a multiple of 4 happens when N is a multiple of 32 bytes, which will
! always be the case for power-of-two sizes of 32 bytes or more. 32/64 may already
! be done without a loop. So non-part-unrolled version only really for odd array or
! struct sizes, such as [100]char.

		if nwords iand 3 then		!not 4n

			rcount:=mgenreg(countreg:=getworkireg())
			lab:=++mlabelno

			ax:=makesimpleaddr(ax)

			genmc(m_mov,rcount,mgenint(nwords))
			genmc(m_labelx,mgenlabel(lab))
			genmc(m_mov,ax,rx)

			genmc(m_add,mgenreg(ax.reg),mgenint(8))

			genmc(m_dec,rcount)
			genmc_cond(m_jmpcc,ne_cond,mgenlabel(lab))

			offset:=0
		else
			rcount:=mgenreg(countreg:=getworkireg())
			lab:=++mlabelno

			ax:=makesimpleaddr(ax)
			genmc(m_mov,rcount,mgenint(nwords/4))
			genmc(m_labelx,mgenlabel(lab))

			for i to 4 do
				genmc(m_mov,applyoffset(ax,offset),rx)
				offset+:=8
			od

			genmc(m_add,mgenreg(ax.reg),mgenint(targetsize*4))

			genmc(m_dec,rcount)
			genmc_cond(m_jmpcc,ne_cond,mgenlabel(lab))

			offset:=0
		fi
	fi

	if oddbytes then
		n:=oddbytes						!1..7

		if n>=4 then
			rx:=changeopndsize(rx,4)
			genmc(m_mov,applyoffset(ax,offset,4),rx)
			n-:=4
			offset+:=4
		fi
		if n>=2 then
			rx:=changeopndsize(rx,2)
			genmc(m_mov,applyoffset(ax,offset,2),rx)
			n-:=2
			offset+:=2
		fi
		if n=1 then
			rx:=changeopndsize(rx,1)
			genmc(m_mov,applyoffset(ax,offset,1),rx)
		fi
	fi
end

global proc do_blockdata(pcl p) =
	ref byte s
	ref u64 d
	int n,nqwords,nwords,r

	n:=p.size
	return when n=0

	nwords:=n/8

	d:=cast(p.svalue)
	to nwords do
		genmc(m_dq, mgenint(d++^))
	od

	r:=n-nwords*8
	if r then
		genstring_db(cast(d), r, 'B')
	fi
	MGENCOMMENT("ENDDATA")

end

global proc copyblock(mclopnd ax,bx, int n, savedest=1)=
!ax,bx refer to memory; do ax:=bx for n bytes
!savedest=1 to ensure that the value in ax register is not modified

	mclopnd rx, rcount
	int nwords, lab, oddbytes, offset, workreg, countreg, axreg
	byte saved:=0

	if n=16 then
!		rx:=getworkregm(tur64)
		rx:=getworkregm(tpr64)
!
		genmc(m_movdqu, rx, bx)
		genmc(m_movdqu, ax, rx)

!		genmc(m_movdqa, rx, bx)
!		genmc(m_movdqa, ax, rx)

		return
	fi

	oddbytes:=n rem 8		!will be zero, or 1..7
	n-:=oddbytes			!n will always be a multiple of 8; n can be zero too
	nwords:=n/8				!number of u64s (ie. octobytes)

	rx:=getworkregm(tpu64)		!work reg

	offset:=0

	if 1<=nwords<=4 then		!use unrolled code (no loop)
		ax:=changeopndsize(ax, targetsize)
		bx:=changeopndsize(bx, targetsize)

		to nwords do
			genmc(m_mov, rx, applyoffset(bx, offset))
			genmc(m_mov, applyoffset(ax, offset), rx)
			offset+:=8
		od

	elsif nwords<>0 then		!use a loop
		rcount:=getworkregm(tpu64)
		lab:=++mlabelno
		if savedest then
			axreg:=ax.reg
			genmc(m_push, mgenreg(axreg))
			saved:=1
		fi

		ax:=makesimpleaddr(ax)
		bx:=makesimpleaddr(bx)
		ax.size:=8

		genmc(m_mov, rcount, mgenint(nwords))
		genmc(m_labelx, mgenlabel(lab))
		genmc(m_mov, rx, bx)
		genmc(m_mov, ax, rx)

		genmc(m_add, mgenreg(ax.reg), mgenint(targetsize))
		genmc(m_add, mgenreg(bx.reg), mgenint(targetsize))

		genmc(m_dec, rcount)
		genmc_cond(m_jmpcc, ne_cond, mgenlabel(lab))

		offset:=0
	fi

	if oddbytes then
		n:=oddbytes						!1..7

		if n>=4 then
			rx:=changeopndsize(rx, 4)
			genmc(m_mov, rx, applyoffset(bx, offset, 4))
			genmc(m_mov, applyoffset(ax, offset, 4), rx)
			n-:=4
			offset+:=4
		fi
		if n>=2 then
			rx:=changeopndsize(rx, 2)
			genmc(m_mov, rx, applyoffset(bx, offset, 2))
			genmc(m_mov, applyoffset(ax, offset, 2), rx)
			n-:=2
			offset+:=2
		fi
		if n=1 then
			rx:=changeopndsize(rx, 1)
			genmc(m_mov, rx, applyoffset(bx, offset, 1))
			genmc(m_mov, applyoffset(ax, offset, 1), rx)
		fi
	fi
	if saved then
		genmc(m_pop, mgenreg(axreg))
	fi
end

global proc genstringtable=
	ref constrec p

	return unless cstringlist

	mgencomment("String Table")

	setsegment('I',8)

	if kk0used then
		genmc(m_labelx,mgenlabel(kk0used))
		gendb(0)
	fi

	p:=cstringlist
	while p, p:=p.nextconst do
		genmc(m_labelx,mgenlabel(p.labelno))
		genstring_db(p.svalue, p.slength, strtype:1)
	od
end

global proc genstring_db(ichar s, int length, strtype)=
!string table generated in ax pass, so is just text
!this is target-specific, so should really be moved
!strtype should be zero for a normal string, then a zero-terminator is added.
	int i, c, seqlen
	ref char seq

	if length=-1 then
		length:=strlen(s)
	fi

	if length=0 then
		gendb(0)
		return
	fi

	seqlen:=0

	to length do
		c:=s++^
!		if c<32 or c>=127 or c='\"' then
		if c<32 or c>=127 or c in ['\"', '\\'] then
			if seqlen then
				gendbstring(seq, seqlen)
				seqlen:=0
			fi
			gendb(c)
		else
			if seqlen=0 then
				seqlen:=1
				seq:=s-1
			else
				++seqlen
			fi
		fi
	od
	if seqlen then
		gendbstring(seq,seqlen)
	fi
	if strtype=0 then
		gendb(0)
	fi
end

proc gendb(int a)=
	genmc(m_db,mgenint(a))
end

proc gendbstring(ichar s, int length)=
!string is printable, and doesn't include double quotes
	genmc(m_ascii,mgenstring(s,length))
end

proc gendq(int a)=
	genmc(m_dq,mgenint(a))
end

global proc genrealtable=
	ref constrec p

	return unless creallist or cr32list

	mgencomment("Real Table")
	setsegment('I',8)
	p:=creallist
	while p, p:=p.nextconst do
		genmc(m_labelx,mgenlabel(p.labelno))

		if p.xvalue=infinity then
			genmc(m_dq, mgenint(u64@(p.xvalue)))
		else
			genmc(m_dq, mgenint(u64@(p.xvalue)))
!			genmc(m_dq, mgenrealimm(p.xvalue,tpr64))
!			genmc(m_dq, mgenrealimm(p.xvalue,tpr64))
		fi
	od

	mgencomment("Real32 Table")
	p:=cr32list
	while p, p:=p.nextconst do
		genmc(m_labelx,mgenlabel(p.labelno))
		if p.xvalue=infinity then
			genmc(m_dd, mgenint(i32@(r32(p.xvalue))))
		else
			genmc(m_dd, mgenrealimm(p.xvalue,tpr32))
		fi

	od
end

global proc genabsneg=
	if lababs32+lababs64+labneg32+labneg64 then
		setsegment('I',16)
	fi

	if lababs32 then
		mgencomment("lababs32")
		genmc(m_labelx,mgenlabel(lababs32))
		gendq(0x7FFF'FFFF'7FFF'FFFF)
		gendq(0x7FFF'FFFF'7FFF'FFFF)
	fi
	if lababs64 then
		mgencomment("lababs64")
		genmc(m_labelx,mgenlabel(lababs64))
		gendq(0x7FFF'FFFF'FFFF'FFFF)
		gendq(0x7FFF'FFFF'FFFF'FFFF)
	fi

	if labneg32 then
		mgencomment("labneg32")
		genmc(m_labelx,mgenlabel(labneg32))
		gendq(0x8000'0000'8000'0000)
		gendq(0x8000'0000'8000'0000)
	fi
	if labneg64 then
		mgencomment("labneg64")
		genmc(m_labelx,mgenlabel(labneg64))
		gendq(0x8000'0000'0000'0000)
		gendq(0x8000'0000'0000'0000)
	fi

	if labzero then
		mgencomment("labzero")
		genmc(m_labelx,mgenlabel(labzero))
		gendq(0)
	fi

	if labmask63 then
		mgencomment("mask63/offset64")
		genmc(m_labelx,mgenlabel(labmask63))
		gendq(0x7FFF'FFFF'FFFF'FFFF)
		genmc(m_labelx,mgenlabel(laboffset64))
		gendq(0x43E0'0000'0000'0000)
	fi
end

global proc do_maths(pcl p, ichar opname, int nargs=1)=
	do_callrts(p, opname, nil, nargs)
end

global proc do_host(pcl p, psymbol d, int nargs=1)=
	do_callrts(p, nil, d, nargs)
end

global proc do_callrts(pcl p, ichar opname, psymbol d, int nargs)=
	int slots

	saveopnds(nargs)
	slots:=0

	if mstackdepth.odd then
		pushslots(1)
		slots:=1
	fi

	do_pushlowargs(nargs, pstack:1)

	if mstackdepth then
		slots+:=4
		pushslots(4)					!shadowspace
	else
		localshadow:=1
	fi

	if opname then
		genmc(m_call, mgenextname(opname))
	else
		genmc(m_call, mgenmemaddr(d))
	fi

	to nargs do
		poppcl()
	od

	if slots then
		popslots(slots)
	fi

	do_getretvalue(p)
end

global proc do_max_int(int cond)=
	mclopnd ax,bx

	ax:=loadopnd(yy, pmode)
	bx:=loadopnd(zz, pmode)

	genmc(m_cmp, ax, bx)
	genmc_cond(m_cmovcc, cond, ax, bx)

	poppcl()
end

global proc do_max_float(int opc)=
	mclopnd ax,bx
	ax:=loadopnd(yy, pmode)
	bx:=getopnd(zz, pmode)
	genmc(opc,ax,bx)
	poppcl()
end

global proc do_maxto_int(int cond, mode)=
	mclopnd ax,bx,lx
	int lab

!	if size<8 then merror("min/maxto size?") fi

	ax:=getopnd_ind(zz, pmode)
	bx:=loadopnd(yy, pmode)

	genmc(m_cmp, ax, bx)
	lab:=++mlabelno

	genmc_cond(m_jmpcc, cond, lx:=mgenlabel(lab))
	genmc(m_mov, ax,bx)
	genmc(m_labelx, lx)
	poppcl()
	poppcl()
end

global proc do_maxto_real(int cond, mode)=
	mclopnd px,ax,bx,lx
	int lab

	px:=getopnd_ind(zz, mode)
	bx:=loadopnd(yy, mode)

	pushpcl_reg(mode)

	ax:=getopnd(yy, pmode)

	genmc(m_mov, ax, px)

	genmc(m_comiss+ispwide(mode), ax, bx)
	lab:=++mlabelno

	genmc_cond(m_jmpcc, cond, lx:=mgenlabel(lab))
	genmc(m_mov, px,bx)
	genmc(m_labelx, lx)
	poppcl()
	poppcl()
	poppcl()
end

global proc do_negreal(mclopnd ax, int mode)=
	if ispwide(pmode) then
		if not labneg64 then labneg64:=mcreatefwdlabel() fi
		genmc(m_xorpd, ax, mgenlabelmem(labneg64))
	else
		if not labneg32 then labneg32:=mcreatefwdlabel() fi
		genmc(m_xorps, ax, mgenlabelmem(labneg32))
	fi
end

global proc do_absreal(mclopnd ax, int mode)=
	if ispwide(pmode) then
		if not lababs64 then lababs64:=mcreatefwdlabel() fi
		genmc(m_andpd, ax, mgenlabelmem(lababs64))
	else
		if not lababs32 then lababs32:=mcreatefwdlabel() fi
		genmc(m_andps, ax, mgenlabelmem(lababs32))
	fi
end

global proc do_loadbf_const(pcl p, int i, j) =
	mclopnd ax, mx
	word mask

	ax:=loadopnd(xx, pmode)

	if j=63 then			!signed field includes sign bit; assume i>0
		genmc(m_sar, ax, mgenint(i))
	else

		if i then
			genmc(m_shr, ax, mgenint(i))
		fi

		mask:=inot(0xFFFF'FFFF'FFFF'FFFF<<(j-i+1))
		if mask<=word(i32.max) then			!use immediate
			genmc(m_andx, ax, mgenint(mask))
		else
			mx:=loadopnd(yy, tpu64)
			genmc(m_mov, mx, mgenint(mask))
			genmc(m_andx, ax, mx)
		fi
	fi

	poppcl()
	poppcl()
end

global proc do_loadbf_var(pcl p) =
	merror("LOADBF_VAR")
end

global proc do_storebit(pcl p) =
!yy.[zz]:=xx; y.[z]:=x or b.[c]:=a
	mclopnd px, ax, cx, ix
	pcl q, r
	int i, offset
	byte mask1s, mask0s

	q:=isimmload(zz)
	r:=isimmload(xx)

	if q then						!a.[k] := 0/1/x
		px:=getopnd_ind(yy, tpu8)	!update only a specific byte
		i:=q.value	
		offset:=i/8					! byte offset 0..7
		i iand:=7					! i will be bit index 0..7
		px:=applyoffset(px, offset)	! point to that byte

		mask0s:=1<<i				!eg 00001000
		mask1s:=inot(1<<i)			!eg 11110111

		if r then
			if r.value=0 then
				genmc(m_andx, px, mgenint(mask1s, pmode))
			else
				genmc(m_orx, px, mgenint(mask0s, pmode))
			fi
		else
			ax:=loadopnd(xx, tpu8)
			genmc(m_andx, px, mgenint(mask1s, pmode))		!clear dest bit first
			if i then
				genmc(m_shl, ax, mgenint(i, tpu8))
			fi
			genmc(m_orx, px, ax)							!add in 0 or 1
		fi
	elsif r then								!A.[i]:=0/1/x
		px:=getopnd_ind(yy, pmode)				!update whole dest word

		if q=nil then								!A.[i]:=0/1
			ax:=getworkregm(tpu64)
			genmc(m_mov, ax, mgenint(1))
			
			cx:=mgenreg(r10,tpu64)
			genmc(m_push, cx) when r10used
			ix:=loadparam(zz, tpi64, r10)
			genmc(m_shl, ax, changeopndsize(cx, 1))
			genmc(m_pop, cx) when r10used

!Now have 00001000 for ezzmple in ax
			if r.value=0 then
				genmc(m_notx, ax)				!change to 111101111
				genmc(m_andx, px, ax)			!set to 0
			else								!set to 1 (assume r.value was 1)
				genmc(m_orx, px, ax)
			fi

		else									!A.[i]:=x
			merror("STOREBIT/VAR")
		fi
	else
			merror("Storebit: both vars")
	fi

	poppcl()
	poppcl()
	poppcl()
end

global proc do_storebf(pcl p) =
	mclopnd ax,rx,mx,mx4,dx
	int i,j
	pcl q, r
	word mask

	q:=isimmload(yy)
	r:=isimmload(zz)

	if q=r=nil then
		merror("storebf not imm")
	fi

	dx:=loadopnd(ww, pmode)

	ax:=getopnd_ind(xx, pmode)

	i:=q.value
	j:=r.value

	mx:=getworkregm(tpu64)
	rx:=getworkregm(pmode)

	genmc(m_mov, rx, ax)

	mask:=inot((inot(0xFFFF'FFFF'FFFF'FFFF<<(j-i+1)))<<i)

	genmc(m_mov, mx, mgenint(mask))

	if i then
		genmc(m_shl, dx, mgenint(i))
	fi

	genmc(m_andx, rx, changeopndsize(mx, p.size))
	genmc(m_orx, rx, dx)

	genmc(m_mov, ax, changeopndsize(rx, p.size))

	poppcl()			!j
	poppcl()			!i
	poppcl()			!A
	poppcl()			!x?
end

global func gethostfn(int opc)psymbol d =
	ichar name, namec

	if igethostfn=nil then

!try manual seach through pcl code
		case opc
		when kpower then
			name:="msys.m$power_i64"		!msys or msysc
			namec:="msysc.m$power_i64"
		else
			name:=nil
		esac

		if name then
			psymbol ps:=psymboltable
			while ps, ps:=ps.next do
				if eqstring(name, ps.name) or eqstring(namec, ps.name) then
					return ps
				fi
			od
		fi

		merror("gethostfn?", pclnames[opc])
	fi

	d:=igethostfn(opc)
	if d=nil then
		merror("No host fn:", pclnames[opc])
	fi
	d
end

global proc copyblockarg(mclopnd px, int size, ARGNO)=
!px refers to a block in a parameter register
!if px is nil, then called for block in zz that will be pushed

!copy the block to a block temp, and change px's register to
!refer to that new block

	psymbol dblock
	mclopnd ax, bx, axi, bxi

	IF PX=NIL THEN
		println "High block arg not copied in", currfunc.name,,"()"
		return
	FI

	dblock:=newblocktemp(size)
	dblock.used:=1


	if px then
		bx:=getworkregm(tpref)			!copy of px
		genmc(m_mov, bx, px)
	else
		bx:=loadopnd(zz, tpblock)
	fi
	ax:=getworkregm(tpref)			!refer to temp block

	genmc(m_lea, ax, mgenmem(dblock))

	copyblock(mgenireg(ax.reg), mgenireg(bx.reg), size)

	if px then
		genmc(m_lea, px, mgenmem(dblock))		!param points to temp
!	else
!		gen
	fi

!note: this is needed since there may be other blocks passed before the end
!of a CALL op, as those ax/bx regs would be tied up
!caller should ensure no workregs are in use

	freeworkregs(nil)
end

global proc fixmain=
!d is a main func with 2 params
!convert params to locald, add more locals needed for calling __getmainargs
	psymbol d:=currfunc, e
	psymbol dn, dargs, denv, dinfo
	mclopnd ax

	dn:=d.nextparam
	dargs:=dn.nextparam

!add 2 new locals
!	denv:=pc_makesymbol("$env", local_id)
	denv:=pc_makesymbol("$env", static_id)
	denv.mode:=tpref
	denv.size:=8
!DENV.USED:=1

!	dinfo:=pc_makesymbol("$info", local_id)
	dinfo:=pc_makesymbol("$info", static_id)
	dinfo.mode:=tpblock
	dinfo.size:=128
!DINFO.USED:=1

	setsegment('Z',8)
	genmc(m_labelx, mgenmemaddr(dinfo))
	genmc(m_resb, mgenint(128))
	genmc(m_labelx, mgenmemaddr(denv))
	genmc(m_resb, mgenint(8))
	setsegment('C',1)
	pc_addlocal(denv)
	pc_addlocal(dinfo)

!remove dn/dargs as params

	dn.nextparam:=dargs.nextparam:=d.nextparam:=nil
	d.nparams:=0
	dn.id:=local_id
	dn.used:=1
	dargs.id:=local_id
	dargs.used:=local_id
!
!add them as locals

	pc_addlocal(dargs)
	pc_addlocal(dn)

	genmc(m_push, ax:=mgenreg(r0))
	genmc(m_lea , ax, mgenmem(dinfo))
	DINFO.ADDROF:=1
	genmc(m_push, ax)
	genmc(m_sub, dstackopnd, mgenint(32))
	genmc(m_lea,  mgenreg(r10), mgenmem(dn))
	DN.ADDROF:=1
	genmc(m_lea,  mgenreg(r11), mgenmem(dargs))
	DARGS.ADDROF:=1
	genmc(m_lea,  mgenreg(r12), mgenmem(denv))
	DENV.ADDROF:=1
	clearreg(mgenreg(r13))
	genmc(m_call, mgenextname("__getmainargs*"))
!
	genmc(m_sub, dstackopnd, mgenint(48))

!do pcmdskip fixes
	if pcmdskip then
		genmc(m_sub, mgenmem(dn), mgenint(pcmdskip, tpi32))
		genmc(m_add, mgenmem(dargs), mgenint(pcmdskip*8))
	fi

end
=== mc_decls.m 0 0 36/108 ===
export type mclopnd = ref mclopndrec

export record mclopndrec =
!	ref pstrec labeldef	!nil, or handle of strec for label
	union
		psymbol def
		i64 value		!immediate value
		r64 xvalue	!immediate real value, mainly for dq
		ichar svalue	!immediate string
		int labelno
		int sysfn
		int tempno
	end

	u16 misc: (			! bitfields
		size:5,		! one of 1 2 4 8
		scale:4,		! one of 1 2 4 8
		mode:3,			! R, X, imm, [mem]
		valtype:4)

	byte reg			!0, or main register
	byte regix			!0, or index register
	i32 offset			!additional offset to memory operands
end

export record mclrec = !$caligned
	ref mclrec lastmcl, nextmcl
	mclopnd a,b
	byte c
	byte opcode
	byte cond
	byte spare1
	u32 seqno
	union
		u32 mpos
		u32 lineno				!used by aa assembler
	end
	u32 spare2

	union
		[r0..r15]byte regfreed		!1 indicates work-register freed after this instr
		pair regfreedpr
	end
end

export enumdata [0:]ichar valtypenames =
	(no_val=0,		$),		!no operand
	(intimm_val,	$),		!immediate int
	(realimm_val,	$),		!immediate real (mainly for dq etc)
	(realmem_val,	$),		!indirect real (for movq etc)
	(stringimm_val,	$),		!immediate string, for comments, or address of string etc
	(def_val,		$),		!var/proc name
	(label_val,		$),		!label index
!	(labelind_val,	$),		!label index
	(name_val,		$),		!immediate string must be output as ah unquoted name
	(temp_val,		$),		!index of pclopnd temp (later becomes ptr to descriptor?)
!	(syscall_val,	$),		!
end

export enumdata []ichar mclnames, []byte mclnopnds, []byte mclcodes =

	(m_procstart,		$,		0,		0),		!
	(m_procend,			$,		0,		0),		!
	(m_comment,			$,		0,		0),		!
!	(m_blank,			$,		0,		0),		!
!	(m_deleted,			$,		0,		0),		!
	(m_labelname,		$,		0,		0),		!
	(m_define,			$,		0,		0),		!
	(m_definereg,		$,		0,		0),		!
!	(m_definetemp,		$,		0,		0),		!
	(m_trace,			$,		0,		0),		!
	(m_endx,			$,		0,		0),		!

	(m_labelx,			$,		1,		0),		!
	(m_nop,				$,		0,		0x90),		!
!	(m_param,			$,		1,		0),		!
!	(m_assembly,		$,		1,		0),		!
!	(m_proc,			$,		1,		0),		!

	(m_mov,				$,		2,		0),		!
	(m_push,			$,		1,		0),		!
	(m_pop,				$,		1,		0),		!
	(m_lea,				$,		2,		0),		!
	(m_cmovcc,			$,		2,		0),		!

	(m_movd,			$,		2,		0),		!
	(m_movq,			$,		2,		0),		!

	(m_movsx,			$,		2,		0),		!
	(m_movzx,			$,		2,		0),		!
	(m_movsxd,			$,		2,		0),		!

	(m_call,			$,		1,		0xE8),		!
	(m_ret,				$,		0,		0xC3),	!
	(m_leave,			$,		0,		0xC9),	!
	(m_retn,			$,		1,		0),		!

	(m_jmp,				$,		1,		0xE9),	!
	(m_jmpcc,			$,		1,		0),		!
	(m_xchg,			$,		2,		0),		!

	(m_add,				$,		2,		0),		!
	(m_sub,				$,		2,		5),		!
	(m_adc,				$,		2,		2),		!
	(m_sbb,				$,		2,		3),		!
	(m_imul,			$,		1,		5),		!
	(m_mul,				$,		1,		4),		!
	(m_imul2,			$,		2,		0),		!
	(m_imul3,			$,		3,		0),		!

	(m_idiv,			$,		1,		7),		!
	(m_div,				$,		1,		6),		!

	(m_andx,			$,		2,		0x04),	!
	(m_orx,				$,		2,		0x01),	!
	(m_xorx,			$,		2,		0x06),	!
	(m_test,			$,		2,		0),		!

	(m_cmp,				$,		2,		0x07),	!

	(m_shl,				$,		2,		0x04),	!
	(m_sar,				$,		2,		0x07),	!
	(m_shr,				$,		2,		0x05),	!
	(m_rol,				$,		2,		0x00),	!
	(m_ror,				$,		2,		0x01),	!
	(m_rcl,				$,		2,		0x02),	!
	(m_rcr,				$,		2,		0x03),	!

	(m_neg,				$,		1,		3),		!
	(m_notx,			$,		1,		2),		!

	(m_inc,				$,		1,		0),		!
	(m_dec,				$,		1,		1),		!

	(m_cbw,				$,		0,		0),	!
	(m_cwd,				$,		0,		0),	!
	(m_cdq,				$,		0,		0),		!
	(m_cqo,				$,		0,		0),		!
	(m_setcc,			$,		1,		0),		!

	(m_bsf,				$,		2,		0xBC),	!
	(m_bsr,				$,		2,		0xBD),	!

	(m_shld,			$,		2,		0xA4),	!
	(m_shrd,			$,		2,		0xAC),	!

	(m_sqrtss,			$,		2,		0x51),	!
	(m_sqrtsd,			$,		2,		0x51),	!

	(m_addss,			$,		2,		0x58),	!
	(m_addsd,			$,		2,		0x58),	!

	(m_subss,			$,		2,		0x5C),	!
	(m_subsd,			$,		2,		0x5C),	!

	(m_mulss,			$,		2,		0x59),	!
	(m_mulsd,			$,		2,		0x59),	!

	(m_divss,			$,		2,		0x5E),	!
	(m_divsd,			$,		2,		0x5E),	!

	(m_comiss,			$,		2,		0),		!
	(m_comisd,			$,		2,		0x2F),	!
	(m_ucomisd,			$,		2,		0x2E),	!

	(m_xorps,			$,		2,		0x57),	!
	(m_xorpd,			$,		2,		0x57),	!

	(m_andps,			$,		2,		0x54),	!
	(m_andpd,			$,		2,		0x54),	!

	(m_pxor,			$,		2,		0xEF),	!
	(m_pand,			$,		2,		0xDB),	!

	(m_cvtss2si,		$,		2,		0),		!
	(m_cvtsd2si,		$,		2,		0),		!

	(m_cvttss2si,		$,		2,		0),		!
	(m_cvttsd2si,		$,		2,		0),		!

	(m_cvtsi2ss,		$,		2,		0),		!
	(m_cvtsi2sd,		$,		2,		0),		!

	(m_cvtsd2ss,		$,		2,		0),		!
	(m_cvtss2sd,		$,		2,		0),		!

	(m_movdqa,			$,		2,		0x66),	!
	(m_movdqu,			$,		2,		0xF3),	!

	(m_pcmpistri,		$,		3,		0x63),	!
	(m_pcmpistrm,		$,		3,		0x62),	!

	(m_fld,				$,		1,		0),		!
	(m_fst,				$,		1,		2),		!
	(m_fstp,			$,		1,		3),		!

	(m_fild,			$,		1,		0),		!
	(m_fist,			$,		1,		2),		!
	(m_fistp,			$,		1,		3),		!

	(m_fadd,			$,		0,		0xC1),	!
	(m_fsub,			$,		0,		0xE9),	!
	(m_fmul,			$,		0,		0xC9),	!
	(m_fdiv,			$,		0,		0xF9),	!
	(m_fsqrt,			$,		0,		0xFA),	!
	(m_fsin,			$,		0,		0xFE),	!
	(m_fcos,			$,		0,		0xFF),	!
	(m_fsincos,			$,		0,		0xFB),	!
	(m_fptan,			$,		0,		0xF2),	!
	(m_fpatan,			$,		0,		0xF3),	!
	(m_fabs,			$,		0,		0xE1),	!
	(m_fchs,			$,		0,		0xE0),	!

	(m_minss,			$,		2,		0x5D),	!
	(m_maxss,			$,		2,		0x5F),	!
	(m_minsd,			$,		2,		0x5D),	!
	(m_maxsd,			$,		2,		0x5F),	!

	(m_db,				$,		1,		0),		!
	(m_dw,				$,		1,		0),		!
	(m_dd,				$,		1,		0),		!
	(m_dq,				$,		1,		0),		!
	(m_ascii,			$,		1,		0),		!
!	(m_ddoffset,		$,		1,		0),		!

!	(m_segment,			$,		1,		0),		!
	(m_isegment,		$,		0,		0),		!
	(m_zsegment,		$,		0,		0),		!
	(m_csegment,		$,		0,		0),		!

	(m_align,			$,		1,		0),		!
	(m_resb,			$,		1,		1),		!
	(m_resw,			$,		1,		2),		!
	(m_resd,			$,		1,		4),		!
	(m_resq,			$,		1,		8),		!

	(m_xlat,			$,		0,		0xD7),	!
	(m_loopnz,			$,		1,		0xE0),	!
	(m_loopz,			$,		1,		0xE1),	!
	(m_loopcx,			$,		1,		0xE2),	!
	(m_jecxz,			$,		1,		0xE3),	!
	(m_jrcxz,			$,		1,		0xE3),	!

	(m_cmpsb,			$,		0,		0),		!
	(m_cmpsw,			$,		0,		0),		!
	(m_cmpsd,			$,		0,		0),		!
	(m_cmpsq,			$,		0,		0),		!

	(m_rdtsc,			$,		0,		0x31),	!
	(m_popcnt,			$,		2,		0),		!
	(m_bswap,			$,		1,		0),		!

	(m_finit,			$,		0,		0),		!

	(m_fldz,			$,		0,		0xEE),	!
	(m_fld1,			$,		0,		0xE8),	!
	(m_fldpi,			$,		0,		0xEB),	!
	(m_fld2t,			$,		0,		0xE9),	!
	(m_fld2e,			$,		0,		0xEA),	!
	(m_fldlg2,			$,		0,		0xEC),	!
	(m_fldln2,			$,		0,		0xED),	!

	(m_cpuid,			$,		0,		0),		!

	(m_xxxx,			$,		0,		0xF4),	!
	(m_halt,			$,		0,		0xF4),	!
end

export enumdata [0:]ichar regnames, [0:]byte regcodes =
	(rnone=0,	$,	0),			!
	(r0,		$,	0),			!d0 rax
	(r1,		$,	10),		!d1 r10
	(r2,		$,	11),		!d2 r11
	(r3,		$,	7),			!d3 rdi
	(r4,		$,	3),			!d4 rbx
	(r5,		$,	6),			!d5 rsi
	(r6,		$,	12),		!d6 r12
	(r7,		$,	13),		!d7 r13
	(r8,		$,	14),		!d8 r14
	(r9,		$,	15),		!d9 r15
	(r10,		$,	1),			!d10 rcx
	(r11,		$,	2),			!d11 rdx
	(r12,		$,	8),			!d12 r8
	(r13,		$,	9),			!d13 r9
	(r14,		$,	5),			!d14 rbp
	(r15,		$,	4),			!d15 rsp

	(r16,		$,	4),			!b0h ah
	(r17,		$,	7),			!b1h bh
	(r18,		$,	5),			!b10h ch
	(r19,		$,	6),			!b11h dh
end

export const rframe = r14
export const rstack = r15

export enumdata [0:]ichar condnames, [0:]ichar asmcondnames,
		[0:]int asmrevcond =

	(ov_cond=0,	"ov",	"o",		nov_cond),
	(nov_cond,	"nov",	"no",		ov_cond),

	(ltu_cond,	"ltu",	"b",		geu_cond),
	(geu_cond,	"geu",	"ae",		ltu_cond),

	(eq_cond,	"eq",	"z",		ne_cond),
	(ne_cond,	"ne",	"nz",		eq_cond),

	(leu_cond,	"leu",	"be",		gtu_cond),
	(gtu_cond,	"gtu",	"a",		leu_cond),

	(s_cond,	"s",	"s",		ns_cond),
	(ns_cond,	"ns",	"ns",		s_cond),

	(p_cond,	"p",	"p",		np_cond),
	(np_cond,	"np",	"np",		p_cond),

	(lt_cond,	"lt",	"l",		ge_cond),
	(ge_cond,	"ge",	"ge",		lt_cond),

	(le_cond,	"le",	"le",		gt_cond),
	(gt_cond,	"gt",	"g",		le_cond),

	(flt_cond,	"flt",	"b",		fge_cond),		!special floating point codes
	(fge_cond,	"fge",	"ae",		flt_cond),
	(fle_cond,	"fle",	"be",		fgt_cond),
	(fgt_cond,	"fgt",	"a",		fle_cond)
end

global const z_cond = eq_cond
global const nz_cond = ne_cond

!I use my own register designations Dn, An, Wn, Bn (8,4,2,1 bytes),
!which have a more sensible order than the official ones.
!The mapping is shown against Dn. Some (not all) of the official register
!names are used too

!Regindex is the ordinal value used to represent the register: 1..16
!This table is intended for initialising the global symbol table

export tabledata []ichar dregnames, []byte regsizes, []byte regindices =
	("d0",		8,	r0),		!rax	d0..d9 are for general use
	("d1",		8,	r1),		!r10	d0..d2 are volatile in ABI
	("d2",		8,	r2),		!r11

	("d3",		8,	r3),		!rdi	d3..d9 are preserved across funcs in ABI
	("d4",		8,	r4),		!rbx
	("d5",		8,	r5),		!rsi
	("d6",		8,	r6),		!r12
	("d7",		8,	r7),		!r13
	("d8",		8,	r8),		!r14
	("d9",		8,	r9),		!r15

	("d10",		8,	r10),		!rcx	d10..d13 are win64 ABI register passing regs
	("d11",		8,	r11),		!rdx	..
	("d12",		8,	r12),		!r8		..
	("d13",		8,	r13),		!r9		..

	("d14",		8,	r14),		!rbp	frame pointer
	("d15",		8,  r15),		!rsp	stack pointer

	("a0",		4,	r0),
	("a1",		4,	r1),
	("a2",		4,	r2),
	("a3",		4,	r3),
	("a4",		4,	r4),
	("a5",		4,	r5),
	("a6",		4,	r6),
	("a7",		4,	r7),
	("a8",		4,	r8),
	("a9",		4,	r9),
	("a10",		4,	r10),
	("a11",		4,	r11),
	("a12",		4,	r12),
	("a13",		4,	r13),
	("a14",		4,	r14),
	("a15",		4,  r15),

	("w0",		2,	r0),
	("w1",		2,	r1),
	("w2",		2,	r2),
	("w3",		2,	r3),
	("w4",		2,	r4),
	("w5",		2,	r5),
	("w6",		2,	r6),
	("w7",		2,	r7),
	("w8",		2,	r8),
	("w9",		2,	r9),
	("w10",		2,	r10),
	("w11",		2,	r11),
	("w12",		2,	r12),
	("w13",		2,	r13),
	("w14",		2,	r14),
	("w15",		2,  r15),


	("b0",		1,	r0),
	("b1",		1,	r1),
	("b2",		1,	r2),
	("b3",		1,	r3),
	("b4",		1,	r4),
	("b5",		1,	r5),
	("b6",		1,	r6),
	("b7",		1,	r7),
	("b8",		1,	r8),
	("b9",		1,	r9),
	("b10",		1,	r10),
	("b11",		1,	r11),
	("b12",		1,	r12),
	("b13",		1,	r13),
	("b14",		1,	r14),
	("b15",		1,  r15),
	("b16",		1,  r16),
	("b17",		1,  r17),
	("b18",		1,  r18),
	("b19",		1,  r19),

	("_b20",	0,  0),			!dummy entry marks start of official names

	("rax",		8,	r0),
	("rbx",		8,	r4),
	("rcx",		8,	r10),
	("rdx",		8,	r11),
	("rsi",		8,	r5),
	("rdi",		8,	r3),
	("rbp",		8,	r14),
	("rsp",		8,	r15),
	("r8",		8,	r12),
	("r9",		8,	r13),
	("r10",		8,	r1),
	("r11",		8,	r2),
	("r12",		8,	r6),
	("r13",		8,	r7),
	("r14",		8,	r8),
	("r15",		8,	r9),

	("eax",		4,	r0),
	("ebx",		4,	r4),
	("ecx",		4,	r10),
	("edx",		4,	r11),
	("esi",		4,	r5),
	("edi",		4,	r3),
	("ebp",		4,	r14),
	("esp",		4,	r15),
	("r8d",		4,	r12),
	("r9d",		4,	r13),
	("r10d",	4,	r1),
	("r11d",	4,	r2),
	("r12d",	4,	r6),
	("r13d",	4,	r7),
	("r14d",	4,	r8),
	("r15d",	4,	r9),

	("ax",		2,	r0),
	("bx",		2,	r4),
	("cx",		2,	r10),
	("dx",		2,	r11),
	("si",		2,	r5),
	("di",		2,	r3),
	("bp",		2,	r14),
	("sp",		2,	r15),
	("r8w",		2,	r12),
	("r9w",		2,	r13),
	("r10w",	2,	r1),
	("r11w",	2,	r2),
	("r12w",	2,	r6),
	("r13w",	2,	r7),
	("r14w",	2,	r8),
	("r15w",	2,	r9),


	("al",		1,	r0),
	("bl",		1,	r4),
	("cl",		1,	r10),
	("dl",		1,	r11),

	("ah",		1,	r16),
	("bh",		1,	r17),
	("ch",		1,	r18),
	("dh",		1,	r19),

	("sil",		1,	r5),
	("dil",		1,	r3),
	("bpl",		1,	r14),
	("spl",		1,	r15),

	("r8b",		1,	r12),
	("r9b",		1,	r13),
	("r10b",	1,	r1),
	("r11b",	1,	r2),
	("r12b",	1,	r6),
	("r13b",	1,	r7),
	("r14b",	1,	r8),
	("r15b",	1,	r9),

end

export []ichar xmmregnames = (
	"xmm0",
	"xmm1",
	"xmm2",
	"xmm3",
	"xmm4",
	"xmm5",
	"xmm6",
	"xmm7",
	"xmm8",
	"xmm9",
	"xmm10",
	"xmm11",
	"xmm12",
	"xmm13",
	"xmm14",
	"xmm15")

export []ichar fregnames = (
	"st0",
	"st1",
	"st2",
	"st3",
	"st4",
	"st5",
	"st6",
	"st7")

export []ichar mregnames = (
	"mmx0",
	"mmx1",
	"mmx2",
	"mmx3",
	"mmx4",
	"mmx5",
	"mmx6",
	"mmx7")

export tabledata []ichar jmpccnames, []byte jmpcccodes =
	("jo",		ov_cond),
	("jno",		nov_cond),
	("jb",		ltu_cond),
	("jae",		geu_cond),
	("jz",		eq_cond),
	("jnz",		ne_cond),
	("jbe",		leu_cond),
	("ja",		gtu_cond),
	("js",		s_cond),
	("jns",		ns_cond),
	("jp",		p_cond),
	("jnp",		np_cond),
	("jl",		lt_cond),
	("jge",		ge_cond),
	("jle",		le_cond),
	("jg",		gt_cond),
	("jc",		ltu_cond),
	("jnc",		geu_cond),
end


export tabledata []ichar setccnames, []byte setcccodes =
	("seto",	ov_cond),
	("setno",	nov_cond),
	("setb",	ltu_cond),
	("setae",	geu_cond),
	("setz",	eq_cond),
	("setnz",	ne_cond),
	("setbe",	leu_cond),
	("seta",	gtu_cond),
	("sets",	s_cond),
	("setns",	ns_cond),
	("setp",	p_cond),
	("setnp",	np_cond),
	("setl",	lt_cond),
	("setge",	ge_cond),
	("setle",	le_cond),
	("setg",	gt_cond),
end

export tabledata []ichar cmovccnames, []byte cmovcccodes =
	("cmovo",	ov_cond),
	("cmovno",	nov_cond),
	("cmovb",	ltu_cond),
	("cmovae",	geu_cond),
	("cmovz",	eq_cond),
	("cmovnz",	ne_cond),
	("cmovbe",	leu_cond),
	("cmova",	gtu_cond),
	("cmovs",	s_cond),
	("cmovns",	ns_cond),
	("cmovp",	p_cond),
	("cmovnp",	np_cond),
	("cmovl",	lt_cond),
	("cmovge",	ge_cond),
	("cmovle",	le_cond),
	("cmovg",	gt_cond),
end

export enumdata [0:]ichar segmentnames =
	(no_seg=0,		$),
	(code_seg,		$),
	(idata_seg,		$),
	(zdata_seg,		$),
	(rodata_seg,	$),
	(impdata_seg,	$),
end

export enumdata [0:]ichar reftypenames =
	(extern_ref=0,		$),		!is external
	(fwd_ref,			$),		!not yet reached
	(back_ref,			$),		!has been reached
end

export enumdata [0:]ichar opndnames_ma =
	(a_none=0,	$),
	(a_reg,		$),		! Ri
	(a_imm,		$),		! d including def name, label etc
	(a_mem,		$),		! any memory modes: [d], [R], [R*4+R2+d+imm] etc
	(a_cond,	$),		! a condition code for jcc/setcc
	(a_xreg,	$),		! xmm register
end

!global const maxoperands=20
global const maxoperands=50

!following are continually updates as opnds are pushed, moved and popped
global [maxoperands]pcl		pclopnd			!pclrec describing opnd when not loaded
global [maxoperands]byte	pclreg			!>0 means in given register
global [maxoperands]byte	pclmode			!copy of mode, esp. if loaded (indicates reg/xreg)
global [maxoperands]byte	pclcount		!dupl count
global [maxoperands]byte	pclloc			!stores loc code

!following are reset per proc and augmented as it is processed
global [maxoperands]byte pcltempflags		!1 means a temp uses local storage
global [maxoperands]mclopnd pcltempopnds	!store mcl opnd for such a temp

global int noperands						!number of pcl operands, including wide
global int mstackdepth						!hw stack size (pcl operands, + extra for wide, + padding)

global enumdata [0:]ichar locnames =
	(pcl_loc=0,	"pend"),				!operand still in pcl instruction
	(reg_loc,	"reg"),					!is in register (look at mode for reg/xreg)
	(regvar_loc,"regvar"),				!lives in register (look at mode for reg/xreg)
	(temp_loc,	"temp"),				!overflow to temporary
end

global [r0..r15]byte workregs, workxregs		!1 indicates available work regs
global int nworkregs, nworkxregs				!no. workregs assigned
global int nregvars, nxregvars					!no. reg vars allocated (consec regs)
global int maxregvars, maxxregvars				!no. reg vars available

global int xregmax


global [r0..r15]byte regset			!register in-use flags: 0/1: free/in-use
global [r0..r15]byte xregset		!same for xregs

global [r0..r15]byte isregvar
global [r0..r15]byte isxregvar

global record pair =
	u64 low, high
end

global pair regsetpr @ regset
global pair isregvarpr @ isregvar
global const u64 invertbytes = 0x0101'0101'0101'0101

global [r0..r15]byte usedregs		!1 means used during proc
global [r0..r15]byte usedxregs		!1 means used during proc

global byte noxorclear		!1 to suppress xor optimisation

global macro zz = noperands
global macro yy = noperands-1
global macro xx = noperands-2
global macro ww = noperands-3

export enumdata [0:]ichar xregnames =
	(xnone=0,	"-"),
	(xr0,		"xmm0"),
	(xr1,		"xmm1"),
	(xr2,		"xmm2"),
	(xr3,		"xmm3"),
	(xr4,		"xmm4"),
	(xr5,		"xmm5"),
	(xr6,		"xmm6"),
	(xr7,		"xmm7"),
	(xr8,		"xmm8"),
	(xr9,		"xmm9"),
	(xr10,		"xmm10"),
	(xr11,		"xmm11"),
	(xr12,		"xmm12"),
	(xr13,		"xmm13"),
	(xr14,		"xmm15"),
	(xr15,		"xmm15")
end

global const maxcalldepth=16
global [maxcalldepth]byte callalign					!pending 1-slot alignment for syscalls
global [maxcalldepth]byte callblockret				!1 if fnc returns a block
global [maxcalldepth]u32 callblocksize				!size of any returned block
global [maxcalldepth, maxparams]byte callargmode	!arg mode set setarg
global [maxcalldepth, maxparams]u32 callargsize		!size incl block from setarg
global int ncalldepth

global int lababs32, lababs64
global int labneg32, labneg64
global int labmask63, laboffset64
global int labzero
global int kk0used=0

export ref mclrec mccode, mccodex		!genmc adds to this linked list

global int currsegment=0

global mclopnd dstackopnd
global mclopnd dframeopnd

global [r0..r15,1..8]mclopnd regtable

global [-128..64]mclopnd frameregtable

global record constrec =
	union
		int value
		real xvalue
		ichar svalue
	end
	ref constrec nextconst
	int labelno
	int slength
end

global ref constrec cstringlist
global ref constrec vstringlist
global ref constrec creallist
global ref constrec cr32list

global psymbol currasmproc

global int lab_funcnametable
global int lab_funcaddrtable
global int lab_funcnprocs

export record relocrec =			!informal version
	ref relocrec nextreloc
	int reloctype
	int offset
	int stindex
end

!record used for expanding buffers. Expansion is not automatic: buffercheck(n)
!is needed at strategic points to ensure that are at least n bytes left
export record dbuffer =
	ref byte pstart
	union
		ref byte pcurr
		ref u16 pcurr16
		ref u32 pcurr32
		ref u64 pcurr64
	end
	ref byte pend
	int alloc
end

global int ss_zdatalen
global ref dbuffer ss_zdata			!used for error checking only (should be empty at end)
global ref dbuffer ss_idata
global ref dbuffer ss_code
global ref relocrec ss_idatarelocs
global ref relocrec ss_coderelocs
global int ss_nidatarelocs
global int ss_ncoderelocs

!const max_ss_symbols=32768				!exported to coff
global const init_ss_symbols=32768				!exported to coff
!global const init_ss_symbols=16384
global ref []psymbol ss_symboltable
global int ss_nsymbols
global int ss_symboltablesize

global ref[]psymbol labeldeftable

global int aaseqno
global int aapos

!The following are highly dependent on the ordering of the base types being:
! r32 r64 ints... block ..., with r32 having value 1
!They assume mode is not void, and for ispfloat, is not a block

global macro ispwide(m)  = m - 1
global macro ispfloat(m) = m <= tpr64
global macro ispint(m)   = m > tpr64	!when block type is not expected

EXPORT [1..8]byte regmodes=(tpu8, tpu16, 0, tpu32, 0,0,0, tpu64)

global byte pmode
global pcl currpcl

global ref mclrec mclprocentry
global ref mclrec mce_oldmccodex, mce_lastmcl, mce_nextmcl		!used by reset/setmclentry
global ref mclrec mcf_oldmccodex, mcf_lastmcl, mcf_nextmcl		!used by reset/setmclentry for frame setup

!global byte fpshortnames
global byte fpcheckunusedlocals
!export byte phighmem

global record riprec =
	ref riprec next
	u32 offset			!within code segment, offset of d32 field
	i32 immsize			!0,1,4 bytes of trailing imm field
end

!global record fwdrec =
!	ref fwdrec nextfwd
!	i32 offset
!	i16 reltype
!	i16 seg
!end

global ref riprec riplist

!export ref proc (ref void) idomcl_assem
!export ref func (ref void)int icheckasmlabel
!export ref func (int)psymbol igethostfn

global const maxblocktemps=50
global [maxblocktemps]psymbol blockdefs
global int nblocktemps

global []int multregs=(r0,r1,r2,r10,r11,r12)
global []int multxregs=(r0,r1,r2,r3,r4,r5)


global [pstdnames.bounds]byte ploadopx

global [pstdnames.bounds]byte ploadop

proc start=
	for i in ploadop.bounds do ploadop[i]:=m_nop od

	ploadop[tpu8]:=ploadop[tpu16]:=ploadop[tpu32]:=m_movzx
	ploadop[tpi8]:=ploadop[tpi16]:=ploadop[tpi32]:=m_movsx
	ploadop[tpr32]:=m_movd
	ploadop[tpr64]:=m_movq
	ploadop[tpu64]:=ploadop[tpi64]:=m_mov
end

=== mc_disasm.m 0 0 37/108 ===

!const showmregs=1
const showmregs=0

const halt=0xF4

int nmodules
int xfchsmask_pd

enumdata [0:]ichar opnames =
	(add_op=0,	"add"),
	(or_op,		"or"),
	(adc_op,	"adc"),
	(sbb_op,	"sbb"),
	(and_op,	"and"),
	(sub_op,	"sub"),
	(xor_op,	"xor"),
	(cmp_op,	"cmp")
end

[0:]ichar condnames = 
("o", "no", "b","ae","z","nz","be","a","s","ns","p","np",
 "l","ge","le","g")

enumdata []ichar addrmodenames=		! rm modes
	(amreg,			$),				! R
	(ammem,			$),				! [R+d]
	(amrel,			$)				! [RIP+d]
end

const wmask = 2x1000
const rmask = 2x0100
const xmask = 2x0010
const bmask = 2x0001

const rstack=5						!1-base register codes
const rframe=6

int rex

int addrmode						!amreg/ammem/amrel
int rmreg							!0, or 1..16; adjusted middle value of modrm byte
int rmopc							!0 to 7; middle value of modrm byte 
int ripmode							!1 for rip-relative
int basereg							!0, or 1..16
int indexreg						!0, or 1..16
int scale							!1,2,4
int opsize							!1,2,4,8
int offset
int offsetsize						!1 or 4
int sizeoverride					!32=>16 switch
int addroverride					!32=>16 switch
int f2override						!xmm regs
int f3override						!xmm regs

[256]char deststr
ichar destptr

ref byte codeptr

global function decodeinstr(ref byte &cptr,baseaddr=nil)ichar=
!decode next instruction at codeptr
!return 1 if decoded, with codeptr stepped to start of next instruction
!return 0 when end-of-code seen (nop or 0x90)
	int n,w
	int opc,reg,op,xxx,oldopsize,dispsize
	ref byte pstart
	static [256]char str
	[128]char str2
	const maxinstrlen=14
	ichar s

	deststr[1]:=0

	pstart:=codeptr:=cptr

	rex:=0
	opsize:=1
	f2override:=f3override:=sizeoverride:=addroverride:=0
	basereg:=indexreg:=offset:=0

	retry:						!back here after prefix byte seen

	switch opc:=codeptr++^
	when 0x00,0x1, 0x08,0x9, 0x10,0x11, 0x18,0x19,
						0x20,0x21, 0x28,0x29, 0x30,0x31, 0x38,0x39 then	!arith R/M, R
		op:=opc>>3
		decodeaddr(opc iand 1)
		getsilx(basereg)
		getsil(rmreg)
		genstr(opnames[op])
		printaddrmode()
		genstr(", ")
		genstr(strreg(rmreg,opsize))

	when 0x02,0x3, 0x0A,0xB, 0x12,0x13, 0x1A,0x1B,
						0x22,0x23, 0x2A,0x2B, 0x32,0x33, 0x3A,0x3B then	!arith R,R/M
		op:=opc>>3
		decodeaddr(opc iand 1)
		genstr(opnames[op])
		genstr(" ")
		getsil(rmreg)
		genstr(strreg(rmreg,opsize))
		genstr(", ")
		printaddrmode()

	when 0x04,0x5, 0x0C,0xD, 0x14,0x15, 0x1C,0x1D,
						0x24,0x25, 0x2C,0x2D, 0x34,0x35, 0x3C,0x3D then	!arith rAX,imm
		genstr(opnames[opc>>3])
		genstr(" ")
		if opc iand 1 then
			opsize:=4
			if sizeoverride then opsize:=2 fi
			if rex iand wmask then opsize:=8 fi
		fi
		genstr(strreg(1,opsize))
		genstr(", ")
		genintd(readimm())

	when 0x0F then
		decodetwobyteinstr()

	when 0x40 .. 0x4F then
		rex:=opc
!	if rex iand wmask then wopsize:=8 fi

		goto retry

	when 0x50 .. 0x57 then
		reg:=getreg(opc iand 7,rex iand bmask)
		genstr("push ")
		genstr(strreg(reg,8))

	when 0x58 .. 0x5F then
		reg:=getreg(opc iand 7,rex iand bmask)
		genstr("pop ")
		genstr(strreg(reg,8))

	when 0x63 then
		decodeaddr(1)
		genstr("movsxd ")
		genstr(strreg(rmreg,opsize))
		genstr(", ")
		opsize:=4
		printaddrmode()

	when 0x66 then
		sizeoverride:=1
		goto retry

	when 0x67 then
		addroverride:=1
		goto retry

	when 0x68 then
		genstr("push ")
		if sizeoverride then
			genintd(readint16())
		else
			genintd(readint32())
		fi

	when 0x6A then
		genstr("push ")
		genintd(readsbyte())

	when 0x69, 0x6B then
		decodeaddr(1)
		if basereg<>rmreg then
			genstr("imul3")
			genstr(" ")
			genstr(strreg(rmreg,opsize))
			genstr(", ")
		else
			genstr("imul2")
		fi
		printaddrmode()
		genstr(", ")
		opsize:=(opc iand 2|1|opsize)
		genintd(readimm())

	when 0x70..0x7F then
		genstr("j")
		genstr(condnames[opc iand 15])
		genstr(" ")
		genintd(readsbyte())

	when 0x80..0x83 then			!arith r/m,imm
		decodeaddr(opc iand 1)
		genstr(opnames[rmopc])
		getsilx(basereg)
		printaddrmode()
		genstr(", ")
		if opc<>0x83 then
			genintd(readimm())
		else
			genintd(readsbyte())
		fi

	when 0x84, 0x85 then			!test reg,reg/mem
		decodeaddr(opc iand 1)
		getsilx(basereg)
		getsil(rmreg)
		genstr("test ")
		printaddrmode()
		genstr(", ")
		genstr(strreg(rmreg,opsize))

	when 0x86,0x87 then				!complex excg
		decodeaddr(opc iand 1)
		genstr("exch2 ")
		getsilx(basereg)
		getsil(rmreg)
		genstr(strreg(rmreg,opsize))
		genstr(",")
		printaddrmode()

	when 0x88, 0x89 then			!mov r/m,reg
		decodeaddr(opc iand 1)
		genstr("mov")
		getsilx(basereg)
		getsil(rmreg)

		printaddrmode()
		genstr(", ")
		genstr(strreg(rmreg,opsize))

	when 0x8A, 0x8B then			!mov reg,r/m
		decodeaddr(opc iand 1)
		genstr("mov ")
		getsilx(basereg)
		getsil(rmreg)
		genstr(strreg(rmreg,opsize))
		genstr(", ")
		printaddrmode()

	when 0x8D then
		decodeaddr(1)
		genstr("lea ")
		genstr(strreg(rmreg,opsize))
		genstr(", ")
		printaddrmode()

	when 0x8F then
		decodeaddr(1)
		opsize:=1
		genstr("pop")
		printaddrmode()

	when 0x90 then
		if rex then goto doexch fi
		genstr("nop")

	when 0x91..0x97 then			!exch eax/reg
	doexch:
		reg:=(opc iand 7)+1
		if rex iand bmask then reg+:=8 fi
		opsize:=(sizeoverride|2|4)
		if rex iand wmask then opsize:=8 fi
		genstr("xchg ")
		genstr(strreg(1,opsize))
		genstr(", ")
		genstr(strreg(reg,opsize))

	when 0x98 then
		if sizeoverride then
			genstr("cbw")
		else
			genstr("cbw???")
		fi
	when 0x99 then
		if sizeoverride then
			genstr("cwd")
		elsif rex iand wmask then
			genstr("cqo")
		else
			genstr("cdq")
		fi
	when 0x9B then genstr("wait")

	when 0x9C then genstr("pushf")
	when 0x9D then genstr("popf")
	when 0x9E then genstr("sahf")
	when 0x9F then genstr("lahf")

	when 0xA4..0xA7, 0xAA..0xAF then
		genstr((opc>>1 iand 7|"?","movs","cmps","?","stos","lods","scas"|"?"))
		if opc iand 1=0 then
			genstr("b")
		else
			if rex iand wmask then
				genstr("q")
			elsif sizeoverride then
				genstr("w")
			else
				genstr("d")
			fi
		fi

	when 0xA8, 0xA9 then				!test r0,imm
		genstr("test ")
		if opc iand 1 then
			opsize:=(sizeoverride |2|4)
			if rex iand wmask then opsize:=8 fi
		fi
		genstr(strreg(1,opsize))
		genstr(", ")
		genintd(readimm())

	when 0xB0..0xBF then			!mov reg,imm
		reg:=(opc iand 7)+1
		if rex iand bmask then reg+:=8 fi
		if (opc iand 2x1000) then
			opsize:=(sizeoverride |2|4)
			if rex iand wmask then opsize:=8 fi
		fi
		genstr("mov ")
		getsil(reg)

		genstr(strreg(reg,opsize))
		genstr(", ")
		genintd(readimm8())

	when 0xC0, 0xC1, 0xD0..0xD3 then
		decodeaddr(opc iand 1)
		getsilx(basereg)
		genstr((rmopc+1|"rol","ror","rcl","rcr","shl","shr","?","sar"|"?"))
		printaddrmode()
		if opc<=0xC1 then
			genstr(", ")
			genintd(readbyte())
		else
			genstr((opc iand 2|", cl"|", 1"))
		fi

	when 0xC2 then
		genstr("retn ")
		genintd(readword16())

	when 0xC3 then
		genstr("ret")

	when 0xC6,0xC7 then
		decodeaddr(opc iand 1)
		genstr("mov")
		printaddrmode()
		genstr(", ")
		genintd(readimm())

	when 0xD7 then genstr("xlat")

	when 0xD8..0xDF then
		decode8087(opc iand 7)

	when 0xE0 then genstr("loopnz "); genintd(readsbyte())
	when 0xE1 then genstr("loopz "); genintd(readsbyte())
	when 0xE2 then genstr("loop "); genintd(readsbyte())

	when 0xE3 then
		if addroverride then
			genstr("jecxz ")
		else
			genstr("jrcxz ")
		fi
		genintd(readsbyte())

	when 0xE8 then
		genstr("call ")
		genintd(readint32())

	when 0xE9 then
		genstr("[4] jmp ")
		genintd(readint32())

	when 0xEB then
		genstr("jmp ")
		genintd(readsbyte())

	when 0xF2 then
		if codeptr^<>0x0F and (codeptr^<0x40 and codeptr^>0x4F) then
			genstr("repne")
		else
			f2override:=1
			goto retry
		fi
	when 0xF3 then
		if codeptr^<>0x0F and (codeptr^<0x40 and codeptr^>0x4F) then
			genstr("repe")
		else
			f3override:=1
			goto retry
		fi

	when 0xF4 then
!		println "	end of code [halt]"
!		return nil

	when 0xF6,0xF7 then
		decodeaddr(opc iand 1)
		getsilx(basereg)
		genstr((rmopc+1|"test","?","not","neg","mul","imul","div","idiv"|"?"))
		printaddrmode()
		if rmopc=0 then
			if opsize=8 then opsize:=4 fi
			genstr(", ")
			genintd(readimm())
		fi

	when 0xFE then
		w:=0
		goto doff

	when 0xFF then			!various
		w:=1
	doff:
		decodeaddr(w)
		case rmopc
		when 2x_000 then	!inc
			getsilx(basereg)
			genstr("inc")
		when 2x_001 then	!dec
			getsilx(basereg)
			genstr("dec")
		when 2x_010 then	!call
			opsize:=8
			genstr("icall")
		when 2x_100 then	!jmp
			opsize:=8
			genstr("jmp")
		when 2x_110 then	!push
			opsize:=8
			genstr("push")
		else
			println "FFxx?"
		esac
		printaddrmode()

	else
		genstr("Unknown opcode: ")
    genhex(opc)
	end switch


!at this point, deststr contains the decoded instruction
!need to put in address, bytes etc

!	if baseaddr then
		print @str,baseaddr:"z6h",,": "
!	else
!		print @str,pstart:"z6h",,": "
!	fi

	n:=codeptr-pstart
	to n do
		print @str2,int(pstart++^):"z2H",," "

		strcat(str,str2)
	od
	to maxinstrlen-n do
		strcat(str,"-- ")
	od
	strcat(str,deststr)

	cptr:=codeptr

	return str
end

proc decodetwobyteinstr=
!0F has been decoded
	int opc,rhssize,third,imm
	ichar opcstr

	switch opc:=codeptr++^
	when 0x2A then					!cvtsi2ss/sd XMM, REG/MEM
		decodeaddr(1)
		if f3override then
			genstr("cvtsi2ss ")
		else
			genstr("cvtsi2sd ")
		fi
		genstr(strxmm(rmreg))
		genstr(", ")
		printaddrmode(0)
		
	when 0x2C then					!cvt2ss/sd2si XMM, REG/MEM
		decodeaddr(1)
		if f3override then
			genstr("cvttss2si ")
			rhssize:=4
		else
			genstr("cvttsd2si ")
			rhssize:=8
		fi
		if rex iand wmask then
			genstr(strreg(rmreg,8))
		else
			genstr(strreg(rmreg,4))
		fi
		genstr(", ")
		opsize:=rhssize
		printaddrmode(1)

	when 0x2D then					!cvt2ss/sd2si XMM, REG/MEM
		decodeaddr(1)
		if f3override then
			genstr("cvtss2si ")
			rhssize:=4
		else
			genstr("cvtsd2si ")
			rhssize:=8
		fi
		if rex iand wmask then
			genstr(strreg(rmreg,8))
		else
			genstr(strreg(rmreg,4))
		fi
		genstr(", ")
		opsize:=rhssize
		printaddrmode(1)

	when 0x2F then					!comiss/comisd XMM, REG/MEM
		decodeaddr(1)
		if sizeoverride then
			opsize:=8
			genstr("comisd ")
		else
			opsize:=4
			genstr("comiss ")
		fi
		genstr(strxmm(rmreg))
		genstr(", ")
		printaddrmode(1)

	when 0x3A then					!possible pcmpistri
		third:=codeptr++^

		case third
		when 0x63 then
			genstr("pcmpistri ")
		when 0x62 then
			genstr("pcmpistrm ")
		else
			genstr("Unknown opcode 2-byte opcode: 0F ")
		    genhex(opc)
			return
		esac

		decodeaddr(1)
		genstr(strxmm(rmreg))
		genstr(", ")
		printaddrmode(1)
		genstr(", ")
		imm:=codeptr++^
		genintd(imm)

	when 0x40..0x4F then
		decodeaddr(1)
		genstr("cmov")
		genstr(condnames[opc iand 15])
		genstr(" ")
		genstr(strreg(rmreg,opsize))
		genstr(", ")
		printaddrmode()

	when 0x51 then					!sqrtss/sd
		decodeaddr(1)
		opsize:=(f3override|4|8)
		genstr((opsize=4|"sqrtss "|"sqrtsd "))
		genstr(strxmm(rmreg))
		genstr(", ")
		printaddrmode(1)

	when 0x54 then					!ANDPD
		decodeaddr(1)
		genstr((sizeoverride|"andpd "|"andps "))
		genstr(strxmm(rmreg))
		genstr(", ")
		opsize:=(sizeoverride|8|4)
		printaddrmode(1)

	when 0x57 then					!XORPD
		decodeaddr(1)
		genstr((sizeoverride|"xorpd "|"xorps "))
		genstr(strxmm(rmreg))
		genstr(", ")
		opsize:=(sizeoverride|8|4)
		printaddrmode(1)

	when 0x58 then					!addss/addsd
		opcstr:="adds"
	doarith:
		genstr(opcstr)
		decodeaddr(1)
		if f2override then
			opsize:=8
			genstr("d ")
		else
			opsize:=4
			genstr("s ")
		fi
		genstr(strxmm(rmreg))
		genstr(", ")
		printaddrmode(1)

	when 0x59 then					!mulss/mulsd
		opcstr:="muls"
		goto doarith

	when 0x5A then					!cvtss2sd/cvtsd2ss
		decodeaddr(1)
		if f3override then
			genstr("cvtss2sd ")
			rhssize:=4
		else
			genstr("cvtsd2ss ")
			rhssize:=8
		fi
		genstr(strxmm(rmreg))
		genstr(", ")
		opsize:=rhssize
		printaddrmode(1)

	when 0x5C then					!subss/subsd
		opcstr:="subs"
		goto doarith

	when 0x5D then
		opcstr:="mins"
		goto doarith

	when 0x5E then					!divss/divsd
		opcstr:="divs"
		goto doarith

	when 0x5F then
		opcstr:="maxs"
		goto doarith


	when 0x6E then					!mov X/MM, REG/MEM
		decodeaddr(1)
		opsize:=(rex iand wmask|8|4)
		genstr((opsize=4|"movd "|"movq "))
		if sizeoverride then		!xmm
			genstr(strxmm(rmreg))
		else
			genstr(strmmx(rmreg))
		fi
		genstr(", ")
		printaddrmode()

	when 0x6F then					!movdqa/dqu, X/MEM, X/X
		decodeaddr(1)
		opsize:=16
		if sizeoverride then		!66
			genstr("movdqa ")
		elsif f3override then		!F3
			genstr("movdqu ")
		else
			genstr("No 66/F3 ")
		fi
		genstr(strxmm(rmreg))
		genstr(", ")
		printaddrmode(1)

	when 0x7E then					!mov REG/MEM, X/MM
		decodeaddr(1)
		if f3override then
			opsize:=8
			genstr("movq ")
			genstr(strxmm(rmreg))
			genstr(", ")
			printaddrmode(1)
		elsif rex iand wmask then
			opsize:=8
			genstr("movq ")
			printaddrmode()
			genstr(", ")
			genstr(strxmm(rmreg))
		else
			opsize:=4
			genstr("movd ")
			printaddrmode()
			genstr(", ")
			if sizeoverride then		!xmm
				genstr(strxmm(rmreg))
			else
				genstr(strmmx(rmreg))
			fi
		fi

	when 0x7F then					!movdqa/dqu, MEM/X
		decodeaddr(1)
		opsize:=16
		if sizeoverride then		!66
			genstr("movdqa ")
		elsif f3override then		!F3
			genstr("movdqu ")
		else
			genstr("No 66/F3 ")
		fi
		printaddrmode(1)
		genstr(", ")
		genstr(strxmm(rmreg))

	when 0x80..0x8F then			!long rel jumps
		genstr("[long] j")
		genstr(condnames[opc iand 15])
		genstr(" ")
		if sizeoverride then
			genintd(readint16())
		else
			genintd(readint32())
		fi

	when 0x90..0x9F then
		decodeaddr(0)
		genstr("set")
		genstr(condnames[opc iand 15])
		genstr(" ")
		getsilx(basereg)
		printaddrmode()

	when 0xAF then
		decodeaddr(1)
		genstr("imul ")
		genstr(strreg(rmreg,opsize))
		genstr(", ")
		printaddrmode()

	when 0xB6, 0xB7, 0xBE, 0xBF then
		decodeaddr(1)
!	opsize:=4
		genstr((opc<0xBE|"movzx "|"movsx "))
		genstr(strreg(rmreg,opsize))
		genstr(", ")
		opsize:=(opc iand 1|2|1)
		printaddrmode()

	when 0xB8 then
		decodeaddr(1)
		genstr("popcnt ")
		genstr(strreg(rmreg,opsize))
		genstr(", ")
		printaddrmode()

	when 0xBC, 0xBD then
		decodeaddr(1)
		genstr((opc=0xBC|"bsf "|"bsr "))
		genstr(strreg(rmreg,opsize))
		genstr(", ")
		printaddrmode()

	when 0xD6 then
		decodeaddr(1)
		opsize:=8
		genstr("movq ")
		printaddrmode(1)
		genstr(",")
		genstr(strxmm(rmreg))	

	when 0xDB then					!PAND
		decodeaddr(1)
		genstr("pand ")
		genstr(strxmm(rmreg))
		genstr(", ")
		opsize:=8	!(sizeoverride|8|4)
		printaddrmode(1)

	when 0xEF then					!PXOR
		decodeaddr(1)
		genstr("pxor ")
		genstr(strxmm(rmreg))
		genstr(", ")
		opsize:=8	!(sizeoverride|8|4)
		printaddrmode(1)


	else
	error:
		genstr("Unknown opcode 2-byte opcode: 0F ")
    genhex(opc)
	end switch
end

proc decodeaddr(int w=0)=
!codeptr points to modrm byte, with possible sib and/or disp following
!decode modrm, sib and disp
!store result in amode:
! basereg		0 when not used
! indexreg
! scale			1,2,4,8 factor for indexreg
! offset		0, or any offset or abs address
! addrmode		rm-code
!the function returns the xxx value (middle part of modrm byte)
	int modrm,xxx,mode,sib,rm

	basereg:=indexreg:=0
	scale:=1
	offset:=0
	ripmode:=0

	if w then
		opsize:=(sizeoverride|2|4)
		if rex iand wmask then opsize:=8 fi
	else
		opsize:=1
	fi

	modrm:=codeptr++^

	mode:=modrm>>6
	xxx:=(modrm>>3) iand 7
	rm:=modrm iand 7

	if mode=3 then		!plain register access
		basereg:=rm+1
		addrmode:=amreg
	elsif rm<>4 then				!not esp; no sib
		if mode=0 and rm=5 then		![ebp] is actually [rip+disp]
			offset:=readint32()		!
			ripmode:=1
			addrmode:=ammem

		else
			basereg:=rm+1
			addrmode:=ammem
			case mode
			when 1 then
				offset:=readsbyte()
			when 2 then
				offset:=readint32()
			esac
		fi
	else			!sib follows
		addrmode:=ammem
		sib:=readbyte()
		indexreg:=((sib>>3) iand 7)+1
		basereg:=(sib iand 7)+1
		scale:=(sib>>6+1|1,2,4,8|0)

		if mode=0 and basereg=rframe and indexreg=rstack then	!no base/index regs, only d32 disp
			indexreg:=basereg:=0
			offset:=readint32()

		elsif mode=0 and basereg=rframe  then	!no base/index regs, only d32 disp
			basereg:=0
			offset:=readint32()

		elsif mode=0 and indexreg=rstack then	!no index register, only base; no disp
			indexreg:=0

		else
			case mode
			when 1 then
				offset:=readsbyte()
			when 2 then
				offset:=readint32()
			esac
			if indexreg=rstack then				!stack means no index reg
				indexreg:=0
			fi
		fi

	fi

	if basereg and rex iand bmask then basereg+:=8 fi
	if indexreg and rex iand xmask then indexreg+:=8 fi

	rmreg:=xxx+1
	if rex iand rmask then rmreg+:=8 fi
	rmopc:=xxx
end

function readbyte:int=
	return codeptr++^
end

function readsbyte:int=
	return (ref i8(codeptr++))^
end

function readword16:word=
	word a
	a:=ref u16(codeptr)^
	codeptr+:=2
	return a
end

function readint16:int=
	int a
	a:=ref i16(codeptr)^
	codeptr+:=2
	return a
end

function readword32:word=
	word a
	a:=ref u32(codeptr)^
	codeptr+:=4
	return a
END

function readint32:int=
	int a
	a:=ref i32(codeptr)^
	codeptr+:=4
	return a
END

function readi64:i64=
	i64 a
	a:=ref i64(codeptr)^
	codeptr+:=8
	return a
END

function getreg(int regcode,upper)int=
	if upper then
		return regcode+8+1
	fi
	return regcode+1
end

global function strreg(int reg,opsize)ichar=
static []ichar regnames8=("al","cl","dl","bl","spl","bpl","sil","dil",
						"r8b","r9b","r10b","r11b","r12b","r13b","r14b","r15b",
				"ah","bh","ch","dh")

static []ichar regnames16=("ax","cx","dx","bx","sp","bp","si","di",
						"r8w","r9w","r10w","r11w","r12w","r13w","r14w","r15w")

static []ichar regnames32=("eax","ecx","edx","ebx","esp","ebp","esi","edi",
						"r8d","r9d","r10d","r11d","r12d","r13d","r14d","r15d")

static []ichar regnames64=("rax","rcx","rdx","rbx","rsp","rbp","rsi","rdi",
						"r8","r9","r10","r11","r12","r13","r14","r15")

static []ichar mregnames8=("B0","B10","B11","B4","B15","B14","B5","B3",
						"B12","B13","B1","B2","B6","B7","B8","B9",
					"B16","B18","B19","B17")

static []ichar mregnames16=("W0","W10","W11","W4","Wsp","Wbp","W5","W3",
						"W12","W13","W1","W2","W6","W7","W8","W9")

static []ichar mregnames32=("A0","A10","A11","A4","Astack","Aframe","A5","A3",
						"A12","A13","A1","A2","A6","A7","A8","A9")

static []ichar mregnames64=("D0","D10","D11","D4","Dstack","Dframe","D5","D3",
						"D12","D13","D1","D2","D6","D7","D8","D9")

	if reg=0 then return "<>" fi

	if showmregs then
		case opsize
		when 1 then return mregnames8[reg]
		when 2 then return mregnames16[reg]
		when 4 then return mregnames32[reg]
		when 8 then return mregnames64[reg]
		esac
	else
		case opsize
		when 1 then return regnames8[reg]
		when 2 then return regnames16[reg]
		when 4 then return regnames32[reg]
		when 8 then return regnames64[reg]
		esac
	fi
	return ""
end

function strfreg(int freg)ichar=
!freg is 0-based
	static []ichar xxfregnames=("st0","st1","st2","st3","st4","st5","st6","st7")
	return xxfregnames[freg]
end

proc printaddrmode(int xmm=0)=
	static [100]char str
	ichar plus
	int addrsize

	genstr(" ")

	case addrmode
	when amreg then
		if xmm then
			genstr(strxmm(basereg))
		else
			getsilx(basereg)
			genstr(strreg(basereg,opsize))
		fi
		return
	esac

	case opsize
	when 1 then genstr("byte ")
	when 2 then genstr("word ")
	when 4 then genstr("dword ")
	when 8 then genstr("qword ")
	when 10 then genstr("tword ")
	when 16 then genstr("oword ")
	else
	CPL "///OPSIZE",opsize
	esac

	if ripmode then
		genstr("rip:")
	fi
	genstr("[")
	plus:=""
	addrsize:=(addroverride|4|8)

	if basereg then
		genstr(strreg(basereg,addrsize))
		plus:="+"
	fi
	if indexreg then
		genstr(plus)
		genstr(strreg(indexreg,addrsize))
GENSTR("<INDEX>")
		if scale>1 then
			genstr("*")
			genintd(scale)
		fi
		plus:="+"
	fi

	if offset or (basereg=0 and indexreg=0) then
!	print plus,,offset,"<",ref void(offset),,">"
		if basereg=0 and indexreg=0 then
			genhex(offset)
		else
			if offset>0 then genstr(plus) fi
			genintd(offset)
		fi
	fi
	genstr("]")
!	if addrmode=amrel then genstr("+RIP") fi
end

proc genstr(ichar s)=
	strcat(deststr,s)
end

proc genintd(i64 a)=
	genstr(strint(a))
end

proc genhex(i64 a)=
	genstr(strint(a,"h"))
end

function readimm:int=
!read signed offset according to opsize

	case opsize
	when 1 then return readsbyte()
	when 2 then return readint16()
	when 4,8 then return readint32()			!64-bit uses 32-bit immediate
	esac
	return 0
end

function readimm8:i64=
!like readimm but can 8 bytes too
	if opsize<8 then return readimm() fi
	return readi64()
end

function strxmm(int reg)ichar=
	static [32]char str
	print @str,"xmm",,reg-1
	return str
end

function strmmx(int reg)ichar=
	static [32]char str

	print @str,"mmx",,reg-1
	return str
end

proc decode8087(int ttt)=
	byte bb
	int longopc,freg,shortopc,code

	bb:=codeptr++^			!following byte

	longopc:=ttt<<8+bb		!bottom 11 bits of 2-bytes opcode
	freg:=(bb iand 7)+1		!where bb specifies a register in bottom 3 bits

!first look at all dedicated opcodes before treating bb as modrm byte

	case longopc
	when 2x'110'1101'1001 then genstr("fcompp")
	when 2x'001'1110'0100 then genstr("ftst")
	when 2x'001'1110'0101 then genstr("fxam")
	when 2x'001'1110'1110 then genstr("fldz")
	when 2x'001'1110'1000 then genstr("fld1")
	when 2x'001'1110'1011 then genstr("fldpi")
	when 2x'001'1110'1001 then genstr("fldl2t")
	when 2x'001'1110'1010 then genstr("fldl2e")
	when 2x'001'1110'1100 then genstr("fldlg2")
	when 2x'001'1110'1101 then genstr("fldln2")

	when 2x'001'1111'1010 then genstr("fsqrt")
	when 2x'001'1111'1110 then genstr("fsin")
	when 2x'001'1111'1111 then genstr("fcos")
	when 2x'001'1111'1011 then genstr("fsincos")
	when 2x'001'1111'1101 then genstr("fscale")
	when 2x'001'1111'1000 then genstr("fprem")
	when 2x'001'1111'1100 then genstr("frndint")
	when 2x'001'1111'0100 then genstr("fxtract")
	when 2x'001'1110'0001 then genstr("fabs")
	when 2x'001'1110'0000 then genstr("fchs")

	when 2x'001'1111'0010 then genstr("fptan")
	when 2x'001'1111'0011 then genstr("fpatan")
	when 2x'001'1111'0000 then genstr("f2xm1")
	when 2x'001'1111'0001 then genstr("fyl2x")
	when 2x'001'1111'1001 then genstr("fyl2xp1")

	when 2x'011'1110'0011 then genstr("finit")
	when 2x'011'1110'0000 then genstr("feni")
	when 2x'011'1110'0001 then genstr("fdisi")

	when 2x'011'1110'0010 then genstr("fclex")

	when 2x'001'1111'0111 then genstr("fincstp")
	when 2x'001'1111'0110 then genstr("fdecstp")
	when 2x'001'1101'0000 then genstr("fnop")

	elsecase longopc iand 2x'111'11111'000			!ignore bottom 3 bits

	when 2x'001'11000'000 then genstr("fld "); genstr(strfreg(freg))
	when 2x'101'11010'000 then genstr("fst "); genstr(strfreg(freg))
	when 2x'101'11011'000 then genstr("fstp "); genstr(strfreg(freg))
	when 2x'001'11001'000 then genstr("fxch "); genstr(strfreg(freg))
	when 2x'000'11010'000 then genstr("fcom "); genstr(strfreg(freg))
	when 2x'000'11011'000 then genstr("fcomp "); genstr(strfreg(freg))
	when 2x'101'11000'000 then genstr("ffree "); genstr(strfreg(freg))

	elsecase longopc iand 2x'001'11111'000			!ignore bottom 3 bits and top 2

	when 2x'000'11000'000 then do87arith("fadd",ttt,freg)

	when 2x'000'11100'000 then do87arith("fsub",ttt,freg)
	when 2x'000'11101'000 then do87arith("fsubr",ttt,freg)

	when 2x'000'11001'000 then do87arith("fmul",ttt,freg)

	when 2x'000'11110'000 then do87arith("fdiv",ttt,freg)
	when 2x'000'11111'000 then do87arith("fdivr",ttt,freg)

	else	!finally, have to deal with modrm etc
		--codeptr					!put back modrm byte
		decodeaddr(0)			!code is middle bits
		shortopc:=ttt<<3 + rmopc

		case shortopc				!look at combination of ttt and code (middle bits of modrm)
		when 2x'111'101 then do87mem("fld",4)
		when 2x'011'101 then do87mem("fld",5)
		when 2x'111'100 then do87mem("fldbcd")

		when 2x'111'111 then do87mem("fstp",4)
		when 2x'011'111 then do87mem("fstp",5)
		when 2x'111'110 then do87mem("fstpbcd")

		when 2x'001'101 then do87mem("fldcw")
		when 2x'001'111 then do87mem("fstcw")
		when 2x'101'111 then do87mem("fstsw")

		when 2x'001'110 then do87mem("fstenv")
		when 2x'001'100 then do87mem("fldenv")
		when 2x'101'110 then do87mem("fsave")
		when 2x'101'100 then do87mem("frstor")

		elsecase shortopc iand 2x001'111		!ignore top two bits (mf code)

		when 2x'001'000 then do87mem("fld",ttt>>1)
		when 2x'001'010 then do87mem("fst",ttt>>1)
		when 2x'001'011 then do87mem("fstp",ttt>>1)
		when 2x'000'010 then do87mem("fcom",ttt>>1)
		when 2x'000'011 then do87mem("fcomp",ttt>>1)
		when 2x'000'000 then do87mem("fadd",ttt>>1)
		when 2x'000'100 then do87mem("fsub",ttt>>1)
		when 2x'000'101 then do87mem("fsubr",ttt>>1)
		when 2x'000'001 then do87mem("fmul",ttt>>1)
		when 2x'000'110 then do87mem("fdiv",ttt>>1)
		when 2x'000'111 then do87mem("fdivr",ttt>>1)

		else
			genstr("UNKNOWN x87 OPCODE")
		esac
	esac

end

proc do87arith(ichar opcstr, int ttt,freg)=
	int d, p

	d:=ttt iand 2x100		!d=0:  to st0; d<>0: to freg
	p:=ttt iand 2x010		!p<>0: pop after operation

	genstr(opcstr)
	if p then
		genstr("p")
	fi
	genstr(" ")

	if d=0 then
		genstr("st0, ")
    genstr(strfreg(freg))
	else
    genstr(strfreg(freg))
		genstr(", st0")
	fi
end

proc do87mem(ichar opcstr,int mf=-1)=
!mf has values 0,1,2,4 for type and width, when used; but also 4 for i64
	genstr("f")

	case mf
	when 2x'00 then opsize:=4
	when 2x'01 then genstr("i"); opsize:=4
	when 2x'10 then opsize:=8
	when 2x'11 then genstr("i"); opsize:=2
	when 4 then genstr("i"); opsize:=8
	when 5 then opsize:=10
	esac
	genstr(opcstr+1)

	genstr(" ")
	printaddrmode()
end

proc getsil(int &reg)=
!for certain byte-reg combinations, convert regs ah,ch,dh,bh to spl,bpl,sil,dil
	if opsize=1 and not rex and reg>=5 and reg<=8 then
		case reg
		when 5 then reg:=17
		when 6 then reg:=19
		when 7 then reg:=20
		when 8 then reg:=18
		esac

!		reg+:=12				!5..8 => 17..20


	fi
end

proc getsilx(int &reg)=
!as getsil but used for basereg, which must have addrmode=amreg
	if addrmode=amreg and opsize=1 and rex=0 and reg>=5 and reg<=8 then
		case reg
		when 5 then reg:=17
		when 6 then reg:=19
		when 7 then reg:=20
		when 8 then reg:=18
		esac

!		reg+:=12				!5..8 => 17..20
	fi
end
=== mc_genmcl.m 0 0 38/108 ===
!const fshowopndstack=1
const fshowopndstack=0

!global const docalltrace=1
!global const docalltrace=0

GLOBAL INT DEBUG

global int frameoffset, paramoffset
global int framebytes

[pclnames.bounds]ref proc(pcl) px_handlertable

[6]byte scondcodes=(eq_cond, ne_cond, lt_cond, le_cond, ge_cond, gt_cond)
[6]byte ucondcodes=(eq_cond, ne_cond, ltu_cond, leu_cond, geu_cond, gtu_cond)

global proc genmcl(ichar dummy=nil)=

	return when mcldone

!	IF FSHOWIL OR FSHOWOPNDSTACK THEN CPL "********* ASM HAS PCL INFO *********" FI
	IF FSHOWOPNDSTACK THEN CPL "********* ASM HAS PCL INFO *********" FI

!CPL =CURRFUNC

!CPL "MCL", $LINENO
	int tt:=os_clock()
	inithandlers()
!CPL "MCL", $LINENO
	mclinit()
!CPL "MCL", $LINENO

	currpcl:=pcstart

!CPL "MCL", $LINENO

!MGENCOMMENT("MCL1")
	int i:=0
	repeat
		convertpcl(currpcl)

		showopndstack() when fshowopndstack and currpcl.opcode not in [klabel, kcomment, kproc, ktcproc, kretproc, kendproc]

		++currpcl

	until currpcl>pccurr or currpcl.opcode=kendprog
!CPL "MCL", $LINENO

!CPL "DONE CONVERTPCL"

	genrealtable()
!CPL $LINENO
	genabsneg()
	genstringtable()
!CPL $LINENO

	genmc(m_endx)					!need as buffer in optimiser
	genmc(m_endx)

!CPL $LINENO
	if fpeephole then
!CPL "SKIPPING PEEPHOLE"
		peephole()
	fi
!CPL $LINENO
!CPL "-----------------------", =MLABELNO


	mcldone:=1

	mcltime:=os_clock()-tt
!CPL $LINENO

end

!FUNC CHECKFPUSED(MCLOPND A)int=
!	RETURN 0 WHEN A=NIL
!	if a.reg=rframe or a.regix=rframe then return 1 fi
!	0
!END
!
proc convertpcl(pcl p)=
!RETURN WHEN P.OPCODE IN [KCOMMENT]
!CPL "    CONV",PCLNAMES[P.OPCODE]
!CPL STROPNDSTACK()
	doshowpcl(p) when fshowil

!PCLFLAGS[P.OPCODE]++

	pmode:=p.mode
	currpcl:=p
	mmpos:=p.pos

	ppseqno:=p.seqno

	px_handlertable[p.opcode]^(p)

	[r0..r15]byte OLDREGSET
	pair oldregsetpr @ oldregset
	OLDREGSET:=REGSET
	clear regset
	clear xregset

	int reg
!
	for i to noperands do
		reg:=pclreg[i]
		if reg then
			if ispfloat(pclmode[i]) then
				xregset[reg]:=1
			else
				regset[reg]:=1
			fi
		fi
	od

	mccodex.regfreedpr.low ior:=oldregsetpr.low iand ((regsetpr.low ior isregvarpr.low) ixor invertbytes)
	mccodex.regfreedpr.high ior:=oldregsetpr.high iand ((regsetpr.high ior isregvarpr.high) ixor invertbytes)
!U64 A:=MC.REGFREEDPR.LOW


!CP "//",MC.REGFREEDPR.LOW:"Z16H","..."

!FOR R IN R0..R13 DO
!	IF OLDREGSET[R] AND NOT REGSET[R] AND NOT ISREGVAR[R] THEN
!!		MCCODEX.REGFREED[R]:=1
!		MC.REGFREED[R]:=1
!	FI
!OD
!FOR R IN R0..R13 DO
!IF MC.REGFREEDPR.LOW<>0 OR MC.REGFREEDPR.HIGH<>0 THEN CPL "REGFREED NOT ZERO"
!!MC.REGFREEDPR.LOW:"H"
! FI
!FOR R IN R0..r7 DO
!MC.REGFREED[R]:=0
!	IF OLDREGSET[R] AND NOT REGSET[R] AND NOT ISREGVAR[R] THEN
!		MC.REGFREED[R]:=1
!		MC.REGFREED[R]:=oldregset[r] iand ((regset[r] ior isregvar[r]) ixor 1)
!		MC.REGFREED[R] IOR:=oldregset[r] iand ((regset[r] ior isregvar[r]) ixor 1)
!		MC.REGFREED[R]:=oldregset[r] iand inot regset[r] iand inot isregvar[r]
!	FI
!OD
!U64 B:=MC.REGFREEDPR.LOW
!IF A<>B THEN
!CPL "MISMATCH",A,B
!FI
!CPL A,B,A=B
end

proc inithandlers=
	static byte initdone=0
	ichar name, s
	int n

	if initdone then return fi

	n:=$getnprocs()

	for i to n do
		name:=$getprocname(i)
		if eqbytes(name,"px_",3) then
			for k in pclnames.bounds do
				s:=pclnames[k]
				if s^='k' then ++s fi				!some are kload, others just store
				if eqstring(s,name+3) then
					px_handlertable[k]:=$getprocaddr(i)
					exit
				fi
			else
				merror("Invalid handler name:",name)
			od
		fi
	od

	static [,2]byte dupltable = (

!mapping           =>
		(77, 88),
		(ktoboolf, 		ktoboolt),

		(kcallf,		kcallp),
		(kicallp,		kcallp),
		(kicallf,		kcallp),

		(kendmx,		kresetmx),
		(ktcproc,		kproc),

		(kidivto,		kidiv),
		(kiremto,		kirem)
		)

	for i to dupltable.len do
		px_handlertable[dupltable[i,1]]:=px_handlertable[dupltable[i,2]]
	end

	for i in px_handlertable.bounds do
		if not px_handlertable[i] then
			px_handlertable[i]:=cast(&unimpl)
		fi
	od

	initdone:=1
end

proc doshowpcl(pcl p)=
	[1256]char str

!	return unless fshowil

	case p.opcode
!	when kproc, ktcproc, kretproc, kendproc, kistatic, kzstatic, kdata then
	when kproc, ktcproc, kendproc, kistatic, kzstatic, kdata then
	else
		strcpy(str,"                       ")
		strcat(str,strpclstr(p, str.len))
		mgencomment(PCM_COPYHEAPSTRING(str))
	esac
end

proc unimpl(pcl p)=
	[100]char str
	fprint @str, "Unimpl: # (#)", pclnames[p.opcode], strpmode(pmode)
	CPL STR
	mgencomment(pcm_copyheapstring(str))
end

proc px_nop*(pcl p) =
! ?
!*!	unimpl(p)
end

proc px_dupl*(pcl p) =
! Z' := Y' := Z
	duplpcl()
end

proc px_double*(pcl p) =
! Count extra instance of Z (only works for top stack item)
	if ncalldepth then
!CPL "DOUBLE/DUPL"
		duplpcl()
	else
!CPL "DOUBLE", STRPMODE(PCLMODE[ZZ])
		++pclcount[noperands]
	fi
end

proc px_opnd*(pcl p) =
! Define auxiliary operand M or L
	unimpl(p)
end

proc px_type*(pcl p) =
! Define auxiliary type t
	unimpl(p)
end

proc px_comment*(pcl p) =
! Comment C (a string)
!	unimpl(p)
end

proc px_proc*(pcl p) =
! ?
!Things that are remembered:

!PCLPROCDEF:	PCL op for kdefprocdef: used to repeat PASS2 pass for optimising
!				Note will normally skip back to following op, as below is for PASS1 only

!MCLPROCENTRY:	MCL op for dummy op (or anything that will work), used to insert
!				proc entry ops during do_procentry()

	currfunc:=p.def

	setsegment('C',1)

	genmc(m_procstart,mgenmemaddr(currfunc))
	genmc(m_labelname,mgenmemaddr(currfunc))

	initproc(currfunc)

!create dummy mcl op at which to insert hang proc-entry code onto later
	mgencomment("?>>")
	mclprocentry:=mccodex
!*!	mgencomment("--")

	if currfunc.nparams=2 and currfunc.isentry and not pdcc then
		fixmain()
	fi

!	enterproc(currfunc.name)

end

proc px_endproc*(pcl p) =
! ?

	if noperands then

	cpl("PCL STACK NOT EMPTY"), CURRFUNC.NAME
	MCOMM("PCL STACK NOT EMPTY")
!		merror("PCL stack not empty")
	fi

	genmc(m_procend)
end

proc px_endprog*(pcl p) =
! End-of-program marker.
	unimpl(p)
end

proc px_istatic*(pcl p) =
! Define idata label (must be followed by correct db etc ops)
	setsegment('I',p.align)
	genmc(m_labelname,mgenmemaddr(p.def))
end

proc px_zstatic*(pcl p) =
! Define zdata label and reserve sufficient space
	psymbol d

	d:=p.def
	setsegment('Z',p.align)
	genmc(m_labelname,mgenmemaddr(d))

	genmc(m_resb, mgenint(p.size))
end

proc px_data*(pcl p) =
! Constant data. For block types, there can be multiple C values
	mclopnd ax
	int opc

	if p.mode=tpblock then
		do_blockdata(p)
		return
	fi

!CPL "PXDATA", = P.EXTRA, OPNDNAMES[P.OPNDTYPE]

	case p.opndtype
	when int_opnd then
		ax:=mgenint(p.value)
	when realimm_opnd then
		ax:=mgenrealimm(p.xvalue,tpr64)
	when realimm32_opnd then
		ax:=mgenrealimm(p.xvalue,tpr32)
	when r32_opnd then
		ax:=mgenrealimm(p.xvalue, tpr32)

	when string_opnd then
		ax:=mgenlabel(getstringindex(p.svalue, p.slength))

	when memaddr_opnd then
		ax:=mgenmemaddr(p.def)
		ax.offset:=p.extra
!CPL "SETTING OFFSET", AX.OFFSET, MSTROPND(AX)
	when label_opnd then
		ax:=mgenlabel(p.labelno)

	else
		merror("db/dq optype? #", opndnames[p.opndtype])
	esac

	case p.size
	when 1 then opc:=m_db
	when 2 then opc:=m_dw
	when 4 then opc:=m_dd
	when 8 then opc:=m_dq
	else
CPL =P.SIZE, =STRPMODE(P.MODE)
		merror("DATA/not 1248")
	esac
!
	genmc(opc,ax)

end

proc px_label*(pcl p) =
	genmc(m_labelx, mgenlabel(p.labelno))
end

proc px_load*(pcl p) =
! Z' := M &M L &L 123 4.5 "abc"

	pushpcl(p)
end

proc px_store*(pcl p) =
! M := Z
	mclopnd ax, bx
	psymbol d

	bx:=loadopnd(zz, p.mode)

	if p.mode<>tpblock then
		ax:=mgenmem(p.def, p.mode)
		genmc(m_mov, ax, bx)

	else
		ax:=getworkregm(tpu64)

		d:=p.def
		genmc((d.id=param_id|m_mov|m_lea), ax, mgenmem(d, tpu64))
		ax:=makeopndind(ax, tpu64)

		bx:=makeopndind(bx, tpu64)
		copyblock(ax, bx, p.size)
	fi

	poppcl()
end

proc px_add*(pcl p) =
! Z' := Y + Z
	mclopnd ax, bx

!	ax:=loadopnd(yy, p.mode)
!	bx:=getopnd(zz, p.mode)
!	genmc((ispfloat(p.mode)|m_addss+ispwide(p.mode)|m_add), ax, bx)

	ax:=loadopnd(yy, p.mode)
	if ispint(p.mode) then
		if isimmload(zz) and pclopnd[zz].value=1 then
			genmc(m_inc, ax)
		else
			bx:=getopnd(zz, p.mode)
			genmc(m_add, ax, bx)
		fi
	else
		bx:=getopnd(zz, p.mode)
		genmc(m_addss+ispwide(p.mode), ax, bx)
	fi

	poppcl()
end

proc px_sub*(pcl p) =
! Z' := Y - Z
	mclopnd ax, bx

	ax:=loadopnd(yy, p.mode)
	if ispint(p.mode) then
		if isimmload(zz) and pclopnd[zz].value=1 then
			genmc(m_dec, ax)
		else
			bx:=getopnd(zz, p.mode)
			genmc(m_sub, ax, bx)
		fi
	else
		bx:=getopnd(zz, p.mode)
		genmc(m_subss+ispwide(p.mode), ax, bx)
	fi

	poppcl()
end

proc px_mul*(pcl p) =
! Z' := Y * Z
	mclopnd ax, bx
	int x

	ax:=loadopnd(yy, p.mode)

	if ispint(p.mode) then
		if isimmload(zz) then
			mulimm(ax, pclopnd[zz].value)

		else

!			bx:=getopnd(zz, p.mode)
			bx:=LOADopnd(zz, p.mode)
			genmc(m_imul2, ax, bx)
		fi

	else
		bx:=getopnd(zz, p.mode)
		genmc(m_mulss+ispwide(p.mode), ax, bx)
	fi

	poppcl()
end

proc px_div*(pcl p) =
! Z' := Y / Z
	mclopnd ax, bx

	ax:=loadopnd(yy, pmode)
	bx:=getopnd(zz, pmode)
	genmc(m_divss+ispwide(pmode), ax, bx)
	poppcl()
end

proc px_eval*(pcl p) =
! Evaluate Z [load to an actual register], then pop

	loadopnd(zz, p.mode)
	poppcl()
end

proc px_widen*(pcl p) =
! Z' := cast(Z,t) Mask to width of u, but type is widened to t
	mclopnd ax, bx

	if pmode=tpu64 and p.mode2=tpu32 then
		ax:=loadopnd(zz, tpu32)
		if mccodex.opcode<>m_mov then
			genmc(m_mov, ax, ax)			!sets upper half to zero, just in case
		fi
	else
		bx:=getopnd(zz, p.mode2)
		ax:=getworkregm(pmode)
		genmc((psigned[p.mode2]|m_movsx|m_movzx), ax, bx)
		setnewzz(ax.reg, pmode)
	fi

end

proc px_jump*(pcl p) =
! goto L
	int labno:=p.labelno
	pcl q:=p+1

	while q.opcode=kcomment do ++q od
	case q.opcode
	when klabel then
		if q.labelno=labno then return fi
		++q
		if q.opcode=klabel and q.labelno=labno then return fi
	when kjump then
		q.opcode:=knop
	esac

	genmc(m_jmp, mgenlabel(labno))
end

proc px_ijump*(pcl p)=
	genmc(m_jmp, getopnd(zz, tpu64))
	poppcl()
end

proc px_neg*(pcl p) =
! Z' := -Z
	mclopnd ax

	ax:=loadopnd(zz, pmode)

	if ispint(pmode) then
		genmc(m_neg,ax)
	else
		do_negreal(ax, pmode)
	fi
end

proc px_abs*(pcl p) =
! Z' := abs Z
	mclopnd ax,lx

	ax:=loadopnd(zz, pmode)

	if ispint(pmode) then
		genmc(m_cmp, ax, mgenint(0))

		genmc_cond(m_jmpcc, ge_cond, lx:=mgenlabel(++mlabelno))
		genmc(m_neg,ax)
		genmc(m_labelx, lx)

	else
		do_absreal(ax, pmode)
	fi
end

proc px_bitnot*(pcl p) =
! Z' := inot Z
	mclopnd ax
	ax:=loadopnd(zz, pmode)
	genmc(m_notx, ax)
end

proc px_not*(pcl p) =
! Z' := not Z
	mclopnd ax
	ax:=loadopnd(zz, pmode)
	genmc(m_xorx, changeopndsize(ax,1), mgenint(1, tpu8))
end

proc px_toboolt*(pcl p) =
! Z' := istrue Z
	mclopnd ax, bx, cx
	byte pmode2:=p.mode2

	ax:=loadopnd(zz, pmode2)

	if ispfloat(pmode2) then
		bx:=getworkregm(pmode2)
		cx:=getworkregm(tpu8)
		genmc(m_xorps+ispwide(pmode2), bx, bx)
		genmc(m_comiss+ispwide(pmode2), ax, bx)

		genmc_cond(m_setcc, (p.opcode=ktoboolt|ne_cond|eq_cond), cx)
		genmc(m_movzx, changeopndsize(cx,4),cx)		!4 works for u32/u64
		setnewzz(cx.reg, pmode)

	else
		genmc(m_test, ax,ax)
		genmc_cond(m_setcc, (p.opcode=ktoboolt|ne_cond|eq_cond), bx:=changeopndsize(ax,1))
		genmc(m_movzx, changeopndsize(ax,4),bx)
		pclmode[xx]:=pmode
	fi
end

proc px_sqr*(pcl p) =
! Z' := sqr Z
	mclopnd ax

	ax:=loadopnd(zz, pmode)

	if ispint(pmode) then
		genmc(m_imul2,ax,ax)
	else
		genmc(m_mulss+ispwide(pmode),ax,ax)
	fi
end

proc px_sqrt*(pcl p) =
! Z' := sqrt Z
	mclopnd ax

	ax:=loadopnd(zz, pmode)
	genmc(m_sqrtss+ispwide(pmode),ax,ax)
end

proc px_jumpcc*(pcl p) =
! goto L when Y c Z; p=1: Z':=Y (b=0/1)
	int mcond
	mclopnd ax,bx, lx


	mcond:=ucondcodes[p.condcode]
	lx:=mgenlabel(p.labelno)

	if pmode=tpblock then
MERROR("JUMPCC/BLOCK")
!		addimm(p.size)
!		swapopnds(1,3)
!		domaths(nil, "memcmp*", 3)
!		genmc(m_cmp, mgenreg(r0, tpi32), mgenint(0))
!		genmc_cond(m_jmpcc, mcond, lx)

	else

		ax:=loadopnd(yy, pmode)

		if ispint(pmode) then
			if isimmload(zz) and pclopnd[zz].value=0 and p.condcode in [eq_cc, ne_cc] then
				genmc(m_test, ax, ax)
			else
				bx:=getopnd(zz, pmode)
				if psigned[pmode] then
					mcond:=scondcodes[p.condcode]
				fi
				genmc(m_cmp, ax, bx)
			fi
		else
			bx:=getopnd(zz, pmode)
			genmc(m_comiss+ispwide(pmode), ax, bx)
		fi

		genmc_cond(m_jmpcc, mcond, lx)
		poppcl()

		unless p.popone then
			poppcl()
		end
	fi
end

proc px_jumpt*(pcl p) =
! goto L when Z is true
	do_jumptruefalse(p, nz_cond)
end

proc px_jumpf*(pcl p) =
! goto L when Z is false
	do_jumptruefalse(p,z_cond)
end

proc px_bitand*(pcl p) =
! Z' := Y iand Z
	do_bitwise(p, m_andx)
end

proc px_bitor*(pcl p) =
! Z' := Y ior Z
	do_bitwise(p, m_orx)
end

proc px_bitxor*(pcl p) =
! Z' := Y ixor Z
	do_bitwise(p, m_xorx)
end

proc px_shl*(pcl p) =
! Z' := Y << Z
	do_shift(p, m_shl)
end

proc px_shr*(pcl p) =
! Z' := Y >> Z
	do_shift(p, (psigned[pmode]|m_sar|m_shr))
end

proc px_retproc*(pcl p) =
! Return from proc
	if mclprocentry=mccodex then		!empty body: add dummy mcl op
		mgencomment("---")				!injection of entry code goes wrong otherwise
	fi

	do_procentry(p)

!	if p.opcode=kretproc then
!		leaveproc(currfunc.name)
!	fi

	do_procexit()
end

proc px_retfn*(pcl p) =
! Return from func with Z=retval
	mclopnd ax,bx

!	leaveproc(currfunc.name)

	if pmode=tpblock then
		bx:=mgenireg(r0)								!r0 points to local block value
		regset[r0]:=1
		ax:=getworkregm(tpref)
		genmc(m_mov, ax, mgenmem(blockretname))
		ax:=mgenireg(ax.reg)
		copyblock(ax, bx, p.size)
		genmc(m_mov, mgenreg(r0, tpu64), mgenmem(blockretname))
	fi

	px_retproc(p)
end

proc px_setcall*(pcl p) =
! ?
	saveopnds()

	if ncalldepth>=maxcalldepth then
		merror("Too many nested calls")
	fi

	++ncalldepth

	if p.nargs<=4 then
		callalign[ncalldepth]:=mstackdepth.odd
	else
		callalign[ncalldepth]:=p.nargs.odd ixor mstackdepth.odd
	fi
	callblockret[ncalldepth]:=pmode=tpblock
	callblocksize[ncalldepth]:=p.size

	if callalign[ncalldepth] then
		pushslots(1)
	fi
end

proc px_setarg*(pcl p) =
! Mark Z as n'th argument (counting backwards)
	int n

	n:=p.x+callblockret[ncalldepth]

	callargmode[ncalldepth, n]:=pmode
	callargsize[ncalldepth, n]:=p.size

	if pmode=tpblock then
		pclmode[zz]:=tpu64
	else
		pclmode[zz]:=pmode
	fi

	if n>4 then
		pushopnd(zz, pmode, p.size)
	elsif pmode=tpblock then			!need to record its size
		callargsize[ncalldepth, n]:=p.size
	fi
end

proc px_callp*(pcl p) =
! Call &M with nargs, then pop args; v = varargs
	int nargs, nregargs, slots, isptr:=0, shadow:=0

	int blockret:=callblockret[ncalldepth]

!	dopreg:=currpreg:=0

	nargs:=p.nargs+blockret
	nregargs:=min(nargs, 4)

	if p.opcode in [kicallp, kicallf] then
		isptr:=1
	fi

	do_pushlowargs(nregargs, p.nvariadics, isptr)

	slots:=0
	if nargs<=4 then
		if mstackdepth then
			slots+:=4
			pushslots(4)					!shadowspace
			SLOTS+:=CALLALIGN[NCALLDEPTH]
		else
			localshadow:=1
		fi

	else
		slots:=nargs+callalign[ncalldepth]
		pushslots(4)						!shadowspace
	fi

	if isptr then
		genmc(m_call, loadopnd(zz, tpu64))
		poppcl()
	else
		genmc(m_call, mgenmemaddr(p.def))
	fi

	to nregargs-BLOCKRET do
		poppcl()
	od

	if slots then
		popslots(slots)
	fi

	if pmode then
		do_getretvalue(p)
	fi

	--ncalldepth
end

proc px_jumpret*(pcl p) =
! goto L, common return point; deal with any ret value on stack

!CPL "JUMPRET", =PMODE, =NOPERANDS
	if pmode then
		IF NOPERANDS THEN				!ELSE ASSUME ASSEM WAS LAST
			loadparam(zz, pmode, r0)
!CPL "JR/POP"
			poppcl()
		FI
	fi

	px_jump(p)
end

proc px_jumpretm*(pcl p) =
! goto L, common return point; deal with any ret value on stack
	int n, reg

	n:=zz-p.nargs+1
	to p.nargs do
		loadopnd(n, pclmode[n])
		++n
	od

	reg:=r0
	to p.nargs do
		if reg=r3 and ispint(pclmode[zz]) then reg:=r10 fi
		movetoreg(reg)
		poppcl()
		++reg
	od


	px_jump(p)
end

proc px_startmx*(pcl p) =
! -
	saveopnds()
end

proc px_resetmx*(pcl p) =
! -
!	if ispfloat(pmode) then
!		merror("RESETMULT/XREG")
!	fi

	movetoreg(r0)

	if p.opcode=kresetmx then
		poppcl()
	fi
end

proc px_stop*(pcl p) =
! Stop Z
	psymbol d

	loadparam(zz,tpu64, r10)

	genmc(m_call, mgenextname("exit*"))

	localshadow:=1
	poppcl()
end

proc px_incrto*(pcl p) =
! Z^ +:= n
	do_incr(p, m_inc, m_add)
end

proc px_decrto*(pcl p) =
! Z^ -:= n
	do_incr(p, m_dec, m_sub)
end

proc px_incrload*(pcl p) =
! Z' := (Z +:= n)^
	do_incrload(p, m_inc, m_add)
end

proc px_decrload*(pcl p) =
! Z' := (Z -:= n)^
	do_incrload(p, m_dec, m_sub)
end

proc px_loadincr*(pcl p) =
! Z' := Z++^ (difficult to express step)
	do_loadincr(p, m_inc, m_add)
end

proc px_loaddecr*(pcl p) =
! Z' := Z--^
	do_loadincr(p, m_dec, m_sub)
end


proc px_forup*(pcl p) =
! B:=n; goto L when B<=C
	do_for(p, m_inc, m_add, le_cond)
end

proc px_fordown*(pcl p) =
! B-:=n; goto L when B>=C
	do_for(p, m_dec, m_sub, ge_cond)
end

proc px_iload*(pcl p) =
! Z' := Z^
	mclopnd ax, px
	pcl nextpcl

	if pmode<>tpblock then

		if pclloc[zz]=regvar_loc then
			px:=mgenireg(pclreg[zz], pmode)
		else
			px:=getopnd_ind(zz, pmode)
		fi

		nextpcl:=currpcl+1

		if nextpcl.opcode=kwiden then

			ax:=getworkreg_rm(getsharereg(px, nextpcl.mode), nextpcl.mode)

			genmc(ploadop[nextpcl.mode2], ax, px)
			setnewzz(ax.reg, nextpcl.mode)
			currpcl:=nextpcl
		else
			ax:=getworkreg_rm(getsharereg(px, pmode), pmode)
			genmc(m_mov, ax, px)
			setnewzz(ax.reg, pmode)
		fi

	else

		px:=getopnd_ind_simp(zz, pmode)

		ax:=getworkreg_rm(px.reg, tpu64)
		dolea(ax, px)
	fi

end

func getsharereg(mclopnd ax, int mode)int=
!if ax includes reg/regix, then try and use them
!return 0 if not reg available or not possibe
	byte reg:=ax.reg, regix:=ax.regix

	if ispfloat(mode) then return 0 fi

	if reg and (workregs[reg] or reg in r10..r13) then			!not a regvar
		return reg
	elsif regix and (workregs[regix] or reg in r10..r13) then
		return regix
	fi

	return 0
end

proc px_iloadx*(pcl p) =
! Z' := (Y + Z*s + d)^
	pcl z, nextpcl
	mclopnd ax, bx, px, fx

	px:=do_addrmode(p)

	if pmode=tpblock then
		ax:=getworkreg_rm(px.reg, tpu64)
		dolea(ax, px)
		poppcl()
		setnewzz(ax.reg, tpu64)

	else
		nextpcl:=currpcl+1

		if nextpcl.opcode=kwiden then
			ax:=getworkreg_rm(getsharereg(px, nextpcl.mode), nextpcl.mode)

			genmc(ploadop[nextpcl.mode2], ax, px)
			poppcl()
			setnewzz(ax.reg, nextpcl.mode)
			currpcl:=nextpcl
		else

			ax:=getworkreg_rm(getsharereg(px, pmode), pmode)

			genmc(m_mov, ax, px)
			poppcl()
			setnewzz(ax.reg, pmode)
		fi

	fi
end

proc px_istore*(pcl p) =
! Y^ := Z
	mclopnd bx, px

	bx:=loadopnd(yy, pmode)				!rhs to store into lhs


	if pclloc[zz]=regvar_loc then
		px:=mgenireg(pclreg[zz], pmode)
	else
		px:=getopnd_ind(zz, pmode)
	fi

	if pmode=tpblock then
		px:=makesimpleaddr(px)
		bx:=makeopndind(bx, tpu64)

		copyblock(px, bx, p.size)

	else
		genmc(m_mov, px, bx)
	fi

	poppcl()
	poppcl()
end

proc px_istorex*(pcl p) =
! (Y + Z*s + d)^ := X
	mclopnd ax, cx, px
	pcl z

	cx:=loadopnd(xx, pmode)			!rhs
	px:=do_addrmode(p)

	if pmode=tpblock then
		px:=makesimpleaddr(px)
		cx:=makeopndind(cx, tpu64)
		copyblock(px, cx, p.size)

	else
		genmc(m_mov, px, cx)

	fi

	poppcl()
	poppcl()
	poppcl()
end

proc px_storem*(pcl p) =
! Z' := (Y, Z) for mem:16
	mclopnd ax, bx, px
	pcl z
	psymbol dblock

	if p.size<>16 then merror("Storem not 16") fi		!only Y/Z for now

	dblock:=newblocktemp(16)
!
	px:=mgenmem(dblock)
!
	bx:=loadopnd(zz, tpu64)
!
	genmc(m_mov, applyoffset(px, 8), bx)
	poppcl()
!
	bx:=loadopnd(zz, tpu64)
	genmc(m_mov, px, bx)

	genmc(m_lea, mgenreg(bx.reg,tpu64), px)
	setnewzz(bx.reg, tpu64)
end

proc px_addpx*(pcl p) =
! Z' := Y + Z*s + d
	mclopnd ax,cx

!P.MODE:=PMODE:=TPU64

	cx:=do_addrmode(p)
	ax:=getworkreg_rm(cx.reg, tpu64)

	dolea(ax, cx)
	poppcl()

	setnewzz(ax.reg, tpu64)
end

proc px_subpx*(pcl p) =
! Z' := Y - Z*s + s
	int scale, extra, offset
	mclopnd ax,bx
	pcl z

	scale:=p.scale
	extra:=p.extra

	ax:=loadopnd(yy, tpu64)

	if z:=isimmload(zz) then
		genmc(m_sub, ax, mgenint(z.value*scale+extra))
	else
		bx:=loadopnd(zz, tpu64)
		scale:=scaleindex(bx, scale)
		if scale>1 then
			mulimm(bx,scale)
		fi
		genmc(m_sub, ax, bx)
		if extra then
			CPL =EXTRA
			MERROR("SUBREF/EXTRA")
!			genmc(m_add, ax, mgenint(extra))
		fi
	fi
	poppcl()
end

proc px_to*(pcl p) =
! --B (aux); goto L when B<>0 
	pcl q
	mclopnd ax

	q:=currpcl:=p+1

	ax:=mgenmem(q.def)
	genmc(m_dec, ax)
	genmc_cond(m_jmpcc, nz_cond, mgenlabel(p.labelno))
end

proc px_iswap*(pcl p) =
! swap(Y^,Z^) ref T/V
	mclopnd ax, bx

	mclopnd px:=getopnd_ind(yy, pmode)
	mclopnd qx:=getopnd_ind(zz, pmode)

	ax:=getworkregm(pmode)
	bx:=getworkregm(pmode)

	if pmode<>tpblock then
		genmc(m_mov, ax, px)
		genmc(m_mov, bx, qx)
		genmc(m_mov, qx, ax)
		genmc(m_mov, px, bx)
	else
		merror("swap/block")
	fi

	poppcl()
	poppcl()
end

proc px_swapstk*(pcl p) =
! (Z', Y') := (Z, Y)
!	swapopnds(yy,zz)
	swapopnds(noperands-p.x+1, noperands-p.y+1)
end

proc px_labeldef*(pcl p) =
! ?
	[100]char str
	strcpy(str, p.def.name)
	strcat(str, ":")
	MCOMM(str)

end

proc px_addto*(pcl p) =
! Z^ +:= Y
	do_binto(p, m_add, m_addss)
end

proc px_subto*(pcl p) =
! Z^ -:= Y
	do_binto(p, m_sub, m_subss)
end

proc px_multo*(pcl p) =
! Z^ *:= Y
	mclopnd ax,bx,cx
	pcl x

	if ispfloat(pmode) then
		do_binto_float(p, m_mulss)
		return
	fi

	if psize[pmode]=1 then merror("multo/byte") fi

	pushpcl_reg(tpi64)

!operands are now Y^ *:= X with Z used as working value

!xx yy zz = addr rhs workreg
	ax:=getopnd_ind(yy, pmode)
	bx:=getopnd(xx, pmode)
	cx:=getopnd(zz, pmode)

	genmc(m_mov, cx, ax)

	if x:=isimmload(xx) then
		mulimm(cx, x.value)
	else
		genmc(m_imul2, cx,bx)
	fi
	genmc(m_mov, ax,cx)

	poppcl()
	poppcl()
	poppcl()
end

proc px_bitandto*(pcl p) =
! Z^ iand:= Y
	do_binto(p,m_andx, 0)
end

proc px_bitorto*(pcl p) =
! Z^ ior:= Y
	do_binto(p,m_orx, 0)
end

proc px_bitxorto*(pcl p) =
! Z^ ixor:= Y
	do_binto(p,m_xorx, 0)
end

proc px_shlto*(pcl p) =
! Z^ <<:= Y
	do_shiftnto(p,m_shl)
end

proc px_shrto*(pcl p) =
! Z^ >>:= Y
	do_shiftnto(p,(psigned[pmode]|m_sar|m_shr))
end

proc px_fix*(pcl p) =
! Z' := cast(Z,t) Real u to int t
	mclopnd fx,ax
!
	fx:=loadopnd(zz, p.mode2)
	pushpcl_reg(pmode)

	ax:=getopnd(zz, pmin[pmode])
	genmc(m_cvttss2si+ispwide(p.mode2), ax, fx)

	swapopnds(yy,zz)
	poppcl()


	setnewzz(ax.reg, pmode)
end

proc px_float*(pcl p) =
! Z' := cast(Z,t) Int u to real t
	mclopnd ax,fx
	int lab,lab2
	byte pmode2:=p.mode2

	ax:=loadopnd(zz, pmode2)

	if psize[pmode2]<4 then merror("float/short") fi

	if psigned[pmode2] then
		pushpcl_reg(pmode)
		fx:=getopnd(zz, p.mode)

		genmc(m_cvtsi2ss+ispwide(pmode), fx, ax)
		swapopnds(yy,zz)

	elsif pmode2=tpu64 then								!u64 to r32/r64
		pushpcl_reg(tpr64)								!convert to r64 in all cases

		fx:=getopnd(zz, tpr64)

		lab:=mcreatefwdlabel()
		lab2:=mcreatefwdlabel()

		genmc(m_cmp, ax, mgenint(0))					!range of +ve i64?
		genmc_cond(m_jmpcc, lt_cond, mgenlabel(lab))
		genmc(m_cvtsi2sd, fx, ax)						!number is +ve i64
		genmc(m_jmp, mgenlabel(lab2))

		mdefinefwdlabel(lab)
		if not labmask63 then
			labmask63:=++mlabelno
			laboffset64:=++mlabelno
		fi
		genmc(m_andx,ax, mgenlabelmem(labmask63))		!clear top bit of u64 (subtract 2**63)
		genmc(m_cvtsi2sd, fx, ax)						!now in +ve i64 range
		genmc(m_addsd, fx, mgenlabelmem(laboffset64))	!add back 2**63 as float

		mdefinefwdlabel(lab2)							!done conv to r64
reduce:
		if pmode=tpr32 then								!for r64, reduce down
			genmc(m_cvtsd2ss, changeopndsize(fx, 4), fx)
			pclmode[zz]:=tpr32
		fi

		swapopnds(yy,zz)								!bring old int value to top
	else												!u32 to r32/r64
		pushpcl_reg(tpr64)								!convert to r64 in all cases

		fx:=getopnd(zz, tpr64)
		ax:=changeopndsize(ax, 8)						!eg A0 to D0

		genmc(m_cvtsi2sd, fx, ax)						!u64 (always in range) to r64

		goto reduce

	fi

	poppcl()
end

proc px_idiv*(pcl p) =
! Z' := Y % Z
	do_divrem(p, issigned:psigned[pmode], isdiv:1)
end

proc px_irem*(pcl p) =
! Z' := Y rem Z
	do_divrem(p, issigned:psigned[pmode], isdiv:0)
end

proc px_idivrem*(pcl p) =
! Z' := divrem(Y, Z)
	do_divrem(p, issigned:psigned[pmode], isdiv:2)
end

proc px_clear*(pcl p) =
! Clear Z^
	mclopnd ax

	ax:=getopnd_ind_simp(zz, tpu64)

	clearblock(ax, p.size)
	poppcl()
end

proc px_subp*(pcl p) =
! Z' := (Y - Z)/s
	mclopnd ax,bx
	int n

	ax:=loadopnd(yy, pmode)
	bx:=getopnd(zz, pmode)
	genmc(m_sub,ax,bx)

	if p.scale>1 then
		n:=ispoweroftwo(p.scale)
		if n then
			genmc(m_shr, ax, mgenint(n))
		else
CPL P.SCALE
			MERROR("SUB/REF NOT POWER OF xx")
		fi
	fi

	poppcl()
end

proc px_switch*(pcl p) =
! L=jumptab; B=elselab; x/y=min/max values
	int minlab, maxlab, jumplab, elselab, reg
	mclopnd ax, bx, ax2

	minlab:=p.minlab
	maxlab:=p.maxlab
	jumplab:=p.labelno
	currpcl:=p+1
	elselab:=currpcl.labelno

	ax:=loadopnd(zz, pmode)
	if p.size<8 then
		genmc(m_movsx, ax2:=changeopndsize(ax,8), ax)
		ax:=ax2
	fi

	if minlab<>0 then
		genmc(m_sub, ax, mgenint(minlab))
	fi

	genmc(m_cmp,ax,mgenint(maxlab-minlab+1))
	genmc_cond(m_jmpcc,geu_cond,mgenlabel(elselab))

	if phighmem=2 then
		reg:=getworkireg()
		bx:=mgenreg(reg, tpref)

		genmc(m_lea, bx, mgenlabelmem(jumplab))

		genmc(m_jmp, mgenindex(ireg:ax.reg, areg:reg, scale:8))
	else
		genmc(m_jmp, mgenindex(ireg:ax.reg,scale:8,labno:jumplab))

	fi

	poppcl()

!	setsegment('I')
end

proc px_switchu*(pcl p) =
! L=jumptab; B=elselab; x/y=min/max values
	int minlab, maxlab, jumplab, reg
	mclopnd ax, bx

	minlab:=p.minlab
	maxlab:=p.maxlab
	jumplab:=p.labelno

	ax:=loadopnd(zz, pmode)

	if phighmem=2 then
		reg:=getworkireg()
		bx:=mgenreg(reg, pmode)

!		genmc(m_mov, bx, mgenlabel(jumplab))
		genmc(m_lea, bx, mgenlabelmem(jumplab))

		genmc(m_jmp, mgenindex(ireg:ax.reg, areg:reg, scale:8, offset:-minlab*8))
	else
		genmc(m_jmp, mgenindex(ireg:ax.reg,scale:8,labno:jumplab, offset:-minlab*8))
	fi

	poppcl()
end

proc px_swlabel*(pcl p) =
! jumptable entry
	genmc(m_dq, mgenlabel(p.labelno))
end

proc px_endsw*(pcl p) =
! Mark end of switch jumptable
!	setsegment('C')
end

proc px_fwiden*(pcl p) =
! Z' := cast(Z,t) r32 to r64
	mclopnd fx
	fx:=loadopnd(zz,p.mode2)
	genmc(m_cvtss2sd, changeopndsize(fx,8), fx)
	pclmode[zz]:=tpr64
end

proc px_fnarrow*(pcl p) =
! Z' := cast(Z,t) r64 to r32
	mclopnd fx
	fx:=loadopnd(zz,p.mode2)
	genmc(m_cvtsd2ss, changeopndsize(fx,4), fx)
	pclmode[zz]:=tpr32
end

proc px_truncate*(pcl p) =
! Z' := cast(Z,u) Mask to width of u, but type is widened to t
	mclopnd ax
	byte pmode2:=p.mode2

!	if p.size<8 then merror("trunc32") FI

	ax:=loadopnd(zz, pmode2)
	if p.size<>psize[pmode2] then
		genmc(ploadop[pmode2], changeopndsize(ax, psize[pmode]), ax)
	fi
end

proc px_typepun*(pcl p) =
! Z' := t(u!(Z^))
	mclopnd ax,bx

	bx:=loadopnd(zz, p.mode2)
	ax:=getworkregm(pmode)
	genmc(m_mov, ax, changeopndsize(bx, ax.size))

	setnewzz(ax.reg, pmode)
end

proc px_unload*(pcl p) =
! Pop stack
	poppcl()
end

proc px_loadbit*(pcl p) =
! Z' := Y.[Z]
	mclopnd ax
	pcl z
	int i, m

	if z:=isimmload(zz) then
		i:=z.value
		m:=(i in 0..31|tpu32|tpu64)

		ax:=loadopnd(yy, m)
		if i then
			genmc(m_shr, ax, mgenint(i, m))

			goto skip when i=63

		fi
	else
		ax:=loadopnd(yy, pmode)
		genmc(m_push, mgenreg(r10)) when r10used
		genmc(m_shr, ax, loadparam(zz, tpu8, r10))
		genmc(m_pop, mgenreg(r10)) when r10used
	fi

	genmc(m_andx, changeopndsize(ax,4), mgenint(1, tpu32))

skip:
	poppcl()
end

proc px_assem*(pcl p) =
! To be worked out....
	if idomcl_assem then
		idomcl_assem(p.asmcode)
	else
		merror("No Assem handler")
	fi
end

proc px_sin*(pcl p) =
! Z' := sin Z
	do_maths(p,"sin*")
end

proc px_cos*(pcl p) =
! Z' := cos Z
	do_maths(p,"cos*")
end

proc px_tan*(pcl p) =
! Z' := tan Z
	do_maths(p,"tan*")
end

proc px_asin*(pcl p) =
! Z' := asin Z
	do_maths(p,"asin*")
end

proc px_acos*(pcl p) =
! Z' := acos Z
	do_maths(p,"acos*")
end

proc px_atan*(pcl p) =
! Z' := atan Z
	do_maths(p,"atan*")
end

proc px_log*(pcl p) =
! Z' := log Z
	do_maths(p,"log*")
end

proc px_log10*(pcl p) =
! Z' := log10 Z
	do_maths(p,"log10*")
end

proc px_exp*(pcl p) =
! Z' := round Z
	do_maths(p,"exp*")
end

proc px_round*(pcl p) =
! Z' := round Z
	do_maths(p,"round*")
end

proc px_floor*(pcl p) =
! Z' := floor Z
	do_maths(p,"floor*")
end

proc px_ceil*(pcl p) =
! Z' := ceil Z
	do_maths(p,"ceil*")
end

proc px_atan2*(pcl p) =
! Z' := atan2(Y, Z)
	swapopnds(yy,zz)
	do_maths(p,"atan2*", 2)
end

proc px_fmod*(pcl p) =
! Z' := fmod(Y, Z)
	swapopnds(yy,zz)
	do_maths(p,"fmod*", 2)
end

proc px_setcc*(pcl p) =
! Z' := Y cc Z
	int cond
	mclopnd ax,bx,cx

	ax:=loadopnd(yy, pmode)
	bx:=getopnd(zz, pmode)
	cond:=ucondcodes[p.condcode]

	if pmode=tpblock then
		merror("setcc/block")

	elsif ispint(pmode) then
		if psigned[pmode] then
			cond:=scondcodes[p.condcode]
		fi
		genmc(m_cmp,ax,bx)
		cx:=changeopndsize(ax,1)

	else
		genmc(m_comiss+ispwide(pmode),ax,bx)

		cx:=getworkregm(tpu8)
		setnewzz(cx.reg, tpi64)
		swapopnds(yy,zz)
	fi

	genmc_cond(m_setcc, cond, cx)
	genmc(m_movzx, changeopndsize(cx,4), cx)

	poppcl()
end

proc px_min*(pcl p) =
! Z' := min(Y, Z)
	if ispint(pmode) then
		do_max_int((psigned[pmode]|gt_cond|gtu_cond))
	else
		do_max_float(m_minss+ispwide(pmode))
	fi
end

proc px_max*(pcl p) =
! Z' := max(Y, Z)
	if ispint(pmode) then
		do_max_int((psigned[pmode]|lt_cond|ltu_cond))
	else
		do_max_float(m_maxss+ispwide(pmode))
	fi
end

proc px_power*(pcl p) =
! Z' := Y ** Z
	mclopnd ax,bx
	psymbol d

	if ispint(pmode) then
		d:=gethostfn(kpower)
		swapopnds(yy,zz)
		do_host(p, d, 2)
	else
		swapopnds(yy,zz)
		do_maths(p,"pow*",2)
	fi
end
!
proc px_minto*(pcl p) =
! Z^ min:= Y
	if ispint(pmode) then
		do_maxto_int((psigned[pmode]|le_cond|leu_cond), pmode)
	else
		do_maxto_real(leu_cond, pmode)
	fi
end

proc px_maxto*(pcl p) =
! Z^ max:= Y
	if ispint(pmode) then
		do_maxto_int((psigned[pmode]|ge_cond|geu_cond), pmode)
	else
		do_maxto_real(geu_cond, pmode)
	fi
end

proc px_negto*(pcl p) =
! -:= Z^
	mclopnd px, fx

	px:=getopnd_ind(zz, pmode)

	if ispint(pmode) then
		genmc(m_neg, px)
	else
		fx:=getworkregm(pmode)
		genmc(m_mov, fx, px)

		do_negreal(fx, pmode)

		genmc(m_mov, px, fx)
	fi
	poppcl()
end

proc px_absto*(pcl p) =
! abs:= Z^
	mclopnd px, ax, lx

	px:=getopnd_ind(zz, pmode)

	ax:=getworkregm(pmode)
	genmc(m_mov, ax, px)

	if ispint(pmode) then
		genmc(m_cmp, ax, mgenint(0))

		genmc_cond(m_jmpcc, ge_cond, lx:=mgenlabel(++mlabelno))
		genmc(m_neg, ax)
		genmc(m_labelx, lx)

	else
		do_absreal(ax, pmode)
	fi

	genmc(m_mov, px, ax)

	poppcl()
end

proc px_addpxto*(pcl p) =
! Z^ +:= Y
	mclopnd ax,bx
	pcl z
!
	ax:=getopnd_ind(zz, pmode)

	if z:=isimmload(yy) then
		genmc(m_add, ax, mgenint(z.value*p.scale))
	else
		bx:=loadopnd(yy, pmode)
		mulimm(bx, p.scale)
		genmc(m_add, ax, bx)
	fi

	poppcl()
	poppcl()
end

proc px_subpxto*(pcl p) =
! Z^ -:= Y
	mclopnd ax, bx
	pcl z

	ax:=getopnd_ind(zz, pmode)

	if z:=isimmload(yy) then
!		genmc(m_sub, ax, mgenint(z.value*p.scale+p.extra))
		genmc(m_sub, ax, mgenint(z.value*p.scale))
	else
		bx:=loadopnd(yy, pmode)
		mulimm(bx, p.scale)
		genmc(m_sub, ax, bx)
		if p.extra then
			MERROR("SUBTOREF/EXTRA")
!			genmc(m_sub, ax, mgenint(extra))
		fi
	fi

	poppcl()
	poppcl()
end

proc px_divto*(pcl p) =
! Z^ /:= Y
	do_binto_float(p, m_divss)
end

proc px_bitnotto*(pcl p) =
! inot-:= Z^
	mclopnd px, fx

	px:=getopnd_ind(zz, pmode)

	genmc(m_notx, px)
	poppcl()
end

proc px_notto*(pcl p) =
! not:= Z^
	mclopnd px
	px:=getopnd_ind(zz, tpu8)
	genmc(m_xorx, changeopndsize(px,1), mgenint(1, tpu8))
end

proc px_toboolto*(pcl p) =
! istrue:= Z^
	mclopnd ax, bx, px

	px:=getopnd_ind(zz, tpu8)
	ax:=getworkregM(pmode)
	genmc(m_mov, ax, px)
	genmc(m_test, ax,ax)
	genmc_cond(m_setcc, ne_cond, bx:=changeopndsize(ax,1))
	genmc(m_movzx, changeopndsize(ax,4),bx)
	genmc(m_mov, px, ax)
end

proc px_sign*(pcl p) =
! Z' := sign Z
	mclopnd ax, bx
	mclopnd lx1, lx2, lx3
	byte gtop, ltop


	ax:=loadopnd(zz, pmode)

	bx:=getworkregm(tpi64)
	clearreg(bx)
!	genmc(m_xorx, bx, bx)

	if ispfloat(pmode) then
		gtop:=gtu_cond; ltop:=ltu_cond
		genmc(m_comiss+ispwide(pmode), ax, mgenrealmem(0.0, pmode))
	else
		gtop:=gt_cond; ltop:=lt_cond
		genmc(m_cmp, ax, mgenint(0,pmode))
	fi

		genmc_cond(m_jmpcc, gtop, lx1:=mgenlabel(++mlabelno))
		genmc_cond(m_jmpcc, ltop, lx2:=mgenlabel(++mlabelno))
		genmc(m_jmp, lx3:=mgenlabel(++mlabelno))

	genmc(m_labelx, lx1)
		genmc(m_mov, changeopndsize(bx, 1), mgenint(1))
		genmc(m_jmp, lx3)
	genmc(m_labelx, lx2)
		genmc(m_dec, bx)
	genmc(m_labelx, lx3)

	setnewzz(bx.reg, tpi64)

end

proc px_loadbf*(pcl p) =
! Z' := X.[Y..Z]
	pcl y, z

	y:=isimmload(yy)
	z:=isimmload(zz)

	if y and z then
		do_loadbf_const(p, y.value, z.value)
	else
		do_loadbf_var(p)
	fi
end

proc px_storebit*(pcl p) =
! Y^.[Z] := X
	do_storebit(p)
end

proc px_storebf*(pcl p) =
! X^.[Y..Z] := W
	do_storebf(p)
end

proc px_loadall*(pcl p) =
	checkallloaded()
end

proc px_setjmp*(pcl p)=
	mclopnd ax,bx
	int lab:=mcreatefwdlabel()

	bx:=getopnd_ind(zz, tpref)

	pushpcl_reg(tpref)

	ax:=getopnd(zz, tpref)
	genmc(m_mov, ax, mgenlabel(lab))
	genmc(m_mov, bx, ax)
	genmc(m_mov, applyoffset(bx,8), dstackopnd)
	genmc(m_mov, applyoffset(bx,16), dframeopnd)
	swapopnds(yy,zz)
	poppcl()
	clearreg(ax)

!since this is the end of this op anway, free any workregs in advance (freeing
!will be done again by convertpcl)
	freeworkregs(p)
	movetoreg(r0)
	mdefinefwdlabel(lab)

end

proc px_longjmp*(pcl p)=
	mclopnd ax,bx,cx

	bx:=loadopnd(zz, tpref)		!ret value
	ax:=getopnd_ind(yy, tpref)	!buffer

	genmc(m_mov, dstackopnd, applyoffset(ax,8))
	genmc(m_mov, dframeopnd, applyoffset(ax,16))

!	addreg_d64()
	pushpcl_reg(tpref)

	cx:=getopnd(zz, tpref)

	genmc(m_mov, cx, ax)		!load stored return address
	swapopnds(xx, zz)
	poppcl()					!addr of buffer

	swapopndregs(r0)			!move ret value to r0
	genmc(m_jmp, cx)			!
	swapopnds(yy, zz)
	poppcl()					!get rid of dest addr; leave ret value in r0
end

proc px_initdswx*(pcl p)=		!ignore for mcl/x64
end

!proc px_enter*(pcl p)=
!	do_callrts(p, "puts*", nil, 1)
!end
!
!proc px_leave*(pcl p)=
!	do_callrts(p, "puts*", nil, 1)
!end
!
!
=== mc_genss.m 0 0 39/108 ===
const wmask = 2x1000				!1 means 64-bit operand size
const rmask = 2x0100				!extends mod/rm reg field
const xmask = 2x0010				!extends sib index field
const bmask = 2x0001				!extends mod/rm r/m field, also sib base field

const wbit = 3

byte rex
byte sizeoverride					!32=>16 switch
byte addroverride					!32=>16 switch
byte f2override						!xmm regs
byte f3override						!xmm regs
byte nowmask						!disable w-bit
byte usesizeb						!1 tests opnd b for wmask

GLOBAL record amoderec =					!return from genrm
!record amoderec =					!return from genrm
	byte modrm						!
	byte sib						!
	i8 usesib						!-1/0/1 = rip/not used/used
	byte dispsize					!0, 1 or 4
	i32 offset					!for dispsize = 1/4
end

mclopnd extraparam

int currseg=0
ref dbuffer currdata				!copy of ss_idata or ss_code
ref relocrec currrelocs
int nrelocs

[r0..r15]byte ishighreg				!high regs have 0x40 (see start)

REF MCLREC CURRMCL
ref riprec ripentry

macro genbyte(x) = currdata.pcurr++^:=x

macro makemodrm(mode,opc,rm) = mode<<6+opc<<3+rm

global proc genss(int obj=0)=
	int index
	ref mclrec m

	return when ssdone

	sstime:=os_clock()

	initlib(mlabelno)
!CPL "INITLAB 50"
!	initlib(50)

	ss_zdatalen:=0
	ss_zdata:=buffercreate()
	ss_idata:=buffercreate()
	ss_code:=buffercreate()
	ss_idatarelocs:=nil
	ss_coderelocs:=nil
	ss_nsymbols:=0

	switchseg(code_seg)

	aaseqno:=9999
	extraparam:=nil

!	fixregvar()

	m:=mccode
	index:=0

!CPL "SS1", OS_CLOCK()-SSTIME

	while m do
		doinstr(m,++index)
		m:=m.nextmcl
	od
!CPL "DONE GENSS LOOP"
!CPL "SS2", OS_CLOCK()-SSTIME

	switchseg(0)					!update ss_currrelocs etc

	if bufferlength(ss_zdata) then
		axerror("Zdata contains code or data")
	fi

	if obj then					!do fixups needed for .obj files
		ref riprec pr			!(exe module does its own fixups)
		ref byte codeaddr
		ref u32 offsetptr

		codeaddr:=bufferelemptr(ss_code, 0)
			pr:=riplist
			while pr, pr:=pr.next do
				offsetptr:=ref u32(codeaddr+pr.offset)
				offsetptr^-:=pr.immsize
		od
	fi
!CPL "SS3", OS_CLOCK()-SSTIME

	ssdone:=1
	sstime:=os_clock()-sstime

end

proc doinstr(ref mclrec m,int index)=
	mclopnd a,b
	psymbol d,e
	int x,offset,shortjmp,n

!CPL "DOINSTR",MCLNAMES[M.OPCODE], M.SEQNO

	if currdata.pend-currdata.pcurr<1024 then
		bufferexpand(currdata)
	fi

	rex:=sizeoverride:=addroverride:=f2override:=f3override:=nowmask:=usesizeb:=0

	a:=m.a
	b:=m.b

	aaseqno:=m.seqno
	aapos:=m.mpos
	ripentry:=nil
	CURRMCL:=M

	switch m.opcode
	when m_procstart then
		CURRASMPROC:=M.A.DEF
!CPL "PROC", CURRASMPROC.NAME

	when m_procend then
	when m_define then

	when m_definereg then
!	when m_definetemp then

	when m_labelname then
		case a.valtype
		when stringimm_val then
		when def_val then
			d:=a.def
!CPL "LABEL", D.NAME
			d.reftype:=back_ref
			d.segment:=currseg
			d.offset:=getcurrdatalen(6)

			if d.exported then
				getstindex(d)
			fi

			dofwdrefs(d)
		esac

	when m_labelx then

		if a.valtype=def_val then			!named label (probably from assembler)
			d:=a.def
		else
			d:=labeldeftable[a.labelno]
		fi
	
		d.reftype:=back_ref
		d.segment:=currseg
		d.offset:=getcurrdatalen(6)

		if d.exported then
			getstindex(d)
		fi

		dofwdrefs(d)

	when m_call then
		do_call(a)

	when m_jmp then
		do_jmp(a,m)

	when m_jmpcc then
		d:=getdef(a,1)
		offset:=getrel32(d,getcurrdatalen(7)+1)
		if offset<0 then			!backjump
			if offset<-126 then
				genbyte(0x0F)
				genbyte(0x80+m.cond)
				gendword(offset-4)
			else
				genbyte(0x70+m.cond)
				genbyte(offset)
			fi
		else
			shortjmp:=checkshortjump(m,d)
			if not shortjmp then
				genbyte(0x0F)
				genbyte(0x80+m.cond)
				genrel32(a)
			else
				genbyte(0x70+m.cond)
				genrel8(a)
			fi
		fi

	when m_db, m_ascii then
		genopnd(a,1)
	when m_dw then
		genopnd(a,2)
	when m_dd then
		genopnd(a,4)
	when m_dq then
		genopnd(a,8)

	when m_csegment then
		switchseg(code_seg)
	when m_isegment then
		switchseg(idata_seg)
	when m_zsegment then
		switchseg(zdata_seg)

	when m_nop, m_halt then
		genbyte(mclcodes[m.opcode])

	when m_cbw then
		genbyte(0x66)
		genbyte(0x98)

	when m_cwd then
		genbyte(0x66)
		genbyte(0x99)

	when m_cdq then
		genbyte(0x99)

	when m_cqo then
		genbyte(0x48)
		genbyte(0x99)

	when m_ret then
		genbyte(0xC3)

	when m_retn then
		if a.mode<>a_imm then axerror("retn?") fi
		genbyte(0xC2)
		genword(a.value)

	when m_push then
		do_push(a)

	when m_pop then
		do_pop(a)

	when m_inc, m_dec then
		do_inc(a,mclcodes[m.opcode])

	when m_neg, m_notx, m_mul, m_imul, m_div, m_idiv then
		do_neg(a,mclcodes[m.opcode])

	when m_add, m_sub, m_andx, m_orx, m_xorx, m_adc, m_sbb, m_cmp then
		do_arith(a,b, mclcodes[m.opcode])

	when m_mov then
		do_mov(a,b)

	when m_lea then
		do_lea(a,b)

	when m_movsx then
		do_movsx(a,b,0xBE)

	when m_movzx then
		do_movsx(a,b,0xB6)

	when m_movsxd then
		do_movsxd(a,b)

	when m_xchg then
		do_exch(a,b)

	when m_imul2 then
		do_imul2(a,b)

	when m_resb, m_resw, m_resd, m_resq then
		if a.mode=a_imm then
			n:=a.value*mclcodes[m.opcode]
			case currseg
			when code_seg then
				to n do genbyte(0x90) od
			when idata_seg then
				to n do genbyte(0) od
			else
				ss_zdatalen+:=n
			esac
		
		else
			axerror("resb?")
		fi

	when m_align then
		if a.mode=a_imm then
			x:=a.value
			if x<1 or x>16384 then axerror("align2") fi
			buffercheck(currdata, x)
			if currseg<>zdata_seg then
				while bufferlength(currdata) rem x do genbyte((currseg=code_seg|0x90|0)) od
			else
				while ss_zdatalen rem x do	++ss_zdatalen od
			fi
		else
			axerror("align?")
		fi

	when m_shl,m_shr,m_sar,m_rol,m_ror,m_rcl,m_rcr then
		do_shift(a,b,mclcodes[m.opcode])

	when m_test then
		do_test(a,b)

	when m_loopcx, m_loopz, m_loopnz then
		do_loop(a,mclcodes[m.opcode])

	when m_jecxz then
		do_jcxz(a,4)

	when m_jrcxz then
		do_jcxz(a,8)

	when m_xlat then
		genbyte(0xD7)

	when m_setcc then
		do_setcc(m.cond,a)

	when m_movd then
		do_movxmm(a,b,4)

	when m_movq then
		do_movxmm(a,b,8)

	when m_addss, m_subss, m_mulss, m_divss, m_sqrtss, m_minss, m_maxss then
		do_arithxmm(a,b,0xF3,mclcodes[m.opcode])

	when m_addsd, m_subsd, m_mulsd, m_divsd, m_sqrtsd, m_minsd, m_maxsd then
		do_arithxmm(a,b,0xF2,mclcodes[m.opcode])

	when m_andps,m_xorps then
		do_logicxmm(a,b,mclcodes[m.opcode],4)

	when m_andpd,m_xorpd,m_pand,m_pxor then
		do_logicxmm(a,b,mclcodes[m.opcode],8)

	when m_comiss then
		do_arithxmm(a,b,0,0x2F)

	when m_comisd, m_ucomisd then
		do_arithxmm(a,b,0x66,mclcodes[m.opcode])

	when m_cvtss2sd then
		do_convertfloat(a,b,0xF3)

	when m_cvtsd2ss then
		do_convertfloat(a,b,0xF2)

	when m_cvtss2si then
		do_fix(a,b,0xF3,0x2D)

	when m_cvtsd2si then
		do_fix(a,b,0xF2,0x2D)

	when m_cvttss2si then
		do_fix(a,b,0xF3,0x2C)

	when m_cvttsd2si then
		do_fix(a,b,0xF2,0x2C)

	when m_cvtsi2ss then
		do_float(a,b,0xF3)

	when m_cvtsi2sd then
		do_float(a,b,0xF2)

!	when m_param then
!		extraparam:=a

	when m_cmovcc then
		do_cmovcc(m.cond, a,b)

	when m_fsqrt,m_fsin,m_fcos,m_fsincos,m_fptan, m_fpatan,m_fabs,m_fchs then
		genbyte(0xD9)
		genbyte(mclcodes[m.opcode])

	when m_fld, m_fst, m_fstp then
		do_fmem(a,1,mclcodes[m.opcode])

	when m_fild, m_fist, m_fistp then
		do_fmem(a,0,mclcodes[m.opcode])

	when m_fadd, m_fsub, m_fmul, m_fdiv then
		genbyte(0xDE)
		genbyte(mclcodes[m.opcode])

	when m_cmpsb then
		genbyte(0xA6)

	when m_cmpsw then
		genbyte(0x66)
		genbyte(0xA7)
	when m_cmpsd then
		genbyte(0xA7)
	when m_cmpsq then
		genbyte(0x48)
		genbyte(0xA7)

	when m_rdtsc then		!single opcodes that need a 0x0F prefix
		genbyte(0x0F)
		genbyte(mclcodes[m.opcode])

	when m_movdqa, m_movdqu then
		do_movdqx(a,b,mclcodes[m.opcode])

	when m_finit then
		genbyte(0xDB)
		genbyte(0xE3)

	when m_fldz, m_fld1, m_fldpi, m_fld2t, m_fld2e, m_fldlg2, m_fldln2 then
		genbyte(0xD9)
		genbyte(mclcodes[m.opcode])

	when m_popcnt then
		do_popcnt(a,b)

	when m_bsf, m_bsr then
		do_bsf(a,b,mclcodes[m.opcode])

	when m_cpuid then
		genbyte(0x0F)
		genbyte(0xA2)

	when m_bswap then
		do_bswap(a)

	when m_shld, m_shrd then
		do_dshift(a, b, m.c, mclcodes[m.opcode])

	when m_comment, m_endx then
	else
		println "*** Can't do opcode",mclnames[m.opcode],"line",aaseqno,=M.OPCODE,=M_HALT
	CPL
	CPL
	AXERROR("STOPPING")
!	end switch
	end

end

proc start=
	ishighreg[r3]:=0x40
	ishighreg[r5]:=0x40
	ishighreg[r14]:=0x40
	ishighreg[r15]:=0x40
end

proc genword(int x)=
	addword(currdata,x)
end

proc gendword(int x)=
	adddword(currdata,x)
end

proc genqword(i64 x)=
	addqword(currdata,x)
end

proc genopnd(mclopnd a,int size=0)=
!generate any label/offset/label+offset/immstring part
!ignore reg etc
!any labels, assume abs addresses of 32 or 64 bits
	ref char s
	i64 x
	int length

	if size=0 then size:=a.size fi

	case a.valtype
	when stringimm_val then
		s:=a.svalue
		length:=strlen(s)
		if length>100 then
			buffercheck(currdata,max(1024,length+1))
		fi
		while s^ do
			genbyte(s++^)
		od
		return
	WHEN NAME_VAL THEN
		PRINTLN "GENSS/NAME OPND"
	esac

	if getdef(a) and size<=2 then
		axerror("8/16-BIT RELOC")
	fi

	case size
	when 1 then
		genbyte(a.value)
	when 2 then
		genword(a.value)
	when 4 then
		case a.valtype
		when intimm_val then
			gendword(a.value)
		when realimm_val then
			r32 x32
			x32:=a.xvalue
			gendword(i32@(x32))
!		when realmem_val then
!			CPL "		OPND/REALMEM4"
!		when stringimm_val then
!			CPL "		OPND/STRINGIMM4"
		when def_val,label_val then
			genabs32(a)
!		when name_val then
!			CPL "		OPND/NAME4"
		else
			cpl valtypenames[a.valtype]
			axerror("OPND/4/VALTYPE?")
		esac

	when 8 then
		case a.valtype
		when intimm_val then
			genqword(a.value)
		when realimm_val then
			genqword(i64@(a.xvalue))
!		when realmem_val then
!			CPL "		OPND/REALMEM8",ALINENO
!		when stringimm_val then
!			CPL "		OPND/STRINGIMM8"
		when def_val,label_val then
			genabs64(a)
!		when name_val then
!			CPL "		OPND/NAME8"
		else
			cpl valtypenames[a.valtype]
			axerror("OPND/8/VALTYPE?")
		esac

	esac
end

proc addrelocitem(int reloctype, psymbol d)=
	ref relocrec r
	int stindex, adjust

!CPL "GETST3", D.NAME
	stindex:=getstindex(d)

	adjust:=4
	if reloctype=addr64_rel then adjust:=8 fi

!	r:=pcm_alloc(relocrec.bytes)
	r:=pcm_allocnfz(relocrec.bytes)
	r.nextreloc:=currrelocs
	r.reloctype:=reloctype
	r.offset:=getcurrdatalen(1)-adjust
	r.stindex:=stindex

	++nrelocs
	currrelocs:=r
end

func getstindex(psymbol d)int=
!retrieve existing obj st index, or create new one
	if d.stindex=0 then
		if ss_nsymbols>=ss_symboltablesize then
			extendsymboltable()
		fi
		d.stindex:=++ss_nsymbols

		ss_symboltable[d.stindex]:=d

		if d.segment=0 then
			if d.imported then
				d.segment:=code_seg
			fi
		fi

	fi
	return d.stindex
end

proc genrel32(mclopnd a)=
!used by call/longjmp/ddoffset
	psymbol d

!CPL "GENREL32"
	d:=getdef(a)

	if d=nil then				!constant
		gendword(a.value)
		return
	fi

	case d.reftype
	when back_ref then
		if d.segment<>currseg then
			axerror("Rel label across segments")			!might be Ok if treated as external?
		fi
		gendword(d.offset-(getcurrdatalen(2)+4)+a.offset)
	when fwd_ref then
		d.fwdrefs:=addfwdref(d.fwdrefs,getcurrdatalen(3),rel32_rel)
		gendword(a.offset)
	else								!external psymbol
		gendword(a.offset)		!this is probably just zero
		addrelocitem(rel32_rel,d)
	esac
end

func getdef(mclopnd a,int dneeded=0)psymbol =
	psymbol d

	if a.mode in [a_mem,a_imm] then
		case a.valtype
		when label_val then
			return labeldeftable[a.labelno]
		when def_val then
			d:=a.def
			if d.reftype=0 then
				if not d.imported then
					d.reftype:=fwd_ref
				fi
			fi

			return d
		esac
	fi
	if dneeded then				!must return a non-nil value
		println opndnames_ma[a.mode],valtypenames[a.valtype]
		axerror("getdef/no def")
	fi
	return nil
end

proc genabs32(mclopnd a)=
!absolute refs to labels
	psymbol d

	d:=getdef(a,1)

	case d.reftype
	when back_ref then

		gendword(d.offset+a.offset)
		addrelocitem(addr32_rel,d)

	when fwd_ref then
		d.fwdrefs:=addfwdref(d.fwdrefs,getcurrdatalen(4),addr32_rel,currseg)
		if d.id in [local_id, param_id] then
			gendword(d.offset+a.offset)
		else
			gendword(a.offset)
			addrelocitem(addr32_rel,d)
		fi

	else								!external psymbol
		gendword(a.offset)					!this is probably just zero
		addrelocitem(addr32_rel,d)
	esac
end

proc genabs64(mclopnd a)=
!absolute refs to labels
	psymbol d

	d:=getdef(a,1)

	case d.reftype
	when back_ref then
		genqword(d.offset+a.offset)
		addrelocitem(addr64_rel,d)

	when fwd_ref then
		d.fwdrefs:=addfwdref(d.fwdrefs,getcurrdatalen(5),addr64_rel,currseg)
		if d.id in [local_id, param_id] then
			genqword(d.offset+a.offset)
		else
			genqword(a.offset)
			addrelocitem(addr64_rel,d)
		fi

	else								!external psymbol
		genqword(a.offset)				!this is probably just zero
		addrelocitem(addr64_rel,d)
	esac
end

func getrel32(psymbol d,int offset)int=
!get rel difference between offset in this segment, and label d
	if d.reftype=back_ref then					!defined earlier in this segment
		if d.segment<>currseg then
			axerror("Rel label across segments2")
		fi
		return d.offset-(offset+1)
	else
		return i32.max
	fi
end

proc dofwdrefs(psymbol d)=
!label d has been encountered
!update any fwd refs
!assume inside same offset, at least for rel-32 which only works in text segment
	ref fwdrec f
	int offset, seg
	ref byte p8
	ref i32 p32
	ref i64 p64
	ref dbuffer data

	if d.fwdrefs=nil then return fi
	f:=d.fwdrefs

	while f do
		offset:=f.offset

		case f.reltype
		when rel32_rel then
			p32:=bufferelemptr(currdata,offset)
			p32^:=d.offset-offset-4

		when addr32_rel,addr64_rel then
			case f.seg
			when code_seg then data:=ss_code
			when zdata_seg then axerror("Fwd ref in zdata")
			when idata_seg then data:=ss_idata
			esac

			p32:=bufferelemptr(data,offset)
			if f.reltype=addr32_rel then
				p32^:=p32^+d.offset
			else
				p64:=cast(p32)
				p64^:=p64^+d.offset
			fi
		when rel8_rel then
			p8:=bufferelemptr(currdata,offset)
			p8^:=d.offset-offset-1
		else
			CPL RELOCNAMES[F.RELTYPE],D.NAME
			AXERROR("DOFWDREFS/CAN'T DO RELTYPE")
		esac

		f:=f.nextfwd
	od
end

proc genrex=
	if f2override then genbyte(0xF2) fi
	if f3override then genbyte(0xF3) fi
	if sizeoverride then genbyte(0x66) fi
	if addroverride then genbyte(0x67) fi

	if nowmask then rex.[wbit]:=0 fi

	if rex then genbyte(rex iand 15+0x40) fi
end

func isbytesized(i64 x)int=
	return -128<=x<=127
end

func isdwordsized(i64 x)int=
	return i32.min<=x<=i32.max
end

proc genamode(mclopnd a, amoderec am)=
	psymbol d
	ref riprec pr

	genbyte(am.modrm)

	if am.usesib=1 then
		genbyte(am.sib)
	fi

	case am.dispsize			!disp bytes
	when 0 then
	when 1 then
		genbyte(am.offset)
	when 4 then
		if am.usesib=-1 then
			pr:=pcm_alloc(riprec.bytes)
			pr.next:=riplist
			pr.offset:=currdata.pcurr-currdata.pstart
			ripentry:=riplist:=pr
		fi
		case a.mode
		when a_mem then
			case a.valtype
			when def_val, label_val then
				genabs32(a)
			when no_val, temp_val then
				gendword(am.offset)
			else
				axerror("genam/3")
			esac
		else
			CPL OPNDNAMES_MA[A.MODE]
			axerror("GENAMODE/MODE?")
		esac
	else
		axerror("genamode size 2/8")
	esac
end

proc setopsize(mclopnd a)=
	case a.size
	when 8 then			!override default 4 bytes
	    rex ior:=wmask
	when 4 then			!assume 4 bytes is default
	when 1 then			!assume set via specific opcodes
	when 2 then			!override default 4 bytes
		sizeoverride:=1
	else
		axerror("Operand size not set")
	esac
end

func getdispsize(mclopnd a, i32 &offset)int=
!look at imm/mem displacement, and return (0,1 or 4) and offset
!0 is returned when no disp is needed (no labeldef and offset is zero)
!unless mand=1 then 1 is returned
	psymbol d

	d:=getdef(a)
	offset:=a.offset

	if d then
		if d.id in [local_id, param_id] then
			offset+:=d.offset
		else
			return 4
		fi
	fi

	if offset then
		return (isbytesized(offset)|1|4)
	else
		return 0
	fi
end

proc checkhighreg(mclopnd a)=
	if a.mode=a_reg then
		rex ior:=ishighreg[a.reg]
	fi
end

proc do_loop(mclopnd a,int opc)=
	int offset

	offset:=getrel32(getdef(a,1),getcurrdatalen(9)+1)
	if offset<0 then			!backjump
		if offset<-126 then
			axerror("loop jmp out of range")
		fi
		genbyte(opc)
		genbyte(offset)
	else
		axerror("Can't do loopxx fwd jump")
	fi
end

proc do_jcxz(mclopnd a,int opsize)=
	int offset

	offset:=getrel32(getdef(a,1),getcurrdatalen(10)+1)
	if offset<0 then			!backjump
		if offset<-126 then
			axerror("jcxz jmp out of range")
		fi
		if opsize=4 then genbyte(0x67) fi
		genbyte(0xE3)
		genbyte(offset)
	else
		axerror("Can't do jcxz fwd jump")
	fi
end

proc do_call(mclopnd a)=
	int am, regcode
	case a.mode
	when a_imm then
		genbyte(0xE8)
		genrel32(a)
	else				!indirect call
		case a.size
		when 0 then a.size:=8
		when 1,2,4 then
			axerror("call[]size")
		esac

		genxrm(0xFF, 2, a)

	esac
end

proc do_jmp(mclopnd a,ref mclrec m)=
	int am, regcode, offset, shortjmp
	psymbol d:=getdef(a)

	case a.mode
	when a_imm then
		offset:=getrel32(d, getcurrdatalen(11)+1)
		if offset<0 and offset>-126 then
			genbyte(0xEB)
			genbyte(offset)
		else
			shortjmp:=0
			if offset>0 then				!fwd jump
!check if destlabel occurs within next 8 instrs, then likely to need short disp
				shortjmp:=checkshortjump(m, d)
			fi

			if not shortjmp then
				genbyte(0xE9)
				genrel32(a)
			else
				genbyte(0xEB)
				genrel8(a)
			fi
		fi
	else				!indirect jump
		case a.size
		when 0 then a.size:=8
		when 1,2,4 then
			axerror("jmp[]size")
		esac

		genxrm(0xFF, 4, a)
	esac

end

func getcurrdatalen(int id)int=
!I think that zdata-seg is only likely when id=6

	if currseg=zdata_seg then
		return ss_zdatalen
	fi
	return bufferlength(currdata)
end

proc do_cmovcc(int cond, mclopnd a,b)=
	if a.size<>b.size and b.size then
		axerror("1:Opnd size mismatch")
	fi
	if a.size=1 then axerror("cmov/byte") fi

	genrrm(0x0F'40+cond, a, b)
end

proc do_fmem(mclopnd a, int freal, code)=
!do fld/fild/fst/fstp/fist,fistp
!freal=1 for fld/etc, 0 for fild etc
!code is middle 3 bits of 2nd byte: 0=load, 2=store, 3=store+pop
	int am, regcode, mf

	if a.mode<>a_mem then
		axerror("fmem/not mem")
	fi

	if freal then
		case a.size
		when 4 then mf:=0
		when 8 then mf:=2
		when 10,16 then
			mf:=1
			case code
			when 0 then code:=5
			when 3 then code:=7
			else
				axerror("r80 not allowed")
			esac
		else
			CPL "SIZE=",A.SIZE
			axerror("fmem size")
		esac
	else
		case a.size
		when 2 then mf:=3
		when 4 then mf:=1
		when 8 then
			mf:=3
			case code
			when 0 then code:=5
			when 3 then code:=7
			else
				axerror("fst i64?")
			esac
		else
			axerror("fmem int size")
		esac
	fi
	
	genxrm(0xD9+mf<<1, code, a)
end

proc genrel8(mclopnd a)=
!a is a known fwd reference, and expected to be <=127 bytes
	psymbol d

	d:=getdef(a,1)

	if d.reftype=fwd_ref then
		d.fwdrefs:=addfwdref(d.fwdrefs,getcurrdatalen(3),rel8_rel)
		genbyte(0)
	else								!external psymbol
		axerror("genrel8")
	fi
end

func checkshortjump(ref mclrec m,psymbol d)int=
!at mccode[index] which should contain a jmp/jmpcc instruction
!d is the labeldef being jumped to
!return 1 if this is certain to be a short jump (8-bit disp) otherwise 0 
!return 0
! d can be a named label, or a labelno; either should have .labelno set
	int n
	mclopnd a

	n:=0
	m:=m.nextmcl
	while m and n<=8 do
		case m.opcode
		when m_labelx then
			a:=m.a

			case a.valtype
			when label_val then
				if a.labelno=d.labelno then return 1 fi
			when def_val then
				if a.def=d then return 1 fi
			esac

		when m_comment, m_endx then
		when m_resb then
			return 0
		else
			++n
		esac
		m:=m.nextmcl
	od

	return 0
end

func addfwdref(ref fwdrec p, int offset, reltype, seg=0)ref fwdrec=
	ref fwdrec q

!	q:=pcm_alloc(fwdrec.bytes)
	q:=pcm_allocnfz(fwdrec.bytes)
	q.nextfwd:=p
	q.offset:=offset
	q.reltype:=reltype
	q.seg:=seg
	return q
end

proc switchseg(int newseg)=
	if newseg=currseg then return fi

	case currseg						!reloc linked list roots must be updated
	when code_seg then
		ss_coderelocs:=currrelocs
		ss_ncoderelocs:=nrelocs
	when idata_seg then
		ss_idatarelocs:=currrelocs
		ss_nidatarelocs:=nrelocs
	esac

	currseg:=newseg

	case currseg
	when code_seg then
		currdata:=ss_code
		currrelocs:=ss_coderelocs
		nrelocs:=ss_ncoderelocs
	when idata_seg then
		currdata:=ss_idata
		currrelocs:=ss_idatarelocs
		nrelocs:=ss_nidatarelocs
	when zdata_seg then
		currdata:=ss_zdata
	esac							!else 0, done at end to update linked lists

end

proc do_popcnt(mclopnd a,b)=
	int am, regcode

	if b.mode=a_mem then
		if b.size=0 then b.size:=8 fi
	fi

	f3override:=1
	genrrm(0x0F'B8, a, b)
end

proc do_bsf(mclopnd a,b, int opc)=
	int am, regcode

	if b.mode=a_mem then
		if b.size=0 then b.size:=8 fi
	fi
	if a.size<>b.size then axerror("bsf size") fi

	genrrm(0x0F<<8+opc, a, b)
end

proc extendsymboltable=
	ref[]psymbol oldsymboltable
	int oldsymboltablesize

	oldsymboltablesize:=ss_symboltablesize
	oldsymboltable:=ss_symboltable

	ss_symboltablesize*:=2

	ss_symboltable:=pcm_alloc(ref void.bytes*ss_symboltablesize)

	for i:=1 to ss_nsymbols do
		ss_symboltable[i]:=oldsymboltable[i]
	od

	pcm_free(oldsymboltable,ref void.bytes*oldsymboltablesize)
end

global proc initlib(int nlabels)=
	[256]char str
	psymbol d

	ss_symboltable:=pcm_alloc(init_ss_symbols*ref void.bytes)
	ss_symboltablesize:=init_ss_symbols
	ss_nsymbols:=0
	labeldeftable:=pcm_alloc(nlabels*ref void.bytes)

!IF NLABELS<MLABELNO THEN
!CPL "INITLAB: BAD LABEL COUNT"
!CPL "INITLAB: BAD LABEL COUNT"
!!SROP
!STOP
!FI
!
!CPL "//INITLIB", NLABELS
!STOP

	for i to nlabels do
		d:=labeldeftable[i]:=pcm_allocnfz(pstrec.bytes)

!CPL "SETTING LAB",I,"TO",D
		d.labelno:=i
		fprint @str,"l#",i
		d.name:=pcm_copyheapstring(str)
		d.reftype:=fwd_ref
	od
end

global func buffercreate(int size=1024)ref dbuffer=
	ref dbuffer a

	a:=pcm_alloc(dbuffer.bytes)

	a.alloc:=size
	a.pstart:=a.pcurr:=pcm_alloc(a.alloc)
	a.pend:=a.pstart+a.alloc
	return a
end

proc bufferexpand(ref dbuffer a)=
	int newalloc,usedbytes
	ref byte p

	newalloc:=a.alloc*2
	usedbytes:=a.pcurr-a.pstart

	if usedbytes>a.alloc then
		println "dbuffer error"
		stop
	fi

	p:=pcm_alloc(newalloc)
	memcpy(p,a.pstart,usedbytes)
	a.pstart:=p
	a.pcurr:=p+usedbytes
	a.alloc:=newalloc
	a.pend:=p+newalloc
end

global proc buffercheck(ref dbuffer a,int n=1024)=
	while a.pend-a.pcurr<n do
		bufferexpand(a)
	od
end

global func bufferlength(ref dbuffer a)int=
	return a.pcurr-a.pstart
end

global func bufferelemptr(ref dbuffer a, int offset)ref void=
	return a.pstart+offset
end

global proc addword(ref dbuffer a, int x)=
	a.pcurr16^:=x
	++(a.pcurr16)
end

global proc adddword(ref dbuffer a, int x)=
	a.pcurr32^:=x
	++(a.pcurr32)
end

global proc addqword(ref dbuffer a, i64 x)=
	a.pcurr64^:=x
	++(a.pcurr64)
end

proc genxrm(int opcode, code, mclopnd b)=
!deal with /d instructions, where code = 0..7
	amoderec am

	setopsize(b)

	am:=genrm(0, code, b, 0)

	case currmcl.opcode
	when m_push, m_pop then rex.[wbit]:=0
	esac


!	if opbytes[2] then genbyte(opbytes[2]) fi		!extra opcodes will not be 0
!	if opbytes[1] then genbyte(opbytes[1]) fi
	if opcode.[16..23] then genbyte(opcode.[16..24]) fi
	genrex()
	if opcode.[8..15] then genbyte(opcode.[8..15]) fi

	genbyte(opcode)
	genamode(b,am)
end

proc genrrm(int opcode, mclopnd a, b)=
!deal with /r instructions; rrm = reg,reg/mem
!opcode represents 1, 2 and maybe 3-byte(?) opcodes, with last in lsb place
!a is a register mclopnd, b is a register or memory mclopnd, always
!when data direction is the other way, as in mov reg/mem, reg, then reverse mclopnds
!Output will be:
! Any override prefixes
! Any rex prefix
! 1 or 2 (or 3?) opcode bytes
! modrm byte
! possible sib byte
! Any address offset (which may be an imm value, or fwd label, or external etc)
!Any additional immediate data that follows should be added by the caller.
!There are two main modes:
! REG, REG   2 registers are involved; there is no address offset, no sib byte
! REG, MEM   1, 2 or 3 registers are involved. Last 2 may be base and index registers,
!            and the index register may be scaled
	amoderec am
!	[0..7]byte opbytes @opcode

!CPL "GENRRM", OPCODE:"Z6H", A,B


!	checkhighreg(a)
	if a.mode=a_reg then rex ior:=ishighreg[a.reg] fi

	setopsize(a)

	if usesizeb then				!wmask comes from b
		rex.[wbit]:=0
		if b.size=8 then rex ior:=wmask fi
	fi

	am:=genrm(a.reg, 0, b, a.mode=a_xreg)

	if opcode.[16..23] then genbyte(opcode.[16..24]) fi
	genrex()
	if opcode.[8..15] then genbyte(opcode.[8..15]) fi

	genbyte(opcode)

	genamode(b,am)
end

func getregcode(int reg, int mask, isxreg=0)int regcode=
!convert m-register code (1 to 16/20) to hardware code (0..7 plus any rex bits)
!mask is the rex bit to set for high registers
!isxreg is 1 for float registers, where I don't need to do the usual mapping

	if not isxreg then
		regcode:=regcodes[reg]
	else
		regcode:=reg-1			!xr1 is 1; xmm0 is 0
	fi

	if regcode>=8 then
		regcode-:=8
		rex ior:=mask
	fi
	regcode
end

proc checkimmrange(int value, size)=
	case size
	when 1 then
		unless -128<=value<=255 then axerror("exceeding byte value") end

	when 2 then
		unless -32768<=value<=65535 then axerror("exceeding u16 value") end
	else
		unless -0x8000'0000<=value<=0xFFFF'FFFF then axerror("2:exceeding u32 value") end
	esac
end

func genrm(int reg, opc, mclopnd b, int isxreg=0)amoderec=
!reg =  0:	opc is a 3-bit code that goes in reg field of mod-reg-rm
!reg >= r0:	reg is an M-register code, which is converted to a machine reg encoding
!			of 3 bits (to go in middle of modrm byte), and may set rex.r bit for high
!			regs; opc is 0 in this case
!
!b is mclopnd containing rhs reg value, or is mem mclopnd using base/index regs and addr
!For now, return same encoded value as old genrm

	static []int scaletable=( 0, 1, 0, 2, 0, 0, 0, 3)
	int mode, rm, scale, index, base
	int regix, code, ismem
	amoderec am

	clear am

!deal with first reg/opc field

	if reg then				!else use opc as-is
		opc:=getregcode(reg, rmask, isxreg)
	fi

	case b.mode
	when a_reg, a_xreg then			!modrm can only ref to a single register
		rm:=getregcode(b.reg, bmask, b.mode=a_xreg)
		rex ior:=ishighreg[b.reg]

		am.modrm:=makemodrm(3,opc,rm)
		return am

	when a_mem then
		ismem:=1
		case b.valtype
		when def_val then
			if b.def.id=static_id then ismem:=2 fi
		when realmem_val then ismem:=2
		when label_val then ismem:=2
		esac

	else
		axerror("genrm not mem")
	esac

	mode:=rm:=0				!modrm is (mode, x, rm), of (2,3,3) bits
	scale:=0				!0=modrm only; 1/2/4/8 means sib used

	reg:=b.reg
	regix:=b.regix

	if reg=regix=0 then						!address only
		mode:=0
		rm:=4
		scale:=1
		index:=4
		base:=5
		am.dispsize:=4

	elsif b.scale<=1 and regix=0 then			!simple address mode (no sib)
SIMPLE:
		am.dispsize:=getdispsize(b, am.offset)
		if am.dispsize then
			mode:=(am.dispsize=1|1|2)
		fi

		rm:=base:=getregcode(reg, bmask)

		if rm<>4 then
			if rm=5 and am.dispsize=0 then
				mode:=1; am.dispsize:=1
			fi
			index:=0
		else
			index:=4				!means no index
			scale:=1				!force sib

		fi
	elsif regix and reg=0 then

IF B.SCALE<=1 THEN					!try and avoid sib
		SWAP(REG, REGIX)
		GOTO SIMPLE
FI

		am.dispsize:=4
		mode:=0
		rm:=4
		scale:=(b.scale|b.scale|1)
		base:=5
		index:=getregcode(regix, xmask)
		if regix=rstack then axerror("Scaled rstack?") fi

	else									!assume regix used; optional reg and disp
		am.dispsize:=getdispsize(b, am.offset)
		if am.dispsize then
			mode:=(am.dispsize=1|1|2)
		fi
		rm:=4

		scale:=(b.scale|b.scale|1)
!CP "SCAD"
		if reg=0 then
			base:=5
		else
			if reg in [rframe,r7] and am.dispsize=0 then
				mode:=1; am.dispsize:=1
			fi
			base:=getregcode(reg, bmask)
		fi

		if regix=0 then
			index:=4
		else
			index:=getregcode(regix, xmask)
			if not reg then
				am.dispsize:=4
			fi
			if regix=rstack and scale>1 then axerror("Can't scale rstack") fi
		fi
	fi

	if scale then
		am.sib:=scaletable[scale]<<6 + index<<3 + base
		am.usesib:=1
	fi

	if am.dispsize=4 and ismem then
		if reg or regix then
			if phighmem=2 AND ISMEM=2 then
				CPL "Addr32 can't use RIP, line",aaseqno,STRMCLSTR(CURRMCL)
			fi
		elsif phighmem then
			am.usesib:=-1
			mode:=0
			rm:=5
		fi
	fi

	am.modrm:=makemodrm(mode, opc, rm)

	return am
end

proc do_arith(mclopnd a,b,int code)=
!code is 3-bit 0..7 value indicating which of add, sub, and, or, xor, adc, sbb, cmp
!ops is being done
	psymbol d
	int opc, dispsize
	i64 x

	case a.mode
	when a_reg then
		case b.mode
		when a_reg,a_mem then
			opc:=code<<3 ior (a.size=1|0x02|0x03)
			genrrm(opc, a, b)

		when a_imm then
	doregimm:
			d:=getdef(b)
			if d then
				if a.size<4 then axerror("add imm/size") fi
				genxrm(0x81, code, a)
				genopnd(b,4)
				return
			fi

			x:=b.value
			dispsize:=1
			if a.size=1 then
				opc:=0x80
!				if x not in -128..127 then axerror("Exceeding i8 range") fi
				checkimmrange(x,1)
				if x not in -128..255 then axerror("Exceeding i8/u8 range") fi
			elsif -128<=x<=127 then
				opc:=0x83
			else
				checkimmrange(x,4)
				opc:=0x81
				dispsize:=(a.size=2|2|4)
			fi

			genxrm(opc, code, a)

			case dispsize
			when 1 then genbyte(x)
			when 2 then genword(x)
			when 4 then gendword(x)
			esac
			fixrip(dispsize)

		else
			axerror("ADD reg,???")
		esac

	when a_mem then
		case b.mode
		when a_reg then
			opc:=code<<3 ior (b.size=1|0x00|0x01)
			genrrm(opc, b, a)

		when a_imm then
			goto doregimm
		else
			axerror("ADD mem,???")
		esac

	else
	cpl opndnames_ma[code],=CODE
		axerror("1:Can't add to this opnd")
	esac
end

proc do_mov(mclopnd a,b)=
	int regcode, opc, dispsize
	i64 value
	psymbol d:=getdef(b)

	case a.mode
	when a_reg then
		case b.mode
		when a_reg, a_mem then
			if a.size<>b.size and b.size then axerror("2:Opnd size mismatch") fi

			genrrm((a.size=1|0x8A|0x8B), a, b)

		when a_imm then
			value:=b.value

			regcode:=getregcode(a.reg, bmask)
			setopsize(a)
			if d and a.size<=2 then axerror("mov imm?") fi

			CHECKHIGHREG(A)

			case a.size
			when 1 then
				unless -128<=value<=255 then axerror("exceeding byte value") end
				genrex()
				genbyte(0xB0+regcode)
				genbyte(value)

			when 2 then
				unless -32768<=value<=65535 then axerror("exceeding u16 value") end
				genbyte(0x66)
				genrex()
				genbyte(0xB8+regcode)
				genword(value)
			when 4 then
				if d then
					genrex()
					genbyte(0xB8+regcode)
					genopnd(b,4)
				else
					unless -0x8000'0000<=value<=u32(0xFFFF'FFFF) then
						CPL value,ref void(value)
						axerror("1:exceeding u32 value")
					end
doreg32:
					genrex()
					genbyte(0xB8+regcode)
					gendword(value)
				fi

			else							!assum 8 bytes
				if d then
					rex ior:=wmask
					genrex()
					genbyte(0xB8+regcode)
					genopnd(b,8)
				else
					if value>=0 and value<=0xFFFF'FFFF then		!mov r64,imm -> r32,imm
						rex.[wbit]:=0
						goto doreg32			!load 32-bit value which is zero-extended to 64
					fi
!there might be short form for negative values that fit into 32 bits, using other opcs
!but ignore that for now
					rex ior:=wmask
					genrex()
					genbyte(0xB8+regcode)
					genqword(value)
				fi

			esac

		else
			axerror("MOV REG/??")
		esac
	when a_mem then
		case b.mode
		when a_reg then

			if a.size=0 then a.size:=b.size fi
			if a.size<>b.size and a.size then axerror("3:Opnd size mismatch") fi
			genrrm((b.size=1|0x88|0x89), b, a)

		when a_imm then
			value:=b.value

			if a.size=0 then a.size:=1 fi
			if d and a.size<=2 then axerror("mov imm?") fi
			setopsize(a)
			opc:=(a.size=1|0xC6|0xC7)

			if not d then checkimmrange(value, a.size) fi

			genxrm(opc, 0, a)
			value:=b.value

			dispsize:=a.size
			case a.size
			when 1 then
				genbyte(value)
	
			when 2 then
				genword(value)
			when 4,8 then
				genopnd(b,4)
				dispsize:=4
			esac
			fixrip(dispsize)	
		else
			axerror("MOV MEM/?")
		esac
	else
		axerror("MOV ?/..")
	esac
end

proc do_push(mclopnd a)=
	int code

	if a.size=0 then a.size:=8 fi

	case a.mode
	when a_reg then
		if a.size<>8 then axerror("pushreg not 64-bit") fi
		code:=getregcode(a.reg, bmask)
		rex.[wbit]:=0
		genrex()
		genbyte(0x50+code)

	when a_imm then
		if getdef(a) then
			genbyte(0x68)
			genopnd(a,4)
		elsif isbytesized(a.value) then
			genbyte(0x6A)
			genbyte(a.value)
		elsif isdwordsized(a.value) then
			genbyte(0x68)
			gendword(a.value)
		else
			axerror("push imm value too large")
		fi

	when a_mem then
		if a.size<>8 then axerror("push not 64-bit") fi
		genxrm(0xFF, 6, a)

	else
		axerror("push opnd?")
	esac
end

proc do_pop(mclopnd a)=
	int code

	if a.size=0 then a.size:=8 fi

	case a.mode
	when a_reg then
		if a.size<>8 then axerror("popreg not 64-bit") fi
		code:=getregcode(a.reg, bmask)
		genrex()
		genbyte(0x58+code)

	when a_mem then
		if a.size<>8 then axerror("pop not 64-bit") fi
		genxrm(0x8F, 0, a)
	else
		axerror("pop opnd?")
	esac
end

proc do_inc(mclopnd a,int code)=
!inc/dec

	case a.mode
	when a_reg, a_mem then
		genxrm((a.size=1|0xFE|0xFF), code, a)
	else
		axerror("inc/opnd?")
	esac
end

proc do_neg(mclopnd a,int code)=
!neg/not/mul/imul/div/idiv
	case a.mode
	when a_reg, a_mem then
		genxrm((a.size=1|0xF6|0xF7), code, a)
	else
		axerror("neg/div/etc opnd?")
	esac
end

proc do_lea(mclopnd a,b)=
	int regcode, am

	unless a.mode=a_reg and b.mode=a_mem then
		axerror("LEA not reg/mem")
	end

	if a.size<4 then
CPL =A.SIZE
 axerror("LEA size error") fi
	genrrm(0x8D, a, b)
end

proc do_movsx(mclopnd a,b,int opc)=
!opc=B6 for movzx, and BE for movsx
	int am, regcode

	if a.mode<>a_reg then axerror("movsx not reg") fi

	if a.size=8 and b.size=4 then
		if opc=0xBE then
			do_movsxd(a,b)
		else						!movsx 4->8 bytes, do normal move 4->4
			a:=regtable[a.reg,4]
			do_mov(a,b)
		fi
		return
	fi

	if a.size=1 or a.size<=b.size then axerror("movsx size error") fi
	if opc=0xB6 and b.size=4 then axerror("movsx 4=>8 bytes?") fi

	case b.mode
	when a_reg then
	when a_mem then
		if b.size=0 then axerror("movsx need size prefix") fi
		if b.size=8 then axerror("movsx size 8") fi
	else
		axerror("movsx not reg/mem")
	esac

	genrrm(0x0F<<8+(b.size=1|opc|opc+1), a, b)
end

proc do_exch(mclopnd a,b)=
	int regcode, am

	if a.mode=a_reg and b.mode=a_reg and (a.reg=r0 or b.reg=r0) and a.size<>1 then		!simple r0/reg
		if a.reg<>r0 then				!get a to be r0
			swap(a,b)
		fi
		if a.size<>b.size then axerror("exch size") fi

		setopsize(a)
		regcode:=getregcode(b.reg, bmask)
		genrex()
		genbyte(0x90+regcode)
		return
	fi

	if a.mode=a_mem then swap(a,b) fi

	unless a.mode=a_reg and (b.mode=a_reg or b.mode=a_mem) then axerror("exch opnds") end
	if b.size=0 and b.mode=a_mem then b.size:=a.size fi
	if a.size<>b.size then axerror("exch size") fi

	genrrm((a.size=1|0x86|0x87), a, b)
end

proc do_movsxd(mclopnd a,b)=
	int regcode, am

	if b.mode=a_mem and b.size=0 then b.size:=4 fi

	if a.size<>8 or b.size>4 then axerror("movsxd size") fi

	if a.mode<>a_reg or (b.mode<>a_reg and b.mode<>a_mem) then
		axerror("movsxd opnds")
	fi

	genrrm(0x63, a, b)
end

proc do_imul2(mclopnd a,b)=
	int regcode, am, opc, dispsize
	i64 value

	if a.mode<>a_reg then
		axerror("imul2 opnds")
	fi
	if b.size=0 then b.size:=a.size fi
	if a.size=1 then axerror("imul2 byte") fi

	case b.mode
	when a_reg,a_mem then
		if a.size<>b.size then axerror("imul2 size") fi

		genrrm(0x0F'AF, a, b)

	when a_imm then						!imul reg1,reg2,imm but implemented as imul reg,imm
		if getdef(b) then axerror("mul/label") fi
		value:=b.value

		if -128<=value<=127 then
			opc:=0x6B
		else
			opc:=0x69
		fi

		genrrm(opc, a, a)

		if -128<=value<=127 then
			genbyte(value)
			dispsize:=1
		elsif a.size=2 then
			genword(value)
			dispsize:=2
		else
			gendword(value)
			dispsize:=4
		fi
		fixrip(dispsize)
	else
		axerror("imul2 opnds")
	esac
end

proc do_shift(mclopnd a,b,int code)=
	int w,opc,needdisp

	if a.mode<>a_reg and a.mode<>a_mem then axerror("shift opnds1?") fi
	if getdef(b) then axerror("shift/label") fi
	w:=(a.size=1|0|1)
	needdisp:=0

	case b.mode
	when a_imm then
		if b.value=1 then
			opc:=0xD0+w
		else
			opc:=0xC0+w
			needdisp:=1
		fi
	when a_reg then
		if b.reg<>r10 or b.size<>1 then axerror("cl or b10 needed") fi
		opc:=0xD2+w
	else
		axerror("shift opnds2?")
	esac

	genxrm(opc, code, a)

	if needdisp then genbyte(b.value); fixrip(1) fi
end

proc do_test(mclopnd a,b)=
	i64 value
	int opc, am, regcode

	if a.mode=a_reg and a.reg=r0 and b.mode=a_imm then
		value:=b.value
		case a.size
		when 1 then
			genbyte(0xA8)
			genbyte(value)
		when 2 then
			genbyte(0x66)
			genbyte(0xA9)
			genword(value)
		when 4 then
			genbyte(0xA9)
			gendword(value)
		else
			genbyte(0x48)
			genbyte(0xA9)
			gendword(value)
		esac

	elsif (a.mode=a_reg or a.mode=a_mem) and b.mode=a_imm then
		genxrm((a.size=1|0xF6|0xF7), 0, a)

		case a.size
		when 1 then
			genbyte(value)
		when 2 then
			genword(value)
		else
			gendword(value)
		esac
		fixrip(a.size)

	elsif a.mode in [a_reg, a_mem] and b.mode=a_reg then
domemreg:
		genrrm((a.size=1|0x84|0x85), a, b)

	elsif a.mode=a_reg and b.mode=a_mem then
		swap(a,b)
		goto domemreg
	else
		axerror("test opnds")
	fi

end

proc do_setcc(int cond, mclopnd b)=
!a is cond
!b is byte reg/mem

	if b.mode not in [a_reg, a_mem] or b.size>1 then axerror("setcc opnd/size") fi

	genxrm(0x0F'90+cond, 0, b)
end

proc checksize(mclopnd a, int size1=0, size2=0)=
	if a.size=0 then axerror("Need size") fi
	if size1 and a.size not in [size1,size2] then
		CPL =A.SIZE
		axerror("Wrong size")
	fi
end

proc do_arithxmm(mclopnd a,b,int prefix,opc)=
	if a.mode<>a_xreg or (b.mode<>a_xreg and b.mode<>a_mem) then
		axerror("arithxmm opnds")
	fi

	if prefix then genbyte(prefix) fi
	genrrm(0x0F<<8+opc, a, b)
end

proc do_logicxmm(mclopnd a,b,int opc,size)=
	int am, regcode

	if a.mode<>a_xreg or (b.mode<>a_xreg and b.mode<>a_mem) then
		axerror("logicxmm opnds")
	fi

	if size=8 then genbyte(0x66) fi

	genrrm(0x0F<<8+opc, a, b)
end

proc do_convertfloat(mclopnd a,b,int prefix)=
!cvtss2sd and cvtsd2ss
	int am, regcode

	if a.mode<>a_xreg or (b.mode<>a_xreg and b.mode<>a_mem) then
		axerror("convertfloat opnds")
	fi
	genbyte(prefix)
	nowmask:=1
	genrrm(0x0F'5A, a,b)
end

proc do_fix(mclopnd a,b,int prefix,opc)=
	int am, regcode

	if a.mode<>a_reg or (b.mode<>a_xreg and b.mode<>a_mem) then
		axerror("fix opnds")
	fi

	checksize(a, 4, 8)
	
	b.size:=(prefix=0xF3|4|8)

	genbyte(prefix)
	genrrm(0x0F<<8+opc, a, b)
end

proc do_float(mclopnd a,b,int prefix)=
!cvtss2si and cvtsd2si
	if a.mode<>a_xreg or (b.mode<>a_reg and b.mode<>a_mem) then
		axerror("float opnds")
	fi

	checksize(b, 4, 8)
!
	a.size:=(prefix=0xF3|4|8)

	genbyte(prefix)
	usesizeb:=1
	genrrm(0x0F'2A, a, b)
end

proc do_movxmm(mclopnd a,b,int size)=
!do movd/movq depending on size being 4 or 8
	int am, regcode, regcode1, regcode2

	case a.mode
	when a_reg then
		case b.mode
		when a_xreg then
			if a.size<>size then axerror("1:movdq size") fi
			b.size:=a.size

			sizeoverride:=1
			genrrm(0x0F'7E, b, a)

		else
			axerror("movdq reg,?")
		esac
	when a_xreg then
		case b.mode
		when a_reg then
			a.size:=b.size
			if b.size<>size then axerror("3:movdq size") fi
			sizeoverride:=1
			genrrm(0x0F'6E, a, b)

		when a_xreg then
			a.size:=b.size
			f3override:=1
			genrrm(0x0F'7E, a, b)

		when a_mem then
			if b.size=0 then b.size:=a.size fi
!			if b.size<>size then axerror("31:movdq size") fi
			if b.size<>size then axerror("31:movdq size") fi
!
			if size=4 then
				sizeoverride:=1
				nowmask:=1
				genrrm(0x0F'6E, a, b)

			else
				f3override:=1
				nowmask:=1
				genrrm(0x0F'7E, a, b)
			fi

		else
			axerror("movdq xreg,?")
		esac
	when a_mem then
		case b.mode
		when a_xreg then
			if a.size and a.size<>size then axerror("5:movdq size") fi

			sizeoverride:=1
			genrrm((size=4|0x0F'7E|0x0F'D6), b,a)

		else
			axerror("movdq mem,?")
		esac

	else
		axerror("movdq opnds")
	esac
end

proc fixrip(int dispsize)=
	ref byte codeaddr
	ref u32 offsetptr

	if not ripentry then return fi

	case dispsize
	when 0 then return
	when 1,2,4 then
	else
CPL =DISPSIZE
		axerror("fixrip disp?")
	esac
	ripentry.immsize:=dispsize
end

proc do_bswap(mclopnd a)=
	int code
	if a.mode<>a_reg or a.size<4 then axerror("bswap reg>") fi

	setopsize(a)

	code:=getregcode(a.reg, bmask)

	genrex()
	genbyte(0x0F)
	genbyte(0xC8 + code)
end

proc do_movdqx(mclopnd a, b, int prefix)=
	prefix:=prefix<<16 + 0x0F<<8

	if a.size=0 then a.size:=16 fi
	if b.size=0 then b.size:=16 fi

	if a.mode=a_mem then
		genrrm(prefix+0x7F, b, a)
	else
		genrrm(prefix+0x6F, a, b)
	fi
end

proc do_dshift(mclopnd a, b, int c, opc)=

	if a.size=0 then a.size:=b.size fi
	if a.size<>b.size or a.size<=1 then axerror("dshift/size") fi

	sizeoverride:=0
	genrrm(0x0F<<8+opc, b, a)
	genbyte(c)
end

=== mc_libmcl.m 0 0 40/108 ===
const fuseregtable=1
!const fuseregtable=0

global const targetsize=8

export const ctarget=0

!global int mclseqno
EXPORT int mclseqno
EXPORT int NMCLOPND

[-1..10]mclopnd smallinttable
[20]psymbol nametable
int nnametable

global macro isframex(d) = (d.id in [local_id, param_id])

global macro mcomm = mgencomment

export proc mclinit(int bypass=0)=
	mclopnd a
	int r,s

	if mclrec.bytes>64 then ABORTPROGRAM("MCLREC>64B") fi

	for r:=r0 to r15 do
		regtable[r,1]:=mgenreg0(r,1)
		regtable[r,2]:=mgenreg0(r,2)
		regtable[r,4]:=mgenreg0(r,4)
		regtable[r,8]:=mgenreg0(r,8)
	od

	for i in frameregtable.bounds do
		a:=newmclopnd()
		a.mode:=a_mem
		a.reg:=rframe
		a.size:=8
		a.offset:=i
		frameregtable[i]:=a
	end

	dframeopnd:=mgenreg(rframe, tpu64)
	dstackopnd:=mgenreg(rstack, tpu64)

	initmcdest()

	setsegment('C')

	lab_funcnametable:=0
	lab_funcaddrtable:=0

	for i in smallinttable.bounds do
		smallinttable[i]:=mgenint0(i,8)
	od

!bypass is used when directly using mcl api (eg. from an external assembler)
!then genmcl(), called from pcl functions, is a no-op
	if bypass then
		mcldone:=1
	fi
end

global proc initmcdest=
!reset mccode/mccodex
!called should have saved any values from last linked list 
	mccode:=mccodex:=nil
!	clear rtsproclabels
end

EXPORT proc genmc(int opcode, mclopnd a=nil,b=nil)=		!used in do_mcl/assem in host
	ref mclrec m, oldm
	int labno

	m:=pcm_allocnfz(mclrec.bytes)

	m.opcode:=opcode
	m.seqno:=++mclseqno
	m.mpos:=mmpos

	m.a:=a
	m.b:=b

	case opcode
	when m_lea then
		if b and b.valtype=def_val then
			b.def.addrof:=1
		fi
	when m_labelx then
		labno:=a.labelno

	when m_mov then				!change to movd/q if needed
		if a.mode=a_xreg or (b and b.mode=a_xreg) then
			m.opcode:=(a.size=8|m_movq|m_movd)
		fi
	esac

	if mccode then
		m.lastmcl:=mccodex
		mccodex.nextmcl:=m
		mccodex:=m
	else
		mccode:=mccodex:=m
	fi
end

export proc genmc_cond(int opcode, cond, mclopnd a=nil,b=nil)=
	genmc(opcode,a,b)
	mccodex.cond:=cond
end

global proc genmc_str(int opcode,ichar s)=
!as genmc but uses a single immediate string operand
	genmc(opcode,mgenstring(s))
end

func newmclopnd:mclopnd a=
!	a:=pcm_allocz(mclopndrec.bytes)
	a:=pcm_allocnfz(mclopndrec.bytes)

++NMCLOPND
	return a
end

global func duplopnd(mclopnd a)mclopnd=
	mclopnd b
!	b:=pcm_alloc(mclopndrec.bytes)
	b:=pcm_allocnfz(mclopndrec.bytes)
	b^:=a^
	return b
end

EXPORT func mgenindex(int areg=0,ireg=0,scale=1,offset=0,size=0, labno=0, psymbol def=nil)mclopnd=
!construct a mem address mode
	mclopnd a
	a:=newmclopnd()

	a.mode:=a_mem
	a.reg:=areg

	if areg=rframe or ireg=rframe then usedregs[rframe]:=1 fi

	a.regix:=ireg
	a.scale:=scale
	a.size:=size

	a.offset:=offset

	if labno then
		a.value:=labno
		a.valtype:=label_val
	elsif def then
		a.def:=def
		++def.nrefs
		a.valtype:=def_val
		if isframex(def) then
			a.reg:=rframe
			usedregs[rframe]:=1
		fi
	fi

	return a
end

global proc mgencomment(ichar s)=
!if not debugmode then return fi
!	if s=nil or s^=0 then
!		genmc(m_blank)
!	else
		genmc_str(m_comment,s)
!	fi
end

export func mgenstring(ichar s,int length=-1)mclopnd=
	mclopnd a
	a:=newmclopnd()
	a.mode:=a_imm
	if length<0 then
		length:=strlen(s)
	fi
	a.svalue:=pcm_alloc(length+1)
	memcpy(a.svalue,s,length)
	(a.svalue+length)^:=0

	a.valtype:=stringimm_val
	a.size:=8
	return a
end

global func mgenname(ichar s)mclopnd=
	[64]char str
	mclopnd a
	a:=newmclopnd()
	a.mode:=a_imm
	a.svalue:=pcm_copyheapstring(s)
	a.valtype:=name_val
	a.size:=8

	return a
end

global proc setsegment(int seg,align=1)=
!seg is 'D', 'Z', 'C', 'R' for data, zdata, code, rdata
	int opc,oldalign

	if seg<>currsegment then
		case seg
		when 'I' then opc:=m_isegment
		when 'Z' then opc:=m_zsegment
		when 'C' then opc:=m_csegment
		when 'R' then MERROR("CAN'T DO RODATA SEG")
		else
			MERROR("BAD SEG CODE")
		esac
		if mccodex and mccodex.opcode in [m_isegment,m_zsegment,m_csegment] then
			mccodex.opcode:=opc
		else
			genmc(opc)
		fi

		currsegment:=seg
	fi

	if align>1 then
		if mccodex.opcode=m_align then
			oldalign:=mccodex.a.value
			if oldalign>=align then return fi
		fi
		genmc(m_align,mgenint(align))
	fi
end

global func changeopndsize(mclopnd a,int size)mclopnd=
	mclopnd b

	if a.size<>size then
		if a.mode=a_reg then
			b:=regtable[a.reg, size]
		else
			b:=duplopnd(a)
			b.size:=size
		fi
		return b
	fi
	return a
end

global func applyoffset(mclopnd a,int offset,int size=0)mclopnd=
!astr is an asm operand
!add possible byte offset
	mclopnd b

	if offset=0 and size=0 then
		return a
	fi
	b:=duplopnd(a)
	b.offset+:=offset
	if size then
		b.size:=size
	fi

	return b
end

export func mgenint(i64 x,int mode=tpi64)mclopnd a=
	int size:=psize[mode]

	if x in -1..10 and size=8 then
		return smallinttable[x]
	fi

	a:=newmclopnd()
	a.mode:=a_imm

	a.value:=x
	a.valtype:=intimm_val
	a.size:=size

	return a
end

global func mgenint0(i64 x,int size=8)mclopnd a=
	a:=newmclopnd()
	a.mode:=a_imm

	a.value:=x
	a.valtype:=intimm_val
	a.size:=size

	return a
end

global func mgenrealmem(r64 x,int mode=tpr64)mclopnd a=
	a:=newmclopnd()
	a.mode:=a_mem
	if ispwide(mode) then
		a.value:=getrealindex(x)
	else
		a.value:=getr32index(x)
	fi
	a.valtype:=label_val
	a.size:=psize[mode]
	return a
end

export func mgenrealimm(r64 x,int mode=tpr64)mclopnd a=
	a:=newmclopnd()
	a.mode:=a_imm
	a.xvalue:=x
	a.valtype:=realimm_val
	a.size:=psize[mode]
	return a
end

EXPORT func mgenlabel(int x=0)mclopnd a=
!x is a label index
!generate immediate operand containing label
	a:=newmclopnd()
	a.mode:=a_imm

	if x=0 then x:=++mlabelno fi
	a.value:=x
	a.valtype:=label_val

	return a
end

global func mgenlabelmem(int x)mclopnd a=
!x is a label index
!generate immediate operand containing label

	a:=mgenlabel(x)
	a.mode:=a_mem
	return a
end

export func mgenmem(psymbol d, int mode=tpu64)mclopnd a=
	int reg

	if d.reg then
		if pfloat[d.mode] then
			return mgenxregvar(d)
		else
			return mgenregvar(d, mode)
		fi
	fi

	reg:=rnone
	if isframex(d) then
!		if not foptim and (int(d.offset) in -128..64) and ttsize[d.mode]=8 then
!			return frameregtable[d.offset]
!		fi

		reg:=rframe
		usedregs[rframe]:=1

	fi

	a:=newmclopnd()
	a.mode:=a_mem
	a.reg:=reg
	a.def:=d
	++d.nrefs
	a.valtype:=def_val

	if mode then
		a.size:=psize[mode]
	else
		a.size:=min(d.size,8)
	fi

	return a
end

EXPORT func mgenmemaddr(psymbol d)mclopnd=
	mclopnd a

	d.addrof:=1
	++d.nrefs

	a:=newmclopnd()
	a.mode:=a_imm

	a.def:=d
	++d.nrefs
	a.valtype:=def_val
	a.size:=8

	return a
end

global func mgenreg0(int reg,size=8)mclopnd a=
	a:=newmclopnd()
	a.mode:=a_reg
	a.reg:=reg
	a.size:=size

IF SIZE=0 THEN MERROR("1:SIZE=0") FI
	return a
end

EXPORT func mgenxreg(int xreg, size=8)mclopnd=
	mclopnd a

!	if xreg=rnone then xreg:=++currxregno fi
	a:=newmclopnd()

	a.mode:=a_xreg
	a.reg:=xreg
	a.size:=size
IF SIZE=0 THEN MERROR("2:SIZE=0") FI
	return a
end

EXPORT func mgenreg(int reg, mode=tpi64)mclopnd a =
!EXPORT func mgenreg(int reg, mode)mclopnd a =
	int size:=psize[mode]

	if ispfloat(mode) then
		a:=newmclopnd()
		a.mode:=a_xreg
		a.reg:=reg
		usedxregs[reg]:=1
		a.size:=psize[mode]
		a
	else
		if size=0 then size:=8 fi
		usedregs[reg]:=1

IF REG IN R10..R13 THEN REGSET[REG]:=1 FI

		if fuseregtable then
			return regtable[reg,size]
		fi
		return mgenreg0(reg,size)
	fi
end

global func mgenregi(int reg, mode=tpi64)mclopnd a =
	if fuseregtable then
		return regtable[reg, psize[mode]]
	fi
	return mgenreg0(reg, psize[mode])
end

global func mgenireg(int reg, mode=tpi64, offset=0)mclopnd=
	mclopnd a

	a:=newmclopnd()
	a.mode:=a_mem
	a.reg:=reg
	a.size:=psize[mode]
	a.offset:=offset

	return a
end

global func mgentemp(int n, mode)mclopnd a=
!pcl temps are used to spill pcl operands from a register
!they will always be 64 bits

	int reg, size

	if pcltempflags[n] then			!already in use
		return changeopndsize(pcltempopnds[n], psize[mode])
	fi

	a:=newmclopnd()
	a.mode:=a_mem
	a.reg:=rframe
	usedregs[rframe]:=1
	a.valtype:=temp_val
	a.size:=psize[mode]
	a.tempno:=n

	pcltempopnds[n]:=a
	pcltempflags[n]:=1

	return a
end

global func roundsizetg(int size)int=
!make sure size is round up to next multiple of targetsize (4 or 8)
	if size iand 7=0 then return size fi
	return size+(8-(size iand 7))
end

global proc merroropnd(ichar mess,int opndtype)=
	fprintln "MCL Opnd not supported: # (#) [#]",mess,opndnames[opndtype]
	PRINTLN
	STOP 1
!	stopcompiler(sourcefilepaths[mmpos>>24],mmpos iand 16777215)
end

global func mcreatefwdlabel:int =
	return ++mlabelno
end

global proc mdefinefwdlabel(int lab) =
	genmc(m_labelx,mgenlabel(lab))
end

global func mgenextname(ichar s)mclopnd=
	[64]char str
	psymbol d
	static [20]psymbol table
	static int ntable

	strcpy(str,s)
	str[strlen(s)]:=0			!lose final *

	d:=findnamesym(str)

	if not d then
		d:=pcm_allocnfz(pstrec.bytes)

		d.name:=pcm_copyheapstring(str)
		d.id:=import_id
		d.imported:=1
		addnamesym(d)
	fi

	return mgenmemaddr(d)
end

global func mgenregvar(psymbol d, int mode)mclopnd a=
	a:=mgenreg(d.reg, mode)
!	isregvar[d.reg]:=1

	return a
end

global func mgenxregvar(psymbol d)mclopnd a=
	a:=mgenxreg(d.reg)
	isxregvar[d.reg]:=1

	return a
end

global func getprimreg(mclopnd ax)int =
!get primary reg value; only one should be active
!return 0 if no regs
!//error if both regs are active

	if ax.reg then
!		if ax.regix then merror("getprim?") fi
		ax.reg
	else
		ax.regix	!0 if no regs used
	fi
end

global proc pushslots(int nslots)=
	pushstack(nslots*8)
	mstackdepth+:=nslots
end

global proc popslots(int nslots)=
	popstack(nslots*8)
	mstackdepth-:=nslots
end

global proc pushstack(int n)=
	if n then
		genmc(m_sub,dstackopnd,mgenint(n))
	fi
end

global proc popstack(int n)=
	if n then
		genmc(m_add,dstackopnd,mgenint(n))
	fi
end

global func getstringindex(ichar s, int length)int=
	if s=nil then			!assume nil
		kk0used:=++mlabelno
		return kk0used
	fi

	if cstringlist and length=cstringlist.slength and eqbytes(cstringlist.svalue, s, length) then
		return cstringlist.labelno
	fi

	return addconst(cstringlist, cast(s), length)
end

global func addconst(ref constrec &clist, int value=0, length=0)int=
	ref constrec p
	p:=pcm_allocnfz(constrec.bytes)
	p.value:=value
	p.slength:=length
	p.labelno:=++mlabelno
	p.nextconst:=clist
	clist:=p
	return mlabelno
end

global func getrealindex(real x)int=
	return addconst(creallist,cast@(x,int))
end

global func getr32index(real x)int=
	return addconst(cr32list,cast@(x,int))
end

!global func ispoweroftwo(i64 x)int=
EXPORT func ispoweroftwo(i64 x)int=
!when x is a power of two, and is at least 2, then return the power (ie. equiv number of shifts)
!otherwise return zero when x is negative, 0, 1, not a power of two, or more than 2**31
	i64 a
	int n

	a:=1
	n:=0
	to 60 do
		++n
		a:=a<<1
		if a=x then
			return n
		fi
	od
	return 0
end

global proc axerror(ichar mess)=
	int lineno
	ichar filename, sourceline

	CPL "AX ERROR:", mess, "AASEQ:", aaseqno, =aapos
!!	CPL "AX ERROR:", mess, "Line:", aapos, aapos.[24..31], aapos.[0..23]
!	CPL "AX ERROR:", mess, "File:", sources[aapos.[24..31]].filename, getlineno(aapos)
!	CPL
!	STOP 1
!

	if igetmsourceinfo then
		lineno:=igetmsourceinfo(mmpos, filename, sourceline)
		CPL =LINENO
		CPL =FILENAME
!	else
!		lineno:=0
	fi

	STOP 1

end

global func newblocktemp(int size)psymbol=
	[16]char str
	psymbol d

	if nblocktemps>maxblocktemps then
		merror("Too many block temps")
	fi
	++nblocktemps

	fprint @str,"$B#",nblocktemps
	d:=pc_makesymbol(str, misc_id)
	d.mode:=tpblock
	d.size:=size
	d.used:=1
	d.id:=local_id
	d.nextlocal:=currfunc.nextlocal
 	d.owner:=currfunc
	currfunc.nextlocal:=d

	blockdefs[nblocktemps]:=d
	d
end

global func findnamesym(ichar s)psymbol d=
!search for s in cache of named symbols

	for i to nnametable do
		if eqstring(s, nametable[i].name) then
			return nametable[i]
		fi
	od
	nil
end

global proc addnamesym(psymbol d)=
!add new name symbol, which should be unique

	if nnametable<nametable.len then
		nametable[++nnametable]:=d
	else
		merror("Ext nametab overflow")
	fi
end

global proc clearreg(mclopnd ax)=
	if ax.size=8 then
		ax:=changeopndsize(ax,4)
	fi
	genmc(m_xorx, ax, ax)
end

!func mgenstrdir(ichar s)mclopnd=
!!generate string directly, not from pcl, by allocating it in string table
!!and a returning a label operand
!
!	mgenlabelmem(getstringindex(s, strlen(s)))
!end
!
!global proc enterproc(ichar name)=
!RETURN
!	if eqstring(name,"$enterproc") or eqstring(name,"$callproc") or eqstring(name, "$leaveproc") then
!		return
!	fi
!!CPL "1:DOING", NAME
!	genmc(m_sub, mgenreg(rstack,8), mgenint(32))
!	genmc(m_mov, mgenreg(r10,8), mgenstrdir(name))
!	genmc(m_call, mgenname("$enterproc"))
!	genmc(m_add, mgenreg(rstack,8), mgenint(32))
!end
!
!global proc callproc(ichar cpname, name)=
!RETURN
!	if eqstring(cpname,"$enterproc") or eqstring(cpname,"$callproc") or eqstring(cpname, "$leaveproc") then
!!CPL "21:SKIP",CPNAME, NAME
!		return
!	fi
!	if eqstring(name,"$enterproc") or eqstring(name,"$callproc") or eqstring(name, "$leaveproc") then
!!CPL "22:SKIP",CPNAME, NAME
!		return
!	fi
!!CPL "2:DOING", NAME
!
!	genmc(m_sub, mgenreg(rstack,8), mgenint(32))
!	genmc(m_mov, mgenreg(r10,8), mgenstrdir(cpname))
!	genmc(m_mov, mgenreg(r11,8), mgenstrdir(name))
!	genmc(m_mov, mgenreg(r12,8), mgenint(lineno))
!	genmc(m_call, mgenname("$callproc"))
!	genmc(m_add, mgenreg(rstack,8), mgenint(32))
!end
!
!global proc leaveproc(ichar name)=
!RETURN
!	if eqstring(name,"$enterproc") or eqstring(name,"$callproc") or eqstring(name, "$leaveproc") then
!		return
!	fi
!!CPL "3:DOING", NAME
!	genmc(m_sub, mgenreg(rstack,8), mgenint(32))
!	genmc(m_mov, mgenreg(r10,8), mgenstrdir(name))
!	genmc(m_mov, mgenreg(r11,8), mgenint(lineno))
!	genmc(m_call, mgenname("$leaveproc"))
!	genmc(m_add, mgenreg(rstack,8), mgenint(32))
!end
!
!
=== mc_objdecls.m 0 0 41/108 ===
global record imagefileheader =
	u16	machine
	u16	nsections
	u32	timedatestamp
	u32	symtaboffset
	u32	nsymbols
	u16	optheadersize
	u16	characteristics
end

global record imagedir =
	u32	virtualaddr
	u32	size
end

global record optionalheader =			!exe/dll only
	u16  magic
	byte     majorlv
	byte     minorlv
	u32 codesize
	u32 idatasize
	u32 zdatasize
	u32 entrypoint
	u32 codebase
!	u32 datebase		!32-bit exe files only
	u64	imagebase
	u32 sectionalignment
	u32 filealignment
	u16  majorosv
	u16  minorosv
	u16  majorimagev
	u16  minorimagev
	u16  majorssv
	u16  minorssv
	u32 win32version
	u32 imagesize
	u32 headerssize
	u32 checksum
	u16  subsystem
	u16  dllcharacteristics
	u64   stackreserve
	u64   stackcommit
	u64   heapreserve
	u64   heapcommit
	u32 loaderflags
	u32 rvadims
	imagedir exporttable
	imagedir importtable
	imagedir resourcetable
	imagedir exceptiontable
	imagedir certtable
	imagedir basereloctable
	imagedir debug
	imagedir architecture
	imagedir globalptr
	imagedir tlstable
	imagedir loadconfigtable
	imagedir boundimport
	imagedir iat
	imagedir delayimportdescr
	imagedir clrheader
	imagedir reserved
end

global record imagesectionheader =
	[8]char name
	union
		u32	physical_address
		u32	virtual_size
	end
	u32	virtual_address
	u32	rawdata_size
	u32	rawdata_offset
	u32	relocations_ptr
	u32	linenos_offset
	u16	nrelocs
	u16	nlinenos
	u32	characteristics
end

global record imagesymbol =
	union
		[8]char shortname
		struct
			u32	shortx
			u32	longx
		end
		u64 longname
	end
	u32	value
	i16	sectionno
	u16	symtype
	byte	storageclass
	byte	nauxsymbols
end

global record importdirrec =
	u32	implookuprva
	u32	timedatestamp
	u32	fwdchain
	u32	namerva
	u32	impaddressrva
end

global record coffrelocrec =
	i32	virtualaddr
	i32	stindex
	i16	reloctype
end

global enumdata [0:]ichar relocnames =
	(abs_rel = 0,	$),
	(addr64_rel,	$),
	(addr32_rel,	$),
	(addr32nb_rel,	$),
	(rel32_rel,		$),
	(rel321_rel,	$),
	(rel8_rel,		$),				!used within assembler only, not in coff format
end

global record auxsectionrec = 
	i32 length
	i16 nrelocs
	i16 nlines
	i32 checksum
	i16 sectionno
	i32 dummy
end

global record sectionrec =
	union
		ref dbuffer data		!copy of ss_zdata etc
		ref byte bytedata		!added later, eg, import dir block
	end
	ichar name					!name like ".bss" as it will be in obj/exe file
	int segtype					!code_seg etc
	int rawsize					!in file
	int rawoffset				!offset in exe file
	int virtsize				!in image
	int virtoffset				!offset from imagebase
	ref relocrec relocs			!for idata/code: reloc info needs to be processed
	int nrelocs					!
end

global record importrec = 				!details about all imported symbols
	psymbol def				!full st entry
	int libno					!which dll lib this belongs to
	ichar name					!name of symbol (extracted from lib.name if needed)
	int hintnameoffset			!voffset of hint/name entry in impdir section
	int iatoffset				!voffset of IAT entry
	int thunkoffset				!offset within code section of thunk entry
end

global record exportrec = 		!details about all exported symbols
	psymbol def				!full st entry
	ichar name					!name of symbol (extracted from lib.name if needed)
end

global record dllrec =					!all imported libraries
	ichar name					!name of library, including .dll
	int nprocs					!no. of imports which use this library
	int nametableoffset			!start of name table in impdir
	int addrtableoffset			!start of addr table (IAT)
	int dllnameoffset			!offset of name within impdir
	int dllextraoffset			!offset of mysterious region just before the name
end

global record exportdirrec =
	u32 exportflags
	u32 timedatestamp
	u16 majorversion
	u16 minorversion
	u32 namerva
	u32 ordinalbase
	u32 naddrtable
	u32 nnamepointers
	u32 expaddressrva
	u32 namepointerrva
	u32 ordtablerva
end
=== mc_optim.m 0 0 42/108 ===
global proc peephole=
	ref mclrec m, m2,m3
	int lab1,lab2

	if not fpeephole then return fi
!CPL "PEEP"

	m:=mccode.nextmcl

	while m, m:=m.nextmcl do 
		m2:=m.nextmcl
		m3:=m2.nextmcl

		case m.opcode
		when m_endx then
			exit

		when m_mov then
			case m2.opcode
			when m_mov then					!mov/mov
				if isreg0(m.a) and m.a=m2.b and endr0(m2) then		!mov r0,x/mov x,r0
					if isreg10(m2.a) then
					elsif isreg(m2.a) or isreg(m.b) then				!one x is a reg
						m.a:=m2.a
						deletemcl(m2)
					fi
				elsif isreg0(m.a) and m.a=m2.b and isreg10(m2.a) and m3.opcode=m_call and
						endr0(m3) then
					m.a:=m2.a
					deletemcl(m2)
				fi
			when m_test then				!mov/test
				if isreg0(m.a) and m.a=m2.a=m2.b and isreg(m.b) and endr0(m3) then		!mov r0,x/test r0,r0
					m.opcode:=m_test
					m.a:=m.b
					m:=deletemcl(m2)
				fi
			when m_cmp then					!mov r0, reg/cmp r0,x
				if isreg0(m.a) and m.a=m2.a and isreg(m.b) and endr0(m3) then
					m.opcode:=m_cmp
					m.a:=m.b
					m.b:=m2.b
					deletemcl(m2)
				fi
			when m_add, m_sub then
				if isreg(m.a) and m.a=m2.a and isreg(m.b) and isconst(m2.b) then
					m.opcode:=m_lea
					m.b:=mgenindex(areg:m.b.reg, offset: (m2.opcode=m_add|m2.b.value|-m2.b.value))
					deletemcl(m2)
				fi
			when m_inc, m_dec then
				if isreg(m.a) and m.a=m2.a and isreg(m.b) then
					m.opcode:=m_lea
					m.b:=mgenindex(areg:m.b.reg, offset: (m2.opcode=m_inc|1|-1))
					deletemcl(m2)
				fi
			when m_jmp then
				if isreg0(m.a) and isreg0(m2.a) then
					m.opcode:=m_jmp
					m.a:=m.b
					m.b:=nil
					deletemcl(m2)
				fi
			esac

		when m_andx then
			if m2.opcode=m_test then				!and r0../test r0,r0 -> and r0.. only
				if isreg0(m.a) and m.a=m2.a=m2.b and endr0(m3) then
					m:=deletemcl(m2)
				fi
			fi
		when m_xorx then
			if m2.opcode=m_mov then					!xor r0,r0; mov reg, r0
				if isreg0(m.a) and m.a=m.b and isreg(m2.a) and isreg0(m2.b) and endr0(m2) then
					m.a:=m.b:=m2.a
					m:=deletemcl(m2)
				fi
			fi

		when m_jmpcc then
			if m2.opcode=m_jmp and m3.opcode=m_labelx and m.a.labelno=m3.a.labelno and endr0(m) then
				m.cond:=asmrevcond[m.cond]
				m.a:=m2.a
				m:=deletemcl(m2)

			fi

!		when m_add then
!			if m2.opcode in [m_add, m_sub] then
!				if isreg(m.a) and m.a=m2.a and isreg(m.b) and isconst(m2.b) then
!STATIC INT AA
!!					m.opcode:=m_lea
!!					m.b:=mgenindex(areg:m.b.reg, offset: (m2.opcode=m_add|m2.b.value|-m2.b.value))
!!					deletemcl(m2)
!CPL "ADD/ADD/SUB NN",++AA
!				fi
!			fi
!
!!!		when m_jmp then			!this uses more bytes than it saves, when self-hosting
!!!			if m.a.mode=a_imm and m2.opcode=m_labelx and m.a.labelno=m2.a.labelno then
!!!				m:=deletemcl(m)
!!			FI

		esac
	od

end

func isreg(mclopnd a)int=
	return a.mode=a_reg
end

func isreg0(mclopnd a)int=
	if not a then return 0 fi
	if a.mode=a_reg and a.reg=r0 then return 1 fi
	return 0
end

func isreg10(mclopnd a)int=
	if not a then return 0 fi
	if a.mode=a_reg and a.reg=r10 then return 1 fi
	return 0
end

func isreg00(ref mclrec m)int=
	if isreg(m.a) and m.a=m.b then return 1 fi
	0
end

func isconst(mclopnd a)int=
	if not a then return 0 fi
	if a.mode=a_imm and a.valtype=intimm_val then
		return 1
	fi
	return 0
end

func sameoperand(mclopnd a,b)int=
	return memcmp(a,b,mclopndrec.bytes)=0
end

func sameregopnd(mclopnd a,b)int=
!check if same register operand
	unless a.mode=b.mode=a_reg then return 0 end
	return a.reg=b.reg
end

!func deletemcl(ref mclrec p, ichar comment=nil)ref mclrec =
func deletemcl(ref mclrec p)ref mclrec =
!delete p; return following instr
	ref mclrec a,b

	a:=p.lastmcl
	b:=p.nextmcl
	if a=nil or b=nil then merror("delmcl?") fi

!	if comment then
!		p.opcode:=m_comment
!		p.a:=mgenstring(pcm_copyheapstring(comment))
!	else
		a.nextmcl:=b
		b.lastmcl:=a
!	fi

	b
end

func endr0(ref mclrec m)int=
	return m.regfreed[r0]
end
=== mc_stackmcl.m 0 0 43/108 ===
!'PCS' Support - PCL Operand Stack 

global func getopnd(int n, mode, reg=rnone)mclopnd ax =
!get access mode for operand n
	mclopnd bx
	pcl a
	psymbol d

	a:=pclopnd[n]

	case pclloc[n]
!	when reg_loc then
	when reg_loc, regvar_loc then
		return mgenreg(pclreg[n], mode)

	when temp_loc then
		bx:=mgentemp(n, mode)
		return bx
	esac

	case a.opndtype
	when mem_opnd then
		d:=a.def
		if mode=tpblock and d.id<>param_id then
			mode:=tpu64
			recase memaddr_opnd
		else
			ax:=mgenmem(a.def, mode)
		fi

	when memaddr_opnd then
		d:=a.def
		if d.id=param_id and d.mode=tpblock then		!pcl mode will be u64
			ax:=mgenmem(a.def, mode)
		else
			ax:=getworkreg_rm(reg, mode)
			genmc(m_lea, ax, mgenmem(a.def, mode))
		fi

	when int_opnd then
		CASE PSIZE[MODE]
		WHEN 2 THEN
			A.VALUE IAND:=0xFFFF
		WHEN 4 THEN
			A.VALUE IAND:=0xFFFF'FFFF
		ESAC

		bx:=mgenint(a.value, mode)
		if a.value in i32.bounds then			!keep as immediate
			ax:=bx
		else
			ax:=getworkreg_rm(reg, mode)
			genmc(m_mov, ax, bx)
		fi

	when real_opnd, r32_opnd then
		ax:=mgenrealmem(a.xvalue, mode)

	when string_opnd then
		ax:=getworkreg_rm(reg, mode)

		genmc(m_lea, ax, mgenlabelmem(getstringindex(a.svalue, a.slength)))

	when label_opnd then
		ax:=getworkreg_rm(reg, mode)

		genmc(m_lea, ax, mgenlabelmem(a.labelno))

	else
error:
		merror("getopnd", opndnames[a.opndtype])
	esac

	ax
end

global func loadopnd(int n, mode, reg = rnone)mclopnd ax =
!Load operand to designated register reg. If not provided, one is allocated
!If operand resides in a register already, and reg=0, then that is what is
!returned. But if it will be modified, either REG is needed, or an alternate
!scheme is needed to force a load to a different register

	ax:=getopnd(n, mode, reg)

	if pclloc[n]=regvar_loc then			!force a load to a workreg
		if reg=rnone then
			reg:=getworkreg(mode)
		fi
	fi

	ax:=loadtoreg(ax, mode, reg)

	pclopnd[n]:=nil
	pclloc[n]:=reg_loc
	pclreg[n]:=ax.reg

	ax
end

global func loadparam(int n, mode, reg)mclopnd ax =
!Load operand to designated arg reg.
!If operand resides in a register already, and reg=0, then that is what is
!returned. But if it will be modified, either REG is needed, or an alternate
!scheme is needed to force a load to a different register
	ax:=getopnd(n, mode, reg)
	ax:=loadtoreg_m(ax, mode, reg)
	ax
end

!global func loadretval(int n, mode, reg)mclopnd ax =
!!Load operand to return register
!!reg will be r0 for most functions
!	ax:=getopnd(n, mode, reg)
!	ax:=loadtoreg_m(ax, mode, reg)
!	ax
!end

global proc pushopnd(int n, mode, size)=
!Push a to hardware stack then pop it from pcl stack
!The hardware stack is popped on return from a call

	mclopnd ax, bx
	pcl p:=pclopnd[n]			!in case it is mem/int etc


!	if mode=tpvoid then mode:=pclmode[n] fi

!CPL "PUSHOPND", STRPMODE(MODE), SIZE

!First look for operands that can be directly pushed without using a register

	if pclloc[n]=pcl_loc then	!p refers to operand
		case p.opndtype
		when mem_opnd then
			if size=8 then
				ax:=mgenmem(p.def, pmode)
				pushit
			fi
		when int_opnd then
			if p.value in i32.bounds then		!fits in d32 offset
				ax:=mgenint(p.value, tpi64)
				pushit
			fi

		when real_opnd then
			ax:=mgenrealmem(p.xvalue, tpr64)
			pushit

		esac

	fi

!need to go via register

	ax:=loadopnd(n, mode)

	if mode=tpblock then
!CPL "HIGH: COPYBLOCK ARG"
		copyblockarg(ax, size, n)
		mode:=tpu64				!push the pointer
	fi


	if ax.mode=a_xreg then			!float register
		bx:=ax
		ax:=getworkregm((mode=4|tpu32|tpu64))
		genmc(m_mov, ax, bx)

	fi

pushit:
	genmc(m_push, changeopndsize(ax,8))

	poppcl()
	++mstackdepth

end

global func loadtoreg(mclopnd ax, int mode, reg)mclopnd=
!if ax is not a register operand, then load it to given register
!mode is needed to give type of register (float etc) and size
!It is assumed that if ax /is/ in a register, that it is the correct one, or doesn't matter
	mclopnd bx

	if ax.mode in [a_reg, a_xreg] then			!might already be in reg
		if not reg or ax.reg=reg then
			return ax
		fi
	fi

	bx:=getworkreg_rm(reg, mode)

	loadtoreg_common(bx, ax)

	bx
end

global func loadtoreg_m(mclopnd ax, int mode, reg)mclopnd=
!same as loadtoreg but if already in a register, will move it to required one if needed
	mclopnd bx

	if ax.mode in [a_reg, a_xreg] then			!already in register
		if ax.reg=reg then return ax fi			!in correct one
	fi

!need loading/moving to given reg
	bx:=mgenreg(reg, mode)

	loadtoreg_common(bx, ax)
!	genmc(m_mov, bx, ax)
	bx
end

proc loadtoreg_common(mclopnd bx, ax)=
	if ax.mode=a_imm and ax.valtype=intimm_val and ax.value=0 then
		bx:=changeopndsize(bx,4)
		clearreg(bx)
!		genmc(m_xorx, bx, bx)
	
	else
		genmc(m_mov, bx, ax)
	fi

end

global proc pushpcl(pcl p)=
!Push a inline operand from pcl code to pcs
	int n

	if noperands>=maxoperands then
		merror("PCL stack overflow")
	fi

	n:=++noperands

	pclloc[n]:=pcl_loc

	pclopnd[n]:=p
	pclreg[n]:=0
	pclcount[n]:=1
	pclmode[n]:=p.mode

	if p.opndtype=mem_opnd and p.def.reg then
		pclreg[n]:=p.def.reg
		pclloc[n]:=regvar_loc
	fi

end

global proc pushpcl_reg(int mode, reg=rnone)=
!Push a new, empty pcs slot located in given register
	int n

	if noperands>=maxoperands then
		merror("PCL stack overflow")
	fi

	if reg=rnone then reg:=getworkreg(mode) fi

	n:=++noperands

	pclloc[n]:=reg_loc
	pclopnd[n]:=nil
	pclreg[n]:=reg
	pclcount[n]:=1
	pclmode[n]:=mode

	if ispfloat(mode) then
		xregset[reg]:=1
	else
		regset[reg]:=1
	fi

end

global proc poppcl=
	int n:=noperands

	if n<=0 then merror("poppcl/underflow") fi

	if pclcount[n]>1 then
		--pclcount[n]
		return
	fi

	--noperands
end

global proc duplpcl=
!ensure zz is in a register, duplicate into a new register
	int mode:=pclmode[zz]

	loadopnd(zz, mode)							!get zz to reg
!	pushpcl_reg(getworkreg(mode), mode)				!create new zz opnd, old is now yy
	pushpcl_reg(mode)							!create new zz opnd, old is now yy

!MCOMM("DUPLOP")
	genmc(m_mov, getopnd(zz, mode), getopnd(yy, mode))	!copy old to new
end

global func getworkireg:int r=

	to 10 do
		for r in r0..r13 do
			if workregs[r] and regset[r]=0 then
				regset[r]:=1
				return r
			fi
		od
!CPL "GWI"
!FOR R:=R0 TO R13 DO
!	CP REGSET[R],$
!OD
!CPL
!FOR R:=R0 TO R13 DO
!	CP WORKREGS[R],$
!OD
!CPL
		savenextopnd()
	od
	merror("No more work regs")
	0
end

global func getworkxreg:int=
	for r in r4..r15 do
		if workxregs[r] and xregset[r]=0 then
			xregset[r]:=1
			return r
		fi
	od
	merror("No more work xregs")
	0
end

global func getworkregm(int mode)mclopnd=
!return mcl opnd for a work reg
	return mgenreg(getworkreg(mode), mode)
end

global func getworkreg(int mode)int reg=
!return new work reg depending on mode
	if ispfloat(mode) then
		getworkxreg()
	else
		getworkireg()
	fi
end

global func getworkreg_rm(int reg, mode)mclopnd=
!return an mcl operand for a specific reg if provided, or
!it will allocate a work reg is not (ie. reg=rnone)

	if reg in [rnone, rframe] then
		return getworkregm(mode)
	fi

	if ispint(mode) and isregvar[reg] or isxregvar[reg] then
		return getworkregm(mode)
	fi

	mgenreg(reg, mode)
end

!global proc freeireg(int reg)=
!	regset[reg]:=0
!end

!global proc freexreg(int reg)=
!	xregset[reg]:=0
!end

!global proc freereg(int reg, mode)=
!	if ispfloat(mode) then
!		xregset[reg]:=0
!	else
!		regset[reg]:=0
!	fi
!end
!
global proc saveopnd(int n, allregs=1)=
!if operand is in a volatile register, then save it in a temp
!allregs=1 to save both A and B regs (vol/nonval), which can include P regs if
!used as workregs; this is to save pne reg=opnd to a temp to free up a register
!allregs=0 to limit to A regs (possibly some P regs) only; normall for CALLs
!in order to preserve non-vol regs, as call will preserve the rest

!NOTE: operands that are unlikely to be unchanged from their value in
!pclrec, could be revert to pcl_loc. Eg. immediates, addresses, or any
!variable that is immutable

	int reg, mode
	mclopnd tx

	return unless pclloc[n]=reg_loc

	reg:=pclreg[n]
	mode:=pclmode[n]

	if ispint(mode) then
		if allregs or reg not in r3..r9 then
			genmc(m_mov, mgentemp(n,mode), mgenreg(reg,mode))
		fi
		regset[reg]:=0

	else
		if allregs or reg in r0..r5 then
			genmc(m_mov, mgentemp(n, mode), mgenxreg(reg, mode))
		fi
		xregset[reg]:=0
	fi

	pclloc[n]:=temp_loc
	pclreg[n]:=0

end
!
global proc saveopnds(int n=0)=
!save all operands other than top n
!assume this is to do with calls
	for i:=1 to noperands-n do
		saveopnd(i,0)
	od
end

global proc savenextopnd=


!starting from the first loaded, look for and save first reg-based opnd
!this does A/B/P regs if used
	for i:=1 to noperands do
		if pclloc[i]=reg_loc and ispint(pclmode[i]) then
			saveopnd(i,1)
			return
		fi
	od
end

global proc savenextxopnd=
!as savenextopnd but only does AX/BX/PX regs 
	for i:=1 to noperands do
		if pclloc[i]=reg_loc and ispfloat(pclmode[i]) then
			saveopnd(i,1)
			return
		fi
	od
end

global proc movetoreg(int newreg)=
!move top of stack (assumed to be in reg) to newreg
!assumes integer reg
	int oldreg
	int mode:=pclmode[zz]

	loadopnd(zz, mode)

retry:

	oldreg:=pclreg[zz]

	if oldreg=newreg then
		return
	fi

	if ispfloat(mode) then
		if xregset[newreg] then
			MERROR("MOVE TO REG: XREG IN USE")
		fi
	else
		if regset[newreg] then
			for i to noperands do
				if ispint(mode) and pclreg[i]=newreg then
					swapopnds(i,zz)
					genmc(m_xchg, mgenreg(oldreg, tpu64), mgenreg(newreg,tpu64))
					retry
				fi
			od
		fi
	fi

	genmc(m_mov, mgenreg(newreg,mode), mgenreg(oldreg,mode))

	pclreg[zz]:=newreg

	if ispfloat(mode) then
		xregset[newreg]:=1
!		if newreg>=xr3 then highxreg max:=newreg fi
	else
		regset[newreg]:=1
!		if newreg>=r10 then highreg max:=newreg fi
	fi
end

global func getopnd_ind(int n=noperands, mode=tpi64)mclopnd=
!Get access mode to operand which is to be used as a pointer elsewhere
!So it needs first to in a register, if not already
	pcl a
	psymbol d

	if pclloc[n]=pcl_loc then
!CPL "GETOPI"
		a:=pclopnd[n]
		if a.opndtype=memaddr_opnd then
			d:=a.def
!CPL "GETOPI2", D.NAME
			unless d.id=param_id and d.mode=tpblock then
!CPL "GETOPI3", D.NAME
				return mgenmem(a.def, mode)
			end
		fi
	fi

	if pclloc[n]<>reg_loc then
		loadopnd(n, tpu64)
	fi

	return mgenireg(pclreg[n], mode)
end

global func getopnd_ind_simp(int n=noperands, mode=tpi64)mclopnd=
!version of getopnd_ind which always returns [reg]

	if pclloc[n]<>reg_loc then
		loadopnd(n, tpu64)
	fi

	return mgenireg(pclreg[n], mode)
end

global proc swapopnds(int m,n)=
!exchange pcl stack operands
	swap(pclopnd[m],	pclopnd[n])
	swap(pclloc[m],		pclloc[n])
	swap(pclreg[m],		pclreg[n])
	swap(pclmode[m],	pclmode[n])
	swap(pclcount[m],	pclcount[n])
end

global func isimmload(int n)pcl p=
!return nil if operand is not immediate integer
!otherwise return the pcl operand

	p:=pclopnd[n]
	if pclloc[n]=pcl_loc and p.opcode=kload and p.opndtype=int_opnd then p else nil fi
end

global proc setnewzz(int reg, mode)=
!some value has been into into given register
!create replace pcl[zz] with that new operand
!assume pclcount was 1 and stays at 1

	pclloc[zz]:=reg_loc
	pclopnd[zz]:=nil
	pclreg[zz]:=reg
	pclmode[zz]:=mode

end

global proc freeworkregs(pcl p)=
	int reg

!Clear everything first

!(Code is a copy of that used inline in convertpcl)
	clear regset
	clear xregset

!Then set the regs still in use as pcl opnds:

	for i to noperands do
		reg:=pclreg[i]
		if pclreg[i] then
			if ispfloat(pclmode[i]) then
				xregset[reg]:=1
			else
				regset[reg]:=1
			fi
		fi
	od

end

global proc swapopndregs(int reg2)=
!top operand is in a register. Need to switch its reg with whatever is occupying
!reg2
!Note that swapondregs is best assumed to invalidate all existing mclopnds that
!refer to registers, as stuff if moved aound
!Also invalided are workregs that might use reg2, even if no mclopnd exists for it

	if not ispint(pclmode[zz]) then merror("SOR1") fi

!assume int regs

	int reg1:=pclreg[zz]

	if reg1=reg2 then return fi

	for i:=noperands-1 downto 1 do
		if pclloc[i]=reg_loc and pclreg[i]=reg2 then
			swap(pclreg[zz], pclreg[i])
			return
		fi
	else
!pcl op not found that occupies reg2, so it is assumed to be a work register
!that is no longer needed. If it /is/ needed

		regset[reg1]:=0				!make available (although done for next pcl op anyway)
		pclreg[zz]:=reg2
!		merror("swapopndregs/reg not found")
	od
end

global func makeopndind(mclopnd a, int mode=tpvoid)mclopnd=
	mclopnd b

	if a.mode<>a_reg then
		merror("makeopndind")
	fi

	return mgenireg(a.reg, mode)
end

global func makesimpleaddr(mclopnd ax)mclopnd bx=
!assume ax is an ireg, but need a simple one with areg set but not ireg
	int newreg, reg, regix

	reg:=ax.reg
	regix:=ax.regix
	if reg=rframe then reg:=rnone fi

	if ax.mode<>a_mem then merror("MSA") fi

	if reg=rnone and regix=rnone then
		newreg:=getworkireg()
	elsif reg then				![reg] only; already simple
		return ax
	elsif regix then			![regix] only; may be scaled; use lea anyway
		newreg:=regix
	else						![reg+regix]
		newreg:=regix
	fi

	bx:=mgenireg(newreg)

	genmc(m_lea, mgenreg(newreg), ax)
	return bx
end

global proc checkallloaded=
	for i to noperands do

!		if pclopnd[i].opndtype=mem_opnd and pclloc[i] in [pcl_loc, regvar_loc] then
!			loadopnd(i, pclopnd[i].mode)
!		fi

		if pclloc[i]=pcl_loc and pclopnd[i].opndtype=mem_opnd then
			loadopnd(i, pclopnd[i].mode)
		fi
	od
end

global func stropndstack(int indent=0)ichar=
	static [512]char str
	[512]char str2
	ichar s:=str, t

	if indent then
		fprint @s, "="*40 + "#:(", NOPERANDS
!		fprint @s, "="*20 + "#:(", NOPERANDS
	else
		fprint @s, "#:(", NOPERANDS
	fi

	for i to noperands do

		strcat(s, (noperands-i+1|"Z:", "Y:", "X:", "W:"|""))

		case pclloc[i]
		when reg_loc, regvar_loc then				!loaded
			if ispfloat(pclmode[i]) then
				strcat(s, xregnames[pclreg[i]])
			else
				strcat(s, regnames[pclreg[i]])
			fi
			if pclloc[i]=regvar_loc then strcat(s, "*") fi
		when temp_loc then				!in temp
			strcat(s, "T")
			strcat(s, strint(i))

		else
			strcat(s, "(==")
!int fs:=fpshortnames
!fpshortnames:=1
!			strcat(s, stropnd(pclopnd[i]))
!fpshortnames:=fs
			strcat(s, ")")
		esac
		if pclcount[i]>1 then strcat(s, "@") fi
		strcat(s, "<")
		strcat(s, pstdnames[pclmode[i]])
		strcat(s, ">")

		if i<noperands then strcat(s,", ") fi
	od
	strcat(s,") ")

	ipadstr(str, 50)
!	ipadstr(str, 10)

	strcat(s,"WR:(")
!	for r:=r0 to r9 when workregs[r] do
	for r:=r0 to r9  do
		strcat(s,(regset[r]|"1 "|"0 "))
	od
	strcat(s,") ")

	strcat(s,"XWR:(")
	for r:=r0 to xregmax do
		strcat(s,(xregset[r]|"1 "|"0 "))
	od

	strcat(s,") hwstack:")
	strcat(s,strint(mstackdepth))
	strcat(s," noperands:")
	strcat(s,strint(noperands))
	strcat(s," ncalldepth:")
	strcat(s,strint(ncalldepth))
	return s
end

global proc showopndstack=
	mgencomment(stropndstack(1))
end
=== mc_writeasm.m 0 0 44/108 ===
!export int assemtype='AA'

export ichar asmext="asm"

const fshowseq=1
!const fshowseq=0

!const useintelregs=1
const useintelregs=0

const showsizes=1
!const showsizes=0

!const showfreed=1
const showfreed=0

!const fextendednames=1			!include module name in qualified names
const fextendednames=0

[8, r0..r15]ichar nregnames

[r0..r15]psymbol regvars		!nil, or strec when it uses that reg
[r0..r15]psymbol xregvars

proc writemcl(int index,ref mclrec mcl)=

!	case mcl.opcode
	
	if mcl.opcode=m_comment and mcl.a.svalue^='?' then
	else
		strmcl(mcl)
		gs_line(pdest)
	fi
!	esac
end

global proc strmcl(ref mclrec mcl)=
	static [512]char str
	[128]char opcname
	mclopnd a,b
	int opcode,cond,sizepref
	ichar s,comment
	psymbol d

	opcode:=mcl.opcode
	str[1]:=0

	cond:=mcl.cond
	a:=mcl.a
	b:=mcl.b
	comment:=nil

	case opcode
	when m_procstart then
		asmstr(";Proc ")
		asmstr(a.def.name)
		currasmproc:=a.def
		clear regvars
		clear xregvars

		return

	when m_procend then
		asmstr(";End\n")
		currasmproc:=nil

		return

	when m_comment then
		asmchar(';')
		asmstr(a.svalue)
		return
	when m_endx then
		return

	when m_labelname then				!label name will be complete and will have colon(s)
		d:=a.def
		case a.valtype
		when def_val then
			asmstr(getdispname(d))
		when stringimm_val then
			asmstr(a.svalue)
			return
		else
			merror("strmcl/lab")
		esac

		asmstr(":")

		if d.exported then
			if eqstring(getbasename(d.name), d.name) then
				asmstr(":")
			else
				asmstr("\n`")
				asmstr(getbasename(d.name))
				asmstr("::")
			fi
		fi


		return

	when m_labelx then
		if a.valtype=label_val then
			fprint @str,"L#:",a.value
		else
			recase m_labelname
		fi
		asmstr(str)
		return

	when m_define then
		asmstr("    ")
		asmstr(a.svalue)
		asmstr(" = ")
		asmopnd(b)
		return

	when m_definereg then
		d:=a.def
		asmstr("    ")
		asmstr(getdispname(d))
		if ispfloat(d.mode) then
			xregvars[d.reg]:=d
		else
			regvars[d.reg]:=d
		fi

!		asmstr(a.svalue)
		asmstr(" = ")

		case b.mode
		when a_reg then
			asmstr(getregname(b.reg, b.size))

		else
			asmstr(getxregname(b.reg, b.size))
		esac
		return

!	WHEN M_TRACE THEN
!!		ASMSTR(SINCLUDE("c:\\px\\trace.aa"))
!		ASMSTR(SINCLUDE("c:trace.aa"))
!
!		RETURN

	esac

	case opcode
	when m_jmpcc then
		print @opcname,"j",,asmcondnames[cond]

	when m_setcc then
		print @opcname,"set",,asmcondnames[cond]

	when m_cmovcc then
		print @opcname,"cmov",,asmcondnames[cond]

	when m_andx then
		strcpy(opcname,"and")
	when m_orx then
		strcpy(opcname,"or")
	when m_xorx then
		strcpy(opcname,"xor")
	when m_notx then
		strcpy(opcname,"not")

	when m_ascii then
		strcpy(opcname, "dq")

	ELSIF OPCODE>M_HALT THEN
		STRCPY(OPCNAME,STRINT(OPCODE))

	else
		strcpy(opcname,mclnames[opcode]+2)
	esac

	ipadstr(opcname,(opcode=m_dq|4|10)," ")

	ipadstr(str,4)

	strcat(str,opcname)

	asmstr(str)

	if a and b then		!2 operands
		sizepref:=needsizeprefix(opcode,a,b)
!
		asmopnd(a,sizepref)
		asmstr(",	")
		asmopnd(b,sizepref)

		if mcl.c then
			asmstr(",")
			asmstr(strint(mcl.c))
		fi

	elsif a and a.mode then								!1 operand
		if opcode=m_call then
			asmopnd(a,0,opcode)
		else
			asmopnd(a,1,opcode)
		fi
	fi

	if showsizes then
		if a then
			asmstr("  ; ")
			asmstr(strint(a.size))
			if b then
				asmstr("/")
				asmstr(strint(b.size))
			fi
		fi
	fi

IF SHOWFREED THEN
BYTE FIRST:=1
	FOR R IN R0..R15 WHEN MCL.REGFREED[R] DO
		IF FIRST THEN
			FIRST:=0
			ASMSTR(" #======<")
		ELSE
			ASMSTR(" ")
		FI
		ASMSTR(GETREGNAME(R))
	OD
	IF NOT FIRST THEN
		ASMSTR(">")
	FI
FI

IF FSHOWSEQ THEN ASMSTR("	#"); ASMSTR(STRINT(MCL.SEQNO)) FI
end

global func strmclstr(ref mclrec m)ichar=
	gs_init(pdest)
	strmcl(m)
	return pdest.strptr
end

global func mstropnd(mclopnd a,int sizeprefix=0,opcode=0)ichar=
	static [512]char str
	[128]char str2
	ichar plus,t
	int offset,tc

	str[1]:=0

	case a.mode
	when a_reg then
		return strreg(a.reg, a.size)

	when a_imm then
		if opcode=m_dq and a.valtype=intimm_val then
			if a.value in 0..9 then
				strcat(str,strint(a.value))
			else
				strcat(str,"0x")
				strcat(str,strword(a.value,"H"))
			fi
		else
			strcpy(str,strvalue(a))
		fi

	when a_mem then
!		case a.valtype
!		when intimm_val then
!CPL "OPND/MEM/INT"
!			strcpy(str,strint(a.value))
!		when realimm_val then
!CPL "OPND/MEM/REALIMM"
!			strcpy(str,strreal(a.xvalue))
!		when realmem_val then
!CPL "OPND/MEM/REALMEM"
!			fprint @str,"M#",a.xvalue
!		esac
!CPL "OPND/MEM"

		strcat(str,getsizeprefix(a.size,sizeprefix))
		strcat(str,"[")

		plus:=""
		if a.reg then
			strcat(str,strreg(a.reg,8))
			plus:=" + "
		fi
		if a.regix then
			strcat(str,plus)
			strcat(str,strreg(a.regix,8))
			plus:=" + "

			if a.scale>1 then
				strcat(str,"*")
				strcat(str,strint(a.scale))
			fi
		fi

		if a.valtype in [def_val,label_val, temp_val] then
			if plus^ then
				strcat(str,plus)
			fi
			strcat(str,strvalue(a))
	    elsif offset:=a.offset then
			print @str2,offset:" + "
			strcat(str,str2)
		fi
		strcat(str,"]")

	when a_xreg then
		return strxreg(a.reg,a.size)

	else
		println "BAD OPND",A.MODE
		return "<BAD OPND>"
	esac

	return str
end

global func strvalue(mclopnd a)ichar=
	static [512]char str
	[128]char str2
	psymbol def
	i64 value,offset,length
	ichar ss

	def:=a.def
	value:=a.value

	strcpy(str,"")

	case a.valtype
	when def_val then
		strcat(str,getdispname(def))

	addoffset:
		if offset:=a.offset then
			print @str2,(offset>0|"+"|""),,offset
			strcat(str,str2)
		fi

	when intimm_val then
		strcat(str,strint(value))

	when realimm_val then
		print @str,a.xvalue:"20.20"

	when realmem_val then
		strcat(str,"M")
		strcat(str,strreal(a.xvalue))

	when stringimm_val then
		strcat(str,"""")
		strcat(str,a.svalue)
		strcat(str,"""")

	when name_val then
		strcat(str,a.svalue)

	when label_val then
		strcat(str,"L")
		strcat(str,strint(a.labelno))
		goto addoffset

	when temp_val then
		return gettempname(currasmproc,a.tempno)

	else
		merror("Stropnd?")
	esac

!STRCAT(STR, VALTYPENAMES[A.VALTYPE])
	return str

end

global proc asmopnd(mclopnd a,int sizeprefix=0,opcode=0)=
	asmstr(mstropnd(a,sizeprefix,opcode))
end

global func getregname(int reg,size=8)ichar=
	static [1..17]ichar prefix=("B","W","","A","","","","D","","","","","","","","Q","N")
	static [32]char str
	[16]char str2
	ichar rs
	int size2

	if useintelregs then
		return nregnames[size, reg]
	fi

	size2:=size
	if size2>16 then
		size2:=17
	FI

	case reg
	when rnone then return "-"
	when rframe then rs:="fp"
	when rstack then rs:="sp"
	else
		getstrint(reg-r0,str2)
		rs:=str2
	esac

	print @str,prefix[size2],,rs
	return str
end

global func getxregname(int reg,size=8)ichar=
	static [32]char str

	if reg=rnone then return "-" fi

	print @str,"XMM",,reg-xr0
	return str
end

proc asmstr(ichar s)=
	gs_str(pdest,s)
end

proc asmchar(int c)=
	gs_char(pdest,c)
end

global func getdispname(psymbol d)ichar=
	static [256]char str

	if d.reg then

		IF FEXTENDEDNAMES THEN
			fprint @str,"##R.#.#", (fpshortnames|""|"`"),(pfloat[d.mode]|"X"|""), $PMODULENAME,(fpshortnames|d.name|getfullname(d))
		else
			fprint @str,"##R.#", (fpshortnames|""|"`"),(pfloat[d.mode]|"X"|""), (fpshortnames|d.name|getfullname(d))
		fi

		return str
	fi

	if fpshortnames then
		return d.name
	else
		return getfullname(d,backtick:1)
	fi

end 

global func gettempname(psymbol d, int n)ichar=
	static [128]char str

	if fpshortnames or d=nil then
		print @str,"T",,n
	else
		fprint @str,"#.$T#",getdispname(d),n
	fi
	str
end

EXPORT func strreg(int reg, size=8)ichar=
	psymbol d

	d:=regvars[reg]
!D:=NIL

	if d and psize[d.mode]=size then
		return getdispname(d)
	fi
	getregname(reg,size)
end

func strxreg(int reg, size=8)ichar=
	psymbol d

	d:=xregvars[reg]

	if size=8 and d then
		getdispname(d)
	else
		getxregname(reg,size)
	fi
end

export func getassemstr:ref strbuffer=
!write all mcl code in system by scanning all procs
!mcl code is only stored per-proc
	psymbol d,e
	ref mclrec m
	[32]char str2,str3
	int i

	gs_init(pdest)
!
	asmstr(";   mm7\n")
	case phighmem
	when 1 then asmstr("    $userip\n")
	when 2 then asmstr("    $highmem\n")
	esac

	m:=mccode
	i:=1
	while m do
		writemcl(i,m)
		++i
		m:=m.nextmcl
	od

	return pdest
end

global func needsizeprefix(int opcode,mclopnd a,b)int=
	case opcode
	when m_movsx, m_movzx, m_cvtsi2ss, m_cvtsi2sd then
		return 1

	when m_cvtss2si,m_cvtsd2si, m_cvttss2si,m_cvttsd2si then
		return 1
	when m_shl, m_shr, m_sar then
		if a.mode=a_mem then return 1 fi
		return 0
	esac

	if a.mode=a_reg or a.mode=a_xreg or b.mode=a_reg or b.mode=a_xreg then
		return 0
	fi
	return 1
end

global func getsizeprefix(int size,enable=0)ichar=
	if not enable then return "" fi
	case size
	when 1 then return "byte "
	when 2 then return "u16 "
	when 4 then return "u32 "
	when 8 then return "u64 "
	esac
	return ""
end

proc start=
	byte flag

	assemtype:='AA'

	if useintelregs then
		for i in 1..8 when i in [1,2,4,8] do
			for r in r0..r15 do
				flag:=0
				for k in dregnames.bounds do
					if flag then
						if regsizes[k]=i and regindices[k]=r then
							nregnames[i, r]:=dregnames[k]
						fi
					elsif regsizes[k]=0 then
						flag:=1
					fi
				od
			od
		od
	fi
end
=== mc_writeexe.m 0 0 45/108 ===
!Create .exe file from SS-data (code, data, reloc and psymbol tables)

[maxplibfile]i64 libinsttable
[maxplibfile]ichar libinstnames
[maxplibfile]int libnotable			!index into dlltable

global const zsect=3
global const dsect=2
global const csect=1
global const isect=4

record basereloc =
	ref basereloc nextitem
	u32 address				!virtual address
	i32 reloctype
end

ref basereloc basereloclist
int nbaserelocs
int maxrelocaddr
const maxbaseblock=500
[maxbaseblock]int blockbases
[maxbaseblock]i32 blockcounts
[maxbaseblock]i32 blockbytes
[maxbaseblock]byte blockpadding
int nbaseblocks
int basetablesize


const filealign = 512
!const filealign = 32
const sectionalign = 4096
const exe_imagebase = 0x40'0000
const dll_imagebase = 0x1000'0000

global int imagebase

int imagesize
int filesize
ref[]i64 thunktable				!point into code segment
int fileiatoffset
int fileiatsize
psymbol stentrypoint				!psymbol to be the entry point
psymbol stentrypoint2
psymbol stentrypoint3

const maxsection = 10
global [maxsection]sectionrec sectiontable
global int nsections

ref byte importdir				!allowed section data for import directort in .idata

global const maximports = 3000
global [0..maximports]importrec importtable
global int nimports

global const maxexports = 1000
global [maxexports]exportrec exporttable
global int nexports
ichar dllfilename
int isdll

const maxlibs = 50
global [maxlibs]dllrec dlltable
global int ndlls

ref byte datastart
ref byte dataptr
ichar userentrypoint

int exportdirvirtaddr
int exportdirvirtsize
int exportdiroffset				!from start of imp dir

int blockdirvirtaddr
int blockdirvirtsize
int blockdiroffset

global proc writeexe(ichar outfile, int dodll, ichar entrypoint=nil)=
	return when exedone

	genexe1(entrypoint, outfile, dodll)
	genexe2(outfile, dodll)

	exedone:=1
end

global proc genexe1(ichar entrypoint, outfile, int dodll)=
!manipulate the ss data to fill in all the details needed for exe format
	int offset
	ref byte codeaddr				!mem address of start of code seg
	ref u32 offsetptr

	initsectiontable()
!CPL =NPLIBFILES
!FOR I TO NPLIBFILES DO
!	CPL I, PLIBFILES[I]
!OD


	dllfilename:=extractfile(outfile)
	isdll:=dodll

	imagebase:=(isdll|dll_imagebase|exe_imagebase)

	userentrypoint:=entrypoint
	loadlibs()
	scanst()				!build dll/import tables

	getoffsets()

	relocdata(&sectiontable[csect])
	relocdata(&sectiontable[dsect])

	codeaddr:=bufferelemptr(sectiontable[csect].data, 0)

	if phighmem then
		ref riprec pr

		pr:=riplist
		while pr, pr:=pr.next do
			offsetptr:=ref u32(codeaddr+pr.offset)
			offset:=getripoffset(pr.offset, offsetptr^-imagebase, pr.immsize)
			offsetptr^:=offset	
		od
	fi
end

global proc genexe2(ichar outfile, int dodll)=
!construct the exe image in memory, then write out the file
	imagefileheader header
	optionalheader optheader
	int offset,i
	i64 aa

	dllfilename:=extractfile(outfile)

	isdll:=dodll

	datastart:=dataptr:=pcm_allocz(filesize)

	writedosstub()
	writepesig()
	writefileheader()
	writeoptheader()
	for i to nsections do
		writesectionheader(&sectiontable[i])
	od
	writepadding(sectiontable[1].rawoffset)
	for i to nsections do
		writesectiondata(&sectiontable[i])
	od

	if pverbose=2 then
		println "EXE size:  ", dataptr-datastart:"10s,jr"
		println
	fi

	if writefile(outfile,datastart,dataptr-datastart)=0 then
		println "Error writing exe file (possibly still running)"
		stop 1
	fi
end

proc loadlibs=
!load library instances
	int i
	i64 hinst
	ichar file
	[300]char filename

	for i to nplibfiles when plibfiles[i]^<>'$' do
		strcpy(filename, plibfiles[i])
		hinst:=os_getdllinst(filename)
		if hinst=0 then
			cpl "File:",filename
			axerror("Can't load search lib")
		fi
		libinsttable[i]:=hinst
		libinstnames[i]:=pcm_copyheapstring(filename)
	od
end

global proc initsectiontable=
!set up the section table

	sectiontable[csect].name:=".text"
	sectiontable[csect].segtype:=code_seg
	sectiontable[csect].data:=ss_code
	sectiontable[csect].virtsize:=bufferlength(ss_code)

	if pverbose then
		println "Code size: ", bufferlength(ss_code):"10s,jr","bytes"
		if pverbose=2 then
			println "Idata size:", bufferlength(ss_idata):"10s,jr"
			println "Code+Idata:", bufferlength(ss_code)+bufferlength(ss_idata):"10s,jr"
			println "Zdata size:", ss_zdatalen:"10s,jr"
		fi
	fi

	if bufferlength(ss_idata)=0 then
		addqword (ss_idata,0)
	fi

	sectiontable[dsect].name:=".data"
	sectiontable[dsect].segtype:=idata_seg
	sectiontable[dsect].data:=ss_idata

	sectiontable[dsect].virtsize:=bufferlength(ss_idata)
	sectiontable[dsect].rawsize:=roundtoblock(sectiontable[dsect].virtsize,filealign)
	sectiontable[dsect].nrelocs:=ss_nidatarelocs
	sectiontable[dsect].relocs:=ss_idatarelocs

	if ss_zdatalen=0 then
		ss_zdatalen:=16
	fi

	sectiontable[zsect].name:=".bss"
	sectiontable[zsect].segtype:=zdata_seg
	sectiontable[zsect].virtsize:=ss_zdatalen


!note: rawsize will be recalculated later after thunk table is added
	sectiontable[csect].rawsize:=roundtoblock(sectiontable[csect].virtsize,filealign)
	sectiontable[csect].nrelocs:=ss_ncoderelocs
	sectiontable[csect].relocs:=ss_coderelocs

	sectiontable[isect].name:=".idata"
	sectiontable[isect].segtype:=impdata_seg
	sectiontable[isect].virtsize:=0
	sectiontable[isect].rawsize:=0

	nsections:=4
end

func extractlibname(ichar name, int &libno,moduleno)ichar=
!if name contains a dot, eg lib.abc, then set libno to index of "lib", and return "abc"
!otherwise return original name
	ref char s,name2
	[256]char str
	[256]char str2
	int i

	name2:=nil

	reenter:
	s:=name
	libno:=0

	while s^ do
		if s^='.' then			!assume lib.name
			memcpy(str,name,s-name)
			str[s-name+1]:=0
			strcat(str,".dll")

			for i:=1 to ndlls do
				if eqstring(str,dlltable[i].name) then
					libno:=i
					++dlltable[libno].nprocs
					return (name2|name2|s+1)
				fi
			od
			if ndlls>=maxlibs then axerror("Too many libs") fi
			libno:=++ndlls

			dlltable[libno].name:=pcm_copyheapstring(str)
			dlltable[libno].nprocs:=1
			return (name2|name2|s+1)
		fi

		++s
	od

!do explicit search
	int n


	for i:=1 to nplibfiles when libinsttable[i] do
		if os_getdllprocaddr(libinsttable[i],name) then
			n:=i
			exit				!don't need the actual address; just whether it exists
		fi
	else
		CPL NAME
		axerror("Can't find external function")
	od

!found in search lib n
	if libno:=libnotable[n] then			!already added this library
		++dlltable[libno].nprocs
		return name
	fi

!first use of this lib
	strcpy(str, plibfiles[n])
	strcat(str,".dll")
	if ndlls>=maxlibs then axerror("2:Too many libs") fi
	libno:=++ndlls

	dlltable[libno].name:=pcm_copyheapstring(str)
	dlltable[libno].nprocs:=1
	libnotable[n]:=libno

	return name
end

proc scanst=
!scan symbol table and build dll and imports list
!this version assumes dlls are encoded into the name of each import
!(otherwise, it means requiring a list of dlls and loading/searching for
!the names: doing real linker work.)

	int i,libno
	psymbol d
	ichar name, libname, basename

	for i:=1 to ss_nsymbols do
		d:=ss_symboltable[i]
		if d.imported then
			if nimports>=maximports then axerror("genexe: Too many imports") fi
			++nimports
			name:=extractlibname(d.name,libno,1)
			importtable[nimports].libno:=libno			!0 if no lib
			importtable[nimports].name:=name				!original, or 2nd part of lib.name
			importtable[nimports].def:=d

			d.importindex:=nimports
		elsif d.exported then
			basename:=getbasename(d.name)
			if userentrypoint then
				if eqstring(basename,userentrypoint) then
					stentrypoint:=d
				fi
			else
!				if eqstring(basename,"main") and not isdll then
				if d.isentry and not isdll then
					stentrypoint:=d
				fi
			fi

			if nexports>=maxexports then axerror("gendll: Too many exports") fi
			++nexports

			exporttable[nexports].def:=d
			exporttable[nexports].name:=getbasename(d.name)
		fi
	od
end

proc relocdata(ref sectionrec s)=
	ref sectionrec u
	ref relocrec r
	ref byte p
	ref u32 p32
	ref u64 p64
	psymbol d
	int offset,index,thunkoffset,iatoffset

	p:=bufferelemptr(s.data,0)
	r:=s.relocs

	while r do
		d:=ss_symboltable[r.stindex]
		index:=d.importindex				!into importtable
		thunkoffset:=importtable[index].thunkoffset

		case r.reloctype
		when rel32_rel then
			if not d.imported then
				axerror("rel32/not imported")
			fi
			(ref u32(p+r.offset)^:=thunkoffset-r.offset-4)
!
		when addr32_rel, addr64_rel then				!for addr64, just leave top half zero
			if d.imported then
				(ref u32(p+r.offset)^:=imagebase+thunkoffset+sectiontable[csect].virtoffset)
			else
				u:=nil
				case d.segment
				when zdata_seg then u:=&sectiontable[zsect]
				when idata_seg then u:=&sectiontable[dsect]
				when code_seg then u:=&sectiontable[csect]
				else
					PRINTLN D.NAME,D.SEGMENT
					AXERROR("RELOCDATA/SEG?")

				esac
					p32:=cast(p+r.offset)
					if r.reloctype=addr32_rel then
						p32^:=p32^+u.virtoffset+imagebase
					else
						p64:=cast(P32)
						p64^:=p64^+u.virtoffset+imagebase
					fi
			fi
		else
			cpl relocnames[r.reloctype]
			axerror("Can't do this rel type")
		esac

		r:=r.nextreloc
	od

end

proc getbaserelocs(ref sectionrec s)=
!	ref sectionrec u
	ref relocrec r
	ref byte p
	psymbol d
	int index

	p:=bufferelemptr(s.data,0)
	r:=s.relocs

	while r do
		d:=ss_symboltable[r.stindex]

		case r.reloctype
		when addr32_rel, addr64_rel then				!for addr64, just leave top half zero
			if d.imported then
			else

IF R.RELOCTYPE=ADDR32_REL THEN
!PRINTLN "??BASE RELOC",(D.SEGMENT=CODE_SEG|"CODE"|"DATA"),(R.RELOCTYPE=ADDR32_REL|"ADDR32"|"ADDR64")
ELSE
				newbasereloc(s.virtoffset+r.offset, r.reloctype)
FI

			fi
		esac

		r:=r.nextreloc
	od

end

proc writerecordx(ref void r, int length)=
	memcpy(dataptr,r,length)
	dataptr+:=length
end

proc writedosstub=
!write 128-byte dos stub to dataptr
	static []byte stubdata = (
	0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 
	0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
	0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD, 
	0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68, 
	0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 
	0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F, 
	0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E, 
	0x20, 0x69, 0x6E, 0x20, 0x44, 0x4F, 0x53, 0x20, 
	0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A, 
	0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)

	writerecordx(&stubdata,stubdata.bytes)
end

proc writepesig=
	dataptr++^:='P'
	dataptr++^:='E'
	dataptr++^:=0
	dataptr++^:=0
end

proc writepadding(int offset)=
!offset is the next desired offset in the file
	dataptr:=datastart+offset			!data will have been cleared
end

proc writefileheader=
	imagefileheader header

	clear header

	header.machine:=0x8664
	header.nsections:=nsections
	header.optheadersize:=optionalheader.bytes
	header.characteristics:=0x22F
	if isdll then
		header.characteristics:=0x22E ior 0x2000
	fi

	writerecordx(&header,header.bytes)
end

proc writeoptheader=
	optionalheader header

	clear header

	header.magic:=0x20B
	header.majorlv:=1
	header.minorlv:=0
	header.codesize:=sectiontable[csect].rawsize
	header.idatasize:=sectiontable[dsect].rawsize+sectiontable[isect].rawsize
	header.zdatasize:=roundtoblock(sectiontable[zsect].virtsize,filealign)
	
	if stentrypoint=nil then
		stentrypoint:=stentrypoint2
	fi

	if stentrypoint=nil then
		if userentrypoint then
			cpl userentrypoint
			axerror("User entry point not found")
		else
			if not isdll then
				axerror("Entry point not found: main")
			fi
		fi
	else
		header.entrypoint:=sectiontable[csect].virtoffset+stentrypoint.offset
	fi

	header.codebase:=sectionalign
	header.imagebase:=imagebase
	header.sectionalignment:=sectionalign
	header.filealignment:=filealign
	header.majorosv:=4
	header.minorosv:=0
	header.majorssv:=5
	header.minorssv:=2
	header.imagesize:=imagesize
	header.headerssize:=sectiontable[1].rawoffset
	header.subsystem:=3
!	header.subsystem:=2

	header.stackreserve:=4194304
	header.stackcommit:=2097152

	header.heapreserve:=1048576
	header.heapcommit:=4096
	header.rvadims:=16

	header.importtable.virtualaddr:=sectiontable[isect].virtoffset
	header.importtable.size:=sectiontable[isect].virtsize-exportdirvirtsize-blockdirvirtsize

	if isdll then
		header.dllcharacteristics:=0x40		!relocatable
		header.exporttable.virtualaddr:=exportdirvirtaddr
		header.exporttable.size:=exportdirvirtsize

		header.basereloctable.virtualaddr:=blockdirvirtaddr
		header.basereloctable.size:=blockdirvirtsize
	fi

	header.iat.virtualaddr:=fileiatoffset
	header.iat.size:=fileiatsize

	writerecordx(&header,header.bytes)

end

proc writesectionheader(ref sectionrec s)=
	imagesectionheader sheader

	clear sheader

	strcpy(&sheader.name[1],s.name)
	sheader.virtual_size:=s.virtsize
	sheader.virtual_address:=s.virtoffset
	sheader.rawdata_offset:=s.rawoffset
	sheader.rawdata_size:=s.rawsize

	i64 aa
	case s.segtype
	when zdata_seg then
		aa:=0xC050'0080
		sheader.characteristics:=aa
!		sheader.characteristics:=0xC050'0080
	when idata_seg then
		aa:=0xC050'0040
		sheader.characteristics:=aa
!		sheader.characteristics:=0xC050'0040
	when code_seg then
		aa:=0x6050'0020
		sheader.characteristics:=aa
!		sheader.characteristics:=0x6050'0020
	when impdata_seg then
		aa:=0xC030'0040
		sheader.characteristics:=aa
!		sheader.characteristics:=0xC030'0040
	esac
	writerecordx(&sheader,sheader.bytes)
end

proc writesectiondata(ref sectionrec s)=
	case s.segtype
	when impdata_seg then
		writerecordx(s.bytedata,s.virtsize)		!rest of section will be zeros
		if s.rawsize>s.virtsize then
			dataptr+:=(s.rawsize-s.virtsize)
		fi

	when zdata_seg then					!nothing goes to disk
!		dataptr+:=s.rawsize
	else
		writerecordx(bufferelemptr(s.data,0),s.rawsize)
	esac
end

proc writeexporttable(ref byte pstart)=
	const maxexports=2000
	[maxexports]int sortindex
	ref exportdirrec phdr := cast(pstart)
	ref u32 paddrtable
	ref u32 pnametable
	ref u16 pordtable
	ref char pdllname
	ref char pnames
	int addrtableoffset
	int nametableoffset
	int ordtableoffset
	int dllnameoffset
	int namesoffset
	int virtoffset
	int sectionno
	psymbol d
	ichar basename

	phdr.timedatestamp:=0x5f89f4f8

	phdr.ordinalbase:=1
	phdr.naddrtable:=nexports
	phdr.nnamepointers:=nexports

!these are offsets from the start of the export data, from the start of the export dir
	addrtableoffset:=exportdirrec.bytes
	nametableoffset:=addrtableoffset+nexports*4
	ordtableoffset:=nametableoffset+nexports*4
	dllnameoffset:=ordtableoffset+nexports*2
	namesoffset:=dllnameoffset+strlen(dllfilename)+1

!virtoffset must be added to all above basic offsets, before being written to the file 
	virtoffset:=sectiontable[isect].virtoffset+exportdiroffset

!work out pointers into memory to receive the data
	paddrtable:=cast(pstart+addrtableoffset)
	pnametable:=cast(pstart+nametableoffset)
	pordtable:=cast(pstart+ordtableoffset)
	pdllname:=cast(pstart+dllnameoffset)
	pnames:=cast(pstart+namesoffset)

!fill in rest of export dir
	phdr.namerva:=dllnameoffset+virtoffset
	phdr.expaddressrva:=addrtableoffset+virtoffset
	phdr.namepointerrva:=nametableoffset+virtoffset
	phdr.ordtablerva:=ordtableoffset+virtoffset

	strcpy(pdllname,dllfilename)

!address table
	if nexports>maxexports then
		axerror("Too many exports - can't sort")
	fi

	sortexports(sortindex)

	for i to nexports do
!		d:=exporttable[i].def
		d:=exporttable[sortindex[i]].def
		basename:=exporttable[sortindex[i]].name
		sectionno:=getsectionno(d.segment)

		strcpy(pnames,basename)
		pnametable^:=namesoffset+virtoffset
		++pnametable
		namesoffset+:=strlen(basename)+1
		pnames+:=strlen(basename)+1

		paddrtable^:=d.offset+sectiontable[sectionno].virtoffset
		++paddrtable
		pordtable^:=i-1
		++pordtable
	od
end

func getexporttablesize:int=
	int size

	size:=exportdirrec.bytes
	size+:=nexports*4			!address table entries
	size+:=nexports*4			!name pointers
	size+:=nexports*2			!ordinal table

	size+:=strlen(dllfilename)+1
	for i to nexports do
		size+:=strlen(exporttable[i].def.name)+1
	od

	return size
end

proc newbasereloc(int addr, reltype)=
	ref basereloc p

	p:=pcm_allocnfz(basereloc.bytes)
	p.address:=addr
	p.reloctype:=reltype

	p.nextitem:=basereloclist

	basereloclist:=p
	++nbaserelocs
	maxrelocaddr max:=addr

end

proc scanbaserelocs=
!go through all the relocs and build the block tables, and work out overall size
!	int maxaddr:=maxrelocaddr+4096
	int baseaddr,addr,nextblock
	ref basereloc p

	baseaddr:=0x1000
	nbaseblocks:=0

	repeat
		nextblock:=baseaddr+0x1000
		if nbaseblocks>=maxbaseblock then axerror("Too many blocks") fi
		++nbaseblocks
		blockbases[nbaseblocks]:=baseaddr
		blockcounts[nbaseblocks]:=0


		p:=basereloclist
		while p do
			addr:=p.address
			if addr>=baseaddr and addr<nextblock then
!				println "	",addr:"h",addr-baseaddr:"h", relocnames[p.reloctype]
				++blockcounts[nbaseblocks]
			fi

			p:=p.nextitem
		od

		baseaddr:=nextblock
	until baseaddr>maxrelocaddr

	for i to nbaseblocks when blockcounts[i] do
!	for i to nbaseblocks do
		if blockcounts[i].odd then
			++blockcounts[i]
			++blockpadding[i]
		fi
		blockbytes[i]:=blockcounts[i]*2+8
		basetablesize+:=blockbytes[i]
	od
end

proc writebasereloctable(ref byte pstart)=
	
	ref u32 p32
	ref u16 p16
	int baseaddr,addr,nextblock
	ref basereloc q

	p32:=cast(pstart)

	for i to nbaseblocks when blockcounts[i] do
		p32^:=blockbases[i]
		++p32
		p32^:=blockbytes[i]
		++p32
		p16:=cast(p32)

		q:=basereloclist
		baseaddr:=blockbases[i]
		nextblock:=baseaddr+4096

		while q do
			addr:=q.address
			if addr>=baseaddr and addr<nextblock then
				p16^:=addr-baseaddr+(q.reloctype=addr32_rel|3|10)<<12
				++p16
			fi
!
			q:=q.nextitem
		od
		if blockpadding[i] then p16++^:=0 fi

		p32:=cast(p16)

	od
end

proc sortexports([]int &sortindex)=
!Sort exporttable by name. This is done by building a set of sorted indices into
!sortindex
	psymbol d,e

!First, store 1..nexports into sortindex
	for i to nexports do
		sortindex[i]:=i
	od

!do bubble sort for now
	repeat
		int swapped:=0
		for i:=1 to nexports-1 do

			d:=exporttable[sortindex[i]].def
			e:=exporttable[sortindex[i+1]].def

			if strcmp(getbasename(d.name), getbasename(e.name))>0 then
				swapped:=1
				swap(sortindex[i], sortindex[i+1])
			fi
		od
	until not swapped

end

func getsectionno(int segment)int=
	case segment
	when zdata_seg then zsect
	when idata_seg then dsect
	when code_seg then csect
	else axerror("GSN"); 0
	esac
end

proc getoffsets=
!apply file/image offsets to sectiontable
	int fileoffset, imageoffset,i,diroffset,impdirno,hinttableoffset,j,n
	int codesize,length,thunkoffset,offset,dirstartoffset

	fileoffset:=128+4+imagefileheader.bytes+optionalheader.bytes	!dosstub+sig
	fileoffset+:=imagesectionheader.bytes*nsections

	fileoffset:=roundtoblock(fileoffset,filealign)
	imageoffset:=4096

!Need to increase size of code segment to incorporate the thunk table
	ref byte pcode
	codesize:=sectiontable[csect].virtsize
	pcode:=bufferelemptr(ss_code,codesize)
	while codesize iand 7 do pcode++^:=0x90; ++codesize od
	thunkoffset:=codesize
	codesize+:=nimports*8

	sectiontable[csect].virtsize:=codesize
	sectiontable[csect].rawsize:=roundtoblock(codesize,filealign)

!have to actually add the extra memory now.
	buffercheck(ss_code, codesize-thunkoffset+16)		!just ensure it's there for now

	for i:=1 to nsections do
		if sectiontable[i].segtype<>zdata_seg then
			sectiontable[i].rawoffset:=fileoffset
		fi
		if sectiontable[i].segtype<>zdata_seg then
			fileoffset:=roundtoblock(fileoffset+sectiontable[i].virtsize,filealign)
		fi
		sectiontable[i].virtoffset:=imageoffset

		if sectiontable[i].segtype=impdata_seg then
			diroffset:=imageoffset
			impdirno:=i
		fi

		imageoffset:=roundtoblock(imageoffset+sectiontable[i].virtsize,sectionalign)
	od

	if isdll then
		getbaserelocs(&sectiontable[csect])
		getbaserelocs(&sectiontable[dsect])
	fi

!Work out offsets within import directory
!assume dll/imports have been set up
!diroffset starts off as virtual offset of start of impdata section

	diroffset+:=(ndlls+1)*importdirrec.bytes			!need blank entry as terminator

!diroffset now points to import name table
!usual arrangements is for all import name table, followed by all import addr tables

	for i to ndlls do
		dlltable[i].nametableoffset:=diroffset				!data will be filled in later
		diroffset+:=(dlltable[i].nprocs+1)*8
	od
	fileiatoffset:=diroffset
	for i to ndlls do
		dlltable[i].addrtableoffset:=diroffset				!data will be filled in later
		diroffset+:=(dlltable[i].nprocs+1)*8
	od
	fileiatsize:=diroffset-fileiatoffset

!diroffset now points to hint/name table, which is shared by all libs
!At this point, I need to write into an actual impdata segment, which doesn't
!exist yet. So I need to do a first pass over the import names to work out the size
	hinttableoffset:=diroffset
	for i to nimports do
		length:=strlen(importtable[i].name)+3
		if length iand 1 then ++length fi		!keep even
		importtable[i].hintnameoffset:=diroffset
		diroffset+:=length
	od

!need also space for the names of the libs

!need I think to get to next multiple of four
	diroffset:=roundtoblock(diroffset,4)

	for i to ndlls do
		length:=strlen(dlltable[i].name)+1
		if length iand 1 then ++length fi		!keep even
		dlltable[i].dllextraoffset:=diroffset
		diroffset+:=dlltable[i].nprocs*4		!space for back-links to dir entry
		dlltable[i].dllnameoffset:=diroffset
		diroffset+:=length
	od

	dirstartoffset:=sectiontable[impdirno].virtoffset

	if isdll then
		exportdirvirtaddr:=diroffset
		exportdiroffset:=diroffset-dirstartoffset
		exportdirvirtsize:=getexporttablesize()

		diroffset+:=exportdirvirtsize

		scanbaserelocs()

		blockdirvirtaddr:=diroffset
		blockdiroffset:=diroffset-dirstartoffset
		blockdirvirtsize:=basetablesize
		diroffset+:=blockdirvirtsize
	fi

	offset:=diroffset-dirstartoffset

!offset contains now the overall size of the import directory
!diroffset contains is the overall size of the image

!finish off last section data, and compute final file and image sizes
	sectiontable[impdirno].virtsize:=offset
	sectiontable[impdirno].rawsize:=roundtoblock(offset,filealign)
	filesize:=roundtoblock(fileoffset+offset,filealign)

	imagesize:=roundtoblock(imageoffset+(diroffset-dirstartoffset),sectionalign)

	ref byte pimpdir

	pimpdir:=sectiontable[impdirno].bytedata:=pcm_allocz(offset)

!prepare the thunk area in the code segment
	ref importdirrec pdir
	ref i64 paddr,pname
	int iatoffset
	pdir:=cast(pimpdir)

!start fill in details within the import directory section
	for i:=1 to ndlls do
		pdir.implookuprva:=dlltable[i].nametableoffset
		pdir.impaddressrva:=dlltable[i].addrtableoffset
		pdir.namerva:=dlltable[i].dllnameoffset
		++pdir

		iatoffset:=dlltable[i].addrtableoffset
		paddr:=cast(pimpdir+iatoffset-dirstartoffset)
		pname:=cast(pimpdir+dlltable[i].nametableoffset-dirstartoffset)
		for j to nimports when importtable[j].libno=i do
			pname^:=paddr^:=importtable[j].hintnameoffset
			importtable[j].iatoffset:=iatoffset
			iatoffset+:=8
			++pname
			++paddr
		od
	od

!Fill in the hint/name table
	ref byte phint
	ref u32 pextra

	for i to nimports do
		phint:=pimpdir+importtable[i].hintnameoffset-dirstartoffset
		phint+:=2					!leave hint as 0
		strcpy(cast(phint),importtable[i].name)
	od

!same for lib names (no hint here, but re-use phint anyway)
	int xxx
	xxx:=dirstartoffset
	for i to ndlls do
		pextra:=cast(pimpdir+dlltable[i].dllextraoffset-dirstartoffset)
		for j to dlltable[i].nprocs do
!CPL "  PROC", J, DLLTABLE[I].NAME, IMPORTDIRREC.BYTES
			pextra^:=xxx
			++pextra
		od
		xxx+:=importdirrec.bytes
		phint:=pimpdir+dlltable[i].dllnameoffset-dirstartoffset
		strcpy(cast(phint),dlltable[i].name)
	od

	if isdll then
		writeexporttable(ref byte(pimpdir)+exportdiroffset)
		writebasereloctable(ref byte(pimpdir)+blockdiroffset)
	fi

!write the thunk table
	ref byte thunkptr,codebase
	int thunkaddr
	thunkptr:=bufferelemptr(ss_code,thunkoffset)
	codebase:=bufferelemptr(ss_code,0)

	for i to nimports do
		importtable[i].thunkoffset:=thunkptr-codebase
		if phighmem=0 then
			thunkptr++^:=0x48
			thunkptr++^:=0xFF
			thunkptr++^:=0x24
			thunkptr++^:=0x25
			thunkaddr:=imagebase+importtable[i].iatoffset
			(ref i32(thunkptr)^:=thunkaddr)
			thunkptr+:=4
		else					!use rip mode

			thunkptr++^:=0x48
			thunkptr++^:=0xFF
			thunkptr++^:=0x25
			thunkaddr:=imagebase+importtable[i].iatoffset
			(ref i32(thunkptr)^:=getripoffset(int(thunkptr-codebase),thunkaddr-imagebase))
			thunkptr+:=4
			thunkptr++^:=0x90
		fi
	od
!-----------------------------------------------
end

func getripoffset(int addr, dest, int extra=0)int=
!work out the rip offset for a d32 field at <addr>, to <dest>
!opbytes is the number of opcode bytes that precede the field
!addr is offset of d32 field with codeseg, from start of code segment
!dest is offset within image, relative to imagebase
!extra is 0/1/2/4 bytes of imm data that some instructions will have

	addr+:=sectiontable[csect].virtoffset		!now is offset rel to imagebase
	dest-(addr+4)-extra
end

=== mc_writegas.m 0 0 46/108 ===
const fasmformat=2			!gas
!const fasmformat=1			!nasm
!const fasmformat=0			!aa

!export ichar asmext="s"
export ichar asmext="asm"

[8, r0..r15]ichar nregnames

byte currseg

global func getassemstr:ref strbuffer=
!write all mcl code in system by scanning all procs
!mcl code is only stored per-proc
	psymbol d,e
	ref mclrec m
	[32]char str2,str3
	int i

!CPL "WRITE GAS",=PHIGHMEM


	gs_init(pdest)
!	asmstr("# GAS VERSION\n")

	asmstr("    .code64\n")
!	asmstr("    .intel_syntax noprefix\n")
	asmstr("    .intel_syntax prefix\n")
!	asmstr("    .global main\n")

!	asmstr("    default rel\n")
!	asmstr("    extern fmod\n")
!	asmstr("    extern sin\n")
!	asmstr("    extern cos\n")
!	asmstr("    extern tan\n")
!	asmstr("    extern asin\n")
!	asmstr("    extern acos\n")
!	asmstr("    extern atan\n")
!	asmstr("    extern log\n")
!	asmstr("    extern log10\n")
!	asmstr("    extern exp\n")
!	asmstr("    extern floor\n")
!	asmstr("    extern ceil\n")
!	asmstr("    extern pow\n")
!	asmstr("    extern exit\n")
!	asmstr("    extern __getmainargs\n")
!	asmstr("    global main\n")
	asmstr("\n")

!do globals and externs
	d:=psymboltable

	while d, d:=d.next do
		if d.exported then
			asmstr("    .global ")
			asmstr(getbasename(d.name))
			asmstr("\n")
		fi
	od
	asmstr("\n")
	m:=mccode
	i:=1
	while m do
		writemcl(i,m)
		++i
		m:=m.nextmcl
	od

	byte first:=1
	d:=psymboltable

	while d, d:=d.next do
		if d.dllexport then
			if first then
				first:=0
				asmstr("    .section .drectve\n")
			fi
			asmstr("    .ascii "" -export:\\""")
			asmstr(d.name)
			asmstr("\\""""\n")
		fi
	od
	asmstr("\n")

	return pdest
end

proc writemcl(int index,ref mclrec mcl)=

	case mcl.opcode
!	when m_define, m_definereg then
	when m_definereg then
	else
		strmcl(mcl)
		gs_line(pdest)
	esac
end

proc start=
	byte flag

	assemtype:='GAS'

!initialise table of official gp reg names

	for i in 1..8 when i in [1,2,4,8] do
		for r in r0..r15 do
			flag:=0
			for k in dregnames.bounds do
				if flag then
					if regsizes[k]=i and regindices[k]=r then
						nregnames[i, r]:=dregnames[k]
					fi
				elsif regsizes[k]=0 then
					flag:=1
				fi
			od
		od
	od


!for i in 1..8 do
!	for r in r0..r15 do
!		if nregnames[i,r]=nil then
!			print "nil, "
!		else
!			fprint """#"", ",nregnames[i, r]
!		fi
!	od
!	println "\t!", i
!od
!
end


global proc strmcl(ref mclrec mcl)=
	static [512]char str
	[128]char opcname
	mclopnd a,b
	int opcode,cond,sizepref
	ichar s,comment
	psymbol d

	opcode:=mcl.opcode


	cond:=mcl.cond
	a:=mcl.a
	b:=mcl.b
	comment:=nil

!CPL =MCLNAMES[OPCODE]

	case opcode
	when m_procstart then
		asmstr("# Proc ")
		asmstr(a.def.name)
		currasmproc:=a.def

		return

	when m_procend then
		asmstr("# End ")
		currasmproc:=nil

		return

	when m_comment then
		asmchar('# ')
		asmstr(a.svalue)
		return

	when m_labelname then				!label name will be complete and will have colon(s)
		d:=a.def
		case a.valtype
		when def_val then
			asmstr(getdispname(d))
		when stringimm_val then
			asmstr(a.svalue)
			return
		else
			merror("strmcl/lab")
		esac

		asmstr(":")

		if d.exported then
			if eqstring(getbasename(d.name), d.name) then
!				asmstr(":")
			else
				asmstr("\n")
				asmstr(getbasename(d.name))
!				asmstr("::")
				asmstr(":")
			fi
		fi

		return

	when m_labelx then
!		fprint @str,"L#:",a.value
!		asmstr(str)
!		return
		if a.valtype=label_val then
			fprint @str,"L#:",a.value
		else
			recase m_labelname
		fi
		asmstr(str)
		return

	when m_define then
		asmstr("    .set ")
		asmstr(a.svalue)
		asmstr(", ")
		asmopnd(b)
		return

!	when m_definetemp then
!		asmstr("    .set ")
!		asmstr(a.svalue)
!		asmstr(", ")
!		asmopnd(b)
!		return

!	when m_definereg then
!		d:=a.def
!		asmstr("   %define ")
!		asmstr(getdispname(d))
!		asmstr(" ")
!
!		case b.mode
!		when a_reg then
!			asmstr(strreg(b.reg, b.size))
!
!		else
!!			asmstr(getxregname(b.reg, b.size))
!			asmstr(strxreg(b.reg, b.size))
!		esac
!		return

		return

	when m_csegment then asmstr("    .text"); currseg:=code_seg; return
	when m_isegment then asmstr("    .data"); currseg:=idata_seg; return
	when m_zsegment then asmstr("    .bss"); currseg:=zdata_seg; return

	esac

	case opcode
	when m_jmpcc then
		print @opcname,"j",,asmcondnames[cond]

	when m_setcc then
		print @opcname,"set",,asmcondnames[cond]

	when m_cmovcc then
		print @opcname,"cmov",,asmcondnames[cond]

	when m_andx then
		strcpy(opcname,"and")
	when m_orx then
		strcpy(opcname,"or")
	when m_xorx then
		strcpy(opcname,"xor")
	when m_notx then
		strcpy(opcname,"not")

	when m_imul2 then
		strcpy(opcname,"imul")

	when m_movzx then
		if a.size=8 and b.size=4 then
			mcl.a:=a:=changeopndsize(a, 4)
			opcode:=m_mov
		fi
		recase else

	when m_movsx then
		if a.size=8 and b.size=4 then
			strcpy(opcname, "movsxd")
		else
			recase else
		fi

	when m_movd then
		if a.mode=a_xreg and b.mode=a_xreg then		!
			opcode:=m_movq
		fi

		recase else

    when m_mov then
        if a.mode=a_reg and b.mode=a_imm and b.valtype=intimm_val and b.value not in i32.bounds then
            mcl.opcode:=m_movq
        fi
		recase else

	when m_align then
		strcpy(opcname, ".align")
!		if currseg=zdata_seg then
!			strcpy(opcname, "alignb")
!		else
!			recase else
!		fi
	when m_resb then
		strcpy(opcname, ".space")

	when m_db then
		strcpy(opcname, ".byte")
	when m_dw then
		strcpy(opcname, ".word")
	when m_dd then
		strcpy(opcname, ".long")
	when m_dq then
		strcpy(opcname, ".quad")
	when m_ascii then
		strcpy(opcname, ".ascii")


	when m_endx then
		return

	ELSIF OPCODE>M_HALT THEN
		STRCPY(OPCNAME,STRINT(OPCODE))

	else
		strcpy(opcname,mclnames[opcode]+2)
	esac

	ipadstr(opcname,10," ")

	if not fasmformat then
		if a and b then
			fprint @str,"  #/#",a.size,b.size
		elsif a then
			fprint @str,"  #",a.size
		else
			strcpy(str,"  ")
		fi
	else
		strcpy(str,"  ")
	fi

	ipadstr(str,4)

	strcat(str,opcname)

	asmstr(str)

	if a and b then		!2 operands
		sizepref:=needsizeprefix(opcode,a,b)
!
		asmopnd(a,sizepref)
		asmstr(",	")
		asmopnd(b,sizepref)

		if mcl.c then
			asmstr(",")
			asmstr(strint(mcl.c))
		fi

!		ASMSTR("; ")
!		ASMSTR(strint(a.size))
!		ASMSTR(" ")
!		ASMSTR(strint(b.size))
!		ASMSTR(" #")
!		ASMSTR(STRINT(MCL.SEQNO))
!!
	elsif a and a.mode then								!1 operand
		if opcode=m_call then
			asmopnd(a,0,opcode)
		else
			asmopnd(a,1,opcode)
		fi
	fi

!ASMSTR("	#"); ASMSTR(STRINT(MCL.SEQNO))

end

global func strmclstr(ref mclrec m)ichar=
	gs_init(pdest)
	strmcl(m)
	return pdest.strptr
end

global func mstropnd(mclopnd a,int sizeprefix=0,opcode=0)ichar=
	static [512]char str
	[128]char str2
	ichar plus,t
	int offset,tc

	str[1]:=0

	case a.mode
	when a_reg then
		return strreg(a.reg, a.size)

	when a_imm then
		if opcode=m_dq and a.valtype=intimm_val then
			if a.value in 0..9 then
				strcat(str,strint(a.value))
			else
				strcat(str,"0x")
				strcat(str,strword(a.value,"H"))
			fi
		else
			strcpy(str,strvalue(a))
		fi

	when a_mem then
!		case a.valtype
!		when intimm_val then
!			strcpy(str,strint(a.value))
!		when realimm_val then
!			strcpy(str,strreal(a.xvalue))
!		when realmem_val then
!			fprint @str,"M#",a.xvalue
!		esac

		strcat(str,getsizeprefix(a.size,sizeprefix))
		strcat(str,"[")

		plus:=""
		if a.reg then
			strcat(str,strreg(a.reg,8))
			plus:=" + "
		fi
		if a.regix then
			strcat(str,plus)
			strcat(str,strreg(a.regix,8))
			plus:=" + "

			if a.scale>1 then
				strcat(str,"*")
				strcat(str,strint(a.scale))
			fi
		fi

		if a.valtype in [def_val,label_val, temp_val] then
			IF A.REG=A.REGIX=RNONE AND PHIGHMEM THEN
				STRCAT(STR, "%rip+")
			fi
			if plus^ then
				strcat(str,plus)
			fi
			strcat(str,strvalue(a))
	    elsif offset:=a.offset then
			print @str2,offset:" + "
			strcat(str,str2)
		fi
		strcat(str,"]")

	when a_xreg then
		return strxreg(a.reg,a.size)

	else
		println "BAD OPND",A.MODE
		return "<BAD OPND>"
	esac

	return str
end

global func strvalue(mclopnd a)ichar=
	static [512]char str
	[128]char str2
	psymbol def
	i64 value,offset,length
	ichar ss

	def:=a.def
	value:=a.value

	strcpy(str,"")

	case a.valtype
	when def_val then
		strcat(str,getdispname(def))

	addoffset:
		if offset:=a.offset then
			print @str2,(offset>0|"+"|""),,offset
			strcat(str,str2)
		fi

	when intimm_val then
		strcat(str,strint(value))

	when realimm_val then
		print @str,a.xvalue:"20.20"

	when realmem_val then
		strcat(str,"M")
		strcat(str,strreal(a.xvalue))

	when stringimm_val then
		strcat(str,"""")
		strcat(str,a.svalue)
		strcat(str,"""")

	when name_val then
		strcat(str,a.svalue)

	when label_val then
		strcat(str,"L")
		strcat(str,strint(a.labelno))
		goto addoffset

	when temp_val then
		return gettempname(currasmproc,a.tempno)

	else
		merror("Stropnd?")
	esac

	return str

end

global proc asmopnd(mclopnd a,int sizeprefix=0,opcode=0)=
	asmstr(mstropnd(a,sizeprefix,opcode))
end

global func getxregname(int reg,size=8)ichar=
	static [32]char str

	if reg=rnone then return "-" fi

!	if fasmformat then
		print @str,"%XMM",,reg-xr0
!	else
!		print @str,(size=8|"DX"|"SX"),,reg-xr0
!	fi
	return str
end

proc asmstr(ichar s)=
	gs_str(pdest,s)
end

proc asmchar(int c)=
	gs_char(pdest,c)
end

global func getdispname(psymbol d)ichar=
	static [256]char str

!	if d.reg then
!		fprint @str,"#.#","R", d.name
!		return str
!	fi
!
!	if fpshortnames then
!		return d.name
!	fi

	return getfullname(d)
!	strcpy(str, getfullname(d))
!	if d.id=static_id then
!!IF D.IMPORTED THEN CPL "STATIC", D.NAME, D.IMPORTED FI
!		strcat(str,".")
!	fi
!	return str
!	return "FULL"

end 

global func gettempname(psymbol d, int n)ichar=
	static [128]char str

!CPL "TEMP:", D.NAME,D.OFFSET

	if fpshortnames then
		print @str,"T",,n
	else
		fprint @str,"#.$T#",getdispname(d),n
	fi
	str
end

func strreg(int reg, size=8)ichar=
	static [16]char str

	strcpy(str, "%")
	strcat(str, nregnames[size, reg])

	str

!	nregnames[size, reg]
end

func strxreg(int reg, size=8)ichar=
	psymbol d

	d:=checkregvar(reg,1)

	if size=8 and d then
		return getdispname(d)
	else
		return getxregname(reg,size)
	fi
end

global func needsizeprefix(int opcode,mclopnd a,b)int=
	case opcode
	when m_movsx, m_movzx, m_cvtsi2ss, m_cvtsi2sd then
		return 1

	when m_cvtss2si,m_cvtsd2si, m_cvttss2si,m_cvttsd2si then
		return 1
	when m_shl, m_shr, m_sar then
		if a.mode=a_mem then return 1 fi
		return 0
	esac

	if a.mode=a_reg or a.mode=a_xreg or b.mode=a_reg or b.mode=a_xreg then
		return 0
	fi
	return 1
end

global func getsizeprefix(int size,enable=0)ichar=
	if not enable then return "" fi
	case size
	when 1 then return "byte ptr"
	when 2 then return "word ptr"
	when 4 then return "dword ptr"
	when 8 then return "qword ptr"
	esac
	return ""
end

func checkregvar(int reg, ispfloat)psymbol d=
	RETURN NIL
end

=== mc_writenasm.m 0 0 47/108 ===
!export int assemtype='NASM'

const fasmformat=1
!const fasmformat=0

export ichar asmext="nasm"

[8, r0..r15]ichar nregnames

byte currseg

global func getassemstr:ref strbuffer=
!write all mcl code in system by scanning all procs
!mcl code is only stored per-proc
	psymbol d,e
	ref mclrec m
	[32]char str2,str3
	int i

	gs_init(pdest)

	asmstr(";NASM VERSION\n")
	asmstr("    default rel\n")
	asmstr("    extern fmod\n")
	asmstr("    extern sin\n")
	asmstr("    extern cos\n")
	asmstr("    extern tan\n")
	asmstr("    extern asin\n")
	asmstr("    extern acos\n")
	asmstr("    extern atan\n")
	asmstr("    extern log\n")
	asmstr("    extern log10\n")
	asmstr("    extern exp\n")
	asmstr("    extern floor\n")
	asmstr("    extern ceil\n")
	asmstr("    extern pow\n")
	asmstr("    extern exit\n")
	asmstr("    extern __getmainargs\n")
!	asmstr("    global main\n")
	asmstr("\n")

!do globals and externs
	d:=psymboltable

	while d, d:=d.next do
		if d.imported then
			asmstr("    extern ")
			asmstr(d.name)
			asmstr("\n")
		fi
		if d.exported then
			asmstr("    global ")
			asmstr(getbasename(d.name))
			asmstr("\n")
		fi
	od
	asmstr("\n")

	m:=mccode
	i:=1
	while m do
		writemcl(i,m)
		++i
		m:=m.nextmcl
	od

	return pdest
end

proc writemcl(int index,ref mclrec mcl)=

!	case mcl.opcode
!	when m_deleted then
!	else
		strmcl(mcl)
		gs_line(pdest)
!	esac
end

proc start=
	byte flag

	assemtype:='NASM'

!initialise table of official gp reg names

	for i in 1..8 when i in [1,2,4,8] do
		for r in r0..r15 do
			flag:=0
			for k in dregnames.bounds do
				if flag then
					if regsizes[k]=i and regindices[k]=r then
						nregnames[i, r]:=dregnames[k]
					fi
				elsif regsizes[k]=0 then
					flag:=1
				fi
			od
		od
	od

end


global proc strmcl(ref mclrec mcl)=
	static [512]char str
	[128]char opcname
	mclopnd a,b
	int opcode,cond,sizepref
	ichar s,comment
	psymbol d

	opcode:=mcl.opcode


	cond:=mcl.cond
	a:=mcl.a
	b:=mcl.b
	comment:=nil

!CPL =MCLNAMES[OPCODE]

	case opcode
	when m_procstart then
		asmstr(";Proc ")
		asmstr(a.def.name)
		currasmproc:=a.def

		return

	when m_procend then
		asmstr(";End ")
		currasmproc:=nil

		return

	when m_comment then
		asmchar(';')
		asmstr(a.svalue)
		return

	when m_labelname then				!label name will be complete and will have colon(s)
		d:=a.def
		case a.valtype
		when def_val then
			asmstr(getdispname(d))
		when stringimm_val then
			asmstr(a.svalue)
			return
		else
			merror("strmcl/lab")
		esac

		asmstr(":")

		if d.exported then
			if eqstring(getbasename(d.name), d.name) then
!				asmstr(":")
			else
				asmstr("\n")
				asmstr(getbasename(d.name))
!				asmstr("::")
				asmstr(":")
			fi
		fi

		return

	when m_labelx then
		if a.valtype=label_val then
			fprint @str,"L#:",a.value
		else
			recase m_labelname
		fi
		asmstr(str)
		return

	when m_define then
		asmstr("    %define ")
		asmstr(a.svalue)
		asmstr(" ")
		asmopnd(b)
		return

	when m_definereg then
		d:=a.def
		asmstr("   %define ")
		asmstr(getdispname(d))
!		if ispfloat(d.mode) then
!			xregvars[d.reg]:=d
!		else
!			regvars[d.reg]:=d
!		fi

!		asmstr(" = ")
		asmstr(" ")

		case b.mode
		when a_reg then
			asmstr(strreg(b.reg, b.size))

		else
!			asmstr(getxregname(b.reg, b.size))
			asmstr(strxreg(b.reg, b.size))
		esac
		return

		return

	when m_csegment then asmstr("    segment .text"); currseg:=code_seg; return
	when m_isegment then asmstr("    segment .data"); currseg:=idata_seg; return
	when m_zsegment then asmstr("    segment .bss"); currseg:=zdata_seg; return

	esac

	case opcode
	when m_jmpcc then
		print @opcname,"j",,asmcondnames[cond]

	when m_setcc then
		print @opcname,"set",,asmcondnames[cond]

	when m_cmovcc then
		print @opcname,"cmov",,asmcondnames[cond]

	when m_andx then
		strcpy(opcname,"and")
	when m_orx then
		strcpy(opcname,"or")
	when m_xorx then
		strcpy(opcname,"xor")
	when m_notx then
		strcpy(opcname,"not")

	when m_imul2 then
		strcpy(opcname,"imul")

	when m_movzx then
		if a.size=8 and b.size=4 then
			mcl.a:=a:=changeopndsize(a, 4)
			opcode:=m_mov
		fi
		recase else

	when m_movsx then
		if a.size=8 and b.size=4 then
			strcpy(opcname, "movsxd")
		else
			recase else
		fi

	when m_movd then
		if a.mode=a_xreg and b.mode=a_xreg then		!
			opcode:=m_movq
		fi

		recase else

	when m_align then
		if currseg=zdata_seg then
			strcpy(opcname, "alignb")
		else
			recase else
		fi
	when m_endx then
		return

	when m_ascii then
		strcpy(opcname, "dq")

	ELSIF OPCODE>M_HALT THEN
		STRCPY(OPCNAME,STRINT(OPCODE))

	else
		strcpy(opcname,mclnames[opcode]+2)
	esac

	ipadstr(opcname,(opcode=m_dq|4|10)," ")

	if not fasmformat then
		if a and b then
			fprint @str,"  #/#",a.size,b.size
		elsif a then
			fprint @str,"  #",a.size
		else
			strcpy(str,"  ")
		fi
	else
		strcpy(str,"  ")
	fi

	ipadstr(str,4)

	strcat(str,opcname)

	asmstr(str)

	if a and b then		!2 operands
		sizepref:=needsizeprefix(opcode,a,b)
!
		asmopnd(a,sizepref)
		asmstr(",	")
		asmopnd(b,sizepref)

		if mcl.c then
			asmstr(",")
			asmstr(strint(mcl.c))
		fi

!		ASMSTR("; ")
!		ASMSTR(strint(a.size))
!		ASMSTR(" ")
!		ASMSTR(strint(b.size))
!		ASMSTR(" #")
!		ASMSTR(STRINT(MCL.SEQNO))
!!
	elsif a and a.mode then								!1 operand
		if opcode=m_call then
			asmopnd(a,0,opcode)
		else
			asmopnd(a,1,opcode)
		fi
	fi

!ASMSTR("	#"); ASMSTR(STRINT(MCL.SEQNO))

end

global func strmclstr(ref mclrec m)ichar=
	gs_init(pdest)
	strmcl(m)
	return pdest.strptr
end

global func mstropnd(mclopnd a,int sizeprefix=0,opcode=0)ichar=
	static [512]char str
	[128]char str2
	ichar plus,t
	int offset,tc

	str[1]:=0

	case a.mode
	when a_reg then
		return strreg(a.reg, a.size)

	when a_imm then
		if opcode=m_dq and a.valtype=intimm_val then
			if a.value in 0..9 then
				strcat(str,strint(a.value))
			else
				strcat(str,"0x")
				strcat(str,strword(a.value,"H"))
			fi
		else
			strcpy(str,strvalue(a))
		fi

	when a_mem then
		case a.valtype
		when intimm_val then
			strcpy(str,strint(a.value))
		when realimm_val then
			strcpy(str,strreal(a.xvalue))
		when realmem_val then
			fprint @str,"M#",a.xvalue
		esac

		strcat(str,getsizeprefix(a.size,sizeprefix))
		strcat(str,"[")

		plus:=""
		if a.reg then
			strcat(str,strreg(a.reg,8))
			plus:=" + "
		fi
		if a.regix then
			strcat(str,plus)
			strcat(str,strreg(a.regix,8))
			plus:=" + "

			if a.scale>1 then
				strcat(str,"*")
				strcat(str,strint(a.scale))
			fi
		fi

		if a.valtype in [def_val,label_val, temp_val] then
			if plus^ then
				strcat(str,plus)
			fi
			strcat(str,strvalue(a))
	    elsif offset:=a.offset then
			print @str2,offset:" + "
			strcat(str,str2)
		fi
		strcat(str,"]")

	when a_xreg then
		return strxreg(a.reg,a.size)

	else
		println "BAD OPND",A.MODE
		return "<BAD OPND>"
	esac

	return str
end

global func strvalue(mclopnd a)ichar=
	static [512]char str
	[128]char str2
	psymbol def
	i64 value,offset,length
	ichar ss

	def:=a.def
	value:=a.value

	strcpy(str,"")

	case a.valtype
	when def_val then
		strcat(str,getdispname(def))

	addoffset:
		if offset:=a.offset then
			print @str2,(offset>0|"+"|""),,offset
			strcat(str,str2)
		fi

	when intimm_val then
		strcat(str,strint(value))

	when realimm_val then
		print @str,a.xvalue:"20.20"

	when realmem_val then
		strcat(str,"M")
		strcat(str,strreal(a.xvalue))

	when stringimm_val then
		strcat(str,"""")
		strcat(str,a.svalue)
		strcat(str,"""")

	when name_val then
		strcat(str,a.svalue)

	when label_val then
		strcat(str,"L")
		strcat(str,strint(a.labelno))
		goto addoffset

	when temp_val then
		return gettempname(currasmproc,a.tempno)

	else
		merror("Stropnd?")
	esac

	return str

end

global proc asmopnd(mclopnd a,int sizeprefix=0,opcode=0)=
	asmstr(mstropnd(a,sizeprefix,opcode))
end

global func getxregname(int reg,size=8)ichar=
	static [32]char str

	if reg=rnone then return "-" fi

!	if fasmformat then
		print @str,"XMM",,reg-xr0
!	else
!		print @str,(size=8|"DX"|"SX"),,reg-xr0
!	fi
	return str
end

proc asmstr(ichar s)=
	gs_str(pdest,s)
end

proc asmchar(int c)=
	gs_char(pdest,c)
end

global func getdispname(psymbol d)ichar=
	static [256]char str

	if d.reg then
		fprint @str,"#.#","R", d.name
		return str
	fi

	if fpshortnames then
		return d.name
	fi

	return getfullname(d)
!	return "FULL"

end 

global func gettempname(psymbol d, int n)ichar=
	static [128]char str

	if fpshortnames then
		print @str,"T",,n
	else
		fprint @str,"#.$T#",getdispname(d),n
	fi
	str
end

func strreg(int reg, size=8)ichar=
	psymbol d

	nregnames[size, reg]
end

func strxreg(int reg, size=8)ichar=
	psymbol d

	d:=checkregvar(reg,1)

	if size=8 and d then
		return getdispname(d)
	else
		return getxregname(reg,size)
	fi
end

global func needsizeprefix(int opcode,mclopnd a,b)int=
	case opcode
	when m_movsx, m_movzx, m_cvtsi2ss, m_cvtsi2sd then
		return 1

	when m_cvtss2si,m_cvtsd2si, m_cvttss2si,m_cvttsd2si then
		return 1
	when m_shl, m_shr, m_sar then
		if a.mode=a_mem then return 1 fi
		return 0
	esac

	if a.mode=a_reg or a.mode=a_xreg or b.mode=a_reg or b.mode=a_xreg then
		return 0
	fi
	return 1
end

global func getsizeprefix(int size,enable=0)ichar=
	if not enable then return "" fi
	case size
	when 1 then return "byte "
	when 2 then return "word "
	when 4 then return "dword "
	when 8 then return "qword "
	esac
	return ""
end

func checkregvar(int reg, ispfloat)psymbol d=
	RETURN NIL
end

=== mc_writeobj.m 0 0 48/108 ===
!NEEDS REVISING TO MATCH UNLIMITED SS_SYMBOLTABLE size used for EXE
!and also unlimited strings

int symtaboffset

ref byte datastart
ref byte dataptr

[0..13'000]imagesymbol symboltable

int nsymbols

int stoffset=0				!usually +7 to convert ss_symboltable indices to symboltable

const maxstring=5000
[maxstring]ichar stringtable
[maxstring]int stringlengths
int nextstringoffset=0
int nstrings=0

global proc writecoff(ichar outfile)=
	imagefileheader header
	imagesectionheader zsection, isection, csection
	int offset
	i64 aa

	return when objdone

	clear header
	clear zsection
	clear isection
	clear csection

	header.machine:=0x8664
	header.nsections:=3

	strcpy(&zsection.name[1],".bss")
	zsection.rawdata_size:=ss_zdatalen

	zsection.characteristics:=0xC040'0080

	if ss_nidatarelocs>=65536 or ss_ncoderelocs>=65536 then
		axerror("Too many relocs (exceeds 16-bit field)")
	fi

	strcpy(&isection.name[1],".data")
	isection.rawdata_size:=bufferlength(ss_idata)
	isection.nrelocs:=ss_nidatarelocs

	isection.characteristics:=0xC050'0040

	strcpy(&csection.name[1],".text")
	csection.rawdata_size:=bufferlength(ss_code)
	csection.nrelocs:=ss_ncoderelocs

	csection.characteristics:=0x6050'0020

	initsymboltable(outfile)

	convertsymboltable()

	offset:=imagefileheader.bytes

	offset+:=imagesectionheader.bytes*3

	if isection.nrelocs then
		isection.relocations_ptr:=offset
		offset+:=isection.nrelocs*coffrelocrec.bytes
	fi

	if csection.nrelocs then
		csection.relocations_ptr:=offset
		offset+:=csection.nrelocs*coffrelocrec.bytes
	fi

	isection.rawdata_offset:=offset
	offset+:=isection.rawdata_size

	csection.rawdata_offset:=offset
	offset+:=csection.rawdata_size

!create symbol table and string table

	header.symtaboffset:=offset
	offset+:=nsymbols*imagesymbol.bytes
	header.nsymbols:=nsymbols

	offset+:=nextstringoffset

!Allocate data block in memory for coff image
	datastart:=dataptr:=malloc(offset)

	writerecord(&header,header.bytes)
	writerecord(&zsection,zsection.bytes)
	writerecord(&isection,isection.bytes)
	writerecord(&csection,csection.bytes)
	writerelocs(ss_idatarelocs,ss_nidatarelocs)
	writerelocs(ss_coderelocs,ss_ncoderelocs)

	writedata(ss_idata)
	writedata(ss_code)

	writesymboltable()

	writestringtable()

	if pverbose then
		println "Writing file:",outfile
	fi
	writefile(outfile,datastart,dataptr-datastart)

	objdone:=1

end

proc writerecord(ref void r, int length)=
	memcpy(dataptr,r,length)
	dataptr+:=length
end

proc writerelocs(ref relocrec r,int nrelocs)=
	static coffrelocrec s
	psymbol d

	return when nrelocs=0

	while r do
		case r.reloctype
		when addr32_rel, addr64_rel then		!change to section entry
			d:=ss_symboltable^[r.stindex]

			case d.segment
			when zdata_seg then s.stindex:=2
			when idata_seg then s.stindex:=4
			when code_seg then s.stindex:=6
			when 0 then							!external; leave stindex pointing to symbol
				s.stindex:=r.stindex+stoffset
			else
				axerror("wrelocs/bad seg")
			esac

		else
			s.stindex:=r.stindex+stoffset
		esac

		s.reloctype:=r.reloctype
		case phighmem
		when 0 then
		when 2 then
			IF R.RELOCTYPE=ADDR32_REL THEN
				S.RELOCTYPE:=REL32_REL
				R.RELOCTYPE:=REL32_REL
			FI
		else
			axerror("OBJ/phighmem 1?")
		esac

		s.virtualaddr:=r.offset


		memcpy(dataptr,&s,s.bytes)
		dataptr+:=s.bytes

		r:=r.nextreloc
	od
end

proc writedata(ref dbuffer data)=
	memcpy(dataptr, bufferelemptr(data,0), bufferlength(data))
	dataptr+:=bufferlength(data)
end

proc writesymboltable=
	int i
	for i:=1 to nsymbols do
		writerecord(&symboltable[i],imagesymbol.bytes)
	od
end

proc writestringtable=
!should immediately follow symboltable
	ref i32 p
	int i,n

	p:=cast(dataptr)
	p^:=nextstringoffset
	dataptr+:=4

	for i to nstrings do
		n:=stringlengths[i]+1
		memcpy(dataptr,stringtable[i],n)
		dataptr+:=n
	od
end

function makesymbol(ichar name, int value=0, sectionno=0,symtype=0,storage=0,naux=0)ref imagesymbol=
	static imagesymbol r
	int length, namelen

	namelen:=strlen(name)

	if namelen<8 then
		strcpy(&r.shortname[1],name)
	elsif namelen=8 then
		memcpy(&r.shortname[1],name,namelen)
	else
		r.shortx:=0
		r.longx:=addstringentry(name,namelen)
	fi
	r.value:=value
	r.sectionno:=sectionno
	r.symtype:=symtype
	r.storageclass:=storage
	r.nauxsymbols:=naux
	return &r
end

proc addsymbol(ref imagesymbol r)=
	if nsymbols>=symboltable.upb then
		axerror("as:Too many symbols")
	fi
	memcpy(&symboltable[++nsymbols],r,imagesymbol.bytes)

end

proc initsymboltable(ichar filename)=
!add first few special symbols to coff symboltable

	nsymbols:=0

	addsymbol(makesymbol(".file",storage:103, sectionno:-2,naux:1))
	addsymbol(strtoaux(filename))

	addsymbol(makesymbol(".bss", storage:3, sectionno:1, naux:1))
	addsymbol(cast(sectiontoaux(nil, 0)))

	addsymbol(makesymbol(".data", storage:3, sectionno:2, naux:1))
	addsymbol(cast(sectiontoaux(ss_idata, ss_nidatarelocs)))

	addsymbol(makesymbol(".text", storage:3, sectionno:3, naux:1))
	addsymbol(cast(sectiontoaux(ss_code, ss_ncoderelocs)))
end

function strtoaux(ref char s)ref imagesymbol=
!turn string s into 18-byte imagesymbol record
	static imagesymbol r
	ref byte p:=cast(&r)
	int n

	memset(p,0,r.bytes)
!	clear p^

	n:=0
	while s^<>0 and n<r.bytes do
		p++^:=s++^
		++n
	od

	return &r
end

function sectiontoaux(ref dbuffer data, int nrelocs)ref auxsectionrec=
!!turn segment into into aux section/reloc entry for symboltable
	static auxsectionrec r

	clear r

	if data=nil then			!zdata
		r.length:=ss_zdatalen
	else
		r.length:=bufferlength(data)

	fi
	r.nrelocs:=nrelocs
	return &r
end

function addstringentry(ichar s, int length)int=
!assume s is longer than 8 chars
!add string table entry, return offset to string, as it would be in the coff string table
!assume s in stable memory so doesn't need copying
	int offset

	offset:=nextstringoffset
	if nstrings>maxstring then
		axerror("W:too many strings")
	fi
	stringtable[++nstrings]:=pcm_copyheapstring(s)

	stringlengths[nstrings]:=length

	nextstringoffset+:=length+1

	return offset
end

proc convertsymboltable=
!scan ss_symboltable and generate coff symboltable equivalents
	psymbol s
	ichar name
	int i,sect, scope

	stoffset:=nsymbols-1

	nstrings:=0
	nextstringoffset:=4

	for i to ss_nsymbols do
		s:=ss_symboltable^[i]

		name:=s.name

		case s.segment
		when zdata_seg then sect:=1
		when idata_seg then sect:=2
		when code_seg then sect:=3
		else sect:=0
		esac

		IF S.IMPORTED THEN SECT:=0 FI

		SCOPE:=0
		if s.imported or s.exported then
			scope:=2
		else
			scope:=3
		fi

		if s.exported then
			name:=getbasename(name)
!		else
!			name:=getfullname(s)
		fi

		addsymbol(makesymbol(name, sectionno:sect, storage:scope, value:s.offset))

	od
end
=== mc_writess.m 0 0 49/108 ===

export function writessdata(int fexe)ref strbuffer=
	gs_init(pdest)
GS_STRLN(PDEST,"HELLO/SS")
	showssdata(fexe)

	gs_line(pdest)
	return pdest
end

proc showssdata(int fexe)=
	pclerror("SS not done") when not ssdone

	gs_strln(pdest,(fexe|"EXE FORMAT"|"AFTER GENSS"))

!	showsections()

	gs_line(pdest)

!	showsectionrelocs2("Idata",ss_idatarelocs,ss_nidatarelocs)
!	showsectionrelocs2("Code",ss_coderelocs,ss_ncoderelocs)

	gs_str(pdest,"proc Section Zdata: ")
	gs_strint(pdest,ss_zdatalen)
	gs_line(pdest)

	showsectiondata(&sectiontable[dsect])
	showsectioncode(&sectiontable[csect])
	if fexe then
		showsectiondata(&sectiontable[isect])
	fi

	showsymboltable2()
	showimporttable()
	gs_strln(pdest,"END OF GENSS")

end

proc showsectiondata(ref sectionrec d)=
int i,k,length,bb
	[128]char str,str2
	ref byte p

	gs_str(pdest,"proc Section ")
	gs_str(pdest,d.name)
	gs_str(pdest," Size:")
	gs_strint(pdest,d.virtsize)
	gs_line(pdest)
	gs_line(pdest)

	k:=0
	if d.segtype<>impdata_seg then
		p:=bufferelemptr(d.data,0)
	else
		p:=d.bytedata
	fi
	length:=d.virtsize

	str[1]:=0

	ref byte baseaddr:=cast(imagebase+d.virtoffset)

	print @str2,baseaddr:"Z8H",,": "

	gs_str(pdest,str2)

	for i:=1 to length do
		bb:=p++^
		print @str2,bb:"z2H",," "
		gs_str(pdest,str2)

		if 32<=bb<=127 then
			str2[1]:=bb
			str2[2]:=0
			strcat(str,str2)
		else
			strcat(str,".")
		fi
		if ++k=16 or i=length then
			if k<16 then
				to 16-k do
					gs_str(pdest,"   ")
					strcat(str," ")
				od
			fi
			gs_str(pdest,"	[")
			gs_str(pdest,str)
			gs_strln(pdest,"]")
			k:=0
			str[1]:=0
			baseaddr+:=16
			print @str2,baseaddr:"z8h",,": "
			gs_str(pdest,str2)
		fi
	od
	if k=0 then
		gs_line(pdest)
	fi

	gs_line(pdest)
	if k then gs_line(pdest) fi
end

proc showsectioncode(ref sectionrec p)=
ref byte codeptr,codeend,codestart
	int length,offset
	ichar s
	[16]char str

	gs_strln(pdest, "proc Section Code")

	length:=p.virtsize
	codestart:=codeptr:=bufferelemptr(p.data,0)
	codeend:=codeptr+length

	ref byte baseaddr:=cast(imagebase+p.virtoffset)

!INT TT:=CLOCK(), N:=0
	while codeptr<codeend do
		offset:=codeptr-codestart
		s:=decodeinstr(codeptr,baseaddr+offset)
!++N
		exit when s=nil

		print @str,offset:"4",," "
		gs_str(pdest,str)

		gs_strln(pdest,s)
	od
!TT:=CLOCK()-TT
!CPL "DECODE TIME:",TT,N
!OS_GETCH()
	gs_line(pdest)
end

proc showsectionrelocs2(ichar caption,ref relocrec relocs, int nrelocs)=
	ref relocrec r

	gs_str(pdest,"proc Section Relocs: ")
	gs_str(pdest,caption)
	gs_str(pdest," ")
	gs_strint(pdest,nrelocs)
	gs_line(pdest)

	r:=relocs

	while r do

		gs_str(pdest,"Reloc: ")
		gs_str(pdest,relocnames[r.reloctype])
		gs_str(pdest," Offset: ")
		gs_strint(pdest,r.offset)
		gs_str(pdest," ST Index: ")
		gs_strint(pdest,r.stindex)
		gs_str(pdest," ")
		gs_str(pdest,ss_symboltable[r.stindex].name)
		gs_line(pdest)

		r:=r.nextreloc
	od
	gs_line(pdest)

end

proc gs_value(ichar caption, i64 value)=
	[256]char str

	strcpy(str,caption)
	strcat(str,":")
	ipadstr(str,20)
	gs_str(pdest,str)

	fprint @str,"0x# #",value:"H",value
	gs_strln(pdest,str)
end

proc showsymboltable2=

	gs_strln(pdest,"Proc Symbol Table")
	int i
	for i:=1 to ss_nsymbols do
		gs_strint(pdest,i)
		gs_str(pdest,": ")
		gs_strln(pdest,ss_symboltable[i].name)
	od
	gs_line(pdest)
end

proc showimporttable=
	[256]char str
	dllrec d
	importrec p


	gs_strln(pdest,"Proc Dll List")
	int i
	for i:=1 to ndlls do
		gs_strint(pdest,i)
		gs_str(pdest,": ")
		gs_str(pdest,dlltable[i].name)
		gs_str(pdest," ")
		gs_strint(pdest,dlltable[i].nprocs)
		gs_line(pdest)
		gs_value("		Name Table Offset",dlltable[i].nametableoffset)
		gs_value("		Addr Table Offset",dlltable[i].addrtableoffset)
		gs_value("		DLL Name Offset  ",dlltable[i].dllnameoffset)
	od
	gs_line(pdest)
	gs_strln(pdest,"Proc Import List")

	for i:=1 to nimports do
		p:=importtable[i]

		gs_strint(pdest,i)
		gs_str(pdest,": ")
		if p.libno then
			strcpy(str,p.name)
			ipadstr(str,16)
			gs_str(pdest,str)
			gs_str(pdest," (")
			gs_str(pdest,dlltable[p.libno].name)
			gs_strln(pdest,")")

			gs_value("	IAT Offset        ",p.iatoffset)
			gs_value("	Thunk Offset      ",p.thunkoffset)
			gs_value("	Hint/Name Offset  ",p.hintnameoffset)

		else
			strcpy(str,p.name)
			ipadstr(str,20)
			gs_str(pdest,str)
			gs_strln(pdest," (---)")
		fi
	od
	gs_line(pdest)
end

proc showsections=
	sectionrec s
	int i

	gs_strln(pdest,"proc Section Headersxxx")
	gs_line(pdest)

	for i:=1 to nsections do
		s:=sectiontable[i]

		gs_str(pdest,"Section ")
		gs_strint(pdest,i)
		gs_str(pdest,": ")
		gs_str(pdest,s.name)
		gs_str(pdest,"  (")
		gs_str(pdest,segmentnames[s.segtype])
		gs_strln(pdest,")")

		gs_value("    Raw Offset",s.rawoffset)
		gs_value("    Raw Size",s.rawsize)
		gs_value("    Virtual Offset",s.virtoffset)
		gs_value("    Virtual Size",s.virtsize)
		gs_value("    Nrelocs",s.nrelocs)
		gs_value("    Data",int(s.data))
		gs_line(pdest)

	od
end

=== mx_decls.m 0 0 50/108 ===
!Declarations for M-Code scheme
!Terms:
! MCU		MCode Unit, binary code/data/imports/relocs for whole program (LIBREC)
! MCB		MCU rendered to flat data block, written out as .mx/.ml file
! MCX		MCU with allocations, imports and fixups done to make it ready to run
! LIB		Informal reference to MCU or MCX in-memory data; or to MX/ML file
!
! MCU is created from SS data (which normally was used to generate EXE)
! An MCU block is either converted to MCB which is then sent to an MX/ML file;
! or it is directly fixed up into MCX to allow immediate execution
!
! MCB can be read from a file into a memory block. MCB data contains a lineat
! set of tagged data blocks. Those blocks are scanned to form a normal MCU/LIBREC
! data-structure. That MCU can be fixed up like above to make it ready to be
! run or any function to be called.


!single byte tags in mcx file

export const mcxsig = 'MCX\x1A'

export enumdata [0:]ichar mcxdirnames =
	(pad_dir = 0,		$),		! nothing follows except next tag; for padding/alignment
	(version_dir,		$),		! STR string follows with version code (stringz)
	(code_dir,			$),		! N(u32) then N bytes of code data
	(idata_dir,			$),		! N(u32) then N bytes init data
	(zdata_dir,			$),		! N(u32) (no data follows)
	(reloc_dir,			$),		! N(u32) then N records follow
	(dlls_dir,			$),		! N(u32) then N STR items, the DLL base names
	(libs_dir,			$),		! N(u32) then N STR items, the MCX base names (ML libs)
	(importsymbols_dir,	$),		! N(u32) then N STR items, the imported names
	(exportsymbols_dir,	$),		! N(u32) then N STR items, the exported names
	(exportsegs_dir,	$),		! N(u32) then N u8 items, each is a segment code
	(exportoffsets_dir,	$),		! N(u32) then N u32 items, each an offset in the segment
	(entry_dir,			$),		! N(u32) N is a byte offset within code segment for entry point
	(end_dir,			$),		! nothing follows; end of file
end

!Reloc item record
! For Locabs-codes, the field contains the offset of the local symbol within target segment
! For Imp-codes, the field contains zero bytes

export record mcxreloc =
	u32		offset			! Offset with .segment of the reloc item
	union
		u16		stindex			! For Imp-codes, index into global import tables
		byte	targetsegment	! For Loc-codes, target segment refered to
	end
	byte	segment			! Segment containing the reloc item
	byte	reloctype		! Reloc code (see enums); also sets size of reloc item
end



!Relocation codes

export enumdata [0:]ichar mcxrelocnames =
	(no_rel = 0,		$),

	(locabs32_rel,	"locabs32"),		! add target segment address to 32-bit offset
	(locabs64_rel,	"locabs64"),		! add target segment address to 64-bit offset

	(impabs32_rel,	"impabs32"),		! replace 32-bit 0-field with address of imported symbol
	(impabs64_rel,	"impabs64"),		! replace 64-bit 0-field with address of imported symbol

	(imprel32_rel,	"imprel32"),		! replace 32-bit 0-field with offset of thunk entry for symbol
end

! Explanation of reloc codes
! No reloc
!	For local call/jmp, which are /only/ within code segment, no fixups are needed
!
! Locabs32/Locabs64
!	Reloc field contains offset of location within target segment, plus any
!   constant offset (eg. A+3 has offset of A, plus 3)
!   Baseaddr of that segment is added to that offset
!
! Impabs32/64
!	Reloc field contains any local offset (eg. the 3 in A+3)
!	Symbol index is used (via xlate to global index) to get abs address of symbol
!   Reloc field is replaced with 32/64 bits of that address plus the original value
!
! Imprel32
!	Only used for imported names, and only for CALL. Reloc field may be zeros
!	Reloc field will be changed to relative offset thunk table at end of code segment
!	Thunk table (indexed by local import index), is populated with JMPs to values
!	stored in address table which follows immediately
!	That address table needs to be populated with abs addresses of those imports
!	(Calls to LIB rather than DLL can have CALL offset replaced with direct offset to the
!	imported function, provided top 31 bits of address are zero.)

!export enumdata []ichar segmentnames =
!	(code_seg,		"code"),
!	(idata_seg,		"idata"),
!	(zdata_seg,		"zdata"),
!	(rodata_seg,	"rodata"),
!	(impdata_seg,	$),
!end

!Describe an MCX program loaded into memory


export record librec=
!The first section describes data residing in a file and loaded into these vars
!(code block is loaded directly into an actual executable block, with thunk/
!address table space added)

	ichar version

	int codesize			! bytes in code block, excluding thunk/addr tables
	int idatasize			! bytes in idata block
	int zdatasize			! bytes in zdata block (no data; created on fixup)

	int nrelocs				! size of reloctable
	int	ndlllibs			! size of imported dll names
	int	nlibs				! size of imported libnames
	int nimports			! size of imports/importlib tables
	int nexports			! size of exports/exportsegs/exportoffsets tables

	ref byte codeptr		! executable code block (includes thunk/addr table)
	ref byte idataptr		! initialised data block

	ref[]mcxreloc	reloctable		! table of reloc entries
	ref[]ichar		dllnames		! base names of imported dll files (no extension)
	ref[]ichar		libnames		! base names of imported mcx files (no extension)
	ref[]ichar		importnames		! names of imported symbols
	ref[]ichar		exports			! names of exported symbols
	ref[]byte		exportsegs		! segment where each is located
	ref[]u64		exportoffsets	! offsets within each segment

	u64 entryoffset					! offset within code block where execution will start
									! value of 0xFFFFFFFF (is u32 in file) means not set

!The next section is filled in after loading

	ref byte zdataptr				! zeroed data block
	int codexsize					! bytes in thunk/addr tables that follow code
	ref[]u64		exportaddr		! fully fixed-up addresses of exported symbols (not in file)
	ref[]i16		importxreftable	! map symbol index to global one

	ichar			filespec		!full path
	ichar			libname			!base name of library
	ref byte		entryaddr		!start address (left at nil when entryoffset not set)
	int				libno			!index of this entry in progtable
end

global const maxdlls =		20
global const maxlibs =		20
global const maxsymbols =	3000

!Global DLL tables

global [maxdlls]ichar		dllnametable
global [maxdlls]u64			dllinsttable
global int ndlllibs

!Global Prog table

global [maxlibs]ichar		libnametable
global [maxlibs]ref librec	libtable
global [maxlibs]byte		librelocated		!1 when relocated
global [maxlibs]byte		libinitdone			!1 when entry point called
global int nlibs

!Global import tables

global [maxsymbols]ichar	symbolnametable	! Name of symbol
global [maxsymbols]byte		symboldefined	! 1 when fully resolved with address
global [maxsymbols]ref void	symboladdress	! Abs address
global [maxsymbols]i16	symbollibindex	! Lib index where defined
global [maxsymbols]byte		symboldllindex	! DLL index of library where found
global int nsymbols

export int nsymimports=0, nsymexports=0
=== mx_lib.m 0 0 51/108 ===
global enumdata [0:]ichar rsegmentnames =
	(no_seg=0,		$),
	(code_rseg,		$),
	(idata_rseg,		$),
	(zdata_rseg,		$),
	(rodata_rseg,	$),
	(impdata_rseg,	$),
end

global func readlibfile(ichar filespec, ref byte p)ref librec plib=
!p points to an MCB block; scan that into an MCU descriptor (librec)

	librec lib
	u64 sig
	int dir,n,tablesize
	ref byte q

	clear lib

	sig:=readu32(p)
	if sig<>mcxsig then
		println "Bad sig - not MCX file"
		stop 1
	fi

	lib.filespec:=pcm_copyheapstring(filespec)
	lib.libname:=pcm_copyheapstring(extractbasefile(filespec))

	doswitch dir:=readbyte(p)
	when version_dir then
		lib.version:=readstring(p)

	when zdata_dir then
		lib.zdatasize:=readu32(p)
!		lib.zdataptr:=pcm_allocz(lib.zdatasize)

	when idata_dir then
		lib.idatasize:=n:=readu32(p)
		lib.idataptr:=pcm_alloc(n)
		memcpy(lib.idataptr, p, n)	
		p+:=n

	when code_dir then
		lib.codesize:=n:=readu32(p)
		lib.codeptr:=p				!for now, point into file image
		p+:=n

	when dlls_dir then
		lib.ndlllibs:=n:=readu32(p)
		lib.dllnames:=pcm_alloc(ichar.bytes*n)
		for i to n do
			lib.dllnames[i]:=readstring(p)
		od

	when libs_dir then
		lib.nlibs:=n:=readu32(p)
		lib.libnames:=pcm_alloc(ichar.bytes*n)
		for i to n do
			lib.libnames[i]:=readstring(p)
		od
	when importsymbols_dir then
		lib.nimports:=n:=readu32(p)
		lib.importnames:=pcm_alloc(ichar.bytes*n)
		for i to n do
			lib.importnames[i]:=readstring(p)
		od

	when exportsymbols_dir then
		lib.nexports:=n:=readu32(p)
		lib.exports:=pcm_alloc(ichar.bytes*n)
		for i to n do
			lib.exports[i]:=readstring(p)
		od

	when exportsegs_dir then
		n:=readu32(p)
		lib.exportsegs:=pcm_alloc(n)
		for i to n do
			lib.exportsegs[i]:=readbyte(p)
		od

	when exportoffsets_dir then
		n:=readu32(p)
		lib.exportoffsets:=pcm_alloc(u64.bytes*n)
		for i to n do
			lib.exportoffsets[i]:=readu32(p)
		od

	when reloc_dir then
		lib.nrelocs:=n:=readu32(p)
		n:=lib.nrelocs*mcxreloc.bytes
		lib.reloctable:=pcm_alloc(n)
		memcpy(lib.reloctable, p, n)
		p+:=n

	when entry_dir then
		lib.entryoffset:=readu32(p)

	when end_dir then
		exit

	when pad_dir then

	else
		println "Unknown directive:",mcxdirnames[dir]
		stop
	end doswitch

	plib:=pcm_allocnfz(librec.bytes)
	memcpy(plib, &lib, librec.bytes)	

	return plib
end

func readbyte(ref byte &p)int=
	return p++^
end
!
func readu32(ref byte &p)u64 x=
	x:=ref u32(p)^
	p+:=4
	x
end

func readstring(ref byte &p)ichar s=
	s:=pcm_copyheapstring(p)

	while (++p)^ do od
	++p

	return s
end

global proc alloclibdata(ref librec lib)=
	int tablesize, n
	ref byte p

	lib.zdataptr:=pcm_allocz(lib.zdatasize)
!CPL "RUN/MX: NO ALLOCZ"
!	lib.zdataptr:=pcm_alloc(lib.zdatasize)

	tablesize:=lib.nimports*16			!add in thunk table+address table
	n:=lib.codesize

	p:=os_allocexecmem(n+tablesize)		!MUST BE EXECUTABLE MEMORY
	if p=nil then
		error("Can't alloc code memory")
	fi
	memcpy(p, lib.codeptr, n)

	memset(p+n, 0, tablesize)
!	memset(p+n, 0xAA, tablesize)

	lib.codeptr:=p
	lib.codexsize:=tablesize

	lib.exportaddr:=pcm_alloc(u64.bytes*lib.nexports)
	lib.importxreftable:=pcm_alloc(i16.bytes*lib.nimports)

	if lib.entryoffset<>0xFFFF'FFFF then
		lib.entryaddr:=lib.codeptr+lib.entryoffset
	fi
end

global proc error(ichar mess, param="")=
	if param^ then
		fprintln mess,param
	else
		println mess
	fi
	println "Aborting"
	stop 1
end

global proc loadmemmcu(ref librec lib)=
!load mcu into lib tables and load any dependencies

	int newlib
	ichar name:=lib.libname

	checknew(name,lib.filespec)

	newlib:=mxaddlib(name)
	libtable[newlib]:=lib

	loadimports(lib)
end

global proc checknew(ichar name, filename)=
	if findlib(name) then
		error("Lib already exists:",filename)
	fi
end

global func findlib(ichar name)int n=
!find an existing library existing

	for i to nlibs do
		if eqstring(name,libnametable[i]) then return i fi
	od
	return 0
end

global func mxaddlib(ichar name)int n=
!add a new lib slot with given name
	if nlibs>=maxlibs then 
		error("Too many libs")
	fi

	libnametable[++nlibs]:=name
	return nlibs
end

!export proc fixuplib(ref librec lib)=
global proc fixuplib(ref librec lib)=
!do second fixup pass, which is done across global symbols, but then 
!all relocs are done for all libs which are not yet relocated

	loaddlls()				!global
	checksymbols()			!global
	dorelocations()			!all libs
end

proc loaddlls=
!load all dll instances
	u64 inst

	for i to ndlllibs when not dllinsttable[i] do
		inst:=os_getdllinst(dllnametable[i])
		if inst=0 then
			error("Can't find DLL: #", dllnametable[i])
		fi
		dllinsttable[i]:=inst
    od
end

func finddllsymbol(ichar name, int &dllindex)ref void p=
!look up symbol in any of the DLLs
!return address, or void if not found
!dllindex is set to dll where it was found

	dllindex:=0
	for i to ndlllibs do
		p:=os_getdllprocaddr(dllinsttable[i], name)
		if p then
			dllindex:=i
			return p
		fi
	od

	return nil
end

proc checksymbols=
	int dllindex,undef:=0
	ref void p

	for i to nsymbols when not symboldefined[i] do
		p:=finddllsymbol(symbolnametable[i], dllindex)
		if p then
			symboladdress[i]:=p
			symboldllindex[i]:=dllindex
			symboldefined[i]:=1
		else
			println "Undef",symbolnametable[i]
			++undef
		fi
	od

	if undef then
!		error("Symbols Undefined")
	fi
end

proc dorelocations=
	for i to nlibs when not librelocated[i] do
		reloclib(libtable[i])
	od
end

proc reloclib(ref librec lib)=
	int index, targetoffset
	ichar name
	ref byte p
	ref byte q
	ref u64 qaddr		!to import address table
	mcxreloc r

!do thunk tables first
	p:=lib.codeptr+lib.codesize
	qaddr:=cast(p+lib.nimports*u64.bytes)

	for i to lib.nimports do
		name:=lib.importnames[i]
		p++^:=0x48
		p++^:=0xFF
		p++^:=0x24
		p++^:=0x25
		(ref u32(p)^:=cast(qaddr))
		p+:=4

		index:=lib.importxreftable[i]
		qaddr++^:=cast(symboladdress[index])

	od

!Now do the actual relocations
	for i to lib.nrelocs do
		r:=lib.reloctable[i]
		case r.segment
		when code_rseg then p:=lib.codeptr+r.offset
		when idata_rseg then p:=lib.idataptr+r.offset
		when zdata_rseg then p:=lib.zdataptr+r.offset
		esac

		case r.reloctype
		when locabs32_rel then
			targetoffset:=ref u32(p)^
			case r.targetsegment
			when code_rseg then
				(ref u32(p)^ := cast(lib.codeptr+targetoffset))
			when idata_rseg then
				(ref u32(p)^ := cast(lib.idataptr+targetoffset))
			when zdata_rseg then
				(ref u32(p)^ := cast(lib.zdataptr+targetoffset))
			esac

		when locabs64_rel then
			targetoffset:=ref u32(p)^
			case r.targetsegment
			when code_rseg then
				(ref u64(p)^ := cast(lib.codeptr+targetoffset))
			when idata_rseg then
				(ref u64(p)^ := cast(lib.idataptr+targetoffset))
			when zdata_rseg then
				(ref u64(p)^ := cast(lib.zdataptr+targetoffset))
			esac

		when impabs64_rel then

			index:=lib.importxreftable[r.stindex]			!global index
			(ref u64(p)^+:=cast(symboladdress[index],u64))

		when impabs32_rel then
			index:=lib.importxreftable[r.stindex]			!global index
			(ref u32(p)^+:=cast(symboladdress[index],u64))

		when imprel32_rel then
			if r.segment<>code_rseg then error("imprel32?") fi
			index:=r.stindex								!local index
			q:=lib.codeptr+lib.codesize+(index-1)*8

			(ref u32(p)^ := q-(p+4))	!offset to thunk entry
		esac

	od

	librelocated[lib.libno]:=1

end

global proc loadimports(ref librec plib)=
! load imported libs
! do first fixup pass which sets up tables adds imports/exports to global table
! This is done per libs and can be called on imported sub-libs

	ref librec qlib
	ichar name

	for i to plib.nlibs do
		dosublib(plib.libnames[i])
	od

	alloclibdata(plib)
	dosymbols(plib)
end

proc dosublib(ichar name)=
	ref librec qlib
	int n:=findlib(name)

	if not n then									!not already loaded
		n:=mxaddlib(name)
		println "Loading sublib", name
		qlib:=loadlibfile(addext(name,"ml"),n)		!get mcu
		loadimports(qlib)						!recursive call
	fi
end

global func loadlibfile(ichar filename, int libno)ref librec plib=
!read mcb file into memory, process it into a new librec
	ref byte p

	p:=readmxfile(filename)
	if p=nil then
		error("Can't find #",filename)
	fi

	plib:=readlibfile(filename,p)
	plib.libno:=libno
	libtable[libno]:=plib	
end

proc dosymbols(ref librec lib)=
!Add any dll libs to global table (libs already done)
!Then deal with imported and exported symbols

	int ix, libx, dllx
	ref byte baseaddr

	for i to lib.ndlllibs do
		adddll(lib.dllnames[i])
	od

	for i to lib.nimports do
		ix:=addsymbol(lib.importnames[i])
		lib.importxreftable[i]:=ix
	od

	for i to lib.nexports do
		ix:=addsymbol(lib.exports[i])
		if symboldefined[ix] then
			CPL "Dupl symbol:",lib.exports[i]
			NEXTLOOP
		fi
		symboldefined[ix]:=1

		case lib.exportsegs[i]
		when code_rseg then baseaddr:=lib.codeptr
		when idata_rseg then baseaddr:=lib.idataptr
		when zdata_rseg then baseaddr:=lib.zdataptr
		else baseaddr:=nil
		esac

		symboladdress[ix]:=cast(baseaddr+lib.exportoffsets[i])
		symbollibindex[ix]:=lib.libno

	od
end

func readmxfile(ichar filename)ref byte p=
!read in mx/ml file into an mcb block, add end_dir byte at the end just in case
!return pointer to mcb block

	p:=readfile(filename)
	return nil when p=nil
	(p+rfsize)^:=end_dir		!add eof-marker

	return p
end

proc adddll(ichar name)=
	for i to ndlllibs do
		if eqstring(name,dllnametable[i]) then return fi
	od

	if ndlllibs>=maxdlls then 
		error("Too many DLLs")
	fi

	dllnametable[++ndlllibs]:=name
end

func addsymbol(ichar name)int=
	for i to nsymbols do
		if eqstring(name,symbolnametable[i]) then return i fi
	od

	if nsymbols>=maxsymbols then 
		error("Too many Imports")
	fi

	symbolnametable[++nsymbols]:=name
	return nsymbols
end

proc setspecialglobals(int cmdskip)=
!adjust cmdparams visible to application by setting $cmdskip flag
!	for i to nsymbols when symbolnametable[i]^='$' do
	for i to nsymbols do
!CPL =NSYMBOLS, SYMBOLNAMETABLE[I]

		if eqstring(symbolnametable[i],"msys.$cmdskip") or
			eqstring(symbolnametable[i],"$cmdskip") then
!CPL "FOUND $CMDSKIP"

			(ref byte(symboladdress[i])^:=cmdskip)
!			(ref byte(symboladdress[i])^:=0)
		fi
	od
end

global proc runprogram(ref librec lib, int cmdskip=0)=
	ref proc fnptr
	int libno:=lib.libno

	for i to nlibs when i<>libno and not libinitdone[i] do
		calllibinit(libtable[i])
	od

	if lib.entryaddr=nil then
		error("No entry point found")
	fi

	setspecialglobals(cmdskip)

	fnptr:=cast(lib.entryaddr)

	fnptr()

	libinitdone[libno]:=1
end

global proc calllibinit(ref librec lib)=
	ref proc fnptr
	int libno:=lib.libno

	if lib.entryaddr then
		fnptr:=cast(lib.entryaddr)
		fnptr()
	fi
	libinitdone[lib.libno]:=1
end

global func findsymbol(ichar name)ref void=

	for i to nsymbols do
		if eqstring(symbolnametable[i], name) then
			return symboladdress[i]
		fi
	od
	return nil
end

global func loadmx(ichar filename)ref librec plib=
!load mx/ml into mcu then scan for other imported libraries
	int newlib
	ichar name

	name:=pcm_copyheapstring(convlcstring(extractbasefile(filename)))
	checknew(name,filename)

	newlib:=mxaddlib(name)

	plib:=loadlibfile(filename,newlib)

	loadimports(plib)
	return plib
end

global func loadmemmcb(ichar filename, ref byte p)ref librec plib=
!read from mcb block in memory
!'filename' is just an identifying string

	int newlib
	ichar name

	name:=pcm_copyheapstring(convlcstring(extractbasefile(filename)))
	checknew(name,filename)

	newlib:=mxaddlib(name)
	plib:=readlibfile(filename,p)
	plib.libno:=newlib
	libtable[newlib]:=plib	

	loadimports(plib)
	return plib
end

=== mx_run.m 0 0 52/108 ===
!Translate SS data directly into MCU block, then try and run that

global func writememlib(ichar filename)ref librec plib=
!write ss to mcu
	int n, k
	librec lib

	clear lib

	ss_zdatalen:=roundtoblock(ss_zdatalen, 8)

	roundsegment(ss_code,8,0x90)
	roundsegment(ss_idata,8,0)

	lib.version:="0.1234"

	lib.filespec:=filename
	lib.libname:=pcm_copyheapstring(extractbasefile(filename))
	lib.libno:=1

	countsymbols()
	writerelocs(&lib)

	lib.zdatasize:=ss_zdatalen
	lib.codesize:=bufferlength(ss_code)
	lib.idatasize:=bufferlength(ss_idata)

	lib.codeptr:=bufferelemptr(ss_code,0)
	lib.idataptr:=bufferelemptr(ss_idata,0)

	int ndlls:=0, nlibs:=0
	for i to nplibfiles when plibfiles[i]^<>'$' do
!		if libtypes[i]='D' then ++ndlls else ++nlibs fi
		++ndlls
	od

	lib.ndlllibs:=ndlls
	lib.nlibs:=nlibs

	lib.dllnames:=pcm_alloc(ichar.bytes*ndlls)
	lib.libnames:=pcm_alloc(ichar.bytes*nlibs)

	k:=0
!	for i to nlibfiles when libfiles[i]^<>'$' and libtypes[i]='D' do
	for i to nplibfiles when plibfiles[i]^<>'$' do
		lib.dllnames[++k]:=plibfiles[i]
	od

!	k:=0
!	for i to nlibfiles when libfiles[i]^<>'$' and libtypes[i]='L' do
!		lib.libnames[++k]:=libfiles[i]
!	od

	addsymbols(&lib)
	plib:=pcm_allocnfz(librec.bytes)
	memcpy(plib, &lib, librec.bytes)	

	return plib
end

proc roundsegment(ref dbuffer p, int align, value)=
	int length:=bufferlength(p)
	int newlength:=roundtoblock(length, align)

	buffercheck(p, align)

	to newlength-length do
		p.pcurr++^:=value
	od
end

proc writerelocs(ref librec lib)=
	ref relocrec oldr
	mcxreloc newr
	int n, k
	psymbol d
	ref u64 baseptr64
	ref u32 baseptr32@baseptr64

	lib.nrelocs:=ss_nidatarelocs+ss_ncoderelocs
	lib.reloctable:=pcm_alloc(lib.nrelocs*mcxreloc.bytes)

	k:=0

	for i in code_seg..idata_seg do
		oldr:=(i=code_seg|ss_idatarelocs|ss_coderelocs)

		while oldr, oldr:=oldr.nextreloc do
			clear newr

			newr.offset:=oldr.offset
			newr.segment:=(i=code_seg|idata_seg|code_seg)

			d:=ss_symboltable[oldr.stindex]

			case oldr.reloctype
			when rel32_rel then
				if d.imported then
					newr.stindex:=d.impindex
					newr.reloctype:=imprel32_rel
				else
					axerror("rel32/rel not imported")
				fi
			when addr32_rel, addr64_rel then
				if d.imported then
					newr.reloctype:=(oldr.reloctype=addr32_rel|impabs32_rel|impabs64_rel)
					newr.stindex:=d.impindex
				else
					if oldr.reloctype=addr32_rel then
						newr.reloctype:=locabs32_rel
					else
						newr.reloctype:=locabs64_rel
					fi
					newr.targetsegment:=d.segment
				fi
			else
				axerror("reloc?")
			esac

			lib.reloctable[++k]:=newr

		od
	od
end

proc addsymbols(ref librec lib)=
	psymbol d, stentry:=nil
	u64 epoffset:=-1
	int n, k
	ichar name


	lib.nimports:=nsymimports
	lib.nexports:=nsymexports
	lib.importnames:=pcm_alloc(nsymimports*ichar.bytes)
	lib.exports:=pcm_alloc(nsymexports*ichar.bytes)
	lib.exportsegs:=pcm_alloc(nsymexports)
	lib.exportoffsets:=pcm_alloc(nsymexports*u64.bytes)

	k:=0
	for i to ss_nsymbols when ss_symboltable[i].impindex do
		d:=ss_symboltable[i]
		lib.importnames[++k]:=d.name
	od

	k:=0
	for i to ss_nsymbols do
		d:=ss_symboltable[i]
!CPL =D.NAME, =D.EXPINDEX, =D.ISENTRY
		if d.expindex then
			if d.isentry then
				stentry:=d
			fi
			lib.exports[++k]:=d.name
			lib.exportsegs[k]:=d.segment
			lib.exportoffsets[k]:=d.offset
		fi
	od

!CPL =STENTRY

	if stentry then
		lib.entryoffset:=stentry.offset
	else
CPL "NO MAIN FOUND"
		lib.entryoffset:=-1
	fi
end

global proc countsymbols=
	psymbol d
	for i:=1 to ss_nsymbols do
		d:=ss_symboltable[i]
		if d.exported then d.expindex:=++nsymexports fi
		if d.imported then d.impindex:=++nsymimports fi
	od
end

global proc runlibfile(ichar filename, int cmdskip)=
!LOADERROR("RUNLIBFILE")

	ref librec plib

	plib:=writememlib(filename)

	loadmemmcu(plib)
	fixuplib(plib)

!	if fshowmx then
!		LOADERROR("SHOWMX missing")
!!		initlogfile()
!!		showlibs()
!!		closelogfile()
!	else
		runprogram(plib, cmdskip)
!	fi
end

=== mx_show.m 0 0 53/108 ===
int logdest=2

const logfile="rx.log"

ref void logdev		!dest for diagnostics and output of tables

strbuffer destv
ref strbuffer dest=&destv

global proc initlogfile=
	case logdest
	when 2 then
		remove(logfile)
		logdev:=cast(fopen(logfile,"w"))
	when 0,1 then
		logdev:=nil
	esac

end

global proc closelogfile=
	[512]char str

	if logdest=2 then
		fclose(logdev)

		print @&.str,f"\m\ed.bat",logfile

!		os_execwait(&.str,1,nil)
		os_execwait(&.str,0,nil)
	fi
end

global proc showlibs=
!show details of all libs, plus the global data
	showglobals(logdev)

	for i to nlibs do
!	for i to nlibs when libdefined[i] do
		showlib(libtable[i], logdev)
	od
end

global proc showlib(ref librec lib, filehandle logdev)=
	[300]char str
	u64 sig
	int dir,n
	ref byte q
	ref[]ichar names

	gs_init(dest)

	showstrln("-------------------------")
	showstr("LIBFILE: ")
	showstr(lib.libname)
	showstr(" ")
	showstrln(lib.filespec)

	print @str,"Version:",lib.version
	showstrln(str)

	showstrln("")

	fprint @str,"Zdata size: # #", lib.zdatasize, lib.zdataptr
	showstrln(str)

	fprint @str,"Idata size: # #", lib.idatasize, lib.idataptr
	showstrln(str)

	showsectiondata(lib.idataptr, lib.idatasize)

	fprint @str,"Code size: # # Extra:#", lib.codesize, lib.codeptr, lib.codexsize
	showstrln(str)
	showsectioncode(lib.codeptr, lib.codesize,lib.codexsize)
	showrelocs(lib)

	fprint @str,"DLL Libs #", n:=lib.ndlllibs
	showstrln(str)
	shownames(lib.dllnames,n)
	showstrln("")

	fprint @str,"Libs #", n:=lib.nlibs
	showstrln(str)
	shownames(lib.libnames,n)
	showstrln("")

	fprint @str,"Imports #", n:=lib.nimports
	showstrln(str)
	names:=lib.importnames
	for i to n do
		fprint @str,"   #: #", i, names[i]:"20jl"
		showstrln(str)
	od
	showstrln("")
!	shownames(lib.imports,n)

	fprint @str,"Exports #", n:=lib.nexports
	showstrln(str)
	names:=lib.exports
	showstrln("     Name                 Seg      Offset")
	showstrln("--------------------------------------------")

	for i to n do
		fprint @str,"#: # # #",
			i:"3", names[i]:"20jl",
			rsegmentnames[lib.exportsegs[i]]:"8jl",
			lib.exportoffsets[i]:"8zh"
		showstrln(str)
	od
	showstrln("")


	fprint @str,"Entry point offset:  #",lib.entryoffset
	showstrln(str)
	fprint @str,"Entry point address: #",lib.entryaddr
	showstrln(str)
	showstrln("")

FINISH:

	gs_println(dest,logdev)
end

proc showstr(ichar str)=
	gs_str(dest, str)
end

proc showstrln(ichar str)=
	gs_strln(dest, str)
end

proc showstrint(int a)=
	gs_strint(dest, a)
end

proc shownames(ref[]ichar names, int n)=
	[300]char str
	for i to n do
		fprint @str,"   #: #", i, names[i]
		showstrln(str)
	od
end

proc showrelocs(ref librec lib)=
	[300]char str
	mcxreloc r
	int n:=lib.nrelocs, m
	u64 targetoffset
	ref u64 baseptr64
	ref u32 baseptr32@baseptr64

	fprint @str,"Relocs #", n:=lib.nrelocs
	showstrln(str)

	showstrln("     Type       Seg      Offset    Symbol/Target+Offset")
	showstrln("---------------------------------------------------------")

	for i to n do
		r:=lib.reloctable[i]
		fprint @str,"#: # # ##",
			i:"3", mcxrelocnames[r.reloctype]:"10jl",
			rsegmentnames[r.segment]:"8jl",
			r.offset:"8zh",,"  "

		m:=strlen(str)
		case r.reloctype
		when locabs32_rel, locabs64_rel then
			case r.segment
			when code_rseg then baseptr64:=cast(lib.codeptr+r.offset)
			when idata_rseg then baseptr64:=cast(lib.idataptr+r.offset)
			esac
			if r.reloctype=locabs32_rel then
				targetoffset:=baseptr32^
			else
				targetoffset:=baseptr64^
			fi

			print @&.str+m, rsegmentnames[r.targetsegment]:"6jlt:",,targetoffset:"8zh"
		else
			print @&.str+m, lib.importnames[r.stindex]
		esac
		showstrln(str)
	od
	showstrln("")
end

proc showsectiondata(ref byte p, int length)=
	int i,k,bb
	[128]char str,str2

	showstr("proc Section ")
	showstr("Idata:")
	showstr(" Size:")
	showstrint( length)
	gs_line(dest)
	gs_line(dest)

	k:=0

	str[1]:=0

	ref byte baseaddr:=nil

	print @&.str2,baseaddr:"Z8H",,": "

	showstr(&.str2)

	for i:=1 to length do
		bb:=p++^
		print @&.str2,bb:"z2H",," "
		showstr(&.str2)

		if 32<=bb<=127 then
			str2[1]:=bb
			str2[2]:=0
			strcat(&.str,&.str2)
		else
			strcat(&.str,".")
		fi
		if ++k=16 or i=length then
			if k<16 then
				to 16-k do
					showstr("   ")
					strcat(&.str," ")
				od
			fi
			showstr("	[")
			showstr(&.str)
			showstrln("]")
			k:=0
			str[1]:=0
			baseaddr+:=16
			print @&.str2,baseaddr:"z8h",,": "
			showstr(&.str2)
		fi
	od
	if k=0 then
		gs_line(dest)
	fi

	gs_line(dest)
	if k then gs_line(dest) fi
end

proc showsectioncode(ref byte p, int length, extra)=
	ref byte codeptr,codeend, codeendx,codestart
	int offset
	ichar s
	[16]char str

	showstrln( "proc Section Code")

	codestart:=codeptr:=p
	codeend:=codeptr+length
	codeendx:=codeend+extra

!	ref byte baseaddr:=cast(imagebase+p.virtoffset)
	ref byte baseaddr:=nil

	while codeptr<codeendx do
		if codeptr=codeend then
			showstrln("")
		fi
		offset:=codeptr-codestart
S:=NIL
!		s:=decodeinstr(codeptr,baseaddr+offset)
		exit when s=nil

		print @&.str,offset:"4",," "
		showstr(&.str)

		showstrln(s)
	od

	gs_line(dest)
end

global proc showglobals(filehandle logdev)=
	[300]char str
	[300]char name

	gs_init(dest)
	showstrln("Global Tables\n")

	print @str, "DLLs:",ndlllibs
	showstrln(str)

	for i to ndlllibs do
		print @str,i,,":",dllnametable[i]:"16jl", dllinsttable[i]:"h"
		showstrln(str)
	od
	showstrln("")

	print @str, "LIBs:",nlibs
	showstrln(str)

	for i to nlibs do
		print @str,i,,":",libnametable[i]:"20jl", (librelocated[i]|"Relocated"|"-")
		showstrln(str)
	od
	showstrln("")

	print @str, "Global Symbols:",nsymbols
	showstrln(str)

	showstrln("     Name              Def Address       Lib        Dll")
	showstrln("-----------------------------------------------------------")

	for i to nsymbols do
		strcpy(name,symbolnametable[i])
		if strlen(name)>17 then
			strcat(name,"\n                      ")
		fi
		fprint @str,"#: # # #  # #",
			i:"3",
!			symbolnametable[i]:"17jl",
			&.name:"17jl",
			(symboldefined[i]|"Y"|"-"):"3JL",
			symboladdress[i]:"Z12H",
			(symbollibindex[i]|libnametable[symbollibindex[i]]|"-"):"10jl",
			(symboldllindex[i]|dllnametable[symboldllindex[i]]|"-"):"10jl"
!symboldllindex[i]
		showstrln(str)
	od
	showstrln("")

	gs_println(dest,logdev)
end
=== mx_write.m 0 0 54/108 ===
!Translate SS data directly into MCB block, then write as mx/ml file

ref dbuffer dest

psymbol entrypoint

global proc writemcx(ichar filename)=
	int n

	ss_zdatalen:=roundtoblock(ss_zdatalen, 8)

	roundsegment(ss_code,8,0x90)
	roundsegment(ss_idata,8,0)

	dest:=buffercreate()

	genu32(mcxsig)

	genbyte(version_dir)
	genstring("0.1234")

	countsymbols()
	writerelocs()

	genbyte(zdata_dir)
	genu32(ss_zdatalen)

	genbyte(code_dir)
	genu32(n:=bufferlength(ss_code))
	genblock(bufferelemptr(ss_code,0), n)

	genbyte(idata_dir)
	genu32(n:=bufferlength(ss_idata))

	genblock(bufferelemptr(ss_idata,0), n)

	int ndlls:=0, nlibs:=0
	for i to nplibfiles when plibfiles[i]^<>'$' do
		++ndlls
	od

	genbyte(dlls_dir)
	genu32(ndlls)
!	for i to nplibfiles when libfiles[i]^<>'$' and libtypes[i]='D' do
	for i to nplibfiles when plibfiles[i]^<>'$' do
		genstring(plibfiles[i])
	od

	writesymbols()

	genbyte(end_dir)

	writefile(filename, dest.pstart, dest.pcurr-dest.pstart)
end

global proc writerelocs=
	ref relocrec oldr
	mcxreloc newr
	int n,count
	psymbol d
	ref u64 baseptr64
	ref u32 baseptr32@baseptr64

	genbyte(reloc_dir)
	genu32(n:=ss_nidatarelocs+ss_ncoderelocs)

	count:=0

	for i in code_seg..idata_seg do
		oldr:=(i=code_seg|ss_idatarelocs|ss_coderelocs)

		while oldr, oldr:=oldr.nextreloc do
			++count
			clear newr

			newr.offset:=oldr.offset
			newr.segment:=(i=code_seg|idata_seg|code_seg)

			d:=ss_symboltable[oldr.stindex]

			case oldr.reloctype
			when rel32_rel then
				if d.imported then
					newr.stindex:=d.impindex
					newr.reloctype:=imprel32_rel
				else
					axerror("rel32/rel not imported")
				fi
			when addr32_rel, addr64_rel then
				if d.imported then
					newr.reloctype:=(oldr.reloctype=addr32_rel|impabs32_rel|impabs64_rel)
					newr.stindex:=d.impindex
				else
					if oldr.reloctype=addr32_rel then
						newr.reloctype:=locabs32_rel
					else
						newr.reloctype:=locabs64_rel
					fi
					newr.targetsegment:=d.segment
				fi
			else
				axerror("reloc?")
			esac

			genblock(&newr, newr.bytes)

		od
	od
end

proc writesymbols=
	psymbol d
	int n
	ichar name

	genbyte(importsymbols_dir)
	genu32(nsymimports)

	for i to ss_nsymbols when ss_symboltable[i].impindex do
		d:=ss_symboltable[i]
		genstring(d.name)
	od

	genbyte(exportsymbols_dir)
	genu32(nsymexports)

	for i to ss_nsymbols do
		d:=ss_symboltable[i]
		if d.expindex then
!			if eqstring(d.name, "main") then
			if d.isentry then
				entrypoint:=d
			fi
			genstring(d.name)
		fi
	od

	genbyte(exportsegs_dir)
	genu32(nsymexports)
	for i to ss_nsymbols do
		d:=ss_symboltable[i]
		if d.expindex then
			genbyte(d.segment)
		fi
	od

	genbyte(exportoffsets_dir)
	genu32(nsymexports)
	for i to ss_nsymbols do
		d:=ss_symboltable[i]
		if d.expindex then
			genu32(d.offset)
		fi
	od

	genbyte(entry_dir)		!must be present; writes 0xFFFFFFFF when no entry point
	if entrypoint then
		genu32(entrypoint.offset)
	else
		genu32(0xFFFF'FFFF)
	fi
end

proc roundsegment(ref dbuffer p, int align, value)=
	int length:=bufferlength(p)
	int newlength:=roundtoblock(length, align)

	buffercheck(p, align)

	to newlength-length do
		p.pcurr++^:=value
	od
end

proc genbyte(int x)=
	buffercheck(dest,1)
	dest.pcurr++^:=x
end

proc genu32(int x)=
	buffercheck(dest,4)
	dest.pcurr32++^:=x
end

proc genstring(ichar s)=
	genblock(s, strlen(s)+1)
end

proc genblock(ref void p, int length)=
	buffercheck(dest,length)
	memcpy(dest.pcurr, p, length)
	dest.pcurr+:=length
end
=== cc.pro 0 0 55/108 ===
runexe cc
!runexe uu

!runexe \mxp\pci cc

runoptions

!	runopt -no

!	runopt -e
!	runopt -c
!	runopt -s
!	runopt -exe
!	runopt -obj
!	runopt -run

!	runopt -no
!	runopt -noregs
!	runopt -nopeep

!	runopt -ss
!	runopt -exe
!	runopt -mcl
!	runopt -s
!	runopt -p
!	runopt -parse
!	runopt -load

!	runopt -showss
	runopt -showmcl
	runopt -showpcl
	runopt -showast

!	runopt -showst
	runopt -showpst
!	runopt -showstflat
!	runopt -showtypes
!	runopt -showfiles

!	runopt -showil

!	runopt -long64

!	runopt -shortnames
!	runopt -rip
	runopt -norip

	runopt -himem

!	runopt -ext
!	runopt -NOCONST
!	runopt -time
!	runopt -i:headers\

end

runtarget $

modules

	mmproject cc.m

!	file \mx\mc_genmcl.m
!	FILE CC_BLOCKPCL.M
!	FILE CC_LEX.M
!	FILE CC_PARSE.M
!	FILE CC_GENPCL.M
!	FILE cc_cli.m
!	FILE \mx\pc_api.m
	FILE CC_PARSE.M
!	FILE CC_LEX.M
!	FILE CC_parse.M
!	file \mx\pc_api.m
!	file \mx\pcl.m
	file \mx\mc_auxmcl.m
	file \mx\mc_genmcl.m
	file \mx\mc_LIBmcl.m
	file \mx\mc_STACKmcl.m
	FILE CC_LIBPCL.M
	file \mx\pc_diags.m
	FILE CC_tables.M
!	file \mx\mc_Optim.m
!	file \mx\pc_tables.m
!	file \mx\mc_genss.m
!	file \mx\mc_auxmcl.m
!!	file \mx\mc_libmcl.m
!!	FILE CC_PARSE.M
	file ---
	module cc.m
	module \mx\pcl.m
	module cc_CLI.m
	module cc_BlockPCL.m
	module cc_Decls.m
	module cc_Export.m
	module cc_GenPCL.m
	module cc_Headers.m
	module cc_HeadersX.m
!	module cc_headersy.m
	module cc_Lex.m
	module cc_Lib.m
	module cc_LibPCL.m
	module cc_Parse.m
	module cc_PCL.m
	module cc_Show.m
	module cc_Showdummy.m
	module cc_Support.m
	module cc_Tables.m
	file ---
	file mcc.h


	file ---

	module \mx\pcl.m
	module \mx\pclint.m
	module \mx\pc_api.m
	module \mx\pc_decls.m
	module \mx\pc_diags.m
	module \mx\pc_reduce.m
	module \mx\pc_run.m
	module \mx\pc_runaux.m
	module \mx\pc_tables.m
	file ---

	module \mx\mc_AuxMCL.m
	module \mx\mc_GenMCL.m
	module \mx\mc_GenSS.m
	module \mx\mc_LibMCL.m
	module \mx\MC_Decls.m
	module \mx\mc_OBJdecls.m
	module \mx\mc_Optim.m
	module \mx\mc_StackMCL.m
	module \mx\mc_WriteASM.m
	module \mx\mc_WriteNASM.m
	module \mx\mc_WriteGAS.m
	module \mx\mc_WriteEXE.m
	module \mx\mc_WriteOBJ.m
!	module \mx\mc_WriteSS.m
!	module \mx\mc_disasm.m
	file ---

	module \mx\mx_Decls.m
	module \mx\mx_Run.m
	module \mx\mx_Lib.m
	module \mx\mx_Write.m



	file ---
	file cc.txt

!	link \windows\system32\user32.dll
end

!	file help.txt
!	file info.txt
!	file diff.txt
!	file \bcx\bcclib.asm
!	file longjmp.c

!	file \tcs\big
	file cxpaims.txt
	file stb_image.h
	file cc_help.txt
file $.asm
file trace.aa
file optim
file while.pas
file $.s
file mcc.h
file cpu.c
=== ccgas.pro 0 0 56/108 ===
runexe ccgas
!runexe tt $

!runexe \mxp\pci cc

runoptions

!	runopt -no

!	runopt -e
!	runopt -c
!	runopt -s
!	runopt -exe
!	runopt -obj
!	runopt -run

!	runopt -ss
!	runopt -exe
!	runopt -mcl
!	runopt -s
!	runopt -p
!	runopt -parse
!	runopt -load

!	runopt -showss
	runopt -showmcl
!	runopt -showpcl
!	runopt -showast

!	runopt -showst
!	runopt -showpst
!	runopt -showstflat
!	runopt -showtypes
!	runopt -showfiles

	runopt -showil

!	runopt -shortnames
!	runopt -rip
!	runopt -himem
!	runopt -norip

!	runopt -ext
!	runopt -time
!	runopt -i:headers\

end

runtarget $

modules

	mmproject ccgas.m

	FILE CC_BLOCKPCL.M
!	FILE CC_PARSE.M
	FILE CC_GENPCL.M
!	FILE cc_cli.m
!	FILE \mx\pc_api.m
!	FILE CC_LEX.M
!	FILE CC_parse.M
!	file \mx\pc_api.m
	file \mx\mc_LIBmcl.m
	file \mx\mc_writegas.m
	file \mx\pcl.m
	file \mx\mc_auxmcl.m
	file \mx\mc_genmcl.m
!	file \mx\mc_STACKmcl.m
	FILE CC_LIBPCL.M
	file \mx\pc_diags.m
	FILE CC_tables.M
!	file \mx\mc_Optim.m
!	file \mx\pc_tables.m
!	file \mx\mc_genss.m
!	file \mx\mc_auxmcl.m
!!	file \mx\mc_libmcl.m
!!	FILE CC_PARSE.M
	file ---
	module ccgas.m
	module \mx\pepcl.m
	module cc_CLI.m
	module cc_BlockPCL.m
	module cc_Decls.m
	module cc_Export.m
	module cc_GenPCL.m
	module cc_Headers.m
	module cc_HeadersX.m
!	module cc_headersy.m
	module cc_Lex.m
	module cc_Lib.m
	module cc_LibPCL.m
	module cc_Parse.m
	module cc_PCL.m
	module cc_Show.m
	module cc_Showdummy.m
	module cc_Support.m
	module cc_Tables.m
	file ---
	file mcc.h


	file ---

	module \mx\pcl.m
	module \mx\pclint.m
	module \mx\pc_api.m
	module \mx\pc_decls.m
	module \mx\pc_diags.m
	module \mx\pc_diags_dummy.m
	module \mx\pc_reduce.m
	module \mx\pc_run.m
	module \mx\pc_rund.m
	module \mx\pc_runaux.m
	module \mx\pc_tables.m
	file ---

	module \mx\mc_AuxMCL.m
	module \mx\mc_GenMCL.m
	module \mx\mc_GenSS.m
	module \mx\mc_LibMCL.m
	module \mx\MC_Decls.m
	module \mx\mc_OBJdecls.m
	module \mx\mc_Optim.m
	module \mx\mc_StackMCL.m
	module \mx\mc_WriteASM.m
	module \mx\mc_WriteGAS.m
	module \mx\mc_WriteNASM.m
!	module \mx\mc_WriteASM_dummy.m
	module \mx\mc_WriteEXE.m
	module \mx\mc_WriteOBJ.m
!	module \mx\mc_WriteSS.m
!	module \mx\mc_disasm.m
	file ---

	module \mx\mx_Decls.m
	module \mx\mx_Run.m
	module \mx\mx_Lib.m
	module \mx\mx_Write.m



	file ---
	file cc.txt

!	link \windows\system32\user32.dll
end

!	file help.txt
!	file info.txt
!	file diff.txt
!	file \bcx\bcclib.asm
!	file longjmp.c

!	file \tcs\big
	file cxpaims.txt
	file stb_image.h
	file cc_help.txt
file $.asm
file trace.aa
file optim
file while.pas
file $.asm
=== backup.bat 0 0 57/108 ===
del *.log
del *.i
del *.asm
del *.nasm
del *.s
del *.o*
del *.ppm
del *.pgm
del *.pcl
del *.ma
del *.zip
del sql.exe
rem rem ren cc.exe cc.eee
rem rem del *.exe
rem rem ren cc.eee cc.exe

call backupproject cx test\*.c
copy cxall.zip \test

rem cd \px
rem call backup
rem cd \cx

rem zip cxheaders headers\*.* headers\sys\*.*
rem copy cxheaders.zip %PENDRIVE%\
=== cc_help.txt 0 0 58/108 ===
C Subset Compiler for 64-bit Windows

Normal use:           Compiles prog.c to:

    cc      prog      prog.exe (default)
    cc -r   prog      in-memory native code then execute
    cc -i   prog      in-memory IL then interpret

    cc -exe prog      prog.exe
    cc -dll prog      prog.dll
    cc -obj prog      prog.obj
    cc -s   prog      prog.asm (also -a)
    cc -mx  prog      prog.mx
    cc -p   prog      prog.pcl (textual IL)
    cc -e   prog      prog.i   (preprocess only)

Other options:

    -incl:path        Add path to search for includes
    -ext              Used std headers external to compiler
    -opt              Optimise native code
    -o:file           Name output file (extension can be added)
    -norip            Don't use RIP address modes
    -himem            Generate PIC code (automatic with -obj/-dll)
    @file             Read files and options from a file
    -c                Same as -obj
    -s                Same as -asm
    -ei               Same as -e, but when result is interpreted

Notes:

    * Compiles single module only
    * For -i and -r, options
    * .c extension is optional on input file
=== info.txt 0 0 59/108 ===
    The 'MCC' C Compiler comprises:

    mcc.exe            Compiles to .asm files
    aa.exe             Assembles .asm files to .obj files
                       Assemblers and links .asm/.dll files to .exe
    Standard headers   A minimal set inside mcc.exe
    windows.h          As a standalone file

    Input files:

      prog             This is prog.c as the extension is optional
      prog.c
      lib.dll          Include .dll library when generating .exe
      @file            Read parameters and optons from given file

    Options:

      -exe             (DEFAULT) Compile all modules to one .exe file via .asm files
      -e               Preprocess each module to .i file
      -s               Compile each module to .asm file
      -c               Compile each module .obj via .asm

      -out:file        Specify output file for -exe only

    For .exe output, it will be named based on the first input file. Otherwise
    use -out option

    .obj files can be linked using gcc on Windows. This option is
    needed to be able to generate .dll files. However, this will not
    work on newer gcc versions because mcc's generated code is not position
    independent, and will only work loaded in the low 2GB of address space.

    Libraries msvcrt.dll, gdi32.dll, user32.dll and kernel32.dll are
    automatically included as search libraries for imported functions.

    Other kinds of binary libraries or files (.a, .lib, .obj etc) are not supported.

    Omissions, Restrictions and Bugs (highlights only as there are dozens):

      * No VLAs, compound literals, designated initialisers
      * Restrictions on complexity of data initialisers
=== putbcc.bat 0 0 60/108 ===
mm7 ccp.m
copy ccp.exe \m\bcc.exe
copy ccp.exe \m\cc7.exe
copy headers\windows.h \m
del ccp.exe
=== mcc.h 0 0 61/108 ===
#define __attribute__(x)
#define _WIN32
#define WIN32
#define __WIN32__
#define __inline
#define __dllimport(x)
//#define __declspec(x)
#define __stdcall
#define CALLBACK $callback
#define __cdecl
#define EXTERN_C extern
#define DECLSPEC_IMPORT
#define __32BIT__
#define register
#define __MCCC__

//typedef signed char		i8;
//typedef short			i16;
//typedef int				i32;
//typedef long long int	i64;
//typedef unsigned char			u8;
//typedef unsigned short			u16;
//typedef unsigned int			u32;
//typedef unsigned long long int	u64;
//
//typedef unsigned char byte;
//
//typedef float r32;
//typedef double r64;

=== assert.h 0 0 62/108 ===
/* Header assert.h */

//#define assert(x) 0
#define assert(x)
=== conio.h 0 0 63/108 ===
/* conio.h */
#include <stddef.h>
#include <wchar.h>

int _getch(void);
int _kbhit(void);
wint_t _getwch(void);

#define getch _getch
#define kbhit _kbhit

int _putch(int);
int _cprintf(char *, ...);
int _getche(void);
int _ungetch(int);

#define putch _putch
#define cprintf _cprintf
#define getche _getche
#define ungetch _ungetch
=== ctype.h 0 0 64/108 ===
/* Header ctype.h */

int tolower(int);
int toupper(int);
int isalpha(int);
int isdigit(int);
int isspace(int);
int isalnum(int);
int isupper(int);
int islower(int);

int isxdigit(int);
int iscntrl(int);
int isgraph(int);
int ispunct(int);
int isprint(int);
int __isascii(int);
#define isascii __isascii

int __toascii(int);
#define toascii __toascii
=== direct.h 0 0 65/108 ===
#ifndef $direct
#define $direct

typedef struct {
 unsigned int total_clusters;
 unsigned int avail_clusters;
 unsigned int sectors_per_cluster;
 unsigned int bytes_per_sector;
} diskfree_t;

int chdir(const char *);
char* _getcwd(char *, int);
#define getcwd _getcwd
int _mkdir(const char *);
int _rmdir(const char *);
int _wrmdir(const wchar_t*);
int _wmkdir(const wchar_t*);

#define mkdir _mkdir
#define rmdir _rmdir

int _chdrive(int);
char* _getdcwd(int, char *, int);
wchar_t* _wgetcwd(wchar_t*, int);
int _wchdir(const wchar_t*);
int _getdrive(void);
int _chdir(const char*);
#define chdir _chdir

unsigned long _getdrives(void);
unsigned int _getdiskfree(unsigned int, diskfree_t*);

#endif

=== errno.h 0 0 66/108 ===
/* Header errno.h */

#ifndef $errno
#define $errno

extern int* _errno(void);
#define errno (*_errno())

#define EPERM 1
#define ENOENT 2
#define ESRCH 3
#define EINTR 4
#define EIO 5
#define ENXIO 6
#define E2BIG 7
#define ENOEXEC 8
#define EBADF 9
#define ECHILD 10
#define EAGAIN 11
#define ENOMEM 12
#define EACCES 13
#define EFAULT 14
#define ENOTBLK 15
#define EBUSY 16
#define EEXIST 17
#define EXDEV 18
#define ENODEV 19
#define ENOTDIR 20
#define EISDIR 21
#define EINVAL 22
#define ENFILE 23
#define EMFILE 24
#define ENOTTY 25
#define ETXTBSY 26
#define EFBIG 27
#define ENOSPC 28
#define ESPIPE 29
#define EROFS 30
#define EMLINK 31
#define EPIPE 32
#define EDOM 33
#define ERANGE 34
#define ENOMSG 35
#define EIDRM 36
#define ECHRNG 37
#define EL2NSYNC 38
#define EL3HLT 39
#define EL3RST 40
#define ELNRNG 41
#define EUNATCH 42
#define ENOCSI 43
#define EL2HLT 44
#define EDEADLK 45
#define ENOLCK 46
#define EBADE 50
#define EBADR 51
#define EXFULL 52
#define ENOANO 53
#define EBADRQC 54
#define EBADSLT 55
#define EDEADLOCK 56
#define EBFONT 57
#define ENOSTR 60
#define ENODATA 61
#define ETIME 62
#define ENOSR 63
#define ENONET 64
#define ENOPKG 65
#define EREMOTE 66
#define ENOLINK 67
#define EADV 68
#define ESRMNT 69
#define ECOMM 70
#define EPROTO 71
#define EMULTIHOP 74
#define ELBIN 75
#define EOVERFLOW 76
#define EBADMSG 77
#define ENOTUNIQ 80
#define EBADFD 81
#define EREMCHG 82
#define ELIBACC 83
#define ELIBBAD 84
#define ELIBSCN 85
#define ELIBMAX 86
#define ELIBEXEC 87
#define ENOSYS 88
#define ENMFILE 89
#define ENOTEMPTY 90
#define ENAMETOOLONG 91
#define EILSEQ 92
#define __ELASTERROR 2000

#endif
=== fcntl.h 0 0 67/108 ===
/* FCNTL.H */

int _setmode(int,int);

#ifndef _INC_FCNTL
#define _INC_FCNTL

#define _O_RDONLY 0x0000
#define _O_WRONLY 0x0001
#define _O_RDWR 0x0002
#define _O_APPEND 0x0008
#define _O_CREAT 0x0100
#define _O_TRUNC 0x0200
#define _O_EXCL 0x0400
#define _O_TEXT 0x4000
#define _O_BINARY 0x8000
#define _O_WTEXT 0x10000
#define _O_U16TEXT 0x20000
#define _O_U8TEXT 0x40000
#define _O_ACCMODE (_O_RDONLY|_O_WRONLY|_O_RDWR)

#define _O_RAW _O_BINARY
#define _O_NOINHERIT 0x0080
#define _O_TEMPORARY 0x0040
#define _O_SHORT_LIVED 0x1000

#define _O_SEQUENTIAL 0x0020
#define _O_RANDOM 0x0010

#if !defined(NO_OLDNAMES) || defined(_POSIX)
#define O_RDONLY _O_RDONLY
#define O_WRONLY _O_WRONLY
#define O_RDWR _O_RDWR
#define O_APPEND _O_APPEND
#define O_CREAT _O_CREAT
#define O_TRUNC _O_TRUNC
#define O_EXCL _O_EXCL
#define O_TEXT _O_TEXT
#define O_BINARY _O_BINARY
#define O_RAW _O_BINARY
#define O_TEMPORARY _O_TEMPORARY
#define O_NOINHERIT _O_NOINHERIT
#define O_SEQUENTIAL _O_SEQUENTIAL
#define O_RANDOM _O_RANDOM
#define O_ACCMODE _O_ACCMODE
#endif

#endif
=== fenv.h 0 0 68/108 ===
/* Header fenv.h */

int feclearexcept(int);
int fetestexcept(int);

#define FE_INVALID 1
#define FE_DENORMAL 2
#define FE_INEXACT 32
#define FE_DIVBYZERO 4 
#define FE_OVERFLOW 8
#define FE_UNDERFLOW 16
#define FE_STACKFAULT 64
#define FE_ALL_EXCEPT (FE_INVALID|FE_DENORMAL|FE_INEXACT|FE_DIVBYZERO|FE_OVERFLOW|FE_UNDERFLOW)
=== float.h 0 0 69/108 ===
/* Header float.h */

//#define DBL_MAX_10_EXP 308
//#define DBL_MANT_DIG 53

#define FLT_RADIX 2

#define FLT_DIG 6
#define FLT_MIN_EXP -125
#define FLT_MIN 1.17549435E-38F // decimal constant
#define FLT_MIN 0X1P-126F // hex constant
#define FLT_TRUE_MIN 1.40129846E-45F // decimal constant
#define FLT_TRUE_MIN 0X1P-149F // hex constant
#define FLT_HAS_SUBNORM 1
#define FLT_MIN_10_EXP -37
#define FLT_MAX_EXP +128
#define FLT_MAX 3.40282347E+38F // decimal constant
#define FLT_MAX 0X1.fffffeP127F // hex constant
#define FLT_MAX_10_EXP +38
#define FLT_EPSILON 1.19209290e-07F
#define FLT_MANT_DIG 23

#define DBL_MANT_DIG 53
#define DBL_EPSILON 2.2204460492503131E-16 // decimal constant
//#define DBL_EPSILON 0X1P-52 // hex constant
#define DBL_DECIMAL_DIG 17
#define DBL_DIG 15
#define DBL_MIN_EXP -1021
#define DBL_MIN 2.2250738585072014E-308 // decimal constant
//#define DBL_MIN 0X1P-1022 // hex constant
#define DBL_TRUE_MIN 4.9406564584124654E-324 // decimal constant
//#define DBL_TRUE_MIN 0X1P-1074 // hex constant
#define DBL_HAS_SUBNORM 1
#define DBL_MIN_10_EXP -307
#define DBL_MAX_EXP +1024
#define DBL_MAX 1.7976931348623157E+308 // decimal constant
//#define DBL_MAX 0X1.fffffffffffffP1023 // h
#define DBL_MAX_10_EXP +308

#define LDBL_MIN DBL_MIN
#define LDBL_MAX DBL_MAX
#define LDBL_EPSILON 2.2204460492503131E-16
#define LDBL_MANT_DIG 53
#define LDBL_MIN_EXP -1021
#define LDBL_MAX_EXP +1024

int     _isnan(double);
#define isnan _isnan
=== inttypes.h 0 0 70/108 ===
/* Header inttypes.h */

#include <stdint.h>

/* fprintf macros for signed types */
#define PRId8 "d"
#define PRId16 "d"
#define PRId32 "d"
#define PRId64 "I64d"

#define PRIdLEAST8 "d"
#define PRIdLEAST16 "d"
#define PRIdLEAST32 "d"
#define PRIdLEAST64 "I64d"

#define PRIdFAST8 "d"
#define PRIdFAST16 "d"
#define PRIdFAST32 "d"
#define PRIdFAST64 "I64d"

#define PRIdMAX "I64d"

#define PRIi8 "i"
#define PRIi16 "i"
#define PRIi32 "i"
#define PRIi64 "I64i"

#define PRIiLEAST8 "i"
#define PRIiLEAST16 "i"
#define PRIiLEAST32 "i"
#define PRIiLEAST64 "I64i"

#define PRIiFAST8 "i"
#define PRIiFAST16 "i"
#define PRIiFAST32 "i"
#define PRIiFAST64 "I64i"

#define PRIiMAX "I64i"

#define PRIo8 "o"
#define PRIo16 "o"
#define PRIo32 "o"
#define PRIo64 "I64o"

#define PRIoLEAST8 "o"
#define PRIoLEAST16 "o"
#define PRIoLEAST32 "o"
#define PRIoLEAST64 "I64o"

#define PRIoFAST8 "o"
#define PRIoFAST16 "o"
#define PRIoFAST32 "o"
#define PRIoFAST64 "I64o"

#define PRIoMAX "I64o"

/* fprintf macros for unsigned types */
#define PRIu8 "u"
#define PRIu16 "u"
#define PRIu32 "u"
#define PRIu64 "I64u"


#define PRIuLEAST8 "u"
#define PRIuLEAST16 "u"
#define PRIuLEAST32 "u"
#define PRIuLEAST64 "I64u"

#define PRIuFAST8 "u"
#define PRIuFAST16 "u"
#define PRIuFAST32 "u"
#define PRIuFAST64 "I64u"

#define PRIuMAX "I64u"

#define PRIx8 "x"
#define PRIx16 "x"
#define PRIx32 "x"
#define PRIx64 "I64x"

#define PRIxLEAST8 "x"
#define PRIxLEAST16 "x"
#define PRIxLEAST32 "x"
#define PRIxLEAST64 "I64x"

#define PRIxFAST8 "x"
#define PRIxFAST16 "x"
#define PRIxFAST32 "x"
#define PRIxFAST64 "I64x"

#define PRIxMAX "I64x"

#define PRIX8 "X"
#define PRIX16 "X"
#define PRIX32 "X"
#define PRIX64 "I64X"

#define PRIXLEAST8 "X"
#define PRIXLEAST16 "X"
#define PRIXLEAST32 "X"
#define PRIXLEAST64 "I64X"

#define PRIXFAST8 "X"
#define PRIXFAST16 "X"
#define PRIXFAST32 "X"
#define PRIXFAST64 "I64X"

#define PRIXMAX "I64X"

=== io.h 0 0 71/108 ===

#ifndef $io
#define $io

#include <stdint.h>
#include <wchar.h>
#include <time.h>

/* io.h */

#define _A_NORMAL 0x00
#define _A_RDONLY 0x01
#define _A_HIDDEN 0x02
#define _A_SYSTEM 0x04
#define _A_SUBDIR 0x10
#define _A_ARCH 0x20


//#message "IO included"
struct _finddata_t {
        unsigned    attrib;
        time_t      time_create;
        time_t      time_access;
        time_t      time_write;
        unsigned long    size;
        char        name[260];
};

int _isatty(int);

int _read(int, void*, unsigned int);
#define read _read

int _open(const char*, int, ...);
#define open _open

long _lseek(int, long, int);
#define lseek _lseek

int _close(int);
#define close _close

intptr_t _get_osfhandle(int);
int _open_osfhandle(intptr_t,int);

int _setmode(int,int);
#define setmode _setmode

int _wchmod(const wchar_t*, int);

int _chmod(const char *, int);
#define chmod _chmod

int _dup(int);
#define dup _dup

intptr_t _findfirst(const char*, struct _finddata_t*);
int _findnext(intptr_t, struct _finddata_t*);
int _findclose(intptr_t);

int _access(const char*,int);
#define access _access

int _wunlink(const wchar_t*);


#endif
=== iso646.h 0 0 72/108 ===
/* iso646.h */

#define and	&&
#define and_eq	&=
#define bitand	&
#define bitor	|
#define compl	~
#define not	!
#define not_eq	!=
#define or	||
#define or_eq	|=
#define xor	^
#define xor_eq	^=
=== limits.h 0 0 73/108 ===
/* Header limits.h */

#define CHAR_BIT 8

#define CHAR_MIN 0
#define CHAR_MAX 255

#define UCHAR_MIN 0
#define UCHAR_MAX 255

#define SCHAR_MIN -128
#define SCHAR_MAX 127

#define SHRT_MIN -32768
#define SHRT_MAX 32767

#define USHRT_MIN 0
#define USHRT_MAX 65535

#define INT_MIN -2147483648
#define INT_MAX  2147483647

#define UINT_MIN 0
#define UINT_MAX 4294967295

#define LONG_MIN -2147483648
#define LONG_MAX  2147483647

#define ULONG_MIN 0
#define ULONG_MAX 4294967295

#define LLONG_MIN -9223372036854775808LL
#define LLONG_MAX  9223372036854775807LL

#define ULLONG_MIN 0
#define ULLONG_MAX 0xFFFFFFFFFFFFFFFFLL

#define SIZE_MAX ULLONG_MAX
=== locale.h 0 0 74/108 ===
/* Header locale.h */

#ifndef $locale
#define $locale

#define LC_ALL 0
#define LC_COLLATE 1
#define LC_CTYPE 2
#define LC_MONETARY 3
#define LC_NUMERIC 4
#define LC_TIME 5

struct lconv {
	char *decimal_point;
	char *thousands_sep;
	char *grouping;
	char *int_curr_symbol;
	char *currency_symbol;
	char *mon_decimal_point;
	char *mon_thousands_sep;
	char *mon_grouping;
	char *positive_sign;
	char *negative_sign;
	char int_frac_digits;
	char frac_digits;
	char p_cs_precedes;
	char p_sep_by_space;
	char n_cs_precedes;
	char n_sep_by_space;
	char p_sign_posn;
	char n_sign_posn;
};
char *setlocale(int category, const char *locale);

struct lconv *localeconv(void);

char * setlocale(int,const char *);
#endif
=== malloc.h 0 0 75/108 ===
#include <stddef.h>

void* malloc(size_t);
void* realloc(void *, size_t);
void  free(void *);
void *_alloca(size_t);

#define alloca malloc
=== math.h 0 0 76/108 ===
/* Header math.h */

#define HUGE_VAL 1.7976931348623156e+308

double floor(double);
double ceil(double);
double sqrt(double);
double sin(double);
double cos(double);
double tan(double);
double fmod(double,double);
double asin(double);
double acos(double);
double atan(double);
double log(double);
double log10(double);
double exp(double);
double modf(double,double*);
double atan2(double,double);
double pow(double,double);
double fabs(double);
double sinh(double);
double cosh(double);
double tanh(double);
double frexp(double,int*);
double ldexp(double,int);
int isnan(double);

#define ldexpl ldexp

float sinf(float);
float cosf(float);
float tanf(float);
float expf(float);
float powf(float, float);
float logf(float);

float sqrtf(float);
float acosf(float);
float atan2f(float,float);
float ceilf(float);

double acosh (double);
long double acoshl(long double);
long double acoshl(long double);
float acoshf(float);

double asinh (double);
long double asinhl(long double);
long double sinhl(long double);
float asinhf(float);

double atanh(double);
long double atanhl(long double);
float atanhf(float);

long double expm1l(long double);
double expm1(double);
float expm1f(float);
double _expm1i(int);

double cbrt(double);
long double cbrtl(long double);
float cbrtf(float);

double trunc(double x);
long double truncl(long double);
float truncf(float);

double round(double);
float roundf(float);
long double roundl(long double);
double _roundi(int);

long double fminl(long double,long double);
float fminf(float ,float);
double fmin(double,double);

//float fabsf(float);
#define fabsf fabs

double lgamma (double);
long double lgammal(long double);
float lgammaf(float);

long double tgammal(long double);
double tgamma(double);
float tgammaf(float);

double log1p(double);
long double log1pl(long double);
float log1pf(float);

long double log10l(long double);
float log10f(float);
double _log10i(int);
double log10(double);

double erf(double);
long double erfl(long double);
float erff(float);

double hypot (double, double);
double _hypot(double,double);
long double hypotl(long double,long double);
float hypotf(float,float);

double nextafter (double, double);
long double nextafterl(long double,long double);
float nextafterf(float,float);

double nexttoward(double,long double);
long double nexttowardl(long double,long double);
float nexttowardf(float,long double);

double erfc(double);
long double erfcl(long double);
float erfcf(float);

int _finite(double);
#define finite _finite

float floorf(float);

double _copysign(double,double);
#define copysign _copysign

long double fmaxl(long double,long double);
double fmax(double,double);
float fmaxf(float,float);
float fmodf(float,float);

//long double exp2l(long double);
double exp2(double);
float exp2f(float);

//double log2(double);
#define log2(x) (log(x)*1.442695041)

#define M_PI 3.1415926535897932384625433
#define M_PI_2 (M_PI/2.0)
#define M_2_PI 0.63661977236758134308

int isinf(double);

int _finite(double);

#define isfinite _finite

int isfinitef(float);
int isfinitel(long double);

=== mcc.h 0 0 77/108 ===
#define __attribute__(x)
#define _WIN32
#define __inline
=== memory.h 0 0 78/108 ===
#include <malloc.h>
=== process.h 0 0 79/108 ===
/* Header process.h */
#ifndef $process
#define $process

#include <stdint.h>

#define P_WAIT		0
#define P_NOWAIT	1
#define P_OVERLAY	2
#define P_DETACH	4
#define WAIT_CHILD 0
#define _P_WAIT P_WAIT
#define _P_NOWAIT P_NOWAIT
#define _P_OVERLAY P_OVERLAY

int _spawnvp(int, const char*, const char*const*);
#define spawnvp _spawnvp

void endthread(void);
unsigned long _beginthreadex(void *,unsigned,unsigned (*)(void *),void *,unsigned,unsigned *);
void _endthreadex(unsigned);
int _cwait(int*, int, int);
#define cwait _cwait
//int _System(const char *cmd,int nCmdShow);

intptr_t _execve(const char*, const char*const*, const char*const*);
#define execve _execve

//#define _WAIT_CHILD	0
//#endif
#endif

=== safelib.h 0 0 80/108 ===
/* Header safelib.h */
=== setjmp.h 0 0 81/108 ===
/* Header setjmp.h */


#ifndef $setjmphdr
#define $setjmphdr 1

typedef int jmp_buf[128];

//void $mcclongjmp(jmp_buf, int);
//int $mccsetjmp(jmp_buf);

#define setjmp $setjmp
#define longjmp $longjmp

#endif

=== shellapi.h 0 0 82/108 ===
#ifndef _INC_SHELLAPI
#define _INC_SHELLAPI
//#include <SpecStrings.h>
#ifndef WINSHELLAPI
#if !defined(_SHELL32_)
#define WINSHELLAPI DECLSPEC_IMPORT
#else
#define WINSHELLAPI
#endif
#endif 
#ifndef SHSTDAPI
#if !defined(_SHELL32_)
#define SHSTDAPI EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define SHSTDAPI_(type) EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#else
#define SHSTDAPI STDAPI
#define SHSTDAPI_(type) STDAPI_(type)
#endif
#endif 
#ifndef SHDOCAPI
#if !defined(_SHDOCVW_)
#define SHDOCAPI EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define SHDOCAPI_(type) EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#else
#define SHDOCAPI STDAPI
#define SHDOCAPI_(type) STDAPI_(type)
#endif
#endif 
//#if !defined(_WIN64)
//#include <pshpack1.h>
//#endif
DECLARE_HANDLE(HDROP);
SHSTDAPI_(UINT) DragQueryFileA(HDROP hDrop,UINT iFile,LPSTR lpszFile,UINT cch);
SHSTDAPI_(UINT) DragQueryFileW(HDROP hDrop,UINT iFile,LPWSTR lpszFile,UINT cch);
#ifdef UNICODE
#define DragQueryFile DragQueryFileW
#else
#define DragQueryFile DragQueryFileA
#endif 
SHSTDAPI_(BOOL) DragQueryPoint(HDROP hDrop,LPPOINT lppt);
SHSTDAPI_(void) DragFinish(HDROP hDrop);
SHSTDAPI_(void) DragAcceptFiles(HWND hWnd,BOOL fAccept);
SHSTDAPI_(HINSTANCE) ShellExecuteA(HWND hwnd,LPCSTR lpOperation,LPCSTR lpFile,LPCSTR lpParameters,LPCSTR lpDirectory,INT nShowCmd);
SHSTDAPI_(HINSTANCE) ShellExecuteW(HWND hwnd,LPCWSTR lpOperation,LPCWSTR lpFile,LPCWSTR lpParameters,LPCWSTR lpDirectory,INT nShowCmd);
#ifdef UNICODE
#define ShellExecute ShellExecuteW
#else
#define ShellExecute ShellExecuteA
#endif 
SHSTDAPI_(HINSTANCE) FindExecutableA(LPCSTR lpFile,LPCSTR lpDirectory,LPSTR lpResult);
SHSTDAPI_(HINSTANCE) FindExecutableW(LPCWSTR lpFile,LPCWSTR lpDirectory,LPWSTR lpResult);
#ifdef UNICODE
#define FindExecutable FindExecutableW
#else
#define FindExecutable FindExecutableA
#endif 
SHSTDAPI_(LPWSTR *) CommandLineToArgvW(LPCWSTR lpCmdLine,int*pNumArgs);
SHSTDAPI_(INT) ShellAboutA(HWND hWnd,LPCSTR szApp,LPCSTR szOtherStuff,HICON hIcon);
SHSTDAPI_(INT) ShellAboutW(HWND hWnd,LPCWSTR szApp,LPCWSTR szOtherStuff,HICON hIcon);
#ifdef UNICODE
#define ShellAbout ShellAboutW
#else
#define ShellAbout ShellAboutA
#endif 
SHSTDAPI_(HICON) DuplicateIcon(HINSTANCE hInst,HICON hIcon);
SHSTDAPI_(HICON) ExtractAssociatedIconA(HINSTANCE hInst,LPSTR pszIconPath,WORD *piIcon);
SHSTDAPI_(HICON) ExtractAssociatedIconW(HINSTANCE hInst,LPWSTR pszIconPath,WORD *piIcon);
#ifdef UNICODE
#define ExtractAssociatedIcon ExtractAssociatedIconW
#else
#define ExtractAssociatedIcon ExtractAssociatedIconA
#endif 
SHSTDAPI_(HICON) ExtractAssociatedIconExA(HINSTANCE hInst,LPSTR pszIconPath,WORD *piIconIndex,WORD *piIconId);
SHSTDAPI_(HICON) ExtractAssociatedIconExW(HINSTANCE hInst,LPWSTR pszIconPath,WORD *piIconIndex,WORD *piIconId);
#ifdef UNICODE
#define ExtractAssociatedIconEx ExtractAssociatedIconExW
#else
#define ExtractAssociatedIconEx ExtractAssociatedIconExA
#endif 
SHSTDAPI_(HICON) ExtractIconA(HINSTANCE hInst,LPCSTR lpszExeFileName,UINT nIconIndex);
SHSTDAPI_(HICON) ExtractIconW(HINSTANCE hInst,LPCWSTR lpszExeFileName,UINT nIconIndex);
#ifdef UNICODE
#define ExtractIcon ExtractIconW
#else
#define ExtractIcon ExtractIconA
#endif 
#if(WINVER >=0x0400)
typedef struct _DRAGINFOA {
	UINT uSize; 
	POINT pt;
	BOOL fNC;
	LPSTR lpFileList;
	DWORD grfKeyState;
} DRAGINFOA,*LPDRAGINFOA;
typedef struct _DRAGINFOW {
	UINT uSize; 
	POINT pt;
	BOOL fNC;
	LPWSTR lpFileList;
	DWORD grfKeyState;
} DRAGINFOW,*LPDRAGINFOW;
#ifdef UNICODE
typedef DRAGINFOW DRAGINFO;
typedef LPDRAGINFOW LPDRAGINFO;
#else
typedef DRAGINFOA DRAGINFO;
typedef LPDRAGINFOA LPDRAGINFO;
#endif 
#define ABM_NEW 0
#define ABM_REMOVE 1
#define ABM_QUERYPOS 2
#define ABM_SETPOS 3
#define ABM_GETSTATE 4
#define ABM_GETTASKBARPOS 5
#define ABM_ACTIVATE 6 
#define ABM_GETAUTOHIDEBAR 7
#define ABM_SETAUTOHIDEBAR 8 
#define ABM_WINDOWPOSCHANGED 9
#if (NTDDI_VERSION >=NTDDI_WINXP)
#define ABM_SETSTATE 10
#endif 
#define ABN_STATECHANGE 0
#define ABN_POSCHANGED 1
#define ABN_FULLSCREENAPP 2
#define ABN_WINDOWARRANGE 3 
#define ABS_AUTOHIDE 1
#define ABS_ALWAYSONTOP 2
#define ABE_LEFT 0
#define ABE_TOP 1
#define ABE_RIGHT 2
#define ABE_BOTTOM 3
typedef struct _AppBarData {
	DWORD cbSize;
	HWND hWnd;
	UINT uCallbackMessage;
	UINT uEdge;
	RECT rc;
	LPARAM lParam; 
} APPBARDATA,*PAPPBARDATA;
SHSTDAPI_(UINT_PTR) SHAppBarMessage(DWORD dwMessage,PAPPBARDATA pData);
SHSTDAPI_(DWORD) DoEnvironmentSubstA(LPSTR szString,UINT cchString);
SHSTDAPI_(DWORD) DoEnvironmentSubstW(LPWSTR szString,UINT cchString);
#ifdef UNICODE
#define DoEnvironmentSubst DoEnvironmentSubstW
#else
#define DoEnvironmentSubst DoEnvironmentSubstA
#endif 
#define EIRESID(x) (-1 *(int)(x))
SHSTDAPI_(UINT) ExtractIconExA(LPCSTR lpszFile,int nIconIndex,HICON *phiconLarge,HICON *phiconSmall,UINT nIcons);
SHSTDAPI_(UINT) ExtractIconExW(LPCWSTR lpszFile,int nIconIndex,HICON *phiconLarge,HICON *phiconSmall,UINT nIcons);
#ifdef UNICODE
#define ExtractIconEx ExtractIconExW
#else
#define ExtractIconEx ExtractIconExA
#endif 
#define FO_MOVE 1
#define FO_COPY 2
#define FO_DELETE 3
#define FO_RENAME 4
#define FOF_MULTIDESTFILES 1
#define FOF_CONFIRMMOUSE 2
#define FOF_SILENT 4 
#define FOF_RENAMEONCOLLISION 8 
#define FOF_NOCONFIRMATION 16 
#define FOF_WANTMAPPINGHANDLE 32 
#define FOF_ALLOWUNDO 64 
#define FOF_FILESONLY 128 
#define FOF_SIMPLEPROGRESS 256 
#define FOF_NOCONFIRMMKDIR 512 
#define FOF_NOERRORUI 1024 
#if (_WIN32_IE >=0x0500)
#define FOF_NOCOPYSECURITYATTRIBS 2048 
#define FOF_NORECURSION 4096 
#define FOF_NO_CONNECTED_ELEMENTS 8192 
#define FOF_WANTNUKEWARNING 16384 
#endif 
#if (_WIN32_WINNT >=0x0501)
#define FOF_NORECURSEREPARSE 32768 
#endif 
#define FOF_NO_UI (FOF_SILENT|FOF_NOCONFIRMATION|FOF_NOERRORUI|FOF_NOCONFIRMMKDIR) 
typedef WORD FILEOP_FLAGS;
#define PO_DELETE 19 
#define PO_RENAME 20 
#define PO_PORTCHANGE 32 
#define PO_REN_PORT 52 
typedef WORD PRINTEROP_FLAGS;
typedef struct _SHFILEOPSTRUCTA {
	HWND hwnd;
	UINT wFunc;
	LPCSTR pFrom;
	LPCSTR pTo;
	FILEOP_FLAGS fFlags;
	BOOL fAnyOperationsAborted;
	LPVOID hNameMappings;
	LPCSTR lpszProgressTitle; 
} SHFILEOPSTRUCTA,*LPSHFILEOPSTRUCTA;
typedef struct _SHFILEOPSTRUCTW {
	HWND hwnd;
	UINT wFunc;
	LPCWSTR pFrom;
	LPCWSTR pTo;
	FILEOP_FLAGS fFlags;
	BOOL fAnyOperationsAborted;
	LPVOID hNameMappings;
	LPCWSTR lpszProgressTitle; 
} SHFILEOPSTRUCTW,*LPSHFILEOPSTRUCTW;
#ifdef UNICODE
typedef SHFILEOPSTRUCTW SHFILEOPSTRUCT;
typedef LPSHFILEOPSTRUCTW LPSHFILEOPSTRUCT;
#else
typedef SHFILEOPSTRUCTA SHFILEOPSTRUCT;
typedef LPSHFILEOPSTRUCTA LPSHFILEOPSTRUCT;
#endif 
SHSTDAPI_(int) SHFileOperationA(LPSHFILEOPSTRUCTA lpFileOp);
SHSTDAPI_(int) SHFileOperationW(LPSHFILEOPSTRUCTW lpFileOp);
#ifdef UNICODE
#define SHFileOperation SHFileOperationW
#else
#define SHFileOperation SHFileOperationA
#endif 
SHSTDAPI_(void) SHFreeNameMappings(HANDLE hNameMappings);
typedef struct _SHNAMEMAPPINGA {
	LPSTR pszOldPath;
	LPSTR pszNewPath;
	int cchOldPath;
	int cchNewPath;
} SHNAMEMAPPINGA,*LPSHNAMEMAPPINGA;
typedef struct _SHNAMEMAPPINGW {
	LPWSTR pszOldPath;
	LPWSTR pszNewPath;
	int cchOldPath;
	int cchNewPath;
} SHNAMEMAPPINGW,*LPSHNAMEMAPPINGW;
#ifdef UNICODE
typedef SHNAMEMAPPINGW SHNAMEMAPPING;
typedef LPSHNAMEMAPPINGW LPSHNAMEMAPPING;
#else
typedef SHNAMEMAPPINGA SHNAMEMAPPING;
typedef LPSHNAMEMAPPINGA LPSHNAMEMAPPING;
#endif 
#define SE_ERR_FNF 2 
#define SE_ERR_PNF 3 
#define SE_ERR_ACCESSDENIED 5 
#define SE_ERR_OOM 8 
#define SE_ERR_DLLNOTFOUND 32
#endif 
#define SE_ERR_SHARE 26
#define SE_ERR_ASSOCINCOMPLETE 27
#define SE_ERR_DDETIMEOUT 28
#define SE_ERR_DDEFAIL 29
#define SE_ERR_DDEBUSY 30
#define SE_ERR_NOASSOC 31
#if(WINVER >=0x0400)
#define SEE_MASK_DEFAULT 0
#define SEE_MASK_CLASSNAME 1 
#define SEE_MASK_CLASSKEY 3 
#define SEE_MASK_IDLIST 4 
#define SEE_MASK_INVOKEIDLIST 12 
#if (NTDDI_VERSION < NTDDI_VISTA)
#define SEE_MASK_ICON 16 
#endif 
#define SEE_MASK_HOTKEY 32 
#define SEE_MASK_NOCLOSEPROCESS 64 
#define SEE_MASK_CONNECTNETDRV 128 
#define SEE_MASK_NOASYNC 256 
#define SEE_MASK_FLAG_DDEWAIT SEE_MASK_NOASYNC 
#define SEE_MASK_DOENVSUBST 512 
#define SEE_MASK_FLAG_NO_UI 1024 
#define SEE_MASK_UNICODE 16384
#define SEE_MASK_NO_CONSOLE 32768
#define SEE_MASK_ASYNCOK 0x100000
#if (NTDDI_VERSION >=NTDDI_WIN2K)
#define SEE_MASK_HMONITOR 0x200000 
#endif 
#if (NTDDI_VERSION >=NTDDI_WINXPSP1)
#define SEE_MASK_NOZONECHECKS 0x800000
#endif 
#if (NTDDI_VERSION >=NTDDI_WIN2K)
#define SEE_MASK_NOQUERYCLASSSTORE 0x1000000
#define SEE_MASK_WAITFORINPUTIDLE 0x2000000
#endif 
#if (NTDDI_VERSION >=NTDDI_WINXP)
#define SEE_MASK_FLAG_LOG_USAGE 0x4000000
#endif 
#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME u
#define DUMMYUNIONNAME2 u2
#define DUMMYUNIONNAME3 u3
#define DUMMYUNIONNAME4 u4
#define DUMMYUNIONNAME5 u5
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#define DUMMYUNIONNAME4
#define DUMMYUNIONNAME5
#endif
#endif 
#if defined(_MSC_VER) && (_MSC_VER >=1200)
#pragma once
#endif
typedef struct _SHELLEXECUTEINFOA {
	DWORD cbSize; 
	ULONG fMask; 
	HWND hwnd; 
	LPCSTR lpVerb; 
	LPCSTR lpFile; 
	LPCSTR lpParameters; 
	LPCSTR lpDirectory; 
	int nShow; 
	HINSTANCE hInstApp; 
	void *lpIDList; 
	LPCSTR lpClass; 
	HKEY hkeyClass; 
	DWORD dwHotKey; 
	union 
	{ 
		HANDLE hIcon; 
#if (NTDDI_VERSION >=NTDDI_WIN2K)
		HANDLE hMonitor; 
#endif 
	} DUMMYUNIONNAME; 
	HANDLE hProcess; 
} SHELLEXECUTEINFOA,*LPSHELLEXECUTEINFOA;
typedef struct _SHELLEXECUTEINFOW {
	DWORD cbSize; 
	ULONG fMask; 
	HWND hwnd; 
	LPCWSTR lpVerb; 
	LPCWSTR lpFile; 
	LPCWSTR lpParameters; 
	LPCWSTR lpDirectory; 
	int nShow; 
	HINSTANCE hInstApp; 
	void *lpIDList; 
	LPCWSTR lpClass; 
	HKEY hkeyClass; 
	DWORD dwHotKey; 
	union 
	{ 
		HANDLE hIcon; 
#if (NTDDI_VERSION >=NTDDI_WIN2K)
		HANDLE hMonitor; 
#endif 
	} DUMMYUNIONNAME; 
	HANDLE hProcess; 
} SHELLEXECUTEINFOW,*LPSHELLEXECUTEINFOW;
#ifdef UNICODE
typedef SHELLEXECUTEINFOW SHELLEXECUTEINFO;
typedef LPSHELLEXECUTEINFOW LPSHELLEXECUTEINFO;
#else
typedef SHELLEXECUTEINFOA SHELLEXECUTEINFO;
typedef LPSHELLEXECUTEINFOA LPSHELLEXECUTEINFO;
#endif 
SHSTDAPI_(BOOL) ShellExecuteExA(SHELLEXECUTEINFOA *pExecInfo);
SHSTDAPI_(BOOL) ShellExecuteExW(SHELLEXECUTEINFOW *pExecInfo);
#ifdef UNICODE
#define ShellExecuteEx ShellExecuteExW
#else
#define ShellExecuteEx ShellExecuteExA
#endif 
#if (NTDDI_VERSION >=NTDDI_WIN2K)
typedef struct _SHCREATEPROCESSINFOW {
	DWORD cbSize;
	ULONG fMask;
	HWND hwnd;
	LPCWSTR pszFile;
	LPCWSTR pszParameters;
	LPCWSTR pszCurrentDirectory;
	HANDLE hUserToken;
	LPSECURITY_ATTRIBUTES lpProcessAttributes;
	LPSECURITY_ATTRIBUTES lpThreadAttributes;
	BOOL bInheritHandles;
	DWORD dwCreationFlags;
	LPSTARTUPINFOW lpStartupInfo;
	LPPROCESS_INFORMATION lpProcessInformation;
} SHCREATEPROCESSINFOW,*PSHCREATEPROCESSINFOW;
SHSTDAPI_(BOOL) SHCreateProcessAsUserW(PSHCREATEPROCESSINFOW pscpi);
#endif 
#if (NTDDI_VERSION >=NTDDI_VISTA)
SHSTDAPI SHEvaluateSystemCommandTemplate(PCWSTR pszCmdTemplate,PWSTR *ppszApplication,PWSTR *ppszCommandLine,PWSTR *ppszParameters);
typedef enum ASSOCCLASS
{ 
	ASSOCCLASS_SHELL_KEY=0,ASSOCCLASS_PROGID_KEY,ASSOCCLASS_PROGID_STR,ASSOCCLASS_CLSID_KEY,ASSOCCLASS_CLSID_STR,ASSOCCLASS_APP_KEY,ASSOCCLASS_APP_STR,ASSOCCLASS_SYSTEM_STR,ASSOCCLASS_FOLDER,ASSOCCLASS_STAR,} ASSOCCLASS;
typedef struct ASSOCIATIONELEMENT_ {
	ASSOCCLASS ac; 
	HKEY hkClass; 
	PCWSTR pszClass; 
} ASSOCIATIONELEMENT;
SHSTDAPI AssocCreateForClasses(const ASSOCIATIONELEMENT *rgClasses,ULONG cClasses,REFIID riid,void **ppv);
#endif 
#if (NTDDI_VERSION >=NTDDI_WIN2K)
typedef struct _SHQUERYRBINFO {
	DWORD cbSize;
#if !defined(_MAC)||defined(_MAC_INT_64)
	__int64 i64Size;
	__int64 i64NumItems;
#else
	DWORDLONG i64Size;
	DWORDLONG i64NumItems;
#endif
} SHQUERYRBINFO,*LPSHQUERYRBINFO;
#define SHERB_NOCONFIRMATION 1
#define SHERB_NOPROGRESSUI 2
#define SHERB_NOSOUND 4
SHSTDAPI SHQueryRecycleBinA(LPCSTR pszRootPath,LPSHQUERYRBINFO pSHQueryRBInfo);
SHSTDAPI SHQueryRecycleBinW(LPCWSTR pszRootPath,LPSHQUERYRBINFO pSHQueryRBInfo);
#ifdef UNICODE
#define SHQueryRecycleBin SHQueryRecycleBinW
#else
#define SHQueryRecycleBin SHQueryRecycleBinA
#endif 
SHSTDAPI SHEmptyRecycleBinA(HWND hwnd,LPCSTR pszRootPath,DWORD dwFlags);
SHSTDAPI SHEmptyRecycleBinW(HWND hwnd,LPCWSTR pszRootPath,DWORD dwFlags);
#ifdef UNICODE
#define SHEmptyRecycleBin SHEmptyRecycleBinW
#else
#define SHEmptyRecycleBin SHEmptyRecycleBinA
#endif 
#endif 
#if (NTDDI_VERSION >=NTDDI_VISTA)
typedef enum {
	QUNS_NOT_PRESENT=1,QUNS_BUSY=2,QUNS_RUNNING_D3D_FULL_SCREEN=3,QUNS_PRESENTATION_MODE=4,QUNS_ACCEPTS_NOTIFICATIONS=5,
#if (NTDDI_VERSION >=NTDDI_WIN7)
	QUNS_QUIET_TIME=6,
#endif
} QUERY_USER_NOTIFICATION_STATE;
SHSTDAPI SHQueryUserNotificationState(QUERY_USER_NOTIFICATION_STATE *pquns);
#endif 
#if (NTDDI_VERSION >=NTDDI_WIN7)
SHSTDAPI SHGetPropertyStoreForWindow(HWND hwnd,REFIID riid,void**ppv);
#endif 
typedef struct _NOTIFYICONDATAA {
	DWORD cbSize;
	HWND hWnd;
	UINT uID;
	UINT uFlags;
	UINT uCallbackMessage;
	HICON hIcon;
#if (NTDDI_VERSION < NTDDI_WIN2K)
	CHAR szTip[64];
#endif
#if (NTDDI_VERSION >=NTDDI_WIN2K)
	CHAR szTip[128];
	DWORD dwState;
	DWORD dwStateMask;
	CHAR szInfo[256];
	union {
		UINT uTimeout;
		UINT uVersion; 
	} DUMMYUNIONNAME;
	CHAR szInfoTitle[64];
	DWORD dwInfoFlags;
#endif
#if (NTDDI_VERSION >=NTDDI_WINXP)
	GUID guidItem;
#endif
#if (NTDDI_VERSION >=NTDDI_VISTA)
	HICON hBalloonIcon;
#endif
} NOTIFYICONDATAA,*PNOTIFYICONDATAA;
typedef struct _NOTIFYICONDATAW {
	DWORD cbSize;
	HWND hWnd;
	UINT uID;
	UINT uFlags;
	UINT uCallbackMessage;
	HICON hIcon;
#if (NTDDI_VERSION < NTDDI_WIN2K)
	WCHAR szTip[64];
#endif
#if (NTDDI_VERSION >=NTDDI_WIN2K)
	WCHAR szTip[128];
	DWORD dwState;
	DWORD dwStateMask;
	WCHAR szInfo[256];
	union {
		UINT uTimeout;
		UINT uVersion; 
	} DUMMYUNIONNAME;
	WCHAR szInfoTitle[64];
	DWORD dwInfoFlags;
#endif
#if (NTDDI_VERSION >=NTDDI_WINXP)
	GUID guidItem;
#endif
#if (NTDDI_VERSION >=NTDDI_VISTA)
	HICON hBalloonIcon;
#endif
} NOTIFYICONDATAW,*PNOTIFYICONDATAW;
#ifdef UNICODE
typedef NOTIFYICONDATAW NOTIFYICONDATA;
typedef PNOTIFYICONDATAW PNOTIFYICONDATA;
#else
typedef NOTIFYICONDATAA NOTIFYICONDATA;
typedef PNOTIFYICONDATAA PNOTIFYICONDATA;
#endif 
#define NOTIFYICONDATAA_V1_SIZE FIELD_OFFSET(NOTIFYICONDATAA,szTip[64])
#define NOTIFYICONDATAW_V1_SIZE FIELD_OFFSET(NOTIFYICONDATAW,szTip[64])
#ifdef UNICODE
#define NOTIFYICONDATA_V1_SIZE NOTIFYICONDATAW_V1_SIZE
#else
#define NOTIFYICONDATA_V1_SIZE NOTIFYICONDATAA_V1_SIZE
#endif
#define NOTIFYICONDATAA_V2_SIZE FIELD_OFFSET(NOTIFYICONDATAA,guidItem)
#define NOTIFYICONDATAW_V2_SIZE FIELD_OFFSET(NOTIFYICONDATAW,guidItem)
#ifdef UNICODE
#define NOTIFYICONDATA_V2_SIZE NOTIFYICONDATAW_V2_SIZE
#else
#define NOTIFYICONDATA_V2_SIZE NOTIFYICONDATAA_V2_SIZE
#endif
#define NOTIFYICONDATAA_V3_SIZE FIELD_OFFSET(NOTIFYICONDATAA,hBalloonIcon)
#define NOTIFYICONDATAW_V3_SIZE FIELD_OFFSET(NOTIFYICONDATAW,hBalloonIcon)
#ifdef UNICODE
#define NOTIFYICONDATA_V3_SIZE NOTIFYICONDATAW_V3_SIZE
#else
#define NOTIFYICONDATA_V3_SIZE NOTIFYICONDATAA_V3_SIZE
#endif
#if (_WIN32_IE >=0x0500)
#define NIN_SELECT (WM_USER + 0)
#define NINF_KEY 1
#define NIN_KEYSELECT (NIN_SELECT|NINF_KEY)
#endif
#if (_WIN32_IE >=0x0501)
#define NIN_BALLOONSHOW (WM_USER + 2)
#define NIN_BALLOONHIDE (WM_USER + 3)
#define NIN_BALLOONTIMEOUT (WM_USER + 4)
#define NIN_BALLOONUSERCLICK (WM_USER + 5)
#endif
#if (NTDDI_VERSION >=NTDDI_VISTA)
#define NIN_POPUPOPEN (WM_USER + 6)
#define NIN_POPUPCLOSE (WM_USER + 7)
#endif 
#define NIM_ADD 0
#define NIM_MODIFY 1
#define NIM_DELETE 2
#if (_WIN32_IE >=0x0500)
#define NIM_SETFOCUS 3
#define NIM_SETVERSION 4
#define NOTIFYICON_VERSION 3
#if (NTDDI_VERSION >=NTDDI_VISTA)
#define NOTIFYICON_VERSION_4 4
#endif 
#endif
#define NIF_MESSAGE 1
#define NIF_ICON 2
#define NIF_TIP 4
#if (_WIN32_IE >=0x0500)
#define NIF_STATE 8
#define NIF_INFO 16
#endif
#if (_WIN32_IE >=0x600)
#define NIF_GUID 32
#endif
#if (NTDDI_VERSION >=NTDDI_VISTA)
#define NIF_REALTIME 64
#define NIF_SHOWTIP 128
#endif 
#if (_WIN32_IE >=0x0500)
#define NIS_HIDDEN 1
#define NIS_SHAREDICON 2
#define NIIF_NONE 0
#define NIIF_INFO 1
#define NIIF_WARNING 2
#define NIIF_ERROR 3
#if (NTDDI_VERSION >=NTDDI_XPSP2) 
#define NIIF_USER 4
#endif 
#define NIIF_ICON_MASK 15
#if (_WIN32_IE >=0x0501)
#define NIIF_NOSOUND 16
#endif
#endif
#if (NTDDI_VERSION >=NTDDI_VISTA)
#define NIIF_LARGE_ICON 32
#endif 
#if (NTDDI_VERSION >=NTDDI_WIN7)
#define NIIF_RESPECT_QUIET_TIME 128
#endif 
typedef struct _NOTIFYICONIDENTIFIER {
	DWORD cbSize;
	HWND hWnd;
	UINT uID;
	GUID guidItem;
} NOTIFYICONIDENTIFIER,*PNOTIFYICONIDENTIFIER;
SHSTDAPI_(BOOL) Shell_NotifyIconA(DWORD dwMessage,PNOTIFYICONDATAA lpData);
SHSTDAPI_(BOOL) Shell_NotifyIconW(DWORD dwMessage,PNOTIFYICONDATAW lpData);
#ifdef UNICODE
#define Shell_NotifyIcon Shell_NotifyIconW
#else
#define Shell_NotifyIcon Shell_NotifyIconA
#endif 
SHSTDAPI Shell_NotifyIconGetRect(const NOTIFYICONIDENTIFIER*identifier,RECT*iconLocation);
#ifndef SHFILEINFO_DEFINED
#define SHFILEINFO_DEFINED
typedef struct _SHFILEINFOA {
		HICON hIcon; 
		int iIcon; 
		DWORD dwAttributes; 
		CHAR szDisplayName[MAX_PATH]; 
		CHAR szTypeName[80]; 
} SHFILEINFOA;
typedef struct _SHFILEINFOW {
		HICON hIcon; 
		int iIcon; 
		DWORD dwAttributes; 
		WCHAR szDisplayName[MAX_PATH]; 
		WCHAR szTypeName[80]; 
} SHFILEINFOW;
#ifdef UNICODE
typedef SHFILEINFOW SHFILEINFO;
#else
typedef SHFILEINFOA SHFILEINFO;
#endif 
#endif 
#define SHGFI_ICON 256 
#define SHGFI_DISPLAYNAME 512 
#define SHGFI_TYPENAME 1024 
#define SHGFI_ATTRIBUTES 2048 
#define SHGFI_ICONLOCATION 4096 
#define SHGFI_EXETYPE 8192 
#define SHGFI_SYSICONINDEX 16384 
#define SHGFI_LINKOVERLAY 32768 
#define SHGFI_SELECTED 65536 
#if (NTDDI_VERSION >=NTDDI_WIN2K)
#define SHGFI_ATTR_SPECIFIED 0x20000 
#endif 
#define SHGFI_LARGEICON 0 
#define SHGFI_SMALLICON 1 
#define SHGFI_OPENICON 2 
#define SHGFI_SHELLICONSIZE 4 
#define SHGFI_PIDL 8 
#define SHGFI_USEFILEATTRIBUTES 16 
#if (_WIN32_IE >=0x0500)
#define SHGFI_ADDOVERLAYS 32 
#define SHGFI_OVERLAYINDEX 64 
#endif
SHSTDAPI_(DWORD_PTR) SHGetFileInfoA(LPCSTR pszPath,DWORD dwFileAttributes,SHFILEINFOA *psfi,UINT cbFileInfo,UINT uFlags);
SHSTDAPI_(DWORD_PTR) SHGetFileInfoW(LPCWSTR pszPath,DWORD dwFileAttributes,SHFILEINFOW *psfi,UINT cbFileInfo,UINT uFlags);
#ifdef UNICODE
#define SHGetFileInfo SHGetFileInfoW
#else
#define SHGetFileInfo SHGetFileInfoA
#endif 
#if (NTDDI_VERSION >=NTDDI_VISTA)
typedef struct _SHSTOCKICONINFO {
	DWORD cbSize;
	HICON hIcon;
	int iSysImageIndex;
	int iIcon;
	WCHAR szPath[MAX_PATH];
} SHSTOCKICONINFO;
#define SHGSI_ICONLOCATION 0 
#define SHGSI_ICON SHGFI_ICON
#define SHGSI_SYSICONINDEX SHGFI_SYSICONINDEX
#define SHGSI_LINKOVERLAY SHGFI_LINKOVERLAY
#define SHGSI_SELECTED SHGFI_SELECTED
#define SHGSI_LARGEICON SHGFI_LARGEICON
#define SHGSI_SMALLICON SHGFI_SMALLICON
#define SHGSI_SHELLICONSIZE SHGFI_SHELLICONSIZE
typedef enum SHSTOCKICONID {
	SIID_DOCNOASSOC=0,SIID_DOCASSOC=1,SIID_APPLICATION=2,SIID_FOLDER=3,SIID_FOLDEROPEN=4,SIID_DRIVE525=5,SIID_DRIVE35=6,SIID_DRIVEREMOVE=7,SIID_DRIVEFIXED=8,SIID_DRIVENET=9,SIID_DRIVENETDISABLED=10,SIID_DRIVECD=11,SIID_DRIVERAM=12,
	SIID_WORLD=13,SIID_SERVER=15,SIID_PRINTER=16,SIID_MYNETWORK=17,SIID_FIND=22,SIID_HELP=23,SIID_SHARE=28,SIID_LINK=29,SIID_SLOWFILE=30,SIID_RECYCLER=31,SIID_RECYCLERFULL=32,SIID_MEDIACDAUDIO=40,SIID_LOCK=47,SIID_AUTOLIST=49,
	SIID_PRINTERNET=50,SIID_SERVERSHARE=51,SIID_PRINTERFAX=52,SIID_PRINTERFAXNET=53,SIID_PRINTERFILE=54,SIID_STACK=55,SIID_MEDIASVCD=56,SIID_STUFFEDFOLDER=57,SIID_DRIVEUNKNOWN=58,SIID_DRIVEDVD=59,SIID_MEDIADVD=60,SIID_MEDIADVDRAM=61,
	SIID_MEDIADVDRW=62,SIID_MEDIADVDR=63,SIID_MEDIADVDROM=64,SIID_MEDIACDAUDIOPLUS=65,SIID_MEDIACDRW=66,SIID_MEDIACDR=67,SIID_MEDIACDBURN=68,SIID_MEDIABLANKCD=69,SIID_MEDIACDROM=70,SIID_AUDIOFILES=71,SIID_IMAGEFILES=72,SIID_VIDEOFILES=73,
	SIID_MIXEDFILES=74,SIID_FOLDERBACK=75,SIID_FOLDERFRONT=76,SIID_SHIELD=77,SIID_WARNING=78,SIID_INFO=79,SIID_ERROR=80,SIID_KEY=81,SIID_SOFTWARE=82,SIID_RENAME=83,SIID_DELETE=84,SIID_MEDIAAUDIODVD=85,SIID_MEDIAMOVIEDVD=86,
	SIID_MEDIAENHANCEDCD=87,SIID_MEDIAENHANCEDDVD=88,SIID_MEDIAHDDVD=89,SIID_MEDIABLURAY=90,SIID_MEDIAVCD=91,SIID_MEDIADVDPLUSR=92,SIID_MEDIADVDPLUSRW=93,SIID_DESKTOPPC=94,SIID_MOBILEPC=95,SIID_USERS=96,SIID_MEDIASMARTMEDIA=97,
	SIID_MEDIACOMPACTFLASH=98,SIID_DEVICECELLPHONE=99,SIID_DEVICECAMERA=100,SIID_DEVICEVIDEOCAMERA=101,SIID_DEVICEAUDIOPLAYER=102,SIID_NETWORKCONNECT=103,SIID_INTERNET=104,SIID_ZIPFILE=105,SIID_SETTINGS=106,SIID_DRIVEHDDVD=132,
	SIID_DRIVEBD=133,SIID_MEDIAHDDVDROM=134,SIID_MEDIAHDDVDR=135,SIID_MEDIAHDDVDRAM=136,SIID_MEDIABDROM=137,SIID_MEDIABDR=138,SIID_MEDIABDRE=139,SIID_CLUSTEREDDRIVE=140,SIID_MAX_ICONS=174,} SHSTOCKICONID;
#define SIID_INVALID ((SHSTOCKICONID)-1)
SHSTDAPI SHGetStockIconInfo(SHSTOCKICONID siid,UINT uFlags,SHSTOCKICONINFO *psii);
#endif 
#if (NTDDI_VERSION >=NTDDI_WIN2K)
#define SHGetDiskFreeSpace SHGetDiskFreeSpaceEx
SHSTDAPI_(BOOL) SHGetDiskFreeSpaceExA(LPCSTR pszDirectoryName,ULARGE_INTEGER*pulFreeBytesAvailableToCaller,ULARGE_INTEGER*pulTotalNumberOfBytes,ULARGE_INTEGER*pulTotalNumberOfFreeBytes);
SHSTDAPI_(BOOL) SHGetDiskFreeSpaceExW(LPCWSTR pszDirectoryName,ULARGE_INTEGER*pulFreeBytesAvailableToCaller,ULARGE_INTEGER*pulTotalNumberOfBytes,ULARGE_INTEGER*pulTotalNumberOfFreeBytes);
#ifdef UNICODE
#define SHGetDiskFreeSpaceEx SHGetDiskFreeSpaceExW
#else
#define SHGetDiskFreeSpaceEx SHGetDiskFreeSpaceExA
#endif 
SHSTDAPI_(BOOL) SHGetNewLinkInfoA(LPCSTR pszLinkTo,LPCSTR pszDir,LPSTR pszName,BOOL *pfMustCopy,UINT uFlags);
SHSTDAPI_(BOOL) SHGetNewLinkInfoW(LPCWSTR pszLinkTo,LPCWSTR pszDir,LPWSTR pszName,BOOL *pfMustCopy,UINT uFlags);
#ifdef UNICODE
#define SHGetNewLinkInfo SHGetNewLinkInfoW
#else
#define SHGetNewLinkInfo SHGetNewLinkInfoA
#endif 
#define SHGNLI_PIDL 1 
#define SHGNLI_PREFIXNAME 2 
#define SHGNLI_NOUNIQUE 4 
#if (_WIN32_IE >=0x0501)
#define SHGNLI_NOLNK 8 
#endif 
#if (_WIN32_IE >=0x0600)
#define SHGNLI_NOLOCNAME 16 
#endif
#if (NTDDI_VERSION >=NTDDI_WIN7)
#define SHGNLI_USEURLEXT 32 
#endif
#endif 
#if (NTDDI_VERSION >=NTDDI_WIN2K)
#define PRINTACTION_OPEN 0 
#define PRINTACTION_PROPERTIES 1 
#define PRINTACTION_NETINSTALL 2 
#define PRINTACTION_NETINSTALLLINK 3 
#define PRINTACTION_TESTPAGE 4 
#define PRINTACTION_OPENNETPRN 5 
#define PRINTACTION_DOCUMENTDEFAULTS 6 
#define PRINTACTION_SERVERPROPERTIES 7 
SHSTDAPI_(BOOL) SHInvokePrinterCommandA(HWND hwnd,UINT uAction,LPCSTR lpBuf1,LPCSTR lpBuf2,BOOL fModal);
SHSTDAPI_(BOOL) SHInvokePrinterCommandW(HWND hwnd,UINT uAction,LPCWSTR lpBuf1,LPCWSTR lpBuf2,BOOL fModal);
#ifdef UNICODE
#define SHInvokePrinterCommand SHInvokePrinterCommandW
#else
#define SHInvokePrinterCommand SHInvokePrinterCommandA
#endif 
#endif 
#if (NTDDI_VERSION >=NTDDI_VISTA)
typedef struct _OPEN_PRINTER_PROPS_INFOA {
	DWORD dwSize;
	LPSTR pszSheetName;
	UINT uSheetIndex;
	DWORD dwFlags;
	BOOL bModal;
} OPEN_PRINTER_PROPS_INFOA,*POPEN_PRINTER_PROPS_INFOA;
typedef struct _OPEN_PRINTER_PROPS_INFOW {
	DWORD dwSize;
	LPWSTR pszSheetName;
	UINT uSheetIndex;
	DWORD dwFlags;
	BOOL bModal;
} OPEN_PRINTER_PROPS_INFOW,*POPEN_PRINTER_PROPS_INFOW;
#ifdef UNICODE
typedef OPEN_PRINTER_PROPS_INFOW OPEN_PRINTER_PROPS_INFO;
typedef POPEN_PRINTER_PROPS_INFOW POPEN_PRINTER_PROPS_INFO;
#else
typedef OPEN_PRINTER_PROPS_INFOA OPEN_PRINTER_PROPS_INFO;
typedef POPEN_PRINTER_PROPS_INFOA POPEN_PRINTER_PROPS_INFO;
#endif 
#define PRINT_PROP_FORCE_NAME 1
#endif 
#endif 
#if (_WIN32_WINNT >=0x0500)||(_WIN32_WINDOWS >=0x0500)
SHSTDAPI SHLoadNonloadedIconOverlayIdentifiers(void);
SHSTDAPI SHIsFileAvailableOffline(LPCWSTR pwszPath,LPDWORD pdwStatus);
#define OFFLINE_STATUS_LOCAL 1 
#define OFFLINE_STATUS_REMOTE 2 
#define OFFLINE_STATUS_INCOMPLETE 4 
#endif
#if (NTDDI_VERSION >=NTDDI_WINXP)
SHSTDAPI SHSetLocalizedName(LPCWSTR pszPath,LPCWSTR pszResModule,int idsRes);
#endif 
#if (NTDDI_VERSION >=NTDDI_VISTA)
SHSTDAPI SHRemoveLocalizedName(LPCWSTR pszPath);
SHSTDAPI SHGetLocalizedName(LPCWSTR pszPath,LPWSTR pszResModule,UINT cch,int *pidsRes);
#endif 
#if !defined(_SHLWAPI_)
#define LWSTDAPIV_(type) EXTERN_C DECLSPEC_IMPORT type STDAPIVCALLTYPE
#else
#define LWSTDAPIV_(type) STDAPIV_(type)
#endif
LWSTDAPIV_(int) ShellMessageBoxA(HINSTANCE hAppInst,HWND hWnd,LPCSTR lpcText,LPCSTR lpcTitle,UINT fuStyle,...);
LWSTDAPIV_(int) ShellMessageBoxW(HINSTANCE hAppInst,HWND hWnd,LPCWSTR lpcText,LPCWSTR lpcTitle,UINT fuStyle,...);
#ifdef UNICODE
#define ShellMessageBox ShellMessageBoxW
#else
#define ShellMessageBox ShellMessageBoxA
#endif 
#if (NTDDI_VERSION >=NTDDI_WIN2K)
SHSTDAPI_(BOOL) IsLFNDriveA(LPCSTR pszPath);
SHSTDAPI_(BOOL) IsLFNDriveW(LPCWSTR pszPath);
#ifdef UNICODE
#define IsLFNDrive IsLFNDriveW
#else
#define IsLFNDrive IsLFNDriveA
#endif 
#endif 
#if _WIN32_IE >=0x0600
STDAPI SHEnumerateUnreadMailAccountsA(HKEY hKeyUser,DWORD dwIndex,LPSTR pszMailAddress,int cchMailAddress);
STDAPI SHEnumerateUnreadMailAccountsW(HKEY hKeyUser,DWORD dwIndex,LPWSTR pszMailAddress,int cchMailAddress);
#ifdef UNICODE
#define SHEnumerateUnreadMailAccounts SHEnumerateUnreadMailAccountsW
#else
#define SHEnumerateUnreadMailAccounts SHEnumerateUnreadMailAccountsA
#endif 
STDAPI SHGetUnreadMailCountA(HKEY hKeyUser,LPCSTR pszMailAddress,DWORD *pdwCount,FILETIME *pFileTime,LPSTR pszShellExecuteCommand,int cchShellExecuteCommand);
STDAPI SHGetUnreadMailCountW(HKEY hKeyUser,LPCWSTR pszMailAddress,DWORD *pdwCount,FILETIME *pFileTime,LPWSTR pszShellExecuteCommand,int cchShellExecuteCommand);
#ifdef UNICODE
#define SHGetUnreadMailCount SHGetUnreadMailCountW
#else
#define SHGetUnreadMailCount SHGetUnreadMailCountA
#endif 
STDAPI SHSetUnreadMailCountA(LPCSTR pszMailAddress,DWORD dwCount,LPCSTR pszShellExecuteCommand);
STDAPI SHSetUnreadMailCountW(LPCWSTR pszMailAddress,DWORD dwCount,LPCWSTR pszShellExecuteCommand);
#ifdef UNICODE
#define SHSetUnreadMailCount SHSetUnreadMailCountW
#else
#define SHSetUnreadMailCount SHSetUnreadMailCountA
#endif 
#endif 
#if (_WIN32_IE >=0x0601)
STDAPI_(BOOL) SHTestTokenMembership(HANDLE hToken,ULONG ulRID);
#endif 
#if _WIN32_IE >=0x0600
#if (NTDDI_VERSION >=NTDDI_WINXP)
SHSTDAPI SHGetImageList(int iImageList,REFIID riid,void **ppvObj);
#endif 
#if (NTDDI_VERSION >=NTDDI_WINXP)
#define SHIL_LARGE 0 
#define SHIL_SMALL 1 
#define SHIL_EXTRALARGE 2
#define SHIL_SYSSMALL 3 
#if (NTDDI_VERSION >=NTDDI_VISTA)
#define SHIL_JUMBO 4 
#define SHIL_LAST SHIL_JUMBO
#else
#define SHIL_LAST SHIL_SYSSMALL
#endif 
#endif 
typedef HRESULT (*PFNCANSHAREFOLDERW)(LPCWSTR pszPath);
typedef HRESULT (*PFNSHOWSHAREFOLDERUIW)(HWND hwndParent,LPCWSTR pszPath);
#endif 
//#if !defined(_WIN64)
//#include <poppack.h>
//#endif
#if (NTDDI_VERSION >=NTDDI_VISTA)
#define WC_NETADDRESS L"msctls_netaddress"
SHSTDAPI_(BOOL) InitNetworkAddressControl(void);
#define NCM_GETADDRESS (WM_USER+1)
#define NetAddr_GetAddress(hwnd,pv)(HRESULT)SNDMSG(hwnd,NCM_GETADDRESS,0,(LPARAM)pv)
typedef struct tagNC_ADDRESS {
 struct NET_ADDRESS_INFO_ *pAddrInfo; 
 USHORT PortNumber;
 BYTE PrefixLength;
} NC_ADDRESS,*PNC_ADDRESS;
#define NCM_SETALLOWTYPE (WM_USER+2)
#define NetAddr_SetAllowType(hwnd,addrMask)(HRESULT)SNDMSG(hwnd,NCM_SETALLOWTYPE,(WPARAM)addrMask,0)
#define NCM_GETALLOWTYPE (WM_USER+3)
#define NetAddr_GetAllowType(hwnd)(DWORD)SNDMSG(hwnd,NCM_GETALLOWTYPE,0,0)
#define NCM_DISPLAYERRORTIP (WM_USER+4)
#define NetAddr_DisplayErrorTip(hwnd)(HRESULT)SNDMSG(hwnd,NCM_DISPLAYERRORTIP,0,0)
#endif 
#if (NTDDI_VERSION >=NTDDI_VISTA)
STDAPI SHGetDriveMedia(LPCWSTR pszDrive,DWORD *pdwMediaContent);
#endif 
#endif 
=== signal.h 0 0 83/108 ===
/* Header signal.h */

#define SIGINT    2
#define SIGILL    4
#define SIGFPE    8
#define SIGSEGV  11
#define SIGTERM  15
#define SIGBREAK 21
#define SIGABRT  22

#define SIG_DFL (void (*)(int))0
#define SIG_IGN (void (*)(int))1
#define SIG_SGE (void (*)(int))3
#define SIG_ACK (void (*)(int))4

#define SIG_ERR (void (*)(int))-1

extern void (*signal(int, void (*)(int)))(int);

extern int raise(int);


typedef int sig_atomic_t;
=== smallwindows.h 0 0 84/108 ===
#ifndef $windows
#define $windows 1

#include <stdarg.h>
#include <stddef.h>

#define ETO_CLIPPED	4
#define ETO_GLYPH_INDEX	16
#define ETO_OPAQUE	2
#define ETO_RTLREADING	128
#define ETO_PDY	0x2000
#define ETO_NUMERICSLOCAL	0x0400
#define ETO_NUMERICSLATIN	0x0800
#define ETO_IGNORELANGUAGE	0x1000

#define DC_BRUSH        18
#define DC_PEN         19
#define REG_OPTION_VOLATILE	1
#define REG_OPTION_NON_VOLATILE	0
#define REG_CREATED_NEW_KEY	1
#define REG_OPENED_EXISTING_KEY	2
#define REG_BINARY	3
#define REG_DWORD	4
#define REG_DWORD_LITTLE_ENDIAN	4
#define REG_DWORD_BIG_ENDIAN	5
#define REG_EXPAND_SZ	2
#define REG_LINK	6
#define REG_MULTI_SZ	7
#define REG_NONE	0
#define REG_RESOURCE_LIST	8
#define REG_FULL_RESOURCE_DESCRIPTOR 9
#define REG_RESOURCE_REQUIREMENTS_LIST 10
#define REG_SZ	1
#define NEAR
#define LPTR 64

#define APIENTRY
#define WAVE_MAPPER 0xFFFFFFFF
#define CALLBACK_FUNCTION 0x30000

#define IMAGE_NT_SIGNATURE
#define DUMMYUNIONNAME

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16
//#define IMAGE_SIZEOF_SHORT_NAME 8

//#define IMAGE_DIRECTORY_ENTRY_BASERELOC 5

#define IMAGE_DOS_SIGNATURE 0x5A4D
#define IMAGE_OS2_SIGNATURE 0x454E
#define IMAGE_OS2_SIGNATURE_LE 0x454C
#define IMAGE_VXD_SIGNATURE 0x454C
#define IMAGE_NT_SIGNATURE 0x4550
#define IMAGE_SIZEOF_FILE_HEADER 20
#define IMAGE_FILE_RELOCS_STRIPPED 1
#define IMAGE_FILE_EXECUTABLE_IMAGE 2
#define IMAGE_FILE_LINE_NUMS_STRIPPED 4
#define IMAGE_FILE_LOCAL_SYMS_STRIPPED 8
#define IMAGE_FILE_BYTES_REVERSED_LO 128
#define IMAGE_FILE_32BIT_MACHINE 256
#define IMAGE_FILE_DEBUG_STRIPPED 512
#define IMAGE_FILE_SYSTEM 0x1000
#define IMAGE_FILE_DLL 0x2000
#define IMAGE_FILE_BYTES_REVERSED_HI 0x8000
#define IMAGE_FILE_MACHINE_UNKNOWN 0
#define IMAGE_FILE_MACHINE_I386 0x14c
#define IMAGE_FILE_MACHINE_R3000 0x162
#define IMAGE_FILE_MACHINE_R4000 0x166
#define IMAGE_FILE_MACHINE_R10000 0x168
#define IMAGE_FILE_MACHINE_ALPHA 0x184
#define IMAGE_FILE_MACHINE_POWERPC 0x1F0
#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16
#define IMAGE_SIZEOF_ROM_OPTIONAL_HEADER 56
#define IMAGE_SIZEOF_STD_OPTIONAL_HEADER 28
#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER 224
#define IMAGE_NT_OPTIONAL_HDR_MAGIC 0x10b
#define IMAGE_ROM_OPTIONAL_HDR_MAGIC 0x107
#define IMAGE_FIRST_SECTION(nth) ((PIMAGE_SECTION_HEADER) \
 ((DWORD)nth + FIELD_OFFSET( IMAGE_NT_HEADERS,OptionalHeader ) + \
 ((PIMAGE_NT_HEADERS)(nth))->FileHeader.SizeOfOptionalHeader))
#define IMAGE_SUBSYSTEM_UNKNOWN 0
#define IMAGE_SUBSYSTEM_NATIVE 1
#define IMAGE_SUBSYSTEM_WINDOWS_GUI 2
#define IMAGE_SUBSYSTEM_WINDOWS_CUI 3
#define IMAGE_SUBSYSTEM_OS2_CUI 5
#define IMAGE_SUBSYSTEM_POSIX_CUI 7
#define IMAGE_SUBSYSTEM_WINDOWS_CE_GUI 9
#define IMAGE_DIRECTORY_ENTRY_EXPORT 0
#define IMAGE_DIRECTORY_ENTRY_IMPORT 1
#define IMAGE_DIRECTORY_ENTRY_RESOURCE 2
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3
#define IMAGE_DIRECTORY_ENTRY_SECURITY 4
#define IMAGE_DIRECTORY_ENTRY_BASERELOC 5
#define IMAGE_DIRECTORY_ENTRY_DEBUG 6
#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT 7
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8
#define IMAGE_DIRECTORY_ENTRY_TLS 9
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11
#define IMAGE_DIRECTORY_ENTRY_IAT 12
#define IMAGE_SIZEOF_SHORT_NAME 8
#define IMAGE_SIZEOF_SECTION_HEADER 40
#define IMAGE_SCN_TYPE_NO_PAD 8
#define IMAGE_SCN_CNT_CODE 32
#define IMAGE_SCN_CNT_INITIALIZED_DATA 64
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA 128
#define IMAGE_SCN_LNK_OTHER 256
#define IMAGE_SCN_LNK_INFO 512
#define IMAGE_SCN_LNK_REMOVE 0x800
#define IMAGE_SCN_LNK_COMDAT 0x1000
#define IMAGE_SCN_MEM_FARDATA 0x8000
#define IMAGE_SCN_MEM_PURGEABLE 0x20000
#define IMAGE_SCN_MEM_16BIT 0x20000
#define IMAGE_SCN_MEM_LOCKED 0x40000
#define IMAGE_SCN_MEM_PRELOAD 0x80000
#define IMAGE_SCN_ALIGN_1BYTES 0x100000
#define IMAGE_SCN_ALIGN_2BYTES 0x200000
#define IMAGE_SCN_ALIGN_4BYTES 0x300000
#define IMAGE_SCN_ALIGN_8BYTES 0x400000
#define IMAGE_SCN_ALIGN_16BYTES 0x500000
#define IMAGE_SCN_ALIGN_32BYTES 0x600000
#define IMAGE_SCN_ALIGN_64BYTES 0x700000
#define IMAGE_SCN_LNK_NRELOC_OVFL 0x1000000
#define IMAGE_SCN_MEM_DISCARDABLE 0x2000000
#define IMAGE_SCN_MEM_NOT_CACHED 0x4000000
#define IMAGE_SCN_MEM_NOT_PAGED 0x8000000
#define IMAGE_SCN_MEM_SHARED 0x10000000
#define IMAGE_SCN_MEM_EXECUTE 0x20000000
#define IMAGE_SCN_MEM_READ 0x40000000
#define IMAGE_SCN_MEM_WRITE 0x80000000
#define IMAGE_SIZEOF_SYMBOL 18
#define IMAGE_SYM_UNDEFINED (SHORT)0
#define IMAGE_SYM_ABSOLUTE (SHORT)-1
#define IMAGE_SYM_DEBUG (SHORT)-2
#define IMAGE_SYM_TYPE_NULL 0
#define IMAGE_SYM_TYPE_VOID 1
#define IMAGE_SYM_TYPE_CHAR 2
#define IMAGE_SYM_TYPE_SHORT 3
#define IMAGE_SYM_TYPE_INT 4
#define IMAGE_SYM_TYPE_LONG 5
#define IMAGE_SYM_TYPE_FLOAT 6
#define IMAGE_SYM_TYPE_DOUBLE 7
#define IMAGE_SYM_TYPE_STRUCT 8
#define IMAGE_SYM_TYPE_UNION 9
#define IMAGE_SYM_TYPE_ENUM 10
#define IMAGE_SYM_TYPE_MOE 11
#define IMAGE_SYM_TYPE_BYTE 12
#define IMAGE_SYM_TYPE_WORD 13
#define IMAGE_SYM_TYPE_UINT 14
#define IMAGE_SYM_TYPE_DWORD 15
#define IMAGE_SYM_TYPE_PCODE 0x8000
#define IMAGE_SYM_DTYPE_NULL 0
#define IMAGE_SYM_DTYPE_POINTER 1
#define IMAGE_SYM_DTYPE_FUNCTION 2
#define IMAGE_SYM_DTYPE_ARRAY 3
#define IMAGE_SYM_CLASS_END_OF_FUNCTION (BYTE )-1
#define IMAGE_SYM_CLASS_NULL 0
#define IMAGE_SYM_CLASS_AUTOMATIC 1
#define IMAGE_SYM_CLASS_EXTERNAL 2
#define IMAGE_SYM_CLASS_STATIC 3
#define IMAGE_SYM_CLASS_REGISTER 4
#define IMAGE_SYM_CLASS_EXTERNAL_DEF 5
#define IMAGE_SYM_CLASS_LABEL 6
#define IMAGE_SYM_CLASS_UNDEFINED_LABEL 7
#define IMAGE_SYM_CLASS_MEMBER_OF_STRUCT 8
#define IMAGE_SYM_CLASS_ARGUMENT 9
#define IMAGE_SYM_CLASS_STRUCT_TAG 10
#define IMAGE_SYM_CLASS_MEMBER_OF_UNION 11
#define IMAGE_SYM_CLASS_UNION_TAG 12
#define IMAGE_SYM_CLASS_TYPE_DEFINITION 13
#define IMAGE_SYM_CLASS_UNDEFINED_STATIC 14
#define IMAGE_SYM_CLASS_ENUM_TAG 15
#define IMAGE_SYM_CLASS_MEMBER_OF_ENUM 16
#define IMAGE_SYM_CLASS_REGISTER_PARAM 17
#define IMAGE_SYM_CLASS_BIT_FIELD 18
#define IMAGE_SYM_CLASS_FAR_EXTERNAL 0x44
#define IMAGE_SYM_CLASS_BLOCK 0x64
#define IMAGE_SYM_CLASS_FUNCTION 0x65
#define IMAGE_SYM_CLASS_END_OF_STRUCT 0x66
#define IMAGE_SYM_CLASS_FILE 0x67
#define IMAGE_SYM_CLASS_SECTION 0x68
#define IMAGE_SYM_CLASS_WEAK_EXTERNAL 0x69



#define MAKEWORD(a,b)	((WORD)(((BYTE)(((DWORD_PTR)(a))&0xFF))|(((WORD)((BYTE)(((DWORD_PTR)(b))&0xFF)))<<8)))
#define LOBYTE(w)	((BYTE)(((DWORD_PTR)(w))&0xFF))
#define HIBYTE(w)	((BYTE)((((DWORD_PTR)(w))>>8)&0xFF))

#define MAKELANGID(p,s)	((((WORD)(s))<<10)|(WORD)(p))
#define SUBLANG_DEFAULT	0x01
#define LANG_NEUTRAL 0x00


//#define __int64 long long int
#define TA_BASELINE	24
#define TA_BOTTOM	8
#define TA_TOP	0
#define TA_CENTER	6
#define TA_LEFT	0
#define TA_RIGHT	2
#define TA_RTLREADING	256
#define TA_MASK	(TA_BASELINE+TA_CENTER+TA_UPDATECP+TA_RTLREADING)
#define TA_NOUPDATECP	0
#define TA_UPDATECP	1

#define GetRValue(rgb) ((BYTE) (rgb))
#define GetGValue(rgb) ((BYTE) (((WORD) (rgb)) >> 8))
#define GetBValue(rgb) ((BYTE) ((rgb) >> 16))

#define ANSI_CHARSET 0

#define OUT_DEFAULT_PRECIS	0
#define OUT_STRING_PRECIS	1
#define OUT_CHARACTER_PRECIS	2
#define OUT_STROKE_PRECIS	3
#define OUT_TT_PRECIS	4
#define OUT_DEVICE_PRECIS	5
#define OUT_RASTER_PRECIS	6
#define OUT_TT_ONLY_PRECIS	7
#define OUT_OUTLINE_PRECIS	8
#define CLIP_DEFAULT_PRECIS	0
#define CLIP_CHARACTER_PRECIS	1
#define CLIP_STROKE_PRECIS	2
#define CLIP_MASK	15
#define CLIP_LH_ANGLES	16
#define CLIP_TT_ALWAYS	32
#define CLIP_EMBEDDED	128
#define DEFAULT_QUALITY	0
#define DRAFT_QUALITY	1
#define PROOF_QUALITY	2
#define NONANTIALIASED_QUALITY	3
#define ANTIALIASED_QUALITY	4
#define DEFAULT_PITCH	0
#define FIXED_PITCH	1
#define VARIABLE_PITCH	2
#define FF_DECORATIVE	80
#define FF_DONTCARE	0
#define FF_MODERN	48
#define FF_ROMAN	16
#define FF_SCRIPT	64
#define FF_SWISS	32
#define HS_BDIAGONAL	3
#define HS_CROSS	4
#define HS_DIAGCROSS	5
#define HS_FDIAGONAL	2
#define HS_HORIZONTAL	0
#define HS_VERTICAL	1
#define LR_DEFAULTCOLOR	0
#define LR_LOADREALSIZE	128
#define LR_MONOCHROME	1
#define LR_COPYRETURNORG 4
#define LR_COPYDELETEORG 8
#define LR_LOADFROMFILE	16
#define LR_LOADTRANSPARENT 32
#define LR_DEFAULTSIZE	64
#define LR_VGACOLOR	0x80
#define LR_LOADMAP3DCOLORS 0x1000
#define LR_CREATEDIBSECTION 0x2000
#define LR_COPYFROMRESOURCE 0x4000
#define LR_SHARED	0x8000

#define FW_DONTCARE	0
#define FW_THIN	100
#define FW_EXTRALIGHT	200
#define FW_LIGHT	300
#define FW_NORMAL	400
#define FW_REGULAR	400
#define FW_MEDIUM	500
#define FW_SEMIBOLD	600
#define FW_BOLD	700
#define FW_EXTRABOLD	800
#define FW_HEAVY	900

#define	SM_CXSCREEN	0
#define	SM_CYSCREEN	1
#define	SM_CXVSCROLL	2
#define	SM_CYHSCROLL	3
#define	SM_CYCAPTION	4
#define	SM_CXBORDER	5
#define	SM_CYBORDER	6
#define	SM_CXDLGFRAME	7
#define	SM_CYDLGFRAME	8
#define	SM_CYVTHUMB	9
#define	SM_CXHTHUMB	10
#define	SM_CXICON	11
#define	SM_CYICON	12
#define	SM_CXCURSOR	13
#define	SM_CYCURSOR	14
#define	SM_CYMENU	15
#define	SM_CXFULLSCREEN	16
#define	SM_CYFULLSCREEN	17
#define	SM_CYKANJIWINDOW	18
#define	SM_MOUSEPRESENT	19
#define	SM_CYVSCROLL	20
#define	SM_CXHSCROLL	21
#define	SM_DEBUG	22
#define	SM_SWAPBUTTON	23
#define	SM_RESERVED1	24
#define	SM_RESERVED2	25
#define	SM_RESERVED3	26
#define	SM_RESERVED4	27
#define	SM_CXMIN	28
#define	SM_CYMIN	29
#define	SM_CXSIZE	30
#define	SM_CYSIZE	31
#define	SM_CXFRAME	32
#define	SM_CYFRAME	33
#define	SM_CXMINTRACK	34
#define	SM_CYMINTRACK	35
#define	SM_CXDOUBLECLK	36
#define	SM_CYDOUBLECLK	37
#define	SM_CXICONSPACING	38
#define	SM_CYICONSPACING	39
#define	SM_MENUDROPALIGNMENT	40
#define	SM_PENWINDOWS	41
#define	SM_DBCSENABLED	42
#define	SM_CMOUSEBUTTONS	43
#define	SM_CXFIXEDFRAME	SM_CXDLGFRAME
#define	SM_CYFIXEDFRAME	SM_CYDLGFRAME
#define	SM_CXSIZEFRAME	SM_CXFRAME
#define	SM_CYSIZEFRAME	SM_CYFRAME
#define	SM_SECURE	44
#define	SM_CXEDGE	45
#define	SM_CYEDGE	46
#define	SM_CXMINSPACING	47
#define	SM_CYMINSPACING	48
#define	SM_CXSMICON	49
#define	SM_CYSMICON	50
#define	SM_CYSMCAPTION	51
#define	SM_CXSMSIZE	52
#define	SM_CYSMSIZE	53
#define	SM_CXMENUSIZE	54
#define	SM_CYMENUSIZE	55
#define	SM_ARRANGE	56
#define	SM_CXMINIMIZED	57
#define	SM_CYMINIMIZED	58
#define	SM_CXMAXTRACK	59
#define	SM_CYMAXTRACK	60
#define	SM_CXMAXIMIZED	61
#define	SM_CYMAXIMIZED	62
#define	SM_NETWORK	63
#define	SM_CLEANBOOT	67
#define	SM_CXDRAG	68
#define	SM_CYDRAG	69
#define	SM_SHOWSOUNDS	70
#define	SM_CXMENUCHECK	71
#define	SM_CYMENUCHECK	72
#define	SM_SLOWMACHINE	73
#define	SM_MIDEASTENABLED	74
#define	SM_MOUSEWHEELPRESENT	75
#define	SM_XVIRTUALSCREEN	76
#define	SM_YVIRTUALSCREEN	77
#define	SM_CXVIRTUALSCREEN	78
#define	SM_CYVIRTUALSCREEN	79
#define	SM_CMONITORS	80
#define	SM_SAMEDISPLAYFORMAT	81
#define	SM_CMETRICS	76

#define SWP_DRAWFRAME	32
#define SWP_FRAMECHANGED	32
#define SWP_HIDEWINDOW	128
#define SWP_NOACTIVATE	16
#define SWP_NOCOPYBITS	256
#define SWP_NOMOVE	2
#define SWP_NOSIZE	1
#define SWP_NOREDRAW	8
#define SWP_NOZORDER	4
#define SWP_SHOWWINDOW	64
#define SWP_NOOWNERZORDER	512
#define SWP_NOREPOSITION	512
#define SWP_NOSENDCHANGING	1024

#define LF_FACESIZE	32
#define LF_FULLFACESIZE	64

#define FOREGROUND_BLUE	1
#define FOREGROUND_GREEN	2
#define FOREGROUND_RED	4
#define FOREGROUND_INTENSITY	8
#define BACKGROUND_BLUE	16
#define BACKGROUND_GREEN	32
#define BACKGROUND_RED	64

#define CTRL_C_EVENT	0
#define CTRL_BREAK_EVENT	1
#define CTRL_CLOSE_EVENT	2
#define CTRL_LOGOFF_EVENT	5
#define CTRL_SHUTDOWN_EVENT	6

#define INVALID_HANDLE_VALUE (HANDLE)(0xFFFFFFFFFFFFFFFF)
#define INVALID_FILE_SIZE ((DWORD)0xFFFFFFFFFFFFFFFF)
#define INVALID_SET_FILE_POINTER ((DWORD)-1)
#define INVALID_FILE_ATTRIBUTES ((DWORD)-1)

#define Int32x32To64(a,b)(((long long)((long)(a))) *((long long)((long)(b))))

#define PAGE_READONLY 2
#define PAGE_READWRITE 4
#define PAGE_WRITECOPY 8

#define FILE_BEGIN 0
#define FILE_CURRENT 1
#define FILE_END 2

#define FILE_READ_DATA	1
#define FILE_LIST_DIRECTORY	1
#define FILE_WRITE_DATA	2
#define FILE_ADD_FILE	2
#define FILE_APPEND_DATA	4
#define FILE_ADD_SUBDIRECTORY	4
#define FILE_CREATE_PIPE_INSTANCE 4
#define FILE_READ_EA	8
#define FILE_WRITE_EA	0x10
#define FILE_EXECUTE	0x20
#define FILE_TRAVERSE	0x0020
#define FILE_DELETE_CHILD	0x0040
#define FILE_READ_ATTRIBUTES	0x0080
#define FILE_WRITE_ATTRIBUTES	0x100
#define FILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x1FF)
#define FILE_GENERIC_READ (STANDARD_RIGHTS_READ|FILE_READ_DATA| FILE_READ_ATTRIBUTES|FILE_READ_EA|SYNCHRONIZE)
#define FILE_GENERIC_WRITE (STANDARD_RIGHTS_WRITE|FILE_WRITE_DATA|FILE_WRITE_ATTRIBUTES|FILE_WRITE_EA|FILE_APPEND_DATA|SYNCHRONIZE)
#define FILE_GENERIC_EXECUTE (STANDARD_RIGHTS_EXECUTE|FILE_READ_ATTRIBUTES|FILE_EXECUTE|SYNCHRONIZE)

#define FILE_FLAG_WRITE_THROUGH 0x80000000
#define FILE_FLAG_OVERLAPPED 1073741824
#define FILE_FLAG_NO_BUFFERING 536870912
#define FILE_FLAG_RANDOM_ACCESS 268435456
#define FILE_FLAG_SEQUENTIAL_SCAN 134217728
#define FILE_FLAG_DELETE_ON_CLOSE 67108864
#define FILE_FLAG_BACKUP_SEMANTICS 33554432
#define FILE_FLAG_POSIX_SEMANTICS 16777216
#define FILE_FLAG_OPEN_REPARSE_POINT 0x200000
#define FILE_FLAG_OPEN_NO_RECALL 0x100000
#define FILE_FLAG_FIRST_PIPE_INSTANCE 0x00080000

#define SMTO_ABORTIFHUNG 2
#define SMTO_BLOCK 1
#define SMTO_NORMAL 0

#define FORMAT_MESSAGE_ALLOCATE_BUFFER 256
#define FORMAT_MESSAGE_IGNORE_INSERTS 512
#define FORMAT_MESSAGE_FROM_STRING 1024
#define FORMAT_MESSAGE_FROM_HMODULE 2048
#define FORMAT_MESSAGE_FROM_SYSTEM 4096
#define FORMAT_MESSAGE_ARGUMENT_ARRAY 8192
#define FORMAT_MESSAGE_MAX_WIDTH_MASK 255

#define HWND_BOTTOM (HWND)1
#define HWND_NOTOPMOST (HWND)(-2)
#define HWND_TOP (HWND)0
#define HWND_TOPMOST (HWND)(-1)
#define HWND_BROADCAST (HWND)65535
#define VER_PLATFORM_WIN32s 0
#define VER_PLATFORM_WIN32_WINDOWS 1
#define VER_PLATFORM_WIN32_NT 2

#define CP_ACP 0
#define CP_MACCP 2
#define CP_OEMCP 1
#define CP_THREAD_ACP 3
#define CP_SYMBOL 42
#define CP_UTF7 65000
#define CP_UTF8 65001

#define WAIT_OBJECT_0 0
#define WAIT_ABANDONED_0 0x80
#define WAIT_TIMEOUT 0x102
#define WAIT_IO_COMPLETION 0xC0
#define WAIT_ABANDONED 0x80
#define WAIT_FAILED 0xFFFFFFFF

#define GENERIC_READ  0x80000000
#define GENERIC_WRITE 0x40000000
#define FILE_SHARE_READ 1
#define FILE_SHARE_WRITE 2
#define FILE_SHARE_DELETE 4
#define CREATE_NEW 1
#define CREATE_ALWAYS 2
#define OPEN_EXISTING 3
#define OPEN_ALWAYS 4
#define TRUNCATE_EXISTING 5

//#define CALLBACK
#define WINAPI
#define UINT32 unsigned int
#define HANDLE_FLAG_INHERIT 1

#define STARTF_USESHOWWINDOW 1
#define STARTF_USESIZE 2
#define STARTF_USEPOSITION 4
#define STARTF_USECOUNTCHARS 8
#define STARTF_USEFILLATTRIBUTE 16
#define STARTF_RUNFULLSCREEN 32
#define STARTF_FORCEONFEEDBACK 64
#define STARTF_FORCEOFFFEEDBACK 128
#define STARTF_USESTDHANDLES 256
#define STARTF_USEHOTKEY 512

#define FILE_ATTRIBUTE_ARCHIVE 32
#define FILE_ATTRIBUTE_COMPRESSED 2048
#define FILE_ATTRIBUTE_NORMAL 128
#define FILE_ATTRIBUTE_DIRECTORY 16
#define FILE_ATTRIBUTE_HIDDEN 2
#define FILE_ATTRIBUTE_READONLY 1
#define FILE_ATTRIBUTE_SYSTEM 4
#define FILE_ATTRIBUTE_TEMPORARY 256
#define FILE_ATTRIBUTE_SPARSE_FILE 0x200
#define FILE_ATTRIBUTE_REPARSE_POINT 0x400
#define FILE_ATTRIBUTE_OFFLINE 0x1000
#define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED 0x00002000
#define FILE_ATTRIBUTE_ENCRYPTED 0x4000

#define CREATE_UNICODE_ENVIRONMENT 1024

#define STILL_ACTIVE 0x103
#define FALSE 0
#define TRUE 1
#define INFINITE (-1)

#define CF_TEXT 1

#define GMEM_FIXED 0
#define GMEM_MOVEABLE 2
#define GMEM_MODIFY 128
#define GMEM_VALID_FLAGS 0x7F72

#define DIB_PAL_COLORS 1
#define DIB_RGB_COLORS 0

#define BI_RGB 0
#define BI_RLE8 1
#define BI_RLE4 2
#define BI_BITFIELDS 3
#define BI_JPEG 4
#define BI_PNG 5

#define MK_CONTROL 8
#define MK_LBUTTON 1
#define MK_MBUTTON 16
#define MK_RBUTTON 2
#define MK_SHIFT 4

#define MAKEINTRESOURCE(i) (LPSTR) ((DWORD) ((WORD) (i)))
#define MAKELONG(a,b) ((LONG) (((WORD) (a)) | ((DWORD) ((WORD) (b))) << 16))
#define MAKELPARAM(l,h) ((LPARAM) MAKELONG(l,h))
#define RGB(r,g,b) ((DWORD)(((BYTE)(r)|((WORD)(g) << 8))|(((DWORD)(BYTE)(b)) << 16)))

#define BLACKNESS 0x42
#define NOTSRCERASE 0x1100A6
#define NOTSRCCOPY 0x330008
#define SRCERASE 0x440328
#define DSTINVERT 0x550009
#define PATINVERT 0x5A0049
#define SRCINVERT 0x660046
#define SRCAND 0x8800C6
#define MERGEPAINT 0xBB0226
#define MERGECOPY 0xC000CA
#define SRCCOPY 0xCC0020
#define SRCPAINT 0xEE0086
#define PATCOPY 0xF00021
#define PATPAINT 0xFB0A09
#define WHITENESS 0xFF0062
#define NOMIRRORBITMAP 0x80000000
#define CAPTUREBLT 0x40000000

#define GWL_EXSTYLE (-20)
#define GWL_STYLE (-16)
#define GWL_WNDPROC (-4)
#define GWL_HINSTANCE (-6)
#define GWL_HWNDPARENT (-8)
#define GWL_ID (-12)
#define GWL_USERDATA (-21)
#define GWLP_WNDPROC (-4)
#define GWLP_HINSTANCE (-6)
#define GWLP_HWNDPARENT (-8)
#define GWLP_USERDATA (-21)
#define GWLP_ID (-12)

#define COLOR_HOTLIGHT 26
#define COLOR_GRADIENTACTIVECAPTION 27
#define COLOR_GRADIENTINACTIVECAPTION 28
#define COLOR_MENUHILIGHT 29
#define COLOR_MENUBAR 30
#define COLOR_3DDKSHADOW 21
#define COLOR_3DFACE 15
#define COLOR_3DHILIGHT 20
#define COLOR_3DHIGHLIGHT 20
#define COLOR_3DLIGHT 22
#define COLOR_BTNHILIGHT 20
#define COLOR_3DSHADOW 16
#define COLOR_ACTIVEBORDER 10
#define COLOR_ACTIVECAPTION 2
#define COLOR_APPWORKSPACE 12
#define COLOR_BACKGROUND 1
#define COLOR_DESKTOP 1
#define COLOR_BTNFACE 15
#define COLOR_BTNHIGHLIGHT 20
#define COLOR_BTNSHADOW 16
#define COLOR_BTNTEXT 18
#define COLOR_CAPTIONTEXT 9
#define COLOR_GRAYTEXT 17
#define COLOR_HIGHLIGHT 13
#define COLOR_HIGHLIGHTTEXT 14
#define COLOR_INACTIVEBORDER 11
#define COLOR_INACTIVECAPTION 3
#define COLOR_INACTIVECAPTIONTEXT 19
#define COLOR_INFOBK 24
#define COLOR_INFOTEXT 23
#define COLOR_MENU 4
#define COLOR_MENUTEXT 7
#define COLOR_SCROLLBAR 0
#define COLOR_WINDOW 5
#define COLOR_WINDOWFRAME 6
#define COLOR_WINDOWTEXT 8

#define SW_HIDE 0
#define SW_NORMAL 1
#define SW_MAXIMIZE 3
#define SW_MINIMIZE 6
#define SW_RESTORE 9
#define SW_SHOW 5
#define SW_SHOWDEFAULT 10
#define SW_SHOWMAXIMIZED 3
#define SW_SHOWMINIMIZED 2
#define SW_SHOWMINNOACTIVE 7
#define SW_SHOWNA 8
#define SW_SHOWNOACTIVATE 4
#define SW_SHOWNORMAL 1

#define PS_GEOMETRIC 65536
#define PS_COSMETIC 0
#define PS_ALTERNATE 8
#define PS_SOLID 0
#define PS_DASH 1
#define PS_DOT 2
#define PS_DASHDOT 3
#define PS_DASHDOTDOT 4
#define PS_NULL 5
#define PS_USERSTYLE 7
#define PS_INSIDEFRAME 6
#define PS_ENDCAP_ROUND 0
#define PS_ENDCAP_SQUARE 256
#define PS_ENDCAP_FLAT 512
#define PS_JOIN_BEVEL 4096
#define PS_JOIN_MITER 8192
#define PS_JOIN_ROUND 0
#define PS_STYLE_MASK 15
#define PS_ENDCAP_MASK 3840
#define PS_TYPE_MASK 983040

#define HTBOTTOM 15
#define HTBOTTOMLEFT 16
#define HTBOTTOMRIGHT 17
#define HTCAPTION 2
#define HTCLIENT 1
#define HTERROR (-2)
#define HTGROWBOX 4
#define HTHSCROLL 6
#define HTLEFT 10
#define HTMENU 5
#define HTNOWHERE 0
#define HTREDUCE 8
#define HTRIGHT 11
#define HTSIZE 4
#define HTSYSMENU 3
#define HTTOP 12
#define HTTOPLEFT 13
#define HTTOPRIGHT 14
#define HTTRANSPARENT (-1)
#define HTVSCROLL 7
#define HTZOOM 9
#define HTOBJECT 19
#define HTCLOSE 20
#define HTHELP 21
#define HTBORDER 18
#define HTMINBUTTON 8
#define HTMAXBUTTON 9

#define VK_LBUTTON 1
#define VK_RBUTTON 2
#define VK_CANCEL 3
#define VK_MBUTTON 4
#define VK_BACK 8
#define VK_TAB 9
#define VK_CLEAR 12
#define VK_RETURN 13
#define VK_SHIFT 16
#define VK_CONTROL 17
#define VK_MENU 18
#define VK_PAUSE 19
#define VK_PRINT 42
#define VK_CAPITAL 20
#define VK_KANA 0x15
#define VK_HANGEUL 0x15
#define VK_HANGUL 0x15
#define VK_JUNJA 0x17
#define VK_FINAL 0x18
#define VK_HANJA 0x19
#define VK_KANJI 0x19
#define VK_CONVERT 0x1C
#define VK_NONCONVERT 0x1D
#define VK_ACCEPT 0x1E
#define VK_MODECHANGE 0x1F
#define VK_ESCAPE 27
#define VK_SPACE 32
#define VK_PRIOR 33
#define VK_NEXT 34
#define VK_END 35
#define VK_HOME 36
#define VK_LEFT 37
#define VK_UP 38
#define VK_RIGHT 39
#define VK_DOWN 40
#define VK_SELECT 41
#define VK_EXECUTE 43
#define VK_SNAPSHOT 44
#define VK_INSERT 45
#define VK_DELETE 46
#define VK_HELP 47
#define VK_0 48
#define VK_1 49
#define VK_2 50
#define VK_3 51
#define VK_4 52
#define VK_5 53
#define VK_6 54
#define VK_7 55
#define VK_8 56
#define VK_9 57
#define VK_A 65
#define VK_B 66
#define VK_C 67
#define VK_D 68
#define VK_E 69
#define VK_F 70
#define VK_G 71
#define VK_H 72
#define VK_I 73
#define VK_J 74
#define VK_K 75
#define VK_L 76
#define VK_M 77
#define VK_N 78
#define VK_O 79
#define VK_P 80
#define VK_Q 81
#define VK_R 82
#define VK_S 83
#define VK_T 84
#define VK_U 85
#define VK_V 86
#define VK_W 87
#define VK_X 88
#define VK_Y 89
#define VK_Z 90
#define VK_LWIN 0x5B
#define VK_RWIN 0x5C
#define VK_APPS 0x5D
#define VK_NUMPAD0 96
#define VK_NUMPAD1 97
#define VK_NUMPAD2 98
#define VK_NUMPAD3 99
#define VK_NUMPAD4 100
#define VK_NUMPAD5 101
#define VK_NUMPAD6 102
#define VK_NUMPAD7 103
#define VK_NUMPAD8 104
#define VK_NUMPAD9 105
#define VK_MULTIPLY 106
#define VK_ADD 107
#define VK_SEPARATOR 108
#define VK_SUBTRACT 109
#define VK_DECIMAL 110
#define VK_DIVIDE 111
#define VK_F1 112
#define VK_F2 113
#define VK_F3 114
#define VK_F4 115
#define VK_F5 116
#define VK_F6 117
#define VK_F7 118
#define VK_F8 119
#define VK_F9 120
#define VK_F10 121
#define VK_F11 122
#define VK_F12 123
#define VK_F13 124
#define VK_F14 125
#define VK_F15 126
#define VK_F16 127
#define VK_F17 128
#define VK_F18 129
#define VK_F19 130
#define VK_F20 131
#define VK_F21 132
#define VK_F22 133
#define VK_F23 134
#define VK_F24 135
#define VK_NUMLOCK 144
#define VK_SCROLL 145
#define VK_LSHIFT 160
#define VK_LCONTROL 162
#define VK_LMENU 164
#define VK_RSHIFT 161
#define VK_RCONTROL 163
#define VK_RMENU 165

#define FILE_TYPE_UNKNOWN 0
#define FILE_TYPE_DISK 1
#define FILE_TYPE_CHAR 2
#define FILE_TYPE_PIPE 3
#define FILE_TYPE_REMOTE 0x8000

#define FILE_MAP_ALL_ACCESS 0xf001f
#define FILE_MAP_READ 4
#define FILE_MAP_WRITE 2
#define FILE_MAP_COPY 1

#define PM_NOREMOVE 0
#define PM_REMOVE 1
#define PM_NOYIELD 2

#define LOWORD(l) (((WORD) (l)) & 0xFFFF)
#define HIWORD(l) ((WORD) (((DWORD) (l) >> 16) & 0xFFFF))

//#define ERROR_BROKEN_PIPE 109

#define WM_NULL 0
#define WM_APP 0x8000
#define WM_ACTIVATE 6
#define WM_ACTIVATEAPP 28
#define WM_ASKCBFORMATNAME 780
#define WM_CANCELJOURNAL 75
#define WM_CANCELMODE 31
#define WM_CAPTURECHANGED 533
#define WM_CHANGECBCHAIN 781
#define WM_CHAR 258
#define WM_CHARTOITEM 47
#define WM_CHILDACTIVATE 34
#define WM_CHOOSEFONT_GETLOGFONT 1025
#define WM_CHOOSEFONT_SETLOGFONT 1125
#define WM_CHOOSEFONT_SETFLAGS 1126
#define WM_CLEAR 771
#define WM_CLOSE 16

//!=================

#define WM_COMMAND 273
#define WM_COMPACTING 65
#define WM_COMPAREITEM 57
#define WM_CONTEXTMENU 123
#define WM_COPY 769
#define WM_COPYDATA 74
#define WM_CREATE 1
#define WM_CTLCOLORBTN 309
#define WM_CTLCOLORDLG 310
#define WM_CTLCOLOREDIT 307
#define WM_CTLCOLORLISTBOX 308
#define WM_CTLCOLORMSGBOX 306
#define WM_CTLCOLORSCROLLBAR 311
#define WM_CTLCOLORSTATIC 312
#define WM_CUT 768
#define WM_DEADCHAR 259
#define WM_DELETEITEM 45
#define WM_DESTROY 2
#define WM_DESTROYCLIPBOARD 775
#define WM_DEVICECHANGE 537
#define WM_DEVMODECHANGE 27
#define WM_DISPLAYCHANGE 126
#define WM_DRAWCLIPBOARD 776
#define WM_DRAWITEM 43
#define WM_DROPFILES 563
#define WM_ENABLE 10
#define WM_ENDSESSION 22
#define WM_ENTERIDLE 289
#define WM_ENTERMENULOOP 529
#define WM_ENTERSIZEMOVE 561
#define WM_ERASEBKGND 20
#define WM_EXITMENULOOP 530
#define WM_EXITSIZEMOVE 562
#define WM_FONTCHANGE 29
#define WM_GETDLGCODE 135
#define WM_GETFONT 49
#define WM_GETHOTKEY 51
#define WM_GETICON 127
#define WM_GETMINMAXINFO 36
#define WM_GETTEXT 13
#define WM_GETTEXTLENGTH 14
#define WM_HELP 83
#define WM_HOTKEY 786
#define WM_HSCROLL 276
#define WM_HSCROLLCLIPBOARD 782
#define WM_ICONERASEBKGND 39
#define WM_IME_CHAR 646
#define WM_IME_COMPOSITION 271
#define WM_IME_COMPOSITIONFULL 644
#define WM_IME_CONTROL 643
#define WM_IME_ENDCOMPOSITION 270
#define WM_IME_KEYDOWN 656
#define WM_IME_KEYUP 657
#define WM_IME_NOTIFY 642
#define WM_IME_SELECT 645
#define WM_IME_SETCONTEXT 641
#define WM_IME_STARTCOMPOSITION 269
#define WM_INITDIALOG 272
#define WM_INITMENU 278
#define WM_INITMENUPOPUP 279
#define WM_INPUTLANGCHANGE 81
#define WM_INPUTLANGCHANGEREQUEST 80
#define WM_INPUT 0xff
#define WM_KEYDOWN 256
#define WM_KEYUP 257
#define WM_KILLFOCUS 8
#define WM_LBUTTONDBLCLK 515
#define WM_LBUTTONDOWN 513
#define WM_LBUTTONUP 514
#define WM_MBUTTONDBLCLK 521
#define WM_MBUTTONDOWN 519
#define WM_MBUTTONUP 520
#define WM_MDIACTIVATE 546
#define WM_MDICASCADE 551
#define WM_MDICREATE 544
#define WM_MDIDESTROY 545
#define WM_MDIGETACTIVE 553
#define WM_MDIICONARRANGE 552
#define WM_MDIMAXIMIZE 549
#define WM_MDINEXT 548
#define WM_MDIREFRESHMENU 564
#define WM_MDIRESTORE 547
#define WM_MDISETMENU 560
#define WM_MDITILE 550
#define WM_MEASUREITEM 44
#define WM_MENUCHAR 288
#define WM_MENUSELECT 287
#define WM_MENURBUTTONUP 0x0122
#define WM_MENUDRAG 0x0123
#define WM_MENUGETOBJECT 0x0124
#define WM_UNINITMENUPOPUP 0x0125
#define WM_MENUCOMMAND 0x0126
//#define WM_CHANGEUISTATE 0x0127
#define WM_UPDATEUISTATE 0x0128
#define WM_QUERYUISTATE 0x0129
#define UIS_SET 1
#define UIS_CLEAR 2
#define UIS_INITIALIZE  3
#define WM_MOUSEACTIVATE 33
#define WM_MOUSEMOVE 512
#define WM_MOUSEHOVER 0x2a1
#define WM_MOUSELEAVE 0x2a3
#define WM_MOUSEWHEEL 0x20A
#define WM_MOVE 3
#define WM_MOVING 534
#define WM_NCACTIVATE 134
#define WM_NCCALCSIZE 131
#define WM_NCCREATE 129
#define WM_NCDESTROY 130
#define WM_NCHITTEST 132
#define WM_NCLBUTTONDBLCLK 163
#define WM_NCLBUTTONDOWN 161
#define WM_NCLBUTTONUP 162
#define WM_NCMBUTTONDBLCLK 169
#define WM_NCMBUTTONDOWN 167
#define WM_NCMBUTTONUP 168
#define WM_NCMOUSEMOVE 160
#define WM_NCPAINT 133
#define WM_NCRBUTTONDBLCLK 166
#define WM_NCRBUTTONDOWN 164
#define WM_NCRBUTTONUP 165
#define WM_NEXTDLGCTL 40
#define WM_NOTIFY 78
#define WM_NOTIFYFORMAT 85
#define WM_PAINT 15
#define WM_PAINTCLIPBOARD 777
#define WM_PAINTICON 38
#define WM_PALETTECHANGED 785
#define WM_PALETTEISCHANGING 784
#define WM_PARENTNOTIFY 528
#define WM_PASTE 770
#define WM_PENWINFIRST 896
#define WM_SYNCPAINT 0x0088
#define WM_AFXFIRST 0x0360
#define WM_AFXLAST 0x037F
#define WM_HANDHELDFIRST 0x0358
#define WM_HANDHELDLAST 0x035F
#define WM_PENWINLAST 911
#define WM_POWER 72
#define WM_POWERBROADCAST 536
#define WM_PRINT 791
#define WM_PRINTCLIENT 792
#define WM_PSD_ENVSTAMPRECT 1029
#define WM_PSD_FULLPAGERECT 1025
#define WM_PSD_GREEKTEXTRECT 1028
#define WM_PSD_MARGINRECT 1027
#define WM_PSD_MINMARGINRECT 1026
#define WM_PSD_PAGESETUPDLG 1024
#define WM_PSD_YAFULLPAGERECT 1030
#define WM_QUERYDRAGICON 55
#define WM_QUERYENDSESSION 17
#define WM_QUERYNEWPALETTE 783
#define WM_QUERYOPEN 19
#define WM_QUEUESYNC 35
#define WM_QUIT 18
#define WM_RBUTTONDBLCLK 518
#define WM_RBUTTONDOWN 516
#define WM_RBUTTONUP 517
#define WM_RENDERALLFORMATS 774
#define WM_RENDERFORMAT 773
#define WM_SETCURSOR 32
#define WM_SETFOCUS 7
#define WM_SETFONT 48
#define WM_SETHOTKEY 50
#define WM_SETICON 128
#define WM_SETREDRAW 11
#define WM_SETTEXT 12
#define WM_SETTINGCHANGE 26
#define WM_SHOWWINDOW 24
#define WM_SIZE 5
#define WM_SIZECLIPBOARD 779
#define WM_SIZING 532
#define WM_SPOOLERSTATUS 42
#define WM_STYLECHANGED 125
#define WM_STYLECHANGING 124
#define WM_SYSCHAR 262
#define WM_SYSCOLORCHANGE 21
#define WM_SYSCOMMAND 274
#define WM_SYSDEADCHAR 263
#define WM_SYSKEYDOWN 260
#define WM_SYSKEYUP 261
#define WM_TCARD 82
#define WM_TIMECHANGE 30
#define WM_TIMER 275
#define WM_UNDO 772
#define WM_USER 1024
#define WM_USERCHANGED 84
#define WM_VKEYTOITEM 46
#define WM_VSCROLL 277
#define WM_VSCROLLCLIPBOARD 778
#define WM_WINDOWPOSCHANGED 71
#define WM_WINDOWPOSCHANGING 70
#define WM_XBUTTONDOWN 0x020B
#define WM_XBUTTONUP 0x020C
#define WM_XBUTTONDBLCLK 0x020D
#define WM_WININICHANGE 26
#define WM_KEYFIRST 256
#define WM_KEYLAST 264
#define WM_MOUSEFIRST 512
#define WM_MOUSELAST 0x020D
#define WM_NEXTMENU 0x0213
//#define WM_CHANGEUISTATE 0x0127
//#define WM_UPDATEUISTATE 0x0128
//#define WM_QUERYUISTATE 0x0129
#define WM_WTSSESSION_CHANGE 0x02B1
#define WM_LBTRACKPOINT 0x0131
#define WM_GETOBJECT 0x003D
#define WM_COMMNOTIFY 0x0044
#define WM_TABLET_FIRST 0x02c0
#define WM_TABLET_LAST 0x02df
#define WM_IME_REQUEST 0x0288
#define WM_IME_KEYLAST  0x010F
#define WM_NCMOUSEHOVER 0x02A0
#define WM_NCMOUSELEAVE 0x02A2

#define WS_BORDER 0x800000
#define WS_CAPTION 0xc00000
#define WS_CHILD 0x40000000
#define WS_CHILDWINDOW 0x40000000
#define WS_CLIPCHILDREN 0x2000000
#define WS_CLIPSIBLINGS 0x4000000
#define WS_DISABLED 0x8000000
#define WS_DLGFRAME 0x400000
#define WS_GROUP 0x20000
#define WS_HSCROLL 0x100000
#define WS_ICONIC 0x20000000
#define WS_MAXIMIZE 0x1000000
#define WS_MAXIMIZEBOX 0x10000
#define WS_MINIMIZE 0x20000000
#define WS_MINIMIZEBOX 0x20000
#define WS_OVERLAPPED 0
#define WS_OVERLAPPEDWINDOW 0xcf0000
#define WS_POPUP 0x80000000
#define WS_POPUPWINDOW 0x80880000
#define WS_SIZEBOX 0x40000
#define WS_SYSMENU 0x80000
#define WS_TABSTOP 0x10000
#define WS_THICKFRAME 0x40000
#define WS_TILED 0
#define WS_TILEDWINDOW 0xcf0000
#define WS_VISIBLE 0x10000000
#define WS_VSCROLL 0x200000

#define HORZRES	8
#define VERTRES	10
#define DESKTOPHORZRES	118
#define DESKTOPVERTRES	117

//!=================


//#define INVALID_HANDLE_VALUE (HANDLE)(0xffffffff)
#define MEM_RESERVE 8192
#define MEM_COMMIT 4096
#define PAGE_READWRITE 4
#define PAGE_WRITECOPY 8
#define PAGE_EXECUTE_READ 32
#define MEM_TOP_DOWN 1048576
#define MEM_RELEASE 32768
#define MAX_PATH 260
//#define FORMAT_MESSAGE_IGNORE_INSERTS 512
//#define FORMAT_MESSAGE_FROM_SYSTEM 4096
//#define WAIT_OBJECT_0 0
#define STD_INPUT_HANDLE (DWORD)(0xfffffff6)
#define STD_OUTPUT_HANDLE (DWORD)(0xfffffff5)
#define STD_ERROR_HANDLE (DWORD)(0xfffffff4)
#define ENABLE_LINE_INPUT 2
#define ENABLE_ECHO_INPUT 4
#define ENABLE_PROCESSED_INPUT 1
#define ENABLE_WINDOW_INPUT 8
#define ENABLE_MOUSE_INPUT 16
#define ENABLE_PROCESSED_OUTPUT 1
#define CONST const

#define CAPSLOCK_ON 128
#define ENHANCED_KEY 256
#define LEFT_ALT_PRESSED 2
#define LEFT_CTRL_PRESSED 8
#define NUMLOCK_ON 32
#define RIGHT_ALT_PRESSED 1
#define RIGHT_CTRL_PRESSED 4
#define SCROLLLOCK_ON 64
#define SHIFT_PRESSED 16
#define FROM_LEFT_1ST_BUTTON_PRESSED 1
#define RIGHTMOST_BUTTON_PRESSED 2
#define FROM_LEFT_2ND_BUTTON_PRESSED 4
#define FROM_LEFT_3RD_BUTTON_PRESSED 8
#define FROM_LEFT_4TH_BUTTON_PRESSED 16
#define DOUBLE_CLICK 2
#define MOUSE_MOVED 1
#define KEY_EVENT 1
#define MOUSE_EVENT 2
#define WINDOW_BUFFER_SIZE_EVENT 4
#define MENU_EVENT 8
#define FOCUS_EVENT 16

//for PlaySound
#define SND_SYNC 0 
#define SND_ASYNC 1 
#define SND_NODEFAULT 2 
#define SND_MEMORY 4 
#define SND_LOOP 8 
#define SND_NOSTOP 16 
#define SND_NOWAIT 8192 
#define SND_ALIAS 65536 
#define SND_ALIAS_ID 0x110000 
#define SND_FILENAME 0x20000 
#define SND_RESOURCE 0x40004 

#define CW_USEDEFAULT 0x80000000
#define CS_BYTEALIGNCLIENT 4096
#define CS_BYTEALIGNWINDOW 8192
#define CS_KEYCVTWINDOW 4
#define CS_NOKEYCVT 256
#define CS_CLASSDC 64
#define CS_DBLCLKS 8
#define CS_GLOBALCLASS 16384
#define CS_IME 0x10000
#define CS_DROPSHADOW 0x20000
#define CS_HREDRAW 2
#define CS_NOCLOSE 512
#define CS_OWNDC 32
#define CS_PARENTDC 128
#define CS_SAVEBITS 2048
#define CS_VREDRAW 1

#define IDI_APPLICATION MAKEINTRESOURCE(32512)
#define IDC_ARROW MAKEINTRESOURCE(32512)

#define BLACK_BRUSH 4
#define DKGRAY_BRUSH 3
#define GRAY_BRUSH 2
#define HOLLOW_BRUSH 5
#define LTGRAY_BRUSH 1
#define NULL_BRUSH 5
#define WHITE_BRUSH 0
#define BLACK_PEN 7
#define NULL_PEN 8
#define WHITE_PEN 6

#define MB_USERICON 128
#define MB_ICONASTERISK 64
#define MB_ICONEXCLAMATION 0x30
#define MB_ICONWARNING 0x30
#define MB_ICONERROR 16
#define MB_ICONHAND 16
#define MB_ICONQUESTION 32
#define MB_OK 0
#define MB_ABORTRETRYIGNORE 2
#define MB_APPLMODAL 0
#define MB_DEFAULT_DESKTOP_ONLY 0x20000
#define MB_HELP 0x4000
#define MB_RIGHT 0x80000
#define MB_RTLREADING 0x100000
#define MB_TOPMOST 0x40000
#define MB_DEFBUTTON1 0
#define MB_DEFBUTTON2 256
#define MB_DEFBUTTON3 512
#define MB_DEFBUTTON4 0x300
#define MB_ICONINFORMATION 64
#define MB_ICONSTOP 16
#define MB_OKCANCEL 1
#define MB_RETRYCANCEL 0x5
#define MB_SERVICE_NOTIFICATION 0x40000
#define MB_SETFOREGROUND 0x10000
#define MB_SYSTEMMODAL 4096
#define MB_TASKMODAL 0x2000
#define MB_YESNO 4
#define MB_YESNOCANCEL 3

#define DT_BOTTOM 8
#define DT_CALCRECT 1024
#define DT_CENTER 1
#define DT_EDITCONTROL 8192
#define DT_END_ELLIPSIS 32768
#define DT_PATH_ELLIPSIS 16384
#define DT_EXPANDTABS 64
#define DT_EXTERNALLEADING 512
#define DT_LEFT 0
#define DT_MODIFYSTRING 65536
#define DT_NOCLIP 256
#define DT_NOPREFIX 2048
#define DT_RIGHT 2
#define DT_RTLREADING 131072
#define DT_SINGLELINE 32
#define DT_TABSTOP 128
#define DT_TOP 0
#define DT_VCENTER 4
#define DT_WORDBREAK 16
#define DT_INTERNAL 4096
#define DT_WORD_ELLIPSIS 0x40000
#define DT_NOFULLWIDTHCHARBREAK 0x80000
#define DT_HIDEPREFIX 0x100000
#define DT_PREFIXONLY 0x200000

#define HKEY_CLASSES_ROOT (HKEY)0x80000000
#define HKEY_CURRENT_USER (HKEY)0x80000001
#define HKEY_LOCAL_MACHINE (HKEY)0x80000002
#define HKEY_USERS (HKEY)(-2147483645)
#define HKEY_PERFORMANCE_DATA (HKEY)(-2147483644)
#define HKEY_CURRENT_CONFIG (HKEY)(-2147483643)
#define HKEY_DYN_DATA ((HKEY)(0x80000006))

#define KEY_QUERY_VALUE 1
#define KEY_SET_VALUE 2
#define KEY_CREATE_SUB_KEY 4
#define KEY_ENUMERATE_SUB_KEYS 8
#define KEY_NOTIFY 16
#define KEY_CREATE_LINK 32
#define KEY_ALL_ACCESS 0xF003F
#define KEY_EXECUTE 0x20019
#define KEY_READ 0x20019
#define KEY_WRITE 0x20006

#define NO_ERROR 0
#define ERROR_SUCCESS 0
#define ERROR_INVALID_FUNCTION 1
#define ERROR_FILE_NOT_FOUND 2
#define ERROR_PATH_NOT_FOUND 3
#define ERROR_TOO_MANY_OPEN_FILES 4
#define ERROR_ACCESS_DENIED 5
#define ERROR_INVALID_HANDLE 6
#define ERROR_ARENA_TRASHED 7
#define ERROR_NOT_ENOUGH_MEMORY 8
#define ERROR_INVALID_BLOCK 9
#define ERROR_BAD_ENVIRONMENT 10
#define ERROR_BAD_FORMAT 11
#define ERROR_INVALID_ACCESS 12
#define ERROR_INVALID_DATA 13
#define ERROR_OUTOFMEMORY 14
#define ERROR_INVALID_DRIVE 15
#define ERROR_CURRENT_DIRECTORY 16
#define ERROR_NOT_SAME_DEVICE 17
#define ERROR_NO_MORE_FILES 18
#define ERROR_WRITE_PROTECT 19
#define ERROR_BAD_UNIT 20
#define ERROR_NOT_READY 21
#define ERROR_BAD_COMMAND 22
#define ERROR_CRC 23
#define ERROR_BAD_LENGTH 24
#define ERROR_SEEK 25
#define ERROR_NOT_DOS_DISK 26
#define ERROR_SECTOR_NOT_FOUND 27
#define ERROR_OUT_OF_PAPER 28
#define ERROR_WRITE_FAULT 29
#define ERROR_READ_FAULT 30
#define ERROR_GEN_FAILURE 31
#define ERROR_SHARING_VIOLATION 32
#define ERROR_LOCK_VIOLATION 33
#define ERROR_WRONG_DISK 34
#define ERROR_SHARING_BUFFER_EXCEEDED 36
#define ERROR_HANDLE_EOF 38
#define ERROR_HANDLE_DISK_FULL 39
#define ERROR_NOT_SUPPORTED 50
#define ERROR_REM_NOT_LIST 51
#define ERROR_DUP_NAME 52
#define ERROR_BAD_NETPATH 53
#define ERROR_NETWORK_BUSY 54
#define ERROR_DEV_NOT_EXIST 55
#define ERROR_TOO_MANY_CMDS 56
#define ERROR_ADAP_HDW_ERR 57
#define ERROR_BAD_NET_RESP 58
#define ERROR_UNEXP_NET_ERR 59
#define ERROR_BAD_REM_ADAP 60
#define ERROR_PRINTQ_FULL 61
#define ERROR_NO_SPOOL_SPACE 62
#define ERROR_PRINT_CANCELLED 63
#define ERROR_NETNAME_DELETED 64
#define ERROR_NETWORK_ACCESS_DENIED 65
#define ERROR_BAD_DEV_TYPE 66
#define ERROR_BAD_NET_NAME 67
#define ERROR_TOO_MANY_NAMES 68
#define ERROR_TOO_MANY_SESS 69
#define ERROR_SHARING_PAUSED 70
#define ERROR_REQ_NOT_ACCEP 71
#define ERROR_REDIR_PAUSED 72
#define ERROR_FILE_EXISTS 80
#define ERROR_CANNOT_MAKE 82
#define ERROR_FAIL_I24 83
#define ERROR_OUT_OF_STRUCTURES 84
#define ERROR_ALREADY_ASSIGNED 85
#define ERROR_INVALID_PASSWORD 86
#define ERROR_INVALID_PARAMETER 87
#define ERROR_NET_WRITE_FAULT 88
#define ERROR_NO_PROC_SLOTS 89
#define ERROR_TOO_MANY_SEMAPHORES 100
#define ERROR_EXCL_SEM_ALREADY_OWNED 101
#define ERROR_SEM_IS_SET 102
#define ERROR_TOO_MANY_SEM_REQUESTS 103
#define ERROR_INVALID_AT_INTERRUPT_TIME 104
#define ERROR_SEM_OWNER_DIED 105
#define ERROR_SEM_USER_LIMIT 106
#define ERROR_DISK_CHANGE 107
#define ERROR_DRIVE_LOCKED 108
#define ERROR_BROKEN_PIPE 109
#define ERROR_OPEN_FAILED 110
#define ERROR_BUFFER_OVERFLOW 111
#define ERROR_DISK_FULL 112
#define ERROR_NO_MORE_SEARCH_HANDLES 113
#define ERROR_INVALID_TARGET_HANDLE 114
#define ERROR_INVALID_CATEGORY 117
#define ERROR_INVALID_VERIFY_SWITCH 118
#define ERROR_BAD_DRIVER_LEVEL 119
#define ERROR_CALL_NOT_IMPLEMENTED 120
#define ERROR_SEM_TIMEOUT 121
#define ERROR_INSUFFICIENT_BUFFER 122
#define ERROR_INVALID_NAME 123
#define ERROR_INVALID_LEVEL 124
#define ERROR_NO_VOLUME_LABEL 125
#define ERROR_MOD_NOT_FOUND 126
#define ERROR_PROC_NOT_FOUND 127
#define ERROR_WAIT_NO_CHILDREN 128
#define ERROR_CHILD_NOT_COMPLETE 129
#define ERROR_DIRECT_ACCESS_HANDLE 130
#define ERROR_NEGATIVE_SEEK 131
#define ERROR_SEEK_ON_DEVICE 132
#define ERROR_IS_JOIN_TARGET 133
#define ERROR_IS_JOINED 134
#define ERROR_IS_SUBSTED 135
#define ERROR_NOT_JOINED 136
#define ERROR_NOT_SUBSTED 137
#define ERROR_JOIN_TO_JOIN 138
#define ERROR_SUBST_TO_SUBST 139
#define ERROR_JOIN_TO_SUBST 140
#define ERROR_SUBST_TO_JOIN 141
#define ERROR_BUSY_DRIVE 142
#define ERROR_SAME_DRIVE 143
#define ERROR_DIR_NOT_ROOT 144
#define ERROR_DIR_NOT_EMPTY 145
#define ERROR_IS_SUBST_PATH 146
#define ERROR_IS_JOIN_PATH 147
#define ERROR_PATH_BUSY 148
#define ERROR_IS_SUBST_TARGET 149
#define ERROR_SYSTEM_TRACE 150
#define ERROR_INVALID_EVENT_COUNT 151
#define ERROR_TOO_MANY_MUXWAITERS 152
#define ERROR_INVALID_LIST_FORMAT 153
#define ERROR_LABEL_TOO_LONG 154
#define ERROR_TOO_MANY_TCBS 155
#define ERROR_SIGNAL_REFUSED 156
#define ERROR_DISCARDED 157
#define ERROR_NOT_LOCKED 158
#define ERROR_BAD_THREADID_ADDR 159
#define ERROR_BAD_ARGUMENTS 160
#define ERROR_BAD_PATHNAME 161
#define ERROR_SIGNAL_PENDING 162
#define ERROR_MAX_THRDS_REACHED 164
#define ERROR_LOCK_FAILED 167
#define ERROR_BUSY 170
#define ERROR_CANCEL_VIOLATION 173
#define ERROR_ATOMIC_LOCKS_NOT_SUPPORTED 174
#define ERROR_INVALID_SEGMENT_NUMBER 180
#define ERROR_INVALID_ORDINAL 182
#define ERROR_ALREADY_EXISTS 183
#define ERROR_INVALID_FLAG_NUMBER 186
#define ERROR_SEM_NOT_FOUND 187
#define ERROR_INVALID_STARTING_CODESEG 188
#define ERROR_INVALID_STACKSEG 189
#define ERROR_INVALID_MODULETYPE 190
#define ERROR_INVALID_EXE_SIGNATURE 191
#define ERROR_EXE_MARKED_INVALID 192
#define ERROR_EXE_MACHINE_TYPE_MISMATCH 216
#define ERROR_BAD_EXE_FORMAT 193
#define ERROR_ITERATED_DATA_EXCEEDS_64k 194
#define ERROR_INVALID_MINALLOCSIZE 195
#define ERROR_DYNLINK_FROM_INVALID_RING 196
#define ERROR_IOPL_NOT_ENABLED 197
#define ERROR_INVALID_SEGDPL 198
#define ERROR_AUTODATASEG_EXCEEDS_64k 199
#define ERROR_RING2SEG_MUST_BE_MOVABLE 200
#define ERROR_RELOC_CHAIN_XEEDS_SEGLIM 201
#define ERROR_INFLOOP_IN_RELOC_CHAIN 202
#define ERROR_ENVVAR_NOT_FOUND 203
#define ERROR_NO_SIGNAL_SENT 205
#define ERROR_FILENAME_EXCED_RANGE 206
#define ERROR_RING2_STACK_IN_USE 207
#define ERROR_META_EXPANSION_TOO_LONG 208
#define ERROR_INVALID_SIGNAL_NUMBER 209
#define ERROR_THREAD_1_INACTIVE 210
#define ERROR_LOCKED 212
#define ERROR_TOO_MANY_MODULES 214
#define ERROR_NESTING_NOT_ALLOWED 215
#define ERROR_BAD_PIPE 230
#define ERROR_PIPE_BUSY 231
#define ERROR_NO_DATA 232
#define ERROR_PIPE_NOT_CONNECTED 233
#define ERROR_MORE_DATA 234
#define ERROR_VC_DISCONNECTED 240
#define ERROR_INVALID_EA_NAME 254
#define ERROR_EA_LIST_INCONSISTENT 255
#define ERROR_NO_MORE_ITEMS 259
#define ERROR_CANNOT_COPY 266
#define ERROR_DIRECTORY 267
#define ERROR_EAS_DIDNT_FIT 275
#define ERROR_EA_FILE_CORRUPT 276
#define ERROR_EA_TABLE_FULL 277
#define ERROR_INVALID_EA_HANDLE 278
#define ERROR_EAS_NOT_SUPPORTED 282
#define ERROR_NOT_OWNER 288
#define ERROR_TOO_MANY_POSTS 298
#define ERROR_PARTIAL_COPY 299
#define ERROR_MR_MID_NOT_FOUND 317
#define ERROR_INVALID_ADDRESS 487
#define ERROR_ARITHMETIC_OVERFLOW 534
#define ERROR_PIPE_CONNECTED 535
#define ERROR_PIPE_LISTENING 536
#define ERROR_EA_ACCESS_DENIED 994
#define ERROR_OPERATION_ABORTED 995
#define ERROR_IO_INCOMPLETE 996
#define ERROR_IO_PENDING 997
#define ERROR_NOACCESS 998
#define ERROR_SWAPERROR 999
#define ERROR_STACK_OVERFLOW 1001
#define ERROR_INVALID_MESSAGE 1002
#define ERROR_CAN_NOT_COMPLETE 1003
#define ERROR_INVALID_FLAGS 1004
#define ERROR_UNRECOGNIZED_VOLUME 1005
#define ERROR_FILE_INVALID 1006
#define ERROR_FULLSCREEN_MODE 1007
#define ERROR_NO_TOKEN 1008
#define ERROR_BADDB 1009
#define ERROR_BADKEY 1010
#define ERROR_CANTOPEN 1011
#define ERROR_CANTREAD 1012
#define ERROR_CANTWRITE 1013
#define ERROR_REGISTRY_RECOVERED 1014
#define ERROR_REGISTRY_CORRUPT 1015
#define ERROR_REGISTRY_IO_FAILED 1016
#define ERROR_NOT_REGISTRY_FILE 1017
#define ERROR_KEY_DELETED 1018
#define ERROR_NO_LOG_SPACE 1019
#define ERROR_KEY_HAS_CHILDREN 1020
#define ERROR_CHILD_MUST_BE_VOLATILE 1021
#define ERROR_NOTIFY_ENUM_DIR 1022
#define ERROR_DEPENDENT_SERVICES_RUNNING 1051
#define ERROR_INVALID_SERVICE_CONTROL 1052
#define ERROR_SERVICE_REQUEST_TIMEOUT 1053
#define ERROR_SERVICE_NO_THREAD 1054
#define ERROR_SERVICE_DATABASE_LOCKED 1055
#define ERROR_SERVICE_ALREADY_RUNNING 1056
#define ERROR_INVALID_SERVICE_ACCOUNT 1057
#define ERROR_SERVICE_DISABLED 1058
#define ERROR_CIRCULAR_DEPENDENCY 1059
#define ERROR_SERVICE_DOES_NOT_EXIST 1060
#define ERROR_SERVICE_CANNOT_ACCEPT_CTRL 1061
#define ERROR_SERVICE_NOT_ACTIVE 1062
#define ERROR_FAILED_SERVICE_CONTROLLER_CONNECT 1063
#define ERROR_EXCEPTION_IN_SERVICE 1064
#define ERROR_DATABASE_DOES_NOT_EXIST 1065
#define ERROR_SERVICE_SPECIFIC_ERROR 1066
#define ERROR_PROCESS_ABORTED 1067
#define ERROR_SERVICE_DEPENDENCY_FAIL 1068
#define ERROR_SERVICE_LOGON_FAILED 1069
#define ERROR_SERVICE_START_HANG 1070
#define ERROR_INVALID_SERVICE_LOCK 1071
#define ERROR_SERVICE_MARKED_FOR_DELETE 1072
#define ERROR_SERVICE_EXISTS 1073
#define ERROR_ALREADY_RUNNING_LKG 1074
#define ERROR_SERVICE_DEPENDENCY_DELETED 1075
#define ERROR_BOOT_ALREADY_ACCEPTED 1076
#define ERROR_SERVICE_NEVER_STARTED 1077
#define ERROR_DUPLICATE_SERVICE_NAME 1078
#define ERROR_DIFFERENT_SERVICE_ACCOUNT 1079
#define ERROR_END_OF_MEDIA 1100
#define ERROR_FILEMARK_DETECTED 1101
#define ERROR_BEGINNING_OF_MEDIA 1102
#define ERROR_SETMARK_DETECTED 1103
#define ERROR_NO_DATA_DETECTED 1104
#define ERROR_PARTITION_FAILURE 1105
#define ERROR_INVALID_BLOCK_LENGTH 1106

#define ERROR_DEVICE_NOT_PARTITIONED 1107
#define ERROR_UNABLE_TO_LOCK_MEDIA 1108
#define ERROR_UNABLE_TO_UNLOAD_MEDIA 1109
#define ERROR_MEDIA_CHANGED 1110
#define ERROR_BUS_RESET 1111
#define ERROR_NO_MEDIA_IN_DRIVE 1112
#define ERROR_NO_UNICODE_TRANSLATION 1113
#define ERROR_DLL_INIT_FAILED 1114
#define ERROR_SHUTDOWN_IN_PROGRESS 1115
#define ERROR_NO_SHUTDOWN_IN_PROGRESS 1116
#define ERROR_IO_DEVICE 1117
#define ERROR_SERIAL_NO_DEVICE 1118
#define ERROR_IRQ_BUSY 1119
#define ERROR_MORE_WRITES 1120
#define ERROR_COUNTER_TIMEOUT 1121
#define ERROR_FLOPPY_ID_MARK_NOT_FOUND 1122
#define ERROR_FLOPPY_WRONG_CYLINDER 1123
#define ERROR_FLOPPY_UNKNOWN_ERROR 1124
#define ERROR_FLOPPY_BAD_REGISTERS 1125
#define ERROR_DISK_RECALIBRATE_FAILED 1126
#define ERROR_DISK_OPERATION_FAILED 1127
#define ERROR_DISK_RESET_FAILED 1128
#define ERROR_EOM_OVERFLOW 1129
#define ERROR_NOT_ENOUGH_SERVER_MEMORY 1130
#define ERROR_POSSIBLE_DEADLOCK 1131
#define ERROR_MAPPED_ALIGNMENT 1132
#define ERROR_SET_POWER_STATE_VETOED 1140
#define ERROR_SET_POWER_STATE_FAILED 1141
#define ERROR_TOO_MANY_LINKS 1142
#define ERROR_OLD_WIN_VERSION 1150
#define ERROR_APP_WRONG_OS 1151
#define ERROR_SINGLE_INSTANCE_APP 1152
#define ERROR_RMODE_APP 1153
#define ERROR_INVALID_DLL 1154
#define ERROR_NO_ASSOCIATION 1155
#define ERROR_DDE_FAIL 1156
#define ERROR_DLL_NOT_FOUND 1157
#define ERROR_BAD_USERNAME 2202
#define ERROR_NOT_CONNECTED 2250
#define ERROR_OPEN_FILES 2401
#define ERROR_ACTIVE_CONNECTIONS 2402
#define ERROR_DEVICE_IN_USE 2404
#define ERROR_BAD_DEVICE 1200
#define ERROR_CONNECTION_UNAVAIL 1201
#define ERROR_DEVICE_ALREADY_REMEMBERED 1202
#define ERROR_NO_NET_OR_BAD_PATH 1203
#define ERROR_BAD_PROVIDER 1204
#define ERROR_CANNOT_OPEN_PROFILE 1205
#define ERROR_BAD_PROFILE 1206
#define ERROR_NOT_CONTAINER 1207
#define ERROR_EXTENDED_ERROR 1208
#define ERROR_INVALID_GROUPNAME 1209
#define ERROR_INVALID_COMPUTERNAME 1210
#define ERROR_INVALID_EVENTNAME 1211
#define ERROR_INVALID_DOMAINNAME 1212
#define ERROR_INVALID_SERVICENAME 1213
#define ERROR_INVALID_NETNAME 1214
#define ERROR_INVALID_SHARENAME 1215
#define ERROR_INVALID_PASSWORDNAME 1216
#define ERROR_INVALID_MESSAGENAME 1217
#define ERROR_INVALID_MESSAGEDEST 1218
#define ERROR_SESSION_CREDENTIAL_CONFLICT 1219
#define ERROR_REMOTE_SESSION_LIMIT_EXCEEDED 1220
#define ERROR_DUP_DOMAINNAME 1221
#define ERROR_NO_NETWORK 1222
#define ERROR_CANCELLED 1223
#define ERROR_USER_MAPPED_FILE 1224
#define ERROR_CONNECTION_REFUSED 1225
#define ERROR_GRACEFUL_DISCONNECT 1226
#define ERROR_ADDRESS_ALREADY_ASSOCIATED 1227
#define ERROR_ADDRESS_NOT_ASSOCIATED 1228
#define ERROR_CONNECTION_INVALID 1229
#define ERROR_CONNECTION_ACTIVE 1230
#define ERROR_NETWORK_UNREACHABLE 1231
#define ERROR_HOST_UNREACHABLE 1232
#define ERROR_PROTOCOL_UNREACHABLE 1233
#define ERROR_PORT_UNREACHABLE 1234
#define ERROR_REQUEST_ABORTED 1235
#define ERROR_CONNECTION_ABORTED 1236
#define ERROR_RETRY 1237
#define ERROR_CONNECTION_COUNT_LIMIT 1238
#define ERROR_LOGIN_TIME_RESTRICTION 1239
#define ERROR_LOGIN_WKSTA_RESTRICTION 1240
#define ERROR_INCORRECT_ADDRESS 1241
#define ERROR_ALREADY_REGISTERED 1242
#define ERROR_SERVICE_NOT_FOUND 1243
#define ERROR_NOT_AUTHENTICATED 1244
#define ERROR_NOT_LOGGED_ON 1245
#define ERROR_CONTINUE 1246
#define ERROR_ALREADY_INITIALIZED 1247
#define ERROR_NO_MORE_DEVICES 1248
#define ERROR_NOT_ALL_ASSIGNED 1300
#define ERROR_SOME_NOT_MAPPED 1301
#define ERROR_NO_QUOTAS_FOR_ACCOUNT 1302
#define ERROR_LOCAL_USER_SESSION_KEY 1303
#define ERROR_NULL_LM_PASSWORD 1304
#define ERROR_UNKNOWN_REVISION 1305
#define ERROR_REVISION_MISMATCH 1306
#define ERROR_INVALID_OWNER 1307
#define ERROR_INVALID_PRIMARY_GROUP 1308
#define ERROR_NO_IMPERSONATION_TOKEN 1309
#define ERROR_CANT_DISABLE_MANDATORY 1310
#define ERROR_NO_LOGON_SERVERS 1311
#define ERROR_NO_SUCH_LOGON_SESSION 1312
#define ERROR_NO_SUCH_PRIVILEGE 1313
#define ERROR_PRIVILEGE_NOT_HELD 1314
#define ERROR_INVALID_ACCOUNT_NAME 1315
#define ERROR_USER_EXISTS 1316
#define ERROR_NO_SUCH_USER 1317
#define ERROR_GROUP_EXISTS 1318
#define ERROR_NO_SUCH_GROUP 1319
#define ERROR_MEMBER_IN_GROUP 1320
#define ERROR_MEMBER_NOT_IN_GROUP 1321
#define ERROR_LAST_ADMIN 1322
#define ERROR_WRONG_PASSWORD 1323
#define ERROR_ILL_FORMED_PASSWORD 1324
#define ERROR_PASSWORD_RESTRICTION 1325
#define ERROR_LOGON_FAILURE 1326
#define ERROR_ACCOUNT_RESTRICTION 1327
#define ERROR_INVALID_LOGON_HOURS 1328
#define ERROR_INVALID_WORKSTATION 1329
#define ERROR_PASSWORD_EXPIRED 1330
#define ERROR_ACCOUNT_DISABLED 1331
#define ERROR_NONE_MAPPED 1332
#define ERROR_TOO_MANY_LUIDS_REQUESTED 1333
#define ERROR_LUIDS_EXHAUSTED 1334
#define ERROR_INVALID_SUB_AUTHORITY 1335
#define ERROR_INVALID_ACL 1336
#define ERROR_INVALID_SID 1337
#define ERROR_INVALID_SECURITY_DESCR 1338
#define ERROR_BAD_INHERITANCE_ACL 1340
#define ERROR_SERVER_DISABLED 1341
#define ERROR_SERVER_NOT_DISABLED 1342
#define ERROR_INVALID_ID_AUTHORITY 1343
#define ERROR_ALLOTTED_SPACE_EXCEEDED 1344
#define ERROR_INVALID_GROUP_ATTRIBUTES 1345
#define ERROR_BAD_IMPERSONATION_LEVEL 1346
#define ERROR_CANT_OPEN_ANONYMOUS 1347
#define ERROR_BAD_VALIDATION_CLASS 1348
#define ERROR_BAD_TOKEN_TYPE 1349
#define ERROR_NO_SECURITY_ON_OBJECT 1350
#define ERROR_CANT_ACCESS_DOMAIN_INFO 1351
#define ERROR_INVALID_SERVER_STATE 1352
#define ERROR_INVALID_DOMAIN_STATE 1353
#define ERROR_INVALID_DOMAIN_ROLE 1354
#define ERROR_NO_SUCH_DOMAIN 1355
#define ERROR_DOMAIN_EXISTS 1356
#define ERROR_DOMAIN_LIMIT_EXCEEDED 1357
#define ERROR_INTERNAL_DB_CORRUPTION 1358
#define ERROR_INTERNAL_ERROR 1359
#define ERROR_GENERIC_NOT_MAPPED 1360
#define ERROR_BAD_DESCRIPTOR_FORMAT 1361
#define ERROR_NOT_LOGON_PROCESS 1362
#define ERROR_LOGON_SESSION_EXISTS 1363
#define ERROR_NO_SUCH_PACKAGE 1364
#define ERROR_BAD_LOGON_SESSION_STATE 1365
#define ERROR_LOGON_SESSION_COLLISION 1366
#define ERROR_INVALID_LOGON_TYPE 1367
#define ERROR_CANNOT_IMPERSONATE 1368
#define ERROR_RXACT_INVALID_STATE 1369
#define ERROR_RXACT_COMMIT_FAILURE 1370
#define ERROR_SPECIAL_ACCOUNT 1371
#define ERROR_SPECIAL_GROUP 1372
#define ERROR_SPECIAL_USER 1373
#define ERROR_MEMBERS_PRIMARY_GROUP 1374
#define ERROR_TOKEN_ALREADY_IN_USE 1375
#define ERROR_NO_SUCH_ALIAS 1376
#define ERROR_MEMBER_NOT_IN_ALIAS 1377
#define ERROR_MEMBER_IN_ALIAS 1378
#define ERROR_ALIAS_EXISTS 1379
#define ERROR_LOGON_NOT_GRANTED 1380
#define ERROR_TOO_MANY_SECRETS 1381
#define ERROR_SECRET_TOO_LONG 1382
#define ERROR_INTERNAL_DB_ERROR 1383
#define ERROR_TOO_MANY_CONTEXT_IDS 1384
#define ERROR_LOGON_TYPE_NOT_GRANTED 1385
#define ERROR_NT_CROSS_ENCRYPTION_REQUIRED 1386
#define ERROR_NO_SUCH_MEMBER 1387
#define ERROR_INVALID_MEMBER 1388
#define ERROR_TOO_MANY_SIDS 1389
#define ERROR_LM_CROSS_ENCRYPTION_REQUIRED 1390
#define ERROR_NO_INHERITANCE 1391
#define ERROR_FILE_CORRUPT 1392
#define ERROR_DISK_CORRUPT 1393
#define ERROR_NO_USER_SESSION_KEY 1394
#define ERROR_LICENSE_QUOTA_EXCEEDED 1395
#define ERROR_INVALID_WINDOW_HANDLE 1400
#define ERROR_INVALID_MENU_HANDLE 1401
#define ERROR_INVALID_CURSOR_HANDLE 1402
#define ERROR_INVALID_ACCEL_HANDLE 1403
#define ERROR_INVALID_HOOK_HANDLE 1404
#define ERROR_INVALID_DWP_HANDLE 1405
#define ERROR_TLW_WITH_WSCHILD 1406
#define ERROR_CANNOT_FIND_WND_CLASS 1407
#define ERROR_WINDOW_OF_OTHER_THREAD 1408
#define ERROR_HOTKEY_ALREADY_REGISTERED 1409
#define ERROR_CLASS_ALREADY_EXISTS 1410
#define ERROR_CLASS_DOES_NOT_EXIST 1411
#define ERROR_CLASS_HAS_WINDOWS 1412
#define ERROR_INVALID_INDEX 1413
#define ERROR_INVALID_ICON_HANDLE 1414
#define ERROR_PRIVATE_DIALOG_INDEX 1415
#define ERROR_LISTBOX_ID_NOT_FOUND 1416
#define ERROR_NO_WILDCARD_CHARACTERS 1417
#define ERROR_CLIPBOARD_NOT_OPEN 1418
#define ERROR_HOTKEY_NOT_REGISTERED 1419
#define ERROR_WINDOW_NOT_DIALOG 1420
#define ERROR_CONTROL_ID_NOT_FOUND 1421
#define ERROR_INVALID_COMBOBOX_MESSAGE 1422
#define ERROR_WINDOW_NOT_COMBOBOX 1423
#define ERROR_INVALID_EDIT_HEIGHT 1424
#define ERROR_DC_NOT_FOUND 1425
#define ERROR_INVALID_HOOK_FILTER 1426
#define ERROR_INVALID_FILTER_PROC 1427
#define ERROR_HOOK_NEEDS_HMOD 1428
#define ERROR_GLOBAL_ONLY_HOOK 1429
#define ERROR_JOURNAL_HOOK_SET 1430
#define ERROR_HOOK_NOT_INSTALLED 1431
#define ERROR_INVALID_LB_MESSAGE 1432
#define ERROR_SETCOUNT_ON_BAD_LB 1433
#define ERROR_LB_WITHOUT_TABSTOPS 1434
#define ERROR_DESTROY_OBJECT_OF_OTHER_THREAD 1435
#define ERROR_CHILD_WINDOW_MENU 1436
#define ERROR_NO_SYSTEM_MENU 1437
#define ERROR_INVALID_MSGBOX_STYLE 1438
#define ERROR_INVALID_SPI_VALUE 1439
#define ERROR_SCREEN_ALREADY_LOCKED 1440
#define ERROR_HWNDS_HAVE_DIFF_PARENT 1441
#define ERROR_NOT_CHILD_WINDOW 1442
#define ERROR_INVALID_GW_COMMAND 1443
#define ERROR_INVALID_THREAD_ID 1444
#define ERROR_NON_MDICHILD_WINDOW 1445
#define ERROR_POPUP_ALREADY_ACTIVE 1446
#define ERROR_NO_SCROLLBARS 1447
#define ERROR_INVALID_SCROLLBAR_RANGE 1448
#define ERROR_INVALID_SHOWWIN_COMMAND 1449
#define ERROR_NO_SYSTEM_RESOURCES 1450
#define ERROR_NONPAGED_SYSTEM_RESOURCES 1451
#define ERROR_PAGED_SYSTEM_RESOURCES 1452
#define ERROR_WORKING_SET_QUOTA 1453
#define ERROR_PAGEFILE_QUOTA 1454
#define ERROR_COMMITMENT_LIMIT 1455
#define ERROR_MENU_ITEM_NOT_FOUND 1456
#define ERROR_INVALID_KEYBOARD_HANDLE 1457
#define ERROR_HOOK_TYPE_NOT_ALLOWED 1458
#define ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION 1459
#define ERROR_EVENTLOG_FILE_CORRUPT 1500
#define ERROR_EVENTLOG_CANT_START 1501
#define ERROR_LOG_FILE_FULL 1502
#define ERROR_EVENTLOG_FILE_CHANGED 1503

#define OWNER_SECURITY_INFORMATION 0x00000001
#define GROUP_SECURITY_INFORMATION 0x00000002

#define TOKEN_QUERY (0x0008)


/*
proc
*/
#define DECLARE_HANDLE(n) typedef HANDLE n

typedef void *HANDLE;
typedef HANDLE HRGN;
typedef float FLOAT;
typedef int INT;
typedef unsigned char BYTE;
typedef BYTE* LPBYTE;
typedef struct {int dummy;} *HWND;
typedef const char *LPCSTR;
typedef char *LPSTR;
typedef unsigned int UINT;
typedef void* HANDLE;
typedef void* HINSTANCE;
typedef void* HMODULE;
typedef void* HLOCAL;
typedef void* LPVOID;
typedef void* HFONT;
typedef void* HDWP;
typedef unsigned short *LPWSTR;
//typedef short *LPWSTR;
//typedef const signed short *LPCWSTR;
typedef const unsigned short *LPCWSTR;
typedef const void* LPCVOID;
typedef void* PVOID;
typedef int LONG;
typedef unsigned int ULONG;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef DWORD* PDWORD;
typedef DWORD* LPDWORD;
typedef int BOOL;
typedef void VOID;
typedef long LONG_PTR;
typedef unsigned long ULONG_PTR;
typedef ULONG_PTR DWORD_PTR;
typedef unsigned long long ULONGLONG;
typedef signed long long LONGLONG;
typedef char CHAR;
typedef unsigned short WCHAR;
typedef short int SHORT;
typedef WORD* LPWORD;
typedef BOOL (CALLBACK *PHANDLER_ROUTINE) (DWORD);
typedef unsigned long long UINT_PTR;
typedef UINT_PTR WPARAM;
typedef LONG_PTR LPARAM;
typedef BYTE *PBYTE;
typedef unsigned long COLORREF;
typedef WORD ATOM;
typedef long LRESULT;
typedef HANDLE HICON;
typedef LRESULT (CALLBACK *WNDPROC) (HWND,UINT,WPARAM,LPARAM);
typedef HANDLE HCURSOR;
typedef char *PSTR;
typedef const unsigned short *LPCTSTR;
typedef DWORD (CALLBACK *PTHREAD_START_ROUTINE) (LPVOID);
typedef PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;
typedef HANDLE HGLOBAL;
typedef HANDLE HDC;
typedef HANDLE HBITMAP;
typedef HANDLE HPEN;
typedef HANDLE HBRUSH;
typedef HANDLE *PHANDLE;
typedef HANDLE HMENU;
typedef HANDLE HGLRC;
typedef HANDLE HGDIOBJ;
typedef HANDLE HKEY,*PHKEY;
typedef DWORD ACCESS_MASK;
typedef ACCESS_MASK REGSAM;
typedef BOOL *LPBOOL;
typedef int *PINT;
typedef long *PLONG;
typedef short *PSHORT;
typedef ULONG_PTR SIZE_T;
typedef SIZE_T *PSIZE_T;
typedef HANDLE *LPHANDLE;
typedef long long int LONG64;
typedef unsigned short *PWORD;
typedef HANDLE HWAVEOUT;
typedef int MMRESULT;
typedef void* LPWAVEOUT;
typedef long long int INT_PTR;
typedef unsigned long long int UINT_PTR;
typedef BOOL (CALLBACK *DLGPROC) (HWND,UINT,WPARAM,LPARAM);
typedef int *LPINT;
//typedef const unsigned short *LPCWSTR;
typedef const unsigned short *PCWSTR;
typedef unsigned short USHORT;
typedef USHORT COLOR16;
typedef struct _TRIVERTEX {
	LONG x; LONG y; COLOR16 Red; COLOR16 Green;
COLOR16 Blue; COLOR16 Alpha;
} TRIVERTEX,*PTRIVERTEX,*LPTRIVERTEX;


/*
proc
*/

typedef struct _nmhdr {
  HWND hwndFrom;
  UINT idFrom;
  UINT code;
} NMHDR;

typedef struct tagWINDOWPOS {
  HWND hwnd;
  HWND hwndInsertAfter;
  int  x;
  int  y;
  int  cx;
  int  cy;
  UINT flags;
} WINDOWPOS, *LPWINDOWPOS, *PWINDOWPOS;

typedef struct tagPOINT {
	LONG x;
	LONG y;
} POINT,*PPOINT;
#define LPPOINT PPOINT

typedef struct tagMSG {
	HWND hwnd;
	UINT message;
	WPARAM wParam;
	LPARAM lParam;
	DWORD time;
	POINT pt;
} MSG,*LPMSG,*PMSG;

typedef struct _LIST_ENTRY {
	struct _LIST_ENTRY *Flink;
	struct _LIST_ENTRY *Blink;
} LIST_ENTRY,*PLIST_ENTRY;

typedef struct _CONSOLE_CURSOR_INFO {
	DWORD dwSize;
	BOOL bVisible;
} CONSOLE_CURSOR_INFO,*PCONSOLE_CURSOR_INFO;

typedef struct {
	PVOID BaseAddress;
	PVOID AllocationBase;
	DWORD AllocationProtect;
	DWORD RegionSize;
	DWORD State;
	DWORD Protect;
	DWORD Type;
} MEMORY_BASIC_INFORMATION;

typedef struct _RTL_CRITICAL_SECTION_DEBUG {
	WORD Type;
	WORD CreatorBackTraceIndex;
	struct _RTL_CRITICAL_SECTION *CriticalSection;
	LIST_ENTRY ProcessLocksList;
	DWORD EntryCount;
	DWORD ContentionCount;
	DWORD Spare[ 2];
} RTL_CRITICAL_SECTION_DEBUG,*PRTL_CRITICAL_SECTION_DEBUG;

typedef struct {
	PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
	LONG LockCount;
	LONG RecursionCount;
	HANDLE OwningThread;
	HANDLE LockSemaphore;
	ULONG_PTR SpinCount;
} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;

typedef RTL_CRITICAL_SECTION CRITICAL_SECTION,*LPCRITICAL_SECTION;

typedef struct _SECURITY_ATTRIBUTES {
	DWORD nLength;
	LPVOID lpSecurityDescriptor;
	BOOL bInheritHandle;
} SECURITY_ATTRIBUTES,*LPSECURITY_ATTRIBUTES;

typedef enum _GET_FILEEX_INFO_LEVELS { GetFileExInfoStandard, GetFileExMaxInfoLevel } GET_FILEEX_INFO_LEVELS;

typedef struct tagFILETIME {
	DWORD dwLowDateTime;
	DWORD dwHighDateTime;
} FILETIME,*LPFILETIME,*PFILETIME;

typedef struct _WIN32_FIND_DATAA {
	DWORD dwFileAttributes;
	FILETIME ftCreationTime;
	FILETIME ftLastAccessTime;
	FILETIME ftLastWriteTime;
	DWORD nFileSizeHigh;
	DWORD nFileSizeLow;
	DWORD dwReserved0;
	DWORD dwReserved1;
	CHAR   cFileName[ MAX_PATH ];
	CHAR   cAlternateFileName[ 14 ];
} WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;

typedef struct _WIN32_FIND_DATAW {
	DWORD dwFileAttributes;
	FILETIME ftCreationTime;
	FILETIME ftLastAccessTime;
	FILETIME ftLastWriteTime;
	DWORD nFileSizeHigh;
	DWORD nFileSizeLow;
	DWORD dwReserved0;
	DWORD dwReserved1;
	WCHAR  cFileName[ MAX_PATH ];
	WCHAR  cAlternateFileName[ 14 ];
} WIN32_FIND_DATAW, *PWIN32_FIND_DATAW, *LPWIN32_FIND_DATAW;

typedef struct _COORD {
	SHORT X;
	SHORT Y;
} COORD;
//!=================

typedef struct _CHAR_INFO {
	union { WCHAR UnicodeChar; CHAR AsciiChar; } Char;
	WORD Attributes;
} CHAR_INFO,*PCHAR_INFO;

typedef struct _SMALL_RECT {
	SHORT Left;
	SHORT Top;
	SHORT Right;
	SHORT Bottom;
} SMALL_RECT,*PSMALL_RECT;

typedef struct _FOCUS_EVENT_RECORD {
	BOOL bSetFocus;
} FOCUS_EVENT_RECORD;

typedef struct _CONSOLE_SCREEN_BUFFER_INFO {
	COORD dwSize;
	COORD dwCursorPosition;
	WORD wAttributes;
	SMALL_RECT srWindow;
	COORD dwMaximumWindowSize;
} CONSOLE_SCREEN_BUFFER_INFO,*PCONSOLE_SCREEN_BUFFER_INFO;

typedef struct _KEY_EVENT_RECORD {
	BOOL bKeyDown;
	WORD wRepeatCount;
	WORD wVirtualKeyCode;
	WORD wVirtualScanCode;
	union { WCHAR UnicodeChar; CHAR AsciiChar; } uChar;
	DWORD dwControlKeyState;
} KEY_EVENT_RECORD;

typedef struct _MOUSE_EVENT_RECORD {
	COORD dwMousePosition;
	DWORD dwButtonState;
	DWORD dwControlKeyState;
	DWORD dwEventFlags;
} MOUSE_EVENT_RECORD;

typedef struct _WINDOW_BUFFER_SIZE_RECORD {
	COORD dwSize;
} WINDOW_BUFFER_SIZE_RECORD;

typedef struct _MENU_EVENT_RECORD {
	UINT dwCommandId;
} MENU_EVENT_RECORD,*PMENU_EVENT_RECORD;

typedef struct _INPUT_RECORD {
	WORD EventType;
	WORD __alignmentDummy;
	union {
		KEY_EVENT_RECORD KeyEvent;
		MOUSE_EVENT_RECORD MouseEvent;
		WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
		MENU_EVENT_RECORD MenuEvent;
		FOCUS_EVENT_RECORD FocusEvent;
	} Event;
} INPUT_RECORD,*PINPUT_RECORD;

typedef struct _STARTUPINFOW {
	DWORD cb;
	LPWSTR lpReserved;
	LPWSTR lpDesktop;
	LPWSTR lpTitle;
	DWORD dwX;
	DWORD dwY;
	DWORD dwXSize;
	DWORD dwYSize;
	DWORD dwXCountChars;
	DWORD dwYCountChars;
	DWORD dwFillAttribute;
	DWORD dwFlags;
	WORD wShowWindow;
	WORD cbReserved2;
	LPBYTE lpReserved2;
	HANDLE hStdInput;
	HANDLE hStdOutput;
	HANDLE hStdError;
} STARTUPINFOW, *LPSTARTUPINFOW;

typedef struct _PROCESS_INFORMATION {
	HANDLE hProcess;
	HANDLE hThread;
	DWORD dwProcessId;
	DWORD dwThreadId;
} PROCESS_INFORMATION,*LPPROCESS_INFORMATION;

typedef struct _WIN32_FILE_ATTRIBUTE_DATA {
	DWORD dwFileAttributes;
	FILETIME ftCreationTime;
	FILETIME ftLastAccessTime;
	FILETIME ftLastWriteTime;
	DWORD nFileSizeHigh;
	DWORD nFileSizeLow;
} WIN32_FILE_ATTRIBUTE_DATA,*LPWIN32_FILE_ATTRIBUTE_DATA;
typedef struct tagWNDCLASSA {
	UINT	style;
	WNDPROC	lpfnWndProc;
	int	cbClsExtra;
	int	cbWndExtra;
	HINSTANCE	hInstance;
	HICON	hIcon;
	HCURSOR	hCursor;
	HBRUSH	hbrBackground;
	LPCSTR	lpszMenuName;
	LPCSTR	lpszClassName;
} WNDCLASSA, *PWNDCLASSA,*NPWNDCLASSA,*LPWNDCLASSA;
typedef struct tagWNDCLASSW {
	UINT	style;
	WNDPROC	lpfnWndProc;
	int	cbClsExtra;
	int	cbWndExtra;
	HINSTANCE hInstance;
	HICON	hIcon;
	HCURSOR	hCursor;
	HBRUSH	hbrBackground;
	LPCWSTR	lpszMenuName;
	LPCWSTR	lpszClassName;
} WNDCLASSW, *PWNDCLASSW,*NPWNDCLASSW,*LPWNDCLASSW;
typedef struct tagWNDCLASSEXA {
	UINT	cbSize;
	UINT	style;
	WNDPROC	lpfnWndProc;
	int	cbClsExtra;
	int	cbWndExtra;
	HINSTANCE	hInstance;
	HICON	hIcon;
	HCURSOR	hCursor;
	HBRUSH	hbrBackground;
	LPCSTR	lpszMenuName;
	LPCSTR	lpszClassName;
	HICON	hIconSm;
} WNDCLASSEXA, *PWNDCLASSEXA,*NPWNDCLASSEXA,*LPWNDCLASSEXA;
typedef struct tagWNDCLASSEXW {
	UINT cbSize;
	UINT style;
	WNDPROC lpfnWndProc;
	int cbClsExtra;
	int cbWndExtra;
	HINSTANCE hInstance;
	HICON hIcon;
	HCURSOR hCursor;
	HBRUSH hbrBackground;
	LPCWSTR lpszMenuName;
	LPCWSTR lpszClassName;
	HICON hIconSm;
} WNDCLASSEXW,*PWNDCLASSEXW,*NPWNDCLASSEXW,*LPWNDCLASSEXW;
#ifdef UNICODE
	typedef WNDCLASSW WNDCLASS;
	typedef PWNDCLASSW PWNDCLASS;
	typedef NPWNDCLASSW NPWNDCLASS;
	typedef LPWNDCLASSW LPWNDCLASS;
	typedef WNDCLASSEXW WNDCLASSEX;
#else
	typedef WNDCLASSA WNDCLASS;
	typedef PWNDCLASSA PWNDCLASS;
	typedef NPWNDCLASSA NPWNDCLASS;
	typedef LPWNDCLASSA LPWNDCLASS;
	typedef WNDCLASSEXA WNDCLASSEX;
#endif
typedef struct _RECT {
	LONG left;
	LONG top;
	LONG right;
	LONG bottom;
} RECT,*LPRECT;

typedef const RECT *LPCRECT;

typedef struct tagPAINTSTRUCT {
	HDC hdc;
	BOOL fErase;
	RECT rcPaint;
	BOOL fRestore;
	BOOL fIncUpdate;
	BYTE rgbReserved[32];
} PAINTSTRUCT,*LPPAINTSTRUCT;
typedef struct tagCREATESTRUCT {
	LPVOID lpCreateParams;
	HINSTANCE hInstance;
	HMENU hMenu;
	HWND hwndParent;
	int cy;
	int cx;
	int y;
	int x;
	LONG style;
	LPCTSTR lpszName;
	LPCTSTR lpszClass;
	DWORD dwExStyle;
} CREATESTRUCT,*LPCREATESTRUCT;

typedef struct tagBITMAP {
	LONG bmType;
	LONG bmWidth;
	LONG bmHeight;
	LONG bmWidthBytes;
	WORD bmPlanes;
	WORD bmBitsPixel;
	LPVOID bmBits;
} BITMAP,*PBITMAP,*NPBITMAP,*LPBITMAP;
typedef struct tagBITMAPCOREHEADER {
	DWORD bcSize;
	WORD bcWidth;
	WORD bcHeight;
	WORD bcPlanes;
	WORD bcBitCount;
} BITMAPCOREHEADER;
 /* was missing jn */
typedef BITMAPCOREHEADER *LPBITMAPCOREHEADER;
typedef struct tagRGBTRIPLE {
	BYTE rgbtBlue;
	BYTE rgbtGreen;
	BYTE rgbtRed;
} RGBTRIPLE;
typedef struct _BITMAPCOREINFO {
	BITMAPCOREHEADER bmciHeader;
	RGBTRIPLE bmciColors[1];
} BITMAPCOREINFO;
/* was missing jn */
typedef BITMAPCOREINFO *LPBITMAPCOREINFO;
typedef struct tagBITMAPFILEHEADER {
	WORD bfType;
	DWORD bfSize;
	WORD bfReserved1;
	WORD bfReserved2;
	DWORD bfOffBits;
} BITMAPFILEHEADER,*LPBITMAPFILEHEADER,*PBITMAPFILEHEADER;
typedef struct tagBITMAPINFOHEADER {
	DWORD biSize;
	LONG biWidth;
	LONG biHeight;
	WORD biPlanes;
	WORD biBitCount;
	DWORD biCompression;
	DWORD biSizeImage;
	LONG biXPelsPerMeter;
	LONG biYPelsPerMeter;
	DWORD biClrUsed;
	DWORD biClrImportant;
} BITMAPINFOHEADER,*LPBITMAPINFOHEADER,*PBITMAPINFOHEADER;
typedef struct tagRGBQUAD {
	BYTE rgbBlue;
	BYTE rgbGreen;
	BYTE rgbRed;
	BYTE rgbReserved;
} RGBQUAD,*LPRGBQUAD;
typedef struct tagBITMAPINFO {
	BITMAPINFOHEADER bmiHeader;
	RGBQUAD bmiColors[1];
} BITMAPINFO,*LPBITMAPINFO,*PBITMAPINFO;
typedef union _LARGE_INTEGER {
	struct { DWORD LowPart; LONG HighPart;};
	struct { DWORD LowPart; LONG HighPart; } u;
	long long int QuadPart;
} LARGE_INTEGER,*PLARGE_INTEGER;
typedef VOID (CALLBACK *TIMERPROC) (HWND,UINT,UINT,DWORD);

typedef struct _STARTUPINFOA {
	DWORD cb;
	LPSTR lpReserved;
	LPSTR lpDesktop;
	LPSTR lpTitle;
	DWORD dwX;
	DWORD dwY;
	DWORD dwXSize;
	DWORD dwYSize;
	DWORD dwXCountChars;
	DWORD dwYCountChars;
	DWORD dwFillAttribute;
	DWORD dwFlags;
	WORD wShowWindow;
	WORD cbReserved2;
	LPBYTE lpReserved2;
	HANDLE hStdInput;
	HANDLE hStdOutput;
	HANDLE hStdError;
} STARTUPINFOA, *LPSTARTUPINFOA;
typedef struct _SYSTEMTIME {
	WORD wYear;
	WORD wMonth;
	WORD wDayOfWeek;
	WORD wDay;
	WORD wHour;
	WORD wMinute;
	WORD wSecond;
	WORD wMilliseconds;
} SYSTEMTIME,*LPSYSTEMTIME,*PSYSTEMTIME;
typedef struct _SYSTEM_INFO {
	WORD wProcessorArchitecture;
	WORD wReserved;
	DWORD dwPageSize;
	LPVOID lpMinimumApplicationAddress;
	LPVOID lpMaximumApplicationAddress;
	DWORD dwActiveProcessorMask;
	DWORD dwNumberOfProcessors;
	DWORD dwProcessorType;
	DWORD dwAllocationGranularity;
	WORD wProcessorLevel;
	WORD wProcessorRevision;
} SYSTEM_INFO,*LPSYSTEM_INFO;
typedef struct _OVERLAPPED {
	DWORD Internal;
	DWORD InternalHigh;
	DWORD Offset;
	DWORD OffsetHigh;
	HANDLE hEvent;
} OVERLAPPED,*LPOVERLAPPED;
typedef struct _IO_COUNTERS {
	ULONGLONG ReadOperationCount;
	ULONGLONG WriteOperationCount;
	ULONGLONG OtherOperationCount;
	ULONGLONG ReadTransferCount;
	ULONGLONG WriteTransferCount;
	ULONGLONG OtherTransferCount;
} IO_COUNTERS;
typedef IO_COUNTERS *PIO_COUNTERS;
typedef union _ULARGE_INTEGER {
	struct {DWORD LowPart; DWORD HighPart;};
	long long QuadPart;
} ULARGE_INTEGER,*PULARGE_INTEGER;
typedef struct tagLOGFONTW
{
	LONG	lfHeight;
	LONG	lfWidth;
	LONG	lfEscapement;
	LONG	lfOrientation;
	LONG	lfWeight;
	BYTE	lfItalic;
	BYTE	lfUnderline;
	BYTE	lfStrikeOut;
	BYTE	lfCharSet;
	BYTE	lfOutPrecision;
	BYTE	lfClipPrecision;
	BYTE	lfQuality;
	BYTE	lfPitchAndFamily;
	WCHAR	lfFaceName[LF_FACESIZE];
} LOGFONTW, *PLOGFONTW, *NPLOGFONTW, *LPLOGFONTW;
typedef struct _BY_HANDLE_FILE_INFORMATION {
	DWORD dwFileAttributes;
	FILETIME ftCreationTime;
	FILETIME ftLastAccessTime;
	FILETIME ftLastWriteTime;
	DWORD dwVolumeSerialNumber;
	DWORD nFileSizeHigh;
	DWORD nFileSizeLow;
	DWORD nNumberOfLinks;
	DWORD nFileIndexHigh;
	DWORD nFileIndexLow;
} BY_HANDLE_FILE_INFORMATION,*LPBY_HANDLE_FILE_INFORMATION;
typedef struct _IMAGE_DOS_HEADER {
	WORD e_magic;
	WORD e_cblp;
	WORD e_cp;
	WORD e_crlc;
	WORD e_cparhdr;
	WORD e_minalloc;
	WORD e_maxalloc;
	WORD e_ss;
	WORD e_sp;
	WORD e_csum;
	WORD e_ip;
	WORD e_cs;
	WORD e_lfarlc;
	WORD e_ovno;
	WORD e_res[4];
	WORD e_oemid;
	WORD e_oeminfo;
	WORD e_res2[10];
	LONG e_lfanew;
} IMAGE_DOS_HEADER,*PIMAGE_DOS_HEADER;
typedef struct _IMAGE_FILE_HEADER {
	WORD Machine;
	WORD NumberOfSections;
	DWORD TimeDateStamp;
	DWORD PointerToSymbolTable;
	DWORD NumberOfSymbols;
	WORD SizeOfOptionalHeader;
	WORD Characteristics;
} IMAGE_FILE_HEADER,*PIMAGE_FILE_HEADER;
typedef struct _IMAGE_DATA_DIRECTORY {
	DWORD VirtualAddress;
	DWORD Size;
} IMAGE_DATA_DIRECTORY,*PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_OPTIONAL_HEADER {
    //
    // Standard fields.
    //

    WORD    Magic;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;
    DWORD   BaseOfCode;
    DWORD   BaseOfData;

    //
    // NT additional fields.
    //

    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;


typedef struct _IMAGE_OPTIONAL_HEADER64 {
    WORD        Magic;
    BYTE        MajorLinkerVersion;
    BYTE        MinorLinkerVersion;
    DWORD       SizeOfCode;
    DWORD       SizeOfInitializedData;
    DWORD       SizeOfUninitializedData;
    DWORD       AddressOfEntryPoint;
    DWORD       BaseOfCode;
    ULONGLONG   ImageBase;
    DWORD       SectionAlignment;
    DWORD       FileAlignment;
    WORD        MajorOperatingSystemVersion;
    WORD        MinorOperatingSystemVersion;
    WORD        MajorImageVersion;
    WORD        MinorImageVersion;
    WORD        MajorSubsystemVersion;
    WORD        MinorSubsystemVersion;
    DWORD       Win32VersionValue;
    DWORD       SizeOfImage;
    DWORD       SizeOfHeaders;
    DWORD       CheckSum;
    WORD        Subsystem;
    WORD        DllCharacteristics;
    ULONGLONG   SizeOfStackReserve;
    ULONGLONG   SizeOfStackCommit;
    ULONGLONG   SizeOfHeapReserve;
    ULONGLONG   SizeOfHeapCommit;
    DWORD       LoaderFlags;
    DWORD       NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;

#define IMAGE_SIZEOF_NT_OPTIONAL64_HEADER	240

typedef struct _IMAGE_SECTION_HEADER {
	BYTE Name[IMAGE_SIZEOF_SHORT_NAME];
	union {
		DWORD PhysicalAddress;
		DWORD VirtualSize;
	} Misc;
	DWORD VirtualAddress;
	DWORD SizeOfRawData;
	DWORD PointerToRawData;
	DWORD PointerToRelocations;
	DWORD PointerToLinenumbers;
	WORD NumberOfRelocations;
	WORD NumberOfLinenumbers;
	DWORD Characteristics;
} IMAGE_SECTION_HEADER,*PIMAGE_SECTION_HEADER;

typedef struct _IMAGE_IMPORT_BY_NAME {
	WORD Hint;
	BYTE Name[1];
} IMAGE_IMPORT_BY_NAME,*PIMAGE_IMPORT_BY_NAME;
typedef struct _IMAGE_THUNK_DATA {
	union {
		PBYTE ForwarderString;
		PDWORD Function;
		DWORD Ordinal;
		PIMAGE_IMPORT_BY_NAME AddressOfData;
	} ;
} IMAGE_THUNK_DATA,*PIMAGE_THUNK_DATA;

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD   Characteristics;            // 0 for terminating null import descriptor
        DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
    } DUMMYUNIONNAME;
    DWORD   TimeDateStamp;                  // 0 if not bound,
                                            // -1 if bound, and real date\time stamp
                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                                            // O.W. date/time stamp of DLL bound to (Old BIND)

    DWORD   ForwarderChain;                 // -1 if no forwarders
    DWORD   Name;
    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR;

typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Name;
    DWORD   Base;
    DWORD   NumberOfFunctions;
    DWORD   NumberOfNames;
    DWORD   AddressOfFunctions;     // RVA from base of image
    DWORD   AddressOfNames;         // RVA from base of image
    DWORD   AddressOfNameOrdinals;  // RVA from base of image
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

//typedef struct _OSVERSIONINFOA {
//	DWORD dwOSVersionInfoSize;
//	DWORD dwMajorVersion;
//	DWORD dwMinorVersion;
//	DWORD dwBuildNumber;
//	DWORD dwPlatformId;
//	CHAR szCSDVersion[128];
//} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;
//
//typedef struct _OSVERSIONINFOW {
//	DWORD dwOSVersionInfoSize;
//	DWORD dwMajorVersion;
//	DWORD dwMinorVersion;
//	DWORD dwBuildNumber;
//	DWORD dwPlatformId;
//	WCHAR szCSDVersion[128];
//} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW, RTL_OSVERSIONINFOW, *PRTL_OSVERSIONINFOW;

typedef struct {
  WORD  wFormatTag;
  WORD  nChannels;
  DWORD nSamplesPerSec;
  DWORD nAvgBytesPerSec;
  WORD  nBlockAlign;
  WORD  wBitsPerSample;
  WORD  cbSize;
} WAVEFORMATEX;

typedef struct wavehdr_tag {
  LPSTR              lpData;
  DWORD              dwBufferLength;
  DWORD              dwBytesRecorded;
  DWORD_PTR          dwUser;
  DWORD              dwFlags;
  DWORD              dwLoops;
  struct wavehdr_tag  *lpNext;
  DWORD_PTR          reserved;
} WAVEHDR, *LPWAVEHDR;

typedef struct {
	DWORD style;
	DWORD dwExtendedStyle;
	WORD cdit;
	short x;
	short y;
	short cx;
	short cy;
} DLGTEMPLATE,*LPDLGTEMPLATE;
typedef const DLGTEMPLATE *LPCDLGTEMPLATE;

typedef DWORD SECURITY_INFORMATION, *PSECURITY_INFORMATION;
typedef PVOID PSID;
typedef struct _ACL {
BYTE AclRevision;
BYTE Sbz1;
WORD AclSize;
WORD AceCount;
WORD Sbz2;
} ACL, *PACL;
typedef WORD SECURITY_DESCRIPTOR_CONTROL, *PSECURITY_DESCRIPTOR_CONTROL;
typedef struct _SECURITY_DESCRIPTOR {
BYTE Revision;
BYTE Sbz1;
SECURITY_DESCRIPTOR_CONTROL Control;
PSID Owner;
PSID Group;
PACL Sacl;
PACL Dacl;
} SECURITY_DESCRIPTOR, *PSECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;
typedef enum _SID_NAME_USE {
SidTypeUser=1,
SidTypeGroup,
SidTypeDomain,
SidTypeAlias,
SidTypeWellKnownGroup,
SidTypeDeletedAccount,
SidTypeInvalid,
SidTypeUnknown,
SidTypeComputer
} SID_NAME_USE,*PSID_NAME_USE;
typedef struct _SID_AND_ATTRIBUTES {
PSID Sid;
DWORD Attributes;
} SID_AND_ATTRIBUTES, *PSID_AND_ATTRIBUTES;
typedef struct _TOKEN_USER {
SID_AND_ATTRIBUTES User;
} TOKEN_USER, *PTOKEN_USER;
typedef enum _TOKEN_INFORMATION_CLASS {
TokenUser=1,
} TOKEN_INFORMATION_CLASS;
typedef enum _SE_OBJECT_TYPE {
  SE_UNKNOWN_OBJECT_TYPE,
  SE_FILE_OBJECT,
  SE_SERVICE,
  SE_PRINTER,
  SE_REGISTRY_KEY,
  SE_LMSHARE,
  SE_KERNEL_OBJECT,
  SE_WINDOW_OBJECT,
  SE_DS_OBJECT,
  SE_DS_OBJECT_ALL,
  SE_PROVIDER_DEFINED_OBJECT,
  SE_WMIGUID_OBJECT,
  SE_REGISTRY_WOW64_32KEY,
  SE_REGISTRY_WOW64_64KEY
} SE_OBJECT_TYPE;
typedef struct _BLENDFUNCTION {
	BYTE	BlendOp;
	BYTE	BlendFlags;
	BYTE	SourceConstantAlpha;
	BYTE	AlphaFormat;
}BLENDFUNCTION,*PBLENDFUNCTION;

#define _FILETIME

/*
proc
*/

#ifdef UNICODE
	typedef WIN32_FIND_DATAW WIN32_FIND_DATA;
	typedef PWIN32_FIND_DATAW PWIN32_FIND_DATA;
	typedef LPWIN32_FIND_DATAW LPWIN32_FIND_DATA;
	typedef struct _OSVERSIONINFOW {
		DWORD dwOSVersionInfoSize;
		DWORD dwMajorVersion;
		DWORD dwMinorVersion;
		DWORD dwBuildNumber;
		DWORD dwPlatformId;
		WCHAR szCSDVersion[128];
	} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW, RTL_OSVERSIONINFOW, *PRTL_OSVERSIONINFOW;
	typedef LPOSVERSIONINFOW LPOSVERSIONINFO;
#else
	typedef WIN32_FIND_DATAA WIN32_FIND_DATA;
	typedef PWIN32_FIND_DATAA PWIN32_FIND_DATA;
	typedef LPWIN32_FIND_DATAA LPWIN32_FIND_DATA;
	typedef struct _OSVERSIONINFOA {
		DWORD dwOSVersionInfoSize;
		DWORD dwMajorVersion;
		DWORD dwMinorVersion;
		DWORD dwBuildNumber;
		DWORD dwPlatformId;
		CHAR szCSDVersion[128];
	} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;
	typedef LPOSVERSIONINFOA LPOSVERSIONINFO;
#endif

int MessageBoxA(HWND,LPCSTR,LPCSTR,UINT);
#define MessageBox MessageBoxA
int MessageBoxW(HWND,LPCWSTR,LPCWSTR,UINT);

typedef struct {int dummy;} _Dummystruct;

//typedef int (*FARPROC)();
//typedef int (*FARPROC)(void);
//typedef int (*FARPROC)(_Dummystruct);
typedef int (*FARPROC)(struct {});

FARPROC GetProcAddress(HINSTANCE,const char*);
HINSTANCE LoadLibraryA(LPCSTR);
HMODULE GetModuleHandleA(char*);
HINSTANCE  LoadLibraryExW(LPCWSTR,HANDLE,DWORD);
HINSTANCE  LoadLibraryExA(LPCSTR,HANDLE,DWORD);

BOOL  SetEvent(HANDLE);
DWORD  WaitForMultipleObjects(DWORD,CONST HANDLE *,BOOL,DWORD);
LPVOID VirtualAlloc(LPVOID,DWORD,DWORD,DWORD);
BOOL VirtualFree(LPVOID,DWORD,DWORD);
BOOL VirtualProtect(LPVOID,DWORD,DWORD,PDWORD);
DWORD VirtualQuery(LPCVOID,MEMORY_BASIC_INFORMATION*,DWORD);
HLOCAL LocalFree(HLOCAL);
LPWSTR GetCommandLineW(VOID);
LPSTR GetCommandLineA(VOID);
LPWSTR* CommandLineToArgvW(LPCWSTR,int*);
DWORD GetModuleFileNameA(HINSTANCE,LPSTR,DWORD);
DWORD GetModuleFileNameW(HINSTANCE,LPWSTR,DWORD);
DWORD GetLastError(VOID);

DWORD FormatMessageA(DWORD,LPCVOID,DWORD,DWORD,LPSTR,DWORD,va_list *);

LONG InterlockedCompareExchange(LONG volatile*, LONG, LONG);
//LONG64 InterlockedCompareExchange64(LONG64 volatile*, LONG64, LONG64);

VOID InitializeCriticalSection(LPCRITICAL_SECTION);
VOID DeleteCriticalSection(LPCRITICAL_SECTION);
VOID EnterCriticalSection(LPCRITICAL_SECTION);
VOID LeaveCriticalSection(LPCRITICAL_SECTION);
DWORD GetCurrentThreadId(VOID);
BOOL CloseHandle(HANDLE);
BOOL FreeLibrary(HINSTANCE);
BOOL AreFileApisANSI(VOID);
VOID OutputDebugStringA(LPCSTR);
HANDLE CreateFileA(LPCSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE);
HANDLE CreateFileW(LPCWSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE);
HANDLE CreateFileMappingW(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,DWORD,DWORD,LPCWSTR);
HANDLE CreateFileMappingA(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,DWORD,DWORD,LPCSTR);
HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES,BOOL,LPCWSTR);
HANDLE CreateMutexA(LPSECURITY_ATTRIBUTES,BOOL,LPCSTR);
BOOL DeleteFileA(LPCSTR);
BOOL DeleteFileW(LPCWSTR);
BOOL FlushFileBuffers(HANDLE);
DWORD FormatMessageW(DWORD,LPCVOID,DWORD,DWORD,LPWSTR,DWORD,va_list *);
//DWORD FormatMessageA(DWORD,LPCVOID,DWORD,DWORD,LPSTR,DWORD,va_list *);
DWORD GetCurrentProcessId(VOID);
BOOL GetDiskFreeSpaceW(LPCWSTR,LPDWORD,LPDWORD,LPDWORD,LPDWORD);
BOOL GetDiskFreeSpaceA(LPCSTR,LPDWORD,LPDWORD,LPDWORD,LPDWORD);
DWORD GetFileAttributesW(LPCWSTR);
DWORD GetFileAttributesA(LPCSTR);
BOOL GetFileAttributesExA(LPCSTR,GET_FILEEX_INFO_LEVELS,LPVOID);
BOOL GetFileAttributesExW(LPCWSTR,GET_FILEEX_INFO_LEVELS,LPVOID);
DWORD GetFileSize(HANDLE,LPDWORD);
BOOL SetConsoleMode(HANDLE,DWORD);
BOOL GetConsoleMode(HANDLE,LPDWORD);
HANDLE GetStdHandle(DWORD);
BOOL PeekConsoleInputW(HANDLE,PINPUT_RECORD,DWORD,LPDWORD);
BOOL ReadConsoleInputW(HANDLE,PINPUT_RECORD,DWORD,LPDWORD);
BOOL WriteConsoleInputW(HANDLE,CONST INPUT_RECORD *,DWORD,LPDWORD);
BOOL ReadConsoleOutputW(HANDLE,PCHAR_INFO,COORD,COORD,PSMALL_RECT);
BOOL WriteConsoleOutputW(HANDLE,CONST CHAR_INFO *,COORD,COORD,PSMALL_RECT);
BOOL ReadConsoleOutputCharacterW(HANDLE,LPWSTR,DWORD,COORD,LPDWORD);
BOOL WriteConsoleOutputCharacterW(HANDLE,LPCWSTR,DWORD,COORD,LPDWORD);
BOOL FillConsoleOutputCharacterW(HANDLE,WCHAR,DWORD,COORD,LPDWORD);
BOOL ScrollConsoleScreenBufferW(HANDLE,CONST SMALL_RECT *,CONST SMALL_RECT *,COORD,CONST CHAR_INFO *);
BOOL ScrollConsoleScreenBufferA(HANDLE,CONST SMALL_RECT *,CONST SMALL_RECT *,COORD,CONST CHAR_INFO *);
DWORD GetConsoleTitleW(LPWSTR,DWORD);
BOOL SetConsoleTitleW(LPCWSTR);
BOOL ReadConsoleW(HANDLE,LPVOID,DWORD,LPDWORD,LPVOID);
BOOL WriteConsoleW(HANDLE,CONST VOID *,DWORD,LPDWORD,LPVOID);
BOOL ReadConsoleOutputAttribute(HANDLE,LPWORD,DWORD,COORD,LPDWORD);
BOOL WriteConsoleOutputAttribute(HANDLE,CONST WORD *,DWORD,COORD,LPDWORD);
BOOL FillConsoleOutputAttribute(HANDLE,WORD,DWORD,COORD,LPDWORD);
BOOL GetConsoleMode(HANDLE,LPDWORD);
BOOL GetNumberOfConsoleInputEvents(HANDLE,LPDWORD);
BOOL GetConsoleScreenBufferInfo(HANDLE,PCONSOLE_SCREEN_BUFFER_INFO);
COORD GetLargestConsoleWindowSize(HANDLE);
BOOL GetConsoleCursorInfo(HANDLE,PCONSOLE_CURSOR_INFO);
BOOL GetNumberOfConsoleMouseButtons(LPDWORD);
BOOL SetConsoleMode(HANDLE,DWORD);
BOOL SetConsoleActiveScreenBuffer(HANDLE);
BOOL FlushConsoleInputBuffer(HANDLE);
BOOL SetConsoleScreenBufferSize(HANDLE,COORD);
BOOL SetConsoleCursorPosition(HANDLE,COORD);
BOOL SetConsoleCursorInfo(HANDLE,CONST CONSOLE_CURSOR_INFO *);
BOOL SetConsoleWindowInfo(HANDLE,BOOL,CONST SMALL_RECT *);
BOOL SetConsoleTextAttribute(HANDLE,WORD);
BOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE,BOOL);
BOOL GenerateConsoleCtrlEvent(DWORD,DWORD);
BOOL AllocConsole(VOID);
BOOL FreeConsole(VOID);
HANDLE CreateConsoleScreenBuffer(DWORD,DWORD,CONST SECURITY_ATTRIBUTES *,DWORD,LPVOID);
DWORD GetFileType(HANDLE);
DWORD WaitForSingleObject(HANDLE,DWORD);
BOOL PeekNamedPipe(HANDLE,LPVOID,DWORD,LPDWORD,LPDWORD,LPDWORD);
BOOL CreatePipe(PHANDLE,PHANDLE,LPSECURITY_ATTRIBUTES,DWORD);
BOOL GetMessageA(LPMSG,HWND,UINT,UINT);
SHORT GetKeyState(int);
BOOL TranslateMessage(CONST MSG *);
BOOL PeekMessageA(LPMSG,HWND,UINT,UINT,UINT);
LONG DispatchMessageA(CONST MSG *);
BOOL IsWindow(HWND);
BOOL IsMenu(HMENU);
BOOL IsChild(HWND,HWND);
BOOL DestroyWindow(HWND);
BOOL ShowWindow(HWND,int);
SHORT GetKeyState(int);
SHORT GetAsyncKeyState(int);
BOOL GetKeyboardState(PBYTE);
BOOL SetKeyboardState(LPBYTE);
int GetKeyboardType(int);
BOOL GetExitCodeProcess(HANDLE,LPDWORD);
BOOL TerminateProcess(HANDLE,UINT);
BOOL SetHandleInformation(HANDLE,DWORD,DWORD);
HANDLE FindFirstFileA(LPCSTR,LPWIN32_FIND_DATA);
HPEN CreatePen(int,int,COLORREF);
HBRUSH CreateSolidBrush(COLORREF);
HGDIOBJ SelectObject(HDC,HGDIOBJ);
VOID PostQuitMessage(int);

BOOL PlaySoundA(LPCSTR,HMODULE,DWORD);
HICON LoadIconW(HINSTANCE,LPCWSTR);
HICON LoadIconA(HINSTANCE,LPCSTR);
HCURSOR LoadCursorW(HINSTANCE,LPCWSTR);
HCURSOR LoadCursorA(HINSTANCE,LPCSTR);
HGDIOBJ GetStockObject(int);
ATOM RegisterClassW(CONST WNDCLASS *);
ATOM RegisterClassA(CONST WNDCLASS *);
BOOL UpdateWindow(HWND);
HDC BeginPaint( HWND,LPPAINTSTRUCT);
BOOL EndPaint(HWND,CONST PAINTSTRUCT *);
BOOL GetClientRect(HWND,LPRECT);
int DrawTextW(HDC,LPCWSTR,int,LPRECT,UINT);
int DrawTextA(HDC,LPCSTR,int,LPRECT,UINT);
LRESULT DefWindowProcW(HWND,UINT,WPARAM,LPARAM);
LRESULT DefWindowProcA(HWND,UINT,WPARAM,LPARAM);
BOOL FillConsoleOutputCharacterA(HANDLE,WCHAR,DWORD,COORD,LPDWORD);
BOOL FillConsoleOutputCharacterW(HANDLE,WCHAR,DWORD,COORD,LPDWORD);
VOID Sleep(DWORD);
HANDLE CreateEventW(LPSECURITY_ATTRIBUTES,BOOL,BOOL,LPCWSTR);
HANDLE CreateEventA(LPSECURITY_ATTRIBUTES,BOOL,BOOL,LPCSTR);
HANDLE CreateThread(LPSECURITY_ATTRIBUTES,DWORD,LPTHREAD_START_ROUTINE,LPVOID,DWORD,LPDWORD);
LPVOID MapViewOfFile(HANDLE,DWORD,DWORD,DWORD,DWORD);
BOOL ReadConsoleOutputCharacterW(HANDLE,LPWSTR,DWORD,COORD,LPDWORD);
BOOL ReadConsoleOutputCharacterA(HANDLE,LPSTR,DWORD,COORD,LPDWORD);
BOOL WriteConsoleInputW(HANDLE,CONST INPUT_RECORD *,DWORD,LPDWORD);
BOOL WriteConsoleInputA(HANDLE,CONST INPUT_RECORD *,DWORD,LPDWORD);
UINT GetSystemDirectoryW(LPWSTR,UINT);
UINT GetSystemDirectoryA(LPSTR,UINT);
DWORD SearchPathW(LPCWSTR,LPCWSTR,LPCWSTR,DWORD,LPWSTR,LPWSTR *);
DWORD SearchPathA(LPCSTR,LPCSTR,LPCSTR,DWORD,LPSTR,LPSTR *);
DWORD GetTickCount(VOID);
ATOM RegisterClassExW(CONST WNDCLASSEX *);
ATOM RegisterClassExA(CONST WNDCLASSEX *);
HWND CreateWindowExW(DWORD,LPCWSTR,LPCWSTR,DWORD,int,int,int,int,HWND,HMENU,HINSTANCE,LPVOID);
HWND CreateWindowExA(DWORD,LPCSTR,LPCSTR,DWORD,int,int,int,int,HWND,HMENU,HINSTANCE,LPVOID);
COLORREF SetPixel(HDC,int,int,COLORREF);
COLORREF GetPixel(HDC,int,int);
BOOL LineTo(HDC,int,int);
VOID GetSystemTimeAsFileTime(LPFILETIME);
BOOL MoveWindow(HWND,int,int,int,int,BOOL);
BOOL GetWindowRect(HWND,LPRECT);
BOOL ScreenToClient(HWND,LPPOINT);
HWND GetParent(HWND);
HWND SetFocus(HWND);
BOOL InvalidateRect(HWND,CONST RECT *,BOOL);
BOOL DeleteObject(HGDIOBJ);
LONG GetWindowLongA(HWND,int);
LONG GetWindowLongW(HWND,int);
LONG SetWindowLongA(HWND,int,LONG);
LONG SetWindowLongW(HWND,int,LONG);
HDC CreateCompatibleDC(HDC);
BOOL BitBlt(HDC,int,int,int,int,HDC,int,int,DWORD);
BOOL DeleteDC(HDC);
LRESULT SendMessageW(HWND,UINT,WPARAM,LPARAM);
LRESULT SendMessageA(HWND,UINT,WPARAM,LPARAM);
LRESULT SendMessageTimeoutW(HWND,UINT,WPARAM,LPARAM,UINT,UINT,LPDWORD);
LRESULT SendMessageTimeoutA(HWND,UINT,WPARAM,LPARAM,UINT,UINT,LPDWORD);
BOOL ClientToScreen(HWND,LPPOINT);
HDC GetDC(HWND);
HBITMAP CreateDIBSection(HDC,CONST BITMAPINFO *,UINT,VOID **,HANDLE,DWORD);
BOOL OpenClipboard(HWND);
BOOL CloseClipboard(VOID);
BOOL EmptyClipboard(VOID);
BOOL IsClipboardFormatAvailable(UINT);
HANDLE SetClipboardData(UINT,HANDLE);
HANDLE GetClipboardData(UINT);
HGLOBAL GlobalAlloc(UINT,DWORD);
LPVOID GlobalLock(HGLOBAL);
LPVOID GlobalUnlock(HGLOBAL);
BOOL Rectangle(HDC,int,int,int,int);
HWND GetDesktopWindow(VOID);
BOOL AdjustWindowRect(LPRECT,DWORD,BOOL);
BOOL MoveToEx(HDC,int,int,LPPOINT);
HWND SetCapture(HWND hWnd);
BOOL ReleaseCapture(VOID);
int MapWindowPoints(HWND,HWND,LPPOINT,UINT);
BOOL GetCursorPos(LPPOINT);
DWORD GetLogicalDriveStringsW(DWORD,LPWSTR);
DWORD GetLogicalDriveStringsA(DWORD,LPSTR);
HANDLE FindFirstFileW(LPCWSTR,LPWIN32_FIND_DATAW);
HANDLE FindFirstFileA(LPCSTR,LPWIN32_FIND_DATA);
BOOL FindNextFileW(HANDLE,LPWIN32_FIND_DATAW);
BOOL FindNextFileA(HANDLE,LPWIN32_FIND_DATAA);
BOOL FindClose(HANDLE);
BOOL QueryPerformanceCounter(LARGE_INTEGER *);
BOOL QueryPerformanceFrequency(LARGE_INTEGER *);
UINT SetTimer(HWND,UINT,UINT,TIMERPROC);
BOOL KillTimer(HWND,UINT);
HBITMAP CreateCompatibleBitmap(HDC,int,int);
HBITMAP CreateDiscardableBitmap(HDC,int,int);
HDC CreateCompatibleDC(HDC);
int FillRect(HDC,CONST RECT *,HBRUSH);
LONG RegOpenKeyExW(HKEY,LPCWSTR,DWORD,REGSAM,PHKEY);
LONG RegOpenKeyExA(HKEY,LPCSTR,DWORD,REGSAM,PHKEY);
LONG RegQueryValueExW(HKEY,LPCWSTR,LPDWORD,LPDWORD,LPBYTE,LPDWORD);
LONG RegQueryValueExA (HKEY,LPCSTR,LPDWORD,LPDWORD,LPBYTE,LPDWORD);
LONG RegSetValueExW(HKEY,LPCWSTR,DWORD,DWORD,BYTE*,DWORD);
LONG RegSetValueExA(HKEY,LPCSTR,DWORD,DWORD,BYTE*,DWORD);
LONG RegCloseKey (HKEY);
BOOL SystemTimeToFileTime(CONST SYSTEMTIME *,LPFILETIME);
BOOL FileTimeToLocalFileTime(CONST FILETIME *,LPFILETIME);
BOOL LocalFileTimeToFileTime(CONST FILETIME *,LPFILETIME);
BOOL FileTimeToSystemTime(CONST FILETIME *,LPSYSTEMTIME);
LONG CompareFileTime(CONST FILETIME *,CONST FILETIME *);
DWORD GetFullPathNameW(LPCWSTR,DWORD,LPWSTR,LPWSTR *);
DWORD GetFullPathNameA(LPCSTR,DWORD,LPSTR,LPSTR *);
VOID GetSystemInfo(LPSYSTEM_INFO);
VOID GetSystemTime(LPSYSTEMTIME);
DWORD GetTempPathW(DWORD,LPWSTR);
DWORD GetTempPathA(DWORD,LPSTR);
BOOL GetVersionExW(LPOSVERSIONINFO);
BOOL GetVersionExA(LPOSVERSIONINFO);
HANDLE HeapCreate(DWORD,DWORD,DWORD);
BOOL HeapDestroy(HANDLE);
LPVOID HeapAlloc(HANDLE,DWORD,DWORD);
LPVOID HeapReAlloc(HANDLE,DWORD,LPVOID,DWORD);
BOOL HeapFree(HANDLE,DWORD,LPVOID);
DWORD HeapSize(HANDLE,DWORD,LPCVOID);
BOOL HeapValidate(HANDLE,DWORD,LPCVOID);
UINT HeapCompact(HANDLE,DWORD);
HINSTANCE LoadLibraryW(LPCWSTR);
HINSTANCE LoadLibraryExW(LPCWSTR,HANDLE,DWORD);
HINSTANCE LoadLibraryA(LPCSTR);
HINSTANCE LoadLibraryExA(LPCSTR,HANDLE,DWORD);
BOOL LockFile( HANDLE,DWORD,DWORD,DWORD,DWORD);
BOOL UnlockFile(HANDLE,DWORD,DWORD,DWORD,DWORD);
BOOL LockFileEx(HANDLE,DWORD,DWORD,DWORD,DWORD,LPOVERLAPPED);
BOOL UnlockFileEx(HANDLE,DWORD,DWORD,DWORD,LPOVERLAPPED);
int MultiByteToWideChar(UINT,DWORD,LPCSTR,int,LPWSTR,int);
int WideCharToMultiByte(UINT,DWORD,LPCWSTR,int,LPSTR,int,LPCSTR,LPBOOL);
BOOL WriteFile(HANDLE,LPCVOID,DWORD,LPDWORD,LPOVERLAPPED);
BOOL ReadFile(HANDLE,LPVOID,DWORD,LPDWORD,LPOVERLAPPED);
BOOL SetEndOfFile(HANDLE);
DWORD SetFilePointer(HANDLE,LONG,PLONG,DWORD);
DWORD WaitForSingleObject(HANDLE,DWORD);
DWORD WaitForMultipleObjects(DWORD,CONST HANDLE *,BOOL,DWORD);
DWORD WaitForSingleObjectEx(HANDLE,DWORD,BOOL);
DWORD WaitForMultipleObjectsEx(DWORD,CONST HANDLE *,BOOL,DWORD,BOOL);
VOID OutputDebugStringW(LPCWSTR);
VOID OutputDebugStringA(LPCSTR);
HANDLE GetProcessHeap(VOID);
DWORD WINAPI GetProcessIdOfThread(HANDLE);
DWORD WINAPI GetProcessId(HANDLE);
DWORD WINAPI GetCurrentProcessorNumber(void);
BOOL WINAPI GetProcessHandleCount(HANDLE,PDWORD);
BOOL WINAPI GetProcessIoCounters(HANDLE,PIO_COUNTERS);
BOOL WINAPI GetProcessWorkingSetSize(HANDLE,PSIZE_T,PSIZE_T);
BOOL WINAPI GetProcessWorkingSetSizeEx(HANDLE,PSIZE_T,PSIZE_T,PDWORD);
BOOL WINAPI SetProcessWorkingSetSize(HANDLE,SIZE_T,SIZE_T);
BOOL WINAPI SetProcessWorkingSetSizeEx(HANDLE,SIZE_T,SIZE_T,DWORD);
DWORD GetProcessHeaps(DWORD,PHANDLE);
DWORD GetProcessVersion(DWORD);
LPVOID MapViewOfFile(HANDLE,DWORD,DWORD,DWORD,DWORD);
BOOL FlushViewOfFile(LPCVOID,DWORD);
BOOL UnmapViewOfFile(LPCVOID);
HANDLE GetCurrentProcess(VOID);
BOOL SetFileTime(HANDLE,CONST FILETIME *,CONST FILETIME *,CONST FILETIME *);
DWORD GetEnvironmentVariableW(LPCWSTR,LPWSTR,DWORD);
BOOL SetEnvironmentVariableW(LPCWSTR,LPCWSTR);
DWORD GetEnvironmentVariableA(LPCSTR,LPSTR,DWORD);
BOOL SetEnvironmentVariableA(LPCSTR,LPCSTR);
BOOL SetCurrentDirectoryW(LPCWSTR);
DWORD GetCurrentDirectoryW(DWORD,LPWSTR);
BOOL SetCurrentDirectoryA(LPCSTR);
DWORD GetCurrentDirectoryA(DWORD,LPSTR);
VOID DebugBreak(VOID);
HMENU GetMenu(HWND);
BOOL AdjustWindowRectEx(LPRECT,DWORD,BOOL,DWORD);
BOOL SetWindowPos(HWND,HWND,int,int,int,int,UINT);
HBRUSH GetSysColorBrush(int);
BOOL GetUpdateRect(HWND,LPRECT,BOOL);
BOOL AngleArc(HDC,int,int,DWORD,FLOAT,FLOAT);
BOOL BeginPath(HDC);
BOOL CloseFigure(HDC);
BOOL EndPath(HDC);
BOOL FillPath(HDC);
BOOL FlattenPath(HDC);
BOOL StrokeAndFillPath(HDC);
BOOL StrokePath(HDC);
BOOL WidenPath(HDC);
BOOL Ellipse(HDC,int,int,int,int);
int ReleaseDC(HWND,HDC);
DWORD GetWindowThreadProcessId(HWND,LPDWORD);
int GetSystemMetrics(int);
HFONT CreateFontW(int,int,int,int,int,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPCWSTR);
HFONT CreateFontA(int,int,int,int,int,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPCSTR);
BOOL Polygon(HDC,CONST POINT *,int);
COLORREF SetTextColor(HDC,COLORREF);
COLORREF SetBkColor(HDC,COLORREF);
UINT SetTextAlign(HDC,UINT);
BOOL TextOutW(HDC,int,int,LPCWSTR,int);
BOOL TextOutA(HDC,int,int,LPCSTR,int);
DWORD GetLogicalDrives(VOID);
BOOL GetFileInformationByHandle(HANDLE,LPBY_HANDLE_FILE_INFORMATION);
HANDLE CreateFileMappingW(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,DWORD,DWORD,LPCWSTR);
HANDLE CreateFileMappingA(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,DWORD,DWORD,LPCSTR);
HWND GetTopWindow(HWND);
HWND GetActiveWindow(VOID);
BOOL SetWindowTextA(HWND,LPCSTR);
MMRESULT waveOutUnprepareHeader(HWAVEOUT, LPWAVEHDR, UINT);
MMRESULT waveOutPrepareHeader(HWAVEOUT, LPWAVEHDR, UINT);
MMRESULT waveOutWrite(HWAVEOUT, LPWAVEHDR, UINT);
MMRESULT waveOutOpen(void*, UINT, void*, DWORD_PTR, DWORD_PTR, DWORD);
HWND WINAPI GetConsoleWindow(void);
BOOL EndDeferWindowPos(HDWP hWinPosInfo);
BOOL SetCursorPos(int,int);
int GetDeviceCaps(HDC,int);
BOOL StretchBlt(HDC,int,int,int,int,HDC,int,int,int,int,DWORD);
BOOL WINAPI LookupAccountNameW(LPCWSTR,LPCWSTR,PSID,PDWORD,LPWSTR,PDWORD,PSID_NAME_USE);
BOOL WINAPI LookupAccountSidW(LPCWSTR,PSID,LPWSTR,PDWORD,LPWSTR,PDWORD,PSID_NAME_USE);
HANDLE WINAPI GetCurrentProcess(void);
HANDLE WINAPI GetCurrentThread(void);
BOOL WINAPI OpenProcessToken(HANDLE,DWORD,PHANDLE);
BOOL WINAPI OpenThreadToken(HANDLE,DWORD,BOOL,PHANDLE);
BOOL WINAPI GetTokenInformation(HANDLE,TOKEN_INFORMATION_CLASS,PVOID,DWORD,PDWORD);
HGLOBAL WINAPI GlobalFree(HGLOBAL);
HLOCAL WINAPI LocalAlloc(UINT,SIZE_T);
HBITMAP CreateBitmap(int,int,UINT,UINT,CONST VOID *);
DWORD SetNamedSecurityInfoW(
  LPWSTR               pObjectName,
  SE_OBJECT_TYPE       ObjectType,
  SECURITY_INFORMATION SecurityInfo,
  PSID                 psidOwner,
  PSID                 psidGroup,
  PACL                 pDacl,
  PACL                 pSacl
);

LPWSTR * CommandLineToArgvW(
  LPCWSTR lpCmdLine,
  int     *pNumArgs
);
int SetDIBits(HDC,HBITMAP,UINT,UINT,CONST VOID *,CONST BITMAPINFO *,UINT);
int GetObjectW(HGDIOBJ,int,LPVOID);
int GetObjectA(HGDIOBJ,int,LPVOID);
int SelectClipRgn(HDC,HRGN);
int IntersectClipRect(HDC,int,int,int,int);
COLORREF WINAPI SetDCPenColor(HDC,COLORREF);
BOOL RoundRect(HDC,int,int,int,int,int,int);
BOOL ExtTextOutW(HDC,int,int,UINT,CONST RECT *,LPCWSTR,UINT,CONST INT *);
COLORREF WINAPI SetDCBrushColor(HDC,COLORREF);
COLORREF WINAPI SetDCPenColor(HDC,COLORREF);

//!=================

/*
proc
*/
#define GetWindowLongPtrW GetWindowLongW
#define GetWindowLongPtrA GetWindowLongA
#define SetWindowLongPtrW SetWindowLongW
#define SetWindowLongPtrA SetWindowLongA

#ifdef UNICODE
	#define GetModuleHandle GetModuleHandleW
	#define LoadLibrary LoadLibraryW
	#define LoadLibraryEx LoadLibraryExW
	#define OutputDebugString OutputDebugStringW
	#define GetMessage GetMessageW
	#define PeekMessage PeekMessageW
	#define DispatchMessage DispatchMessageW
	#define PlaySound PlaySoundW
	#define TEXT(quote) L##quote
	#define LoadIcon LoadIconW
	typedef unsigned short *LPTSTR;
	typedef unsigned short TCHAR;
	#define LoadCursor LoadCursorW
	#define RegisterClass RegisterClassW
	#define CreateWindowEx CreateWindowExW
	#define CreateWindowW(Class,Name,Style,x,y,W,H,Parent,Menu,Inst,Param) CreateWindowExW(0,Class,Name,Style,x,y,W,H,Parent,Menu,Inst,Param)
	#define CreateWindow CreateWindowW
	#define DrawText DrawTextW
	#define DefWindowProc DefWindowProcW
	#define FillConsoleOutputCharacter FillConsoleOutputCharacterW
	#define CreateEvent CreateEventW
	#define ReadConsoleOutputCharacter ReadConsoleOutputCharacterW
	#define WriteConsoleInput WriteConsoleInputW
	#define GetSystemDirectory GetSystemDirectoryW
	#define SearchPath SearchPathW
	#define RegisterClassEx RegisterClassExA
	#define GetWindowLong GetWindowLongW
	#define GetWindowLongPtr GetWindowLongPtrW
	#define SetWindowLong SetWindowLongW
	#define SetWindowLongPtr SetWindowLongPtrW
	#define SendMessage SendMessageW
	#define SendMessageTimeout SendMessageTimeoutW
	#define GetLogicalDriveStrings GetLogicalDriveStringsW
	#define FindFirstFile FindFirstFileW
	#define FindNextFile FindNextFileW
	#define GetCommandLine GetCommandLineW
	#define ScrollConsoleScreenBuffer ScrollConsoleScreenBufferW
	#define CreateProcess CreateProcessW
	#define LPSTARTUPINFO LPSTARTUPINFOW
	#define CreateFile CreateFileW
	#define RegOpenKeyEx RegOpenKeyExW
	#define RegQueryValueEx RegQueryValueExW
	#define RegSetValueEx RegSetValueExW
	#define GetFullPathname GetFullPathNameW
	#define GetTempPath GetTempPathW
	#define GetEnvironmentVariable GetEnvironmentVariableW
	#define SetEnvironmentVariable SetEnvironmentVariableW
	#define GetCurrentDirectory GetCurrentDirectoryW
	#define SetCurrentDirectory SetCurrentDirectoryW
	#define CreateFont CreateFontW
	#define TextOut TextOutW
	#define CreateFileMapping CreateFileMappingW
	#define OSVERSIONINFO OSVERSIONINFOW
	#define STARTUPINFO STARTUPINFOW
	#define GetObject GetObjectW
#else
	#define GetModuleHandle GetModuleHandleA
	#define LoadLibrary LoadLibraryA

	#define LoadLibraryEx LoadLibraryExA
	#define OutputDebugString OutputDebugStringA
	#define GetMessage GetMessageA
	#define PeekMessage PeekMessageA
	#define DispatchMessage DispatchMessageA
	#define PlaySound PlaySoundA
	#define TEXT(quote) quote
	#define LoadIcon LoadIconA
	typedef unsigned char *LPTSTR;
	typedef char TCHAR;
	#define LoadCursor LoadCursorA
	#define RegisterClass RegisterClassA
	#define CreateWindowEx CreateWindowExA
	#define CreateWindowA(C,WN,S,x,y,W,H,hW,hM,hI,l) CreateWindowExA(0,C,WN,S,x,y,W,H,hW,hM,hI,l)
	#define CreateWindow CreateWindowA
	#define DrawText DrawTextA
	#define DefWindowProc DefWindowProcA
	#define FillConsoleOutputCharacter FillConsoleOutputCharacterA
	#define CreateEvent CreateEventA
	#define ReadConsoleOutputCharacter ReadConsoleOutputCharacterA
	#define WriteConsoleInput WriteConsoleInputA
	#define GetSystemDirectory GetSystemDirectoryA
	#define SearchPath SearchPathA
	#define RegisterClassEx RegisterClassExA
	#define GetWindowLong GetWindowLongA
	#define GetWindowLongPtr GetWindowLongPtrA
	#define SetWindowLong SetWindowLongA
	#define SetWindowLongPtr SetWindowLongPtrA
	#define SendMessage SendMessageA
	#define SendMessageTimeout SendMessageTimeoutA
	#define GetLogicalDriveStrings GetLogicalDriveStringsA
	#define FindFirstFile FindFirstFileA
	#define FindNextFile FindNextFileA
	#define GetCommandLine GetCommandLineA
	#define ScrollConsoleScreenBuffer ScrollConsoleScreenBufferA
	#define CreateProcess CreateProcessA
	#define LPSTARTUPINFO LPSTARTUPINFOA
	#define CreateFile CreateFileA
	#define RegOpenKeyEx RegOpenKeyExA
	#define RegQueryValueEx RegQueryValueExA
	#define RegSetValueEx RegSetValueExA
	#define GetFullPathname GetFullPathNameA
	#define GetVersionEx GetVersionExA
	#define GetEnvironmentVariable GetEnvironmentVariableA
	#define SetEnvironmentVariable SetEnvironmentVariableA
	#define GetCurrentDirectory GetCurrentDirectoryA
	#define SetCurrentDirectory SetCurrentDirectoryA
	#define CreateFont CreateFontA
	#define TextOut TextOutA
	#define CreateFileMapping CreateFileMappingA
	#define OSVERSIONINFO OSVERSIONINFOA
	#define STARTUPINFO STARTUPINFOA
	#define SetWindowText SetWindowTextA
	#define GetObject GetObjectA
#endif // windows.h

BOOL CreateProcessW(LPCWSTR,LPWSTR,LPSECURITY_ATTRIBUTES,LPSECURITY_ATTRIBUTES,BOOL,DWORD,LPVOID,LPCWSTR,LPSTARTUPINFOW,LPPROCESS_INFORMATION);
BOOL CreateProcessA(LPCSTR,LPSTR,LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES,BOOL,DWORD,LPVOID,LPCSTR,LPSTARTUPINFOA,LPPROCESS_INFORMATION);

#endif
=== stdarg.h 0 0 85/108 ===
/* Header stdarg.h */

#ifndef $STDARG
 #define $STDARG

//coded for x64 target as used by mcc (with first four params also on stack)

 typedef char *	va_list;

 #if __MCCI__
  #define va_start(ap,v) ap=((va_list)&v-8)
  #define va_arg(ap,t) *(t*)((ap-=8)+8)
  #define va_copy(dest,src) (dest=src)
  #define va_end(ap)	( ap = (va_list)0 )

 #else
  #define va_start(ap,v) ap=((va_list)&v+8)
  #define va_arg(ap,t) *(t*)((ap+=8)-8)
  #define va_copy(dest,src) (dest=src)
  #define va_end(ap)	( ap = (va_list)0 )

 #endif

#endif
=== stdbool.h 0 0 86/108 ===
/* Header stdbool.h */

#define bool unsigned char
#define true 1
#define false 0


=== stddef.h 0 0 87/108 ===
/* Header stddef.h */

#ifndef $stddef
#define $stddef

typedef signed long long int ssize_t;
typedef unsigned long long int size_t;

#define _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
//typedef signed short wchar_t;

#define NULL ((void*)0)

#define offsetof(a,b) (size_t) &( ((a*)0) -> b)

typedef long long int ptrdiff_t;

#endif // stddef
=== stdint.h 0 0 88/108 ===
/* Header stdint.h */

#ifndef $stdint
#define $stdint

typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long long int int64_t;

typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long int uint64_t;

typedef long long int intptr_t;
typedef unsigned long long int uintptr_t;
typedef long long intmax_t;
typedef unsigned long long uintmax_t;

typedef char int_least8_t;
typedef unsigned char uint_least8_t;
typedef short int_least16_t;
typedef unsigned short uint_least16_t;
typedef int int_least32_t;
typedef unsigned int uint_least32_t;
typedef long long int_least64_t;
typedef unsigned long long uint_least64_t;

#define INTMAX_C(a) (a##LL)
#define UINTMAX_C(a) (a##ULL)

typedef char int_fast8_t;
typedef unsigned char uint_fast8_t;
typedef short int_fast16_t;
typedef unsigned short uint_fast16_t;
typedef int int_fast32_t;
typedef unsigned int uint_fast32_t;
typedef long long int_fast64_t;
typedef unsigned long long uint_fast64_t;


#define INT8_MIN -128
#define INT8_MAX 127
#define INT16_MIN -32768
#define INT16_MAX 32767
#define INT32_MIN 0x80000000
#define INT32_MAX 0x7FFFFFFF
#define INT64_MIN 0x8000000000000000
#define INT64_MAX 0x7FFFFFFFFFFFFFFF

#define UINT8_MAX 255
#define UINT16_MAX 65535
#define UINT32_MAX 0xFFFFFFFF
#define UINT64_MAX 0xFFFFFFFFFFFFFFFF

#define INTPTR_MIN 0x8000000000000000
#define INTPTR_MAX 0x7FFFFFFFFFFFFFFF
#define UINTPTR_MAX 0xFFFFFFFFFFFFFFFF

#define UINT64_MAX 0xFFFFFFFFFFFFFFFF
#define SIZE_MAX 0xFFFFFFFFFFFFFFFF

#define PTRDIFF_MIN 0x8000000000000000
#define PTRDIFF_MAX 0x7FFFFFFFFFFFFFFF

#define WCHAR_MIN 0
#define WCHAR_MAX 65535

#define WINT_MIN 0
#define WINT_MAX 65535

#define UINT64_C(x) (x##ull)

#endif
=== stdio.h 0 0 89/108 ===
/* Header stdio.h */

#ifndef $stdio
#define $stdio 1

#define __attribute__(x)

#ifndef $valist
	typedef char* va_list;
	#define $valist
#endif

#include <stddef.h>

typedef long long int fpos_t;

#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2

#define	STDIN_FILENO	0
#define	STDOUT_FILENO	1
#define	STDERR_FILENO	2

#define EOF (-1)
#define FILENAME_MAX 260

#define L_tmpnam 10

typedef struct {
	char *_ptr;
	int   _cnt;
	char *_base;
	int   _flag;
	int   _file;
	int   _charbuf;
	int   _bufsiz;
	char *_tmpfname;
} FILE;

extern char* __iob_func(void);

#define stdin ((FILE*)(__iob_func()))
#define stdout ((FILE*)(__iob_func()+sizeof(FILE)))
#define stderr ((FILE*)(__iob_func()+sizeof(FILE)*2))

#define _IOREAD 0x0001
#define _IOWRT 0x0002

#define _IOFBF 0x0000
#define _IOLBF 0x0040
#define _IONBF 0x0004

#define _IOMYBUF 0x0008
#define _IOEOF 0x0010
#define _IOERR 0x0020
#define _IOSTRG 0x0040
#define _IORW 0x0080

#define BUFSIZ 512

FILE* fopen(const char*, const char*);
int fclose(FILE*);
long ftell(FILE*);
//long long int _ftelli64(FILE*);
int fseek(FILE*,long,int);
int _fseeki64(FILE*,long long int,int);

size_t fread(void*, size_t, size_t, FILE*);
size_t fwrite(const void*, size_t, size_t, FILE*);
int remove(const char*);
int rename(const char *,const char *);
FILE* freopen(const char*, const char*, FILE*);
FILE* _wfopen(const wchar_t*,const wchar_t *);

int printf(const char*, ...);
int sprintf(char*,const char*, ...);
int fprintf(FILE*,const char*, ...);
int sscanf(const char*, const char*, ...);
int scanf(const char*, ...);
int fscanf(FILE *,const char *, ...);
int _snprintf(char *,size_t,const char*,...);
#define snprintf _snprintf
int _vsnprintf(char*, size_t, const char*, va_list);
int vsnprintf(char*,size_t,const char*,va_list);
int vsprintf(char*, const char*, va_list);
int _wremove(const wchar_t*);
int _wrename(const wchar_t*,const wchar_t*);

typedef char* va_list;

int vfprintf(FILE*, const char*, va_list);
int vprintf(const char*, va_list);

int puts(const char*);
char* fgets(char*, int, FILE*);
int fputs(const char*, FILE*);
int fgetc(FILE*);
int fputc(int, FILE*);
int ungetc(int, FILE*);
int getchar(void);
int putchar(int);
int fflush(FILE *);
int getc(FILE *);
int putc(int, FILE *);

int feof(FILE*);
int ferror(FILE*);
void clearerr(FILE*);

int fileno(FILE*);
int _fileno(FILE*);
int setvbuf(FILE*,char*,int,size_t);
FILE* _popen(const char*, const char*);
int _pclose(FILE*);
int _unlink(const char *);
#define unlink _unlink;
FILE* _fdopen(int, const char *);
#define fdopen _fdopen
int fgetpos(FILE*, fpos_t*);
int fsetpos(FILE*, const fpos_t*);
void perror(char*);
void setbuf(FILE*, char*);

void rewind(FILE*);

FILE* tmpfile(void);

char* tmpnam(char*);
wchar_t getwc(FILE *);

extern void* _wenviron;

#endif

=== stdlib.h 0 0 90/108 ===
/* Header stdlib.h */

#ifndef $stdlib
#define $stdlib 1

#include <stddef.h>

#define EXIT_FAILURE 1
#define EXIT_SUCCESS 0

#define RAND_MAX 32767

void* malloc(size_t);
void* realloc(void*, size_t);
void* calloc(size_t, size_t);

void free(void*);

void exit(int);

int system(const char*);
int _wsystem(const wchar_t*);

int abs(int);
long labs(long);
long long llabs(long);
int rand(void);
void srand(unsigned int);
int atoi(const char*);
long atol(const char*);
long long atoll(const char*);
long long atoi64(const char*);
double atof(const char *);
int	atexit(void (*)(void));
char *_itoa(int,char *,int);

#define itoa _itoa

void qsort(void*, size_t, size_t, int (*)(void*, void*));

typedef struct {
	long long int quot;
	long long int rem;
} lldiv_t;

lldiv_t lldiv(long long int, long long int);

char* getenv(const char*);
wchar_t* _wgetenv(const wchar_t*);
int _wputenv(const wchar_t*);


double strtod(const char*, char**);

//float strtof(const char *, char**);
#define strtof strtod

long double strtold(const char*, char**);
void abort(void);
long int strtol(const char*, char**, int);

long double strtold(const char *,char **);

long long int _strtoi64(const char *,char **,int);
#define strtoll _strtoi64

unsigned long long int _strtoui64(const char *,char **,int);

unsigned long long int _strtoui64(const char*, char**, int);
#define strtoull _strtoui64
unsigned long strtoul(const char*, char**, int);

size_t _msize(void *);
#define msize _msize

void* bsearch(const void *,const void *, size_t, size_t,
		int (*_compar)(const void *,const void *));


char* _fullpath(char*, const char*, size_t);


#endif
=== string.h 0 0 91/108 ===
/* Header string.h */

#include <stddef.h>

void* memcpy(void*, const void*, size_t);
void* memmove(const void*, const void*, size_t);
void* memset(void*, int, size_t);
int memcmp(const void*, const void*, size_t);
void* memchr(const void *, int, size_t);

size_t strlen(const char*);
char* strcpy(char*, const char*);
char* strncpy(char*, const char*, size_t);
char* strcat(char*, const char*);
int strcmp(const char*, const char*);
int strncmp(const char*, const char*, size_t);
char* strchr(const char*, int);
char* strstr(const char*, const char*);
char* strrchr(const char*, int);
int _stricmp(const char*, const char*);
#define stricmp _stricmp
#define strcasecmp _stricmp



int _strnicmp(const char*, const char*, size_t);
#define strnicmp _strnicmp
char* strncat(char*, const char*, size_t);
char* strtok(char*, const char*);

size_t strcspn(const char*, const char*);
size_t strspn(const char*, const char*);
int strcoll(const char *, const char *);

unsigned long strtoul(const char*, char**, int);

char* strerror(int);
char* strpbrk(const char*, const char*);
size_t strxfrm(char*, const char *, size_t);

char* _strupr(char*);
char* _strlwr(char*);
#define strupr _strupr
#define strlwr _strlwr

char*strnupr(char*,size_t);
char*strnlwr(char*,size_t);
int strtrim(char*);
char*strrev(char*);

char* _strdup(const char*);
#define strdup _strdup

int _wcsicmp(const wchar_t *,const wchar_t *);

wchar_t *wcspbrk(const wchar_t*,const wchar_t*);

size_t wcslen(const wchar_t*);
=== time.h 0 0 92/108 ===
/* Header time.h */

#ifndef $time
#define $time

#include <stddef.h>

typedef long clock_t;
clock_t clock(void);

//typedef long time_t;
#ifndef _TIME_T_DEFINED
#define _TIME_T_DEFINED
typedef long long int time_t;
#endif

struct tm
{
  int	tm_sec;
  int	tm_min;
  int	tm_hour;
  int	tm_mday;
  int	tm_mon;
  int	tm_year;
  int	tm_wday;
  int	tm_yday;
  int	tm_isdst;
};

//struct tm *localtime(time_t*);
struct tm* _localtime32(time_t*);
#define localtime _localtime32

time_t _time64(time_t *_timer);
#define time _time64

#define CLOCKS_PER_SEC 1000

struct tm *gmtime(const time_t*);
size_t strftime(char *, size_t, const char *, const struct tm *);
time_t mktime(struct tm *);
double difftime(time_t, time_t);

char* asctime(const struct tm*);
//char* ctime(const time_t *_time);
char* _ctime64(const time_t *_time);
#define ctime _ctime64

#endif
=== unistd.h 0 0 93/108 ===
/* unistd.h header */

unsigned int _sleep(unsigned int);
#define sleep _sleep

#define alarm(x) {puts("ALARM"); exit(1);}

int _write(int,void*,unsigned int);
#define write _write

int _close(int);
#define close _close
=== utime.h 0 0 94/108 ===
/* sys/utime.h header */

#ifndef $utime
#define $utime

struct _utimbuf {
	long actime;
	long modtime;
};


struct utimbuf {
	long actime;
	long modtime;
};

struct __utimbuf64 {
  long long int actime;
  long long int modtime;
};

int _utime64(const char *_Filename,struct __utimbuf64 *_Time);

int utime(const char *_Filename,struct utimbuf *_Utimbuf) {
  return _utime64(_Filename,(struct __utimbuf64 *)_Utimbuf);
}

#endif
=== w.c 0 0 95/108 ===
//#define __attribute__(x)
//#define _WIN32
//#define WIN32
//#define __inline
//#define __dllimport(x)
//#define __declspec(x)
//#define __stdcall
#define CALLBACK
//#define __cdecl
#define EXTERN_C extern
#define DECLSPEC_IMPORT

#include "windows.h"
=== wchar.h 0 0 96/108 ===
/* Header wchar.h */

#include <stddef.h>


#define _WCHAR_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wchar_t;
//typedef signed short wchar_t;

size_t wcslen(const wchar_t*);
wchar_t* wcscpy(wchar_t*,const wchar_t*);
//wchar_t* _wgetenv(constwchar_t*);
wchar_t* wcstok(wchar_t*,wchar_t*,wchar_t**);
wchar_t* wcstok_s(wchar_t*,wchar_t*,wchar_t**);

wchar_t* wcschr(wchar_t*,wchar_t);
wchar_t* wcsstr(const wchar_t*,const wchar_t*);


int wcscmp(const wchar_t*,const wchar_t*);
typedef long _off_t;
=== wctype.h 0 0 97/108 ===
/* Header wctype.h */
=== windows.h 0 0 98/108 ===
#ifndef $windows
#define $windows 1
#include <stdarg.h>
#include <stddef.h>

#define FALSE 0
#define TRUE 1

typedef int BOOL;
typedef BOOL *PBOOL;
#define FAR
#define NEAR
#define Int32x32To64(a,b)(((long long)((long)(a))) *((long long)((long)(b))))


#define DECLARE_HANDLE(n) typedef HANDLE n
#define _WINBASE_
#define WINBASEAPI
typedef int WINBOOL;
typedef unsigned short UINT16;
typedef unsigned short ATOM;
typedef unsigned char BOOLEAN;
typedef unsigned char BYTE;
typedef unsigned long CALTYPE;
typedef unsigned long CALID;
typedef unsigned long long *PULONGLONG;
typedef long long LONG64;
typedef char CCHAR;
typedef char CHAR;
typedef unsigned long COLORREF;
#define CONST const
typedef unsigned long DWORD;

typedef unsigned long ULONG_PTR;
typedef ULONG_PTR *PULONG_PTR;
typedef ULONG_PTR DWORD_PTR;
typedef long long int LONGLONG;
typedef unsigned long long UINT_PTR;
typedef ULONG_PTR SIZE_T;
typedef SIZE_T *PSIZE_T;
typedef unsigned long long int DWORDLONG,*PDWORDLONG;
typedef float FLOAT;
typedef void *HANDLE;
typedef long SCODE,*PSCODE;
typedef double DOUBLE;
typedef HANDLE GLOBALHANDLE;
typedef HANDLE HSTMT;
typedef HANDLE HDBC;
typedef HANDLE HENV;
typedef HANDLE LOCALHANDLE;
typedef HANDLE HTASK;
typedef HANDLE HACCEL;
typedef HANDLE HBITMAP;
typedef HANDLE HBRUSH;
typedef HANDLE HCOLORSPACE;
typedef HANDLE HCONV;
typedef HANDLE HCONVLIST;
typedef HANDLE HCURSOR;
typedef HANDLE HDC;
typedef HANDLE HDDEDATA;
typedef HANDLE HDESK;
typedef HANDLE HWINEVENTHOOK;
typedef HANDLE HDWP;
typedef HANDLE HENHMETAFILE;
typedef int HFILE;
typedef HANDLE HFONT;
typedef HANDLE HGDIOBJ;
typedef HANDLE HGLOBAL;
typedef HANDLE HGLRC;
typedef HANDLE HHOOK;
typedef HANDLE HICON;
typedef HANDLE HIMAGELIST;
typedef HANDLE HINSTANCE;
typedef HANDLE HKEY,*PHKEY;
typedef HANDLE HKL;
typedef HANDLE HLOCAL;
typedef HANDLE HMENU;
typedef HANDLE HMETAFILE;
typedef HANDLE HMODULE;
typedef HANDLE HPALETTE;
typedef HANDLE HPEN;
typedef long HRESULT;
#define _HRESULT_DEFINED
#define SNDMSG SendMessage
typedef HANDLE HRGN;
typedef HANDLE HRSRC;
typedef HANDLE HSZ;
typedef HANDLE HWINSTA;
typedef HANDLE HWND;
typedef int INT;
typedef unsigned short LANGID;
typedef DWORD LCID;
#define _LCID_DEFINED
typedef DWORD LCTYPE;
typedef enum _SYSTEM_POWER_STATE { PowerSystemUnspecified=0,PowerSystemWorking=1,
	PowerSystemSleeping1 =2,PowerSystemSleeping2=3,PowerSystemSleeping3=4,
	PowerSystemHibernate=5,PowerSystemShutdown=6,PowerSystemMaximum=7
} SYSTEM_POWER_STATE,*PSYSTEM_POWER_STATE;
#define POWER_SYSTEM_MAXIMUM 7
typedef enum { PowerActionNone=0,PowerActionReserved,PowerActionSleep,PowerActionHibernate,
	PowerActionShutdown,PowerActionShutdownReset,PowerActionShutdownOff,PowerActionWarmEject
} POWER_ACTION, *PPOWER_ACTION;
typedef enum _DEVICE_POWER_STATE { PowerDeviceUnspecified=0,PowerDeviceD0,PowerDeviceD1,
	PowerDeviceD2,PowerDeviceD3,PowerDeviceMaximum
} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;
#define ES_SYSTEM_REQUIRED	0x1
#define ES_DISPLAY_REQUIRED	0x2
#define ES_USER_PRESENT	0x4
#define ES_CONTINUOUS	0x80000000
typedef DWORD EXECUTION_STATE;
typedef long LONG;
typedef long long USN;
typedef unsigned long long ULONGLONG;
typedef long LPARAM;
typedef BOOL *LPBOOL;
typedef BYTE *LPBYTE;
typedef CONST BYTE *LPCBYTE;
typedef CONST CHAR *LPCCH;
typedef CHAR *LPCH;
typedef COLORREF *LPCOLORREF;
typedef const char *LPCSTR;
typedef unsigned short * LPCOLESTR;
#define OLESTR(str) L##str
typedef unsigned char UCHAR;
typedef signed char SCHAR;
typedef long int SDWORD;
typedef short int SWORD;
typedef unsigned long int UDWORD;
typedef unsigned short int UWORD;
typedef unsigned long ULONG;
typedef unsigned short USHORT;
//#endif
typedef signed short RETCODE;
#define STDAPI
#define STDAPICALLTYPE
#define STDAPIVCALLTYPE
#define STDMETHODCALLTYPE
#define STDAPI_(type) type
#define APIPRIVATE
//#endif /* rc_invoked */
#define CONTROL_C_EXIT STATUS_CONTROL_C_EXIT
#define WC_LINK L"Syslink"
#define WC_SCROLLBARA "ScrollBar"
#define WC_SCROLLBARW L"ScrollBar"
#define WC_IPADDRESSW	L"SysIPAddress32"
#define WC_IPADDRESSA	"SysIPAddress32"
#define WC_NATIVEFONTCTLW	L"NativeFontCtl"
#define WC_NATIVEFONTCTLA	"NativeFontCtl"
#define WC_COMBOBOXEXW	L"ComboBoxEx32"
#define WC_COMBOBOXEXA	"ComboBoxEx32"
#define WC_BUTTONA "Button"
#define WC_BUTTONW L"Button"
#define WC_STATICA "Static"
#define WC_STATICW L"Static"
#define WC_EDITA "Edit"
#define WC_EDITW L"Edit"
#define WC_LISTBOXA "ListBox"
#define WC_LISTBOXW L"ListBox"
#define WC_COMBOBOXA "ComboBox"
#define WC_COMBOBOXW L"ComboBox"
#define SB_GETUNICODEFORMAT	CCM_GETUNICODEFORMAT
#define SB_SETUNICODEFORMAT	CCM_SETUNICODEFORMAT
#define TB_GETUNICODEFORMAT CCM_GETUNICODEFORMAT
#define TB_SETUNICODEFORMAT CCM_SETUNICODEFORMAT
#define TC_NORMAL 0
#define TC_HARDERR 1
#define TC_GP_TRAP 2
#define TC_SIGNAL 3
#ifdef UNICODE
#define WC_EDIT WC_EDITW
#define WC_BUTTON WC_BUTTONW
typedef const unsigned short *LPCTSTR;
typedef unsigned short *LPTCH;
typedef unsigned short *LPTSTR;
typedef unsigned short *PTBYTE;
typedef unsigned short *PTCH;
typedef unsigned short *PTCHAR;
typedef unsigned short *PTSTR;
typedef unsigned short TBYTE;
typedef unsigned short TCHAR;
typedef unsigned short BCHAR;
#define WC_STATIC WC_STATICW
#define WC_LISTBOX WC_LISTBOXW
#define WC_COMBOBOX WC_COMBOBOXW
#define ANYSIZE_ARRAY 1
#define TEXT(quote) L##quote
#define SERVICES_ACTIVE_DATABASE	SERVICES_ACTIVE_DATABASEW
#define SERVICES_FAILED_DATABASE	SERVICES_FAILED_DATABASEW
#define SC_GROUP_IDENTIFIER	SC_GROUP_IDENTIFIERW
#define HDM_GETITEM HDM_GETITEMW
#define HDM_INSERTITEM HDM_INSERTITEMW
#define HDM_SETITEM HDM_SETITEMW
#define HDM_SETUNICODEFORMAT CCM_SETUNICODEFORMAT
#define HDM_GETUNICODEFORMAT CCM_GETUNICODEFORMAT
#define ACM_OPEN ACM_OPENW
#define HDN_BEGINTRACK HDN_BEGINTRACKW
#define HDN_DIVIDERDBLCLICK HDN_DIVIDERDBLCLICKW
#define HDN_ENDTRACK HDN_ENDTRACKW
#define HDN_ITEMCHANGED HDN_ITEMCHANGEDW
#define HDN_ITEMCHANGING HDN_ITEMCHANGINGW
#define HDN_ITEMCLICK HDN_ITEMCLICKW
#define HDN_ITEMDBLCLICK HDN_ITEMDBLCLICKW
#define HDN_GETDISPINFO	HDN_GETDISPINFOW
#define HDN_TRACK HDN_TRACKW
#define WC_COMBOBOXEX	WC_COMBOBOXEXW
#define WC_IPADDRESS	WC_IPADDRESSW
#define WC_SCROLLBAR	WC_SCROLLBARW
#define GetSystemWindowsDirectory GetSystemWindowsDirectoryW
#define IPN_FIELDCHANGED	(IPN_FIRST - 0)
#define MAKEIPRANGE(low, high)	((LPARAM)(WORD)(((BYTE)(high) << 8) + (BYTE)(low)))
#define MAKEIPADDRESS(b1,b2,b3,b4)	((LPARAM)(((DWORD)(b1)<<24)+((DWORD)(b2)<<16)+((DWORD)(b3)<<8)+((DWORD)(b4))))
#define FIRST_IPADDRESS(x)	((x>>24) & 0xff)
#define SECOND_IPADDRESS(x)	((x>>16) & 0xff)
#define THIRD_IPADDRESS(x)	((x>>8) & 0xff)
#define FOURTH_IPADDRESS(x)	(x & 0xff)
#define LVM_EDITLABEL LVM_EDITLABELW
#define	LVM_FINDITEM	LVM_FINDITEMW
#define	LVM_GETCOLUMN	LVM_GETCOLUMNW
#define	LVM_GETITEMTEXT	LVM_GETITEMTEXTW
#define	LVM_GETSTRINGWIDTH	LVM_GETSTRINGWIDTHW
#define	LVM_INSERTCOLUMN	LVM_INSERTCOLUMNW
#define	LVM_SETCOLUMN	LVM_SETCOLUMNW
#define	LVM_SETITEMTEXT	LVM_SETITEMTEXTW
#define	LVM_EDITLABEL	LVM_EDITLABELW
#define	LVM_GETBKIMAGE	LVM_GETBKIMAGEW
#define	LVM_GETISEARCHSTRING	LVM_GETISEARCHSTRINGW
#define	LVM_GETITEM	LVM_GETITEMW
#define	LVM_INSERTITEM	LVM_INSERTITEMW
#define	LVM_SETBKIMAGE	LVM_SETBKIMAGEW
#define	LVM_SETITEM	LVM_SETITEMW
#define LVN_BEGINLABELEDIT LVN_BEGINLABELEDITW
#define LVN_ENDLABELEDIT LVN_ENDLABELEDITW
#define LVN_GETDISPINFO LVN_GETDISPINFOW
#define LVN_SETDISPINFO LVN_SETDISPINFOW
#define LVN_ODFNDITEM LVN_ODFINDITEMW
#define LVN_HOTTRACK	(LVN_FIRST+21)
#define PSM_SETFINISHTEXT PSM_SETFINISHTEXTW
#define PSM_SETTITLE PSM_SETTITLEW
#define SB_GETTEXT SB_GETTEXTW
#define SB_GETTEXTLENGTH SB_GETTEXTLENGTHW
#define SB_SETTEXT SB_SETTEXTW
#define TB_ADDSTRING TB_ADDSTRINGW
#define TB_GETBUTTONTEXT TB_GETBUTTONTEXTW
#define TB_SAVERESTORE TB_SAVERESTOREW
#define TBBUTTONINFO TBBUTTONINFOW
#define LPTBBUTTONINFO LPTBBUTTONINFOW
#define DESKTOPENUMPROC DESKTOPENUMPROCW
#define TBN_GETBUTTONINFO TBN_GETBUTTONINFOW
#define TBN_GETDISPINFO	TBN_GETDISPINFOW
#define TCM_GETITEM TCM_GETITEM
#define TCM_INSERTITEM TCM_INSERTITEMW
#define TCM_SETITEM TCM_SETITEMW
#define TTM_ADDTOOL TTM_ADDTOOLW
#define TTM_DELTOOL TTM_DELTOOLW
#define TTM_ENUMTOOLS TTM_ENUMTOOLSW
#define TTM_GETCURRENTTOOL TTM_GETCURRENTTOOLW
#define TTM_GETTEXT TTM_GETTEXTW
#define TTM_GETTOOLINFO TTM_GETTOOLINFOW
#define TTM_HITTEST TTM_HITTESTW
#define TTM_NEWTOOLRECT TTM_NEWTOOLRECTW
#define TTM_SETTOOLINFO TTM_SETTOOLINFOW
#define TTM_UPDATETIPTEXT TTM_UPDATETIPTEXTW
#define TTN_NEEDTEXT TTN_NEEDTEXTW
#define TTN_GETDISPINFO	TTN_GETDISPINFOW
#define TVM_EDITLABEL TVM_EDITLABELW
#define TVM_GETISEARCHSTRING TVM_GETISEARCHSTRINGW
#define TVM_GETITEM TVM_GETITEMW
#define TVM_INSERTITEM TVM_INSERTITEMW
#define TVM_SETITEM TVM_SETITEMW
#define TVN_BEGINDRAG TVN_BEGINDRAGW
#define TVN_BEGINLABELEDIT TVN_BEGINLABELEDITW
#define TVN_BEGINRDRAG TVN_BEGINRDRAGW
#define TVN_DELETEITEM TVN_DELETEITEMW
#define TVN_ENDLABELEDIT TVN_ENDLABELEDITW
#define TVN_GETDISPINFO TVN_GETDISPINFOW
#define TVN_ITEMEXPANDED TVN_ITEMEXPANDEDW
#define TVN_ITEMEXPANDING TVN_ITEMEXPANDINGW
#define TVN_SELCHANGED TVN_SELCHANGEDW
#define TVN_SELCHANGING TVN_SELCHANGINGW
#define TVN_SETDISPINFO TVN_SETDISPINFOW
#define ANIMATE_CLASS ANIMATE_CLASSW
#define HOTKEY_CLASS HOTKEY_CLASSW
#define PROGRESS_CLASS PROGRESS_CLASSW
#define STATUSCLASSNAME STATUSCLASSNAMEW
#define REBARCLASSNAME REBARCLASSNAMEW
#define REBARBANDINFO REBARBANDINFOW
#define TOOLBARCLASSNAME TOOLBARCLASSNAMEW
#define TOOLTIPS_CLASS TOOLTIPS_CLASSW
#define TRACKBAR_CLASS TRACKBAR_CLASSW
#define UPDOWN_CLASS UPDOWN_CLASSW
#define WC_HEADER WC_HEADERW
#define WC_NATIVEFONTCTL	WC_NATIVEFONTCTLA
#define WC_LISTVIEW WC_LISTVIEWW
#define WC_TABCONTROL WC_TABCONTROLW
#define WC_TREEVIEW WC_TREEVIEWW
#define LPSTR_TEXTCALLBACK LPSTR_TEXTCALLBACKW
#define RB_INSERTBAND	RB_INSERTBANDW
#define RB_SETBANDINFO	RB_SETBANDINFOW
#define LPREBARBANDINFO	LPREBARBANDINFOW
#define NMLVDISPINFO NMLVDISPINFOW
#define LVN_GETINFOTIP	LVN_GETINFOTIPW
#define NMLVGETINFOTIP	NMLVGETINFOTIPW
#define LPNMLVGETINFOTIP	LPNMLVGETINFOTIPW
#define LVFINDINFO	LVFINDINFOW
#define NMCBEDRAGBEGIN NMCBEDRAGBEGINW
#define LPNMCBEDRAGBEGIN LPNMCBEDRAGBEGINW
#define PNMCBEDRAGBEGIN PNMCBEDRAGBEGINW
#define NMCBEENDEDIT NMCBEENDEDITW
#define LPNMCBEENDEDIT LPNMCBEENDEDITW
#define PNMCBEENDEDIT PNMCBEENDEDITW
#define LPLVITEM	LPLVITEMW
#define LPLVCOLUMN	LPLVCOLUMNW
#define PGET_MODULE_HANDLE_EX PGET_MODULE_HANDLE_EXW
#else
typedef const char *LPCTSTR;
typedef char *LPTCH;
typedef char *LPTSTR;
typedef unsigned char *PTBYTE;
typedef char *PTCH;
typedef char *PTCHAR;
typedef char *PTSTR;
typedef unsigned char TBYTE;
typedef char TCHAR;
typedef BYTE BCHAR;
#define WC_EDIT WC_EDITA
#define WC_BUTTON WC_BUTTONA
#define WC_STATIC WC_STATICA
#define WC_LISTBOX WC_LISTBOXA
#define WC_COMBOBOX WC_COMBOBOXW
#define TEXT(quote) quote
#define SERVICES_ACTIVE_DATABASE	SERVICES_ACTIVE_DATABASEA
#define SERVICES_FAILED_DATABASE	SERVICES_FAILED_DATABASEA
#define SC_GROUP_IDENTIFIER	SC_GROUP_IDENTIFIERA
#define WC_COMBOBOXEX	WC_COMBOBOXEXA
#define WC_NATIVEFONTCTL	WC_NATIVEFONTCTLA
#define WC_IPADDRESS	WC_IPADDRESSA
#define WC_SCROLLBAR	WC_SCROLLBARA
#define GetSystemWindowsDirectory GetSystemWindowsDirectoryA
#define HDN_GETDISPINFO	HDN_GETDISPINFOA
#define HDM_GETITEM HDM_GETITEMA
#define HDM_INSERTITEM HDM_INSERTITEMA
#define HDM_SETITEM HDM_SETITEMA
#define ACM_OPEN ACM_OPENA
#define HDN_BEGINTRACK HDN_BEGINTRACKA
#define HDN_DIVIDERDBLCLICK HDN_DIVIDERDBLCLICKA
#define HDN_ENDTRACK HDN_ENDTRACKA
#define HDN_ITEMCHANGED HDN_ITEMCHANGEDA
#define HDN_ITEMCHANGING HDN_ITEMCHANGINGA
#define HDN_ITEMCLICK HDN_ITEMCLICKA
#define HDN_ITEMDBLCLICK HDN_ITEMDBLCLICKA
#define HDN_TRACK HDN_TRACKA
#define	LVM_FINDITEM	LVM_FINDITEMA
#define	LVM_GETCOLUMN	LVM_GETCOLUMNA
#define	LVM_GETITEMTEXT	LVM_GETITEMTEXTA
#define	LVM_GETSTRINGWIDTH	LVM_GETSTRINGWIDTHA
#define	LVM_INSERTCOLUMN	LVM_INSERTCOLUMNA
#define	LVM_SETCOLUMN	LVM_SETCOLUMNA
#define	LVM_SETITEMTEXT	LVM_SETITEMTEXTA
#define	LVM_EDITLABEL	LVM_EDITLABELA
#define	LVM_GETBKIMAGE	LVM_GETBKIMAGEA
#define	LVM_GETISEARCHSTRING	LVM_GETISEARCHSTRINGA
#define	LVM_GETITEM	LVM_GETITEMA
#define	LVM_INSERTITEM	LVM_INSERTITEMA
#define	LVM_SETBKIMAGE	LVM_SETBKIMAGEA
#define	LVM_SETITEM	LVM_SETITEMA
#define LVN_BEGINLABELEDIT LVN_BEGINLABELEDITA
#define LVN_ENDLABELEDIT LVN_ENDLABELEDITA
#define LVN_GETDISPINFO LVN_GETDISPINFOA
#define LVN_SETDISPINFO LVN_SETDISPINFOA
#define LVN_ODFINDITEM LVN_ODFINDITEMA
#define PSM_SETFINISHTEXT PSM_SETFINISHTEXTA
#define PSM_SETTITLE PSM_SETTITLEA
#define SB_GETTEXT SB_GETTEXTA
#define SB_GETTEXTLENGTH SB_GETTEXTLENGTHA
#define SB_SETTEXT SB_SETTEXTA
#define TB_ADDSTRING TB_ADDSTRINGA
#define TB_GETBUTTONTEXT TB_GETBUTTONTEXTA
#define TB_SAVERESTORE TB_SAVERESTOREA
#define TB_GETBUTTONINFO	TB_GETBUTTONINFOA
#define TB_SETBUTTONINFO	TB_SETBUTTONINFOA
#define TBBUTTONINFO TBBUTTONINFOA
#define LPTBBUTTONINFO LPTBBUTTONINFOA
#define DESKTOPENUMPROC DESKTOPENUMPROCA
#define TBN_GETBUTTONINFO TBN_GETBUTTONINFOA
#define TBN_GETDISPINFO TBN_GETDISPINFOA
#define TCM_GETITEM TCM_GETITEMA
#define TCM_INSERTITEM TCM_INSERTITEMA
#define TCM_SETITEM TCM_SETITEMA
#define TTM_ADDTOOL TTM_ADDTOOLA
#define TTM_DELTOOL TTM_DELTOOLA
#define TTM_ENUMTOOLS TTM_ENUMTOOLSA
#define TTM_GETCURRENTTOOL TTM_GETCURRENTTOOLA
#define TTM_GETTEXT TTM_GETTEXTA
#define TTM_GETTOOLINFO TTM_GETTOOLINFOA
#define TTM_HITTEST TTM_HITTESTA
#define TTM_NEWTOOLRECT TTM_NEWTOOLRECTA
#define TTM_SETTOOLINFO TTM_SETTOOLINFOA
#define TTM_UPDATETIPTEXT TTM_UPDATETIPTEXTA
#define TTN_NEEDTEXT TTN_NEEDTEXTA
#define TTN_GETDISPINFO	TTN_GETDISPINFOA
#define TVM_EDITLABEL TVM_EDITLABELA
#define TVM_GETISEARCHSTRING TVM_GETISEARCHSTRINGA
#define TVM_GETITEM TVM_GETITEMA
#define TVM_INSERTITEM TVM_INSERTITEMA
#define TVM_SETITEM TVM_SETITEMA
#define TVN_BEGINDRAG TVN_BEGINDRAGA
#define TVN_BEGINLABELEDIT TVN_BEGINLABELEDITA
#define TVN_BEGINRDRAG TVN_BEGINRDRAGA
#define TVN_DELETEITEM TVN_DELETEITEMA
#define TVN_ENDLABELEDIT TVN_ENDLABELEDITA
#define TVN_GETDISPINFO TVN_GETDISPINFOA
#define TVN_ITEMEXPANDED TVN_ITEMEXPANDEDA
#define TVN_ITEMEXPANDING TVN_ITEMEXPANDINGA
#define TVN_SELCHANGED TVN_SELCHANGEDA
#define TVN_SELCHANGING TVN_SELCHANGINGA
#define TVN_SETDISPINFO TVN_SETDISPINFOA
#define ANIMATE_CLASS ANIMATE_CLASSA
#define HOTKEY_CLASS HOTKEY_CLASSA
#define PROGRESS_CLASS PROGRESS_CLASSA
#define STATUSCLASSNAME STATUSCLASSNAMEA
#define REBARCLASSNAME REBARCLASSNAMEA
#define REBARBANDINFO REBARBANDINFOA
#define TOOLBARCLASSNAME TOOLBARCLASSNAMEA
#define TOOLTIPS_CLASS TOOLTIPS_CLASSA
#define TRACKBAR_CLASS TRACKBAR_CLASSA
#define UPDOWN_CLASS UPDOWN_CLASSA
#define WC_HEADER WC_HEADERA
#define WC_LISTVIEW WC_LISTVIEWA
#define WC_TABCONTROL WC_TABCONTROLA
#define WC_TREEVIEW WC_TREEVIEWA
#define LPSTR_TEXTCALLBACK LPSTR_TEXTCALLBACKA
#define RB_INSERTBAND	RB_INSERTBANDA
#define RB_SETBANDINFO	RB_SETBANDINFOA
#define LPREBARBANDINFO LPREBARBANDINFOA
#define NMLDISPINFO NMLDISPINFOA
#define LVN_GETINFOTIP	LVN_GETINFOTIPA
#define NMLVGETINFOTIP	NMLVGETINFOTIPA
#define LPNMLVGETINFOTIP	LPNMLVGETINFOTIPA
#define LVFINDINFO LVFINDINFOA
#define NMCBEDRAGBEGIN NMCBEDRAGBEGINA
#define NMLVDISPINFO NMLVDISPINFOA
#define LPNMCBEDRAGBEGIN LPNMCBEDRAGBEGINA
#define PNMCBEDRAGBEGIN PNMCBEDRAGBEGINA
#define NMCBEENDEDIT NMCBEENDEDITA
#define LPNMCBEENDEDIT LPNMCBEENDEDITA
#define PNMCBEENDEDIT PNMCBEENDEDITA
#define LPLVITEM	LPLVITEMA
#define LPLVCOLUMN	LPLVCOLUMNA
#define PGET_MODULE_HANDLE_EX PGET_MODULE_HANDLE_EXA
#endif // UNICODE

//#ifndef RC_INVOKED
typedef const unsigned short *LPCWCH;
typedef const unsigned short *LPCWSTR;
typedef DWORD *LPDWORD;
typedef HANDLE *LPHANDLE;
typedef int *LPINT;
typedef long *LPLONG;
typedef char *LPSTR;
typedef long LRESULT;
typedef void *LPVOID;
typedef const void *LPCVOID;
typedef unsigned short *LPWCH;
typedef unsigned short *LPWORD;
typedef unsigned short *LPWSTR;
typedef unsigned short *PWSTR;
typedef unsigned short *NWPSTR;
typedef BOOL *PWINBOOL;
typedef BYTE *PBOOLEAN;
typedef BYTE *PBYTE;
typedef const CHAR *PCCH;
typedef CHAR *PCH;
typedef CHAR *PCHAR;
typedef const char *PCSTR;
typedef const unsigned short *PCWCH;
typedef const unsigned short *PCWSTR;
typedef DWORD *PDWORD;
typedef float *PFLOAT;
typedef HANDLE *PHANDLE;
typedef int *PINT;
typedef long *PLONG;
typedef short *PSHORT;
typedef char *PSTR;
typedef char *PSZ;
typedef unsigned char *PUCHAR;
typedef unsigned int *PUINT;
typedef unsigned long *PULONG;
typedef unsigned short *PUSHORT;
typedef void *PVOID;
typedef unsigned short *PWCH;
typedef unsigned short *PWCHAR;
typedef unsigned short *PWORD;
typedef short SHORT;
typedef unsigned int UINT;
#define VOID void
typedef unsigned short WCHAR;
typedef unsigned short WORD;
typedef unsigned int WPARAM;
#define CDECL
#define CALLBACK
#define PASCAL
#define WINAPI	
#define NTAPI	
#define WINGDIAPI 
#define WINAPIV
#define APIENTRY	
#define IPM_CLEARADDRESS	(WM_USER+100)
#define IPM_SETADDRESS	(WM_USER+101)
#define IPM_GETADDRESS	(WM_USER+102)
#define IPM_SETRANGE	(WM_USER+103)
#define IPM_SETFOCUS	(WM_USER+104)
#define IPM_ISBLANK	(WM_USER+105)
typedef enum _ACL_INFORMATION_CLASS {
	AclRevisionInformation = 1,AclSizeInformation
} ACL_INFORMATION_CLASS;
typedef enum _SECURITY_IMPERSONATION_LEVEL {
	SecurityAnonymous,SecurityIdentification, SecurityImpersonation,
	SecurityDelegation
} SECURITY_IMPERSONATION_LEVEL;
typedef enum _SID_NAME_USE {
	SidTypeUser = 1,SidTypeGroup, SidTypeDomain, SidTypeAlias,
	SidTypeWellKnownGroup,SidTypeDeletedAccount, SidTypeInvalid,
	SidTypeUnknown
} SID_NAME_USE,*PSID_NAME_USE;
typedef enum _TOKEN_INFORMATION_CLASS {
	TokenUser = 1,TokenGroups, TokenPrivileges, TokenOwner,
	TokenPrimaryGroup,TokenDefaultDacl, TokenSource, TokenType,
	TokenImpersonationLevel,TokenStatistics
} TOKEN_INFORMATION_CLASS;
typedef enum tagTOKEN_TYPE {
	TokenPrimary = 1,TokenImpersonation
} TOKEN_TYPE;
typedef enum { LT_DONT_CARE, LT_LOWEST_LATENCY } LATENCY_TIME;
//#endif RC_INVOKED

#define FORWARD_WM_NOTIFY(h,id,hdr,fn) (void)(fn)((h),WM_NOTIFY,(WPARAM)(id),(LPARAM)(hdr))
#define GetBValue(rgb) ((BYTE) ((rgb) >> 16))
#define GetGValue(rgb) ((BYTE) (((WORD) (rgb)) >> 8))
#define GetRValue(rgb) ((BYTE) (rgb))
#define RGB(r,g,b) ((DWORD)(((BYTE)(r)|((WORD)(g) << 8))|(((DWORD)(BYTE)(b)) << 16)))
#define HANDLE_WM_NOTIFY(h,wP,lP,fn) (fn)((h),(int)(wP),(NMHDR *)(lP))
#define HIBYTE(w) ((BYTE) (((WORD) (w) >> 8) & 0xFF))
#define HIWORD(l) ((WORD) (((DWORD) (l) >> 16) & 0xFFFF))
#define LOBYTE(w) (((BYTE) (w)) & 0xFF)
#define LOWORD(l) (((WORD) (l)) & 0xFFFF)
#define MAKELONG(a,b) ((LONG) (((WORD) (a)) | ((DWORD) ((WORD) (b))) << 16))
#define MAKEWORD(a,b) ((WORD) (((BYTE) (a)) | ((WORD) ((BYTE) (b))) << 8))
#define INDEXTOOVERLAYMASK(i) ((i) << 8)
#define INDEXTOSTATEIMAGEMASK(i) ((i) << 12)
#define MAXINTATOM 0xC000
#define INVALID_ATOM ((ATOM)0)
#define MAKEINTATOM(i) (LPTSTR) ((DWORD) ((WORD) (i)))
#define MAKEINTRESOURCE(i) (LPTSTR) ((DWORD) ((WORD) (i)))
#define IS_INTRESOURCE(_r) (((ULONG_PTR)(_r) >> 16)==0)
#define MAKELANGID(p,s) ((((WORD) (s)) << 10) | (WORD) (p))
#define PRIMARYLANGID(lgid) ((WORD )(lgid) & 0x3ff)
#define SUBLANGID(lgid) ((WORD )(lgid) >> 10)
#define LANGIDFROMLCID(lcid) ((WORD) (lcid))
#define SORTIDFROMLCID(lcid) ((WORD )((((DWORD)(lcid)) & 0xFFFFF) >> 16))
#define MAKELCID(lgid,srtid) ((DWORD)((((DWORD)((WORD)(srtid))) << 16)|((DWORD)((WORD)(lgid)))))
#define MAKELPARAM(l,h) ((LPARAM) MAKELONG(l,h))
#define MAKELRESULT(l,h) ((LRESULT) MAKELONG(l,h))
#define MAKEPOINTS(l) (*((POINTS *) & (l)))
#define MAKEROP4(fore,back) (DWORD)((((back) << 8) & 0xFF000000) | (fore))
#define MAKEWPARAM(l,h)	((WPARAM) MAKELONG(l,h))
#define PALETTEINDEX(i) ((COLORREF) (0x01000000 | (DWORD) (WORD) (i)))
#define PALETTERGB(r,g,b) (0x02000000 | RGB(r,g,b))
#define POINTSTOPOINT(pt,pts) {(pt).x = (LONG)(SHORT) LOWORD(*(LONG*)&pts); (pt).y = (LONG)(SHORT) HIWORD(*(LONG*)&pts);}
#define POINTTOPOINTS(pt) (MAKELONG((short) ((pt).x),(short) ((pt).y)))
#define INDEXTOOVERLAYMASK(i) ((i) << 8)

typedef int (CALLBACK *BFFCALLBACK) (HWND,UINT,LPARAM,LPARAM);
typedef UINT (CALLBACK *LPCCHOOKPROC) (HWND,UINT,WPARAM,LPARAM);
typedef UINT (CALLBACK *LPCFHOOKPROC) (HWND,UINT,WPARAM,LPARAM);
typedef DWORD (CALLBACK *PTHREAD_START_ROUTINE) (LPVOID);
typedef PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;
typedef UINT (CALLBACK *LPFRHOOKPROC) (HWND,UINT,WPARAM,LPARAM);
typedef UINT (CALLBACK *LPOFNHOOKPROC) (HWND,UINT,WPARAM,LPARAM);
typedef UINT (CALLBACK *LPPRINTHOOKPROC) (HWND,UINT,WPARAM,LPARAM);
typedef UINT (CALLBACK *LPSETUPHOOKPROC) (HWND,UINT,WPARAM,LPARAM);
typedef BOOL (CALLBACK *DLGPROC) (HWND,UINT,WPARAM,LPARAM);
typedef int (CALLBACK *PFNPROPSHEETCALLBACK) (HWND,UINT,LPARAM);
typedef VOID (CALLBACK *LPSERVICE_MAIN_FUNCTION) (DWORD,LPTSTR);
typedef int (CALLBACK *PFNTVCOMPARE) (LPARAM,LPARAM,LPARAM);
typedef LRESULT (CALLBACK *WNDPROC) (HWND,UINT,WPARAM,LPARAM);
typedef int (CALLBACK *FARPROC)(void);
typedef int (WINAPI *PROC)(void);
typedef BOOL (CALLBACK *WNDENUMPROC)(HWND,LPARAM);
typedef BOOL (CALLBACK *ENUMRESTYPEPROCA) (HANDLE,LPSTR,LONG);
typedef BOOL (CALLBACK *ENUMRESTYPEPROCW) (HANDLE,LPWSTR,LONG);
typedef BOOL (CALLBACK *ENUMRESNAMEPROC) (HANDLE,LPCTSTR,LPTSTR,LONG);
typedef BOOL (CALLBACK *ENUMRESLANGPROC) (HANDLE,LPCTSTR,LPCTSTR,WORD,LONG);
typedef BOOL (CALLBACK *ENUMWINDOWSPROC) (HWND,LPARAM);
typedef BOOL (CALLBACK *ENUMWINDOWSTATIONPROC) (LPTSTR,LPARAM);
typedef VOID (CALLBACK *SENDASYNCPROC) (HWND,UINT,DWORD,LRESULT);
typedef VOID (CALLBACK *TIMERPROC) (HWND,UINT,UINT,DWORD);
typedef BOOL (CALLBACK *GRAYSTRINGPROC)(HDC,LPARAM,int);
typedef BOOL (CALLBACK *DRAWSTATEPROC) (HDC,LPARAM,WPARAM,int,int);
typedef BOOL (CALLBACK *PROPENUMPROCEX) (HWND,LPCTSTR,HANDLE,DWORD);
typedef BOOL (CALLBACK *PROPENUMPROC) (HWND,LPCTSTR,HANDLE);
typedef LRESULT (CALLBACK *HOOKPROC) (int,WPARAM,LPARAM);
typedef VOID (CALLBACK *ENUMOBJECTSPROC) (LPVOID,LPARAM);
typedef VOID (CALLBACK *LINEDDAPROC) (int,int,LPARAM);
typedef BOOL (CALLBACK *ABORTPROC) (HDC,int);
typedef UINT (CALLBACK *LPPAGEPAINTHOOK) (HWND,UINT,WPARAM,LPARAM);
typedef UINT (CALLBACK *LPPAGESETUPHOOK) (HWND,UINT,WPARAM,LPARAM);
typedef int (CALLBACK *ICMENUMPROC) (LPTSTR,LPARAM);
typedef LONG (*EDITWORDBREAKPROCEX) (char *,LONG,BYTE,INT);
typedef int (CALLBACK *PFNLVCOMPARE) (LPARAM,LPARAM,LPARAM);
typedef BOOL (CALLBACK *LOCALE_ENUMPROC) (LPTSTR);
typedef BOOL (CALLBACK *CODEPAGE_ENUMPROC) (LPTSTR);
typedef BOOL (CALLBACK *DATEFMT_ENUMPROC) (LPTSTR);
typedef BOOL (CALLBACK *TIMEFMT_ENUMPROC) (LPTSTR);
typedef BOOL (CALLBACK *CALINFO_ENUMPROC) (LPTSTR);
typedef BOOL (CALLBACK *PHANDLER_ROUTINE) (DWORD);
typedef UINT (CALLBACK *PFNGETPROFILEPATH) (LPCTSTR,LPSTR,UINT);
typedef UINT (CALLBACK *PFNRECONCILEPROFILE) (LPCTSTR,LPCTSTR,DWORD);
typedef BOOL (CALLBACK *PFNPROCESSPOLICIES) (HWND,LPCTSTR,LPCTSTR,LPCTSTR,DWORD);
typedef BOOL (CALLBACK* NAMEENUMPROCA)(LPSTR,LPARAM);
typedef BOOL (CALLBACK* NAMEENUMPROCW)(LPWSTR,LPARAM);
typedef NAMEENUMPROCA WINSTAENUMPROCA;
typedef NAMEENUMPROCA DESKTOPENUMPROCA;
typedef NAMEENUMPROCW WINSTAENUMPROCW;
typedef NAMEENUMPROCW DESKTOPENUMPROCW;

#define SECURITY_NULL_SID_AUTHORITY	{0,0,0,0,0,0}
#define SECURITY_WORLD_SID_AUTHORITY	{0,0,0,0,0,1}
#define SECURITY_LOCAL_SID_AUTHORITY	{0,0,0,0,0,2}
#define SECURITY_CREATOR_SID_AUTHORITY	{0,0,0,0,0,3}
#define SECURITY_NON_UNIQUE_AUTHORITY	{0,0,0,0,0,4}
#define SECURITY_NT_AUTHORITY	{0,0,0,0,0,5}
#define SE_CREATE_TOKEN_NAME	TEXT("SeCreateTokenPrivilege")
#define SE_ASSIGNPRIMARYTOKEN_NAME	TEXT("SeAssignPrimaryTokenPrivilege")
#define SE_LOCK_MEMORY_NAME	TEXT("SeLockMemoryPrivilege")
#define SE_INCREASE_QUOTA_NAME	TEXT("SeIncreaseQuotaPrivilege")
#define SE_UNSOLICITED_INPUT_NAME	TEXT("SeUnsolicitedInputPrivilege")
#define SE_MACHINE_ACCOUNT_NAME	TEXT("SeMachineAccountPrivilege")
#define SE_TCB_NAME	TEXT("SeTcbPrivilege")
#define SE_SECURITY_NAME	TEXT("SeSecurityPrivilege")
#define SE_TAKE_OWNERSHIP_NAME	TEXT("SeTakeOwnershipPrivilege")
#define SE_LOAD_DRIVER_NAME	TEXT("SeLoadDriverPrivilege")
#define SE_SYSTEM_PROFILE_NAME	TEXT("SeSystemProfilePrivilege")
#define SE_SYSTEMTIME_NAME	TEXT("SeSystemtimePrivilege")
#define SE_PROF_SINGLE_PROCESS_NAME	TEXT("SeProfileSingleProcessPrivilege")
#define SE_INC_BASE_PRIORITY_NAME	TEXT("SeIncreaseBasePriorityPrivilege")
#define SE_CREATE_PAGEFILE_NAME	TEXT("SeCreatePagefilePrivilege")
#define SE_CREATE_PERMANENT_NAME	TEXT("SeCreatePermanentPrivilege")
#define SE_BACKUP_NAME	TEXT("SeBackupPrivilege")
#define SE_RESTORE_NAME	TEXT("SeRestorePrivilege")
#define SE_SHUTDOWN_NAME	TEXT("SeShutdownPrivilege")
#define SE_DEBUG_NAME	TEXT("SeDebugPrivilege")
#define SE_AUDIT_NAME	TEXT("SeAuditPrivilege")
#define SE_SYSTEM_ENVIRONMENT_NAME	TEXT("SeSystemEnvironmentPrivilege")
#define SE_CHANGE_NOTIFY_NAME	TEXT("SeChangeNotifyPrivilege")
#define SE_REMOTE_SHUTDOWN_NAME	TEXT("SeRemoteShutdownPrivilege")
#define SERVICES_ACTIVE_DATABASEW	L"ServicesActive"
#define SERVICES_FAILED_DATABASEW	L"ServicesFailed"
#define SERVICES_ACTIVE_DATABASEA	"ServicesActive"
#define SERVICES_FAILED_DATABASEA	"ServicesFailed"
#define SC_GROUP_IDENTIFIERW	L'+'
#define SC_GROUP_IDENTIFIERA	'+'
/* Messages.h WIN32 message definitions */
#define ACM_OPENW	1127
#define ACM_OPENA	1124
#define ACM_PLAY	1125
#define ACM_STOP	1126
#define ACN_START	1
#define ACN_STOP	2
#define BM_CLICK	245
#define BM_GETCHECK	240
#define BM_GETIMAGE	246
#define BM_GETSTATE	242
#define BM_SETCHECK	241
#define BM_SETIMAGE	247
#define BM_SETSTATE	243
#define BM_SETSTYLE	244
#define BN_CLICKED	0
#define BN_DBLCLK	5
#define BN_DISABLE	4
#define BN_DOUBLECLICKED	5
#define BN_HILITE	2
#define BN_KILLFOCUS	7
#define BN_PAINT	1
#define BN_PUSHED	2
#define BN_SETFOCUS	6
#define BN_UNHILITE	3
#define BN_UNPUSHED	3
#define CB_ADDSTRING	323
#define CB_DELETESTRING	324
#define CB_DIR	325
#define CB_FINDSTRING	332
#define CB_FINDSTRINGEXACT	344
#define CB_GETCOUNT	326
#define CB_GETCURSEL	327
#define CB_GETDROPPEDCONTROLRECT	338
#define CB_GETDROPPEDSTATE	343
#define CB_GETDROPPEDWIDTH	351
#define CB_GETEDITSEL	320
#define CB_GETEXTENDEDUI	342
#define CB_GETHORIZONTALEXTENT	349
#define CB_GETITEMDATA	336
#define CB_GETITEMHEIGHT	340
#define CB_GETLBTEXT	328
#define CB_GETLBTEXTLEN	329
#define CB_GETLOCALE	346
#define CB_GETTOPINDEX	347
#define CB_INITSTORAGE	353
#define CB_INSERTSTRING	330
#define CB_LIMITTEXT	321
#define CB_RESETCONTENT	331
#define CB_SELECTSTRING	333
#define CB_SETCURSEL	334
#define CB_SETDROPPEDWIDTH	352
#define CB_SETEDITSEL	322
#define CB_SETEXTENDEDUI	341
#define CB_SETHORIZONTALEXTENT	350
#define CB_SETITEMDATA	337
#define CB_SETITEMHEIGHT	339
#define CB_SETLOCALE	345
#define CB_SETTOPINDEX	348
#define CB_SHOWDROPDOWN	335
#define CBN_CLOSEUP	8
#define CBN_DBLCLK	2
#define CBN_DROPDOWN	7
#define CBN_EDITCHANGE	5
#define CBN_EDITUPDATE	6
#define CBN_ERRSPACE	(-1)
#define CBN_KILLFOCUS	4
#define CBN_SELCHANGE	1
#define CBN_SELENDCANCEL	10
#define CBN_SELENDOK	9
#define CBN_SETFOCUS	3
#define DL_BEGINDRAG	1157
#define DL_CANCELDRAG	1160
#define DL_DRAGGING	1158
#define DL_DROPPED	1159
#define DRAGLISTMSGSTRING	TEXT("commctrl_DragListMsg")
#define DM_GETDEFID	1024
#define DM_REPOSITION	1026
#define DM_SETDEFID	1025
#define EM_SETCUEBANNER (ECM_FIRST+1)
#define EM_GETCUEBANNER (ECM_FIRST + 2)
#define EM_SHOWBALLOONTIP (ECM_FIRST + 3)
#define EM_HIDEBALLOONTIP (ECM_FIRST+4)
#define EM_CANPASTE	1074
#define EM_CANUNDO	198
#define EM_CHARFROMPOS	215
#define EM_DISPLAYBAND	1075
#define EM_EMPTYUNDOBUFFER	205
#define EM_EXGETSEL	1076
#define EM_EXLIMITTEXT	1077
#define EM_EXLINEFROMCHAR	1078
#define EM_EXSETSEL	1079
#define EM_FINDTEXT	1080
#define EM_FINDTEXTEX	1103
#define EM_FINDWORDBREAK	1100
#define EM_FMTLINES	200
#define EM_FORMATRANGE	1081
#define EM_GETCHARFORMAT	1082
#define EM_GETEVENTMASK	1083
#define EM_GETFIRSTVISIBLELINE	206
#define EM_GETHANDLE	189
#define EM_GETLIMITTEXT	213
#define EM_GETLINE	196
#define EM_GETLINECOUNT	186
#define EM_GETMARGINS	212
#define EM_GETMODIFY	184
#define EM_GETIMECOLOR	1129
#define EM_GETIMEOPTIONS	1131
#define EM_GETOPTIONS	1102
#define EM_GETOLEINTERFACE	1084
#define EM_GETPARAFORMAT	1085
#define EM_GETPASSWORDCHAR	210
#define EM_GETPUNCTUATION	1125
#define EM_GETRECT	178
#define EM_GETSEL	176
#define EM_GETSELTEXT	1086
#define EM_GETTEXTRANGE	1099
#define EM_GETTHUMB	190
#define EM_GETWORDBREAKPROC	209
#define EM_GETWORDBREAKPROCEX	1104
#define EM_GETWORDWRAPMODE	1127
#define EM_HIDESELECTION	1087
#define EM_LIMITTEXT	197
#define EM_LINEFROMCHAR	201
#define EM_LINEINDEX	187
#define EM_LINELENGTH	193
#define EM_LINESCROLL	182
#define EM_PASTESPECIAL	1088
#define EM_POSFROMCHAR	214
#define EM_REPLACESEL	194
#define EM_REQUESTRESIZE	1089
#define EM_SCROLL	181
#define EM_SCROLLCARET	183
#define EM_SELECTIONTYPE	1090
#define EM_SETBKGNDCOLOR	1091
#define EM_SETCHARFORMAT	1092
#define EM_SETEVENTMASK	1093
#define EM_SETHANDLE	188
#define EM_SETIMECOLOR	1128
#define EM_SETIMEOPTIONS	1130
#define EM_SETLIMITTEXT	197
#define EM_SETMARGINS	211
#define EM_SETMODIFY	185
#define EM_SETOLECALLBACK	1094
#define EM_SETOPTIONS	1101
#define EM_SETPARAFORMAT	1095
#define EM_SETPASSWORDCHAR	204
#define EM_SETPUNCTUATION	1124
#define EM_SETREADONLY	207
#define EM_SETRECT	179
#define EM_SETRECTNP	180
#define EM_SETSEL	177
#define EM_SETTABSTOPS	203
#define EM_SETTARGETDEVICE	1096
#define EM_SETWORDBREAKPROC	208
#define EM_SETWORDBREAKPROCEX	1105
#define EM_SETWORDWRAPMODE	1126
#define EM_STREAMIN	1097
#define EM_STREAMOUT	1098
#define EM_UNDO	199
#define EN_CHANGE	768
#define EN_CORRECTTEXT	1797
#define EN_DROPFILES	1795
#define EN_ERRSPACE	1280
#define EN_HSCROLL	1537
#define EN_IMECHANGE	1799
#define EN_KILLFOCUS	512
#define EN_MAXTEXT	1281
#define EN_MSGFILTER	1792
#define EN_OLEOPFAILED	1801
#define EN_PROTECTED	1796
#define EN_REQUESTRESIZE	1793
#define EN_SAVECLIPBOARD	1800
#define EN_SELCHANGE	1794
#define EN_SETFOCUS	256
#define EN_STOPNOUNDO	1798
#define EN_UPDATE	1024
#define EN_VSCROLL	1538
#define HDM_FIRST	0x1200
#define HDM_DELETEITEM	4610
#define HDM_GETITEMW	4619
#define HDM_INSERTITEMW	4618
#define HDM_SETITEMW	4620
#define HDM_GETITEMA	4611
#define HDM_INSERTITEMA	4609
#define HDM_SETITEMA	4612
#define HDM_GETITEMCOUNT	4608
#define HDM_HITTEST	4614
#define HDM_LAYOUT	4613
#define HDM_SETBITMAPMARGIN (HDM_FIRST + 20)
#define Header_SetBitmapMargin(hwnd, iWidth) (int)SNDMSG((hwnd), HDM_SETBITMAPMARGIN, (WPARAM)(iWidth), 0)
#define HDM_GETBITMAPMARGIN (HDM_FIRST + 21)
#define Header_GetBitmapMargin(hwnd) (int)SNDMSG((hwnd), HDM_GETBITMAPMARGIN, 0, 0)
#define HDM_SETFILTERCHANGETIMEOUT (HDM_FIRST+22)
#define Header_SetFilterChangeTimeout(hwnd, i) (int)SNDMSG((hwnd), HDM_SETFILTERCHANGETIMEOUT, 0, (LPARAM)(i))
#define HDM_EDITFILTER	(HDM_FIRST+23)
#define Header_EditFilter(h,i,f) (int)SNDMSG((h),HDM_EDITFILTER,(WPARAM)(i),MAKELPARAM(f,0))
#define HDM_CLEARFILTER	(HDM_FIRST+24)
#define Header_ClearFilter(h,i) (int)SNDMSG((h), HDM_CLEARFILTER, (WPARAM)(i),0)
#define Header_ClearAllFilters(hwnd) (int)SNDMSG((hwnd), HDM_CLEARFILTER, (WPARAM)-1, 0)
#define HDM_GETITEMRECT	(HDM_FIRST+7)
#define Header_GetItemRect(h,I,lprc) (BOOL)SendMessage((h), HDM_GETITEMRECT, (WPARAM)(I),(LPARAM)(lprc))
#define HDM_SETIMAGELIST	(HDM_FIRST+8)
#define Header_SetImageList(h,himl) (HIMAGELIST)SendMessage((h),HDM_SETIMAGELIST,0,(LPARAM)(himl))
#define HDM_GETIMAGELIST	(HDM_FIRST+9)
#define Header_GetImageList(h) (HIMAGELIST)SendMessage((h),HDM_GETIMAGELIST,0,0)
#define HDM_ORDERTOINDEX	(HDM_FIRST+15)
#define Header_OrderToIndex(hwnd, i) (int)SendMessage((hwnd), HDM_ORDERTOINDEX, (WPARAM)(i), 0)
#define HDM_CREATEDRAGIMAGE	(HDM_FIRST+16)
#define Header_CreateDragImage(h,i) (HIMAGELIST)SendMessage((h),HDM_CREATEDRAGIMAGE,(WPARAM)(i),0)
#define HDM_GETORDERARRAY	(HDM_FIRST+17)
#define Header_GetOrderArray(h,C,i) (BOOL)SendMessage((h),HDM_GETORDERARRAY,(WPARAM)(C),(LPARAM)(i))
#define HDM_SETORDERARRAY	(HDM_FIRST+18)
#define Header_SetOrderArray(h,C,lpi) (BOOL)SendMessage((h), HDM_SETORDERARRAY, (WPARAM)(C),(LPARAM)(lpi))
#define HDM_SETHOTDIVIDER	(HDM_FIRST+19)
#define Header_SetHotDivider(h,P,dw) (int)SendMessage((h),HDM_SETHOTDIVIDER,(WPARAM)(P),(LPARAM)(dw))
#define HDN_BEGINTRACKW	(-326)
#define HDN_DIVIDERDBLCLICKW	(-325)
#define HDN_ENDTRACKW	(-327)
#define HDN_ITEMCHANGEDW	(-321)
#define HDN_ITEMCHANGINGW	(-320)
#define HDN_ITEMCLICKW	(-322)
#define HDN_ITEMDBLCLICKW	(-323)
#define HDN_TRACKW	(-328)
#define HDN_BEGINTRACKA	(-306)
#define HDN_DIVIDERDBLCLICKA	(-305)
#define HDN_ENDTRACKA	(-307)
#define HDN_ITEMCHANGEDA	(-301)
#define HDN_ITEMCHANGINGA	(-300)
#define HDN_ITEMCLICKA	(-302)
#define HDN_ITEMDBLCLICKA	(-303)
#define HDN_TRACKA	(-308)
#define HDN_GETDISPINFOA	(HDN_FIRST-9)
#define HDN_GETDISPINFOW	(HDN_FIRST-29)
#define HDN_BEGINDRAG	(HDN_FIRST-10)
#define HDN_ENDDRAG	(HDN_FIRST-11)
#define HDN_FILTERCHANGE (HDN_FIRST-12)
#define HDN_FILTERBTNCLICK (HDN_FIRST-13)
#define HD_NOTIFYA NMHEADERA
#define HD_NOTIFYW NMHEADERW
#define HKM_GETHOTKEY	1026
#define HKM_SETHOTKEY	1025
#define HKM_SETRULES	1027
#define LB_ADDFILE	406
#define LB_ADDSTRING	384
#define LB_DELETESTRING	386
#define LB_DIR	397
#define LB_FINDSTRING	399
#define LB_FINDSTRINGEXACT	418
#define LB_GETANCHORINDEX	413
#define LB_GETCARETINDEX	415
#define LB_GETCOUNT	395
#define LB_GETCURSEL	392
#define LB_GETHORIZONTALEXTENT	403
#define LB_GETITEMDATA	409
#define LB_GETITEMHEIGHT	417
#define LB_GETITEMRECT	408
#define LB_GETLOCALE	422
#define LB_GETSEL	391
#define LB_GETSELCOUNT	400
#define LB_GETSELITEMS	401
#define LB_GETTEXT	393
#define LB_GETTEXTLEN	394
#define LB_GETTOPINDEX	398
#define LB_INITSTORAGE	424
#define LB_INSERTSTRING	385
#define LB_ITEMFROMPOINT	425
#define LB_RESETCONTENT	388
#define LB_SELECTSTRING	396
#define LB_SELITEMRANGE	411
#define LB_SELITEMRANGEEX	387
#define LB_SETANCHORINDEX	412
#define LB_SETCARETINDEX	414
#define LB_SETCOLUMNWIDTH	405
#define LB_SETCOUNT	423
#define LB_SETCURSEL	390
#define LB_SETHORIZONTALEXTENT	404
#define LB_SETITEMDATA	410
#define LB_SETITEMHEIGHT	416
#define LB_SETLOCALE	421
#define LB_SETSEL	389
#define LB_SETTABSTOPS	402
#define LB_SETTOPINDEX	407
#define LBN_DBLCLK	2
#define LBN_ERRSPACE	(-2)
#define LBN_KILLFOCUS	5
#define LBN_SELCANCEL	3
#define LBN_SELCHANGE	1
#define LBN_SETFOCUS	4
#define LVM_FIRST	0x1000
#define	LVM_APPROXIMATEVIEWRECT	(LVM_FIRST+64)
#define	LVM_ARRANGE	(LVM_FIRST+22)
#define	LVM_CANCELEDITLABEL	(LVM_FIRST+179)
#define	LVM_CREATEDRAGIMAGE	(LVM_FIRST+33)
#define	LVM_DELETEALLITEMS	(LVM_FIRST+9)
#define	LVM_DELETECOLUMN	(LVM_FIRST+28)
#define	LVM_DELETEITEM	(LVM_FIRST+8)
#define	LVM_EDITLABELA	(LVM_FIRST+23)
#define	LVM_EDITLABELW	(LVM_FIRST+118)
#define	LVM_ENABLEGROUPVIEW	(LVM_FIRST+157)
#define	LVM_ENSUREVISIBLE	(LVM_FIRST+19)
#define	LVM_FINDITEMA	(LVM_FIRST+13)
#define	LVM_FINDITEMW	(LVM_FIRST+83)
#define	LVM_GETBKCOLOR	(LVM_FIRST+0)
#define	LVM_GETBKIMAGEA	(LVM_FIRST+69)
#define	LVM_GETBKIMAGEW	(LVM_FIRST+139)
#define	LVM_GETCALLBACKMASK	(LVM_FIRST+10)
#define	LVM_GETCOLUMNA	(LVM_FIRST+25)
#define	LVM_GETCOLUMNORDERARRAY	(LVM_FIRST+59)
#define	LVM_GETCOLUMNW	(LVM_FIRST+95)
#define	LVM_GETCOLUMNWIDTH	(LVM_FIRST+29)
#define	LVM_GETCOUNTPERPAGE	(LVM_FIRST+40)
#define	LVM_GETEDITCONTROL	(LVM_FIRST+24)
#define	LVM_GETEXTENDEDLISTVIEWSTYLE	(LVM_FIRST+55)
#define	LVM_GETGROUPINFO	(LVM_FIRST+149)
#define	LVM_GETGROUPMETRICS	(LVM_FIRST+156)
#define	LVM_GETHEADER	(LVM_FIRST+31)
#define	LVM_GETHOTCURSOR	(LVM_FIRST+63)
#define	LVM_GETHOTITEM	(LVM_FIRST+61)
#define	LVM_GETHOVERTIME	(LVM_FIRST+72)
#define	LVM_GETIMAGELIST	(LVM_FIRST+2)
#define	LVM_GETINSERTMARK	(LVM_FIRST+167)
#define	LVM_GETINSERTMARKCOLOR	(LVM_FIRST+171)
#define	LVM_GETINSERTMARKRECT	(LVM_FIRST+169)
#define	LVM_GETISEARCHSTRINGA	(LVM_FIRST+52)
#define	LVM_GETISEARCHSTRINGW	(LVM_FIRST+117)
#define	LVM_GETITEMA	(LVM_FIRST+5)
#define	LVM_GETITEMCOUNT	(LVM_FIRST+4)
#define	LVM_GETITEMPOSITION	(LVM_FIRST+16)
#define	LVM_GETITEMRECT	(LVM_FIRST+14)
#define	LVM_GETITEMSPACING	(LVM_FIRST+51)
#define	LVM_GETITEMSTATE	(LVM_FIRST+44)
#define	LVM_GETITEMTEXTA	(LVM_FIRST+45)
#define	LVM_GETITEMTEXTW	(LVM_FIRST+115)
#define	LVM_GETITEMW	(LVM_FIRST+75)
#define	LVM_GETNEXTITEM	(LVM_FIRST+12)
#define	LVM_GETNUMBEROFWORKAREAS	(LVM_FIRST+73)
#define	LVM_GETORIGIN	(LVM_FIRST+41)
#define	LVM_GETOUTLINECOLOR	(LVM_FIRST+176)
#define	LVM_GETSELECTEDCOLUMN	(LVM_FIRST+174)
#define	LVM_GETSELECTEDCOUNT	(LVM_FIRST+50)
#define	LVM_GETSELECTIONMARK	(LVM_FIRST+66)
#define	LVM_GETSTRINGWIDTHA	(LVM_FIRST+17)
#define	LVM_GETSTRINGWIDTHW	(LVM_FIRST+87)
#define	LVM_GETSUBITEMRECT	(LVM_FIRST+56)
#define	LVM_GETTEXTBKCOLOR	(LVM_FIRST+37)
#define	LVM_GETTEXTCOLOR	(LVM_FIRST+35)
#define	LVM_GETTILEINFO	(LVM_FIRST+165)
#define	LVM_GETTILEVIEWINFO	(LVM_FIRST+163)
#define	LVM_GETTOOLTIPS	(LVM_FIRST+78)
#define	LVM_GETTOPINDEX	(LVM_FIRST+39)
#define	LVM_GETVIEW	(LVM_FIRST+143)
#define	LVM_GETVIEWRECT	(LVM_FIRST+34)
#define	LVM_GETWORKAREAS	(LVM_FIRST+70)
#define	LVM_HASGROUP	(LVM_FIRST+161)
#define	LVM_HITTEST	(LVM_FIRST+18)
#define	LVM_INSERTCOLUMNA	(LVM_FIRST+27)
#define	LVM_INSERTCOLUMNW	(LVM_FIRST+97)
#define	LVM_INSERTGROUP	(LVM_FIRST+145)
#define	LVM_INSERTGROUPSORTED	(LVM_FIRST+159)
#define	LVM_INSERTITEMA	(LVM_FIRST+7)
#define	LVM_INSERTITEMW	(LVM_FIRST+77)
#define	LVM_INSERTMARKHITTEST	(LVM_FIRST+168)
#define	LVM_ISGROUPVIEWENABLED	(LVM_FIRST+175)
#define	LVM_MAPIDTOINDEX	(LVM_FIRST+181)
#define	LVM_MAPINDEXTOID	(LVM_FIRST+180)
#define	LVM_MOVEGROUP	(LVM_FIRST+151)
#define	LVM_MOVEITEMTOGROUP	(LVM_FIRST+154)
#define	LVM_REDRAWITEMS	(LVM_FIRST+21)
#define	LVM_REMOVEALLGROUPS	(LVM_FIRST+160)
#define	LVM_REMOVEGROUP	(LVM_FIRST+150)
#define	LVM_SCROLL	(LVM_FIRST+20)
#define	LVM_SETBKCOLOR	(LVM_FIRST+1)
#define	LVM_SETBKIMAGEA	(LVM_FIRST+68)
#define	LVM_SETBKIMAGEW	(LVM_FIRST+138)
#define	LVM_SETCALLBACKMASK	(LVM_FIRST+11)
#define	LVM_SETCOLUMNA	(LVM_FIRST+26)
#define	LVM_SETCOLUMNORDERARRAY	(LVM_FIRST+58)
#define	LVM_SETCOLUMNW	(LVM_FIRST+96)
#define	LVM_SETCOLUMNWIDTH	(LVM_FIRST+30)
#define	LVM_SETEXTENDEDLISTVIEWSTYLE	(LVM_FIRST+54)
#define	LVM_SETGROUPINFO	(LVM_FIRST+147)
#define	LVM_SETGROUPMETRICS	(LVM_FIRST+155)
#define	LVM_SETHOTCURSOR	(LVM_FIRST+62)
#define	LVM_SETHOTITEM	(LVM_FIRST+60)
#define	LVM_SETHOVERTIME	(LVM_FIRST+71)
#define	LVM_SETICONSPACING	(LVM_FIRST+53)
#define	LVM_SETIMAGELIST	(LVM_FIRST+3)
#define	LVM_SETINFOTIP	(LVM_FIRST+173)
#define	LVM_SETINSERTMARK	(LVM_FIRST+166)
#define	LVM_SETINSERTMARKCOLOR	(LVM_FIRST+170)
#define	LVM_SETITEMA	(LVM_FIRST+6)
#define	LVM_SETITEMCOUNT	(LVM_FIRST+47)
#define	LVM_SETITEMPOSITION	(LVM_FIRST+15)
#define	LVM_SETITEMPOSITION32	(LVM_FIRST+49)
#define	LVM_SETITEMSTATE	(LVM_FIRST+43)
#define	LVM_SETITEMTEXTA	(LVM_FIRST+46)
#define	LVM_SETITEMTEXTW	(LVM_FIRST+116)
#define	LVM_SETITEMW	(LVM_FIRST+76)
#define	LVM_SETOUTLINECOLOR	(LVM_FIRST+177)
#define	LVM_SETSELECTEDCOLUMN	(LVM_FIRST+140)
#define	LVM_SETSELECTIONMARK	(LVM_FIRST+67)
#define	LVM_SETTEXTBKCOLOR	(LVM_FIRST+38)
#define	LVM_SETTEXTCOLOR	(LVM_FIRST+36)
#define	LVM_SETTILEINFO	(LVM_FIRST+164)
#define	LVM_SETTILEVIEWINFO	(LVM_FIRST+162)
#define	LVM_SETTILEWIDTH	(LVM_FIRST+141)
#define	LVM_SETTOOLTIPS	(LVM_FIRST+74)
#define	LVM_SETVIEW	(LVM_FIRST+142)
#define	LVM_SETWORKAREAS	(LVM_FIRST+65)
#define	LVM_SORTGROUPS	(LVM_FIRST+158)
#define	LVM_SORTITEMS	(LVM_FIRST+48)
#define	LVM_SORTITEMSEX	(LVM_FIRST+81)
#define	LVM_SUBITEMHITTEST	(LVM_FIRST+57)
#define	LVM_UPDATE	(LVM_FIRST+42)
#define LVM_GETUNICODEFORMAT CCM_GETUNICODEFORMAT
#define LVM_SETUNICODEFORMAT CCM_SETUNICODEFORMAT
#define LVN_BEGINDRAG	(-109)
#define LVN_BEGINRDRAG	(-111)
#define LVN_COLUMNCLICK	(-108)
#define LVN_DELETEALLITEMS	(-104)
#define LVN_DELETEITEM	(-103)
#define LVN_BEGINLABELEDITW	(-175)
#define LVN_ENDLABELEDITW	(-176)
#define LVN_GETDISPINFOW	(-177)
#define LVN_SETDISPINFOW	(-178)
#define LVN_BEGINLABELEDITA	(-105)
#define LVN_ENDLABELEDITA	(-106)
#define LVN_GETDISPINFOA	(-150)
#define LVN_SETDISPINFOA	(-151)
#define LVN_INSERTITEM	(-102)
#define LVN_ITEMCHANGED	(-101)
#define LVN_ITEMCHANGING	(-100)
#define LVN_KEYDOWN	(-155)
#define LVN_ODCACHEHINT (-113)
#define LVN_ODFINDITEMA (-152)
#define LVN_ODFINDITEMW (-179)
#define LVN_ODSTATECHANGED (-115)
#define LVN_ITEMACTIVATE	(LVN_FIRST-14)
#define LV_MAX_WORKAREAS	16
#define LV_VIEW_ICON	0
#define LV_VIEW_DETAILS	1
#define LV_VIEW_SMALLICON	2
#define LV_VIEW_LIST	3
#define LV_VIEW_TILE	4
#define LV_VIEW_MAX	4
#define LVGF_NONE 0
#define LVGF_HEADER	1
#define LVGF_FOOTER	2
#define LVGF_STATE	4
#define LVGF_ALIGN	8
#define LVGF_GROUPID	0x10
#define LVGS_NORMAL	0
#define LVGS_COLLAPSED	1
#define LVGS_HIDDEN	2
#define LVGA_HEADER_LEFT 1
#define LVGA_HEADER_CENTER 2
#define LVGA_HEADER_RIGHT 4
#define LVGA_FOOTER_LEFT 8
#define LVGA_FOOTER_CENTER 16
#define LVGA_FOOTER_RIGHT 32
#define LVGMF_NONE 0
#define LVGMF_BORDERSIZE 1
#define LVGMF_BORDERCOLOR 2
#define LVGMF_TEXTCOLOR 4
#define LVTVIF_AUTOSIZE 0
#define LVTVIF_FIXEDWIDTH 1
#define LVTVIF_FIXEDHEIGHT 2
#define LVTVIF_FIXEDSIZE 3
#define LVTVIM_TILESIZE 1
#define LVTVIM_COLUMNS 2
#define LVTVIM_LABELMARGIN 4
#define LVIM_AFTER 1
#define LVM_SETWORKAREAS	(LVM_FIRST+65)
#define LVM_GETWORKAREAS	(LVM_FIRST+70)
#define LVM_GETNUMBEROFWORKAREAS	(LVM_FIRST+73)
#define LVM_GETSELECTIONMARK	(LVM_FIRST+66)
#define LVM_SETSELECTIONMARK	(LVM_FIRST+67)
#define LVM_SETHOVERTIME	(LVM_FIRST+71)
#define LVM_GETHOVERTIME	(LVM_FIRST+72)
#define LVM_SETTOOLTIPS	(LVM_FIRST+74)
#define LVM_GETTOOLTIPS	(LVM_FIRST+78)
#define LVM_SORTITEMSEX	(LVM_FIRST+81)
#define LVBKIF_SOURCE_NONE	0
#define LVBKIF_SOURCE_HBITMAP	1
#define LVBKIF_SOURCE_URL	2
#define LVBKIF_SOURCE_MASK	3
#define LVBKIF_STYLE_NORMAL	0
#define LVBKIF_STYLE_TILE	16
#define LVBKIF_STYLE_MASK	16
#define LVBKIF_FLAG_TILEOFFSET	0x00000100
#define LVBKIF_TYPE_WATERMARK	0x10000000
#define LVM_SETBKIMAGEA		(LVM_FIRST+68)
#define LVM_SETBKIMAGEW		(LVM_FIRST+138)
#define LVM_GETBKIMAGEA		(LVM_FIRST+69)
#define LVM_GETBKIMAGEW		(LVM_FIRST+139)
#define LVKF_ALT	1
#define LVKF_CONTROL	2
#define LVKF_SHIFT	4

#ifdef UNICODE
#define ENUMRESTYPEPROC	ENUMRESTYPEPROCW
#define LVBKIMAGE	LVBKIMAGEW
#define LPLVBKIMAGE	LPLVBKIMAGEW
#define LVM_SETBKIMAGE	LVM_SETBKIMAGEW
#define LVM_GETBKIMAGE	LVM_GETBKIMAGEW
#define GetWindowModuleFileName GetWindowModuleFileNameW
#define NMTOOLBAR	NMTOOLBARW
#define LPNMTOOLBAR	LPNMTOOLBARW
#define TCITEMHEADER	TCITEMHEADERW
#define LPTCITEMHEADER	LPTCITEMHEADERW
#else
#define ENUMRESTYPEPROC	ENUMRESTYPEPROCA
#define LVBKIMAGE	LVBKIMAGEA
#define LPLVBKIMAGE	LPLVBKIMAGEA
#define LVM_SETBKIMAGE	LVM_SETBKIMAGEA
#define LVM_GETBKIMAGE	LVM_GETBKIMAGEA
#define GetWindowModuleFileName GetWindowModuleFileNameA
#define NMTOOLBAR	NMTOOLBARA
#define LPNMTOOLBAR	LPNMTOOLBARA
#define TCITEMHEADER	TCITEMHEADERA
#define LPTCITEMHEADER	LPTCITEMHEADERA
#endif

#define NM_CLICK	(-2)
#define NM_DBLCLK	(-3)
#define NM_KILLFOCUS	(-8)
#define NM_OUTOFMEMORY	(-1)
#define NM_RCLICK	(-5)
#define NM_RDBLCLK	(-6)
#define NM_RETURN	(-4)
#define NM_SETFOCUS	(-7)
#define NM_KILLFOCUS	(-8)
#define NM_CUSTOMDRAW	(-12)
#define NM_HOVER	(-13)
#define NM_NCHITTEST	(-14)
#define NM_KEYDOWN	(-15)
#define NM_RELEASEDCAPTURE (-16)
#define NM_SETCURSOR	(-17)
#define NM_CHAR		(-18)
#define NM_TOOLTIPSCREATED (-19)
#define NM_LDOWN	(-20)
#define NM_THEMECHANGED (-22)
#define NM_RDOWN	(-21)
#define NM_FIRST	0
#define NM_UPDOWN	NMUPDOWN
#define LPNM_UPDOWN	LPNMUPDOWN
#define PBM_DELTAPOS	1027
#define PBM_SETPOS	1026
#define PBM_SETRANGE	1025
#define PBM_SETSTEP	1028
#define PBM_STEPIT	1029
#define PSM_ADDPAGE	1127
#define PSM_APPLY	1134
#define PSM_CANCELTOCLOSE	1131
#define PSM_CHANGED	1128
#define PSM_GETTABCONTROL	1140
#define PSM_GETCURRENTPAGEHWND	1142
#define PSM_ISDIALOGMESSAGE	1141
#define PSM_PRESSBUTTON	1137
#define PSM_QUERYSIBLINGS	1132
#define PSM_REBOOTSYSTEM	1130
#define PSM_REMOVEPAGE	1126
#define PSM_RESTARTWINDOWS	1129
#define PSM_SETCURSEL	1125
#define PSM_SETCURSELID	1138
#define PSM_SETFINISHTEXTW	1145
#define PSM_SETTITLEW	1144
#define PSM_SETFINISHTEXTA	1139
#define PSM_SETTITLEA	1135
#define PSM_SETWIZBUTTONS	1136
#define PSM_UNCHANGED	1133
#define PSN_APPLY	(-202)
#define PSN_HELP	(-205)
#define PSN_KILLACTIVE	(-201)
#define PSN_QUERYCANCEL	(-209)
#define PSN_RESET	(-203)
#define PSN_SETACTIVE	(-200)
#define PSN_WIZBACK	(-206)
#define PSN_WIZFINISH	(-208)
#define PSN_WIZNEXT	(-207)
#define SB_GETBORDERS	1031
#define SB_GETPARTS	1030
#define SB_GETRECT	1034
#define SB_GETTEXTW	1037
#define SB_GETTEXTLENGTHW	1036
#define SB_SETTEXTW	1035
#define SB_GETTEXTA	1026
#define SB_GETTEXTLENGTHA	1027
#define SB_SETTEXTA	1025
#define SB_SETMINHEIGHT	1032
#define SB_SETPARTS	1028
#define SB_SIMPLE	1033
#define SBM_ENABLE_ARROWS	228
#define SBM_GETPOS	225
#define SBM_GETRANGE	227
#define SBM_GETSCROLLINFO	234
#define SBM_SETPOS	224
#define SBM_SETRANGE	226
#define SBM_SETRANGEREDRAW	230
#define SBM_SETSCROLLINFO	233
#define STM_GETICON	369
#define STM_GETIMAGE	371
#define STM_SETICON	368
#define STM_SETIMAGE	370
#define STN_CLICKED	0
#define STN_DBLCLK	1
#define STN_DISABLE	3
#define STN_ENABLE	2
#define TB_ADDBITMAP	1043
#define TB_ADDBUTTONS	1044
#define TB_AUTOSIZE	1057
#define TB_BUTTONCOUNT	1048
#define TB_BUTTONSTRUCTSIZE	1054
#define TB_CHANGEBITMAP	1067
#define TB_CHECKBUTTON	1026
#define TB_COMMANDTOINDEX	1049
#define TB_CUSTOMIZE	1051
#define TB_DELETEBUTTON	1046
#define TB_ENABLEBUTTON	1025
#define TB_GETBITMAP	1068
#define TB_GETBITMAPFLAGS	1065
#define TB_GETBUTTON	1047
#define TB_ADDSTRINGW	1101
#define TB_GETBUTTONTEXTW	1099
#define TB_SAVERESTOREW	1100
#define TB_ADDSTRINGA	1052
#define TB_GETBUTTONTEXTA	1069
#define TB_SAVERESTOREA	1050
#define TB_GETITEMRECT	1053
#define TB_GETROWS	1064
#define TB_GETSTATE	1042
#define TB_GETTOOLTIPS	1059
#define TB_HIDEBUTTON	1028
#define TB_INDETERMINATE	1029
#define TB_INSERTBUTTON	1045
#define TB_INSERTBUTTONW	(WM_USER+67)
#define TB_ADDBUTTONSW	(WM_USER+68)
#define TB_HITTEST	(WM_USER+69)
#define TB_ISBUTTONCHECKED	1034
#define TB_ISBUTTONENABLED	1033
#define TB_ISBUTTONHIDDEN	1036
#define TB_ISBUTTONINDETERMINATE	1037
#define TB_ISBUTTONPRESSED	1035
#define TB_PRESSBUTTON	1027
#define TB_SETBITMAPSIZE	1056
#define TB_SETBUTTONSIZE	1055
#define TB_SETCMDID	1066
#define TB_SETPARENT	1061
#define TB_SETROWS	1063
#define TB_SETSTATE	1041
#define TB_SETTOOLTIPS	1060
#define TB_HITTEST	(WM_USER+69)
#define TB_REPLACEBITMAP (WM_USER+46)
#define TB_SETINDENT	(WM_USER+47)
#define TB_SETIMAGELIST	(WM_USER+48)
#define TB_GETIMAGELIST	(WM_USER+49)
#define TB_LOADIMAGES	(WM_USER+50)
#define TB_GETRECT	(WM_USER+51)
#define TB_SETHOTIMAGELIST	(WM_USER+52)
#define TB_GETHOTIMAGELIST	(WM_USER+53)
#define TB_SETDISABLEDIMAGELIST (WM_USER+54)
#define TB_GETDISABLEDIMAGELIST	(WM_USER+55)
#define TB_SETSTYLE	(WM_USER+56)
#define TB_GETSTYLE	(WM_USER+57)
#define TB_GETBUTTONSIZE	(WM_USER+58)
#define TB_SETBUTTONWIDTH	(WM_USER+59)
#define TB_SETMAXTEXTROWS	(WM_USER+60)
#define TB_GETTEXTROWS	(WM_USER+61)
#define TB_GETINSERTMARK	(WM_USER+79)
#define TB_SETINSERTMARK	(WM_USER+80)
#define TB_INSERTMARKHITTEST	(WM_USER+81)
#define TB_MOVEBUTTON		(WM_USER+82)
#define TB_GETMAXSIZE		(WM_USER+83)
#define TB_SETEXTENDEDSTYLE	(WM_USER+84)
#define TB_GETEXTENDEDSTYLE	(WM_USER+85)
#define TB_GETPADDING		(WM_USER+86)
#define TB_SETPADDING		(WM_USER+87)
#define TB_SETINSERTMARKCOLOR	(WM_USER+88)
#define TB_GETINSERTMARKCOLOR	(WM_USER+89)
#define TB_SETCOLORSCHEME	CCM_SETCOLORSCHEME
#define TB_GETCOLORSCHEME	CCM_GETCOLORSCHEME
#define TB_SETUNICODEFORMAT	CCM_SETUNICODEFORMAT
#define TB_GETUNICODEFORMAT	CCM_GETUNICODEFORMAT
#define TB_MAPACCELERATORW	(WM_USER+90)
#define TB_ADDBUTTONSA		(WM_USER + 20)
#define TB_INSERTBUTTONA	(WM_USER + 21)
#define TB_GETOBJECT		(WM_USER + 62)
#define TB_GETHOTITEM		(WM_USER + 71)
#define TB_SETHOTITEM		(WM_USER + 72)
#define TB_SETANCHORHIGHLIGHT	(WM_USER + 73)
#define TB_GETANCHORHIGHLIGHT	(WM_USER + 74)
#define TB_GETBUTTONINFOW	(WM_USER + 63)
#define TB_SETBUTTONINFOW	(WM_USER + 64)
#define TB_SETDRAWTEXTFLAGS	(WM_USER + 70)
#define TB_GETSTRINGW		(WM_USER + 91)
#define TB_GETSTRINGA		(WM_USER + 92)
#define TB_GETMETRICS		(WM_USER + 101)
#define TB_SETMETRICS		(WM_USER + 102)
#define TB_SETWINDOWTHEME     CCM_SETWINDOWTHEME
#define TBNF_IMAGE	1
#define TBNF_TEXT	2
#define TBNF_DI_SETITEM 0x10000000
#define HICF_OTHER	0
#define HICF_MOUSE	1
#define HICF_ARROWKEYS	2
#define HICF_ACCELERATOR 4
#define HICF_DUPACCEL	8
#define HICF_ENTERING	0x10
#define HICF_LEAVING	0x20
#define HICF_RESELECT	0x40
#define HICF_LMOUSE	0x80
#define HICF_TOGGLEDROPDOWN 0x100
#define WMN_FIRST	(0U-1000U)
#define WMN_LAST	(0U-1200U)
#define BCN_FIRST	(0U-1250U)
#define BCN_HOTITEMCHANGE (BCN_FIRST + 0x0001)
#define BCN_LAST	(0U-1350U)
#define BST_HOT 0x0200
#define MSGF_COMMCTRL_BEGINDRAG	0x4200
#define CDIS_SHOWKEYBOARDCUES	0x0200
#define MSGF_COMMCTRL_SIZEHEADER	0x4201
#define MSGF_COMMCTRL_DRAGSELECT	0x4202
#define MSGF_COMMCTRL_TOOLBARCUST	0x4203

#ifdef UNICODE
#define TB_GETSTRING TB_GETSTRINGW
#define TB_MAPACCELERATOR	TB_MAPACCELERATORW
#else
#define TB_GETSTRING TB_GETSTRINGA
#define TB_MAPACCELERATOR	TB_MAPACCELERATORA
#endif

#define TBMF_PAD 1
#define TBMF_BARPAD 2
#define TBMF_BUTTONSPACING 4
#define TBBF_LARGE	1
#define TBIF_IMAGE	1
#define TBIF_TEXT	2
#define TBIF_STATE	4
#define TBIF_STYLE	8
#define TBIF_LPARAM	16
#define TBIF_COMMAND	32
#define TBIF_SIZE	64
#define TBIF_BYINDEX	0x80000000
#define PGS_VERT	0
#define PGS_HORZ	1
#define PGS_AUTOSCROLL	2
#define PGS_DRAGNDROP	4
#define PGF_INVISIBLE	0
#define PGF_NORMAL	1
#define PGF_GRAYED	2
#define PGF_DEPRESSED	4
#define PGF_HOT	8
#define PGB_TOPORLEFT	0
#define PGB_BOTTOMORRIGHT 1
#define PGM_SETCHILD	(PGM_FIRST+1)
#define Pager_SetChild(h,C) (void)SendMsg((h),PGM_SETCHILD,0,(LPARAM)(C))
#define PGM_RECALCSIZE	(PGM_FIRST+2)
#define Pager_RecalcSize(hwnd) (void)SendMessage((hwnd),PGM_RECALCSIZE,0,0)
#define PGM_FORWARDMOUSE	(PGM_FIRST+3)
#define Pager_ForwardMouse(hwnd,F) (void)SendMessage((hwnd), PGM_FORWARDMOUSE, (WPARAM)(F),0)
#define PGM_SETBKCOLOR	(PGM_FIRST+4)
#define Pager_SetBkColor(h,c) (COLORREF)SendMessage((h),PGM_SETBKCOLOR,0,(LPARAM)(c))
#define PGM_GETBKCOLOR	(PGM_FIRST+5)
#define Pager_GetBkColor(h) (COLORREF)SendMessage((h),PGM_GETBKCOLOR,0,0)
#define PGM_SETBORDER	(PGM_FIRST+6)
#define Pager_SetBorder(h,B) (int)SNDMSG((h),PGM_SETBORDER,0,(LPARAM)(B))
#define PGM_GETBORDER	(PGM_FIRST+7)
#define Pager_GetBorder(hwnd) (int)SNDMSG((hwnd),PGM_GETBORDER,0,0)
#define PGM_SETPOS	(PGM_FIRST+8)
#define Pager_SetPos(hwnd, iPos) (int)SNDMSG((hwnd),PGM_SETPOS,0,(LPARAM)(iPos))
#define PGM_GETPOS	(PGM_FIRST+9)
#define Pager_GetPos(hwnd) (int)SNDMSG((hwnd),PGM_GETPOS,0,0)
#define PGM_SETBUTTONSIZE	(PGM_FIRST+10)
#define Pager_SetButtonSize(hwnd, iSize) (int)SNDMSG((hwnd), PGM_SETBUTTONSIZE, 0, (LPARAM)(iSize))
#define PGM_GETBUTTONSIZE	(PGM_FIRST+11)
#define Pager_GetButtonSize(hwnd) (int)SNDMSG((hwnd),PGM_GETBUTTONSIZE, 0,0)
#define PGM_GETBUTTONSTATE	(PGM_FIRST+12)
#define Pager_GetButtonState(hwnd, iButton) (DWORD)SNDMSG((hwnd), PGM_GETBUTTONSTATE, 0, (LPARAM)(iButton))
#define PGM_GETDROPTARGET	CCM_GETDROPTARGET
#define Pager_GetDropTarget(h,t) (void)SNDMSG((h),PGM_GETDROPTARGET,0,(LPARAM)(t))
#define PGN_SCROLL	(PGN_FIRST-1)
#define PGN_CALCSIZE	(PGN_FIRST-2)
#define PGF_CALCWIDTH	1
#define PGF_CALCHEIGHT	2
#define PGF_SCROLLUP	1
#define PGF_SCROLLDOWN	2
#define PGF_SCROLLLEFT	4
#define PGF_SCROLLRIGHT	8
#define PGK_SHIFT	1
#define PGK_CONTROL	2
#define PGK_MENU	4
#define TBM_CLEARSEL	1043
#define TBM_CLEARTICS	1033
#define TBM_GETCHANNELRECT	1050
#define TBM_GETLINESIZE	1048
#define TBM_GETNUMTICS	1040
#define TBM_GETPAGESIZE	1046
#define TBM_GETPOS	1024
#define TBM_GETPTICS	1038
#define TBM_GETRANGEMAX	1026
#define TBM_GETRANGEMIN	1025
#define TBM_GETSELEND	1042
#define TBM_GETSELSTART	1041
#define TBM_GETTHUMBLENGTH	1052
#define TBM_GETTHUMBRECT	1049
#define TBM_GETTIC	1027
#define TBM_GETTICPOS	1039
#define TBM_SETLINESIZE	1047
#define TBM_SETPAGESIZE	1045
#define TBM_SETPOS	1029
#define TBM_SETRANGE	1030
#define TBM_SETRANGEMAX	1032
#define TBM_SETRANGEMIN	1031
#define TBM_SETSEL	1034
#define TBM_SETSELEND	1036
#define TBM_SETSELSTART	1035
#define TBM_SETTHUMBLENGTH	1051
#define TBM_SETTIC	1028
#define TBM_SETTICFREQ	1044
#define TBM_GETUNICODEFORMAT CCM_GETUNICODEFORMAT
#define TBM_SETUNICODEFORMAT CCM_SETUNICODEFORMAT
#define	TBN_FIRST	(-700U)
#define TBN_BEGINADJUST	(-703U)
#define TBN_BEGINDRAG	(-701U)
#define TBN_CUSTHELP	(-709U)
#define TBN_ENDADJUST	(-704U)
#define TBN_ENDDRAG	(-702U)
#define TBN_GETBUTTONINFOW	(-720U)
#define TBN_GETBUTTONINFOA	(-700U)
#define TBN_QUERYDELETE	(-707U)
#define TBN_QUERYINSERT	(-706U)
#define TBN_RESET	(-705U)
#define TBN_TOOLBARCHANGE	(-708U)
#define TBN_GETDISPINFOA	(TBN_FIRST-16)
#define TBN_GETDISPINFOW	(TBN_FIRST-17)
#define TBN_HOTITEMCHANGE	(TBN_FIRST - 13)
#define TBN_DRAGOUT	(TBN_FIRST - 14)
#define TBN_DELETINGBUTTON	(TBN_FIRST - 15)
#define TBN_GETINFOTIPA	(TBN_FIRST - 18)
#define TBN_GETINFOTIPW	(TBN_FIRST - 19)
#define TBN_RESTORE	(TBN_FIRST - 21)
#define TBN_SAVE	(TBN_FIRST - 22)
#define TBN_INITCUSTOMIZE	(TBN_FIRST - 23)
#define TBN_DROPDOWN	(TBN_FIRST-10)
#define TBN_GETOBJECT	(TBN_FIRST-12)
#define TBNRF_HIDEHELP	1
#define TBNRF_ENDCUSTOMIZE	2
#define TBDDRET_DEFAULT	0
#define TBDDRET_NODEFAULT	1
#define TBDDRET_TREATPRESSED	2
#define TBN_LAST	(-720U)
#define TCM_FIRST	0x1300
#define TCM_ADJUSTRECT	4904
#define TCM_DELETEALLITEMS	4873
#define TCM_DELETEITEM	4872
#define TCM_GETCURFOCUS	4911
#define TCM_GETCURSEL	4875
#define TCM_GETIMAGELIST	4866
#define TCM_GETITEMW	4924
#define TCM_INSERTITEMW	4926
#define TCM_SETITEMW	4925
#define TCM_GETITEMA	4869
#define TCM_INSERTITEMA	4871
#define TCM_SETITEMA	4870
#define TCM_GETITEMCOUNT	4868
#define TCM_GETITEMRECT	4874
#define TCM_GETROWCOUNT	4908
#define TCM_GETTOOLTIPS	4909
#define TCM_HITTEST	4877
#define TCM_REMOVEIMAGE	4906
#define TCM_SETCURFOCUS	4912
#define TCM_SETCURSEL	4876
#define TCM_SETIMAGELIST	4867
#define TCM_SETITEMEXTRA	4878
#define TCM_SETITEMSIZE	4905
#define TCM_SETPADDING	4907
#define TCM_SETTOOLTIPS	4910
#define TCM_GETUNICODEFORMAT CCM_GETUNICODEFORMAT
#define TCM_SETUNICODEFORMAT CCM_SETUNICODEFORMAT
#define TCM_SETMINTABWIDTH	(TCM_FIRST+49)
#define TCM_DESELECTALL	(TCM_FIRST+50)
#define TCM_HIGHLIGHTITEM	(TCM_FIRST+51)
#define TCM_SETEXTENDEDSTYLE	(TCM_FIRST+52)
#define TCM_GETEXTENDEDSTYLE	(TCM_FIRST+53)
#define TCM_SETUNICODEFORMAT	CCM_SETUNICODEFORMAT
#define TCM_GETUNICODEFORMAT	CCM_GETUNICODEFORMAT
#define TCN_KEYDOWN	(-550)
#define TCN_SELCHANGE	(-551)
#define TCN_SELCHANGING	(-552)
#define TCN_GETOBJECT	(TCN_FIRST-3)
#define TTM_ACTIVATE	1025
#define TTM_ADDTOOLW	1074
#define TTM_DELTOOLW	1075
#define TTM_ENUMTOOLSW	1082
#define TTM_GETCURRENTTOOLW	1083
#define TTM_SETWINDOWTHEME	CCM_SETWINDOWTHEME
#define TTM_GETTEXTW	1080
#define TTM_GETTOOLINFOW	1077
#define TTM_HITTESTW	1079
#define TTM_NEWTOOLRECTW	1076
#define TTM_SETTOOLINFOW	1078
#define TTM_UPDATETIPTEXTW	1081
#define TTM_ADDTOOLA	1028
#define TTM_DELTOOLA	1029
#define TTM_ENUMTOOLSA	1038
#define TTM_GETCURRENTTOOLA	1039
#define TTM_GETTEXTA	1035
#define TTM_GETTOOLINFOA	1032
#define TTM_HITTESTA	1034
#define TTM_NEWTOOLRECTA	1030
#define TTM_SETTOOLINFOA	1033
#define TTM_UPDATETIPTEXTA	1036
#define TTM_GETTOOLCOUNT	1037
#define TTM_RELAYEVENT	1031
#define TTM_SETDELAYTIME	1027
#define TTM_WINDOWFROMPOINT	1040
#define	TTM_POP (WM_USER+28)
#define TTM_SETMARGIN	(WM_USER+26)
#define TTM_GETMARGIN	(WM_USER+27)
#define TTM_GETMAXTIPWIDTH	(WM_USER+25)
#define TTM_SETMAXTIPWIDTH	(WM_USER+24)
#define TTM_TRACKACTIVATE	(WM_USER+17)
#define TTM_TRACKPOSITION	(WM_USER+18)
#define TTM_SETTIPBKCOLOR	(WM_USER+19)
#define TTM_SETTIPTEXTCOLOR	(WM_USER+20)
#define TTM_GETDELAYTIME	(WM_USER+21)
#define TTM_GETTIPBKCOLOR	(WM_USER+22)
#define TTM_GETTIPTEXTCOLOR	(WM_USER+23)
#define TTM_GETBUBBLESIZE	(WM_USER + 30)
#define TTM_ADJUSTRECT	(WM_USER+31)
#define TTM_SETTITLEA	(WM_USER+32)
#define TTM_SETTITLEW	(WM_USER+33)
#define TTM_POPUP	(WM_USER + 34)
#define TTM_GETTITLE	(WM_USER + 35)
#define TTN_GETDISPINFOA	(TTN_FIRST-0)
#define TTN_GETDISPINFOW	(TTN_FIRST-10)
#define TTN_SHOW	(TTN_FIRST-1)
#define TTN_POP	(TTN_FIRST - 2)
#define TTN_NEEDTEXTW	(-530)
#define TTN_NEEDTEXTA	(-520)
#define TVM_FIRST	0x1100
#define TV_FIRST	0x1100
#define TVM_INSERTITEMA	(TV_FIRST)
#define TVM_INSERTITEMW	(TV_FIRST+50)
#define TVM_GETTOOLTIPS	(TV_FIRST+25)
#define TVM_SETTOOLTIPS	(TV_FIRST+24)
#define TVM_SETITEMHEIGHT	(TV_FIRST + 27)
#define TVM_GETITEMHEIGHT	(TV_FIRST + 28)
#define TVM_SETBKCOLOR	(TV_FIRST + 29)
#define TVM_SETTEXTCOLOR	(TV_FIRST + 30)
#define TVM_GETBKCOLOR	(TV_FIRST + 31)
#define TVM_GETTEXTCOLOR	(TV_FIRST + 32)
#define TVM_SETSCROLLTIME	(TV_FIRST + 33)
#define TVM_GETSCROLLTIME	(TV_FIRST + 34)
#define TVM_SETINSERTMARKCOLOR	(TV_FIRST + 37)
#define TVM_GETINSERTMARKCOLOR	(TV_FIRST + 38)
#define TVM_CREATEDRAGIMAGE	4370
#define TVM_DELETEITEM	4353
#define TVM_ENDEDITLABELNOW	4374
#define TVM_ENSUREVISIBLE	4372
#define TVM_EXPAND	4354
#define TVM_GETCOUNT	4357
#define TVM_GETEDITCONTROL	4367
#define TVM_GETIMAGELIST	4360
#define TVM_GETINDENT	4358
#define TVM_GETITEMSTATE	(TV_FIRST+39)
#define TVM_SETLINECOLOR	(TV_FIRST+40)
#define TVM_GETLINECOLOR	(TV_FIRST+41)
#define TVM_GETITEMRECT	4356
#define TVM_GETNEXTITEM	4362
#define TVM_GETVISIBLECOUNT	4368
#define TVM_HITTEST	4369
#define TVM_EDITLABELW	4417
#define TVM_GETISEARCHSTRINGW	4416
#define TVM_GETITEMW	4414
#define TVM_SETITEMW	4415
#define TVM_EDITLABELA	4366
#define TVM_GETISEARCHSTRINGA	4375
#define TVM_GETITEMA	4364
#define TVM_SETITEMA	4365
#define TVM_SELECTITEM	4363
#define TVM_SETIMAGELIST	4361
#define TVM_SETINDENT	4359
#define TVM_SORTCHILDREN	4371
#define TVM_SORTCHILDRENCB	4373
#define TVM_GETUNICODEFORMAT CCM_GETUNICODEFORMAT
#define TVM_SETUNICODEFORMAT CCM_SETUNICODEFORMAT
#define TVN_KEYDOWN	(-412)
#define TVN_BEGINDRAGW	(-456)
#define TVN_BEGINLABELEDITW	(-459)
#define TVN_BEGINRDRAGW	(-457)
#define TVN_DELETEITEMW	(-458)
#define TVN_ENDLABELEDITW	(-460)
#define TVN_GETDISPINFOW	(-452)
#define TVN_ITEMEXPANDEDW	(-455)
#define TVN_ITEMEXPANDINGW	(-454)
#define TVN_SELCHANGEDW	(-451)
#define TVN_SELCHANGINGW	(-450)
#define TVN_SETDISPINFOW	(-453)
#define TVN_BEGINDRAGA	(-407)
#define TVN_BEGINLABELEDITA	(-410)
#define TVN_BEGINRDRAGA	(-408)
#define TVN_DELETEITEMA	(-409)
#define TVN_ENDLABELEDITA	(-411)
#define TVN_GETDISPINFOA	(-403)
#define TVN_ITEMEXPANDEDA	(-406)
#define TVN_ITEMEXPANDINGA	(-405)
#define TVN_SELCHANGEDA	(-402)
#define TVN_SELCHANGINGA	(-401)
#define TVN_SETDISPINFOA	(-404)
#define UDM_GETACCEL	1132
#define UDM_GETBASE	1134
#define UDM_GETBUDDY	1130
#define UDM_GETPOS	1128
#define UDM_GETRANGE	1126
#define UDM_SETACCEL	1131
#define UDM_SETBASE	1133
#define UDM_SETBUDDY	1129
#define UDM_SETPOS	1127
#define UDM_SETRANGE	1125
#define UDM_GETUNICODEFORMAT CCM_GETUNICODEFORMAT
#define UDM_SETUNICODEFORMAT CCM_SETUNICODEFORMAT
#define UDN_DELTAPOS	(-722)

#define WM_NULL	0
#define WM_APP	0x8000
#define WM_ACTIVATE	6
#define WM_ACTIVATEAPP	28
#define WM_ASKCBFORMATNAME	780
#define WM_CANCELJOURNAL	75
#define WM_CANCELMODE	31
#define WM_CAPTURECHANGED	533
#define WM_CHANGECBCHAIN	781
#define WM_CHAR	258
#define WM_CHARTOITEM	47
#define WM_CHILDACTIVATE	34
#define WM_CHOOSEFONT_GETLOGFONT	1025
#define WM_CHOOSEFONT_SETLOGFONT	1125
#define WM_CHOOSEFONT_SETFLAGS	1126
#define WM_CLEAR	771
#define WM_CLOSE	16
#define WM_COMMAND	273
#define WM_COMPACTING	65
#define WM_COMPAREITEM	57
#define WM_CONTEXTMENU	123
#define WM_COPY	769
#define WM_COPYDATA	74
#define WM_CREATE	1
#define WM_CTLCOLORBTN	309
#define WM_CTLCOLORDLG	310
#define WM_CTLCOLOREDIT	307
#define WM_CTLCOLORLISTBOX	308
#define WM_CTLCOLORMSGBOX	306
#define WM_CTLCOLORSCROLLBAR	311
#define WM_CTLCOLORSTATIC	312
#define WM_CUT	768
#define WM_DEADCHAR	259
#define WM_DELETEITEM	45
#define WM_DESTROY	2
#define WM_DESTROYCLIPBOARD	775
#define WM_DEVICECHANGE	537
#define WM_DEVMODECHANGE	27
#define WM_DISPLAYCHANGE	126
#define WM_DRAWCLIPBOARD	776
#define WM_DRAWITEM	43
#define WM_DROPFILES	563
#define WM_ENABLE	10
#define WM_ENDSESSION	22
#define WM_ENTERIDLE	289
#define WM_ENTERMENULOOP	529
#define WM_ENTERSIZEMOVE	561
#define WM_ERASEBKGND	20
#define WM_EXITMENULOOP	530
#define WM_EXITSIZEMOVE	562
#define WM_FONTCHANGE	29
#define WM_GETDLGCODE	135
#define WM_GETFONT	49
#define WM_GETHOTKEY	51
#define WM_GETICON	127
#define WM_GETMINMAXINFO	36
#define WM_GETTEXT	13
#define WM_GETTEXTLENGTH	14
#define WM_HELP	83
#define WM_HOTKEY	786
#define WM_HSCROLL	276
#define WM_HSCROLLCLIPBOARD	782
#define WM_ICONERASEBKGND	39
#define WM_IME_CHAR	646
#define WM_IME_COMPOSITION	271
#define WM_IME_COMPOSITIONFULL	644
#define WM_IME_CONTROL	643
#define WM_IME_ENDCOMPOSITION	270
#define WM_IME_KEYDOWN	656
#define WM_IME_KEYUP	657
#define WM_IME_NOTIFY	642
#define WM_IME_SELECT	645
#define WM_IME_SETCONTEXT	641
#define WM_IME_STARTCOMPOSITION	269
#define WM_INITDIALOG	272
#define WM_INITMENU	278
#define WM_INITMENUPOPUP	279
#define WM_INPUTLANGCHANGE	81
#define WM_INPUTLANGCHANGEREQUEST	80
#define WM_INPUT 0xff
#define WM_KEYDOWN	256
#define WM_KEYUP	257
#define WM_KILLFOCUS	8
#define WM_LBUTTONDBLCLK	515
#define WM_LBUTTONDOWN	513
#define WM_LBUTTONUP	514
#define WM_MBUTTONDBLCLK	521
#define WM_MBUTTONDOWN	519
#define WM_MBUTTONUP	520
#define WM_MDIACTIVATE	546
#define WM_MDICASCADE	551
#define WM_MDICREATE	544
#define WM_MDIDESTROY	545
#define WM_MDIGETACTIVE	553
#define WM_MDIICONARRANGE	552
#define WM_MDIMAXIMIZE	549
#define WM_MDINEXT	548
#define WM_MDIREFRESHMENU	564
#define WM_MDIRESTORE	547
#define WM_MDISETMENU	560
#define WM_MDITILE	550
#define WM_MEASUREITEM	44
#define WM_MENUCHAR	288
#define WM_MENUSELECT	287
#define WM_MENURBUTTONUP 0x0122
#define WM_MENUDRAG	0x0123
#define WM_MENUGETOBJECT 0x0124
#define WM_UNINITMENUPOPUP 0x0125
#define WM_MENUCOMMAND	0x0126
#define WM_CHANGEUISTATE 0x0127
#define WM_UPDATEUISTATE 0x0128
#define WM_QUERYUISTATE	0x0129
#define UIS_SET	1
#define UIS_CLEAR	2
#define UIS_INITIALIZE 3
#define WM_MOUSEACTIVATE	33
#define WM_MOUSEMOVE	512
#define WM_MOUSEHOVER	0x2a1
#define WM_MOUSELEAVE	0x2a3
#define WM_MOUSEWHEEL	0x20A
#define WM_MOVE	3
#define WM_MOVING	534
#define WM_NCACTIVATE	134
#define WM_NCCALCSIZE	131
#define WM_NCCREATE	129
#define WM_NCDESTROY	130
#define WM_NCHITTEST	132
#define WM_NCLBUTTONDBLCLK	163
#define WM_NCLBUTTONDOWN	161
#define WM_NCLBUTTONUP	162
#define WM_NCMBUTTONDBLCLK	169
#define WM_NCMBUTTONDOWN	167
#define WM_NCMBUTTONUP	168
#define WM_NCMOUSEMOVE	160
#define WM_NCPAINT	133
#define WM_NCRBUTTONDBLCLK	166
#define WM_NCRBUTTONDOWN	164
#define WM_NCRBUTTONUP	165
#define WM_NEXTDLGCTL	40
#define WM_NOTIFY	78
#define WM_NOTIFYFORMAT	85
#define WM_PAINT	15
#define WM_PAINTCLIPBOARD	777
#define WM_PAINTICON	38
#define WM_PALETTECHANGED	785
#define WM_PALETTEISCHANGING	784
#define WM_PARENTNOTIFY	528
#define WM_PASTE	770
#define WM_PENWINFIRST	896
#define WM_SYNCPAINT	0x0088
#define WM_AFXFIRST	0x0360
#define WM_AFXLAST	0x037F
#define WM_HANDHELDFIRST 0x0358
#define WM_HANDHELDLAST 0x035F
#define WM_PENWINLAST	911
#define WM_POWER	72
#define WM_POWERBROADCAST	536
#define WM_PRINT	791
#define WM_PRINTCLIENT	792
#define WM_PSD_ENVSTAMPRECT	1029
#define WM_PSD_FULLPAGERECT	1025
#define WM_PSD_GREEKTEXTRECT	1028
#define WM_PSD_MARGINRECT	1027
#define WM_PSD_MINMARGINRECT	1026
#define WM_PSD_PAGESETUPDLG	1024
#define WM_PSD_YAFULLPAGERECT	1030
#define WM_QUERYDRAGICON	55
#define WM_QUERYENDSESSION	17
#define WM_QUERYNEWPALETTE	783
#define WM_QUERYOPEN	19
#define WM_QUEUESYNC	35
#define WM_QUIT	18
#define WM_RBUTTONDBLCLK	518
#define WM_RBUTTONDOWN	516
#define WM_RBUTTONUP	517
#define WM_RENDERALLFORMATS	774
#define WM_RENDERFORMAT	773
#define WM_SETCURSOR	32
#define WM_SETFOCUS	7
#define WM_SETFONT	48
#define WM_SETHOTKEY	50
#define WM_SETICON	128
#define WM_SETREDRAW	11
#define WM_SETTEXT	12
#define WM_SETTINGCHANGE	26
#define WM_SHOWWINDOW	24
#define WM_SIZE	5
#define WM_SIZECLIPBOARD	779
#define WM_SIZING	532
#define WM_SPOOLERSTATUS	42
#define WM_STYLECHANGED	125
#define WM_STYLECHANGING	124
#define WM_SYSCHAR	262
#define WM_SYSCOLORCHANGE	21
#define WM_SYSCOMMAND	274
#define WM_SYSDEADCHAR	263
#define WM_SYSKEYDOWN	260
#define WM_SYSKEYUP	261
#define WM_TCARD	82
#define WM_TIMECHANGE	30
#define WM_TIMER	275
#define WM_UNDO	772
#define WM_USER	1024
#define WM_USERCHANGED	84
#define WM_VKEYTOITEM	46
#define WM_VSCROLL	277
#define WM_VSCROLLCLIPBOARD	778
#define WM_WINDOWPOSCHANGED	71
#define WM_WINDOWPOSCHANGING	70
#define WM_XBUTTONDOWN	0x020B
#define WM_XBUTTONUP	0x020C
#define WM_XBUTTONDBLCLK	0x020D
#define WM_WININICHANGE	26
#define WM_KEYFIRST	256
#define WM_KEYLAST	264
#define WM_MOUSEFIRST	512
#define WM_MOUSELAST 0x020D
#define WM_NEXTMENU	0x0213
#define WM_CHANGEUISTATE	0x0127
#define WM_UPDATEUISTATE	0x0128
#define WM_QUERYUISTATE	0x0129
#define WM_WTSSESSION_CHANGE 0x02B1
#define WM_LBTRACKPOINT	0x0131
#define WM_GETOBJECT 0x003D
#define WM_COMMNOTIFY 0x0044
#define WM_TABLET_FIRST	0x02c0
#define WM_TABLET_LAST	0x02df
#define WM_IME_REQUEST	0x0288
#define WM_IME_KEYLAST 0x010F
#define WM_NCMOUSEHOVER	0x02A0
#define WM_NCMOUSELEAVE 0x02A2

#define COMCTL32_VERSION 6
#define CCM_SETVERSION (CCM_FIRST+0x7)
#define CCM_GETVERSION (CCM_FIRST+0x8)
#define CCM_SETNOTIFYWINDOW (CCM_FIRST+0x9)
#define CCM_SETWINDOWTHEME    (CCM_FIRST + 0xb)
#define CCM_DPISCALE        (CCM_FIRST + 0xc)
#define INFOTIPSIZE	1024
#define PGM_FIRST	0x1400
#define CCM_FIRST	0x2000
#define CCM_LAST	(CCM_FIRST + 0x200)
#define CCM_SETBKCOLOR	(CCM_FIRST + 1)
#define CCM_SETCOLORSCHEME	(CCM_FIRST + 2)
#define CCM_GETCOLORSCHEME	(CCM_FIRST + 3)
#define CCM_GETDROPTARGET	(CCM_FIRST + 4)
#define CCM_SETUNICODEFORMAT	(CCM_FIRST + 5)
#define CCM_GETUNICODEFORMAT	(CCM_FIRST + 6)
#define CBEM_INSERTITEMA	(WM_USER+1)
#define CBEM_SETIMAGELIST	(WM_USER+2)
#define CBEM_GETIMAGELIST	(WM_USER+3)
#define CBEM_GETITEMA		(WM_USER+4)
#define CBEM_SETITEMA		(WM_USER+5)
#define CBEM_DELETEITEM	CB_DELETESTRING
#define CBEM_GETCOMBOCONTROL	(WM_USER+6)
#define CBEM_GETEDITCONTROL	(WM_USER+7)
#define CBEM_SETEXSTYLE		(WM_USER+8)
#define CBEM_SETEXTENDEDSTYLE	(WM_USER+14)
#define CBEM_GETEXSTYLE		(WM_USER+9)
#define CBEM_GETEXTENDEDSTYLE	(WM_USER+9)
#define CBEM_SETUNICODEFORMAT	CCM_SETUNICODEFORMAT
#define CBEM_GETUNICODEFORMAT	CCM_GETUNICODEFORMAT
#define CBEM_HASEDITCHANGED	(WM_USER+10)
#define CBEM_INSERTITEMW	(WM_USER+11)
#define CBEM_SETITEMW	(WM_USER+12)
#define CBEM_GETITEMW	(WM_USER+13)
/* Defines.h WIN32 definitions */
#undef MAX_PATH
#define MAX_PATH	260
#define UNICODE_NULL ((WCHAR)0)
#define LF_FACESIZE	32
#define LF_FULLFACESIZE	64
#define ELF_VENDOR_SIZE	4
#define SECURITY_STATIC_TRACKING	0
#define SECURITY_DYNAMIC_TRACKING	1
#define MAX_DEFAULTCHAR	2
#define MAX_LEADBYTES	12
#define EXCEPTION_MAXIMUM_PARAMETERS	15
#define CCHDEVICENAME	32
#define CCHFORMNAME	32
#define MENU_TEXT_LEN	40
#define MAX_LANA	254
#define NCBNAMSZ	16
#define NETBIOS_NAME_LEN	16
#define OFS_MAXPATHNAME	128
#define MAX_TAB_STOPS	32
#define ANYSIZE_ARRAY	1
#define FILE_BEGIN	0
#define FILE_CURRENT	1
#define FILE_END	2
#define OF_READ	0
#define OF_READWRITE	2
#define OF_WRITE	1
#define OF_SHARE_COMPAT	0
#define OF_SHARE_DENY_NONE	64
#define OF_SHARE_DENY_READ	48
#define OF_SHARE_DENY_WRITE	32
#define OF_SHARE_EXCLUSIVE	16
#define OF_CANCEL	2048
#define OF_CREATE	4096
#define OF_DELETE	512
#define OF_EXIST	16384
#define OF_PARSE	256
#define OF_PROMPT	8192
#define OF_REOPEN	32768
#define OF_VERIFY	1024
#define HKL_NEXT	1
#define HKL_PREV	0
#define KLF_REORDER	8
#define KLF_UNLOADPREVIOUS	4
#define KLF_ACTIVATE	1
#define KLF_NOTELLSHELL	128
#define KLF_REPLACELANG	16
#define KLF_SUBSTITUTE_OK	2
#define MF_BITMAP	4
#define MF_CHECKED	8
#define MF_DISABLED	2
#define MF_ENABLED	0
#define MF_GRAYED	1
#define MF_MENUBARBREAK	32
#define MF_MENUBREAK	64
#define MF_OWNERDRAW	256
#define MF_POPUP	16
#define MF_SEPARATOR	0x800
#define MF_STRING	0
#define MF_UNCHECKED	0
#define MF_DEFAULT	4096
#define MF_SYSMENU	0x2000
#define MF_HELP		0x4000
#define MF_END	128
#define MF_RIGHTJUSTIFY 0x4000
#define MF_MOUSESELECT 0x8000
#define BLACKNESS	0x42
#define NOTSRCERASE	0x1100A6
#define NOTSRCCOPY	0x330008
#define SRCERASE	0x440328
#define DSTINVERT	0x550009
#define PATINVERT	0x5A0049
#define SRCINVERT	0x660046
#define SRCAND	0x8800C6
#define MERGEPAINT	0xBB0226
#define MERGECOPY	0xC000CA
#define SRCCOPY	0xCC0020
#define SRCPAINT	0xEE0086
#define PATCOPY	0xF00021
#define PATPAINT	0xFB0A09
#define WHITENESS	0xFF0062
#define NOMIRRORBITMAP	0x80000000
#define CAPTUREBLT	0x40000000
#define R2_BLACK	1
#define R2_COPYPEN	13
#define R2_MASKNOTPEN	3
#define R2_MASKPEN	9
#define R2_MASKPENNOT	5
#define R2_MERGENOTPEN	12
#define R2_MERGEPEN	15
#define R2_MERGEPENNOT	14
#define R2_NOP	11
#define R2_NOT	6
#define R2_NOTCOPYPEN	4
#define R2_NOTMASKPEN	8
#define R2_NOTMERGEPEN	2
#define R2_NOTXORPEN	10
#define R2_WHITE	16
#define R2_XORPEN	7
#define R2_LAST		16
#define BSF_FLUSHDISK	4
#define BSF_FORCEIFHUNG	32
#define BSF_IGNORECURRENTTASK	2
#define BSF_NOHANG	8
#define BSF_POSTMESSAGE	16
#define BSF_QUERY	1
#define BSM_ALLCOMPONENTS	0
#define BSM_APPLICATIONS	8
#define BSM_INSTALLABLEDRIVERS	4
#define BSM_NETDRIVER	2
#define BSM_VXDS	1
#define BROADCAST_QUERY_DENY	1112363332
#define NMPWAIT_NOWAIT	1
#define NMPWAIT_WAIT_FOREVER	(-1)
#define NMPWAIT_USE_DEFAULT_WAIT	0
#define MDITILE_SKIPDISABLED	2
#define MDITILE_HORIZONTAL	1
#define MDITILE_VERTICAL	0
#define HCBT_ACTIVATE	5
#define HCBT_CLICKSKIPPED	6
#define HCBT_CREATEWND	3
#define HCBT_DESTROYWND	4
#define HCBT_KEYSKIPPED	7
#define HCBT_MINMAX	1
#define HCBT_MOVESIZE	0
#define HCBT_QS	2
#define HCBT_SETFOCUS	9
#define HCBT_SYSCOMMAND	8
#define DM_BITSPERPEL	0x40000
#define DM_PELSWIDTH	0x80000
#define DM_PELSHEIGHT	0x100000
#define DM_DISPLAYFLAGS	0x200000
#define DM_DISPLAYFREQUENCY 0x400000
#define CDS_UPDATEREGISTRY	1
#define CDS_TEST	2
#define CDS_GLOBAL	8
#define CDS_FULLSCREEN	4
#define CDS_SETPRIMARY	16
#define CDS_VIDEOPARAMETERS 32
#define CDS_RESET	0x40000000
#define CDS_NORESET	0x10000000
#define DISP_CHANGE_SUCCESSFUL	0
#define DISP_CHANGE_RESTART	1
#define DISP_CHANGE_BADPARAM     (-5)
#define DISP_CHANGE_BADFLAGS	(-4)
#define DISP_CHANGE_FAILED	(-1)
#define DISP_CHANGE_BADMODE	(-2)
#define DISP_CHANGE_NOTUPDATED	(-3)
#define BST_CHECKED	1
#define BST_INDETERMINATE	2
#define BST_UNCHECKED	0
#define BST_FOCUS	8
#define BST_PUSHED	4
#define MF_BYCOMMAND	0
#define MF_BYPOSITION	0x400
#define MF_UNCHECKED	0
#define MF_HILITE	128
#define MF_UNHILITE	0
#define CWP_ALL	0
#define CWP_SKIPINVISIBLE	1
#define CWP_SKIPDISABLED	2
#define CWP_SKIPTRANSPARENT	4
#define CE_BREAK	16
#define CE_DNS	2048
#define CE_FRAME	8
#define CE_IOE	1024
#define CE_MODE	32768
#define CE_OOP	4096
#define CE_OVERRUN	2
#define CE_PTO	512
#define CE_RXOVER	1
#define CE_RXPARITY	4
#define CE_TXFULL	256
#define RGN_AND	1
#define RGN_COPY	5
#define RGN_DIFF	4
#define RGN_OR	2
#define RGN_XOR	3
#define NULLREGION	1
#define SIMPLEREGION	2
#define COMPLEXREGION	3
#define ERROR	0
#define RGN_ERROR	ERROR
#define RGN_MIN	RGN_AND
#define RGN_MAX	RGN_COPY
#define LOCALE_SYSTEM_DEFAULT	0x800
#define LOCALE_USER_DEFAULT	0x400
#define NORM_IGNORECASE	1
#define NORM_IGNOREKANATYPE	65536
#define NORM_IGNORENONSPACE	2
#define NORM_IGNORESYMBOLS	4
#define NORM_IGNOREWIDTH	131072
#define SORT_STRINGSORT	4096
#define LCMAP_BYTEREV	2048
#define LCMAP_FULLWIDTH	8388608
#define LCMAP_HALFWIDTH	4194304
#define LCMAP_HIRAGANA	1048576
#define LCMAP_KATAKANA	2097152
#define LCMAP_LOWERCASE	256
#define LCMAP_SORTKEY	1024
#define LCMAP_UPPERCASE	512
#define DBG_CONTINUE ((DWORD)0x10002)
#define DBG_TERMINATE_THREAD ((DWORD)0x40010003)
#define DBG_TERMINATE_PROCESS ((DWORD)0x40010004)
#define DBG_CONTROL_C ((DWORD)0x40010005)
#define DBG_CONTROL_BREAK ((DWORD)0x40010008)
#define DBG_EXCEPTION_NOT_HANDLED ((DWORD)0x80010001)
#define IMAGE_BITMAP	0
#define IMAGE_CURSOR	2
#define IMAGE_ENHMETAFILE	1
#define IMAGE_ICON	1
#define LR_COPYDELETEORG	8
#define LR_COPYRETURNORG	4
#define LR_MONOCHROME	1
#define LR_DEFAULTSIZE	64
#define DF_ALLOWOTHERACCOUNTHOOK	1
#define DESKTOP_CREATEMENU	4
#define DESKTOP_CREATEWINDOW	2
#define DESKTOP_ENUMERATE	64
#define DESKTOP_HOOKCONTROL	8
#define DESKTOP_JOURNALPLAYBACK	32
#define DESKTOP_JOURNALRECORD	16
#define DESKTOP_READOBJECTS	1
#define DESKTOP_SWITCHDESKTOP	256
#define DESKTOP_WRITEOBJECTS	128
#define WSF_VISIBLE	1
#define CBM_INIT	4
#define DIB_PAL_COLORS	1
#define DIB_RGB_COLORS	0
#define GENERIC_READ	0x80000000
#define GENERIC_WRITE	0x40000000
#define FILE_SHARE_READ	1
#define FILE_SHARE_WRITE	2
#define FILE_SHARE_DELETE 4
#define CONSOLE_TEXTMODE_BUFFER	1
#define CREATE_NEW	1
#define CREATE_ALWAYS	2
#define OPEN_EXISTING	3
#define OPEN_ALWAYS	4
#define TRUNCATE_EXISTING	5
#define FILE_ATTRIBUTE_ARCHIVE	32
#define FILE_ATTRIBUTE_COMPRESSED	2048
#define FILE_ATTRIBUTE_NORMAL	128
#define FILE_ATTRIBUTE_DIRECTORY	16
#define FILE_ATTRIBUTE_HIDDEN	2
#define FILE_ATTRIBUTE_READONLY	1
#define FILE_ATTRIBUTE_SYSTEM	4
#define FILE_ATTRIBUTE_TEMPORARY	256
#define FILE_ATTRIBUTE_SPARSE_FILE 0x200
#define FILE_ATTRIBUTE_REPARSE_POINT 0x400
#define FILE_ATTRIBUTE_OFFLINE 0x1000
#define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED 0x00002000
#define FILE_ATTRIBUTE_ENCRYPTED 0x4000
#define FILE_FLAG_WRITE_THROUGH	0x80000000
#define FILE_FLAG_OVERLAPPED	1073741824
#define FILE_FLAG_NO_BUFFERING	536870912
#define FILE_FLAG_RANDOM_ACCESS	268435456
#define FILE_FLAG_SEQUENTIAL_SCAN	134217728
#define FILE_FLAG_DELETE_ON_CLOSE	67108864
#define FILE_FLAG_BACKUP_SEMANTICS	33554432
#define FILE_FLAG_POSIX_SEMANTICS	16777216
#define FILE_FLAG_OPEN_REPARSE_POINT	0x200000
#define FILE_FLAG_OPEN_NO_RECALL	0x100000
#define FILE_FLAG_FIRST_PIPE_INSTANCE	0x00080000
#define SECURITY_ANONYMOUS	0
#define SECURITY_IDENTIFICATION	65536
#define SECURITY_IMPERSONATION	131072
#define SECURITY_DELEGATION	196608
#define SECURITY_CONTEXT_TRACKING	262144
#define SECURITY_EFFECTIVE_ONLY	524288
#define SECURITY_SQOS_PRESENT	1048576
#define PAGE_READONLY	2
#define PAGE_READWRITE	4
#define PAGE_WRITECOPY	8
#define SEC_COMMIT	134217728
#define SEC_IMAGE	16777216
#define SEC_NOCACHE	268435456
#define SEC_RESERVE	67108864
#define MEM_COMMIT	4096
#define MEM_RESERVE	8192
#define MEM_TOP_DOWN	1048576
#define PAGE_EXECUTE	16
#define PAGE_EXECUTE_READ	32
#define PAGE_EXECUTE_READWRITE	64
#define PAGE_GUARD	256
#define PAGE_NOACCESS	1
#define PAGE_NOCACHE	512
#define MEM_COMMIT	4096
#define MEM_FREE	65536
#define MEM_RESERVE	8192
#define MEM_IMAGE	16777216
#define MEM_MAPPED	262144
#define MEM_PRIVATE	131072
#define MEM_DECOMMIT	16384
#define MEM_RELEASE	32768
#define WRITE_WATCH_FLAG_RESET 1
#define FILE_READ_DATA	1
#define FILE_LIST_DIRECTORY	1
#define FILE_WRITE_DATA	2
#define FILE_ADD_FILE	2
#define FILE_APPEND_DATA	4
#define FILE_ADD_SUBDIRECTORY	4
#define FILE_CREATE_PIPE_INSTANCE 4
#define FILE_READ_EA	8
#define FILE_WRITE_EA	0x10
#define FILE_EXECUTE	0x20
#define FILE_TRAVERSE	0x0020
#define FILE_DELETE_CHILD	0x0040
#define FILE_READ_ATTRIBUTES	0x0080
#define FILE_WRITE_ATTRIBUTES	0x100
#define FILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x1FF)
#define FILE_GENERIC_READ (STANDARD_RIGHTS_READ|FILE_READ_DATA| FILE_READ_ATTRIBUTES|FILE_READ_EA|SYNCHRONIZE)
#define FILE_GENERIC_WRITE (STANDARD_RIGHTS_WRITE|FILE_WRITE_DATA|FILE_WRITE_ATTRIBUTES|FILE_WRITE_EA|FILE_APPEND_DATA|SYNCHRONIZE)
#define FILE_GENERIC_EXECUTE (STANDARD_RIGHTS_EXECUTE|FILE_READ_ATTRIBUTES|FILE_EXECUTE|SYNCHRONIZE)
#define PAGE_EXECUTE_WRITECOPY	128
#define EXCEPTION_GUARD_PAGE	0x80000001
#define SECTION_EXTEND_SIZE	16
#define SECTION_MAP_READ	4
#define SECTION_MAP_WRITE	2
#define SECTION_QUERY	1
#define SECTION_ALL_ACCESS	0xf001f
#define FW_DONTCARE	0
#define FW_THIN	100
#define FW_EXTRALIGHT	200
#define FW_LIGHT	300
#define FW_NORMAL	400
#define FW_REGULAR	400
#define FW_MEDIUM	500
#define FW_SEMIBOLD	600
#define FW_BOLD	700
#define FW_EXTRABOLD	800
#define FW_HEAVY	900
#define CLEARTYPE_QUALITY 5
#define ANSI_CHARSET	0
#define DEFAULT_CHARSET	1
#define SYMBOL_CHARSET	2
#define SHIFTJIS_CHARSET	128
#define HANGEUL_CHARSET	129
#define GB2312_CHARSET	134
#define CHINESEBIG5_CHARSET	136
#define GREEK_CHARSET	161
#define TURKISH_CHARSET	162
#define HEBREW_CHARSET	177
#define ARABIC_CHARSET	178
#define BALTIC_CHARSET	186
#define RUSSIAN_CHARSET	204
#define THAI_CHARSET	222
#define EASTEUROPE_CHARSET	238
#define OEM_CHARSET	255
#define OUT_DEFAULT_PRECIS	0
#define OUT_STRING_PRECIS	1
#define OUT_CHARACTER_PRECIS	2
#define OUT_STROKE_PRECIS	3
#define OUT_TT_PRECIS	4
#define OUT_DEVICE_PRECIS	5
#define OUT_RASTER_PRECIS	6
#define OUT_TT_ONLY_PRECIS	7
#define OUT_OUTLINE_PRECIS	8
#define CLIP_DEFAULT_PRECIS	0
#define CLIP_CHARACTER_PRECIS	1
#define CLIP_STROKE_PRECIS	2
#define CLIP_MASK	15
#define CLIP_LH_ANGLES	16
#define CLIP_TT_ALWAYS	32
#define CLIP_EMBEDDED	128
#define DEFAULT_QUALITY	0
#define DRAFT_QUALITY	1
#define PROOF_QUALITY	2
#define NONANTIALIASED_QUALITY	3
#define ANTIALIASED_QUALITY	4
#define DEFAULT_PITCH	0
#define FIXED_PITCH	1
#define VARIABLE_PITCH	2
#define FF_DECORATIVE	80
#define FF_DONTCARE	0
#define FF_MODERN	48
#define FF_ROMAN	16
#define FF_SCRIPT	64
#define FF_SWISS	32
#define HS_BDIAGONAL	3
#define HS_CROSS	4
#define HS_DIAGCROSS	5
#define HS_FDIAGONAL	2
#define HS_HORIZONTAL	0
#define HS_VERTICAL	1
#define LR_DEFAULTCOLOR	0
#define LR_LOADREALSIZE	128
#define LR_MONOCHROME	1
#define LR_COPYRETURNORG 4
#define LR_COPYDELETEORG 8
#define LR_LOADFROMFILE	16
#define LR_LOADTRANSPARENT 32
#define LR_DEFAULTSIZE	64
#define LR_VGACOLOR	0x80
#define LR_LOADMAP3DCOLORS 0x1000
#define LR_CREATEDIBSECTION 0x2000
#define LR_COPYFROMRESOURCE 0x4000
#define LR_SHARED	0x8000
#define MAILSLOT_WAIT_FOREVER	0xffffffff
#define MAILSLOT_NO_MESSAGE	0xffffffff
#define CMB_MASKED	2
#define PIPE_ACCESS_DUPLEX	3
#define PIPE_ACCESS_INBOUND	1
#define PIPE_ACCESS_OUTBOUND	2
#define WRITE_DAC	0x40000
#define WRITE_OWNER	0x80000
#define ACCESS_SYSTEM_SECURITY	0x1000000
#define PIPE_TYPE_BYTE	0
#define PIPE_TYPE_MESSAGE	4
#define PIPE_READMODE_BYTE	0
#define PIPE_READMODE_MESSAGE	2
#define PIPE_WAIT	0
#define PIPE_NOWAIT	1
#define PIPE_UNLIMITED_INSTANCES 255
#define PROGRESS_CONTINUE 0
#define PROGRESS_CANCEL	1
#define PROGRESS_STOP	2
#define PROGRESS_QUIET	3
#define CALLBACK_CHUNK_FINISHED 0
#define CALLBACK_STREAM_SWITCH	1
#define COPY_FILE_FAIL_IF_EXISTS 1
#define COPY_FILE_RESTARTABLE	2
#define COPY_FILE_OPEN_SOURCE_FOR_WRITE 4
#define COPY_FILE_ALLOW_DECRYPTED_DESTINATION 8
#define REPLACEFILE_WRITE_THROUGH 1
#define REPLACEFILE_IGNORE_MERGE_ERRORS 2
#define PS_GEOMETRIC	65536
#define PS_COSMETIC	0
#define PS_ALTERNATE	8
#define PS_SOLID	0
#define PS_DASH	1
#define PS_DOT	2
#define PS_DASHDOT	3
#define PS_DASHDOTDOT	4
#define PS_NULL	5
#define PS_USERSTYLE	7
#define PS_INSIDEFRAME	6
#define PS_ENDCAP_ROUND	0
#define PS_ENDCAP_SQUARE	256
#define PS_ENDCAP_FLAT	512
#define PS_JOIN_BEVEL	4096
#define PS_JOIN_MITER	8192
#define PS_JOIN_ROUND	0
#define PS_STYLE_MASK	15
#define PS_ENDCAP_MASK	3840
#define PS_TYPE_MASK	983040
#define ALTERNATE	1
#define WINDING	2
#define POLYFILL_LAST	2
#define LAYOUT_RTL	1
#define LAYOUT_BTT	2
#define LAYOUT_VBH	4
#define LAYOUT_BITMAPORIENTATIONPRESERVED	8
#define LAYOUT_ORIENTATIONMASK	(LAYOUT_RTL|LAYOUT_BTT|LAYOUT_VBH)
#define CREATE_NEW_CONSOLE	16
#define CREATE_NEW_PROCESS_GROUP	512
#define CREATE_SEPARATE_WOW_VDM	2048
#define CREATE_SUSPENDED	4
#define CREATE_UNICODE_ENVIRONMENT	1024
#define CREATE_BREAKAWAY_FROM_JOB 0x01000000
#define CREATE_PRESERVE_CODE_AUTHZ_LEVEL 0x02000000
#define CREATE_DEFAULT_ERROR_MODE 0x04000000
#define CREATE_NO_WINDOW 0x08000000
#define CREATE_SHARED_WOW_VDM 0x00001000
#define CREATE_FORCEDOS 0x00002000
#define PROFILE_USER 0x10000000
#define PROFILE_KERNEL 0x20000000
#define PROFILE_SERVER 0x40000000
#define DEBUG_PROCESS	1
#define DEBUG_ONLY_THIS_PROCESS	2
#define DETACHED_PROCESS	8
#define HIGH_PRIORITY_CLASS	128
#define IDLE_PRIORITY_CLASS	64
#define NORMAL_PRIORITY_CLASS	32
#define REALTIME_PRIORITY_CLASS	256
#define BELOW_NORMAL_PRIORITY_CLASS 0x04000
#define ABOVE_NORMAL_PRIORITY_CLASS 0x08000
#define DELETE	0x10000
#define READ_CONTROL	0x20000
#define GENERIC_EXECUTE	0x20000000
#define SERVICE_WIN32_OWN_PROCESS	16
#define SERVICE_WIN32_SHARE_PROCESS	32
#define SERVICE_KERNEL_DRIVER	1
#define SERVICE_FILE_SYSTEM_DRIVER	2
#define SERVICE_INTERACTIVE_PROCESS	256
#define SERVICE_BOOT_START	0
#define SERVICE_SYSTEM_START	1
#define SERVICE_AUTO_START	2
#define SERVICE_DEMAND_START	3
#define SERVICE_DISABLED	4
#define SERVICE_ERROR_IGNORE	0
#define SERVICE_ERROR_NORMAL	1
#define SERVICE_ERROR_SEVERE	2
#define SERVICE_ERROR_CRITICAL	3
#define TAPE_FIXED_PARTITIONS	0
#define TAPE_INITIATOR_PARTITIONS	2
#define TAPE_SELECT_PARTITIONS	1
#define TAPE_FILEMARKS	1
#define TAPE_LONG_FILEMARKS	3
#define TAPE_SETMARKS	0
#define TAPE_SHORT_FILEMARKS	2
#define CW_USEDEFAULT	0x80000000
#define WS_BORDER	0x800000
#define WS_CAPTION	0xc00000
#define WS_CHILD	0x40000000
#define WS_CHILDWINDOW	0x40000000
#define WS_CLIPCHILDREN	0x2000000
#define WS_CLIPSIBLINGS	0x4000000
#define WS_DISABLED	0x8000000
#define WS_DLGFRAME	0x400000
#define WS_GROUP	0x20000
#define WS_HSCROLL	0x100000
#define WS_ICONIC	0x20000000
#define WS_MAXIMIZE	0x1000000
#define WS_MAXIMIZEBOX	0x10000
#define WS_MINIMIZE	0x20000000
#define WS_MINIMIZEBOX	0x20000
#define WS_OVERLAPPED	0
#define WS_OVERLAPPEDWINDOW	0xcf0000
#define WS_POPUP	0x80000000
#define WS_POPUPWINDOW	0x80880000
#define WS_SIZEBOX	0x40000
#define WS_SYSMENU	0x80000
#define WS_TABSTOP	0x10000
#define WS_THICKFRAME	0x40000
#define WS_TILED	0
#define WS_TILEDWINDOW	0xcf0000
#define WS_VISIBLE	0x10000000
#define WS_VSCROLL	0x200000
#define MDIS_ALLCHILDSTYLES	1
#define BS_3STATE	5
#define BS_AUTO3STATE	6
#define BS_AUTOCHECKBOX	3
#define BS_AUTORADIOBUTTON	9
#define BS_BITMAP	128
#define BS_BOTTOM	0x800
#define BS_CENTER	0x300
#define BS_CHECKBOX	2
#define BS_DEFPUSHBUTTON	1
#define BS_GROUPBOX	7
#define BS_ICON	64
#define BS_LEFT	256
#define BS_LEFTTEXT	32
#define BS_MULTILINE	0x2000
#define BS_NOTIFY	0x4000
#define BS_OWNERDRAW	0xb
#define BS_PUSHBUTTON	0
#define BS_PUSHBOX	10
#define BS_PUSHLIKE	4096
#define BS_RADIOBUTTON	4
#define BS_RIGHT	512
#define BS_RIGHTBUTTON	32
#define BS_TEXT	0
#define BS_TOP	0x400
#define BS_USERBUTTON	8
#define BS_VCENTER	0xc00
#define BS_FLAT	0x8000
#define BUTTON_IMAGELIST_ALIGN_LEFT	0
#define BUTTON_IMAGELIST_ALIGN_RIGHT	1
#define BUTTON_IMAGELIST_ALIGN_TOP	2
#define BUTTON_IMAGELIST_ALIGN_BOTTOM	3
#define BUTTON_IMAGELIST_ALIGN_CENTER	4
#define CBS_AUTOHSCROLL	64
#define CBS_DISABLENOSCROLL	0x800
#define CBS_DROPDOWN	2
#define CBS_DROPDOWNLIST	3
#define CBS_HASSTRINGS	512
#define CBS_LOWERCASE	0x4000
#define CBS_NOINTEGRALHEIGHT	0x400
#define CBS_OEMCONVERT	128
#define CBS_OWNERDRAWFIXED	16
#define CBS_OWNERDRAWVARIABLE	32
#define CBS_SIMPLE	1
#define CBS_SORT	256
#define CBS_UPPERCASE	0x2000
#define ES_AUTOHSCROLL	128
#define ES_AUTOVSCROLL	64
#define ES_CENTER	1
#define ES_LEFT	0
#define ES_LOWERCASE	16
#define ES_MULTILINE	4
#define ES_NOHIDESEL	256
#define ES_NUMBER	0x2000
#define ES_OEMCONVERT	0x400
#define ES_PASSWORD	32
#define ES_READONLY	0x800
#define ES_RIGHT	2
#define ES_UPPERCASE	8
#define ES_WANTRETURN	4096
#define LBS_DISABLENOSCROLL	4096
#define LBS_EXTENDEDSEL	0x800
#define LBS_HASSTRINGS	64
#define LBS_MULTICOLUMN	512
#define LBS_MULTIPLESEL	8
#define LBS_NODATA	0x2000
#define LBS_NOINTEGRALHEIGHT	256
#define LBS_NOREDRAW	4
#define LBS_NOSEL	0x4000
#define LBS_NOTIFY	1
#define LBS_OWNERDRAWFIXED	16
#define LBS_OWNERDRAWVARIABLE	32
#define LBS_SORT	2
#define LBS_STANDARD	0xa00003
#define LBS_USETABSTOPS	128
#define LBS_WANTKEYBOARDINPUT	0x400
#define SBS_BOTTOMALIGN	4
#define SBS_HORZ	0
#define SBS_LEFTALIGN	2
#define SBS_RIGHTALIGN	4
#define SBS_SIZEBOX	8
#define SBS_SIZEBOXBOTTOMRIGHTALIGN	4
#define SBS_SIZEBOXTOPLEFTALIGN	2
#define SBS_SIZEGRIP	16
#define SBS_TOPALIGN	2
#define SBS_VERT	1
#define SS_BITMAP	0xe
#define SS_BLACKFRAME	7
#define SS_BLACKRECT	4
#define SS_CENTER	1
#define SS_CENTERIMAGE	512
#define SS_ENHMETAFILE	0xf
#define SS_ETCHEDFRAME	0x12
#define SS_ETCHEDHORZ	16
#define SS_ETCHEDVERT	0x11
#define SS_GRAYFRAME	8
#define SS_GRAYRECT	5
#define SS_ICON	3
#define SS_LEFT	0
#define SS_LEFTNOWORDWRAP	0xc
#define SS_TYPEMASK	0x1f
#define SS_ENDELLIPSIS	0x4000
#define SS_PATHELLIPSIS	0x8000
#define SS_WORDELLIPSIS	0xC000
#define SS_ELLIPSISMASK	0xC000
#define SS_REALSIZECONTROL	0x40
#define SS_NOPREFIX	128
#define SS_NOTIFY	256
#define SS_OWNERDRAW	0xd
#define SS_REALSIZEIMAGE	0x800
#define SS_RIGHT	2
#define SS_RIGHTJUST	0x400
#define SS_SIMPLE	11
#define SS_SUNKEN	4096
#define SS_WHITEFRAME	9
#define SS_WHITERECT	6
#define SS_USERITEM 10
#define DS_3DLOOK	4
#define DS_ABSALIGN	1
#define DS_CENTER	0x800
#define DS_CENTERMOUSE	4096
#define DS_CONTEXTHELP	0x2000
#define DS_CONTROL	0x400
#define DS_FIXEDSYS	8
#define DS_LOCALEDIT	32
#define DS_MODALFRAME	128
#define DS_NOFAILCREATE	16
#define DS_NOIDLEMSG	256
#define DS_SETFONT	64
#define DS_SETFOREGROUND	512
#define DS_SYSMODAL	2
#define DS_FIXEDSYS	8
#define DS_SHELLFONT	(DS_SETFONT|DS_FIXEDSYS)
#define WS_EX_ACCEPTFILES	16
#define WS_EX_APPWINDOW	0x40000
#define WS_EX_CLIENTEDGE	512
#define WS_EX_CONTEXTHELP	0x400
#define WS_EX_CONTROLPARENT	0x10000
#define WS_EX_DLGMODALFRAME	1
#define WS_EX_LEFT	0
#define WS_EX_LEFTSCROLLBAR	0x4000
#define WS_EX_LTRREADING	0
#define WS_EX_MDICHILD	64
#define WS_EX_NOPARENTNOTIFY	4
#define WS_EX_OVERLAPPEDWINDOW	0x300
#define WS_EX_PALETTEWINDOW	0x188
#define WS_EX_RIGHT	0x1000
#define WS_EX_RIGHTSCROLLBAR	0
#define WS_EX_RTLREADING	0x2000
#define WS_EX_STATICEDGE	0x20000
#define WS_EX_TOOLWINDOW	128
#define WS_EX_TOPMOST	8
#define WS_EX_TRANSPARENT	32
#define WS_EX_WINDOWEDGE	256
#define WS_EX_LAYERED	0x080000
#define WINSTA_ACCESSCLIPBOARD	4
#define WINSTA_ACCESSGLOBALATOMS	32
#define WINSTA_CREATEDESKTOP	8
#define WINSTA_ENUMDESKTOPS	1
#define WINSTA_ENUMERATE	256
#define WINSTA_EXITWINDOWS	64
#define WINSTA_READATTRIBUTES	2
#define WINSTA_READSCREEN	512
#define WINSTA_WRITEATTRIBUTES	16
#define WH_CALLWNDPROC	4
#define WH_CALLWNDPROCRET	12
#define WH_KEYBOARD_LL	13
#define WH_MOUSE_LL	14
#define WH_MAX 14
#define WH_MINHOOK WH_MIN
#define WH_MAXHOOK WH_MAX
#define HC_ACTION 0
#define HC_GETNEXT 1
#define HC_ACTION	0
#define HC_GETNEXT	1
#define HC_SKIP	2
#define HC_NOREMOVE	3
#define HC_NOREM	HC_NOREMOVE
#define HC_SYSMODALON	4
#define HC_SYSMODALOFF	5
#define HCBT_MOVESIZE	0
#define HCBT_MINMAX	1
#define HCBT_QS	2
#define HCBT_CREATEWND	3
#define HCBT_DESTROYWND	4
#define HCBT_ACTIVATE	5
#define HCBT_CLICKSKIPPED	6
#define HCBT_KEYSKIPPED	7
#define HCBT_SYSCOMMAND	8
#define HCBT_SETFOCUS	9
#define HC_SYSMODALON	4
#define WH_CBT	5
#define WH_DEBUG	9
#define WH_GETMESSAGE	3
#define WH_JOURNALPLAYBACK	1
#define WH_JOURNALRECORD	0
#define WH_KEYBOARD	2
#define WH_MOUSE	7
#define WH_MSGFILTER	(-1)
#define WH_SHELL	10
#define WH_SYSMSGFILTER	6
#define WH_MIN (-1)
#define WH_FOREGROUNDIDLE	11
#define DDD_RAW_TARGET_PATH	1
#define DDD_REMOVE_DEFINITION	2
#define DDD_EXACT_MATCH_ON_REMOVE	4
#define DDD_NO_BROADCAST_SYSTEM 8
#define DDD_LUID_BROADCAST_DRIVE 16
#define DC_BINNAMES	12
#define DC_BINS	6
#define DC_COPIES	18
#define DC_DRIVER	11
#define DC_DATATYPE_PRODUCED	21
#define DC_DUPLEX	7
#define DC_EMF_COMPLIANT	20
#define DC_ENUMRESOLUTIONS	13
#define DC_EXTRA	9
#define DC_FIELDS	1
#define DC_FILEDEPENDENCIES	14
#define DC_MAXEXTENT	5
#define DC_MINEXTENT	4
#define DC_ORIENTATION	17
#define DC_PAPERNAMES	16
#define DC_PAPERS	2
#define DC_PAPERSIZE	3
#define DC_SIZE	8
#define DC_TRUETYPE	15
#define DCTT_BITMAP	1
#define DCTT_DOWNLOAD	2
#define DCTT_SUBDEV	4
#define DC_VERSION	10
#define DC_BINADJUST	19
#define DC_EMF_COMPLIANT	20
#define DC_DATATYPE_PRODUCED	21
#define DDL_ARCHIVE	32
#define DDL_DIRECTORY	16
#define DDL_DRIVES	16384
#define DDL_EXCLUSIVE	32768
#define DDL_HIDDEN	2
#define DDL_READONLY	1
#define DDL_READWRITE	0
#define DDL_SYSTEM	4
#define DDL_POSTMSGS	8192
#define DLL_PROCESS_ATTACH	1
#define DLL_THREAD_ATTACH	2
#define DLL_PROCESS_DETACH	0
#define DLL_THREAD_DETACH	3
#define DM_IN_BUFFER	8
#define DM_MODIFY	8
#define DM_IN_PROMPT	4
#define DM_PROMPT	4
#define DM_OUT_BUFFER	2
#define DM_COPY	2
#define DM_UPDATE	1
#define IDANI_OPEN	1
#define IDANI_CLOSE	2
#define DC_ACTIVE	1
#define DC_SMALLCAP	2
#define DC_ICON	4
#define DC_TEXT	8
#define DC_INBUTTON	16
#define DC_GRADIENT	32
#define BDR_RAISEDINNER	4
#define BDR_SUNKENINNER	8
#define BDR_RAISEDOUTER	1
#define BDR_SUNKENOUTER	2
#define BDR_OUTER	(BDR_RAISEDOUTER|BDR_SUNKENOUTER)
#define BDR_INNER	(BDR_RAISEDINNER|BDR_SUNKENINNER)
#define BDR_RAISED	(BDR_RAISEDOUTER|BDR_RAISEDINNER)
#define BDR_SUNKEN	(BDR_SUNKENOUTER|BDR_SUNKENINNER)
#define EDGE_BUMP	9
#define EDGE_ETCHED	6
#define EDGE_RAISED	5
#define EDGE_SUNKEN	10
#define BF_ADJUST	8192
#define BF_BOTTOM	8
#define BF_BOTTOMLEFT	9
#define BF_BOTTOMRIGHT	12
#define BF_DIAGONAL	16
#define BF_DIAGONAL_ENDBOTTOMLEFT	25
#define BF_DIAGONAL_ENDBOTTOMRIGHT	28
#define BF_DIAGONAL_ENDTOPLEFT	19
#define BF_DIAGONAL_ENDTOPRIGHT	22
#define BF_FLAT	16384
#define BF_LEFT	1
#define BF_MIDDLE	2048
#define BF_MONO	32768
#define BF_RECT	15
#define BF_RIGHT	4
#define BF_SOFT	4096
#define BF_TOP	2
#define BF_TOPLEFT	3
#define BF_TOPRIGHT	6
#define DFC_BUTTON	4
#define DFC_CAPTION	1
#define DFC_MENU	2
#define DFC_SCROLL	3
#define DFCS_BUTTON3STATE	8
#define DFCS_BUTTONCHECK	0
#define DFCS_BUTTONPUSH	16
#define DFCS_BUTTONRADIO	4
#define DFCS_BUTTONRADIOIMAGE	1
#define DFCS_BUTTONRADIOMASK	2
#define DFCS_CAPTIONCLOSE	0
#define DFCS_CAPTIONHELP	4
#define DFCS_CAPTIONMAX	2
#define DFCS_CAPTIONMIN	1
#define DFCS_CAPTIONRESTORE	3
#define DFCS_MENUARROW	0
#define DFCS_MENUBULLET	2
#define DFCS_MENUCHECK	1
#define DFCS_SCROLLCOMBOBOX	5
#define DFCS_SCROLLDOWN	1
#define DFCS_SCROLLLEFT	2
#define DFCS_SCROLLRIGHT	3
#define DFCS_SCROLLSIZEGRIP	8
#define DFCS_SCROLLUP	0
#define DFCS_ADJUSTRECT	8192
#define DFCS_CHECKED	1024
#define DFCS_FLAT	16384
#define DFCS_INACTIVE	256
#define DFCS_MONO	32768
#define DFCS_PUSHED	512
#define DI_COMPAT	4
#define DI_DEFAULTSIZE	8
#define DI_IMAGE	2
#define DI_MASK	1
#define DI_NORMAL	3
#define DST_BITMAP	4
#define DST_COMPLEX	0
#define DST_ICON	3
#define DST_PREFIXTEXT	2
#define DST_TEXT	1
#define DSS_NORMAL	0
#define DSS_UNION	16
#define DSS_DISABLED	32
#define DSS_MONO	128
#define SBT_NOBORDERS	256
#define SBT_OWNERDRAW	4096
#define SBT_POPOUT	512
#define SBT_RTLREADING	1024
#define SBT_TOOLTIPS	0x800
#define SB_SIMPLEID	0x00ff
#define DT_BOTTOM	8
#define DT_CALCRECT	1024
#define DT_CENTER	1
#define DT_EDITCONTROL	8192
#define DT_END_ELLIPSIS	32768
#define DT_PATH_ELLIPSIS	16384
#define DT_EXPANDTABS	64
#define DT_EXTERNALLEADING	512
#define DT_LEFT	0
#define DT_MODIFYSTRING	65536
#define DT_NOCLIP	256
#define DT_NOPREFIX	2048
#define DT_RIGHT	2
#define DT_RTLREADING	131072
#define DT_SINGLELINE	32
#define DT_TABSTOP	128
#define DT_TOP	0
#define DT_VCENTER	4
#define DT_WORDBREAK	16
#define DT_INTERNAL	4096
#define DT_WORD_ELLIPSIS	0x40000
#define DT_NOFULLWIDTHCHARBREAK	0x80000
#define DT_HIDEPREFIX	0x100000
#define DT_PREFIXONLY	0x200000
#define DUPLICATE_CLOSE_SOURCE	1
#define DUPLICATE_SAME_ACCESS	2
#define FILE_MAP_ALL_ACCESS	0xf001f
#define FILE_MAP_READ	4
#define FILE_MAP_WRITE	2
#define FILE_MAP_COPY	1
#define MUTEX_ALL_ACCESS	0x1f0001
#define MUTEX_MODIFY_STATE	1
#define SYNCHRONIZE	0x100000
#define SEMAPHORE_ALL_ACCESS	0x1f0003
#define SEMAPHORE_MODIFY_STATE	2
#define S_NORMAL 0
#define S_LEGATO 1
#define S_STACCATO 2
#define S_PERIOD512 0
#define S_PERIOD1024 1
#define S_PERIOD2048 2
#define S_PERIODVOICE 3
#define S_SERDVNA (-1)
#define S_SEROFM (-2)
#define S_SERMACT (-3)
#define S_SERQFUL (-4)
#define S_SERBDNT (-5)
#define S_SERDLN (-6)
#define S_SERDCC (-7)
#define S_SERDTP (-8)
#define S_SERDV  (-9)
#define S_SERDMD (-10)
#define S_SERDSH (-11)
#define S_SERDPT (-12)
#define S_SERDFQ (-13)
#define S_SERDDR (-14)
#define S_SERDSR (-15)
#define S_SERDST (-16)
#define S_WHITE512 4
#define S_WHITE1024 5
#define S_WHITE2048 6
#define S_WHITEVOICE 7
#define EVENT_ALL_ACCESS	0x1f0003
#define EVENT_MODIFY_STATE	2
#define KEY_ALL_ACCESS	0xf003f
#define KEY_CREATE_LINK	32
#define KEY_CREATE_SUB_KEY	4
#define KEY_ENUMERATE_SUB_KEYS	8
#define KEY_EXECUTE	0x20019
#define KEY_NOTIFY	16
#define KEY_QUERY_VALUE	1
#define KEY_READ	0x20019
#define KEY_SET_VALUE	2
#define KEY_WRITE	0x20006
#define PROCESS_ALL_ACCESS	0x1f0fff
#define PROCESS_CREATE_PROCESS	128
#define PROCESS_CREATE_THREAD	2
#define PROCESS_DUP_HANDLE	64
#define PROCESS_QUERY_INFORMATION	1024
#define PROCESS_SET_INFORMATION	512
#define PROCESS_TERMINATE	1
#define PROCESS_VM_OPERATION	8
#define PROCESS_VM_READ	16
#define PROCESS_VM_WRITE	32
#define THREAD_ALL_ACCESS	0x1f03ff
#define THREAD_DIRECT_IMPERSONATION	512
#define THREAD_GET_CONTEXT	8
#define THREAD_IMPERSONATE	256
#define THREAD_QUERY_INFORMATION	64
#define THREAD_SET_CONTEXT	16
#define THREAD_SET_INFORMATION	32
#define THREAD_SET_THREAD_TOKEN	128
#define THREAD_SUSPEND_RESUME	2
#define THREAD_TERMINATE	1
#define WB_ISDELIMITER	2
#define WB_LEFT	0
#define WB_RIGHT	1
#define SB_BOTH	3
#define SB_CTL	2
#define SB_HORZ	0
#define SB_VERT	1
#define ESB_DISABLE_BOTH	3
#define ESB_DISABLE_DOWN	2
#define ESB_DISABLE_LEFT	1
#define ESB_DISABLE_LTUP	1
#define ESB_DISABLE_RIGHT	2
#define ESB_DISABLE_RTDN	2
#define ESB_DISABLE_UP	1
#define ESB_ENABLE_BOTH	0
#define SB_LINEUP	0
#define SB_LINEDOWN	1
#define SB_LINELEFT	0
#define SB_LINERIGHT	1
#define SB_PAGEUP	2
#define SB_PAGEDOWN	3
#define SB_PAGELEFT	2
#define SB_PAGERIGHT	3
#define SB_THUMBPOSITION	4
#define SB_THUMBTRACK	5
#define SB_ENDSCROLL	8
#define SB_LEFT	6
#define SB_RIGHT	7
#define SB_BOTTOM	7
#define SB_TOP	6
#define ENUM_ALL_CALENDARS	0xffffffff
#define DATE_SHORTDATE	1
#define DATE_LONGDATE	2
#define SERVICE_ACTIVE	1
#define SERVICE_INACTIVE	2
#define DEVICE_FONTTYPE	2
#define RASTER_FONTTYPE	1
#define TRUETYPE_FONTTYPE	4
#define OBJ_BRUSH	2
#define OBJ_PEN	1
#define OBJ_PAL	5
#define OBJ_FONT	6
#define OBJ_BITMAP	7
#define OBJ_EXTPEN	11
#define OBJ_REGION	8
#define OBJ_DC	3
#define OBJ_MEMDC	10
#define OBJ_METAFILE	9
#define OBJ_METADC	4
#define OBJ_ENHMETAFILE	13
#define OBJ_COLORSPACE	14
#define OBJ_ENHMETADC	12
#define IPPROTO_TCP	6
#define IPPROTO_UDP	17
#define RT_ACCELERATOR	MAKEINTRESOURCE(9)
#define RT_BITMAP	MAKEINTRESOURCE(2)
#define RT_DIALOG	MAKEINTRESOURCE(5)
#define RT_FONT	MAKEINTRESOURCE(8)
#define RT_FONTDIR	MAKEINTRESOURCE(7)
#define RT_MENU	MAKEINTRESOURCE(4)
#define RT_RCDATA	MAKEINTRESOURCE(0xa)
#define RT_STRING	MAKEINTRESOURCE(0x6)
#define RT_MESSAGETABLE	MAKEINTRESOURCE(0xb)
#define RT_CURSOR	MAKEINTRESOURCE(1)
#define RT_GROUP_CURSOR	MAKEINTRESOURCE(0xc)
#define RT_ICON	MAKEINTRESOURCE(3)
#define RT_GROUP_ICON	MAKEINTRESOURCE(0xe)
#define RT_VERSION	MAKEINTRESOURCE(16)
#define RT_VXD		MAKEINTRESOURCE(20)
#define RT_ANICURSOR	MAKEINTRESOURCE(21)
#define RT_ANIICON	MAKEINTRESOURCE(22)
#define RT_HTML		MAKEINTRESOURCE(23)
#define RT_DLGINCLUDE MAKEINTRESOURCE(0x11)
#define RT_PLUGPLAY	MAKEINTRESOURCE(19)
#define RT_HTML	MAKEINTRESOURCE(23)
#define SERVICE_WIN32	48
#define SERVICE_DRIVER	11
#define CP_INSTALLED	1
#define CP_SUPPORTED	2
#define LCID_INSTALLED	1
#define LCID_SUPPORTED	2
#define TAPE_ERASE_LONG	1
#define TAPE_ERASE_SHORT	0
#define PR_JOBSTATUS	0
#define SP_NOTREPORTED	0x4000
#define SP_ERROR	(-1)
#define SP_OUTOFDISK	(-4)
#define SP_OUTOFMEMORY	(-5)
#define SP_USERABORT	(-3)
#define SP_APPABORT	(-2)
#define PHYSICALWIDTH	110
#define PHYSICALHEIGHT	111
#define PHYSICALOFFSETX	112
#define PHYSICALOFFSETY	113
#define SCALINGFACTORX	114
#define SCALINGFACTORY	115
#define QUERYESCSUPPORT	8
#define ABORTDOC	2
#define ENDDOC	11
#define GETPHYSPAGESIZE	12
#define GETPRINTINGOFFSET	13
#define GETSCALINGFACTOR	14
#define NEWFRAME	1
#define NEXTBAND	3
#define PASSTHROUGH	19
#define SETABORTPROC	9
#define STARTDOC	10
#define SETCOLORTABLE	4
#define GETCOLORTABLE	5
#define FLUSHOUTPUT	6
#define DRAFTMODE	7
#define MFCOMMENT	15
#define GETPENWIDTH	16
#define SETCOPYCOUNT	17
#define SELECTPAPERSOURCE	18
#define DEVICEDATA	19
#define GETTECHNOLGY	20
#define GETTECHNOLOGY	20
#define SETLINECAP	21
#define SETLINEJOIN	22
#define SETMITERLIMIT	23
#define BANDINFO	24
#define DRAWPATTERNRECT	25
#define GETVECTORPENSIZE	26
#define GETVECTORBRUSHSIZE	27
#define ENABLEDUPLEX	28
#define GETSETPAPERBINS	29
#define GETSETPRINTORIENT	30
#define ENUMPAPERBINS	31
#define SETDIBSCALING	32
#define EPSPRINTING	33
#define ENUMPAPERMETRICS	34
#define GETSETPAPERMETRICS	35
#define POSTSCRIPT_DATA	37
#define POSTSCRIPT_IGNORE	38
#define MOUSETRAILS	39
#define GETDEVICEUNITS	42
#define GETEXTENDEDTEXTMETRICS	256
#define GETEXTENTTABLE	257
#define GETPAIRKERNTABLE	258
#define GETTRACKKERNTABLE	259
#define EXTTEXTOUT	512
#define GETFACENAME	513
#define DOWNLOADFACE	514
#define ENABLERELATIVEWIDTHS	768
#define ENABLEPAIRKERNING	769
#define SETKERNTRACK	770
#define SETALLJUSTVALUES	771
#define SETCHARSET	772
#define STRETCHBLT	2048
#define METAFILE_DRIVER	2049
#define GETSETSCREENPARAMS	3072
#define QUERYDIBSUPPORT	3073
#define BEGIN_PATH	4096
#define CLIP_TO_PATH	4097
#define END_PATH	4098
#define EXT_DEVICE_CAPS	4099
#define RESTORE_CTM	4100
#define SAVE_CTM	4101
#define SET_ARC_DIRECTION	4102
#define SET_BACKGROUND_COLOR	4103
#define SET_POLY_MODE	4104
#define SET_SCREEN_ANGLE	4105
#define SET_SPREAD	4106
#define TRANSFORM_CTM	4107
#define SET_CLIP_BOX	4108
#define SET_BOUNDS	4109
#define SET_MIRROR_MODE	4110
#define OPENCHANNEL	4110
#define DOWNLOADHEADER	4111
#define CLOSECHANNEL	4112
#define POSTSCRIPT_PASSTHROUGH	4115
#define ENCAPSULATED_POSTSCRIPT	4116
#define POSTSCRIPT_IDENTIFY	4117
#define POSTSCRIPT_INJECTION	4118
#define CHECKJPEGFORMAT	4119
#define CHECKPNGFORMAT	4120
#define GET_PS_FEATURESETTING	4121
#define SPCLPASSTHROUGH2	4568
#define PSIDENT_GDICENTRIC	0
#define PSIDENT_PSCENTRIC	1
#define PSINJECT_BEGINSTREAM	1
#define PSINJECT_PSADOBE	2
#define PSINJECT_PAGESATEND	3
#define PSINJECT_PAGES	4
#define PSINJECT_DOCNEEDEDRES	5
#define PSINJECT_DOCSUPPLIEDRES	6
#define PSINJECT_PAGEORDER	7
#define PSINJECT_ORIENTATION	8
#define PSINJECT_BOUNDINGBOX	9
#define PSINJECT_DOCUMENTPROCESSCOLORS	10
#define PSINJECT_COMMENTS	11
#define PSINJECT_BEGINDEFAULTS	12
#define PSINJECT_ENDDEFAULTS	13
#define PSINJECT_BEGINPROLOG	14
#define PSINJECT_ENDPROLOG	15
#define PSINJECT_BEGINSETUP	16
#define PSINJECT_ENDSETUP	17
#define PSINJECT_TRAILER	18
#define PSINJECT_EOF	19
#define PSINJECT_ENDSTREAM	20
#define PSINJECT_DOCUMENTPROCESSCOLORSATEND 21
#define PSINJECT_PAGENUMBER	100
#define PSINJECT_BEGINPAGESETUP	101
#define PSINJECT_ENDPAGESETUP	102
#define PSINJECT_PAGETRAILER	103
#define PSINJECT_PLATECOLOR	104
#define PSINJECT_SHOWPAGE	105
#define PSINJECT_PAGEBBOX	106
#define PSINJECT_ENDPAGECOMMENTS 107
#define PSINJECT_VMSAVE	200
#define PSINJECT_VMRESTORE	201
#define FEATURESETTING_NUP	0
#define FEATURESETTING_OUTPUT	1
#define FEATURESETTING_PSLEVEL	2
#define FEATURESETTING_CUSTPAPER 3
#define FEATURESETTING_MIRROR	4
#define FEATURESETTING_NEGATIVE	5
#define FEATURESETTING_PROTOCOL	6
#define PSPROTOCOL_ASCII	0
#define PSPROTOCOL_BCP	1
#define PSPROTOCOL_TBCP	2
#define PSPROTOCOL_BINARY	3
#define CLRDTR	6
#define CLRRTS	4
#define SETDTR	5
#define SETRTS	3
#define SETXOFF	1
#define SETXON	2
#define RESETDEV 7
#define SETBREAK	8
#define CLRBREAK	9
#define EWX_FORCE	4
#define EWX_LOGOFF	0
#define EWX_POWEROFF	8
#define EWX_REBOOT	2
#define EWX_SHUTDOWN	1
#define FLOODFILLBORDER	0
#define FLOODFILLSURFACE	1
#define ETO_CLIPPED	4
#define ETO_GLYPH_INDEX	16
#define ETO_OPAQUE	2
#define ETO_RTLREADING	128
#define ETO_PDY	0x2000
#define ETO_NUMERICSLOCAL	0x0400
#define ETO_NUMERICSLATIN	0x0800
#define ETO_IGNORELANGUAGE	0x1000
#define ASPECT_FILTERING	1
#define FOREGROUND_BLUE	1
#define FOREGROUND_GREEN	2
#define FOREGROUND_RED	4
#define FOREGROUND_INTENSITY	8
#define BACKGROUND_BLUE	16
#define BACKGROUND_GREEN	32
#define BACKGROUND_RED	64
#define BACKGROUND_INTENSITY	128
#define FILE_NOTIFY_CHANGE_FILE_NAME	1
#define FILE_NOTIFY_CHANGE_DIR_NAME	2
#define FILE_NOTIFY_CHANGE_ATTRIBUTES	4
#define FILE_NOTIFY_CHANGE_SIZE	8
#define FILE_NOTIFY_CHANGE_LAST_WRITE	16
#define FILE_NOTIFY_CHANGE_LAST_ACCESS 0x20
#define FILE_NOTIFY_CHANGE_CREATION 0x40
#define FILE_NOTIFY_CHANGE_SECURITY 256
#define FILE_ACTION_ADDED 1
#define FILE_ACTION_REMOVED 2
#define FILE_ACTION_MODIFIED	3
#define FILE_ACTION_RENAMED_OLD_NAME	4
#define FILE_ACTION_RENAMED_NEW_NAME	5
#define FILE_CASE_SENSITIVE_SEARCH	1
#define FILE_CASE_PRESERVED_NAMES	2
#define FILE_UNICODE_ON_DISK	4
#define FILE_PERSISTENT_ACLS	8
#define FILE_FILE_COMPRESSION	16
#define FILE_VOLUME_QUOTAS	32
#define FILE_SUPPORTS_SPARSE_FILES	0x40
#define FILE_SUPPORTS_REPARSE_POINTS	0x80
#define FILE_SUPPORTS_REMOTE_STORAGE	0x100
#define FILE_VOLUME_IS_COMPRESSED	0x08000
#define FILE_SUPPORTS_OBJECT_IDS	0x10000
#define FILE_SUPPORTS_ENCRYPTION	0x20000
#define MAP_FOLDCZONE	16
#define MAP_FOLDDIGITS	128
#define MAP_PRECOMPOSED	32
#define MAP_COMPOSITE	64
#define HC_ACTION	0
#define FORMAT_MESSAGE_ALLOCATE_BUFFER	256
#define FORMAT_MESSAGE_IGNORE_INSERTS	512
#define FORMAT_MESSAGE_FROM_STRING	1024
#define FORMAT_MESSAGE_FROM_HMODULE	2048
#define FORMAT_MESSAGE_FROM_SYSTEM	4096
#define FORMAT_MESSAGE_ARGUMENT_ARRAY	8192
#define FORMAT_MESSAGE_MAX_WIDTH_MASK	255
#define GDICOMMENT_WINDOWS_METAFILE	(-2147483647)
#define GDICOMMENT_BEGINGROUP	2
#define GDICOMMENT_ENDGROUP	3
#define GDICOMMENT_MULTIFORMATS	1073741828
#define GDICOMMENT_IDENTIFIER	1128875079
#define CTRL_C_EVENT	0
#define CTRL_BREAK_EVENT	1
#define CTRL_CLOSE_EVENT	2
#define CTRL_LOGOFF_EVENT	5
#define CTRL_SHUTDOWN_EVENT	6
#define AD_COUNTERCLOCKWISE	1
#define AD_CLOCKWISE	2
#define SCS_32BIT_BINARY	0
#define SCS_DOS_BINARY	1
#define SCS_OS216_BINARY	5
#define SCS_PIF_BINARY	3
#define SCS_POSIX_BINARY	4
#define SCS_WOW_BINARY	2
#define SCS_OS216_BINARY 5
#define SCS_64BIT_BINARY 6
#define DCB_DISABLE	8
#define DCB_ENABLE	4
#define DCB_RESET	1
#define DCB_SET	3
#define DCB_ACCUMULATE	2
#define DCB_DIRTY	DCB_ACCUMULATE
#define GCP_DBCS	1
#define GCP_ERROR	0x8000
#define GCP_CLASSIN	0x80000
#define GCP_DIACRITIC	256
#define GCP_DISPLAYZWG	0x400000
#define GCP_GLYPHSHAPE	16
#define GCP_JUSTIFY	0x10000
#define GCP_JUSTIFYIN	0x200000
#define GCP_KASHIDA	1024
#define GCP_LIGATE	32
#define GCP_MAXEXTENT	0x100000
#define GCP_NEUTRALOVERRIDE	0x2000000
#define GCP_NUMERICOVERRIDE	0x1000000
#define GCP_NUMERICSLATIN	0x4000000
#define GCP_NUMERICSLOCAL	0x8000000
#define GCP_REORDER	2
#define GCP_SYMSWAPOFF	0x800000
#define GCP_USEKERNING	8
#define FLI_GLYPHS	0x40000
#define FLI_MASK	0x103b
#define GCW_ATOM	(-32)
#define GCL_CBCLSEXTRA	(-20)
#define GCL_CBWNDEXTRA	(-18)
#define GCL_HBRBACKGROUND	(-10)
#define GCL_HCURSOR	(-12)
#define GCL_HICON	(-14)
#define GCL_HICONSM	(-34)
#define GCL_HMODULE	(-16)
#define GCL_MENUNAME	(-8)
#define GCL_STYLE	(-26)
#define GCL_WNDPROC	(-24)
#define GCLP_MENUNAME	(-8)
#define GCLP_HBRBACKGROUND	(-10)
#define GCLP_HCURSOR	(-12)
#define GCLP_HICON	(-14)
#define GCLP_HMODULE	(-16)
#define GCLP_WNDPROC	(-24)
#define GCLP_HICONSM	(-34)
#define CF_BITMAP	2
#define CF_DIB	8
#define CF_PALETTE	9
#define CF_ENHMETAFILE	14
#define CF_METAFILEPICT	3
#define CF_OEMTEXT	7
#define CF_TEXT	1
#define CF_UNICODETEXT	13
#define CF_DIF	5
#define CF_DSPBITMAP	130
#define CF_DSPENHMETAFILE	142
#define CF_DSPMETAFILEPICT	131
#define CF_DSPTEXT	129
#define CF_GDIOBJFIRST	768
#define CF_GDIOBJLAST	1023
#define CF_HDROP	15
#define CF_LOCALE	16
#define CF_OWNERDISPLAY	128
#define CF_PENDATA	10
#define CF_PRIVATEFIRST	512
#define CF_PRIVATELAST	767
#define CF_RIFF	11
#define CF_SYLK	4
#define CF_WAVE	12
#define CF_TIFF	6
#define EV_BREAK	64
#define EV_CTS	8
#define EV_DSR	16
#define EV_ERR	128
#define EV_EVENT1	2048
#define EV_EVENT2	4096
#define EV_PERR	512
#define EV_RING	256
#define EV_RLSD	32
#define EV_RX80FULL	1024
#define EV_RXCHAR	1
#define EV_RXFLAG	2
#define EV_TXEMPTY	4
#define MS_CTS_ON	16
#define MS_DSR_ON	32
#define MS_RING_ON	64
#define MS_RLSD_ON	128
#define MAX_COMPUTERNAME_LENGTH	15
#define ENABLE_LINE_INPUT	2
#define ENABLE_ECHO_INPUT	4
#define ENABLE_PROCESSED_INPUT	1
#define ENABLE_WINDOW_INPUT	8
#define ENABLE_MOUSE_INPUT	16
#define ENABLE_PROCESSED_OUTPUT	1
#define ENABLE_WRAP_AT_EOL_OUTPUT	2
#define CP_ACP	0
#define CP_MACCP	2
#define CP_OEMCP	1
#define CP_THREAD_ACP 3
#define CP_SYMBOL 42
#define CP_UTF7 65000
#define CP_UTF8 65001
#define DATE_SHORTDATE	1
#define DATE_LONGDATE	2
#define DATE_USE_ALT_CALENDAR	4
#define DCX_WINDOW	1
#define DCX_CACHE	2
#define DCX_PARENTCLIP	32
#define DCX_CLIPSIBLINGS	16
#define DCX_CLIPCHILDREN	8
#define DCX_NORESETATTRS	4
#define DCX_LOCKWINDOWUPDATE	0x400
#define DCX_EXCLUDERGN	64
#define DCX_INTERSECTRGN	128
#define DCX_VALIDATE	0x200000
#define DRIVERVERSION	0
#define TECHNOLOGY	2
#define DT_PLOTTER	0
#define DT_RASDISPLAY	1
#define DT_RASPRINTER	2
#define DT_RASCAMERA	3
#define DT_CHARSTREAM	4
#define DT_METAFILE	5
#define DT_DISPFILE	6
#define HORZSIZE	4
#define VERTSIZE	6
#define HORZRES	8
#define VERTRES	10
#define LOGPIXELSX	88
#define LOGPIXELSY	90
#define BITSPIXEL	12
#define PLANES	14
#define NUMBRUSHES	16
#define NUMPENS	18
#define NUMFONTS	22
#define NUMCOLORS	24
#define	NUMMARKERS	20
#define ASPECTX	40
#define ASPECTY	42
#define ASPECTXY	44
#define PDEVICESIZE	26
#define CLIPCAPS	36
#define SIZEPALETTE	104
#define NUMRESERVED	106
#define COLORRES	108
#define VREFRESH	116
#define DESKTOPHORZRES	118
#define DESKTOPVERTRES	117
#define BLTALIGNMENT	119
#define RASTERCAPS	38
#define RC_BANDING	2
#define RC_BITBLT	1
#define RC_BITMAP64	8
#define RC_DI_BITMAP	128
#define RC_DIBTODEV	512
#define RC_FLOODFILL	4096
#define RC_GDI20_OUTPUT	16
#define RC_PALETTE	256
#define RC_SCALING	4
#define RC_STRETCHBLT	2048
#define RC_STRETCHDIB	8192
#define RC_DEVBITS	0x8000
#define RC_OP_DX_OUTPUT	0x4000
#define CURVECAPS	28
#define CC_NONE	0
#define CC_CIRCLES	1
#define CC_PIE	2
#define CC_CHORD	4
#define CC_ELLIPSES	8
#define CC_WIDE	16
#define CC_STYLED	32
#define CC_WIDESTYLED	64
#define CC_INTERIORS	128
#define CC_ROUNDRECT	256
#define LINECAPS	30
#define LC_NONE	0
#define LC_POLYLINE	2
#define LC_MARKER	4
#define LC_POLYMARKER	8
#define LC_WIDE	16
#define LC_STYLED	32
#define LC_WIDESTYLED	64
#define LC_INTERIORS	128
#define POLYGONALCAPS	32
#define RC_BANDING	2
#define RC_BIGFONT	1024
#define RC_BITBLT	1
#define RC_BITMAP64	8
#define RC_DEVBITS	0x8000
#define RC_DI_BITMAP	128
#define RC_GDI20_OUTPUT	16
#define RC_GDI20_STATE	32
#define RC_NONE	0
#define RC_OP_DX_OUTPUT	0x4000
#define RC_PALETTE	256
#define RC_SAVEBITMAP	64
#define RC_SCALING	4
#define PC_NONE	0
#define PC_POLYGON	1
#define PC_POLYPOLYGON	256
#define PC_PATHS	512
#define PC_RECTANGLE	2
#define PC_WINDPOLYGON	4
#define PC_SCANLINE	8
#define PC_TRAPEZOID	4
#define PC_WIDE	16
#define PC_STYLED	32
#define PC_WIDESTYLED	64
#define PC_INTERIORS	128
#define TEXTCAPS	34
#define TC_OP_CHARACTER	1
#define TC_OP_STROKE	2
#define TC_CP_STROKE	4
#define TC_CR_90	8
#define TC_CR_ANY	16
#define TC_SF_X_YINDEP	32
#define TC_SA_DOUBLE	64
#define TC_SA_INTEGER	128
#define TC_SA_CONTIN	256
#define TC_EA_DOUBLE	512
#define TC_IA_ABLE	1024
#define TC_UA_ABLE	2048
#define TC_SO_ABLE	4096
#define TC_RA_ABLE	8192
#define TC_VA_ABLE	16384
#define TC_RESERVED	32768
#define TC_SCROLLBLT	65536
#define PC_PATHS	512
#define CP_NONE	0
#define CP_RECTANGLE	1
#define CP_REGION	2
#define DRIVE_REMOVABLE	2
#define DRIVE_FIXED	3
#define DRIVE_REMOTE	4
#define DRIVE_CDROM	5
#define DRIVE_RAMDISK	6
#define DRIVE_UNKNOWN	0
#define DRIVE_NO_ROOT_DIR	1
#define EXCEPTION_ACCESS_VIOLATION	0xc0000005
#define EXCEPTION_BREAKPOINT	0x80000003
#define EXCEPTION_DATATYPE_MISALIGNMENT	0x80000002
#define EXCEPTION_SINGLE_STEP	0x80000004
#define EXCEPTION_ARRAY_BOUNDS_EXCEEDED	0xc000008c
#define EXCEPTION_FLT_DENORMAL_OPERAND	0xc000008d
#define EXCEPTION_FLT_DIVIDE_BY_ZERO	0xc000008e
#define EXCEPTION_FLT_INEXACT_RESULT	0xc000008f
#define EXCEPTION_FLT_INVALID_OPERATION	0xc0000090
#define EXCEPTION_FLT_OVERFLOW	0xc0000091
#define EXCEPTION_FLT_STACK_CHECK	0xc0000092
#define EXCEPTION_FLT_UNDERFLOW	0xc0000093
#define EXCEPTION_INT_DIVIDE_BY_ZERO	0xc0000094
#define EXCEPTION_INT_OVERFLOW	0xc0000095
#define EXCEPTION_PRIV_INSTRUCTION	0xc0000096
#define EXCEPTION_IN_PAGE_ERROR		0xC0000025
#define EXCEPTION_ILLEGAL_INSTRUCTION     STATUS_ILLEGAL_INSTRUCTION
#define EXCEPTION_INVALID_HANDLE        STATUS_INVALID_HANDLE
#define EXCEPTION_NONCONTINUABLE_EXCEPTION	0xc0000025
#define EXCEPTION_NONCONTINUABLE	1
#define EXCEPTION_STACK_OVERFLOW	0xc00000fd
#define EXCEPTION_INVALID_DISPOSITION	0xc0000026
#define EXCEPTION_POSSIBLE_DEADLOCK 0xC0000194L
#define CS_ENABLE 1
#define CS_DISABLE 2
#define CS_DELETE_TRANSFORM 3
#define LCS_SIGNATURE 'PSOC'
#define LCS_sRGB 'sRGB'
#define LCS_WINDOWS_COLOR_SPACE 'Win '
#define LCS_CALIBRATED_RGB	0
#define LCS_DEVICE_RGB	1
#define LCS_DEVICE_CMYK	2
#define LCS_GM_BUSINESS	1
#define LCS_GM_GRAPHICS	2
#define LCS_GM_IMAGES	4
#define ICM_ADDPROFILE	1
#define ICM_DELETEPROFILE	2
#define ICM_QUERYPROFILE	3
#define ICM_SETDEFAULTPROFILE	4
#define ICM_REGISTERICMATCHER	5
#define ICM_UNREGISTERICMATCHER 6
#define ICM_QUERYMATCH	7
#define CM_OUT_OF_GAMUT	255
#define CM_IN_GAMUT	0
#define FILE_TYPE_UNKNOWN	0
#define FILE_TYPE_DISK	1
#define FILE_TYPE_CHAR	2
#define FILE_TYPE_PIPE	3
#define FILE_TYPE_REMOTE 0x8000
#define GGO_BITMAP	1
#define GGO_NATIVE	2
#define GGO_METRICS	0
#define GGO_GRAY2_BITMAP	4
#define GGO_GRAY4_BITMAP	5
#define GGO_GRAY8_BITMAP	6
#define GDI_ERROR	0xffffffff
#define HGDI_ERROR (LongToHandle(0xFFFFFFFFL))
#define GM_COMPATIBLE	1
#define GM_ADVANCED	2

//#if(WINVER >= 0x0500)
#define WS_EX_NOINHERITLAYOUT  0x00100000L
#define WS_EX_LAYOUTRTL      0x00400000L
//#endif

//#if(_WIN32_WINNT >= 0x0501)
#define WS_EX_COMPOSITED     0x02000000L
//#endif
//#if(_WIN32_WINNT >= 0x0500)
#define WS_EX_NOACTIVATE     0x08000000L
//#endif
#define HANDLE_FLAG_INHERIT	1
#define HANDLE_FLAG_PROTECT_FROM_CLOSE	2
#define IE_BADID  (-1)
#define IE_OPEN   (-2)
#define IE_NOPEN  (-3)
#define IE_MEMORY (-4)
#define IE_DEFAULT (-5)
#define IE_HARDWARE (-10)
#define IE_BYTESIZE (-11)
#define IE_BAUDRATE (-12)
#define IDC_HAND	MAKEINTRESOURCE(32649)
#define IDC_ARROW	MAKEINTRESOURCE(32512)
#define IDC_IBEAM	MAKEINTRESOURCE(32513)
#define IDC_WAIT	MAKEINTRESOURCE(32514)
#define IDC_CROSS	MAKEINTRESOURCE(32515)
#define IDC_UPARROW	MAKEINTRESOURCE(32516)
#define IDC_SIZENWSE	MAKEINTRESOURCE(32642)
#define IDC_SIZENESW	MAKEINTRESOURCE(32643)
#define IDC_SIZEWE	MAKEINTRESOURCE(32644)
#define IDC_SIZENS	MAKEINTRESOURCE(32645)
#define IDC_SIZEALL	MAKEINTRESOURCE(32646)
#define IDC_ICON	MAKEINTRESOURCE(32641)
#define IDC_SIZE	MAKEINTRESOURCE(32640)
#define IDC_NO	MAKEINTRESOURCE(32648)
#define IDC_APPSTARTING	MAKEINTRESOURCE(32650)
#define IDC_HELP	MAKEINTRESOURCE(32651)
#define IDI_APPLICATION	MAKEINTRESOURCE(32512)
#define IDI_HAND	MAKEINTRESOURCE(32513)
#define IDI_QUESTION	MAKEINTRESOURCE(32514)
#define IDI_EXCLAMATION	MAKEINTRESOURCE(32515)
#define IDI_ASTERISK	MAKEINTRESOURCE(32516)
#define IDI_WINLOGO	MAKEINTRESOURCE(32517)
#define IDI_WARNING	IDI_EXCLAMATION
#define IDI_ERROR	IDI_HAND
#define IDI_INFORMATION IDI_ASTERISK
#define MM_ANISOTROPIC	8
#define MM_HIENGLISH	5
#define MM_HIMETRIC	3
#define MM_ISOTROPIC	7
#define MM_LOENGLISH	4
#define MM_LOMETRIC	2
#define MM_TEXT	1
#define MM_TWIPS	6
#define GMDI_GOINTOPOPUPS	2
#define GMDI_USEDISABLED	1
#define PM_NOREMOVE	0
#define PM_REMOVE	1
#define PM_NOYIELD	2
#define PIPE_NOWAIT	1
#define PIPE_READMODE_MESSAGE	2
#define PIPE_CLIENT_END	0
#define PIPE_SERVER_END	1
#define GW_HWNDNEXT	2
#define GW_HWNDPREV	3
#define GW_CHILD	5
#define GW_HWNDFIRST	0
#define GW_HWNDLAST	1
#define GW_OWNER	4
#define GetNextWindow(HWND,cmd) GetWindow(HWND,cmd)
#define PT_MOVETO	6
#define PT_LINETO	2
#define PT_BEZIERTO	4
#define PT_CLOSEFIGURE	1
#define SHUTDOWN_NORETRY	1
#define QS_ALLEVENTS	191
#define QS_ALLINPUT	255
#define QS_HOTKEY	128
#define QS_INPUT	7
#define QS_KEY	1
#define QS_MOUSE	6
#define QS_MOUSEBUTTON	4
#define QS_MOUSEMOVE	2
#define QS_PAINT	32
#define QS_POSTMESSAGE	8
#define QS_SENDMESSAGE	64
#define QS_TIMER	16
#define SIF_TRACKPOS	16
#define SIF_PAGE	2
#define SIF_POS	4
#define SIF_RANGE	1
#define SIF_DISABLENOSCROLL	8
#define SIF_ALL	(SIF_RANGE|SIF_PAGE|SIF_POS|SIF_TRACKPOS)
//#ifndef __stdio_h__
#define STD_INPUT_HANDLE	(DWORD)(0xfffffff6)
#define STD_OUTPUT_HANDLE	(DWORD)(0xfffffff5)
#define STD_ERROR_HANDLE	(DWORD)(0xfffffff4)
//#endif
#define INVALID_HANDLE_VALUE	(HANDLE)(0xffffffff)
#define INVALID_FILE_SIZE ((DWORD)0xFFFFFFFF)
#define INVALID_SET_FILE_POINTER ((DWORD)-1)
#define INVALID_FILE_ATTRIBUTES ((DWORD)-1)
#define BLACK_BRUSH	4
#define DKGRAY_BRUSH	3
#define GRAY_BRUSH	2
#define HOLLOW_BRUSH	5
#define LTGRAY_BRUSH	1
#define NULL_BRUSH	5
#define WHITE_BRUSH	0
#define BLACK_PEN	7
#define NULL_PEN	8
#define WHITE_PEN	6
#define ANSI_FIXED_FONT	11
#define ANSI_VAR_FONT	12
#define DEVICE_DEFAULT_FONT	14
#define DEFAULT_GUI_FONT	17
#define OEM_FIXED_FONT	10
#define SYSTEM_FONT	13
#define SYSTEM_FIXED_FONT	16

//#if(WINVER >= 0x0400)
#define DEFAULT_GUI_FONT	17
//#endif
#define DC_BRUSH        18
#define DC_PEN         19
//#if (_WIN32_WINNT >= _WIN32_WINNT_WIN2K)
#define STOCK_LAST       19
//#elif (WINVER >= 0x0400)
//#define STOCK_LAST       17
//#else
//#define STOCK_LAST       16
//#endif

#define DEFAULT_PALETTE	15
#define CT_CTYPE1	1
#define CT_CTYPE2	2
#define CT_CTYPE3	4
#define C1_UPPER	1
#define C1_LOWER	2
#define C1_DIGIT	4
#define C1_SPACE	8
#define C1_PUNCT	16
#define C1_CNTRL	32
#define C1_BLANK	64
#define C1_XDIGIT	128
#define C1_ALPHA	256
#define C2_LEFTTORIGHT	1
#define C2_RIGHTTOLEFT	2
#define C2_EUROPENUMBER	3
#define C2_EUROPESEPARATOR	4
#define C2_EUROPETERMINATOR	5
#define C2_ARABICNUMBER	6
#define C2_COMMONSEPARATOR	7
#define C2_BLOCKSEPARATOR	8
#define C2_SEGMENTSEPARATOR	9
#define C2_WHITESPACE	10
#define C2_OTHERNEUTRAL	11
#define C2_NOTAPPLICABLE	0
#define C3_NONSPACING	1
#define C3_DIACRITIC	2
#define C3_VOWELMARK	4
#define C3_SYMBOL	8
#define C3_KATAKANA	16
#define C3_HIRAGANA	32
#define C3_HALFWIDTH	64
#define C3_FULLWIDTH	128
#define C3_IDEOGRAPH	256
#define C3_KASHIDA	512
#define C3_ALPHA	32768
#define C3_NOTAPPLICABLE	0
#define COLOR_HOTLIGHT	26
#define COLOR_GRADIENTACTIVECAPTION 27
#define COLOR_GRADIENTINACTIVECAPTION 28
#define COLOR_MENUHILIGHT	29
#define COLOR_MENUBAR	30
#define COLOR_3DDKSHADOW	21
#define COLOR_3DFACE	15
#define COLOR_3DHILIGHT	20
#define COLOR_3DHIGHLIGHT	20
#define COLOR_3DLIGHT	22
#define COLOR_BTNHILIGHT	20
#define COLOR_3DSHADOW	16
#define COLOR_ACTIVEBORDER	10
#define COLOR_ACTIVECAPTION	2
#define COLOR_APPWORKSPACE	12
#define COLOR_BACKGROUND	1
#define COLOR_DESKTOP	1
#define COLOR_BTNFACE	15
#define COLOR_BTNHIGHLIGHT	20
#define COLOR_BTNSHADOW	16
#define COLOR_BTNTEXT	18
#define COLOR_CAPTIONTEXT	9
#define COLOR_GRAYTEXT	17
#define COLOR_HIGHLIGHT	13
#define COLOR_HIGHLIGHTTEXT	14
#define COLOR_INACTIVEBORDER	11
#define COLOR_INACTIVECAPTION	3
#define COLOR_INACTIVECAPTIONTEXT	19
#define COLOR_INFOBK	24
#define COLOR_INFOTEXT	23
#define COLOR_MENU	4
#define COLOR_MENUTEXT	7
#define COLOR_SCROLLBAR	0
#define COLOR_WINDOW	5
#define COLOR_WINDOWFRAME	6
#define COLOR_WINDOWTEXT	8
#define CTLCOLOR_MSGBOX 0
#define CTLCOLOR_EDIT 1
#define CTLCOLOR_LISTBOX 2
#define CTLCOLOR_BTN 3
#define CTLCOLOR_DLG 4
#define CTLCOLOR_SCROLLBAR 5
#define CTLCOLOR_STATIC 6
#define CTLCOLOR_MAX 7
#define	SM_CXSCREEN	0
#define	SM_CYSCREEN	1
#define	SM_CXVSCROLL	2
#define	SM_CYHSCROLL	3
#define	SM_CYCAPTION	4
#define	SM_CXBORDER	5
#define	SM_CYBORDER	6
#define	SM_CXDLGFRAME	7
#define	SM_CYDLGFRAME	8
#define	SM_CYVTHUMB	9
#define	SM_CXHTHUMB	10
#define	SM_CXICON	11
#define	SM_CYICON	12
#define	SM_CXCURSOR	13
#define	SM_CYCURSOR	14
#define	SM_CYMENU	15
#define	SM_CXFULLSCREEN	16
#define	SM_CYFULLSCREEN	17
#define	SM_CYKANJIWINDOW	18
#define	SM_MOUSEPRESENT	19
#define	SM_CYVSCROLL	20
#define	SM_CXHSCROLL	21
#define	SM_DEBUG	22
#define	SM_SWAPBUTTON	23
#define	SM_RESERVED1	24
#define	SM_RESERVED2	25
#define	SM_RESERVED3	26
#define	SM_RESERVED4	27
#define	SM_CXMIN	28
#define	SM_CYMIN	29
#define	SM_CXSIZE	30
#define	SM_CYSIZE	31
#define	SM_CXFRAME	32
#define	SM_CYFRAME	33
#define	SM_CXMINTRACK	34
#define	SM_CYMINTRACK	35
#define	SM_CXDOUBLECLK	36
#define	SM_CYDOUBLECLK	37
#define	SM_CXICONSPACING	38
#define	SM_CYICONSPACING	39
#define	SM_MENUDROPALIGNMENT	40
#define	SM_PENWINDOWS	41
#define	SM_DBCSENABLED	42
#define	SM_CMOUSEBUTTONS	43
#define	SM_CXFIXEDFRAME	SM_CXDLGFRAME
#define	SM_CYFIXEDFRAME	SM_CYDLGFRAME
#define	SM_CXSIZEFRAME	SM_CXFRAME
#define	SM_CYSIZEFRAME	SM_CYFRAME
#define	SM_SECURE	44
#define	SM_CXEDGE	45
#define	SM_CYEDGE	46
#define	SM_CXMINSPACING	47
#define	SM_CYMINSPACING	48
#define	SM_CXSMICON	49
#define	SM_CYSMICON	50
#define	SM_CYSMCAPTION	51
#define	SM_CXSMSIZE	52
#define	SM_CYSMSIZE	53
#define	SM_CXMENUSIZE	54
#define	SM_CYMENUSIZE	55
#define	SM_ARRANGE	56
#define	SM_CXMINIMIZED	57
#define	SM_CYMINIMIZED	58
#define	SM_CXMAXTRACK	59
#define	SM_CYMAXTRACK	60
#define	SM_CXMAXIMIZED	61
#define	SM_CYMAXIMIZED	62
#define	SM_NETWORK	63
#define	SM_CLEANBOOT	67
#define	SM_CXDRAG	68
#define	SM_CYDRAG	69
#define	SM_SHOWSOUNDS	70
#define	SM_CXMENUCHECK	71
#define	SM_CYMENUCHECK	72
#define	SM_SLOWMACHINE	73
#define	SM_MIDEASTENABLED	74
#define	SM_MOUSEWHEELPRESENT	75
#define	SM_XVIRTUALSCREEN	76
#define	SM_YVIRTUALSCREEN	77
#define	SM_CXVIRTUALSCREEN	78
#define	SM_CYVIRTUALSCREEN	79
#define	SM_CMONITORS	80
#define	SM_SAMEDISPLAYFORMAT	81
#define	SM_CMETRICS	76
#define ARW_BOTTOMLEFT	0
#define ARW_BOTTOMRIGHT	1
#define ARW_HIDE	8
#define ARW_TOPLEFT	2
#define ARW_TOPRIGHT	3
#define ARW_DOWN	4
#define ARW_LEFT	0
#define ARW_RIGHT	0
#define ARW_UP	4
#define SYSPAL_NOSTATIC	2
#define SYSPAL_STATIC	1
#define SYSPAL_ERROR	0
#define GET_TAPE_MEDIA_INFORMATION	0
#define GET_TAPE_DRIVE_INFORMATION	1
#define SET_TAPE_MEDIA_INFORMATION	0
#define SET_TAPE_DRIVE_INFORMATION	1
#define TAPE_ABSOLUTE_POSITION	0
#define TAPE_LOGICAL_POSITION	1
#define TA_BASELINE	24
#define TA_BOTTOM	8
#define TA_TOP	0
#define TA_CENTER	6
#define TA_LEFT	0
#define TA_RIGHT	2
#define TA_RTLREADING	256
#define TA_MASK	(TA_BASELINE+TA_CENTER+TA_UPDATECP+TA_RTLREADING)
#define TA_NOUPDATECP	0
#define TA_UPDATECP	1
#define VTA_BASELINE	24
#define VTA_CENTER	6
#define VTA_LEFT	TA_BOTTOM
#define VTA_RIGHT	TA_TOP
#define VTA_BOTTOM	TA_RIGHT
#define VTA_TOP	TA_LEFT
#define THREAD_PRIORITY_ABOVE_NORMAL	1
#define THREAD_PRIORITY_BELOW_NORMAL	(-1)
#define THREAD_PRIORITY_HIGHEST	2
#define THREAD_PRIORITY_IDLE	(-15)
#define THREAD_PRIORITY_LOWEST	(-2)
#define THREAD_PRIORITY_NORMAL	0
#define THREAD_PRIORITY_TIME_CRITICAL	15
#define THREAD_PRIORITY_ERROR_RETURN	2147483647
#define TLS_MINIMUM_AVAILABLE	64
#define TIME_NOMINUTESORSECONDS	1
#define TIME_NOSECONDS	2
#define TIME_NOTIMEMARKER	4
#define TIME_FORCE24HOURFORMAT	8
#define TIME_ZONE_ID_UNKNOWN	0
#define TIME_ZONE_ID_STANDARD	1
#define TIME_ZONE_ID_DAYLIGHT	2
#define UOI_FLAGS	1
#define UOI_NAME	2
#define UOI_TYPE	3
#define FS_CASE_IS_PRESERVED	2
#define FS_CASE_SENSITIVE	1
#define FS_UNICODE_STORED_ON_DISK	4
#define FS_PERSISTENT_ACLS	8
#define FS_FILE_COMPRESSION	16
#define FS_VOL_IS_COMPRESSED	32768
#define FS_FILE_ENCRYPTION FILE_SUPPORTS_ENCRYPTION
#define GWL_EXSTYLE	(-20)
#define GWL_STYLE	(-16)
#define GWL_WNDPROC	(-4)
#define GWL_HINSTANCE	(-6)
#define GWL_HWNDPARENT	(-8)
#define GWL_ID	(-12)
#define GWL_USERDATA	(-21)
#define GWLP_WNDPROC	(-4)
#define GWLP_HINSTANCE	(-6)
#define GWLP_HWNDPARENT	(-8)
#define GWLP_USERDATA	(-21)
#define GWLP_ID	(-12)
#define DWL_DLGPROC	4
#define DWL_MSGRESULT	0
#define DWL_USER	8
#define DWLP_MSGRESULT	0
#define DWLP_DLGPROC	DWLP_MSGRESULT+sizeof(LRESULT)
#define DWLP_USER	DWLP_DLGPROC+sizeof(DLGPROC)
#define GMEM_FIXED	0
#define GMEM_MOVEABLE	2
#define GMEM_MODIFY 128
#define GMEM_VALID_FLAGS 0x7F72
#define GPTR	64
#define GHND	66
#define GMEM_DDESHARE	8192
#define GMEM_DISCARDABLE	256
#define GMEM_LOWER	4096
#define GMEM_NOCOMPACT	16
#define GMEM_NODISCARD	32
#define GMEM_NOT_BANKED	4096
#define GMEM_NOTIFY	16384
#define GMEM_SHARE	8192
#define GMEM_ZEROINIT	64
#define GMEM_DISCARDED	16384
#define GMEM_INVALID_HANDLE	32768
#define GMEM_LOCKCOUNT	255
#define GlobalLRUNewest(h) ((HANDLE)(h))
#define GlobalLRUOldest(h) ((HANDLE)(h))
#define HEAP_GENERATE_EXCEPTIONS	4
#define HEAP_NO_SERIALIZE	1
#define HEAP_ZERO_MEMORY	8
#define STATUS_WAIT_0	0
#define STATUS_ABANDONED_WAIT_0	0x80
#define STATUS_USER_APC	0xC0
#define STATUS_TIMEOUT	0x102
#define STATUS_PENDING	0x103
#define STATUS_SEGMENT_NOTIFICATION	0x40000005
#define STATUS_GUARD_PAGE_VIOLATION	0x80000001
#define STATUS_DATATYPE_MISALIGNMENT	0x80000002
#define STATUS_BREAKPOINT	0x80000003
#define STATUS_SINGLE_STEP	0x80000004
#define STATUS_ACCESS_VIOLATION	0xC0000005
#define STATUS_IN_PAGE_ERROR	0xC0000006
#define STATUS_NO_MEMORY	0xC0000017
#define STATUS_ILLEGAL_INSTRUCTION	0xC000001D
#define STATUS_NONCONTINUABLE_EXCEPTION	0xC0000025
#define STATUS_INVALID_DISPOSITION	0xC0000026
#define STATUS_ARRAY_BOUNDS_EXCEEDED	0xC000008C
#define STATUS_FLOAT_DENORMAL_OPERAND	0xC000008D
#define STATUS_FLOAT_DIVIDE_BY_ZERO	0xC000008E
#define STATUS_FLOAT_INEXACT_RESULT	0xC000008F
#define STATUS_FLOAT_INVALID_OPERATION	0xC0000090
#define STATUS_FLOAT_OVERFLOW	0xC0000091
#define STATUS_FLOAT_STACK_CHECK	0xC0000092
#define STATUS_FLOAT_UNDERFLOW	0xC0000093
#define STATUS_INTEGER_DIVIDE_BY_ZERO	0xC0000094
#define STATUS_INTEGER_OVERFLOW	0xC0000095
#define STATUS_PRIVILEGED_INSTRUCTION	0xC0000096
#define STATUS_STACK_OVERFLOW	0xC00000FD
#define STATUS_CONTROL_C_EXIT	0xC000013A
#define STATUS_INVALID_HANDLE ((DWORD)0xC0000008L)
#define STATUS_POSSIBLE_DEADLOCK 0xC0000194L
#define ILC_COLOR	0
#define ILC_COLOR4	4
#define ILC_COLOR8	8
#define ILC_COLOR16	16
#define ILC_COLOR24	24
#define ILC_COLOR32	32
#define ILC_COLORDDB	254
#define ILC_MASK	1
#define ILC_MIRROR	0x00002000
#define ILC_PERITEMMIRROR	0x00008000
#define ILC_PALETTE	2048
#define ILD_BLEND25	2
#define ILD_BLEND50	4
#define ILD_SELECTED	4
#define ILD_BLEND	4
#define ILD_FOCUS	2
#define ILD_MASK	16
#define ILD_NORMAL	0
#define ILD_TRANSPARENT	1
#define ILD_IMAGE	0x00000020
#define ILD_ROP	0x040
#define ILD_BLEND25 2
#define ILD_BLEND50 4
#define ILD_OVERLAYMASK 0x0F00
#define INDEXTOOVERLAYMASK(i)	((i) << 8)
#define ILD_PRESERVEALPHA 0x1000
#define ILD_SCALE	0x00002000
#define ILD_DPISCALE	0x00004000
#define ILS_NORMAL	0
#define ILS_GLOW	1
#define ILS_SHADOW	2
#define ILS_SATURATE	4
#define ILS_ALPHA	8
#define ILCF_MOVE	0
#define ILCF_SWAP	1
#define CLR_NONE	0xffffffff
#define CLR_INVALID	CLR_NONE
#define CLR_DEFAULT	0xff000000
#define LR_DEFAULTCOLOR	0
#define LR_LOADFROMFILE	16
#define LR_LOADTRANSPARENT	32
#define LR_MONOCHROME	1
#define IME_CONFIG_GENERAL	1
#define IME_CONFIG_REGISTERWORD	2
#define IME_CONFIG_SELECTDICTIONARY	3
#define GCL_CONVERSION	1
#define GCL_REVERSECONVERSION	2
#define GCL_REVERSE_LENGTH	3
#define CPS_CANCEL	4
#define CPS_COMPLETE	1
#define CPS_CONVERT	2
#define CPS_REVERT	3
#define SECURITY_DESCRIPTOR_REVISION	1
#define SECURITY_DESCRIPTOR_REVISION1	1
#define IS_TEXT_UNICODE_ASCII16	1
#define IS_TEXT_UNICODE_REVERSE_ASCII16	16
#define IS_TEXT_UNICODE_STATISTICS	2
#define IS_TEXT_UNICODE_REVERSE_STATISTICS	32
#define IS_TEXT_UNICODE_CONTROLS	4
#define IS_TEXT_UNICODE_REVERSE_CONTROLS	64
#define IS_TEXT_UNICODE_SIGNATURE	8
#define IS_TEXT_UNICODE_REVERSE_SIGNATURE	128
#define IS_TEXT_UNICODE_ILLEGAL_CHARS	256
#define IS_TEXT_UNICODE_ODD_LENGTH	512
#define IS_TEXT_UNICODE_NULL_BYTES	4096
#define IS_TEXT_UNICODE_UNICODE_MASK	15
#define IS_TEXT_UNICODE_REVERSE_MASK	240
#define IS_TEXT_UNICODE_NOT_UNICODE_MASK	3840
#define IS_TEXT_UNICODE_NOT_ASCII_MASK	61440
#define HC_GETNEXT	1
#define HC_SKIP	2
#define HC_SYSMODALOFF	5
#define HC_SYSMODALON	4
#define HC_NOREMOVE	3
#define KEYEVENTF_EXTENDEDKEY	1
#define KEYEVENTF_KEYUP	2
#define OBM_BTNCORNERS	32758
#define OBM_BTSIZE	32761
#define OBM_CHECK	32760
#define OBM_CHECKBOXES	32759
#define OBM_CLOSE	32754
#define OBM_COMBO	32738
#define OBM_DNARROW	32752
#define OBM_DNARROWD	32742
#define OBM_DNARROWI	32736
#define OBM_LFARROW	32750
#define OBM_LFARROWI	32734
#define OBM_LFARROWD	32740
#define OBM_MNARROW	32739
#define OBM_OLD_CLOSE	32767
#define OBM_OLD_DNARROW	32764
#define OBM_OLD_LFARROW	32762
#define OBM_OLD_REDUCE	32757
#define OBM_OLD_RESTORE	32755
#define OBM_OLD_RGARROW	32763
#define OBM_OLD_UPARROW	32765
#define OBM_OLD_ZOOM	32756
#define OBM_REDUCE	32749
#define OBM_REDUCED	32746
#define OBM_RESTORE	32747
#define OBM_RESTORED	32744
#define OBM_RGARROW	32751
#define OBM_RGARROWD	32741
#define OBM_RGARROWI	32735
#define OBM_SIZE	32766
#define OBM_UPARROW	32753
#define OBM_UPARROWD	32743
#define OBM_UPARROWI	32737
#define OBM_ZOOM	32748
#define OBM_ZOOMD	32745
#define DONT_RESOLVE_DLL_REFERENCES	1
#define LOAD_LIBRARY_AS_DATAFILE	2
#define LOAD_WITH_ALTERED_SEARCH_PATH	8
#define LMEM_FIXED	0
#define LMEM_MOVEABLE	2
#define LPTR	64
#define LHND	66
#define NONZEROLHND	2
#define NONZEROLPTR	0
#define LMEM_NONZEROLHND	2
#define LMEM_NONZEROLPTR	0
#define LMEM_DISCARDABLE	3840
#define LMEM_NOCOMPACT	16
#define LMEM_NODISCARD	32
#define LMEM_ZEROINIT	64
#define LMEM_DISCARDED	16384
#define LMEM_MODIFY	128
#define LMEM_INVALID_HANDLE	32768
#define LMEM_LOCKCOUNT	255
#define LOCKFILE_FAIL_IMMEDIATELY	1
#define LOCKFILE_EXCLUSIVE_LOCK	2
#define MB_USERICON	128
#define MB_ICONASTERISK	64
#define MB_ICONEXCLAMATION	0x30
#define MB_ICONWARNING	0x30
#define MB_ICONERROR	16
#define MB_ICONHAND	16
#define MB_ICONQUESTION	32
#define MB_OK	0
#define MB_ABORTRETRYIGNORE	2
#define MB_APPLMODAL	0
#define MB_DEFAULT_DESKTOP_ONLY	0x20000
#define MB_HELP	0x4000
#define MB_RIGHT	0x80000
#define MB_RTLREADING	0x100000
#define MB_TOPMOST	0x40000
#define MB_DEFBUTTON1	0
#define MB_DEFBUTTON2	256
#define MB_DEFBUTTON3	512
#define MB_DEFBUTTON4	0x300
#define MB_ICONINFORMATION	64
#define MB_ICONSTOP	16
#define MB_OKCANCEL	1
#define MB_RETRYCANCEL	0x5
#define MB_SERVICE_NOTIFICATION	0x40000
#define MB_SETFOREGROUND	0x10000
#define MB_SYSTEMMODAL	4096
#define MB_TASKMODAL	0x2000
#define MB_YESNO	4
#define MB_YESNOCANCEL	3
#define IDABORT	3
#define IDCANCEL	2
#define IDCLOSE	8
#define IDHELP	9
#define IDIGNORE	5
#define IDNO	7
#define IDOK	1
#define IDRETRY	4
#define IDYES	6
#define MSGF_DIALOGBOX	0
#define MSGF_MENU	2
#define MSGF_NEXTWINDOW	6
#define MSGF_SCROLLBAR	5
#define MSGF_MAINLOOP	8
#define MSGF_USER	4096
#define MWT_IDENTITY	1
#define MWT_LEFTMULTIPLY	2
#define MWT_RIGHTMULTIPLY	3
#define MWT_MIN	MWT_IDENTITY
#define MWT_MAX	MWT_RIGHTMULTIPLY
#define MOUSEEVENTF_ABSOLUTE	32768
#define MOUSEEVENTF_MOVE	1
#define MOUSEEVENTF_LEFTDOWN	2
#define MOUSEEVENTF_LEFTUP	4
#define MOUSEEVENTF_RIGHTDOWN	8
#define MOUSEEVENTF_RIGHTUP	16
#define MOUSEEVENTF_MIDDLEDOWN	32
#define MOUSEEVENTF_MIDDLEUP	64
#define MOVEFILE_REPLACE_EXISTING	1
#define MOVEFILE_COPY_ALLOWED	2
#define MOVEFILE_DELAY_UNTIL_REBOOT	4
#define MOVEFILE_WRITE_THROUGH	8
#define MOVEFILE_CREATE_HARD_LINK 16
#define MOVEFILE_FAIL_IF_NOT_TRACKABLE 32
#define MOVEFILE_CREATE_HARDLINK 16
#define MOVEFILE_FAIL_IF_NOT_TRACKABLE 32
#define WAIT_OBJECT_0	0
#define WAIT_ABANDONED_0	128
#define WAIT_TIMEOUT	0x102
#define WAIT_IO_COMPLETION	0xc0
#define WAIT_ABANDONED	128
#define WAIT_FAILED	0xffffffff
#define MAXIMUM_WAIT_OBJECTS	64
#define MAXIMUM_SUSPEND_COUNT	0x7f
#define MB_PRECOMPOSED	1
#define MB_COMPOSITE	2
#define MB_ERR_INVALID_CHARS	8
#define MB_USEGLYPHCHARS	4
#define TOKEN_ADJUST_DEFAULT	128
#define TOKEN_ADJUST_GROUPS	64
#define TOKEN_ADJUST_PRIVILEGES	32
#define TOKEN_ALL_ACCESS	0xf00ff
#define TOKEN_ASSIGN_PRIMARY	1
#define TOKEN_DUPLICATE	2
#define TOKEN_EXECUTE	0x20000
#define TOKEN_IMPERSONATE	4
#define TOKEN_QUERY	8
#define TOKEN_QUERY_SOURCE	16
#define TOKEN_READ	0x20008
#define TOKEN_WRITE	0x200e0
#define HWND_BROADCAST	(HWND)65535
#define CopyMemory	RtlCopyMemory
#define RtlCopyMemory	memcpy
#define TAPE_FORMAT	5
#define TAPE_LOAD	0
#define TAPE_LOCK	3
#define TAPE_TENSION	2
#define TAPE_UNLOAD	1
#define TAPE_UNLOCK	4
#define IS_PSREBOOTSYSTEM	3
#define IS_PSRESTARTWINDOWS	2
#define PSPCB_CREATE	2
#define PSPCB_RELEASE	1
#define PURGE_TXABORT	1
#define PURGE_RXABORT	2
#define PURGE_TXCLEAR	4
#define PURGE_RXCLEAR	8
#define LPTx 0x80
#define OWNER_SECURITY_INFORMATION	1
#define GROUP_SECURITY_INFORMATION	2
#define DACL_SECURITY_INFORMATION	4
#define SACL_SECURITY_INFORMATION	8
#define EVENTLOG_FORWARDS_READ	4
#define EVENTLOG_BACKWARDS_READ	8
#define EVENTLOG_SEEK_READ	2
#define EVENTLOG_SEQUENTIAL_READ	1
#define EVENTLOG_ERROR_TYPE	1
#define EVENTLOG_WARNING_TYPE	2
#define EVENTLOG_INFORMATION_TYPE	4
#define EVENTLOG_AUDIT_SUCCESS	8
#define EVENTLOG_AUDIT_FAILURE	16
#define RDW_ERASE	4
#define RDW_FRAME	1024
#define RDW_INTERNALPAINT	2
#define RDW_INVALIDATE	1
#define RDW_NOERASE	32
#define RDW_NOFRAME	2048
#define RDW_NOINTERNALPAINT	16
#define RDW_VALIDATE	8
#define RDW_ERASENOW	512
#define RDW_UPDATENOW	256
#define RDW_ALLCHILDREN	128
#define RDW_NOCHILDREN	64
#define HKEY_CLASSES_ROOT	(HKEY)0x80000000
#define HKEY_CURRENT_USER	(HKEY)0x80000001
#define HKEY_LOCAL_MACHINE	(HKEY)0x80000002
#define HKEY_USERS	(HKEY)(-2147483645)
#define HKEY_PERFORMANCE_DATA	(HKEY)(-2147483644)
#define HKEY_CURRENT_CONFIG	(HKEY)(-2147483643)

//#ifndef HKEY_DYN_DATA
#define HKEY_DYN_DATA	((HKEY)(0x80000006))
//#endif
#define REG_OPTION_VOLATILE	1
#define REG_OPTION_NON_VOLATILE	0
#define REG_CREATED_NEW_KEY	1
#define REG_OPENED_EXISTING_KEY	2
#define REG_BINARY	3
#define REG_DWORD	4
#define REG_DWORD_LITTLE_ENDIAN	4
#define REG_DWORD_BIG_ENDIAN	5
#define REG_EXPAND_SZ	2
#define REG_LINK	6
#define REG_MULTI_SZ	7
#define REG_NONE	0
#define REG_RESOURCE_LIST	8
#define REG_FULL_RESOURCE_DESCRIPTOR 9
#define REG_RESOURCE_REQUIREMENTS_LIST 10
#define REG_SZ	1
#define MOD_ALT	1
#define MOD_CONTROL	2
#define MOD_SHIFT	4
#define MOD_WIN	8
#define IDHOT_SNAPDESKTOP	(-2)
#define IDHOT_SNAPWINDOW	(-1)
#define REG_NOTIFY_CHANGE_NAME	1
#define REG_NOTIFY_CHANGE_ATTRIBUTES	2
#define REG_NOTIFY_CHANGE_LAST_SET	4
#define REG_NOTIFY_CHANGE_SECURITY	8
#define SW_ERASE	4
#define SW_INVALIDATE	2
#define SW_SCROLLCHILDREN	1
#define SMTO_ABORTIFHUNG	2
#define SMTO_BLOCK	1
#define SMTO_NORMAL	0
#define OPAQUE	2
#define TRANSPARENT	1
#define SLE_ERROR	1
#define SLE_MINORERROR	2
#define SLE_WARNING	3
#define SEM_FAILCRITICALERRORS	1
#define SEM_NOALIGNMENTFAULTEXCEPT	4
#define SEM_NOGPFAULTERRORBOX	2
#define SEM_NOOPENFILEERRORBOX	32768
#define ICM_ON	2
#define ICM_OFF	1
#define ICM_QUERY	3
#define LOCALE_ILANGUAGE	1
#define LOCALE_SLANGUAGE	2
#define LOCALE_SENGLANGUAGE	4097
#define LOCALE_SABBREVLANGNAME	3
#define LOCALE_SNATIVELANGNAME	4
#define LOCALE_ICOUNTRY	5
#define LOCALE_SCOUNTRY	6
#define LOCALE_SENGCOUNTRY	4098
#define LOCALE_SABBREVCTRYNAME	7
#define LOCALE_SNATIVECTRYNAME	8
#define LOCALE_IDEFAULTLANGUAGE	9
#define LOCALE_IDEFAULTCOUNTRY	10
#define LOCALE_IDEFAULTANSICODEPAGE	4100
#define LOCALE_IDEFAULTCODEPAGE	11
#define LOCALE_SLIST	12
#define LOCALE_IMEASURE	13
#define LOCALE_SDECIMAL	14
#define LOCALE_STHOUSAND	15
#define LOCALE_SGROUPING	16
#define LOCALE_IDIGITS	17
#define LOCALE_ILZERO	18
#define LOCALE_INEGNUMBER	4112
#define LOCALE_SCURRENCY	20
#define LOCALE_SMONDECIMALSEP	22
#define LOCALE_SMONTHOUSANDSEP	23
#define LOCALE_SMONGROUPING	24
#define LOCALE_ICURRDIGITS	25
#define LOCALE_ICURRENCY	27
#define LOCALE_INEGCURR	28
#define LOCALE_SDATE	29
#define LOCALE_STIME	30
#define LOCALE_STIMEFORMAT	4099
#define LOCALE_SSHORTDATE	31
#define LOCALE_SLONGDATE	32
#define LOCALE_IDATE	33
#define LOCALE_ILDATE	34
#define LOCALE_ITIME	35
#define LOCALE_ITLZERO	37
#define LOCALE_IDAYLZERO	38
#define LOCALE_IMONLZERO	39
#define LOCALE_S1159	40
#define LOCALE_S2359	41
#define LOCALE_ICALENDARTYPE	4105
#define LOCALE_IOPTIONALCALENDAR	4107
#define LOCALE_IFIRSTDAYOFWEEK	4108
#define LOCALE_IFIRSTWEEKOFYEAR	4109
#define LOCALE_SDAYNAME1	42
#define LOCALE_SDAYNAME2	43
#define LOCALE_SDAYNAME3	44
#define LOCALE_SDAYNAME4	45
#define LOCALE_SDAYNAME5	46
#define LOCALE_SDAYNAME6	47
#define LOCALE_SDAYNAME7	48
#define LOCALE_SABBREVDAYNAME1	49
#define LOCALE_SABBREVDAYNAME2	50
#define LOCALE_SABBREVDAYNAME3	51
#define LOCALE_SABBREVDAYNAME4	52
#define LOCALE_SABBREVDAYNAME5	53
#define LOCALE_SABBREVDAYNAME6	54
#define LOCALE_SABBREVDAYNAME7	55
#define LOCALE_SMONTHNAME1	56
#define LOCALE_SMONTHNAME2	57
#define LOCALE_SMONTHNAME3	58
#define LOCALE_SMONTHNAME4	59
#define LOCALE_SMONTHNAME5	60
#define LOCALE_SMONTHNAME6	61
#define LOCALE_SMONTHNAME7	62
#define LOCALE_SMONTHNAME8	63
#define LOCALE_SMONTHNAME9	64
#define LOCALE_SMONTHNAME10	65
#define LOCALE_SMONTHNAME11	66
#define LOCALE_SMONTHNAME12	67
#define LOCALE_SMONTHNAME13	4110
#define LOCALE_SABBREVMONTHNAME1	68
#define LOCALE_SABBREVMONTHNAME2	69
#define LOCALE_SABBREVMONTHNAME3	70
#define LOCALE_SABBREVMONTHNAME4	71
#define LOCALE_SABBREVMONTHNAME5	72
#define LOCALE_SABBREVMONTHNAME6	73
#define LOCALE_SABBREVMONTHNAME7	74
#define LOCALE_SABBREVMONTHNAME8	75
#define LOCALE_SABBREVMONTHNAME9	76
#define LOCALE_SABBREVMONTHNAME10	77
#define LOCALE_SABBREVMONTHNAME11	78
#define LOCALE_SABBREVMONTHNAME12	79
#define LOCALE_SABBREVMONTHNAME13	4111
#define LOCALE_SPOSITIVESIGN	80
#define LOCALE_SNEGATIVESIGN	81
#define LOCALE_IPOSSIGNPOSN	82
#define LOCALE_INEGSIGNPOSN	83
#define LOCALE_IPOSSYMPRECEDES	84
#define LOCALE_IPOSSEPBYSPACE	85
#define LOCALE_INEGSYMPRECEDES	86
#define LOCALE_INEGSEPBYSPACE	87
#define LOCALE_NOUSEROVERRIDE	0x80000000
#define CAL_ICALINTVALUE	1
#define CAL_IYEAROFFSETRANGE	3
#define CAL_SABBREVDAYNAME1	14
#define CAL_SABBREVDAYNAME2	15
#define CAL_SABBREVDAYNAME3	16
#define CAL_SABBREVDAYNAME4	17
#define CAL_SABBREVDAYNAME5	18
#define CAL_SABBREVDAYNAME6	19
#define CAL_SABBREVDAYNAME7	20
#define CAL_SABBREVMONTHNAME1	34
#define CAL_SABBREVMONTHNAME2	35
#define CAL_SABBREVMONTHNAME3	36
#define CAL_SABBREVMONTHNAME4	37
#define CAL_SABBREVMONTHNAME5	38
#define CAL_SABBREVMONTHNAME6	39
#define CAL_SABBREVMONTHNAME7	40
#define CAL_SABBREVMONTHNAME8	41
#define CAL_SABBREVMONTHNAME9	42
#define CAL_SABBREVMONTHNAME10	43
#define CAL_SABBREVMONTHNAME11	44
#define CAL_SABBREVMONTHNAME12	45
#define CAL_SABBREVMONTHNAME13	46
#define CAL_SCALNAME	2
#define CAL_SDAYNAME1	7
#define CAL_SDAYNAME2	8
#define CAL_SDAYNAME3	9
#define CAL_SDAYNAME4	10
#define CAL_SDAYNAME5	11
#define CAL_SDAYNAME6	12
#define CAL_SDAYNAME7	13
#define CAL_SERASTRING	4
#define CAL_SLONGDATE	6
#define CAL_SMONTHNAME1	21
#define CAL_SMONTHNAME2	22
#define CAL_SMONTHNAME3	23
#define CAL_SMONTHNAME4	24
#define CAL_SMONTHNAME5	25
#define CAL_SMONTHNAME6	26
#define CAL_SMONTHNAME7	27
#define CAL_SMONTHNAME8	28
#define CAL_SMONTHNAME9	29
#define CAL_SMONTHNAME10	30
#define CAL_SMONTHNAME11	31
#define CAL_SMONTHNAME12	32
#define CAL_SMONTHNAME13	33
#define CAL_SSHORTDATE	5
#define PROCESS_SET_QUOTA	256
#define BLACKONWHITE	1
#define COLORONCOLOR	3
#define HALFTONE	4
#define MAXSTRETCHBLTMODE	4
#define STRETCH_ANDSCANS	1
#define STRETCH_DELETESCANS	3
#define STRETCH_HALFTONE	4
#define STRETCH_ORSCANS	2
#define WHITEONBLACK	2
#define OCR_NORMAL	32512
#define OCR_IBEAM	32513
#define OCR_WAIT	32514
#define OCR_CROSS	32515
#define OCR_UP	32516
#define OCR_SIZE	32640
#define OCR_ICON	32641
#define OCR_SIZENWSE	32642
#define OCR_SIZENESW	32643
#define OCR_SIZEWE	32644
#define OCR_SIZENS	32645
#define OCR_SIZEALL	32646
#define OCR_NO	32648
#define OCR_APPSTARTING	32650
#define TAPE_ABSOLUTE_BLOCK	1
#define TAPE_LOGICAL_BLOCK	2
#define TAPE_REWIND	0
#define TAPE_SPACE_END_OF_DATA	4
#define TAPE_SPACE_FILEMARKS	6
#define TAPE_SPACE_RELATIVE_BLOCKS	5
#define TAPE_SPACE_SEQUENTIAL_FMKS	7
#define TAPE_SPACE_SEQUENTIAL_SMKS	9
#define TAPE_SPACE_SETMARKS	8
#define EXCEPTION_EXECUTE_HANDLER	1
#define EXCEPTION_CONTINUE_EXECUTION	-1
#define EXCEPTION_CONTINUE_SEARCH	0
#define HWND_BOTTOM	(HWND)1
#define HWND_NOTOPMOST	(HWND)(-2)
#define HWND_TOP	(HWND)0
#define HWND_TOPMOST	(HWND)(-1)
#define SWP_DRAWFRAME	32
#define SWP_FRAMECHANGED	32
#define SWP_HIDEWINDOW	128
#define SWP_NOACTIVATE	16
#define SWP_NOCOPYBITS	256
#define SWP_NOMOVE	2
#define SWP_NOSIZE	1
#define SWP_NOREDRAW	8
#define SWP_NOZORDER	4
#define SWP_SHOWWINDOW	64
#define SWP_NOOWNERZORDER	512
#define SWP_NOREPOSITION	512
#define SWP_NOSENDCHANGING	1024
#define HSHELL_ACTIVATESHELLWINDOW	3
#define HSHELL_GETMINRECT	5
#define HSHELL_LANGUAGE	8
#define HSHELL_REDRAW	6
#define HSHELL_TASKMAN	7
#define HSHELL_WINDOWACTIVATED	4
#define HSHELL_WINDOWCREATED	1
#define HSHELL_WINDOWDESTROYED	2
#define HSHELL_ACCESSIBILITYSTATE	11
#define HSHELL_APPCOMMAND	12
#define SW_HIDE	0
#define SW_NORMAL 1
#define SW_MAXIMIZE	3
#define SW_MINIMIZE	6
#define SW_RESTORE	9
#define SW_SHOW	5
#define SW_SHOWDEFAULT	10
#define SW_SHOWMAXIMIZED	3
#define SW_SHOWMINIMIZED	2
#define SW_SHOWMINNOACTIVE	7
#define SW_SHOWNA	8
#define SW_SHOWNOACTIVATE	4
#define SW_SHOWNORMAL	1
#define WPF_RESTORETOMAXIMIZED	2
#define WPF_SETMINPOSITION	1
#define INFINITE	(-1)
#define SPI_GETACCESSTIMEOUT	60
#define SPI_GETANIMATION	72
#define SPI_GETBEEP	1
#define SPI_GETBORDER	5
#define SPI_GETDEFAULTINPUTLANG	89
#define SPI_GETDRAGFULLWINDOWS	38
#define SPI_GETFASTTASKSWITCH	35
#define SPI_GETFILTERKEYS	50
#define SPI_GETFONTSMOOTHING	74
#define SPI_GETGRIDGRANULARITY	18
#define SPI_GETHIGHCONTRAST	66
#define SPI_GETICONMETRICS	45
#define SPI_GETICONTITLELOGFONT	31
#define SPI_GETICONTITLEWRAP	25
#define SPI_GETKEYBOARDDELAY	22
#define SPI_GETKEYBOARDPREF	68
#define SPI_GETKEYBOARDSPEED	10
#define SPI_GETLOWPOWERACTIVE	83
#define SPI_GETLOWPOWERTIMEOUT	79
#define SPI_GETMENUDROPALIGNMENT	27
#define SPI_GETMINIMIZEDMETRICS	43
#define SPI_GETMOUSE	3
#define SPI_GETMOUSEKEYS	54
#define SPI_GETMOUSETRAILS	94
#define SPI_GETNONCLIENTMETRICS	41
#define SPI_GETPOWEROFFACTIVE	84
#define SPI_GETPOWEROFFTIMEOUT	80
#define SPI_GETSCREENREADER	70
#define SPI_GETSCREENSAVEACTIVE	16
#define SPI_GETSCREENSAVETIMEOUT	14
#define SPI_GETSERIALKEYS	62
#define SPI_GETSHOWSOUNDS	56
#define SPI_GETSOUNDSENTRY	64
#define SPI_GETSTICKYKEYS	58
#define SPI_GETTOGGLEKEYS	52
#define SPI_GETMOUSESPEED	0x70
#define SPI_SETMOUSESPEED	0x71
#define SPI_GETSCREENSAVERRUNNING 0x72
#define SPI_GETDESKWALLPAPER	0x73
#define SPI_GETWINDOWSEXTENSION	92
#define SPI_GETWORKAREA	48
#define SPI_GETACTIVEWINDOWTRACKING	0x1000
#define SPI_SETACTIVEWINDOWTRACKING	0x1001
#define SPI_GETMENUANIMATION	0x1002
#define SPI_SETMENUANIMATION	0x1003
#define SPI_GETCOMBOBOXANIMATION	0x1004
#define SPI_SETCOMBOBOXANIMATION	0x1005
#define SPI_GETLISTBOXSMOOTHSCROLLING	0x1006
#define SPI_SETLISTBOXSMOOTHSCROLLING	0x1007
#define SPI_GETGRADIENTCAPTIONS	0x1008
#define SPI_SETGRADIENTCAPTIONS	0x1009
#define SPI_GETKEYBOARDCUES	0x100A
#define SPI_SETKEYBOARDCUES	0x100B
#define SPI_GETMENUUNDERLINES	SPI_GETKEYBOARDCUES
#define SPI_SETMENUUNDERLINES	SPI_SETKEYBOARDCUES
#define SPI_GETACTIVEWNDTRKZORDER	0x100C
#define SPI_SETACTIVEWNDTRKZORDER	0x100D
#define SPI_GETHOTTRACKING	0x100E
#define SPI_SETHOTTRACKING	0x100F
#define SPI_GETMENUFADE	0x1012
#define SPI_SETMENUFADE	0x1013
#define SPI_GETSELECTIONFADE	0x1014
#define SPI_SETSELECTIONFADE	0x1015
#define SPI_GETTOOLTIPANIMATION	0x1016
#define SPI_SETTOOLTIPANIMATION	0x1017
#define SPI_GETTOOLTIPFADE	0x1018
#define SPI_SETTOOLTIPFADE	0x1019
#define SPI_GETCURSORSHADOW	0x101A
#define SPI_SETCURSORSHADOW	0x101B
#define SPI_GETMOUSESONAR	0x101C
#define SPI_SETMOUSESONAR	0x101D
#define SPI_GETMOUSECLICKLOCK	0x101E
#define SPI_SETMOUSECLICKLOCK	0x101F
#define SPI_GETMOUSEVANISH	0x1020
#define SPI_SETMOUSEVANISH	0x1021
#define SPI_GETFLATMENU	0x1022
#define SPI_SETFLATMENU	0x1023
#define SPI_GETDROPSHADOW	0x1024
#define SPI_SETDROPSHADOW	0x1025
#define SPI_GETMOUSECLICKLOCKTIME	0x2008
#define SPI_SETMOUSECLICKLOCKTIME	0x2009
#define SPI_GETFONTSMOOTHINGTYPE	0x200A
#define SPI_SETFONTSMOOTHINGTYPE	0x200B
#define FE_FONTSMOOTHINGSTANDARD	0x0001
#define FE_FONTSMOOTHINGCLEARTYPE	0x0002
#define FE_FONTSMOOTHINGDOCKING	0x8000
#define SPI_GETFONTSMOOTHINGCONTRAST	2
#define SPI_SETFONTSMOOTHINGCONTRAST	2
#define SPI_GETFOCUSBORDERWIDTH	0x200E
#define SPI_SETFOCUSBORDERWIDTH	0x200F
#define SPI_GETFOCUSBORDERHEIGHT	0x2010
#define SPI_SETFOCUSBORDERHEIGHT	0x2011
#define SPI_ICONHORIZONTALSPACING	13
#define SPI_ICONVERTICALSPACING	24
#define SPI_LANGDRIVER	12
#define SPI_SCREENSAVERRUNNING	97
#define SPI_SETACCESSTIMEOUT	61
#define SPI_SETANIMATION	73
#define SPI_SETBEEP	2
#define SPI_SETBORDER	6
#define SPI_SETDEFAULTINPUTLANG	90
#define SPI_SETDESKPATTERN	21
#define SPI_SETDESKWALLPAPER	20
#define SPI_SETDOUBLECLICKTIME	32
#define SPI_SETDOUBLECLKHEIGHT	30
#define SPI_SETDOUBLECLKWIDTH	29
#define SPI_SETDRAGFULLWINDOWS	37
#define SPI_SETDRAGHEIGHT	77
#define SPI_SETDRAGWIDTH	76
#define SPI_SETFASTTASKSWITCH	36
#define SPI_SETFILTERKEYS	51
#define SPI_SETFONTSMOOTHING	75
#define SPI_SETGRIDGRANULARITY	19
#define SPI_SETHANDHELD	78
#define SPI_SETHIGHCONTRAST	67
#define SPI_SETICONMETRICS	46
#define SPI_SETICONTITLELOGFONT	34
#define SPI_SETICONTITLEWRAP	26
#define SPI_SETKEYBOARDDELAY	23
#define SPI_SETKEYBOARDPREF	69
#define SPI_SETKEYBOARDSPEED	11
#define SPI_SETLANGTOGGLE	91
#define SPI_SETLOWPOWERACTIVE	85
#define SPI_SETLOWPOWERTIMEOUT	81
#define SPI_SETMENUDROPALIGNMENT	28
#define SPI_SETMINIMIZEDMETRICS	44
#define SPI_SETMOUSE	4
#define SPI_SETMOUSEBUTTONSWAP	33
#define SPI_SETMOUSEKEYS	55
#define SPI_SETMOUSETRAILS	93
#define SPI_SETNONCLIENTMETRICS	42
#define SPI_SETPENWINDOWS	49
#define SPI_SETPOWEROFFACTIVE	86
#define SPI_SETPOWEROFFTIMEOUT	82
#define SPI_SETSCREENREADER	71
#define SPI_SETSCREENSAVEACTIVE	17
#define SPI_SETSCREENSAVETIMEOUT	15
#define SPI_SETSERIALKEYS	63
#define SPI_SETSHOWSOUNDS	57
#define SPI_SETSOUNDSENTRY	65
#define SPI_SETSTICKYKEYS	59
#define SPI_SETTOGGLEKEYS	53
#define SPI_SETWORKAREA	47
#define SPIF_UPDATEINIFILE	1
#define SPIF_SENDWININICHANGE	2
#define SPIF_SENDCHANGE	2
#define TPM_CENTERALIGN	4
#define TPM_LEFTALIGN	0
#define TPM_RIGHTALIGN	8
#define TPM_LEFTBUTTON	0
#define TPM_RIGHTBUTTON	2
#define TPM_HORIZONTAL	0
#define TPM_VERTICAL	64
#define TPM_TOPALIGN 0
#define TPM_VCENTERALIGN 16
#define TPM_BOTTOMALIGN 32
#define TPM_NONOTIFY 128
#define TPM_RETURNCMD 256
#define TPM_RECURSE	1
#define TPM_HORPOSANIMATION 0x0400
#define TPM_HORNEGANIMATION 0x0800
#define TPM_VERPOSANIMATION 0x1000
#define TPM_VERNEGANIMATION 0x2000
#define TPM_NOANIMATION	0x4000
#define TCI_SRCCHARSET	1
#define TCI_SRCCODEPAGE	2
#define TCI_SRCFONTSIG	3
#define WC_COMPOSITECHECK	512
#define WC_DISCARDNS	16
#define WC_SEPCHARS	32
#define WC_DEFAULTCHAR	64
#define WC_DIALOG	MAKEINTATOM(0x8002)
#define HELP_COMMAND	0x102
#define HELP_CONTENTS	3
#define HELP_CONTEXT	1
#define HELP_CONTEXTPOPUP	8
#define HELP_FORCEFILE	9
#define HELP_HELPONHELP	4
#define HELP_INDEX	3
#define HELP_KEY	0x101
#define HELP_MULTIKEY	0x201
#define HELP_PARTIALKEY	0x105
#define HELP_QUIT	2
#define HELP_SETCONTENTS	5
#define HELP_SETINDEX	5
#define HELP_CONTEXTMENU	0xa
#define HELP_FINDER	0xb
#define HELP_WM_HELP	0xc
#define HELP_TCARD	0x8000
#define HELP_TCARD_DATA	16
#define HELP_TCARD_OTHER_CALLER	0x11
#define WNNC_NET_MSNET 0x010000
#define WNNC_NET_LANMAN 0x020000
#define WNNC_NET_NETWARE 0x030000
#define WNNC_NET_VINES 0x040000
#define WNNC_NET_10NET 0x050000
#define WNNC_NET_LOCUS 0x060000
#define WNNC_NET_SUN_PC_NFS 0x070000
#define WNNC_NET_LANSTEP 0x080000
#define WNNC_NET_9TILES 0x090000
#define WNNC_NET_LANTASTIC 0x0A0000
#define WNNC_NET_AS400 0x0B0000
#define WNNC_NET_FTP_NFS 0x0C0000
#define WNNC_NET_PATHWORKS 0x0D0000
#define WNNC_NET_LIFENET 0x0E0000
#define WNNC_NET_POWERLAN 0x0F0000
#define WNNC_NET_BWNFS 0x100000
#define WNNC_NET_COGENT 0x110000
#define WNNC_NET_FARALLON 0x120000
#define WNNC_NET_APPLETALK 0x130000
#define WNNC_NET_INTERGRAPH 0x140000
#define WNNC_NET_SYMFONET 0x150000
#define WNNC_NET_CLEARCASE 0x160000
#define WNNC_NET_FRONTIER 0x170000
#define WNNC_NET_BMC 0x180000
#define WNNC_NET_DCE 0x190000
#define WNNC_NET_DECORB 0x200000
#define WNNC_NET_PROTSTOR 0x210000
#define WNNC_NET_FJ_REDIR 0x220000
#define WNNC_NET_DISTINCT 0x230000
#define WNNC_NET_TWINS 0x240000
#define WNNC_NET_RDR2SAMPLE 0x250000
#define WNFMT_MULTILINE 1
#define WNFMT_ABBREVIATED 2
#define WNFMT_INENUM 16
#define WNFMT_CONNECTION	0x20
#define WNCON_FORNETCARD	1
#define WNCON_NOTROUTED	2
#define WNCON_SLOWLINK	4
#define WNCON_DYNAMIC	8
#define NETINFO_DLL16	1
#define NETINFO_DISKRED	4
#define NETINFO_PRINTERRED	8
#define NETPROPERTY_PERSISTENT	1
#define CONNECT_UPDATE_PROFILE	1
#define CONNECT_UPDATE_RECENT	2
#define CONNECT_TEMPORARY	4
#define CONNECT_INTERACTIVE	8
#define CONNECT_PROMPT		16
#define CONNECT_NEED_DRIVE	32
#define CONNECT_REFCOUNT	64
#define CONNECT_REDIRECT	0x80
#define CONNECT_LOCALDRIVE	0x100
#define CONNECT_CURRENT_MEDIA	0x200
#define CONNECT_DEFERRED	0x400
#define CONNECT_RESERVED	0xFF000000
#define CONNDLG_RO_PATH		1
#define CONNDLG_CONN_POINT	2
#define CONNDLG_USE_MRU		4
#define CONNDLG_HIDE_BOX	8
#define CONNDLG_PERSIST		16
#define CONNDLG_NOT_PERSIST	32
#define DISC_UPDATE_PROFILE	1
#define DISC_NO_FORCE		0x40
#define RESOURCETYPE_DISK	1
#define RESOURCETYPE_PRINT	2
#define RESOURCETYPE_ANY	0
#define RESOURCE_CONNECTED	1
#define RESOURCE_GLOBALNET	2
#define RESOURCE_REMEMBERED	3
#define RESOURCEUSAGE_CONNECTABLE	1
#define RESOURCEUSAGE_CONTAINER	2
#define WN_SUCCESS NO_ERROR
#define WN_NO_ERROR NO_ERROR
#define WN_NOT_SUPPORTED ERROR_NOT_SUPPORTED
#define WN_CANCEL ERROR_CANCELLED
#define WN_RETRY ERROR_RETRY
#define WN_NET_ERROR ERROR_UNEXP_NET_ERR
#define WN_MORE_DATA ERROR_MORE_DATA
#define WN_BAD_POINTER ERROR_INVALID_ADDRESS
#define WN_BAD_VALUE ERROR_INVALID_PARAMETER
#define WN_BAD_USER ERROR_BAD_USERNAME
#define WN_BAD_PASSWORD ERROR_INVALID_PASSWORD
#define WN_ACCESS_DENIED ERROR_ACCESS_DENIED
#define WN_FUNCTION_BUSY ERROR_BUSY
#define WN_WINDOWS_ERROR ERROR_UNEXP_NET_ERR
#define WN_OUT_OF_MEMORY ERROR_NOT_ENOUGH_MEMORY
#define WN_NO_NETWORK ERROR_NO_NETWORK
#define WN_EXTENDED_ERROR ERROR_EXTENDED_ERROR
#define WN_BAD_LEVEL ERROR_INVALID_LEVEL
#define WN_BAD_HANDLE ERROR_INVALID_HANDLE
#define WN_NOT_INITIALIZING ERROR_ALREADY_INITIALIZED
#define WN_NO_MORE_DEVICES ERROR_NO_MORE_DEVICES
#define WN_NOT_CONNECTED ERROR_NOT_CONNECTED
#define WN_OPEN_FILES ERROR_OPEN_FILES
#define WN_DEVICE_IN_USE ERROR_DEVICE_IN_USE
#define WN_BAD_NETNAME ERROR_BAD_NET_NAME
#define WN_BAD_LOCALNAME ERROR_BAD_DEVICE
#define WN_ALREADY_CONNECTED ERROR_ALREADY_ASSIGNED
#define WN_DEVICE_ERROR ERROR_GEN_FAILURE
#define WN_CONNECTION_CLOSED ERROR_CONNECTION_UNAVAIL
#define WN_NO_NET_OR_BAD_PATH ERROR_NO_NET_OR_BAD_PATH
#define WN_BAD_PROVIDER ERROR_BAD_PROVIDER
#define WN_CANNOT_OPEN_PROFILE ERROR_CANNOT_OPEN_PROFILE
#define WN_BAD_PROFILE ERROR_BAD_PROFILE
#define WN_BAD_DEV_TYPE ERROR_BAD_DEV_TYPE
#define WN_DEVICE_ALREADY_REMEMBERED ERROR_DEVICE_ALREADY_REMEMBERED
#define WN_CONNECTED_OTHER_PASSWORD ERROR_CONNECTED_OTHER_PASSWORD
#define WN_NO_MORE_ENTRIES ERROR_NO_MORE_ITEMS
#define WN_NOT_CONTAINER ERROR_NOT_CONTAINER
#define WN_NOT_AUTHENTICATED ERROR_NOT_AUTHENTICATED
#define WN_NOT_LOGGED_ON ERROR_NOT_LOGGED_ON
#define WN_NOT_VALIDATED ERROR_NO_LOGON_SERVERS
#define UNIVERSAL_NAME_INFO_LEVEL	1
#define REMOTE_NAME_INFO_LEVEL	2
#define STILL_ACTIVE	0x103
#define SP_SERIALCOMM	1
#define BAUD_075	1
#define BAUD_110	2
#define BAUD_134_5	4
#define BAUD_150	8
#define BAUD_300	16
#define BAUD_600	32
#define BAUD_1200	64
#define BAUD_1800	128
#define BAUD_2400	256
#define BAUD_4800	512
#define BAUD_7200	0x400
#define BAUD_9600	0x800
#define BAUD_14400	4096
#define BAUD_19200	0x2000
#define BAUD_38400	0x4000
#define BAUD_56K	0x8000
#define BAUD_57600	0x40000
#define BAUD_115200	0x20000
#define BAUD_128K	0x10000
#define BAUD_USER	0x10000000
#define PST_FAX	0x21
#define PST_LAT	0x101
#define PST_MODEM	6
#define PST_NETWORK_BRIDGE	256
#define PST_PARALLELPORT	2
#define PST_RS232	1
#define PST_RS422	3
#define PST_RS423	4
#define PST_RS449	5
#define PST_SCANNER	0x22
#define PST_TCPIP_TELNET	0x102
#define PST_UNSPECIFIED	0
#define PST_X25	0x103
#define PCF_16BITMODE	512
#define PCF_DTRDSR	1
#define PCF_INTTIMEOUTS	128
#define PCF_PARITY_CHECK	8
#define PCF_RLSD	4
#define PCF_RTSCTS	2
#define PCF_SETXCHAR	32
#define PCF_SPECIALCHARS	256
#define PCF_TOTALTIMEOUTS	64
#define PCF_XONXOFF	16
#define SP_BAUD	2
#define SP_DATABITS	4
#define SP_HANDSHAKING	0x10
#define SP_PARITY	1
#define SP_PARITY_CHECK	32
#define SP_RLSD	64
#define SP_STOPBITS	8
#define DATABITS_5	1
#define DATABITS_6	2
#define DATABITS_7	4
#define DATABITS_8	8
#define DATABITS_16	16
#define DATABITS_16X	32
#define STOPBITS_10	1
#define STOPBITS_15	2
#define STOPBITS_20	4
#define PARITY_NONE	256
#define PARITY_ODD	512
#define PARITY_EVEN	1024
#define PARITY_MARK	2048
#define PARITY_SPACE	4096
#define COMMPROP_INITIALIZED	0xe73cf52e
#define CBR_110	110
#define CBR_300	300
#define CBR_600	600
#define CBR_1200	1200
#define CBR_2400	2400
#define CBR_4800	4800
#define CBR_9600	9600
#define CBR_14400	14400
#define CBR_19200	19200
#define CBR_38400	38400
#define CBR_56000	56000
#define CBR_57600	57600
#define CBR_115200	115200
#define CBR_128000	128000
#define CBR_256000	256000
#define DTR_CONTROL_DISABLE	0
#define DTR_CONTROL_ENABLE	1
#define DTR_CONTROL_HANDSHAKE	2
#define RTS_CONTROL_DISABLE	0
#define RTS_CONTROL_ENABLE	1
#define RTS_CONTROL_HANDSHAKE	2
#define RTS_CONTROL_TOGGLE	3
#define EVENPARITY	2
#define MARKPARITY	3
#define NOPARITY	0
#define SPACEPARITY	4
#define ODDPARITY	1
#define ONESTOPBIT	0
#define ONE5STOPBITS	1
#define TWOSTOPBITS	2
#define CREATE_FOR_IMPORT 1
#define CREATE_FOR_DIR 2
#define OVERWRITE_HIDDEN 4
#define CREATE_PROCESS_DEBUG_EVENT	3
#define CREATE_THREAD_DEBUG_EVENT	2
#define EXCEPTION_DEBUG_EVENT	1
#define EXIT_PROCESS_DEBUG_EVENT	5
#define EXIT_THREAD_DEBUG_EVENT	4
#define LOAD_DLL_DEBUG_EVENT	6
#define OUTPUT_DEBUG_STRING_EVENT	8
#define UNLOAD_DLL_DEBUG_EVENT	7
#define RIP_EVENT	9
#define PROCESS_HEAP_REGION	1
#define PROCESS_HEAP_UNCOMMITTED_RANGE	2
#define PROCESS_HEAP_ENTRY_BUSY	4
#define PROCESS_HEAP_ENTRY_MOVEABLE	16
#define PROCESS_HEAP_ENTRY_DDESHARE	32
#define HINSTANCE_ERROR	32
#define BACKUP_INVALID	0
#define BACKUP_DATA	1
#define BACKUP_EA_DATA	2
#define BACKUP_SECURITY_DATA	3
#define BACKUP_ALTERNATE_DATA	4
#define BACKUP_LINK	5
#define BACKUP_PROPERTY_DATA	6
#define BACKUP_OBJECT_ID	7
#define BACKUP_REPARSE_DATA	8
#define BACKUP_SPARSE_BLOCK	9
#define STREAM_NORMAL_ATTRIBUTE	0
#define STREAM_MODIFIED_WHEN_READ	1
#define STREAM_CONTAINS_SECURITY	2
#define STREAM_CONTAINS_PROPERTIES	4
#define STREAM_SPARSE_ATTRIBUTE	8
#define STARTF_USESHOWWINDOW	1
#define STARTF_USEPOSITION	4
#define STARTF_USESIZE	2
#define STARTF_RUNFULLSCREEN	0x20
#define STARTF_USECOUNTCHARS	8
#define STARTF_USEFILLATTRIBUTE	16
#define STARTF_FORCEONFEEDBACK	64
#define STARTF_FORCEOFFFEEDBACK	128
#define STARTF_USESTDHANDLES	256
#define STARTF_USEHOTKEY	0x0200
#define VER_PLATFORM_WIN32s	0
#define VER_PLATFORM_WIN32_WINDOWS 1
#define VER_PLATFORM_WIN32_NT	2
#define MAXPROPPAGES	100
#define PSP_DEFAULT	0
#define PSP_HASHELP	32
#define PSP_USECALLBACK	128
#define PSP_USEHICON	2
#define PSP_USEICONID	4
#define PSP_USEREFPARENT	64
#define PSP_USETITLE	8
#define PSP_RTLREADING	16
#define PSP_DLGINDIRECT	1
#define PSH_DEFAULT	0
#define PSH_HASHELP	512
#define PSH_MODELESS	1024
#define PSH_NOAPPLYNOW	128
#define PSH_PROPSHEETPAGE	8
#define PSH_PROPTITLE	1
#define PSH_USECALLBACK	256
#define PSH_USEHICON	2
#define PSH_USEICONID	4
#define PSH_USEPSTARTPAGE	64
#define PSH_WIZARD	32
#define PSH_RTLREADING	2048
#define PSCB_INITIALIZED	1
#define PSCB_PRECREATE	2
#define PSNRET_NOERROR	0
#define PSNRET_INVALID_NOCHANGEPAGE	2
#define PSBTN_APPLYNOW	4
#define PSBTN_BACK	0
#define PSBTN_CANCEL	5
#define PSBTN_FINISH	2
#define PSBTN_HELP	6
#define PSBTN_NEXT	1
#define PSBTN_OK	3
#define PSWIZB_BACK	1
#define PSWIZB_NEXT	2
#define PSWIZB_FINISH	4
#define PSWIZB_DISABLEDFINISH	8
#define ID_PSREBOOTSYSTEM	3
#define ID_PSRESTARTWINDOWS	2
#define WIZ_BODYCX	184
#define WIZ_BODYX	92
#define WIZ_CXBMP	80
#define WIZ_CXDLG	276
#define WIZ_CYDLG	140
#define PAN_ANY	0
#define PAN_NO_FIT	1
#define PAN_FAMILY_TEXT_DISPLAY	2
#define PAN_FAMILY_SCRIPT	3
#define PAN_FAMILY_DECORATIVE	4
#define PAN_FAMILY_PICTORIAL	5
#define PAN_SERIF_COVE	2
#define PAN_SERIF_OBTUSE_COVE	3
#define PAN_SERIF_SQUARE_COVE	4
#define PAN_SERIF_OBTUSE_SQUARE_COVE	5
#define PAN_SERIF_SQUARE	6
#define PAN_SERIF_THIN	7
#define PAN_SERIF_BONE	8
#define PAN_SERIF_EXAGGERATED	9
#define PAN_SERIF_TRIANGLE	10
#define PAN_SERIF_NORMAL_SANS	11
#define PAN_SERIF_OBTUSE_SANS	12
#define PAN_SERIF_PERP_SANS	13
#define PAN_SERIF_FLARED	14
#define PAN_SERIF_ROUNDED	15
#define PAN_WEIGHT_VERY_LIGHT	2
#define PAN_WEIGHT_LIGHT	3
#define PAN_WEIGHT_THIN	4
#define PAN_WEIGHT_BOOK	5
#define PAN_WEIGHT_MEDIUM	6
#define PAN_WEIGHT_DEMI	7
#define PAN_WEIGHT_BOLD	8
#define PAN_WEIGHT_HEAVY	9
#define PAN_WEIGHT_BLACK	10
#define PAN_WEIGHT_NORD	11
#define PAN_PROP_OLD_STYLE	2
#define PAN_PROP_MODERN	3
#define PAN_PROP_EVEN_WIDTH	4
#define PAN_PROP_EXPANDED	5
#define PAN_PROP_CONDENSED	6
#define PAN_PROP_VERY_EXPANDED	7
#define PAN_PROP_VERY_CONDENSED	8
#define PAN_PROP_MONOSPACED	9
#define PAN_CONTRAST_NONE	2
#define PAN_CONTRAST_VERY_LOW	3
#define PAN_CONTRAST_LOW	4
#define PAN_CONTRAST_MEDIUM_LOW	5
#define PAN_CONTRAST_MEDIUM	6
#define PAN_CONTRAST_MEDIUM_HIGH	7
#define PAN_CONTRAST_HIGH	8
#define PAN_CONTRAST_VERY_HIGH	9
#define PAN_STROKE_GRADUAL_DIAG	2
#define PAN_STROKE_GRADUAL_TRAN	3
#define PAN_STROKE_GRADUAL_VERT	4
#define PAN_STROKE_GRADUAL_HORZ	5
#define PAN_STROKE_RAPID_VERT	6
#define PAN_STROKE_RAPID_HORZ	7
#define PAN_STROKE_INSTANT_VERT	8
#define PAN_STRAIGHT_ARMS_HORZ	2
#define PAN_STRAIGHT_ARMS_WEDGE	3
#define PAN_STRAIGHT_ARMS_VERT	4
#define PAN_STRAIGHT_ARMS_SINGLE_SERIF	5
#define PAN_STRAIGHT_ARMS_DOUBLE_SERIF	6
#define PAN_BENT_ARMS_HORZ	7
#define PAN_BENT_ARMS_VERT	9
#define PAN_BENT_ARMS_WEDGE	8
#define PAN_BENT_ARMS_SINGLE_SERIF	10
#define PAN_BENT_ARMS_DOUBLE_SERIF	11
#define PAN_LETT_NORMAL_CONTACT	2
#define PAN_LETT_NORMAL_WEIGHTED	3
#define PAN_LETT_NORMAL_BOXED	4
#define PAN_LETT_NORMAL_FLATTENED	5
#define PAN_LETT_NORMAL_ROUNDED	6
#define PAN_LETT_NORMAL_OFF_CENTER	7
#define PAN_LETT_NORMAL_SQUARE	8
#define PAN_LETT_OBLIQUE_CONTACT	9
#define PAN_LETT_OBLIQUE_WEIGHTED	10
#define PAN_LETT_OBLIQUE_BOXED	11
#define PAN_LETT_OBLIQUE_FLATTENED	12
#define PAN_LETT_OBLIQUE_ROUNDED	13
#define PAN_LETT_OBLIQUE_OFF_CENTER	14
#define PAN_LETT_OBLIQUE_SQUARE	15
#define PAN_MIDLINE_STANDARD_TRIMMED	2
#define PAN_MIDLINE_STANDARD_POINTED	3
#define PAN_MIDLINE_STANDARD_SERIFED	4
#define PAN_MIDLINE_HIGH_TRIMMED	5
#define PAN_MIDLINE_HIGH_POINTED	6
#define PAN_MIDLINE_HIGH_SERIFED	7
#define PAN_MIDLINE_CONSTANT_TRIMMED	8
#define PAN_MIDLINE_CONSTANT_POINTED	9
#define PAN_MIDLINE_CONSTANT_SERIFED	10
#define PAN_MIDLINE_LOW_TRIMMED	11
#define PAN_MIDLINE_LOW_POINTED	12
#define PAN_MIDLINE_LOW_SERIFED	13
#define PAN_XHEIGHT_CONSTANT_SMALL	2
#define PAN_XHEIGHT_CONSTANT_STD	3
#define PAN_XHEIGHT_CONSTANT_LARGE	4
#define PAN_XHEIGHT_DUCKING_SMALL	5
#define PAN_XHEIGHT_DUCKING_STD	6
#define PAN_XHEIGHT_DUCKING_LARGE	7
#define PC_EXPLICIT	2
#define PC_NOCOLLAPSE	4
#define PC_RESERVED	1
#define BS_DIBPATTERN	5
#define BS_DIBPATTERN8X8	8
#define BS_DIBPATTERNPT	6
#define BS_HATCHED	2
#define BS_HOLLOW	1
#define BS_NULL	1
#define BS_PATTERN	3
#define BS_PATTERN8X8	7
#define BS_SOLID	0
#define DM_ORIENTATION	1
#define DM_PAPERSIZE	2
#define DM_PAPERLENGTH	4
#define DM_PAPERWIDTH	8
#define DM_SCALE	16
#define DM_COPIES	256
#define DM_DEFAULTSOURCE	512
#define DM_PRINTQUALITY	0x400
#define DM_COLOR	0x800
#define DM_DUPLEX	4096
#define DM_YRESOLUTION	0x2000
#define DM_TTOPTION	0x4000
#define DM_COLLATE	0x8000
#define DM_FORMNAME	0x10000
#define DM_LOGPIXELS	0x20000
#define DM_ICMMETHOD	0x800000
#define DM_ICMINTENT	0x1000000
#define DM_MEDIATYPE	0x2000000
#define DM_DITHERTYPE	0x4000000
#define DMORIENT_LANDSCAPE	2
#define DMORIENT_PORTRAIT	1
#define DMPAPER_FIRST	1
#define DMPAPER_LETTER	1
#define DMPAPER_LEGAL	5
#define DMPAPER_A4	9
#define DMPAPER_CSHEET	24
#define DMPAPER_DSHEET	25
#define DMPAPER_ESHEET	26
#define DMPAPER_LETTERSMALL	2
#define DMPAPER_TABLOID	3
#define DMPAPER_LEDGER	4
#define DMPAPER_STATEMENT	6
#define DMPAPER_EXECUTIVE	7
#define DMPAPER_A3	8
#define DMPAPER_A4SMALL	10
#define DMPAPER_A5	11
#define DMPAPER_B4	12
#define DMPAPER_B5	13
#define DMPAPER_FOLIO	14
#define DMPAPER_QUARTO	15
#define DMPAPER_10X14	16
#define DMPAPER_11X17	17
#define DMPAPER_NOTE	18
#define DMPAPER_ENV_9	19
#define DMPAPER_ENV_10	20
#define DMPAPER_ENV_11	21
#define DMPAPER_ENV_12	22
#define DMPAPER_ENV_14	23
#define DMPAPER_ENV_DL	27
#define DMPAPER_ENV_C5	28
#define DMPAPER_ENV_C3	29
#define DMPAPER_ENV_C4	30
#define DMPAPER_ENV_C6	31
#define DMPAPER_ENV_C65	32
#define DMPAPER_ENV_B4	33
#define DMPAPER_ENV_B5	34
#define DMPAPER_ENV_B6	35
#define DMPAPER_ENV_ITALY	36
#define DMPAPER_ENV_MONARCH	37
#define DMPAPER_ENV_PERSONAL	38
#define DMPAPER_FANFOLD_US	39
#define DMPAPER_FANFOLD_STD_GERMAN	40
#define DMPAPER_FANFOLD_LGL_GERMAN	41
#define DMPAPER_ISO_B4	42
#define DMPAPER_JAPANESE_POSTCARD	43
#define DMPAPER_9X11	44
#define DMPAPER_10X11	45
#define DMPAPER_15X11	46
#define DMPAPER_ENV_INVITE	47
#define DMPAPER_RESERVED_48	48
#define DMPAPER_RESERVED_49	49
#define DMPAPER_LETTER_EXTRA	50
#define DMPAPER_LEGAL_EXTRA	51
#define DMPAPER_TABLOID_EXTRA	52
#define DMPAPER_A4_EXTRA	53
#define DMPAPER_LETTER_TRANSVERSE	54
#define DMPAPER_A4_TRANSVERSE	55
#define DMPAPER_LETTER_EXTRA_TRANSVERSE	56
#define DMPAPER_A_PLUS	57
#define DMPAPER_B_PLUS	58
#define DMPAPER_LETTER_PLUS	59
#define DMPAPER_A4_PLUS	60
#define DMPAPER_A5_TRANSVERSE	61
#define DMPAPER_B5_TRANSVERSE	62
#define DMPAPER_A3_EXTRA	63
#define DMPAPER_A5_EXTRA	64
#define DMPAPER_B5_EXTRA	65
#define DMPAPER_A2	66
#define DMPAPER_A3_TRANSVERSE	67
#define DMPAPER_A3_EXTRA_TRANSVERSE	68
#define DMPAPER_DBL_JAPANESE_POSTCARD 69
#define DMPAPER_A6 70
#define DMPAPER_JENV_KAKU2 71
#define DMPAPER_JENV_KAKU3 72
#define DMPAPER_JENV_CHOU3 73
#define DMPAPER_JENV_CHOU4 74
#define DMPAPER_LETTER_ROTATED 75
#define DMPAPER_A3_ROTATED 76
#define DMPAPER_A4_ROTATED 77
#define DMPAPER_A5_ROTATED 78
#define DMPAPER_B4_JIS_ROTATED 79
#define DMPAPER_B5_JIS_ROTATED 80
#define DMPAPER_JAPANESE_POSTCARD_ROTATED 81
#define DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED 82
#define DMPAPER_A6_ROTATED 83
#define DMPAPER_JENV_KAKU2_ROTATED 84
#define DMPAPER_JENV_KAKU3_ROTATED 85
#define DMPAPER_JENV_CHOU3_ROTATED 86
#define DMPAPER_JENV_CHOU4_ROTATED 87
#define DMPAPER_B6_JIS 88
#define DMPAPER_B6_JIS_ROTATED 89
#define DMPAPER_12X11 90
#define DMPAPER_JENV_YOU4 91
#define DMPAPER_JENV_YOU4_ROTATED 92
#define DMPAPER_P16K 93
#define DMPAPER_P32K 94
#define DMPAPER_P32KBIG 95
#define DMPAPER_PENV_1 96
#define DMPAPER_PENV_2 97
#define DMPAPER_PENV_3 98
#define DMPAPER_PENV_4 99
#define DMPAPER_PENV_5 100
#define DMPAPER_PENV_6 101
#define DMPAPER_PENV_7 102
#define DMPAPER_PENV_8 103
#define DMPAPER_PENV_9 104
#define DMPAPER_PENV_10 105
#define DMPAPER_P16K_ROTATED 106
#define DMPAPER_P32K_ROTATED 107
#define DMPAPER_P32KBIG_ROTATED 108
#define DMPAPER_PENV_1_ROTATED 109
#define DMPAPER_PENV_2_ROTATED 110
#define DMPAPER_PENV_3_ROTATED 111
#define DMPAPER_PENV_4_ROTATED 112
#define DMPAPER_PENV_5_ROTATED 113
#define DMPAPER_PENV_6_ROTATED 114
#define DMPAPER_PENV_7_ROTATED 115
#define DMPAPER_PENV_8_ROTATED 116
#define DMPAPER_PENV_9_ROTATED 117
#define DMPAPER_PENV_10_ROTATED 118
#define DMPAPER_LAST 118
#define DMPAPER_USER 256
#define DMBIN_FIRST	1
#define DMBIN_UPPER	1
#define DMBIN_ONLYONE	1
#define DMBIN_LOWER	2
#define DMBIN_MIDDLE	3
#define DMBIN_MANUAL	4
#define DMBIN_ENVELOPE	5
#define DMBIN_ENVMANUAL	6
#define DMBIN_AUTO	7
#define DMBIN_TRACTOR	8
#define DMBIN_SMALLFMT	9
#define DMBIN_LARGEFMT	10
#define DMBIN_LARGECAPACITY	11
#define DMBIN_CASSETTE	14
#define DMBIN_FORMSOURCE	15
#define DMBIN_LAST	15
#define DMBIN_USER	256
#define DMRES_HIGH	(-4)
#define DMRES_MEDIUM	(-3)
#define DMRES_LOW	(-2)
#define DMRES_DRAFT	(-1)
#define DMCOLOR_COLOR	2
#define DMCOLOR_MONOCHROME	1
#define DMDUP_SIMPLEX	1
#define DMDUP_HORIZONTAL	3
#define DMDUP_VERTICAL	2
#define DMTT_BITMAP	1
#define DMTT_DOWNLOAD	2
#define DMTT_SUBDEV	3
#define DMCOLLATE_TRUE	1
#define DMCOLLATE_FALSE	0
#define DM_GRAYSCALE	1
#define DM_INTERLACED	2
#define DMICMMETHOD_NONE	1
#define DMICMMETHOD_SYSTEM	2
#define DMICMMETHOD_DRIVER	3
#define DMICMMETHOD_DEVICE	4
#define DMICMMETHOD_USER	256
#define DMICM_SATURATE	1
#define DMICM_CONTRAST	2
#define DMICM_COLORMETRIC	3
#define DMICM_USER	256
#define DMMEDIA_STANDARD	1
#define DMMEDIA_GLOSSY	3
#define DMMEDIA_TRANSPARENCY	2
#define DMMEDIA_USER	256
#define DMDITHER_NONE	1
#define DMDITHER_COARSE	2
#define DMDITHER_FINE	3
#define DMDITHER_LINEART	4
#define DMDITHER_GRAYSCALE	10
#define DMDITHER_USER	256
#define DISPLAY_DEVICE_ATTACHED_TO_DESKTOP 1
#define DISPLAY_DEVICE_MULTI_DRIVER	2
#define DISPLAY_DEVICE_PRIMARY_DEVICE	4
#define DISPLAY_DEVICE_MIRRORING_DRIVER 8
#define DISPLAY_DEVICE_VGA_COMPATIBLE	0x10
#define DISPLAY_DEVICE_REMOVABLE	0x20
#define DISPLAY_DEVICE_MODESPRUNED	0x08000000
#define DISPLAY_DEVICE_REMOTE	0x04000000
#define DISPLAY_DEVICE_DISCONNECT 0x02000000
#define RDH_RECTANGLES	1
#define TT_POLYGON_TYPE	24
#define TT_PRIM_LINE	1
#define TT_PRIM_QSPLINE	2
#define GCPCLASS_ARABIC	2
#define GCPCLASS_HEBREW	2
#define GCPCLASS_LATIN	1
#define GCPCLASS_LATINNUMBER	5
#define GCPCLASS_LOCALNUMBER	4
#define GCPCLASS_LATINNUMERICSEPARATOR	7
#define GCPCLASS_LATINNUMERICTERMINATOR	6
#define GCPCLASS_NEUTRAL	3
#define GCPCLASS_NUMERICSEPARATOR	8
#define GCPCLASS_PREBOUNDLTR	128
#define GCPCLASS_PREBOUNDRTL	64
#define GCPCLASS_POSTBOUNDLTR	32
#define GCPCLASS_POSTBOUNDRTL	16
#define GCPGLYPH_LINKBEFORE	32768
#define GCPGLYPH_LINKAFTER	16384
#define TT_AVAILABLE	1
#define TT_ENABLED	2
#define CA_NEGATIVE	1
#define CA_LOG_FILTER	2
#define ILLUMINANT_DEVICE_DEFAULT	0
#define ILLUMINANT_A	1
#define ILLUMINANT_B	2
#define ILLUMINANT_C	3
#define ILLUMINANT_D50	4
#define ILLUMINANT_D55	5
#define ILLUMINANT_D65	6
#define ILLUMINANT_D75	7
#define ILLUMINANT_F2	8
#define ILLUMINANT_TUNGSTEN	1
#define ILLUMINANT_DAYLIGHT	3
#define ILLUMINANT_FLUORESCENT	8
#define ILLUMINANT_NTSC	3
#define ILLUMINANT_MAX_INDEX	ILLUMINANT_F2
#define REFERENCE_WHITE_MIN	(WORD)6000
#define REFERENCE_WHITE_MAX	(WORD)10000
#define REFERENCE_BLACK_MIN	(WORD)0
#define REFERENCE_BLACK_MAX	(WORD)4000
#define DI_APPBANDING	1
#define EMR_HEADER	1
#define EMR_POLYBEZIER	2
#define EMR_POLYGON	3
#define EMR_POLYLINE	4
#define EMR_POLYBEZIERTO	5
#define EMR_POLYLINETO	6
#define EMR_POLYPOLYLINE	7
#define EMR_POLYPOLYGON	8
#define EMR_SETWINDOWEXTEX	9
#define EMR_SETWINDOWORGEX	10
#define EMR_SETVIEWPORTEXTEX	11
#define EMR_SETVIEWPORTORGEX	12
#define EMR_SETBRUSHORGEX	13
#define EMR_EOF	14
#define EMR_SETPIXELV	15
#define EMR_SETMAPPERFLAGS	16
#define EMR_SETMAPMODE	17
#define EMR_SETBKMODE	18
#define EMR_SETPOLYFILLMODE	19
#define EMR_SETROP2	20
#define EMR_SETSTRETCHBLTMODE	21
#define EMR_SETTEXTALIGN	22
#define EMR_SETCOLORADJUSTMENT	23
#define EMR_SETTEXTCOLOR	24
#define EMR_SETBKCOLOR	25
#define EMR_OFFSETCLIPRGN	26
#define EMR_MOVETOEX	27
#define EMR_SETMETARGN	28
#define EMR_EXCLUDECLIPRECT	29
#define EMR_INTERSECTCLIPRECT	30
#define EMR_SCALEVIEWPORTEXTEX	31
#define EMR_SCALEWINDOWEXTEX	32
#define EMR_SAVEDC	33
#define EMR_RESTOREDC	34
#define EMR_SETWORLDTRANSFORM	35
#define EMR_MODIFYWORLDTRANSFORM	36
#define EMR_SELECTOBJECT	37
#define EMR_CREATEPEN	38
#define EMR_CREATEBRUSHINDIRECT	39
#define EMR_DELETEOBJECT	40
#define EMR_ANGLEARC	41
#define EMR_ELLIPSE	42
#define EMR_RECTANGLE	43
#define EMR_ROUNDRECT	44
#define EMR_ARC	45
#define EMR_CHORD	46
#define EMR_PIE	47
#define EMR_SELECTPALETTE	48
#define EMR_CREATEPALETTE	49
#define EMR_SETPALETTEENTRIES	50
#define EMR_RESIZEPALETTE	51
#define EMR_REALIZEPALETTE	52
#define EMR_EXTFLOODFILL	53
#define EMR_LINETO	54
#define EMR_ARCTO	55
#define EMR_POLYDRAW	56
#define EMR_SETARCDIRECTION	57
#define EMR_SETMITERLIMIT	58
#define EMR_BEGINPATH	59
#define EMR_ENDPATH	60
#define EMR_CLOSEFIGURE	61
#define EMR_FILLPATH	62
#define EMR_STROKEANDFILLPATH	63
#define EMR_STROKEPATH	64
#define EMR_FLATTENPATH	65
#define EMR_WIDENPATH	66
#define EMR_SELECTCLIPPATH	67
#define EMR_ABORTPATH	68
#define EMR_GDICOMMENT	70
#define EMR_FILLRGN	71
#define EMR_FRAMERGN	72
#define EMR_INVERTRGN	73
#define EMR_PAINTRGN	74
#define EMR_EXTSELECTCLIPRGN	75
#define EMR_BITBLT	76
#define EMR_STRETCHBLT	77
#define EMR_MASKBLT	78
#define EMR_PLGBLT	79
#define EMR_SETDIBITSTODEVICE	80
#define EMR_STRETCHDIBITS	81
#define EMR_EXTCREATEFONTINDIRECTW	82
#define EMR_EXTTEXTOUTA	83
#define EMR_EXTTEXTOUTW	84
#define EMR_POLYBEZIER16	85
#define EMR_POLYGON16	86
#define EMR_POLYLINE16	87
#define EMR_POLYBEZIERTO16	88
#define EMR_POLYLINETO16	89
#define EMR_POLYPOLYLINE16	90
#define EMR_POLYPOLYGON16	91
#define EMR_POLYDRAW16	92
#define EMR_CREATEMONOBRUSH	93
#define EMR_CREATEDIBPATTERNBRUSHPT	94
#define EMR_EXTCREATEPEN	95
#define EMR_POLYTEXTOUTA	96
#define EMR_POLYTEXTOUTW	97
#define EMR_SETICMMODE	98
#define EMR_CREATECOLORSPACE	99
#define EMR_SETCOLORSPACE	100
#define EMR_DELETECOLORSPACE	101
#define EMR_GLSRECORD	102
#define EMR_GLSBOUNDEDRECORD	103
#define EMR_PIXELFORMAT	104
#define EMR_RESERVED_105 105
#define EMR_RESERVED_106 106
#define EMR_RESERVED_107 107
#define EMR_RESERVED_108 108
#define EMR_RESERVED_109 109
#define EMR_RESERVED_110 110
#define EMR_COLORCORRECTPALETTE 111
#define EMR_SETICMPROFILEA 112
#define EMR_SETICMPROFILEW 113
#define EMR_ALPHABLEND 114
#define EMR_SETLAYOUT 115
#define EMR_TRANSPARENTBLT 116
#define EMR_RESERVED_117 117
#define EMR_GRADIENTFILL 118
#define EMR_RESERVED_119 119
#define EMR_RESERVED_120 120
#define EMR_COLORMATCHTOTARGETW 121
#define EMR_CREATECOLORSPACEW 122
#define ENHMETA_SIGNATURE	1179469088
#define ENM_NONE	0
#define ENM_CHANGE	1
#define ENM_UPDATE	2
#define ENM_SCROLL	4
#define ENM_KEYEVENTS 0x10000
#define ENM_MOUSEEVENTS 0x20000
#define ENM_REQUESTRESIZE 0x40000
#define ENM_SELCHANGE 0x80000
#define ENM_DROPFILES 0x100000
#define ENM_PROTECTED 0x200000
#define ENM_CORRECTTEXT 0x400000
#define ENM_SCROLLEVENTS	8
#define ENM_DRAGDROPDONE	16
#define ENM_PARAGRAPHEXPANDED	32
#define ENM_IMECHANGE	0x800000
#define ENM_LANGCHANGE	0x1000000
#define ENM_OBJECTPOSITIONS	0x2000000
#define ES_DISABLENOSCROLL	0x2000

//#if (WINVER > 1024)
#define ES_EX_NOCALLOLEINIT 0
//#else
//#define ES_EX_NOCALLOLEINIT 16777216
//#endif
#define ES_NOIME	0x80000
#define ES_SAVESEL	0x8000
#define ES_SELFIME	0x40000
#define ES_SUNKEN	0x4000
#define ES_VERTICAL	0x400000
#define ES_SELECTIONBAR	0x1000000
#define ECOOP_SET	1
#define ECOOP_OR	2
#define ECOOP_AND	3
#define ECOOP_XOR	4
#define ECO_AUTOWORDSELECTION	1
#define ECO_AUTOVSCROLL	64
#define ECO_AUTOHSCROLL	128
#define ECO_NOHIDESEL	256
#define ECO_READONLY	2048
#define ECO_WANTRETURN	4096
#define ECO_SAVESEL	0x8000
#define ECO_SELECTIONBAR	0x1000000
#define ECO_VERTICAL	0x400000
#define SCF_WORD	2
#define SCF_SELECTION	1
#define SF_TEXT	1
#define SF_RTF	2
#define SF_RTFNOOBJS	3
#define SF_TEXTIZED	4
#define SFF_SELECTION	0x8000
#define SFF_PLAINRTF	0x4000
#define WB_CLASSIFY	3
#define WB_ISDELIMITER	2
#define WB_LEFT	0
#define WB_LEFTBREAK	6
#define WB_PREVBREAK	6
#define WB_MOVEWORDLEFT	4
#define WB_MOVEWORDPREV	4
#define WB_MOVEWORDRIGHT	5
#define WB_MOVEWORDNEXT	5
#define WB_RIGHT	1
#define WB_RIGHTBREAK	7
#define WB_NEXTBREAK	7
#define PC_LEADING	2
#define PC_FOLLOWING	1
#define PC_DELIMITER	4
#define PC_OVERFLOW	3
#define WBF_WORDWRAP	16
#define WBF_WORDBREAK	32
#define WBF_OVERFLOW	64
#define WBF_LEVEL1	128
#define WBF_LEVEL2	256
#define WBF_CUSTOM	512
#define WBF_BREAKAFTER	64
#define WBF_BREAKLINE	32
#define WBF_ISWHITE	16
#define CFM_BOLD	1
#define CFM_COLOR	0x40000000
#define CFM_FACE	0x20000000
#define CFM_ITALIC	2
#define CFM_OFFSET	0x10000000
#define CFM_PROTECTED	16
#define CFM_SIZE	0x80000000
#define CFM_STRIKEOUT	8
#define CFM_UNDERLINE	4
#define CFE_AUTOCOLOR	0x40000000
#define CFE_BOLD	1
#define CFE_ITALIC	2
#define CFE_STRIKEOUT	8
#define CFE_UNDERLINE	4
#define CFE_PROTECTED	16
#define PFM_ALIGNMENT	8
#define PFM_NUMBERING	32
#define PFM_OFFSET	4
#define PFM_OFFSETINDENT	0x80000000
#define PFM_RIGHTINDENT	2
#define PFM_STARTINDENT	1
#define PFM_TABSTOPS	16
#define PFN_BULLET	1
#define PFA_LEFT	1
#define PFA_RIGHT	2
#define PFA_CENTER	3
#define SEL_EMPTY	0
#define SEL_TEXT	1
#define SEL_OBJECT	2
#define SEL_MULTICHAR	4
#define SEL_MULTIOBJECT	8
#define CF_RTF	TEXT("Rich Text Format")
#define CF_RETEXTOBJ	TEXT("RichEdit Text and Objects")
#define ODT_BUTTON	4
#define ODT_COMBOBOX	3
#define ODT_LISTBOX	2
#define ODT_LISTVIEW	102
#define ODT_MENU	1
#define ODT_STATIC	5
#define ODT_TAB	101
#define ODT_HEADER	100
#define ODA_DRAWENTIRE	1
#define ODA_FOCUS	4
#define ODA_SELECT	2
#define ODS_CHECKED	8
#define ODS_COMBOBOXEDIT	4096
#define ODS_DEFAULT	32
#define ODS_DISABLED	4
#define ODS_FOCUS	16
#define ODS_GRAYED	2
#define ODS_SELECTED	1
#define ANIMATE_CLASSW	L"SysAnimate32"
#define HOTKEY_CLASSW	L"msctls_hotkey32"
#define PROGRESS_CLASSW	L"msctls_progress32"
#define STATUSCLASSNAMEW	L"msctls_statusbar32"
#define REBARCLASSNAMEW		L"ReBarWindow32"
#define TOOLBARCLASSNAMEW	L"ToolbarWindow32"
#define TOOLTIPS_CLASSW	L"tooltips_class32"
#define TRACKBAR_CLASSW	L"msctls_trackbar32"
#define UPDOWN_CLASSW	L"msctls_updown32"
#define WC_HEADERW	L"SysHeader32"
#define WC_LISTVIEWW	L"SysListView32"
#define WC_TABCONTROLW	L"SysTabControl32"
#define WC_TREEVIEWW	L"SysTreeView32"
#define WC_PAGESCROLLERW	L"SysPager"
#define WC_PAGESCROLLERA	"SysPager"
#define DATETIMEPICK_CLASSW	L"SysDateTimePick32"
#define DATETIMEPICK_CLASSA	"SysDateTimePick32"
#define CCS_ADJUSTABLE	32
#define CCS_BOTTOM	3
#define CCS_NODIVIDER	64
#define CCS_NOMOVEY	2
#define CCS_NOPARENTALIGN	8
#define CCS_NORESIZE	4
#define CCS_TOP	1
#define CCS_VERT 0x80
#define CCS_LEFT 0x81
#define CCS_RIGHT	(CCS_VERT|CCS_BOTTOM)
#define CCS_NOMOVEX	(CCS_VERT|CCS_NOMOVEY)
#define RICHEDIT_CLASSA         "RichEdit20A"
#define RICHEDIT_CLASS10A   "RICHEDIT"

//#ifndef _RICHEDIT_VER
#define _RICHEDIT_VER  0x0210
//#endif

#define RICHEDIT_CLASSA      "RichEdit20A"
#define RICHEDIT_CLASS10A     "RICHEDIT"
#define RICHEDIT_CLASSW      L"RichEdit20W"
//#if (_RICHEDIT_VER >= 0x0200 )

#ifdef UNICODE
	#define RICHEDIT_CLASS       RICHEDIT_CLASSW
#else
	#define RICHEDIT_CLASS       RICHEDIT_CLASSA
#endif
//#else
//#define RICHEDIT_CLASS       RICHEDIT_CLASS10A
//#endif /* _RICHEDIT_VER >= 0x0200 */

#define ANIMATE_CLASSA	"SysAnimate32"
#define HOTKEY_CLASSA	"msctls_hotkey32"
#define PROGRESS_CLASSA	"msctls_progress32"
#define STATUSCLASSNAMEA	"msctls_statusbar32"
#define REBARCLASSNAMEA	"ReBarWindow32"
#define TOOLBARCLASSNAMEA	"ToolbarWindow32"
#define TOOLTIPS_CLASSA	"tooltips_class32"
#define TRACKBAR_CLASSA	"msctls_trackbar32"
#define UPDOWN_CLASSA	"msctls_updown32"
#define WC_HEADERA	"SysHeader32"
#define WC_LISTVIEWA	"SysListView32"
#define WC_TABCONTROLA	"SysTabControl32"
#define WC_TREEVIEWA	"SysTreeView32"
#define HDS_BUTTONS	2
#define HDS_HIDDEN	8
#define HDS_HOTTRACK	4
#define HDS_DRAGDROP	0x40
#define HDS_FULLDRAG	0x80
#define HDS_FILTERBAR	0x100
#define HDS_HORZ	0
#define HDS_FLAT	0x0200
#define HDFT_ISSTRING	0
#define HDFT_ISNUMBER	1
#define HDFT_HASNOVALUE 0x8000
#define HDI_BITMAP	16
#define HDI_FORMAT	4
#define HDI_HEIGHT	1
#define HDI_LPARAM	8
#define HDI_TEXT	2
#define HDI_WIDTH	1
#define HDI_IMAGE	0x20
#define HDI_DI_SETITEM	0x40
#define HDI_ORDER	0x80
#define HDI_FILTER	0x100
#define HDF_CENTER	2
#define HDF_LEFT	0
#define HDF_RIGHT	1
#define HDF_RTLREADING	4
#define HDF_BITMAP	8192
#define HDF_OWNERDRAW	32768
#define HDF_STRING	16384
#define HDF_BITMAP_ON_RIGHT 0x1000
#define HDF_IMAGE	0x800
#define HDF_SORTUP	0x0400
#define HDF_SORTDOWN	0x0200
#define HDF_JUSTIFYMASK	3
#define HHT_NOWHERE	1
#define HHT_ONDIVIDER	4
#define HHT_ONDIVOPEN	8
#define HHT_ONHEADER	2
#define HHT_TOLEFT	2048
#define HHT_TORIGHT	1024
#define HHT_ONFILTER	0x0010
#define HHT_ONFILTERBUTTON 0x0020
#define HHT_ABOVE	0x0100
#define HHT_BELOW	0x0200
#define HINST_COMMCTRL	((HANDLE)-1)
#define IDB_STD_LARGE_COLOR	1
#define IDB_STD_SMALL_COLOR	0
#define IDB_VIEW_LARGE_COLOR	5
#define IDB_VIEW_SMALL_COLOR	4
#define IDB_HIST_SMALL_COLOR	8
#define IDB_HIST_LARGE_COLOR	9
#define STD_COPY	1
#define STD_CUT	0
#define STD_DELETE	5
#define STD_FILENEW	6
#define STD_FILEOPEN	7
#define STD_FILESAVE	8
#define STD_FIND	12
#define STD_HELP	11
#define STD_PASTE	2
#define STD_PRINT	14
#define STD_PRINTPRE	9
#define STD_PROPERTIES	10
#define STD_REDOW	4
#define STD_REPLACE	13
#define STD_UNDO	3
#define VIEW_LARGEICONS	0
#define VIEW_SMALLICONS	1
#define VIEW_LIST	2
#define VIEW_DETAILS	3
#define VIEW_SORTNAME	4
#define VIEW_SORTSIZE	5
#define VIEW_SORTDATE	6
#define VIEW_SORTTYPE	7
#define VIEW_PARENTFOLDER	8
#define VIEW_NETCONNECT	9
#define VIEW_NETDISCONNECT	10
#define VIEW_NEWFOLDER	11
#define VIEW_VIEWMENU	12
#define HIST_BACK	0
#define HIST_FORWARD	1
#define HIST_FAVORITES	2
#define HIST_ADDTOFAVORITES	3
#define HIST_VIEWTREE	4
#define TBSTYLE_FLAT	2048
#define TBSTYLE_ALTDRAG	1024
#define TBSTYLE_TOOLTIPS	256
#define TBSTYLE_WRAPABLE	512
#define TBSTYLE_BUTTON	0
#define TBSTYLE_CHECK	2
#define TBSTYLE_CHECKGROUP	6
#define TBSTYLE_GROUP	4
#define TBSTYLE_SEP	1
#define TBSTYLE_DROPDOWN	8
#define TBSTYLE_AUTOSIZE	16
#define TBSTYLE_NOPREFIX	32
#define TBSTYLE_LIST	0x1000
#define TBSTYLE_CUSTOMERASE	0x2000
#define TBSTYLE_REGISTERDROP	0x4000
#define TBSTYLE_TRANSPARENT	0x8000
#define TBSTYLE_EX_DRAWDDARROWS	1
#define TBSTYLE_EX_MIXEDBUTTONS	0x8
#define TBSTYLE_EX_HIDECLIPPEDBUTTONS	0x10
#define TBSTYLE_EX_DOUBLEBUFFER 0x80
#define TBCDRF_NOEDGES	0x00010000
#define TBCDRF_HILITEHOTTRACK	0x00020000
#define TBCDRF_NOOFFSET	0x040000
#define TBCDRF_NOMARK	0x00080000
#define TBCDRF_NOETCHEDEFFECT	0x00100000
#define TBCDRF_BLENDICON	0x00200000
#define TBCDRF_NOBACKGROUND	0x00400000
#define BTNS_BUTTON	TBSTYLE_BUTTON
#define BTNS_SEP	TBSTYLE_SEP
#define BTNS_CHECK	TBSTYLE_CHECK
#define BTNS_GROUP	TBSTYLE_GROUP
#define BTNS_CHECKGROUP TBSTYLE_CHECKGROUP
#define BTNS_DROPDOWN	TBSTYLE_DROPDOWN
#define BTNS_AUTOSIZE	TBSTYLE_AUTOSIZE
#define BTNS_NOPREFIX	TBSTYLE_NOPREFIX
#define BTNS_SHOWTEXT	0x0040
#define BTNS_WHOLEDROPDOWN	0x0080
#define TBSTATE_CHECKED	1
#define TBSTATE_ENABLED	4
#define TBSTATE_HIDDEN	8
#define TBSTATE_INDETERMINATE	16
#define TBSTATE_PRESSED	2
#define TBSTATE_WRAP	32
#define TBSTATE_ELLIPSES	0x40
#define TBSTATE_MARKED	0x80
#define TBIMHT_AFTER	1
#define TBIMHT_BACKGROUND	2
#define TTS_ALWAYSTIP	1
#define TTS_NOPREFIX	2
#define TTS_NOANIMATE	0x10
#define TTS_NOFADE	0x20
#define TTS_BALLOON	0x40
#define TTS_CLOSE	0x80
#define TTF_IDISHWND	1
#define TTF_CENTERTIP	2
#define TTF_RTLREADING	4
#define TTF_SUBCLASS	16
#define TTF_TRACK	0x0020
#define TTF_ABSOLUTE	0x0080
#define TTF_PARSELINKS	0x1000
#define TTF_DI_SETITEM	0x8000
#define TTI_NONE	0
#define TTI_INFO	1
#define TTI_WARNING	2
#define TTI_ERROR	3
#define TTM_GETBUBBLESIZE	(WM_USER + 30)
#define TTM_POPUP	(WM_USER + 34)
#define TTM_GETTITLE	(WM_USER + 35)
#define TTDT_AUTOMATIC	0
#define TTDT_AUTOPOP	2
#define TTDT_INITIAL	3
#define TTDT_RESHOW	1
#define SBARS_SIZEGRIP	256
#define SBARS_SIZEGRIP	256
#define RBS_TOOLTIPS	0x0100
#define RBS_VARHEIGHT	0x0200
#define RBS_BANDBORDERS	0x0400
#define RBS_FIXEDORDER	0x0800
#define RBS_REGISTERDROP	0x1000
#define RBS_AUTOSIZE	0x2000
#define RBS_VERTICALGRIPPER 0x4000
#define RBS_DBLCLKTOGGLE	0x8000
#define RBIM_IMAGELIST	1
#define RB_INSERTBANDA	(WM_USER+1)
#define RB_DELETEBAND	(WM_USER+2)
#define RB_GETBARINFO	(WM_USER+3)
#define RB_SETBARINFO	(WM_USER+4)
#define RB_GETBANDINFO	(WM_USER+5)
#define RB_SETBANDINFOA	(WM_USER+6)
#define RB_SETPARENT	(WM_USER+7)
#define RB_HITTEST	(WM_USER+8)
#define RB_GETRECT	(WM_USER+9)
#define RB_INSERTBANDW	(WM_USER+10)
#define RB_SETBANDINFOW	(WM_USER+11)
#define RB_GETBANDCOUNT (WM_USER+12)
#define RB_GETROWCOUNT	(WM_USER+13)
#define RB_GETROWHEIGHT	(WM_USER+14)
#define RB_IDTOINDEX (WM_USER+16)
#define RB_GETTOOLTIPS (WM_USER+17)
#define RB_SETTOOLTIPS (WM_USER+18)
#define RB_SETBKCOLOR (WM_USER+19)
#define RB_GETBKCOLOR (WM_USER+20)
#define RB_SETTEXTCOLOR (WM_USER+21)
#define RB_GETTEXTCOLOR (WM_USER+22)
#define RB_SIZETORECT (WM_USER+23)
#define RB_BEGINDRAG	(WM_USER+24)
#define RB_ENDDRAG	(WM_USER+25)
#define RB_DRAGMOVE	(WM_USER+26)
#define RB_GETBARHEIGHT	(WM_USER+27)
#define RB_GETBANDINFOW (WM_USER+28)
#define RB_GETBANDINFOA (WM_USER+29)
#define RB_MINIMIZEBAND (WM_USER+30)
#define RB_MAXIMIZEBAND (WM_USER+31)
#define RB_GETBANDBORDERS (WM_USER+34)
#define RB_SHOWBAND	(WM_USER+35)
#define RB_SETPALETTE	(WM_USER+37)
#define RB_GETPALETTE	(WM_USER+38)
#define RB_SETCOLORSCHEME CCM_SETCOLORSCHEME
#define RB_GETCOLORSCHEME CCM_GETCOLORSCHEME
#define RB_GETDROPTARGET (CCM_GETDROPTARGET)
#define RB_SETUNICODEFORMAT CCM_SETUNICODEFORMAT
#define RB_GETUNICODEFORMAT CCM_GETUNICODEFORMAT
#define RB_GETBANDMARGINS	(WM_USER + 40)
#define RB_SETWINDOWTHEME	CCM_SETWINDOWTHEME
#define RB_PUSHCHEVRON	(WM_USER + 43)
#define RB_MOVEBAND	(WM_USER + 39)
#define RBBIM_STYLE	1
#define RBBIM_COLORS	2
#define RBBIM_TEXT	4
#define RBBIM_IMAGE	8
#define RBBIM_CHILD	16
#define RBBIM_CHILDSIZE	32
#define RBBIM_SIZE	64
#define RBBIM_BACKGROUND	0x80
#define RBBIM_ID	0x100
#define RBBIM_IDEALSIZE	0x200
#define RBBIM_LPARAM	0x400
#define RBBIM_HEADERSIZE	0x800
#define RBBS_BREAK	1
#define RBBS_FIXEDSIZE	2
#define RBBS_CHILDEDGE	4
#define RBBS_HIDDEN	8
#define RBBS_NOVERT	16
#define RBBS_FIXEDBMP	32
#define RBBS_VARIABLEHEIGHT	0x40
#define RBBS_GRIPPERALWAYS	0x80
#define RBBS_NOGRIPPER	0x100
#define RBBS_USECHEVRON	0x200
#define RBBS_HIDETITLE	0x400
#define RBBS_TOPALIGN	0x0800
#define RBHT_NOWHERE	1
#define RBHT_CAPTION	2
#define RBHT_CLIENT	3
#define RBHT_GRABBER	4
#define RBHT_CHEVRON	8
#define RB_INSERTBANDA	(WM_USER+1)
#define RB_DELETEBAND	(WM_USER+2)
#define RB_GETBARINFO	(WM_USER+3)
#define RB_SETBARINFO	(WM_USER+4)
#define RB_GETBANDINFO	(WM_USER+5)
#define RB_SETBANDINFOA	(WM_USER+6)
#define RB_SETPARENT	(WM_USER+7)
#define RB_HITTEST (WM_USER+8)
#define RB_GETRECT (WM_USER+9)
#define RB_INSERTBANDW (WM_USER+10)
#define RB_SETBANDINFOW (WM_USER+11)
#define RB_GETBANDCOUNT (WM_USER+12)
#define RB_GETROWCOUNT (WM_USER+13)
#define RB_GETROWHEIGHT (WM_USER+14)
#define RB_IDTOINDEX (WM_USER+16)
#define RB_GETTOOLTIPS (WM_USER+17)
#define RB_SETTOOLTIPS (WM_USER+18)
#define RB_SETBKCOLOR (WM_USER+19)
#define RB_GETBKCOLOR (WM_USER+20)
#define RB_SETTEXTCOLOR (WM_USER+21)
#define RB_GETTEXTCOLOR (WM_USER+22)
#define RB_SIZETORECT (WM_USER+23)
#define DL_MOVECURSOR	3
#define DL_COPYCURSOR	2
#define DL_STOPCURSOR	1
#define UDS_ALIGNLEFT	8
#define UDS_ALIGNRIGHT	4
#define UDS_ARROWKEYS	32
#define UDS_AUTOBUDDY	16
#define UDS_HORZ	64
#define UDS_NOTHOUSANDS	128
#define UDS_HOTTRACK	256
#define UDS_SETBUDDYINT	2
#define UDS_WRAP	1
#define PBS_SMOOTH 1
#define PBS_VERTICAL 4
#define UD_MAXVAL	32767
#define UD_MINVAL	(-32767)
#define HOTKEYF_ALT	4
#define HOTKEYF_CONTROL	2
#define HOTKEYF_EXT	8
#define HOTKEYF_SHIFT	1
#define HKCOMB_A	8
#define HKCOMB_C	4
#define HKCOMB_CA	64
#define HKCOMB_NONE	1
#define HKCOMB_S	2
#define HKCOMB_SA	32
#define HKCOMB_SC	16
#define HKCOMB_SCA	128
#define CBES_EX_NOEDITIMAGE	1
#define CBES_EX_NOEDITIMAGEINDENT	2
#define CBES_EX_PATHWORDBREAKPROC	4
#define CBES_EX_NOSIZELIMIT	8
#define CBES_EX_CASESENSITIVE	0x10
#define TBS_HORZ	0
#define TBS_VERT	2
#define TBS_AUTOTICKS	1
#define TBS_NOTICKS	16
#define TBS_TOP	4
#define TBS_BOTTOM	0
#define TBS_LEFT	4
#define TBS_RIGHT	0
#define TBS_BOTH	8
#define TBS_ENABLESELRANGE	32
#define TBS_FIXEDLENGTH	64
#define TBS_NOTHUMB	128
#define TBS_TOOLTIPS	256
#define TBS_REVERSED	0x200
#define TB_BOTTOM	7
#define TB_ENDTRACK	8
#define TB_LINEDOWN	1
#define TB_LINEUP	0
#define TB_PAGEDOWN	3
#define TB_PAGEUP	2
#define TB_THUMBPOSITION	4
#define TB_THUMBTRACK	5
#define TB_TOP	6
#define TB_MARKBUTTON	(WM_USER + 6)
#define TB_ISBUTTONHIGHLIGHTED (WM_USER + 14)
#define LVS_ALIGNLEFT	2048
#define LVS_ALIGNTOP	0
#define LVS_AUTOARRANGE	256
#define LVS_EDITLABELS	512
#define LVS_ICON	0
#define LVS_LIST	3
#define LVS_NOCOLUMNHEADER	16384
#define LVS_NOLABELWRAP	128
#define LVS_NOSCROLL	8192
#define LVS_NOSORTHEADER	32768
#define LVS_OWNERDRAWFIXED	1024
#define LVS_REPORT	1
#define LVS_SHAREIMAGELISTS	64
#define LVS_SHOWSELALWAYS	8
#define LVS_SINGLESEL	4
#define LVS_SMALLICON	2
#define LVS_SORTASCENDING	16
#define LVS_SORTDESCENDING	32
#define LVS_TYPESTYLEMASK	64512
#define LVS_TYPEMASK	3
#define LVS_ALIGNMASK	0xc00
#define LVS_OWNERDATA	0x1000
#define LVS_EX_GRIDLINES	1
#define LVS_EX_SUBITEMIMAGES	2
#define LVS_EX_CHECKBOXES	4
#define LVS_EX_TRACKSELECT	8
#define LVS_EX_HEADERDRAGDROP	16
#define LVS_EX_FULLROWSELECT	32
#define LVS_EX_ONECLICKACTIVATE 64
#define LVS_EX_TWOCLICKACTIVATE	128
#define LVS_EX_FLATSB	256
#define LVS_EX_REGIONAL	512
#define LVS_EX_INFOTIP	1024
#define LVS_EX_UNDERLINEHOT	0x800
#define LVS_EX_UNDERLINECOLD	0x1000
#define LVS_EX_MULTIWORKAREAS	0x2000
#define LVS_EX_LABELTIP	0x4000
#define LVS_EX_BORDERSELECT	0x8000
#define LVS_EX_LABELTIP	0x4000
#define LVS_EX_BORDERSELECT	0x8000
#define LVS_EX_DOUBLEBUFFER	0x10000
#define LVS_EX_HIDELABELS	0x20000
#define LVS_EX_SINGLEROW	0x40000
#define LVS_EX_SNAPTOGRID	0x80000
#define LVS_EX_SIMPLESELECT	0x100000
#define LVSIL_NORMAL	0
#define LVSIL_SMALL	1
#define LVSIL_STATE	2
#define LVIS_CUT	4
#define LVIS_DROPHILITED	8
#define LVIS_FOCUSED	1
#define LVIS_SELECTED	2
#define LVIS_OVERLAYMASK	3840
#define LVIS_STATEIMAGEMASK	61440
#define INDEXTOSTATEIMAGEMASK(i) ((i) << 12)
#define LPSTR_TEXTCALLBACKW	((LPWSTR)-1)
#define LPSTR_TEXTCALLBACKA	((LPSTR)-1)
#define LVIF_TEXT	1
#define LVIF_IMAGE	2
#define LVIF_PARAM	4
#define LVIF_STATE	8
#define LVIF_DI_SETITEM	4096
#define LVNI_ABOVE	256
#define LVNI_ALL	0
#define LVNI_BELOW	512
#define LVNI_TOLEFT	1024
#define LVNI_TORIGHT	2048
#define LVNI_CUT	4
#define LVNI_DROPHILITED	8
#define LVNI_FOCUSED	1
#define LVNI_SELECTED	2
#define LVFI_PARAM	1
#define LVFI_PARTIAL	8
#define LVFI_STRING	2
#define LVFI_WRAP	32
#define LVFI_NEARESTXY	64
#define LVHT_ABOVE	8
#define LVHT_BELOW	16
#define LVHT_NOWHERE	1
#define LVHT_ONITEMICON	2
#define LVHT_ONITEMLABEL	4
#define LVHT_ONITEMSTATEICON	8
#define LVHT_TOLEFT	64
#define LVHT_TORIGHT	32
#define LVHT_ONITEM	(LVHT_ONITEMICON|LVHT_ONITEMLABEL|LVHT_ONITEMSTATEICON)
#define LVCF_FMT	1
#define LVCF_SUBITEM	8
#define LVCF_TEXT	4
#define LVCF_WIDTH	2
#define LVCF_IMAGE         0x0010
#define LVCF_ORDER         0x0020
#define LVCFMT_CENTER	2
#define LVCFMT_LEFT	0
#define LVCFMT_RIGHT	1
#define LVCFMT_IMAGE        0x0800
#define LVCFMT_BITMAP_ON_RIGHT 0x1000
#define LVCFMT_COL_HAS_IMAGES  0x8000
#define LVCFMT_JUSTIFYMASK   0x0003
#define LVIR_BOUNDS	0
#define LVIR_ICON	1
#define LVIR_LABEL	2
#define LVIR_SELECTBOUNDS	3
#define LVA_ALIGNLEFT	1
#define LVA_ALIGNTOP	2
#define LVA_DEFAULT	0
#define LVA_SNAPTOGRID	5
#define LVSCW_AUTOSIZE	(-1)
#define LVSCW_AUTOSIZE_USEHEADER	(-2)
#define MONTHCAL_CLASSW	L"SysMonthCal32"
#define MONTHCAL_CLASSA	"SysMonthCal32"
#define MCM_FIRST	0x1000
#define MCM_GETCURSEL	(MCM_FIRST + 1)
#define MonthCal_GetCurSel(h,p) (BOOL)SNDMSG(h,MCM_GETCURSEL,0,(LPARAM)(p))
#define MCM_SETCURSEL	(MCM_FIRST+2)
#define MonthCal_SetCurSel(h,p) (BOOL)SNDMSG(h,MCM_SETCURSEL,0,(LPARAM)(p))
#define MCM_GETMAXSELCOUNT (MCM_FIRST+3)
#define MonthCal_GetMaxSelCount(h) (DWORD)SNDMSG(h,MCM_GETMAXSELCOUNT,0,0)
#define MCM_SETMAXSELCOUNT (MCM_FIRST+4)
#define MonthCal_SetMaxSelCount(h,n) (BOOL)SNDMSG(h,MCM_SETMAXSELCOUNT,(WPARAM)(n),0)
#define MCM_GETSELRANGE (MCM_FIRST+5)
#define MonthCal_GetSelRange(h,r) SNDMSG(h,MCM_GETSELRANGE,0,(LPARAM)(r))
#define MCM_SETSELRANGE	(MCM_FIRST+6)
#define MonthCal_SetSelRange(h,r) SNDMSG(h,MCM_SETSELRANGE,0,(LPARAM)(r))
#define MCM_GETMONTHRANGE (MCM_FIRST+7)
#define MonthCal_GetMonthRange(h,g,r) (DWORD)SNDMSG(h,MCM_GETMONTHRANGE,(WPARAM)(g),(LPARAM)(r))
#define MCM_SETDAYSTATE (MCM_FIRST+8)
#define MonthCal_SetDayState(h,c,r) SNDMSG(h,MCM_SETDAYSTATE,(WPARAM)(c),(LPARAM)(r))
#define MCM_GETMINREQRECT	(MCM_FIRST+9)
#define MonthCal_GetMinReqRect(h,p) SNDMSG(h,MCM_GETMINREQRECT,0,(LPARAM)(p))
#define MCM_SETCOLOR (MCM_FIRST + 10)
#define MonthCal_SetColor(h,i,c) SNDMSG(h,MCM_SETCOLOR,i,c)
#define MCM_GETCOLOR (MCM_FIRST+11)
#define MonthCal_GetColor(h,i) SNDMSG(h,MCM_GETCOLOR,i,0)
#define MCSC_BACKGROUND	0
#define MCSC_TEXT	1
#define MCSC_TITLEBK	2
#define MCSC_TITLETEXT	3
#define MCSC_MONTHBK	4
#define MCSC_TRAILINGTEXT	5
#define MCM_SETTODAY	(MCM_FIRST+12)
#define MonthCal_SetToday(h,p) SNDMSG(h,MCM_SETTODAY,0,(LPARAM)(p))
#define MCM_GETTODAY	(MCM_FIRST+13)
#define MonthCal_GetToday(h,p)	(BOOL)SNDMSG(h,MCM_GETTODAY,0,(LPARAM)(p))
#define MCM_HITTEST	(MCM_FIRST+14)
#define MonthCal_HitTest(h,p) SNDMSG(h, MCM_HITTEST, 0, (LPARAM)(PMCHITTESTINFO)(p))
#define MCHT_TITLE	0x10000
#define MCHT_CALENDAR	0x20000
#define MCHT_TODAYLINK	0x30000
#define MCHT_NEXT	0x1000000
#define MCHT_PREV	0x2000000
#define MCHT_NOWHERE	0
#define MCHT_TITLEBK	(MCHT_TITLE)
#define MCHT_TITLEMONTH	(MCHT_TITLE|1)
#define MCHT_TITLEYEAR	(MCHT_TITLE|2)
#define MCHT_TITLEBTNNEXT	(MCHT_TITLE|MCHT_NEXT|3)
#define MCHT_TITLEBTNPREV	(MCHT_TITLE|MCHT_PREV|3)
#define MCHT_CALENDARBK	(MCHT_CALENDAR)
#define MCHT_CALENDARDATE	(MCHT_CALENDAR|1)
#define MCHT_CALENDARDATENEXT	(MCHT_CALENDARDATE|MCHT_NEXT)
#define MCHT_CALENDARDATEPREV	(MCHT_CALENDARDATE|MCHT_PREV)
#define MCHT_CALENDARDAY	(MCHT_CALENDAR | 0x0002)
#define MCHT_CALENDARWEEKNUM	(MCHT_CALENDAR | 0x0003)
#define MCM_SETFIRSTDAYOFWEEK (MCM_FIRST+15)
#define MonthCal_SetFirstDayOfWeek(h,i) SNDMSG(h,MCM_SETFIRSTDAYOFWEEK,0,i)
#define MCM_GETFIRSTDAYOFWEEK (MCM_FIRST+16)
#define MonthCal_GetFirstDayOfWeek(h) (DWORD)SNDMSG(h,MCM_GETFIRSTDAYOFWEEK,0,0)
#define MCM_GETRANGE (MCM_FIRST+17)
#define MonthCal_GetRange(h, r) (DWORD)SNDMSG(h,MCM_GETRANGE,0,(LPARAM)(r))
#define MCM_SETRANGE (MCM_FIRST+18)
#define MonthCal_SetRange(h,g,r) (BOOL)SNDMSG(h,MCM_SETRANGE,(WPARAM)(g),(LPARAM)(r))
#define MCM_GETMONTHDELTA (MCM_FIRST + 19)
#define MonthCal_GetMonthDelta(hmc) (int)SNDMSG(h,MCM_GETMONTHDELTA,0,0)
#define MCM_SETMONTHDELTA (MCM_FIRST+20)
#define MonthCal_SetMonthDelta(h,n) (int)SNDMSG(h,MCM_SETMONTHDELTA,n,0)
#define MCM_GETMAXTODAYWIDTH (MCM_FIRST+21)
#define MonthCal_GetMaxTodayWidth(hmc) (DWORD)SNDMSG(h,MCM_GETMAXTODAYWIDTH,0,0)

//#if (_WIN32_IE >= 0x0400)
#define MCM_SETUNICODEFORMAT	CCM_SETUNICODEFORMAT
#define MonthCal_SetUnicodeFormat(h,f) (BOOL)SNDMSG((h),MCM_SETUNICODEFORMAT,(WPARAM)(f),0)
#define MCM_GETUNICODEFORMAT	CCM_GETUNICODEFORMAT
#define MonthCal_GetUnicodeFormat(h) (BOOL)SNDMSG((h),MCM_GETUNICODEFORMAT,0,0)
//#endif
#define MCN_SELCHANGE	(MCN_FIRST+1)
#define MCN_GETDAYSTATE	(MCN_FIRST+3)
#define MCN_SELECT	(MCN_FIRST+4)
#define MCS_DAYSTATE	1
#define MCS_MULTISELECT	2
#define MCS_WEEKNUMBERS	4
#define MCS_NOTODAYCIRCLE	8
#define MCS_NOTODAY	16
#define GMR_VISIBLE	0
#define GMR_DAYSTATE	1
#define TVS_DISABLEDRAGDROP	16
#define TVS_EDITLABELS	8
#define TVS_HASBUTTONS	1
#define TVS_HASLINES	2
#define TVS_LINESATROOT	4
#define TVS_SHOWSELALWAYS	32
#define TVS_NOTOOLTIPS	0x80
#define TVS_CHECKBOXES	0x100
#define TVS_TRACKSELECT	0x200
#define TVS_SINGLEEXPAND	0x400
#define TVS_INFOTIP	0x800
#define TVS_FULLROWSELECT	0x1000
#define TVS_NOSCROLL	0x2000
#define TVS_NONEVENHEIGHT	0x4000
#define TVS_NOHSCROLL	0x8000
#define TVS_RTLREADING	0x40
#define TVIS_BOLD	16
#define TVIS_CUT	4
#define TVIS_DROPHILITED	8
#define TVIS_EXPANDED	32
#define TVIS_EXPANDEDONCE	64
#define TVIS_FOCUSED	1
#define TVIS_OVERLAYMASK	3840
#define TVIS_SELECTED	2
#define TVIS_STATEIMAGEMASK	61440
#define TVIS_USERMASK	61440
#define TVIF_CHILDREN	64
#define TVIF_HANDLE	16
#define TVIF_IMAGE	2
#define TVIF_PARAM	4
#define TVIF_SELECTEDIMAGE	32
#define TVIF_STATE	8
#define TVIF_TEXT	1
#define TVIF_DI_SETITEM	0x1000
#define I_CHILDRENCALLBACK	(-1)
#define I_IMAGECALLBACK	(-1)
#define I_IMAGENONE	(-2)
#define TVI_ROOT	((HTREEITEM)(-65536))
#define TVI_FIRST	((HTREEITEM)(-65535))
#define TVI_LAST	((HTREEITEM)(-65534))
#define TVI_SORT	((HTREEITEM)(-65533))
#define TVHT_ABOVE	256
#define TVHT_BELOW	512
#define TVHT_NOWHERE	1
#define TVHT_ONITEM	70
#define TVHT_ONITEMBUTTON	16
#define TVHT_ONITEMICON	2
#define TVHT_ONITEMINDENT	8
#define TVHT_ONITEMLABEL	4
#define TVHT_ONITEMRIGHT	32
#define TVHT_ONITEMSTATEICON	64
#define TVHT_TOLEFT	2048
#define TVHT_TORIGHT	1024
#define TVE_COLLAPSE	1
#define TVE_COLLAPSERESET	32768
#define TVE_EXPAND	2
#define TVE_TOGGLE	3
#define TVSIL_NORMAL	0
#define TVSIL_STATE	2
#define TVGN_CARET	9
#define TVGN_CHILD	4
#define TVGN_DROPHILITE	8
#define TVGN_FIRSTVISIBLE	5
#define TVGN_NEXT	1
#define TVGN_NEXTVISIBLE	6
#define TVGN_PARENT	3
#define TVGN_PREVIOUS	2
#define TVGN_PREVIOUSVISIBLE	7
#define TVGN_ROOT	0
#define TVC_BYKEYBOARD	2
#define TVC_BYMOUSE	1
#define TVC_UNKNOWN	0
#define TCS_BUTTONS	256
#define TCS_FIXEDWIDTH	1024
#define TCS_FOCUSNEVER	32768
#define TCS_FOCUSONBUTTONDOWN	4096
#define TCS_FORCEICONLEFT	16
#define TCS_FORCELABELLEFT	32
#define TCS_MULTILINE	512
#define TCS_OWNERDRAWFIXED	8192
#define TCS_RAGGEDRIGHT	2048
#define TCS_RIGHTJUSTIFY	0
#define TCS_SINGLELINE	0
#define TCS_TABS	0
#define TCS_TOOLTIPS	16384
#define TCS_SCROLLOPPOSITE	1
#define TCS_BOTTOM	2
#define TCS_RIGHT	2
#define TCS_BOTTOM	2
#define TCS_MULTISELECT	4
#define TCS_HOTTRACK	0x40
#define TCS_VERTICAL	0x80
#define TCS_FLATBUTTONS	8
#define TCS_HOTTRACK	0x40
#define TCS_VERTICAL	0x80
#define TCS_TABS	0
#define TCS_SINGLELINE	0
#define TCS_RIGHTJUSTIFY	0
#define TCS_RAGGEDRIGH	0x800
#define TCS_EX_FLATSEPARATORS	1
#define TCS_EX_REGISTERDROP	2
#define TCIF_TEXT	1
#define TCIF_IMAGE	2
#define TCIF_PARAM	8
#define TCIF_RTLREADING	4
#define TCIF_STATE	0x10
#define TCIS_BUTTONPRESSED	1
#define TCIS_HIGHLIGHTED	2
#define TCHT_NOWHERE	1
#define TCHT_ONITEM	6
#define TCHT_ONITEMICON	2
#define TCHT_ONITEMLABEL	4
#define LPTC_HITTESTINFO	LPTCHITTESTINFO
#define TC_HITTESTINFO	TCHITTESTINFO
#define ACS_AUTOPLAY	4
#define ACS_CENTER	1
#define ACS_TRANSPARENT	2
#define ACS_TIMER	8
#define DIALOPTION_BILLING	64
#define DIALOPTION_QUIET	128
#define DIALOPTION_DIALTONE	256
#define MDMVOLFLAG_LOW	1
#define MDMVOLFLAG_MEDIUM	2
#define MDMVOLFLAG_HIGH	4
#define MDMVOL_LOW	0
#define MDMVOL_MEDIUM	1
#define MDMVOL_HIGH	2
#define MDMSPKRFLAG_OFF	1
#define MDMSPKRFLAG_DIAL	2
#define MDMSPKRFLAG_ON	4
#define MDMSPKRFLAG_CALLSETUP	8
#define MDMSPKR_OFF	0
#define MDMSPKR_DIAL	1
#define MDMSPKR_ON	2
#define MDMSPKR_CALLSETUP	3
#define MDM_BLIND_DIAL	512
#define MDM_CCITT_OVERRIDE	64
#define MDM_CELLULAR	8
#define MDM_COMPRESSION	1
#define MDM_ERROR_CONTROL	2
#define MDM_FLOWCONTROL_HARD	16
#define MDM_FLOWCONTROL_SOFT	32
#define MDM_FORCED_EC	4
#define MDM_SPEED_ADJUST	128
#define MDM_TONE_DIAL	256
#define MDM_V23_OVERRIDE	1024
#define MINCHAR	0x80
#define MAXCHAR	0x7f
#define MINSHORT	0x8000
#define MAXSHORT	0x7fff
#define MINLONG	0x80000000
#define MAXLONG	0x7fffffff
#define MAXBYTE	0xff
#define MAXWORD	0xffff
#define MAXDWORD	0xffffffff
#define LANG_BULGARIAN	2
#define LANG_CHINESE	4
#define LANG_CROATIAN	26
#define LANG_CZECH	5
#define LANG_DANISH	6
#define LANG_DUTCH	19
#define LANG_ENGLISH	9
#define LANG_FINNISH	11
#define LANG_FRENCH	12
#define LANG_GERMAN	7
#define LANG_GREEK	8
#define LANG_HUNGARIAN	14
#define LANG_ICELANDIC	15
#define LANG_ITALIAN	16
#define LANG_JAPANESE	17
#define LANG_KOREAN	18
#define LANG_NEUTRAL	0
#define LANG_NORWEGIAN	20
#define LANG_POLISH	21
#define LANG_PORTUGUESE	22
#define LANG_ROMANIAN	24
#define LANG_RUSSIAN	25
#define LANG_SLOVAK	27
#define LANG_SLOVENIAN	36
#define LANG_SPANISH	10
#define LANG_SWEDISH	29
#define LANG_TURKISH	31
#define SUBLANG_CHINESE_SIMPLIFIED	2
#define SUBLANG_CHINESE_TRADITIONAL	1
#define SUBLANG_CHINESE_HONGKONG	3
#define SUBLANG_CHINESE_SINGAPORE	4
#define SUBLANG_DEFAULT	1
#define SUBLANG_DUTCH	1
#define SUBLANG_DUTCH_BELGIAN	2
#define SUBLANG_ENGLISH_AUS	3
#define SUBLANG_ENGLISH_CAN	4
#define SUBLANG_ENGLISH_EIRE	6
#define SUBLANG_ENGLISH_NZ	5
#define SUBLANG_ENGLISH_UK	2
#define SUBLANG_ENGLISH_US	1
#define SUBLANG_FRENCH	1
#define SUBLANG_FRENCH_BELGIAN	2
#define SUBLANG_FRENCH_CANADIAN	3
#define SUBLANG_FRENCH_SWISS	4
#define SUBLANG_GERMAN	1
#define SUBLANG_GERMAN_AUSTRIAN	3
#define SUBLANG_GERMAN_SWISS	2
#define SUBLANG_ITALIAN	1
#define SUBLANG_ITALIAN_SWISS	2
#define SUBLANG_NEUTRAL	0
#define SUBLANG_NORWEGIAN_BOKMAL	1
#define SUBLANG_NORWEGIAN_NYNORSK	2
#define SUBLANG_PORTUGUESE	2
#define SUBLANG_PORTUGUESE_BRAZILIAN	1
#define SUBLANG_SPANISH	1
#define SUBLANG_SPANISH_MEXICAN	2
#define SUBLANG_SPANISH_MODERN	3
#define SUBLANG_SYS_DEFAULT	2
#define NLS_VALID_LOCALE_MASK	1048575
#define SORT_DEFAULT	0
#define SORT_JAPANESE_XJIS	0
#define SORT_JAPANESE_UNICODE	1
#define SORT_CHINESE_BIG5	0
#define SORT_CHINESE_UNICODE	1
#define SORT_KOREAN_KSC	0
#define SORT_KOREAN_UNICODE	1
#define NM_LAST	(-99U)
#define LVN_FIRST	((unsigned)-100)
#define LVN_LAST	(-199U)
#define HDN_FIRST	(-300U)
#define HDN_LAST	(-399U)
#define TVN_FIRST	(-400U)
#define TVN_LAST	(-499U)
#define TTN_FIRST	(-520U)
#define TTN_LAST	(-549U)
#define TCN_FIRST	(-550U)
#define TCN_LAST	(-580U)
#define CDN_FIRST	(-601U)
#define CDN_LAST	(-699U)
#define TBN_FIRST	(-700U)
#define TBN_LAST	(-720U)
#define UDN_FIRST	(-721)
#define UDN_LAST	(-740)
#define MCN_FIRST	(-750U)
#define MCN_LAST	(-759U)
#define DTN_FIRST	(-760U)
#define DTN_LAST	(-799U)
#define DTM_FIRST	0x1000
#define CBEN_FIRST	(0xfffffce0)
#define CBEN_GETDISPINFO CBEN_FIRST
#define CBEN_GETDISPINFOA CBEN_FIRST
#define CBEN_GETDISPINFOW (CBEN_FIRST-7)
#define CBEN_BEGINEDIT	(CBEN_FIRST-4)
#define CBEN_ENDEDITA	(CBEN_FIRST-5)
#define CBEN_ENDEDITW	(CBEN_FIRST-6)
#define CBEN_INSERTITEM	(CBEN_FIRST-1)
#define CBEN_DELETEITEM	(CBEN_FIRST-2)

#ifdef UNICODE
#define TVM_INSERTITEM	TVM_INSERTITEMW
#define CBEN_ENDEDIT CBEN_ENDEDITW
#define CBEN_DRAGBEGIN CBEN_DRAGBEGINW
#define MONTHCAL_CLASS	MONTHCAL_CLASSW
#define WC_PAGESCROLLER	WC_PAGESCROLLERW
#define TTM_SETTITLE	TTM_SETTITLEW
#else
#define TTM_SETTITLE	TTM_SETTITLEA
#define TVM_INSERTITEM	TVM_INSERTITEMA
#define CBEN_ENDEDIT CBEN_ENDEDITA
#define CBEN_DRAGBEGIN CBEN_DRAGBEGINA
#define MONTHCAL_CLASS	MONTHCAL_CLASSA
#define WC_PAGESCROLLER	WC_PAGESCROLLERA
#endif

#define CBENF_KILLFOCUS	1
#define CBENF_RETURN	2
#define CBENF_ESCAPE	3
#define CBENF_DROPDOWN	4
#define CBEMAXSTRLEN 260
#define CBEN_DRAGBEGINA	(CBEN_FIRST - 8)
#define CBEN_DRAGBEGINW	(CBEN_FIRST - 9)
#define CBEN_LAST	(-830U)
#define RBN_FIRST	(0U-831U)
#define RBN_LAST	(0U-859U)
#define RBN_HEIGHTCHANGE	(RBN_FIRST - 0)
#define RBN_GETOBJECT	(RBN_FIRST - 1)
#define RBN_LAYOUTCHANGED	(RBN_FIRST - 2)
#define RBN_AUTOSIZE	(RBN_FIRST - 3)
#define RBN_BEGINDRAG	(RBN_FIRST - 4)
#define RBN_ENDDRAG	(RBN_FIRST - 5)
#define RBN_DELETINGBAND	(RBN_FIRST - 6)
#define RBN_DELETEDBAND	(RBN_FIRST - 7)
#define RBN_CHILDSIZE	(RBN_FIRST - 8)
#define RBN_CHEVRONPUSHED	(RBN_FIRST - 10)
#define RBN_MINMAX	(RBN_FIRST - 21)
#define RBN_AUTOBREAK	(RBN_FIRST - 22)
#define RBNM_ID	1
#define RBNM_STYLE	2
#define RBNM_LPARAM	4
#define IPN_FIRST	(-860U)
#define IPN_LAST	(-879U)
#define PGN_FIRST	(-900U)
#define PGN_LAST	(-950U)
#define SBN_FIRST	(-880U)
#define SBN_LAST	(-899U)
#define DTM_GETSYSTEMTIME	(DTM_FIRST+1)
#define DTM_SETSYSTEMTIME	(DTM_FIRST+2)
#define DTM_GETRANGE	(DTM_FIRST+3)
#define DTM_SETRANGE	(DTM_FIRST+4)
#define DTM_SETFORMATA	(DTM_FIRST+5)
#define DTM_SETFORMATW	(DTM_FIRST+50)
#define DTM_SETMCCOLOR	(DTM_FIRST+6)
#define DTM_GETMCCOLOR	(DTM_FIRST+7)
#define DTM_GETMONTHCAL	(DTM_FIRST+8)
#define DTM_SETMCFONT	(DTM_FIRST+9)
#define DTM_GETMCFONT	(DTM_FIRST+10)
#define DTS_UPDOWN	1
#define DTS_SHOWNONE	2
#define DTS_SHORTDATEFORMAT 0
#define DTS_LONGDATEFORMAT 4
#define DTS_TIMEFORMAT	9
#define DTS_APPCANPARSE	16
#define DTS_RIGHTALIGN	32
#define DTS_SHORTDATECENTURYFORMAT 0xC
#define DTN_DATETIMECHANGE (DTN_FIRST+1)
#define DTN_USERSTRINGA	(DTN_FIRST+2)
#define DTN_USERSTRINGW	(DTN_FIRST+15)
#define DTN_WMKEYDOWNA	(DTN_FIRST+3)
#define DTN_WMKEYDOWNW	(DTN_FIRST+16)
#define DTN_FORMATA	(DTN_FIRST + 4)
#define DTN_FORMATW	(DTN_FIRST+17)
#define DTN_FORMATQUERYA	(DTN_FIRST+5)
#define DTN_FORMATQUERYW	(DTN_FIRST+18)
#define DTN_DROPDOWN	(DTN_FIRST + 6)
#define DTN_CLOSEUP	(DTN_FIRST + 7)
#define GDTR_MIN	1
#define GDTR_MAX	2
#define GDT_ERROR	-1
#define GDT_VALID	0
#define GDT_NONE	1
#define CDRF_DODEFAULT	0
#define CDRF_NEWFONT	2
#define CDRF_SKIPDEFAULT	4
#define CDRF_NOTIFYPOSTPAINT	16
#define CDRF_NOTIFYITEMDRAW	32
#define CDRF_NOTIFYSUBITEMDRAW	32
#define CDRF_NOTIFYPOSTERASE	0x40
#define CDDS_PREPAINT	1
#define CDDS_POSTPAINT	2
#define CDDS_PREERASE	3
#define CDDS_POSTERASE	4
#define CDDS_ITEM	0x10000
#define CDDS_ITEMPREPAINT	(CDDS_ITEM | CDDS_PREPAINT)
#define CDDS_ITEMPOSTPAINT	(CDDS_ITEM | CDDS_POSTPAINT)
#define CDDS_ITEMPREERASE	(CDDS_ITEM | CDDS_PREERASE)
#define CDDS_ITEMPOSTERASE	(CDDS_ITEM | CDDS_POSTERASE)
#define CDDS_SUBITEM	0x20000
#define CDIS_SELECTED	1
#define CDIS_GRAYED	2
#define CDIS_DISABLED	4
#define CDIS_CHECKED	8
#define CDIS_FOCUS	16
#define CDIS_DEFAULT	32
#define CDIS_HOT	64
#define CDIS_MARKED	0x80
#define CDIS_INDETERMINATE	0x0100
#define CLR_HILIGHT	CLR_DEFAULT
#define PROCESSOR_INTEL_386	386
#define PROCESSOR_INTEL_486	486
#define PROCESSOR_INTEL_PENTIUM	586
#define PROCESSOR_MIPS_R4000	4000
#define PROCESSOR_ALPHA_21064	21064
#define COMPRESSION_FORMAT_NONE	0
#define COMPRESSION_FORMAT_DEFAULT	1
#define COMPRESSION_FORMAT_LZNT1	2
#define TAPE_DRIVE_COMPRESSION	131072
#define TAPE_DRIVE_ECC	65536
#define TAPE_DRIVE_ERASE_BOP_ONLY	64
#define TAPE_DRIVE_ERASE_LONG	32
#define TAPE_DRIVE_ERASE_IMMEDIATE	128
#define TAPE_DRIVE_ERASE_SHORT	16
#define TAPE_DRIVE_FIXED	1
#define TAPE_DRIVE_FIXED_BLOCK	1024
#define TAPE_DRIVE_INITIATOR	4
#define TAPE_DRIVE_PADDING	262144
#define TAPE_DRIVE_GET_ABSOLUTE_BLK	1048576
#define TAPE_DRIVE_GET_LOGICAL_BLK	2097152
#define TAPE_DRIVE_REPORT_SMKS	524288
#define TAPE_DRIVE_SELECT	2
#define TAPE_DRIVE_SET_EOT_WZ_SIZE	4194304
#define TAPE_DRIVE_TAPE_CAPACITY	256
#define TAPE_DRIVE_TAPE_REMAINING	512
#define TAPE_DRIVE_VARIABLE_BLOCK	2048
#define TAPE_DRIVE_WRITE_PROTECT	4096
#define TAPE_DRIVE_ABS_BLK_IMMED	(-2147475456)
#define TAPE_DRIVE_ABSOLUTE_BLK	(-2147479552)
#define TAPE_DRIVE_END_OF_DATA	(-2147418112)
#define TAPE_DRIVE_FILEMARKS	(-2147221504)
#define TAPE_DRIVE_LOAD_UNLOAD	(-2147483647)
#define TAPE_DRIVE_LOAD_UNLD_IMMED	(-2147483616)
#define TAPE_DRIVE_LOCK_UNLOCK	(-2147483644)
#define TAPE_DRIVE_LOCK_UNLK_IMMED	(-2147483520)
#define TAPE_DRIVE_LOG_BLK_IMMED	(-2147450880)
#define TAPE_DRIVE_LOGICAL_BLK	(-2147467264)
#define TAPE_DRIVE_RELATIVE_BLKS	(-2147352576)
#define TAPE_DRIVE_REVERSE_POSITION	(-2143289344)
#define TAPE_DRIVE_REWIND_IMMEDIATE	(-2147483640)
#define TAPE_DRIVE_SEQUENTIAL_FMKS	(-2146959360)
#define TAPE_DRIVE_SEQUENTIAL_SMKS	(-2145386496)
#define TAPE_DRIVE_SET_BLOCK_SIZE	(-2147483632)
#define TAPE_DRIVE_SET_COMPRESSION	(-2147483136)
#define TAPE_DRIVE_SET_ECC	(-2147483392)
#define TAPE_DRIVE_SET_PADDING	(-2147482624)
#define TAPE_DRIVE_SET_REPORT_SMKS	(-2147481600)
#define TAPE_DRIVE_SETMARKS	(-2146435072)
#define TAPE_DRIVE_SPACE_IMMEDIATE	(-2139095040)
#define TAPE_DRIVE_TENSION	(-2147483646)
#define TAPE_DRIVE_TENSION_IMMED	(-2147483584)
#define TAPE_DRIVE_WRITE_FILEMARKS	(-2113929216)
#define TAPE_DRIVE_WRITE_LONG_FMKS	(-2013265920)
#define TAPE_DRIVE_WRITE_MARK_IMMED	(-1879048192)
#define TAPE_DRIVE_WRITE_SETMARKS	(-2130706432)
#define TAPE_DRIVE_WRITE_SHORT_FMKS	(-2080374784)
#define STANDARD_RIGHTS_REQUIRED	0xf0000
#define STANDARD_RIGHTS_WRITE	0x20000
#define STANDARD_RIGHTS_READ	0x20000
#define STANDARD_RIGHTS_EXECUTE	0x20000
#define STANDARD_RIGHTS_ALL	0x1f0000
#define SPECIFIC_RIGHTS_ALL	0xffff
#define MAXIMUM_ALLOWED	0x2000000
#define GENERIC_ALL	0x10000000
#define SECURITY_NULL_RID	0
#define SECURITY_WORLD_RID	0
#define SECURITY_LOCAL_RID	0
#define SECURITY_CREATOR_OWNER_RID	0
#define SECURITY_CREATOR_GROUP_RID	1
#define SECURITY_DIALUP_RID	1
#define SECURITY_NETWORK_RID	2
#define SECURITY_BATCH_RID	3
#define SECURITY_INTERACTIVE_RID	4
#define SECURITY_LOGON_IDS_RID	5
#define SECURITY_LOGON_IDS_RID_COUNT	3
#define SECURITY_SERVICE_RID	6
#define SECURITY_LOCAL_SYSTEM_RID	0x12
#define SECURITY_BUILTIN_DOMAIN_RID	32
#define DOMAIN_USER_RID_ADMIN	0x1f4
#define DOMAIN_USER_RID_GUEST	0x1f5
#define DOMAIN_GROUP_RID_ADMINS	512
#define DOMAIN_GROUP_RID_USERS	0x201
#define DOMAIN_ALIAS_RID_ADMINS	0x220
#define DOMAIN_ALIAS_RID_USERS	0x221
#define DOMAIN_ALIAS_RID_GUESTS	0x222
#define DOMAIN_ALIAS_RID_POWER_USERS	0x223
#define DOMAIN_ALIAS_RID_ACCOUNT_OPS	0x224
#define DOMAIN_ALIAS_RID_SYSTEM_OPS	0x225
#define DOMAIN_ALIAS_RID_PRINT_OPS	0x226
#define DOMAIN_ALIAS_RID_BACKUP_OPS	0x227
#define DOMAIN_ALIAS_RID_REPLICATOR	0x228
#define SE_GROUP_MANDATORY	1
#define SE_GROUP_ENABLED_BY_DEFAULT	2
#define SE_GROUP_ENABLED	4
#define SE_GROUP_OWNER	8
#define SE_GROUP_LOGON_ID	0xc0000000
#define SECURITY_DESCRIPTOR_REVISION	1
#define SECURITY_DESCRIPTOR_MIN_LENGTH	20
#define SE_OWNER_DEFAULTED	1
#define SE_GROUP_DEFAULTED	2
#define SE_DACL_PRESENT	4
#define SE_DACL_DEFAULTED	8
#define SE_SACL_PRESENT	16
#define SE_SACL_DEFAULTED	32
#define SE_SELF_RELATIVE	32768
#define SE_PRIVILEGE_ENABLED_BY_DEFAULT	1
#define SE_PRIVILEGE_ENABLED	2
#define SE_PRIVILEGE_USED_FOR_ACCESS	0x80000000
#define PRIVILEGE_SET_ALL_NECESSARY	1
#define OFN_ALLOWMULTISELECT	512
#define OFN_CREATEPROMPT	0x2000
#define OFN_ENABLEHOOK	32
#define OFN_ENABLETEMPLATE	64
#define OFN_ENABLETEMPLATEHANDLE	128
#define OFN_EXPLORER	0x80000
#define OFN_EXTENSIONDIFFERENT	0x400
#define OFN_FILEMUSTEXIST	0x1000
#define OFN_HIDEREADONLY	4
#define OFN_LONGNAMES	0x200000
#define OFN_NOCHANGEDIR	8
#define OFN_NODEREFERENCELINKS	0x100000
#define OFN_NOLONGNAMES	0x40000
#define OFN_NONETWORKBUTTON	0x20000
#define OFN_NOREADONLYRETURN	0x8000
#define OFN_NOTESTFILECREATE	0x10000
#define OFN_NOVALIDATE	256
#define OFN_OVERWRITEPROMPT	2
#define OFN_PATHMUSTEXIST	0x800
#define OFN_READONLY	1
#define OFN_SHAREAWARE	0x4000
#define OFN_SHOWHELP	16
#define OFN_SHAREFALLTHROUGH	2
#define OFN_SHARENOWARN	1
#define OFN_SHAREWARN	0
#define CDN_INITDONE	0xfffffda7
#define CDN_SELCHANGE	0xfffffda6
#define CDN_FOLDERCHANGE	0xfffffda5
#define CDN_SHAREVIOLATION	0xfffffda4
#define CDN_HELP	0xfffffda3
#define CDN_FILEOK	0xfffffda2
#define CDN_TYPECHANGE	0xfffffda1
#define CDM_GETFILEPATH	0x465
#define CDM_GETFOLDERIDLIST	0x467
#define CDM_GETFOLDERPATH	0x466
#define CDM_GETSPEC	0x464
#define CDM_HIDECONTROL	0x469
#define CDM_SETCONTROLTEXT	0x468
#define CDM_SETDEFEXT	0x46a
#define CC_ENABLEHOOK	16
#define CC_ENABLETEMPLATE	32
#define CC_ENABLETEMPLATEHANDLE	64
#define CC_FULLOPEN	2
#define CC_PREVENTFULLOPEN	4
#define CC_RGBINIT	1
#define CC_SHOWHELP	8
#define CC_SOLIDCOLOR	128
#define FR_DIALOGTERM	64
#define FR_DOWN	1
#define FR_ENABLEHOOK	256
#define FR_ENABLETEMPLATE	512
#define FR_ENABLETEMPLATEHANDLE	0x2000
#define FR_FINDNEXT	8
#define FR_HIDEUPDOWN	0x4000
#define FR_HIDEMATCHCASE	0x8000
#define FR_HIDEWHOLEWORD	0x10000
#define FR_MATCHCASE	4
#define FR_NOMATCHCASE	0x800
#define FR_NOUPDOWN	0x400
#define FR_NOWHOLEWORD	4096
#define FR_REPLACE	16
#define FR_REPLACEALL	32
#define FR_SHOWHELP	128
#define FR_WHOLEWORD	2
#define FR_PRIVATE	0x10
#define FR_NOT_ENUM	0x20
#define CF_APPLY	512
#define CF_ANSIONLY	0x400
#define CF_BOTH	3
#define CF_TTONLY	0x40000
#define CF_EFFECTS	256
#define CF_ENABLEHOOK	8
#define CF_ENABLETEMPLATE	16
#define CF_ENABLETEMPLATEHANDLE	32
#define CF_FIXEDPITCHONLY	0x4000
#define CF_FORCEFONTEXIST	0x10000
#define CF_INITTOLOGFONTSTRUCT	64
#define CF_LIMITSIZE	0x2000
#define CF_NOOEMFONTS	0x800
#define CF_NOFACESEL	0x80000
#define CF_NOSCRIPTSEL	0x800000
#define CF_NOSTYLESEL	0x100000
#define CF_NOSIZESEL	0x200000
#define CF_NOSIMULATIONS	4096
#define CF_NOVECTORFONTS	0x800
#define CF_NOVERTFONTS	0x1000000
#define CF_PRINTERFONTS	2
#define CF_SCALABLEONLY	0x20000
#define CF_SCREENFONTS	1
#define CF_SCRIPTSONLY	0x400
#define CF_SELECTSCRIPT	0x400000
#define CF_SHOWHELP	4
#define CF_USESTYLE	128
#define CF_WYSIWYG	0x8000
#define BOLD_FONTTYPE	256
#define ITALIC_FONTTYPE	512
#define PRINTER_FONTTYPE	0x4000
#define REGULAR_FONTTYPE	0x400
#define SCREEN_FONTTYPE	0x2000
#define SIMULATED_FONTTYPE	0x8000
#define COLOROKSTRINGW	L"commdlg_ColorOK"
#define FILEOKSTRINGW	L"commdlg_FileNameOK"
#define FINDMSGSTRINGW	L"commdlg_FindReplace"
#define HELPMSGSTRINGW	L"commdlg_help"
#define LBSELCHSTRINGW	L"commdlg_LBSelChangedNotify"
#define SETRGBSTRINGW	L"commdlg_SetRGBColor"
#define SHAREVISTRINGW	L"commdlg_ShareViolation"
#define COLOROKSTRINGA	"commdlg_ColorOK"
#define FILEOKSTRINGA	"commdlg_FileNameOK"
#define FINDMSGSTRINGA	"commdlg_FindReplace"
#define HELPMSGSTRINGA	"commdlg_help"
#define LBSELCHSTRINGA	"commdlg_LBSelChangedNotify"
#define SETRGBSTRINGA	"commdlg_SetRGBColor"
#define SHAREVISTRINGA	"commdlg_ShareViolation"
#define TBNOTIFYA NMTOOLBARA
#define TBNOTIFYW NMTOOLBARW
#define LPTBNOTIFYA LPNMTOOLBARA
#define LPTBNOTIFYW LPNMTOOLBARW
#define TBNOTIFY	NMTOOLBAR
#define LPTBNOTIFY	LPNMTOOLBAR

#ifdef UNICODE
#define COLOROKSTRING COLOROKSTRINGW
#define FILEOKSTRING FILEOKSTRINGW
#define FINDMSGSTRING FINDMSGSTRINGW
#define HELPMSGSTRING HELPMSGSTRINGW
#define LBSELCHSTRING LBSELCHSTRINGW
#define SETRGBSTRING SETRGBSTRINGW
#define SHAREVISTRING SHAREVISTRINGW
#define LVITEM	LVITEMW
#else
#define COLOROKSTRING COLOROKSTRINGA
#define FILEOKSTRING FILEOKSTRINGA
#define FINDMSGSTRING FINDMSGSTRINGA
#define HELPMSGSTRING HELPMSGSTRINGA
#define LBSELCHSTRING LBSELCHSTRINGA
#define SETRGBSTRING SETRGBSTRINGA
#define SHAREVISTRING SHAREVISTRINGA
#define LVITEM	LVITEMA
#endif

#define CD_LBSELCHANGE	0
#define CD_LBSELADD	2
#define CD_LBSELSUB	1
#define CD_LBSELNOITEMS	(-1)
#define DN_DEFAULTPRN	1
#define PD_ALLPAGES	0
#define PD_COLLATE	16
#define PD_DISABLEPRINTTOFILE	524288
#define PD_ENABLEPRINTHOOK	4096
#define PD_ENABLEPRINTTEMPLATE	16384
#define PD_ENABLEPRINTTEMPLATEHANDLE	65536
#define PD_ENABLESETUPHOOK	8192
#define PD_ENABLESETUPTEMPLATE	32768
#define PD_ENABLESETUPTEMPLATEHANDLE	131072
#define PD_HIDEPRINTTOFILE	1048576
#define PD_NOPAGENUMS	8
#define PD_NOSELECTION	4
#define PD_NOWARNING	128
#define PD_PAGENUMS	2
#define PD_PRINTSETUP	64
#define PD_PRINTTOFILE	32
#define PD_RETURNDC	256
#define PD_RETURNDEFAULT	1024
#define PD_RETURNIC	512
#define PD_SELECTION	1
#define PD_SHOWHELP	2048
#define PD_USEDEVMODECOPIES	262144
#define PD_USEDEVMODECOPIESANDCOLLATE	262144
#define PSD_DEFAULTMINMARGINS	0
#define PSD_DISABLEMARGINS	16
#define PSD_DISABLEORIENTATION	256
#define PSD_DISABLEPAGEPAINTING	524288
#define PSD_DISABLEPAPER	512
#define PSD_DISABLEPRINTER	32
#define PSD_ENABLEPAGEPAINTHOOK	262144
#define PSD_ENABLEPAGESETUPHOOK	8192
#define PSD_ENABLEPAGESETUPTEMPLATE	32768
#define PSD_ENABLEPAGESETUPTEMPLATEHANDLE	131072
#define PSD_INHUNDREDTHSOFMILLIMETERS	8
#define PSD_INTHOUSANDTHSOFINCHES	4
#define PSD_INWININIINTLMEASURE	0
#define PSD_MARGINS	2
#define PSD_MINMARGINS	1
#define PSD_NOWARNING	128
#define PSD_RETURNDEFAULT	1024
#define PSD_SHOWHELP	2048
#define SW_OTHERUNZOOM	4
#define SW_OTHERZOOM	2
#define SW_PARENTCLOSING	1
#define SW_PARENTOPENING	3
#define AW_HOR_POSITIVE	1
#define AW_HOR_NEGATIVE	2
#define AW_VER_POSITIVE	4
#define AW_VER_NEGATIVE	8
#define AW_CENTER	0x10
#define AW_HIDE	0x10000
#define AW_ACTIVATE	0x20000
#define AW_SLIDE	0x40000
#define AW_BLEND	0x80000
#define VK_LBUTTON	1
#define VK_RBUTTON	2
#define VK_CANCEL	3
#define VK_MBUTTON	4
#define VK_BACK	8
#define VK_TAB	9
#define VK_CLEAR	12
#define VK_RETURN	13
#define VK_SHIFT	16
#define VK_CONTROL	17
#define VK_MENU	18
#define VK_PAUSE	19
#define VK_PRINT	42
#define VK_CAPITAL	20
#define VK_KANA	0x15
#define VK_HANGEUL	0x15
#define VK_HANGUL	0x15
#define VK_JUNJA	0x17
#define VK_FINAL	0x18
#define VK_HANJA	0x19
#define VK_KANJI	0x19
#define VK_CONVERT	0x1C
#define VK_NONCONVERT	0x1D
#define VK_ACCEPT	0x1E
#define VK_MODECHANGE	0x1F
#define VK_ESCAPE	27
#define VK_SPACE	32
#define VK_PRIOR	33
#define VK_NEXT	34
#define VK_END	35
#define VK_HOME	36
#define VK_LEFT	37
#define VK_UP	38
#define VK_RIGHT	39
#define VK_DOWN	40
#define VK_SELECT	41
#define VK_EXECUTE	43
#define VK_SNAPSHOT	44
#define VK_INSERT	45
#define VK_DELETE	46
#define VK_HELP	47
#define VK_0	48
#define VK_1	49
#define VK_2	50
#define VK_3	51
#define VK_4	52
#define VK_5	53
#define VK_6	54
#define VK_7	55
#define VK_8	56
#define VK_9	57
#define VK_A	65
#define VK_B	66
#define VK_C	67
#define VK_D	68
#define VK_E	69
#define VK_F	70
#define VK_G	71
#define VK_H	72
#define VK_I	73
#define VK_J	74
#define VK_K	75
#define VK_L	76
#define VK_M	77
#define VK_N	78
#define VK_O	79
#define VK_P	80
#define VK_Q	81
#define VK_R	82
#define VK_S	83
#define VK_T	84
#define VK_U	85
#define VK_V	86
#define VK_W	87
#define VK_X	88
#define VK_Y	89
#define VK_Z	90
#define VK_LWIN	0x5B
#define VK_RWIN	0x5C
#define VK_APPS	0x5D
#define VK_NUMPAD0	96
#define VK_NUMPAD1	97
#define VK_NUMPAD2	98
#define VK_NUMPAD3	99
#define VK_NUMPAD4	100
#define VK_NUMPAD5	101
#define VK_NUMPAD6	102
#define VK_NUMPAD7	103
#define VK_NUMPAD8	104
#define VK_NUMPAD9	105
#define VK_MULTIPLY	106
#define VK_ADD	107
#define VK_SEPARATOR	108
#define VK_SUBTRACT	109
#define VK_DECIMAL	110
#define VK_DIVIDE	111
#define VK_F1	112
#define VK_F2	113
#define VK_F3	114
#define VK_F4	115
#define VK_F5	116
#define VK_F6	117
#define VK_F7	118
#define VK_F8	119
#define VK_F9	120
#define VK_F10	121
#define VK_F11	122
#define VK_F12	123
#define VK_F13	124
#define VK_F14	125
#define VK_F15	126
#define VK_F16	127
#define VK_F17	128
#define VK_F18	129
#define VK_F19	130
#define VK_F20	131
#define VK_F21	132
#define VK_F22	133
#define VK_F23	134
#define VK_F24	135
#define VK_NUMLOCK	144
#define VK_SCROLL	145
#define VK_LSHIFT	160
#define VK_LCONTROL	162
#define VK_LMENU	164
#define VK_RSHIFT	161
#define VK_RCONTROL	163
#define VK_RMENU	165
#define VK_PROCESSKEY	229
#define KF_ALTDOWN	8192
#define KF_DLGMODE	2048
#define KF_EXTENDED	256
#define KF_MENUMODE	4096
#define KF_REPEAT	16384
#define KF_UP	32768
#define KL_NAMELENGTH	9
#define WA_ACTIVE	1
#define WA_CLICKACTIVE	2
#define WA_INACTIVE	0
#define PWR_CRITICALRESUME	3
#define PWR_SUSPENDREQUEST	1
#define PWR_SUSPENDRESUME	2
#define PWR_FAIL	(-1)
#define PWR_OK	1
#define NF_QUERY	3
#define NF_REQUERY	4
#define NFR_ANSI	1
#define NFR_UNICODE	2
#define WMSZ_BOTTOM	6
#define WMSZ_BOTTOMLEFT	7
#define WMSZ_BOTTOMRIGHT	8
#define WMSZ_LEFT	1
#define WMSZ_RIGHT	2
#define WMSZ_TOP	3
#define WMSZ_TOPLEFT	4
#define WMSZ_TOPRIGHT	5
#define WMSZ_BOTTOM 6
#define WMSZ_BOTTOMLEFT 7
#define WMSZ_BOTTOMRIGHT 8
#define MA_ACTIVATE	1
#define MA_ACTIVATEANDEAT	2
#define MA_NOACTIVATE	3
#define MA_NOACTIVATEANDEAT	4
#define ICON_SMALL	0
#define ICON_BIG	1
#define SIZE_MAXHIDE	4
#define SIZE_MAXIMIZED	2
#define SIZEFULLSCREEN	2
#define SIZE_MAXSHOW	3
#define SIZE_MINIMIZED	1
#define SIZEICONIC	1
#define SIZE_RESTORED	0
#define SIZENORMAL	0
#define WVR_ALIGNTOP	16
#define WVR_ALIGNLEFT	32
#define WVR_ALIGNBOTTOM	64
#define WVR_ALIGNRIGHT	128
#define WVR_HREDRAW	256
#define WVR_VREDRAW	512
#define WVR_REDRAW	768
#define WVR_VALIDRECTS	1024
#define HTBOTTOM	15
#define HTBOTTOMLEFT	16
#define HTBOTTOMRIGHT	17
#define HTCAPTION	2
#define HTCLIENT	1
#define HTERROR	(-2)
#define HTGROWBOX	4
#define HTHSCROLL	6
#define HTLEFT	10
#define HTMENU	5
#define HTNOWHERE	0
#define HTREDUCE	8
#define HTRIGHT	11
#define HTSIZE	4
#define HTSYSMENU	3
#define HTTOP	12
#define HTTOPLEFT	13
#define HTTOPRIGHT	14
#define HTTRANSPARENT	(-1)
#define HTVSCROLL	7
#define HTZOOM	9
#define HTOBJECT	19
#define HTCLOSE	20
#define HTHELP	21
#define HTBORDER	18
#define HTMINBUTTON 8
#define HTMAXBUTTON 9
#define MK_CONTROL	8
#define MK_LBUTTON	1
#define MK_MBUTTON	16
#define MK_RBUTTON	2
#define MK_SHIFT	4
#define CS_BYTEALIGNCLIENT	4096
#define CS_BYTEALIGNWINDOW	8192
#define CS_KEYCVTWINDOW	4
#define	CS_NOKEYCVT	256
#define CS_CLASSDC	64
#define CS_DBLCLKS	8
#define CS_GLOBALCLASS	16384
#define CS_IME	0x10000
#define CS_DROPSHADOW	0x20000
#define CS_HREDRAW	2
#define CS_NOCLOSE	512
#define CS_OWNDC	32
#define CS_PARENTDC	128
#define CS_SAVEBITS	2048
#define CS_VREDRAW	1
#define DLGWINDOWEXTRA	30
#define FALT	16
#define FCONTROL	8
#define FNOINVERT	2
#define FSHIFT	4
#define FVIRTKEY	1
#define MIIM_CHECKMARKS	8
#define MIIM_DATA	32
#define MIIM_ID	2
#define MIIM_STATE	1
#define MIIM_SUBMENU	4
#define MIIM_TYPE	16
#define MIIM_STRING	0x040
#define MIIM_BITMAP	0x080
#define MIIM_FTYPE	0x0100
#define MFT_BITMAP	4
#define MFT_MENUBARBREAK	32
#define MFT_MENUBREAK	64
#define MFT_OWNERDRAW	256
#define MFT_RADIOCHECK	512
#define MFT_RIGHTJUSTIFY	0x4000
#define MFT_SEPARATOR	0x800
#define MFT_STRING	0
#define MFS_CHECKED	8
#define MFS_DEFAULT	4096
#define MFS_DISABLED	3
#define MFS_ENABLED	0
#define MFS_GRAYED	3
#define MFS_HILITE	128
#define MFS_UNCHECKED	0
#define MFS_UNHILITE	0
#define SERKF_AVAILABLE	2
#define SERKF_INDICATOR	4
#define SERKF_SERIALKEYSON	1
#define FKF_AVAILABLE	2
#define FKF_CLICKON	64
#define FKF_FILTERKEYSON	1
#define FKF_HOTKEYACTIVE	4
#define FKF_HOTKEYSOUND	16
#define FKF_CONFIRMHOTKEY	8
#define FKF_INDICATOR	32
#define HELPINFO_MENUITEM	2
#define HELPINFO_WINDOW	1
#define PRF_CHECKVISIBLE	1
#define PRF_CHILDREN	16
#define PRF_CLIENT	4
#define PRF_ERASEBKGND	8
#define PRF_NONCLIENT	2
#define PRF_OWNED	32
#define HWND_DESKTOP	(HWND)0
#define SC_CLOSE	61536
#define SC_CONTEXTHELP	61824
#define SC_DEFAULT	61792
#define SC_HOTKEY	61776
#define SC_HSCROLL	61568
#define SC_KEYMENU	61696
#define SC_MAXIMIZE	61488
#define SC_ZOOM	61488
#define SC_MINIMIZE	61472
#define SC_ICON	61472
#define SC_MONITORPOWER	61808
#define SC_MOUSEMENU	61584
#define SC_MOVE	61456
#define SC_NEXTWINDOW	61504
#define SC_PREVWINDOW	61520
#define SC_RESTORE	61728
#define SC_SCREENSAVE	61760
#define SC_SIZE	61440
#define SC_TASKLIST	61744
#define SC_VSCROLL	61552
#define SC_ARRANGE	61712
#define DC_HASDEFID	21323
#define DLGC_BUTTON	8192
#define DLGC_DEFPUSHBUTTON	16
#define DLGC_HASSETSEL	8
#define DLGC_RADIOBUTTON	64
#define DLGC_STATIC	256
#define DLGC_UNDEFPUSHBUTTON	32
#define DLGC_WANTALLKEYS	4
#define DLGC_WANTARROWS	1
#define DLGC_WANTCHARS	128
#define DLGC_WANTMESSAGE	4
#define DLGC_WANTTAB	2
#define EC_LEFTMARGIN	1
#define EC_RIGHTMARGIN	2
#define EC_USEFONTINFO	65535
#define LB_ERR	(-1)
#define LB_ERRSPACE	(-2)
#define CB_ERR	(-1)
#define CB_ERRSPACE	(-2)
#define SKF_AUDIBLEFEEDBACK	64
#define SKF_AVAILABLE	2
#define SKF_CONFIRMHOTKEY	8
#define SKF_HOTKEYACTIVE	4
#define SKF_HOTKEYSOUND	16
#define SKF_INDICATOR	32
#define SKF_STICKYKEYSON	1
#define SKF_TRISTATE	128
#define SKF_TWOKEYSOFF	256
#define MKF_AVAILABLE	2
#define MKF_CONFIRMHOTKEY	8
#define MKF_HOTKEYACTIVE	4
#define MKF_HOTKEYSOUND	16
#define MKF_INDICATOR	32
#define MKF_MOUSEKEYSON	1
#define MKF_MODIFIERS	64
#define MKF_REPLACENUMBERS	128
#define SSF_AVAILABLE	2
#define SSF_SOUNDSENTRYON	1
#define SSTF_BORDER	2
#define SSTF_CHARS	1
#define SSTF_DISPLAY	3
#define SSTF_NONE	0
#define SSGF_DISPLAY	3
#define SSGF_NONE	0
#define SSWF_CUSTOM	4
#define SSWF_DISPLAY	3
#define SSWF_NONE	0
#define SSWF_TITLE	1
#define SSWF_WINDOW	2
#define ATF_ONOFFFEEDBACK	2
#define ATF_TIMEOUTON	1
#define HCF_AVAILABLE	2
#define HCF_CONFIRMHOTKEY	8
#define HCF_HIGHCONTRASTON	1
#define HCF_HOTKEYACTIVE	4
#define HCF_HOTKEYAVAILABLE	64
#define HCF_HOTKEYSOUND	16
#define HCF_INDICATOR	32
#define TKF_AVAILABLE	2
#define TKF_CONFIRMHOTKEY	8
#define TKF_HOTKEYACTIVE	4
#define TKF_HOTKEYSOUND	16
#define TKF_TOGGLEKEYSON	1
#define PP_DISPLAYERRORS	1
#define RESOURCEDISPLAYTYPE_DOMAIN	1
#define RESOURCEDISPLAYTYPE_FILE	4
#define RESOURCEDISPLAYTYPE_GENERIC	0
#define RESOURCEDISPLAYTYPE_GROUP	5
#define RESOURCEDISPLAYTYPE_SERVER	2
#define RESOURCEDISPLAYTYPE_SHARE	3
#define CAPSLOCK_ON	128
#define ENHANCED_KEY	256
#define LEFT_ALT_PRESSED	2
#define LEFT_CTRL_PRESSED	8
#define NUMLOCK_ON	32
#define RIGHT_ALT_PRESSED	1
#define RIGHT_CTRL_PRESSED	4
#define SCROLLLOCK_ON	64
#define SHIFT_PRESSED	16
#define FROM_LEFT_1ST_BUTTON_PRESSED	1
#define RIGHTMOST_BUTTON_PRESSED	2
#define FROM_LEFT_2ND_BUTTON_PRESSED	4
#define FROM_LEFT_3RD_BUTTON_PRESSED	8
#define FROM_LEFT_4TH_BUTTON_PRESSED	16
#define DOUBLE_CLICK	2
#define MOUSE_MOVED	1
#define KEY_EVENT	1
#define MOUSE_EVENT	2
#define WINDOW_BUFFER_SIZE_EVENT	4
#define MENU_EVENT	8
#define FOCUS_EVENT	16
#define BI_RGB 0
#define BI_RLE8 1
#define BI_RLE4 2
#define BI_BITFIELDS 3
#define BI_JPEG 4
#define BI_PNG 5
#define HFILE_ERROR ((HFILE)-1)
#define CONTEXT_i386 0x10000
#define CONTEXT_i486 0x10000
#define CONTEXT_CONTROL (CONTEXT_i386 | 1)
#define CONTEXT_INTEGER (CONTEXT_i386 | 2)
#define CONTEXT_SEGMENTS (CONTEXT_i386 | 4)
#define CONTEXT_FLOATING_POINT (CONTEXT_i386 | 8)
#define CONTEXT_DEBUG_REGISTERS (CONTEXT_i386|0x10)
#define CONTEXT_EXTENDED_REGISTERS (CONTEXT_i386 | 0x00000020L)
#define CONTEXT_FULL (CONTEXT_CONTROL|CONTEXT_INTEGER|CONTEXT_SEGMENTS)
#define MAX_MODULE_NAME32 255
#define TH32CS_SNAPHEAPLIST 1
#define TH32CS_SNAPPROCESS 2
#define TH32CS_SNAPTHREAD 4
#define TH32CS_SNAPMODULE 8
#define TH32CS_SNAPALL (TH32CS_SNAPHEAPLIST|TH32CS_SNAPPROCESS|TH32CS_SNAPTHREAD|TH32CS_SNAPMODULE)
#define TH32CS_INHERIT 0x80000000
#define HF32_DEFAULT 1
#define HF32_SHARED 2
#define LF32_FIXED 1
#define LF32_FREE 2
#define LF32_MOVEABLE 4
#define UnlockResource(r) ((r),0)
#define METHOD_BUFFERED 0
#define METHOD_IN_DIRECT 1
#define METHOD_OUT_DIRECT 2
#define METHOD_NEITHER 3
#define FILE_ANY_ACCESS 0
#define FILE_READ_ACCESS 1
#define FILE_WRITE_ACCESS 2
#define TMPF_FIXED_PITCH 1
#define TMPF_VECTOR 2
#define TMPF_DEVICE 8
#define TMPF_TRUETYPE 4
#define NTM_REGULAR 0x40
#define NTM_BOLD 0x20
#define NTM_ITALIC 1
#define NTM_NONNEGATIVE_AC	0x00010000
#define NTM_PS_OPENTYPE	0x00020000
#define NTM_TT_OPENTYPE	0x00040000
#define NTM_MULTIPLEMASTER	0x00080000
#define NTM_TYPE1	0x00100000
#define NTM_DSIG	0x00200000
#define META_ANIMATEPALETTE	0x436
#define META_ARC	0x817
#define META_BITBLT	0x922
#define META_CHORD	0x830
#define META_CREATEBRUSHINDIRECT	0x2FC
#define META_CREATEFONTINDIRECT	0x2FB
#define META_CREATEPALETTE	0xf7
#define META_CREATEPATTERNBRUSH	0x1F9
#define META_CREATEPENINDIRECT	0x2FA
#define META_CREATEREGION	0x6FF
#define META_DELETEOBJECT	0x1f0
#define META_DIBBITBLT	0x940
#define META_DIBCREATEPATTERNBRUSH	0x142
#define META_DIBSTRETCHBLT	0xb41
#define META_ELLIPSE	0x418
#define META_ESCAPE	0x626
#define META_EXCLUDECLIPRECT	0x415
#define META_EXTFLOODFILL	0x548
#define META_EXTTEXTOUT	0xa32
#define META_FILLREGION	0x228
#define META_FLOODFILL	0x419
#define META_FRAMEREGION	0x429
#define META_INTERSECTCLIPRECT	0x416
#define META_INVERTREGION	0x12A
#define META_LINETO	0x213
#define META_MOVETO	0x214
#define META_OFFSETCLIPRGN	0x220
#define META_OFFSETVIEWPORTORG	0x211
#define META_OFFSETWINDOWORG	0x20F
#define META_PAINTREGION	0x12B
#define META_PATBLT	0x61D
#define META_PIE	0x81A
#define META_POLYGON	0x324
#define META_POLYLINE	0x325
#define META_POLYPOLYGON	0x538
#define META_REALIZEPALETTE	0x35
#define META_RECTANGLE	0x41B
#define META_RESIZEPALETTE	0x139
#define META_RESTOREDC	0x127
#define META_ROUNDRECT	0x61C
#define META_SAVEDC	0x1E
#define META_SCALEVIEWPORTEXT	0x412
#define META_SCALEWINDOWEXT	0x410
#define META_SELECTCLIPREGION	0x12C
#define META_SELECTOBJECT	0x12D
#define META_SELECTPALETTE	0x234
#define META_SETBKCOLOR	0x201
#define META_SETBKMODE	0x102
#define META_SETDIBTODEV	0xd33
#define META_SETMAPMODE	0x103
#define META_SETMAPPERFLAGS	0x231
#define META_SETPALENTRIES	0x37
#define META_SETPIXEL	0x41F
#define META_SETPOLYFILLMODE	0x106
#define META_SETRELABS	0x105
#define META_SETROP2	0x104
#define META_SETSTRETCHBLTMODE	0x107
#define META_SETTEXTALIGN	0x12E
#define META_SETTEXTCHAREXTRA	0x108
#define META_SETTEXTCOLOR	0x209
#define META_SETTEXTJUSTIFICATION	0x20A
#define META_SETVIEWPORTEXT	0x20E
#define META_SETVIEWPORTORG	0x20D
#define META_SETWINDOWEXT	0x20C
#define META_SETWINDOWORG	0x20B
#define META_STRETCHBLT	0xB23
#define META_STRETCHDIB	0xf43
#define META_TEXTOUT	0x521
#define PFD_DOUBLEBUFFER 1
#define PFD_STEREO 2
#define PFD_DRAW_TO_WINDOW 4
#define PFD_DRAW_TO_BITMAP 8
#define PFD_SUPPORT_GDI 0x10
#define PFD_SUPPORT_OPENGL 0x20
#define PFD_GENERIC_FORMAT 0x40
#define PFD_NEED_PALETTE 0x80
#define PFD_NEED_SYSTEM_PALETTE 0x100
#define PFD_SWAP_EXCHANGE 0x200
#define PFD_SWAP_COPY 0x400
#define PFD_SWAP_LAYER_BUFFERS 0x800
#define PFD_GENERIC_ACCELERATED	0x1000
#define PFD_TYPE_RGBA 0
#define PFD_TYPE_COLORINDEX 1
#define PFD_MAIN_PLANE 0
#define PFD_OVERLAY_PLANE 1
#define PFD_UNDERLAY_PLANE (-1)
#define QDI_SETDIBITS	1
#define QDI_GETDIBITS	2
#define QDI_DIBTOSCREEN	4
#define QDI_STRETCHDIB	8
#define RAS_MaxDeviceType	16
#define RAS_MaxPhoneNumber	128
#define RAS_MaxIpAddress	15
#define RAS_MaxIpxAddress	21
#define RAS_MaxEntryName	256
#define RAS_MaxDeviceName	128
#define RAS_MaxAreaCode	10
#define RAS_MaxPadType	32
#define RAS_MaxX25Address	200
#define RAS_MaxFacilities	200
#define RAS_MaxUserData	200
#define TME_HOVER 1
#define TME_LEAVE 2
#define TME_NONCLIENT 16
#define TME_QUERY	0x40000000
#define TME_CANCEL	0x80000000
#define HOVER_DEFAULT 0xFFFFFFFF
#define	GA_PARENT	1
#define	GA_ROOT	2
#define	GA_ROOTOWNER	3
#define CBEIF_TEXT	1
#define CBEIF_IMAGE	2
#define CBEIF_SELECTEDIMAGE	4
#define CBEIF_OVERLAY	8
#define CBEIF_INDENT	16
#define CBEIF_LPARAM	32
#define CBEIF_DI_SETITEM	0x10000000
#define HW_PROFILE_GUIDLEN 39
#define MAX_PROFILE_LEN	80
#define DOCKINFO_UNDOCKED	1
#define DOCKINFO_DOCKED	2
#define DOCKINFO_USER_SUPPLIED	4
#define DOCKINFO_USER_UNDOCKED (DOCKINFO_USER_SUPPLIED | DOCKINFO_UNDOCKED)
#define DOCKINFO_USER_DOCKED (DOCKINFO_USER_SUPPLIED | DOCKINFO_DOCKED)
#define FIND_FIRST_EX_CASE_SENSITIVE 1
#define ALL_TRANSPORTS "M\0\0\0"
#define MS_NBF "MNBF"
#define NCBCALL 0x10
#define NCBLISTEN 0x11
#define NCBHANGUP 0x12
#define NCBSEND 0x14
#define NCBRECV 0x15
#define NCBRECVANY 0x16
#define NCBCHAINSEND 0x17
#define NCBDGSEND 0x20
#define NCBDGRECV 0x21
#define NCBDGSENDBC 0x22
#define NCBDGRECVBC 0x23
#define NCBADDNAME 0x30
#define NCBDELNAME 0x31
#define NCBRESET 0x32
#define NCBASTAT 0x33
#define NCBSSTAT 0x34
#define NCBCANCEL 0x35
#define NCBADDGRNAME 0x36
#define NCBENUM 0x37
#define NCBUNLINK 0x70
#define NCBSENDNA 0x71
#define NCBCHAINSENDNA 0x72
#define NCBLANSTALERT 0x73
#define NCBACTION 0x77
#define NCBFINDNAME 0x78
#define NCBTRACE 0x79
#define ASYNCH 0x80
#define NRC_GOODRET 0x00
#define NRC_BUFLEN 0x01
#define NRC_ILLCMD 0x03
#define NRC_CMDTMO 0x05
#define NRC_INCOMP 0x06
#define NRC_BADDR 0x07
#define NRC_SNUMOUT 0x08
#define NRC_NORES 0x09
#define NRC_SCLOSED 0x0a
#define NRC_CMDCAN 0x0b
#define NRC_DUPNAME 0x0d
#define NRC_NAMTFUL 0x0e
#define NRC_ACTSES 0x0f
#define NRC_LOCTFUL 0x11
#define NRC_REMTFUL 0x12
#define NRC_ILLNN 0x13
#define NRC_NOCALL 0x14
#define NRC_NOWILD 0x15
#define NRC_INUSE 0x16
#define NRC_NAMERR 0x17
#define NRC_SABORT 0x18
#define NRC_NAMCONF 0x19
#define NRC_IFBUSY 0x21
#define NRC_TOOMANY 0x22
#define NRC_BRIDGE 0x23
#define NRC_CANOCCR 0x24
#define NRC_CANCEL 0x26
#define NRC_DUPENV 0x30
#define NRC_ENVNOTDEF 0x34
#define NRC_OSRESNOTAV 0x35
#define NRC_MAXAPPS 0x36
#define NRC_NOSAPS 0x37
#define NRC_NORESOURCES 0x38
#define NRC_INVADDRESS 0x39
#define NRC_INVDDID 0x3B
#define NRC_LOCKFAIL 0x3C
#define NRC_OPENERR 0x3f
#define NRC_SYSTEM 0x40
#define NRC_PENDING 0xff
#define NCB_POST void CALLBACK
#define ACL_REVISION	2
#define ACL_REVISION_DS	4
#define ACL_REVISION1	1
#define MIN_ACL_REVISION ACL_REVISION2
#define ACL_REVISION2	2
#define ACL_REVISION3	3
#define ACL_REVISION4	4
#define MAX_ACL_REVISION ACL_REVISION4
#define CONTAINING_RECORD(a,t,f) ((t *)((PCHAR)(a) - (ULONG_PTR)(&((t *)0)->f)))
#define LOGON32_LOGON_INTERACTIVE	2
#define LOGON32_LOGON_NETWORK	3
#define LOGON32_LOGON_BATCH	4
#define LOGON32_LOGON_SERVICE	5
#define LOGON32_LOGON_UNLOCK	7
#define LOGON32_LOGON_NETWORK_CLEARTEXT 8
#define LOGON32_LOGON_NEW_CREDENTIALS 9
#define LOGON32_PROVIDER_DEFAULT	0
#define LOGON32_PROVIDER_WINNT35	1
#define LOGON32_PROVIDER_WINNT40	2
#define LOGON32_PROVIDER_WINNT50	3
#define LOGON_WITH_PROFILE	1
#define LOGON_NETCREDENTIALS_ONLY	2
#define LOGON_ZERO_PASSWORD_BUFFER	0x80000000
#define WINEVENT_OUTOFCONTEXT	0
#define WINEVENT_SKIPOWNTHREAD	1
#define WINEVENT_SKIPOWNPROCESS	2
#define WINEVENT_INCONTEXT	4
#define GetKValue(cmyk)	((BYTE)(cmyk))
#define GetYValue(cmyk)	((BYTE)((cmyk)>> 8))
#define GetMValue(cmyk)	((BYTE)((cmyk)>>16))
#define GetCValue(cmyk)	((BYTE)((cmyk)>>24))
#define GR_GDIOBJECTS	0
#define GR_USEROBJECTS	1
#define ENUM_CURRENT_SETTINGS ((DWORD)-1)
#define ENUM_REGISTRY_SETTINGS ((DWORD)-2)
#define NFS_EDIT	1
#define NFS_STATIC	2
#define NFS_LISTCOMBO	4
#define NFS_BUTTON	8
#define NFS_ALL	0x10
#define NFS_USEFONTASSOC	0x20
#define ENDSESSION_LOGOFF	0x80000000
#define GET_RAWINPUT_CODE_WPARAM(wParam)	((wParam)&0xff)
#define RIM_INPUT	0
#define RIM_INPUTSINK	1
#define RIM_TYPEMOUSE	0
#define RIM_TYPEKEYBOARD	1
#define RIM_TYPEHID	2
#define RI_MOUSE_LEFT_BUTTON_DOWN	1
#define RI_MOUSE_LEFT_BUTTON_UP	2
#define RI_MOUSE_RIGHT_BUTTON_DOWN	4
#define RI_MOUSE_RIGHT_BUTTON_UP	8
#define RI_MOUSE_MIDDLE_BUTTON_DOWN	16
#define RI_MOUSE_MIDDLE_BUTTON_UP	0x20
#define RI_MOUSE_BUTTON_1_DOWN	RI_MOUSE_LEFT_BUTTON_DOWN
#define RI_MOUSE_BUTTON_1_UP	RI_MOUSE_LEFT_BUTTON_UP
#define RI_MOUSE_BUTTON_2_DOWN	RI_MOUSE_RIGHT_BUTTON_DOWN
#define RI_MOUSE_BUTTON_2_UP	RI_MOUSE_RIGHT_BUTTON_UP
#define RI_MOUSE_BUTTON_3_DOWN	RI_MOUSE_MIDDLE_BUTTON_DOWN
#define RI_MOUSE_BUTTON_3_UP	RI_MOUSE_MIDDLE_BUTTON_UP
#define RI_MOUSE_BUTTON_4_DOWN	0x0040
#define RI_MOUSE_BUTTON_4_UP	0x0080
#define RI_MOUSE_BUTTON_5_DOWN	0x0100
#define RI_MOUSE_BUTTON_5_UP	0x0200
#define RI_MOUSE_WHEEL	0x0400
#define MOUSE_MOVE_RELATIVE	0
#define MOUSE_MOVE_ABSOLUTE	1
#define MOUSE_VIRTUAL_DESKTOP	2
#define MOUSE_ATTRIBUTES_CHANGED 4
#define KEYBOARD_OVERRUN_MAKE_CODE	0xFF
#define RI_KEY_MAKE	0
#define RI_KEY_BREAK	1
#define RI_KEY_E0	2
#define RI_KEY_E1	4
#define RI_KEY_TERMSRV_SET_LED	8
#define RI_KEY_TERMSRV_SHADOW	0x10
#define RAWINPUT_ALIGN(x)	(((x) + sizeof(DWORD) - 1) & ~(sizeof(DWORD) - 1))
#define NEXTRAWINPUTBLOCK(ptr) ((PRAWINPUT)RAWINPUT_ALIGN((ULONG_PTR)((PBYTE)(ptr) + (ptr)->header.dwSize)))
#define RID_INPUT	0x10000003
#define RID_HEADER	0x10000005
#define RIDI_PREPARSEDDATA	0x20000005
#define RIDI_DEVICENAME	0x20000007
#define RIDI_DEVICEINFO	0x2000000b
#define RIDEV_REMOVE	1
#define RIDEV_EXCLUDE	0x10
#define RIDEV_PAGEONLY	0x20
#define RIDEV_NOLEGACY	0x30
#define RIDEV_CAPTUREMOUSE	0x200
#define RIDEV_NOHOTKEYS	0x200
#define RIDEV_EXMODEMASK	0x0F0
#define RIDEV_EXMODE(mode) ((mode)&RIDEV_EXMODEMASK)
#define WTS_CONSOLE_CONNECT	0x1
#define WTS_CONSOLE_DISCONNECT	0x2
#define WTS_REMOTE_CONNECT	0x3
#define WTS_REMOTE_DISCONNECT	0x4
#define WTS_SESSION_LOGON	0x5
#define WTS_SESSION_LOGOFF	0x6
#define WTS_SESSION_LOCK	0x7
#define WTS_SESSION_UNLOCK	0x8
#define APPCOMMAND_BROWSER_BACKWARD 1
#define APPCOMMAND_BROWSER_FORWARD 2
#define APPCOMMAND_BROWSER_REFRESH 3
#define APPCOMMAND_BROWSER_STOP 4
#define APPCOMMAND_BROWSER_SEARCH 5
#define APPCOMMAND_BROWSER_FAVORITES 6
#define APPCOMMAND_BROWSER_HOME 7
#define APPCOMMAND_VOLUME_MUTE 8
#define APPCOMMAND_VOLUME_DOWN 9
#define APPCOMMAND_VOLUME_UP 10
#define APPCOMMAND_MEDIA_NEXTTRACK 11
#define APPCOMMAND_MEDIA_PREVIOUSTRACK 12
#define APPCOMMAND_MEDIA_STOP 13
#define APPCOMMAND_MEDIA_PLAY_PAUSE 14
#define APPCOMMAND_LAUNCH_MAIL 15
#define APPCOMMAND_LAUNCH_MEDIA_SELECT 16
#define APPCOMMAND_LAUNCH_APP1 17
#define APPCOMMAND_LAUNCH_APP2 18
#define APPCOMMAND_BASS_DOWN 19
#define APPCOMMAND_BASS_BOOST 20
#define APPCOMMAND_BASS_UP 21
#define APPCOMMAND_TREBLE_DOWN 22
#define APPCOMMAND_TREBLE_UP 23
#define APPCOMMAND_MICROPHONE_VOLUME_MUTE 24
#define APPCOMMAND_MICROPHONE_VOLUME_DOWN 25
#define APPCOMMAND_MICROPHONE_VOLUME_UP 26
#define APPCOMMAND_HELP 27
#define APPCOMMAND_FIND 28
#define APPCOMMAND_NEW 29
#define APPCOMMAND_OPEN 30
#define APPCOMMAND_CLOSE 31
#define APPCOMMAND_SAVE 32
#define APPCOMMAND_PRINT 33
#define APPCOMMAND_UNDO 34
#define APPCOMMAND_REDO 35
#define APPCOMMAND_COPY 36
#define APPCOMMAND_CUT 37
#define APPCOMMAND_PASTE 38
#define APPCOMMAND_REPLY_TO_MAIL 39
#define APPCOMMAND_FORWARD_MAIL 40
#define APPCOMMAND_SEND_MAIL 41
#define APPCOMMAND_SPELL_CHECK 42
#define APPCOMMAND_DICTATE_OR_COMMAND_CONTROL_TOGGLE 43
#define APPCOMMAND_MIC_ON_OFF_TOGGLE 44
#define APPCOMMAND_CORRECTION_LIST 45
#define FAPPCOMMAND_MOUSE 0x8000
#define FAPPCOMMAND_KEY 0
#define FAPPCOMMAND_OEM 0x1000
#define FAPPCOMMAND_MASK 0xF000
#define GET_APPCOMMAND_LPARAM(lParam) ((short)(HIWORD(lParam) & ~FAPPCOMMAND_MASK))
#define GET_DEVICE_LPARAM(lParam) ((WORD)(HIWORD(lParam) & FAPPCOMMAND_MASK))
#define GET_MOUSEORKEY_LPARAM GET_DEVICE_LPARAM
#define GET_FLAGS_LPARAM(lParam) (LOWORD(lParam))
#define GET_KEYSTATE_LPARAM(lParam) GET_FLAGS_LPARAM(lParam)
#define UISF_HIDEFOCUS	1
#define UISF_HIDEACCEL	2
#define UISF_ACTIVE	4
#define UIS_SET	1
#define UIS_CLEAR	2
#define UIS_INITIALIZE	3
#define FLS_OUT_OF_INDEXES ((DWORD)0xFFFFFFFF)
#define TLS_OUT_OF_INDEXES ((DWORD)0xFFFFFFFF)
#define META_SETLAYOUT 0x0149
#define MSGF_MESSAGEBOX 1
#define MSGF_MAX 8
#define ACCESS_STICKYKEYS 1
#define ACCESS_FILTERKEYS 2
#define ACCESS_MOUSEKEYS 3
#define LLKHF_EXTENDED (KF_EXTENDED >> 8)
#define LLKHF_INJECTED 0x00000010
#define LLKHF_ALTDOWN (KF_ALTDOWN >> 8)
#define LLKHF_UP (KF_UP >> 8)
#define LLMHF_INJECTED 1
#define ACCESS_OBJECT_GUID	0
#define ACCESS_PROPERTY_SET_GUID 1
#define ACCESS_PROPERTY_GUID	2
#define ACCESS_MAX_LEVEL	4
#define VER_NT_WORKSTATION	1
#define VER_NT_DOMAIN_CONTROLLER	2
#define VER_NT_SERVER	3
#define VER_SERVER_NT	0x80000000
#define VER_WORKSTATION_NT	0x40000000
#define VER_SUITE_SMALLBUSINESS	1
#define VER_SUITE_ENTERPRISE	2
#define VER_SUITE_BACKOFFICE	4
#define VER_SUITE_COMMUNICATIONS 8
#define VER_SUITE_TERMINAL	0x10
#define VER_SUITE_SMALLBUSINESS_RESTRICTED 0x20
#define VER_SUITE_EMBEDDEDNT	0x40
#define VER_SUITE_DATACENTER	0x80
#define VER_SUITE_SINGLEUSERTS	0x100
#define VER_SUITE_PERSONAL	0x200
#define VER_SUITE_BLADE	0x400
#define VER_SUITE_EMBEDDED_RESTRICTED	0x800
#define VER_SUITE_SECURITY_APPLIANCE 0x1000
#define AC_LINE_OFFLINE	0
#define AC_LINE_ONLINE	1
#define AC_LINE_BACKUP_POWER	2
#define AC_LINE_UNKNOWN	0xFF
#define BATTERY_FLAG_HIGH	1
#define BATTERY_FLAG_LOW	2
#define BATTERY_FLAG_CRITICAL	4
#define BATTERY_FLAG_CHARGING	8
#define BATTERY_FLAG_NO_BATTERY	0x80
#define BATTERY_FLAG_UNKNOWN	0xFF
#define BATTERY_PERCENTAGE_UNKNOWN	0xFF
#define BATTERY_LIFE_UNKNOWN	0xFFFFFFFF
#define JOB_OBJECT_MSG_END_OF_JOB_TIME 1
#define JOB_OBJECT_MSG_END_OF_PROCESS_TIME 2
#define JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT 3
#define JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO 4
#define JOB_OBJECT_MSG_NEW_PROCESS 6
#define JOB_OBJECT_MSG_EXIT_PROCESS 7
#define JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS 8
#define JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT 9
#define JOB_OBJECT_MSG_JOB_MEMORY_LIMIT 10
#define JOB_OBJECT_LIMIT_WORKINGSET	1
#define JOB_OBJECT_LIMIT_PROCESS_TIME	2
#define JOB_OBJECT_LIMIT_JOB_TIME	4
#define JOB_OBJECT_LIMIT_ACTIVE_PROCESS	8
#define JOB_OBJECT_LIMIT_AFFINITY	0x10
#define JOB_OBJECT_LIMIT_PRIORITY_CLASS	0x20
#define JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME 0x40
#define JOB_OBJECT_LIMIT_SCHEDULING_CLASS	0x80
#define JOB_OBJECT_LIMIT_PROCESS_MEMORY	0x100
#define JOB_OBJECT_LIMIT_JOB_MEMORY	0x200
#define JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION 0x400
#define JOB_OBJECT_LIMIT_BREAKAWAY_OK	0x800
#define JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK	0x1000
#define JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE	0x2000
#define JOB_OBJECT_LIMIT_RESERVED2 0x4000
#define JOB_OBJECT_LIMIT_RESERVED3 0x8000
#define JOB_OBJECT_LIMIT_RESERVED4 0x10000
#define JOB_OBJECT_LIMIT_RESERVED5 0x20000
#define JOB_OBJECT_LIMIT_RESERVED6 0x40000
#define JOB_OBJECT_LIMIT_VALID_FLAGS	0x7ffff
#define JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS 0x0ff
#define JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS 0x003fff
#define JOB_OBJECT_RESERVED_LIMIT_VALID_FLAGS 0x07ffff
#define JOB_OBJECT_UILIMIT_NONE	0
#define JOB_OBJECT_UILIMIT_HANDLES	1
#define JOB_OBJECT_UILIMIT_READCLIPBOARD	2
#define JOB_OBJECT_UILIMIT_WRITECLIPBOARD	4
#define JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS	8
#define JOB_OBJECT_UILIMIT_DISPLAYSETTINGS	0x10
#define JOB_OBJECT_UILIMIT_GLOBALATOMS	0x20
#define JOB_OBJECT_UILIMIT_DESKTOP	0x40
#define JOB_OBJECT_UILIMIT_EXITWINDOWS	0x80
#define JOB_OBJECT_UILIMIT_ALL	0xFF
#define JOB_OBJECT_UI_VALID_FLAGS 0xFF
#define JOB_OBJECT_SECURITY_NO_ADMIN	1
#define JOB_OBJECT_SECURITY_RESTRICTED_TOKEN	2
#define JOB_OBJECT_SECURITY_ONLY_TOKEN	4
#define JOB_OBJECT_SECURITY_FILTER_TOKENS	8
#define JOB_OBJECT_SECURITY_VALID_FLAGS	0xf
#define SEF_DACL_AUTO_INHERIT	1
#define SEF_SACL_AUTO_INHERIT	2
#define SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT	4
#define SEF_AVOID_PRIVILEGE_CHECK	8
#define SEF_AVOID_OWNER_CHECK	0x10
#define SEF_DEFAULT_OWNER_FROM_PARENT	0x20
#define SEF_DEFAULT_GROUP_FROM_PARENT	0x40
#define MIM_MAXHEIGHT 1
#define MIM_BACKGROUND 2
#define MIM_HELPID 4
#define MIM_MENUDATA 8
#define MIM_STYLE 0x10
#define MIM_APPLYTOSUBMENUS 0x80000000
#define MNS_NOCHECK 0x80000000
#define MNS_MODELESS 0x40000000
#define MNS_DRAGDROP 0x20000000
#define MNS_AUTODISMISS 0x10000000
#define MNS_NOTIFYBYPOS 0x8000000
#define MNS_CHECKORBMP 0x4000000
#define QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX 4
#define QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE 8
#define QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS 0x10
#define QUERY_ACTCTX_FLAG_NO_ADDREF 0x80000000
#define EVENTLOG_FULL_INFO 0
//#if (_WIN32_IE >= 0x0300)
#define LPTV_HITTESTINFO	LPTVHITTESTINFO
#define TV_HITTESTINFO	TVHITTESTINFO
//#else
//#define tagTVHITTESTINFO	_TV_HITTESTINFO
//#define TVHITTESTINFO	TV_HITTESTINFO
//#define LPTVHITTESTINFO	LPTV_HITTESTINFO
//#endif
#define LWA_COLORKEY	1
#define LWA_ALPHA	2
#define ULW_COLORKEY	1
#define ULW_ALPHA	2
#define ULW_OPAQUE	4
#define ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID 1
#define ACTCTX_FLAG_LANGID_VALID 2
#define ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID 4
#define ACTCTX_FLAG_RESOURCE_NAME_VALID 8
#define ACTCTX_FLAG_SET_PROCESS_DEFAULT 0x10
#define ACTCTX_FLAG_APPLICATION_NAME_VALID 0x20
#define ACTCTX_FLAG_SOURCE_IS_ASSEMBLYREF 0x040
#define ACTCTX_FLAG_HMODULE_VALID 0x080
#define TIME_ZONE_ID_INVALID ((DWORD)0xFFFFFFFF)
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A "GetSystemWow64DirectoryA"
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_A_W L"GetSystemWow64DirectoryA"
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_A_T TEXT("GetSystemWow64DirectoryA")
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A "GetSystemWow64DirectoryW"
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_W_W L"GetSystemWow64DirectoryW"
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_W_T TEXT("GetSystemWow64DirectoryW")
#define HEAP_NO_SERIALIZE	1
#define HEAP_GROWABLE	2
#define HEAP_GENERATE_EXCEPTIONS	4
#define HEAP_ZERO_MEMORY	8
#define HEAP_REALLOC_IN_PLACE_ONLY	0x10
#define HEAP_TAIL_CHECKING_ENABLED	0x020
#define HEAP_FREE_CHECKING_ENABLED	0x040
#define HEAP_DISABLE_COALESCE_ON_FREE	0x080
#define HEAP_CREATE_ALIGN_16	0x010000
#define HEAP_CREATE_ENABLE_TRACING	0x00020000
#define HEAP_CREATE_ENABLE_EXECUTE	0x00040000
#define HEAP_MAXIMUM_TAG	0x0FFF
#define HEAP_PSEUDO_TAG_FLAG 0x8000
#define HEAP_TAG_SHIFT            18
#define HEAP_MAKE_TAG_FLAGS(b,o) ((DWORD)((b)+((o)<<18)))
#define FILE_ENCRYPTABLE 0
#define FILE_IS_ENCRYPTED 1
#define FILE_SYSTEM_ATTR 2
#define FILE_ROOT_DIR 3
#define FILE_SYSTEM_DIR 4
#define FILE_UNKNOWN 5
#define FILE_SYSTEM_NOT_SUPPORT 6
#define FILE_USER_DISALLOWED 7
#define FILE_READ_ONLY 8
#define FILE_DIR_DISALLOWED 9
#define HasOverlappedIoCompleted(lpOverlapped) (((DWORD)(lpOverlapped)->Internal) != STATUS_PENDING)
#define FIBER_FLAG_FLOAT_SWITCH 1
#define DEACTIVATE_ACTCTX_FLAG_FORCE_EARLY_DEACTIVATION 1
#define GET_MODULE_HANDLE_EX_FLAG_PIN 1
#define GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT 2
#define GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS	4
#define FreeModule(hLibModule) FreeLibrary((hLibModule))
#define PROFILE_LINKED	'LINK'
#define PROFILE_EMBEDDED	'MBED'
#define LVCF_IMAGE	0x0010
#define LVCF_ORDER	0x0020
#define LVCFMT_IMAGE	0x0800
#define LVCFMT_BITMAP_ON_RIGHT	0x1000
#define LVCFMT_COL_HAS_IMAGES	0x8000
#define LVCFMT_JUSTIFYMASK	0x0003

#ifdef UNICODE
#define HD_TEXTFILTER HD_TEXTFILTERW
#define HDTEXTFILTER HD_TEXTFILTERW
#define LPHD_TEXTFILTER LPHD_TEXTFILTERW
#define LPHDTEXTFILTER LPHD_TEXTFILTERW
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_W GET_SYSTEM_WOW64_DIRECTORY_NAME_W_W
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_T GET_SYSTEM_WOW64_DIRECTORY_NAME_W_T
#else
#define HD_TEXTFILTER HD_TEXTFILTERA
#define HDTEXTFILTER HD_TEXTFILTERA
#define LPHD_TEXTFILTER LPHD_TEXTFILTERA
#define LPHDTEXTFILTER LPHD_TEXTFILTERA
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_W GET_SYSTEM_WOW64_DIRECTORY_NAME_A_W
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_T GET_SYSTEM_WOW64_DIRECTORY_NAME_A_T
#endif

#define INVALID_LINK_INDEX (-1)
#define MAX_LINKID_TEXT	48
#define L_MAX_URL_LENGTH	(2048 + 32 + sizeof("://"))
#define LWS_TRANSPARENT 1
#define LWS_IGNORERETURN 2
#define LIF_ITEMINDEX 1
#define LIF_STATE 2
#define LIF_ITEMID 4
#define LIF_URL	8
#define LIS_FOCUSED 1
#define LIS_ENABLED 2
#define LIS_VISITED 4
/* Structures.h */
typedef struct tagACTCTXA {
	ULONG     cbSize;
	DWORD     dwFlags;
	LPCSTR    lpSource;
	USHORT    wProcessorArchitecture;
	LANGID    wLangId;
	LPCSTR    lpAssemblyDirectory;
	LPCSTR    lpResourceName;
	LPCSTR    lpApplicationName;
	HMODULE   hModule;
} ACTCTXA, *PACTCTXA;
typedef struct tagACTCTXW {
	ULONG     cbSize;
	DWORD     dwFlags;
	LPCWSTR   lpSource;
	USHORT    wProcessorArchitecture;
	LANGID    wLangId;
	LPCWSTR   lpAssemblyDirectory;
	LPCWSTR   lpResourceName;
	LPCWSTR   lpApplicationName;
	HMODULE   hModule;
} ACTCTXW, *PACTCTXW;
typedef const ACTCTXA *PCACTCTXA;
typedef const ACTCTXW *PCACTCTXW;

//#if !defined(ACTIVATION_CONTEXT_BASIC_INFORMATION_DEFINED)
//typedef struct _ACTIVATION_CONTEXT_BASIC_INFORMATION {
//	HANDLE hActCtx;
//	DWORD  dwFlags;
//} ACTIVATION_CONTEXT_BASIC_INFORMATION, *PACTIVATION_CONTEXT_BASIC_INFORMATION;
//typedef const struct _ACTIVATION_CONTEXT_BASIC_INFORMATION *PCACTIVATION_CONTEXT_BASIC_INFORMATION;
//#define ACTIVATION_CONTEXT_BASIC_INFORMATION_DEFINED 1
//#endif

typedef struct tagWTSSESSION_NOTIFICATION { DWORD cbSize; DWORD dwSessionId; } WTSSESSION_NOTIFICATION, *PWTSSESSION_NOTIFICATION;
//#ifndef RC_INVOKED
typedef struct tagKBDLLHOOKSTRUCT {
	DWORD vkCode;
	DWORD scanCode;
	DWORD flags;
	DWORD time;
	ULONG_PTR dwExtraInfo;
} KBDLLHOOKSTRUCT, *LPKBDLLHOOKSTRUCT, *PKBDLLHOOKSTRUCT;
typedef struct tagHARDWAREHOOKSTRUCT {
	HWND hwnd;
	UINT message;
	WPARAM wParam;
	LPARAM lParam;
} HARDWAREHOOKSTRUCT, *LPHARDWAREHOOKSTRUCT, *PHARDWAREHOOKSTRUCT;
typedef struct tagRAWHID{DWORD dwSizeHid;DWORD dwCount;BYTE bRawData[1];}RAWHID,*PRAWHID,*LPRAWHID;
typedef struct tagRID_DEVICE_INFO_MOUSE {
	DWORD dwId;
	DWORD dwNumberOfButtons;
	DWORD dwSampleRate;
} RID_DEVICE_INFO_MOUSE, *PRID_DEVICE_INFO_MOUSE;
typedef struct tagRID_DEVICE_INFO_KEYBOARD {
	DWORD dwType;
	DWORD dwSubType;
	DWORD dwKeyboardMode;
	DWORD dwNumberOfFunctionKeys;
	DWORD dwNumberOfIndicators;
	DWORD dwNumberOfKeysTotal;
} RID_DEVICE_INFO_KEYBOARD, *PRID_DEVICE_INFO_KEYBOARD;
typedef struct tagRID_DEVICE_INFO_HID {
	DWORD dwVendorId;
	DWORD dwProductId;
	DWORD dwVersionNumber;
	USHORT usUsagePage;
	USHORT usUsage;
} RID_DEVICE_INFO_HID, *PRID_DEVICE_INFO_HID;
typedef struct tagRID_DEVICE_INFO {
	DWORD cbSize;
	DWORD dwType;
	union {
		RID_DEVICE_INFO_MOUSE mouse;
		RID_DEVICE_INFO_KEYBOARD keyboard;
		RID_DEVICE_INFO_HID hid;
	};
} RID_DEVICE_INFO, *PRID_DEVICE_INFO, *LPRID_DEVICE_INFO;
typedef struct tagRAWKEYBOARD {
	USHORT MakeCode;
	USHORT Flags;
	USHORT Reserved;
	USHORT VKey;
	UINT Message;
	ULONG ExtraInformation;
} RAWKEYBOARD, *PRAWKEYBOARD, *LPRAWKEYBOARD;
typedef struct tagRAWINPUTHEADER {
	DWORD dwType;
	DWORD dwSize;
	HANDLE hDevice;
	WPARAM wParam;
} RAWINPUTHEADER, *PRAWINPUTHEADER, *LPRAWINPUTHEADER;
typedef struct tagRAWMOUSE {
	USHORT usFlags;
	union {
		ULONG ulButtons;
		struct {
		USHORT usButtonFlags;
		USHORT usButtonData;
		};
	};
	ULONG ulRawButtons;
	LONG lLastX;
	LONG lLastY;
	ULONG ulExtraInformation;
} RAWMOUSE, *PRAWMOUSE, *LPRAWMOUSE;
typedef struct tagRAWINPUT {
	RAWINPUTHEADER header;
	union {
		RAWMOUSE mouse;
		RAWKEYBOARD keyboard;
		RAWHID hid;
	} data;
} RAWINPUT, *PRAWINPUT, *LPRAWINPUT;
typedef struct tagRAWINPUTDEVICE {
	USHORT usUsagePage;
	USHORT usUsage;
	DWORD dwFlags;
	HWND hwndTarget;
} RAWINPUTDEVICE, *PRAWINPUTDEVICE, *LPRAWINPUTDEVICE;
typedef CONST RAWINPUTDEVICE* PCRAWINPUTDEVICE;
typedef struct tagRAWINPUTDEVICELIST { HANDLE hDevice; DWORD dwType;} RAWINPUTDEVICELIST, *PRAWINPUTDEVICELIST;
typedef union _LARGE_INTEGER {
	struct { DWORD LowPart; LONG HighPart;};
	struct { DWORD LowPart; LONG HighPart; } u;
	long long int QuadPart;
} LARGE_INTEGER,*PLARGE_INTEGER;
typedef DWORD (WINAPI *LPPROGRESS_ROUTINE)(LARGE_INTEGER,LARGE_INTEGER,LARGE_INTEGER,LARGE_INTEGER,DWORD,DWORD,HANDLE,HANDLE,LPVOID);
typedef struct _ABC {
	int abcA;
	UINT abcB;
	int abcC;
} ABC,*LPABC;
typedef struct _ABCFLOAT {
	FLOAT abcfA;
	FLOAT abcfB;
	FLOAT abcfC;
} ABCFLOAT,*LPABCFLOAT;
#pragma pack(push,2)
typedef struct tagACCEL {
	BYTE fVirt;
	WORD key;
	WORD cmd;
} ACCEL,*LPACCEL;
#pragma pack(pop)
typedef struct _ACE_HEADER {
	BYTE AceType;
	BYTE AceFlags;
	WORD AceSize;
} ACE_HEADER;
typedef DWORD ACCESS_MASK;
typedef ACCESS_MASK REGSAM;
typedef struct _ACCESS_ALLOWED_ACE {
	ACE_HEADER Header;
	ACCESS_MASK Mask;
	DWORD SidStart;
} ACCESS_ALLOWED_ACE;
typedef struct _ACCESS_DENIED_ACE {
	ACE_HEADER Header;
	ACCESS_MASK Mask;
	DWORD SidStart;
} ACCESS_DENIED_ACE;
typedef struct tagACCESSTIMEOUT {
	UINT cbSize;
	DWORD dwFlags;
	DWORD iTimeOutMSec;
} ACCESSTIMEOUT;
typedef struct _ACL {
	BYTE AclRevision;
	BYTE Sbz1;
	WORD AclSize;
	WORD AceCount;
	WORD Sbz2;
} ACL,*PACL;
typedef struct _ACL_REVISION_INFORMATION {
	DWORD AclRevision;
} ACL_REVISION_INFORMATION;
typedef struct _ACL_SIZE_INFORMATION {
	DWORD AceCount;
	DWORD AclBytesInUse;
	DWORD AclBytesFree;
} ACL_SIZE_INFORMATION;
typedef struct _ACTION_HEADER {
	ULONG transport_id;
	USHORT action_code;
	USHORT reserved;
} ACTION_HEADER;
typedef struct _ADAPTER_STATUS {
	UCHAR adapter_address[6];
	UCHAR rev_major;
	UCHAR reserved0;
	UCHAR adapter_type;
	UCHAR rev_minor;
	WORD duration;
	WORD frmr_recv;
	WORD frmr_xmit;
	WORD iframe_recv_err;
	WORD xmit_aborts;
	DWORD xmit_success;
	DWORD recv_success;
	WORD iframe_xmit_err;
	WORD recv_buff_unavail;
	WORD t1_timeouts;
	WORD ti_timeouts;
	DWORD reserved1;
	WORD free_ncbs;
	WORD max_cfg_ncbs;
	WORD max_ncbs;
	WORD xmit_buf_unavail;
	WORD max_dgram_size;
	WORD pending_sess;
	WORD max_cfg_sess;
	WORD max_sess;
	WORD max_sess_pkt_size;
	WORD name_count;
} ADAPTER_STATUS;
typedef struct tagANIMATIONINFO {
	UINT cbSize;
	int iMinAnimate;
} ANIMATIONINFO,*LPANIMATIONINFO;
typedef struct _RECT {
	LONG left;
	LONG top;
	LONG right;
	LONG bottom;
} RECT,*LPRECT;
typedef struct _RECT *PRECT;
typedef const RECT *LPCRECT;
typedef struct _RECTL {
	LONG left;
	LONG top;
	LONG right;
	LONG bottom;
} RECTL,*LPRECTL;
typedef const RECTL *LPCRECTL;
typedef struct tagBITMAP {
	LONG bmType;
	LONG bmWidth;
	LONG bmHeight;
	LONG bmWidthBytes;
	WORD bmPlanes;
	WORD bmBitsPixel;
	LPVOID bmBits;
} BITMAP,*PBITMAP,*NPBITMAP,*LPBITMAP;
typedef struct tagBITMAPCOREHEADER {
	DWORD bcSize;
	WORD bcWidth;
	WORD bcHeight;
	WORD bcPlanes;
	WORD bcBitCount;
} BITMAPCOREHEADER;
 /* was missing jn */
typedef BITMAPCOREHEADER *LPBITMAPCOREHEADER;
typedef struct tagRGBTRIPLE {
	BYTE rgbtBlue;
	BYTE rgbtGreen;
	BYTE rgbtRed;
} RGBTRIPLE;
typedef struct _BITMAPCOREINFO {
	BITMAPCOREHEADER bmciHeader;
	RGBTRIPLE bmciColors[1];
} BITMAPCOREINFO;
/* was missing jn */
typedef BITMAPCOREINFO *LPBITMAPCOREINFO;
#pragma pack(1)
typedef struct tagBITMAPFILEHEADER {
	WORD bfType;
	DWORD bfSize;
	WORD bfReserved1;
	WORD bfReserved2;
	DWORD bfOffBits;
} BITMAPFILEHEADER,*LPBITMAPFILEHEADER,*PBITMAPFILEHEADER;
#pragma pack()
typedef struct tagBITMAPINFOHEADER {
	DWORD biSize;
	LONG biWidth;
	LONG biHeight;
	WORD biPlanes;
	WORD biBitCount;
	DWORD biCompression;
	DWORD biSizeImage;
	LONG biXPelsPerMeter;
	LONG biYPelsPerMeter;
	DWORD biClrUsed;
	DWORD biClrImportant;
} BITMAPINFOHEADER,*LPBITMAPINFOHEADER,*PBITMAPINFOHEADER;
typedef struct tagRGBQUAD {
	BYTE rgbBlue;
	BYTE rgbGreen;
	BYTE rgbRed;
	BYTE rgbReserved;
} RGBQUAD,*LPRGBQUAD;
typedef struct tagBITMAPINFO {
	BITMAPINFOHEADER bmiHeader;
	RGBQUAD bmiColors[1];
} BITMAPINFO,*LPBITMAPINFO,*PBITMAPINFO;
typedef long FXPT2DOT30,*LPFXPT2DOT30;
typedef struct tagCIEXYZ {
	FXPT2DOT30 ciexyzX;
	FXPT2DOT30 ciexyzY;
	FXPT2DOT30 ciexyzZ;
} CIEXYZ;
typedef CIEXYZ *LPCIEXYZ;
typedef struct tagICEXYZTRIPLE {
	CIEXYZ ciexyzRed;
	CIEXYZ ciexyzGreen;
	CIEXYZ ciexyzBlue;
} CIEXYZTRIPLE, *LPCIEXYZTRIPLE;
typedef struct {
	DWORD bV4Size;
	LONG bV4Width;
	LONG bV4Height;
	WORD bV4Planes;
	WORD bV4BitCount;
	DWORD bV4V4Compression;
	DWORD bV4SizeImage;
	LONG bV4XPelsPerMeter;
	LONG bV4YPelsPerMeter;
	DWORD bV4ClrUsed;
	DWORD bV4ClrImportant;
	DWORD bV4RedMask;
	DWORD bV4GreenMask;
	DWORD bV4BlueMask;
	DWORD bV4AlphaMask;
	DWORD bV4CSType;
	CIEXYZTRIPLE bV4Endpoints;
	DWORD bV4GammaRed;
	DWORD bV4GammaGreen;
	DWORD bV4GammaBlue;
} BITMAPV4HEADER,*LPBITMAPV4HEADER,*PBITMAPV4HEADER;
typedef struct {
	DWORD bV5Size;
	LONG bV5Width;
	LONG bV5Height;
	WORD bV5Planes;
	WORD bV5BitCount;
	DWORD bV5Compression;
	DWORD bV5SizeImage;
	LONG bV5XPelsPerMeter;
	LONG bV5YPelsPerMeter;
	DWORD bV5ClrUsed;
	DWORD bV5ClrImportant;
	DWORD bV5RedMask;
	DWORD bV5GreenMask;
	DWORD bV5BlueMask;
	DWORD bV5AlphaMask;
	DWORD bV5CSType;
	CIEXYZTRIPLE bV5Endpoints;
	DWORD bV5GammaRed;
	DWORD bV5GammaGreen;
	DWORD bV5GammaBlue;
	DWORD bV5Intent;
	DWORD bV5ProfileData;
	DWORD bV5ProfileSize;
	DWORD bV5Reserved;
} BITMAPV5HEADER, *LPBITMAPV5HEADER, *PBITMAPV5HEADER;

//#ifndef _SHITEMID_DEFINED
typedef struct _SHITEMID { USHORT cb; BYTE abID[1]; } SHITEMID,*LPSHITEMID;
#define _SHITEMID_DEFINED
//#endif
typedef const SHITEMID *LPCSHITEMID;
//#ifndef _ITEMIDLIST_DEFINED
#define _ITEMIDLIST_DEFINED
typedef struct _ITEMIDLIST { SHITEMID mkid; } ITEMIDLIST,*LPITEMIDLIST;
//#endif
typedef const ITEMIDLIST *LPCITEMIDLIST;
typedef struct _browseinfo {
	HWND hwndOwner;
	LPCITEMIDLIST pidlRoot;
	LPSTR pszDisplayName;
	LPCSTR lpszTitle;
	UINT ulFlags;
	BFFCALLBACK lpfn;
	LPARAM lParam;
	int iImage;
} BROWSEINFO,*PBROWSEINFO,*LPBROWSEINFO;
typedef struct tagFILETIME {
	DWORD dwLowDateTime;
	DWORD dwHighDateTime;
} FILETIME,*LPFILETIME,*PFILETIME;
#define _FILETIME
typedef struct _BY_HANDLE_FILE_INFORMATION {
	DWORD dwFileAttributes;
	FILETIME ftCreationTime;
	FILETIME ftLastAccessTime;
	FILETIME ftLastWriteTime;
	DWORD dwVolumeSerialNumber;
	DWORD nFileSizeHigh;
	DWORD nFileSizeLow;
	DWORD nNumberOfLinks;
	DWORD nFileIndexHigh;
	DWORD nFileIndexLow;
} BY_HANDLE_FILE_INFORMATION,*LPBY_HANDLE_FILE_INFORMATION;
typedef struct _FIXED {
	WORD fract;
	short value;
} FIXED;
typedef struct tagPOINT {
	LONG x;
	LONG y;
} POINT,*PPOINT;
#define LPPOINT PPOINT
typedef struct tagPOINTFX {
	FIXED x;
	FIXED y;
} POINTFX;
typedef struct _POINTL {
	LONG x;
	LONG y;
} POINTL;
typedef struct tagPOINTS {
	SHORT x;
	SHORT y;
} POINTS;
typedef struct tagCREATESTRUCT {
	LPVOID lpCreateParams;
	HINSTANCE hInstance;
	HMENU hMenu;
	HWND hwndParent;
	int cy;
	int cx;
	int y;
	int x;
	LONG style;
	LPCTSTR lpszName;
	LPCTSTR lpszClass;
	DWORD dwExStyle;
} CREATESTRUCT,*LPCREATESTRUCT;
typedef struct tagCBT_CREATEWNDA {
	struct tagCREATESTRUCTA *lpcs;
	HWND	hwndInsertAfter;
} CBT_CREATEWNDA, *LPCBT_CREATEWNDA;
typedef struct tagCBT_CREATEWNDW {
	struct tagCREATESTRUCTW *lpcs;
	HWND hwndInsertAfter;
} CBT_CREATEWNDW, *LPCBT_CREATEWNDW;

#ifdef UNICODE
typedef ACTCTXW ACTCTX;
typedef PACTCTXW PACTCTX;
typedef CBT_CREATEWNDW CBT_CREATEWND;
typedef LPCBT_CREATEWNDW LPCBT_CREATEWND;
#else
typedef ACTCTXA ACTCTX;
typedef PACTCTXA PACTCTX;
typedef CBT_CREATEWNDA CBT_CREATEWND;
typedef LPCBT_CREATEWNDA LPCBT_CREATEWND;
#endif

typedef struct tagCBTACTIVATESTRUCT {
	BOOL fMouse;
	HWND hWndActive;
} CBTACTIVATESTRUCT, *LPCBTACTIVATESTRUCT;
#define WTS_CONSOLE_CONNECT		1
#define WTS_CONSOLE_DISCONNECT		2
#define WTS_REMOTE_CONNECT		3
#define WTS_REMOTE_DISCONNECT		4
#define WTS_SESSION_LOGON		5
#define WTS_SESSION_LOGOFF		6
#define WTS_SESSION_LOCK		7
#define WTS_SESSION_UNLOCK		8
#define WTS_SESSION_REMOTE_CONTROL	9
typedef struct _CHAR_INFO {
	union { WCHAR UnicodeChar; CHAR AsciiChar; } Char;
	WORD Attributes;
} CHAR_INFO,*PCHAR_INFO;
typedef struct tagMSLLHOOKSTRUCT {
	POINT pt;
	DWORD mouseData;
	DWORD flags;
	DWORD time;
	ULONG_PTR dwExtraInfo;
} MSLLHOOKSTRUCT, *LPMSLLHOOKSTRUCT, *PMSLLHOOKSTRUCT;
#ifndef _CHARRANGE_DEFINED
#define _CHARRANGE_DEFINED
typedef struct _charrange { LONG cpMin; LONG cpMax; } CHARRANGE;
#endif
typedef struct tagCHARSET { DWORD aflBlock[3]; DWORD flLang; } CHARSET;
typedef struct tagFONTSIGNATURE { DWORD fsUsb[4]; DWORD fsCsb[2]; }
	FONTSIGNATURE,*LPFONTSIGNATURE;
typedef struct {
	UINT ciCharset;
	UINT ciACP;
	FONTSIGNATURE fs;
} CHARSETINFO,*LPCHARSETINFO;
typedef struct {
	DWORD lStructSize;
	HWND hwndOwner;
	HWND hInstance;
	COLORREF rgbResult;
	COLORREF *lpCustColors;
	DWORD Flags;
	LPARAM lCustData;
	LPCCHOOKPROC lpfnHook;
	LPCTSTR lpTemplateName;
} CHOOSECOLOR,*LPCHOOSECOLOR;
typedef struct tagLOGFONTA {
	LONG	lfHeight;
	LONG	lfWidth;
	LONG	lfEscapement;
	LONG	lfOrientation;
	LONG	lfWeight;
	BYTE	lfItalic;
	BYTE	lfUnderline;
	BYTE	lfStrikeOut;
	BYTE	lfCharSet;
	BYTE	lfOutPrecision;
	BYTE	lfClipPrecision;
	BYTE	lfQuality;
	BYTE	lfPitchAndFamily;
	CHAR	lfFaceName[LF_FACESIZE];
} LOGFONTA, *PLOGFONTA, NEAR *NPLOGFONTA, FAR *LPLOGFONTA;
typedef struct tagLOGFONTW
{
	LONG	lfHeight;
	LONG	lfWidth;
	LONG	lfEscapement;
	LONG	lfOrientation;
	LONG	lfWeight;
	BYTE	lfItalic;
	BYTE	lfUnderline;
	BYTE	lfStrikeOut;
	BYTE	lfCharSet;
	BYTE	lfOutPrecision;
	BYTE	lfClipPrecision;
	BYTE	lfQuality;
	BYTE	lfPitchAndFamily;
	WCHAR	lfFaceName[LF_FACESIZE];
} LOGFONTW, *PLOGFONTW, *NPLOGFONTW, *LPLOGFONTW;
#ifdef UNICODE
typedef LOGFONTW LOGFONT;
typedef PLOGFONTW PLOGFONT;
typedef NPLOGFONTW NPLOGFONT;
typedef LPLOGFONTW LPLOGFONT;
#else
typedef LOGFONTA LOGFONT;
typedef PLOGFONTA PLOGFONT;
typedef NPLOGFONTA NPLOGFONT;
typedef LPLOGFONTA LPLOGFONT;
#endif
typedef struct {
	DWORD lStructSize;
	HWND hwndOwner;
	HDC hDC;
	LPLOGFONT lpLogFont;
	INT iPointSize;
	DWORD Flags;
	DWORD rgbColors;
	LPARAM lCustData;
	LPCFHOOKPROC lpfnHook;
	LPCTSTR lpTemplateName;
	HINSTANCE hInstance;
	LPTSTR lpszStyle;
	WORD nFontType;
	WORD ___MISSING_ALIGNMENT__;
	INT nSizeMin;
	INT nSizeMax;
} CHOOSEFONT,*LPCHOOSEFONT;
#ifndef _IDA_DEFINED
#define _IDA_DEFINED
typedef struct _IDA { UINT cidl; UINT aoffset[1]; } CIDA,*LPIDA;
#endif
typedef struct tagCLIENTCREATESTRUCT {
	HANDLE hWindowMenu;
	UINT idFirstChild;
} CLIENTCREATESTRUCT;
typedef struct tagCOLORADJUSTMENT {
	WORD caSize;
	WORD caFlags;
	WORD caIlluminantIndex;
	WORD caRedGamma;
	WORD caGreenGamma;
	WORD caBlueGamma;
	WORD caReferenceBlack;
	WORD caReferenceWhite;
	SHORT caContrast;
	SHORT caBrightness;
	SHORT caColorfulness;
	SHORT caRedGreenTint;
} COLORADJUSTMENT,*LPCOLORADJUSTMENT;
typedef struct _COLORMAP {
	COLORREF from;
	COLORREF to;
} COLORMAP,*LPCOLORMAP;
typedef struct _DCB {
	DWORD DCBlength;
	DWORD BaudRate;
	unsigned fBinary:1;
	unsigned fParity:1;
	unsigned fOutxCtsFlow:1;
	unsigned fOutxDsrFlow:1;
	unsigned fDtrControl:2;
	unsigned fDsrSensitivity:1;
	unsigned fTXContinueOnXoff:1;
	unsigned fOutX:1;
	unsigned fInX:1;
	unsigned fErrorChar:1;
	unsigned fNull:1;
	unsigned fRtsControl:2;
	unsigned fAbortOnError:1;
	unsigned fDummy2:17;
	WORD wReserved;
	WORD XonLim;
	WORD XoffLim;
	BYTE ByteSize;
	BYTE Parity;
	BYTE StopBits;
	char XonChar;
	char XoffChar;
	char ErrorChar;
	char EofChar;
	char EvtChar;
	WORD wReserved1;
} DCB,*LPDCB;
typedef struct _DEC { USHORT wReserved; BYTE scale; BYTE sign;
 ULONG Hi32; long long int Lo64; } DECIMAL;
typedef struct tagBLOB { ULONG cbSize; BYTE *pBlobData; } BLOB;
typedef struct tagBLOB *LPBLOB;
#define _LPBLOB_DEFINED
typedef struct _COMM_CONFIG {
	DWORD dwSize;
	WORD wVersion;
	WORD wReserved;
	DCB dcb;
	DWORD dwProviderSubType;
	DWORD dwProviderOffset;
	DWORD dwProviderSize;
	WCHAR wcProviderData[2];
} COMMCONFIG,*LPCOMMCONFIG;
typedef struct _COMMPROP {
	WORD wPacketLength;
	WORD wPacketVersion;
	DWORD dwServiceMask;
	DWORD dwReserved1;
	DWORD dwMaxTxQueue;
	DWORD dwMaxRxQueue;
	DWORD dwMaxBaud;
	DWORD dwProvSubType;
	DWORD dwProvCapabilities;
	DWORD dwSettableParams;
	DWORD dwSettableBaud;
	WORD wSettableData;
	WORD wSettableStopParity;
	DWORD dwCurrentTxQueue;
	DWORD dwCurrentRxQueue;
	DWORD dwProvSpec1;
	DWORD dwProvSpec2;
	WCHAR wcProvChar[1];
} COMMPROP,*LPCOMMPROP;
typedef struct _COMMTIMEOUTS {
	DWORD ReadIntervalTimeout;
	DWORD ReadTotalTimeoutMultiplier;
	DWORD ReadTotalTimeoutConstant;
	DWORD WriteTotalTimeoutMultiplier;
	DWORD WriteTotalTimeoutConstant;
} COMMTIMEOUTS,*LPCOMMTIMEOUTS;
typedef struct tagCOMPAREITEMSTRUCT {
	UINT CtlType;
	UINT CtlID;
	HWND hwndItem;
	UINT itemID1;
	DWORD itemData1;
	UINT itemID2;
	DWORD itemData2;
} COMPAREITEMSTRUCT;
typedef struct _COMSTAT {
	unsigned fCtsHold:1;
	unsigned fDsrHold:1;
	unsigned fRlsdHold:1;
	unsigned fXoffHold:1;
	unsigned fXoffSent:1;
	unsigned fEof:1;
	unsigned fTxim:1;
	unsigned fReserved:25;
	DWORD cbInQue;
	DWORD cbOutQue;
} COMSTAT,*LPCOMSTAT;
typedef struct _CONSOLE_CURSOR_INFO {
	DWORD dwSize;
	BOOL bVisible;
} CONSOLE_CURSOR_INFO,*PCONSOLE_CURSOR_INFO;
typedef struct _COORD {
	SHORT X;
	SHORT Y;
} COORD;
typedef struct _SMALL_RECT {
	SHORT Left;
	SHORT Top;
	SHORT Right;
	SHORT Bottom;
} SMALL_RECT,*PSMALL_RECT;
typedef struct _CONSOLE_SCREEN_BUFFER_INFO {
	COORD dwSize;
	COORD dwCursorPosition;
	WORD wAttributes;
	SMALL_RECT srWindow;
	COORD dwMaximumWindowSize;
} CONSOLE_SCREEN_BUFFER_INFO,*PCONSOLE_SCREEN_BUFFER_INFO;
#ifndef _CONTEXT_DEFINED_
#define _CONTEXT_DEFINED_
#define MAXIMUM_SUPPORTED_EXTENSION	512
typedef struct _FLOATING_SAVE_AREA {
	DWORD ControlWord;
	DWORD StatusWord;
	DWORD TagWord;
	DWORD ErrorOffset;
	DWORD ErrorSelector;
	DWORD DataOffset;
	DWORD DataSelector;
	BYTE RegisterArea[80];
	DWORD Cr0NpxState;
} FLOATING_SAVE_AREA;
typedef struct _CONTEXT {
	DWORD ContextFlags;
	DWORD Dr0;
	DWORD Dr1;
	DWORD Dr2;
	DWORD Dr3;
	DWORD Dr6;
	DWORD Dr7;
	FLOATING_SAVE_AREA FloatSave;
	DWORD SegGs;
	DWORD SegFs;
	DWORD SegEs;
	DWORD SegDs;
	DWORD Edi;
	DWORD Esi;
	DWORD Ebx;
	DWORD Edx;
	DWORD Ecx;
	DWORD Eax;
	DWORD Ebp;
	DWORD Eip;
	DWORD SegCs;
	DWORD EFlags;
	DWORD Esp;
	DWORD SegSs;
	BYTE ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];
} CONTEXT,*PCONTEXT,*LPCONTEXT;
#endif
typedef struct _POWER_DEVICE_TIMEOUTS {
 DWORD ConservationIdleTime;
 DWORD PerformanceIdleTime;
} POWER_DEVICE_TIMEOUTS, *PPOWER_DEVICE_TIMEOUTS;
typedef struct _LIST_ENTRY {
	struct _LIST_ENTRY *Flink;
	struct _LIST_ENTRY *Blink;
} LIST_ENTRY,*PLIST_ENTRY;
typedef struct _RTL_CRITICAL_SECTION_DEBUG {
	WORD Type;
	WORD CreatorBackTraceIndex;
	struct _RTL_CRITICAL_SECTION *CriticalSection;
	LIST_ENTRY ProcessLocksList;
	DWORD EntryCount;
	DWORD ContentionCount;
	DWORD Spare[ 2];
} RTL_CRITICAL_SECTION_DEBUG,*PRTL_CRITICAL_SECTION_DEBUG,RTL_RESOURCE_DEBUG,*PRTL_RESOURCE_DEBUG;
typedef struct _SECURITY_QUALITY_OF_SERVICE {
	DWORD Length;
	SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
	BOOL ContextTrackingMode;
	BOOLEAN EffectiveOnly;
} SECURITY_QUALITY_OF_SERVICE;
typedef struct tagCONVCONTEXT {
	UINT cb;
	UINT wFlags;
	UINT wCountryID;
	int iCodePage;
	DWORD dwLangID;
	DWORD dwSecurity;
	SECURITY_QUALITY_OF_SERVICE qos;
} CONVCONTEXT;
typedef struct tagCONVINFO {
	DWORD cb;
	DWORD hUser;
	HCONV hConvPartner;
	HSZ hszSvcPartner;
	HSZ hszServiceReq;
	HSZ hszTopic;
	HSZ hszItem;
	UINT wFmt;
	UINT wType;
	UINT wStatus;
	UINT wConvst;
	UINT wLastError;
	HCONVLIST hConvList;
	CONVCONTEXT ConvCtxt;
	HWND hwnd;
	HWND hwndPartner;
} CONVINFO;
typedef struct tagCOPYDATASTRUCT {
	DWORD dwData;
	DWORD cbData;
	PVOID lpData;
} COPYDATASTRUCT,*PCOPYDATASTRUCT;
typedef struct tagMDINEXTMENU {
	HMENU hmenuIn;
	HMENU hmenuNext;
	HWND hwndNext;
} MDINEXTMENU,*PMDINEXTMENU, *LPMDINEXTMENU;
typedef struct _cpinfo {
	UINT MaxCharSize;
	BYTE DefaultChar[MAX_DEFAULTCHAR];
	BYTE LeadByte[MAX_LEADBYTES];
} CPINFO,*LPCPINFO;
typedef struct _CREATE_PROCESS_DEBUG_INFO {
	HANDLE hFile;
	HANDLE hProcess;
	HANDLE hThread;
	LPVOID lpBaseOfImage;
	DWORD dwDebugInfoFileOffset;
	DWORD nDebugInfoSize;
	LPVOID lpThreadLocalBase;
	LPTHREAD_START_ROUTINE lpStartAddress;
	LPVOID lpImageName;
	WORD fUnicode;
} CREATE_PROCESS_DEBUG_INFO,*LPCREATE_PROCESS_DEBUG_INFO;
typedef struct _CREATE_THREAD_DEBUG_INFO {
	HANDLE hThread;
	LPVOID lpThreadLocalBase;
	LPTHREAD_START_ROUTINE lpStartAddress;
} CREATE_THREAD_DEBUG_INFO,*LPCREATE_THREAD_DEBUG_INFO;
typedef struct _currencyfmtA {
	UINT NumDigits;
	UINT LeadingZero;
	UINT Grouping;
	LPSTR lpDecimalSep;
	LPSTR lpThousandSep;
	UINT NegativeOrder;
	UINT PositiveOrder;
	LPTSTR lpCurrencySymbol;
} CURRENCYFMTA,*LPCURRENCYFMTA;
typedef struct _currencyfmtW {
	UINT NumDigits;
	UINT LeadingZero;
	UINT Grouping;
	LPWSTR lpDecimalSep;
	LPWSTR lpThousandSep;
	UINT NegativeOrder;
	UINT PositiveOrder;
	LPWSTR lpCurrencySymbol;
} CURRENCYFMTW,*LPCURRENCYFMTW;
typedef struct tagCURSORSHAPE {
	int xHotSpot;
	int yHotSpot;
	int cx;
	int cy;
	int cbWidth;
	BYTE Planes;
	BYTE BitsPixel;
} CURSORSHAPE,*LPCURSORSHAPE;
typedef struct tagCWPRETSTRUCT {
	LRESULT lResult;
	LPARAM lParam;
	WPARAM wParam;
	DWORD message;
	HWND hwnd;
} CWPRETSTRUCT;
typedef struct tagCWPSTRUCT {
	LPARAM lParam;
	WPARAM wParam;
	UINT message;
	HWND hwnd;
} CWPSTRUCT,*PWCWPSTRUCT;
typedef struct {
	unsigned bAppReturnCode:8,reserved:6,fBusy:1,fAck:1;
} DDEACK;
typedef struct {
	unsigned reserved:14,fDeferUpd:1,fAckReq:1;
	short cfFormat;
} DDEADVISE;
typedef struct {
	unsigned unused:12,fResponse:1,fRelease:1,reserved:1,fAckReq:1;
	short cfFormat;
	BYTE Value[1];
} DDEDATA;
typedef struct {
	unsigned unused:13,fRelease:1,fDeferUpd:1,fAckReq:1;
	short cfFormat;
} DDELN;
typedef struct tagDDEML_MSG_HOOK_DATA {
	UINT uiLo;
	UINT uiHi;
	DWORD cbData;
	DWORD Data[8];
} DDEML_MSG_HOOK_DATA;
typedef struct {
	unsigned unused:13,fRelease:1,fReserved:2;
	short cfFormat;
	BYTE Value[1];
} DDEPOKE;
typedef struct {
	unsigned unused:12,fAck:1,fRelease:1,fReserved:1,fAckReq:1;
	short cfFormat;
	BYTE rgb[1];
} DDEUP;
#ifndef _EXCEPTION_RECORD_DEFINED_
#define _EXCEPTION_RECORD_DEFINED_
typedef struct _EXCEPTION_RECORD {
	DWORD ExceptionCode;
	DWORD ExceptionFlags;
	struct _EXCEPTION_RECORD *ExceptionRecord;
	PVOID ExceptionAddress;
	DWORD NumberParameters;
	DWORD ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD,*PEXCEPTION_RECORD,*LPEXCEPTION_RECORD;
#endif
typedef struct _EXCEPTION_DEBUG_INFO {
	EXCEPTION_RECORD ExceptionRecord;
	DWORD dwFirstChance;
} EXCEPTION_DEBUG_INFO;
typedef struct _EXIT_PROCESS_DEBUG_INFO {
	DWORD dwExitCode;
} EXIT_PROCESS_DEBUG_INFO;
typedef struct _EXIT_THREAD_DEBUG_INFO {
	DWORD dwExitCode;
} EXIT_THREAD_DEBUG_INFO;
typedef struct _LOAD_DLL_DEBUG_INFO {
	HANDLE hFile;
	LPVOID lpBaseOfDll;
	DWORD dwDebugInfoFileOffset;
	DWORD nDebugInfoSize;
	LPVOID lpImageName;
	WORD fUnicode;
} LOAD_DLL_DEBUG_INFO;
typedef struct _UNLOAD_DLL_DEBUG_INFO {
	LPVOID lpBaseOfDll;
} UNLOAD_DLL_DEBUG_INFO;
typedef struct _OUTPUT_DEBUG_STRING_INFO {
	LPSTR lpDebugStringData;
	WORD fUnicode;
	WORD nDebugStringLength;
} OUTPUT_DEBUG_STRING_INFO;
typedef struct _RIP_INFO {
	DWORD dwError;
	DWORD dwType;
} RIP_INFO;
typedef struct _DEBUG_EVENT {
	DWORD dwDebugEventCode;
	DWORD dwProcessId;
	DWORD dwThreadId;
	union {
		EXCEPTION_DEBUG_INFO Exception;
		CREATE_THREAD_DEBUG_INFO CreateThread;
		CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
		EXIT_THREAD_DEBUG_INFO ExitThread;
		EXIT_PROCESS_DEBUG_INFO ExitProcess;
		LOAD_DLL_DEBUG_INFO LoadDll;
		UNLOAD_DLL_DEBUG_INFO UnloadDll;
		OUTPUT_DEBUG_STRING_INFO DebugString;
		RIP_INFO RipInfo;
	} u;
} DEBUG_EVENT,*LPDEBUG_EVENT;
typedef struct tagDEBUGHOOKINFO {
	DWORD idThread;
	DWORD idThreadInstaller;
	LPARAM lParam;
	WPARAM wParam;
	int code;
} DEBUGHOOKINFO;
#ifndef _EXCEPTION_POINTERS_DEFINED_
#define _EXCEPTION_POINTERS_DEFINED_
typedef struct _EXCEPTION_POINTERS {
	PEXCEPTION_RECORD ExceptionRecord;
	PCONTEXT ContextRecord;
} EXCEPTION_POINTERS,*PEXCEPTION_POINTERS,*LPEXCEPTION_POINTERS;
#endif
typedef LONG( * PTOP_LEVEL_EXCEPTION_FILTER) (struct _EXCEPTION_POINTERS * ExceptionInfo);
typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;
typedef struct tagDELETEITEMSTRUCT {
	UINT CtlType;
	UINT CtlID;
	UINT itemID;
	HWND hwndItem;
	UINT itemData;
} DELETEITEMSTRUCT,*LPDELETEITEMSTRUCT,*PDELETEITEMSTRUCT;
typedef struct _DEV_BROADCAST_HDR {
	ULONG dbch_size;
	ULONG dbch_devicetype;
	ULONG dbch_reserved;
} DEV_BROADCAST_HDR;
typedef DEV_BROADCAST_HDR *PDEV_BROADCAST_HDR;
typedef struct _DEV_BROADCAST_OEM {
	ULONG dbco_size;
	ULONG dbco_devicetype;
	ULONG dbco_reserved;
	ULONG dbco_identifier;
	ULONG dbco_suppfunc;
} DEV_BROADCAST_OEM;
typedef DEV_BROADCAST_OEM *PDEV_BROADCAST_OEM;
typedef struct _DEV_BROADCAST_PORT {
	ULONG dbcp_size;
	ULONG dbcp_devicetype;
	ULONG dbcp_reserved;
	char dbcp_name[1];
} DEV_BROADCAST_PORT;
typedef DEV_BROADCAST_PORT *PDEV_BROADCAST_PORT;
struct _DEV_BROADCAST_USERDEFINED {
	struct _DEV_BROADCAST_HDR dbud_dbh;
	char dbud_szName[1];
	BYTE dbud_rgbUserDefined[1];
};
typedef struct _DEV_BROADCAST_VOLUME {
	ULONG dbcv_size;
	ULONG dbcv_devicetype;
	ULONG dbcv_reserved;
	ULONG dbcv_unitmask;
	USHORT dbcv_flags;
} DEV_BROADCAST_VOLUME;
typedef DEV_BROADCAST_VOLUME *PDEV_BROADCAST_VOLUME;
typedef struct _devicemodeA {
	BYTE dmDeviceName[CCHDEVICENAME];
	WORD dmSpecVersion;
	WORD dmDriverVersion;
	WORD dmSize;
	WORD dmDriverExtra;
	DWORD dmFields;
	union {
	struct { short dmOrientation; short dmPaperSize; short dmPaperLength;
		short dmPaperWidth; };
	POINTL dmPosition;
	};
	short dmScale;
	short dmCopies;
	short dmDefaultSource;
	short dmPrintQuality;
	short dmColor;
	short dmDuplex;
	short dmYResolution;
	short dmTTOption;
	short dmCollate;
	BYTE dmFormName[CCHFORMNAME];
	WORD dmLogPixels;
	DWORD dmBitsPerPel;
	DWORD dmPelsWidth;
	DWORD dmPelsHeight;
	DWORD dmDisplayFlags;
	DWORD dmDisplayFrequency;
#if(WINVER >= 0x0400)
	DWORD dmICMMethod;
	DWORD dmICMIntent;
	DWORD dmMediaType;
	DWORD dmDitherType;
	DWORD dmReserved1;
	DWORD dmReserved2;
#if (WINVER >= 0x0500)
	DWORD dmPanningWidth;
	DWORD dmPanningHeight;
#endif
#endif
} DEVMODEA,*PDEVMODEA,*NPDEVMODEA,*LPDEVMODEA;
typedef struct _devicemodeW {
	WCHAR dmDeviceName[CCHDEVICENAME];
	WORD dmSpecVersion;
	WORD dmDriverVersion;
	WORD dmSize;
	WORD dmDriverExtra;
	DWORD dmFields;
	union {
	struct {
	short dmOrientation; short dmPaperSize; short dmPaperLength; short dmPaperWidth; };
	POINTL dmPosition;
	};
	short dmScale;
	short dmCopies;
	short dmDefaultSource;
	short dmPrintQuality;
	short dmColor;
	short dmDuplex;
	short dmYResolution;
	short dmTTOption;
	short dmCollate;
	WCHAR dmFormName[CCHFORMNAME];
	WORD dmLogPixels;
	DWORD dmBitsPerPel;
	DWORD dmPelsWidth;
	DWORD dmPelsHeight;
	DWORD dmDisplayFlags;
	DWORD dmDisplayFrequency;
#if(WINVER >= 0x0400)
	DWORD dmICMMethod;
	DWORD dmICMIntent;
	DWORD dmMediaType;
	DWORD dmDitherType;
	DWORD dmReserved1;
	DWORD dmReserved2;
#if (WINVER >= 0x0500)
	DWORD dmPanningWidth;
	DWORD dmPanningHeight;
#endif
#endif
} DEVMODEW, *PDEVMODEW, *NPDEVMODEW, *LPDEVMODEW;
#ifdef UNICODE
typedef DEVMODEW DEVMODE;
typedef PDEVMODEW PDEVMODE;
typedef NPDEVMODEW NPDEVMODE;
typedef LPDEVMODEW LPDEVMODE;
typedef CURRENCYFMTW CURRENCYFMT;
typedef LPCURRENCYFMTW LPCURRENCYFMT;
#else
typedef DEVMODEA DEVMODE;
typedef PDEVMODEA PDEVMODE;
typedef NPDEVMODEA NPDEVMODE;
typedef LPDEVMODEA LPDEVMODE;
typedef CURRENCYFMTA CURRENCYFMT;
typedef LPCURRENCYFMTA LPCURRENCYFMT;
#endif
typedef struct tagDEVNAMES {
	WORD wDriverOffset;
	WORD wDeviceOffset;
	WORD wOutputOffset;
	WORD wDefault;
} DEVNAMES,*LPDEVNAMES;
typedef struct tagDIBSECTION {
	BITMAP dsBm;
	BITMAPINFOHEADER dsBmih;
	DWORD dsBitfields[3];
	HANDLE dshSection;
	DWORD dsOffset;
} DIBSECTION,*LPDIBSECTION,*PDIBSECTION;
typedef struct {
	DWORD style;
	DWORD dwExtendedStyle;
	short x;
	short y;
	short cx;
	short cy;
	WORD id;
} DLGITEMTEMPLATE,*LPDLGITEMTEMPLATE;
typedef struct {
	DWORD style;
	DWORD dwExtendedStyle;
	WORD cdit;
	short x;
	short y;
	short cx;
	short cy;
} DLGTEMPLATE,*LPDLGTEMPLATE;
typedef const DLGTEMPLATE *LPCDLGTEMPLATE;
typedef struct {
	int cbSize;
	LPCTSTR lpszDocName;
	LPCTSTR lpszOutput;
	LPCTSTR lpszDatatype;
	DWORD fwType;
} DOCINFO;
typedef struct {
	UINT uNotification;
	HWND hWnd;
	POINT ptCursor;
} DRAGLISTINFO,*LPDRAGLISTINFO;
typedef struct tagDRAWITEMSTRUCT {
	UINT CtlType;
	UINT CtlID;
	UINT itemID;
	UINT itemAction;
	UINT itemState;
	HWND hwndItem;
	HDC hDC;
	RECT rcItem;
	DWORD itemData;
} DRAWITEMSTRUCT,*LPDRAWITEMSTRUCT,*PDRAWITEMSTRUCT;
typedef struct {
	UINT cbSize;
	int iTabLength;
	int iLeftMargin;
	int iRightMargin;
	UINT uiLengthDrawn;
} DRAWTEXTPARAMS,*LPDRAWTEXTPARAMS;
typedef struct tagEMR {
	DWORD iType;
	DWORD nSize;
} EMR,*PEMR;
typedef struct tagEMRANGLEARC {
	EMR emr;
	POINTL ptlCenter;
	DWORD nRadius;
	FLOAT eStartAngle;
	FLOAT eSweepAngle;
} EMRANGLEARC,*PEMRANGLEARC;
typedef struct tagEMRARC {
	EMR emr;
	RECTL rclBox;
	POINTL ptlStart;
	POINTL ptlEnd;
} EMRARC,*PEMRARC,
EMRARCTO,*PEMRARCTO,
EMRCHORD,*PEMRCHORD,
EMRPIE,*PEMRPIE;
typedef struct _XFORM {
	FLOAT eM11;
	FLOAT eM12;
	FLOAT eM21;
	FLOAT eM22;
	FLOAT eDx;
	FLOAT eDy;
} XFORM,*PXFORM,*LPXFORM;
typedef struct tagEMRBITBLT {
	EMR emr;
	RECTL rclBounds;
	LONG xDest;
	LONG yDest;
	LONG cxDest;
	LONG cyDest;
	DWORD dwRop;
	LONG xSrc;
	LONG ySrc;
	XFORM xformSrc;
	COLORREF crBkColorSrc;
	DWORD iUsageSrc;
	DWORD offBmiSrc;
	DWORD offBitsSrc;
	DWORD cbBitsSrc;
} EMRBITBLT,*PEMRBITBLT;
typedef struct tagLOGBRUSH {
	UINT lbStyle;
	COLORREF lbColor;
	LONG lbHatch;
} LOGBRUSH,*LPLOGBRUSH;
typedef struct tagLOGBRUSH32 {
	UINT	lbStyle;
	COLORREF	lbColor;
	ULONG	lbHatch;
} LOGBRUSH32, *PLOGBRUSH32, *NPLOGBRUSH32, *LPLOGBRUSH32;
typedef struct tagEMRCREATEBRUSHINDIRECT {
	EMR emr;
	DWORD ihBrush;
	LOGBRUSH lb;
} EMRCREATEBRUSHINDIRECT,*PEMRCREATEBRUSHINDIRECT;
typedef LONG LCSCSTYPE;
typedef LONG LCSGAMUTMATCH;
typedef struct tagLOGCOLORSPACE {
	DWORD lcsSignature;
	DWORD lcsVersion;
	DWORD lcsSize;
	LCSCSTYPE lcsCSType;
	LCSGAMUTMATCH lcsIntent;
	CIEXYZTRIPLE lcsEndpoints;
	DWORD lcsGammaRed;
	DWORD lcsGammaGreen;
	DWORD lcsGammaBlue;
	TCHAR lcsFilename[MAX_PATH];
} LOGCOLORSPACE,*LPLOGCOLORSPACE;
typedef struct tagEMRCREATECOLORSPACE {
	EMR emr;
	DWORD ihCS;
	LOGCOLORSPACE lcs;
} EMRCREATECOLORSPACE,*PEMRCREATECOLORSPACE;
typedef struct tagEMRCREATEDIBPATTERNBRUSHPT {
	EMR emr;
	DWORD ihBrush;
	DWORD iUsage;
	DWORD offBmi;
	DWORD cbBmi;
	DWORD offBits;
	DWORD cbBits;
} EMRCREATEDIBPATTERNBRUSHPT,
PEMRCREATEDIBPATTERNBRUSHPT;
typedef struct tagEMRCREATEMONOBRUSH {
	EMR emr;
	DWORD ihBrush;
	DWORD iUsage;
	DWORD offBmi;
	DWORD cbBmi;
	DWORD offBits;
	DWORD cbBits;
} EMRCREATEMONOBRUSH,*PEMRCREATEMONOBRUSH;
typedef struct tagPALETTEENTRY {
	BYTE peRed;
	BYTE peGreen;
	BYTE peBlue;
	BYTE peFlags;
} PALETTEENTRY,*LPPALETTEENTRY,*PPALETTEENTRY;
typedef struct tagLOGPALETTE {
	WORD palVersion;
	WORD palNumEntries;
	PALETTEENTRY palPalEntry[1];
} LOGPALETTE,*PLOGPALETTE;
typedef LOGPALETTE *LPLOGPALETTE;
typedef struct tagEMRCREATEPALETTE {
	EMR emr;
	DWORD ihPal;
	LOGPALETTE lgpl;
} EMRCREATEPALETTE,*PEMRCREATEPALETTE;
typedef struct tagLOGPEN {
	UINT lopnStyle;
	POINT lopnWidth;
	COLORREF lopnColor;
} LOGPEN,*LPLOGPEN;
typedef struct tagEMRCREATEPEN {
	EMR emr;
	DWORD ihPen;
	LOGPEN lopn;
} EMRCREATEPEN,*PEMRCREATEPEN;
typedef struct tagEMRELLIPSE {
	EMR emr;
	RECTL rclBox;
} EMRELLIPSE,*PEMRELLIPSE,
EMRRECTANGLE,*PEMRRECTANGLE;
typedef struct tagEMREOF {
	EMR emr;
	DWORD nPalEntries;
	DWORD offPalEntries;
	DWORD nSizeLast;
} EMREOF,*PEMREOF;
typedef struct tagEMREXCLUDECLIPRECT {
	EMR emr;
	RECTL rclClip;
} EMREXCLUDECLIPRECT,*PEMREXCLUDECLIPRECT,
EMRINTERSECTCLIPRECT,*PEMRINTERSECTCLIPRECT;
typedef struct tagPANOSE {
	BYTE bFamilyType;
	BYTE bSerifStyle;
	BYTE bWeight;
	BYTE bProportion;
	BYTE bContrast;
	BYTE bStrokeVariation;
	BYTE bArmStyle;
	BYTE bLetterform;
	BYTE bMidline;
	BYTE bXHeight;
} PANOSE,*LPPANOSE;
typedef struct tagEXTLOGFONT {
	LOGFONT elfLogFont;
	BCHAR elfFullName[LF_FULLFACESIZE];
	BCHAR elfStyle[LF_FACESIZE];
	DWORD elfVersion;
	DWORD elfStyleSize;
	DWORD elfMatch;
	DWORD elfReserved;
	BYTE elfVendorId[ELF_VENDOR_SIZE];
	DWORD elfCulture;
	PANOSE elfPanose;
} EXTLOGFONT,*LPEXTLOGFONT;
typedef struct tagEMREXTCREATEFONTINDIRECTW {
	EMR emr;
	DWORD ihFont;
	EXTLOGFONT elfw;
} EMREXTCREATEFONTINDIRECTW, *PEMREXTCREATEFONTINDIRECTW;
typedef struct tagEXTLOGPEN {
	UINT elpPenStyle;
	UINT elpWidth;
	UINT elpBrushStyle;
	COLORREF elpColor;
	LONG elpHatch;
	DWORD elpNumEntries;
	DWORD elpStyleEntry[1];
} EXTLOGPEN,*LPEXTLOGPEN,*NPEXTLOGPEN;
typedef struct tagEMREXTCREATEPEN {
	EMR emr;
	DWORD ihPen;
	DWORD offBmi;
	DWORD cbBmi;
	DWORD offBits;
	DWORD cbBits;
	EXTLOGPEN elp;
} EMREXTCREATEPEN,*PEMREXTCREATEPEN;
typedef struct tagEMREXTFLOODFILL {
	EMR emr;
	POINTL ptlStart;
	COLORREF crColor;
	DWORD iMode;
} EMREXTFLOODFILL,*PEMREXTFLOODFILL;
typedef struct tagEMREXTSELECTCLIPRGN {
	EMR emr;
	DWORD cbRgnData;
	DWORD iMode;
	BYTE RgnData[1];
} EMREXTSELECTCLIPRGN,*PEMREXTSELECTCLIPRGN;
typedef struct tagEMRTEXT {
	POINTL ptlReference;
	DWORD nChars;
	DWORD offString;
	DWORD fOptions;
	RECTL rcl;
	DWORD offDx;
} EMRTEXT,*PEMRTEXT;
typedef struct tagEMREXTTEXTOUTA {
	EMR emr;
	RECTL rclBounds;
	DWORD iGraphicsMode;
	FLOAT exScale;
	FLOAT eyScale;
	EMRTEXT emrtext;
} EMREXTTEXTOUTA,*PEMREXTTEXTOUTA,
EMREXTTEXTOUTW,*PEMREXTTEXTOUTW;
typedef struct tagEMRFILLPATH {
	EMR emr;
	RECTL rclBounds;
} EMRFILLPATH,*PEMRFILLPATH,
EMRSTROKEANDFILLPATH,*PEMRSTROKEANDFILLPATH,
EMRSTROKEPATH,*PEMRSTROKEPATH;
typedef struct tagEMRFILLRGN {
	EMR emr;
	RECTL rclBounds;
	DWORD cbRgnData;
	DWORD ihBrush;
	BYTE RgnData[1];
} EMRFILLRGN,*PEMRFILLRGN;
typedef struct tagEMRFORMAT {
	DWORD dSignature;
	DWORD nVersion;
	DWORD cbData;
	DWORD offData;
} EMRFORMAT;
typedef struct tagSIZE {
	LONG cx;
	LONG cy;
} SIZE,*PSIZE,*LPSIZE,SIZEL,*PSIZEL,*LPSIZEL;
typedef struct tagEMRFRAMERGN {
	EMR emr;
	RECTL rclBounds;
	DWORD cbRgnData;
	DWORD ihBrush;
	SIZEL szlStroke;
	BYTE RgnData[1];
} EMRFRAMERGN,*PEMRFRAMERGN;
typedef struct tagEMRGDICOMMENT {
	EMR emr;
	DWORD cbData;
	BYTE Data[1];
} EMRGDICOMMENT,*PEMRGDICOMMENT;
typedef struct tagEMRINVERTRGN {
	EMR emr;
	RECTL rclBounds;
	DWORD cbRgnData;
	BYTE RgnData[1];
} EMRINVERTRGN,*PEMRINVERTRGN,
EMRPAINTRGN,*PEMRPAINTRGN;
typedef struct tagEMRLINETO {
	EMR emr;
	POINTL ptl;
} EMRLINETO,*PEMRLINETO,
EMRMOVETOEX,*PEMRMOVETOEX;
typedef struct tagEMRMASKBLT {
	EMR emr;
	RECTL rclBounds;
	LONG xDest;
	LONG yDest;
	LONG cxDest;
	LONG cyDest;
	DWORD dwRop;
	LONG xSrc;
	LONG ySrc;
	XFORM xformSrc;
	COLORREF crBkColorSrc;
	DWORD iUsageSrc;
	DWORD offBmiSrc;
	DWORD cbBmiSrc;
	DWORD offBitsSrc;
	DWORD cbBitsSrc;
	LONG xMask;
	LONG yMask;
	DWORD iUsageMask;
	DWORD offBmiMask;
	DWORD cbBmiMask;
	DWORD offBitsMask;
	DWORD cbBitsMask;
} EMRMASKBLT,*PEMRMASKBLT;
typedef struct tagEMRMODIFYWORLDTRANSFORM {
	EMR emr;
	XFORM xform;
	DWORD iMode;
} EMRMODIFYWORLDTRANSFORM,
PEMRMODIFYWORLDTRANSFORM;
typedef struct tagEMROFFSETCLIPRGN {
	EMR emr;
	POINTL ptlOffset;
} EMROFFSETCLIPRGN,*PEMROFFSETCLIPRGN;
typedef struct tagEMRPLGBLT {
	EMR emr;
	RECTL rclBounds;
	POINTL aptlDest[3];
	LONG xSrc;
	LONG ySrc;
	LONG cxSrc;
	LONG cySrc;
	XFORM xformSrc;
	COLORREF crBkColorSrc;
	DWORD iUsageSrc;
	DWORD offBmiSrc;
	DWORD cbBmiSrc;
	DWORD offBitsSrc;
	DWORD cbBitsSrc;
	LONG xMask;
	LONG yMask;
	DWORD iUsageMask;
	DWORD offBmiMask;
	DWORD cbBmiMask;
	DWORD offBitsMask;
	DWORD cbBitsMask;
} EMRPLGBLT,*PEMRPLGBLT;
typedef struct tagEMRPOLYDRAW {
	EMR emr;
	RECTL rclBounds;
	DWORD cptl;
	POINTL aptl[1];
	BYTE abTypes[1];
} EMRPOLYDRAW,*PEMRPOLYDRAW;
typedef struct tagEMRPOLYDRAW16 {
	EMR emr;
	RECTL rclBounds;
	DWORD cpts;
	POINTS apts[1];
	BYTE abTypes[1];
} EMRPOLYDRAW16,*PEMRPOLYDRAW16;
typedef struct tagEMRPOLYLINE {
	EMR emr;
	RECTL rclBounds;
	DWORD cptl;
	POINTL aptl[1];
} EMRPOLYLINE,*PEMRPOLYLINE,
EMRPOLYBEZIER,*PEMRPOLYBEZIER,
EMRPOLYGON,*PEMRPOLYGON,
EMRPOLYBEZIERTO,*PEMRPOLYBEZIERTO,
EMRPOLYLINETO,*PEMRPOLYLINETO;
typedef struct tagEMRPOLYLINE16 {
	EMR emr;
	RECTL rclBounds;
	DWORD cpts;
	POINTL apts[1];
} EMRPOLYLINE16,*PEMRPOLYLINE16,
EMRPOLYBEZIER16,*PEMRPOLYBEZIER16,
EMRPOLYGON16,*PEMRPOLYGON16,
EMRPOLYBEZIERTO16,*PEMRPOLYBEZIERTO16,
EMRPOLYLINETO16,*PEMRPOLYLINETO16;
typedef struct tagEMRPOLYPOLYLINE {
	EMR emr;
	RECTL rclBounds;
	DWORD nPolys;
	DWORD cptl;
	DWORD aPolyCounts[1];
	POINTL aptl[1];
} EMRPOLYPOLYLINE,*PEMRPOLYPOLYLINE,
EMRPOLYPOLYGON,*PEMRPOLYPOLYGON;
typedef struct tagEMRPOLYPOLYLINE16 {
	EMR emr;
	RECTL rclBounds;
	DWORD nPolys;
	DWORD cpts;
	DWORD aPolyCounts[1];
	POINTS apts[1];
} EMRPOLYPOLYLINE16,*PEMRPOLYPOLYLINE16,
EMRPOLYPOLYGON16,*PEMRPOLYPOLYGON16;
typedef struct tagEMRPOLYTEXTOUTA {
	EMR emr;
	RECTL rclBounds;
	DWORD iGraphicsMode;
	FLOAT exScale;
	FLOAT eyScale;
	LONG cStrings;
	EMRTEXT aemrtext[1];
} EMRPOLYTEXTOUTA,*PEMRPOLYTEXTOUTA,
EMRPOLYTEXTOUTW,*PEMRPOLYTEXTOUTW;
typedef struct tagEMRRESIZEPALETTE {
	EMR emr;
	DWORD ihPal;
	DWORD cEntries;
} EMRRESIZEPALETTE,*PEMRRESIZEPALETTE;
typedef struct tagEMRRESTOREDC {
	EMR emr;
	LONG iRelative;
} EMRRESTOREDC,*PEMRRESTOREDC;
typedef struct tagEMRROUNDRECT {
	EMR emr;
	RECTL rclBox;
	SIZEL szlCorner;
} EMRROUNDRECT,*PEMRROUNDRECT;
typedef struct tagEMRSCALEVIEWPORTEXTEX {
	EMR emr;
	LONG xNum;
	LONG xDenom;
	LONG yNum;
	LONG yDenom;
} EMRSCALEVIEWPORTEXTEX,*PEMRSCALEVIEWPORTEXTEX,
EMRSCALEWINDOWEXTEX,*PEMRSCALEWINDOWEXTEX;
typedef struct tagEMRSELECTCOLORSPACE {
	EMR emr;
	DWORD ihCS;
} EMRSELECTCOLORSPACE,*PEMRSELECTCOLORSPACE,
EMRDELETECOLORSPACE,*PEMRDELETECOLORSPACE;
typedef struct tagEMRSELECTOBJECT {
	EMR emr;
	DWORD ihObject;
} EMRSELECTOBJECT,*PEMRSELECTOBJECT,
EMRDELETEOBJECT,*PEMRDELETEOBJECT;
typedef struct tagEMRSELECTPALETTE {
	EMR emr;
	DWORD ihPal;
} EMRSELECTPALETTE,*PEMRSELECTPALETTE;
typedef struct tagEMRSETARCDIRECTION {
	EMR emr;
	DWORD iArcDirection;
} EMRSETARCDIRECTION,*PEMRSETARCDIRECTION;
typedef struct tagEMRSETTEXTCOLOR {
	EMR emr;
	COLORREF crColor;
} EMRSETBKCOLOR,*PEMRSETBKCOLOR,
EMRSETTEXTCOLOR,*PEMRSETTEXTCOLOR;
typedef struct tagEMRSETCOLORADJUSTMENT {
	EMR emr;
	COLORADJUSTMENT ColorAdjustment;
} EMRSETCOLORADJUSTMENT,*PEMRSETCOLORADJUSTMENT;
typedef struct tagEMRSETDIBITSTODEVICE {
	EMR emr;
	RECTL rclBounds;
	LONG xDest;
	LONG yDest;
	LONG xSrc;
	LONG ySrc;
	LONG cxSrc;
	LONG cySrc;
	DWORD offBmiSrc;
	DWORD cbBmiSrc;
	DWORD offBitsSrc;
	DWORD cbBitsSrc;
	DWORD iUsageSrc;
	DWORD iStartScan;
	DWORD cScans;
} EMRSETDIBITSTODEVICE,*PEMRSETDIBITSTODEVICE;
typedef struct tagEMRSETMAPPERFLAGS {
	EMR emr;
	DWORD dwFlags;
} EMRSETMAPPERFLAGS,*PEMRSETMAPPERFLAGS;
typedef struct tagEMRSETMITERLIMIT {
	EMR emr;
	FLOAT eMiterLimit;
} EMRSETMITERLIMIT,*PEMRSETMITERLIMIT;
typedef struct tagEMRSETPALETTEENTRIES {
	EMR emr;
	DWORD ihPal;
	DWORD iStart;
	DWORD cEntries;
	PALETTEENTRY aPalEntries[1];
} EMRSETPALETTEENTRIES,*PEMRSETPALETTEENTRIES;
typedef struct tagEMRSETPIXELV {
	EMR emr;
	POINTL ptlPixel;
	COLORREF crColor;
} EMRSETPIXELV,*PEMRSETPIXELV;
typedef struct tagEMRSETVIEWPORTEXTEX {
	EMR emr;
	SIZEL szlExtent;
} EMRSETVIEWPORTEXTEX,*PEMRSETVIEWPORTEXTEX,
EMRSETWINDOWEXTEX,*PEMRSETWINDOWEXTEX;
typedef struct tagEMRSETVIEWPORTORGEX {
	EMR emr;
	POINTL ptlOrigin;
} EMRSETVIEWPORTORGEX,*PEMRSETVIEWPORTORGEX,
EMRSETWINDOWORGEX,*PEMRSETWINDOWORGEX,
EMRSETBRUSHORGEX,*PEMRSETBRUSHORGEX;
typedef struct tagEMRSETWORLDTRANSFORM {
	EMR emr;
	XFORM xform;
} EMRSETWORLDTRANSFORM,*PEMRSETWORLDTRANSFORM;
typedef struct tagEMRSTRETCHBLT {
	EMR emr;
	RECTL rclBounds;
	LONG xDest;
	LONG yDest;
	LONG cxDest;
	LONG cyDest;
	DWORD dwRop;
	LONG xSrc;
	LONG ySrc;
	XFORM xformSrc;
	COLORREF crBkColorSrc;
	DWORD iUsageSrc;
	DWORD offBmiSrc;
	DWORD cbBmiSrc;
	DWORD offBitsSrc;
	DWORD cbBitsSrc;
	LONG cxSrc;
	LONG cySrc;
} EMRSTRETCHBLT,*PEMRSTRETCHBLT;
typedef struct tagEMRSTRETCHDIBITS {
	EMR emr;
	RECTL rclBounds;
	LONG xDest;
	LONG yDest;
	LONG xSrc;
	LONG ySrc;
	LONG cxSrc;
	LONG cySrc;
	DWORD offBmiSrc;
	DWORD cbBmiSrc;
	DWORD offBitsSrc;
	DWORD cbBitsSrc;
	DWORD iUsageSrc;
	DWORD dwRop;
	LONG cxDest;
	LONG cyDest;
} EMRSTRETCHDIBITS,*PEMRSTRETCHDIBITS;
typedef struct tagABORTPATH {
	EMR emr;
} EMRABORTPATH,*PEMRABORTPATH,
EMRBEGINPATH,*PEMRBEGINPATH,
EMRENDPATH,*PEMRENDPATH,
EMRCLOSEFIGURE,*PEMRCLOSEFIGURE,
EMRFLATTENPATH,*PEMRFLATTENPATH,
EMRWIDENPATH,*PEMRWIDENPATH,
EMRSETMETARGN,*PEMRSETMETARGN,
EMRSAVEDC,*PEMRSAVEDC,
EMRREALIZEPALETTE,*PEMRREALIZEPALETTE;
typedef struct tagEMRSELECTCLIPPATH {
	EMR emr;
	DWORD iMode;
} EMRSELECTCLIPPATH,*PEMRSELECTCLIPPATH,
EMRSETBKMODE,*PEMRSETBKMODE,
EMRSETMAPMODE,*PEMRSETMAPMODE,
EMRSETPOLYFILLMODE,*PEMRSETPOLYFILLMODE,
EMRSETROP2,*PEMRSETROP2,
EMRSETSTRETCHBLTMODE,*PEMRSETSTRETCHBLTMODE,
EMRSETTEXTALIGN,*PEMRSETTEXTALIGN,
EMRENABLEICM,*PEMRENABLEICM;
typedef struct tagNMHDR {
	HWND hwndFrom;
	UINT idFrom;
	UINT code;
} NMHDR;
typedef struct tagNMIPADDRESS { NMHDR hdr; int iField; int iValue; } NMIPADDRESS, *LPNMIPADDRESS;
typedef NMHDR *LPNMHDR;
typedef struct tagENHMETAHEADER {
	DWORD iType;
	DWORD nSize;
	RECTL rclBounds;
	RECTL rclFrame;
	DWORD dSignature;
	DWORD nVersion;
	DWORD nBytes;
	DWORD nRecords;
	WORD nHandles;
	WORD sReserved;
	DWORD nDescription;
	DWORD offDescription;
	DWORD nPalEntries;
	SIZEL szlDevice;
	SIZEL szlMillimeters;
} ENHMETAHEADER,*LPENHMETAHEADER;
typedef struct tagENHMETARECORD {
	DWORD iType;
	DWORD nSize;
	DWORD dParm[1];
} ENHMETARECORD,*LPENHMETARECORD;
typedef struct tagENUMLOGFONT {
	LOGFONT elfLogFont;
	BCHAR elfFullName[LF_FULLFACESIZE];
	BCHAR elfStyle[LF_FACESIZE];
} ENUMLOGFONT;
typedef struct tagENUMLOGFONTEX {
	LOGFONT elfLogFont;
	BCHAR elfFullName[LF_FULLFACESIZE];
	BCHAR elfStyle[LF_FACESIZE];
	BCHAR elfScript[LF_FACESIZE];
} ENUMLOGFONTEX;
typedef struct _EVENTLOGRECORD {
	DWORD Length;
	DWORD Reserved;
	DWORD RecordNumber;
	DWORD TimeGenerated;
	DWORD TimeWritten;
	DWORD EventID;
	WORD EventType;
	WORD NumStrings;
	WORD EventCategory;
	WORD ReservedFlags;
	DWORD ClosingRecordNumber;
	DWORD StringOffset;
	DWORD UserSidLength;
	DWORD UserSidOffset;
	DWORD DataLength;
	DWORD DataOffset;
} EVENTLOGRECORD;
typedef struct tagEVENTMSG {
	UINT message;
	UINT paramL;
	UINT paramH;
	DWORD time;
	HWND hwnd;
} EVENTMSG;
typedef PVOID PACCESS_TOKEN;
typedef ACCESS_MASK *PACCESS_MASK;
typedef struct _EXT_BUTTON {
	WORD idCommand;
	WORD idsHelp;
	WORD fsStyle;
} EXT_BUTTON,*LPEXT_BUTTON;
typedef struct tagFILTERKEYS {
	UINT cbSize;
	DWORD dwFlags;
	DWORD iWaitMSec;
	DWORD iDelayMSec;
	DWORD iRepeatMSec;
	DWORD iBounceMSec;
} FILTERKEYS;
typedef struct _FIND_NAME_BUFFER {
	UCHAR length;
	UCHAR access_control;
	UCHAR frame_control;
	UCHAR destination_addr[6];
	UCHAR source_addr[6];
	UCHAR routing_info[18];
} FIND_NAME_BUFFER;
typedef struct _FIND_NAME_HEADER {
	WORD node_count;
	UCHAR reserved;
	UCHAR unique_group;
} FIND_NAME_HEADER;
typedef struct {
	DWORD lStructSize;
	HWND hwndOwner;
	HINSTANCE hInstance;
	DWORD Flags;
	LPTSTR lpstrFindWhat;
	LPTSTR lpstrReplaceWith;
	WORD wFindWhatLen;
	WORD wReplaceWithLen;
	LPARAM lCustData;
	LPFRHOOKPROC lpfnHook;
	LPCTSTR lpTemplateName;
} FINDREPLACE,*LPFINDREPLACE;
#ifndef __FINDTEXT_DEFINED
#define __FINDTEXT_DEFINED
typedef struct _findtext {
	CHARRANGE chrg;
	LPCSTR lpstrText;
} FINDTEXT;
#endif
typedef struct _findtextex {
	CHARRANGE chrg;
	LPSTR lpstrText;
	CHARRANGE chrgText;
} FINDTEXTEX;
typedef struct _FMS_GETDRIVEINFO {
	DWORD dwTotalSpace;
	DWORD dwFreeSpace;
	TCHAR szPath[260];
	TCHAR szVolume[14];
	TCHAR szShare[128];
} FMS_GETDRIVEINFO;
typedef struct _FMS_GETFILESEL {
	FILETIME ftTime;
	DWORD dwSize;
	BYTE bAttr;
	TCHAR szName[260];
} FMS_GETFILESEL;
typedef struct _FMS_LOAD {
	DWORD dwSize;
	TCHAR szMenuName[MENU_TEXT_LEN];
	HMENU hMenu;
	UINT wMenuDelta;
} FMS_LOAD;
typedef struct _FMS_TOOLBARLOAD {
	DWORD dwSize;
	LPEXT_BUTTON lpButtons;
	WORD cButtons;
	WORD cBitmaps;
	WORD idBitmap;
	HBITMAP hBitmap;
} FMS_TOOLBARLOAD;
typedef struct _FOCUS_EVENT_RECORD {
	BOOL bSetFocus;
} FOCUS_EVENT_RECORD;
typedef struct tagGCP_RESULTS {
	DWORD lStructSize;
	LPTSTR lpOutString;
	UINT *lpOrder;
	INT *lpDx;
	INT *lpCaretPos;
	LPTSTR lpClass;
	UINT *lpGlyphs;
	UINT nGlyphs;
	UINT nMaxFit;
} GCP_RESULTS,*LPGCP_RESULTS;
typedef struct _GENERIC_MAPPING {
	ACCESS_MASK GenericRead;
	ACCESS_MASK GenericWrite;
	ACCESS_MASK GenericExecute;
	ACCESS_MASK GenericAll;
} GENERIC_MAPPING,*PGENERIC_MAPPING;
typedef struct _GLYPHMETRICS {
	UINT gmBlackBoxX;
	UINT gmBlackBoxY;
	POINT gmptGlyphOrigin;
	short gmCellIncX;
	short gmCellIncY;
} GLYPHMETRICS,*LPGLYPHMETRICS;
typedef struct tagHANDLETABLE {
	HGDIOBJ objectHandle[1];
} HANDLETABLE,*LPHANDLETABLE;
typedef struct _HD_HITTESTINFO {
	POINT pt;
	UINT flags;
	int iItem;
} HD_HITTESTINFO,*LPHDHITTESTINFO;
#define HDHITTESTINFO	HD_HITTESTINFO
typedef struct _HD_ITEM {
	UINT mask;
	int cxy;
	LPTSTR pszText;
	HBITMAP hbm;
	int cchTextMax;
	int fmt;
	LPARAM lParam;
} HD_ITEM;
typedef struct _WINDOWPOS {
	HWND hwnd;
	HWND hwndInsertAfter;
	int x;
	int y;
	int cx;
	int cy;
	UINT flags;
} WINDOWPOS,*PWINDOWPOS,*LPWINDOWPOS;
typedef struct _HD_LAYOUT {
	RECT *prc;
	WINDOWPOS *pwpos;
} HD_LAYOUT,*LPHDLAYOUT;
#define HDLAYOUT HD_LAYOUT
typedef struct _HD_NOTIFY {
	NMHDR hdr;
	int iItem;
	int iButton;
	HD_ITEM *pitem;
} HD_NOTIFY;
typedef struct _HD_ITEMA {
	UINT	mask;
	int	cxy;
	LPSTR	pszText;
	HBITMAP hbm;
	int	cchTextMax;
	int	fmt;
	LPARAM lParam;
	int	iImage;
	int	iOrder;
	UINT	type;
	LPVOID	pvFilter;
} HDITEMA, *LPHDITEMA;
#define HDITEMA_V1_SIZE CCSIZEOF_STRUCT(HDITEMA, lParam)
#define HDITEMW_V1_SIZE CCSIZEOF_STRUCT(HDITEMW, lParam)
typedef struct _HD_ITEMW {
	UINT	mask;
	int	cxy;
	LPWSTR	pszText;
	HBITMAP hbm;
	int	cchTextMax;
	int	fmt;
	LPARAM lParam;
	int	iImage;
	int	iOrder;
	UINT	type;
	LPVOID pvFilter;
} HDITEMW, *LPHDITEMW;
#ifdef UNICODE
#define HDITEM HDITEMW
#define LPHDITEM LPHDITEMW
#define HDITEM_V1_SIZE HDITEMW_V1_SIZE
#else
#define HDITEM HDITEMA
#define LPHDITEM LPHDITEMA
#define HDITEM_V1_SIZE HDITEMA_V1_SIZE
#endif
typedef struct tagNMHEADERA {
	NMHDR	hdr;
	int	iItem;
	int	iButton;
	HDITEMA *pitem;
} NMHEADERA,* LPNMHEADERA;
typedef struct tagNMHEADERW {
	NMHDR	hdr;
	int	iItem;
	int	iButton;
	HDITEMW *pitem;
} NMHEADERW,*LPNMHEADERW;
#ifdef UNICODE
#define NMHEADER	NMHEADERW
#define LPNMHEADER	LPNMHEADERW
#else
#define NMHEADER	NMHEADERA
#define LPNMHEADER	LPNMHEADERA
#endif
typedef struct tagHELPINFO {
	UINT cbSize;
	int iContextType;
	int iCtrlId;
	HANDLE hItemHandle;
	DWORD dwContextId;
	POINT MousePos;
} HELPINFO,*LPHELPINFO;
typedef struct {
	int wStructSize;
	int x;
	int y;
	int dx;
	int dy;
	int wMax;
	TCHAR rgchMember[2];
} HELPWININFO;
typedef struct tagHIGHCONTRAST {
	UINT cbSize;
	DWORD dwFlags;
	LPTSTR lpszDefaultScheme;
} HIGHCONTRAST,*LPHIGHCONTRAST;
typedef struct tagHSZPAIR {
	HSZ hszSvc;
	HSZ hszTopic;
} HSZPAIR;
typedef struct _ICONINFO {
	BOOL fIcon;
	DWORD xHotspot;
	DWORD yHotspot;
	HBITMAP hbmMask;
	HBITMAP hbmColor;
} ICONINFO,*PICONINFO;
typedef struct tagICONMETRICS {
	UINT cbSize;
	int iHorzSpacing;
	int iVertSpacing;
	int iTitleWrap;
	LOGFONT lfFont;
} ICONMETRICS,*LPICONMETRICS;
typedef struct _IMAGEINFO {
	HBITMAP hbmImage;
	HBITMAP hbmMask;
	int Unused1;
	int Unused2;
	RECT rcImage;
} IMAGEINFO;
typedef struct _KEY_EVENT_RECORD {
	BOOL bKeyDown;
	WORD wRepeatCount;
	WORD wVirtualKeyCode;
	WORD wVirtualScanCode;
	union { WCHAR UnicodeChar; CHAR AsciiChar; } uChar;
	DWORD dwControlKeyState;
} KEY_EVENT_RECORD;
typedef struct _MOUSE_EVENT_RECORD {
	COORD dwMousePosition;
	DWORD dwButtonState;
	DWORD dwControlKeyState;
	DWORD dwEventFlags;
} MOUSE_EVENT_RECORD;
typedef struct _WINDOW_BUFFER_SIZE_RECORD {
	COORD dwSize;
} WINDOW_BUFFER_SIZE_RECORD;
typedef struct _MENU_EVENT_RECORD {
	UINT dwCommandId;
} MENU_EVENT_RECORD,*PMENU_EVENT_RECORD;
typedef struct _INPUT_RECORD {
	WORD EventType;
	WORD __alignmentDummy;
	union {
		KEY_EVENT_RECORD KeyEvent;
		MOUSE_EVENT_RECORD MouseEvent;
		WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
		MENU_EVENT_RECORD MenuEvent;
		FOCUS_EVENT_RECORD FocusEvent;
	} Event;
} INPUT_RECORD,*PINPUT_RECORD;
typedef struct _SYSTEMTIME {
	WORD wYear;
	WORD wMonth;
	WORD wDayOfWeek;
	WORD wDay;
	WORD wHour;
	WORD wMinute;
	WORD wSecond;
	WORD wMilliseconds;
} SYSTEMTIME,*LPSYSTEMTIME,*PSYSTEMTIME;
typedef struct _SID_IDENTIFIER_AUTHORITY {
	BYTE Value[6];
} SID_IDENTIFIER_AUTHORITY,*PSID_IDENTIFIER_AUTHORITY,
*LPSID_IDENTIFIER_AUTHORITY;
typedef struct _SID {
	BYTE Revision;
	BYTE SubAuthorityCount;
	SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
	DWORD SubAuthority[ANYSIZE_ARRAY];
} SID,*PSID;
#define SID_REVISION              (1)
#define SID_MAX_SUB_AUTHORITIES       (15)
#define SID_RECOMMENDED_SUB_AUTHORITIES (1)
#define SECURITY_MAX_SID_SIZE (sizeof(SID) - sizeof(DWORD) + (SID_MAX_SUB_AUTHORITIES * sizeof(DWORD)))
typedef WORD SECURITY_DESCRIPTOR_CONTROL,*PSECURITY_DESCRIPTOR_CONTROL;
typedef struct _SECURITY_DESCRIPTOR_RELATIVE {
	BYTE Revision;
	BYTE Sbz1;
	SECURITY_DESCRIPTOR_CONTROL Control;
	DWORD Owner;
	DWORD Group;
	DWORD Sacl;
	DWORD Dacl;
} SECURITY_DESCRIPTOR_RELATIVE, *PISECURITY_DESCRIPTOR_RELATIVE;
typedef struct _SECURITY_DESCRIPTOR {
	BYTE Revision;
	BYTE Sbz1;
	SECURITY_DESCRIPTOR_CONTROL Control;
	PSID Owner;
	PSID Group;
	PACL Sacl;
	PACL Dacl;
} SECURITY_DESCRIPTOR,*PSECURITY_DESCRIPTOR;
typedef struct tagKERNINGPAIR {
	WORD wFirst;
	WORD wSecond;
	int iKernAmount;
} KERNINGPAIR,*LPKERNINGPAIR;
typedef struct _LANA_ENUM {
	UCHAR length;
	UCHAR lana[MAX_LANA];
} LANA_ENUM;
typedef struct _LDT_ENTRY {
	WORD LimitLow;
	WORD BaseLow;
	union {
		struct {
			BYTE BaseMid;
			BYTE Flags1;
			BYTE Flags2;
			BYTE BaseHi;
		} Bytes;
		struct {
			unsigned BaseMid:8;
			unsigned Type:5;
			unsigned Dpl:2;
			unsigned Pres:1;
			unsigned LimitHi:4;
			unsigned Sys:1;
			unsigned Reserved_0:1;
			unsigned Default_Big:1;
			unsigned Granularity:1;
			unsigned BaseHi:8;
		} Bits;
	} HighWord;
} LDT_ENTRY,*PLDT_ENTRY,*LPLDT_ENTRY;
typedef struct tagLOCALESIGNATURE {
	DWORD lsUsb[4];
	DWORD lsCsbDefault[2];
	DWORD lsCsbSupported[2];
} LOCALESIGNATURE;
typedef long FXPT16DOT16,*LPFXPT16DOT16;
typedef LARGE_INTEGER LUID,*PLUID;
typedef struct _LUID_AND_ATTRIBUTES {
	LUID Luid;
	DWORD Attributes;
} LUID_AND_ATTRIBUTES,*PLUID_AND_ATTRIBUTES;
typedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[ANYSIZE_ARRAY];
typedef LUID_AND_ATTRIBUTES_ARRAY *PLUID_AND_ATTRIBUTES_ARRAY;
typedef struct _LV_COLUMN {
	UINT mask;
	int fmt;
	int cx;
	LPTSTR pszText;
	int cchTextMax;
	int iSubItem;
} LV_COLUMN;
typedef struct _LV_ITEM {
	UINT mask;
	int iItem;
	int iSubItem;
	UINT state;
	UINT stateMask;
	LPTSTR pszText;
	int cchTextMax;
	int iImage;
	LPARAM lParam;
} LV_ITEM;
typedef struct tagLV_DISPINFO {
	NMHDR hdr;
	LV_ITEM item;
} LV_DISPINFO;
typedef struct _LV_FINDINFO {
	UINT flags;
	LPCTSTR psz;
	LPARAM lParam;
	POINT pt;
	UINT vkDirection;
} LV_FINDINFO;
typedef struct _LV_HITTESTINFO {
	POINT pt;
	UINT flags;
	int iItem;
} LV_HITTESTINFO;
typedef struct tagLV_KEYDOWN {
	NMHDR hdr;
	WORD wVKey;
	UINT flags;
} LV_KEYDOWN;
typedef struct _MAT2 {
	FIXED eM11;
	FIXED eM12;
	FIXED eM21;
	FIXED eM22;
} MAT2;
typedef struct tagMDICREATESTRUCT {
	LPCTSTR szClass;
	LPCTSTR szTitle;
	HANDLE hOwner;
	int x;
	int y;
	int cx;
	int cy;
	DWORD style;
	LPARAM lParam;
} MDICREATESTRUCT;
typedef MDICREATESTRUCT *LPMDICREATESTRUCT;
typedef struct tagMEASUREITEMSTRUCT {
	UINT CtlType;
	UINT CtlID;
	UINT itemID;
	UINT itemWidth;
	UINT itemHeight;
	DWORD itemData;
} MEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT *LPMEASUREITEMSTRUCT,*PMEASUREITEMSTRUCT;
typedef struct _MEMORY_BASIC_INFORMATION {
	PVOID BaseAddress;
	PVOID AllocationBase;
	DWORD AllocationProtect;
	DWORD RegionSize;
	DWORD State;
	DWORD Protect;
	DWORD Type;
} MEMORY_BASIC_INFORMATION;
typedef MEMORY_BASIC_INFORMATION *PMEMORY_BASIC_INFORMATION;
typedef struct _MEMORYSTATUS {
	DWORD dwLength;
	DWORD dwMemoryLoad;
	DWORD dwTotalPhys;
	DWORD dwAvailPhys;
	DWORD dwTotalPageFile;
	DWORD dwAvailPageFile;
	DWORD dwTotalVirtual;
	DWORD dwAvailVirtual;
} MEMORYSTATUS,*LPMEMORYSTATUS;
typedef struct _MEMORYSTATUSEX {
	DWORD dwLength;
	DWORD dwMemoryLoad;
	long long ullTotalPhys;
	long long ullAvailPhys;
	long long ullTotalPageFile;
	long long ullAvailPageFile;
	long long ullTotalVirtual;
	long long ullAvailVirtual;
	long long ullAvailExtendedVirtual;
} MEMORYSTATUSEX, *LPMEMORYSTATUSEX;
typedef struct {
	WORD wVersion;
	WORD wOffset;
	DWORD dwHelpId;
} MENUEX_TEMPLATE_HEADER;
typedef struct {
	DWORD dwType;
	DWORD dwState;
	UINT uId;
	BYTE bResInfo;
	WCHAR szText[1];
	DWORD dwHelpId;
} MENUEX_TEMPLATE_ITEM;
typedef struct tagMENUITEMINFO {
	UINT cbSize;
	UINT fMask;
	UINT fType;
	UINT fState;
	UINT wID;
	HMENU hSubMenu;
	HBITMAP hbmpChecked;
	HBITMAP hbmpUnchecked;
	DWORD dwItemData;
	LPTSTR dwTypeData;
	UINT cch;
} MENUITEMINFO,*LPMENUITEMINFO;
typedef MENUITEMINFO CONST *LPCMENUITEMINFO;
typedef struct {
	WORD mtOption;
	WORD mtID;
	WCHAR mtString[1];
} MENUITEMTEMPLATE;
typedef struct {
	WORD versionNumber;
	WORD offset;
} MENUITEMTEMPLATEHEADER;
typedef VOID MENUTEMPLATE,*LPMENUTEMPLATE;
typedef struct tagMETAFILEPICT {
	LONG mm;
	LONG xExt;
	LONG yExt;
	HMETAFILE hMF;
} METAFILEPICT,*LPMETAFILEPICT;
typedef struct tagMETAHEADER {
	WORD mtType;
	WORD mtHeaderSize;
	WORD mtVersion;
	DWORD mtSize;
	WORD mtNoObjects;
	DWORD mtMaxRecord;
	WORD mtNoParameters;
} METAHEADER,*LPMETAHEADER;
typedef struct tagMETARECORD {
	DWORD rdSize;
	WORD rdFunction;
	WORD rdParm[1];
} METARECORD,*LPMETARECORD;
typedef struct tagMINIMIZEDMETRICS {
	UINT cbSize;
	int iWidth;
	int iHorzGap;
	int iVertGap;
	int iArrange;
} MINIMIZEDMETRICS,*LPMINIMIZEDMETRICS;
typedef struct tagMINMAXINFO {
	POINT ptReserved;
	POINT ptMaxSize;
	POINT ptMaxPosition;
	POINT ptMinTrackSize;
	POINT ptMaxTrackSize;
} MINMAXINFO,*LPMINMAXINFO;
typedef struct modemdevcaps_tag {
	DWORD dwActualSize;
	DWORD dwRequiredSize;
	DWORD dwDevSpecificOffset;
	DWORD dwDevSpecificSize;
	DWORD dwModemProviderVersion;
	DWORD dwModemManufacturerOffset;
	DWORD dwModemManufacturerSize;
	DWORD dwModemModelOffset;
	DWORD dwModemModelSize;
	DWORD dwModemVersionOffset;
	DWORD dwModemVersionSize;
	DWORD dwDialOptions;
	DWORD dwCallSetupFailTimer;
	DWORD dwInactivityTimeout;
	DWORD dwSpeakerVolume;
	DWORD dwSpeakerMode;
	DWORD dwModemOptions;
	DWORD dwMaxDTERate;
	DWORD dwMaxDCERate;
	BYTE abVariablePortion[1];
} MODEMDEVCAPS,*PMODEMDEVCAPS,*LPMODEMDEVCAPS;
typedef struct modemsettings_tag {
	DWORD dwActualSize;
	DWORD dwRequiredSize;
	DWORD dwDevSpecificOffset;
	DWORD dwDevSpecificSize;
	DWORD dwCallSetupFailTimer;
	DWORD dwInactivityTimeout;
	DWORD dwSpeakerVolume;
	DWORD dwSpeakerMode;
	DWORD dwPreferredModemOptions;
	DWORD dwNegotiatedModemOptions;
	DWORD dwNegotiatedDCERate;
	BYTE abVariablePortion[1];
} MODEMSETTINGS,*PMODEMSETTINGS,*LPMODEMSETTINGS;
typedef struct tagMONCBSTRUCT {
	UINT cb;
	DWORD dwTime;
	HANDLE hTask;
	DWORD dwRet;
	UINT wType;
	UINT wFmt;
	HCONV hConv;
	HSZ hsz1;
	HSZ hsz2;
	HDDEDATA hData;
	DWORD dwData1;
	DWORD dwData2;
	CONVCONTEXT cc;
	DWORD cbData;
	DWORD Data[8];
} MONCBSTRUCT;
typedef struct tagMONCONVSTRUCT {
	UINT cb;
	BOOL fConnect;
	DWORD dwTime;
	HANDLE hTask;
	HSZ hszSvc;
	HSZ hszTopic;
	HCONV hConvClient;
	HCONV hConvServer;
} MONCONVSTRUCT;
typedef struct tagMONERRSTRUCT {
	UINT cb;
	UINT wLastError;
	DWORD dwTime;
	HANDLE hTask;
} MONERRSTRUCT;
typedef struct tagMONHSZSTRUCT {
	UINT cb;
	BOOL fsAction;
	DWORD dwTime;
	HSZ hsz;
	HANDLE hTask;
	TCHAR str[1];
} MONHSZSTRUCT;
typedef struct tagMONLINKSTRUCT {
	UINT cb;
	DWORD dwTime;
	HANDLE hTask;
	BOOL fEstablished;
	BOOL fNoData;
	HSZ hszSvc;
	HSZ hszTopic;
	HSZ hszItem;
	UINT wFmt;
	BOOL fServer;
	HCONV hConvServer;
	HCONV hConvClient;
} MONLINKSTRUCT;
typedef struct tagMONMSGSTRUCT {
	UINT cb;
	HWND hwndTo;
	DWORD dwTime;
	HANDLE hTask;
	UINT wMsg;
	WPARAM wParam;
	LPARAM lParam;
	DDEML_MSG_HOOK_DATA dmhd;
} MONMSGSTRUCT;
typedef struct tagMOUSEHOOKSTRUCT {
	POINT pt;
	HWND hwnd;
	UINT wHitTestCode;
	DWORD dwExtraInfo;
} MOUSEHOOKSTRUCT,*PMOUSEHOOKSTRUCT;
typedef struct tagMOUSEHOOKSTRUCTEX {
	POINT pt;
	HWND hwnd;
	UINT wHitTestCode;
	DWORD dwExtraInfo;
	DWORD mouseData;
} MOUSEHOOKSTRUCTEX, *LPMOUSEHOOKSTRUCTEX, *PMOUSEHOOKSTRUCTEX;
typedef struct _MOUSEKEYS {
	DWORD cbSize;
	DWORD dwFlags;
	DWORD iMaxSpeed;
	DWORD iTimeToMaxSpeed;
	DWORD iCtrlSpeed;
	DWORD dwReserved1;
	DWORD dwReserved2;
} MOUSEKEYS;
typedef struct tagMSG {
	HWND hwnd;
	UINT message;
	WPARAM wParam;
	LPARAM lParam;
	DWORD time;
	POINT pt;
} MSG,*LPMSG,*PMSG;
typedef void (CALLBACK * MSGBOXCALLBACK) (LPHELPINFO lpHelpInfo);
typedef struct {
	UINT cbSize;
	HWND hwndOwner;
	HINSTANCE hInstance;
	LPCTSTR lpszText;
	LPCTSTR lpszCaption;
	DWORD dwStyle;
	LPCTSTR lpszIcon;
	DWORD dwContextHelpId;
	MSGBOXCALLBACK lpfnMsgBoxCallback;
	DWORD dwLanguageId;
} MSGBOXPARAMS,*PMSGBOXPARAMS,*LPMSGBOXPARAMS;
typedef struct tagMULTIKEYHELP {
	DWORD mkSize;
	TCHAR mkKeylist;
	TCHAR szKeyphrase[1];
} MULTIKEYHELP;
typedef struct _NAME_BUFFER {
	UCHAR name[NCBNAMSZ];
	UCHAR name_num;
	UCHAR name_flags;
} NAME_BUFFER;
typedef struct _NCB {
	UCHAR ncb_command;
	UCHAR ncb_retcode;
	UCHAR ncb_lsn;
	UCHAR ncb_num;
	PUCHAR ncb_buffer;
	WORD ncb_length;
	UCHAR ncb_callname[NCBNAMSZ];
	UCHAR ncb_name[NCBNAMSZ];
	UCHAR ncb_rto;
	UCHAR ncb_sto;
	void (*ncb_post) (struct _NCB *);
	UCHAR ncb_lana_num;
	UCHAR ncb_cmd_cplt;
	UCHAR ncb_reserve[10];
	HANDLE ncb_event;
} NCB,*PNCB;
typedef struct _NCCALCSIZE_PARAMS {
	RECT rgrc[3];
	PWINDOWPOS lppos;
} NCCALCSIZE_PARAMS;
typedef struct _NDDESHAREINFO {
	LONG lRevision;
	LPTSTR lpszShareName;
	LONG lShareType;
	LPTSTR lpszAppTopicList;
	LONG fSharedFlag;
	LONG fService;
	LONG fStartAppFlag;
	LONG nCmdShow;
	LONG qModifyId[2];
	LONG cNumItems;
	LPTSTR lpszItemList;
} NDDESHAREINFO;
#ifndef _NETRESOURCE_DEFINED
#define _NETRESOURCE_DEFINED
typedef struct _NETRESOURCE {
	DWORD dwScope;
	DWORD dwType;
	DWORD dwDisplayType;
	DWORD dwUsage;
	LPTSTR lpLocalName;
	LPTSTR lpRemoteName;
	LPTSTR lpComment;
	LPTSTR lpProvider;
} NETRESOURCE,*LPNETRESOURCE;
#endif
#pragma pack(push,4)
typedef struct tagNEWTEXTMETRIC {
	LONG tmHeight;
	LONG tmAscent;
	LONG tmDescent;
	LONG tmInternalLeading;
	LONG tmExternalLeading;
	LONG tmAveCharWidth;
	LONG tmMaxCharWidth;
	LONG tmWeight;
	LONG tmOverhang;
	LONG tmDigitizedAspectX;
	LONG tmDigitizedAspectY;
	BCHAR tmFirstChar;
	BCHAR tmLastChar;
	BCHAR tmDefaultChar;
	BCHAR tmBreakChar;
	BYTE tmItalic;
	BYTE tmUnderlined;
	BYTE tmStruckOut;
	BYTE tmPitchAndFamily;
	BYTE tmCharSet;
	DWORD ntmFlags;
	UINT ntmSizeEM;
	UINT ntmCellHeight;
	UINT ntmAvgWidth;
} NEWTEXTMETRIC;
#pragma pack(pop)
typedef struct tagNEWTEXTMETRICEX {
	NEWTEXTMETRIC ntmentm;
	FONTSIGNATURE ntmeFontSignature;
} NEWTEXTMETRICEX;
typedef struct tagNM_LISTVIEW {
	NMHDR hdr;
	int iItem;
	int iSubItem;
	UINT uNewState;
	UINT uOldState;
	UINT uChanged;
	POINT ptAction;
	LPARAM lParam;
} NM_LISTVIEW,*LPNM_LISTVIEW;
typedef struct _TREEITEM *HTREEITEM;
typedef struct tagTVITEMA {
	UINT mask;
	HTREEITEM hItem;
	UINT state;
	UINT stateMask;
	LPSTR pszText;
	int cchTextMax;
	int iImage;
	int iSelectedImage;
	int cChildren;
	LPARAM lParam;
} TVITEMA, *LPTVITEMA;
typedef struct tagTVITEMW {
	UINT mask;
	HTREEITEM hItem;
	UINT state;
	UINT stateMask;
	LPWSTR pszText;
	int cchTextMax;
	int iImage;
	int iSelectedImage;
	int cChildren;
	LPARAM lParam;
} TVITEMW, *LPTVITEMW;
#define TV_ITEM	TVITEM
#define LPTV_ITEM	LPTVITEM
#ifdef UNICODE
#define TVITEM	TVITEMW
#define	LPTVITEM LPTVITEMW
#else
#define TVITEM	TVITEMA
#define	LPTVITEM LPTVITEMA
#endif
typedef struct tagTVITEMEXA {
	UINT	mask;
	HTREEITEM hItem;
	UINT	state;
	UINT	stateMask;
	LPSTR	pszText;
	int	cchTextMax;
	int	iImage;
	int	iSelectedImage;
	int	cChildren;
	LPARAM	lParam;
	int	iIntegral;
} TVITEMEXA, *LPTVITEMEXA;
typedef struct tagTVITEMEXW {
	UINT	mask;
	HTREEITEM hItem;
	UINT	state;
	UINT	stateMask;
	LPWSTR	pszText;
	int	cchTextMax;
	int	iImage;
	int	iSelectedImage;
	int	cChildren;
	LPARAM	lParam;
	int	iIntegral;
} TVITEMEXW,*LPTVITEMEXW;
typedef struct tagTVINSERTSTRUCTA {
	HTREEITEM hParent;
	HTREEITEM hInsertAfter;
	union {
		TVITEMEXA itemex;
		TVITEMA item;
	};
} TVINSERTSTRUCTA,*LPTVINSERTSTRUCTA;
typedef struct tagTVINSERTSTRUCTW {
	HTREEITEM hParent;
	HTREEITEM hInsertAfter;
	union {
		TVITEMEXW itemex;
		TVITEMW item;
	} ;
} TVINSERTSTRUCTW,*LPTVINSERTSTRUCTW;
typedef struct _NM_TREEVIEW {
	NMHDR hdr;
	UINT action;
	TV_ITEM itemOld;
	TV_ITEM itemNew;
	POINT ptDrag;
} NM_TREEVIEW;
typedef NM_TREEVIEW *LPNM_TREEVIEW;
typedef NM_TREEVIEW *LPNMTREEVIEW;
typedef struct _NM_UPDOWN {
	NMHDR hdr;
	int iPos;
	int iDelta;
} NMUPDOWN,*LPNMUPDOWN;
typedef struct tagNONCLIENTMETRICS {
	UINT cbSize;
	int iBorderWidth;
	int iScrollWidth;
	int iScrollHeight;
	int iCaptionWidth;
	int iCaptionHeight;
	LOGFONT lfCaptionFont;
	int iSmCaptionWidth;
	int iSmCaptionHeight;
	LOGFONT lfSmCaptionFont;
	int iMenuWidth;
	int iMenuHeight;
	LOGFONT lfMenuFont;
	LOGFONT lfStatusFont;
	LOGFONT lfMessageFont;
} NONCLIENTMETRICS,*LPNONCLIENTMETRICS;
typedef struct _SERVICE_ADDRESS {
	DWORD dwAddressType;
	DWORD dwAddressFlags;
	DWORD dwAddressLength;
	DWORD dwPrincipalLength;
	BYTE *lpAddress;
	BYTE *lpPrincipal;
} SERVICE_ADDRESS;
typedef struct _SERVICE_ADDRESSES {
	DWORD dwAddressCount;
	SERVICE_ADDRESS Addresses[1];
} SERVICE_ADDRESSES,*LPSERVICE_ADDRESSES;
#ifndef GUID_DEFINED
typedef struct _GUID {
	unsigned long Data1;
	unsigned short Data2;
	unsigned short Data3;
	unsigned char Data4[8];
} GUID,*LPGUID;
typedef CONST GUID *LPCGUID;
#define GUID_DEFINED
#endif
#if !defined(__IID_DEFINED__)
#define __IID_DEFINED__
typedef GUID IID;
typedef IID *LPIID;
typedef IID *REFIID;
typedef GUID CLSID,*LPCLSID;
typedef CLSID *REFCLSID;
typedef GUID *REFGUID;
#endif
typedef struct tagRemHGLOBAL {
	long fNullHGlobal;
	unsigned long cbData;
	unsigned char data[1]; } RemHGLOBAL;
typedef struct tagRemHMETAFILEPICT {
	long mm;
	long xExt;
	long yExt;
	unsigned long cbData;
	unsigned char data[1];
}	RemHMETAFILEPICT;
typedef void *HMETAFILEPICT;
typedef struct tagRemHENHMETAFILE {
	unsigned long cbData;
	unsigned char data[1];
	} RemHENHMETAFILE;
typedef struct tagRemHBITMAP {
	unsigned long cbData;
	unsigned char data[1];
}	RemHBITMAP;
typedef struct tagRemHPALETTE {
	unsigned long cbData;
	unsigned char data[1];
}	RemHPALETTE;
typedef struct tagRemBRUSH {
	unsigned long cbData;
	unsigned char data[1];
}	RemHBRUSH;
typedef struct _numberfmta {
	UINT NumDigits;
	UINT LeadingZero;
	UINT Grouping;
	LPSTR lpDecimalSep;
	LPSTR lpThousandSep;
	UINT NegativeOrder;
} NUMBERFMTA;
typedef struct _numberfmtw {
	UINT NumDigits;
	UINT LeadingZero;
	UINT Grouping;
	LPWSTR lpDecimalSep;
	LPWSTR lpThousandSep;
	UINT NegativeOrder;
} NUMBERFMTW;
typedef struct _OFSTRUCT {
	BYTE cBytes;
	BYTE fFixedDisk;
	WORD nErrCode;
	WORD Reserved1;
	WORD Reserved2;
	CHAR szPathName[OFS_MAXPATHNAME];
} OFSTRUCT,*LPOFSTRUCT;
typedef struct tagOFNA {
	DWORD	lStructSize;
	HWND	hwndOwner;
	HINSTANCE	hInstance;
	LPCSTR	lpstrFilter;
	LPSTR	lpstrCustomFilter;
	DWORD	nMaxCustFilter;
	DWORD	nFilterIndex;
	LPSTR	lpstrFile;
	DWORD	nMaxFile;
	LPSTR	lpstrFileTitle;
	DWORD	nMaxFileTitle;
	LPCSTR	lpstrInitialDir;
	LPCSTR	lpstrTitle;
	DWORD	Flags;
	WORD	nFileOffset;
	WORD	nFileExtension;
	LPCSTR	lpstrDefExt;
	LPARAM	lCustData;
	LPOFNHOOKPROC	lpfnHook;
	LPCSTR	lpTemplateName;
} OPENFILENAMEA,*LPOPENFILENAMEA;
typedef struct tagOFNW {
	DWORD	lStructSize;
	HWND	hwndOwner;
	HINSTANCE	hInstance;
	LPCWSTR	lpstrFilter;
	LPWSTR	lpstrCustomFilter;
	DWORD	nMaxCustFilter;
	DWORD	nFilterIndex;
	LPWSTR	lpstrFile;
	DWORD	nMaxFile;
	LPWSTR	lpstrFileTitle;
	DWORD	nMaxFileTitle;
	LPCWSTR	lpstrInitialDir;
	LPCWSTR	lpstrTitle;
	DWORD	Flags;
	WORD	nFileOffset;
	WORD	nFileExtension;
	LPCWSTR	lpstrDefExt;
	LPARAM	lCustData;
	LPOFNHOOKPROC	lpfnHook;
	LPCWSTR	lpTemplateName;
} OPENFILENAMEW, *LPOPENFILENAMEW;
#ifdef UNICODE
typedef TVITEMEXW TVITEMEX;
typedef LPTVITEMEXW LPTVITEMEX;
#define LPOPENFILENAME LPOPENFILENAMEW
#define OPENFILENAME OPENFILENAMEW
#define TVINSERTSTRUCT		TVINSERTSTRUCTW
#define LPTVINSERTSTRUCT	LPTVINSERTSTRUCTW
#define NUMBERFMT	NUMBERFMTW
#else
#define LPOPENFILENAME LPOPENFILENAMEA
#define OPENFILENAME OPENFILENAMEA
typedef TVITEMEXA TVITEMEX;
typedef LPTVITEMEXA LPTVITEMEX;
#define TVINSERTSTRUCT		TVINSERTSTRUCTA
#define LPTVINSERTSTRUCT	LPTVINSERTSTRUCTA
#define NUMBERFMT	NUMBERFMTA
#endif
typedef struct _OFNOTIFY {
	NMHDR hdr;
	LPOPENFILENAME lpOFN;
	LPTSTR pszFile;
} OFNOTIFY,*LPOFNOTIFY;
typedef struct _OSVERSIONINFOA {
	DWORD dwOSVersionInfoSize;
	DWORD dwMajorVersion;
	DWORD dwMinorVersion;
	DWORD dwBuildNumber;
	DWORD dwPlatformId;
	CHAR szCSDVersion[128];
} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;

typedef struct _OSVERSIONINFOW {
	DWORD dwOSVersionInfoSize;
	DWORD dwMajorVersion;
	DWORD dwMinorVersion;
	DWORD dwBuildNumber;
	DWORD dwPlatformId;
	WCHAR szCSDVersion[128];
} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW, RTL_OSVERSIONINFOW, *PRTL_OSVERSIONINFOW;
typedef struct _OSVERSIONINFOEXA {
	DWORD dwOSVersionInfoSize;
	DWORD dwMajorVersion;
	DWORD dwMinorVersion;
	DWORD dwBuildNumber;
	DWORD dwPlatformId;
	CHAR szCSDVersion[128];
	WORD wServicePackMajor;
	WORD wServicePackMinor;
	WORD wSuiteMask;
	BYTE wProductType;
	BYTE wReserved;
} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;

typedef struct _OSVERSIONINFOEXW {
	DWORD dwOSVersionInfoSize;
	DWORD dwMajorVersion;
	DWORD dwMinorVersion;
	DWORD dwBuildNumber;
	DWORD dwPlatformId;
	WCHAR szCSDVersion[128];
	WORD wServicePackMajor;
	WORD wServicePackMinor;
	WORD wSuiteMask;
	BYTE wProductType;
	BYTE wReserved;
} OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW, RTL_OSVERSIONINFOEXW, *PRTL_OSVERSIONINFOEXW;
#ifdef UNICODE
typedef OSVERSIONINFOW OSVERSIONINFO;
typedef POSVERSIONINFOW POSVERSIONINFO;
typedef LPOSVERSIONINFOW LPOSVERSIONINFO;
typedef OSVERSIONINFOEXW OSVERSIONINFOEX;
typedef POSVERSIONINFOEXW POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXW LPOSVERSIONINFOEX;
#else
typedef OSVERSIONINFOEXA OSVERSIONINFOEX;
typedef POSVERSIONINFOEXA POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXA LPOSVERSIONINFOEX;
typedef OSVERSIONINFOA OSVERSIONINFO;
typedef POSVERSIONINFOA POSVERSIONINFO;
typedef LPOSVERSIONINFOA LPOSVERSIONINFO;
#endif
typedef struct tagTEXTMETRIC {
	LONG tmHeight;
	LONG tmAscent;
	LONG tmDescent;
	LONG tmInternalLeading;
	LONG tmExternalLeading;
	LONG tmAveCharWidth;
	LONG tmMaxCharWidth;
	LONG tmWeight;
	LONG tmOverhang;
	LONG tmDigitizedAspectX;
	LONG tmDigitizedAspectY;
	BCHAR tmFirstChar;
	BCHAR tmLastChar;
	BCHAR tmDefaultChar;
	BCHAR tmBreakChar;
	BYTE tmItalic;
	BYTE tmUnderlined;
	BYTE tmStruckOut;
	BYTE tmPitchAndFamily;
	BYTE tmCharSet;
	BYTE pad1;
	BYTE pad2;
	BYTE pad3;
	BYTE pad4;
} TEXTMETRIC,*LPTEXTMETRIC;
typedef int (CALLBACK *OLDFONTENUMPROC)(LOGFONT *,TEXTMETRIC *,DWORD,LPARAM);
typedef struct tagTEXTMETRIC *PTEXTMETRIC;
typedef struct tagTEXTMETRICW {
	LONG	tmHeight;
	LONG	tmAscent;
	LONG	tmDescent;
	LONG	tmInternalLeading;
	LONG	tmExternalLeading;
	LONG	tmAveCharWidth;
	LONG	tmMaxCharWidth;
	LONG	tmWeight;
	LONG	tmOverhang;
	LONG	tmDigitizedAspectX;
	LONG	tmDigitizedAspectY;
	WCHAR	tmFirstChar;
	WCHAR	tmLastChar;
	WCHAR	tmDefaultChar;
	WCHAR	tmBreakChar;
	BYTE	tmItalic;
	BYTE	tmUnderlined;
	BYTE	tmStruckOut;
	BYTE	tmPitchAndFamily;
	BYTE	tmCharSet;
} TEXTMETRICW,*PTEXTMETRICW,*NPTEXTMETRICW,*LPTEXTMETRICW;
typedef struct _OUTLINETEXTMETRIC {
	UINT otmSize;
	TEXTMETRIC otmTextMetrics;
	BYTE otmFiller;
	PANOSE otmPanoseNumber;
	UINT otmfsSelection;
	UINT otmfsType;
	int otmsCharSlopeRise;
	int otmsCharSlopeRun;
	int otmItalicAngle;
	UINT otmEMSquare;
	int otmAscent;
	int otmDescent;
	UINT otmLineGap;
	UINT otmsCapEmHeight;
	UINT otmsXHeight;
	RECT otmrcFontBox;
	int otmMacAscent;
	int otmMacDescent;
	UINT otmMacLineGap;
	UINT otmusMinimumPPEM;
	POINT otmptSubscriptSize;
	POINT otmptSubscriptOffset;
	POINT otmptSuperscriptSize;
	POINT otmptSuperscriptOffset;
	UINT otmsStrikeoutSize;
	int otmsStrikeoutPosition;
	int otmsUnderscoreSize;
	int otmsUnderscorePosition;
	PSTR otmpFamilyName;
	PSTR otmpFaceName;
	PSTR otmpStyleName;
	PSTR otmpFullName;
} OUTLINETEXTMETRIC,*LPOUTLINETEXTMETRIC;
typedef struct _OVERLAPPED {
	DWORD Internal;
	DWORD InternalHigh;
	DWORD Offset;
	DWORD OffsetHigh;
	HANDLE hEvent;
} OVERLAPPED,*LPOVERLAPPED;
typedef struct tagPSD {
	DWORD lStructSize;
	HWND hwndOwner;
	HGLOBAL hDevMode;
	HGLOBAL hDevNames;
	DWORD Flags;
	POINT ptPaperSize;
	RECT rtMinMargin;
	RECT rtMargin;
	HINSTANCE hInstance;
	LPARAM lCustData;
	LPPAGESETUPHOOK lpfnPageSetupHook;
	LPPAGEPAINTHOOK lpfnPagePaintHook;
	LPCTSTR lpPageSetupTemplateName;
	HGLOBAL hPageSetupTemplate;
} PAGESETUPDLG,*LPPAGESETUPDLG;
typedef struct tagPAINTSTRUCT {
	HDC hdc;
	BOOL fErase;
	RECT rcPaint;
	BOOL fRestore;
	BOOL fIncUpdate;
	BYTE rgbReserved[32];
} PAINTSTRUCT,*LPPAINTSTRUCT;
#ifndef __PARAFORMAT_DEFINED
#define __PARAFORMAT_DEFINED
typedef struct _paraformat {
	UINT cbSize;
	DWORD dwMask;
	WORD wNumbering;
	WORD wEffects;
	LONG dxStartIndent;
	LONG dxRightIndent;
	LONG dxOffset;
	WORD wAlignment;
	SHORT cTabCount;
	LONG rgxTabs[MAX_TAB_STOPS];
} PARAFORMAT;
#endif
typedef struct _POLYTEXT {
	int x;
	int y;
	UINT n;
	LPCTSTR lpstr;
	UINT uiFlags;
	RECT rcl;
	int *pdx;
} POLYTEXT;
typedef struct _PRIVILEGE_SET {
	DWORD PrivilegeCount;
	DWORD Control;
	LUID_AND_ATTRIBUTES Privilege[ANYSIZE_ARRAY];
} PRIVILEGE_SET,*PPRIVILEGE_SET,*LPPRIVILEGE_SET;
typedef struct _PROCESS_HEAP_ENTRY {
	PVOID lpData;
	DWORD cbData;
	BYTE cbOverhead;
	BYTE iRegionIndex;
	WORD wFlags;
	DWORD dwCommittedSize;
	DWORD dwUnCommittedSize;
	LPVOID lpFirstBlock;
	LPVOID lpLastBlock;
	HANDLE hMem;
} PROCESS_HEAP_ENTRY,*LPPROCESS_HEAP_ENTRY;
typedef struct _PROCESS_INFORMATION {
	HANDLE hProcess;
	HANDLE hThread;
	DWORD dwProcessId;
	DWORD dwThreadId;
} PROCESS_INFORMATION,*LPPROCESS_INFORMATION;
typedef PROCESS_INFORMATION *PPROCESS_INFORMATION;
typedef UINT(CALLBACK * LPFNPSPCALLBACK) (HWND,UINT,LPVOID);
typedef struct _PROPSHEETPAGE {
	DWORD dwSize;
	DWORD dwFlags;
	HINSTANCE hInstance;
	union {
		LPCTSTR pszTemplate;
		LPCDLGTEMPLATE pResource;
	};
	union {
		HICON hIcon;
		LPCTSTR pszIcon;
	};
	LPCTSTR pszTitle;
	DLGPROC pfnDlgProc;
	LPARAM lParam;
	LPFNPSPCALLBACK pfnCallback;
	UINT *pcRefParent;
} PROPSHEETPAGE,*LPPROPSHEETPAGE;
typedef const PROPSHEETPAGE *LPCPROPSHEETPAGE;
typedef struct _PSP *HPROPSHEETPAGE;
typedef struct _PROPSHEETHEADER {
	DWORD dwSize;
	DWORD dwFlags;
	HWND hwndParent;
	HINSTANCE hInstance;
	union {
		HICON hIcon;
		LPCTSTR pszIcon;
	};
	LPCTSTR pszCaption;
	UINT nPages;
	union {
		UINT nStartPage;
		LPCTSTR pStartPage;
	};
	union {
		LPCPROPSHEETPAGE ppsp;
		HPROPSHEETPAGE *phpage;
	};
	PFNPROPSHEETCALLBACK pfnCallback;
} PROPSHEETHEADER,*LPPROPSHEETHEADER;
typedef const PROPSHEETHEADER *LPCPROPSHEETHEADER;
typedef BOOL(CALLBACK * LPFNADDPROPSHEETPAGE) (HPROPSHEETPAGE,LPARAM);
typedef
BOOL(CALLBACK * LPFNADDPROPSHEETPAGES) (LPVOID, LPFNADDPROPSHEETPAGE, LPARAM);
typedef struct _PROTOCOL_INFO {
	DWORD dwServiceFlags;
	INT iAddressFamily;
	INT iMaxSockAddr;
	INT iMinSockAddr;
	INT iSocketType;
	INT iProtocol;
	DWORD dwMessageSize;
	LPTSTR lpProtocol;
} PROTOCOL_INFO;
typedef struct _PSHNOTIFY {
	NMHDR hdr;
	LPARAM lParam;
} PSHNOTIFY,*LPPSHNOTIFY;
typedef struct _RASAMB {
	DWORD dwSize;
	DWORD dwError;
	TCHAR szNetBiosError[NETBIOS_NAME_LEN + 1];
	BYTE bLana;
} RASAMB;
typedef struct _RASTERIZER_STATUS {
	short nSize;
	short wFlags;
	short nLanguageID;
} RASTERIZER_STATUS,*LPRASTERIZER_STATUS;
typedef struct _REMOTE_NAME_INFO {
	LPTSTR lpUniversalName;
	LPTSTR lpConnectionName;
	LPTSTR lpRemainingPath;
} REMOTE_NAME_INFO;
typedef struct _RGNDATAHEADER {
	DWORD dwSize;
	DWORD iType;
	DWORD nCount;
	DWORD nRgnSize;
	RECT rcBound;
} RGNDATAHEADER;
typedef struct _RGNDATA {
	RGNDATAHEADER rdh;
	char Buffer[1];
} RGNDATA,*LPRGNDATA;
typedef struct tagSCROLLINFO {
	UINT cbSize;
	UINT fMask;
	int nMin;
	int nMax;
	UINT nPage;
	int nPos;
	int nTrackPos;
} SCROLLINFO,*LPSCROLLINFO;
typedef SCROLLINFO const *LPCSCROLLINFO;
typedef struct _SECURITY_ATTRIBUTES {
	DWORD nLength;
	LPVOID lpSecurityDescriptor;
	BOOL bInheritHandle;
} SECURITY_ATTRIBUTES,*LPSECURITY_ATTRIBUTES;
typedef DWORD SECURITY_INFORMATION,*PSECURITY_INFORMATION;
typedef struct tagSERIALKEYS {
	DWORD cbSize;
	DWORD dwFlags;
	LPSTR lpszActivePort;
	LPSTR lpszPort;
	DWORD iBaudRate;
	DWORD iPortState;
} SERIALKEYS,*LPSERIALKEYS;
typedef struct _SESSION_BUFFER {
	UCHAR lsn;
	UCHAR state;
	UCHAR local_name[NCBNAMSZ];
	UCHAR remote_name[NCBNAMSZ];
	UCHAR rcvs_outstanding;
	UCHAR sends_outstanding;
} SESSION_BUFFER;
typedef struct _SESSION_HEADER {
	UCHAR sess_name;
	UCHAR num_sess;
	UCHAR rcv_dg_outstanding;
	UCHAR rcv_any_outstanding;
} SESSION_HEADER;
//#ifndef SHCONTF_DEFINED
//typedef enum tagSHCONTF { SHCONTF_FOLDERS=32, SHCONTF_NONFOLDERS=64, SHCONTF_INCLUDEHIDDEN=128,
//SHCONTF_INIT_ON_FIRST_NEXT=256, SHCONTF_NETPRINTERSRCH=512, SHCONTF_SHAREABLE=1024,
//SHCONTF_STORAGE=2048 };
//
//typedef DWORD SHCONTF;
//
//#define SHCONTF_DEFINED
//#endif
#ifndef __FILEOP_FLAGS_DEFINED
typedef WORD FILEOP_FLAGS;
#define __FILEOP_FLAGS_DEFINED
#endif
#ifndef SHGNO_DEFINED
typedef enum tagSHGDN { SHGDN_NORMAL=0, SHGDN_INFOLDER=1, SHGDN_FOREDITING=4096,
SHGDN_FORADDRESSBAR=0x4000, SHGDN_FORPARSING=0x8000 } SHGNO;
#define SHGNO_DEFINED
#endif
typedef struct _SID_AND_ATTRIBUTES {
	PSID Sid;
	DWORD Attributes;
} SID_AND_ATTRIBUTES,*PSID_AND_ATTRIBUTES;
typedef SID_AND_ATTRIBUTES SID_AND_ATTRIBUTES_ARRAY[ANYSIZE_ARRAY];
typedef SID_AND_ATTRIBUTES_ARRAY *PSID_AND_ATTRIBUTES_ARRAY;
typedef struct _SINGLE_LIST_ENTRY {
	struct _SINGLE_LIST_ENTRY *Next;
} SINGLE_LIST_ENTRY;
typedef struct tagSOUNDSENTRY {
	UINT cbSize;
	DWORD dwFlags;
	DWORD iFSTextEffect;
	DWORD iFSTextEffectMSec;
	DWORD iFSTextEffectColorBits;
	DWORD iFSGrafEffect;
	DWORD iFSGrafEffectMSec;
	DWORD iFSGrafEffectColor;
	DWORD iWindowsEffect;
	DWORD iWindowsEffectMSec;
	LPTSTR lpszWindowsEffectDLL;
	DWORD iWindowsEffectOrdinal;
} SOUNDSENTRY,*LPSOUNDSENTRY;
typedef struct _STARTUPINFOA {
	DWORD cb;
	LPSTR lpReserved;
	LPSTR lpDesktop;
	LPSTR lpTitle;
	DWORD dwX;
	DWORD dwY;
	DWORD dwXSize;
	DWORD dwYSize;
	DWORD dwXCountChars;
	DWORD dwYCountChars;
	DWORD dwFillAttribute;
	DWORD dwFlags;
	WORD wShowWindow;
	WORD cbReserved2;
	LPBYTE lpReserved2;
	HANDLE hStdInput;
	HANDLE hStdOutput;
	HANDLE hStdError;
} STARTUPINFOA, *LPSTARTUPINFOA;
typedef struct _STARTUPINFOW {
	DWORD cb;
	LPWSTR lpReserved;
	LPWSTR lpDesktop;
	LPWSTR lpTitle;
	DWORD dwX;
	DWORD dwY;
	DWORD dwXSize;
	DWORD dwYSize;
	DWORD dwXCountChars;
	DWORD dwYCountChars;
	DWORD dwFillAttribute;
	DWORD dwFlags;
	WORD wShowWindow;
	WORD cbReserved2;
	LPBYTE lpReserved2;
	HANDLE hStdInput;
	HANDLE hStdOutput;
	HANDLE hStdError;
} STARTUPINFOW, *LPSTARTUPINFOW;
#ifdef UNICODE
typedef STARTUPINFOW STARTUPINFO;
typedef LPSTARTUPINFOW LPSTARTUPINFO;
#else
typedef STARTUPINFOA STARTUPINFO;
typedef LPSTARTUPINFOA LPSTARTUPINFO;
#endif
typedef struct tagSTICKYKEYS {
	DWORD cbSize;
	DWORD dwFlags;
} STICKYKEYS,*LPSTICKYKEYS;
#ifndef _STRRET_DEFINED
#pragma pack(push,8)
typedef struct _STRRET { UINT uType; union { LPWSTR pOleStr; UINT uOffset; char cStr[260]; } ;
} STRRET,*LPSTRRET;
#define _STRRET_DEFINED
#endif
#pragma pack(pop)
typedef struct tagSTYLESTRUCT {
	DWORD styleOld;
	DWORD styleNew;
} STYLESTRUCT,*LPSTYLESTRUCT;
typedef struct _SYSTEM_AUDIT_ACE {
	ACE_HEADER Header;
	ACCESS_MASK Mask;
	DWORD SidStart;
} SYSTEM_AUDIT_ACE;
typedef struct _SYSTEM_INFO {
	WORD wProcessorArchitecture;
	WORD wReserved;
	DWORD dwPageSize;
	LPVOID lpMinimumApplicationAddress;
	LPVOID lpMaximumApplicationAddress;
	DWORD dwActiveProcessorMask;
	DWORD dwNumberOfProcessors;
	DWORD dwProcessorType;
	DWORD dwAllocationGranularity;
	WORD wProcessorLevel;
	WORD wProcessorRevision;
} SYSTEM_INFO,*LPSYSTEM_INFO;
typedef struct _SYSTEM_POWER_STATUS {
	BYTE ACLineStatus;
	BYTE BatteryFlag;
	BYTE BatteryLifePercent;
	BYTE Reserved1;
	DWORD BatteryLifeTime;
	DWORD BatteryFullLifeTime;
} SYSTEM_POWER_STATUS;
typedef SYSTEM_POWER_STATUS *LPSYSTEM_POWER_STATUS;
typedef struct _TAPE_ERASE {
	ULONG Type;
} TAPE_ERASE;
typedef struct _TAPE_GET_DRIVE_PARAMETERS {
	BOOLEAN ECC;
	BOOLEAN Compression;
	BOOLEAN DataPadding;
	BOOLEAN ReportSetmarks;
	ULONG DefaultBlockSize;
	ULONG MaximumBlockSize;
	ULONG MinimumBlockSize;
	ULONG MaximumPartitionCount;
	ULONG FeaturesLow;
	ULONG FeaturesHigh;
	ULONG EOTWarningZoneSize;
} TAPE_GET_DRIVE_PARAMETERS;
typedef struct _TAPE_GET_MEDIA_PARAMETERS {
	LARGE_INTEGER Capacity;
	LARGE_INTEGER Remaining;
	DWORD BlockSize;
	DWORD PartitionCount;
	BOOLEAN WriteProtected;
} TAPE_GET_MEDIA_PARAMETERS;
typedef struct _TAPE_GET_POSITION {
	ULONG Type;
	ULONG Partition;
	ULONG OffsetLow;
	ULONG OffsetHigh;
} TAPE_GET_POSITION;
typedef struct _TAPE_PREPARE {
	ULONG Operation;
} TAPE_PREPARE;
typedef struct _TAPE_SET_DRIVE_PARAMETERS {
	BOOLEAN ECC;
	BOOLEAN Compression;
	BOOLEAN DataPadding;
	BOOLEAN ReportSetmarks;
	ULONG EOTWarningZoneSize;
} TAPE_SET_DRIVE_PARAMETERS;
typedef struct _TAPE_SET_MEDIA_PARAMETERS {
	ULONG BlockSize;
} TAPE_SET_MEDIA_PARAMETERS;
typedef struct _TAPE_SET_POSITION {
	ULONG Method;
	ULONG Partition;
	ULONG OffsetLow;
	ULONG OffsetHigh;
} TAPE_SET_POSITION;
typedef struct _TAPE_WRITE_MARKS {
	ULONG Type;
	ULONG Count;
} TAPE_WRITE_MARKS;
typedef struct tagTBADDBITMAP {
	HINSTANCE hInst;
	UINT nID;
} TBADDBITMAP,*LPTBADDBITMAP;
typedef struct _TBBUTTON {
	int iBitmap;
	int idCommand;
	BYTE fsState;
	BYTE fsStyle;
	BYTE bReserved[2];
	DWORD dwData;
	int iString;
} TBBUTTON,*PTBBUTTON,*LPTBBUTTON;
typedef const TBBUTTON *LPCTBBUTTON;
typedef struct tagNMTOOLBARA {
	NMHDR	hdr;
	int	iItem;
	TBBUTTON tbButton;
	int	cchText;
	LPSTR	pszText;
	RECT	rcButton;
} NMTOOLBARA,*LPNMTOOLBARA;
typedef struct tagNMTOOLBARW {
	NMHDR	hdr;
	int	iItem;
	TBBUTTON tbButton;
	int	cchText;
	LPWSTR	pszText;
	RECT	rcButton;
} NMTOOLBARW, *LPNMTOOLBARW;
typedef struct tagNMTOOLTIPSCREATED {
	NMHDR hdr;
	HWND hwndToolTips;
} NMTOOLTIPSCREATED, * LPNMTOOLTIPSCREATED;
typedef struct tagTBSAVEPARAMSA {
	HKEY hkr;
	LPCSTR pszSubKey;
	LPCSTR pszValueName;
} TBSAVEPARAMSA,*LPTBSAVEPARAMSA;
typedef struct tagTBSAVEPARAMSW {
	HKEY hkr;
	LPCWSTR pszSubKey;
	LPCWSTR pszValueName;
} TBSAVEPARAMSW,*LPTBSAVEPARAMW;
#ifdef UNICODE
#define TBSAVEPARAMS	TBSAVEPARAMSW
#define LPTBSAVEPARAMS	LPTBSAVEPARAMSW
#else
#define TBSAVEPARAMS	TBSAVEPARAMSA
#define LPTBSAVEPARAMS	LPTBSAVEPARAMSA
#endif
typedef struct _TC_HITTESTINFO {
	POINT pt;
	UINT flags;
} TC_HITTESTINFO;
typedef struct _TC_ITEM {
	UINT mask;
	UINT lpReserved1;
	UINT lpReserved2;
	LPTSTR pszText;
	int cchTextMax;
	int iImage;
	LPARAM lParam;
} TC_ITEM;
typedef struct _TC_ITEMHEADER {
	UINT mask;
	UINT lpReserved1;
	UINT lpReserved2;
	LPTSTR pszText;
	int cchTextMax;
	int iImage;
} TC_ITEMHEADER;
typedef struct _TC_KEYDOWN {
	NMHDR hdr;
	WORD wVKey;
	UINT flags;
} NMTCKEYDOWN;
#ifndef _TEXTRANGE_DEFINED
#define _TEXTRANGE_DEFINED
typedef struct _textrange { CHARRANGE chrg; LPSTR lpstrText; } TEXTRANGE;
#endif
typedef struct _TIME_ZONE_INFORMATION {
	LONG Bias;
	WCHAR StandardName[32];
	SYSTEMTIME StandardDate;
	LONG StandardBias;
	WCHAR DaylightName[32];
	SYSTEMTIME DaylightDate;
	LONG DaylightBias;
} TIME_ZONE_INFORMATION,*LPTIME_ZONE_INFORMATION;
typedef struct tagTOGGLEKEYS {
	DWORD cbSize;
	DWORD dwFlags;
} TOGGLEKEYS;
typedef struct _TOKEN_SOURCE {
	CHAR SourceName[8];
	LUID SourceIdentifier;
} TOKEN_SOURCE,*PTOKEN_SOURCE;
typedef struct _TOKEN_CONTROL {
	LUID TokenId;
	LUID AuthenticationId;
	LUID ModifiedId;
	TOKEN_SOURCE TokenSource;
} TOKEN_CONTROL;
typedef struct _TOKEN_DEFAULT_DACL {
	PACL DefaultDacl;
} TOKEN_DEFAULT_DACL;
typedef struct _TOKEN_GROUPS {
	DWORD GroupCount;
	SID_AND_ATTRIBUTES Groups[ANYSIZE_ARRAY];
} TOKEN_GROUPS,*PTOKEN_GROUPS,*LPTOKEN_GROUPS;
typedef struct _TOKEN_OWNER {
	PSID Owner;
} TOKEN_OWNER;
typedef struct _TOKEN_PRIMARY_GROUP {
	PSID PrimaryGroup;
} TOKEN_PRIMARY_GROUP;
typedef struct _TOKEN_PRIVILEGES {
	DWORD PrivilegeCount;
	LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];
} TOKEN_PRIVILEGES,*PTOKEN_PRIVILEGES,*LPTOKEN_PRIVILEGES;
typedef struct _TOKEN_STATISTICS {
	LUID TokenId;
	LUID AuthenticationId;
	LARGE_INTEGER ExpirationTime;
	TOKEN_TYPE TokenType;
	SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
	DWORD DynamicCharged;
	DWORD DynamicAvailable;
	DWORD GroupCount;
	DWORD PrivilegeCount;
	LUID ModifiedId;
} TOKEN_STATISTICS;
typedef struct _TOKEN_USER {
	SID_AND_ATTRIBUTES User;
} TOKEN_USER;
typedef struct {
	UINT cbSize;
	UINT uFlags;
	HWND hwnd;
	UINT uId;
	RECT rect;
	HINSTANCE hinst;
	LPTSTR lpszText;
	LPARAM lParam;
} TOOLINFO,*PTOOLINFO,*LPTOOLINFO;
typedef struct {
	NMHDR hdr;
	LPTSTR lpszText;
	char szText[80];
	HINSTANCE hinst;
	UINT uFlags;
} TOOLTIPTEXT,*LPTOOLTIPTEXT;
typedef struct tagTPMPARAMS {
	UINT cbSize;
	RECT rcExclude;
} TPMPARAMS,*LPTPMPARAMS;
typedef struct _TT_HITTESTINFO {
	HWND hwnd;
	POINT pt;
	TOOLINFO ti;
} TTHITTESTINFO,*LPHITTESTINFO;
typedef struct tagTTPOLYCURVE {
	WORD wType;
	WORD cpfx;
	POINTFX apfx[1];
} TTPOLYCURVE,*LPTTPOLYCURVE;
typedef struct _TTPOLYGONHEADER {
	DWORD cb;
	DWORD dwType;
	POINTFX pfxStart;
} TTPOLYGONHEADER,*LPTTPOLYGONHEADER;
typedef struct _TV_DISPINFO {
	NMHDR hdr;
	TV_ITEM item;
} TV_DISPINFO;
typedef struct tagTVDISPINFOA {
	NMHDR hdr;
	TVITEMA item;
} NMTVDISPINFOA, *LPNMTVDISPINFOA;
typedef struct tagTVDISPINFOW {
	NMHDR hdr;
	TVITEMW item;
} NMTVDISPINFOW, *LPNMTVDISPINFOW;
typedef struct _TVHITTESTINFO {
	POINT pt;
	UINT flags;
	HTREEITEM hItem;
} TV_HITTESTINFO,*LPTV_HITTESTINFO;
typedef struct _TV_INSERTSTRUCT {
	HTREEITEM hParent;
	HTREEITEM hInsertAfter;
	TV_ITEM item;
} TV_INSERTSTRUCT,*LPTV_INSERTSTRUCT;
typedef struct _TV_KEYDOWN {
	NMHDR hdr;
	WORD wVKey;
	UINT flags;
} TV_KEYDOWN;
typedef struct _TV_SORTCB {
	HTREEITEM hParent;
	PFNTVCOMPARE lpfnCompare;
	LPARAM lParam;
} TV_SORTCB,*LPTV_SORTCB;
typedef union _ULARGE_INTEGER {
	struct {DWORD LowPart; DWORD HighPart;};
	long long QuadPart;
} ULARGE_INTEGER,*PULARGE_INTEGER;
typedef struct _UNIVERSAL_NAME_INFO {
	LPTSTR lpUniversalName;
} UNIVERSAL_NAME_INFO;
typedef struct tagUSEROBJECTFLAGS {
	BOOL fInherit;
	BOOL fReserved;
	DWORD dwFlags;
} USEROBJECTFLAGS;
typedef struct value_entA {
	LPSTR ve_valuename;
	DWORD ve_valuelen;
	DWORD ve_valueptr;
	DWORD ve_type;
}VALENTA, *PVALENTA;
typedef struct value_entW {
	LPWSTR ve_valuename;
	DWORD ve_valuelen;
	DWORD ve_valueptr;
	DWORD ve_type;
}VALENTW, *PVALENTW;
typedef struct pvalueA { LPSTR pv_valuename; int pv_valuelen; LPVOID pv_value_context;DWORD pv_type;}PVALUEA, *PPVALUEA;
typedef struct pvalueW { LPWSTR pv_valuename;int pv_valuelen;LPVOID pv_value_context;DWORD pv_type;}PVALUEW, *PPVALUEW;
#ifdef UNICODE
typedef PVALUEW PVALUE;
typedef PPVALUEW PPVALUE;
typedef VALENTW VALENT;
typedef PVALENTW PVALENT;
#define TBN_GETDISPINFO	TBN_GETDISPINFOW
#define NMTBDISPINFO	NMTBDISPINFOW
#define LPNMTBDISPINFO	LPNMTBDISPINFOW
#define TBN_GETINFOTIP	TBN_GETINFOTIPW
#define NMTBGETINFOTIP	NMTBGETINFOTIPW
#define LPNMTBGETINFOTIP	LPNMTBGETINFOTIPW
#define WIN32_FIND_DATA	WIN32_FIND_DATAW
#define LPWIN32_FIND_DATA LPWIN32_FIND_DATAW
#define NMTVDISPINFO	NMTVDISPINFOW
#define LPNMTVDISPINFO	LPNMTVDISPINFOW
#else
typedef PVALUEA PVALUE;
typedef PPVALUEA PPVALUE;
typedef VALENTA VALENT;
typedef PVALENTA PVALENT;
#define TBN_GETDISPINFO	TBN_GETDISPINFOA
#define NMTBDISPINFO	NMTBDISPINFOA
#define LPNMTBDISPINFO	LPNMTBDISPINFOA
#define TBN_GETINFOTIP	TBN_GETINFOTIPA
#define NMTBGETINFOTIP	NMTBGETINFOTIPA
#define LPNMTBGETINFOTIP	LPNMTBGETINFOTIPA
#define WIN32_FIND_DATA WIN32_FIND_DATAA
#define LPWIN32_FIND_DATA	LPWIN32_FIND_DATAA
#define NMTVDISPINFO	NMTVDISPINFOA
#define LPNMTVDISPINFO	LPNMTVDISPINFOA
#endif
typedef struct _WIN32_STREAM_ID {
	DWORD dwStreamId;
	DWORD dwStreamAttributes;
	LARGE_INTEGER Size;
	DWORD dwStreamNameSize;
	WCHAR *cStreamName;
} WIN32_STREAM_ID,*LPWIN32_STREAM_ID;
typedef struct _WINDOWPLACEMENT {
	UINT length;
	UINT flags;
	UINT showCmd;
	POINT ptMinPosition;
	POINT ptMaxPosition;
	RECT rcNormalPosition;
} WINDOWPLACEMENT,*LPWINDOWPLACEMENT,*PWINDOWPLACEMENT;
typedef struct tagWNDCLASSEXA {
	UINT	cbSize;
	UINT	style;
	WNDPROC	lpfnWndProc;
	int	cbClsExtra;
	int	cbWndExtra;
	HINSTANCE	hInstance;
	HICON	hIcon;
	HCURSOR	hCursor;
	HBRUSH	hbrBackground;
	LPCSTR	lpszMenuName;
	LPCSTR	lpszClassName;
	HICON	hIconSm;
} WNDCLASSEXA, *PWNDCLASSEXA,*NPWNDCLASSEXA,*LPWNDCLASSEXA;
typedef struct tagWNDCLASSEXW {
	UINT cbSize;
	UINT style;
	WNDPROC lpfnWndProc;
	int cbClsExtra;
	int cbWndExtra;
	HINSTANCE hInstance;
	HICON hIcon;
	HCURSOR hCursor;
	HBRUSH hbrBackground;
	LPCWSTR lpszMenuName;
	LPCWSTR lpszClassName;
	HICON hIconSm;
} WNDCLASSEXW,*PWNDCLASSEXW,*NPWNDCLASSEXW,*LPWNDCLASSEXW;
#ifdef UNICODE
typedef WNDCLASSEXW WNDCLASSEX;
typedef PWNDCLASSEXW PWNDCLASSEX;
typedef NPWNDCLASSEXW NPWNDCLASSEX;
typedef LPWNDCLASSEXW LPWNDCLASSEX;
#else
typedef WNDCLASSEXA WNDCLASSEX;
typedef PWNDCLASSEXA PWNDCLASSEX;
typedef NPWNDCLASSEXA NPWNDCLASSEX;
typedef LPWNDCLASSEXA LPWNDCLASSEX;
#endif
typedef struct tagWNDCLASSA {
	UINT	style;
	WNDPROC	lpfnWndProc;
	int	cbClsExtra;
	int	cbWndExtra;
	HINSTANCE	hInstance;
	HICON	hIcon;
	HCURSOR	hCursor;
	HBRUSH	hbrBackground;
	LPCSTR	lpszMenuName;
	LPCSTR	lpszClassName;
} WNDCLASSA, *PWNDCLASSA,*NPWNDCLASSA,*LPWNDCLASSA;
typedef struct tagWNDCLASSW {
	UINT	style;
	WNDPROC	lpfnWndProc;
	int	cbClsExtra;
	int	cbWndExtra;
	HINSTANCE hInstance;
	HICON	hIcon;
	HCURSOR	hCursor;
	HBRUSH	hbrBackground;
	LPCWSTR	lpszMenuName;
	LPCWSTR	lpszClassName;
} WNDCLASSW, *PWNDCLASSW,*NPWNDCLASSW,*LPWNDCLASSW;
#ifdef UNICODE
typedef WNDCLASSW WNDCLASS;
typedef PWNDCLASSW PWNDCLASS;
typedef NPWNDCLASSW NPWNDCLASS;
typedef LPWNDCLASSW LPWNDCLASS;
#else
typedef WNDCLASSA WNDCLASS;
typedef PWNDCLASSA PWNDCLASS;
typedef NPWNDCLASSA NPWNDCLASS;
typedef LPWNDCLASSA LPWNDCLASS;
#endif
typedef struct _CONNECTDLGSTRUCT {
	DWORD cbStructure;
	HWND hwndOwner;
	LPNETRESOURCE lpConnRes;
	DWORD dwFlags;
	DWORD dwDevNum;
} CONNECTDLGSTRUCT,*LPCONNECTDLGSTRUCT;
typedef struct _DISCDLGSTRUCT {
	DWORD cbStructure;
	HWND hwndOwner;
	LPTSTR lpLocalName;
	LPTSTR lpRemoteName;
	DWORD dwFlags;
} DISCDLGSTRUCT,*LPDISCDLGSTRUCT;
typedef struct _NETINFOSTRUCT {
	DWORD cbStructure;
	DWORD dwProviderVersion;
	DWORD dwStatus;
	DWORD dwCharacteristics;
	DWORD dwHandle;
	WORD wNetType;
	DWORD dwPrinters;
	DWORD dwDrives;
} NETINFOSTRUCT,*LPNETINFOSTRUCT;
typedef struct _NETCONNECTINFOSTRUCT {
	DWORD cbStructure;
	DWORD dwFlags;
	DWORD dwSpeed;
	DWORD dwDelay;
	DWORD dwOptDataSize;
} NETCONNECTINFOSTRUCT,*LPNETCONNECTINFOSTRUCT;
typedef struct _MESSAGE_RESOURCE_ENTRY {
	WORD	Length;
	WORD	Flags;
	BYTE	Text[ 1 ];
} MESSAGE_RESOURCE_ENTRY,*PMESSAGE_RESOURCE_ENTRY;
#define MESSAGE_RESOURCE_UNICODE 1
typedef struct _MESSAGE_RESOURCE_BLOCK {
	DWORD	LowId;
	DWORD	HighId;
	DWORD OffsetToEntries;
} MESSAGE_RESOURCE_BLOCK,*PMESSAGE_RESOURCE_BLOCK;
typedef struct _MESSAGE_RESOURCE_DATA {
	DWORD	NumberOfBlocks;
	MESSAGE_RESOURCE_BLOCK Blocks[1];
} MESSAGE_RESOURCE_DATA,*PMESSAGE_RESOURCE_DATA;
typedef enum tagMEMCTX {MEMCTX_TASK=1,MEMCTX_SHARED=2,MEMCTX_MACSYSTEM=3,MEMCTX_UNKNOWN = -1,MEMCTX_SAME=-2 }MEMCTX;
typedef enum tagCLSCTX {CLSCTX_INPROC_SERVER=1,CLSCTX_INPROC_HANDLER=2,
	CLSCTX_LOCAL_SERVER=4,CLSCTX_INPROC_SERVER16=8,CLSCTX_REMOTE_SERVER=16} CLSCTX;
typedef enum tagMSHLFLAGS {MSHLFLAGS_NORMAL=0,MSHLFLAGS_TABLESTRONG= 1,
	MSHLFLAGS_TABLEWEAK=2,MSHLFLAGS_NOPING=4} MSHLFLAGS;
typedef enum tagMSHCTX {MSHCTX_LOCAL=0,MSHCTX_NOSHAREDMEM=1,
	MSHCTX_DIFFERENTMACHINE=2,MSHCTX_INPROC=3,MSHCTX_CROSSCTX = 4} MSHCTX;
typedef enum _DVASPECT {DVASPECT_CONTENT=1,DVASPECT_THUMBNAIL=2,
 DVASPECT_ICON=4,DVASPECT_DOCPRINT=8} DVASPECT;
typedef enum tagSTGC {STGC_DEFAULT=0,STGC_OVERWRITE=1,
	STGC_ONLYIFCURRENT=2,STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE=4,STGC_CONSOLIDATE=8}STGC;
typedef enum tagSTGMOVE {STGMOVE_MOVE=0,STGMOVE_COPY=1,STGMOVE_SHALLOWCOPY=2}STGMOVE;
typedef enum tagSTATFLAG {STATFLAG_DEFAULT= 0,STATFLAG_NONAME=1,STATFLAG_NOOPEN=2} STATFLAG;
typedef void *HCONTEXT;
typedef struct tagLVBKIMAGEA {
	ULONG ulFlags;
	HBITMAP hbm;
	LPSTR pszImage;
	UINT cchImageMax;
	int xOffsetPercent;
	int yOffsetPercent;
} LVBKIMAGEA, *LPLVBKIMAGEA;
typedef struct tagLVBKIMAGEW {
	ULONG ulFlags;
	HBITMAP hbm;
	LPWSTR pszImage;
	UINT cchImageMax;
	int xOffsetPercent;
	int yOffsetPercent;
} LVBKIMAGEW, *LPLVBKIMAGEW;
typedef struct {
	UINT cbSize;
	DWORD dwMask;
	int idCommand;
	int iImage;
	BYTE fsState;
	BYTE fsStyle;
	WORD cx;
	DWORD_PTR lParam;
	LPSTR pszText;
	int cchText;
} TBBUTTONINFOA, *LPTBBUTTONINFOA;
typedef struct {
	UINT cbSize;
	DWORD dwMask;
	int idCommand;
	int iImage;
	BYTE fsState;
	BYTE fsStyle;
	WORD cx;
	DWORD *lParam;
	LPWSTR pszText;
	int cchText;
} TBBUTTONINFOW, *LPTBBUTTONINFOW;
typedef struct tagNMKEY {
	NMHDR hdr;
	UINT nVKey;
	UINT uFlags;
} NMKEY,*LPNMKEY;
typedef struct tagNMCHAR {
	NMHDR	hdr;
	UINT	ch;
	DWORD	dwItemPrev;
	DWORD	dwItemNext;
} NMCHAR,*LPNMCHAR;
typedef struct tagNMCUSTOMDRAWINFO {
	NMHDR hdr;
	DWORD dwDrawStage;
	HDC hdc;
	RECT rc;
	DWORD_PTR dwItemSpec;
	UINT uItemState;
	LPARAM lItemlParam;
} NMCUSTOMDRAW, FAR * LPNMCUSTOMDRAW;
typedef struct tagNMLVCUSTOMDRAW {
	NMCUSTOMDRAW nmcd;
	COLORREF clrText;
	COLORREF clrTextBk;
	int iSubItem;
} NMLVCUSTOMDRAW, *LPNMLVCUSTOMDRAW;
typedef struct _NMTBCUSTOMDRAW {
	NMCUSTOMDRAW nmcd;
	HBRUSH hbrMonoDither;
	HBRUSH hbrLines;
	HPEN hpenLines;
	COLORREF clrText;
	COLORREF clrMark;
	COLORREF clrTextHighlight;
	COLORREF clrBtnFace;
	COLORREF clrBtnHighlight;
	COLORREF clrHighlightHotTrack;
	RECT rcText;
	int nStringBkMode;
	int nHLStringBkMode;
} NMTBCUSTOMDRAW, *LPNMTBCUSTOMDRAW;
typedef struct {
	NMHDR hdr;
	DWORD dwMask;
	int idCommand;
	DWORD_PTR lParam;
	int iImage;
	LPSTR pszText;
	int cchText;
} NMTBDISPINFOA,*LPNMTBDISPINFOA;
typedef struct {
	NMHDR hdr;
	DWORD dwMask;
	int idCommand;
	DWORD_PTR lParam;
	int iImage;
	LPWSTR pszText;
	int cchText;
} NMTBDISPINFOW,*LPNMTBDISPINFOW;
typedef struct tagNMOBJECTNOTIFY {
	NMHDR	hdr;
	int	iItem;
	const void *piid;
	void *pObject;
	HRESULT hResult;
	DWORD dwFlags;
} NMOBJECTNOTIFY,*LPNMOBJECTNOTIFY;
typedef struct tagNMTBHOTITEM {
	NMHDR	hdr;
	int	idOld;
	int	idNew;
	DWORD	dwFlags;
} NMTBHOTITEM, * LPNMTBHOTITEM;
typedef struct tagNMTBGETINFOTIPA {
	NMHDR hdr;
	LPSTR pszText;
	int cchTextMax;
	int iItem;
	LPARAM lParam;
} NMTBGETINFOTIPA, *LPNMTBGETINFOTIPA;
typedef struct tagNMTBGETINFOTIPW {
	NMHDR hdr;
	LPWSTR pszText;
	int cchTextMax;
	int iItem;
	LPARAM lParam;
} NMTBGETINFOTIPW, *LPNMTBGETINFOTIPW;
typedef struct {
	int	iButton;
	DWORD dwFlags;
} TBINSERTMARK,*LPTBINSERTMARK;
typedef struct {
	HINSTANCE	hInstOld;
	UINT_PTR	nIDOld;
	HINSTANCE	hInstNew;
	UINT_PTR	nIDNew;
	int	nButtons;
} TBREPLACEBITMAP, *LPTBREPLACEBITMAP;
#define TBIMHT_AFTER	1
#define TBIMHT_BACKGROUND	2
typedef struct {
	NMHDR hdr;
	WORD fwKeys;
	RECT rcParent;
	int iDir;
	int iXpos;
	int iYpos;
	int iScroll;
}NMPGSCROLL,*LPNMPGSCROLL;
typedef struct {
	NMHDR	hdr;
	DWORD	dwFlag;
	int	iWidth;
	int	iHeight;
}NMPGCALCSIZE, *LPNMPGCALCSIZE;
#define PBM_SETRANGE32	(WM_USER+6)
typedef struct {
	int iLow;
	int iHigh;
} PBRANGE, *PPBRANGE;
#define PBM_GETRANGE	(WM_USER+7)
#define PBM_GETPOS	(WM_USER+8)
#define PBM_SETBARCOLOR	(WM_USER+9)
#define PBM_SETBKCOLOR	CCM_SETBKCOLOR
typedef struct _UDACCEL {
	UINT nSec;
	UINT nInc;
} UDACCEL,*LPUDACCEL;
typedef struct tagTCITEMHEADERA {
	UINT mask;
	UINT lpReserved1;
	UINT lpReserved2;
	LPSTR pszText;
	int cchTextMax;
	int iImage;
} TCITEMHEADERA,*LPTCITEMHEADERA;
typedef struct tagTCITEMHEADERW {
	UINT mask;
	UINT lpReserved1;
	UINT lpReserved2;
	LPWSTR pszText;
	int cchTextMax;
	int iImage;
} TCITEMHEADERW,*LPTCITEMHEADERW;
typedef struct tagTCITEMA {
	UINT mask;
	DWORD dwState;
	DWORD dwStateMask;
	LPSTR pszText;
	int cchTextMax;
	int iImage;
	LPARAM lParam;
} TCITEMA,*LPTCITEMA;
typedef struct tagTCITEMW {
	UINT mask;
	DWORD dwState;
	DWORD dwStateMask;
	LPWSTR pszText;
	int cchTextMax;
	int iImage;
	LPARAM lParam;
} TCITEMW, *LPTCITEMW;
#ifdef UNICODE
#define TCITEMHEADER	TCITEMHEADERW
#define LPTCITEMHEADER	LPTCITEMHEADERW
#define TCITEMHEADER	TCITEMHEADERW
#define LPTCITEMHEADER	LPTCITEMHEADERW
#define TCITEM	TCITEMW
#define LPTCITEM	LPTCITEMW
#else
#define TCITEMHEADER	TCITEMHEADERA
#define LPTCITEMHEADER	LPTCITEMHEADERA
#define TCITEMHEADER	TCITEMHEADERA
#define LPTCITEMHEADER	LPTCITEMHEADERA
#define TCITEM	TCITEMA
#define LPTCITEM	LPTCITEMA
#endif
#ifndef FIELD_OFFSET
#define FIELD_OFFSET(type, field) ((LONG)(LONG *)&(((type *)0)->field))
#endif
typedef DWORD MONTHDAYSTATE,*LPMONTHDAYSTATE;
typedef HANDLE HRAWINPUT;
/* Structures associated with the executable image files. jn */

#define IMAGE_DOS_SIGNATURE 0x5A4D
#define IMAGE_OS2_SIGNATURE 0x454E
#define IMAGE_OS2_SIGNATURE_LE 0x454C
#define IMAGE_VXD_SIGNATURE 0x454C
#define IMAGE_NT_SIGNATURE 0x4550
#define IMAGE_SIZEOF_FILE_HEADER 20
#define IMAGE_FILE_RELOCS_STRIPPED 1
#define IMAGE_FILE_EXECUTABLE_IMAGE 2
#define IMAGE_FILE_LINE_NUMS_STRIPPED 4
#define IMAGE_FILE_LOCAL_SYMS_STRIPPED 8
#define IMAGE_FILE_BYTES_REVERSED_LO 128
#define IMAGE_FILE_32BIT_MACHINE 256
#define IMAGE_FILE_DEBUG_STRIPPED 512
#define IMAGE_FILE_SYSTEM 0x1000
#define IMAGE_FILE_DLL 0x2000
#define IMAGE_FILE_BYTES_REVERSED_HI 0x8000
#define IMAGE_FILE_MACHINE_UNKNOWN 0
#define IMAGE_FILE_MACHINE_I386 0x14c
#define IMAGE_FILE_MACHINE_R3000 0x162
#define IMAGE_FILE_MACHINE_R4000 0x166
#define IMAGE_FILE_MACHINE_R10000 0x168
#define IMAGE_FILE_MACHINE_ALPHA 0x184
#define IMAGE_FILE_MACHINE_POWERPC 0x1F0
#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16
#define IMAGE_SIZEOF_ROM_OPTIONAL_HEADER 56
#define IMAGE_SIZEOF_STD_OPTIONAL_HEADER 28
#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER 224
#define IMAGE_NT_OPTIONAL_HDR_MAGIC 0x10b
#define IMAGE_ROM_OPTIONAL_HDR_MAGIC 0x107
#define IMAGE_FIRST_SECTION(nth) ((PIMAGE_SECTION_HEADER) \
 ((DWORD)nth + FIELD_OFFSET( IMAGE_NT_HEADERS,OptionalHeader ) + \
 ((PIMAGE_NT_HEADERS)(nth))->FileHeader.SizeOfOptionalHeader))
#define IMAGE_SUBSYSTEM_UNKNOWN 0
#define IMAGE_SUBSYSTEM_NATIVE 1
#define IMAGE_SUBSYSTEM_WINDOWS_GUI 2
#define IMAGE_SUBSYSTEM_WINDOWS_CUI 3
#define IMAGE_SUBSYSTEM_OS2_CUI 5
#define IMAGE_SUBSYSTEM_POSIX_CUI 7
#define IMAGE_SUBSYSTEM_WINDOWS_CE_GUI 9
#define IMAGE_DIRECTORY_ENTRY_EXPORT 0
#define IMAGE_DIRECTORY_ENTRY_IMPORT 1
#define IMAGE_DIRECTORY_ENTRY_RESOURCE 2
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3
#define IMAGE_DIRECTORY_ENTRY_SECURITY 4
#define IMAGE_DIRECTORY_ENTRY_BASERELOC 5
#define IMAGE_DIRECTORY_ENTRY_DEBUG 6
#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT 7
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8
#define IMAGE_DIRECTORY_ENTRY_TLS 9
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11
#define IMAGE_DIRECTORY_ENTRY_IAT 12
#define IMAGE_SIZEOF_SHORT_NAME 8
#define IMAGE_SIZEOF_SECTION_HEADER 40
#define IMAGE_SCN_TYPE_NO_PAD 8
#define IMAGE_SCN_CNT_CODE 32
#define IMAGE_SCN_CNT_INITIALIZED_DATA 64
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA 128
#define IMAGE_SCN_LNK_OTHER 256
#define IMAGE_SCN_LNK_INFO 512
#define IMAGE_SCN_LNK_REMOVE 0x800
#define IMAGE_SCN_LNK_COMDAT 0x1000
#define IMAGE_SCN_MEM_FARDATA 0x8000
#define IMAGE_SCN_MEM_PURGEABLE 0x20000
#define IMAGE_SCN_MEM_16BIT 0x20000
#define IMAGE_SCN_MEM_LOCKED 0x40000
#define IMAGE_SCN_MEM_PRELOAD 0x80000
#define IMAGE_SCN_ALIGN_1BYTES 0x100000
#define IMAGE_SCN_ALIGN_2BYTES 0x200000
#define IMAGE_SCN_ALIGN_4BYTES 0x300000
#define IMAGE_SCN_ALIGN_8BYTES 0x400000
#define IMAGE_SCN_ALIGN_16BYTES 0x500000
#define IMAGE_SCN_ALIGN_32BYTES 0x600000
#define IMAGE_SCN_ALIGN_64BYTES 0x700000
#define IMAGE_SCN_LNK_NRELOC_OVFL 0x1000000
#define IMAGE_SCN_MEM_DISCARDABLE 0x2000000
#define IMAGE_SCN_MEM_NOT_CACHED 0x4000000
#define IMAGE_SCN_MEM_NOT_PAGED 0x8000000
#define IMAGE_SCN_MEM_SHARED 0x10000000
#define IMAGE_SCN_MEM_EXECUTE 0x20000000
#define IMAGE_SCN_MEM_READ 0x40000000
#define IMAGE_SCN_MEM_WRITE 0x80000000
#define IMAGE_SIZEOF_SYMBOL 18
#define IMAGE_SYM_UNDEFINED (SHORT)0
#define IMAGE_SYM_ABSOLUTE (SHORT)-1
#define IMAGE_SYM_DEBUG (SHORT)-2
#define IMAGE_SYM_TYPE_NULL 0
#define IMAGE_SYM_TYPE_VOID 1
#define IMAGE_SYM_TYPE_CHAR 2
#define IMAGE_SYM_TYPE_SHORT 3
#define IMAGE_SYM_TYPE_INT 4
#define IMAGE_SYM_TYPE_LONG 5
#define IMAGE_SYM_TYPE_FLOAT 6
#define IMAGE_SYM_TYPE_DOUBLE 7
#define IMAGE_SYM_TYPE_STRUCT 8
#define IMAGE_SYM_TYPE_UNION 9
#define IMAGE_SYM_TYPE_ENUM 10
#define IMAGE_SYM_TYPE_MOE 11
#define IMAGE_SYM_TYPE_BYTE 12
#define IMAGE_SYM_TYPE_WORD 13
#define IMAGE_SYM_TYPE_UINT 14
#define IMAGE_SYM_TYPE_DWORD 15
#define IMAGE_SYM_TYPE_PCODE 0x8000
#define IMAGE_SYM_DTYPE_NULL 0
#define IMAGE_SYM_DTYPE_POINTER 1
#define IMAGE_SYM_DTYPE_FUNCTION 2
#define IMAGE_SYM_DTYPE_ARRAY 3
#define IMAGE_SYM_CLASS_END_OF_FUNCTION (BYTE )-1
#define IMAGE_SYM_CLASS_NULL 0
#define IMAGE_SYM_CLASS_AUTOMATIC 1
#define IMAGE_SYM_CLASS_EXTERNAL 2
#define IMAGE_SYM_CLASS_STATIC 3
#define IMAGE_SYM_CLASS_REGISTER 4
#define IMAGE_SYM_CLASS_EXTERNAL_DEF 5
#define IMAGE_SYM_CLASS_LABEL 6
#define IMAGE_SYM_CLASS_UNDEFINED_LABEL 7
#define IMAGE_SYM_CLASS_MEMBER_OF_STRUCT 8
#define IMAGE_SYM_CLASS_ARGUMENT 9
#define IMAGE_SYM_CLASS_STRUCT_TAG 10
#define IMAGE_SYM_CLASS_MEMBER_OF_UNION 11
#define IMAGE_SYM_CLASS_UNION_TAG 12
#define IMAGE_SYM_CLASS_TYPE_DEFINITION 13
#define IMAGE_SYM_CLASS_UNDEFINED_STATIC 14
#define IMAGE_SYM_CLASS_ENUM_TAG 15
#define IMAGE_SYM_CLASS_MEMBER_OF_ENUM 16
#define IMAGE_SYM_CLASS_REGISTER_PARAM 17
#define IMAGE_SYM_CLASS_BIT_FIELD 18
#define IMAGE_SYM_CLASS_FAR_EXTERNAL 0x44
#define IMAGE_SYM_CLASS_BLOCK 0x64
#define IMAGE_SYM_CLASS_FUNCTION 0x65
#define IMAGE_SYM_CLASS_END_OF_STRUCT 0x66
#define IMAGE_SYM_CLASS_FILE 0x67
#define IMAGE_SYM_CLASS_SECTION 0x68
#define IMAGE_SYM_CLASS_WEAK_EXTERNAL 0x69
#define N_BTMASK 0xF
#define N_TMASK 0x30
#define N_TMASK1 0xC0
#define N_TMASK2 0xF0
#define N_BTSHFT 4
#define N_TSHIFT 2
#define BTYPE(x) ((x) & N_BTMASK)
#ifndef ISPTR
#define ISPTR(x) (((x)&N_TMASK)==(IMAGE_SYM_DTYPE_POINTER << N_BTSHFT))
#endif
#ifndef ISFCN
#define ISFCN(x) (((x)&N_TMASK)==(IMAGE_SYM_DTYPE_FUNCTION << N_BTSHFT))
#endif
#ifndef ISARY
#define ISARY(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_ARRAY << N_BTSHFT))
#endif
#ifndef ISTAG
#define ISTAG(x) ((x)==IMAGE_SYM_CLASS_STRUCT_TAG || (x)==IMAGE_SYM_CLASS_UNION_TAG || (x)==IMAGE_SYM_CLASS_ENUM_TAG)
#endif
#ifndef INCREF
#define INCREF(x) ((((x)&~N_BTMASK)<<N_TSHIFT)|(IMAGE_SYM_DTYPE_POINTER<<N_BTSHFT)|((x)&N_BTMASK))
#endif
#ifndef DECREF
#define DECREF(x) ((((x)>>N_TSHIFT)&~N_BTMASK)|((x)&N_BTMASK))
#endif
#define IMAGE_SIZEOF_SYMBOL	18
#define IMAGE_COMDAT_SELECT_NODUPLICATES	1
#define IMAGE_COMDAT_SELECT_ANY	2
#define IMAGE_COMDAT_SELECT_SAME_SIZE	3
#define IMAGE_COMDAT_SELECT_EXACT_MATCH	4
#define IMAGE_COMDAT_SELECT_ASSOCIATIVE	5
#define IMAGE_COMDAT_SELECT_LARGEST	6
#define IMAGE_COMDAT_SELECT_NEWEST	7
#define IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY	1
#define IMAGE_WEAK_EXTERN_SEARCH_LIBRARY	2
#define IMAGE_WEAK_EXTERN_SEARCH_ALIAS	3
#define IMAGE_SIZEOF_RELOCATION 10
#define IMAGE_REL_I386_ABSOLUTE	0
#define IMAGE_REL_I386_DIR16	1
#define IMAGE_REL_I386_REL16	2
#define IMAGE_REL_I386_DIR32	6
#define IMAGE_REL_I386_DIR32NB	7
#define IMAGE_REL_I386_SEG12 9
#define IMAGE_REL_I386_SECTION 10
#define IMAGE_REL_I386_SECREL 11
#define IMAGE_REL_I386_REL32 0x14
#define IMAGE_SIZEOF_BASE_RELOCATION 8
#define IMAGE_REL_BASED_ABSOLUTE 0
#define IMAGE_REL_BASED_HIGH 1
#define IMAGE_REL_BASED_LOW 2
#define IMAGE_REL_BASED_HIGHLOW 3
#define IMAGE_REL_BASED_HIGHADJ 4
#define IMAGE_REL_BASED_MIPS_JMPADDR 5
#define IMAGE_SIZEOF_LINENUMBER 6
#define IMAGE_ARCHIVE_START_SIZE 8
#define IMAGE_ARCHIVE_START "!<arch>\n"
#define IMAGE_ARCHIVE_END "`\n"
#define IMAGE_ARCHIVE_PAD "\n"
#define IMAGE_ARCHIVE_LINKER_MEMBER "/ "
#define IMAGE_ARCHIVE_LONGNAMES_MEMBER "// "
#define IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR 60
#define IMAGE_ORDINAL_FLAG 0x80000000
#define IMAGE_SNAP_BY_ORDINAL(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG) != 0)
#define IMAGE_ORDINAL(Ordinal) (Ordinal & 0xffff)
#define IMAGE_RESOURCE_NAME_IS_STRING 0x80000000
#define IMAGE_RESOURCE_DATA_IS_DIRECTORY 0x80000000
#define IMAGE_DEBUG_TYPE_UNKNOWN 0
#define IMAGE_DEBUG_TYPE_COFF 1
#define IMAGE_DEBUG_TYPE_CODEVIEW 2
#define IMAGE_DEBUG_TYPE_FPO 3
#define IMAGE_DEBUG_TYPE_MISC 4
#define IMAGE_DEBUG_TYPE_EXCEPTION 5
#define IMAGE_DEBUG_TYPE_FIXUP 6
#define IMAGE_DEBUG_TYPE_OMAP_TO_SRC 7
#define IMAGE_DEBUG_TYPE_OMAP_FROM_SRC 8
#define FRAME_FPO 0
#define FRAME_TRAP 1
#define FRAME_TSS 2
#define FRAME_NONFPO 3
#define SIZEOF_RFPO_DATA 16
#define IMAGE_DEBUG_MISC_EXENAME 1
#define IMAGE_SEPARATE_DEBUG_SIGNATURE 0x4944
#define CCHILDREN_TITLEBAR	5
#define CCHILDREN_SCROLLBAR	5
typedef struct _IMAGE_DOS_HEADER {
	WORD e_magic;
	WORD e_cblp;
	WORD e_cp;
	WORD e_crlc;
	WORD e_cparhdr;
	WORD e_minalloc;
	WORD e_maxalloc;
	WORD e_ss;
	WORD e_sp;
	WORD e_csum;
	WORD e_ip;
	WORD e_cs;
	WORD e_lfarlc;
	WORD e_ovno;
	WORD e_res[4];
	WORD e_oemid;
	WORD e_oeminfo;
	WORD e_res2[10];
	LONG e_lfanew;
} IMAGE_DOS_HEADER,*PIMAGE_DOS_HEADER;
typedef struct _IMAGE_OS2_HEADER {
	WORD ne_magic;
	CHAR ne_ver;
	CHAR ne_rev;
	WORD ne_enttab;
	WORD ne_cbenttab;
	LONG ne_crc;
	WORD ne_flags;
	WORD ne_autodata;
	WORD ne_heap;
	WORD ne_stack;
	LONG ne_csip;
	LONG ne_sssp;
	WORD ne_cseg;
	WORD ne_cmod;
	WORD ne_cbnrestab;
	WORD ne_segtab;
	WORD ne_rsrctab;
	WORD ne_restab;
	WORD ne_modtab;
	WORD ne_imptab;
	LONG ne_nrestab;
	WORD ne_cmovent;
	WORD ne_align;
	WORD ne_cres;
	BYTE ne_exetyp;
	BYTE ne_flagsothers;
	WORD ne_pretthunks;
	WORD ne_psegrefbytes;
	WORD ne_swaparea;
	WORD ne_expver;
} IMAGE_OS2_HEADER,*PIMAGE_OS2_HEADER;
typedef struct _IMAGE_VXD_HEADER {
	WORD e32_magic;
	BYTE e32_border;
	BYTE e32_worder;
	DWORD e32_level;
	WORD e32_cpu;
	WORD e32_os;
	DWORD e32_ver;
	DWORD e32_mflags;
	DWORD e32_mpages;
	DWORD e32_startobj;
	DWORD e32_eip;
	DWORD e32_stackobj;
	DWORD e32_esp;
	DWORD e32_pagesize;
	DWORD e32_lastpagesize;
	DWORD e32_fixupsize;
	DWORD e32_fixupsum;
	DWORD e32_ldrsize;
	DWORD e32_ldrsum;
	DWORD e32_objtab;
	DWORD e32_objcnt;
	DWORD e32_objmap;
	DWORD e32_itermap;
	DWORD e32_rsrctab;
	DWORD e32_rsrccnt;
	DWORD e32_restab;
	DWORD e32_enttab;
	DWORD e32_dirtab;
	DWORD e32_dircnt;
	DWORD e32_fpagetab;
	DWORD e32_frectab;
	DWORD e32_impmod;
	DWORD e32_impmodcnt;
	DWORD e32_impproc;
	DWORD e32_pagesum;
	DWORD e32_datapage;
	DWORD e32_preload;
	DWORD e32_nrestab;
	DWORD e32_cbnrestab;
	DWORD e32_nressum;
	DWORD e32_autodata;
	DWORD e32_debuginfo;
	DWORD e32_debuglen;
	DWORD e32_instpreload;
	DWORD e32_instdemand;
	DWORD e32_heapsize;
	BYTE e32_res3[12];
	DWORD e32_winresoff;
	DWORD e32_winreslen;
	WORD e32_devid;
	WORD e32_ddkver;
} IMAGE_VXD_HEADER,*PIMAGE_VXD_HEADER;
typedef struct _IMAGE_FILE_HEADER {
	WORD Machine;
	WORD NumberOfSections;
	DWORD TimeDateStamp;
	DWORD PointerToSymbolTable;
	DWORD NumberOfSymbols;
	WORD SizeOfOptionalHeader;
	WORD Characteristics;
} IMAGE_FILE_HEADER,*PIMAGE_FILE_HEADER;
typedef struct _IMAGE_DATA_DIRECTORY {
	DWORD VirtualAddress;
	DWORD Size;
} IMAGE_DATA_DIRECTORY,*PIMAGE_DATA_DIRECTORY;
typedef struct _IMAGE_OPTIONAL_HEADER {
	WORD Magic;
	BYTE MajorLinkerVersion;
	BYTE MinorLinkerVersion;
	DWORD SizeOfCode;
	DWORD SizeOfInitializedData;
	DWORD SizeOfUninitializedData;
	DWORD AddressOfEntryPoint;
	DWORD BaseOfCode;
	DWORD BaseOfData;
	DWORD ImageBase;
	DWORD SectionAlignment;
	DWORD FileAlignment;
	WORD MajorOperatingSystemVersion;
	WORD MinorOperatingSystemVersion;
	WORD MajorImageVersion;
	WORD MinorImageVersion;
	WORD MajorSubsystemVersion;
	WORD MinorSubsystemVersion;
	DWORD Win32VersionValue;
	DWORD SizeOfImage;
	DWORD SizeOfHeaders;
	DWORD CheckSum;
	WORD Subsystem;
	WORD DllCharacteristics;
	DWORD SizeOfStackReserve;
	DWORD SizeOfStackCommit;
	DWORD SizeOfHeapReserve;
	DWORD SizeOfHeapCommit;
	DWORD LoaderFlags;
	DWORD NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER32,*PIMAGE_OPTIONAL_HEADER32;
typedef struct _IMAGE_OPTIONAL_HEADER64 {
	WORD	Magic;
	BYTE	MajorLinkerVersion;
	BYTE	MinorLinkerVersion;
	DWORD	SizeOfCode;
	DWORD	SizeOfInitializedData;
	DWORD	SizeOfUninitializedData;
	DWORD	AddressOfEntryPoint;
	DWORD	BaseOfCode;
	ULONGLONG	ImageBase;
	DWORD	SectionAlignment;
	DWORD	FileAlignment;
	WORD	MajorOperatingSystemVersion;
	WORD	MinorOperatingSystemVersion;
	WORD	MajorImageVersion;
	WORD	MinorImageVersion;
	WORD	MajorSubsystemVersion;
	WORD	MinorSubsystemVersion;
	DWORD	Win32VersionValue;
	DWORD	SizeOfImage;
	DWORD	SizeOfHeaders;
	DWORD	CheckSum;
	WORD	Subsystem;
	WORD	DllCharacteristics;
	ULONGLONG SizeOfStackReserve;
	ULONGLONG SizeOfStackCommit;
	ULONGLONG SizeOfHeapReserve;
	ULONGLONG SizeOfHeapCommit;
	DWORD	LoaderFlags;
	DWORD	NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;

typedef IMAGE_OPTIONAL_HEADER64 IMAGE_OPTIONAL_HEADER;
typedef PIMAGE_OPTIONAL_HEADER64 PIMAGE_OPTIONAL_HEADER;

#define IMAGE_SIZEOF_NT_OPTIONAL64_HEADER	240

typedef struct _IMAGE_NT_HEADERS64 {
	DWORD Signature;
	IMAGE_FILE_HEADER FileHeader;
	IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
	WORD Magic;
	BYTE MajorLinkerVersion;
	BYTE MinorLinkerVersion;
	DWORD SizeOfCode;
	DWORD SizeOfInitializedData;
	DWORD SizeOfUninitializedData;
	DWORD AddressOfEntryPoint;
	DWORD BaseOfCode;
	DWORD BaseOfData;
	DWORD BaseOfBss;
	DWORD GprMask;
	DWORD CprMask[4];
	DWORD GpValue;
} IMAGE_ROM_OPTIONAL_HEADER,*PIMAGE_ROM_OPTIONAL_HEADER;
#define IMAGE_SIZEOF_ROM_OPTIONAL_HEADER 56
#define IMAGE_SIZEOF_STD_OPTIONAL_HEADER 28
#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER 224
#define IMAGE_NT_OPTIONAL_HDR_MAGIC 0x10b
#define IMAGE_ROM_OPTIONAL_HDR_MAGIC 0x107
typedef struct _IMAGE_NT_HEADERS {
	DWORD Signature;
	IMAGE_FILE_HEADER FileHeader;
	IMAGE_OPTIONAL_HEADER OptionalHeader;
} IMAGE_NT_HEADERS,*PIMAGE_NT_HEADERS;
typedef IMAGE_NT_HEADERS IMAGE_NT_HEADERS32;
typedef IMAGE_NT_HEADERS32 *PIMAGE_NT_HEADERS32;
#define LPIMAGE_NT_HEADERS PIMAGE_NT_HEADERS;
typedef struct _IMAGE_ROM_HEADERS {
	IMAGE_FILE_HEADER FileHeader;
	IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
} IMAGE_ROM_HEADERS,*PIMAGE_ROM_HEADERS;
typedef struct _IMAGE_SECTION_HEADER {
	BYTE Name[IMAGE_SIZEOF_SHORT_NAME];
	union {
		DWORD PhysicalAddress;
		DWORD VirtualSize;
	} Misc;
	DWORD VirtualAddress;
	DWORD SizeOfRawData;
	DWORD PointerToRawData;
	DWORD PointerToRelocations;
	DWORD PointerToLinenumbers;
	WORD NumberOfRelocations;
	WORD NumberOfLinenumbers;
	DWORD Characteristics;
} IMAGE_SECTION_HEADER,*PIMAGE_SECTION_HEADER;
typedef struct _IMAGE_SYMBOL {
	union {
		BYTE ShortName[8];
		struct {
			DWORD Short;
			DWORD Long;
		} Name;
		PBYTE LongName[2];
	} N;
	DWORD Value;
	SHORT SectionNumber;
	WORD Type;
	BYTE StorageClass;
	BYTE NumberOfAuxSymbols;
} IMAGE_SYMBOL;
typedef IMAGE_SYMBOL *PIMAGE_SYMBOL;
typedef union _IMAGE_AUX_SYMBOL {
	struct {
		DWORD TagIndex;
		union {
			struct { WORD Linenumber; WORD Size; } LnSz;
			DWORD TotalSize;
		} Misc;
		union {
			struct {
				DWORD PointerToLinenumber;
				DWORD PointerToNextFunction;
			} Function;
			struct {
				WORD Dimension[4];
			} Array;
		} FcnAry;
		WORD TvIndex;
	} Sym;
	struct {
		BYTE Name[IMAGE_SIZEOF_SYMBOL];
	} File;
	struct {
		DWORD Length;
		WORD NumberOfRelocations;
		WORD NumberOfLinenumbers;
		DWORD CheckSum;
		SHORT Number;
		BYTE Selection;
	} Section;
} IMAGE_AUX_SYMBOL;
typedef IMAGE_AUX_SYMBOL *PIMAGE_AUX_SYMBOL;
typedef struct _IMAGE_RELOCATION {
#ifdef __LCC__ /* I do not support unnamed unions... jn */
	DWORD VirtualAddress;
#else
	union {
		DWORD VirtualAddress;
		DWORD RelocCount;
	};
#endif
	DWORD SymbolTableIndex;
	WORD Type;
} IMAGE_RELOCATION;
typedef IMAGE_RELOCATION *PIMAGE_RELOCATION;
typedef struct _IMAGE_BASE_RELOCATION {
	DWORD VirtualAddress;
	DWORD SizeOfBlock;
} IMAGE_BASE_RELOCATION,*PIMAGE_BASE_RELOCATION;
typedef struct _IMAGE_LINENUMBER {
	union {
		DWORD SymbolTableIndex;
		DWORD VirtualAddress;
	} Type;
	WORD Linenumber;
} IMAGE_LINENUMBER;
typedef IMAGE_LINENUMBER *PIMAGE_LINENUMBER;
typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
	BYTE Name[16];
	BYTE Date[12];
	BYTE UserID[6];
	BYTE GroupID[6];
	BYTE Mode[8];
	BYTE Size[10];
	BYTE EndHeader[2];
} IMAGE_ARCHIVE_MEMBER_HEADER,*PIMAGE_ARCHIVE_MEMBER_HEADER;
typedef struct _IMAGE_EXPORT_DIRECTORY {
	DWORD Characteristics;
	DWORD TimeDateStamp;
	WORD MajorVersion;
	WORD MinorVersion;
	DWORD Name;
	DWORD Base;
	DWORD NumberOfFunctions;
	DWORD NumberOfNames;
	DWORD AddressOfFunctions;
	DWORD AddressOfNames;
	DWORD AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY;

typedef struct _IMAGE_IMPORT_BY_NAME {
	WORD Hint;
	BYTE Name[1];
} IMAGE_IMPORT_BY_NAME,*PIMAGE_IMPORT_BY_NAME;
typedef struct _IMAGE_THUNK_DATA {
	union {
		PBYTE ForwarderString;
		PDWORD Function;
		DWORD Ordinal;
		PIMAGE_IMPORT_BY_NAME AddressOfData;
	} ;
} IMAGE_THUNK_DATA,*PIMAGE_THUNK_DATA;
typedef struct _IMAGE_THUNK_DATA64 {
	union {
		ULONGLONG ForwarderString;
		ULONGLONG Function;
		ULONGLONG Ordinal;
		ULONGLONG AddressOfData;
	};
} IMAGE_THUNK_DATA64;
typedef IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;
typedef struct _IMAGE_IMPORT_DESCRIPTOR {
	union {
		DWORD Characteristics;
		DWORD OriginalFirstThunk;
	} ;
	DWORD TimeDateStamp;
	DWORD ForwarderChain;
	DWORD Name;
	DWORD FirstThunk;
} IMAGE_IMPORT_DESCRIPTOR,*PIMAGE_IMPORT_DESCRIPTOR;
typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {
	DWORD TimeDateStamp;
	WORD OffsetModuleName;
	WORD NumberOfModuleForwarderRefs;
} IMAGE_BOUND_IMPORT_DESCRIPTOR,*PIMAGE_BOUND_IMPORT_DESCRIPTOR;
typedef struct _IMAGE_BOUND_FORWARDER_REF {
	DWORD TimeDateStamp;
	WORD OffsetModuleName;
	WORD Reserved;
} IMAGE_BOUND_FORWARDER_REF,*PIMAGE_BOUND_FORWARDER_REF;
typedef VOID ( *PIMAGE_TLS_CALLBACK)(PVOID,DWORD,PVOID);
typedef struct _IMAGE_TLS_DIRECTORY {
	DWORD StartAddressOfRawData;
	DWORD EndAddressOfRawData;
	PDWORD AddressOfIndex;
	PIMAGE_TLS_CALLBACK *AddressOfCallBacks;
	DWORD SizeOfZeroFill;
	DWORD Characteristics;
} IMAGE_TLS_DIRECTORY,*PIMAGE_TLS_DIRECTORY;
typedef struct _IMAGE_RESOURCE_DIRECTORY {
	DWORD Characteristics;
	DWORD TimeDateStamp;
	WORD MajorVersion;
	WORD MinorVersion;
	WORD NumberOfNamedEntries;
	WORD NumberOfIdEntries;
} IMAGE_RESOURCE_DIRECTORY,*PIMAGE_RESOURCE_DIRECTORY;
typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
	union {
		struct { unsigned NameOffset:31; unsigned NameIsString:1; };
		DWORD Name;
		WORD Id;
	} ;
	union {
		DWORD OffsetToData;
		struct { unsigned OffsetToDirectory:31; unsigned DataIsDirectory:1; };
	} ;
} IMAGE_RESOURCE_DIRECTORY_ENTRY,*PIMAGE_RESOURCE_DIRECTORY_ENTRY;
typedef struct _IMAGE_RESOURCE_DIRECTORY_STRING {
	WORD Length;
	CHAR NameString[1];
} IMAGE_RESOURCE_DIRECTORY_STRING,*PIMAGE_RESOURCE_DIRECTORY_STRING;
typedef struct _IMAGE_RESOURCE_DIR_STRING_U {
	WORD Length;
	WCHAR NameString[1];
} IMAGE_RESOURCE_DIR_STRING_U,*PIMAGE_RESOURCE_DIR_STRING_U;
typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
	DWORD OffsetToData;
	DWORD Size;
	DWORD CodePage;
	DWORD Reserved;
} IMAGE_RESOURCE_DATA_ENTRY,*PIMAGE_RESOURCE_DATA_ENTRY;
typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY {
	DWORD Characteristics;
	DWORD TimeDateStamp;
	WORD MajorVersion;
	WORD MinorVersion;
	DWORD GlobalFlagsClear;
	DWORD GlobalFlagsSet;
	DWORD CriticalSectionDefaultTimeout;
	DWORD DeCommitFreeBlockThreshold;
	DWORD DeCommitTotalFreeThreshold;
	PVOID LockPrefixTable;
	DWORD MaximumAllocationSize;
	DWORD VirtualMemoryThreshold;
	DWORD ProcessHeapFlags;
	DWORD Reserved[4];
} IMAGE_LOAD_CONFIG_DIRECTORY,*PIMAGE_LOAD_CONFIG_DIRECTORY;
typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
	DWORD BeginAddress;
	DWORD EndAddress;
	PVOID ExceptionHandler;
	PVOID HandlerData;
	DWORD PrologEndAddress;
} IMAGE_RUNTIME_FUNCTION_ENTRY,*PIMAGE_RUNTIME_FUNCTION_ENTRY;
typedef struct _IMAGE_DEBUG_DIRECTORY {
	DWORD Characteristics;
	DWORD TimeDateStamp;
	WORD MajorVersion;
	WORD MinorVersion;
	DWORD Type;
	DWORD SizeOfData;
	DWORD AddressOfRawData;
	DWORD PointerToRawData;
} IMAGE_DEBUG_DIRECTORY,*PIMAGE_DEBUG_DIRECTORY;
typedef struct _IMAGE_COFF_SYMBOLS_HEADER {
	DWORD NumberOfSymbols;
	DWORD LvaToFirstSymbol;
	DWORD NumberOfLinenumbers;
	DWORD LvaToFirstLinenumber;
	DWORD RvaToFirstByteOfCode;
	DWORD RvaToLastByteOfCode;
	DWORD RvaToFirstByteOfData;
	DWORD RvaToLastByteOfData;
} IMAGE_COFF_SYMBOLS_HEADER,*PIMAGE_COFF_SYMBOLS_HEADER;
#define FRAME_FPO 0
#define FRAME_TRAP 1
#define FRAME_TSS 2
#define FRAME_NONFPO 3
typedef struct _FPO_DATA {
	DWORD ulOffStart;
	DWORD cbProcSize;
	DWORD cdwLocals;
	WORD cdwParams;
	unsigned cbProlog:8;
	unsigned cbRegs:3;
	unsigned fHasSEH:1;
	unsigned fUseBP:1;
	unsigned reserved:1;
	unsigned cbFrame:2;
} FPO_DATA,*PFPO_DATA;
#define SIZEOF_RFPO_DATA 16
typedef struct _IMAGE_DEBUG_MISC {
	DWORD DataType;
	DWORD Length;
	BOOLEAN Unicode;
	BYTE Reserved[3];
	BYTE Data[1];
} IMAGE_DEBUG_MISC,*PIMAGE_DEBUG_MISC;
typedef struct _IMAGE_FUNCTION_ENTRY {
	DWORD StartingAddress;
	DWORD EndingAddress;
	DWORD EndOfPrologue;
} IMAGE_FUNCTION_ENTRY,*PIMAGE_FUNCTION_ENTRY;
typedef struct _IMAGE_SEPARATE_DEBUG_HEADER {
	WORD Signature;
	WORD Flags;
	WORD Machine;
	WORD Characteristics;
	DWORD TimeDateStamp;
	DWORD CheckSum;
	DWORD ImageBase;
	DWORD SizeOfImage;
	DWORD NumberOfSections;
	DWORD ExportedNamesSize;
	DWORD DebugDirectorySize;
	DWORD SectionAlignment;
	DWORD Reserved[2];
} IMAGE_SEPARATE_DEBUG_HEADER,*PIMAGE_SEPARATE_DEBUG_HEADER;
typedef int (CALLBACK *ENUMMETAFILEPROC)(HDC,HANDLETABLE *,METARECORD *,int,LPARAM);
typedef int (CALLBACK *ENHMETAFILEPROC) (HDC,HANDLETABLE,ENHMETARECORD,int,LPARAM);
typedef int (CALLBACK *ENUMFONTSPROC) (LPLOGFONT,LPTEXTMETRIC,DWORD,LPARAM);
typedef int (CALLBACK *FONTENUMPROC)(ENUMLOGFONT *,NEWTEXTMETRIC *,int,LPARAM);
typedef int (CALLBACK *FONTENUMEXPROC)(ENUMLOGFONTEX *,NEWTEXTMETRICEX *,int,LPARAM);
typedef VOID(CALLBACK *LPOVERLAPPED_COMPLETION_ROUTINE)(DWORD,DWORD,LPOVERLAPPED);
typedef int (CALLBACK* ENHMFENUMPROC)(HDC,HANDLETABLE *,ENHMETARECORD *,int,LPARAM);
typedef int (CALLBACK* MFENUMPROC)(HDC,HANDLETABLE *,METARECORD *,int,LPARAM);
typedef struct _NT_TIB {
	struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;
	PVOID StackBase;
	PVOID StackLimit;
	PVOID SubSystemTib;
	union { PVOID FiberData; DWORD Version; };
	PVOID ArbitraryUserPointer;
	struct _NT_TIB *Self;
} NT_TIB;
typedef NT_TIB *PNT_TIB;
#define THREAD_BASE_PRIORITY_LOWRT	15
#define THREAD_BASE_PRIORITY_MAX	2
#define THREAD_BASE_PRIORITY_MIN	-2
#define THREAD_BASE_PRIORITY_IDLE	-15
#pragma pack(push,8)
typedef struct _QUOTA_LIMITS {
	SIZE_T PagedPoolLimit;
	SIZE_T NonPagedPoolLimit;
	SIZE_T MinimumWorkingSetSize;
	SIZE_T MaximumWorkingSetSize;
	SIZE_T PagefileLimit;
	LARGE_INTEGER TimeLimit;
} QUOTA_LIMITS, *PQUOTA_LIMITS;
#pragma pack(pop)
#define QUOTA_LIMITS_HARDWS_MIN_ENABLE	1
#define QUOTA_LIMITS_HARDWS_MIN_DISABLE 2
#define QUOTA_LIMITS_HARDWS_MAX_ENABLE	4
#define QUOTA_LIMITS_HARDWS_MAX_DISABLE 8
typedef struct _QUOTA_LIMITS_EX {
	SIZE_T PagedPoolLimit;
	SIZE_T NonPagedPoolLimit;
	SIZE_T MinimumWorkingSetSize;
	SIZE_T MaximumWorkingSetSize;
	SIZE_T PagefileLimit;
	LARGE_INTEGER TimeLimit;
	SIZE_T Reserved1;
	SIZE_T Reserved2;
	SIZE_T Reserved3;
	SIZE_T Reserved4;
	DWORD Flags;
	DWORD Reserved5;
} QUOTA_LIMITS_EX, *PQUOTA_LIMITS_EX;
typedef struct _IO_COUNTERS {
	ULONGLONG ReadOperationCount;
	ULONGLONG WriteOperationCount;
	ULONGLONG OtherOperationCount;
	ULONGLONG ReadTransferCount;
	ULONGLONG WriteTransferCount;
	ULONGLONG OtherTransferCount;
} IO_COUNTERS;
typedef IO_COUNTERS *PIO_COUNTERS;
typedef struct _JOBOBJECT_BASIC_LIMIT_INFORMATION {
	LARGE_INTEGER PerProcessUserTimeLimit;
	LARGE_INTEGER PerJobUserTimeLimit;
	DWORD LimitFlags;
	SIZE_T MinimumWorkingSetSize;
	SIZE_T MaximumWorkingSetSize;
	DWORD ActiveProcessLimit;
	ULONG_PTR Affinity;
	DWORD PriorityClass;
	DWORD SchedulingClass;
} JOBOBJECT_BASIC_LIMIT_INFORMATION, *PJOBOBJECT_BASIC_LIMIT_INFORMATION;
typedef struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
	JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
	DWORD align;
	IO_COUNTERS IoInfo;
	SIZE_T ProcessMemoryLimit;
	SIZE_T JobMemoryLimit;
	SIZE_T PeakProcessMemoryUsed;
	SIZE_T PeakJobMemoryUsed;
} JOBOBJECT_EXTENDED_LIMIT_INFORMATION, *PJOBOBJECT_EXTENDED_LIMIT_INFORMATION;
typedef struct _JOBOBJECT_BASIC_PROCESS_ID_LIST {
	DWORD NumberOfAssignedProcesses;
	DWORD NumberOfProcessIdsInList;
	ULONG_PTR ProcessIdList[1];
} JOBOBJECT_BASIC_PROCESS_ID_LIST, *PJOBOBJECT_BASIC_PROCESS_ID_LIST;
typedef struct _JOBOBJECT_BASIC_UI_RESTRICTIONS {
	DWORD UIRestrictionsClass;
} JOBOBJECT_BASIC_UI_RESTRICTIONS, *PJOBOBJECT_BASIC_UI_RESTRICTIONS;
typedef struct _JOBOBJECT_SECURITY_LIMIT_INFORMATION {
	DWORD SecurityLimitFlags ;
	HANDLE JobToken ;
	PTOKEN_GROUPS SidsToDisable ;
	PTOKEN_PRIVILEGES PrivilegesToDelete ;
	PTOKEN_GROUPS RestrictedSids ;
} JOBOBJECT_SECURITY_LIMIT_INFORMATION, *PJOBOBJECT_SECURITY_LIMIT_INFORMATION ;
typedef struct _JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
	DWORD EndOfJobTimeAction;
} JOBOBJECT_END_OF_JOB_TIME_INFORMATION, *PJOBOBJECT_END_OF_JOB_TIME_INFORMATION;
typedef struct _JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
	PVOID CompletionKey;
	HANDLE CompletionPort;
} JOBOBJECT_ASSOCIATE_COMPLETION_PORT, *PJOBOBJECT_ASSOCIATE_COMPLETION_PORT;
typedef struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
	LARGE_INTEGER TotalUserTime;
	LARGE_INTEGER TotalKernelTime;
	LARGE_INTEGER ThisPeriodTotalUserTime;
	LARGE_INTEGER ThisPeriodTotalKernelTime;
	DWORD TotalPageFaultCount;
	DWORD TotalProcesses;
	DWORD ActiveProcesses;
	DWORD TotalTerminatedProcesses;
} JOBOBJECT_BASIC_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION;
typedef struct _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
	JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
	IO_COUNTERS IoInfo;
} JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;
typedef struct _JOBOBJECT_JOBSET_INFORMATION {
	DWORD MemberLevel;
} JOBOBJECT_JOBSET_INFORMATION, *PJOBOBJECT_JOBSET_INFORMATION;
#define JOB_OBJECT_TERMINATE_AT_END_OF_JOB 0
#define JOB_OBJECT_POST_AT_END_OF_JOB	1
typedef struct tagPIXELFORMATDESCRIPTOR {
	WORD	nSize;
	WORD	nVersion;
	DWORD	dwFlags;
	BYTE	iPixelType;
	BYTE	cColorBits;
	BYTE	cRedBits;
	BYTE	cRedShift;
	BYTE	cGreenBits;
	BYTE	cGreenShift;
	BYTE	cBlueBits;
	BYTE	cBlueShift;
	BYTE	cAlphaBits;
	BYTE	cAlphaShift;
	BYTE	cAccumBits;
	BYTE	cAccumRedBits;
	BYTE	cAccumGreenBits;
	BYTE	cAccumBlueBits;
	BYTE	cAccumAlphaBits;
	BYTE	cDepthBits;
	BYTE	cStencilBits;
	BYTE	cAuxBuffers;
	BYTE	iLayerType;
	BYTE	bReserved;
	DWORD	dwLayerMask;
	DWORD	dwVisibleMask;
	DWORD	dwDamageMask;
} PIXELFORMATDESCRIPTOR,*PPIXELFORMATDESCRIPTOR,*LPPIXELFORMATDESCRIPTOR;
typedef struct _WIN_CERTIFICATE {
	DWORD	dwLength;
	WORD	wRevision;
	WORD	wCertificateType;
	BYTE	bCertificate[1];
} WIN_CERTIFICATE,*LPWIN_CERTIFICATE;
#define WIN_CERT_REVISION_1_0	0x100
#define WIN_CERT_TYPE_X509 1
#define WIN_CERT_TYPE_PKCS_SIGNED_DATA	2
#define WIN_CERT_TYPE_RESERVED_1	3
typedef LPVOID WIN_TRUST_SUBJECT;
typedef struct _WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT {
	HANDLE	hClientToken;
	GUID	*SubjectType;
	WIN_TRUST_SUBJECT Subject;
} WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT,*LPWIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT;
typedef struct _WIN_TRUST_ACTDATA_SUBJECT_ONLY {
	GUID	*SubjectType;
	WIN_TRUST_SUBJECT Subject;
} WIN_TRUST_ACTDATA_SUBJECT_ONLY,*LPWIN_TRUST_ACTDATA_SUBJECT_ONLY;
#define WIN_TRUST_SUBJTYPE_RAW_FILE {0x959dc450,0x8d9e,0x11cf,{0x87,0x36,0,0xaa,0,0xa4,0x85,0xeb}}
#define WIN_TRUST_SUBJTYPE_PE_IMAGE {0x43c9a1e0,0x8da0,0x11cf,{0x87,0x36,0,0xaa,0,0xa4,0x85,0xeb}}
#define WIN_TRUST_SUBJTYPE_OLE_STORAGE {0xc257e740,0x8da0,0x11cf,{0x87,0x36,0,0xaa,0,0xa4,0x85,0xeb}}
#define WIN_TRUST_SUBJTYPE_JAVA_CLASS {0x08ad3990,0x8da1,0x11cf,{0x87,0x36,0,0xaa,0,0xa4,0x85,0xeb}}
typedef struct _WIN_TRUST_SUBJECT_FILE {
	HANDLE hFile; LPCWSTR lpPath;
} WIN_TRUST_SUBJECT_FILE,*LPWIN_TRUST_SUBJECT_FILE;
/* TrustedPublisher == 66426730-8da1-11cf-8736-00aa00a485eb */
#define WIN_SPUB_ACTION_TRUSTED_PUBLISHER {0x66426730,0x8da1,0x11cf,{0x87,0x36,0,0xaa,0,0xa4,0x85,0xeb}}
#define WIN_SPUB_ACTION_NT_ACTIVATE_IMAGE {0x8bc96b00,0x8da1,0x11cf,{0x87,0x36,0,0xaa,0,0xa4,0x85,0xeb}}
#define WIN_SPUB_ACTION_PUBLISHED_SOFTWARE {0x64b9d180,0x8da2,0x11cf,{0x87,0x36,0,0xaa,0,0xa4,0x85,0xeb}}
typedef struct _WIN_SPUB_TRUSTED_PUBLISHER_DATA { HANDLE hClientToken;
	LPWIN_CERTIFICATE	lpCertificate;
} WIN_SPUB_TRUSTED_PUBLISHER_DATA,*LPWIN_SPUB_TRUSTED_PUBLISHER_DATA;
typedef VOID (WINAPI *PFIBER_START_ROUTINE)(LPVOID);
typedef PFIBER_START_ROUTINE LPFIBER_START_ROUTINE;
typedef struct tagNMDATETIMECHANGE {
 NMHDR nmhdr;
 DWORD dwFlags;
 SYSTEMTIME st;
} NMDATETIMECHANGE,*LPNMDATETIMECHANGE;
typedef struct tagNMDATETIMESTRINGA {
 NMHDR nmhdr;
 LPCSTR pszUserString;
 SYSTEMTIME st;
 DWORD dwFlags;
} NMDATETIMESTRINGA,FAR * LPNMDATETIMESTRINGA;
typedef struct tagNMDATETIMESTRINGW {
 NMHDR nmhdr;
 LPCWSTR pszUserString;
 SYSTEMTIME st;
 DWORD dwFlags;
} NMDATETIMESTRINGW,* LPNMDATETIMESTRINGW;
typedef struct tagNMDATETIMEWMKEYDOWNA {
	NMHDR	nmhdr;
	int	nVirtKey;
	LPCSTR	pszFormat;
	SYSTEMTIME	st;
} NMDATETIMEWMKEYDOWNA,* LPNMDATETIMEWMKEYDOWNA;
typedef struct tagNMDATETIMEWMKEYDOWNW {
	NMHDR	nmhdr;
	int	nVirtKey;
	LPCWSTR	pszFormat;
	SYSTEMTIME	st;
} NMDATETIMEWMKEYDOWNW,* LPNMDATETIMEWMKEYDOWNW;
typedef struct tagNMDATETIMEFORMATA {
	NMHDR	nmhdr;
	LPCSTR	pszFormat;
	SYSTEMTIME st;
	LPCSTR pszDisplay;
	CHAR szDisplay[64];
} NMDATETIMEFORMATA,* LPNMDATETIMEFORMATA;
typedef struct tagNMDATETIMEFORMATW {
	NMHDR nmhdr;
	LPCWSTR pszFormat;
	SYSTEMTIME st;
	LPCWSTR pszDisplay;
	WCHAR szDisplay[64];
} NMDATETIMEFORMATW,* LPNMDATETIMEFORMATW;
typedef struct tagNMDATETIMEFORMATQUERYA {
	NMHDR nmhdr;
	LPCSTR pszFormat;
	SIZE szMax;
} NMDATETIMEFORMATQUERYA,* LPNMDATETIMEFORMATQUERYA;
typedef struct tagNMDATETIMEFORMATQUERYW {
	NMHDR nmhdr;
	LPCWSTR pszFormat;
	SIZE szMax;
} NMDATETIMEFORMATQUERYW,* LPNMDATETIMEFORMATQUERYW;
typedef struct _COAUTHIDENTITY {
	USHORT *User;
	ULONG UserLength;
	USHORT *Domain;
	ULONG DomainLength;
	USHORT *Password;
	ULONG PasswordLength;
	ULONG Flags;
} COAUTHIDENTITY;
typedef struct _COAUTHINFO {
	DWORD dwAuthnSvc;
	DWORD dwAuthzSvc;
	LPWSTR pwszServerPrincName;
	DWORD dwAuthnLevel;
	DWORD dwImpersonationLevel;
	COAUTHIDENTITY *pAuthIdentityData;
	DWORD dwCapabilities;
} COAUTHINFO;
typedef WCHAR OLECHAR;
typedef struct _userCLIPFORMAT {
	long fContext;
	union __MIDL_IWinTypes_0001 {
		DWORD dwValue;
		short *pwszName;
	} u;
} userCLIPFORMAT;
typedef struct _userBITMAP {
	LONG bmType;
	LONG bmWidth;
	LONG bmHeight;
	LONG bmWidthBytes;
	WORD bmPlanes;
	WORD bmBitsPixel;
	ULONG cbSize;
	UCHAR pBuffer[1];
} userBITMAP;
typedef struct _userHBITMAP {
	long fContext;
	union __MIDL_IWinTypes_0007 {
		long hInproc;
		userBITMAP *hRemote;
		long hGlobal;
	} u;
} userHBITMAP;
typedef struct tagrpcLOGPALETTE {
	WORD palVersion;
	WORD palNumEntries;
	PALETTEENTRY palPalEntry[1];
} rpcLOGPALETTE;
typedef struct _FLAGGED_BYTE_BLOB {
	unsigned long fFlags;
	unsigned long clSize;
	BYTE abData[1];
} FLAGGED_BYTE_BLOB;
typedef struct _BYTE_BLOB {
	unsigned long clSize;
	BYTE abData[1];
} BYTE_BLOB;
typedef struct _userHMETAFILE {
	long fContext;
	union __MIDL_IWinTypes_0004 {
		long hInproc;
		BYTE_BLOB *hRemote;
		long hGlobal;
	} u;
} userHMETAFILE;
typedef struct _remoteMETAFILEPICT {
	long mm;
	long xExt;
	long yExt;
	userHMETAFILE *hMF;
} remoteMETAFILEPICT;
typedef struct _userHENHMETAFILE {
	long fContext;
	union __MIDL_IWinTypes_0006 {
		long hInproc;
		BYTE_BLOB *hRemote;
		long hGlobal;
	} u;
} userHENHMETAFILE;
typedef struct _userHMETAFILEPICT {
	long fContext;
	union __MIDL_IWinTypes_0005 {
		long hInproc;
		remoteMETAFILEPICT *hRemote;
		long hGlobal;
	} u;
} userHMETAFILEPICT;
typedef struct _userHGLOBAL {
	long fContext;
	union __MIDL_IWinTypes_0003 {
		long hInproc;
		FLAGGED_BYTE_BLOB *hRemote;
		long hGlobal;
	} u;
} userHGLOBAL;
typedef struct _userHPALETTE {
	long fContext;
	union __MIDL_IWinTypes_0008 {
		long hInproc;
		rpcLOGPALETTE *hRemote;
		long hGlobal;
	} u;
} userHPALETTE;
#ifndef _tagBSTRBLOB_DEFINED
#define _tagBSTRBLOB_DEFINED
typedef struct tagBSTRBLOB {
	ULONG cbSize;
	BYTE *pData;
} BSTRBLOB;
typedef struct tagBSTRBLOB *LPBSTRBLOB;
#endif
typedef struct _CLIPDATA {
	ULONG cbSize;
	long ulClipFmt;
	BYTE *pClipData;
} CLIPDATA;
typedef struct _FLAGGED_WORD_BLOB {
	unsigned long fFlags;
	unsigned long clSize;
	unsigned short asData[1];
}FLAGGED_WORD_BLOB;
typedef struct _BYTE_SIZEDARR {
	unsigned long clSize;
	unsigned char *pData;
}BYTE_SIZEDARR;
typedef struct _SHORT_SIZEDARR {
	unsigned long clSize;
	unsigned short *pData;
} WORD_SIZEDARR;
typedef struct _LONG_SIZEDARR {
	unsigned long clSize;
	unsigned long *pData;
}DWORD_SIZEDARR;
typedef struct _HYPER_SIZEDARR {
	unsigned long clSize;
	long long int *pData;
}HYPER_SIZEDARR;
typedef FLAGGED_WORD_BLOB *wireBSTR;
typedef userHENHMETAFILE *wireHENHMETAFILE;
typedef userHGLOBAL *wireHGLOBAL;
typedef userHMETAFILEPICT wireHMETAFILEPICT;
typedef userHMETAFILE *wireHMETAFILE;
typedef userHPALETTE *wireHPALETTE;
typedef userHBITMAP *wireHBITMAP;
typedef userCLIPFORMAT *wireCLIPFORMAT;
typedef WORD CLIPFORMAT;
typedef unsigned long PROPID;
typedef OLECHAR *LPOLESTR;
typedef GUID FMTID;
typedef FMTID *REFFMTID;
typedef enum _CLASSPATHTYPE { ExeNamePath=0,DllNamePath=ExeNamePath+1,TlbNamePath=DllNamePath+1,
	CabFilePath=TlbNamePath+1,InfFilePath=CabFilePath+1,DrwFilePath=InfFilePath+1,
	SetupNamePath=DrwFilePath+1 } CLASSPATHTYPE;
typedef struct __MIDL___MIDL_itf_wtypes_0002_0001 {
	DWORD tyspec;
	union __MIDL___MIDL_itf_wtypes_0002_00 {
		CLSID clsid;
		IID iid;
		GUID typelibID;
		LPOLESTR pFileExt;
		LPOLESTR pMimeType;
		LPOLESTR pProgId;
		LPOLESTR pFileName;
		LPOLESTR pJavaClassName;
		struct { LPOLESTR pPackageName; GUID PolicyId;} ByName;
		struct { LPOLESTR pScriptName; GUID PolicyId;} ByScript;
	} tagged_union;
} uCLSSPEC;
typedef struct _CSPLATFORM {
	DWORD dwPlatformId;
	DWORD dwVersionHi;
	DWORD dwVersionLo;
	DWORD dwProcessorArch;
} CSPLATFORM;
typedef struct _QUERYCONTEXT {
	DWORD dwContext;
	CSPLATFORM Platform;
	LCID Locale;
	DWORD dwVersionHi;
	DWORD dwVersionLo;
} QUERYCONTEXT;
typedef struct _CLASSDETAIL {
	CLSID Clsid;
	CLSID TreatAs;
	DWORD cProgId;
	DWORD dwComClassContext;
	LPOLESTR *prgProgId;
} CLASSDETAIL;
typedef struct _ACTIVATIONINFO {
	UINT cClasses;
	CLASSDETAIL *pClasses;
	UINT cShellFileExt;
	LPOLESTR *prgShellFileExt;
	UINT *prgPriority;
	UINT cInterfaces;
	IID *prgInterfaceId;
	UINT cTypeLib;
	GUID *prgTlbId;
} ACTIVATIONINFO;
typedef struct _PLATFORMINFO {
	UINT cPlatforms;
	CSPLATFORM *prgPlatform;
 UINT cLocales;
	LCID *prgLocale;
} PLATFORMINFO;
typedef struct tagINSTALLINFO {
	DWORD dwActFlags;
	CLASSPATHTYPE PathType;
	LPOLESTR pszScriptPath;
	LPOLESTR pszSetupCommand;
	LPOLESTR pszUrl;
	ULONGLONG Usn;
	UINT InstallUiLevel;
	GUID *pClsid;
	GUID ProductCode;
	GUID Mvipc;
	DWORD dwVersionHi;
	DWORD dwVersionLo;
	DWORD dwRevision;
	UINT cUpgrades;
	LPOLESTR *prgUpgradeScript;
	DWORD *prgUpgradeFlag;
	ULONG cScriptLen;
}INSTALLINFO;
typedef struct tagPACKAGEDETAIL {
	LPOLESTR pszPackageName;
	LPOLESTR pszPublisher;
	UINT cSources;
	LPOLESTR *pszSourceList;
	UINT cCategories;
	GUID *rpCategory;
	ACTIVATIONINFO *pActInfo;
	PLATFORMINFO *pPlatformInfo;
	INSTALLINFO *pInstallInfo;
} PACKAGEDETAIL;
typedef struct tagTRACKMOUSEEVENT {
	DWORD cbSize;
	DWORD dwFlags;
	HWND hwndTrack;
	DWORD dwHoverTime;
} TRACKMOUSEEVENT, *LPTRACKMOUSEEVENT;
typedef struct tagREBARINFO {
	UINT cbSize;
	UINT fMask;
	HANDLE himl;
} REBARINFO,*LPREBARINFO;
typedef struct tagREBARBANDINFOA {
	UINT cbSize;
	UINT fMask;
	UINT fStyle;
	COLORREF clrFore;
	COLORREF clrBack;
	LPSTR lpText;
	UINT cch;
	int iImage;
	HWND hwndChild;
	UINT cxMinChild;
	UINT cyMinChild;
	UINT cx;
	HBITMAP hbmBack;
	UINT wID;
	UINT cyChild;
	UINT cyMaxChild;
	UINT cyIntegral;
	UINT cxIdeal;
	LPARAM lParam;
	UINT cxHeader;
} REBARBANDINFOA,*LPREBARBANDINFOA;
typedef REBARBANDINFOA CONST *LPCREBARBANDINFOA;
typedef struct tagREBARBANDINFOW {
	UINT	cbSize;
	UINT	fMask;
	UINT	fStyle;
	COLORREF	clrFore;
	COLORREF	clrBack;
	LPWSTR	lpText;
	UINT	cch;
	int	iImage;
	HWND	hwndChild;
	UINT	cxMinChild;
	UINT	cyMinChild;
	UINT	cx;
	HBITMAP	hbmBack;
	UINT	wID;
	UINT	cyChild;
	UINT	cyMaxChild;
	UINT	cyIntegral;
	UINT	cxIdeal;
	LPARAM	lParam;
	UINT	cxHeader;
} REBARBANDINFOW, *LPREBARBANDINFOW;
typedef REBARBANDINFOW CONST *LPCREBARBANDINFOW;
typedef struct tagLVITEMA {
	UINT mask;
	int iItem;
	int iSubItem;
	UINT state;
	UINT stateMask;
	LPSTR pszText;
	int cchTextMax;
	int iImage;
	LPARAM lParam;
	int iIndent;
} LVITEMA, *LPLVITEMA;
typedef struct tagLVITEMW {
	UINT mask;
	int iItem;
	int iSubItem;
	UINT state;
	UINT stateMask;
	LPWSTR pszText;
	int cchTextMax;
	int iImage;
	LPARAM lParam;
	int iIndent;
} LVITEMW, *LPLVITEMW;
typedef struct tagLVDISPINFO {
	NMHDR hdr;
	LVITEMA item;
} NMLVDISPINFOA, *LPNMLVDISPINFOA;
typedef struct tagLVDISPINFOW {
	NMHDR hdr;
	LVITEMW item;
} NMLVDISPINFOW, *LPNMLVDISPINFOW;
#define LVN_KEYDOWN	(-155)
#define LV_KEYDOWN NMLVKEYDOWN
typedef struct tagLVKEYDOWN {
	NMHDR hdr;
	WORD wVKey;
	UINT flags;
} NMLVKEYDOWN, *LPNMLVKEYDOWN;
#define LVN_MARQUEEBEGIN	(-156)
typedef struct tagNMLVGETINFOTIPA {
	NMHDR hdr;
	DWORD dwFlags;
	LPSTR pszText;
	int cchTextMax;
	int iItem;
	int iSubItem;
	LPARAM lParam;
} NMLVGETINFOTIPA, *LPNMLVGETINFOTIPA;
typedef struct tagNMLVGETINFOTIPW {
	NMHDR hdr;
	DWORD dwFlags;
	LPWSTR pszText;
	int cchTextMax;
	int iItem;
	int iSubItem;
	LPARAM lParam;
} NMLVGETINFOTIPW, *LPNMLVGETINFOTIPW;
#define LVGIT_UNFOLDED	1
#define LVN_GETINFOTIPA (-157)
#define LVN_GETINFOTIPW (-158)
typedef struct tagNMMOUSE {
	NMHDR	hdr;
	DWORD_PTR dwItemSpec;
	DWORD_PTR dwItemData;
	POINT	pt;
	LPARAM dwHitInfo;
} NMMOUSE, *LPNMMOUSE;
typedef NMMOUSE NMCLICK;
typedef LPNMMOUSE LPNMCLICK;
typedef struct tagNMLVCACHEHINT {
	NMHDR hdr;
	int iFrom;
	int iTo;
} NMLVCACHEHINT,*LPNMLVCACHEHINT;
typedef struct tagCOLORSCHEME {
	DWORD	dwSize;
	COLORREF	clrBtnHighlight;
	COLORREF	clrBtnShadow;
} COLORSCHEME, *LPCOLORSCHEME;
#define LPNM_CACHEHINT	LPNMLVCACHEHINT
#define PNM_CACHEHINT	LPNMLVCACHEHINT
#define NM_CACHEHINT	NMLVCACHEHINT
typedef struct tagLVFINDINFOA {
	UINT flags;
	LPCSTR psz;
	LPARAM lParam;
	POINT pt;
	UINT vkDirection;
} LVFINDINFOA, *LPFINDINFOA;
typedef struct tagLVFINDINFOW {
	UINT flags;
	LPCWSTR psz;
	LPARAM lParam;
	POINT pt;
	UINT vkDirection;
} LVFINDINFOW, *LPFINDINFOW;
typedef struct tagNMLVFINDITEM {
	NMHDR hdr;
	int iStart;
	LVFINDINFO lvfi;
} NMLVFINDITEM, *LPNMLVFINDITEM;
#define PNM_FINDITEM LPNMLVFINDITEM
#define LPNM_FINDITEM LPNMLVFINDITEM
#define NM_FINDITEM NMLVFINDITEM
typedef struct tagNMLVODSTATECHANGE {
	NMHDR hdr;
	int iFrom;
	int iTo;
	UINT uNewState;
	UINT uOldState;
} NMLVODSTATECHANGE, *LPNMLVODSTATECHANGE;
#define PNM_ODSTATECHANGE LPNMLVODSTATECHANGE
#define LPNM_ODSTATECHANGE LPNMLVODSTATECHANGE
#define NM_ODSTATECHANGE NMLVODSTATECHANGE
#define IID_NULL	GUID_NULL
#define CLSID_NULL	GUID_NULL
#define FMTID_NULL	GUID_NULL
typedef struct tagNMITEMACTIVATE{
	NMHDR	hdr;
	int	iItem;
	int	iSubItem;
	UINT	uNewState;
	UINT	uOldState;
	UINT	uChanged;
	POINT	ptAction;
	LPARAM	lParam;
	UINT	uKeyFlags;
} NMITEMACTIVATE, *LPNMITEMACTIVATE;
typedef struct _LVHITTESTINFO {
	POINT pt;
	UINT flags;
	int iItem;
	int iSubItem;
} LVHITTESTINFO, *LPLVHITTESTINFO;
typedef struct tagCOMBOBOXINFO {
	DWORD cbSize;
	RECT rcItem;
	RECT rcButton;
	DWORD stateButton;
	HWND hwndCombo;
	HWND hwndItem;
	HWND hwndList;
} COMBOBOXINFO, *PCOMBOBOXINFO, *LPCOMBOBOXINFO;
typedef struct tagWINDOWINFO {
	DWORD cbSize;
	RECT rcWindow;
	RECT rcClient;
	DWORD dwStyle;
	DWORD dwExStyle;
	DWORD dwWindowStatus;
	UINT cxWindowBorders;
	UINT cyWindowBorders;
	ATOM atomWindowType;
	WORD wCreatorVersion;
} WINDOWINFO, *PWINDOWINFO, *LPWINDOWINFO;
typedef VOID (APIENTRY *PAPCFUNC)(ULONG *);
#define INPUT_MOUSE	0
#define INPUT_KEYBOARD	1
#define INPUT_HARDWARE	2
typedef struct tagMOUSEINPUT {
	LONG	dx;
	LONG	dy;
	DWORD	mouseData;
	DWORD	dwFlags;
	DWORD	time;
	DWORD	dwExtraInfo;
} MOUSEINPUT, *PMOUSEINPUT, * LPMOUSEINPUT;
typedef struct tagHARDWAREINPUT {
	DWORD	uMsg;
	WORD	wParamL;
	WORD	wParamH;
} HARDWAREINPUT, *PHARDWAREINPUT, *LPHARDWAREINPUT;
typedef struct tagKEYBDINPUT {
	WORD	wVk;
	WORD	wScan;
	DWORD	dwFlags;
	DWORD	time;
	DWORD	dwExtraInfo;
} KEYBDINPUT, *PKEYBDINPUT, FAR* LPKEYBDINPUT;
typedef struct tagINPUT {
	DWORD	type;
	union {
		MOUSEINPUT	mi;
		KEYBDINPUT	ki;
		HARDWAREINPUT	hi;
	};
} INPUT, *PINPUT, *LPINPUT;
typedef struct tagMENUBARINFO {
	DWORD cbSize;
	RECT rcBar;
	HMENU hMenu;
	HWND hwndMenu;
	BOOL fBarFocused:1;
	BOOL fFocused:1;
} MENUBARINFO, *PMENUBARINFO, *LPMENUBARINFO;
typedef struct tagSCROLLBARINFO {
	DWORD	cbSize;
	RECT	rcScrollBar;
	int	dxyLineButton;
	int	xyThumbTop;
	int	xyThumbBottom;
	int	reserved;
	DWORD rgstate[CCHILDREN_SCROLLBAR+1];
} SCROLLBARINFO, *PSCROLLBARINFO, *LPSCROLLBARINFO;
typedef struct tagTITLEBARINFO {
	DWORD	cbSize;
	RECT	rcTitleBar;
	DWORD	rgstate[CCHILDREN_TITLEBAR+1];
} TITLEBARINFO, *PTITLEBARINFO, *LPTITLEBARINFO;
typedef struct tagCURSORINFO {
	DWORD	cbSize;
	DWORD	flags;
	HCURSOR hCursor;
	POINT	ptScreenPos;
} CURSORINFO, *PCURSORINFO, *LPCURSORINFO;
typedef struct {
	NMHDR hdr;
	int	iItemid;
	WCHAR szText[CBEMAXSTRLEN];
}NMCBEDRAGBEGINW, *LPNMCBEDRAGBEGINW, *PNMCBEDRAGBEGINW;
typedef struct {
	NMHDR hdr;
	int	iItemid;
	char szText[CBEMAXSTRLEN];
}NMCBEDRAGBEGINA, *LPNMCBEDRAGBEGINA, *PNMCBEDRAGBEGINA;
typedef struct {
	NMHDR hdr;
	BOOL fChanged;
	int iNewSelection;
	WCHAR szText[CBEMAXSTRLEN];
	int iWhy;
} NMCBEENDEDITW, *LPNMCBEENDEDITW, *PNMCBEENDEDITW;

typedef struct {
	NMHDR hdr;
	BOOL fChanged;
	int iNewSelection;
	char szText[CBEMAXSTRLEN];
	int iWhy;
} NMCBEENDEDITA, *LPNMCBEENDEDITA,*PNMCBEENDEDITA;
typedef struct tagCOMBOBOXEXITEMA {
	UINT mask;
	int iItem;
	LPSTR pszText;
	int cchTextMax;
	int iImage;
	int iSelectedImage;
	int iOverlay;
	int iIndent;
	LPARAM lParam;
} COMBOBOXEXITEMA, *PCOMBOBOXEXITEMA;
typedef COMBOBOXEXITEMA CONST *PCCOMBOEXITEMA;
typedef struct tagCOMBOBOXEXITEMW {
	UINT mask;
	int iItem;
	LPWSTR pszText;
	int cchTextMax;
	int iImage;
	int iSelectedImage;
	int iOverlay;
	int iIndent;
	LPARAM lParam;
} COMBOBOXEXITEMW, *PCOMBOBOXEXITEMW;
typedef COMBOBOXEXITEMW CONST *PCCOMBOEXITEMW;
typedef struct tagNMHDDISPINFOW {
	NMHDR	hdr;
	int	iItem;
	UINT	mask;
	LPWSTR pszText;
	int	cchTextMax;
	int	iImage;
	LPARAM lParam;
} NMHDDISPINFOW, *LPNMHDDISPINFOW;
typedef struct tagNMHDDISPINFOA {
	NMHDR	hdr;
	int	iItem;
	UINT	mask;
	LPSTR	pszText;
	int	cchTextMax;
	int	iImage;
	LPARAM lParam;
} NMHDDISPINFOA,*LPNMHDDISPINFOA;
#ifdef UNICODE
#define NMHDDISPINFO	NMHDDISPINFOW
#define LPNMHDDISPINFO	LPNMHDDISPINFOW
#else
#define NMHDDISPINFO	NMHDDISPINFOA
#define LPNMHDDISPINFO	LPNMHDDISPINFOA
#endif
typedef enum _JOBOBJECTINFOCLASS { JobObjectBasicAccountingInformation = 1,
	JobObjectBasicLimitInformation, JobObjectBasicProcessIdList,
	JobObjectBasicUIRestrictions, JobObjectSecurityLimitInformation,
	JobObjectEndOfJobTimeInformation, JobObjectAssociateCompletionPortInformation,
	JobObjectBasicAndIoAccountingInformation, JobObjectExtendedLimitInformation,
	JobObjectJobSetInformation, MaxJobObjectInfoClass
} JOBOBJECTINFOCLASS;
typedef struct tagPDA {
	DWORD lStructSize;
	HWND hwndOwner;
	HGLOBAL hDevMode;
	HGLOBAL hDevNames;
	HDC hDC;
	DWORD Flags;
	WORD nFromPage;
	WORD nToPage;
	WORD nMinPage;
	WORD nMaxPage;
	WORD nCopies;
	HINSTANCE hInstance;
	LPARAM lCustData;
	LPPRINTHOOKPROC lpfnPrintHook;
	LPSETUPHOOKPROC lpfnSetupHook;
	LPCSTR lpPrintTemplateName;
	LPCSTR lpSetupTemplateName;
	HGLOBAL hPrintTemplate;
	HGLOBAL hSetupTemplate;
} PRINTDLGA, *LPPRINTDLGA;
typedef struct tagPDW {
	DWORD lStructSize;
	HWND hwndOwner;
	HGLOBAL hDevMode;
	HGLOBAL hDevNames;
	HDC	hDC;
	DWORD Flags;
	WORD nFromPage;
	WORD nToPage;
	WORD nMinPage;
	WORD nMaxPage;
	WORD nCopies;
	HINSTANCE hInstance;
	LPARAM lCustData;
	LPPRINTHOOKPROC lpfnPrintHook;
	LPSETUPHOOKPROC lpfnSetupHook;
	LPCWSTR lpPrintTemplateName;
	LPCWSTR lpSetupTemplateName;
	HGLOBAL hPrintTemplate;
	HGLOBAL		hSetupTemplate;
} PRINTDLGW, *LPPRINTDLGW;
typedef struct tagHW_PROFILE_INFOA {
	DWORD dwDockInfo; CHAR szHwProfileGuid[HW_PROFILE_GUIDLEN];
	CHAR	szHwProfileName[MAX_PROFILE_LEN];
} HW_PROFILE_INFOA, *LPHW_PROFILE_INFOA;
typedef struct tagHW_PROFILE_INFOW {
	DWORD dwDockInfo;
	WCHAR szHwProfileGuid[HW_PROFILE_GUIDLEN];
	WCHAR szHwProfileName[MAX_PROFILE_LEN];
} HW_PROFILE_INFOW, *LPHW_PROFILE_INFOW;
typedef struct _FILE_NOTIFY_INFORMATION {
	DWORD NextEntryOffset;
	DWORD Action;
	DWORD FileNameLength;
	WCHAR FileName[1];
} FILE_NOTIFY_INFORMATION, *PFILE_NOTIFY_INFORMATION;
typedef union _FILE_SEGMENT_ELEMENT {
	long long * Buffer;
	long long Alignment;
}FILE_SEGMENT_ELEMENT, *PFILE_SEGMENT_ELEMENT;
typedef struct tagALTTABINFO {
	DWORD	cbSize;
	int	cItems;
	int	cColumns;
	int	cRows;
	int	iColFocus;
	int	iRowFocus;
	int	cxItem;
	int	cyItem;
	POINT	ptStart;
} ALTTABINFO, *PALTTABINFO, *LPALTTABINFO;
typedef VOID (CALLBACK* WINEVENTPROC)(HWINEVENTHOOK,DWORD,HWND,LONG,LONG,DWORD,DWORD);
typedef VOID (APIENTRY *PTIMERAPCROUTINE)(LPVOID,DWORD,DWORD);
typedef enum _FINDEX_INFO_LEVELS { FindExInfoStandard, FindExInfoMaxInfoLevel } FINDEX_INFO_LEVELS;
typedef enum _FINDEX_SEARCH_OPS { FindExSearchNameMatch, FindExSearchLimitToDirectories, FindExSearchLimitToDevices, FindExSearchMaxSearchOp } FINDEX_SEARCH_OPS;
typedef struct { UINT cbSize; POINT pt; UINT uHit; SYSTEMTIME st; } MCHITTESTINFO, *PMCHITTESTINFO;
typedef struct tagNMSELCHANGE { NMHDR nmhdr;SYSTEMTIME stSelStart; SYSTEMTIME stSelEnd; } NMSELCHANGE, *LPNMSELCHANGE;
typedef struct tagNMDAYSTATE { NMHDR nmhdr; SYSTEMTIME stStart; int cDayState; LPMONTHDAYSTATE prgDayState; } NMDAYSTATE,*LPNMDAYSTATE;
#ifdef UNICODE
typedef HW_PROFILE_INFOW HW_PROFILE_INFO;
typedef LPHW_PROFILE_INFOW LPHW_PROFILE_INFO;
typedef PRINTDLGW PRINTDLG;
typedef LPPRINTDLGW LPPRINTDLG;
#else
typedef HW_PROFILE_INFOA HW_PROFILE_INFO;
typedef LPHW_PROFILE_INFOA LPHW_PROFILE_INFO;
typedef PRINTDLGA PRINTDLG;
typedef LPPRINTDLGA LPPRINTDLG;
#endif
typedef struct tagGUITHREADINFO {
	DWORD cbSize;
	DWORD flags;
	HWND hwndActive;
	HWND hwndFocus;
	HWND hwndCapture;
	HWND hwndMenuOwner;
	HWND hwndMoveSize;
	HWND hwndCaret;
	RECT rcCaret;
} GUITHREADINFO, *PGUITHREADINFO, *LPGUITHREADINFO;
#define GUI_CARETBLINKING	1
#define GUI_INMOVESIZE	2
#define GUI_INMENUMODE	4
#define GUI_SYSTEMMENUMODE 8
#define GUI_POPUPMENUMODE	16
typedef struct tagLVCOLUMNA {
	UINT mask;
	int fmt;
	int cx;
	LPSTR pszText;
	int cchTextMax;
	int iSubItem;
	int iImage;
	int iOrder;
} LVCOLUMNA, *LPLVCOLUMNA;
typedef struct tagLVCOLUMNW {
	UINT mask;
	int fmt;
	int cx;
	LPWSTR pszText;
	int cchTextMax;
	int iSubItem;
	int iImage;
	int iOrder;
} LVCOLUMNW, *LPLVCOLUMNW;
typedef struct {UINT cbSize; HWND hwnd; DWORD dwFlags; UINT uCount; DWORD dwTimeout; } FLASHWINFO, *PFLASHWINFO;
typedef enum _GET_FILEEX_INFO_LEVELS { GetFileExInfoStandard, GetFileExMaxInfoLevel } GET_FILEEX_INFO_LEVELS;
typedef struct _BLENDFUNCTION {
	BYTE	BlendOp;
	BYTE	BlendFlags;
	BYTE	SourceConstantAlpha;
	BYTE	AlphaFormat;
}BLENDFUNCTION,*PBLENDFUNCTION;
typedef struct _WIN32_FILE_ATTRIBUTE_DATA {
	DWORD dwFileAttributes;
	FILETIME ftCreationTime;
	FILETIME ftLastAccessTime;
	FILETIME ftLastWriteTime;
	DWORD nFileSizeHigh;
	DWORD nFileSizeLow;
} WIN32_FILE_ATTRIBUTE_DATA,*LPWIN32_FILE_ATTRIBUTE_DATA;
typedef VOID (WINAPI *PFLS_CALLBACK_FUNCTION)(PVOID);
typedef USHORT COLOR16;
typedef struct _TRIVERTEX {LONG x; LONG y; COLOR16 Red; COLOR16 Green;
COLOR16 Blue; COLOR16 Alpha; }TRIVERTEX,*PTRIVERTEX,*LPTRIVERTEX;
typedef struct _GRADIENT_TRIANGLE { ULONG Vertex1; ULONG Vertex2; ULONG Vertex3;
} GRADIENT_TRIANGLE,*PGRADIENT_TRIANGLE,*LPGRADIENT_TRIANGLE;
typedef struct _GRADIENT_RECT { ULONG UpperLeft; ULONG LowerRight;
}GRADIENT_RECT,*PGRADIENT_RECT,*LPGRADIENT_RECT;
typedef struct _OBJECT_TYPE_LIST { WORD Level; WORD Sbz; GUID *ObjectType; } OBJECT_TYPE_LIST, *POBJECT_TYPE_LIST;
typedef enum _AUDIT_EVENT_TYPE { AuditEventObjectAccess, AuditEventDirectoryServiceAccess } AUDIT_EVENT_TYPE, *PAUDIT_EVENT_TYPE;
typedef ACE_HEADER *PACE_HEADER;
typedef struct tagMENUINFO {
	DWORD cbSize;
	DWORD fMask;
	DWORD dwStyle;
	UINT cyMax;
	HBRUSH hbrBack;
	DWORD dwContextHelpID;
	ULONG_PTR dwMenuData;
} MENUINFO, *LPMENUINFO;
typedef MENUINFO CONST *LPCMENUINFO;
typedef struct tagMENUGETOBJECTINFO {
	DWORD dwFlags;
	UINT uPos;
	HMENU hmenu;
	PVOID riid;
	PVOID pvObj;
} MENUGETOBJECTINFO, *PMENUGETOBJECTINFO;
typedef struct _JOB_SET_ARRAY {
	HANDLE JobHandle;
	DWORD MemberLevel;
	DWORD Flags;
} JOB_SET_ARRAY, *PJOB_SET_ARRAY;
typedef enum _LOGICAL_PROCESSOR_RELATIONSHIP {
RelationProcessorCore, RelationNumaNode
} LOGICAL_PROCESSOR_RELATIONSHIP;
typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
	ULONG_PTR  ProcessorMask;
	LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
	union {
		struct {
			BYTE Flags;
		} ProcessorCore;
		struct {
			DWORD NodeNumber;
		} NumaNode;
		ULONGLONG Reserved[2];
	};
} SYSTEM_LOGICAL_PROCESSOR_INFORMATION, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION;
typedef LONG (NTAPI *PVECTORED_EXCEPTION_HANDLER)(struct _EXCEPTION_POINTERS *);
typedef struct tagACTCTX_SECTION_KEYED_DATA_2600 {
	ULONG cbSize;
	ULONG ulDataFormatVersion;
	PVOID lpData;
	ULONG ulLength;
	PVOID lpSectionGlobalData;
	ULONG ulSectionGlobalDataLength;
	PVOID lpSectionBase;
	ULONG ulSectionTotalLength;
	HANDLE hActCtx;
	ULONG ulAssemblyRosterIndex;
} ACTCTX_SECTION_KEYED_DATA_2600, *PACTCTX_SECTION_KEYED_DATA_2600;
typedef const ACTCTX_SECTION_KEYED_DATA_2600 * PCACTCTX_SECTION_KEYED_DATA_2600;

typedef struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {
	PVOID lpInformation;
	PVOID lpSectionBase;
	ULONG ulSectionLength;
	PVOID lpSectionGlobalDataBase;
	ULONG ulSectionGlobalDataLength;
} ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA, *PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
typedef const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA *PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
typedef struct tagACTCTX_SECTION_KEYED_DATA {
	ULONG cbSize;
	ULONG ulDataFormatVersion;
	PVOID lpData;
	ULONG ulLength;
	PVOID lpSectionGlobalData;
	ULONG ulSectionGlobalDataLength;
	PVOID lpSectionBase;
	ULONG ulSectionTotalLength;
	HANDLE hActCtx;
	ULONG ulAssemblyRosterIndex;
// 2600 stops here
	ULONG ulFlags;
	ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA AssemblyMetadata;
} ACTCTX_SECTION_KEYED_DATA, *PACTCTX_SECTION_KEYED_DATA;
typedef const ACTCTX_SECTION_KEYED_DATA * PCACTCTX_SECTION_KEYED_DATA;
typedef struct _EVENTLOG_FULL_INFORMATION { DWORD   dwFull; }
EVENTLOG_FULL_INFORMATION, *LPEVENTLOG_FULL_INFORMATION;
#define FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX 1
#define FIND_ACTCTX_SECTION_KEY_RETURN_FLAGS 2
#define FIND_ACTCTX_SECTION_KEY_RETURN_ASSEMBLY_METADATA 4
typedef enum _COMPUTER_NAME_FORMAT {
   ComputerNameNetBIOS, ComputerNameDnsHostname, ComputerNameDnsDomain,
   ComputerNameDnsFullyQualified, ComputerNamePhysicalNetBIOS, ComputerNamePhysicalDnsHostname,
   ComputerNamePhysicalDnsDomain, ComputerNamePhysicalDnsFullyQualified, ComputerNameMax
} COMPUTER_NAME_FORMAT ;
typedef enum _STREAM_INFO_LEVELS { FindStreamInfoStandard, FindStreamInfoMaxInfoLevel
} STREAM_INFO_LEVELS;
typedef struct _WIN32_FIND_DATAA {
	DWORD dwFileAttributes;
	FILETIME ftCreationTime;
	FILETIME ftLastAccessTime;
	FILETIME ftLastWriteTime;
	DWORD nFileSizeHigh;
	DWORD nFileSizeLow;
	DWORD dwReserved0;
	DWORD dwReserved1;
	CHAR  cFileName[ MAX_PATH ];
	CHAR  cAlternateFileName[ 14 ];
} WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;
typedef struct _WIN32_FIND_DATAW {
	DWORD dwFileAttributes;
	FILETIME ftCreationTime;
	FILETIME ftLastAccessTime;
	FILETIME ftLastWriteTime;
	DWORD nFileSizeHigh;
	DWORD nFileSizeLow;
	DWORD dwReserved0;
	DWORD dwReserved1;
	WCHAR cFileName[ MAX_PATH ];
	WCHAR cAlternateFileName[ 14 ];
} WIN32_FIND_DATAW, *PWIN32_FIND_DATAW, *LPWIN32_FIND_DATAW;
#define RTL_CRITSECT_TYPE 0
#define RTL_RESOURCE_TYPE 1
typedef struct _RTL_CRITICAL_SECTION {
	PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
	LONG LockCount;
	LONG RecursionCount;
	HANDLE OwningThread;
	HANDLE LockSemaphore;
	ULONG_PTR SpinCount;
} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;
typedef RTL_CRITICAL_SECTION CRITICAL_SECTION;
typedef RTL_CRITICAL_SECTION *LPCRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION_DEBUG LPCRITICAL_SECTION_DEBUG;
typedef enum _HEAP_INFORMATION_CLASS { HeapCompatibilityInformation } HEAP_INFORMATION_CLASS;
typedef enum { WinNullSid=0,WinWorldSid=1, WinLocalSid=2, WinCreatorOwnerSid=3,
 WinCreatorGroupSid=4, WinCreatorOwnerServerSid=5, WinCreatorGroupServerSid=6,
 WinNtAuthoritySid=7, WinDialupSid=8, WinNetworkSid=9, WinBatchSid=10,
 WinInteractiveSid=11, WinServiceSid=12, WinAnonymousSid=13, WinProxySid=14,
 WinEnterpriseControllersSid=15, WinSelfSid=16, WinAuthenticatedUserSid=17,
 WinRestrictedCodeSid=18, WinTerminalServerSid=19, WinRemoteLogonIdSid=20,
 WinLogonIdsSid=21, WinLocalSystemSid=22, WinLocalServiceSid=23,
 WinNetworkServiceSid=24, WinBuiltinDomainSid=25, WinBuiltinAdministratorsSid=26,
 WinBuiltinUsersSid=27, WinBuiltinGuestsSid=28, WinBuiltinPowerUsersSid=29,
 WinBuiltinAccountOperatorsSid=30, WinBuiltinSystemOperatorsSid=31,
 WinBuiltinPrintOperatorsSid=32, WinBuiltinBackupOperatorsSid=33,
 WinBuiltinReplicatorSid=34, WinBuiltinPreWindows2000CompatibleAccessSid=35,
 WinBuiltinRemoteDesktopUsersSid=36, WinBuiltinNetworkConfigurationOperatorsSid=37,
 WinAccountAdministratorSid=38, WinAccountGuestSid=39, WinAccountKrbtgtSid=40,
 WinAccountDomainAdminsSid=41, WinAccountDomainUsersSid=42, WinAccountDomainGuestsSid=43,
 WinAccountComputersSid=44, WinAccountControllersSid=45, WinAccountCertAdminsSid=46,
 WinAccountSchemaAdminsSid=47, WinAccountEnterpriseAdminsSid=48,
 WinAccountPolicyAdminsSid=49, WinAccountRasAndIasServersSid=50,
 WinNTLMAuthenticationSid=51, WinDigestAuthenticationSid=52,
 WinSChannelAuthenticationSid=53, WinThisOrganizationSid=54, WinOtherOrganizationSid=55,
 WinBuiltinIncomingForestTrustBuildersSid=56, WinBuiltinPerfMonitoringUsersSid=57,
 WinBuiltinPerfLoggingUsersSid=58, WinBuiltinAuthorizationAccessSid=59,
 WinBuiltinTerminalServerLicenseServersSid=60
} WELL_KNOWN_SID_TYPE;
typedef enum _MEMORY_RESOURCE_NOTIFICATION_TYPE { LowMemoryResourceNotification,
HighMemoryResourceNotification } MEMORY_RESOURCE_NOTIFICATION_TYPE;
typedef struct _WIN32_FIND_STREAM_DATA {
	LARGE_INTEGER StreamSize;
	WCHAR cStreamName[ MAX_PATH + 36 ];
} WIN32_FIND_STREAM_DATA, *PWIN32_FIND_STREAM_DATA;
typedef BOOL (WINAPI* PGET_MODULE_HANDLE_EXA)(DWORD,LPCSTR,HMODULE*);
typedef BOOL (WINAPI* PGET_MODULE_HANDLE_EXW)(DWORD,LPCWSTR,HMODULE*);
typedef DWORD (WINAPI *PFE_EXPORT_FUNC)(PBYTE,PVOID,ULONG);
typedef DWORD (WINAPI *PFE_IMPORT_FUNC)(PBYTE,PVOID,PULONG);
typedef struct tagNMTTCUSTOMDRAW {
	NMCUSTOMDRAW nmcd;
	UINT uDrawFlags;
} NMTTCUSTOMDRAW, *LPNMTTCUSTOMDRAW;
typedef struct _IMAGELISTDRAWPARAMS {
	DWORD cbSize;
	HIMAGELIST himl;
	int i;
	HDC hdcDst;
	int x;
	int y;
	int cx;
	int cy;
	int xBitmap;
	int yBitmap;
	COLORREF rgbBk;
	COLORREF rgbFg;
	UINT fStyle;
	DWORD dwRop;
#if (_WIN32_IE >= 0x501)
	DWORD fState;
	DWORD Frame;
	COLORREF crEffect;
#endif
} IMAGELISTDRAWPARAMS, *LPIMAGELISTDRAWPARAMS;
#ifndef __ISequentialStream_INTERFACE_DEFINED__
#define __ISequentialStream_INTERFACE_DEFINED__
struct ISequentialStream { const struct ISequentialStreamVtbl *lpVtbl; };
#endif
typedef struct _HD_TEXTFILTERA {
	LPSTR pszText;
	INT cchTextMax;
} HD_TEXTFILTERA, *LPHD_TEXTFILTERA;
typedef struct _HD_TEXTFILTERW {
	LPWSTR pszText;
	INT cchTextMax;
} HD_TEXTFILTERW, *LPHD_TEXTFILTERW;
typedef struct {
	UINT cbSize;
	DWORD dwMask;
	int cxPad;
	int cyPad;
	int cxBarPad;
	int cyBarPad;
	int cxButtonSpacing;
	int cyButtonSpacing;
} TBMETRICS, * LPTBMETRICS;
typedef struct tagNMTBSAVE {
	NMHDR hdr;
	DWORD* pData;
	DWORD* pCurrent;
	UINT cbData;
	int iItem;
	int cButtons;
	TBBUTTON tbButton;
} NMTBSAVE, *LPNMTBSAVE;
typedef struct tagNMTBRESTORE {
	NMHDR hdr;
	DWORD* pData;
	DWORD* pCurrent;
	UINT cbData;
	int iItem;
	int cButtons;
	int cbBytesPerRecord;
	TBBUTTON tbButton;
} NMTBRESTORE, *LPNMTBRESTORE;
typedef struct tagNMREBARCHILDSIZE {
	NMHDR hdr;
	UINT uBand;
	UINT wID;
	RECT rcChild;
	RECT rcBand;
} NMREBARCHILDSIZE, *LPNMREBARCHILDSIZE;
typedef struct tagNMREBAR {
	NMHDR  hdr;
	DWORD  dwMask;
	UINT   uBand;
	UINT   fStyle;
	UINT   wID;
	LPARAM lParam;
} NMREBAR, *LPNMREBAR;
typedef struct tagLVGROUPMETRICS {
	UINT cbSize;
	UINT mask;
	UINT Left;
	UINT Top;
	UINT Right;
	UINT Bottom;
	COLORREF crLeft;
	COLORREF crTop;
	COLORREF crRight;
	COLORREF crBottom;
	COLORREF crHeader;
	COLORREF crFooter;
} LVGROUPMETRICS, *PLVGROUPMETRICS;
typedef struct tagLVGROUP {
	UINT cbSize;
	UINT mask;
	LPWSTR pszHeader;
	int cchHeader;
	LPWSTR pszFooter;
	int cchFooter;
	int iGroupId;
	UINT stateMask;
	UINT state;
	UINT uAlign;
} LVGROUP, *PLVGROUP;
typedef int (CALLBACK *PFNLVGROUPCOMPARE)(int, int, void *);
typedef struct tagLVINSERTGROUPSORTED {
	PFNLVGROUPCOMPARE pfnGroupCompare;
	void *pvData;
	LVGROUP lvGroup;
}LVINSERTGROUPSORTED, *PLVINSERTGROUPSORTED;
typedef struct tagLVTILEVIEWINFO {
	UINT cbSize;
	DWORD dwMask;
	DWORD dwFlags;
	SIZE sizeTile;
	int cLines;
	RECT rcLabelMargin;
} LVTILEVIEWINFO, *PLVTILEVIEWINFO;
typedef struct {
	UINT cbSize;
	DWORD dwFlags;
	int iItem;
	DWORD dwReserved;
} LVINSERTMARK, * LPLVINSERTMARK;
typedef struct tagLVSETINFOTIP {
	UINT cbSize;
	DWORD dwFlags;
	LPWSTR pszText;
	int iItem;
	int iSubItem;
} LVSETINFOTIP, *PLVSETINFOTIP;
typedef struct {
	HIMAGELIST himl;
	RECT margin;
	UINT uAlign;
} BUTTON_IMAGELIST, *PBUTTON_IMAGELIST;
typedef struct tagNMBCHOTITEM {
	NMHDR hdr;
	DWORD dwFlags;
} NMBCHOTITEM, *LPNMBCHOTITEM;
typedef struct _tagEDITBALLOONTIP {
	DWORD  cbStruct;
	LPCWSTR pszTitle;
	LPCWSTR pszText;
	INT   ttiIcon;
} EDITBALLOONTIP, *PEDITBALLOONTIP;
typedef struct tagNMHDFILTERBTNCLICK {
	NMHDR hdr;
	INT iItem;
	RECT rc;
} NMHDFILTERBTNCLICK, *LPNMHDFILTERBTNCLICK;
typedef struct tagNMRBAUTOSIZE {
	NMHDR hdr;
	BOOL fChanged;
	RECT rcTarget;
	RECT rcActual;
} NMRBAUTOSIZE, *LPNMRBAUTOSIZE;
typedef struct tagNMREBARCHEVRON {
	NMHDR hdr;
	UINT uBand;
	UINT wID;
	LPARAM lParam;
	RECT rc;
	LPARAM lParamNM;
} NMREBARCHEVRON, *LPNMREBARCHEVRON;
typedef struct tagNMREBARAUTOBREAK {
	NMHDR hdr;
	UINT uBand;
	UINT wID;
	LPARAM lParam;
	UINT uMsg;
	UINT fStyleCurrent;
	BOOL fAutoBreak;
} NMREBARAUTOBREAK, *LPNMREBARAUTOBREAK;
typedef struct _RB_HITTESTINFO {
	POINT pt;
	UINT flags;
	int iBand;
} RBHITTESTINFO, *LPRBHITTESTINFO;
typedef struct _TTGETTITLE {
	DWORD dwSize;
	UINT uTitleBitmap;
	UINT cch;
	WCHAR* pszTitle;
} TTGETTITLE, *PTTGETTITLE;
typedef struct _DRAWPATRECT {
	POINT ptPosition;
	POINT ptSize;
	WORD wStyle;
	WORD wPattern;
} DRAWPATRECT, *PDRAWPATRECT;
typedef struct _PSINJECTDATA {
	DWORD	DataBytes;
	WORD	InjectionPoint;
	WORD   PageNumber;
} PSINJECTDATA, *PPSINJECTDATA;
typedef struct _PSFEATURE_OUTPUT {
	BOOL bPageIndependent;
	BOOL bSetPageDevice;
} PSFEATURE_OUTPUT, *PPSFEATURE_OUTPUT;
typedef struct _PSFEATURE_CUSTPAPER {
	LONG lOrientation;
	LONG lWidth;
	LONG lHeight;
	LONG lWidthOffset;
	LONG lHeightOffset;
} PSFEATURE_CUSTPAPER, *PPSFEATURE_CUSTPAPER;
typedef struct tagWCRANGE {
	WCHAR wcLow;
	USHORT cGlyphs;
} WCRANGE, *PWCRANGE,*LPWCRANGE;
typedef struct tagGLYPHSET {
	DWORD   cbThis;
	DWORD   flAccel;
	DWORD   cGlyphsSupported;
	DWORD   cRanges;
	WCRANGE ranges[1];
} GLYPHSET, *PGLYPHSET, *LPGLYPHSET;
typedef struct _WGLSWAP {
	HDC hdc;
	UINT uiFlags;
} WGLSWAP, *PWGLSWAP, *LPWGLSWAP;
typedef struct tagLITEM {
	UINT	mask ;
	int	iLink ;
	UINT	state ;
	UINT	stateMask ;
	WCHAR	szID[MAX_LINKID_TEXT] ;
	WCHAR	szUrl[L_MAX_URL_LENGTH] ;
} LITEM, * PLITEM ;
typedef struct tagNMLINK {
	NMHDR hdr;
	LITEM item ;
} NMLINK, *PNMLINK;
typedef struct tagUPDATELAYEREDWINDOWINFO {
	DWORD	cbSize;
	HDC	hdcDst;
	POINT	*pptDst;
	SIZE	*psize;
	HDC	hdcSrc;
	POINT	*pptSrc;
	COLORREF	crKey;
	BLENDFUNCTION	 *pblend;
	DWORD	dwFlags;
	RECT	*prcDirty;
} UPDATELAYEREDWINDOWINFO, *PUPDATELAYEREDWINDOWINFO;
typedef struct tagLASTINPUTINFO { UINT cbSize; DWORD dwTime; } LASTINPUTINFO,*PLASTINPUTINFO;
/* Functions.h Declarations for all the WIN32 Functions */
BOOL WINAPI GetLastInputInfo(PLASTINPUTINFO);
DWORD WINAPI GetClipboardSequenceNumber(void);
BOOL WINAPI UpdateLayeredWindow(HWND,HDC,POINT *,SIZE *,HDC,POINT *,COLORREF,BLENDFUNCTION *,DWORD);
UINT WINAPI GetEnhMetaFilePixelFormat(HENHMETAFILE,UINT,PIXELFORMATDESCRIPTOR *);
BOOL WINAPI ColorCorrectPalette(HDC,HPALETTE,DWORD,DWORD);
DWORD WINAPI ReadEncryptedFileRaw(PFE_EXPORT_FUNC,PVOID,PVOID);
DWORD WINAPI WriteEncryptedFileRaw(PFE_IMPORT_FUNC,PVOID,PVOID);
VOID WINAPI CloseEncryptedFileRaw(PVOID);
BOOLEAN WINAPI Wow64EnableWow64FsRedirection(BOOLEAN);
BOOL WINAPI FileEncryptionStatusA(LPCSTR,LPDWORD);
BOOL WINAPI FileEncryptionStatusW(LPCWSTR,LPDWORD);
BOOL WINAPI AddAuditAccessAceEx(PACL,DWORD,DWORD,DWORD,PSID,BOOL,BOOL);
BOOL WINAPI AddAccessDeniedObjectAce(PACL,DWORD,DWORD,DWORD,GUID *,GUID *,PSID);
BOOL WINAPI AddAuditAccessObjectAce(PACL,DWORD,DWORD,DWORD,GUID *,GUID *,PSID,BOOL,BOOL);
BOOL WINAPI ZombifyActCtx(HANDLE);
HANDLE WINAPI CreateActCtxA(PCACTCTXA);
HANDLE WINAPI CreateActCtxW(PCACTCTXW);
VOID WINAPI AddRefActCtx(HANDLE);
VOID WINAPI ReleaseActCtx(HANDLE);
BOOL WINAPI ActivateActCtx(HANDLE,ULONG_PTR *);
BOOL WINAPI DeactivateActCtx(DWORD,ULONG_PTR);
BOOL WINAPI GetCurrentActCtx(HANDLE *);
BOOL WINAPI SetThreadStackGuarantee(PULONG);
BOOL WINAPI SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR,SECURITY_DESCRIPTOR_CONTROL,SECURITY_DESCRIPTOR_CONTROL);
BOOL WINAPI SetPrivateObjectSecurityEx(SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR *,ULONG,PGENERIC_MAPPING,HANDLE);
BOOL WINAPI MakeAbsoluteSD2(PSECURITY_DESCRIPTOR,LPDWORD);
BOOL WINAPI TzSpecificLocalTimeToSystemTime(LPTIME_ZONE_INFORMATION,LPSYSTEMTIME,LPSYSTEMTIME);
BOOL WINAPI IsTokenRestricted(HANDLE);
DWORD WINAPI GetThreadId(HANDLE);
BOOL WINAPI GetThreadIOPendingFlag(HANDLE,PBOOL);
LPVOID WINAPI CreateFiberEx(SIZE_T,SIZE_T,DWORD,LPFIBER_START_ROUTINE,LPVOID);
LPVOID WINAPI ConvertThreadToFiberEx(LPVOID,DWORD);
BOOL WINAPI ConvertFiberToThread(VOID);
BOOL WINAPI IsWellKnownSid (PSID, WELL_KNOWN_SID_TYPE);
HANDLE WINAPI CreateMemoryResourceNotification(MEMORY_RESOURCE_NOTIFICATION_TYPE);
BOOL WINAPI QueryMemoryResourceNotification(HANDLE,PBOOL);
DWORD WINAPI OpenEncryptedFileRawA(LPCSTR,ULONG,PVOID *);
DWORD WINAPI OpenEncryptedFileRawW(LPCWSTR,ULONG,PVOID *);
BOOL WINAPI IsTokenUntrusted(HANDLE);
BOOL APIENTRY CheckTokenMembership(HANDLE,PSID,PBOOL);
BOOL WINAPI NeedCurrentDirectoryForExePathA(LPCSTR);
BOOL WINAPI NeedCurrentDirectoryForExePathW(LPCWSTR);
HANDLE WINAPI OpenWaitableTimerA(DWORD,BOOL,LPCSTR);
HANDLE WINAPI OpenWaitableTimerW(DWORD,BOOL,LPCWSTR);
BOOL WINAPI SetFirmwareEnvironmentVariableA(LPCSTR,LPCSTR,PVOID,DWORD);
BOOL WINAPI SetFirmwareEnvironmentVariableW(LPCWSTR,LPCWSTR,PVOID,DWORD);
DWORD WINAPI GetFirmwareEnvironmentVariableA(LPCSTR,LPCSTR,PVOID,DWORD);
DWORD WINAPI GetFirmwareEnvironmentVariableW(LPCWSTR,LPCWSTR,PVOID,DWORD);
BOOL WINAPI GetWindowsAccountDomainSid(PSID,PSID,DWORD *);
BOOL WINAPI EqualDomainSid(PSID,PSID,BOOL *);
BOOL WINAPI CreatePrivateObjectSecurityEx(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR,
	PSECURITY_DESCRIPTOR *,GUID *,BOOL,ULONG,HANDLE,PGENERIC_MAPPING);
BOOL WINAPI CreatePrivateObjectSecurityWithMultipleInheritance(PSECURITY_DESCRIPTOR,
	PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR *,GUID **,ULONG,BOOL,ULONG,
	HANDLE,PGENERIC_MAPPING);
BOOL WINAPI CreateWellKnownSid(WELL_KNOWN_SID_TYPE,PSID,PSID,DWORD *);
BOOL WINAPI AccessCheckByTypeResultListAndAuditAlarmByHandleA(LPCSTR,LPVOID,HANDLE,LPCSTR,
	LPCSTR,PSECURITY_DESCRIPTOR,PSID,DWORD,AUDIT_EVENT_TYPE,DWORD,POBJECT_TYPE_LIST,
	DWORD,PGENERIC_MAPPING,BOOL,LPDWORD,LPDWORD,LPBOOL);
BOOL WINAPI AccessCheckByTypeResultListAndAuditAlarmByHandleW(LPCWSTR,LPVOID,HANDLE,LPCWSTR,
	LPCWSTR,PSECURITY_DESCRIPTOR,PSID,DWORD,AUDIT_EVENT_TYPE,DWORD,POBJECT_TYPE_LIST,
	DWORD,PGENERIC_MAPPING,BOOL,LPDWORD,LPDWORD,LPBOOL);
BOOL WINAPI AccessCheckByTypeResultListAndAuditAlarmA(LPCSTR,LPVOID,LPCSTR,LPCSTR,
	PSECURITY_DESCRIPTOR,PSID,DWORD,AUDIT_EVENT_TYPE,DWORD,POBJECT_TYPE_LIST,
	DWORD,PGENERIC_MAPPING,BOOL,LPDWORD,LPDWORD,LPBOOL);
BOOL WINAPI AccessCheckByTypeResultListAndAuditAlarmW(LPCWSTR,LPVOID,LPCWSTR,LPCWSTR,
	PSECURITY_DESCRIPTOR,PSID,DWORD,AUDIT_EVENT_TYPE,DWORD,POBJECT_TYPE_LIST,
	DWORD,PGENERIC_MAPPING,BOOL,LPDWORD,LPDWORD,LPBOOL);
BOOL WINAPI CheckNameLegalDOS8Dot3A(LPCSTR,LPSTR,DWORD,PBOOL,PBOOL);
BOOL WINAPI CheckNameLegalDOS8Dot3W(LPCWSTR,LPSTR,DWORD,PBOOL,PBOOL);
DWORD WINAPI GetDllDirectoryA(DWORD,LPSTR);
DWORD WINAPI GetDllDirectoryW(DWORD,LPWSTR);
BOOL WINAPI SetDllDirectoryA(LPCSTR);
BOOL WINAPI SetDllDirectoryW(LPCWSTR);
BOOL WINAPI DnsHostnameToComputerNameA(LPCSTR,LPSTR,LPDWORD);
BOOL WINAPI DnsHostnameToComputerNameW(LPCWSTR,LPWSTR,LPDWORD);
UINT WINAPI GetWriteWatch(DWORD,PVOID,SIZE_T,PVOID *,PULONG_PTR,PULONG);
UINT WINAPI ResetWriteWatch(LPVOID,SIZE_T);
SIZE_T WINAPI GetLargePageMinimum(void);
BOOL WINAPI HeapSetInformation(HANDLE,HEAP_INFORMATION_CLASS,PVOID,SIZE_T);
BOOL WINAPI HeapQueryInformation(HANDLE,HEAP_INFORMATION_CLASS,PVOID,SIZE_T,PSIZE_T);
DWORD WINAPI GetFreeSpace(UINT);
BOOL WINAPI AccessCheckByType(PSECURITY_DESCRIPTOR,PSID,HANDLE,DWORD,POBJECT_TYPE_LIST,DWORD,PGENERIC_MAPPING,PPRIVILEGE_SET,LPDWORD,LPDWORD,LPBOOL);
BOOL WINAPI AccessCheckByTypeResultList (PSECURITY_DESCRIPTOR,PSID,HANDLE,DWORD,POBJECT_TYPE_LIST,DWORD,PGENERIC_MAPPING,PPRIVILEGE_SET,LPDWORD,LPDWORD,LPDWORD);
BOOL WINAPI AccessCheckByTypeAndAuditAlarmA(LPCSTR,LPVOID,LPCSTR,LPCSTR,PSECURITY_DESCRIPTOR,
	PSID,DWORD,AUDIT_EVENT_TYPE,DWORD,POBJECT_TYPE_LIST,DWORD,PGENERIC_MAPPING,
	BOOL,LPDWORD,LPBOOL,LPBOOL);
BOOL WINAPI AccessCheckByTypeAndAuditAlarmW(LPCWSTR,LPVOID,LPCWSTR,LPCWSTR,PSECURITY_DESCRIPTOR,
	PSID,DWORD,AUDIT_EVENT_TYPE,DWORD,POBJECT_TYPE_LIST,DWORD,PGENERIC_MAPPING,
	BOOL,LPDWORD,LPBOOL,LPBOOL);
BOOL WINAPI AccessCheckAndAuditAlarmA(LPCSTR,LPVOID,LPSTR,LPSTR,PSECURITY_DESCRIPTOR,DWORD,PGENERIC_MAPPING,BOOL,LPDWORD,LPBOOL,LPBOOL);
BOOL WINAPI AccessCheckAndAuditAlarmW(LPCWSTR,LPVOID,LPWSTR,LPWSTR,PSECURITY_DESCRIPTOR,DWORD,PGENERIC_MAPPING,BOOL,LPDWORD,LPBOOL,LPBOOL);
HANDLE WINAPI FindFirstStreamW(LPCWSTR,STREAM_INFO_LEVELS,LPVOID,DWORD);
BOOL APIENTRY FindNextStreamW(HANDLE,LPVOID);
PVOID WINAPI AddVectoredContinueHandler (ULONG,PVECTORED_EXCEPTION_HANDLER);
ULONG WINAPI RemoveVectoredContinueHandler (PVOID);
BOOL WINAPI UnregisterWaitEx(HANDLE,HANDLE);
BOOL WINAPI DeleteTimerQueueTimer(HANDLE,HANDLE,HANDLE);
BOOL WINAPI VerifyVersionInfoA(LPOSVERSIONINFOEXA,DWORD,DWORDLONG);
BOOL WINAPI VerifyVersionInfoW(LPOSVERSIONINFOEXW,DWORD,DWORDLONG);
BOOL WINAPI GetEventLogInformation (HANDLE,DWORD,LPVOID,DWORD,LPDWORD);
BOOL WINAPI GetLongPathNameW(LPCWSTR,LPWSTR,DWORD);
UINT GetRawInputDeviceInfoA(HANDLE,UINT,LPVOID,PUINT);
UINT GetRawInputDeviceInfoW(HANDLE,UINT,LPVOID,PUINT);
UINT WINAPI GetRegisteredRawInputDevices(PRAWINPUTDEVICE,PUINT,UINT);
UINT WINAPI GetRawInputDeviceList(PRAWINPUTDEVICELIST,PUINT,UINT);
LRESULT WINAPI DefRawInputProc(PRAWINPUT*,INT,UINT);
BOOL WINAPI ReplaceFileA(LPCSTR,LPCSTR,LPCSTR,DWORD,LPVOID,LPVOID);
BOOL WINAPI ReplaceFileW(LPCWSTR,LPCWSTR,LPCWSTR,DWORD,LPVOID,LPVOID);
HANDLE WINAPI ReOpenFile(HANDLE,DWORD,DWORD,DWORD);
#ifdef UNICODE
#define FileEncryptionStatus FileEncryptionStatusW
#define CreateActCtx CreateActCtxW
#define OpenEncryptedFileRaw OpenEncryptedFileRawW
#define NeedCurrentDirectoryForExePath NeedCurrentDirectoryForExePathW
#define OpenWaitableTimer OpenWaitableTimerW
#define SetFirmwareEnvironmentVariable SetFirmwareEnvironmentVariableW
#define GetFirmwareEnvironmentVariable GetFirmwareEnvironmentVariableW
#define AccessCheckByTypeResultListAndAuditAlarmByHandle AccessCheckByTypeResultListAndAuditAlarmByHandleW
#define AccessCheckByTypeResultListAndAuditAlarm AccessCheckByTypeResultListAndAuditAlarmW
#define AccessCheckByTypeAndAuditAlarm AccessCheckByTypeAndAuditAlarmW
#define CheckNameLegalDOS8Dot3 CheckNameLegalDOS8Dot3W
#define GetDllDirectory GetDllDirectoryW
#define SetDllDirectory SetDllDirectoryW
#define DnsHostnameToComputerName DnsHostnameToComputerNameW
typedef PWIN32_FIND_DATAW PWIN32_FIND_DATA;
typedef LPWIN32_FIND_DATAW LPWIN32_FIND_DATA;
#define ReplaceFile ReplaceFileW
#define AccessCheckAndAuditAlarm AccessCheckAndAuditAlarmW
#define VerifyVersionInfo VerifyVersionInfoW
#define GetRawInputDeviceInfo GetRawInputDeviceInfoW
#define FindActCtxSectionString FindActCtxSectionStringW
#else
#define FileEncryptionStatus FileEncryptionStatusA
#define CreateActCtx CreateActCtxA
#define OpenEncryptedFileRaw OpenEncryptedFileRawA
#define NeedCurrentDirectoryForExePath NeedCurrentDirectoryForExePathA
#define OpenWaitableTimer OpenWaitableTimerA
#define SetFirmwareEnvironmentVariable SetFirmwareEnvironmentVariableA
#define GetFirmwareEnvironmentVariable GetFirmwareEnvironmentVariableA
#define AccessCheckByTypeResultListAndAuditAlarmByHandle AccessCheckByTypeResultListAndAuditAlarmByHandleA
#define AccessCheckByTypeResultListAndAuditAlarm AccessCheckByTypeResultListAndAuditAlarmA
#define AccessCheckByTypeAndAuditAlarm AccessCheckByTypeAndAuditAlarmA
#define CheckNameLegalDOS8Dot3 CheckNameLegalDOS8Dot3A
#define GetDllDirectory GetDllDirectoryA
#define SetDllDirectory SetDllDirectoryA
#define DnsHostnameToComputerName DnsHostnameToComputerNameA
typedef PWIN32_FIND_DATAA PWIN32_FIND_DATA;
typedef LPWIN32_FIND_DATAA LPWIN32_FIND_DATA;
#define ReplaceFile ReplaceFileA
#define GetRawInputDeviceInfo GetRawInputDeviceInfoA
#define FindActCtxSectionString FindActCtxSectionStringA
#define VerifyVersionInfo VerifyVersionInfoA
#define AccessCheckAndAuditAlarm AccessCheckAndAuditAlarmA
#endif
BOOL WINAPI FindActCtxSectionStringA(DWORD,const GUID *,ULONG,LPCSTR,PACTCTX_SECTION_KEYED_DATA);
BOOL WINAPI FindActCtxSectionStringW(DWORD,const GUID *,ULONG,LPCWSTR,PACTCTX_SECTION_KEYED_DATA);
BOOL WINAPI FindActCtxSectionGuid(DWORD,const GUID *,ULONG,const GUID *,PACTCTX_SECTION_KEYED_DATA);
UINT WINAPI GetRawInputBuffer(PRAWINPUT,PUINT,UINT);
UINT GetRawInputData(HRAWINPUT,UINT,LPVOID,PUINT,UINT);
void RtlZeroMemory(void *,unsigned int);
BOOL GetBinaryTypeW(LPCWSTR,LPDWORD);
DWORD GetShortPathNameW(LPCWSTR,LPWSTR,DWORD);
LPWSTR GetEnvironmentStringsW(VOID);
BOOL FreeEnvironmentStringsW(LPWSTR);
DWORD FormatMessageW(DWORD,LPCVOID,DWORD,DWORD,LPWSTR,DWORD,va_list *);
HANDLE CreateMailslotW(LPCWSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
int lstrcmpW(LPCWSTR,LPCWSTR);
int lstrcmpiW( LPCWSTR,LPCWSTR);
LPWSTR lstrcpynW(LPWSTR,LPCWSTR,int);
LPWSTR lstrcpyW(LPWSTR,LPCWSTR);
LPWSTR lstrcatW(LPWSTR,LPCWSTR);
int lstrlenW(LPCWSTR);
HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES,BOOL,LPCWSTR);
HANDLE OpenMutexW(DWORD,BOOL,LPCWSTR);
HANDLE CreateEventW(LPSECURITY_ATTRIBUTES,BOOL,BOOL,LPCWSTR);
HANDLE OpenEventW(DWORD,BOOL,LPCWSTR);
HANDLE CreateSemaphoreW(LPSECURITY_ATTRIBUTES,LONG,LONG,LPCWSTR);
HANDLE OpenSemaphoreW(DWORD,BOOL,LPCWSTR);
HANDLE CreateFileMappingW(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,DWORD,DWORD,LPCWSTR);
HANDLE OpenFileMappingW(DWORD,BOOL,LPCWSTR);
DWORD GetLogicalDriveStringsW(DWORD,LPWSTR);
HINSTANCE LoadLibraryW(LPCWSTR);
HINSTANCE LoadLibraryExW(LPCWSTR,HANDLE,DWORD);
DWORD GetModuleFileNameW(HINSTANCE,LPWSTR,DWORD);
HMODULE GetModuleHandleW(LPCWSTR);
BOOL WINAPI GetModuleHandleExA(DWORD,LPCSTR,HMODULE*);
BOOL WINAPI GetModuleHandleExW(DWORD,LPCWSTR,HMODULE*);
VOID FatalAppExitW(UINT,LPCWSTR);
LPWSTR GetCommandLineW(VOID);
DWORD GetEnvironmentVariableW(LPCWSTR,LPWSTR,DWORD);
BOOL SetEnvironmentVariableW(LPCWSTR,LPCWSTR);
DWORD ExpandEnvironmentStringsW(LPCWSTR,LPWSTR,DWORD);
VOID OutputDebugStringW(LPCWSTR);
HRSRC FindResourceW(HINSTANCE,LPCWSTR,LPCWSTR);
HRSRC FindResourceExW(HINSTANCE,LPCWSTR,LPCWSTR,WORD);
BOOL EnumResourceTypesW(HINSTANCE,ENUMRESTYPEPROC,LONG);
BOOL EnumResourceNamesW(HINSTANCE,LPCWSTR,ENUMRESNAMEPROC,LONG);
BOOL EnumResourceLanguagesW(HINSTANCE,LPCWSTR,LPCWSTR,ENUMRESLANGPROC,LONG);
HANDLE BeginUpdateResourceW(LPCWSTR,BOOL);
BOOL UpdateResourceW(HANDLE,LPCWSTR,LPCWSTR,WORD,LPVOID,DWORD);
BOOL EndUpdateResourceW(HANDLE,BOOL);
ATOM GlobalAddAtomW( LPCWSTR);
ATOM GlobalFindAtomW( LPCWSTR);
UINT GlobalGetAtomNameW(ATOM,LPWSTR,int);
ATOM AddAtomW(LPCWSTR);
ATOM FindAtomW(LPCWSTR);
UINT GetAtomNameW(ATOM,LPWSTR,int);
UINT GetProfileIntW(LPCWSTR,LPCWSTR,INT);
DWORD GetProfileStringW(LPCWSTR,LPCWSTR,LPCWSTR,LPWSTR,DWORD);
BOOL WriteProfileStringW(LPCWSTR,LPCWSTR,LPCWSTR);
DWORD GetProfileSectionW(LPCWSTR,LPWSTR,DWORD);
BOOL WriteProfileSectionW(LPCWSTR,LPCWSTR);
UINT GetPrivateProfileIntW(LPCWSTR,LPCWSTR,INT,LPCWSTR);
BOOL WINAPI GetPrivateProfileStructA(LPCSTR,LPCSTR,LPVOID,UINT,LPCSTR);
BOOL WINAPI GetPrivateProfileStructW(LPCWSTR,LPCWSTR,LPVOID,UINT,LPCWSTR);
DWORD GetPrivateProfileStringW(LPCWSTR,LPCWSTR,LPCWSTR,LPWSTR,DWORD,LPCWSTR);
BOOL WritePrivateProfileStringW(LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR);
BOOL WINAPI WritePrivateProfileStructA(LPCSTR,LPCSTR,LPVOID,UINT,LPCSTR);
BOOL WINAPI WritePrivateProfileStructW(LPCWSTR,LPCWSTR,LPVOID,UINT,LPCWSTR);
DWORD GetPrivateProfileSectionW(LPCWSTR,LPWSTR,DWORD,LPCWSTR);
DWORD WINAPI GetPrivateProfileSectionNamesA(LPSTR,DWORD,LPCSTR);
DWORD WINAPI GetPrivateProfileSectionNamesW(LPWSTR,DWORD,LPCWSTR);
BOOL WritePrivateProfileSectionW(LPCWSTR,LPCWSTR,LPCWSTR);
UINT GetDriveTypeW(LPCWSTR);
UINT GetSystemDirectoryW(LPWSTR,UINT);
DWORD GetTempPathW(DWORD,LPWSTR);
UINT GetTempFileNameW(LPCWSTR,LPCWSTR,UINT,LPWSTR);
UINT WINAPI GetWindowModuleFileNameA(HWND,LPSTR,UINT);
UINT WINAPI GetWindowModuleFileNameW(HWND,LPWSTR,UINT);
UINT WINAPI GetWindowsDirectoryW(LPWSTR,UINT);
UINT WINAPI GetSystemWindowsDirectoryA(LPSTR,UINT);
UINT WINAPI GetSystemWindowsDirectoryW(LPWSTR,UINT);
BOOL WINAPI GetWindowInfo(HWND,PWINDOWINFO);
DWORD WINAPI GetListBoxInfo(HWND);
BOOL WINAPI GetScrollBarInfo(HWND,LONG,PSCROLLBARINFO);
BOOL WINAPI GetCursorInfo(PCURSORINFO);
BOOL WINAPI GetTitleBarInfo(HWND,PTITLEBARINFO);
BOOL SetCurrentDirectoryW(LPCWSTR);
DWORD GetCurrentDirectoryW(DWORD,LPWSTR);
BOOL WINAPI GetCurrentHwProfileA(LPHW_PROFILE_INFOA);
BOOL WINAPI GetCurrentHwProfileW(LPHW_PROFILE_INFOW);
BOOL GetDiskFreeSpaceW(LPCWSTR,LPDWORD,LPDWORD,LPDWORD,LPDWORD);
BOOL WINAPI GetDiskFreeSpaceExW(LPCWSTR,long long *,long long *,long long *);
BOOL CreateDirectoryW(LPCWSTR,LPSECURITY_ATTRIBUTES);
BOOL CreateDirectoryExW(LPCWSTR,LPCWSTR,LPSECURITY_ATTRIBUTES);
BOOL RemoveDirectoryW(LPCWSTR);
DWORD GetFullPathNameW(LPCWSTR,DWORD,LPWSTR,LPWSTR *);
BOOL DefineDosDeviceW(DWORD,LPCWSTR,LPCWSTR);
DWORD QueryDosDeviceW(LPCWSTR,LPWSTR,DWORD);
HANDLE CreateFileW(LPCWSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE);
BOOL SetFileAttributesW(LPCWSTR,DWORD);
DWORD GetFileAttributesW(LPCWSTR);
BOOL WINAPI GetFileAttributesExA(LPCSTR,GET_FILEEX_INFO_LEVELS,LPVOID);
BOOL WINAPI GetFileAttributesExW(LPCWSTR,GET_FILEEX_INFO_LEVELS,LPVOID);
DWORD GetCompressedFileSizeW(LPCWSTR,LPDWORD);
BOOL DeleteFileW(LPCWSTR);
DWORD SearchPathW(LPCWSTR,LPCWSTR,LPCWSTR,DWORD,LPWSTR,LPWSTR *);
BOOL CopyFileW(LPCWSTR,LPCWSTR,BOOL);
BOOL WINAPI CopyFileExW(LPCWSTR,LPCWSTR,LPPROGRESS_ROUTINE,LPVOID,LPBOOL,DWORD);
BOOL WINAPI CreateHardLinkW(LPCWSTR,LPCWSTR,LPSECURITY_ATTRIBUTES);
BOOL MoveFileW(LPCWSTR,LPCWSTR);
BOOL MoveFileExW(LPCWSTR,LPCWSTR,DWORD);
BOOL WINAPI MoveFileWithProgressW(LPCWSTR,LPCWSTR,LPPROGRESS_ROUTINE,LPVOID,DWORD);
HANDLE CreateNamedPipeW(LPCWSTR,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
BOOL GetNamedPipeHandleStateW(HANDLE,LPDWORD,LPDWORD,LPDWORD,LPDWORD,LPWSTR,DWORD);
BOOL CallNamedPipeW(LPCWSTR,LPVOID,DWORD,LPVOID,DWORD,LPDWORD,DWORD);
BOOL WaitNamedPipeW(LPCWSTR,DWORD);
BOOL SetVolumeLabelW(LPCWSTR,LPCWSTR);
BOOL GetVolumeInformationW(LPCWSTR,LPWSTR,DWORD,LPDWORD,LPDWORD,LPDWORD,LPWSTR,DWORD);
BOOL WINAPI CancelIo(HANDLE);
BOOL ClearEventLogW(HANDLE,LPCWSTR);
BOOL BackupEventLogW(HANDLE,LPCWSTR);
HANDLE OpenEventLogW(LPCWSTR,LPCWSTR);
HANDLE RegisterEventSourceW(LPCWSTR,LPCWSTR);
HANDLE OpenBackupEventLogW(LPCWSTR,LPCWSTR);
BOOL ReadEventLogW(HANDLE,DWORD,DWORD,LPVOID,DWORD,DWORD *,DWORD *);
BOOL ReportEventW(HANDLE,WORD,WORD,DWORD,PSID,WORD,DWORD,LPCWSTR *,LPVOID);
BOOL AccessCheckAndAuditAlarmW(LPCWSTR,LPVOID HandleId,LPWSTR,LPWSTR,PSECURITY_DESCRIPTOR,DWORD,PGENERIC_MAPPING,BOOL,LPDWORD,LPBOOL,LPBOOL);
BOOL ObjectOpenAuditAlarmW(LPCWSTR,LPVOID,LPWSTR,LPWSTR,PSECURITY_DESCRIPTOR,HANDLE,DWORD,DWORD,PPRIVILEGE_SET,BOOL,BOOL,LPBOOL);
BOOL ObjectPrivilegeAuditAlarmW(LPCWSTR,LPVOID,HANDLE,DWORD,PPRIVILEGE_SET,BOOL);
BOOL ObjectCloseAuditAlarmW(LPCWSTR,LPVOID,BOOL);
BOOL WINAPI ObjectDeleteAuditAlarmA(LPCSTR,LPVOID,BOOL);
BOOL WINAPI ObjectDeleteAuditAlarmW(LPCWSTR,LPVOID,BOOL);
DWORD WINAPI GetGuiResources(HANDLE,DWORD);
COLORREF WINAPI SetDCBrushColor(HDC,COLORREF);
COLORREF WINAPI SetDCPenColor(HDC,COLORREF);
DWORD WINAPI SetLayout(HDC,DWORD);
DWORD WINAPI GetLayout(HDC);
BOOL LockWorkStation(void);
BOOL WINAPI UserHandleGrantAccess(HANDLE,HANDLE,BOOL);
HANDLE WINAPI AddFontMemResourceEx(PVOID,DWORD,PVOID,DWORD*);
BOOL WINAPI RemoveFontMemResourceEx(HANDLE);
#ifdef UNICODE
#define GetModuleHandleEx GetModuleHandleExW
#define GetCurrentHwProfile GetCurrentHwProfileW
#define ObjectDeleteAuditAlarm	ObjectDeleteAuditAlarmW
#define GetComputerNameEx GetComputerNameExW
#define SetComputerNameEx SetComputerNameExW
#define AddFontResourceEx AddFontResourceExW
#define RemoveFontResourceEx RemoveFontResourceExW
#else
#define RemoveFontResourceEx RemoveFontResourceExA
#define AddFontResourceEx AddFontResourceExA
#define GetModuleHandleEx GetModuleHandleExA
#define GetCurrentHwProfile GetCurrentHwProfileA
#define ObjectDeleteAuditAlarm	ObjectDeleteAuditAlarmA
#define GetComputerNameEx GetComputerNameExA
#define SetComputerNameEx SetComputerNameExA
#endif
BOOL PrivilegedServiceAuditAlarmW(LPCWSTR,LPCWSTR,HANDLE,PPRIVILEGE_SET,BOOL);
BOOL SetFileSecurityW(LPCWSTR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR);
BOOL GetFileSecurityW(LPCWSTR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,LPDWORD);
HANDLE FindFirstChangeNotificationW(LPCWSTR,BOOL,DWORD);
BOOL IsBadStringPtrW(LPCWSTR,UINT);
BOOL LookupAccountSidW(LPCWSTR,PSID,LPWSTR,LPDWORD,LPWSTR,LPDWORD,PSID_NAME_USE);
BOOL LookupAccountNameW(LPCWSTR,LPCWSTR,PSID,LPDWORD,LPWSTR,LPDWORD,PSID_NAME_USE);
BOOL LookupPrivilegeValueW(LPCWSTR,LPCWSTR,PLUID);
BOOL LookupPrivilegeNameW(LPCWSTR,PLUID,LPWSTR,LPDWORD);
BOOL LookupPrivilegeDisplayNameW(LPCWSTR,LPCWSTR,LPWSTR,LPDWORD,LPDWORD);
BOOL BuildCommDCBW(LPCWSTR,LPDCB);
BOOL BuildCommDCBAndTimeoutsW(LPCWSTR,LPDCB,LPCOMMTIMEOUTS);
BOOL CommConfigDialogW(LPCWSTR,HWND,LPCOMMCONFIG);
BOOL GetDefaultCommConfigW(LPCWSTR,LPCOMMCONFIG,LPDWORD);
BOOL SetDefaultCommConfigW(LPCWSTR,LPCOMMCONFIG,DWORD);
BOOL GetComputerNameW(LPWSTR,LPDWORD);
BOOL SetComputerNameW(LPCWSTR);
BOOL WINAPI GetComputerNameExA(COMPUTER_NAME_FORMAT,LPSTR,LPDWORD);
BOOL WINAPI GetComputerNameExW(COMPUTER_NAME_FORMAT,LPWSTR,LPDWORD);
BOOL WINAPI SetComputerNameExA(COMPUTER_NAME_FORMAT,LPCSTR);
BOOL WINAPI SetComputerNameExW(COMPUTER_NAME_FORMAT,LPCWSTR);
BOOL GetUserNameW(LPWSTR,LPDWORD);
int wvsprintfW(LPWSTR,LPCWSTR,va_list arglist);
int CDECL wsprintfW(LPWSTR,LPCWSTR,...);
HKL LoadKeyboardLayoutW(LPCWSTR,UINT);
BOOL GetKeyboardLayoutNameW(LPWSTR);
HDESK CreateDesktopW(LPWSTR,LPWSTR,LPDEVMODE,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
HDESK OpenDesktopW(LPWSTR,DWORD,BOOL,DWORD);
BOOL EnumDesktopsW(HWINSTA,DESKTOPENUMPROC,LPARAM);
HWINSTA CreateWindowStationW(LPWSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
HWINSTA OpenWindowStationW(LPWSTR,BOOL,DWORD);
BOOL EnumWindowStationsW(ENUMWINDOWSTATIONPROC,LPARAM);
BOOL GetUserObjectInformationW(HANDLE,int,PVOID,DWORD,LPDWORD);
BOOL SetUserObjectInformationW(HANDLE,int,PVOID,DWORD);
UINT RegisterWindowMessageW(LPCWSTR);
BOOL GetMessageW(LPMSG,HWND,UINT,UINT);
LONG DispatchMessageW(CONST MSG *);
BOOL PeekMessageW(LPMSG,HWND,UINT,UINT,UINT);
LRESULT SendMessageW(HWND,UINT,WPARAM,LPARAM);
LRESULT SendMessageTimeoutW(HWND,UINT,WPARAM,LPARAM,UINT,UINT,LPDWORD);
BOOL SendNotifyMessageW(HWND,UINT,WPARAM,LPARAM);
BOOL SendMessageCallbackW(HWND,UINT,WPARAM,LPARAM,SENDASYNCPROC,DWORD);
BOOL PostMessageW(HWND,UINT,WPARAM,LPARAM);
BOOL PostThreadMessageW(DWORD,UINT,WPARAM,LPARAM);
LRESULT DefWindowProcW(HWND,UINT,WPARAM,LPARAM);
LRESULT CallWindowProcW(WNDPROC,HWND,UINT,WPARAM,LPARAM);
ATOM RegisterClassW(CONST WNDCLASSW *);
BOOL UnregisterClassW(LPCWSTR,HINSTANCE);
BOOL GetClassInfoW(HINSTANCE,LPCWSTR,LPWNDCLASS);
ATOM RegisterClassExW(CONST WNDCLASSEX *);
BOOL GetClassInfoExW(HINSTANCE,LPCWSTR,LPWNDCLASSEX);
HWND CreateWindowExW(DWORD,LPCWSTR,LPCWSTR,DWORD,int,int,int,int,HWND,HMENU,HINSTANCE,LPVOID);
HWND CreateDialogParamW(HINSTANCE,LPCWSTR,HWND,DLGPROC,LPARAM);
HWND CreateDialogIndirectParamW(HINSTANCE,LPCDLGTEMPLATE,HWND,DLGPROC,LPARAM);
int DialogBoxParamW(HINSTANCE,LPCWSTR,HWND,DLGPROC,LPARAM);
int DialogBoxIndirectParamW(HINSTANCE,LPCDLGTEMPLATE,HWND,DLGPROC,LPARAM);
BOOL SetDlgItemTextW(HWND,int,LPCWSTR);
UINT GetDlgItemTextW(HWND,int,LPWSTR,int);
LONG SendDlgItemMessageW(HWND,int,UINT,WPARAM,LPARAM);
LRESULT DefDlgProcW(HWND,UINT,WPARAM,LPARAM);
BOOL CallMsgFilterW(LPMSG,int);
UINT RegisterClipboardFormatW(LPCWSTR);
int GetClipboardFormatNameW(UINT,LPWSTR,int);
BOOL CharToOemW(LPCWSTR,LPSTR);
BOOL OemToCharW(LPCSTR,LPWSTR);
BOOL CharToOemBuffW(LPCWSTR,LPSTR,DWORD);
BOOL OemToCharBuffW(LPCSTR,LPWSTR,DWORD);
LPWSTR CharUpperW(LPWSTR);
DWORD CharUpperBuffW(LPWSTR,DWORD);
LPWSTR CharLowerW(LPWSTR);
DWORD CharLowerBuffW(LPWSTR,DWORD);
LPWSTR CharNextW(LPCWSTR);
LPWSTR CharPrevW(LPCWSTR,LPCWSTR);
BOOL IsCharAlphaW(WCHAR);
BOOL IsCharAlphaNumericW(WCHAR);
BOOL IsCharUpperW(WCHAR);
BOOL IsCharLowerW(WCHAR);
int GetKeyNameTextW(LONG,LPWSTR,int);
UINT WINAPI SendInput(UINT,LPINPUT,int);
SHORT VkKeyScanW(WCHAR);
SHORT VkKeyScanExW(WCHAR,HKL);
UINT MapVirtualKeyW(UINT,UINT);
UINT MapVirtualKeyExW(UINT,UINT,HKL);
HACCEL LoadAcceleratorsW(HINSTANCE,LPCWSTR);
HACCEL CreateAcceleratorTableW(LPACCEL,int);
int CopyAcceleratorTableW(HACCEL,LPACCEL,int);
int TranslateAcceleratorW(HWND,HACCEL,LPMSG);
HMENU LoadMenuW(HINSTANCE,LPCWSTR);
HMENU LoadMenuIndirectW(CONST MENUTEMPLATE *);
BOOL ChangeMenuW(HMENU,UINT,LPCWSTR,UINT,UINT);
int GetMenuStringW(HMENU,UINT,LPWSTR,int,UINT);
BOOL InsertMenuW(HMENU,UINT,UINT,UINT,LPCWSTR);
BOOL AppendMenuW(HMENU,UINT,UINT,LPCWSTR);
BOOL ModifyMenuW(HMENU,UINT,UINT,UINT,LPCWSTR);
BOOL InsertMenuItemW(HMENU,UINT,BOOL,LPCMENUITEMINFO);
BOOL GetMenuItemInfoW(HMENU,UINT,BOOL,LPMENUITEMINFO);
BOOL SetMenuItemInfoW( HMENU,UINT,BOOL,LPCMENUITEMINFO);
int DrawTextW(HDC,LPCWSTR,int,LPRECT,UINT);
int DrawTextExW(HDC,LPWSTR,int,LPRECT,UINT,LPDRAWTEXTPARAMS);
BOOL GrayStringW(HDC,HBRUSH,GRAYSTRINGPROC,LPARAM,int,int,int,int,int);
BOOL DrawStateW(HDC,HBRUSH,DRAWSTATEPROC,LPARAM,WPARAM,int,int,int,int,UINT);
LONG TabbedTextOutW(HDC,int,int,LPCWSTR,int,int,LPINT,int);
DWORD GetTabbedTextExtentW(HDC,LPCWSTR,int,int,LPINT);
BOOL SetPropW(HWND,LPCWSTR,HANDLE);
HANDLE GetPropW(HWND,LPCWSTR);
HANDLE RemovePropW(HWND,LPCWSTR);
int EnumPropsExW(HWND,PROPENUMPROCEX,LPARAM);
int EnumPropsW(HWND,PROPENUMPROC);
BOOL SetWindowTextW(HWND,LPCWSTR);
int GetWindowTextW(HWND,LPWSTR,int);
int GetWindowTextLengthW(HWND);
int MessageBoxW(HWND,LPCWSTR,LPCWSTR,UINT);
int MessageBoxExW(HWND,LPCWSTR,LPCWSTR,UINT,WORD);
int MessageBoxIndirectW(LPMSGBOXPARAMS);
LONG GetWindowLongW(HWND,int);
#define GetWindowLongPtrW	GetWindowLongW
#define GetWindowLongPtrA	GetWindowLongA
LONG SetWindowLongW(HWND,int,LONG);
#define SetWindowLongPtrW	SetWindowLongW
#define SetWindowLongPtrA	SetWindowLongA
#define GetClassLongPtrA	GetWindowLongA
#define GetClassLongPtrW	GetWindowLongW
#define SetClassLongPtrA	SetWindowLongA
#define SetClassLongPtrW	SetWindowLongA
DWORD GetClassLongW(HWND,int);
DWORD SetClassLongW(HWND,int,LONG);
HWND FindWindowW(LPCWSTR,LPCWSTR);
HWND FindWindowExW(HWND,HWND,LPCWSTR,LPCWSTR);
int GetClassNameW(HWND,LPWSTR,int);
HHOOK SetWindowsHookExW(int,HOOKPROC,HINSTANCE,DWORD);
#define DefHookProc(c,p,lp,hh) CallNextHookEx((HHOOK)*hh,c,p,lp)
HBITMAP LoadBitmapW(HINSTANCE,LPCWSTR);
HCURSOR LoadCursorW(HINSTANCE,LPCWSTR);
HCURSOR LoadCursorFromFileW(LPCWSTR);
HICON LoadIconW(HINSTANCE,LPCWSTR);
HANDLE LoadImageW(HINSTANCE,LPCWSTR,UINT,int,int,UINT);
int LoadStringW(HINSTANCE,UINT,LPWSTR,int);
BOOL IsDialogMessageW(HWND,LPMSG);
int DlgDirListW(HWND,LPWSTR,int,int,UINT);
BOOL DlgDirSelectExW(HWND,LPWSTR,int,int);
int DlgDirListComboBoxW(HWND,LPWSTR,int,int,UINT);
BOOL DlgDirSelectComboBoxExW(HWND,LPWSTR,int,int);
LRESULT DefFrameProcW(HWND,HWND,UINT,WPARAM,LPARAM);
LRESULT DefMDIChildProcW(HWND,UINT,WPARAM,LPARAM);
HWND CreateMDIWindowW(LPWSTR,LPWSTR,DWORD,int,int,int,int,HWND,HINSTANCE,LPARAM);
BOOL WinHelpW(HWND,LPCWSTR,UINT,DWORD);
LONG ChangeDisplaySettingsW(LPDEVMODE,DWORD);
LONG WINAPI ChangeDisplaySettingsExW(
   LPCWSTR lpszDeviceName,
   LPDEVMODEW lpDevMode,
   HWND hwnd,
   DWORD dwflags,
   LPVOID lParam);



BOOL EnumDisplaySettingsW(LPCWSTR,DWORD,LPDEVMODE);
BOOL SystemParametersInfoW(UINT,UINT,PVOID,UINT);
int AddFontResourceW(LPCWSTR);
int WINAPI AddFontResourceExA(LPCSTR,DWORD,PVOID);
int WINAPI AddFontResourceExW(LPCWSTR,DWORD,PVOID);
HMETAFILE CopyMetaFileW(HMETAFILE,LPCWSTR);
HFONT CreateFontIndirectW(CONST LOGFONT *);
HFONT CreateFontW(int,int,int,int,int,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPCWSTR);
HDC CreateICW(LPCWSTR,LPCWSTR,LPCWSTR,CONST DEVMODE *);
HDC CreateMetaFileW(LPCWSTR);
BOOL CreateScalableFontResourceW(DWORD,LPCWSTR,LPCWSTR,LPCWSTR);
int DeviceCapabilitiesW(LPCWSTR,LPCWSTR,WORD,LPWSTR,CONST DEVMODE *);
int EnumFontFamiliesExW(HDC,LPLOGFONT,FONTENUMEXPROC,LPARAM,DWORD);
int EnumFontFamiliesW(HDC,LPCWSTR,FONTENUMPROC,LPARAM);
int EnumFontsW(HDC,LPCWSTR,ENUMFONTSPROC,LPARAM);
BOOL GetCharWidthW(HDC,UINT,UINT,LPINT);
BOOL GetCharWidth32W(HDC,UINT,UINT,LPINT);
BOOL GetCharWidthFloatW(HDC,UINT,UINT,PFLOAT);
BOOL GetCharABCWidthsW(HDC,UINT,UINT,LPABC);
BOOL GetCharABCWidthsFloatW(HDC,UINT,UINT,LPABCFLOAT);
DWORD GetGlyphOutlineW(HDC,UINT,UINT,LPGLYPHMETRICS,DWORD,LPVOID,CONST MAT2 *);
HMETAFILE GetMetaFileW(LPCWSTR);
UINT GetOutlineTextMetricsW(HDC,UINT,LPOUTLINETEXTMETRIC);
BOOL GetTextExtentPointW(HDC,LPCWSTR,int,LPSIZE);
BOOL GetTextExtentPoint32W( HDC,LPCWSTR,int,LPSIZE);
BOOL GetTextExtentExPointW( HDC,LPCWSTR,int,int,LPINT,LPINT,LPSIZE );
BOOL WINAPI GetTextExtentPointI(HDC,LPWORD,int,LPSIZE);
BOOL WINAPI GetTextExtentExPointI(HDC,LPWORD,int,int,LPINT,LPINT,LPSIZE);
BOOL WINAPI GetCharWidthI(HDC,UINT,UINT,LPWORD,LPINT);
BOOL WINAPI GetCharABCWidthsI(HDC,UINT,UINT,LPWORD,LPABC);
DWORD GetCharacterPlacementW(HDC,LPCWSTR,int,int,LPGCP_RESULTS,DWORD);
HDC ResetDCW(HDC,CONST DEVMODE *);
BOOL RemoveFontResourceW(LPCWSTR);
BOOL WINAPI RemoveFontResourceExA(LPCSTR,DWORD,PVOID);
BOOL WINAPI RemoveFontResourceExW(LPCWSTR,DWORD,PVOID);
HENHMETAFILE CopyEnhMetaFileW(HENHMETAFILE,LPCWSTR);
HDC CreateEnhMetaFileW(HDC,LPCWSTR,CONST RECT *,LPCWSTR);
HENHMETAFILE GetEnhMetaFileW(LPCWSTR);
UINT GetEnhMetaFileDescriptionW(HENHMETAFILE,UINT,LPWSTR );
BOOL GetTextMetricsW(HDC,LPTEXTMETRICW);
int StartDocW(HDC,CONST DOCINFO *);
int GetObjectW(HGDIOBJ,int,LPVOID);
BOOL TextOutW(HDC,int,int,LPCWSTR,int);
BOOL ExtTextOutW(HDC,int,int,UINT,CONST RECT *,LPCWSTR,UINT,CONST INT *);
BOOL PolyTextOutW(HDC,CONST POLYTEXT *,int);
int GetTextFaceW(HDC,int,LPWSTR);
DWORD GetKerningPairsW(HDC,DWORD,LPKERNINGPAIR);
BOOL GetLogColorSpaceW(HCOLORSPACE,LPLOGCOLORSPACE,DWORD);
HCOLORSPACE CreateColorSpaceW(LPLOGCOLORSPACE);
BOOL GetICMProfileW(HDC,DWORD,LPWSTR);
BOOL SetICMProfileW(HDC,LPWSTR);
BOOL UpdateICMRegKeyW(DWORD,DWORD,LPWSTR,UINT);
int EnumICMProfilesW(HDC,ICMENUMPROC,LPARAM);
HPROPSHEETPAGE CreatePropertySheetPageW(LPCPROPSHEETPAGE);
int PropertySheetW(LPCPROPSHEETHEADER);
HIMAGELIST ImageList_LoadImageW(HINSTANCE,LPCWSTR,int,int,COLORREF,UINT,UINT);
HIMAGELIST WINAPI ImageList_Duplicate(HIMAGELIST);
BOOL WINAPI ImageList_Copy(HIMAGELIST,int,HIMAGELIST,int,UINT);
BOOL WINAPI ImageList_DrawIndirect(IMAGELISTDRAWPARAMS*);
#define	ImageList_LoadBitmap(h,l,x,G,M) ImageList_LoadImage(h,l,x,G,M,IMAGE_BITMAP,0)
#define ImageList_RemoveAll(himl) ImageList_Remove(himl,-1)
#define ImageList_ExtractIcon(hi, himl,i) ImageList_GetIcon(himl,i,0)
HWND CreateStatusWindowW(LONG,LPCWSTR,HWND,UINT);
void DrawStatusTextW(HDC,LPRECT,LPCWSTR,UINT);
BOOL GetOpenFileNameW(LPOPENFILENAME);
BOOL GetSaveFileNameW(LPOPENFILENAME);
short GetFileTitleW(LPCWSTR,LPWSTR,WORD);
BOOL ChooseColorW(LPCHOOSECOLOR);
HWND ReplaceTextW(LPFINDREPLACE);
BOOL ChooseFontW(LPCHOOSEFONT);
HWND FindTextW(LPFINDREPLACE);
BOOL PrintDlgW(LPPRINTDLG);
BOOL PageSetupDlgW(LPPAGESETUPDLG);
BOOL CreateProcessW(LPCWSTR,LPWSTR,LPSECURITY_ATTRIBUTES,LPSECURITY_ATTRIBUTES,BOOL,DWORD,LPVOID,LPCWSTR,LPSTARTUPINFO,LPPROCESS_INFORMATION);
BOOL WINAPI CreateProcessAsUserA(HANDLE,LPCSTR,LPSTR, LPSECURITY_ATTRIBUTES,LPSECURITY_ATTRIBUTES, BOOL,DWORD,LPVOID,LPCSTR, LPSTARTUPINFOA, LPPROCESS_INFORMATION);
BOOL WINAPI CreateProcessAsUserW(HANDLE,LPCWSTR,LPWSTR,LPSECURITY_ATTRIBUTES,LPSECURITY_ATTRIBUTES,BOOL,DWORD,LPVOID,LPCWSTR,LPSTARTUPINFOW,LPPROCESS_INFORMATION);
BOOL WINAPI CreateProcessWithLogonW(LPCWSTR,LPCWSTR,LPCWSTR,DWORD,LPCWSTR,LPWSTR,DWORD,LPVOID,LPCWSTR,LPSTARTUPINFOW,LPPROCESS_INFORMATION);
BOOL APIENTRY ImpersonateAnonymousToken(HANDLE);
VOID GetStartupInfoW(LPSTARTUPINFO);
HANDLE FindFirstFileW(LPCWSTR,LPWIN32_FIND_DATAW);
HANDLE WINAPI FindFirstFileExW(LPCWSTR,FINDEX_INFO_LEVELS,LPVOID,FINDEX_SEARCH_OPS,LPVOID,DWORD);
BOOL FindNextFileW(HANDLE,LPWIN32_FIND_DATA);
BOOL GetVersionExW(LPOSVERSIONINFO);
#define CreateWindowW(Class,Name,Style,x,y,W,H,Parent,Menu,Inst,Param) CreateWindowExW(0,Class,Name,Style,x,y,W,H,Parent,Menu,Inst,Param)
#define CreateDialogW(hI,lpN,hP,Func) CreateDialogParamW(hI,lpN,hP,Func,0)
#define CreateDialogIndirectW(I,T,hP,Func) CreateDialogIndirectParamW(I,T,hP,Func,0)
#define DialogBoxW(Inst,Template,Parent,Func) DialogBoxParamW(Inst,Template,Parent,Func,0)
#define DialogBoxIndirectW(Inst,Template,Parent,Func) DialogBoxIndirectParamW(Inst,Template,Parent,Func,0)
HDC CreateDCW(LPCWSTR,LPCWSTR,LPCWSTR,CONST DEVMODE *);
HFONT CreateFontA(int,int,int,int,int,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPCSTR);
DWORD VerInstallFileW(DWORD,LPWSTR,LPWSTR,LPWSTR,LPWSTR,LPWSTR,LPWSTR,PUINT);
DWORD GetFileVersionInfoSizeW(LPWSTR,LPDWORD);
BOOL GetFileVersionInfoW(LPWSTR,DWORD,DWORD,LPVOID);
DWORD VerLanguageNameW(DWORD,LPWSTR,DWORD);
DWORD VerFindFileW(DWORD,LPWSTR,LPWSTR,LPWSTR,LPWSTR,PUINT,LPWSTR,PUINT);
LONG RegSetValueExW(HKEY,LPCWSTR,DWORD,DWORD,BYTE*,DWORD);
LONG RegUnLoadKeyW(HKEY,LPCWSTR);
BOOL InitiateSystemShutdownW(LPWSTR,LPWSTR,DWORD,BOOL,BOOL);
BOOL AbortSystemShutdownW(LPWSTR);
LONG RegRestoreKeyW(HKEY,LPCWSTR,DWORD);
LONG RegSaveKeyW(HKEY,LPCWSTR,LPSECURITY_ATTRIBUTES);
LONG RegSetValueW(HKEY,LPCWSTR,DWORD,LPCWSTR,DWORD);
LONG RegQueryValueW(HKEY,LPCWSTR,LPWSTR,PLONG);
LONG RegQueryMultipleValuesW(HKEY,PVALENTW,DWORD,LPWSTR,LPDWORD);
LONG RegQueryValueExW(HKEY,LPCWSTR,LPDWORD,LPDWORD,LPBYTE,LPDWORD);
LONG RegReplaceKeyW(HKEY,LPCWSTR,LPCWSTR,LPCWSTR);
LONG RegConnectRegistryW(LPWSTR,HKEY,PHKEY);
LONG RegCreateKeyW(HKEY,LPCWSTR,PHKEY);
LONG RegCreateKeyExW(HKEY,LPCWSTR,DWORD,LPWSTR,DWORD,REGSAM,LPSECURITY_ATTRIBUTES,PHKEY,LPDWORD);
LONG RegDeleteKeyW(HKEY,LPCWSTR);
LONG RegDeleteValueW(HKEY,LPCWSTR);
LONG RegEnumKeyW(HKEY,DWORD,LPWSTR,DWORD);
LONG RegEnumKeyExW(HKEY,DWORD,LPWSTR,LPDWORD,LPDWORD,LPWSTR,LPDWORD,PFILETIME);
LONG RegEnumValueW(HKEY,DWORD,LPWSTR,LPDWORD,LPDWORD,LPDWORD,LPBYTE,LPDWORD);
LONG RegLoadKeyW(HKEY,LPCWSTR,LPCWSTR);
LONG RegOpenKeyW(HKEY,LPCWSTR,PHKEY);
LONG RegOpenKeyExW(HKEY,LPCWSTR,DWORD,REGSAM,PHKEY);
LONG RegQueryInfoKeyW(HKEY,LPWSTR,LPDWORD,LPDWORD,LPDWORD,LPDWORD,LPDWORD,LPDWORD,LPDWORD,LPDWORD,LPDWORD,PFILETIME);
int CompareStringW(LCID,DWORD,LPCWSTR,int,LPCWSTR,int);
int LCMapStringW(LCID,DWORD,LPCWSTR,int,LPWSTR,int);
int GetLocaleInfoW(LCID,LCTYPE,LPWSTR,int);
BOOL SetLocaleInfoW(LCID,LCTYPE,LPCWSTR);
int GetTimeFormatW(LCID,DWORD,CONST SYSTEMTIME *,LPCWSTR,LPWSTR,int);
int GetDateFormatW(LCID,DWORD,CONST SYSTEMTIME *,LPCWSTR,LPWSTR,int);
int GetNumberFormatW(LCID,DWORD,LPCWSTR,CONST NUMBERFMTW *,LPWSTR,int);
int GetCurrencyFormatW(LCID,DWORD,LPCWSTR,CONST CURRENCYFMTW *,LPWSTR,int);
BOOL EnumCalendarInfoW(CALINFO_ENUMPROC,LCID,CALID,CALTYPE);
BOOL EnumTimeFormatsW(TIMEFMT_ENUMPROC,LCID,DWORD);
BOOL EnumDateFormatsW(DATEFMT_ENUMPROC,LCID,DWORD);
BOOL GetStringTypeExW(LCID,DWORD,LPCWSTR,int,LPWORD);
BOOL GetStringTypeW(DWORD,LPCWSTR,int,LPWORD);
int FoldStringW(DWORD,LPCWSTR,int,LPWSTR,int);
BOOL EnumSystemLocalesW(LOCALE_ENUMPROC,DWORD);
BOOL EnumSystemCodePagesW(CODEPAGE_ENUMPROC,DWORD);
BOOL PeekConsoleInputW(HANDLE,PINPUT_RECORD,DWORD,LPDWORD);
BOOL ReadConsoleInputW(HANDLE,PINPUT_RECORD,DWORD,LPDWORD);
BOOL WriteConsoleInputW(HANDLE,CONST INPUT_RECORD *,DWORD,LPDWORD);
BOOL ReadConsoleOutputW(HANDLE,PCHAR_INFO,COORD,COORD,PSMALL_RECT);
BOOL WriteConsoleOutputW(HANDLE,CONST CHAR_INFO *,COORD,COORD,PSMALL_RECT);
BOOL ReadConsoleOutputCharacterW(HANDLE,LPWSTR,DWORD,COORD,LPDWORD);
BOOL WriteConsoleOutputCharacterW(HANDLE,LPCWSTR,DWORD,COORD,LPDWORD);
BOOL FillConsoleOutputCharacterW(HANDLE,WCHAR,DWORD,COORD,LPDWORD);
BOOL ScrollConsoleScreenBufferW(HANDLE,CONST SMALL_RECT *,CONST SMALL_RECT *,COORD,CONST CHAR_INFO *);
DWORD GetConsoleTitleW(LPWSTR,DWORD);
BOOL SetConsoleTitleW(LPCWSTR);
HANDLE GetConsoleWindow(void);
BOOL ReadConsoleW(HANDLE,LPVOID,DWORD,LPDWORD,LPVOID);
BOOL WriteConsoleW(HANDLE,CONST VOID *,DWORD,LPDWORD,LPVOID);
DWORD WNetAddConnectionW(LPCWSTR,LPCWSTR,LPCWSTR);
DWORD WNetAddConnection2W(LPNETRESOURCE,LPCWSTR,LPCWSTR,DWORD);
DWORD WNetAddConnection3W(HWND,LPNETRESOURCE,LPCWSTR,LPCWSTR,DWORD);
DWORD WNetCancelConnectionW(LPCWSTR,BOOL);
DWORD WNetCancelConnection2W(LPCWSTR,DWORD,BOOL);
DWORD WNetGetConnectionW(LPCWSTR,LPWSTR,LPDWORD);
DWORD WNetUseConnectionW(HWND,LPNETRESOURCE,LPCWSTR,LPCWSTR,DWORD,LPWSTR,LPDWORD,LPDWORD);
DWORD WNetSetConnectionW(LPCWSTR,DWORD,LPVOID);
DWORD WNetConnectionDialog1W(LPCONNECTDLGSTRUCT);
DWORD WNetDisconnectDialog1W(LPDISCDLGSTRUCT);
DWORD WNetOpenEnumW(DWORD,DWORD,DWORD,LPNETRESOURCE,LPHANDLE);
DWORD WNetEnumResourceW(HANDLE,LPDWORD,LPVOID,LPDWORD);
DWORD WNetGetUniversalNameW(LPCWSTR,DWORD,LPVOID,LPDWORD);
DWORD WNetGetUserW(LPCWSTR,LPWSTR,LPDWORD);
DWORD WNetGetProviderNameW(DWORD,LPWSTR,LPDWORD);
DWORD WNetGetNetworkInformationW(LPCWSTR,LPNETINFOSTRUCT);
DWORD WNetGetLastErrorW(LPDWORD,LPWSTR,DWORD,LPWSTR,DWORD);
DWORD MultinetGetConnectionPerformanceW(LPNETRESOURCE,LPNETCONNECTINFOSTRUCT);
/* ASCIIFunctions.h Declarations for all the WIN32 ASCII Functions */
DWORD WINAPI GetLongPathNameA(LPCSTR,LPSTR,DWORD);
BOOL GetBinaryTypeA(LPCSTR,LPDWORD);
DWORD GetShortPathNameA(LPCSTR,LPSTR,DWORD);
BOOL FreeEnvironmentStringsA(LPSTR);
DWORD FormatMessageA(DWORD,LPCVOID,DWORD,DWORD,LPSTR,DWORD,va_list *);
HANDLE CreateMailslotA(LPCSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
int lstrcmpA(LPCSTR,LPCSTR);
int lstrcmpiA(LPCSTR,LPCSTR);
LPSTR lstrcpynA(LPSTR,LPCSTR,int);
LPSTR lstrcpyA(LPSTR,LPCSTR);
LPSTR lstrcatA(LPSTR,LPCSTR);
int lstrlenA(LPCSTR);
HANDLE CreateMutexA(LPSECURITY_ATTRIBUTES,BOOL,LPCSTR);
HANDLE OpenMutexA(DWORD,BOOL,LPCSTR);
HANDLE CreateEventA(LPSECURITY_ATTRIBUTES,BOOL,BOOL,LPCSTR);
HANDLE OpenEventA(DWORD,BOOL,LPCSTR);
HANDLE CreateSemaphoreA(LPSECURITY_ATTRIBUTES,LONG,LONG,LPCSTR);
HANDLE OpenSemaphoreA(DWORD,BOOL,LPCSTR);
HANDLE CreateFileMappingA(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,DWORD,DWORD,LPCSTR);
HANDLE OpenFileMappingA(DWORD,BOOL,LPCSTR);
DWORD GetLogicalDriveStringsA(DWORD,LPSTR);
HINSTANCE LoadLibraryA(LPCSTR);
HINSTANCE LoadLibraryExA(LPCSTR,HANDLE,DWORD);
DWORD GetModuleFileNameA(HINSTANCE,LPSTR,DWORD);
HMODULE GetModuleHandleA(LPCSTR);
VOID FatalAppExitA(UINT,LPCSTR);
LPSTR GetCommandLineA(VOID);
DWORD GetEnvironmentVariableA(LPCSTR,LPSTR,DWORD);
BOOL SetEnvironmentVariableA(LPCSTR,LPCSTR);
DWORD ExpandEnvironmentStringsA(LPCSTR,LPSTR,DWORD);
VOID OutputDebugStringA(LPCSTR);
HRSRC FindResourceA(HMODULE,LPCSTR,LPCSTR);
HRSRC FindResourceExA(HINSTANCE,LPCSTR,LPCSTR,WORD);
BOOL EnumResourceTypesA(HINSTANCE,ENUMRESTYPEPROC,LONG);
BOOL EnumResourceNamesA(HINSTANCE,LPCSTR,ENUMRESNAMEPROC,LONG);
BOOL EnumResourceLanguagesA(HINSTANCE,LPCSTR,LPCSTR,ENUMRESLANGPROC,LONG);
HANDLE BeginUpdateResourceA(LPCSTR,BOOL);
BOOL UpdateResourceA(HANDLE,LPCSTR,LPCSTR,WORD,LPVOID,DWORD);
BOOL EndUpdateResourceA(HANDLE,BOOL);
ATOM GlobalAddAtomA(LPCSTR);
ATOM GlobalFindAtomA(LPCSTR);
UINT GlobalGetAtomNameA(ATOM,LPSTR,int);
ATOM AddAtomA(LPCSTR);
ATOM FindAtomA(LPCSTR);
UINT GetAtomNameA(ATOM,LPSTR,int);
UINT GetProfileIntA(LPCSTR,LPCSTR,INT);
DWORD GetProfileStringA(LPCSTR,LPCSTR,LPCSTR,LPSTR,DWORD);
BOOL WriteProfileStringA(LPCSTR,LPCSTR,LPCSTR);
DWORD GetProfileSectionA(LPCSTR,LPSTR,DWORD);
BOOL WriteProfileSectionA(LPCSTR,LPCSTR);
UINT GetPrivateProfileIntA(LPCSTR,LPCSTR,INT,LPCSTR);
DWORD GetPrivateProfileStringA(LPCSTR,LPCSTR,LPCSTR,LPSTR,DWORD,LPCSTR);
BOOL WritePrivateProfileStringA(LPCSTR,LPCSTR,LPCSTR,LPCSTR);
DWORD GetPrivateProfileSectionA(LPCSTR,LPSTR,DWORD,LPCSTR);
BOOL WritePrivateProfileSectionA(LPCSTR,LPCSTR,LPCSTR);
UINT GetDriveTypeA(LPCSTR);
UINT GetSystemDirectoryA(LPSTR,UINT);
BOOL WINAPI GetSystemRegistryQuota(PDWORD,PDWORD);
BOOL WINAPI GetSystemTimes(LPFILETIME,LPFILETIME,LPFILETIME);
VOID WINAPI GetNativeSystemInfo(LPSYSTEM_INFO);
DWORD GetTempPathA(DWORD,LPSTR);
UINT GetTempFileNameA(LPCSTR,LPCSTR,UINT,LPSTR);
UINT GetWindowsDirectoryA(LPSTR,UINT);
BOOL SetCurrentDirectoryA(LPCSTR);
DWORD GetCurrentDirectoryA(DWORD,LPSTR);
BOOL GetDiskFreeSpaceA(LPCSTR,LPDWORD,LPDWORD,LPDWORD,LPDWORD);
BOOL WINAPI GetDiskFreeSpaceExA(LPCSTR,long long *,long long *,long long *);
BOOL CreateDirectoryA(LPCSTR,LPSECURITY_ATTRIBUTES);
BOOL CreateDirectoryExA(LPCSTR,LPCSTR,LPSECURITY_ATTRIBUTES);
BOOL RemoveDirectoryA(LPCSTR);
DWORD GetFullPathNameA(LPCSTR,DWORD,LPSTR,LPSTR *);
BOOL DefineDosDeviceA(DWORD,LPCSTR,LPCSTR);
DWORD QueryDosDeviceA(LPCSTR,LPSTR,DWORD);
HANDLE CreateFileA(LPCSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE);
BOOL SetFileAttributesA(LPCSTR,DWORD);
DWORD GetFileAttributesA(LPCSTR);
DWORD GetCompressedFileSizeA(LPCSTR,LPDWORD);
BOOL DeleteFileA(LPCSTR);
DWORD SearchPathA(LPCSTR,LPCSTR,LPCSTR,DWORD,LPSTR,LPSTR *);
HANDLE WINAPI FindFirstVolumeA(LPSTR,DWORD);
HANDLE WINAPI FindFirstVolumeW(LPWSTR,DWORD);
BOOL WINAPI FindNextVolumeA(HANDLE,LPSTR,DWORD);
BOOL WINAPI FindNextVolumeW(HANDLE,LPWSTR,DWORD);
BOOL CopyFileA(LPCSTR,LPCSTR,BOOL);
HANDLE WINAPI FindFirstVolumeMountPointA(LPCSTR,LPSTR,DWORD);
HANDLE WINAPI FindFirstVolumeMountPointW(LPCWSTR,LPWSTR,DWORD);
BOOL WINAPI FindNextVolumeMountPointA(HANDLE,LPSTR,DWORD);
BOOL WINAPI FindNextVolumeMountPointW(HANDLE,LPWSTR,DWORD);
BOOL WINAPI FindVolumeMountPointClose(HANDLE);
BOOL WINAPI FindVolumeClose(HANDLE);
BOOL WINAPI SetVolumeMountPointA(LPCSTR,LPCSTR);
BOOL WINAPI SetVolumeMountPointW(LPCWSTR,LPCWSTR);
BOOL WINAPI DeleteVolumeMountPointA(LPCSTR);
BOOL WINAPI DeleteVolumeMountPointW(LPCWSTR);
BOOL WINAPI GetVolumeNameForVolumeMountPointA(LPCSTR,LPSTR,DWORD);
BOOL WINAPI GetVolumeNameForVolumeMountPointW(LPCWSTR,LPWSTR,DWORD);
BOOL WINAPI GetVolumePathNameA(LPCSTR,LPSTR,DWORD);
BOOL WINAPI GetVolumePathNameW(LPCWSTR,LPWSTR,DWORD);
BOOL WINAPI GetVolumePathNamesForVolumeNameA(LPCSTR,LPSTR,DWORD,PDWORD);
BOOL WINAPI GetVolumePathNamesForVolumeNameW(LPCWSTR,LPWSTR,DWORD,PDWORD);
BOOL WINAPI AllocateUserPhysicalPages(HANDLE,PULONG_PTR,PULONG_PTR);
BOOL WINAPI FreeUserPhysicalPages(HANDLE,PULONG_PTR,PULONG_PTR);
BOOL WINAPI MapUserPhysicalPages(PVOID,ULONG_PTR,PULONG_PTR);
BOOL WINAPI MapUserPhysicalPagesScatter(PVOID *,ULONG_PTR,PULONG_PTR);
HANDLE WINAPI CreateJobObjectA(LPSECURITY_ATTRIBUTES,LPCSTR);
HANDLE WINAPI CreateJobObjectW(LPSECURITY_ATTRIBUTES,LPCWSTR);
#ifdef UNICODE
#define CreateJobObject CreateJobObjectW
#define OpenJobObject OpenJobObjectW
#define EncryptFile EncryptFileW
#else
#define CreateJobObject CreateJobObjectA
#define OpenJobObject OpenJobObjectA
#define EncryptFile EncryptFileA
#endif
typedef BOOL(WINAPI *PQUERYACTCTXW_FUNC)(DWORD,HANDLE,PVOID,ULONG,PVOID,SIZE_T,SIZE_T *);
BOOL WINAPI QueryActCtxW(DWORD,HANDLE,PVOID,ULONG,PVOID,SIZE_T,SIZE_T *);
DWORD WINAPI WTSGetActiveConsoleSessionId(void);
BOOL WINAPI IsWow64Process(HANDLE,PBOOL);
BOOL WINAPI GetNumaProcessorNode(UCHAR,PUCHAR);
BOOL WINAPI GetNumaNodeProcessorMask(UCHAR,PULONGLONG);
BOOL WINAPI GetNumaAvailableMemoryNode(UCHAR,PULONGLONG);
BOOL WINAPI GetNumaHighestNodeNumber(PULONG);
BOOL WINAPI GetLogicalProcessorInformation(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION,PDWORD);
BOOL WINAPI EncryptFileA(LPCSTR);
BOOL WINAPI EncryptFileW(LPCWSTR);
BOOL WINAPI DecryptFileA(LPCSTR,DWORD);
BOOL WINAPI DecryptFileW(LPCWSTR,DWORD);
BOOL WINAPI AssignProcessToJobObject(HANDLE,HANDLE);
BOOL WINAPI TerminateJobObject(HANDLE,UINT);
BOOL WINAPI QueryInformationJobObject(HANDLE,JOBOBJECTINFOCLASS,LPVOID,DWORD,LPDWORD);
BOOL WINAPI SetInformationJobObject(HANDLE,JOBOBJECTINFOCLASS,LPVOID,DWORD);
BOOL WINAPI IsProcessInJob (HANDLE,HANDLE,PBOOL);
BOOL WINAPI CreateJobSet (ULONG,PJOB_SET_ARRAY,ULONG);
PVOID WINAPI AddVectoredExceptionHandler(ULONG,PVECTORED_EXCEPTION_HANDLER);
ULONG WINAPI RemoveVectoredExceptionHandler(PVOID);
HANDLE WINAPI OpenJobObjectA(DWORD,BOOL,LPCSTR);
HANDLE WINAPI OpenJobObjectW(DWORD,BOOL,LPCWSTR);
BOOL WINAPI CopyFileExA(LPCSTR,LPCSTR,LPPROGRESS_ROUTINE,LPVOID,LPBOOL,DWORD);
BOOL WINAPI CreateHardLinkA(LPCSTR,LPCSTR,LPSECURITY_ATTRIBUTES);
BOOL MoveFileA(LPCSTR,LPCSTR);
BOOL MoveFileExA(LPCSTR,LPCSTR,DWORD);
BOOL WINAPI MoveFileWithProgressA(LPCSTR,LPCSTR,LPPROGRESS_ROUTINE,LPVOID,DWORD);
HANDLE CreateNamedPipeA(LPCSTR,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
BOOL GetNamedPipeHandleStateA(HANDLE,LPDWORD,LPDWORD,LPDWORD,LPDWORD,LPSTR,DWORD);
BOOL CallNamedPipeA(LPCSTR,LPVOID,DWORD,LPVOID,DWORD,LPDWORD,DWORD);
BOOL WaitNamedPipeA(LPCSTR,DWORD);
BOOL SetVolumeLabelA(LPCSTR,LPCSTR);
BOOL GetVolumeInformationA(LPCSTR,LPSTR,DWORD,LPDWORD,LPDWORD,LPDWORD,LPSTR,DWORD);
BOOL ClearEventLogA(HANDLE,LPCSTR);
BOOL BackupEventLogA(HANDLE,LPCSTR);
HANDLE OpenEventLogA (LPCSTR,LPCSTR);
HANDLE RegisterEventSourceA (LPCSTR,LPCSTR);
HANDLE OpenBackupEventLogA(LPCSTR,LPCSTR);
BOOL ReadEventLogA(HANDLE,DWORD,DWORD,LPVOID,DWORD,DWORD *,DWORD *);
BOOL ReportEventA(HANDLE,WORD,WORD,DWORD,PSID,WORD,DWORD,LPCSTR *,LPVOID);
BOOL AccessCheckAndAuditAlarmA(LPCSTR,LPVOID,LPSTR,LPSTR,PSECURITY_DESCRIPTOR,
	DWORD,PGENERIC_MAPPING,BOOL,LPDWORD,LPBOOL,LPBOOL);
BOOL ObjectOpenAuditAlarmA(LPCSTR,LPVOID,LPSTR,LPSTR,PSECURITY_DESCRIPTOR,HANDLE,DWORD,DWORD,PPRIVILEGE_SET,BOOL,BOOL,LPBOOL);
BOOL ObjectPrivilegeAuditAlarmA(LPCSTR,LPVOID,HANDLE,DWORD,PPRIVILEGE_SET,BOOL);
BOOL ObjectCloseAuditAlarmA(LPCSTR,LPVOID,BOOL);
BOOL PrivilegedServiceAuditAlarmA(LPCSTR,LPCSTR,HANDLE,PPRIVILEGE_SET,BOOL);
BOOL SetFileSecurityA(LPCSTR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR);
BOOL GetFileSecurityA(LPCSTR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,LPDWORD);
HANDLE FindFirstChangeNotificationA(LPCSTR,BOOL,DWORD);
BOOL IsBadStringPtrA(LPCSTR,UINT);
BOOL LookupAccountSidA(LPCSTR,PSID,LPSTR,LPDWORD,LPSTR,LPDWORD,PSID_NAME_USE);
BOOL LookupAccountNameA(LPCSTR,LPCSTR,PSID,LPDWORD,LPSTR,LPDWORD,PSID_NAME_USE);
BOOL LookupPrivilegeValueA(LPCSTR,LPCSTR,PLUID);
BOOL LookupPrivilegeNameA(LPCSTR,PLUID,LPSTR,LPDWORD);
BOOL LookupPrivilegeDisplayNameA(LPCSTR,LPCSTR,LPSTR,LPDWORD,LPDWORD);
BOOL BuildCommDCBA(LPCSTR lpDef,LPDCB lpDCB);
BOOL BuildCommDCBAndTimeoutsA(LPCSTR,LPDCB,LPCOMMTIMEOUTS);
BOOL CommConfigDialogA(LPCSTR,HWND,LPCOMMCONFIG);
BOOL GetDefaultCommConfigA(LPCSTR,LPCOMMCONFIG,LPDWORD);
BOOL SetDefaultCommConfigA(LPCSTR,LPCOMMCONFIG,DWORD);
BOOL GetComputerNameA (LPSTR,LPDWORD);
BOOL SetComputerNameA (LPCSTR);
BOOL GetUserNameA (LPSTR,LPDWORD);
int wvsprintfA(LPSTR,LPCSTR,va_list arglist);
int CDECL wsprintfA(LPSTR,LPCSTR,...);
HKL LoadKeyboardLayoutA(LPCSTR,UINT);
BOOL GetKeyboardLayoutNameA(LPSTR);
HDESK CreateDesktopA(LPSTR,LPSTR,LPDEVMODE,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
HDESK OpenDesktopA(LPSTR,DWORD,BOOL,DWORD);
BOOL EnumDesktopsA(HWINSTA,DESKTOPENUMPROC,LPARAM);
HWINSTA CreateWindowStationA(LPSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES);
HWINSTA OpenWindowStationA(LPSTR,BOOL,DWORD);
BOOL EnumWindowStationsA(ENUMWINDOWSTATIONPROC,LPARAM);
BOOL GetUserObjectInformationA(HANDLE,int,PVOID,DWORD,LPDWORD);
BOOL SetUserObjectInformationA(HANDLE,int,PVOID,DWORD);
UINT RegisterWindowMessageA(LPCSTR);
BOOL GetMessageA(LPMSG,HWND,UINT,UINT);
LONG DispatchMessageA(CONST MSG *);
BOOL PeekMessageA(LPMSG,HWND,UINT,UINT,UINT);
LRESULT SendMessageA(HWND,UINT,WPARAM,LPARAM);
LRESULT SendMessageTimeoutA(HWND,UINT,WPARAM,LPARAM,UINT,UINT,LPDWORD);
BOOL SendNotifyMessageA(HWND,UINT,WPARAM,LPARAM);
BOOL SendMessageCallbackA(HWND,UINT,WPARAM,LPARAM,SENDASYNCPROC,DWORD);
BOOL PostMessageA(HWND,UINT,WPARAM,LPARAM);
BOOL PostThreadMessageA(DWORD,UINT,WPARAM,LPARAM);
LRESULT DefWindowProcA(HWND,UINT,WPARAM,LPARAM);
LRESULT CallWindowProcA(WNDPROC,HWND,UINT,WPARAM,LPARAM);
ATOM RegisterClassA(CONST WNDCLASS *);
BOOL UnregisterClassA(LPCSTR,HINSTANCE);
BOOL GetClassInfoA(HINSTANCE,LPCSTR,LPWNDCLASS);
ATOM RegisterClassExA(CONST WNDCLASSEX *);
BOOL GetClassInfoExA(HINSTANCE,LPCSTR,LPWNDCLASSEX);
HWND CreateWindowExA(DWORD,LPCSTR,LPCSTR,DWORD,int,int,int,int,HWND,HMENU,HINSTANCE,LPVOID);
HWND CreateDialogParamA(HINSTANCE,LPCSTR,HWND,DLGPROC,LPARAM);
HWND CreateDialogIndirectParamA(HINSTANCE,LPCDLGTEMPLATE,HWND,DLGPROC,LPARAM);
int DialogBoxParamA(HINSTANCE,LPCSTR,HWND,DLGPROC,LPARAM);
int DialogBoxIndirectParamA(HINSTANCE,LPCDLGTEMPLATE,HWND,DLGPROC,LPARAM);
BOOL SetDlgItemTextA(HWND,int,LPCSTR);
UINT GetDlgItemTextA(HWND,int,LPSTR,int);
LONG SendDlgItemMessageA(HWND,int,UINT,WPARAM,LPARAM);
LRESULT DefDlgProcA(HWND,UINT,WPARAM,LPARAM);
BOOL CallMsgFilterA(LPMSG,int);
UINT RegisterClipboardFormatA(LPCSTR);
int GetClipboardFormatNameA(UINT,LPSTR,int);
BOOL CharToOemA(LPCSTR,LPSTR);
BOOL OemToCharA(LPCSTR,LPSTR);
BOOL CharToOemBuffA(LPCSTR,LPSTR,DWORD);
BOOL OemToCharBuffA(LPCSTR,LPSTR,DWORD);
LPSTR CharUpperA(LPSTR);
DWORD CharUpperBuffA(LPSTR,DWORD);
LPSTR CharLowerA(LPSTR);
DWORD CharLowerBuffA(LPSTR,DWORD);
LPSTR CharNextA(LPCSTR);
LPSTR CharPrevA(LPCSTR,LPCSTR);
BOOL IsCharAlphaA(CHAR ch);
BOOL IsCharAlphaNumericA(CHAR);
BOOL IsCharUpperA(CHAR);
BOOL IsCharLowerA(CHAR);
int GetKeyNameTextA(LONG,LPSTR,int);
SHORT VkKeyScanA(CHAR);
SHORT VkKeyScanExA(CHAR,HKL);
UINT MapVirtualKeyA(UINT,UINT);
UINT MapVirtualKeyExA(UINT,UINT,HKL);
HACCEL LoadAcceleratorsA(HINSTANCE,LPCSTR);
HACCEL CreateAcceleratorTableA(LPACCEL,int);
int CopyAcceleratorTableA(HACCEL,LPACCEL,int);
int TranslateAcceleratorA(HWND,HACCEL,LPMSG);
HMENU LoadMenuA(HINSTANCE,LPCSTR);
HMENU LoadMenuIndirectA(CONST MENUTEMPLATE *);
BOOL ChangeMenuA(HMENU,UINT,LPCSTR,UINT,UINT);
int GetMenuStringA(HMENU,UINT,LPSTR,int,UINT);
BOOL InsertMenuA(HMENU,UINT,UINT,UINT,LPCSTR);
BOOL AppendMenuA(HMENU,UINT,UINT,LPCSTR);
BOOL ModifyMenuA(HMENU,UINT,UINT,UINT,LPCSTR);
BOOL InsertMenuItemA(HMENU,UINT,BOOL,LPCMENUITEMINFO);
BOOL GetMenuItemInfoA(HMENU,UINT,BOOL,LPMENUITEMINFO);
BOOL SetMenuItemInfoA(HMENU,UINT,BOOL,LPCMENUITEMINFO);
int DrawTextA(HDC,LPCSTR,int,LPRECT,UINT);
int DrawTextExA(HDC,LPSTR,int,LPRECT,UINT,LPDRAWTEXTPARAMS);
BOOL GrayStringA(HDC,HBRUSH,GRAYSTRINGPROC,LPARAM,int,int,int,int,int);
BOOL DrawStateA(HDC,HBRUSH,DRAWSTATEPROC,LPARAM,WPARAM,int,int,int,int,UINT);
LONG TabbedTextOutA(HDC,int,int,LPCSTR,int,int,LPINT,int);
DWORD GetTabbedTextExtentA(HDC,LPCSTR,int,int,LPINT);
BOOL SetPropA(HWND,LPCSTR,HANDLE);
HANDLE GetPropA(HWND,LPCSTR);
HANDLE RemovePropA(HWND,LPCSTR);
int EnumPropsExA(HWND,PROPENUMPROCEX,LPARAM);
int EnumPropsA(HWND,PROPENUMPROC);
BOOL SetWindowTextA(HWND,LPCSTR);
int GetWindowTextA(HWND,LPSTR,int);
int GetWindowTextLengthA(HWND);
int MessageBoxA(HWND,LPCSTR,LPCSTR,UINT);
int MessageBoxExA(HWND,LPCSTR,LPCSTR,UINT,WORD);
int MessageBoxIndirectA(LPMSGBOXPARAMS);
LONG GetWindowLongA(HWND,int);
LONG SetWindowLongA(HWND,int,LONG);
#define GetWindowLongPtrA	GetWindowLongA
#define SetWindowLongPtrA	SetWindowLongA
DWORD GetClassLongA(HWND,int);
DWORD SetClassLongA(HWND,int,LONG);
HWND FindWindowA(LPCSTR,LPCSTR);
HWND FindWindowExA(HWND,HWND,LPCSTR,LPCSTR);
int GetClassNameA(HWND,LPSTR,int);
HHOOK SetWindowsHookExA(int,HOOKPROC,HINSTANCE,DWORD);
HOOKPROC WINAPI SetWindowsHookA(int,HOOKPROC);
HBITMAP LoadBitmapA(HINSTANCE,LPCSTR);
HCURSOR LoadCursorA(HINSTANCE,LPCSTR);
HCURSOR LoadCursorFromFileA(LPCSTR);
HICON LoadIconA(HINSTANCE,LPCSTR);
HANDLE LoadImageA(HINSTANCE,LPCSTR,UINT,int,int,UINT);
int LoadStringA(HINSTANCE,UINT,LPSTR,int);
BOOL IsDialogMessageA(HWND,LPMSG);
int DlgDirListA(HWND,LPSTR,int,int,UINT);
BOOL DlgDirSelectExA(HWND,LPSTR,int,int);
int DlgDirListComboBoxA(HWND,LPSTR,int,int,UINT);
BOOL DlgDirSelectComboBoxExA(HWND,LPSTR,int,int);
LRESULT DefFrameProcA(HWND,HWND,UINT,WPARAM,LPARAM);
LRESULT DefMDIChildProcA(HWND,UINT,WPARAM,LPARAM);
HWND CreateMDIWindowA(LPSTR,LPSTR,DWORD,int,int,int,int,HWND,HINSTANCE,LPARAM);
BOOL WinHelpA(HWND,LPCSTR,UINT,DWORD);
LONG ChangeDisplaySettingsA(LPDEVMODE,DWORD);
LONG WINAPI ChangeDisplaySettingsExA(LPCSTR lpszDeviceName, LPDEVMODEA lpDevMode, HWND hwnd,
											   DWORD dwflags, LPVOID lParam);
BOOL EnumDisplaySettingsA(LPCSTR,DWORD,LPDEVMODE);
BOOL SystemParametersInfoA(UINT,UINT,PVOID,UINT);
int AddFontResourceA(LPCSTR);
int WINAPI ChoosePixelFormat(HDC,PIXELFORMATDESCRIPTOR *);
BOOL WINAPI SetPixelFormat(HDC,int,PIXELFORMATDESCRIPTOR *);
HMETAFILE CopyMetaFileA(HMETAFILE,LPCSTR);
HFONT CreateFontIndirectA(CONST LOGFONT *);
HDC CreateICA(LPCSTR,LPCSTR,LPCSTR,CONST DEVMODE *);
HDC CreateMetaFileA(LPCSTR);
BOOL CreateScalableFontResourceA(DWORD,LPCSTR,LPCSTR,LPCSTR);
int DeviceCapabilitiesA(LPCSTR,LPCSTR,WORD,LPSTR,CONST DEVMODE *);
int EnumFontFamiliesExA(HDC,LPLOGFONT,FONTENUMEXPROC,LPARAM,DWORD);
int EnumFontFamiliesA(HDC,LPCSTR,FONTENUMPROC,LPARAM);
int EnumFontsA(HDC,LPCSTR,ENUMFONTSPROC,LPARAM);
BOOL GetCharWidthA(HDC,UINT,UINT,LPINT);
BOOL GetCharWidth32A(HDC,UINT,UINT,LPINT);
BOOL GetCharWidthFloatA(HDC,UINT,UINT,PFLOAT);
BOOL GetCharABCWidthsA(HDC,UINT,UINT,LPABC);
BOOL GetCharABCWidthsFloatA(HDC,UINT,UINT,LPABCFLOAT);
DWORD GetGlyphOutlineA(HDC,UINT,UINT,LPGLYPHMETRICS,DWORD,LPVOID,CONST MAT2 *);
HMETAFILE GetMetaFileA(LPCSTR);
UINT GetOutlineTextMetricsA(HDC,UINT,LPOUTLINETEXTMETRIC);
BOOL GetTextExtentPointA(HDC,LPCSTR,int,LPSIZE);
BOOL GetTextExtentPoint32A(HDC,LPCSTR,int,LPSIZE);
BOOL GetTextExtentExPointA(HDC,LPCSTR,int,int,LPINT,LPINT,LPSIZE);
BOOL SignalObjectAndWait(HANDLE,HANDLE,DWORD,BOOL);
DWORD GetCharacterPlacementA(HDC,LPCSTR,int,int,LPGCP_RESULTS,DWORD);
HDC ResetDCA(HDC,CONST DEVMODE *);
BOOL RemoveFontResourceA(LPCSTR);
HENHMETAFILE CopyEnhMetaFileA(HENHMETAFILE,LPCSTR);
HDC CreateEnhMetaFileA(HDC,LPCSTR,CONST RECT *,LPCSTR);
HENHMETAFILE GetEnhMetaFileA(LPCSTR);
UINT GetEnhMetaFileDescriptionA(HENHMETAFILE,UINT,LPSTR);
BOOL GetTextMetricsA(HDC,LPTEXTMETRIC);
int StartDocA(HDC,CONST DOCINFO *);
int GetObjectA(HGDIOBJ,int,LPVOID);
BOOL TextOutA(HDC,int,int,LPCSTR,int);
BOOL ExtTextOutA(HDC,int,int,UINT,CONST RECT *,LPCSTR,UINT,CONST INT *);
BOOL PolyTextOutA(HDC,CONST POLYTEXT *,int);
int GetTextFaceA(HDC,int,LPSTR);
DWORD GetKerningPairsA(HDC,DWORD,LPKERNINGPAIR);
HCOLORSPACE CreateColorSpaceA(LPLOGCOLORSPACE);
BOOL GetLogColorSpaceA(HCOLORSPACE,LPLOGCOLORSPACE,DWORD);
BOOL GetICMProfileA(HDC,DWORD,LPSTR);
BOOL SetICMProfileA(HDC,LPSTR);
BOOL UpdateICMRegKeyA(DWORD,DWORD,LPSTR,UINT);
int EnumICMProfilesA(HDC,ICMENUMPROC,LPARAM);
int PropertySheetA(LPCPROPSHEETHEADER);
HIMAGELIST ImageList_LoadImageA(HINSTANCE,LPCSTR,int,int,COLORREF,UINT,UINT);
HWND CreateStatusWindowA(LONG,LPCSTR,HWND,UINT);
void DrawStatusTextA(HDC,LPRECT,LPCSTR,UINT);
BOOL GetOpenFileNameA(LPOPENFILENAME);
BOOL GetSaveFileNameA(LPOPENFILENAME);
short GetFileTitleA(LPCSTR,LPSTR,WORD);
BOOL ChooseColorA(LPCHOOSECOLOR);
HWND FindTextA(LPFINDREPLACE);
HWND ReplaceTextA(LPFINDREPLACE);
BOOL ChooseFontA(LPCHOOSEFONT);
BOOL PrintDlgA(LPPRINTDLG);
BOOL PageSetupDlgA(LPPAGESETUPDLG);
BOOL CreateProcessA(LPCSTR,LPSTR,LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES,BOOL,DWORD,LPVOID,LPCSTR,LPSTARTUPINFO,LPPROCESS_INFORMATION);
BOOL WINAPI CreateProcessWithTokenW(HANDLE,DWORD,LPCWSTR,LPWSTR,DWORD,LPVOID,
	LPCWSTR,LPSTARTUPINFOW,LPPROCESS_INFORMATION);
VOID GetStartupInfoA(LPSTARTUPINFO);
HANDLE FindFirstFileA(LPCSTR,LPWIN32_FIND_DATA);
HANDLE WINAPI FindFirstFileExA(LPCSTR,FINDEX_INFO_LEVELS,LPVOID,FINDEX_SEARCH_OPS,LPVOID,DWORD);
BOOL FindNextFileA(HANDLE,LPWIN32_FIND_DATA);
BOOL GetVersionExA(LPOSVERSIONINFO);
#define CreateWindowA(C,WN,S,x,y,W,H,hW,hM,hI,l) CreateWindowExA(0,C,WN,S,x,y,W,H,hW,hM,hI,l)
#define CreateDialogA(hI,Name,hP,Func) CreateDialogParamA(hI,Name,hP,Func,0)
#define CreateDialogIndirectA(hI,T,P,Func) CreateDialogIndirectParamA(hI,T,P,Func,0)
#define DialogBoxA(h,T,P,D) DialogBoxParamA(h,T,P,D,0)
#define DialogBoxIndirectA(h,T,P,D) DialogBoxIndirectParamA(h,T,P,D,0)
HDC CreateDCA(LPCSTR,LPCSTR,LPCSTR,CONST DEVMODE *);
DWORD VerInstallFileA(DWORD,LPSTR,LPSTR,LPSTR,LPSTR,LPSTR,LPSTR,PUINT);
DWORD GetFileVersionInfoSizeA(LPSTR,LPDWORD);
BOOL GetFileVersionInfoA(LPSTR,DWORD,DWORD,LPVOID);
DWORD VerLanguageNameA(DWORD,LPSTR,DWORD);
DWORD VerFindFileA(DWORD,LPSTR,LPSTR,LPSTR,LPSTR,PUINT,LPSTR,PUINT);
LONG RegConnectRegistryA(LPSTR,HKEY,PHKEY);
LONG RegCreateKeyA(HKEY,LPCSTR,PHKEY);
LONG RegCreateKeyExA(HKEY,LPCSTR,DWORD,LPSTR,DWORD,REGSAM,LPSECURITY_ATTRIBUTES,PHKEY,LPDWORD);
LONG RegDeleteKeyA(HKEY,LPCSTR);
LONG RegDeleteValueA (HKEY,LPCSTR);
LONG RegEnumKeyA (HKEY,DWORD,LPSTR,DWORD);
LONG RegEnumKeyExA(HKEY,DWORD,LPSTR,LPDWORD,LPDWORD,LPSTR,LPDWORD,PFILETIME);
LONG RegEnumValueA(HKEY,DWORD,LPSTR,LPDWORD,LPDWORD,LPDWORD,LPBYTE,LPDWORD);
LONG RegLoadKeyA(HKEY,LPCSTR,LPCSTR);
LONG RegOpenKeyA(HKEY,LPCSTR,PHKEY);
LONG RegOpenKeyExA(HKEY,LPCSTR,DWORD,REGSAM,PHKEY);
LONG RegQueryInfoKeyA(HKEY,LPSTR,LPDWORD,LPDWORD,LPDWORD,LPDWORD,
	LPDWORD,LPDWORD,LPDWORD,LPDWORD,LPDWORD,PFILETIME);
LONG RegQueryValueA(HKEY,LPCSTR,LPSTR,PLONG);
LONG RegQueryMultipleValuesA(HKEY,PVALENT,DWORD,LPSTR,LPDWORD);
LONG RegQueryValueExA (HKEY,LPCSTR,LPDWORD,LPDWORD,LPBYTE,LPDWORD);
LONG RegReplaceKeyA(HKEY,LPCSTR,LPCSTR,LPCSTR);
LONG RegRestoreKeyA (HKEY,LPCSTR,DWORD);
LONG RegSaveKeyA(HKEY,LPCSTR,LPSECURITY_ATTRIBUTES);
LONG RegSetValueA(HKEY,LPCSTR,DWORD,LPCSTR,DWORD);
LONG RegSetValueExA(HKEY,LPCSTR,DWORD,DWORD,BYTE*,DWORD);
LONG RegUnLoadKeyA(HKEY,LPCSTR);
BOOL InitiateSystemShutdownA(LPSTR,LPSTR,DWORD,BOOL,BOOL);
BOOL AbortSystemShutdownA(LPSTR);
int CompareStringA(LCID,DWORD,LPCSTR,int,LPCSTR,int);
int LCMapStringA(LCID,DWORD,LPCSTR,int,LPSTR,int);
int GetLocaleInfoA(LCID,LCTYPE,LPSTR,int);
BOOL SetLocaleInfoA(LCID,LCTYPE,LPCSTR);
int GetTimeFormatA(LCID,DWORD,CONST SYSTEMTIME *,LPCSTR,LPSTR,int);
int GetDateFormatA(LCID,DWORD,CONST SYSTEMTIME *,LPCSTR,LPSTR,int);
int GetNumberFormatA(LCID,DWORD,LPCSTR,CONST NUMBERFMTA *,LPSTR,int);
int GetCurrencyFormatA(LCID,DWORD,LPCSTR,CONST CURRENCYFMT *,LPSTR,int);
BOOL EnumCalendarInfoA(CALINFO_ENUMPROC,LCID,CALID,CALTYPE);
BOOL EnumTimeFormatsA(TIMEFMT_ENUMPROC,LCID,DWORD);
BOOL EnumDateFormatsA(DATEFMT_ENUMPROC,LCID,DWORD);
BOOL GetStringTypeExA(LCID,DWORD,LPCSTR,int,LPWORD);
BOOL GetStringTypeA(LCID,DWORD,LPCSTR,int,LPWORD);
int FoldStringA(DWORD,LPCSTR,int,LPSTR,int);
BOOL EnumSystemLocalesA(LOCALE_ENUMPROC,DWORD);
BOOL EnumSystemCodePagesA(CODEPAGE_ENUMPROC,DWORD);
BOOL PeekConsoleInputA(HANDLE,PINPUT_RECORD,DWORD,LPDWORD);
BOOL ReadConsoleInputA(HANDLE,PINPUT_RECORD,DWORD,LPDWORD);
BOOL WriteConsoleInputA(HANDLE,CONST INPUT_RECORD *,DWORD,LPDWORD);
BOOL ReadConsoleOutputA(HANDLE,PCHAR_INFO,COORD,COORD,PSMALL_RECT);
BOOL WriteConsoleOutputA(HANDLE,CONST CHAR_INFO *,COORD,COORD,PSMALL_RECT);
BOOL ReadConsoleOutputCharacterA(HANDLE,LPSTR,DWORD,COORD,LPDWORD);
BOOL WriteConsoleOutputCharacterA(HANDLE,LPCSTR,DWORD,COORD,LPDWORD);
BOOL FillConsoleOutputCharacterA(HANDLE,CHAR,DWORD,COORD,LPDWORD);
BOOL ScrollConsoleScreenBufferA(HANDLE,CONST SMALL_RECT *,CONST SMALL_RECT *,COORD,CONST CHAR_INFO *);
DWORD GetConsoleTitleA(LPSTR,DWORD);
BOOL SetConsoleTitleA(LPCSTR);
BOOL ReadConsoleA(HANDLE,LPVOID,DWORD,LPDWORD,LPVOID);
BOOL WriteConsoleA(HANDLE,CONST VOID *,DWORD,LPDWORD,LPVOID);
DWORD WNetAddConnectionA(LPCSTR,LPCSTR,LPCSTR);
DWORD WNetAddConnection2A(LPNETRESOURCE,LPCSTR,LPCSTR,DWORD);
DWORD WNetAddConnection3A(HWND,LPNETRESOURCE,LPCSTR,LPCSTR,DWORD);
DWORD WNetCancelConnectionA(LPCSTR,BOOL);
DWORD WNetCancelConnection2A(LPCSTR,DWORD,BOOL);
DWORD WNetGetConnectionA(LPCSTR,LPSTR,LPDWORD);
DWORD WNetUseConnectionA(HWND,LPNETRESOURCE,LPCSTR,LPCSTR,DWORD,LPSTR,LPDWORD,LPDWORD);
DWORD WNetSetConnectionA(LPCSTR,DWORD,LPVOID);
DWORD WNetConnectionDialog1A(LPCONNECTDLGSTRUCT);
DWORD WNetDisconnectDialog1A(LPDISCDLGSTRUCT);
DWORD WNetOpenEnumA(DWORD,DWORD,DWORD,LPNETRESOURCE,LPHANDLE);
DWORD WNetEnumResourceA(HANDLE,LPDWORD,LPVOID,LPDWORD);
DWORD WNetGetUniversalNameA(LPCSTR,DWORD,LPVOID,LPDWORD);
DWORD WNetGetUserA(LPCSTR,LPSTR,LPDWORD);
DWORD WNetGetProviderNameA(DWORD,LPSTR,LPDWORD);
DWORD WNetGetNetworkInformationA(LPCSTR,LPNETINFOSTRUCT);
DWORD WNetGetLastErrorA(LPDWORD,LPSTR,DWORD,LPSTR,DWORD);
DWORD MultinetGetConnectionPerformanceA(LPNETRESOURCE,LPNETCONNECTINFOSTRUCT);
BOOL WINAPI TrackMouseEvent(LPTRACKMOUSEEVENT);
HWND WINAPI GetAncestor(HWND,UINT);
BOOL WINAPI GetComboBoxInfo(HWND,PCOMBOBOXINFO);
UCHAR APIENTRY Netbios(PNCB);
LANGID WINAPI GetMUILanguage(void);
void WINAPI InitMUILanguage(LANGID);
#ifdef UNICODE
#define GetLongPathName GetLongPathNameW
#define GetDiskFreeSpaceEx GetDiskFreeSpaceExW
#define CreateProcessAsUser CreateProcessAsUserW
#define HDITEM	HDITEMW
#define LPHDITEM LPHDITEMW
#define COMBOBOXEXITEM	COMBOBOXEXITEMW
#define PCOMBOBOXEXITEM	PCOMBOBOXEXITEMW
#define PCCOMBOBOXEXITEM	PCCOMBOBOXEXITEMW
#define CBEM_INSERTITEM	CBEM_INSERTITEMW
#define CBEM_SETITEM	CBEM_SETITEMW
#define CBEM_GETITEM	CBEM_GETITEMW
#define DATETIMEPICK_CLASS	DATETIMEPICK_CLASSW
#define DTN_USERSTRING	DTN_USERSTRINGW
#define NMDATETIMESTRING	NMDATETIMESTRINGW
#define LPNMDATETIMESTRING	LPNMDATETIMESTRINGW
#define DTN_WMKEYDOWN	DTN_WMKEYDOWNW
#define NMDATETIMEWMKEYDOWN	NMDATETIMEWMKEYDOWNW
#define LPNMDATETIMEWMKEYDOWN	LPNMDATETIMEWMKEYDOWNW
#define DTN_FORMAT	DTN_FORMATW
#define NMDATETIMEFORMAT	NMDATETIMEFORMATW
#define LPNMDATETIMEFORMAT	LPNMDATETIMEFORMATW
#define DTN_FORMATQUERY	DTN_FORMATQUERYW
#define NMDATETIMEFORMATQUERY	NMDATETIMEFORMATQUERYW
#define LPNMDATETIMEFORMATQUERY	LPNMDATETIMEFORMATQUERYW
#define RegConnectRegistry	RegConnectRegistryW
#define RegCreateKey	RegCreateKeyW
#define RegCreateKeyEx	RegCreateKeyExW
#define RegDeleteKey	RegDeleteKeyW
#define RegDeleteValue	RegDeleteValueW
#define RegEnumKey	RegEnumKeyW
#define RegEnumKeyEx	RegEnumKeyExW
#define RegEnumValue	RegEnumValueW
#define RegLoadKey	RegLoadKeyW
#define RegOpenKey	RegOpenKeyW
#define RegOpenKeyEx	RegOpenKeyExW
#define RegQueryInfoKey RegQueryInfoKeyW
#define RegQueryValue	RegQueryValueW
#define RegQueryMultipleValues RegQueryMultipleValuesW
#define RegQueryValueEx RegQueryValueExW
#define RegReplaceKey	RegReplaceKeyW
#define RegRestoreKey	RegRestoreKeyW
#define RegSaveKey	RegSaveKeyW
#define RegSetValue	RegSetValueW
#define RegSetValueEx RegSetValueExW
#define AbortSystemShutdown AbortSystemShutdownW
#define InitiateSystemShutdown InitiateSystemShutdownW
#define RegUnLoadKey RegUnLoadKeyW
#define SetProp SetPropW
#define GetProp GetPropW
#define RemoveProp RemovePropW
#define EnumPropsEx EnumPropsExW
#define EnumProps EnumPropsW
#define SetWindowText SetWindowTextW
#define GetWindowText GetWindowTextW
#define GetWindowTextLength GetWindowTextLengthW
#define MessageBox MessageBoxW
#define MessageBoxEx MessageBoxExW
#define MessageBoxIndirect MessageBoxIndirectW
#define GetWindowLong GetWindowLongW
#define SetWindowLong SetWindowLongW
#define GetWindowLongPtr GetWindowLongPtrW
#define SetWindowLongPtr SetWindowLongPtrW
#define SetWindowLongPtrW	SetWindowLongW
#define GetClassLong GetClassLongW
#define SetClassLong SetClassLongW
#define GetClassLongPtr GetClassLongPtrW
#define SetClassLongPtr	SetClassLongPtrW
#define FindWindow FindWindowW
#define FindWindowEx FindWindowExW
#define GetClassName	GetClassNameW
#define SetWindowsHookEx	SetWindowsHookExW
#define SetWindowsHook	SetWindowsHookW
#define LoadBitmap	LoadBitmapW
#define LoadCursor	LoadCursorW
#define LoadCursorFromFile	LoadCursorFromFileW
#define LoadIcon	LoadIconW
#define LoadImage LoadImageW
#define LoadString LoadStringW
#define IsDialogMessage IsDialogMessageW
#define DlgDirList DlgDirListW
#define DlgDirSelectEx DlgDirSelectExW
#define DlgDirListComboBox DlgDirListComboBoxW
#define DlgDirSelectComboBoxEx DlgDirSelectComboBoxExW
#define DefFrameProc DefFrameProcW
#define DefMDIChildProc DefMDIChildProcW
#define CreateMDIWindow CreateMDIWindowW
#define WinHelp WinHelpW
#define ChangeDisplaySettings ChangeDisplaySettingsW
#define ChangeDisplaySettingsEx ChangeDisplaySettingsExW
#define EnumDisplaySettings EnumDisplaySettingsW
#define SystemParametersInfo SystemParametersInfoW
#define AddFontResource AddFontResourceW
#define CopyMetaFile CopyMetaFileW
#define CreateDC CreateDCW
#define CreateFontIndirect CreateFontIndirectW
#define CreateFont CreateFontW
#define CreateIC CreateICW
#define CreateMetaFile CreateMetaFileW
#define CreateScalableFontResource CreateScalableFontResourceW
#define DeviceCapabilities DeviceCapabilitiesW
#define EnumFontFamiliesEx EnumFontFamiliesExW
#define EnumFontFamilies EnumFontFamiliesW
#define EnumFonts EnumFontsW
#define GetCharWidth GetCharWidthW
#define GetCharWidth32 GetCharWidth32W
#define GetCharWidthFloat GetCharWidthFloatW
#define GetCharABCWidths GetCharABCWidthsW
#define GetCharABCWidthsFloat GetCharABCWidthsFloatW
#define GetGlyphOutline GetGlyphOutlineW
#define GetMetaFile GetMetaFileW
#define GetOutlineTextMetrics GetOutlineTextMetricsW
#define GetTextExtentPoint GetTextExtentPointW
#define GetTextExtentPoint32 GetTextExtentPoint32W
#define GetTextExtentExPoint GetTextExtentExPointW
#define GetCharacterPlacement GetCharacterPlacementW
#define ResetDC ResetDCW
#define RemoveFontResource RemoveFontResourceW
#define CopyEnhMetaFile CopyEnhMetaFileW
#define CreateEnhMetaFile CreateEnhMetaFileW
#define GetEnhMetaFile GetEnhMetaFileW
#define GetEnhMetaFileDescription GetEnhMetaFileDescriptionW
#define GetTextMetrics GetTextMetricsW
#define StartDoc StartDocW
#define GetObject GetObjectW
#define TextOut TextOutW
#define ExtTextOut ExtTextOutW
#define PolyTextOut PolyTextOutW
#define GetTextFace GetTextFaceW
#define GetKerningPairs GetKerningPairsW
#define GetLogColorSpace GetLogColorSpaceW
#define CreateColorSpace CreateColorSpaceW
#define GetICMProfile GetICMProfileW
#define SetICMProfile SetICMProfileW
#define UpdateICMRegKey UpdateICMRegKeyW
#define EnumICMProfiles EnumICMProfilesW
#define CreatePropertySheetPage CreatePropertySheetPageW
#define PropertySheet PropertySheetW
#define ImageList_LoadImage ImageList_LoadImageW
#define CreateStatusWindow CreateStatusWindowW
#define DrawStatusText DrawStatusTextW
#define GetOpenFileName GetOpenFileNameW
#define GetSaveFileName GetSaveFileNameW
#define GetFileTitle GetFileTitleW
#define ChooseColor ChooseColorW
#define FindText FindTextW
#define ReplaceText ReplaceTextW
#define ChooseFont ChooseFontW
#define PrintDlg PrintDlgW
#define PageSetupDlg PageSetupDlgW
#define DefWindowProc DefWindowProcW
#define CallWindowProc CallWindowProcW
#define RegisterClass RegisterClassW
#define UnregisterClass UnregisterClassW
#define GetClassInfo GetClassInfoW
#define RegisterClassEx RegisterClassExW
#define GetClassInfoEx GetClassInfoExW
#define CreateWindowEx CreateWindowExW
#define CreateWindow CreateWindowW
#define CreateDialogParam CreateDialogParamW
#define CreateDialogIndirectParam CreateDialogIndirectParamW
#define CreateDialog CreateDialogW
#define CreateDialogIndirect CreateDialogIndirectW
#define DialogBoxParam DialogBoxParamW
#define DialogBoxIndirectParam DialogBoxIndirectParamW
#define DialogBox DialogBoxW
#define DialogBoxIndirect DialogBoxIndirectW
#define RegisterClipboardFormat RegisterClipboardFormatW
#define SetDlgItemText SetDlgItemTextW
#define GetDlgItemText GetDlgItemTextW
#define SendDlgItemMessage SendDlgItemMessageW
#define DefDlgProc DefDlgProcW
#define CallMsgFilter CallMsgFilterW
#define GetClipboardFormatName GetClipboardFormatNameW
#define CharToOem CharToOemW
#define OemToChar OemToCharW
#define CharToOemBuff CharToOemBuffW
#define OemToCharBuff OemToCharBuffW
#define CharUpper CharUpperW
#define CharUpperBuff CharUpperBuffW
#define CharLower CharLowerW
#define CharLowerBuff CharLowerBuffW
#define CharNext CharNextW
#define CharPrev CharPrevW
#define IsCharAlpha IsCharAlphaW
#define IsCharAlphaNumeric IsCharAlphaNumericW
#define IsCharUpper IsCharUpperW
#define IsCharLower IsCharLowerW
#define GetKeyNameText GetKeyNameTextW
#define VkKeyScan VkKeyScanW
#define VkKeyScanEx VkKeyScanExW
#define MapVirtualKey MapVirtualKeyW
#define MapVirtualKeyEx MapVirtualKeyExW
#define LoadAccelerators LoadAcceleratorsW
#define CreateAcceleratorTable CreateAcceleratorTableW
#define CopyAcceleratorTable CopyAcceleratorTableW
#define TranslateAccelerator TranslateAcceleratorW
#define LoadMenu LoadMenuW
#define LoadMenuIndirect LoadMenuIndirectW
#define ChangeMenu ChangeMenuW
#define GetMenuString GetMenuStringW
#define InsertMenu InsertMenuW
#define AppendMenu AppendMenuW
#define ModifyMenu ModifyMenuW
#define InsertMenuItem InsertMenuItemW
#define GetMenuItemInfo GetMenuItemInfoW
#define SetMenuItemInfo SetMenuItemInfoW
#define DrawText DrawTextW
#define DrawTextEx DrawTextExW
#define GrayString GrayStringW
#define DrawState DrawStateW
#define TabbedTextOut TabbedTextOutW
#define GetTabbedTextExtent GetTabbedTextExtentW
#define GetVersionEx GetVersionExW
#define wvsprintf wvsprintfW
#define wsprintf wsprintfW
#define LoadKeyboardLayout LoadKeyboardLayoutW
#define GetKeyboardLayoutName GetKeyboardLayoutNameW
#define CreateDesktop CreateDesktopW
#define OpenDesktop OpenDesktopW
#define EnumDesktops EnumDesktopsW
#define CreateWindowStation CreateWindowStationW
#define OpenWindowStation OpenWindowStationW
#define EnumWindowStations EnumWindowStationsW
#define IsBadStringPtr IsBadStringPtrW
#define LookupAccountSid LookupAccountSidW
#define LookupAccountName LookupAccountNameW
#define LookupPrivilegeValue LookupPrivilegeValueW
#define LookupPrivilegeName LookupPrivilegeNameW
#define LookupPrivilegeDisplayName LookupPrivilegeDisplayNameW
#define BuildCommDCB BuildCommDCBW
#define BuildCommDCBAndTimeouts BuildCommDCBAndTimeoutsW
#define CommConfigDialog CommConfigDialogW
#define GetDefaultCommConfig GetDefaultCommConfigW
#define SetDefaultCommConfig SetDefaultCommConfigW
#define GetComputerName GetComputerNameW
#define SetComputerName SetComputerNameW
#define GetUserName GetUserNameW
#define CreateMailslot CreateMailslotW
#define FormatMessage FormatMessageW
#define GetEnvironmentStrings GetEnvironmentStringsW
#define FreeEnvironmentStrings FreeEnvironmentStringsW
#define lstrcmp lstrcmpW
#define lstrcmpi lstrcmpiW
#define lstrcpyn lstrcpynW
#define lstrcpy lstrcpyW
#define lstrcat lstrcatW
#define lstrlen lstrlenW
#define GetBinaryType GetBinaryTypeW
#define GetShortPathName GetShortPathNameW
#define SetFileSecurity SetFileSecurityW
#define GetFileSecurity GetFileSecurityW
#define FindFirstChangeNotification FindFirstChangeNotificationW
#define AccessCheckAndAuditAlarm AccessCheckAndAuditAlarmW
#define ObjectOpenAuditAlarm ObjectOpenAuditAlarmW
#define ObjectPrivilegeAuditAlarm ObjectPrivilegeAuditAlarmW
#define ObjectCloseAuditAlarm ObjectCloseAuditAlarmW
#define PrivilegedServiceAuditAlarm PrivilegedServiceAuditAlarmW
#define OpenEventLog OpenEventLogW
#define RegisterEventSource RegisterEventSourceW
#define OpenBackupEventLog OpenBackupEventLogW
#define ReadEventLog ReadEventLogW
#define ReportEvent ReportEventW
#define CreateProcess CreateProcessW
#define FatalAppExit FatalAppExitW
#define GetStartupInfo GetStartupInfoW
#define GetEnvironmentVariable GetEnvironmentVariableW
#define GetCommandLine GetCommandLineW
#define SetEnvironmentVariable SetEnvironmentVariableW
#define ExpandEnvironmentStrings ExpandEnvironmentStringsW
#define OutputDebugString OutputDebugStringW
#define FindResource FindResourceW
#define FindResourceEx FindResourceExW
#define EnumResourceTypes EnumResourceTypesW
#define EnumResourceNames EnumResourceNamesW
#define EnumResourceLanguages EnumResourceLanguagesW
#define BeginUpdateResource BeginUpdateResourceW
#define UpdateResource UpdateResourceW
#define EndUpdateResource EndUpdateResourceW
#define GlobalAddAtom GlobalAddAtomW
#define GlobalFindAtom GlobalFindAtomW
#define GlobalGetAtomName GlobalGetAtomNameW
#define AddAtom AddAtomW
#define FindAtom FindAtomW
#define GetAtomName GetAtomNameW
#define GetProfileInt GetProfileIntW
#define GetProfileString GetProfileStringW
#define WriteProfileString WriteProfileStringW
#define GetProfileSection GetProfileSectionW
#define WriteProfileSection WriteProfileSectionW
#define GetPrivateProfileInt GetPrivateProfileIntW
#define GetPrivateProfileSectionNames GetrivateProfileSectionNamesW
#define GetPrivateProfileString GetPrivateProfileStringW
#define WritePrivateProfileString WritePrivateProfileStringW
#define WritePrivateProfileStruct WritePrivateProfileStructW
#define GetPrivateProfileSection GetPrivateProfileSectionW
#define WritePrivateProfileSection WritePrivateProfileSectionW
#define GetDriveType GetDriveTypeW
#define GetSystemDirectory GetSystemDirectoryW
#define GetTempPath GetTempPathW
#define GetTempFileName GetTempFileNameW
#define GetWindowsDirectory GetWindowsDirectoryW
#define SetCurrentDirectory SetCurrentDirectoryW
#define GetCurrentDirectory GetCurrentDirectoryW
#define GetDiskFreeSpace GetDiskFreeSpaceW
#define CreateDirectory CreateDirectoryW
#define CreateDirectoryEx CreateDirectoryExW
#define RemoveDirectory RemoveDirectoryW
#define GetFullPathName GetFullPathNameW
#define DefineDosDevice DefineDosDeviceW
#define QueryDosDevice QueryDosDeviceW
#define CreateFile CreateFileW
#define SetFileAttributes SetFileAttributesW
#define GetFileAttributes GetFileAttributesW
#define GetCompressedFileSize GetCompressedFileSizeW
#define DeleteFile DeleteFileW
#define FindFirstFile FindFirstFileW
#define FindFirstFileEx FindFirstFileExW
#define FindNextFile FindNextFileW
#define SearchPath SearchPathW
#define CopyFile CopyFileW
#define CopyFileEx CopyFileExW
#define CreateHardLink CreateHardLinkW
#define MoveFile MoveFileW
#define MoveFileWithProgress MoveFileWithProgressW
#define MoveFileEx MoveFileExW
#define CreateNamedPipe CreateNamedPipeW
#define GetNamedPipeHandleState GetNamedPipeHandleStateW
#define CallNamedPipe CallNamedPipeW
#define WaitNamedPipe WaitNamedPipeW
#define SetVolumeLabel SetVolumeLabelW
#define GetVolumeInformation GetVolumeInformationW
#define ClearEventLog ClearEventLogW
#define BackupEventLog BackupEventLogW
#define CreateMutex CreateMutexW
#define OpenMutex OpenMutexW
#define CreateEvent CreateEventW
#define OpenEvent OpenEventW
#define CreateSemaphore CreateSemaphoreW
#define OpenSemaphore OpenSemaphoreW
#define CreateFileMapping CreateFileMappingW
#define OpenFileMapping OpenFileMappingW
#define GetLogicalDriveStrings GetLogicalDriveStringsW
#define LoadLibrary LoadLibraryW
#define LoadLibraryEx LoadLibraryExW
#define GetModuleFileName GetModuleFileNameW
#define GetModuleHandle GetModuleHandleW
#define GetUserObjectInformation GetUserObjectInformationW
#define SetUserObjectInformation SetUserObjectInformationW
#define RegisterWindowMessage RegisterWindowMessageW
#define GetMessage GetMessageW
#define DispatchMessage DispatchMessageW
#define PeekMessage PeekMessageW
#define SendMessage SendMessageW
#define SendMessageTimeout SendMessageTimeoutW
#define SendNotifyMessage SendNotifyMessageW
#define SendMessageCallback SendMessageCallbackW
#define PostMessage PostMessageW
#define PostThreadMessage PostThreadMessageW
#define VerFindFile VerFindFileW
#define VerInstallFile VerInstallFileW
#define GetFileVersionInfoSize GetFileVersionInfoSizeW
#define GetFileVersionInfo GetFileVersionInfoW
#define VerLanguageName VerLanguageNameW
#define VerQueryValue VerQueryValueW
#define CompareString CompareStringW
#define LCMapString LCMapStringW
#define GetLocaleInfo GetLocaleInfoW
#define SetLocaleInfo SetLocaleInfoW
#define GetTimeFormat GetTimeFormatW
#define GetDateFormat GetDateFormatW
#define GetNumberFormat GetNumberFormatW
#define GetCurrencyFormat GetCurrencyFormatW
#define EnumCalendarInfo EnumCalendarInfoW
#define EnumTimeFormats EnumTimeFormatsW
#define FoldString FoldStringW
#define EnumSystemCodePages EnumSystemCodePagesW
#define EnumSystemLocales EnumSystemLocalesW
#define GetStringTypeEx GetStringTypeExW
#define EnumDateFormats EnumDateFormatsW
#define GetConsoleTitle GetConsoleTitleW
#define ScrollConsoleScreenBuffer ScrollConsoleScreenBufferW
#define SetConsoleTitle SetConsoleTitleW
#define ReadConsole ReadConsoleW
#define WriteConsole WriteConsoleW
#define PeekConsoleInput PeekConsoleInputW
#define ReadConsoleInput ReadConsoleInputW
#define WriteConsoleInput WriteConsoleInputW
#define ReadConsoleOutput ReadConsoleOutputW
#define WriteConsoleOutput WriteConsoleOutputW
#define ReadConsoleOutputCharacter ReadConsoleOutputCharacterW
#define WriteConsoleOutputCharacter WriteConsoleOutputCharacterW
#define FillConsoleOutputCharacter FillConsoleOutputCharacterW
#define WNetGetProviderName WNetGetProviderNameW
#define WNetGetNetworkInformation WNetGetNetworkInformationW
#define WNetGetLastError WNetGetLastErrorW
#define MultinetGetConnectionPerformance MultinetGetConnectionPerformanceW
#define WNetConnectionDialog1 WNetConnectionDialog1W
#define WNetDisconnectDialog1 WNetDisconnectDialog1W
#define WNetOpenEnum WNetOpenEnumW
#define WNetEnumResource WNetEnumResourceW
#define WNetGetUniversalName WNetGetUniversalNameW
#define WNetGetUser WNetGetUserW
#define WNetAddConnection WNetAddConnectionW
#define WNetAddConnection2 WNetAddConnection2W
#define WNetAddConnection3 WNetAddConnection3W
#define WNetCancelConnection WNetCancelConnectionW
#define WNetCancelConnection2 WNetCancelConnection2W
#define WNetGetConnection WNetGetConnectionW
#define WNetUseConnection WNetUseConnectionW
#define WNetSetConnection WNetSetConnectionW
#define CreateService CreateServiceW
#define ChangeServiceConfig ChangeServiceConfigW
#define EnumDependentServices EnumDependentServicesW
#define EnumServicesStatus EnumServicesStatusW
#define GetServiceKeyName GetServiceKeyNameW
#define GetServiceDisplayName GetServiceDisplayNameW
#define OpenSCManager OpenSCManagerW
#define OpenService OpenServiceW
#define QueryServiceConfig QueryServiceConfigW
#define QueryServiceLockStatus QueryServiceLockStatusW
#define RegisterServiceCtrlHandler RegisterServiceCtrlHandlerW
#define StartServiceCtrlDispatcher StartServiceCtrlDispatcherW
#define StartService StartServiceW
#define CommDlg_OpenSave_GetSpec CommDlg_OpenSave_GetSpecW
#define CommDlg_OpenSave_GetFilePath CommDlg_OpenSave_GetFilePathW
#define CommDlg_OpenSave_GetFolderPath CommDlg_OpenSave_GetFolderPathW
#define GetPrivateProfileStruct GetPrivateProfileStructW
#define LVCOLUMN LVCOLUMNW
#define GetVolumeNameForVolumeMountPoint GetVolumeNameForVolumeMountPointW
#define GetVolumePathName GetVolumePathNameW
#define GetVolumePathNamesForVolumeName GetVolumePathNamesForVolumeNameW
#define DeleteVolumeMountPoint DeleteVolumeMountPointW
#define SetVolumeMountPoint SetVolumeMountPointW
#define FindNextVolumeMountPoint FindNextVolumeMountPointW
#define FindFirstVolumeMountPoint FindFirstVolumeMountPointW
#define FindNextVolume FindNextVolumeW
#define FindFirstVolume FindFirstVolumeW
#define GetGlyphIndices GetGlyphIndicesW
#else
#define GetGlyphIndices GetGlyphIndicesA
#define GetLongPathName GetLongPathNameA
#define GetDiskFreeSpaceEx GetDiskFreeSpaceExA
#define CreateProcessAsUser CreateProcessAsUserA
#define HDITEM HDITEMA
#define LPHDITEM LPHDITEMA
#define COMBOBOXEXITEM	COMBOBOXEXITEMA
#define PCOMBOBOXEXITEM	PCOMBOBOXEXITEMA
#define PCCOMBOBOXEXITEM	PCCOMBOBOXEXITEMA
#define CBEM_INSERTITEM	CBEM_INSERTITEMA
#define CBEM_SETITEM	CBEM_SETITEMA
#define CBEM_GETITEM	CBEM_GETITEMA
#define DATETIMEPICK_CLASS	DATETIMEPICK_CLASSA
#define DATETIMEPICK_CLASS	DATETIMEPICK_CLASSA
#define DTN_USERSTRING	DTN_USERSTRINGA
#define NMDATETIMESTRING	NMDATETIMESTRINGA
#define LPNMDATETIMESTRING	LPNMDATETIMESTRINGA
#define DTN_WMKEYDOWN	DTN_WMKEYDOWNA
#define NMDATETIMEWMKEYDOWN	NMDATETIMEWMKEYDOWNA
#define LPNMDATETIMEWMKEYDOWN	LPNMDATETIMEWMKEYDOWNA
#define DTN_FORMAT	DTN_FORMATA
#define NMDATETIMEFORMAT	NMDATETIMEFORMATA
#define LPNMDATETIMEFORMAT	LPNMDATETIMEFORMATA
#define DTN_FORMATQUERY	DTN_FORMATQUERYA
#define NMDATETIMEFORMATQUERY	NMDATETIMEFORMATQUERYA
#define LPNMDATETIMEFORMATQUERY	LPNMDATETIMEFORMATQUERYA
#define RegConnectRegistry RegConnectRegistryA
#define RegCreateKey RegCreateKeyA
#define RegCreateKeyEx RegCreateKeyExA
#define RegDeleteKey RegDeleteKeyA
#define RegDeleteValue RegDeleteValueA
#define RegEnumKey RegEnumKeyA
#define RegEnumKeyEx RegEnumKeyExA
#define RegEnumValue RegEnumValueA
#define RegLoadKey RegLoadKeyA
#define RegOpenKey RegOpenKeyA
#define RegOpenKeyEx RegOpenKeyExA
#define RegQueryInfoKey RegQueryInfoKeyA
#define RegQueryValue RegQueryValueA
#define RegQueryMultipleValues RegQueryMultipleValuesA
#define RegQueryValueEx RegQueryValueExA
#define RegReplaceKey RegReplaceKeyA
#define RegRestoreKey RegRestoreKeyA
#define RegSaveKey RegSaveKeyA
#define RegSetValue RegSetValueA
#define RegSetValueEx RegSetValueExA
#define AbortSystemShutdown AbortSystemShutdownA
#define InitiateSystemShutdown InitiateSystemShutdownA
#define RegUnLoadKey RegUnLoadKeyA
#define LoadIcon LoadIconA
#define LoadImage LoadImageA
#define LoadString LoadStringA
#define IsDialogMessage IsDialogMessageA
#define DlgDirList DlgDirListA
#define DlgDirSelectEx DlgDirSelectExA
#define DlgDirListComboBox DlgDirListComboBoxA
#define DlgDirSelectComboBoxEx DlgDirSelectComboBoxExA
#define DefFrameProc DefFrameProcA
#define DefMDIChildProc DefMDIChildProcA
#define CreateMDIWindow CreateMDIWindowA
#define WinHelp WinHelpA
#define ChangeDisplaySettings ChangeDisplaySettingsA
#define ChangeDisplaySettingsEx ChangeDisplaySettingsExA
#define EnumDisplaySettings EnumDisplaySettingsA
#define SystemParametersInfo SystemParametersInfoA
#define GetWindowLong GetWindowLongA
#define SetWindowLong SetWindowLongA
#define GetWindowLongPtrA	GetWindowLongA
#define GetWindowLongPtr	GetWindowLongPtrA
#define SetWindowLongPtr	SetWindowLongPtrA
#define GetClassLong GetClassLongA
#define GetClassLongPtr	GetClassLongPtrA
#define SetClassLongPtr	SetClassLongPtrA
#define SetClassLong SetClassLongA
#define FindWindow FindWindowA
#define FindWindowEx FindWindowExA
#define GetClassName GetClassNameA
#define SetWindowsHookEx SetWindowsHookExA
#define SetWindowsHook SetWindowsHookA
#define LoadBitmap LoadBitmapA
#define LoadCursor LoadCursorA
#define LoadCursorFromFile LoadCursorFromFileA
#define SetProp SetPropA
#define GetProp GetPropA
#define RemoveProp RemovePropA
#define EnumPropsEx EnumPropsExA
#define EnumProps EnumPropsA
#define SetWindowText SetWindowTextA
#define GetWindowText GetWindowTextA
#define GetWindowTextLength GetWindowTextLengthA
#define MessageBox MessageBoxA
#define MessageBoxEx MessageBoxExA
#define MessageBoxIndirect MessageBoxIndirectA
#define AddFontResource AddFontResourceA
#define CopyMetaFile CopyMetaFileA
#define CreateDC CreateDCA
#define CreateFontIndirect CreateFontIndirectA
#define CreateFont CreateFontA
#define CreateIC CreateICA
#define CreateMetaFile CreateMetaFileA
#define CreateScalableFontResource CreateScalableFontResourceA
#define DeviceCapabilities DeviceCapabilitiesA
#define EnumFontFamiliesEx EnumFontFamiliesExA
#define EnumFontFamilies EnumFontFamiliesA
#define EnumFonts EnumFontsA
#define GetCharWidth GetCharWidthA
#define GetCharWidth32 GetCharWidth32A
#define GetCharWidthFloat GetCharWidthFloatA
#define GetCharABCWidths GetCharABCWidthsA
#define GetCharABCWidthsFloat GetCharABCWidthsFloatA
#define GetGlyphOutline GetGlyphOutlineA
#define GetMetaFile GetMetaFileA
#define GetOutlineTextMetrics GetOutlineTextMetricsA
#define GetTextExtentPoint GetTextExtentPointA
#define GetTextExtentPoint32 GetTextExtentPoint32A
#define GetTextExtentExPoint GetTextExtentExPointA
#define GetCharacterPlacement GetCharacterPlacementA
#define ResetDC ResetDCA
#define RemoveFontResource RemoveFontResourceA
#define CopyEnhMetaFile CopyEnhMetaFileA
#define CreateEnhMetaFile CreateEnhMetaFileA
#define GetEnhMetaFile GetEnhMetaFileA
#define GetEnhMetaFileDescription GetEnhMetaFileDescriptionA
#define GetTextMetrics GetTextMetricsA
#define StartDoc StartDocA
#define GetObject GetObjectA
#define TextOut TextOutA
#define ExtTextOut ExtTextOutA
#define PolyTextOut PolyTextOutA
#define GetTextFace GetTextFaceA
#define GetKerningPairs GetKerningPairsA
#define GetLogColorSpace GetLogColorSpaceA
#define CreateColorSpace CreateColorSpaceA
#define GetICMProfile GetICMProfileA
#define SetICMProfile SetICMProfileA
#define UpdateICMRegKey UpdateICMRegKeyA
#define EnumICMProfiles EnumICMProfilesA
#define CreatePropertySheetPage CreatePropertySheetPageA
#define PropertySheet PropertySheetA
#define ImageList_LoadImage ImageList_LoadImageA
#define CreateStatusWindow CreateStatusWindowA
#define DrawStatusText DrawStatusTextA
#define GetOpenFileName GetOpenFileNameA
#define GetSaveFileName GetSaveFileNameA
#define GetFileTitle GetFileTitleA
#define ChooseColor ChooseColorA
#define FindText FindTextA
#define ReplaceText ReplaceTextA
#define ChooseFont ChooseFontA
#define PrintDlg PrintDlgA
#define PageSetupDlg PageSetupDlgA
#define DefWindowProc DefWindowProcA
#define CallWindowProc CallWindowProcA
#define RegisterClass RegisterClassA
#define UnregisterClass UnregisterClassA
#define GetClassInfo GetClassInfoA
#define RegisterClassEx RegisterClassExA
#define GetClassInfoEx GetClassInfoExA
#define CreateWindowEx CreateWindowExA
#define CreateWindow CreateWindowA
#define CreateDialogParam CreateDialogParamA
#define CreateDialogIndirectParam CreateDialogIndirectParamA
#define CreateDialog CreateDialogA
#define CreateDialogIndirect CreateDialogIndirectA
#define DialogBoxParam DialogBoxParamA
#define DialogBoxIndirectParam DialogBoxIndirectParamA
#define DialogBox DialogBoxA
#define DialogBoxIndirect DialogBoxIndirectA
#define RegisterClipboardFormat RegisterClipboardFormatA
#define SetDlgItemText SetDlgItemTextA
#define GetDlgItemText GetDlgItemTextA
#define SendDlgItemMessage SendDlgItemMessageA
#define DefDlgProc DefDlgProcA
#define CallMsgFilter CallMsgFilterA
#define GetClipboardFormatName GetClipboardFormatNameA
#define CharToOem CharToOemA
#define OemToChar OemToCharA
#define CharToOemBuff CharToOemBuffA
#define OemToCharBuff OemToCharBuffA
#define CharUpper CharUpperA
#define CharUpperBuff CharUpperBuffA
#define CharLower CharLowerA
#define CharLowerBuff CharLowerBuffA
#define CharNext CharNextA
#define CharPrev CharPrevA
#define IsCharAlpha IsCharAlphaA
#define IsCharAlphaNumeric IsCharAlphaNumericA
#define IsCharUpper IsCharUpperA
#define IsCharLower IsCharLowerA
#define GetKeyNameText GetKeyNameTextA
#define VkKeyScan VkKeyScanA
#define VkKeyScanEx VkKeyScanExA
#define MapVirtualKey MapVirtualKeyA
#define MapVirtualKeyEx MapVirtualKeyExA
#define LoadAccelerators LoadAcceleratorsA
#define CreateAcceleratorTable CreateAcceleratorTableA
#define CopyAcceleratorTable CopyAcceleratorTableA
#define TranslateAccelerator TranslateAcceleratorA
#define LoadMenu LoadMenuA
#define LoadMenuIndirect LoadMenuIndirectA
#define ChangeMenu ChangeMenuA
#define GetMenuString GetMenuStringA
#define InsertMenu InsertMenuA
#define AppendMenu AppendMenuA
#define ModifyMenu ModifyMenuA
#define InsertMenuItem InsertMenuItemA
#define GetMenuItemInfo GetMenuItemInfoA
#define SetMenuItemInfo SetMenuItemInfoA
#define DrawText DrawTextA
#define DrawTextEx DrawTextExA
#define GrayString GrayStringA
#define DrawState DrawStateA
#define TabbedTextOut TabbedTextOutA
#define GetTabbedTextExtent GetTabbedTextExtentA
#define GetVersionEx GetVersionExA
#define wvsprintf wvsprintfA
#define wsprintf wsprintfA
#define LoadKeyboardLayout LoadKeyboardLayoutA
#define GetKeyboardLayoutName GetKeyboardLayoutNameA
#define CreateDesktop CreateDesktopA
#define OpenDesktop OpenDesktopA
#define EnumDesktops EnumDesktopsA
#define CreateWindowStation CreateWindowStationA
#define OpenWindowStation OpenWindowStationA
#define EnumWindowStations EnumWindowStationsA
#define IsBadStringPtr IsBadStringPtrA
#define LookupAccountSid LookupAccountSidA
#define LookupAccountName LookupAccountNameA
#define LookupPrivilegeValue LookupPrivilegeValueA
#define LookupPrivilegeName LookupPrivilegeNameA
#define LookupPrivilegeDisplayName LookupPrivilegeDisplayNameA
#define BuildCommDCB BuildCommDCBA
#define BuildCommDCBAndTimeouts BuildCommDCBAndTimeoutsA
#define CommConfigDialog CommConfigDialogA
#define GetDefaultCommConfig GetDefaultCommConfigA
#define SetDefaultCommConfig SetDefaultCommConfigA
#define GetComputerName GetComputerNameA
#define SetComputerName SetComputerNameA
#define GetUserName GetUserNameA
#define CreateMailslot CreateMailslotA
#define FormatMessage FormatMessageA
#define GetEnvironmentStrings GetEnvironmentStringsA
#define FreeEnvironmentStrings FreeEnvironmentStringsA
#define lstrcmp lstrcmpA
#define lstrcmpi lstrcmpiA
#define lstrcpyn lstrcpynA
#define lstrcpy lstrcpyA
#define lstrcat lstrcatA
#define lstrlen lstrlenA
#define GetBinaryType GetBinaryTypeA
#define GetShortPathName GetShortPathNameA
#define SetFileSecurity SetFileSecurityA
#define GetFileSecurity GetFileSecurityA
#define FindFirstChangeNotification FindFirstChangeNotificationA
#define AccessCheckAndAuditAlarm AccessCheckAndAuditAlarmA
#define ObjectOpenAuditAlarm ObjectOpenAuditAlarmA
#define ObjectPrivilegeAuditAlarm ObjectPrivilegeAuditAlarmA
#define ObjectCloseAuditAlarm ObjectCloseAuditAlarmA
#define PrivilegedServiceAuditAlarm PrivilegedServiceAuditAlarmA
#define OpenEventLog OpenEventLogA
#define RegisterEventSource RegisterEventSourceA
#define OpenBackupEventLog OpenBackupEventLogA
#define ReadEventLog ReadEventLogA
#define ReportEvent ReportEventA
#define CreateProcess CreateProcessA
#define FatalAppExit FatalAppExitA
#define GetStartupInfo GetStartupInfoA
#define GetCommandLine GetCommandLineA
#define GetEnvironmentVariable GetEnvironmentVariableA
#define SetEnvironmentVariable SetEnvironmentVariableA
#define ExpandEnvironmentStrings ExpandEnvironmentStringsA
#define OutputDebugString OutputDebugStringA
#define FindResource FindResourceA
#define FindResourceEx FindResourceExA
#define EnumResourceTypes EnumResourceTypesA
#define EnumResourceNames EnumResourceNamesA
#define EnumResourceLanguages EnumResourceLanguagesA
#define BeginUpdateResource BeginUpdateResourceA
#define UpdateResource UpdateResourceA
#define EndUpdateResource EndUpdateResourceA
#define GlobalAddAtom GlobalAddAtomA
#define GlobalFindAtom GlobalFindAtomA
#define GlobalGetAtomName GlobalGetAtomNameA
#define AddAtom AddAtomA
#define FindAtom FindAtomA
#define GetProfileInt GetProfileIntA
#define GetAtomName GetAtomNameA
#define GetProfileString GetProfileStringA
#define WriteProfileString WriteProfileStringA
#define GetProfileSection GetProfileSectionA
#define WriteProfileSection WriteProfileSectionA
#define GetPrivateProfileInt GetPrivateProfileIntA
#define GetPrivateProfileSectionNames GetPrivateProfileSectionNamesA
#define GetPrivateProfileString GetPrivateProfileStringA
#define WritePrivateProfileString WritePrivateProfileStringA
#define WritePrivateProfileStruct WritePrivateProfileStructA
#define GetPrivateProfileSection GetPrivateProfileSectionA
#define WritePrivateProfileSection WritePrivateProfileSectionA
#define GetDriveType GetDriveTypeA
#define GetSystemDirectory GetSystemDirectoryA
#define GetTempPath GetTempPathA
#define GetTempFileName GetTempFileNameA
#define GetWindowsDirectory GetWindowsDirectoryA
#define SetCurrentDirectory SetCurrentDirectoryA
#define GetCurrentDirectory GetCurrentDirectoryA
#define GetDiskFreeSpace GetDiskFreeSpaceA
#define CreateDirectory CreateDirectoryA
#define CreateDirectoryEx CreateDirectoryExA
#define RemoveDirectory RemoveDirectoryA
#define GetFullPathName GetFullPathNameA
#define DefineDosDevice DefineDosDeviceA
#define QueryDosDevice QueryDosDeviceA
#define CreateFile CreateFileA
#define SetFileAttributes SetFileAttributesA
#define GetFileAttributes GetFileAttributesA
#define GetCompressedFileSize GetCompressedFileSizeA
#define DeleteFile DeleteFileA
#define FindFirstFile FindFirstFileA
#define FindFirstFileEx FindFirstFileExA
#define FindNextFile FindNextFileA
#define SearchPath SearchPathA
#define CopyFile CopyFileA
#define CopyFileEx CopyFileExA
#define CreateHardLink CreateHardLinkA
#define MoveFile MoveFileA
#define MoveFileEx MoveFileExA
#define MoveFileWithProgress MoveFileWithProgressA
#define CreateNamedPipe CreateNamedPipeA
#define GetNamedPipeHandleState GetNamedPipeHandleStateA
#define CallNamedPipe CallNamedPipeA
#define WaitNamedPipe WaitNamedPipeA
#define SetVolumeLabel SetVolumeLabelA
#define GetVolumeInformation GetVolumeInformationA
#define ClearEventLog ClearEventLogA
#define BackupEventLog BackupEventLogA
#define CreateMutex CreateMutexA
#define OpenMutex OpenMutexA
#define CreateEvent CreateEventA
#define OpenEvent OpenEventA
#define CreateSemaphore CreateSemaphoreA
#define OpenSemaphore OpenSemaphoreA
#define CreateFileMapping CreateFileMappingA
#define OpenFileMapping OpenFileMappingA
#define GetLogicalDriveStrings GetLogicalDriveStringsA
#define LoadLibrary LoadLibraryA
#define LoadLibraryEx LoadLibraryExA
#define GetModuleFileName GetModuleFileNameA
#define GetModuleHandle GetModuleHandleA
#define GetUserObjectInformation GetUserObjectInformationA
#define SetUserObjectInformation SetUserObjectInformationA
#define RegisterWindowMessage RegisterWindowMessageA
#define GetMessage GetMessageA
#define DispatchMessage DispatchMessageA
#define PeekMessage PeekMessageA
#define SendMessage SendMessageA
#define SendMessageTimeout SendMessageTimeoutA
#define SendNotifyMessage SendNotifyMessageA
#define SendMessageCallback SendMessageCallbackA
#define PostMessage PostMessageA
#define PostThreadMessage PostThreadMessageA
#define VerFindFile VerFindFileA
#define VerInstallFile VerInstallFileA
#define GetFileVersionInfoSize GetFileVersionInfoSizeA
#define GetFileVersionInfo GetFileVersionInfoA
#define VerLanguageName VerLanguageNameA
#define VerQueryValue VerQueryValueA
#define CompareString CompareStringA
#define LCMapString LCMapStringA
#define GetLocaleInfo GetLocaleInfoA
#define SetLocaleInfo SetLocaleInfoA
#define GetTimeFormat GetTimeFormatA
#define GetDateFormat GetDateFormatA
#define GetNumberFormat GetNumberFormatA
#define GetCurrencyFormat GetCurrencyFormatA
#define EnumCalendarInfo EnumCalendarInfoA
#define EnumTimeFormats EnumTimeFormatsA
#define FoldString FoldStringA
#define EnumSystemCodePages EnumSystemCodePagesA
#define EnumSystemLocales EnumSystemLocalesA
#define GetStringTypeEx GetStringTypeExA
#define EnumDateFormats EnumDateFormatsA
#define GetConsoleTitle GetConsoleTitleA
#define ScrollConsoleScreenBuffer ScrollConsoleScreenBufferA
#define SetConsoleTitle SetConsoleTitleA
#define ReadConsole ReadConsoleA
#define WriteConsole WriteConsoleA
#define PeekConsoleInput PeekConsoleInputA
#define ReadConsoleInput ReadConsoleInputA
#define WriteConsoleInput WriteConsoleInputA
#define ReadConsoleOutput ReadConsoleOutputA
#define WriteConsoleOutput WriteConsoleOutputA
#define ReadConsoleOutputCharacter ReadConsoleOutputCharacterA
#define WriteConsoleOutputCharacter WriteConsoleOutputCharacterA
#define FillConsoleOutputCharacter FillConsoleOutputCharacterA
#define MultinetGetConnectionPerformance MultinetGetConnectionPerformanceA
#define WNetGetLastError WNetGetLastErrorA
#define WNetGetProviderName WNetGetProviderNameA
#define WNetGetNetworkInformation WNetGetNetworkInformationA
#define WNetConnectionDialog1 WNetConnectionDialog1A
#define WNetDisconnectDialog1 WNetDisconnectDialog1A
#define WNetOpenEnum WNetOpenEnumA
#define WNetEnumResource WNetEnumResourceA
#define WNetGetUniversalName WNetGetUniversalNameA
#define WNetGetUser WNetGetUserA
#define WNetAddConnection WNetAddConnectionA
#define WNetAddConnection2 WNetAddConnection2A
#define WNetAddConnection3 WNetAddConnection3A
#define WNetCancelConnection WNetCancelConnectionA
#define WNetCancelConnection2 WNetCancelConnection2A
#define WNetGetConnection WNetGetConnectionA
#define WNetUseConnection WNetUseConnectionA
#define WNetSetConnection WNetSetConnectionA
#define OpenService OpenServiceA
#define QueryServiceConfig QueryServiceConfigA
#define QueryServiceLockStatus QueryServiceLockStatusA
#define RegisterServiceCtrlHandler RegisterServiceCtrlHandlerA
#define StartServiceCtrlDispatcher StartServiceCtrlDispatcherA
#define StartService StartServiceA
#define ChangeServiceConfig ChangeServiceConfigA
#define CreateService CreateServiceA
#define EnumDependentServices EnumDependentServicesA
#define EnumServicesStatus EnumServicesStatusA
#define GetServiceKeyName GetServiceKeyNameA
#define GetServiceDisplayName GetServiceDisplayNameA
#define OpenSCManager OpenSCManagerA
#define CommDlg_OpenSave_GetSpec CommDlg_OpenSave_GetSpecA
#define CommDlg_OpenSave_GetFilePath CommDlg_OpenSave_GetFilePathA
#define CommDlg_OpenSave_GetFolderPath CommDlg_OpenSave_GetFolderPathA
#define GetPrivateProfileStruct GetPrivateProfileStructA
#define LVCOLUMN LVCOLUMNA
#define GetVolumeNameForVolumeMountPoint GetVolumeNameForVolumeMountPointA
#define GetVolumePathName GetVolumePathNameA
#define GetVolumePathNamesForVolumeName GetVolumePathNamesForVolumeNameA
#define DeleteVolumeMountPoint DeleteVolumeMountPointA
#define SetVolumeMountPoint SetVolumeMountPointA
#define FindNextVolumeMountPoint FindNextVolumeMountPointA
#define FindFirstVolumeMountPoint FindFirstVolumeMountPointA
#define FindNextVolume FindNextVolumeA
#define FindFirstVolume FindFirstVolumeA
#endif
long get_osfhandle(int);
#define _get_osfhandle get_osfhandle
BOOL AbnormalTermination(VOID);
int AbortDoc(HDC);
BOOL AbortPrinter(HANDLE);
BOOL CALLBACK AbortProc(HDC,int);
LONG InterlockedIncrement(LPLONG);
LONG WINAPI InterlockedExchangeAdd ( LONG volatile *Addend, LONG Value );
LONG WINAPI InterlockedCompareExchange ( LONG volatile *Destination, LONG Exchange, LONG Comperand );
LONG InterlockedDecrement(LPLONG);
LONG InterlockedExchange(LPLONG,LONG);
BOOL FreeResource(HGLOBAL);
LPVOID LockResource(HGLOBAL);
int WinMain(HINSTANCE,HINSTANCE,LPSTR,int);
BOOL FreeLibrary(HINSTANCE);
VOID FreeLibraryAndExitThread(HMODULE,DWORD);
BOOL DisableThreadLibraryCalls(HMODULE);
FARPROC GetProcAddress(HINSTANCE,LPCSTR);
DWORD GetVersion(VOID);
HGLOBAL GlobalAlloc(UINT,DWORD);
HGLOBAL GlobalDiscard(HGLOBAL);
HGLOBAL GlobalReAlloc(HGLOBAL,DWORD,UINT);
DWORD GlobalSize(HGLOBAL);
UINT GlobalFlags(HGLOBAL);
LPVOID GlobalLock(HGLOBAL);
HGLOBAL GlobalHandle(LPCVOID);
BOOL GlobalUnlock(HGLOBAL);
HGLOBAL GlobalFree(HGLOBAL);
UINT GlobalCompact(DWORD);
VOID GlobalFix(HGLOBAL);
VOID GlobalUnfix(HGLOBAL);
LPVOID GlobalWire(HGLOBAL);
BOOL GlobalUnWire(HGLOBAL);
VOID GlobalMemoryStatus(LPMEMORYSTATUS);
BOOL GlobalMemoryStatusEx(LPMEMORYSTATUSEX);
HLOCAL LocalAlloc(UINT,UINT);
HLOCAL LocalDiscard(HLOCAL);
HLOCAL LocalReAlloc(HLOCAL,UINT,UINT);
LPVOID LocalLock(HLOCAL);
HLOCAL LocalHandle(LPCVOID);
BOOL LocalUnlock(HLOCAL);
UINT LocalSize(HLOCAL);
UINT LocalFlags(HLOCAL);
HLOCAL LocalFree(HLOCAL);
UINT LocalShrink(HLOCAL,UINT);
UINT LocalCompact(UINT);
BOOL FlushInstructionCache(HANDLE,LPCVOID,DWORD);
LPVOID VirtualAlloc(LPVOID,DWORD,DWORD,DWORD);
LPVOID WINAPI VirtualAllocEx(HANDLE,LPVOID,unsigned long,DWORD,DWORD);
BOOL VirtualFree(LPVOID,DWORD,DWORD);
BOOL WINAPI VirtualFreeEx(HANDLE,LPVOID,DWORD,DWORD);
BOOL VirtualProtect(LPVOID,DWORD,DWORD,PDWORD);
DWORD VirtualQuery(LPCVOID,PMEMORY_BASIC_INFORMATION,DWORD);
BOOL VirtualProtectEx(HANDLE,LPVOID,DWORD,DWORD,PDWORD);
DWORD VirtualQueryEx(HANDLE,LPCVOID,PMEMORY_BASIC_INFORMATION,DWORD);
HANDLE HeapCreate(DWORD,DWORD,DWORD);
BOOL HeapDestroy(HANDLE);
LPVOID HeapAlloc(HANDLE,DWORD,DWORD);
LPVOID HeapReAlloc(HANDLE,DWORD,LPVOID,DWORD);
BOOL HeapFree(HANDLE,DWORD,LPVOID);
DWORD HeapSize(HANDLE,DWORD,LPCVOID);
BOOL HeapValidate(HANDLE,DWORD,LPCVOID);
UINT HeapCompact(HANDLE,DWORD);
HANDLE GetProcessHeap(VOID);
DWORD WINAPI GetProcessIdOfThread(HANDLE);
DWORD WINAPI GetProcessId(HANDLE);
DWORD WINAPI GetCurrentProcessorNumber(void);
BOOL WINAPI GetProcessHandleCount(HANDLE,PDWORD);
BOOL WINAPI GetProcessIoCounters(HANDLE,PIO_COUNTERS);
BOOL WINAPI GetProcessWorkingSetSize(HANDLE,PSIZE_T,PSIZE_T);
BOOL WINAPI GetProcessWorkingSetSizeEx(HANDLE,PSIZE_T,PSIZE_T,PDWORD);
BOOL WINAPI SetProcessWorkingSetSize(HANDLE,SIZE_T,SIZE_T);
BOOL WINAPI SetProcessWorkingSetSizeEx(HANDLE,SIZE_T,SIZE_T,DWORD);
DWORD GetProcessHeaps(DWORD,PHANDLE);
DWORD GetProcessVersion(DWORD);
BOOL WINAPI SetEnvironmentStringsA(LPSTR);
BOOL WINAPI SetEnvironmentStringsW(LPWSTR);
BOOL HeapLock(HANDLE);
BOOL HeapUnlock(HANDLE);
BOOL HeapWalk(HANDLE,LPPROCESS_HEAP_ENTRY);
BOOL GetProcessAffinityMask(HANDLE,LPDWORD,LPDWORD);
BOOL GetProcessTimes(HANDLE,LPFILETIME,LPFILETIME,LPFILETIME,LPFILETIME);
BOOL GetProcessWorkingSetSize(HANDLE,LPDWORD,LPDWORD);
BOOL SetProcessWorkingSetSize(HANDLE,DWORD,DWORD);
BOOL WINAPI SetProcessAffinityMask(HANDLE,DWORD);
BOOL WINAPI SetProcessPriorityBoost(HANDLE,BOOL);
BOOL WINAPI GetProcessPriorityBoost(HANDLE,BOOL *);
BOOL WINAPI RequestWakeupLatency(LATENCY_TIME);
BOOL WINAPI IsSystemResumeAutomatic(VOID);
HANDLE WINAPI OpenThread(DWORD,BOOL,DWORD);
HANDLE OpenProcess(DWORD,BOOL,DWORD);
HANDLE GetCurrentProcess(VOID);
DWORD GetCurrentProcessId(VOID);
BOOL ProcessIdToSessionId(DWORD DWORD);
VOID ExitProcess(UINT);
BOOL TerminateProcess(HANDLE,UINT);
BOOL GetExitCodeProcess(HANDLE,LPDWORD);
VOID FatalExit(int);
LPTSTR GetEnvironmentStrings(VOID);
VOID RaiseException(DWORD,DWORD,DWORD,CONST DWORD *);
LONG UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *);
LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER);
HANDLE CreateThread(LPSECURITY_ATTRIBUTES,DWORD,LPTHREAD_START_ROUTINE,LPVOID,DWORD,LPDWORD);
HANDLE CreateRemoteThread(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,LPTHREAD_START_ROUTINE,LPVOID,DWORD,LPDWORD);
HANDLE GetCurrentThread(VOID);
DWORD GetCurrentThreadId(VOID);
DWORD SetThreadAffinityMask(HANDLE,DWORD);
DWORD WINAPI SetThreadIdealProcessor(HANDLE,DWORD);
BOOL SetThreadPriority(HANDLE,int);
int GetThreadPriority(HANDLE);
BOOL WINAPI SetThreadPriorityBoost(HANDLE,BOOL);
BOOL WINAPI GetThreadPriorityBoost(HANDLE,BOOL *);
BOOL GetThreadTimes(HANDLE,LPFILETIME,LPFILETIME,LPFILETIME,LPFILETIME);
BOOL WINAPI GetGUIThreadInfo(DWORD,PGUITHREADINFO pgui);
VOID ExitThread(DWORD);
BOOL TerminateThread(HANDLE,DWORD);
EXECUTION_STATE WINAPI SetThreadExecutionState(EXECUTION_STATE);
BOOL GetExitCodeThread(HANDLE,LPDWORD);
BOOL GetThreadSelectorEntry(HANDLE,DWORD,LPLDT_ENTRY);
DWORD GetLastError(VOID);
VOID WINAPI RestoreLastError(DWORD);
VOID SetLastError(DWORD);
BOOL GetOverlappedResult(HANDLE,LPOVERLAPPED,LPDWORD,BOOL);
HANDLE CreateIoCompletionPort(HANDLE,HANDLE,DWORD,DWORD);
BOOL GetQueuedCompletionStatus(HANDLE,LPDWORD,LPDWORD,LPOVERLAPPED *,DWORD);
BOOL WINAPI PostQueuedCompletionStatus(HANDLE,DWORD,long long int *,LPOVERLAPPED);
DWORD WINAPI QueueUserAPC(PAPCFUNC,HANDLE,long long int *);
BOOL WINAPI IsDebuggerPresent(void);
UINT SetErrorMode(UINT);
BOOL ReadProcessMemory(HANDLE,LPCVOID,LPVOID,DWORD,LPDWORD);
BOOL WriteProcessMemory(HANDLE,LPVOID,LPVOID,DWORD,LPDWORD);
BOOL GetThreadContext(HANDLE,LPCONTEXT);
BOOL SetThreadContext(HANDLE,CONST CONTEXT *);
DWORD SuspendThread(HANDLE);
DWORD ResumeThread(HANDLE);
VOID DebugBreak(VOID);
BOOL WaitForDebugEvent(LPDEBUG_EVENT,DWORD);
BOOL ContinueDebugEvent(DWORD,DWORD,DWORD);
BOOL DebugActiveProcess(DWORD);
BOOL WINAPI DebugActiveProcessStop(DWORD);
BOOL WINAPI DebugSetProcessKillOnExit(BOOL);
BOOL WINAPI DebugBreakProcess(HANDLE);
BOOL WINAPI CheckRemoteDebuggerPresent(HANDLE,PBOOL);
VOID InitializeCriticalSection(LPCRITICAL_SECTION);
VOID EnterCriticalSection(LPCRITICAL_SECTION);
VOID LeaveCriticalSection(LPCRITICAL_SECTION);
VOID DeleteCriticalSection(LPCRITICAL_SECTION);
BOOL WINAPI InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION,DWORD);
WINBASEAPI DWORD WINAPI SetCriticalSectionSpinCount(LPCRITICAL_SECTION,DWORD);
WINBASEAPI BOOL WINAPI TryEnterCriticalSection(LPCRITICAL_SECTION);
BOOL SetEvent(HANDLE);
BOOL ResetEvent(HANDLE);
BOOL PulseEvent(HANDLE);
BOOL ReleaseSemaphore(HANDLE,LONG,LPLONG);
BOOL ReleaseMutex(HANDLE);
DWORD WaitForSingleObject(HANDLE,DWORD);
DWORD WaitForMultipleObjects(DWORD,CONST HANDLE *,BOOL,DWORD);
VOID Sleep(DWORD);
HGLOBAL LoadResource(HINSTANCE,HRSRC);
DWORD SizeofResource(HINSTANCE,HRSRC);
ATOM GlobalDeleteAtom(ATOM);
BOOL InitAtomTable(DWORD);
ATOM DeleteAtom(ATOM);
UINT SetHandleCount(UINT);
DWORD GetLogicalDrives(VOID);
BOOL LockFile( HANDLE,DWORD,DWORD,DWORD,DWORD);
BOOL UnlockFile(HANDLE,DWORD,DWORD,DWORD,DWORD);
BOOL LockFileEx(HANDLE,DWORD,DWORD,DWORD,DWORD,LPOVERLAPPED);
BOOL UnlockFileEx(HANDLE,DWORD,DWORD,DWORD,LPOVERLAPPED);
BOOL GetFileInformationByHandle(HANDLE,LPBY_HANDLE_FILE_INFORMATION);
DWORD GetFileType(HANDLE);
DWORD GetFileSize(HANDLE,LPDWORD);
BOOL WINAPI GetFileSizeEx(HANDLE,PLARGE_INTEGER);
HANDLE GetStdHandle(DWORD);
BOOL SetStdHandle(DWORD,HANDLE);
BOOL WriteFile(HANDLE,LPCVOID,DWORD,LPDWORD,LPOVERLAPPED);
BOOL ReadFile(HANDLE,LPVOID,DWORD,LPDWORD,LPOVERLAPPED);
BOOL WINAPI ReadFileScatter(HANDLE h,FILE_SEGMENT_ELEMENT aSegmentArray[],DWORD,LPDWORD,LPOVERLAPPED);
BOOL WINAPI WriteFileGather(HANDLE hFile,FILE_SEGMENT_ELEMENT aSegmentArray[],DWORD n,LPDWORD l,LPOVERLAPPED);
BOOL FlushFileBuffers(HANDLE);
BOOL DeviceIoControl(HANDLE,DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD,LPOVERLAPPED);
BOOL WINAPI RequestDeviceWakeup(HANDLE);
BOOL WINAPI CancelDeviceWakeupRequest(HANDLE);
BOOL WINAPI GetDevicePowerState(HANDLE,BOOL *);
BOOL WINAPI SetMessageWaitingIndicator(HANDLE,ULONG);
BOOL SetEndOfFile(HANDLE);
DWORD SetFilePointer(HANDLE,LONG,PLONG,DWORD);
BOOL WINAPI SetFilePointerEx(HANDLE,LARGE_INTEGER,PLARGE_INTEGER,DWORD);
BOOL WINAPI SetFileValidData(HANDLE,LONGLONG);
BOOL WINAPI SetFileShortNameA(HANDLE,LPCSTR);
BOOL WINAPI SetFileShortNameW(HANDLE,LPCWSTR);
BOOL FindClose(HANDLE);
BOOL GetFileTime(HANDLE,LPFILETIME,LPFILETIME,LPFILETIME);
BOOL SetFileTime(HANDLE,CONST FILETIME *,CONST FILETIME *,CONST FILETIME *);
BOOL CloseHandle(HANDLE);
BOOL DuplicateHandle(HANDLE,HANDLE,HANDLE,LPHANDLE,DWORD,BOOL,DWORD);
BOOL GetHandleInformation(HANDLE,LPDWORD);
BOOL SetHandleInformation(HANDLE,DWORD,DWORD);
DWORD LoadModule(LPCSTR,LPVOID);
UINT WinExec(LPCSTR,UINT);
BOOL ClearCommBreak(HANDLE);
BOOL ClearCommError(HANDLE,LPDWORD,LPCOMSTAT);
BOOL SetupComm(HANDLE,DWORD,DWORD);
BOOL EscapeCommFunction(HANDLE,DWORD);
BOOL GetCommConfig(HANDLE,LPCOMMCONFIG,LPDWORD);
BOOL GetCommMask(HANDLE,LPDWORD);
BOOL GetCommProperties(HANDLE,LPCOMMPROP);
BOOL GetCommModemStatus(HANDLE,LPDWORD);
BOOL GetCommState(HANDLE,LPDCB);
BOOL GetCommTimeouts(HANDLE,LPCOMMTIMEOUTS);
BOOL PurgeComm(HANDLE,DWORD);
BOOL SetCommBreak(HANDLE);
BOOL SetCommConfig(HANDLE,LPCOMMCONFIG,DWORD);
BOOL SetCommMask(HANDLE,DWORD);
BOOL SetCommState(HANDLE,LPDCB);
BOOL SetCommTimeouts(HANDLE,LPCOMMTIMEOUTS);
BOOL TransmitCommChar(HANDLE,char);
BOOL WaitCommEvent(HANDLE,LPDWORD,LPOVERLAPPED);
DWORD SetTapePosition(HANDLE,DWORD,DWORD,DWORD,DWORD,BOOL);
DWORD GetTapePosition(HANDLE,DWORD,LPDWORD,LPDWORD,LPDWORD);
DWORD PrepareTape(HANDLE,DWORD,BOOL);
DWORD EraseTape(HANDLE,DWORD,BOOL);
DWORD CreateTapePartition(HANDLE,DWORD,DWORD,DWORD);
DWORD WriteTapemark(HANDLE,DWORD,DWORD,BOOL);
DWORD GetTapeStatus(HANDLE);
DWORD GetTapeParameters(HANDLE,DWORD,LPDWORD,LPVOID);
DWORD SetTapeParameters( HANDLE,DWORD,LPVOID);
BOOL Beep(DWORD,DWORD);
VOID OpenSound(VOID);
VOID CloseSound(VOID);
VOID StartSound(VOID);
VOID StopSound(VOID);
DWORD WaitSoundState(DWORD);
DWORD SyncAllVoices(VOID);
DWORD CountVoiceNotes(DWORD nVoice);
LPDWORD GetThresholdEvent(VOID);
DWORD GetThresholdStatus(VOID);
DWORD SetSoundNoise(DWORD,DWORD);
DWORD SetVoiceAccent(DWORD,DWORD,DWORD,DWORD,DWORD);
DWORD SetVoiceEnvelope(DWORD,DWORD,DWORD);
DWORD SetVoiceNote(DWORD,DWORD,DWORD,DWORD);
DWORD SetVoiceQueueSize(DWORD,DWORD);
DWORD SetVoiceSound(DWORD,DWORD,DWORD);
DWORD SetVoiceThreshold(DWORD,DWORD);
int MulDiv(int,int,int);
VOID GetSystemTime(LPSYSTEMTIME);
VOID GetSystemTimeAsFileTime(LPFILETIME);
BOOL SetSystemTime(CONST SYSTEMTIME *);
BOOL SetSystemPowerState(BOOL,BOOL);
BOOL WINAPI GetSystemPowerStatus(LPSYSTEM_POWER_STATUS);
VOID GetLocalTime(LPSYSTEMTIME);
BOOL SetLocalTime(CONST SYSTEMTIME *);
VOID GetSystemInfo(LPSYSTEM_INFO);
BOOL SystemTimeToTzSpecificLocalTime(LPTIME_ZONE_INFORMATION,LPSYSTEMTIME,LPSYSTEMTIME);
DWORD GetTimeZoneInformation(LPTIME_ZONE_INFORMATION);
BOOL SetTimeZoneInformation(CONST TIME_ZONE_INFORMATION *);
BOOL SystemTimeToFileTime(CONST SYSTEMTIME *,LPFILETIME);
BOOL FileTimeToLocalFileTime(CONST FILETIME *,LPFILETIME);
BOOL LocalFileTimeToFileTime(CONST FILETIME *,LPFILETIME);
BOOL FileTimeToSystemTime(CONST FILETIME *,LPSYSTEMTIME);
LONG CompareFileTime(CONST FILETIME *,CONST FILETIME *);
BOOL FileTimeToDosDateTime(CONST FILETIME *,LPWORD,LPWORD);
BOOL DosDateTimeToFileTime(WORD,WORD,LPFILETIME);
DWORD GetTickCount(VOID);
BOOL SetSystemTimeAdjustment(DWORD,BOOL);
BOOL GetSystemTimeAdjustment(PDWORD,PDWORD,PWINBOOL);
BOOL CreatePipe(PHANDLE,PHANDLE,LPSECURITY_ATTRIBUTES,DWORD);
BOOL ConnectNamedPipe(HANDLE,LPOVERLAPPED);
BOOL DisconnectNamedPipe(HANDLE);
BOOL SetNamedPipeHandleState(HANDLE,LPDWORD,LPDWORD,LPDWORD);
BOOL GetNamedPipeInfo(HANDLE,LPDWORD,LPDWORD,LPDWORD,LPDWORD);
BOOL PeekNamedPipe(HANDLE,LPVOID,DWORD,LPDWORD,LPDWORD,LPDWORD);
BOOL TransactNamedPipe(HANDLE,LPVOID,DWORD,LPVOID,DWORD,LPDWORD,LPOVERLAPPED);
BOOL GetMailslotInfo(HANDLE,LPDWORD,LPDWORD,LPDWORD,LPDWORD);
BOOL SetMailslotInfo(HANDLE,DWORD);
LPVOID MapViewOfFile(HANDLE,DWORD,DWORD,DWORD,DWORD);
BOOL FlushViewOfFile(LPCVOID,DWORD);
BOOL UnmapViewOfFile(LPVOID);
HFILE OpenFile(LPCSTR,LPOFSTRUCT,UINT);
HFILE _lopen( LPCSTR,int);
HFILE _lcreat(LPCSTR,int);
UINT _lread(HFILE,LPVOID,UINT);
UINT _lwrite(HFILE,LPCSTR,UINT);
long _hread(HFILE,LPVOID,long);
long _hwrite(HFILE,LPCSTR,long);
HFILE _lclose(HFILE);
LONG _llseek(HFILE,LONG,int);
BOOL IsTextUnicode(CONST LPVOID,int,LPINT);
WINBASEAPI DWORD WINAPI FlsAlloc(PFLS_CALLBACK_FUNCTION);
WINBASEAPI PVOID WINAPI FlsGetValue(DWORD);
WINBASEAPI BOOL WINAPI FlsSetValue(DWORD,PVOID);
WINBASEAPI BOOL WINAPI FlsFree(DWORD);
DWORD TlsAlloc(VOID);
LPVOID TlsGetValue(DWORD);
BOOL TlsSetValue(DWORD,LPVOID);
BOOL TlsFree(DWORD);
DWORD SleepEx(DWORD,BOOL);
DWORD WaitForSingleObjectEx(HANDLE,DWORD,BOOL);
DWORD WaitForMultipleObjectsEx(DWORD,CONST HANDLE *,BOOL,DWORD,BOOL);
BOOL ReadFileEx(HANDLE,LPVOID,DWORD,LPOVERLAPPED,LPOVERLAPPED_COMPLETION_ROUTINE);
BOOL WriteFileEx( HANDLE,LPCVOID,DWORD,LPOVERLAPPED,LPOVERLAPPED_COMPLETION_ROUTINE);
BOOL BackupRead(HANDLE,LPBYTE,DWORD,LPDWORD,BOOL,BOOL,LPVOID *);
BOOL BackupSeek(HANDLE,DWORD,DWORD,LPDWORD,LPDWORD,LPVOID *);
BOOL BackupWrite(HANDLE,LPBYTE,DWORD,LPDWORD,BOOL,BOOL,LPVOID *);
BOOL SetProcessShutdownParameters(DWORD,DWORD);
BOOL GetProcessShutdownParameters(LPDWORD,LPDWORD);
VOID SetFileApisToOEM(VOID);
VOID SetFileApisToANSI(VOID);
BOOL AreFileApisANSI(VOID);
BOOL CloseEventLog(HANDLE);
BOOL DeregisterEventSource(HANDLE);
BOOL NotifyChangeEventLog (HANDLE,HANDLE);
BOOL GetNumberOfEventLogRecords(HANDLE,PDWORD);
BOOL GetOldestEventLogRecord(HANDLE,PDWORD);
BOOL DuplicateToken(HANDLE,SECURITY_IMPERSONATION_LEVEL,PHANDLE);
BOOL WINAPI DuplicateTokenEx(HANDLE,DWORD,LPSECURITY_ATTRIBUTES,SECURITY_IMPERSONATION_LEVEL,TOKEN_TYPE,PHANDLE);
BOOL APIENTRY CreateRestrictedToken(HANDLE,DWORD,DWORD,PSID_AND_ATTRIBUTES,DWORD,PLUID_AND_ATTRIBUTES,DWORD,PSID_AND_ATTRIBUTES,PHANDLE);
BOOL GetKernelObjectSecurity(HANDLE,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,LPDWORD);
BOOL WINAPI IsProcessRestricted(void);
BOOL ImpersonateNamedPipeClient(HANDLE);
BOOL WINAPI ImpersonateLoggedOnUser(HANDLE);
BOOL WINAPI LogonUserA(LPSTR,LPSTR,LPSTR,DWORD,DWORD,PHANDLE);
BOOL WINAPI LogonUserW(LPWSTR,LPWSTR,LPWSTR,DWORD,DWORD,PHANDLE);
BOOL WINAPI LogonUserExA (LPCSTR,LPCSTR,LPCSTR,DWORD,DWORD,PHANDLE,PSID *,PVOID *,LPDWORD,PQUOTA_LIMITS);
BOOL WINAPI LogonUserExW (LPCWSTR,LPCWSTR,LPCWSTR,DWORD,DWORD,PHANDLE,PSID *,PVOID *,LPDWORD,PQUOTA_LIMITS);
#ifdef UNICODE
#define SetFileShortName SetFileShortNameW
#define SetEnvironmentStrings SetEnvironmentStringsW
#define LogonUserEx LogonUserExW
#define LogonUser LogonUserW
#define GetFileAttributesEx GetFileAttributesExW
#else
#define SetFileShortName SetFileShortNameA
#define SetEnvironmentStrings SetEnvironmentStringsW
#define LogonUser	LogonUserA
#define GetFileAttributesEx GetFileAttributesExA
#define LogonUserEx LogonUserExA
#endif
BOOL ImpersonateSelf(SECURITY_IMPERSONATION_LEVEL);
BOOL RevertToSelf(VOID);
BOOL SetThreadToken (PHANDLE,HANDLE);
BOOL AccessCheck(PSECURITY_DESCRIPTOR,HANDLE,DWORD,PGENERIC_MAPPING,PPRIVILEGE_SET,LPDWORD,LPDWORD,LPBOOL);
BOOL OpenProcessToken(HANDLE,DWORD,PHANDLE);
BOOL OpenThreadToken(HANDLE,DWORD,BOOL,PHANDLE);
BOOL GetTokenInformation(HANDLE,TOKEN_INFORMATION_CLASS,LPVOID,DWORD,PDWORD);
BOOL SetTokenInformation(HANDLE,TOKEN_INFORMATION_CLASS,LPVOID,DWORD);
BOOL AdjustTokenPrivileges(HANDLE,BOOL,PTOKEN_PRIVILEGES,DWORD,PTOKEN_PRIVILEGES,PDWORD);
BOOL AdjustTokenGroups (HANDLE,BOOL,PTOKEN_GROUPS,DWORD,PTOKEN_GROUPS,PDWORD);
BOOL PrivilegeCheck (HANDLE,PPRIVILEGE_SET,LPBOOL);
BOOL IsValidSid (PSID);
BOOL EqualSid(PSID,PSID);
BOOL EqualPrefixSid (PSID,PSID);
DWORD GetSidLengthRequired(UCHAR);
BOOL AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY,BYTE,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,PSID *);
PVOID FreeSid(PSID);
BOOL InitializeSid (PSID,PSID_IDENTIFIER_AUTHORITY,BYTE);
PSID_IDENTIFIER_AUTHORITY GetSidIdentifierAuthority(PSID);
PDWORD GetSidSubAuthority (PSID,DWORD);
PUCHAR GetSidSubAuthorityCount (PSID);
DWORD GetLengthSid (PSID);
BOOL CopySid(DWORD,PSID,PSID);
BOOL AreAllAccessesGranted (DWORD,DWORD);
BOOL AreAnyAccessesGranted (DWORD,DWORD);
VOID MapGenericMask(PDWORD,PGENERIC_MAPPING);
BOOL IsValidAcl(PACL);
BOOL InitializeAcl(PACL,DWORD,DWORD);
BOOL GetAclInformation(PACL,LPVOID,DWORD,ACL_INFORMATION_CLASS);
BOOL SetAclInformation (PACL,LPVOID,DWORD,ACL_INFORMATION_CLASS);
BOOL AddAce(PACL,DWORD,DWORD,LPVOID,DWORD);
BOOL WINAPI AddAccessAllowedObjectAce(PACL,DWORD,DWORD,DWORD,GUID *,GUID *,PSID);
BOOL WINAPI AddAccessDeniedAceEx(PACL,DWORD,DWORD,DWORD,PSID);
BOOL DeleteAce(PACL,DWORD);
BOOL GetAce (PACL,DWORD,LPVOID *);
BOOL AddAccessAllowedAce(PACL,DWORD,DWORD,PSID);
BOOL WINAPI AddAccessAllowedAceEx(PACL,DWORD,DWORD,DWORD,PSID);
BOOL AddAccessDeniedAce(PACL,DWORD,DWORD,PSID);
BOOL AddAuditAccessAce(PACL,DWORD,DWORD,PSID,BOOL,BOOL);
BOOL FindFirstFreeAce (PACL,LPVOID *);
BOOL InitializeSecurityDescriptor(PSECURITY_DESCRIPTOR,DWORD);
BOOL IsValidSecurityDescriptor(PSECURITY_DESCRIPTOR);
DWORD GetSecurityDescriptorLength(PSECURITY_DESCRIPTOR);
BOOL GetSecurityDescriptorControl(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR_CONTROL,LPDWORD);
BOOL SetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR,BOOL,PACL,BOOL);
BOOL GetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR,LPBOOL,PACL *,LPBOOL);
BOOL SetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR,BOOL,PACL,BOOL);
BOOL GetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR,LPBOOL,PACL *,LPBOOL);
BOOL SetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR,PSID pOwner,BOOL);
BOOL GetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR,PSID *,LPBOOL);
BOOL SetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR,PSID,BOOL);
BOOL GetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR,PSID *,LPBOOL);
DWORD WINAPI SetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR,PUCHAR);
DWORD WINAPI GetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR,PUCHAR);
BOOL WINAPI ConvertToAutoInheritPrivateObjectSecurity(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR *,GUID *,BOOLEAN,PGENERIC_MAPPING);
BOOL CreatePrivateObjectSecurity(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR *,BOOL,HANDLE,PGENERIC_MAPPING);
BOOL SetPrivateObjectSecurity(SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR *,PGENERIC_MAPPING,HANDLE);
BOOL GetPrivateObjectSecurity(PSECURITY_DESCRIPTOR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,PDWORD);
BOOL DestroyPrivateObjectSecurity(PSECURITY_DESCRIPTOR *);
BOOL MakeSelfRelativeSD(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR,LPDWORD);
BOOL MakeAbsoluteSD(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR,LPDWORD,PACL,LPDWORD,PACL,LPDWORD,PSID,LPDWORD,PSID,LPDWORD);
BOOL SetKernelObjectSecurity(HANDLE,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR);
BOOL FindNextChangeNotification(HANDLE);
BOOL FindCloseChangeNotification(HANDLE);
BOOL VirtualLock(LPVOID,DWORD);
BOOL VirtualUnlock(LPVOID,DWORD);
LPVOID MapViewOfFileEx(HANDLE,DWORD,DWORD,DWORD,DWORD,LPVOID);
BOOL SetPriorityClass(HANDLE,DWORD);
DWORD GetPriorityClass(HANDLE);
BOOL IsBadReadPtr(CONST VOID *,UINT);
BOOL IsBadWritePtr(LPVOID,UINT);
BOOL IsBadHugeReadPtr(CONST VOID *,UINT);
BOOL IsBadHugeWritePtr(LPVOID,UINT);
BOOL IsBadCodePtr(FARPROC);
BOOL AllocateLocallyUniqueId(PLUID);
BOOL QueryPerformanceCounter(LARGE_INTEGER *);
BOOL QueryPerformanceFrequency(LARGE_INTEGER *);
VOID MoveMemory(PVOID,CONST VOID *,DWORD);
VOID NTAPI RtlMoveMemory(VOID *,CONST VOID *,SIZE_T);
#define MoveMemory(a,b,c) RtlMoveMemory(a,b,c)
VOID FillMemory(PVOID,DWORD,BYTE);
VOID ZeroMemory(PVOID,DWORD);
#ifdef WIN95
HKL ActivateKeyboardLayout(HKL,UINT);
#else
BOOL ActivateKeyboardLayout(HKL,UINT);
#endif
int ToUnicodeEx(UINT,UINT,PBYTE,LPWSTR,int,UINT,HKL);
BOOL UnloadKeyboardLayout(HKL);
int GetKeyboardLayoutList(int,HKL *);
HKL GetKeyboardLayout(DWORD);
HDESK OpenInputDesktop(DWORD,BOOL,DWORD);
BOOL EnumDesktopWindows(HDESK,ENUMWINDOWSPROC,LPARAM);
BOOL SwitchDesktop(HDESK);
BOOL SetThreadDesktop(HDESK);
BOOL CloseDesktop(HDESK);
HDESK GetThreadDesktop(DWORD);
BOOL CloseWindowStation(HWINSTA);
BOOL SetProcessWindowStation(HWINSTA);
HWINSTA GetProcessWindowStation(VOID);
BOOL SetUserObjectSecurity(HANDLE,PSECURITY_INFORMATION,PSECURITY_DESCRIPTOR);
BOOL GetUserObjectSecurity(HANDLE,PSECURITY_INFORMATION,PSECURITY_DESCRIPTOR,DWORD,LPDWORD);
BOOL TranslateMessage(CONST MSG *);
BOOL SetMessageQueue(int);
BOOL RegisterHotKey(HWND,int,UINT,UINT);
BOOL UnregisterHotKey(HWND,int);
BOOL ExitWindowsEx(UINT,DWORD);
#define ExitWindows(a,b) ExitWindowsEx(EWX_LOGOFF,0xFFFFFFFF)
BOOL SwapMouseButton(BOOL);
DWORD GetMessagePos(VOID);
LONG GetMessageTime(VOID);
LONG GetMessageExtraInfo(VOID);
LPARAM SetMessageExtraInfo(LPARAM);
long BroadcastSystemMessage(DWORD,LPDWORD,UINT,WPARAM,LPARAM);
BOOL AttachThreadInput(DWORD,DWORD,BOOL);
BOOL ReplyMessage(LRESULT);
BOOL WaitMessage(VOID);
DWORD WaitForInputIdle(HANDLE,DWORD);
VOID PostQuitMessage(int);
BOOL InSendMessage(VOID);
UINT GetDoubleClickTime(VOID);
BOOL SetDoubleClickTime(UINT);
BOOL IsWindow(HWND);
BOOL IsMenu(HMENU);
BOOL IsChild(HWND,HWND);
BOOL DestroyWindow(HWND);
BOOL ShowWindow(HWND,int);
BOOL AnimateWindow(HWND,DWORD,DWORD);
BOOL UpdateLayeredWindow(HWND,HDC,POINT *,SIZE *,HDC,POINT *,COLORREF,BLENDFUNCTION *,DWORD);
BOOL SetLayeredWindowAttributes(HWND,COLORREF,BYTE,DWORD);
#define LWA_COLORKEY	1
#define LWA_ALPHA	2
#define ULW_COLORKEY	1
#define ULW_ALPHA	2
#define ULW_OPAQUE	4
BOOL ShowWindowAsync(HWND,int);
BOOL FlashWindow(HWND,BOOL);
BOOL FlashWindowEx(PFLASHWINFO);
#define FLASHW_STOP	0
#define FLASHW_CAPTION	1
#define FLASHW_TRAY	2
#define FLASHW_ALL	(FLASHW_CAPTION|FLASHW_TRAY)
#define FLASHW_TIMER	4
#define FLASHW_TIMERNOFG	0xC
BOOL ShowOwnedPopups(HWND,BOOL);
BOOL OpenIcon(HWND);
BOOL CloseWindow(HWND);
BOOL MoveWindow(HWND,int,int,int,int,BOOL);
BOOL SetWindowPos(HWND,HWND,int,int,int,int,UINT);
BOOL GetWindowPlacement(HWND,WINDOWPLACEMENT *);
BOOL SetWindowPlacement(HWND hWnd,CONST WINDOWPLACEMENT *);
HDWP BeginDeferWindowPos(int);
HDWP DeferWindowPos(HDWP,HWND,HWND,int,int,int,int,UINT);
BOOL EndDeferWindowPos(HDWP);
BOOL IsWindowVisible(HWND);
BOOL IsIconic(HWND);
BOOL AnyPopup(VOID);
BOOL BringWindowToTop(HWND);
BOOL IsZoomed(HWND);
BOOL EndDialog(HWND,int);
HWND GetDlgItem(HWND,int);
BOOL SetDlgItemInt(HWND,int,UINT,BOOL);
UINT GetDlgItemInt(HWND,int,BOOL *,BOOL);
BOOL CheckDlgButton(HWND,int,UINT);
BOOL CheckRadioButton(HWND,int,int,int);
UINT IsDlgButtonChecked(HWND,int);
HWND GetNextDlgGroupItem(HWND,HWND,BOOL);
HWND GetNextDlgTabItem(HWND,HWND,BOOL);
int GetDlgCtrlID(HWND);
long GetDialogBaseUnits(VOID);
BOOL OpenClipboard(HWND);
BOOL CloseClipboard(VOID);
HWND GetClipboardOwner(VOID);
HWND SetClipboardViewer(HWND);
HWND GetClipboardViewer(VOID);
BOOL ChangeClipboardChain(HWND,HWND);
HANDLE SetClipboardData(UINT,HANDLE);
HANDLE GetClipboardData(UINT);
int CountClipboardFormats(VOID);
UINT EnumClipboardFormats(UINT);
BOOL EmptyClipboard(VOID);
BOOL IsClipboardFormatAvailable(UINT);
int GetPriorityClipboardFormat(UINT *,int);
HWND GetOpenClipboardWindow(VOID);
LPSTR CharNextExA(WORD,LPCSTR,DWORD);
LPSTR CharPrevExA(WORD,LPCSTR,LPCSTR,DWORD dwFlags);
HWND SetFocus(HWND);
HWND GetActiveWindow(VOID);
HWND GetFocus(VOID);
UINT GetKBCodePage(VOID);
SHORT GetKeyState(int);
SHORT GetAsyncKeyState(int);
BOOL GetKeyboardState(PBYTE);
BOOL SetKeyboardState(LPBYTE);
int GetKeyboardType(int);
int ToAscii(UINT,UINT,PBYTE,LPWORD,UINT);
int ToAsciiEx(UINT,UINT,PBYTE,LPWORD,UINT,HKL);
int ToUnicode(UINT,UINT,PBYTE,LPWSTR,int,UINT);
DWORD OemKeyScan(WORD);
VOID keybd_event(BYTE,BYTE,DWORD,DWORD);
VOID mouse_event(DWORD,DWORD,DWORD,DWORD,DWORD);
BOOL GetInputState(VOID);
DWORD GetQueueStatus(UINT flags);
HWND GetCapture(VOID);
HWND SetCapture(HWND hWnd);
BOOL ReleaseCapture(VOID);
DWORD MsgWaitForMultipleObjects(DWORD,LPHANDLE,BOOL,DWORD,DWORD);
DWORD WINAPI MsgWaitForMultipleObjectsEx(DWORD,CONST HANDLE *,DWORD,DWORD,DWORD);
UINT SetTimer(HWND,UINT,UINT,TIMERPROC);
BOOL KillTimer(HWND,UINT);
BOOL IsWindowUnicode(HWND);
BOOL EnableWindow(HWND,BOOL);
BOOL IsWindowEnabled(HWND);
BOOL DestroyAcceleratorTable(HACCEL);
int GetSystemMetrics(int);
HMENU GetMenu(HWND);
BOOL WINAPI GetMenuBarInfo(HWND,LONG,LONG,PMENUBARINFO);
BOOL SetMenu(HWND,HMENU);
BOOL HiliteMenuItem(HWND,HMENU,UINT,UINT);
UINT GetMenuState(HMENU,UINT,UINT);
BOOL DrawMenuBar(HWND);
HMENU GetSystemMenu(HWND,BOOL);
HMENU CreateMenu(VOID);
HMENU CreatePopupMenu(VOID);
BOOL DestroyMenu(HMENU);
DWORD CheckMenuItem(HMENU,UINT,UINT);
BOOL EnableMenuItem(HMENU,UINT,UINT);
HMENU GetSubMenu(HMENU,int);
UINT GetMenuItemID(HMENU,int);
int GetMenuItemCount(HMENU);
BOOL RemoveMenu(HMENU,UINT,UINT);
BOOL DeleteMenu(HMENU,UINT,UINT);
BOOL SetMenuItemBitmaps(HMENU,UINT,UINT,HBITMAP,HBITMAP);
LONG GetMenuCheckMarkDimensions(VOID);
BOOL TrackPopupMenu(HMENU,UINT,int,int,int,HWND,CONST RECT *);
BOOL WINAPI GetMenuInfo(HMENU,LPMENUINFO);
BOOL WINAPI SetMenuInfo(HMENU,LPCMENUINFO);
BOOL WINAPI EndMenu(VOID);
UINT GetMenuDefaultItem(HMENU,UINT,UINT);
BOOL SetMenuDefaultItem(HMENU,UINT,UINT);
BOOL GetMenuItemRect(HWND,HMENU,UINT,LPRECT);
int MenuItemFromPoint(HWND,HMENU,POINT);
DWORD DragObject(HWND,HWND,UINT,DWORD,HCURSOR);
BOOL DragDetect(HWND,POINT);
BOOL DrawIcon(HDC,int,int,HICON);
BOOL UpdateWindow(HWND);
HWND SetActiveWindow(HWND);
HWND GetForegroundWindow(VOID);
BOOL PaintDesktop(HDC);
BOOL SetForegroundWindow(HWND hWnd);
HWND WindowFromDC(HDC hDC);
HDC GetDC(HWND);
HDC GetDCEx(HWND,HRGN,DWORD);
HDC GetWindowDC(HWND);
int ReleaseDC(HWND,HDC);
HDC BeginPaint( HWND,LPPAINTSTRUCT);
BOOL EndPaint(HWND,CONST PAINTSTRUCT *);
BOOL GetUpdateRect(HWND,LPRECT,BOOL);
int GetUpdateRgn(HWND,HRGN,BOOL);
int SetWindowRgn(HWND,HRGN,BOOL);
int GetWindowRgn(HWND,HRGN);
int ExcludeUpdateRgn(HDC,HWND);
BOOL InvalidateRect(HWND,CONST RECT *,BOOL);
BOOL ValidateRect(HWND,CONST RECT *);
BOOL InvalidateRgn(HWND,HRGN,BOOL);
BOOL ValidateRgn(HWND,HRGN);
BOOL RedrawWindow(HWND,CONST RECT *,HRGN,UINT);
BOOL LockWindowUpdate(HWND );
BOOL ScrollWindow(HWND,int,int,CONST RECT *,CONST RECT *);
BOOL ScrollDC(HDC,int,int,CONST RECT *,CONST RECT *,HRGN,LPRECT);
int ScrollWindowEx(HWND,int,int,CONST RECT *,CONST RECT *,HRGN,LPRECT,UINT);
int SetScrollPos(HWND,int,int,BOOL);
int GetScrollPos(HWND,int);
BOOL SetScrollRange(HWND,int,int,int,BOOL);
BOOL GetScrollRange(HWND,int,LPINT,LPINT);
BOOL ShowScrollBar(HWND,int,BOOL);
BOOL EnableScrollBar(HWND,UINT,UINT);
BOOL GetClientRect(HWND,LPRECT);
BOOL GetWindowRect(HWND,LPRECT);
BOOL AdjustWindowRect(LPRECT,DWORD,BOOL);
BOOL AdjustWindowRectEx(LPRECT,DWORD,BOOL,DWORD);
BOOL SetWindowContextHelpId(HWND,DWORD);
DWORD GetWindowContextHelpId(HWND);
BOOL SetMenuContextHelpId(HMENU,DWORD);
DWORD GetMenuContextHelpId(HMENU);
BOOL MessageBeep(UINT);
int ShowCursor(BOOL);
BOOL SetCursorPos(int,int);
HCURSOR SetCursor(HCURSOR);
BOOL GetCursorPos(LPPOINT);
BOOL ClipCursor(CONST RECT *);
BOOL GetClipCursor(LPRECT);
HCURSOR GetCursor(VOID);
BOOL CreateCaret(HWND,HBITMAP,int,int);
UINT GetCaretBlinkTime(VOID);
BOOL SetCaretBlinkTime(UINT);
BOOL DestroyCaret(VOID);
BOOL HideCaret(HWND);
BOOL ShowCaret(HWND);
BOOL SetCaretPos(int,int);
BOOL GetCaretPos(LPPOINT);
BOOL ClientToScreen(HWND,LPPOINT);
BOOL ScreenToClient(HWND,LPPOINT);
int MapWindowPoints(HWND,HWND,LPPOINT,UINT);
HWND WindowFromPoint(POINT);
HWND ChildWindowFromPoint(HWND,POINT);
DWORD GetSysColor(int);
HBRUSH GetSysColorBrush(int);
BOOL SetSysColors(int,CONST INT *,CONST COLORREF *);
BOOL DrawFocusRect(HDC,CONST RECT *);
int FillRect(HDC,CONST RECT *,HBRUSH);
int FrameRect(HDC,CONST RECT *,HBRUSH);
BOOL InvertRect(HDC,CONST RECT *);
BOOL SetRect(LPRECT,int,int,int,int);
BOOL SetRectEmpty(LPRECT);
BOOL CopyRect(LPRECT,CONST RECT *);
BOOL InflateRect(LPRECT,int,int);
BOOL IntersectRect(LPRECT,CONST RECT *,CONST RECT *);
BOOL UnionRect(LPRECT,CONST RECT *,CONST RECT *);
BOOL SubtractRect(LPRECT,CONST RECT *,CONST RECT *);
BOOL OffsetRect(LPRECT,int,int);
BOOL IsRectEmpty( CONST RECT *);
BOOL EqualRect(CONST RECT *,CONST RECT *);
BOOL PtInRect( CONST RECT *lprc,POINT pt);
WORD GetWindowWord(HWND,int);
WORD SetWindowWord(HWND,int,WORD);
WORD GetClassWord(HWND,int);
WORD SetClassWord(HWND,int,WORD);
HWND GetDesktopWindow(VOID);
HWND GetParent(HWND);
HWND SetParent(HWND,HWND);
BOOL EnumChildWindows(HWND,ENUMWINDOWSPROC,LPARAM);
BOOL EnumWindows(ENUMWINDOWSPROC,LPARAM );
BOOL EnumThreadWindows(DWORD,ENUMWINDOWSPROC,LPARAM);
HWND GetTopWindow(HWND);
DWORD GetWindowThreadProcessId(HWND,LPDWORD);
HWND GetLastActivePopup(HWND);
HWND GetWindow(HWND,UINT);
BOOL UnhookWindowsHook(int,HOOKPROC);
BOOL UnhookWindowsHookEx(HHOOK);
BOOL WINAPI UnhookWinEvent(HWINEVENTHOOK);
HWINEVENTHOOK WINAPI SetWinEventHook(DWORD,DWORD,HMODULE,WINEVENTPROC,DWORD,DWORD,DWORD);
LRESULT CallNextHookEx(HHOOK,int,WPARAM,LPARAM);
VOID WINAPI NotifyWinEvent(DWORD,HWND,LONG,LONG);
BOOL CheckMenuRadioItem(HMENU,UINT,UINT,UINT,UINT);
HCURSOR CreateCursor(HINSTANCE,int,int,int,int,CONST VOID *,CONST VOID *);
BOOL DestroyCursor(HCURSOR);
BOOL SetSystemCursor( HCURSOR,DWORD);
HICON CreateIcon(HINSTANCE,int,int,BYTE,BYTE,CONST BYTE *,CONST BYTE *);
BOOL DestroyIcon(HICON);
int LookupIconIdFromDirectory(PBYTE,BOOL);
int LookupIconIdFromDirectoryEx(PBYTE,BOOL,int,int,UINT);
HICON CreateIconFromResource(PBYTE,DWORD,BOOL,DWORD);
HICON CreateIconFromResourceEx(PBYTE,DWORD,BOOL,DWORD,int,int,UINT);
HICON CopyImage( HANDLE,UINT,int,int,UINT);
HICON CreateIconIndirect(PICONINFO);
HICON CopyIcon(HICON);
#define CopyCursor(p) ((HCURSOR)CopyIcon((HICON)(p)))
BOOL GetIconInfo( HICON hIcon,PICONINFO piconinfo);
BOOL MapDialogRect( HWND hDlg,LPRECT lpRect);
int SetScrollInfo(HWND,int,LPCSCROLLINFO,BOOL);
BOOL GetScrollInfo(HWND,int,LPSCROLLINFO);
BOOL TranslateMDISysAccel(HWND,LPMSG);
UINT ArrangeIconicWindows(HWND);
WORD TileWindows(HWND,UINT,CONST RECT *,UINT,const HWND *);
WORD CascadeWindows(HWND,UINT,CONST RECT *,UINT,const HWND *);
VOID SetLastErrorEx(DWORD,DWORD);
VOID SetDebugErrorLevel(DWORD);
BOOL DrawEdge(HDC,LPRECT,UINT,UINT);
BOOL DrawFrameControl(HDC,LPRECT,UINT,UINT);
BOOL DrawCaption(HWND,HDC,CONST RECT *,UINT);
BOOL DrawAnimatedRects(HWND,int,CONST RECT *,CONST RECT *);
BOOL TrackPopupMenuEx(HMENU,UINT,int,int,HWND,LPTPMPARAMS);
HWND ChildWindowFromPointEx(HWND,POINT,UINT);
HWND WINAPI RealChildWindowFromPoint(HWND,POINT);
UINT WINAPI RealGetWindowClassA(HWND,LPSTR,UINT);
BOOL WINAPI IsProcessorFeaturePresent(DWORD);
BOOL DrawIconEx(HDC,int,int,HICON,int,int,UINT,HBRUSH,UINT);
BOOL AnimatePalette(HPALETTE,UINT,UINT,CONST PALETTEENTRY *);
BOOL Arc(HDC,int,int,int,int,int,int,int,int);
BOOL BitBlt(HDC,int,int,int,int,HDC,int,int,DWORD);
BOOL CancelDC(HDC);
BOOL Chord(HDC,int,int,int,int,int,int,int,int);
HMETAFILE CloseMetaFile(HDC);
int CombineRgn(HRGN,HRGN,HRGN,int);
HBITMAP CreateBitmap(int,int,UINT,UINT,CONST VOID *);
HBITMAP CreateBitmapIndirect(CONST BITMAP *);
HBRUSH CreateBrushIndirect(CONST LOGBRUSH *);
HBITMAP CreateCompatibleBitmap(HDC,int,int);
HBITMAP CreateDiscardableBitmap(HDC,int,int);
HDC CreateCompatibleDC(HDC);
HBITMAP CreateDIBitmap(HDC,CONST BITMAPINFOHEADER *,DWORD,CONST VOID *,CONST BITMAPINFO *,UINT);
HBRUSH CreateDIBPatternBrush(HGLOBAL,UINT);
HBRUSH CreateDIBPatternBrushPt(CONST VOID *,UINT);
HRGN CreateEllipticRgn(int,int,int,int);
HRGN CreateEllipticRgnIndirect(CONST RECT *);
HBRUSH CreateHatchBrush(int,COLORREF);
HPALETTE CreatePalette(CONST LOGPALETTE *);
HPEN CreatePen(int,int,COLORREF);
HPEN CreatePenIndirect(CONST LOGPEN *);
HRGN CreatePolyPolygonRgn(CONST POINT *,CONST INT *,int,int);
HBRUSH CreatePatternBrush(HBITMAP);
HRGN CreateRectRgn(int,int,int,int);
HRGN CreateRectRgnIndirect(CONST RECT *);
HRGN CreateRoundRectRgn(int,int,int,int,int,int);
HBRUSH CreateSolidBrush(COLORREF);
BOOL DeleteDC(HDC);
BOOL DeleteMetaFile(HMETAFILE);
BOOL DeleteObject(HGDIOBJ);
int WINAPI DescribePixelFormat(HDC,int, UINT, LPPIXELFORMATDESCRIPTOR);
BOOL WINAPI SwapBuffers(HDC);
int DrawEscape(HDC,int,int,LPCSTR);
BOOL Ellipse(HDC,int,int,int,int);
int EnumObjects(HDC,int,ENUMOBJECTSPROC,LPARAM);
BOOL EqualRgn(HRGN,HRGN);
int Escape(HDC,int,int,LPCSTR,LPVOID);
int ExtEscape(HDC,int,int,LPCSTR,int,LPSTR);
int ExcludeClipRect(HDC,int,int,int,int);
HRGN ExtCreateRegion(CONST XFORM *,DWORD,CONST RGNDATA *);
BOOL ExtFloodFill(HDC,int,int,COLORREF,UINT);
BOOL FillRgn(HDC,HRGN,HBRUSH);
BOOL FloodFill(HDC,int,int,COLORREF);
BOOL FrameRgn(HDC,HRGN,HBRUSH,int,int);
int GetROP2(HDC);
BOOL GetAspectRatioFilterEx(HDC,LPSIZE);
COLORREF GetBkColor(HDC);
COLORREF GetDCBrushColor(HDC);
COLORREF GetDCPenColor(HDC);
int GetBkMode(HDC);
LONG GetBitmapBits(HBITMAP,LONG,LPVOID);
BOOL GetBitmapDimensionEx(HBITMAP,LPSIZE);
UINT GetBoundsRect(HDC,LPRECT,UINT);
BOOL GetBrushOrgEx(HDC,LPPOINT);
int GetClipBox(HDC,LPRECT);
int GetClipRgn(HDC,HRGN);
int GetMetaRgn(HDC,HRGN);
HGDIOBJ GetCurrentObject(HDC,UINT);
BOOL GetCurrentPositionEx(HDC,LPPOINT);
int GetDeviceCaps(HDC,int);
int GetDIBits(HDC,HBITMAP,UINT,UINT,LPVOID,LPBITMAPINFO,UINT);
DWORD GetFontData(HDC,DWORD,DWORD,LPVOID,DWORD);
DWORD WINAPI GetFontUnicodeRanges(HDC,LPGLYPHSET);
DWORD WINAPI GetGlyphIndicesA(HDC,LPCSTR,int,LPWORD,DWORD);
DWORD WINAPI GetGlyphIndicesW(HDC,LPCWSTR,int,LPWORD,DWORD);
int GetGraphicsMode(HDC);
int GetMapMode(HDC);
UINT GetMetaFileBitsEx(HMETAFILE,UINT,LPVOID);
COLORREF GetNearestColor(HDC,COLORREF);
UINT GetNearestPaletteIndex(HPALETTE,COLORREF);
DWORD GetObjectType(HGDIOBJ);
UINT GetPaletteEntries(HPALETTE,UINT,UINT,LPPALETTEENTRY);
COLORREF GetPixel(HDC,int,int);
int GetPixelFormat(HDC);
int GetPolyFillMode(HDC);
BOOL GetRasterizerCaps(LPRASTERIZER_STATUS,UINT);
int WINAPI GetRandomRgn (HDC,HRGN,INT);
DWORD GetRegionData(HRGN,DWORD,LPRGNDATA);
int GetRgnBox(HRGN,LPRECT);
HGDIOBJ GetStockObject(int);
int GetStretchBltMode(HDC);
UINT GetSystemPaletteEntries(HDC,UINT,UINT,LPPALETTEENTRY);
UINT GetSystemPaletteUse(HDC);
int GetTextCharacterExtra(HDC);
UINT GetTextAlign(HDC);
COLORREF GetTextColor(HDC);
int GetTextCharset(HDC);
int GetTextCharsetInfo(HDC,LPFONTSIGNATURE,DWORD);
BOOL TranslateCharsetInfo( DWORD *,LPCHARSETINFO,DWORD);
DWORD GetFontLanguageInfo(HDC);
BOOL GetViewportExtEx(HDC,LPSIZE);
BOOL GetViewportOrgEx(HDC,LPPOINT);
BOOL GetWindowExtEx(HDC,LPSIZE);
BOOL GetWindowOrgEx(HDC,LPPOINT);
int IntersectClipRect(HDC,int,int,int,int);
BOOL InvertRgn(HDC,HRGN);
BOOL LineDDA(int,int,int,int,LINEDDAPROC,LPARAM);
BOOL LineTo(HDC,int,int);
BOOL MaskBlt(HDC,int,int,int,int,HDC,int,int,HBITMAP,int,int,DWORD);
BOOL PlgBlt(HDC,CONST POINT *,HDC,int,int,int,int,HBITMAP,int,int);
int OffsetClipRgn(HDC,int,int);
int OffsetRgn(HRGN,int,int);
BOOL PatBlt(HDC,int,int,int,int,DWORD);
BOOL Pie(HDC,int,int,int,int,int,int,int,int);
BOOL PlayMetaFile(HDC,HMETAFILE);
BOOL PaintRgn(HDC,HRGN);
BOOL PolyPolygon(HDC,CONST POINT *,CONST INT *,int);
BOOL PtInRegion(HRGN,int,int);
BOOL PtVisible(HDC,int,int);
BOOL RectInRegion(HRGN,CONST RECT *);
BOOL RectVisible(HDC,CONST RECT *);
BOOL Rectangle(HDC,int,int,int,int);
BOOL RestoreDC(HDC,int);
UINT RealizePalette(HDC);
BOOL RoundRect(HDC,int,int,int,int,int,int);
BOOL ResizePalette(HPALETTE,UINT);
int SaveDC(HDC);
int SelectClipRgn(HDC,HRGN);
int ExtSelectClipRgn(HDC,HRGN,int);
int SetMetaRgn(HDC);
HGDIOBJ SelectObject(HDC,HGDIOBJ);
HPALETTE SelectPalette(HDC,HPALETTE,BOOL);
COLORREF SetBkColor(HDC,COLORREF);
int SetBkMode(HDC,int);
LONG SetBitmapBits(HBITMAP,DWORD,CONST VOID *);
UINT SetBoundsRect(HDC,CONST RECT *,UINT);
int SetDIBits(HDC,HBITMAP,UINT,UINT,CONST VOID *,CONST BITMAPINFO *,UINT);
int SetDIBitsToDevice(HDC,int,int,DWORD,DWORD,int,int,UINT,UINT,CONST VOID *,CONST BITMAPINFO *,UINT);
DWORD SetMapperFlags(HDC,DWORD);
int SetGraphicsMode(HDC,int);
int SetMapMode(HDC,int);
HMETAFILE SetMetaFileBitsEx(UINT,CONST BYTE *);
UINT SetPaletteEntries(HPALETTE,UINT,UINT,CONST PALETTEENTRY *);
COLORREF SetPixel(HDC,int,int,COLORREF);
BOOL SetPixelV(HDC,int,int,COLORREF);
int SetPolyFillMode(HDC,int);
BOOL StretchBlt(HDC,int,int,int,int,HDC,int,int,int,int,DWORD);
BOOL SetRectRgn(HRGN,int,int,int,int);
int StretchDIBits(HDC,int,int,int,int,int,int,int,int,CONST VOID *,CONST BITMAPINFO *,UINT,DWORD);
int SetROP2(HDC,int);
int SetStretchBltMode(HDC,int);
UINT SetSystemPaletteUse(HDC,UINT);
int SetTextCharacterExtra(HDC,int);
COLORREF SetTextColor(HDC,COLORREF);
UINT SetTextAlign(HDC,UINT);
BOOL SetTextJustification(HDC,int,int);
BOOL UpdateColors(HDC);
BOOL PlayMetaFileRecord(HDC,LPHANDLETABLE,LPMETARECORD,UINT);
BOOL EnumMetaFile(HDC,HMETAFILE,ENUMMETAFILEPROC,LPARAM);
HENHMETAFILE CloseEnhMetaFile(HDC);
BOOL DeleteEnhMetaFile(HENHMETAFILE);
BOOL EnumEnhMetaFile(HDC,HENHMETAFILE,ENHMETAFILEPROC,LPVOID,CONST RECT *);
UINT GetEnhMetaFileHeader(HENHMETAFILE,UINT,LPENHMETAHEADER );
UINT GetEnhMetaFilePaletteEntries(HENHMETAFILE,UINT,LPPALETTEENTRY );
UINT WINAPI GetEnhMetaFileBits(HENHMETAFILE,UINT,LPBYTE);
UINT GetWinMetaFileBits(HENHMETAFILE,UINT,LPBYTE,INT,HDC);
BOOL PlayEnhMetaFile(HDC,HENHMETAFILE,CONST RECT *);
BOOL PlayEnhMetaFileRecord(HDC,LPHANDLETABLE,CONST ENHMETARECORD *,UINT);
HENHMETAFILE SetEnhMetaFileBits(UINT,CONST BYTE *);
HENHMETAFILE SetWinMetaFileBits(UINT,CONST BYTE *,HDC,CONST METAFILEPICT *);
BOOL GdiComment(HDC,UINT,CONST BYTE *);
BOOL AngleArc(HDC,int,int,DWORD,FLOAT,FLOAT);
BOOL PolyPolyline(HDC,CONST POINT *,CONST DWORD *,DWORD);
BOOL GetWorldTransform(HDC,LPXFORM);
BOOL SetWorldTransform(HDC,CONST XFORM *);
BOOL ModifyWorldTransform(HDC,CONST XFORM *,DWORD);
BOOL CombineTransform(LPXFORM,CONST XFORM *,CONST XFORM *);
HBITMAP CreateDIBSection(HDC,CONST BITMAPINFO *,UINT,VOID **,HANDLE,DWORD);
UINT GetDIBColorTable(HDC,UINT,UINT,RGBQUAD *);
UINT SetDIBColorTable(HDC,UINT,UINT,CONST RGBQUAD *);
BOOL SetColorAdjustment(HDC,CONST COLORADJUSTMENT *);
BOOL GetColorAdjustment(HDC,LPCOLORADJUSTMENT);
HPALETTE CreateHalftonePalette(HDC);
BOOL WINAPI ReadDirectoryChangesW(HANDLE,LPVOID,DWORD,BOOL,DWORD,LPDWORD,LPOVERLAPPED,LPOVERLAPPED_COMPLETION_ROUTINE);
int EndDoc(HDC);
int StartPage(HDC);
int EndPage(HDC);
int AbortDoc(HDC);
int SetAbortProc(HDC,ABORTPROC);
BOOL AbortPath(HDC);
BOOL ArcTo(HDC,int,int,int,int,int,int,int,int);
BOOL BeginPath(HDC);
BOOL CloseFigure(HDC);
BOOL EndPath(HDC);
BOOL FillPath(HDC);
BOOL FlattenPath(HDC);
int GetPath(HDC,LPPOINT,LPBYTE,int);
HRGN PathToRegion(HDC);
BOOL PolyDraw(HDC,CONST POINT *,CONST BYTE *,int);
BOOL SelectClipPath(HDC,int);
int SetArcDirection(HDC,int);
BOOL SetMiterLimit(HDC,FLOAT,PFLOAT);
BOOL StrokeAndFillPath(HDC);
BOOL StrokePath(HDC);
BOOL WidenPath(HDC);
HPEN ExtCreatePen(DWORD,DWORD,CONST LOGBRUSH *,DWORD,CONST DWORD *);
BOOL GetMiterLimit(HDC,PFLOAT);
int GetArcDirection(HDC);
BOOL MoveToEx(HDC,int,int,LPPOINT);
HRGN CreatePolygonRgn(CONST POINT *,int,int);
BOOL DPtoLP(HDC,LPPOINT,int);
BOOL LPtoDP(HDC,LPPOINT,int);
BOOL Polygon(HDC,CONST POINT *,int);
BOOL Polyline(HDC,CONST POINT *,int);
BOOL PolyBezier(HDC,CONST POINT *,DWORD);
BOOL PolyBezierTo(HDC,CONST POINT *,DWORD);
BOOL PolylineTo(HDC,CONST POINT *,DWORD);
BOOL SetViewportExtEx(HDC,int,int,LPSIZE);
BOOL SetViewportOrgEx(HDC,int,int,LPPOINT);
BOOL SetWindowExtEx(HDC,int,int,LPSIZE);
BOOL SetWindowOrgEx(HDC,int,int,LPPOINT);
BOOL OffsetViewportOrgEx(HDC,int,int,LPPOINT);
BOOL OffsetWindowOrgEx(HDC,int,int,LPPOINT);
BOOL ScaleViewportExtEx(HDC,int,int,int,int,LPSIZE);
BOOL ScaleWindowExtEx(HDC,int,int,int,int,LPSIZE);
BOOL SetBitmapDimensionEx(HBITMAP,int,int,LPSIZE);
BOOL SetBrushOrgEx(HDC,int,int,LPPOINT);
BOOL GetDCOrgEx(HDC,LPPOINT);
BOOL FixBrushOrgEx(HDC,int,int,LPPOINT);
BOOL UnrealizeObject(HGDIOBJ);
BOOL GdiFlush(void);
DWORD GdiSetBatchLimit(DWORD);
DWORD GdiGetBatchLimit(void);
int SetICMMode(HDC,int);
BOOL CheckColorsInGamut(HDC,LPVOID,LPVOID,DWORD);
HANDLE GetColorSpace(HDC);
BOOL SetColorSpace(HDC,HCOLORSPACE);
BOOL DeleteColorSpace(HCOLORSPACE);
BOOL GetDeviceGammaRamp(HDC,LPVOID);
BOOL SetDeviceGammaRamp(HDC,LPVOID);
BOOL ColorMatchToTarget(HDC,HDC,DWORD);
HPROPSHEETPAGE CreatePropertySheetPageA(LPCPROPSHEETPAGE);
BOOL DestroyPropertySheetPage(HPROPSHEETPAGE);
void InitCommonControls(void);
typedef struct tagINITCOMMONCONTROLSEX { DWORD dwSize; DWORD dwICC; } INITCOMMONCONTROLSEX, *LPINITCOMMONCONTROLSEX;
#define ICC_LISTVIEW_CLASSES 1
#define ICC_TREEVIEW_CLASSES 2
#define ICC_BAR_CLASSES	4
#define ICC_TAB_CLASSES 8
#define ICC_UPDOWN_CLASS 0x10
#define ICC_PROGRESS_CLASS 0x20
#define ICC_HOTKEY_CLASS 0x40
#define ICC_ANIMATE_CLASS 0x80
#define ICC_WIN95_CLASSES 0xFF
#define ICC_DATE_CLASSES 0x100
#define ICC_USEREX_CLASSES 0x200
#define ICC_COOL_CLASSES 0x400
#define ICC_INTERNET_CLASSES 0x800
#define ICC_PAGESCROLLER_CLASS 0x1000
#define ICC_NATIVEFNTCTL_CLASS 0x2000
#define ICC_STANDARD_CLASSES 0x04000
#define ECM_FIRST 0x1500
#define BCM_FIRST 0x1600
#define BCM_GETIDEALSIZE  (BCM_FIRST + 1)
#define BCM_SETIMAGELIST  (BCM_FIRST + 2)
#define BCM_GETIMAGELIST  (BCM_FIRST + 3)
#define BCM_SETTEXTMARGIN (BCM_FIRST + 4)
#define BCM_GETTEXTMARGIN (BCM_FIRST + 5)
#define CBM_FIRST 0x1700
#define ICC_LINK_CLASS 0x08000
BOOL AlphaBlend(HDC,int,int,int,int,HDC,int,int,int,int,BLENDFUNCTION);
BOOL TransparentBlt(HDC,int,int,int,int,HDC,int,int,int,int,UINT);
#define AC_SRC_OVER 0
#define AC_SRC_ALPHA 1
#define GRADIENT_FILL_RECT_H	0
#define GRADIENT_FILL_RECT_V	1
#define GRADIENT_FILL_TRIANGLE	2
#define GRADIENT_FILL_OP_FLAG	0x0ff
BOOL GradientFill(HDC,PTRIVERTEX,ULONG,PVOID,ULONG,ULONG);
BOOL WINAPI InitCommonControlsEx(LPINITCOMMONCONTROLSEX);
#define ImageList_AddIcon(himl,hicon) ImageList_ReplaceIcon(himl,-1,hicon)
HIMAGELIST ImageList_Create(int,int,UINT,int,int);
BOOL ImageList_Destroy(HIMAGELIST);
int ImageList_GetImageCount(HIMAGELIST);
int ImageList_Add(HIMAGELIST,HBITMAP,HBITMAP);
int ImageList_ReplaceIcon(HIMAGELIST,int,HICON);
COLORREF ImageList_SetBkColor(HIMAGELIST,COLORREF);
COLORREF ImageList_GetBkColor(HIMAGELIST himl);
BOOL ImageList_SetOverlayImage(HIMAGELIST,int,int);
BOOL ImageList_Draw(HIMAGELIST,int,HDC,int,int,UINT);
BOOL ImageList_Replace(HIMAGELIST,int,HBITMAP,HBITMAP);
int ImageList_AddMasked(HIMAGELIST,HBITMAP,COLORREF);
BOOL ImageList_DrawEx(HIMAGELIST,int,HDC,int,int,int,int,COLORREF,COLORREF,UINT);
BOOL ImageList_Remove(HIMAGELIST,int);
HICON ImageList_GetIcon(HIMAGELIST,int,UINT);
BOOL ImageList_BeginDrag(HIMAGELIST,int,int,int);
void ImageList_EndDrag(VOID);
BOOL ImageList_DragEnter(HWND,int,int);
BOOL ImageList_DragLeave(HWND);
BOOL ImageList_DragMove(int,int);
BOOL ImageList_SetDragCursorImage(HIMAGELIST,int,int,int);
BOOL ImageList_DragShowNolock(BOOL);
HIMAGELIST ImageList_GetDragImage(POINT *,POINT *);
BOOL ImageList_GetIconSize(HIMAGELIST,int *,int *);
BOOL ImageList_SetIconSize(HIMAGELIST,int,int);
BOOL ImageList_GetImageInfo(HIMAGELIST,int,IMAGEINFO *);
HIMAGELIST ImageList_Merge(HIMAGELIST,int,HIMAGELIST,int,int,int);
BOOL WINAPI ImageList_SetImageCount(HIMAGELIST,UINT);
HWND CreateToolbarEx(HWND,DWORD,UINT,int,HINSTANCE,UINT,LPCTBBUTTON,int,int,int,int,int,UINT);
HBITMAP CreateMappedBitmap(HINSTANCE,int,UINT,LPCOLORMAP,int);
void MenuHelp(UINT,WPARAM,LPARAM,HMENU,HINSTANCE,HWND,UINT *);
BOOL ShowHideMenuCtl(HWND,UINT,LPINT);
void GetEffectiveClientRect(HWND,LPRECT,LPINT);
BOOL MakeDragList(HWND);
void DrawInsert(HWND,HWND,int);
int LBItemFromPt(HWND,POINT,BOOL);
HWND CreateUpDownControl(DWORD,int,int,int,int,HWND,int,HINSTANCE,HWND,int,int,int);
DWORD CommDlgExtendedError(VOID);
BOOL SetWaitableTimer(HANDLE,const LARGE_INTEGER *,LONG,PTIMERAPCROUTINE,LPVOID,BOOL);
BOOL CancelWaitableTimer(HANDLE);
HANDLE WINAPI CreateWaitableTimerA(LPSECURITY_ATTRIBUTES,BOOL,LPCSTR);
HANDLE WINAPI CreateWaitableTimerW(LPSECURITY_ATTRIBUTES,BOOL,LPCWSTR);
#define WSB_PROP_CYVSCROLL	1
#define WSB_PROP_CXHSCROLL	2
#define WSB_PROP_CYHSCROLL	4
#define WSB_PROP_CXVSCROLL	8
#define WSB_PROP_CXHTHUMB	0x10
#define WSB_PROP_CYVTHUMB	0x20
#define WSB_PROP_VBKGCOLOR	0x40
#define WSB_PROP_HBKGCOLOR	0x80
#define WSB_PROP_VSTYLE	0x100
#define WSB_PROP_HSTYLE	0x200
#define WSB_PROP_WINSTYLE	0x400
#define WSB_PROP_PALETTE	0x800
#define WSB_PROP_MASK	0xFFF
#define FSB_FLAT_MODE	2
#define FSB_ENCARTA_MODE	1
#define FSB_REGULAR_MODE	0
BOOL WINAPI FlatSB_EnableScrollBar(HWND,int,UINT);
BOOL WINAPI FlatSB_ShowScrollBar(HWND,int,BOOL);
BOOL WINAPI FlatSB_GetScrollRange(HWND,int,LPINT,LPINT);
BOOL WINAPI FlatSB_GetScrollInfo(HWND,int,LPSCROLLINFO);
int WINAPI FlatSB_GetScrollPos(HWND,int);
BOOL WINAPI FlatSB_GetScrollProp(HWND,int,LPINT);
#define FlatSB_GetScrollPropPtr FlatSB_GetScrollProp
int WINAPI FlatSB_SetScrollPos(HWND,int,int,BOOL);
int WINAPI FlatSB_SetScrollInfo(HWND,int,LPSCROLLINFO,BOOL);
int WINAPI FlatSB_SetScrollRange(HWND,int,int,int,BOOL);
BOOL WINAPI FlatSB_SetScrollProp(HWND,UINT,int,BOOL);
#define FlatSB_SetScrollPropPtr FlatSB_SetScrollProp
BOOL WINAPI InitializeFlatSB(HWND);
HRESULT WINAPI UninitializeFlatSB(HWND);
#define Button_GetTextMargin(h,p) (BOOL)SNDMSG((h),BCM_GETTEXTMARGIN,0,(LPARAM)(p))
#define Button_SetTextMargin(h, p) (BOOL)SNDMSG((h),BCM_SETTEXTMARGIN,0, (LPARAM)(p))
#define Button_GetImageList(h,p) (BOOL)SNDMSG((h),BCM_GETIMAGELIST,0,(LPARAM)(p))
#define Button_SetImageList(hwnd, pbuttonImagelist) (BOOL)SNDMSG((hwnd), BCM_SETIMAGELIST, 0, (LPARAM)(pbuttonImagelist))
#define Button_GetIdealSize(hwnd, psize) (BOOL)SNDMSG((hwnd), BCM_GETIDEALSIZE, 0, (LPARAM)(psize))
#define Edit_SetCueBannerText(hwnd, lpcwText) (BOOL)SNDMSG((hwnd), EM_SETCUEBANNER, 0, (LPARAM)(lpcwText))
#define Edit_GetCueBannerText(h,lpwText, cchText) (BOOL)SNDMSG((h),EM_GETCUEBANNER, (WPARAM)(lpwText), (LPARAM)(cchText))
#define Edit_ShowBalloonTip(hwnd, peditballoontip) (BOOL)SNDMSG((hwnd), EM_SHOWBALLOONTIP, 0, (LPARAM)(peditballoontip))
#define Edit_HideBalloonTip(hwnd) (BOOL)SNDMSG((hwnd), EM_HIDEBALLOONTIP, 0, 0)
#define DateTime_GetSystemtime(hdp, pst) (DWORD)SNDMSG(hdp, DTM_GETSYSTEMTIME, 0, (LPARAM)(pst))
#define DateTime_SetSystemtime(hdp, gd, pst) (BOOL)SNDMSG(hdp, DTM_SETSYSTEMTIME, (WPARAM)(gd), (LPARAM)(pst))
#define DateTime_GetRange(hdp, rgst) (DWORD)SNDMSG(hdp, DTM_GETRANGE, 0, (LPARAM)(rgst))
#define DateTime_SetRange(hdp, gd, rgst) (BOOL)SNDMSG(hdp, DTM_SETRANGE, (WPARAM)(gd), (LPARAM)(rgst))
#define Animate_Create(hP,id,S,I) CreateWindow(ANIMATE_CLASS,NULL,S,0,0,0,0,hP,(HMENU)(id),I,NULL)
#define Animate_Open(hw,Name) SendMessage(hw,ACM_OPEN,0,(LPARAM)(LPTSTR)(Name))
#define Animate_Play(h,f,t,r) SendMessage(h,ACM_PLAY,(WPARAM)(r),(LPARAM)MAKELONG(f,t))
#define Animate_Stop(hw) SendMessage(hw,ACM_STOP,0,0)
#define Animate_Close(h) Animate_Open(h,NULL)
#define Animate_Seek(h,f) Animate_Play(h,f,f,1)
#define PropSheet_AddPage(h,hp) SendMessage(h,PSM_ADDPAGE,0,(LPARAM)hp)
#define PropSheet_Apply(h) SendMessage(h,PSM_APPLY,0,0)
#define PropSheet_CancelToClose(h) SendMessage(h,PSM_CANCELTOCLOSE,0,0)
#define PropSheet_Changed(h,w) SendMessage(h,PSM_CHANGED,(WPARAM)w,0)
#define PropSheet_GetCurrentPageHwnd(h) SendMessage(h,PSM_GETCURRENTPAGEHWND,0,0)
#define PropSheet_GetTabControl(h) SendMessage(h,PSM_GETTABCONTROL,0,0)
#define PropSheet_IsDialogMessage(h,M) SendMessage(h,PSM_ISDIALOGMESSAGE,0,(LPARAM)M)
#define PropSheet_PressButton(h,B) SendMessage(h,PSM_PRESSBUTTON,(WPARAM)B,0)
#define PropSheet_QuerySiblings(h,p1,p2) SendMessage(h,PSM_QUERYSIBLINGS,(WPARAM)p1,(LPARAM)p2)
#define PropSheet_RebootSystem(h) SendMessage(h,PSM_REBOOTSYSTEM,0,0)
#define PropSheet_RemovePage(h,i,p) SendMessage(h,PSM_REMOVEPAGE,(WPARAM)(int)i,(LPARAM)p)
#define PropSheet_RestartWindows(h) SendMessage(h,PSM_RESTARTWINDOWS,0,0)
#define PropSheet_SetCurSel(hDlg,hpage,index) SendMessage(hDlg,PSM_SETCURSEL,(WPARAM)index,(LPARAM)hpage)
#define PropSheet_SetCurSelByID(hPropSheetDlg,id) SendMessage(hPropSheetDlg,PSM_SETCURSELID,0,(LPARAM)id)
#define PropSheet_SetFinishText(h,T) SendMessage(h,PSM_SETFINISHTEXT,0,(LPARAM)T)
#define PropSheet_SetTitle(h,S,T) SendMessage(h,PSM_SETTITLE,(WPARAM)S,(LPARAM)T)
#define PropSheet_SetWizButtons(h,F) SendMessage(h,PSM_SETWIZBUTTONS,0,(LPARAM)F)
#define PropSheet_UnChanged(hDlg,hP) SendMessage(hDlg,PSM_UNCHANGED,(WPARAM)(HWND)hP,0)
#define Header_DeleteItem(hHD,i) (BOOL)SendMessage((hHD),HDM_DELETEITEM,(WPARAM)(i),0)
#define Header_GetItem(hHD,i,p) (BOOL)SendMessage((hHD),HDM_GETITEM,(WPARAM)(i),(LPARAM)(p))
#define Header_GetUnicodeFormat(h) (BOOL)SendMessage(h,HDM_GETUNICODEFORMAT,0,0)
#define Header_SetUnicodeFormat(h,f) (BOOL)SendMessage(h,HDM_SETUNICODEFORMAT,f,0)
#define Header_GetItemCount(hHD) (int)SendMessage((hHD),HDM_GETITEMCOUNT,0,0)
#define Header_InsertItem(hHD,i,phdi) (int)SendMessage((hHD),HDM_INSERTITEM,(WPARAM)(i),(LPARAM)(phdi))
#define Header_Layout(hHD,p) (BOOL)SendMessage((hHD),HDM_LAYOUT,0,(LPARAM)(p))
#define Header_SetItem(hHD,i,p) (BOOL)SendMessage((hHD),HDM_SETITEM,(WPARAM)(i),(LPARAM)(p))
#define ListView_MapIDToIndex(hwnd, id) (UINT)SNDMSG((hwnd), LVM_MAPIDTOINDEX, (WPARAM)id, (LPARAM)0)
#define ListView_MapIndexToID(hwnd, index) (UINT)SNDMSG((hwnd), LVM_MAPINDEXTOID, (WPARAM)index, (LPARAM)0)
#define ListView_CancelEditLabel(hwnd) (VOID)SNDMSG((hwnd), LVM_CANCELEDITLABEL, (WPARAM)0, (LPARAM)0)
#define ListView_SetOutlineColor(hwnd, color) (COLORREF)SNDMSG((hwnd), LVM_SETOUTLINECOLOR, (WPARAM)0, (LPARAM)(COLORREF)(color))
#define ListView_GetOutlineColor(hwnd) (COLORREF)SNDMSG((hwnd), LVM_GETOUTLINECOLOR, 0, 0)
#define ListView_IsGroupViewEnabled(h) (BOOL)SNDMSG((h), LVM_ISGROUPVIEWENABLED, 0, 0)
#define ListView_GetSelectedColumn(hwnd) (UINT)SNDMSG((hwnd), LVM_GETSELECTEDCOLUMN, 0, 0)
#define ListView_SetInfoTip(hwndLV, plvInfoTip) (BOOL)SNDMSG((hwndLV), LVM_SETINFOTIP, (WPARAM)0, (LPARAM)plvInfoTip)
#define ListView_GetInsertMarkColor(h) (COLORREF)SNDMSG((h),LVM_GETINSERTMARKCOLOR,(WPARAM)0, (LPARAM)0)
#define ListView_SetInsertMarkColor(hwnd, color) (COLORREF)SNDMSG((hwnd), LVM_SETINSERTMARKCOLOR, (WPARAM)0, (LPARAM)(COLORREF)(color))
#define ListView_GetInsertMarkRect(h,rc) (int)SNDMSG((h),LVM_GETINSERTMARKRECT,(WPARAM)0,(LPARAM)(LPRECT)(rc))
#define ListView_InsertMarkHitTest(h,p,lvim) (int)SNDMSG((h),LVM_INSERTMARKHITTEST,(WPARAM)(LPPOINT)(p),(LPARAM)(LPLVINSERTMARK)(lvim))
#define ListView_GetInsertMark(hwnd, lvim) (BOOL)SNDMSG((hwnd), LVM_GETINSERTMARK, (WPARAM) 0, (LPARAM) (lvim))
#define ListView_SetInsertMark(hwnd, lvim) (BOOL)SNDMSG((hwnd), LVM_SETINSERTMARK, (WPARAM) 0, (LPARAM) (lvim))
#define ListView_GetTileInfo(hwnd, pti) SNDMSG((hwnd), LVM_GETTILEINFO, 0, (LPARAM)pti)
#define ListView_SetTileInfo(hwnd, pti) SNDMSG((hwnd), LVM_SETTILEINFO, 0, (LPARAM)pti)
#define ListView_GetTileViewInfo(hwnd, ptvi) SNDMSG((hwnd), LVM_GETTILEVIEWINFO, 0, (LPARAM)ptvi)
#define ListView_SetTileViewInfo(hwnd, ptvi) SNDMSG((hwnd), LVM_SETTILEVIEWINFO, 0, (LPARAM)ptvi)
#define ListView_HasGroup(hwnd, dwGroupId) SNDMSG((hwnd), LVM_HASGROUP, dwGroupId, 0)
#define ListView_RemoveAllGroups(hwnd) SNDMSG((hwnd), LVM_REMOVEALLGROUPS, 0, 0)
#define ListView_InsertGroupSorted(hwnd, structInsert) SNDMSG((hwnd), LVM_INSERTGROUPSORTED, (WPARAM)structInsert, 0)
#define ListView_SortGroups(hwnd, _pfnGroupCompate, _plv) SNDMSG((hwnd), LVM_SORTGROUPS, (WPARAM)_pfnGroupCompate, (LPARAM)_plv)
#define ListView_EnableGroupView(hwnd, fEnable) SNDMSG((hwnd), LVM_ENABLEGROUPVIEW, (WPARAM)fEnable, 0)
#define ListView_GetGroupMetrics(hwnd, pGroupMetrics) SNDMSG((hwnd), LVM_GETGROUPMETRICS, 0, (LPARAM)pGroupMetrics)
#define ListView_SetGroupMetrics(hwnd, pGroupMetrics) SNDMSG((hwnd),LVM_SETGROUPMETRICS, 0, (LPARAM)pGroupMetrics)
#define ListView_MoveItemToGroup(hwnd, idItemFrom, idGroupTo) SNDMSG((hwnd), LVM_MOVEITEMTOGROUP, (WPARAM)idItemFrom, (LPARAM)idGroupTo)
#define ListView_MoveGroup(hwnd, iGroupId, toIndex) SNDMSG((hwnd), LVM_MOVEGROUP, (WPARAM)iGroupId, (LPARAM)toIndex)
#define ListView_RemoveGroup(hwnd, iGroupId) SNDMSG((hwnd), LVM_REMOVEGROUP, (WPARAM)iGroupId, 0)
#define ListView_GetGroupInfo(hwnd, iGroupId, pgrp) SNDMSG((hwnd),LVM_GETGROUPINFO, (WPARAM)iGroupId, (LPARAM)pgrp)
#define ListView_SetGroupInfo(hwnd, iGroupId, pgrp) SNDMSG((hwnd), LVM_SETGROUPINFO, (WPARAM)iGroupId, (LPARAM)pgrp)
#define ListView_InsertGroup(hwnd, index, pgrp) SNDMSG((hwnd), LVM_INSERTGROUP, (WPARAM)index, (LPARAM)pgrp)
#define ListView_SetTileWidth(h,cpWidth) SNDMSG((h), LVM_SETTILEWIDTH,(WPARAM)cpWidth,0)
#define ListView_SetSelectedColumn(h,iCol) SNDMSG((h), LVM_SETSELECTEDCOLUMN, (WPARAM)iCol, 0)
#define ListView_ApproximateViewRect(h,W,H,C) (DWORD)SNDMSG((h),LVM_APPROXIMATEVIEWRECT,C,MAKELPARAM(W,H))
#define ListView_SetView(hwnd, iView) (DWORD)SNDMSG((hwnd), LVM_SETVIEW, (WPARAM)(DWORD)iView, 0)
#define ListView_GetColumnOrderArray(h,iCount, pi) (BOOL)SendMessage((h),LVM_GETCOLUMNORDERARRAY,(WPARAM)(iCount),(LPARAM)(LPINT)(pi))
#define ListView_GetExtendedListViewStyle(h) (DWORD)SendMessage((h),LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0)
#define ListView_GetHeader(hwnd) (HWND)SendMessage((hwnd), LVM_GETHEADER, 0, 0L)
#define ListView_GetHotCursor(hwnd) (HCURSOR)SendMessage((hwnd), LVM_GETHOTCURSOR, 0, 0)
#define ListView_GetHotItem(hwnd) (int)SendMessage((hwnd), LVM_GETHOTITEM, 0, 0)
#define ListView_SetColumnOrderArray(hwnd, iCount, pi) (BOOL)SendMessage((hwnd), LVM_SETCOLUMNORDERARRAY, (WPARAM)(iCount), (LPARAM)(LPINT)(pi))
#define ListView_SetExtendedListViewStyle(h,dw) (DWORD)SNDMSG((h),LVM_SETEXTENDEDLISTVIEWSTYLE,0,dw)
#define ListView_SetExtendedListViewStyleEx(h,M,dw) (DWORD)SNDMSG(h,LVM_SETEXTENDEDLISTVIEWSTYLE,M,dw)
#define ListView_SetHotItem(hwnd, i) (int)SendMessage((hwnd),LVM_SETHOTITEM, (WPARAM)(i),0)
#define ListView_SetHotCursor(hwnd, hcur) (HCURSOR)SendMessage((hwnd), LVM_SETHOTCURSOR, 0, (LPARAM)(hcur))
#define ListView_SetIconSpacing(hwndLV, cx, cy) (DWORD)SendMessage((hwndLV), LVM_SETICONSPACING,0, MAKELONG(cx,cy))
#define ListView_SetWorkAreas(h,WA,prc) (BOOL)SNDMSG((h),LVM_SETWORKAREAS,(WPARAM)(int)(WA),(LPARAM)(RECT *)(prc))
#define ListView_SetCheckState(h,i,f) ListView_SetItemState(h,i,INDEXTOSTATEIMAGEMASK((f)?2:1),LVIS_STATEIMAGEMASK)
#define ListView_GetCheckState(h,i) ((((UINT)(SNDMSG((h),LVM_GETITEMSTATE,(WPARAM)(i),LVIS_STATEIMAGEMASK))) >> 12) -1)
#define ListView_GetWorkAreas(hwnd, nWorkAreas, prc) (BOOL)SNDMSG((hwnd),LVM_GETWORKAREAS,(WPARAM)(int)(nWorkAreas),(LPARAM)(RECT *)(prc))
#define ListView_GetNumberOfWorkAreas(hwnd, pnWorkAreas) (BOOL)SNDMSG((hwnd),LVM_GETNUMBEROFWORKAREAS,0,(LPARAM)(UINT *)(pnWorkAreas))
#define ListView_GetSelectionMark(hwnd) (int)SNDMSG((hwnd),LVM_GETSELECTIONMARK,0,0)
#define ListView_SetSelectionMark(hwnd, i) (int)SNDMSG((hwnd),LVM_SETSELECTIONMARK,0,(LPARAM)(i))
#define ListView_GetSubItemRect(h,i,SI,code,prc) (BOOL)SNDMSG((h),LVM_GETSUBITEMRECT,(WPARAM)(int)(i), ((prc) ? ((((LPRECT)(prc))->top=SI),(((LPRECT)(prc))->left = code), (LPARAM)(prc)) : (LPARAM)(LPRECT)NULL))
#define ListView_SubItemHitTest(h,p) (int)SNDMSG((h),LVM_SUBITEMHITTEST,0,(LPARAM)(LPLVHITTESTINFO)(p))
#define ListView_SetHoverTime(hwndLV, dwHoverTimeMs) (DWORD)SNDMSG((hwndLV),LVM_SETHOVERTIME,0,(LPARAM)(dwHoverTimeMs))
#define ListView_GetHoverTime(hwndLV) (DWORD)SNDMSG((hwndLV),LVM_GETHOVERTIME,0,0)
#define ListView_SetToolTips(hwndLV, hwndNewHwnd) (HWND)SNDMSG((hwndLV),LVM_SETTOOLTIPS,(WPARAM)(hwndNewHwnd),0)
#define ListView_GetToolTips(hwndLV) (HWND)SNDMSG((hwndLV),LVM_GETTOOLTIPS,0,0)
#define ListView_SortItemsEx(hwndLV, _pfnCompare, _lPrm) (BOOL)SNDMSG((hwndLV),LVM_SORTITEMSEX,(WPARAM)(LPARAM)(_lPrm),(LPARAM)(PFNLVCOMPARE)(_pfnCompare))
#define ListView_SetBkImage(hwnd, plvbki) (BOOL)SNDMSG((hwnd),LVM_SETBKIMAGE,0,(LPARAM)(plvbki))
#define ListView_GetBkImage(hwnd, plvbki) (BOOL)SNDMSG((hwnd),LVM_GETBKIMAGE,0,(LPARAM)(plvbki))
#define ListView_Arrange(hLV,c) SendMessage((hLV),LVM_ARRANGE,(WPARAM)(c),0)
#define ListView_CreateDragImage(h,i,l) SendMessage((h),LVM_CREATEDRAGIMAGE,(WPARAM)(i),(LPARAM)(l))
#define ListView_DeleteAllItems(h) SendMessage(h,LVM_DELETEALLITEMS,0,0)
#define ListView_DeleteColumn(h,iCol) SendMessage((h),LVM_DELETECOLUMN,(WPARAM)(iCol),0)
#define ListView_DeleteItem(h,iItem) SendMessage(h,LVM_DELETEITEM,(WPARAM)iItem,0)
#define ListView_EditLabel(hLV,i) (HWND)SendMessage((hLV),LVM_EDITLABEL,(WPARAM)i,0)
#define ListView_EnsureVisible(hLV,i,fOK) SendMessage(hLV,LVM_ENSUREVISIBLE,(WPARAM)i,MAKELPARAM((fOK),0))
#define ListView_FindItem(hwnd,i,p) SendMessage(hwnd,LVM_FINDITEM,(WPARAM)i,(LPARAM)p)
#define ListView_GetBkColor(hwnd) SendMessage((HWND)hwnd,LVM_GETBKCOLOR,0,0)
#define ListView_GetCallbackMask(h) SendMessage(h,LVM_GETCALLBACKMASK,0,0)
#define ListView_GetColumn(hwnd,iCol,pcol) SendMessage((hwnd),LVM_GETCOLUMN,(WPARAM)(iCol),(LPARAM)(pcol))
#define ListView_GetColumnWidth(h,iCol) SendMessage((h),LVM_GETCOLUMNWIDTH,(WPARAM)(iCol),0)
#define ListView_GetCountPerPage(h) SendMessage((h),LVM_GETCOUNTPERPAGE,0,0)
#define ListView_GetEditControl(h) (HWND)SendMessage((h),LVM_GETEDITCONTROL,0,0)
#define ListView_GetImageList(h,iIL) SendMessage(h,LVM_GETIMAGELIST,(WPARAM)iIL,0)
#define ListView_GetISearchString(h,l) SendMessage((h),LVM_GETISEARCHSTRING,0,(LPARAM)l)
#define ListView_GetItem(h,p) SendMessage(h,LVM_GETITEM,0,(LPARAM)(p))
#define ListView_GetItemCount(h) SendMessage(h,LVM_GETITEMCOUNT,0,0)
#define ListView_GetItemPosition(h,i,ppt) SendMessage(h,LVM_GETITEMPOSITION,(WPARAM)(int)i,(LPARAM)ppt)
#define ListView_GetItemRect(h,i,p,c) SendMessage(h,LVM_GETITEMRECT,(WPARAM)i,((p) ? (((RECT *)(p))->left=(c),(LPARAM)(p)):(LPARAM)NULL))
#define ListView_GetItemSpacing(hLV,f) SendMessage((hLV),LVM_GETITEMSPACING,f,0)
#define ListView_GetItemState(hLV,i,m) SendMessage((hLV),LVM_GETITEMSTATE,(WPARAM)i,(LPARAM)m)
#define ListView_GetItemText(hLV,i,iS,T,c) {LV_ITEM _gnu_l;_gnu_l.iSubItem=iS;_gnu_l.cchTextMax=c;_gnu_l.pszText=(TCHAR *)T;SendMessage((hLV),LVM_GETITEMTEXT,(WPARAM)i,(LPARAM)&_gnu_l);}
#define ListView_GetNextItem(h,S,f) SendMessage(h,LVM_GETNEXTITEM,(WPARAM)S,(LPARAM)f)
#define ListView_GetOrigin(hLV,ppt) SendMessage((hLV),LVM_GETORIGIN,(WPARAM)0,(LPARAM)(ppt))
#define ListView_GetSelectedCount(h) SendMessage((h),LVM_GETSELECTEDCOUNT,0,0)
#define ListView_GetStringWidth(h,psz) SendMessage(h,LVM_GETSTRINGWIDTH,0,(LPARAM)psz)
#define ListView_GetTextBkColor(h) SendMessage((h),LVM_GETTEXTBKCOLOR,0,0)
#define ListView_GetTextColor(h) SendMessage((h),LVM_GETTEXTCOLOR,0,0)
#define ListView_GetTopIndex(h) SendMessage((h),LVM_GETTOPINDEX,0,0)
#define ListView_GetViewRect(h,prc) SendMessage((h),LVM_GETVIEWRECT,0,(LPARAM)(prc))
#define ListView_HitTest(hLV,pinfo) SendMessage(hLV,LVM_HITTEST,0,(LPARAM)pinfo)
#define ListView_InsertColumn(hwnd,iCol,pcol) SendMessage((hwnd),LVM_INSERTCOLUMN,(WPARAM)(int)(iCol),(LPARAM)(pcol))
#define ListView_InsertItem(hwnd,pitem) SendMessage(hwnd,LVM_INSERTITEM,0,(LPARAM)pitem)
#define ListView_RedrawItems(hLV,iFirst,iLast) SendMessage((hLV),LVM_REDRAWITEMS,(WPARAM)iFirst,(LPARAM)iLast)
#define ListView_Scroll(hLV,dx,dy) SendMessage((hLV),LVM_SCROLL,(WPARAM)dx,(LPARAM)dy)
#define ListView_SetBkColor(h,clrBk) SendMessage(h,LVM_SETBKCOLOR,0,(LPARAM)(COLORREF)clrBk)
#define ListView_SetCallbackMask(h,m) SendMessage(h,LVM_SETCALLBACKMASK,(WPARAM)(UINT)(m),0)
#define ListView_SetColumn(h,iCol,pcol) SendMessage((h),LVM_SETCOLUMN,(WPARAM)(iCol),(LPARAM)(pcol))
#define ListView_SetColumnWidth(hwnd,iCol,cx) SendMessage((hwnd),LVM_SETCOLUMNWIDTH,(WPARAM)(int)(iCol),MAKELPARAM((cx),0))
#define ListView_SetImageList(hwnd,himl,iImageList) (HIMAGELIST)SendMessage(hwnd,LVM_SETIMAGELIST,(WPARAM)(iImageList),(LPARAM)(HIMAGELIST)(himl))
#define ListView_SetItem(hwnd,pitem) SendMessage(hwnd,LVM_SETITEM,0,(LPARAM)pitem)
#define ListView_SetItemCount(hLV,cItems) SendMessage((hLV),LVM_SETITEMCOUNT,(WPARAM)cItems,0)
#define ListView_SetItemPosition(hLV,i,x,y) SendMessage(hLV,LVM_SETITEMPOSITION,(WPARAM)(int)(i),MAKELPARAM((x),(y)))
#define ListView_SetItemPosition32(hLV,i,x,y) {POINT ptNewPos={x,y};SendMessage((hLV),LVM_SETITEMPOSITION32,(WPARAM)(i),(LPARAM)&ptNewPos);}
#define ListView_SetItemState(hLV,i,d,m) {LV_ITEM _gnu_l;_gnu_l.stateMask=m;_gnu_l.state=d;SendMessage((hLV),LVM_SETITEMSTATE,(WPARAM)(i),(LPARAM)&_gnu_l);}
#define ListView_SetItemText(hLV,i,iS,T) {LV_ITEM _gnu_l;_gnu_l.iSubItem=iS;_gnu_l.pszText=T;SendMessage((hLV),LVM_SETITEMTEXT,(WPARAM)(i),(LPARAM)&_gnu_l);}
#define ListView_SetTextBkColor(h,c) SendMessage((h),LVM_SETTEXTBKCOLOR,0,(LPARAM)(c))
#define ListView_SetTextColor(h,c) SendMessage((h),LVM_SETTEXTCOLOR,0,(LPARAM)(c))
#define ListView_SortItems(hLV,p,l) SendMessage((hLV),LVM_SORTITEMS,(WPARAM)l,(LPARAM)p)
#define ListView_Update(hLV,i) SendMessage((hLV),LVM_UPDATE,(WPARAM)i,0)
#define ListView_GetUnicodeFormat(h) (BOOL)SendMessage((h),LVM_GETUNICODEFORMAT,0,0)
#define ListView_SetUnicodeFormat(h,f) (BOOL)SendMessage((h),LVM_SETUNICODEFORMAT,(WPARAM)f,0)
#define TreeView_GetScrollTime(h) (UINT)SendMessage(h,TVM_GETSCROLLTIME,0,0)
#define TreeView_SetItemHeight(h,iHeight) (int)SendMessage((h), TVM_SETITEMHEIGHT,(WPARAM)(iHeight), 0)
#define TreeView_GetItemHeight(h) (int)SendMessage((h),TVM_GETITEMHEIGHT, 0, 0)
#define TreeView_SetItemState(h,hti,d,m) {TVITEM TVi;TVi.mask=TVIF_STATE;TVi.hItem = hti;TVi.stateMask=m;TVi.state=d;SNDMSG((h),TVM_SETITEM,0,(LPARAM)(TV_ITEM *)&TVi);}
#define TreeView_SetBkColor(h,clr) (COLORREF)SendMessage((h),TVM_SETBKCOLOR, 0, (LPARAM)(clr))
#define TreeView_SetTextColor(hwnd, clr) (COLORREF)SendMessage((hwnd), TVM_SETTEXTCOLOR, 0, (LPARAM)(clr))
#define TreeView_GetBkColor(hwnd) (COLORREF)SendMessage((hwnd), TVM_GETBKCOLOR, 0, 0)
#define TreeView_GetTextColor(hwnd) (COLORREF)SendMessage((hwnd),TVM_GETTEXTCOLOR, 0, 0)
#define TreeView_SetScrollTime(hwnd, uTime) (UINT)SendMessage((hwnd), TVM_SETSCROLLTIME, uTime, 0)
#define TreeView_SetInsertMarkColor(hwnd, clr) (COLORREF)SendMessage((hwnd),TVM_SETINSERTMARKCOLOR, 0, (LPARAM)(clr))
#define TreeView_GetInsertMarkColor(hwnd) (COLORREF)SendMessage((hwnd), TVM_GETINSERTMARKCOLOR, 0, 0)
#define TreeView_InsertItem(h,l) (HTREEITEM)SendMessage((h),TVM_INSERTITEM,0,(LPARAM)(l))
#define TreeView_DeleteItem(h,i) (HTREEITEM)SendMessage((h),TVM_DELETEITEM,0,(LPARAM)(i))
#define TreeView_DeleteAllItems(h) SendMessage((h),TVM_DELETEITEM,0,(LPARAM)TVI_ROOT)
#define TreeView_Expand(h,i,c) SendMessage((h),TVM_EXPAND,(WPARAM)c,(LPARAM)(i))
#define TreeView_GetLineColor(h) (COLORREF)SendMessage(h,TVM_GETLINECOLOR,0,0)
#define TreeView_SetLineColor(h,c) (COLORREF)SendMessage(h,TVM_SETLINECOLOR,0,(LPARAM)c)
#define TreeView_GetCheckState(h,i) ((((UINT)(SendMessage(h,TVM_GETITEMSTATE,(WPARAM)i,TVIS_STATEIMAGEMASK))) >> 12) -1)
#define TreeView_GetItemState(h,i,m) (UINT)SendMessage(h,TVM_GETITEMSTATE,(WPARAM)i,(LPARAM)m)
#define TreeView_SetCheckState(h,i,C) TreeView_SetItemState(h,i,INDEXTOSTATEIMAGEMASK((C)?2:1),TVIS_STATEIMAGEMASK)
#define TreeView_GetItemRect(h,hitem,prc,c) (*(HTREEITEM *)prc=(hitem),(BOOL)SendMessage((h),TVM_GETITEMRECT,(WPARAM)(c),(LPARAM)(RECT *)(prc)))
#define TreeView_GetCount(h) SendMessage((h),TVM_GETCOUNT,0,0)
#define TreeView_GetIndent(h) SendMessage((h),TVM_GETINDENT,0,0)
#define TreeView_SetIndent(h,i) SendMessage((h),TVM_SETINDENT,(WPARAM)i,0)
#define TreeView_GetImageList(h,i) SendMessage((h),TVM_GETIMAGELIST,i,0)
#define TreeView_SetImageList(h,hi,i) SendMessage((h),TVM_SETIMAGELIST,i,(LPARAM)(hi))
#define TreeView_GetNextItem(h,hi,c) (HTREEITEM)SendMessage((h),TVM_GETNEXTITEM,(WPARAM)c,(LPARAM)(hi))
#define TreeView_GetChild(h,i) TreeView_GetNextItem(h,i,TVGN_CHILD)
#define TreeView_GetNextSibling(h,i) TreeView_GetNextItem(h,i,TVGN_NEXT)
#define TreeView_GetPrevSibling(h,i) TreeView_GetNextItem(h,i,TVGN_PREVIOUS)
#define TreeView_GetParent(h,i) TreeView_GetNextItem(h,i,TVGN_PARENT)
#define TreeView_GetFirstVisible(h) TreeView_GetNextItem(h,NULL,TVGN_FIRSTVISIBLE)
#define TreeView_GetNextVisible(h,i) TreeView_GetNextItem(h,i,TVGN_NEXTVISIBLE)
#define TreeView_GetPrevVisible(h,i) TreeView_GetNextItem(h,i,TVGN_PREVIOUSVISIBLE)
#define TreeView_GetSelection(h) TreeView_GetNextItem(h,NULL,TVGN_CARET)
#define TreeView_GetDropHilight(h) TreeView_GetNextItem(h,NULL,TVGN_DROPHILITE)
#define TreeView_GetRoot(h) (HTREEITEM)TreeView_GetNextItem(h,NULL,TVGN_ROOT)
#define TreeView_Select(h,i,c) SendMessage((h),TVM_SELECTITEM,(WPARAM)c,(LPARAM)(i))
#define TreeView_SelectItem(h,i) TreeView_Select(h,i,TVGN_CARET)
#define TreeView_SelectDropTarget(h,i) TreeView_Select(h,i,TVGN_DROPHILITE)
#define TreeView_SelectSetFirstVisible(h,p) TreeView_Select(h,p,TVGN_FIRSTVISIBLE)
#define TreeView_GetItem(h,p) SendMessage((h),TVM_GETITEM,0,(LPARAM)(TV_ITEM *)(p))
#define TreeView_SetItem(h,p) (int)SendMessage((h),TVM_SETITEM,0,(LPARAM)(TV_ITEM *)(p))
#define TreeView_EditLabel(h,i) (HWND)SendMessage((h),TVM_EDITLABEL,0,(LPARAM)(HTREEITEM)(i))
#define TreeView_GetEditControl(h) (HWND)SendMessage((h),TVM_GETEDITCONTROL,0,0)
#define TreeView_GetVisibleCount(h) (unsigned int)SendMessage((h),TVM_GETVISIBLECOUNT,0,0)
#define TreeView_HitTest(h,l) (HTREEITEM)SendMessage((h),TVM_HITTEST,0,(LPARAM)(LPTV_HITTESTINFO)(l))
#define TreeView_CreateDragImage(hwnd,hitem) (HIMAGELIST)SendMessage((hwnd),TVM_CREATEDRAGIMAGE,0,(LPARAM)(hitem))
#define TreeView_SortChildren(h,i,r) (BOOL)SendMessage((h),TVM_SORTCHILDREN,(WPARAM)r,(LPARAM)(i))
#define TreeView_EnsureVisible(h,i) (BOOL)SendMessage((h),TVM_ENSUREVISIBLE,0,(LPARAM)(i))
#define TreeView_SortChildrenCB(h,p,r) SendMessage((h),TVM_SORTCHILDRENCB,(WPARAM)r,(LPARAM)(p))
#define TreeView_EndEditLabelNow(h,f) SendMessage((h),TVM_ENDEDITLABELNOW,(WPARAM)f,0)
#define TreeView_GetISearchString(h,lpsz) SendMessage((h),TVM_GETISEARCHSTRING,0,(LPARAM)(LPTSTR)lpsz)
#define TabCtrl_GetImageList(h) SendMessage((h),TCM_GETIMAGELIST,0,0)
#define TabCtrl_SetImageList(hwnd,himl) SendMessage((hwnd),TCM_SETIMAGELIST,0,(LPARAM)(himl))
#define TabCtrl_GetItemCount(hwnd) SendMessage((hwnd),TCM_GETITEMCOUNT,0,0)
#define TabCtrl_GetItem(h,i,p) SendMessage(h,TCM_GETITEM,(WPARAM)i,(LPARAM)(TC_ITEM *)(p))
#define TabCtrl_SetItem(h,i,p) SendMessage((h),TCM_SETITEM,(WPARAM)i,(LPARAM)(TC_ITEM *)(p))
#define TabCtrl_InsertItem(h,i,p) SendMessage((h),TCM_INSERTITEM,(WPARAM)i,(LPARAM)(TC_ITEM *)(p))
#define TabCtrl_DeleteItem(hwnd,i) SendMessage((hwnd),TCM_DELETEITEM,(WPARAM)(int)(i),0)
#define TabCtrl_DeleteAllItems(h) SendMessage((h),TCM_DELETEALLITEMS,0,0)
#define TabCtrl_GetItemRect(h,i,prc) SendMessage((h),TCM_GETITEMRECT,(WPARAM)(i),(LPARAM)(prc))
#define TabCtrl_GetCurSel(h) SendMessage((h),TCM_GETCURSEL,0,0)
#define TabCtrl_SetCurSel(h,i) SendMessage((h),TCM_SETCURSEL,(WPARAM)i,0)
#define TabCtrl_HitTest(h,p) SendMessage((h),TCM_HITTEST,0,(LPARAM)(TC_HITTESTINFO *)(p))
#define TabCtrl_SetItemExtra(h,cb) SendMessage((h),TCM_SETITEMEXTRA,(WPARAM)(cb),0)
#define TabCtrl_AdjustRect(h,L,prc) SendMessage(h,TCM_ADJUSTRECT,(WPARAM)L,(LPARAM)(RECT *)prc)
#define TabCtrl_SetItemSize(h,x,y) SendMessage((h),TCM_SETITEMSIZE,0,MAKELPARAM(x,y))
#define TabCtrl_RemoveImage(h,i) SendMessage((h),TCM_REMOVEIMAGE,i,0)
#define TabCtrl_SetPadding(h,cx,cy) SendMessage((h),TCM_SETPADDING,0,MAKELPARAM(cx,cy))
#define TabCtrl_GetRowCount(h) SendMessage((h),TCM_GETROWCOUNT,0,0)
#define TabCtrl_GetToolTips(h) SendMessage((h),TCM_GETTOOLTIPS,0,0)
#define TabCtrl_SetToolTips(h,T) SendMessage((h),TCM_SETTOOLTIPS,(WPARAM)T,0)
#define TabCtrl_GetCurFocus(hwnd) SendMessage((hwnd),TCM_GETCURFOCUS,0,0)
#define TabCtrl_SetCurFocus(hwnd,i) SendMessage((hwnd),TCM_SETCURFOCUS,i,0)
#define TabCtrl_SetMinTabWidth(h,x) (int)SNDMSG((h),TCM_SETMINTABWIDTH,0,x)
#define TabCtrl_DeselectAll(h,E) (void)SNDMSG((h), TCM_DESELECTALL,E,0)
#define TabCtrl_SetExtendedStyle(h,d) (DWORD)SNDMSG((h),TCM_SETEXTENDEDSTYLE,0,d)
#define TabCtrl_GetExtendedStyle(h) (DWORD)SNDMSG((h),TCM_GETEXTENDEDSTYLE,0,0)
#define TabCtrl_SetUnicodeFormat(h,U) (BOOL)SNDMSG((h),TCM_SETUNICODEFORMAT,(WPARAM)(U),0)
#define TabCtrl_GetUnicodeFormat(h) (BOOL)SNDMSG((h),TCM_GETUNICODEFORMAT,0,0)
#define CommDlg_OpenSave_GetSpecA(h,p,c) SendMessage(h,CDM_GETSPEC,(WPARAM)c,(LPARAM)p)
#define CommDlg_OpenSave_GetSpecW(h,_psz,c) SendMessage(h,CDM_GETSPEC,(WPARAM)c,(LPARAM)_psz)
#define CommDlg_OpenSave_GetFilePathA(_hdlg,_psz,c) SendMessage(_hdlg,CDM_GETFILEPATH,(WPARAM)c,(LPARAM)(LPSTR)_psz)
#define CommDlg_OpenSave_GetFilePathW(h,p,c) SendMessage(h,CDM_GETFILEPATH,(WPARAM)c,(LPARAM)(LPWSTR)p)
#define CommDlg_OpenSave_GetFolderPathA(h,_psz,c) SendMessage(h,CDM_GETFOLDERPATH,(WPARAM)c,(LPARAM)(LPSTR)_psz)
#define CommDlg_OpenSave_GetFolderPathW(h,p,c) SendMessage(h,CDM_GETFOLDERPATH,(WPARAM)c,(LPARAM)(LPWSTR)p)
#define CommDlg_OpenSave_GetFolderIDList(g,p,c) SendMessage(g,CDM_GETFOLDERIDLIST,(WPARAM)c,(LPARAM)(LPVOID)p)
#define CommDlg_OpenSave_SetControlText(h,id,t) SendMessage(h,CDM_SETCONTROLTEXT,(WPARAM)id,(LPARAM)t)
#define CommDlg_OpenSave_HideControl(_hdlg,_id) SendMessage(_hdlg,CDM_HIDECONTROL,(WPARAM)_id,0)
#define CommDlg_OpenSave_SetDefExt(h,psz) SendMessage(h,CDM_SETDEFEXT,0,(LPARAM)psz)
#define GetCurrentFiber() (((PNT_TIB)NtCurrentTeb())->FiberData)
#define GetFiberData() (*(PVOID *)(GetCurrentFiber()))
LONG RegCloseKey (HKEY);
LONG RegSetKeySecurity(HKEY,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR);
LONG RegFlushKey(HKEY);
LONG RegGetKeySecurity(HKEY,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR,LPDWORD);
LONG RegNotifyChangeKeyValue(HKEY,BOOL,DWORD,HANDLE,BOOL);
BOOL IsValidCodePage(UINT);
UINT GetACP(void);
UINT GetOEMCP(void);
BOOL GetCPInfo(UINT,LPCPINFO);
BOOL IsDBCSLeadByte(BYTE);
BOOL IsDBCSLeadByteEx(UINT,BYTE);
int MultiByteToWideChar(UINT,DWORD,LPCSTR,int,LPWSTR,int);
int WideCharToMultiByte(UINT,DWORD,LPCWSTR,int,LPSTR,int,LPCSTR,LPBOOL);
BOOL IsValidLocale(LCID,DWORD);
LCID ConvertDefaultLocale(LCID);
LCID GetThreadLocale(void);
BOOL SetThreadLocale(LCID);
LANGID GetSystemDefaultLangID(void);
LANGID GetUserDefaultLangID(void);
LCID GetSystemDefaultLCID(void);
LCID GetUserDefaultLCID(void);
BOOL ReadConsoleOutputAttribute(HANDLE,LPWORD,DWORD,COORD,LPDWORD);
BOOL WriteConsoleOutputAttribute(HANDLE,CONST WORD *,DWORD,COORD,LPDWORD);
BOOL FillConsoleOutputAttribute(HANDLE,WORD,DWORD,COORD,LPDWORD);
BOOL GetConsoleMode(HANDLE,LPDWORD);
BOOL GetNumberOfConsoleInputEvents(HANDLE,LPDWORD);
BOOL GetConsoleScreenBufferInfo(HANDLE,PCONSOLE_SCREEN_BUFFER_INFO);
COORD GetLargestConsoleWindowSize(HANDLE);
BOOL GetConsoleCursorInfo(HANDLE,PCONSOLE_CURSOR_INFO);
BOOL GetNumberOfConsoleMouseButtons(LPDWORD);
BOOL SetConsoleMode(HANDLE,DWORD);
BOOL SetConsoleActiveScreenBuffer(HANDLE);
BOOL FlushConsoleInputBuffer(HANDLE);
BOOL SetConsoleScreenBufferSize(HANDLE,COORD);
BOOL SetConsoleCursorPosition(HANDLE,COORD);
BOOL SetConsoleCursorInfo(HANDLE,CONST CONSOLE_CURSOR_INFO *);
BOOL SetConsoleWindowInfo(HANDLE,BOOL,CONST SMALL_RECT *);
BOOL SetConsoleTextAttribute(HANDLE,WORD);
BOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE,BOOL);
BOOL GenerateConsoleCtrlEvent(DWORD,DWORD);
BOOL AllocConsole(VOID);
BOOL FreeConsole(VOID);
HANDLE CreateConsoleScreenBuffer(DWORD,DWORD,CONST SECURITY_ATTRIBUTES *,DWORD,LPVOID);
UINT GetConsoleCP(VOID);
BOOL SetConsoleCP(UINT);
UINT GetConsoleOutputCP(VOID);
BOOL SetConsoleOutputCP(UINT);
DWORD WNetConnectionDialog(HWND,DWORD);
DWORD WNetDisconnectDialog(HWND,DWORD);
DWORD WNetCloseEnum( HANDLE);
BOOL NotifyBootConfigStatus(BOOL);
BOOL WinLoadTrustProvider(GUID *);
LONG WinVerifyTrust(HWND,GUID *,LPVOID);
BOOL WinSubmitCertificate(LPWIN_CERTIFICATE);
BOOL	WINAPI wglCopyContext(HGLRC,HGLRC, UINT);
HGLRC	WINAPI wglCreateContext(HDC);
HGLRC	WINAPI wglCreateLayerContext(HDC,int);
BOOL	WINAPI wglDeleteContext(HGLRC);
HGLRC	WINAPI wglGetCurrentContext(VOID);
HDC	WINAPI wglGetCurrentDC(VOID);
FARPROC	WINAPI wglGetProcAddress(LPCSTR);
BOOL	WINAPI wglMakeCurrent(HDC,HGLRC);
BOOL	WINAPI wglShareLists(HGLRC,HGLRC);
BOOL	WINAPI wglUseFontBitmapsA(HDC,DWORD, DWORD, DWORD);
BOOL	WINAPI wglUseFontBitmapsW(HDC,DWORD, DWORD, DWORD);
BOOL	WINAPI SwapBuffers(HDC);
BOOL	WINAPI wglSwapLayerBuffers(HDC,UINT);
BOOL	WINAPI GetAltTabInfoA(HWND,int,PALTTABINFO,LPSTR,UINT);
BOOL	WINAPI GetAltTabInfoW(HWND,int,PALTTABINFO,LPWSTR,UINT);
#ifdef UNICODE
#define wglUseFontBitmaps wglUseFontBitmapsW
#define GetAltTabInfo	GetAltTabInfoW
#define CreateWaitableTimer	CreateWaitableTimerW
#else
#define wglUseFontBitmaps wglUseFontBitmapsA
#define GetAltTabInfo	GetAltTabInfoA
#define CreateWaitableTimer	CreateWaitableTimerA
#endif
typedef struct _POINTFLOAT {
	FLOAT	x;
	FLOAT	y;
} POINTFLOAT,*PPOINTFLOAT;
typedef struct _GLYPHMETRICSFLOAT {
	FLOAT	gmfBlackBoxX;
	FLOAT	gmfBlackBoxY;
	POINTFLOAT gmfptGlyphOrigin;
	FLOAT	gmfCellIncX;
	FLOAT	gmfCellIncY;
} GLYPHMETRICSFLOAT,*PGLYPHMETRICSFLOAT,*LPGLYPHMETRICSFLOAT;
#define WGL_FONT_LINES	0
#define WGL_FONT_POLYGONS	1
#define WGL_SWAPMULTIPLE_MAX 16
BOOL	WINAPI wglUseFontOutlinesA(HDC,DWORD,DWORD,DWORD,FLOAT,FLOAT,int,LPGLYPHMETRICSFLOAT);
BOOL	WINAPI wglUseFontOutlinesW(HDC,DWORD,DWORD,DWORD,FLOAT,FLOAT,int,LPGLYPHMETRICSFLOAT);
#ifdef UNICODE
#define wglUseFontOutlines wglUseFontOutlinesW
#else
#define wglUseFontOutlines wglUseFontOutlinesA
#endif
typedef struct _LAYERPLANEDESCRIPTOR {
	WORD	nSize;
	WORD	nVersion;
	DWORD	dwFlags;
	BYTE	iPixelType;
	BYTE	cColorBits;
	BYTE	cRedBits;
	BYTE	cRedShift;
	BYTE	cGreenBits;
	BYTE	cGreenShift;
	BYTE	cBlueBits;
	BYTE	cBlueShift;
	BYTE	cAlphaBits;
	BYTE	cAlphaShift;
	BYTE	cAccumBits;
	BYTE	cAccumRedBits;
	BYTE	cAccumGreenBits;
	BYTE	cAccumBlueBits;
	BYTE	cAccumAlphaBits;
	BYTE	cDepthBits;
	BYTE	cStencilBits;
	BYTE	cAuxBuffers;
	BYTE	iLayerPlane;
	BYTE	bReserved;
	COLORREF crTransparent;
} LAYERPLANEDESCRIPTOR,*PLAYERPLANEDESCRIPTOR,*LPLAYERPLANEDESCRIPTOR;
#define LPD_DOUBLEBUFFER	1
#define LPD_STEREO	2
#define LPD_SUPPORT_GDI	16
#define LPD_SUPPORT_OPENGL	32
#define LPD_SHARE_DEPTH	0x40
#define LPD_SHARE_STENCIL	0x80
#define LPD_SHARE_ACCUM	0x100
#define LPD_SWAP_EXCHANGE	0x200
#define LPD_SWAP_COPY	0x400
#define LPD_TRANSPARENT	0x1000
#define LPD_TYPE_RGBA	0
#define LPD_TYPE_COLORINDEX	1
#define WGL_SWAP_MAIN_PLANE	1
#define WGL_SWAP_OVERLAY1	2
#define WGL_SWAP_OVERLAY2	4
#define WGL_SWAP_OVERLAY3	8
#define	WGL_SWAP_OVERLAY4	0x10
#define	WGL_SWAP_OVERLAY5	0x20
#define	WGL_SWAP_OVERLAY6	0x40
#define	WGL_SWAP_OVERLAY7	0x80
#define	WGL_SWAP_OVERLAY8	0x100
#define	WGL_SWAP_OVERLAY9	0x200
#define	WGL_SWAP_OVERLAY10	0x400
#define	WGL_SWAP_OVERLAY11	0x800
#define	WGL_SWAP_OVERLAY12	0x1000
#define	WGL_SWAP_OVERLAY13	0x2000
#define	WGL_SWAP_OVERLAY14	0x4000
#define	WGL_SWAP_OVERLAY15	0x8000
#define	WGL_SWAP_UNDERLAY1	0x10000
#define	WGL_SWAP_UNDERLAY2	0x20000
#define	WGL_SWAP_UNDERLAY3	0x40000
#define	WGL_SWAP_UNDERLAY4	0x80000
#define	WGL_SWAP_UNDERLAY5	0x100000
#define	WGL_SWAP_UNDERLAY6	0x200000
#define	WGL_SWAP_UNDERLAY7	0x400000
#define	WGL_SWAP_UNDERLAY8	0x800000
#define	WGL_SWAP_UNDERLAY9	0x1000000
#define	WGL_SWAP_UNDERLAY10	0x2000000
#define	WGL_SWAP_UNDERLAY11	0x4000000
#define	WGL_SWAP_UNDERLAY12	0x08000000
#define WGL_SWAP_UNDERLAY13 0x10000000
#define WGL_SWAP_UNDERLAY14 0x20000000
#define WGL_SWAP_UNDERLAY15 0x40000000
BOOL WINAPI wglDescribeLayerPlane(HDC,int,int,UINT,LPLAYERPLANEDESCRIPTOR);
int WINAPI wglSetLayerPaletteEntries(HDC,int,int,int,COLORREF *);
int WINAPI wglGetLayerPaletteEntries(HDC,int,int,int,COLORREF *);
BOOL WINAPI wglRealizeLayerPalette(HDC,int, BOOL);
BOOL WINAPI wglSwapLayerBuffers(HDC,UINT);
struct	_TEB	*NtCurrentTeb(void);
LPVOID	WINAPI	CreateFiber(DWORD,LPFIBER_START_ROUTINE,LPVOID);
VOID WINAPI DeleteFiber(LPVOID);
LPVOID WINAPI ConvertThreadToFiber(LPVOID);
VOID WINAPI SwitchToFiber(LPVOID);
BOOL WINAPI SwitchToThread(VOID);
typedef void (* WAITORTIMERCALLBACKFUNC)(PVOID,BOOL);
typedef WAITORTIMERCALLBACKFUNC WAITORTIMERCALLBACK ;
HANDLE WINAPI RegisterWaitForSingleObject(HANDLE,WAITORTIMERCALLBACK,PVOID,ULONG);
HANDLE WINAPI RegisterWaitForSingleObjectEx(HANDLE,WAITORTIMERCALLBACK,PVOID,ULONG,ULONG);
BOOL WINAPI UnregisterWait(HANDLE);
BOOL WINAPI QueueUserWorkItem(LPTHREAD_START_ROUTINE,PVOID,BOOL);
BOOL WINAPI CreateTimerQueueTimer(PHANDLE,HANDLE, WAITORTIMERCALLBACK,PVOID,DWORD,DWORD,ULONG);
BOOL WINAPI BindIoCompletionCallback (HANDLE,LPOVERLAPPED_COMPLETION_ROUTINE,ULONG);
HANDLE WINAPI CreateTimerQueue(VOID);
HANDLE WINAPI SetTimerQueueTimer(HANDLE,WAITORTIMERCALLBACK,PVOID,DWORD,DWORD,BOOL);
BOOL WINAPI ChangeTimerQueueTimer(HANDLE,HANDLE,ULONG,ULONG);
WINBASEAPI BOOL WINAPI CancelTimerQueueTimer(HANDLE,HANDLE);
WINBASEAPI BOOL WINAPI DeleteTimerQueue(HANDLE);
BOOL WINAPI DeleteTimerQueueEx(HANDLE, HANDLE);
#define MakeProcInstance(a,b) (a)
#define FreeProcInstance(a)	(a)
#define AnsiToOem CharToOemA
#define OemToAnsi OemToCharA
#define AnsiToOemBuff CharToOemBuffA
#define OemToAnsiBuff OemToCharBuffA
#define AnsiUpper CharUpperA
#define AnsiUpperBuff CharUpperBuffA
#define AnsiLower CharLowerA
#define AnsiLowerBuff CharLowerBuffA
#define AnsiNext CharNextA
#define AnsiPrev CharPrevA
#define DefineHandleTable(w) ((w),TRUE)
#define LimitEmsPages(dw)
#define SetSwapAreaSize(w) (w)
#define LockSegment(w) GlobalFix((HANDLE)(w))
#define UnlockSegment(w) GlobalUnfix((HANDLE)(w))
#define GetCurrentTime() GetTickCount()
#define Yield()
#define ZeroMemory RtlZeroMemory
#define RtlFillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
#define MAKE_HRESULT(s,f,c) ((HRESULT)(((DWORD)(s)<<31)|((DWORD)(f)<<16)|((DWORD)(c))))

//#ifdef RC_INVOKED
//#define _HRESULT_TYPEDEF_(_sc) _sc
//#else
//#define _HRESULT_TYPEDEF_(_sc) ((HRESULT)_sc)
//#endif

#define E_FAIL	_HRESULT_TYPEDEF_(0x80004005)
#define E_UNEXPECTED	_HRESULT_TYPEDEF_(0x8000FFFF)
#define E_NOTIMPL	_HRESULT_TYPEDEF_(0x80004001)
#define E_OUTOFMEMORY	_HRESULT_TYPEDEF_(0x8007000E)
#define E_INVALIDARG	_HRESULT_TYPEDEF_(0x80070057)
#define E_NOINTERFACE	_HRESULT_TYPEDEF_(0x80004002)
#define E_POINTER	_HRESULT_TYPEDEF_(0x80004003)
#define E_HANDLE	_HRESULT_TYPEDEF_(0x80070006)
#define E_ABORT		_HRESULT_TYPEDEF_(0x80004004)
#define E_ACCESSDENIED	_HRESULT_TYPEDEF_(0x80070005)
#define CO_E_INIT_TLS	_HRESULT_TYPEDEF_(0x80004006)
#define CO_E_INIT_SHARED_ALLOCATOR	_HRESULT_TYPEDEF_(0x80004007)
#define CO_E_INIT_MEMORY_ALLOCATOR	_HRESULT_TYPEDEF_(0x80004008)
#define CO_E_INIT_CLASS_CACHE	_HRESULT_TYPEDEF_(0x80004009)
#define CO_E_INIT_RPC_CHANNEL	_HRESULT_TYPEDEF_(0x8000400A)
#define CO_E_INIT_TLS_SET_CHANNEL_CONTROL	_HRESULT_TYPEDEF_(0x8000400B)
#define CO_E_INIT_TLS_CHANNEL_CONTROL	_HRESULT_TYPEDEF_(0x8000400C)
#define CO_E_INIT_UNACCEPTED_USER_ALLOCATOR _HRESULT_TYPEDEF_(0x8000400D)
#define CO_E_INIT_SCM_MUTEX_EXISTS	_HRESULT_TYPEDEF_(0x8000400E)
#define CO_E_INIT_SCM_FILE_MAPPING_EXISTS _HRESULT_TYPEDEF_(0x8000400F)
#define CO_E_INIT_SCM_MAP_VIEW_OF_FILE	_HRESULT_TYPEDEF_(0x80004010)
#define CO_E_INIT_SCM_EXEC_FAILURE	_HRESULT_TYPEDEF_(0x80004011)
#define CO_E_INIT_ONLY_SINGLE_THREADED	_HRESULT_TYPEDEF_(0x80004012)
#define CO_E_CANT_REMOTE	_HRESULT_TYPEDEF_(0x80004013)
#define CO_E_BAD_SERVER_NAME	_HRESULT_TYPEDEF_(0x80004014)
#define CO_E_WRONG_SERVER_IDENTITY	_HRESULT_TYPEDEF_(0x80004015)
#define CO_E_OLE1DDE_DISABLED	_HRESULT_TYPEDEF_(0x80004016)
#define CO_E_RUNAS_SYNTAX	_HRESULT_TYPEDEF_(0x80004017)
#define CO_E_CREATEPROCESS_FAILURE	_HRESULT_TYPEDEF_(0x80004018)
#define CO_E_RUNAS_CREATEPROCESS_FAILURE _HRESULT_TYPEDEF_(0x80004019)
#define CO_E_RUNAS_LOGON_FAILURE	_HRESULT_TYPEDEF_(0x8000401A)
#define CO_E_LAUNCH_PERMSSION_DENIED	_HRESULT_TYPEDEF_(0x8000401B)
#define CO_E_START_SERVICE_FAILURE	_HRESULT_TYPEDEF_(0x8000401C)
#define CO_E_REMOTE_COMMUNICATION_FAILURE _HRESULT_TYPEDEF_(0x8000401D)
#define CO_E_SERVER_START_TIMEOUT	_HRESULT_TYPEDEF_(0x8000401E)
#define CO_E_CLSREG_INCONSISTENT	_HRESULT_TYPEDEF_(0x8000401F)
#define CO_E_IIDREG_INCONSISTENT	_HRESULT_TYPEDEF_(0x80004020)
#define CO_E_NOT_SUPPORTED	_HRESULT_TYPEDEF_(0x80004021)
#define CO_E_RELOAD_DLL	_HRESULT_TYPEDEF_(0x80004022)
#define CO_E_MSI_ERROR	_HRESULT_TYPEDEF_(0x80004023)
#define	CLASS_E_NOAGGREGATION	_HRESULT_TYPEDEF_(0x80040110)
#define CLASS_E_CLASSNOTAVAILABLE	_HRESULT_TYPEDEF_(0x80040111)
/* Errors.h WIN32 error codes Numerical order */
#define NO_ERROR 0
#define ERROR_SUCCESS 0
#define ERROR_INVALID_FUNCTION 1
#define ERROR_FILE_NOT_FOUND 2
#define ERROR_PATH_NOT_FOUND 3
#define ERROR_TOO_MANY_OPEN_FILES 4
#define ERROR_ACCESS_DENIED 5
#define ERROR_INVALID_HANDLE 6
#define ERROR_ARENA_TRASHED 7
#define ERROR_NOT_ENOUGH_MEMORY 8
#define ERROR_INVALID_BLOCK 9
#define ERROR_BAD_ENVIRONMENT 10
#define ERROR_BAD_FORMAT 11
#define ERROR_INVALID_ACCESS 12
#define ERROR_INVALID_DATA 13
#define ERROR_OUTOFMEMORY 14
#define ERROR_INVALID_DRIVE 15
#define ERROR_CURRENT_DIRECTORY 16
#define ERROR_NOT_SAME_DEVICE 17
#define ERROR_NO_MORE_FILES 18
#define ERROR_WRITE_PROTECT 19
#define ERROR_BAD_UNIT 20
#define ERROR_NOT_READY 21
#define ERROR_BAD_COMMAND 22
#define ERROR_CRC 23
#define ERROR_BAD_LENGTH 24
#define ERROR_SEEK 25
#define ERROR_NOT_DOS_DISK 26
#define ERROR_SECTOR_NOT_FOUND 27
#define ERROR_OUT_OF_PAPER 28
#define ERROR_WRITE_FAULT 29
#define ERROR_READ_FAULT 30
#define ERROR_GEN_FAILURE 31
#define ERROR_SHARING_VIOLATION 32
#define ERROR_LOCK_VIOLATION 33
#define ERROR_WRONG_DISK 34
#define ERROR_SHARING_BUFFER_EXCEEDED 36
#define ERROR_HANDLE_EOF 38
#define ERROR_HANDLE_DISK_FULL 39
#define ERROR_NOT_SUPPORTED 50
#define ERROR_REM_NOT_LIST 51
#define ERROR_DUP_NAME 52
#define ERROR_BAD_NETPATH 53
#define ERROR_NETWORK_BUSY 54
#define ERROR_DEV_NOT_EXIST 55
#define ERROR_TOO_MANY_CMDS 56
#define ERROR_ADAP_HDW_ERR 57
#define ERROR_BAD_NET_RESP 58
#define ERROR_UNEXP_NET_ERR 59
#define ERROR_BAD_REM_ADAP 60
#define ERROR_PRINTQ_FULL 61
#define ERROR_NO_SPOOL_SPACE 62
#define ERROR_PRINT_CANCELLED 63
#define ERROR_NETNAME_DELETED 64
#define ERROR_NETWORK_ACCESS_DENIED 65
#define ERROR_BAD_DEV_TYPE 66
#define ERROR_BAD_NET_NAME 67
#define ERROR_TOO_MANY_NAMES 68
#define ERROR_TOO_MANY_SESS 69
#define ERROR_SHARING_PAUSED 70
#define ERROR_REQ_NOT_ACCEP 71
#define ERROR_REDIR_PAUSED 72
#define ERROR_FILE_EXISTS 80
#define ERROR_CANNOT_MAKE 82
#define ERROR_FAIL_I24 83
#define ERROR_OUT_OF_STRUCTURES 84
#define ERROR_ALREADY_ASSIGNED 85
#define ERROR_INVALID_PASSWORD 86
#define ERROR_INVALID_PARAMETER 87
#define ERROR_NET_WRITE_FAULT 88
#define ERROR_NO_PROC_SLOTS 89
#define ERROR_TOO_MANY_SEMAPHORES 100
#define ERROR_EXCL_SEM_ALREADY_OWNED 101
#define ERROR_SEM_IS_SET 102
#define ERROR_TOO_MANY_SEM_REQUESTS 103
#define ERROR_INVALID_AT_INTERRUPT_TIME 104
#define ERROR_SEM_OWNER_DIED 105
#define ERROR_SEM_USER_LIMIT 106
#define ERROR_DISK_CHANGE 107
#define ERROR_DRIVE_LOCKED 108
#define ERROR_BROKEN_PIPE 109
#define ERROR_OPEN_FAILED 110
#define ERROR_BUFFER_OVERFLOW 111
#define ERROR_DISK_FULL 112
#define ERROR_NO_MORE_SEARCH_HANDLES 113
#define ERROR_INVALID_TARGET_HANDLE 114
#define ERROR_INVALID_CATEGORY 117
#define ERROR_INVALID_VERIFY_SWITCH 118
#define ERROR_BAD_DRIVER_LEVEL 119
#define ERROR_CALL_NOT_IMPLEMENTED 120
#define ERROR_SEM_TIMEOUT 121
#define ERROR_INSUFFICIENT_BUFFER 122
#define ERROR_INVALID_NAME 123
#define ERROR_INVALID_LEVEL 124
#define ERROR_NO_VOLUME_LABEL 125
#define ERROR_MOD_NOT_FOUND 126
#define ERROR_PROC_NOT_FOUND 127
#define ERROR_WAIT_NO_CHILDREN 128
#define ERROR_CHILD_NOT_COMPLETE 129
#define ERROR_DIRECT_ACCESS_HANDLE 130
#define ERROR_NEGATIVE_SEEK 131
#define ERROR_SEEK_ON_DEVICE 132
#define ERROR_IS_JOIN_TARGET 133
#define ERROR_IS_JOINED 134
#define ERROR_IS_SUBSTED 135
#define ERROR_NOT_JOINED 136
#define ERROR_NOT_SUBSTED 137
#define ERROR_JOIN_TO_JOIN 138
#define ERROR_SUBST_TO_SUBST 139
#define ERROR_JOIN_TO_SUBST 140
#define ERROR_SUBST_TO_JOIN 141
#define ERROR_BUSY_DRIVE 142
#define ERROR_SAME_DRIVE 143
#define ERROR_DIR_NOT_ROOT 144
#define ERROR_DIR_NOT_EMPTY 145
#define ERROR_IS_SUBST_PATH 146
#define ERROR_IS_JOIN_PATH 147
#define ERROR_PATH_BUSY 148
#define ERROR_IS_SUBST_TARGET 149
#define ERROR_SYSTEM_TRACE 150
#define ERROR_INVALID_EVENT_COUNT 151
#define ERROR_TOO_MANY_MUXWAITERS 152
#define ERROR_INVALID_LIST_FORMAT 153
#define ERROR_LABEL_TOO_LONG 154
#define ERROR_TOO_MANY_TCBS 155
#define ERROR_SIGNAL_REFUSED 156
#define ERROR_DISCARDED 157
#define ERROR_NOT_LOCKED 158
#define ERROR_BAD_THREADID_ADDR 159
#define ERROR_BAD_ARGUMENTS 160
#define ERROR_BAD_PATHNAME 161
#define ERROR_SIGNAL_PENDING 162
#define ERROR_MAX_THRDS_REACHED 164
#define ERROR_LOCK_FAILED 167
#define ERROR_BUSY 170
#define ERROR_CANCEL_VIOLATION 173
#define ERROR_ATOMIC_LOCKS_NOT_SUPPORTED 174
#define ERROR_INVALID_SEGMENT_NUMBER 180
#define ERROR_INVALID_ORDINAL 182
#define ERROR_ALREADY_EXISTS 183
#define ERROR_INVALID_FLAG_NUMBER 186
#define ERROR_SEM_NOT_FOUND 187
#define ERROR_INVALID_STARTING_CODESEG 188
#define ERROR_INVALID_STACKSEG 189
#define ERROR_INVALID_MODULETYPE 190
#define ERROR_INVALID_EXE_SIGNATURE 191
#define ERROR_EXE_MARKED_INVALID 192
#define ERROR_EXE_MACHINE_TYPE_MISMATCH 216
#define ERROR_BAD_EXE_FORMAT 193
#define ERROR_ITERATED_DATA_EXCEEDS_64k 194
#define ERROR_INVALID_MINALLOCSIZE 195
#define ERROR_DYNLINK_FROM_INVALID_RING 196
#define ERROR_IOPL_NOT_ENABLED 197
#define ERROR_INVALID_SEGDPL 198
#define ERROR_AUTODATASEG_EXCEEDS_64k 199
#define ERROR_RING2SEG_MUST_BE_MOVABLE 200
#define ERROR_RELOC_CHAIN_XEEDS_SEGLIM 201
#define ERROR_INFLOOP_IN_RELOC_CHAIN 202
#define ERROR_ENVVAR_NOT_FOUND 203
#define ERROR_NO_SIGNAL_SENT 205
#define ERROR_FILENAME_EXCED_RANGE 206
#define ERROR_RING2_STACK_IN_USE 207
#define ERROR_META_EXPANSION_TOO_LONG 208
#define ERROR_INVALID_SIGNAL_NUMBER 209
#define ERROR_THREAD_1_INACTIVE 210
#define ERROR_LOCKED 212
#define ERROR_TOO_MANY_MODULES 214
#define ERROR_NESTING_NOT_ALLOWED 215
#define ERROR_BAD_PIPE 230
#define ERROR_PIPE_BUSY 231
#define ERROR_NO_DATA 232
#define ERROR_PIPE_NOT_CONNECTED 233
#define ERROR_MORE_DATA 234
#define ERROR_VC_DISCONNECTED 240
#define ERROR_INVALID_EA_NAME 254
#define ERROR_EA_LIST_INCONSISTENT 255
#define ERROR_NO_MORE_ITEMS 259
#define ERROR_CANNOT_COPY 266
#define ERROR_DIRECTORY 267
#define ERROR_EAS_DIDNT_FIT 275
#define ERROR_EA_FILE_CORRUPT 276
#define ERROR_EA_TABLE_FULL 277
#define ERROR_INVALID_EA_HANDLE 278
#define ERROR_EAS_NOT_SUPPORTED 282
#define ERROR_NOT_OWNER 288
#define ERROR_TOO_MANY_POSTS 298
#define ERROR_PARTIAL_COPY 299
#define ERROR_MR_MID_NOT_FOUND 317
#define ERROR_INVALID_ADDRESS 487
#define ERROR_ARITHMETIC_OVERFLOW 534
#define ERROR_PIPE_CONNECTED 535
#define ERROR_PIPE_LISTENING 536
#define ERROR_EA_ACCESS_DENIED 994
#define ERROR_OPERATION_ABORTED 995
#define ERROR_IO_INCOMPLETE 996
#define ERROR_IO_PENDING 997
#define ERROR_NOACCESS 998
#define ERROR_SWAPERROR 999
#define ERROR_STACK_OVERFLOW 1001
#define ERROR_INVALID_MESSAGE 1002
#define ERROR_CAN_NOT_COMPLETE 1003
#define ERROR_INVALID_FLAGS 1004
#define ERROR_UNRECOGNIZED_VOLUME 1005
#define ERROR_FILE_INVALID 1006
#define ERROR_FULLSCREEN_MODE 1007
#define ERROR_NO_TOKEN 1008
#define ERROR_BADDB 1009
#define ERROR_BADKEY 1010
#define ERROR_CANTOPEN 1011
#define ERROR_CANTREAD 1012
#define ERROR_CANTWRITE 1013
#define ERROR_REGISTRY_RECOVERED 1014
#define ERROR_REGISTRY_CORRUPT 1015
#define ERROR_REGISTRY_IO_FAILED 1016
#define ERROR_NOT_REGISTRY_FILE 1017
#define ERROR_KEY_DELETED 1018
#define ERROR_NO_LOG_SPACE 1019
#define ERROR_KEY_HAS_CHILDREN 1020
#define ERROR_CHILD_MUST_BE_VOLATILE 1021
#define ERROR_NOTIFY_ENUM_DIR 1022
#define ERROR_DEPENDENT_SERVICES_RUNNING 1051
#define ERROR_INVALID_SERVICE_CONTROL 1052
#define ERROR_SERVICE_REQUEST_TIMEOUT 1053
#define ERROR_SERVICE_NO_THREAD 1054
#define ERROR_SERVICE_DATABASE_LOCKED 1055
#define ERROR_SERVICE_ALREADY_RUNNING 1056
#define ERROR_INVALID_SERVICE_ACCOUNT 1057
#define ERROR_SERVICE_DISABLED 1058
#define ERROR_CIRCULAR_DEPENDENCY 1059
#define ERROR_SERVICE_DOES_NOT_EXIST 1060
#define ERROR_SERVICE_CANNOT_ACCEPT_CTRL 1061
#define ERROR_SERVICE_NOT_ACTIVE 1062
#define ERROR_FAILED_SERVICE_CONTROLLER_CONNECT 1063
#define ERROR_EXCEPTION_IN_SERVICE 1064
#define ERROR_DATABASE_DOES_NOT_EXIST 1065
#define ERROR_SERVICE_SPECIFIC_ERROR 1066
#define ERROR_PROCESS_ABORTED 1067
#define ERROR_SERVICE_DEPENDENCY_FAIL 1068
#define ERROR_SERVICE_LOGON_FAILED 1069
#define ERROR_SERVICE_START_HANG 1070
#define ERROR_INVALID_SERVICE_LOCK 1071
#define ERROR_SERVICE_MARKED_FOR_DELETE 1072
#define ERROR_SERVICE_EXISTS 1073
#define ERROR_ALREADY_RUNNING_LKG 1074
#define ERROR_SERVICE_DEPENDENCY_DELETED 1075
#define ERROR_BOOT_ALREADY_ACCEPTED 1076
#define ERROR_SERVICE_NEVER_STARTED 1077
#define ERROR_DUPLICATE_SERVICE_NAME 1078
#define ERROR_DIFFERENT_SERVICE_ACCOUNT 1079
#define ERROR_END_OF_MEDIA 1100
#define ERROR_FILEMARK_DETECTED 1101
#define ERROR_BEGINNING_OF_MEDIA 1102
#define ERROR_SETMARK_DETECTED 1103
#define ERROR_NO_DATA_DETECTED 1104
#define ERROR_PARTITION_FAILURE 1105
#define ERROR_INVALID_BLOCK_LENGTH 1106

#define ERROR_DEVICE_NOT_PARTITIONED 1107
#define ERROR_UNABLE_TO_LOCK_MEDIA 1108
#define ERROR_UNABLE_TO_UNLOAD_MEDIA 1109
#define ERROR_MEDIA_CHANGED 1110
#define ERROR_BUS_RESET 1111
#define ERROR_NO_MEDIA_IN_DRIVE 1112
#define ERROR_NO_UNICODE_TRANSLATION 1113
#define ERROR_DLL_INIT_FAILED 1114
#define ERROR_SHUTDOWN_IN_PROGRESS 1115
#define ERROR_NO_SHUTDOWN_IN_PROGRESS 1116
#define ERROR_IO_DEVICE 1117
#define ERROR_SERIAL_NO_DEVICE 1118
#define ERROR_IRQ_BUSY 1119
#define ERROR_MORE_WRITES 1120
#define ERROR_COUNTER_TIMEOUT 1121
#define ERROR_FLOPPY_ID_MARK_NOT_FOUND 1122
#define ERROR_FLOPPY_WRONG_CYLINDER 1123
#define ERROR_FLOPPY_UNKNOWN_ERROR 1124
#define ERROR_FLOPPY_BAD_REGISTERS 1125
#define ERROR_DISK_RECALIBRATE_FAILED 1126
#define ERROR_DISK_OPERATION_FAILED 1127
#define ERROR_DISK_RESET_FAILED 1128
#define ERROR_EOM_OVERFLOW 1129
#define ERROR_NOT_ENOUGH_SERVER_MEMORY 1130
#define ERROR_POSSIBLE_DEADLOCK 1131
#define ERROR_MAPPED_ALIGNMENT 1132
#define ERROR_SET_POWER_STATE_VETOED 1140
#define ERROR_SET_POWER_STATE_FAILED 1141
#define ERROR_TOO_MANY_LINKS 1142
#define ERROR_OLD_WIN_VERSION 1150
#define ERROR_APP_WRONG_OS 1151
#define ERROR_SINGLE_INSTANCE_APP 1152
#define ERROR_RMODE_APP 1153
#define ERROR_INVALID_DLL 1154
#define ERROR_NO_ASSOCIATION 1155
#define ERROR_DDE_FAIL 1156
#define ERROR_DLL_NOT_FOUND 1157
#define ERROR_BAD_USERNAME 2202
#define ERROR_NOT_CONNECTED 2250
#define ERROR_OPEN_FILES 2401
#define ERROR_ACTIVE_CONNECTIONS 2402
#define ERROR_DEVICE_IN_USE 2404
#define ERROR_BAD_DEVICE 1200
#define ERROR_CONNECTION_UNAVAIL 1201
#define ERROR_DEVICE_ALREADY_REMEMBERED 1202
#define ERROR_NO_NET_OR_BAD_PATH 1203
#define ERROR_BAD_PROVIDER 1204
#define ERROR_CANNOT_OPEN_PROFILE 1205
#define ERROR_BAD_PROFILE 1206
#define ERROR_NOT_CONTAINER 1207
#define ERROR_EXTENDED_ERROR 1208
#define ERROR_INVALID_GROUPNAME 1209
#define ERROR_INVALID_COMPUTERNAME 1210
#define ERROR_INVALID_EVENTNAME 1211
#define ERROR_INVALID_DOMAINNAME 1212
#define ERROR_INVALID_SERVICENAME 1213
#define ERROR_INVALID_NETNAME 1214
#define ERROR_INVALID_SHARENAME 1215
#define ERROR_INVALID_PASSWORDNAME 1216
#define ERROR_INVALID_MESSAGENAME 1217
#define ERROR_INVALID_MESSAGEDEST 1218
#define ERROR_SESSION_CREDENTIAL_CONFLICT 1219
#define ERROR_REMOTE_SESSION_LIMIT_EXCEEDED 1220
#define ERROR_DUP_DOMAINNAME 1221
#define ERROR_NO_NETWORK 1222
#define ERROR_CANCELLED 1223
#define ERROR_USER_MAPPED_FILE 1224
#define ERROR_CONNECTION_REFUSED 1225
#define ERROR_GRACEFUL_DISCONNECT 1226
#define ERROR_ADDRESS_ALREADY_ASSOCIATED 1227
#define ERROR_ADDRESS_NOT_ASSOCIATED 1228
#define ERROR_CONNECTION_INVALID 1229
#define ERROR_CONNECTION_ACTIVE 1230
#define ERROR_NETWORK_UNREACHABLE 1231
#define ERROR_HOST_UNREACHABLE 1232
#define ERROR_PROTOCOL_UNREACHABLE 1233
#define ERROR_PORT_UNREACHABLE 1234
#define ERROR_REQUEST_ABORTED 1235
#define ERROR_CONNECTION_ABORTED 1236
#define ERROR_RETRY 1237
#define ERROR_CONNECTION_COUNT_LIMIT 1238
#define ERROR_LOGIN_TIME_RESTRICTION 1239
#define ERROR_LOGIN_WKSTA_RESTRICTION 1240
#define ERROR_INCORRECT_ADDRESS 1241
#define ERROR_ALREADY_REGISTERED 1242
#define ERROR_SERVICE_NOT_FOUND 1243
#define ERROR_NOT_AUTHENTICATED 1244
#define ERROR_NOT_LOGGED_ON 1245
#define ERROR_CONTINUE 1246
#define ERROR_ALREADY_INITIALIZED 1247
#define ERROR_NO_MORE_DEVICES 1248
#define ERROR_NOT_ALL_ASSIGNED 1300
#define ERROR_SOME_NOT_MAPPED 1301
#define ERROR_NO_QUOTAS_FOR_ACCOUNT 1302
#define ERROR_LOCAL_USER_SESSION_KEY 1303
#define ERROR_NULL_LM_PASSWORD 1304
#define ERROR_UNKNOWN_REVISION 1305
#define ERROR_REVISION_MISMATCH 1306
#define ERROR_INVALID_OWNER 1307
#define ERROR_INVALID_PRIMARY_GROUP 1308
#define ERROR_NO_IMPERSONATION_TOKEN 1309
#define ERROR_CANT_DISABLE_MANDATORY 1310
#define ERROR_NO_LOGON_SERVERS 1311
#define ERROR_NO_SUCH_LOGON_SESSION 1312
#define ERROR_NO_SUCH_PRIVILEGE 1313
#define ERROR_PRIVILEGE_NOT_HELD 1314
#define ERROR_INVALID_ACCOUNT_NAME 1315
#define ERROR_USER_EXISTS 1316
#define ERROR_NO_SUCH_USER 1317
#define ERROR_GROUP_EXISTS 1318
#define ERROR_NO_SUCH_GROUP 1319
#define ERROR_MEMBER_IN_GROUP 1320
#define ERROR_MEMBER_NOT_IN_GROUP 1321
#define ERROR_LAST_ADMIN 1322
#define ERROR_WRONG_PASSWORD 1323
#define ERROR_ILL_FORMED_PASSWORD 1324
#define ERROR_PASSWORD_RESTRICTION 1325
#define ERROR_LOGON_FAILURE 1326
#define ERROR_ACCOUNT_RESTRICTION 1327
#define ERROR_INVALID_LOGON_HOURS 1328
#define ERROR_INVALID_WORKSTATION 1329
#define ERROR_PASSWORD_EXPIRED 1330
#define ERROR_ACCOUNT_DISABLED 1331
#define ERROR_NONE_MAPPED 1332
#define ERROR_TOO_MANY_LUIDS_REQUESTED 1333
#define ERROR_LUIDS_EXHAUSTED 1334
#define ERROR_INVALID_SUB_AUTHORITY 1335
#define ERROR_INVALID_ACL 1336
#define ERROR_INVALID_SID 1337
#define ERROR_INVALID_SECURITY_DESCR 1338
#define ERROR_BAD_INHERITANCE_ACL 1340
#define ERROR_SERVER_DISABLED 1341
#define ERROR_SERVER_NOT_DISABLED 1342
#define ERROR_INVALID_ID_AUTHORITY 1343
#define ERROR_ALLOTTED_SPACE_EXCEEDED 1344
#define ERROR_INVALID_GROUP_ATTRIBUTES 1345
#define ERROR_BAD_IMPERSONATION_LEVEL 1346
#define ERROR_CANT_OPEN_ANONYMOUS 1347
#define ERROR_BAD_VALIDATION_CLASS 1348
#define ERROR_BAD_TOKEN_TYPE 1349
#define ERROR_NO_SECURITY_ON_OBJECT 1350
#define ERROR_CANT_ACCESS_DOMAIN_INFO 1351
#define ERROR_INVALID_SERVER_STATE 1352
#define ERROR_INVALID_DOMAIN_STATE 1353
#define ERROR_INVALID_DOMAIN_ROLE 1354
#define ERROR_NO_SUCH_DOMAIN 1355
#define ERROR_DOMAIN_EXISTS 1356
#define ERROR_DOMAIN_LIMIT_EXCEEDED 1357
#define ERROR_INTERNAL_DB_CORRUPTION 1358
#define ERROR_INTERNAL_ERROR 1359
#define ERROR_GENERIC_NOT_MAPPED 1360
#define ERROR_BAD_DESCRIPTOR_FORMAT 1361
#define ERROR_NOT_LOGON_PROCESS 1362
#define ERROR_LOGON_SESSION_EXISTS 1363
#define ERROR_NO_SUCH_PACKAGE 1364
#define ERROR_BAD_LOGON_SESSION_STATE 1365
#define ERROR_LOGON_SESSION_COLLISION 1366
#define ERROR_INVALID_LOGON_TYPE 1367
#define ERROR_CANNOT_IMPERSONATE 1368
#define ERROR_RXACT_INVALID_STATE 1369
#define ERROR_RXACT_COMMIT_FAILURE 1370
#define ERROR_SPECIAL_ACCOUNT 1371
#define ERROR_SPECIAL_GROUP 1372
#define ERROR_SPECIAL_USER 1373
#define ERROR_MEMBERS_PRIMARY_GROUP 1374
#define ERROR_TOKEN_ALREADY_IN_USE 1375
#define ERROR_NO_SUCH_ALIAS 1376
#define ERROR_MEMBER_NOT_IN_ALIAS 1377
#define ERROR_MEMBER_IN_ALIAS 1378
#define ERROR_ALIAS_EXISTS 1379
#define ERROR_LOGON_NOT_GRANTED 1380
#define ERROR_TOO_MANY_SECRETS 1381
#define ERROR_SECRET_TOO_LONG 1382
#define ERROR_INTERNAL_DB_ERROR 1383
#define ERROR_TOO_MANY_CONTEXT_IDS 1384
#define ERROR_LOGON_TYPE_NOT_GRANTED 1385
#define ERROR_NT_CROSS_ENCRYPTION_REQUIRED 1386
#define ERROR_NO_SUCH_MEMBER 1387
#define ERROR_INVALID_MEMBER 1388
#define ERROR_TOO_MANY_SIDS 1389
#define ERROR_LM_CROSS_ENCRYPTION_REQUIRED 1390
#define ERROR_NO_INHERITANCE 1391
#define ERROR_FILE_CORRUPT 1392
#define ERROR_DISK_CORRUPT 1393
#define ERROR_NO_USER_SESSION_KEY 1394
#define ERROR_LICENSE_QUOTA_EXCEEDED 1395
#define ERROR_INVALID_WINDOW_HANDLE 1400
#define ERROR_INVALID_MENU_HANDLE 1401
#define ERROR_INVALID_CURSOR_HANDLE 1402
#define ERROR_INVALID_ACCEL_HANDLE 1403
#define ERROR_INVALID_HOOK_HANDLE 1404
#define ERROR_INVALID_DWP_HANDLE 1405
#define ERROR_TLW_WITH_WSCHILD 1406
#define ERROR_CANNOT_FIND_WND_CLASS 1407
#define ERROR_WINDOW_OF_OTHER_THREAD 1408
#define ERROR_HOTKEY_ALREADY_REGISTERED 1409
#define ERROR_CLASS_ALREADY_EXISTS 1410
#define ERROR_CLASS_DOES_NOT_EXIST 1411
#define ERROR_CLASS_HAS_WINDOWS 1412
#define ERROR_INVALID_INDEX 1413
#define ERROR_INVALID_ICON_HANDLE 1414
#define ERROR_PRIVATE_DIALOG_INDEX 1415
#define ERROR_LISTBOX_ID_NOT_FOUND 1416
#define ERROR_NO_WILDCARD_CHARACTERS 1417
#define ERROR_CLIPBOARD_NOT_OPEN 1418
#define ERROR_HOTKEY_NOT_REGISTERED 1419
#define ERROR_WINDOW_NOT_DIALOG 1420
#define ERROR_CONTROL_ID_NOT_FOUND 1421
#define ERROR_INVALID_COMBOBOX_MESSAGE 1422
#define ERROR_WINDOW_NOT_COMBOBOX 1423
#define ERROR_INVALID_EDIT_HEIGHT 1424
#define ERROR_DC_NOT_FOUND 1425
#define ERROR_INVALID_HOOK_FILTER 1426
#define ERROR_INVALID_FILTER_PROC 1427
#define ERROR_HOOK_NEEDS_HMOD 1428
#define ERROR_GLOBAL_ONLY_HOOK 1429
#define ERROR_JOURNAL_HOOK_SET 1430
#define ERROR_HOOK_NOT_INSTALLED 1431
#define ERROR_INVALID_LB_MESSAGE 1432
#define ERROR_SETCOUNT_ON_BAD_LB 1433
#define ERROR_LB_WITHOUT_TABSTOPS 1434
#define ERROR_DESTROY_OBJECT_OF_OTHER_THREAD 1435
#define ERROR_CHILD_WINDOW_MENU 1436
#define ERROR_NO_SYSTEM_MENU 1437
#define ERROR_INVALID_MSGBOX_STYLE 1438
#define ERROR_INVALID_SPI_VALUE 1439
#define ERROR_SCREEN_ALREADY_LOCKED 1440
#define ERROR_HWNDS_HAVE_DIFF_PARENT 1441
#define ERROR_NOT_CHILD_WINDOW 1442
#define ERROR_INVALID_GW_COMMAND 1443
#define ERROR_INVALID_THREAD_ID 1444
#define ERROR_NON_MDICHILD_WINDOW 1445
#define ERROR_POPUP_ALREADY_ACTIVE 1446
#define ERROR_NO_SCROLLBARS 1447
#define ERROR_INVALID_SCROLLBAR_RANGE 1448
#define ERROR_INVALID_SHOWWIN_COMMAND 1449
#define ERROR_NO_SYSTEM_RESOURCES 1450
#define ERROR_NONPAGED_SYSTEM_RESOURCES 1451
#define ERROR_PAGED_SYSTEM_RESOURCES 1452
#define ERROR_WORKING_SET_QUOTA 1453
#define ERROR_PAGEFILE_QUOTA 1454
#define ERROR_COMMITMENT_LIMIT 1455
#define ERROR_MENU_ITEM_NOT_FOUND 1456
#define ERROR_INVALID_KEYBOARD_HANDLE 1457
#define ERROR_HOOK_TYPE_NOT_ALLOWED 1458
#define ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION 1459
#define ERROR_EVENTLOG_FILE_CORRUPT 1500
#define ERROR_EVENTLOG_CANT_START 1501
#define ERROR_LOG_FILE_FULL 1502
#define ERROR_EVENTLOG_FILE_CHANGED 1503
#define RPC_S_INVALID_STRING_BINDING 1700
#define RPC_S_WRONG_KIND_OF_BINDING 1701
#define RPC_S_INVALID_BINDING 1702
#define RPC_S_PROTSEQ_NOT_SUPPORTED 1703
#define RPC_S_INVALID_RPC_PROTSEQ 1704
#define RPC_S_INVALID_STRING_UUID 1705
#define RPC_S_INVALID_ENDPOINT_FORMAT 1706
#define RPC_S_INVALID_NET_ADDR 1707
#define RPC_S_NO_ENDPOINT_FOUND 1708
#define RPC_S_INVALID_TIMEOUT 1709
#define RPC_S_OBJECT_NOT_FOUND 1710
#define RPC_S_ALREADY_REGISTERED 1711
#define RPC_S_TYPE_ALREADY_REGISTERED 1712
#define RPC_S_ALREADY_LISTENING 1713
#define RPC_S_NO_PROTSEQS_REGISTERED 1714
#define RPC_S_NOT_LISTENING 1715
#define RPC_S_UNKNOWN_MGR_TYPE 1716
#define RPC_S_UNKNOWN_IF 1717
#define RPC_S_NO_BINDINGS 1718
#define RPC_S_NO_PROTSEQS 1719
#define RPC_S_CANT_CREATE_ENDPOINT 1720
#define RPC_S_OUT_OF_RESOURCES 1721
#define RPC_S_SERVER_UNAVAILABLE 1722
#define RPC_S_SERVER_TOO_BUSY 1723
#define RPC_S_INVALID_NETWORK_OPTIONS 1724
#define RPC_S_NO_CALL_ACTIVE 1725
#define RPC_S_CALL_FAILED 1726
#define RPC_S_CALL_FAILED_DNE 1727
#define RPC_S_PROTOCOL_ERROR 1728
#define RPC_S_UNSUPPORTED_TRANS_SYN 1730
#define RPC_S_UNSUPPORTED_TYPE 1732
#define RPC_S_INVALID_TAG 1733
#define RPC_S_INVALID_BOUND 1734
#define RPC_S_NO_ENTRY_NAME 1735
#define RPC_S_INVALID_NAME_SYNTAX 1736
#define RPC_S_UNSUPPORTED_NAME_SYNTAX 1737
#define RPC_S_UUID_NO_ADDRESS 1739
#define RPC_S_DUPLICATE_ENDPOINT 1740
#define RPC_S_UNKNOWN_AUTHN_TYPE 1741
#define RPC_S_MAX_CALLS_TOO_SMALL 1742
#define RPC_S_STRING_TOO_LONG 1743
#define RPC_S_PROTSEQ_NOT_FOUND 1744
#define RPC_S_PROCNUM_OUT_OF_RANGE 1745
#define RPC_S_BINDING_HAS_NO_AUTH 1746
#define RPC_S_UNKNOWN_AUTHN_SERVICE 1747
#define RPC_S_UNKNOWN_AUTHN_LEVEL 1748
#define RPC_S_INVALID_AUTH_IDENTITY 1749
#define RPC_S_UNKNOWN_AUTHZ_SERVICE 1750
#define EPT_S_INVALID_ENTRY 1751
#define EPT_S_CANT_PERFORM_OP 1752
#define EPT_S_NOT_REGISTERED 1753
#define RPC_S_NOTHING_TO_EXPORT 1754
#define RPC_S_INCOMPLETE_NAME 1755
#define RPC_S_INVALID_VERS_OPTION 1756
#define RPC_S_NO_MORE_MEMBERS 1757
#define RPC_S_NOT_ALL_OBJS_UNEXPORTED 1758
#define RPC_S_INTERFACE_NOT_FOUND 1759
#define RPC_S_ENTRY_ALREADY_EXISTS 1760
#define RPC_S_ENTRY_NOT_FOUND 1761
#define RPC_S_NAME_SERVICE_UNAVAILABLE 1762
#define RPC_S_INVALID_NAF_ID 1763
#define RPC_S_CANNOT_SUPPORT 1764
#define RPC_S_NO_CONTEXT_AVAILABLE 1765
#define RPC_S_INTERNAL_ERROR 1766
#define RPC_S_ZERO_DIVIDE 1767
#define RPC_S_ADDRESS_ERROR 1768
#define RPC_S_FP_DIV_ZERO 1769
#define RPC_S_FP_UNDERFLOW 1770
#define RPC_S_FP_OVERFLOW 1771
#define RPC_X_NO_MORE_ENTRIES 1772
#define RPC_X_SS_CHAR_TRANS_OPEN_FAIL 1773
#define RPC_X_SS_CHAR_TRANS_SHORT_FILE 1774
#define RPC_X_SS_IN_NULL_CONTEXT 1775
#define RPC_X_SS_CONTEXT_DAMAGED 1777
#define RPC_X_SS_HANDLES_MISMATCH 1778
#define RPC_X_SS_CANNOT_GET_CALL_HANDLE 1779
#define RPC_X_NULL_REF_POINTER 1780
#define RPC_X_ENUM_VALUE_OUT_OF_RANGE 1781
#define RPC_X_BYTE_COUNT_TOO_SMALL 1782
#define RPC_X_BAD_STUB_DATA 1783
#define ERROR_INVALID_USER_BUFFER 1784
#define ERROR_UNRECOGNIZED_MEDIA 1785
#define ERROR_NO_TRUST_LSA_SECRET 1786
#define ERROR_NO_TRUST_SAM_ACCOUNT 1787
#define ERROR_TRUSTED_DOMAIN_FAILURE 1788
#define ERROR_TRUSTED_RELATIONSHIP_FAILURE 1789
#define ERROR_TRUST_FAILURE 1790
#define RPC_S_CALL_IN_PROGRESS 1791
#define ERROR_NETLOGON_NOT_STARTED 1792
#define ERROR_ACCOUNT_EXPIRED 1793
#define ERROR_REDIRECTOR_HAS_OPEN_HANDLES 1794
#define ERROR_PRINTER_DRIVER_ALREADY_INSTALLED 1795
#define ERROR_UNKNOWN_PORT 1796
#define ERROR_UNKNOWN_PRINTER_DRIVER 1797
#define ERROR_UNKNOWN_PRINTPROCESSOR 1798
#define ERROR_INVALID_SEPARATOR_FILE 1799
#define ERROR_INVALID_PRIORITY 1800
#define ERROR_INVALID_PRINTER_NAME 1801
#define ERROR_PRINTER_ALREADY_EXISTS 1802
#define ERROR_INVALID_PRINTER_COMMAND 1803
#define ERROR_INVALID_DATATYPE 1804
#define ERROR_INVALID_ENVIRONMENT 1805
#define RPC_S_NO_MORE_BINDINGS 1806
#define ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT 1807
#define ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT 1808
#define ERROR_NOLOGON_SERVER_TRUST_ACCOUNT 1809
#define ERROR_DOMAIN_TRUST_INCONSISTENT 1810
#define ERROR_SERVER_HAS_OPEN_HANDLES 1811
#define ERROR_RESOURCE_DATA_NOT_FOUND 1812
#define ERROR_RESOURCE_TYPE_NOT_FOUND 1813
#define ERROR_RESOURCE_NAME_NOT_FOUND 1814
#define ERROR_RESOURCE_LANG_NOT_FOUND 1815
#define ERROR_NOT_ENOUGH_QUOTA 1816
#define RPC_S_NO_INTERFACES 1817
#define RPC_S_CALL_CANCELLED 1818
#define RPC_S_BINDING_INCOMPLETE 1819
#define RPC_S_COMM_FAILURE 1820
#define RPC_S_UNSUPPORTED_AUTHN_LEVEL 1821
#define RPC_S_NO_PRINC_NAME 1822
#define RPC_S_NOT_RPC_ERROR 1823
#define RPC_S_UUID_LOCAL_ONLY 1824
#define RPC_S_SEC_PKG_ERROR 1825
#define RPC_S_NOT_CANCELLED 1826
#define RPC_X_INVALID_ES_ACTION 1827
#define RPC_X_WRONG_ES_VERSION 1828
#define RPC_X_WRONG_STUB_VERSION 1829
#define RPC_S_GROUP_MEMBER_NOT_FOUND 1898
#define EPT_S_CANT_CREATE 1899
#define RPC_S_INVALID_OBJECT 1900
#define ERROR_INVALID_TIME 1901
#define ERROR_INVALID_FORM_NAME 1902
#define ERROR_INVALID_FORM_SIZE 1903
#define ERROR_ALREADY_WAITING 1904
#define ERROR_PRINTER_DELETED 1905
#define ERROR_INVALID_PRINTER_STATE 1906
#define ERROR_PASSWORD_MUST_CHANGE 1907
#define ERROR_DOMAIN_CONTROLLER_NOT_FOUND 1908
#define ERROR_ACCOUNT_LOCKED_OUT 1909
#define ERROR_NO_BROWSER_SERVERS_FOUND 6118
#define ERROR_INVALID_PIXEL_FORMAT 2000
#define ERROR_BAD_DRIVER 2001
#define ERROR_INVALID_WINDOW_STYLE 2002
#define ERROR_METAFILE_NOT_SUPPORTED 2003
#define ERROR_TRANSFORM_NOT_SUPPORTED 2004
#define ERROR_CLIPPING_NOT_SUPPORTED 2005
#define ERROR_UNKNOWN_PRINT_MONITOR 3000
#define ERROR_PRINTER_DRIVER_IN_USE 3001
#define ERROR_SPOOL_FILE_NOT_FOUND 3002
#define ERROR_SPL_NO_STARTDOC 3003
#define ERROR_SPL_NO_ADDJOB 3004
#define ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED 3005
#define ERROR_PRINT_MONITOR_ALREADY_INSTALLED 3006
#define ERROR_INVALID_PRINT_MONITOR 3007
#define ERROR_PRINT_MONITOR_IN_USE 3008
#define ERROR_PRINTER_HAS_JOBS_QUEUED 3009
#define ERROR_SUCCESS_REBOOT_REQUIRED 3010
#define ERROR_SUCCESS_RESTART_REQUIRED 3011
#define ERROR_WINS_INTERNAL 4000
#define ERROR_CAN_NOT_DEL_LOCAL_WINS 4001
#define ERROR_STATIC_INIT 4002
#define ERROR_INC_BACKUP 4003
#define ERROR_FULL_BACKUP 4004
#define ERROR_REC_NON_EXISTENT 4005
#define ERROR_RPL_NOT_ALLOWED 4006
#define ERROR_NO_BROWSER_SERVERS_FOUND 6118
#define FAILED(S) ((HRESULT)((S)<0))
#define SUCCEEDED(Status) ((HRESULT)(Status) >= 0)
#define FACILITY_WINDOWS	8
#define FACILITY_STORAGE	3
#define FACILITY_SSPI	9
#define FACILITY_SCARD	16
#define FACILITY_SETUPAPI	15
#define FACILITY_RPC	1
#define FACILITY_WIN32	7
#define FACILITY_CONTROL	10
#define FACILITY_NULL	0
#define FACILITY_MSMQ	14
#define FACILITY_MEDIASERVER	13
#define FACILITY_INTERNET	12
#define FACILITY_ITF	4
#define FACILITY_DISPATCH	2
#define FACILITY_CERT	11
#define FACILITY_NT_BIT 0x10000000
#define S_OK	0
#define S_FALSE	1
#define HRESULT_FROM_NT(x)	((HRESULT) ((x)|FACILITY_NT_BIT))
#define HRESULT_FROM_WIN32(x) ((HRESULT)(x) <= 0 ? ((HRESULT)(x)):((HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000)))
#define HRESULT_SEVERITY(hr) (((hr) >> 31) & 1)
#define SCODE_CODE(s)	((s)&0xFFFF)
#define GetScode(h)	((SCODE)(h))
#define NOERROR	S_OK
#define IS_ERROR(Status) ((unsigned long)(Status) >> 31 == SEVERITY_ERROR)
#define UNREFERENCED_PARAMETER(a)
#define CDERR_DIALOGFAILURE 0xFFFF
#define CDERR_GENERALCODES 0
#define CDERR_STRUCTSIZE 1
#define CDERR_INITIALIZATION 2
#define CDERR_NOTEMPLATE 3
#define CDERR_NOHINSTANCE 4
#define CDERR_LOADSTRFAILURE 5
#define CDERR_FINDRESFAILURE 6
#define CDERR_LOADRESFAILURE 7
#define CDERR_LOCKRESFAILURE 8
#define CDERR_MEMALLOCFAILURE 9
#define CDERR_MEMLOCKFAILURE 10
#define CDERR_NOHOOK 0xB
#define CDERR_REGISTERMSGFAIL 0xC
#define PDERR_PRINTERCODES 0x1000
#define PDERR_SETUPFAILURE 0x1001
#define PDERR_PARSEFAILURE 0x1002
#define PDERR_RETDEFFAILURE 0x1003
#define PDERR_LOADDRVFAILURE 0x1004
#define PDERR_GETDEVMODEFAIL 0x1005
#define PDERR_INITFAILURE 0x1006
#define PDERR_NODEVICES 0x1007
#define PDERR_NODEFAULTPRN 0x1008
#define PDERR_DNDMMISMATCH 0x1009
#define PDERR_CREATEICFAILURE 0x100A
#define PDERR_PRINTERNOTFOUND 0x100B
#define PDERR_DEFAULTDIFFERENT 0x100C
#define CFERR_CHOOSEFONTCODES 0x2000
#define CFERR_NOFONTS 0x2001
#define CFERR_MAXLESSTHANMIN 0x2002
#define FNERR_FILENAMECODES 0x3000
#define FNERR_SUBCLASSFAILURE 0x3001
#define FNERR_INVALIDFILENAME 0x3002
#define FNERR_BUFFERTOOSMALL 0x3003
#define FRERR_FINDREPLACECODES 0x4000
#define FRERR_BUFFERLENGTHZERO 0x4001
#define CCERR_CHOOSECOLORCODES 0x5000
#define	TYPE_E_BUFFERTOOSMALL	0x80028016
#define	TYPE_E_INVDATAREAD	0x80028018
#define	TYPE_E_UNSUPFORMAT	0x80028019
#define	TYPE_E_REGISTRYACCESS	0x8002801C
#define	TYPE_E_LIBNOTREGISTERED	0x8002801D
#define	TYPE_E_UNDEFINEDTYPE	0x80028027
#define	TYPE_E_QUALIFIEDNAMEDISALLOWED	0x80028028
#define	TYPE_E_INVALIDSTATE	0x80028029
#define	TYPE_E_WRONGTYPEKIND	0x8002802A
#define	TYPE_E_ELEMENTNOTFOUND	0x8002802B
#define	TYPE_E_AMBIGUOUSNAME	0x8002802C
#define	TYPE_E_NAMECONFLICT	0x8002802D
#define	TYPE_E_UNKNOWNLCID	0x8002802E
#define	TYPE_E_DLLFUNCTIONNOTFOUND	0x8002802F
#define	TYPE_E_BADMODULEKIND	0x800288BD
#define	TYPE_E_SIZETOOBIG	0x800288C5
#define	TYPE_E_DUPLICATEID	0x800288C6
#define	TYPE_E_INVALIDID	0x800288CF
#define	TYPE_E_TYPEMISMATCH	0x80028CA0
#define	TYPE_E_OUTOFBOUNDS	0x80028CA1
#define	TYPE_E_IOERROR	0x80028CA2
#define	TYPE_E_CANTCREATETMPFILE	0x80028CA3
#define	TYPE_E_CANTLOADLIBRARY	0x80029C4A
#define	TYPE_E_INCONSISTENTPROPFUNCS	0x80029C83
#define	TYPE_E_CIRCULARTYPE	0x80029C84
#define REGDB_E_FIRST	0x80040150
#define REGDB_E_LAST	0x8004015F
#define REGDB_S_FIRST	0x40150
#define REGDB_S_LAST	0x4015F
#define REGDB_E_READREGDB	_HRESULT_TYPEDEF_(0x80040150)
#define REGDB_E_WRITEREGDB	_HRESULT_TYPEDEF_(0x80040151)
#define REGDB_E_KEYMISSING	_HRESULT_TYPEDEF_(0x80040152)
#define REGDB_E_INVALIDVALUE	_HRESULT_TYPEDEF_(0x80040153)
#define REGDB_E_CLASSNOTREG	_HRESULT_TYPEDEF_(0x80040154)
#define REGDB_E_IIDNOTREG	_HRESULT_TYPEDEF_(0x80040155)
#define OLE_E_FIRST ((HRESULT)0x80040000)
#define OLE_E_LAST ((HRESULT)0x800400FF)
#define OLE_S_FIRST ((HRESULT)0x40000)
#define OLE_S_LAST ((HRESULT)0x400FF)
#define OLE_E_OLEVERB _HRESULT_TYPEDEF_(0x80040000)
#define OLE_E_ADVF _HRESULT_TYPEDEF_(0x80040001)
#define OLE_E_ENUM_NOMORE _HRESULT_TYPEDEF_(0x80040002)
#define OLE_E_ADVISENOTSUPPORTED _HRESULT_TYPEDEF_(0x80040003)
#define OLE_E_NOCONNECTION _HRESULT_TYPEDEF_(0x80040004)
#define OLE_E_NOTRUNNING _HRESULT_TYPEDEF_(0x80040005)
#define OLE_E_NOCACHE _HRESULT_TYPEDEF_(0x80040006)
#define OLE_E_BLANK _HRESULT_TYPEDEF_(0x80040007)
#define OLE_E_CLASSDIFF _HRESULT_TYPEDEF_(0x80040008)
#define OLE_E_CANT_GETMONIKER _HRESULT_TYPEDEF_(0x80040009)
#define OLE_E_CANT_BINDTOSOURCE _HRESULT_TYPEDEF_(0x8004000A)
#define OLE_E_STATIC _HRESULT_TYPEDEF_(0x8004000B)
#define OLE_E_PROMPTSAVECANCELLED _HRESULT_TYPEDEF_(0x8004000C)
#define OLE_E_INVALIDRECT _HRESULT_TYPEDEF_(0x8004000D)
#define OLE_E_WRONGCOMPOBJ _HRESULT_TYPEDEF_(0x8004000E)
#define OLE_E_INVALIDHWND _HRESULT_TYPEDEF_(0x8004000F)
#define OLE_E_NOT_INPLACEACTIVE _HRESULT_TYPEDEF_(0x80040010)
#define OLE_E_CANTCONVERT _HRESULT_TYPEDEF_(0x80040011)
#define OLE_E_NOSTORAGE _HRESULT_TYPEDEF_(0x80040012)
#define DV_E_FORMATETC _HRESULT_TYPEDEF_(0x80040064)
#define DV_E_DVTARGETDEVICE _HRESULT_TYPEDEF_(0x80040065)
#define DV_E_STGMEDIUM _HRESULT_TYPEDEF_(0x80040066)
#define DV_E_STATDATA _HRESULT_TYPEDEF_(0x80040067)
#define DV_E_LINDEX _HRESULT_TYPEDEF_(0x80040068)
#define DV_E_TYMED _HRESULT_TYPEDEF_(0x80040069)
#define DV_E_CLIPFORMAT _HRESULT_TYPEDEF_(0x8004006A)
#define DV_E_DVASPECT _HRESULT_TYPEDEF_(0x8004006B)
#define DV_E_DVTARGETDEVICE_SIZE _HRESULT_TYPEDEF_(0x8004006C)
#define DV_E_NOIVIEWOBJECT _HRESULT_TYPEDEF_(0x8004006D)
#define DRAGDROP_E_FIRST 0x80040100
#define DRAGDROP_E_LAST 0x8004010F
#define DRAGDROP_S_FIRST 0x40100
#define DRAGDROP_S_LAST 0x4010F
#define DRAGDROP_E_NOTREGISTERED _HRESULT_TYPEDEF_(0x80040100)
#define DRAGDROP_E_ALREADYREGISTERED _HRESULT_TYPEDEF_(0x80040101)
#define DRAGDROP_E_INVALIDHWND _HRESULT_TYPEDEF_(0x80040102)
#define CLASSFACTORY_E_FIRST 0x80040110
#define CLASSFACTORY_E_LAST 0x8004011F
#define CLASSFACTORY_S_FIRST 0x40110
#define CLASSFACTORY_S_LAST 0x4011F
#define CLASS_E_NOAGGREGATION _HRESULT_TYPEDEF_(0x80040110)
#define CLASS_E_CLASSNOTAVAILABLE _HRESULT_TYPEDEF_(0x80040111)
#define CLASS_E_NOTLICENSED _HRESULT_TYPEDEF_(0x80040112)
#define MARSHAL_E_FIRST 0x80040120
#define MARSHAL_E_LAST 0x8004012F
#define MARSHAL_S_FIRST 0x40120
#define MARSHAL_S_LAST 0x4012F
#define DATA_E_FIRST 0x80040130
#define DATA_E_LAST 0x8004013F
#define DATA_S_FIRST 0x40130
#define DATA_S_LAST 0x4013F
#define VIEW_E_FIRST 0x80040140
#define VIEW_E_LAST 0x8004014F
#define VIEW_S_FIRST 0x40140
#define VIEW_S_LAST 0x4014F
#define VIEW_E_DRAW _HRESULT_TYPEDEF_(0x80040140)
#define REGDB_E_FIRST 0x80040150
#define REGDB_E_LAST 0x8004015F
#define REGDB_S_FIRST 0x40150
#define REGDB_S_LAST 0x4015F
#define REGDB_E_READREGDB _HRESULT_TYPEDEF_(0x80040150)
#define REGDB_E_WRITEREGDB _HRESULT_TYPEDEF_(0x80040151)
#define REGDB_E_KEYMISSING _HRESULT_TYPEDEF_(0x80040152)
#define REGDB_E_INVALIDVALUE _HRESULT_TYPEDEF_(0x80040153)
#define REGDB_E_CLASSNOTREG _HRESULT_TYPEDEF_(0x80040154)
#define REGDB_E_IIDNOTREG _HRESULT_TYPEDEF_(0x80040155)
#define CAT_E_FIRST 0x80040160
#define CAT_E_LAST 0x80040161
#define CAT_E_CATIDNOEXIST _HRESULT_TYPEDEF_(0x80040160)
#define CAT_E_NODESCRIPTION _HRESULT_TYPEDEF_(0x80040161)
#define CS_E_FIRST 0x80040164
#define CS_E_LAST 0x8004016F
#define CS_E_PACKAGE_NOTFOUND _HRESULT_TYPEDEF_(0x80040164)
#define CS_E_NOT_DELETABLE _HRESULT_TYPEDEF_(0x80040165)
#define CS_E_CLASS_NOTFOUND _HRESULT_TYPEDEF_(0x80040166)
#define CS_E_INVALID_VERSION _HRESULT_TYPEDEF_(0x80040167)
#define CS_E_NO_CLASSSTORE _HRESULT_TYPEDEF_(0x80040168)
#define CS_E_OBJECT_NOTFOUND _HRESULT_TYPEDEF_(0x80040169)
#define CS_E_OBJECT_ALREADY_EXISTS _HRESULT_TYPEDEF_(0x8004016A)
#define CS_E_INVALID_PATH _HRESULT_TYPEDEF_(0x8004016B)
#define CS_E_NETWORK_ERROR _HRESULT_TYPEDEF_(0x8004016C)
#define CS_E_ADMIN_LIMIT_EXCEEDED _HRESULT_TYPEDEF_(0x8004016D)
#define CS_E_SCHEMA_MISMATCH _HRESULT_TYPEDEF_(0x8004016E)
#define CS_E_INTERNAL_ERROR _HRESULT_TYPEDEF_(0x8004016F)
#define CACHE_E_FIRST 0x80040170
#define CACHE_E_LAST 0x8004017F
#define CACHE_S_FIRST 0x40170
#define CACHE_S_LAST 0x4017F
#define CACHE_E_NOCACHE_UPDATED _HRESULT_TYPEDEF_(0x80040170)
#define OLEOBJ_E_FIRST 0x80040180
#define OLEOBJ_E_LAST 0x8004018F
#define OLEOBJ_S_FIRST 0x40180
#define OLEOBJ_S_LAST 0x4018F
#define OLEOBJ_E_NOVERBS _HRESULT_TYPEDEF_(0x80040180)
#define OLEOBJ_E_INVALIDVERB _HRESULT_TYPEDEF_(0x80040181)
#define CLIENTSITE_E_FIRST 0x80040190
#define CLIENTSITE_E_LAST 0x8004019F
#define CLIENTSITE_S_FIRST 0x40190
#define CLIENTSITE_S_LAST 0x4019F
#define INPLACE_E_NOTUNDOABLE _HRESULT_TYPEDEF_(0x800401A0)
#define INPLACE_E_NOTOOLSPACE _HRESULT_TYPEDEF_(0x800401A1)
#define INPLACE_E_FIRST 0x800401A0
#define INPLACE_E_LAST 0x800401AF
#define INPLACE_S_FIRST 0x401A0
#define INPLACE_S_LAST 0x401AF
#define ENUM_E_FIRST 0x800401B0
#define ENUM_E_LAST 0x800401BF
#define ENUM_S_FIRST 0x401B0
#define ENUM_S_LAST 0x401BF
#define CONVERT10_E_FIRST 0x800401C0
#define CONVERT10_E_LAST 0x800401CF
#define CONVERT10_S_FIRST 0x401C0
#define CONVERT10_S_LAST 0x401CF
#define CONVERT10_E_OLESTREAM_GET _HRESULT_TYPEDEF_(0x800401C0)
#define CONVERT10_E_OLESTREAM_PUT _HRESULT_TYPEDEF_(0x800401C1)
#define CONVERT10_E_OLESTREAM_FMT _HRESULT_TYPEDEF_(0x800401C2)
#define CONVERT10_E_OLESTREAM_BITMAP_TO_DIB _HRESULT_TYPEDEF_(0x800401C3)
#define CONVERT10_E_STG_FMT _HRESULT_TYPEDEF_(0x800401C4)
#define CONVERT10_E_STG_NO_STD_STREAM _HRESULT_TYPEDEF_(0x800401C5)
#define CONVERT10_E_STG_DIB_TO_BITMAP _HRESULT_TYPEDEF_(0x800401C6)
#define CLIPBRD_E_FIRST 0x800401D0
#define CLIPBRD_E_LAST 0x800401DF
#define CLIPBRD_S_FIRST 0x401D0
#define CLIPBRD_S_LAST 0x401DF
#define CLIPBRD_E_CANT_OPEN _HRESULT_TYPEDEF_(0x800401D0)
#define CLIPBRD_E_CANT_EMPTY _HRESULT_TYPEDEF_(0x800401D1)
#define CLIPBRD_E_CANT_SET _HRESULT_TYPEDEF_(0x800401D2)
#define CLIPBRD_E_BAD_DATA _HRESULT_TYPEDEF_(0x800401D3)
#define CLIPBRD_E_CANT_CLOSE _HRESULT_TYPEDEF_(0x800401D4)
#define MK_E_FIRST 0x800401E0
#define MK_E_LAST 0x800401EF
#define MK_S_FIRST 0x401E0
#define MK_S_LAST 0x401EF
#define MK_E_CONNECTMANUALLY _HRESULT_TYPEDEF_(0x800401E0)
#define MK_E_EXCEEDEDDEADLINE _HRESULT_TYPEDEF_(0x800401E1)
#define MK_E_NEEDGENERIC _HRESULT_TYPEDEF_(0x800401E2)
#define MK_E_UNAVAILABLE _HRESULT_TYPEDEF_(0x800401E3)
#define MK_E_SYNTAX _HRESULT_TYPEDEF_(0x800401E4)
#define MK_E_NOOBJECT _HRESULT_TYPEDEF_(0x800401E5)
#define MK_E_INVALIDEXTENSION _HRESULT_TYPEDEF_(0x800401E6)
#define MK_E_INTERMEDIATEINTERFACENOTSUPPORTED _HRESULT_TYPEDEF_(0x800401E7)
#define MK_E_NOTBINDABLE _HRESULT_TYPEDEF_(0x800401E8)
#define MK_E_NOTBOUND _HRESULT_TYPEDEF_(0x800401E9)
#define MK_E_CANTOPENFILE _HRESULT_TYPEDEF_(0x800401EA)
#define MK_E_MUSTBOTHERUSER _HRESULT_TYPEDEF_(0x800401EB)
#define MK_E_NOINVERSE _HRESULT_TYPEDEF_(0x800401EC)
#define MK_E_NOSTORAGE _HRESULT_TYPEDEF_(0x800401ED)
#define MK_E_NOPREFIX _HRESULT_TYPEDEF_(0x800401EE)
#define MK_E_ENUMERATION_FAILED _HRESULT_TYPEDEF_(0x800401EF)
#define CO_E_FIRST 0x800401F0
#define CO_E_LAST 0x800401FF
#define CO_S_FIRST 0x401F0
#define CO_S_LAST 0x401FF
#define CO_E_NOTINITIALIZED _HRESULT_TYPEDEF_(0x800401F0)
#define CO_E_ALREADYINITIALIZED _HRESULT_TYPEDEF_(0x800401F1)
#define CO_E_CANTDETERMINECLASS _HRESULT_TYPEDEF_(0x800401F2)
#define CO_E_CLASSSTRING _HRESULT_TYPEDEF_(0x800401F3)
#define CO_E_IIDSTRING _HRESULT_TYPEDEF_(0x800401F4)
#define CO_E_APPNOTFOUND _HRESULT_TYPEDEF_(0x800401F5)
#define CO_E_APPSINGLEUSE _HRESULT_TYPEDEF_(0x800401F6)
#define CO_E_ERRORINAPP _HRESULT_TYPEDEF_(0x800401F7)
#define CO_E_DLLNOTFOUND _HRESULT_TYPEDEF_(0x800401F8)
#define CO_E_ERRORINDLL _HRESULT_TYPEDEF_(0x800401F9)
#define CO_E_WRONGOSFORAPP _HRESULT_TYPEDEF_(0x800401FA)
#define CO_E_OBJNOTREG _HRESULT_TYPEDEF_(0x800401FB)
#define CO_E_OBJISREG _HRESULT_TYPEDEF_(0x800401FC)
#define CO_E_OBJNOTCONNECTED _HRESULT_TYPEDEF_(0x800401FD)
#define CO_E_APPDIDNTREG _HRESULT_TYPEDEF_(0x800401FE)
#define CO_E_RELEASED _HRESULT_TYPEDEF_(0x800401FF)
#define OLE_S_USEREG _HRESULT_TYPEDEF_(0x40000)
#define OLE_S_STATIC _HRESULT_TYPEDEF_(0x40001)
#define OLE_S_MAC_CLIPFORMAT _HRESULT_TYPEDEF_(0x40002)
#define DRAGDROP_S_DROP _HRESULT_TYPEDEF_(0x40100)
#define DRAGDROP_S_CANCEL _HRESULT_TYPEDEF_(0x40101)
#define DRAGDROP_S_USEDEFAULTCURSORS _HRESULT_TYPEDEF_(0x40102)
#define DATA_S_SAMEFORMATETC _HRESULT_TYPEDEF_(0x40130)
#define VIEW_S_ALREADY_FROZEN _HRESULT_TYPEDEF_(0x40140)
#define CACHE_S_FORMATETC_NOTSUPPORTED _HRESULT_TYPEDEF_(0x40170)
#define CACHE_S_SAMECACHE _HRESULT_TYPEDEF_(0x40171)
#define CACHE_S_SOMECACHES_NOTUPDATED _HRESULT_TYPEDEF_(0x40172)
#define OLEOBJ_S_INVALIDVERB _HRESULT_TYPEDEF_(0x40180)
#define OLEOBJ_S_CANNOT_DOVERB_NOW _HRESULT_TYPEDEF_(0x40181)
#define OLEOBJ_S_INVALIDHWND _HRESULT_TYPEDEF_(0x40182)
#define INPLACE_S_TRUNCATED _HRESULT_TYPEDEF_(0x401A0)
#define CONVERT10_S_NO_PRESENTATION _HRESULT_TYPEDEF_(0x401C0)
#define MK_S_REDUCED_TO_SELF _HRESULT_TYPEDEF_(0x401E2)
#define MK_S_ME _HRESULT_TYPEDEF_(0x401E4)
#define MK_S_HIM _HRESULT_TYPEDEF_(0x401E5)
#define MK_S_US _HRESULT_TYPEDEF_(0x401E6)
#define MK_S_MONIKERALREADYREGISTERED _HRESULT_TYPEDEF_(0x401E7)
#define CO_E_CLASS_CREATE_FAILED _HRESULT_TYPEDEF_(0x80080001)
#define CO_E_SCM_ERROR _HRESULT_TYPEDEF_(0x80080002)
#define CO_E_SCM_RPC_FAILURE _HRESULT_TYPEDEF_(0x80080003)
#define CO_E_BAD_PATH _HRESULT_TYPEDEF_(0x80080004)
#define CO_E_SERVER_EXEC_FAILURE _HRESULT_TYPEDEF_(0x80080005)
#define CO_E_OBJSRV_RPC_FAILURE _HRESULT_TYPEDEF_(0x80080006)
#define MK_E_NO_NORMALIZED _HRESULT_TYPEDEF_(0x80080007)
#define CO_E_SERVER_STOPPING _HRESULT_TYPEDEF_(0x80080008)
#define MEM_E_INVALID_ROOT _HRESULT_TYPEDEF_(0x80080009)
#define MEM_E_INVALID_LINK _HRESULT_TYPEDEF_(0x80080010)
#define MEM_E_INVALID_SIZE _HRESULT_TYPEDEF_(0x80080011)
#define CO_S_NOTALLINTERFACES _HRESULT_TYPEDEF_(0x80012)
#define DIGSIG_E_ENCODE	_HRESULT_TYPEDEF_(0x800B0005)
#define DIGSIG_E_DECODE	_HRESULT_TYPEDEF_(0x800B0006)
#define DIGSIG_E_EXTENSIBILITY	_HRESULT_TYPEDEF_(0x800B0007)
#define DIGSIG_E_CRYPTO	_HRESULT_TYPEDEF_(0x800B0008)
#define PERSIST_E_SIZEDEFINITE	_HRESULT_TYPEDEF_(0x800B0009)
#define PERSIST_E_SIZEINDEFINITE	_HRESULT_TYPEDEF_(0x800B000A)
#define PERSIST_E_NOTSELFSIZING	_HRESULT_TYPEDEF_(0x800B000B)
#define DISP_E_UNKNOWNINTERFACE _HRESULT_TYPEDEF_(0x80020001)
#define DISP_E_MEMBERNOTFOUND _HRESULT_TYPEDEF_(0x80020003)
#define DISP_E_PARAMNOTFOUND _HRESULT_TYPEDEF_(0x80020004)
#define DISP_E_TYPEMISMATCH _HRESULT_TYPEDEF_(0x80020005)
#define DISP_E_UNKNOWNNAME _HRESULT_TYPEDEF_(0x80020006)
#define DISP_E_NONAMEDARGS _HRESULT_TYPEDEF_(0x80020007)
#define DISP_E_BADVARTYPE _HRESULT_TYPEDEF_(0x80020008)
#define DISP_E_EXCEPTION _HRESULT_TYPEDEF_(0x80020009)
#define DISP_E_OVERFLOW _HRESULT_TYPEDEF_(0x8002000A)
#define DISP_E_BADINDEX _HRESULT_TYPEDEF_(0x8002000B)
#define DISP_E_UNKNOWNLCID _HRESULT_TYPEDEF_(0x8002000C)
#define DISP_E_ARRAYISLOCKED _HRESULT_TYPEDEF_(0x8002000D)
#define DISP_E_BADPARAMCOUNT _HRESULT_TYPEDEF_(0x8002000E)
#define DISP_E_PARAMNOTOPTIONAL _HRESULT_TYPEDEF_(0x8002000F)
#define DISP_E_BADCALLEE _HRESULT_TYPEDEF_(0x80020010)
#define DISP_E_NOTACOLLECTION _HRESULT_TYPEDEF_(0x80020011)
#define DISP_E_DIVBYZERO _HRESULT_TYPEDEF_(0x80020012)
#define DISP_E_BUFFERTOOSMALL _HRESULT_TYPEDEF_(0x80020013)
#define STG_E_INVALIDFUNCTION _HRESULT_TYPEDEF_(0x80030001)
#define STG_E_FILENOTFOUND _HRESULT_TYPEDEF_(0x80030002)
#define STG_E_PATHNOTFOUND _HRESULT_TYPEDEF_(0x80030003)
#define STG_E_TOOMANYOPENFILES _HRESULT_TYPEDEF_(0x80030004)
#define STG_E_ACCESSDENIED _HRESULT_TYPEDEF_(0x80030005)
#define STG_E_INVALIDHANDLE _HRESULT_TYPEDEF_(0x80030006)
#define STG_E_INSUFFICIENTMEMORY _HRESULT_TYPEDEF_(0x80030008)
#define STG_E_INVALIDPOINTER _HRESULT_TYPEDEF_(0x80030009)
#define STG_E_NOMOREFILES _HRESULT_TYPEDEF_(0x80030012)
#define STG_E_DISKISWRITEPROTECTED _HRESULT_TYPEDEF_(0x80030013)
#define STG_E_SEEKERROR _HRESULT_TYPEDEF_(0x80030019)
#define STG_E_WRITEFAULT _HRESULT_TYPEDEF_(0x8003001D)
#define STG_E_READFAULT _HRESULT_TYPEDEF_(0x8003001E)
#define STG_E_SHAREVIOLATION _HRESULT_TYPEDEF_(0x80030020)
#define STG_E_LOCKVIOLATION _HRESULT_TYPEDEF_(0x80030021)
#define STG_E_FILEALREADYEXISTS _HRESULT_TYPEDEF_(0x80030050)
#define STG_E_INVALIDPARAMETER _HRESULT_TYPEDEF_(0x80030057)
#define STG_E_MEDIUMFULL _HRESULT_TYPEDEF_(0x80030070)
#define STG_E_PROPSETMISMATCHED _HRESULT_TYPEDEF_(0x800300F0)
#define STG_E_ABNORMALAPIEXIT _HRESULT_TYPEDEF_(0x800300FA)
#define STG_E_INVALIDHEADER _HRESULT_TYPEDEF_(0x800300FB)
#define STG_E_INVALIDNAME _HRESULT_TYPEDEF_(0x800300FC)
#define STG_E_UNKNOWN _HRESULT_TYPEDEF_(0x800300FD)
#define STG_E_UNIMPLEMENTEDFUNCTION _HRESULT_TYPEDEF_(0x800300FE)
#define STG_E_INVALIDFLAG _HRESULT_TYPEDEF_(0x800300FF)
#define STG_E_INUSE _HRESULT_TYPEDEF_(0x80030100)
#define STG_E_NOTCURRENT _HRESULT_TYPEDEF_(0x80030101)
#define STG_E_REVERTED _HRESULT_TYPEDEF_(0x80030102)
#define STG_E_CANTSAVE _HRESULT_TYPEDEF_(0x80030103)
#define STG_E_OLDFORMAT _HRESULT_TYPEDEF_(0x80030104)
#define STG_E_OLDDLL _HRESULT_TYPEDEF_(0x80030105)
#define STG_E_SHAREREQUIRED _HRESULT_TYPEDEF_(0x80030106)
#define STG_E_NOTFILEBASEDSTORAGE _HRESULT_TYPEDEF_(0x80030107)
#define STG_E_EXTANTMARSHALLINGS _HRESULT_TYPEDEF_(0x80030108)
#define STG_E_DOCFILETOOLARGE _HRESULT_TYPEDEF_(0x80030111)
#define STG_E_NOTSIMPLEFORMAT _HRESULT_TYPEDEF_(0x80030112)
#define STG_E_INCOMPLETE _HRESULT_TYPEDEF_(0x80030201)
#define STG_E_TERMINATED _HRESULT_TYPEDEF_(0x80030202)
#define STG_E_DOCFILECORRUPT _HRESULT_TYPEDEF_(0x80030109)
#define STG_E_BADBASEADDRESS _HRESULT_TYPEDEF_(0x80030110)
#define STG_S_CONVERTED _HRESULT_TYPEDEF_(0x30200)
#define STG_S_BLOCK _HRESULT_TYPEDEF_(0x30201)
#define STG_S_RETRYNOW _HRESULT_TYPEDEF_(0x30202)
#define STG_S_MONITORING _HRESULT_TYPEDEF_(0x30203)
#define STG_S_MULTIPLEOPENS _HRESULT_TYPEDEF_(0x30204)
#define STG_S_CONSOLIDATIONFAILED _HRESULT_TYPEDEF_(0x30205)
#define STG_S_CANNOTCONSOLIDATE _HRESULT_TYPEDEF_(0x30206)
#define SCHED_E_SERVICE_NOT_LOCALSYSTEM	6200
#define SCHED_E_TRIGGER_NOT_FOUND	_HRESULT_TYPEDEF_(0x80041309L)
#define SCHED_E_TASK_NOT_READY		_HRESULT_TYPEDEF_(0x8004130AL)
#define SCHED_E_TASK_NOT_RUNNING	_HRESULT_TYPEDEF_(0x8004130BL)
#define SCHED_E_SERVICE_NOT_INSTALLED	_HRESULT_TYPEDEF_(0x8004130CL)
#define SCHED_E_CANNOT_OPEN_TASK	_HRESULT_TYPEDEF_(0x8004130DL)
#define SCHED_E_INVALID_TASK		_HRESULT_TYPEDEF_(0x8004130EL)
#define SCHED_E_ACCOUNT_INFORMATION_NOT_SET _HRESULT_TYPEDEF_(0x8004130FL)
#define SCHED_E_ACCOUNT_NAME_NOT_FOUND	_HRESULT_TYPEDEF_(0x80041310L)
#define SCHED_E_ACCOUNT_DBASE_CORRUPT	_HRESULT_TYPEDEF_(0x80041311L)
#define SCHED_E_NO_SECURITY_SERVICES	_HRESULT_TYPEDEF_(0x80041312L)
#define SCHED_E_UNKNOWN_OBJECT_VERSION	_HRESULT_TYPEDEF_(0x80041313L)
#define SCHED_E_UNSUPPORTED_ACCOUNT_OPTION _HRESULT_TYPEDEF_(0x80041314L)
#define SCHED_E_SERVICE_NOT_RUNNING	_HRESULT_TYPEDEF_(0x80041315L)
#define CERT_E_EXPIRED _HRESULT_TYPEDEF_(0x800B0101)
#define CERT_E_VALIDITYPERIODNESTING _HRESULT_TYPEDEF_(0x800B0102)
#define CERT_E_ROLE _HRESULT_TYPEDEF_(0x800B0103)
#define CERT_E_PATHLENCONST _HRESULT_TYPEDEF_(0x800B0104)
#define CERT_E_CRITICAL _HRESULT_TYPEDEF_(0x800B0105)
#define CERT_E_PURPOSE _HRESULT_TYPEDEF_(0x800B0106)
#define CERT_E_ISSUERCHAINING _HRESULT_TYPEDEF_(0x800B0107)
#define CERT_E_MALFORMED _HRESULT_TYPEDEF_(0x800B0108)
#define CERT_E_UNTRUSTEDROOT _HRESULT_TYPEDEF_(0x800B0109)
#define CERT_E_CHAINING _HRESULT_TYPEDEF_(0x800B010A)
#define CERT_E_REVOKED _HRESULT_TYPEDEF_(0x800B010C)
#define CERT_E_UNTRUSTEDTESTROOT _HRESULT_TYPEDEF_(0x800B010D)
#define CERT_E_REVOCATION_FAILURE _HRESULT_TYPEDEF_(0x800B010E)
#define CERT_E_CN_NO_MATCH _HRESULT_TYPEDEF_(0x800B010F)
#define CERT_E_WRONG_USAGE _HRESULT_TYPEDEF_(0x800B0110)
#define SEVERITY_ERROR 1
#define OR_INVALID_OXID	1910
#define OR_INVALID_OID	1911
#define OR_INVALID_SET	1912
#define MAKE_SCODE(sev,fac,code) ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )
#define HRESULT_FACILITY(hr) (((hr) >> 16) & 0x1fff)
#define HRESULT_CODE(hr) (hr&0xFFFF)
#define EXTERN_C extern
#define ResultFromScode(sc) ((HRESULT) (sc))
#define UNALIGNED
#define WHEEL_DELTA 120

enum VARENUM { VT_EMPTY=0,VT_NULL=1, VT_I2=2, VT_I4=3, VT_R4=4, VT_R8=5,
 VT_CY=6,VT_DATE=7, VT_BSTR=8, VT_DISPATCH=9, VT_ERROR=10, VT_BOOL=11,
 VT_VARIANT=12,VT_UNKNOWN=13, VT_DECIMAL=14, VT_I1=16, VT_UI1=17,
 VT_UI2=18,VT_UI4=19, VT_I8=20, VT_UI8=21, VT_INT=22, VT_UINT=23,
 VT_VOID=24,VT_HRESULT=25, VT_PTR=26, VT_SAFEARRAY=27, VT_CARRAY=28,
 VT_USERDEFINED=29,VT_LPSTR=30, VT_LPWSTR=31, VT_RECORD=36, VT_FILETIME=64,
 VT_BLOB=65,VT_STREAM=66, VT_STORAGE=67, VT_STREAMED_OBJECT=68, VT_STORED_OBJECT=69,
 VT_BLOB_OBJECT=70,VT_CF=71, VT_CLSID=72, VT_VERSIONED_STREAM=73, VT_BSTR_BLOB=0xfff,
 VT_VECTOR=0x1000,VT_ARRAY=0x2000, VT_BYREF=0x4000, VT_RESERVED=0x8000,
 VT_ILLEGAL=0xffff,VT_ILLEGALMASKED=0xfff, VT_TYPEMASK=0xfff
};

//#ifndef _VARIANT_BOOL_DEFINED
//typedef short VARIANT_BOOL;
//typedef short _VARIANT_BOOL;
//#define _VARIANT_BOOL_DEFINED
//#endif

#define VARIANT_TRUE ((VARIANT_BOOL)-1)
#define VARIANT_FALSE ((VARIANT_BOOL)0)

BOOL GdiGradientFill(
  HDC        hdc,
  PTRIVERTEX pVertex,
  ULONG      nVertex,
  PVOID      pMesh,
  ULONG      nCount,
  ULONG      ulMode
);

#endif
=== windowsx.h 0 0 99/108 ===
/* Header windowsx.h */

#ifndef $windowsx
#define $windowsx 1

#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))
#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))

#endif // windowsx

=== winsock2.h 0 0 100/108 ===
#ifndef _WINSOCK2_H
#define _WINSOCK2_H

#include <_mingw.h>
#include <windows.h>

#ifndef FD_SETSIZE
#define FD_SETSIZE 64
#endif

typedef unsigned int SOCKET;

typedef struct fd_set {
  unsigned int   fd_count;
  SOCKET  fd_array[FD_SETSIZE];
} fd_set;

extern int __stdcall __WSAFDIsSet(SOCKET,fd_set *);

#ifndef FD_CLR
#define FD_CLR(fd,set) do { unsigned int __i;\
for (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {\
    if (((fd_set *)(set))->fd_array[__i] == (fd)) {\
    while (__i < ((fd_set *)(set))->fd_count-1) {\
        ((fd_set*)(set))->fd_array[__i] = ((fd_set*)(set))->fd_array[__i+1];\
        __i++;\
    }\
    ((fd_set*)(set))->fd_count--;\
    break;\
    }\
}\
} while (0)
#endif

#ifndef FD_SET
/* this differs from the define in winsock.h and in cygwin sys/types.h */
#define FD_SET(fd, set) do { unsigned int __i;\
for (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {\
    if (((fd_set *)(set))->fd_array[__i] == (fd)) {\
        break;\
    }\
}\
if (__i == ((fd_set *)(set))->fd_count) {\
    if (((fd_set *)(set))->fd_count < FD_SETSIZE) {\
        ((fd_set *)(set))->fd_array[__i] = (fd);\
        ((fd_set *)(set))->fd_count++;\
    }\
}\
} while(0)
#endif

#ifndef FD_ZERO
#define FD_ZERO(set) (((fd_set *)(set))->fd_count=0)
#endif

#ifndef FD_ISSET
#define FD_ISSET(fd, set) __WSAFDIsSet((SOCKET)(fd), (fd_set *)(set))
#endif

#ifndef _TIMEVAL_DEFINED /* also in sys/time.h */
#define _TIMEVAL_DEFINED
struct timeval {
    long tv_sec;
    long tv_usec;
};
#endif

struct in_addr {
    union {
        struct { unsigned char s_b1,s_b2,s_b3,s_b4; } S_un_b;
        struct { unsigned short s_w1,s_w2; } S_un_w;
        unsigned long S_addr;
    } S_un;
};
#define s_addr  S_un.S_addr

struct sockaddr_in {
    short sin_family;
    unsigned short sin_port;
    struct in_addr sin_addr;
    char sin_zero[8];
};

struct sockaddr {
    unsigned short sa_family;
    char sa_data[14];
};

struct hostent {
    char *h_name;
    char **h_aliases;
    short h_addrtype;
    short h_length;
    char **h_addr_list;
};
#define h_addr h_addr_list[0]

#define WSADESCRIPTION_LEN  256
#define WSASYS_STATUS_LEN   128
typedef struct WSAData {
    WORD wVersion;
    WORD wHighVersion;
    char szDescription[WSADESCRIPTION_LEN+1];
    char szSystemStatus[WSASYS_STATUS_LEN+1];
    unsigned short iMaxSockets;
    unsigned short iMaxUdpDg;
    char *lpVendorInfo;
} WSADATA;
typedef WSADATA *LPWSADATA;

#define INVALID_SOCKET (SOCKET)(~0)
#define SOCK_STREAM  1
#define SO_REUSEADDR 4
#define AF_INET 2
#define MSG_PEEK 0x2
#define INADDR_ANY (unsigned long)0x00000000
#define INADDR_LOOPBACK 0x7f000001
#define SOL_SOCKET 0xffff

#define SD_RECEIVE  0x00
#define SD_SEND     0x01
#define SD_BOTH     0x02

#define h_errno WSAGetLastError()

#define WSABASEERR 10000
#define TRY_AGAIN (WSABASEERR+1002)

SOCKET __stdcall accept(SOCKET, struct sockaddr *, int *);
int __stdcall bind(SOCKET, const struct sockaddr *, int);
int __stdcall closesocket(SOCKET);
int __stdcall connect(SOCKET, const struct sockaddr *, int);
struct hostent *__stdcall gethostbyname(const char *);
int __stdcall gethostname(char *, int);
int __stdcall getpeername(SOCKET, struct sockaddr *, int *);
int __stdcall getsockname(SOCKET, struct sockaddr *, int *);
unsigned long __stdcall htonl(unsigned long);
unsigned short __stdcall htons(unsigned short);
int __stdcall listen(SOCKET, int);
unsigned long __stdcall ntohl(unsigned long);
unsigned short __stdcall ntohs(unsigned short);
int __stdcall recv(SOCKET, char *, int, int);
int __stdcall recvfrom(SOCKET, char *, int, int, struct sockaddr *, int *);
int __stdcall select(int nfds, fd_set *, fd_set *, fd_set *, const struct timeval *);
int __stdcall send(SOCKET, const char *, int, int);
int __stdcall sendto(SOCKET, const char *, int, int, const struct sockaddr *, int);
int __stdcall setsockopt(SOCKET, int, int, const char *, int);
int __stdcall shutdown(SOCKET, int);
int __stdcall WSACleanup(void);
int __stdcall WSAGetLastError(void);
int __stdcall WSAStartup(WORD, LPWSADATA);

SOCKET __stdcall socket(int, int, int);

#endif

=== _ansi.h 0 0 101/108 ===
/* Header _ansi.h */
=== _mingw.h 0 0 102/108 ===
/*
 * _mingw.h
 *
 *  This file is for TinyCC and not part of the Mingw32 package.
 *
 *  THIS SOFTWARE IS NOT COPYRIGHTED
 *
 *  This source code is offered for use in the public domain. You may
 *  use, modify or distribute it freely.
 *
 *  This code is distributed in the hope that it will be useful but
 *  WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 *  DISCLAIMED. This includes but is not limited to warranties of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

#ifndef __MINGW_H
#define __MINGW_H

/* some winapi files define these before including _mingw.h --> */
#undef __cdecl
#undef _X86_
#undef WIN32
/* <-- */

#include <stddef.h>
#include <stdarg.h>

#define __int8 char
#define __int16 short
#define __int32 int
#define __int64 long long
#define _HAVE_INT64

#define __cdecl
#define __declspec(x) __attribute__((x))
#define __unaligned __attribute__((packed))
#define __fastcall __attribute__((fastcall))

#define __MSVCRT__ 1
#undef _MSVCRT_
#define __MINGW_IMPORT extern __declspec(dllimport)
#define __MINGW_ATTRIB_NORETURN
#define __MINGW_ATTRIB_CONST
#define __MINGW_ATTRIB_DEPRECATED
#define __MINGW_ATTRIB_MALLOC
#define __MINGW_ATTRIB_PURE
#define __MINGW_ATTRIB_NONNULL(arg)
#define __MINGW_NOTHROW
#define __GNUC_VA_LIST

#define _CRTIMP extern
#define __CRT_INLINE extern __inline__

#define _CRT_ALIGN(x) __attribute__((aligned(x)))
#define DECLSPEC_ALIGN(x) __attribute__((aligned(x)))
#define _CRT_PACKING 8
#define __CRT_UNALIGNED
#define _CONST_RETURN

#ifndef _TRUNCATE
#define _TRUNCATE ((size_t)-1)
#endif

#define __CRT_STRINGIZE(_Value) #_Value
#define _CRT_STRINGIZE(_Value) __CRT_STRINGIZE(_Value)
#define __CRT_WIDE(_String) L ## _String
#define _CRT_WIDE(_String) __CRT_WIDE(_String)

#ifdef _WIN64
#define __stdcall
#define _AMD64_ 1
#define __x86_64 1
#define _M_X64 100 /* Visual Studio */
#define _M_AMD64 100 /* Visual Studio */
#define USE_MINGW_SETJMP_TWO_ARGS
#define mingw_getsp tinyc_getbp
#define __TRY__
#else
#define __stdcall __attribute__((__stdcall__))
#define _X86_ 1
#define _M_IX86 300 /* Visual Studio */
#define WIN32 1
#define _USE_32BIT_TIME_T
#ifdef __arm__
#define __TRY__
#else
#define __TRY__ void __try__(void**), *_sehrec[6]; __try__(_sehrec);
#endif
#endif

/* in stddef.h */
#define _SIZE_T_DEFINED
#define _SSIZE_T_DEFINED
#define _PTRDIFF_T_DEFINED
#define _WCHAR_T_DEFINED
#define _UINTPTR_T_DEFINED
#define _INTPTR_T_DEFINED
#define _INTEGRAL_MAX_BITS 64

#ifndef _TIME32_T_DEFINED
#define _TIME32_T_DEFINED
typedef long __time32_t;
#endif

#ifndef _TIME64_T_DEFINED
#define _TIME64_T_DEFINED
typedef long long __time64_t;
#endif

#ifndef _TIME_T_DEFINED
#define _TIME_T_DEFINED
#ifdef _USE_32BIT_TIME_T
typedef __time32_t time_t;
#else
typedef __time64_t time_t;
#endif
#endif

#ifndef _WCTYPE_T_DEFINED
#define _WCTYPE_T_DEFINED
typedef wchar_t wctype_t;
#endif

#ifndef _WINT_T
#define _WINT_T
typedef short wint_t;
#endif

typedef int errno_t;
#define _ERRCODE_DEFINED

typedef struct threadlocaleinfostruct *pthreadlocinfo;
typedef struct threadmbcinfostruct *pthreadmbcinfo;
typedef struct localeinfo_struct _locale_tstruct,*_locale_t;

/* for winapi */
#define _ANONYMOUS_UNION
#define _ANONYMOUS_STRUCT
#define DECLSPEC_NORETURN
#define DECLARE_STDCALL_P(type) __stdcall type
#define NOSERVICE 1
#define NOMCX 1
#define NOIME 1
#define __INTRIN_H_
#ifndef DUMMYUNIONNAME
#  define DUMMYUNIONNAME
#  define DUMMYUNIONNAME1
#  define DUMMYUNIONNAME2
#  define DUMMYUNIONNAME3
#  define DUMMYUNIONNAME4
#  define DUMMYUNIONNAME5
#endif
#ifndef DUMMYSTRUCTNAME
#  define DUMMYSTRUCTNAME
#endif
#ifndef WINVER
# define WINVER 0x0502
#endif
#ifndef _WIN32_WINNT
# define _WIN32_WINNT 0x502
#endif

#define __C89_NAMELESS
#define __MINGW_EXTENSION
#define WINAPI_FAMILY_PARTITION(X) 1
#define MINGW_HAS_SECURE_API

#endif /* __MINGW_H */
=== _syslist.h 0 0 103/108 ===
/* Header _syslist.h */
=== stat.h 0 0 104/108 ===
/* stat.h */

#ifndef $sysstat
#define $sysstat

#include <stddef.h>

struct _stat {
	unsigned int	st_dev;
	unsigned short	st_ino;
	unsigned short	st_mode;
	short			st_nlink;
	short			st_uid;
	short			st_gid;
	unsigned long	st_rdev;
	unsigned int	st_size;
	unsigned long long int	st_atime;
	unsigned long long int	st_mtime;
	unsigned long long int	st_ctime;
};

#define stat _stat
#define _stati64 _stat

#define _S_IFMT 0xF000
#define _S_IFDIR 0x4000
#define _S_IFCHR 0x2000
#define _S_IFIFO 0x1000
#define _S_IFREG 0x8000
#define _S_IREAD 0x0100
#define _S_IWRITE 0x0080
#define _S_IEXEC 0x0040

#define S_IFMT 0xF000
#define S_IFDIR 0x4000
#define S_IFCHR 0x2000
#define S_IFIFO 0x1000
#define S_IFREG 0x8000
#define S_IREAD 0x0100
#define S_IWRITE 0x0080
#define S_IEXEC 0x0040

#define S_ISCHR(nd) (((nd) & S_IFMT) == S_IFCHR)
#define S_ISDIR(nd) (((nd) & S_IFMT) == S_IFDIR)
#define S_ISFIFO(nd) (((nd) & S_IFMT) == S_IFIFO)
#define S_ISREG(nd) (((nd) & S_IFMT) == S_IFREG)


#define	_S_IRWXU	(_S_IREAD | _S_IWRITE | _S_IEXEC)
#define	_S_IXUSR	_S_IEXEC
#define	_S_IWUSR	_S_IWRITE

#define	S_IRWXU		_S_IRWXU
#define	S_IXUSR		_S_IXUSR
#define	S_IWUSR		_S_IWUSR
#define	S_IRUSR		_S_IRUSR
#define	_S_IRUSR	_S_IREAD

#define S_IRGRP    (S_IRUSR >> 3)
#define S_IWGRP    (S_IWUSR >> 3)
#define S_IXGRP    (S_IXUSR >> 3)
#define S_IRWXG    (S_IRWXU >> 3)

#define S_IROTH    (S_IRGRP >> 3)
#define S_IWOTH    (S_IWGRP >> 3)
#define S_IXOTH    (S_IXGRP >> 3)
#define S_IRWXO    (S_IRWXG >> 3)

//#define	S_ISDIR(m)	(((m) & S_IFMT) == S_IFDIR)
//#define	S_ISFIFO(m)	(((m) & S_IFMT) == S_IFIFO)
//#define	S_ISCHR(m)	(((m) & S_IFMT) == S_IFCHR)
#define	S_IFBLK	0x3000	/* Block: Is this ever set under w32? */
#define	S_ISBLK(m)	(((m) & S_IFMT) == S_IFBLK)
#define	S_ISREG(m)	(((m) & S_IFMT) == S_IFREG)



int stat(const char *, struct stat*);

int _fstati64(int, struct stat*);

int fstat(int, struct stat *);
#define _fstat fstat

int _wstati64(const wchar_t,struct _stati64 *buffer);  



#endif
=== time.h 0 0 105/108 ===
/* Header time.h */

#ifndef $time
#define $time

#include <stddef.h>

typedef long clock_t;
clock_t clock(void);

//typedef long time_t;
#ifndef _TIME_T_DEFINED
#define _TIME_T_DEFINED
typedef long long int time_t;
#endif

struct tm
{
  int	tm_sec;
  int	tm_min;
  int	tm_hour;
  int	tm_mday;
  int	tm_mon;
  int	tm_year;
  int	tm_wday;
  int	tm_yday;
  int	tm_isdst;
};

//struct tm *localtime(time_t*);
struct tm* _localtime32(time_t*);
#define localtime _localtime32

time_t _time64(time_t *_timer);
#define time _time64

#define CLOCKS_PER_SEC 1000

struct tm *gmtime(const time_t*);
size_t strftime(char *, size_t, const char *, const struct tm *);
time_t mktime(struct tm *);
double difftime(time_t, time_t);

char* asctime(const struct tm*);
//char* ctime(const time_t *_time);
char* _ctime64(const time_t *_time);
#define ctime _ctime64

#endif
=== timeb.h 0 0 106/108 ===
/* timeb.h */

#ifndef $timeb
#define $timeb

#include <time.h>

struct _timeb {
	time_t time;
	unsigned short millitm;
	short timezone;
	short dstflag;
};
#define timeb _timeb

void _ftime64(struct _timeb*);
#define _ftime _ftime64
#define ftime _ftime64

#endif
=== types.h 0 0 107/108 ===
/* types.h */
#ifndef $systypes
#define $systypes 1

typedef long int off_t;
typedef long int ino_t;
typedef unsigned int dev_t;

typedef long long time_t;

#endif
=== utime.h 0 0 108/108 ===
/* sys/utime.h header */

#ifndef $utime
#define $utime

struct _utimbuf {
	long actime;
	long modtime;
};


struct utimbuf {
	long actime;
	long modtime;
};

struct __utimbuf64 {
  long long int actime;
  long long int modtime;
};

int _utime64(const char *_Filename,struct __utimbuf64 *_Time);

int utime(const char *_Filename,struct utimbuf *_Utimbuf) {
  return _utime64(_Filename,(struct __utimbuf64 *)_Utimbuf);
}

#endif
=== END ===
1 cc.m 0 0
2 ccgas.m 0 0
3 cci.m 0 0
4 ccp.m 0 0
5 cc_blockmcl.m 0 0
6 cc_blockpcl.m 0 0
7 cc_cli.m 0 0
8 cc_decls.m 0 0
9 cc_export.m 0 0
10 cc_genpcl.m 0 0
11 cc_headers.m 0 0
12 cc_headersx.m 0 0
13 cc_headersy.m 0 0
14 cc_lex.m 0 0
15 cc_lib.m 0 0
16 cc_libpcl.m 0 0
17 cc_parse.m 0 0
18 cc_pcl.m 0 0
19 cc_show.m 0 0
20 cc_showdummy.m 0 0
21 cc_support.m 0 0
22 cc_tables.m 0 0
23 pcl.m 0 0
24 pclc.m 0 0
25 pclcp.m 0 0
26 pclp.m 0 0
27 pcl_lib.m 0 0
28 pc_api.m 0 0
29 pc_decls.m 0 0
30 pc_diags.m 0 0
31 pc_reduce.m 0 0
32 pc_run.m 0 0
33 pc_runaux.m 0 0
34 pc_tables.m 0 0
35 mc_auxmcl.m 0 0
36 mc_decls.m 0 0
37 mc_disasm.m 0 0
38 mc_genmcl.m 0 0
39 mc_genss.m 0 0
40 mc_libmcl.m 0 0
41 mc_objdecls.m 0 0
42 mc_optim.m 0 0
43 mc_stackmcl.m 0 0
44 mc_writeasm.m 0 0
45 mc_writeexe.m 0 0
46 mc_writegas.m 0 0
47 mc_writenasm.m 0 0
48 mc_writeobj.m 0 0
49 mc_writess.m 0 0
50 mx_decls.m 0 0
51 mx_lib.m 0 0
52 mx_run.m 0 0
53 mx_show.m 0 0
54 mx_write.m 0 0
55 cc.pro 0 0
56 ccgas.pro 0 0
57 backup.bat 0 0
58 cc_help.txt 0 0
59 info.txt 0 0
60 putbcc.bat 0 0
61 mcc.h 0 0
62 assert.h 0 0
63 conio.h 0 0
64 ctype.h 0 0
65 direct.h 0 0
66 errno.h 0 0
67 fcntl.h 0 0
68 fenv.h 0 0
69 float.h 0 0
70 inttypes.h 0 0
71 io.h 0 0
72 iso646.h 0 0
73 limits.h 0 0
74 locale.h 0 0
75 malloc.h 0 0
76 math.h 0 0
77 mcc.h 0 0
78 memory.h 0 0
79 process.h 0 0
80 safelib.h 0 0
81 setjmp.h 0 0
82 shellapi.h 0 0
83 signal.h 0 0
84 smallwindows.h 0 0
85 stdarg.h 0 0
86 stdbool.h 0 0
87 stddef.h 0 0
88 stdint.h 0 0
89 stdio.h 0 0
90 stdlib.h 0 0
91 string.h 0 0
92 time.h 0 0
93 unistd.h 0 0
94 utime.h 0 0
95 w.c 0 0
96 wchar.h 0 0
97 wctype.h 0 0
98 windows.h 0 0
99 windowsx.h 0 0
100 winsock2.h 0 0
101 _ansi.h 0 0
102 _mingw.h 0 0
103 _syslist.h 0 0
104 stat.h 0 0
105 time.h 0 0
106 timeb.h 0 0
107 types.h 0 0
108 utime.h 0 0
