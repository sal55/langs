/*
Info header for C distribution.
Project: 'QQ' Q Byte-code compiler and interpreter

Typical Build Instructions:

Needs a 64-bit compiler. Examples:

  gcc qq.c -oqq -lm -ldl
  tcc qq.c -oqq -lm -ldl

This program is a compiler/interpreter for my Q dynamic language. It compiles
an entire program into a single byte-code binary then runs it.

Run as follows:

  ./qq prog.q      # Compile application prog.q to prog.pc then run prog.pc

  ./qq prog.pc     # Run pre-compiled program prog.pc


Test hello.q file:

  proc start =
    println "Hello, World!"
  end

*/

/*
  M to C  Whole Program Translator
  Input:  qq.m plus imported modules
  Output: qq.c (this file, or renamed from that)
          File represents entire program
  Target: C 64-bit
  OS:     Neutral

  Modules:
  Module 1: qq.m
  Module 2: <Built-in: msysnewc.m>
  Module 3: <Built-in: clibnewc.m>
  Module 4: <Built-in: mlib.m>
  Module 5: <Built-in: osnos.m>
  Module 6: ./pci.m
  Module 7: ./pc_types.m
  Module 8: ./pc_decls.m
  Module 9: ./pq_common.m
  Module 10: ./pc_support.m
  Module 11: ./pc_misc.m
  Module 12: ./pc_pcfns.m
  Module 13: ./pc_objlib.m
  Module 14: ./pc_bignum.m
  Module 15: c:/oldmx/mbignum.m
  Module 16: ./pc_print.m
  Module 17: ./pc_jhandlers.m
  Module 18: ./pc_oslayer.m
  Module 19: c:/oldmx/osnosdll.m
  Module 20: ./pc_host.m
  Module 21: ./pc_dxfns.m
  Module 22: ./pc_khandlers.m
  Module 23: ./pc_assemc.m
  Module 24: ./var_decls.m
  Module 25: ./var_types.m
  Module 26: ./qc_tables.m
  Module 27: ./qci.m
  Module 28: ./qc_support.m
  Module 29: ./qc_lex.m
  Module 30: ./qc_parse.m
  Module 31: ./qc_lib.m
  Module 32: ./qc_name.m
  Module 33: ./qc_pclgen.m
  Module 34: ./qc_pcllib.m
  Module 35: ./q_libs.m

*********** Start of C Code **********/


#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>

#pragma pack(1)

typedef int8_t i8;
typedef int16_t i16;
typedef int32_t i32;
typedef int64_t i64;

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef unsigned char byte;

typedef void* var;

#ifndef CALLBACK
#define CALLBACK
#endif

#if (UINTPTR_MAX<0xFFFFFFFFFFFFFFFF)
	#error "Need 64-bit target. Try -m64"
#endif

/* Forward Struct Declarations */
struct msysnewc_procinforec;
struct msysnewc_fmtrec;
struct mlib_strbuffer;
struct osnos_rsystemtime;
struct osnos_os_getdllprocaddr_rec;
struct pc_decls_uflagsrec;
struct pc_decls_fieldrec;
struct pc_decls_strec;
struct pc_decls_listrec;
struct pc_decls_stringrec;
struct pc_decls_recordrec;
struct pc_decls_decimalrec;
struct pc_decls_setrec;
struct pc_decls_dictrec;
struct pc_decls_arrayrec;
struct pc_decls_bitsrec;
struct pc_decls_structrec;
struct pc_decls_objrec;
struct pc_decls_exceptionrec;
struct pc_decls_returnrec;
struct pc_decls_refrec;
struct pc_decls_operatorrec;
struct pc_decls_iterrec;
struct pc_decls_varrec;
struct pc_decls_genfieldnamerec;
struct pc_decls_genfielddatarec;
struct pc_decls_modulerec;
struct pc_decls_dllprocrec;
struct pc_decls_applprocrec;
struct pc_decls_procrec;
struct pc_decls_fmtrec;
struct mbignum_bignumrec;
struct mbignum_constrec;
struct pc_host_dimrec;
struct pc_host_overloadrec;
struct pc_host_pch_setoverload_rec;
struct var_decls_attribrec;
struct var_decls_uflagsrec;
struct var_decls_fieldrec;
struct var_decls_strec;
struct var_decls_unitrec;
struct var_decls_genfieldnamerec;
struct var_decls_genfielddatarec;
struct var_decls_modulerec;
struct var_decls_dllprocrec;
struct var_decls_procrec;
struct var_decls_userxrec;
struct qc_lex_lexrec;

/* Struct Definitions */
struct msysnewc_procinforec {
    uint16_t fnindex;
    byte rettype;
    byte nparams;
    byte paramlist[12];
};

struct msysnewc_fmtrec {
    byte minwidth;
    int8_t precision;
    byte base;
    uint8_t quotechar;
    uint8_t padchar;
    uint8_t realfmt;
    uint8_t plus;
    uint8_t sepchar;
    uint8_t lettercase;
    uint8_t justify;
    uint8_t suffix;
    uint8_t usigned;
    uint8_t charmode;
    uint8_t heapmode;
    uint8_t param;
    byte spare;
};

struct mlib_strbuffer {
    uint8_t *  strptr;
    int32_t length;
    int32_t allocated;
};

struct osnos_rsystemtime {
    int64_t year;
    int64_t month;
    int64_t dayofweek;
    int64_t day;
    int64_t hour;
    int64_t minute;
    int64_t second;
    int64_t milliseconds;
};

struct osnos_os_getdllprocaddr_rec {
    uint8_t *  name;
    void *  addr;
};

struct pc_decls_uflagsrec {
    byte codes[7];
    byte ulength;
};

struct pc_decls_fieldrec {
    uint8_t *  name;
    int16_t recordtype;
    int16_t fieldtype;
    int32_t fieldoffset;
};

struct pc_decls_strec {
    uint8_t *  name;
    struct pc_decls_strec* owner;
    struct pc_decls_strec* deflist;
    struct pc_decls_strec* nextdef;
    uint8_t *  metadata;
    byte symbol;
    byte nameid;
    int16_t subcode;
    int16_t mode;
    byte ax_at;
    byte ax_moduleno;
    int32_t index;
    union {
        void *  address;
        int32_t offset;
        int64_t *  pcaddress;
    };
};

struct pc_decls_listrec {
    uint32_t refcount;
    uint16_t tag;
    struct {
        byte objtype;
        byte mutable;
    };
    union {
        struct pc_decls_varrec *  vptr;
        uint64_t padding1;
    };
    uint32_t length;
    int32_t lower;
    union {
        struct pc_decls_objrec *  objptr2;
        uint32_t allocated;
        uint64_t padding2;
    };
};

struct pc_decls_stringrec {
    uint32_t refcount;
    uint16_t tag;
    struct {
        byte objtype;
        byte mutable;
    };
    union {
        uint8_t *  strptr;
        uint64_t padding1;
    };
    int32_t length;
    int32_t spare3;
    union {
        struct pc_decls_objrec *  objptr2;
        uint32_t allocated;
    };
};

struct pc_decls_recordrec {
    uint32_t refcount;
    uint16_t tag;
    struct {
        byte spare;
        byte mutable;
    };
    union {
        struct pc_decls_varrec *  vptr;
        byte *  ptr;
        uint64_t padding1;
    };
    uint32_t length;
    int32_t lower;
    int64_t spare2;
};

struct pc_decls_decimalrec {
    uint32_t refcount;
    uint16_t tag;
    byte spare1;
    byte spare2;
    union {
        void *  bnptr;
        uint64_t padding1;
    };
    int64_t spare3;
    int64_t spare4;
};

struct pc_decls_setrec {
    uint32_t refcount;
    uint16_t tag;
    struct {
        byte spare;
        byte mutable;
    };
    union {
        byte *  ptr;
        uint64_t padding1;
    };
    uint32_t length;
    int16_t lower;
    int16_t elemtag;
    uint64_t allocated64;
};

struct pc_decls_dictrec {
    uint32_t refcount;
    uint16_t tag;
    struct {
        byte spare;
        byte mutable;
    };
    union {
        struct pc_decls_varrec *  vptr;
        uint64_t padding1;
    };
    uint32_t length;
    int32_t lower;
    union {
        struct {
            uint32_t allocated;
            uint32_t dictitems;
        };
        struct pc_decls_objrec *  objptr2;
    };
};

struct pc_decls_arrayrec {
    uint32_t refcount;
    uint16_t tag;
    struct {
        byte objtype;
        byte mutable;
    };
    union {
        byte *  ptr;
        uint64_t padding1;
    };
    uint32_t length;
    int16_t lower;
    int16_t elemtag;
    union {
        struct pc_decls_objrec *  objptr2;
        uint32_t allocated;
    };
};

struct pc_decls_bitsrec {
    uint32_t refcount;
    uint16_t tag;
    struct {
        byte objtype;
        byte mutable;
    };
    union {
        byte *  ptr;
        uint64_t padding1;
    };
    uint32_t length;
    int16_t lower;
    byte elemtag;
    byte bitoffset;
    union {
        struct pc_decls_objrec *  objptr2;
        uint64_t allocated64;
    };
};

struct pc_decls_structrec {
    uint32_t refcount;
    uint16_t tag;
    struct {
        byte spare;
        byte mutable;
    };
    union {
        byte *  ptr;
        uint64_t padding1;
    };
    uint32_t length;
    int16_t lower;
    int16_t elemtag;
    union {
        struct pc_decls_objrec *  objptr2;
        uint32_t allocated;
    };
};

struct pc_decls_objrec {
    union {
        struct {
            uint32_t refcount;
            uint16_t tag;
            byte objtype;
            byte spare1;
            uint64_t spare2;
            uint64_t spare3;
            union {
                struct pc_decls_objrec* objptr2;
                uint64_t dummy4;
            };
        };
        struct pc_decls_listrec ulist;
        struct pc_decls_stringrec ustr;
        struct pc_decls_recordrec urec;
        struct pc_decls_decimalrec udec;
        struct pc_decls_setrec uset;
        struct pc_decls_dictrec udict;
        struct pc_decls_arrayrec uarray;
        struct pc_decls_bitsrec ubits;
        struct pc_decls_structrec ustruct;
    };
};

struct pc_decls_exceptionrec {
    union {
        struct {
            uint16_t tag;
            byte hasref;
            byte exceptiontype;
        };
    };
    struct {
        int16_t frameoffset;
        int16_t nexceptions;
    };
    byte *  ptr;
};

struct pc_decls_returnrec {
    union {
        struct {
            uint16_t tag;
            byte hasref;
            byte stackadj;
        };
    };
    int32_t frameptr_low;
    int64_t *  retaddr;
};

struct pc_decls_refrec {
    union {
        struct {
            uint16_t tag;
            byte hasref;
            byte spare1;
        };
    };
    struct {
        uint16_t elemtag;
        byte bitoffset;
        byte bitlength;
    };
    union {
        byte *  ptr;
        int64_t *  ptr64;
    };
};

struct pc_decls_operatorrec {
    union {
        struct {
            uint16_t tag;
            byte hasref;
            byte opdims;
        };
    };
    uint32_t spare2;
    int64_t opcode;
};

struct pc_decls_iterrec {
    union {
        struct {
            uint16_t tag;
            byte hasref;
            byte opdims;
        };
    };
    uint32_t itcount;
    byte ittype;
    byte spare3[3];
};

struct pc_decls_varrec {
    union {
        struct {
            union {
                struct {
                    uint16_t tag;
                    byte hasref;
                    byte spare1;
                };
                uint32_t tagx;
            };
            uint32_t spare2;
            union {
                int64_t value;
                double xvalue;
                uint64_t uvalue;
                struct {
                    int32_t range_lower;
                    int32_t range_upper;
                };
                struct pc_decls_objrec *  objptr;
                struct pc_decls_varrec* varptr;
                byte *  refptr;
            };
        };
        struct pc_decls_exceptionrec uexcept;
        struct pc_decls_returnrec uret;
        struct pc_decls_refrec uref;
        struct pc_decls_operatorrec uop;
        struct pc_decls_iterrec uiter;
    };
};

struct pc_decls_genfieldnamerec {
    uint8_t *  name;
    int32_t dataindex;
    union {
        int32_t datalength;
        int32_t datalast;
    };
};

struct pc_decls_genfielddatarec {
    int32_t fieldindex;
    int32_t recordtype;
    int32_t fieldtype;
    union {
        int32_t offset;
        uint32_t index;
        uint32_t procoffset;
    };
};

struct pc_decls_modulerec {
    uint8_t *  name;
    uint8_t *  filename;
    uint8_t *  sourcecode;
    int64_t (*pccode)[];
    uint16_t (*linetable)[];
    int32_t sourcelen;
    int32_t npccode;
    int32_t pcindex;
    int32_t level;
    int32_t exported;
    byte importmap[50];
};

struct pc_decls_dllprocrec {
    uint8_t *  name;
    void (*address)(void);
    int32_t dllindex;
};

struct pc_decls_applprocrec {
    uint8_t *  name;
    void (*address)(void);
    struct msysnewc_procinforec *  info;
};

struct pc_decls_procrec {
    struct pc_decls_strec *  def;
    struct pc_decls_procrec* nextproc;
};

struct pc_decls_fmtrec {
    byte minwidth;
    int8_t precision;
    byte base;
    uint8_t quotechar;
    uint8_t padchar;
    uint8_t realfmt;
    uint8_t plus;
    uint8_t sepchar;
    uint8_t lettercase;
    uint8_t justify;
    uint8_t suffix;
    uint8_t usigned;
    uint8_t charmode;
    uint8_t showtype;
    byte spare[2];
};

struct mbignum_bignumrec {
    int32_t (*num)[];
    int64_t length;
    int64_t expon;
    int32_t neg;
    int32_t numtype;
};

struct mbignum_constrec {
    int64_t value;
    struct mbignum_bignumrec *  bnvalue;
    struct mbignum_constrec* nextconst;
};

struct pc_host_dimrec {
    int64_t lbound;
    int64_t upper;
    int64_t length;
};

struct pc_host_overloadrec {
    int64_t optype;
    int64_t optype2;
    int64_t *  pchandler;
    struct pc_host_overloadrec* nextrec;
};

struct pc_host_pch_setoverload_rec {
    int64_t cmd;
    void *  tableptr;
    void *  handleptr;
    struct pc_host_overloadrec * *  ovlist;
};

struct var_decls_attribrec {
    byte ax_global;
    byte ax_static;
    byte ax_equals;
    byte ax_at;
    byte ax_byrefmode;
    byte ax_optional;
    byte ax_varparams;
    byte ax_used;
    byte ax_forward;
    byte ax_frame;
    byte ax_autovar;
    byte ax_nparams;
    byte ax_fflang;
    byte ax_moduleno;
    byte ax_baseclass;
    union {
        byte ax_align;
        byte ax_dllindex;
        byte ax_extmodno;
    };
};

struct var_decls_uflagsrec {
    byte codes[7];
    byte ulength;
};

struct var_decls_fieldrec {
    uint8_t *  name;
    int16_t recordtype;
    int16_t fieldtype;
    int64_t fieldoffset;
};

struct var_decls_strec {
    uint8_t *  name;
    struct var_decls_strec* owner;
    struct var_decls_strec* deflist;
    struct var_decls_strec* nextdef;
    struct var_decls_strec* nextdupl;
    struct var_decls_strec* prevdupl;
    struct var_decls_strec* firstdupl;
    union {
        struct var_decls_strec* nextparam;
        struct var_decls_unitrec *  callchain;
    };
    struct var_decls_unitrec *  code;
    union {
        struct var_decls_strec* paramlist;
        struct var_decls_uflagsrec uflags;
    };
    union {
        struct var_decls_strec* equiv;
        uint8_t *  docstring;
    };
    union {
        uint8_t *  truename;
        uint8_t *  metadata;
        uint8_t *  macrovalue;
    };
    byte namelen;
    byte symbol;
    byte nameid;
    byte sparebyte;
    int16_t subcode;
    int16_t mode;
    int32_t index;
    union {
        void *  address;
        int32_t offset;
        int64_t *  pcaddress;
        int32_t base_class;
        int32_t bcindex;
    };
    int32_t lineno;
    struct var_decls_attribrec attribs;
};

struct var_decls_unitrec {
    int32_t tag;
    int32_t lineno;
    struct var_decls_unitrec* a;
    struct var_decls_unitrec* b;
    struct var_decls_unitrec* c;
    struct var_decls_unitrec* nextunit;
    union {
        struct var_decls_strec *  def;
        int64_t value;
        uint64_t uvalue;
        double xvalue;
        uint8_t *  svalue;
        struct var_decls_strec *  labeldef;
        struct {
            int32_t range_lower;
            int32_t range_upper;
        };
    };
    union {
        int32_t opcode;
        int32_t index;
        int32_t trylevel;
        int32_t slength;
        int32_t length;
        byte dottedname;
    };
    int16_t mode;
    int16_t moduleno;
};

struct var_decls_genfieldnamerec {
    union {
        struct var_decls_strec *  def;
        uint8_t *  name;
    };
    int32_t dataindex;
    union {
        int32_t datalength;
        int32_t datalast;
    };
};

struct var_decls_genfielddatarec {
    int32_t fieldindex;
    int32_t recordtype;
    int32_t fieldtype;
    union {
        int32_t offset;
        uint32_t index;
        uint32_t procoffset;
    };
};

struct var_decls_modulerec {
    uint8_t *  name;
    uint8_t *  filename;
    uint8_t *  sourcecode;
    uint8_t *  qafilestr;
    struct var_decls_strec *  stmodule;
    int64_t (*pccode)[];
    uint16_t (*linetable)[];
    int32_t sourcelen;
    int32_t npccode;
    int32_t pcindex;
    int32_t level;
    int32_t exported;
    byte importmap[50];
};

struct var_decls_dllprocrec {
    uint8_t *  name;
    int32_t dllindex;
};

struct var_decls_procrec {
    struct var_decls_strec *  def;
    struct var_decls_procrec* nextproc;
};

struct var_decls_userxrec {
    struct var_decls_strec *  owner;
    int16_t *  pmode;
    struct var_decls_userxrec* nextmode;
};

struct qc_lex_lexrec {
    union {
        int64_t value;
        double xvalue;
        uint64_t uvalue;
        uint8_t *  svalue;
        struct var_decls_strec *  symptr;
    };
    int32_t symbol;
    int32_t subcode;
    int32_t length;
    int32_t lineno;
    int32_t fileno;
    uint32_t hashvalue;
};


/* PROCDECLS */
void start(void);
static void qq_getinputoptions(int64_t * filetype);
static void qq_do_option(int64_t sw,uint8_t * value);
static void qq_getsyscmdline(int64_t n);
static void qq_showcaption(void);
static void qq_showhelp(void);
int64_t msysnewc_m_getdotindex(uint64_t a,int64_t i);
void msysnewc_m_setdotindex(uint64_t * a,int64_t i,int64_t x);
int64_t msysnewc_m_getdotslice(uint64_t a,int64_t i,int64_t j);
void msysnewc_m_setdotslice(uint64_t * a,int64_t i,int64_t j,uint64_t x);
int64_t msysnewc_m_get_nprocs(void);
int64_t msysnewc_m_get_nexports(void);
void * msysnewc_m_get_procname(int64_t n);
uint8_t * msysnewc_m_get_procaddr(int64_t n);
void * msysnewc_m_get_procexport(int64_t n);
static void msysnewc_pushio(void);
void msysnewc_m_print_startfile(void * dev);
void msysnewc_m_print_startstr(uint8_t * s);
void msysnewc_m_print_startptr(uint8_t * * p);
void msysnewc_m_print_startcon(void);
void msysnewc_m_print_setfmt(uint8_t * format);
void msysnewc_m_print_end(void);
void msysnewc_m_print_ptr(void * a,uint8_t * fmtstyle);
void msysnewc_m_print_i64(int64_t a,uint8_t * fmtstyle);
void msysnewc_m_print_u64(uint64_t a,uint8_t * fmtstyle);
void msysnewc_m_print_r64(double x,uint8_t * fmtstyle);
void msysnewc_m_print_r32(float x,uint8_t * fmtstyle);
void msysnewc_m_print_c8(int64_t a,uint8_t * fmtstyle);
void msysnewc_m_print_str(uint8_t * s,uint8_t * fmtstyle);
void msysnewc_m_print_newline(void);
void msysnewc_m_print_nogap(void);
void msysnewc_printstr(uint8_t * s);
void msysnewc_printstr_n(uint8_t * s,int64_t n);
void msysnewc_printstrn_app(uint8_t * s,int64_t length,void * f);
static uint8_t * msysnewc_makezstring(uint8_t * s,int64_t n,uint8_t * local);
static void msysnewc_freezstring(uint8_t * t,int64_t n);
static void msysnewc_printchar(int64_t ch);
void msysnewc_nextfmtchars(int64_t lastx);
void msysnewc_strtofmt(uint8_t * s,int64_t slen,struct msysnewc_fmtrec * fmt);
static int64_t msysnewc_domultichar(uint8_t * p,int64_t n,uint8_t * dest,struct msysnewc_fmtrec * fmt);
static int64_t msysnewc_expandstr(uint8_t * s,uint8_t * t,int64_t n,struct msysnewc_fmtrec * fmt);
static uint64_t msysnewc_xdivrem(uint64_t a,uint64_t b,uint64_t * remainder);
static int64_t msysnewc_u64tostr(uint64_t aa,uint8_t * s,uint64_t base,int64_t sep);
static int64_t msysnewc_i64tostrfmt(int64_t aa,uint8_t * s,struct msysnewc_fmtrec * fmt);
static int64_t msysnewc_u64tostrfmt(int64_t aa,uint8_t * s,struct msysnewc_fmtrec * fmt);
static int64_t msysnewc_i64mintostr(uint8_t * s,int64_t base,int64_t sep);
static int64_t msysnewc_strtostrfmt(uint8_t * s,uint8_t * t,int64_t n,struct msysnewc_fmtrec * fmt);
static void msysnewc_tostr_i64(int64_t a,struct msysnewc_fmtrec * fmt);
static void msysnewc_tostr_u64(uint64_t a,struct msysnewc_fmtrec * fmt);
static void msysnewc_tostr_r64(double x,struct msysnewc_fmtrec * fmt);
static void msysnewc_tostr_str(uint8_t * s,struct msysnewc_fmtrec * fmt);
static struct msysnewc_fmtrec * msysnewc_getfmt(uint8_t * fmtstyle);
uint8_t * msysnewc_strint(int64_t a,uint8_t * fmtstyle);
void msysnewc_getstrint(int64_t a,uint8_t * dest);
uint8_t * msysnewc_strword(uint64_t a,uint8_t * fmtstyle);
uint8_t * msysnewc_strreal(double a,uint8_t * fmtstyle);
static uint8_t * msysnewc_getstr(uint8_t * s,struct msysnewc_fmtrec * fmt);
static void msysnewc_initreadbuffer(void);
void msysnewc_m_read_conline(void);
void msysnewc_m_read_fileline(void * f);
void msysnewc_m_read_strline(uint8_t * s);
static uint8_t * msysnewc_readitem(int64_t * itemlength);
int64_t msysnewc_strtoint(uint8_t * s,int64_t length,int64_t base);
int64_t msysnewc_m_read_i64(int64_t fmt);
double msysnewc_m_read_r64(int64_t fmt);
void msysnewc_m_read_str(uint8_t * dest,int64_t destlen,int64_t fmt);
void msysnewc_readstr(uint8_t * dest,int64_t fmt,int64_t destlen);
void msysnewc_rereadln(void);
void msysnewc_reread(void);
int64_t msysnewc_valint(uint8_t * s,int64_t fmt);
double msysnewc_valreal(uint8_t * s);
static void msysnewc_iconvlcn(uint8_t * s,int64_t n);
static void msysnewc_iconvucn(uint8_t * s,int64_t n);
static void msysnewc_convlcstring(uint8_t * s);
static void msysnewc_convucstring(uint8_t * s);
int64_t msysnewc_m_power_i64(int64_t n,int64_t a);
void msysnewc_m_intoverflow(void);
void msysnewc_m_dotindex(uint64_t i,uint64_t a);
void msysnewc_m_dotslice(uint64_t j,uint64_t i,uint64_t a);
void msysnewc_m_popdotindex(uint64_t i,uint64_t * p,uint64_t x);
void msysnewc_m_popdotslice(uint64_t j,uint64_t i,uint64_t * p,uint64_t x);
int64_t msysnewc_m_imin(int64_t a,int64_t b);
int64_t msysnewc_m_imax(int64_t a,int64_t b);
double msysnewc_m_sign(double x);
void * mlib_pcm_alloc(int64_t n);
void mlib_pcm_freestr(uint8_t * s);
void mlib_pcm_free(void * p,int64_t n);
void mlib_pcm_freeac(void * p,int64_t alloc);
void mlib_pcm_copymem4(void * p,void * q,int64_t n);
void mlib_pcm_clearmem(void * p,int64_t n);
void mlib_pcm_init(void);
int64_t mlib_pcm_getac(int64_t size);
void * mlib_pcm_newblock(int64_t itemsize);
int64_t mlib_pcm_round(int64_t n);
int64_t mlib_pcm_array(int64_t n);
void mlib_pcm_printfreelist(int64_t size,uint64_t * p);
void mlib_pcm_diags(uint8_t * caption);
void * mlib_pcm_allocz(int64_t n);
uint8_t * mlib_pcm_copyheapstring(uint8_t * s);
uint8_t * mlib_pcm_copyheapstringn(uint8_t * s,int64_t n);
uint8_t * mlib_pcm_copyheapblock(uint8_t * s,int64_t length);
static void mlib_addtomemalloc(int32_t * ptr,int64_t size);
static void mlib_removefrommemalloc(int32_t * ptr,int64_t size);
void * mlib_allocmem(int64_t n);
void * mlib_reallocmem(void * p,int64_t n);
void mlib_abortprogram(uint8_t * s);
int64_t mlib_getfilesize(void * handlex);
void mlib_readrandom(void * handlex,byte * mem,int64_t offset,int64_t size);
int64_t mlib_writerandom(void * handlex,byte * mem,int64_t offset,int64_t size);
int64_t mlib_setfilepos(void * file,int64_t offset);
int64_t mlib_getfilepos(void * file);
byte * mlib_readfile(uint8_t * filename);
int64_t mlib_writefile(uint8_t * filename,byte * data,int64_t size);
int64_t mlib_checkfile(uint8_t * file);
void mlib_readlinen(void * handlex,uint8_t * buffer,int64_t size);
void mlib_iconvlcn(uint8_t * s,int64_t n);
void mlib_iconvucn(uint8_t * s,int64_t n);
void mlib_convlcstring(uint8_t * s);
void mlib_convucstring(uint8_t * s);
uint8_t * mlib_changeext(uint8_t * s,uint8_t * newext);
uint8_t * mlib_extractext(uint8_t * s,int64_t period);
uint8_t * mlib_extractpath(uint8_t * s);
uint8_t * mlib_extractfile(uint8_t * s);
uint8_t * mlib_extractbasefile(uint8_t * s);
uint8_t * mlib_addext(uint8_t * s,uint8_t * newext);
void * mlib_alloctable(int64_t n,int64_t size);
void * mlib_zalloctable(int64_t n,int64_t size);
void mlib_checkfreelists(uint8_t * s);
void * mlib_pcm_alloc32(void);
void mlib_pcm_free32(void * p);
void mlib_outbyte(void * f,int64_t x);
void mlib_outword16(void * f,uint64_t x);
void mlib_outword(void * f,uint64_t x);
void mlib_outword64(void * f,uint64_t x);
int64_t mlib_myeof(void * f);
void * mlib_pcm_smallallocz(int64_t n);
void * mlib_pcm_smallalloc(int64_t n);
void mlib_strbuffer_add(struct mlib_strbuffer * dest,uint8_t * s,int64_t n);
void mlib_gs_init(struct mlib_strbuffer * dest);
void mlib_gs_free(struct mlib_strbuffer * dest);
void mlib_gs_str(struct mlib_strbuffer * dest,uint8_t * s);
void mlib_gs_char(struct mlib_strbuffer * dest,int64_t c);
void mlib_gs_strn(struct mlib_strbuffer * dest,uint8_t * s,int64_t length);
void mlib_gs_strvar(struct mlib_strbuffer * dest,struct mlib_strbuffer * s);
void mlib_gs_strint(struct mlib_strbuffer * dest,int64_t a);
void mlib_gs_strln(struct mlib_strbuffer * dest,uint8_t * s);
void mlib_gs_strsp(struct mlib_strbuffer * dest,uint8_t * s);
void mlib_gs_line(struct mlib_strbuffer * dest);
int64_t mlib_gs_getcol(struct mlib_strbuffer * dest);
void mlib_gs_leftstr(struct mlib_strbuffer * dest,uint8_t * s,int64_t w,int64_t padch);
void mlib_gs_leftint(struct mlib_strbuffer * dest,int64_t a,int64_t w,int64_t padch);
void mlib_gs_padto(struct mlib_strbuffer * dest,int64_t col,int64_t ch);
void mlib_gs_println(struct mlib_strbuffer * dest,void * f);
int64_t mlib_nextcmdparam(int64_t * paramno,uint8_t * * name,uint8_t * * value,uint8_t * defext);
static int64_t mlib_readnextfileitem(uint8_t * * fileptr,uint8_t * * item);
void mlib_ipadstr(uint8_t * s,int64_t width,uint8_t * padchar);
uint8_t * mlib_padstr(uint8_t * s,int64_t width,uint8_t * padchar);
uint8_t * mlib_chr(int64_t c);
int64_t mlib_cmpstring(uint8_t * s,uint8_t * t);
int64_t mlib_cmpstringn(uint8_t * s,uint8_t * t,int64_t n);
int64_t mlib_eqstring(uint8_t * s,uint8_t * t);
int64_t mlib_cmpbytes(void * p,void * q,int64_t n);
int64_t mlib_eqbytes(void * p,void * q,int64_t n);
void mlib_mseed(uint64_t a,uint64_t b);
uint64_t mlib_mrandom(void);
int64_t mlib_mrandomp(void);
int64_t mlib_mrandomint(int64_t n);
int64_t mlib_mrandomrange(int64_t a,int64_t b);
double mlib_mrandomreal(void);
double mlib_mrandomreal1(void);
byte * mlib_checkpackfile(void);
void osnos_os_init(void);
int64_t osnos_os_execwait(uint8_t * cmdline,int64_t newconsole,uint8_t * workdir);
int64_t osnos_os_execcmd(uint8_t * cmdline,int64_t newconsole);
int64_t osnos_os_getch(void);
int64_t osnos_os_kbhit(void);
void osnos_os_flushkeys(void);
void * osnos_os_getconsolein(void);
void * osnos_os_getconsoleout(void);
void * osnos_os_proginstance(void);
uint64_t osnos_os_getdllinst(uint8_t * name);
void (*osnos_os_getdllprocaddr(int64_t hinst,uint8_t * name))(void);
void osnos_os_initwindows(void);
int64_t osnos_os_getchx(void);
uint8_t * osnos_os_getos(void);
int64_t osnos_os_getoscode(void);
int64_t osnos_os_iswindows(void);
int64_t osnos_os_shellexec(uint8_t * opc,uint8_t * file);
void osnos_os_sleep(int64_t a);
void * osnos_os_getstdin(void);
void * osnos_os_getstdout(void);
uint8_t * osnos_os_gethostname(void);
int64_t osnos_os_gethostsize(void);
uint8_t * osnos_os_getmpath(void);
void osnos_os_exitprocess(int64_t x);
int64_t osnos_os_gettimestamp(void);
int64_t osnos_os_gettickcount(void);
int64_t osnos_os_clock(void);
int64_t osnos_os_getclockspersec(void);
void osnos_os_setmesshandler(void * addr);
int64_t osnos_os_filelastwritetime(uint8_t * filename);
int64_t osnos_os_hpcounter(void);
int64_t osnos_os_hpfrequency(void);
void osnos_os_getsystime(void * tm);
void osnos_os_peek(void);
int64_t pci_runpcl(uint8_t * filename,int64_t filetype);
void pci_run_initdata(void);
int64_t pci_runpcprogram(void);
static void pci_initbytecode(void);
static void pci_disploop(void);
static void pci_pclinit(void);
static void pci_fixup_all_pc(void);
static void pci_fixup_module_pc(int64_t mx);
static int64_t * pci_disploop_fn(int64_t n);
static void pci_disploop_deb(void);
void pci_runproc(void * fnptr,struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * dest);
static void pci_allocatestrings(void);
uint8_t * pci_compileq(uint8_t * qfilename);
static int64_t pci_loadpcfile(byte * s);
void pci_initpcldata(void);
static struct pc_decls_strec * pci_createstentry(int64_t index,uint8_t * name,int64_t owner,int64_t id);
static int64_t * pci_getprocaddr(int64_t n);
void pci_pcl_initusertypes(void);
void pci_setcmdparam(int64_t index,uint8_t * s);
void pc_support_prterror(uint8_t * mess);
int64_t pc_support_testelem(byte (*p)[],int64_t n);
void pc_support_setelem(byte (*p)[],int64_t n);
void pc_support_pcustype_def(uint8_t * mess,struct pc_decls_varrec * x);
int64_t * pc_support_pcustype(uint8_t * mess,struct pc_decls_varrec * x);
int64_t * pc_support_pcustypet(uint8_t * mess,int64_t t);
void pc_support_pcmxtypes_def(uint8_t * mess,struct pc_decls_varrec * x,struct pc_decls_varrec * y);
int64_t * pc_support_pcmxtypes(uint8_t * mess,struct pc_decls_varrec * x,struct pc_decls_varrec * y);
int64_t * pc_support_pcmxtypestt(uint8_t * mess,int64_t s,int64_t t);
uint8_t * pc_support_gettypename(int64_t t);
void pc_support_inittypetables(void);
int64_t * pc_support_pcerror(uint8_t * mess);
void pc_support_vxunimpl(uint8_t * mess);
void pc_support_pclunimpl(int64_t cmd);
uint8_t * pc_support_convcstring(uint8_t * svalue,int64_t length);
int64_t pc_support_getintvalue(struct pc_decls_varrec * p);
int64_t pc_support_nextpoweroftwo(int64_t x);
void pc_support_showlinenumber(void);
static void pc_support_printlinenumber(int64_t lineno,int64_t moduleno,uint8_t * calledfrom);
void pc_support_findlinenumber(int64_t * ptr,int64_t * lineno,int64_t * moduleno);
int64_t pc_support_findpcindex(int64_t * ptr,int64_t * moduleno);
void pc_support_showlinetable(uint8_t * caption,int64_t i);
void pc_support_writezstring(void * f,uint8_t * s);
void pc_support_writezint(void * f,int64_t x);
void pc_support_writezint4(void * f,int64_t x);
void pc_support_writezrange(void * f,byte * p);
void pc_support_writezreal(void * f,double x);
void pc_support_writezeof(void * f);
static void pc_support_zerror(uint8_t * mess);
int64_t pc_support_readzvalue(byte * * pp,int32_t * dest,int32_t * dest2);
int64_t pc_support_readzint(byte * * p);
int64_t pc_support_readzdint(byte * * p);
double pc_support_readzreal(byte * * p);
uint8_t * pc_support_readzstring(byte * * p,int64_t * ilength);
byte * pc_support_readzblock(byte * * pp,int64_t length);
void pc_support_checkmt(int64_t id);
int64_t pc_support_ipower(int64_t a,int64_t n);
void pc_support_loaderror(uint8_t * mess,uint8_t * mess2);
int64_t pc_support_gettypesig(int64_t s,int64_t t);
uint8_t * pc_support_getfnname(void * fnaddr);
void pc_support_junimpl(uint8_t * s);
int64_t * pc_misc_raiseexception(int64_t exceptno);
void pc_misc_raise_error(int64_t error_no);
static void pc_misc_default_exception(int64_t exceptno);
void pc_pcfns_pc_unshare(struct pc_decls_varrec * p);
void pc_pcfns_pc_free(struct pc_decls_varrec * p);
struct pc_decls_varrec * pc_pcfns_pc_share(struct pc_decls_varrec * p);
void pc_pcfns_pc_dupl(struct pc_decls_varrec * p);
void pc_pcfns_j_free_s(struct pc_decls_varrec * p);
void pc_pcfns_j_free_m(struct pc_decls_varrec * p);
void pc_pcfns_j_free_l_d(struct pc_decls_varrec * p);
void pc_pcfns_j_free_k(struct pc_decls_varrec * p);
void pc_pcfns_j_free_a(struct pc_decls_varrec * p);
void pc_pcfns_j_free_j(struct pc_decls_varrec * p);
void pc_pcfns_j_free_b_e(struct pc_decls_varrec * p);
void pc_pcfns_j_dupl_s(struct pc_decls_varrec * p);
void pc_pcfns_j_dupl_l_m_d(struct pc_decls_varrec * p);
void pc_pcfns_j_dupl_a(struct pc_decls_varrec * p);
void pc_pcfns_j_dupl_j(struct pc_decls_varrec * p);
void pc_pcfns_j_dupl_b(struct pc_decls_varrec * p);
void pc_pcfns_j_dupl_e(struct pc_decls_varrec * p);
void pc_pcfns_j_dupl_k(struct pc_decls_varrec * p);
void pc_pcfns_pc_makelist(int64_t n,struct pc_decls_varrec * a,struct pc_decls_varrec * b,int64_t lower);
void pc_pcfns_pc_makerecord(int64_t n,int64_t t,struct pc_decls_varrec * a,struct pc_decls_varrec * b);
void pc_pcfns_pc_makearray(int64_t n,int64_t arraytype,int64_t elemtype,int64_t lower,struct pc_decls_varrec * a,struct pc_decls_varrec * b);
void pc_pcfns_pc_makerange(struct pc_decls_varrec * x,struct pc_decls_varrec * y,struct pc_decls_varrec * z);
void pc_pcfns_pc_makeset(int64_t n,struct pc_decls_varrec * data,struct pc_decls_varrec * dest);
void pc_pcfns_pc_makestruct(int64_t n,int64_t t,struct pc_decls_varrec * a,struct pc_decls_varrec * b);
void pc_pcfns_pc_makedict(int64_t n,struct pc_decls_varrec * a,struct pc_decls_varrec * b);
void pc_pcfns_pc_storepacked(byte * p,struct pc_decls_varrec * q,int64_t t);
static void pc_pcfns_adddictitem(struct pc_decls_varrec * d,struct pc_decls_varrec * p,struct pc_decls_varrec * q);
int64_t pc_pcfns_gethashvalue(struct pc_decls_varrec * p);
struct pc_decls_varrec * pc_pcfns_finddictitem(struct pc_decls_varrec * vd,struct pc_decls_varrec * p,int64_t doins);
static void pc_pcfns_expanddict(struct pc_decls_varrec * vd);
static void pc_pcfns_setfslength(uint8_t * s,int64_t m,int64_t n);
int64_t pc_pcfns_getfslength(uint8_t * s,int64_t m);
void pc_pcfns_pc_storeptr(struct pc_decls_varrec * p,struct pc_decls_varrec * q);
void pc_pcfns_pc_storebit(byte * p,int64_t shift,struct pc_decls_varrec * q,int64_t t,int64_t bitlength);
void pc_pcfns_pc_popptrlist(struct pc_decls_varrec * p,struct pc_decls_varrec * q);
void pc_pcfns_pc_loadpacked(void * p,int64_t t,struct pc_decls_varrec * dest,struct pc_decls_objrec * ownerobj);
void pc_pcfns_pc_loadbit(byte * p,int64_t shift,int64_t t,int64_t bitlength,struct pc_decls_varrec * dest);
void pc_pcfns_pc_loadptr(struct pc_decls_varrec * x,struct pc_decls_varrec * y);
void pc_pcfns_pc_storestring(struct pc_decls_varrec * p,struct pc_decls_varrec * q);
void pc_pcfns_pc_iconvert(int64_t t,struct pc_decls_varrec * x);
void pc_pcfns_pc_iconvcase(struct pc_decls_varrec * a,struct pc_decls_varrec * b,int64_t upper);
int64_t pc_pcfns_pc_eqstring_nf(struct pc_decls_varrec * x,struct pc_decls_varrec * y);
int64_t pc_pcfns_pc_equal_nf(struct pc_decls_varrec * x,struct pc_decls_varrec * y,int64_t shallow);
int64_t pc_pcfns_comparebytes(byte * p,byte * q,int64_t n);
int64_t pc_pcfns_pc_compare_nf(struct pc_decls_varrec * x,struct pc_decls_varrec * y);
int64_t pc_pcfns_cmpstring_len(uint8_t * s,uint8_t * t,int64_t slen,int64_t tlen);
int64_t pc_pcfns_pc_eqstring(struct pc_decls_varrec * x,struct pc_decls_varrec * y);
int64_t pc_pcfns_pc_equal(struct pc_decls_varrec * x,struct pc_decls_varrec * y,int64_t shallow);
int64_t pc_pcfns_pc_compare(struct pc_decls_varrec * x,struct pc_decls_varrec * y);
int64_t pc_pcfns_u8inarray(byte a,struct pc_decls_objrec * p);
int64_t pc_pcfns_u16inarray(uint16_t a,struct pc_decls_objrec * p);
int64_t pc_pcfns_u32inarray(uint32_t a,struct pc_decls_objrec * p);
int64_t pc_pcfns_u64inarray(uint64_t a,struct pc_decls_objrec * p);
int64_t pc_pcfns_bitinbits(byte a,struct pc_decls_objrec * p);
int64_t pc_pcfns_pc_strinstr(struct pc_decls_varrec * x,struct pc_decls_varrec * y);
byte * pc_pcfns_getbitoffset(byte * p,int64_t offset,int64_t index,int64_t t,byte * newoffset);
void pc_pcfns_pc_iappendlist(struct pc_decls_varrec * a,struct pc_decls_varrec * b);
void pc_pcfns_pc_iappendarray(struct pc_decls_varrec * a,struct pc_decls_varrec * b);
void pc_pcfns_pc_mul_listi(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c);
void pc_pcfns_pc_mul_stri(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c);
void pc_pcfns_pc_duplvar(struct pc_decls_varrec * p);
void pc_pcfns_pc_iconcatlist(struct pc_decls_varrec * a,struct pc_decls_varrec * b);
void pc_pcfns_pc_iappendbits(struct pc_decls_varrec * a,struct pc_decls_varrec * b);
void pc_pcfns_pc_makestring(uint8_t * s,int64_t length,struct pc_decls_varrec * dest);
void pc_pcfns_pc_makestringx(uint8_t * s,int64_t length,int64_t allocated,struct pc_decls_varrec * dest);
void pc_pcfns_pc_makestringn(int64_t length,struct pc_decls_varrec * dest);
void pc_pcfns_pc_emptystring(struct pc_decls_varrec * dest);
void pc_pcfns_pc_makechar(int64_t ch,struct pc_decls_varrec * dest);
static void pc_objlib_Dinit(void);
struct pc_decls_objrec * pc_objlib_obj_new(int64_t tag);
void pc_objlib_freeobject(struct pc_decls_objrec * p);
struct pc_decls_objrec * pc_objlib_array_new(int64_t ta,int64_t elemtype,int64_t length,int64_t lower);
struct pc_decls_objrec * pc_objlib_list_new(int64_t length,int64_t lower,struct pc_decls_varrec * defval);
void pc_objlib_objtovar(struct pc_decls_objrec * p,struct pc_decls_varrec * q);
struct pc_decls_objrec * pc_objlib_set_new(int64_t length,int64_t lower);
struct pc_decls_objrec * pc_objlib_bits_new(int64_t elemtype,int64_t length,int64_t lower);
struct pc_decls_objrec * pc_objlib_struct_new(int64_t t);
struct pc_decls_objrec * pc_objlib_dict_new(int64_t n);
struct pc_decls_objrec * pc_objlib_record_new(int64_t rectype);
void pc_objlib_list_free(struct pc_decls_objrec * p);
void pc_objlib_record_free(struct pc_decls_objrec * p);
void pc_objlib_array_free(struct pc_decls_objrec * p);
void pc_objlib_bits_free(struct pc_decls_objrec * p);
void pc_objlib_dict_free(struct pc_decls_objrec * p);
int64_t pc_objlib_bits_bytesize(struct pc_decls_objrec * p);
void pc_objlib_list_resize(struct pc_decls_objrec * p,int64_t n);
void pc_objlib_array_resize(struct pc_decls_objrec * p,int64_t n);
void pc_objlib_bits_resize(struct pc_decls_objrec * p,int64_t n);
void pc_objlib_string_resize(struct pc_decls_objrec * p,int64_t n);
struct pc_decls_objrec * pc_objlib_copyonwrite(struct pc_decls_objrec * p,int64_t tag);
struct pc_decls_objrec * pc_objlib_make_strslicexobj(uint8_t * s,int64_t length);
struct pc_decls_objrec * pc_objlib_bignum_make(void * bn);
void pc_bignum_bx_makestr(uint8_t * s,int64_t length,struct pc_decls_varrec * p);
uint8_t * pc_bignum_bx_tostring(struct pc_decls_varrec * a,int64_t fmt);
void pc_bignum_bx_dupl(struct pc_decls_varrec * p);
void pc_bignum_bx_negto(struct pc_decls_varrec * p);
void pc_bignum_bx_absto(struct pc_decls_varrec * p);
static struct mbignum_bignumrec * pc_bignum_makebnvar(struct pc_decls_varrec * dest,struct mbignum_bignumrec * bn);
void pc_bignum_bx_free(struct pc_decls_varrec * a);
void pc_bignum_bx_makeint(int64_t aa,struct pc_decls_varrec * dest);
void pc_bignum_bx_add(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c);
void pc_bignum_bx_sub(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c);
void pc_bignum_bx_mul(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c);
void pc_bignum_bx_div(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c);
void pc_bignum_bx_idiv(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c);
void pc_bignum_bx_irem(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c);
int64_t pc_bignum_bx_equal(struct pc_decls_varrec * a,struct pc_decls_varrec * b);
int64_t pc_bignum_bx_cmp(struct pc_decls_varrec * a,struct pc_decls_varrec * b);
int64_t pc_bignum_bx_int(struct pc_decls_varrec * p);
void pc_bignum_bx_power(struct pc_decls_varrec * a,int64_t n,struct pc_decls_varrec * dest);
void pc_bignum_bx_reduce(struct pc_decls_varrec * bn);
int64_t pc_bignum_bx_length(struct pc_decls_varrec * bn);
struct mbignum_bignumrec * mbignum_bn_init(void);
static int64_t mbignum_readexpon(uint8_t * s);
void mbignum_bn_print(struct mbignum_bignumrec * a,int64_t format);
void mbignum_bn_println(struct mbignum_bignumrec * a,int64_t format);
static int64_t mbignum_getbintype(struct mbignum_bignumrec * a,struct mbignum_bignumrec * b);
static struct mbignum_bignumrec * mbignum_makebignum(int64_t length);
static int32_t * mbignum_makesmallnum(int64_t length);
static struct mbignum_bignumrec * mbignum_smalltobig(struct mbignum_bignumrec * c,int32_t * a,int64_t length,int64_t alloc,int64_t offset);
static void mbignum_freesmall(int32_t * p,int64_t length);
void * mbignum_bn_alloc(int64_t size);
void * mbignum_checkedmalloc(int64_t size);
void mbignum_bn_free(struct mbignum_bignumrec * a);
static void mbignum_freemem(void * p,int64_t size);
void mbignum_bn_setzero(struct mbignum_bignumrec * a);
void mbignum_bn_move(struct mbignum_bignumrec * a,struct mbignum_bignumrec * b);
void mbignum_bn_dupl(struct mbignum_bignumrec * a,struct mbignum_bignumrec * b);
void mbignum_bn_setinf(struct mbignum_bignumrec * dest);
void mbignum_bn_setnan(struct mbignum_bignumrec * dest);
static void mbignum_bn_error(uint8_t * mess);
int64_t mbignum_bn_iszero(struct mbignum_bignumrec * a);
void mbignum_bn_negto(struct mbignum_bignumrec * a);
void mbignum_bn_absto(struct mbignum_bignumrec * a);
int64_t mbignum_bn_isint(struct mbignum_bignumrec * a);
int64_t mbignum_bn_getprec(struct mbignum_bignumrec * a);
void mbignum_bn_setprec(struct mbignum_bignumrec * a,int64_t prec);
int64_t mbignum_bn_getglobalprec(void);
void mbignum_bn_setglobalprec(int64_t prec);
struct mbignum_bignumrec * mbignum_bn_makeint(int64_t x);
struct mbignum_bignumrec * mbignum_bn_makefloat(double x);
void mbignum_bn_ipower(struct mbignum_bignumrec * d,struct mbignum_bignumrec * a,int64_t n);
static int64_t mbignum_smallsubto(int32_t * p,int32_t * q,int64_t plen,int64_t qlen);
static int64_t mbignum_smallmulto(int32_t * p,int32_t * q,int64_t plen,int64_t m);
int64_t mbignum_bn_equal(struct mbignum_bignumrec * a,struct mbignum_bignumrec * b);
void mbignum_bn_addu(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b);
static void mbignum_bn_subu(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b);
static void mbignum_bn_mulu(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b);
static int32_t mbignum_smalldiv(int32_t * x,int32_t * b,int64_t * xlen,int64_t nb);
void mbignum_bn_idivu(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b,struct mbignum_bignumrec * rm);
static int64_t mbignum_strvaln(uint8_t * s,int64_t n);
struct mbignum_bignumrec * mbignum_bn_makestr(uint8_t * s,int64_t length);
static void mbignum_bn_fdivu(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b,int64_t precision);
static uint8_t * mbignum_tostring_float(struct mbignum_bignumrec * a,int64_t fmt);
uint8_t * mbignum_bn_tostring(struct mbignum_bignumrec * a,int64_t fmt);
static uint8_t * mbignum_tostring_scient(struct mbignum_bignumrec * a);
int64_t mbignum_bn_add(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b);
int64_t mbignum_bn_sub(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b);
int64_t mbignum_bn_mul(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b);
int64_t mbignum_bn_mulp(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b,int64_t prec);
int64_t mbignum_bn_div(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b,int64_t prec);
int64_t mbignum_bn_idiv(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b);
int64_t mbignum_bn_idivrem(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * rm,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b);
int64_t mbignum_bn_irem(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b);
int64_t mbignum_bn_cmp(struct mbignum_bignumrec * a,struct mbignum_bignumrec * b);
struct mbignum_bignumrec * mbignum_bn_const(int64_t value);
int64_t mbignum_bn_sign(struct mbignum_bignumrec * a);
static struct mbignum_bignumrec * mbignum_badnumber(void);
int64_t mbignum_bn_digits(struct mbignum_bignumrec * a);
int64_t mbignum_bn_toint(struct mbignum_bignumrec * a);
double mbignum_bn_tofloat(struct mbignum_bignumrec * a);
void mbignum_bn_fix(struct mbignum_bignumrec * c,struct mbignum_bignumrec * a);
void mbignum_bntest(struct mbignum_bignumrec * a);
void pc_print_pch_print(struct pc_decls_varrec * p,struct pc_decls_varrec * fmt);
void pc_print_pch_println(void);
void pc_print_pch_startprintcon(void);
void pc_print_pch_startprint(struct pc_decls_varrec * p);
void pc_print_pch_endprint(void);
void pc_print_pch_strstartprint(void);
void pc_print_pch_strendprint(struct pc_decls_varrec * dest);
void pc_print_pch_setformat(struct pc_decls_varrec * p);
void pc_print_pch_setformat2(struct pc_decls_varrec * p);
void pc_print_pch_dprint(struct pc_decls_varrec * p,struct pc_decls_varrec * fmt);
void pc_print_pch_printnogap(void);
static void pc_print_initfmtcode(struct pc_decls_fmtrec * f);
static int64_t pc_print_i64mintostr(uint8_t * s,int64_t base,int64_t sep);
static int64_t pc_print_u64tostr(uint64_t aa,uint8_t * s,uint64_t base,int64_t sep);
static int64_t pc_print_i64tostrfmt(int64_t aa,uint8_t * s,struct pc_decls_fmtrec * fmt,int64_t usigned);
static int64_t pc_print_u64tostrfmt(int64_t aa,uint8_t * s,struct pc_decls_fmtrec * fmt);
static int64_t pc_print_strtostrfmt(uint8_t * s,uint8_t * t,int64_t n,struct pc_decls_fmtrec * fmt);
static int64_t pc_print_expandstr(uint8_t * s,uint8_t * t,int64_t n,struct pc_decls_fmtrec * fmt);
void pc_print_pc_strtofmt(uint8_t * s,int64_t slen,struct pc_decls_fmtrec * fmt);
static void pc_print_printstrz(uint8_t * s);
static void pc_print_printstr_n(uint8_t * s,int64_t n);
void pc_print_printerror(uint8_t * s);
void pc_print_addstring(struct pc_decls_objrec * p,uint8_t * t,int64_t n);
void pc_print_j_tostr_i(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
void pc_print_j_tostr_r(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
void pc_print_j_tostr_w(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
void pc_print_j_tostr_n(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
void pc_print_j_tostr_s(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
void pc_print_j_tostr_l_m(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
void pc_print_j_tostr_a(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
void pc_print_j_tostr_b(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
void pc_print_j_tostr_e(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
void pc_print_j_tostr_k(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
void pc_print_j_tostr_j(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
void pc_print_j_tostr_d(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
void pc_print_j_tostr_z(struct pc_decls_varrec * a,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
static void pc_print_printnextfmtchars(int64_t lastx);
static int64_t pc_print_getreadfmtcode(struct pc_decls_varrec * p);
void pc_print_pch_sreadln(struct pc_decls_varrec * dev,struct pc_decls_varrec * dest);
void pc_print_pch_strtoval(struct pc_decls_varrec * p,struct pc_decls_varrec * fmt,struct pc_decls_varrec * dest);
void pc_print_pch_reread(void);
void pc_print_pch_rereadln(void);
static uint8_t * pc_print_readname(uint8_t * s,int64_t length,struct pc_decls_varrec * dest);
static uint8_t * pc_print_readstring(uint8_t * s,int64_t length,struct pc_decls_varrec * dest);
static uint8_t * pc_print_readint(uint8_t * sold,int64_t length,struct pc_decls_varrec * dest);
static uint8_t * pc_print_readhex(uint8_t * sold,int64_t length,struct pc_decls_varrec * dest);
static uint8_t * pc_print_readbin(uint8_t * sold,int64_t length,struct pc_decls_varrec * dest);
static uint8_t * pc_print_readreal(uint8_t * sold,int64_t length,struct pc_decls_varrec * dest);
void pc_print_pch_readln(struct pc_decls_varrec * dev);
static void pc_print_stepkbpos(uint8_t * s);
void pc_print_pch_sread(struct pc_decls_varrec * fmt,struct pc_decls_varrec * dest);
static void pc_print_domultichar(uint8_t * p,int64_t n,uint8_t * dest,struct pc_decls_fmtrec * fmt);
void pc_print_pch_tostr(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result);
struct pc_decls_fmtrec * pc_print_pc_getfmt(struct pc_decls_varrec * p,struct pc_decls_fmtrec * fmt);
static void pc_print_pc_readlinen(void * handlex,uint8_t * buffer,int64_t size);
static uint8_t * pc_print_readitem(uint8_t * s,int64_t length,uint8_t * * itemstr,int64_t * itemlength);
static uint8_t * pc_print_readany(uint8_t * sold,int64_t length,struct pc_decls_varrec * dest);
static void pc_print_strtoreal(uint8_t * s,int64_t length,struct pc_decls_varrec * dest);
static void pc_print_strtoint(uint8_t * s,int64_t length,struct pc_decls_varrec * dest);
static void pc_print_calltostrtable(struct pc_decls_varrec * q,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
static uint8_t * pc_print_printbn(struct pc_decls_varrec * a0,struct pc_decls_fmtrec * fmt,int64_t * length);
void pc_jhandlers_initcalltables(void);
static void pc_jhandlers_initjhandler(uint8_t * p,void * fnaddr);
static void pc_jhandlers_add_stable_entry(void * (*table)[],int64_t t,void * fnaddr);
static void pc_jhandlers_add_dtable_entry(uint64_t * (*(*table)[])(void),int64_t s,int64_t t,void * fnaddr);
static void pc_jhandlers_def_handler(void);
static void pc_jhandlers_ddef_handler(void);
int64_t * pc_jhandlers_j_add_i_w(void);
int64_t * pc_jhandlers_j_add_r(void);
int64_t * pc_jhandlers_j_add_s(void);
int64_t * pc_jhandlers_j_add_j(void);
int64_t * pc_jhandlers_j_add_e(void);
int64_t * pc_jhandlers_j_add_z(void);
int64_t * pc_jhandlers_j_add_iw_wi(void);
int64_t * pc_jhandlers_j_add_zz(void);
int64_t * pc_jhandlers_j_sub_i_w(void);
int64_t * pc_jhandlers_j_sub_r(void);
int64_t * pc_jhandlers_j_sub_p(void);
int64_t * pc_jhandlers_j_sub_j(void);
int64_t * pc_jhandlers_j_sub_e(void);
int64_t * pc_jhandlers_j_sub_z(void);
int64_t * pc_jhandlers_j_sub_zz(void);
static int64_t * pc_jhandlers_j_mixed_iw_wi(void);
static int64_t * pc_jhandlers_j_mixed_ir(void);
static int64_t * pc_jhandlers_j_mixed_ri(void);
static int64_t * pc_jhandlers_j_mixed_ij(void);
static int64_t * pc_jhandlers_j_mixed_ji(void);
int64_t * pc_jhandlers_j_mul_i_w(void);
int64_t * pc_jhandlers_j_mul_r(void);
int64_t * pc_jhandlers_j_mul_j(void);
int64_t * pc_jhandlers_j_mul_z(void);
int64_t * pc_jhandlers_j_mul_li(void);
int64_t * pc_jhandlers_j_mul_si(void);
int64_t * pc_jhandlers_j_mul_e(void);
int64_t * pc_jhandlers_j_mul_zz(void);
int64_t * pc_jhandlers_j_div_i(void);
int64_t * pc_jhandlers_j_div_r(void);
int64_t * pc_jhandlers_j_div_j(void);
int64_t * pc_jhandlers_j_div_z(void);
int64_t * pc_jhandlers_j_jumple_i(void);
int64_t * pc_jhandlers_j_jumple_r(void);
int64_t * pc_jhandlers_j_jumple_s(void);
int64_t * pc_jhandlers_j_jumple_z(void);
int64_t * pc_jhandlers_j_jumpeq_i_r_t_o(void);
int64_t * pc_jhandlers_j_jumpeq_v_p_f_g(void);
int64_t * pc_jhandlers_j_jumpeq_s(void);
int64_t * pc_jhandlers_j_jumpeq_z(void);
int64_t * pc_jhandlers_j_jumpeq_zz(void);
int64_t * pc_jhandlers_j_jumpne_i_r_t_o(void);
int64_t * pc_jhandlers_j_jumpne_v_p_f_g(void);
int64_t * pc_jhandlers_j_jumpne_s(void);
int64_t * pc_jhandlers_j_jumpne_z(void);
int64_t * pc_jhandlers_j_jumpne_zz(void);
int64_t * pc_jhandlers_j_jumpge_i(void);
int64_t * pc_jhandlers_j_jumpge_w(void);
int64_t * pc_jhandlers_j_jumpge_r(void);
int64_t * pc_jhandlers_j_jumpge_z(void);
int64_t * pc_jhandlers_j_jumpgt_i(void);
int64_t * pc_jhandlers_j_jumpgt_w(void);
int64_t * pc_jhandlers_j_jumpgt_r(void);
int64_t * pc_jhandlers_j_jumpgt_z(void);
int64_t * pc_jhandlers_j_jumplt_i(void);
int64_t * pc_jhandlers_j_jumplt_v_p(void);
int64_t * pc_jhandlers_j_jumplt_r(void);
int64_t * pc_jhandlers_j_jumplt_z(void);
int64_t * pc_jhandlers_j_pushix_li(void);
int64_t * pc_jhandlers_j_pushix_mi(void);
int64_t * pc_jhandlers_j_pushix_vi(void);
int64_t * pc_jhandlers_j_pushix_ln(void);
int64_t * pc_jhandlers_j_pushix_ll(void);
int64_t * pc_jhandlers_j_pushix_le(void);
int64_t * pc_jhandlers_j_pushix_ai(void);
int64_t * pc_jhandlers_j_pushix_bi_ei(void);
int64_t * pc_jhandlers_j_pushix_an(void);
int64_t * pc_jhandlers_j_pushix_si(void);
int64_t * pc_jhandlers_j_pushix_sn(void);
int64_t * pc_jhandlers_j_pushix_bn(void);
int64_t * pc_jhandlers_j_pushix_di(void);
int64_t * pc_jhandlers_j_pushix_zz(void);
int64_t * pc_jhandlers_j_pushixref_li(void);
int64_t * pc_jhandlers_j_pushixref_ln(void);
int64_t * pc_jhandlers_j_pushixref_ai(void);
int64_t * pc_jhandlers_j_pushixref_si(void);
int64_t * pc_jhandlers_j_pushixref_bi(void);
int64_t * pc_jhandlers_j_pushixref_zz(void);
int64_t * pc_jhandlers_j_pushdotix_si(void);
int64_t * pc_jhandlers_j_pushdotix_sn(void);
int64_t * pc_jhandlers_j_pushdotix_ii(void);
int64_t * pc_jhandlers_j_pushdotix_in(void);
int64_t * pc_jhandlers_j_pushdotix_ei(void);
int64_t * pc_jhandlers_j_pushdotix_mi(void);
int64_t * pc_jhandlers_j_pushdotix_zz(void);
int64_t * pc_jhandlers_j_pushdotixref_si(void);
int64_t * pc_jhandlers_j_pushdotixref_sn(void);
int64_t * pc_jhandlers_j_pushdotixref_ii(void);
int64_t * pc_jhandlers_j_pushdotixref_in_wn(void);
int64_t * pc_jhandlers_j_pushdotixref_ei(void);
int64_t * pc_jhandlers_j_pushdotixref_zz(void);
int64_t * pc_jhandlers_j_addto_i(void);
int64_t * pc_jhandlers_j_addto_r(void);
int64_t * pc_jhandlers_j_addto_s(void);
int64_t * pc_jhandlers_j_addto_p(void);
int64_t * pc_jhandlers_j_addto_z(void);
int64_t * pc_jhandlers_j_addto_si(void);
int64_t * pc_jhandlers_j_addto_ir(void);
int64_t * pc_jhandlers_j_addto_ri(void);
int64_t * pc_jhandlers_j_addto_zz(void);
int64_t * pc_jhandlers_j_subto_i(void);
int64_t * pc_jhandlers_j_subto_r(void);
int64_t * pc_jhandlers_j_subto_z(void);
int64_t * pc_jhandlers_j_subto_ir(void);
int64_t * pc_jhandlers_j_subto_ri(void);
int64_t * pc_jhandlers_j_subto_zz(void);
int64_t * pc_jhandlers_j_multo_i_w(void);
int64_t * pc_jhandlers_j_multo_r(void);
int64_t * pc_jhandlers_j_multo_z(void);
int64_t * pc_jhandlers_j_divto_i_w(void);
int64_t * pc_jhandlers_j_divto_r(void);
int64_t * pc_jhandlers_j_divto_z(void);
int64_t * pc_jhandlers_j_idivto_i(void);
int64_t * pc_jhandlers_j_idivto_z(void);
int64_t * pc_jhandlers_j_iand_i_w(void);
int64_t * pc_jhandlers_j_iand_e(void);
int64_t * pc_jhandlers_j_iand_z(void);
int64_t * pc_jhandlers_j_ior_i_w(void);
int64_t * pc_jhandlers_j_ior_e(void);
int64_t * pc_jhandlers_j_ior_z(void);
int64_t * pc_jhandlers_j_ixor_i_w(void);
int64_t * pc_jhandlers_j_ixor_e(void);
int64_t * pc_jhandlers_j_ixor_z(void);
int64_t * pc_jhandlers_j_iandto_i_w(void);
int64_t * pc_jhandlers_j_iandto_z(void);
int64_t * pc_jhandlers_j_iorto_i_w(void);
int64_t * pc_jhandlers_j_iorto_z(void);
int64_t * pc_jhandlers_j_ixorto_i_w(void);
int64_t * pc_jhandlers_j_ixorto_z(void);
int64_t * pc_jhandlers_j_shlto_i(void);
int64_t * pc_jhandlers_j_shlto_z(void);
int64_t * pc_jhandlers_j_shrto_i(void);
int64_t * pc_jhandlers_j_shrto_z(void);
int64_t * pc_jhandlers_j_concat_s(void);
int64_t * pc_jhandlers_j_concat_l(void);
int64_t * pc_jhandlers_j_concat_z(void);
int64_t * pc_jhandlers_j_concatto_s(void);
int64_t * pc_jhandlers_j_concatto_l(void);
int64_t * pc_jhandlers_j_concatto_z(void);
int64_t * pc_jhandlers_j_append_s(void);
int64_t * pc_jhandlers_j_append_l(void);
int64_t * pc_jhandlers_j_append_a(void);
int64_t * pc_jhandlers_j_append_b(void);
int64_t * pc_jhandlers_j_append_z(void);
int64_t * pc_jhandlers_j_appendto_s(void);
int64_t * pc_jhandlers_j_appendto_l(void);
int64_t * pc_jhandlers_j_appendto_a(void);
int64_t * pc_jhandlers_j_appendto_b_e(void);
int64_t * pc_jhandlers_j_appendto_z(void);
int64_t * pc_jhandlers_j_max_i(void);
int64_t * pc_jhandlers_j_max_r(void);
int64_t * pc_jhandlers_j_max_z(void);
int64_t * pc_jhandlers_j_min_z(void);
int64_t * pc_jhandlers_j_len_l_a_e_s_b_d(void);
int64_t * pc_jhandlers_j_len_m_k(void);
int64_t * pc_jhandlers_j_len_n(void);
int64_t * pc_jhandlers_j_len_z(void);
int64_t * pc_jhandlers_j_lwb_l(void);
int64_t * pc_jhandlers_j_lwb_a_b(void);
int64_t * pc_jhandlers_j_lwb_s_m_k_d(void);
int64_t * pc_jhandlers_j_lwb_e(void);
int64_t * pc_jhandlers_j_lwb_n(void);
int64_t * pc_jhandlers_j_lwb_z(void);
int64_t * pc_jhandlers_j_upb_l(void);
int64_t * pc_jhandlers_j_upb_a_b(void);
int64_t * pc_jhandlers_j_upb_s_d(void);
int64_t * pc_jhandlers_j_upb_m_k(void);
int64_t * pc_jhandlers_j_upb_e(void);
int64_t * pc_jhandlers_j_upb_n(void);
int64_t * pc_jhandlers_j_upb_z(void);
int64_t * pc_jhandlers_j_bounds_l_a_b_s_e(void);
int64_t * pc_jhandlers_j_bounds_m_k(void);
int64_t * pc_jhandlers_j_bounds_n(void);
int64_t * pc_jhandlers_j_bounds_z(void);
int64_t * pc_jhandlers_j_minto_i(void);
int64_t * pc_jhandlers_j_minto_r(void);
int64_t * pc_jhandlers_j_minto_z(void);
int64_t * pc_jhandlers_j_maxto_i(void);
int64_t * pc_jhandlers_j_maxto_r(void);
int64_t * pc_jhandlers_j_maxto_z(void);
int64_t * pc_jhandlers_j_neg_i_w(void);
int64_t * pc_jhandlers_j_neg_r(void);
int64_t * pc_jhandlers_j_neg_j(void);
int64_t * pc_jhandlers_j_neg_e(void);
int64_t * pc_jhandlers_j_neg_z(void);
int64_t * pc_jhandlers_j_abs_i_w(void);
int64_t * pc_jhandlers_j_abs_r(void);
int64_t * pc_jhandlers_j_abs_j(void);
int64_t * pc_jhandlers_j_abs_z(void);
int64_t * pc_jhandlers_j_inot_i_w(void);
int64_t * pc_jhandlers_j_inot_e(void);
int64_t * pc_jhandlers_j_inot_z(void);
int64_t * pc_jhandlers_j_istrue_i_w_r(void);
int64_t * pc_jhandlers_j_istrue_l_a_e_s_b(void);
int64_t * pc_jhandlers_j_istrue_k_m_h(void);
int64_t * pc_jhandlers_j_istrue_j(void);
int64_t * pc_jhandlers_j_istrue_z(void);
int64_t * pc_jhandlers_j_jumpfalse_i_w_r_v_p_f(void);
int64_t * pc_jhandlers_j_jumpfalse_s_l_e_a_b(void);
int64_t * pc_jhandlers_j_jumpfalse_z(void);
int64_t * pc_jhandlers_j_jumptrue_i_r_w_v_p_f(void);
int64_t * pc_jhandlers_j_jumptrue_s_l_e_a_b(void);
int64_t * pc_jhandlers_j_jumptrue_z(void);
int64_t * pc_jhandlers_j_shl_i_w(void);
int64_t * pc_jhandlers_j_shl_z(void);
int64_t * pc_jhandlers_j_shr_i_w(void);
int64_t * pc_jhandlers_j_shr_j_i(void);
int64_t * pc_jhandlers_j_shr_z(void);
int64_t * pc_jhandlers_j_shr_wi(void);
int64_t * pc_jhandlers_j_shr_zz(void);
int64_t * pc_jhandlers_j_idiv_w(void);
int64_t * pc_jhandlers_j_idiv_j(void);
int64_t * pc_jhandlers_j_idiv_z(void);
int64_t * pc_jhandlers_j_rem_w(void);
int64_t * pc_jhandlers_j_rem_j(void);
int64_t * pc_jhandlers_j_remz(void);
int64_t pc_oslayer_runproc_m(void * amsg);
void pc_oslayer_os_getconsize(struct pc_decls_varrec * result);
void pc_oslayer_pch_setmesshandler(struct pc_decls_varrec * fn);
void pc_oslayer_pch_gethostname(struct pc_decls_varrec * result);
void pc_oslayer_os_initdllmodules(void);
int64_t pc_oslayer_os_loaddllmodule(uint8_t * dllname);
void pc_oslayer_os_initdllfunctions(void);
void * pc_oslayer_os_loaddllfunction(int64_t fnindex);
void pc_oslayer_pch_getos(struct pc_decls_varrec * result);
void pc_oslayer_pch_gethostsize(struct pc_decls_varrec * result);
void pc_oslayer_pch_iswindows(struct pc_decls_varrec * result);
void pc_oslayer_os_calldll(int64_t calltype,int64_t fnindex,int64_t offset,int64_t nparams,int64_t restype,struct pc_decls_varrec * dest);
uint64_t osnosdll_os_calldllfunction(void (*fnaddr)(void),int64_t retcode,int64_t nargs,int64_t (*args)[],byte (*argcodes)[]);
uint64_t osnosdll_os_pushargs(uint64_t (*args)[],int64_t nargs,int64_t nextra,void (*fnaddr)(void),int64_t isfloat);
extern byte * imgload_bgr(uint8_t * filename,int64_t * x,int64_t * y,int64_t * channels,int64_t needchannels);
void pc_host_callhostfunction(int64_t hostfn,int64_t calledasfn);
static void pc_host_pch_leftstr(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c,struct pc_decls_varrec * result);
static void pc_host_pch_rightstr(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c,struct pc_decls_varrec * result);
static void pc_host_pch_convlc(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result);
static void pc_host_pch_convuc(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result);
static void pc_host_pch_iconvlc(struct pc_decls_varrec * a,struct pc_decls_varrec * b);
static void pc_host_pch_iconvuc(struct pc_decls_varrec * a,struct pc_decls_varrec * b);
static void pc_host_pch_stop(void);
static void pc_host_pch_stopx(struct pc_decls_varrec * a);
static void pc_host_pch_ismain(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_waitkey(struct pc_decls_varrec * result);
static void pc_host_pch_testkey(struct pc_decls_varrec * result);
static void pc_host_pch_execwait(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c,struct pc_decls_varrec * result);
static void pc_host_pch_execcmd(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c,struct pc_decls_varrec * result);
static void pc_host_pch_makestr(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result);
static void pc_host_pch_makestrslice(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result);
static void pc_host_pch_makeref(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result);
static void pc_host_pch_new(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c,struct pc_decls_varrec * d,struct pc_decls_varrec * result);
static void pc_host_pch_newheap(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c,struct pc_decls_varrec * d,struct pc_decls_varrec * result);
static void pc_host_pch_heapvar(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_freeheap(struct pc_decls_varrec * a);
static void pc_host_pch_getcmdparam(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_setpcerror(struct pc_decls_varrec * a);
static void pc_host_pch_setdebug(struct pc_decls_varrec * a);
static void pc_host_pch_setfprintf(struct pc_decls_varrec * a,struct pc_decls_varrec * b);
static void pc_host_pch_ticks(struct pc_decls_varrec * result);
static void pc_host_pch_sleep(struct pc_decls_varrec * a);
static void pc_host_pch_random(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_findmetafunction(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_loadpcl(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result);
static void pc_host_pch_runpcl(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result);
static void pc_host_pch_runtask(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result);
static void pc_host_pch_callext(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c);
static void pc_host_pch_system(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_shellexec(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result);
static void pc_host_pch_gethash(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_test(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result);
static void pc_host_pch_pcldata(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result);
static void pc_host_pch_getcstring(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_getparam(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_clearlist(struct pc_decls_varrec * a);
static void pc_host_pch_makelink(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_allparams(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_stackvars(struct pc_decls_varrec * result);
static void pc_host_pch_makeempty(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_readlines(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_dictitems(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_setoverload(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c);
static void pc_host_pch_errorinfo(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_getbounds(struct pc_decls_varrec * p,struct pc_host_dimrec * dims,int64_t lower);
static int64_t pc_host_checkparam(struct pc_decls_varrec * p,int64_t tag,int64_t defaultx);
static void pc_host_leftstring(struct pc_decls_varrec * a,int64_t n,struct pc_decls_varrec * result);
static void pc_host_rightstring(struct pc_decls_varrec * a,int64_t n,struct pc_decls_varrec * result);
static void pc_host_padstring_right(struct pc_decls_varrec * a,int64_t n,int64_t fillchar,struct pc_decls_varrec * result);
static void pc_host_padstring_left(struct pc_decls_varrec * a,int64_t n,int64_t fillchar,struct pc_decls_varrec * result);
static void pc_host_pcld_makevint(struct pc_decls_varrec * p,int64_t a);
static void pc_host_pcld_makelist(struct pc_decls_varrec * p,struct pc_decls_varrec * result,int64_t n);
static void pc_host_getproctabledata(struct pc_decls_procrec * p,struct pc_decls_varrec * result);
static int64_t * pc_host_convert_handler(int64_t _1);
static void pc_host_addtoproclist(struct pc_decls_strec * d);
static int64_t * pc_host_tostr_handler(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
static int64_t * pc_host_add_handler(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
static void pc_host_addovrecord(struct pc_host_overloadrec * * p,int64_t t,int64_t * fnptr);
static void (*pc_host_findapplproc(int64_t fnindex))(void);
void pc_host_do_callapplproc(int64_t fnindex,int64_t nargs,struct pc_decls_varrec * result);
static int64_t pc_host_vartopack(struct pc_decls_varrec * p,int64_t tp);
int64_t pc_host_dummyfn(int64_t a,int64_t b,int64_t c);
int64_t pc_host_pythag(int64_t n);
struct pc_decls_varrec * pc_host_new_random(struct pc_decls_varrec * a);
struct pc_decls_varrec * pc_host_new_heapvar(struct pc_decls_varrec * a);
int64_t pc_host_mfib(int64_t n);
void pc_dxfns_dx_iorset(struct pc_decls_varrec * x,struct pc_decls_varrec * y);
void pc_dxfns_dx_iandset(struct pc_decls_varrec * x,struct pc_decls_varrec * y);
void pc_dxfns_dx_ixorset(struct pc_decls_varrec * x,struct pc_decls_varrec * y);
void pc_dxfns_dx_inotset(struct pc_decls_varrec * x);
void pc_dxfns_dx_subset(struct pc_decls_varrec * x,struct pc_decls_varrec * y);
void pc_dxfns_inotsetbits(int64_t * p,int64_t n);
void pc_dxfns_iorsetbits(int64_t * p,int64_t * q,int64_t n);
void pc_dxfns_iandsetbits(int64_t * p,int64_t * q,int64_t n);
void pc_dxfns_ixorsetbits(int64_t * p,int64_t * q,int64_t n);
void pc_dxfns_subsetbits(int64_t * p,int64_t * q,int64_t n);
void pc_dxfns_iresizeset(struct pc_decls_varrec * p,int64_t n);
int64_t pc_dxfns_dx_varinvar(struct pc_decls_varrec * x,struct pc_decls_varrec * y);
int64_t pc_dxfns_dx_mixed(struct pc_decls_varrec * x,struct pc_decls_varrec * y);
void * pc_khandlers_k_zero(void);
void * pc_khandlers_k_nop(void);
void * pc_khandlers_k_procstart(void);
void * pc_khandlers_k_procend(void);
void * pc_khandlers_k_endmodule(void);
void * pc_khandlers_k_push_m(void);
void * pc_khandlers_k_push_f(void);
void * pc_khandlers_k_push_am(void);
void * pc_khandlers_k_push_af(void);
void * pc_khandlers_k_push_ap(void);
void * pc_khandlers_k_push_al(void);
void * pc_khandlers_k_push_ci(void);
void * pc_khandlers_k_push_cw(void);
void * pc_khandlers_k_push_cr(void);
void * pc_khandlers_k_push_cn(void);
void * pc_khandlers_k_push_cs(void);
void * pc_khandlers_k_push_t(void);
void * pc_khandlers_k_push_op(void);
void * pc_khandlers_k_pushz(void);
void * pc_khandlers_k_pushz_void(void);
void * pc_khandlers_k_pushz_str(void);
void * pc_khandlers_k_pushz_list(void);
void * pc_khandlers_k_pushz_listl(void);
void * pc_khandlers_k_pushz_set(void);
void * pc_khandlers_k_pushz_arrayl(void);
void * pc_khandlers_k_pop_m(void);
void * pc_khandlers_k_pop_f(void);
void * pc_khandlers_k_store_m(void);
void * pc_khandlers_k_store_f(void);
void * pc_khandlers_k_pushptr(void);
void * pc_khandlers_k_popptr(void);
void * pc_khandlers_k_storeptr(void);
void * pc_khandlers_k_zpop_m(void);
void * pc_khandlers_k_zpop_f(void);
void * pc_khandlers_k_zstore_m(void);
void * pc_khandlers_k_zstore_f(void);
void * pc_khandlers_k_copy(void);
void * pc_khandlers_k_swap(void);
void * pc_khandlers_k_convptr(void);
void * pc_khandlers_k_jump(void);
void * pc_khandlers_k_jumpptr(void);
void * pc_khandlers_k_jumptrue(void);
void * pc_khandlers_k_jumpfalse(void);
void * pc_khandlers_k_jumpdef(void);
void * pc_khandlers_k_jumpvoid(void);
void * pc_khandlers_k_jumpeq(void);
void * pc_khandlers_k_jumpne(void);
void * pc_khandlers_k_jumplt(void);
void * pc_khandlers_k_jumple(void);
void * pc_khandlers_k_jumpge(void);
void * pc_khandlers_k_jumpgt(void);
void * pc_khandlers_k_jumptesteq(void);
void * pc_khandlers_k_jumptestne(void);
void * pc_khandlers_k_jumplabel(void);
void * pc_khandlers_k_jumpclabel(void);
void * pc_khandlers_k_switch(void);
void * pc_khandlers_k_cswitch(void);
void * pc_khandlers_k_new(void);
void * pc_khandlers_k_to_f(void);
void * pc_khandlers_k_for_fci(void);
void * pc_khandlers_k_for_ff(void);
void * pc_khandlers_k_ford_fci(void);
void * pc_khandlers_k_ford_ff(void);
void * pc_khandlers_k_call(void);
void * pc_khandlers_k_callptr(void);
void * pc_khandlers_k_return(void);
void * pc_khandlers_k_startdll(void);
void * pc_khandlers_k_pushdll(void);
void * pc_khandlers_k_calldll(void);
void * pc_khandlers_k_callhost(void);
void * pc_khandlers_k_stackframe(void);
void * pc_khandlers_k_free(void);
void * pc_khandlers_k_addsp(void);
void * pc_khandlers_k_stop(void);
void * pc_khandlers_k_test(void);
void * pc_khandlers_k_makelist(void);
void * pc_khandlers_k_makerecord(void);
void * pc_khandlers_k_makearray(void);
void * pc_khandlers_k_makestruct(void);
void * pc_khandlers_k_makeset(void);
void * pc_khandlers_k_makerange(void);
void * pc_khandlers_k_makedict(void);
void * pc_khandlers_k_pushdot(void);
void * pc_khandlers_k_pushdotref(void);
void * pc_khandlers_k_softconv(void);
void * pc_khandlers_k_hardconv(void);
void * pc_khandlers_k_mixed(void);
void * pc_khandlers_k_incrptr(void);
void * pc_khandlers_k_incrto_m(void);
void * pc_khandlers_k_incrto_f(void);
void * pc_khandlers_k_loadincr(void);
void * pc_khandlers_k_incrload(void);
void * pc_khandlers_k_decrptr(void);
void * pc_khandlers_k_decrto_m(void);
void * pc_khandlers_k_decrto_f(void);
void * pc_khandlers_k_loaddecr(void);
void * pc_khandlers_k_decrload(void);
void * pc_khandlers_k_incr(void);
void * pc_khandlers_k_decr(void);
void * pc_khandlers_k_neg(void);
void * pc_khandlers_k_abs(void);
void * pc_khandlers_k_not(void);
void * pc_khandlers_k_inot(void);
void * pc_khandlers_k_istrue(void);
void * pc_khandlers_k_asc(void);
void * pc_khandlers_k_chr(void);
void * pc_khandlers_k_sqrt(void);
void * pc_khandlers_k_sqr(void);
void * pc_khandlers_k_cube(void);
void * pc_khandlers_k_sin(void);
void * pc_khandlers_k_cos(void);
void * pc_khandlers_k_tan(void);
void * pc_khandlers_k_asin(void);
void * pc_khandlers_k_acos(void);
void * pc_khandlers_k_atan(void);
void * pc_khandlers_k_sign(void);
void * pc_khandlers_k_ln(void);
void * pc_khandlers_k_log(void);
void * pc_khandlers_k_lg(void);
void * pc_khandlers_k_exp(void);
void * pc_khandlers_k_round(void);
void * pc_khandlers_k_floor(void);
void * pc_khandlers_k_ceil(void);
void * pc_khandlers_k_fract(void);
void * pc_khandlers_k_negto(void);
void * pc_khandlers_k_absto(void);
void * pc_khandlers_k_notto(void);
void * pc_khandlers_k_inotto(void);
void * pc_khandlers_k_len(void);
void * pc_khandlers_k_lwb(void);
void * pc_khandlers_k_upb(void);
void * pc_khandlers_k_bounds(void);
void * pc_khandlers_k_bits(void);
void * pc_khandlers_k_bytes(void);
void * pc_khandlers_k_type(void);
void * pc_khandlers_k_elemtype(void);
void * pc_khandlers_k_basetype(void);
void * pc_khandlers_k_minval(void);
void * pc_khandlers_k_maxval(void);
void * pc_khandlers_k_isint(void);
void * pc_khandlers_k_isreal(void);
void * pc_khandlers_k_isstring(void);
void * pc_khandlers_k_isrange(void);
void * pc_khandlers_k_isnumber(void);
void * pc_khandlers_k_isarray(void);
void * pc_khandlers_k_isrecord(void);
void * pc_khandlers_k_ispointer(void);
void * pc_khandlers_k_ismutable(void);
void * pc_khandlers_k_isset(void);
void * pc_khandlers_k_isvoid(void);
void * pc_khandlers_k_isdef(void);
void * pc_khandlers_k_tostr(void);
void * pc_khandlers_k_isequal(void);
void * pc_khandlers_k_add(void);
void * pc_khandlers_k_sub(void);
void * pc_khandlers_k_mul(void);
void * pc_khandlers_k_div(void);
void * pc_khandlers_k_idiv(void);
void * pc_khandlers_k_rem(void);
void * pc_khandlers_k_divrem(void);
void * pc_khandlers_k_iand(void);
void * pc_khandlers_k_ior(void);
void * pc_khandlers_k_ixor(void);
void * pc_khandlers_k_shl(void);
void * pc_khandlers_k_shr(void);
void * pc_khandlers_k_in(void);
void * pc_khandlers_k_notin(void);
void * pc_khandlers_k_inrev(void);
void * pc_khandlers_k_eq(void);
void * pc_khandlers_k_ne(void);
void * pc_khandlers_k_lt(void);
void * pc_khandlers_k_le(void);
void * pc_khandlers_k_ge(void);
void * pc_khandlers_k_gt(void);
void * pc_khandlers_k_min(void);
void * pc_khandlers_k_max(void);
void * pc_khandlers_k_concat(void);
void * pc_khandlers_k_append(void);
void * pc_khandlers_k_power(void);
void * pc_khandlers_k_atan2(void);
void * pc_khandlers_k_addto(void);
void * pc_khandlers_k_subto(void);
void * pc_khandlers_k_multo(void);
void * pc_khandlers_k_divto(void);
void * pc_khandlers_k_idivto(void);
void * pc_khandlers_k_iandto(void);
void * pc_khandlers_k_iorto(void);
void * pc_khandlers_k_ixorto(void);
void * pc_khandlers_k_shlto(void);
void * pc_khandlers_k_shrto(void);
void * pc_khandlers_k_minto(void);
void * pc_khandlers_k_maxto(void);
void * pc_khandlers_k_concatto(void);
void * pc_khandlers_k_appendto(void);
void * pc_khandlers_k_pushix(void);
void * pc_khandlers_k_pushdotix(void);
void * pc_khandlers_k_pushkeyix(void);
void * pc_khandlers_k_pushkeyixd(void);
void * pc_khandlers_k_pushixref(void);
void * pc_khandlers_k_pushdotixref(void);
void * pc_khandlers_k_pushkeyixref(void);
void * pc_khandlers_k_pushbyteix(void);
void * pc_khandlers_k_pushbyteixref(void);
void * pc_khandlers_k_appendset(void);
void * pc_khandlers_k_pushdotm(void);
void * pc_khandlers_k_pushdott(void);
void * pc_khandlers_k_push_ad(void);
void * pc_khandlers_k_push_try(void);
void * pc_khandlers_k_raise(void);
void * pc_khandlers_k_applyop(void);
void * pc_khandlers_k_makeiter(void);
void * pc_khandlers_k_forall(void);
void * pc_khandlers_k_forallx(void);
void * pc_khandlers_k_foreach(void);
void * pc_khandlers_k_foreachx(void);
void * pc_khandlers_k_expandrange(void);
void * pc_khandlers_k_callappl(void);
void pc_assemc_fixup_asm(int64_t mx);
int64_t pc_assemc_asmavailable(void);
void pc_assemc_addcountint(void * cmd);
void pc_assemc_addcountext(void);
void pc_assemc_showasmcmd(void * cmd);
int64_t * pc_assemc_disploop_asm(void);
uint64_t pc_assemc_getasmjump(int64_t cmd);
int64_t qci_qcompiler_prod(uint8_t * locinfile,uint8_t * locoutfile,int64_t intlibs,int64_t fdocs);
void qci_do_loadmodules(uint8_t * infile);
static int64_t qci_loadmainmodule(uint8_t * filespec);
static int64_t qci_addmodule(uint8_t * modulename,uint8_t * filespec,uint8_t * source,int64_t length,int64_t id,int64_t * exportflag);
static int64_t qci_loadimport(uint8_t * modulename,int64_t * exportflag,uint8_t * ownername);
static int64_t qci_readimportlist(struct var_decls_modulerec * m,uint8_t * (*importnames)[],byte (*importflags)[],int64_t maximports);
void qci_initdata(void);
void qci_initsearchdirs(void);
static void qci_addsearchdir(uint8_t * path);
static uint8_t * qci_getmodulestr(uint8_t * modulename,uint8_t * filespec);
static uint8_t * qci_findmodule(uint8_t * modulename);
static int64_t qci_checkname(uint8_t * name,int64_t length);
void qci_do_parse(void);
void qci_do_name(void);
void qci_do_pclgen(void);
void qci_loaderror(uint8_t * mess,uint8_t * mess2);
static void qci_getsyscmdline(void);
static void qci_checkkeyword(uint8_t * kwd);
static int64_t qci_readinttoken(void);
void qci_do_writepcfile(void);
static void qci_writesymbols(int64_t mx);
static void qci_showpcsymbol(struct var_decls_strec * d);
static void qci_writepccode2pc(int64_t mx);
static void qci_writestructfields(void);
static void qci_fixup_genfields(void);
static void qci_showhelp(void);
int64_t qci_nextcmd(int64_t * paramno,uint8_t * * name,uint8_t * * value,uint8_t * defext);
void qci_writedocs(void);
static void qci_do_writeqa(uint8_t * outfile);
void qc_support_prterror(uint8_t * mess);
void qc_support_serror_gen(uint8_t * mess);
void qc_support_serror(uint8_t * mess);
void qc_support_serror_ss(uint8_t * mess,uint8_t * a,uint8_t * b);
void qc_support_serror_s(uint8_t * mess,uint8_t * a);
void qc_support_error_gen(int64_t pass,uint8_t * mess,struct var_decls_unitrec * p);
void qc_support_rxerror(uint8_t * mess,struct var_decls_unitrec * p);
void qc_support_gerror(uint8_t * mess,struct var_decls_unitrec * p);
void qc_support_rxerror_s(uint8_t * mess,uint8_t * a,struct var_decls_unitrec * p);
int64_t qc_support_testelem(byte (*p)[],int64_t n);
void qc_support_setelem(byte (*p)[],int64_t n);
void qc_support_inittypetables(void);
int64_t qc_support_nextpoweroftwo(int64_t x);
void qc_support_initpcdest(void);
int64_t qc_support_getpcpos(void);
void qc_support_setpcpos(int64_t pos);
int64_t qc_support_writepcdata(uint8_t * filename);
void qc_support_writezstring(uint8_t * s);
void qc_support_writezblock(byte * s,int64_t length);
void qc_support_writezint(int64_t x);
void qc_support_writezint4(int64_t x);
void qc_support_writezrange(byte * p);
void qc_support_writezreal(double x);
void qc_support_writezeof(void);
int64_t qc_support_ipower(int64_t a,int64_t n);
void qc_support_gs_additem(struct mlib_strbuffer * dest,uint8_t * s);
static int64_t qc_support_isalphanum(int64_t c);
static void qc_support_outpcbyte(int64_t x);
static void qc_support_outpcword(int64_t x);
static void qc_support_outpcword16(int64_t x);
void qc_support_writeqafile(uint8_t * destfile);
void qc_support_addqafile(uint8_t * filespec,uint8_t * source,int64_t length);
void qc_lex_lexreadtoken(void);
static void qc_lex_lxreadstring(int64_t termchar);
static void qc_lex_readnumber(int64_t base);
static void qc_lex_readrealnumber(uint8_t * intstart,int64_t intlen,int64_t base);
static int64_t qc_lex_readexponent(int64_t base);
static void qc_lex_lxerror(uint8_t * mess);
void qc_lex_printsymbol(struct qc_lex_lexrec * lp);
static void qc_lex_stringtonumber(uint8_t * s,int64_t length,int64_t base,int64_t numtype);
void qc_lex_lexsetup(void);
static byte * qc_lex_scannumber(int64_t base);
static void qc_lex_readrawstring(void);
static int64_t qc_lex_lookup(void);
static uint64_t qc_lex_gethashvaluez(uint8_t * s);
static void qc_lex_inithashtable(void);
static int64_t qc_lex_dolexdirective(int64_t index);
static void qc_lex_lexreadline(void);
void qc_lex_startlex(uint8_t * caption,uint8_t * sourcecode);
uint8_t * qc_lex_convertzstring(uint8_t * s,int64_t length);
struct var_decls_strec * qc_lex_addnamestr(uint8_t * name);
void qc_lex_ps1(uint8_t * caption);
void qc_lex_ps2(uint8_t * caption);
void qc_lex_ps(uint8_t * caption);
void qc_lex_lex(void);
void qc_lex_showhashtablesize(void);
static void qc_lex_addmacro(struct var_decls_strec * symptr,uint8_t * value,int64_t length);
static void qc_lex_stackmacro(uint8_t * s);
static void qc_lex_unstackmacro(void);
int64_t qc_parse_parsemodule(int64_t n);
int64_t qc_parse_readmoduledefs(struct var_decls_strec * owner);
static void qc_parse_initparser(void);
static void qc_parse_skipsemi(void);
static void qc_parse_addalias(struct var_decls_strec * stold,struct var_decls_strec * stnew);
static struct var_decls_unitrec * qc_parse_makeblock(struct var_decls_unitrec * p);
static void qc_parse_checkequals(void);
static int64_t qc_parse_getcurrline(void);
static int64_t qc_parse_checkbegin(int64_t fbrack);
static void qc_parse_checkbeginend(int64_t closesym,int64_t kwd,int64_t startline);
static void qc_parse_checkend(int64_t endsym,int64_t endkwd1,int64_t endkwd2,int64_t startline);
static void qc_parse_addgenfield(struct var_decls_strec * d);
static void qc_parse_readvardef(struct var_decls_strec * owner,int64_t isglobal,int64_t isstatic,int64_t varid);
static void qc_parse_readconstdef(struct var_decls_strec * owner,int64_t isglobal);
static struct var_decls_unitrec * qc_parse_readexpression(void);
static struct var_decls_unitrec * qc_parse_readfactor(int64_t level);
static struct var_decls_unitrec * qc_parse_readterm(void);
static struct var_decls_unitrec * qc_parse_readlbrack(void);
static void qc_parse_addlistunit(struct var_decls_unitrec * * ulist,struct var_decls_unitrec * * ulistx,struct var_decls_unitrec * p);
static void qc_parse_addlistparam(struct var_decls_strec * * ulist,struct var_decls_strec * * ulistx,struct var_decls_strec * p);
static struct var_decls_unitrec * qc_parse_readlsqbrack(void);
static struct var_decls_unitrec * qc_parse_readcast(void);
static struct var_decls_unitrec * qc_parse_readopc(void);
static struct var_decls_unitrec * qc_parse_readsprint(void);
static struct var_decls_unitrec * qc_parse_readsread(void);
static struct var_decls_unitrec * qc_parse_readcompilervar(void);
static struct var_decls_unitrec * qc_parse_readcastx(void);
void qc_parse_checksymbol(int64_t symbol);
static int64_t qc_parse_readtypespec(struct var_decls_strec * owner,int64_t typedefx);
static struct var_decls_unitrec * qc_parse_readhostparams(struct var_decls_unitrec * lhs,int64_t isfn);
static struct var_decls_unitrec * qc_parse_readslist(int64_t iscall,int64_t donulls);
static struct var_decls_unitrec * qc_parse_readindex(struct var_decls_unitrec * p,int64_t dot);
static struct var_decls_unitrec * qc_parse_readkeyindex(struct var_decls_unitrec * p,int64_t dot);
static struct var_decls_unitrec * qc_parse_readdotsuffix(struct var_decls_unitrec * p);
int64_t qc_parse_isconstexpr(struct var_decls_unitrec * p);
static struct var_decls_unitrec * qc_parse_readconstexpr(struct var_decls_strec * owner,int64_t needconst);
static int64_t qc_parse_readconstexprvalue(struct var_decls_strec * owner);
static int64_t qc_parse_readconstint(void);
static void qc_parse_readprocdef(struct var_decls_strec * procowner,int64_t isglobal,int64_t fflang);
struct var_decls_strec * qc_parse_readprocdecl(struct var_decls_strec * procowner,int64_t isglobal,int64_t fflang);
static struct var_decls_strec * qc_parse_readparams(struct var_decls_strec * owner,int64_t * nparams);
static struct var_decls_strec * qc_parse_readparamsff(struct var_decls_strec * procowner,struct var_decls_strec * owner,int64_t * varparams,int64_t * nparams);
static struct var_decls_strec * qc_parse_readparamsff_types(int64_t pmode,struct var_decls_strec * procowner,struct var_decls_strec * owner,int64_t * varparams,int64_t * nparams);
static struct var_decls_strec * qc_parse_readparamsff_names(int64_t pmode,struct var_decls_strec * procowner,struct var_decls_strec * owner,int64_t * varparams,int64_t * nparams);
static struct var_decls_unitrec * qc_parse_readblock(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readexecstmt(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readstmtexpr(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readcondsuffix(struct var_decls_unitrec * p);
static struct var_decls_unitrec * qc_parse_readif(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readgoto(struct var_decls_strec * owner,int64_t gototag);
static struct var_decls_unitrec * qc_parse_readunless(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readswitchcase(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readstop(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readreturn(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readdo(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readto(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readwhile(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readrepeat(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readloopcontrol(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readprint(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readread(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readtry(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readraise(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readfor(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readforall(struct var_decls_strec * owner);
void qc_parse_readtypedef(struct var_decls_strec * owner,int64_t isglobal);
static int64_t qc_parse_readstructdef(struct var_decls_strec * owner,int64_t typedefx,int64_t kwd);
void qc_parse_readstructfields(struct var_decls_strec * owner,int64_t m);
void qc_parse_readtabledef(struct var_decls_strec * owner,int64_t isglobal);
void qc_parse_readclassdef(struct var_decls_strec * owner,int64_t isglobal);
static void qc_parse_readclassbody(struct var_decls_strec * owner,int64_t classkwd);
static int64_t qc_parse_readenumtype(struct var_decls_strec * owner,int64_t typedefx,int64_t isglobal);
void qc_parse_readrecordfields(struct var_decls_strec * owner);
static void qc_parse_readimportmodule(struct var_decls_strec * owner);
static void qc_parse_readimportbody(struct var_decls_strec * owner);
static struct var_decls_strec * qc_parse_createprocdef(struct var_decls_strec * owner,struct var_decls_strec * stname,int64_t id,uint8_t * truename);
static struct var_decls_strec * qc_parse_readequivfield(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_testconstruct(struct var_decls_unitrec * p);
static struct var_decls_unitrec * qc_parse_readapplyop(int64_t inexpr);
static void qc_parse_readapplprocs(struct var_decls_strec * owner);
static struct var_decls_strec * qc_parse_defineapplproc(void);
static struct var_decls_strec * qc_parse_findapplproc(uint8_t * name);
static void qc_parse_addapplproc(struct var_decls_strec * d);
static struct var_decls_unitrec * qc_parse_readapplcall(void);
static struct var_decls_strec * qc_lib_newstrec(void);
void qc_lib_initqclib(void);
struct var_decls_strec * qc_lib_getduplnameptr(struct var_decls_strec * owner,struct var_decls_strec * symptr,int64_t id);
void qc_lib_adddef(struct var_decls_strec * owner,struct var_decls_strec * p);
void qc_lib_adddef_nodupl(struct var_decls_strec * owner,struct var_decls_strec * p);
void qc_lib_printst(void * f,struct var_decls_strec * p,int64_t level);
static void qc_lib_printstrec(void * f,struct var_decls_strec * p,int64_t level);
void qc_lib_printstflat(void * f);
static struct var_decls_unitrec * qc_lib_newunitrec(void);
struct var_decls_unitrec * qc_lib_createname(struct var_decls_strec * p);
struct var_decls_unitrec * qc_lib_createunit0(int64_t tag);
struct var_decls_unitrec * qc_lib_createunit1(int64_t tag,struct var_decls_unitrec * p);
struct var_decls_unitrec * qc_lib_createunit2(int64_t tag,struct var_decls_unitrec * p,struct var_decls_unitrec * q);
struct var_decls_unitrec * qc_lib_createunit3(int64_t tag,struct var_decls_unitrec * p,struct var_decls_unitrec * q,struct var_decls_unitrec * r);
struct var_decls_unitrec * qc_lib_createconstunit(uint64_t a,int64_t t);
struct var_decls_unitrec * qc_lib_createstringconstunit(uint8_t * s,int64_t length);
int64_t qc_lib_getoptocode(int64_t opc);
int64_t qc_lib_checkpackedtype(int64_t m);
void qc_lib_checkunpackedtype(int64_t t);
int64_t qc_lib_checkdlltype(int64_t m);
int64_t qc_lib_createtype(struct var_decls_strec * d);
int64_t qc_lib_createusertype(struct var_decls_strec * stname);
int64_t qc_lib_createusertypefromstr(uint8_t * name);
int64_t qc_lib_getconstvalue(struct var_decls_unitrec * p,int64_t id);
int64_t qc_lib_getrangelwb(struct var_decls_unitrec * p);
int64_t qc_lib_getrangeupb(struct var_decls_unitrec * p);
struct var_decls_unitrec * qc_lib_getrangelwbunit(struct var_decls_unitrec * p);
struct var_decls_unitrec * qc_lib_getrangeupbunit(struct var_decls_unitrec * p);
int64_t qc_lib_createarraymode(struct var_decls_strec * owner,int64_t target,struct var_decls_unitrec * lower,struct var_decls_unitrec * length,int64_t typedefx);
uint8_t * qc_lib_nextautotype(void);
int64_t qc_lib_createstringmode(struct var_decls_strec * owner,int64_t t,struct var_decls_unitrec * lengthx,int64_t typedefx);
int64_t qc_lib_createrefpackmode(struct var_decls_strec * owner,int64_t target,int64_t typedefx);
int64_t qc_lib_getscope(struct var_decls_strec * p);
void qc_lib_setnameptr(struct var_decls_unitrec * p);
void qc_lib_printcode(void * f,uint8_t * caption);
void qc_lib_printunit(struct var_decls_unitrec * p,int64_t level,uint8_t * prefix,void * dev);
static void qc_lib_printunitlist(void * dev,struct var_decls_unitrec * p,int64_t level,uint8_t * prefix);
static uint8_t * qc_lib_getprefix(int64_t level,uint8_t * prefix,struct var_decls_unitrec * p);
uint8_t * qc_lib_getdottedname(struct var_decls_strec * p);
static uint8_t * qc_lib_getlineinfok(void);
struct var_decls_strec * qc_lib_getavname(struct var_decls_strec * owner,int64_t id);
void qc_lib_unionstr_clear(struct var_decls_uflagsrec * u);
void qc_lib_unionstr_append(struct var_decls_uflagsrec * u,int64_t c);
void qc_lib_unionstr_concat(struct var_decls_uflagsrec * u,struct var_decls_uflagsrec * v);
int64_t qc_lib_unionstr_last(struct var_decls_uflagsrec * u);
void qc_lib_unionstr_copy(struct var_decls_uflagsrec * u,struct var_decls_uflagsrec * v);
void qc_lib_unionstr_print(struct var_decls_uflagsrec * u);
int64_t qc_lib_createrecordmode(struct var_decls_strec * owner,int64_t t,int64_t typedefx);
int64_t qc_lib_createenummode(struct var_decls_strec * owner,int64_t typedefx);
void qc_lib_convertstring(uint8_t * s,uint8_t * t);
struct mlib_strbuffer * qc_lib_strexpr(struct var_decls_unitrec * p);
static void qc_lib_jeval(struct mlib_strbuffer * dest,struct var_decls_unitrec * p);
uint8_t * qc_lib_getopcjname(int64_t opc);
uint8_t * qc_lib_strmode(int64_t m,int64_t expand);
void qc_lib_istrmode(int64_t m,int64_t expand,uint8_t * dest);
int64_t qc_lib_countunits(struct var_decls_unitrec * p);
struct var_decls_strec * qc_lib_finddefstr(struct var_decls_strec * owner,uint8_t * name);
static void qc_lib_purgesymbol(struct var_decls_strec * p,struct var_decls_strec * prev,int64_t del);
void qc_lib_purgesymbollist(struct var_decls_strec * p,int64_t ismodule,int64_t del);
void qc_lib_purgeprocs(struct var_decls_strec * p,int64_t del);
void qc_lib_purgeproc(struct var_decls_strec * p,int64_t del);
void qc_lib_printmodelist(void * f);
void qc_lib_printgenfieldtable(void * f,uint8_t * caption);
void qc_lib_addtoproclist(struct var_decls_strec * d);
int64_t qc_lib_newusertypex(struct var_decls_strec * d,struct var_decls_strec * e);
void qc_lib_storemode(struct var_decls_strec * owner,int64_t m,int16_t * p);
struct var_decls_unitrec * qc_lib_duplunit(struct var_decls_unitrec * p);
void qc_name_rx_unit(struct var_decls_strec * owner,struct var_decls_unitrec * p);
int64_t qc_name_rx_module(int64_t n);
void qc_name_rx_deflist(struct var_decls_strec * owner,struct var_decls_strec * p);
void qc_name_rx_passdef(struct var_decls_strec * owner,struct var_decls_strec * p);
static void qc_name_rx_unitlist(struct var_decls_strec * owner,struct var_decls_unitrec * p);
struct var_decls_strec * qc_name_resolvetopname(struct var_decls_strec * owner,struct var_decls_strec * stnewname,int64_t moduleno,int64_t fmodule);
void qc_name_resolvename(struct var_decls_strec * owner,struct var_decls_unitrec * p,int64_t mode);
struct var_decls_strec * qc_name_finddupl(struct var_decls_strec * d,struct var_decls_strec * pdupl);
static void qc_name_resolvedot(struct var_decls_strec * owner,struct var_decls_unitrec * p);
static void qc_name_fixmode(struct var_decls_strec * owner,struct var_decls_strec * p);
static int64_t qc_name_fixmode2(struct var_decls_strec * owner,int64_t m);
void qc_name_fixusertypes(void);
struct var_decls_strec * qc_name_resolve_equiv_name(struct var_decls_strec * owner,struct var_decls_strec * p);
static struct var_decls_strec * qc_name_addframevar(struct var_decls_strec * owner,struct var_decls_strec * d,int64_t moduleno,int64_t mode);
static void qc_name_converteqeq(struct var_decls_strec * owner,struct var_decls_unitrec * p);
void qc_name_evalbinop(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_name_evalbinop_real(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_name_makenewconst(struct var_decls_unitrec * p,int64_t value,int64_t t);
void qc_name_evalmonop(struct var_decls_unitrec * p);
void qc_name_tx_typetable(void);
static void qc_name_checkconstexpr(struct var_decls_unitrec * a);
void qc_name_converttype(int64_t m);
static int64_t qc_name_scanstruct(int64_t fstruct,struct var_decls_strec * (*flist)[],int64_t flistlen,int64_t * index,int64_t nextoffset,int64_t countmode);
static int64_t qc_name_scanrecord(struct var_decls_strec * (*flist)[],int64_t flistlen);
static void qc_name_shiftflagsleft(struct var_decls_uflagsrec * flags);
static int64_t qc_name_getconstint(struct var_decls_strec * owner,struct var_decls_unitrec * a);
int64_t qc_name_checkdict(struct var_decls_unitrec * p);
void qc_name_checkconstlist(struct var_decls_unitrec * p);
static void qc_name_duplfield(struct var_decls_strec * p,struct var_decls_strec * q);
static void qc_name_dobaseclass(int64_t baseclassindex);
static void qc_pclgen_evalexpr(struct var_decls_unitrec * p);
static void qc_pclgen_do_stmt(struct var_decls_unitrec * p);
int64_t qc_pclgen_codegen(int64_t n);
static void qc_pclgen_scanidata(struct var_decls_strec * p);
static void qc_pclgen_genidata(struct var_decls_strec * p);
static void qc_pclgen_initgenpcl(int64_t sourcelen);
void qc_pclgen_doprogramstartup(void);
static void qc_pclgen_do_block(struct var_decls_unitrec * p);
static void qc_pclgen_do_print(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_pclgen_do_fprint(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b,struct var_decls_unitrec * c);
static void qc_pclgen_do_read(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_pclgen_do_assign(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_pclgen_do_to(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b,struct var_decls_unitrec * c);
static void qc_pclgen_do_while(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b,struct var_decls_unitrec * c);
static void qc_pclgen_do_repeat(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_pclgen_do_forstep(struct var_decls_unitrec * p,struct var_decls_unitrec * pvar,struct var_decls_unitrec * pbody,struct var_decls_unitrec * pautovar);
static void qc_pclgen_do_forall(struct var_decls_unitrec * p,struct var_decls_unitrec * pindex,struct var_decls_unitrec * pbody,struct var_decls_unitrec * pautovar);
static void qc_pclgen_do_do(struct var_decls_unitrec * p,struct var_decls_unitrec * a);
static void qc_pclgen_do_cfor(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_pclgen_do_if(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b,struct var_decls_unitrec * pelse);
static void qc_pclgen_do_longif(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_pclgen_do_callproc(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_pclgen_do_callhostproc(struct var_decls_unitrec * p,struct var_decls_unitrec * a);
static void qc_pclgen_do_return(struct var_decls_unitrec * p,struct var_decls_unitrec * a);
static void qc_pclgen_genstartproc(struct var_decls_strec * dmodule);
static void qc_pclgen_do_procdef(struct var_decls_strec * p);
static void qc_pclgen_genprocentry(struct var_decls_strec * p,int64_t * nfreevars,int64_t * nnofreevars);
static void qc_pclgen_genprocexit(int64_t nfree,int64_t nnofree);
static void qc_pclgen_do_preincr(struct var_decls_unitrec * p,struct var_decls_unitrec * a);
static void qc_pclgen_do_exit(struct var_decls_unitrec * p,struct var_decls_unitrec * a);
static void qc_pclgen_do_goto(struct var_decls_unitrec * p,struct var_decls_unitrec * a);
static void qc_pclgen_do_switch(struct var_decls_unitrec * p,struct var_decls_unitrec * pindex,struct var_decls_unitrec * pwhenthen,struct var_decls_unitrec * pelse);
static void qc_pclgen_do_simpleswitch(struct var_decls_unitrec * p,struct var_decls_unitrec * pindex,struct var_decls_unitrec * pwhenthen,struct var_decls_unitrec * pelse,int64_t a,int64_t b);
static void qc_pclgen_do_case(struct var_decls_unitrec * p,struct var_decls_unitrec * pindex,struct var_decls_unitrec * pwhenthen,struct var_decls_unitrec * pelse);
static void qc_pclgen_do_try(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_pclgen_do_applyop(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b,struct var_decls_unitrec * c);
static void qc_pclgen_evalref(struct var_decls_unitrec * p);
static int64_t qc_pclgen_getpclop(int64_t opc);
static void qc_pclgen_genjumpl(int64_t lab);
static int64_t qc_pclgen_definelabel(void);
static int64_t qc_pclgen_createfwdlabel(void);
static void qc_pclgen_definefwdlabel(int64_t * oldlab);
static void qc_pclgen_stacklooplabels(int64_t * a,int64_t * b,int64_t * c,int64_t * d);
static void qc_pclgen_unstacklooplabels(void);
static int64_t qc_pclgen_findlooplabel(int64_t k,int64_t n);
static int64_t qc_pclgen_issimpleparam(struct var_decls_unitrec * p);
static void qc_pclgen_genjumpcond(int64_t opc,struct var_decls_unitrec * p,int64_t lab);
static void qc_pclgen_gcomparejump(int64_t jumpopc,struct var_decls_unitrec * p,struct var_decls_unitrec * lhs,struct var_decls_unitrec * rhs,int64_t lab);
static int64_t qc_pclgen_reversecond(int64_t op);
static void qc_pclgen_do_convert(int64_t m,struct var_decls_unitrec * p);
static void qc_pclgen_do_selectx(struct var_decls_unitrec * pindex,struct var_decls_unitrec * pplist,struct var_decls_unitrec * pelse);
static void qc_pclgen_do_calldll(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static int64_t qc_pclgen_islogical(struct var_decls_unitrec * p);
static void qc_pclgen_do_and(struct var_decls_unitrec * x,struct var_decls_unitrec * y);
static void qc_pclgen_do_or(struct var_decls_unitrec * x,struct var_decls_unitrec * y);
static void qc_pclgen_do_callptr(struct var_decls_unitrec * p,struct var_decls_unitrec * pproc,struct var_decls_unitrec * pparams);
static void qc_pclgen_do_callmproc(struct var_decls_unitrec * p,struct var_decls_unitrec * pproc,struct var_decls_unitrec * pparams,int64_t calledasfn);
static int64_t qc_pclgen_checkblockreturn(struct var_decls_unitrec * p);
static void qc_pclgen_genfree(int64_t n);
static void qc_pclgen_do_clamp(struct var_decls_unitrec * x,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_pclgen_do_applyopx(struct var_decls_unitrec * x,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_pclgen_do_calldllvar(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_pclgen_callhostfn(int64_t fnindex,int64_t calledasfn);
static void qc_pclgen_extractparams(struct var_decls_strec * d,struct var_decls_strec * (*params)[]);
static int64_t qc_pclgen_unitstoarray(struct var_decls_unitrec * p,struct var_decls_unitrec * (*plist)[],int64_t maxunits);
static void qc_pclgen_do_idiv(struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static int64_t qc_pclgen_ispoweroftwo(int64_t x);
static void qc_pclgen_genpushint(uint64_t a);
static void qc_pclgen_do_callappl(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b,int64_t callasfn);
void qc_pcllib_initpcl(int64_t size);
void qc_pcllib_initpcldata(void);
void qc_pcllib_initpclgen(void);
static void qc_pcllib_writepcl3(int64_t pc);
static uint8_t * qc_pcllib_writepclopnd3(int64_t fmt,int64_t x,int64_t n,int64_t cmdcode);
struct mlib_strbuffer * qc_pcllib_writepccode(uint8_t * caption,int64_t n);
void qc_pcllib_genpc(int64_t opc);
void qc_pcllib_genopnd_int(int64_t x);
void qc_pcllib_genopnd_s(struct var_decls_strec * d);
void qc_pcllib_genpc_int(int64_t opc,int64_t a);
void qc_pcllib_genpc_int2(int64_t opc,int64_t a,int64_t b);
void qc_pcllib_genpc_int4(int64_t opc,int64_t a,int64_t b,int64_t c,int64_t d);
void qc_pcllib_genpc_s(int64_t opc,struct var_decls_strec * d);
void qc_pcllib_genpc_str(int64_t opc,uint8_t * s,int64_t length);
void qc_pcllib_genopnd_str(uint8_t * s,int64_t length);
void qc_pcllib_genpc_lab(int64_t opc,int64_t a);
int64_t qc_pcllib_isframe_s(struct var_decls_strec * p);
int64_t qc_pcllib_addstringtotable(uint8_t * s,int64_t length);
uint8_t * q_libs_getintlib(uint8_t * name);

/* VARS */
static uint8_t *  qq_optionnames[10] = {(uint8_t*)"fn",(uint8_t*)"asm",(uint8_t*)"asmnop",(uint8_t*)"debug",(uint8_t*)"fdebug",(uint8_t*)"v",(uint8_t*)"help",(uint8_t*)"ext",(uint8_t*)"qa",(uint8_t*)"c"};
static uint8_t *  qq_inputfile;
static int64_t qq_fcompile;
static void *  msysnewc__fnaddresses[]= {
    &start,
    &qq_getinputoptions,
    &qq_do_option,
    &qq_getsyscmdline,
    &qq_showcaption,
    &qq_showhelp,
    &msysnewc_m_getdotindex,
    &msysnewc_m_setdotindex,
    &msysnewc_m_getdotslice,
    &msysnewc_m_setdotslice,
    &msysnewc_m_get_nprocs,
    &msysnewc_m_get_nexports,
    &msysnewc_m_get_procname,
    &msysnewc_m_get_procaddr,
    &msysnewc_m_get_procexport,
    &msysnewc_pushio,
    &msysnewc_m_print_startfile,
    &msysnewc_m_print_startstr,
    &msysnewc_m_print_startptr,
    &msysnewc_m_print_startcon,
    &msysnewc_m_print_setfmt,
    &msysnewc_m_print_end,
    &msysnewc_m_print_ptr,
    &msysnewc_m_print_i64,
    &msysnewc_m_print_u64,
    &msysnewc_m_print_r64,
    &msysnewc_m_print_r32,
    &msysnewc_m_print_c8,
    &msysnewc_m_print_str,
    &msysnewc_m_print_newline,
    &msysnewc_m_print_nogap,
    &msysnewc_printstr,
    &msysnewc_printstr_n,
    &msysnewc_printstrn_app,
    &msysnewc_makezstring,
    &msysnewc_freezstring,
    &msysnewc_printchar,
    &msysnewc_nextfmtchars,
    &msysnewc_strtofmt,
    &msysnewc_domultichar,
    &msysnewc_expandstr,
    &msysnewc_xdivrem,
    &msysnewc_u64tostr,
    &msysnewc_i64tostrfmt,
    &msysnewc_u64tostrfmt,
    &msysnewc_i64mintostr,
    &msysnewc_strtostrfmt,
    &msysnewc_tostr_i64,
    &msysnewc_tostr_u64,
    &msysnewc_tostr_r64,
    &msysnewc_tostr_str,
    &msysnewc_getfmt,
    &msysnewc_strint,
    &msysnewc_getstrint,
    &msysnewc_strword,
    &msysnewc_strreal,
    &msysnewc_getstr,
    &msysnewc_initreadbuffer,
    &msysnewc_m_read_conline,
    &msysnewc_m_read_fileline,
    &msysnewc_m_read_strline,
    &msysnewc_readitem,
    &msysnewc_strtoint,
    &msysnewc_m_read_i64,
    &msysnewc_m_read_r64,
    &msysnewc_m_read_str,
    &msysnewc_readstr,
    &msysnewc_rereadln,
    &msysnewc_reread,
    &msysnewc_valint,
    &msysnewc_valreal,
    &msysnewc_iconvlcn,
    &msysnewc_iconvucn,
    &msysnewc_convlcstring,
    &msysnewc_convucstring,
    &msysnewc_m_power_i64,
    &msysnewc_m_intoverflow,
    &msysnewc_m_dotindex,
    &msysnewc_m_dotslice,
    &msysnewc_m_popdotindex,
    &msysnewc_m_popdotslice,
    &msysnewc_m_imin,
    &msysnewc_m_imax,
    &msysnewc_m_sign,
    &mlib_pcm_alloc,
    &mlib_pcm_freestr,
    &mlib_pcm_free,
    &mlib_pcm_freeac,
    &mlib_pcm_copymem4,
    &mlib_pcm_clearmem,
    &mlib_pcm_init,
    &mlib_pcm_getac,
    &mlib_pcm_newblock,
    &mlib_pcm_round,
    &mlib_pcm_array,
    &mlib_pcm_printfreelist,
    &mlib_pcm_diags,
    &mlib_pcm_allocz,
    &mlib_pcm_copyheapstring,
    &mlib_pcm_copyheapstringn,
    &mlib_pcm_copyheapblock,
    &mlib_addtomemalloc,
    &mlib_removefrommemalloc,
    &mlib_allocmem,
    &mlib_reallocmem,
    &mlib_abortprogram,
    &mlib_getfilesize,
    &mlib_readrandom,
    &mlib_writerandom,
    &mlib_setfilepos,
    &mlib_getfilepos,
    &mlib_readfile,
    &mlib_writefile,
    &mlib_checkfile,
    &mlib_readlinen,
    &mlib_iconvlcn,
    &mlib_iconvucn,
    &mlib_convlcstring,
    &mlib_convucstring,
    &mlib_changeext,
    &mlib_extractext,
    &mlib_extractpath,
    &mlib_extractfile,
    &mlib_extractbasefile,
    &mlib_addext,
    &mlib_alloctable,
    &mlib_zalloctable,
    &mlib_checkfreelists,
    &mlib_pcm_alloc32,
    &mlib_pcm_free32,
    &mlib_outbyte,
    &mlib_outword16,
    &mlib_outword,
    &mlib_outword64,
    &mlib_myeof,
    &mlib_pcm_smallallocz,
    &mlib_pcm_smallalloc,
    &mlib_strbuffer_add,
    &mlib_gs_init,
    &mlib_gs_free,
    &mlib_gs_str,
    &mlib_gs_char,
    &mlib_gs_strn,
    &mlib_gs_strvar,
    &mlib_gs_strint,
    &mlib_gs_strln,
    &mlib_gs_strsp,
    &mlib_gs_line,
    &mlib_gs_getcol,
    &mlib_gs_leftstr,
    &mlib_gs_leftint,
    &mlib_gs_padto,
    &mlib_gs_println,
    &mlib_nextcmdparam,
    &mlib_readnextfileitem,
    &mlib_ipadstr,
    &mlib_padstr,
    &mlib_chr,
    &mlib_cmpstring,
    &mlib_cmpstringn,
    &mlib_eqstring,
    &mlib_cmpbytes,
    &mlib_eqbytes,
    &mlib_mseed,
    &mlib_mrandom,
    &mlib_mrandomp,
    &mlib_mrandomint,
    &mlib_mrandomrange,
    &mlib_mrandomreal,
    &mlib_mrandomreal1,
    &mlib_checkpackfile,
    &osnos_os_init,
    &osnos_os_execwait,
    &osnos_os_execcmd,
    &osnos_os_getch,
    &osnos_os_kbhit,
    &osnos_os_flushkeys,
    &osnos_os_getconsolein,
    &osnos_os_getconsoleout,
    &osnos_os_proginstance,
    &osnos_os_getdllinst,
    &osnos_os_getdllprocaddr,
    &osnos_os_initwindows,
    &osnos_os_getchx,
    &osnos_os_getos,
    &osnos_os_getoscode,
    &osnos_os_iswindows,
    &osnos_os_shellexec,
    &osnos_os_sleep,
    &osnos_os_getstdin,
    &osnos_os_getstdout,
    &osnos_os_gethostname,
    &osnos_os_gethostsize,
    &osnos_os_getmpath,
    &osnos_os_exitprocess,
    &osnos_os_gettimestamp,
    &osnos_os_gettickcount,
    &osnos_os_clock,
    &osnos_os_getclockspersec,
    &osnos_os_setmesshandler,
    &osnos_os_filelastwritetime,
    &osnos_os_hpcounter,
    &osnos_os_hpfrequency,
    &osnos_os_getsystime,
    &osnos_os_peek,
    &pci_runpcl,
    &pci_run_initdata,
    &pci_runpcprogram,
    &pci_initbytecode,
    &pci_disploop,
    &pci_pclinit,
    &pci_fixup_all_pc,
    &pci_fixup_module_pc,
    &pci_disploop_fn,
    &pci_disploop_deb,
    &pci_runproc,
    &pci_allocatestrings,
    &pci_compileq,
    &pci_loadpcfile,
    &pci_initpcldata,
    &pci_createstentry,
    &pci_getprocaddr,
    &pci_pcl_initusertypes,
    &pci_setcmdparam,
    &pc_support_prterror,
    &pc_support_testelem,
    &pc_support_setelem,
    &pc_support_pcustype_def,
    &pc_support_pcustype,
    &pc_support_pcustypet,
    &pc_support_pcmxtypes_def,
    &pc_support_pcmxtypes,
    &pc_support_pcmxtypestt,
    &pc_support_gettypename,
    &pc_support_inittypetables,
    &pc_support_pcerror,
    &pc_support_vxunimpl,
    &pc_support_pclunimpl,
    &pc_support_convcstring,
    &pc_support_getintvalue,
    &pc_support_nextpoweroftwo,
    &pc_support_showlinenumber,
    &pc_support_printlinenumber,
    &pc_support_findlinenumber,
    &pc_support_findpcindex,
    &pc_support_showlinetable,
    &pc_support_writezstring,
    &pc_support_writezint,
    &pc_support_writezint4,
    &pc_support_writezrange,
    &pc_support_writezreal,
    &pc_support_writezeof,
    &pc_support_zerror,
    &pc_support_readzvalue,
    &pc_support_readzint,
    &pc_support_readzdint,
    &pc_support_readzreal,
    &pc_support_readzstring,
    &pc_support_readzblock,
    &pc_support_checkmt,
    &pc_support_ipower,
    &pc_support_loaderror,
    &pc_support_gettypesig,
    &pc_support_getfnname,
    &pc_support_junimpl,
    &pc_misc_raiseexception,
    &pc_misc_raise_error,
    &pc_misc_default_exception,
    &pc_pcfns_pc_unshare,
    &pc_pcfns_pc_free,
    &pc_pcfns_pc_share,
    &pc_pcfns_pc_dupl,
    &pc_pcfns_j_free_s,
    &pc_pcfns_j_free_m,
    &pc_pcfns_j_free_l_d,
    &pc_pcfns_j_free_k,
    &pc_pcfns_j_free_a,
    &pc_pcfns_j_free_j,
    &pc_pcfns_j_free_b_e,
    &pc_pcfns_j_dupl_s,
    &pc_pcfns_j_dupl_l_m_d,
    &pc_pcfns_j_dupl_a,
    &pc_pcfns_j_dupl_j,
    &pc_pcfns_j_dupl_b,
    &pc_pcfns_j_dupl_e,
    &pc_pcfns_j_dupl_k,
    &pc_pcfns_pc_makelist,
    &pc_pcfns_pc_makerecord,
    &pc_pcfns_pc_makearray,
    &pc_pcfns_pc_makerange,
    &pc_pcfns_pc_makeset,
    &pc_pcfns_pc_makestruct,
    &pc_pcfns_pc_makedict,
    &pc_pcfns_pc_storepacked,
    &pc_pcfns_adddictitem,
    &pc_pcfns_gethashvalue,
    &pc_pcfns_finddictitem,
    &pc_pcfns_expanddict,
    &pc_pcfns_setfslength,
    &pc_pcfns_getfslength,
    &pc_pcfns_pc_storeptr,
    &pc_pcfns_pc_storebit,
    &pc_pcfns_pc_popptrlist,
    &pc_pcfns_pc_loadpacked,
    &pc_pcfns_pc_loadbit,
    &pc_pcfns_pc_loadptr,
    &pc_pcfns_pc_storestring,
    &pc_pcfns_pc_iconvert,
    &pc_pcfns_pc_iconvcase,
    &pc_pcfns_pc_eqstring_nf,
    &pc_pcfns_pc_equal_nf,
    &pc_pcfns_comparebytes,
    &pc_pcfns_pc_compare_nf,
    &pc_pcfns_cmpstring_len,
    &pc_pcfns_pc_eqstring,
    &pc_pcfns_pc_equal,
    &pc_pcfns_pc_compare,
    &pc_pcfns_u8inarray,
    &pc_pcfns_u16inarray,
    &pc_pcfns_u32inarray,
    &pc_pcfns_u64inarray,
    &pc_pcfns_bitinbits,
    &pc_pcfns_pc_strinstr,
    &pc_pcfns_getbitoffset,
    &pc_pcfns_pc_iappendlist,
    &pc_pcfns_pc_iappendarray,
    &pc_pcfns_pc_mul_listi,
    &pc_pcfns_pc_mul_stri,
    &pc_pcfns_pc_duplvar,
    &pc_pcfns_pc_iconcatlist,
    &pc_pcfns_pc_iappendbits,
    &pc_pcfns_pc_makestring,
    &pc_pcfns_pc_makestringx,
    &pc_pcfns_pc_makestringn,
    &pc_pcfns_pc_emptystring,
    &pc_pcfns_pc_makechar,
    &pc_objlib_Dinit,
    &pc_objlib_obj_new,
    &pc_objlib_freeobject,
    &pc_objlib_array_new,
    &pc_objlib_list_new,
    &pc_objlib_objtovar,
    &pc_objlib_set_new,
    &pc_objlib_bits_new,
    &pc_objlib_struct_new,
    &pc_objlib_dict_new,
    &pc_objlib_record_new,
    &pc_objlib_list_free,
    &pc_objlib_record_free,
    &pc_objlib_array_free,
    &pc_objlib_bits_free,
    &pc_objlib_dict_free,
    &pc_objlib_bits_bytesize,
    &pc_objlib_list_resize,
    &pc_objlib_array_resize,
    &pc_objlib_bits_resize,
    &pc_objlib_string_resize,
    &pc_objlib_copyonwrite,
    &pc_objlib_make_strslicexobj,
    &pc_objlib_bignum_make,
    &pc_bignum_bx_makestr,
    &pc_bignum_bx_tostring,
    &pc_bignum_bx_dupl,
    &pc_bignum_bx_negto,
    &pc_bignum_bx_absto,
    &pc_bignum_makebnvar,
    &pc_bignum_bx_free,
    &pc_bignum_bx_makeint,
    &pc_bignum_bx_add,
    &pc_bignum_bx_sub,
    &pc_bignum_bx_mul,
    &pc_bignum_bx_div,
    &pc_bignum_bx_idiv,
    &pc_bignum_bx_irem,
    &pc_bignum_bx_equal,
    &pc_bignum_bx_cmp,
    &pc_bignum_bx_int,
    &pc_bignum_bx_power,
    &pc_bignum_bx_reduce,
    &pc_bignum_bx_length,
    &mbignum_bn_init,
    &mbignum_readexpon,
    &mbignum_bn_print,
    &mbignum_bn_println,
    &mbignum_getbintype,
    &mbignum_makebignum,
    &mbignum_makesmallnum,
    &mbignum_smalltobig,
    &mbignum_freesmall,
    &mbignum_bn_alloc,
    &mbignum_checkedmalloc,
    &mbignum_bn_free,
    &mbignum_freemem,
    &mbignum_bn_setzero,
    &mbignum_bn_move,
    &mbignum_bn_dupl,
    &mbignum_bn_setinf,
    &mbignum_bn_setnan,
    &mbignum_bn_error,
    &mbignum_bn_iszero,
    &mbignum_bn_negto,
    &mbignum_bn_absto,
    &mbignum_bn_isint,
    &mbignum_bn_getprec,
    &mbignum_bn_setprec,
    &mbignum_bn_getglobalprec,
    &mbignum_bn_setglobalprec,
    &mbignum_bn_makeint,
    &mbignum_bn_makefloat,
    &mbignum_bn_ipower,
    &mbignum_smallsubto,
    &mbignum_smallmulto,
    &mbignum_bn_equal,
    &mbignum_bn_addu,
    &mbignum_bn_subu,
    &mbignum_bn_mulu,
    &mbignum_smalldiv,
    &mbignum_bn_idivu,
    &mbignum_strvaln,
    &mbignum_bn_makestr,
    &mbignum_bn_fdivu,
    &mbignum_tostring_float,
    &mbignum_bn_tostring,
    &mbignum_tostring_scient,
    &mbignum_bn_add,
    &mbignum_bn_sub,
    &mbignum_bn_mul,
    &mbignum_bn_mulp,
    &mbignum_bn_div,
    &mbignum_bn_idiv,
    &mbignum_bn_idivrem,
    &mbignum_bn_irem,
    &mbignum_bn_cmp,
    &mbignum_bn_const,
    &mbignum_bn_sign,
    &mbignum_badnumber,
    &mbignum_bn_digits,
    &mbignum_bn_toint,
    &mbignum_bn_tofloat,
    &mbignum_bn_fix,
    &mbignum_bntest,
    &pc_print_pch_print,
    &pc_print_pch_println,
    &pc_print_pch_startprintcon,
    &pc_print_pch_startprint,
    &pc_print_pch_endprint,
    &pc_print_pch_strstartprint,
    &pc_print_pch_strendprint,
    &pc_print_pch_setformat,
    &pc_print_pch_setformat2,
    &pc_print_pch_dprint,
    &pc_print_pch_printnogap,
    &pc_print_initfmtcode,
    &pc_print_i64mintostr,
    &pc_print_u64tostr,
    &pc_print_i64tostrfmt,
    &pc_print_u64tostrfmt,
    &pc_print_strtostrfmt,
    &pc_print_expandstr,
    &pc_print_pc_strtofmt,
    &pc_print_printstrz,
    &pc_print_printstr_n,
    &pc_print_printerror,
    &pc_print_addstring,
    &pc_print_j_tostr_i,
    &pc_print_j_tostr_r,
    &pc_print_j_tostr_w,
    &pc_print_j_tostr_n,
    &pc_print_j_tostr_s,
    &pc_print_j_tostr_l_m,
    &pc_print_j_tostr_a,
    &pc_print_j_tostr_b,
    &pc_print_j_tostr_e,
    &pc_print_j_tostr_k,
    &pc_print_j_tostr_j,
    &pc_print_j_tostr_d,
    &pc_print_j_tostr_z,
    &pc_print_printnextfmtchars,
    &pc_print_getreadfmtcode,
    &pc_print_pch_sreadln,
    &pc_print_pch_strtoval,
    &pc_print_pch_reread,
    &pc_print_pch_rereadln,
    &pc_print_readname,
    &pc_print_readstring,
    &pc_print_readint,
    &pc_print_readhex,
    &pc_print_readbin,
    &pc_print_readreal,
    &pc_print_pch_readln,
    &pc_print_stepkbpos,
    &pc_print_pch_sread,
    &pc_print_domultichar,
    &pc_print_pch_tostr,
    &pc_print_pc_getfmt,
    &pc_print_pc_readlinen,
    &pc_print_readitem,
    &pc_print_readany,
    &pc_print_strtoreal,
    &pc_print_strtoint,
    &pc_print_calltostrtable,
    &pc_print_printbn,
    &pc_jhandlers_initcalltables,
    &pc_jhandlers_initjhandler,
    &pc_jhandlers_add_stable_entry,
    &pc_jhandlers_add_dtable_entry,
    &pc_jhandlers_def_handler,
    &pc_jhandlers_ddef_handler,
    &pc_jhandlers_j_add_i_w,
    &pc_jhandlers_j_add_r,
    &pc_jhandlers_j_add_s,
    &pc_jhandlers_j_add_j,
    &pc_jhandlers_j_add_e,
    &pc_jhandlers_j_add_z,
    &pc_jhandlers_j_add_iw_wi,
    &pc_jhandlers_j_add_zz,
    &pc_jhandlers_j_sub_i_w,
    &pc_jhandlers_j_sub_r,
    &pc_jhandlers_j_sub_p,
    &pc_jhandlers_j_sub_j,
    &pc_jhandlers_j_sub_e,
    &pc_jhandlers_j_sub_z,
    &pc_jhandlers_j_sub_zz,
    &pc_jhandlers_j_mixed_iw_wi,
    &pc_jhandlers_j_mixed_ir,
    &pc_jhandlers_j_mixed_ri,
    &pc_jhandlers_j_mixed_ij,
    &pc_jhandlers_j_mixed_ji,
    &pc_jhandlers_j_mul_i_w,
    &pc_jhandlers_j_mul_r,
    &pc_jhandlers_j_mul_j,
    &pc_jhandlers_j_mul_z,
    &pc_jhandlers_j_mul_li,
    &pc_jhandlers_j_mul_si,
    &pc_jhandlers_j_mul_e,
    &pc_jhandlers_j_mul_zz,
    &pc_jhandlers_j_div_i,
    &pc_jhandlers_j_div_r,
    &pc_jhandlers_j_div_j,
    &pc_jhandlers_j_div_z,
    &pc_jhandlers_j_jumple_i,
    &pc_jhandlers_j_jumple_r,
    &pc_jhandlers_j_jumple_s,
    &pc_jhandlers_j_jumple_z,
    &pc_jhandlers_j_jumpeq_i_r_t_o,
    &pc_jhandlers_j_jumpeq_v_p_f_g,
    &pc_jhandlers_j_jumpeq_s,
    &pc_jhandlers_j_jumpeq_z,
    &pc_jhandlers_j_jumpeq_zz,
    &pc_jhandlers_j_jumpne_i_r_t_o,
    &pc_jhandlers_j_jumpne_v_p_f_g,
    &pc_jhandlers_j_jumpne_s,
    &pc_jhandlers_j_jumpne_z,
    &pc_jhandlers_j_jumpne_zz,
    &pc_jhandlers_j_jumpge_i,
    &pc_jhandlers_j_jumpge_w,
    &pc_jhandlers_j_jumpge_r,
    &pc_jhandlers_j_jumpge_z,
    &pc_jhandlers_j_jumpgt_i,
    &pc_jhandlers_j_jumpgt_w,
    &pc_jhandlers_j_jumpgt_r,
    &pc_jhandlers_j_jumpgt_z,
    &pc_jhandlers_j_jumplt_i,
    &pc_jhandlers_j_jumplt_v_p,
    &pc_jhandlers_j_jumplt_r,
    &pc_jhandlers_j_jumplt_z,
    &pc_jhandlers_j_pushix_li,
    &pc_jhandlers_j_pushix_mi,
    &pc_jhandlers_j_pushix_vi,
    &pc_jhandlers_j_pushix_ln,
    &pc_jhandlers_j_pushix_ll,
    &pc_jhandlers_j_pushix_le,
    &pc_jhandlers_j_pushix_ai,
    &pc_jhandlers_j_pushix_bi_ei,
    &pc_jhandlers_j_pushix_an,
    &pc_jhandlers_j_pushix_si,
    &pc_jhandlers_j_pushix_sn,
    &pc_jhandlers_j_pushix_bn,
    &pc_jhandlers_j_pushix_di,
    &pc_jhandlers_j_pushix_zz,
    &pc_jhandlers_j_pushixref_li,
    &pc_jhandlers_j_pushixref_ln,
    &pc_jhandlers_j_pushixref_ai,
    &pc_jhandlers_j_pushixref_si,
    &pc_jhandlers_j_pushixref_bi,
    &pc_jhandlers_j_pushixref_zz,
    &pc_jhandlers_j_pushdotix_si,
    &pc_jhandlers_j_pushdotix_sn,
    &pc_jhandlers_j_pushdotix_ii,
    &pc_jhandlers_j_pushdotix_in,
    &pc_jhandlers_j_pushdotix_ei,
    &pc_jhandlers_j_pushdotix_mi,
    &pc_jhandlers_j_pushdotix_zz,
    &pc_jhandlers_j_pushdotixref_si,
    &pc_jhandlers_j_pushdotixref_sn,
    &pc_jhandlers_j_pushdotixref_ii,
    &pc_jhandlers_j_pushdotixref_in_wn,
    &pc_jhandlers_j_pushdotixref_ei,
    &pc_jhandlers_j_pushdotixref_zz,
    &pc_jhandlers_j_addto_i,
    &pc_jhandlers_j_addto_r,
    &pc_jhandlers_j_addto_s,
    &pc_jhandlers_j_addto_p,
    &pc_jhandlers_j_addto_z,
    &pc_jhandlers_j_addto_si,
    &pc_jhandlers_j_addto_ir,
    &pc_jhandlers_j_addto_ri,
    &pc_jhandlers_j_addto_zz,
    &pc_jhandlers_j_subto_i,
    &pc_jhandlers_j_subto_r,
    &pc_jhandlers_j_subto_z,
    &pc_jhandlers_j_subto_ir,
    &pc_jhandlers_j_subto_ri,
    &pc_jhandlers_j_subto_zz,
    &pc_jhandlers_j_multo_i_w,
    &pc_jhandlers_j_multo_r,
    &pc_jhandlers_j_multo_z,
    &pc_jhandlers_j_divto_i_w,
    &pc_jhandlers_j_divto_r,
    &pc_jhandlers_j_divto_z,
    &pc_jhandlers_j_idivto_i,
    &pc_jhandlers_j_idivto_z,
    &pc_jhandlers_j_iand_i_w,
    &pc_jhandlers_j_iand_e,
    &pc_jhandlers_j_iand_z,
    &pc_jhandlers_j_ior_i_w,
    &pc_jhandlers_j_ior_e,
    &pc_jhandlers_j_ior_z,
    &pc_jhandlers_j_ixor_i_w,
    &pc_jhandlers_j_ixor_e,
    &pc_jhandlers_j_ixor_z,
    &pc_jhandlers_j_iandto_i_w,
    &pc_jhandlers_j_iandto_z,
    &pc_jhandlers_j_iorto_i_w,
    &pc_jhandlers_j_iorto_z,
    &pc_jhandlers_j_ixorto_i_w,
    &pc_jhandlers_j_ixorto_z,
    &pc_jhandlers_j_shlto_i,
    &pc_jhandlers_j_shlto_z,
    &pc_jhandlers_j_shrto_i,
    &pc_jhandlers_j_shrto_z,
    &pc_jhandlers_j_concat_s,
    &pc_jhandlers_j_concat_l,
    &pc_jhandlers_j_concat_z,
    &pc_jhandlers_j_concatto_s,
    &pc_jhandlers_j_concatto_l,
    &pc_jhandlers_j_concatto_z,
    &pc_jhandlers_j_append_s,
    &pc_jhandlers_j_append_l,
    &pc_jhandlers_j_append_a,
    &pc_jhandlers_j_append_b,
    &pc_jhandlers_j_append_z,
    &pc_jhandlers_j_appendto_s,
    &pc_jhandlers_j_appendto_l,
    &pc_jhandlers_j_appendto_a,
    &pc_jhandlers_j_appendto_b_e,
    &pc_jhandlers_j_appendto_z,
    &pc_jhandlers_j_max_i,
    &pc_jhandlers_j_max_r,
    &pc_jhandlers_j_max_z,
    &pc_jhandlers_j_min_z,
    &pc_jhandlers_j_len_l_a_e_s_b_d,
    &pc_jhandlers_j_len_m_k,
    &pc_jhandlers_j_len_n,
    &pc_jhandlers_j_len_z,
    &pc_jhandlers_j_lwb_l,
    &pc_jhandlers_j_lwb_a_b,
    &pc_jhandlers_j_lwb_s_m_k_d,
    &pc_jhandlers_j_lwb_e,
    &pc_jhandlers_j_lwb_n,
    &pc_jhandlers_j_lwb_z,
    &pc_jhandlers_j_upb_l,
    &pc_jhandlers_j_upb_a_b,
    &pc_jhandlers_j_upb_s_d,
    &pc_jhandlers_j_upb_m_k,
    &pc_jhandlers_j_upb_e,
    &pc_jhandlers_j_upb_n,
    &pc_jhandlers_j_upb_z,
    &pc_jhandlers_j_bounds_l_a_b_s_e,
    &pc_jhandlers_j_bounds_m_k,
    &pc_jhandlers_j_bounds_n,
    &pc_jhandlers_j_bounds_z,
    &pc_jhandlers_j_minto_i,
    &pc_jhandlers_j_minto_r,
    &pc_jhandlers_j_minto_z,
    &pc_jhandlers_j_maxto_i,
    &pc_jhandlers_j_maxto_r,
    &pc_jhandlers_j_maxto_z,
    &pc_jhandlers_j_neg_i_w,
    &pc_jhandlers_j_neg_r,
    &pc_jhandlers_j_neg_j,
    &pc_jhandlers_j_neg_e,
    &pc_jhandlers_j_neg_z,
    &pc_jhandlers_j_abs_i_w,
    &pc_jhandlers_j_abs_r,
    &pc_jhandlers_j_abs_j,
    &pc_jhandlers_j_abs_z,
    &pc_jhandlers_j_inot_i_w,
    &pc_jhandlers_j_inot_e,
    &pc_jhandlers_j_inot_z,
    &pc_jhandlers_j_istrue_i_w_r,
    &pc_jhandlers_j_istrue_l_a_e_s_b,
    &pc_jhandlers_j_istrue_k_m_h,
    &pc_jhandlers_j_istrue_j,
    &pc_jhandlers_j_istrue_z,
    &pc_jhandlers_j_jumpfalse_i_w_r_v_p_f,
    &pc_jhandlers_j_jumpfalse_s_l_e_a_b,
    &pc_jhandlers_j_jumpfalse_z,
    &pc_jhandlers_j_jumptrue_i_r_w_v_p_f,
    &pc_jhandlers_j_jumptrue_s_l_e_a_b,
    &pc_jhandlers_j_jumptrue_z,
    &pc_jhandlers_j_shl_i_w,
    &pc_jhandlers_j_shl_z,
    &pc_jhandlers_j_shr_i_w,
    &pc_jhandlers_j_shr_j_i,
    &pc_jhandlers_j_shr_z,
    &pc_jhandlers_j_shr_wi,
    &pc_jhandlers_j_shr_zz,
    &pc_jhandlers_j_idiv_w,
    &pc_jhandlers_j_idiv_j,
    &pc_jhandlers_j_idiv_z,
    &pc_jhandlers_j_rem_w,
    &pc_jhandlers_j_rem_j,
    &pc_jhandlers_j_remz,
    &pc_oslayer_runproc_m,
    &pc_oslayer_os_getconsize,
    &pc_oslayer_pch_setmesshandler,
    &pc_oslayer_pch_gethostname,
    &pc_oslayer_os_initdllmodules,
    &pc_oslayer_os_loaddllmodule,
    &pc_oslayer_os_initdllfunctions,
    &pc_oslayer_os_loaddllfunction,
    &pc_oslayer_pch_getos,
    &pc_oslayer_pch_gethostsize,
    &pc_oslayer_pch_iswindows,
    &pc_oslayer_os_calldll,
    &osnosdll_os_calldllfunction,
    &osnosdll_os_pushargs,
    &pc_host_callhostfunction,
    &pc_host_pch_leftstr,
    &pc_host_pch_rightstr,
    &pc_host_pch_convlc,
    &pc_host_pch_convuc,
    &pc_host_pch_iconvlc,
    &pc_host_pch_iconvuc,
    &pc_host_pch_stop,
    &pc_host_pch_stopx,
    &pc_host_pch_ismain,
    &pc_host_pch_waitkey,
    &pc_host_pch_testkey,
    &pc_host_pch_execwait,
    &pc_host_pch_execcmd,
    &pc_host_pch_makestr,
    &pc_host_pch_makestrslice,
    &pc_host_pch_makeref,
    &pc_host_pch_new,
    &pc_host_pch_newheap,
    &pc_host_pch_heapvar,
    &pc_host_pch_freeheap,
    &pc_host_pch_getcmdparam,
    &pc_host_pch_setpcerror,
    &pc_host_pch_setdebug,
    &pc_host_pch_setfprintf,
    &pc_host_pch_ticks,
    &pc_host_pch_sleep,
    &pc_host_pch_random,
    &pc_host_pch_findmetafunction,
    &pc_host_pch_loadpcl,
    &pc_host_pch_runpcl,
    &pc_host_pch_runtask,
    &pc_host_pch_callext,
    &pc_host_pch_system,
    &pc_host_pch_shellexec,
    &pc_host_pch_gethash,
    &pc_host_pch_test,
    &pc_host_pch_pcldata,
    &pc_host_pch_getcstring,
    &pc_host_pch_getparam,
    &pc_host_pch_clearlist,
    &pc_host_pch_makelink,
    &pc_host_pch_allparams,
    &pc_host_pch_stackvars,
    &pc_host_pch_makeempty,
    &pc_host_pch_readlines,
    &pc_host_pch_dictitems,
    &pc_host_pch_setoverload,
    &pc_host_pch_errorinfo,
    &pc_host_getbounds,
    &pc_host_checkparam,
    &pc_host_leftstring,
    &pc_host_rightstring,
    &pc_host_padstring_right,
    &pc_host_padstring_left,
    &pc_host_pcld_makevint,
    &pc_host_pcld_makelist,
    &pc_host_getproctabledata,
    &pc_host_convert_handler,
    &pc_host_addtoproclist,
    &pc_host_tostr_handler,
    &pc_host_add_handler,
    &pc_host_addovrecord,
    &pc_host_findapplproc,
    &pc_host_do_callapplproc,
    &pc_host_vartopack,
    &pc_host_dummyfn,
    &pc_host_pythag,
    &pc_host_new_random,
    &pc_host_new_heapvar,
    &pc_host_mfib,
    &pc_dxfns_dx_iorset,
    &pc_dxfns_dx_iandset,
    &pc_dxfns_dx_ixorset,
    &pc_dxfns_dx_inotset,
    &pc_dxfns_dx_subset,
    &pc_dxfns_inotsetbits,
    &pc_dxfns_iorsetbits,
    &pc_dxfns_iandsetbits,
    &pc_dxfns_ixorsetbits,
    &pc_dxfns_subsetbits,
    &pc_dxfns_iresizeset,
    &pc_dxfns_dx_varinvar,
    &pc_dxfns_dx_mixed,
    &pc_khandlers_k_zero,
    &pc_khandlers_k_nop,
    &pc_khandlers_k_procstart,
    &pc_khandlers_k_procend,
    &pc_khandlers_k_endmodule,
    &pc_khandlers_k_push_m,
    &pc_khandlers_k_push_f,
    &pc_khandlers_k_push_am,
    &pc_khandlers_k_push_af,
    &pc_khandlers_k_push_ap,
    &pc_khandlers_k_push_al,
    &pc_khandlers_k_push_ci,
    &pc_khandlers_k_push_cw,
    &pc_khandlers_k_push_cr,
    &pc_khandlers_k_push_cn,
    &pc_khandlers_k_push_cs,
    &pc_khandlers_k_push_t,
    &pc_khandlers_k_push_op,
    &pc_khandlers_k_pushz,
    &pc_khandlers_k_pushz_void,
    &pc_khandlers_k_pushz_str,
    &pc_khandlers_k_pushz_list,
    &pc_khandlers_k_pushz_listl,
    &pc_khandlers_k_pushz_set,
    &pc_khandlers_k_pushz_arrayl,
    &pc_khandlers_k_pop_m,
    &pc_khandlers_k_pop_f,
    &pc_khandlers_k_store_m,
    &pc_khandlers_k_store_f,
    &pc_khandlers_k_pushptr,
    &pc_khandlers_k_popptr,
    &pc_khandlers_k_storeptr,
    &pc_khandlers_k_zpop_m,
    &pc_khandlers_k_zpop_f,
    &pc_khandlers_k_zstore_m,
    &pc_khandlers_k_zstore_f,
    &pc_khandlers_k_copy,
    &pc_khandlers_k_swap,
    &pc_khandlers_k_convptr,
    &pc_khandlers_k_jump,
    &pc_khandlers_k_jumpptr,
    &pc_khandlers_k_jumptrue,
    &pc_khandlers_k_jumpfalse,
    &pc_khandlers_k_jumpdef,
    &pc_khandlers_k_jumpvoid,
    &pc_khandlers_k_jumpeq,
    &pc_khandlers_k_jumpne,
    &pc_khandlers_k_jumplt,
    &pc_khandlers_k_jumple,
    &pc_khandlers_k_jumpge,
    &pc_khandlers_k_jumpgt,
    &pc_khandlers_k_jumptesteq,
    &pc_khandlers_k_jumptestne,
    &pc_khandlers_k_jumplabel,
    &pc_khandlers_k_jumpclabel,
    &pc_khandlers_k_switch,
    &pc_khandlers_k_cswitch,
    &pc_khandlers_k_new,
    &pc_khandlers_k_to_f,
    &pc_khandlers_k_for_fci,
    &pc_khandlers_k_for_ff,
    &pc_khandlers_k_ford_fci,
    &pc_khandlers_k_ford_ff,
    &pc_khandlers_k_call,
    &pc_khandlers_k_callptr,
    &pc_khandlers_k_return,
    &pc_khandlers_k_startdll,
    &pc_khandlers_k_pushdll,
    &pc_khandlers_k_calldll,
    &pc_khandlers_k_callhost,
    &pc_khandlers_k_stackframe,
    &pc_khandlers_k_free,
    &pc_khandlers_k_addsp,
    &pc_khandlers_k_stop,
    &pc_khandlers_k_test,
    &pc_khandlers_k_makelist,
    &pc_khandlers_k_makerecord,
    &pc_khandlers_k_makearray,
    &pc_khandlers_k_makestruct,
    &pc_khandlers_k_makeset,
    &pc_khandlers_k_makerange,
    &pc_khandlers_k_makedict,
    &pc_khandlers_k_pushdot,
    &pc_khandlers_k_pushdotref,
    &pc_khandlers_k_softconv,
    &pc_khandlers_k_hardconv,
    &pc_khandlers_k_mixed,
    &pc_khandlers_k_incrptr,
    &pc_khandlers_k_incrto_m,
    &pc_khandlers_k_incrto_f,
    &pc_khandlers_k_loadincr,
    &pc_khandlers_k_incrload,
    &pc_khandlers_k_decrptr,
    &pc_khandlers_k_decrto_m,
    &pc_khandlers_k_decrto_f,
    &pc_khandlers_k_loaddecr,
    &pc_khandlers_k_decrload,
    &pc_khandlers_k_incr,
    &pc_khandlers_k_decr,
    &pc_khandlers_k_neg,
    &pc_khandlers_k_abs,
    &pc_khandlers_k_not,
    &pc_khandlers_k_inot,
    &pc_khandlers_k_istrue,
    &pc_khandlers_k_asc,
    &pc_khandlers_k_chr,
    &pc_khandlers_k_sqrt,
    &pc_khandlers_k_sqr,
    &pc_khandlers_k_cube,
    &pc_khandlers_k_sin,
    &pc_khandlers_k_cos,
    &pc_khandlers_k_tan,
    &pc_khandlers_k_asin,
    &pc_khandlers_k_acos,
    &pc_khandlers_k_atan,
    &pc_khandlers_k_sign,
    &pc_khandlers_k_ln,
    &pc_khandlers_k_log,
    &pc_khandlers_k_lg,
    &pc_khandlers_k_exp,
    &pc_khandlers_k_round,
    &pc_khandlers_k_floor,
    &pc_khandlers_k_ceil,
    &pc_khandlers_k_fract,
    &pc_khandlers_k_negto,
    &pc_khandlers_k_absto,
    &pc_khandlers_k_notto,
    &pc_khandlers_k_inotto,
    &pc_khandlers_k_len,
    &pc_khandlers_k_lwb,
    &pc_khandlers_k_upb,
    &pc_khandlers_k_bounds,
    &pc_khandlers_k_bits,
    &pc_khandlers_k_bytes,
    &pc_khandlers_k_type,
    &pc_khandlers_k_elemtype,
    &pc_khandlers_k_basetype,
    &pc_khandlers_k_minval,
    &pc_khandlers_k_maxval,
    &pc_khandlers_k_isint,
    &pc_khandlers_k_isreal,
    &pc_khandlers_k_isstring,
    &pc_khandlers_k_isrange,
    &pc_khandlers_k_isnumber,
    &pc_khandlers_k_isarray,
    &pc_khandlers_k_isrecord,
    &pc_khandlers_k_ispointer,
    &pc_khandlers_k_ismutable,
    &pc_khandlers_k_isset,
    &pc_khandlers_k_isvoid,
    &pc_khandlers_k_isdef,
    &pc_khandlers_k_tostr,
    &pc_khandlers_k_isequal,
    &pc_khandlers_k_add,
    &pc_khandlers_k_sub,
    &pc_khandlers_k_mul,
    &pc_khandlers_k_div,
    &pc_khandlers_k_idiv,
    &pc_khandlers_k_rem,
    &pc_khandlers_k_divrem,
    &pc_khandlers_k_iand,
    &pc_khandlers_k_ior,
    &pc_khandlers_k_ixor,
    &pc_khandlers_k_shl,
    &pc_khandlers_k_shr,
    &pc_khandlers_k_in,
    &pc_khandlers_k_notin,
    &pc_khandlers_k_inrev,
    &pc_khandlers_k_eq,
    &pc_khandlers_k_ne,
    &pc_khandlers_k_lt,
    &pc_khandlers_k_le,
    &pc_khandlers_k_ge,
    &pc_khandlers_k_gt,
    &pc_khandlers_k_min,
    &pc_khandlers_k_max,
    &pc_khandlers_k_concat,
    &pc_khandlers_k_append,
    &pc_khandlers_k_power,
    &pc_khandlers_k_atan2,
    &pc_khandlers_k_addto,
    &pc_khandlers_k_subto,
    &pc_khandlers_k_multo,
    &pc_khandlers_k_divto,
    &pc_khandlers_k_idivto,
    &pc_khandlers_k_iandto,
    &pc_khandlers_k_iorto,
    &pc_khandlers_k_ixorto,
    &pc_khandlers_k_shlto,
    &pc_khandlers_k_shrto,
    &pc_khandlers_k_minto,
    &pc_khandlers_k_maxto,
    &pc_khandlers_k_concatto,
    &pc_khandlers_k_appendto,
    &pc_khandlers_k_pushix,
    &pc_khandlers_k_pushdotix,
    &pc_khandlers_k_pushkeyix,
    &pc_khandlers_k_pushkeyixd,
    &pc_khandlers_k_pushixref,
    &pc_khandlers_k_pushdotixref,
    &pc_khandlers_k_pushkeyixref,
    &pc_khandlers_k_pushbyteix,
    &pc_khandlers_k_pushbyteixref,
    &pc_khandlers_k_appendset,
    &pc_khandlers_k_pushdotm,
    &pc_khandlers_k_pushdott,
    &pc_khandlers_k_push_ad,
    &pc_khandlers_k_push_try,
    &pc_khandlers_k_raise,
    &pc_khandlers_k_applyop,
    &pc_khandlers_k_makeiter,
    &pc_khandlers_k_forall,
    &pc_khandlers_k_forallx,
    &pc_khandlers_k_foreach,
    &pc_khandlers_k_foreachx,
    &pc_khandlers_k_expandrange,
    &pc_khandlers_k_callappl,
    &pc_assemc_fixup_asm,
    &pc_assemc_asmavailable,
    &pc_assemc_addcountint,
    &pc_assemc_addcountext,
    &pc_assemc_showasmcmd,
    &pc_assemc_disploop_asm,
    &pc_assemc_getasmjump,
    &qci_qcompiler_prod,
    &qci_do_loadmodules,
    &qci_loadmainmodule,
    &qci_addmodule,
    &qci_loadimport,
    &qci_readimportlist,
    &qci_initdata,
    &qci_initsearchdirs,
    &qci_addsearchdir,
    &qci_getmodulestr,
    &qci_findmodule,
    &qci_checkname,
    &qci_do_parse,
    &qci_do_name,
    &qci_do_pclgen,
    &qci_loaderror,
    &qci_getsyscmdline,
    &qci_checkkeyword,
    &qci_readinttoken,
    &qci_do_writepcfile,
    &qci_writesymbols,
    &qci_showpcsymbol,
    &qci_writepccode2pc,
    &qci_writestructfields,
    &qci_fixup_genfields,
    &qci_showhelp,
    &qci_nextcmd,
    &qci_writedocs,
    &qci_do_writeqa,
    &qc_support_prterror,
    &qc_support_serror_gen,
    &qc_support_serror,
    &qc_support_serror_ss,
    &qc_support_serror_s,
    &qc_support_error_gen,
    &qc_support_rxerror,
    &qc_support_gerror,
    &qc_support_rxerror_s,
    &qc_support_testelem,
    &qc_support_setelem,
    &qc_support_inittypetables,
    &qc_support_nextpoweroftwo,
    &qc_support_initpcdest,
    &qc_support_getpcpos,
    &qc_support_setpcpos,
    &qc_support_writepcdata,
    &qc_support_writezstring,
    &qc_support_writezblock,
    &qc_support_writezint,
    &qc_support_writezint4,
    &qc_support_writezrange,
    &qc_support_writezreal,
    &qc_support_writezeof,
    &qc_support_ipower,
    &qc_support_gs_additem,
    &qc_support_isalphanum,
    &qc_support_outpcbyte,
    &qc_support_outpcword,
    &qc_support_outpcword16,
    &qc_support_writeqafile,
    &qc_support_addqafile,
    &qc_lex_lexreadtoken,
    &qc_lex_lxreadstring,
    &qc_lex_readnumber,
    &qc_lex_readrealnumber,
    &qc_lex_readexponent,
    &qc_lex_lxerror,
    &qc_lex_printsymbol,
    &qc_lex_stringtonumber,
    &qc_lex_lexsetup,
    &qc_lex_scannumber,
    &qc_lex_readrawstring,
    &qc_lex_lookup,
    &qc_lex_gethashvaluez,
    &qc_lex_inithashtable,
    &qc_lex_dolexdirective,
    &qc_lex_lexreadline,
    &qc_lex_startlex,
    &qc_lex_convertzstring,
    &qc_lex_addnamestr,
    &qc_lex_ps1,
    &qc_lex_ps2,
    &qc_lex_ps,
    &qc_lex_lex,
    &qc_lex_showhashtablesize,
    &qc_lex_addmacro,
    &qc_lex_stackmacro,
    &qc_lex_unstackmacro,
    &qc_parse_parsemodule,
    &qc_parse_readmoduledefs,
    &qc_parse_initparser,
    &qc_parse_skipsemi,
    &qc_parse_addalias,
    &qc_parse_makeblock,
    &qc_parse_checkequals,
    &qc_parse_getcurrline,
    &qc_parse_checkbegin,
    &qc_parse_checkbeginend,
    &qc_parse_checkend,
    &qc_parse_addgenfield,
    &qc_parse_readvardef,
    &qc_parse_readconstdef,
    &qc_parse_readexpression,
    &qc_parse_readfactor,
    &qc_parse_readterm,
    &qc_parse_readlbrack,
    &qc_parse_addlistunit,
    &qc_parse_addlistparam,
    &qc_parse_readlsqbrack,
    &qc_parse_readcast,
    &qc_parse_readopc,
    &qc_parse_readsprint,
    &qc_parse_readsread,
    &qc_parse_readcompilervar,
    &qc_parse_readcastx,
    &qc_parse_checksymbol,
    &qc_parse_readtypespec,
    &qc_parse_readhostparams,
    &qc_parse_readslist,
    &qc_parse_readindex,
    &qc_parse_readkeyindex,
    &qc_parse_readdotsuffix,
    &qc_parse_isconstexpr,
    &qc_parse_readconstexpr,
    &qc_parse_readconstexprvalue,
    &qc_parse_readconstint,
    &qc_parse_readprocdef,
    &qc_parse_readprocdecl,
    &qc_parse_readparams,
    &qc_parse_readparamsff,
    &qc_parse_readparamsff_types,
    &qc_parse_readparamsff_names,
    &qc_parse_readblock,
    &qc_parse_readexecstmt,
    &qc_parse_readstmtexpr,
    &qc_parse_readcondsuffix,
    &qc_parse_readif,
    &qc_parse_readgoto,
    &qc_parse_readunless,
    &qc_parse_readswitchcase,
    &qc_parse_readstop,
    &qc_parse_readreturn,
    &qc_parse_readdo,
    &qc_parse_readto,
    &qc_parse_readwhile,
    &qc_parse_readrepeat,
    &qc_parse_readloopcontrol,
    &qc_parse_readprint,
    &qc_parse_readread,
    &qc_parse_readtry,
    &qc_parse_readraise,
    &qc_parse_readfor,
    &qc_parse_readforall,
    &qc_parse_readtypedef,
    &qc_parse_readstructdef,
    &qc_parse_readstructfields,
    &qc_parse_readtabledef,
    &qc_parse_readclassdef,
    &qc_parse_readclassbody,
    &qc_parse_readenumtype,
    &qc_parse_readrecordfields,
    &qc_parse_readimportmodule,
    &qc_parse_readimportbody,
    &qc_parse_createprocdef,
    &qc_parse_readequivfield,
    &qc_parse_testconstruct,
    &qc_parse_readapplyop,
    &qc_parse_readapplprocs,
    &qc_parse_defineapplproc,
    &qc_parse_findapplproc,
    &qc_parse_addapplproc,
    &qc_parse_readapplcall,
    &qc_lib_newstrec,
    &qc_lib_initqclib,
    &qc_lib_getduplnameptr,
    &qc_lib_adddef,
    &qc_lib_adddef_nodupl,
    &qc_lib_printst,
    &qc_lib_printstrec,
    &qc_lib_printstflat,
    &qc_lib_newunitrec,
    &qc_lib_createname,
    &qc_lib_createunit0,
    &qc_lib_createunit1,
    &qc_lib_createunit2,
    &qc_lib_createunit3,
    &qc_lib_createconstunit,
    &qc_lib_createstringconstunit,
    &qc_lib_getoptocode,
    &qc_lib_checkpackedtype,
    &qc_lib_checkunpackedtype,
    &qc_lib_checkdlltype,
    &qc_lib_createtype,
    &qc_lib_createusertype,
    &qc_lib_createusertypefromstr,
    &qc_lib_getconstvalue,
    &qc_lib_getrangelwb,
    &qc_lib_getrangeupb,
    &qc_lib_getrangelwbunit,
    &qc_lib_getrangeupbunit,
    &qc_lib_createarraymode,
    &qc_lib_nextautotype,
    &qc_lib_createstringmode,
    &qc_lib_createrefpackmode,
    &qc_lib_getscope,
    &qc_lib_setnameptr,
    &qc_lib_printcode,
    &qc_lib_printunit,
    &qc_lib_printunitlist,
    &qc_lib_getprefix,
    &qc_lib_getdottedname,
    &qc_lib_getlineinfok,
    &qc_lib_getavname,
    &qc_lib_unionstr_clear,
    &qc_lib_unionstr_append,
    &qc_lib_unionstr_concat,
    &qc_lib_unionstr_last,
    &qc_lib_unionstr_copy,
    &qc_lib_unionstr_print,
    &qc_lib_createrecordmode,
    &qc_lib_createenummode,
    &qc_lib_convertstring,
    &qc_lib_strexpr,
    &qc_lib_jeval,
    &qc_lib_getopcjname,
    &qc_lib_strmode,
    &qc_lib_istrmode,
    &qc_lib_countunits,
    &qc_lib_finddefstr,
    &qc_lib_purgesymbol,
    &qc_lib_purgesymbollist,
    &qc_lib_purgeprocs,
    &qc_lib_purgeproc,
    &qc_lib_printmodelist,
    &qc_lib_printgenfieldtable,
    &qc_lib_addtoproclist,
    &qc_lib_newusertypex,
    &qc_lib_storemode,
    &qc_lib_duplunit,
    &qc_name_rx_unit,
    &qc_name_rx_module,
    &qc_name_rx_deflist,
    &qc_name_rx_passdef,
    &qc_name_rx_unitlist,
    &qc_name_resolvetopname,
    &qc_name_resolvename,
    &qc_name_finddupl,
    &qc_name_resolvedot,
    &qc_name_fixmode,
    &qc_name_fixmode2,
    &qc_name_fixusertypes,
    &qc_name_resolve_equiv_name,
    &qc_name_addframevar,
    &qc_name_converteqeq,
    &qc_name_evalbinop,
    &qc_name_evalbinop_real,
    &qc_name_makenewconst,
    &qc_name_evalmonop,
    &qc_name_tx_typetable,
    &qc_name_checkconstexpr,
    &qc_name_converttype,
    &qc_name_scanstruct,
    &qc_name_scanrecord,
    &qc_name_shiftflagsleft,
    &qc_name_getconstint,
    &qc_name_checkdict,
    &qc_name_checkconstlist,
    &qc_name_duplfield,
    &qc_name_dobaseclass,
    &qc_pclgen_evalexpr,
    &qc_pclgen_do_stmt,
    &qc_pclgen_codegen,
    &qc_pclgen_scanidata,
    &qc_pclgen_genidata,
    &qc_pclgen_initgenpcl,
    &qc_pclgen_doprogramstartup,
    &qc_pclgen_do_block,
    &qc_pclgen_do_print,
    &qc_pclgen_do_fprint,
    &qc_pclgen_do_read,
    &qc_pclgen_do_assign,
    &qc_pclgen_do_to,
    &qc_pclgen_do_while,
    &qc_pclgen_do_repeat,
    &qc_pclgen_do_forstep,
    &qc_pclgen_do_forall,
    &qc_pclgen_do_do,
    &qc_pclgen_do_cfor,
    &qc_pclgen_do_if,
    &qc_pclgen_do_longif,
    &qc_pclgen_do_callproc,
    &qc_pclgen_do_callhostproc,
    &qc_pclgen_do_return,
    &qc_pclgen_genstartproc,
    &qc_pclgen_do_procdef,
    &qc_pclgen_genprocentry,
    &qc_pclgen_genprocexit,
    &qc_pclgen_do_preincr,
    &qc_pclgen_do_exit,
    &qc_pclgen_do_goto,
    &qc_pclgen_do_switch,
    &qc_pclgen_do_simpleswitch,
    &qc_pclgen_do_case,
    &qc_pclgen_do_try,
    &qc_pclgen_do_applyop,
    &qc_pclgen_evalref,
    &qc_pclgen_getpclop,
    &qc_pclgen_genjumpl,
    &qc_pclgen_definelabel,
    &qc_pclgen_createfwdlabel,
    &qc_pclgen_definefwdlabel,
    &qc_pclgen_stacklooplabels,
    &qc_pclgen_unstacklooplabels,
    &qc_pclgen_findlooplabel,
    &qc_pclgen_issimpleparam,
    &qc_pclgen_genjumpcond,
    &qc_pclgen_gcomparejump,
    &qc_pclgen_reversecond,
    &qc_pclgen_do_convert,
    &qc_pclgen_do_selectx,
    &qc_pclgen_do_calldll,
    &qc_pclgen_islogical,
    &qc_pclgen_do_and,
    &qc_pclgen_do_or,
    &qc_pclgen_do_callptr,
    &qc_pclgen_do_callmproc,
    &qc_pclgen_checkblockreturn,
    &qc_pclgen_genfree,
    &qc_pclgen_do_clamp,
    &qc_pclgen_do_applyopx,
    &qc_pclgen_do_calldllvar,
    &qc_pclgen_callhostfn,
    &qc_pclgen_extractparams,
    &qc_pclgen_unitstoarray,
    &qc_pclgen_do_idiv,
    &qc_pclgen_ispoweroftwo,
    &qc_pclgen_genpushint,
    &qc_pclgen_do_callappl,
    &qc_pcllib_initpcl,
    &qc_pcllib_initpcldata,
    &qc_pcllib_initpclgen,
    &qc_pcllib_writepcl3,
    &qc_pcllib_writepclopnd3,
    &qc_pcllib_writepccode,
    &qc_pcllib_genpc,
    &qc_pcllib_genopnd_int,
    &qc_pcllib_genopnd_s,
    &qc_pcllib_genpc_int,
    &qc_pcllib_genpc_int2,
    &qc_pcllib_genpc_int4,
    &qc_pcllib_genpc_s,
    &qc_pcllib_genpc_str,
    &qc_pcllib_genopnd_str,
    &qc_pcllib_genpc_lab,
    &qc_pcllib_isframe_s,
    &qc_pcllib_addstringtotable,
    &q_libs_getintlib,
0};
static uint8_t *  msysnewc__fnnames[]= {
    (byte*)"start",
    (byte*)"getinputoptions",
    (byte*)"do_option",
    (byte*)"getsyscmdline",
    (byte*)"showcaption",
    (byte*)"showhelp",
    (byte*)"m_getdotindex",
    (byte*)"m_setdotindex",
    (byte*)"m_getdotslice",
    (byte*)"m_setdotslice",
    (byte*)"m_get_nprocs",
    (byte*)"m_get_nexports",
    (byte*)"m_get_procname",
    (byte*)"m_get_procaddr",
    (byte*)"m_get_procexport",
    (byte*)"pushio",
    (byte*)"m_print_startfile",
    (byte*)"m_print_startstr",
    (byte*)"m_print_startptr",
    (byte*)"m_print_startcon",
    (byte*)"m_print_setfmt",
    (byte*)"m_print_end",
    (byte*)"m_print_ptr",
    (byte*)"m_print_i64",
    (byte*)"m_print_u64",
    (byte*)"m_print_r64",
    (byte*)"m_print_r32",
    (byte*)"m_print_c8",
    (byte*)"m_print_str",
    (byte*)"m_print_newline",
    (byte*)"m_print_nogap",
    (byte*)"printstr",
    (byte*)"printstr_n",
    (byte*)"printstrn_app",
    (byte*)"makezstring",
    (byte*)"freezstring",
    (byte*)"printchar",
    (byte*)"nextfmtchars",
    (byte*)"strtofmt",
    (byte*)"domultichar",
    (byte*)"expandstr",
    (byte*)"xdivrem",
    (byte*)"u64tostr",
    (byte*)"i64tostrfmt",
    (byte*)"u64tostrfmt",
    (byte*)"i64mintostr",
    (byte*)"strtostrfmt",
    (byte*)"tostr_i64",
    (byte*)"tostr_u64",
    (byte*)"tostr_r64",
    (byte*)"tostr_str",
    (byte*)"getfmt",
    (byte*)"strint",
    (byte*)"getstrint",
    (byte*)"strword",
    (byte*)"strreal",
    (byte*)"getstr",
    (byte*)"initreadbuffer",
    (byte*)"m_read_conline",
    (byte*)"m_read_fileline",
    (byte*)"m_read_strline",
    (byte*)"readitem",
    (byte*)"strtoint",
    (byte*)"m_read_i64",
    (byte*)"m_read_r64",
    (byte*)"m_read_str",
    (byte*)"readstr",
    (byte*)"rereadln",
    (byte*)"reread",
    (byte*)"valint",
    (byte*)"valreal",
    (byte*)"iconvlcn",
    (byte*)"iconvucn",
    (byte*)"convlcstring",
    (byte*)"convucstring",
    (byte*)"m_power_i64",
    (byte*)"m_intoverflow",
    (byte*)"m_dotindex",
    (byte*)"m_dotslice",
    (byte*)"m_popdotindex",
    (byte*)"m_popdotslice",
    (byte*)"m_imin",
    (byte*)"m_imax",
    (byte*)"m_sign",
    (byte*)"pcm_alloc",
    (byte*)"pcm_freestr",
    (byte*)"pcm_free",
    (byte*)"pcm_freeac",
    (byte*)"pcm_copymem4",
    (byte*)"pcm_clearmem",
    (byte*)"pcm_init",
    (byte*)"pcm_getac",
    (byte*)"pcm_newblock",
    (byte*)"pcm_round",
    (byte*)"pcm_array",
    (byte*)"pcm_printfreelist",
    (byte*)"pcm_diags",
    (byte*)"pcm_allocz",
    (byte*)"pcm_copyheapstring",
    (byte*)"pcm_copyheapstringn",
    (byte*)"pcm_copyheapblock",
    (byte*)"addtomemalloc",
    (byte*)"removefrommemalloc",
    (byte*)"allocmem",
    (byte*)"reallocmem",
    (byte*)"abortprogram",
    (byte*)"getfilesize",
    (byte*)"readrandom",
    (byte*)"writerandom",
    (byte*)"setfilepos",
    (byte*)"getfilepos",
    (byte*)"readfile",
    (byte*)"writefile",
    (byte*)"checkfile",
    (byte*)"readlinen",
    (byte*)"iconvlcn",
    (byte*)"iconvucn",
    (byte*)"convlcstring",
    (byte*)"convucstring",
    (byte*)"changeext",
    (byte*)"extractext",
    (byte*)"extractpath",
    (byte*)"extractfile",
    (byte*)"extractbasefile",
    (byte*)"addext",
    (byte*)"alloctable",
    (byte*)"zalloctable",
    (byte*)"checkfreelists",
    (byte*)"pcm_alloc32",
    (byte*)"pcm_free32",
    (byte*)"outbyte",
    (byte*)"outword16",
    (byte*)"outword",
    (byte*)"outword64",
    (byte*)"myeof",
    (byte*)"pcm_smallallocz",
    (byte*)"pcm_smallalloc",
    (byte*)"strbuffer_add",
    (byte*)"gs_init",
    (byte*)"gs_free",
    (byte*)"gs_str",
    (byte*)"gs_char",
    (byte*)"gs_strn",
    (byte*)"gs_strvar",
    (byte*)"gs_strint",
    (byte*)"gs_strln",
    (byte*)"gs_strsp",
    (byte*)"gs_line",
    (byte*)"gs_getcol",
    (byte*)"gs_leftstr",
    (byte*)"gs_leftint",
    (byte*)"gs_padto",
    (byte*)"gs_println",
    (byte*)"nextcmdparam",
    (byte*)"readnextfileitem",
    (byte*)"ipadstr",
    (byte*)"padstr",
    (byte*)"chr",
    (byte*)"cmpstring",
    (byte*)"cmpstringn",
    (byte*)"eqstring",
    (byte*)"cmpbytes",
    (byte*)"eqbytes",
    (byte*)"mseed",
    (byte*)"mrandom",
    (byte*)"mrandomp",
    (byte*)"mrandomint",
    (byte*)"mrandomrange",
    (byte*)"mrandomreal",
    (byte*)"mrandomreal1",
    (byte*)"checkpackfile",
    (byte*)"os_init",
    (byte*)"os_execwait",
    (byte*)"os_execcmd",
    (byte*)"os_getch",
    (byte*)"os_kbhit",
    (byte*)"os_flushkeys",
    (byte*)"os_getconsolein",
    (byte*)"os_getconsoleout",
    (byte*)"os_proginstance",
    (byte*)"os_getdllinst",
    (byte*)"os_getdllprocaddr",
    (byte*)"os_initwindows",
    (byte*)"os_getchx",
    (byte*)"os_getos",
    (byte*)"os_getoscode",
    (byte*)"os_iswindows",
    (byte*)"os_shellexec",
    (byte*)"os_sleep",
    (byte*)"os_getstdin",
    (byte*)"os_getstdout",
    (byte*)"os_gethostname",
    (byte*)"os_gethostsize",
    (byte*)"os_getmpath",
    (byte*)"os_exitprocess",
    (byte*)"os_gettimestamp",
    (byte*)"os_gettickcount",
    (byte*)"os_clock",
    (byte*)"os_getclockspersec",
    (byte*)"os_setmesshandler",
    (byte*)"os_filelastwritetime",
    (byte*)"os_hpcounter",
    (byte*)"os_hpfrequency",
    (byte*)"os_getsystime",
    (byte*)"os_peek",
    (byte*)"runpcl",
    (byte*)"run_initdata",
    (byte*)"runpcprogram",
    (byte*)"initbytecode",
    (byte*)"disploop",
    (byte*)"pclinit",
    (byte*)"fixup_all_pc",
    (byte*)"fixup_module_pc",
    (byte*)"disploop_fn",
    (byte*)"disploop_deb",
    (byte*)"runproc",
    (byte*)"allocatestrings",
    (byte*)"compileq",
    (byte*)"loadpcfile",
    (byte*)"initpcldata",
    (byte*)"createstentry",
    (byte*)"getprocaddr",
    (byte*)"pcl_initusertypes",
    (byte*)"setcmdparam",
    (byte*)"prterror",
    (byte*)"testelem",
    (byte*)"setelem",
    (byte*)"pcustype_def",
    (byte*)"pcustype",
    (byte*)"pcustypet",
    (byte*)"pcmxtypes_def",
    (byte*)"pcmxtypes",
    (byte*)"pcmxtypestt",
    (byte*)"gettypename",
    (byte*)"inittypetables",
    (byte*)"pcerror",
    (byte*)"vxunimpl",
    (byte*)"pclunimpl",
    (byte*)"convcstring",
    (byte*)"getintvalue",
    (byte*)"nextpoweroftwo",
    (byte*)"showlinenumber",
    (byte*)"printlinenumber",
    (byte*)"findlinenumber",
    (byte*)"findpcindex",
    (byte*)"showlinetable",
    (byte*)"writezstring",
    (byte*)"writezint",
    (byte*)"writezint4",
    (byte*)"writezrange",
    (byte*)"writezreal",
    (byte*)"writezeof",
    (byte*)"zerror",
    (byte*)"readzvalue",
    (byte*)"readzint",
    (byte*)"readzdint",
    (byte*)"readzreal",
    (byte*)"readzstring",
    (byte*)"readzblock",
    (byte*)"checkmt",
    (byte*)"ipower",
    (byte*)"loaderror",
    (byte*)"gettypesig",
    (byte*)"getfnname",
    (byte*)"junimpl",
    (byte*)"raiseexception",
    (byte*)"raise_error",
    (byte*)"default_exception",
    (byte*)"pc_unshare",
    (byte*)"pc_free",
    (byte*)"pc_share",
    (byte*)"pc_dupl",
    (byte*)"j_free_s",
    (byte*)"j_free_m",
    (byte*)"j_free_l_d",
    (byte*)"j_free_k",
    (byte*)"j_free_a",
    (byte*)"j_free_j",
    (byte*)"j_free_b_e",
    (byte*)"j_dupl_s",
    (byte*)"j_dupl_l_m_d",
    (byte*)"j_dupl_a",
    (byte*)"j_dupl_j",
    (byte*)"j_dupl_b",
    (byte*)"j_dupl_e",
    (byte*)"j_dupl_k",
    (byte*)"pc_makelist",
    (byte*)"pc_makerecord",
    (byte*)"pc_makearray",
    (byte*)"pc_makerange",
    (byte*)"pc_makeset",
    (byte*)"pc_makestruct",
    (byte*)"pc_makedict",
    (byte*)"pc_storepacked",
    (byte*)"adddictitem",
    (byte*)"gethashvalue",
    (byte*)"finddictitem",
    (byte*)"expanddict",
    (byte*)"setfslength",
    (byte*)"getfslength",
    (byte*)"pc_storeptr",
    (byte*)"pc_storebit",
    (byte*)"pc_popptrlist",
    (byte*)"pc_loadpacked",
    (byte*)"pc_loadbit",
    (byte*)"pc_loadptr",
    (byte*)"pc_storestring",
    (byte*)"pc_iconvert",
    (byte*)"pc_iconvcase",
    (byte*)"pc_eqstring_nf",
    (byte*)"pc_equal_nf",
    (byte*)"comparebytes",
    (byte*)"pc_compare_nf",
    (byte*)"cmpstring_len",
    (byte*)"pc_eqstring",
    (byte*)"pc_equal",
    (byte*)"pc_compare",
    (byte*)"u8inarray",
    (byte*)"u16inarray",
    (byte*)"u32inarray",
    (byte*)"u64inarray",
    (byte*)"bitinbits",
    (byte*)"pc_strinstr",
    (byte*)"getbitoffset",
    (byte*)"pc_iappendlist",
    (byte*)"pc_iappendarray",
    (byte*)"pc_mul_listi",
    (byte*)"pc_mul_stri",
    (byte*)"pc_duplvar",
    (byte*)"pc_iconcatlist",
    (byte*)"pc_iappendbits",
    (byte*)"pc_makestring",
    (byte*)"pc_makestringx",
    (byte*)"pc_makestringn",
    (byte*)"pc_emptystring",
    (byte*)"pc_makechar",
    (byte*)"$init",
    (byte*)"obj_new",
    (byte*)"freeobject",
    (byte*)"array_new",
    (byte*)"list_new",
    (byte*)"objtovar",
    (byte*)"set_new",
    (byte*)"bits_new",
    (byte*)"struct_new",
    (byte*)"dict_new",
    (byte*)"record_new",
    (byte*)"list_free",
    (byte*)"record_free",
    (byte*)"array_free",
    (byte*)"bits_free",
    (byte*)"dict_free",
    (byte*)"bits_bytesize",
    (byte*)"list_resize",
    (byte*)"array_resize",
    (byte*)"bits_resize",
    (byte*)"string_resize",
    (byte*)"copyonwrite",
    (byte*)"make_strslicexobj",
    (byte*)"bignum_make",
    (byte*)"bx_makestr",
    (byte*)"bx_tostring",
    (byte*)"bx_dupl",
    (byte*)"bx_negto",
    (byte*)"bx_absto",
    (byte*)"makebnvar",
    (byte*)"bx_free",
    (byte*)"bx_makeint",
    (byte*)"bx_add",
    (byte*)"bx_sub",
    (byte*)"bx_mul",
    (byte*)"bx_div",
    (byte*)"bx_idiv",
    (byte*)"bx_irem",
    (byte*)"bx_equal",
    (byte*)"bx_cmp",
    (byte*)"bx_int",
    (byte*)"bx_power",
    (byte*)"bx_reduce",
    (byte*)"bx_length",
    (byte*)"bn_init",
    (byte*)"readexpon",
    (byte*)"bn_print",
    (byte*)"bn_println",
    (byte*)"getbintype",
    (byte*)"makebignum",
    (byte*)"makesmallnum",
    (byte*)"smalltobig",
    (byte*)"freesmall",
    (byte*)"bn_alloc",
    (byte*)"checkedmalloc",
    (byte*)"bn_free",
    (byte*)"freemem",
    (byte*)"bn_setzero",
    (byte*)"bn_move",
    (byte*)"bn_dupl",
    (byte*)"bn_setinf",
    (byte*)"bn_setnan",
    (byte*)"bn_error",
    (byte*)"bn_iszero",
    (byte*)"bn_negto",
    (byte*)"bn_absto",
    (byte*)"bn_isint",
    (byte*)"bn_getprec",
    (byte*)"bn_setprec",
    (byte*)"bn_getglobalprec",
    (byte*)"bn_setglobalprec",
    (byte*)"bn_makeint",
    (byte*)"bn_makefloat",
    (byte*)"bn_ipower",
    (byte*)"smallsubto",
    (byte*)"smallmulto",
    (byte*)"bn_equal",
    (byte*)"bn_addu",
    (byte*)"bn_subu",
    (byte*)"bn_mulu",
    (byte*)"smalldiv",
    (byte*)"bn_idivu",
    (byte*)"strvaln",
    (byte*)"bn_makestr",
    (byte*)"bn_fdivu",
    (byte*)"tostring_float",
    (byte*)"bn_tostring",
    (byte*)"tostring_scient",
    (byte*)"bn_add",
    (byte*)"bn_sub",
    (byte*)"bn_mul",
    (byte*)"bn_mulp",
    (byte*)"bn_div",
    (byte*)"bn_idiv",
    (byte*)"bn_idivrem",
    (byte*)"bn_irem",
    (byte*)"bn_cmp",
    (byte*)"bn_const",
    (byte*)"bn_sign",
    (byte*)"badnumber",
    (byte*)"bn_digits",
    (byte*)"bn_toint",
    (byte*)"bn_tofloat",
    (byte*)"bn_fix",
    (byte*)"bntest",
    (byte*)"pch_print",
    (byte*)"pch_println",
    (byte*)"pch_startprintcon",
    (byte*)"pch_startprint",
    (byte*)"pch_endprint",
    (byte*)"pch_strstartprint",
    (byte*)"pch_strendprint",
    (byte*)"pch_setformat",
    (byte*)"pch_setformat2",
    (byte*)"pch_dprint",
    (byte*)"pch_printnogap",
    (byte*)"initfmtcode",
    (byte*)"i64mintostr",
    (byte*)"u64tostr",
    (byte*)"i64tostrfmt",
    (byte*)"u64tostrfmt",
    (byte*)"strtostrfmt",
    (byte*)"expandstr",
    (byte*)"pc_strtofmt",
    (byte*)"printstrz",
    (byte*)"printstr_n",
    (byte*)"printerror",
    (byte*)"addstring",
    (byte*)"j_tostr_i",
    (byte*)"j_tostr_r",
    (byte*)"j_tostr_w",
    (byte*)"j_tostr_n",
    (byte*)"j_tostr_s",
    (byte*)"j_tostr_l_m",
    (byte*)"j_tostr_a",
    (byte*)"j_tostr_b",
    (byte*)"j_tostr_e",
    (byte*)"j_tostr_k",
    (byte*)"j_tostr_j",
    (byte*)"j_tostr_d",
    (byte*)"j_tostr_z",
    (byte*)"printnextfmtchars",
    (byte*)"getreadfmtcode",
    (byte*)"pch_sreadln",
    (byte*)"pch_strtoval",
    (byte*)"pch_reread",
    (byte*)"pch_rereadln",
    (byte*)"readname",
    (byte*)"readstring",
    (byte*)"readint",
    (byte*)"readhex",
    (byte*)"readbin",
    (byte*)"readreal",
    (byte*)"pch_readln",
    (byte*)"stepkbpos",
    (byte*)"pch_sread",
    (byte*)"domultichar",
    (byte*)"pch_tostr",
    (byte*)"pc_getfmt",
    (byte*)"pc_readlinen",
    (byte*)"readitem",
    (byte*)"readany",
    (byte*)"strtoreal",
    (byte*)"strtoint",
    (byte*)"calltostrtable",
    (byte*)"printbn",
    (byte*)"initcalltables",
    (byte*)"initjhandler",
    (byte*)"add_stable_entry",
    (byte*)"add_dtable_entry",
    (byte*)"def_handler",
    (byte*)"ddef_handler",
    (byte*)"j_add_i_w",
    (byte*)"j_add_r",
    (byte*)"j_add_s",
    (byte*)"j_add_j",
    (byte*)"j_add_e",
    (byte*)"j_add_z",
    (byte*)"j_add_iw_wi",
    (byte*)"j_add_zz",
    (byte*)"j_sub_i_w",
    (byte*)"j_sub_r",
    (byte*)"j_sub_p",
    (byte*)"j_sub_j",
    (byte*)"j_sub_e",
    (byte*)"j_sub_z",
    (byte*)"j_sub_zz",
    (byte*)"j_mixed_iw_wi",
    (byte*)"j_mixed_ir",
    (byte*)"j_mixed_ri",
    (byte*)"j_mixed_ij",
    (byte*)"j_mixed_ji",
    (byte*)"j_mul_i_w",
    (byte*)"j_mul_r",
    (byte*)"j_mul_j",
    (byte*)"j_mul_z",
    (byte*)"j_mul_li",
    (byte*)"j_mul_si",
    (byte*)"j_mul_e",
    (byte*)"j_mul_zz",
    (byte*)"j_div_i",
    (byte*)"j_div_r",
    (byte*)"j_div_j",
    (byte*)"j_div_z",
    (byte*)"j_jumple_i",
    (byte*)"j_jumple_r",
    (byte*)"j_jumple_s",
    (byte*)"j_jumple_z",
    (byte*)"j_jumpeq_i_r_t_o",
    (byte*)"j_jumpeq_v_p_f_g",
    (byte*)"j_jumpeq_s",
    (byte*)"j_jumpeq_z",
    (byte*)"j_jumpeq_zz",
    (byte*)"j_jumpne_i_r_t_o",
    (byte*)"j_jumpne_v_p_f_g",
    (byte*)"j_jumpne_s",
    (byte*)"j_jumpne_z",
    (byte*)"j_jumpne_zz",
    (byte*)"j_jumpge_i",
    (byte*)"j_jumpge_w",
    (byte*)"j_jumpge_r",
    (byte*)"j_jumpge_z",
    (byte*)"j_jumpgt_i",
    (byte*)"j_jumpgt_w",
    (byte*)"j_jumpgt_r",
    (byte*)"j_jumpgt_z",
    (byte*)"j_jumplt_i",
    (byte*)"j_jumplt_v_p",
    (byte*)"j_jumplt_r",
    (byte*)"j_jumplt_z",
    (byte*)"j_pushix_li",
    (byte*)"j_pushix_mi",
    (byte*)"j_pushix_vi",
    (byte*)"j_pushix_ln",
    (byte*)"j_pushix_ll",
    (byte*)"j_pushix_le",
    (byte*)"j_pushix_ai",
    (byte*)"j_pushix_bi_ei",
    (byte*)"j_pushix_an",
    (byte*)"j_pushix_si",
    (byte*)"j_pushix_sn",
    (byte*)"j_pushix_bn",
    (byte*)"j_pushix_di",
    (byte*)"j_pushix_zz",
    (byte*)"j_pushixref_li",
    (byte*)"j_pushixref_ln",
    (byte*)"j_pushixref_ai",
    (byte*)"j_pushixref_si",
    (byte*)"j_pushixref_bi",
    (byte*)"j_pushixref_zz",
    (byte*)"j_pushdotix_si",
    (byte*)"j_pushdotix_sn",
    (byte*)"j_pushdotix_ii",
    (byte*)"j_pushdotix_in",
    (byte*)"j_pushdotix_ei",
    (byte*)"j_pushdotix_mi",
    (byte*)"j_pushdotix_zz",
    (byte*)"j_pushdotixref_si",
    (byte*)"j_pushdotixref_sn",
    (byte*)"j_pushdotixref_ii",
    (byte*)"j_pushdotixref_in_wn",
    (byte*)"j_pushdotixref_ei",
    (byte*)"j_pushdotixref_zz",
    (byte*)"j_addto_i",
    (byte*)"j_addto_r",
    (byte*)"j_addto_s",
    (byte*)"j_addto_p",
    (byte*)"j_addto_z",
    (byte*)"j_addto_si",
    (byte*)"j_addto_ir",
    (byte*)"j_addto_ri",
    (byte*)"j_addto_zz",
    (byte*)"j_subto_i",
    (byte*)"j_subto_r",
    (byte*)"j_subto_z",
    (byte*)"j_subto_ir",
    (byte*)"j_subto_ri",
    (byte*)"j_subto_zz",
    (byte*)"j_multo_i_w",
    (byte*)"j_multo_r",
    (byte*)"j_multo_z",
    (byte*)"j_divto_i_w",
    (byte*)"j_divto_r",
    (byte*)"j_divto_z",
    (byte*)"j_idivto_i",
    (byte*)"j_idivto_z",
    (byte*)"j_iand_i_w",
    (byte*)"j_iand_e",
    (byte*)"j_iand_z",
    (byte*)"j_ior_i_w",
    (byte*)"j_ior_e",
    (byte*)"j_ior_z",
    (byte*)"j_ixor_i_w",
    (byte*)"j_ixor_e",
    (byte*)"j_ixor_z",
    (byte*)"j_iandto_i_w",
    (byte*)"j_iandto_z",
    (byte*)"j_iorto_i_w",
    (byte*)"j_iorto_z",
    (byte*)"j_ixorto_i_w",
    (byte*)"j_ixorto_z",
    (byte*)"j_shlto_i",
    (byte*)"j_shlto_z",
    (byte*)"j_shrto_i",
    (byte*)"j_shrto_z",
    (byte*)"j_concat_s",
    (byte*)"j_concat_l",
    (byte*)"j_concat_z",
    (byte*)"j_concatto_s",
    (byte*)"j_concatto_l",
    (byte*)"j_concatto_z",
    (byte*)"j_append_s",
    (byte*)"j_append_l",
    (byte*)"j_append_a",
    (byte*)"j_append_b",
    (byte*)"j_append_z",
    (byte*)"j_appendto_s",
    (byte*)"j_appendto_l",
    (byte*)"j_appendto_a",
    (byte*)"j_appendto_b_e",
    (byte*)"j_appendto_z",
    (byte*)"j_max_i",
    (byte*)"j_max_r",
    (byte*)"j_max_z",
    (byte*)"j_min_z",
    (byte*)"j_len_l_a_e_s_b_d",
    (byte*)"j_len_m_k",
    (byte*)"j_len_n",
    (byte*)"j_len_z",
    (byte*)"j_lwb_l",
    (byte*)"j_lwb_a_b",
    (byte*)"j_lwb_s_m_k_d",
    (byte*)"j_lwb_e",
    (byte*)"j_lwb_n",
    (byte*)"j_lwb_z",
    (byte*)"j_upb_l",
    (byte*)"j_upb_a_b",
    (byte*)"j_upb_s_d",
    (byte*)"j_upb_m_k",
    (byte*)"j_upb_e",
    (byte*)"j_upb_n",
    (byte*)"j_upb_z",
    (byte*)"j_bounds_l_a_b_s_e",
    (byte*)"j_bounds_m_k",
    (byte*)"j_bounds_n",
    (byte*)"j_bounds_z",
    (byte*)"j_minto_i",
    (byte*)"j_minto_r",
    (byte*)"j_minto_z",
    (byte*)"j_maxto_i",
    (byte*)"j_maxto_r",
    (byte*)"j_maxto_z",
    (byte*)"j_neg_i_w",
    (byte*)"j_neg_r",
    (byte*)"j_neg_j",
    (byte*)"j_neg_e",
    (byte*)"j_neg_z",
    (byte*)"j_abs_i_w",
    (byte*)"j_abs_r",
    (byte*)"j_abs_j",
    (byte*)"j_abs_z",
    (byte*)"j_inot_i_w",
    (byte*)"j_inot_e",
    (byte*)"j_inot_z",
    (byte*)"j_istrue_i_w_r",
    (byte*)"j_istrue_l_a_e_s_b",
    (byte*)"j_istrue_k_m_h",
    (byte*)"j_istrue_j",
    (byte*)"j_istrue_z",
    (byte*)"j_jumpfalse_i_w_r_v_p_f",
    (byte*)"j_jumpfalse_s_l_e_a_b",
    (byte*)"j_jumpfalse_z",
    (byte*)"j_jumptrue_i_r_w_v_p_f",
    (byte*)"j_jumptrue_s_l_e_a_b",
    (byte*)"j_jumptrue_z",
    (byte*)"j_shl_i_w",
    (byte*)"j_shl_z",
    (byte*)"j_shr_i_w",
    (byte*)"j_shr_j_i",
    (byte*)"j_shr_z",
    (byte*)"j_shr_wi",
    (byte*)"j_shr_zz",
    (byte*)"j_idiv_w",
    (byte*)"j_idiv_j",
    (byte*)"j_idiv_z",
    (byte*)"j_rem_w",
    (byte*)"j_rem_j",
    (byte*)"j_remz",
    (byte*)"runproc_m",
    (byte*)"os_getconsize",
    (byte*)"pch_setmesshandler",
    (byte*)"pch_gethostname",
    (byte*)"os_initdllmodules",
    (byte*)"os_loaddllmodule",
    (byte*)"os_initdllfunctions",
    (byte*)"os_loaddllfunction",
    (byte*)"pch_getos",
    (byte*)"pch_gethostsize",
    (byte*)"pch_iswindows",
    (byte*)"os_calldll",
    (byte*)"os_calldllfunction",
    (byte*)"os_pushargs",
    (byte*)"callhostfunction",
    (byte*)"pch_leftstr",
    (byte*)"pch_rightstr",
    (byte*)"pch_convlc",
    (byte*)"pch_convuc",
    (byte*)"pch_iconvlc",
    (byte*)"pch_iconvuc",
    (byte*)"pch_stop",
    (byte*)"pch_stopx",
    (byte*)"pch_ismain",
    (byte*)"pch_waitkey",
    (byte*)"pch_testkey",
    (byte*)"pch_execwait",
    (byte*)"pch_execcmd",
    (byte*)"pch_makestr",
    (byte*)"pch_makestrslice",
    (byte*)"pch_makeref",
    (byte*)"pch_new",
    (byte*)"pch_newheap",
    (byte*)"pch_heapvar",
    (byte*)"pch_freeheap",
    (byte*)"pch_getcmdparam",
    (byte*)"pch_setpcerror",
    (byte*)"pch_setdebug",
    (byte*)"pch_setfprintf",
    (byte*)"pch_ticks",
    (byte*)"pch_sleep",
    (byte*)"pch_random",
    (byte*)"pch_findmetafunction",
    (byte*)"pch_loadpcl",
    (byte*)"pch_runpcl",
    (byte*)"pch_runtask",
    (byte*)"pch_callext",
    (byte*)"pch_system",
    (byte*)"pch_shellexec",
    (byte*)"pch_gethash",
    (byte*)"pch_test",
    (byte*)"pch_pcldata",
    (byte*)"pch_getcstring",
    (byte*)"pch_getparam",
    (byte*)"pch_clearlist",
    (byte*)"pch_makelink",
    (byte*)"pch_allparams",
    (byte*)"pch_stackvars",
    (byte*)"pch_makeempty",
    (byte*)"pch_readlines",
    (byte*)"pch_dictitems",
    (byte*)"pch_setoverload",
    (byte*)"pch_errorinfo",
    (byte*)"getbounds",
    (byte*)"checkparam",
    (byte*)"leftstring",
    (byte*)"rightstring",
    (byte*)"padstring_right",
    (byte*)"padstring_left",
    (byte*)"pcld_makevint",
    (byte*)"pcld_makelist",
    (byte*)"getproctabledata",
    (byte*)"convert_handler",
    (byte*)"addtoproclist",
    (byte*)"tostr_handler",
    (byte*)"add_handler",
    (byte*)"addovrecord",
    (byte*)"findapplproc",
    (byte*)"do_callapplproc",
    (byte*)"vartopack",
    (byte*)"dummyfn",
    (byte*)"pythag",
    (byte*)"new_random",
    (byte*)"new_heapvar",
    (byte*)"mfib",
    (byte*)"dx_iorset",
    (byte*)"dx_iandset",
    (byte*)"dx_ixorset",
    (byte*)"dx_inotset",
    (byte*)"dx_subset",
    (byte*)"inotsetbits",
    (byte*)"iorsetbits",
    (byte*)"iandsetbits",
    (byte*)"ixorsetbits",
    (byte*)"subsetbits",
    (byte*)"iresizeset",
    (byte*)"dx_varinvar",
    (byte*)"dx_mixed",
    (byte*)"k_zero",
    (byte*)"k_nop",
    (byte*)"k_procstart",
    (byte*)"k_procend",
    (byte*)"k_endmodule",
    (byte*)"k_push_m",
    (byte*)"k_push_f",
    (byte*)"k_push_am",
    (byte*)"k_push_af",
    (byte*)"k_push_ap",
    (byte*)"k_push_al",
    (byte*)"k_push_ci",
    (byte*)"k_push_cw",
    (byte*)"k_push_cr",
    (byte*)"k_push_cn",
    (byte*)"k_push_cs",
    (byte*)"k_push_t",
    (byte*)"k_push_op",
    (byte*)"k_pushz",
    (byte*)"k_pushz_void",
    (byte*)"k_pushz_str",
    (byte*)"k_pushz_list",
    (byte*)"k_pushz_listl",
    (byte*)"k_pushz_set",
    (byte*)"k_pushz_arrayl",
    (byte*)"k_pop_m",
    (byte*)"k_pop_f",
    (byte*)"k_store_m",
    (byte*)"k_store_f",
    (byte*)"k_pushptr",
    (byte*)"k_popptr",
    (byte*)"k_storeptr",
    (byte*)"k_zpop_m",
    (byte*)"k_zpop_f",
    (byte*)"k_zstore_m",
    (byte*)"k_zstore_f",
    (byte*)"k_copy",
    (byte*)"k_swap",
    (byte*)"k_convptr",
    (byte*)"k_jump",
    (byte*)"k_jumpptr",
    (byte*)"k_jumptrue",
    (byte*)"k_jumpfalse",
    (byte*)"k_jumpdef",
    (byte*)"k_jumpvoid",
    (byte*)"k_jumpeq",
    (byte*)"k_jumpne",
    (byte*)"k_jumplt",
    (byte*)"k_jumple",
    (byte*)"k_jumpge",
    (byte*)"k_jumpgt",
    (byte*)"k_jumptesteq",
    (byte*)"k_jumptestne",
    (byte*)"k_jumplabel",
    (byte*)"k_jumpclabel",
    (byte*)"k_switch",
    (byte*)"k_cswitch",
    (byte*)"k_new",
    (byte*)"k_to_f",
    (byte*)"k_for_fci",
    (byte*)"k_for_ff",
    (byte*)"k_ford_fci",
    (byte*)"k_ford_ff",
    (byte*)"k_call",
    (byte*)"k_callptr",
    (byte*)"k_return",
    (byte*)"k_startdll",
    (byte*)"k_pushdll",
    (byte*)"k_calldll",
    (byte*)"k_callhost",
    (byte*)"k_stackframe",
    (byte*)"k_free",
    (byte*)"k_addsp",
    (byte*)"k_stop",
    (byte*)"k_test",
    (byte*)"k_makelist",
    (byte*)"k_makerecord",
    (byte*)"k_makearray",
    (byte*)"k_makestruct",
    (byte*)"k_makeset",
    (byte*)"k_makerange",
    (byte*)"k_makedict",
    (byte*)"k_pushdot",
    (byte*)"k_pushdotref",
    (byte*)"k_softconv",
    (byte*)"k_hardconv",
    (byte*)"k_mixed",
    (byte*)"k_incrptr",
    (byte*)"k_incrto_m",
    (byte*)"k_incrto_f",
    (byte*)"k_loadincr",
    (byte*)"k_incrload",
    (byte*)"k_decrptr",
    (byte*)"k_decrto_m",
    (byte*)"k_decrto_f",
    (byte*)"k_loaddecr",
    (byte*)"k_decrload",
    (byte*)"k_incr",
    (byte*)"k_decr",
    (byte*)"k_neg",
    (byte*)"k_abs",
    (byte*)"k_not",
    (byte*)"k_inot",
    (byte*)"k_istrue",
    (byte*)"k_asc",
    (byte*)"k_chr",
    (byte*)"k_sqrt",
    (byte*)"k_sqr",
    (byte*)"k_cube",
    (byte*)"k_sin",
    (byte*)"k_cos",
    (byte*)"k_tan",
    (byte*)"k_asin",
    (byte*)"k_acos",
    (byte*)"k_atan",
    (byte*)"k_sign",
    (byte*)"k_ln",
    (byte*)"k_log",
    (byte*)"k_lg",
    (byte*)"k_exp",
    (byte*)"k_round",
    (byte*)"k_floor",
    (byte*)"k_ceil",
    (byte*)"k_fract",
    (byte*)"k_negto",
    (byte*)"k_absto",
    (byte*)"k_notto",
    (byte*)"k_inotto",
    (byte*)"k_len",
    (byte*)"k_lwb",
    (byte*)"k_upb",
    (byte*)"k_bounds",
    (byte*)"k_bits",
    (byte*)"k_bytes",
    (byte*)"k_type",
    (byte*)"k_elemtype",
    (byte*)"k_basetype",
    (byte*)"k_minval",
    (byte*)"k_maxval",
    (byte*)"k_isint",
    (byte*)"k_isreal",
    (byte*)"k_isstring",
    (byte*)"k_isrange",
    (byte*)"k_isnumber",
    (byte*)"k_isarray",
    (byte*)"k_isrecord",
    (byte*)"k_ispointer",
    (byte*)"k_ismutable",
    (byte*)"k_isset",
    (byte*)"k_isvoid",
    (byte*)"k_isdef",
    (byte*)"k_tostr",
    (byte*)"k_isequal",
    (byte*)"k_add",
    (byte*)"k_sub",
    (byte*)"k_mul",
    (byte*)"k_div",
    (byte*)"k_idiv",
    (byte*)"k_rem",
    (byte*)"k_divrem",
    (byte*)"k_iand",
    (byte*)"k_ior",
    (byte*)"k_ixor",
    (byte*)"k_shl",
    (byte*)"k_shr",
    (byte*)"k_in",
    (byte*)"k_notin",
    (byte*)"k_inrev",
    (byte*)"k_eq",
    (byte*)"k_ne",
    (byte*)"k_lt",
    (byte*)"k_le",
    (byte*)"k_ge",
    (byte*)"k_gt",
    (byte*)"k_min",
    (byte*)"k_max",
    (byte*)"k_concat",
    (byte*)"k_append",
    (byte*)"k_power",
    (byte*)"k_atan2",
    (byte*)"k_addto",
    (byte*)"k_subto",
    (byte*)"k_multo",
    (byte*)"k_divto",
    (byte*)"k_idivto",
    (byte*)"k_iandto",
    (byte*)"k_iorto",
    (byte*)"k_ixorto",
    (byte*)"k_shlto",
    (byte*)"k_shrto",
    (byte*)"k_minto",
    (byte*)"k_maxto",
    (byte*)"k_concatto",
    (byte*)"k_appendto",
    (byte*)"k_pushix",
    (byte*)"k_pushdotix",
    (byte*)"k_pushkeyix",
    (byte*)"k_pushkeyixd",
    (byte*)"k_pushixref",
    (byte*)"k_pushdotixref",
    (byte*)"k_pushkeyixref",
    (byte*)"k_pushbyteix",
    (byte*)"k_pushbyteixref",
    (byte*)"k_appendset",
    (byte*)"k_pushdotm",
    (byte*)"k_pushdott",
    (byte*)"k_push_ad",
    (byte*)"k_push_try",
    (byte*)"k_raise",
    (byte*)"k_applyop",
    (byte*)"k_makeiter",
    (byte*)"k_forall",
    (byte*)"k_forallx",
    (byte*)"k_foreach",
    (byte*)"k_foreachx",
    (byte*)"k_expandrange",
    (byte*)"k_callappl",
    (byte*)"fixup_asm",
    (byte*)"asmavailable",
    (byte*)"addcountint",
    (byte*)"addcountext",
    (byte*)"showasmcmd",
    (byte*)"disploop_asm",
    (byte*)"getasmjump",
    (byte*)"qcompiler_prod",
    (byte*)"do_loadmodules",
    (byte*)"loadmainmodule",
    (byte*)"addmodule",
    (byte*)"loadimport",
    (byte*)"readimportlist",
    (byte*)"initdata",
    (byte*)"initsearchdirs",
    (byte*)"addsearchdir",
    (byte*)"getmodulestr",
    (byte*)"findmodule",
    (byte*)"checkname",
    (byte*)"do_parse",
    (byte*)"do_name",
    (byte*)"do_pclgen",
    (byte*)"loaderror",
    (byte*)"getsyscmdline",
    (byte*)"checkkeyword",
    (byte*)"readinttoken",
    (byte*)"do_writepcfile",
    (byte*)"writesymbols",
    (byte*)"showpcsymbol",
    (byte*)"writepccode2pc",
    (byte*)"writestructfields",
    (byte*)"fixup_genfields",
    (byte*)"showhelp",
    (byte*)"nextcmd",
    (byte*)"writedocs",
    (byte*)"do_writeqa",
    (byte*)"prterror",
    (byte*)"serror_gen",
    (byte*)"serror",
    (byte*)"serror_ss",
    (byte*)"serror_s",
    (byte*)"error_gen",
    (byte*)"rxerror",
    (byte*)"gerror",
    (byte*)"rxerror_s",
    (byte*)"testelem",
    (byte*)"setelem",
    (byte*)"inittypetables",
    (byte*)"nextpoweroftwo",
    (byte*)"initpcdest",
    (byte*)"getpcpos",
    (byte*)"setpcpos",
    (byte*)"writepcdata",
    (byte*)"writezstring",
    (byte*)"writezblock",
    (byte*)"writezint",
    (byte*)"writezint4",
    (byte*)"writezrange",
    (byte*)"writezreal",
    (byte*)"writezeof",
    (byte*)"ipower",
    (byte*)"gs_additem",
    (byte*)"isalphanum",
    (byte*)"outpcbyte",
    (byte*)"outpcword",
    (byte*)"outpcword16",
    (byte*)"writeqafile",
    (byte*)"addqafile",
    (byte*)"lexreadtoken",
    (byte*)"lxreadstring",
    (byte*)"readnumber",
    (byte*)"readrealnumber",
    (byte*)"readexponent",
    (byte*)"lxerror",
    (byte*)"printsymbol",
    (byte*)"stringtonumber",
    (byte*)"lexsetup",
    (byte*)"scannumber",
    (byte*)"readrawstring",
    (byte*)"lookup",
    (byte*)"gethashvaluez",
    (byte*)"inithashtable",
    (byte*)"dolexdirective",
    (byte*)"lexreadline",
    (byte*)"startlex",
    (byte*)"convertzstring",
    (byte*)"addnamestr",
    (byte*)"ps1",
    (byte*)"ps2",
    (byte*)"ps",
    (byte*)"lex",
    (byte*)"showhashtablesize",
    (byte*)"addmacro",
    (byte*)"stackmacro",
    (byte*)"unstackmacro",
    (byte*)"parsemodule",
    (byte*)"readmoduledefs",
    (byte*)"initparser",
    (byte*)"skipsemi",
    (byte*)"addalias",
    (byte*)"makeblock",
    (byte*)"checkequals",
    (byte*)"getcurrline",
    (byte*)"checkbegin",
    (byte*)"checkbeginend",
    (byte*)"checkend",
    (byte*)"addgenfield",
    (byte*)"readvardef",
    (byte*)"readconstdef",
    (byte*)"readexpression",
    (byte*)"readfactor",
    (byte*)"readterm",
    (byte*)"readlbrack",
    (byte*)"addlistunit",
    (byte*)"addlistparam",
    (byte*)"readlsqbrack",
    (byte*)"readcast",
    (byte*)"readopc",
    (byte*)"readsprint",
    (byte*)"readsread",
    (byte*)"readcompilervar",
    (byte*)"readcastx",
    (byte*)"checksymbol",
    (byte*)"readtypespec",
    (byte*)"readhostparams",
    (byte*)"readslist",
    (byte*)"readindex",
    (byte*)"readkeyindex",
    (byte*)"readdotsuffix",
    (byte*)"isconstexpr",
    (byte*)"readconstexpr",
    (byte*)"readconstexprvalue",
    (byte*)"readconstint",
    (byte*)"readprocdef",
    (byte*)"readprocdecl",
    (byte*)"readparams",
    (byte*)"readparamsff",
    (byte*)"readparamsff_types",
    (byte*)"readparamsff_names",
    (byte*)"readblock",
    (byte*)"readexecstmt",
    (byte*)"readstmtexpr",
    (byte*)"readcondsuffix",
    (byte*)"readif",
    (byte*)"readgoto",
    (byte*)"readunless",
    (byte*)"readswitchcase",
    (byte*)"readstop",
    (byte*)"readreturn",
    (byte*)"readdo",
    (byte*)"readto",
    (byte*)"readwhile",
    (byte*)"readrepeat",
    (byte*)"readloopcontrol",
    (byte*)"readprint",
    (byte*)"readread",
    (byte*)"readtry",
    (byte*)"readraise",
    (byte*)"readfor",
    (byte*)"readforall",
    (byte*)"readtypedef",
    (byte*)"readstructdef",
    (byte*)"readstructfields",
    (byte*)"readtabledef",
    (byte*)"readclassdef",
    (byte*)"readclassbody",
    (byte*)"readenumtype",
    (byte*)"readrecordfields",
    (byte*)"readimportmodule",
    (byte*)"readimportbody",
    (byte*)"createprocdef",
    (byte*)"readequivfield",
    (byte*)"testconstruct",
    (byte*)"readapplyop",
    (byte*)"readapplprocs",
    (byte*)"defineapplproc",
    (byte*)"findapplproc",
    (byte*)"addapplproc",
    (byte*)"readapplcall",
    (byte*)"newstrec",
    (byte*)"initqclib",
    (byte*)"getduplnameptr",
    (byte*)"adddef",
    (byte*)"adddef_nodupl",
    (byte*)"printst",
    (byte*)"printstrec",
    (byte*)"printstflat",
    (byte*)"newunitrec",
    (byte*)"createname",
    (byte*)"createunit0",
    (byte*)"createunit1",
    (byte*)"createunit2",
    (byte*)"createunit3",
    (byte*)"createconstunit",
    (byte*)"createstringconstunit",
    (byte*)"getoptocode",
    (byte*)"checkpackedtype",
    (byte*)"checkunpackedtype",
    (byte*)"checkdlltype",
    (byte*)"createtype",
    (byte*)"createusertype",
    (byte*)"createusertypefromstr",
    (byte*)"getconstvalue",
    (byte*)"getrangelwb",
    (byte*)"getrangeupb",
    (byte*)"getrangelwbunit",
    (byte*)"getrangeupbunit",
    (byte*)"createarraymode",
    (byte*)"nextautotype",
    (byte*)"createstringmode",
    (byte*)"createrefpackmode",
    (byte*)"getscope",
    (byte*)"setnameptr",
    (byte*)"printcode",
    (byte*)"printunit",
    (byte*)"printunitlist",
    (byte*)"getprefix",
    (byte*)"getdottedname",
    (byte*)"getlineinfok",
    (byte*)"getavname",
    (byte*)"unionstr_clear",
    (byte*)"unionstr_append",
    (byte*)"unionstr_concat",
    (byte*)"unionstr_last",
    (byte*)"unionstr_copy",
    (byte*)"unionstr_print",
    (byte*)"createrecordmode",
    (byte*)"createenummode",
    (byte*)"convertstring",
    (byte*)"strexpr",
    (byte*)"jeval",
    (byte*)"getopcjname",
    (byte*)"strmode",
    (byte*)"istrmode",
    (byte*)"countunits",
    (byte*)"finddefstr",
    (byte*)"purgesymbol",
    (byte*)"purgesymbollist",
    (byte*)"purgeprocs",
    (byte*)"purgeproc",
    (byte*)"printmodelist",
    (byte*)"printgenfieldtable",
    (byte*)"addtoproclist",
    (byte*)"newusertypex",
    (byte*)"storemode",
    (byte*)"duplunit",
    (byte*)"rx_unit",
    (byte*)"rx_module",
    (byte*)"rx_deflist",
    (byte*)"rx_passdef",
    (byte*)"rx_unitlist",
    (byte*)"resolvetopname",
    (byte*)"resolvename",
    (byte*)"finddupl",
    (byte*)"resolvedot",
    (byte*)"fixmode",
    (byte*)"fixmode2",
    (byte*)"fixusertypes",
    (byte*)"resolve_equiv_name",
    (byte*)"addframevar",
    (byte*)"converteqeq",
    (byte*)"evalbinop",
    (byte*)"evalbinop_real",
    (byte*)"makenewconst",
    (byte*)"evalmonop",
    (byte*)"tx_typetable",
    (byte*)"checkconstexpr",
    (byte*)"converttype",
    (byte*)"scanstruct",
    (byte*)"scanrecord",
    (byte*)"shiftflagsleft",
    (byte*)"getconstint",
    (byte*)"checkdict",
    (byte*)"checkconstlist",
    (byte*)"duplfield",
    (byte*)"dobaseclass",
    (byte*)"evalexpr",
    (byte*)"do_stmt",
    (byte*)"codegen",
    (byte*)"scanidata",
    (byte*)"genidata",
    (byte*)"initgenpcl",
    (byte*)"doprogramstartup",
    (byte*)"do_block",
    (byte*)"do_print",
    (byte*)"do_fprint",
    (byte*)"do_read",
    (byte*)"do_assign",
    (byte*)"do_to",
    (byte*)"do_while",
    (byte*)"do_repeat",
    (byte*)"do_forstep",
    (byte*)"do_forall",
    (byte*)"do_do",
    (byte*)"do_cfor",
    (byte*)"do_if",
    (byte*)"do_longif",
    (byte*)"do_callproc",
    (byte*)"do_callhostproc",
    (byte*)"do_return",
    (byte*)"genstartproc",
    (byte*)"do_procdef",
    (byte*)"genprocentry",
    (byte*)"genprocexit",
    (byte*)"do_preincr",
    (byte*)"do_exit",
    (byte*)"do_goto",
    (byte*)"do_switch",
    (byte*)"do_simpleswitch",
    (byte*)"do_case",
    (byte*)"do_try",
    (byte*)"do_applyop",
    (byte*)"evalref",
    (byte*)"getpclop",
    (byte*)"genjumpl",
    (byte*)"definelabel",
    (byte*)"createfwdlabel",
    (byte*)"definefwdlabel",
    (byte*)"stacklooplabels",
    (byte*)"unstacklooplabels",
    (byte*)"findlooplabel",
    (byte*)"issimpleparam",
    (byte*)"genjumpcond",
    (byte*)"gcomparejump",
    (byte*)"reversecond",
    (byte*)"do_convert",
    (byte*)"do_selectx",
    (byte*)"do_calldll",
    (byte*)"islogical",
    (byte*)"do_and",
    (byte*)"do_or",
    (byte*)"do_callptr",
    (byte*)"do_callmproc",
    (byte*)"checkblockreturn",
    (byte*)"genfree",
    (byte*)"do_clamp",
    (byte*)"do_applyopx",
    (byte*)"do_calldllvar",
    (byte*)"callhostfn",
    (byte*)"extractparams",
    (byte*)"unitstoarray",
    (byte*)"do_idiv",
    (byte*)"ispoweroftwo",
    (byte*)"genpushint",
    (byte*)"do_callappl",
    (byte*)"initpcl",
    (byte*)"initpcldata",
    (byte*)"initpclgen",
    (byte*)"writepcl3",
    (byte*)"writepclopnd3",
    (byte*)"writepccode",
    (byte*)"genpc",
    (byte*)"genopnd_int",
    (byte*)"genopnd_s",
    (byte*)"genpc_int",
    (byte*)"genpc_int2",
    (byte*)"genpc_int4",
    (byte*)"genpc_s",
    (byte*)"genpc_str",
    (byte*)"genopnd_str",
    (byte*)"genpc_lab",
    (byte*)"isframe_s",
    (byte*)"addstringtotable",
    (byte*)"getintlib",
(byte*)""};
static struct msysnewc_procinforec msysnewc__fnexports[]= {
{805, 1,3, {1,1,1,0,0,0,0,0,0,0,0,0}},
{806, 1,1, {1,0,0,0,0,0,0,0,0,0,0,0}},
{807, 19,1, {19,0,0,0,0,0,0,0,0,0,0,0}},
{808, 19,1, {19,0,0,0,0,0,0,0,0,0,0,0}},
{809, 1,1, {1,0,0,0,0,0,0,0,0,0,0,0}},
	{0, 0,0, {0,0,0, 0,0,0, 0,0,0, 0,0,0}}}
;
static int64_t msysnewc__fnnprocs=1403;
static int64_t msysnewc__fnnexports=5;
static int64_t msysnewc_fmtparam;
int64_t msysnewc_needgap = (int64_t)0;
static int64_t msysnewc_outdev = (int64_t)1;
static void *  msysnewc_outchan = 0;
static uint8_t *  msysnewc_fmtstr = 0;
static void *  msysnewc_outchan_stack[10];
static int64_t msysnewc_outdev_stack[10];
static uint8_t *  msysnewc_fmtstr_stack[10];
static byte msysnewc_needgap_stack[10];
static uint8_t *  msysnewc_ptr_stack[10];
static int64_t msysnewc_niostack = (int64_t)0;
static uint8_t msysnewc_digits[16] = {
    '0',
    '1',
    '2',
    '3',
    '4',
    '5',
    '6',
    '7',
    '8',
    '9',
    'A',
    'B',
    'C',
    'D',
    'E',
    'F'
};
static struct msysnewc_fmtrec msysnewc_defaultfmt = {
    (uint8_t)0u,
    (int8_t)0,
    (uint8_t)10u,
    (uint64_t)0u,
    ' ',
    'f',
    (uint64_t)0u,
    (uint64_t)0u,
    (uint64_t)0u,
    'R',
    (uint64_t)0u,
    (uint64_t)0u,
    (uint64_t)0u,
    (uint64_t)0u,
    (uint64_t)0u,
    (uint8_t)0u
};
static uint8_t *  msysnewc_rd_buffer;
static int64_t msysnewc_rd_length;
static uint8_t *  msysnewc_rd_pos;
static uint8_t *  msysnewc_rd_lastpos;
static int64_t msysnewc_termchar;
static int64_t msysnewc_itemerror;
int64_t msysnewc_nsysparams;
uint8_t *  msysnewc_sysparams[128];
static uint64_t msysnewc_callbackstack[9][8];
static int64_t msysnewc_ncallbacks = (int64_t)0;
static uint64_t msysnewc_mask63 = (uint64_t)9223372036854775807u;
static double msysnewc_offset64 = (double)9223372036854775800.;
static double msysnewc_offset32 = (double)9223372036854775800.;
int64_t mlib_mdebug;
uint64_t mlib_allocupper[301];
int64_t mlib_alloccode;
int64_t mlib_allocbytes;
int64_t mlib_fdebug = (int64_t)0;
int64_t mlib_rfsize;
static uint64_t mlib_maxmemory;
static int64_t mlib_maxalloccode;
static byte mlib_pcm_setup = (uint8_t)0u;
static int64_t mlib_show = (int64_t)0;
int64_t mlib_memtotal = (int64_t)0;
int64_t mlib_smallmemtotal = (int64_t)0;
int64_t mlib_smallmemobjs = (int64_t)0;
int64_t mlib_maxmemtotal = (int64_t)0;
static int32_t *  mlib_memalloctable[500001];
static int32_t mlib_memallocsize[500001];
static byte *  mlib_pcheapstart;
static byte *  mlib_pcheapend;
static byte *  mlib_pcheapptr;
static byte mlib_sizeindextable[2049];
uint64_t *  mlib_freelist[9];
uint8_t *  mlib_pmnames[6] = {(uint8_t*)"pm_end",(uint8_t*)"pm_option",(uint8_t*)"pm_sourcefile",(uint8_t*)"pm_libfile",(uint8_t*)"pm_colon",(uint8_t*)"pm_extra"};
static int64_t mlib_seed[2] = {(int64_t)2993073034246558322,(int64_t)1617678968452121188};
static int64_t osnos_init_flag = (int64_t)0;
int64_t pci_dispatch_type = (int64_t)5;
uint8_t *  pci_filetypenames[4] = {(uint8_t*)"pc_file",(uint8_t*)"q_file",(uint8_t*)"qq_file",(uint8_t*)"mem_file"};
uint8_t *  pci_errorcodenames[5] = {(uint8_t*)"Runtime error",(uint8_t*)"General load error:",(uint8_t*)"Couldn't compile:",(uint8_t*)"File not found:",(uint8_t*)"normal_exit"};
static void *  pci_handlertable[218] = {
    0,
    (void *)(&pc_khandlers_k_nop),
    (void *)(&pc_khandlers_k_procstart),
    (void *)(&pc_khandlers_k_procend),
    (void *)(&pc_khandlers_k_endmodule),
    (void *)(&pc_khandlers_k_push_m),
    (void *)(&pc_khandlers_k_push_f),
    (void *)(&pc_khandlers_k_push_am),
    (void *)(&pc_khandlers_k_push_af),
    (void *)(&pc_khandlers_k_push_ap),
    (void *)(&pc_khandlers_k_push_al),
    (void *)(&pc_khandlers_k_push_ci),
    (void *)(&pc_khandlers_k_push_cw),
    (void *)(&pc_khandlers_k_push_cr),
    (void *)(&pc_khandlers_k_push_cn),
    (void *)(&pc_khandlers_k_push_cs),
    (void *)(&pc_khandlers_k_push_t),
    (void *)(&pc_khandlers_k_push_op),
    (void *)(&pc_khandlers_k_pushz),
    (void *)(&pc_khandlers_k_pushz_void),
    (void *)(&pc_khandlers_k_pushz_str),
    (void *)(&pc_khandlers_k_pushz_list),
    (void *)(&pc_khandlers_k_pushz_listl),
    (void *)(&pc_khandlers_k_pushz_set),
    (void *)(&pc_khandlers_k_pushz_arrayl),
    (void *)(&pc_khandlers_k_pop_m),
    (void *)(&pc_khandlers_k_pop_f),
    (void *)(&pc_khandlers_k_store_m),
    (void *)(&pc_khandlers_k_store_f),
    (void *)(&pc_khandlers_k_pushptr),
    (void *)(&pc_khandlers_k_popptr),
    (void *)(&pc_khandlers_k_storeptr),
    (void *)(&pc_khandlers_k_zpop_m),
    (void *)(&pc_khandlers_k_zpop_f),
    (void *)(&pc_khandlers_k_zstore_m),
    (void *)(&pc_khandlers_k_zstore_f),
    (void *)(&pc_khandlers_k_copy),
    (void *)(&pc_khandlers_k_swap),
    (void *)(&pc_khandlers_k_convptr),
    (void *)(&pc_khandlers_k_jump),
    (void *)(&pc_khandlers_k_jumpptr),
    (void *)(&pc_khandlers_k_jumptrue),
    (void *)(&pc_khandlers_k_jumpfalse),
    (void *)(&pc_khandlers_k_jumpdef),
    (void *)(&pc_khandlers_k_jumpvoid),
    (void *)(&pc_khandlers_k_jumpeq),
    (void *)(&pc_khandlers_k_jumpne),
    (void *)(&pc_khandlers_k_jumplt),
    (void *)(&pc_khandlers_k_jumple),
    (void *)(&pc_khandlers_k_jumpge),
    (void *)(&pc_khandlers_k_jumpgt),
    (void *)(&pc_khandlers_k_jumptesteq),
    (void *)(&pc_khandlers_k_jumptestne),
    (void *)(&pc_khandlers_k_jumplabel),
    (void *)(&pc_khandlers_k_jumpclabel),
    (void *)(&pc_khandlers_k_switch),
    (void *)(&pc_khandlers_k_cswitch),
    (void *)(&pc_khandlers_k_new),
    (void *)(&pc_khandlers_k_to_f),
    (void *)(&pc_khandlers_k_for_fci),
    (void *)(&pc_khandlers_k_for_ff),
    (void *)(&pc_khandlers_k_ford_fci),
    (void *)(&pc_khandlers_k_ford_ff),
    (void *)(&pc_khandlers_k_call),
    (void *)(&pc_khandlers_k_callptr),
    (void *)(&pc_khandlers_k_return),
    (void *)(&pc_khandlers_k_startdll),
    (void *)(&pc_khandlers_k_pushdll),
    (void *)(&pc_khandlers_k_calldll),
    (void *)(&pc_khandlers_k_callhost),
    (void *)(&pc_khandlers_k_stackframe),
    (void *)(&pc_khandlers_k_free),
    (void *)(&pc_khandlers_k_addsp),
    (void *)(&pc_khandlers_k_stop),
    (void *)(&pc_khandlers_k_test),
    (void *)(&pc_khandlers_k_makelist),
    (void *)(&pc_khandlers_k_makerecord),
    (void *)(&pc_khandlers_k_makearray),
    (void *)(&pc_khandlers_k_makestruct),
    (void *)(&pc_khandlers_k_makeset),
    (void *)(&pc_khandlers_k_makerange),
    (void *)(&pc_khandlers_k_makedict),
    (void *)(&pc_khandlers_k_pushdot),
    (void *)(&pc_khandlers_k_pushdotref),
    (void *)(&pc_khandlers_k_softconv),
    (void *)(&pc_khandlers_k_hardconv),
    (void *)(&pc_khandlers_k_mixed),
    (void *)(&pc_khandlers_k_incrptr),
    (void *)(&pc_khandlers_k_incrto_m),
    (void *)(&pc_khandlers_k_incrto_f),
    (void *)(&pc_khandlers_k_loadincr),
    (void *)(&pc_khandlers_k_incrload),
    (void *)(&pc_khandlers_k_decrptr),
    (void *)(&pc_khandlers_k_decrto_m),
    (void *)(&pc_khandlers_k_decrto_f),
    (void *)(&pc_khandlers_k_loaddecr),
    (void *)(&pc_khandlers_k_decrload),
    (void *)(&pc_khandlers_k_incr),
    (void *)(&pc_khandlers_k_decr),
    (void *)(&pc_khandlers_k_neg),
    (void *)(&pc_khandlers_k_abs),
    (void *)(&pc_khandlers_k_not),
    (void *)(&pc_khandlers_k_inot),
    (void *)(&pc_khandlers_k_istrue),
    (void *)(&pc_khandlers_k_asc),
    (void *)(&pc_khandlers_k_chr),
    (void *)(&pc_khandlers_k_sqrt),
    (void *)(&pc_khandlers_k_sqr),
    (void *)(&pc_khandlers_k_cube),
    (void *)(&pc_khandlers_k_sin),
    (void *)(&pc_khandlers_k_cos),
    (void *)(&pc_khandlers_k_tan),
    (void *)(&pc_khandlers_k_asin),
    (void *)(&pc_khandlers_k_acos),
    (void *)(&pc_khandlers_k_atan),
    (void *)(&pc_khandlers_k_sign),
    (void *)(&pc_khandlers_k_ln),
    (void *)(&pc_khandlers_k_log),
    (void *)(&pc_khandlers_k_lg),
    (void *)(&pc_khandlers_k_exp),
    (void *)(&pc_khandlers_k_round),
    (void *)(&pc_khandlers_k_floor),
    (void *)(&pc_khandlers_k_ceil),
    (void *)(&pc_khandlers_k_fract),
    (void *)(&pc_khandlers_k_negto),
    (void *)(&pc_khandlers_k_absto),
    (void *)(&pc_khandlers_k_notto),
    (void *)(&pc_khandlers_k_inotto),
    (void *)(&pc_khandlers_k_len),
    (void *)(&pc_khandlers_k_lwb),
    (void *)(&pc_khandlers_k_upb),
    (void *)(&pc_khandlers_k_bounds),
    (void *)(&pc_khandlers_k_bits),
    (void *)(&pc_khandlers_k_bytes),
    (void *)(&pc_khandlers_k_type),
    (void *)(&pc_khandlers_k_elemtype),
    (void *)(&pc_khandlers_k_basetype),
    (void *)(&pc_khandlers_k_minval),
    (void *)(&pc_khandlers_k_maxval),
    (void *)(&pc_khandlers_k_isint),
    (void *)(&pc_khandlers_k_isreal),
    (void *)(&pc_khandlers_k_isstring),
    (void *)(&pc_khandlers_k_isrange),
    (void *)(&pc_khandlers_k_isnumber),
    (void *)(&pc_khandlers_k_isarray),
    (void *)(&pc_khandlers_k_isrecord),
    (void *)(&pc_khandlers_k_ispointer),
    (void *)(&pc_khandlers_k_ismutable),
    (void *)(&pc_khandlers_k_isset),
    (void *)(&pc_khandlers_k_isvoid),
    (void *)(&pc_khandlers_k_isdef),
    (void *)(&pc_khandlers_k_tostr),
    (void *)(&pc_khandlers_k_isequal),
    (void *)(&pc_khandlers_k_add),
    (void *)(&pc_khandlers_k_sub),
    (void *)(&pc_khandlers_k_mul),
    (void *)(&pc_khandlers_k_div),
    (void *)(&pc_khandlers_k_idiv),
    (void *)(&pc_khandlers_k_rem),
    (void *)(&pc_khandlers_k_divrem),
    (void *)(&pc_khandlers_k_iand),
    (void *)(&pc_khandlers_k_ior),
    (void *)(&pc_khandlers_k_ixor),
    (void *)(&pc_khandlers_k_shl),
    (void *)(&pc_khandlers_k_shr),
    (void *)(&pc_khandlers_k_in),
    (void *)(&pc_khandlers_k_notin),
    (void *)(&pc_khandlers_k_inrev),
    (void *)(&pc_khandlers_k_eq),
    (void *)(&pc_khandlers_k_ne),
    (void *)(&pc_khandlers_k_lt),
    (void *)(&pc_khandlers_k_le),
    (void *)(&pc_khandlers_k_ge),
    (void *)(&pc_khandlers_k_gt),
    (void *)(&pc_khandlers_k_min),
    (void *)(&pc_khandlers_k_max),
    (void *)(&pc_khandlers_k_concat),
    (void *)(&pc_khandlers_k_append),
    (void *)(&pc_khandlers_k_power),
    (void *)(&pc_khandlers_k_atan2),
    (void *)(&pc_khandlers_k_addto),
    (void *)(&pc_khandlers_k_subto),
    (void *)(&pc_khandlers_k_multo),
    (void *)(&pc_khandlers_k_divto),
    (void *)(&pc_khandlers_k_idivto),
    (void *)(&pc_khandlers_k_iandto),
    (void *)(&pc_khandlers_k_iorto),
    (void *)(&pc_khandlers_k_ixorto),
    (void *)(&pc_khandlers_k_shlto),
    (void *)(&pc_khandlers_k_shrto),
    (void *)(&pc_khandlers_k_minto),
    (void *)(&pc_khandlers_k_maxto),
    (void *)(&pc_khandlers_k_concatto),
    (void *)(&pc_khandlers_k_appendto),
    (void *)(&pc_khandlers_k_pushix),
    (void *)(&pc_khandlers_k_pushdotix),
    (void *)(&pc_khandlers_k_pushkeyix),
    (void *)(&pc_khandlers_k_pushkeyixd),
    (void *)(&pc_khandlers_k_pushixref),
    (void *)(&pc_khandlers_k_pushdotixref),
    (void *)(&pc_khandlers_k_pushkeyixref),
    (void *)(&pc_khandlers_k_pushbyteix),
    (void *)(&pc_khandlers_k_pushbyteixref),
    (void *)(&pc_khandlers_k_appendset),
    (void *)(&pc_khandlers_k_pushdotm),
    (void *)(&pc_khandlers_k_pushdott),
    (void *)(&pc_khandlers_k_push_ad),
    (void *)(&pc_khandlers_k_push_try),
    (void *)(&pc_khandlers_k_raise),
    (void *)(&pc_khandlers_k_applyop),
    (void *)(&pc_khandlers_k_makeiter),
    (void *)(&pc_khandlers_k_forall),
    (void *)(&pc_khandlers_k_forallx),
    (void *)(&pc_khandlers_k_foreach),
    (void *)(&pc_khandlers_k_foreachx),
    (void *)(&pc_khandlers_k_expandrange),
    (void *)(&pc_khandlers_k_callappl),
    0
};
uint8_t *  pc_types_stdtypenames[54] = {
    (uint8_t*)"tvoid",
    (uint8_t*)"tint",
    (uint8_t*)"tword",
    (uint8_t*)"treal",
    (uint8_t*)"trange",
    (uint8_t*)"tstring",
    (uint8_t*)"twstring",
    (uint8_t*)"tbignum",
    (uint8_t*)"trational",
    (uint8_t*)"tset",
    (uint8_t*)"tdict",
    (uint8_t*)"tword128",
    (uint8_t*)"tenum",
    (uint8_t*)"ttype",
    (uint8_t*)"toperator",
    (uint8_t*)"tsymbol",
    (uint8_t*)"tretaddr",
    (uint8_t*)"texception",
    (uint8_t*)"trefproc",
    (uint8_t*)"trefdllproc",
    (uint8_t*)"treflabel",
    (uint8_t*)"tstringz",
    (uint8_t*)"trefvar",
    (uint8_t*)"trefpacked",
    (uint8_t*)"trefbit",
    (uint8_t*)"trecordlink",
    (uint8_t*)"treflist",
    (uint8_t*)"trefarray",
    (uint8_t*)"trefbits",
    (uint8_t*)"tlist",
    (uint8_t*)"tarray",
    (uint8_t*)"tbits",
    (uint8_t*)"trecord",
    (uint8_t*)"tstruct",
    (uint8_t*)"tuser",
    (uint8_t*)"tvariant",
    (uint8_t*)"tc8",
    (uint8_t*)"ti8",
    (uint8_t*)"ti16",
    (uint8_t*)"ti32",
    (uint8_t*)"ti64",
    (uint8_t*)"tbit",
    (uint8_t*)"tbit2",
    (uint8_t*)"tbit4",
    (uint8_t*)"tu8",
    (uint8_t*)"tu16",
    (uint8_t*)"tu32",
    (uint8_t*)"tu64",
    (uint8_t*)"tr32",
    (uint8_t*)"tr64",
    (uint8_t*)"tintm",
    (uint8_t*)"twordm",
    (uint8_t*)"trefm",
    (uint8_t*)"tlast"
};
int64_t pc_types_stdtypewidths[54] = {
    (int64_t)128,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)0,
    (int64_t)0,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)128,
    (int64_t)8,
    (int64_t)8,
    (int64_t)16,
    (int64_t)32,
    (int64_t)64,
    (int64_t)1,
    (int64_t)2,
    (int64_t)4,
    (int64_t)8,
    (int64_t)16,
    (int64_t)32,
    (int64_t)64,
    (int64_t)32,
    (int64_t)64,
    (int64_t)32,
    (int64_t)32,
    (int64_t)64,
    (int64_t)0
};
uint8_t *  pc_decls_usercatnames[3] = {(uint8_t*)"std_cat",(uint8_t*)"anon_cat",(uint8_t*)"user_cat"};
int64_t pc_decls_ntypes;
int32_t pc_decls_ttmodule[300];
struct pc_decls_strec *  pc_decls_ttnamedef[300];
int32_t pc_decls_ttbasetype[300];
uint8_t *  pc_decls_ttname[300];
int32_t pc_decls_ttbitwidth[300];
int64_t pc_decls_ttsize[300];
int32_t pc_decls_ttlower[300];
uint32_t pc_decls_ttlength[300];
int32_t pc_decls_ttstartfield[300];
int32_t pc_decls_ttstructfields[300];
int32_t pc_decls_tttarget[300];
byte pc_decls_ttusercat[300];
byte pc_decls_typestarterset[300];
uint8_t *  pc_decls_objtypenames[3] = {(uint8_t*)"normal_obj",(uint8_t*)"slice_obj",(uint8_t*)"extslice_obj"};
struct pc_decls_objrec *  pc_decls_chrtable[256];
struct pc_decls_modulerec pc_decls_moduletable[51];
int64_t pc_decls_nmodules;
uint8_t *  pc_decls_pendingmodules[50];
int64_t pc_decls_npendingmodules;
int64_t pc_decls_currmoduleno;
struct pc_decls_modulerec *  pc_decls_currmodule;
uint8_t *  pc_decls_searchdirs[6];
int64_t pc_decls_nsearchdirs = (int64_t)0;
struct pc_decls_strec *  pc_decls_stprogram;
int64_t pc_decls_optflag = (int64_t)0;
struct pc_decls_genfieldnamerec pc_decls_genfieldnames[1000];
struct pc_decls_genfielddatarec pc_decls_genfielddata[1000];
int64_t *  pc_decls_genfieldpcaddress[1000];
int64_t pc_decls_ngenfieldnames;
int64_t pc_decls_ngenfielddata;
uint8_t *  pc_decls_libpaths[10];
int64_t pc_decls_nlibpaths;
int64_t pc_decls_ftrace = (int64_t)0;
int64_t pc_decls_fdtrace = (int64_t)0;
int64_t pc_decls_foptimise = (int64_t)0;
int64_t pc_decls_mlineno = (int64_t)0;
int64_t pc_decls_exportsprepass = (int64_t)0;
int64_t pc_decls_debug = (int64_t)0;
int64_t pc_decls_nnames;
int64_t pc_decls_nchecks;
int64_t pc_decls_forcheck;
int64_t pc_decls_nclashes;
int64_t pc_decls_nlookups;
int64_t pc_decls_allnames;
int64_t pc_decls_allfoundnames;
int64_t pc_decls_allnotfoundnames;
struct pc_decls_varrec pc_decls_ttdeststrv;
struct pc_decls_varrec *  pc_decls_ttdeststr = &pc_decls_ttdeststrv;
int64_t pc_decls_totalstrings = (int64_t)0;
uint8_t *  pc_decls_dispatchnames[5] = {(uint8_t*)"-lab",(uint8_t*)"-fn",(uint8_t*)"-deb1",(uint8_t*)"-deb2",(uint8_t*)"-asm"};
int64_t pc_decls_optimiseasm = (int64_t)1;
struct pc_decls_varrec *  pc_decls_sptr;
struct pc_decls_varrec *  pc_decls_stacklimit;
byte *  pc_decls_frameptr;
int64_t *  pc_decls_pcptr;
struct pc_decls_varrec (*pc_decls_varstack)[];
struct pc_decls_objrec (*pc_decls_stringobjtable)[];
int64_t pc_decls_dllindex;
int64_t pc_decls_dllcallindex;
int64_t pc_decls_dllparams[30];
int64_t pc_decls_dllcallstack[30];
int16_t pc_decls_dlltypes[30];
int64_t pc_decls_ndlltable;
int64_t pc_decls_ndllproctable;
uint8_t *  pc_decls_dlltable[50];
uint64_t pc_decls_dllinsttable[50];
struct pc_decls_dllprocrec pc_decls_dllproctable[2000];
int64_t pc_decls_napplproctable;
struct pc_decls_applprocrec pc_decls_applproctable[500];
void (*pc_decls_fprintf_ptr)(void);
void (*pc_decls_fgets_ptr)(void);
void (*pc_decls_pcl_callbackfn)(void) = 0;
uint8_t *  pc_decls_pcerror_mess = 0;
struct pc_decls_varrec pc_decls_emptystringvar;
int64_t pc_decls_ncmdparams;
uint8_t *  pc_decls_cmdparamtable[33];
struct pc_decls_procrec *  pc_decls_proclist;
int64_t pc_decls_nproclist;
int64_t pc_decls_nstrings = (int64_t)0;
int64_t pc_decls_nsymbols = (int64_t)0;
int64_t pc_decls_nstructfields = (int64_t)0;
uint8_t * (*pc_decls_stringtable)[];
int64_t (*pc_decls_stringlentable)[];
struct pc_decls_strec (*pc_decls_pcsymboltable)[];
struct pc_decls_fieldrec (*pc_decls_pcfieldtable)[];
uint8_t *  pc_decls_extrafiles[10];
uint8_t *  pc_decls_extratext[10];
int64_t pc_decls_extrasizes[10];
int64_t pc_decls_nextra;
uint8_t *  pc_decls_err_message;
struct pc_decls_varrec pc_decls_err_var1;
struct pc_decls_varrec pc_decls_err_var2;
int64_t *  pc_decls_err_pcptr;
int64_t *  pc_decls_stopseq;
int64_t *  pc_decls_raiseseq;
int64_t (*pc_decls_pccode)[];
int64_t pc_decls_npccode = (int64_t)0;
int64_t pc_decls_pcindex;
uint16_t (*pc_decls_linetable)[];
int64_t pc_decls_cmdnopnds[218];
int64_t pc_decls_lastticks = (int64_t)0;
int64_t * (*pc_decls_neg_table[301])(void);
int64_t * (*pc_decls_abs_table[301])(void);
int64_t * (*pc_decls_inot_table[301])(void);
int64_t * (*pc_decls_istrue_table[301])(void);
int64_t * (*pc_decls_jumpf_table[301])(void);
int64_t * (*pc_decls_jumpt_table[301])(void);
int64_t * (*pc_decls_len_table[301])(void);
int64_t * (*pc_decls_lwb_table[301])(void);
int64_t * (*pc_decls_upb_table[301])(void);
int64_t * (*pc_decls_bounds_table[301])(void);
int64_t * (*pc_decls_incr_table[301])(void);
int64_t * (*pc_decls_decr_table[301])(void);
int64_t * (*pc_decls_add_table[301])(void);
int64_t * (*pc_decls_sub_table[301])(void);
int64_t * (*pc_decls_mul_table[301])(void);
int64_t * (*pc_decls_div_table[301])(void);
int64_t * (*pc_decls_idiv_table[301])(void);
int64_t * (*pc_decls_rem_table[301])(void);
int64_t * (*pc_decls_iand_table[301])(void);
int64_t * (*pc_decls_ior_table[301])(void);
int64_t * (*pc_decls_ixor_table[301])(void);
int64_t * (*pc_decls_shl_table[301])(void);
int64_t * (*pc_decls_shr_table[301])(void);
int64_t * (*pc_decls_min_table[301])(void);
int64_t * (*pc_decls_max_table[301])(void);
int64_t * (*pc_decls_jumpeq_table[301])(void);
int64_t * (*pc_decls_jumpne_table[301])(void);
int64_t * (*pc_decls_jumplt_table[301])(void);
int64_t * (*pc_decls_jumpgt_table[301])(void);
int64_t * (*pc_decls_jumple_table[301])(void);
int64_t * (*pc_decls_jumpge_table[301])(void);
int64_t * (*pc_decls_jumptesteq_table[301])(void);
int64_t * (*pc_decls_jumptestne_table[301])(void);
int64_t * (*pc_decls_jumpfalse_table[301])(void);
int64_t * (*pc_decls_jumptrue_table[301])(void);
int64_t * (*pc_decls_eq_table[301])(void);
int64_t * (*pc_decls_lt_table[301])(void);
int64_t * (*pc_decls_le_table[301])(void);
int64_t * (*pc_decls_concat_table[301])(void);
int64_t * (*pc_decls_append_table[301])(void);
int64_t * (*pc_decls_addto_table[301])(void);
int64_t * (*pc_decls_subto_table[301])(void);
int64_t * (*pc_decls_multo_table[301])(void);
int64_t * (*pc_decls_divto_table[301])(void);
int64_t * (*pc_decls_idivto_table[301])(void);
int64_t * (*pc_decls_iandto_table[301])(void);
int64_t * (*pc_decls_iorto_table[301])(void);
int64_t * (*pc_decls_ixorto_table[301])(void);
int64_t * (*pc_decls_shlto_table[301])(void);
int64_t * (*pc_decls_shrto_table[301])(void);
int64_t * (*pc_decls_minto_table[301])(void);
int64_t * (*pc_decls_maxto_table[301])(void);
int64_t * (*pc_decls_concatto_table[301])(void);
int64_t * (*pc_decls_appendto_table[301])(void);
int64_t * (*(*pc_decls_opc_tableptr)[301])(void);
void (*pc_decls_new_table[301])(struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_varrec *);
void (*pc_decls_free_table[301])(struct pc_decls_varrec *);
void (*pc_decls_dupl_table[301])(struct pc_decls_varrec *);
void (*pc_decls_tostr_table[301])(struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_fmtrec *,struct pc_decls_objrec *);
int64_t * (*pc_decls_in_dtable[301])(int64_t);
int64_t * (*pc_decls_inrev_dtable[301])(int64_t);
int64_t * (*pc_decls_pushix_dtable[301])(void);
int64_t * (*pc_decls_pushixref_dtable[301])(void);
int64_t * (*pc_decls_pushdotix_dtable[301])(void);
int64_t * (*pc_decls_pushdotixref_dtable[301])(void);
int64_t * (*pc_decls_mixed_dtable[301])(void);
int64_t * (*pc_decls_convert_dtable[301])(int64_t);
int64_t * (*pc_decls_mulx_dtable[301])(void);
int64_t * (*pc_decls_add_dtable[301])(void);
int64_t * (*pc_decls_sub_dtable[301])(void);
int64_t * (*pc_decls_mul_dtable[301])(void);
int64_t * (*pc_decls_div_dtable[301])(void);
int64_t * (*pc_decls_idiv_dtable[301])(void);
int64_t * (*pc_decls_rem_dtable[301])(void);
int64_t * (*pc_decls_iand_dtable[301])(void);
int64_t * (*pc_decls_ior_dtable[301])(void);
int64_t * (*pc_decls_ixor_dtable[301])(void);
int64_t * (*pc_decls_shl_dtable[301])(void);
int64_t * (*pc_decls_shr_dtable[301])(void);
int64_t * (*pc_decls_min_dtable[301])(void);
int64_t * (*pc_decls_max_dtable[301])(void);
int64_t * (*pc_decls_jumpeq_dtable[301])(void);
int64_t * (*pc_decls_jumpne_dtable[301])(void);
int64_t * (*pc_decls_jumplt_dtable[301])(void);
int64_t * (*pc_decls_jumple_dtable[301])(void);
int64_t * (*pc_decls_jumpge_dtable[301])(void);
int64_t * (*pc_decls_jumpgt_dtable[301])(void);
int64_t * (*pc_decls_addto_dtable[301])(void);
int64_t * (*pc_decls_subto_dtable[301])(void);
int64_t * (*pc_decls_multo_dtable[301])(void);
int64_t * (*pc_decls_divto_dtable[301])(void);
int64_t * (*pc_decls_idivto_dtable[301])(void);
int64_t * (*pc_decls_iandto_dtable[301])(void);
int64_t * (*pc_decls_iorto_dtable[301])(void);
int64_t * (*pc_decls_ixorto_dtable[301])(void);
int64_t * (*pc_decls_shlto_dtable[301])(void);
int64_t * (*pc_decls_shrto_dtable[301])(void);
int64_t * (*pc_decls_minto_dtable[301])(void);
int64_t * (*pc_decls_maxto_dtable[301])(void);
int64_t pc_decls_nexttypesig = (int64_t)0;
byte pc_decls_sigmap[256][256];
int64_t pc_decls_overloadtype = (int64_t)0;
uint8_t *  pc_decls_strpclversion;
int64_t pc_decls_intcounts[2001];
int64_t pc_decls_nallints;
int64_t pc_decls_nsmallints;
int64_t pc_decls_nallpops;
int64_t pc_decls_nchanges;
int64_t pc_decls_nobjects;
uint8_t *  pq_common_opndnames[18] = {
    (uint8_t*)"cnone",
    (uint8_t*)"cmemory",
    (uint8_t*)"cframe",
    (uint8_t*)"cproc",
    (uint8_t*)"cdllproc",
    (uint8_t*)"cdllvar",
    (uint8_t*)"cfield",
    (uint8_t*)"cgenfield",
    (uint8_t*)"clabel",
    (uint8_t*)"cint",
    (uint8_t*)"cword",
    (uint8_t*)"creal",
    (uint8_t*)"crange",
    (uint8_t*)"cstring",
    (uint8_t*)"ctype",
    (uint8_t*)"coperator",
    (uint8_t*)"capplproc",
    (uint8_t*)"?"
};
uint8_t *  pq_common_cmdnames[218] = {
    (uint8_t*)"kzero",
    (uint8_t*)"knop",
    (uint8_t*)"kprocstart",
    (uint8_t*)"kprocend",
    (uint8_t*)"kendmodule",
    (uint8_t*)"kpush_m",
    (uint8_t*)"kpush_f",
    (uint8_t*)"kpush_am",
    (uint8_t*)"kpush_af",
    (uint8_t*)"kpush_ap",
    (uint8_t*)"kpush_al",
    (uint8_t*)"kpush_ci",
    (uint8_t*)"kpush_cw",
    (uint8_t*)"kpush_cr",
    (uint8_t*)"kpush_cn",
    (uint8_t*)"kpush_cs",
    (uint8_t*)"kpush_t",
    (uint8_t*)"kpush_op",
    (uint8_t*)"kpushz",
    (uint8_t*)"kpushz_void",
    (uint8_t*)"kpushz_str",
    (uint8_t*)"kpushz_list",
    (uint8_t*)"kpushz_listl",
    (uint8_t*)"kpushz_set",
    (uint8_t*)"kpushz_arrayl",
    (uint8_t*)"kpop_m",
    (uint8_t*)"kpop_f",
    (uint8_t*)"kstore_m",
    (uint8_t*)"kstore_f",
    (uint8_t*)"kpushptr",
    (uint8_t*)"kpopptr",
    (uint8_t*)"kstoreptr",
    (uint8_t*)"kzpop_m",
    (uint8_t*)"kzpop_f",
    (uint8_t*)"kzstore_m",
    (uint8_t*)"kzstore_f",
    (uint8_t*)"kcopy",
    (uint8_t*)"kswap",
    (uint8_t*)"kconvptr",
    (uint8_t*)"kjump",
    (uint8_t*)"kjumpptr",
    (uint8_t*)"kjumptrue",
    (uint8_t*)"kjumpfalse",
    (uint8_t*)"kjumpdef",
    (uint8_t*)"kjumpvoid",
    (uint8_t*)"kjumpeq",
    (uint8_t*)"kjumpne",
    (uint8_t*)"kjumplt",
    (uint8_t*)"kjumple",
    (uint8_t*)"kjumpge",
    (uint8_t*)"kjumpgt",
    (uint8_t*)"kjumptesteq",
    (uint8_t*)"kjumptestne",
    (uint8_t*)"kjumplabel",
    (uint8_t*)"kjumpclabel",
    (uint8_t*)"kswitch",
    (uint8_t*)"kcswitch",
    (uint8_t*)"knew",
    (uint8_t*)"kto_f",
    (uint8_t*)"kfor_fci",
    (uint8_t*)"kfor_ff",
    (uint8_t*)"kford_fci",
    (uint8_t*)"kford_ff",
    (uint8_t*)"kcall",
    (uint8_t*)"kcallptr",
    (uint8_t*)"kreturn",
    (uint8_t*)"kstartdll",
    (uint8_t*)"kpushdll",
    (uint8_t*)"kcalldll",
    (uint8_t*)"kcallhost",
    (uint8_t*)"kstackframe",
    (uint8_t*)"kfree",
    (uint8_t*)"kaddsp",
    (uint8_t*)"kstop",
    (uint8_t*)"ktest",
    (uint8_t*)"kmakelist",
    (uint8_t*)"kmakerecord",
    (uint8_t*)"kmakearray",
    (uint8_t*)"kmakestruct",
    (uint8_t*)"kmakeset",
    (uint8_t*)"kmakerange",
    (uint8_t*)"kmakedict",
    (uint8_t*)"kpushdot",
    (uint8_t*)"kpushdotref",
    (uint8_t*)"ksoftconv",
    (uint8_t*)"khardconv",
    (uint8_t*)"kmixed",
    (uint8_t*)"kincrptr",
    (uint8_t*)"kincrto_m",
    (uint8_t*)"kincrto_f",
    (uint8_t*)"kloadincr",
    (uint8_t*)"kincrload",
    (uint8_t*)"kdecrptr",
    (uint8_t*)"kdecrto_m",
    (uint8_t*)"kdecrto_f",
    (uint8_t*)"kloaddecr",
    (uint8_t*)"kdecrload",
    (uint8_t*)"kincr",
    (uint8_t*)"kdecr",
    (uint8_t*)"kneg",
    (uint8_t*)"kabs",
    (uint8_t*)"knot",
    (uint8_t*)"kinot",
    (uint8_t*)"kistrue",
    (uint8_t*)"kasc",
    (uint8_t*)"kchr",
    (uint8_t*)"ksqrt",
    (uint8_t*)"ksqr",
    (uint8_t*)"kcube",
    (uint8_t*)"ksin",
    (uint8_t*)"kcos",
    (uint8_t*)"ktan",
    (uint8_t*)"kasin",
    (uint8_t*)"kacos",
    (uint8_t*)"katan",
    (uint8_t*)"ksign",
    (uint8_t*)"kln",
    (uint8_t*)"klog",
    (uint8_t*)"klg",
    (uint8_t*)"kexp",
    (uint8_t*)"kround",
    (uint8_t*)"kfloor",
    (uint8_t*)"kceil",
    (uint8_t*)"kfract",
    (uint8_t*)"knegto",
    (uint8_t*)"kabsto",
    (uint8_t*)"knotto",
    (uint8_t*)"kinotto",
    (uint8_t*)"klen",
    (uint8_t*)"klwb",
    (uint8_t*)"kupb",
    (uint8_t*)"kbounds",
    (uint8_t*)"kbits",
    (uint8_t*)"kbytes",
    (uint8_t*)"ktype",
    (uint8_t*)"kelemtype",
    (uint8_t*)"kbasetype",
    (uint8_t*)"kminval",
    (uint8_t*)"kmaxval",
    (uint8_t*)"kisint",
    (uint8_t*)"kisreal",
    (uint8_t*)"kisstring",
    (uint8_t*)"kisrange",
    (uint8_t*)"kisnumber",
    (uint8_t*)"kisarray",
    (uint8_t*)"kisrecord",
    (uint8_t*)"kispointer",
    (uint8_t*)"kismutable",
    (uint8_t*)"kisset",
    (uint8_t*)"kisvoid",
    (uint8_t*)"kisdef",
    (uint8_t*)"ktostr",
    (uint8_t*)"kisequal",
    (uint8_t*)"kadd",
    (uint8_t*)"ksub",
    (uint8_t*)"kmul",
    (uint8_t*)"kdiv",
    (uint8_t*)"kidiv",
    (uint8_t*)"krem",
    (uint8_t*)"kdivrem",
    (uint8_t*)"kiand",
    (uint8_t*)"kior",
    (uint8_t*)"kixor",
    (uint8_t*)"kshl",
    (uint8_t*)"kshr",
    (uint8_t*)"kin",
    (uint8_t*)"knotin",
    (uint8_t*)"kinrev",
    (uint8_t*)"keq",
    (uint8_t*)"kne",
    (uint8_t*)"klt",
    (uint8_t*)"kle",
    (uint8_t*)"kge",
    (uint8_t*)"kgt",
    (uint8_t*)"kmin",
    (uint8_t*)"kmax",
    (uint8_t*)"kconcat",
    (uint8_t*)"kappend",
    (uint8_t*)"kpower",
    (uint8_t*)"katan2",
    (uint8_t*)"kaddto",
    (uint8_t*)"ksubto",
    (uint8_t*)"kmulto",
    (uint8_t*)"kdivto",
    (uint8_t*)"kidivto",
    (uint8_t*)"kiandto",
    (uint8_t*)"kiorto",
    (uint8_t*)"kixorto",
    (uint8_t*)"kshlto",
    (uint8_t*)"kshrto",
    (uint8_t*)"kminto",
    (uint8_t*)"kmaxto",
    (uint8_t*)"kconcatto",
    (uint8_t*)"kappendto",
    (uint8_t*)"kpushix",
    (uint8_t*)"kpushdotix",
    (uint8_t*)"kpushkeyix",
    (uint8_t*)"kpushkeyixd",
    (uint8_t*)"kpushixref",
    (uint8_t*)"kpushdotixref",
    (uint8_t*)"kpushkeyixref",
    (uint8_t*)"kpushbyteix",
    (uint8_t*)"kpushbyteixref",
    (uint8_t*)"kappendset",
    (uint8_t*)"kpushdotm",
    (uint8_t*)"kpushdott",
    (uint8_t*)"kpush_ad",
    (uint8_t*)"kpush_try",
    (uint8_t*)"kraise",
    (uint8_t*)"kapplyop",
    (uint8_t*)"kmakeiter",
    (uint8_t*)"kforall",
    (uint8_t*)"kforallx",
    (uint8_t*)"kforeach",
    (uint8_t*)"kforeachx",
    (uint8_t*)"kexpandrange",
    (uint8_t*)"kcallappl",
    (uint8_t*)"klastcmd"
};
byte pq_common_cmdfmt[218][4] = {
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)3u,(uint8_t)9u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)1u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)2u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)1u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)2u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)3u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)8u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)9u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)10u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)11u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)12u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)13u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)14u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)15u,(uint8_t)9u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)14u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)9u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)14u,(uint8_t)9u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)1u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)2u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)1u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)2u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)1u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)2u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)1u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)2u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)8u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)8u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)8u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)8u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)8u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)8u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)8u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)8u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)8u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)8u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)8u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)8u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)8u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)8u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)8u,(uint8_t)9u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)9u,(uint8_t)9u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)9u,(uint8_t)9u,(uint8_t)9u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)8u,(uint8_t)2u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)8u,(uint8_t)2u,(uint8_t)9u,(uint8_t)0u},
    {(uint8_t)8u,(uint8_t)2u,(uint8_t)2u,(uint8_t)0u},
    {(uint8_t)8u,(uint8_t)2u,(uint8_t)9u,(uint8_t)0u},
    {(uint8_t)8u,(uint8_t)2u,(uint8_t)2u,(uint8_t)0u},
    {(uint8_t)3u,(uint8_t)9u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)9u,(uint8_t)9u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)14u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)4u,(uint8_t)9u,(uint8_t)14u,(uint8_t)0u},
    {(uint8_t)9u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)9u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)9u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)9u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)9u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)9u,(uint8_t)9u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)9u,(uint8_t)14u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)9u,(uint8_t)9u,(uint8_t)14u,(uint8_t)14u},
    {(uint8_t)9u,(uint8_t)14u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)9u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)9u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)7u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)7u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)14u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)14u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)1u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)2u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)1u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)2u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)14u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)14u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)14u,(uint8_t)3u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)14u,(uint8_t)14u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)4u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)8u,(uint8_t)9u,(uint8_t)9u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)9u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)9u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)8u,(uint8_t)2u,(uint8_t)2u,(uint8_t)0u},
    {(uint8_t)8u,(uint8_t)2u,(uint8_t)2u,(uint8_t)2u},
    {(uint8_t)8u,(uint8_t)2u,(uint8_t)2u,(uint8_t)0u},
    {(uint8_t)8u,(uint8_t)2u,(uint8_t)2u,(uint8_t)2u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)16u,(uint8_t)9u,(uint8_t)0u,(uint8_t)0u},
    {(uint8_t)0u,(uint8_t)0u,(uint8_t)0u,(uint8_t)0u}
};
void *  pq_common_cmdmap[218];
uint8_t *  pq_common_bcdirnames[14] = {
    (uint8_t*)"kkpclversion",
    (uint8_t*)"kkmoduletable",
    (uint8_t*)"kkdlltable",
    (uint8_t*)"kkdllproctable",
    (uint8_t*)"kksymboltable",
    (uint8_t*)"kktypetable",
    (uint8_t*)"kkgenfieldnames",
    (uint8_t*)"kkgenfielddata",
    (uint8_t*)"kkstringtable",
    (uint8_t*)"kkstructtable",
    (uint8_t*)"kkpccode",
    (uint8_t*)"kkend",
    (uint8_t*)"kknewstringtable",
    (uint8_t*)"kkapplproctable"
};
uint8_t *  pq_common_hostfnnames[73] = {
    (uint8_t*)"host_dummy",
    (uint8_t*)"host_startprint",
    (uint8_t*)"host_startprintcon",
    (uint8_t*)"host_strstartprint",
    (uint8_t*)"host_setformat",
    (uint8_t*)"host_endprint",
    (uint8_t*)"host_strendprint",
    (uint8_t*)"host_print",
    (uint8_t*)"host_dprint",
    (uint8_t*)"host_println",
    (uint8_t*)"host_printnogap",
    (uint8_t*)"host_readln",
    (uint8_t*)"host_sreadln",
    (uint8_t*)"host_sread",
    (uint8_t*)"host_rereadln",
    (uint8_t*)"host_reread",
    (uint8_t*)"host_strtoval",
    (uint8_t*)"host_tostr",
    (uint8_t*)"host_leftstr",
    (uint8_t*)"host_rightstr",
    (uint8_t*)"host_convlc",
    (uint8_t*)"host_convuc",
    (uint8_t*)"host_iconvlc",
    (uint8_t*)"host_iconvuc",
    (uint8_t*)"host_stop",
    (uint8_t*)"host_stopx",
    (uint8_t*)"host_ismain",
    (uint8_t*)"host_waitkey",
    (uint8_t*)"host_testkey",
    (uint8_t*)"host_execwait",
    (uint8_t*)"host_execcmd",
    (uint8_t*)"host_shellexec",
    (uint8_t*)"host_system",
    (uint8_t*)"host_makestr",
    (uint8_t*)"host_makestrslice",
    (uint8_t*)"host_makeref",
    (uint8_t*)"host_new",
    (uint8_t*)"host_newheap",
    (uint8_t*)"host_readlines",
    (uint8_t*)"host_heapvar",
    (uint8_t*)"host_dictitems",
    (uint8_t*)"host_freeheap",
    (uint8_t*)"host_setoverload",
    (uint8_t*)"host_getcmdparam",
    (uint8_t*)"host_gethostname",
    (uint8_t*)"host_setpcerror",
    (uint8_t*)"host_setdebug",
    (uint8_t*)"host_test",
    (uint8_t*)"host_ticks",
    (uint8_t*)"host_sleep",
    (uint8_t*)"host_random",
    (uint8_t*)"host_findmetafunction",
    (uint8_t*)"host_gethash",
    (uint8_t*)"host_getos",
    (uint8_t*)"host_gethostsize",
    (uint8_t*)"host_iswindows",
    (uint8_t*)"host_setmesshandler",
    (uint8_t*)"host_setfprintf",
    (uint8_t*)"host_loadpcl",
    (uint8_t*)"host_runpcl",
    (uint8_t*)"host_runtask",
    (uint8_t*)"host_callext",
    (uint8_t*)"host_pcldata",
    (uint8_t*)"host_getcstring",
    (uint8_t*)"host_getparam",
    (uint8_t*)"host_clearlist",
    (uint8_t*)"host_makelink",
    (uint8_t*)"host_allparams",
    (uint8_t*)"host_stackvars",
    (uint8_t*)"host_makeempty",
    (uint8_t*)"host_errorinfo",
    (uint8_t*)"host_strrepl",
    (uint8_t*)"host_last"
};
int64_t pq_common_hostnparams[73] = {
    (int64_t)0,
    (int64_t)1,
    (int64_t)0,
    (int64_t)0,
    (int64_t)1,
    (int64_t)0,
    (int64_t)0,
    (int64_t)2,
    (int64_t)2,
    (int64_t)0,
    (int64_t)0,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)0,
    (int64_t)0,
    (int64_t)2,
    (int64_t)2,
    (int64_t)3,
    (int64_t)3,
    (int64_t)2,
    (int64_t)2,
    (int64_t)2,
    (int64_t)2,
    (int64_t)0,
    (int64_t)1,
    (int64_t)1,
    (int64_t)0,
    (int64_t)0,
    (int64_t)3,
    (int64_t)3,
    (int64_t)2,
    (int64_t)1,
    (int64_t)2,
    (int64_t)2,
    (int64_t)2,
    (int64_t)4,
    (int64_t)4,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)3,
    (int64_t)1,
    (int64_t)0,
    (int64_t)1,
    (int64_t)1,
    (int64_t)2,
    (int64_t)0,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)1,
    (int64_t)2,
    (int64_t)2,
    (int64_t)2,
    (int64_t)2,
    (int64_t)3,
    (int64_t)2,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)0,
    (int64_t)1,
    (int64_t)1,
    (int64_t)3,
    (int64_t)0
};
int64_t pq_common_hostisfn[73] = {
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)1,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)1,
    (int64_t)1,
    (int64_t)0,
    (int64_t)0,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)0,
    (int64_t)0,
    (int64_t)1,
    (int64_t)1,
    (int64_t)0,
    (int64_t)0,
    (int64_t)1,
    (int64_t)1,
    (int64_t)0,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)0,
    (int64_t)0,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)0,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)0,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)1,
    (int64_t)0
};
uint8_t *  pq_common_namenames[20] = {
    (uint8_t*)"nullid",
    (uint8_t*)"programid",
    (uint8_t*)"moduleid",
    (uint8_t*)"dllmoduleid",
    (uint8_t*)"typeid",
    (uint8_t*)"procid",
    (uint8_t*)"dllprocid",
    (uint8_t*)"dllvarid",
    (uint8_t*)"applprocid",
    (uint8_t*)"constid",
    (uint8_t*)"staticid",
    (uint8_t*)"frameid",
    (uint8_t*)"paramid",
    (uint8_t*)"fieldid",
    (uint8_t*)"genfieldid",
    (uint8_t*)"enumid",
    (uint8_t*)"labelid",
    (uint8_t*)"blockid",
    (uint8_t*)"aliasid",
    (uint8_t*)"linkid"
};
uint8_t *  pq_common_errornames[7] = {(uint8_t*)"pc_error",(uint8_t*)"user_error",(uint8_t*)"type_error",(uint8_t*)"mixedtype_error",(uint8_t*)"divide_error",(uint8_t*)"stopmodule_error",(uint8_t*)"bounds_error"};
byte pc_support_bytemasks[8] = {(uint8_t)1u,(uint8_t)2u,(uint8_t)4u,(uint8_t)8u,(uint8_t)16u,(uint8_t)32u,(uint8_t)64u,(uint8_t)128u};
int64_t pc_pcfns_lookups;
int64_t pc_pcfns_clashes;
int64_t pc_pcfns_hist[65536];
struct pc_decls_objrec *  pc_objlib_zeroobj;
struct pc_decls_objrec *  pc_objlib_emptylist;
struct pc_decls_objrec *  pc_objlib_emptystring;
struct pc_decls_objrec *  pc_objlib_emptyset;
static uint8_t *  mbignum_fpnames[4] = {(uint8_t*)"zero_type",(uint8_t*)"normal_type",(uint8_t*)"inf_type",(uint8_t*)"nan_type"};
static int64_t mbignum_currprec = (int64_t)33;
static int64_t mbignum_stblz;
static struct mbignum_constrec *  mbignum_constlist = 0;
int64_t pc_print_mindev;
int64_t pc_print_moutdev;
int64_t *  pc_print_minchan;
void *  pc_print_moutchan;
struct pc_decls_varrec pc_print_minvar;
struct pc_decls_varrec pc_print_moutvar;
uint8_t *  pc_print_mfmtstr;
uint8_t *  pc_print_mfmtcurr;
struct pc_decls_fmtrec pc_print_defaultfmt = {
    (uint8_t)0u,
    (int8_t)0,
    (uint8_t)10u,
    (uint64_t)0u,
    ' ',
    'f',
    (uint64_t)0u,
    (uint64_t)0u,
    (uint64_t)0u,
    'R',
    (uint64_t)0u,
    (uint64_t)0u,
    (uint64_t)0u,
    (uint64_t)0u,
    {(uint8_t)0u,(uint8_t)0u}
};
void *  pc_print_testfilech;
static int32_t pc_print_moutdevstack[6];
static void *  pc_print_moutchanstack[6];
static struct pc_decls_varrec pc_print_moutvarstack[6];
static byte pc_print_mgapstack[6];
static uint8_t *  pc_print_mfmtstrstack[6];
static uint8_t *  pc_print_mfmtcurrstack[6];
static int64_t pc_print_noclevels;
static byte pc_print_mgapneeded;
static int64_t pc_print_listdepth = (int64_t)0;
static uint8_t pc_print_digits[16] = {
    '0',
    '1',
    '2',
    '3',
    '4',
    '5',
    '6',
    '7',
    '8',
    '9',
    'A',
    'B',
    'C',
    'D',
    'E',
    'F'
};
static uint8_t *  pc_print_kb_start;
static uint8_t *  pc_print_kb_pos;
static uint8_t *  pc_print_kb_lastpos;
static int64_t pc_print_kb_size;
static int64_t pc_print_kb_linelength;
static int64_t pc_print_kb_length;
static int64_t pc_print_kb_lastlength;
static uint8_t pc_print_termchar;
static int64_t pc_print_itemerror;
static int32_t pc_jhandlers_typemap[26] = {
    (int32_t)30,
    (int32_t)31,
    (int32_t)0,
    (int32_t)10,
    (int32_t)9,
    (int32_t)18,
    (int32_t)19,
    (int32_t)25,
    (int32_t)1,
    (int32_t)7,
    (int32_t)33,
    (int32_t)29,
    (int32_t)32,
    (int32_t)4,
    (int32_t)14,
    (int32_t)23,
    (int32_t)0,
    (int32_t)3,
    (int32_t)5,
    (int32_t)13,
    (int32_t)0,
    (int32_t)22,
    (int32_t)2,
    (int32_t)0,
    (int32_t)0,
    (int32_t)35
};
static uint8_t *  pc_jhandlers_tabnames[66] = {
    (uint8_t*)"add",
    (uint8_t*)"sub",
    (uint8_t*)"mul",
    (uint8_t*)"div",
    (uint8_t*)"idiv",
    (uint8_t*)"rem",
    (uint8_t*)"iand",
    (uint8_t*)"ior",
    (uint8_t*)"ixor",
    (uint8_t*)"shl",
    (uint8_t*)"shr",
    (uint8_t*)"min",
    (uint8_t*)"max",
    (uint8_t*)"jumpeq",
    (uint8_t*)"jumpne",
    (uint8_t*)"jumplt",
    (uint8_t*)"jumple",
    (uint8_t*)"jumpge",
    (uint8_t*)"jumpgt",
    (uint8_t*)"jumptesteq",
    (uint8_t*)"jumptestne",
    (uint8_t*)"jumpfalse",
    (uint8_t*)"jumptrue",
    (uint8_t*)"eq",
    (uint8_t*)"lt",
    (uint8_t*)"le",
    (uint8_t*)"concat",
    (uint8_t*)"append",
    (uint8_t*)"addto",
    (uint8_t*)"subto",
    (uint8_t*)"multo",
    (uint8_t*)"divto",
    (uint8_t*)"idivto",
    (uint8_t*)"iandto",
    (uint8_t*)"iorto",
    (uint8_t*)"ixorto",
    (uint8_t*)"shlto",
    (uint8_t*)"shrto",
    (uint8_t*)"minto",
    (uint8_t*)"maxto",
    (uint8_t*)"concatto",
    (uint8_t*)"appendto",
    (uint8_t*)"neg",
    (uint8_t*)"abs",
    (uint8_t*)"inot",
    (uint8_t*)"istrue",
    (uint8_t*)"jumpf",
    (uint8_t*)"jumpt",
    (uint8_t*)"len",
    (uint8_t*)"lwb",
    (uint8_t*)"upb",
    (uint8_t*)"bounds",
    (uint8_t*)"incr",
    (uint8_t*)"decr",
    (uint8_t*)"decr",
    (uint8_t*)"free",
    (uint8_t*)"dupl",
    (uint8_t*)"tostr",
    (uint8_t*)"in",
    (uint8_t*)"inrev",
    (uint8_t*)"pushix",
    (uint8_t*)"pushixref",
    (uint8_t*)"pushdotix",
    (uint8_t*)"pushdotixref",
    (uint8_t*)"convert",
    (uint8_t*)"mixed"
};
static void *  pc_jhandlers_singletable[66] = {
    (void *)(&pc_decls_add_table),
    (void *)(&pc_decls_sub_table),
    (void *)(&pc_decls_mul_table),
    (void *)(&pc_decls_div_table),
    (void *)(&pc_decls_idiv_table),
    (void *)(&pc_decls_rem_table),
    (void *)(&pc_decls_iand_table),
    (void *)(&pc_decls_ior_table),
    (void *)(&pc_decls_ixor_table),
    (void *)(&pc_decls_shl_table),
    (void *)(&pc_decls_shr_table),
    (void *)(&pc_decls_min_table),
    (void *)(&pc_decls_max_table),
    (void *)(&pc_decls_jumpeq_table),
    (void *)(&pc_decls_jumpne_table),
    (void *)(&pc_decls_jumplt_table),
    (void *)(&pc_decls_jumple_table),
    (void *)(&pc_decls_jumpge_table),
    (void *)(&pc_decls_jumpgt_table),
    (void *)(&pc_decls_jumptesteq_table),
    (void *)(&pc_decls_jumptestne_table),
    (void *)(&pc_decls_jumpfalse_table),
    (void *)(&pc_decls_jumptrue_table),
    (void *)(&pc_decls_eq_table),
    (void *)(&pc_decls_lt_table),
    (void *)(&pc_decls_le_table),
    (void *)(&pc_decls_concat_table),
    (void *)(&pc_decls_append_table),
    (void *)(&pc_decls_addto_table),
    (void *)(&pc_decls_subto_table),
    (void *)(&pc_decls_multo_table),
    (void *)(&pc_decls_divto_table),
    (void *)(&pc_decls_idivto_table),
    (void *)(&pc_decls_iandto_table),
    (void *)(&pc_decls_iorto_table),
    (void *)(&pc_decls_ixorto_table),
    (void *)(&pc_decls_shlto_table),
    (void *)(&pc_decls_shrto_table),
    (void *)(&pc_decls_minto_table),
    (void *)(&pc_decls_maxto_table),
    (void *)(&pc_decls_concatto_table),
    (void *)(&pc_decls_appendto_table),
    (void *)(&pc_decls_neg_table),
    (void *)(&pc_decls_abs_table),
    (void *)(&pc_decls_inot_table),
    (void *)(&pc_decls_istrue_table),
    (void *)(&pc_decls_jumpf_table),
    (void *)(&pc_decls_jumpt_table),
    (void *)(&pc_decls_len_table),
    (void *)(&pc_decls_lwb_table),
    (void *)(&pc_decls_upb_table),
    (void *)(&pc_decls_bounds_table),
    (void *)(&pc_decls_incr_table),
    (void *)(&pc_decls_decr_table),
    (void *)(&pc_decls_decr_table),
    (void *)(&pc_decls_free_table),
    (void *)(&pc_decls_dupl_table),
    (void *)(&pc_decls_tostr_table),
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
static void *  pc_jhandlers_doubletable[66] = {
    (void *)(&pc_decls_add_dtable),
    (void *)(&pc_decls_sub_dtable),
    (void *)(&pc_decls_mul_dtable),
    (void *)(&pc_decls_div_dtable),
    (void *)(&pc_decls_idiv_dtable),
    (void *)(&pc_decls_rem_dtable),
    (void *)(&pc_decls_iand_dtable),
    (void *)(&pc_decls_ior_dtable),
    (void *)(&pc_decls_ixor_dtable),
    (void *)(&pc_decls_shl_dtable),
    (void *)(&pc_decls_shr_dtable),
    (void *)(&pc_decls_min_dtable),
    (void *)(&pc_decls_max_dtable),
    (void *)(&pc_decls_jumpeq_dtable),
    (void *)(&pc_decls_jumpne_dtable),
    (void *)(&pc_decls_jumplt_dtable),
    (void *)(&pc_decls_jumple_dtable),
    (void *)(&pc_decls_jumpge_dtable),
    (void *)(&pc_decls_jumpgt_dtable),
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    (void *)(&pc_decls_addto_dtable),
    (void *)(&pc_decls_subto_dtable),
    (void *)(&pc_decls_multo_dtable),
    (void *)(&pc_decls_divto_dtable),
    (void *)(&pc_decls_idivto_dtable),
    (void *)(&pc_decls_iandto_dtable),
    (void *)(&pc_decls_iorto_dtable),
    (void *)(&pc_decls_ixorto_dtable),
    (void *)(&pc_decls_shlto_dtable),
    (void *)(&pc_decls_shrto_dtable),
    (void *)(&pc_decls_minto_dtable),
    (void *)(&pc_decls_maxto_dtable),
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    (void *)(&pc_decls_in_dtable),
    (void *)(&pc_decls_inrev_dtable),
    (void *)(&pc_decls_pushix_dtable),
    (void *)(&pc_decls_pushixref_dtable),
    (void *)(&pc_decls_pushdotix_dtable),
    (void *)(&pc_decls_pushdotixref_dtable),
    (void *)(&pc_decls_convert_dtable),
    (void *)(&pc_decls_mixed_dtable)
};
static byte (*pc_jhandlers_mixedmap)[];
uint8_t *  pc_host_packtypenames[20] = {
    (uint8_t*)"tp_void",
    (uint8_t*)"tp_i64",
    (uint8_t*)"tp_u64",
    (uint8_t*)"tp_r64",
    (uint8_t*)"tp_pvoid",
    (uint8_t*)"tp_pi8",
    (uint8_t*)"tp_pi16",
    (uint8_t*)"tp_pi32",
    (uint8_t*)"tp_pi64",
    (uint8_t*)"tp_pi128",
    (uint8_t*)"tp_pu8",
    (uint8_t*)"tp_pu16",
    (uint8_t*)"tp_pu32",
    (uint8_t*)"tp_pu64",
    (uint8_t*)"tp_pu128",
    (uint8_t*)"tp_pr32",
    (uint8_t*)"tp_pr64",
    (uint8_t*)"tp_pstruct",
    (uint8_t*)"tp_stringz",
    (uint8_t*)"tp_variant"
};
int64_t pc_host_packtypewidths[20] = {
    (int64_t)0,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64
};
int64_t pc_host_packconvtypes[20] = {
    (int64_t)0,
    (int64_t)1,
    (int64_t)2,
    (int64_t)3,
    (int64_t)23,
    (int64_t)23,
    (int64_t)23,
    (int64_t)23,
    (int64_t)23,
    (int64_t)23,
    (int64_t)23,
    (int64_t)23,
    (int64_t)23,
    (int64_t)23,
    (int64_t)23,
    (int64_t)23,
    (int64_t)23,
    (int64_t)23,
    (int64_t)21,
    (int64_t)35
};
static struct pc_host_overloadrec *  pc_host_tostr_list;
static struct pc_host_overloadrec *  pc_host_convert_list;
static struct pc_decls_procrec *  pc_host_proclistptr;
static struct pc_decls_varrec pc_host_applresult;
static void *  pc_host_hosttable[70] = {
    (void *)(&pc_print_pch_startprint),
    (void *)(&pc_print_pch_startprintcon),
    (void *)(&pc_print_pch_strstartprint),
    (void *)(&pc_print_pch_setformat),
    (void *)(&pc_print_pch_endprint),
    (void *)(&pc_print_pch_strendprint),
    (void *)(&pc_print_pch_print),
    (void *)(&pc_print_pch_dprint),
    (void *)(&pc_print_pch_println),
    (void *)(&pc_print_pch_printnogap),
    (void *)(&pc_print_pch_readln),
    (void *)(&pc_print_pch_sreadln),
    (void *)(&pc_print_pch_sread),
    (void *)(&pc_print_pch_rereadln),
    (void *)(&pc_print_pch_reread),
    (void *)(&pc_print_pch_strtoval),
    (void *)(&pc_print_pch_tostr),
    (void *)(&pc_host_pch_leftstr),
    (void *)(&pc_host_pch_rightstr),
    (void *)(&pc_host_pch_convlc),
    (void *)(&pc_host_pch_convuc),
    (void *)(&pc_host_pch_iconvlc),
    (void *)(&pc_host_pch_iconvuc),
    (void *)(&pc_host_pch_stop),
    (void *)(&pc_host_pch_stopx),
    (void *)(&pc_host_pch_ismain),
    (void *)(&pc_host_pch_waitkey),
    (void *)(&pc_host_pch_testkey),
    (void *)(&pc_host_pch_execwait),
    (void *)(&pc_host_pch_execcmd),
    (void *)(&pc_host_pch_shellexec),
    (void *)(&pc_host_pch_system),
    (void *)(&pc_host_pch_makestr),
    (void *)(&pc_host_pch_makestrslice),
    (void *)(&pc_host_pch_makeref),
    (void *)(&pc_host_pch_new),
    (void *)(&pc_host_pch_newheap),
    (void *)(&pc_host_pch_readlines),
    (void *)(&pc_host_pch_heapvar),
    (void *)(&pc_host_pch_dictitems),
    (void *)(&pc_host_pch_freeheap),
    (void *)(&pc_host_pch_setoverload),
    (void *)(&pc_host_pch_getcmdparam),
    (void *)(&pc_oslayer_pch_gethostname),
    (void *)(&pc_host_pch_setpcerror),
    (void *)(&pc_host_pch_setdebug),
    (void *)(&pc_host_pch_test),
    (void *)(&pc_host_pch_ticks),
    (void *)(&pc_host_pch_sleep),
    (void *)(&pc_host_pch_random),
    (void *)(&pc_host_pch_findmetafunction),
    (void *)(&pc_host_pch_gethash),
    (void *)(&pc_oslayer_pch_getos),
    (void *)(&pc_oslayer_pch_gethostsize),
    (void *)(&pc_oslayer_pch_iswindows),
    (void *)(&pc_oslayer_pch_setmesshandler),
    (void *)(&pc_host_pch_setfprintf),
    (void *)(&pc_host_pch_loadpcl),
    (void *)(&pc_host_pch_runpcl),
    (void *)(&pc_host_pch_runtask),
    (void *)(&pc_host_pch_callext),
    (void *)(&pc_host_pch_pcldata),
    (void *)(&pc_host_pch_getcstring),
    (void *)(&pc_host_pch_getparam),
    (void *)(&pc_host_pch_clearlist),
    (void *)(&pc_host_pch_makelink),
    (void *)(&pc_host_pch_allparams),
    (void *)(&pc_host_pch_stackvars),
    (void *)(&pc_host_pch_makeempty),
    (void *)(&pc_host_pch_errorinfo)
};
struct pc_decls_objrec *  pc_khandlers_zerostringobj;
byte pc_khandlers_stopped;
uint8_t *  var_decls_usercatnames[3] = {(uint8_t*)"std_cat",(uint8_t*)"anon_cat",(uint8_t*)"user_cat"};
int64_t var_decls_ntypes;
int64_t var_decls_nuserxtypes;
int64_t var_decls_userxtypebase;
struct var_decls_userxrec *  var_decls_userxmodelist;
int32_t var_decls_ttmodule[500];
struct var_decls_strec *  var_decls_ttnamedef[500];
int32_t var_decls_ttbasetype[500];
uint8_t *  var_decls_ttname[500];
int32_t var_decls_ttbitwidth[500];
int32_t var_decls_ttsize[500];
int32_t var_decls_ttlower[500];
int32_t var_decls_ttlength[500];
struct var_decls_unitrec *  var_decls_ttlowerexpr[500];
struct var_decls_unitrec *  var_decls_ttlengthexpr[500];
struct var_decls_strec *  var_decls_ttowner[500];
int32_t var_decls_ttstartfield[500];
int32_t var_decls_ttstructfields[500];
int16_t var_decls_tttarget[500];
byte var_decls_ttusercat[500];
byte var_decls_typestarterset[500];
int64_t var_decls_ttlineno[500];
byte var_decls_ttmoduleno[500];
struct var_decls_strec *  var_decls_ttnamedefx[5000];
struct var_decls_strec *  var_decls_ttnamedefx2[5000];
int64_t var_decls_ttlinenox[5000];
int64_t var_decls_ttxmap[5000];
byte var_decls_ttxmoduleno[5000];
int16_t var_decls_baseclasstable[256];
struct var_decls_strec *  var_decls_baseclassdef[256];
int64_t var_decls_nbaseclasses;
uint8_t *  var_decls_objtypenames[3] = {(uint8_t*)"normal_obj",(uint8_t*)"slice_obj",(uint8_t*)"extslice_obj"};
byte var_decls_exprstarterset[135];
struct var_decls_modulerec var_decls_moduletable[51];
int64_t var_decls_nmodules;
int64_t var_decls_currmoduleno;
struct var_decls_modulerec *  var_decls_currmodule;
int64_t var_decls_moduleinitorder[50];
int64_t var_decls_ninitmodules;
uint8_t *  var_decls_inputfiles[51];
int64_t var_decls_ninputfiles;
uint8_t *  var_decls_searchdirs[6];
int64_t var_decls_nsearchdirs = (int64_t)0;
struct var_decls_strec *  var_decls_stprogram;
struct var_decls_strec *  var_decls_stmodule;
struct var_decls_strec *  var_decls_stsysmodule;
struct var_decls_strec *  var_decls_alldeflist;
int64_t var_decls_optflag = (int64_t)0;
struct var_decls_genfieldnamerec var_decls_genfieldnames[1000];
struct var_decls_genfielddatarec var_decls_genfielddata[1000];
int64_t var_decls_ngenfieldnames;
int64_t var_decls_ngenfielddata;
struct var_decls_unitrec *  var_decls_nullunit;
uint8_t *  var_decls_libpaths[10];
int64_t var_decls_nlibpaths;
int64_t var_decls_fverbose = (int64_t)0;
int64_t var_decls_ftrace = (int64_t)0;
int64_t var_decls_fdtrace = (int64_t)0;
int64_t var_decls_foptimise = (int64_t)0;
int64_t var_decls_mlineno = (int64_t)0;
int64_t var_decls_dointlibs = (int64_t)1;
int64_t var_decls_exportsprepass = (int64_t)0;
int64_t var_decls_debug = (int64_t)0;
int64_t var_decls_totalstrings = (int64_t)0;
int64_t var_decls_ndlltable;
struct var_decls_strec *  var_decls_dllsttable[50];
int64_t var_decls_ndllproctable;
uint8_t *  var_decls_dlltable[50];
struct var_decls_dllprocrec var_decls_dllproctable[2000];
int64_t var_decls_napplproctable;
struct var_decls_strec *  var_decls_applproctable[500];
int64_t var_decls_ncmdparams;
uint8_t *  var_decls_cmdparamtable[33];
struct var_decls_procrec *  var_decls_proclist;
int64_t var_decls_nproclist;
int64_t var_decls_nstrings = (int64_t)0;
int64_t var_decls_nsymbols = (int64_t)0;
uint8_t * (*var_decls_stringtable)[];
int64_t (*var_decls_stringlentable)[];
struct var_decls_fieldrec (*var_decls_pcfieldtable)[];
uint8_t *  var_decls_err_message;
int64_t *  var_decls_stopseq;
int64_t *  var_decls_raiseseq;
byte *  var_decls_ppp;
int64_t var_decls_prescanmode;
int64_t var_decls_progstart;
int64_t var_decls_progend;
int64_t var_decls_loadstart;
int64_t var_decls_loadend;
int64_t var_decls_parsestart;
int64_t var_decls_parseend;
int64_t var_decls_namesstart;
int64_t var_decls_namesend;
int64_t var_decls_genstart;
int64_t var_decls_genend;
static struct mlib_strbuffer var_decls_docstrx;
struct mlib_strbuffer *  var_decls_docstring = &var_decls_docstrx;
struct var_decls_strec *  var_decls_currproc;
int64_t var_decls_alllines;
uint8_t *  var_decls_qafilenames[101];
int64_t var_decls_qafilesizes[101];
int64_t var_decls_qafileoffsets[101];
uint8_t *  var_decls_qafiletext[101];
byte var_decls_qafilefileno[101];
byte var_decls_qafilemult[101];
int64_t var_decls_nqafiles;
uint8_t *  var_decls_qafilesource;
int64_t var_decls_fbundled = (int64_t)0;
int64_t var_decls_fwriteqa;
int64_t var_decls_nfor;
int64_t var_decls_nto;
int64_t var_decls_nwhile;
int64_t var_decls_ndo;
int64_t var_decls_nrepeat;
int64_t var_decls_ndoswitch;
int64_t var_decls_ndocase;
uint8_t *  var_types_stdtypenames[54] = {
    (uint8_t*)"tvoid",
    (uint8_t*)"tint",
    (uint8_t*)"tword",
    (uint8_t*)"treal",
    (uint8_t*)"trange",
    (uint8_t*)"tstring",
    (uint8_t*)"twstring",
    (uint8_t*)"tlongint",
    (uint8_t*)"trational",
    (uint8_t*)"tset",
    (uint8_t*)"tdict",
    (uint8_t*)"tword128",
    (uint8_t*)"tenum",
    (uint8_t*)"ttype",
    (uint8_t*)"toperator",
    (uint8_t*)"tsymbol",
    (uint8_t*)"tretaddr",
    (uint8_t*)"texception",
    (uint8_t*)"trefproc",
    (uint8_t*)"trefdllproc",
    (uint8_t*)"treflabel",
    (uint8_t*)"tstringz",
    (uint8_t*)"trefvar",
    (uint8_t*)"trefpacked",
    (uint8_t*)"trefbit",
    (uint8_t*)"trecordlink",
    (uint8_t*)"treflist",
    (uint8_t*)"trefarray",
    (uint8_t*)"trefbits",
    (uint8_t*)"tlist",
    (uint8_t*)"tarray",
    (uint8_t*)"tbits",
    (uint8_t*)"trecord",
    (uint8_t*)"tstruct",
    (uint8_t*)"tuser",
    (uint8_t*)"tvariant",
    (uint8_t*)"tc8",
    (uint8_t*)"ti8",
    (uint8_t*)"ti16",
    (uint8_t*)"ti32",
    (uint8_t*)"ti64",
    (uint8_t*)"tbit",
    (uint8_t*)"tbit2",
    (uint8_t*)"tbit4",
    (uint8_t*)"tu8",
    (uint8_t*)"tu16",
    (uint8_t*)"tu32",
    (uint8_t*)"tu64",
    (uint8_t*)"tr32",
    (uint8_t*)"tr64",
    (uint8_t*)"tintm",
    (uint8_t*)"twordm",
    (uint8_t*)"trefm",
    (uint8_t*)"tlast"
};
int64_t var_types_stdtypewidths[54] = {
    (int64_t)128,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)0,
    (int64_t)0,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)64,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)128,
    (int64_t)8,
    (int64_t)8,
    (int64_t)16,
    (int64_t)32,
    (int64_t)64,
    (int64_t)1,
    (int64_t)2,
    (int64_t)4,
    (int64_t)8,
    (int64_t)16,
    (int64_t)32,
    (int64_t)64,
    (int64_t)32,
    (int64_t)64,
    (int64_t)32,
    (int64_t)32,
    (int64_t)64,
    (int64_t)0
};
uint8_t *  qc_tables_jtagnames[250] = {
    (uint8_t*)"j_none",
    (uint8_t*)"j_const",
    (uint8_t*)"j_null",
    (uint8_t*)"j_name",
    (uint8_t*)"j_block",
    (uint8_t*)"j_codeblock",
    (uint8_t*)"j_blockdef",
    (uint8_t*)"j_doblock",
    (uint8_t*)"j_typeval",
    (uint8_t*)"j_longint",
    (uint8_t*)"j_whenthen",
    (uint8_t*)"j_elsif",
    (uint8_t*)"j_fmtitem",
    (uint8_t*)"j_nogap",
    (uint8_t*)"j_callproc",
    (uint8_t*)"j_callmproc",
    (uint8_t*)"j_return",
    (uint8_t*)"j_assign",
    (uint8_t*)"j_shallowcopy",
    (uint8_t*)"j_deepcopy",
    (uint8_t*)"j_to",
    (uint8_t*)"j_if",
    (uint8_t*)"j_longif",
    (uint8_t*)"j_forup",
    (uint8_t*)"j_fordown",
    (uint8_t*)"j_forstep",
    (uint8_t*)"j_forall",
    (uint8_t*)"j_forallrev",
    (uint8_t*)"j_foreach",
    (uint8_t*)"j_foreachrev",
    (uint8_t*)"j_cfor",
    (uint8_t*)"j_while",
    (uint8_t*)"j_repeat",
    (uint8_t*)"j_goto",
    (uint8_t*)"j_gotoblock",
    (uint8_t*)"j_labeldef",
    (uint8_t*)"j_restart",
    (uint8_t*)"j_redo",
    (uint8_t*)"j_next",
    (uint8_t*)"j_exit",
    (uint8_t*)"j_break",
    (uint8_t*)"j_do",
    (uint8_t*)"j_case",
    (uint8_t*)"j_docase",
    (uint8_t*)"j_switch",
    (uint8_t*)"j_doswitch",
    (uint8_t*)"j_swap",
    (uint8_t*)"j_select",
    (uint8_t*)"j_print",
    (uint8_t*)"j_println",
    (uint8_t*)"j_fprint",
    (uint8_t*)"j_fprintln",
    (uint8_t*)"j_cprint",
    (uint8_t*)"j_cprintln",
    (uint8_t*)"j_sprint",
    (uint8_t*)"j_sfprint",
    (uint8_t*)"j_scprint",
    (uint8_t*)"j_read",
    (uint8_t*)"j_readln",
    (uint8_t*)"j_sread",
    (uint8_t*)"j_sreadln",
    (uint8_t*)"j_stop",
    (uint8_t*)"j_try",
    (uint8_t*)"j_except",
    (uint8_t*)"j_yield",
    (uint8_t*)"j_raise",
    (uint8_t*)"j_callhostproc",
    (uint8_t*)"j_callapplproc",
    (uint8_t*)"j_callapplfn",
    (uint8_t*)"j_eval",
    (uint8_t*)"j_listcomp",
    (uint8_t*)"j_appendlc",
    (uint8_t*)"j_startiter",
    (uint8_t*)"j_nextiter",
    (uint8_t*)"j_andl",
    (uint8_t*)"j_orl",
    (uint8_t*)"j_xorl",
    (uint8_t*)"j_notl",
    (uint8_t*)"j_istruel",
    (uint8_t*)"j_makelist",
    (uint8_t*)"j_makeconstr",
    (uint8_t*)"j_makesetlist",
    (uint8_t*)"j_makerange",
    (uint8_t*)"j_makedict",
    (uint8_t*)"j_exprlist",
    (uint8_t*)"j_multexpr",
    (uint8_t*)"j_keyword",
    (uint8_t*)"j_keyvalue",
    (uint8_t*)"j_assignx",
    (uint8_t*)"j_deepcopyx",
    (uint8_t*)"j_callfn",
    (uint8_t*)"j_callmfn",
    (uint8_t*)"j_ifx",
    (uint8_t*)"j_selectx",
    (uint8_t*)"j_callhostfn",
    (uint8_t*)"j_applyop",
    (uint8_t*)"j_applyopx",
    (uint8_t*)"j_andand",
    (uint8_t*)"j_eq",
    (uint8_t*)"j_ne",
    (uint8_t*)"j_lt",
    (uint8_t*)"j_le",
    (uint8_t*)"j_gt",
    (uint8_t*)"j_ge",
    (uint8_t*)"j_isequal",
    (uint8_t*)"j_add",
    (uint8_t*)"j_sub",
    (uint8_t*)"j_mul",
    (uint8_t*)"j_div",
    (uint8_t*)"j_idiv",
    (uint8_t*)"j_fdiv",
    (uint8_t*)"j_ddiv",
    (uint8_t*)"j_rem",
    (uint8_t*)"j_divrem",
    (uint8_t*)"j_iand",
    (uint8_t*)"j_ior",
    (uint8_t*)"j_ixor",
    (uint8_t*)"j_shl",
    (uint8_t*)"j_shr",
    (uint8_t*)"j_in",
    (uint8_t*)"j_notin",
    (uint8_t*)"j_inrev",
    (uint8_t*)"j_min",
    (uint8_t*)"j_max",
    (uint8_t*)"j_addptr",
    (uint8_t*)"j_subptr",
    (uint8_t*)"j_concat",
    (uint8_t*)"j_append",
    (uint8_t*)"j_clamp",
    (uint8_t*)"j_index",
    (uint8_t*)"j_indexref",
    (uint8_t*)"j_slice",
    (uint8_t*)"j_keyindex",
    (uint8_t*)"j_dotindex",
    (uint8_t*)"j_dotleft",
    (uint8_t*)"j_dotright",
    (uint8_t*)"j_dotslice",
    (uint8_t*)"j_dotkeyindex",
    (uint8_t*)"j_anddotindex",
    (uint8_t*)"j_anddotslice",
    (uint8_t*)"j_byteindex",
    (uint8_t*)"j_dot",
    (uint8_t*)"j_dotref",
    (uint8_t*)"j_dotattr",
    (uint8_t*)"j_atan2",
    (uint8_t*)"j_power",
    (uint8_t*)"j_ptr",
    (uint8_t*)"j_ptrto",
    (uint8_t*)"j_addrof",
    (uint8_t*)"j_convert",
    (uint8_t*)"j_typepun",
    (uint8_t*)"j_typeconst",
    (uint8_t*)"j_operator",
    (uint8_t*)"j_packtypeconst",
    (uint8_t*)"j_classconst",
    (uint8_t*)"j_upper",
    (uint8_t*)"j_neg",
    (uint8_t*)"j_abs",
    (uint8_t*)"j_inot",
    (uint8_t*)"j_chr",
    (uint8_t*)"j_asc",
    (uint8_t*)"j_sqrt",
    (uint8_t*)"j_sqr",
    (uint8_t*)"j_cube",
    (uint8_t*)"j_sign",
    (uint8_t*)"j_sin",
    (uint8_t*)"j_cos",
    (uint8_t*)"j_tan",
    (uint8_t*)"j_asin",
    (uint8_t*)"j_acos",
    (uint8_t*)"j_atan",
    (uint8_t*)"j_ln",
    (uint8_t*)"j_lg",
    (uint8_t*)"j_log",
    (uint8_t*)"j_exp",
    (uint8_t*)"j_round",
    (uint8_t*)"j_floor",
    (uint8_t*)"j_ceil",
    (uint8_t*)"j_fract",
    (uint8_t*)"j_fmod",
    (uint8_t*)"j_lwb",
    (uint8_t*)"j_upb",
    (uint8_t*)"j_len",
    (uint8_t*)"j_bounds",
    (uint8_t*)"j_bitwidth",
    (uint8_t*)"j_bytesize",
    (uint8_t*)"j_dictitems",
    (uint8_t*)"j_gettype",
    (uint8_t*)"j_getbasetype",
    (uint8_t*)"j_getelemtype",
    (uint8_t*)"j_isvoid",
    (uint8_t*)"j_isnone",
    (uint8_t*)"j_isdef",
    (uint8_t*)"j_isint",
    (uint8_t*)"j_isreal",
    (uint8_t*)"j_isstring",
    (uint8_t*)"j_isrange",
    (uint8_t*)"j_islist",
    (uint8_t*)"j_isrecord",
    (uint8_t*)"j_isclass",
    (uint8_t*)"j_isarray",
    (uint8_t*)"j_isset",
    (uint8_t*)"j_istype",
    (uint8_t*)"j_ispointer",
    (uint8_t*)"j_ismutable",
    (uint8_t*)"j_minvalue",
    (uint8_t*)"j_maxvalue",
    (uint8_t*)"j_min1",
    (uint8_t*)"j_max1",
    (uint8_t*)"j_preincrx",
    (uint8_t*)"j_predecrx",
    (uint8_t*)"j_postincrx",
    (uint8_t*)"j_postdecrx",
    (uint8_t*)"j_addto",
    (uint8_t*)"j_subto",
    (uint8_t*)"j_multo",
    (uint8_t*)"j_divto",
    (uint8_t*)"j_idivto",
    (uint8_t*)"j_fdivto",
    (uint8_t*)"j_iandto",
    (uint8_t*)"j_iorto",
    (uint8_t*)"j_ixorto",
    (uint8_t*)"j_shlto",
    (uint8_t*)"j_shrto",
    (uint8_t*)"j_minto",
    (uint8_t*)"j_maxto",
    (uint8_t*)"j_concatto",
    (uint8_t*)"j_appendto",
    (uint8_t*)"j_negto",
    (uint8_t*)"j_absto",
    (uint8_t*)"j_inotto",
    (uint8_t*)"j_preincr",
    (uint8_t*)"j_predecr",
    (uint8_t*)"j_postincr",
    (uint8_t*)"j_postdecr",
    (uint8_t*)"j_cvlineno",
    (uint8_t*)"j_cvstrlineno",
    (uint8_t*)"j_cvmodulename",
    (uint8_t*)"j_cvfilename",
    (uint8_t*)"j_cvfunction",
    (uint8_t*)"j_cvdate",
    (uint8_t*)"j_cvtime",
    (uint8_t*)"j_cvversion",
    (uint8_t*)"j_cvpclversion",
    (uint8_t*)"j_new",
    (uint8_t*)"j_mixed",
    (uint8_t*)"j_tostr",
    (uint8_t*)"j_free",
    (uint8_t*)"j_dupl",
    (uint8_t*)"j_dummy"
};
uint8_t *  qc_tables_scopenames[4] = {(uint8_t*)"noscope",(uint8_t*)"localscope",(uint8_t*)"importscope",(uint8_t*)"exportscope"};
uint8_t *  qc_tables_fflangnames[5] = {(uint8_t*)"WL",(uint8_t*)"CL",(uint8_t*)"QL",(uint8_t*)"ML",(uint8_t*)"dummyff"};
uint8_t *  qc_tables_symbolnames[135] = {
    (uint8_t*)"errorsym",
    (uint8_t*)"dotsym",
    (uint8_t*)"lexdotsym",
    (uint8_t*)"anddotsym",
    (uint8_t*)"commasym",
    (uint8_t*)"semisym",
    (uint8_t*)"colonsym",
    (uint8_t*)"dcolonsym",
    (uint8_t*)"assignsym",
    (uint8_t*)"deepcopysym",
    (uint8_t*)"sendtosym",
    (uint8_t*)"lbracksym",
    (uint8_t*)"rbracksym",
    (uint8_t*)"lsqsym",
    (uint8_t*)"rsqsym",
    (uint8_t*)"lcurlysym",
    (uint8_t*)"rcurlysym",
    (uint8_t*)"ptrsym",
    (uint8_t*)"barsym",
    (uint8_t*)"dbarsym",
    (uint8_t*)"atsym",
    (uint8_t*)"datsym",
    (uint8_t*)"questionsym",
    (uint8_t*)"addrsym",
    (uint8_t*)"daddrsym",
    (uint8_t*)"poundsym",
    (uint8_t*)"curlsym",
    (uint8_t*)"gatesym",
    (uint8_t*)"rangesym",
    (uint8_t*)"ellipsissym",
    (uint8_t*)"opsym",
    (uint8_t*)"eolsym",
    (uint8_t*)"eofsym",
    (uint8_t*)"rawnamesym",
    (uint8_t*)"docstringsym",
    (uint8_t*)"incrsym",
    (uint8_t*)"intconstsym",
    (uint8_t*)"longintconstsym",
    (uint8_t*)"realconstsym",
    (uint8_t*)"charconstsym",
    (uint8_t*)"wcharconstsym",
    (uint8_t*)"stringconstsym",
    (uint8_t*)"wstringconstsym",
    (uint8_t*)"unitnamesym",
    (uint8_t*)"namesym",
    (uint8_t*)"ksourcedirsym",
    (uint8_t*)"lexmacronamesym",
    (uint8_t*)"stdtypesym",
    (uint8_t*)"packtypesym",
    (uint8_t*)"kifsym",
    (uint8_t*)"kthensym",
    (uint8_t*)"kelsifsym",
    (uint8_t*)"kelsesym",
    (uint8_t*)"kelsecasesym",
    (uint8_t*)"kelseswitchsym",
    (uint8_t*)"kelseselectsym",
    (uint8_t*)"kendsym",
    (uint8_t*)"kunlesssym",
    (uint8_t*)"kcasesym",
    (uint8_t*)"kdocasesym",
    (uint8_t*)"kwhensym",
    (uint8_t*)"kforsym",
    (uint8_t*)"kforallsym",
    (uint8_t*)"ktosym",
    (uint8_t*)"kbysym",
    (uint8_t*)"kdosym",
    (uint8_t*)"kwhilesym",
    (uint8_t*)"krepeatsym",
    (uint8_t*)"kuntilsym",
    (uint8_t*)"kreturnsym",
    (uint8_t*)"kstopsym",
    (uint8_t*)"kloopsym",
    (uint8_t*)"kbreaksym",
    (uint8_t*)"kgotosym",
    (uint8_t*)"kswitchsym",
    (uint8_t*)"kdoswitchsym",
    (uint8_t*)"kprintsym",
    (uint8_t*)"ksprintsym",
    (uint8_t*)"kreadsym",
    (uint8_t*)"ksreadsym",
    (uint8_t*)"ksreadlnsym",
    (uint8_t*)"khostfnsym",
    (uint8_t*)"kprocsym",
    (uint8_t*)"kfunctionsym",
    (uint8_t*)"kmethodsym",
    (uint8_t*)"krecordsym",
    (uint8_t*)"kstructsym",
    (uint8_t*)"kunionsym",
    (uint8_t*)"kimportsym",
    (uint8_t*)"kimportmodulesym",
    (uint8_t*)"kimportpathsym",
    (uint8_t*)"kmodulesym",
    (uint8_t*)"kapplprocsym",
    (uint8_t*)"kapplsym",
    (uint8_t*)"ktypesym",
    (uint8_t*)"ktypeattrsym",
    (uint8_t*)"krefsym",
    (uint8_t*)"kmacrosym",
    (uint8_t*)"kconstsym",
    (uint8_t*)"kvarsym",
    (uint8_t*)"klocalssym",
    (uint8_t*)"klabelsym",
    (uint8_t*)"kenumsym",
    (uint8_t*)"knewsym",
    (uint8_t*)"kclasssym",
    (uint8_t*)"kdoblocksym",
    (uint8_t*)"kblockdefsym",
    (uint8_t*)"kdirectivesym",
    (uint8_t*)"kfflangsym",
    (uint8_t*)"kglobalsym",
    (uint8_t*)"kstaticsym",
    (uint8_t*)"kbeginsym",
    (uint8_t*)"ktrysym",
    (uint8_t*)"kexceptsym",
    (uint8_t*)"kfinallysym",
    (uint8_t*)"kraisesym",
    (uint8_t*)"kyieldsym",
    (uint8_t*)"kextendsym",
    (uint8_t*)"kblocksym",
    (uint8_t*)"kcastsym",
    (uint8_t*)"ktypeconstsym",
    (uint8_t*)"compilervarsym",
    (uint8_t*)"dollarsym",
    (uint8_t*)"kevalsym",
    (uint8_t*)"ktabledatasym",
    (uint8_t*)"kmapsym",
    (uint8_t*)"kapplyopsym",
    (uint8_t*)"kstacksym",
    (uint8_t*)"kforwardsym",
    (uint8_t*)"kclampsym",
    (uint8_t*)"kswapsym",
    (uint8_t*)"kcondcompsym",
    (uint8_t*)"kerrorsym",
    (uint8_t*)"sysconstsym",
    (uint8_t*)"kdummysym"
};
uint8_t *  qc_tables_sourcedirnames[19] = {
    (uint8_t*)"definedir",
    (uint8_t*)"emitdir",
    (uint8_t*)"ifdir",
    (uint8_t*)"elsifdir",
    (uint8_t*)"elsedir",
    (uint8_t*)"endifdir",
    (uint8_t*)"debuglinedir",
    (uint8_t*)"includedir",
    (uint8_t*)"endincludedir",
    (uint8_t*)"exportdir",
    (uint8_t*)"endexportdir",
    (uint8_t*)"commentdir",
    (uint8_t*)"endcommentdir",
    (uint8_t*)"strincludedir",
    (uint8_t*)"modulenamedir",
    (uint8_t*)"targetlangdir",
    (uint8_t*)"cincludedir",
    (uint8_t*)"pyimportdir",
    (uint8_t*)"enddir"
};
uint8_t *  qc_tables_stnames[327] = {
    (uint8_t*)"if",
    (uint8_t*)"then",
    (uint8_t*)"elsif",
    (uint8_t*)"else",
    (uint8_t*)"elsecase",
    (uint8_t*)"elseswitch",
    (uint8_t*)"case",
    (uint8_t*)"docase",
    (uint8_t*)"when",
    (uint8_t*)"for",
    (uint8_t*)"forall",
    (uint8_t*)"foreach",
    (uint8_t*)"to",
    (uint8_t*)"downto",
    (uint8_t*)"by",
    (uint8_t*)"do",
    (uint8_t*)"end",
    (uint8_t*)"while",
    (uint8_t*)"repeat",
    (uint8_t*)"until",
    (uint8_t*)"always",
    (uint8_t*)"return",
    (uint8_t*)"yield",
    (uint8_t*)"stop",
    (uint8_t*)"restart",
    (uint8_t*)"redo",
    (uint8_t*)"loop",
    (uint8_t*)"next",
    (uint8_t*)"exit",
    (uint8_t*)"break",
    (uint8_t*)"goto",
    (uint8_t*)"go",
    (uint8_t*)"switch",
    (uint8_t*)"doswitch",
    (uint8_t*)"tabledata",
    (uint8_t*)"applyop",
    (uint8_t*)"clamp",
    (uint8_t*)"eval",
    (uint8_t*)"$windows",
    (uint8_t*)"$linux",
    (uint8_t*)"print",
    (uint8_t*)"println",
    (uint8_t*)"fprint",
    (uint8_t*)"fprintln",
    (uint8_t*)"cprint",
    (uint8_t*)"cprintln",
    (uint8_t*)"sprint",
    (uint8_t*)"sfprint",
    (uint8_t*)"scprint",
    (uint8_t*)"cp",
    (uint8_t*)"cpl",
    (uint8_t*)"read",
    (uint8_t*)"readln",
    (uint8_t*)"cast",
    (uint8_t*)"typeconst",
    (uint8_t*)"proc",
    (uint8_t*)"function",
    (uint8_t*)"method",
    (uint8_t*)"type",
    (uint8_t*)"class",
    (uint8_t*)"doblock",
    (uint8_t*)"blockdef",
    (uint8_t*)"record",
    (uint8_t*)"struct",
    (uint8_t*)"union",
    (uint8_t*)"ref",
    (uint8_t*)"module",
    (uint8_t*)"cinclude",
    (uint8_t*)"pyimport",
    (uint8_t*)"include",
    (uint8_t*)"strinclude",
    (uint8_t*)"define",
    (uint8_t*)"macro",
    (uint8_t*)"export",
    (uint8_t*)"endexport",
    (uint8_t*)"static",
    (uint8_t*)"const",
    (uint8_t*)"var",
    (uint8_t*)"variant",
    (uint8_t*)"enum",
    (uint8_t*)"importdll",
    (uint8_t*)"import",
    (uint8_t*)"importpath",
    (uint8_t*)"hostproc",
    (uint8_t*)"applproc",
    (uint8_t*)"host",
    (uint8_t*)"appl",
    (uint8_t*)"begin",
    (uint8_t*)"unless",
    (uint8_t*)"try",
    (uint8_t*)"except",
    (uint8_t*)"finally",
    (uint8_t*)"raise",
    (uint8_t*)"global",
    (uint8_t*)"qlang",
    (uint8_t*)"clang",
    (uint8_t*)"mlang",
    (uint8_t*)"windows",
    (uint8_t*)"swap",
    (uint8_t*)"void",
    (uint8_t*)"int",
    (uint8_t*)"word",
    (uint8_t*)"real",
    (uint8_t*)"refvar",
    (uint8_t*)"pointer",
    (uint8_t*)"range",
    (uint8_t*)"longint",
    (uint8_t*)"bignum",
    (uint8_t*)"string",
    (uint8_t*)"set",
    (uint8_t*)"list",
    (uint8_t*)"dict",
    (uint8_t*)"array",
    (uint8_t*)"bits",
    (uint8_t*)"recordtype",
    (uint8_t*)"structtype",
    (uint8_t*)"int8",
    (uint8_t*)"int16",
    (uint8_t*)"int32",
    (uint8_t*)"int64",
    (uint8_t*)"i8",
    (uint8_t*)"i16",
    (uint8_t*)"i32",
    (uint8_t*)"i64",
    (uint8_t*)"real32",
    (uint8_t*)"real64",
    (uint8_t*)"r32",
    (uint8_t*)"r64",
    (uint8_t*)"sreal",
    (uint8_t*)"bit",
    (uint8_t*)"bit2",
    (uint8_t*)"bit4",
    (uint8_t*)"byte",
    (uint8_t*)"u8",
    (uint8_t*)"u16",
    (uint8_t*)"u32",
    (uint8_t*)"u64",
    (uint8_t*)"word8",
    (uint8_t*)"word16",
    (uint8_t*)"word32",
    (uint8_t*)"word64",
    (uint8_t*)"stringz",
    (uint8_t*)"intm",
    (uint8_t*)"wordm",
    (uint8_t*)"refm",
    (uint8_t*)"million",
    (uint8_t*)"billion",
    (uint8_t*)"thousand",
    (uint8_t*)"kb",
    (uint8_t*)"mb",
    (uint8_t*)"gb",
    (uint8_t*)"$lineno",
    (uint8_t*)"$strlineno",
    (uint8_t*)"$filename",
    (uint8_t*)"$modulename",
    (uint8_t*)"$function",
    (uint8_t*)"$date",
    (uint8_t*)"$time",
    (uint8_t*)"$version",
    (uint8_t*)"$pclversion",
    (uint8_t*)"$",
    (uint8_t*)"and",
    (uint8_t*)"or",
    (uint8_t*)"xor",
    (uint8_t*)"iand",
    (uint8_t*)"ior",
    (uint8_t*)"ixor",
    (uint8_t*)"in",
    (uint8_t*)"notin",
    (uint8_t*)"inrev",
    (uint8_t*)"rem",
    (uint8_t*)"divrem",
    (uint8_t*)"min",
    (uint8_t*)"max",
    (uint8_t*)"not",
    (uint8_t*)"inot",
    (uint8_t*)"istrue",
    (uint8_t*)"abs",
    (uint8_t*)"$neg",
    (uint8_t*)"asc",
    (uint8_t*)"chr",
    (uint8_t*)"sqrt",
    (uint8_t*)"sqr",
    (uint8_t*)"cube",
    (uint8_t*)"cos",
    (uint8_t*)"sin",
    (uint8_t*)"tan",
    (uint8_t*)"asin",
    (uint8_t*)"acos",
    (uint8_t*)"atan",
    (uint8_t*)"atan2",
    (uint8_t*)"sign",
    (uint8_t*)"ln",
    (uint8_t*)"log",
    (uint8_t*)"lg",
    (uint8_t*)"exp",
    (uint8_t*)"round",
    (uint8_t*)"floor",
    (uint8_t*)"ceil",
    (uint8_t*)"fract",
    (uint8_t*)"fmod",
    (uint8_t*)"len",
    (uint8_t*)"lwb",
    (uint8_t*)"upb",
    (uint8_t*)"bounds",
    (uint8_t*)"bitwidth",
    (uint8_t*)"bytes",
    (uint8_t*)"basetype",
    (uint8_t*)"dictitems",
    (uint8_t*)"elemtype",
    (uint8_t*)"defined",
    (uint8_t*)"isdef",
    (uint8_t*)"isvoid",
    (uint8_t*)"isnone",
    (uint8_t*)"isint",
    (uint8_t*)"isreal",
    (uint8_t*)"isarray",
    (uint8_t*)"isset",
    (uint8_t*)"islist",
    (uint8_t*)"isrecord",
    (uint8_t*)"isrange",
    (uint8_t*)"isstring",
    (uint8_t*)"ispointer",
    (uint8_t*)"ismutable",
    (uint8_t*)"minvalue",
    (uint8_t*)"maxvalue",
    (uint8_t*)"concat",
    (uint8_t*)"append",
    (uint8_t*)"$free",
    (uint8_t*)"$dupl",
    (uint8_t*)"$mixed",
    (uint8_t*)"$index",
    (uint8_t*)"$dotindex",
    (uint8_t*)"$convert",
    (uint8_t*)"$new",
    (uint8_t*)"$tostr",
    (uint8_t*)"$dot",
    (uint8_t*)"$dotref",
    (uint8_t*)"endif",
    (uint8_t*)"fi",
    (uint8_t*)"endcase",
    (uint8_t*)"esac",
    (uint8_t*)"enddocase",
    (uint8_t*)"endswitch",
    (uint8_t*)"enddoswitch",
    (uint8_t*)"endfor",
    (uint8_t*)"endforall",
    (uint8_t*)"od",
    (uint8_t*)"endproc",
    (uint8_t*)"endfunction",
    (uint8_t*)"endmethod",
    (uint8_t*)"endwhile",
    (uint8_t*)"endto",
    (uint8_t*)"enddo",
    (uint8_t*)"endunless",
    (uint8_t*)"endmodule",
    (uint8_t*)"endimportmodule",
    (uint8_t*)"endtry",
    (uint8_t*)"endrecord",
    (uint8_t*)"endclass",
    (uint8_t*)"endblock",
    (uint8_t*)"nil",
    (uint8_t*)"con",
    (uint8_t*)"tab",
    (uint8_t*)"pi",
    (uint8_t*)"sreadln",
    (uint8_t*)"sread",
    (uint8_t*)"rereadln",
    (uint8_t*)"reread",
    (uint8_t*)"strtoval",
    (uint8_t*)"tostr",
    (uint8_t*)"leftstr",
    (uint8_t*)"rightstr",
    (uint8_t*)"convlc",
    (uint8_t*)"convuc",
    (uint8_t*)"iconvlc",
    (uint8_t*)"iconvuc",
    (uint8_t*)"ismain",
    (uint8_t*)"waitkey",
    (uint8_t*)"testkey",
    (uint8_t*)"execwait",
    (uint8_t*)"execcmd",
    (uint8_t*)"shellexec",
    (uint8_t*)"system",
    (uint8_t*)"makestr",
    (uint8_t*)"makestrslice",
    (uint8_t*)"makeref",
    (uint8_t*)"new",
    (uint8_t*)"newheap",
    (uint8_t*)"readlines",
    (uint8_t*)"heapvar",
    (uint8_t*)"freeheap",
    (uint8_t*)"getcmdparam",
    (uint8_t*)"gethostname",
    (uint8_t*)"$setpcerror",
    (uint8_t*)"$setdebug",
    (uint8_t*)"$test",
    (uint8_t*)"ticks",
    (uint8_t*)"sleep",
    (uint8_t*)"random",
    (uint8_t*)"findmetafunction",
    (uint8_t*)"gethash",
    (uint8_t*)"getos",
    (uint8_t*)"gethostsize",
    (uint8_t*)"iswindows",
    (uint8_t*)"setmesshandler",
    (uint8_t*)"$setfprintf",
    (uint8_t*)"clearlist",
    (uint8_t*)"loadpcl",
    (uint8_t*)"runpcl",
    (uint8_t*)"runtask",
    (uint8_t*)"callext",
    (uint8_t*)"$pcldata",
    (uint8_t*)"getcstring",
    (uint8_t*)"$getparam",
    (uint8_t*)"makelink",
    (uint8_t*)"allparams",
    (uint8_t*)"stackvars",
    (uint8_t*)"makeempty",
    (uint8_t*)"$errorinfo",
    (uint8_t*)"$setoverload",
    (uint8_t*)"pc_error",
    (uint8_t*)"user_error",
    (uint8_t*)"mixedtype_error",
    (uint8_t*)"divide_error",
    (uint8_t*)"stopmodule_error",
    (uint8_t*)"bounds_error"
};
int64_t qc_tables_stsymbols[327] = {
    (int64_t)50,
    (int64_t)51,
    (int64_t)52,
    (int64_t)53,
    (int64_t)54,
    (int64_t)55,
    (int64_t)59,
    (int64_t)60,
    (int64_t)61,
    (int64_t)62,
    (int64_t)63,
    (int64_t)63,
    (int64_t)64,
    (int64_t)64,
    (int64_t)65,
    (int64_t)66,
    (int64_t)57,
    (int64_t)67,
    (int64_t)68,
    (int64_t)69,
    (int64_t)69,
    (int64_t)70,
    (int64_t)117,
    (int64_t)71,
    (int64_t)72,
    (int64_t)72,
    (int64_t)72,
    (int64_t)72,
    (int64_t)72,
    (int64_t)73,
    (int64_t)74,
    (int64_t)74,
    (int64_t)75,
    (int64_t)76,
    (int64_t)125,
    (int64_t)127,
    (int64_t)130,
    (int64_t)124,
    (int64_t)132,
    (int64_t)132,
    (int64_t)77,
    (int64_t)77,
    (int64_t)77,
    (int64_t)77,
    (int64_t)77,
    (int64_t)77,
    (int64_t)78,
    (int64_t)78,
    (int64_t)78,
    (int64_t)77,
    (int64_t)77,
    (int64_t)79,
    (int64_t)79,
    (int64_t)120,
    (int64_t)121,
    (int64_t)83,
    (int64_t)84,
    (int64_t)85,
    (int64_t)95,
    (int64_t)105,
    (int64_t)106,
    (int64_t)107,
    (int64_t)86,
    (int64_t)87,
    (int64_t)88,
    (int64_t)97,
    (int64_t)108,
    (int64_t)108,
    (int64_t)108,
    (int64_t)46,
    (int64_t)46,
    (int64_t)46,
    (int64_t)46,
    (int64_t)46,
    (int64_t)46,
    (int64_t)111,
    (int64_t)99,
    (int64_t)100,
    (int64_t)100,
    (int64_t)103,
    (int64_t)90,
    (int64_t)89,
    (int64_t)91,
    (int64_t)93,
    (int64_t)93,
    (int64_t)94,
    (int64_t)94,
    (int64_t)112,
    (int64_t)58,
    (int64_t)113,
    (int64_t)114,
    (int64_t)115,
    (int64_t)116,
    (int64_t)110,
    (int64_t)109,
    (int64_t)109,
    (int64_t)109,
    (int64_t)109,
    (int64_t)131,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)48,
    (int64_t)44,
    (int64_t)44,
    (int64_t)44,
    (int64_t)44,
    (int64_t)44,
    (int64_t)44,
    (int64_t)122,
    (int64_t)122,
    (int64_t)122,
    (int64_t)122,
    (int64_t)122,
    (int64_t)122,
    (int64_t)122,
    (int64_t)122,
    (int64_t)122,
    (int64_t)123,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)31,
    (int64_t)57,
    (int64_t)57,
    (int64_t)57,
    (int64_t)57,
    (int64_t)57,
    (int64_t)57,
    (int64_t)57,
    (int64_t)57,
    (int64_t)57,
    (int64_t)57,
    (int64_t)57,
    (int64_t)57,
    (int64_t)57,
    (int64_t)57,
    (int64_t)57,
    (int64_t)57,
    (int64_t)57,
    (int64_t)57,
    (int64_t)57,
    (int64_t)57,
    (int64_t)57,
    (int64_t)57,
    (int64_t)57,
    (int64_t)134,
    (int64_t)134,
    (int64_t)134,
    (int64_t)134,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)82,
    (int64_t)133,
    (int64_t)133,
    (int64_t)133,
    (int64_t)133,
    (int64_t)133,
    (int64_t)133
};
int64_t qc_tables_stsubcodes[327] = {
    (int64_t)21,
    (int64_t)0,
    (int64_t)21,
    (int64_t)0,
    (int64_t)42,
    (int64_t)44,
    (int64_t)42,
    (int64_t)43,
    (int64_t)0,
    (int64_t)0,
    (int64_t)26,
    (int64_t)28,
    (int64_t)0,
    (int64_t)1,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)1,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)36,
    (int64_t)37,
    (int64_t)38,
    (int64_t)38,
    (int64_t)39,
    (int64_t)40,
    (int64_t)0,
    (int64_t)1,
    (int64_t)44,
    (int64_t)45,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)1,
    (int64_t)2,
    (int64_t)48,
    (int64_t)49,
    (int64_t)50,
    (int64_t)51,
    (int64_t)52,
    (int64_t)53,
    (int64_t)54,
    (int64_t)55,
    (int64_t)56,
    (int64_t)48,
    (int64_t)49,
    (int64_t)57,
    (int64_t)58,
    (int64_t)149,
    (int64_t)151,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)32,
    (int64_t)33,
    (int64_t)0,
    (int64_t)0,
    (int64_t)15,
    (int64_t)17,
    (int64_t)18,
    (int64_t)8,
    (int64_t)14,
    (int64_t)1,
    (int64_t)1,
    (int64_t)10,
    (int64_t)11,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)0,
    (int64_t)3,
    (int64_t)2,
    (int64_t)4,
    (int64_t)1,
    (int64_t)0,
    (int64_t)0,
    (int64_t)1,
    (int64_t)2,
    (int64_t)3,
    (int64_t)22,
    (int64_t)22,
    (int64_t)4,
    (int64_t)7,
    (int64_t)7,
    (int64_t)5,
    (int64_t)9,
    (int64_t)29,
    (int64_t)10,
    (int64_t)30,
    (int64_t)31,
    (int64_t)32,
    (int64_t)33,
    (int64_t)37,
    (int64_t)38,
    (int64_t)39,
    (int64_t)40,
    (int64_t)37,
    (int64_t)38,
    (int64_t)39,
    (int64_t)40,
    (int64_t)48,
    (int64_t)49,
    (int64_t)48,
    (int64_t)49,
    (int64_t)48,
    (int64_t)41,
    (int64_t)42,
    (int64_t)43,
    (int64_t)44,
    (int64_t)44,
    (int64_t)45,
    (int64_t)46,
    (int64_t)47,
    (int64_t)44,
    (int64_t)45,
    (int64_t)46,
    (int64_t)47,
    (int64_t)21,
    (int64_t)50,
    (int64_t)51,
    (int64_t)52,
    (int64_t)2,
    (int64_t)3,
    (int64_t)1,
    (int64_t)4,
    (int64_t)5,
    (int64_t)6,
    (int64_t)235,
    (int64_t)236,
    (int64_t)238,
    (int64_t)237,
    (int64_t)239,
    (int64_t)240,
    (int64_t)241,
    (int64_t)242,
    (int64_t)243,
    (int64_t)0,
    (int64_t)74,
    (int64_t)75,
    (int64_t)76,
    (int64_t)114,
    (int64_t)115,
    (int64_t)116,
    (int64_t)119,
    (int64_t)120,
    (int64_t)121,
    (int64_t)112,
    (int64_t)113,
    (int64_t)122,
    (int64_t)123,
    (int64_t)77,
    (int64_t)158,
    (int64_t)78,
    (int64_t)157,
    (int64_t)156,
    (int64_t)160,
    (int64_t)159,
    (int64_t)161,
    (int64_t)162,
    (int64_t)163,
    (int64_t)166,
    (int64_t)165,
    (int64_t)167,
    (int64_t)168,
    (int64_t)169,
    (int64_t)170,
    (int64_t)144,
    (int64_t)164,
    (int64_t)171,
    (int64_t)173,
    (int64_t)172,
    (int64_t)174,
    (int64_t)175,
    (int64_t)176,
    (int64_t)177,
    (int64_t)178,
    (int64_t)179,
    (int64_t)182,
    (int64_t)180,
    (int64_t)181,
    (int64_t)183,
    (int64_t)184,
    (int64_t)185,
    (int64_t)188,
    (int64_t)186,
    (int64_t)189,
    (int64_t)192,
    (int64_t)192,
    (int64_t)190,
    (int64_t)191,
    (int64_t)193,
    (int64_t)194,
    (int64_t)200,
    (int64_t)201,
    (int64_t)200,
    (int64_t)198,
    (int64_t)196,
    (int64_t)195,
    (int64_t)203,
    (int64_t)204,
    (int64_t)205,
    (int64_t)206,
    (int64_t)126,
    (int64_t)127,
    (int64_t)247,
    (int64_t)248,
    (int64_t)245,
    (int64_t)129,
    (int64_t)133,
    (int64_t)149,
    (int64_t)244,
    (int64_t)246,
    (int64_t)141,
    (int64_t)142,
    (int64_t)50,
    (int64_t)50,
    (int64_t)59,
    (int64_t)59,
    (int64_t)60,
    (int64_t)75,
    (int64_t)76,
    (int64_t)62,
    (int64_t)63,
    (int64_t)66,
    (int64_t)83,
    (int64_t)84,
    (int64_t)85,
    (int64_t)67,
    (int64_t)64,
    (int64_t)66,
    (int64_t)58,
    (int64_t)92,
    (int64_t)90,
    (int64_t)113,
    (int64_t)86,
    (int64_t)105,
    (int64_t)119,
    (int64_t)1,
    (int64_t)4,
    (int64_t)3,
    (int64_t)2,
    (int64_t)12,
    (int64_t)13,
    (int64_t)14,
    (int64_t)15,
    (int64_t)16,
    (int64_t)17,
    (int64_t)18,
    (int64_t)19,
    (int64_t)20,
    (int64_t)21,
    (int64_t)22,
    (int64_t)23,
    (int64_t)26,
    (int64_t)27,
    (int64_t)28,
    (int64_t)29,
    (int64_t)30,
    (int64_t)31,
    (int64_t)32,
    (int64_t)33,
    (int64_t)34,
    (int64_t)35,
    (int64_t)36,
    (int64_t)37,
    (int64_t)38,
    (int64_t)39,
    (int64_t)41,
    (int64_t)43,
    (int64_t)44,
    (int64_t)45,
    (int64_t)46,
    (int64_t)47,
    (int64_t)48,
    (int64_t)49,
    (int64_t)50,
    (int64_t)51,
    (int64_t)52,
    (int64_t)53,
    (int64_t)54,
    (int64_t)55,
    (int64_t)56,
    (int64_t)57,
    (int64_t)65,
    (int64_t)58,
    (int64_t)59,
    (int64_t)60,
    (int64_t)61,
    (int64_t)62,
    (int64_t)63,
    (int64_t)64,
    (int64_t)66,
    (int64_t)67,
    (int64_t)68,
    (int64_t)69,
    (int64_t)70,
    (int64_t)42,
    (int64_t)1,
    (int64_t)2,
    (int64_t)4,
    (int64_t)5,
    (int64_t)6,
    (int64_t)7
};
int64_t qc_tables_oplist[36] = {
    (int64_t)105,
    (int64_t)106,
    (int64_t)107,
    (int64_t)108,
    (int64_t)109,
    (int64_t)112,
    (int64_t)113,
    (int64_t)74,
    (int64_t)75,
    (int64_t)76,
    (int64_t)114,
    (int64_t)115,
    (int64_t)116,
    (int64_t)117,
    (int64_t)118,
    (int64_t)119,
    (int64_t)120,
    (int64_t)121,
    (int64_t)98,
    (int64_t)99,
    (int64_t)100,
    (int64_t)103,
    (int64_t)101,
    (int64_t)102,
    (int64_t)104,
    (int64_t)122,
    (int64_t)123,
    (int64_t)145,
    (int64_t)144,
    (int64_t)124,
    (int64_t)125,
    (int64_t)126,
    (int64_t)127,
    (int64_t)88,
    (int64_t)89,
    (int64_t)82
};
int64_t qc_tables_oppriolist[36] = {
    (int64_t)4,
    (int64_t)4,
    (int64_t)3,
    (int64_t)3,
    (int64_t)3,
    (int64_t)3,
    (int64_t)3,
    (int64_t)7,
    (int64_t)8,
    (int64_t)6,
    (int64_t)4,
    (int64_t)4,
    (int64_t)4,
    (int64_t)3,
    (int64_t)3,
    (int64_t)6,
    (int64_t)6,
    (int64_t)6,
    (int64_t)6,
    (int64_t)6,
    (int64_t)6,
    (int64_t)6,
    (int64_t)6,
    (int64_t)6,
    (int64_t)6,
    (int64_t)4,
    (int64_t)4,
    (int64_t)2,
    (int64_t)3,
    (int64_t)4,
    (int64_t)4,
    (int64_t)4,
    (int64_t)4,
    (int64_t)1,
    (int64_t)1,
    (int64_t)5
};
byte qc_tables_jtagpriotable[250];
int64_t qc_tables_d_exprstarterset[24] = {
    (int64_t)12,
    (int64_t)14,
    (int64_t)18,
    (int64_t)24,
    (int64_t)31,
    (int64_t)45,
    (int64_t)36,
    (int64_t)37,
    (int64_t)38,
    (int64_t)39,
    (int64_t)40,
    (int64_t)42,
    (int64_t)48,
    (int64_t)78,
    (int64_t)80,
    (int64_t)81,
    (int64_t)104,
    (int64_t)123,
    (int64_t)122,
    (int64_t)130,
    (int64_t)82,
    (int64_t)127,
    (int64_t)133,
    (int64_t)94
};
int64_t qc_tables_d_typestarterset[6] = {(int64_t)48,(int64_t)14,(int64_t)100,(int64_t)97,(int64_t)103,(int64_t)86};
byte qc_tables_hostlvset[73];
byte qc_tables_condopset[250];
static int64_t qci_totalpclopcodes = (int64_t)0;
static int64_t qci_totallines = (int64_t)0;
static int64_t qci_nstringobjects = (int64_t)0;
byte qc_support_bytemasks[8] = {(uint8_t)1u,(uint8_t)2u,(uint8_t)4u,(uint8_t)8u,(uint8_t)16u,(uint8_t)32u,(uint8_t)64u,(uint8_t)128u};
static byte *  qc_support_pcstart;
static byte *  qc_support_pcdest;
static byte *  qc_support_pcend;
static int64_t qc_support_pcalloc;
int64_t qc_lex_nlookups;
int64_t qc_lex_nclashes;
struct qc_lex_lexrec qc_lex_lx;
struct qc_lex_lexrec qc_lex_nextlx;
static byte *  qc_lex_macrostack[10];
static int64_t qc_lex_macrolevel = (int64_t)0;
static byte *  qc_lex_lxstart;
static byte *  qc_lex_lxsptr;
static struct var_decls_strec *  qc_lex_lxsymptr;
struct var_decls_strec qc_lex_hashtable[32768];
static uint8_t *  qc_lex_maxnumlist[16] = {
    (uint8_t*)"",
    (uint8_t*)"1111111111111111111111111111111111111111111111111111111111111111",
    (uint8_t*)"11112220022122120101211020120210210211220",
    (uint8_t*)"33333333333333333333333333333333",
    (uint8_t*)"2214220303114400424121122430",
    (uint8_t*)"3520522010102100444244423",
    (uint8_t*)"45012021522523134134601",
    (uint8_t*)"1777777777777777777777",
    (uint8_t*)"145808576354216723756",
    (uint8_t*)"18446744073709551615",
    (uint8_t*)"335500516A429071284",
    (uint8_t*)"839365134A2A240713",
    (uint8_t*)"219505A9511A867B72",
    (uint8_t*)"8681049ADB03DB171",
    (uint8_t*)"2C1D56B648C6CD110",
    (uint8_t*)"FFFFFFFFFFFFFFFF"
};
static int64_t qc_lex_maxnumlen[16];
static int64_t qc_parse_intabledata = (int64_t)0;
static int64_t qc_parse_inreadprint = (int64_t)0;
static int64_t qc_parse_inparamlist = (int64_t)0;
static int64_t qc_parse_inrecordbody = (int64_t)0;
static int64_t qc_parse_inimportmodule = (int64_t)0;
static int64_t qc_parse_labelseen = (int64_t)0;
static uint8_t *  qc_parse_tabledataname = 0;
static struct var_decls_uflagsrec qc_parse_unionstring;
static struct var_decls_uflagsrec qc_parse_unionpend;
static struct var_decls_strec *  qc_parse_unionlastvar = 0;
static int64_t qc_parse_try_level = (int64_t)0;
static int64_t qc_parse_varattribs = (int64_t)0;
static struct var_decls_unitrec *  qc_parse_dollarstack[10];
static int64_t qc_parse_ndollar = (int64_t)0;
static int64_t qc_parse_inmultexpr = (int64_t)0;
static struct var_decls_strec *  qc_parse_currimport;
static int64_t qc_lib_autotypeno = (int64_t)0;
static int64_t qc_lib_currlineno;
int64_t qc_lib_nextavindex = (int64_t)0;
static int64_t qc_lib_nextsvindex = (int64_t)0;
static struct mlib_strbuffer qc_lib_exprstrvar;
static struct mlib_strbuffer *  qc_lib_exprstr = &qc_lib_exprstrvar;
static int64_t qc_lib_opc_codes[36] = {
    (int64_t)105,
    (int64_t)106,
    (int64_t)107,
    (int64_t)108,
    (int64_t)109,
    (int64_t)156,
    (int64_t)98,
    (int64_t)99,
    (int64_t)100,
    (int64_t)101,
    (int64_t)102,
    (int64_t)103,
    (int64_t)114,
    (int64_t)115,
    (int64_t)116,
    (int64_t)158,
    (int64_t)117,
    (int64_t)118,
    (int64_t)74,
    (int64_t)75,
    (int64_t)77,
    (int64_t)207,
    (int64_t)208,
    (int64_t)213,
    (int64_t)214,
    (int64_t)215,
    (int64_t)216,
    (int64_t)228,
    (int64_t)222,
    (int64_t)223,
    (int64_t)209,
    (int64_t)211,
    (int64_t)210,
    (int64_t)212,
    (int64_t)145,
    (int64_t)0
};
static uint8_t *  qc_lib_opc_names[36] = {
    (uint8_t*)"+",
    (uint8_t*)"-",
    (uint8_t*)"*",
    (uint8_t*)"/",
    (uint8_t*)"%",
    (uint8_t*)"-",
    (uint8_t*)"=",
    (uint8_t*)"<>",
    (uint8_t*)"<",
    (uint8_t*)"<=",
    (uint8_t*)">",
    (uint8_t*)">=",
    (uint8_t*)"iand",
    (uint8_t*)"ior",
    (uint8_t*)"ixor",
    (uint8_t*)"inot",
    (uint8_t*)"<<",
    (uint8_t*)">>",
    (uint8_t*)"and",
    (uint8_t*)"or",
    (uint8_t*)"not",
    (uint8_t*)"min",
    (uint8_t*)"max",
    (uint8_t*)"+:=",
    (uint8_t*)"-:=",
    (uint8_t*)"*:=",
    (uint8_t*)"/:=",
    (uint8_t*)"-:=",
    (uint8_t*)"<<:=",
    (uint8_t*)">>:=",
    (uint8_t*)"++",
    (uint8_t*)"++",
    (uint8_t*)"--",
    (uint8_t*)"--",
    (uint8_t*)"**",
    (uint8_t*)""
};
static struct var_decls_strec *  qc_name_currstproc;
static int64_t qc_name_allowmodname = (int64_t)0;
static int64_t qc_name_nfields;
static int64_t qc_name_nallfields;
static int64_t qc_pclgen_nprocframevars;
static struct var_decls_strec *  qc_pclgen_stretval;
static int64_t qc_pclgen_retindex;
static int64_t qc_pclgen_nprocparamvars;
static int64_t *  qc_pclgen_loopstack[20][4];
static int64_t qc_pclgen_trylevelstack[20];
static int64_t qc_pclgen_loopindex = (int64_t)0;
static int64_t qc_pclgen_looptrylevel;
static int64_t qc_pclgen_trylevel = (int64_t)0;
static struct var_decls_strec *  qc_pclgen_st_startproc;
static int64_t qc_pclgen_pcl_jcodes[100] = {
    (int64_t)105,
    (int64_t)106,
    (int64_t)107,
    (int64_t)108,
    (int64_t)109,
    (int64_t)112,
    (int64_t)113,
    (int64_t)98,
    (int64_t)99,
    (int64_t)100,
    (int64_t)101,
    (int64_t)102,
    (int64_t)103,
    (int64_t)104,
    (int64_t)114,
    (int64_t)115,
    (int64_t)116,
    (int64_t)158,
    (int64_t)117,
    (int64_t)118,
    (int64_t)119,
    (int64_t)120,
    (int64_t)121,
    (int64_t)122,
    (int64_t)123,
    (int64_t)145,
    (int64_t)144,
    (int64_t)126,
    (int64_t)127,
    (int64_t)156,
    (int64_t)157,
    (int64_t)77,
    (int64_t)78,
    (int64_t)180,
    (int64_t)181,
    (int64_t)182,
    (int64_t)183,
    (int64_t)190,
    (int64_t)192,
    (int64_t)193,
    (int64_t)194,
    (int64_t)200,
    (int64_t)196,
    (int64_t)195,
    (int64_t)198,
    (int64_t)201,
    (int64_t)203,
    (int64_t)204,
    (int64_t)187,
    (int64_t)188,
    (int64_t)189,
    (int64_t)184,
    (int64_t)185,
    (int64_t)205,
    (int64_t)206,
    (int64_t)159,
    (int64_t)160,
    (int64_t)162,
    (int64_t)163,
    (int64_t)161,
    (int64_t)164,
    (int64_t)165,
    (int64_t)166,
    (int64_t)167,
    (int64_t)168,
    (int64_t)169,
    (int64_t)170,
    (int64_t)171,
    (int64_t)172,
    (int64_t)173,
    (int64_t)174,
    (int64_t)175,
    (int64_t)177,
    (int64_t)178,
    (int64_t)176,
    (int64_t)213,
    (int64_t)214,
    (int64_t)215,
    (int64_t)216,
    (int64_t)228,
    (int64_t)219,
    (int64_t)220,
    (int64_t)221,
    (int64_t)222,
    (int64_t)223,
    (int64_t)224,
    (int64_t)225,
    (int64_t)226,
    (int64_t)227,
    (int64_t)209,
    (int64_t)211,
    (int64_t)210,
    (int64_t)212,
    (int64_t)246,
    (int64_t)245,
    (int64_t)244,
    (int64_t)149,
    (int64_t)129,
    (int64_t)133,
    (int64_t)0
};
static byte qc_pclgen_pcl_nopnds[100] = {
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)1u,
    (uint8_t)2u,
    (uint8_t)2u,
    (uint8_t)0u
};
static int64_t qc_pclgen_pcl_kcodes[100] = {
    (int64_t)153,
    (int64_t)154,
    (int64_t)155,
    (int64_t)156,
    (int64_t)157,
    (int64_t)158,
    (int64_t)159,
    (int64_t)168,
    (int64_t)169,
    (int64_t)170,
    (int64_t)171,
    (int64_t)173,
    (int64_t)172,
    (int64_t)152,
    (int64_t)160,
    (int64_t)161,
    (int64_t)162,
    (int64_t)102,
    (int64_t)163,
    (int64_t)164,
    (int64_t)165,
    (int64_t)166,
    (int64_t)167,
    (int64_t)174,
    (int64_t)175,
    (int64_t)178,
    (int64_t)179,
    (int64_t)176,
    (int64_t)177,
    (int64_t)99,
    (int64_t)100,
    (int64_t)101,
    (int64_t)103,
    (int64_t)129,
    (int64_t)130,
    (int64_t)128,
    (int64_t)131,
    (int64_t)149,
    (int64_t)150,
    (int64_t)139,
    (int64_t)140,
    (int64_t)144,
    (int64_t)142,
    (int64_t)141,
    (int64_t)145,
    (int64_t)148,
    (int64_t)146,
    (int64_t)147,
    (int64_t)134,
    (int64_t)136,
    (int64_t)135,
    (int64_t)132,
    (int64_t)133,
    (int64_t)137,
    (int64_t)138,
    (int64_t)105,
    (int64_t)104,
    (int64_t)107,
    (int64_t)108,
    (int64_t)106,
    (int64_t)115,
    (int64_t)109,
    (int64_t)110,
    (int64_t)111,
    (int64_t)112,
    (int64_t)113,
    (int64_t)114,
    (int64_t)116,
    (int64_t)118,
    (int64_t)117,
    (int64_t)119,
    (int64_t)120,
    (int64_t)122,
    (int64_t)123,
    (int64_t)121,
    (int64_t)180,
    (int64_t)181,
    (int64_t)182,
    (int64_t)183,
    (int64_t)124,
    (int64_t)185,
    (int64_t)186,
    (int64_t)187,
    (int64_t)188,
    (int64_t)189,
    (int64_t)190,
    (int64_t)191,
    (int64_t)192,
    (int64_t)193,
    (int64_t)91,
    (int64_t)90,
    (int64_t)96,
    (int64_t)95,
    (int64_t)151,
    (int64_t)86,
    (int64_t)57,
    (int64_t)85,
    (int64_t)194,
    (int64_t)195,
    (int64_t)0
};
static int64_t qc_pclgen_noperands;
static int64_t qc_pclgen_dummyop = (int64_t)0;
int64_t (*qc_pcllib_pccode)[];
int64_t qc_pcllib_npccode = (int64_t)0;
int64_t qc_pcllib_pcindex;
uint16_t (*qc_pcllib_linetable)[];
static byte (*qc_pcllib_labelmap)[];
int64_t *  qc_pcllib_lastopc;
int32_t qc_pcllib_cmdnopnds[218];
int32_t qc_pcllib_labeltable[1000];
int64_t qc_pcllib_nextfreelabel;
static int64_t qc_pcllib_nfields;
static int64_t qc_pcllib_nallfields;
int64_t qc_pcllib_nconvertedtypes = (int64_t)52;
struct var_decls_strec *  qc_pcllib_stcurrproc;
static struct mlib_strbuffer qc_pcllib_pclv;
struct mlib_strbuffer *  qc_pcllib_pcl = &qc_pcllib_pclv;
static uint8_t *  q_libs_libnames[18] = {
    (uint8_t*)"wincon",
    (uint8_t*)"sys",
    (uint8_t*)"files",
    (uint8_t*)"clib",
    (uint8_t*)"oslib",
    (uint8_t*)"oslibsw",
    (uint8_t*)"winlib",
    (uint8_t*)"linlib",
    (uint8_t*)"console",
    (uint8_t*)"consolesw",
    (uint8_t*)"lincon",
    (uint8_t*)"winapi",
    (uint8_t*)"winconsts",
    (uint8_t*)"wingxlib",
    (uint8_t*)"winmessages",
    (uint8_t*)"gxlib",
    (uint8_t*)"gxmisc",
    (uint8_t*)"bmlib"
};
static uint8_t *  q_libs_libtext[18] = {
    \
(uint8_t*)"import sys\r\nimport clib\r\nimport oslib\r\n\r\nimport winconsts\r\nimport winapi\r\n\r\nglobal VAR SUPPRESS=0\r\n\r\nvar keypending=0\r\nvar lastkey\r\nvar pendkey\r\nglobal var hconsole, hconsolein\r\nvar colourpalette\r\n\r\nglobal var wscreencols,wscreenrows\r\nglobal var currbgnd=-1,currfgnd=-1\r\n\r\nglobal var screencolour=con_dkred..con_grey\r\n\r\n!global var colourmap\r\n\r\nVAR ALLCHARS\r\n\r\nproc START=\r\nif iswindows() then\r\nCPL \"WINCON INIT\"\r\n\tinit()\r\nfi\r\nend\r\n\r\nproc main=\r\ninit()\r\nCPL \"WINCON MAIN\"\r\nsettitle(\"New Title\")\r\n\r\nend\r\n\r\nglobal function makerspoint(x,y)=\r\n!combine x,y into 32-bit value (rspoint)\r\nreturn y<<16 ior x\r\nend\r\n\r\nglobal proc setpos(col,row)=\r\nsetconsolecursorposition(hconsole,makerspoint(col-1,row-1))\r\nend\r\n\r\nglobal function getpos=\r\ninfo:=new(ws_console)\r\ngetconsolescreenbufferinfo(hconsole,&info)\r\nreturn (info.pos.x+1,info.pos.y+1)\r\nend\r\n\r\nglobal proc init(cols=100)=\r\n!static var setdimdone=0\r\n\r\nhconsole:=getstdhandle(-11)\r\n!CPL =HCONSOLE\r\n\r\nhconsolein:=getstdhandle(-10)\r\nlastkey:=new(ws_keyevent)\r\nlastkey.repeatcount:=0\r\npendkey:=new(ws_keyevent)\r\n\r\nsetdims(cols,60)\r\n\r\ngetdims()\r\n\r\n!colourmap:=(@0: \\\r\n!\t0,\t!black\tdk versions\r\n!\t1,\t!blue\r\n!\t4,\t!red\r\n!\t5,\t!magenta\r\n!\t2,\t!green\r\n!\t3,\t!cyan\r\n!\t6,\t!yellow\r\n!\t7,\t!green\r\n!\r\n!\t8,\t!dkgrey\r\n!\t9,\t!blue\tbright versions\r\n!\t12,\r\n!\t13,\r\n!\t10,\r\n!\t11,\r\n!\t14,\r\n!\t15)\r\n\r\ncolourpalette:=new(ws_palette16)\r\n\r\nsetstdpalette()\r\nend\r\n\r\nglobal function setcursor(?visible)=\r\ncursor:=new(ws_cursor)\r\ngetconsolecursorinfo(hconsole,&cursor)\r\n\r\nif visible.defined then\r\n\tcursor.visible:=visible\r\n\tsetconsolecursorinfo(hconsole,&cursor)\r\nfi\r\nreturn cursor.visible\r\nend\r\n\r\nglobal proc setcolour(fgnd,bgnd)=\r\n!call with as (fgnd,bgnd) or as (fgnd..bgnd)\r\n\r\nif fgnd=currfgnd and bgnd=currbgnd then\r\n\treturn\r\nfi\r\n\r\ncurrfgnd:=fgnd\r\ncurrbgnd:=bgnd\r\n\r\n!setconsoletextattribute(hconsole,(colourmap[bgnd]*16 + colourmap[fgnd]))\r\nsetconsoletextattribute(hconsole,(bgnd*16+fgnd))\r\nend\r\n\r\nglobal proc settitle(caption)=\r\nsetconsoletitle(caption)\r\nend\r\n\r\nglobal function getkeychar=\r\n!wait for any key, return single char code; as returned by C's getch()\r\nreturn waitkey()\r\nend\r\n\r\nglobal function getkey2=\r\n!wait for any key, return keyrec\r\n!includes shift key presses as discrete keys\r\n!use getkey() to ignore these\r\n\r\nreturn getchx()\r\n\r\nk:=getchx()\t\t\t!get keyrec, encoded as int\r\n\r\nkey:=new(rkey)\t\t\t!convert to proper keyrec\r\nkey.charcode:=k iand 65535\r\nkey.shift:=k>>24\r\nkey.keycode:=k.[23..16]\r\n!CPL \"GK2:\",KEY\r\n\r\nreturn key\r\nend\r\n\r\nglobal function getkey=\r\n!calls igetkey but doesn't return shift keys as discrete key presses\r\ndo\r\n\tk:=getkey2()\r\n\tcase k.keycode\r\n\twhen vkshift,vkctrl,vkalt,vkcapslock then\r\n\telse\r\n\t\texit\r\n\tesac\r\nod\r\nreturn k\r\nend\r\n\r\nglobal function keyready=\r\nreturn testkey()\r\nend\r\n\r\nglobal proc showtext(s)=\r\nif s then\r\n\tcount:=0\r\n\tif not suppress then\r\n\t\twriteconsole(hconsole,s,s.len,&count,0)\r\n\tfi\r\nfi\r\nend\r\n\r\nproc setwindowsize(cols,rows)=\r\nr:=new(ws_srect)\r\nr.leftx:=0\r\nr.rightx:=cols-1\r\nr.top:=0\r\nr.bottom:=rows-1\r\nif not setconsolewindowinfo(hconsole,1,&r) then\r\nCPL \"WINDOW ERROR 1\"\r\n!\tabort(\"Window error 1\")\r\nfi\r\nend\r\n\r\nglobal proc setdims(cols,rows)=\r\n!set new size for console, by reinitialising\r\n\r\n!CPL \"WINCON/SETDIMS\"\r\nmaxcol:=cols\r\nmaxrow:=rows\r\n\r\ninfo:=new(ws_console)\r\noldscreenattributes:=info.attributes\r\noldscreensize:=info.size\r\n\r\noldcols:=info.window.rightx-info.window.leftx+1\r\noldrows:=info.window.bottom-info.window.top+1\r\n\r\nIF OLDSCREENSIZE.X>COLS OR OLDSCREENSIZE.Y>ROWS THEN\t!need to reduce window size first\r\n\tsetwindowsize(oldscreensize.x min cols, oldscreensize.y min rows)\r\nfi\r\n\r\n!Set the new size of the entire (virtual) console window\r\nif setconsolescreenbuffersize(hconsole,rows<<16+cols)=0 then\r\n!\tabort(\"Buffer size error\")\r\nfi\r\n\r\n!now set the size of the displayed portion of it; in this case exactly the same\r\n!size as the buffer, with no scrollbars\r\nsetwindowsize(cols,rows)\r\n\r\nwscreencols:=cols\r\nwscreenrows:=rows\r\n\r\n!hide blinking cursor\r\ncursor:=new(ws_cursor)\r\ncursor.size:=10\r\ncursor.visible:=1\r\nend\r\n\r\nglobal proc setpalette(index,colour)=\r\n!index is 0..15; colour is an rgb value bbggrr\r\n!updates local palette array\r\n!to update actual console, use writepalette\r\ncolourpalette[index]:=colour\r\nend\r\n\r\nglobal proc writepalette=\r\nr:=new(ws_consoleex)\r\nr.recsize:=ws_consoleex.bytes\r\nX:=getconsolescreenbufferinfoex(hconsole,&r)\r\n\r\nr.palette:=colourpalette\r\n\r\nR.WINDOW.RIGHTX:=R.WINDOW.RIGHTX+1\t\t!workaround off-by-one bug\r\nR.WINDOW.BOTTOM:=R.WINDOW.BOTTOM+1\r\n\r\nX:=setconsolescreenbufferinfoex(hconsole,&r)\r\nend\r\n\r\n!global proc READPALETTE=\r\n!r:=new(rconsoleex)\r\n!r.recsize:=rconsoleex.bytes\r\n!x:=getconsolescreenbufferinfoex(hconsole,&r)\r\n!\r\n!CPL \"GCSBI X=\",X\r\n!FOR I:=0 TO 15 DO\r\n! CPL I,\":\",R.PALETTE[I]:\"H\"\r\n!OD\r\n!\r\n!end\r\n\r\nproc setstdpalette=\r\n!global const con_black=0\r\n!global const con_dkblue=1\r\n!global const con_dkred=2\r\n!global const con_dkmagenta=3\r\n!global const con_dkgreen=4\r\n!global const con_dkcyan=5\r\n!global const con_dkyellow=6\r\n!global const con_grey=7\r\n!global const con_dkgrey=8\r\n!global const con_blue=9\r\n!global const con_red=10\r\n!global const con_magenta=11\r\n!global const con_green=12\r\n!global const con_cyan=13\r\n!global const con_yellow=14\r\n!global const con_white=15\r\n\r\n!R G B\r\ncols:=(\r\n(0,\t\t0,\t\t0),\t\t\t!black\r\n(0,\t\t0,\t\t128),\t\t!dk blue\r\n(128,\t0,\t\t0),\t\t\t!dk red\r\n(128,\t0,\t\t128),\t\t!dk magenta\r\n(0,\t\t128,\t0),\t\t\t!dk green\r\n(0,\t\t128,\t128),\t\t!dk cyan\r\n(128,\t128,\t0),\t\t\t!dk yellow\r\n(128,\t128,\t128),\t\t!dk grey\r\n(192,\t192,\t192),\t\t!grey\r\n(0,\t\t0,\t\t192),\t\t!blue\r\n(192,\t0,\t\t0),\t\t\t!red\r\n(192,\t0,\t\t192),\t\t!magenta\r\n(0,\t\t192,\t0),\t\t\t!green\r\n(0,\t\t192,\t192),\t\t!cyan\r\n(192,\t192,\t0),\t\t\t!yellow\r\n(255,\t255,\t255))\t\t!white\r\n\r\nforall i,c in cols do\r\n\tsetpalette(i-1,c[3]<<16+c[2]<<8+c[1])\r\nod\r\n!CPL \"WRITEPAL\"; WAITKEY()\r\nwritepalette()\r\nend\r\n\r\nproc getdims=\r\n!CPL \"WINCON/GETDIMS\"\r\ninfo:=new(ws_console)\r\ngetconsolescreenbufferinfo(hconsole,&info)\r\n\r\nwscreencols:=info.window.rightx-info.window.leftx+1\r\nwscreenrows:=info.window.bottom-info.window.top+1\r\nend\r\n\r\nglobal function getchx=\r\nconst rightaltmask\t= 1\t\t\t\t!masks used by .controlkeystate\r\nconst leftaltmask\t= 2\r\nconst leftctrlmask\t= 8\r\nconst rightctrlmask\t= 4\r\nconst shiftmask\t\t= 16\r\nconst capsmask\t\t= 128\r\nconst scrollmask\t= 64\r\n\r\nconst leftctrlbit\t= 3\t\t!for c.l.p\r\nconst rightctrlbit\t= 2\r\n\r\nif keypending then\r\n\tlastkey:=pendkey\r\n\tkeypending:=0\r\nelse\r\n\tif lastkey.repeatcount=0 then\r\n\t\trepeat\r\n\t\t\tcount:=0\r\n\t\t\treadconsoleinput(hconsolein,&lastkey,1,&count)\r\n\t\tuntil lastkey.eventtype=1 and lastkey.keydown=1\r\n\tfi\r\nfi\r\n\r\naltdown\t\t:= (lastkey.controlkeystate iand (leftaltmask ior rightaltmask)|1|0)\r\nctrldown\t:= (lastkey.controlkeystate iand (leftctrlmask ior rightctrlmask)|1|0)\r\nshiftdown\t:= (lastkey.controlkeystate iand shiftmask|1|0)\r\ncapslock\t:= (lastkey.controlkeystate iand capsmask|1|0)\r\n\r\nlastkey.repeatcount:=lastkey.repeatcount-1\r\n\r\ncharcode:=lastkey.asciichar\r\nkeycode:=lastkey.virtualkeycode iand 255\r\n\r\n!for keycodes in range 186 to 223, which are all stand-alone punctuation keys, I might\r\n!wish to set charcode to the appropriate printed char code (currently charcode will be\r\n!zero, and keyboard handlers need to detect keycodes such as vkequals)\r\n!\r\nif altdown and ctrldown and charcode=166 then\r\n\taltdown:=ctrldown:=0;\r\nelse\r\n\tif altdown or ctrldown then\r\n\t\tcharcode:=0;\r\n\t\tif keycode>='A' and keycode<= 'Z' then\r\n\t\t\tcharcode:=keycode-'@'\r\n\t\tfi\r\n\tfi\r\nfi\r\n\r\nkeyshift:=capslock<<3 ior altdown<<2 ior ctrldown<<1 ior shiftdown\r\n\r\nkeyshift.[4]:=lastkey.controlkeystate.[leftctrlbit]\t\t!for c.l.p\r\nkeyshift.[5]:=lastkey.controlkeystate.[rightctrlbit]\r\n\r\n!need to be more ruthless with how keycoded and charcodes are combined.\r\n!More combinations need to have only charcode or keycode set, and the other zero\r\n\r\nswitch charcode\r\nwhen 'A'..'Z','a'..'z','0'..'9' then\r\nwhen 8,9,13,27,' ','`' then\r\nwhen 0 then\t\t\t\t!already key-only event\r\nelse\r\n\tkeycode:=0\r\nendswitch\r\n\r\nreturn rkey(charcode,keycode,keyshift)\r\n\r\nend\r\n\r\nglobal proc flushkeyboard=\r\nflushconsoleinputbuffer(hconsolein)\r\nend\r\n\r\nglobal proc w_writeconsolerow(text, attributes, length, row)=\r\nbuffersize:=1<<16+length\r\ncoord:=0\r\n\r\nbox:=ws_srect(0,row-1,length-1,row-1)\r\n\r\nbuffer:=new(array,ws_charinfo,length)\r\n\r\nfor i:=1 to length do\r\n\tx:=new(ws_charinfo)\r\n\tx.asciichar  := text.[i]\r\n\tx.attributes := attributes.[i]\r\n!\tx.attributes := attributes.[1]\r\n\tbuffer[i]:=x\r\nod\r\n!CPL \"HELLO\",text; WAITKEY()\r\n\r\nwriteconsoleoutputa(hconsole, &buffer,buffersize,coord,&box)\r\nend\r\n\r\nglobal function setclipboard(s)=\r\n!copy text to the Windows clipboard\r\n!return status 0 if no clipboard o/p was possible\r\nconst ghnd=2 + 0x40\r\n\r\nif openclipboard(0)=0 then\r\n\treturn 0\r\nfi\r\n\r\nemptyclipboard()\r\n\r\nif s<>\"\" then\r\n\th:=globalalloc(ghnd,s.len+1)\r\n\tp:=globallock(h)\r\n\r\n\tmemcpy(p,&s,s.len+1)\r\n\tglobalunlock(h)\r\n\tsetclipboarddata(cf_text,h)\r\nfi\r\n\r\ncloseclipboard()\r\n\r\nreturn 1\r\nend\r\n\r\nglobal function getclipboard=\r\n!copy text from Windows clipboard\r\n!return clipboard text, or \"\" when error or not text data available\r\n\r\nif openclipboard(0)=0 then\r\n\treturn \"\"\r\nfi\r\n\r\nhtext:=getclipboarddata(cf_text)\r\n\r\nif not htext then\r\n\treturn \"\"\r\nfi\r\n\r\nsize:=globalsize(htext)\t\t!should include zero terminator\r\n\r\np:=globallock(htext)\r\ns:=makestr(p,size-1)\t\t!assignment should copy the string data\r\n\r\nglobalunlock(htext)\r\n\r\ncloseclipboard()\r\nreturn s\r\nend\r\n\r\n",
    \
(uint8_t*)"global type rkey=struct\t!key info as it's used locally\r\n\tword16\tcharcode\r\n\tbyte\tkeycode\r\n\tbyte\tshift\r\nend\r\n\r\nglobal var ncmdparams\r\nglobal var cmdparams\r\nglobal var stclock=0\r\n\r\nproc start=\r\n\r\n\tncmdparams:=getcmdparam()-1\r\n\tcmdparams:=new(list,0..ncmdparams)\r\n\r\n\tfor i:=0 to ncmdparams do\r\n\t\tcmdparams[i]:=getcmdparam(i)\r\n\tod\r\n\r\n\tcmdparams[0]:=gethostname()\r\nend\r\n\r\nproc main=\r\n\tstart()\r\n\r\n\tfiles:=cmd_getparams()\r\n\tswitches:=cmd_getswitches()\r\n\r\n\tprintln =files\r\n\tprintln =switches\r\n\r\nend\r\n\r\nglobal proc reporterror(m)=\t\t!REPORTERROR\r\n\tprintln \"Error:\",m\r\nend\r\n\r\nglobal function splitstring(s,sep)=\t\t!SPLITSTRING\r\n!split up the string s into strings separated by the sep sequence\r\n!return a list of all the individual strings, excluding the sep seq\r\n\r\n\ta:=()\r\n\tns:=0\r\n\tif s=\"\" or sep=\"\" then return (s,) fi\r\n\tdo\r\n\t\tn:=sep in s\r\n\t\tif n=0 then\r\n\t\t\ta[++ns]:=s\r\n\t\t\treturn a\r\n\t\tfi\r\n\t\tt:=leftstr(s,n-1)\r\n\t\ta[++ns]:=t\r\n\t\ts:=rightstr(s,-(n+sep.len-1))\r\n\tod\r\n\treturn \"\"\r\nend\r\n\r\nglobal function joinstrings(a,sep)=\t\t!JOINSTRINGS\r\n!join the strings in list, using the given separator string\r\n!return new single string\r\n\tif a.upb=0 then return \"\" fi\r\n\ts:=a[1]\r\n\tfor i:=2 to a.upb do\r\n\t\ts:=s+sep+a[i]\r\n\tod\r\n\treturn s\r\nend\r\n\r\nglobal proc abort(s)=\t\t!ABORT\r\n\tprintln \"Abort:\",s,\"Error\"\r\n\twaitkey()\r\n\tstop 1\r\nend\r\n\r\nglobal function extractpath(fs)=\t\t!EXTRACTPATH\r\n!fs is a full filespec string\r\n!extract any path from it and return that; ie, strip the filename\r\n!otherwise return \"\"\r\n\tl:=fs.len\r\n\tfor i:=l downto 1 do\r\n\t\tif chr(fs.[i]) in \"\\\\/:\" then\r\n\t\t\treturn leftstr(fs,i)\r\n\t\tfi\r\n\tod\r\n\treturn \"\"\r\nend\r\n\r\nglobal function extractfile(fs)=\t\t!EXTRACTFILE\r\n!return filename portion of path fs\r\n\tp:=extractpath(fs)\r\n\tif p=\"\" then return fs fi\r\n\treturn rightstr(fs,-p.len)\r\nend\r\n\r\nglobal function extractbasefile(fs)=\t\t!EXTRACTBASEFILE\r\n!return filename portion of path fs\r\n\tf:=extractfile(fs)\r\n\tif f=\"\" then return \"\" fi\r\n\te:=extractext(f)\r\n\tif e.len then\r\n\t\tf:=leftstr(f,-e.len)\r\n\tfi\r\n\tif rightstr(f)=\".\" then\r\n\t\tf:=leftstr(f,-1)\r\n\tfi\r\n\treturn f\r\nend\r\n\r\nglobal function extractext(fs,?period)=\t\t!EXTRACTEXT\r\n!extract extension part of filespec fs\r\n!endings of \"xxx\" (no extension) and \"xxx.\" both return \"\"\r\n!with period=1, then \"xxx\" returns \"\" and \"xxx.\" returns . (so can be used to\r\n!override default extensions)\r\n\r\n\tf:=extractfile(fs)\r\n\tif f=\"\" then return \"\" fi\r\n\te:=\"\"\r\n\tdo\r\n\t\tn:=\".\" in f\r\n\t\tif n then\r\n\t\t\te:=rightstr(f,-n)\r\n\t\t\tif e=\"\" then\t\t!. ending\r\n\t\t\t\treturn (period.defined and period|\".\"|\"\")\r\n\t\t\tfi\r\n\r\n\t\t\tf:=e\r\n\t\telse\r\n\t\t\texit\r\n\t\tfi\r\n\tod\r\n\r\n\treturn e\r\nend\r\n\r\nglobal function changeext(file,newext,soft=0)=\t\t!CHANGEEXT\r\n!normally face a change of extension to the file spec\r\n!use soft=1 to only change extension if no extension is present (a \".\" ending is an extension)\r\n\r\n\text:=extractext(file)\r\n\r\n\tp:=extractpath(file)\r\n\tbf:=extractbasefile(file)\r\n\tep:=extractext(file,1)\r\n\r\n\tif soft and ep<>\"\" then return file fi\t\t!has extension, don't change!\r\n\r\n\tif newext=\"\" then\r\n\t\treturn p+bf\r\n\telsif leftstr(newext)=\".\" then\r\n\t\treturn p+bf+newext\r\n\telse\r\n\t\treturn p+bf+\".\"+newext\r\n\tfi\r\nend\r\n\r\nglobal function addpath(path,file)=\t\t!ADDPATH\r\n\r\n\tif leftstr(file) in \"/\\\\.\" or file.len>=2 and file.[2]=\":\" then\r\n\t\treturn file\r\n\tfi\r\n\treturn path+file\r\nend\r\n\r\nglobal function addext(file,ext)=\t\t!ADDEXT\r\n!add extension to filename, if it doesn't already have it's own extenstion\r\n\r\n\tif extractext(file,1)=\"\" then\r\n\t\treturn changeext(file,ext)\r\n\tfi\r\n\treturn file\r\nend\r\n\r\nglobal function replacestr (s,a,b)=\t\t!REPLACESTR\r\n!if string a exists in s, then replace with b\r\n!return original or modified s\r\n\tdo\r\n\t\tn:=a in s\r\n\t\tif not n then return s fi\r\n\t\ts:=leftstr(s,n-1)+b+rightstr(s,1-n-a.len)\r\n\tod\r\n\treturn \"\"\r\nend\r\n\r\nglobal function parsecmdparams(cmd)=\t\t!PARSECMDPARAMS\r\n!cmd consists of:\r\n!blocks of text separated by whitespace or commas\r\n!each block is one of these formats\r\n! ...\t\tparam only\r\n! /...\t\tconsists of switches only\r\n! .../...\tparam followed by switches\r\n!return of (params,switches), where each is a list of strings\r\n!note that any correspondence between params and switches is lost; all switches assumed\r\n!to be global, but can appear anywhere\r\n!NOTE: cmd can also already be a list of blocks\r\n\r\nconst dash=\"-\"\r\n\r\n\tif cmd.isarray then\r\n\t\tblocks:=cmd\r\n\telse\r\n\t\tsreadln(cmd)\r\n\t\tblocks:=()\r\n\t\tdo\r\n\t\t\tread a:\"s\"\r\n\t\t\tif a=\"\" then exit fi\r\n\t\t\tblocks append:=a\r\n\t\tod\r\n\tfi\r\n\r\n\tparams:=()\r\n\tswitches:=()\r\n\r\n\tforall x in blocks do\r\n\t\tn:=dash in x\r\n!CPL \"PCPLOOP\",=N\r\n\t\tif n<>1 then\t\t!pure param\r\n\t\t\tparams append:=x\r\n\t\telse\t\t!pure switches\r\n\t\t\tswitches concat:=splitstring(convlc(rightstr(x,-1)),\"/\")\r\n!\t\telse\t\t\t!param followed by switches\r\n!\t\t\tparams append:=leftstr(x,n-1)\r\n!\t\t\tswitches concat:=splitstring(convlc(rightstr(x,-n)),\"/\")\r\n\t\tfi\r\n\tod\r\n\r\n\treturn (params,switches)\r\nend\r\n\r\nglobal proc waitsec(secs)=\t\t!WAITSEC\r\n\tsleep(int(secs*1000))\r\nend\r\n\r\nglobal function cmd_getswitches=\t\t!CMD_GETSWITCHES\r\n!params is a list of strings, which can start with \"/\" or not\r\n!read all switches, and return a list of switch names (minus the \"/\")\r\n!each string can have more than one switch\r\n!some switches can follow a name in a string\r\n\r\n\tswitches:=()\r\n\tfor i:=2 to cmdparams.upb do\t\t!use 1..len in case called on <cmdparams> which has lwb 0\r\n\t\ts:=cmdparams[i]\r\n\t\tif leftstr(s) in \"-/\" then\r\n\t\t\tswitches append:=convlc(rightstr(s,-1))\r\n\t\tfi\r\n\tod\r\n\treturn switches\r\nend\r\n\r\nglobal function cmd_getparams=\t\t!CMD_GETPARAMS\r\n!params is a list of strings\r\n!return list of actual params, not including any switches\r\n!switches are read separately using cmd_getswitches, but are not associated with\r\n!specific params. That would need to be done here (when / is detected in the middle\r\n!of a param, then make use readswitches. But to return that info, may be best to\r\n!create a parallel function)\r\n\r\n\tcmds:=()\r\n\r\n!CPL \"CMDGET2\",cmdparams.bounds\r\n\r\n\tfor i:=2 to cmdparams.upb do\r\n\t\tpm:=cmdparams[i]\r\n!forall pm in params do\r\n\t\tif leftstr(pm) in \"-\" then\r\n\t\t\tnext\r\n\t\tfi\r\n!\tn:=\"/\" in pm\r\n!\tif n=0 then\r\n\t\t\tcmds append:=pm\r\n!\telse\r\n!\t\tcmds append:=leftstr(pm,n-1)\r\n!\tfi\r\n\tod\r\n\treturn cmds\r\nend\r\n\r\nglobal function starttimer=\t\t!STARTTIMER\r\n\treturn stclock:=ticks()\r\nend\r\n\r\nglobal function stoptimer=\t\t!STOPTIMER\r\n\treturn ticks()-stclock\r\nend\r\n\r\nglobal function bnfact(n)=\t\t!BNFACT\r\n!n is limited to 9 million million million\r\n\r\n\tif n<=2 then\r\n\t\treturn longint(n)\r\n\tfi\r\n\r\n\tf:=1L\r\n\tg:=2L\r\n\tto n-1 do\r\n\t\tf:=f*g\r\n\t\tg:=g+1L\r\n\r\n\tod\r\n\treturn f\r\nend\r\n\r\nglobal proc isort(a,?ll,?rr)=\r\n\r\n\tif ll.isvoid then\r\n\t\tll:=a.lwb\r\n\t\trr:=a.upb\r\n\tfi\r\n\r\n\ti:=ll\r\n\tj:=rr\r\n\r\n\tpivot:=a[(ll+rr)%2]\r\n\r\n\trepeat\r\n\t\twhile pivot>a[i] and i<rr do ++i od\r\n\t\twhile pivot<a[j] and j>ll do --j od\r\n\t\tif i<=j then\r\n\t\t\tswap(a[i],a[j])\r\n\t\t\t++i\r\n\t\t\t--j\r\n\t\tfi\r\n\tuntil i>j\r\n\tif ll<j then isort(a,ll,j) fi\r\n\tif i<rr then isort(a,i,rr) fi\r\nend\r\n\r\nglobal function sort(a)=\r\n\tb::=a\r\n\tisort(b)\r\n\treturn b\r\nend\r\n\r\nglobal function pcerror(m)=\r\n\tprintln \"Internal error:\",m\r\n\ta:=b+c\r\n\treturn 0\r\nend\r\n\r\n!=========================================\r\nglobal proc insert(&a, b, c)=\t\t!INSERT\r\n!insert value c just before index b\r\n!c is always a single value; to insert a sequence c, use insertn()\r\n\tn:=a.upb\r\n\ta[n+1]:=c\r\n\tfor i:=n downto b do\r\n\t\tswap(a[i+1],a[i])\r\n\tod\r\nend\r\n\r\nglobal proc isort2(a,b,?ll,?rr)=\r\n\r\n!CPL \"ISORT2\"\r\n\r\n\tif ll.isvoid then\r\n\t\tll:=a.lwb\r\n\t\trr:=a.upb\r\n\tfi\r\n\r\n\ti:=ll\r\n\tj:=rr\r\n\r\n\tpivot:=a[(ll+rr)%2]\r\n\r\n\trepeat\r\n\t\twhile pivot>a[i] and i<rr do ++i od\r\n\t\twhile pivot<a[j] and j>ll do --j od\r\n\t\tif i<=j then\r\n\t\t\tswap(a[i],a[j])\r\n\t\t\tswap(b[i],b[j])\r\n\t\t\t++i\r\n\t\t\t--j\r\n\t\tfi\r\n\tuntil i>j\r\n\tif ll<j then isort2(a,b,ll,j) fi\r\n\tif i<rr then isort2(a,b,i,rr) fi\r\nend\r\n\r\nglobal function left(a,n=1)=\r\n#return leftmost n elements of a (default left element)\r\n#when n is negative, all except rightmost -n\r\n\r\n\tif n>=0 then\r\n\t\treturn take(a,n)\r\n\telse\r\n\t\treturn take(a,a.len+n)\r\n\tfi\r\nend\r\n\r\nglobal function right(a,n=1)=\r\n#return rightmost n elements of a (default right element)\r\n#when n is negative, all except leftmost -n\r\n\r\n\tif n>=0 then\r\n\t\treturn drop(a,a.len-n)\r\n\telse\r\n\t\treturn drop(a,-n)\r\n\tfi\r\nend\r\n\r\nglobal function reverse(a)=\r\n#return reversed version of a\r\n#when 0, returns empty\r\n#when 1 element, returns a distinct, writeable copy\r\n\r\n\tif a.len=0 then\r\n\t\treturn makeempty(a)\r\n\tfi\r\n\tb::=a\r\n\tif a then\r\n\t\tfor i in a do\r\n\t\t\tb[a.upb-i+a.lwb]:=a[i]\r\n\t\tod\r\n\tfi\r\n\treturn b\r\nend\r\n\r\nproc rotate(&a,middle)=\r\n\r\n\tfirst:=a.lwb\r\n\tlastx:=a.upb+1\r\n\tnxt:=middle\r\n\r\n\twhile first<>nxt do\r\n\t\tswap(a[first++],a[nxt++])\r\n\t\tif nxt=lastx then\r\n\t\t\tnxt:=middle\r\n\t\telsif first=middle then\r\n\t\t\tmiddle:=nxt\r\n\t\tfi\r\n\tod\r\nend\r\n\r\nfunction rotate2(a,middle)=\r\n\treturn right(a,-middle) concat left(a,middle)\r\nend\r\n\r\nglobal function expandrange(a,step=1)=\r\n\r\n\tx:=()\r\n\ti:=a.lwb\r\n\twhile i<=a.upb do\r\n\t\tx append:=i\r\n\t\ti+:=step\r\n\tod\r\n\treturn x\r\nend\r\n\r\nglobal function head(a)=\r\n#return first element, or empty when empty\r\n\r\n\tif a.len then\r\n\t\treturn a[a.lwb]\r\n\telse\r\n\t\treturn makeempty(a)\r\n\tfi\r\nend\r\n\r\nglobal function tail(a)=\r\n#return all except the first element\r\n#returns empty when only 0 or 1 elements\r\n\r\n\tcase a.len\r\n\twhen 0,1 then\r\n\t\treturn makeempty(a)\r\n\tesac\r\n\treturn a[2..$]\r\nend\r\n\r\nglobal function init(a)=\r\n#return all except last element\r\n#returns empty when only 0 or 1 elements\r\n\tcase a.len\r\n\twhen 0,1 then\r\n\t\treturn makeempty(a)\r\n\tesac\r\n\treturn a[a.lwb..$-1]\r\nend\r\n\r\nglobal function last(a)=\r\n#return last element, or empty\r\n\tif a.len then\r\n\t\treturn a[$]\r\n\telse\r\n\t\treturn makeempty(a)\r\n\tfi\r\nend\r\n\r\nglobal function take(a,n)=\r\n#return first n elements from list/string a\r\n#returns () or \"\" when a is empty\r\n#n > 0 (n<=0 returns empty)\r\n\r\n\tif a.len=0 or n<=0 then\r\n\t\treturn makeempty(a)\r\n\tfi\r\n\tif n>=a.len then\r\n\t\treturn a\r\n\tfi\r\n\treturn a[a.lwb..a.lwb+n-1]\r\nend\r\n\r\nglobal function drop(a,n)=\r\n#skips first n elements of a then returns the rest\r\n#returns () when empty, or skipping the whole list\r\n#n >= 0\r\n\r\n\tif a.len=0 or n>=a.len then\r\n\t\treturn makeempty(a)\r\n\tfi\r\n\tif n<=0 then\r\n\t\treturn a\r\n\tfi\r\n\treturn a[a.lwb+n..$]\r\nend\r\n\r\nglobal function zip(a,b)=\r\n#return a list consisting of alternate elements from a and b\r\n#uses smaller of the two dimensions\r\n\r\n\tn:=min(a.len,b.len)\r\n\tc:=()\r\n\r\n!\tj:=a.lwb; k:=b.lwb\r\n\t(j, k) := (a.lwb, b.lwb)\r\n\r\n\tto n do\r\n\t\tc append:=a[j++]\r\n\t\tc append:=b[k++]\r\n\tod\r\n\treturn c\r\nend\r\n\r\nglobal function repeatlist(a,n)=\r\n#duplicate a n times, and return the result\r\n#this ought to be built-in as a*n, but that's only implemented for a.len=1\r\n\r\n\tb:=makeempty(a)\r\n\tto n do\r\n\t\tb concat:=a\r\n\tod\r\n\treturn b\r\nend\r\n\r\nglobal function minimum(a)=\r\n\tif not a then\r\n\t\treturn void\r\n\tfi\r\n\tx:=head(a)\r\n\tforall y in tail(a) do\r\n\t\tx min:=y\r\n\tod\r\n\treturn x\r\nend\r\n\r\nglobal function maximum(a)=\r\n\tif not a then\r\n\t\treturn void\r\n\tfi\r\n\tx:=head(a)\r\n\tforall y in tail(a) do\r\n!\t\tx max:=y\r\n\t\tx := x max y\r\n\tod\r\n\treturn x\r\nend\r\n\r\nglobal function sumlist(a)=\r\n# apply \"+\" between all elements of a, and return result\r\n# all elements must be compatble (all strings or all numbers for example)\r\n# returns void then a is empty, or head(a) when just one element\r\n\r\n\tif not a then\r\n\t\treturn void\r\n\tfi\r\n\tx:=head(a)\r\n\tforall y in tail(a) do\r\n\t\tx +:=y\r\n\tod\r\n\treturn x\r\nend\r\n\r\nglobal function prepend(x,a)=\r\n#return a but with x inserted as the first element\r\n\treturn (x,) concat a\r\nend\r\n\r\nglobal proc delete(&a,?b)=\t\t!DELETE\r\n!delete element b\r\n\tn:=a.upb\r\n\tif b.isvoid then b:=n fi\r\n\r\n\tif n=b=1 then\r\n\t\ta:=()\r\n\t\treturn\r\n\tfi\r\n\r\n\tif b>n then return fi\r\n\tif b<a.lwb then return fi\r\n\tfor i:=b to n-1 do\r\n\t\tswap(a[i],a[i+1])\t\t\t!swap is faster for complex elements\r\n\tod\r\n!a[n]:=0\t\t!don't leave any heap data beyond new end of list\r\n\r\n\tresize(a,n-1)\r\nend\r\n\r\nglobal proc resize(&a,n)=\r\n!change the upper bound of a to n\r\n\r\n\tif n<a.lwb then\r\n\t\ta:=makeempty(a)\r\n\t\treturn\r\n\tfi\r\n\r\n\ta::=a[a.lwb..n]\t\t\t!duplication forces original to be freed\r\nend\r\n \r\nglobal function makebits(data,t=bit)=\r\n\r\n!CPL =DATA,data.bounds,t,bit\r\n\r\n\ta:=new(bits,t,data.bounds)\r\n\tfor i:=data.lwb to data.upb do\r\n\t\ta[i]:=data[i]\r\n\tod\r\n!CPL \"MB\",=A,a.bounds\r\n\r\n\treturn a\r\nend\r\n\r\nglobal function makearray(data,t=int32)=\r\n\r\n\ta:=new(array,t,data.bounds)\r\n\tfor i:=data.lwb to data.upb do\r\n\t\ta[i]:=data[i]\r\n\tod\r\n\treturn a\r\nend\r\n\r\nglobal function tolist(a)=\r\n\tcase a.basetype\r\n\twhen array,string,bits then\r\n\t\tb:=new(list,a.bounds)\r\n\t\tforall i,x in a do\r\n\t\t\tb[i]:=x\r\n\t\tod\r\n\t\treturn b\r\n!\twhen string then\r\n!\t\tb:=new(list,a.len)\r\n!\t\ti:=1\r\n!\t\tforall i,x in a do\r\n!\t\t\tb[i++]:=x\r\n!\t\tod\r\n!\t\treturn b\r\n\r\n\twhen list then\r\n\t\treturn a\r\n\telse\r\n\t\tpcerror(\"tolist:\"+tostr(a.type))\r\n\tesac\r\n\treturn 0\r\nend\r\n\r\nglobal function toarray(a,?t)=\r\n\tcase a.basetype\r\n\twhen list then\r\n\t\tif t.isvoid then\r\n\t\t\tif a then\r\n\t\t\t\tt:=a[a.lwb].type\r\n\t\t\telse\r\n\t\t\t\tt:=int32\r\n\t\t\tfi\r\n\t\tfi\r\n\r\n\twhen bits then\r\n\t\tif t.isvoid then\r\n\t\t\tt:=byte\r\n\t\tfi\r\n\r\n\twhen string then\r\n\t\tif t.isvoid then t:=byte fi\r\n\t\tb:=new(array,t,a.len)\r\n\t\tforeach i,x in a do\r\n\t\t\tb[i]:=x\r\n\t\tod\r\n\t\treturn b\r\n\twhen array then\r\n\t\tif t.isvoid then\r\n\t\t\treturn a\r\n\t\tfi\r\n\t\tu:=e.elemtype\r\n\t\tif t=u then return a fi\r\n\telse\r\n\t\tpcerror(\"toarray:\"+tostr(a.type))\r\n\tesac\r\n\tb:=new(array,t,a.bounds)\r\n\r\n\tforall i,x in a do\r\n\t\tb[i]:=x\r\n\tod\r\n\treturn b\r\nend\r\n\r\nglobal function tobits(a,t=bit)=\r\n\tcase a.basetype\r\n\twhen list,array then\r\n\r\n\twhen bits then\r\n\t\tif a.elemtype=t then\r\n\t\t\treturn a\r\n\t\tfi\r\n\r\n\telse\r\n\t\tpcerror(\"tobits:\"+tostr(a.type))\r\n\tesac\r\n\tb:=new(bits,t,a.bounds)\r\n\tforall i,x in a do\r\n\t\tb[i]:=x\r\n\tod\r\n\treturn b\r\nend\r\n\r\nglobal function listtostring(a)=\r\n!a should be a list or array\r\n!interpreter elements as characters and form a single string\r\n\ts:=\"\"\r\n\tforall x in a do\r\n!\t\ts+:=chr(x)\r\n\t\ts+:=x\r\n\tod\r\n\treturn s\r\nend\r\n\r\nglobal function qversion=\r\n\treturn \"3.0\"\r\nend\r\n\r\nglobal proc issort(a,?ll,?rr)=\r\n\r\n\tif ll.isvoid then\r\n\t\tll:=a.lwb\r\n\t\trr:=a.upb\r\n\tfi\r\n\r\n\ti:=ll\r\n\tj:=rr\r\n\r\n\tpivot:=a.[(ll+rr)%2]\r\n\r\n\trepeat\r\n\t\twhile pivot>a.[i] and i<rr do ++i od\r\n\t\twhile pivot<a.[j] and j>ll do --j od\r\n\t\tif i<=j then\r\n\t\t\tswap(a.[i],a.[j])\r\n\t\t\t++i\r\n\t\t\t--j\r\n\t\tfi\r\n\tuntil i>j\r\n\tif ll<j then issort(a,ll,j) fi\r\n\tif i<rr then issort(a,i,rr) fi\r\nend\r\n\r\nglobal function ssort(a)=\r\n\tb::=a\r\n\tissort(b)\r\n\treturn b\r\nend\r\n\r\nglobal function mapop(op,a)=\r\n\tb:=()\r\n\tif op.ispointer then\r\n\r\n\t\tforall i,x in a do\r\n\t\t\tb[i]:=op^(x)\r\n\t\tod\r\n\telse\r\n\t\tforall i,x in a do\r\n\t\t\tb[i]:=applyop(op,x)\r\n\t\tod\r\n\tfi\r\n\treturn b\r\nend\r\n\r\nglobal function mapop2(op,a,b)=\r\n\tc:=()\r\n\tforall i,x in a do\r\n\t\tc[i]:=applyop(op,x,b[i])\r\n\tod\r\n\treturn c\r\nend\r\n\r\nglobal function mapopvs(op,a,y)=\r\n\tc:=()\r\n\tforall i,x in a do\r\n\t\tc[i]:=applyop(op,x,y)\r\n\tod\r\n\treturn c\r\nend\r\n\r\nglobal function mapopvv(op,a,b)=\r\n\tc:=()\r\n\tforall i,x in a do\r\n\t\tc[i]:=applyop(op,x,b[i])\r\n\tod\r\n\treturn c\r\nend\r\n\r\n",
    \
(uint8_t*)"import sys\r\nimport clib\r\n\r\nglobal var readfilesize\r\n\r\nproc start=\t\t\t\t!START\r\nend\r\n\r\nproc main=\r\n\r\n!cpl \"FILES TESTING\"\r\n!S:=READSTRFILE(\"KKK1\")\r\n!\r\n!CPL S\r\n\r\nend\r\n\r\nglobal function openfile(name,option=\"rb\")=\r\nif not name.isstring or name=\"\" then\r\n\treturn 0\r\nfi\r\nreturn fopen(name,option)\r\nend\r\n\r\nglobal function createfile(name,options=\"wb\")=\t\t!CREATEFILE\r\nif not options.defined then options:=\"wb\" fi\r\nif not name.isstring or name=\"\" then return 0 fi\r\n\r\nreturn fopen(name,options)\r\nend\r\n\r\nglobal function closefile(file)=\t\t!CLOSEFILE\r\nreturn fclose(file)=0\r\nend\r\n\r\nglobal function checkfile(name)=\t\t!CHECKFILE\r\nfile:=fopen(name,\"rb\")\r\nif file=0 then return 0 fi\r\nfclose(file)\r\nreturn 1\r\nend\r\n\r\nglobal function eof(file)=\t\t!EOF\r\n!CPL =FILE\r\nc:=fgetc(file)\r\nif c=-1 then return 1 fi\r\n\r\nungetc(c,file)\r\nreturn 0\r\nend\r\n\r\nglobal function getfilesize(file)=\t\t!GETFILESIZE\r\np:=ftell(file)\t\t!p=current position\r\nfseek(file,0,2)\t\t!get eof position\r\nsize:=ftell(file)\t\t!size in bytes\r\nfseek(file,p,0)\t\t!restore file position\r\nreturn size\r\nend\r\n\r\nglobal function setfilepos(file,offset)=\t\t!SETFILEPOS\r\nreturn fseek(file,offset,0)\r\nend\r\n\r\nglobal function getfilepos(file)=\t\t!GETFILEPOS\r\nreturn ftell(file)\r\nend\r\n\r\nglobal function readrandom(file,mem,offset,size)=\t\t!READRANDOM\r\nfseek(file,offset,0)\r\nreturn fread(mem,1,size,file)\r\nend\r\n\r\nglobal function writerandom(file,mem,offset,size)=\t\t!WRITERANDOM\r\nfseek(file,offset,0)\r\nreturn fwrite(mem,1,size,file)\r\nend\r\n\r\nglobal function readbytes(file,mem,size)=\t\t!READBYTES\r\nreturn fread(mem,1,size,file)\r\nend\r\n\r\nglobal function writebytes(file,mem,size)=\t\t!WRITEBYTES\r\nreturn fwrite(mem,1,size,file)\r\nend\r\n\r\nglobal function inbyte(file)=\t\t!INBYTE\r\nreturn fgetc(file)\r\nend\r\n\r\nglobal function inword(file)=\t\t!INWORD\r\nbb:=fgetc(file)\r\nreturn fgetc(file)<<8+bb\r\nend\r\n\r\nglobal function inlong(file)=\t\t!INLONG\r\nww:=inword(file)\r\nreturn inword(file)<<16+ww\r\nend\r\n\r\nglobal proc outbyte(file,x)=\t\t!OUTBYTE\r\n!writerandom(file,&x,getfilepos(file),1)\r\nfputc(x,file)\r\nend\r\n\r\nglobal proc outword(file,x)=\t\t!OUTWORD\r\noutbyte(file,x iand 255)\r\noutbyte(file,x.[15..8])\r\nend\r\n\r\nglobal proc outlong(file,x)=\t\t!OUTLONG\r\noutword(file,x iand 65535)\r\noutword(file,x>>16)\r\nend\r\n\r\nglobal function instring(file)=\t\t!INSTRING\r\ns:=\"\"\r\ndo\r\n\tc:=inbyte(file)\r\n\tif c=0 then return s fi\r\n\ts+:=c\r\nod\r\nreturn s\r\nend\r\n\r\nglobal function appendfile(a,b)=\t\t!APPENDFILE\r\n!append line-based text file a to file b\r\n\r\nf:=openfile(a)\r\nif f=0 then return 0 fi\r\n\r\nh:=openfile(b,\"ab\")\r\nif h=0 then return 0 fi\r\n\r\nwhile not eof(f) do\r\n\treadln @f,x:\"l\"\r\n\tprintln @h,x\r\nod\r\n\r\nclosefile(f)\r\nclosefile(h)\r\nreturn 1\r\nend\r\n\r\nglobal function readblockfile(filename,doetx=0)=\t\t!READBLOCKFILE\r\n!read text file into a memory block\r\n!block is allocated here\r\n!return byte pointer to start of block, or nil\r\n!doetx=1 to add etx byte to end\r\n\r\nf:=openfile(filename)\r\nif f=0 then return 0 fi\r\n\r\nn:=getfilesize(f)\r\nreadfilesize:=n\r\n\r\ns:=malloc(n+doetx)\r\nif s=0 then abort(\"Readfile/Malloc fails\") fi\r\nsptr:=makeref(s,byte)\r\n\r\n!readrandom(f,&s,0,n)\r\nreadrandom(f,s,0,n)\r\n\r\nif doetx then\r\n\t(sptr+n)^:=26\r\nfi\r\n\r\nclosefile(f)\r\nreturn sptr\r\nend\r\n\r\nglobal function readstrfile(filename,doetx=0)=\t\t!READSTRFILE\r\n!read text file into a single string\r\n!return string, or 0 if there was an error\r\n\r\nf:=openfile(filename)\r\nif f=0 then return 0 fi\r\n\r\nn:=getfilesize(f)\r\nreadfilesize:=n\r\n\r\nptr:=malloc(n+1+doetx)\r\nif ptr=0 then abort(\"Readfile/Malloc fails\") fi\r\n\r\nreadrandom(f,ptr,0,n)\r\nif doetx then\r\n\t(makeref(ptr,byte)+n)^:=26\r\nfi\r\n\r\nclosefile(f)\r\ns::=makestr(ptr,n+doetx)\r\n\r\nfree(ptr)\r\nreturn s\r\nend\r\n\r\nglobal function writestrfile(filename,s)=\t\t!WRITESTRFILE\r\n!read text file from a single string\r\n!return status\r\n\r\nf:=createfile(filename)\r\nif f=0 then return 0 fi\r\n\r\nwriterandom(f,makeref(s,byte),0,s.len)\r\n\r\nreturn closefile(f)\r\nend\r\n\r\nglobal function readbinfile(filename)=\t\t!READBINFILE\r\n!read binary file into byte array\r\n!return () (empty list not array) on error\r\n\r\nf:=openfile(filename)\r\nif f=0 then return 0 fi\r\n\r\nn:=getfilesize(f)\r\nreadfilesize:=n\r\n\r\na:=new(array,byte,n)\r\nreadrandom(f,&a,0,n)\r\n\r\nclosefile(f)\r\nreturn a\r\nend\r\n\r\nglobal function writebinfile(filename,a)=\t\t!WRITEBINFILE\r\n!write binary file from byte array a\r\n!return status 1/0\r\n\r\nf:=createfile(filename)\r\nif f=0 then return 0 fi\r\n\r\nwriterandom(f,(&a),0,a.len)\r\n\r\nclosefile(f)\r\nreturn 1\r\nend\r\n\r\nglobal function writeblockfile(filename,p,length)=\r\n!return status 1/0\r\n\r\nf:=createfile(filename)\r\nif f=0 then return 0 fi\r\n\r\nwriterandom(f,p,0,length)\r\n\r\nclosefile(f)\r\nreturn 1\r\nend\r\n\r\nglobal function erasefile(filename)=\t\t!ERASEFILE\r\nreturn remove(filename)\r\nend\r\n\r\nglobal function renamefile(oldfilename,newfilename)=\t\t!RENAMEFILE\r\nreturn rename(oldfilename,newfilename)\r\nend\r\n\r\nglobal function readtextfile(file)=\r\n!read text file into a list of strings; one per line\r\n!return list, or 0 on error\r\nf:=openfile(file)\r\nif not f then\r\n\treturn 0 \r\nfi\r\n\r\nreadfilesize:=getfilesize(f)\r\na::=()\r\n\r\nwhile not eof(f) do\r\n\ta append:= sreadln(f)\r\nod\r\nclosefile(f)\r\nreturn a\r\nend\r\n\r\nglobal function writetextfile(file,a)=\t\t!WRITETEXTFILE\r\n!write list of strings <a> as a text file <file>\r\nf:=createfile(file)\r\nif not f then return 0 fi\r\n\r\nfor i:=a.lwb to a.upb do\r\n\tprintln @f,a[i]\r\nod\r\nclosefile(f)\r\nreturn 1\r\nend\r\n\r\nglobal function readbinaryfile(filename,t)=\t\t!READBINFILE\r\n!read binary file into byte array\r\n!return () (empty list not array) on error\r\n\r\n\tf:=openfile(filename)\r\n\tif f=0 then return () fi\r\n\r\n\tn:=getfilesize(f)\r\n\treadfilesize:=n\r\n\telems:=n%t.bytes\r\n\r\n\ta:=new(array,t,elems)\r\n\treadrandom(f,&a,0,n)\r\n\r\n\tclosefile(f)\r\n\treturn a\r\nend\r\n\r\nglobal proc writebinaryfile(filename,data)=\r\n\twriteblockfile(filename,&data,data.bytes)\r\nend\r\n\r\n",
    (uint8_t*)"importdll msvcrt=\r\n\tclang function\tmalloc\t\t(int32)intm\r\n\tclang function\trealloc\t\t(intm, int32)intm\r\n\tclang proc\t\tfree\t\t(intm)\r\n\tclang proc\t\tmemset\t\t(ref int32, int32, int32)\r\n\tclang proc\t\tmemcpy\t\t(ref int32, ref int32, int32)\r\n\tclang function\tclock\t\t:int32\r\n\tclang function\tftell\t\t(intm)int32\r\n\tclang function\tfseek\t\t(intm, int32, int32)int32\r\n\tclang function\tfread\t\t(ref int32, int32, int32, intm)int32\r\n\tclang function\tfwrite\t\t(ref int32, int32, int32, intm)int32\r\n\tclang function\tgetc\t\t(intm)int32\r\n\tclang function\tungetc\t\t(int32, intm)int32\r\n\tclang function\tfopen\t\t(string, string)intm\r\n\tclang function\tfclose\t\t(intm)int32\r\n\tclang function\tfgets\t\t(ref byte, int32, intm)ref byte\r\n\tclang function\tremove\t\t(string)int32\r\n\tclang function\trename\t\t(string, string)int32\r\n\tclang function\tgetchar\t\t:int32\r\n\tclang proc\t\tputchar\t\t(int32)\r\n\tclang proc\t\tsetbuf\t\t(intm, intm)\r\n\r\n\tclang function\trand\t\t:int32\r\n\tclang proc\t\tsrand\t\t(int32)\r\n\r\n\tclang function\tputs\t\t(string)int32\r\n\tclang function\tprintf\t\t(string, ...)int32\r\n\r\n\tclang function\tsprintf\t\t(string, string, ...)int32\r\n\r\n\tclang function\tsscanf\t\t(string, string, ...)int32\r\n\tclang function\tisalpha\t\t(int32)int32\r\n\tclang function\ttolower\t\t(int32)int32\r\n\tclang function\tstrlen\t\t(ref byte)int32\r\n\r\n!\tclang function\tsystem\t\t(string)int32\r\n\r\n\tclang function\tfgetc\t\t(intm)int32\r\n\tclang function\tfputc\t\t(int32,  intm)int32\r\n\tclang function\tfprintf\t\t(intm, string, ...)int32\r\n\tclang function\tfputs\t\t(string,  intm)int32\r\n\tclang function\tfeof\t\t(intm)int32\r\n\tclang function\tgetch\t\t:int32\r\n\r\n\tconst c_eof\t\t= -1\r\n\tconst seek_set\t= 0\r\n\tconst seek_curr\t= 1\r\n\tconst seek_end\t= 2\r\nend\r\n",
    \
(uint8_t*)"import sys\r\n\r\nimport oslibsw\r\n\r\nglobal var daynames=(\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\")\r\n\r\nglobal var Monthnames=(\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\r\n\t\t\"August\",\"September\",\"October\",\"November\",\"December\")\r\n\r\nglobal var days=(31,28,31, 30,31,30, 31,31,30, 31,30,31)\r\n\r\nglobal class rdate=\r\n\tvar day,month,year\r\nend\r\n\r\nglobal class rdatetime = \r\n\tvar\tday\r\n\tvar\tmonth\r\n\tvar\tyear\r\n\tvar\thour\r\n\tvar\tminute\r\n\tvar\tsecond\r\n\tvar\tmilliseconds\r\n\tvar\tdayofweek\r\nend\r\n\r\n!!Virtual keycodes\r\nglobal const vklbutton=1\t\t!note these are physical not logical buttons\r\nglobal const vkrbutton=2\r\nglobal const vkmbutton=4\t\t!middle button is correct\r\nglobal const vkbackspace=8\r\nglobal const vktab=9\r\nglobal const vkclear=12\r\nglobal const vkenter=13\r\nglobal const vkshift=16\r\nglobal const vkctrl=17\r\nglobal const vkalt=18\r\nglobal const vkbreak=19\r\nglobal const vkcapslock=20\r\n!global const vkrshift=21\r\nglobal const vkrctrl=22\r\n!global const vkralt=23\r\nglobal const vkinslock=24\r\nglobal const vkescape=27\r\nglobal const vkspace=32\r\nglobal const vkpageup=33\r\nglobal const vkpagedown=34\r\nglobal const vkend=35\r\nglobal const vkhome=36\r\nglobal const vkleft=37\r\nglobal const vkup=38\r\nglobal const vkright=39\r\nglobal const vkdown=40\r\nglobal const vkinsert=45\r\nglobal const vkdelete=46\r\nglobal const vkhelp=47\r\nglobal const vk0='0'\r\nglobal const vka='A'\r\nglobal const vkwindows=91\r\nglobal const vkrightbutton=93\r\nglobal const vknumpad0=96\t\t!96..105 = '0'..'9'\r\nglobal const vkmul=106\r\nglobal const vkadd=107\r\nglobal const vksub=109\r\nglobal const vkdecimal=110\r\nglobal const vkdiv=111\r\nglobal const vkf1=112\r\nglobal const vkf2=113\r\nglobal const vkf3=114\r\nglobal const vkf4=115\r\nglobal const vkf5=116\r\nglobal const vkf6=117\r\nglobal const vkf7=118\r\nglobal const vkf8=119\r\nglobal const vkf9=120\r\nglobal const vkf10=121\r\nglobal const vkf11=122\r\nglobal const vkf12=123\r\n!global const vklsq=128\r\n!global const vkrsq=129\r\n!global const vksemi=130\r\n!global const vkquote=131\r\n!global const vkstroke=132\r\n!global const vkdot=133\r\n!global const vkcomma=134\r\n!global const vkbackslash=135\r\n!global const vkquote2=136\r\n!global const vkequals=137\r\n!global const vkminus=138\r\n!global const vkhash=139\r\nglobal const vklshift=160\r\nglobal const vkrshift=161\r\nglobal const vklcontrol=162\r\nglobal const vkrcontrol=163\r\nglobal const vklalt=164\r\nglobal const vkralt=165\r\n\r\n!oem codes\r\nglobal const vkminus=189\r\nglobal const vkequals=187\r\nglobal const vklsq=219\r\nglobal const vkrsq=221\r\nglobal const vksemi=186\r\nglobal const vkquote=192\r\nglobal const vkhash=222\r\nglobal const vkcomma=188\r\nglobal const vkperiod=190\r\nglobal const vkslash=191\r\nglobal const vkbackslash=220\r\nglobal const vkbackquote=223\r\n\r\nglobal const con_black=0\r\nglobal const con_dkblue=1\r\nglobal const con_dkred=2\r\nglobal const con_dkmagenta=3\r\nglobal const con_dkgreen=4\r\nglobal const con_dkcyan=5\r\nglobal const con_dkyellow=6\r\nglobal const con_dkgrey=7\r\nglobal const con_grey=8\r\nglobal const con_blue=9\r\nglobal const con_red=10\r\nglobal const con_magenta=11\r\nglobal const con_green=12\r\nglobal const con_cyan=13\r\nglobal const con_yellow=14\r\nglobal const con_white=15\r\n\r\nproc start=\r\nend\r\n\r\nproc main=\r\nend\r\n\r\nglobal function makedatetime(d,m,y, h=0, minute=0, s=0)=\r\n\r\nd:=rdatetime(d,m,y, h,minute,s,0,0)\r\nd.dayofweek:=getdow(d)\r\nreturn d\r\nend\r\n\r\nglobal proc setdow(&d)=\r\nd.dayofweek:=getdow(d)\r\nend\r\n\r\nglobal function strdate(d,sep=\"-\")=\r\n!return leftstr(daynames[d.dayofweek],3)+\" \"+tostr(d.day)+sep+leftstr(monthnames[d.month],3)+sep+tostr(d.year)\r\nreturn tostr(d.day)+sep+leftstr(monthnames[d.month],3)+sep+tostr(d.year)\r\nend\r\n\r\nglobal function strtime(d,sep=\":\")=\r\nreturn tostr(d.hour)+sep+tostr(d.minute,\"z2\")+sep+tostr(d.second,\"z2\")\r\nend\r\n\r\nglobal function strdow(d,n=0)=\r\nif n then\r\n\treturn leftstr(daynames[d.dayofweek],n)\r\nelse\r\n\treturn daynames[d.dayofweek]\r\nfi\r\nend\r\n\r\nglobal function strdatetime(d,dsep=\"-\",tsep=\":\")=\r\nreturn strdate(d,dsep)+\" \"+strtime(d,tsep)\r\nend\r\n\r\nglobal function confirm(m,?caption,?default)=\t\t!CONFIRM\r\n!default=1/2/3 for yes/no/cancel button\r\n\r\nflags:=0x20000+0x20\t!foreground window/question mark icon\r\nflags ior:=3\t\t!yes/no/cancel\r\n\r\nif default.isvoid then default:=1 fi\r\nflags ior:=(default|0,0x100,0x200|0)\r\n\r\nstatus:=messagebox(0,m,(caption.defined|caption|\"Confirm\"),flags)\r\nreturn status=6\r\nend\r\n\r\nglobal function parsedate(s,defdate)=\r\n!parse string s into a new date record\r\n!def = default date to work from, eg. for missing year\r\n!return date record obtained, or 0 if error\r\n\r\nday:=defdate.day\r\nmonth:=defdate.month\r\nyear:=defdate.year\r\nif s.[1]=\" \" then s:=rightstr(s,-1) fi\r\n\r\nsepset:=[' ', '-', '/', '.']\r\n\r\nseppos:=0\r\nfor i:=1 to s.len do if s.[i] in sepset then seppos:=i; exit fi od\r\n\r\nif not seppos then\t\t!day only\r\n\tday:=strtoval(s)\r\n\tgoto gotday\r\nfi\r\nday:=strtoval(leftstr(s,seppos-1))\r\n\r\ns:=rightstr(s,-seppos)\t\t!month and possible year\r\nseppos:=0\r\nfor i:=1 to s.len do if s.[i] in sepset then seppos:=i; exit fi od\r\n\r\nif seppos then\r\n\tmonthstr:=leftstr(s,seppos-1)\r\n\tyearstr:=rightstr(s,s.len-seppos)\r\nelse\r\n\tmonthstr:=s\r\n\tyearstr:=\"\"\r\nfi\r\n\r\nif asc(leftstr(monthstr)) in ['0'..'9'] then\t!numeric month\r\n\tmonth:=strtoval(monthstr)\r\n\tif month<1 or month>12 then\r\n\t\treturn 0\r\n\tfi\r\nelse\r\n\tmonth:=0\r\n\tfor i:=1 to 12 do\r\n\t\tif convlc(leftstr(monthnames[i],3))=convlc(leftstr(monthstr,3)) then\r\n\t\t\tmonth:=i\r\n\t\t\texit\r\n\t\tfi\r\n\tod\r\n\tif not month then\r\n\t\treturn 0\r\n\tfi\r\nfi\r\n\r\nif yearstr<>\"\" then\r\n\tyear:=strtoval(yearstr)\r\n\tif year<200 then\r\n\t\tif year in [00..89] then\r\n\t\t\tyear+:=2000\r\n\t\telse\r\n\t\t\tyear+:=1900\r\n\t\tfi\r\n\tfi\r\nfi\r\n\r\ngotday:\r\n!check the date, rather than correct using addday(d,0)\r\ndd:=days[month] \r\nif leapyear(year) and month=2 then dd+:=1 fi\r\nif day<1 or day>dd then return 0 fi\r\nif year<1990 or year>2089 then return 0 fi\r\nreturn makedatetime(day,month,year)\r\nend\r\n\r\nglobal function leapyear(y)=\r\n!return true if y (eg. 1994) is a leap year\r\nreturn (y-1900) rem 4=0\r\nend\r\n\r\nglobal function getdow(d)=\r\n!return day of week for given date, returning 1..7 (monday..sunday)\r\nreturn ((getday(d)-1) rem 7)+1\r\nend\r\n\r\nglobal function getday(d)=\r\n!return day number for date d, measured from 1.1.90\r\nday:=0\r\nfor i:=1990 to d.year-1 do\r\n\tday+:=(leapyear(i)|366|365)\r\nod\r\n\r\nfor i:=1 to d.month-1 do\r\n\tday+:=(i=2|(leapyear(d.year)|29|28)|days[i])\r\nod\r\nday+:=d.day\r\nreturn day\r\nend\r\n\r\nglobal function getdays(m,y)=\r\n!return no. of days in month m, for year y\r\nif leapyear(y) and m=2 then return 29 fi\r\nreturn days[m]\r\nend\r\n\r\nglobal function getmonthname(m,?n)=\r\nif not m.isint then\r\n\tm:=m.month\r\nfi\r\nm:=monthnames[m]\r\nif n.defined then m:=leftstr(m,n) fi\r\nreturn m\r\nend\r\n\r\nglobal function getdayname(d,?n)=\r\nif not d.isint then\r\n\td:=getdow(d)\r\nfi\r\nd:=daynames[d]\r\nif n.defined then d:=leftstr(d,n) fi\r\nreturn d\r\nend\r\n\r\nglobal function addday(d0,i)=\r\nd:=d0\r\nif i>0 then\r\n\tto i do\r\n\t\t++d.day\r\n\t\tif d.day>getdays(d.month,d.year) then\r\n\t\t\td.day:=1\r\n\t\t\t++d.month\r\n\t\t\tif d.month>12 then\r\n\t\t\t\td.month:=1\r\n\t\t\t\t++d.year\r\n\t\t\tfi\r\n\t\tfi\r\n\tod\r\nelse\r\n\tto -i do\r\n\t\t--d.day\r\n\t\tif d.day<1 then\r\n\t\t\t--d.month\r\n\t\t\tif d.month<1 then\r\n\t\t\t\td.month:=12\r\n\t\t\t\t--d.year\r\n\t\t\tfi\r\n\t\t\td.day:=getdays(d.month,d.year)\r\n\t\tfi\r\n\tod\r\nfi\r\n\r\n!do checking\r\nif d.year<1990 then d:=makedatetime(1,1,1990) fi\r\nif d.year>2089 then d:=makedatetime(31,12,2089) fi\r\n\r\ndd:=getdays(d.month,d.year)\r\nif leapyear(d.year) and d.month=2 then dd+:=1 fi\r\nif d.day<1 then d.day:=1 fi\r\nif d.day>dd then d.day:=dd fi\r\nsetdow(d)\r\nreturn d\r\nend\r\n\r\nglobal function getdatetime=\r\ntm:=getsystime()\r\n\r\nreturn rdatetime(tm.day,tm.month,tm.year,\r\n\t\ttm.hour, tm.minute, tm.second, tm.milliseconds,tm.dayofweek)\r\nend\r\n\r\nglobal function messagebox(a,mess,caption,d)=\r\nreturn oslibsw.messagebox(a,mess,caption,d)\r\nend\r\n\r\nglobal function dirlist(s,?t)=\t\t!DIRLIST\r\nif t.isvoid then t:=1 fi\t\t\t!files only\r\nreturn oslibsw.dirlist(s,t)\r\nend\r\n\r\nglobal function setcurrdir(newdir)=\t\t!SETCURRDIR\r\nreturn oslibsw.setcurrdir(newdir)\r\nend\r\n\r\nglobal function getcurrdir=\t\t!GETCURRDIR\r\nreturn oslibsw.getcurrdir()\r\nend\r\n\r\nglobal function createdir(name)=\r\nreturn oslibsw.createdir(name)\r\nend\r\n\r\nglobal function direxists(path)=\r\nreturn oslibsw.direxists(path)\r\nend\r\n\r\nglobal function getsystime=\r\nreturn oslibsw.getsystime()\r\nend\r\n\r\nglobal proc beep1=\r\noslibsw.beep1()\r\nend\r\n",
    (uint8_t*)"!Interface module between oslib and winlib/linlib\r\n\r\nimport sys\r\nimport winlib\r\nimport linlib\r\n\r\n!var iswindows=leftstr(getos())=\"W\"\r\n!var iswindows=0\r\n\r\nglobal function messagebox(a,mess,caption,d)=\r\nif iswindows() then\r\n\treturn winlib.messagebox(a,mess,caption,d)\r\nelse\r\n\treturn linlib.messagebox(a,mess,caption,d)\r\nfi\r\nend\r\n\r\nglobal function dirlist(s,?t)=\t\t!DIRLIST\r\n!CPL \"DIRLISTSW\"\r\nif t.isvoid then t:=1 fi\t\t\t!files only\r\n\r\nif iswindows() then\r\n\treturn winlib.dirlist(s,t)\r\nelse\r\n\treturn linlib.dirlist(s,t)\r\nfi\r\nend\r\n\r\nglobal function setcurrdir(newdir)=\t\t!SETCURRDIR\r\nif iswindows() then\r\n\treturn winlib.setcurrdir(newdir)\r\nelse\r\n\treturn linlib.setcurrdir(newdir)\r\nfi\r\nend\r\n\r\nglobal function getcurrdir=\t\t!GETCURRDIR\r\nif iswindows() then\r\n\treturn winlib.getcurrdir()\r\nelse\r\n\treturn linlib.getcurrdir()\r\nfi\r\nend\r\n\r\nglobal function createdir(name)=\r\nif iswindows() then\r\n\treturn winlib.createdir(name)\r\nelse\r\n\treturn linlib.createdir(name)\r\nfi\r\nend\r\n\r\nglobal function direxists(path)=\r\nif iswindows() then\r\n\treturn winlib.direxists(path)\r\nelse\r\n\treturn linlib.direxists(path)\r\nfi\r\nend\r\n\r\nglobal function getsystime=\r\nif iswindows() then\r\n\treturn winlib.getsystime()\r\nelse\r\n\treturn linlib.getsystime()\r\nfi\r\nend\r\n\r\nglobal proc beep1=\r\nif iswindows() then\r\n\twinlib.beep1()\r\nelse\r\n\tlinlib.beep1()\r\nfi\r\nend\r\n",
    \
(uint8_t*)"!Miscellaneous functions for Windows\r\n!date/time handling, directory handling\r\n!Import indirectly via oslibsw\r\n\r\nimport sys\r\nimport winapi\r\n\r\nglobal function messagebox(a,mess,caption,d)=\r\nreturn messageboxa(a,mess,caption,d)\r\nend\r\n\r\nglobal function dirlist(s,t=1)=\t\t!DIRLIST\r\n!s is a global filename (eg. \"*.dwg\") with possible drive/path; scan\r\n!directory for all matching files and return as a list of names\r\n!also returns total no. of files so far\r\n!t= +1\tInclude normal files, no sub-directory names\r\n!t= +2  Include directories\r\n!t= +3  Include all files including directories\r\n!t= +4  Convert to lower case\r\n!t=  0  Defaults to +1\r\n\r\n!CPL \"DIRLIST/WINLIB\"\r\n\r\nif t.isvoid then t:=1 fi\t\t\t!files only\r\n\r\nnfiles:=0\r\ndata::=()\r\nfile:=new(ws_finddata)\r\n\r\nif (hfind:=findfirstfile(s,&file))<>-1 then\t!at least one file\r\n\trepeat\r\n\t\tif (file.fileattributes iand 16) then\t\t!this is a directory\r\n\t\t\tif (t iand 2)=0 then goto skip fi\t\t!no directories\r\n\t\telse\t\t\t\t\t\t!this is a file\r\n\t\t\tif (t iand 1)=0 then goto skip fi\r\n\t\tfi\r\n\t\t++nfiles\r\n\t\tif (t iand 4) then\t\t\t\t!to lower case\r\n\t\t\tdata[nfiles]:=convlc(file.filename)\r\n\t\telse\r\n\t\t\tdata[nfiles]::=file.filename\r\n\t\tfi\r\nskip:\r\n\tuntil not findnextfile(hfind,&file)\r\n\tfindclose(hfind)\r\nfi\r\nreturn data\r\nend\r\n\r\nglobal function setcurrdir(newdir)=\t\t!SETCURRDIR\r\nreturn setcurrentdirectory(newdir)\r\nend\r\n\r\nglobal function getcurrdir=\t\t!GETCURRDIR\r\na:=new(array,byte,256)\r\nn:=getcurrentdirectory(a.len,&a[1])\r\n\r\nif n then\r\n\tdir::=makestr(&a[1],n)\r\nelse\r\n\tdir:=\"\"\r\nfi\r\n\r\n!if not (rightstr(dir) in \"\\\\/\") then dir.iappend(\"\\\\\") fi\r\n!if not (rightstr(dir) in \"\\\\/\") then iappend(dir,\"\\\\\") fi\r\nif not (rightstr(dir) in \"\\\\/\") then dir +:= \"\\\\\" fi\r\nreturn dir\r\nend\r\n\r\nglobal function createdir(name)=\r\nreturn createdirectory(name,0)\r\nend\r\n\r\nglobal function direxists(path)=\r\nconst file_attribute_directory=16\r\nconst invalid_file_attributes=-1\r\n\r\nattrib := getfileattributesa(path)\r\n\r\nreturn attrib<>invalid_file_attributes and (attrib iand file_attribute_directory)\r\nend\r\n\r\nglobal function getsystime=\r\ntm:=new(ws_systemtime)\r\ngetsystemtime(&tm)\r\n\r\nif tm.dayofweek=0 then\r\n\ttm.dayofweek:=7\r\nfi\r\n\r\nreturn tm\r\nend\r\n\r\nglobal proc beep1=\r\n!beep(500,200)\r\nmessagebeep(0)\r\nend\r\n",
    \
(uint8_t*)"!Miscellaneous functions for Linux\r\n!date/time handling, directory handling\r\n!Import indirectly via oslibsw\r\n\r\nimport sys\r\nimport clib\r\n\r\nimportdll msvcrt=\r\n\tclang function \topendir(string)ref byte\r\n\tclang function \tclosedir(ref byte)ref byte\r\n\tclang function \tgetcwd(ref byte,int32)ref byte\r\n\tclang function \tchdir(string)int32\r\n\tclang function \tmkdir(string,int32)int32\r\n\tclang function \treaddir(ref byte)ref byte\r\n\tclang function \tfnmatch(string,string,int32)int32\r\nend\r\n\r\ntype dirent32 = struct\r\n\t[10]byte d32_filler\r\n\tbyte d_type\r\n\tstringz*256 d_name\r\nend\r\n\r\ntype dirent64 = struct\r\n\t[18]byte d64_filler\r\n\tbyte d_type\r\n\tstringz*256 d_name\r\nend\r\n\r\nglobal function messagebox(a,mess,caption,d)=\r\nRETURN PCERROR(\"LINUX MESSAGEBOX\")\r\nend\r\n\r\nglobal function dirlist(filespec,?t)=\r\nif t.isvoid then t:=1 fi\t\t\t!files only\r\n\r\n!CPL \"DIRLIST1\"\r\n\r\npath:=extractpath(filespec)\r\nfilepattern:=extractfile(filespec)\r\n!CPL \"DIRLIST2\",path\r\n\r\nif path=\"\" then path:=\".\" fi\r\n!CPL \"DIRLIST3\",path\r\n\r\nd:=opendir(path)\r\n!CPL \"DIRLIST4\",path\r\nif not d then\r\n\treturn ()\r\nfi\r\n\r\nnfiles:=0\r\ndata:=()\r\n!CPL \"OPENED DIR\",gethostsize()\r\n\r\nwhile dir:=readdir(d) do\r\n\tif gethostsize()=32 then\r\n\t\tdir:=makeref(dir,dirent32)\r\n\telse\r\n\t\tdir:=makeref(dir,dirent64)\r\n\tfi\r\n\tif dir^.d_type=4 then\t\t!DIR\r\n\telsif fnmatch(filepattern,dir^.d_name,16)=0 then\r\n!CPL \"GOT FILE\",dir^.d_name\r\n\t\t++nfiles\r\n\t\tif (t iand 4) then\t\t\t\t!to lower case\r\n\t\t\tdata[nfiles]:=convlc(dir^.d_name)\r\n\t\telse\r\n\t\t\tdata[nfiles]::=dir^.d_name\r\n\t\tfi\r\n\tfi\r\nod\r\n\r\nclosedir(d)\r\n\r\nreturn data\r\nend\r\n\r\nglobal function setcurrdir(newdir)=\t\t!SETCURRDIR\r\nreturn chdir(newdir)<>0\r\nend\r\n\r\nglobal function getcurrdir=\t\t!GETCURRDIR\r\na:=new(array,byte,256)\r\np:=&a[1]\r\n\r\ns:=getcwd(p,a.len)\r\n\r\nif s then\r\n\tdir::=makestr(&a[1],strlen(p))\r\nelse\r\n\tdir:=\"\"\r\nfi\r\n\r\nif rightstr(dir)<>\"/\" then dir +:= \"/\" fi\r\nreturn dir\r\nend\r\n\r\nglobal function createdir(name)=\r\nreturn system(\"mkdir \"+name)=0\r\nend\r\n\r\nglobal function direxists(path)=\r\nd:=opendir(path)\r\nif d then\r\n\tclosedir(d)\r\n\treturn 1\r\nfi\r\nreturn 0\r\nend\r\n\r\nglobal function getsystime=\r\nRETURN PCERROR(\"LINUX GETSYSTIME\")\r\nend\r\n\r\nglobal proc beep1=\r\nPCERROR(\"LINUX BEEP1\")\r\nend\r\n",
    \
(uint8_t*)"import sys\r\nimport oslib\r\nimport consolesw\r\n\r\nVAR CCC=0\r\n\r\nglobal record winrec =\r\n\tvar posx,posy\r\n\tvar cols,rows\r\n\tvar fgnd,bgnd\t\t\t!default text/background colour\r\n\r\n\tvar columns\t\t\t!used when divided into columns\r\n\tvar itemcols\t\t\t!width of each column\r\n\tvar pagesize\t\t\t!columns*rows\r\n\r\n\tvar name\r\n\r\n\tvar hdata\t\t\t!pointer to data record, or is nil\r\nend\r\n\r\nglobal var wscreen\r\nglobal var screencols,screenrows\r\n\r\nglobal var chardata\t\t\t!string these two represent row of the console\r\nglobal var attrdata\t\t\t!string\r\n\r\nglobal var defscreenfgnd=con_black\r\nglobal var defscreenbgnd=con_grey\r\nglobal var rlkey=0\t\t!set by readline, when special key has been input\r\nglobal var rlbuffer\t\t\t!contents of readline buffer when special key pressed\r\n\r\nvar cmdindex,ncmds\r\nvar cmdhistory\r\n\r\nglobal const capsmask  = 0x8\t\t!shift states as they are in .keyshift\r\nglobal const altmask   = 0x4\r\nglobal const ctrlmask  = 0x2\r\nglobal const shiftmask = 0x1\r\n\r\nglobal const capsbit=3\r\nglobal const altbit=2\r\nglobal const ctrlbit=1\r\nglobal const shiftbit=0\r\n\r\nPROC START=\r\nCPL \"YYYCONSOLE START INIT\",=ISWINDOWS()\r\n!; WAITKEY()\r\ninit()\r\ninitcmds()\r\nEND\r\n\r\nPROC MAIN=\r\nCPL \"CONSOLE INIT\"; WAITKEY()\r\ninit()\r\n\r\ninitcmds()\r\n!for i:=0 to 15 do\r\n!\tsetcolour(i,15)\r\n!\tsetpos(1,i+1)\r\n!\tCPL i,\"hello\"\r\n!od\r\n!\r\n!waitkey()\r\n\r\nEND\r\n\r\nproc keyscreentest=\r\n(cols,rows):=(screencols, screenrows)\r\n!CPL =COLS,=ROWS\r\n\r\nrow:=rows%2\r\ncol:=cols%2\r\nch:=\"X\"\r\n\r\nsetcolour(6,1)\r\n\r\ndo\r\n\tsetpos(col,row)\r\n\tcp ch\r\n\tsetpos(col,row)\r\n\tk:=getkey().keycode\r\n\tcase k\r\n\twhen 27 then\r\n\t\texit\r\n\twhen vkleft then col:=max(1,col-1)\r\n\twhen vkright then col:=min(cols,col+1)\r\n\twhen vkup then row:=max(1,row-1)\r\n\twhen vkdown then row:=min(rows,row+1)\r\n\tesac\r\nod\r\n\r\n!waitkey()\r\n\r\nend\r\n\r\nglobal proc setpos(col,row)=\r\nconsolesw.setpos(col,row)\r\nend\r\n\r\nglobal function getpos=\r\nreturn consolesw.getpos()\r\nend\r\n\r\nglobal function getdims=\r\nreturn (screencols,screenrows)\r\nend\r\n\r\nglobal proc init(cols=100)=\r\n\r\n!CPL \"CONSOLE INIT\",=COLS; WAITKEY()\r\n\r\nconsolesw.init(cols)\r\ncmdhistory::=()\t!\"one\",\"two\",\"three\",\"four\")\r\nncmds:=cmdhistory.upb\r\ncmdindex:=0\r\n\r\nscreencols:=consolesw.wscreencols\r\nscreenrows:=consolesw.wscreenrows\r\n\r\n!CPL =WINCON.WSCREENCOLS\r\n!CPL =CONSOLESW.WSCREENCOLS\r\n!CPL =SCREENCOLS,=screenrows\r\n!WAITKEY()\r\n!\r\n\r\nwscreen:=makewin((1,1),(screencols,screenrows),defscreencolour)\r\n\r\nchardata:=\" \"*screencols\r\nattrdata:=chr(0xf0)*screencols\r\nend\r\n\r\nglobal proc setcolour(fgnd,bgnd)=\r\n!call with as (fgnd,bgnd) or as (fgnd..bgnd)\r\nconsolesw.setcolour(fgnd,bgnd)\r\nend\r\n\r\nglobal proc settitle(caption)=\r\nconsolesw.settitle(caption)\r\nend\r\n\r\nglobal function getkey=\r\n!calls icongetkey but doesn't return shift keys as discrete key presses\r\nreturn consolesw.getkey()\r\nend\r\n\r\nglobal function keyready=\r\nreturn consolesw.keyready()\r\nend\r\n\r\nglobal proc flushkbd=\r\nconsolesw.flushkeyboard()\r\nend\r\n\r\nglobal function readline(?cmdline,donewline=1)=\r\n!this function doesn't handle tabs properly\r\n!would need to maintain 2 buffers, one with tabs translated to spaces\r\n!or convert tabs to another char which is translated back to tabs on exit\r\n!return with input buffer set to the line, but also returns the complete line\r\n!newline=1 to end with a newline, 0 to leave it\r\n\r\n!readln\r\n!return\r\n\r\nbuffer:=\"\"\r\nnchars:=0\r\n!congetpos()\r\n\r\n!NOTE: getpos is dodgy using TERMCON; MAY NEED CALLER TO SPECIFY START POINT\r\n(startx,starty):=(getpos())\r\n\r\npos:=0\t\t!with nchars shown, pos can be 0 to nchars\r\n\r\nreenter:\r\nif cmdline.defined and cmdline<>\"\" then\r\n\tbuffer:=cmdline\r\nreenter2:\r\n\tpos:=nchars:=buffer.len\r\nfi\r\n\r\ndo\r\n! print \"_\"\r\n\trlkey:=0\t\t\t!normal input starts with \"*\" will expect rlkey to be a keyrec\r\n\tsetpos(startx,starty)\r\n\tprint buffer\r\n\tsetpos(startx+pos,starty)\r\n\r\n\tkey:=getkey()\r\n\tkeycode:=key.keycode\r\n\tkeyshift:=key.shift\r\n\r\n\tcase keycode\r\n\twhen vkpageup,vkpagedown,vkup,vkdown,vkinsert,vkf1..vkf12 then\r\n\r\ndospecial:\r\n\trlbuffer:=buffer\r\n\t\toldbufferlen:=buffer.len\t\t!to help erase old buffer\r\n\t\tbuffer:=getkeyname(key)\r\n\t\trlkey:=key\t\t\t\t!allow caller to use key code rather than name\r\n\t\texit\r\n\r\n\twhen vkleft then\r\n\t\tif buffer=\"\" then goto dospecial fi\r\n\t\tif (keyshift iand 7) then goto dospecial fi\r\n\r\n\t\tif pos>0 then\r\n\t\t\t--pos\r\n\t\tfi\r\n\r\n\twhen vkhome then\r\n\t\tif buffer=\"\" then goto dospecial fi\r\n\t\tif (keyshift iand 7) then goto dospecial fi\r\n\t\tpos:=0\r\n\r\n\twhen vkend then\r\n\t\tif buffer=\"\" then goto dospecial fi\r\n\t\tif (keyshift iand 7) then goto dospecial fi\r\n\t\tpos:=nchars\r\n\r\n\twhen vkright then\r\n\t\tif buffer=\"\" then goto dospecial fi\r\n\t\tif (keyshift iand 7) then goto dospecial fi\r\n\t\tif pos<nchars then\r\n\t\t\t++pos\r\n\t\tfi\r\n\r\n\twhen vkenter then\r\n\r\n!  println\r\n\t\texit\r\n\r\n\twhen vkbackspace then\r\n\r\n\t\tif (keyshift iand 7) then goto dospecial fi\r\n\t\tif nchars then\r\n\t\t\tsetpos(startx,starty)\r\n\t\t\tprint \" \"*buffer.len\r\n\r\n\t\t\tcase pos\r\n\t\t\twhen 0 then\t\t\t!not allowed\r\n\t\t\twhen nchars then\t\t!at end\r\n\t\t\t\tbuffer:=leftstr(buffer,-1)\r\n\t\t\t\t--nchars\r\n\t\t\t\t--pos\r\n\t\t\telse\t\t\t\t!in middle\r\n\t\t\t\tbuffer:=leftstr(buffer,pos-1)+rightstr(buffer,-(pos))\r\n\t\t\t\t--nchars\r\n\t\t\t\t--pos\r\n\t\t\tesac\r\n\r\n\t\tfi\r\n\r\n\twhen vkdelete then\r\n\t\tif (keyshift iand 7) then goto dospecial fi\r\n\t\tif nchars and nchars=pos then\r\n\t\t\tgoto delline\r\n\t\tfi\r\n\t\tif nchars=0 then\r\n\t\t\tgoto dospecial\r\n\t\tfi\r\n\t\tif nchars then\r\n!CPL \"\\NNCHARS\",=NCHARS,++CCC,=POS,\"\\N\"\r\n\t\t\tsetpos(startx,starty)\r\n\t\t\tprint \" \"*buffer.len\r\n\r\n\t\t\tcase pos\r\n\t\t\twhen nchars then\t\t!not allowed\r\n!\t\t\twhen 0 then\t\t\t!at start\r\n!\t\t\t\tbuffer:=leftstr(buffer,-1)\r\n!\t\t\t\t--nchars\r\n\t\t\telse\t\t\t\t!in middle\r\n\t\t\t\tbuffer:=leftstr(buffer,pos)+rightstr(buffer,-(pos+1))\r\n\t\t\t\t--nchars\r\n!    --pos\r\n\t\t\tesac\r\n\r\n\t\tfi\r\n\r\n\twhen vkescape then\r\n\t\tif nchars=0 then\r\n\t\t\tgoto dospecial\r\n!   oldbufferlen:=buffer.len\r\n!   buffer:=\"*esc\"\r\n!   exit\r\n\t\tfi\r\ndelline:\r\n\t\tsetpos(startx,starty)\r\n\t\tprint \" \"*buffer.len\r\n\r\n\t\tbuffer:=\"\"\r\n\t\tnchars:=pos:=0\r\n\r\n\twhen vktab then\r\n\t\tgoto normalkey\r\n\r\n\telse\r\nnormalkey:\r\n\t\tif (key.charcode>=' ' or key.charcode=9) then\r\n\t\t\tif pos=0 then\r\n\t\t\t\tbuffer:=chr(key.charcode)+buffer\r\n\t\t\telsif pos=nchars then\r\n\t\t\t\tbuffer:=buffer+chr(key.charcode)\r\n\t\t\telse\r\n\t\t\t\tbuffer:=leftstr(buffer,pos)+chr(key.charcode)+rightstr(buffer,-(pos))\r\n\t\t\tfi\r\n\t\t\t++nchars\r\n\t\t\t++pos\r\n\t\telse\r\n\t\t\tGOTO DOSPECIAL\r\n\t\t\tprint \"<\",keycode,key.charcode,\">\"\r\n\t\tfi\r\n\r\n\tesac\r\nod\r\n\r\ncase buffer\r\nwhen \"*cup\",\"*cdown\" then\r\n\tif ncmds then\r\n\t\tsetpos(startx,starty)\r\n\t\tprint \" \"*oldbufferlen\r\n\r\n\t\tif cmdindex=0 then\t\t!get started on last\r\n\t\t\tcmdline:=cmdhistory[ncmds]\r\n\t\t\tcmdindex:=ncmds\r\n\t\t\tgoto reenter\r\n\t\tfi\r\n\r\n\t\tif buffer=\"*cup\" and cmdindex>1 then\r\n\t\t\t--cmdindex\r\n\t\telsif buffer=\"*cdown\" and cmdindex<ncmds then\r\n\t\t\t++cmdindex\r\n\t\tfi\r\n\t\tcmdline:=cmdhistory[cmdindex]\r\n\t\tgoto reenter\r\n\tfi\r\n\tbuffer:=\"\"\r\n\tgoto reenter2\r\nesac\r\n\r\nif buffer.len>1 and leftstr(buffer)<>\"*\" then\r\n\tif ncmds=0 or cmdhistory[ncmds]<>buffer then\r\n\t\tcmdhistory[++ncmds]:=buffer\r\n\tfi\r\n\tcmdindex:=0\r\nfi\r\n\r\nif donewline then println fi\r\n\r\nreturn sreadln(buffer)\r\nend\r\n\r\nglobal proc showtext(s,?x,?y)=\r\n\r\nif x.defined then\r\n\tconsolesw.setpos(x,y)\r\nfi\r\ncount:=0\r\nif s then\r\n\tconsolesw.showtext(s)\r\nfi\r\nend\r\n\r\nglobal proc setdims(cols,rows)=\r\n!set new size for console, by reinitialising\r\nconsolesw.setdims(cols,rows)\r\nend\r\n\r\nglobal function setcursor(?visible)=\r\nreturn consolesw.setcursor(visible)\r\nend\r\n\r\nproc initcmds=\r\ncmdhistory::=()\r\nncmds:=cmdhistory.upb\r\ncmdindex:=0\r\nend\r\n\r\nglobal proc clearscreen(?bgnd,?fgnd)=\r\n\r\nif bgnd.isvoid then bgnd:=defscreenbgnd fi\r\nif fgnd.isvoid then fgnd:=defscreenfgnd fi\r\nsetcolour(fgnd,bgnd)\r\n\r\nfor i:=1 to screenrows do\r\n\tconsolesw.setpos(1,i)\r\n\tconsolesw.showtext(\" \"*screencols)\r\nod\r\nsetpos(1,1)\r\nend\r\n\r\nglobal proc clearwin(w)=\r\n!clear region used by listbox\r\n!can clear multi-columns at once\r\nspaces:=\" \"*w.cols\r\n\r\nsetcolour(w.fgnd,w.bgnd)\r\nfor i:=1 to w.rows do\r\n\tshowtext(spaces,w.posx,w.posy+i-1)\r\nod\r\nsetpos(w.posx,w.posy)\r\nend\r\n\r\nglobal function getkeyname(key)=\r\ncase key.keycode\r\nwhen vkleft then name:=\"left\"\r\nwhen vkright then name:=\"right\"\r\nwhen vkup then name:=\"up\"\r\nwhen vkdown then name:=\"down\"\r\nwhen vkpageup then name:=\"pageup\"\r\nwhen vkpagedown then name:=\"pagedown\"\r\nwhen vkhome then name:=\"home\"\r\nwhen vkend then name:=\"end\"\r\nwhen vkinsert then name:=\"insert\"\r\nwhen vkdelete then name:=\"delete\"\r\nwhen vktab then name:=\"tab\"\r\nwhen vkescape then name:=\"escape\"\r\nwhen vkbackspace then name:=\"backspace\"\r\nwhen vkenter then name:=\"enter\"\r\nwhen vkf1..vkf12 then name:=\"f\"+tostr(key.keycode-vkf1+1)\r\nwhen vkspace then name:=\"space\"\r\nelse\r\n\tif key.charcode in [1..26] then\t!ctrl code\r\n\t\tname:=chr(key.charcode+'a'-1)\r\n\telsif key.charcode in ['!','\"','','$','%','^','&','*','(',')','-','_','+','=','[',']',\r\n\t'{','}',':',';','\\'','@','~','#','<','>',',','.','/','','','|','\\\\','?'] then\r\n\t\tname:=chr(key.charcode)\r\n\t\tkey.shift iand:=inot shiftmask\t\t!ignore any shift press needed to get char\r\n\r\n\telsif key.keycode in ['A'..'Z','0'..'9'] then\r\n\t\tif (key.shift iand (ctrlmask ior altmask))=0 then\r\n\t\t\tname:=chr(key.charcode)\r\n\t\t\tkey.shift iand:=inot shiftmask\r\n\t\telse\r\n\t\t\tname:=convlc(chr(key.keycode))\r\n\t\tfi\r\n\telsif key.keycode in (186..223) then\r\n\t\tcase key.keycode\r\n\t\twhen vkminus then name:=\"-\"\r\n\t\twhen vkequals then name:=\"=\"\r\n\t\twhen vklsq then name:=\"[\"\r\n\t\twhen vkrsq then name:=\"]\"\r\n\t\twhen vksemi then name:=\";\"\r\n\t\twhen vkquote then name:=\"'\"\r\n\t\twhen vkhash then name:=\"#\"\r\n\t\twhen vkcomma then name:=\",\"\r\n\t\twhen vkperiod then name:=\".\"\r\n\t\twhen vkslash then name:=\"/\"\r\n\t\twhen vkbackslash then name:=\"\\\\\"\r\n\t\twhen vkbackquote then name:=\"`\"\r\n\t\telse\r\n\t\t\treturn \"?\"\r\n\t\tesac\r\n\telse\r\n\t\treturn \"?\"\r\n\tfi\r\nesac\r\n\r\nprefix:=\"*\"\r\nif key.shift iand shiftmask then prefix+:=\"s\" fi\r\nif key.shift iand ctrlmask then prefix+:=\"c\" fi\r\nif key.shift iand altmask then prefix+:=\"a\" fi\r\nreturn prefix+name\r\n\r\nend\r\n\r\nglobal function keynametokey(name)=\r\n!given a key name in the format \"*...\", reconstruct an rkey record, and return that\r\ncharcode:=shift:=keycode:=0\r\n\r\nname:=rightstr(name,-1)\t\t!get rid of \"*\"\r\n\r\nif name.len=1 then\t\t!simple printable key, no shifts\r\n\tcharcode:=asc(name)\r\n\tgoto simplekey\r\n\r\nelse\t\t\t\t!any letters s,c,a on left indicate a modifier\r\n\twhile name.len>1 do\r\n\t\tcase leftstr(name)\r\n\t\twhen \"s\" then\r\n\t\t\tshift ior:=shiftmask\r\n\t\t\tname:=rightstr(name,-1)\r\n\t\twhen \"c\" then\r\n\t\t\tshift ior:=ctrlmask\r\n\t\t\tname:=rightstr(name,-1)\r\n\t\twhen \"a\" then\r\n\t\t\tshift ior:=altmask\r\n\t\t\tname:=rightstr(name,-1)\r\n\t\telse\r\n\t\t\texit\r\n\t\tesac\r\n\tod\r\n\r\n\tcase name\r\n\twhen \"left\" then keycode:=vkleft\r\n\twhen \"right\" then keycode:=vkright\r\n\twhen \"up\" then keycode:=vkup\r\n\twhen \"down\" then keycode:=vkdown\r\n\twhen \"pageup\" then keycode:=vkpageup\r\n\twhen \"pagedown\" then keycode:=vkpagedown\r\n\twhen \"home\" then keycode:=vkhome\r\n\twhen \"end\" then keycode:=vkend\r\n\twhen \"insert\" then keycode:=vkinsert\r\n\twhen \"delete\" then keycode:=vkdelete\r\n\twhen \"tab\" then keycode:=charcode:=vktab\r\n\twhen \"escape\" then keycode:=vkescape\r\n\twhen \"backspace\" then keycode:=charcode:=vkbackspace\r\n\twhen \"enter\" then keycode:=charcode:=vkenter\r\n\twhen \"space\" then keycode:=charcode:=vkspace\r\n\telse\r\n\t\tif name.len>=2 and leftstr(name)=\"f\" then\t!function key\r\n\t\t\tkeycode:=vkf1+strtoval(rightstr(name,-1))-1\r\n\t\telsif name.len=1 then\t\t\t\t!ordinary key, but with shifts\r\nsimplekey:\r\n\t\t\tc:=asc(name)\r\n\t\t\tcase c\r\n\t\t\twhen ['A'..'Z'] then\r\n\t\t\t\tkeycode:=c\r\n\t\t\twhen ['a'..'z'] then\r\n\t\t\t\tkeycode:=c-' '\r\n\t\t\twhen ['0'..'9'] then\r\n\t\t\t\tkeycode:=c\r\n\t\t\twhen '-','_' then keycode:=vkminus\r\n\t\t\twhen '=','+' then keycode:=vkequals\r\n\t\t\twhen '[','{' then keycode:=vklsq\r\n\t\t\twhen ']','}' then keycode:=vkrsq\r\n\t\t\twhen ';',':' then keycode:=vksemi\r\n\t\t\twhen '\\'','@' then keycode:=vkquote\r\n\t\t\twhen ',','<' then keycode:=vkcomma\r\n\t\t\twhen '.','>' then keycode:=vkperiod\r\n\t\t\twhen '/','?' then keycode:=vkslash\r\n\t\t\twhen '\\\\','|' then keycode:=vkbackslash\r\n\t\t\twhen '`','' then keycode:=vkbackquote\r\n\t\t\twhen '#','~' then keycode:=vkhash\r\n\t\t\twhen '!' then keycode:='1'\r\n\t\t\twhen '\"' then keycode:='2'\r\n\t\t\twhen '' then keycode:='3'\r\n\t\t\twhen '$' then keycode:='4'\r\n\t\t\twhen '%' then keycode:='5'\r\n\t\t\twhen '^' then keycode:='6'\r\n\t\t\twhen '&' then keycode:='7'\r\n\t\t\twhen '*' then keycode:='8'\r\n\t\t\twhen '(' then keycode:='9'\r\n\t\t\twhen ')' then keycode:='0'\r\n\t\t\telse\r\n\t\t\t\tpcerror(\"keynametokey\")\r\n\t\t\tend\r\n\t\tfi\r\n\tesac\r\nfi\r\n\r\nif shift iand (altmask ior ctrlmask) then\r\n\tcharcode:=0\r\n\tif keycode in 'A'..'Z' then\r\n\t\tcharcode:=keycode-'@'\r\n\tfi\r\nfi\r\n\r\nkey:=new(rkey)\t\t\t!convert to proper keyrec\r\nkey.charcode:=charcode\r\nkey.shift:=shift\r\nkey.keycode:=keycode\r\nreturn key\r\nend\r\n\r\nglobal function makewin(pos, dims, ?fgnd,?bgnd,name=\"Anon\")=\r\n!global function makewin(pos, dims, ?colour)=\r\n\r\nw:=new(winrec)\r\nw.posx:=pos[1]\r\nw.posy:=pos[2]\r\nw.cols:=dims[1]\r\nw.rows:=dims[2]\r\nw.columns:=1\r\nif dims.len>=3 then\r\n\tw.columns:=dims[3]\r\nfi\r\n\r\n!CPL =POS,=DIMS,=W.COLUMNS\r\n\r\nw.itemcols:=w.cols%w.columns\r\nw.pagesize:=w.rows*w.columns\r\nw.hdata:=nil\r\n\r\nw.fgnd:=fgnd\r\nw.bgnd:=bgnd\r\nw.name:=name\r\n\r\nreturn w\r\nend\r\n\r\nglobal proc wsetpos(w,col,row)=\r\nsetpos(w.posx+col-1,w.posy+row-1)\r\nend\r\n\r\nglobal proc wshowtext(w,s,?col,?row)=\r\nif col.defined then\r\n\tshowtext(s,w.posx+col-1,w.posy+row-1)\r\nelse\r\n\tshowtext(s)\r\nfi\r\nend\r\n\r\nglobal function wgetpos(w)=\r\npos:=consolesw.getpos()\r\nreturn (w.posx+pos.lwb-1)..(w.posy+pos.upb-1)\r\nend\r\n\r\nglobal proc wsetcolour(w,?fgnd,?bgnd)=\r\nif fgnd.defined then\r\n\tsetcolour(fgnd,bgnd)\r\nelse\r\n\tsetcolour(w.fgnd,w.bgnd)\r\nfi\r\nend\r\n\r\nglobal proc wsetcolumns(w,columns)=\r\nw.columns:=columns\r\nw.itemcols:=w.cols%w.columns\r\nw.pagesize:=w.rows*w.columns\r\nend\r\n\r\nglobal proc wshowtext_b(w,s,col,fgnd,bgnd)=\r\n!version of wshowtext that dumps into char/attr buffer.\r\n!w is used for absolute column number\r\n\r\nlength:=s.len\r\noffset:=w.posx-1\t!hoz offset\r\n\r\nchardata.[(col+offset)..(col-1+length+offset)]:=s\r\n\r\n!attr:=consolesw.colourmap[bgnd]<<4+consolesw.colourmap[fgnd]\r\nattr:=bgnd<<4+fgnd\r\n\r\nattrdata.[(col+offset)..(col-1+length+offset)]:=chr(attr)*length\r\nend\r\n\r\nglobal proc updateconsolerow(row)=\r\n!write out latest contents to chardata/attrdata to console\r\n!this represents an entire composite wlineno+wvgap+wedit row, for given row within wedit\r\n!etc\r\nconsolesw.w_writeconsolerow(chardata,attrdata,screencols,row)\r\nend\r\n\r\nglobal function setclipboard(s)=\r\nreturn consolesw.setclipboard(s)\r\nend\r\n\r\nglobal function getclipboard=\r\nreturn consolesw.getclipboard()\r\nend\r\n",
    \
(uint8_t*)"import sys\r\n\r\nimport wincon\r\nimport lincon\r\n\r\n!global var hconsole, hconsolein\r\nglobal var wscreencols,wscreenrows\r\n!global var currbgnd=-1,currfgnd=-1\r\n!!console attribute colours (x16 for background)\r\n\r\n!global var screencolour=con_dkred..con_grey\r\n\r\nglobal var colourmap\r\n\r\nvar iswin=iswindows()\r\n\r\nproc start=\r\n!CPL \"CONSOLESW\",=iswin\r\n\r\nif iswin then\r\n!\tcolourmap:=wincon.colourmap\r\n\twscreencols:=wincon.wscreencols\r\n\twscreenrows:=wincon.wscreenrows\r\nelse\r\n!\tcolourmap:=lincon.colourmap\r\n\twscreencols:=lincon.wscreencols\r\n\twscreenrows:=lincon.wscreenrows\r\nfi\r\nend\r\n\r\nglobal proc init(?cols)=\r\n!CPL \"CONSOLESW\",=ISWIN\r\n\r\nif iswin then\r\n\twincon.init(cols)\r\nelse\r\n\tlincon.init(cols)\r\nfi\r\nif iswin then\r\n!\tcolourmap:=wincon.colourmap\r\n\twscreencols:=wincon.wscreencols\r\n\twscreenrows:=wincon.wscreenrows\r\nelse\r\n!\tcolourmap:=lincon.colourmap\r\n\twscreencols:=lincon.wscreencols\r\n\twscreenrows:=lincon.wscreenrows\r\nfi\r\nend\r\n\r\nglobal proc setpos(col,row)=\r\nif iswin then\r\n\twincon.setpos(col,row)\r\nelse\r\n\tlincon.setpos(col,row)\r\nfi\r\nend\r\n\r\nglobal function getpos=\r\nif iswin then\r\n\treturn wincon.getpos()\r\nelse\r\n\treturn lincon.getpos()\r\nfi\r\nend\r\n\r\nglobal function setcursor(?visible)=\r\nif iswin then\r\n\treturn wincon.setcursor(visible)\r\nelse\r\n\treturn lincon.setcursor(visible)\r\nfi\r\nend\r\n\r\nglobal proc setcolour(fgnd,bgnd)=\r\nif iswin then\r\n\twincon.setcolour(fgnd,bgnd)\r\nelse\r\n\tlincon.setcolour(fgnd,bgnd)\r\nfi\r\nend\r\n\r\nglobal proc settitle(caption)=\r\nif iswin then\r\n\twincon.settitle(caption)\r\nelse\r\n\tlincon.settitle(caption)\r\nfi\r\nend\r\n\r\n!global function getkeychar=\r\n!!wait for any key, return single char code; as returned by C's getch()\r\n!return waitkey()\r\n!end\r\n\r\nglobal function getkey2=\r\nreturn PCERROR(\"SW/GETKEY2\")\r\nend\r\n\r\nglobal function getkey=\r\nif iswin then\r\n\treturn wincon.getkey()\r\nelse\r\n\treturn lincon.getkey()\r\nfi\r\nend\r\n\r\nglobal function keyready=\r\nif iswin then\r\n\treturn wincon.keyready()\r\nelse\r\n\treturn lincon.keyready()\r\nfi\r\nend\r\n\r\nglobal proc showtext(s)=\r\nif iswin then\r\n\twincon.showtext(s)\r\nelse\r\n\tlincon.showtext(s)\r\nfi\r\nend\r\n\r\nglobal proc setdims(cols,rows)=\r\nPCERROR(\"SW/SETDIMS\")\r\nend\r\n\r\nglobal proc setpalette(index,colour)=\r\nif iswin then\r\n\twincon.setpalette(index,colour)\r\nelse\r\n\tlincon.setpalette(index,colour)\r\nfi\r\nend\r\n\r\nglobal proc writepalette=\r\npcerror(\"SW/WRITEPALETTE\")\r\nend\r\n\r\nglobal proc flushkeyboard=\r\nif iswin then\r\n\twincon.flushkeyboard()\r\nelse\r\n\tlincon.flushkeyboard()\r\nfi\r\nend\r\n\r\nglobal proc w_writeconsolerow(text, attributes, length, row)=\r\nif iswin then\r\n\twincon.w_writeconsolerow(text,attributes,length,row)\r\nelse\r\n\tlincon.w_writeconsolerow(text,attributes,length,row)\r\nfi\r\nend\r\n\r\nglobal function setclipboard(s)=\r\nif iswin then\r\n\treturn wincon.setclipboard(s)\r\nelse\r\n\treturn lincon.setclipboard(s)\r\nfi\r\nend\r\n\r\nglobal function getclipboard=\r\nif iswin then\r\n\treturn wincon.getclipboard()\r\nelse\r\n\treturn lincon.getclipboard()\r\nfi\r\nend\r\n",
    \
(uint8_t*)"import sys\r\nimport oslib\r\n!import condata\r\n!import newconsole\r\n\r\nvar digits=['0'..'9']\r\nvar navkeys=['A':vkup, 'B':vkdown, 'C': vkright, 'D':vkleft, 'H':vkhome, 'F':vkend,\r\n\t\t\t\t'P':vkf1, 'Q':vkf2, 'R': vkf3, 'S':vkf4]\r\n\r\nvar fnkeys= [15:vkf5, 17:vkf6, 18:vkf7, 19:vkf8, 20:vkf9, 21:vkf10, 23:vkf11, 24:vkf12]\r\n\r\nconst capsmask  = 0x8\t\t!shift states as they are in .keyshift\r\nconst altmask   = 0x4\r\nconst ctrlmask  = 0x2\r\nconst shiftmask = 0x1\r\n\r\nconst capsbit=3\r\nconst altbit=2\r\nconst ctrlbit=1\r\nconst shiftbit=0\r\n\r\nvar shiftcodes = [5:ctrlmask, 2:shiftmask, 3:altmask, 4:shiftmask+altmask, 7:ctrlmask+altmask]\r\n\r\n!global var screenwin\r\nglobal var wscreencols,wscreenrows\r\nglobal var currbgnd=-1,currfgnd=-1\r\n\r\n!global var screencolour=con_dkred..con_grey\r\nglobal var colourmap\r\nvar colourxref\r\n\r\nglobal proc init(cols=100)=\r\n!static var setdimdone=0\r\n\r\n!hconsole:=getstdhandle(-11)\r\n!hconsolein:=getstdhandle(-10)\r\n!lastkey:=new(ws_keyevent)\r\n!lastkey.repeatcount:=0\r\n!pendkey:=new(ws_keyevent)\r\n\r\n!setdims(cols,60)\r\n\r\n!CPL \"LINCON INIT\"\r\n!CPL\r\n!CPL\r\n!STOP\r\ngetdims()\r\n\r\ncolourmap:=(@0: \\\r\n\t0,\t!black\tdk versions\r\n\t1,\t!blue\r\n\t4,\t!red\r\n\t5,\t!magenta\r\n\t2,\t!green\r\n\t3,\t!cyan\r\n\t6,\t!yellow\r\n\t7,\t!green\r\n\r\n\t8,\t!dkgrey\r\n\t9,\t!blue\tbright versions\r\n\t12,\r\n\t13,\r\n\t10,\r\n\t11,\r\n\t14,\r\n\t15)\r\n\r\ncolourxref:=(0:\\\t\t!windows colour numbers to linux (or nearest equiv)\r\n\t0,\r\n\t4,\r\n\t1,\r\n\t5,\r\n\t2,\r\n\t14,\r\n\t3,\r\n\t7,\r\n\t8,\r\n\t12,\r\n\t9,\r\n\t13,\r\n\t10,\r\n\t14,\r\n\t5,\r\n\t15)\r\n\r\n\r\n\r\n\r\n!colourpalette:=new(ws_palette16)\r\n!\r\n!setstdpalette()\r\nend\r\n\r\nproc getdims=\r\n(wscreencols,wscreenrows):=getscreensize()\r\n\r\n!CPL \"LINUX/GETDIMS\",WSCREENCOLS,WSCREENROWS\r\n\r\nend\r\n\r\nglobal proc setpos(column,row)=\r\nfprint \"\\s[#;#H\",row,column\r\nend\r\n\r\nproc setfgndcol(colour)=\r\nfprint \"\\s[#m\",colour+30\r\nend\r\n\r\nproc setbgndcol(colour)=\r\nfprint \"\\s[#m\",colour+40\r\nend\r\n\r\nglobal proc setbold(bold)=\r\nfprint \"\\s[#m\",(bold|1|21)\r\nend\r\n\r\nglobal proc setitalic(italic)=\r\nfprint \"\\s[#m\",(italic|3|23)\r\nend\r\n\r\nglobal function getpos=\r\nprint \"\\s[6n\"\r\nreadkey()\t\t!escape\r\nreadkey()\t\t![\r\n\r\n(row,column,c):=readkbdsequence()\r\nreturn (column,row)\r\nend\r\n\r\nglobal function setcursor(?visible)=\r\nreturn 1\r\nend\r\n\r\nglobal proc setcolour(fgnd,bgnd)=\r\n!call with as (fgnd,bgnd) or as (fgnd..bgnd)\r\n\r\nif fgnd=currfgnd and bgnd=currbgnd then\r\n\treturn\r\nfi\r\n\r\ncurrfgnd:=fgnd\r\ncurrbgnd:=bgnd\r\n\r\nfgnd:=colourxref[fgnd]\r\nbgnd:=colourxref[bgnd]\r\n\r\nsetbold(fgnd>7)\r\nsetfgndcol(fgnd iand 7)\r\nsetbgndcol(bgnd iand 7)\r\nend\r\n\r\nglobal proc settitle(caption)=\r\nend\r\n\r\nglobal function keyready=\r\nreturn pcerror(\"Linux/keyready\")\r\nend\r\n\r\nglobal proc showtext(s)=\r\nif s then\r\n\tprint s\r\nfi\r\nend\r\n\r\nglobal proc setdims(cols,rows)=\r\npcerror(\"linux/setdims\")\r\nend\r\n\r\nglobal proc setpalette(index,colour)=\r\npcerror(\"linux/setpallete\")\r\nend\r\n\r\nfunction getscreensize=\r\nsavepos()\r\nsetpos(999,999)\r\n(cols,rows):=getpos()\r\n!CPL \"GETSCREENSIZE\",COLS,ROWS\r\n\r\nrestorepos()\r\nreturn (cols,rows)\r\nend\r\n\r\nproc savepos=\r\nprint \"\\s[s\"\r\nend\r\n\r\nproc restorepos=\r\nprint \"\\s[u\"\r\nend\r\n\r\nfunction readkey=\r\nreturn waitkey()\r\nend\r\n\r\nfunction readintseq(c)=\r\n!c is '0' to '9'\r\n!read integer sequence up to first non-digit\r\n!return (number, terminator character)\r\nx:=c-'0'\r\ndo\r\n\tc:=readkey()\r\n\tif c in digits then\r\n\t\tx:=x*10+c-'0'\r\n\telse\r\n\t\texit\r\n\tfi\r\nod\r\nreturn (x,c)\r\nend\r\n\r\nfunction readkbdsequence=\r\n!Some key escape sequences for control chars in Linux look like this:\r\n! <esc> \"[\" [x[\";\"y] c/\"~\"\r\n!Parts in \"...\" are actual characters\r\n!x and y are optional integers, c is a capital letter\r\n!The sequence may have 0, 1 or 2 numbers (separated with ;) and end with\r\n!a capital letter, or \"~\"\r\n!the \"[\" has already been read\r\n!return (X, Y, C)\r\n!X or Y will be zero if not present. C will 'A' etc, or 0 if it ends with \"~\"\r\n!-1 is returned on error\r\n\r\nx:=y:=0\r\n\r\nc:=readkey()\r\n\r\nif c in digits then\r\n\t(x,c):=readintseq(c)\r\n\tif c=';' then\r\n\t\tc:=readkey()\r\n\t\tif c not in digits then return -1 fi\r\n\r\n\t\t(y,c):=readintseq(c)\r\n\tfi\r\nfi\r\n\r\nif c='~' then\r\n\treturn (x,y,0)\r\nfi\r\nreturn (x,y,c)\t\t\t\t!assume A-Z\r\nend\r\n\r\n!function keyname(k,shift=0)=\r\n!return getkeyname(rkey(0,k,shift))\r\n!end\r\n\r\nglobal function getkey=\r\n!read key events via readkey()\r\n!convert escape sequences to Windows virtual keys\r\n\r\nk:=readkey()\t\t\t\t!LINUX ONLY\r\n\r\ncase k\r\nwhen 10 then\r\n\treturn rkey(13,vkenter,0)\r\nwhen 8,127 then\r\n\treturn rkey(127,vkbackspace,0)\r\nwhen 9 then\r\nCPL \"TAB1\"\r\n\treturn rkey(vktab,vktab,0)\r\nwhen 'A'..'Z','0'..'9' then\r\n\treturn rkey(k,k,0)\r\nwhen 'a'..'z' then\r\n\treturn rkey(k,k-' ',0)\r\nwhen 27 then\r\nwhen 1..31 then\r\n\treturn rkey(k,0,ctrlmask)\r\nelse\r\n\tc:=k\r\n\tcase k\r\n\twhen '[','{' then k:=vklsq\r\n\twhen ']','}' then k:=vkrsq\r\n\telse\r\n\t\tk:=0\r\n\tesac\r\n\r\n\treturn rkey(c,k,0)\r\nesac\r\n\r\n!CPL \"ESC SEEN\"\r\n\r\n!escape seen; look at next key\r\nk:=readkey()\r\n\r\ncase k\r\nwhen 27 then\t\t\t!esc/esc => single escape\r\n\treturn rkey(0,k,0)\r\n\r\nwhen 10 then\t\t\t!esc/10 => alt enter\r\n\treturn rkey(0,vkenter,altmask)\r\n\r\nwhen 8,127 then\t\t\t!esc/bs => alt bs\r\n\treturn rkey(0,vkbackspace,altmask)\r\n\r\nwhen 'O' then\t\t\t!short set of function keys\r\n\t(x,y,c):=readkbdsequence()\r\n\r\nCPL \"O\",x,y,chr(c)\r\n\treturn rkey(0,navkeys{c},shiftcodes{y,0})\r\n\r\nwhen '[' then\r\n\t(x,y,c):=readkbdsequence()\r\n\tcase c\r\n\twhen 'Z' then\t\t\t\t\t\t!shift+tab\r\n\t\treturn rkey(9,9,shiftmask)\r\n!\t\treturn rkey(0,9,shiftmask)\r\n\twhen 'A','B','C','D','H','F','P','Q','R','S' then\t\t!cursor keys, fn1..4; assume x=1\r\n\t\treturn rkey(0,navkeys{c},shiftcodes{y,0})\r\n\tesac\r\n\r\n\tcase x\r\n\twhen 2,3,5,6 then\r\n\t\tshift:=0\r\n\t\tcase y\r\n\t\twhen 5 then shift:=ctrlmask\r\n\t\twhen 3 then shift:=altmask\r\n\t\twhen 7 then shift:=altmask+ctrlmask\r\n\t\tesac\r\n\t\treturn rkey(0,(x|0,vkinsert,vkdelete,0,vkpageup|vkpagedown),shift)\r\n\twhen 15..24 then\r\n\t\treturn rkey(0,fnkeys{x},shiftcodes{y,0})\r\n\tesac\r\n\r\nwhen 'A'..'Z' then\t\t\t!must have been alt version (some esc letter codes above)\r\n\treturn rkey(k-64,0,altmask) \r\n\r\nwhen 'a'..'z' then\t\t\t!must have been alt version (some esc letter codes above)\r\n\treturn rkey(k-96,0,altmask) \r\n\r\nwhen '0'..'9' then\r\n\treturn rkey(0,k,altmask) \r\n\r\nesac\r\nCPL \"ESC 91\"\r\n\r\n!Code 91 SEEN\r\nreturn rkey(0,'?',0)\r\nend\r\n\r\nproc screentest=\r\n\r\nsavepos()\r\nsetpos(10,10)\r\nsetfgndcol(5)\r\nsetbgndcol(3)\r\nsetbold(1)\r\nsetitalic(1)\r\nprintln \"\tHELLO\t\"\r\nsetbold(0)\r\nsetitalic(0)\r\nrestorepos()\r\nprintln \"\tGoodbye\t\"\r\n\r\n(cols,rows):=getscreensize()\r\ncpl =rows,=cols\r\nwaitkey()\r\nend\r\n\r\n!proc keytest=\r\n!\r\n!lastkey:=0\r\n!\r\n!!do\r\n!!\tk:=readkey()\r\n!!\tif k=27 and lastkey=27 then exit fi\r\n!!\tif k=27 then\r\n!!\t\tcpl\r\n!!\t\tcp \"ESC \"\r\n!!\telsif k in 32..126 then\r\n!!\t\tcp chr(k)\r\n!!\telse\r\n!!\t\tcp \"<\"+tostr(k)+\">\"\r\n!!\tfi\r\n!!\tlastkey:=k\r\n!!od\r\n!\r\n!do\r\n!\tk:=getkey()\r\n!\tcpl getkeyname(k),k\r\n!\tif k.keycode=27 then exit fi\r\n!od\r\n!\r\n!end\r\n\r\nproc keyscreentest=\r\n(cols,rows):=getscreensize()\r\nCPL =COLS,=ROWS\r\n\r\nrow:=rows%2\r\ncol:=cols%2\r\nch:=\"X\"\r\n\r\nsetfgndcol(6)\r\nsetbgndcol(1)\r\n\r\ndo\r\n\tsetpos(col,row)\r\n\tcp ch\r\n\tsetpos(col,row)\r\n\tk:=getkey().keycode\r\n\tcase k\r\n\twhen 27 then\r\n\t\texit\r\n\twhen vkleft then col:=max(1,col-1)\r\n\twhen vkright then col:=min(cols,col+1)\r\n\twhen vkup then row:=max(1,row-1)\r\n\twhen vkdown then row:=min(rows,row+1)\r\n\tesac\r\nod\r\n\r\n!waitkey()\r\n\r\nend\r\n\r\nproc main=\r\n\r\n!keytest()\r\n!screentest()\r\nkeyscreentest()\r\nend\r\n\r\nproc start=\r\n!CPL \"LINCON START\"\r\n!if not iswindows() then\r\n!\tinit()\r\n!fi\r\nend\r\n\r\nglobal proc w_writeconsolerow(text, attributes, length, row)=\r\n!pcerror(\"lincon/writeconsolerow\")\r\n!buffersize:=1<<16+length\r\n!coord:=0\r\n\r\n!setpos(1,row)\r\n!print leftstr(text,length)\r\n\r\nsetpos(1,row)\r\nfor i:=1 to length-1 do\r\n\tattrs:=attributes.[i]\r\n\tc:=text.[i]\r\n!\tsetcolour(attrs>>4, attrs iand 15)\r\n\tsetcolour(attrs iand 15, attrs>>4)\r\n\tprint chr(c)\r\nod\r\nreturn\r\n\r\nend\r\n\r\nglobal proc flushkeyboard=\r\n!pcerror(\"lincon/flushkeyboard\")\r\nend\r\n\r\nglobal function setclipboard(s)=\r\nabort(\"linux/setclipboard\")\r\nreturn 0\r\nend\r\n\r\nglobal function getclipboard=\r\nabort(\"linux/getclipboard\")\r\nreturn \"\"\r\nend\r\n\r\n",
    \
(uint8_t*)"global type wt_word\t\t= word16\r\nglobal type wt_bool\t\t= word32\r\nglobal type wt_dword\t= word32\r\nglobal type wt_wchar\t= word16\r\nglobal type wt_char\t\t= byte\r\nglobal type wt_ichar\t= string\r\nglobal type wt_string\t= string\r\nglobal type wt_ptr\t\t= ref byte\r\nglobal type wt_wndproc\t= wordm\r\n\r\nglobal type wt_handle\t= refm\r\nglobal type wt_int\t\t= int32\r\nglobal type wt_uint\t\t= word32\r\nglobal type wt_long\t\t= int32\r\nglobal type wt_wparam\t= wordm\r\nglobal type wt_lparam\t= wordm\r\nglobal type wt_size\t\t= wordm\r\n\r\nglobal type wt_wparam32\t= word32\r\nglobal type wt_lparam32\t= word32\r\nglobal type wt_handle32\t= word32\r\nglobal type wt_ptr32\t= word32\r\nglobal type wt_string32\t= word32\r\nglobal type wt_wndproc32\t= word32\r\n\r\nglobal type wt_wparam64\t= word64\r\nglobal type wt_lparam64\t= word64\r\nglobal type wt_handle64\t= word64\r\nglobal type wt_ptr64\t= word64\r\nglobal type wt_string64\t= word64\r\nglobal type wt_wndproc64= word64\r\n\r\nglobal type wt_result\t= wordm\r\nglobal type wt_intptr\t= wordm\r\nglobal type wt_coord\t= word32\r\n\r\nglobal type ws_spoint= struct\r\n\tint16 x,y\r\nend\r\n\r\nglobal type ws_srect=struct\t\t!rect record occupying 8 bytes\r\n\tint16 leftx,top, rightx,bottom\r\nend\r\n\r\nglobal type ws_charinfo=struct\r\n\tunion\r\n\t\twt_word\tunicodechar\r\n\t\twt_char\tasciichar\r\n\tend union\r\n\twt_word\t\tattributes\r\nend\r\n\r\nglobal type ws_palette16=[0..15]int32\r\n\r\nglobal type ws_console=struct\r\n\tws_spoint size,pos\r\n\twt_word attributes\r\n\tws_srect window\r\n\tws_spoint maxwindowsize\r\nend\r\n\r\nglobal type ws_consoleex=struct\r\n\tint32 recsize\r\n\tws_spoint size,pos\r\n\twt_word attributes\r\n\tws_srect window\r\n\tws_spoint maxwindowsize\r\n\twt_word wpopup\r\n\tint32 fullscreen\r\n\tws_palette16 palette\r\nend\r\n\r\nglobal type ws_keyevent = struct\r\n\twt_word\teventtype\r\n\t\twt_bool\tkeydown\t\t\t@@4\t!key event record (was inside 'Event' union in win32)\r\n\t\twt_word\trepeatcount\r\n\t\twt_word\tvirtualkeycode\r\n\t\twt_word\tvirtualscancode\r\n\t\tunion\r\n\t\t\twt_word unicodechar\r\n\t\t\twt_char asciichar\r\n\t\tend\r\n\t\twt_dword controlkeystate\r\nend\r\n\r\nglobal type ws_cursor=struct(int32 size,visible)\r\n\r\nglobal var hconsole, hconsolein\r\n\r\nglobal const stdoutputhandle=0xffff_fff5i\r\nglobal const stdinputhandle=0xfffffff6i\r\nglobal const stderrorputhandle=0xfffffff4i\r\nglobal const invalidhandlevalue=0xffffffffi\r\n\r\nglobal const maxpathlen=260\r\n\r\ntype spath=stringz*maxpathlen\r\ntype sshort=stringz*14\r\n!\r\nglobal type ws_filetime=struct\r\n\tint32 ftlow\r\n\tint32 fthigh\r\nend\r\n\r\nglobal type ws_finddata=struct\r\n\tint32\t\tfileattributes\r\n\tws_filetime\tcreationtime\r\n\tws_filetime\tlastaccesstime\r\n\tws_filetime\tlastwritetime\r\n\tint32\t\tfilesizehigh\r\n\tint32\t\tfilesizelow\r\n\tint32\t\treserved0\r\n\tint32\t\treserved1\r\n\tspath\t\tfilename\r\n\tsshort\t\tshortfilename\r\nend\r\n\r\nglobal type ws_systemtime = struct\r\n\tword16\tyear\r\n\tword16\tmonth\r\n\tword16\tdayofweek\r\n\tword16\tday\r\n\tword16\thour\r\n\tword16\tminute\r\n\tword16\tsecond\r\n\tword16\tmilliseconds\r\nend\r\n\r\nglobal type ws_msg32 = struct\r\n\tint32\thwnd\r\n\tint32\tmessage\r\n\tint32\twparam\r\n\tint32\tlparam\r\n\tint32\ttime\r\n\tint32\tptx\r\n\tint32\tpty\r\nend\r\n\r\nglobal type ws_msg64 = struct@@8\r\n\tint64\thwnd\r\n\tint32\tmessage\r\n\tint64\twparam@@0\r\n\tint64\tlparam\r\n\tint32\ttime\r\n\tint32\tptx\t@@8\r\n\tint32\tpty\r\nend\r\n\r\nglobal type ws_point = struct\r\n\tint32 x, y\r\nend\r\n\r\nglobal type ws_rect=struct\t\t!rect record occupying 16 bytes\r\n\tint32 leftx,top, rightx,bottom\r\n\tint32\tx@leftx\r\n\tint32\ty@top\r\n\tint32\tx2@rightx\r\n\tint32\ty2@bottom\r\n\tint32\tx1@leftx\r\n\tint32\ty1@top\r\nend\r\n\r\nglobal type ws_logbrush = struct\r\n\tint32 lbstyle\r\n\tint32 lbcolour\r\n\tint32 lbhatch\r\nend\r\n\r\nglobal type ws_textmetrics = struct\r\n\tint32\theight\r\n\tint32\tascent\r\n\tint32\tdescent\r\n\tint32\tint32ernalleading\r\n\tint32\texternalleading\r\n\tint32\tavecharwidth\r\n\tint32\tmaxcharwidth\r\n\tint32\tweight\r\n\tint32\toverhang\r\n\tint32\tdigitizedaspectx\r\n\tint32\tdigitizedaspecty\r\n\tbyte\tfirstchar\r\n\tbyte\tlastchar\r\n\tbyte\tdefaultchar\r\n\tbyte\tbreakchar\r\n\tbyte\titalic\r\n\tbyte\tunderlined\r\n\tbyte\tstruckout\r\n\tbyte\tpitchandfamily\r\n\tbyte\tcharset\r\nend\r\n!=========================================\r\n\r\nglobal type ws_bitmapv5header = struct\r\n\tint32\tsize\r\n\tint32\twidth\r\n\tint32\theight\r\n\tword16\tplanes\r\n\tword16\tbitcount\r\n\tint32\tcompression\r\n\tint32\tsizeimage\r\n\tint32\txpelspermeter\r\n\tint32\typelspermeter\r\n\tint32\tclrused\r\n\tint32\tclrimportant\r\n\tint32\tredmask\r\n\tint32\tgreenmask\r\n\tint32\tbluemask\r\n\tint32\talphamask\r\n\tint32\tcstype\r\n\t[1..9]int32 endpoints\r\n\tint32\tredgamma\r\n\tint32\tgreengamma\r\n\tint32\tbluegamma\r\n\tint32\tintent\r\n\tint32\tprofiledata\r\n\tint32\tprofilesize\r\n\tint32\treserved\r\nend\r\n\r\nglobal type ws_bitmapfileheader = struct\r\n\twt_word\t\ttypex\r\n\twt_dword\tsize\r\n\twt_word\t\tres1, res2\r\n\twt_dword\toffbits\r\nend\r\n\r\nglobal type ws_bitmapinfoheader = struct\r\n\twt_dword \tsize\r\n\twt_long\t\twidth\r\n\twt_long\t\theight\r\n\twt_word\t\tplanes\r\n\twt_word\t\tbitcount\r\n\twt_dword\tcompression\r\n\twt_dword\tsizeimage\r\n\twt_long\t\txpelspermetre\r\n\twt_long\t\typelspermetre\r\n\twt_dword\tclrused\r\n\twt_dword\tclrimportant\r\nend\r\n\r\nglobal type ws_paintstruct = struct\r\n!\tintm\t\thdc\r\n\tint64\t\thdc\r\n\tint32\t\terase\r\n\tws_rect\t\tpaintrect\r\n\tint32\t\trestore\r\n\tint32\t\tincupdate\r\n\t[32]byte\trgbreserved\r\nend\r\n\r\n!32-BIT VERSION\r\nglobal type ws_openfilename32 = struct\r\n\twt_dword\t\tstructsize\r\n\twt_handle32\t\towner\r\n\twt_handle32\t\tinstance\r\n\twt_string32\t\tfilter\r\n\twt_string32\t\tcustomfilter\r\n\twt_dword\t\tmaxcustfilter\r\n\twt_dword\t\tfilterindex\r\n\twt_string32\t\tfile\r\n\twt_dword\t\tmaxfile\r\n\twt_string32\t\tfiletitle\r\n\twt_dword\t\tmaxfiletitle\r\n\twt_string32\t\tinitialdir\r\n\twt_string32\t\ttitle\r\n\twt_dword\t\tflags\r\n\twt_word\t\t\tfileoffset\r\n\twt_word\t\t\tfileextension\r\n\twt_string32\t\tdefext\r\n\twt_lparam32\t\tcustdata\r\n\twt_wndproc32\thook\r\n\twt_string32\t\ttemplatename\r\n\twt_ptr32\t\treserved1\r\n\twt_dword\t\treserved2\r\n\twt_dword\t\tflagsex\r\nend\r\n\r\n!64-BIT VERSION\r\nglobal type ws_openfilename64 = struct @@8\r\n\twt_dword\t\tstructsize\r\n\twt_handle64\t\towner@@0\r\n\twt_handle64\t\tinstance\r\n\twt_string64\t\tfilter\r\n\twt_string64\t\tcustomfilter\r\n\twt_dword\t\tmaxcustfilter\r\n\twt_dword\t\tfilterindex\r\n\twt_string64\t\tfile@@0\r\n\twt_dword\t\tmaxfile\r\n\twt_string64\t\tfiletitle@@0\r\n\twt_dword\t\tmaxfiletitle\r\n\twt_string64\t\tinitialdir@@0\r\n\twt_string64\t\ttitle\r\n\twt_dword\t\tflags\r\n\twt_word\t\t\tfileoffset\r\n\twt_word\t\t\tfileextension\r\n\twt_string64\t\tdefext@@0\r\n\twt_lparam64\t\tcustdata\r\n\twt_wndproc64\thook\r\n\twt_string64\t\ttemplatename\r\n\twt_ptr64\t\treserved1\r\n\twt_dword\t\treserved2\r\n\twt_dword\t\tflagsex\r\nend\r\n\r\n!export\r\nimportdll kernel32=\r\n\twindows function\t\"GetLastError\"\t\t\t\t\t:wt_dword\r\n\twindows function\t\"GetStdHandle\"\t\t\t\t\t(wt_dword)wt_handle\r\n\twindows function\t\"WriteConsoleA\" as writeconsole\t\t\t\t(wt_handle,wt_ptr,wt_dword,wt_ptr,wt_ptr)wt_bool\r\n\twindows function\t\"SetConsoleCursorPosition\"\t\t(wt_handle,wt_coord)wt_bool\r\n\twindows function\t\"GetConsoleScreenBufferInfo\"\t(wt_handle,wt_ptr)wt_bool\r\n\twindows function\t\"SetConsoleMode\"\t\t\t\t(wt_handle,wt_dword)wt_bool\r\n\twindows function\t\"WriteConsoleOutputA\" as writeconsoleoutput\t\t\t(wt_handle,wt_ptr,wt_coord,wt_coord,wt_ptr)wt_bool\r\n\r\n\twindows function\t\"GetConsoleScreenBufferInfoEx\"\t(wt_handle,wt_ptr)wt_bool\r\n\twindows function\t\"SetConsoleScreenBufferInfoEx\"\t(wt_handle,wt_ptr)wt_bool\r\n\r\n\twindows function\t\"SetConsoleTextAttribute\"\t\t(wt_handle,wt_word)wt_bool\r\n\twindows function\t\"SetConsoleTitleA\" as setconsoletitle\t\t\t\t(wt_string)wt_bool\r\n\twindows function\t\"ReadConsoleInputA\" as readconsoleinput\t\t\t(wt_handle,wt_ptr,wt_dword,wt_ptr)wt_bool\r\n\twindows function\t\"PeekConsoleInputA\"\t\t\t(wt_handle,wt_ptr,wt_dword,wt_ptr)wt_bool\r\n\twindows function\t\"FlushConsoleInputBuffer\"\t\t(wt_handle)wt_bool\r\n\twindows function\t\"SetConsoleWindowInfo\"\t\t\t(wt_handle,wt_bool,wt_ptr)wt_bool\r\n\twindows function\t\"SetConsoleScreenBufferSize\"\t(wt_handle,wt_coord)wt_bool\r\n\twindows function\t\"GetConsoleCursorInfo\"\t\t\t(wt_handle,wt_ptr)wt_bool\r\n\twindows function\t\"SetConsoleCursorInfo\"\t\t\t(wt_handle,wt_ptr)wt_bool\r\n\twindows function\t\"GetNumberOfConsoleInputEvents\"(wt_handle,wt_ptr)wt_bool\r\n\twindows function    \t\"GetConsoleWindow\":wt_handle\r\n\r\n!\tdefine writeconsole=writeconsolea\r\n!\tdefine setconsoletitle=setconsoletitlea\r\n!\tdefine readconsoleinput=readconsoleinputa\r\n!\tdefine peekconsoleinput=peekconsoleinputa\r\n!\r\n\twindows function\t\"FindFirstFileA\" as findfirstfile\t\t(string,ref int32)int32\r\n\twindows function\t\"FindNextFileA\"  as findnextfile\t\t\t(int32,ref int32)int32\r\n\twindows function\t\"FindClose\"\t\t\t\t\t(int32)int32\r\n\twindows function\t\"SetCurrentDirectoryA\" as setcurrentdirectory\t(string)int32\r\n\twindows function\t\"GetCurrentDirectoryA\" as getcurrentdirectory\t(int32,int32)int32\r\n\twindows function\t\"CreateDirectoryA\" as createdirectory\t\t(string,int32)int32\r\n\twindows function\t\"GetFileAttributesA\"\t\t\t(string)int32\r\n\twindows function\t\"GetModuleHandleA\" as getmodulehandle\t\t(wt_string)wt_handle\r\n\twindows function\t\"GetTickCount\"\t\t\t\t\t\t\t\t:wt_dword\r\n\twindows function\t\"GlobalAlloc\"\t\t\t\t\t\t\t\t\t(wt_uint,wt_size)wt_handle\r\n\twindows function\t\"GlobalLock\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_ptr\r\n\twindows function\t\"GlobalUnlock\"\t\t\t\t\t\t\t\t(wt_handle)wt_bool\r\n\twindows function\t\"GlobalSize\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_size\r\n\r\n\twindows function\t\"GetSystemTime\"(ref byte)int32\r\n\twindows function\t\"Beep\"\t\t\t\t\t\t\t(wt_dword, wt_dword)wt_bool\r\n\twindows function\t\"SetConsoleCP\"\t\t\t\t\t\t\t\t(wt_uint)wt_bool\r\nend\r\n\r\nimportdll user32=\r\n\twindows function\t\"CreateWindowExA\" as createwindowex\t\t(wt_dword, wt_string, wt_string, wt_dword, wt_int,wt_int,wt_int,wt_int,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t wt_handle, wt_handle, wt_handle, wt_ptr)wt_handle\r\n\r\n\twindows function\t\"GetMessageA\" as getmessage\t\t\t\t(wt_ptr, wt_handle, wt_uint, wt_uint)wt_bool\r\n\twindows function\t\"TranslateMessage\"\t\t\t\t\t\t(wt_ptr)wt_bool\r\n\twindows function\t\"DispatchMessageA\" as dispatchmessage\t\t(wt_ptr)wt_result\r\n\twindows function\t\"SetTimer\"\t\t\t\t\t\t\t\t(wt_handle,wt_intptr,wt_uint,wt_ptr)wt_intptr\r\n\twindows function\t\"KillTimer\"\t\t\t\t\t\t\t\t(wt_handle,wt_intptr)wt_bool\r\n\twindows function\t\"SystemParametersInfoA\"\t\t\t\t\t(wt_uint,wt_uint,wt_ptr,wt_uint)wt_bool\r\n\twindows function\t\"GetSystemMetrics\"\t\t\t\t\t\t(wt_int)wt_int\r\n!\twindows function\t\"CreateMenu\"\t\t\t\t\t\t\t\t:int\r\n\twindows function\t\"AppendMenuA\" as appendmenu\t\t\t\t(wt_handle,wt_uint,wt_intptr,wt_string)wt_bool\r\n\twindows function\t\"GetDC\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_handle\r\n\twindows function\t\"ReleaseDC\"\t\t\t\t\t\t\t\t(wt_handle,wt_handle)wt_int\r\n\r\n\twindows function\t\"SendMessageA\" as sendmessage\t\t\t\t(wt_handle,wt_uint,wt_wparam,wt_lparam)wt_result\r\n\twindows function\t\"PostMessageA\" as postmessage\t\t\t\t(wt_handle,wt_uint,wt_wparam,wt_lparam)wt_bool\r\n\twindows function\t\"PeekMessageA\" as peekmessage\t\t\t\t(wt_ptr,wt_handle,wt_uint,wt_uint,wt_uint)wt_bool\r\n\twindows function\t\"BeginPaint\"\t\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_handle\r\n\twindows function\t\"EndPaint\"\t\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\r\n\twindows proc\t\"PostQuitMessage\"\t\t\t\t\t(wt_int)\r\n\twindows function\t\"LoadIconA\" as loadicon\t\t\t\t\t(wt_handle,wt_string)wt_handle\r\n\twindows function\t\"LoadCursorA\" as loadcursor\t\t\t\t(wt_handle,wt_string)wt_handle\r\n\twindows function\t\"SetCursor\"\t\t\t\t\t\t\t\t(wt_handle)wt_handle\r\n\twindows function\t\"DrawMenuBar\"\t\t\t\t\t\t\t\t(wt_handle)wt_bool\r\n\twindows function\t\"GetSystemMenu\"\t\t\t\t\t\t\t(wt_handle,wt_bool)wt_handle\r\n\twindows function\t\"CreateMenu\"\t\t\t\t\t\t\t\t:wt_handle\r\n\twindows function\t\"CreatePopupMenu\"\t\t\t\t\t\t\t:wt_handle\r\n\twindows function\t\"DestroyMenu\"\t\t\t\t\t\t\t\t(wt_handle)wt_bool\r\n\twindows function\t\"CheckMenuItem\"\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_uint)wt_dword\r\n\twindows function\t\"EnableMenuItem\"\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_uint)wt_bool\r\n\twindows function\t\"GetSubMenu\"\t\t\t\t\t\t\t\t(wt_handle,wt_int)wt_handle\r\n\twindows function\t\"GetMenuItemID\"\t\t\t\t\t\t\t(wt_handle,wt_int)wt_uint\r\n\twindows function\t\"GetMenuItemCount\"\t\t\t\t\t\t(wt_handle)wt_int\r\n\twindows function\t\"InsertMenuA\" as insertmenu\t\t\t\t(wt_handle,wt_uint,wt_uint,wt_intptr,wt_string)wt_bool\r\n\twindows function\t\"ModifyMenuA\" as modifymenu\t\t\t\t(wt_handle,wt_uint,wt_uint,wt_intptr,wt_string)wt_bool\r\n\twindows function\t\"RemoveMenu\"\t\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_uint)wt_bool\r\n\twindows function\t\"DeleteMenu\"\t\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_uint)wt_bool\r\n\r\n\twindows function\t\"DestroyWindow\"\t\t\t\t\t\t\t(wt_handle)wt_bool\r\n\twindows function\t\"InvalidateRect\"\t\t\t\t\t\t\t(wt_handle,wt_ptr,wt_bool)wt_bool\r\n\twindows function\t\"ValidateRect\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\r\n\twindows function\t\"ShowWindow\"\t\t\t\t\t\t\t\t(wt_handle,wt_int)wt_bool\r\n\twindows function\t\"GetClassLongA\" as getclassint\t\t\t(wt_handle,wt_int)wt_word\r\n\twindows function\t\"SetClassLongA\" as setclasslong\t\t\t(wt_handle,wt_int,wt_dword)wt_word\r\n\twindows function\t\"SetWindowTextA\" as setwindowtext\t\t\t(wt_handle,wt_string)wt_bool\r\n\twindows function\t\"GetWindowTextA\" as getwindowtext\t\t\t(wt_handle,wt_string,wt_int)wt_int\r\n\twindows function\t\"GetWindowTextLengthA\" as getwindowtextlength\t(wt_handle)wt_int\r\n\twindows function\t\"GetKeyState\"\t\t\t\t\t\t\t\t(wt_int)wt_word\r\n\r\n!\twindows function\t\"GetWindowLongPtrA\" as getwindowlongptr\t(wt_handle,wt_int)intm\r\n!\twindows function\t\"SetWindowLongPtrA\" as setwindowlongptr\t(wt_handle,wt_int,wt_int)intm\r\n\twindows function\t\"GetWindowLongA\" as getwindowlongptr\t\t(wt_handle,wt_int)intm\r\n\twindows function\t\"SetWindowLongA\" as setwindowlongptr\t\t(wt_handle,wt_int,intm)intm\r\n\r\n\twindows function\t\"GetClientRect\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\r\n\twindows function\t\"ClientToScreen\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\r\n\twindows function\t\"ScreenToClient\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\r\n\twindows function\t\"GetWindowRect\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\r\n\twindows function\t\"GetSysColor\" as getsyscolour\t\t\t\t(wt_int)wt_dword\r\n\twindows function\t\"GetScrollInfo\"\t\t\t\t\t\t\t(wt_handle,wt_int,wt_ptr)wt_bool\r\n\twindows function\t\"GetMenu\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_handle\r\n\twindows function\t\"SetMenu\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_handle)wt_ptr\r\n\twindows function\t\"TrackPopupMenu\"\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_int,wt_int,wt_int,wt_handle,wt_ptr)wt_bool\r\n\twindows function\t\"GetMenuState\"\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_uint)wt_uint\r\n\twindows function\t\"MessageBoxA\" \\\r\n\t\t\t\t\t\t\t\t(wt_handle a=0,wt_string message, wt_string caption, wt_uint b=0)wt_int\r\n\twindows function\t\"OpenClipboard\"\t\t\t\t\t\t\t(wt_handle)wt_bool\r\n\twindows function\t\"CloseClipboard\"\t\t\t\t\t\t\t:wt_bool\r\n\twindows function\t\"EmptyClipboard\"\t\t\t\t\t\t\t:wt_bool\r\n\twindows function\t\"GetClipboardData\"\t\t\t\t\t\t(wt_uint)wt_handle\r\n\twindows function\t\"SetClipboardData\"\t\t\t\t\t\t(wt_uint,wt_handle)wt_handle\r\n\twindows function\t\"MessageBeep\"\t\t\t\t\t\t\t(wt_uint x=0)wt_bool\r\nend\r\n!=========================================\r\n\r\nimportdll gdi32=\r\n\twindows function\t\"Rectangle\"\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int)wt_bool\r\n\twindows function\t\"RoundRect\"\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int)wt_bool\r\n\twindows function\t\"Ellipse\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int)wt_bool\r\n\twindows function\t\"Arc\"\t\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int)wt_bool\r\n\twindows function\t\"Chord\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int)wt_bool\r\n\twindows function\t\"Pie\"\t\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int)wt_bool\r\n\twindows function\t\"Polygon\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_handle,wt_int)wt_bool\r\n\twindows function\t\"TextOutA\" as textout\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_string,wt_int)wt_bool\r\n\twindows function\t\"TextOutW\" \t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_ptr,wt_int)wt_bool\r\n\twindows function\t\"GetStockObject\"\t\t\t\t\t\t\t(wt_int)wt_handle\r\n\twindows function\t\"SelectObject\"\t\t\t\t\t\t\t(wt_handle,wt_handle)wt_handle\r\n\twindows function\t\"CreateDCA\" as createdc\t\t\t\t\t(wt_string,wt_string,wt_string,wt_ptr)wt_handle\r\n\twindows function\t\"MoveToEx\"\t\t\t\t\t\t(wt_handle a,wt_int b,wt_int c,wt_ptr d=nil)wt_bool\r\n\twindows function\t\"CreatePen\"\t\t\t\t\t\t\t\t(wt_int,wt_int,wt_dword)wt_handle\r\n\twindows function\t\"CreateSolidBrush\"\t\t\t\t\t\t(wt_dword)wt_handle\r\n\twindows function\t\"CreateBrushIndirect\"\t\t\t\t\t\t(wt_ptr)wt_handle\r\n\twindows function\t\"LineTo\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int)wt_bool\r\n\twindows function\t\"GetPixel\"\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int)wt_dword\r\n\twindows function\t\"SetPixel\"\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_dword)wt_dword\r\n\twindows function\t\"SetGraphicsMode\"\t\t\t\t\t\t\t(wt_handle,wt_int)wt_int\r\n\twindows function\t\"CreateFontIndirectA\" as createfontindirect\t(wt_ptr)wt_handle\r\n\twindows function\t\"CreateFontA\" as createfont \\\r\n\t\t\t(wt_int height, wt_int width=0, wt_int escapement=0, wt_int orientation=0, wt_int bold=0,\r\n\t\t\t wt_dword italic=0, wt_dword underline=0, wt_dword strikeout=0, wt_dword charset=0,\r\n\t\t\t wt_dword outprec=0, wt_dword clipprec=0, wt_dword quality=0, wt_dword pitch=0, wt_string facename)wt_handle\r\n\twindows function\t\"SaveDC\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_int\r\n\twindows function\t\"GetTextMetricsA\" as gettextmetrics\t\t(wt_handle,wt_ptr)wt_bool\r\n\twindows function\t\"DeleteObject\"\t\t\t\t\t\t\t(wt_handle)wt_bool\r\n\twindows function\t\"RestoreDC\"\t\t\t\t\t\t\t\t(wt_handle,wt_int)wt_bool\r\n!\twindows function\t\"GetTextExtentPoint32A\" as gettextextentpoint32\t(wt_handle,wt_string,wt_int,wt_ptr)wt_bool\r\n\twindows function\t\"GetTextExtentPoint32A\" as gettextextentpoint32\t(wt_handle,wt_ptr,wt_int,wt_ptr)wt_bool\r\n\twindows function\t\"GetObjectA\" as getobject\t\t\t\t\t(wt_handle,wt_int,wt_ptr)wt_int\r\n\twindows function\t\"CreatePalette\"\t\t\t\t\t\t\t(wt_ptr)wt_handle\r\n\twindows function\t\"GetWindowExtEx\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\r\n\twindows function\t\"CreateCompatibleBitmap\"\t\t\t\t\t(wt_handle,wt_int,wt_int)wt_handle\r\n\twindows function\t\"SetBitmapBits\"\t\t\t\t\t\t\t(wt_handle,wt_dword,wt_ptr)wt_long\r\n\twindows function\t\"SelectPalette\"\t\t\t\t\t\t\t(wt_handle,wt_handle,wt_bool)wt_handle\r\n\twindows function\t\"RealizePalette\"\t\t\t\t\t\t\t(wt_handle)wt_uint\r\n\twindows function\t\"SetDIBitsToDevice\"\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_dword,wt_dword,wt_int,wt_int,wt_uint,wt_uint,wt_ptr,wt_ptr,wt_uint)wt_int\r\n\twindows function\t\"StretchDIBits\"\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_ptr,wt_ptr,wt_uint,wt_dword)wt_int\r\n\twindows function\t\"SetStretchBltMode\"\t\t\t\t\t\t(wt_handle,wt_int)wt_int\r\n\twindows function\t\"PatBlt\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_dword)wt_bool\r\n\twindows function\t\"BitBlt\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_handle,wt_int,wt_int,wt_dword)wt_bool\r\n\twindows function\t\"SetROP2\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int)wt_int\r\n\twindows function\t\"CreateCompatibleDC\"\t\t\t\t\t\t(wt_handle)wt_handle\r\n\twindows function\t\"DeleteDC\"\t\t\t\t\t\t\t\t(wt_handle)wt_bool\r\n\twindows function\t\"CreateBitmap\"\t\t\t\t\t\t\t(wt_int,wt_int,wt_uint,wt_uint,wt_ptr)wt_handle\r\n\twindows function\t\"CreateBitmapIndirect\"\t\t\t\t\t(wt_ptr)wt_handle\r\n\twindows function\t\"CreateDIBitmap\"\t\t\t\t\t\t\t(wt_handle,wt_ptr,wt_dword,wt_ptr,wt_ptr,wt_uint)wt_handle\r\n\twindows function\t\"CreateDIBSection\"\t\t\t\t\t\t(wt_handle,wt_ptr,wt_uint,wt_ptr,wt_handle,wt_dword)wt_handle\r\n\twindows function\t\"StretchBlt\"\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int, wt_int,wt_int,wt_handle, wt_int,wt_int,wt_int, wt_int,wt_dword)wt_bool\r\n\twindows function\t\"PlgBlt\"\t\t\t\t\t\t\t\t(wt_handle,wt_ptr,wt_handle, wt_int,wt_int,wt_int,wt_int, wt_handle, wt_int,wt_int)wt_bool\r\n\twindows function\t\"SetTextColor\"  as settextcolour\t\t\t(wt_handle,wt_dword)wt_dword\r\n\twindows function\t\"SetTextAlign\"\t\t\t\t\t\t\t(wt_handle,wt_uint)wt_uint\r\n\twindows function\t\"SetTextJustification\"\t\t\t\t\t(wt_handle,wt_int,wt_int)wt_bool\r\n\twindows function\t\"SetBkColor\"  as setbkcolour\t\t\t\t(wt_handle,wt_dword)wt_dword\r\n\twindows function\t\"SetBkMode\"\t\t\t\t\t\t\t\t(wt_handle,wt_int)wt_int\r\n\twindows function\t\"GetBkColor\"  as getbkcolour\t\t\t\t(wt_handle)wt_dword\r\n\twindows function\t\"GetBkMode\"\t\t\t\t\t\t\t\t(wt_handle)wt_int\r\n\twindows function\t\"StartDocA\" as startdoc\t\t\t\t\t(wt_handle,wt_ptr)wt_int\r\n\twindows function\t\"StartPage\"\t\t\t\t\t\t\t\t(wt_handle)wt_int\r\n\twindows function\t\"EndPage\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_int\r\n\twindows function\t\"EndDoc\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_int\r\n\twindows function\t\"AbortDoc\"\t\t\t\t\t\t\t\t(wt_handle)wt_int\r\n\twindows function\t\"GetViewportOrgEx\"\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\r\n\twindows function\t\"GetDIBits\"\t\t\t\t\t\t\t\t(wt_handle,wt_handle,wt_uint,wt_uint,wt_ptr,wt_ptr,wt_uint)wt_int\r\n\twindows function\t\"GetDIBColorTable\" as getdibcolourtable\t(wt_handle,wt_uint,wt_uint,wt_ptr)wt_uint\r\n\twindows function\t\"SetDIBColorTable\" as setdibcolourtable\t(wt_handle,wt_uint,wt_uint,wt_ptr)wt_uint\r\n\twindows function\t\"GetTextAlign\"\t\t\t\t\t\t\t(wt_handle)wt_uint\r\nend\r\n!=========================================\r\n\r\nimportdll comdlg32=\r\n\twindows function\t\"GetOpenFileNameA\"\t\t\t\t\t\t(wt_ptr)wt_bool\r\n\twindows function\t\"GetSaveFileNameA\"\t\t\t\t\t\t(wt_ptr)wt_bool\r\nend\r\n\r\nproc start=\r\nend\r\n\r\nproc main=\r\n!CPL \"TEST WINAPI\"\r\nend\r\n",
    \
(uint8_t*)"!Windows win32 constants\r\n\r\nglobal const driverversion =  0\r\nglobal const technology =  2\r\nglobal const horzsize =  4\r\nglobal const vertsize =  6\r\nglobal const horzres =  8\r\nglobal const vertres =  10\r\nglobal const bitspixel =  12\r\nglobal const bitplanes =  14\r\nglobal const numbrushes =  16\r\nglobal const numpens =  18\r\nglobal const nummarkers =  20\r\nglobal const numfonts =  22\r\nglobal const numcolours =  24\r\nglobal const pdevicesize =  26\r\nglobal const curvecaps =  28\r\nglobal const linecaps =  30\r\nglobal const polygonalcaps =  32\r\nglobal const textcaps =  34\r\nglobal const clipcaps =  36\r\nglobal const rastercaps =  38\r\nglobal const aspectx =  40\r\nglobal const aspecty =  42\r\nglobal const aspectxy =  44\r\nglobal const logpixelsx =  88\r\nglobal const logpixelsy =  90\r\nglobal const sizepalette =  104\r\nglobal const numreserved =  106\r\nglobal const colourres =  108\r\nglobal const physicalwidth =  110\r\nglobal const physicalheight =  111\r\nglobal const physicaloffsetx =  112\r\nglobal const physicaloffsety =  113\r\nglobal const scalingfactorx =  114\r\nglobal const scalingfactory =  115\r\nglobal const fw_dontcare =  0\r\nglobal const fw_thin =  100\r\nglobal const fw_extralight =  200\r\nglobal const fw_ultralight =  200\r\nglobal const fw_light =  300\r\nglobal const fw_normal =  400\r\nglobal const fw_regular =  400\r\nglobal const fw_medium =  500\r\nglobal const fw_semibold =  600\r\nglobal const fw_demibold =  600\r\nglobal const fw_bold =  700\r\nglobal const fw_extrabold =  800\r\nglobal const fw_ultrabold =  800\r\nglobal const fw_heavy =  900\r\nglobal const fw_black =  900\r\nglobal const cs_vredraw =  1\r\nglobal const cs_hredraw =  2\r\nglobal const cs_keycvtwindow =  4\r\nglobal const cs_dblclks =  8\r\nglobal const cs_owndc =  32\r\nglobal const cs_classdc =  64\r\nglobal const cs_parentdc =  128\r\nglobal const cs_nokeycvt =  256\r\nglobal const cs_noclose =  512\r\nglobal const cs_savebits =  2048\r\nglobal const cs_bytealignclient =  4096\r\nglobal const cs_bytealignwindow =  8192\r\nglobal const cs_publicclass =  16384\r\nglobal const sw_hide =  0\r\nglobal const sw_shownormal =  1\r\nglobal const sw_normal =  1\r\nglobal const sw_showminimized =  2\r\nglobal const sw_showmaximized =  3\r\nglobal const sw_maximize =  3\r\nglobal const sw_shownoactivate =  4\r\nglobal const sw_show =  5\r\nglobal const sw_minimize =  6\r\nglobal const sw_showminnoactive =  7\r\nglobal const sw_showna =  8\r\nglobal const sw_restore =  9\r\nglobal const sw_showdefault =  10\r\nglobal const sw_max =  10\r\nglobal const pm_noremove =  0\r\nglobal const pm_remove =  1\r\nglobal const pm_noyield =  2\r\nglobal const wm_null =  0\r\nglobal const wm_create =  1\r\nglobal const wm_destroy =  2\r\nglobal const wm_move =  3\r\nglobal const wm_size =  5\r\nglobal const wm_activate =  6\r\nglobal const wa_inactive =  0\r\nglobal const wa_active =  1\r\nglobal const wa_clickactive =  2\r\nglobal const wm_setfocus =  7\r\nglobal const wm_killfocus =  8\r\nglobal const wm_enable =  10\r\nglobal const wm_setredraw =  11\r\nglobal const wm_settext =  12\r\nglobal const wm_gettext =  13\r\nglobal const wm_gettextlength =  14\r\nglobal const wm_paint =  15\r\nglobal const wm_close =  16\r\nglobal const wm_queryendsession =  17\r\nglobal const wm_quit =  18\r\nglobal const wm_queryopen =  19\r\nglobal const wm_erasebkgnd =  20\r\nglobal const wm_syscolourchange =  21\r\nglobal const wm_endsession =  22\r\nglobal const wm_showwindow =  24\r\nglobal const wm_wininichange =  26\r\nglobal const wm_devmodechange =  27\r\nglobal const wm_activateapp =  28\r\nglobal const wm_fontchange =  29\r\nglobal const wm_timechange =  30\r\nglobal const wm_cancelmode =  31\r\nglobal const wm_setcursor =  32\r\nglobal const wm_mouseactivate =  33\r\nglobal const wm_childactivate =  34\r\nglobal const wm_queuesync =  35\r\nglobal const wm_getminmaxinfo =  36\r\nglobal const wm_drawitem =  43\r\nglobal const wm_notify =  78\r\nglobal const wm_contextmenu =  123\r\nglobal const wm_geticon =  127\r\nglobal const wm_seticon =  128\r\nglobal const wm_nchittest =  132\r\n\r\nglobal const wm_nclbuttondown\t= 161\r\nglobal const wm_nclbuttonup\t= 162\r\nglobal const wm_nclbuttondblclick\t= 163\r\n\r\nglobal const wm_menurbuttonup\t= 290\r\n\r\nglobal const wm_parentnotify =  528\r\nglobal const wm_dropfiles =  563\r\nglobal const wm_enteridle =  289\r\nglobal const wm_user =  1024\r\nglobal const wm_mdicreate =  544\r\nglobal const wm_mdidestroy =  545\r\nglobal const wm_mdiactivate =  546\r\nglobal const wm_mdirestore =  547\r\nglobal const wm_mdinext =  548\r\nglobal const wm_mdimaximize =  549\r\nglobal const wm_mditile =  550\r\nglobal const wm_mdicascade =  551\r\nglobal const wm_mdiiconarange =  552\r\nglobal const wm_mdigetactive =  553\r\nglobal const wm_mdisetmenu =  560\r\nglobal const wm_entersizemove =  561\r\nglobal const wm_exitsizemove =  562\r\nglobal const wm_mdirefrshmenu =  564\r\nglobal const wm_lbuttondblclk =  515\r\nglobal const wm_rbuttondblclk =  518\r\nglobal const wm_lbuttondown =  513\r\nglobal const wm_rbuttondown =  516\r\nglobal const wm_mbuttondown =  519\r\nglobal const wm_mousemove =  512\r\nglobal const wm_lbuttonup =  514\r\nglobal const wm_rbuttonup =  517\r\nglobal const wm_mbuttonup =  520\r\nglobal const wm_mbuttondblclk =  521\r\nglobal const wm_mousewheel =  522\r\nglobal const snd_filename =  131072\r\nglobal const snd_async =  1\r\nglobal const dt_singleline =  32\r\nglobal const dt_centre =  1\r\nglobal const dt_vcentre =  4\r\nglobal const ws_overlapped =  0\r\nglobal const ws_popup =  2147483648\r\nglobal const ws_child =  1073741824\r\nglobal const ws_minimize =  536870912\r\nglobal const ws_visible =  268435456\r\nglobal const ws_disabled =  134217728\r\nglobal const ws_clipsiblings =  67108864\r\nglobal const ws_clipchildren =  33554432\r\nglobal const ws_maximize =  16777216\r\nglobal const ws_caption =  12582912\r\nglobal const ws_border =  8388608\r\nglobal const ws_dlgframe =  4194304\r\nglobal const ws_hscroll =  1048576\r\nglobal const ws_vscroll =  2097152\r\nglobal const ws_sysmenu =  524288\r\nglobal const ws_thickframe =  262144\r\nglobal const ws_group =  131072\r\nglobal const ws_tabstop =  0\r\nglobal const ws_scrollbars =  3145728\r\nglobal const ws_minimizebox =  131072\r\nglobal const ws_maximizebox =  65536\r\nglobal const ws_tiled =  0\r\nglobal const ws_iconic =  536870912\r\nglobal const ws_sizebox =  262144\r\nglobal const ws_overlappedwindow =  13565952\r\nglobal const ws_tiledwindow =  13565952\r\nglobal const ws_popupwindow =  -2138570752\r\nglobal const ws_childwindow =  1073741824\r\nglobal const ws_ex_acceptfiles =  16\r\nglobal const ws_ex_appwindow =  262144\r\nglobal const ws_ex_clientedge =  512\r\nglobal const ws_ex_contexthelp =  1024\r\nglobal const ws_ex_controlparent =  65536\r\nglobal const ws_ex_dlgmodalframe =  1\r\nglobal const ws_ex_left =  0\r\nglobal const ws_ex_leftscrollbar =  16384\r\nglobal const ws_ex_ltrreading =  0\r\nglobal const ws_ex_mdichild =  64\r\nglobal const ws_ex_noparentnotify =  4\r\nglobal const ws_ex_overlappedwindow =  768\r\nglobal const ws_ex_palettewindow =  392\r\nglobal const ws_ex_right =  4096\r\nglobal const ws_ex_rightscrollbar =  0\r\nglobal const ws_ex_rtlreading =  8192\r\nglobal const ws_ex_staticedge =  131072\r\nglobal const ws_ex_toolwindow =  128\r\nglobal const ws_ex_topmost =  8\r\nglobal const ws_ex_transparent =  32\r\nglobal const ws_ex_windowedge =  256\r\n\r\nglobal const gw_hwndfirst =  0\r\nglobal const gw_hwndlast =  1\r\nglobal const gw_hwndnext =  2\r\nglobal const gw_hwndprev =  3\r\nglobal const gw_owner =  4\r\nglobal const gw_child =  5\r\nglobal const gw_enabledpopup =  6\r\nglobal const cb_geteditsel =  320\r\nglobal const cb_limittext =  321\r\nglobal const cb_seteditsel =  322\r\nglobal const cb_addstring =  323\r\nglobal const cb_deletestring =  324\r\nglobal const cb_dir =  325\r\nglobal const cb_getcount =  326\r\nglobal const cb_getcursel =  327\r\nglobal const cb_getlbtext =  328\r\nglobal const cb_getlbtextlen =  329\r\nglobal const cb_insertstring =  330\r\nglobal const cb_resetcontent =  331\r\nglobal const cb_findstring =  332\r\nglobal const cb_findstringexact =  344\r\nglobal const cb_selectstring =  333\r\nglobal const cb_setcursel =  334\r\nglobal const cb_showdropdown =  335\r\nglobal const cb_getitemdata =  336\r\nglobal const cb_setitemdata =  337\r\nglobal const cb_getdroppedcontrolrect =  338\r\nglobal const cb_setitemheight =  339\r\nglobal const cb_getitemheight =  340\r\nglobal const cb_setextendedui =  341\r\nglobal const cb_getextendedui =  342\r\nglobal const cb_getdroppedstate =  343\r\nglobal const cb_setlocale =  345\r\nglobal const cb_getlocale =  346\r\nglobal const cb_gettopindex =  347\r\nglobal const cb_settopindex =  348\r\nglobal const cb_gethorizontalextent =  349\r\nglobal const cb_sethorizontalextent =  350\r\nglobal const cb_getdroppedwidth =  351\r\nglobal const cb_setdroppedwidth =  352\r\nglobal const cb_initstorage =  353\r\nglobal const cb_multipleaddstring =  355\r\nglobal const bm_click =  245\r\nglobal const bm_getcheck =  240\r\nglobal const bm_getimage =  246\r\nglobal const bm_getstate =  242\r\nglobal const bm_setcheck =  241\r\nglobal const bm_setimage =  247\r\nglobal const bm_setstate =  243\r\nglobal const bm_setstyle =  244\r\nglobal const cf_bitmap =  2\r\nglobal const cf_dib =  8\r\nglobal const cf_palette =  9\r\nglobal const cf_enhmetafile =  14\r\nglobal const cf_metafilepict =  3\r\nglobal const cf_oemtext =  7\r\nglobal const cf_text =  1\t\t\t!used in sys\r\nglobal const cf_unicodetext =  13\r\nglobal const cf_dif =  5\r\nglobal const cf_dspbitmap =  130\r\nglobal const cf_dspenhmetafile =  142\r\nglobal const cf_dspmetafilepict =  131\r\nglobal const cf_dsptext =  129\r\nglobal const cf_gdiobjfirst =  768\r\nglobal const cf_gdiobjlast =  1023\r\nglobal const cf_hdrop =  15\r\nglobal const cf_locale =  16\r\nglobal const cf_ownerdisplay =  128\r\nglobal const cf_pendata =  10\r\nglobal const cf_privatefirst =  512\r\nglobal const cf_privatelast =  767\r\nglobal const cf_riff =  11\r\nglobal const cf_sylk =  4\r\nglobal const cf_wave =  12\r\nglobal const cf_tiff =  6\r\n\r\nglobal const tcif_text =  1\r\nglobal const tcif_image =  2\r\nglobal const tcif_param =  8\r\nglobal const tcif_rtlreading =  4\r\n\r\nglobal const wm_keydown =  256\r\nglobal const wm_keyup =  257\r\nglobal const wm_char =  258\r\nglobal const wm_syschar =  262\r\nglobal const wm_sysdeadchar =  263\r\nglobal const wm_syskeydown =  260\r\nglobal const wm_syskeyup =  261\r\nglobal const mf_insert =  0\r\nglobal const mf_change =  128\r\nglobal const mf_append =  256\r\nglobal const mf_delete =  512\r\nglobal const mf_remove =  4096\r\nglobal const mf_bycommand =  0\r\nglobal const mf_byposition =  1024\r\nglobal const mf_separator =  2048\r\nglobal const mf_enabled =  0\r\nglobal const mf_grayed =  1\r\nglobal const mf_greyed =  1\r\nglobal const mf_disabled =  2\r\nglobal const mf_unchecked =  0\r\nglobal const mf_checked =  8\r\nglobal const mf_usecheckbitmaps =  512\r\nglobal const mf_string =  0\r\nglobal const mf_bitmap =  4\r\nglobal const mf_ownerdraw =  256\r\nglobal const mf_popup =  16\r\nglobal const mf_menubarbreak =  32\r\nglobal const mf_menubreak =  64\r\nglobal const mf_unhilite =  0\r\nglobal const mf_hilite =  128\r\nglobal const mf_sysmenu =  8192\r\nglobal const mf_help =  16384\r\nglobal const mf_mouseselect =  32768\r\n\r\n!global const bn_clicked =  0\r\n!global const bn_dblclk =  5\r\n!global const bn_disable =  4\r\n!global const bn_doubleclicked =  5\r\n!global const bn_hilite =  2\r\n!global const bn_killfocus =  7\r\n!global const bn_paint =  1\r\n!global const bn_pushed =  2\r\n!global const bn_setfocus =  6\r\n!global const bn_unhilite =  3\r\n!global const bn_unpushed =  3\r\n!global const en_setfocus =  256\r\n!global const en_killfocus =  512\r\n!global const en_change =  768\r\n!global const en_update =  1024\r\n!global const en_errspace =  1280\r\n!global const en_maxtext =  1281\r\n!global const en_hscroll =  1537\r\n!global const en_vscroll =  1538\r\n!global const lbn_errspace =  -2\r\n!global const lbn_selchange =  1\r\n!global const lbn_dblclk =  2\r\n!global const lbn_selcancel =  3\r\n!global const lbn_setfocus =  4\r\n!global const lbn_killfocus =  5\r\n!global const cbn_errspace =  -1\r\n!global const cbn_selchange =  1\r\n!global const cbn_dblclk =  2\r\n!global const cbn_setfocus =  3\r\n!global const cbn_killfocus =  4\r\n!global const cbn_editchange =  5\r\n!global const cbn_editupdate =  6\r\n!global const cbn_dropdown =  7\r\n!global const cbn_closeup =  8\r\n!global const cbn_selendok =  9\r\n!global const cbn_selendcancel =  10\r\n!\r\n!global const cbs_autohscroll =  64\r\n!global const cbs_disablenoscroll =  2048\r\n!global const cbs_dropdown =  2\r\n!global const cbs_dropdownlist =  3\r\n!global const cbs_hasstrings =  512\r\n!global const cbs_lowercase =  16384\r\n!global const cbs_nointegralheight =  1024\r\n!global const cbs_oemconvert =  128\r\n!global const cbs_ownerdrawfixed =  16\r\n!global const cbs_ownerdrawvariable =  32\r\n!global const cbs_simple =  1\r\n!global const cbs_sort =  256\r\n!global const cbs_uppercase =  8192\r\n\r\nglobal const wm_command =  273\r\nglobal const wm_menuselect =  287\r\nglobal const wm_cut =  768\r\nglobal const wm_copy =  769\r\nglobal const wm_paste =  770\r\nglobal const wm_clear =  771\r\nglobal const wm_undo =  772\r\nglobal const em_getsel =  176\r\nglobal const em_setsel =  177\r\nglobal const em_scroll =  181\r\nglobal const em_linescroll =  182\r\nglobal const em_scrollcaret =  183\r\nglobal const em_getmodify =  184\r\nglobal const em_setmodify =  185\r\nglobal const em_getlinecount =  186\r\nglobal const em_lineindex =  187\r\nglobal const em_sethandle =  188\r\nglobal const em_gethandle =  189\r\nglobal const em_getthumb =  190\r\nglobal const em_linelength =  193\r\nglobal const em_replacesel =  194\r\nglobal const em_getline =  196\r\nglobal const em_limittext =  197\r\nglobal const em_canundo =  198\r\nglobal const em_undo =  199\r\nglobal const em_fmtlines =  200\r\nglobal const em_linefromchar =  201\r\nglobal const em_settabstops =  203\r\nglobal const em_setpasswordchar =  204\r\nglobal const em_emptyundobuffer =  205\r\nglobal const em_getfirstvisibleline =  206\r\nglobal const em_setreadonly =  207\r\nglobal const em_setwordbreakproc =  208\r\nglobal const em_getwordbreakproc =  209\r\nglobal const em_getpasswordchar =  210\r\nglobal const em_setlimittext =  197\r\nglobal const em_getseltext =  1086\r\nglobal const em_setcharformat =  1092\r\nglobal const em_getcharformat =  1082\r\nglobal const em_settextmode =  1113\r\nglobal const em_gettextmode =  1114\r\nglobal const em_gettextex =  1118\r\nglobal const em_gettextlengthex =  1119\r\nglobal const tm_plaintext =  1\r\nglobal const tm_richtext =  2\r\nglobal const tm_singlelevelundo =  4\r\nglobal const tm_multilevelundo =  8\r\nglobal const tm_singlecodepage =  16\r\nglobal const tm_multicodepage =  32\r\nglobal const scf_word =  2\r\nglobal const scf_selection =  1\r\nglobal const sb_getborders =  1031\r\nglobal const sb_getparts =  1030\r\nglobal const sb_getrect =  1034\r\nglobal const sb_gettextw =  1037\r\nglobal const sb_gettextlengthw =  1036\r\nglobal const sb_settextw =  1035\r\nglobal const sb_gettexta =  1026\r\nglobal const sb_gettextlengtha =  1027\r\nglobal const sb_settexta =  1025\r\nglobal const sb_gettext =  1026\r\nglobal const sb_gettextlength =  1027\r\nglobal const sb_settext =  1025\r\nglobal const sb_setminheight =  1032\r\nglobal const sb_setparts =  1028\r\nglobal const sb_simple =  1033\r\nglobal const wm_setfont =  48\r\nglobal const wm_getfont =  49\r\nglobal const gm_advanced =  2\r\nglobal const transparent =  1\r\nglobal const opaque =  2\r\nglobal const mwt_identity =  1\r\nglobal const cw_usedefault =  0x8000'0000\r\nglobal const idc_arrow =  32512\r\nglobal const idc_ibeam =  32513\r\nglobal const idc_wait =  32514\r\nglobal const idc_cross =  32515\r\nglobal const idc_uparrow =  32516\r\nglobal const idc_sizenwse =  32642\r\nglobal const idc_sizenesw =  32643\r\nglobal const idc_sizewe =  32644\r\nglobal const idc_sizens =  32645\r\nglobal const idc_sizeall =  32646\r\nglobal const idc_no =  32648\r\nglobal const idc_appstarting =  32650\r\nglobal const idc_help =  32651\r\nglobal const idi_application =  32512\r\nglobal const idi_hand =  32513\r\nglobal const idi_question =  32514\r\nglobal const idi_exclamation =  32515\r\nglobal const idi_asterisk =  32516\r\nglobal const idi_winlogo =  32517\r\nglobal const idc_size =  32640\r\nglobal const idc_icon =  32641\r\nglobal const arrowpointer =  32512\r\nglobal const ibeampointer =  32513\r\nglobal const waitpointer =  32514\r\nglobal const crosspointer =  32515\r\nglobal const uparrowpointer =  32516\r\nglobal const sizenwsepointer =  32642\r\nglobal const sizeneswpointer =  32643\r\nglobal const sizewepointer =  32644\r\nglobal const sizenspointer =  32645\r\nglobal const sizeallpointer =  32646\r\nglobal const nopointer =  32648\r\nglobal const appstartingpointer =  32650\r\nglobal const helpicon =  32651\r\nglobal const applicationicon =  32512\r\nglobal const handicon =  32513\r\nglobal const questionicon =  32514\r\nglobal const exclamationicon =  32515\r\nglobal const asteriskicon =  32516\r\nglobal const winlogoicon =  32517\r\nglobal const sizepointer =  32640\r\nglobal const iconicon =  32641\r\nglobal const sm_cymin =  29\r\nglobal const sm_cxmin =  28\r\nglobal const sm_arrange =  56\r\nglobal const sm_cleanboot =  67\r\nglobal const sm_cmetrics =  76\r\nglobal const sm_cmousebuttons =  43\r\nglobal const sm_cxborder =  5\r\nglobal const sm_cyborder =  6\r\nglobal const sm_cxcursor =  13\r\nglobal const sm_cycursor =  14\r\nglobal const sm_cxdlgframe =  7\r\nglobal const sm_cydlgframe =  8\r\nglobal const sm_cxdoubleclk =  36\r\nglobal const sm_cydoubleclk =  37\r\nglobal const sm_cxdrag =  68\r\nglobal const sm_cydrag =  69\r\nglobal const sm_cxedge =  45\r\nglobal const sm_cyedge =  46\r\nglobal const sm_cxfixedframe =  7\r\nglobal const sm_cyfixedframe =  8\r\nglobal const sm_cxframe =  32\r\nglobal const sm_cyframe =  33\r\nglobal const sm_cxfullscreen =  16\r\nglobal const sm_cyfullscreen =  17\r\nglobal const sm_cxhscroll =  21\r\nglobal const sm_cyhscroll =  3\r\nglobal const sm_cxhthumb =  10\r\nglobal const sm_cxicon =  11\r\nglobal const sm_cyicon =  12\r\nglobal const sm_cxiconspacing =  38\r\nglobal const sm_cyiconspacing =  39\r\nglobal const sm_cxmaximized =  61\r\nglobal const sm_cymaximized =  62\r\nglobal const sm_cxmaxtrack =  59\r\nglobal const sm_cymaxtrack =  60\r\nglobal const sm_cxmenucheck =  71\r\nglobal const sm_cymenucheck =  72\r\nglobal const sm_cxmenusize =  54\r\nglobal const sm_cymenusize =  55\r\nglobal const sm_cxminimized =  57\r\nglobal const sm_cyminimized =  58\r\nglobal const sm_cxminspacing =  47\r\nglobal const sm_cyminspacing =  48\r\nglobal const sm_cxmintrack =  34\r\nglobal const sm_cymintrack =  35\r\nglobal const sm_cxscreen =  0\r\nglobal const sm_cyscreen =  1\r\nglobal const sm_cxsize =  30\r\nglobal const sm_cysize =  31\r\nglobal const sm_cxsizeframe =  32\r\nglobal const sm_cysizeframe =  33\r\nglobal const sm_cxsmicon =  49\r\nglobal const sm_cysmicon =  50\r\nglobal const sm_cxsmsize =  52\r\nglobal const sm_cysmsize =  53\r\nglobal const sm_cxvscroll =  2\r\nglobal const sm_cyvscroll =  20\r\nglobal const sm_cyvthumb =  9\r\nglobal const sm_cycaption =  4\r\nglobal const sm_cykanjiwindow =  18\r\nglobal const sm_cymenu =  15\r\nglobal const sm_cysmcaption =  51\r\nglobal const sm_dbcsenabled =  42\r\nglobal const sm_debug =  22\r\nglobal const sm_menudropalignment =  40\r\nglobal const sm_mideastenabled =  74\r\nglobal const sm_mousepresent =  19\r\nglobal const sm_mousewheelpresent =  75\r\nglobal const sm_network =  63\r\nglobal const sm_penwindows =  41\r\nglobal const sm_reserved1 =  24\r\nglobal const sm_reserved2 =  25\r\nglobal const sm_reserved3 =  26\r\nglobal const sm_reserved4 =  27\r\nglobal const sm_secure =  44\r\nglobal const sm_showsounds =  70\r\nglobal const sm_slowmachine =  73\r\nglobal const sm_swapbutton =  23\r\nglobal const arw_bottomleft =  0\r\nglobal const arw_bottomright =  1\r\nglobal const arw_hide =  8\r\nglobal const arw_topleft =  2\r\nglobal const arw_topright =  3\r\nglobal const arw_down =  4\r\nglobal const arw_left =  0\r\nglobal const arw_right =  0\r\nglobal const arw_up =  4\r\nglobal const white_brush =  0\r\nglobal const ltgray_brush =  1\r\nglobal const gray_brush =  2\r\nglobal const dkgray_brush =  3\r\nglobal const black_brush =  4\r\nglobal const null_brush =  5\r\nglobal const hollow_brush =  5\r\nglobal const white_pen =  6\r\nglobal const black_pen =  7\r\nglobal const null_pen =  8\r\nglobal const oem_fixed_font =  10\r\nglobal const ansi_fixed_font =  11\r\nglobal const ansi_var_font =  12\r\nglobal const system_font =  13\r\nglobal const device_default_font =  14\r\nglobal const default_palette =  15\r\nglobal const system_fixed_font =  16\r\nglobal const stock_last =  16\r\n\r\n!global const sbm_setpos =  224\r\n!global const sbm_getpos =  225\r\n!global const sbm_setrange =  226\r\n!global const sbm_setrangeredraw =  230\r\n!global const sbm_getrange =  227\r\n!global const sbm_enable_arrows =  228\r\n!global const sbs_horz =  0\r\n!global const sbs_vert =  1\r\n!global const sbs_topalign =  2\r\n!global const sbs_leftalign =  2\r\n!global const sbs_bottomalign =  4\r\n!global const sbs_rightalign =  4\r\n!global const sbs_sizeboxtopleftalign =  2\r\n!global const sbs_sizeboxbottomrightalign =  4\r\n!global const sbs_sizebox =  8\r\n\r\nglobal const wm_hscroll =  276\r\nglobal const wm_vscroll =  277\r\n\r\n!global const sb_horz =  0\r\n!global const sb_hoz =  0\r\n!global const sb_vert =  1\r\n!global const sb_ctl =  2\r\n!global const sb_both =  3\r\n!global const sb_lineup =  0\r\n!global const sb_lineleft =  0\r\n!global const sb_linedown =  1\r\n!global const sb_lineright =  1\r\n!global const sb_pageup =  2\r\n!global const sb_pageleft =  2\r\n!global const sb_pagedown =  3\r\n!global const sb_pageright =  3\r\n!global const sb_thumbposition =  4\r\n!global const sb_thumbtrack =  5\r\n!global const sb_top =  6\r\n!global const sb_left =  6\r\n!global const sb_bottom =  7\r\n!global const sb_right =  7\r\n!global const sb_endscroll =  8\r\n!global const sif_disablenoscroll =  8\r\n!global const sif_page =  2\r\n!global const sif_pos =  4\r\n!global const sif_range =  1\r\n!global const sif_trackpos =  16\r\n!global const sif_all =  23\r\n\r\nglobal const wm_ctlcolourmsgbox =  306\r\nglobal const wm_ctlcolouredit =  307\r\nglobal const wm_ctlcolourlistbox =  308\r\nglobal const wm_ctlcolourbtn =  309\r\nglobal const wm_ctlcolourdlg =  310\r\nglobal const wm_ctlcolourscrollbar =  311\r\nglobal const wm_ctlcolourstatic =  312\r\nglobal const wm_timer =  275\r\n\r\nglobal const srccopy =  13369376\r\nglobal const srcpaint =  15597702\r\nglobal const srcand =  8913094\r\nglobal const srcinvert =  6684742\r\nglobal const srcerase =  4457256\r\n\r\nglobal const notsrccopy =  3342344\r\nglobal const notsrcerase =  1114278\r\nglobal const mergecopy =  12583114\r\nglobal const mergepaint =  12255782\r\nglobal const patcopy =  15728673\r\nglobal const patpaint =  16452105\r\nglobal const patinvert =  5898313\r\nglobal const dstinvert =  5570569\r\nglobal const blackness =  66\r\nglobal const whiteness =  16711778\r\n\r\nglobal const r2_black =  1\r\nglobal const r2_notmergepen =  2\r\nglobal const r2_masknotpen =  3\r\nglobal const r2_notcopypen =  4\r\nglobal const r2_maskpennot =  5\r\nglobal const r2_not =  6\r\nglobal const r2_xorpen =  7\r\nglobal const r2_notmaskpen =  8\r\nglobal const r2_maskpen =  9\r\nglobal const r2_notxorpen =  10\r\nglobal const r2_nop =  11\r\nglobal const r2_mergenotpen =  12\r\nglobal const r2_copypen =  13\r\nglobal const r2_mergepennot =  14\r\nglobal const r2_mergepen =  15\r\nglobal const r2_white =  16\r\nglobal const r2_last =  16\r\n\r\nglobal const gdi_error =  4294967295\r\nglobal const hgdi_error =  4294967295\r\nglobal const clr_invalid =  4278190080\r\nglobal const clr_default =  4278190080\r\nglobal const clr_none =  4294967295\r\nglobal const ofn_readonly =  1\r\nglobal const ofn_overwriteprompt =  2\r\nglobal const ofn_hidereadonly =  4\r\nglobal const ofn_nochangedir =  8\r\nglobal const ofn_showhelp =  16\r\nglobal const ofn_enablehook =  32\r\nglobal const ofn_enabletemplate =  64\r\nglobal const ofn_enabletemplatehandle =  128\r\nglobal const ofn_novalidate =  256\r\nglobal const ofn_allowmultiselect =  512\r\nglobal const ofn_extensiondifferent =  1024\r\nglobal const ofn_pathmustexist =  2048\r\nglobal const ofn_filemustexist =  4096\r\nglobal const ofn_createprompt =  8192\r\nglobal const ofn_shareaware =  16384\r\nglobal const ofn_noreadonlyreturn =  32768\r\nglobal const ofn_notestfilecreate =  65536\r\nglobal const ofn_nonetworkbutton =  131072\r\nglobal const ofn_nolongnames =  262144\r\nglobal const ofn_explorer =  524288\r\nglobal const ofn_nodereferencelinks =  1048576\r\nglobal const ofn_longnames =  2097152\r\nglobal const ofn_sharefallthrough =  2\r\nglobal const ofn_sharenowarn =  1\r\nglobal const ofn_sharewarn =  0\r\n!global const gmem_fixed =  0\r\n!global const gmem_moveable =  2\r\n!global const gmem_nocompact =  16\r\n!global const gmem_nodiscard =  32\r\n!global const gmem_zeroinit =  64\r\n!global const gmem_modify =  128\r\n!global const gmem_discardable =  256\r\n!global const gmem_not_banked =  4096\r\n!global const gmem_share =  8192\r\n!global const gmem_ddeshare =  8192\r\n!global const gmem_notify =  16384\r\n!global const gmem_lower =  4096\r\n!global const gmem_valid_flags =  32626\r\n!global const gmem_invalid_handle =  32768\r\n!global const gmem_clipboard =  8194\r\n!global const ghnd =  66\r\n!global const gptr =  64\r\n!global const pd_allpages =  0\r\n!global const pd_collate =  16\r\n!global const pd_disableprinttofile =  524288\r\n!global const pd_enableprinthook =  4096\r\n!global const pd_enableprinttemplate =  16384\r\n!global const pd_enableprinttemplatehandle =  65536\r\n!global const pd_enablesetuphook =  8192\r\n!global const pd_enablesetuptemplate =  32768\r\n!global const pd_enablesetuptemplatehandle =  131072\r\n!global const pd_hideprinttofile =  1048576\r\n!global const pd_nopagenums =  8\r\n!global const pd_noselection =  4\r\n!global const pd_nowarning =  128\r\n!global const pd_pagenums =  2\r\n!global const pd_printsetup =  64\r\n!global const pd_printtofile =  32\r\n!global const pd_returndc =  256\r\n!global const pd_returndefault =  1024\r\n!global const pd_returnic =  512\r\n!global const pd_selection =  1\r\n!global const pd_showhelp =  2048\r\n!global const pd_usedevmodecopies =  262144\r\n!global const pd_usedevmodecopiesandcollate =  262144\r\nglobal const dib_rgb_colours =  0\r\nglobal const dib_pal_colours =  1\r\nglobal const dib_pal_indices =  2\r\nglobal const dib_pal_physindices =  2\r\nglobal const dib_pal_logindices =  4\r\nglobal const stm_seticon =  368\r\nglobal const stm_setimage =  370\r\nglobal const lr_loadfromfile =  16\r\nglobal const image_bitmap =  0\r\nglobal const image_icon =  1\r\nglobal const lr_copydeleteorg =  8\r\nglobal const lr_copyreturnorg =  4\r\nglobal const lr_monochrome =  1\r\nglobal const lr_createdibsection =  8192\r\nglobal const lr_defaultsize =  64\r\nglobal const ss_icon =  3\r\nglobal const ss_bitmap =  14\r\nglobal const gcl_menuname =  -8\r\nglobal const gcl_hbrbackground =  -10\r\nglobal const gcl_hcursor =  -12\r\nglobal const gcl_hicon =  -14\r\nglobal const gcl_hmodule =  -16\r\nglobal const gcl_cbwndextra =  -18\r\nglobal const gcl_cbclsextra =  -20\r\nglobal const gcl_wndproc =  -24\r\nglobal const gcl_style =  -26\r\nglobal const gcw_atom =  -32\r\nglobal const colour_scrollbar =  0\r\nglobal const colour_background =  1\r\nglobal const colour_desktop =  1\r\nglobal const colour_activecaption =  2\r\nglobal const colour_inactivecaption =  3\r\nglobal const colour_menu =  4\r\nglobal const colour_window =  5\r\nglobal const colour_windowframe =  6\r\nglobal const colour_menutext =  7\r\nglobal const colour_windowtext =  8\r\nglobal const colour_captiontext =  9\r\nglobal const colour_activeborder =  10\r\nglobal const colour_inactiveborder =  11\r\nglobal const colour_appworkspace =  12\r\nglobal const colour_highlight =  13\r\nglobal const colour_highlighttext =  14\r\nglobal const colour_btnface =  15\r\nglobal const colour_3dface =  15\r\nglobal const colour_btnshadow =  16\r\nglobal const colour_3dshadow =  16\r\nglobal const colour_graytext =  17\r\nglobal const colour_btntext =  18\r\nglobal const colour_inactivecaptiontext =  19\r\nglobal const colour_btnhighlight =  20\r\nglobal const colour_3dhilight =  20\r\nglobal const colour_3ddkshadow =  21\r\nglobal const colour_3dlight =  22\r\nglobal const colour_infotext =  23\r\nglobal const colour_infobk =  24\r\nglobal const colour_tooltipbk =  24\r\nglobal const mk_lbutton =  1\r\nglobal const mk_rbutton =  2\r\nglobal const mk_shift =  4\r\nglobal const mk_control =  8\r\nglobal const mk_mbutton =  16\r\nglobal const cbm_createdib =  2\r\nglobal const cbm_init =  4\r\nglobal const cc_enablehook =  16\r\nglobal const cc_enabletemplate =  32\r\nglobal const cc_enabletemplatehandle =  64\r\nglobal const cc_fullopen =  2\r\nglobal const cc_preventfullopen =  4\r\nglobal const cc_rgbinit =  1\r\nglobal const cc_showhelp =  8\r\nglobal const cc_solidcolour =  128\r\nglobal const cf_screenfonts =  1\r\nglobal const cf_printerfonts =  2\r\nglobal const cf_effects =  256\r\nglobal const size_restored =  0\r\nglobal const size_minimized =  1\r\nglobal const size_maximized =  2\r\nglobal const size_maxshow =  3\r\nglobal const size_maxhide =  4\r\n!global const gwl_wndproc =  -4\r\n!global const gwl_hinstance =  -6\r\n!global const gwl_hwndparent =  -8\r\n!global const gwl_style =  -16\r\n!global const gwl_exstyle =  -20\r\nglobal const gwl_userdata =  -21\r\nglobal const gwl_id =  -12\r\nglobal const ta_top =  0\r\nglobal const ta_left =  0\r\nglobal const ta_noupdatecp =  0\r\nglobal const ta_updatecp =  1\r\nglobal const ta_right =  2\r\nglobal const ta_centre =  6\r\nglobal const vta_centre =  6\r\nglobal const ta_bottom =  8\r\nglobal const ta_baseline =  24\r\nglobal const vta_baseline =  24\r\nglobal const ta_rtlreading =  256\r\nglobal const aligntop =  0\r\nglobal const alignbottom =  8\r\nglobal const alignbaseline =  24\r\nglobal const aligncentre =  6\r\nglobal const alignleft =  0\r\nglobal const alignright =  2\r\n\r\nglobal const em_exgetsel =  1076\r\nglobal const em_exlimittext =  1077\r\nglobal const em_exlinefromchar =  1078\r\nglobal const em_exsetsel =  1079\r\nglobal const em_getparaformat =  1085\r\nglobal const em_setparaformat =  1095\r\nglobal const em_streamin =  1097\r\nglobal const em_streamout =  1098\r\nglobal const em_gettextrange =  1099\r\nglobal const em_findtext =  1080\r\nglobal const em_findtextex =  1103\r\n\r\n!global const ttf_idishwnd =  1\r\n!global const ttf_centretip =  2\r\n!global const ttf_rtlreading =  4\r\n!global const ttf_subclass =  16\r\n!global const ttf_track =  32\r\n!global const ttf_absolute =  128\r\n!global const ttf_transparent =  256\r\n!global const ttf_di_setitem =  32768\r\n\r\nglobal const hwnd_top =  0\r\nglobal const hwnd_bottom =  1\r\nglobal const hwnd_topmost =  -1\r\nglobal const hwnd_notopmost =  -2\r\n\r\nglobal const normalwind =  0\r\nglobal const modalwind =  -1\r\nglobal const dialogwind =  -2\r\nglobal const minimize =  2\r\nglobal const maximize =  3\r\nglobal const shiftmask =  1\r\nglobal const controlmask =  2\r\nglobal const altmask =  4\r\nglobal const windowcolour =  15\r\nglobal const ps_geometric =  65536\r\nglobal const ps_cosmetic =  0\r\nglobal const ps_alternate =  8\r\nglobal const ps_solid =  0\r\nglobal const ps_dash =  1\r\nglobal const ps_dot =  2\r\nglobal const ps_dashdot =  3\r\nglobal const ps_dashdotdot =  4\r\nglobal const ps_null =  5\r\nglobal const ps_insideframe =  6\r\nglobal const ps_userstyle =  7\r\nglobal const ps_endcap_round =  0\r\nglobal const ps_endcap_square =  256\r\nglobal const ps_endcap_flat =  512\r\nglobal const ps_join_bevel =  4096\r\nglobal const ps_join_miter =  8192\r\nglobal const ps_join_round =  0\r\nglobal const ps_style_mask =  15\r\nglobal const ps_endcap_mask =  3840\r\nglobal const ps_type_mask =  983040\r\nglobal const bs_solid =  0\r\nglobal const bs_hollow =  1\r\nglobal const bs_null =  1\r\nglobal const bs_hatched =  2\r\nglobal const bs_pattern =  3\r\nglobal const bs_dibpattern =  5\r\nglobal const bs_dibpatternpt =  6\r\nglobal const bs_pattern8x8 =  7\r\nglobal const bs_dibpattern8x8 =  8\r\nglobal const hs_horizontal =  0\r\nglobal const hs_vertical =  1\r\nglobal const hs_fdiagonal =  2\r\nglobal const hs_bdiagonal =  3\r\nglobal const hs_cross =  4\r\nglobal const hs_diagcross =  5\r\n\r\n!global const gl_points =  0\r\n!global const gl_lines =  1\r\n!global const gl_line_loop =  2\r\n!global const gl_line_strip =  3\r\n!global const gl_triangles =  4\r\n!global const gl_triangle_strip =  5\r\n!global const gl_triangle_fan =  6\r\n!global const gl_quads =  7\r\n!global const gl_quad_strip =  8\r\n!global const gl_polygon =  9\r\n\r\nglobal const spi_getworkarea =  48\r\n\r\nproc start=\r\nend\r\n\r\n",
    \
(uint8_t*)"import sys\r\n\r\nimport winmessages\r\nimport winconsts\r\nimport gxmisc\r\nimport winapi\r\n\r\n!import test\r\n\r\nglobal var hwapplic=nil\r\nglobal var hwchild=nil\r\nglobal var iswin32\r\nglobal var screendc\r\n\r\n!const int maxfont=200\r\nglobal var nglobalfonts=0\r\nglobal var fonttable=()\t\t\t![]font handles\r\nglobal var fontdimtable=()\t\t![]rpoint (width,total line height)\r\nglobal var fontvdimtable=()\t\t![]rpoint (ascenders, descenders) \r\n\r\nproc start\t=\t\t!START\r\n\r\ninitdata()\r\nend\r\n\r\nproc main=\t\t\t!MAIN\r\nstart()\r\nend\r\n\r\nproc initdata=\t\t\t\t\t\t!INITDATA\r\niswin32:=(getos()=\"W32\")\r\n!setmesshandler(^processmessage)\r\nscreendc:=getdc(0)\r\n\r\nfonttable:=(0,)*20\r\nfontdimtable:=(0,)*20\r\nfontvdimtable:=(0,)*20\r\n\r\nfonttable[1]:=getstockobject(17)\t!default gui\r\nfonttable[2]:=getstockobject(13)\t!system font\r\nfonttable[3]:=getstockobject(16)\t!system fixed\r\nfonttable[4]:=getstockobject(10)\t!oem fixed\r\nfor i:=1 to 4 do\r\n fontdimtable[i]:=ws_point(0,0)\r\n fontvdimtable[i]:=ws_point(0,0)\r\nod\r\nnglobalfonts:=4\r\n\r\n!messagequeue:=new(list,100)\r\n!nmessages:=0\r\n\r\nend\r\n\r\nfunction checkoption(optionnames,optionvalues,name,default=-1)=\t\t!CHECKOPTION\r\n!search for option with given name\r\n!return value of option, or -1 if not present\r\n!options (which can be void) will be a list of (name,value) list pairs\r\n\r\nn:=name in optionnames\r\nif not n then return default fi\r\nreturn optionvalues[n]\r\nend\r\n\r\nglobal proc wx_waitmess=\t\t\t\t!WAITMESS\r\nwindmsg:=new((iswin32|ws_msg32|ws_msg64))\r\n\r\ndo\r\n\tif getmessage(&windmsg,0,0,0)<>0 then\r\n\t\tw:=windmsg.hwnd\r\nCPL \"WM2 GOT MESSAGE\",windmsg.message,WINMESSAGENAMES{WINDMSG.MESSAGE}\r\n\t\tif windmsg.message=wm_keydown and windmsg.wparam=27 then exit fi\r\n\t\tif windmsg.message=wm_timer then CPL \"TIMER!!\" fi\r\n\t\ttranslatemessage(&windmsg)\r\n\t!\tif not processmessage(windmsg) then\r\n\t\tdispatchmessage(&windmsg)\r\n\t!\tfi\r\n\t\tif windmsg.message=wm_close then exit fi\r\n\telse\r\n\t\tCPL \"EXITING WAITMESS\"\r\n\t\texit\r\n\tfi\r\nod\r\nend\r\n\r\nglobal function wx_getw(hwnd)=\r\n!return allwindow-index of window that has been stored into it\r\n\r\nn:=getwindowlongptr(hwnd, gwl_userdata)\r\nreturn n\r\nend\r\n\r\nglobal proc wx_setw(hwnd,index)=\r\n!store mm window handle into win32 window\r\n!index is .gindex (index into allwindows)\r\nsetwindowlongptr(hwnd, gwl_userdata, index)\r\nend\r\n\r\nglobal function wx_gettextwidth(hdc,s)=\r\nsize:=new(ws_point)\r\ngettextextentpoint32(hdc,s,s.len,&size)\r\nreturn size.x\r\nend\r\n\r\nglobal function wx_createpopup(?caption,?pos,?dim,?options,owner=nil)=\t!CREATEPOPUP\r\n!wrapper around win32 createwindow\r\n!return win32 handle to newly created window\r\nconst gap=40\r\nconst smallestwidth=150\r\n\r\nif options.isvoid then\r\n options:=[wf_caption:1,wf_border:wbs_resize]\r\nfi\r\n\r\nposx:=posy:=-1\r\ndimx:=640\r\ndimy:=480\r\nfcentre:=0\r\nfautopos:=0\r\nfmax:=fdesktop:=0\r\n\r\nif caption.isvoid then caption:=\"<No Caption>\" fi\r\n\r\nif dim.defined then\r\n\tif dim.isstring and dim=\"max\" then\r\n\t\tfmax:=1\r\n\telsif dim.isstring and dim=\"desktop\" then\r\n\t\tfdesktop:=1\r\n\telse\r\n\t\tdimx:=dim[1]\r\n\t\tdimy:=dim[2]\r\n\tfi\r\nfi\r\n\r\nif pos.isvoid or pos=\"cent\" then\r\n\tfcentre:=1\r\nelsif pos=\"auto\" then\r\n\tfautopos:=1\r\nelsif pos.defined and not pos.isstring then\r\n\tposx:=pos[1]\r\n\tposy:=pos[2]\r\nelse\t\t\t\t!check options?\r\n\tabort(\"gxcw bad pos\")\r\nfi\r\n\r\nbstyle:=bxstyle:=0\r\nnocap:=0\t\t\t!whether to suppress caption\r\n\r\nframex:=framey:=0\r\n\r\n!note: can only reliably work out the frame thickness for:\r\n! border = none, simple, thick, resize\r\n!for others, a value is used based on comparing frame/client sizes on test cases\r\n!Otherwise: best not to use 'iframe:1' option as overall frame dimensions\r\n!may not be what is requested.\r\n\r\ncase options{wf_border,wbs_resize}\r\nwhen wbs_none then\t\t!no border\r\n\tnocap:=1\r\n\tframex:=0\r\n\tframey:=0\r\nwhen wbs_simple then\t\t!single line\r\n\tnocap:=1\r\n\tbstyle:=ws_border\r\n\tframex:=1\r\n\tframey:=1\r\nwhen wbs_thick then\t\t!thick line\r\n\tbstyle:=ws_dlgframe\r\n\tfixedframe:=0\r\n\tframex:=getsystemmetrics(sm_cxfixedframe)\r\n\tframey:=getsystemmetrics(sm_cyfixedframe)\r\nwhen wbs_resize then\r\n\tbstyle:=ws_sizebox\r\n\tframex:=getsystemmetrics(sm_cxsizeframe)\r\n\tframey:=getsystemmetrics(sm_cysizeframe)\r\nwhen wbs_sunken,wbs_sunken2 then\t\t!sunken\r\n\tbstyle:=ws_dlgframe\r\n\tbxstyle:=ws_ex_clientedge\r\n!\tframex:=getsystemmetrics(sm_cxdlgframe)\r\n!\tframey:=getsystemmetrics(sm_cydlgframe)\r\n\tframex:=5\r\n\tframey:=5\r\nwhen wbs_sunkenrs then\r\n\tbstyle:=ws_sizebox\r\n\tbxstyle:=ws_ex_clientedge\r\n\tframex:=6\r\n\tframey:=6\r\nesac\r\n\r\ncapheight:=getsystemmetrics(sm_cycaption)\r\nmbheight:=getsystemmetrics(sm_cymenu)\r\n\r\nstyle:=0\r\nexstyle:=0\r\n\r\nif options{wf_show,1} then\r\n\tstyle ior:=ws_visible\r\nfi\r\n\r\nmxleft:=framex\r\nmxright:=framey\r\nmytop:=framey+capheight\r\nmybottom:=framey\r\nshowstyle:=sw_shownormal\r\n\r\nhcwmenu:=0\r\nif options{wf_menu,0}=1 then\r\n\tmytop+:=mbheight\r\n\thcwmenu:=createmenu()\r\n\tappendmenu(hcwmenu,0,998,\"fred\")\r\nfi\r\n\r\nstyle ior:=ws_clipchildren\r\n\r\n!STYLE IOR:=WS_OVERLAPPEDWINDOW\r\n\r\nif nocap or options{wf_caption,1}=0 then\r\n!CPL \"NO CAP:**********************\"\r\n\tmytop-:=capheight\r\n\tstyle ior:=ws_popup\r\n!else\r\n! style ior:=ws_overlappedwindow\r\nfi\r\n\r\n\r\n!if checkoption(optionnames,optionvalues,\"iframe\",0)=1 then\r\nif options{wf_iframe,0}=0 then\r\n\tif not fautopos then\r\n\t\tposx-:=mxleft\r\n\t\tposy-:=mytop\r\n\tfi\r\n\tdimx+:=mxleft+mxright\r\n\tdimy+:=mytop+mybottom\r\nfi\r\n\r\nif fcentre or options{wf_cent,0}=1 then\r\n\tfautopos:=0\r\n\tbox:=new(ws_rect)\r\n\tsystemparametersinfoa(spi_getworkarea,0,&box,0)\r\n\tposx:=box.rightx%2-dimx%2\r\n\tposy:=(box.bottom-box.top)%2-dimy%2+box.top\r\nfi\r\n\r\nif fmax or options{wf_max,0} then\r\n\tshowstyle:=sw_maximize\r\n\tstyle ior:=ws_maximize\r\nfi\r\n\r\n\r\nif options{wf_minmax,1}=1 then\r\n\tstyle ior:=(ws_maximizebox ior ws_minimizebox)\r\n\r\nfi\r\n\r\nif options{wf_sysmenu,1}=1 then\r\n\tstyle ior:=ws_sysmenu\r\nfi\r\n\r\nif fautopos=0 and options{wf_clip,0}=1 then\r\n\tbox:=new(ws_rect)\r\n\tsystemparametersinfoa(spi_getworkarea,0,&box,0)\r\n\r\n\tif posx<box.leftx+gap then posx:=box.leftx+gap fi\r\n\r\n\tif posy<box.top+gap then posy:=box.top+gap fi\r\n\tdimxmin:=dimx max smallestwidth\r\n\tif posx+dimxmin>=box.rightx+gap then posx:=box.rightx-gap-dimxmin fi\r\n\tif posy+dimy>=box.bottom+gap then posy:=box.bottom-gap-dimy fi\r\nelsif fautopos then\r\n\tposx:=posy:=cw_usedefault\r\nfi\r\n\r\nif fdesktop or options{wf_desktop,0}=1 then\r\n\tbox:=new(ws_rect)\r\n\tsystemparametersinfoa(spi_getworkarea,0,&box,0)\r\n\tposx:=box.leftx\r\n\tposy:=box.top\r\n\tdimx:=box.rightx-box.leftx\r\n\tdimy:=box.bottom-box.top\r\nfi\r\n\r\nif options{wf_toolwind,0}=1 then\r\n\texstyle ior:=ws_ex_toolwindow\r\nfi\r\n\r\nclassname:=\"pcc001\"\r\n\r\nSTYLE IOR:=WS_VISIBLE\r\n\r\nstyle ior:=bstyle\r\nexstyle ior:=bxstyle\r\n!\r\n!style ior:=cs_dblclks\r\n\r\nhwnd:=createwindowex(\r\n\texstyle,\r\n\tclassname,\r\n\tcaption,\r\n\tstyle,\r\n\tposx,posy,\t\t\t!initial position and size\r\n\tdimx,dimy,\r\n\towner,\t\t\t!will be 0 for 1st window, other popups use hwapplic as owner\r\n\thcwmenu,\t\t\t!menu handle\r\n\t0,\t!proginstance,\t\t!instance handle\r\n\tnil)\t\t\t!creation params\r\n\r\nif hwnd=0 then\r\n\te:=getlasterror()\r\n\tabort(\"wx:Can't create popup window \"+tostr(e))\r\nfi\r\nreturn hwnd\r\nend\r\n\r\nglobal function wx_createcontrol(?pos,?dim,border=wbs_simple,owner)=\t!CREATECONTROL\r\n!wrapper around win32 createwindow\r\n!return win32 handle to newly created window\r\nconst gap=40\r\nconst smallestwidth=150\r\n\r\nposx:=posy:=0\r\ndimx:=160\r\ndimy:=120\r\n\r\nif dim.defined then\r\n\tdimx:=dim[1]\r\n\tdimy:=dim[2]\r\nfi\r\n\r\nif pos.defined then\r\n\tposx:=pos[1]\r\n\tposy:=pos[2]\r\nfi\r\n\r\nbstyle:=bxstyle:=0\r\n\r\ncase border\r\nwhen wbs_none then\t\t!no border\r\nwhen wbs_simple then\t\t!single line\r\n\tbstyle:=ws_border\r\n!when wbs_thick then\t\t!thick line\r\n!\tbstyle:=ws_dlgframe\r\n!\tfixedframe:=0\r\n!\tframex:=getsystemmetrics(sm_cxfixedframe)\r\n!\tframey:=getsystemmetrics(sm_cyfixedframe)\r\nelse\r\n\tpcerror(\"createcontrol/bad border \"+wbsnames[border])\r\nesac\r\n\r\nstyle:=0\r\nexstyle:=0\r\n\r\n!showstyle:=sw_shownormal\r\n\r\n!if scroll.[0] then\r\n!\tstyle ior:=ws_hscroll\r\n!\tmybottom+:=getsystemmetrics(sm_cyhscroll)\r\n!fi\r\n\r\n!if scroll.[1] then\r\n!\tstyle ior:=ws_vscroll\r\n!\tmxright+:=getsystemmetrics(sm_cxvscroll)\r\n!fi\r\n\r\nstyle ior:=ws_clipchildren\r\n\r\nclassname:=\"pcc001\"\r\n\r\nstyle ior:=ws_child\r\nstyle ior:=ws_visible\r\n\r\nstyle ior:=bstyle\r\nexstyle ior:=bxstyle\r\n\r\nhwnd:=createwindowex(\r\n\texstyle,\r\n\tclassname,\r\n\t0,\r\n\tstyle,\r\n\tposx,posy,\t\t\t!initial position and size\r\n\tdimx,dimy,\r\n\towner,\t\t\t!will be 0 for 1st window, other popups use hwapplic as owner\r\n\t0,\t\t\t\t!menu handle\r\n\t0,\t!proginstance,\t\t!instance handle\r\n\tnil)\t\t\t!creation params\r\n\r\nCPL \"CONTRPL\",=EXSTYLE,=STYLE,=POSX,POSY,=DIMX,DIMY\r\n\r\n\r\nif hwnd=0 then\r\n\te:=getlasterror()\r\n\tabort(\"wx:Can't create child window \"+tostr(e))\r\nfi\r\n\r\nreturn hwnd\r\nend\r\n\r\n",
    \
(uint8_t*)"global var winmessagenames=[\r\n\t(0:\"wm_null\"),\r\n\t(1:\"wm_create\"),\r\n\t(2:\"wm_destroy\"),\r\n\t(3:\"wm_move\"),\r\n\t(4:\"pgk_menu\"),\r\n\t(5:\"wm_size\"),\r\n\t(6:\"wm_activate\"),\r\n\t(7:\"wm_setfocus\"),\r\n\t(8:\"wm_killfocus\"),\r\n\t(9:\"cbn_selendok\"),\r\n\t(10:\"wm_enable\"),\r\n\t(11:\"wm_setredraw\"),\r\n\t(12:\"wm_settext\"),\r\n\t(13:\"wm_gettext\"),\r\n\t(14:\"wm_gettextlength\"),\r\n\t(15:\"wm_paint\"),\r\n\t(16:\"wm_close\"),\r\n\t(17:\"wm_queryendsession\"),\r\n\t(18:\"wm_quit\"),\r\n\t(19:\"wm_queryopen\"),\r\n\t(20:\"wm_erasebkgnd\"),\r\n\t(21:\"wm_syscolorchange\"),\r\n\t(22:\"wm_endsession\"),\r\n\t(24:\"wm_showwindow\"),\r\n\t(26:\"wm_wininichange\"),\r\n\t(27:\"wm_devmodechange\"),\r\n\t(28:\"wm_activateapp\"),\r\n\t(29:\"wm_fontchange\"),\r\n\t(30:\"wm_timechange\"),\r\n\t(31:\"wm_cancelmode\"),\r\n\t(32:\"wm_setcursor\"),\r\n\t(33:\"wm_mouseactivate\"),\r\n\t(34:\"wm_childactivate\"),\r\n\t(35:\"wm_queuesync\"),\r\n\t(36:\"wm_getminmaxinfo\"),\r\n\t(38:\"wm_painticon\"),\r\n\t(39:\"wm_iconerasebkgnd\"),\r\n\t(40:\"wm_nextdlgctl\"),\r\n\t(42:\"wm_spoolerstatus\"),\r\n\t(43:\"wm_drawitem\"),\r\n\t(44:\"wm_measureitem\"),\r\n\t(45:\"wm_deleteitem\"),\r\n\t(46:\"wm_vkeytoitem\"),\r\n\t(47:\"wm_chartoitem\"),\r\n\t(48:\"wm_setfont\"),\r\n\t(49:\"wm_getfont\"),\r\n\t(50:\"wm_sethotkey\"),\r\n\t(51:\"wm_gethotkey\"),\r\n\t(55:\"wm_querydragicon\"),\r\n\t(57:\"wm_compareitem\"),\r\n\t(64:\"tbif_size\"),\r\n\t(65:\"wm_compacting\"),\r\n\t(70:\"wm_windowposchanging\"),\r\n\t(71:\"wm_windowposchanged\"),\r\n\t(72:\"wm_power\"),\r\n\t(74:\"wm_copydata\"),\r\n\t(75:\"wm_canceljournal\"),\r\n\t(78:\"wm_notify\"),\r\n\t(80:\"wm_inputlangchangerequest\"),\r\n\t(81:\"wm_inputlangchange\"),\r\n\t(82:\"wm_tcard\"),\r\n\t(83:\"wm_help\"),\r\n\t(84:\"wm_userchanged\"),\r\n\t(85:\"wm_notifyformat\"),\r\n\t(123:\"wm_contextmenu\"),\r\n\t(124:\"wm_stylechanging\"),\r\n\t(125:\"wm_stylechanged\"),\r\n\t(126:\"wm_displaychange\"),\r\n\t(127:\"wm_geticon\"),\r\n\t(128:\"wm_seticon\"),\r\n\t(129:\"wm_nccreate\"),\r\n\t(130:\"wm_ncdestroy\"),\r\n\t(131:\"wm_nccalcsize\"),\r\n\t(132:\"wm_nchittest\"),\r\n\t(133:\"wm_ncpaint\"),\r\n\t(134:\"wm_ncactivate\"),\r\n\t(135:\"wm_getdlgcode\"),\r\n\t(160:\"wm_ncmousemove\"),\r\n\t(161:\"wm_nclbuttondown\"),\r\n\t(162:\"wm_nclbuttonup\"),\r\n\t(163:\"wm_nclbuttondblclk\"),\r\n\t(164:\"wm_ncrbuttondown\"),\r\n\t(165:\"wm_ncrbuttonup\"),\r\n\t(166:\"wm_ncrbuttondblclk\"),\r\n\t(167:\"wm_ncmbuttondown\"),\r\n\t(168:\"wm_ncmbuttonup\"),\r\n\t(169:\"wm_ncmbuttondblclk\"),\r\n\t(176:\"em_getsel\"),\r\n\t(177:\"em_setsel\"),\r\n\t(178:\"em_getrect\"),\r\n\t(179:\"em_setrect\"),\r\n\t(180:\"em_setrectnp\"),\r\n\t(181:\"em_scroll\"),\r\n\t(182:\"em_linescroll\"),\r\n\t(183:\"em_scrollcaret\"),\r\n\t(184:\"em_getmodify\"),\r\n\t(185:\"em_setmodify\"),\r\n\t(186:\"em_getlinecount\"),\r\n\t(187:\"em_lineindex\"),\r\n\t(188:\"em_sethandle\"),\r\n\t(189:\"em_gethandle\"),\r\n\t(190:\"em_getthumb\"),\r\n\t(193:\"em_linelength\"),\r\n\t(194:\"em_replacesel\"),\r\n\t(196:\"em_getline\"),\r\n\t(197:\"em_setlimittext\"),\r\n\t(198:\"em_canundo\"),\r\n\t(199:\"em_undo\"),\r\n\t(200:\"em_fmtlines\"),\r\n\t(201:\"em_linefromchar\"),\r\n\t(203:\"em_settabstops\"),\r\n\t(204:\"em_setpasswordchar\"),\r\n\t(205:\"em_emptyundobuffer\"),\r\n\t(206:\"em_getfirstvisibleline\"),\r\n\t(207:\"em_setreadonly\"),\r\n\t(208:\"em_setwordbreakproc\"),\r\n\t(209:\"em_getwordbreakproc\"),\r\n\t(210:\"em_getpasswordchar\"),\r\n\t(211:\"em_setmargins\"),\r\n\t(212:\"em_getmargins\"),\r\n\t(213:\"em_getlimittext\"),\r\n\t(214:\"em_posfromchar\"),\r\n\t(215:\"em_charfrompos\"),\r\n\t(224:\"sbm_setpos\"),\r\n\t(225:\"sbm_getpos\"),\r\n\t(226:\"sbm_setrange\"),\r\n\t(227:\"sbm_getrange\"),\r\n\t(228:\"sbm_enable_arrows\"),\r\n\t(230:\"sbm_setrangeredraw\"),\r\n\t(233:\"sbm_setscrollinfo\"),\r\n\t(234:\"sbm_getscrollinfo\"),\r\n\t(240:\"bm_getcheck\"),\r\n\t(241:\"bm_setcheck\"),\r\n\t(242:\"bm_getstate\"),\r\n\t(243:\"bm_setstate\"),\r\n\t(244:\"bm_setstyle\"),\r\n\t(245:\"bm_click\"),\r\n\t(246:\"bm_getimage\"),\r\n\t(247:\"bm_setimage\"),\r\n\t(255:\"wm_input\"),\r\n\t(256:\"wm_keydown\"),\r\n\t(257:\"wm_keyup\"),\r\n\t(258:\"wm_char\"),\r\n\t(259:\"wm_deadchar\"),\r\n\t(260:\"wm_syskeydown\"),\r\n\t(261:\"wm_syskeyup\"),\r\n\t(262:\"wm_syschar\"),\r\n\t(263:\"wm_sysdeadchar\"),\r\n\t(269:\"wm_ime_startcomposition\"),\r\n\t(270:\"wm_ime_endcomposition\"),\r\n\t(271:\"wm_ime_composition\"),\r\n\t(272:\"wm_initdialog\"),\r\n\t(273:\"wm_command\"),\r\n\t(274:\"wm_syscommand\"),\r\n\t(275:\"wm_timer\"),\r\n\t(276:\"wm_hscroll\"),\r\n\t(277:\"wm_vscroll\"),\r\n\t(278:\"wm_initmenu\"),\r\n\t(279:\"wm_initmenupopup\"),\r\n\t(287:\"wm_menuselect\"),\r\n\t(288:\"wm_menuchar\"),\r\n\t(289:\"wm_enteridle\"),\r\n\t(290:\"wm_menurbuttonup\"),\r\n\t(295:\"wm_changeuistate\"),\r\n\t(296:\"wm_updateuistate\"),\r\n\t(297:\"wm_queryuistate\"),\r\n\t(306:\"wm_ctlcolormsgbox\"),\r\n\t(307:\"wm_ctlcoloredit\"),\r\n\t(308:\"wm_ctlcolorlistbox\"),\r\n\t(309:\"wm_ctlcolorbtn\"),\r\n\t(310:\"wm_ctlcolordlg\"),\r\n\t(311:\"wm_ctlcolorscrollbar\"),\r\n\t(312:\"wm_ctlcolorstatic\"),\r\n\t(320:\"cb_geteditsel\"),\r\n\t(321:\"cb_limittext\"),\r\n\t(322:\"cb_seteditsel\"),\r\n\t(323:\"cb_addstring\"),\r\n\t(324:\"cbem_deleteitem\"),\r\n\t(325:\"cb_dir\"),\r\n\t(326:\"cb_getcount\"),\r\n\t(327:\"cb_getcursel\"),\r\n\t(328:\"cb_getlbtext\"),\r\n\t(329:\"cb_getlbtextlen\"),\r\n\t(330:\"cb_insertstring\"),\r\n\t(331:\"cb_resetcontent\"),\r\n\t(332:\"cb_findstring\"),\r\n\t(333:\"cb_selectstring\"),\r\n\t(334:\"cb_setcursel\"),\r\n\t(335:\"cb_showdropdown\"),\r\n\t(336:\"cb_getitemdata\"),\r\n\t(337:\"cb_setitemdata\"),\r\n\t(338:\"cb_getdroppedcontrolrect\"),\r\n\t(339:\"cb_setitemheight\"),\r\n\t(340:\"cb_getitemheight\"),\r\n\t(341:\"cb_setextendedui\"),\r\n\t(342:\"cb_getextendedui\"),\r\n\t(343:\"cb_getdroppedstate\"),\r\n\t(344:\"cb_findstringexact\"),\r\n\t(345:\"cb_setlocale\"),\r\n\t(346:\"cb_getlocale\"),\r\n\t(347:\"cb_gettopindex\"),\r\n\t(348:\"cb_settopindex\"),\r\n\t(349:\"cb_gethorizontalextent\"),\r\n\t(350:\"cb_sethorizontalextent\"),\r\n\t(351:\"cb_getdroppedwidth\"),\r\n\t(352:\"cb_setdroppedwidth\"),\r\n\t(353:\"cb_initstorage\"),\r\n\t(368:\"stm_seticon\"),\r\n\t(369:\"stm_geticon\"),\r\n\t(370:\"stm_setimage\"),\r\n\t(371:\"stm_getimage\"),\r\n\t(384:\"lb_addstring\"),\r\n\t(385:\"lb_insertstring\"),\r\n\t(386:\"lb_deletestring\"),\r\n\t(387:\"lb_selitemrangeex\"),\r\n\t(388:\"lb_resetcontent\"),\r\n\t(389:\"lb_setsel\"),\r\n\t(390:\"lb_setcursel\"),\r\n\t(391:\"lb_getsel\"),\r\n\t(392:\"lb_getcursel\"),\r\n\t(393:\"lb_gettext\"),\r\n\t(394:\"lb_gettextlen\"),\r\n\t(395:\"lb_getcount\"),\r\n\t(396:\"lb_selectstring\"),\r\n\t(397:\"lb_dir\"),\r\n\t(398:\"lb_gettopindex\"),\r\n\t(399:\"lb_findstring\"),\r\n\t(400:\"lb_getselcount\"),\r\n\t(401:\"lb_getselitems\"),\r\n\t(402:\"lb_settabstops\"),\r\n\t(403:\"lb_gethorizontalextent\"),\r\n\t(404:\"lb_sethorizontalextent\"),\r\n\t(405:\"lb_setcolumnwidth\"),\r\n\t(406:\"lb_addfile\"),\r\n\t(407:\"lb_settopindex\"),\r\n\t(408:\"lb_getitemrect\"),\r\n\t(409:\"lb_getitemdata\"),\r\n\t(410:\"lb_setitemdata\"),\r\n\t(411:\"lb_selitemrange\"),\r\n\t(412:\"lb_setanchorindex\"),\r\n\t(413:\"lb_getanchorindex\"),\r\n\t(414:\"lb_setcaretindex\"),\r\n\t(415:\"lb_getcaretindex\"),\r\n\t(416:\"lb_setitemheight\"),\r\n\t(417:\"lb_getitemheight\"),\r\n\t(418:\"lb_findstringexact\"),\r\n\t(421:\"lb_setlocale\"),\r\n\t(422:\"lb_getlocale\"),\r\n\t(423:\"lb_setcount\"),\r\n\t(424:\"lb_initstorage\"),\r\n\t(425:\"lb_itemfrompoint\"),\r\n\t(512:\"wm_mousemove\"),\r\n\t(513:\"wm_lbuttondown\"),\r\n\t(514:\"wm_lbuttonup\"),\r\n\t(515:\"wm_lbuttondblclk\"),\r\n\t(516:\"wm_rbuttondown\"),\r\n\t(517:\"wm_rbuttonup\"),\r\n\t(518:\"wm_rbuttondblclk\"),\r\n\t(519:\"wm_mbuttondown\"),\r\n\t(520:\"wm_mbuttonup\"),\r\n\t(521:\"wm_mbuttondblclk\"),\r\n\t(522:\"wm_mousewheel\"),\r\n\t(523:\"wm_xbuttondown\"),\r\n\t(524:\"wm_xbuttonup\"),\r\n\t(525:\"wm_xbuttondblclk\"),\r\n\t(528:\"wm_parentnotify\"),\r\n\t(529:\"wm_entermenuloop\"),\r\n\t(530:\"wm_exitmenuloop\"),\r\n\t(531:\"wm_nextmenu\"),\r\n\t(532:\"wm_sizing\"),\r\n\t(533:\"wm_capturechanged\"),\r\n\t(534:\"wm_moving\"),\r\n\t(536:\"wm_powerbroadcast\"),\r\n\t(537:\"wm_devicechange\"),\r\n\t(544:\"wm_mdicreate\"),\r\n\t(545:\"wm_mdidestroy\"),\r\n\t(546:\"wm_mdiactivate\"),\r\n\t(547:\"wm_mdirestore\"),\r\n\t(548:\"wm_mdinext\"),\r\n\t(549:\"wm_mdimaximize\"),\r\n\t(550:\"wm_mditile\"),\r\n\t(551:\"wm_mdicascade\"),\r\n\t(552:\"wm_mdiiconarrange\"),\r\n\t(553:\"wm_mdigetactive\"),\r\n\t(560:\"wm_mdisetmenu\"),\r\n\t(561:\"wm_entersizemove\"),\r\n\t(562:\"wm_exitsizemove\"),\r\n\t(563:\"wm_dropfiles\"),\r\n\t(564:\"wm_mdirefreshmenu\"),\r\n\t(641:\"wm_ime_setcontext\"),\r\n\t(642:\"wm_ime_notify\"),\r\n\t(643:\"wm_ime_control\"),\r\n\t(644:\"wm_ime_compositionfull\"),\r\n\t(645:\"wm_ime_select\"),\r\n\t(646:\"wm_ime_char\"),\r\n\t(656:\"wm_ime_keydown\"),\r\n\t(657:\"wm_ime_keyup\"),\r\n\t(673:\"wm_mousehover\"),\r\n\t(675:\"wm_mouseleave\"),\r\n\t(689:\"wm_wtssession_change\"),\r\n\t(768:\"wm_cut\"),\r\n\t(769:\"wm_copy\"),\r\n\t(770:\"wm_paste\"),\r\n\t(771:\"wm_clear\"),\r\n\t(772:\"wm_undo\"),\r\n\t(773:\"wm_renderformat\"),\r\n\t(774:\"wm_renderallformats\"),\r\n\t(775:\"wm_destroyclipboard\"),\r\n\t(776:\"wm_drawclipboard\"),\r\n\t(777:\"wm_paintclipboard\"),\r\n\t(778:\"wm_vscrollclipboard\"),\r\n\t(779:\"wm_sizeclipboard\"),\r\n\t(780:\"wm_askcbformatname\"),\r\n\t(781:\"wm_changecbchain\"),\r\n\t(782:\"wm_hscrollclipboard\"),\r\n\t(783:\"wm_querynewpalette\"),\r\n\t(784:\"wm_paletteischanging\"),\r\n\t(785:\"wm_palettechanged\"),\r\n\t(786:\"wm_hotkey\"),\r\n\t(791:\"wm_print\"),\r\n\t(792:\"wm_printclient\"),\r\n\t(896:\"wm_penwinirst\"),\r\n\t(911:\"wm_penwinlast\"),\r\n\t(1024:\"infotipsize\"),\r\n\t(1025:\"cbem_insertitema\"),\r\n\t(1026:\"cbem_setimagelist\"),\r\n\t(1027:\"cbem_getimagelist\"),\r\n\t(1028:\"cbem_getitema\"),\r\n\t(1029:\"cbem_setitema\"),\r\n\t(1030:\"cbem_getcombocontrol\"),\r\n\t(1031:\"cbem_geteditcontrol\"),\r\n\t(1032:\"cbem_setexstyle\"),\r\n\t(1033:\"cbem_getextendedstyle\"),\r\n\t(1034:\"cbem_haseditchanged\"),\r\n\t(1035:\"cbem_insertitemw\"),\r\n\t(1036:\"cbem_setitemw\"),\r\n\t(1037:\"cbem_getitemw\"),\r\n\t(1038:\"cbem_setextendedstyle\"),\r\n\t(1039:\"ttm_getcurrenttoola\"),\r\n\t(1040:\"ttm_windowfrompoint\"),\r\n\t(1041:\"ttm_trackactivate\"),\r\n\t(1042:\"ttm_trackposition\"),\r\n\t(1043:\"ttm_settipbkcolor\"),\r\n\t(1044:\"ttm_settiptextcolor\"),\r\n\t(1045:\"ttm_getdelaytime\"),\r\n\t(1046:\"ttm_gettipbkcolor\"),\r\n\t(1047:\"ttm_gettiptextcolor\"),\r\n\t(1048:\"ttm_setmaxtipwidth\"),\r\n\t(1049:\"ttm_getmaxtipwidth\"),\r\n\t(1050:\"ttm_setmargin\"),\r\n\t(1051:\"ttm_getmargin\"),\r\n\t(1052:\"ttm_pop\"),\r\n\t(1053:\"tb_getitemrect\"),\r\n\t(1054:\"tb_buttonstructsize\"),\r\n\t(1055:\"tb_setbuttonsize\"),\r\n\t(1056:\"tb_setbitmapsize\"),\r\n\t(1057:\"tb_autosize\"),\r\n\t(1059:\"tb_gettooltips\"),\r\n\t(1060:\"tb_settooltips\"),\r\n\t(1061:\"tb_setparent\"),\r\n\t(1063:\"tb_setrows\"),\r\n\t(1064:\"tb_getrows\"),\r\n\t(1065:\"tb_getbitmapflags\"),\r\n\t(1066:\"tb_setcmdid\"),\r\n\t(1067:\"tb_changebitmap\"),\r\n\t(1068:\"tb_getbitmap\"),\r\n\t(1069:\"tb_getbuttontexta\"),\r\n\t(1070:\"tb_replacebitmap\"),\r\n\t(1071:\"tb_setindent\"),\r\n\t(1072:\"tb_setimagelist\"),\r\n\t(1073:\"tb_getimagelist\"),\r\n\t(1074:\"ttm_addtoolw\"),\r\n\t(1075:\"ttm_deltoolw\"),\r\n\t(1076:\"ttm_newtoolrectw\"),\r\n\t(1077:\"ttm_gettoolinfow\"),\r\n\t(1078:\"ttm_settoolinfow\"),\r\n\t(1079:\"ttm_hittestw\"),\r\n\t(1080:\"ttm_gettextw\"),\r\n\t(1081:\"ttm_updatetiptextw\"),\r\n\t(1082:\"ttm_enumtoolsw\"),\r\n\t(1083:\"ttm_getcurrenttoolw\"),\r\n\t(1084:\"tb_setmaxtextrows\"),\r\n\t(1085:\"tb_gettextrows\"),\r\n\t(1086:\"em_getseltext\"),\r\n\t(1087:\"em_hideselection\"),\r\n\t(1088:\"em_pastespecial\"),\r\n\t(1089:\"em_requestresize\"),\r\n\t(1090:\"em_selectiontype\"),\r\n\t(1091:\"tb_insertbuttonw\"),\r\n\t(1092:\"tb_addbuttonsw\"),\r\n\t(1093:\"tb_hittest\"),\r\n\t(1094:\"em_setolecallback\"),\r\n\t(1095:\"em_setparaformat\"),\r\n\t(1096:\"em_settargetdevice\"),\r\n\t(1097:\"em_streamin\"),\r\n\t(1098:\"em_streamout\"),\r\n\t(1099:\"tb_getbuttontextw\"),\r\n\t(1100:\"tb_saverestorew\"),\r\n\t(1101:\"tb_addstringw\"),\r\n\t(1102:\"em_getoptions\"),\r\n\t(1103:\"tb_getinsertmark\"),\r\n\t(1104:\"tb_setinsertmark\"),\r\n\t(1105:\"tb_insertmarkhittest\"),\r\n\t(1106:\"tb_movebutton\"),\r\n\t(1107:\"tb_getmaxsize\"),\r\n\t(1108:\"tb_setextendedstyle\"),\r\n\t(1109:\"tb_getextendedstyle\"),\r\n\t(1110:\"tb_getpadding\"),\r\n\t(1111:\"tb_setpadding\"),\r\n\t(1112:\"tb_setinsertmarkcolor\"),\r\n\t(1113:\"tb_getinsertmarkcolor\"),\r\n\t(1114:\"tb_mapacceleratorw\"),\r\n\t(1124:\"em_setpunctuation\"),\r\n\t(1125:\"wm_choosefont_setlogfont\"),\r\n\t(1126:\"wm_choosefont_setflags\"),\r\n\t(1127:\"udm_setpos\"),\r\n\t(1128:\"udm_getpos\"),\r\n\t(1129:\"udm_setbuddy\"),\r\n\t(1130:\"udm_getbuddy\"),\r\n\t(1131:\"udm_setaccel\"),\r\n\t(1132:\"udm_getaccel\"),\r\n\t(1133:\"udm_setbase\"),\r\n\t(1134:\"udm_getbase\"),\r\n\t(1135:\"psm_settitlea\"),\r\n\t(1136:\"psm_setwizbuttons\"),\r\n\t(1137:\"psm_pressbutton\"),\r\n\t(1138:\"psm_setcurselid\"),\r\n\t(1139:\"psm_setfinishtexta\"),\r\n\t(1140:\"psm_gettabcontrol\"),\r\n\t(1141:\"psm_isdialogmessage\"),\r\n\t(1142:\"psm_getcurrentpagehwnd\"),\r\n\t(1144:\"psm_settitlew\"),\r\n\t(1145:\"psm_setfinishtextw\"),\r\n\t(1157:\"dl_begindrag\"),\r\n\t(1158:\"dl_dragging\"),\r\n\t(1159:\"dl_dropped\"),\r\n\t(1160:\"dl_canceldrag\"),\r\n\t(1280:\"en_errspace\"),\r\n\t(1281:\"en_maxtext\"),\r\n\t(1537:\"en_hscroll\"),\r\n\t(1538:\"en_vscroll\"),\r\n\t(1792:\"en_msgfilter\"),\r\n\t(1793:\"en_requestresize\"),\r\n\t(1794:\"en_selchange\"),\r\n\t(1795:\"en_dropfiles\"),\r\n\t(1796:\"en_protected\"),\r\n\t(1797:\"en_correcttext\"),\r\n\t(1798:\"en_stopnoundo\"),\r\n\t(1799:\"en_imechange\"),\r\n\t(1800:\"en_saveclipboard\"),\r\n\t(1801:\"en_oleopfailed\"),\r\n\t(4096:\"lvm_getbkcolor\"),\r\n\t(4097:\"lvm_setbkcolor\"),\r\n\t(4098:\"lvm_getimagelist\"),\r\n\t(4099:\"lvm_setimagelist\"),\r\n\t(4100:\"lvm_getitemcount\"),\r\n\t(4101:\"lvm_getitema\"),\r\n\t(4102:\"lvm_setitema\"),\r\n\t(4103:\"lvm_insertitema\"),\r\n\t(4104:\"lvm_deleteitem\"),\r\n\t(4105:\"lvm_deleteallitems\"),\r\n\t(4106:\"lvm_getcallbackmask\"),\r\n\t(4107:\"lvm_setcallbackmask\"),\r\n\t(4108:\"lvm_getnextitem\"),\r\n\t(4109:\"lvm_finditema\"),\r\n\t(4110:\"lvm_getitemrect\"),\r\n\t(4111:\"lvm_setitemposition\"),\r\n\t(4112:\"lvm_getitemposition\"),\r\n\t(4113:\"lvm_getstringwidtha\"),\r\n\t(4114:\"lvm_hittest\"),\r\n\t(4115:\"lvm_ensurevisible\"),\r\n\t(4116:\"lvm_scroll\"),\r\n\t(4117:\"lvm_redrawitems\"),\r\n\t(4118:\"lvm_arrange\"),\r\n\t(4119:\"lvm_editlabela\"),\r\n\t(4120:\"lvm_geteditcontrol\"),\r\n\t(4121:\"lvm_getcolumna\"),\r\n\t(4122:\"lvm_setcolumna\"),\r\n\t(4123:\"lvm_insertcolumna\"),\r\n\t(4124:\"lvm_deletecolumn\"),\r\n\t(4125:\"lvm_getcolumnwidth\"),\r\n\t(4126:\"lvm_setcolumnwidth\"),\r\n\t(4129:\"lvm_createdragimage\"),\r\n\t(4130:\"lvm_getviewrect\"),\r\n\t(4131:\"lvm_gettextcolor\"),\r\n\t(4132:\"lvm_settextcolor\"),\r\n\t(4133:\"lvm_gettextbkcolor\"),\r\n\t(4134:\"lvm_settextbkcolor\"),\r\n\t(4135:\"lvm_gettopindex\"),\r\n\t(4136:\"lvm_getcountperpage\"),\r\n\t(4137:\"lvm_getorigin\"),\r\n\t(4138:\"lvm_update\"),\r\n\t(4139:\"lvm_setitemstate\"),\r\n\t(4140:\"lvm_getitemstate\"),\r\n\t(4141:\"lvm_getitemtexta\"),\r\n\t(4142:\"lvm_setitemtexta\"),\r\n\t(4143:\"lvm_setitemcount\"),\r\n\t(4144:\"lvm_sortitems\"),\r\n\t(4145:\"lvm_setitemposition32\"),\r\n\t(4146:\"lvm_getselectedcount\"),\r\n\t(4147:\"lvm_getitemspacing\"),\r\n\t(4148:\"lvm_getisearchstringa\"),\r\n\t(4171:\"lvm_getitemw\"),\r\n\t(4172:\"lvm_setitemw\"),\r\n\t(4173:\"lvm_insertitemw\"),\r\n\t(4179:\"lvm_finditemw\"),\r\n\t(4183:\"lvm_getstringwidthw\"),\r\n\t(4191:\"lvm_getcolumnw\"),\r\n\t(4192:\"lvm_setcolumnw\"),\r\n\t(4193:\"lvm_insertcolumnw\"),\r\n\t(4211:\"lvm_getitemtextw\"),\r\n\t(4212:\"lvm_setitemtextw\"),\r\n\t(4213:\"lvm_getisearchstringw\"),\r\n\t(4214:\"lvm_editlabelw\"),\r\n\t(4352:\"tvm_insertitema\"),\r\n\t(4353:\"tvm_deleteitem\"),\r\n\t(4354:\"tvm_expand\"),\r\n\t(4356:\"tvm_getitemrect\"),\r\n\t(4357:\"tvm_getcount\"),\r\n\t(4358:\"tvm_getindent\"),\r\n\t(4359:\"tvm_setindent\"),\r\n\t(4360:\"tvm_getimagelist\"),\r\n\t(4361:\"tvm_setimagelist\"),\r\n\t(4362:\"tvm_getnextitem\"),\r\n\t(4363:\"tvm_selectitem\"),\r\n\t(4364:\"tvm_getitema\"),\r\n\t(4365:\"tvm_setitema\"),\r\n\t(4366:\"tvm_editlabela\"),\r\n\t(4367:\"tvm_geteditcontrol\"),\r\n\t(4368:\"tvm_getvisiblecount\"),\r\n\t(4369:\"tvm_hittest\"),\r\n\t(4370:\"tvm_createdragimage\"),\r\n\t(4371:\"tvm_sortchildren\"),\r\n\t(4372:\"tvm_ensurevisible\"),\r\n\t(4373:\"tvm_sortchildrencb\"),\r\n\t(4374:\"tvm_endeditlabelnow\"),\r\n\t(4375:\"tvm_getisearchstringa\"),\r\n\t(4402:\"tvm_insertitemw\"),\r\n\t(4414:\"tvm_getitemw\"),\r\n\t(4415:\"tvm_setitemw\"),\r\n\t(4416:\"tvm_getisearchstringw\"),\r\n\t(4417:\"tvm_editlabelw\"),\r\n\t(4608:\"hdm_getitemcount\"),\r\n\t(4609:\"hdm_insertitema\"),\r\n\t(4610:\"hdm_deleteitem\"),\r\n\t(4611:\"hdm_getitema\"),\r\n\t(4612:\"hdm_setitema\"),\r\n\t(4613:\"hdm_layout\"),\r\n\t(4614:\"hdm_hittest\"),\r\n\t(4618:\"hdm_insertitemw\"),\r\n\t(4619:\"hdm_getitemw\"),\r\n\t(4620:\"hdm_setitemw\"),\r\n\t(4864:\"tcm_first\"),\r\n\t(4866:\"tcm_getimagelist\"),\r\n\t(4867:\"tcm_setimagelist\"),\r\n\t(4868:\"tcm_getitemcount\"),\r\n\t(4869:\"tcm_getitema\"),\r\n\t(4870:\"tcm_setitema\"),\r\n\t(4871:\"tcm_insertitema\"),\r\n\t(4872:\"tcm_deleteitem\"),\r\n\t(4873:\"tcm_deleteallitems\"),\r\n\t(4874:\"tcm_getitemrect\"),\r\n\t(4875:\"tcm_getcursel\"),\r\n\t(4876:\"tcm_setcursel\"),\r\n\t(4877:\"tcm_hittest\"),\r\n\t(4878:\"tcm_setitemextra\"),\r\n\t(4904:\"tcm_adjustrect\"),\r\n\t(4905:\"tcm_setitemsize\"),\r\n\t(4906:\"tcm_removeimage\"),\r\n\t(4907:\"tcm_setpadding\"),\r\n\t(4908:\"tcm_getrowcount\"),\r\n\t(4909:\"tcm_gettooltips\"),\r\n\t(4910:\"tcm_settooltips\"),\r\n\t(4911:\"tcm_getcurfocus\"),\r\n\t(4912:\"tcm_setcurfocus\"),\r\n\t(4924:\"tcm_getitemw\"),\r\n\t(4925:\"tcm_setitemw\"),\r\n\t(4926:\"tcm_insertitemw\"),\r\n\t(5120:\"pgm_first\"),\r\n\t(8192:\"ccm_first\")]\r\n\r\nproc start=\r\nend\r\n",
    \
(uint8_t*)"import sys\r\nimport files\r\nimport clib\r\nimport oslib\r\n\r\nimport winconsts\r\nimport winapi\r\nimport wingxlib\r\nimport winmessages\r\n\r\nimport gxmisc\r\n\r\nglobal var debug=0\r\n\r\nglobal var messhandlertable=9000\t!message by windowclass table of message handlers\r\n\r\nglobal var chx,chy\t\t!default text sizes for menus\r\nglobal var cha,chd\t\t!ascender/descender heights\r\nglobal const smx=3\t\t!margins around button text in pixels (both sides)\r\nglobal const smy=4\r\nglobal var arrowdim\r\nglobal var markdim\r\nglobal var buttonheight\r\nglobal var listrowheight\r\nglobal const labelfont=1\r\n\r\nglobal var tabstops=(8,)*20\r\n\r\nglobal var wmouse=0\r\nglobal var wfocus=0\r\nglobal var wprinter=0\r\nglobal var lastmousepos=0\r\nglobal var lastmousewindow=0\r\nglobal var currmousewindow=0\r\n\r\nglobal var mousepos\r\nglobal var mousesw\r\nglobal var quitmess=0\r\nglobal var dragmode=0\r\nglobal var lastbuttontime=0\r\n\r\nglobal var buttonstate=0\r\nglobal var wmessagetable\t\t!see initdata\r\nglobal var buttontable\t\t!see initdata\r\n\r\nconst maxqueuesize=100\r\nglobal var messagequeue=()\r\nglobal var nmessages=()\r\n\r\nconst dragtol=1\r\n\r\nglobal var copymode=4\r\n\r\nGLOBAL var vktomesstable\r\n\r\n!Describe gx window (also bitmap, control or child window)\r\nglobal record rwindow =\r\n\r\n\tvar windclass\t\t\t\t\t! type of window (popup, control, etc)\r\n\tvar flags\t\t\t\t\t\t! general purpose flags\r\n\tvar style\t\t\t\t\t\t! stylerec entry\r\n\tvar name\t\t\t\t\t\t! Optional debugging name\r\n\r\n\tvar owner\t\t\t\t\t\t! owner when this is a child window\r\n\tvar index\t\t\t\t\t\t! index 1..n when part of a list (eg. .childlist of owner)\r\n\tvar childlist\t\t\t\t\t! list of child windows\r\n\r\n!framepos/dim describe the overall window size including Windows or gx-drawn borders,\r\n\tvar frameposx, frameposy\t\t! top left of frame, in screen or owner window client coords\r\n\tvar framedimx, framedimy\t\t! pixels dims including frame and caption\r\n\r\n\tvar\tposx, posy\t\t\t\t\t! Pixel pos client area as seen by application\r\n\tvar\tdimx, dimy\t\t\t\t\t! Pixel dims of client area as seen by application\r\n\r\n\tvar gdi\t\t\t\t\t\t\t! (rgdistate)\tgdi state record\r\n\r\n\tvar enable\t\t\t\t\t\t! 1 to enable toggle/button/arrow etc, 0 to disable and show greyed out\r\n\tvar id\t\t\t\t\t\t\t! button/et al: command code associated with control\r\n\tvar text\t\t\t\t\t\t! caption or label or primary data\r\n\t\tvar data \t@text\r\n!\t\tvar dir \t@text\r\n\tvar linkvar\t\t\t\t\t\t! pointer to linked var for toggle/select/scroll\r\n\tvar gindex\t\t\t\t\t\t! window global index\r\n\r\n\tvar attrs\t\t\t\t\t\t! general purpose attributes, depends on window class\r\n\r\n!bitmap data\r\n\tvar pixelbits\t\t\t\t\t! 1, 4, 16, 24, 32 bits per pixel\r\n\tvar pixelptr\t\t\t\t\t! pointer to image data\r\n\tvar pixelbytes\t\t\t\t\t!bytes/pixel (round up to next whole byte)\r\n\tvar linebytes\t\t\t\t\t!bytes/per row, also pitch\r\n\tvar framebytes\r\n\tvar paltype\t\t\t\t\t\t!0, or palette type\r\nend\r\n\r\n!global record bitmaprec=\t\t\t!bitmap-specfic data\r\n!\tvar pixelbits\t\t\t\t\t! 1, 4, 16, 24, 32 bits per pixel\r\n!\tvar pixelptr\t\t\t\t\t! pointer to image data\r\n!\tvar pixelbytes\t\t\t\t\t!bytes/pixel (round up to next whole byte)\r\n!\tvar linebytes\t\t\t\t\t!bytes/per row, also pitch\r\n!\tvar ncolours\t\t\t\t\t!0, or colours in palette\r\n!end\r\n\r\nglobal tabledata() paltypenames =\r\n\t(no_pal=0,\t\t$),\r\n\t(greyscale_pal,\t$),\r\n\t(tinted_pal,\t$),\r\n\t(colour_pal,\t$),\r\n\t(uv_pal,\t\t$),\r\nend\r\n\r\nglobal type rgdistate = struct\r\n\tint64 hwnd\t\t\t\t! win32 handle (hwnd)\r\n\tint64 hdc\t\t\t\t! 0 or device context handle for hwnd\r\n\tint64 hwnd2\t\t\t\t! secondary window/memory backup\r\n\tint64 hdc2\t\t\t\t! 0 or hwnd3 DC screen or memory hdc\r\n\tint64 originalwndproc\t! win32 control handling proc\r\n\tint64 menuhandle\t\t\t! win32 handle to any menubar\r\n\t\tint64 oldbmobj @menuhandle\t\t!used for bitmaps\r\n\tint32 drawmode\t\t\t! see dm- drawcodes\r\n\tint32 updated\t\t\t\t! 1 when pixels have changed\r\n\r\n\tint32 posx,posy\t\t\t!current drawing position\r\n!\tint32 windcolour\t\t\t! current background colour (rgb)\r\n\tint32 pencolour\t\t\t! current line colour (rgb)\r\n\tint32 penwidth\t\t\t! current line width\r\n\r\n\tint32 penstyle\t\t\t! current line dotted style\r\n!\tint32 textcolour\t\t\t! current text colour\r\n!\tint32 bgndcolour\t\t\t! current background colour\r\n!\tint32 bgndmode\t\t\t! current opaque/transparent mode\r\n\r\n\tint32 xormode\t\t\t\t! 0=normal, 1=xor\r\n\tint32 brushcolour\t\t\t! current brush colour\r\n\tint32 brushstyle\t\t\t! current brush style (bs_solid/etc)\r\n\tint32 brushpattern\t\t! current brush hatch/bitmap pattern\r\n\r\n\tint32 font\t\t\t\t! current font number\r\nend\r\n\r\nglobal tabledata() marktypenames =\r\n\t(no_mark=0,\t\t\t$),\r\n\t(radio_mark,\t\t$),\r\n\t(tick_mark,\t\t\t$),\r\n\t(check_mark,\t\t$),\r\n\t(invert_mark,\t\t$),\r\n\t(outline_mark,\t\t$),\r\n\t(bold_mark,\t\t\t$),\r\nend\r\n\r\nglobal tabledata() hilitetypenames =\r\n\t(no_hilite=0,\t\t$),\r\n\t(invert_hilite,\t\t$),\r\n\t(outline_hilite,\t$),\r\nend\r\n\r\nglobal record togglerec=\t\t!for toggle and select\r\n\tvar textoffset\r\n\tvar onvalue\r\nend\r\n\r\nglobal record scrollbarrec=\t\t!scroll bars\r\n\tvar limits\t\t\t\t\t\t!range\r\n\tvar span\t\t\t\t\t\t!portion of limits represented by visible data (0 means not relevant)\r\n\tvar thumbsize\t\t\t\t\t!pixel length of thumb (vert or hoz extent along scrollbar)\r\n\tvar thumbspan\t\t\t\t\t!pixels that the thumb can move\r\n\tvar thumbpos\t\t\t\t\t!current thumb position in pixels from start of scrollbar\r\n\tvar currpos\t\t\t\t\t\t!current position, will be in limits range\r\n\tvar dragmode\t\t\t\t\t!1 if thum currently being dragged\r\nend\r\n\r\nglobal record editboxrec=\t\t!edit boxes\r\n!current char position within edit text\r\n!if text has N characters, then position will be 1..N+1\r\n!The position is just /before/ the stated character\r\n!This matches column position within the MED text editor\r\n\tvar currpos\t\t\t\t\t\t!cursor position, 1 to N+1 (N=chars in edit text)\r\n\tvar caretpos\t\t\t\t\t!current pixel position of any caret\r\n\tvar textpos\t\t\t\t\t\t!start x,y pixel position of text, set by gxjust_text\r\nend\r\n\r\nglobal record listboxrec=\r\n\tvar rows\t\t\t\t\t\t!number of displayed rows\r\n\tvar pagepos\t\t\t\t\t\t!data position corresponding to row 1 of display\r\n\tvar length\t\t\t\t\t\t!all data items, same as linkvar^.len\r\n\tvar currpos\t\t\t\t\t\t!cursor position within the data, 1 to N (can be 0 when N=0)\r\n\tvar pitch, offset\t\t\t\t!pixel dims of each row\r\nend\r\n\r\nglobal class rmessage=\r\n\tvar\t\twind\t\t!main window/button associated with message\r\n\tvar\t\tmenuwind\t!top-level window owning button\r\n\tvar\t\tmessage\t\t!message number\r\n\tvar\t\tstate\t\t!button/shift key state at time of message\r\n\tvar\t\ta,b\t\t\t!general purpose data, depends on message\r\n\tvar\t\tx,y\t\t\t!current mouse position\r\nend\r\n\r\n!contains many different flags and style codes for assorted controls\r\n!But at one mostly byte each, is very low overhead (32 values is same as two vars)\r\n\r\nglobal type stylerec = struct\r\n\tbyte\tborder\t\t\t\t!bs_ code\r\n\tbyte\tjustify\t\t\t\t!'L', 'R', 'C'\r\n\tbyte\tvjustify\t\t\t!'T', 'B', 'M'\r\n\tbyte\twindbgnd\t\t\t!colour index for window background\r\n\tbyte\ttextfgnd\t\t\t!colour index\r\n\tbyte\ttextbgnd\t\t\t!\r\n\tbyte\tbgndmode\t\t\t!\r\n\tbyte\ttextfont\t\t\t!font index\r\n\tbyte\ttextsize\t\t\t!pixel size\r\n\tbyte\ttextbold\t\t\t!1 if bold\r\n\tbyte\ttextitalic\t\t\t!1 if italic\r\n\tbyte\tispassword\t\t\t!1 when edit field is a password\r\n\tbyte\tfieldwidth\t\t\t!edit field maximum char width\r\n\tbyte\tdir\t\t\t\t\t!'L','R','U','D'\r\n\tbyte\tmarktype\t\t\t!xxx_mark style, or:\r\n\tbyte\thilitetype\t\t\t!xxx_hilite style\r\n\tbyte\tiframe\t\t\t\t!1: pos/dim include frame\r\n\tbyte\timark\t\t\t\t!1: pos/dim include mark for toggle/select\r\n\tbyte\thscroll\t\t\t\t!1: include windows-drawn hoz scroll bar\r\n\tbyte\tvscroll\t\t\t\t!1: include windows-drawn vert scroll bar\r\n\tbyte\tlbchange\t\t\t!1: return mm_change on list boxes when row has changed\r\n\tbyte\treturnmess\t\t\t!1: return id code when clicking toggle/select/editbox\r\n\tbyte\tnoupdate\t\t\t!1: don't change or allow editing on toggle/select/editbox\r\nend\r\n\r\nglobal record rpoint = var x,y end\r\nglobal record rrect  = (var pos,dim)\r\nglobal record rframe = (var x1,y1,x2,y2)\r\n\r\nglobal class getrec=\r\n\tmethod getbounds(&self)=\r\n\t\treturn 0\r\n\tend method\r\n\tmethod getitem(&self,n)=\r\n\t\treturn 0\r\n\tend method\r\n\tmethod getstritem(&self,n)= return \"\" end method\r\nend\r\n\r\nglobal tabledata() stylenames =\t! (default)\r\n\t(ss_border,\t\t\t$),\t\t! Border style (wbs_simple)\r\n\t(ss_justify,\t\t$),\t\t! 'L' 'C' 'R'\tHorizontal text justify ('L')\r\n\t(ss_vjustify,\t\t$),\t\t! 'T' 'M' 'B'\tVertical text justify ('M' for buttons)\r\n\t(ss_textfgnd,\t\t$),\t\t! Text colour index (black)\r\n\t(ss_textbgnd,\t\t$),\t\t! Text background colour index (if opaque mode) (0)\r\n\t(ss_bgndmode,\t\t$),\t\t! 0\r\n\t(ss_textfont,\t\t$),\t\t! Text font number (1)\r\n\t(ss_textsize,\t\t$),\t\t! (0)\r\n\t(ss_textbold,\t\t$),\t\t! (0)\r\n\t(ss_textitalic,\t\t$),\t\t! (0)\r\n\t(ss_ispassword,\t\t$),\t\t! (0)\r\n\t(ss_marktype,\t\t$),\t\t! Toggle/select mark style (radio_mark)\r\n\t(ss_hilitetype,\t\t$),\t\t! Toggle/select hilite style (no_hilite)\r\n\t(ss_iframe,\t\t\t$),\t\t! Whether pos and dim include frame width (also caption bar/menu for windows)\r\n\t(ss_windbgnd,\t\t$),\t\t! Background colour of window or button (ltgrey)\r\n\t(ss_imark,\t\t\t$),\t\t! Background colour of window or button (ltgrey)\r\n\t(ss_hscroll,\t\t$),\t\t! (0)\r\n\t(ss_vscroll,\t\t$),\t\t! (0)\r\n\t(ss_lbchange,\t\t$),\t\t! (0)\r\n\t(ss_returnmess,\t\t$),\t\t! (0) Toggle/select/editbox, return id when clicked\r\n\t(ss_noupdate,\t\t$),\t\t! (0) Toggle/select/editbox, don't change or allow edit\r\nend\r\n\r\nglobal tabledata() drawmodenames =\r\n\t\t\t\t\t\t\t\t!HDC\tHDC2\tRestore\r\n\t(dm_screen=0,\t\t$),\t\t!screen\t--\t\tCustom routine\tDraw directly to screen; no mem backup\r\n\t(dm_memory,\t\t\t$),\t\t!memory\t--\t\tNA\t\t\t\tDraw to memory only; no screen hdc (eg. bitmap)\r\n\t(dm_screenmemory,\t$),\t\t!screen\tmemory\tBlit mem->scr\tDraw to both screen and memory at same time\r\n\t(dm_memoryscreen,\t$),\t\t!memory\tscreen\tBlit mem->scr\tDraw to memory; update screen periodically\r\nend\r\n\r\n!var windowlist=nil\r\n\r\nglobal tabledata() wfnames = begin\r\n\t(wa_rightclick=0,\t$),\t\t!allow right click\r\n\t(wa_middleclick,\t$),\t\t!allow middle click\r\n\t(wa_leftdbl,\t\t$),\t\t!allow left double click\r\n\t(wa_rightdbl,\t\t$),\t\t!allow right double click\r\n\t(wa_middledbl,\t\t$),\t\t!allow middle double click\r\n\t(wa_leftdrag,\t\t$),\t\t!allow left drag\r\n\t(wa_rightdrag,\t\t$),\t\t!etc\r\n\t(wa_middledrag,\t\t$),\r\n\t(wa_autoupdate,\t\t$),\t\t!auto update screen for toggles/etc\r\n\t(wa_tab,\t\t\t$), \t!allow tab to switch to next button which has watab\r\n\t(wa_strvar,\t\t\t$), \t!1 for listbox linkvar to use string not index\r\n\t(wa_retmess,\t\t$), \t!1 for button to return .value as mess not qmcommand\r\n\t(wa_retsel,\t\t\t$), \t!1 for button to return .value as mess not qmcommand\r\n\t(wa_memory,\t\t\t$), \t!1 when hdc/hdcmem have been switched, hdc points to memory dev\r\n\t(wa_maximised,\t\t$),\t\t!1 when maximised, 0 when normal/minimised\r\n\t(wa_param1,\t\t\t$), \t!general purpose control-specific flags\r\n\t(wa_param2,\t\t\t$), \r\n\t(wa_useenter,\t\t$),\r\n\t(wa_closed,\t\t\t$),\t\t!whether window has been closed\r\n\r\n\t(wa_$last,\t\t\t$)\r\nend\r\n\r\nconst wa_needdbl\t= wa_param1\t!1 requires double-click on listbox to return wmcommand\r\nconst wa_editdd\t\t= wa_param2\t!1 means editable dropdown box\r\n\r\n!GX border styles, used for child windows.\r\n!some child windows\r\nglobal tabledata() bsnames, bscat, bswidths=\r\n\t(bs_none=0,\t\t$,\t0,\tws_rect(0,0,0,0)),\t\t\t!no border\r\n!\t(bs_windows,\t$,\t'W',\tws_rect(0,0,0,0)),\t\t\t!windows-drawn, but no own-drawn border\r\n\t(bs_simplew,\t$,\t'W',\tws_rect(1,1,1,1)),\t\t\t!single 1-pixel black line, windows drawn\r\n\t(bs_simple,\t\t$,\t'X',\tws_rect(1,1,1,1)),\t\t\t!single 1-pixel black line\r\n\t(bs_thick,\t\t$,\t'X',\tws_rect(2,2,2,2)),\t\t\t!2-pixel border\r\n\t(bs_panel,\t\t$,\t'X',\tws_rect(1,1,1,1)),\t\t\t!raised panel, 1-pixel\r\n\t(bs_inset,\t\t$,\t'X',\tws_rect(1,1,1,1)),\t\t\t!inset panel, 1-pixel\r\n\t(bs_ownsimple,\t$,\t'I',\tws_rect(0,0,0,0)),\t\t\t!included inset panel, 1-pixel (drawn as part of client area)\r\n\t(bs_ownpanel,\t$,\t'I',\tws_rect(0,0,0,0)),\t\t\t!included inset panel, 1-pixel (drawn as part of client area)\r\n\t(bs_owninset,\t$,\t'I',\tws_rect(0,0,0,0)),\t\t\t!included inset panel, 1-pixel\r\n\t(bs_testext,\t$,\t'X',\tws_rect(10,10,10,10)),\r\n\t(bs_testint,\t$,\t'I',\tws_rect(8,8,8,8)),\r\n\t(bs_dummy,\t\t$,\t0,\tws_rect(0,0,0,0))\r\nend\r\n\r\nglobal tabledata() windowclassnames, defaultborderstyles = begin\r\n\t(no_class=0,\t\t$,\tbs_none),\t\t\t!Unassigned\r\n\t(window_class,\t\t$,\twbs_resize),\t\t!Main window\r\n\t(memwindow_class,\t$,\twbs_none),\t\t\t!memory backup to any window\r\n\t(popup_class,\t\t$,\twbs_thick),\t\t\t!Pop-up window (forms a stack)\r\n\t(float_class,\t\t$,\tbs_thick),\t\t\t!Independent window\r\n\t(bitmap_class,\t\t$,\tbs_none),\t\t\t!(image handling)\r\n\t(screen_class,\t\t$,\tbs_none),\t\t\t!Describes the desktop screen (not owned by my app)\r\n\t(printer_class,\t\t$,\tbs_none),\t\t\t!Used for printing\r\n\r\n\t(group_class,\t\t$,\tbs_inset),\t\t\t!Used mainly for grouping other buttons (eg. for Smdefblock)\r\n\t(panel_class,\t\t$,\tbs_inset),\t\t\t!General purpose panel for drawing in etc\r\n!\t(button_class,\t\t$,\tbs_panel),\t\t\t!Click button\r\n\t(button_class,\t\t$,\tbs_simplew),\t\t!Click button\r\n\t(toggle_class,\t\t$,\tbs_none),\t\t\t!Toggle button (can be composite, eg mark and label)\r\n\t(select_class,\t\t$,\tbs_none),\t\t\t!Select from several choices\r\n\t(editbox_class,\t\t$,\tbs_simplew),\t\t!Single-line edit control\r\n\t(scrollbar_class,\t$,\tbs_simplew),\t\t!Hoz or vert scroll bar (Some windows can also have Windows-drawn scroll bars)\r\n\t(listbox_class,\t\t$,\tbs_simplew),\t\t!List of options (scrollable usually)\r\n\t(dropdown_class,\t$,\tbs_none),\t\t\t!Button revealing attached listbox when clicked\r\n\t(framebar_class,\t$,\tbs_panel),\t\t\t!Left or right full-height panel used for toolboxes etc\r\n\t(statusbar_class,\t$,\tbs_panel),\t\t\t!Top or bottom full-width panel used for scrollbars\r\n\t(tooltip_class,\t\t$,\tbs_simplew),\t\t!Tooltops displayed when hovering over enabled buttons\r\n\t(arrow_class,\t\t$,\tbs_ownpanel),\t\t!Click button normally displaying an error in one of 4 orientations\r\n\t(mark_class,\t\t$,\tbs_none),\t\t\t!Toggle or select mark\r\n\t(label_class,\t\t$,\tbs_none),\t\t\t!Contains unclickable text usually\r\n\t(dummy_class,\t\t$,\tbs_none)\r\nend\r\n\r\nglobal tabledata() actionnames, actionhandlertable=\r\n\t(draw_w,\t\t$,\t\t()),\r\n\t(update_w,\t\t$,\t\t()),\r\n\t(last_w,\t\t$,\t\t()),\r\nend\r\n\r\n!MM Message Numbers\r\n\r\nglobal tabledata() messagenames= begin\r\n\r\n!all messages have x,y coord relative to top most window or child window\r\n!\r\n\t(mm_null=0,\t\t\t$),\t\t! empty message\r\n\r\n!window messages\r\n\t(mm_activate,\t\t$),\t\t! (w,a) a=1/0 activate/deactivate window\r\n\t(mm_close,\t\t\t$),\t\t! (w) close window (X button clicked)\r\n\t(mm_sizewindow,\t\t$),\t\t! (w...) resize window\r\n\t(mm_movewindow,\t\t$),\t\t! (w...) move window\r\n\t(mm_restore,\t\t$),\t\t! (w...) repaint window\r\n\r\n!cursor/focus messages\r\n\t(mm_setcursor,\t\t$),\t\t! (w...) update cursor type\r\n\t(mm_setfocus,\t\t$),\t\t! (w...) set focus to w\r\n\t(mm_killfocus,\t\t$),\t\t! (w...) lose focus from w\r\n\r\n!basic mouse messages (click messages can be promoted to other messages eg mm_command)\r\n\t(mm_move,\t\t\t$),\t\t! (w,x,y,b) mouse move, btns up/down (also drag messages when down)\r\n\t(mm_click,\t\t\t$),\t\t! (w,x,y) left btn click, can be promoted to mm_command etc depending on context\r\n\t(mm_dblclick,\t\t$),\t\t! (w,x,y) left btn dbl click, usu promoted\r\n\t(mm_clickup,\t\t$),\t\t! (w,x,y) left btn released\r\n\t(mm_rclick,\t\t\t$),\t\t! (w,x,y) right click in window, these usu. promoted\r\n\t(mm_rdblclick,\t\t$),\t\t! (w,x,y) right double click\r\n\t(mm_rclickup,\t\t$),\t\t! (w,x,y) right button released\r\n\t(mm_mclick,\t\t\t$),\t\t! (w,x,y) middle button versions of above\r\n\t(mm_mdblclick,\t\t$),\t\t! (w,x,y)\r\n\t(mm_mclickup,\t\t$),\t\t! (w,x,y)\r\n\t(mm_hover,\t\t\t$),\t\t! (w,x,y) paused over button\r\n\r\n\t(mm_onwindow,\t\t$),\t\t! (w,x,y) newly over a window\r\n\t(mm_offwindow,\t\t$),\t\t! (w,x,y) just came off window\r\n\t(mm_draw,\t\t\t$),\t\t! (w,x,y) redraw window\r\n\t(mm_update,\t\t\t$),\t\t! (w,x,y) update window (change of pos etc)\r\n\r\n!drag messages\r\n\t(mm_startdrag,\t\t$),\t\t! (w) start mouse movement with some btns down\r\n\t(mm_rstartdrag,\t\t$),\t\t! (w)\r\n\t(mm_mstartdrag,\t\t$),\t\t! (w)\r\n\t(mm_drag,\t\t\t$),\t\t! (w,x,y) moving mouse with buttons down (also qmmove sent)\r\n\t(mm_enddrag,\t\t$),\t\t! (w,x,y) all buttons up after drag\r\n\r\n!left command\r\n\t(mm_command,\t\t$),\t\t! (w,id) button clicked, id and sub-event given\r\n\t(mm_dblcommand,\t\t$),\t\t! (w,id) button double clicked\r\n\r\n!right command\r\n\t(mm_rcommand,\t\t$),\t\t! (w,id) right click button\r\n\t(mm_rdblcommand,\t$),\t\t! (w,id) right double click button\r\n\r\n!middle command\r\n\t(mm_mcommand,\t\t$),\t\t! (w,id)\r\n\t(mm_mdblcommand,\t$),\t\t! (w,id)\r\n\r\n!general key messages\r\n\t(mm_char,\t\t\t$),\t\t! (w,ch)\r\n\t(mm_key,\t\t\t$),\t\t! (w,k,shift)\r\n\t(mm_keyup,\t\t\t$),\t\t! (w,k,shift)\r\n\r\n!scroll/select/wheel messages\r\n\t(mm_sethozpos,\t\t$),\t\t! (w,pos)\t\tNew logical position set by hoz scrollbar\r\n\t(mm_setvertpos,\t\t$),\t\t! (w,pos)\t\tfrom vertical scrollbar\r\n\t(mm_select,\t\t\t$),\t\t! (w,n)\t\t\tSet nth item as current/highlighted/selected item\r\n\t(mm_pick,\t\t\t$),\t\t! (w,n)\t\t\tPick and return item n\r\n\t(mm_wheel,\t\t\t$),\t\t! (w,delta)\t\tMove log pos etc but depends on context\r\n\t(mm_lbchange,\t\t$),\t\t! (w,n)\t\t\tA listbox position has changed\r\n\r\n!misc messages\r\n\t(mm_timer,\t\t\t$),\t\t! (w)\r\n\r\n!high level window messages\r\n\t(mm_cancel,\t\t\t$),\t\t! (w)\r\n\t(mm_ok,\t\t\t\t$),\t\t! (w)\r\n\t(mm_help,\t\t\t$),\t\t! (w,id)\r\n\t(mm_cmdline,\t\t$),\t\t! (w,s)\r\n\r\n!specific key messages\r\n\t(mm_leftkey ,\t\t$),\t\t! (w,shift)\r\n\t(mm_rightkey,\t\t$),\t\t! (w,shift)\r\n\t(mm_upkey,\t\t\t$),\t\t! (w,shift)\r\n\t(mm_downkey,\t\t$),\t\t! (w,shift)\r\n\t(mm_pageupkey,\t\t$),\t\t! (w,shift)\r\n\t(mm_pagedownkey,\t$),\t\t! (w,shift)\r\n\t(mm_homekey,\t\t$),\t\t! (w,shift)\r\n\t(mm_endkey,\t\t\t$),\t\t! (w,shift)\r\n\t(mm_tabkey,\t\t\t$),\t\t! (w,shift)\r\n\t(mm_bskey,\t\t\t$),\t\t! (w,shift)\r\n\t(mm_deletekey,\t\t$),\t\t! (w,shift)\r\n\t(mm_enterkey,\t\t$),\t\t! (w,shift)\r\n\t(mm_insertkey,\t\t$),\t\t! (w,shift)\r\n\t(mm_functionkey,\t$),\t\t! (w,shift)\r\n\r\n!Other messages for controls, mainly for attached arrow buttons\r\n\t(mm_up,\t\t\t\t$),\t\t! (w,id) Arrow up/etc\r\n\t(mm_down,\t\t\t$),\t\t! (w,id)\r\n\t(mm_right,\t\t\t$),\t\t! (w,id)\r\n\t(mm_left,\t\t\t$),\t\t! (w,id)\r\n\t(mm_edit,\t\t\t$),\t\t! (w,id)\tUpdate of edit box\r\n\t(mm_edited,\t\t\t$),\t\t! (w,id)\tFinished edit box entry (tab etc)\r\n\t(mm_last,\t\t\t$)\r\nend\r\n\r\n!global const mm_scroll\t= mm_hscroll\t!general scroll independent of orientation\r\n\r\n!!other messages wmuser+ are user assigned, usually applied as\r\n!ids to controls. Depending on the options to Waitmess(), a wm_commmand message\r\n!is coverted to a direct message number. So (wm_command, 230) is covered to\r\n!message 230. So message ids have to start from 200 so that they occupy a different\r\n!number space from normal message codes.\r\nglobal const mm_user\t= 200\r\n\r\nglobal const kb_lbutton\t= 0x1\t!used in buttonstate\r\nglobal const kb_rbutton\t= 0x2\r\nglobal const kb_mbutton\t= 0x4\r\n\r\nglobal const kb_shift\t= 0x8\t!used in shiftstate\r\nglobal const kb_ctrl\t= 0x10\r\nglobal const kb_alt\t\t= 0x20\r\nglobal const kb_capslock\t= 0x40\r\nglobal const kb_dblclick\t= 0x80\t!used for some messages that don't have dblclick versions,\r\n\r\nglobal const kb_rshift\t= 0x100\r\nglobal const kb_rctrl\t= 0x200\r\nglobal const kb_ralt\t= 0x400\r\n\r\nglobal tabledata() colournames, colourvalues = begin\r\n!\t\t\t\t\t   BB'GG'RR\r\n\t(black,\t\t$,\t0x_00'00'00),\r\n\t(red,\t\t$,\t0x_00'00'C0),\r\n\t(dkred,\t\t$,\t0x_00'00'90),\r\n\t(red3,\t\t$,\t0x_00'00'70),\r\n\t(green,\t\t$,\t0x_00'C0'00),\r\n\t(dkgreen,\t$,\t0x_00'90'00),\r\n\t(green3,\t$,\t0x_00'70'00),\r\n\t\r\n\t(blue,\t\t$,\t0x_C0'00'00),\r\n\t(dkblue,\t$,\t0x_90'00'00),\r\n\t(blue3,\t\t$,\t0x_70'00'00),\r\n\r\n\t(cyan,\t\t$,\t0x_c0'c0'00),\r\n\t(dkcyan,\t$,\t0x_90'90'00),\r\n\t(cyan3,\t\t$,\t0x_70'70'00),\r\n\r\n\t(magenta,\t$,\t0x_c0'00'c0),\r\n\t(dkmagenta,\t$,\t0x_90'00'90),\r\n\t(magenta3,\t$,\t0x_70'00'70),\r\n\r\n\t(yellow,\t$,\t0x_00'C0'C0),\r\n\t(dkyellow,\t$,\t0x_00'90'90),\r\n\t(yellow3,\t$,\t0x_00'70'70),\r\n\t(yellow4,\t$,\t0x_00'50'50),\r\n\r\n\t(white,\t\t$,\t0x_FF'FF'FF),\r\n\t(ltgrey,\t$,\t0x_C0'C0'C0),\r\n\t(grey,\t\t$,\t0x_90'90'90),\r\n\t(dkgrey,\t$,\t0x_70'70'70),\r\n\r\n\t(ltorange,\t$,\t0x_00'A0'FF),\r\n\t(orange,\t$,\t0x_00'60'FF),\r\n\t(flesh,\t\t$,\t0x_70'85'EE),\r\n\t(pink,\t\t$,\t0x_9A'32'DB),\r\n\t(dkpink,\t$,\t0x_72'24'A9),\r\n\t(brown,\t\t$,\t0x_46'43'7D),\r\n\t(blue4,\t\t$,\t0x_B7'1C'5E),\r\n\t(blue5,\t\t$,\t0x_6F'3D'0D),\r\n\t(olive,\t\t$,\t0x_05'A0'88),\r\n\t(ltbrown,\t$,\t0x_00'70'B0),\r\n\r\n\t(blue6,\t\t$,\t0x_9C'63'1C),\r\n\t(green4,\t$,\t0x_12'51'11),\r\n\t(purple,\t$,\t0x_5E'0D'73),\r\n\t(blue7,\t\t$,\t0x_E6'27'1C),\r\n\t(crimson,\t$,\t0x_15'2A'D3),\r\n\t(violet,\t$,\t0x_54'16'A0),\r\n\t(blue8,\t\t$,\t0x_86'68'1E),\r\n\t(dkorange,\t$,\t0x_25'6A'D4),\r\n\t(green5,\t$,\t0x_09'46'41),\r\n\t(blue9,\t\t$,\t0x_65'0A'1D),\r\n\r\n\t(ltred,\t\t$,\t0x_00'00'FF),\r\n\t(ltgreen,\t$,\t0x_00'FF'00),\r\n\t(ltblue,\t$,\t0x_FF'00'00),\r\n\t(ltcyan,\t$,\t0x_FF'FF'00),\r\n\t(ltmagenta,\t$,\t0x_FF'00'FF),\r\n\t(ltyellow,\t$,\t0x_00'FF'FF),\r\n\r\n!The following are the Windows system colours, set up as indices\r\n!Init needs need to retrieve the values and set up the rgb values in this table\r\n\t(button_col,\t$,\t0),\t\t!button colour\r\n\t(window_col,\t$,\t0),\t\t!window colour\r\n\t(text_col,\t\t$,\t0),\t\t!text in windows\r\nend\r\n\r\nglobal const skipmess = 1\t\t!message has been processed; caller must wait for another message\r\nglobal const thismess = 0\t\t!caller should deal with this message (it has not been processed, or has been but caller can process it too)\r\n\r\nglobal var bmbgnd\r\nglobal var defstyle\t\t\t!set initdata\r\nglobal var currmess\r\n\r\nglobal var wapplic=0\r\nglobal var wscreen=0\r\n\r\nvar data,ndata\r\nvar tabstack,ntab\r\nvar breakflag\r\n\r\nmacro k_menu=30000\r\nmacro kdivide=30001\r\nmacro kcolumn=30002\r\nmacro kfilehistory=30003\r\n\r\nvar caretdrawn=0\r\nvar dkcolour=0x000000\r\nvar ltcolour=0xFFFFFF\r\nvar thumbdragmode=0\r\nvar thumbstartpos=0\r\n\r\nvar dirtomess=['L':mm_left,'R':mm_right,'U':mm_up,'D':mm_down]\r\n\r\nglobal proc setupgdi(w,hwnd)=\t\t\t!SETUPGDI\r\n!NOTE: rare care of a function within a data header. This is to allow bitmap module\r\n!to be higher up the hierarchy than gx, but still let it use some gx functions.\r\n\r\n!set up the default gdi descriptor for window w\r\n\r\nif w.gdi then\r\n\treturn\t\t\t!assume already done\r\nfi\r\n\r\ngdi:=new(rgdistate)\r\ngdi.hwnd:=hwnd\r\n\r\n!start with default drawmodes of dm_screen, or dm_memory for bitmaps\r\n!These can be converted later using gxdrawmode\r\n\r\nif w.type=rwindow then\r\n\tgdi.hdc:=getdc(hwnd)\r\n\tgdi.drawmode:=dm_screen\r\nelse\t\t\t\t\t\t!assume bitmap\r\n\tgdi.hdc:=createcompatibledc(nil)\r\n\tgdi.drawmode:=dm_memory\r\nfi\r\n\r\ngdi.posx:=gdi.posy:=0\r\ngdi.updated:=0\r\ngdi.font:=0\r\ngdi.pencolour:=getsyscolour(colour_windowtext)\r\ngdi.penwidth:=0\r\ngdi.penstyle:=ps_solid\r\ngdi.xormode:=0\r\ngdi.brushcolour:=0xff'ff'ff\r\ngdi.brushstyle:=bs_solid\r\ngdi.brushpattern:=0\r\nw.gdi:=gdi\r\nend\r\n\r\nglobal const arleft = \"<\"\r\nglobal const arright = \">\"\r\nglobal const arup = \"^\"\r\nglobal const ardown = \"V\"\r\n\r\nglobal var allwindows=()\t\t\t!list of all windows and controls\r\n\r\nglobal function ctrlpressed = return (currmess.state iand kb_ctrl) end\r\nglobal function shiftpressed = return (currmess.state iand kb_shift) end\r\n\r\nproc start=\r\ninitdata()\r\nmxinit()\r\ninitmenuhandlers()\r\nend\r\n\r\nproc initdata=\r\nmessagequeue:=new(list,100)\r\nnmessages:=0\r\n\r\ncolourvalues[button_col]:=getsyscolour(colour_btnface)\r\n\r\ncolourvalues[window_col]:=getsyscolour(colour_window)\r\ncolourvalues[text_col]:=getsyscolour(colour_windowtext)\r\n\r\ndefstyle:=new(stylerec)\r\ndefstyle.border\t\t:= bs_simplew\r\ndefstyle.justify\t:= 'L'\r\ndefstyle.vjustify\t:= 'M'\r\ndefstyle.textfgnd\t:= black\r\ndefstyle.marktype\t:= check_mark\r\ndefstyle.hilitetype\t:= no_hilite\r\ndefstyle.windbgnd\t:= button_col\r\ndefstyle.imark\t\t:= 1\r\n!defstyle.windbgnd\t:= window_col\r\n\r\ninit_handlertables()\r\nd:=gxchardim(labelfont)\r\nchx:=d.x\r\nchy:=d.y\r\n\r\nd:=gxchardim(0,1)\r\ncha:=d.x\r\nchd:=d.y\r\narrowdim:=chy+2\r\nmarkdim:=arrowdim-2\r\n\r\nbuttonheight:=chy+smy*2\r\nlistrowheight:=chy+smy*2\r\nend\r\n\r\nglobal function gxcreatewindow(?caption,?pos,?dim,?options,owner=nil)=\t\t!CREATEWINDOW\r\n#create a popup window which is not a child window.\r\n#(nevertheless, it can have an owner window, such as the main window of the\r\n#application)\r\n#returns an rwindow handle\r\n#caption\toptional caption txt\r\n#pos\t\t(x,y) is pixel pos of top left corner in screen coordinates (of frame?)\r\n#\t\t\"cent\" to place centrally\r\n#\t\tomitted: use default placement\r\n#dim\t\t(width,height) overall pixel size\r\n#\t\t\"max\" maximised\r\n#\t\t\"desktop\" fill desktop screen\r\n#\t\tomitted: use (640,480)\r\n#owner\toptional owner window (default nil)\r\n#options\toption dict, default is [wf_caption:1, wf_border:wbs_resize]\r\n\r\nhwnd:=wx_createpopup(caption,pos,dim,options,(owner|owner.gdi.hwnd|nil))\r\n!!CPL \"CW2\"\r\n\r\n!HWND:=GETCONSOLEWINDOW()\r\n\r\nw:=newwindow(hwnd,0,no_class,bs_windows)\r\n\r\nif wapplic=nil then\r\n\twapplic:=w\r\nfi\r\n\r\nW.STYLE:=NEW(STYLEREC)\r\nW.STYLE.BORDER:=0\r\nW.WINDCLASS:=WINDOW_CLASS\r\nW.STYLE.WINDBGND:=WINDOW_COL\r\nW.ENABLE:=1\r\nW.FLAGS.[WA_LEFTDRAG]:=1\r\nW.FLAGS.[WA_LEFTDBL]:=1\r\n\r\nsetwindowdims_w(w,hwnd)\r\nsetupgdi(w,hwnd)\r\ngxfont(w,1)\r\n\r\nGXDRAWMODE(W,DM_SCREENMEMORY)\r\nGXCLEAR(W)\r\n\r\nreturn w\r\nend\r\n\r\nproc setwindowdims_w(w,hwnd)=\t\t\t!SETWINDOWDIMS\r\n!use windows functions to set up client and frame pos and dims of top-level window\r\n\r\nbox:=new(ws_rect)\r\ngetwindowrect(hwnd,&box)\r\nw.frameposx:=box.x\r\nw.frameposy:=box.y\r\nw.framedimx:=box.x2-box.x\r\nw.framedimy:=box.y2-box.y\r\n\r\ngetclientrect(hwnd,&box)\r\nw.dimx:=box.x2-box.x\r\nw.dimy:=box.y2-box.y\r\n\r\npt:=ws_point(0,0)\r\nclienttoscreen(hwnd,&pt)\t\t!pos starts at 0,0\r\nw.posx:=pt.x\r\nw.posy:=pt.y\r\nend\r\n\r\nproc setwindowdims_c(w,hwnd)=\t\t\t!SETWINDOWDIMS\r\n!use windows functions to set up client and frame pos and dims of child window\r\n\r\n\r\nbox:=new(ws_rect)\r\ngetwindowrect(hwnd,&box)\t\t\t!client dims also Windows frame dims as has no Windows border\r\nw.posx:=box.x-w.owner.posx\r\nw.posy:=box.y-w.owner.posy\r\nw.dimx:=box.x2-box.x\r\nw.dimy:=box.y2-box.y\r\n\r\nwidths:=bswidths[w.style.border]\r\nif bscat[w.style.border]='I' then widths:=ws_rect(0,0,0,0) fi\r\n\r\nw.frameposx:=w.posx-widths.x1\r\nw.frameposy:=w.posy-widths.y1\r\nw.framedimx:=w.dimx+widths.x1+widths.x2\r\nw.framedimy:=w.dimy+widths.y1+widths.y2\r\nend\r\n\r\nglobal proc gxclear(w,?colour)=\t\t\t!GXCLEAR\r\n#fill window w with <colour>, or with current background if omitted\r\n\r\ngdi:=w.gdi\r\ngdi.updated:=1\r\n\r\ngxcolour(w,getrgb(black))\r\ngxstyle(w,0)\r\n\r\nif colour.isvoid then\r\n!cpl \"CLEAR/VOID\",W.STYLE.WINDBGND, YELLOW\r\n\tcolour:=getrgb(w.style.windbgnd)\r\nfi\r\n\r\noldpenstyle:=gdi.penstyle\r\noldbrushstyle:=gdi.brushstyle\r\n\r\ngxbrushstyle(w,bs_solid)\r\ngxstyle(w,ps_null)\r\n\r\ngxfillrect(w,0,0,w.dimx,w.dimy,colour)\r\ngxbrushstyle(w,oldbrushstyle)\r\ngxstyle(w,oldpenstyle)\r\nend\r\n\r\nglobal function gxstyle(w,?style)=\t\t\t!GXSTYLE\r\n#style omitted: get pen current pen style\r\n#style supplied: set pen style for subsequent line drawing\r\n#Style is a char code or int refering to a small variety of Windows dotted styles:\r\n#\t0 S |\t\tSolid\r\n#\tSpace\t\tNull (pen up?)\r\n#\t-\t\t\tDotted\r\n#\t:\t\t\tDashdotdot\r\n#\t!\t\t\tDashdotd\r\n#\tF\t\t\tInside frame\r\n\r\ngdi:=w.gdi\r\n\r\nif style.isdef and gdi.penstyle<>style then\r\n\tcase style\r\n\twhen '!' then style:=ps_dashdot\r\n\twhen ':' then style:=ps_dashdotdot\r\n\twhen '-' then style:=ps_dot\r\n\twhen ' ' then style:=ps_null\r\n\twhen 'D' then style:=ps_alternate\r\n\twhen '|','S',0 then style:=ps_solid\r\n\twhen 'F' then style:=ps_insideframe\r\n\tesac\r\n\r\n\tgdi.penstyle:=style\r\n\tif style>=10 then style:=ps_dot fi\r\n\tdeleteobject(selectobject(gdi.hdc,createpen(style,gdi.penwidth,gdi.pencolour)))\r\n\tif gdi.drawmode=dm_screenmemory then\r\n\t\tdeleteobject(selectobject(gdi.hdc2,createpen(style,gdi.penwidth,gdi.pencolour)))\r\n\tfi\r\nfi\r\nreturn gdi.penstyle\r\nend\r\n\r\nglobal proc gxbrushstyle(w,?style,?pattern)=\t\t!GXBRUSHSTYLE\r\n#Set Windows brush style and pattern\r\n#Style supplied:\tset style\r\n#pattern supplied:\tset style\r\n#style is:\t\tS, H, Space, B for Solid, Hatched, Null, DIB\r\n#pattern is:\t- | \\ / + x/X for Hoz, Vert, Diag, Fwd Diag, Cross, Diag Cross\r\n\r\ngdi:=w.gdi\r\nbrush:=new(ws_logbrush)\r\n\r\nif style.isdef then\r\n\tif style<>gdi.brushstyle then\r\n\t\tcase style\r\n\t\twhen 'S' then style:=bs_solid\r\n\t\twhen 'H' then style:=bs_hatched\r\n\t\twhen ' ' then style:=bs_null\r\n\t\twhen 'B' then style:=bs_dibpattern\r\n\t\tesac\r\n\r\n\t\tgdi.brushstyle:=style\r\n\tfi\r\n\tgdi.brushpattern:=0\t\t!default to no pattern, will be changed by pattern if supplied\r\nfi\r\n\r\nif pattern.isdef and pattern<>gdi.brushpattern then\r\n\tcase pattern\r\n\twhen '-' then pattern:=hs_horizontal\r\n\twhen '|' then pattern:=hs_vertical\r\n\twhen '\\\\' then pattern:=hs_fdiagonal\r\n\twhen '/' then pattern:=hs_bdiagonal\r\n\twhen '+' then pattern:=hs_cross\r\n\twhen 'x','X' then pattern:=hs_diagcross\r\n\tesac\r\n\tgdi.brushpattern:=pattern\r\nfi\r\n\r\nbrush.lbstyle:=gdi.brushstyle\r\nbrush.lbcolour:=gdi.brushcolour\r\nbrush.lbhatch:=gdi.brushpattern\r\n\r\ndeleteobject(selectobject(gdi.hdc,createbrushindirect(&brush)))\r\nif gdi.drawmode=dm_screenmemory then\r\n\tdeleteobject(x:=selectobject(gdi.hdc2,createbrushindirect(&brush)))\r\nfi\r\nend\r\n\r\nglobal function gxbrushcolour(w,?colour)=\t\t\t!GXBRUSHCOLOUR\r\n#colour supplied:\tset current fill colour\r\n#colour omitted:\treturn current fill colour\r\n\r\ngdi:=w.gdi\r\n\r\nif colour.isdef and colour<>gdi.brushcolour then\r\n\tgdi.brushcolour:=colour\r\n\tbrush:=new(ws_logbrush)\r\n\tbrush.lbstyle:=gdi.brushstyle\r\n\tbrush.lbcolour:=colour\r\n\tbrush.lbhatch:=gdi.brushpattern\r\n\r\n\tdeleteobject(selectobject(gdi.hdc,createbrushindirect(&brush)))\r\n\tif gdi.drawmode=dm_screenmemory then\r\n\t\tdeleteobject(selectobject(gdi.hdc2,createbrushindirect(&brush)))\r\n\tfi\r\nfi\r\nreturn gdi.brushcolour\r\nend\r\n\r\nglobal proc gxfillrect(w,x,y,width,height,?colour,mode=0)=\t\t!GXFILLRECT\r\n#Draw filled rectangle with optional outline\r\n#x,y are top-left coordinates\r\n#width, height are overall pixel dimensions, inclusive; they include any outline\r\n#(When the outline is drawn, the filled region is 1 pixel smaller all round)\r\n#colour is the colour of the filled region (current brush colour when omitted)\r\n#mode=1 to draw the outline, or mode=0 (default) to omit it\r\n#The outline is drawn in the current pen colour\r\n\r\ngdi:=w.gdi\r\ngdi.updated:=1\r\n\r\noldbrushcolour:=gdi.brushcolour\r\nif colour.isdef then\r\n\tgxbrushcolour(w,colour)\r\nfi\r\n\r\noldpenstyle:=gdi.penstyle\r\nif mode=0 then\t\t!inside only\r\n\tgxstyle(w,ps_null)\r\nfi\r\n\r\nif height<0 then y:=y+height+1; height:=-height fi\r\nif width<0 then x:=x+w+1; width:=-width fi\r\n\r\nif mode=0 then\t\t!inside only, needs extra pixel width\r\n\trectangle(gdi.hdc,x, y,x+width+1,y+height+1)\r\n\tif gdi.drawmode=dm_screenmemory then\r\n\t\trectangle(gdi.hdc2,x,y,x+width+1,y+height+1)\r\n\tfi\r\nelse\t\t\t!inside and outside\r\n\trectangle(gdi.hdc,x, y, x+width, y+height)\r\n\tif gdi.drawmode=dm_screenmemory then\r\n\t\trectangle(gdi.hdc2,x,y,x+width,y+height)\r\n\tfi\r\nfi\r\ngxstyle(w,oldpenstyle)\r\ngxbrushcolour(w,oldbrushcolour)\r\nend\r\n\r\nglobal function gxcolour(w,?colour)=\t\t!GXCOLOUR\r\n# colour supplied:\tset current outline colour for subsequent line drawing\r\n# colour omitted:\treturn current outline colour\r\n\r\ngdi:=w.gdi\r\n\r\nif colour.isdef and gdi.pencolour<>colour then\r\n\tgdi.pencolour:=colour\r\n\tgdi.xormode:=0\r\n\tdeleteobject(selectobject(gdi.hdc,createpen(gdi.penstyle,gdi.penwidth,gdi.pencolour)))\r\n\tsetrop2(gdi.hdc,r2_copypen)\r\n\tif gdi.drawmode=dm_screenmemory then\r\n\t\tdeleteobject(selectobject(gdi.hdc2,createpen(gdi.penstyle,gdi.penwidth,gdi.pencolour)))\r\n\t\tsetrop2(gdi.hdc2,r2_copypen)\r\n\tfi\r\n\r\nfi\r\n\r\nreturn gdi.pencolour\r\nend\r\n\r\nglobal proc gxsetpen(w,pen)=\r\ngxcolour(w,getrgb(pen))\r\nend\r\n\r\nglobal proc gxline(w,x,y,?x2,?y2)=\t\t!GXLINE\r\n#gxline(w,x,y)\t\t\tDraw line from current position to x,y\r\n#gxline(w,x,y,x2,y2)\tDraw line from x,y to x2,y2\r\n\r\ngdi:=w.gdi\r\n\r\nif x2.isvoid then\t\t!assume 2 params\r\n\tx2:=x\r\n\ty2:=y\r\n\r\n\tmovetoex(gdi.hdc,gdi.posx, gdi.posy)\r\n\tif gdi.drawmode=dm_screenmemory then\r\n\t\tmovetoex(gdi.hdc2,gdi.posx, gdi.posy)\r\n\tfi\r\nelse\r\n\tmovetoex(gdi.hdc,x, y)\r\n\tif gdi.drawmode=dm_screenmemory then\r\n\t\tmovetoex(gdi.hdc2,x, y)\r\n\tfi\r\n\tgdi.posx:=x\r\n\tgdi.posy:=y\r\nfi\r\nlineto(gdi.hdc,x2,y2)\r\nif gdi.drawmode=dm_screenmemory then\r\n\tlineto(gdi.hdc2,x2,y2)\r\nfi\r\ngdi.posx:=x2\r\ngdi.posy:=y2\r\nend\r\n\r\nglobal function gxwidth(w,width)=\r\n!get/set pen width for subsequent line drawing\r\ngdi:=w.gdi\r\nif width.isvoid then\r\n\treturn gdi.penwidth\r\nfi\r\n\r\nif gdi.penwidth<>width then\r\n\tgdi.penwidth:=width\r\n\tdeleteobject(selectobject(gdi.hdc,createpen(gdi.penstyle,gdi.penwidth,gdi.pencolour)))\r\n\tif gdi.drawmode=dm_screenmemory then\r\n\t\tdeleteobject(selectobject(gdi.hdc2,createpen(gdi.penstyle,gdi.penwidth,gdi.pencolour)))\r\n\tfi\r\n\r\nfi\r\nreturn width\r\nEND\r\n\r\nglobal proc gxlinerel(w,dx,dy)=\t\t!GXLINEREL\r\n#Draw line from current position, to current position + (dx,dy)\r\n\r\ngdi:=w.gdi\r\nmovetoex(gdi.hdc, gdi.posx, gdi.posy)\r\nif gdi.drawmode=dm_screenmemory then\r\n\tmovetoex(gdi.hdc2, gdi.posx, gdi.posy)\r\nfi\r\n!w.x+:=dx\r\n!w.y+:=dy\r\nx:=gdi.posx+dx\r\ny:=gdi.posy+dy\r\ngxline(w,x,y)\r\ngdi.posx:=x\r\ngdi.posy:=y\r\nend\r\n\r\nglobal proc gxmove(w,x2,y2)=\t\t!GXMOVE\r\n#Set current position to x2,y2\r\n\r\ngdi:=w.gdi\r\n\r\nmovetoex(gdi.hdc, x2, y2)\r\nif gdi.drawmode=dm_screenmemory then\r\n\tmovetoex(gdi.hdc2,x2, y2)\r\nfi\r\ngdi.posx:=x2\r\ngdi.posy:=y2\r\nend\r\n\r\nglobal proc gxmoverel(w,dx,dy)=\t\t!GXMOVEREL\r\n#\tSet current position to current position+(dx,dy)\r\ngdi:=w.gdi\r\n\r\ngdi.posx+:=dx\r\ngdi.posy+:=dy\r\n\r\nmovetoex(gdi.hdc,gdi.posx, gdi.posy)\r\nif gdi.drawmode=dm_screenmemory then\r\n\tmovetoex(gdi.hdc2,gdi.posx, gdi.posy)\r\nfi\r\nend\r\n\r\nglobal proc gxrect(w,x,y,width,height)=\t\t!GXRECT\r\n#draw outline rectangle starting from x,y at top left, in current pen colour\r\n#overall size is width by height pixels inclusive (x,y to x+width+1,y+height-1)\r\n#outline is 1 pixel wide\r\n\r\ngdi:=w.gdi\r\ngdi.updated:=1\r\nif height<0 then y:=y+height+1; height:=-height fi\r\nif width<0 then x:=x+width+1; width:=-width fi\r\n\r\noldbrushstyle:=gdi.brushstyle\r\ngxbrushstyle(w,bs_hollow)\r\n\r\nrectangle(gdi.hdc,x, y, x+width, y+height)\r\nif gdi.drawmode=dm_screenmemory then\r\n\trectangle(gdi.hdc2,x, y, x+width,y+height)\r\nfi\r\ngxbrushstyle(w,oldbrushstyle)\r\nend\r\n\r\nglobal proc gxcircle(w,x,y,r)=\t\t!GXCIRCLE\r\n#draw circle at centre x,y in window w, of radius r, using current pen colour\r\n#outline is 1 pixel wide\r\n\r\ngdi:=w.gdi\r\ngdi.updated:=1\r\noldbrushstyle:=gdi.brushstyle\r\ngxbrushstyle(w,bs_hollow)\r\n\r\nellipse(gdi.hdc,x-r, y-r, x+r-1, y+r-1)\r\nif gdi.drawmode=dm_screenmemory then\r\n\tellipse(gdi.hdc2,x-r, y-r, x+r-1, y+r-1)\r\nfi\r\ngxbrushstyle(w,oldbrushstyle)\r\nend\r\n\r\nglobal proc gxellipse(w,x,y,r,r2)=\r\n\r\ngdi:=w.gdi\r\ngdi.updated:=1\r\noldbrushstyle:=gdi.brushstyle\r\ngxbrushstyle(w,bs_hollow)\r\n\r\nellipse(gdi.hdc,x-r, y-r2, x+r-1, y+r2-1)\r\nif gdi.drawmode=dm_screenmemory then\r\n\tellipse(gdi.hdc2,x-r, y-r2, x+r2-1, y+r2-1)\r\nfi\r\ngxbrushstyle(w,oldbrushstyle)\r\nend\r\n\r\nglobal proc gxfillcircle(w,x,y,r,?colour,mode=0)=\t\t!GXFILLCIRCLE\r\n#Draw filled circle with optional outline\r\n#x,y is the centre, r is the radius\r\n#(When the outline is drawn, the filled region is 1 pixel smaller all round)\r\n#colour is the colour of the filled region (current brush colour when omitted)\r\n#mode=1 to draw the outline, or mode=0 (default) to omit it\r\n#The outline is drawn in the current pen colour\r\ngdi:=w.gdi\r\n\r\ngdi.updated:=1\r\noldbrushcolour:=gdi.brushcolour\r\nif colour.isdef then\r\n\tgxbrushcolour(w,colour)\r\nfi\r\n\r\noldpenstyle:=gdi.penstyle\r\nif mode=0 then\t\t!inside only\r\n\tgxstyle(w,ps_null)\r\nfi\r\n\r\nellipse(gdi.hdc,x-r, y-r, x+r-1, y+r-1)\r\nif gdi.drawmode=dm_screenmemory then\r\n\tellipse(gdi.hdc2,x-r, y-r, x+r-1, y+r-1)\r\nfi\r\n\r\ngxstyle(w,oldpenstyle)\r\ngxbrushcolour(w,oldbrushcolour)\r\nend\r\n\r\nglobal function gxpixel(w,x,y,?colour)=\t\t!GXPIXEL\r\n#colour provided: set pixel at point x,y of window w to colour\r\n#colour omitted: return pixel colour from point x,y\r\n!set pixel at x,y with given rgb colour, or return pixel value if omitted (-1)\r\nw.gdi.updated:=1\r\n\r\nif colour.isvoid then\t\t!get pixel\r\n\tres:=getpixel(w.gdi.hdc, x, y)\r\n\tif w.gdi.drawmode=dm_screenmemory then\r\n\t\tgetpixel(w.gdi.hdc2, x, y)\r\n\tfi\r\n\treturn res\r\nelse\r\n\tsetpixel(w.gdi.hdc,x, y, colour)\r\n\tif w.gdi.drawmode=dm_screenmemory then\r\n\t\tsetpixel(w.gdi.hdc2,x,y,colour)\r\n\tfi\r\n\treturn colour\r\nfi\r\nend\r\n\r\nglobal function gxcaption(w,?caption)=\t\t!GXCAPTION\r\n#caption omitted:  return current window caption text\r\n#caption provided: set new window caption text\r\n\r\ncase w.windclass\r\nwhen window_class,popup_class then\r\n\r\n\tif caption.isdef then\t\t!set text\r\n\t\tsetwindowtext(w.gdi.hwnd,caption)\r\n\t\treturn caption\r\n\telse\r\n\t\tbuffer:=new(array,byte,512)\r\n\t\tn:=getwindowtext(w.gdi.hwnd,int(&buffer),buffer.len)\r\n\t\tif n then\r\n\t\t\ts:=makestr(&buffer,n)\t\t!needs assigment to ensure a copy is made befor buffer\r\n\t\t\t\t\t\t\t\t\t\t!is freed (assignment of return value might do the same)\r\n\t\telse\r\n\t\t\ts:=\"\"\r\n\t\tfi\r\n\t\treturn s\r\n\tfi\r\nesac\r\n\r\nif caption.isdef then\t\t!set text\r\n\tw.text:=caption\r\n\tgxdraw(w)\r\nfi\r\n\r\nreturn w.text\r\nend\r\n\r\nglobal proc gxtext(w,s,?x,?y)=\t\t!GXTEXT\r\n#Display text s\r\n#Text is drawn starting at (x,y) when provided, otherwise at current position\r\n#insertion point refers either to base line, or to top left of cell (not sure)\r\n#Text is drawn in current font, size, style and mode\r\n#Text typically contains no control codes, but can also contain cr and lf (also\r\n#tabs, but currently position isn't changed). However, text with control codes is\r\n#drawn a character at a time\r\n#Finishes with current position set to the end of the text\r\n\r\n!uses chr(16) for reverse tab. Reverse tabs are usually encoded as:\r\n!  chr(9)+chr(16), ie. normal tab then reverse tab\r\n!Reverse tab, after tabbing to next stop, then moves position back by width\r\n!of next substring\r\n\r\nreturn when s=\"\"\r\n\r\ngdi:=w.gdi\r\n\r\nif x.isvoid then x:=gdi.posx fi\r\nif y.isvoid then y:=gdi.posy fi\r\ngdi.updated:=1\r\n\r\n!scan the string and create a table of substrings and control codes\r\nstartpos:=lengths:=()\r\nngroups:=0\r\n\r\nforeach i,c in s do\r\n\tif c<32 then\r\n\t\t++ngroups\r\n\t\tstartpos[ngroups]:=i\r\n\t\tlengths[ngroups]:=0\r\n\telse\r\n\t\tif ngroups and lengths[ngroups] then\t\t!extend this group\r\n\t\t\t++lengths[ngroups]\r\n\t\telse\t\t\t\t\t\t\t\t\t\t!start new substring group\r\n\t\t\t++ngroups\r\n\t\t\tstartpos[ngroups]:=i\r\n\t\t\tlengths[ngroups]:=1\r\n\t\tfi\r\n\tfi\r\nod\r\n\r\nforall i,l in lengths do\r\n\tpos:=startpos[i]\r\n\tif l then\r\n\t\tslice:=pos..pos+l-1\r\n\t\ttextout(gdi.hdc,x, y,s.[slice],l)\r\n\r\n\t\tif gdi.drawmode=dm_screenmemory then\r\n\t\t\ttextout(gdi.hdc2,x,y,s.[slice],l)\r\n\t\tfi\r\n\t\tx +:= gxtextwidth(w,s.[slice])\r\n\r\n\telse\t\t\t\t!Deal with control codes\r\n\t\tcase s.[pos]\r\n\t\twhen 13 then\r\n\t\t\tx:=0\r\n\t\twhen 10 then\r\n\t\t\ty+:=20\t\t\t\t!NEEDS TO PICK CURRENT FONT DIMS\r\n\r\n\t\twhen 9,16 then\t\t\t!16 will be used as reverse tab\r\n\t\t\tcurrx:=x\r\n\t\t\tx:=0\r\n\t\t\tforall t in tabstops do\r\n\t\t\t\tx+:=t*chx\t\t\t\t!MUST BE CURRENT FONT NOT CHX\r\n\t\t\t\tif x>currx then exit fi\r\n\t\t\tod\r\n\t\t\twhile x<=currx do x+:=chx*8 od\r\n\r\n\t\t\tif s.[pos]=16 and i<ngroups and lengths[i+1] then\t!reverse offset for next substring\r\n\t\t\t\tpos:=startpos[i+1]\r\n\t\t\t\tx -:= gxtextwidth(w,s.[pos..pos+lengths[i+1]-1])+1\r\n\t\t\tfi\r\n\r\n\t\tesac\t\r\n\tfi\r\nod\r\n\r\ngdi.posx:=x\r\ngdi.posy:=y\r\nend\r\n\r\nglobal function gxtextcolour(w,?colour,?bgndcolour)=\t\t!GXTEXTCOLOUR\r\n#Set either text foreground colour or background colour, or both, or neither,\r\n#depending on which are supplied\r\n#Text colours will be colour indices, not rgb\r\n#Always returned current or new foreground\r\n\r\ngdi:=w.gdi\r\n\r\nif colour.isdef and colour<>w.style.textfgnd then\r\n\tw.style.textfgnd:=colour\r\n\tsettextcolour(gdi.hdc,getrgb(colour))\r\n\tif gdi.drawmode=dm_screenmemory then\r\n\t\tsettextcolour(gdi.hdc2,getrgb(colour))\r\n\tfi\r\nfi\r\nif bgndcolour.isdef and bgndcolour<>w.style.textbgnd then\r\n\tgxbgndcolour(w,bgndcolour)\r\nfi\r\n\r\nreturn w.style.textfgnd\r\nend\r\n\r\nglobal function gxtextwidth(font,?s)=\t\t!GXTEXTWIDTH\r\n# font is a window, or a font number within fonttable\r\n# font can be zero (then uses font 1)\r\n# return total pixel width of string s, using given font\r\n\r\nif s=\"\" then return 0 fi\r\n\r\nif not font.isint then\t\t\t!aasume font is window\r\n\tfont:=font.gdi.font\r\nfi\r\nif font=0 then font:=1 fi\r\n\r\nselectobject(screendc,fonttable[font])\r\nwidthheight:=new(ws_point)\r\n\r\ngettextextentpoint32(screendc,s,s.len,&widthheight)\r\n\r\nreturn widthheight.x\r\nend\r\n\r\nglobal function gxloadfont(n,facename,?style,height=0,width=0)=\t\t!GXLOADFONT\r\n#define new font\r\n#N is index into fonttable\r\n#facename is the name of the font\r\n#Style is optional font style, a string containing any of:\r\n#\tB,b\t\tBold\r\n#\tI,i\t\tItalic\r\n#\tU,u\t\tUnderline\r\n#\tS,s\t\tStrikeout\r\n#Height is height of text (default 0, gives default height?)\r\n#Weight is width; defautl 0 normally used for normal aspect of text\r\n\r\nif n<=0 then return 0 fi\r\n!n:=min(n,nglobalfonts)\r\n\r\nif style.isvoid then style:=\"\" fi\r\n\r\nif n<=nglobalfonts and fonttable[n] then\t\t\t!remove existing font\r\n\tigxremovefont(n)\r\nfi\r\n\r\np:=style\r\nbold:=400\r\nitalic:=0\r\nunderline:=0\r\nstrikeout:=0\r\nforall c in style do\r\n\tcase asc(convuc(c))\r\n\twhen 'B' then bold:=700\r\n\twhen 'I' then italic:=1\r\n\twhen 'U' then underline:=1\r\n\twhen 'S' then strikeout:=1\r\n\tesac\r\nod\r\n\r\nhfont:=createfont(\r\n\tfacename:\tfacename,\r\n\theight:\t\theight,\r\n\twidth:\t\twidth,\r\n\tbold:\t\tbold,\r\n\titalic:\t\titalic,\r\n\tunderline:\tunderline,\r\n\tcharset:\t0,\r\n\tquality:\t2,\r\n\tescapement:\t0,\r\n\torientation:0)\r\n\r\nif hfont=0 then\r\n\thfont:=getstockobject(system_font)\r\nfi\r\n\r\nfonttable[n]:=hfont\r\nnglobalfonts:=max(n,nglobalfonts)\r\n\r\nselectobject(screendc,fonttable[n])\r\n\r\ntm:=new(ws_textmetrics)\r\n\r\ngettextmetrics(screendc,&tm)\r\nfontdimtable[n]:=ws_point(tm.avecharwidth, tm.height+tm.externalleading)\r\n\r\nfontvdimtable[n]:=ws_point(tm.ascent, tm.descent)\r\n\r\nselectobject(screendc,getstockobject(system_font))\r\n\r\nreturn n\r\nend\r\n\r\nproc igxremovefont(n)=\r\n!unload font n, free table entry\r\n\r\nunless n in 1..nglobalfonts then return end\r\nif fonttable[n]=0 then return fi\t!already freed\r\n\r\n!w:=windowlist\r\n!while w<>nil do\r\n!\tif w.gdi.hdc and w.gdi.font>0 then\t\t!font was in use, set as undefined\r\n!\t\tw.gdi.font:=1\r\n!\t\tselectobject(w.gdi.hdc,fonttable[w.gdi.font])\r\n!\t\tif w.gdi.hdc2 then\r\n!\t\t\tselectobject(w.gdi.hdc2,fonttable[w.gdi.font])\r\n!\t\tfi\r\n!\tfi\r\n!\tw:=w.nextwind\r\n!od\r\n\r\ndeleteobject(fonttable[n])\t\t!get rid of this font\r\nfonttable[n]:=0\r\nend\r\n\r\nglobal function gxfont(w,font=1)=\t\t!GXFONT\r\n# select font from font table for subsequent text display; default is font 1\r\n\r\nif not w then w:=wapplic fi\r\nif not w then w:=wscreen fi\r\ngdi:=w.gdi\r\n\r\nif font.isdef and font<>gdi.font then\r\n\tif font not in 1..nglobalfonts then\r\n\t\tabort(\"Bad font number \"+tostr(font))\r\n\tfi\r\n\tgdi.font:=font\r\n\tif fonttable[font]=0 then\r\n\t\tabort(\"Font not in use \"+tostr(font))\r\n\tfi\r\n\r\n\toldhfont:=selectobject(gdi.hdc,fonttable[font])\r\n\tsendmessage(gdi.hwnd,wm_setfont,fonttable[font],0)\r\n\r\n\tif gdi.drawmode=dm_screenmemory then\r\n\t\toldhfont:=selectobject(gdi.hdc2,fonttable[font])\r\n\t\tsendmessage(gdi.hwnd2,wm_setfont,fonttable[font],0)\r\n\tfi\r\n\tif fontdimtable[font].x=0 then\t\t!set up dims\r\n\t\tgxchardim(font,0)\r\n\tfi\r\nfi\r\nreturn gdi.font\r\nend\r\n\r\nfunction hascontrolchars(s)=\t\t!TESTCTRLCHAR\r\n!scan string s looking for control chars\r\n!return 1 if control chars (<20H) are present\r\n\r\nforeach c in s do\r\n\tif c<32 then return 1 fi\r\nod\r\nreturn 0\r\nend\r\n\r\nglobal function gxchardim(font,vert=0)=\t\t\t!GXCHARDIM\r\n#return font char average width/height info as a point rec\r\n#wfont is a font number, or hwindow when the current font in that window is used\r\n#vert=1 means get ascent/descent pair instead of (vert=0) average width/height\r\n\r\nif not font.isint then\r\n\tfont:=font.gdi.font\r\nfi\r\nif font=0 then font:=1 fi\r\n\r\nif fontdimtable[font].x=0 then\t\t!probably stock fonts not setup with gxloadfont\r\n\tselectobject(screendc,fonttable[font])\r\n\ttm:=new(ws_textmetrics)\r\n\tgettextmetrics(screendc,&tm)\r\n\r\n\tfontdimtable[font]:=ws_point(tm.avecharwidth, tm.height+tm.externalleading)\r\n\tfontvdimtable[font]:=ws_point(tm.ascent, fontvdimtable[font].y:=tm.descent)\r\n\r\n\tselectobject(screendc,getstockobject(ansi_var_font))\r\nfi\r\n\r\nif vert then\r\n\treturn fontvdimtable[font]\r\nfi\r\n\r\nreturn fontdimtable[font]\r\nEND\r\n\r\nglobal function gxbgndcolour(w,?colour)=\t\t!GXBGNDCOLOUR\r\n#Set background colour (for text mainly)\r\n#colour will be a colour index\r\n#return current colour when omitted\r\ngdi:=w.gdi\r\n\r\nif colour.isdef then\r\n\r\n\tif colour<>w.style.textbgnd then\r\n\t\tw.style.textbgnd:=colour\r\nW.STYLE.WINDBGND:=COLOUR\r\n\t\tsetbkcolour(gdi.hdc,getrgb(colour))\r\n\t\tif gdi.drawmode=dm_screenmemory then\r\n\t\t\tsetbkcolour(gdi.hdc2,getrgb(colour))\r\n\t\tfi\r\n\tfi\r\n\tgxbgndmode(w,(colour<>w.style.windbgnd|1|0))\r\nfi\r\nreturn w.style.textbgnd\r\nend\r\n\r\nglobal function gxbgndmode(w,?mode)=\t\t!GXBGNDMODE\r\n#\tmode supplied: set new background mode:\r\n#\t\t1 y Y T\t\tSet opaque (T for True? Looks like Transparent)\r\n#\t\t0 n N F\t\tSet Transparent\r\n\r\ngdi:=w.gdi\r\n\r\nif mode.isdef  then\r\n\tcase mode\r\n\twhen 1,'y','Y','T' then\r\n\t\tw.style.bgndmode:=opaque\r\n\telse\r\n\t\tw.style.bgndmode:=transparent\r\n\tesac\r\n\r\n\tsetbkmode(gdi.hdc,mode+1)\r\n\tif gdi.drawmode=dm_screenmemory then\r\n\t\tsetbkmode(gdi.hdc2,mode+1)\r\n\tfi\r\nfi\r\nreturn w.style.bgndmode\r\nend\r\n\r\nglobal proc gxhighlight(w,x,y,width,height)=\t\t!GXHIGHLIGHT\r\n#Invert rectangular region\r\nconst dstinvert=0x00550009\t!patblt\r\ngdi:=w.gdi\r\n\r\ngdi.updated:=1\r\npatblt(gdi.hdc, x, y, width,height,dstinvert)\r\nif gdi.drawmode=dm_screenmemory then\r\n\tpatblt(gdi.hdc2, x,y, width,height,dstinvert)\r\nfi\r\nend\r\n\r\nglobal proc gxbitblt(w,x2,y2,width,height,x,y)=\t\t\t!GXBITBLT\r\n#Copy rectangular region of window to another location\r\ngdi:=w.gdi\r\ngdi.updated:=1\r\nbitblt(gdi.hdc, x2, y2, width,height,\r\n\t\t\tgdi.hdc,x,y,srccopy)\r\n\r\nif gdi.drawmode=dm_screenmemory then\r\n\tbitblt(gdi.hdc2,x2,y2,width,height,gdi.hdc2,x,y,srccopy)\r\nfi\r\nend\r\n\r\nglobal function gxaskmess(mode=0)=\r\n#wait for next message and return message number\r\n#return 0 if close or quit message seen\r\n#some messages will be ignored here (processsed via procmess) and will wait for next\r\n#mode=0\t\tReturn currmess.message\r\n#mode=1\t\tReturn currmess.message, but if a mm_command message, then return\r\n#\t\t\tthe command id. This means message numbers and command ids share the\r\n#\t\t\tsame space. This should work because messages are below 200, and ids above 200\r\n\r\nrepeat\r\n\tif mxwait_mm_message()=0 then\r\n\t\treturn 0\r\n\tfi\r\n\tif quitmess then return 0 fi\r\n\tx:=process_message(currmess)\r\n\r\n\tif currmess.message=mm_key and currmess.a=27 then\r\n\t\treturn 0\r\n\tfi\r\n\r\nuntil x=thismess\t\t\t\t\t!message ready to return\r\n\r\nif mode=1 and currmess.message=mm_command then\r\n\treturn currmess.a\r\nfi\r\n\r\nreturn currmess.message\r\nend\r\n\r\nfunction process_message(mess)=\r\n#user or default event processing for mm message\r\n#will call event handler if there is one\r\n#returns 1 (skipmess) if message has been processed here; caller must wait for another message\r\n#returns 0 (thismess) caller should deal with this message (it has not been processed, or has beenbut caller can process it too)\r\n\r\nif mess.wind=nil then\r\n\treturn thismess\r\nfi\r\n\r\ncase mess.message\r\nwhen mm_close then\r\n\treturn thismess\r\nesac\r\n\r\nstatus:=domessage(mess)\r\n\r\nreturn status\r\nend\r\n\r\nglobal proc docs=\r\n!global proc where docstrings for entire lib can go\r\n#Option dicts: used as args to gccreatewindow/gxcreatechildwindow:\r\n#\twf_border\t\tBorder style; see wbs_ enums\r\n#\twf_resize\t\t1 for resizable border (for top-level windows)\r\n# wf_hscroll\t\t1 for horizontal scrollbar\r\n# wf_vscroll\t\t1 for vertical scrollbar\r\n# wf_menu\t\t\t1 for a menubar\r\n# wf_caption\t\t1 for a caption bar (needs to be the right kind of border too)\r\n# wf_max\t\t\t1 for a max button\r\n# wf_minmax\t\t1 for a min/max buttons\r\n# wf_sysmenu\t\t1 for a system menu (right-click on top left I think)\r\n# wf_desktop\t\t1 to fill desktop\r\n# wf_clip\t\t\t1 to clip windows to desktop\r\n# wf_show\t\t\t1 to show window after creating\r\n# wf_iframe\t\t1 for pos/dim to refer to frame rather than client area\r\n# wf_cent\t\t\t1 to centre window\r\n# wf_toolwind\t\t1 for tool window (not sure what this means)\r\n\r\nend\r\n\r\nfunction newwindow(hwnd,index,windclass,borderstyle)=\r\n\r\nw:=new(rwindow,0)\r\nw.windclass:=windclass\r\n!w.style.borderstyle:=borderstyle\r\nw.index:=index\r\nw.childlist:=()\r\n\r\naddwindow(w)\r\nwx_setw(hwnd,w.gindex)\r\nreturn w\r\nend\r\n\r\nglobal function getrgb(index)=\r\nif index=0 then return 0 fi\r\nreturn colourvalues[index]\r\nend\r\n\r\nfunction readstyle(owner,windclass,options)=\r\n!process gx options stored in the given dict type\r\n!return a stylerec all filled in\r\n\r\nif options.type=stylerec then\t\t\t!already a stylerec\r\n\treturn options\r\nfi\r\n\r\nss:=new(stylerec)\r\nif options.isvoid then\t\t\t\t!use bunch of defaults\r\n\td::=defstyle\r\n\td.border:=defaultborderstyles[windclass]\r\n\treturn d\r\nfi\r\n\r\nss.border\t:=options{ss_border,defaultborderstyles[windclass]}\r\nss.justify\t:=options{ss_justify,defstyle.justify}\r\nss.vjustify\t:=options{ss_vjustify,defstyle.vjustify}\r\nss.textfgnd\t:=options{ss_textfgnd,defstyle.textfgnd}\r\nss.textbgnd\t:=options{ss_textbgnd,defstyle.textbgnd}\r\nss.bgndmode\t:=options{ss_bgndmode,defstyle.bgndmode}\r\n\r\nss.iframe\t:=options{ss_iframe,0}\r\nss.hilitetype\t:=options{ss_hilitetype,defstyle.hilitetype}\r\nss.marktype\t:=options{ss_marktype,(ss.hilitetype|0|defstyle.marktype)}\r\nss.imark\t:=options{ss_imark,defstyle.imark}\r\n\r\nif windclass in [toggle_class, select_class,mark_class] and ss.marktype then\r\n\tdef:=owner.style.windbgnd\r\nelse\r\n\tdef:=defstyle.windbgnd\r\nfi\r\n\r\nss.windbgnd\t:=options{ss_windbgnd,def}\r\nss.hscroll\t:=options{ss_hscroll,0}\r\nss.vscroll\t:=options{ss_vscroll,0}\r\nss.lbchange\t:=options{ss_lbchange,0}\r\nss.returnmess\t:=options{ss_returnmess,0}\r\nss.noupdate\t:=options{ss_noupdate,0}\r\n\r\nreturn ss\r\nend\r\n\r\nglobal function gxpanel(owner,pos,dim,?style)=\r\nss:=readstyle(owner,panel_class,style)\r\n\r\nw:=gxcontrol(owner,panel_class,pos,dim,ss)\r\n\r\ngxdraw(w)\r\n\r\nreturn w\r\nend\r\n\r\nglobal function gxstatusbar(owner,pos,dim,?style)=\r\n\r\nss:=readstyle(owner,statusbar_class,style)\r\n\r\nif ss.iframe=0 then\t\t\t\t\t!frame not included, but can't have it leaking outside owner\r\n\tbs:=ss.border\r\n\tif bscat[bs]<>'I' then\t\t\t!do adjustments\r\n\t\tdim+:=bswidths[bs].y1+bswidths[bs].y2\r\n\tfi\r\n\tss.iframe:=1\t\t\t\t\t!stop gxcontrol expanding dims\r\nfi\r\n\r\n(ecapos,ecadim):=gxclientarea(owner)\r\n\r\nif pos.isint then pos:=chr(pos) fi\r\nif convuc(pos) in \"T TOP\" then\t\t\t!along the top\r\n\tpos:=ecapos\r\n\tdir:='T'\r\nelse\t\t\t\t\t\t\t\t\t!along the bottom\r\n\tpos:=(ecapos[1],ecadim[2]-dim+ecapos[2])\r\n\tdir:='B'\r\nfi\r\ndim:=(ecadim[1],dim)\r\n\r\nss.dir:=dir\r\n\r\nw:=gxcontrol(owner,statusbar_class,pos,dim,ss)\r\n\r\ngxdraw(w)\r\n\r\nreturn w\r\nend\r\n\r\nglobal function gxframebar(owner,pos,dim,?style)=\r\n\r\nss:=readstyle(owner,framebar_class,style)\r\nif ss.iframe=0 then\t\t\t\t\t!frame not included, but can't have it leaking outside owner\r\n\tbs:=ss.border\r\n\tif bscat[bs]<>'I' then\t\t\t!do adjustments\r\n\t\tdim+:=bswidths[bs].y1+bswidths[bs].y2\r\n\tfi\r\n\tss.iframe:=1\t\t\t\t\t!stop gxcontrol expanding dims\r\nfi\r\n\r\n(ecapos,ecadim):=gxclientarea(owner)\r\n\r\nif pos.isint then pos:=chr(pos) fi\r\nif convuc(pos) in \"L LEFT\" then\t\t\t!along the left\r\n\tpos:=ecapos\r\n\tdir:='L'\r\nelse\t\t\t\t\t\t\t\t\t!along the right\r\n\tpos:=(ecadim[1]-dim+ecapos[1],ecapos[2])\r\n\tdir:='R'\r\nfi\r\ndim:=(dim,ecadim[2])\r\n\r\nss.dir:=dir\r\n\r\nw:=gxcontrol(owner,\tframebar_class,pos,dim,ss)\r\n\r\ngxdraw(w)\r\n\r\nreturn w\r\nend\r\n\r\nglobal function gxbutton(owner,pos,dim,caption,?style,id=201,enable=1)=\r\n#create clickable button\r\n#returns rwindow\r\n\r\nss:=readstyle(owner,button_class,style)\r\n\r\nw:=gxcontrol(owner,button_class,pos,dim,ss)\r\nw.id:=id\r\n\r\nw.text:=caption\r\nw.enable:=enable\r\ngxdraw(w)\r\n\r\nreturn w\r\nend\r\n\r\nglobal function gxlabel(owner,pos,dim,caption,?style)=\r\n#create static label button\r\n#returns rwindow\r\n\r\nss:=readstyle(owner,label_class,style)\r\n\r\nw:=gxcontrol(owner,label_class,pos,dim,ss)\r\n\r\nw.text:=caption\r\ngxdraw(w)\r\n\r\nreturn w\r\nend\r\n\r\nglobal function gxgroup(owner,pos,dim,?style)=\r\n#create group window that encapsulates a set of controls\r\n#returns rwindow\r\n\r\nss:=readstyle(owner,group_class,style)\r\n\r\nw:=gxcontrol(owner,group_class,pos,dim,ss)\r\n\r\ngxdraw(w)\r\n\r\nreturn w\r\nend\r\n\r\nfunction gxcontrol(owner,windclass=button_class,pos,dim,?ss)=\r\n\r\nif ss.type=dict or ss.isvoid then\r\n\tss:=readstyle(owner,windclass,ss)\r\nfi\r\nwb:=wbs_none\r\ncase ss.border\t\t\t!find wbs- version of windows-drawn borders\r\nwhen bs_simplew then\r\n\twb:=wbs_simple\r\nesac\r\n\r\nif ss.iframe and bscat[ss.border]<>'I' then\r\n\twidths:=bswidths[ss.border]\r\n\tpos[1]+:=widths.x1\r\n\tpos[2]+:=widths.y1\r\n\tdim[1]-:=widths.x1+widths.x2\r\n\tdim[2]-:=widths.y1+widths.y2\r\nFI\r\n\r\nhwnd:=wx_createcontrol(pos:pos,dim:dim,border:wb,owner:owner.gdi.hwnd)\r\n\r\nif hwnd=0 then\r\n\tabort(\"Can't create control window\")\r\nfi\r\n\r\nw:=newwindow(hwnd,0,no_class,ss.border)\r\nw.windclass:=windclass\r\nw.style:=ss\r\nw.owner:=owner\r\nw.enable:=1\r\n\r\nsetwindowdims_c(w,hwnd)\r\nsetupgdi(w,hwnd)\r\n\r\ngxdrawmode(w,dm_screenmemory)\r\n\r\ngxfont(w,labelfont)\r\n\r\ngxtextcolour(w,w.style.textfgnd,w.style.textbgnd)\r\n\r\ngxbgndmode(w,w.style.bgndmode)\r\n\r\n!link into owner\r\nw.owner.childlist append:=w\r\nw.index:=w.owner.childlist.upb\r\n\r\nreturn w\r\nend\r\n\r\nglobal function gxtoggle(owner,pos,dim,caption=\"\",linkvar,?style,id=201,enable=1)=\r\n\r\n(posx,posy):=pos\r\n(dimx,dimy):=dim\r\ntextoffset:=0\r\n\r\nss:=readstyle(owner,toggle_class,style)\r\n\r\n!work out whether an auxiliary window is needed\r\n\r\nif ss.marktype then\r\n\tif ss.imark=0 then\t\t\t!dims don't include the mark\r\n\t\tposx-:=markdim\r\n\t\tdimx+:=markdim\r\n\t\ttextoffset:=markdim\r\n\tfi\r\nfi\r\n\r\nw:=gxcontrol(owner,toggle_class,(posx,posy),(dimx,dimy),ss)\r\nw.linkvar:=linkvar\r\nw.id:=id\r\nw.text:=caption\r\nw.attrs:=togglerec(textoffset,1)\r\nw.enable:=enable\r\n\r\nif w.style.marktype then\r\n!\tgxmark(owner:w,pos:(0,(w.dimy-markdim)%2),id:id,style:style)\r\n\tgxmark(owner:w,pos:(0,(w.dimy-markdim)%2),id:id, style:ss)\r\nfi\r\n\r\ngxdraw(w)\r\nreturn w\r\nend\r\n\r\nglobal function gxselect(owner,pos,dim,caption=\"\",linkvar,onvalue,?style,id=201,enable=1)=\r\n\r\n(posx,posy):=pos\r\n(dimx,dimy):=dim\r\ntextoffset:=0\r\n\r\nss:=readstyle(owner,select_class,style)\r\n\r\n!work out whether an auxiliary window is needed\r\nif ss.marktype and ss.imark=0 then\t\t\t!dims don't include the mark\r\n\tposx-:=markdim\r\n\tdimx+:=markdim\r\n\ttextoffset:=markdim\r\nfi\r\n\r\nw:=gxcontrol(owner,select_class,(posx,posy),(dimx,dimy),ss)\r\n\r\nw.linkvar:=linkvar\r\nw.id:=id\r\nw.text:=caption\r\nw.attrs:=togglerec(textoffset,onvalue)\r\nw.enable:=enable\r\nif w.style.marktype then\r\n\tgxmark(owner:w,pos:(0,(w.dimy-markdim)%2),id:id, style:style)\r\nfi\r\n\r\ngxdraw(w)\r\nreturn w\r\nend\r\n\r\nglobal proc showmessage(mess)=\r\n!RETURN\r\nCPL MESS.MESSAGE\r\ncp \"Message:\",leftstr(messagenames[mess.message],20)\r\ncp \"A:\",,mess.a,\"B:\",,mess.b\r\ncp \" (X:\",,mess.x,\"Y:\",,mess.y,,\") Buttons:\",mess.state:\"b\"\r\n\r\ncpl \"\tWindow:\",mess.wind.name\r\nend\r\n\r\nfunction domessage(mess)=\r\n\r\n!CPL \"DOMESSAGE\",MESS.MESSAGE\r\nm:=mess.message\r\nw:=mess.wind\r\n\r\nIF W.GDI=0 THEN PCERROR(\"DOM/GDI=0\") FI\r\n\r\ncase m\r\nwhen mm_move,mm_setcursor then\r\n\treturn skipmess\r\nwhen mm_timer then\r\n\treturn thismess\r\nesac\r\n\r\nx:=messhandlertable[m,w.windclass]^(mess,w)\r\n\r\nreturn x\r\nend\r\n\r\nproc init_handlertables=\r\n\r\nmesshandlertable::=new(list,mm_null..mm_last,new(list,no_class..dummy_class,0))\r\n\r\n$pcldata('PROCINIT')\r\nmessalltable:=new(list,mm_null..mm_last,0)\t\t!for all mess_mess_all handlers\r\nfnallall:=nil\t\t\t\t\t\t\t\t\t!for single mess_all_all handler\r\nfnfixups:=nil\r\n\r\nactionalltable:=new(list,1..last_w,0)\r\nfor i:=1 to last_w do\r\n\tactionhandlertable[i]:=(0:0,)*(dummy_class-no_class+1)\r\nod\r\n\r\nwhile data:=$pcldata('PROC') do\r\n\tif not data[2] then\r\n\t\tnext\r\n\tfi\r\n\tfnptr:=data[4]\r\n\t(name,messname,windname):=splitstring(data[1],\"_\")\t\t\t!split function name\r\n\r\n\tcase leftstr(data[2],2)\r\n\twhen \"mx\" then\r\n\r\n\t\tif messname=\"all\" and windname=\"all\" then\r\n\t\t\tfnallall:=fnptr\r\n\t\telse\r\n\t\t\tmessage:=(\"mm_\"+messname) in messagenames\r\n\t\t\tif not message then\r\n\t\t\t\tABORT(\"CAN'T FIND MESSAGE \"+messname)\r\n\t\t\tfi\r\n\t\t\tif windname=\"all\" then\t\t\t\t!assume <mess> all\r\n\t\t\t\tmessalltable[message]:=fnptr\r\n\t\t\telse\r\n\t\t\t\tbtnnames:=splitstring(data[2],\" \")\t!(mx) or (mx,alt1,alt2 etc)\r\n\t\t\t\tbtnnames[1]:=windname\t\t\t\t!replace mx by name of primary window class\r\n\t\t\t\tforall wname in btnnames do\r\n\t\t\t\t\twindclass:=wname+\"_class\" in windowclassnames\r\n\t\t\t\t\tif windclass=0 then\r\n\t\t\t\t\t\tABORT(\"CAN'T FIND WINDOW \"+wname)\r\n\t\t\t\t\tfi\r\n\t\t\t\t\tmesshandlertable[message,windclass]:=fnptr\r\n\t\t\t\tod\r\n\t\t\tfi\r\n\t\tfi\r\n\r\n\twhen \"wx\" then\r\n\t\taction:=messname+\"_w\" in actionnames\r\n\t\tif not action then\r\n\t\t\tABORT(\"CAN'T FIND ACTION \"+MESSNAME)\r\n\t\tfi\r\n\t\tif windname=\"all\" then\r\n\t\t\tactionalltable[action]:=fnptr\r\n\t\telse\r\n\t\t\tbtnnames:=splitstring(data[2],\" \")\t!(mx) or (mx,alt1,alt2 etc)\r\n\t\t\tbtnnames[1]:=windname\t\t\t\t!replace mx by name of primary window class\r\n\t\t\tforall wname in btnnames do\r\n\t\t\t\twindclass:=wname+\"_class\" in windowclassnames\r\n\t\t\t\tif windclass=0 then\r\n\t\t\t\t\tABORT(\"AX:CAN'T FIND WINDOW \"+wname)\r\n\t\t\t\tfi\r\n\t\t\t\tactionhandlertable[action,windclass]:=fnptr\r\n\t\t\tod\r\n\t\tfi\r\n\twhen \"fx\" then\r\n\t\tfnfixups:=fnptr\r\n\tesac\r\nod\r\n\r\n!!do some manual fixups\r\nif fnfixups then\r\n\tfnfixups^()\r\nfi\r\n\r\nfor mx:=0 to mm_last do\r\n\tfor wx:=0 to dummy_class do\r\n\t\tif not messhandlertable[mx,wx] then\r\n\t\t\tmesshandlertable[mx,wx]:=(messalltable[mx]|messalltable[mx]|fnallall)\r\n\t\tfi\r\n\tod\r\nod\r\n\r\nif not fnallall then\r\n\tpcerror(\"Can't find all/all mess handler\")\r\nfi\r\n\r\nfor ax:=1 to last_w do\r\n\tfor wx:=0 to dummy_class do\r\n\t\tif not actionhandlertable[ax,wx] then\r\n\t\t\tif not actionalltable then\r\n\t\t\t\tpcerror(\"No DO/ALL handler for:\"+actionnames[ax])\r\n\t\t\tfi\r\n\t\t\tactionhandlertable[ax,wx]:=actionalltable[ax]\r\n!\t\t\tactionhandlertable[ax,wx]::=actionalltable[ax]\r\n\t\tfi\r\n\tod\r\nod\r\n\r\nend\r\n\r\nglobal proc gxdraw(w)=\r\nfnptr:=actionhandlertable[draw_w,w.windclass]\r\nif fnptr then\r\n\tfnptr^(w)\r\nelse\r\n\tcpl \"NO DRAW HANDLER\",windowclassnames[w.windclass],w.name\r\n\twaitsec(1)\r\n\tstop\r\nfi\r\nend\r\n\r\nglobal proc gxupdate(w)=\r\nfnptr:=actionhandlertable[update_w,w.windclass]\r\nif fnptr then\r\n\tfnptr^(w)\r\nelse\r\n\tgxdraw(w)\r\nfi\r\nend\r\n\r\nglobal proc eventloop=\r\ndo\r\n\tm:=gxaskmess()\r\n\r\n\tSHOWMESSAGE(CURRMESS)\r\n\r\n\tcase m\r\n\twhen 0,mm_cancel then\r\n\t\treturn\r\n\tesac\r\n\r\nod\r\nend\r\n\r\nglobal function gxeditbox(owner,pos,dim,linkvar,?style,id=201,enable=1)=\r\n\r\nss:=readstyle(owner,editbox_class,style)\r\n\r\nw:=gxcontrol(owner,editbox_class,pos,dim,ss)\r\n\r\nw.linkvar:=linkvar\r\nw.id:=id\r\nw.attrs:=new(editboxrec)\r\nw.attrs.currpos:=linkvar^.len+1\r\nw.enable:=enable\r\ngxdraw(w)\r\n!paintselect(w)\r\nreturn w\r\nend\r\n\r\nglobal proc gxebchange(w,?linkvar,charpos=-1)=\r\n\r\nif linkvar.isdef then\r\n\tw.linkvar:=linkvar\r\nfi\r\n\r\nif charpos=-1 then\r\n\tw.attrs.currpos:=w.linkvar^.len+1\r\nelse\r\n\tw.attrs.currpos:=charpos\r\nfi\r\ngxupdate(w)\r\nend\r\n\r\nglobal proc gxsetlbdata(w,linkvar,?pos)=\r\nw.linkvar:=linkvar\r\nif pos.isvoid then\r\n\tpos:=(linkvar^|1|0)\r\nfi\r\nw.attrs.currpos:=pos\r\n\r\nif w.childlist[1] then\r\n!\tgxsetscrolllimits(ws,linkvar^.bounds,w.attrs.rows)\r\n\tgxsetscrolllimits(ws,getlvbounds(linkvar),w.attrs.rows)\r\n\tgxscrollpos(ws,pos)\r\nfi\r\nend\r\n\r\nglobal proc gxsetlbpos(w,pos)=\r\n!change in pos\r\nw.attrs.currpos:=pos\r\n\r\n!work out screen row\r\nif pos then\r\n\toldpagepos:=w.attrs.pagepos\r\n\tif pos<oldpagepos then\r\n\t\tw.attrs.pagepos:=pos\r\n\telsif pos>oldpagepos+w.attrs.rows-1 then\r\n\t\tw.attrs.pagepos:=pos-w.attrs.rows+1\r\n\tfi\r\n\tif w.attrs.pagepos<>oldpagepos then\r\n\t\tif w.childlist then\r\n\t\t\tgxscrollpos(w.childlist[1],w.attrs.pagepos)\r\n\t\tfi\r\n\t\tm:=mm_draw\r\n\telse\r\n\t\tm:=mm_update\r\n\tfi\r\nelse\r\n\tm:=mm_draw\r\nfi\r\n\r\npostmess(w,m)\r\nif w.style.lbchange then\r\n\tpostmess(w,mm_lbchange,w.attrs.currpos)\r\nfi\r\nend\r\n\r\nglobal proc gxsetlbpage(w,pagepos)=\r\n!change in pagepos (originates from scrollbar message)\r\nw.attrs.pagepos:=pagepos\r\n\r\noldpos:=w.attrs.currpos\r\nif oldpos<pagepos then\r\n\tw.attrs.currpos:=pagepos\r\nelsif oldpos>=pagepos+w.attrs.rows then\r\n\tw.attrs.currpos:=pagepos+w.attrs.rows-1\r\nfi\r\n\r\nif w.childlist then\r\n\tgxscrollpos(w.childlist[1],pagepos)\r\nfi\r\n\r\npostmess(w,mm_draw)\r\nif w.style.lbchange and oldpos<>w.attrs.currpos then\r\n\tpostmess(w,mm_lbchange,w.attrs.currpos)\r\nfi\r\nend\r\n\r\nglobal function gxlistbox(owner,pos,dim,linkvar,?style,id=201,rows=0,pitch=0,offset=0)=\r\n\r\nss:=readstyle(owner,listbox_class,style)\r\n\r\n(dimx,dimy):=dim\r\nif ss_vscroll and ss_imark=0 then\t\t\t!dims don't include the scrollbar\r\n\tdimx+:=arrowdim\r\nfi\r\n\r\nw:=gxcontrol(owner,listbox_class,pos,(dimx,dimy),ss)\r\nw.linkvar:=linkvar\r\nw.id:=id\r\nw.attrs:=new(listboxrec)\r\n\r\nif pitch=0 then\t\t\t\t\t\t\t\t!calculate all these here\r\n\tpitch:=listrowheight\r\n\toffset:=0\r\n\trows:=w.dimy%pitch\r\nfi\r\nw.attrs.rows:=rows\r\nw.attrs.pitch:=pitch\r\nw.attrs.offset:=offset\r\n\r\nw.attrs.pagepos:=1\r\nw.attrs.currpos:=(getlvbounds(linkvar).len|1|0)\r\n\r\nif w.style.vscroll then\r\n\tws:=gxvertscrollbar(owner:w,pos:(w.dimx-arrowdim,0),dim:w.dimy,id:id,style:style)\r\n!\tgxsetscrolllimits(ws,linkvar^.bounds,w.attrs.rows)\r\n\tgxsetscrolllimits(ws,getlvbounds(linkvar),w.attrs.rows)\r\n!\tgxscrollpos(ws,linkvar^.lwb)\r\n\r\n\tgxscrollpos(ws,getlvbounds(linkvar).lwb)\r\n!\tgxscrollpos(ws,1)\r\nfi\r\n\r\ngxdraw(w)\r\nreturn w\r\nend\r\n\r\nglobal function gxarrow(owner,pos,?dim,dir,?style,id=201)=\r\n\r\nss:=readstyle(owner,arrow_class,style)\r\nif dim.isvoid then\r\n\tdim:=(arrowdim,arrowdim)\r\nfi\r\n\r\nw:=gxcontrol(owner,arrow_class,pos,dim,ss)\r\nw.id:=id\r\nif dir.isstring then dir:=asc(dir) fi\r\ncase dir\t\t\t\t\t!allow compass bearings too, but convert to UDLR\r\nwhen 'N' then dir:='U'\r\nwhen 'E' then dir:='R'\r\nwhen 'S' then dir:='D'\r\nwhen 'W' then dir:='L'\r\nesac\r\n\r\nw.style.dir:=dir\t\t\t!don't dir allow via style options\r\ngxdraw(w)\r\n\r\nreturn w\r\nend\r\n\r\nglobal proc gxsetscrolllimits(w,limits,span=0)=\r\n!set up or change scrollbar limits\r\n!span=0:\r\n!\tPure ranging control. Limits are actual range of the thumb.\r\n!\tThumb is drawn at a fixed, nominal size. Might be suppressed when limits are <=1\r\n!\tInitial position set to limits.lwb\r\n!span=M:\r\n!\tPaging control, such as used on a listbox or text editor.\r\n!\tSpan can be the number of rows display at one time.\r\n!\tLimit can be single number N, or range 1..N.\r\n!\tActual scroll bar range will be 1..N-M+1. When upper limit<1 then\r\n!\tlimit will be 1..1, and thumb might not be drawn\r\n!\tData position will: actually there /is/ not data position, except for the\r\n!\tdata position represented by the top row, which will be the same as the scroll\r\n!\tposition.\r\n!Arrows should be disabled (and perhaps thumb suppressed) when scroll range if 1..1,\r\n!or data range is nor larger than a span\r\n\r\nw.attrs.span:=span\r\nif w.style.dir='H' then\r\n\twidth:=w.dimx\r\nelse\r\n\twidth:=w.dimy\r\nfi\r\nm:=width-arrowdim*2\t\t\t\t!number of pixels movement between arrows\r\n\r\nif span=0 then\t\t\t\t\t\t!pure scrolling control\r\n\tw.attrs.limits:=limits\r\n\tw.attrs.currpos:=limits.lwb\r\n\tw.attrs.thumbsize:=arrowdim\r\n\tenable:=limits.len>1\r\n\tw.attrs.thumbsize:=arrowdim*enable\r\nelse\r\n\tif limits.isrange then\r\n\t\tlength:=limits.len\r\n\telse\r\n\t\tlength:=limits\r\n\tfi\r\n\tif length<=span then\r\n\t\tenable:=0\r\n\t\tw.attrs.limits:=1..1\r\n\t\tw.attrs.thumbsize:=0\r\n\telse\r\n\t\tw.attrs.limits:=1..length-span+1\r\n\t\tenable:=1\r\n\t\tw.attrs.thumbsize:=max(10,int(m*(span/length)))\r\n\tfi\r\nfi\r\n\r\nw.attrs.currpos:=w.attrs.limits.lwb\r\nw.enable:=enable\r\n\r\nw.attrs.thumbspan:=m-w.attrs.thumbsize\t\t!movement available to thumb\r\nw.attrs.thumbpos:=arrowdim\r\npostmess(w,mm_draw)\r\nend\r\n\r\nglobal function gxscrollpos(w,pos,u=0)=\r\n!\r\nif pos.isvoid then\r\n\treturn w.attrs.currpos\r\nfi\r\n\r\nw.attrs.currpos:=pos\r\nif pos not in w.attrs.limits then\r\n\tpcerror(\"Bad scroll pos\")\r\nfi\r\n\r\ntpos:=int(w.attrs.thumbspan*((pos-w.attrs.limits.lwb)/(w.attrs.limits.len-1)))\r\nw.attrs.thumbpos:=arrowdim+tpos\r\n\r\nw.childlist[1].enable:=pos>w.attrs.limits.lwb\r\nw.childlist[2].enable:=pos<w.attrs.limits.upb\r\n\r\nif u then\r\n\tpostmess(w,mm_update)\r\nfi\r\nreturn 0\r\nend\r\n\r\nglobal function gxhozscrollbar(owner,pos,dim,?style,id=201)=\r\n\r\nss:=readstyle(owner,scrollbar_class,style)\r\nwidth:=arrowdim\r\nif dim.isint then\r\n\tdim:=(dim,width)\r\nelse\r\n\twidth:=dim[1]\r\nfi\r\n\r\nw:=gxcontrol(owner,scrollbar_class,pos,dim,ss)\r\nw.id:=id\r\nw.style.dir:='H'\r\n\r\nw.attrs:=new(scrollbarrec)\r\nw.flags.[wa_leftdrag]:=1\r\n\r\n!Now, create the arrows at each end. The thumbbar is not an explicit control,\r\n!it's just a drawn box\r\nwa:=gxarrow(owner:w, pos:(0,0), dim:(width,width),dir:'L')\r\nwb:=gxarrow(owner:w, pos:(dim[1]-width,0), dim:(width,width),dir:'R')\r\n\r\ngxsetscrolllimits(w,1..200,20)\r\ngxscrollpos(w,1)\r\n\r\ngxdraw(w)\r\n\r\nreturn w\r\nend\r\n\r\nglobal function gxvertscrollbar(owner,pos,dim,?style,id=201)=\r\nss:=readstyle(owner,scrollbar_class,style)\r\nwidth:=arrowdim\r\nif dim.isint then\r\n\tdim:=(width,dim)\r\nelse\r\n\twidth:=dim[2]\r\nfi\r\n\r\nw:=gxcontrol(owner,scrollbar_class,pos,dim,ss)\r\nw.id:=id\r\nw.style.dir:='V'\r\n\r\nw.attrs:=new(scrollbarrec)\r\nw.flags.[wa_leftdrag]:=1\r\n\r\n!Now, create the arrows at each end. The thumbbar is not an explicit control,\r\n!it's just a drawn box\r\nwa:=gxarrow(owner:w, pos:(0,0), dim:(width,width),dir:'U')\r\nwb:=gxarrow(owner:w, pos:(0,dim[2]-width), dim:(width,width),dir:'D')\r\ngxsetscrolllimits(w,100..200,2)\r\n\r\ngxscrollpos(w,100)\r\n\r\ngxdraw(w)\r\n\r\nreturn w\r\nend\r\n\r\nglobal function gxmark(owner,pos,?dim,?style,id=201)=\r\n\r\nss:=readstyle(owner,mark_class,style)\r\nif dim.isvoid then\r\n\tdim:=(markdim,markdim)\r\nfi\r\n\r\nw:=gxcontrol(owner,mark_class,pos,dim,style)\r\nw.id:=id\r\ngxdraw(w)\r\n\r\nreturn w\r\nend\r\n\r\nglobal proc gxfocus(w)=\r\n!switch focus to window w\r\nif wfocus==w then\r\n\treturn\r\nfi\r\n\r\nif wfocus then\r\n\tdomessage(makemess(wfocus,mm_killfocus))\r\nfi\r\ncaretdrawn:=0\r\ndomessage(makemess(w,mm_setfocus))\r\nend\r\n\r\nglobal proc gxkillfocus=\r\nif wfocus then\r\n\tdrawcaret(0)\r\nfi\r\nwfocus:=nil\r\nend\r\n\r\nglobal function gxcopy(w,?bm,x=0,y=0,scalex=1.0,scaley=0,sx=0,sy=0,dimx=0,dimy=0)=\t\t!GXCOPY\r\n!copy bitmap bm to window w, at position x,y in w. Scalex/y can be 0 for 1:1,\r\n!or Scalex/y can be any real value for unequal x/y scaling\r\n!For equal x/y scaling, Scaley can be 0\r\n!Entire bitmap is copied (sx,sy,w,h all 0); for portion, set sx,sy to top left of rect\r\n!and w,h to size to be copied\r\n![1..100]char str\r\n\r\nif bm.isvoid then\r\n\tbm:=w\r\n\tw:=nil\r\nfi\r\nif bm.isvoid then\r\n\treturn nil\r\nfi\r\n\r\nif dimx=0 then dimx:=bm.dimx-sx fi\r\nif dimy=0 then dimy:=bm.dimy-sy fi\r\n\r\nif scalex=0 then scalex:=1.0 fi\r\nif scaley=0 then scaley:=scalex fi\r\n\r\nif w=nil then\t\t!create appropriate window\r\n\tw:=gxcreatewindow(caption:\"Bitmap \"+tostr(bm.pixelbits)+\" bit\",pos:(500,500),\r\n\t\t\tdim:(bm.dimx*scalex,bm.dimy*scaley))\r\n\tw.gdi.drawmode:=dm_screenmemory\t\t\t!default when using auto-window\r\nfi\r\n\r\ngdi:=w.gdi\r\ngdi.updated:=1\r\n\r\n!#define BLACKONWHITE\t1\r\n!#define COLORONCOLOR\t3\r\n!#define HALFTONE\t4\r\n!#define MAXSTRETCHBLTMODE\t4\r\n!#define STRETCH_ANDSCANS\t1\r\n!#define STRETCH_DELETESCANS\t3\r\n!#define STRETCH_HALFTONE\t4\r\n!#define STRETCH_ORSCANS\t2\r\n!#define WHITEONBLACK\t2\r\n!\r\n\r\nmode:=copymode\r\n!mode:=2\r\n!mode:=4\r\n\r\nsetstretchbltmode(gdi.hdc,mode)\r\nstretchblt(gdi.hdc, x, y,int(dimx*scalex),int(dimy*scaley),\r\n\t\t\t\t\t\t\t\t\t\t\tbm.gdi.hdc,sx,sy,dimx,dimy, srccopy)\r\nif gdi.drawmode=dm_screenmemory then\r\n\tsetstretchbltmode(gdi.hdc2,mode)\r\n\tstretchblt(gdi.hdc2,x,y,int(dimx*scalex),int(dimy*scaley),\r\n\t\t\t\t\t\t\t\t\t\t\tbm.gdi.hdc,sx,sy,dimx,dimy, srccopy)\r\nfi\r\nreturn w\r\nend\r\n\r\nglobal proc gxrestore(w,?r)=\r\n!repaint window w\r\n!only called when repaint can be done from a backup\r\n!r is the region to restore within w; or restore all if omitted\r\n\r\nif r.isvoid then\r\n\tx1:=y1:=0\r\n\twidth:=w.dimx\r\n\theight:=w.dimy\r\nelse\r\n\tx1:=r.x1\r\n\ty1:=r.x2\r\n\twidth:=r.x2-x1+1\r\n\theight:=r.y2-y1+1\r\nfi\r\n\r\ncase w.gdi.drawmode\r\nwhen dm_screen then\t\t\t!can't restore; need to call gx_draw\r\n\tgxdraw(w)\r\nwhen dm_screenmemory then\r\n\tdestdc:=w.gdi.hdc\r\n\tsourcedc:=w.gdi.hdc2\r\nwhen dm_memoryscreen then\r\n\tdestdc:=w.gdi.hdc2\r\n\tsourcedc:=w.gdi.hdc\r\nelse\r\n\tabort(\"gxrest/?\")\r\nesac\r\n\r\nbitblt(destdc,x1,y1, width,height, sourcedc, x1,y1, srccopy)\r\n\r\nend\r\n\r\nglobal function gxdrawmode(w,?drawmode)=\r\n!set or get drawmode\r\n!really requires window to be cleared afterwards.\r\n\r\nolddrawmode:=w.gdi.drawmode\r\nif w.isvoid then\r\n\treturn olddrawmode\r\nfi\r\n\r\nif olddrawmode=drawmode then\t\t!already set\r\n\treturn drawmode\r\nelsif olddrawmode<>dm_screen then\t!can only change screen => screenmemory/memoryscreen\r\n\tabort(\"gxdrawmode2\")\t\t\t!not memory to anything else\r\nfi\r\n\r\n!assuming currently on screen, will need extra compatible bitmap\r\nmemhwnd:=createcompatiblebitmap(screendc,w.dimx,w.dimy)\r\nmemhdc:=createcompatibledc(nil)\r\nselectobject(memhdc,memhwnd)\r\n\r\n!need to change draw mode\r\ncase drawmode\r\nwhen dm_screenmemory then\r\n\tw.gdi.hwnd2:=memhwnd\r\n\tw.gdi.hdc2:=memhdc\r\nwhen dm_memoryscreen then\r\n\tw.gdi.hwnd2:=w.gdi.hwnd\t\t\t!screen becomes secondary\r\n\tw.gdi.hdc2:=w.gdi.hdc\r\n\tw.gdi.hwnd:=memhwnd\r\n\tw.gdi.hdc:=memhdc\r\nelse\r\n\tabort(\"gxdrawmode?\")\r\nesac\r\n\r\nw.gdi.drawmode:=drawmode\r\nreturn drawmode\r\nend\r\n\r\nglobal proc switchdest(w)=\r\n!for a window with screenmemory drawmode, switch things around so that\r\n!it's drawing into the memory area only\r\ngdi:=w.gdi\r\n\r\ncase gdi.drawmode\r\nwhen dm_screenmemory then\r\n\tt:=gdi.hwnd; gdi.hwnd:=gdi.hwnd2; gdi.hwnd2:=t\r\n\tt:=gdi.hdc; gdi.hdc:=gdi.hdc2; gdi.hdc2:=t\r\n\tgdi.drawmode:=dm_memory\r\nwhen dm_memory then\r\n\tt:=gdi.hwnd; gdi.hwnd:=gdi.hwnd2; gdi.hwnd2:=t\r\n\tt:=gdi.hdc; gdi.hdc:=gdi.hdc2; gdi.hdc2:=t\r\n\tgdi.drawmode:=dm_screenmemory\r\nesac\r\nend\r\n\r\nglobal proc gxclose(w)=\r\n\r\ncase w.windclass\r\nwhen bitmap_class then\r\nelse\r\n\tif issubwindow(w,wfocus) then\r\n\t\twfocus:=nil\r\n\tfi\r\n\r\n\tif issubwindow(w,wmouse) then\t\r\n\t\tlastmousewindow:=nil\r\n\t\twmouse:=nil\r\n\tfi\r\n\r\n\tdestroywindow(w.gdi.hwnd)\r\n\tgxfreewindow(w)\r\nesac\r\nend\r\n\r\nproc gxfreewindow(w)=\r\n!recover memory used by this window and all childwindows\r\nforall wc in w.childlist do\r\n\tgxfreewindow(wc)\r\nod\r\n\r\nremovewindow(w)\r\n\r\nw.gdi:=0\r\nw:=0\r\nend\r\n\r\nglobal function gxmsgbox(message,caption=\"\",options=\"\")=\r\n\r\nconst mb_abortretryignore\t= 0x02\r\nconst mb_applmodal\t\t\t= 0x00\r\nconst mb_defbutton1\t\t\t= 0x00\r\nconst mb_defbutton2\t\t\t= 100\r\nconst mb_defbutton3\t\t\t= 200\r\nconst mb_defbutton4\t\t\t= 300\r\nconst mb_help\t\t\t\t= 4000\r\nconst mb_iconasterisk\t\t= 40\r\nconst mb_iconerror\t\t\t= 10\r\nconst mb_iconexclamation\t= 30\r\nconst mb_iconhand\t\t\t= mb_iconerror\r\nconst mb_iconinformation\t= mb_iconasterisk\r\nconst mb_iconquestion\t\t= 20\r\nconst mb_iconstop\t\t\t= mb_iconhand\r\nconst mb_iconwarning\t\t= mb_iconexclamation\r\nconst mb_ok\t\t\t\t\t= 0x00\r\nconst mb_okcancel\t\t\t= 0x01\r\nconst mb_retrycancel\t\t= 0x05\r\nconst mb_right\t\t\t\t= 80000\r\nconst mb_setforeground\t\t= 10000\r\nconst mb_systemmodal \t\t= 1000\r\nconst mb_taskmodal\t\t\t= 2000\r\nconst mb_yesno\t\t\t\t= 0x04\r\nconst mb_yesnocancel\t\t= 0x03\r\nconst mb_topmost\t\t\t= 0x040000\r\n\r\n!return values\r\nconst idfail\t= 0\r\nconst idok\t\t= 1\r\nconst idcancel\t= 2\r\nconst idabort\t= 3\r\nconst idretry\t= 4\r\nconst idignore\t= 5\r\nconst idyes\t\t= 6\r\nconst idno\t\t= 7\r\n\r\nstatic var rettable=(0:\"fail\",\"ok\",\"cancel\",\"abort\",\"retry\",\"ignore\",\"yes\",\"no\",\r\n\t\t\"\",\"\",\"tryagain\",\"continue\")\r\n\r\nstatic var styletable=(\r\n(\"bari\",mb_abortretryignore),\r\n(\"bo\",mb_ok),\r\n(\"boc\",mb_okcancel),\r\n(\"brc\",mb_retrycancel),\r\n(\"byn\",mb_yesno),\r\n(\"bync\",mb_yesnocancel),\r\n(\"ix\",mb_iconexclamation),\r\n(\"iw\",mb_iconwarning),\r\n(\"ii\",mb_iconinformation),\r\n(\"iq\",mb_iconquestion),\r\n(\"is\",mb_iconstop),\r\n(\"ie\",mb_iconerror),\r\n(\"ih\",mb_iconhand),\r\n(\"d1\",mb_defbutton1),\r\n(\"d2\",mb_defbutton2),\r\n(\"d3\",mb_defbutton3),\r\n(\"d4\",mb_defbutton4),\r\n(\"h\",mb_help),\r\n(\"rj\",mb_right),\r\n(\"sm\",mb_systemmodal))\r\n\r\nhwnd:=0\r\n\r\nstyle:=0\r\noptioncodes:=splitstring(options,\" \")\r\n\r\nforall opt in optioncodes do\r\n\tfor i to styletable.len do\r\n\t\tif styletable[i,1]=opt then style ior:=styletable[i,2] fi\r\n\tod\r\nod\r\n\r\nstyle ior:=0x10000\r\n\r\nx:=messageboxa(hwnd,message,caption,style)\r\n!CPL =X\r\nreturn rettable[x]\r\nEND\r\n\r\n\r\nglobal proc gxhandler(windclass,mess,fnptr)=\r\n!windclass is a window, or a window class\r\n!override the current message handler for w's window class, and fo message mess\r\n\r\nif not windclass.isint then\r\n\twindclass:=windclass.windclass\r\nfi\r\n\r\n!CPL \"SETTING GXHANDLER\",MESS,WINDCLASS,FNPTR\r\nmesshandlertable[mess,windclass]:=fnptr\r\nend\r\n\r\nglobal function gxaskfile(caption=\"File\",filespec=\"*.*\",deffile=\"\",startdir=\"\")=\r\n\r\nsave:=0\r\nif caption='*' then\r\n\tsave:=1\r\n\tcaption:=rightstr(caption,-1)\r\nfi\r\n\r\nfilters:=array(filespec+\"@@@\")\t\t!turn into a byte-array\r\n\r\nforall i,bb in filters do\t\t\t!convert all @ into embedded zeros\r\n\tif bb='@' then filters[i]:=0 fi\r\nod\r\n\r\n\r\nofn:=new((iswin32|ws_openfilename32|ws_openfilename64))\r\n\r\nofn.structsize:=ofn.bytes\r\nofn.owner:=wapplic.gdi.hwnd\r\nofn.instance:=getmodulehandle(0)\r\nofn.filter:=int(&filters)\r\nofn.flags:=ofn_explorer ior ofn_nochangedir ior ofn_hidereadonly !IOR OFN_NOVALIDATE\r\n\r\nofn.initialdir:=getcstring(startdir)\r\n\r\nofn.defext:=getcstring(\"\")\r\n\r\nresult:=new(array,byte,300)\r\n\r\nresult[1]:=0\r\nif deffile<>\"\" then\r\n\tmemcpy(&result,&deffile,deffile.len)\r\nfi\r\n\r\nofn.file:=int(&result)\r\n\r\nofn.maxfile:=256\r\nofn.title:=getcstring(caption)\r\n\r\nif not (not save | getopenfilenamea(&ofn) | getsavefilenamea(&ofn)) then\r\n\tresult[1]:=0\t\t!return \"\" on error\r\nfi\r\n\r\nreturn string(result)\r\nEND\r\n\r\nglobal function gxcurrpos(w)=\r\nreturn w.attrs.currpos\r\nend\r\n\r\nglobal function gxtabstops(?tabs,signed=0)=\r\nif tabs.isdef then\r\n\ttabstops:=tabs\r\n\tif signed then\r\n\t\tforall i,x in tabstops do\r\n\t\t\ttabstops[i]:=abs(x)\r\n\t\tod\r\n\tfi\r\nfi\r\nreturn tabstops\r\n\r\nend\r\n\r\nglobal function getlvbounds(linkvar)=\r\nif linkvar.ispointer and linkvar^.islist then\r\n\treturn linkvar^.bounds\r\nelse\r\n\treturn linkvar.getbounds()\r\nfi\r\nreturn 0\r\nend\r\n\r\nglobal function getlvitem(linkvar,n)=\r\nif linkvar.ispointer and linkvar^.islist then\r\n\treturn linkvar^[n]\r\nelse\r\n\tPCERROR(\"GETLVITEM\")\r\nfi\r\nreturn 0\r\nend\r\n\r\nglobal function getlvstritem(linkvar,n)=\r\nif linkvar.ispointer and linkvar^.islist then\r\n\treturn tostr(linkvar^[n])\r\nelse\r\n\treturn linkvar.getstritem(n)\r\nfi\r\nreturn 0\r\nend\r\n\r\nglobal proc gxtext16(w,s,n,x=0,y=0)=\t\t!GXTEXT\r\n\tgdi:=w.gdi\r\n\r\n\ttextoutw(gdi.hdc,x, y,&s,n)\r\n\tif gdi.drawmode=dm_screenmemory then\r\n\t\ttextoutw(gdi.hdc2,x,y,&s,n)\r\n\tfi\r\nend\r\n\r\nglobal function gxenable(w,flag)=\r\nif flag.isdef then\r\n\tw.enable:=flag\r\n\tgxupdate(w)\r\nfi\r\nreturn w.enable\r\nend\r\n\r\nglobal function gxclientarea(w)=\r\n!scan child windows of w, work out remaining client area after taking account of\r\n!framebars etc\r\n!return (pos, dim), each being a 2-element list\r\n\r\naposx:=aposy:=0\r\n\r\nadimx:=w.dimx\r\nadimy:=w.dimy\r\n\r\ncentx:=(aposx+adimx)%2\r\ncenty:=(aposy+adimy)%2\r\n\r\n!forall cw in w.childlist when cw.windclass in [statusbar_class,framebar_class] do\r\nforall cw in w.childlist do\r\n\r\n\t(posx,posy):=(cw.frameposx,cw.frameposy)\r\n\t(dimx,dimy):=(cw.framedimx,cw.framedimy)\r\n\r\n!need to find out which of the four sides the bar is against, and set up side= L R T B\r\n\tcase cw.style.dir\r\n\twhen 'B' then\t\t\t\t!bottom\r\n\t\tif posy<(aposy+adimy) then\r\n\t\t\tadimy-:=dimy\r\n\t\tfi\r\n\r\n\twhen 'T' then\t\t\t\t!top\r\n\t\tif (posy+dimy)>aposy then\t\t!\r\n\t\t\taposy+:=(posy+dimy)\r\n\t\t\tadimy-:=(posy+dimy)\r\n\t\tfi\r\n\r\n\twhen 'R' then\t\t\t\t!right\r\n\t\tif posx<(aposx+adimx) then\r\n\t\t\tadimx-:=dimx\r\n\t\tfi\r\n\r\n\twhen 'L' then\t\t\t\t!LEFT\r\n\t\tif (posx+dimx)>aposx then\t\t!\r\n\t\t\taposx+:=(posx+dimx)\r\n\t\t\tadimx-:=(posx+dimx)\r\n\t\tfi\r\n\telse\r\n\r\n\t\tif dimx>dimy then\t\t\t!assume hoz\r\n\t\t\tif posy>centy then\t\t\t!assume bottom\r\n\t\t\t\tif posy<(aposy+adimy) then\r\n\t\t\t\t\tadimy-:=dimy\r\n\t\t\t\tfi\r\n\r\n\t\t\telse\t\t\t\t\t!top\r\n\t\t\t\tif (posy+dimy)>aposy then\t\t!\r\n\t\t\t\t\taposy+:=(posy+dimy)\r\n\t\t\t\t\tadimy-:=(posy+dimy)\r\n\t\t\t\tfi\r\n\t\t\tfi\r\n\t\telse\t\t\t\t\t!assume vert\r\n\t\t\tif posx>centx then\t\t\t!assume right\r\n\r\n\t\t\t\tif posx<(aposx+adimx) then\r\n\t\t\t\t\tadimx-:=dimx\r\n\t\t\t\tfi\r\n\r\n\t\t\telse\t\t\t\t\t!left\r\n\r\n\t\t\t\tif (posx+dimx)>aposx then\t\t!\r\n\t\t\t\t\taposx+:=(posx+dimx)\r\n\t\t\t\t\tadimx-:=(posx+dimx)\r\n\t\t\t\tfi\r\n\r\n\t\t\tfi\r\n\t\tfi\r\n\tesac\r\nod\r\n\r\nreturn ((aposx,aposy), (adimx,adimy))\r\nEND\r\n\r\nglobal function addwindow(w)=\r\n!w is a newly created window\r\n!add it to all windows\r\nn:=nil in allwindows\r\nif not n then\r\n\tn:=allwindows.len+1\r\nfi\r\n\r\nallwindows[n]:=w\r\nw.gindex:=n\r\nreturn n\r\nend\r\n\r\nglobal proc removewindow(w)=\r\n!remove w from all windows\r\nn:=w in allwindows\r\nif n then\r\n\tallwindows[n]:=nil\r\nfi\r\nend\r\n\r\nfunction get_function_name(fnptr)=\r\nn:=$pcldata('PROC',0)\r\nfor i:=1 to n do\r\n\tdata:=$pcldata('PROC',i)\r\n\tif fnptr=data[4] then\r\n\t\treturn data[1]\r\n\tfi\r\nod\r\nreturn \"NOT FOUND \"+tostr(fnptr)\r\nend\r\n\r\n!===================================\r\n!MESSLIB\r\nfunction process_wmmessage(msg)=\r\n!msg is a windows rmsg record\r\n!Called from MainWndProc callback function (via mechanisms for B code to call into MPL code)\r\n!this function processes some wm_ Windows messages and converts them\r\n!into mm_ messages as necessary\r\n!It returns:\r\n!\t0 The wm_ message has been processed\r\n!\t1 The wm_ message has not been processed, and the caller should call DefWindowProc.\r\n!\t  Or, the DefWindowProc should also be called anyway.\r\n\r\n!CPL \"PROC WMMMESS\",WINMESSAGENAMES[MSG.MESSAGE]\r\n!CPL \"PROC WMMMESS\",MSG.MESSAGE,WM_TIMER\r\n\r\nhwnd:=msg.hwnd\r\nw:=getwindow(hwnd)\r\n\r\nmessage:=msg.message\r\nwparam:=msg.wparam\r\nlparam:=msg.lparam\r\n\r\n!CPL \"PROC WMMMESS2\",WINMESSAGENAMES[MESSAGE]\r\ncase msg.message\r\n!switch msg.message\r\nwhen wm_command then\r\n\tw:=getwindow(lparam)\t\t\t!w was owner, use control window\r\n\ti:=wparam iand 0xffff\t\t\t!id\r\n\tj:=wparam>>16\t\t\t\t!notify code\r\n\tm:=mm_command\r\n\r\n\tif not w then\r\n\t\tw:=wapplic\r\n\tfi\r\n\r\n\tpostmess(w,m,i,j,0)\r\n\r\n\treturn 0\r\n\r\nwhen wm_activate then\r\n\tif wparam then\t\t\t\t!being activated\r\n\tfi\r\n\r\nwhen wm_syskeydown,wm_syskeyup,wm_keydown,wm_keyup then\r\n\tif dokeymessage(hwnd,message,wparam,lparam) then\r\n\t\treturn 0\r\n\tfi\r\n\r\nwhen wm_char then\r\n\tpostmess((wfocus|wfocus|w),mm_char,wparam,lparam,0)\r\n\r\nwhen wm_close then\r\n\tif w==wapplic then\r\n\t\tpostmess(w,mm_close,0,0,0)\r\n\t\treturn 0\r\n\telse\r\n\t\tpostmess(w,mm_cancel,0,0,0)\r\n\t\treturn 0\r\n\tfi\r\n\r\nwhen wm_timer then\r\n!\tif not background and not stationary then\t\t!test for pausing of mouse\r\n!\t\tif gettickcount()-lastxytime>pausetime then\r\n!\t\t\tstationary:=1\r\n!\t\tfi\r\n!\tfi\r\n!CPL \"TIMER\"\r\n\tw:=getwindow(lparam)\t\t\t!w was owner, use control window\r\n\tif not w then\r\n\t\tw:=wapplic\r\n\tfi\r\n\r\n!CPL \"TIMER POSTING MESSAGE\"\r\n\tpostmess(w,mm_timer,0,0,0)\r\n\treturn 0\r\n\r\nwhen wm_destroy then\r\n\tif w and wapplic and w==wapplic then\r\n\t\tkilltimer(hwnd,1)\r\n!*\t\tif tick then killtimer(hwnd,1) fi\r\n\t\tpostquitmessage(0)\t\t\t!mm_quit message\r\n\t\treturn 0\r\n\telse\r\n\t\treturn 1\r\n\tfi\r\n\r\n!when wm_setcursor then\r\n!\tpostmess(w,mm_setcursor,wparam,lparam,0)\r\n\r\nwhen wm_mousemove then\r\n\r\n\tbuttonstate:=wparam iand (kb_lbutton ior kb_rbutton ior kb_mbutton)\r\n\tmousepos.x:=lparam iand 65535\r\n\tmousepos.y:=lparam>>16\r\n\r\ndomousemove:\r\n\txyvalid:=1\t\t\t\t!known again\r\n\tsetnewmousewindow(w)\r\n\r\n\twmouse:=w\r\n\tpostmess(wmouse,mm_move)\r\n\r\n\tlastxy::=getscreencoords(wmouse,mousepos)\r\n\tlastxytime:=gettickcount\r\n\tstationary:=0\r\n\r\n!do drag processing; states are:\r\n!pen up/recent pen down/first drag/subsequent drag\r\n!any drag messages are sent as well as mm_move messages\r\n!dragmode=1/2/3 indicates drag has started (reset by buttonswitching)\r\n\r\n\tif buttonstate<>0 and lastmousewindow<>nil then\t\t!switch pressed\r\n\t\tpt:=getscreencoords(lastmousewindow,lastmousepos)\r\n\t\tdx:=lastxy.x-pt.x\r\n\t\tdy:=lastxy.y-pt.y\r\n\r\n!CPL =DRAGMODE\r\n\t\tif dragmode then\t\t!1st drag message already generated\r\n\t\t\tpostmess(lastmousewindow,mm_drag,dx,dy,-1)\t\t\t!send latest drag coords\r\n\r\n\t\telse\t\t\t\t!test for drag enabling\r\n!CPL \"TESTDRAG\",=MOUSESW\r\n\t\t\tif ((mousesw=1 and lastmousewindow.flags.[wa_leftdrag]<>0) or \\\r\n\t\t\t\t\t\t\t(mousesw=2 and lastmousewindow.flags.[wa_rightdrag]<>0) or \\\r\n\t\t\t\t\t\t\t(mousesw=3 and lastmousewindow.flags.[wa_middledrag]<>0)) and \\\r\n\t\t\t\t\t\t(abs(dx)>dragtol or abs(dy)>dragtol) then\r\n\t\t\t\tdragmode:=mousesw\r\n\t\t\t\tpostmess(lastmousewindow,mm_startdrag,dx,dy,-1)\t\t!send latest drag coords\r\n\t\t\tfi\r\n\r\n\t\tfi\r\n\telse\r\n\t\tif dragmode then\r\n\t\t\tpostmess(lastmousewindow,mm_enddrag,dx,dy,-1)\t!send latest drag coords\r\n\t\t\tdragmode:=0\r\n\t\tfi\r\n\tfi\r\n\r\n\treturn 0\r\n\r\nwhen wm_enteridle then\t\t!enter idle\r\n\tidlemode:=1\r\n\treturn 0\r\n\r\nwhen wm_paint then\r\n\r\n\tif w<>nil then\r\n\t\tps:=new(ws_paintstruct)\r\n\t\trect:=new(ws_rect)\r\n\t\tbeginpaint(hwnd,&ps)\r\n!\t\tframe2rect(^ps.paintrect,^rect)\r\n!\t\tRECT.DIMX-:=1\r\n!\t\tRECT.DIMY-:=1\r\n!*!\t\tgxmplpaint(w,^rect,0)\r\n!gxclear(wapplic,red)\r\n\t\tpostmess(w,mm_restore,0,0,0)\r\n\t\tendpaint(hwnd,^ps)\r\n\t\treturn 0\r\n\tfi\r\n\r\nwhen wm_erasebkgnd then\r\n\r\nwhen wm_move then\r\n\tif w<>nil then\r\n!*!\t\tgxmovewindow(w,lparam iand 65535,lparam>>16)\r\n\tfi\r\n!RETURN 0\r\n\r\nwhen wm_size then\r\n\tx:=lparam iand 0xffff\r\n\ty:=lparam>>16\r\n\tif w<>nil  and (w.dimx<>x or w.dimy<>y) then\r\n!*!\t\tgxmplresize(w,x,y,wparam)\r\n\t\treturn 0\r\n\tfi\r\n\r\n!when wm_killfocus,wm_setfocus then\r\n\r\nwhen wm_contextmenu then\r\n\tsendmess(w,mm_rclick,wparam>>16,wparam iand 0xffff,0)\r\n\treturn 0\r\n\r\nwhen wm_mousewheel then\r\n\tif not wmouse then wmouse:=w fi\r\n!CPL \"WM/WHEEL\",WPARAM:\"H\",WPARAM>>16\r\n\tpostmess(wmouse,mm_wheel,int(wparam>>16),wparam iand 0xffff,0)\r\n\treturn 0\r\n\r\nwhen wm_nclbuttondown,wm_nclbuttondblclick then\r\n\r\nwhen wm_activateapp then\r\n\tif wparam then\r\n\t\tpostmess(w,mm_activate,1,0,0)\r\n\tfi\r\n\r\nelse\r\nbtnmessages:\r\n!check for sequential messages\r\n\tif message>=wm_lbuttondown and message<=wm_mbuttondblclk then\r\n\t\tbuttonmessages(hwnd,message,wparam,lparam)\r\n\t\treturn 0\r\n\tfi\r\nesac\r\n!end\r\n!fall-through here to do default message processing instead of/in addition to local processing\r\nreturn 1\t!defwindowproc(hwnd,imsg,wparam,lparam)\r\nend\r\n\r\nglobal proc mxinit=\r\n!CPL \"MXINIT\"\r\nwmessagetable := [\\\r\n\twm_lbuttondown:\t\tmm_click,\r\n\twm_lbuttonup:\t\tmm_clickup,\r\n\twm_lbuttondblclk:\tmm_dblclick,\r\n\r\n\twm_rbuttondown:\t\tmm_rclick,\r\n\twm_rbuttonup:\t\tmm_rclickup,\r\n\twm_rbuttondblclk:\tmm_rdblclick,\r\n\r\n\twm_mbuttondown:\t\tmm_mclick,\r\n\twm_mbuttonup:\t\tmm_mclickup,\r\n\twm_mbuttondblclk:\tmm_mdblclick]\r\n\r\n!table gives button number 1,2,3 for Windows button message (always 0 for button up)\r\nbuttontable\t:= [\\\r\n\twm_lbuttondown:\t\t1,\r\n\twm_lbuttonup:\t\t0,\r\n\twm_lbuttondblclk:\t1,\r\n\r\n\twm_rbuttondown:\t\t2,\r\n\twm_rbuttonup:\t\t0,\r\n\twm_rbuttondblclk:\t2,\r\n\r\n\twm_mbuttondown:\t\t3,\r\n\twm_mbuttonup:\t\t0,\r\n\twm_mbuttondblclk:\t3]\r\n\r\nmousepos:=new(ws_point)\r\n\r\nsetmesshandler(^process_wmmessage)\r\n\r\nvktomesstable:=[\\\r\n\tvkleft:\t\tmm_leftkey,\r\n\tvkright:\tmm_rightkey,\r\n\tvkup:\t\tmm_upkey,\r\n\tvkdown:\t\tmm_downkey,\r\n\tvkpageup:\tmm_pageupkey,\r\n\tvkpagedown:\tmm_pagedownkey,\r\n\tvkhome:\t\tmm_homekey,\r\n\tvkend:\t\tmm_endkey,\r\n\tvktab:\t\tmm_tabkey,\r\n\tvkbackspace:\tmm_bskey,\r\n\tvkdelete:\tmm_deletekey,\r\n\tvkenter:\tmm_enterkey,\r\n\tvkinsert:\tmm_insertkey,\r\n\tvkescape:\tmm_cancel\r\n]\r\n!CPL \"************************\"\r\n!$TEST(VKTOMESSTABLE)\r\n\r\nend\r\n\r\nglobal function postmess(w,mess,a=0,b=0,c=0)=\r\n!add message m to end of message queue\r\n!use mess+1000 to add message to start of queue rather than the end\r\n\r\nif w=nil then w:=wapplic fi\r\nif w=nil then\r\n return 0 fi\r\n\r\nif w.flags.[wa_closed] then\r\n\r\n return 0 fi\r\n\r\nif mess>=1000 then\r\n\theadx:=1; mess-:=1000\r\nelse\r\n\theadx:=0\r\nfi\r\n\r\n!check if new message can be combined with an old message\r\ncase mess\r\nwhen mm_sethozpos,mm_setvertpos,mm_draw,mm_restore,mm_update then\r\n\tfor i:=1 to nmessages do\r\n\t\tm:=messagequeue[i].message\r\n!\t\tif m=mess then\t\t\t\t!use the old message but update any params\r\n\t\tif m=mess and w==messagequeue[i].wind then\t\t\t\t!use the old message but update any params\r\n\t\t\tmessagequeue[i].a:=a\r\n\t\t\tmessagequeue[i].b:=b\r\n\t\t\treturn 0\r\n\t\telsif mess=mm_draw and m=mm_update then\t\t!convert update to draw\r\n\t\t\tmessagequeue[i].message:=mm_draw\r\n\t\t\treturn 0\r\n\t\tfi\r\n\tod\r\nesac\r\n\r\nif quitmess or nmessages>=maxqueuesize then\r\n\treturn 0\r\nfi\r\n\r\npostmsg(makemess(w,mess,a,b,c))\r\n\r\nreturn 0\t\t\t\t\t!return zero for use in mainwndproc\r\nend\r\n\r\nglobal function postmsg(msg,headx=0)=\r\n!add complete message msg to end of message queue\r\n!use head=1 to add to start of queue rather than the end\r\n\r\nif quitmess or nmessages>=maxqueuesize then\r\n\treturn 0\r\nfi\r\n\r\nif msg.wind.flags.[wa_closed] then return 0 fi\r\n\r\nif headx then\r\n\r\n!avoid dupl paint messages\r\n!\tif nmessages>1 and msg.message=mm_paint and messagequeue[1].message=mm_paint then\r\n!\t\treturn 0\r\n!\tfi\r\n\r\n\t++nmessages\r\n\tfor i:=nmessages downto 2 do\r\n\t\tmessagequeue[i]:=messagequeue[i-1]\r\n\tod\r\n\tmessagequeue[1]:=msg\r\n\r\nelse\r\n\t++nmessages\r\n\tmessagequeue[nmessages]:=msg\r\nfi\r\n\r\nreturn 0\t\t\t\t\t!return zero for use in mainwndproc\r\nend\r\n\r\nglobal proc sendmess(w,mess,a=0,b=0,c=0)=\r\n!add message m to head of message queue\r\n!(may be 100% handled in q smlib)\r\n\r\nif w=nil then return fi\r\nif w.flags.[wa_closed] then return fi\r\n\r\nsendmsg(makemess(w,mess,a,b,c))\r\nend\r\n\r\nproc sendmsg(msg)=\r\n!call event handler for msg or add to head of queue\r\nif msg.wind.flags.[wa_closed] then return fi\r\npostmsg(msg,1)\r\nend\r\n\r\nglobal function makemess(w,mess,a=0,b=0,state=-1)=\r\n!turn params into a new messrec @nemm_ess\r\n!the q version makemess also accepts makemess(w,msg)\r\n\r\nif w=nil then w:=wapplic fi\r\n\r\nm:=new(rmessage,0)\r\n\r\nm.wind:=w\r\n\r\nm.message:=mess\r\nm.a:=a\r\nm.b:=b\r\nm.state:=state\r\n\r\nm.x:=mousepos.x\r\nm.y:=mousepos.y\r\n\r\nif m.state=-1 then m.state:=getshiftstate() fi\r\n\r\nreturn m\r\nend\r\n\r\nfunction dokeymessage(hwnd,msg,wparam,lparam)=\r\n!return 1 if message has been dealt with\r\ncase msg\r\nwhen wm_syskeydown then\r\n!CPL \"SYSKEYDOWN\"\r\n\r\n\tif wparam=vkf10 then msg:=wm_keydown; goto dokey fi\r\n\r\nwhen wm_syskeyup then\r\n\tif wparam=vkf10 then msg:=wm_keyup; goto dokey fi\r\n\r\nwhen wm_keydown,wm_keyup then\r\ndokey:\r\n\tcase wparam\r\n\twhen vkshift,vkctrl,vkalt,vkcapslock then\r\n\telse\r\n\t\tw:=wfocus\r\n!\t\tif not w then w:=wx_getw(hwnd) fi\r\n\t\tif not w then w:=getwindow(hwnd) fi\r\n!CPL =GETSHIFTSTATE()\r\n!\t\tpostmess(w,(msg=wm_keydown|mm_key|mm_keyup),wparam,getshiftstate(),lparam)\r\n\t\tpostmess(w,(msg=wm_keydown|mm_key|mm_keyup),wparam,lparam,-1)\r\n\t\treturn 1\r\n\tesac\r\nesac\r\nreturn 0\r\nend\r\n\r\nfunction getshiftstate=\r\nstate:=0\r\n\r\nif getkeystate(vklshift) iand 0x8000 then state ior:=kb_shift fi\r\nif getkeystate(vklcontrol) iand 0x8000 then state ior:=kb_ctrl fi\r\nif getkeystate(vklalt) iand 0x8000 then state ior:=kb_alt fi\r\n\r\nif getkeystate(vkrshift) iand 0x8000 then state ior:=kb_rshift fi\r\nif getkeystate(vkrcontrol) iand 0x8000 then state ior:=kb_rctrl fi\r\nif getkeystate(vkralt) iand 0x8000 then\r\n\tstate ior:=kb_ralt\r\n\tstate iand:=(inot kb_ctrl)\t\t\t!AltGr gives Lctrl+Ralt; return Ralt only\r\nfi\r\nif getkeystate(vkcapslock) iand 1 then state ior:=kb_capslock fi\r\n\r\nreturn state ior buttonstate\r\nEND\r\n\r\nproc buttonmessages(hwnd,msg,wp,lp)=\r\n!process Windows mouse message <msg>\r\n\r\n!update button from wparam, excluding ctrl/shift (which are updated from key msgs)\r\nbuttonstate:=wp iand (kb_lbutton ior kb_rbutton ior kb_mbutton)\r\n\r\n!update mouse position\r\nmousepos.x:=lp iand 0xffff\r\nmousepos.y:=int(lp)>>16\r\nwmouse:=getwindow(hwnd)\r\n\r\n!set mousesw to last pressed button (1,2,3) or 0 if one just released\r\n!(note other buttons may still be down, used for drag processing)\r\nmousesw:=buttontable{msg}\r\n\r\nif mousesw then\t\t\t!down up on click or dblclick\r\n\tlastbuttontime:=gettickcount\r\n\tlastmousepos::=mousepos\r\n\tlastmousewindow:=wmouse\r\nelse\r\n\tmousesw:=0\r\n\r\n\tif dragmode then\r\n\t\tpostmess(lastmousewindow,mm_enddrag,0,0,-1)\r\n\t\tdragmode:=0\r\n\tfi\r\n\r\n\tlastbuttontime:=0\r\n\tlastmousewindow:=nil\r\nfi\r\n\r\nnewmess:=wmessagetable{msg}\r\n\r\n!filter double-click messages and convert to repeated click if not enabled\r\ncase newmess\r\nwhen mm_dblclick then unless wmouse.flags.[wa_leftdbl] then newmess:=mm_click end\r\nwhen mm_rdblclick then unless wmouse.flags.[wa_rightdbl] then newmess:=mm_click end\r\nesac\r\n\r\n!postmess(wmouse,newmess,wmouse.id,0,getshiftstate())\r\npostmess(wmouse,newmess,wmouse.id,0,-1)\r\nEND\r\n\r\nproc setnewmousewindow(w)=\r\nreturn when not currmousewindow\r\nunless w==currmousewindow then\t\t!changed\r\n\tif currmousewindow<>nil then\r\n\t\tpostmess(currmousewindow,mm_offwindow,0,0,0)\r\n\tfi\r\n\r\n\tcurrmousewindow:=w\r\n\tpostmess(w,mm_onwindow,0,0,0)\r\nend unless\r\nend\r\n\r\nproc frame2rect(f,r)=\r\nr^.x:=f^.x\r\nr^.y:=f^.y\r\n\r\nr^.dimx:=f^.x2-f^.x1+1\r\nr^.dimy:=f^.y2-f^.y1+1\r\nend\r\n\r\nglobal function mxwait_mm_message=\r\n#do windows dispatch loop\r\n#calling dispatchmessage() results in mainwndproc being called in interpreter,\r\n#which passes the Windows message params on to process_wmmessage() in this module\r\n#process_wmmessage() converts wm-messages to mpl mm-messages\r\n#return when at least one mm message is ready; (will return immediately if there\r\n#is already one in the queue)\r\n#return value is normall 1, or 0 when quitmess has been encountered\r\n\r\nif quitmess then\t\t\t\t!quit message already seen\r\n!CPL \"MXWAIT/QUITMESS\"\r\n\treturn 0\r\nfi\r\n\r\nwindmsg:=new((iswin32|ws_msg32|ws_msg64))\r\n\r\nwhile nmessages<=0 do\r\n\tif x:=getmessage(&windmsg,0,0,0)<>0 then\r\n!\tif x:=getmessage(0,0,0,0)<>0 then\r\n\t\tw:=windmsg.hwnd\r\n!\t\tif windmsg.message=wm_keydown and windmsg.wparam=27 then exit fi\r\n!\t\tif windmsg.message=wm_timer then CPL \"TIMER!!\" fi\r\n\r\n\t\ttranslatemessage(&windmsg)\r\n\t\tdispatchmessage(&windmsg)\r\n\telse\r\n\t\tquitmess:=1\r\n!\t\tCPL \"EXITING WAITMESS\",x\r\n!WAITKEY()\r\n\t\texit\r\n\tfi\r\nod\r\n\r\nif not nmessages then\t\t\t!assume quit message seen\r\n\treturn 0\r\nfi\t\r\n\r\ncurrmess:=messagequeue[1]\r\n--nmessages\r\n\r\nxlatkeyboard()\r\n\r\nfor i:=1 to nmessages do\r\n\tmessagequeue[i]:=messagequeue[i+1]\r\nod\r\nreturn 1\r\nend\r\n\r\nproc xlatkeyboard=\r\n!expand any mm_key messages to special key messages\r\n!uses and modified currmess\r\nm:=currmess.message\r\n\r\nif m=mm_key then\r\n\r\n\tk:=currmess.a\r\n\tif k>=vkf1 and k<=vkf12 then\r\n\t\tnewmsg:=currmess\r\n\t\tcurrmess.message:=mm_functionkey\r\n\t\tcurrmess.a:=k-vkf1+1\r\n\telse\r\n\t\tkeymess:=vktomesstable{k,0}\r\n\t\tif keymess then\r\n\t\t\tcurrmess.message:=keymess\r\n\t\tfi\r\n\tfi\r\nfi\r\nend\r\n\r\nfunction getscreencoords(w,pos)=\r\npt::=pos\r\nif not w then\r\n\tPCERROR(\"GSC/W=0\")\r\nfi\r\n\r\nclienttoscreen(w.gdi.hwnd,&pt)\t\t!pos starts at 0,0\r\nreturn pt\r\nend\r\n\r\nglobal function getwindow(hwnd)=\r\n!convert hwnd to window\r\n!return nil if any problem\r\nif hwnd=0 then\r\n\treturn nil\r\nfi\r\n\r\nindex:=wx_getw(hwnd)\r\nif index then\r\n\treturn allwindows[index]\r\nfi\r\nreturn nil\r\nend\r\n\r\nproc initmenuhandlers=\r\nltcolour:=getrgb(ltgrey)\r\ndkcolour:=getrgb(dkgrey)\r\nend\r\n\r\nproc gxhandler_fixups <\"fx\">=\r\n!do some manual fixups for various shared handlers\r\n!(the automatic fixup routine allows multiple window classes per message, but not\r\n! multiple message per window class)\r\nmesshandlertable[mm_startdrag,scrollbar_class]:=^mess_drag_scrollbar()\r\nmesshandlertable[mm_enddrag,scrollbar_class]:=^mess_drag_scrollbar()\r\nmesshandlertable[mm_leftkey,scrollbar_class]:=^mess_upkey_scrollbar()\r\nend\r\n\r\nfunction mess_all_all\t\t\t<\"mx\">\t\t\t(mess,w)=\r\n!CPL \"ALLALL\",MESSAGENAMES[MESS.MESSAGE]\r\ncase mess.message\r\nwhen mm_startdrag,mm_drag,mm_enddrag then\r\nwhen mm_command then\r\nwhen mm_ok,mm_cancel then\r\nwhen mm_click then\r\n\tcase w.windclass\r\n\twhen label_class, group_class then\r\n\t\treturn skipmess\r\n\tesac\r\nwhen mm_key then\r\n!CPL \"ALL/ALL/KEY\"\r\nwhen mm_sethozpos,mm_setvertpos then\r\nwhen mm_pick,mm_lbchange then\r\nwhen mm_leftkey,mm_rightkey,mm_upkey,mm_downkey,mm_enterkey,mm_tabkey then\r\nwhen mm_pageupkey,mm_pagedownkey then\r\nwhen mm_homekey, mm_endkey then\r\nwhen mm_functionkey then\r\nwhen mm_wheel then\r\nelse\r\n\treturn skipmess\r\nesac\r\n\r\nreturn thismess\r\nend\r\n\r\nfunction mess_restore_all\t\t\t<\"mx\">\t\t(mess,w)=\r\ngxrestore(W)\r\n\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_killfocus_all\t\t\t\t<\"mx\">\t\t(mess,w)=\r\n!note: can be called from mess_setfocus_all, with a different mess, but correct w\r\n!assume w is same as wfocus\r\n\r\ndrawcaret(0)\r\nwfocus:=nil\r\n\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_setfocus_all\t\t\t\t<\"mx\">\t\t(mess,w)=\r\nif wfocus then\r\n\tmess_killfocus_all(mess,wfocus)\r\nfi\r\n\r\nwfocus:=w\r\ndrawcaret(1)\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_update_all\t<\"mx\">\t\t\t(mess,w)=\r\ngxupdate(w)\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_draw_all\t\t<\"mx\">\t\t\t(mess,w)=\r\ngxdraw(w)\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_click_select\t\t<\"mx\">\t(mess,w)=\r\nif w.enable then\r\n\tif not w.style.noupdate then\r\n\t\tp:=w.linkvar\r\n\t\tp^:=w.attrs.onvalue\r\n\t\tforall wc in w.owner.childlist do\r\n\t\t\tif wc.windclass=select_class and wc.linkvar=p then\r\n\t\t\t\tgxdraw(wc)\r\n\t\t\tfi\r\n\t\tod\r\n\tfi\r\n\tif w.style.returnmess then\r\n\t\tpostmess(w,mm_command,w.id)\r\n\tfi\r\nfi\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_click_toggle\t\t<\"mx\">\t(mess,w)=\r\nif w.enable then\r\n\tif not w.style.noupdate then\r\n\t\tw.linkvar^:=not w.linkvar^\r\n\t\tgxdraw(w)\r\n\tfi\r\n\tif w.style.returnmess then\r\n\t\tpostmess(w,mm_command,w.id)\r\n\tfi\r\nfi\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_click_button\t\t<\"mx\">\t(mess,w)=\r\n\r\nif w.enable=0 then\r\n\tbeep1()\r\n\treturn skipmess\r\nfi\r\n\r\nif w.id in 0..199 then\t\t\t\t!speficies an actual message number (but no params)\r\n\tpostmess(w,w.id)\r\nelse\r\n\tpostmess(w,mm_command,w.id)\r\nfi\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_click_editbox\t\t<\"mx\">\t(mess,w)=\r\n!CPL \"CLICK EDITBOX\"\r\nif w.enable then\r\n\tif not w.style.noupdate then\r\n\t\tunless w==wfocus then\r\n\t\t\tgxfocus(w)\r\n\t\tend\r\n\tfi\r\n\tif w.style.returnmess then\r\n\t\tpostmess(w,mm_command,w.id)\r\n\tfi\r\nfi\r\n\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_click_arrow\t\t<\"mx\">\t(mess,w)=\r\n\r\ncase w.owner.windclass\r\nwhen scrollbar_class then\r\n\tpostmess(w.owner,dirtomess{w.style.dir},w.id,0,-1)\r\nelse\r\n\tmess.message:=dirtomess{w.style.dir}\r\n\tmess.a:=w.id\r\n\treturn thismess\r\nesac\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_click_mark\t\t<\"mx\">\t(mess,w)=\r\n\r\ncase w.owner.windclass\r\nwhen toggle_class,select_class then\r\n\tpostmess(w.owner,mess.message,w.id,0,-1)\r\nesac\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_click_listbox\t\t<\"mx\">\t(mess,w)=\r\ngxfocus(w)\r\n\r\ny:=max(w.attrs.offset,mess.y)\r\n\r\npos:=(y-w.attrs.offset)%w.attrs.pitch+w.attrs.pagepos\r\n!if pos<=w.linkvar^.len then\r\nif pos<=getlvbounds(w.linkvar).len then\r\n\tgxsetlbpos(w,pos)\r\n\tpostmess(w,mm_pick,pos)\r\nfi\r\n\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_click_scrollbar\t\t<\"mx\">\t(mess,w)=\r\nonthumb:=isonthumb(w,(w.style.dir='H'|mess.x|mess.y))\r\nstep:=w.attrs.span\r\na:=w.attrs.currpos\r\n\r\ncase w.owner.windclass\r\nwhen listbox_class then\r\n\tcase onthumb\r\n\twhen -1 then\r\n\t\tif a>w.attrs.limits.lwb then\r\n\t\t\ta:=max(a-step,w.attrs.limits.lwb)\r\n\t\t\tgxsetlbpage(w.owner,a)\r\n\t\tfi\r\n\twhen 1 then\r\n\t\tif a<w.attrs.limits.upb then\r\n\t\t\ta:=min(a+step,w.attrs.limits.upb)\r\n\t\t\tgxsetlbpage(w.owner,a)\r\n\t\tfi\r\n\tesac\r\nelse\r\n\tif not step then step:=10 fi\r\n\r\n\tcase onthumb\r\n\twhen -1 then\r\n\t\tif a>w.attrs.limits.lwb then\r\n\t\t\ta:=max(a-step,w.attrs.limits.lwb)\r\n\t\t\tgxscrollpos(w,a,1)\r\n\t\t\tpostmess(w,mm_sethozpos,a)\r\n\t\tfi\r\n\twhen 1 then\r\n\t\tif a<w.attrs.limits.upb then\r\n\t\t\ta:=min(a+step,w.attrs.limits.upb)\r\n\t\t\tgxscrollpos(w,a,1)\r\n\t\t\tpostmess(w,mm_sethozpos,a)\r\n\t\tfi\r\n\tesac\r\nesac\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_wheel_scrollbar\t\t<\"mx listbox\">\t(mess,w)=\r\ndelta:=currmess.a\r\nn:=abs(currmess.a%120)\r\nto n do\r\n\tcase w.windclass\r\n\twhen scrollbar_class then\r\ndoscroll:\r\n\t\tpostmess(w,(delta>0|mm_up|mm_down))\r\n\twhen listbox_class then\r\n\t\tif w.childlist then\r\n\t\t\tw:=w.childlist[1]\r\n\t\t\tgoto doscroll\r\n\t\tfi\r\n\t\tpostmess(w,(delta>0|mm_upkey|mm_downkey))\r\n\tesac\r\nod\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_up_scrollbar\t\t<\"mx\">\t(mess,w)=\r\na:=w.attrs.currpos\r\nif a<=w.attrs.limits.lwb then\r\n\treturn skipmess\r\nfi\r\ncase w.owner.windclass\r\nwhen listbox_class then\r\n\tgxsetlbpage(w.owner,a-1)\r\n\treturn skipmess\r\nelse\r\n\t--a\r\n\tgxscrollpos(w,a,1)\r\n\tpostmess(w,mm_setvertpos,a)\r\nesac\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_left_scrollbar\t\t<\"mx\">\t(mess,w)=\r\n\r\ncase w.owner.windclass\r\nwhen listbox_class then\r\n\treturn skipmess\r\nelse\r\n\ta:=w.attrs.currpos\r\n\tif a>w.attrs.limits.lwb then\r\n\t\t--a\r\n\t\tgxscrollpos(w,a,1)\r\n\t\tpostmess(w,mm_sethozpos,a)\r\n\tfi\r\nesac\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_right_scrollbar\t\t<\"mx\">\t(mess,w)=\r\n\r\ncase w.owner.windclass\r\nwhen listbox_class then\r\n\treturn skipmess\r\nelse\r\n\ta:=w.attrs.currpos\r\n\tif a<w.attrs.limits.upb then\r\n\t\t++a\r\n\t\tgxscrollpos(w,a,1)\r\n\t\tpostmess(w,mm_sethozpos,a)\r\n\tfi\r\n\r\nesac\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_down_scrollbar\t\t<\"mx\">\t(mess,w)=\r\n\r\na:=w.attrs.currpos\r\nif a>=w.attrs.limits.upb then\r\n\treturn thismess\r\nfi\r\ncase w.owner.windclass\r\nwhen listbox_class then\r\n\tgxsetlbpage(w.owner,a+1)\r\n\treturn skipmess\r\nelse\r\n\t++a\r\n\tgxscrollpos(w,a,1)\r\n\tpostmess(w,mm_setvertpos,a)\r\n\r\nesac\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_drag_scrollbar\t\t<\"mx\">\t(mess,w)=\r\ncase mess.message\r\nwhen mm_startdrag then\r\n\tif isonthumb(w,(w.style.dir='H'|mess.x|mess.y))=0 then\r\n\t\tthumbdragmode:=1\t\t\t!then treat as mm_drag\r\n\t\tthumbstartpos:=w.attrs.thumbpos-arrowdim\t\t!use thumb pos at start of drag\r\n\telse\t\t\t\t\t\t\t!dragging other part of scrollbar\r\n\t\treturn skipmess\r\n\tfi\r\nwhen mm_enddrag then\r\n\tthumbdragmode:=0\r\n\treturn skipmess\r\nelsif not thumbdragmode then\r\n\treturn skipmess\r\nesac\r\n\r\noffset:=(w.style.dir='H'|mess.a|mess.b)\t\t!pixel offset from initial drag start pos\r\nnewpos:=thumbstartpos+offset\t\t\t\t\t\t!could outside thumb span range\r\n\r\npos:=int(round((newpos/w.attrs.thumbspan)*(w.attrs.limits.len-1)+w.attrs.limits.lwb))\r\npos:=clamp(pos,w.attrs.limits.lwb,w.attrs.limits.upb)\r\n\r\ncase w.owner.windclass\r\nwhen listbox_class then\r\n\tgxsetlbpage(w.owner,pos)\r\nelse\r\n\tgxscrollpos(w,pos,1)\r\n\tpostmess(w,(w.style.dir='H'|mm_sethozpos|mm_setvertpos),pos)\r\nesac\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_move_button\t\t<\"mx\">\t\t\t(mess,w)=\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_move_all\t\t\t<\"mx\">\t\t\t(mess,w)=\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_char_editbox\t\t<\"mx\">\t\t\t(mess,w)=\r\n!CPL \"CHAR/EDITBOX\"\r\nif mess.a not in 32..255 then\r\n!CPL \"NOT CHAR KEY\"\r\n\tif wapplic then\r\n! postmess(wapplic,mess.message,mess.a,mess.b,mess.state) fi\r\n postmess(wapplic,mm_key,mess.a,mess.b,mess.state) fi\r\n!CPL \"SKIPPING CHAR\",MESS.A,MESSAGENAMES[MESS.MESSAGE]\r\n return skipmess fi\r\nif not w.enable or w.style.noupdate then return skipmess fi\r\ns:=w.linkvar^\r\nn:=w.attrs.currpos\r\nc:=chr(mess.a)\r\n\r\nif n>s.len then\t\t\t\t!at end\r\n\ts+:=c\r\nelsif n=1 then\t\t\t\t!at start\r\n\ts:=c+s\r\nelse\t\t\t\t\t\t!in middle\r\n\ts:=leftstr(s,n-1)+c+rightstr(s,-(n-1))\r\nfi\r\nw.linkvar^:=s\r\n++w.attrs.currpos\r\ngxdraw(w)\r\n\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_key_editbox\t\t<\"mx\">\t\t\t(mess,w)=\r\n!CPL \"KEY/EDITBOX\"\r\n\r\npostmess(wapplic,mm_key,mess.a,mess.b,mess.state)\r\n\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_leftkey_editbox\t\t<\"mx\">\t\t(mess,w)=\r\nif ctrlpressed() then\r\n\tpostmess(wapplic,mm_leftkey,mess.a,mess.b,mess.state)\r\n\treturn skipmess\r\nfi\r\n\r\nif w.attrs.currpos>1 then\r\n\tdrawcaret(0)\r\n\t--w.attrs.currpos\r\n\tdrawcaret(1)\r\nfi\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_rightkey_editbox\t\t<\"mx\">\t\t(mess,w)=\r\nif ctrlpressed() then\r\n\tpostmess(wapplic,mm_rightkey,mess.a,mess.b,mess.state)\r\n\treturn skipmess\r\nfi\r\n\r\nif w.attrs.currpos<=w.linkvar^.len then\r\n\tdrawcaret(0)\r\n\t++w.attrs.currpos\r\n\tdrawcaret(1)\r\nfi\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_bskey_editbox\t\t<\"mx\">\t\t(mess,w)=\r\ns:=w.linkvar^\r\nif not s then return skipmess fi\r\nn:=w.attrs.currpos\r\nif n=1 then return skipmess fi\r\n\r\nif n>s.len then\t\t\t\t!at end\r\n\ts:=leftstr(s,-1)\r\nelse\t\t\t\t\t\t!in middle\r\n\ts:=leftstr(s,n-2)+rightstr(s,-(n-1))\r\nfi\r\nw.linkvar^:=s\r\n--w.attrs.currpos\r\ngxdraw(w)\r\n\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_deletekey_editbox\t\t<\"mx\">\t\t(mess,w)=\r\ns:=w.linkvar^\r\nif not s then return skipmess fi\r\nn:=w.attrs.currpos\r\nif n>s.len then return skipmess fi\r\n\r\nif n=1 then\t\t\t\t!at start\r\n\ts:=rightstr(s,-1)\r\nelse\t\t\t\t\t\t!in middle\r\n\ts:=leftstr(s,n-1)+rightstr(s,-n)\r\nfi\r\nw.linkvar^:=s\r\ngxdraw(w)\r\n\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_homekey_editbox\t\t<\"mx\">\t\t(mess,w)=\r\nif ctrlpressed() then\r\n\tpostmess(wapplic,mm_homekey,mess.a,mess.b,mess.state)\r\n\treturn skipmess\r\nfi\r\n\r\ndrawcaret(0)\r\nw.attrs.currpos:=1\r\ndrawcaret(1)\r\n\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_homekey_listbox\t\t<\"mx\">\t\t(mess,w)=\r\nif w.attrs.currpos>1 then\r\n\tgxsetlbpos(w,1)\r\nfi\r\n\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_endkey_editbox\t\t<\"mx\">\t\t(mess,w)=\r\nif ctrlpressed() then\r\n\tpostmess(wapplic,mm_endkey,mess.a,mess.b,mess.state)\r\n\treturn skipmess\r\nfi\r\n\r\ndrawcaret(0)\r\nw.attrs.currpos:=w.linkvar^.len+1\r\ndrawcaret(1)\r\n\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_endkey_listbox\t\t<\"mx\">\t\t(mess,w)=\r\n!if w.attrs.currpos<w.linkvar^.len then\r\nif w.attrs.currpos<getlvbounds(w.linkvar).len then\r\n!\tgxsetlbpos(w,w.linkvar^.len)\r\n\tgxsetlbpos(w,getlvbounds(w.linkvar).len)\r\nfi\r\n\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_upkey_listbox\t\t<\"mx\">\t\t(mess,w)=\r\nif w.attrs.currpos>1 then\r\n\tgxsetlbpos(w,w.attrs.currpos-1)\r\nfi\r\n\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_upkey_scrollbar\t\t<\"mx\">\t\t(mess,w)=\r\n!assume that this is independent scrollbar\r\n!(linked scrollbar wouldn't get the focus)\r\n\r\na:=w.attrs.currpos\r\nif a>w.attrs.limits.lwb then\r\n\t--a\r\n\tgxscrollpos(w,a,1)\r\n\tpostmess(w,mm_setvertpos,a)\r\nfi\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_downkey_listbox\t\t<\"mx\">\t\t(mess,w)=\r\n!if w.attrs.currpos<w.linkvar^.len then\r\nif w.attrs.currpos<getlvbounds(w.linkvar).len then\r\n\tgxsetlbpos(w,w.attrs.currpos+1)\r\nfi\r\n\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_pageupkey_listbox\t\t<\"mx\">\t\t(mess,w)=\r\nif (a:=w.attrs.currpos)>1 then\r\n\ta:=max(a-w.attrs.rows,1)\r\n\tgxsetlbpos(w,a)\r\nfi\r\n\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_pagedownkey_listbox\t\t<\"mx\">\t\t(mess,w)=\r\n!if (a:=w.attrs.currpos)<w.linkvar^.len then\r\nif (a:=w.attrs.currpos)<getlvbounds(w.linkvar).len then\r\n!\ta:=min(a+w.attrs.rows,w.linkvar^.len)\r\n\ta:=min(a+w.attrs.rows,getlvbounds(w.linkvar).len)\r\n\tgxsetlbpos(w,a)\r\nfi\r\n\r\nreturn skipmess\r\nend\r\n\r\nfunction mess_enterkey_listbox\t\t<\"mx\">\t\t(mess,w)=\r\nif w.attrs.currpos then\r\n\tpostmess(w,mm_pick,w.attrs.currpos)\r\nfi\r\n\r\nreturn skipmess\r\nend\r\n\r\nproc do_draw_all\t\t\t<\"wx\">\t\t\t(w)=\r\ngxclear(w)\r\ndrawborder(w)\r\ndrawchildborders(w)\r\nend\r\n\r\nproc do_draw_button\t\t\t<\"wx label\">\t\t\t(w)=\r\ngxclear(w)\r\n\r\ngxtext_just(w,w.text,,w.enable)\r\n\r\ndrawborder(w)\r\n\r\nend\r\n\r\nproc do_draw_toggle\t\t\t<\"wx\">\t(w)=\r\ngxclear(w)\r\n\r\nVALSTR:=\"\"\r\n\r\nturnedon:=istrue w.linkvar^\r\n\r\nif w.style.marktype then\r\n\tdrawmark(w.childlist[1],turnedon,w.enable)\r\n\r\n\tgxtext_just(w,w.text+valstr,markdim,w.enable)\r\nelse\r\n!\tcase w.style.hilitetype\r\n!\twhen invert_hilite then\r\n\t\tif turnedon then\r\n\t\t\tgxclear(w,getrgb(green))\r\n\t\tfi\r\n!\tesac\r\n\r\n\tgxtext_just(w,w.text+valstr)\r\nfi\r\nend\r\n\r\nproc do_draw_select\t\t\t<\"wx\">\t(w)=\r\ngxclear(w)\r\n\r\nturnedon:=w.linkvar^=w.attrs.onvalue\r\n\r\nif w.style.marktype then\r\n\tdrawmark(w.childlist[1],turnedon,w.enable)\r\n\tgxtext_just(w,w.text,markdim,w.enable)\r\nelse\r\n\tcase w.style.hilitetype\r\n\twhen invert_hilite then\r\n\t\tif turnedon then\r\n\t\t\tgxclear(w,getrgb(white))\r\n\t\tfi\r\n\tesac\r\n\t\tgxtext_just(w,w.text)\r\nfi\r\nend\r\n\r\nproc do_draw_editbox\t\t\t<\"wx\">\t(w)=\r\ngxclear(w)\r\n\r\ngxtext_just(w,w.linkvar^,enable:w.enable)\r\n\r\n!Now, have to draw the cursor\r\nunless wfocus==w then\t\t\t!only draw it when this window has the focus\r\n\treturn\r\nend\r\n\r\ncaretdrawn:=0\r\n\r\ndrawcaret(1)\r\nend\r\n\r\nproc do_draw_arrow\t\t\t<\"wx\">\t(w)=\r\ngxclear(w)\r\n\r\ndrawborder(w)\r\ndrawarrow(w,w.enable)\r\nend\r\n\r\nproc do_draw_mark\t\t\t<\"wx\">\t(w)=\r\n\r\ncase w.owner.windclass\r\nwhen toggle_class, select_class then\r\n\treturn\t\t\t\t\t!mark drawn by owner\r\nesac\r\n\r\ngxclear(w,getrgb(w.owner.style.windbgnd))\r\n\r\ndrawborder(w)\r\nend\r\n\r\nproc do_draw_scrollbar\t\t\t<\"wx\">\t(w)=\r\ngxclear(w)\r\ndrawborder(w)\r\ngxdraw(w.childlist[1])\t\t\t!arrows\r\ngxdraw(w.childlist[2])\r\n\r\n!now draw the thumb\r\nif w.attrs.thumbsize then\r\n\tif w.style.dir='H' then\r\n\t\tx:=w.attrs.thumbpos\r\n\t\tdx:=w.attrs.thumbsize\r\n\t\tdrawthumb(w,x,0,dx,w.dimy)\r\n\telse\r\n\t\ty:=w.attrs.thumbpos\r\n\t\tdy:=w.attrs.thumbsize\r\n\t\tdrawthumb(w,0,y,w.dimx,dy)\r\n\tfi\r\nfi\r\nend\r\n\r\nproc do_draw_listbox\t\t\t<\"wx\">\t(w)=\r\ngxclear(w)\r\ndrawborder(w)\r\nif w.childlist then\t\t\t!scrollbar\r\n\tgxdraw(w.childlist[1])\r\nfi\r\n\r\nfor i:=1 to w.attrs.rows do\r\n\tk:=i+w.attrs.pagepos-1\r\n\tif k<=getlvbounds(w.linkvar).len then\r\n\t\tdrawlbtext(w,i,getlvstritem(w.linkvar,k),0,k=w.attrs.currpos)\r\n\tfi\r\nod\r\nend\r\n\r\nproc do_update_all\t\t\t\t<\"wx\">\t(w)=\r\ngxdraw(w)\r\nend\r\n\r\nproc do_update_listbox\t\t\t<\"wx\">\t(w)=\r\ngxdraw(w)\r\nend\r\n\r\nproc drawcaret(x)=\r\n!x=1: draw caret in wfocus window at current position\r\n!x=0: delete caret in wsfocus window\r\n!returns x-pixel position of caret\r\n\r\nif wfocus=nil then\t\t!no window has focus\r\n\tcaretdrawn:=0\r\n\treturn\r\nfi\r\n\r\ncase wfocus.windclass\r\nwhen editbox_class then\r\n\tif x then\t\t\t!new caret\r\n\t\tif caretdrawn then return fi\t!already drawn\r\n\t\txpos:=getcaretpos(wfocus.linkvar^,wfocus.attrs.currpos,0)\r\n\t\twfocus.attrs.caretpos:=xpos\t\t\t!record position\r\n\telse\t\t\t!delete caret\r\n\t\tif not caretdrawn then return fi\t!already deleted\r\n\t\txpos:=wfocus.attrs.caretpos\t\t!use stored value\r\n\tfi\r\n\r\n\tcaretwidth:=2\r\n\r\n\tgxhighlight(wfocus,xpos+wfocus.attrs.textpos[1],wfocus.attrs.textpos[2]-chd,caretwidth,20)\r\n\r\n\tcaretdrawn:=x\r\nesac\r\nend\r\n\r\nfunction getcaretpos(s,pos,offset)=\r\n!return pixel position of in front of pos'th character in string s\r\n!offset is no. of chars not shown, to left of string\r\nif pos=1 then return 0 fi\r\n\r\nreturn wx_gettextwidth(wfocus.gdi.hdc, leftstr(s,pos-1))\r\nend\r\n\r\nproc drawborder(w)=\r\n!do own-drawn borders\r\n!other kinds of borders are windows-drawn, no-border, and the main bs- style\r\n!borders which exist in the owner's client area\r\n!for own-drawn borders, the window should have been cleared first\r\n\r\ncase bscat[w.style.border]\r\nwhen 0 then\t\t\t\t\t!no border\r\n\treturn\r\nwhen 'W' then\t\t\t\t!windows-drawn\r\n\treturn\r\nwhen 'X' then\t\t\t\t!external (drawn in owner's client space\r\n\tposx:=w.frameposx\r\n\tposy:=w.frameposy\r\n\tdimx:=w.framedimx\r\n\tdimy:=w.framedimy\r\n\tbs:=w.style.border\r\n\r\n\tbs:=w.style.border\r\n\two:=w.owner\r\n\tcase bs\r\n\twhen bs_simple then\t\t\t!USUALLY BS_SIMPLE converts to BS_WINDOWS; must be override\r\n\t\tgxcolour(wo,0)\r\n\t\tgxrect(wo,posx,posy,dimx,dimy)\r\n!\t\tgxline(wo,posx,posy,posx+dimx+50,posy+dimy+50)\r\n\twhen bs_thick then\r\n\twhen bs_panel then\r\n\t\tgxcolour(wo,ltcolour)\r\n\t\tgxline(wo,posx+dimx-1,posy, posx,posy)\r\n\t\tgxline(wo,posx,posy+dimy-1)\r\n\t\tgxcolour(wo,dkcolour)\r\n\t\tgxline(wo,posx+dimx-1,posy+dimy-1)\r\n\t\tgxline(wo,posx+dimx-1,posy)\r\n\twhen bs_inset then\r\n\t\tgxcolour(wo,dkcolour)\r\n\t\tgxline(wo,posx+dimx-1,posy, posx,posy)\r\n\t\tgxline(wo,posx,posy+dimy-1)\r\n\t\tgxcolour(wo,ltcolour)\r\n\t\tgxline(wo,posx+dimx-1,posy+dimy-1)\r\n\t\tgxline(wo,posx+dimx-1,posy)\r\n\twhen bs_testext then\r\n\t\tgxcolour(wo,0)\r\n\t\tgxrect(wo,posx,posy,dimx,dimy)\r\n\t\tgxrect(wo,posx+9,posy+9,dimx-18,dimy-18)\r\n!\t\tgxcolour(w,0)\r\n!\t\tgxline(w,0,0,w.dimx-1,w.dimy-1)\r\n!\t\tgxline(w,0,w.dimy-1,w.dimx-1,0)\r\n\r\n\tesac\r\nwhen 'I' then\t\t\t\t!internal (drawn within window's client space\r\n\tposx:=w.frameposx\r\n\tposy:=w.frameposy\r\n\tdimx:=w.dimx\r\n\tdimy:=w.dimy\r\n\r\n\tcase w.style.border\r\n\twhen bs_ownpanel then\r\n\t\tgxcolour(w,ltcolour)\r\n\t\tgxline(w,w.framedimx-1,0,0,0)\r\n\t\tgxline(w,0,w.framedimy-1)\r\n\t\tgxcolour(w,dkcolour)\r\n\t\tgxline(w,w.framedimx-1,w.framedimy-1)\r\n\t\tgxline(w,w.framedimx-1,0)\r\n\r\n\twhen bs_owninset then\r\n\t\tgxcolour(w,dkcolour)\r\n\t\tgxline(w,w.framedimx-1,0,0,0)\r\n\t\tgxline(w,0,w.framedimy-1)\r\n\t\tgxcolour(w,ltcolour)\r\n\t\tgxline(w,w.framedimx-1,w.framedimy-1)\r\n\t\tgxline(w,w.framedimx-1,0)\r\n\twhen bs_ownsimple then\r\n\t\tgxcolour(w,0)\r\n\t\tgxrect(w,0,0,w.framedimx,w.framedimy)\r\n\twhen bs_testint then\r\n\t\tgxcolour(w,0)\r\n\t\tgxrect(w,0,0,dimx,dimy)\r\n\t\tgxrect(w,7,7,dimx-14,dimy-14)\r\n!\t\tgxcolour(w,0)\r\n!\t\tgxline(w,0,0,w.dimx-1,w.dimy-1)\r\n!\t\tgxline(w,0,w.dimy-1,w.dimx-1,0)\r\n\tesac\r\nesac\r\nend\r\n\r\nproc drawchildborders(w)=\r\nif not w.childlist then\r\n\treturn\r\nfi\r\nforall wc in w.childlist do\r\n\tif wc.style.border in [bs_simple,bs_thick,bs_panel,bs_inset] then\r\n\t\tdrawborder(wc)\r\n\tfi\r\nod\r\nend\r\n\r\nproc drawarrow(w,enable)=\r\n!w has already been cleared\r\n!e=1/omitted to enable, 0 to disable (shown grey)\r\nconst factor=0.3\r\n\r\ngxsetpen(w,(enable|black|dkgrey))\r\n\r\nwidth:=w.dimx\r\nheight:=w.dimy\r\n\r\ncase w.style.dir\r\nwhen 'D' then\r\n\tx:=int(round(width/2)-1)\r\n\r\n\twd:=0\r\n\r\n\th:=int(round(min(height,width)*factor))\r\n\tif h<3 then h:=3 fi\r\n\ty:=int((height+h)*0.5)-1\r\n\r\n\tto h do\r\n\t\tgxline(w,x,y,x+wd,y)\r\n\t\tx-:=1\r\n\t\ty-:=1\r\n\t\twd+:=2\r\n\tod\r\n\r\nwhen 'U' then\r\n\tx:=int(round(width/2)-1)\r\n\twd:=0\r\n\r\n\th:=int(round(min(height,width)*factor))\r\n\tif h<3 then h:=3 fi\r\n\ty:=int(round((height-h)*0.5))\r\n\tto h do\r\n\t\tgxline(w,x,y,x+wd,y)\r\n\t\tx-:=1\r\n\t\ty+:=1\r\n\t\twd+:=2\r\n\tod\r\n\r\nwhen 'L' then\r\n\ty:=height%2\r\n\r\n\tht:=0\r\n\twd:=y\r\n\r\n\twd:=int(round(min(height,width)*factor))\r\n\tif wd<3 then wd:=3 fi\r\n\tx:=int(round((width-wd)*0.5)-1)\r\n\r\n\tto wd do\r\n\t\tgxline(w,x,y,x,y+ht)\r\n\t\ty-:=1\r\n\t\tx+:=1\r\n\t\tht+:=2\r\n\tod\r\n\r\nwhen 'R' then\r\n\ty:=height%2\r\n\tht:=0\r\n\r\n\twd:=int(round(min(height,width)*factor))\r\n\tif wd<3 then wd:=3 fi\r\n\tx:=int(round((width+wd)*0.5)-1)\r\n\r\n\tto wd do\r\n\t\tgxline(w,x,y,x,y+ht)\r\n\t\ty-:=1\r\n\t\tx-:=1\r\n\t\tht+:=2\r\n\tod\r\nesac\r\nend\r\n\r\nglobal proc gxtext_just(w,s,offset=0,enable=1)=\r\ndimx:=w.dimx\r\ndimy:=w.dimy\r\nwidth:=wx_gettextwidth(w.gdi.hdc, s)\r\nheight:=chy\t\t\t\t!assume basic font\r\n\r\ncase w.style.justify\r\nwhen 'L' then\tx:=smx\r\nwhen 'R' then\tx:=dimx-width-smx\r\nelse\r\n\t\t\tx:=(dimx-width)%2\r\nesac\r\n\r\ncase w.style.vjustify\r\nwhen 'T' then\ty:=smy\r\nwhen 'B' then\ty:=dimy-height-smy\r\nelse\r\n\t\t\ty:=(dimy-height)%2!\t\t-smy%2\r\nesac\r\n\r\nif not enable then\r\n\toldtextfgnd:=w.style.textfgnd\r\n\tgxtextcolour(w,grey)\r\nfi\r\n\r\ngxtext(w,s,x+offset,y)\r\n\r\nif not enable then\r\n\tgxtextcolour(w,oldtextfgnd)\r\nfi\r\nif w.windclass=editbox_class then\r\n\tw.attrs.textpos:=(x+offset,y)\r\nfi\r\nend\r\n\r\nproc drawthumb(w,x,y,dx,dy)=\r\n!w is a scrollbar, vert or hoz\r\n!draw thumb within w, as a simple rectangle starting at x,y at top left of size dx,dy\r\n\r\ngxcolour(w,0)\r\ngxrect(w,x,y,dx,dy)\r\ngxfillrect(w,x+1,y+1,dx-2,dy-2,getrgb(grey))\r\nend\r\n\r\nfunction isonthumb(w,d)=\r\n!w is a scrollbar, d is a pixel position along it (0 being at left or top)\r\n!return:\r\n! -1\tis before the thumb\r\n!  0\tis on the thumb\r\n! +1\tif after the thumb\r\n!d can specify a spot off the thumbar if being dragged\r\n\r\na:=w.attrs.thumbpos\r\nb:=w.attrs.thumbsize\r\n\r\nif d<a then\r\n\treturn -1\r\nelsif d>(a+b) then\r\n\treturn 1\r\nelse\r\n\treturn 0\r\nfi\r\nend\r\n\r\nproc drawmark(w,turnedon,enable)=\r\n!!w has already been cleared\r\n!draw checked check mark, tick, or radio button, according to whether\r\n!turnedon is 1 or 0\r\n!e=1 to enable, 0 to disable (shown grey)\r\n\r\ngxclear(w,getrgb(w.owner.style.windbgnd))\r\ngxsetpen(w,(enable|black|red))\r\n\r\nwidth:=w.dimx\r\nheight:=w.dimy\r\nx:=y:=1\r\nwd:=width-2\r\nht:=height-2\r\ngxrect(w,x,y,wd,ht)\r\nif not turnedon then return fi\r\n\r\ncase w.style.marktype\r\nwhen radio_mark then\r\n\r\n\tgxfillrect(w,x+3,y+3,wd-6,ht-6,getrgb(red))\r\n\r\nwhen check_mark then\r\n\r\n\tgxline(w,x,y,x+wd-1,y+ht-1)\r\n\tgxline(w,x+wd-1,y,x,y+ht-1)\r\n\r\nwhen tick_mark then\r\n\r\n\tgxline(w,x+3,y+ht%2,x+wd%2,y+ht-4)\r\n\tgxline(w,x+wd-3,y+2)\r\n\r\nesac\r\nend\r\n\r\nproc drawlbtext(w,row,text,clr=0,hilite=0)=\r\n!draw text inside given row of listbox w\r\n!clr=1 to clear the background first (not needed when entired lb has been cleared)\r\n!hilite=1 to highlight this row\r\n\r\nx:=0\r\ny:=(row-1)*w.attrs.pitch+w.attrs.offset\r\n\r\nif clr or hilite then\r\n\tgxfillrect(w,x,y,w.dimx,w.attrs.pitch,(hilite|getrgb(grey)|getrgb(w.style.windbgnd)))\r\nfi\r\n\r\nif hilite then\r\n\toldtextcolour:=gxtextcolour(w)\r\n\tgxtextcolour(w,white)\r\nfi\r\n!RETURN\r\n\r\ngxtext(w,text,x+smx,y+smy)\r\nif hilite then\r\n\tgxtextcolour(w,oldtextcolour)\r\nfi\r\nend\r\n\r\nfunction readnextitem(a)=\r\n!return (level,value,labelx,options)\r\n!special values used for divider, new column, new menu\r\n!next line of file should already have been read\r\n\r\nif a=\"\" then return list(0,0,0,0) fi\r\n\r\nlevel:=1\r\ntabs:=0\r\noptions:=\"\"\r\n\r\nwhile asc(a) in [9,' '] do tabs+:=1; a:=rightstr(a,-1) od\r\n\r\nif a=\"\" then return list(0,0,0,0) fi\r\n\r\ncase asc(a)\r\nwhen '!' then\r\n\treturn list(0,0,0,0)\r\nesac\r\n\r\nif tabs then\r\n\tj:=0\r\n\tfor i:=1 to ntab do\r\n\t\tif tabs=tabstack[i] then j:=i; exit fi\r\n\tod\r\n\r\n\tif j=0 then\r\n\t\tif tabs>tabstack[ntab] then\r\n\t\t\tntab+:=1\r\n\t\t\ttabstack[ntab]:=tabs\r\n!\t\t\tmenustack[ntab]:=0\r\n\t\tfi\r\n\t\tlevel:=ntab\r\n\telse\r\n\t\tlevel:=j\r\n\t\tif j<ntab then ntab:=j fi\r\n\tfi\r\nfi\r\n\r\nif asc(a) in ['0'..'9'] then\r\n\tvalue:=strtoval(a)\r\n\tn:=\" \" in a\r\n\tif not n then\r\n\t\tn:=chr(9) in a\r\n\tfi\r\n\tif n then\r\n\t\tlabelx:=rightstr(a,-n)\r\n\telse\r\n\t\tlabelx:=\"?\"\r\n\tfi\r\n\r\nelse\t\t\t!no preceding number, maybe top-level menu\r\n\r\n\tif \"=\" in a then\t!command def for mpl\r\n\t\treturn (0,0,0,0)\r\n\tfi\r\n\r\n\tvalue:=k_menu\r\n\tlabelx:=a\r\n\tcase convlc(labelx)\r\n\twhen \"hozbreak\",\"divider\" then\r\n\t\tvalue:=kdivide\r\n\twhen \"vertbreak\" then\r\n\t\tvalue:=kcolumn\r\n\twhen \"filehistory\" then\r\n\t\tvalue:=kfilehistory\r\n\telse\r\n\t\tif leftstr(labelx)=\"-\" then value:=kdivide fi\r\n\tesac\r\nfi\r\n\r\nif labelx=\"\" then\t\t\t!maybe [cmd] only\r\n\treturn list(0,0,0,0)\r\nfi\r\n\r\nreturn (level,value,(labelx),options)\r\nend\r\n\r\nfunction readmenu(m,n,level)=\r\n!starting at index n in data, read all following items that are\r\n!at lower level (ie. higher level number) than given level\r\n!insert items into menu handle m\r\n!return index of next item in data, which is at <level> or higher\r\n!will stop at end of data, and return ndata+1\r\n\r\n!restartx:\r\nfor i:=n to ndata do\r\n\t(l,value,labelx,options):=data[i]\r\n\r\n\tif l<=level then\t\t!end of this submenu\r\n\t\treturn i\r\n\tfi\r\n\r\n\tflags:=breakflag\r\n\tenable:=1\r\n\tif rightstr(labelx)=\"?\" then\r\n\t\tenable:=0\r\n\t\tlabelx:=leftstr(labelx,-1)\r\n\tfi\r\n\r\n\tif options<>\"\" then\r\n\t\tif \"H\" in options then flags+:=\"h\" fi\r\n\t\tif \"C\" in options then flags+:=\"c\" fi\r\n\tfi\r\n\r\n\tcase value\r\n\twhen kdivide then\r\n!  breakflag:=\"d\"\r\n\t\tgxaddmb(m,,,\"d\")\r\n!  gxaddmb(m,\"\",0,\"d\")\r\n\twhen kcolumn then\r\n\t\tbreakflag:=\"v\"\r\n\twhen k_menu then\t\t!submenu\r\n\t\tnewm:=gxcreatemb()\r\n\t\tn:=readmenu(newm,i+1,l)\r\n\t\tgxaddmb(m,labelx,newm,\"p\"+flags,enable)\r\n\t\tbreakflag:=\"\"\r\n\t\trestart\r\n!\t\tgoto restartx\r\n\twhen kfilehistory then\r\n\t\tnfiles:=8\r\n\t\tgxaddmb(m,\"filehistory\",1060,breakflag)\r\n\telse\t\t\t\t!ordinary command\r\nnormalcmd:\r\n\t\tgxaddmb(m,labelx,value,flags,enable)\r\n\t\tbreakflag:=\"\"\r\n\tesac\r\n\r\nskip:\r\nod\r\n\r\nreturn ndata+1\t\t\t!eod reached\r\nend\r\n\r\nfunction mbreaddata(a)=\r\n!a is a list of tab-indented strings for a menu bar\r\n!a can also be a text file containing the strings\r\n\r\ntabstack:=(0,)\r\nntab:=1\r\ndata:=()\r\nndata:=0\r\nbreakflag:=\"\"\r\n\r\nif a.isstring then\t\t!read from file\r\n\ta:=readtextfile(a)\r\n\tif a=0 then\r\n\t\ta:=(\"CANTOPENFILE\",)\r\n\tfi\r\nfi\r\n\r\nfor i:=1 to a.upb do\r\n\tx:=readnextitem(a[i])\r\n\r\n\tif x[1] then\r\n\t\t++ndata\r\n\t\tdata[ndata]:=x\r\n\tfi\r\nod\r\n\r\nm:=gxcreatemb()\r\nreadmenu(m,1,0)\r\nreturn m\r\nend\r\n\r\nglobal function gxmenubar(w,?a)=\r\n!called as:\r\n!\tgxmenubar(a):\tcreate standalone menu; return handle\r\n!\tgxmenubar(w,a):\tadd menu to windows w (returns 0)\r\n!a:\r\n!\tstring:\t\t\tassume this is a filename containing menubar tabbed layout\r\n!\tlist:\t\t\ta list of strings containing the data\r\n\r\nif a.defined then\t\t!w,m: read menu into window w\r\n\tm:=mbreaddata(a)\r\n! mbset(w,0)\r\n\r\n\tif not w.isint then\r\n\t\twhile w.owner<>nil do\r\n\t\t\tw:=w.owner\r\n\t\tod\r\n\tfi\r\n\r\n\tgxsetmb(w,m)\r\n\treturn 0\r\nelse\t\t\t\t!create standalone menu, return handle\r\n\treturn mbreaddata(w)\r\nfi\r\nend\r\n\r\nfunction gxcreatemb(?s)=\r\n\r\n!CPL \"MBCREATE:\",S\r\nif s.defined and s in \"Pp\" then\r\n\treturn createpopupmenu()\r\nelse\r\n\treturn createmenu()\r\nfi\r\nend\r\n\r\nproc gxsetmb(w,m)=\r\n\r\nhwnd:=w.gdi.hwnd\r\na:=getmenu(hwnd)\r\ns:=setmenu(hwnd,m)\r\nif a then destroymenu(a) fi\r\nend\r\n\r\nfunction gxaddmb(wm,caption=\"X\",id=0,style=\"\",enable=0)=\r\n\r\nif wm.isint then\t\t\t\t!assume handle\r\n\thmenu:=wm\r\n\twm:=nil\r\nelse\r\n\thmenu:=getmenu(wm.gdi.hwnd)\r\nfi\r\n\r\n!CPL \"WM,HMENU=\",WM,HMENU,ENABLE\r\n\r\nflags:=mf_string ior mf_unchecked\r\n\r\nif not enable then flags ior:=mf_greyed fi\r\n\r\nforeach c in convuc(style) do\r\n\tcase c\r\n\twhen 0 then exit\r\n\twhen 'P' then flags ior:=mf_popup\r\n\twhen 'D' then flags ior:=mf_separator\r\n\twhen 'B' then flags ior:=mf_menubreak\r\n\twhen 'V' then flags ior:=mf_menubarbreak\r\n\twhen 'H' then flags ior:=mf_help\r\n\twhen 'C' then flags ior:=mf_checked\r\n\tesac\r\nod\r\n\r\nif appendmenu(hmenu,flags,id,caption) then\r\n\tif wm<>nil then drawmenubar(wm.gdi.hwnd) fi\r\n\treturn hmenu\r\nfi\r\nreturn 0\r\nend\r\n\r\nproc gxshowmb(wm,w,x,y)=\r\n!update menu associated with window; call this function if it has been updated\r\n!when wm is a menu handle, draw the popup on the screen at x,y\r\nif wm.isint then\r\n\r\n\tif not y.defined then\r\n\t\tx:=w\r\n\t\ty:=x\r\n\t\tw:=nil\r\n\t\thwnd:=wapplic.gdi.hwnd\r\n\telse\r\n\t\thwnd:=w.gdi.hwnd\r\n\tfi\r\n\r\n\tpos:=ws_point(x,y)\r\n\r\n\tif w<>nil then\r\n\t\tclienttoscreen(w.gdi.hwnd,&pos)\r\n\tfi\r\n\r\n\ttrackpopupmenu(wm,0,pos.x,pos.y,0,hwnd,0)\r\nelse\r\n\tdrawmenubar(wm.gdi.hwnd)\r\nfi\r\nend\r\n\r\nfunction gxenablemb(wm,id,enable)=\r\n\r\nif wm.isint then\t\t\t\t!assume handle\r\n\thmenu:=wm\r\nelse\r\n\thmenu:=getmenu(wm.gdi.hwnd)\r\nfi\r\n\r\nif enable.defined then\r\n\treturn enablemenuitem(hmenu,id,(enable|0|mf_greyed)+mf_bycommand)\r\nelse\r\n\treturn (getmenustate(hmenu,id,mf_bycommand) iand mf_greyed|0|1)\r\nfi\r\nend\r\n\r\nfunction gxcheckmb(wm,id,check)=\r\nif wm.isint then\t\t\t\t!assume handle\r\n\thmenu:=wm\r\nelse\r\n\thmenu:=getmenu(wm.gdi.hwnd)\r\nfi\r\n\r\nif check.defined then\r\n\treturn checkmenuitem(hmenu,id,(check|mf_checked|mf_unchecked)+mf_bycommand)\r\nelse\r\n\treturn (getmenustate(hmenu,id,mf_bycommand) iand mf_checked|1|0)\r\nfi\r\nend\r\n\r\nproc gxclosemb(m)=\r\ndestroymenu(m)\r\nend\r\n\r\nglobal function gxconfirm(m)=\r\nx:=gxmsgbox(m,\"Confirm\",\"byn\")\r\nCPL =x\r\nreturn x=\"yes\"\r\nend\r\n\r\nfunction issubwindow(w,w2)=\r\nwhile w2 do\r\n\tif w2==w then return 1 fi\r\n\tw2:=w2.owner\r\nod\r\nreturn 0\r\nend\r\n\r\nglobal proc flushmessages=\r\n\r\nend\r\n",
    (uint8_t*)"global tabledata() optionnames =\r\n\t(wf_border,\t\t$),\t\t! wbs_simple\r\n\t(wf_resize,\t\t$),\t\t! 0\r\n\t(wf_hscroll,\t$),\t\t! 0\r\n\t(wf_vscroll,\t$),\t\t! 0\r\n\t(wf_menu,\t\t$),\t\t! 0\r\n\t(wf_caption,\t$),\t\t! 1\r\n\t(wf_max,\t\t$),\t\t! 0\r\n\t(wf_minmax,\t\t$),\t\t! 1\r\n\t(wf_sysmenu,\t$),\t\t! 1\r\n\t(wf_desktop,\t$),\t\t! 0\r\n\t(wf_clip,\t\t$),\t\t! 0\r\n\t(wf_show,\t\t$),\t\t!\r\n\t(wf_iframe,\t\t$),\t\t! 1\r\n\t(wf_cent,\t\t$),\t\t!\r\n\t(wf_toolwind,\t$)\t\t!\r\nend\r\n\r\n!Windows border styles, used for pop-up windows. Could also be used for\r\n!some child windows\r\nglobal tabledata() wbsnames=\r\n\t(wbs_none=0,$),\r\n\t(wbs_simple,$),\r\n\t(wbs_thick,$),\r\n\t(wbs_resize,$),\r\n\t(wbs_sunken,$),\r\n\t(wbs_sunken2,$),\r\n\t(wbs_sunkenrs,$),\r\n\t(wbs_dummy,$)\r\nend\r\n\r\nproc start=\r\nend\r\n\r\nPROC MAIN=\r\nEND\r\n",
    \
(uint8_t*)"!BMLIB\r\n\r\nimport sys\r\nimport clib\r\nimport files\r\nimport winapi\r\nimport winconsts\r\nimport gxlib\r\n\r\nVAR DEBUG=0\r\n\r\n\r\n!importdll jpeg=\r\n!\tmlang function \"jpeg.loadjpeg\" as loadjpeg\t(string, ref byte, ref byte)ref byte!\tmlang proc     \"jpeg.freejpeg\" as freejpeg (ref byte)\r\n!end\r\n\r\n!hostproc imgloadbgr\r\n\r\n!importdll loadimg =\r\nimportdll imglib =\r\n!    clang function stbi_load\t\t(string, ref byte, ref byte, ref byte, int32)ref byte\r\n    clang function imgload_rgb\t\t(string, ref byte, ref byte, ref byte, int32)ref byte\r\n    clang function imgload_bgr\t\t(string, ref byte, ref byte, ref byte, int32)ref byte\r\n    clang proc     imgload_free\t\t(ref byte)\r\n    clang function imgsave_jpeg_rgb\t(string, ref byte, int32, int32, int32)int32\r\n    clang function imgsave_jpeg_bgr\t(string, ref byte, int32, int32, int32)int32\r\n!    clang proc     stbi_image_free\t(ref byte)\r\nend\r\n\r\ntype bmpheader = struct\r\n\tws_bitmapfileheader fh\r\n\tws_bitmapinfoheader bh\r\nend\r\n\r\nvar\tshifts=[2:1, 4:2, 8:3, 16:4, 32:5, 64:6]\r\n\r\nproc start=\r\n!CPL \"BMLIB START\"\r\nend\r\n\r\nproc main=\r\n\r\n!C\r\n\r\n!PASTETEST()\r\n\r\nCPL \"TESTING BMMAIN\"\r\nFILE:=\"C:/JPEG/GIRL.JPG\"\r\n!FILE:=\"C:/JPEG/freya.JPG\"\r\n\r\n!FILE:=\"C:/JPEG/CARD2.JPG\"\r\n!FILE:=\"C:fred.ppm\"\r\n\r\n!!FILE:=\"C:/PNG/basi2C16.png\"\r\nBM:=BMLOAD(FILE)\r\n!CPL =BM.TYPE\r\nIF NOT BM THEN STOP FI\r\n\r\n!CPL \"LOADED\"\r\n!STOP\r\n!BMSAVE(\"FRED.PPM\",BM)\r\n!BMSAVE(\"FRED.PPM\",BM,0)\r\n!\r\n!!CPL \"SAVED\"\r\n!!!bmfree(bm)\r\n!!\r\n!!BMPUTCLIPBOARD(bm)\r\nw:=GXCREATEWINDOW(DIM:(960,540),caption:\"HI THERE\")\r\n!gxcopy(w,bm,scalex:0.25)\r\ngxcopy(w,bm,scalex:0.5)\r\neventloop()\r\n\r\nend\r\n\r\n!global function bmcreate(pixelbits,width,height,maskptr=nil)=\r\nglobal function bmcreate(pixelbits,width,height)=\r\n!create new bitmap with given specs, return handle to bitmap (=rwindow ref)\r\n!when maskptr<>nil, set up mask values\r\n\r\n\tbminfo:=new(ws_bitmapv5header)\r\n\tbminfo.size:=ws_bitmapv5header.bytes\r\n\tbminfo.width:=width\r\n\tbminfo.height:=-height\r\n\tbminfo.planes:=1\r\n\tbminfo.bitcount:=pixelbits\r\n\r\n\tpixelptr:=nil\r\n\r\n\tif pixelbits not in [8,24,32] then\r\n\t\tabort(\"bmcreate pixel size not supported:\"+tostr(pixelbits))\r\n\tfi\r\n\r\n!\thwnd:=createdibsection(screendc,&bminfo,0,&pixelptr,0,0)\r\n\thwnd:=createdibsection(nil,&bminfo,0,&pixelptr,0,0)\r\n\r\n\tpixelptr:=makeref(pixelptr,byte)\r\n\r\n\tif hwnd=0 then\r\n\t\terror:=getlasterror()\r\n\t\tabort(\"bmcreate:CreateDIB failed:\"+tostr(error))\r\n\tfi\r\n\r\n!now create a bm record based around this handle\r\n\r\n\tbm:=new(rwindow,0)\r\n\tbm.windclass:=bitmap_class\r\n\r\n\tbm.dimx:=width\r\n\tbm.dimy:=abs(height)\t\t!neg height used for top-down bitmaps\r\n\r\n\tbm.style:=defstyle\r\n\r\n\tbm.pixelbits:=pixelbits\r\n\tbm.pixelptr:=pixelptr\r\n!\tbm.pixelptr:=pixelptr\r\n\r\n!\tbm.attrs:=bitmaprec(pixelbits,pixelptr,0,0,0)\t\t!pixelbytes/linebytes/ncolours are zero\r\n\r\n!set bytes per pixel\r\n\tbm.pixelbytes:=pixelbits%8\r\n\r\n!set bytes per scanline\r\n\tn:=bm.pixelbytes*width\r\n\r\n!n must be a multiple of 4 bytes\r\n\tif (n iand 3)<>0 then\t!make bytes a multiple of 4\r\n\t\tn:=(n+4) iand 0xfffc\r\n\tfi\r\n\tbm.linebytes:=n\r\n\tbm.framebytes:=bm.linebytes*bm.dimy\r\n\r\n!set palette colours, using winrgb order\r\n\tif pixelbits=8 then\r\n\t\tpalette:=new(array,int32,0..255)\r\n\t\tbm.paltype:=greyscale_pal\r\n\t\tcolour:=0\r\n\t\tfor i:=0 to 255 do\r\n\t\t\tpalette[i]:=colour\r\n\t\t\tcolour+:=0x10101\r\n\t\tod\r\n\tfi\r\n\r\n\tsetupgdi(bm,hwnd)\r\n\r\n\tbm.gdi.hdc:=createcompatibledc(nil)\r\n\tbm.gdi.drawmode:=dm_memory\r\n\tbm.gdi.oldbmobj:=selectobject(bm.gdi.hdc,hwnd)\t!should store original bitmap\r\n\tsetstretchbltmode(bm.gdi.hdc,4)\t\t\t!average pixels for best result\r\n\r\n\tbmputpalette(bm,palette)\r\n\r\n\treturn bm\r\nend\r\n\r\nglobal function bmgetpalette(bm)=\r\n!extract entire palette to p, in bmrgb order\r\n\tif bm.paltype then\r\n\t\tpalette:=new(array,int32,0..256)\r\n\t\tgetdibcolortable(bm.gdi.hdc,0,256,&palette)\r\n\t\tpalette[256]:=bm.paltype\r\n\t\treversepalette(palette)\r\n\telse\r\n\t\tpalette:=()\r\n\tfi\r\n\treturn palette\r\nend\r\n\r\nglobal proc bmputpalette(bm,p,reverse=1)=\r\n!update entire palette from p, in bmrgb order\r\n\tif bm.paltype then\r\n\t\tif reverse then reversepalette(p) fi\t\t!fix colours\r\n\t\tsetdibcolortable(bm.gdi.hdc,0,256,&p)\t!store\r\n\t\tif reverse then reversepalette(p) fi\t\t\t!restore orignal palette\r\n\t\tif p.upb=256 then\r\n\t\t\tbm.paltype:=p[256]\r\n\t\tfi\r\n\tfi\r\nend\r\n\r\nglobal function bmcolour(bm,n,?colour)=\r\n!get/set palette info:\r\n!n=given:\r\n! colour given: update colour entry\r\n! colour omitted(-1): return colour value\r\n\r\n\tif colour.isdef then\t\t!set colour\r\n\t\tcolour:=revpixel(colour)\r\n\t\tsetdibcolortable(bm.gdi.hdc,n,1,&colour)\r\n\t\treturn colour\r\n\telse\t\t\t\t!get colour\r\n\t\tcolour:=0\r\n\t\tgetdibcolortable(bm.gdi.hdc,n,1,&colour)\r\n\t\treturn revpixel(colour)\r\n\tfi\r\nend\r\n\r\nglobal proc reversepalette(&p)=\r\n!reverse values of 32-bit colour data at p\r\n!CPL \"REV PALETTE\"\r\n\tfor i:=0 to 255 do\r\n\t\tp[i]:=revpixel(p[i])\r\n\tod\r\nend\r\n\r\nglobal function revpixel(a)=\r\n!change rgb to bgr\r\n!windows colours use red in lsb, bitmaps use blue in lsb, in 24-bit pixels and palette colours\r\nreturn (a iand 0x00ff00) ior (a>>16 iand 255) ior ((a iand 255)<<16)\r\nend\r\n\r\nglobal proc bmshow(bm)=\r\n\tgxcopy(bm)\r\n\twaitkey()\r\nend\r\n\r\nglobal proc bmfree(bm)=\r\n\treturn if bm=nil\r\n\tif not deletedc(bm.gdi.hdc) then\r\n\t\tpcerror(\"ERROR DELETING BM/HDC\")\r\n\tfi\r\n\r\n\tif not deleteobject(bm.gdi.hwnd) then\r\n\t\tpcerror(\"ERROR DELETING DIB\")\r\n\tfi\r\nend\r\n\r\nglobal function bmdupl(bm)=\r\n\tnewbm:=bmcreate(bm.pixelbits, bm.dimx, bm.dimy)\r\n\tmemcpy(newbm.pixelptr, bm.pixelptr, bm.linebytes*bm.dimy)\r\n\r\n\tbmduplpalette(newbm,bm)\r\n\r\n\treturn newbm\r\nend\r\n\r\nglobal proc bmduplpalette(newbm,bm)=\r\n\tif bm.paltype then\r\n\t\tpal:=bmgetpalette(bm)\r\n\t\tbmputpalette(newbm,pal)\r\n\t\tnewbm.paltype:=bm.paltype\r\n\tfi\r\nend\r\n\r\nglobal function bmduplz(bm)=\r\n\tnewbm:=bmcreate(bm.pixelbits, bm.dimx, bm.dimy)\r\n\treturn newbm\r\nend\r\n\r\nglobal function bmgetptr(bm,x,y)=\r\n!return byte pointer to given pixel\r\n\treturn bm.pixelptr+(bm.linebytes*y+x*bm.pixelbytes)\r\nend\r\n\r\nglobal function bmgetrowptr(bm,y)=\r\n!\treturn makeref(bm.pixelptr+y*bm.linebytes,byte)\r\n\treturn bm.pixelptr+y*bm.linebytes\r\nend\r\n\r\nfunction getcbbitmap(hwnd)=\r\n\r\n\tp:=globallock(hwnd)\r\n\thsize:=ws_bitmapinfoheader.bytes\r\n\tbm:=nil\r\n\r\n\tif p then\r\n\t\tp:=makeref(p,ws_bitmapinfoheader)\r\n\t\tpb:=makeref(p,byte)\r\n\r\n\t\tbm:=bmcreate(p^.bitcount,p^.width,p^.height)\r\n\t\toffset:=(bm.paltype|1024|0)\t\t!offset due to palette table\r\n\r\n\t\tif offset then\r\n\t\t\tsetdibcolortable(bm.gdi.hdc,0,256,pb+hsize)\r\n\t\tfi\r\n\r\n\t\tpb:=pb+hsize+offset\r\n\t\tfor y:=0 to bm.dimy-1 do\r\n\t\t\tq:=bmgetrowptr(bm,bm.dimy-y-1)\r\n\t\t\tmemcpy(q,pb,bm.linebytes)\r\n\t\t\tpb:=pb+bm.linebytes\r\n\t\tod\r\n\r\n\tfi\r\n\r\n\tglobalunlock(hwnd)\r\n\r\n\treturn bm\r\nend\r\n\r\nglobal function bmgetclipboard=\r\n!get image from clipboard if one is there, otherwise return nil\r\n\tif openclipboard(0)=0 then\r\n\t\treturn nil\r\n\tfi\r\n\r\n\thwnd:=getclipboarddata(cf_dib)\r\n\r\n\tbm:=nil\r\n\tif hwnd then\r\n\t\tbm:=getcbbitmap(hwnd)\r\n\tfi\r\n\r\n\tcloseclipboard()\r\n\r\n\treturn bm\r\nend\r\n\r\nglobal function bmputclipboard(bm)=\r\n\tif openclipboard(0)=0 then\r\n\t\treturn nil\r\n\tfi\r\n\r\n\temptyclipboard()\r\n\r\n\thwnd:=putcbbitmap(bm)\r\n\tif hwnd then\r\n\t\tsetclipboarddata(cf_dib,hwnd)\r\n\tfi\r\n\r\n\tcloseclipboard()\r\n\treturn 1\r\nend\r\n\r\nfunction putcbbitmap(bm)=\r\n\thsize:=ws_bitmapinfoheader.bytes\r\n\tpsize:=(bm.paltype|1024|0)\r\n\tfsize:=bm.linebytes*bm.dimy\r\n\r\n\thmem:=globalalloc(0,hsize+psize+fsize)\r\n\tmem:=makeref(globallock(hmem),byte)\r\n\r\n\thdr:=new(ws_bitmapinfoheader)\r\n\thdr.size:=hsize\r\n\thdr.width:=bm.dimx\r\n\thdr.height:=bm.dimy\r\n\thdr.bitcount:=bm.pixelbits\r\n\thdr.planes:=1\r\n\thdr.xpelspermetre:=11811\r\n\thdr.ypelspermetre:=11811\r\n\thdr.clrused:=0\r\n\r\n\tmemcpy(mem,&hdr,hsize)\r\n\r\n\tif psize then\r\n\t\tpal:=bmgetpalette(bm)\r\n\t\tmemcpy(mem+hsize,&pal,psize)\r\n\tfi\r\n\r\n\tmem:=mem+hsize+psize\r\n\tfor y:=0 to bm.dimy-1 do\r\n\t\tp:=bmgetrowptr(bm,bm.dimy-1-y)\r\n\t\tmemcpy(mem, p, bm.linebytes)\r\n\t\tmem:=mem+bm.linebytes\r\n\tod\r\n!\tmemcpy(mem+hsize+psize,bm.pixelptr,fsize)\r\n\tglobalunlock(hmem)\r\n\r\n\treturn hmem\r\nend\r\n\r\nproc copy24to8(newbm,oldbm)=\r\n!both images are same size. Copy 1st plane of 24-bit oldbm to 8-bit newbm\r\n\tfor y:=0 to oldbm.dimy-1 do\r\n\t\tp:=bmgetrowptr(newbm,y)\r\n\t\tq:=bmgetrowptr(oldbm,y)\r\n\t\tto oldbm.dimx do\r\n\t\t\tp++^:=q^\r\n\t\t\tq:=q+3\r\n\t\tod\r\n\tod\r\nend\r\n\r\n!proc copy8to24(newbm,oldbm)=\r\n!!both images are same size. Copy only plane of 8-bit oldbm to all planes of 24-bit newbm\r\n!\tfor y:=0 to oldbm.dimy-1 do\r\n!\t\tp:=bmgetrowptr(newbm,y)\r\n!\t\tq:=bmgetrowptr(oldbm,y)\r\n!\t\tto oldbm.dimx do\r\n!\t\t\tp++^:=q^\r\n!\t\t\tq:=q+3\r\n!\t\tod\r\n!\tod\r\n!end\r\n\r\nglobal proc bmresetpalette(bm)=\r\n# set palette back to greyscale\r\n\tpal:=new(array,int32,0..256)\r\n\tcolour:=0\r\n\tfor i:=0 to 255 do\r\n\t\tpal[i]:=colour\r\n\t\tcolour+:=0x010101\r\n\tod\r\n\tbmputpalette(bm,pal)\r\n\tbm.paltype:=greyscale_pal\r\nend\r\n\r\nfunction makescalemap(x)=\r\n!x=0..1; create 256-element lookup table to multiply 0..255 by x\r\n\tmap:=new(list,0..255)\r\n\tfor i:=0 to 255 do\r\n\t\tmap[i]:=clamp(int(round(i*x)),0,255)\r\n\tod\r\n\treturn map\r\nend\r\n\r\nfunction bmunimpl(mess)=\r\n!ABORT(\"UNIMPLEMENTED: \"+MESS)\r\nPRINTLN \"UNIMPLEMENTED:\",MESS\r\nPRINTLN \"ABORTING\"\r\nSTOP\r\nreturn 0\r\nend\r\n\r\n!===========================================================================\r\n!========= HANDLERS\r\n!===========================================================================\r\n\r\nglobal function bmload(filename)=\r\n!CPL \"BMLOAD:\",FILENAME\r\n\tcase e:=convlc(extractext(filename))\r\n\twhen \"jpg\",\"jpeg\" then\r\n\t\treturn bmloadjpg(filename)\r\n\twhen \"bmp\" then\r\n\t\treturn bmloadbmp(filename)\r\n\twhen \"pgm\" then\r\n\t\treturn bmloadpgm_p2p5(filename)\r\n\twhen \"ppm\" then\r\n\t\treturn bmloadppm_p3p6(filename)\r\n\twhen \"pbm\" then\r\n\t\treturn bmloadpbm_p1p4(filename)\r\n\twhen \"png\" then\r\n\t\treturn bmloadpng(filename)\r\n\twhen \"\" then\t\t\t\t!try all\r\n\t\texts:=(\"jpg\",\"bmp\",\"pgm\",\"ppm\",\"png\")\r\n\t\tforall ext in exts do\r\n\t\t\tbm:=bmload(addext(filename,ext))\r\n\t\t\tif bm then\r\n\t\t\t\treturn bm\r\n\t\t\tfi\r\n\t\tod\r\n\t\treturn nil\r\n\telse\r\n\t\tprintln \"CAN'T LOAD\",E,\"IMAGE\"\r\n\t\treturn nil\r\n\tesac\r\n\treturn nil\r\nend\r\n\r\nfunction bmloadbmp(filename)=\r\n\tf:=openfile(filename)\r\n\tif not f then return nil fi\r\n\r\n\tfileheader:=new(bmpheader)\r\n\r\n\treadrandom(f,&fileheader,0,bmpheader.bytes)\r\n\tfiledimx:=fileheader.bh.width\r\n\tfiledimy:=fileheader.bh.height\r\n\tinvert:=1\r\n\tif filedimy<0 then\r\n\t\tfiledimy:=abs(filedimy)\r\n\t\tinvert:=0\r\n\tfi\r\n\r\n\tif fileheader.fh.typex<>'BM' then\r\n\t\tclosefile(f)\r\n\t\treturn nil\r\n\tfi\r\n\r\n\tif fileheader.bh.compression<>0 then\r\n\t\tclosefile(f)\r\n\t\treturn nil\r\n\tfi\r\n\r\n\tbm:=bmcreate(fileheader.bh.bitcount,filedimx,filedimy)\r\n\tframebytes:=bm.linebytes*filedimy\r\n\r\n\tif bm.paltype then\r\n\t\tpalette:=new(array,int32,0..255)\r\n\t\treadrandom(f,&palette,bmpheader.bytes,1024)\r\n\t\tbmputpalette(bm,palette,0)\r\n\t\tcolour:=0\r\n\t\tfor i:=0 to 255 do\r\n\t\t\tif palette[i]<>colour then\r\n\t\t\t\tbm.paltype:=colour_pal\r\n\t\t\t\texit\r\n\t\t\tfi\r\n\t\t\tcolour+:=0x010101\r\n\t\tod\r\n\r\n\tfi\r\n\r\n\treadrandom(f,bm.pixelptr,fileheader.fh.offbits,framebytes)\r\n\tclosefile(f)\r\n\r\n\r\n\tif invert then\r\n\t\tn:=bm.linebytes\r\n\t\tbuffer:=makeref(malloc(n),byte)\r\n\r\n\t\tfor y:=0 to filedimy%2 do\r\n\t\t\tp:=bmgetrowptr(bm,y)\r\n\t\t\tq:=bmgetrowptr(bm,filedimy-1-y)\r\n!\r\n\t\t\tmemcpy(buffer,p,n)\r\n\t\t\tmemcpy(p,q,n)\r\n\t\t\tmemcpy(q,buffer,n)\r\n\t\tod\r\n\t\tfree(buffer)\r\n\tfi\r\n\r\n\treturn bm\r\nend\r\n\r\nfunction bmloadjpg(filename)=\r\n\tw:=h:=n:=0\r\n\r\n!CPL \"BMLOADJPEG\"\r\n\r\n\tp:=imgload_bgr(filename,&w,&h,&n,0)\r\n!\tp:=imgloadbgr(filename,&w,&h,&n,0)\r\n\r\n\tpixelbits:=n*8\r\n\r\n\tif p=nil then\r\n\t\treturn nil\r\n\tfi\r\n\r\n\tq:=makeref(p,byte)\r\n\r\n\tbm:=bmcreate(pixelbits,w,h)\r\n\r\n\tnbytes:=w*h*n\r\n\tdest:=makeref(bm.pixelptr,byte)\r\n\r\n\tto h do\r\n\t\tmemcpy(dest,q,w*n)\r\n\t\tdest:=dest+bm.linebytes\r\n\t\tq:=q+w*n\r\n\tod\r\n\r\n\timgload_free(p)\r\n\r\n\treturn bm\r\nend\r\n\r\nfunction bmloadpbm_p1p4(filename)=\r\nCPL \"CAN'T LOAD PBM\"\r\nRETURN NIL\r\n!return bmunimpl(\"bmloadpbm\")\r\nend\r\n\r\nfunction bmloadpgm_p2p5(filename)=\r\nCPL \"CAN'T LOAD PGM\"\r\nRETURN NIL\r\n\r\n!return bmunimpl(\"bmloadpgm\")\r\nend\r\n\r\nfunction bmloadppm_p3p6(filename)=\r\n!read p6 ppm which is binary 24-bit, but will also recognise other formats\r\n\r\n!CPL \"P3P6\"\r\n\tf:=openfile(filename,\"rb\")\r\n\tif f=0 then return nil fi\r\n\r\n\treadln @f, sig:\"s\"\r\n\r\n!CPL =SIG\r\n\tcase sig\r\n\twhen \"P6\" then\r\n\t\tbinary:=1\r\n\twhen \"P3\" then\r\n\t\tbinary:=0\r\n\twhen \"P5\",\"P2\" then\r\n\t\treturn bmloadpgm_p2p5(file)\r\n\twhen \"P4\",\"P1\" then\r\n\t\treturn bmloadpbm_p1p4(file)\r\n\telse\r\n\t\tabort(\"Can't read ppm/P3\")\r\n\t\treturn nil\r\n\tesac\t\r\n\r\n!CPL \"READING P6/P3 PPM\"\r\n\r\n\twidth:=readnextint(f)\r\n\theight:=readnextint(f)\r\n\tmaxpix:=readnextint(f)\r\n\r\n\tbm:=bmcreate(24,width,height)\r\n\r\n\tlinebytes:=width*3\r\n\tdest:=makeref(bm.pixelptr,byte)\r\n\r\n\tto height do\r\n\t\tif binary then\r\n\t\t\treadbytes(f,dest,linebytes)\t\t\t!will be bgr\r\n\t\telse\r\n\t\t\tp:=dest\r\n\t\t\tto linebytes do\r\n\t\t\t\tp++^:=readffint(f)\r\n\t\t\tod\r\n\t\tfi\r\n\r\n\t\tp:=dest\t\t\t\t\t\t\t\t!convert to rgb\r\n\t\tto width do\r\n\t\t\tswap(p^,(p+2)^)\r\n\t\t\tp:=p+3\r\n\t\tod\r\n\r\n\t\tdest:=dest+bm.linebytes\r\n\tod\r\n\r\n\tclosefile(f)\r\n\r\n\treturn bm\r\nend\r\n\r\nfunction readnextint(f)=\r\n\tread x\r\n\twhile not x.isint and not eof(f) do\r\n\t\treadln @f,x\r\n\tod\r\n\tif not x.isint then return 0 fi\r\n\treturn x\r\nend\r\n\r\nfunction readffint(f)=\r\n!read next free-format int from f\r\n\trepeat\r\n\t\tc:=inbyte(f)\r\n\tuntil c in '0'..'9'\r\n\r\n\ta:=c-'0'\r\n\tdo\r\n\t\tc:=inbyte(f)\r\n\t\tif c in '0'..'9' then\r\n\t\t\ta:=a*10+c-'0'\r\n\t\telse\r\n\t\t\texit\r\n\t\tfi\r\n\tod\r\n\r\n\treturn a\r\nend\r\n\r\nfunction bmloadpng(filename)=\r\nRETURN BMLOADJPG(FILENAME)\r\n!return bmunimpl(\"bmloadpng\")\r\nend\r\n\r\nglobal function bmsave(filename,bm,binary=1)=\r\n\tcase e:=convlc(extractext(filename))\r\n\twhen \"jpg\",\"jpeg\" then\r\n\t\treturn bmsavejpg(filename,bm)\r\n\twhen \"bmp\" then\r\n\t\treturn bmsavebmp(filename,bm)\r\n\twhen \"ppm\" then\r\n\t\treturn bmsaveppm_p3p6(filename,bm,binary)\r\n\twhen \"pgm\" then\r\n\t\treturn bmsavepgm_p2p5(filename,bm,binary)\r\n\twhen \"pbm\" then\r\n\t\treturn bmsavepbm_p1p4(filename,bm,binary)\r\n\telse\r\n\t\tprintln \"CAN'T SAVE\",E,\"IMAGE\"\r\n\t\treturn nil\r\n\tesac\r\n\treturn nil\r\nend\r\n\r\nfunction bmsavebmp(filename,bm)=\r\n\tw:=bm.dimx\r\n\th:=bm.dimy\r\n\tpixelbytes:=bm.pixelbytes\r\n\tframebytes:=bm.linebytes*h\r\n\tpalettebytes:=(pixelbytes=1|1024|0)\r\n\r\n\tbmfile:=createfile(filename)\r\n\tif bmfile=nil then\r\n\t\treturn 0\r\n\tfi\r\n\r\n\tfileheader:=new(bmpheader)\r\n\r\n\tfileheader.fh.typex:='BM'\r\n\tfileheader.fh.offbits:=bmpheader.bytes+palettebytes\r\n\tfileheader.fh.size:=fileheader.fh.offbits+framebytes\r\n\tfileheader.bh.size:=ws_bitmapinfoheader.bytes\r\n\tfileheader.bh.width:=bm.dimx\r\n\tfileheader.bh.height:=-bm.dimy\r\n\tfileheader.bh.bitcount:=bm.pixelbits\r\n\tfileheader.bh.planes:=1\r\n\tfileheader.bh.xpelspermetre:=11811\t\t!300 dpi\r\n\tfileheader.bh.ypelspermetre:=11811\r\n\tfileheader.bh.clrused:=0\r\n\r\n\twriterandom(bmfile,&fileheader,0,bmpheader.bytes)\r\n\r\n\tif palettebytes then\r\n\t\tpalette:=bmgetpalette(bm)\r\n\t\treversepalette(palette)\r\n\t\twriterandom(bmfile,&palette,bmpheader.bytes,palettebytes)\r\n\tfi\r\n\r\n\twriterandom(bmfile,bm.pixelptr,fileheader.fh.offbits,framebytes)\r\n\r\n\treturn closefile(bmfile)\r\nend\r\n\r\nfunction bmsavejpg(filename,bm)=\r\n\tw:=bm.dimx\r\n\th:=bm.dimy\r\n\tpixelbytes:=bm.pixelbytes\r\n\tlinebytes:=bm.linebytes\r\n\r\n\tp:=q:=malloc(pixelbytes*w*h)\r\n\r\n\ts:=makeref(bm.pixelptr,byte)\r\n\r\n\tto h do\r\n\t\tmemcpy(q,s,w*pixelbytes)\r\n\t\tq:=q+bm.linebytes\r\n\t\ts:=s+w*pixelbytes\r\n\tod\r\n\r\n\tstatus:=imgsave_jpeg_bgr(filename,p,w,h,pixelbytes)\r\n\r\n\tfree(p)\r\n\r\n\treturn status\r\nend\r\n\r\nfunction bmsavepbm_p1p4(filename,bm,binary)=\r\nreturn bmunimpl(\"bmsaveppm\")\r\nend\r\n\r\nfunction bmsavepgm_p2p5(filename,bm,binary)=\r\nreturn bmunimpl(\"bmsavepgm\")\r\nend\r\n\r\nfunction bmsaveppm_p3p6(filename,bm,binary)=\r\n!\treturn bmunimpl(\"bmsaveppm\")\r\n\r\n\twidth:=bm.dimx\r\n\theight:=bm.dimy\r\n\r\n\tcase bm.pixelbits\r\n\twhen 24 then\r\n\twhen 8 then\r\n\t\treturn bmsavepgm_p2p5(filename,bm,binary)\r\n\telse\r\n\t\treturn 0\r\n\tesac\r\n\r\n\tf:=createfile(changeext(filename,\"ppm\"))\r\n\r\n\tCPL \"WRITEPPM\",CHANGEEXT(FILENAME,\"PPM\")\r\n\r\n\tif not f then return 0 fi\r\n\r\n\tprintln @f,(binary|\"P6\"|\"P3\")\r\n\tprintln @f,width\r\n\tprintln @f,height\r\n\tprintln @f,\"255\"\r\n!\r\n\tbuffer:=data\r\n\r\n\tbuffer:=malloc(bm.linebytes)\r\n\tif buffer=nil then return 0 fi\r\n\tbuffer:=makeref(buffer,byte)\r\n\r\n\tlinebytes:=width*3\t\t\t!also number of values per line when in text mode\r\n\r\n\tfor y:=0 to height-1 do\r\n\t\tmemcpy(buffer,bmgetrowptr(bm,y),linebytes)\r\n\t\tp:=buffer\t\t\t\t\t!convert to bgr\r\n\t\tto width do\r\n\t\t\tswap(p^,(p+2)^)\r\n\t\t\tp:=p+3\r\n\t\tod\r\n\t\tif binary then\r\n\t\t\twritebytes(f,buffer,linebytes)\r\n\t\telse\r\n\t\t\tp:=buffer\r\n\t\t\tto linebytes do\r\n\t\t\t\tprint @f,p++^,,\" \"\r\n\t\t\tod\r\n\t\t\tprintln @f\r\n\t\tfi\r\n\tod\r\n\tclosefile(f)\r\n\treturn 1\r\nend\r\n\r\nglobal function bmrotate(bm, angle)=\r\n\tcase angle\r\n\twhen 0 then return bmdupl(bm)\r\n\twhen -90 then return bmrotleft90(bm)\r\n\twhen +90 then return bmrotright90(bm)\r\n\twhen 180 then return rot180(bm)\r\n\tesac\r\n\treturn bmunimpl(\"bmrotate by \"+tostr(angle))\r\nend\r\n\r\nglobal function bmrotleft90(bm)=\r\n\tcase bm.pixelbits\r\n\twhen 8 then return rotleft90_8(bm)\r\n\twhen 24 then return rotleft90_24(bm)\r\n\twhen 32 then return bmunimpl(\"ROTLEFT90/32\")\r\n\tesac\r\n\treturn nil\r\nend\r\n\r\nglobal function bmrotright90(bm)=\r\n\tcase bm.pixelbits\r\n\twhen 8 then return rotright90_8(bm)\r\n\twhen 24 then return rotright90_24(bm)\r\n\twhen 32 then return bmunimpl(\"ROTRIGHT90/32\")\r\n\tesac\r\n\treturn nil\r\nend\r\n\r\nglobal function rot180(bm)=\r\n\tnewbm1:=bmfliphoz(bm)\r\n\tnewbm2:=bmflipvert(newbm1)\r\n\tbmfree(newbm1)\r\n\treturn newbm2\r\nend\r\n\r\nfunction rotleft90_8(bm)=\r\n\tw:=bm.dimx\r\n\th:=bm.dimy\r\n\tlinebytes:=bm.linebytes\r\n\r\n\tnewbm:=bmcreate(8,h,w)\r\n\r\n\tfor y:=0 to w-1 do\r\n\t\tq:=bmgetptr(bm,w-y-1,0)\r\n\t\tp:=bmgetrowptr(newbm,y)\r\n\r\n\t\tto h do\r\n\t\t\tp++^:=q^\r\n!\t\t\tq:=q+w\r\n\t\t\tq:=q+linebytes\r\n\t\tod\r\n\tod\r\n\r\n\tbmduplpalette(newbm,bm)\r\n\treturn newbm\r\nend\r\n\r\nfunction rotright90_8(bm)=\r\n\tw:=bm.dimx\r\n\th:=bm.dimy\r\n\tlinebytes:=bm.linebytes\r\n\r\n\tnewbm:=bmcreate(8,h,w)\r\n\r\n\tfor y:=0 to w-1 do\r\n\t\tq:=bmgetptr(bm,y,h-1)\r\n\t\tp:=bmgetrowptr(newbm,y)\r\n\r\n\t\tto h do\r\n\t\t\tp++^:=q^\r\n\t\t\tq:=q-linebytes\r\n\t\tod\r\n\tod\r\n\r\n\tbmduplpalette(newbm,bm)\r\n\treturn newbm\r\nend\r\n\r\n!function rotleft90_24(bm)=\r\n!\tnewbm:=bmcreate(24,bm.dimy,bm.dimx)\r\n!\r\n!\txform:=new(array,ws_point,3)\r\n!\txform[1].y:=bm.dimx\r\n!\txform[3].x:=bm.dimy\r\n!\txform[3].y:=bm.dimx\r\n!\r\n!\tplgblt(newbm.gdi.hdc,&xform, bm.gdi.hdc,0,0,bm.dimx,bm.dimy, nil,0,0)\r\n!\r\n!\treturn newbm\r\n!end\r\n\r\nfunction rotleft90_24(bm)=\r\n\tw:=bm.dimx\r\n\th:=bm.dimy\r\n\r\n\tnewbm:=bmcreate(24,h,w)\r\n\r\n\tfor y:=0 to w-1 do\r\n\t\tq:=bmgetptr(bm,w-y-1,0)\r\n\t\tp:=bmgetrowptr(newbm,y)\r\n\r\n\t\tto h do\r\n\t\t\tp++^:=q^\r\n\t\t\tp++^:=(q+1)^\r\n\t\t\tp++^:=(q+2)^\r\n\t\t\tq:=q+bm.linebytes\r\n\t\tod\r\n\tod\r\n\r\n\treturn newbm\r\nend\r\n\r\n!function rotright90_24(bm)=\r\n!\tnewbm:=bmcreate(24,bm.dimy,bm.dimx)\r\n!\r\n!\txform:=new(array,ws_point,3)\r\n!\txform[1].X:=bm.dimy\r\n!\txform[2].x:=bm.dimy\r\n!\txform[2].y:=bm.dimx\r\n!\r\n!\tplgblt(newbm.gdi.hdc,&xform, bm.gdi.hdc,0,0,bm.dimx,bm.dimy, nil,0,0)\r\n!\r\n!\treturn newbm\r\n!end\r\n\r\nfunction rotright90_24(bm)=\r\n\tw:=bm.dimx\r\n\th:=bm.dimy\r\n\r\n\tnewbm:=bmcreate(24,h,w)\r\n\r\n\tfor y:=0 to w-1 do\r\n\t\tq:=bmgetptr(bm,y,h-1)\r\n\t\tp:=bmgetrowptr(newbm,y)\r\n\r\n\t\tto h do\r\n\t\t\tp++^:=q^\r\n\t\t\tp++^:=(q+1)^\r\n\t\t\tp++^:=(q+2)^\r\n\t\t\tq:=q-bm.linebytes\r\n\t\tod\r\n\tod\r\n\r\n\treturn newbm\r\nend\r\n\r\nfunction rotate8(bm,angle)=\r\nreturn bmunimpl(\"rotate8\")\r\nend\r\n\r\nglobal function bmfliphoz(bm)=\r\n\tcase bm.pixelbytes\r\n    when 1 then return fliphoz8(bm)\r\n    when 3 then return fliphoz24(bm)\r\n    when 4 then return fliphoz32(bm)\r\n\tesac\r\n\treturn nil\r\nend\r\n\r\nfunction fliphoz8(bm)=\r\n\tnewbm:=bmdupl(bm)\r\n\r\n\tw:=newbm.dimx\r\n\th:=newbm.dimy\r\n\tbuffer:=makeref(malloc(bm.linebytes),byte)\r\n\r\n\tfor y:=0 to h-1 do\r\n\t\tp:=bmgetrowptr(newbm,y)\r\n\t\tq:=p+w-1\r\n\t\tfor x:=0 to w%2 do\r\n\t\t\tt:=p^\r\n\t\t\tp^:=q^\r\n\t\t\tq^:=t\r\n\t\t\t++p; --q\r\n\t\tod\r\n\tod\r\n\r\n\treturn newbm\r\nend\r\n\r\nfunction fliphoz24(bm)=\r\n\tnewbm:=bmdupl(bm)\r\n\r\n\tw:=newbm.dimx\r\n\th:=newbm.dimy\r\n\tbuffer:=makeref(malloc(bm.linebytes),byte)\r\n\r\n\tfor y:=0 to h-1 do\r\n\t\tp:=bmgetrowptr(newbm,y)\r\n\t\tmemcpy(buffer,p,bm.linebytes)\r\n\t\tq:=buffer+(w-1)*3\r\n\r\n\t\tto w do\r\n\t\t\tp++^:=q++^\r\n\t\t\tp++^:=q++^\r\n\t\t\tp++^:=q^\r\n\r\n\t\t\tq:=q-5\r\n\t\tod\r\n\tod\r\n\r\n\treturn newbm\r\nend\r\n\r\nfunction fliphoz32(bm)=\r\nreturn bmunimpl(\"fliphoz_32\")\r\nend\r\n\r\nglobal function bmflipvert(bm)=\r\n\tnewbm:=bmdupl(bm)\r\n\r\n\tw:=newbm.dimx\r\n\th:=newbm.dimy\r\n\tn:=bm.linebytes\r\n\tbuffer:=makeref(malloc(n),byte)\r\n\r\n\tfor y:=0 to h%2 do\r\n\t\tp:=bmgetrowptr(newbm,y)\r\n\t\tq:=bmgetrowptr(newbm,h-1-y)\r\n!\r\n\t\tmemcpy(buffer,p,n)\r\n\t\tmemcpy(p,q,n)\r\n\t\tmemcpy(q,buffer,n)\r\n\tod\r\n\tfree(buffer)\r\n\r\n\treturn newbm\r\nend\r\n\r\nglobal function bmrepeat(bm,cols,rows)=\r\n\tw:=bm.dimx\r\n\th:=bm.dimy\r\n\tnewbm:=bmcreate(bm.pixelbits, w*cols, h*rows)\r\n\tlinebytes:=bm.linebytes\r\n\r\n\tfor y:=0 to h-1 do\r\n\t\ts:=bmgetrowptr(bm,y)\r\n\t\tfor r:=0 to rows-1 do\r\n\t\t\tfor c:=0 to cols-1 do\r\n\t\t\t\tmemcpy(bmgetptr(newbm,c*w,r*h+y),s,linebytes)\r\n\t\t\tod\r\n\t\tod\r\n\tod\r\n\r\n\tif bm.pixelbits=8 then\r\n\t\tbmduplpalette(newbm,bm)\r\n\tfi\r\n\r\n\treturn newbm\r\nend\r\n\r\nglobal function bmscale(bm, sx,?sy)=\r\n\tif sy.isvoid then sy:=sx fi\r\n\tcase bm.pixelbits\r\n\twhen 8 then return scalex8(bm,sx,sy)\r\n\twhen 24,32 then return scalex24(bm,sx,sy)\r\n\tesac\r\n\treturn nil\r\nend\r\n\r\nfunction scalex8(bm,sx,sy)=\r\n\tw:=bm.dimx\r\n\th:=bm.dimy\r\n\r\n\tneww:=int(round(w*sx))\r\n\tnewh:=int(round(h*sy))\r\n\r\n\tnewbm:=bmcreate(24, neww,newh)\r\n\treturn nil when not newbm\r\n\r\n\tbm24:=bmtorgb(bm,24)\r\n\r\n\tstretchblt(newbm.gdi.hdc,0,0,neww,newh,bm24.gdi.hdc,0,0,w,h, srccopy)\r\n\r\n\tif bm.paltype=greyscale_pal then\r\n\t\tnewbm8:=bmgetplane(newbm,\"R\")\r\n\telse\r\n\t\tnewbm8:=bmtopal(newbm)\r\n\tfi\r\n\tbmfree(newbm)\r\n\t\r\n\treturn newbm8\r\nend\r\n\r\nfunction scalex24(bm,sx,sy)=\r\n\tw:=bm.dimx\r\n\th:=bm.dimy\r\n\r\n\tneww:=int(round(w*sx))\r\n\tnewh:=int(round(h*sy))\r\n\r\n\tif neww<8 or newh<8 then return nil fi\r\n\r\n\tnewbm:=bmcreate(bm.pixelbits, neww,newh)\r\n\tif newbm then\r\n\t\tstretchblt(newbm.gdi.hdc,0,0,neww,newh,bm.gdi.hdc,0,0,w,h, srccopy)\r\n\tfi\r\n\r\n\treturn newbm\r\nend\r\n\r\nfunction bmscaleupi8(bm,sx,sy)=\r\nreturn bmunimpl(\"bmscaleupi8\")\r\nend\r\n\r\nfunction bmscaleupi24(bm,sx,sy)=\r\nreturn bmunimpl(\"bmscaleupi24\")\r\nend\r\n\r\nfunction bmscaleupi32(bm,sx,sy)=\r\nreturn bmunimpl(\"bmscaleupi32\")\r\nend\r\n\r\nfunction bmscaledowni8(bm,sx,sy)=\r\nreturn bmunimpl(\"bmscaledowni8\")\r\nend\r\n\r\nfunction bmscaledowni24(bm,sx,sy)=\r\nreturn bmunimpl(\"bmscaledowni24\")\r\nend\r\n\r\nfunction bmscaledowni32(bm,sx,sy)=\r\nreturn bmunimpl(\"bmscaledowni32\")\r\nend\r\n\r\nglobal function bmneg(bm)=\r\n\tnewbm:=bmdupl(bm)\r\n\r\n\tdx:=newbm.dimx-1\r\n\tdy:=newbm.dimy-1\r\n\tn:=newbm.linebytes\r\n\tdo32:=0\r\n\tif n rem 4=0 then\r\n\t\tdo32:=1\r\n\t\tn:=n%4\r\n\tfi\r\n\r\n\tfor y:=0 to dy do\r\n\t\tif do32 then\r\n\t\t\tp:=makeref(bmgetrowptr(newbm,y),int32)\r\n\t\t\tto n do\r\n\t\t\t\tp++^ := p^ ixor 0xFFFFFFFF\r\n\t\t\tod\r\n\t\telse\r\n\t\t\tp:= bmgetrowptr(newbm,y)\r\n\t\t\tto n do\r\n\t\t\t\tp++^ := p^ ixor 255\r\n\t\t\tod\r\n\t\tfi\r\n\tod\r\n\treturn newbm\r\nend\r\n\r\nglobal function bmmap(bm,map, channels=\"RGB\")=\r\n\tif channels=\"\" then channels:=\"RGB\" fi\r\n\r\n\tcase bm.pixelbits\r\n\twhen 8 then\r\n\t\treturn mapall(bm,map)\r\n\twhen 24 then\r\n\t\tif channels=\"RGB\" then\r\n\t\t\treturn mapall(bm,map)\r\n\t\tfi\r\n\t\treturn mapchan_24(bm,map,channels,0)\r\n\twhen 32 then\r\n\t\tif channels=\"RGBA\" then\r\n\t\t\treturn mapall(bm,map)\r\n\t\tfi\r\n\t\treturn mapchan_24(bm,map,channels,1)\r\n\tesac\r\n\r\n\treturn nil\r\nend\r\n\r\nfunction mapall(bm,map)=\r\n\tnewbm:=bmdupl(bm)\r\n\tp:=newbm.pixelptr\r\n\tto newbm.framebytes do\r\n\t\tp^:=map[p^]\r\n\t\t++p\r\n\tod\r\n\treturn newbm\r\nend\r\n\r\nfunction mapchan_24(bm,map,channels,alpha=0)=\r\n\tdored:=\"R\" in channels\r\n\tdogreen:=\"G\" in channels\r\n\tdoblue:=\"B\" in channels\r\n\tdoalpha:=\"A\" in channels\r\n\r\n\tnewbm:=bmdupl(bm)\r\n\r\n\tfor y:=0 to newbm.dimy-1 do\r\n\t\tp:=bmgetrowptr(newbm,y)\r\n\t\tto newbm.dimx do\r\n\t\t\tif doblue then p^:=map[p^] fi\r\n\t\t\t++p\r\n\t\t\tif dogreen then p^:=map[p^] fi\r\n\t\t\t++p\r\n\t\t\tif dored then p^:=map[p^] fi\r\n\t\t\t++p\r\n\t\t\tif alpha then\r\n\t\t\t\tif doalpha then p^:=map[p^] fi\r\n\t\t\t\t++p\r\n\t\t\tfi\r\n\t\tod\r\n\tod\r\n\r\n\treturn newbm\r\nend\r\n\r\n!function mapchan_32(bm,map,channels)=\r\n!return bmunimpl(\"mapchan_32\")\r\n!end\r\n\r\nglobal function bmbright(bm,dx,channels=\"RGB\")=\r\nreturn bmunimpl(\"bmbright\")\r\nend\r\n\r\nglobal function bmcont(bm,x,channels=\"RGB\")=\r\nreturn bmunimpl(\"bmcont\")\r\nend\r\n\r\nglobal function bmgamma(bm,x,channels=\"RGB\")=\r\nreturn bmunimpl(\"bmgamma\")\r\nend\r\n\r\nglobal function bmtogrey(bm,destbits=24)=\r\n\tif destbits=0 then destbits:=bm.pixelbits fi\r\n\tcase bm.pixelbits\r\n\twhen 8 then\r\n\t\tcase destbits\r\n\t\twhen 8 then\r\n\t\t\treturn pal8togrey8(bm)\r\n\t\twhen 24 then\r\n\t\t\tcm:=pal8togrey8(bm)\r\n\t\t\tnewbm:=grey8torgb24(cm)\r\n\t\t\tbmfree(cm)\r\n\t\t\treturn newbm\r\n\t\tesac\r\n\twhen 24,32 then\r\n\t\tcase destbits\r\n\t\twhen 8 then\r\n\t\t\treturn rgb24togrey8(bm)\r\n\t\twhen 24 then\r\n\t\t\tcm:=rgb24togrey8(bm)\r\n\t\t\tnewbm:=grey8torgb24(cm)\r\n\t\t\tbmfree(cm)\r\n\t\t\treturn newbm\r\n\t\tesac\r\n\tesac\r\nCPL =BM.PIXELBITS, =DESTBITS\r\n\treturn bmunimpl(\"bmtogrey bad combos\")\r\n\r\nend\r\n\r\nfunction pal8togrey8(bm)=\r\n\tw:=bm.dimx\r\n\th:=bm.dimy\r\n\r\n\t(rmap, gmap, bmap):=getlumtables()\r\n\r\n\tnewbm:=bmcreate(8,w,h)\r\n\tpal:=bmgetpalette(bm)\r\n\r\n\tfor y:=0 to h-1 do\r\n\t\tp:=bmgetrowptr(newbm,y)\r\n\t\tq:=bmgetrowptr(bm,y)\r\n\r\n\t\tto w do\r\n\t\t\tcolour:=pal[q++^]\r\n\t\t\tr:=colour.[0..7]\r\n\t\t\tg:=colour.[8..15]\r\n\t\t\tb:=colour.[16..23]\r\n\t\t\tp++^:=rmap[r]+gmap[g]+bmap[b]\r\n\t\tod\r\n\tod\r\n\r\n\treturn newbm\r\nend\r\n\r\nfunction pal8togrey24(bm)=\r\nreturn bmunimpl(\"pal8togrey24\")\r\nend\r\n\r\nfunction rgb24togrey8(bm)=\r\n!does 24/32 bits\r\n\tqincr:=(bm.pixelbits=32)\r\n\tw:=bm.dimx\r\n\th:=bm.dimy\r\n\r\n\t(rmap, gmap, bmap):=getlumtables()\r\n\r\n\tnewbm:=bmcreate(8,w,h)\r\n\r\n\tfor y:=0 to h-1 do\r\n\t\tp:=bmgetrowptr(newbm,y)\r\n\t\tq:=bmgetrowptr(bm,y)\r\n\r\n\t\tto w do\r\n\t\t\tb:=q++^; g:=q++^; r:=q++^\r\n\t\t\tp++^:=rmap[r]+gmap[g]+bmap[b]\r\n\t\t\tq:=q+qincr\r\n\t\tod\r\n\tod\r\n\r\n\treturn newbm\r\nend\r\n\r\nfunction rgb24togrey24(bm)=\r\nreturn bmunimpl(\"rgb24togrey24\")\r\nend\r\n\r\nglobal function bmtorgb(bm,destbits=24)=\r\n\tif destbits=0 then destbits:=24 fi\r\n\tcase bm.pixelbits\r\n\twhen destbits then\r\n\t\treturn bmdupl(bm)\r\n\r\n\twhen 8 then\r\n\t\tcase destbits\r\n\t\twhen 8 then\r\n\t\t\tbmunimpl(\"8 to 8 bits rgb\")\r\n\t\twhen 24 then\r\n\t\t\tif bm.paltype=greyscale_pal then\r\n\t\t\t\treturn grey8torgb24(bm)\r\n\t\t\telse\r\n\t\t\t\treturn paltorgb24(bm)\r\n\t\t\tfi\r\n\t\tesac\r\n\twhen 24 then\r\n\t\tif destbits=32 then\r\n\t\t\treturn bmrgb24torgb32(bm)\r\n\t\tfi\r\n\twhen 32 then\r\n\t\tif destbits=24 then\r\n\t\t\treturn bmrgb32torgb24(bm)\r\n\t\tfi\r\n\tesac\r\nCPL =BM.PIXELBITS, =DESTBITS\r\n\treturn bmunimpl(\"bmtorgb bad combos\")\r\nend\r\n\r\nfunction paltorgb24(bm)=\r\n\tw:=bm.dimx\r\n\th:=bm.dimy\r\n\r\n\tnewbm:=bmcreate(24,w,h)\r\n\tpal:=bmgetpalette(bm)\r\n\r\n\tfor y:=0 to h-1 do\r\n\t\tp:=bmgetrowptr(newbm,y)\r\n\t\tq:=bmgetrowptr(bm,y)\r\n\r\n\t\tto w do\r\n\t\t\tcolour:=pal[q++^]\r\n\t\t\tr:=colour.[0..7]\r\n\t\t\tg:=colour.[8..15]\r\n\t\t\tb:=colour.[16..23]\r\n\r\n\t\t\tp++^:=b\r\n\t\t\tp++^:=g\r\n\t\t\tp++^:=r\r\n\t\tod\r\n\tod\r\n\r\n\treturn newbm\r\nend\r\n\r\nfunction grey8torgb24(bm)=\r\n\tw:=bm.dimx\r\n\th:=bm.dimy\r\n\r\n\tnewbm:=bmcreate(24,w,h)\r\n\r\n\tfor y:=0 to h-1 do\r\n\t\tp:=bmgetrowptr(newbm,y)\r\n\t\tq:=bmgetrowptr(bm,y)\r\n\r\n\t\tto w do\r\n\t\t\tlum:=q++^\r\n\t\t\tp++^:=lum\r\n\t\t\tp++^:=lum\r\n\t\t\tp++^:=lum\r\n\t\tod\r\n\tod\r\n\r\n\treturn newbm\r\nend\r\n\r\nglobal function bmrgb24torgb32(bm)=\r\n\tw:=bm.dimx\r\n\th:=bm.dimy\r\n\tnewbm:=bmcreate(32,w,h)\r\n\r\n\tfor y:=0 to h-1 do\r\n\t\tq:=bmgetrowptr(bm,y)\r\n\t\tp:=bmgetrowptr(newbm,y)\r\n\t\tto w do\r\n\t\t\tp++^:=q++^\r\n\t\t\tp++^:=q++^\r\n\t\t\tp++^:=q++^\r\n\t\t\tp++^:=128\r\n\t\tod\r\n\tod\r\n\treturn newbm\r\nend\r\n\r\nglobal function bmrgb32torgb24(bm)=\r\n\tw:=bm.dimx\r\n\th:=bm.dimy\r\n\tnewbm:=bmcreate(24,w,h)\r\n\r\n\tfor y:=0 to h-1 do\r\n\t\tq:=bmgetrowptr(bm,y)\r\n\t\tp:=bmgetrowptr(newbm,y)\r\n\t\tto w do\r\n\t\t\tp++^:=q++^\r\n\t\t\tp++^:=q++^\r\n\t\t\tp++^:=q++^\r\n\t\t\tq++\r\n\t\tod\r\n\tod\r\n\treturn newbm\r\nend\r\n\r\nglobal function bmtopal(bm)=\r\n\tif bm.pixelbits=8 then return bmdupl(bm) fi\r\n\tqincr:=(bm.pixelbits=32)\r\n\tw:=bm.dimx\r\n\th:=bm.dimy\r\n\r\n\tnewbm:=bmcreate(8,w,h)\r\n\r\n\tpal:=new(array,int32,0..255)\r\n\r\n!create special palette mapping for rrrgggbb\r\n\tfor r:=0 to 7 do\r\n\t\tfor g:=0 to 7 do\r\n\t\t\tfor b:=0 to 3 do\r\n\t\t\t\tindex:=r<<5+g<<2+b\r\n!\t\t\t\tpal[index]:=r<<5+g<<13+b<<18\r\n\t\t\t\tpal[index]:=r<<5+g<<13+b<<22\r\n\t\t\tod\r\n\t\tod\r\n\tod\r\n\tbmputpalette(newbm,pal)\r\n\tbm.paltype:=colour_pal\r\n\r\n\tfor y:=0 to h-1 do\r\n\t\tp:=bmgetrowptr(newbm,y)\r\n\t\tq:=bmgetrowptr(bm,y)\r\n\r\n!noise:=-16..16\r\n!noise:=-8..8\r\n\r\n\t\tto w do\r\n\t\t\tb:=q++^; g:=q++^; r:=q++^\r\n\r\n!\t\t\tr+:=clamp(random(noise),0,255)\r\n!\t\t\tg+:=clamp(random(noise),0,255)\r\n!\t\t\tb+:=clamp(random(noise),0,255)\r\n!\r\n\t\t\tp++^:=r>>5<<5 + g>>5<<2 + b>>6\r\n\t\t\tq:=q+qincr\r\n\t\tod\r\n\tod\r\n\r\n\treturn newbm\r\n\r\nend\r\n\r\nglobal function bmsplittorgb(bm,greydest=1)=\r\n# split 24-bit bitmap into three separate 8-bit planes\r\n# return 3 new bitmaps in the order red, green, blue\r\n# return () on error\r\n# dogreyscale=1 for each image to have a greyscale palette. Otherwise\r\n# the red image will be shades of red, etc\r\n\r\n\tif bm.pixelbits<24 then\r\n\t\treturn ()\r\n\tfi\r\n\tchannels:=bm.pixelbytes\r\n\r\n\tw:=bm.dimx\r\n\th:=bm.dimy\r\n\r\n\tpal:=new(array,int32,0..255)\r\n\timages:=()\r\n\r\n\tfor offset:=channels-1 downto 0 do\r\n\r\n\t\tnewbm:=bmcreate(8,w,h)\r\n\r\n\t\tfor y:=0 to h-1 do\r\n\t\t\tq:=bmgetrowptr(bm,y)+offset\r\n\t\t\tp:=bmgetrowptr(newbm,y)\r\n\t\t\tto w do\r\n\t\t\t\tp++^:=q^\r\n\t\t\t\tq:=q+channels\r\n\t\t\tod\r\n\t\tod\r\n\r\n\t\tif not greydest then\r\n\t\t\tcolour:=0\r\n\t\t\tincr:=(3-offset|0x00'00'01,0x00'01'00,0x01'00'00|0x01'01'01)\r\n\t\t\tfor i:=0 to 255 do\r\n\t\t\t\tpal[i]:=colour\r\n\t\t\t\tcolour+:=incr\r\n\t\t\tod\r\n\t\t\tbmputpalette(newbm,pal)\r\n\t\t\tnewbm.paltype:=tinted_pal\r\n\t\tfi\r\n\r\n\t\timages append:=newbm\r\n\tod\r\n\r\n!image order is r,g,b, or a,r,g,b\r\n\tif images.len=4 then\r\n\t\treturn (images[2],images[3],images[4],images[1])\r\n\telse\r\n\t\treturn images\r\n\tfi\r\nend\r\n\r\nglobal function bmsplittoyuv(bm)=\r\n# split 24-bit bitmap into three separate 8-bit planes\r\n# return 3 new bitmaps in the order y, u, v\r\n# return () on error\r\n\r\n\tneedfree:=0\r\n\tcase bm.pixelbits\r\n\twhen 24 then\r\n\twhen 32 then\r\n\t\tbm:=bmtorgb(bm,24)\r\n\t\tneedfree:=1\r\n\telse\r\n\t\treturn nil\r\n\tesac\r\n\r\n!get y plane first with existing routine\r\n\tgreybm:=bmtogrey(bm,8)\r\n\r\n\tw:=bm.dimx\r\n\th:=bm.dimy\r\n\r\n!equations used are:\r\n! u:=int(round(0.492*(b-y)+128)\r\n! v:=int(round(0.702*(r-y)+128)\r\n!b-y and r-y will be in range +/- 255\r\n\r\n\tumap:=new(list,-255..255)\r\n\tvmap:=new(list,-255..255)\r\n\tfor i:=-255 to 255 do\r\n\t\tumap[i]:=int(round(0.492*(i)+128))\r\n\t\tvmap[i]:=int(round(0.702*(i)+128))\r\n\tod\r\n\r\n\tubm:=bmcreate(8,w,h)\r\n\tvbm:=bmcreate(8,w,h)\r\n\tfor c:=1 to 2 do\r\n\t\tif c=1 then\r\n\t\t\toffset:=0\r\n\t\t\tmap:=umap\r\n\t\telse\r\n\t\t\toffset:=2\r\n\t\t\tmap:=vmap\r\n\t\tfi\r\n\r\n\t\tfor yy:=0 to h-1 do\r\n\t\t\tpy:=bmgetrowptr(greybm,yy)\r\n\t\t\tp:=bmgetrowptr(bm,yy)\t\t\t!point to bgr pixels in original\r\n\r\n\t\t\tpu:=bmgetrowptr(ubm,yy)\r\n\t\t\tpv:=bmgetrowptr(vbm,yy)\r\n\t\t\tto w do\r\n\t\t\t\ty:=py++^\r\n\t\t\t\tr:=(p+2)^\r\n\t\t\t\tb:=p^\r\n\t\t\t\tpu++^:=umap[b-y]\r\n!CPL =B,=Y,=PV,=VMAP.TYPE\r\n\t\t\t\tpv++^:=vmap[r-y]\r\n\r\n\t\t\t\tp:=p+3\r\n\t\t\tod\r\n\t\tod\r\n\tod\r\n\r\n!create special greyscale for u/v images, since point of zero colour\r\n!info has been offset to +128\r\n\tpal:=new(array,int32,0..256)\r\n\tcolour:=0\r\n\tpal[128]:=0\r\n\tfor i:=1 to 127 do\r\n\t\tcolour+:=0x020202\r\n\t\tpal [i+128]:=colour\r\n\t\tpal [128-i]:=colour\r\n\tod\r\n\tpal[256]:=uv_pal\r\n\tbmputpalette(ubm,pal)\r\n\tbmputpalette(vbm,pal)\r\n\r\n\tif needfree then\r\n\t\tbmfree(bm)\r\n\tfi\r\n\r\n\treturn (greybm,ubm,vbm)\r\nend\r\n\r\nglobal function bmgetplane(bm,plane)=\r\n# plane is one of \"R\",\"G\",\"B\"\r\n# extract given plane of a 24-bit bitmaps into a single 8-bit greyscale image\r\n# Return new image\r\n\r\n\tincr:=bm.pixelbytes\r\n\tif plane.len<>1 or bm.pixelbytes<3 then\r\n\t\treturn nil\r\n\tfi\r\n\r\n\tcase asc(plane)\r\n\twhen 'R' then offset:=2\r\n\twhen 'G' then offset:=1\r\n\twhen 'B' then offset:=0\r\n\twhen 'A' then offset:=3\r\n\telse return nil\r\n\tesac\r\n\r\n\tw:=bm.dimx\r\n\th:=bm.dimy\r\n\tnewbm:=bmcreate(8,w,h)\r\n\r\n\tfor y:=0 to h-1 do\r\n\t\tq:=bmgetrowptr(bm,y)+offset\r\n\t\tp:=bmgetrowptr(newbm,y)\r\n\t\tto w do\r\n\t\t\tp++^:=q^\r\n\t\t\tq:=q+incr\r\n\t\tod\r\n\tod\r\n\r\n\treturn newbm\r\nend\r\n\r\nglobal function bmjoinrgb(redbm,greenbm,bluebm,alphabm=nil)=\r\n\r\n\tw:=redbm.dimx\r\n\th:=redbm.dimy\r\n\r\n\tnewbm:=bmcreate((alphabm|32|24),w,h)\r\n\r\n\tfor y:=0 to h-1 do\r\n\t\tp:=bmgetrowptr(newbm,y)\r\n\r\n\t\tr:=bmgetrowptr(redbm,y)\r\n\t\tg:=bmgetrowptr(greenbm,y)\r\n\t\tb:=bmgetrowptr(bluebm,y)\r\n\r\n\t\tif alphabm then\r\n\t\t\ta:=bmgetrowptr(alphabm,y)\r\n\t\t\tto w do\r\n\t\t\t\tp++^:=b++^\r\n\t\t\t\tp++^:=g++^\r\n\t\t\t\tp++^:=r++^\r\n\t\t\t\tp++^:=a++^\r\n\t\t\tod\r\n\t\telse\r\n\t\t\tto w do\r\n\t\t\t\tp++^:=b++^\r\n\t\t\t\tp++^:=g++^\r\n\t\t\t\tp++^:=r++^\r\n\t\t\tod\r\n\t\tfi\r\n\tod\r\n\r\n\treturn newbm\r\nend\r\n\r\nglobal function bmjoinyuv(ybm,ubm,vbm)=\r\n# combine y, u, v separations into a single rgb image\r\n# return new bitmap, or nil\r\n\r\n\tif ybm.pixelbits<>8 then\r\n\t\treturn nil\r\n\tfi\r\n\r\n\tw:=ybm.dimx\r\n\th:=ybm.dimy\r\n\r\n\tv1425map:=new(list,0..255)\r\n\tv726map:=new(list,0..255)\r\n\tu395map:=new(list,0..255)\r\n\tu2032map:=new(list,0..255)\r\n\r\n\tfor i:=0 to 255 do\r\n\t\tv1425map[i]:=int(round(1.425*(i-128)))\r\n\t\tv726map[i]:=int(round(0.726*(i-128)))\r\n\t\tu395map[i]:=int(round(0.395*(i-128)))\r\n\t\tu2032map[i]:=int(round(2.032*(i-128)))\r\n\tod\r\n\r\n\tnewbm:=bmcreate(24,w,h)\r\n\r\n\tfor yy:=0 to h-1 do\r\n\t\tp:=bmgetrowptr(newbm,yy)\r\n\t\tqy:=bmgetrowptr(ybm,yy)\r\n\t\tqu:=bmgetrowptr(ubm,yy)\r\n\t\tqv:=bmgetrowptr(vbm,yy)\r\n\r\n!\t\tto w do\r\n\t\tFOR X:=0 TO W-1 DO\r\n\t\t\ty:=qy++^\r\n\t\t\tr:=y+v1425map[qv^]\r\n\t\t\tg:=y-u395map[qu^]-v726map[qv^]\r\n\t\t\tb:=y+u2032map[qu^]\r\n\t\t\t++qu\r\n\t\t\t++qv\r\n\t\t\tp++^:=clamp(b,0,255)\r\n\t\t\tp++^:=clamp(g,0,255)\r\n\t\t\tp++^:=clamp(r,0,255)\r\n\t\tod\r\n\tod\r\n\treturn newbm\r\nend\r\n\r\nglobal function bmblur(bm,n)=\r\n\tcase bm.pixelbits\r\n\twhen 8 then\r\n\t\treturn blur8(bm,n)\r\n\twhen 24 then\r\n\t\treturn blur24(bm,n)\r\n\twhen 32 then\r\n\t\treturn blur32(bm,n)\r\n\tesac\r\n\treturn nil\r\nend\r\n\r\nfunction blur8(bm,n)=\r\n\tshift:=shifts{n,1}\r\n\r\n\tnewbm:=bmdupl(bm)\r\n\tiblurhoz8(newbm,n)\r\n\r\n\tnewbm2:=rotleft90_8(newbm)\r\n\tiblurhoz8(newbm2,n)\r\n\r\n\tnewbm3:=rotright90_8(newbm2)\r\n\tbmfree(newbm)\r\n\tbmfree(newbm2)\r\n\r\n\tbmduplpalette(newbm3,bm)\r\n\treturn newbm3\r\nend\r\n\r\nfunction blur24(bm,n)=\r\n\t(r,g,b):=bmsplittorgb(bm)\r\n\r\n\tr2:=bmblur(r,n)\r\n\tg2:=bmblur(g,n)\r\n\tb2:=bmblur(b,n)\r\n\r\n\tnewbm:=bmjoinrgb(r2,g2,b2)\r\n\tbmfree(r2)\r\n\tbmfree(g2)\r\n\tbmfree(b2)\r\n\r\n\treturn newbm\r\nend\r\n\r\nfunction blur32(bm,n)=\r\nreturn bmunimpl(\"blur32\")\r\nend\r\n\r\nproc iblurhoz8(bm,n)=\r\n\tshift:=shifts{n,1}\r\n\r\n\tw:=bm.dimx\r\n\th:=bm.dimy\r\n\r\n\tfor y:=0 to h-1 do\r\n\t\tp:=bmgetrowptr(bm,y)\r\n\t\tto w-n-1 do\r\n\t\t\tsum:=0\r\n\t\t\tq:=p\r\n\t\t\tto n do\r\n\t\t\t\tsum+:=q++^\r\n\t\t\tod\r\n\t\t\tp++^:=sum>>shift\r\n\t\tod\r\n\tod\r\nend\r\n\r\nfunction blurhoz24(bm,n)=\r\nreturn bmunimpl(\"blurhoz24\")\r\nend\r\n\r\nfunction blurhoz32(bm,n)=\r\nreturn bmunimpl(\"blurhoz32\")\r\nend\r\n\r\nglobal function bmsharpen(bm,n=0)=\r\n\tcase bm.pixelbits\r\n\twhen 8 then\r\n\t\treturn sharpen8(bm,n)\r\n\twhen 24 then\r\n\t\treturn sharpen24(bm,n)\r\n\twhen 32 then\r\n\t\treturn sharpen32(bm,n)\r\n\tesac\r\n\treturn nil\r\nend\r\n\r\nglobal function sharpen8(bm,n)=\r\n!blur in-place horizontally by averaging each set of n pixels\r\n!n must be multiple of 2 from 2 to 64\r\n!return new modified image\r\n\r\n\tw:=bm.dimx\r\n\th:=bm.dimy\r\n\r\n\tnewbm:=bmdupl(bm)\r\n\r\n\tfor y:=1 to h-2 do\r\n\t\tp:=bmgetptr(newbm,1,y)\r\n\r\n\t\tq:=bmgetptr(bm,1,y-1)\r\n\t\tr:=bmgetptr(bm,1,y)\r\n\t\ts:=bmgetptr(bm,1,y+1)\r\n\r\n\t\tto w-2 do\r\n!\t\t\tabcdefghij\r\n\t\t\ta:=(q-1)^\r\n\t\t\tb:=q^\r\n\t\t\tc:=(q+1)^\r\n\t\t\td:=(r-1)^\r\n\t\t\te:=r^\r\n\t\t\tf:=(r+1)^\r\n\t\t\tg:=(s-1)^\r\n\t\t\th:=s^\r\n\t\t\ti:=(s+1)^\r\n\r\n! a b c\r\n! d e f\r\n! g h i\r\n!\t\t\tsum:=e*4-b-d-f-h\r\n!\t\t\tp^:=clamp(p^+sum%4,0,255)\r\n\r\n\t\t\tsum:=e*8-a-b-c-d-f-g-h-i\r\n\t\t\tp^:=clamp(p^+sum%8,0,255)\r\n\r\n!\t\t\tsum:=e*4+c+g+i-2*(b+d+f+h)\r\n!\t\t\tp^:=clamp(p^+sum%4,0,255)\r\n\r\n\t\t\t++p\r\n\t\t\t++q\r\n\t\t\t++r\r\n\t\t\t++s\r\n\t\tod\r\n\tod\r\n\r\n\treturn newbm\r\n\r\nend\r\n\r\nglobal function sharpen24(bm,n)=\r\n\t(r,g,b):=bmsplittorgb(bm)\r\n\r\n\tr2:=bmsharpen(r,n)\r\n\tg2:=bmsharpen(g,n)\r\n\tb2:=bmsharpen(b,n)\r\n\r\n\tnewbm:=bmjoinrgb(r2,g2,b2)\r\n\tbmfree(r2)\r\n\tbmfree(g2)\r\n\tbmfree(b2)\r\n\r\n\treturn newbm\r\nend\r\n\r\nglobal function sharpen32(bm,n)=\r\nreturn bmunimpl(\"bmsharpen32\")\r\nend\r\n\r\nfunction getlumtables=\r\n\trmap:=makescalemap(0.299)\r\n\tgmap:=makescalemap(0.587)\r\n\tbmap:=makescalemap(0.111)\r\n\treturn (rmap, gmap, bmap)\r\nend\r\n\r\nglobal function bmmean(bm)=\r\n\tnewbm:=bmdupl(bm)\r\n\r\n\tdx:=newbm.dimx-1\r\n\tdy:=newbm.dimy-1\r\n\tn:=newbm.linebytes\r\n\r\n\tallpix:=0\r\n\tsum:=0\r\n\r\n\tfor y:=0 to dy do\r\n\t\tp:= bmgetrowptr(newbm,y)\r\n\t\tto n do\r\n\t\t\tsum+:=p^\r\n\t\t\t++p\r\n\t\t\t++allpix\r\n\t\tod\r\n\tod\r\n\r\nCPL =ALLPIX\r\nCPL =SUM\r\nCPL =SUM/ALLPIX\r\n\taverage:=int(sum/allpix)\r\n\r\n\tfor y:=0 to dy do\r\n\t\tp:= bmgetrowptr(newbm,y)\r\n\t\tto n do\r\n\t\t\tp++^:=average\r\n\t\tod\r\n\tod\r\n\r\n\treturn newbm\r\nend\r\n\r\n"
};

/* PROCDEFS */
// START
void start(void) {
    int64_t stopcode;
    int64_t filetype;
    uint8_t *  outputfile;
    qq_getinputoptions(&filetype);
    if ((filetype == (int64_t)2)) {
        outputfile = mlib_pcm_copyheapstring(mlib_changeext(qq_inputfile,(uint8_t*)"pc"));
        qci_qcompiler_prod(qq_inputfile,outputfile,var_decls_dointlibs,(int64_t)0);
        qq_inputfile = outputfile;
        if (!!(qq_fcompile)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"STOPPING AFTER COMPILING",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            exit(0);
        };
        filetype = (int64_t)1;
    };
    if (!!(var_decls_fverbose)) {
        qq_showcaption();
    };
    stopcode = pci_runpcl(qq_inputfile,filetype);
    if ((stopcode < (int64_t)0)) {
        qci_loaderror(pci_errorcodenames[(stopcode)+4],qq_inputfile);
    };
    exit(stopcode);
}

int main(int nargs, char** args) {
int i;
	msysnewc_nsysparams=nargs;
	if (msysnewc_nsysparams>nargs) {puts("Too many params"); exit(1);}
	for (i=1; i<=nargs; ++i) msysnewc_sysparams[i-1]=(byte*)args[i-1];

	pc_objlib_Dinit();

	start();
	return 0;
}

static void qq_getinputoptions(int64_t * filetype) {
    int64_t paramno;
    int64_t pmtype;
    uint8_t *  ext;
    uint8_t *  name;
    uint8_t *  value;
    uint8_t *  newfile;
    int64_t av_1;
    int64_t sw;
    paramno = (int64_t)2;
    L1 :;
    while (!!((pmtype = mlib_nextcmdparam(&paramno,&name,&value,(uint8_t*)"q")))) {
        if ((pmtype==(int64_t)1)) {
            mlib_convlcstring(name);
            L4 :;
            for (sw=(int64_t)1;sw<=(int64_t)10;sw+=(int64_t)1) {
L5 :;
                if (!!(mlib_eqstring(name,qq_optionnames[(sw)-1]))) {
                    qq_do_option(sw,value);
                    goto L7 ;
                };
L6 :;
            }
            {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((uint8_t*)"Unknown option:",NULL);
                msysnewc_m_print_str(name,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                exit((int64_t)99);
            }L7 :;
            ;
        }else if ((pmtype==(int64_t)2)) {
            if (!!(qq_inputfile)) {
                qci_loaderror((uint8_t*)"Only one input file allowed",(uint8_t*)"");
            };
            qq_inputfile = mlib_pcm_copyheapstring(name);
            goto L3 ;
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"Bad command param",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            exit((int64_t)9);
        };
L2 :;
    }L3 :;
    ;
    if ((qq_inputfile == 0)) {
        qq_showcaption();
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"Usage:",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"\t",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(msysnewc_sysparams[((int64_t)1)-1],NULL);
        msysnewc_m_print_str((uint8_t*)"filename[.pc]",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"\t",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(msysnewc_sysparams[((int64_t)1)-1],NULL);
        msysnewc_m_print_str((uint8_t*)"filename.q",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"\t",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(msysnewc_sysparams[((int64_t)1)-1],NULL);
        msysnewc_m_print_str((uint8_t*)"-help",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit((int64_t)1);
    };
    ext = mlib_extractext(qq_inputfile,(int64_t)0);
    if (!!(mlib_eqstring(ext,(uint8_t*)""))) {
        if (!!(mlib_checkfile((newfile = mlib_changeext(qq_inputfile,(uint8_t*)"q"))))) {
            qq_inputfile = mlib_pcm_copyheapstring(mlib_changeext(qq_inputfile,(uint8_t*)"q"));
            ext = (uint8_t*)"q";
        } else {
            ext = (uint8_t*)"pc";
            qq_inputfile = mlib_pcm_copyheapstring(newfile);
        };
    };
    if (!!(mlib_eqstring(ext,(uint8_t*)"pc"))) {
        (*filetype) = (int64_t)1;
    } else if (!!(mlib_eqstring(ext,(uint8_t*)"q"))) {
        (*filetype) = (int64_t)2;
    } else {
        (*filetype) = (int64_t)2;
    };
    qq_getsyscmdline((paramno - (int64_t)1));
}

static void qq_do_option(int64_t sw,uint8_t * value) {
    if ((sw==(int64_t)1)) {
        pci_dispatch_type = (int64_t)2;
    }else if ((sw==(int64_t)2)) {
        pci_dispatch_type = (int64_t)5;
    }else if ((sw==(int64_t)3)) {
        pci_dispatch_type = (int64_t)5;
        pc_decls_optimiseasm = (int64_t)0;
    }else if ((sw==(int64_t)4)) {
        pci_dispatch_type = (int64_t)3;
    }else if ((sw==(int64_t)5)) {
        pci_dispatch_type = (int64_t)4;
    }else if ((sw==(int64_t)7)) {
        qq_showhelp();
    }else if ((sw==(int64_t)6)) {
        var_decls_fverbose = (int64_t)2;
    }else if ((sw==(int64_t)8)) {
        var_decls_dointlibs = (int64_t)0;
    }else if ((sw==(int64_t)9)) {
        var_decls_fwriteqa = (int64_t)1;
    }else if ((sw==(int64_t)10)) {
        qq_fcompile = (int64_t)1;
    };
}

static void qq_getsyscmdline(int64_t n) {
    int64_t i;
    pci_setcmdparam((int64_t)0,msysnewc_sysparams[((int64_t)1)-1]);
    L8 :;
    for (i=n;i<=msysnewc_nsysparams;i+=(int64_t)1) {
L9 :;
        pci_setcmdparam(((i - n) + (int64_t)1),msysnewc_sysparams[(i)-1]);
L10 :;
    }L11 :;
    ;
}

static void qq_showcaption(void) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"PCL Interpreter",NULL);
    msysnewc_m_print_str((uint8_t*)"25-Jun-2021",NULL);
    msysnewc_m_print_str((uint8_t*)"(",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str(pc_decls_dispatchnames[(pci_dispatch_type)-1],NULL);
    msysnewc_m_print_str((uint8_t*)"no32",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((uint8_t*)")",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static void qq_showhelp(void) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"General usage:",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"\t",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str(msysnewc_sysparams[((int64_t)1)-1],NULL);
    msysnewc_m_print_str((uint8_t*)"[options] filename[.pc]",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"\t",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str(msysnewc_sysparams[((int64_t)1)-1],NULL);
    msysnewc_m_print_str((uint8_t*)"[options] filename.q",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"\tOptions:",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"\t\t-fn           Function table dispatcher (default)",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"\t\t-asm          Fast ASM dispatcher",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"\t\t-debug        Tracing dispatcher",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"\t\t-fdebug       Tracing dispatcher starts on $setdebug(1)",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit((int64_t)0);
}

int64_t msysnewc_m_getdotindex(uint64_t a,int64_t i) {
    return (((int64_t)(a) & ((int64_t)1 << i)) >> i);
}

void msysnewc_m_setdotindex(uint64_t * a,int64_t i,int64_t x) {
    uint32_t *  a32;
    if ((i >= (int64_t)32)) {
        (*a) = (uint64_t)((((int64_t)((*a)) & ~(((int64_t)1 << i))) | (int64_t)(((uint64_t)(x) << i))));
    } else {
        a32 = (uint32_t *)(a);
        (*a32) = (uint64_t)((((int64_t)((uint64_t)((*a32))) & ~(((int64_t)1 << i))) | (int64_t)(((uint64_t)(x) << i))));
    };
}

int64_t msysnewc_m_getdotslice(uint64_t a,int64_t i,int64_t j) {
    if ((i >= j)) {
        return (int64_t)(((a >> j) & ~(((uint64_t)18446744073709551615u << ((i - j) + (int64_t)1)))));
    } else {
        return (int64_t)(((a >> i) & ~(((uint64_t)18446744073709551615u << ((j - i) + (int64_t)1)))));
    };
}

void msysnewc_m_setdotslice(uint64_t * a,int64_t i,int64_t j,uint64_t x) {
    uint64_t mask64;
    uint64_t mask;
    uint32_t *  a32;
    if ((i > j)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"SETDOTSLICE?",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit((int64_t)52);
    };
    if ((j >= (int64_t)32)) {
        mask64 = (~(((uint64_t)18446744073709551615u << ((j - i) + (int64_t)1))) << i);
        (*a) = (((*a) & ~(mask64)) | (x << i));
    } else {
        a32 = (uint32_t *)(a);
        mask = (~(((uint64_t)18446744073709551615u << ((j - i) + (int64_t)1))) << i);
        (*a32) = (((uint64_t)((*a32)) & ~(mask)) | (x << i));
    };
}

int64_t msysnewc_m_get_nprocs(void) {
    return msysnewc__fnnprocs;
}

int64_t msysnewc_m_get_nexports(void) {
    return msysnewc__fnnexports;
}

void * msysnewc_m_get_procname(int64_t n) {
    return (void *)(msysnewc__fnnames[(n)-1]);
}

uint8_t * msysnewc_m_get_procaddr(int64_t n) {
    return (uint8_t *)(msysnewc__fnaddresses[(n)-1]);
}

void * msysnewc_m_get_procexport(int64_t n) {
    return (void *)(&msysnewc__fnexports[(n)-1]);
}

static void msysnewc_pushio(void) {
    if ((msysnewc_niostack >= (int64_t)10)) {
        printf((int8_t *)((uint8_t*)"Too many io levels\n"));
        exit((int64_t)53);
    };
    ++msysnewc_niostack;
    msysnewc_outchan_stack[(msysnewc_niostack)-1] = msysnewc_outchan;
    msysnewc_outdev_stack[(msysnewc_niostack)-1] = msysnewc_outdev;
    msysnewc_fmtstr_stack[(msysnewc_niostack)-1] = msysnewc_fmtstr;
    msysnewc_needgap_stack[(msysnewc_niostack)-1] = (uint64_t)(msysnewc_needgap);
    msysnewc_needgap = (int64_t)0;
    msysnewc_fmtstr = (uint8_t *)(0);
    msysnewc_outchan = 0;
}

void msysnewc_m_print_startfile(void * dev) {
    msysnewc_pushio();
    msysnewc_outchan = dev;
    if (!!(dev)) {
        msysnewc_outdev = (int64_t)2;
    } else {
        msysnewc_outdev = (int64_t)1;
    };
}

void msysnewc_m_print_startstr(uint8_t * s) {
    uint8_t * *  p;
    msysnewc_pushio();
    msysnewc_ptr_stack[(msysnewc_niostack)-1] = s;
    p = &msysnewc_ptr_stack[(msysnewc_niostack)-1];
    msysnewc_outchan = (void *)(p);
    msysnewc_outdev = (int64_t)3;
}

void msysnewc_m_print_startptr(uint8_t * * p) {
    msysnewc_pushio();
    msysnewc_outchan = (void *)(p);
    msysnewc_outdev = (int64_t)3;
}

void msysnewc_m_print_startcon(void) {
    msysnewc_pushio();
    msysnewc_outdev = (int64_t)1;
}

void msysnewc_m_print_setfmt(uint8_t * format) {
    msysnewc_fmtstr = format;
}

void msysnewc_m_print_end(void) {
    msysnewc_needgap = (int64_t)0;
    msysnewc_nextfmtchars((int64_t)1);
    if ((msysnewc_niostack == (int64_t)0)) {
        return;
    };
    msysnewc_outchan = msysnewc_outchan_stack[(msysnewc_niostack)-1];
    msysnewc_outdev = msysnewc_outdev_stack[(msysnewc_niostack)-1];
    msysnewc_fmtstr = msysnewc_fmtstr_stack[(msysnewc_niostack)-1];
    msysnewc_needgap = (int64_t)(msysnewc_needgap_stack[(msysnewc_niostack)-1]);
    --msysnewc_niostack;
}

void msysnewc_m_print_ptr(void * a,uint8_t * fmtstyle) {
    msysnewc_nextfmtchars((int64_t)0);
    msysnewc_printstr(msysnewc_strword((uint64_t)(a),(uint8_t*)"z8h"));
    msysnewc_needgap = (int64_t)1;
}

void msysnewc_m_print_i64(int64_t a,uint8_t * fmtstyle) {
    uint8_t s[40];
    struct msysnewc_fmtrec fmt;
    int64_t n;
    msysnewc_nextfmtchars((int64_t)0);
    if ((fmtstyle == 0)) {
        if ((a >= (int64_t)0)) {
            n = msysnewc_u64tostr((uint64_t)(a),s,(uint64_t)((int64_t)10),(int64_t)0);
        } else {
            s[((int64_t)1)-1] = '-';
            n = (msysnewc_u64tostr((uint64_t)(-(a)),&s[((int64_t)2)-1],(uint64_t)((int64_t)10),(int64_t)0) + (int64_t)1);
        };
        msysnewc_printstr_n(s,n);
    } else {
        msysnewc_strtofmt(fmtstyle,(int64_t)-1,&fmt);
        if (((uint64_t)(fmt.param) == 'V')) {
            msysnewc_fmtparam = a;
            msysnewc_needgap = (int64_t)0;
        } else {
            msysnewc_tostr_i64(a,&fmt);
        };
    };
    msysnewc_needgap = (int64_t)1;
}

void msysnewc_m_print_u64(uint64_t a,uint8_t * fmtstyle) {
    struct msysnewc_fmtrec fmt;
    msysnewc_nextfmtchars((int64_t)0);
    if ((fmtstyle == 0)) {
        msysnewc_printstr(msysnewc_strword(a,(uint8_t *)(0)));
    } else {
        msysnewc_strtofmt(fmtstyle,(int64_t)-1,&fmt);
        msysnewc_tostr_u64(a,&fmt);
    };
    msysnewc_needgap = (int64_t)1;
}

void msysnewc_m_print_r64(double x,uint8_t * fmtstyle) {
    uint8_t s[360];
    struct msysnewc_fmtrec fmt;
    msysnewc_nextfmtchars((int64_t)0);
    if ((fmtstyle == 0)) {
        sprintf((int8_t *)(s),(int8_t *)((uint8_t*)"%f"),x);
        msysnewc_printstr(s);
    } else {
        msysnewc_strtofmt(fmtstyle,(int64_t)-1,&fmt);
        msysnewc_tostr_r64(x,&fmt);
    };
    msysnewc_needgap = (int64_t)1;
}

void msysnewc_m_print_r32(float x,uint8_t * fmtstyle) {
    msysnewc_m_print_r64((double)(x),fmtstyle);
}

void msysnewc_m_print_c8(int64_t a,uint8_t * fmtstyle) {
    uint8_t s[40];
    msysnewc_nextfmtchars((int64_t)0);
    s[((int64_t)1)-1] = (uint64_t)(a);
    s[((int64_t)2)-1] = (uint64_t)0u;
    msysnewc_printstr(s);
    msysnewc_needgap = (int64_t)1;
}

void msysnewc_m_print_str(uint8_t * s,uint8_t * fmtstyle) {
    struct msysnewc_fmtrec fmt;
    msysnewc_nextfmtchars((int64_t)0);
    if ((fmtstyle == 0)) {
        msysnewc_printstr(s);
    } else {
        msysnewc_strtofmt(fmtstyle,(int64_t)-1,&fmt);
        msysnewc_tostr_str(s,&fmt);
    };
    msysnewc_needgap = (int64_t)1;
}

void msysnewc_m_print_newline(void) {
    msysnewc_needgap = (int64_t)0;
    msysnewc_nextfmtchars((int64_t)1);
    msysnewc_printstr((uint8_t*)"\r\n");
}

void msysnewc_m_print_nogap(void) {
    msysnewc_needgap = (int64_t)0;
}

void msysnewc_printstr(uint8_t * s) {
    uint8_t * *  p;
    if ((msysnewc_outdev==(int64_t)1)) {
        printf((int8_t *)((uint8_t*)"%s"),s);
    }else if ((msysnewc_outdev==(int64_t)2)) {
        fprintf(msysnewc_outchan,(int8_t *)((uint8_t*)"%s"),s);
    }else if ((msysnewc_outdev==(int64_t)3)) {
        p = (uint8_t * *)(msysnewc_outchan);
        strcpy((int8_t *)((*p)),(int8_t *)(s));
        (*p) += (int64_t)(strlen((int8_t *)(s)));
    };
}

void msysnewc_printstr_n(uint8_t * s,int64_t n) {
    uint8_t str[256];
    uint8_t * *  p;
    if ((n==(int64_t)-1)) {
        n = (int64_t)(strlen((int8_t *)(s)));
    }else if ((n==(int64_t)0)) {
        return;
    };
    if ((msysnewc_outdev==(int64_t)3)) {
        p = (uint8_t * *)(msysnewc_outchan);
        memcpy((void *)((*p)),(void *)(s),(uint64_t)(n));
        (*p) += n;
        (*(*p)) = (uint64_t)0u;
    }else if ((msysnewc_outdev==(int64_t)2)) {
        s = msysnewc_makezstring(s,n,str);
        fprintf(msysnewc_outchan,(int8_t *)((uint8_t*)"%s"),s);
        msysnewc_freezstring(s,n);
    }else if ((msysnewc_outdev==(int64_t)1)) {
        s = msysnewc_makezstring(s,n,str);
        printf((int8_t *)((uint8_t*)"%s"),s);
        msysnewc_freezstring(s,n);
    };
}

void msysnewc_printstrn_app(uint8_t * s,int64_t length,void * f) {
    if (!!(length)) {
        if ((f == 0)) {
            printf("%.*s",(i32)length,s);;
        } else {
            fprintf(f,"%.*s",(i32)length,s);;
        };
    };
}

static uint8_t * msysnewc_makezstring(uint8_t * s,int64_t n,uint8_t * local) {
    uint8_t *  t;
    if ((n < (int64_t)256)) {
        memcpy((void *)(local),(void *)(s),(uint64_t)(n));
        (*(local + n)) = (uint64_t)0u;
        return local;
    } else {
        t = (uint8_t *)(mlib_pcm_alloc((n + (int64_t)1)));
        memcpy((void *)(t),(void *)(s),(uint64_t)(n));
        (*(t + n)) = (uint64_t)0u;
        return t;
    };
}

static void msysnewc_freezstring(uint8_t * t,int64_t n) {
    if ((n >= (int64_t)256)) {
        mlib_pcm_free((void *)(t),(n + (int64_t)1));
    };
}

static void msysnewc_printchar(int64_t ch) {
    uint8_t * *  p;
    if ((msysnewc_outdev==(int64_t)1)) {
        printf("%c",(int)ch);
    }else if ((msysnewc_outdev==(int64_t)2)) {
        fprintf(msysnewc_outchan,"%c",(int)ch);
    }else if ((msysnewc_outdev==(int64_t)3)) {
        p = (uint8_t * *)(msysnewc_outchan);
        (*(*p)) = (uint64_t)(ch);
        (*p) += (int64_t)1;
        (*(*p)) = (uint64_t)0u;
    };
}

void msysnewc_nextfmtchars(int64_t lastx) {
    uint8_t c;
    uint8_t *  pstart;
    int64_t n;
    if (!(!!(msysnewc_fmtstr))) {
        if (!!(msysnewc_needgap)) {
            msysnewc_printchar((int64_t)32);
        };
        msysnewc_needgap = (int64_t)0;
        return;
    };
    pstart = msysnewc_fmtstr;
    n = (int64_t)0;
    L12 :;
    while (!!((int64_t)1)) {
        c = (uint64_t)((*msysnewc_fmtstr));
        switch ((int64_t)(c)) {
        case 35:;
        {
            if (!!(lastx)) {
                goto L15 ;
;
            };
            ++msysnewc_fmtstr;
            if (!!(n)) {
                msysnewc_printstr_n(pstart,n);
            };
            return;
        }break;
        case 0:;
        {
            if (!!(n)) {
                msysnewc_printstr_n(pstart,n);
            } else if (!(!!(lastx))) {
                msysnewc_printstr_n((uint8_t*)"|",(int64_t)1);
            };
            return;
        }break;
        case 126:;
        {
            if (!!(n)) {
                msysnewc_printstr_n(pstart,n);
                n = (int64_t)0;
            };
            ++msysnewc_fmtstr;
            c = (uint64_t)((*msysnewc_fmtstr));
            if (!!((uint64_t)(c))) {
                ++msysnewc_fmtstr;
                msysnewc_printchar((int64_t)(c));
            };
            pstart = msysnewc_fmtstr;
        }break;
        default: {
            //skip:
L15 :;
;
            ++n;
            ++msysnewc_fmtstr;
        }
        } //SW
;
L13 :;
    }L14 :;
    ;
}

void msysnewc_strtofmt(uint8_t * s,int64_t slen,struct msysnewc_fmtrec * fmt) {
    uint8_t c;
    byte wset;
    int64_t n;
    uint8_t str[100];
    (*fmt) = msysnewc_defaultfmt;
    if ((s == 0)) {
        return;
    };
    if ((slen == (int64_t)-1)) {
        slen = (int64_t)(strlen((int8_t *)(s)));
    };
    memcpy((void *)(str),(void *)(s),(uint64_t)(slen));
    str[(slen)] = (uint64_t)0u;
    s = str;
    wset = (uint64_t)((int64_t)0);
    L16 :;
    while (!!((uint64_t)((*s)))) {
        c = (uint64_t)((*s));
        ++s;
        switch ((int64_t)(c)) {
        case 66:;
        case 98:;
        {
            (*fmt).base = (uint64_t)((int64_t)2);
        }break;
        case 72:;
        case 104:;
        {
            (*fmt).base = (uint64_t)((int64_t)16);
        }break;
        case 79:;
        case 111:;
        {
            (*fmt).base = (uint64_t)((int64_t)8);
        }break;
        case 88:;
        case 120:;
        {
            c = (uint64_t)((*s));
            if (!!((uint64_t)(c))) {
                switch ((int64_t)(c)) {
                case 48:;
                case 49:;
                case 50:;
                case 51:;
                case 52:;
                case 53:;
                case 54:;
                case 55:;
                case 56:;
                case 57:;
                {
                    c = ((uint64_t)(c) - '0');
                }break;
                case 65:;
                case 66:;
                case 67:;
                case 68:;
                case 69:;
                case 70:;
                {
                    c = (uint64_t)((((uint64_t)(c) - 'A') + (int64_t)10));
                }break;
                case 97:;
                case 98:;
                case 99:;
                case 100:;
                case 101:;
                case 102:;
                {
                    c = (uint64_t)((((uint64_t)(c) - 'a') + (int64_t)10));
                }break;
                default: {
                    c = (uint64_t)10u;
                }
                } //SW
;
                (*fmt).base = (uint64_t)(c);
                ++s;
            };
        }break;
        case 81:;
        case 113:;
        {
            (*fmt).quotechar = '"';
        }break;
        case 126:;
        {
            (*fmt).quotechar = '~';
        }break;
        case 74:;
        case 106:;
        {
            (*fmt).justify = (uint64_t)(toupper((int64_t)((int32_t)((*s)))));
            if (!!((uint64_t)((*s)))) {
                ++s;
            };
        }break;
        case 65:;
        {
            (*fmt).lettercase = 'A';
        }break;
        case 97:;
        {
            (*fmt).lettercase = 'a';
        }break;
        case 90:;
        case 122:;
        {
            (*fmt).padchar = '0';
        }break;
        case 83:;
        case 115:;
        {
            (*fmt).sepchar = (uint64_t)((*s));
            if (!!((uint64_t)((*s)))) {
                ++s;
            };
        }break;
        case 80:;
        case 112:;
        {
            (*fmt).padchar = (uint64_t)((*s));
            if (!!((uint64_t)((*s)))) {
                ++s;
            };
        }break;
        case 84:;
        case 116:;
        {
            (*fmt).suffix = (uint64_t)((*s));
            if (!!((uint64_t)((*s)))) {
                ++s;
            };
        }break;
        case 87:;
        case 119:;
        {
            (*fmt).usigned = 'W';
        }break;
        case 69:;
        case 101:;
        {
            (*fmt).realfmt = 'e';
        }break;
        case 70:;
        case 102:;
        {
            (*fmt).realfmt = 'f';
        }break;
        case 71:;
        case 103:;
        {
            (*fmt).realfmt = 'g';
        }break;
        case 46:;
        {
            wset = (uint64_t)((int64_t)1);
        }break;
        case 44:;
        case 95:;
        {
            (*fmt).sepchar = (uint64_t)(c);
        }break;
        case 43:;
        {
            (*fmt).plus = '+';
        }break;
        case 68:;
        case 100:;
        {
            (*fmt).charmode = 'D';
        }break;
        case 67:;
        case 99:;
        {
            (*fmt).charmode = 'C';
        }break;
        case 77:;
        case 109:;
        {
            (*fmt).heapmode = 'M';
        }break;
        case 86:;
        case 118:;
        {
            (*fmt).param = 'V';
        }break;
        case 42:;
        {
            n = msysnewc_fmtparam;
            goto L19 ;
;
        }break;
        default: {
            if ((((uint64_t)(c) >= '0') && ((uint64_t)(c) <= '9'))) {
                n = ((uint64_t)(c) - '0');
                L20 :;
                while (1) {
                    c = (uint64_t)((*s));
                    if (((int64_t)((*s)) == (int64_t)0)) {
                        goto L21 ;
                    };
                    if ((((uint64_t)(c) >= '0') && ((uint64_t)(c) <= '9'))) {
                        ++s;
                        n = (((n * (int64_t)10) + (int64_t)(c)) - (int64_t)48);
                    } else {
                        goto L21 ;
                    };
                }L21 :;
                ;
                //gotwidth:
L19 :;
;
                if (!(!!((uint64_t)(wset)))) {
                    (*fmt).minwidth = (uint64_t)(n);
                    wset = (uint64_t)((int64_t)1);
                } else {
                    (*fmt).precision = n;
                };
            };
        }
        } //SW
;
L17 :;
    }L18 :;
    ;
}

static int64_t msysnewc_domultichar(uint8_t * p,int64_t n,uint8_t * dest,struct msysnewc_fmtrec * fmt) {
    uint8_t str[20];
    uint8_t *  q;
    int64_t nchars;
    int64_t av_1;
    q = str;
    nchars = n;
    av_1 = n;
    while (av_1-- > 0) {
L22 :;
        if (((int64_t)((*p)) == (int64_t)0)) {
            goto L24 ;
        };
        (*q) = (uint64_t)((*p));
        ++q;
        ++p;
L23 :;
    }L24 :;
    ;
    (*q) = (uint64_t)0u;
    return msysnewc_expandstr(str,dest,(int64_t)(strlen((int8_t *)(str))),fmt);
}

static int64_t msysnewc_expandstr(uint8_t * s,uint8_t * t,int64_t n,struct msysnewc_fmtrec * fmt) {
    int64_t i;
    int64_t w;
    int64_t m;
    int64_t av_1;
    int64_t av_2;
    int64_t av_3;
    int64_t av_4;
    int64_t av_5;
    w = (int64_t)((*fmt).minwidth);
    if (((w == (int64_t)0) || (w <= n))) {
        strncpy((int8_t *)(t),(int8_t *)(s),(uint64_t)(n));
        (*(t + n)) = (uint64_t)0u;
        return n;
    };
    if (((uint64_t)((*fmt).justify) == 'L')) {
        strncpy((int8_t *)(t),(int8_t *)(s),(uint64_t)(n));
        t += n;
        L25 :;
        for (i=(int64_t)1;i<=(w - n);i+=(int64_t)1) {
L26 :;
            (*t) = (uint64_t)((*fmt).padchar);
            ++t;
L27 :;
        }L28 :;
        ;
        (*t) = (uint64_t)0u;
    } else if (((uint64_t)((*fmt).justify) == 'R')) {
        if (((((uint64_t)((*fmt).padchar) == '0') && !!((uint64_t)((*fmt).base))) && (((uint64_t)((*s)) == '-') || ((uint64_t)((*s)) == '+')))) {
            (*t) = (uint64_t)((*s));
            ++t;
            av_2 = (w - n);
            while (av_2-- > 0) {
L29 :;
                (*t) = (uint64_t)((*fmt).padchar);
                ++t;
L30 :;
            }L31 :;
            ;
            strncpy((int8_t *)(t),(int8_t *)((s + (int64_t)1)),(uint64_t)((n - (int64_t)1)));
            (*((t + n) - (int64_t)1)) = (uint64_t)0u;
        } else {
            av_3 = (w - n);
            while (av_3-- > 0) {
L32 :;
                (*t) = (uint64_t)((*fmt).padchar);
                ++t;
L33 :;
            }L34 :;
            ;
            strncpy((int8_t *)(t),(int8_t *)(s),(uint64_t)(n));
            (*(t + n)) = (uint64_t)0u;
        };
    } else {
        m = (((w - n) + (int64_t)1) / (int64_t)2);
        av_4 = m;
        while (av_4-- > 0) {
L35 :;
            (*t) = (uint64_t)((*fmt).padchar);
            ++t;
L36 :;
        }L37 :;
        ;
        strncpy((int8_t *)(t),(int8_t *)(s),(uint64_t)(n));
        t += n;
        av_5 = ((w - n) - m);
        while (av_5-- > 0) {
L38 :;
            (*t) = (uint64_t)((*fmt).padchar);
            ++t;
L39 :;
        }L40 :;
        ;
        (*t) = (uint64_t)0u;
    };
    return w;
}

static uint64_t msysnewc_xdivrem(uint64_t a,uint64_t b,uint64_t * remainder) {
    uint64_t q;
    mlib_abortprogram((uint8_t*)"XDIVREM");
    return q;
}

static int64_t msysnewc_u64tostr(uint64_t aa,uint8_t * s,uint64_t base,int64_t sep) {
    uint8_t t[360];
    int64_t i;
    int64_t j;
    int64_t k;
    int64_t g;
    uint8_t *  s0;
    i = (int64_t)0;
    k = (int64_t)0;
    g = (((int64_t)(base) == (int64_t)10)?(int64_t)3:(int64_t)4);
    L41 :;
    do {
        t[(++i)] = (uint64_t)(msysnewc_digits[((int64_t)((aa % base)))]);
        aa = (aa / base);
        ++k;
        if (((!!(sep) && ((int64_t)(aa) != (int64_t)0)) && (k == g))) {
            t[(++i)] = (uint64_t)(sep);
            k = (int64_t)0;
        };
L42 :;
    } while (!((int64_t)(aa) == (int64_t)0));L43 :;
    ;
    j = i;
    s0 = s;
    L44 :;
    while (!!(i)) {
        (*s) = (uint64_t)(t[(i--)]);
        ++s;
L45 :;
    }L46 :;
    ;
    (*s) = (uint64_t)0u;
    return j;
}

static int64_t msysnewc_i64tostrfmt(int64_t aa,uint8_t * s,struct msysnewc_fmtrec * fmt) {
    uint8_t str[360];
    int64_t n;
    int64_t usigned;
    static uint64_t mindint = (uint64_t)9223372036854775808u;
    usigned = (int64_t)0;
    if (!!((uint64_t)((*fmt).usigned))) {
        usigned = (int64_t)1;
    };
    if (((aa == (int64_t)(mindint)) && !(!!(usigned)))) {
        str[((int64_t)0)] = '-';
        n = (msysnewc_i64mintostr(&str[((int64_t)1)],(int64_t)((*fmt).base),(int64_t)((*fmt).sepchar)) + (int64_t)1);
    } else {
        if (((!(!!(usigned)) && (aa < (int64_t)0)) || !!((uint64_t)((*fmt).plus)))) {
            if ((aa < (int64_t)0)) {
                aa = -(aa);
                str[((int64_t)0)] = '-';
            } else {
                str[((int64_t)0)] = '+';
            };
            n = (msysnewc_u64tostr((uint64_t)(aa),&str[((int64_t)1)],(uint64_t)((*fmt).base),(int64_t)((*fmt).sepchar)) + (int64_t)1);
        } else {
            n = msysnewc_u64tostr((uint64_t)(aa),str,(uint64_t)((*fmt).base),(int64_t)((*fmt).sepchar));
        };
    };
    if (!!((uint64_t)((*fmt).suffix))) {
        str[(n)] = (uint64_t)((*fmt).suffix);
        str[(++n)] = (uint64_t)0u;
    };
    if (((((int64_t)((uint64_t)((*fmt).base)) > (int64_t)10) || !!((uint64_t)((*fmt).suffix))) && ((uint64_t)((*fmt).lettercase) == 'a'))) {
        msysnewc_convlcstring(str);
    };
    return msysnewc_expandstr(str,s,n,fmt);
}

static int64_t msysnewc_u64tostrfmt(int64_t aa,uint8_t * s,struct msysnewc_fmtrec * fmt) {
    uint8_t str[360];
    int64_t n;
    n = msysnewc_u64tostr((uint64_t)(aa),str,(uint64_t)((*fmt).base),(int64_t)((*fmt).sepchar));
    if (!!((uint64_t)((*fmt).suffix))) {
        str[(n)] = (uint64_t)((*fmt).suffix);
        str[(++n)] = (uint64_t)0u;
    };
    if ((((int64_t)((uint64_t)((*fmt).base)) > (int64_t)10) || (!!((uint64_t)((*fmt).suffix)) && ((uint64_t)((*fmt).lettercase) == 'a')))) {
        msysnewc_convlcstring(str);
    };
    return msysnewc_expandstr(str,s,n,fmt);
}

static int64_t msysnewc_i64mintostr(uint8_t * s,int64_t base,int64_t sep) {
    uint8_t t[360];
    int64_t i;
    int64_t j;
    int64_t k;
    int64_t g;
    switch (base) {
    case 10:;
    {
        strcpy((int8_t *)(&t[((int64_t)0)]),(int8_t *)((uint8_t*)"9223372036854775808"));
        j = (int64_t)3;
    }break;
    case 16:;
    {
        strcpy((int8_t *)(&t[((int64_t)0)]),(int8_t *)((uint8_t*)"8000000000000000"));
        j = (int64_t)1;
    }break;
    case 2:;
    {
        strcpy((int8_t *)(&t[((int64_t)0)]),(int8_t *)((uint8_t*)"1000000000000000000000000000000000000000000000000000000000000000"));
        j = (int64_t)7;
    }break;
    default: {
        strcpy((int8_t *)(&t[((int64_t)0)]),(int8_t *)((uint8_t*)"<mindint>"));
    }
    } //SW
;
    i = (int64_t)(strlen((int8_t *)(&t[((int64_t)0)])));
    s += i;
    if (!!(sep)) {
        s += j;
    };
    (*s) = (uint64_t)0u;
    k = (int64_t)0;
    g = ((base == (int64_t)10)?(int64_t)3:(int64_t)4);
    L47 :;
    while (!!(i)) {
        --s;
        (*s) = (uint64_t)(t[((i-- - (int64_t)1))]);
        if (((!!(sep) && !!(i)) && (++k == g))) {
            --s;
            (*s) = (uint64_t)(sep);
            k = (int64_t)0;
        };
L48 :;
    }L49 :;
    ;
    return (int64_t)(strlen((int8_t *)(s)));
}

static int64_t msysnewc_strtostrfmt(uint8_t * s,uint8_t * t,int64_t n,struct msysnewc_fmtrec * fmt) {
    uint8_t *  u;
    uint8_t *  v;
    uint8_t str[256];
    int64_t w;
    int64_t nheap;
    nheap = (int64_t)0;
    if ((!!((uint64_t)((*fmt).quotechar)) || !!((uint64_t)((*fmt).lettercase)))) {
        if ((n < (int64_t)256)) {
            u = str;
        } else {
            nheap = (n + (int64_t)3);
            u = (uint8_t *)(mlib_pcm_alloc(nheap));
        };
        if (!!((uint64_t)((*fmt).quotechar))) {
            v = u;
            (*v) = (uint64_t)((*fmt).quotechar);
            ++v;
            if (!!(n)) {
                strcpy((int8_t *)(v),(int8_t *)(s));
                v += n;
            };
            (*v) = (uint64_t)((*fmt).quotechar);
            ++v;
            (*v) = (uint64_t)0u;
            n += (int64_t)2;
        } else {
            memcpy((void *)(u),(void *)(s),(uint64_t)(n));
        };
        switch ((int64_t)((*fmt).lettercase)) {
        case 97:;
        {
            msysnewc_convlcstring(u);
        }break;
        case 65:;
        {
            msysnewc_convucstring(u);
        }break;
        default: {
        }
        } //SW
;
        s = u;
    };
    w = (int64_t)((*fmt).minwidth);
    if ((w > n)) {
        n = msysnewc_expandstr(s,t,n,fmt);
    } else {
        memcpy((void *)(t),(void *)(s),(uint64_t)(n));
    };
    if (!!(nheap)) {
        mlib_pcm_free((void *)(u),nheap);
    };
    return n;
}

static void msysnewc_tostr_i64(int64_t a,struct msysnewc_fmtrec * fmt) {
    uint8_t str[360];
    int64_t n;
    if (((int64_t)((*fmt).charmode)==(int64_t)0)) {
        n = msysnewc_i64tostrfmt(a,str,fmt);
    }else if (((int64_t)((*fmt).charmode)==(int64_t)68) || ((int64_t)((*fmt).charmode)==(int64_t)100)) {
        n = msysnewc_domultichar((uint8_t *)(&a),(int64_t)8,str,fmt);
    } else {
        msysnewc_printchar(a);
        return;
    };
    msysnewc_printstr_n(str,n);
}

static void msysnewc_tostr_u64(uint64_t a,struct msysnewc_fmtrec * fmt) {
    uint8_t str[360];
    int64_t n;
    if (((int64_t)((*fmt).charmode)==(int64_t)68) || ((int64_t)((*fmt).charmode)==(int64_t)100)) {
        n = msysnewc_domultichar((uint8_t *)(&a),(int64_t)8,str,fmt);
    }else if (((int64_t)((*fmt).charmode)==(int64_t)67) || ((int64_t)((*fmt).charmode)==(int64_t)99)) {
        msysnewc_printchar((int64_t)(a));
        return;
    } else {
        n = msysnewc_u64tostrfmt((int64_t)(a),str,fmt);
    };
    msysnewc_printstr_n(str,n);
}

static void msysnewc_tostr_r64(double x,struct msysnewc_fmtrec * fmt) {
    uint8_t str[360];
    uint8_t str2[360];
    uint8_t cfmt[10];
    int64_t n;
    cfmt[((int64_t)0)] = '%';
    if (!!((int64_t)((*fmt).precision))) {
        cfmt[((int64_t)1)] = '.';
        cfmt[((int64_t)2)] = '*';
        cfmt[((int64_t)3)] = (uint64_t)((*fmt).realfmt);
        cfmt[((int64_t)4)] = (uint64_t)0u;
        sprintf((int8_t *)(str),(int8_t *)(cfmt),(int64_t)((*fmt).precision),x);
    } else {
        cfmt[((int64_t)1)] = (uint64_t)((*fmt).realfmt);
        cfmt[((int64_t)2)] = (uint64_t)0u;
        sprintf((int8_t *)(str),(int8_t *)(cfmt),x);
    };
    n = (int64_t)(strlen((int8_t *)(str)));
    if ((n < (int64_t)((uint64_t)((*fmt).minwidth)))) {
        n = msysnewc_expandstr(str,str2,n,fmt);
        strcpy((int8_t *)(str),(int8_t *)(str2));
    };
    msysnewc_printstr_n(str,n);
}

static void msysnewc_tostr_str(uint8_t * s,struct msysnewc_fmtrec * fmt) {
    int64_t oldlen;
    int64_t newlen;
    int64_t n;
    uint8_t *  t;
    oldlen = (int64_t)(strlen((int8_t *)(s)));
    newlen = oldlen;
    if (((!!((uint64_t)((*fmt).quotechar)) || ((int64_t)((uint64_t)((*fmt).minwidth)) > newlen)) || !!((uint64_t)((*fmt).lettercase)))) {
        if (!!((uint64_t)((*fmt).quotechar))) {
            newlen += (int64_t)2;
        };
        if (((int64_t)((uint64_t)((*fmt).minwidth)) > newlen)) {
            newlen = (int64_t)((*fmt).minwidth);
        };
        t = (uint8_t *)(mlib_pcm_alloc((newlen + (int64_t)1)));
        n = msysnewc_strtostrfmt(s,t,oldlen,fmt);
        msysnewc_printstr_n(t,n);
        mlib_pcm_free((void *)(t),(newlen + (int64_t)1));
    } else {
        msysnewc_printstr_n(s,oldlen);
    };
}

static struct msysnewc_fmtrec * msysnewc_getfmt(uint8_t * fmtstyle) {
    static struct msysnewc_fmtrec fmt;
    if (!!(fmtstyle)) {
        msysnewc_strtofmt(fmtstyle,(int64_t)-1,&fmt);
        return &fmt;
    } else {
        return &msysnewc_defaultfmt;
    };
}

uint8_t * msysnewc_strint(int64_t a,uint8_t * fmtstyle) {
    static uint8_t str[100];
    struct msysnewc_fmtrec *  fmt;
    msysnewc_m_print_startstr(str);
    msysnewc_tostr_i64(a,(fmt = msysnewc_getfmt(fmtstyle)));
    msysnewc_m_print_end();
    return msysnewc_getstr(str,fmt);
}

void msysnewc_getstrint(int64_t a,uint8_t * dest) {
    msysnewc_m_print_startstr(dest);
    msysnewc_tostr_i64(a,msysnewc_getfmt((uint8_t *)(0)));
    msysnewc_m_print_end();
}

uint8_t * msysnewc_strword(uint64_t a,uint8_t * fmtstyle) {
    static uint8_t str[100];
    struct msysnewc_fmtrec *  fmt;
    msysnewc_m_print_startstr(str);
    msysnewc_tostr_u64(a,(fmt = msysnewc_getfmt(fmtstyle)));
    msysnewc_m_print_end();
    return msysnewc_getstr(str,fmt);
}

uint8_t * msysnewc_strreal(double a,uint8_t * fmtstyle) {
    static uint8_t str[320];
    struct msysnewc_fmtrec *  fmt;
    msysnewc_m_print_startstr(str);
    msysnewc_tostr_r64(a,(fmt = msysnewc_getfmt(fmtstyle)));
    msysnewc_m_print_end();
    return msysnewc_getstr(str,fmt);
}

static uint8_t * msysnewc_getstr(uint8_t * s,struct msysnewc_fmtrec * fmt) {
    if (!!((uint64_t)((*fmt).heapmode))) {
        return mlib_pcm_copyheapstring(s);
    } else {
        return s;
    };
}

static void msysnewc_initreadbuffer(void) {
    if (!!(msysnewc_rd_buffer)) {
        return;
    };
    msysnewc_rd_buffer = (uint8_t *)(mlib_pcm_alloc((int64_t)16384));
    (*msysnewc_rd_buffer) = (uint64_t)0u;
    msysnewc_rd_pos = (msysnewc_rd_lastpos = msysnewc_rd_buffer);
}

void msysnewc_m_read_conline(void) {
    msysnewc_initreadbuffer();
    mlib_readlinen(0,msysnewc_rd_buffer,(int64_t)16384);
    msysnewc_rd_length = (int64_t)(strlen((int8_t *)(msysnewc_rd_buffer)));
    msysnewc_rd_pos = msysnewc_rd_buffer;
    msysnewc_rd_lastpos = (uint8_t *)(0);
}

void msysnewc_m_read_fileline(void * f) {
    msysnewc_initreadbuffer();
    mlib_readlinen(f,msysnewc_rd_buffer,(int64_t)16384);
    msysnewc_rd_length = (int64_t)(strlen((int8_t *)(msysnewc_rd_buffer)));
    msysnewc_rd_pos = msysnewc_rd_buffer;
    msysnewc_rd_lastpos = (uint8_t *)(0);
}

void msysnewc_m_read_strline(uint8_t * s) {
    int64_t n;
    msysnewc_initreadbuffer();
    n = (int64_t)(strlen((int8_t *)(s)));
    if ((n < (int64_t)16384)) {
        strcpy((int8_t *)(msysnewc_rd_buffer),(int8_t *)(s));
    } else {
        memcpy((void *)(msysnewc_rd_buffer),(void *)(s),(uint64_t)((int64_t)16383));
        (*((msysnewc_rd_buffer + (int64_t)16384) - (int64_t)1)) = (uint64_t)0u;
    };
    msysnewc_rd_length = n;
    msysnewc_rd_pos = msysnewc_rd_buffer;
    msysnewc_rd_lastpos = (uint8_t *)(0);
}

static uint8_t * msysnewc_readitem(int64_t * itemlength) {
    uint8_t *  p;
    uint8_t *  s;
    uint8_t *  itemstr;
    uint8_t quotechar;
    uint8_t c;
    if (!(!!(msysnewc_rd_buffer))) {
        msysnewc_initreadbuffer();
    };
    s = msysnewc_rd_pos;
    L50 :;
    while ((((uint64_t)((*s)) == ' ') || ((int64_t)((*s)) == (int64_t)9))) {
        ++s;
L51 :;
    }L52 :;
    ;
    itemstr = s;
    msysnewc_rd_lastpos = (msysnewc_rd_pos = s);
    if (((int64_t)((*s)) == (int64_t)0)) {
        msysnewc_termchar = (int64_t)0;
        (*itemlength) = (int64_t)0;
        return s;
    };
    quotechar = (uint64_t)0u;
    if (((uint64_t)((*s)) == '"')) {
        quotechar = '"';
        ++s;
    } else if (((uint64_t)((*s)) == (uint64_t)39u)) {
        quotechar = (uint64_t)39u;
        ++s;
    };
    p = (itemstr = s);
    L53 :;
    while (!!((uint64_t)((*s)))) {
        c = (uint64_t)((*s++));
        switch ((int64_t)(c)) {
        case 32:;
        case 9:;
        case 44:;
        case 61:;
        {
            if ((!!((uint64_t)(quotechar)) || (p == s))) {
                goto L56 ;
;
            };
            msysnewc_termchar = (int64_t)(c);
            goto L55 ;
        }break;
        default: {
            //normalchar:
L56 :;
;
            if (((uint64_t)(c) == (uint64_t)(quotechar))) {
                if (((uint64_t)((*s)) == (uint64_t)(quotechar))) {
                    (*p) = (uint64_t)(c);
                    ++s;
                    ++p;
                } else {
                    msysnewc_termchar = (int64_t)((*s));
                    if (((msysnewc_termchar == (int64_t)44) || (msysnewc_termchar == (int64_t)61))) {
                        ++s;
                        msysnewc_termchar = (int64_t)((*s));
                    };
                    goto L55 ;
                };
            } else {
                (*p) = (uint64_t)(c);
                ++p;
            };
        }
        } //SW
;
L54 :;
    }L55 :;
    ;
    if (((int64_t)((*s)) == (int64_t)0)) {
        msysnewc_termchar = (int64_t)0;
    };
    (*itemlength) = (p - itemstr);
    msysnewc_rd_pos = s;
    return itemstr;
}

int64_t msysnewc_strtoint(uint8_t * s,int64_t length,int64_t base) {
    byte signd;
    uint64_t aa;
    uint8_t c;
    uint8_t d;
    msysnewc_itemerror = (int64_t)0;
    if ((length == (int64_t)-1)) {
        length = (int64_t)(strlen((int8_t *)(s)));
    };
    signd = (uint64_t)((int64_t)0);
    if ((!!(length) && ((uint64_t)((*s)) == '-'))) {
        signd = (uint64_t)((int64_t)1);
        ++s;
        --length;
    } else if ((!!(length) && ((uint64_t)((*s)) == '+'))) {
        ++s;
        --length;
    };
    aa = (uint64_t)((int64_t)0);
    L57 :;
    while (!!(length)) {
        c = (uint64_t)((*s++));
        --length;
        switch ((int64_t)(c)) {
        case 65:;
        case 66:;
        case 67:;
        case 68:;
        case 69:;
        case 70:;
        {
            d = (uint64_t)((((uint64_t)(c) - 'A') + (int64_t)10));
        }break;
        case 97:;
        case 98:;
        case 99:;
        case 100:;
        case 101:;
        case 102:;
        {
            d = (uint64_t)((((uint64_t)(c) - 'a') + (int64_t)10));
        }break;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        {
            d = ((uint64_t)(c) - '0');
        }break;
        case 95:;
        case 39:;
        {
            goto L58 ;
        }break;
        default: {
            msysnewc_itemerror = (int64_t)1;
            goto L59 ;
        }
        } //SW
;
        if (((int64_t)(d) >= base)) {
            msysnewc_itemerror = (int64_t)1;
            goto L59 ;
        };
        aa = (uint64_t)((((int64_t)(aa) * base) + (int64_t)(d)));
L58 :;
    }L59 :;
    ;
    if (!!((uint64_t)(signd))) {
        return (int64_t)(-(aa));
    } else {
        return (int64_t)(aa);
    };
}

int64_t msysnewc_m_read_i64(int64_t fmt) {
    uint8_t *  s;
    int64_t length;
    if ((fmt==(int64_t)67) || (fmt==(int64_t)99)) {
        msysnewc_rd_lastpos = msysnewc_rd_pos;
        if (!!((uint64_t)((*msysnewc_rd_pos)))) {
            return (int64_t)((*msysnewc_rd_pos++));
        } else {
            return (int64_t)0;
        };
    }else if ((fmt==(int64_t)84) || (fmt==(int64_t)116)) {
        return msysnewc_termchar;
    }else if ((fmt==(int64_t)69) || (fmt==(int64_t)101)) {
        return msysnewc_itemerror;
    };
    s = msysnewc_readitem(&length);
    if ((fmt==(int64_t)0) || (fmt==(int64_t)73) || (fmt==(int64_t)105)) {
        return msysnewc_strtoint(s,length,(int64_t)10);
    }else if ((fmt==(int64_t)66) || (fmt==(int64_t)98)) {
        return msysnewc_strtoint(s,length,(int64_t)2);
    }else if ((fmt==(int64_t)72) || (fmt==(int64_t)104)) {
        return msysnewc_strtoint(s,length,(int64_t)16);
    };
    return (int64_t)0;
}

double msysnewc_m_read_r64(int64_t fmt) {
    uint8_t str[512];
    uint8_t *  s;
    int64_t length;
    int32_t numlength;
    double x;
    s = msysnewc_readitem(&length);
    if (((length == (int64_t)0) || (length >= (int64_t)512))) {
        return (double)0.;
    };
    memcpy((void *)(str),(void *)(s),(uint64_t)(length));
    str[((length + (int64_t)1))-1] = (uint64_t)0u;
    msysnewc_itemerror = (int64_t)0;
    if ((((int64_t)(sscanf((int8_t *)(str),(int8_t *)((uint8_t*)"%lf%n"),&x,&numlength)) == (int64_t)0) || ((int64_t)(numlength) != length))) {
        x = (double)0.;
        msysnewc_itemerror = (int64_t)1;
    };
    return x;
}

void msysnewc_m_read_str(uint8_t * dest,int64_t destlen,int64_t fmt) {
    uint8_t *  s;
    int64_t length;
    msysnewc_itemerror = (int64_t)0;
    if (((fmt == (int64_t)76) || (fmt == (int64_t)108))) {
        s = msysnewc_rd_pos;
        length = ((msysnewc_rd_buffer + msysnewc_rd_length) - msysnewc_rd_pos);
    } else {
        s = msysnewc_readitem(&length);
        if (((fmt == (int64_t)78) || (fmt == (int64_t)110))) {
            msysnewc_iconvlcn(s,length);
        };
    };
    if ((destlen > (int64_t)0)) {
        if ((length >= destlen)) {
            length = (destlen - (int64_t)1);
            msysnewc_itemerror = (int64_t)1;
        };
    };
    memcpy((void *)(dest),(void *)(s),(uint64_t)(length));
    (*(dest + length)) = (uint64_t)0u;
}

void msysnewc_readstr(uint8_t * dest,int64_t fmt,int64_t destlen) {
    msysnewc_m_read_str(dest,destlen,fmt);
}

void msysnewc_rereadln(void) {
    msysnewc_rd_pos = msysnewc_rd_buffer;
    msysnewc_rd_lastpos = msysnewc_rd_pos;
}

void msysnewc_reread(void) {
    msysnewc_rd_pos = msysnewc_rd_lastpos;
}

int64_t msysnewc_valint(uint8_t * s,int64_t fmt) {
    uint8_t *  old_pos;
    uint8_t *  old_lastpos;
    int64_t aa;
    msysnewc_initreadbuffer();
    old_pos = msysnewc_rd_pos;
    old_lastpos = msysnewc_rd_lastpos;
    msysnewc_rd_pos = s;
    aa = msysnewc_m_read_i64(fmt);
    msysnewc_rd_pos = old_pos;
    msysnewc_rd_lastpos = old_lastpos;
    return aa;
}

double msysnewc_valreal(uint8_t * s) {
    uint8_t *  old_pos;
    uint8_t *  old_lastpos;
    double x;
    msysnewc_initreadbuffer();
    old_pos = msysnewc_rd_pos;
    old_lastpos = msysnewc_rd_lastpos;
    msysnewc_rd_pos = s;
    x = msysnewc_m_read_r64((int64_t)0);
    msysnewc_rd_pos = old_pos;
    msysnewc_rd_lastpos = old_lastpos;
    return x;
}

static void msysnewc_iconvlcn(uint8_t * s,int64_t n) {
    int64_t av_1;
    av_1 = n;
    while (av_1-- > 0) {
L60 :;
        (*s) = (uint64_t)(tolower((int64_t)((int32_t)((*s)))));
        ++s;
L61 :;
    }L62 :;
    ;
}

static void msysnewc_iconvucn(uint8_t * s,int64_t n) {
    int64_t av_1;
    av_1 = n;
    while (av_1-- > 0) {
L63 :;
        (*s) = (uint64_t)(toupper((int64_t)((int32_t)((*s)))));
        ++s;
L64 :;
    }L65 :;
    ;
}

static void msysnewc_convlcstring(uint8_t * s) {
    L66 :;
    while (!!((uint64_t)((*s)))) {
        (*s) = (uint64_t)(tolower((int64_t)((int32_t)((*s)))));
        ++s;
L67 :;
    }L68 :;
    ;
}

static void msysnewc_convucstring(uint8_t * s) {
    L69 :;
    while (!!((uint64_t)((*s)))) {
        (*s) = (uint64_t)(toupper((int64_t)((int32_t)((*s)))));
        ++s;
L70 :;
    }L71 :;
    ;
}

int64_t msysnewc_m_power_i64(int64_t n,int64_t a) {
    if ((n < (int64_t)0)) {
        return (int64_t)0;
    } else if ((n == (int64_t)0)) {
        return (int64_t)1;
    } else if ((n == (int64_t)1)) {
        return a;
    } else if (((n & (int64_t)1) == (int64_t)0)) {
        return msysnewc_m_power_i64((n / (int64_t)2),(a * a));
    } else {
        return (msysnewc_m_power_i64(((n - (int64_t)1) / (int64_t)2),(a * a)) * a);
    };
}

void msysnewc_m_intoverflow(void) {
    mlib_abortprogram((uint8_t*)"Integer overflow detected");
}

void msysnewc_m_dotindex(uint64_t i,uint64_t a) {
    mlib_abortprogram((uint8_t*)"DOT INDEX");
}

void msysnewc_m_dotslice(uint64_t j,uint64_t i,uint64_t a) {
    mlib_abortprogram((uint8_t*)"DOT SLICE");
}

void msysnewc_m_popdotindex(uint64_t i,uint64_t * p,uint64_t x) {
    mlib_abortprogram((uint8_t*)"POP DOT INDEX");
}

void msysnewc_m_popdotslice(uint64_t j,uint64_t i,uint64_t * p,uint64_t x) {
    mlib_abortprogram((uint8_t*)"POP DOT SLICE");
}

int64_t msysnewc_m_imin(int64_t a,int64_t b) {
    return (a<b?a:b);
}

int64_t msysnewc_m_imax(int64_t a,int64_t b) {
    return (a>b?a:b);
}

double msysnewc_m_sign(double x) {
    if ((x > (double)0.)) {
        return (double)1.;
    } else if ((x < (double)0.)) {
        return (double)-1.;
    } else {
        return (double)0.;
    };
}

void * mlib_pcm_alloc(int64_t n) {
    byte *  p;
    if (!(!!((uint64_t)(mlib_pcm_setup)))) {
        mlib_pcm_init();
    };
    if ((n > (int64_t)2048)) {
        mlib_alloccode = mlib_pcm_getac(n);
        mlib_allocbytes = (int64_t)(mlib_allocupper[(mlib_alloccode)]);
        p = (byte *)(mlib_allocmem(mlib_allocbytes));
        if (!(!!(p))) {
            mlib_abortprogram((uint8_t*)"pcm_alloc failure");
        };
        if (!!((int64_t)0)) {
            mlib_addtomemalloc((int32_t *)(p),mlib_allocbytes);
        };
        return (void *)(p);
    };
    mlib_alloccode = (int64_t)(mlib_sizeindextable[(n)]);
    if ((mlib_alloccode == (int64_t)0)) {
        mlib_alloccode = (int64_t)1;
    };
    mlib_allocbytes = (int64_t)(mlib_allocupper[(mlib_alloccode)]);
    mlib_smallmemtotal += mlib_allocbytes;
    if (!!((p = (byte *)(mlib_freelist[(mlib_alloccode)])))) {
        if (!!((int64_t)0)) {
            mlib_addtomemalloc((int32_t *)(p),mlib_allocbytes);
        };
        mlib_freelist[(mlib_alloccode)] = (uint64_t *)((int64_t)((*mlib_freelist[(mlib_alloccode)])));
        return (void *)(p);
    };
    p = mlib_pcheapptr;
    mlib_pcheapptr += mlib_allocbytes;
    if ((mlib_pcheapptr >= mlib_pcheapend)) {
        p = (byte *)(mlib_pcm_newblock(mlib_allocbytes));
        return (void *)(p);
    };
    if (!!((int64_t)0)) {
        mlib_addtomemalloc((int32_t *)(p),mlib_allocbytes);
    };
    return (void *)(p);
}

void mlib_pcm_freestr(uint8_t * s) {
    mlib_pcm_free((void *)(s),((int64_t)(strlen((int8_t *)(s))) + (int64_t)1));
}

void mlib_pcm_free(void * p,int64_t n) {
    int64_t acode;
    if ((n == (int64_t)0)) {
        return;
    };
    if ((n > (int64_t)2048)) {
        if (!!((int64_t)0)) {
            mlib_removefrommemalloc((int32_t *)(p),n);
        };
        free(p);
        return;
    };
    if (!!(p)) {
        acode = (int64_t)(mlib_sizeindextable[(n)]);
        mlib_smallmemtotal -= (int64_t)(mlib_allocupper[(acode)]);
        if (!!((int64_t)0)) {
            mlib_removefrommemalloc((int32_t *)(p),(int64_t)(mlib_allocupper[(acode)]));
        };
        (*(uint64_t *)(p)) = (uint64_t)((int64_t)(mlib_freelist[(acode)]));
        mlib_freelist[(acode)] = (uint64_t *)(p);
    };
}

void mlib_pcm_freeac(void * p,int64_t alloc) {
    mlib_pcm_free(p,(int64_t)(mlib_allocupper[(alloc)]));
}

void mlib_pcm_copymem4(void * p,void * q,int64_t n) {
    memcpy(p,q,(uint64_t)(n));
}

void mlib_pcm_clearmem(void * p,int64_t n) {
    memset(p,(int64_t)0,(uint64_t)(n));
}

void mlib_pcm_init(void) {
    int64_t j;
    int64_t k;
    int64_t size;
    int64_t av_1;
    int64_t i;
    if (!!((uint64_t)(mlib_pcm_setup))) {
        return;
    };
    mlib_pcm_newblock((int64_t)0);
    L72 :;
    for (i=(int64_t)1;i<=(int64_t)2048;i+=(int64_t)1) {
L73 :;
        j = (int64_t)1;
        k = (int64_t)16;
        L76 :;
        while ((i > k)) {
            k = (k << (int64_t)1);
            ++j;
L77 :;
        }L78 :;
        ;
        mlib_sizeindextable[(i)] = (uint64_t)(j);
L74 :;
    }L75 :;
    ;
    mlib_allocupper[((int64_t)1)] = (uint64_t)((int64_t)16);
    size = (int64_t)16;
    L79 :;
    for (i=(int64_t)2;i<=(int64_t)27;i+=(int64_t)1) {
L80 :;
        size *= (int64_t)2;
        mlib_allocupper[(i)] = (uint64_t)(size);
        if ((size >= (int64_t)33554432)) {
            k = i;
            goto L82 ;
        };
L81 :;
    }L82 :;
    ;
    L83 :;
    for (i=(k + (int64_t)1);i<=(int64_t)300;i+=(int64_t)1) {
L84 :;
        size += (int64_t)33554432;
        if ((size < (int64_t)8589934592)) {
            mlib_allocupper[(i)] = (uint64_t)(size);
            mlib_maxmemory = (uint64_t)(size);
        } else {
            mlib_maxalloccode = (i - (int64_t)1);
            goto L86 ;
        };
L85 :;
    }L86 :;
    ;
    mlib_pcm_setup = (uint64_t)((int64_t)1);
}

int64_t mlib_pcm_getac(int64_t size) {
    if ((size <= (int64_t)2048)) {
        return (int64_t)(mlib_sizeindextable[(size)]);
    };
    size = ((size + (int64_t)255) >> (int64_t)8);
    if ((size <= (int64_t)2048)) {
        return ((int64_t)((uint64_t)(mlib_sizeindextable[(size)])) + (int64_t)8);
    };
    size = ((size + (int64_t)63) >> (int64_t)6);
    if ((size <= (int64_t)2048)) {
        return ((int64_t)((uint64_t)(mlib_sizeindextable[(size)])) + (int64_t)14);
    };
    size = ((((size - (int64_t)2048) + (int64_t)2047) / (int64_t)2048) + (int64_t)22);
    return size;
}

void * mlib_pcm_newblock(int64_t itemsize) {
    static int64_t totalheapsize;
    byte *  p;
    totalheapsize += (int64_t)2097152;
    mlib_alloccode = (int64_t)0;
    p = (byte *)(mlib_allocmem((int64_t)2097152));
    if ((p == 0)) {
        mlib_abortprogram((uint8_t*)"Can't alloc pc heap");
    };
    mlib_pcheapptr = p;
    mlib_pcheapend = (p + (int64_t)2097152);
    if ((mlib_pcheapstart == 0)) {
        mlib_pcheapstart = p;
    };
    mlib_pcheapptr += itemsize;
    return (void *)((uint32_t *)(p));
}

int64_t mlib_pcm_round(int64_t n) {
    static int32_t allocbytes[9] = {(int32_t)0,(int32_t)16,(int32_t)32,(int32_t)64,(int32_t)128,(int32_t)256,(int32_t)512,(int32_t)1024,(int32_t)2048};
    if ((n > (int64_t)2048)) {
        return n;
    } else {
        return (int64_t)(allocbytes[((int64_t)(mlib_sizeindextable[(n)]))]);
    };
}

int64_t mlib_pcm_array(int64_t n) {
    int64_t m;
    if ((n <= (int64_t)2048)) {
        return mlib_pcm_round(n);
    } else {
        m = (int64_t)2048;
        L87 :;
        while ((n > m)) {
            m <<= (int64_t)1;
L88 :;
        }L89 :;
        ;
        return m;
    };
}

void mlib_pcm_printfreelist(int64_t size,uint64_t * p) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"Size: ",NULL);
    msysnewc_m_print_i64(size,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L90 :;
    while (!!(p)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)" ",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_ptr(p,(uint8_t*)"h");
        msysnewc_m_print_end();
        ;
        p = (uint64_t *)((int64_t)((*p)));
L91 :;
    }L92 :;
    ;
    puts((int8_t *)((uint8_t*)""));
}

void mlib_pcm_diags(uint8_t * caption) {
    int64_t m;
    int64_t i;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"HEAP FREELISTS:",NULL);
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    m = (int64_t)16;
    L93 :;
    for (i=(int64_t)1;i<=(int64_t)8;i+=(int64_t)1) {
L94 :;
        mlib_pcm_printfreelist(m,mlib_freelist[(i)]);
        m <<= (int64_t)1;
L95 :;
    }L96 :;
    ;
}

void * mlib_pcm_allocz(int64_t n) {
    void *  p;
    p = mlib_pcm_alloc(n);
    memset(p,(int64_t)0,(uint64_t)(n));
    return p;
}

uint8_t * mlib_pcm_copyheapstring(uint8_t * s) {
    uint8_t *  q;
    int64_t n;
    if ((s == 0)) {
        return (uint8_t *)(0);
    };
    n = ((int64_t)(strlen((int8_t *)(s))) + (int64_t)1);
    q = (uint8_t *)(mlib_pcm_alloc(n));
    memcpy((void *)(q),(void *)(s),(uint64_t)(n));
    return q;
}

uint8_t * mlib_pcm_copyheapstringn(uint8_t * s,int64_t n) {
    uint8_t *  q;
    if ((s == 0)) {
        return (uint8_t *)(0);
    };
    q = (uint8_t *)(mlib_pcm_alloc((n + (int64_t)1)));
    memcpy((void *)(q),(void *)(s),(uint64_t)(n));
    (*(q + n)) = (uint64_t)0u;
    return q;
}

uint8_t * mlib_pcm_copyheapblock(uint8_t * s,int64_t length) {
    uint8_t *  q;
    if ((length == (int64_t)0)) {
        return (uint8_t *)(0);
    };
    q = (uint8_t *)(mlib_pcm_alloc(length));
    memcpy((void *)(q),(void *)(s),(uint64_t)(length));
    return q;
}

static void mlib_addtomemalloc(int32_t * ptr,int64_t size) {
    int64_t i;
    L97 :;
    for (i=(int64_t)1;i<=(int64_t)500000;i+=(int64_t)1) {
L98 :;
        if ((mlib_memalloctable[(i)-1] == ptr)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"ALLOC ERROR:",NULL);
            msysnewc_m_print_ptr(ptr,NULL);
            msysnewc_m_print_str((uint8_t*)"ALREADY ALLOCATED\n\n\n",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startcon();
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startcon();
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            exit((int64_t)2);
        };
        if ((mlib_memalloctable[(i)-1] == 0)) {
            mlib_memalloctable[(i)-1] = ptr;
            mlib_memallocsize[(i)-1] = size;
            return;
        };
L99 :;
    }L100 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"MEMALLOCTABLE FULL\n\n\n\n",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    osnos_os_getch();
    exit((int64_t)3);
}

static void mlib_removefrommemalloc(int32_t * ptr,int64_t size) {
    int64_t i;
    L101 :;
    for (i=(int64_t)1;i<=(int64_t)500000;i+=(int64_t)1) {
L102 :;
        if ((mlib_memalloctable[(i)-1] == ptr)) {
            if (((int64_t)(mlib_memallocsize[(i)-1]) != size)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((uint8_t*)"REMOVE:FOUND",NULL);
                msysnewc_m_print_ptr(ptr,NULL);
                msysnewc_m_print_str((uint8_t*)"IN MEMALLOCTABLE, FREESIZE=",NULL);
                msysnewc_m_print_i64(size,NULL);
                msysnewc_m_print_str((uint8_t*)", BUT STORED AS BLOCK SIZE:",NULL);
                msysnewc_m_print_i64(mlib_memallocsize[(i)-1],NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                msysnewc_m_print_startcon();
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                msysnewc_m_print_startcon();
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                mlib_abortprogram((uint8_t*)"MEMSIZE");
            };
            mlib_memalloctable[(i)-1] = (int32_t *)(0);
            return;
        };
L103 :;
    }L104 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"CAN'T FIND",NULL);
    msysnewc_m_print_ptr(ptr,NULL);
    msysnewc_m_print_str((uint8_t*)"IN MEMALLOCTABLE",NULL);
    msysnewc_m_print_i64(size,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mlib_abortprogram((uint8_t*)"MEM");
    exit((int64_t)4);
}

void * mlib_allocmem(int64_t n) {
    void *  p;
    p = malloc((uint64_t)(n));
    if (!!(p)) {
        return p;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_i64(n,NULL);
    msysnewc_m_print_i64(mlib_memtotal,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mlib_abortprogram((uint8_t*)"Alloc mem failure");
    return 0;
}

void * mlib_reallocmem(void * p,int64_t n) {
    p = realloc(p,(uint64_t)(n));
    if (!!(p)) {
        return p;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_i64(n,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mlib_abortprogram((uint8_t*)"Realloc mem failure");
    return 0;
}

void mlib_abortprogram(uint8_t * s) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(s,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"ABORTING: Press key...",NULL);
    msysnewc_m_print_end();
    ;
    exit((int64_t)5);
}

int64_t mlib_getfilesize(void * handlex) {
    uint32_t p;
    uint32_t size;
    p = (uint64_t)(ftell(handlex));
    fseek(handlex,(int64_t)0,(int64_t)2);
    size = (uint64_t)(ftell(handlex));
    fseek(handlex,(int64_t)((int32_t)(p)),(int64_t)0);
    return (int64_t)(size);
}

void mlib_readrandom(void * handlex,byte * mem,int64_t offset,int64_t size) {
    int64_t a;
    fseek(handlex,(int64_t)((int32_t)(offset)),(int64_t)0);
    a = (int64_t)(fread((void *)(mem),(uint64_t)((int64_t)1),(uint64_t)(size),handlex));
}

int64_t mlib_writerandom(void * handlex,byte * mem,int64_t offset,int64_t size) {
    fseek(handlex,(int64_t)((int32_t)(offset)),(int64_t)0);
    return (int64_t)(fwrite((void *)(mem),(uint64_t)((int64_t)1),(uint64_t)(size),handlex));
}

int64_t mlib_setfilepos(void * file,int64_t offset) {
    return (int64_t)(fseek(file,(int64_t)((int32_t)(offset)),(int64_t)0));
}

int64_t mlib_getfilepos(void * file) {
    return (int64_t)(ftell(file));
}

byte * mlib_readfile(uint8_t * filename) {
    void *  f;
    int64_t size;
    byte *  m;
    byte *  p;
    f = fopen((int8_t *)(filename),(int8_t *)((uint8_t*)"rb"));
    if ((f == 0)) {
        return (byte *)(0);
    };
    mlib_rfsize = (size = mlib_getfilesize(f));
    m = (byte *)(malloc((uint64_t)((size + (int64_t)4))));
    if ((m == 0)) {
        return (byte *)(0);
    };
    mlib_readrandom(f,m,(int64_t)0,size);
    p = (m + size);
    (*p) = (uint64_t)((int64_t)0);
    (*(p + (int64_t)1)) = (uint64_t)((int64_t)26);
    (*(p + (int64_t)2)) = (uint64_t)((int64_t)0);
    fclose(f);
    return m;
}

int64_t mlib_writefile(uint8_t * filename,byte * data,int64_t size) {
    void *  f;
    int64_t n;
    f = fopen((int8_t *)(filename),(int8_t *)((uint8_t*)"wb"));
    if ((f == 0)) {
        return (int64_t)0;
    };
    n = mlib_writerandom(f,data,(int64_t)0,size);
    fclose(f);
    return n;
}

int64_t mlib_checkfile(uint8_t * file) {
    void *  f;
    if (!!((f = fopen((int8_t *)(file),(int8_t *)((uint8_t*)"rb"))))) {
        fclose(f);
        return (int64_t)1;
    };
    return (int64_t)0;
}

void mlib_readlinen(void * handlex,uint8_t * buffer,int64_t size) {
    int64_t ch;
    uint8_t *  p;
    int64_t n;
    byte crseen;
    if ((handlex == 0)) {
        handlex = osnos_os_getstdin();
    };
    if ((handlex == 0)) {
        n = (int64_t)0;
        p = buffer;
        L105 :;
        while (1) {
            ch = (int64_t)(getchar());
            if ((((ch == (int64_t)13) || (ch == (int64_t)10)) || (ch == (int64_t)-1))) {
                (*p) = (uint64_t)0u;
                return;
            };
            (*p++) = (uint64_t)(ch);
            ++n;
            if ((n >= (size - (int64_t)2))) {
                (*p) = (uint64_t)0u;
                return;
            };
        }L106 :;
        ;
    };
    (*buffer) = (uint64_t)0u;
    if ((fgets((int8_t *)(buffer),(size - (int64_t)2),handlex) == 0)) {
        return;
    };
    n = (int64_t)(strlen((int8_t *)(buffer)));
    if ((n == (int64_t)0)) {
        return;
    };
    p = ((buffer + n) - (int64_t)1);
    crseen = (uint64_t)((int64_t)0);
    L107 :;
    while (((p >= buffer) && (((int64_t)((*p)) == (int64_t)13) || ((int64_t)((*p)) == (int64_t)10)))) {
        if ((((int64_t)((*p)) == (int64_t)13) || ((int64_t)((*p)) == (int64_t)10))) {
            crseen = (uint64_t)((int64_t)1);
        };
        (*p--) = (uint64_t)0u;
L108 :;
    }L109 :;
    ;
    if ((!(!!((uint64_t)(crseen))) && ((n + (int64_t)4) > size))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_i64(size,NULL);
        msysnewc_m_print_i64(n,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mlib_abortprogram((uint8_t*)"line too long");
    };
}

void mlib_iconvlcn(uint8_t * s,int64_t n) {
    int64_t av_1;
    av_1 = n;
    while (av_1-- > 0) {
L110 :;
        (*s) = (uint64_t)(tolower((int64_t)((int32_t)((*s)))));
        ++s;
L111 :;
    }L112 :;
    ;
}

void mlib_iconvucn(uint8_t * s,int64_t n) {
    int64_t av_1;
    av_1 = n;
    while (av_1-- > 0) {
L113 :;
        (*s) = (uint64_t)(toupper((int64_t)((int32_t)((*s)))));
        ++s;
L114 :;
    }L115 :;
    ;
}

void mlib_convlcstring(uint8_t * s) {
    L116 :;
    while (!!((uint64_t)((*s)))) {
        (*s) = (uint64_t)(tolower((int64_t)((int32_t)((*s)))));
        ++s;
L117 :;
    }L118 :;
    ;
}

void mlib_convucstring(uint8_t * s) {
    L119 :;
    while (!!((uint64_t)((*s)))) {
        (*s) = (uint64_t)(toupper((int64_t)((int32_t)((*s)))));
        ++s;
L120 :;
    }L121 :;
    ;
}

uint8_t * mlib_changeext(uint8_t * s,uint8_t * newext) {
    static uint8_t newfile[260];
    uint8_t newext2[32];
    uint8_t *  sext;
    int64_t n;
    strcpy((int8_t *)(&newfile[((int64_t)1)-1]),(int8_t *)(s));
    if (((int64_t)((*newext))==(int64_t)0)) {
        newext2[((int64_t)1)-1] = (uint64_t)0u;
        newext2[((int64_t)2)-1] = (uint64_t)0u;
    }else if (((int64_t)((*newext))==(int64_t)46)) {
        strcpy((int8_t *)(&newext2[((int64_t)1)-1]),(int8_t *)(newext));
    } else {
        strcpy((int8_t *)(&newext2[((int64_t)1)-1]),(int8_t *)((uint8_t*)"."));
        strcat((int8_t *)(&newext2[((int64_t)1)-1]),(int8_t *)(newext));
    };
    sext = mlib_extractext(s,(int64_t)1);
    if (((int64_t)((*sext))==(int64_t)0)) {
        strcat((int8_t *)(&newfile[((int64_t)1)-1]),(int8_t *)(&newext2[((int64_t)1)-1]));
    }else if (((int64_t)((*sext))==(int64_t)46)) {
        strcat((int8_t *)(&newfile[((int64_t)1)-1]),(int8_t *)(&newext2[((int64_t)2)-1]));
    } else {
        n = ((sext - s) - (int64_t)2);
        strcpy((int8_t *)(((&newfile[((int64_t)1)-1] + n) + (int64_t)1)),(int8_t *)(&newext2[((int64_t)1)-1]));
    };
    return &newfile[((int64_t)1)-1];
}

uint8_t * mlib_extractext(uint8_t * s,int64_t period) {
    uint8_t *  t;
    uint8_t *  u;
    t = mlib_extractfile(s);
    if (((int64_t)((*t)) == (int64_t)0)) {
        return (uint8_t*)"";
    };
    u = ((t + (int64_t)(strlen((int8_t *)(t)))) - (int64_t)1);
    L122 :;
    while ((u >= t)) {
        if (((uint64_t)((*u)) == '.')) {
            if (((int64_t)((*(u + (int64_t)1))) == (int64_t)0)) {
                return (!!(period)?(uint8_t*)".":(uint8_t*)"");
            };
            return (u + (int64_t)1);
        };
        --u;
L123 :;
    }L124 :;
    ;
    return (uint8_t*)"";
}

uint8_t * mlib_extractpath(uint8_t * s) {
    static uint8_t str[260];
    uint8_t *  t;
    int64_t n;
    t = ((s + (int64_t)(strlen((int8_t *)(s)))) - (int64_t)1);
    L125 :;
    while ((t >= s)) {
        switch ((int64_t)((*t))) {
        case 92:;
        case 47:;
        case 58:;
        {
            n = ((t - s) + (int64_t)1);
            memcpy((void *)(str),(void *)(s),(uint64_t)(n));
            str[(n)] = (uint64_t)0u;
            return str;
        }break;
        default: {
        }
        } //SW
;
        --t;
L126 :;
    }L127 :;
    ;
    return (uint8_t*)"";
}

uint8_t * mlib_extractfile(uint8_t * s) {
    uint8_t *  t;
    t = mlib_extractpath(s);
    if (((int64_t)((*t)) == (int64_t)0)) {
        return s;
    };
    return (s + (int64_t)(strlen((int8_t *)(t))));
}

uint8_t * mlib_extractbasefile(uint8_t * s) {
    static uint8_t str[100];
    uint8_t *  f;
    uint8_t *  e;
    int64_t n;
    int64_t flen;
    f = mlib_extractfile(s);
    flen = (int64_t)(strlen((int8_t *)(f)));
    if ((flen == (int64_t)0)) {
        return (uint8_t*)"";
    };
    e = mlib_extractext(f,(int64_t)0);
    if (!!((uint64_t)((*e)))) {
        n = ((flen - (int64_t)(strlen((int8_t *)(e)))) - (int64_t)1);
        memcpy((void *)(&str),(void *)(f),(uint64_t)(n));
        str[(n)] = (uint64_t)0u;
        return str;
    };
    if (((uint64_t)((*((f + flen) - (int64_t)1))) == '.')) {
        memcpy((void *)(&str),(void *)(f),(uint64_t)((flen - (int64_t)1)));
        str[((flen - (int64_t)1))] = (uint64_t)0u;
        return str;
    };
    return f;
}

uint8_t * mlib_addext(uint8_t * s,uint8_t * newext) {
    uint8_t *  sext;
    sext = mlib_extractext(s,(int64_t)1);
    if (((int64_t)((*sext)) == (int64_t)0)) {
        return mlib_changeext(s,newext);
    };
    return s;
}

void * mlib_alloctable(int64_t n,int64_t size) {
    void *  p;
    p = malloc((uint64_t)(((n + (int64_t)1) * size)));
    if (!(!!(p))) {
        mlib_abortprogram((uint8_t*)"Alloctable failure");
    };
    return p;
}

void * mlib_zalloctable(int64_t n,int64_t size) {
    int64_t *  p;
    p = (int64_t *)(mlib_alloctable(n,size));
    mlib_pcm_clearmem((void *)(p),((n + (int64_t)1) * size));
    return (void *)(p);
}

void mlib_checkfreelists(uint8_t * s) {
    uint64_t *  p;
    uint64_t *  q;
    int64_t aa;
    int64_t i;
    L128 :;
    for (i=(int64_t)2;i<=(int64_t)2;i+=(int64_t)1) {
L129 :;
        p = mlib_freelist[(i)];
        L132 :;
        while (!!(p)) {
            aa = (int64_t)(p);
            if (((aa > (int64_t)4294967295) || (aa < (int64_t)100))) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str(s,NULL);
                msysnewc_m_print_str((uint8_t*)"FREE LIST ERROR",NULL);
                msysnewc_m_print_i64(i,NULL);
                msysnewc_m_print_ptr(p,NULL);
                msysnewc_m_print_ptr(q,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            };
            q = p;
            p = (uint64_t *)((int64_t)((*p)));
L133 :;
        }L134 :;
        ;
L130 :;
    }L131 :;
    ;
}

void * mlib_pcm_alloc32(void) {
    mlib_allocbytes = (int64_t)32;
    return mlib_pcm_alloc((int64_t)32);
}

void mlib_pcm_free32(void * p) {
    mlib_smallmemtotal -= (int64_t)32;
    if (!!((int64_t)0)) {
        mlib_removefrommemalloc((int32_t *)(p),(int64_t)32);
    };
    (*(uint64_t *)(p)) = (uint64_t)((int64_t)(mlib_freelist[((int64_t)2)]));
    mlib_freelist[((int64_t)2)] = (uint64_t *)(p);
}

void mlib_outbyte(void * f,int64_t x) {
    fwrite((void *)(&x),(uint64_t)((int64_t)1),(uint64_t)((int64_t)1),f);
}

void mlib_outword16(void * f,uint64_t x) {
    fwrite((void *)(&x),(uint64_t)((int64_t)2),(uint64_t)((int64_t)1),f);
}

void mlib_outword(void * f,uint64_t x) {
    fwrite((void *)(&x),(uint64_t)((int64_t)4),(uint64_t)((int64_t)1),f);
}

void mlib_outword64(void * f,uint64_t x) {
    fwrite((void *)(&x),(uint64_t)((int64_t)8),(uint64_t)((int64_t)1),f);
}

int64_t mlib_myeof(void * f) {
    int64_t c;
    c = (int64_t)(fgetc(f));
    if ((c == (int64_t)-1)) {
        return (int64_t)1;
    };
    ungetc((int64_t)((int32_t)(c)),f);
    return (int64_t)0;
}

void * mlib_pcm_smallallocz(int64_t n) {
    byte *  p;
    if (((mlib_alloccode = (int64_t)(mlib_sizeindextable[(n)])) == (int64_t)0)) {
        mlib_alloccode = (int64_t)1;
    };
    mlib_allocbytes = (int64_t)(mlib_allocupper[(mlib_alloccode)]);
    p = mlib_pcheapptr;
    mlib_pcheapptr += mlib_allocbytes;
    if ((mlib_pcheapptr >= mlib_pcheapend)) {
        p = (byte *)(mlib_pcm_newblock(mlib_allocbytes));
        memset((void *)(p),(int64_t)0,(uint64_t)(n));
        return (void *)(p);
    };
    memset((void *)(p),(int64_t)0,(uint64_t)(n));
    return (void *)(p);
}

void * mlib_pcm_smallalloc(int64_t n) {
    byte *  p;
    if (((mlib_alloccode = (int64_t)(mlib_sizeindextable[(n)])) == (int64_t)0)) {
        mlib_alloccode = (int64_t)1;
    };
    mlib_allocbytes = (int64_t)(mlib_allocupper[(mlib_alloccode)]);
    p = mlib_pcheapptr;
    mlib_pcheapptr += mlib_allocbytes;
    if ((mlib_pcheapptr >= mlib_pcheapend)) {
        p = (byte *)(mlib_pcm_newblock(mlib_allocbytes));
        return (void *)(p);
    };
    return (void *)(p);
}

void mlib_strbuffer_add(struct mlib_strbuffer * dest,uint8_t * s,int64_t n) {
    int64_t newlen;
    int64_t oldlen;
    uint8_t *  newptr;
    if ((n == (int64_t)0)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"N=0",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    if ((n == (int64_t)-1)) {
        n = (int64_t)(strlen((int8_t *)(s)));
    };
    oldlen = (int64_t)((*dest).length);
    if ((oldlen == (int64_t)0)) {
        (*dest).strptr = (uint8_t *)(mlib_pcm_alloc((n + (int64_t)1)));
        (*dest).allocated = mlib_allocbytes;
        (*dest).length = n;
        memcpy((void *)((*dest).strptr),(void *)(s),(uint64_t)(n));
        (*((*dest).strptr + n)) = (uint64_t)0u;
        return;
    };
    newlen = (oldlen + n);
    if (((newlen + (int64_t)1) > (int64_t)((*dest).allocated))) {
        newptr = (uint8_t *)(mlib_pcm_alloc((newlen + (int64_t)1)));
        memcpy((void *)(newptr),(void *)((*dest).strptr),(uint64_t)(oldlen));
        (*dest).strptr = newptr;
        (*dest).allocated = mlib_allocbytes;
    };
    memcpy((void *)(((*dest).strptr + oldlen)),(void *)(s),(uint64_t)(n));
    (*((*dest).strptr + newlen)) = (uint64_t)0u;
    (*dest).length = newlen;
}

void mlib_gs_init(struct mlib_strbuffer * dest) {
    mlib_pcm_clearmem((void *)(dest),(int64_t)16);
}

void mlib_gs_free(struct mlib_strbuffer * dest) {
    if (!!((int64_t)((*dest).allocated))) {
        mlib_pcm_free((void *)((*dest).strptr),(int64_t)((*dest).allocated));
    };
}

void mlib_gs_str(struct mlib_strbuffer * dest,uint8_t * s) {
    mlib_strbuffer_add(dest,s,(int64_t)-1);
}

void mlib_gs_char(struct mlib_strbuffer * dest,int64_t c) {
    uint8_t s[16];
    s[((int64_t)1)-1] = (uint64_t)(c);
    s[((int64_t)2)-1] = (uint64_t)0u;
    mlib_strbuffer_add(dest,s,(int64_t)1);
}

void mlib_gs_strn(struct mlib_strbuffer * dest,uint8_t * s,int64_t length) {
    mlib_strbuffer_add(dest,s,length);
}

void mlib_gs_strvar(struct mlib_strbuffer * dest,struct mlib_strbuffer * s) {
    mlib_strbuffer_add(dest,(*s).strptr,(int64_t)-1);
}

void mlib_gs_strint(struct mlib_strbuffer * dest,int64_t a) {
    mlib_strbuffer_add(dest,msysnewc_strint(a,(uint8_t *)(0)),(int64_t)-1);
}

void mlib_gs_strln(struct mlib_strbuffer * dest,uint8_t * s) {
    mlib_gs_str(dest,s);
    mlib_gs_line(dest);
}

void mlib_gs_strsp(struct mlib_strbuffer * dest,uint8_t * s) {
    mlib_gs_str(dest,s);
    mlib_gs_str(dest,(uint8_t*)" ");
}

void mlib_gs_line(struct mlib_strbuffer * dest) {
    mlib_strbuffer_add(dest,(uint8_t*)"\r\n",(int64_t)-1);
}

int64_t mlib_gs_getcol(struct mlib_strbuffer * dest) {
    return (int64_t)((*dest).length);
}

void mlib_gs_leftstr(struct mlib_strbuffer * dest,uint8_t * s,int64_t w,int64_t padch) {
    int64_t col;
    int64_t i;
    int64_t n;
    int64_t slen;
    uint8_t str[2560];
    col = (int64_t)((*dest).length);
    strcpy((int8_t *)(str),(int8_t *)(s));
    slen = (int64_t)(strlen((int8_t *)(s)));
    n = (w - slen);
    if ((n > (int64_t)0)) {
        L135 :;
        for (i=(int64_t)1;i<=n;i+=(int64_t)1) {
L136 :;
            str[((slen + i))-1] = (uint64_t)(padch);
L137 :;
        }L138 :;
        ;
        str[(((slen + n) + (int64_t)1))-1] = (uint64_t)0u;
    };
    mlib_gs_str(dest,str);
}

void mlib_gs_leftint(struct mlib_strbuffer * dest,int64_t a,int64_t w,int64_t padch) {
    mlib_gs_leftstr(dest,msysnewc_strint(a,(uint8_t *)(0)),w,padch);
}

void mlib_gs_padto(struct mlib_strbuffer * dest,int64_t col,int64_t ch) {
    int64_t n;
    uint8_t str[2560];
    int64_t i;
    n = (col - (int64_t)((*dest).length));
    if ((n <= (int64_t)0)) {
        return;
    };
    L139 :;
    for (i=(int64_t)1;i<=n;i+=(int64_t)1) {
L140 :;
        str[(i)-1] = (uint64_t)(ch);
L141 :;
    }L142 :;
    ;
    str[((n + (int64_t)1))-1] = (uint64_t)0u;
    mlib_gs_str(dest,str);
}

void mlib_gs_println(struct mlib_strbuffer * dest,void * f) {
    (*((*dest).strptr + (int64_t)((*dest).length))) = (uint64_t)0u;
    if ((f == 0)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((*dest).strptr,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((uint8_t*)"\r",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    } else {
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((*dest).strptr,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((uint8_t*)"\r",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
}

int64_t mlib_nextcmdparam(int64_t * paramno,uint8_t * * name,uint8_t * * value,uint8_t * defext) {
    static int64_t infile = (int64_t)0;
    static uint8_t *  filestart = 0;
    static uint8_t *  fileptr = 0;
    static byte colonseen = (uint8_t)0u;
    uint8_t *  q;
    uint8_t *  item;
    uint8_t *  fileext;
    int64_t length;
    static uint8_t str[300];
    //reenter:
L143 :;
;
    (*value) = (uint8_t *)(0);
    (*name) = (uint8_t *)(0);
    if (!!(infile)) {
        if ((mlib_readnextfileitem(&fileptr,&item) == (int64_t)0)) {
            free((void *)(filestart));
            infile = (int64_t)0;
            goto L143 ;
;
        };
    } else {
        if (((*paramno) > msysnewc_nsysparams)) {
            return (int64_t)0;
        };
        item = msysnewc_sysparams[((*paramno))-1];
        ++(*paramno);
        length = (int64_t)(strlen((int8_t *)(item)));
        if (((uint64_t)((*item)) == '@')) {
            filestart = (fileptr = (uint8_t *)(mlib_readfile((item + (int64_t)1))));
            if ((filestart == 0)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((uint8_t*)"Can't open",NULL);
                msysnewc_m_print_str(item,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                exit((int64_t)7);
            };
            infile = (int64_t)1;
            goto L143 ;
;
        };
        if (((uint64_t)((*item)) == ':')) {
            colonseen = (uint64_t)((int64_t)1);
            return (int64_t)4;
        };
    };
    (*value) = (uint8_t *)(0);
    if (((uint64_t)((*item)) == '-')) {
        (*name) = (item + (!!((uint64_t)(colonseen))?(int64_t)0:(int64_t)1));
        q = (uint8_t *)(strchr((int8_t *)(item),(int64_t)58));
        if (!(!!(q))) {
            q = (uint8_t *)(strchr((int8_t *)(item),(int64_t)61));
        };
        if (!!(q)) {
            (*value) = (q + (int64_t)1);
            (*q) = (uint64_t)0u;
        };
        return (!!((uint64_t)(colonseen))?(int64_t)5:(int64_t)1);
    };
    fileext = mlib_extractext(item,(int64_t)0);
    (*name) = item;
    if (((int64_t)((*fileext)) == (int64_t)0)) {
        strcpy((int8_t *)(str),(int8_t *)((*name)));
        if ((!!(defext) && !(!!((uint64_t)(colonseen))))) {
            (*name) = mlib_addext(str,defext);
        };
    } else if (!!(mlib_eqstring(fileext,(uint8_t*)"dll"))) {
        return (!!((uint64_t)(colonseen))?(int64_t)5:(int64_t)3);
    };
    return (!!((uint64_t)(colonseen))?(int64_t)5:(int64_t)2);
}

static int64_t mlib_readnextfileitem(uint8_t * * fileptr,uint8_t * * item) {
    uint8_t *  p;
    uint8_t *  pstart;
    uint8_t *  pend;
    int64_t n;
    static uint8_t str[256];
    p = (*fileptr);
    //reenter:
L144 :;
;
    L145 :;
    while (1) {
        if (((int64_t)((*p))==(int64_t)32) || ((int64_t)((*p))==(int64_t)9) || ((int64_t)((*p))==(int64_t)13) || ((int64_t)((*p))==(int64_t)10)) {
            ++p;
        }else if (((int64_t)((*p))==(int64_t)26) || ((int64_t)((*p))==(int64_t)0)) {
            return (int64_t)0;
        } else {
            goto L146 ;
        };
    }L146 :;
    ;
    if (((int64_t)((*p))==(int64_t)33) || ((int64_t)((*p))==(int64_t)35)) {
        ++p;
        L147 :;
        if (((int64_t)((*p++))==(int64_t)10)) {
            goto L144 ;
;
        }else if (((int64_t)((*p++))==(int64_t)26) || ((int64_t)((*p++))==(int64_t)0)) {
            (*fileptr) = (p - (int64_t)1);
            return (int64_t)0;
        } else {
        }goto L147 ;
L148 :;
        ;
    };
    if (((int64_t)((*p))==(int64_t)34)) {
        pstart = ++p;
        L149 :;
        while (1) {
            if (((int64_t)((*p))==(int64_t)0) || ((int64_t)((*p))==(int64_t)26)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((uint8_t*)"Unexpected EOF in @file",NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                exit((int64_t)8);
            }else if (((int64_t)((*p))==(int64_t)34)) {
                pend = p++;
                if (((uint64_t)((*p)) == ',')) {
                    ++p;
                };
                goto L150 ;
            };
            ++p;
        }L150 :;
        ;
    } else {
        pstart = p;
        L151 :;
        while (1) {
            if (((int64_t)((*p))==(int64_t)0) || ((int64_t)((*p))==(int64_t)26)) {
                pend = p;
                goto L152 ;
            }else if (((int64_t)((*p))==(int64_t)32) || ((int64_t)((*p))==(int64_t)9) || ((int64_t)((*p))==(int64_t)44) || ((int64_t)((*p))==(int64_t)13) || ((int64_t)((*p))==(int64_t)10)) {
                pend = p++;
                goto L152 ;
            };
            ++p;
        }L152 :;
        ;
    };
    n = (pend - pstart);
    if ((n >= (int64_t)256)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"@file item too long",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit((int64_t)9);
    };
    memcpy((void *)(str),(void *)(pstart),(uint64_t)(n));
    str[((n + (int64_t)1))-1] = (uint64_t)0u;
    (*item) = str;
    (*fileptr) = p;
    return (int64_t)1;
}

void mlib_ipadstr(uint8_t * s,int64_t width,uint8_t * padchar) {
    int64_t n;
    int64_t av_1;
    n = (int64_t)(strlen((int8_t *)(s)));
    av_1 = (width - n);
    while (av_1-- > 0) {
L153 :;
        strcat((int8_t *)(s),(int8_t *)(padchar));
L154 :;
    }L155 :;
    ;
}

uint8_t * mlib_padstr(uint8_t * s,int64_t width,uint8_t * padchar) {
    static uint8_t str[256];
    strcpy((int8_t *)(str),(int8_t *)(s));
    mlib_ipadstr(str,width,padchar);
    return str;
}

uint8_t * mlib_chr(int64_t c) {
    static uint8_t str[8];
    str[((int64_t)1)-1] = (uint64_t)(c);
    str[((int64_t)2)-1] = (uint64_t)0u;
    return str;
}

int64_t mlib_cmpstring(uint8_t * s,uint8_t * t) {
    int64_t res;
    if (((res = (int64_t)(strcmp((int8_t *)(s),(int8_t *)(t)))) < (int64_t)0)) {
        return (int64_t)-1;
    } else if ((res > (int64_t)0)) {
        return (int64_t)1;
    } else {
        return (int64_t)0;
    };
}

int64_t mlib_cmpstringn(uint8_t * s,uint8_t * t,int64_t n) {
    int64_t res;
    if (((res = (int64_t)(strncmp((int8_t *)(s),(int8_t *)(t),(uint64_t)(n)))) < (int64_t)0)) {
        return (int64_t)-1;
    } else if ((res > (int64_t)0)) {
        return (int64_t)1;
    } else {
        return (int64_t)0;
    };
}

int64_t mlib_eqstring(uint8_t * s,uint8_t * t) {
    return ((int64_t)(strcmp((int8_t *)(s),(int8_t *)(t))) == (int64_t)0);
}

int64_t mlib_cmpbytes(void * p,void * q,int64_t n) {
    int64_t res;
    if (((res = (int64_t)(memcmp(p,q,(uint64_t)(n)))) < (int64_t)0)) {
        return (int64_t)-1;
    } else if ((res > (int64_t)0)) {
        return (int64_t)1;
    } else {
        return (int64_t)0;
    };
}

int64_t mlib_eqbytes(void * p,void * q,int64_t n) {
    return ((int64_t)(memcmp(p,q,(uint64_t)(n))) == (int64_t)0);
}

void mlib_mseed(uint64_t a,uint64_t b) {
    mlib_seed[((int64_t)1)-1] = (int64_t)(a);
    if (!!(b)) {
        mlib_seed[((int64_t)2)-1] = (int64_t)(b);
    } else {
        mlib_seed[((int64_t)2)-1] ^= (int64_t)(a);
    };
}

uint64_t mlib_mrandom(void) {
    uint64_t x;
    uint64_t y;
    x = (uint64_t)(mlib_seed[((int64_t)1)-1]);
    y = (uint64_t)(mlib_seed[((int64_t)2)-1]);
    mlib_seed[((int64_t)1)-1] = (int64_t)(y);
    x ^= (x << (int64_t)23);
    mlib_seed[((int64_t)2)-1] = (int64_t)((((x ^ y) ^ (x >> (int64_t)17)) ^ (y >> (int64_t)26)));
    return (uint64_t)((mlib_seed[((int64_t)2)-1] + (int64_t)(y)));
}

int64_t mlib_mrandomp(void) {
    return (int64_t)((mlib_mrandom() & (uint64_t)9223372036854775807u));
}

int64_t mlib_mrandomint(int64_t n) {
    return (mlib_mrandomp() % n);
}

int64_t mlib_mrandomrange(int64_t a,int64_t b) {
    int64_t span;
    span = ((b - a) + (int64_t)1);
    if ((span <= (int64_t)0)) {
        return (int64_t)0;
    };
    return ((mlib_mrandomp() % span) + a);
}

double mlib_mrandomreal(void) {
    double x;
    L156 :;
    do {
        x = ((double)(mlib_mrandomp()) / (double)9223372036854775800.);
L157 :;
    } while (!(x != (double)1.));L158 :;
    ;
    return x;
}

double mlib_mrandomreal1(void) {
    return (double)((mlib_mrandomp() / (int64_t)((uint64_t)9223372036854775807u)));
}

byte * mlib_checkpackfile(void) {
    int64_t a;
    int64_t offset;
    uint8_t exefile[300];
    byte *  packexeptr;
    int64_t packexesize;
    uint8_t *  packfilename;
    int64_t packfilesize;
    byte *  packfileptr;
    strcpy((int8_t *)(&exefile[((int64_t)1)-1]),(int8_t *)(osnos_os_gethostname()));
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"Attempting to open",NULL);
    msysnewc_m_print_ptr(&exefile,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    packexeptr = mlib_readfile(&exefile[((int64_t)1)-1]);
    if (!(!!(packexeptr))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"Can't open",NULL);
        msysnewc_m_print_ptr(&exefile,NULL);
        msysnewc_m_print_ptr(&packexeptr,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit(0);
    };
    packexesize = mlib_rfsize;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"File read OK. Size",NULL);
    msysnewc_m_print_i64(packexesize,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    a = (int64_t)((*(int32_t *)((packexeptr + (packexesize - (int64_t)4)))));
    if ((a != (int64_t)1262568272)) {
        free((void *)(packexeptr));
        packfileptr = (byte *)(0);
        return (byte *)(0);
    };
    offset = (int64_t)((*(int32_t *)((packexeptr + (packexesize - (int64_t)8)))));
    packfilename = (uint8_t *)((packexeptr + offset));
    offset += ((int64_t)(strlen((int8_t *)(packfilename))) + (int64_t)1);
    packfilesize = (int64_t)((*(int32_t *)((packexeptr + offset))));
    packfileptr = ((packexeptr + offset) + (int64_t)4);
    return packfileptr;
}

void osnos_os_init(void) {
    osnos_init_flag = (int64_t)1;
}

int64_t osnos_os_execwait(uint8_t * cmdline,int64_t newconsole,uint8_t * workdir) {
    return (int64_t)(system((int8_t *)(cmdline)));
}

int64_t osnos_os_execcmd(uint8_t * cmdline,int64_t newconsole) {
    return (int64_t)(system((int8_t *)(cmdline)));
}

int64_t osnos_os_getch(void) {
    return (int64_t)0;
}

int64_t osnos_os_kbhit(void) {
    mlib_abortprogram((uint8_t*)"kbhit");
    return (int64_t)0;
}

void osnos_os_flushkeys(void) {
    mlib_abortprogram((uint8_t*)"flushkeys");
}

void * osnos_os_getconsolein(void) {
    return 0;
}

void * osnos_os_getconsoleout(void) {
    return 0;
}

void * osnos_os_proginstance(void) {
    mlib_abortprogram((uint8_t*)"PROGINST");
    return 0;
}

uint64_t osnos_os_getdllinst(uint8_t * name) {
    return (uint64_t)((int64_t)0);
}

void (*osnos_os_getdllprocaddr(int64_t hinst,uint8_t * name))(void) {
    static struct osnos_os_getdllprocaddr_rec table[23] = {
    {(uint8_t*)"malloc",(void *)(&malloc)},
    {(uint8_t*)"realloc",(void *)(&realloc)},
    {(uint8_t*)"free",(void *)(&free)},
    {(uint8_t*)"printf",(void *)(&printf)},
    {(uint8_t*)"puts",(void *)(&puts)},
    {(uint8_t*)"fgetc",(void *)(&fgetc)},
    {(uint8_t*)"fputc",(void *)(&fputc)},
    {(uint8_t*)"getchar",(void *)(&getchar)},
    {(uint8_t*)"fopen",(void *)(&fopen)},
    {(uint8_t*)"fclose",(void *)(&fclose)},
    {(uint8_t*)"fseek",(void *)(&fseek)},
    {(uint8_t*)"ftell",(void *)(&ftell)},
    {(uint8_t*)"fread",(void *)(&fread)},
    {(uint8_t*)"fwrite",(void *)(&fwrite)},
    {(uint8_t*)"clock",(void *)(&clock)},
    {(uint8_t*)"isalpha",(void *)(&isalpha)},
    {(uint8_t*)"tolower",(void *)(&tolower)},
    {(uint8_t*)"feof",(void *)(&feof)},
    {(uint8_t*)"memset",(void *)(&memset)},
    {(uint8_t*)"memcpy",(void *)(&memcpy)},
    {(uint8_t*)"ungetc",(void *)(&ungetc)},
    {(uint8_t*)"remove",(void *)(&remove)},
    {(uint8_t*)"system",(void *)(&system)}
};
    int64_t av_1;
    int64_t i;
    L159 :;
    for (i=(int64_t)1;i<=(int64_t)23;i+=(int64_t)1) {
L160 :;
        if (!!(mlib_eqstring(table[(i)-1].name,name))) {
            return (void (*)(void))(table[(i)-1].addr);
        };
L161 :;
    }L162 :;
    ;
    return (void (*)(void))(0);
}

void osnos_os_initwindows(void) {
}

int64_t osnos_os_getchx(void) {
    mlib_abortprogram((uint8_t*)"getchx");
    return (int64_t)0;
}

uint8_t * osnos_os_getos(void) {
    return (uint8_t*)"NO-OS";
}

int64_t osnos_os_getoscode(void) {
    return (int64_t)78;
}

int64_t osnos_os_iswindows(void) {
    static int64_t iswindows = (int64_t)-1;
    void *  f;
    if ((iswindows == (int64_t)-1)) {
        f = fopen((int8_t *)((uint8_t*)"c:/windows/notepad.exe"),(int8_t *)((uint8_t*)"rb"));
        if (!!(f)) {
            fclose(f);
            iswindows = (int64_t)1;
        } else {
            iswindows = (int64_t)0;
        };
    };
    return iswindows;
}

int64_t osnos_os_shellexec(uint8_t * opc,uint8_t * file) {
    mlib_abortprogram((uint8_t*)"SHELL EXEC");
    return (int64_t)0;
}

void osnos_os_sleep(int64_t a) {
    mlib_abortprogram((uint8_t*)"sleep");
}

void * osnos_os_getstdin(void) {
    return 0;
}

void * osnos_os_getstdout(void) {
    return 0;
}

uint8_t * osnos_os_gethostname(void) {
    return (uint8_t*)"";
}

int64_t osnos_os_gethostsize(void) {
    return (int64_t)64;
}

uint8_t * osnos_os_getmpath(void) {
    return (uint8_t*)"";
}

void osnos_os_exitprocess(int64_t x) {
    exit(0);
}

int64_t osnos_os_gettimestamp(void) {
    return (int64_t)(clock());
}

int64_t osnos_os_gettickcount(void) {
    return (int64_t)(clock());
}

int64_t osnos_os_clock(void) {
    if (!!(osnos_os_iswindows())) {
        return (int64_t)(clock());
    } else {
        return ((int64_t)(clock()) / (int64_t)1000);
    };
}

int64_t osnos_os_getclockspersec(void) {
    return (!!(osnos_os_iswindows())?(int64_t)1000:(int64_t)1000000);
}

void osnos_os_setmesshandler(void * addr) {
    mlib_abortprogram((uint8_t*)"SETMESSHANDLER");
}

int64_t osnos_os_filelastwritetime(uint8_t * filename) {
    return (int64_t)0;
}

int64_t osnos_os_hpcounter(void) {
    return (int64_t)1;
}

int64_t osnos_os_hpfrequency(void) {
    return (int64_t)1;
}

void osnos_os_getsystime(void * tm) {
}

void osnos_os_peek(void) {
}

int64_t pci_runpcl(uint8_t * filename,int64_t filetype) {
    byte *  pcfile;
    int64_t stopcode;
    uint8_t *  pcfilename;
    if (((pci_dispatch_type == (int64_t)5) && !(!!(pc_assemc_asmavailable())))) {
        pci_dispatch_type = (int64_t)2;
    };
    pci_run_initdata();
    if ((filetype==(int64_t)1)) {
        pcfile = mlib_readfile(filename);
        if ((pcfile == 0)) {
            return (int64_t)-1;
        };
    }else if ((filetype==(int64_t)4)) {
        pcfile = (byte *)(filename);
    };
    if (!(!!(pci_loadpcfile(pcfile)))) {
        return (int64_t)-3;
    };
    if ((filetype == (int64_t)3)) {
        remove((int8_t *)(pcfilename));
    };
    stopcode = pci_runpcprogram();
    return stopcode;
}

void pci_run_initdata(void) {
    static int64_t initialised = (int64_t)0;
    if (!!(initialised)) {
        return;
    };
    if ((pc_decls_ncmdparams == (int64_t)0)) {
        pc_decls_cmdparamtable[((int64_t)0)] = msysnewc_sysparams[((int64_t)1)-1];
    };
    mlib_pcm_init();
    pc_support_inittypetables();
    pci_initpcldata();
    pc_jhandlers_initcalltables();
}

int64_t pci_runpcprogram(void) {
    pci_initbytecode();
    pc_decls_varstack = (struct pc_decls_varrec (*)[])(malloc((uint64_t)((int64_t)1048576)));
    if (!(!!(pc_decls_varstack))) {
        mlib_abortprogram((uint8_t*)"varstack?");
    };
    pc_decls_sptr = &(*pc_decls_varstack)[((int64_t)65536)];
    --pc_decls_sptr;
    pc_decls_stacklimit = &(*pc_decls_varstack)[((int64_t)1000)];
    pc_decls_frameptr = (byte *)(pc_decls_sptr);
    pc_decls_pcptr = &(*pc_decls_moduletable[((int64_t)0)].pccode)[((int64_t)1)-1];
    pc_decls_pccode = (int64_t (*)[])(&(*pc_decls_moduletable[((int64_t)0)].pccode)[((int64_t)0)-1]);
    pc_khandlers_stopped = (uint64_t)((int64_t)0);
    pci_disploop();
    if (((int64_t)((uint64_t)((*pc_decls_sptr).tagx)) == (int64_t)0)) {
        return (int64_t)0;
    } else {
        return (*pc_decls_sptr).value;
    };
}

static void pci_initbytecode(void) {
    osnos_os_initwindows();
    pci_allocatestrings();
    pci_pclinit();
    pci_pcl_initusertypes();
    pci_fixup_all_pc();
}

static void pci_disploop(void) {
    int64_t k;
    if ((pci_dispatch_type==(int64_t)2)) {
        pci_disploop_fn((int64_t)0);
    }else if ((pci_dispatch_type==(int64_t)3) || (pci_dispatch_type==(int64_t)4)) {
        pci_disploop_deb();
    }else if ((pci_dispatch_type==(int64_t)5)) {
        k = osnos_os_clock();
        pc_assemc_disploop_asm();
        k = (osnos_os_clock() - k);
    };
}

static void pci_pclinit(void) {
    int64_t i;
    L163 :;
    for (i=(int64_t)1;i<=(int64_t)217;i+=(int64_t)1) {
L164 :;
        if ((pci_dispatch_type==(int64_t)2)) {
            pq_common_cmdmap[(i)] = (void *)(pci_disploop_fn(i));
        }else if ((pci_dispatch_type==(int64_t)3) || (pci_dispatch_type==(int64_t)4)) {
            pq_common_cmdmap[(i)] = (void *)(i);
        }else if ((pci_dispatch_type==(int64_t)5)) {
            pq_common_cmdmap[(i)] = (void *)(i);
        };
L165 :;
    }L166 :;
    ;
}

static void pci_fixup_all_pc(void) {
    int64_t mx;
    L167 :;
    for (mx=(int64_t)1;mx<=pc_decls_nmodules;mx+=(int64_t)1) {
L168 :;
        pci_fixup_module_pc(mx);
L169 :;
    }L170 :;
    ;
    pci_fixup_module_pc((int64_t)0);
}

static void pci_fixup_module_pc(int64_t mx) {
    int64_t i;
    int64_t cmd;
    int64_t m;
    int64_t *  p;
    int64_t *  pccode;
    struct pc_decls_strec *  d;
    struct pc_decls_strec *  owner;
    static int64_t scount = (int64_t)0;
    struct pc_decls_varrec *  v;
    int64_t av_1;
    pccode = (p = (int64_t *)(pc_decls_moduletable[(mx)].pccode));
    L171 :;
    while (1) {
        cmd = (*p);
        if ((mx == (int64_t)0)) {
            if (((cmd == (int64_t)73) && (pc_decls_stopseq == 0))) {
                pc_decls_stopseq = (p - (int64_t)2);
            } else if (((cmd == (int64_t)208) && (pc_decls_raiseseq == 0))) {
                pc_decls_raiseseq = p;
            };
        };
        (*p++) = (int64_t)(pq_common_cmdmap[(cmd)]);
        L173 :;
        for (i=(int64_t)1;i<=pc_decls_cmdnopnds[(cmd)];i+=(int64_t)1) {
L174 :;
            switch ((int64_t)(pq_common_cmdfmt[(cmd)][(i)-1])) {
            case 8:;
            {
                (*p) = (int64_t)(((pccode + (*p)) - (int64_t)1));
            }break;
            case 3:;
            {
                d = &(*pc_decls_pcsymboltable)[((*p))-1];
                if (((*d).address == 0)) {
                    owner = (*d).owner;
                    L177 :;
                    while (((int64_t)((uint64_t)((*owner).nameid)) == (int64_t)4)) {
                        owner = (*owner).owner;
L178 :;
                    }L179 :;
                    ;
                    m = (int64_t)((*owner).ax_moduleno);
                    (*d).address = (void *)(&(*pc_decls_moduletable[(m)].pccode)[((int64_t)((*d).index))-1]);
                };
                (*p) = (int64_t)((*d).address);
            }break;
            case 1:;
            {
                d = &(*pc_decls_pcsymboltable)[((*p))-1];
                if (((*d).address == 0)) {
                    v = (struct pc_decls_varrec *)(mlib_pcm_alloc((int64_t)16));
                    (*v).tagx = (uint64_t)((int64_t)0);
                    (*d).address = (void *)(v);
                };
                (*p) = (int64_t)((*d).address);
            }break;
            case 13:;
            {
                (*p) = (int64_t)(&(*pc_decls_stringobjtable)[((*p))]);
            }break;
            default: {
            }
            } //SW
;
            ++p;
L175 :;
        }L176 :;
        ;
        if (((cmd == (int64_t)4) || (cmd == (int64_t)0))) {
            goto L172 ;
        };
    }L172 :;
    ;
    if ((pci_dispatch_type == (int64_t)5)) {
        pc_assemc_fixup_asm(mx);
    };
}

static int64_t * pci_disploop_fn(int64_t n) {
    int64_t count;
    uint64_t lastticks;
    uint64_t ticks;
    if (!!(n)) {
        return (int64_t *)(pci_handlertable[(n)]);
    };
    count = (int64_t)1;
    lastticks = (uint64_t)(osnos_os_clock());
    L180 :;
    do {
        pc_decls_pcptr = ((*(*(int64_t * (**)(void))(pc_decls_pcptr))))();
L181 :;
    } while (!!!((uint64_t)(pc_khandlers_stopped)));L182 :;
    ;
    ticks = (uint64_t)((osnos_os_clock() - (int64_t)(lastticks)));
    return (int64_t *)(0);
}

static void pci_disploop_deb(void) {
    int64_t lastcmd;
    int64_t cmd;
    int64_t index;
    int64_t line;
    int64_t moduleno;
    int64_t count;
    uint64_t lastticks;
    count = (int64_t)1;
    lastticks = (uint64_t)(osnos_os_clock());
    lastcmd = (int64_t)1;
    L183 :;
    do {
        cmd = (*pc_decls_pcptr);
        if (((pci_dispatch_type == (int64_t)3) || !!(mlib_fdebug))) {
            pc_support_findlinenumber(pc_decls_pcptr,&line,&moduleno);
            index = (&(*pc_decls_varstack)[((int64_t)65536)] - pc_decls_sptr);
            msysnewc_m_print_startcon();
            msysnewc_m_print_ptr(pc_decls_pcptr,NULL);
            msysnewc_m_print_str((uint8_t*)"<",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str(pq_common_cmdnames[(cmd)],NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((uint8_t*)">",NULL);
            msysnewc_m_print_str((uint8_t*)"LINE=",NULL);
            msysnewc_m_print_i64(line,NULL);
            msysnewc_m_print_str((uint8_t*)"SPTR=",NULL);
            msysnewc_m_print_ptr(pc_decls_sptr,NULL);
            msysnewc_m_print_str((uint8_t*)"INDEX=",NULL);
            msysnewc_m_print_i64(index,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
        pc_decls_pcptr = ((*(int64_t * (*)(void))(pci_handlertable[((*pc_decls_pcptr))])))();
L184 :;
    } while (!!!((uint64_t)(pc_khandlers_stopped)));L185 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"DEB STOPPED",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

void pci_runproc(void * fnptr,struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * dest) {
    struct pc_decls_varrec *  oldsptr;
    byte *  oldframeptr;
    int64_t *  oldpcptr;
    byte oldstopped;
    int64_t nparams;
    (*dest).tagx = (uint64_t)((int64_t)39);
    (*dest).value = (int64_t)0;
    oldstopped = (uint64_t)(pc_khandlers_stopped);
    oldpcptr = pc_decls_pcptr;
    oldsptr = pc_decls_sptr;
    oldframeptr = pc_decls_frameptr;
    (*--pc_decls_sptr).tagx = (uint64_t)((int64_t)999);
    if ((!!(b) && !!((uint64_t)((*b).tag)))) {
        nparams = (int64_t)2;
        (*--pc_decls_sptr) = (*b);
        (*--pc_decls_sptr) = (*a);
    } else if ((!!(a) && !!((uint64_t)((*a).tag)))) {
        nparams = (int64_t)1;
        (*--pc_decls_sptr) = (*a);
    } else {
        nparams = (int64_t)0;
    };
    (*--pc_decls_sptr).tagx = (uint64_t)((int64_t)16);
    (*pc_decls_sptr).uret.retaddr = pc_decls_stopseq;
    (*pc_decls_sptr).uret.frameptr_low = (int64_t)(*(int32_t*)&pc_decls_frameptr);
    (*pc_decls_sptr).uret.stackadj = (uint64_t)((nparams * (int64_t)16));
    pc_decls_frameptr = (byte *)(pc_decls_sptr);
    pc_decls_pcptr = (int64_t *)(fnptr);
    pci_disploop();
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == (int64_t)16)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"RUNPROC: STOP used",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        (*dest) = (*pc_decls_sptr);
    } else {
        ++pc_decls_sptr;
        (*dest) = (*pc_decls_sptr);
        if (((int64_t)((uint64_t)((*dest).tag)) == (int64_t)0)) {
            (*dest).tagx = (uint64_t)((int64_t)39);
            (*dest).value = (int64_t)0;
        };
    };
    pc_decls_pcptr = oldpcptr;
    pc_khandlers_stopped = (uint64_t)(oldstopped);
    pc_decls_sptr = oldsptr;
    pc_decls_frameptr = oldframeptr;
    pc_khandlers_stopped = (uint64_t)(oldstopped);
}

static void pci_allocatestrings(void) {
    struct pc_decls_objrec *  p;
    int64_t i;
    uint8_t *  s;
    pc_decls_stringobjtable = (struct pc_decls_objrec (*)[])(mlib_zalloctable(pc_decls_nstrings,(int64_t)32));
    L186 :;
    for (i=(int64_t)1;i<=pc_decls_nstrings;i+=(int64_t)1) {
L187 :;
        s = (*pc_decls_stringtable)[(i)-1];
        p = &(*pc_decls_stringobjtable)[(i)];
        (*p).refcount = (uint64_t)((int64_t)5);
        (*p).ustr.strptr = s;
        (*p).ustr.length = (*pc_decls_stringlentable)[(i)-1];
        (*p).ustr.objtype = (uint64_t)((int64_t)2);
L188 :;
    }L189 :;
    ;
}

uint8_t * pci_compileq(uint8_t * qfilename) {
    mlib_abortprogram((uint8_t*)"PCI:COMPILEQ NEEDS REVISING");
    return (uint8_t*)"";
}

static int64_t pci_loadpcfile(byte * s) {
    uint8_t *  str;
    uint8_t *  str2;
    struct pc_decls_modulerec m;
    int64_t i;
    int64_t j;
    int64_t a;
    int64_t b;
    int64_t dir;
    int64_t symtype;
    int64_t x;
    int64_t id;
    int64_t t;
    int64_t modno;
    int64_t n;
    int64_t cmd;
    int64_t recordtype;
    int64_t length;
    struct pc_decls_strec *  d;
    uint16_t (*linetable)[];
    int64_t *  pccode;
    double xvalue;
    int64_t av_1;
    mlib_pcm_clearmem((void *)(&pc_decls_moduletable[((int64_t)0)]),(int64_t)110);
    pc_decls_moduletable[((int64_t)0)].name = (uint8_t*)"PROGRAM";
    pc_decls_moduletable[((int64_t)0)].filename = (uint8_t*)"<->";
    pc_decls_moduletable[((int64_t)0)].sourcecode = (uint8_t*)"<program>";
    pc_decls_moduletable[((int64_t)0)].sourcelen = (int64_t)(strlen((int8_t *)(pc_decls_moduletable[((int64_t)0)].sourcecode)));
    a = (int64_t)((*s++));
    b = (int64_t)((*s++));
    if (((a != (int64_t)80) || (b != (int64_t)67))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"PC: bad sig",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        return (int64_t)0;
    };
    s += (int64_t)2;
    L190 :;
    while (1) {
        dir = pc_support_readzint(&s);
        switch (dir) {
        case 1:;
        {
            pc_decls_strpclversion = pc_support_readzstring(&s,(int64_t *)(0));
        }break;
        case 2:;
        {
            pc_decls_nmodules = pc_support_readzint(&s);
            L192 :;
            for (i=(int64_t)1;i<=pc_decls_nmodules;i+=(int64_t)1) {
L193 :;
                memset((void *)(&m),(int64_t)0,(uint64_t)((int64_t)110));
                m.name = mlib_pcm_copyheapstring(pc_support_readzstring(&s,(int64_t *)(0)));
                m.filename = m.name;
                m.sourcecode = (uint8_t*)"<no source>";
                m.sourcelen = (int64_t)0;
                pc_decls_moduletable[(i)] = m;
L194 :;
            }L195 :;
            ;
        }break;
        case 3:;
        {
            pc_decls_ndlltable = pc_support_readzint(&s);
            L196 :;
            for (i=(int64_t)1;i<=pc_decls_ndlltable;i+=(int64_t)1) {
L197 :;
                pc_decls_dlltable[(i)-1] = mlib_pcm_copyheapstring(pc_support_readzstring(&s,(int64_t *)(0)));
                pc_decls_dllinsttable[(i)-1] = (uint64_t)((int64_t)0);
L198 :;
            }L199 :;
            ;
        }break;
        case 4:;
        {
            pc_decls_ndllproctable = pc_support_readzint(&s);
            L200 :;
            for (i=(int64_t)1;i<=pc_decls_ndllproctable;i+=(int64_t)1) {
L201 :;
                pc_decls_dllproctable[(i)-1].name = mlib_pcm_copyheapstring(pc_support_readzstring(&s,(int64_t *)(0)));
                pc_decls_dllproctable[(i)-1].dllindex = pc_support_readzint(&s);
L202 :;
            }L203 :;
            ;
        }break;
        case 14:;
        {
            pc_decls_napplproctable = pc_support_readzint(&s);
            L204 :;
            for (i=(int64_t)1;i<=pc_decls_napplproctable;i+=(int64_t)1) {
L205 :;
                pc_decls_applproctable[(i)-1].name = mlib_pcm_copyheapstring(pc_support_readzstring(&s,(int64_t *)(0)));
L206 :;
            }L207 :;
            ;
        }break;
        case 5:;
        {
            pc_decls_nsymbols = pc_support_readzint(&s);
            pc_decls_pcsymboltable = (struct pc_decls_strec (*)[])(mlib_zalloctable(pc_decls_nsymbols,(int64_t)60));
            L208 :;
            for (i=(int64_t)1;i<=pc_decls_nsymbols;i+=(int64_t)1) {
L209 :;
                symtype = pc_support_readzint(&s);
                if ((symtype==(int64_t)80)) {
                    id = (int64_t)5;
                }else if ((symtype==(int64_t)83)) {
                    id = (int64_t)10;
                }else if ((symtype==(int64_t)77)) {
                    id = (int64_t)2;
                }else if ((symtype==(int64_t)84)) {
                    id = (int64_t)4;
                };
                str = mlib_pcm_copyheapstring(pc_support_readzstring(&s,(int64_t *)(0)));
                x = pc_support_readzint(&s);
                a = pc_support_readzint(&s);
                b = pc_support_readzint(&s);
                d = pci_createstentry(i,str,x,id);
                (*d).index = a;
                if ((id==(int64_t)2)) {
                    (*d).ax_moduleno = (uint64_t)(a);
                }else if ((id==(int64_t)5)) {
                    str = pc_support_readzstring(&s,(int64_t *)(0));
                    if (!!((uint64_t)((*str)))) {
                        (*d).metadata = mlib_pcm_copyheapstring(str);
                    };
                };
L210 :;
            }L211 :;
            ;
        }break;
        case 6:;
        {
            n = pc_support_readzint(&s);
            pc_decls_ntypes = ((n + (int64_t)53) - (int64_t)1);
            L212 :;
            for (i=(int64_t)1;i<=n;i+=(int64_t)1) {
L213 :;
                t = pc_support_readzint(&s);
                pc_decls_ttname[(t)] = mlib_pcm_copyheapstring(pc_support_readzstring(&s,(int64_t *)(0)));
                pc_decls_ttnamedef[(t)] = &(*pc_decls_pcsymboltable)[(pc_support_readzint(&s))-1];
                pc_decls_ttbasetype[(t)] = pc_support_readzint(&s);
                pc_decls_tttarget[(t)] = pc_support_readzint(&s);
                pc_decls_ttlower[(t)] = pc_support_readzint(&s);
                pc_decls_ttlength[(t)] = (uint64_t)(pc_support_readzint(&s));
                pc_decls_ttsize[(t)] = pc_support_readzint(&s);
L214 :;
            }L215 :;
            ;
        }break;
        case 7:;
        {
            pc_decls_ngenfieldnames = pc_support_readzint(&s);
            L216 :;
            for (i=(int64_t)1;i<=pc_decls_ngenfieldnames;i+=(int64_t)1) {
L217 :;
                pc_decls_genfieldnames[(i)-1].name = mlib_pcm_copyheapstring(pc_support_readzstring(&s,(int64_t *)(0)));
                pc_decls_genfieldnames[(i)-1].dataindex = pc_support_readzint(&s);
                pc_decls_genfieldnames[(i)-1].datalength = pc_support_readzint(&s);
L218 :;
            }L219 :;
            ;
        }break;
        case 8:;
        {
            pc_decls_ngenfielddata = pc_support_readzint(&s);
            if ((pc_decls_ngenfielddata > (int64_t)1000)) {
                pc_support_loaderror((uint8_t*)"Too many genfields",(uint8_t*)"");
            };
            L220 :;
            for (i=(int64_t)1;i<=pc_decls_ngenfielddata;i+=(int64_t)1) {
L221 :;
                pc_decls_genfielddata[(i)-1].fieldindex = pc_support_readzint(&s);
                pc_decls_genfielddata[(i)-1].recordtype = pc_support_readzint(&s);
                pc_decls_genfielddata[(i)-1].fieldtype = pc_support_readzint(&s);
                a = pc_support_readzint(&s);
                if (((int64_t)(pc_decls_genfielddata[(i)-1].fieldtype) == (int64_t)18)) {
                    pc_decls_genfieldpcaddress[(i)-1] = pci_getprocaddr(a);
                } else {
                    pc_decls_genfielddata[(i)-1].offset = a;
                };
L222 :;
            }L223 :;
            ;
        }break;
        case 13:;
        {
            pc_decls_nstrings = pc_support_readzint(&s);
            pc_decls_stringtable = (uint8_t * (*)[])(mlib_alloctable(pc_decls_nstrings,(int64_t)8));
            pc_decls_stringlentable = (int64_t (*)[])(mlib_alloctable(pc_decls_nstrings,(int64_t)8));
            L224 :;
            for (i=(int64_t)1;i<=pc_decls_nstrings;i+=(int64_t)1) {
L225 :;
                length = pc_support_readzint(&s);
                str = (uint8_t *)(pc_support_readzblock(&s,length));
                (*pc_decls_stringlentable)[(i)-1] = length;
                str2 = (uint8_t *)(mlib_pcm_alloc((length + (int64_t)1)));
                memcpy((void *)(str2),(void *)(str),(uint64_t)(length));
                (*(str2 + length)) = (uint64_t)0u;
                (*pc_decls_stringtable)[(i)-1] = str2;
L226 :;
            }L227 :;
            ;
        }break;
        case 10:;
        {
            pc_decls_nstructfields = pc_support_readzint(&s);
            pc_decls_pcfieldtable = (struct pc_decls_fieldrec (*)[])(mlib_zalloctable(pc_decls_nstructfields,(int64_t)60));
            t = (int64_t)0;
            n = (int64_t)0;
            L228 :;
            for (i=(int64_t)1;i<=pc_decls_nstructfields;i+=(int64_t)1) {
L229 :;
                recordtype = pc_support_readzint(&s);
                if ((recordtype != t)) {
                    if (!!(t)) {
                        pc_decls_ttstructfields[(t)] = n;
                    };
                    t = recordtype;
                    pc_decls_ttstartfield[(t)] = i;
                    n = (int64_t)0;
                };
                ++n;
                (*pc_decls_pcfieldtable)[(i)-1].recordtype = recordtype;
                (*pc_decls_pcfieldtable)[(i)-1].name = mlib_pcm_copyheapstring(pc_support_readzstring(&s,(int64_t *)(0)));
                (*pc_decls_pcfieldtable)[(i)-1].fieldtype = pc_support_readzint(&s);
                (*pc_decls_pcfieldtable)[(i)-1].fieldoffset = pc_support_readzint(&s);
L230 :;
            }L231 :;
            ;
            if (!!(t)) {
                pc_decls_ttstructfields[(t)] = n;
            };
        }break;
        case 11:;
        {
            modno = pc_support_readzint(&s);
            n = pc_support_readzint(&s);
            pc_decls_moduletable[(modno)].linetable = (linetable = (uint16_t (*)[])(mlib_zalloctable(n,(int64_t)2)));
            pc_decls_moduletable[(modno)].pccode = (int64_t (*)[])(mlib_zalloctable(n,(int64_t)8));
            pccode = (int64_t *)(pc_decls_moduletable[(modno)].pccode);
            pc_decls_moduletable[(modno)].pcindex = n;
            pc_decls_moduletable[(modno)].npccode = n;
            i = (int64_t)0;
            L232 :;
            while ((++i <= n)) {
                (*linetable)[(i)] = (uint64_t)(pc_support_readzint(&s));
                cmd = pc_support_readzint(&s);
                (*pccode++) = cmd;
                L235 :;
                for (j=(int64_t)1;j<=pc_decls_cmdnopnds[(cmd)];j+=(int64_t)1) {
L236 :;
                    ++i;
                    if (((int64_t)(pq_common_cmdfmt[(cmd)][(j)-1])==(int64_t)11)) {
                        xvalue = pc_support_readzreal(&s);
                        (*pccode++) = *(int64_t*)&xvalue;
                    } else {
                        (*pccode++) = pc_support_readzint(&s);
                    };
L237 :;
                }L238 :;
                ;
L233 :;
            }L234 :;
            ;
        }break;
        case 12:;
        {
            goto L191 ;
        }break;
        default: {
            pc_support_loaderror((uint8_t*)"PCDIR?",(uint8_t*)"");
        }
        } //SW
;
    }L191 :;
    ;
    return (int64_t)1;
}

void pci_initpcldata(void) {
    int64_t i;
    int64_t j;
    int64_t nn;
    L239 :;
    for (i=(int64_t)1;i<=(int64_t)217;i+=(int64_t)1) {
L240 :;
        nn = (int64_t)0;
        L243 :;
        for (j=(int64_t)1;j<=(int64_t)4;j+=(int64_t)1) {
L244 :;
            if (((int64_t)((uint64_t)(pq_common_cmdfmt[(i)][(j)-1])) == (int64_t)0)) {
                goto L246 ;
            };
            ++nn;
L245 :;
        }L246 :;
        ;
        pc_decls_cmdnopnds[(i)] = nn;
L241 :;
    }L242 :;
    ;
}

static struct pc_decls_strec * pci_createstentry(int64_t index,uint8_t * name,int64_t owner,int64_t id) {
    struct pc_decls_strec *  p;
    if (!!(index)) {
        p = &(*pc_decls_pcsymboltable)[(index)-1];
    } else {
        p = (struct pc_decls_strec *)(mlib_pcm_allocz((int64_t)60));
    };
    (*p).name = name;
    (*p).nameid = (uint64_t)(id);
    if (!!(owner)) {
        (*p).owner = &(*pc_decls_pcsymboltable)[(owner)-1];
    } else {
        (*p).owner = pc_decls_stprogram;
    };
    return p;
}

static int64_t * pci_getprocaddr(int64_t n) {
    struct pc_decls_strec *  d;
    struct pc_decls_strec *  owner;
    int64_t m;
    d = &(*pc_decls_pcsymboltable)[(n)-1];
    if (((*d).address == 0)) {
        owner = (*d).owner;
        L247 :;
        while (((int64_t)((uint64_t)((*owner).nameid)) == (int64_t)4)) {
            owner = (*owner).owner;
L248 :;
        }L249 :;
        ;
        m = (int64_t)((*owner).ax_moduleno);
        (*d).address = (void *)(&(*pc_decls_moduletable[(m)].pccode)[((int64_t)((*d).index))-1]);
    };
    return (int64_t *)((*d).address);
}

void pci_pcl_initusertypes(void) {
    int64_t t;
    int64_t sig;
    int64_t basesig;
    L250 :;
    for (t=(int64_t)53;t<=pc_decls_ntypes;t+=(int64_t)1) {
L251 :;
        if (((int64_t)(pc_decls_ttbasetype[(t)])==(int64_t)32)) {
            pc_decls_free_table[(t)] = (void (*)(struct pc_decls_varrec *))(&pc_pcfns_j_free_m);
            pc_decls_dupl_table[(t)] = (void (*)(struct pc_decls_varrec *))(&pc_pcfns_j_dupl_l_m_d);
            pc_decls_tostr_table[(t)] = (void (*)(struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_fmtrec *,struct pc_decls_objrec *))(&pc_print_j_tostr_l_m);
            pc_decls_len_table[(t)] = pc_decls_len_table[((int64_t)32)];
            pc_decls_lwb_table[(t)] = pc_decls_lwb_table[((int64_t)32)];
            pc_decls_upb_table[(t)] = pc_decls_upb_table[((int64_t)32)];
            pc_decls_bounds_table[(t)] = pc_decls_bounds_table[((int64_t)32)];
            basesig = pc_support_gettypesig((int64_t)32,(int64_t)1);
            sig = pc_support_gettypesig(t,(int64_t)1);
            pc_decls_pushix_dtable[(sig)] = pc_decls_pushix_dtable[(basesig)];
            pc_decls_pushdotix_dtable[(sig)] = pc_decls_pushdotix_dtable[(basesig)];
            pc_decls_pushdotixref_dtable[(sig)] = pc_decls_pushdotixref_dtable[(basesig)];
        }else if (((int64_t)(pc_decls_ttbasetype[(t)])==(int64_t)33)) {
            pc_decls_free_table[(t)] = pc_decls_free_table[((int64_t)33)];
            pc_decls_dupl_table[(t)] = pc_decls_dupl_table[((int64_t)33)];
            pc_decls_tostr_table[(t)] = pc_decls_tostr_table[((int64_t)33)];
        }else if (((int64_t)(pc_decls_ttbasetype[(t)])==(int64_t)30)) {
            pc_decls_free_table[(t)] = pc_decls_free_table[((int64_t)30)];
            pc_decls_dupl_table[(t)] = pc_decls_dupl_table[((int64_t)30)];
            pc_decls_tostr_table[(t)] = pc_decls_tostr_table[((int64_t)30)];
            pc_decls_len_table[(t)] = pc_decls_len_table[((int64_t)30)];
            pc_decls_lwb_table[(t)] = pc_decls_lwb_table[((int64_t)30)];
            pc_decls_upb_table[(t)] = pc_decls_upb_table[((int64_t)30)];
            basesig = pc_support_gettypesig((int64_t)30,(int64_t)1);
            sig = pc_support_gettypesig(t,(int64_t)1);
            pc_decls_pushix_dtable[(sig)] = pc_decls_pushix_dtable[(basesig)];
            pc_decls_pushixref_dtable[(sig)] = pc_decls_pushixref_dtable[(basesig)];
        };
L252 :;
    }L253 :;
    ;
}

void pci_setcmdparam(int64_t index,uint8_t * s) {
    if ((s == 0)) {
        pc_decls_ncmdparams = index;
    } else if ((index <= (int64_t)32)) {
        pc_decls_cmdparamtable[(index)] = mlib_pcm_copyheapstring(s);
        pc_decls_ncmdparams=(pc_decls_ncmdparams>index?pc_decls_ncmdparams:index);
;
    };
}

void pc_support_prterror(uint8_t * mess) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"Print error:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    osnos_os_getch();
    exit((int64_t)1);
}

int64_t pc_support_testelem(byte (*p)[],int64_t n) {
    return (!!(((uint64_t)((*p)[((n >> (int64_t)3))]) & (uint64_t)(pc_support_bytemasks[((n & (int64_t)7))])))?(int64_t)1:(int64_t)0);
}

void pc_support_setelem(byte (*p)[],int64_t n) {
    (*p)[((n >> (int64_t)3))] |= pc_support_bytemasks[((n & (int64_t)7))];
}

void pc_support_pcustype_def(uint8_t * mess,struct pc_decls_varrec * x) {
    int64_t t;
    t = (int64_t)((*x).tag);
    pc_support_showlinenumber();
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"USTYPE:Type not supported: ",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_str((uint8_t*)":",NULL);
    msysnewc_m_print_str(pc_decls_ttname[(t)],NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mlib_abortprogram((uint8_t*)"Stopping");
}

int64_t * pc_support_pcustype(uint8_t * mess,struct pc_decls_varrec * x) {
    pc_decls_err_message = mess;
    pc_decls_err_var1 = (*x);
    pc_decls_err_pcptr = pc_decls_pcptr;
    pc_support_pcustype_def(mess,x);
    return pc_decls_pcptr;
}

int64_t * pc_support_pcustypet(uint8_t * mess,int64_t t) {
    static struct pc_decls_varrec v;
    v.tagx = (uint64_t)(t);
    return pc_support_pcustype(mess,&v);
}

void pc_support_pcmxtypes_def(uint8_t * mess,struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    int64_t s;
    int64_t t;
    s = (int64_t)((*x).tag);
    t = (int64_t)((*y).tag);
    pc_support_showlinenumber();
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"MXTYPES:Mixed Types not supported:/",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_str((uint8_t*)"/:",NULL);
    msysnewc_m_print_str(pc_decls_ttname[(s)],NULL);
    msysnewc_m_print_str((uint8_t*)":",NULL);
    msysnewc_m_print_str(pc_decls_ttname[(t)],NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mlib_abortprogram((uint8_t*)"Stopping");
}

int64_t * pc_support_pcmxtypes(uint8_t * mess,struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    pc_decls_err_message = mess;
    pc_decls_err_var1 = (*x);
    pc_decls_err_var2 = (*y);
    pc_decls_err_pcptr = pc_decls_pcptr;
    pc_support_pcmxtypes_def(mess,x,y);
    return pc_decls_pcptr;
}

int64_t * pc_support_pcmxtypestt(uint8_t * mess,int64_t s,int64_t t) {
    static struct pc_decls_varrec u;
    static struct pc_decls_varrec v;
    u.tagx = (uint64_t)(s);
    v.tagx = (uint64_t)(t);
    return pc_support_pcmxtypes(mess,&u,&v);
}

uint8_t * pc_support_gettypename(int64_t t) {
    return pc_decls_ttname[(t)];
}

void pc_support_inittypetables(void) {
    int64_t i;
    int64_t size;
    int64_t bitsize;
    int64_t av_1;
    L254 :;
    for (i=(int64_t)0;i<=(int64_t)52;i+=(int64_t)1) {
L255 :;
        pc_decls_ttname[(i)] = pc_types_stdtypenames[(i)];
        pc_decls_ttbasetype[(i)] = i;
        if ((i==(int64_t)50) || (i==(int64_t)51) || (i==(int64_t)52)) {
            bitsize = (int64_t)64;
        } else {
            bitsize = pc_types_stdtypewidths[(i)];
        };
        switch (bitsize) {
        case 0:;
        {
        }break;
        case 1:;
        case 2:;
        case 4:;
        {
            size = (int64_t)1;
        }break;
        default: {
            size = (bitsize / (int64_t)8);
        }
        } //SW
;
        pc_decls_ttsize[(i)] = size;
        pc_decls_ttbitwidth[(i)] = bitsize;
        pc_decls_ttlower[(i)] = (int64_t)1;
L256 :;
    }L257 :;
    ;
    pc_decls_ntypes = (int64_t)52;
    pc_decls_tttarget[((int64_t)22)] = (int64_t)35;
}

int64_t * pc_support_pcerror(uint8_t * mess) {
    pc_support_showlinenumber();
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"PCERROR:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    osnos_os_getch();
    exit((int64_t)1);
    return (int64_t *)(0);
}

void pc_support_vxunimpl(uint8_t * mess) {
    pc_support_showlinenumber();
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"Unimplemented VX op:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    osnos_os_getch();
    exit((int64_t)1);
}

void pc_support_pclunimpl(int64_t cmd) {
    pc_support_showlinenumber();
    if ((cmd != (int64_t)217)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"Unimplemented cmd:",NULL);
        msysnewc_m_print_str(pq_common_cmdnames[(cmd)],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"J-opcode not allowed with -LAB or -FN",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    mlib_abortprogram((uint8_t*)"Stopping");
}

uint8_t * pc_support_convcstring(uint8_t * svalue,int64_t length) {
    static uint8_t strbuffer1[2000];
    static uint8_t strbuffer2[2000];
    static uint8_t strbuffer3[2000];
    static uint8_t strbuffer4[2000];
    static uint8_t strbuffer5[2000];
    static uint8_t strbuffer6[2000];
    static int64_t strindex = (int64_t)0;
    static uint8_t (*table[6])[] = {&strbuffer1,&strbuffer2,&strbuffer3,&strbuffer4,&strbuffer5,&strbuffer6};
    uint8_t (*p)[];
    if ((length >= (int64_t)2000)) {
        pc_support_pcerror((uint8_t*)"ConvCstring>=2000");
    };
    if ((svalue == 0)) {
        return (uint8_t*)"";
    };
    if ((++strindex == (int64_t)6)) {
        strindex = (int64_t)0;
    };
    p = table[(strindex)];
    memcpy((void *)(p),(void *)(svalue),(uint64_t)(length));
    (*p)[(length)] = (uint64_t)0u;
    return (uint8_t *)(p);
}

int64_t pc_support_getintvalue(struct pc_decls_varrec * p) {
    switch ((int64_t)((*p).tag)) {
    case 1:;
    case 13:;
    {
        return (*p).value;
    }break;
    case 3:;
    {
        return (int64_t)((*p).xvalue);
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"getintvalue",p);
    }
    } //SW
;
    return (int64_t)0;
}

int64_t pc_support_nextpoweroftwo(int64_t x) {
    int64_t a;
    if ((x == (int64_t)0)) {
        return (int64_t)0;
    };
    a = (int64_t)1;
    L258 :;
    while ((a < x)) {
        a <<= (int64_t)1;
L259 :;
    }L260 :;
    ;
    return a;
}

void pc_support_showlinenumber(void) {
    int64_t lineno;
    int64_t moduleno;
    int64_t count;
    int64_t *  ptr;
    struct pc_decls_varrec *  s;
    struct pc_decls_varrec *  send;
    pc_support_findlinenumber(pc_decls_pcptr,&lineno,&moduleno);
    pc_support_printlinenumber(lineno,moduleno,(uint8_t*)"");
    s = pc_decls_sptr;
    send = &(*pc_decls_varstack)[((int64_t)65536)];
    count = (int64_t)0;
    L261 :;
    while (((s <= send) && (count < (int64_t)15))) {
        if (((int64_t)((uint64_t)((*s).tag)) == (int64_t)16)) {
            ptr = ((*s).uret.retaddr - (int64_t)3);
            pc_support_findlinenumber(ptr,&lineno,&moduleno);
            pc_support_printlinenumber(lineno,moduleno,(uint8_t*)"Called from:");
            ++count;
        };
        ++s;
L262 :;
    }L263 :;
    ;
}

static void pc_support_printlinenumber(int64_t lineno,int64_t moduleno,uint8_t * calledfrom) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(calledfrom,NULL);
    msysnewc_m_print_str((uint8_t*)"LINE:",NULL);
    msysnewc_m_print_i64(lineno,NULL);
    msysnewc_m_print_str((uint8_t*)"in FILE:",NULL);
    msysnewc_m_print_str(pc_decls_moduletable[(moduleno)].filename,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

void pc_support_findlinenumber(int64_t * ptr,int64_t * lineno,int64_t * moduleno) {
    int64_t pcindex;
    int64_t i;
    struct pc_decls_modulerec m;
    (*lineno) = (int64_t)0;
    pcindex = pc_support_findpcindex(ptr,moduleno);
    if (!!(pcindex)) {
        m = pc_decls_moduletable[((*moduleno))];
        L264 :;
        for (i=pcindex;i>=(int64_t)1;i-=(int64_t)1) {
L265 :;
            (*lineno) = (int64_t)((*m.linetable)[(i)]);
            if (!!((*lineno))) {
                return;
            };
L266 :;
        }L267 :;
        ;
    };
}

int64_t pc_support_findpcindex(int64_t * ptr,int64_t * moduleno) {
    int64_t i;
    int64_t *  p;
    int64_t *  q;
    L268 :;
    for (i=(int64_t)0;i<=pc_decls_nmodules;i+=(int64_t)1) {
L269 :;
        p = (int64_t *)(pc_decls_moduletable[(i)].pccode);
        q = (p + (int64_t)(pc_decls_moduletable[(i)].pcindex));
        if (((ptr >= p) && (ptr < q))) {
            (*moduleno) = i;
            return ((ptr - p) + (int64_t)1);
        };
L270 :;
    }L271 :;
    ;
    return (int64_t)0;
}

void pc_support_showlinetable(uint8_t * caption,int64_t i) {
    int64_t j;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"MODULE",NULL);
    msysnewc_m_print_i64(i,NULL);
    msysnewc_m_print_i64(pc_decls_moduletable[(i)].pcindex,NULL);
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L272 :;
    for (j=(int64_t)7;j<=(int64_t)12;j+=(int64_t)1) {
L273 :;
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"\tLINE",NULL);
        msysnewc_m_print_i64(j,NULL);
        msysnewc_m_print_u64((*pc_decls_moduletable[(i)].linetable)[(j)],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
L274 :;
    }L275 :;
    ;
}

void pc_support_writezstring(void * f,uint8_t * s) {
    int64_t n;
    int64_t av_1;
    mlib_outbyte(f,(int64_t)254);
    n = (int64_t)(strlen((int8_t *)(s)));
    av_1 = n;
    while (av_1-- > 0) {
L276 :;
        mlib_outbyte(f,(int64_t)((*s++)));
L277 :;
    }L278 :;
    ;
    mlib_outbyte(f,(int64_t)0);
}

void pc_support_writezint(void * f,int64_t x) {
    byte *  p;
    int64_t av_1;
    if (((x >= (int64_t)0) && (x <= (int64_t)239))) {
        mlib_outbyte(f,x);
    } else if (((x >= (int64_t)240) && (x < (int64_t)480))) {
        mlib_outbyte(f,(int64_t)245);
        mlib_outbyte(f,(x - (int64_t)240));
    } else if (((x >= (int64_t)480) && (x < (int64_t)720))) {
        mlib_outbyte(f,(int64_t)246);
        mlib_outbyte(f,(x - (int64_t)480));
    } else if (((x >= (int64_t)720) && (x < (int64_t)960))) {
        mlib_outbyte(f,(int64_t)247);
        mlib_outbyte(f,(x - (int64_t)720));
    } else if (((x >= (int64_t)-127) && (x < (int64_t)0))) {
        mlib_outbyte(f,(int64_t)248);
        mlib_outbyte(f,-(x));
    } else if (((x >= (int64_t)-32768) && (x <= (int64_t)32767))) {
        mlib_outbyte(f,(int64_t)249);
        mlib_outword16(f,(uint64_t)(x));
    } else if (((x > (int64_t)-2147483648) && (x <= (int64_t)2147483647))) {
        mlib_outbyte(f,(int64_t)250);
        mlib_outword(f,(uint64_t)(x));
    } else {
        p = (byte *)(&x);
        mlib_outbyte(f,(int64_t)251);
        av_1 = (int64_t)8;
        while (av_1-- > 0) {
L279 :;
            mlib_outbyte(f,(int64_t)((*p++)));
L280 :;
        }L281 :;
        ;
    };
}

void pc_support_writezint4(void * f,int64_t x) {
    mlib_outbyte(f,(int64_t)250);
    mlib_outword(f,(uint64_t)(x));
}

void pc_support_writezrange(void * f,byte * p) {
    int64_t av_1;
    mlib_outbyte(f,(int64_t)251);
    av_1 = (int64_t)8;
    while (av_1-- > 0) {
L282 :;
        mlib_outbyte(f,(int64_t)((*p++)));
L283 :;
    }L284 :;
    ;
}

void pc_support_writezreal(void * f,double x) {
    byte *  p;
    int64_t *  q;
    int64_t av_1;
    int64_t av_2;
    p = (byte *)(&x);
    q = (int64_t *)(&x);
    if ((q != 0)) {
        mlib_outbyte(f,(int64_t)253);
        av_1 = (int64_t)8;
        while (av_1-- > 0) {
L285 :;
            mlib_outbyte(f,(int64_t)((*p++)));
L286 :;
        }L287 :;
        ;
    } else {
        mlib_outbyte(f,(int64_t)252);
        p += (int64_t)4;
        av_2 = (int64_t)4;
        while (av_2-- > 0) {
L288 :;
            mlib_outbyte(f,(int64_t)((*p++)));
L289 :;
        }L290 :;
        ;
    };
}

void pc_support_writezeof(void * f) {
    mlib_outbyte(f,(int64_t)255);
}

static void pc_support_zerror(uint8_t * mess) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"Z error:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit((int64_t)1);
}

int64_t pc_support_readzvalue(byte * * pp,int32_t * dest,int32_t * dest2) {
    byte *  p;
    int64_t *  destint;
    void * *  destptr;
    int64_t t;
    byte bb;
    byte c;
    int32_t length;
    int32_t dummy;
    p = (*pp);
    bb = (uint64_t)((*p++));
    t = (int64_t)1;
    if ((dest2 == 0)) {
        dest2 = &dummy;
    };
    switch ((int64_t)(bb)) {
    case 245:;
    {
        (*dest) = ((int64_t)((uint64_t)((*p++))) + (int64_t)240);
    }break;
    case 246:;
    {
        (*dest) = ((int64_t)((uint64_t)((*p++))) + (int64_t)480);
    }break;
    case 247:;
    {
        (*dest) = ((int64_t)((uint64_t)((*p++))) + (int64_t)720);
    }break;
    case 248:;
    {
        (*dest) = -((int64_t)((*(int8_t *)(p))));
        ++p;
    }break;
    case 249:;
    {
        (*dest) = (int64_t)((*(int16_t *)(p)));
        p += (int64_t)2;
    }break;
    case 250:;
    {
        (*dest) = (int64_t)((*(int32_t *)(p)));
        p += (int64_t)4;
    }break;
    case 251:;
    {
        destint = (int64_t *)(dest);
        (*destint) = (*(int64_t *)(p));
        p += (int64_t)8;
        t = (int64_t)2;
    }break;
    case 252:;
    {
        (*dest++) = (int64_t)0;
        (*dest) = (int64_t)((*(int32_t *)(p)));
        p += (int64_t)4;
        t = (int64_t)3;
    }break;
    case 253:;
    {
        destint = (int64_t *)(dest);
        (*destint) = (*(int64_t *)(p));
        p += (int64_t)8;
        t = (int64_t)3;
    }break;
    case 254:;
    {
        destptr = (void * *)(dest);
        (*destptr) = (void *)((int64_t)(p));
        length = (int64_t)0;
        L291 :;
        do {
            c = (uint64_t)((*p++));
            ++length;
L292 :;
        } while (!!(!!((uint64_t)(c))));L293 :;
        ;
        (*dest2) = (int64_t)(--length);
        t = (int64_t)4;
    }break;
    case 244:;
    {
        pc_support_zerror((uint8_t*)"Can't deal with ZBYTES yet");
        exit((int64_t)1);
    }break;
    case 255:;
    {
        return (int64_t)0;
    }break;
    default: {
        (*dest) = (int64_t)(bb);
    }
    } //SW
;
    (*pp) = p;
    return t;
}

int64_t pc_support_readzint(byte * * p) {
    int64_t aa;
    int64_t status;
    aa = (int64_t)0;
    status = pc_support_readzvalue(p,(int32_t *)(&aa),(int32_t *)(0));
    if ((status==(int64_t)1)) {
        if (((int64_t)((int32_t)(aa)) < (int64_t)0)) {
            aa |= (int64_t)((uint64_t)18446744069414584320u);
        };
    }else if ((status==(int64_t)2)) {
    } else {
        pc_support_zerror((uint8_t*)"Z:Int32 Expected");
    };
    return aa;
}

int64_t pc_support_readzdint(byte * * p) {
    int64_t aa;
    int64_t status;
    aa = (int64_t)0;
    if (((status = pc_support_readzvalue(p,(int32_t *)(&aa),(int32_t *)(0))) != (int64_t)2)) {
        if ((status == (int64_t)1)) {
            if ((aa > (int64_t)2147483647)) {
                aa |= (int64_t)((uint64_t)18446744071562067968u);
            };
        } else {
            pc_support_zerror((uint8_t*)"ZformatD");
        };
    };
    return aa;
}

double pc_support_readzreal(byte * * p) {
    double x;
    int64_t status;
    if (((status = pc_support_readzvalue(p,(int32_t *)(&x),(int32_t *)(0))) != (int64_t)3)) {
        pc_support_zerror((uint8_t*)"ZformatR");
    };
    return x;
}

uint8_t * pc_support_readzstring(byte * * p,int64_t * ilength) {
    int64_t aa;
    int32_t length;
    int32_t status;
    if (((int64_t)((status = pc_support_readzvalue(p,(int32_t *)(&aa),&length))) != (int64_t)4)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"STATUS=",NULL);
        msysnewc_m_print_i64(status,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        pc_support_zerror((uint8_t*)"ZformatS");
    };
    if (!!(ilength)) {
        (*ilength) = (int64_t)(length);
    };
    return (uint8_t *)(aa);
}

byte * pc_support_readzblock(byte * * pp,int64_t length) {
    byte *  pdata;
    pdata = (*pp);
    (*pp) = (pdata + length);
    return pdata;
}

void pc_support_checkmt(int64_t id) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"CHECKMT",NULL);
    msysnewc_m_print_i64(id,NULL);
    msysnewc_m_print_str((uint8_t*)":",NULL);
    msysnewc_m_print_ptr(pc_decls_moduletable[((int64_t)1)].pccode,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

int64_t pc_support_ipower(int64_t a,int64_t n) {
    if ((n <= (int64_t)0)) {
        return (int64_t)0;
    } else if ((n == (int64_t)0)) {
        return (int64_t)1;
    } else if ((n == (int64_t)1)) {
        return a;
    } else if (((n & (int64_t)1) == (int64_t)0)) {
        return pc_support_ipower((a * a),(n / (int64_t)2));
    } else {
        return (a * pc_support_ipower((a * a),((n - (int64_t)1) / (int64_t)2)));
    };
}

void pc_support_loaderror(uint8_t * mess,uint8_t * mess2) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"Load Error:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_str(mess2,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit((int64_t)1);
}

int64_t pc_support_gettypesig(int64_t s,int64_t t) {
    int64_t typesig;
    typesig = (int64_t)(pc_decls_sigmap[(s)][(t)]);
    if ((typesig == (int64_t)0)) {
        typesig = ++pc_decls_nexttypesig;
        pc_decls_sigmap[(s)][(t)] = (uint64_t)(typesig);
    };
    return typesig;
}

uint8_t * pc_support_getfnname(void * fnaddr) {
    int64_t i;
    int64_t n;
    n = msysnewc_m_get_nprocs();
    L294 :;
    for (i=(int64_t)1;i<=n;i+=(int64_t)1) {
L295 :;
        if ((msysnewc_m_get_procaddr(i) == fnaddr)) {
            return msysnewc_m_get_procname(i);
        };
L296 :;
    }L297 :;
    ;
    return (uint8_t*)"<FUNCTION NOT FOUND>";
}

void pc_support_junimpl(uint8_t * s) {
    uint8_t mess[100];
    strcpy((int8_t *)(mess),(int8_t *)((uint8_t*)"J handler unimpl: "));
    strcat((int8_t *)(mess),(int8_t *)(s));
    pc_support_pcerror(mess);
}

int64_t * pc_misc_raiseexception(int64_t exceptno) {
    struct pc_decls_varrec *  stackend;
    struct pc_decls_varrec *  oldsptr;
    stackend = &(*pc_decls_varstack)[((int64_t)65536)];
    oldsptr = pc_decls_sptr;
    L298 :;
    while (1) {
        if ((pc_decls_sptr >= stackend)) {
            pc_decls_sptr = oldsptr;
            pc_misc_default_exception(exceptno);
        };
        if ((((int64_t)((uint64_t)((*pc_decls_sptr).tag)) == (int64_t)17) && ((exceptno == (int64_t)0) || ((int64_t)((uint64_t)((*pc_decls_sptr).uexcept.exceptiontype)) == exceptno)))) {
            goto L299 ;
        };
        if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
            pc_pcfns_pc_unshare(pc_decls_sptr);
        };
        ++pc_decls_sptr;
    }L299 :;
    ;
    pc_decls_frameptr = ((byte *)(pc_decls_sptr) + (int64_t)((*pc_decls_sptr).uexcept.frameoffset));
    return (int64_t *)((*pc_decls_sptr).refptr);
}

void pc_misc_raise_error(int64_t error_no) {
    (*--pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = error_no;
    pc_decls_err_pcptr = pc_decls_pcptr;
    pc_decls_pcptr = pc_decls_raiseseq;
}

static void pc_misc_default_exception(int64_t exceptno) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"DEFAULT EXCEPTION HANDLER",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    if ((exceptno==(int64_t)1)) {
        pc_support_pcerror((uint8_t*)"PC/ERROR");
    }else if ((exceptno==(int64_t)2)) {
        pc_support_pcerror((uint8_t*)"USER/ERROR");
    }else if ((exceptno==(int64_t)3)) {
        pc_decls_pcptr = pc_decls_err_pcptr;
        pc_support_pcustype_def(pc_decls_err_message,&pc_decls_err_var1);
    }else if ((exceptno==(int64_t)4)) {
        pc_decls_pcptr = pc_decls_err_pcptr;
        pc_support_pcmxtypes_def(pc_decls_err_message,&pc_decls_err_var1,&pc_decls_err_var2);
    }else if ((exceptno==(int64_t)5)) {
        pc_decls_pcptr = pc_decls_err_pcptr;
        pc_support_pcerror((uint8_t*)"EXCEPTION/DIVIDE BY ZERO");
    }else if ((exceptno==(int64_t)6)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"STOPMODULEERROR",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    }else if ((exceptno==(int64_t)7)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"BOUNDSERROR",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"Exception:",NULL);
        msysnewc_m_print_str(pq_common_errornames[(exceptno)-1],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    exit((int64_t)1);
}

void pc_pcfns_pc_unshare(struct pc_decls_varrec * p) {
    if (((int64_t)((uint64_t)((*(*p).objptr).refcount)) <= (int64_t)0)) {
        pc_support_pcerror((uint8_t*)"UNSHARE/REF COUNT ERROR");
    };
    if (((int64_t)((uint64_t)(--(*(*p).objptr).refcount)) == (int64_t)0)) {
        pc_pcfns_pc_free(p);
    };
}

void pc_pcfns_pc_free(struct pc_decls_varrec * p) {
    struct pc_decls_varrec v;
    struct pc_decls_objrec *  pa;
    pa = (*p).objptr;
    if (((int64_t)((uint64_t)((*pa).refcount)) > (int64_t)0)) {
        pc_support_pcerror((uint8_t*)"FREE: REFCOUNT NOT ZERO");
    };
    switch ((int64_t)((*pa).objtype)) {
    case 0:;
    {
        ((*pc_decls_free_table[((int64_t)((*pa).tag))]))(p);
    }break;
    case 1:;
    {
        v.tagx = (uint64_t)((*pa).tag);
        v.objptr = (*pa).objptr2;
        pc_pcfns_pc_unshare(&v);
    }break;
    default: {
        pc_objlib_freeobject(pa);
    }
    } //SW
;
    (*p).tag = (uint64_t)((int64_t)0);
}

struct pc_decls_varrec * pc_pcfns_pc_share(struct pc_decls_varrec * p) {
    ++(*(*p).objptr).refcount;
    return p;
}

void pc_pcfns_pc_dupl(struct pc_decls_varrec * p) {
    struct pc_decls_varrec v;
    if (!!((uint64_t)((*p).hasref))) {
        v = (*p);
        ((*pc_decls_dupl_table[((int64_t)(v.tag))]))(p);
        pc_pcfns_pc_unshare(&v);
    };
}

void pc_pcfns_j_free_s(struct pc_decls_varrec * p) {
    struct pc_decls_objrec *  pa;
    pa = (*p).objptr;
    if (!!((int64_t)((*pa).ustr.length))) {
        mlib_pcm_free((void *)((*pa).ustr.strptr),(int64_t)((*pa).ustr.allocated));
    };
    pc_objlib_freeobject(pa);
}

void pc_pcfns_j_free_m(struct pc_decls_varrec * p) {
    int64_t n;
    struct pc_decls_objrec *  r;
    struct pc_decls_varrec *  q;
    int64_t av_1;
    r = (*p).objptr;
    n = (int64_t)(pc_decls_ttlength[((int64_t)((*p).tag))]);
    q = (*r).urec.vptr;
    av_1 = n;
    while (av_1-- > 0) {
L300 :;
        if (!!((uint64_t)((*q).hasref))) {
            pc_pcfns_pc_unshare(q);
        };
        ++q;
L301 :;
    }L302 :;
    ;
    if (!!(n)) {
        pc_objlib_record_free(r);
    };
    pc_objlib_freeobject(r);
}

void pc_pcfns_j_free_l_d(struct pc_decls_varrec * p) {
    int64_t n;
    struct pc_decls_objrec *  r;
    struct pc_decls_varrec *  q;
    int64_t av_1;
    r = (*p).objptr;
    n = (int64_t)((*r).ulist.length);
    q = (*r).ulist.vptr;
    av_1 = n;
    while (av_1-- > 0) {
L303 :;
        if (!!((uint64_t)((*q).hasref))) {
            pc_pcfns_pc_unshare(q);
        };
        ++q;
L304 :;
    }L305 :;
    ;
    if (!!(n)) {
        pc_objlib_list_free(r);
    };
    pc_objlib_freeobject(r);
}

void pc_pcfns_j_free_k(struct pc_decls_varrec * p) {
    struct pc_decls_objrec *  r;
    r = (*p).objptr;
    pc_objlib_array_free(r);
    pc_objlib_freeobject(r);
}

void pc_pcfns_j_free_a(struct pc_decls_varrec * p) {
    struct pc_decls_objrec *  r;
    r = (*p).objptr;
    pc_objlib_array_free(r);
    pc_objlib_freeobject(r);
}

void pc_pcfns_j_free_j(struct pc_decls_varrec * p) {
    pc_bignum_bx_free(p);
}

void pc_pcfns_j_free_b_e(struct pc_decls_varrec * p) {
    struct pc_decls_objrec *  r;
    r = (*p).objptr;
    pc_objlib_bits_free(r);
    pc_objlib_freeobject(r);
}

void pc_pcfns_j_dupl_s(struct pc_decls_varrec * p) {
    struct pc_decls_objrec *  pa;
    pa = (*p).objptr;
    pc_pcfns_pc_makestring((*pa).ustr.strptr,(int64_t)((*pa).ustr.length),p);
}

void pc_pcfns_j_dupl_l_m_d(struct pc_decls_varrec * p) {
    int64_t n;
    struct pc_decls_varrec *  r;
    struct pc_decls_objrec *  oldp;
    struct pc_decls_objrec *  newp;
    int64_t av_1;
    oldp = (*p).objptr;
    if (((int64_t)((uint64_t)((*oldp).refcount)) < (int64_t)0)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"CIRC",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        pc_support_pcerror((uint8_t*)"DUPL/LIST CIRC");
        return;
    };
    if (((int64_t)(pc_decls_ttbasetype[((int64_t)((*p).tag))]) == (int64_t)32)) {
        n = (int64_t)(pc_decls_ttlength[((int64_t)((*p).tag))]);
        newp = pc_objlib_record_new((int64_t)((*p).tag));
    } else {
        n = (int64_t)((*oldp).ulist.length);
        newp = pc_objlib_list_new(n,(int64_t)((*oldp).ulist.lower),(struct pc_decls_varrec *)(0));
    };
    (*p).objptr = newp;
    (*oldp).refcount = -((uint64_t)((*oldp).refcount));
    if (!!(n)) {
        r = (*newp).ulist.vptr;
        mlib_pcm_copymem4((void *)(r),(void *)((*oldp).ulist.vptr),(n * (int64_t)16));
        av_1 = n;
        while (av_1-- > 0) {
L306 :;
            if (!!((uint64_t)((*r).hasref))) {
                if (((int64_t)(pc_decls_ttbasetype[((int64_t)((*r).tag))]) != (int64_t)32)) {
                    ++(*(*r).objptr).refcount;
                    pc_pcfns_pc_dupl(r);
                } else {
                    ++(*(*r).objptr).refcount;
                };
            };
            ++r;
L307 :;
        }L308 :;
        ;
    };
    (*oldp).refcount = -((uint64_t)((*oldp).refcount));
}

void pc_pcfns_j_dupl_a(struct pc_decls_varrec * p) {
    int64_t n;
    struct pc_decls_objrec *  oldp;
    struct pc_decls_objrec *  newp;
    oldp = (*p).objptr;
    n = (int64_t)((*oldp).uarray.length);
    newp = pc_objlib_array_new((int64_t)((*p).tag),(int64_t)((*oldp).uarray.elemtag),n,(int64_t)((*oldp).uarray.lower));
    (*p).objptr = newp;
    if (!!(n)) {
        mlib_pcm_copymem4((void *)((*newp).uarray.ptr),(void *)((*oldp).uarray.ptr),(n * pc_decls_ttsize[((int64_t)((*oldp).uarray.elemtag))]));
    };
}

void pc_pcfns_j_dupl_j(struct pc_decls_varrec * p) {
    pc_bignum_bx_dupl(p);
}

void pc_pcfns_j_dupl_b(struct pc_decls_varrec * p) {
    int64_t n;
    struct pc_decls_objrec *  oldp;
    struct pc_decls_objrec *  newp;
    oldp = (*p).objptr;
    n = (int64_t)((*oldp).ubits.length);
    newp = pc_objlib_bits_new((int64_t)((*oldp).ubits.elemtag),n,(int64_t)((*oldp).ubits.lower));
    (*p).objptr = newp;
    if (!!(n)) {
        mlib_pcm_copymem4((void *)((*newp).ubits.ptr),(void *)((*oldp).ubits.ptr),pc_objlib_bits_bytesize(oldp));
    };
}

void pc_pcfns_j_dupl_e(struct pc_decls_varrec * p) {
    int64_t n;
    struct pc_decls_objrec *  oldp;
    struct pc_decls_objrec *  newp;
    oldp = (*p).objptr;
    n = (int64_t)((*oldp).uset.allocated64);
    newp = pc_objlib_set_new((int64_t)((*oldp).uset.length),(int64_t)((*oldp).uset.lower));
    (*p).objptr = newp;
    if (!!(n)) {
        mlib_pcm_copymem4((void *)((*newp).uset.ptr),(void *)((*oldp).uset.ptr),pc_objlib_bits_bytesize(oldp));
    };
}

void pc_pcfns_j_dupl_k(struct pc_decls_varrec * p) {
    int64_t nbytes;
    struct pc_decls_objrec *  oldp;
    struct pc_decls_objrec *  newp;
    oldp = (*p).objptr;
    nbytes = pc_decls_ttsize[((int64_t)((*p).tag))];
    newp = pc_objlib_struct_new((int64_t)((*p).tag));
    (*p).objptr = newp;
    mlib_pcm_copymem4((void *)((*newp).ustruct.ptr),(void *)((*oldp).ustruct.ptr),nbytes);
}

void pc_pcfns_pc_makelist(int64_t n,struct pc_decls_varrec * a,struct pc_decls_varrec * b,int64_t lower) {
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec *  q;
    struct pc_decls_objrec *  l;
    int64_t av_1;
    a += (n - (int64_t)1);
    l = pc_objlib_list_new(n,lower,(struct pc_decls_varrec *)(0));
    (*l).ulist.mutable = (uint64_t)((int64_t)0);
    p = (*l).ulist.vptr;
    q = ((p + (int64_t)((*l).ulist.allocated)) - (int64_t)1);
    av_1 = n;
    while (av_1-- > 0) {
L309 :;
        (*p) = (*a--);
        ++p;
L310 :;
    }L311 :;
    ;
    L312 :;
    while ((p <= q)) {
        (*p).tagx = (uint64_t)((int64_t)0);
        ++p;
L313 :;
    }L314 :;
    ;
    pc_objlib_objtovar(l,b);
}

void pc_pcfns_pc_makerecord(int64_t n,int64_t t,struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    struct pc_decls_varrec *  p;
    struct pc_decls_objrec *  r;
    int64_t av_1;
    a += (n - (int64_t)1);
    r = pc_objlib_record_new(t);
    p = (*r).urec.vptr;
    av_1 = n;
    while (av_1-- > 0) {
L315 :;
        (*p) = (*a--);
        if (!!((uint64_t)((*p).hasref))) {
            pc_pcfns_pc_share(p);
        };
        ++p;
L316 :;
    }L317 :;
    ;
    pc_objlib_objtovar(r,b);
}

void pc_pcfns_pc_makearray(int64_t n,int64_t arraytype,int64_t elemtype,int64_t lower,struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    byte *  p;
    int64_t esize;
    int64_t basetag;
    struct pc_decls_objrec *  l;
    int64_t av_1;
    a += (n - (int64_t)1);
    if ((elemtype == (int64_t)0)) {
        elemtype = (int64_t)((*a).tag);
        basetag = (int64_t)(pc_decls_ttbasetype[(elemtype)]);
        if ((basetag==(int64_t)30) || (basetag==(int64_t)33)) {
        } else {
            if ((basetag > (int64_t)35)) {
            } else {
                pc_support_pcerror((uint8_t*)"makearray elem");
            };
        };
    };
    l = pc_objlib_array_new(arraytype,elemtype,n,lower);
    p = (*l).uarray.ptr;
    esize = pc_decls_ttsize[(elemtype)];
    av_1 = n;
    while (av_1-- > 0) {
L318 :;
        pc_pcfns_pc_storepacked(p,a,elemtype);
        p += esize;
        --a;
L319 :;
    }L320 :;
    ;
    pc_objlib_objtovar(l,b);
}

void pc_pcfns_pc_makerange(struct pc_decls_varrec * x,struct pc_decls_varrec * y,struct pc_decls_varrec * z) {
    if ((((int64_t)((uint64_t)((*x).tag)) == (int64_t)1) && ((int64_t)((uint64_t)((*y).tag)) == (int64_t)1))) {
        (*z).tagx = (uint64_t)((int64_t)4);
        (*z).range_upper = (*y).value;
        (*z).range_lower = (*x).value;
    } else {
        pc_support_pcmxtypes((uint8_t*)"vxmakerange",x,y);
    };
}

void pc_pcfns_pc_makeset(int64_t n,struct pc_decls_varrec * data,struct pc_decls_varrec * dest) {
    struct pc_decls_varrec *  q;
    int64_t top;
    int64_t a;
    int64_t b;
    int64_t j;
    int64_t t;
    struct pc_decls_objrec *  s;
    static int64_t count = (int64_t)0;
    int64_t av_1;
    int64_t av_2;
    top = (int64_t)0;
    q = data;
    av_1 = n;
    while (av_1-- > 0) {
L321 :;
        switch ((int64_t)((*q).tag)) {
        case 4:;
        {
            a = (int64_t)((*q).range_lower);
            b = (int64_t)((*q).range_upper);
        }break;
        case 1:;
        {
            a = (*q).value;
            b = a;
        }break;
        default: {
            b = (a = pc_support_getintvalue(q));
        }
        } //SW
;
        if (((a < (int64_t)0) || (b < (int64_t)0))) {
            pc_support_pcerror((uint8_t*)"Neg set element");
        };
        if ((a > top)) {
            top = a;
        };
        if ((b > top)) {
            top = b;
        };
        ++q;
L322 :;
    }L323 :;
    ;
    s = pc_objlib_set_new((top + (int64_t)1),(int64_t)0);
    q = data;
    av_2 = n;
    while (av_2-- > 0) {
L324 :;
        switch ((int64_t)((*q).tag)) {
        case 4:;
        {
            a = (int64_t)((*q).range_lower);
            b = (int64_t)((*q).range_upper);
            if ((a > b)) {
                t = a;
                a = b;
                b = t;
            };
        }break;
        case 1:;
        {
            b = (a = (*q).value);
        }break;
        default: {
            b = (a = pc_support_getintvalue(q));
        }
        } //SW
;
        L327 :;
        for (j=a;j<=b;j+=(int64_t)1) {
L328 :;
            pc_support_setelem((byte (*)[])((*s).uset.ptr),j);
L329 :;
        }L330 :;
        ;
        ++q;
L325 :;
    }L326 :;
    ;
    pc_objlib_objtovar(s,dest);
}

void pc_pcfns_pc_makestruct(int64_t n,int64_t t,struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    byte *  p;
    int64_t i;
    int64_t nfields;
    int64_t index;
    struct pc_decls_objrec *  l;
    l = pc_objlib_struct_new(t);
    p = (*l).ustruct.ptr;
    index = (int64_t)(pc_decls_ttstartfield[(t)]);
    nfields = (int64_t)(pc_decls_ttstructfields[(t)]);
    if ((nfields != n)) {
        pc_support_pcerror((uint8_t*)"makestruct: wrong # fields");
    };
    L331 :;
    for (i=nfields;i>=(int64_t)1;i-=(int64_t)1) {
L332 :;
        pc_pcfns_pc_storepacked((p + (int64_t)((*pc_decls_pcfieldtable)[(((index + i) - (int64_t)1))-1].fieldoffset)),a,(int64_t)((*pc_decls_pcfieldtable)[(((index + i) - (int64_t)1))-1].fieldtype));
        ++a;
L333 :;
    }L334 :;
    ;
    pc_objlib_objtovar(l,b);
}

void pc_pcfns_pc_makedict(int64_t n,struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    struct pc_decls_varrec v;
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec *  q;
    int64_t m;
    struct pc_decls_objrec *  l;
    int64_t av_1;
    m = (n * (int64_t)2);
    a += (m - (int64_t)1);
    l = pc_objlib_dict_new(n);
    v.tagx = (uint64_t)((int64_t)65546);
    v.objptr = l;
    p = (*l).udict.vptr;
    q = ((p + (int64_t)((*l).udict.allocated)) - (int64_t)1);
    av_1 = n;
    while (av_1-- > 0) {
L335 :;
        pc_pcfns_adddictitem(&v,a,(a - (int64_t)1));
        a -= (int64_t)2;
L336 :;
    }L337 :;
    ;
    (*b) = v;
}

void pc_pcfns_pc_storepacked(byte * p,struct pc_decls_varrec * q,int64_t t) {
    int64_t plength;
    int64_t qlength;
    int64_t s;
    int64_t sbase;
    int64_t tbase;
    struct pc_decls_objrec *  qa;
    sbase = (int64_t)(pc_decls_ttbasetype[((s = (int64_t)((*q).tag)))]);
    tbase = (int64_t)(pc_decls_ttbasetype[(t)]);
    switch (sbase) {
    case 1:;
    case 2:;
    {
        switch (tbase) {
        case 37:;
        case 44:;
        {
            (*p) = (uint64_t)((*q).value);
            return;
        }break;
        case 38:;
        case 45:;
        {
            (*(uint16_t *)(p)) = (uint64_t)((*q).value);
            return;
        }break;
        case 39:;
        case 46:;
        {
            (*(int32_t *)(p)) = (*q).value;
            return;
        }break;
        case 40:;
        case 47:;
        case 1:;
        case 2:;
        {
            (*(int64_t *)(p)) = (*q).value;
            return;
        }break;
        case 48:;
        {
            (*(float *)(p)) = (float)((*q).value);
            return;
        }break;
        case 49:;
        {
            (*(double *)(p)) = (double)((*q).value);
            return;
        }break;
        default: {
        }
        } //SW
;
    }break;
    case 3:;
    {
        switch (tbase) {
        case 39:;
        case 46:;
        {
            (*(int32_t *)(p)) = (int64_t)((*q).xvalue);
            return;
        }break;
        case 48:;
        {
            (*(float *)(p)) = (float)((*q).xvalue);
            return;
        }break;
        case 49:;
        {
            (*(double *)(p)) = (*q).xvalue;
            return;
        }break;
        case 38:;
        case 45:;
        {
            (*(int16_t *)(p)) = (int64_t)((*q).xvalue);
            return;
        }break;
        default: {
        }
        } //SW
;
    }break;
    case 5:;
    {
        qa = (*q).objptr;
        plength = (int64_t)(pc_decls_ttlength[(t)]);
        qlength = (int64_t)((*qa).ustr.length);
        switch (tbase) {
        case 5:;
        {
            if ((t == tbase)) {
                if ((qlength != (int64_t)1)) {
                    pc_support_pcerror((uint8_t*)"Str not len 1");
                };
                (*(uint8_t *)(p)) = (uint64_t)((*(*qa).ustr.strptr));
                return;
            };
            if ((qlength > plength)) {
                qlength = plength;
            };
            memcpy((void *)(p),(void *)((*qa).ustr.strptr),(uint64_t)(qlength));
            pc_pcfns_setfslength((uint8_t *)(p),plength,qlength);
            return;
        }break;
        case 21:;
        {
            if ((qlength >= plength)) {
                memcpy((void *)(p),(void *)((*qa).ustr.strptr),(uint64_t)(plength));
                (*((p + plength) - (int64_t)1)) = (uint64_t)((int64_t)0);
            } else {
                memcpy((void *)(p),(void *)((*qa).ustr.strptr),(uint64_t)(qlength));
                (*(p + qlength)) = (uint64_t)((int64_t)0);
            };
            return;
        }break;
        default: {
        }
        } //SW
;
    }break;
    case 33:;
    {
        if ((s != t)) {
            pc_support_pcmxtypestt((uint8_t*)"spack struct",s,t);
        };
        memcpy((void *)(p),(void *)((*(*q).objptr).ustruct.ptr),(uint64_t)(pc_decls_ttsize[(t)]));
        return;
    }break;
    case 30:;
    {
        if ((s != t)) {
            pc_support_pcmxtypestt((uint8_t*)"spack array",s,t);
        };
        memcpy((void *)(p),(void *)((*(*q).objptr).uarray.ptr),(uint64_t)(pc_decls_ttsize[(t)]));
        return;
    }break;
    default: {
    }
    } //SW
;
    pc_support_pcmxtypestt((uint8_t*)"storepacked (source->dest)",s,t);
}

static void pc_pcfns_adddictitem(struct pc_decls_varrec * d,struct pc_decls_varrec * p,struct pc_decls_varrec * q) {
    struct pc_decls_objrec *  da;
    struct pc_decls_varrec *  r;
    da = (*d).objptr;
    if (((int64_t)((uint64_t)((*da).udict.length)) == (int64_t)0)) {
        pc_support_pcerror((uint8_t*)"NULL DICT");
    };
    r = pc_pcfns_finddictitem(d,p,(int64_t)1);
    if (!!((uint64_t)((*r).hasref))) {
        pc_pcfns_pc_unshare(r);
    };
    (*r) = (*q);
    if (!!((uint64_t)((*r).hasref))) {
        pc_pcfns_pc_share(r);
    };
}

int64_t pc_pcfns_gethashvalue(struct pc_decls_varrec * p) {
    int64_t hsum;
    int64_t c;
    int64_t n;
    int64_t result;
    uint8_t *  s;
    int64_t av_1;
    switch ((int64_t)((*p).tag)) {
    case 5:;
    {
        n = (int64_t)((*(*p).objptr).ustr.length);
        if (!(!!(n))) {
            return (int64_t)0;
        };
        hsum = (int64_t)0;
        s = (*(*p).objptr).ustr.strptr;
        av_1 = n;
        while (av_1-- > 0) {
L338 :;
            c = (int64_t)((*s++));
            hsum = (((hsum << (int64_t)4) - hsum) + c);
L339 :;
        }L340 :;
        ;
        result = ((hsum << (int64_t)5) - hsum);
        return (result & (int64_t)((uint64_t)9223372036854775807u));
    }break;
    case 1:;
    case 2:;
    case 3:;
    case 4:;
    {
        return (*p).value;
    }break;
    default: {
        msysnewc_m_print_startcon();
        msysnewc_m_print_u64((*p).tag,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        pc_support_pcustype((uint8_t*)"Can't hash:",p);
    }
    } //SW
;
    return (int64_t)0;
}

struct pc_decls_varrec * pc_pcfns_finddictitem(struct pc_decls_varrec * vd,struct pc_decls_varrec * p,int64_t doins) {
    int64_t index;
    int64_t size;
    int64_t keytag;
    int64_t wrapped;
    int64_t limit;
    int64_t keyvalue;
    struct pc_decls_varrec *  q;
    struct pc_decls_objrec *  pa;
    struct pc_decls_objrec *  qa;
    struct pc_decls_objrec *  d;
    //retry:
L341 :;
;
    d = (*vd).objptr;
    size = ((int64_t)((uint64_t)((*d).udict.length)) / (int64_t)2);
    index = (pc_pcfns_gethashvalue(p) & (size - (int64_t)1));
    q = ((*d).udict.vptr + (index * (int64_t)2));
    wrapped = (int64_t)0;
    keytag = (int64_t)((*p).tag);
    keyvalue = (*p).value;
    pa = (*p).objptr;
    L342 :;
    while (1) {
        if (((int64_t)((uint64_t)((*q).tag)) == (int64_t)0)) {
            goto L343 ;
        } else if (((int64_t)((uint64_t)((*q).tag)) == keytag)) {
            if ((keytag==(int64_t)1) || (keytag==(int64_t)3) || (keytag==(int64_t)2) || (keytag==(int64_t)4)) {
                if (((*q).value == keyvalue)) {
                    ++q;
                    if (!!((uint64_t)((*q).hasref))) {
                        pc_pcfns_pc_share(q);
                    };
                    return q;
                };
            }else if ((keytag==(int64_t)5)) {
                qa = (*q).objptr;
                if (((int64_t)((*pa).ustr.length) == (int64_t)((*qa).ustr.length))) {
                    if (((int64_t)(memcmp((void *)((*pa).ustr.strptr),(void *)((*qa).ustr.strptr),(uint64_t)((*pa).ustr.length))) == (int64_t)0)) {
                        ++q;
                        if (!!((uint64_t)((*q).hasref))) {
                            pc_pcfns_pc_share(q);
                        };
                        return q;
                    };
                };
            };
        };
        ++pc_pcfns_clashes;
        ++index;
        q += (int64_t)2;
        if ((index >= size)) {
            if (!!(wrapped)) {
                pc_support_pcerror((uint8_t*)"DICT FULL?");
            };
            wrapped = (int64_t)1;
            index = (int64_t)0;
            q = (*d).udict.vptr;
        };
    }L343 :;
    ;
    if (!!(doins)) {
        limit = ((size * (int64_t)3) / (int64_t)4);
        if (((int64_t)((uint64_t)((*d).udict.dictitems)) >= limit)) {
            pc_pcfns_expanddict(vd);
            goto L341 ;
;
        };
        (*q) = (*p);
        if (!!((uint64_t)((*q).hasref))) {
            pc_pcfns_pc_share(q);
        };
        ++(*d).udict.dictitems;
        return (q + (int64_t)1);
    } else {
        return (struct pc_decls_varrec *)(0);
    };
}

static void pc_pcfns_expanddict(struct pc_decls_varrec * vd) {
    int64_t n;
    int64_t m;
    int64_t i;
    struct pc_decls_objrec *  d;
    struct pc_decls_objrec *  e;
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec *  q;
    struct pc_decls_varrec *  r;
    struct pc_decls_varrec ev;
    d = (*vd).objptr;
    n = (int64_t)((*d).udict.allocated);
    m = (n / (int64_t)2);
    p = (*d).udict.vptr;
    e = pc_objlib_dict_new((m * (int64_t)2));
    pc_objlib_objtovar(e,&ev);
    q = p;
    L344 :;
    for (i=(int64_t)1;i<=m;i+=(int64_t)1) {
L345 :;
        if (((int64_t)((uint64_t)((*q).tag)) != (int64_t)0)) {
            r = pc_pcfns_finddictitem(&ev,q,(int64_t)1);
            if (!!((uint64_t)((*q).hasref))) {
                pc_pcfns_pc_unshare(q);
            };
            ++q;
            (*r) = (*q++);
        } else {
            q += (int64_t)2;
        };
L346 :;
    }L347 :;
    ;
    pc_objlib_dict_free(d);
    (*vd).objptr = e;
}

static void pc_pcfns_setfslength(uint8_t * s,int64_t m,int64_t n) {
    if ((m == n)) {
    } else if ((n == (m - (int64_t)1))) {
        (*((s + m) - (int64_t)1)) = (uint64_t)0u;
    } else {
        (*((s + m) - (int64_t)2)) = (uint64_t)0u;
        (*((s + m) - (int64_t)1)) = (uint64_t)(n);
    };
}

int64_t pc_pcfns_getfslength(uint8_t * s,int64_t m) {
    s += (m - (int64_t)1);
    if (((int64_t)((*(s - (int64_t)1))) == (int64_t)0)) {
        return (int64_t)((*s));
    } else if (((int64_t)((*s)) == (int64_t)0)) {
        return (m - (int64_t)1);
    } else {
        return m;
    };
}

void pc_pcfns_pc_storeptr(struct pc_decls_varrec * p,struct pc_decls_varrec * q) {
    struct pc_decls_varrec *  dest;
    switch ((int64_t)((*p).tag)) {
    case 22:;
    {
        dest = (*p).varptr;
        if (!!((uint64_t)((*dest).hasref))) {
            pc_pcfns_pc_unshare(dest);
        };
        if (!!((uint64_t)((*q).hasref))) {
            pc_pcfns_pc_share(q);
        };
        (*dest) = (*q);
    }break;
    case 23:;
    {
        pc_pcfns_pc_storepacked((*p).uref.ptr,q,(int64_t)((*p).uref.elemtag));
        if (!!((uint64_t)((*q).hasref))) {
            pc_pcfns_pc_unshare(q);
        };
    }break;
    case 24:;
    {
        pc_pcfns_pc_storebit((*p).uref.ptr,(int64_t)((*p).uref.bitoffset),q,(int64_t)((*p).uref.elemtag),(int64_t)((*p).uref.bitlength));
    }break;
    case 29:;
    {
        pc_pcfns_pc_popptrlist(p,q);
        if (!!((uint64_t)((*p).hasref))) {
            pc_pcfns_pc_unshare(p);
        };
        if (!!((uint64_t)((*q).hasref))) {
            pc_pcfns_pc_unshare(q);
        };
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"pc_popptr",p);
    }
    } //SW
;
}

void pc_pcfns_pc_storebit(byte * p,int64_t shift,struct pc_decls_varrec * q,int64_t t,int64_t bitlength) {
    uint64_t *  pd;
    uint64_t mask1;
    uint64_t mask2;
    uint64_t newvalue;
    if (((int64_t)((uint64_t)((*q).tag)) != (int64_t)1)) {
        pc_support_pcerror((uint8_t*)"storebit not int");
    };
    switch (t) {
    case 41:;
    {
        if ((bitlength == (int64_t)0)) {
            (*p) = (uint64_t)((((int64_t)((uint64_t)((*p))) & ~(((int64_t)1 << shift))) | (((*q).value & (int64_t)1) << shift)));
        } else {
            pd = (uint64_t *)(p);
            mask1 = (uint64_t)18446744073709551614u;
            if ((bitlength==(int64_t)1)) {
            }else if ((bitlength==(int64_t)64)) {
                mask1 = (uint64_t)((int64_t)0);
            } else {
                mask1 <<= (uint64_t)((bitlength - (int64_t)1));
            };
            mask1 = ~(mask1);
            if (!!(shift)) {
                mask1 <<= (uint64_t)(shift);
            };
            mask2 = ~(mask1);
            newvalue = (uint64_t)((*q).value);
            if (!!(shift)) {
                newvalue <<= (uint64_t)(shift);
            };
            (*pd) = (((*pd) & mask2) | (newvalue & mask1));
        };
    }break;
    case 42:;
    {
        (*p) = (uint64_t)((((int64_t)((uint64_t)((*p))) & ~(((int64_t)3 << shift))) | (((*q).value & (int64_t)3) << shift)));
    }break;
    case 43:;
    {
        (*p) = (uint64_t)((((int64_t)((uint64_t)((*p))) & ~(((int64_t)15 << shift))) | (((*q).value & (int64_t)15) << shift)));
    }break;
    default: {
        pc_support_pcustypet((uint8_t*)"storebit",t);
    }
    } //SW
;
}

void pc_pcfns_pc_popptrlist(struct pc_decls_varrec * p,struct pc_decls_varrec * q) {
    int64_t i;
    int64_t nleft;
    int64_t nright;
    struct pc_decls_varrec v;
    struct pc_decls_varrec *  pdata;
    struct pc_decls_varrec *  qdata;
    struct pc_decls_objrec *  pp;
    struct pc_decls_objrec *  qq;
    pp = (*p).objptr;
    nleft = (int64_t)((*pp).ulist.length);
    pdata = (*pp).ulist.vptr;
    v.tagx = (uint64_t)((int64_t)0);
    switch ((int64_t)(pc_decls_ttbasetype[((int64_t)((*q).tag))])) {
    case 29:;
    {
        qq = (*q).objptr;
        nright = (int64_t)((*qq).ulist.length);
        //dolist:
L348 :;
;
        qdata = (*qq).ulist.vptr;
        L349 :;
        for (i=(int64_t)1;i<=nleft;i+=(int64_t)1) {
L350 :;
            if ((i <= nright)) {
                pc_pcfns_pc_storeptr(pdata,qdata++);
            } else {
                pc_pcfns_pc_storeptr(pdata,&v);
            };
            ++pdata;
L351 :;
        }L352 :;
        ;
    }break;
    case 4:;
    {
        L353 :;
        for (i=(int64_t)1;i<=nleft;i+=(int64_t)1) {
L354 :;
            if ((i <= (int64_t)2)) {
                v.tagx = (uint64_t)((int64_t)1);
                v.value = ((i == (int64_t)1)?(int64_t)((*q).range_lower):(int64_t)((*q).range_upper));
                pc_pcfns_pc_storeptr(pdata,&v);
            } else {
                v.tagx = (uint64_t)((int64_t)0);
                pc_pcfns_pc_storeptr(pdata,&v);
            };
            ++pdata;
L355 :;
        }L356 :;
        ;
    }break;
    case 32:;
    {
        qq = (*q).objptr;
        nright = (int64_t)(pc_decls_ttlength[((int64_t)((*q).tag))]);
        goto L348 ;
;
    }break;
    case 30:;
    {
        pc_support_pcerror((uint8_t*)"POPPTRLIST ARRAY");
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"popptrlist",q);
    }
    } //SW
;
}

void pc_pcfns_pc_loadpacked(void * p,int64_t t,struct pc_decls_varrec * dest,struct pc_decls_objrec * ownerobj) {
    int64_t length;
    struct pc_decls_objrec *  s;
    uint8_t *  ss;
    int64_t av_1;
    switch ((int64_t)(pc_decls_ttbasetype[(t)])) {
    case 37:;
    {
        (*dest).tagx = (uint64_t)((int64_t)1);
        (*dest).value = (int64_t)((*(int8_t *)(p)));
    }break;
    case 38:;
    {
        (*dest).tagx = (uint64_t)((int64_t)1);
        (*dest).value = (int64_t)((*(int16_t *)(p)));
    }break;
    case 39:;
    {
        (*dest).tagx = (uint64_t)((int64_t)1);
        (*dest).value = (int64_t)((*(int32_t *)(p)));
    }break;
    case 40:;
    case 1:;
    {
        (*dest).tagx = (uint64_t)((int64_t)1);
        (*dest).value = (*(int64_t *)(p));
    }break;
    case 44:;
    {
        (*dest).tagx = (uint64_t)((int64_t)1);
        (*dest).value = (int64_t)((*(byte *)(p)));
    }break;
    case 45:;
    {
        (*dest).tagx = (uint64_t)((int64_t)1);
        (*dest).value = (int64_t)((*(uint16_t *)(p)));
    }break;
    case 46:;
    {
        (*dest).tagx = (uint64_t)((int64_t)1);
        (*dest).value = (int64_t)((*(uint32_t *)(p)));
    }break;
    case 47:;
    {
        (*dest).tagx = (uint64_t)((int64_t)2);
        (*dest).value = (int64_t)((*(uint32_t *)(p)));
    }break;
    case 49:;
    {
        (*dest).tagx = (uint64_t)((int64_t)3);
        (*dest).xvalue = (*(double *)(p));
    }break;
    case 48:;
    {
        (*dest).tagx = (uint64_t)((int64_t)3);
        (*dest).xvalue = (double)((*(float *)(p)));
    }break;
    case 5:;
    {
        (*dest).tagx = (uint64_t)((int64_t)65541);
        length = (int64_t)(pc_decls_ttlength[(t)]);
        if ((length >= (int64_t)2)) {
            length = pc_pcfns_getfslength((uint8_t *)(p),length);
        } else {
            length = (int64_t)1;
        };
        s = pc_objlib_make_strslicexobj((uint8_t *)(p),length);
        (*dest).objptr = s;
    }break;
    case 21:;
    {
        (*dest).tagx = (uint64_t)((int64_t)65541);
        ss = (uint8_t *)(p);
        av_1 = (int64_t)(pc_decls_ttlength[(t)]);
        while (av_1-- > 0) {
L357 :;
            if (((int64_t)((*ss)) == (int64_t)0)) {
                goto L359 ;
            };
            ++ss;
L358 :;
        }L359 :;
        ;
        s = pc_objlib_make_strslicexobj((uint8_t *)(p),(ss - (uint8_t *)(p)));
        (*dest).objptr = s;
    }break;
    case 23:;
    {
        (*dest).tagx = (uint64_t)((int64_t)23);
        (*dest).uref.ptr = (byte *)((*(int32_t * *)(p)));
        (*dest).uref.elemtag = (uint64_t)(pc_decls_tttarget[(t)]);
    }break;
    case 33:;
    {
        s = pc_objlib_obj_new(t);
        (*s).ustruct.mutable = (uint64_t)((int64_t)1);
        (*s).ustruct.ptr = (byte *)(p);
        //dostruct:
L360 :;
;
        (*dest).objptr = s;
        (*dest).tagx = (uint64_t)((t | (int64_t)65536));
        if (!!(ownerobj)) {
            (*s).objtype = (uint64_t)((int64_t)1);
            (*s).ustruct.objptr2 = ownerobj;
            ++(*ownerobj).refcount;
        } else {
            (*s).objtype = (uint64_t)((int64_t)2);
        };
    }break;
    case 30:;
    {
        s = pc_objlib_array_new(t,(int64_t)(pc_decls_tttarget[(t)]),(int64_t)(pc_decls_ttlength[(t)]),(int64_t)(pc_decls_ttlower[(t)]));
        (*s).uarray.mutable = (uint64_t)((int64_t)1);
        (*s).uarray.lower = (int64_t)(pc_decls_ttlower[(t)]);
        (*s).uarray.ptr = (byte *)(p);
        (*s).uarray.length = (uint64_t)(pc_decls_ttlength[(t)]);
        (*s).uarray.elemtag = (int64_t)(pc_decls_tttarget[(t)]);
        goto L360 ;
;
    }break;
    default: {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"T=",NULL);
        msysnewc_m_print_i64(t,NULL);
        msysnewc_m_print_i64(pc_decls_ttbasetype[(t)],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        pc_support_pcmxtypestt((uint8_t*)"loadpacked",t,(int64_t)(pc_decls_ttbasetype[(t)]));
    }
    } //SW
;
}

void pc_pcfns_pc_loadbit(byte * p,int64_t shift,int64_t t,int64_t bitlength,struct pc_decls_varrec * dest) {
    uint64_t *  pd;
    uint64_t mask;
    (*dest).tagx = (uint64_t)((int64_t)1);
    switch (t) {
    case 41:;
    {
        if ((bitlength == (int64_t)0)) {
            (*dest).value = !!(((int64_t)((uint64_t)((*p))) & ((int64_t)1 << shift)));
        } else {
            pd = (uint64_t *)(p);
            mask = (uint64_t)18446744073709551614u;
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"PD=",NULL);
            msysnewc_m_print_u64((*pd),(uint8_t*)"Z64BS,");
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"MASK=",NULL);
            msysnewc_m_print_u64(mask,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"SHIFT=",NULL);
            msysnewc_m_print_i64(shift,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"BITLENGTH=",NULL);
            msysnewc_m_print_i64(bitlength,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            if ((bitlength==(int64_t)1)) {
            }else if ((bitlength==(int64_t)64)) {
                mask = (uint64_t)((int64_t)0);
            } else {
                mask <<= (uint64_t)((bitlength - (int64_t)1));
            };
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"MASK",NULL);
            msysnewc_m_print_u64(mask,(uint8_t*)"Z64BS,");
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"INOT MASK",NULL);
            msysnewc_m_print_u64(~(mask),(uint8_t*)"Z64BS,");
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            (*dest).value = (int64_t)((((*pd) >> shift) & ~(mask)));
        };
    }break;
    case 42:;
    {
        (*dest).value = (((int64_t)((uint64_t)((*p))) & ((int64_t)3 << shift)) >> shift);
    }break;
    case 43:;
    {
        (*dest).value = (((int64_t)((uint64_t)((*p))) & ((int64_t)15 << shift)) >> shift);
    }break;
    default: {
        pc_support_pcustypet((uint8_t*)"loadbit",t);
    }
    } //SW
;
}

void pc_pcfns_pc_loadptr(struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    switch ((int64_t)((*x).tag)) {
    case 22:;
    {
        (*y) = (*(*x).varptr);
        if (!!((uint64_t)((*y).hasref))) {
            ++(*(*y).objptr).refcount;
        };
    }break;
    case 23:;
    {
        pc_pcfns_pc_loadpacked((void *)((*x).uref.ptr),(int64_t)((*x).uref.elemtag),y,(struct pc_decls_objrec *)(0));
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"pc_loadptr",x);
    }
    } //SW
;
}

void pc_pcfns_pc_storestring(struct pc_decls_varrec * p,struct pc_decls_varrec * q) {
    struct pc_decls_objrec *  pp;
    struct pc_decls_objrec *  qq;
    pp = (*p).objptr;
    qq = (*q).objptr;
    if (((int64_t)((uint64_t)((*pp).objtype)) == (int64_t)0)) {
        pc_support_pcerror((uint8_t*)"popstr not slice");
    };
    if (((int64_t)((uint64_t)((*q).tag)) != (int64_t)5)) {
        pc_support_pcerror((uint8_t*)"popstr not str");
    };
    if (((int64_t)((*pp).ustr.length) != (int64_t)((*qq).ustr.length))) {
        pc_support_pcerror((uint8_t*)"popstr diff lengths");
    };
    if (!(!!((uint64_t)((*pp).ustr.mutable)))) {
        pc_support_pcerror((uint8_t*)"popstr not mut");
    };
    if (!!((int64_t)((*pp).ustr.length))) {
        memcpy((void *)((*pp).ustr.strptr),(void *)((*qq).ustr.strptr),(uint64_t)((*pp).ustr.length));
    };
    pc_pcfns_pc_unshare(p);
    pc_pcfns_pc_unshare(q);
}

void pc_pcfns_pc_iconvert(int64_t t,struct pc_decls_varrec * x) {
    int64_t s;
    int64_t tbase;
    int64_t aa;
    struct pc_decls_varrec bn;
    s = (int64_t)((*x).tag);
    if (((s == t) && (s < (int64_t)29))) {
        return;
    };
    tbase = (int64_t)(pc_decls_ttbasetype[(t)]);
    (*x).tag = (uint64_t)(t);
    switch ((int64_t)(pc_decls_ttbasetype[(s)])) {
    case 1:;
    {
        switch (tbase) {
        case 1:;
        {
        }break;
        case 3:;
        {
            (*x).xvalue = (double)((*x).value);
        }break;
        case 2:;
        {
        }break;
        case 7:;
        {
            pc_bignum_bx_makeint((*pc_decls_sptr).value,pc_decls_sptr);
        }break;
        default: {
            pc_support_pcustypet((uint8_t*)"conv dint=>",t);
        }
        } //SW
;
    }break;
    case 2:;
    {
        switch (tbase) {
        case 1:;
        {
        }break;
        case 2:;
        {
        }break;
        case 3:;
        {
        }break;
        default: {
            pc_support_pcustypet((uint8_t*)"conv dint=>",t);
        }
        } //SW
;
    }break;
    case 3:;
    {
        switch (tbase) {
        case 1:;
        {
            (*x).value = (int64_t)((*x).xvalue);
        }break;
        default: {
            pc_support_pcustypet((uint8_t*)"conv real=>",t);
        }
        } //SW
;
    }break;
    case 23:;
    case 22:;
    case 24:;
    case 18:;
    {
        switch (tbase) {
        case 1:;
        case 2:;
        {
        }break;
        default: {
            pc_support_pcustypet((uint8_t*)"conv ptr=>",t);
        }
        } //SW
;
    }break;
    case 5:;
    {
        switch (tbase) {
        case 7:;
        {
            (*((*(*x).objptr).ustr.strptr + (int64_t)((*(*x).objptr).ustr.length))) = (uint64_t)0u;
            pc_bignum_bx_makestr((*(*x).objptr).ustr.strptr,(int64_t)((*(*x).objptr).ustr.length),&bn);
            (*x).tagx = (uint64_t)((int64_t)65541);
            pc_pcfns_pc_unshare(x);
            (*x) = bn;
        }break;
        case 5:;
        {
        }break;
        default: {
            pc_support_pcustypet((uint8_t*)"string=>",t);
        }
        } //SW
;
    }break;
    case 13:;
    {
        if ((tbase != (int64_t)1)) {
            pc_support_pcustypet((uint8_t*)"type=>",t);
        };
    }break;
    case 7:;
    {
        switch (tbase) {
        case 1:;
        {
            aa = pc_bignum_bx_int(x);
            (*x).tagx = (uint64_t)((int64_t)65543);
            pc_pcfns_pc_unshare(x);
            (*x).tagx = (uint64_t)((int64_t)1);
            (*x).value = aa;
            (*x).tagx = (uint64_t)(t);
        }break;
        default: {
            pc_support_pcustypet((uint8_t*)"bignum=>",t);
        }
        } //SW
;
    }break;
    default: {
        pc_support_pcmxtypestt((uint8_t*)"HARDCONV s^.t",s,t);
    }
    } //SW
;
}

void pc_pcfns_pc_iconvcase(struct pc_decls_varrec * a,struct pc_decls_varrec * b,int64_t upper) {
    int64_t n;
    uint8_t *  s;
    struct pc_decls_objrec *  pa;
    int64_t av_1;
    int64_t av_2;
    pa = (*a).objptr;
    if (((int64_t)((uint64_t)((*b).tag)) > (int64_t)0)) {
        n = pc_support_getintvalue(b);
    } else {
        n = (int64_t)((*pa).ustr.length);
    };
    if (((int64_t)((uint64_t)((*a).tag)) != (int64_t)5)) {
        pc_support_pcerror((uint8_t*)"convcase/notstr");
    };
    if ((n < (int64_t)0)) {
        pc_support_pcerror((uint8_t*)"CONVCASE N<0");
    };
    if ((n == (int64_t)0)) {
        return;
    };
    if ((n > (int64_t)((*pa).ustr.length))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"N=",NULL);
        msysnewc_m_print_i64(n,NULL);
        msysnewc_m_print_i64((*pa).ustr.length,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        pc_support_pcerror((uint8_t*)"convcase/N?");
    };
    s = (*pa).ustr.strptr;
    if (!!(upper)) {
        av_1 = n;
        while (av_1-- > 0) {
L361 :;
            (*s) = (uint64_t)(toupper((int64_t)((int32_t)((*s)))));
            ++s;
L362 :;
        }L363 :;
        ;
    } else {
        av_2 = n;
        while (av_2-- > 0) {
L364 :;
            (*s) = (uint64_t)(tolower((int64_t)((int32_t)((*s)))));
            ++s;
L365 :;
        }L366 :;
        ;
    };
}

int64_t pc_pcfns_pc_eqstring_nf(struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    int64_t n;
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    px = (*x).objptr;
    py = (*y).objptr;
    n = (int64_t)((*px).ustr.length);
    if ((n != (int64_t)((*py).ustr.length))) {
        return (int64_t)0;
    };
    if ((n == (int64_t)0)) {
        return (int64_t)1;
    };
    return (mlib_cmpstringn((*px).ustr.strptr,(*py).ustr.strptr,n) == (int64_t)0);
}

int64_t pc_pcfns_pc_equal_nf(struct pc_decls_varrec * x,struct pc_decls_varrec * y,int64_t shallow) {
    int64_t xt;
    int64_t yt;
    int64_t xbase;
    int64_t ybase;
    int64_t nbytes;
    int64_t n;
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec *  q;
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    int64_t av_1;
    int64_t av_2;
    xbase = (int64_t)(pc_decls_ttbasetype[((xt = (int64_t)((*x).tag)))]);
    ybase = (int64_t)(pc_decls_ttbasetype[((yt = (int64_t)((*y).tag)))]);
    if ((ybase == (int64_t)0)) {
        pc_support_pcerror((uint8_t*)"pcequal/void");
    };
    px = (*x).objptr;
    py = (*y).objptr;
    switch (xbase) {
    case 1:;
    {
        switch (ybase) {
        case 1:;
        case 2:;
        {
            return (((*x).value == (*y).value)?(int64_t)1:(int64_t)0);
        }break;
        case 3:;
        {
            return (((double)((*x).value) == (*y).xvalue)?(int64_t)1:(int64_t)0);
        }break;
        default: {
        }
        } //SW
;
    }break;
    case 2:;
    {
        switch (ybase) {
        case 46:;
        {
            return (((*x).uvalue == (*y).uvalue)?(int64_t)1:(int64_t)0);
        }break;
        default: {
        }
        } //SW
;
    }break;
    case 3:;
    {
        switch (ybase) {
        case 1:;
        {
            return (((*x).xvalue == (double)((*y).value))?(int64_t)1:(int64_t)0);
        }break;
        case 3:;
        {
            return (((*x).xvalue == (*y).xvalue)?(int64_t)1:(int64_t)0);
        }break;
        default: {
        }
        } //SW
;
    }break;
    case 4:;
    {
        if ((ybase == (int64_t)4)) {
            return (((*x).value == (*y).value)?(int64_t)1:(int64_t)0);
        };
    }break;
    case 22:;
    {
        switch (ybase) {
        case 22:;
        case 1:;
        {
            return ((*x).value == (*y).value);
        }break;
        default: {
        }
        } //SW
;
    }break;
    case 23:;
    {
        switch (ybase) {
        case 23:;
        case 1:;
        {
            return ((*x).value == (*y).value);
        }break;
        default: {
        }
        } //SW
;
    }break;
    case 18:;
    {
        switch (ybase) {
        case 18:;
        case 1:;
        {
            return ((*x).value == (*y).value);
        }break;
        default: {
        }
        } //SW
;
    }break;
    case 29:;
    {
        if ((ybase == (int64_t)29)) {
            if (!!(shallow)) {
                return (px == py);
            };
            if (((uint64_t)((*px).ulist.length) != (uint64_t)((*py).ulist.length))) {
                return (int64_t)0;
            };
            p = (*px).ulist.vptr;
            q = (*py).ulist.vptr;
            av_1 = (int64_t)((*px).ulist.length);
            while (av_1-- > 0) {
L367 :;
                if ((pc_pcfns_pc_equal_nf(p++,q++,shallow) == (int64_t)0)) {
                    return (int64_t)0;
                };
L368 :;
            }L369 :;
            ;
            return (int64_t)1;
        };
    }break;
    case 5:;
    {
        switch (ybase) {
        case 5:;
        {
            return pc_pcfns_pc_eqstring_nf(x,y);
        }break;
        default: {
        }
        } //SW
;
    }break;
    case 33:;
    {
        if ((xt != yt)) {
            return (int64_t)0;
        };
        return pc_pcfns_comparebytes((*px).ustruct.ptr,(*py).ustruct.ptr,pc_decls_ttsize[(xt)]);
    }break;
    case 9:;
    {
        if ((ybase != (int64_t)9)) {
            return (int64_t)0;
        };
        if (((uint64_t)((*px).uset.length) != (uint64_t)((*py).uset.length))) {
            return (int64_t)0;
        };
        nbytes = ((((int64_t)((uint64_t)((*px).uset.length)) - (int64_t)1) / (int64_t)64) + (int64_t)1);
        return pc_pcfns_comparebytes((*px).uset.ptr,(*py).uset.ptr,nbytes);
    }break;
    case 0:;
    {
        pc_support_pcerror((uint8_t*)"Comparing void types");
    }break;
    case 7:;
    {
        if ((ybase != (int64_t)7)) {
            return (int64_t)0;
        };
        return (pc_bignum_bx_equal(x,y) == (int64_t)1);
    }break;
    case 32:;
    {
        if ((xt != yt)) {
            return (int64_t)0;
        };
        if (!!(shallow)) {
            return (px == py);
        };
        p = (*px).urec.vptr;
        q = (*py).urec.vptr;
        n = (int64_t)(pc_decls_ttlength[(xt)]);
        av_2 = n;
        while (av_2-- > 0) {
L370 :;
            if ((pc_pcfns_pc_equal_nf(p++,q++,shallow) == (int64_t)0)) {
                return (int64_t)0;
            };
L371 :;
        }L372 :;
        ;
        return (int64_t)1;
    }break;
    case 30:;
    {
        if ((((xt != yt) || (xbase != ybase)) || ((int64_t)((*px).uarray.elemtag) != (int64_t)((*py).uarray.elemtag)))) {
            return (int64_t)0;
        };
        if (((uint64_t)((*px).uarray.length) != (uint64_t)((*py).uarray.length))) {
            return (int64_t)0;
        };
        return pc_pcfns_comparebytes((*px).uarray.ptr,(*py).uarray.ptr,((int64_t)((uint64_t)((*px).uarray.length)) * pc_decls_ttsize[((int64_t)((*px).uarray.elemtag))]));
    }break;
    case 13:;
    {
        if (((ybase == (int64_t)13) && ((*x).value == (*y).value))) {
            return (int64_t)1;
        };
    }break;
    default: {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"DIFF TYPES",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        return (int64_t)0;
    }
    } //SW
;
    return (int64_t)0;
}

int64_t pc_pcfns_comparebytes(byte * p,byte * q,int64_t n) {
    return ((int64_t)(memcmp((void *)(p),(void *)(q),(uint64_t)(n))) == (int64_t)0);
}

int64_t pc_pcfns_pc_compare_nf(struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    int64_t xt;
    int64_t yt;
    int64_t xbase;
    int64_t ybase;
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    ybase = (int64_t)(pc_decls_ttbasetype[((yt = (int64_t)((*y).tag)))]);
    xbase = (int64_t)(pc_decls_ttbasetype[((xt = (int64_t)((*x).tag)))]);
    switch (xbase) {
    case 1:;
    {
        switch (ybase) {
        case 1:;
        {
            return (((*x).value < (*y).value)?(int64_t)-1:(((*x).value > (*y).value)?(int64_t)1:(int64_t)0));
        }break;
        case 3:;
        {
            return (((double)((*x).value) < (*y).xvalue)?(int64_t)-1:(((double)((*x).value) > (*y).xvalue)?(int64_t)1:(int64_t)0));
        }break;
        default: {
            goto L373 ;
;
        }
        } //SW
;
    }break;
    case 2:;
    {
        switch (ybase) {
        case 2:;
        {
            return (((*x).uvalue < (*y).uvalue)?(int64_t)-1:(((*x).uvalue > (*y).uvalue)?(int64_t)1:(int64_t)0));
        }break;
        default: {
            goto L373 ;
;
        }
        } //SW
;
    }break;
    case 3:;
    {
        switch (ybase) {
        case 1:;
        {
            return (((*x).xvalue < (double)((*y).value))?(int64_t)-1:(((*x).xvalue > (double)((*y).value))?(int64_t)1:(int64_t)0));
        }break;
        case 3:;
        {
            return (((*x).xvalue < (*y).xvalue)?(int64_t)-1:(((*x).xvalue > (*y).xvalue)?(int64_t)1:(int64_t)0));
        }break;
        default: {
            goto L373 ;
;
        }
        } //SW
;
    }break;
    case 23:;
    {
        switch (ybase) {
        case 23:;
        case 1:;
        {
            return (((*x).value < (*y).value)?(int64_t)-1:(((*x).value > (*y).value)?(int64_t)1:(int64_t)0));
        }break;
        default: {
            goto L373 ;
;
        }
        } //SW
;
    }break;
    case 22:;
    {
        switch (ybase) {
        case 22:;
        case 1:;
        {
            return (((*x).value < (*y).value)?(int64_t)-1:(((*x).value > (*y).value)?(int64_t)1:(int64_t)0));
        }break;
        default: {
            goto L373 ;
;
        }
        } //SW
;
    }break;
    case 5:;
    {
        switch (ybase) {
        case 5:;
        {
            px = (*x).objptr;
            py = (*y).objptr;
            return pc_pcfns_cmpstring_len((*px).ustr.strptr,(*py).ustr.strptr,(int64_t)((*px).ustr.length),(int64_t)((*py).ustr.length));
        }break;
        default: {
            goto L373 ;
;
        }
        } //SW
;
    }break;
    case 7:;
    {
        if ((ybase == (int64_t)7)) {
            return pc_bignum_bx_cmp(x,y);
        } else {
            goto L373 ;
;
        };
    }break;
    default: {
        //badcmp:
L373 :;
;
        pc_support_pcmxtypes((uint8_t*)"pc_compare",x,y);
    }
    } //SW
;
    return (int64_t)0;
}

int64_t pc_pcfns_cmpstring_len(uint8_t * s,uint8_t * t,int64_t slen,int64_t tlen) {
    if ((slen == (int64_t)0)) {
        if ((tlen == (int64_t)0)) {
            return (int64_t)0;
        } else {
            return (int64_t)-1;
        };
    } else if ((tlen == (int64_t)0)) {
        return (int64_t)1;
    } else {
        if ((slen == tlen)) {
            if ((slen == (int64_t)1)) {
                if (((uint64_t)((*s)) < (uint64_t)((*t)))) {
                    return (int64_t)-1;
                } else if (((uint64_t)((*s)) > (uint64_t)((*t)))) {
                    return (int64_t)1;
                } else {
                    return (int64_t)0;
                };
            };
            return mlib_cmpstringn(s,t,slen);
        } else {
            return mlib_cmpstring(pc_support_convcstring(s,slen),pc_support_convcstring(t,tlen));
        };
    };
}

int64_t pc_pcfns_pc_eqstring(struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    int64_t res;
    res = pc_pcfns_pc_eqstring_nf(x,y);
    px = (*x).objptr;
    py = (*y).objptr;
    if (!!((uint64_t)((*x).hasref))) {
        pc_pcfns_pc_unshare(x);
    };
    if (!!((uint64_t)((*y).hasref))) {
        pc_pcfns_pc_unshare(y);
    };
    return res;
}

int64_t pc_pcfns_pc_equal(struct pc_decls_varrec * x,struct pc_decls_varrec * y,int64_t shallow) {
    int64_t res;
    if ((((uint64_t)((*x).tag) != (uint64_t)((*y).tag)) && (((int64_t)((uint64_t)((*x).tag)) == (int64_t)7) || ((int64_t)((uint64_t)((*y).tag)) == (int64_t)7)))) {
        pc_support_pcerror((uint8_t*)"pcequal/mixed bignum");
    };
    res = pc_pcfns_pc_equal_nf(x,y,shallow);
    if (!!((uint64_t)((*x).hasref))) {
        pc_pcfns_pc_unshare(x);
    };
    if (!!((uint64_t)((*y).hasref))) {
        pc_pcfns_pc_unshare(y);
    };
    return res;
}

int64_t pc_pcfns_pc_compare(struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    int64_t res;
    res = pc_pcfns_pc_compare_nf(x,y);
    if (!!((uint64_t)((*x).hasref))) {
        pc_pcfns_pc_unshare(x);
    };
    if (!!((uint64_t)((*y).hasref))) {
        pc_pcfns_pc_unshare(y);
    };
    return res;
}

int64_t pc_pcfns_u8inarray(byte a,struct pc_decls_objrec * p) {
    int64_t i;
    byte *  q;
    int64_t av_1;
    i = (int64_t)((*p).uarray.lower);
    q = (*p).uarray.ptr;
    av_1 = (int64_t)((*p).uarray.length);
    while (av_1-- > 0) {
L374 :;
        if (((uint64_t)((*q)) == (uint64_t)(a))) {
            return i;
        };
        ++q;
        ++i;
L375 :;
    }L376 :;
    ;
    return ((int64_t)((*p).uarray.lower) - (int64_t)1);
}

int64_t pc_pcfns_u16inarray(uint16_t a,struct pc_decls_objrec * p) {
    int64_t i;
    uint16_t *  q;
    int64_t av_1;
    i = (int64_t)((*p).uarray.lower);
    q = (uint16_t *)((*p).uarray.ptr);
    av_1 = (int64_t)((*p).uarray.length);
    while (av_1-- > 0) {
L377 :;
        if (((uint64_t)((*q)) == (uint64_t)(a))) {
            return i;
        };
        ++q;
        ++i;
L378 :;
    }L379 :;
    ;
    return ((int64_t)((*p).uarray.lower) - (int64_t)1);
}

int64_t pc_pcfns_u32inarray(uint32_t a,struct pc_decls_objrec * p) {
    int64_t i;
    uint32_t *  q;
    int64_t av_1;
    i = (int64_t)((*p).uarray.lower);
    q = (uint32_t *)((*p).uarray.ptr);
    av_1 = (int64_t)((*p).uarray.length);
    while (av_1-- > 0) {
L380 :;
        if (((uint64_t)((*q)) == (uint64_t)(a))) {
            return i;
        };
        ++q;
        ++i;
L381 :;
    }L382 :;
    ;
    return ((int64_t)((*p).uarray.lower) - (int64_t)1);
}

int64_t pc_pcfns_u64inarray(uint64_t a,struct pc_decls_objrec * p) {
    int64_t i;
    uint64_t *  q;
    int64_t av_1;
    i = (int64_t)((*p).uarray.lower);
    q = (uint64_t *)((*p).uarray.ptr);
    av_1 = (int64_t)((*p).uarray.length);
    while (av_1-- > 0) {
L383 :;
        if (((*q) == a)) {
            return i;
        };
        ++q;
        ++i;
L384 :;
    }L385 :;
    ;
    return ((int64_t)((*p).uarray.lower) - (int64_t)1);
}

int64_t pc_pcfns_bitinbits(byte a,struct pc_decls_objrec * p) {
    int64_t i;
    int64_t offset;
    int64_t mask;
    byte *  q;
    int64_t av_1;
    i = (int64_t)((*p).ubits.lower);
    q = (*p).ubits.ptr;
    offset = ((int64_t)((uint64_t)((*p).ubits.bitoffset)) - (int64_t)1);
    mask = (int64_t)1;
    if (!!(offset)) {
        mask = (mask << offset);
    };
    av_1 = (int64_t)((*p).ubits.length);
    while (av_1-- > 0) {
L386 :;
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"Q^=",NULL);
        msysnewc_m_print_u64((*q),NULL);
        msysnewc_m_print_i64(((int64_t)((uint64_t)((*q))) & mask),NULL);
        msysnewc_m_print_str((uint8_t*)"MASK=",NULL);
        msysnewc_m_print_i64(mask,NULL);
        msysnewc_m_print_i64(i,NULL);
        msysnewc_m_print_str((uint8_t*)"A=",NULL);
        msysnewc_m_print_u64(a,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        if (!!(((int64_t)((uint64_t)((*q))) & mask))) {
            if (!!((uint64_t)(a))) {
                return i;
            };
        } else if (((int64_t)((uint64_t)(a)) == (int64_t)0)) {
            return i;
        };
        ++i;
        mask <<= (int64_t)1;
        if ((mask >= (int64_t)256)) {
            mask = (int64_t)1;
            ++q;
        };
L387 :;
    }L388 :;
    ;
    return ((int64_t)((*p).ubits.lower) - (int64_t)1);
}

int64_t pc_pcfns_pc_strinstr(struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    int64_t xlen;
    int64_t ylen;
    int64_t i;
    int64_t j;
    int64_t k;
    uint8_t *  sx;
    uint8_t *  sy;
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    px = (*x).objptr;
    py = (*y).objptr;
    xlen = (int64_t)((*px).ustr.length);
    ylen = (int64_t)((*py).ustr.length);
    if (((xlen == (int64_t)0) || (ylen == (int64_t)0))) {
        return (int64_t)0;
    };
    k = (ylen - xlen);
    L389 :;
    for (i=(int64_t)0;i<=k;i+=(int64_t)1) {
L390 :;
        sx = (*px).ustr.strptr;
        sy = ((*py).ustr.strptr + i);
        L393 :;
        for (j=(int64_t)1;j<=xlen;j+=(int64_t)1) {
L394 :;
            if (((uint64_t)((*sx)) != (uint64_t)((*sy)))) {
                goto L397 ;
;
            };
            ++sx;
            ++sy;
L395 :;
        }L396 :;
        ;
        return (i + (int64_t)1);
        //nextpos:
L397 :;
;
L391 :;
    }L392 :;
    ;
    return (int64_t)0;
}

byte * pc_pcfns_getbitoffset(byte * p,int64_t offset,int64_t index,int64_t t,byte * newoffset) {
    switch (t) {
    case 41:;
    {
        index += offset;
        p += (index >> (int64_t)3);
        (*newoffset) = (uint64_t)((index & (int64_t)7));
    }break;
    case 42:;
    {
        index += (offset >> (int64_t)1);
        p += (index >> (int64_t)2);
        (*newoffset) = (uint64_t)(((index & (int64_t)3) * (int64_t)2));
    }break;
    case 43:;
    {
        index += (offset >> (int64_t)2);
        p += (index >> (int64_t)1);
        (*newoffset) = (uint64_t)(((index & (int64_t)1) * (int64_t)4));
    }break;
    default: {
    }
    } //SW
;
    return p;
}

void pc_pcfns_pc_iappendlist(struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    int64_t n;
    struct pc_decls_varrec *  q;
    struct pc_decls_objrec *  p;
    p = (*a).objptr;
    if (((int64_t)((uint64_t)((*p).objtype)) != (int64_t)0)) {
        pc_support_pcerror((uint8_t*)"Can't extend slice");
    };
    if (!(!!((uint64_t)((*p).ulist.mutable)))) {
        p = pc_objlib_copyonwrite(p,(int64_t)29);
    };
    n = ((int64_t)((uint64_t)((*p).ulist.length)) + (int64_t)1);
    if ((n > (int64_t)((uint64_t)((*p).ulist.allocated)))) {
        pc_objlib_list_resize(p,n);
    } else {
        (*p).ulist.length = (uint64_t)(n);
    };
    (*(((*p).ulist.vptr + n) - (int64_t)1)).tagx = (uint64_t)((int64_t)0);
    (*a).objptr = p;
    q = (((*p).ulist.vptr + (int64_t)((*p).ulist.length)) - (int64_t)1);
    if (!!(b)) {
        (*q) = (*b);
    } else {
        (*q).tagx = (uint64_t)((int64_t)0);
    };
}

void pc_pcfns_pc_iappendarray(struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    int64_t n;
    byte *  q;
    struct pc_decls_objrec *  p;
    p = (*a).objptr;
    if (((int64_t)((uint64_t)((*p).objtype)) != (int64_t)0)) {
        pc_support_pcerror((uint8_t*)"Can't extend slice");
    };
    if (!(!!((uint64_t)((*p).uarray.mutable)))) {
        p = pc_objlib_copyonwrite(p,(int64_t)((*a).tag));
    };
    n = ((int64_t)((uint64_t)((*p).uarray.length)) + (int64_t)1);
    if ((n > (int64_t)((uint64_t)((*p).uarray.allocated)))) {
        pc_objlib_array_resize(p,n);
    } else {
        (*p).uarray.length = (uint64_t)(n);
    };
    (*a).objptr = p;
    q = ((*p).uarray.ptr + (((int64_t)((uint64_t)((*p).uarray.length)) - (int64_t)1) * pc_decls_ttsize[((int64_t)((*p).uarray.elemtag))]));
    if (!!(b)) {
        pc_pcfns_pc_storepacked(q,b,(int64_t)((*p).uarray.elemtag));
    };
}

void pc_pcfns_pc_mul_listi(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c) {
    struct pc_decls_varrec *  newptr;
    struct pc_decls_varrec *  oldptr;
    struct pc_decls_varrec *  q;
    int64_t newlength;
    int64_t oldlength;
    struct pc_decls_varrec d;
    struct pc_decls_objrec *  pa;
    struct pc_decls_objrec *  pc;
    int64_t av_1;
    d = (*a);
    pa = d.objptr;
    oldlength = (int64_t)((*pa).ulist.length);
    newlength = (oldlength * (*b).value);
    oldptr = (*pa).ulist.vptr;
    if (!(!!(oldlength))) {
        return;
    };
    if ((newlength < (int64_t)0)) {
        pc_support_pcerror((uint8_t*)"mullist 0");
    } else if ((newlength == (int64_t)0)) {
        if (!!((uint64_t)((*a).hasref))) {
            pc_pcfns_pc_unshare(a);
        };
        (*c).tagx = (uint64_t)((int64_t)29);
        (*c).objptr = pc_objlib_emptylist;
        ++(*pc_objlib_emptylist).refcount;
        return;
    };
    if ((oldlength == (int64_t)1)) {
        pc = pc_objlib_list_new(newlength,(int64_t)((*pa).ulist.lower),(struct pc_decls_varrec *)(0));
        newptr = (*pc).ulist.vptr;
        (*c).tagx = (uint64_t)(d.tagx);
        (*c).objptr = pc;
        q = (*d.objptr).ulist.vptr;
        av_1 = newlength;
        while (av_1-- > 0) {
L398 :;
            (*newptr) = (*q);
            if (!!((uint64_t)((*newptr).hasref))) {
                ++(*(*newptr).objptr).refcount;
                pc_pcfns_pc_dupl(newptr);
            };
            ++newptr;
L399 :;
        }L400 :;
        ;
        if (!!((uint64_t)(d.hasref))) {
            pc_pcfns_pc_unshare(&d);
        };
    } else {
        pc_support_pcerror((uint8_t*)"MULLISTINT/COMPLEX");
    };
}

void pc_pcfns_pc_mul_stri(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c) {
    int64_t m;
    int64_t oldlen;
    int64_t newlen;
    uint8_t *  p;
    struct pc_decls_varrec v;
    struct pc_decls_objrec *  pa;
    int64_t av_1;
    m = pc_support_getintvalue(b);
    if ((m < (int64_t)0)) {
        pc_support_pcerror((uint8_t*)"neg str mul");
    } else if ((m == (int64_t)0)) {
        pc_pcfns_pc_emptystring(c);
        return;
    } else if ((m == (int64_t)1)) {
        if ((a != c)) {
            (*c) = (*a);
            if (!!((uint64_t)((*c).hasref))) {
                pc_pcfns_pc_share(c);
            };
        };
        return;
    } else {
        pa = (*a).objptr;
        oldlen = (int64_t)((*pa).ustr.length);
        if (!!(oldlen)) {
            newlen = (oldlen * m);
            pc_pcfns_pc_makestringn(newlen,&v);
            p = (*v.objptr).ustr.strptr;
            av_1 = m;
            while (av_1-- > 0) {
L401 :;
                memcpy((void *)(p),(void *)((*pa).ustr.strptr),(uint64_t)(oldlen));
                p += oldlen;
L402 :;
            }L403 :;
            ;
            pc_pcfns_pc_unshare(a);
            (*c) = v;
        } else {
            (*c) = (*a);
            pc_pcfns_pc_share(a);
            return;
        };
    };
}

void pc_pcfns_pc_duplvar(struct pc_decls_varrec * p) {
    if (!!((uint64_t)((*p).hasref))) {
        ((*pc_decls_dupl_table[((int64_t)((*p).tag))]))(p);
    };
}

void pc_pcfns_pc_iconcatlist(struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    struct pc_decls_varrec *  d;
    int64_t alen;
    int64_t blen;
    int64_t newlen;
    struct pc_decls_objrec *  pa;
    struct pc_decls_objrec *  pb;
    int64_t av_1;
    int64_t av_2;
    pa = (*a).objptr;
    if (!(!!((uint64_t)((*pa).ulist.mutable)))) {
        pa = pc_objlib_copyonwrite(pa,(int64_t)((*a).tag));
        (*a).objptr = pa;
    };
    pb = (*b).objptr;
    alen = (int64_t)((*pa).ulist.length);
    blen = (int64_t)((*pb).ulist.length);
    if ((alen == (int64_t)0)) {
        if (!!(blen)) {
            pc_objlib_list_resize(pa,blen);
            d = (*pa).ulist.vptr;
            memcpy((void *)(d),(void *)((*pb).ulist.vptr),(uint64_t)((blen * (int64_t)16)));
            av_1 = blen;
            while (av_1-- > 0) {
L404 :;
                if (!!((uint64_t)((*d).hasref))) {
                    pc_pcfns_pc_share(d);
                };
                ++d;
L405 :;
            }L406 :;
            ;
        };
    } else if (!!(blen)) {
        newlen = (alen + blen);
        pc_objlib_list_resize(pa,newlen);
        d = ((*pa).ulist.vptr + alen);
        memcpy((void *)(d),(void *)((*pb).ulist.vptr),(uint64_t)((blen * (int64_t)16)));
        av_2 = blen;
        while (av_2-- > 0) {
L407 :;
            if (!!((uint64_t)((*d).hasref))) {
                pc_pcfns_pc_share(d);
            };
            ++d;
L408 :;
        }L409 :;
        ;
    };
}

void pc_pcfns_pc_iappendbits(struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    int64_t elemtype;
    int64_t n;
    byte bitoffset;
    byte *  q;
    struct pc_decls_objrec *  p;
    p = (*a).objptr;
    if (!(!!((uint64_t)((*p).ubits.mutable)))) {
        (*a).objptr = (p = pc_objlib_copyonwrite(p,(int64_t)((*a).tag)));
    };
    n = ((int64_t)((uint64_t)((*p).ubits.length)) + (int64_t)1);
    if (((uint64_t)(n) > (*p).ubits.allocated64)) {
        pc_objlib_bits_resize(p,n);
    } else {
        (*p).ubits.length = (uint64_t)(n);
    };
    elemtype = (int64_t)((*p).ubits.elemtag);
    q = pc_pcfns_getbitoffset((*p).ubits.ptr,((int64_t)((uint64_t)((*p).ubits.bitoffset)) - (int64_t)1),((int64_t)((uint64_t)((*p).ubits.length)) - (int64_t)1),elemtype,&bitoffset);
    if (!!(b)) {
        pc_pcfns_pc_storebit(q,(int64_t)(bitoffset),b,elemtype,(int64_t)0);
    };
}

void pc_pcfns_pc_makestring(uint8_t * s,int64_t length,struct pc_decls_varrec * dest) {
    uint8_t *  t;
    if ((s == 0)) {
        pc_pcfns_pc_makestringx((uint8_t *)(0),(int64_t)0,(int64_t)0,dest);
        return;
    };
    if ((length == (int64_t)-1)) {
        length = (int64_t)(strlen((int8_t *)(s)));
    };
    if ((length == (int64_t)0)) {
        pc_pcfns_pc_makestringx(t,(int64_t)0,(int64_t)0,dest);
    } else {
        t = (uint8_t *)(mlib_pcm_alloc(length));
        memcpy((void *)(t),(void *)(s),(uint64_t)(length));
        pc_pcfns_pc_makestringx(t,length,mlib_allocbytes,dest);
    };
}

void pc_pcfns_pc_makestringx(uint8_t * s,int64_t length,int64_t allocated,struct pc_decls_varrec * dest) {
    struct pc_decls_objrec *  p;
    if ((length == (int64_t)-1)) {
        length = (int64_t)(strlen((int8_t *)(s)));
    };
    (*dest).tagx = (uint64_t)((int64_t)65541);
    (*dest).objptr = (p = pc_objlib_obj_new((int64_t)5));
    if ((length == (int64_t)0)) {
        (*p).ustr.strptr = (uint8_t *)(0);
    } else {
        (*p).ustr.strptr = s;
        (*p).ustr.length = length;
        (*p).ustr.allocated = (uint64_t)(allocated);
    };
    (*p).ustr.mutable = (uint64_t)((int64_t)1);
}

void pc_pcfns_pc_makestringn(int64_t length,struct pc_decls_varrec * dest) {
    struct pc_decls_objrec *  p;
    (*dest).tagx = (uint64_t)((int64_t)65541);
    (*dest).objptr = (p = pc_objlib_obj_new((int64_t)5));
    if ((length > (int64_t)4000000000)) {
        pc_support_pcerror((uint8_t*)"String*n too long");
    };
    (*p).ustr.strptr = (uint8_t *)(mlib_pcm_alloc(length));
    (*p).ustr.mutable = (uint64_t)((int64_t)1);
    (*p).ustr.length = length;
    (*p).ustr.allocated = (uint64_t)(mlib_allocbytes);
}

void pc_pcfns_pc_emptystring(struct pc_decls_varrec * dest) {
    (*dest).tagx = (uint64_t)((int64_t)65541);
    (*dest).objptr = pc_objlib_emptystring;
    ++(*pc_objlib_emptystring).refcount;
}

void pc_pcfns_pc_makechar(int64_t ch,struct pc_decls_varrec * dest) {
    struct pc_decls_varrec v;
    uint8_t str[10];
    struct pc_decls_objrec *  p;
    (*dest).tagx = (uint64_t)((int64_t)65541);
    p = pc_decls_chrtable[(ch)];
    if ((p == 0)) {
        str[((int64_t)1)-1] = (uint64_t)(ch);
        str[((int64_t)2)-1] = (uint64_t)0u;
        pc_pcfns_pc_makestring(str,(int64_t)1,&v);
        p = v.objptr;
        (*p).ustr.mutable = (uint64_t)((int64_t)0);
        pc_decls_chrtable[(ch)] = p;
    };
    ++(*p).refcount;
    (*dest).objptr = p;
}

static void pc_objlib_Dinit(void) {
    pc_objlib_zeroobj = (struct pc_decls_objrec *)(mlib_pcm_alloc((int64_t)32));
    (*pc_objlib_zeroobj).refcount = (uint64_t)((int64_t)1);
    pc_objlib_emptylist = pc_objlib_obj_new((int64_t)29);
    (*pc_objlib_emptylist).ulist.lower = (int64_t)1;
    (*pc_objlib_emptylist).objtype = (uint64_t)((int64_t)0);
    pc_objlib_emptystring = pc_objlib_obj_new((int64_t)5);
    (*pc_objlib_emptystring).objtype = (uint64_t)((int64_t)0);
    pc_objlib_emptyset = pc_objlib_obj_new((int64_t)9);
    (*pc_objlib_emptyset).objtype = (uint64_t)((int64_t)0);
}

struct pc_decls_objrec * pc_objlib_obj_new(int64_t tag) {
    struct pc_decls_objrec *  p;
    p = (struct pc_decls_objrec *)(mlib_pcm_alloc32());
    (*p) = (*pc_objlib_zeroobj);
    (*p).tag = (uint64_t)(tag);
    return p;
}

void pc_objlib_freeobject(struct pc_decls_objrec * p) {
    mlib_pcm_free32((void *)(p));
}

struct pc_decls_objrec * pc_objlib_array_new(int64_t ta,int64_t elemtype,int64_t length,int64_t lower) {
    struct pc_decls_objrec *  p;
    byte *  q;
    int64_t elemsize;
    elemsize = pc_decls_ttsize[(elemtype)];
    p = pc_objlib_obj_new(ta);
    (*p).uarray.mutable = (uint64_t)((int64_t)1);
    (*p).uarray.lower = lower;
    (*p).uarray.length = (uint64_t)(length);
    (*p).uarray.objtype = (uint64_t)((int64_t)0);
    (*p).uarray.elemtag = elemtype;
    if (!!(length)) {
        q = ((*p).uarray.ptr = (byte *)(mlib_pcm_allocz((length * elemsize))));
        (*p).uarray.allocated = (uint64_t)((mlib_allocbytes / elemsize));
    };
    return p;
}

struct pc_decls_objrec * pc_objlib_list_new(int64_t length,int64_t lower,struct pc_decls_varrec * defval) {
    struct pc_decls_objrec *  p;
    struct pc_decls_varrec *  q;
    int64_t av_1;
    p = pc_objlib_obj_new((int64_t)29);
    (*p).ulist.mutable = (uint64_t)((int64_t)1);
    (*p).ulist.lower = lower;
    (*p).ulist.length = (uint64_t)(length);
    (*p).ulist.objtype = (uint64_t)((int64_t)0);
    if (!!(length)) {
        q = ((*p).ulist.vptr = (struct pc_decls_varrec *)(mlib_pcm_alloc((length * (int64_t)16))));
        (*p).ulist.allocated = (uint64_t)((mlib_allocbytes / (int64_t)16));
        av_1 = length;
        while (av_1-- > 0) {
L410 :;
            if (!!(defval)) {
                (*q) = (*pc_pcfns_pc_share(defval));
            } else {
                (*q).tagx = (uint64_t)((int64_t)0);
            };
            ++q;
L411 :;
        }L412 :;
        ;
    };
    return p;
}

void pc_objlib_objtovar(struct pc_decls_objrec * p,struct pc_decls_varrec * q) {
    (*q).tagx = (uint64_t)(((int64_t)((uint64_t)((*p).tag)) | (int64_t)65536));
    (*q).objptr = p;
}

struct pc_decls_objrec * pc_objlib_set_new(int64_t length,int64_t lower) {
    struct pc_decls_objrec *  p;
    p = pc_objlib_bits_new((int64_t)41,length,lower);
    (*p).tag = (uint64_t)((int64_t)9);
    return p;
}

struct pc_decls_objrec * pc_objlib_bits_new(int64_t elemtype,int64_t length,int64_t lower) {
    struct pc_decls_objrec *  p;
    int64_t bitwidthx;
    int64_t nbits;
    int64_t nbytes;
    p = pc_objlib_obj_new((int64_t)31);
    (*p).ubits.mutable = (uint64_t)((int64_t)1);
    (*p).ubits.lower = lower;
    (*p).ubits.length = (uint64_t)(length);
    (*p).ubits.objtype = (uint64_t)((int64_t)0);
    (*p).ubits.elemtag = (uint64_t)(elemtype);
    bitwidthx = (int64_t)(pc_decls_ttbitwidth[(elemtype)]);
    nbits = (length * bitwidthx);
    nbytes = ((((nbits - (int64_t)1) / (int64_t)64) + (int64_t)1) * (int64_t)8);
    if (!!(length)) {
        (*p).ubits.ptr = (byte *)(mlib_pcm_alloc(nbytes));
        (*p).ubits.allocated64 = (uint64_t)(((int64_t)((uint64_t)(mlib_allocbytes)) * ((int64_t)8 / bitwidthx)));
        mlib_pcm_clearmem((void *)((*p).ubits.ptr),mlib_allocbytes);
    } else {
        (*p).ubits.ptr = (byte *)(0);
    };
    return p;
}

struct pc_decls_objrec * pc_objlib_struct_new(int64_t t) {
    struct pc_decls_objrec *  p;
    p = pc_objlib_obj_new(t);
    (*p).ustruct.mutable = (uint64_t)((int64_t)1);
    (*p).ustruct.ptr = (byte *)(mlib_pcm_allocz(pc_decls_ttsize[(t)]));
    (*p).ustruct.allocated = (uint64_t)(mlib_allocbytes);
    return p;
}

struct pc_decls_objrec * pc_objlib_dict_new(int64_t n) {
    struct pc_decls_objrec *  p;
    int64_t m;
    m = msysnewc_m_imax((int64_t)16,pc_support_nextpoweroftwo((n * (int64_t)2)));
    p = pc_objlib_list_new(m,(int64_t)1,(struct pc_decls_varrec *)(0));
    (*p).tag = (uint64_t)((int64_t)10);
    (*p).udict.dictitems = (uint64_t)((int64_t)0);
    return p;
}

struct pc_decls_objrec * pc_objlib_record_new(int64_t rectype) {
    struct pc_decls_objrec *  p;
    p = pc_objlib_obj_new(rectype);
    (*p).urec.mutable = (uint64_t)((int64_t)1);
    (*p).urec.vptr = (struct pc_decls_varrec *)(mlib_pcm_allocz(((int64_t)((uint64_t)(pc_decls_ttlength[(rectype)])) * (int64_t)16)));
    return p;
}

void pc_objlib_list_free(struct pc_decls_objrec * p) {
    if (!!((uint64_t)((*p).ulist.length))) {
        mlib_pcm_free((void *)((*p).ulist.vptr),((int64_t)((uint64_t)((*p).ulist.allocated)) * (int64_t)16));
    };
}

void pc_objlib_record_free(struct pc_decls_objrec * p) {
    mlib_pcm_free((void *)((*p).urec.vptr),((int64_t)((uint64_t)(pc_decls_ttlength[((int64_t)((*p).tag))])) * (int64_t)16));
}

void pc_objlib_array_free(struct pc_decls_objrec * p) {
    if (!!((uint64_t)((*p).ulist.length))) {
        mlib_pcm_free((void *)((*p).uarray.ptr),((int64_t)((uint64_t)((*p).uarray.allocated)) * pc_decls_ttsize[((int64_t)((*p).uarray.elemtag))]));
    };
}

void pc_objlib_bits_free(struct pc_decls_objrec * p) {
    if (!!((uint64_t)((*p).ulist.length))) {
        mlib_pcm_free((void *)((*p).ubits.ptr),pc_objlib_bits_bytesize(p));
    };
}

void pc_objlib_dict_free(struct pc_decls_objrec * p) {
    if (!!((uint64_t)((*p).udict.length))) {
        mlib_pcm_free((void *)((*p).udict.vptr),((int64_t)((uint64_t)((*p).udict.allocated)) * (int64_t)16));
    };
}

int64_t pc_objlib_bits_bytesize(struct pc_decls_objrec * p) {
    int64_t elemtype;
    int64_t nbits;
    elemtype = (int64_t)((*p).ubits.elemtag);
    if ((elemtype==(int64_t)41) || (elemtype==(int64_t)42) || (elemtype==(int64_t)43)) {
        nbits = ((int64_t)(pc_decls_ttbitwidth[(elemtype)]) * (int64_t)((uint64_t)((*p).ubits.length)));
        if (!!((nbits & (int64_t)7))) {
            return ((nbits / (int64_t)8) + (int64_t)1);
        } else {
            return (nbits / (int64_t)8);
        };
    };
    return (pc_decls_ttsize[(elemtype)] * (int64_t)((uint64_t)((*p).uarray.length)));
}

void pc_objlib_list_resize(struct pc_decls_objrec * p,int64_t n) {
    struct pc_decls_varrec *  q;
    if ((n <= (int64_t)((uint64_t)((*p).ulist.allocated)))) {
        (*p).ulist.length = (uint64_t)(n);
    } else {
        q = (struct pc_decls_varrec *)(mlib_pcm_alloc((n * (int64_t)16)));
        if (!!((uint64_t)((*p).ulist.length))) {
            memcpy((void *)(q),(void *)((*p).ulist.vptr),(uint64_t)(((int64_t)((uint64_t)((*p).ulist.length)) * (int64_t)16)));
            mlib_pcm_free((void *)((*p).ulist.vptr),((int64_t)((uint64_t)((*p).ulist.allocated)) * (int64_t)16));
        };
        (*p).ulist.vptr = q;
        (*p).ulist.length = (uint64_t)(n);
        (*p).ulist.allocated = (uint64_t)((mlib_allocbytes / (int64_t)16));
    };
}

void pc_objlib_array_resize(struct pc_decls_objrec * p,int64_t n) {
    byte *  q;
    int64_t elemsize;
    elemsize = pc_decls_ttsize[((int64_t)((*p).uarray.elemtag))];
    if ((n <= (int64_t)((uint64_t)((*p).uarray.allocated)))) {
        (*p).uarray.length = (uint64_t)(n);
    } else {
        q = (byte *)(mlib_pcm_alloc((n * elemsize)));
        if (!!((uint64_t)((*p).uarray.length))) {
            memcpy((void *)(q),(void *)((*p).uarray.ptr),(uint64_t)(((int64_t)((uint64_t)((*p).uarray.length)) * elemsize)));
            mlib_pcm_free((void *)((*p).uarray.ptr),((int64_t)((uint64_t)((*p).uarray.allocated)) * elemsize));
        };
        (*p).uarray.ptr = q;
        (*p).uarray.length = (uint64_t)(n);
        (*p).uarray.allocated = (uint64_t)((mlib_allocbytes / elemsize));
    };
}

void pc_objlib_bits_resize(struct pc_decls_objrec * p,int64_t n) {
    struct pc_decls_objrec *  pnew;
    int64_t oldrefcount;
    if (((uint64_t)(n) <= (*p).ubits.allocated64)) {
        (*p).ubits.length = (uint64_t)(n);
        return;
    };
    pnew = pc_objlib_bits_new((int64_t)((*p).ubits.elemtag),(int64_t)((*p).ubits.length),(int64_t)((*p).ubits.lower));
    memcpy((void *)((*pnew).ubits.ptr),(void *)((*p).ubits.ptr),(uint64_t)(pc_objlib_bits_bytesize(p)));
    oldrefcount = (int64_t)((*p).ubits.refcount);
    pc_objlib_bits_free(p);
    (*p) = (*pnew);
    (*p).refcount = (uint64_t)(oldrefcount);
}

void pc_objlib_string_resize(struct pc_decls_objrec * p,int64_t n) {
    uint8_t *  q;
    if ((n <= (int64_t)((uint64_t)((*p).ustr.allocated)))) {
        (*p).ustr.length = n;
    } else {
        q = (uint8_t *)(mlib_pcm_alloc(n));
        if (!!((int64_t)((*p).ustr.length))) {
            memcpy((void *)(q),(void *)((*p).ustr.strptr),(uint64_t)((*p).ustr.length));
            mlib_pcm_free((void *)((*p).ustr.strptr),(int64_t)((*p).ustr.allocated));
        };
        (*p).ustr.strptr = q;
        (*p).ustr.length = n;
        (*p).ustr.allocated = (uint64_t)(mlib_allocbytes);
    };
}

struct pc_decls_objrec * pc_objlib_copyonwrite(struct pc_decls_objrec * p,int64_t tag) {
    struct pc_decls_objrec *  q;
    struct pc_decls_varrec v;
    if (!!((uint64_t)((*p).ulist.mutable))) {
        return p;
    };
    v.tagx = (uint64_t)((tag + (int64_t)65536));
    v.objptr = p;
    pc_pcfns_pc_dupl(&v);
    q = v.objptr;
    (*q).ulist.mutable = (uint64_t)((int64_t)1);
    return q;
}

struct pc_decls_objrec * pc_objlib_make_strslicexobj(uint8_t * s,int64_t length) {
    struct pc_decls_objrec *  p;
    if ((length == (int64_t)0)) {
        s = (uint8_t *)(0);
    };
    p = pc_objlib_obj_new((int64_t)5);
    (*p).ustr.strptr = s;
    (*p).ustr.mutable = (uint64_t)((int64_t)1);
    (*p).ustr.length = length;
    (*p).objtype = (uint64_t)((int64_t)2);
    return p;
}

struct pc_decls_objrec * pc_objlib_bignum_make(void * bn) {
    struct pc_decls_objrec *  p;
    p = pc_objlib_obj_new((int64_t)7);
    (*p).udec.bnptr = bn;
    return p;
}

void pc_bignum_bx_makestr(uint8_t * s,int64_t length,struct pc_decls_varrec * p) {
    pc_bignum_makebnvar(p,mbignum_bn_makestr(s,length));
}

uint8_t * pc_bignum_bx_tostring(struct pc_decls_varrec * a,int64_t fmt) {
    return mbignum_bn_tostring((struct mbignum_bignumrec *)((*(*a).objptr).udec.bnptr),fmt);
}

void pc_bignum_bx_dupl(struct pc_decls_varrec * p) {
    struct mbignum_bignumrec *  a;
    a = mbignum_bn_init();
    mbignum_bn_dupl(a,(struct mbignum_bignumrec *)((*(*p).objptr).udec.bnptr));
    pc_bignum_makebnvar(p,a);
}

void pc_bignum_bx_negto(struct pc_decls_varrec * p) {
    mbignum_bn_negto((struct mbignum_bignumrec *)((*(*p).objptr).udec.bnptr));
}

void pc_bignum_bx_absto(struct pc_decls_varrec * p) {
    mbignum_bn_absto((struct mbignum_bignumrec *)((*(*p).objptr).udec.bnptr));
}

static struct mbignum_bignumrec * pc_bignum_makebnvar(struct pc_decls_varrec * dest,struct mbignum_bignumrec * bn) {
    (*dest).tagx = (uint64_t)((int64_t)65543);
    if ((bn == 0)) {
        bn = mbignum_bn_init();
    };
    (*dest).objptr = pc_objlib_bignum_make((void *)(bn));
    return bn;
}

void pc_bignum_bx_free(struct pc_decls_varrec * a) {
    mbignum_bn_free((struct mbignum_bignumrec *)((*(*a).objptr).udec.bnptr));
    pc_objlib_freeobject((*a).objptr);
}

void pc_bignum_bx_makeint(int64_t aa,struct pc_decls_varrec * dest) {
    pc_bignum_makebnvar(dest,mbignum_bn_makeint(aa));
}

void pc_bignum_bx_add(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c) {
    struct pc_decls_varrec v;
    mbignum_bn_add(pc_bignum_makebnvar(&v,(struct mbignum_bignumrec *)(0)),(struct mbignum_bignumrec *)((*(*a).objptr).udec.bnptr),(struct mbignum_bignumrec *)((*(*b).objptr).udec.bnptr));
    (*c) = v;
}

void pc_bignum_bx_sub(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c) {
    struct pc_decls_varrec v;
    mbignum_bn_sub(pc_bignum_makebnvar(&v,(struct mbignum_bignumrec *)(0)),(struct mbignum_bignumrec *)((*(*a).objptr).udec.bnptr),(struct mbignum_bignumrec *)((*(*b).objptr).udec.bnptr));
    (*c) = v;
}

void pc_bignum_bx_mul(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c) {
    struct pc_decls_varrec v;
    mbignum_bn_mul(pc_bignum_makebnvar(&v,(struct mbignum_bignumrec *)(0)),(struct mbignum_bignumrec *)((*(*a).objptr).udec.bnptr),(struct mbignum_bignumrec *)((*(*b).objptr).udec.bnptr));
    (*c) = v;
}

void pc_bignum_bx_div(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c) {
    struct pc_decls_varrec v;
    mbignum_bn_div(pc_bignum_makebnvar(&v,(struct mbignum_bignumrec *)(0)),(struct mbignum_bignumrec *)((*(*a).objptr).udec.bnptr),(struct mbignum_bignumrec *)((*(*b).objptr).udec.bnptr),(int64_t)1000);
    (*c) = v;
}

void pc_bignum_bx_idiv(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c) {
    struct pc_decls_varrec v;
    mbignum_bn_idiv(pc_bignum_makebnvar(&v,(struct mbignum_bignumrec *)(0)),(struct mbignum_bignumrec *)((*(*a).objptr).udec.bnptr),(struct mbignum_bignumrec *)((*(*b).objptr).udec.bnptr));
    (*c) = v;
}

void pc_bignum_bx_irem(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c) {
    struct pc_decls_varrec v;
    mbignum_bn_irem(pc_bignum_makebnvar(&v,(struct mbignum_bignumrec *)(0)),(struct mbignum_bignumrec *)((*(*a).objptr).udec.bnptr),(struct mbignum_bignumrec *)((*(*b).objptr).udec.bnptr));
    (*c) = v;
}

int64_t pc_bignum_bx_equal(struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    return mbignum_bn_equal((struct mbignum_bignumrec *)((*(*a).objptr).udec.bnptr),(struct mbignum_bignumrec *)((*(*b).objptr).udec.bnptr));
}

int64_t pc_bignum_bx_cmp(struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    return mbignum_bn_cmp((struct mbignum_bignumrec *)((*(*a).objptr).udec.bnptr),(struct mbignum_bignumrec *)((*(*b).objptr).udec.bnptr));
}

int64_t pc_bignum_bx_int(struct pc_decls_varrec * p) {
    struct mbignum_bignumrec *  a;
    struct mbignum_bignumrec *  b;
    int64_t x;
    a = (struct mbignum_bignumrec *)((*(*p).objptr).udec.bnptr);
    if (!!(mbignum_bn_isint(a))) {
        return mbignum_bn_toint(a);
    };
    b = mbignum_bn_init();
    mbignum_bn_fix(b,a);
    x = mbignum_bn_toint(b);
    mbignum_bn_free(b);
    return x;
}

void pc_bignum_bx_power(struct pc_decls_varrec * a,int64_t n,struct pc_decls_varrec * dest) {
    struct pc_decls_varrec e;
    mbignum_bn_ipower(pc_bignum_makebnvar(&e,(struct mbignum_bignumrec *)(0)),(struct mbignum_bignumrec *)((*(*a).objptr).udec.bnptr),n);
    (*dest) = e;
}

void pc_bignum_bx_reduce(struct pc_decls_varrec * bn) {
    pc_support_pcerror((uint8_t*)"BX_REDUCE");
}

int64_t pc_bignum_bx_length(struct pc_decls_varrec * bn) {
    return mbignum_bn_digits((struct mbignum_bignumrec *)((*(*bn).objptr).udec.bnptr));
}

struct mbignum_bignumrec * mbignum_bn_init(void) {
    struct mbignum_bignumrec *  a;
    a = mbignum_makebignum((int64_t)0);
    return a;
}

static int64_t mbignum_readexpon(uint8_t * s) {
    int64_t neg;
    int64_t expon;
    neg = (expon = (int64_t)0);
    if (((int64_t)((*s))==(int64_t)43)) {
        ++s;
    }else if (((int64_t)((*s))==(int64_t)45)) {
        neg = (int64_t)1;
        ++s;
    };
    L413 :;
    switch ((int64_t)((*s))) {
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    {
        expon = ((expon * (int64_t)10) + ((uint64_t)((*s)) - '0'));
        ++s;
    }break;
    case 95:;
    case 39:;
    case 96:;
    case 32:;
    {
        ++s;
    }break;
    case 0:;
    {
        goto L414 ;
    }break;
    default: {
        mbignum_bn_error((uint8_t*)"make expon?");
    }
    } //SW
goto L413 ;
L414 :;
    ;
    return (!!(neg)?-(expon):expon);
}

void mbignum_bn_print(struct mbignum_bignumrec * a,int64_t format) {
    uint8_t *  s;
    s = mbignum_bn_tostring(a,format);
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(s,NULL);
    msysnewc_m_print_end();
    ;
}

void mbignum_bn_println(struct mbignum_bignumrec * a,int64_t format) {
    mbignum_bn_print(a,format);
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static int64_t mbignum_getbintype(struct mbignum_bignumrec * a,struct mbignum_bignumrec * b) {
    int64_t atype;
    int64_t btype;
    atype = (int64_t)((*a).numtype);
    btype = (int64_t)((*b).numtype);
    if (((atype == (int64_t)3) || (btype == (int64_t)3))) {
        return (int64_t)4;
    };
    if ((atype==(int64_t)1)) {
        if ((btype==(int64_t)1)) {
            return (int64_t)1;
        }else if ((btype==(int64_t)0)) {
            return (int64_t)5;
        } else {
            return (int64_t)6;
        };
    }else if ((atype==(int64_t)0)) {
        if ((btype==(int64_t)1)) {
            return (int64_t)7;
        }else if ((btype==(int64_t)0)) {
            return (int64_t)2;
        } else {
            return (int64_t)9;
        };
    } else {
        if ((btype==(int64_t)1)) {
            return (int64_t)8;
        }else if ((btype==(int64_t)0)) {
            return (int64_t)10;
        } else {
            return (int64_t)3;
        };
    };
}

static struct mbignum_bignumrec * mbignum_makebignum(int64_t length) {
    struct mbignum_bignumrec *  a;
    a = (struct mbignum_bignumrec *)(mbignum_bn_alloc((int64_t)32));
    if (!!(length)) {
        (*a).num = (int32_t (*)[])(mbignum_bn_alloc((length * (int64_t)4)));
        (*a).numtype = (int64_t)1;
    } else {
        (*a).num = (int32_t (*)[])(0);
        (*a).numtype = (int64_t)0;
    };
    (*a).length = length;
    (*a).expon = (int64_t)0;
    (*a).neg = (int64_t)0;
    return a;
}

static int32_t * mbignum_makesmallnum(int64_t length) {
    return (int32_t *)(mbignum_bn_alloc((length * (int64_t)4)));
}

static struct mbignum_bignumrec * mbignum_smalltobig(struct mbignum_bignumrec * c,int32_t * a,int64_t length,int64_t alloc,int64_t offset) {
    int32_t *  p;
    int64_t leadingzeros;
    int64_t trailingzeros;
    int64_t nonzeros;
    int64_t newlength;
    int64_t av_1;
    mbignum_bn_setzero(c);
    p = a;
    leadingzeros = (trailingzeros = (nonzeros = (int64_t)0));
    av_1 = length;
    while (av_1-- > 0) {
L415 :;
        if (!!((int64_t)((*p++)))) {
            nonzeros = (int64_t)1;
            trailingzeros = (int64_t)0;
        } else {
            if (!!(nonzeros)) {
                ++trailingzeros;
            } else {
                ++leadingzeros;
            };
        };
L416 :;
    }L417 :;
    ;
    mbignum_stblz = leadingzeros;
    if (!!(nonzeros)) {
        newlength = ((length - trailingzeros) - leadingzeros);
        if (((newlength == length) && (length == alloc))) {
            (*c).num = (int32_t (*)[])(a);
        } else {
            (*c).num = (int32_t (*)[])(mbignum_makesmallnum(newlength));
            memcpy((void *)((*c).num),(void *)((a + leadingzeros)),(uint64_t)((newlength * (int64_t)4)));
            mbignum_freesmall((a + offset),alloc);
        };
        (*c).length = newlength;
        (*c).numtype = (int64_t)1;
        (*c).expon = ((length - (int64_t)1) - leadingzeros);
    } else if (!!(alloc)) {
        mbignum_freesmall((a + offset),alloc);
    };
    return c;
}

static void mbignum_freesmall(int32_t * p,int64_t length) {
    mbignum_freemem((void *)(p),(length * (int64_t)4));
}

void * mbignum_bn_alloc(int64_t size) {
    void *  p;
    p = mlib_pcm_alloc(size);
    if ((p == 0)) {
        mlib_abortprogram((uint8_t*)"bignum:out of memory");
    };
    return p;
}

void * mbignum_checkedmalloc(int64_t size) {
    void *  p;
    p = malloc((uint64_t)(size));
    if ((p == 0)) {
        mlib_abortprogram((uint8_t*)"CM:Out of memory");
    };
    return p;
}

void mbignum_bn_free(struct mbignum_bignumrec * a) {
    if (!!(a)) {
        mbignum_bn_setzero(a);
        mbignum_freemem((void *)(a),(int64_t)32);
    };
}

static void mbignum_freemem(void * p,int64_t size) {
    mlib_pcm_free(p,size);
}

void mbignum_bn_setzero(struct mbignum_bignumrec * a) {
    if (!!(a)) {
        if (!!((*a).num)) {
            mbignum_freesmall((int32_t *)((*a).num),(*a).length);
        };
        (*a).num = (int32_t (*)[])(0);
        (*a).length = (int64_t)0;
        (*a).neg = (int64_t)0;
        (*a).expon = (int64_t)0;
        (*a).numtype = (int64_t)0;
    };
}

void mbignum_bn_move(struct mbignum_bignumrec * a,struct mbignum_bignumrec * b) {
    mbignum_bn_setzero(a);
    (*a) = (*b);
    memset((void *)(b),(int64_t)0,(uint64_t)((int64_t)32));
}

void mbignum_bn_dupl(struct mbignum_bignumrec * a,struct mbignum_bignumrec * b) {
    struct mbignum_bignumrec *  c;
    int64_t size;
    c = mbignum_bn_init();
    (*c) = (*b);
    if (!!((*c).length)) {
        (*c).num = (int32_t (*)[])(mbignum_makesmallnum((size = (*c).length)));
        memcpy((void *)((*c).num),(void *)((*b).num),(uint64_t)((size * (int64_t)4)));
    };
    mbignum_bn_move(a,c);
    mbignum_bn_free(c);
}

void mbignum_bn_setinf(struct mbignum_bignumrec * dest) {
    mbignum_bn_setzero(dest);
    (*dest).numtype = (int64_t)2;
}

void mbignum_bn_setnan(struct mbignum_bignumrec * dest) {
    mbignum_bn_setzero(dest);
    (*dest).numtype = (int64_t)3;
}

static void mbignum_bn_error(uint8_t * mess) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"BN:",NULL);
    msysnewc_m_print_end();
    ;
    mlib_abortprogram(mess);
}

int64_t mbignum_bn_iszero(struct mbignum_bignumrec * a) {
    return ((int64_t)((*a).numtype) == (int64_t)0);
}

void mbignum_bn_negto(struct mbignum_bignumrec * a) {
    if (!(!!(mbignum_bn_iszero(a)))) {
        (*a).neg = !((*a).neg);
    };
}

void mbignum_bn_absto(struct mbignum_bignumrec * a) {
    (*a).neg = (int64_t)0;
}

int64_t mbignum_bn_isint(struct mbignum_bignumrec * a) {
    return ((*a).length <= ((*a).expon + (int64_t)1));
}

int64_t mbignum_bn_getprec(struct mbignum_bignumrec * a) {
    return ((*a).length * (int64_t)9);
}

void mbignum_bn_setprec(struct mbignum_bignumrec * a,int64_t prec) {
    int64_t oldlength;
    int64_t newlength;
    struct mbignum_bignumrec *  c;
    int64_t av_1;
    int64_t i;
    if (((int64_t)((*a).numtype) != (int64_t)1)) {
        return;
    };
    if (((prec < (int64_t)1) || (prec > (int64_t)10000000))) {
        return;
    };
    prec = ((((prec - (int64_t)1) / (int64_t)9) + (int64_t)1) * (int64_t)9);
    newlength = (prec / (int64_t)9);
    oldlength = (*a).length;
    if ((oldlength <= newlength)) {
        return;
    };
    c = mbignum_makebignum(newlength);
    (*c).neg = (int64_t)((*a).neg);
    (*c).expon = (*a).expon;
    L418 :;
    for (i=(int64_t)0;i<=(newlength - (int64_t)1);i+=(int64_t)1) {
L419 :;
        if ((i < oldlength)) {
            (*(*c).num)[(i)] = (int64_t)((*(*a).num)[(i)]);
        } else {
            (*(*c).num)[(i)] = (int64_t)0;
        };
L420 :;
    }L421 :;
    ;
    mbignum_bn_move(a,c);
    mbignum_bn_free(c);
}

int64_t mbignum_bn_getglobalprec(void) {
    return (mbignum_currprec * (int64_t)9);
}

void mbignum_bn_setglobalprec(int64_t prec) {
    mbignum_currprec = (((prec - (int64_t)1) / (int64_t)9) + (int64_t)1);
}

struct mbignum_bignumrec * mbignum_bn_makeint(int64_t x) {
    struct mbignum_bignumrec *  a;
    uint8_t str[256];
    if ((x == (int64_t)0)) {
        a = mbignum_makebignum((int64_t)0);
    } else if ((x>=(int64_t)0 && x<=(int64_t)999999999)) {
        a = mbignum_makebignum((int64_t)1);
        (*(*a).num)[((int64_t)0)] = x;
    } else if ((-(x)>=(int64_t)0 && -(x)<=(int64_t)999999999)) {
        a = mbignum_makebignum((int64_t)1);
        (*(*a).num)[((int64_t)0)] = -(x);
        (*a).neg = (int64_t)1;
    } else {
        sprintf((int8_t *)(str),(int8_t *)((uint8_t*)"%lld"),x);
        a = mbignum_bn_makestr(str,(int64_t)0);
    };
    return a;
}

struct mbignum_bignumrec * mbignum_bn_makefloat(double x) {
    uint8_t str[2048];
    sprintf((int8_t *)(str),(int8_t *)((uint8_t*)"%.30g"),x);
    return mbignum_bn_makestr(str,(int64_t)0);
}

void mbignum_bn_ipower(struct mbignum_bignumrec * d,struct mbignum_bignumrec * a,int64_t n) {
    struct mbignum_bignumrec *  e;
    struct mbignum_bignumrec *  f;
    if ((n < (int64_t)0)) {
        mbignum_bn_setzero(d);
    } else if ((n == (int64_t)0)) {
        mbignum_bn_move(d,mbignum_bn_makeint((int64_t)1));
    } else if ((n == (int64_t)1)) {
        mbignum_bn_dupl(d,a);
    } else if (((n & (int64_t)1) == (int64_t)0)) {
        e = mbignum_bn_init();
        mbignum_bn_mulu(e,a,a);
        mbignum_bn_ipower(d,e,(n / (int64_t)2));
        mbignum_bn_free(e);
    } else {
        e = mbignum_bn_init();
        f = mbignum_bn_init();
        mbignum_bn_mulu(e,a,a);
        mbignum_bn_ipower(f,e,((n - (int64_t)1) / (int64_t)2));
        mbignum_bn_mulu(d,a,f);
        mbignum_bn_free(e);
        mbignum_bn_free(f);
    };
}

static int64_t mbignum_smallsubto(int32_t * p,int32_t * q,int64_t plen,int64_t qlen) {
    int32_t *  pp;
    int32_t *  qq;
    int64_t carry;
    int64_t diff;
    int64_t z;
    int64_t av_1;
    int64_t av_2;
    pp = ((p + plen) - (int64_t)1);
    qq = ((q + qlen) - (int64_t)1);
    carry = (int64_t)0;
    z = (int64_t)0;
    av_1 = plen;
    while (av_1-- > 0) {
L422 :;
        if ((qq >= q)) {
            diff = (((int64_t)((*pp)) - (int64_t)((*qq))) - carry);
            --qq;
        } else {
            diff = ((int64_t)((*pp)) - carry);
        };
        if ((diff < (int64_t)0)) {
            carry = (int64_t)1;
            (*pp) = (diff + (int64_t)1000000000);
        } else {
            (*pp) = diff;
            carry = (int64_t)0;
        };
        if (!!((int64_t)((*pp)))) {
            z = (int64_t)0;
        } else {
            ++z;
        };
        --pp;
L423 :;
    }L424 :;
    ;
    if (!!(carry)) {
        mbignum_bn_error((uint8_t*)"SSUBTO/CARRY?");
    };
    if ((z == plen)) {
        --z;
    };
    if (!!(z)) {
        plen -= z;
        pp = p;
        qq = (p + z);
        av_2 = plen;
        while (av_2-- > 0) {
L425 :;
            (*pp++) = (int64_t)((*qq++));
L426 :;
        }L427 :;
        ;
    };
    return plen;
}

static int64_t mbignum_smallmulto(int32_t * p,int32_t * q,int64_t plen,int64_t m) {
    int32_t *  pp;
    int32_t *  qq;
    int64_t carry;
    int64_t d;
    int64_t av_1;
    int64_t av_2;
    if ((m==(int64_t)0)) {
        (*p) = (int64_t)0;
        return (int64_t)1;
    }else if ((m==(int64_t)1)) {
        memcpy((void *)(p),(void *)(q),(uint64_t)((plen * (int64_t)4)));
        return plen;
    };
    pp = ((p + plen) - (int64_t)1);
    qq = ((q + plen) - (int64_t)1);
    carry = (int64_t)0;
    av_1 = plen;
    while (av_1-- > 0) {
L428 :;
        d = (((int64_t)((*qq)) * m) + carry);
        (*pp) = (d % (int64_t)1000000000);
        carry = (d / (int64_t)1000000000);
        --qq;
        --pp;
L429 :;
    }L430 :;
    ;
    if (!!(carry)) {
        pp = (p + plen);
        av_2 = plen;
        while (av_2-- > 0) {
L431 :;
            (*pp) = (int64_t)((*(pp - (int64_t)1)));
            --pp;
L432 :;
        }L433 :;
        ;
        (*pp) = carry;
        ++plen;
    };
    return plen;
}

int64_t mbignum_bn_equal(struct mbignum_bignumrec * a,struct mbignum_bignumrec * b) {
    if ((((((*a).length != (*b).length) || ((int64_t)((*a).numtype) != (int64_t)((*b).numtype))) || ((int64_t)((*a).neg) != (int64_t)((*b).neg))) || ((*a).expon != (*b).expon))) {
        return (int64_t)0;
    };
    if (((*a).length == (int64_t)0)) {
        return (int64_t)1;
    };
    return mlib_eqbytes((void *)((*a).num),(void *)((*b).num),((*a).length * (int64_t)4));
}

void mbignum_bn_addu(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b) {
    int64_t preca;
    int64_t precb;
    int64_t precc;
    int64_t uppera;
    int64_t upperb;
    int64_t upperc;
    int64_t offset;
    int64_t carry;
    int64_t expona;
    int64_t exponb;
    int64_t dc;
    uint64_t j;
    int32_t (*pa)[];
    int32_t (*pb)[];
    int32_t *  c;
    int32_t *  c2;
    int64_t i;
    if (((*a).expon < (*b).expon)) {
        {struct mbignum_bignumrec *  temp = a; a = b; b = temp; };
    };
    expona = (*a).expon;
    exponb = (*b).expon;
    preca = (*a).length;
    precb = (*b).length;
    offset = (expona - exponb);
    uppera = (preca - (int64_t)1);
    upperb = (precb - (int64_t)1);
    if ((uppera > (upperb + offset))) {
        upperc = uppera;
    } else {
        upperc = (upperb + offset);
    };
    precc = (upperc + (int64_t)1);
    c = mbignum_makesmallnum(precc);
    carry = (int64_t)0;
    pa = (*a).num;
    pb = (*b).num;
    L434 :;
    for (i=upperc;i>=(int64_t)0;i-=(int64_t)1) {
L435 :;
        j = (uint64_t)((i - offset));
        if (((i <= uppera) && (j <= (uint64_t)(upperb)))) {
            dc = (((int64_t)((*pa)[(i)]) + (int64_t)((*pb)[((int64_t)(j))])) + carry);
        } else if ((i <= uppera)) {
            dc = ((int64_t)((*pa)[(i)]) + carry);
        } else if ((j <= (uint64_t)(upperb))) {
            dc = ((int64_t)((*pb)[((int64_t)(j))]) + carry);
        } else {
            dc = carry;
        };
        if ((dc >= (int64_t)1000000000)) {
            carry = (int64_t)1;
            (*(c + i)) = (dc - (int64_t)1000000000);
        } else {
            (*(c + i)) = dc;
            carry = (int64_t)0;
        };
L436 :;
    }L437 :;
    ;
    if (!!(carry)) {
        c2 = mbignum_makesmallnum((precc + (int64_t)1));
        (*c2) = carry;
        memcpy((void *)((c2 + (int64_t)1)),(void *)(c),(uint64_t)((precc * (int64_t)4)));
        mbignum_freesmall(c,precc);
        c = c2;
        ++precc;
    };
    mbignum_smalltobig(dest,c,precc,precc,(int64_t)0);
    (*dest).expon = (expona + carry);
}

static void mbignum_bn_subu(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b) {
    int64_t preca;
    int64_t precb;
    int64_t precc;
    int64_t uppera;
    int64_t upperb;
    int64_t upperc;
    int64_t offset;
    int64_t carry;
    int64_t expona;
    int64_t isneg;
    int64_t diff;
    uint64_t j;
    int32_t (*pa)[];
    int32_t (*pb)[];
    int32_t *  c;
    int64_t i;
    isneg = (int64_t)0;
    if (((*a).expon < (*b).expon)) {
        {struct mbignum_bignumrec *  temp = a; a = b; b = temp; };
        isneg = (int64_t)1;
    };
    //retry:
L438 :;
;
    expona = (*a).expon;
    preca = (*a).length;
    precb = (*b).length;
    offset = (expona - (*b).expon);
    uppera = (preca - (int64_t)1);
    upperb = (precb - (int64_t)1);
    if ((uppera > (upperb + offset))) {
        upperc = uppera;
    } else {
        upperc = (upperb + offset);
    };
    precc = (upperc + (int64_t)1);
    c = mbignum_makesmallnum(precc);
    carry = (int64_t)0;
    pa = (*a).num;
    pb = (*b).num;
    L439 :;
    for (i=upperc;i>=(int64_t)0;i-=(int64_t)1) {
L440 :;
        j = (uint64_t)((i - offset));
        if (((i <= uppera) && (j <= (uint64_t)(upperb)))) {
            diff = (((int64_t)((*pa)[(i)]) - (int64_t)((*pb)[((int64_t)(j))])) - carry);
        } else if ((i <= uppera)) {
            diff = ((int64_t)((*pa)[(i)]) - carry);
        } else if ((j <= (uint64_t)(upperb))) {
            diff = (-((int64_t)((*pb)[((int64_t)(j))])) - carry);
        } else {
            diff = -(carry);
        };
        if ((diff < (int64_t)0)) {
            carry = (int64_t)1;
            (*(c + i)) = (diff + (int64_t)1000000000);
        } else {
            (*(c + i)) = diff;
            carry = (int64_t)0;
        };
L441 :;
    }L442 :;
    ;
    if (!!(carry)) {
        if (!!(isneg)) {
            mbignum_bn_error((uint8_t*)"SUBU/CARRY");
        };
        {struct mbignum_bignumrec *  temp = a; a = b; b = temp; };
        isneg = (int64_t)1;
        mbignum_freesmall(c,precc);
        goto L438 ;
;
    };
    mbignum_smalltobig(dest,c,precc,precc,(int64_t)0);
    (*dest).neg = isneg;
    (*dest).expon = (expona - mbignum_stblz);
    if (!!(mbignum_bn_iszero(dest))) {
        (*dest).expon = (int64_t)0;
    };
}

static void mbignum_bn_mulu(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b) {
    int64_t uppera;
    int64_t upperb;
    int64_t precc;
    int64_t expona;
    int64_t exponb;
    int64_t ax;
    int64_t bx;
    int64_t cx;
    int64_t cx1;
    int64_t nc2;
    int64_t p;
    int64_t carry;
    int64_t x;
    int32_t *  c;
    int64_t pdquot;
    expona = (*a).expon;
    exponb = (*b).expon;
    uppera = ((*a).length - (int64_t)1);
    upperb = ((*b).length - (int64_t)1);
    precc = ((uppera + upperb) + (int64_t)2);
    nc2 = precc;
    c = mbignum_makesmallnum(nc2);
    memset((void *)(c),(int64_t)0,(uint64_t)((precc * (int64_t)4)));
    cx = (precc - (int64_t)1);
    L443 :;
    for (bx=upperb;bx>=(int64_t)0;bx-=(int64_t)1) {
L444 :;
        carry = (int64_t)0;
        cx1 = cx;
        L447 :;
        for (ax=uppera;ax>=(int64_t)0;ax-=(int64_t)1) {
L448 :;
            p = (((int64_t)((*(*a).num)[(ax)]) * (int64_t)((*(*b).num)[(bx)])) + carry);
            pdquot = (p / (int64_t)1000000000);
            x = ((int64_t)((*(c + cx1))) + (p % (int64_t)1000000000));
            if ((x > (int64_t)999999999)) {
                carry = (pdquot + (x / (int64_t)1000000000));
                (*(c + cx1--)) = (x % (int64_t)1000000000);
            } else {
                carry = pdquot;
                (*(c + cx1--)) = x;
            };
L449 :;
        }L450 :;
        ;
        (*(c + cx1)) = carry;
        --cx;
L445 :;
    }L446 :;
    ;
    mbignum_smalltobig(dest,c,precc,nc2,(int64_t)0);
    (*dest).expon = (((expona + exponb) + (int64_t)1) - mbignum_stblz);
}

static int32_t mbignum_smalldiv(int32_t * x,int32_t * b,int64_t * xlen,int64_t nb) {
    int64_t k;
    int64_t count;
    int64_t xx;
    int64_t y;
    int32_t xi;
    int32_t bi;
    int32_t *  e;
    int64_t esize;
    int64_t ne;
    int64_t nx;
    int64_t av_1;
    int64_t i;
    nx = (*xlen);
    k = (int64_t)0;
    count = (int64_t)0;
    e = mbignum_makesmallnum((esize = (nb + (int64_t)1)));
    L451 :;
    while (1) {
        if ((nx < nb)) {
            goto L452 ;
        } else if ((nx > nb)) {
            xx = (((int64_t)((*x)) * (int64_t)1000000000) + (int64_t)((*(x + (int64_t)1))));
            y = (xx / ((int64_t)((*b)) + (int64_t)1));
        } else {
            if (((int64_t)((*x)) >= ((int64_t)((*b)) + (int64_t)1))) {
                y = ((int64_t)((*x)) / ((int64_t)((*b)) + (int64_t)1));
            } else {
                y = (int64_t)1;
                L453 :;
                for (i=(int64_t)0;i<=(nb - (int64_t)1);i+=(int64_t)1) {
L454 :;
                    xi = (int64_t)((*(x + i)));
                    bi = (int64_t)((*(b + i)));
                    if (((int64_t)(xi) < (int64_t)(bi))) {
                        y = (int64_t)0;
                        goto L452 ;
                    } else if (((int64_t)(xi) > (int64_t)(bi))) {
                        goto L456 ;
                    };
L455 :;
                }L456 :;
                ;
            };
        };
        k += y;
        if ((y > (int64_t)1)) {
            ne = mbignum_smallmulto(e,b,nb,y);
            nx = mbignum_smallsubto(x,e,nx,ne);
        } else if (!!(y)) {
            nx = mbignum_smallsubto(x,b,nx,nb);
        } else {
            mbignum_bn_error((uint8_t*)"smalldiv:Y=0");
        };
    }L452 :;
    ;
    mbignum_freesmall(e,esize);
    (*xlen) = nx;
    return (int32_t)(k);
}

void mbignum_bn_idivu(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b,struct mbignum_bignumrec * rm) {
    int32_t *  c;
    int32_t *  x;
    int64_t expona;
    int64_t exponb;
    int64_t badjust;
    int64_t na;
    int64_t nb;
    int64_t nc;
    int64_t nx;
    int64_t nx2;
    int64_t cx;
    int64_t nupper;
    int64_t uppera;
    int64_t upperb;
    int64_t upperc;
    int64_t n;
    int64_t k;
    int64_t nexta;
    int32_t *  pa;
    int32_t *  pb;
    struct mbignum_bignumrec *  d;
    int64_t i;
    na = (*a).length;
    nb = (*b).length;
    expona = (*a).expon;
    exponb = (*b).expon;
    badjust = ((exponb + (int64_t)1) - nb);
    if (((na > (expona + (int64_t)1)) || (nb > (exponb + (int64_t)1)))) {
        mbignum_bn_error((uint8_t*)"idivu:a or b not int");
    };
    nc = (expona + (int64_t)1);
    if ((expona < exponb)) {
        mbignum_bn_setzero(dest);
        if (!!(rm)) {
            mbignum_bn_dupl(rm,a);
        };
        return;
    };
    uppera = (na - (int64_t)1);
    upperb = (nb - (int64_t)1);
    upperc = (nc - (int64_t)1);
    pa = (int32_t *)((*a).num);
    pb = (int32_t *)((*b).num);
    n = nb;
    x = mbignum_makesmallnum((nx2 = (n + (int64_t)1)));
    nx = n;
    nupper = (nc - badjust);
    L457 :;
    for (i=(int64_t)0;i<=upperb;i+=(int64_t)1) {
L458 :;
        if ((i <= uppera)) {
            (*(x + i)) = (int64_t)((*(pa + i)));
        } else {
            (*(x + i)) = (int64_t)0;
        };
L459 :;
    }L460 :;
    ;
    c = mbignum_makesmallnum(nc);
    cx = (int64_t)0;
    L461 :;
    while (1) {
        k = (int64_t)(mbignum_smalldiv(x,pb,&nx,nb));
        (*(c + cx++)) = k;
        if ((n >= nupper)) {
            goto L462 ;
        };
        nexta = ((n > uppera)?(int64_t)0:(int64_t)((*(pa + n))));
        ++n;
        if (((nx == (int64_t)1) && ((int64_t)((*x)) == (int64_t)0))) {
            (*x) = nexta;
        } else {
            (*(x + nx)) = nexta;
            ++nx;
        };
    }L462 :;
    ;
    if ((!!(rm) && (exponb < nb))) {
        mbignum_smalltobig(rm,x,nx,nx2,(int64_t)0);
    } else {
        mbignum_freesmall(x,nx2);
    };
    if (((cx == (int64_t)1) && ((int64_t)((*c)) == (int64_t)0))) {
        mbignum_freesmall(c,nc);
        mbignum_bn_setzero(dest);
        if (!!(rm)) {
            mbignum_bn_dupl(rm,a);
        };
        return;
    };
    if ((((int64_t)((*c)) == (int64_t)0) && (cx >= (int64_t)2))) {
        mbignum_smalltobig(dest,(c + (int64_t)1),(cx - (int64_t)1),nc,(int64_t)-1);
    } else {
        mbignum_smalltobig(dest,c,cx,nc,(int64_t)0);
    };
    if ((!!(rm) && (exponb >= nb))) {
        d = mbignum_bn_init();
        mbignum_bn_mulu(d,b,dest);
        mbignum_bn_subu(rm,a,d);
        mbignum_bn_free(d);
    };
}

static int64_t mbignum_strvaln(uint8_t * s,int64_t n) {
    int64_t a;
    int64_t av_1;
    a = (int64_t)0;
    av_1 = n;
    while (av_1-- > 0) {
L463 :;
        if (((uint64_t)((*s)) != '_')) {
            a = (((a * (int64_t)10) + (int64_t)((*s))) - (int64_t)48);
        };
        ++s;
L464 :;
    }L465 :;
    ;
    return a;
}

struct mbignum_bignumrec * mbignum_bn_makestr(uint8_t * s,int64_t length) {
    uint8_t *  t;
    uint8_t *  u;
    int64_t neg;
    int64_t dpindex;
    int64_t expon;
    int64_t nonzeros;
    int64_t talloc;
    int64_t dpseen;
    int64_t leadingzeros;
    int64_t trailingzeros;
    int64_t zerosafterdp;
    int64_t d;
    int64_t n;
    int64_t wd;
    int64_t dp;
    int64_t wdp;
    int64_t w;
    int64_t d2;
    int64_t na;
    int64_t nb;
    struct mbignum_bignumrec *  a;
    int64_t av_1;
    int64_t av_2;
    int64_t i;
    if ((length == (int64_t)0)) {
        length = (int64_t)(strlen((int8_t *)(s)));
    };
    if ((length <= (int64_t)0)) {
        return mbignum_badnumber();
    };
    talloc = ((length + (int64_t)1) + (int64_t)10);
    neg = (int64_t)0;
    if (((int64_t)((*s))==(int64_t)43)) {
        ++s;
    }else if (((int64_t)((*s))==(int64_t)45)) {
        neg = (int64_t)1;
        ++s;
    };
    t = (u = (uint8_t *)(mbignum_bn_alloc(talloc)));
    dpindex = (int64_t)-1;
    dpseen = (zerosafterdp = (int64_t)0);
    nonzeros = (int64_t)0;
    leadingzeros = (trailingzeros = (int64_t)0);
    expon = (int64_t)0;
    L466 :;
    switch ((int64_t)((*s))) {
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    {
        (*u++) = (uint64_t)((*s++));
        trailingzeros = (int64_t)0;
        nonzeros = (int64_t)1;
    }break;
    case 48:;
    {
        if (!!(nonzeros)) {
            ++trailingzeros;
            (*u++) = (uint64_t)((*s++));
        } else {
            ++leadingzeros;
            if (!!(dpseen)) {
                ++zerosafterdp;
            };
            ++s;
        };
    }break;
    case 95:;
    case 39:;
    case 96:;
    case 32:;
    case 13:;
    case 10:;
    {
        ++s;
    }break;
    case 46:;
    {
        if ((!!(dpseen) || (dpindex >= (int64_t)0))) {
            return mbignum_badnumber();
        };
        if (!!(nonzeros)) {
            dpindex = (u - t);
        } else {
            dpseen = (int64_t)1;
        };
        ++s;
    }break;
    case 0:;
    {
        goto L467 ;
    }break;
    case 101:;
    case 69:;
    {
        expon = mbignum_readexpon((s + (int64_t)1));
        goto L467 ;
    }break;
    default: {
        return mbignum_badnumber();
    }
    } //SW
goto L466 ;
L467 :;
    ;
    (*u) = (uint64_t)0u;
    length = (u - t);
    if ((dpindex < (int64_t)0)) {
        if (!!(dpseen)) {
            dpindex = -(zerosafterdp);
        } else {
            dpindex = length;
        };
    };
    length -= trailingzeros;
    (*(t + length)) = (uint64_t)0u;
    if ((length == (int64_t)0)) {
        return mbignum_bn_makeint((int64_t)0);
    };
    d = ((dpindex - (int64_t)1) + expon);
    n = length;
    dp = (int64_t)0;
    na = (int64_t)1;
    nb = (n - na);
    w = (int64_t)9;
    if ((d >= (int64_t)0)) {
        wd = (d / w);
        wdp = (d % w);
    } else {
        d2 = labs((d + (int64_t)1));
        wd = -(((d2 / w) + (int64_t)1));
        wdp = ((w - (int64_t)1) - (d2 % w));
    };
    na = (wdp + (int64_t)1);
    nb = msysnewc_m_imax((n - na),(int64_t)0);
    L468 :;
    while (!!((nb % w))) {
        ++nb;
L469 :;
    }L470 :;
    ;
    length = ((nb / w) + (int64_t)1);
    u = (t + n);
    av_1 = ((na + nb) - n);
    while (av_1-- > 0) {
L471 :;
        (*u++) = '0';
L472 :;
    }L473 :;
    ;
    n = (na + nb);
    (*(t + n)) = (uint64_t)0u;
    a = mbignum_makebignum(length);
    (*a).neg = neg;
    (*a).expon = wd;
    u = t;
    (*(*a).num)[((int64_t)0)] = mbignum_strvaln(u,na);
    u += na;
    L474 :;
    for (i=(int64_t)1;i<=(length - (int64_t)1);i+=(int64_t)1) {
L475 :;
        (*(*a).num)[(i)] = mbignum_strvaln(u,w);
        u += w;
L476 :;
    }L477 :;
    ;
    mbignum_freemem((void *)(t),talloc);
    return a;
}

static void mbignum_bn_fdivu(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b,int64_t precision) {
    int32_t *  c;
    int32_t *  x;
    int64_t expona;
    int64_t exponb;
    int64_t na;
    int64_t nb;
    int64_t nc;
    int64_t nx;
    int64_t nx2;
    int64_t cx;
    int64_t nc2;
    int64_t uppera;
    int64_t upperb;
    int64_t upperc;
    int64_t n;
    int64_t k;
    int64_t nexta;
    int32_t *  pa;
    int32_t *  pb;
    int64_t i;
    na = (*a).length;
    nb = (*b).length;
    expona = (*a).expon;
    exponb = (*b).expon;
    if (!!(precision)) {
        precision = (((precision - (int64_t)1) / (int64_t)9) + (int64_t)1);
    } else {
        precision = mbignum_currprec;
    };
    nc = precision;
    uppera = (na - (int64_t)1);
    upperb = (nb - (int64_t)1);
    upperc = (nc - (int64_t)1);
    pa = (int32_t *)((*a).num);
    pb = (int32_t *)((*b).num);
    n = nb;
    x = mbignum_makesmallnum((nx2 = (n + (int64_t)1)));
    nx = n;
    L478 :;
    for (i=(int64_t)0;i<=upperb;i+=(int64_t)1) {
L479 :;
        if ((i <= uppera)) {
            (*(x + i)) = (int64_t)((*(pa + i)));
        } else {
            (*(x + i)) = (int64_t)0;
        };
L480 :;
    }L481 :;
    ;
    c = mbignum_makesmallnum((nc2 = (nc + (int64_t)1)));
    cx = (int64_t)0;
    L482 :;
    while (1) {
        k = (int64_t)(mbignum_smalldiv(x,pb,&nx,nb));
        (*(c + cx++)) = k;
        if ((cx > nc)) {
            goto L483 ;
        };
        nexta = ((n > uppera)?(int64_t)0:(int64_t)((*(pa + n))));
        ++n;
        if (((nx == (int64_t)1) && ((int64_t)((*x)) == (int64_t)0))) {
            (*x) = nexta;
        } else {
            (*(x + nx)) = nexta;
            ++nx;
        };
    }L483 :;
    ;
    mbignum_freesmall(x,nx2);
    if (((cx == (int64_t)1) && ((int64_t)((*c)) == (int64_t)0))) {
        mbignum_freesmall(c,nc2);
        mbignum_bn_setzero(dest);
        return;
    };
    if ((((int64_t)((*c)) == (int64_t)0) && (cx >= (int64_t)2))) {
        mbignum_smalltobig(dest,(c + (int64_t)1),(cx - (int64_t)1),nc2,(int64_t)-1);
        (*dest).expon = ((expona - exponb) - (int64_t)1);
    } else {
        mbignum_smalltobig(dest,c,cx,nc2,(int64_t)0);
        (*dest).expon = (expona - exponb);
    };
}

static uint8_t * mbignum_tostring_float(struct mbignum_bignumrec * a,int64_t fmt) {
    int64_t expon;
    int64_t upper;
    int64_t nchars;
    int64_t w;
    int64_t prel;
    int64_t n;
    int64_t showdot;
    uint8_t *  s;
    uint8_t *  t;
    int64_t av_1;
    int64_t av_2;
    int64_t av_3;
    int64_t av_4;
    int64_t i;
    expon = (*a).expon;
    upper = ((*a).length - (int64_t)1);
    if (((fmt == (int64_t)73) && !!(mbignum_bn_isint(a)))) {
        showdot = (int64_t)0;
    } else {
        showdot = (int64_t)1;
    };
    w = (int64_t)9;
    nchars = (int64_t)3;
    if ((expon < (int64_t)0)) {
        nchars += (labs((expon - (int64_t)1)) * w);
    };
    nchars += ((*a).length * w);
    if (((expon - upper) > (int64_t)0)) {
        nchars += ((expon - upper) * w);
    };
    nchars += (int64_t)8;
    s = (t = (uint8_t *)(mbignum_checkedmalloc(nchars)));
    if (!!((int64_t)((*a).neg))) {
        (*t++) = '-';
    };
    prel = (int64_t)0;
    if ((expon < (int64_t)0)) {
        prel = (int64_t)1;
        (*t++) = '0';
        (*t++) = '.';
        av_2 = (labs(expon) - (int64_t)1);
        while (av_2-- > 0) {
L484 :;
            av_1 = (int64_t)9;
            while (av_1-- > 0) {
L487 :;
                (*t++) = '0';
L488 :;
            }L489 :;
            ;
L485 :;
        }L486 :;
        ;
    };
    L490 :;
    for (i=(int64_t)0;i<=upper;i+=(int64_t)1) {
L491 :;
        n = (int64_t)(sprintf((int8_t *)(t),(((i > (int64_t)0) || !!(prel))?(int8_t *)((uint8_t*)"%09lld"):(int8_t *)((uint8_t*)"%lld")),(int64_t)((*(*a).num)[(i)])));
        t += n;
        if ((((expon == i) && (i < upper)) && !!(showdot))) {
            (*t++) = '.';
        };
L492 :;
    }L493 :;
    ;
    av_4 = (expon - upper);
    while (av_4-- > 0) {
L494 :;
        av_3 = (int64_t)9;
        while (av_3-- > 0) {
L497 :;
            (*t++) = '0';
L498 :;
        }L499 :;
        ;
L495 :;
    }L496 :;
    ;
    if (((expon >= upper) && !!(showdot))) {
        (*t++) = '.';
        (*t++) = '0';
    };
    (*t) = (uint64_t)0u;
    return s;
}

uint8_t * mbignum_bn_tostring(struct mbignum_bignumrec * a,int64_t fmt) {
    uint8_t *  s;
    uint8_t *  t;
    t = (uint8_t *)(0);
    if ((a == 0)) {
        t = (uint8_t*)"<void>";
    } else {
        if (((int64_t)((*a).numtype)==(int64_t)0)) {
            t = (((fmt == (int64_t)69) || (fmt == (int64_t)70))?(uint8_t*)"0.0":(uint8_t*)"0");
        }else if (((int64_t)((*a).numtype)==(int64_t)2)) {
            t = (uint8_t*)"<inf>";
        }else if (((int64_t)((*a).numtype)==(int64_t)3)) {
            t = (uint8_t*)"<nan>";
        };
    };
    if (!!(t)) {
        s = (uint8_t *)(mbignum_checkedmalloc(((int64_t)(strlen((int8_t *)(t))) + (int64_t)1)));
        strcpy((int8_t *)(s),(int8_t *)(t));
        return s;
    };
    if (((fmt == (int64_t)0) || (fmt == (int64_t)65))) {
        if ((!!(mbignum_bn_isint(a)) && ((((*a).expon - (*a).length) * (int64_t)9) < (int64_t)60))) {
            fmt = (int64_t)73;
        } else if ((labs(((*a).expon * (int64_t)9)) < (int64_t)60)) {
            fmt = (int64_t)70;
        } else {
            fmt = (int64_t)69;
        };
    };
    if ((fmt == (int64_t)69)) {
        s = mbignum_tostring_scient(a);
    } else {
        s = mbignum_tostring_float(a,fmt);
    };
    return s;
}

static uint8_t * mbignum_tostring_scient(struct mbignum_bignumrec * a) {
    uint8_t *  s;
    uint8_t *  t;
    int64_t expon;
    int64_t nchars;
    int64_t shift;
    int64_t x;
    int64_t scale;
    int64_t av_1;
    int64_t i;
    nchars = (int64_t)3;
    expon = ((*a).expon * (int64_t)9);
    x = (int64_t)((*(*a).num)[((int64_t)0)]);
    scale = (int64_t)1;
    shift = (int64_t)0;
    L500 :;
    while ((x >= (int64_t)10)) {
        x = (x / (int64_t)10);
        scale *= (int64_t)10;
        ++expon;
        ++shift;
L501 :;
    }L502 :;
    ;
    nchars = (((*a).length * (int64_t)9) + (int64_t)16);
    s = (t = (uint8_t *)(mbignum_checkedmalloc(nchars)));
    if (!!((int64_t)((*a).neg))) {
        (*t++) = '-';
    };
    msysnewc_m_print_startstr(t);
    msysnewc_m_print_i64(x,NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((uint8_t*)".",NULL);
    msysnewc_m_print_end();
    ;
    t += (int64_t)(strlen((int8_t *)(t)));
    if (!!(shift)) {
        msysnewc_m_print_startstr(t);
        msysnewc_m_print_i64(shift,(uint8_t*)"v");
        msysnewc_m_print_nogap();
        msysnewc_m_print_i64(((int64_t)((*(*a).num)[((int64_t)0)]) - (x * scale)),(uint8_t*)"z*");
        msysnewc_m_print_end();
        ;
        t += (int64_t)(strlen((int8_t *)(t)));
    };
    L503 :;
    for (i=(int64_t)1;i<=((*a).length - (int64_t)1);i+=(int64_t)1) {
L504 :;
        msysnewc_m_print_startstr(t);
        msysnewc_m_print_i64((*(*a).num)[(i)],(uint8_t*)"z9");
        msysnewc_m_print_end();
        ;
        t += (int64_t)(strlen((int8_t *)(t)));
L505 :;
    }L506 :;
    ;
    L507 :;
    while ((((uint64_t)((*(t - (int64_t)1))) == '0') && ((uint64_t)((*(t - (int64_t)2))) != '.'))) {
        --t;
L508 :;
    }L509 :;
    ;
    msysnewc_m_print_startstr(t);
    msysnewc_m_print_str((uint8_t*)"e",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64(expon,NULL);
    msysnewc_m_print_end();
    ;
    t += (int64_t)(strlen((int8_t *)(t)));
    (*t) = (uint64_t)0u;
    return s;
}

int64_t mbignum_bn_add(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b) {
    int64_t nega;
    int64_t negb;
    switch (mbignum_getbintype(a,b)) {
    case 1:;
    {
    }break;
    case 2:;
    {
        mbignum_bn_setzero(dest);
        return (int64_t)1;
    }break;
    case 5:;
    {
        mbignum_bn_dupl(dest,a);
        return (int64_t)1;
    }break;
    case 7:;
    {
        mbignum_bn_dupl(dest,b);
        return (int64_t)1;
    }break;
    default: {
        mbignum_bn_setnan(dest);
        return (int64_t)0;
    }
    } //SW
;
    nega = (int64_t)((*a).neg);
    negb = (int64_t)((*b).neg);
    if ((!(!!(nega)) && !(!!(negb)))) {
        mbignum_bn_addu(dest,a,b);
    } else if ((!!(nega) && !!(negb))) {
        mbignum_bn_addu(dest,a,b);
        mbignum_bn_negto(dest);
    } else if ((!(!!(nega)) && !!(negb))) {
        mbignum_bn_subu(dest,a,b);
    } else {
        mbignum_bn_subu(dest,b,a);
    };
    return (int64_t)1;
}

int64_t mbignum_bn_sub(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b) {
    int64_t nega;
    int64_t negb;
    switch (mbignum_getbintype(a,b)) {
    case 1:;
    {
    }break;
    case 2:;
    {
        mbignum_bn_setzero(dest);
        return (int64_t)1;
    }break;
    case 5:;
    {
        mbignum_bn_dupl(dest,a);
        return (int64_t)1;
    }break;
    case 7:;
    {
        mbignum_bn_dupl(dest,b);
        mbignum_bn_negto(dest);
        return (int64_t)1;
    }break;
    default: {
        mbignum_bn_setnan(dest);
        return (int64_t)0;
    }
    } //SW
;
    nega = (int64_t)((*a).neg);
    negb = (int64_t)((*b).neg);
    if ((!(!!(nega)) && !(!!(negb)))) {
        mbignum_bn_subu(dest,a,b);
    } else if ((!!(nega) && !!(negb))) {
        mbignum_bn_subu(dest,b,a);
    } else if ((!(!!(nega)) && !!(negb))) {
        mbignum_bn_addu(dest,a,b);
    } else {
        mbignum_bn_subu(dest,b,a);
    };
    return (int64_t)1;
}

int64_t mbignum_bn_mul(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b) {
    int64_t neg;
    switch (mbignum_getbintype(a,b)) {
    case 1:;
    {
    }break;
    case 2:;
    case 5:;
    case 7:;
    {
        mbignum_bn_setzero(dest);
        return (int64_t)1;
    }break;
    default: {
        mbignum_bn_setnan(dest);
        return (int64_t)0;
    }
    } //SW
;
    neg = ((int64_t)((*a).neg) != (int64_t)((*b).neg));
    mbignum_bn_mulu(dest,a,b);
    if (!!(neg)) {
        mbignum_bn_negto(dest);
    };
    return (int64_t)1;
}

int64_t mbignum_bn_mulp(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b,int64_t prec) {
    int64_t res;
    res = mbignum_bn_mul(dest,a,b);
    if (!!(res)) {
        mbignum_bn_setprec(dest,((prec == (int64_t)0)?mbignum_currprec:prec));
    };
    return res;
}

int64_t mbignum_bn_div(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b,int64_t prec) {
    int64_t neg;
    switch (mbignum_getbintype(a,b)) {
    case 1:;
    {
    }break;
    case 7:;
    {
        mbignum_bn_setzero(dest);
        return (int64_t)1;
    }break;
    case 2:;
    case 5:;
    {
        mbignum_bn_setinf(dest);
        return (int64_t)0;
    }break;
    default: {
        mbignum_bn_setnan(dest);
        return (int64_t)0;
    }
    } //SW
;
    neg = ((int64_t)((*a).neg) != (int64_t)((*b).neg));
    mbignum_bn_fdivu(dest,a,b,prec);
    if (!!(neg)) {
        mbignum_bn_negto(dest);
    };
    return (int64_t)1;
}

int64_t mbignum_bn_idiv(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b) {
    int64_t neg;
    switch (mbignum_getbintype(a,b)) {
    case 1:;
    {
    }break;
    case 7:;
    {
        mbignum_bn_setzero(dest);
        return (int64_t)1;
    }break;
    case 2:;
    case 5:;
    {
        mbignum_bn_setinf(dest);
        return (int64_t)0;
    }break;
    default: {
        mbignum_bn_setnan(dest);
        return (int64_t)0;
    }
    } //SW
;
    neg = ((int64_t)((*a).neg) != (int64_t)((*b).neg));
    mbignum_bn_idivu(dest,a,b,(struct mbignum_bignumrec *)(0));
    if (!!(neg)) {
        mbignum_bn_negto(dest);
    };
    return (int64_t)1;
}

int64_t mbignum_bn_idivrem(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * rm,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b) {
    int64_t nega;
    int64_t negb;
    switch (mbignum_getbintype(a,b)) {
    case 1:;
    {
    }break;
    case 7:;
    {
        mbignum_bn_setzero(dest);
        mbignum_bn_setzero(rm);
        return (int64_t)1;
    }break;
    case 2:;
    case 5:;
    {
        mbignum_bn_setinf(dest);
        mbignum_bn_setzero(rm);
        return (int64_t)0;
    }break;
    default: {
        mbignum_bn_setnan(dest);
        return (int64_t)0;
    }
    } //SW
;
    nega = (int64_t)((*a).neg);
    negb = (int64_t)((*b).neg);
    mbignum_bn_idivu(dest,a,b,rm);
    if ((nega != negb)) {
        mbignum_bn_negto(dest);
    };
    if (!!(nega)) {
        mbignum_bn_negto(rm);
    };
    return (int64_t)1;
}

int64_t mbignum_bn_irem(struct mbignum_bignumrec * dest,struct mbignum_bignumrec * a,struct mbignum_bignumrec * b) {
    struct mbignum_bignumrec *  d;
    int64_t nega;
    switch (mbignum_getbintype(a,b)) {
    case 1:;
    {
    }break;
    case 7:;
    {
        mbignum_bn_dupl(dest,b);
        return (int64_t)1;
    }break;
    case 2:;
    case 5:;
    {
        mbignum_bn_setinf(dest);
        mbignum_bn_setzero(dest);
        return (int64_t)0;
    }break;
    default: {
        mbignum_bn_setnan(dest);
        return (int64_t)0;
    }
    } //SW
;
    nega = (int64_t)((*a).neg);
    d = mbignum_bn_init();
    mbignum_bn_idivu(d,a,b,dest);
    if (!!(nega)) {
        mbignum_bn_negto(dest);
    };
    mbignum_bn_free(d);
    return (int64_t)1;
}

int64_t mbignum_bn_cmp(struct mbignum_bignumrec * a,struct mbignum_bignumrec * b) {
    struct mbignum_bignumrec *  d;
    int64_t neg;
    if (!!(mbignum_bn_equal(a,b))) {
        return (int64_t)0;
    };
    d = mbignum_bn_init();
    mbignum_bn_sub(d,a,b);
    neg = (int64_t)((*d).neg);
    mbignum_bn_free(d);
    return (!!(neg)?(int64_t)-1:(int64_t)1);
}

struct mbignum_bignumrec * mbignum_bn_const(int64_t value) {
    struct mbignum_constrec *  p;
    p = mbignum_constlist;
    L510 :;
    while (!!(p)) {
        if (((*p).value == value)) {
            return (*p).bnvalue;
        };
        p = (*p).nextconst;
L511 :;
    }L512 :;
    ;
    p = (struct mbignum_constrec *)(mbignum_bn_alloc((int64_t)24));
    (*p).bnvalue = mbignum_bn_makeint(value);
    (*p).value = value;
    (*p).nextconst = mbignum_constlist;
    mbignum_constlist = p;
    return (*p).bnvalue;
}

int64_t mbignum_bn_sign(struct mbignum_bignumrec * a) {
    if (!!(mbignum_bn_iszero(a))) {
        return (int64_t)0;
    } else if (!!((int64_t)((*a).neg))) {
        return (int64_t)-1;
    } else {
        return (int64_t)0;
    };
}

static struct mbignum_bignumrec * mbignum_badnumber(void) {
    struct mbignum_bignumrec *  c;
    c = mbignum_makebignum((int64_t)0);
    (*c).numtype = (int64_t)3;
    return c;
}

int64_t mbignum_bn_digits(struct mbignum_bignumrec * a) {
    int64_t n;
    uint8_t str[32];
    if (!(!!(mbignum_bn_isint(a)))) {
        return (int64_t)0;
    };
    if (!!(mbignum_bn_iszero(a))) {
        return (int64_t)1;
    };
    n = (int64_t)(sprintf((int8_t *)(str),(int8_t *)((uint8_t*)"%lld"),(int64_t)((*(*a).num)[((int64_t)0)])));
    return (n + ((*a).expon * (int64_t)9));
}

int64_t mbignum_bn_toint(struct mbignum_bignumrec * a) {
    int64_t x;
    int64_t av_1;
    int64_t i;
    if (!(!!(mbignum_bn_isint(a)))) {
        return (int64_t)0;
    };
    if (!!(mbignum_bn_iszero(a))) {
        return (int64_t)0;
    };
    x = (int64_t)0;
    L513 :;
    for (i=(int64_t)0;i<=((*a).length - (int64_t)1);i+=(int64_t)1) {
L514 :;
        x = ((x * (int64_t)1000000000) + (int64_t)((*(*a).num)[(i)]));
L515 :;
    }L516 :;
    ;
    if (!!((int64_t)((*a).neg))) {
        return -(x);
    } else {
        return x;
    };
}

double mbignum_bn_tofloat(struct mbignum_bignumrec * a) {
    double x;
    uint8_t *  s;
    if (!!(mbignum_bn_iszero(a))) {
        return (double)0.;
    };
    s = mbignum_bn_tostring(a,(int64_t)69);
    sscanf((int8_t *)(s),(int8_t *)((uint8_t*)"%lf"),&x);
    return x;
}

void mbignum_bn_fix(struct mbignum_bignumrec * c,struct mbignum_bignumrec * a) {
    if ((!!(mbignum_bn_iszero(a)) || ((*a).expon < (int64_t)0))) {
        mbignum_bn_setzero(c);
        return;
    };
    mbignum_bn_dupl(c,a);
    if (!(!!(mbignum_bn_isint(c)))) {
        mbignum_bn_setprec(c,((*c).expon + (int64_t)1));
    };
}

void mbignum_bntest(struct mbignum_bignumrec * a) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"BNTEST",NULL);
    msysnewc_m_print_str((uint8_t*)"A.NUMTYPE=",NULL);
    msysnewc_m_print_i64((*a).numtype,NULL);
    msysnewc_m_print_str((uint8_t*)"A.LENGTH=",NULL);
    msysnewc_m_print_i64((*a).length,NULL);
    msysnewc_m_print_str((uint8_t*)"A.EXPON=",NULL);
    msysnewc_m_print_i64((*a).expon,NULL);
    msysnewc_m_print_str((uint8_t*)"A.NEG=",NULL);
    msysnewc_m_print_i64((*a).neg,NULL);
    msysnewc_m_print_str((uint8_t*)"A.NUM=",NULL);
    msysnewc_m_print_ptr((*a).num,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

void pc_print_pch_print(struct pc_decls_varrec * p,struct pc_decls_varrec * fmt) {
    struct pc_decls_varrec v;
    struct pc_decls_varrec emptyfmt;
    if ((fmt == 0)) {
        fmt = &emptyfmt;
        emptyfmt.tagx = (uint64_t)((int64_t)0);
    };
    if ((pc_print_mfmtstr == 0)) {
        if (!!((uint64_t)(pc_print_mgapneeded))) {
            pc_print_printstr_n((uint8_t*)" ",(int64_t)1);
        } else {
            pc_print_mgapneeded = (uint64_t)((int64_t)1);
        };
    } else {
        pc_print_printnextfmtchars((int64_t)0);
    };
    switch ((int64_t)(pc_decls_ttbasetype[((int64_t)((*p).tag))])) {
    case 5:;
    {
        if (((fmt == 0) || ((int64_t)((uint64_t)((*fmt).tag)) == (int64_t)0))) {
            pc_print_printstr_n((*(*p).objptr).ustr.strptr,(int64_t)((*(*p).objptr).ustr.length));
            return;
        };
    }break;
    case 1:;
    case 3:;
    case 4:;
    case 2:;
    {
        pc_print_pch_tostr(p,fmt,&v);
        pc_print_printstr_n((*v.objptr).ustr.strptr,(int64_t)((*v.objptr).ustr.length));
        pc_pcfns_pc_unshare(&v);
        return;
    }break;
    default: {
    }
    } //SW
;
    pc_print_pch_tostr(p,fmt,&v);
    pc_print_printstr_n((*v.objptr).ustr.strptr,(int64_t)((*v.objptr).ustr.length));
    pc_pcfns_pc_unshare(&v);
}

void pc_print_pch_println(void) {
    if (!!(pc_print_mfmtstr)) {
        pc_print_printnextfmtchars((int64_t)1);
    };
    pc_print_printstrz((uint8_t*)"\r\n");
}

void pc_print_pch_startprintcon(void) {
    struct pc_decls_varrec v;
    v.tagx = (uint64_t)((int64_t)1);
    v.value = (int64_t)0;
    pc_print_pch_startprint(&v);
}

void pc_print_pch_startprint(struct pc_decls_varrec * p) {
    struct pc_decls_objrec *  s;
    switch (++pc_print_noclevels) {
    case 0:;
    case 1:;
    {
    }break;
    case 7:;
    {
        pc_print_printerror((uint8_t*)"print #x overflow");
    }break;
    default: {
        pc_print_moutdevstack[((pc_print_noclevels - (int64_t)1))] = pc_print_moutdev;
        pc_print_moutchanstack[((pc_print_noclevels - (int64_t)1))] = pc_print_moutchan;
        pc_print_moutvarstack[((pc_print_noclevels - (int64_t)1))] = pc_print_moutvar;
        pc_print_mfmtstrstack[((pc_print_noclevels - (int64_t)1))] = pc_print_mfmtstr;
        pc_print_mfmtcurrstack[((pc_print_noclevels - (int64_t)1))] = pc_print_mfmtcurr;
        pc_print_mgapstack[((pc_print_noclevels - (int64_t)1))] = (uint64_t)(pc_print_mgapneeded);
    }
    } //SW
;
    pc_print_mfmtstr = (uint8_t *)(0);
    pc_print_mfmtcurr = (uint8_t *)(0);
    if ((p == 0)) {
        goto L517 ;
;
    };
    switch ((int64_t)((*p).tag)) {
    case 1:;
    {
        switch ((*p).value) {
        case 0:;
        {
            //doconsole:
L517 :;
;
            pc_print_moutdev = (int64_t)0;
            pc_print_moutchan = 0;
        }break;
        case 1:;
        {
            pc_print_moutdev = (int64_t)2;
            pc_print_moutchan = 0;
            pc_print_moutvar.tagx = (uint64_t)((int64_t)65541);
            s = pc_objlib_obj_new((int64_t)5);
            (*s).ustr.mutable = (uint64_t)((int64_t)1);
            pc_print_moutvar.objptr = s;
        }break;
        case 2:;
        {
            if ((pc_print_testfilech == 0)) {
                pc_support_prterror((uint8_t*)"@2: file not open");
            };
            pc_print_moutdev = (int64_t)1;
            pc_print_moutchan = pc_print_testfilech;
        }break;
        default: {
            pc_print_moutdev = (int64_t)1;
            pc_print_moutchan = (void *)((*p).value);
        }
        } //SW
;
    }break;
    case 22:;
    {
        p = (*p).varptr;
        switch ((int64_t)((*p).tag)) {
        case 5:;
        {
            pc_print_moutdev = (int64_t)4;
            pc_print_moutchan = 0;
            pc_print_moutvar.tagx = (uint64_t)((int64_t)22);
            pc_print_moutvar.varptr = p;
        }break;
        default: {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(pc_decls_ttname[((int64_t)((*p).tag))],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            pc_support_prterror((uint8_t*)"Print@^?");
        }
        } //SW
;
    }break;
    default: {
        switch ((int64_t)(pc_decls_ttbasetype[((int64_t)((*p).tag))])) {
        case 32:;
        case 33:;
        {
            pc_print_moutdev = (int64_t)0;
        }break;
        default: {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(pc_decls_ttname[((int64_t)((*p).tag))],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            pc_print_printerror((uint8_t*)"Can't do startprint...");
        }
        } //SW
;
    }
    } //SW
;
    pc_print_mgapneeded = (uint64_t)((int64_t)0);
}

void pc_print_pch_endprint(void) {
    struct pc_decls_varrec *  p;
    if (!!(pc_print_mfmtstr)) {
        pc_print_printnextfmtchars((int64_t)1);
    };
    switch (pc_print_moutdev) {
    case 4:;
    {
        p = pc_print_moutvar.varptr;
    }break;
    default: {
    }
    } //SW
;
    if ((pc_print_mfmtstr != 0)) {
        mlib_pcm_free((void *)(pc_print_mfmtstr),((int64_t)(strlen((int8_t *)(pc_print_mfmtstr))) + (int64_t)1));
    };
    if ((--pc_print_noclevels == (int64_t)-1)) {
        pc_print_printerror((uint8_t*)"resetoc??");
    };
    if ((pc_print_noclevels == (int64_t)0)) {
        pc_print_moutdev = (int64_t)0;
    } else {
        pc_print_moutdev = (int64_t)(pc_print_moutdevstack[(pc_print_noclevels)]);
        pc_print_moutchan = pc_print_moutchanstack[(pc_print_noclevels)];
        pc_print_moutvar = pc_print_moutvarstack[(pc_print_noclevels)];
        pc_print_mgapneeded = (uint64_t)(pc_print_mgapstack[(pc_print_noclevels)]);
        pc_print_mfmtstr = pc_print_mfmtstrstack[(pc_print_noclevels)];
        pc_print_mfmtcurr = pc_print_mfmtcurrstack[(pc_print_noclevels)];
    };
}

void pc_print_pch_strstartprint(void) {
    struct pc_decls_varrec p;
    p.tagx = (uint64_t)((int64_t)1);
    p.value = (int64_t)1;
    pc_print_pch_startprint(&p);
}

void pc_print_pch_strendprint(struct pc_decls_varrec * dest) {
    if (!!(pc_print_mfmtstr)) {
        pc_print_printnextfmtchars((int64_t)1);
    };
    if ((pc_print_moutdev != (int64_t)2)) {
        pc_support_prterror((uint8_t*)"STRendPRT/NOT STR");
    };
    (*dest) = pc_print_moutvar;
    pc_print_moutvar.tagx = (uint64_t)((int64_t)0);
    pc_print_pch_endprint();
}

void pc_print_pch_setformat(struct pc_decls_varrec * p) {
    int64_t n;
    uint8_t *  s;
    if (((int64_t)((uint64_t)((*p).tag)) != (int64_t)5)) {
        pc_support_prterror((uint8_t*)"(str)");
    };
    if (!!(pc_print_mfmtstr)) {
        pc_support_prterror((uint8_t*)"Setfmt?");
    };
    n = (int64_t)((*(*p).objptr).ustr.length);
    pc_print_mfmtstr = (uint8_t *)(mlib_pcm_alloc((n + (int64_t)1)));
    if (!!(n)) {
        memcpy((void *)(pc_print_mfmtstr),(void *)((*(*p).objptr).ustr.strptr),(uint64_t)(n));
    };
    s = (pc_print_mfmtstr + n);
    (*s) = (uint64_t)0u;
    pc_print_mfmtcurr = pc_print_mfmtstr;
}

void pc_print_pch_setformat2(struct pc_decls_varrec * p) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"PC/SETFORMAT2",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

void pc_print_pch_dprint(struct pc_decls_varrec * p,struct pc_decls_varrec * fmt) {
    pc_print_pch_print(p,fmt);
    switch ((int64_t)((*p).tag)) {
    case 1:;
    {
        pc_print_printstrz((uint8_t*)"d");
    }break;
    case 2:;
    {
        pc_print_printstrz((uint8_t*)"u");
    }break;
    default: {
    }
    } //SW
;
}

void pc_print_pch_printnogap(void) {
    pc_print_mgapneeded = (uint64_t)((int64_t)0);
}

static void pc_print_initfmtcode(struct pc_decls_fmtrec * f) {
    (*f) = pc_print_defaultfmt;
}

static int64_t pc_print_i64mintostr(uint8_t * s,int64_t base,int64_t sep) {
    uint8_t t[1024];
    int64_t i;
    int64_t j;
    int64_t k;
    int64_t g;
    switch (base) {
    case 10:;
    {
        strcpy((int8_t *)(&t[((int64_t)0)]),(int8_t *)((uint8_t*)"9223372036854775808"));
        j = (int64_t)3;
    }break;
    case 16:;
    {
        strcpy((int8_t *)(&t[((int64_t)0)]),(int8_t *)((uint8_t*)"8000000000000000"));
        j = (int64_t)1;
    }break;
    case 2:;
    {
        strcpy((int8_t *)(&t[((int64_t)0)]),(int8_t *)((uint8_t*)"1000000000000000000000000000000000000000000000000000000000000000"));
        j = (int64_t)7;
    }break;
    default: {
        strcpy((int8_t *)(&t[((int64_t)0)]),(int8_t *)((uint8_t*)"<mindint>"));
    }
    } //SW
;
    i = (int64_t)(strlen((int8_t *)(&t[((int64_t)0)])));
    s += i;
    if (!!(sep)) {
        s += j;
    };
    (*s) = (uint64_t)0u;
    k = (int64_t)0;
    g = ((base == (int64_t)10)?(int64_t)3:(int64_t)4);
    L518 :;
    while (!!(i)) {
        --s;
        (*s) = (uint64_t)(t[((i-- - (int64_t)1))]);
        if (((!!(sep) && !!(i)) && (++k == g))) {
            --s;
            (*s) = (uint64_t)(sep);
            k = (int64_t)0;
        };
L519 :;
    }L520 :;
    ;
    return (int64_t)(strlen((int8_t *)(s)));
}

static int64_t pc_print_u64tostr(uint64_t aa,uint8_t * s,uint64_t base,int64_t sep) {
    uint8_t t[1024];
    int64_t i;
    int64_t j;
    int64_t k;
    int64_t g;
    uint8_t *  s0;
    i = (int64_t)0;
    k = (int64_t)0;
    g = (((int64_t)(base) == (int64_t)10)?(int64_t)3:(int64_t)4);
    L521 :;
    do {
        t[(++i)] = (uint64_t)(pc_print_digits[((int64_t)((aa % base)))]);
        aa = (aa / base);
        if (((!!(sep) && ((int64_t)(aa) != (int64_t)0)) && (++k == g))) {
            t[(++i)] = (uint64_t)(sep);
            k = (int64_t)0;
        };
L522 :;
    } while (!((int64_t)(aa) == (int64_t)0));L523 :;
    ;
    j = i;
    s0 = s;
    L524 :;
    while (!!(i)) {
        (*s) = (uint64_t)(t[(i--)]);
        ++s;
L525 :;
    }L526 :;
    ;
    (*s) = (uint64_t)0u;
    return j;
}

static int64_t pc_print_i64tostrfmt(int64_t aa,uint8_t * s,struct pc_decls_fmtrec * fmt,int64_t usigned) {
    uint8_t str[1024];
    int64_t n;
    static uint64_t mindint = (uint64_t)9223372036854775808u;
    if (!!((uint64_t)((*fmt).usigned))) {
        usigned = (int64_t)1;
    };
    if (((aa == (int64_t)(mindint)) && !(!!(usigned)))) {
        str[((int64_t)0)] = '-';
        n = (pc_print_i64mintostr(&str[((int64_t)1)],(int64_t)((*fmt).base),(int64_t)((*fmt).sepchar)) + (int64_t)1);
    } else {
        if (((!(!!(usigned)) && (aa < (int64_t)0)) || !!((uint64_t)((*fmt).plus)))) {
            if ((aa < (int64_t)0)) {
                aa = -(aa);
                str[((int64_t)0)] = '-';
            } else {
                str[((int64_t)0)] = '+';
            };
            n = (pc_print_u64tostr((uint64_t)(aa),&str[((int64_t)1)],(uint64_t)((*fmt).base),(int64_t)((*fmt).sepchar)) + (int64_t)1);
        } else {
            n = pc_print_u64tostr((uint64_t)(aa),str,(uint64_t)((*fmt).base),(int64_t)((*fmt).sepchar));
        };
    };
    if (!!((uint64_t)((*fmt).suffix))) {
        str[(n)] = (uint64_t)((*fmt).suffix);
        str[(++n)] = (uint64_t)0u;
    };
    if ((((int64_t)((uint64_t)((*fmt).base)) > (int64_t)10) || (!!((uint64_t)((*fmt).suffix)) && ((uint64_t)((*fmt).lettercase) == 'a')))) {
        mlib_convlcstring(str);
    };
    return pc_print_expandstr(str,s,n,fmt);
}

static int64_t pc_print_u64tostrfmt(int64_t aa,uint8_t * s,struct pc_decls_fmtrec * fmt) {
    uint8_t str[1024];
    int64_t n;
    n = pc_print_u64tostr((uint64_t)(aa),str,(uint64_t)((*fmt).base),(int64_t)((*fmt).sepchar));
    if (!!((uint64_t)((*fmt).suffix))) {
        str[(n)] = (uint64_t)((*fmt).suffix);
        str[(++n)] = (uint64_t)0u;
    };
    if ((((int64_t)((uint64_t)((*fmt).base)) > (int64_t)10) || (!!((uint64_t)((*fmt).suffix)) && ((uint64_t)((*fmt).lettercase) == 'a')))) {
        mlib_convlcstring(str);
    };
    return pc_print_expandstr(str,s,n,fmt);
}

static int64_t pc_print_strtostrfmt(uint8_t * s,uint8_t * t,int64_t n,struct pc_decls_fmtrec * fmt) {
    uint8_t *  u;
    uint8_t *  v;
    uint8_t str[256];
    int64_t w;
    int64_t nheap;
    nheap = (int64_t)0;
    if ((!!((uint64_t)((*fmt).quotechar)) || !!((uint64_t)((*fmt).lettercase)))) {
        if ((n < (int64_t)256)) {
            u = str;
        } else {
            nheap = (n + (int64_t)3);
            u = (uint8_t *)(mlib_pcm_alloc(nheap));
        };
        if (!!((uint64_t)((*fmt).quotechar))) {
            v = u;
            (*v) = (uint64_t)((*fmt).quotechar);
            ++v;
            if (!!(n)) {
                strcpy((int8_t *)(v),(int8_t *)(s));
                v += n;
            };
            (*v) = (uint64_t)((*fmt).quotechar);
            ++v;
            (*v) = (uint64_t)0u;
            n += (int64_t)2;
        } else {
            memcpy((void *)(u),(void *)(s),(uint64_t)(n));
        };
        switch ((int64_t)((*fmt).lettercase)) {
        case 97:;
        {
            mlib_convlcstring(u);
        }break;
        case 65:;
        {
            mlib_convucstring(u);
        }break;
        default: {
        }
        } //SW
;
        s = u;
    };
    w = (int64_t)((*fmt).minwidth);
    if ((w > n)) {
        n = pc_print_expandstr(s,t,n,fmt);
    } else {
        memcpy((void *)(t),(void *)(s),(uint64_t)(n));
    };
    if (!!(nheap)) {
        mlib_pcm_free((void *)(u),nheap);
    };
    return n;
}

static int64_t pc_print_expandstr(uint8_t * s,uint8_t * t,int64_t n,struct pc_decls_fmtrec * fmt) {
    int64_t i;
    int64_t w;
    int64_t m;
    int64_t av_1;
    int64_t av_2;
    int64_t av_3;
    int64_t av_4;
    int64_t av_5;
    w = (int64_t)((*fmt).minwidth);
    if (((w == (int64_t)0) || (w <= n))) {
        strncpy((int8_t *)(t),(int8_t *)(s),(uint64_t)(n));
        (*(t + n)) = (uint64_t)0u;
        return n;
    };
    if (((uint64_t)((*fmt).justify) == 'L')) {
        strncpy((int8_t *)(t),(int8_t *)(s),(uint64_t)(n));
        t += n;
        L527 :;
        for (i=(int64_t)1;i<=(w - n);i+=(int64_t)1) {
L528 :;
            (*t) = (uint64_t)((*fmt).padchar);
            ++t;
L529 :;
        }L530 :;
        ;
        (*t) = (uint64_t)0u;
    } else if (((uint64_t)((*fmt).justify) == 'R')) {
        if (((((uint64_t)((*fmt).padchar) == '0') && !!((uint64_t)((*fmt).base))) && (((uint64_t)((*s)) == '-') || ((uint64_t)((*s)) == '+')))) {
            (*t) = (uint64_t)((*s));
            ++t;
            av_2 = (w - n);
            while (av_2-- > 0) {
L531 :;
                (*t) = (uint64_t)((*fmt).padchar);
                ++t;
L532 :;
            }L533 :;
            ;
            strncpy((int8_t *)(t),(int8_t *)((s + (int64_t)1)),(uint64_t)((n - (int64_t)1)));
            (*((t + n) - (int64_t)1)) = (uint64_t)0u;
        } else {
            av_3 = (w - n);
            while (av_3-- > 0) {
L534 :;
                (*t) = (uint64_t)((*fmt).padchar);
                ++t;
L535 :;
            }L536 :;
            ;
            strncpy((int8_t *)(t),(int8_t *)(s),(uint64_t)(n));
            (*(t + n)) = (uint64_t)0u;
        };
    } else {
        m = (((w - n) + (int64_t)1) / (int64_t)2);
        av_4 = m;
        while (av_4-- > 0) {
L537 :;
            (*t) = (uint64_t)((*fmt).padchar);
            ++t;
L538 :;
        }L539 :;
        ;
        strncpy((int8_t *)(t),(int8_t *)(s),(uint64_t)(n));
        t += n;
        av_5 = ((w - n) - m);
        while (av_5-- > 0) {
L540 :;
            (*t) = (uint64_t)((*fmt).padchar);
            ++t;
L541 :;
        }L542 :;
        ;
        (*t) = (uint64_t)0u;
    };
    return w;
}

void pc_print_pc_strtofmt(uint8_t * s,int64_t slen,struct pc_decls_fmtrec * fmt) {
    int64_t c;
    byte wset;
    int64_t n;
    uint8_t str[100];
    pc_print_initfmtcode(fmt);
    memcpy((void *)(str),(void *)(s),(uint64_t)(slen));
    str[(slen)] = (uint64_t)0u;
    s = str;
    wset = (uint64_t)((int64_t)0);
    L543 :;
    while (!!((uint64_t)((*s)))) {
        c = (int64_t)((*s));
        ++s;
        switch (c) {
        case 66:;
        case 98:;
        {
            (*fmt).base = (uint64_t)((int64_t)2);
        }break;
        case 72:;
        case 104:;
        {
            (*fmt).base = (uint64_t)((int64_t)16);
        }break;
        case 79:;
        case 111:;
        {
            (*fmt).base = (uint64_t)((int64_t)8);
        }break;
        case 88:;
        case 120:;
        {
            c = (int64_t)((*s));
            if (!!(c)) {
                switch (c) {
                case 50:;
                case 51:;
                case 52:;
                case 53:;
                case 54:;
                case 55:;
                case 56:;
                case 57:;
                {
                    c = (c - (int64_t)48);
                }break;
                case 49:;
                {
                    ++s;
                    c = (int64_t)((*s));
                    if ((c>=(uint64_t)48u && c<=(uint64_t)54u)) {
                        c = ((c - (int64_t)48) + (int64_t)10);
                    };
                }break;
                default: {
                    c = (int64_t)10;
                }
                } //SW
;
                (*fmt).base = (uint64_t)(c);
                ++s;
            };
        }break;
        case 81:;
        case 113:;
        {
            (*fmt).quotechar = '"';
        }break;
        case 126:;
        {
            (*fmt).quotechar = '~';
        }break;
        case 74:;
        case 106:;
        {
            (*fmt).justify = (uint64_t)(toupper((int64_t)((int32_t)((*s)))));
            if (!!((uint64_t)((*s)))) {
                ++s;
            };
        }break;
        case 65:;
        {
            (*fmt).lettercase = 'A';
        }break;
        case 97:;
        {
            (*fmt).lettercase = 'a';
        }break;
        case 90:;
        case 122:;
        {
            (*fmt).padchar = '0';
        }break;
        case 83:;
        case 115:;
        {
            (*fmt).sepchar = (uint64_t)((*s));
            if (!!((uint64_t)((*s)))) {
                ++s;
            };
        }break;
        case 80:;
        case 112:;
        {
            (*fmt).padchar = (uint64_t)((*s));
            if (!!((uint64_t)((*s)))) {
                ++s;
            };
        }break;
        case 84:;
        case 116:;
        {
            (*fmt).suffix = (uint64_t)((*s));
            if (!!((uint64_t)((*s)))) {
                ++s;
            };
        }break;
        case 85:;
        case 117:;
        {
            (*fmt).usigned = 'U';
        }break;
        case 69:;
        case 101:;
        {
            (*fmt).realfmt = 'e';
        }break;
        case 70:;
        case 102:;
        {
            (*fmt).realfmt = 'f';
        }break;
        case 71:;
        case 103:;
        {
            (*fmt).realfmt = 'g';
        }break;
        case 46:;
        {
            wset = (uint64_t)((int64_t)1);
        }break;
        case 44:;
        case 95:;
        {
            (*fmt).sepchar = (uint64_t)(c);
        }break;
        case 43:;
        {
            (*fmt).plus = '+';
        }break;
        case 77:;
        case 109:;
        {
            (*fmt).charmode = 'M';
        }break;
        case 67:;
        case 99:;
        {
            (*fmt).charmode = 'C';
        }break;
        case 89:;
        case 121:;
        {
            (*fmt).showtype = 'Y';
        }break;
        default: {
            if (((c >= (int64_t)48) && (c <= (int64_t)57))) {
                n = (c - (int64_t)48);
                L546 :;
                while (1) {
                    c = (int64_t)((*s));
                    if (((int64_t)((*s)) == (int64_t)0)) {
                        goto L547 ;
                    };
                    if (((c >= (int64_t)48) && (c <= (int64_t)57))) {
                        ++s;
                        n = (((n * (int64_t)10) + c) - (int64_t)48);
                    } else {
                        goto L547 ;
                    };
                }L547 :;
                ;
                if (!(!!((uint64_t)(wset)))) {
                    (*fmt).minwidth = (uint64_t)((n<(int64_t)1023?n:(int64_t)1023));
                    wset = (uint64_t)((int64_t)1);
                } else {
                    (*fmt).precision = (n<(int64_t)100?n:(int64_t)100);
                };
            };
        }
        } //SW
;
L544 :;
    }L545 :;
    ;
}

static void pc_print_printstrz(uint8_t * s) {
    switch (pc_print_moutdev) {
    case 0:;
    {
        printf((int8_t *)((uint8_t*)"%s"),s);
    }break;
    case 1:;
    {
        fprintf(pc_print_moutchan,(int8_t *)((uint8_t*)"%s"),s);
    }break;
    case 2:;
    {
        pc_print_addstring(pc_print_moutvar.objptr,s,(int64_t)-1);
    }break;
    case 4:;
    {
        pc_print_printstr_n(s,(int64_t)(strlen((int8_t *)(s))));
    }break;
    case 3:;
    {
    }break;
    default: {
    }
    } //SW
;
}

static void pc_print_printstr_n(uint8_t * s,int64_t n) {
    struct pc_decls_varrec *  p;
    if ((n == (int64_t)-1)) {
        n = (int64_t)(strlen((int8_t *)(s)));
    };
    if ((n == (int64_t)0)) {
        return;
    };
    switch (pc_print_moutdev) {
    case 0:;
    {
        msysnewc_printstrn_app(s,n,0);
    }break;
    case 1:;
    {
        msysnewc_printstrn_app(s,n,pc_print_moutchan);
    }break;
    case 2:;
    {
        pc_print_addstring(pc_print_moutvar.objptr,s,n);
    }break;
    case 4:;
    {
        p = pc_print_moutvar.varptr;
        if (((int64_t)((uint64_t)((*p).tag)) != (int64_t)5)) {
            pc_support_prterror((uint8_t*)"prtstrn1");
        };
        pc_print_addstring(pc_print_moutvar.objptr,s,n);
    }break;
    case 3:;
    {
    }break;
    default: {
    }
    } //SW
;
}

void pc_print_printerror(uint8_t * s) {
    pc_support_prterror(s);
}

void pc_print_addstring(struct pc_decls_objrec * p,uint8_t * t,int64_t n) {
    int64_t oldlen;
    int64_t newlen;
    int64_t oldbytes;
    int64_t newbytes;
    uint8_t *  newptr;
    if (((n == (int64_t)0) || ((int64_t)((*t)) == (int64_t)0))) {
        return;
    };
    if ((n < (int64_t)0)) {
        n = (int64_t)(strlen((int8_t *)(t)));
    };
    oldlen = (int64_t)((*p).ustr.length);
    if (((int64_t)((uint64_t)((*p).refcount)) == (int64_t)0)) {
        if ((oldlen == (int64_t)0)) {
            memcpy((void *)((*p).ustr.strptr),(void *)(t),(uint64_t)(n));
            (*p).ustr.length = n;
        } else {
            memcpy((void *)(((*p).ustr.strptr + oldlen)),(void *)(t),(uint64_t)(n));
            (*p).ustr.length = (oldlen + n);
        };
        return;
    };
    if ((oldlen == (int64_t)0)) {
        (*p).ustr.strptr = (uint8_t *)(mlib_pcm_alloc(n));
        (*p).ustr.length = n;
        (*p).ustr.allocated = (uint64_t)(mlib_allocbytes);
        memcpy((void *)((*p).ustr.strptr),(void *)(t),(uint64_t)(n));
    } else {
        newlen = (oldlen + n);
        oldbytes = (int64_t)((*p).ustr.allocated);
        newbytes = (oldlen + n);
        if ((newbytes <= oldbytes)) {
            memcpy((void *)(((*p).ustr.strptr + oldlen)),(void *)(t),(uint64_t)(n));
        } else {
            newptr = (uint8_t *)(mlib_pcm_alloc(newbytes));
            memcpy((void *)(newptr),(void *)((*p).ustr.strptr),(uint64_t)(oldlen));
            memcpy((void *)((newptr + oldlen)),(void *)(t),(uint64_t)(n));
            (*p).ustr.allocated = (uint64_t)(mlib_allocbytes);
            mlib_pcm_free((void *)((*p).ustr.strptr),oldbytes);
            (*p).ustr.strptr = newptr;
        };
        (*p).ustr.length = newlen;
    };
}

void pc_print_j_tostr_i(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    uint8_t str[1024];
    switch ((int64_t)((*fmt).charmode)) {
    case 77:;
    {
        pc_print_domultichar((uint8_t *)(&(*p).value),(int64_t)8,str,fmt);
    }break;
    case 67:;
    {
        str[((int64_t)1)] = (uint64_t)((*p).value);
        str[((int64_t)2)] = (uint64_t)0u;
    }break;
    default: {
        pc_print_i64tostrfmt((*p).value,str,fmt,(int64_t)0);
    }
    } //SW
;
    if (!!((uint64_t)((*fmt).showtype))) {
        pc_print_addstring(dest,(uint8_t*)"I:",(int64_t)2);
    };
    pc_print_addstring(dest,str,(int64_t)(strlen((int8_t *)(str))));
}

void pc_print_j_tostr_r(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    uint8_t str[1024];
    uint8_t str2[1024];
    uint8_t cfmt[10];
    int64_t n;
    cfmt[((int64_t)0)] = '%';
    if (!!((int64_t)((*fmt).precision))) {
        cfmt[((int64_t)1)] = '.';
        cfmt[((int64_t)2)] = '*';
        cfmt[((int64_t)3)] = (uint64_t)((*fmt).realfmt);
        cfmt[((int64_t)4)] = (uint64_t)0u;
        sprintf((int8_t *)(str),(int8_t *)(cfmt),(int64_t)((*fmt).precision),(*p).xvalue);
    } else {
        cfmt[((int64_t)1)] = (uint64_t)((*fmt).realfmt);
        cfmt[((int64_t)2)] = (uint64_t)0u;
        sprintf((int8_t *)(str),(int8_t *)(cfmt),(*p).xvalue);
    };
    n = (int64_t)(strlen((int8_t *)(str)));
    if ((n < (int64_t)((uint64_t)((*fmt).minwidth)))) {
        pc_print_expandstr(str,str2,n,fmt);
        strcpy((int8_t *)(str),(int8_t *)(str2));
    };
    pc_print_addstring(dest,str,(int64_t)(strlen((int8_t *)(str))));
}

void pc_print_j_tostr_w(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    uint8_t str[1024];
    switch ((int64_t)((*fmt).charmode)) {
    case 77:;
    {
        pc_print_domultichar((uint8_t *)(&(*p).uvalue),(int64_t)8,str,fmt);
    }break;
    case 67:;
    {
        str[((int64_t)1)] = (uint64_t)((*p).uvalue);
        str[((int64_t)2)] = (uint64_t)0u;
    }break;
    default: {
        pc_print_u64tostrfmt((*p).value,str,fmt);
    }
    } //SW
;
    if (!!((uint64_t)((*fmt).showtype))) {
        pc_print_addstring(dest,(uint8_t*)"W:",(int64_t)2);
    };
    pc_print_addstring(dest,str,(int64_t)(strlen((int8_t *)(str))));
}

void pc_print_j_tostr_n(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    uint8_t str[1024];
    pc_print_i64tostrfmt((int64_t)((*p).range_lower),str,fmt,(int64_t)0);
    strcat((int8_t *)(str),(int8_t *)((uint8_t*)".."));
    pc_print_addstring(dest,str,(int64_t)-1);
    pc_print_i64tostrfmt((int64_t)((*p).range_upper),str,fmt,(int64_t)0);
    pc_print_addstring(dest,str,(int64_t)-1);
}

void pc_print_j_tostr_s(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    int64_t oldlen;
    int64_t newlen;
    uint8_t *  s;
    struct pc_decls_objrec *  q;
    q = (*p).objptr;
    oldlen = (int64_t)((*q).ustr.length);
    newlen = oldlen;
    if ((!!((uint64_t)((*fmt).quotechar)) || ((int64_t)((uint64_t)((*fmt).minwidth)) > newlen))) {
        if (!!((uint64_t)((*fmt).quotechar))) {
            newlen += (int64_t)2;
        };
        if (((int64_t)((uint64_t)((*fmt).minwidth)) > newlen)) {
            newlen = (int64_t)((*fmt).minwidth);
        };
        s = (uint8_t *)(mlib_pcm_alloc((newlen + (int64_t)1)));
        pc_print_strtostrfmt((*q).ustr.strptr,s,oldlen,fmt);
        pc_print_addstring(dest,s,newlen);
        mlib_pcm_free((void *)(s),(newlen + (int64_t)1));
    } else {
        pc_print_addstring(dest,(*q).ustr.strptr,oldlen);
    };
}

void pc_print_j_tostr_l_m(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    struct pc_decls_varrec *  q;
    int64_t i;
    int64_t n;
    struct pc_decls_objrec *  r;
    ++pc_print_listdepth;
    r = (*p).objptr;
    if ((((int64_t)((uint64_t)((*r).refcount)) < (int64_t)0) || (pc_print_listdepth > (int64_t)4))) {
        pc_print_addstring(dest,(uint8_t*)"...",(int64_t)3);
        --pc_print_listdepth;
        return;
    };
    pc_print_addstring(dest,(uint8_t*)"(",(int64_t)1);
    (*r).refcount = -((uint64_t)((*r).refcount));
    q = (*r).ulist.vptr;
    if (((int64_t)((uint64_t)((*p).tag)) == (int64_t)29)) {
        n = (int64_t)((*(*p).objptr).ulist.length);
    } else {
        n = (int64_t)(pc_decls_ttlength[((int64_t)((*p).tag))]);
    };
    L548 :;
    for (i=n;i>=(int64_t)1;i-=(int64_t)1) {
L549 :;
        pc_print_calltostrtable(q,fmtstr,fmt,dest);
        ++q;
        if ((i != (int64_t)1)) {
            pc_print_addstring(dest,(uint8_t*)",",(int64_t)1);
        };
L550 :;
    }L551 :;
    ;
    pc_print_addstring(dest,(uint8_t*)")",(int64_t)1);
    (*r).refcount = -((uint64_t)((*r).refcount));
    --pc_print_listdepth;
}

void pc_print_j_tostr_a(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    uint8_t str[1024];
    byte *  q;
    int64_t i;
    int64_t m;
    int64_t elemtype;
    int64_t a;
    int64_t b;
    struct pc_decls_varrec v;
    struct pc_decls_objrec *  pa;
    if ((fmt == 0)) {
        fmt = &pc_print_defaultfmt;
    };
    m = (int64_t)((*p).tag);
    pa = (*p).objptr;
    a = (int64_t)((*pa).uarray.lower);
    elemtype = (int64_t)((*pa).uarray.elemtag);
    b = (((int64_t)((uint64_t)((*pa).uarray.length)) + a) - (int64_t)1);
    q = (*pa).uarray.ptr;
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt((uint8_t*)"#[#:#]");
    msysnewc_m_print_str(pc_decls_ttname[(m)],NULL);
    msysnewc_m_print_i64((*pa).uarray.lower,NULL);
    msysnewc_m_print_str(pc_decls_ttname[(elemtype)],NULL);
    msysnewc_m_print_end();
    ;
    pc_print_addstring(dest,str,(int64_t)-1);
    pc_print_addstring(dest,(uint8_t*)"A(",(int64_t)-1);
    L552 :;
    for (i=a;i<=b;i+=(int64_t)1) {
L553 :;
        pc_pcfns_pc_loadpacked((void *)(q),elemtype,&v,(struct pc_decls_objrec *)(0));
        q += pc_decls_ttsize[(elemtype)];
        pc_print_calltostrtable(&v,fmtstr,fmt,dest);
        if ((i < b)) {
            pc_print_addstring(dest,(uint8_t*)",",(int64_t)1);
        };
L554 :;
    }L555 :;
    ;
    pc_print_addstring(dest,(uint8_t*)")",(int64_t)1);
}

void pc_print_j_tostr_b(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    uint8_t *  q;
    int64_t i;
    int64_t m;
    int64_t elemtype;
    int64_t a;
    int64_t b;
    int64_t offset;
    int64_t bitwidthx;
    struct pc_decls_varrec v;
    struct pc_decls_objrec *  pa;
    if ((fmt == 0)) {
        fmt = &pc_print_defaultfmt;
    };
    m = (int64_t)((*p).tag);
    pa = (*p).objptr;
    a = (int64_t)((*pa).ubits.lower);
    elemtype = (int64_t)((*pa).ubits.elemtag);
    offset = (int64_t)((*pa).ubits.bitoffset);
    b = (((int64_t)((uint64_t)((*pa).ubits.length)) + a) - (int64_t)1);
    bitwidthx = (int64_t)(pc_decls_ttbitwidth[(elemtype)]);
    pc_print_addstring(dest,(uint8_t*)"(",(int64_t)-1);
    q = (uint8_t *)((*pa).ubits.ptr);
    L556 :;
    for (i=a;i<=b;i+=(int64_t)1) {
L557 :;
        pc_pcfns_pc_loadbit((byte *)(q),offset,elemtype,(int64_t)0,&v);
        offset += bitwidthx;
        if ((offset >= (int64_t)8)) {
            offset = (int64_t)0;
            ++q;
        };
        pc_print_calltostrtable(&v,fmtstr,fmt,dest);
        if ((i < b)) {
            pc_print_addstring(dest,(uint8_t*)",",(int64_t)1);
        };
L558 :;
    }L559 :;
    ;
    pc_print_addstring(dest,(uint8_t*)")",(int64_t)1);
}

void pc_print_j_tostr_e(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    int64_t i;
    int64_t j;
    int64_t first;
    struct pc_decls_varrec v;
    struct pc_decls_objrec *  s;
    if ((fmt == 0)) {
        fmt = &pc_print_defaultfmt;
    };
    pc_print_addstring(dest,(uint8_t*)"[",(int64_t)1);
    s = (*p).objptr;
    first = (int64_t)1;
    i = (int64_t)0;
    L560 :;
    while ((i < (int64_t)((uint64_t)((*s).uset.length)))) {
        if (!!(pc_support_testelem((byte (*)[])((*s).uset.ptr),i))) {
            j = (i + (int64_t)1);
            L563 :;
            while (((j < (int64_t)((uint64_t)((*s).uset.length))) && !!(pc_support_testelem((byte (*)[])((*s).uset.ptr),j)))) {
                ++j;
L564 :;
            }L565 :;
            ;
            --j;
            if (!(!!(first))) {
                pc_print_addstring(dest,(uint8_t*)",",(int64_t)1);
            };
            first = (int64_t)0;
            if ((i == j)) {
                v.tagx = (uint64_t)((int64_t)1);
                v.value = i;
            } else {
                v.tagx = (uint64_t)((int64_t)4);
                v.range_lower = i;
                v.range_upper = j;
            };
            pc_print_calltostrtable(&v,fmtstr,fmt,dest);
            i = (j + (int64_t)1);
        } else {
            ++i;
        };
L561 :;
    }L562 :;
    ;
    pc_print_addstring(dest,(uint8_t*)"]",(int64_t)1);
}

void pc_print_j_tostr_k(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    byte needcomma;
    int64_t i;
    int64_t stag;
    int64_t ftype;
    int64_t offset;
    int64_t index;
    byte *  ptr;
    struct pc_decls_varrec v;
    struct pc_decls_objrec *  pa;
    int64_t fieldtypes[100];
    int64_t fieldoffsets[100];
    int64_t nfields;
    if ((fmt == 0)) {
        fmt = &pc_print_defaultfmt;
    };
    stag = (int64_t)((*p).tag);
    index = (int64_t)(pc_decls_ttstartfield[(stag)]);
    nfields = (int64_t)(pc_decls_ttstructfields[(stag)]);
    L566 :;
    for (i=(int64_t)1;i<=nfields;i+=(int64_t)1) {
L567 :;
        fieldtypes[(((nfields - i) + (int64_t)1))-1] = (int64_t)((*pc_decls_pcfieldtable)[(((index + i) - (int64_t)1))-1].fieldtype);
        fieldoffsets[(((nfields - i) + (int64_t)1))-1] = (int64_t)((*pc_decls_pcfieldtable)[(((index + i) - (int64_t)1))-1].fieldoffset);
L568 :;
    }L569 :;
    ;
    pa = (*p).objptr;
    ptr = (*pa).ustruct.ptr;
    pc_print_addstring(dest,(uint8_t*)"(",(int64_t)-1);
    needcomma = (uint64_t)((int64_t)0);
    L570 :;
    for (i=nfields;i>=(int64_t)1;i-=(int64_t)1) {
L571 :;
        ftype = fieldtypes[(i)-1];
        offset = fieldoffsets[(i)-1];
        pc_pcfns_pc_loadpacked((void *)((ptr + offset)),ftype,&v,(struct pc_decls_objrec *)(0));
        if (!!((uint64_t)(needcomma))) {
            pc_print_addstring(dest,(uint8_t*)",",(int64_t)1);
        };
        needcomma = (uint64_t)((int64_t)1);
        pc_print_calltostrtable(&v,fmtstr,fmt,dest);
L572 :;
    }L573 :;
    ;
    pc_print_addstring(dest,(uint8_t*)")",(int64_t)1);
}

void pc_print_j_tostr_j(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    uint8_t *  s;
    s = pc_bignum_bx_tostring(p,(int64_t)0);
    pc_print_addstring(dest,s,(int64_t)-1);
    free((void *)(s));
}

void pc_print_j_tostr_d(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    struct pc_decls_varrec *  q;
    int64_t i;
    int64_t length;
    int64_t needcomma;
    struct pc_decls_objrec *  pa;
    needcomma = (int64_t)0;
    if ((fmt == 0)) {
        fmt = &pc_print_defaultfmt;
    };
    pc_print_addstring(dest,(uint8_t*)"[",(int64_t)-1);
    pa = (*p).objptr;
    q = (*pa).udict.vptr;
    length = ((int64_t)((uint64_t)((*pa).udict.length)) / (int64_t)2);
    L574 :;
    for (i=length;i>=(int64_t)1;i-=(int64_t)1) {
L575 :;
        if (((int64_t)((uint64_t)((*q).tag)) == (int64_t)0)) {
            q += (int64_t)2;
            goto L576 ;
        };
        if (!!(needcomma)) {
            pc_print_addstring(dest,(uint8_t*)",",(int64_t)1);
        };
        needcomma = (int64_t)1;
        pc_print_calltostrtable(q,fmtstr,fmt,dest);
        ++q;
        pc_print_addstring(dest,(uint8_t*)":",(int64_t)1);
        pc_print_calltostrtable(q,fmtstr,fmt,dest);
        ++q;
L576 :;
    }L577 :;
    ;
    pc_print_addstring(dest,(uint8_t*)"]",(int64_t)1);
}

void pc_print_j_tostr_z(struct pc_decls_varrec * a,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    int64_t cmd;
    uint8_t str[1024];
    switch ((int64_t)((*a).tag)) {
    case 0:;
    {
        pc_print_addstring(dest,(uint8_t*)"<Void>",(int64_t)-1);
    }break;
    case 23:;
    {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"Ref #:#");
        msysnewc_m_print_str(pc_decls_ttname[((int64_t)((*a).uref.elemtag))],NULL);
        msysnewc_m_print_ptr((*a).uref.ptr,NULL);
        msysnewc_m_print_end();
        ;
        pc_print_addstring(dest,str,(int64_t)-1);
    }break;
    case 24:;
    {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"Refbit #:# @# [*#]");
        msysnewc_m_print_str(pc_decls_ttname[((int64_t)((*a).uref.elemtag))],NULL);
        msysnewc_m_print_ptr((*a).uref.ptr,NULL);
        msysnewc_m_print_u64((*a).uref.bitoffset,NULL);
        msysnewc_m_print_u64((*a).uref.bitlength,NULL);
        msysnewc_m_print_end();
        ;
        pc_print_addstring(dest,str,(int64_t)-1);
    }break;
    case 22:;
    {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((uint8_t*)"Refvar:",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_ptr((*a).varptr,NULL);
        msysnewc_m_print_end();
        ;
        pc_print_addstring(dest,str,(int64_t)-1);
        if (!!((*a).varptr)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_setfmt((uint8_t*)" <#>");
            msysnewc_m_print_str(pc_decls_ttname[((int64_t)((*(*a).varptr).tag))],NULL);
            msysnewc_m_print_end();
            ;
            pc_print_addstring(dest,str,(int64_t)-1);
        };
    }break;
    case 25:;
    {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"Link:<#>");
        msysnewc_m_print_str(pc_decls_ttname[((int64_t)((*a).uref.elemtag))],NULL);
        msysnewc_m_print_end();
        ;
        pc_print_addstring(dest,str,(int64_t)-1);
    }break;
    case 18:;
    {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((uint8_t*)"Refproc:",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_ptr((*a).refptr,NULL);
        msysnewc_m_print_end();
        ;
        pc_print_addstring(dest,str,(int64_t)-1);
    }break;
    case 20:;
    {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((uint8_t*)"Reflabel:",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_ptr((*a).refptr,NULL);
        msysnewc_m_print_end();
        ;
        pc_print_addstring(dest,str,(int64_t)-1);
    }break;
    case 13:;
    {
        pc_print_addstring(dest,(uint8_t*)"<",(int64_t)1);
        pc_print_addstring(dest,pc_decls_ttname[((*a).value)],(int64_t)-1);
        pc_print_addstring(dest,(uint8_t*)">",(int64_t)1);
    }break;
    case 14:;
    {
        pc_print_addstring(dest,(uint8_t*)"<OP:",(int64_t)-1);
        cmd = (*a).value;
        pc_print_addstring(dest,(pq_common_cmdnames[(cmd)] + (int64_t)1),(int64_t)-1);
        pc_print_addstring(dest,(((int64_t)((uint64_t)((*a).uop.opdims)) == (int64_t)1)?(uint8_t*)":1":(uint8_t*)":2"),(int64_t)2);
        pc_print_addstring(dest,(uint8_t*)">",(int64_t)1);
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"tostr_def",a);
    }
    } //SW
;
}

static void pc_print_printnextfmtchars(int64_t lastx) {
    uint8_t c;
    uint8_t *  pstart;
    int64_t n;
    pstart = pc_print_mfmtcurr;
    n = (int64_t)0;
    L578 :;
    while (1) {
        c = (uint64_t)((*pc_print_mfmtcurr));
        switch ((int64_t)(c)) {
        case 35:;
        {
            if (!!(lastx)) {
                goto L580 ;
;
            };
            ++pc_print_mfmtcurr;
            if (!!(n)) {
                pc_print_printstr_n(pstart,n);
            };
            return;
        }break;
        case 0:;
        {
            if (!!(n)) {
                pc_print_printstr_n(pstart,n);
            } else if (!(!!(lastx))) {
                pc_print_printstr_n((uint8_t*)"|",(int64_t)1);
            };
            return;
        }break;
        case 126:;
        {
            if (!!(n)) {
                pc_print_printstr_n(pstart,n);
                n = (int64_t)0;
            };
            ++pc_print_mfmtcurr;
            c = (uint64_t)((*pc_print_mfmtcurr));
            if (!!((uint64_t)(c))) {
                ++pc_print_mfmtcurr;
                pc_print_printstr_n(&c,(int64_t)1);
            };
            pstart = pc_print_mfmtcurr;
        }break;
        default: {
            //skip:
L580 :;
;
            ++n;
            ++pc_print_mfmtcurr;
        }
        } //SW
;
    }L579 :;
    ;
}

static int64_t pc_print_getreadfmtcode(struct pc_decls_varrec * p) {
    uint8_t c;
    if (((p == 0) || ((int64_t)((uint64_t)((*p).tag)) == (int64_t)0))) {
        return (int64_t)65;
    };
    if (((int64_t)((uint64_t)((*p).tag)) != (int64_t)5)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"P=%s",NULL);
        msysnewc_m_print_str(pc_decls_ttname[((int64_t)((*p).tag))],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        pc_support_prterror((uint8_t*)"Readfmt?");
    };
    if (((int64_t)((*(*p).objptr).ustr.length) == (int64_t)0)) {
        return (int64_t)65;
    };
    c = (uint64_t)(toupper((int64_t)((int32_t)((*(*(*p).objptr).ustr.strptr)))));
    switch ((int64_t)(c)) {
    case 73:;
    case 82:;
    case 78:;
    case 83:;
    case 70:;
    case 84:;
    case 90:;
    case 67:;
    case 76:;
    case 72:;
    case 66:;
    case 65:;
    case 69:;
    {
        return (int64_t)(c);
    }break;
    default: {
    }
    } //SW
;
    pc_support_prterror((uint8_t*)"Readfmt2?");
    return (int64_t)0;
}

void pc_print_pch_sreadln(struct pc_decls_varrec * dev,struct pc_decls_varrec * dest) {
    pc_print_pch_readln(dev);
    pc_pcfns_pc_makestring(pc_print_kb_start,pc_print_kb_length,dest);
}

void pc_print_pch_strtoval(struct pc_decls_varrec * p,struct pc_decls_varrec * fmt,struct pc_decls_varrec * dest) {
    int64_t fmtcode;
    int64_t length;
    struct pc_decls_objrec *  q;
    uint8_t str[1024];
    uint8_t *  s;
    s = str;
    q = (*p).objptr;
    if (((int64_t)((*q).ustr.length) < (int64_t)1024)) {
        memcpy((void *)(s),(void *)((*q).ustr.strptr),(uint64_t)((*q).ustr.length));
        str[(((int64_t)((*q).ustr.length) + (int64_t)1))-1] = (uint64_t)0u;
    } else {
        pc_support_pcerror((uint8_t*)"STRTOVAL/string too long");
    };
    fmtcode = pc_print_getreadfmtcode(fmt);
    if (((int64_t)((uint64_t)((*p).tag)) != (int64_t)5)) {
        pc_support_prterror((uint8_t*)"strval");
    };
    length = (int64_t)((*(*p).objptr).ustr.length);
    switch (fmtcode) {
    case 73:;
    {
        pc_print_readint(s,length,dest);
    }break;
    case 82:;
    {
        pc_print_readreal(s,length,dest);
    }break;
    case 78:;
    {
        pc_print_readname(s,length,dest);
    }break;
    case 83:;
    {
        pc_print_readstring(s,length,dest);
    }break;
    case 72:;
    {
        pc_print_readhex(s,length,dest);
    }break;
    case 66:;
    {
        pc_print_readbin(s,length,dest);
    }break;
    case 65:;
    {
        pc_print_readany(s,length,dest);
    }break;
    default: {
        pc_support_prterror((uint8_t*)"strval:fmt?");
    }
    } //SW
;
}

void pc_print_pch_reread(void) {
    pc_print_kb_pos = pc_print_kb_lastpos;
    pc_print_kb_length = pc_print_kb_lastlength;
}

void pc_print_pch_rereadln(void) {
    pc_print_kb_pos = pc_print_kb_start;
    pc_print_kb_length = pc_print_kb_linelength;
}

static uint8_t * pc_print_readname(uint8_t * s,int64_t length,struct pc_decls_varrec * dest) {
    uint8_t *  send;
    uint8_t *  itemstr;
    int64_t itemlength;
    send = pc_print_readitem(s,length,&itemstr,&itemlength);
    pc_pcfns_pc_makestring(itemstr,itemlength,dest);
    mlib_iconvlcn((*(*dest).objptr).ustr.strptr,(int64_t)((*(*dest).objptr).ustr.length));
    return send;
}

static uint8_t * pc_print_readstring(uint8_t * s,int64_t length,struct pc_decls_varrec * dest) {
    uint8_t *  send;
    uint8_t *  itemstr;
    int64_t itemlength;
    send = pc_print_readitem(s,length,&itemstr,&itemlength);
    pc_pcfns_pc_makestring(itemstr,itemlength,dest);
    return send;
}

static uint8_t * pc_print_readint(uint8_t * sold,int64_t length,struct pc_decls_varrec * dest) {
    uint8_t *  s;
    uint8_t *  send;
    int64_t itemlength;
    send = pc_print_readitem(sold,length,&s,&itemlength);
    pc_print_strtoint(s,itemlength,dest);
    return send;
}

static uint8_t * pc_print_readhex(uint8_t * sold,int64_t length,struct pc_decls_varrec * dest) {
    uint8_t str[256];
    uint8_t *  p;
    uint8_t *  s;
    int64_t aa;
    int64_t t;
    int64_t nalloc;
    uint8_t c;
    if ((length == (int64_t)0)) {
        (*dest).tagx = (uint64_t)((int64_t)1);
        (*dest).value = (int64_t)0;
        pc_print_termchar = (uint64_t)0u;
        return sold;
    };
    L581 :;
    while ((!!(length) && (((uint64_t)((*sold)) == ' ') || ((int64_t)((*sold)) == (int64_t)9)))) {
        ++sold;
        --length;
L582 :;
    }L583 :;
    ;
    if ((length <= (int64_t)256)) {
        s = str;
        nalloc = (int64_t)0;
    } else {
        nalloc = (length + (int64_t)1);
        s = (uint8_t *)(mlib_pcm_alloc(nalloc));
    };
    p = s;
    L584 :;
    while (!!(length)) {
        c = (uint64_t)(toupper((int64_t)((int32_t)((*sold)))));
        ++sold;
        --length;
        if ((((uint64_t)(c) >= '0') && ((uint64_t)(c) <= '9'))) {
            (*p) = (uint64_t)(c);
            ++p;
        } else if ((((uint64_t)(c) >= 'A') && ((uint64_t)(c) <= 'F'))) {
            (*p) = (uint64_t)(c);
            ++p;
        } else if (((uint64_t)(c) == '_')) {
        } else {
            pc_print_termchar = (uint64_t)(c);
            goto L586 ;
        };
L585 :;
    }L586 :;
    ;
    (*p) = (uint64_t)0u;
    length = (p - s);
    if ((length <= (int64_t)16)) {
        t = (int64_t)1;
    } else {
        t = (int64_t)7;
    };
    p = s;
    switch (t) {
    case 1:;
    {
        aa = (int64_t)0;
        L587 :;
        while (1) {
            c = (uint64_t)((*p));
            ++p;
            if (((int64_t)(c) == (int64_t)0)) {
                goto L588 ;
            };
            if (((uint64_t)(c) < 'A')) {
                aa = (((aa * (int64_t)16) + (int64_t)(c)) - (int64_t)48);
            } else {
                aa = (((aa * (int64_t)16) + ((uint64_t)(c) - 'A')) + (int64_t)10);
            };
        }L588 :;
        ;
        (*dest).tagx = (uint64_t)((int64_t)1);
        (*dest).value = aa;
    }break;
    default: {
        pc_support_prterror((uint8_t*)"Readhex/long");
    }
    } //SW
;
    if (!!(nalloc)) {
        mlib_pcm_free((void *)(s),nalloc);
    };
    return sold;
}

static uint8_t * pc_print_readbin(uint8_t * sold,int64_t length,struct pc_decls_varrec * dest) {
    uint8_t str[256];
    uint8_t *  p;
    uint8_t *  s;
    int64_t aa;
    int64_t t;
    int64_t nalloc;
    uint8_t c;
    if ((length == (int64_t)0)) {
        (*dest).tagx = (uint64_t)((int64_t)1);
        (*dest).value = (int64_t)0;
        pc_print_termchar = (uint64_t)0u;
        return sold;
    };
    L589 :;
    while ((!!(length) && (((uint64_t)((*sold)) == ' ') || ((int64_t)((*sold)) == (int64_t)9)))) {
        ++sold;
        --length;
L590 :;
    }L591 :;
    ;
    if ((length <= (int64_t)256)) {
        s = str;
        nalloc = (int64_t)0;
    } else {
        nalloc = (length + (int64_t)1);
        s = (uint8_t *)(mlib_pcm_alloc(nalloc));
    };
    p = s;
    L592 :;
    while (!!(length)) {
        c = (uint64_t)(toupper((int64_t)((int32_t)((*sold)))));
        ++sold;
        --length;
        if ((((uint64_t)(c) >= '0') && ((uint64_t)(c) <= '1'))) {
            (*p) = (uint64_t)(c);
            ++p;
        } else if (((uint64_t)(c) == '_')) {
        } else {
            pc_print_termchar = (uint64_t)(c);
            goto L594 ;
        };
L593 :;
    }L594 :;
    ;
    (*p) = (uint64_t)0u;
    length = (p - s);
    if ((length <= (int64_t)64)) {
        t = (int64_t)1;
    } else {
        t = (int64_t)7;
    };
    p = s;
    switch (t) {
    case 1:;
    {
        aa = (int64_t)0;
        L595 :;
        while (1) {
            c = (uint64_t)((*p));
            ++p;
            if (((int64_t)(c) == (int64_t)0)) {
                goto L596 ;
            };
            aa = (((aa * (int64_t)2) + (int64_t)(c)) - (int64_t)48);
        }L596 :;
        ;
        (*dest).tagx = (uint64_t)((int64_t)1);
        (*dest).value = aa;
    }break;
    default: {
        pc_support_prterror((uint8_t*)"Readbin/long");
    }
    } //SW
;
    if (!!(nalloc)) {
        mlib_pcm_free((void *)(s),nalloc);
    };
    return sold;
}

static uint8_t * pc_print_readreal(uint8_t * sold,int64_t length,struct pc_decls_varrec * dest) {
    uint8_t *  send;
    uint8_t *  itemstr;
    int64_t itemlength;
    send = pc_print_readitem(sold,length,&itemstr,&itemlength);
    pc_print_strtoreal(itemstr,itemlength,dest);
    return send;
}

void pc_print_pch_readln(struct pc_decls_varrec * dev) {
    void *  ch;
    int64_t length;
    struct pc_decls_objrec *  pdev;
    if ((pc_print_kb_start == 0)) {
        pc_print_kb_start = (uint8_t *)(mlib_pcm_alloc((int64_t)1048576));
        pc_print_kb_size = (int64_t)1048576;
        pc_print_kb_lastpos = pc_print_kb_start;
        pc_print_kb_pos = pc_print_kb_start;
        pc_print_kb_length = (int64_t)0;
        pc_print_kb_lastlength = (int64_t)0;
        pc_print_kb_linelength = (int64_t)0;
    };
    switch ((int64_t)((*dev).tag)) {
    case 0:;
    {
        //doconsole:
L597 :;
;
        mlib_readlinen(0,pc_print_kb_start,pc_print_kb_size);
        pc_print_kb_length = (int64_t)(strlen((int8_t *)(pc_print_kb_start)));
    }break;
    case 1:;
    {
        switch ((*dev).value) {
        case 0:;
        {
            goto L597 ;
;
        }break;
        case 1:;
        {
            if ((pc_print_testfilech == 0)) {
                pc_support_prterror((uint8_t*)"R@2: file not open");
            };
            ch = pc_print_testfilech;
        }break;
        default: {
            ch = (void *)((*dev).value);
        }
        } //SW
;
        pc_print_pc_readlinen(ch,pc_print_kb_start,pc_print_kb_size);
        pc_print_kb_length = (int64_t)(strlen((int8_t *)(pc_print_kb_start)));
    }break;
    case 5:;
    {
        pdev = (*dev).objptr;
        length = (int64_t)((*pdev).ustr.length);
        if ((length == (int64_t)0)) {
            pc_print_kb_length = (int64_t)0;
            (*pc_print_kb_start) = (uint64_t)0u;
        } else if ((length >= pc_print_kb_size)) {
            pc_support_prterror((uint8_t*)"KB overflow");
        } else {
            pc_print_kb_length = length;
            memcpy((void *)(pc_print_kb_start),(void *)((*pdev).ustr.strptr),(uint64_t)(length));
        };
    }break;
    default: {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(pc_support_gettypename((int64_t)((*dev).tag)),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        pc_support_prterror((uint8_t*)"readln@");
    }
    } //SW
;
    pc_print_kb_pos = pc_print_kb_start;
    pc_print_kb_lastpos = pc_print_kb_pos;
    pc_print_kb_linelength = pc_print_kb_length;
}

static void pc_print_stepkbpos(uint8_t * s) {
    int64_t newlen;
    newlen = (s - pc_print_kb_pos);
    if ((newlen == (int64_t)0)) {
        return;
    };
    if ((newlen >= pc_print_kb_length)) {
        pc_print_kb_pos = (pc_print_kb_pos + pc_print_kb_length);
        pc_print_kb_length = (int64_t)0;
    } else {
        pc_print_kb_pos = (pc_print_kb_pos + newlen);
        pc_print_kb_length -= newlen;
    };
}

void pc_print_pch_sread(struct pc_decls_varrec * fmt,struct pc_decls_varrec * dest) {
    int64_t fmtcode;
    fmtcode = pc_print_getreadfmtcode(fmt);
    pc_print_kb_lastpos = pc_print_kb_pos;
    pc_print_kb_lastlength = pc_print_kb_length;
    switch (fmtcode) {
    case 73:;
    {
        pc_print_stepkbpos(pc_print_readint(pc_print_kb_pos,pc_print_kb_length,dest));
    }break;
    case 82:;
    {
        pc_print_stepkbpos(pc_print_readreal(pc_print_kb_pos,pc_print_kb_length,dest));
    }break;
    case 78:;
    {
        pc_print_stepkbpos(pc_print_readname(pc_print_kb_pos,pc_print_kb_length,dest));
    }break;
    case 83:;
    {
        pc_print_stepkbpos(pc_print_readstring(pc_print_kb_pos,pc_print_kb_length,dest));
    }break;
    case 72:;
    {
        pc_print_stepkbpos(pc_print_readhex(pc_print_kb_pos,pc_print_kb_length,dest));
    }break;
    case 66:;
    {
        pc_print_stepkbpos(pc_print_readbin(pc_print_kb_pos,pc_print_kb_length,dest));
    }break;
    case 65:;
    {
        pc_print_stepkbpos(pc_print_readany(pc_print_kb_pos,pc_print_kb_length,dest));
    }break;
    case 76:;
    {
        if ((pc_print_kb_length == (int64_t)0)) {
            pc_pcfns_pc_emptystring(dest);
        } else {
            pc_pcfns_pc_makestring(pc_print_kb_pos,pc_print_kb_length,dest);
            pc_print_kb_pos += pc_print_kb_length;
            pc_print_kb_length = (int64_t)0;
        };
    }break;
    case 67:;
    {
        if ((pc_print_kb_length == (int64_t)0)) {
            pc_pcfns_pc_emptystring(dest);
        } else {
            pc_print_termchar = (uint64_t)((*pc_print_kb_pos));
            //dochar:
L598 :;
;
            (*dest).tagx = (uint64_t)((int64_t)1);
            (*dest).value = (int64_t)(pc_print_termchar);
            ++pc_print_kb_pos;
            --pc_print_kb_length;
        };
    }break;
    case 90:;
    {
        goto L598 ;
;
    }break;
    case 69:;
    {
        (*dest).tagx = (uint64_t)((int64_t)1);
        (*dest).value = pc_print_itemerror;
    }break;
    default: {
        pc_support_prterror((uint8_t*)"SREAD/FMT?");
    }
    } //SW
;
}

static void pc_print_domultichar(uint8_t * p,int64_t n,uint8_t * dest,struct pc_decls_fmtrec * fmt) {
    uint8_t str[20];
    uint8_t *  q;
    int64_t nchars;
    int64_t av_1;
    q = str;
    nchars = n;
    av_1 = n;
    while (av_1-- > 0) {
L599 :;
        if (((int64_t)((*p)) == (int64_t)0)) {
            goto L601 ;
        };
        (*q) = (uint64_t)((*p));
        ++q;
        ++p;
L600 :;
    }L601 :;
    ;
    (*q) = (uint64_t)0u;
    pc_print_expandstr(str,dest,nchars,fmt);
}

void pc_print_pch_tostr(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result) {
    struct pc_decls_fmtrec fmt;
    struct pc_decls_fmtrec *  ifmt;
    struct pc_decls_objrec *  p;
    ifmt = pc_print_pc_getfmt(b,&fmt);
    p = pc_objlib_obj_new((int64_t)5);
    (*p).ustr.mutable = (uint64_t)((int64_t)1);
    pc_print_listdepth = (int64_t)0;
    pc_print_calltostrtable(a,b,ifmt,p);
    (*result).tagx = (uint64_t)((int64_t)65541);
    (*result).objptr = p;
}

struct pc_decls_fmtrec * pc_print_pc_getfmt(struct pc_decls_varrec * p,struct pc_decls_fmtrec * fmt) {
    if (((p == 0) || ((int64_t)((uint64_t)((*p).tag)) == (int64_t)0))) {
        return &pc_print_defaultfmt;
    } else {
        if (((int64_t)((uint64_t)((*p).tag)) != (int64_t)5)) {
            pc_support_prterror((uint8_t*)"pc_getfmt/not str?");
        };
        if (((*(*p).objptr).ustr.strptr == 0)) {
            return &pc_print_defaultfmt;
        } else {
            pc_print_pc_strtofmt((*(*p).objptr).ustr.strptr,(int64_t)((*(*p).objptr).ustr.length),fmt);
            return fmt;
        };
    };
}

static void pc_print_pc_readlinen(void * handlex,uint8_t * buffer,int64_t size) {
    uint8_t *  p;
    int64_t n;
    byte crseen;
    (*buffer) = (uint64_t)0u;
    fgets((int8_t *)(buffer),(size - (int64_t)2),handlex);
    n = (int64_t)(strlen((int8_t *)(buffer)));
    if ((n == (int64_t)0)) {
        return;
    };
    p = ((buffer + n) - (int64_t)1);
    crseen = (uint64_t)((int64_t)0);
    L602 :;
    while (((p >= buffer) && (((int64_t)((*p)) == (int64_t)13) || ((int64_t)((*p)) == (int64_t)10)))) {
        if ((((int64_t)((*p)) == (int64_t)13) || ((int64_t)((*p)) == (int64_t)10))) {
            crseen = (uint64_t)((int64_t)1);
        };
        (*p--) = (uint64_t)0u;
L603 :;
    }L604 :;
    ;
    if ((!(!!((uint64_t)(crseen))) && ((n + (int64_t)4) > size))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_i64(size,NULL);
        msysnewc_m_print_i64(n,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mlib_abortprogram((uint8_t*)"line too long");
    };
}

static uint8_t * pc_print_readitem(uint8_t * s,int64_t length,uint8_t * * itemstr,int64_t * itemlength) {
    uint8_t *  p;
    uint8_t quotechar;
    uint8_t c;
    L605 :;
    while ((!!(length) && (((uint64_t)((*s)) == ' ') || ((int64_t)((*s)) == (int64_t)9)))) {
        ++s;
        --length;
L606 :;
    }L607 :;
    ;
    (*itemstr) = s;
    if ((length == (int64_t)0)) {
        pc_print_termchar = (uint64_t)0u;
        (*itemlength) = (int64_t)0;
        return s;
    };
    quotechar = (uint64_t)0u;
    if (((uint64_t)((*s)) == '"')) {
        quotechar = '"';
        ++s;
        --length;
    } else if (((uint64_t)((*s)) == (uint64_t)39u)) {
        quotechar = (uint64_t)39u;
        ++s;
        --length;
    };
    p = ((*itemstr) = s);
    L608 :;
    while (!!(length)) {
        c = (uint64_t)((*s++));
        --length;
        switch ((int64_t)(c)) {
        case 32:;
        case 9:;
        case 44:;
        case 61:;
        {
            if ((!!((uint64_t)(quotechar)) || (p == s))) {
                goto L611 ;
;
            };
            pc_print_termchar = (uint64_t)(c);
            goto L610 ;
        }break;
        default: {
            //normalchar:
L611 :;
;
            if (((uint64_t)(c) == (uint64_t)(quotechar))) {
                if ((!!(length) && ((uint64_t)((*s)) == (uint64_t)(quotechar)))) {
                    (*p) = (uint64_t)(c);
                    ++s;
                    ++p;
                } else {
                    pc_print_termchar = (uint64_t)((*s));
                    if ((((uint64_t)(pc_print_termchar) == ',') || ((uint64_t)(pc_print_termchar) == '='))) {
                        ++s;
                        pc_print_termchar = (uint64_t)((*s));
                    };
                    goto L610 ;
                };
            } else {
                (*p) = (uint64_t)(c);
                ++p;
            };
        }
        } //SW
;
L609 :;
    }L610 :;
    ;
    if ((length == (int64_t)0)) {
        pc_print_termchar = (uint64_t)0u;
    };
    (*itemlength) = (p - (*itemstr));
    return s;
}

static uint8_t * pc_print_readany(uint8_t * sold,int64_t length,struct pc_decls_varrec * dest) {
    uint8_t *  p;
    uint8_t *  s;
    int64_t digits;
    int64_t expon;
    int64_t other;
    uint8_t *  send;
    int64_t itemlength;
    int64_t av_1;
    pc_print_itemerror = (int64_t)0;
    send = pc_print_readitem(sold,length,&s,&itemlength);
    p = s;
    digits = (expon = (other = (int64_t)0));
    av_1 = itemlength;
    while (av_1-- > 0) {
L612 :;
        switch ((int64_t)((*p++))) {
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        case 43:;
        case 45:;
        case 95:;
        {
            digits = (int64_t)1;
        }break;
        case 69:;
        case 101:;
        case 46:;
        {
            expon = (int64_t)1;
        }break;
        default: {
            other = (int64_t)1;
        }
        } //SW
;
L613 :;
    }L614 :;
    ;
    (*dest).tagx = (uint64_t)((int64_t)1);
    if ((!!(other) || (itemlength == (int64_t)0))) {
        (*dest).value = (int64_t)5395539;
        pc_pcfns_pc_makestring(s,itemlength,dest);
    } else if (!!(expon)) {
        pc_print_strtoreal(s,itemlength,dest);
    } else {
        pc_print_strtoint(s,itemlength,dest);
    };
    return send;
}

static void pc_print_strtoreal(uint8_t * s,int64_t length,struct pc_decls_varrec * dest) {
    uint8_t str[512];
    double x;
    int32_t numlength;
    (*dest).tagx = (uint64_t)((int64_t)3);
    if (((length >= (int64_t)512) || (length == (int64_t)0))) {
        (*dest).xvalue = (double)0.;
        return;
    };
    memcpy((void *)(str),(void *)(s),(uint64_t)(length));
    str[((length + (int64_t)1))-1] = (uint64_t)0u;
    pc_print_itemerror = (int64_t)0;
    if ((((int64_t)(sscanf((int8_t *)(str),(int8_t *)((uint8_t*)"%lf%n"),&x,&numlength)) == (int64_t)0) || ((int64_t)(numlength) != length))) {
        if (((int64_t)(numlength) == length)) {
            x = (double)0.;
        };
        pc_print_itemerror = (int64_t)1;
    };
    (*dest).xvalue = x;
}

static void pc_print_strtoint(uint8_t * s,int64_t length,struct pc_decls_varrec * dest) {
    uint8_t *  p;
    uint8_t *  q;
    byte signd;
    int64_t aa;
    int64_t cat;
    int64_t t;
    uint8_t c;
    pc_print_itemerror = (int64_t)0;
    if ((length == (int64_t)0)) {
        (*dest).tagx = (uint64_t)((int64_t)1);
        (*dest).value = (int64_t)0;
        return;
    };
    signd = (uint64_t)((int64_t)0);
    if ((!!(length) && ((uint64_t)((*s)) == '-'))) {
        signd = (uint64_t)((int64_t)1);
        ++s;
        --length;
    } else if ((!!(length) && ((uint64_t)((*s)) == '+'))) {
        ++s;
        --length;
    };
    L615 :;
    while ((((uint64_t)((*s)) == '0') && (length > (int64_t)1))) {
        ++s;
        --length;
L616 :;
    }L617 :;
    ;
    p = (q = s);
    L618 :;
    while (!!(length)) {
        c = (uint64_t)((*q++));
        --length;
        if ((((uint64_t)(c) >= '0') && ((uint64_t)(c) <= '9'))) {
            (*p) = (uint64_t)(c);
            ++p;
        } else {
            if (((uint64_t)(c) == '_')) {
            } else {
                pc_print_itemerror = (int64_t)1;
                goto L620 ;
            };
        };
L619 :;
    }L620 :;
    ;
    (*p) = (uint64_t)0u;
    length = (p - s);
    if ((length <= (int64_t)18)) {
        cat = (int64_t)65;
    } else if ((length == (int64_t)19)) {
        if ((mlib_cmpstring(s,(uint8_t*)"9223372036854775808")==(int64_t)-1)) {
            cat = (int64_t)65;
        }else if ((mlib_cmpstring(s,(uint8_t*)"9223372036854775808")==(int64_t)0)) {
            cat = (int64_t)66;
        } else {
            cat = (int64_t)67;
        };
    } else if ((length == (int64_t)20)) {
        if ((mlib_cmpstring(s,(uint8_t*)"18446744073709551615") <= (int64_t)0)) {
            cat = (int64_t)67;
        } else {
            cat = (int64_t)68;
        };
    } else {
        cat = (int64_t)68;
    };
    if (!!((uint64_t)(signd))) {
        if ((cat==(int64_t)66)) {
            cat = (int64_t)65;
        }else if ((cat==(int64_t)67)) {
            cat = (int64_t)68;
        };
    };
    if ((cat==(int64_t)65)) {
        t = (int64_t)1;
    }else if ((cat==(int64_t)66) || (cat==(int64_t)67)) {
        t = (int64_t)2;
    } else {
        t = (int64_t)7;
    };
    p = s;
    if ((t != (int64_t)7)) {
        aa = (int64_t)0;
        L621 :;
        while (1) {
            c = (uint64_t)((*p));
            ++p;
            if (((int64_t)(c) == (int64_t)0)) {
                goto L622 ;
            };
            aa = ((aa * (int64_t)10) + ((uint64_t)(c) - '0'));
        }L622 :;
        ;
        if (!!((uint64_t)(signd))) {
            aa = -(aa);
        };
        (*dest).tagx = (uint64_t)(t);
        (*dest).value = aa;
    } else {
        pc_bignum_bx_makestr(s,length,dest);
    };
}

static void pc_print_calltostrtable(struct pc_decls_varrec * q,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    struct pc_decls_varrec v;
    pc_decls_overloadtype = (int64_t)((*q).tag);
    if (((int64_t)((uint64_t)((*fmtstr).tag)) == (int64_t)0)) {
        pc_pcfns_pc_emptystring(&v);
        fmtstr = &v;
    };
    ((*pc_decls_tostr_table[(pc_decls_overloadtype)]))(q,fmtstr,fmt,dest);
}

static uint8_t * pc_print_printbn(struct pc_decls_varrec * a0,struct pc_decls_fmtrec * fmt,int64_t * length) {
    static struct mlib_strbuffer destx;
    static struct mlib_strbuffer *  dest = &destx;
    pc_support_pcerror((uint8_t*)"PRINTBN");
    return (uint8_t*)"XXX";
}

void pc_jhandlers_initcalltables(void) {
    int64_t n;
    int64_t i;
    int64_t j;
    int64_t slen;
    uint8_t *  name;
    void *  fnaddr;
    void * (*stable)[];
    void * (*dtable)[];
    byte localmixedmap[301];
    int64_t av_1;
    pc_jhandlers_mixedmap = &localmixedmap;
    memset((void *)(pc_jhandlers_mixedmap),(int64_t)0,(uint64_t)((int64_t)301));
    n = msysnewc_m_get_nprocs();
    L623 :;
    for (i=(int64_t)1;i<=n;i+=(int64_t)1) {
L624 :;
        name = msysnewc_m_get_procname(i);
        if ((((uint64_t)((*name)) == 'j') && ((uint64_t)((*(name + (int64_t)1))) == '_'))) {
            pc_jhandlers_initjhandler(name,msysnewc_m_get_procaddr(i));
        };
L625 :;
    }L626 :;
    ;
    L627 :;
    for (i=(int64_t)1;i<=(int64_t)66;i+=(int64_t)1) {
L628 :;
        stable = (void * (*)[])(pc_jhandlers_singletable[(i)-1]);
        dtable = (void * (*)[])(pc_jhandlers_doubletable[(i)-1]);
        if (!!(stable)) {
            fnaddr = (*stable)[((int64_t)0)];
            if ((fnaddr == 0)) {
                fnaddr = (void *)(&pc_jhandlers_def_handler);
            };
            L631 :;
            for (j=(int64_t)0;j<=(int64_t)300;j+=(int64_t)1) {
L632 :;
                if (((*stable)[(j)] == 0)) {
                    (*stable)[(j)] = fnaddr;
                };
L633 :;
            }L634 :;
            ;
        };
        if (!!(dtable)) {
            fnaddr = (*dtable)[((int64_t)0)];
            if ((fnaddr == 0)) {
                fnaddr = (void *)(&pc_jhandlers_ddef_handler);
            };
            L635 :;
            for (j=(int64_t)0;j<=(int64_t)300;j+=(int64_t)1) {
L636 :;
                if (((*dtable)[(j)] == 0)) {
                    if (!!((uint64_t)(localmixedmap[(j)]))) {
                        name = pc_jhandlers_tabnames[(i)-1];
                        slen = (int64_t)(strlen((int8_t *)(name)));
                        if (!!(mlib_eqstring(((name + slen) - (int64_t)2),(uint8_t*)"to"))) {
                            goto L639 ;
;
                        };
                        (*dtable)[(j)] = (void *)(pc_decls_mixed_dtable[(j)]);
                    } else {
                        //donormal:
L639 :;
;
                        (*dtable)[(j)] = fnaddr;
                    };
                };
L637 :;
            }L638 :;
            ;
        };
L629 :;
    }L630 :;
    ;
}

static void pc_jhandlers_initjhandler(uint8_t * p,void * fnaddr) {
    uint8_t opname[32];
    uint8_t *  q;
    uint8_t c;
    uint8_t d;
    int64_t t;
    int64_t u;
    int64_t i;
    void * (*stable)[];
    void * (*dtable)[];
    int64_t av_1;
    p += (int64_t)2;
    q = p;
    L640 :;
    while ((((uint64_t)((*q)) != '_') && ((int64_t)((*q)) != (int64_t)0))) {
        ++q;
L641 :;
    }L642 :;
    ;
    memcpy((void *)(opname),(void *)(p),(uint64_t)((q - p)));
    opname[(((q - p) + (int64_t)1))-1] = (uint64_t)0u;
    if (((int64_t)((*q)) == (int64_t)0)) {
        return;
    };
    L643 :;
    for (i=(int64_t)1;i<=(int64_t)66;i+=(int64_t)1) {
L644 :;
        if (!!(mlib_eqstring(pc_jhandlers_tabnames[(i)-1],opname))) {
            stable = (void * (*)[])(pc_jhandlers_singletable[(i)-1]);
            dtable = (void * (*)[])(pc_jhandlers_doubletable[(i)-1]);
            goto L646 ;
        };
L645 :;
    }
    {
        pc_support_loaderror((uint8_t*)"Init: Can't find Jhandler op:",opname);
        exit(0);
    }L646 :;
    ;
    L647 :;
    while (((uint64_t)((*q)) == '_')) {
        c = (uint64_t)((*++q));
        if ((((uint64_t)(c) < 'a') || ((uint64_t)(c) > 'z'))) {
            return;
        };
        d = (uint64_t)((*++q));
        if ((((uint64_t)(d) >= 'a') && ((uint64_t)(d) <= 'z'))) {
            ++q;
        } else {
            d = (uint64_t)0u;
        };
        t = (int64_t)(pc_jhandlers_typemap[((int64_t)(c))-97]);
        if (!!((uint64_t)(d))) {
            u = (int64_t)(pc_jhandlers_typemap[((int64_t)(d))-97]);
        } else {
            u = (int64_t)0;
        };
        if (!!((uint64_t)(d))) {
            if ((dtable == 0)) {
                pc_support_loaderror((uint8_t*)"No d-calltable for:",(p - (int64_t)2));
            };
            pc_jhandlers_add_dtable_entry((uint64_t * (*(*)[])(void))(dtable),t,u,fnaddr);
        } else {
            if ((stable == 0)) {
                pc_support_loaderror((uint8_t*)"No s-calltable for:",(p - (int64_t)2));
            };
            pc_jhandlers_add_stable_entry(stable,t,fnaddr);
        };
L648 :;
    }L649 :;
    ;
}

static void pc_jhandlers_add_stable_entry(void * (*table)[],int64_t t,void * fnaddr) {
    if ((t == (int64_t)35)) {
        t = (int64_t)0;
    };
    (*table)[(t)] = fnaddr;
}

static void pc_jhandlers_add_dtable_entry(uint64_t * (*(*table)[])(void),int64_t s,int64_t t,void * fnaddr) {
    int64_t typesig;
    if ((s == (int64_t)35)) {
        typesig = (int64_t)0;
    } else {
        typesig = pc_support_gettypesig(s,t);
        if (((int64_t)(table) == (int64_t)(&pc_decls_mixed_dtable))) {
            (*pc_jhandlers_mixedmap)[(typesig)] = (uint64_t)((int64_t)1);
        };
    };
    (*table)[(typesig)] = (uint64_t * (*)(void))(fnaddr);
}

static void pc_jhandlers_def_handler(void) {
    pc_support_pcerror((uint8_t*)"Single disp: no handler");
}

static void pc_jhandlers_ddef_handler(void) {
    pc_support_pcerror((uint8_t*)"Double disp: no handler");
}

int64_t * pc_jhandlers_j_add_i_w(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).value += (*y).value;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_add_r(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).xvalue += (*y).xvalue;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_add_s(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64_t xlen;
    int64_t ylen;
    int64_t newlen;
    uint8_t *  s;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    xlen = (int64_t)((*(*x).objptr).ustr.length);
    ylen = (int64_t)((*(*y).objptr).ustr.length);
    if ((xlen == (int64_t)0)) {
        if (!!(ylen)) {
            (*pc_decls_sptr) = (*y);
        };
    } else if ((ylen == (int64_t)0)) {
    } else {
        newlen = (xlen + ylen);
        s = (uint8_t *)(mlib_pcm_alloc(newlen));
        memcpy((void *)(s),(void *)((*(*x).objptr).ustr.strptr),(uint64_t)(xlen));
        memcpy((void *)((s + xlen)),(void *)((*(*y).objptr).ustr.strptr),(uint64_t)(ylen));
        pc_pcfns_pc_unshare(x);
        pc_pcfns_pc_unshare(y);
        pc_pcfns_pc_makestringx(s,newlen,mlib_allocbytes,pc_decls_sptr);
    };
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_add_j(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    struct pc_decls_varrec result;
    y = pc_decls_sptr++;
    x = pc_decls_sptr;
    pc_bignum_bx_add(x,y,&result);
    pc_pcfns_pc_unshare(x);
    pc_pcfns_pc_unshare(y);
    (*pc_decls_sptr) = result;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_add_e(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    pc_dxfns_dx_iorset(x,y);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_add_z(void) {
    pc_support_pcmxtypes((uint8_t*)"add_def",(pc_decls_sptr + (int64_t)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_add_iw_wi(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).value += (*y).value;
    (*pc_decls_sptr).tag = (uint64_t)((int64_t)1);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_add_zz(void) {
    struct pc_decls_varrec *  y;
    int64_t yt;
    y = pc_decls_sptr++;
    yt = (int64_t)((*y).tag);
    switch ((int64_t)((*pc_decls_sptr).tag)) {
    case 23:;
    {
        switch (yt) {
        case 1:;
        {
            (*pc_decls_sptr).uref.ptr = ((*pc_decls_sptr).uref.ptr + ((*y).value * pc_decls_ttsize[((int64_t)((*pc_decls_sptr).uref.elemtag))]));
            return (pc_decls_pcptr + (int64_t)1);
        }break;
        default: {
        }
        } //SW
;
    }break;
    case 22:;
    {
        switch (yt) {
        case 1:;
        {
            (*pc_decls_sptr).varptr = ((*pc_decls_sptr).varptr + (*y).value);
            return (pc_decls_pcptr + (int64_t)1);
        }break;
        default: {
        }
        } //SW
;
    }break;
    default: {
    }
    } //SW
;
    pc_support_pcmxtypes((uint8_t*)"add/mixed_def",pc_decls_sptr,y);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_sub_i_w(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).value -= (*y).value;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_sub_r(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).xvalue -= (*y).xvalue;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_sub_p(void) {
    struct pc_decls_varrec *  y;
    byte *  p;
    byte *  q;
    int64_t elemsize;
    y = pc_decls_sptr++;
    p = (*pc_decls_sptr).uref.ptr;
    q = (*y).uref.ptr;
    if (((elemsize = pc_decls_ttsize[((int64_t)((*pc_decls_sptr).uref.elemtag))])==(int64_t)1)) {
        (*pc_decls_sptr).value = (p - q);
    }else if (((elemsize = pc_decls_ttsize[((int64_t)((*pc_decls_sptr).uref.elemtag))])==(int64_t)2)) {
        (*pc_decls_sptr).value = ((p - q) >> (int64_t)1);
    }else if (((elemsize = pc_decls_ttsize[((int64_t)((*pc_decls_sptr).uref.elemtag))])==(int64_t)4)) {
        (*pc_decls_sptr).value = ((p - q) >> (int64_t)2);
    } else {
        (*pc_decls_sptr).value = ((p - q) / elemsize);
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_sub_j(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    struct pc_decls_varrec result;
    y = pc_decls_sptr++;
    x = pc_decls_sptr;
    pc_bignum_bx_sub(x,y,&result);
    pc_pcfns_pc_unshare(x);
    pc_pcfns_pc_unshare(y);
    (*pc_decls_sptr) = result;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_sub_e(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    pc_dxfns_dx_subset(x,y);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_sub_z(void) {
    pc_support_pcmxtypes((uint8_t*)"sub_def",(pc_decls_sptr + (int64_t)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_sub_zz(void) {
    struct pc_decls_varrec *  y;
    int64_t yt;
    y = pc_decls_sptr++;
    yt = (int64_t)((*y).tag);
    switch ((int64_t)((*pc_decls_sptr).tag)) {
    case 23:;
    {
        switch (yt) {
        case 1:;
        {
            (*pc_decls_sptr).uref.ptr = ((*pc_decls_sptr).uref.ptr - ((*y).value * pc_decls_ttsize[((int64_t)((*pc_decls_sptr).uref.elemtag))]));
            return (pc_decls_pcptr + (int64_t)1);
        }break;
        default: {
        }
        } //SW
;
    }break;
    case 22:;
    {
        switch (yt) {
        case 1:;
        {
            (*pc_decls_sptr).varptr = ((*pc_decls_sptr).varptr - (*y).value);
            return (pc_decls_pcptr + (int64_t)1);
        }break;
        default: {
        }
        } //SW
;
    }break;
    default: {
    }
    } //SW
;
    pc_support_pcmxtypes((uint8_t*)"sub/mixed_def",pc_decls_sptr,y);
    return (pc_decls_pcptr + (int64_t)1);
}

static int64_t * pc_jhandlers_j_mixed_iw_wi(void) {
    (*pc_decls_sptr).tag = (uint64_t)((int64_t)1);
    return ((*(*pc_decls_opc_tableptr)[((int64_t)1)]))();
}

static int64_t * pc_jhandlers_j_mixed_ir(void) {
    struct pc_decls_varrec *  x;
    x = (pc_decls_sptr + (int64_t)1);
    (*x).tag = (uint64_t)((int64_t)3);
    (*x).xvalue = (double)((*x).value);
    return ((*(*pc_decls_opc_tableptr)[((int64_t)3)]))();
}

static int64_t * pc_jhandlers_j_mixed_ri(void) {
    (*pc_decls_sptr).tag = (uint64_t)((int64_t)3);
    (*pc_decls_sptr).xvalue = (double)((*pc_decls_sptr).value);
    return ((*(*pc_decls_opc_tableptr)[((int64_t)3)]))();
}

static int64_t * pc_jhandlers_j_mixed_ij(void) {
    pc_bignum_bx_makeint((*(pc_decls_sptr + (int64_t)1)).value,(pc_decls_sptr + (int64_t)1));
    return ((*(*pc_decls_opc_tableptr)[((int64_t)7)]))();
}

static int64_t * pc_jhandlers_j_mixed_ji(void) {
    pc_bignum_bx_makeint((*pc_decls_sptr).value,pc_decls_sptr);
    return ((*(*pc_decls_opc_tableptr)[((int64_t)7)]))();
}

int64_t * pc_jhandlers_j_mul_i_w(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).value = ((*pc_decls_sptr).value * (*y).value);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_mul_r(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).xvalue *= (*y).xvalue;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_mul_j(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    struct pc_decls_varrec result;
    y = pc_decls_sptr++;
    x = pc_decls_sptr;
    pc_bignum_bx_mul(x,y,&result);
    pc_pcfns_pc_unshare(x);
    pc_pcfns_pc_unshare(y);
    (*pc_decls_sptr) = result;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_mul_z(void) {
    pc_support_pcmxtypes((uint8_t*)"mul_def",(pc_decls_sptr + (int64_t)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_mul_li(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    pc_pcfns_pc_mul_listi(x,y,pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_mul_si(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    pc_pcfns_pc_mul_stri(x,y,pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_mul_e(void) {
    return pc_jhandlers_j_iand_e();
}

int64_t * pc_jhandlers_j_mul_zz(void) {
    pc_support_pcmxtypes((uint8_t*)"mul/zz",(pc_decls_sptr + (int64_t)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_div_i(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).xvalue = ((double)((*pc_decls_sptr).value) / (double)((*y).value));
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)3);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_div_r(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).xvalue = ((*pc_decls_sptr).xvalue / (*y).xvalue);
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)3);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_div_j(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    struct pc_decls_varrec result;
    y = pc_decls_sptr++;
    x = pc_decls_sptr;
    pc_bignum_bx_div(x,y,&result);
    pc_pcfns_pc_unshare(x);
    pc_pcfns_pc_unshare(y);
    (*pc_decls_sptr) = result;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_div_z(void) {
    pc_support_pcmxtypes((uint8_t*)"div_def",(pc_decls_sptr + (int64_t)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_jumple_i(void) {
    if (((*(pc_decls_sptr + (int64_t)1)).value <= (*pc_decls_sptr).value)) {
        pc_decls_sptr += (int64_t)2;
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    pc_decls_sptr += (int64_t)2;
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumple_r(void) {
    if (((*(pc_decls_sptr + (int64_t)1)).xvalue <= (*pc_decls_sptr).xvalue)) {
        pc_decls_sptr += (int64_t)2;
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    pc_decls_sptr += (int64_t)2;
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumple_s(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64_t res;
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    y = pc_decls_sptr++;
    x = pc_decls_sptr++;
    px = (*x).objptr;
    py = (*y).objptr;
    res = pc_pcfns_cmpstring_len((*px).ustr.strptr,(*py).ustr.strptr,(int64_t)((*px).ustr.length),(int64_t)((*py).ustr.length));
    pc_pcfns_pc_unshare(x);
    pc_pcfns_pc_unshare(y);
    if ((res <= (int64_t)0)) {
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumple_z(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64_t res;
    y = pc_decls_sptr++;
    x = pc_decls_sptr++;
    res = pc_pcfns_pc_compare(x,y);
    if ((res <= (int64_t)0)) {
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumpeq_i_r_t_o(void) {
    if (((*(pc_decls_sptr + (int64_t)1)).value == (*pc_decls_sptr).value)) {
        pc_decls_sptr += (int64_t)2;
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    pc_decls_sptr += (int64_t)2;
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumpeq_v_p_f_g(void) {
    if (((*(pc_decls_sptr + (int64_t)1)).refptr == (*pc_decls_sptr).refptr)) {
        pc_decls_sptr += (int64_t)2;
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    pc_decls_sptr += (int64_t)2;
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumpeq_s(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64_t res;
    y = pc_decls_sptr++;
    x = pc_decls_sptr++;
    res = pc_pcfns_pc_eqstring(x,y);
    if (!!(res)) {
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumpeq_z(void) {
    int64_t res;
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = pc_decls_sptr++;
    res = pc_pcfns_pc_equal(x,y,(int64_t)0);
    if (!!(res)) {
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumpeq_zz(void) {
    return pc_jhandlers_j_jumpeq_z();
}

int64_t * pc_jhandlers_j_jumpne_i_r_t_o(void) {
    if (((*(pc_decls_sptr + (int64_t)1)).value != (*pc_decls_sptr).value)) {
        pc_decls_sptr += (int64_t)2;
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    pc_decls_sptr += (int64_t)2;
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumpne_v_p_f_g(void) {
    if (((*(pc_decls_sptr + (int64_t)1)).refptr != (*pc_decls_sptr).refptr)) {
        pc_decls_sptr += (int64_t)2;
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    pc_decls_sptr += (int64_t)2;
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumpne_s(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    int64_t res;
    int64_t n;
    y = pc_decls_sptr++;
    x = pc_decls_sptr++;
    px = (*x).objptr;
    py = (*y).objptr;
    res = (int64_t)0;
    n = (int64_t)((*px).ustr.length);
    if ((n != (int64_t)((*py).ustr.length))) {
    } else if ((n == (int64_t)0)) {
        res = (int64_t)1;
    } else {
        if ((mlib_cmpstringn((*px).ustr.strptr,(*py).ustr.strptr,n) == (int64_t)0)) {
            res = (int64_t)1;
        };
    };
    pc_pcfns_pc_unshare(x);
    pc_pcfns_pc_unshare(y);
    if ((res == (int64_t)0)) {
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumpne_z(void) {
    int64_t res;
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = pc_decls_sptr++;
    res = pc_pcfns_pc_equal(x,y,(int64_t)0);
    if (!(!!(res))) {
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumpne_zz(void) {
    return pc_jhandlers_j_jumpne_z();
}

int64_t * pc_jhandlers_j_jumpge_i(void) {
    if (((*(pc_decls_sptr + (int64_t)1)).value >= (*pc_decls_sptr).value)) {
        pc_decls_sptr += (int64_t)2;
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    pc_decls_sptr += (int64_t)2;
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumpge_w(void) {
    if (((*(pc_decls_sptr + (int64_t)1)).uvalue >= (*pc_decls_sptr).uvalue)) {
        pc_decls_sptr += (int64_t)2;
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    pc_decls_sptr += (int64_t)2;
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumpge_r(void) {
    if (((*(pc_decls_sptr + (int64_t)1)).xvalue >= (*pc_decls_sptr).xvalue)) {
        pc_decls_sptr += (int64_t)2;
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    pc_decls_sptr += (int64_t)2;
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumpge_z(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64_t res;
    y = pc_decls_sptr++;
    x = pc_decls_sptr++;
    res = pc_pcfns_pc_compare(x,y);
    if ((res >= (int64_t)0)) {
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumpgt_i(void) {
    if (((*(pc_decls_sptr + (int64_t)1)).value > (*pc_decls_sptr).value)) {
        pc_decls_sptr += (int64_t)2;
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    pc_decls_sptr += (int64_t)2;
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumpgt_w(void) {
    if (((*(pc_decls_sptr + (int64_t)1)).uvalue > (*pc_decls_sptr).uvalue)) {
        pc_decls_sptr += (int64_t)2;
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    pc_decls_sptr += (int64_t)2;
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumpgt_r(void) {
    if (((*(pc_decls_sptr + (int64_t)1)).xvalue > (*pc_decls_sptr).xvalue)) {
        pc_decls_sptr += (int64_t)2;
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    pc_decls_sptr += (int64_t)2;
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumpgt_z(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64_t res;
    y = pc_decls_sptr++;
    x = pc_decls_sptr++;
    res = pc_pcfns_pc_compare(x,y);
    if ((res > (int64_t)0)) {
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumplt_i(void) {
    if (((*(pc_decls_sptr + (int64_t)1)).value < (*pc_decls_sptr).value)) {
        pc_decls_sptr += (int64_t)2;
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    pc_decls_sptr += (int64_t)2;
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumplt_v_p(void) {
    if (((*(pc_decls_sptr + (int64_t)1)).refptr < (*pc_decls_sptr).refptr)) {
        pc_decls_sptr += (int64_t)2;
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    pc_decls_sptr += (int64_t)2;
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumplt_r(void) {
    if (((*(pc_decls_sptr + (int64_t)1)).xvalue < (*pc_decls_sptr).xvalue)) {
        pc_decls_sptr += (int64_t)2;
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    pc_decls_sptr += (int64_t)2;
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumplt_z(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64_t res;
    y = pc_decls_sptr++;
    x = pc_decls_sptr++;
    res = pc_pcfns_pc_compare(x,y);
    if ((res < (int64_t)0)) {
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_pushix_li(void) {
    struct pc_decls_objrec *  p;
    struct pc_decls_varrec va;
    int64_t index;
    va = (*(pc_decls_sptr + (int64_t)1));
    p = va.objptr;
    index = ((*pc_decls_sptr).value - (int64_t)((*p).ulist.lower));
    if (((uint64_t)((uint32_t)(index)) >= (uint64_t)((*p).ulist.length))) {
        pc_support_pcerror((uint8_t*)"list[int] bounds");
    };
    (*++pc_decls_sptr) = (*((*p).ulist.vptr + index));
    if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
        ++(*(*pc_decls_sptr).objptr).ulist.refcount;
    };
    if (!!((uint64_t)(va.hasref))) {
        pc_pcfns_pc_unshare(&va);
    };
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_pushix_mi(void) {
    struct pc_decls_objrec *  p;
    struct pc_decls_varrec va;
    int64_t index;
    va = (*(pc_decls_sptr + (int64_t)1));
    p = va.objptr;
    index = ((*pc_decls_sptr).value - (int64_t)1);
    if (((uint64_t)((uint32_t)(index)) >= (uint64_t)(pc_decls_ttlength[((int64_t)(va.tag))]))) {
        pc_support_pcerror((uint8_t*)"rec[int] bounds");
    };
    (*++pc_decls_sptr) = (*((*p).urec.vptr + index));
    if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
        ++(*(*pc_decls_sptr).objptr).refcount;
    };
    pc_pcfns_pc_unshare(&va);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_pushix_vi(void) {
    int64_t index;
    index = (*pc_decls_sptr).value;
    ++pc_decls_sptr;
    (*pc_decls_sptr) = (*((*pc_decls_sptr).varptr + index));
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_pushix_ln(void) {
    struct pc_decls_varrec v;
    struct pc_decls_varrec *  a;
    struct pc_decls_varrec *  x;
    int64_t i;
    int64_t j;
    int64_t alower;
    struct pc_decls_objrec *  p;
    struct pc_decls_objrec *  q;
    x = pc_decls_sptr++;
    a = pc_decls_sptr;
    p = (*a).objptr;
    i = (int64_t)((*x).range_lower);
    j = (int64_t)((*x).range_upper);
    alower = (int64_t)((*p).ulist.lower);
    if ((((i < alower) || (j > (((int64_t)((uint64_t)((*p).ulist.length)) + alower) - (int64_t)1))) || (i > j))) {
        pc_support_pcerror((uint8_t*)"list/slice bounds");
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)65565);
    q = pc_objlib_obj_new((int64_t)29);
    (*pc_decls_sptr).objptr = q;
    (*q).objtype = (uint64_t)((int64_t)1);
    (*q).ulist.mutable = (uint64_t)((*p).ulist.mutable);
    (*q).ulist.lower = (int64_t)1;
    if (((int64_t)((*p).objtype)==(int64_t)1)) {
        (*q).ulist.objptr2 = (*p).ulist.objptr2;
        ++(*(*q).objptr2).ulist.refcount;
        (*q).ulist.vptr = (((*p).ulist.vptr + i) - alower);
        v.tagx = (uint64_t)((int64_t)65565);
        v.objptr = p;
        pc_pcfns_pc_unshare(&v);
    }else if (((int64_t)((*p).objtype)==(int64_t)2)) {
        (*q).objptr2 = (struct pc_decls_objrec *)(0);
        (*q).objtype = (uint64_t)((int64_t)2);
        (*q).ulist.vptr = (((*p).ulist.vptr + i) - alower);
    } else {
        (*q).ulist.objptr2 = p;
        (*q).ulist.vptr = (((*p).ulist.vptr + i) - alower);
    };
    (*q).ulist.length = (uint64_t)(((j - i) + (int64_t)1));
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_pushix_ll(void) {
    pc_support_junimpl((uint8_t*)"pushix_listlist");
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_pushix_le(void) {
    pc_support_junimpl((uint8_t*)"pushix_list_set");
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_pushix_ai(void) {
    struct pc_decls_objrec *  p;
    int64_t index;
    int64_t elemtype;
    struct pc_decls_varrec va;
    va = (*(pc_decls_sptr + (int64_t)1));
    p = va.objptr;
    index = ((*pc_decls_sptr).value - (int64_t)((*p).uarray.lower));
    if (((uint64_t)((uint32_t)(index)) >= (uint64_t)((*p).uarray.length))) {
        pc_support_pcerror((uint8_t*)"ax[int] bounds");
    };
    if (((elemtype = (int64_t)((*p).uarray.elemtag)) == (int64_t)44)) {
        ++pc_decls_sptr;
        (*pc_decls_sptr).value = (int64_t)((*((*p).uarray.ptr + index)));
        (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    } else {
        pc_pcfns_pc_loadpacked((void *)(((*p).uarray.ptr + (index * pc_decls_ttsize[(elemtype)]))),elemtype,++pc_decls_sptr,p);
    };
    if (!!((uint64_t)(va.hasref))) {
        pc_pcfns_pc_unshare(&va);
    };
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_pushix_bi_ei(void) {
    struct pc_decls_objrec *  p;
    int64_t index;
    int64_t offset;
    int64_t shift;
    byte *  q;
    struct pc_decls_varrec va;
    va = (*(pc_decls_sptr + (int64_t)1));
    p = va.objptr;
    index = ((*pc_decls_sptr).value - (int64_t)((*p).ubits.lower));
    offset = (int64_t)((*p).ubits.bitoffset);
    q = (*p).ubits.ptr;
    if (((uint64_t)((uint32_t)(index)) >= (uint64_t)((*p).ubits.length))) {
        pc_support_pcerror((uint8_t*)"bits[int] bounds");
    };
    ++pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    switch ((int64_t)((*p).ubits.elemtag)) {
    case 41:;
    {
        index += offset;
        (*pc_decls_sptr).value = !!(((int64_t)((uint64_t)((*(q + (index >> (int64_t)3))))) & ((int64_t)1 << (index & (int64_t)7))));
    }break;
    case 42:;
    {
        index += (offset >> (int64_t)1);
        shift = ((index & (int64_t)3) * (int64_t)2);
        (*pc_decls_sptr).value = (((int64_t)((uint64_t)((*(q + (index >> (int64_t)2))))) & ((int64_t)3 << shift)) >> shift);
    }break;
    case 43:;
    {
        index += (offset >> (int64_t)2);
        shift = ((index & (int64_t)1) * (int64_t)4);
        (*pc_decls_sptr).value = (((int64_t)((uint64_t)((*(q + (index >> (int64_t)1))))) & ((int64_t)15 << shift)) >> shift);
    }break;
    default: {
        pc_support_pcustypet((uint8_t*)"bitix",(int64_t)((*p).ubits.elemtag));
    }
    } //SW
;
    if (!!((uint64_t)(va.hasref))) {
        pc_pcfns_pc_unshare(&va);
    };
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_pushix_an(void) {
    struct pc_decls_varrec v;
    struct pc_decls_varrec *  a;
    struct pc_decls_varrec *  x;
    int64_t i;
    int64_t j;
    int64_t offset;
    struct pc_decls_objrec *  p;
    struct pc_decls_objrec *  q;
    x = pc_decls_sptr++;
    a = pc_decls_sptr;
    p = (*a).objptr;
    i = (int64_t)((*x).range_lower);
    j = (int64_t)((*x).range_upper);
    if ((((i < (int64_t)((*p).uarray.lower)) || (j > (int64_t)((uint64_t)((*p).uarray.length)))) || (i > j))) {
        pc_support_pcerror((uint8_t*)"ax[slice] bounds");
    };
    (*pc_decls_sptr).tagx = (uint64_t)((*a).tagx);
    q = pc_objlib_obj_new((int64_t)((*a).tagx));
    (*pc_decls_sptr).objptr = q;
    (*q).objtype = (uint64_t)((int64_t)1);
    (*q).uarray.mutable = (uint64_t)((*p).uarray.mutable);
    (*q).uarray.elemtag = (int64_t)((*p).uarray.elemtag);
    (*q).uarray.lower = (int64_t)((*p).uarray.lower);
    offset = ((i - (int64_t)((*p).uarray.lower)) * pc_decls_ttsize[((int64_t)((*p).uarray.elemtag))]);
    if (((int64_t)((*p).objtype)==(int64_t)1)) {
        (*q).uarray.objptr2 = (*p).uarray.objptr2;
        ++(*(*q).objptr2).refcount;
        (*q).uarray.ptr = ((*p).uarray.ptr + offset);
        v.tagx = (uint64_t)((int64_t)65541);
        v.objptr = p;
        pc_pcfns_pc_unshare(&v);
    }else if (((int64_t)((*p).objtype)==(int64_t)2)) {
        (*q).uarray.objptr2 = (struct pc_decls_objrec *)(0);
        (*q).objtype = (uint64_t)((int64_t)2);
        (*q).uarray.ptr = ((*p).uarray.ptr + offset);
    } else {
        (*q).uarray.objptr2 = p;
        (*q).uarray.ptr = ((*p).uarray.ptr + offset);
    };
    (*q).uarray.length = (uint64_t)(((j - i) + (int64_t)1));
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_pushix_si(void) {
    struct pc_decls_varrec v;
    struct pc_decls_varrec *  a;
    struct pc_decls_varrec *  x;
    int64_t i;
    struct pc_decls_objrec *  p;
    struct pc_decls_objrec *  q;
    x = pc_decls_sptr++;
    a = pc_decls_sptr;
    p = (*a).objptr;
    i = ((*x).value - (int64_t)1);
    if (((uint64_t)((uint32_t)(i)) >= (uint64_t)((uint32_t)((*p).ustr.length)))) {
        pc_support_pcerror((uint8_t*)"string[int] bounds");
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)65541);
    q = pc_objlib_obj_new((int64_t)5);
    (*pc_decls_sptr).objptr = q;
    (*q).objtype = (uint64_t)((int64_t)1);
    (*q).ustr.mutable = (uint64_t)((*p).ustr.mutable);
    if (((int64_t)((*p).objtype)==(int64_t)1)) {
        (*q).ustr.objptr2 = (*p).ustr.objptr2;
        ++(*(*q).objptr2).refcount;
        (*q).ustr.strptr = ((*p).ustr.strptr + i);
        v.tagx = (uint64_t)((int64_t)65541);
        v.objptr = p;
        pc_pcfns_pc_unshare(&v);
    }else if (((int64_t)((*p).objtype)==(int64_t)2)) {
        (*q).ustr.objptr2 = (struct pc_decls_objrec *)(0);
        (*q).objtype = (uint64_t)((int64_t)2);
        (*q).ustr.strptr = ((*p).ustr.strptr + i);
    } else {
        (*q).ustr.objptr2 = p;
        (*q).ustr.strptr = ((*p).ustr.strptr + i);
    };
    (*q).ustr.length = (int64_t)1;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_pushix_sn(void) {
    return pc_jhandlers_j_pushdotix_sn();
}

int64_t * pc_jhandlers_j_pushix_bn(void) {
    struct pc_decls_varrec v;
    struct pc_decls_varrec *  a;
    struct pc_decls_varrec *  x;
    int64_t i;
    int64_t j;
    struct pc_decls_objrec *  p;
    struct pc_decls_objrec *  q;
    x = pc_decls_sptr++;
    a = pc_decls_sptr;
    p = (*a).objptr;
    i = (int64_t)((*x).range_lower);
    j = (int64_t)((*x).range_upper);
    if ((((i < (int64_t)((*p).ubits.lower)) || (j > (int64_t)((uint64_t)((*p).ubits.length)))) || (i > j))) {
        pc_support_pcerror((uint8_t*)"bits[slice] bounds");
    };
    (*pc_decls_sptr).tagx = (uint64_t)((*a).tagx);
    q = pc_objlib_obj_new((int64_t)31);
    (*pc_decls_sptr).objptr = q;
    (*q).objtype = (uint64_t)((int64_t)1);
    (*q).ubits.mutable = (uint64_t)((*p).ubits.mutable);
    (*q).ubits.elemtag = (uint64_t)((*p).ubits.elemtag);
    (*q).ubits.lower = (int64_t)((*p).ubits.lower);
    (*q).ubits.ptr = pc_pcfns_getbitoffset((*p).ubits.ptr,(int64_t)((*p).ubits.bitoffset),(i - (int64_t)((*p).ubits.lower)),(int64_t)((*p).ubits.elemtag),&(*q).ubits.bitoffset);
    ++(*q).ubits.bitoffset;
    if (((int64_t)((*p).objtype)==(int64_t)1)) {
        (*q).ubits.objptr2 = (*p).ubits.objptr2;
        ++(*(*q).objptr2).refcount;
        v.tagx = (uint64_t)((int64_t)65541);
        v.objptr = p;
        pc_pcfns_pc_unshare(&v);
    }else if (((int64_t)((*p).objtype)==(int64_t)2)) {
        (*q).ubits.objptr2 = (struct pc_decls_objrec *)(0);
        (*q).objtype = (uint64_t)((int64_t)2);
    } else {
        (*q).ubits.objptr2 = p;
    };
    (*q).ubits.length = (uint64_t)(((j - i) + (int64_t)1));
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_pushix_di(void) {
    struct pc_decls_varrec *  a;
    struct pc_decls_varrec *  x;
    int64_t i;
    int64_t j;
    int64_t alower;
    struct pc_decls_objrec *  p;
    struct pc_decls_objrec *  q;
    x = pc_decls_sptr++;
    a = pc_decls_sptr;
    p = (*a).objptr;
    i = (*x).value;
    j = (int64_t)((*x).range_upper);
    alower = (int64_t)((*p).udict.lower);
    if (((i < (int64_t)1) || (j > (int64_t)((uint64_t)((*p).udict.allocated))))) {
        pc_support_pcerror((uint8_t*)"dict[] bounds");
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)65565);
    q = pc_objlib_obj_new((int64_t)10);
    (*pc_decls_sptr).objptr = q;
    (*q).objtype = (uint64_t)((int64_t)1);
    (*q).udict.lower = (int64_t)1;
    (*q).udict.length = (uint64_t)((int64_t)2);
    (*q).udict.objptr2 = p;
    (*q).udict.vptr = ((*p).udict.vptr + ((i - (int64_t)1) * (int64_t)2));
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_pushix_zz(void) {
    pc_support_pcmxtypes((uint8_t*)"pushix/def",(pc_decls_sptr + (int64_t)1),pc_decls_sptr);
    return (int64_t *)(0);
}

int64_t * pc_jhandlers_j_pushixref_li(void) {
    struct pc_decls_objrec *  p;
    struct pc_decls_varrec *  a;
    int64_t index;
    a = (*(pc_decls_sptr + (int64_t)1)).varptr;
    p = (*a).objptr;
    if (!(!!((uint64_t)((*p).ulist.mutable)))) {
        p = ((*a).objptr = pc_objlib_copyonwrite(p,(int64_t)29));
    };
    index = ((*pc_decls_sptr).value - (int64_t)((*p).ulist.lower));
    if (((uint64_t)((uint32_t)(index)) >= (uint64_t)((*p).ulist.length))) {
        if ((index < (int64_t)0)) {
            pc_support_pcerror((uint8_t*)"LWB");
        } else {
            if ((((uint64_t)((uint32_t)(index)) == (uint64_t)((*p).ulist.length)) && ((int64_t)((uint64_t)((*a).tag)) == (int64_t)29))) {
                pc_pcfns_pc_iappendlist(a,(struct pc_decls_varrec *)(0));
                p = (*a).objptr;
            } else {
                pc_support_pcerror((uint8_t*)"&pushix list[i] bounds");
            };
        };
    };
    (*++pc_decls_sptr).tagx = (uint64_t)((int64_t)22);
    (*pc_decls_sptr).varptr = ((*p).ulist.vptr + index);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_pushixref_ln(void) {
    pc_support_junimpl((uint8_t*)"pushixref_list_range");
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_pushixref_ai(void) {
    int64_t index;
    int64_t elemtype;
    struct pc_decls_objrec *  p;
    struct pc_decls_varrec *  a;
    a = (*(pc_decls_sptr + (int64_t)1)).varptr;
    p = (*a).objptr;
    index = ((*pc_decls_sptr).value - (int64_t)((*p).uarray.lower));
    if (((uint64_t)((uint32_t)(index)) >= (uint64_t)((*p).uarray.length))) {
        if ((index < (int64_t)0)) {
            pc_support_pcerror((uint8_t*)"&AXLWB");
        } else {
            if (((uint64_t)((uint32_t)(index)) == (uint64_t)((*p).uarray.length))) {
                pc_pcfns_pc_iappendarray(a,(struct pc_decls_varrec *)(0));
                p = (*a).objptr;
            } else {
                pc_support_pcerror((uint8_t*)"&AXBOUNDS");
            };
        };
    };
    elemtype = (int64_t)((*p).uarray.elemtag);
    ++pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)23);
    (*pc_decls_sptr).uref.elemtag = (uint64_t)(elemtype);
    (*pc_decls_sptr).uref.ptr = ((*p).uarray.ptr + (index * pc_decls_ttsize[(elemtype)]));
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_pushixref_si(void) {
    struct pc_decls_varrec *  a;
    int64_t index;
    struct pc_decls_objrec *  pa;
    a = (*(pc_decls_sptr + (int64_t)1)).varptr;
    pa = (*a).objptr;
    index = ((*pc_decls_sptr).value - (int64_t)1);
    if (!(!!((uint64_t)((*pa).ustr.mutable)))) {
        (*a).objptr = (pa = pc_objlib_copyonwrite(pa,(int64_t)5));
    };
    if (((uint64_t)((uint32_t)(index)) >= (uint64_t)((uint32_t)((*pa).ustr.length)))) {
        pc_support_pcerror((uint8_t*)"&str[int] bounds");
    };
    (*++pc_decls_sptr).tagx = (uint64_t)((int64_t)23);
    (*pc_decls_sptr).uref.elemtag = (uint64_t)((int64_t)5);
    (*pc_decls_sptr).uref.ptr = ((byte *)((*pa).ustr.strptr) + index);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_pushixref_bi(void) {
    int64_t index;
    int64_t elemtype;
    struct pc_decls_objrec *  p;
    struct pc_decls_varrec *  a;
    a = (*(pc_decls_sptr + (int64_t)1)).varptr;
    p = (*a).objptr;
    index = ((*pc_decls_sptr).value - (int64_t)((*p).ubits.lower));
    if (((uint64_t)((uint32_t)(index)) >= (uint64_t)((*p).ubits.length))) {
        if ((index < (int64_t)0)) {
            pc_support_pcerror((uint8_t*)"&BITSLWB");
        } else {
            if (((uint64_t)((uint32_t)(index)) == (uint64_t)((*p).ubits.length))) {
                pc_pcfns_pc_iappendbits(a,(struct pc_decls_varrec *)(0));
                p = (*a).objptr;
            } else {
                pc_support_pcerror((uint8_t*)"&BITSBOUNDS");
            };
        };
    };
    elemtype = (int64_t)((*p).ubits.elemtag);
    ++pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)24);
    (*pc_decls_sptr).uref.elemtag = (uint64_t)(elemtype);
    (*pc_decls_sptr).uref.ptr = pc_pcfns_getbitoffset((*p).ubits.ptr,(int64_t)((*p).ubits.bitoffset),index,elemtype,&(*pc_decls_sptr).uref.bitoffset);
    (*pc_decls_sptr).uref.bitlength = (uint64_t)((int64_t)0);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_pushixref_zz(void) {
    pc_support_pcerror((uint8_t*)"JPUSHIXREF/DEF");
    return (int64_t *)(0);
}

int64_t * pc_jhandlers_j_pushdotix_si(void) {
    struct pc_decls_varrec *  a;
    struct pc_decls_varrec *  x;
    int64_t index;
    int64_t value;
    struct pc_decls_objrec *  p;
    x = pc_decls_sptr++;
    a = pc_decls_sptr;
    p = (*a).objptr;
    index = ((*x).value - (int64_t)1);
    if (((uint64_t)((uint32_t)(index)) >= (uint64_t)((uint32_t)((*p).ustr.length)))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"INDEX=",NULL);
        msysnewc_m_print_i64(index,NULL);
        msysnewc_m_print_str((uint8_t*)"P.USTR.LENGTH=",NULL);
        msysnewc_m_print_i64((*p).ustr.length,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        pc_support_pcerror((uint8_t*)"string.[int] bounds");
    };
    value = (int64_t)((*((*p).ustr.strptr + index)));
    if (!!((uint64_t)((*a).hasref))) {
        pc_pcfns_pc_unshare(a);
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = value;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_pushdotix_sn(void) {
    struct pc_decls_varrec v;
    struct pc_decls_varrec *  a;
    struct pc_decls_varrec *  x;
    int64_t i;
    int64_t j;
    struct pc_decls_objrec *  p;
    struct pc_decls_objrec *  q;
    x = pc_decls_sptr++;
    a = pc_decls_sptr;
    p = (*a).objptr;
    i = (int64_t)((*x).range_lower);
    j = (int64_t)((*x).range_upper);
    if ((((i < (int64_t)1) || (j > (int64_t)((*p).ustr.length))) || (i > j))) {
        if ((i == (j + (int64_t)1))) {
            (*pc_decls_sptr).objptr = pc_objlib_emptystring;
            (*pc_decls_sptr).tagx = (uint64_t)((int64_t)65541);
            ++(*pc_objlib_emptystring).refcount;
            return (pc_decls_pcptr + (int64_t)1);
        };
        pc_support_pcerror((uint8_t*)"string[slice] bounds");
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)65541);
    q = pc_objlib_obj_new((int64_t)5);
    (*pc_decls_sptr).objptr = q;
    (*q).objtype = (uint64_t)((int64_t)1);
    (*q).ustr.mutable = (uint64_t)((*p).ustr.mutable);
    if (((int64_t)((*p).objtype)==(int64_t)1)) {
        (*q).ustr.objptr2 = (*p).ustr.objptr2;
        ++(*(*q).objptr2).refcount;
        (*q).ustr.strptr = (((*p).ustr.strptr + i) - (int64_t)1);
        v.tagx = (uint64_t)((int64_t)65541);
        v.objptr = p;
        pc_pcfns_pc_unshare(&v);
    }else if (((int64_t)((*p).objtype)==(int64_t)2)) {
        (*q).ustr.objptr2 = (struct pc_decls_objrec *)(0);
        (*q).objtype = (uint64_t)((int64_t)2);
        (*q).ustr.strptr = (((*p).ustr.strptr + i) - (int64_t)1);
    } else {
        (*q).ustr.objptr2 = p;
        (*q).ustr.strptr = (((*p).ustr.strptr + i) - (int64_t)1);
    };
    (*q).ustr.length = ((j - i) + (int64_t)1);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_pushdotix_ii(void) {
    int64_t index;
    index = (*pc_decls_sptr).value;
    ++pc_decls_sptr;
    if (((index < (int64_t)0) || (index >= (int64_t)64))) {
        pc_support_pcerror((uint8_t*)"int.[int] bounds");
    };
    (*pc_decls_sptr).value = (((*pc_decls_sptr).value >> index) & (int64_t)1);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_pushdotix_in(void) {
    int64_t i;
    int64_t j;
    i = (int64_t)((*pc_decls_sptr).range_lower);
    j = (int64_t)((*pc_decls_sptr).range_upper);
    ++pc_decls_sptr;
    if ((j < i)) {
        {int64_t temp = i; i = j; j = temp; };
    };
    if (((i >= (int64_t)64) || (j >= (int64_t)64))) {
        pc_support_pcerror((uint8_t*)"int.[slice] bounds");
    };
    (*pc_decls_sptr).value = (((*pc_decls_sptr).value >> i) & (int64_t)(~(((uint64_t)18446744073709551615u << ((j - i) + (int64_t)1)))));
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_pushdotix_ei(void) {
    return pc_jhandlers_j_pushix_bi_ei();
}

int64_t * pc_jhandlers_j_pushdotix_mi(void) {
    return pc_jhandlers_j_pushix_mi();
}

int64_t * pc_jhandlers_j_pushdotix_zz(void) {
    pc_support_pcmxtypes((uint8_t*)"pushdotix/def",(pc_decls_sptr + (int64_t)1),pc_decls_sptr);
    return (int64_t *)(0);
}

int64_t * pc_jhandlers_j_pushdotixref_si(void) {
    struct pc_decls_varrec *  a;
    int64_t index;
    struct pc_decls_objrec *  pa;
    a = (*(pc_decls_sptr + (int64_t)1)).varptr;
    pa = (*a).objptr;
    index = ((*pc_decls_sptr).value - (int64_t)1);
    if (((uint64_t)((uint32_t)(index)) >= (uint64_t)((uint32_t)((*pa).ustr.length)))) {
        pc_support_pcerror((uint8_t*)"&str.[int] bounds");
    };
    (*++pc_decls_sptr).tagx = (uint64_t)((int64_t)23);
    (*pc_decls_sptr).uref.elemtag = (uint64_t)((int64_t)44);
    (*pc_decls_sptr).uref.ptr = ((byte *)((*pa).ustr.strptr) + index);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_pushdotixref_sn(void) {
    pc_support_pcerror((uint8_t*)"JPUSHDOTIXREF/SRANGE");
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_pushdotixref_ii(void) {
    int64_t index;
    byte *  p;
    index = (*pc_decls_sptr).value;
    ++pc_decls_sptr;
    if (((index < (int64_t)0) || (index >= (int64_t)64))) {
        pc_support_pcerror((uint8_t*)"int.[int] bounds");
    };
    p = (*pc_decls_sptr).uref.ptr;
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)24);
    (*pc_decls_sptr).uref.elemtag = (uint64_t)((int64_t)41);
    (*pc_decls_sptr).uref.bitoffset = (uint64_t)((index & (int64_t)7));
    (*pc_decls_sptr).uref.ptr = ((p + (int64_t)8) + (index >> (int64_t)3));
    (*pc_decls_sptr).uref.bitlength = (uint64_t)((int64_t)0);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_pushdotixref_in_wn(void) {
    int64_t i;
    int64_t j;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"PUSHDOTIXREF/INT/RANGE",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    i = (int64_t)((*pc_decls_sptr).range_lower);
    j = (int64_t)((*pc_decls_sptr).range_upper);
    if ((i > j)) {
        {int64_t temp = i; i = j; j = temp; };
    };
    ++pc_decls_sptr;
    if (((i < (int64_t)0) || (j >= (int64_t)64))) {
        pc_support_pcerror((uint8_t*)"int.[slice] bounds");
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)24);
    (*pc_decls_sptr).uref.bitlength = (uint64_t)(((j - i) + (int64_t)1));
    (*pc_decls_sptr).uref.elemtag = (uint64_t)((int64_t)41);
    (*pc_decls_sptr).uref.bitoffset = (uint64_t)(i);
    ++(*pc_decls_sptr).uref.ptr64;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_pushdotixref_ei(void) {
    return pc_support_pcerror((uint8_t*)"PUSHDOTIXREF/SET");
}

int64_t * pc_jhandlers_j_pushdotixref_zz(void) {
    pc_support_pcmxtypes((uint8_t*)"ZZpushdotixref/def",(pc_decls_sptr + (int64_t)1),pc_decls_sptr);
    return (int64_t *)(0);
}

int64_t * pc_jhandlers_j_addto_i(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).value += (*y).value;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_addto_r(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).xvalue += (*y).xvalue;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_addto_s(void) {
    int64_t xlen;
    int64_t ylen;
    int64_t newlen;
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    px = (*x).objptr;
    py = (*y).objptr;
    if (!(!!((uint64_t)((*px).ustr.mutable)))) {
        (*x).objptr = (px = pc_objlib_copyonwrite(px,(int64_t)5));
    };
    if (((int64_t)((uint64_t)((*px).objtype)) != (int64_t)0)) {
        pc_support_pcerror((uint8_t*)"extending string slice");
    };
    xlen = (int64_t)((*px).ustr.length);
    ylen = (int64_t)((*py).ustr.length);
    if ((xlen == (int64_t)0)) {
        if (!!(ylen)) {
            (*px).ustr.strptr = (uint8_t *)(mlib_pcm_alloc(ylen));
            (*px).ustr.allocated = (uint64_t)(mlib_allocbytes);
            (*px).ustr.length = ylen;
            memcpy((void *)((*px).ustr.strptr),(void *)((*py).ustr.strptr),(uint64_t)(ylen));
        };
    } else if ((ylen == (int64_t)1)) {
        if ((++xlen > (int64_t)((uint64_t)((*px).ustr.allocated)))) {
            pc_objlib_string_resize(px,xlen);
        };
        (*px).ustr.length = xlen;
        (*(((*px).ustr.strptr + xlen) - (int64_t)1)) = (uint64_t)((*(*py).ustr.strptr));
    } else if (!!(ylen)) {
        newlen = (xlen + ylen);
        if ((newlen > (int64_t)((uint64_t)((*px).ustr.allocated)))) {
            pc_objlib_string_resize(px,newlen);
        };
        (*px).ustr.length = newlen;
        memcpy((void *)(((*px).ustr.strptr + xlen)),(void *)((*py).ustr.strptr),(uint64_t)(ylen));
    };
    pc_pcfns_pc_unshare(y);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_addto_p(void) {
    pc_support_pcerror((uint8_t*)"ADDTO REF PACK");
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_addto_z(void) {
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    struct pc_decls_varrec result;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    px = (*x).objptr;
    py = (*y).objptr;
    if (((int64_t)((*y).tag)==(int64_t)7)) {
        pc_bignum_bx_add(x,y,&result);
        pc_pcfns_pc_unshare(x);
        pc_pcfns_pc_unshare(y);
        (*x) = result;
    } else {
        pc_support_pcmxtypes((uint8_t*)"addto_def",x,y);
    };
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_addto_si(void) {
    int64_t ch;
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64_t xlen;
    struct pc_decls_objrec *  px;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    ch = (*y).value;
    px = (*x).objptr;
    if (!(!!((uint64_t)((*px).ustr.mutable)))) {
        (*x).objptr = (px = pc_objlib_copyonwrite(px,(int64_t)5));
    };
    xlen = (int64_t)((*px).ustr.length);
    if ((xlen == (int64_t)0)) {
        (*px).ustr.strptr = (uint8_t *)(mlib_pcm_alloc((int64_t)1));
        (*px).ustr.allocated = (uint64_t)(mlib_allocbytes);
        (*px).ustr.length = (int64_t)1;
        (*(*px).ustr.strptr) = (uint64_t)(ch);
    } else {
        if ((++xlen > (int64_t)((uint64_t)((*px).ustr.allocated)))) {
            pc_objlib_string_resize(px,xlen);
        };
        (*px).ustr.length = xlen;
        (*(((*px).ustr.strptr + xlen) - (int64_t)1)) = (uint64_t)(ch);
    };
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_addto_ir(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).value += (int64_t)((*y).xvalue);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_addto_ri(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).xvalue += (double)((*y).value);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_addto_zz(void) {
    pc_support_pcmxtypes((uint8_t*)"addto_zz",(*(pc_decls_sptr + (int64_t)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_subto_i(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).value -= (*y).value;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_subto_r(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).xvalue -= (*y).xvalue;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_subto_z(void) {
    pc_support_pcmxtypes((uint8_t*)"subto_def",(*(pc_decls_sptr + (int64_t)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_subto_ir(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).value -= (int64_t)((*y).xvalue);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_subto_ri(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).xvalue -= (double)((*y).value);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_subto_zz(void) {
    pc_support_pcmxtypes((uint8_t*)"subto_zz",(*(pc_decls_sptr + (int64_t)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_multo_i_w(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).value *= (*y).value;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_multo_r(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).xvalue *= (*y).xvalue;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_multo_z(void) {
    pc_support_pcmxtypes((uint8_t*)"multo_def",(*(pc_decls_sptr + (int64_t)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_divto_i_w(void) {
    pc_support_pcerror((uint8_t*)"divto int?");
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_divto_r(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).xvalue /= (*y).xvalue;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_divto_z(void) {
    pc_support_pcmxtypes((uint8_t*)"divto_def",(*(pc_decls_sptr + (int64_t)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_idivto_i(void) {
    pc_support_pcustype((uint8_t*)"idivto",pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_idivto_z(void) {
    pc_support_pcmxtypes((uint8_t*)"idivto_def",(*(pc_decls_sptr + (int64_t)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_iand_i_w(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).value &= (*y).value;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_iand_e(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    pc_dxfns_dx_iandset(x,y);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_iand_z(void) {
    pc_support_pcmxtypes((uint8_t*)"iand_def",(pc_decls_sptr + (int64_t)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_ior_i_w(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).value |= (*y).value;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_ior_e(void) {
    return pc_jhandlers_j_add_e();
}

int64_t * pc_jhandlers_j_ior_z(void) {
    pc_support_pcmxtypes((uint8_t*)"ior_def",(pc_decls_sptr + (int64_t)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_ixor_i_w(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).value ^= (*y).value;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_ixor_e(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = pc_decls_sptr;
    pc_dxfns_dx_ixorset(x,y);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_ixor_z(void) {
    pc_support_pcmxtypes((uint8_t*)"ixor_def",(pc_decls_sptr + (int64_t)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_iandto_i_w(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).value &= (*y).value;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_iandto_z(void) {
    pc_support_pcmxtypes((uint8_t*)"iandto_def",(*(pc_decls_sptr + (int64_t)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_iorto_i_w(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).value |= (*y).value;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_iorto_z(void) {
    pc_support_pcmxtypes((uint8_t*)"iorto_def",(*(pc_decls_sptr + (int64_t)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_ixorto_i_w(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).value ^= (*y).value;
    return (pc_decls_pcptr + (int64_t)1);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_ixorto_z(void) {
    pc_support_pcmxtypes((uint8_t*)"ixorto_def",(*(pc_decls_sptr + (int64_t)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_shlto_i(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).value = ((*x).value << (*y).value);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_shlto_z(void) {
    pc_support_pcmxtypes((uint8_t*)"shlto_def",(*(pc_decls_sptr + (int64_t)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_shrto_i(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).value = ((*x).value >> (*y).value);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_shrto_z(void) {
    pc_support_pcmxtypes((uint8_t*)"shrto_def",(*(pc_decls_sptr + (int64_t)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_concat_s(void) {
    return pc_jhandlers_j_add_s();
}

int64_t * pc_jhandlers_j_concat_l(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    pc_pcfns_pc_duplvar(x);
    pc_pcfns_pc_iconcatlist(x,y);
    if (!!((uint64_t)((*y).hasref))) {
        pc_pcfns_pc_unshare(y);
    };
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_concat_z(void) {
    pc_support_pcmxtypes((uint8_t*)"concat_def",(pc_decls_sptr + (int64_t)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_concatto_s(void) {
    pc_support_junimpl((uint8_t*)"concatto_string");
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_concatto_l(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    pc_pcfns_pc_iconcatlist(x,y);
    if (!!((uint64_t)((*y).hasref))) {
        pc_pcfns_pc_unshare(y);
    };
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_concatto_z(void) {
    pc_support_pcmxtypes((uint8_t*)"concatto_def",(pc_decls_sptr + (int64_t)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_append_s(void) {
    if (((int64_t)((uint64_t)((*pc_decls_sptr).tag)) != (int64_t)5)) {
        pc_support_pcustype((uint8_t*)"append/s",pc_decls_sptr);
    };
    return pc_jhandlers_j_add_s();
}

int64_t * pc_jhandlers_j_append_l(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    pc_pcfns_pc_duplvar(x);
    pc_pcfns_pc_iappendlist(x,y);
    if (!!((uint64_t)((*y).hasref))) {
        pc_pcfns_pc_unshare(y);
    };
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_append_a(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    pc_pcfns_pc_duplvar(x);
    pc_pcfns_pc_iappendarray(x,y);
    if (!!((uint64_t)((*y).hasref))) {
        pc_pcfns_pc_unshare(y);
    };
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_append_b(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    pc_pcfns_pc_duplvar(x);
    pc_pcfns_pc_iappendbits(x,y);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_append_z(void) {
    pc_support_pcmxtypes((uint8_t*)"append_def",(pc_decls_sptr + (int64_t)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_appendto_s(void) {
    return pc_jhandlers_j_addto_s();
}

int64_t * pc_jhandlers_j_appendto_l(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    pc_pcfns_pc_iappendlist(x,y);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_appendto_a(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    pc_pcfns_pc_iappendarray(x,y);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_appendto_b_e(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    pc_pcfns_pc_iappendbits(x,y);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_appendto_z(void) {
    pc_support_pcmxtypes((uint8_t*)"appendto_def",(pc_decls_sptr + (int64_t)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_max_i(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).value=((*pc_decls_sptr).value>(*y).value?(*pc_decls_sptr).value:(*y).value);
;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_max_r(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).xvalue=((*pc_decls_sptr).xvalue>(*y).xvalue?(*pc_decls_sptr).xvalue:(*y).xvalue);
;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_max_z(void) {
    int64_t res;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    res = pc_pcfns_pc_compare_nf(pc_decls_sptr,y);
    if ((res >= (int64_t)0)) {
        if (!!((uint64_t)((*y).hasref))) {
            pc_pcfns_pc_unshare(y);
        };
    } else {
        if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
            pc_pcfns_pc_unshare(pc_decls_sptr);
        };
        (*pc_decls_sptr) = (*y);
    };
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_min_z(void) {
    int64_t res;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    res = pc_pcfns_pc_compare_nf(pc_decls_sptr,y);
    if ((res <= (int64_t)0)) {
        if (!!((uint64_t)((*y).hasref))) {
            pc_pcfns_pc_unshare(y);
        };
    } else {
        if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
            pc_pcfns_pc_unshare(pc_decls_sptr);
        };
        (*pc_decls_sptr) = (*y);
    };
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_len_l_a_e_s_b_d(void) {
    int64_t length;
    length = (int64_t)((*(*pc_decls_sptr).objptr).ulist.length);
    pc_pcfns_pc_unshare(pc_decls_sptr);
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = length;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_len_m_k(void) {
    int64_t length;
    length = (int64_t)(pc_decls_ttlength[((int64_t)((*pc_decls_sptr).tag))]);
    pc_pcfns_pc_unshare(pc_decls_sptr);
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = length;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_len_n(void) {
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = (((int64_t)((*pc_decls_sptr).range_upper) - (int64_t)((*pc_decls_sptr).range_lower)) + (int64_t)1);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_len_z(void) {
    if (((int64_t)((*pc_decls_sptr).tag)==(int64_t)7)) {
        (*pc_decls_sptr).value = pc_bignum_bx_length(pc_decls_sptr);
    }else if (((int64_t)((*pc_decls_sptr).tag)==(int64_t)10)) {
        (*pc_decls_sptr).value = ((int64_t)((uint64_t)((*(*pc_decls_sptr).objptr).udict.allocated)) / (int64_t)2);
    }else if (((int64_t)((*pc_decls_sptr).tag)==(int64_t)1)) {
        (*pc_decls_sptr).value = (int64_t)64;
        (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    } else {
        pc_support_pcustype((uint8_t*)"len_def",pc_decls_sptr);
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_lwb_l(void) {
    int64_t n;
    struct pc_decls_objrec *  p;
    p = (*pc_decls_sptr).objptr;
    n = (int64_t)((*p).ulist.lower);
    pc_pcfns_pc_unshare(pc_decls_sptr);
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = n;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_lwb_a_b(void) {
    int64_t n;
    struct pc_decls_objrec *  p;
    p = (*pc_decls_sptr).objptr;
    n = (int64_t)((*p).uarray.lower);
    pc_pcfns_pc_unshare(pc_decls_sptr);
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = n;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_lwb_s_m_k_d(void) {
    pc_pcfns_pc_unshare(pc_decls_sptr);
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = (int64_t)1;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_lwb_e(void) {
    pc_pcfns_pc_unshare(pc_decls_sptr);
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = (int64_t)0;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_lwb_n(void) {
    (*pc_decls_sptr).value = (int64_t)((*pc_decls_sptr).range_lower);
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_lwb_z(void) {
    if (((int64_t)((*pc_decls_sptr).tag)==(int64_t)1)) {
        (*pc_decls_sptr).value = (int64_t)0;
        (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    } else {
        pc_support_pcustype((uint8_t*)"lwb_def",pc_decls_sptr);
    };
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_upb_l(void) {
    int64_t n;
    struct pc_decls_objrec *  p;
    p = (*pc_decls_sptr).objptr;
    n = (int64_t)((uint32_t)((((int64_t)((uint64_t)((*p).ulist.length)) + (int64_t)((*p).ulist.lower)) - (int64_t)1)));
    pc_pcfns_pc_unshare(pc_decls_sptr);
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = n;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_upb_a_b(void) {
    int64_t n;
    struct pc_decls_objrec *  p;
    p = (*pc_decls_sptr).objptr;
    n = (int64_t)((uint32_t)((((int64_t)((uint64_t)((*p).uarray.length)) + (int64_t)((*p).uarray.lower)) - (int64_t)1)));
    pc_pcfns_pc_unshare(pc_decls_sptr);
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = n;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_upb_s_d(void) {
    int64_t n;
    n = (int64_t)((*(*pc_decls_sptr).objptr).ustr.length);
    pc_pcfns_pc_unshare(pc_decls_sptr);
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = n;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_upb_m_k(void) {
    int64_t n;
    n = (int64_t)(pc_decls_ttlength[((int64_t)((*pc_decls_sptr).tag))]);
    pc_pcfns_pc_unshare(pc_decls_sptr);
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = n;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_upb_e(void) {
    int64_t n;
    n = ((int64_t)((uint64_t)((*(*pc_decls_sptr).objptr).uset.length)) - (int64_t)1);
    pc_pcfns_pc_unshare(pc_decls_sptr);
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = n;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_upb_n(void) {
    (*pc_decls_sptr).value = (int64_t)((*pc_decls_sptr).range_upper);
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_upb_z(void) {
    if (((int64_t)((*pc_decls_sptr).tag)==(int64_t)10)) {
        (*pc_decls_sptr).value = ((int64_t)((uint64_t)((*(*pc_decls_sptr).objptr).udict.allocated)) / (int64_t)2);
    }else if (((int64_t)((*pc_decls_sptr).tag)==(int64_t)1)) {
        (*pc_decls_sptr).value = (int64_t)63;
    } else {
        pc_support_pcustype((uint8_t*)"upb_def",pc_decls_sptr);
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_bounds_l_a_b_s_e(void) {
    int64_t a;
    int64_t b;
    struct pc_decls_objrec *  r;
    r = (*pc_decls_sptr).objptr;
    if (((int64_t)(pc_decls_ttbasetype[((int64_t)((*pc_decls_sptr).tag))])==(int64_t)5) || ((int64_t)(pc_decls_ttbasetype[((int64_t)((*pc_decls_sptr).tag))])==(int64_t)32) || ((int64_t)(pc_decls_ttbasetype[((int64_t)((*pc_decls_sptr).tag))])==(int64_t)33)) {
        a = (int64_t)1;
    }else if (((int64_t)(pc_decls_ttbasetype[((int64_t)((*pc_decls_sptr).tag))])==(int64_t)9)) {
        a = (int64_t)0;
    }else if (((int64_t)(pc_decls_ttbasetype[((int64_t)((*pc_decls_sptr).tag))])==(int64_t)30) || ((int64_t)(pc_decls_ttbasetype[((int64_t)((*pc_decls_sptr).tag))])==(int64_t)31)) {
        a = (int64_t)((*r).uarray.lower);
    } else {
        a = (int64_t)((*r).ulist.lower);
    };
    b = (((int64_t)((uint64_t)((*r).ulist.length)) + a) - (int64_t)1);
    if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
        pc_pcfns_pc_unshare(pc_decls_sptr);
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)4);
    (*pc_decls_sptr).range_lower = a;
    (*pc_decls_sptr).range_upper = b;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_bounds_m_k(void) {
    int64_t b;
    b = (int64_t)(pc_decls_ttlength[((int64_t)((*pc_decls_sptr).tag))]);
    pc_pcfns_pc_unshare(pc_decls_sptr);
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)4);
    (*pc_decls_sptr).range_lower = (int64_t)1;
    (*pc_decls_sptr).range_upper = b;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_bounds_n(void) {
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_bounds_z(void) {
    if (((int64_t)((*pc_decls_sptr).tag)==(int64_t)1)) {
        (*pc_decls_sptr).tagx = (uint64_t)((int64_t)4);
        (*pc_decls_sptr).range_lower = (int64_t)0;
        (*pc_decls_sptr).range_upper = (int64_t)63;
    } else {
        pc_support_pcustype((uint8_t*)"bounds_def",pc_decls_sptr);
    };
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_minto_i(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).value=((*x).value<(*y).value?(*x).value:(*y).value);
;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_minto_r(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).xvalue=((*x).xvalue<(*y).xvalue?(*x).xvalue:(*y).xvalue);
;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_minto_z(void) {
    pc_support_pcmxtypes((uint8_t*)"minto_def",(*(pc_decls_sptr + (int64_t)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_maxto_i(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).value=((*x).value>(*y).value?(*x).value:(*y).value);
;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_maxto_r(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).xvalue=((*x).xvalue>(*y).xvalue?(*x).xvalue:(*y).xvalue);
;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_maxto_z(void) {
    pc_support_pcmxtypes((uint8_t*)"maxto_def",(*(pc_decls_sptr + (int64_t)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_neg_i_w(void) {
    (*pc_decls_sptr).value = -((*pc_decls_sptr).value);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_neg_r(void) {
    (*pc_decls_sptr).xvalue = -((*pc_decls_sptr).xvalue);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_neg_j(void) {
    pc_pcfns_pc_duplvar(pc_decls_sptr);
    pc_bignum_bx_negto(pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_neg_e(void) {
    pc_dxfns_dx_inotset(pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_neg_z(void) {
    pc_support_pcustype((uint8_t*)"neg_def",pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_abs_i_w(void) {
    (*pc_decls_sptr).value = labs((*pc_decls_sptr).value);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_abs_r(void) {
    (*pc_decls_sptr).xvalue = fabs((*pc_decls_sptr).xvalue);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_abs_j(void) {
    pc_pcfns_pc_duplvar(pc_decls_sptr);
    pc_bignum_bx_absto(pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_abs_z(void) {
    pc_support_pcustype((uint8_t*)"abs_def",pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_inot_i_w(void) {
    (*pc_decls_sptr).value = ~((*pc_decls_sptr).value);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_inot_e(void) {
    pc_dxfns_dx_inotset(pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_inot_z(void) {
    pc_support_pcustype((uint8_t*)"inot_def",pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_istrue_i_w_r(void) {
    (*pc_decls_sptr).tag = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = !!((*pc_decls_sptr).value);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_istrue_l_a_e_s_b(void) {
    int64_t res;
    res = ((int64_t)((uint64_t)((*(*pc_decls_sptr).objptr).ulist.length)) != (int64_t)0);
    pc_pcfns_pc_unshare(pc_decls_sptr);
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = res;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_istrue_k_m_h(void) {
    if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
        pc_pcfns_pc_unshare(pc_decls_sptr);
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = (int64_t)1;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_istrue_j(void) {
    pc_support_junimpl((uint8_t*)"istrue_longint");
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_istrue_z(void) {
    pc_support_pcustype((uint8_t*)"istrue_def",pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_jumpfalse_i_w_r_v_p_f(void) {
    if (!(!!((*pc_decls_sptr).value))) {
        ++pc_decls_sptr;
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    ++pc_decls_sptr;
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumpfalse_s_l_e_a_b(void) {
    int64_t n;
    n = (int64_t)((*(*pc_decls_sptr).objptr).ulist.length);
    pc_pcfns_pc_unshare(pc_decls_sptr);
    ++pc_decls_sptr;
    if ((n == (int64_t)0)) {
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumpfalse_z(void) {
    switch ((int64_t)(pc_decls_ttbasetype[((int64_t)((*pc_decls_sptr).tag))])) {
    case 32:;
    case 33:;
    case 25:;
    {
        ++pc_decls_sptr;
        return (pc_decls_pcptr + (int64_t)2);
    }break;
    default: {
    }
    } //SW
;
    pc_support_pcustype((uint8_t*)"jumpfalse_def",pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumptrue_i_r_w_v_p_f(void) {
    if (!!((*pc_decls_sptr).value)) {
        ++pc_decls_sptr;
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    ++pc_decls_sptr;
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumptrue_s_l_e_a_b(void) {
    int64_t n;
    n = (int64_t)((*(*pc_decls_sptr).objptr).ulist.length);
    pc_pcfns_pc_unshare(pc_decls_sptr);
    ++pc_decls_sptr;
    if (!!(n)) {
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    };
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_jumptrue_z(void) {
    switch ((int64_t)(pc_decls_ttbasetype[((int64_t)((*pc_decls_sptr).tag))])) {
    case 32:;
    case 33:;
    case 25:;
    {
        ++pc_decls_sptr;
        return (int64_t *)((*(pc_decls_pcptr + (int64_t)1)));
    }break;
    default: {
    }
    } //SW
;
    pc_support_pcustype((uint8_t*)"jumptrue_def",pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)2);
}

int64_t * pc_jhandlers_j_shl_i_w(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).value = ((*pc_decls_sptr).value << (*y).value);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_shl_z(void) {
    pc_support_pcmxtypes((uint8_t*)"shl_def",(pc_decls_sptr + (int64_t)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_shr_i_w(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).value = ((*pc_decls_sptr).value >> (*y).value);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_shr_j_i(void) {
    pc_support_pcerror((uint8_t*)"SHR/J/I");
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_shr_z(void) {
    pc_support_pcmxtypes((uint8_t*)"shr_def",(pc_decls_sptr + (int64_t)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_shr_wi(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).uvalue = ((*pc_decls_sptr).uvalue >> (*y).value);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_shr_zz(void) {
    return pc_support_pcmxtypes((uint8_t*)"shr_zz",(pc_decls_sptr + (int64_t)1),pc_decls_sptr);
}

int64_t * pc_jhandlers_j_idiv_w(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).uvalue = ((*pc_decls_sptr).uvalue / (*y).uvalue);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_idiv_j(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    struct pc_decls_varrec result;
    y = pc_decls_sptr++;
    x = pc_decls_sptr;
    pc_bignum_bx_idiv(x,y,&result);
    if (!!((uint64_t)((*x).hasref))) {
        pc_pcfns_pc_unshare(x);
    };
    if (!!((uint64_t)((*y).hasref))) {
        pc_pcfns_pc_unshare(y);
    };
    (*pc_decls_sptr) = result;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_idiv_z(void) {
    pc_support_pcmxtypes((uint8_t*)"idiv_def",(pc_decls_sptr + (int64_t)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_rem_w(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).uvalue = ((*pc_decls_sptr).uvalue % (*y).uvalue);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_rem_j(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    struct pc_decls_varrec result;
    y = pc_decls_sptr++;
    x = pc_decls_sptr;
    pc_bignum_bx_irem(x,y,&result);
    if (!!((uint64_t)((*x).hasref))) {
        pc_pcfns_pc_unshare(x);
    };
    if (!!((uint64_t)((*y).hasref))) {
        pc_pcfns_pc_unshare(y);
    };
    (*pc_decls_sptr) = result;
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t * pc_jhandlers_j_remz(void) {
    pc_support_pcmxtypes((uint8_t*)"rem_def",(pc_decls_sptr + (int64_t)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64_t)1);
}

int64_t pc_oslayer_runproc_m(void * amsg) {
    struct pc_decls_varrec a;
    struct pc_decls_varrec dest;
    static int64_t rmsg_typeno;
    int64_t i;
    int64_t result;
    struct pc_decls_objrec obj;
    if ((rmsg_typeno == (int64_t)0)) {
        L650 :;
        for (i=(int64_t)1;i<=pc_decls_ntypes;i+=(int64_t)1) {
L651 :;
            if (!!(mlib_eqstring(pc_decls_ttname[(i)],(((int64_t)64 == (int64_t)32)?(uint8_t*)"ws_msg32":(uint8_t*)"ws_msg64")))) {
                rmsg_typeno = i;
                goto L653 ;
            };
L652 :;
        }L653 :;
        ;
    };
    if ((rmsg_typeno == (int64_t)0)) {
        mlib_abortprogram((uint8_t*)"mainwndproc: can't find rmsg");
    };
    memset((void *)(&obj),(int64_t)0,(uint64_t)((int64_t)32));
    obj.refcount = (uint64_t)((int64_t)99);
    obj.ustruct.ptr = (byte *)(amsg);
    a.tagx = (uint64_t)((rmsg_typeno | (int64_t)65536));
    a.objptr = &obj;
    pci_runproc((void *)(pc_decls_pcl_callbackfn),&a,(struct pc_decls_varrec *)(0),&dest);
    result = dest.value;
    result = (int64_t)0;
    return result;
}

void pc_oslayer_os_getconsize(struct pc_decls_varrec * result) {
    pc_support_pcerror((uint8_t*)"GETCONSIZE");
}

void pc_oslayer_pch_setmesshandler(struct pc_decls_varrec * fn) {
    if (((int64_t)((uint64_t)((*fn).tag)) != (int64_t)18)) {
        pc_support_pcerror((uint8_t*)"Not refproc");
    };
    pc_decls_pcl_callbackfn = (void (*)(void))((*fn).refptr);
    osnos_os_setmesshandler((void *)(&pc_oslayer_runproc_m));
}

void pc_oslayer_pch_gethostname(struct pc_decls_varrec * result) {
    static uint8_t name[256];
    strcpy((int8_t *)(name),(int8_t *)(osnos_os_gethostname()));
    pc_pcfns_pc_makestring(name,(int64_t)-1,result);
}

void pc_oslayer_os_initdllmodules(void) {
    int64_t i;
    int64_t hinst;
    uint8_t *  dllname;
    L654 :;
    for (i=(int64_t)1;i<=pc_decls_ndlltable;i+=(int64_t)1) {
L655 :;
        dllname = pc_decls_dlltable[(i)-1];
        hinst = pc_oslayer_os_loaddllmodule(dllname);
        if ((hinst == (int64_t)0)) {
        };
        pc_decls_dllinsttable[(i)-1] = (uint64_t)(hinst);
L656 :;
    }L657 :;
    ;
}

int64_t pc_oslayer_os_loaddllmodule(uint8_t * dllname) {
    int64_t hinst;
    if (!!(mlib_eqstring(dllname,(uint8_t*)"jpeglib"))) {
        dllname = (uint8_t*)"jpeglib64";
    } else if (!!(mlib_eqstring(dllname,(uint8_t*)"jpeglibc"))) {
        dllname = (uint8_t*)"jpeglibc64";
    };
    hinst = (int64_t)(osnos_os_getdllinst(dllname));
    return hinst;
}

void pc_oslayer_os_initdllfunctions(void) {
    void (*fnaddr)(void);
    int64_t hinst;
    int64_t i;
    int64_t dllmodno;
    L658 :;
    for (i=(int64_t)1;i<=pc_decls_ndllproctable;i+=(int64_t)1) {
L659 :;
        dllmodno = (int64_t)(pc_decls_dllproctable[(i)-1].dllindex);
        hinst = (int64_t)(pc_decls_dllinsttable[(dllmodno)-1]);
        fnaddr = osnos_os_getdllprocaddr(hinst,pc_decls_dllproctable[(i)-1].name);
        if ((fnaddr == 0)) {
            if ((hinst == (int64_t)0)) {
                goto L660 ;
            };
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"dllfns: fnaddr=0:",NULL);
            msysnewc_m_print_str(pc_decls_dllproctable[(i)-1].name,NULL);
            msysnewc_m_print_str((uint8_t*)"from",NULL);
            msysnewc_m_print_str(pc_decls_dlltable[(dllmodno)-1],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
        pc_decls_dllproctable[(i)-1].address = fnaddr;
L660 :;
    }L661 :;
    ;
}

void * pc_oslayer_os_loaddllfunction(int64_t fnindex) {
    int64_t dllmodno;
    int64_t hinst;
    void (*fnaddr)(void);
    dllmodno = (int64_t)(pc_decls_dllproctable[(fnindex)-1].dllindex);
    hinst = (int64_t)(pc_decls_dllinsttable[(dllmodno)-1]);
    if (!(!!(hinst))) {
        hinst = pc_oslayer_os_loaddllmodule(pc_decls_dlltable[(dllmodno)-1]);
        if (!(!!(hinst))) {
        } else {
            pc_decls_dllinsttable[(dllmodno)-1] = (uint64_t)(hinst);
        };
    };
    fnaddr = osnos_os_getdllprocaddr(hinst,pc_decls_dllproctable[(fnindex)-1].name);
    if (!(!!(fnaddr))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(pc_decls_dllproctable[(fnindex)-1].name,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        pc_support_pcerror((uint8_t*)"Can't find DLL function");
        exit((int64_t)1);
    } else {
        pc_decls_dllproctable[(fnindex)-1].address = fnaddr;
    };
    return (void *)(fnaddr);
}

void pc_oslayer_pch_getos(struct pc_decls_varrec * result) {
    pc_pcfns_pc_makestring(osnos_os_getos(),(int64_t)-1,result);
}

void pc_oslayer_pch_gethostsize(struct pc_decls_varrec * result) {
    (*result).tagx = (uint64_t)((int64_t)1);
    (*result).value = osnos_os_gethostsize();
}

void pc_oslayer_pch_iswindows(struct pc_decls_varrec * result) {
    (*result).tagx = (uint64_t)((int64_t)1);
    (*result).value = osnos_os_iswindows();
}

void pc_oslayer_os_calldll(int64_t calltype,int64_t fnindex,int64_t offset,int64_t nparams,int64_t restype,struct pc_decls_varrec * dest) {
    int64_t baserestype;
    void (*fnaddr)(void);
    int64_t retval;
    int64_t retcode;
    int64_t (*iparams)[];
    int16_t (*iparamtypes)[];
    byte paramcodes[100];
    int64_t i;
    fnaddr = pc_decls_dllproctable[(fnindex)-1].address;
    if (!(!!(fnaddr))) {
        fnaddr = (void (*)(void))(pc_oslayer_os_loaddllfunction(fnindex));
        if (!!(fnaddr)) {
            pc_decls_dllproctable[(fnindex)-1].address = fnaddr;
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(pc_decls_dllproctable[(fnindex)-1].name,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            pc_support_pcerror((uint8_t*)"Calldll nil fn:");
        };
    };
    iparams = (int64_t (*)[])(&pc_decls_dllparams[((offset + (int64_t)1))-1]);
    iparamtypes = (int16_t (*)[])(&pc_decls_dlltypes[((offset + (int64_t)1))-1]);
    L662 :;
    for (i=(int64_t)1;i<=nparams;i+=(int64_t)1) {
L663 :;
        if (((int64_t)(pc_decls_ttbasetype[((int64_t)((*iparamtypes)[(i)-1]))]) == (int64_t)3)) {
            paramcodes[(i)-1] = (uint64_t)82u;
        } else {
            paramcodes[(i)-1] = (uint64_t)73u;
        };
L664 :;
    }L665 :;
    ;
    baserestype = (int64_t)(pc_decls_ttbasetype[(restype)]);
    retcode = ((baserestype == (int64_t)49)?(int64_t)82:(int64_t)73);
    retval = (int64_t)(osnosdll_os_calldllfunction(fnaddr,retcode,nparams,iparams,&paramcodes));
    switch (baserestype) {
    case 0:;
    {
    }break;
    case 3:;
    case 49:;
    {
        (*dest).tagx = (uint64_t)((int64_t)3);
        (*dest).xvalue = *(double*)&retval;
    }break;
    case 48:;
    {
        pc_support_pcerror((uint8_t*)"dll/r32ret");
    }break;
    case 40:;
    case 47:;
    case 50:;
    case 51:;
    case 52:;
    {
        (*dest).tagx = (uint64_t)((int64_t)1);
        (*dest).value = retval;
    }break;
    case 39:;
    {
        (*dest).tagx = (uint64_t)((int64_t)1);
        (*dest).value = (int64_t)((int32_t)(retval));
    }break;
    case 46:;
    {
        (*dest).tagx = (uint64_t)((int64_t)1);
        (*dest).value = (int64_t)((uint32_t)(retval));
    }break;
    case 38:;
    {
        (*dest).tagx = (uint64_t)((int64_t)1);
        (*dest).value = (int64_t)((int16_t)(retval));
    }break;
    case 45:;
    {
        (*dest).tagx = (uint64_t)((int64_t)1);
        (*dest).value = (int64_t)((uint16_t)(retval));
    }break;
    case 23:;
    {
        (*dest).tagx = (uint64_t)((int64_t)23);
        (*dest).uref.ptr = (byte *)(retval);
        (*dest).uref.elemtag = (uint64_t)(pc_decls_tttarget[(restype)]);
    }break;
    default: {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(pc_decls_ttname[(baserestype)],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        pc_support_pcerror((uint8_t*)"Rettype not supported");
    }
    } //SW
;
}

uint64_t osnosdll_os_calldllfunction(void (*fnaddr)(void),int64_t retcode,int64_t nargs,int64_t (*args)[],byte (*argcodes)[]) {
    return (uint64_t)((int64_t)0);
}

uint64_t osnosdll_os_pushargs(uint64_t (*args)[],int64_t nargs,int64_t nextra,void (*fnaddr)(void),int64_t isfloat) {
    return (uint64_t)((int64_t)0);
}

void pc_host_callhostfunction(int64_t hostfn,int64_t calledasfn) {
    void (*fnaddr)(void);
    int64_t nparams;
    int64_t isfn;
    int64_t av_1;
    fnaddr = (void (*)(void))(pc_host_hosttable[(hostfn)-1]);
    nparams = pq_common_hostnparams[(hostfn)];
    isfn = pq_common_hostisfn[(hostfn)];
    if (!!(isfn)) {
        switch (nparams) {
        case 0:;
        {
            ((*(void (*)(struct pc_decls_varrec *))(fnaddr)))(pc_decls_sptr);
        }break;
        case 1:;
        {
            ((*(void (*)(struct pc_decls_varrec *,struct pc_decls_varrec *))(fnaddr)))(pc_decls_sptr,(pc_decls_sptr + (int64_t)1));
        }break;
        case 2:;
        {
            ((*(void (*)(struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_varrec *))(fnaddr)))(pc_decls_sptr,(pc_decls_sptr + (int64_t)1),(pc_decls_sptr + (int64_t)2));
        }break;
        case 3:;
        {
            ((*(void (*)(struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_varrec *))(fnaddr)))(pc_decls_sptr,(pc_decls_sptr + (int64_t)1),(pc_decls_sptr + (int64_t)2),(pc_decls_sptr + (int64_t)3));
        }break;
        case 4:;
        {
            ((*(void (*)(struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_varrec *))(fnaddr)))(pc_decls_sptr,(pc_decls_sptr + (int64_t)1),(pc_decls_sptr + (int64_t)2),(pc_decls_sptr + (int64_t)3),(pc_decls_sptr + (int64_t)4));
        }break;
        default: {
            pc_support_pcerror((uint8_t*)"callhost/fn");
        }
        } //SW
;
    } else {
        switch (nparams) {
        case 0:;
        {
            ((*fnaddr))();
        }break;
        case 1:;
        {
            ((*(void (*)(struct pc_decls_varrec *))(fnaddr)))(pc_decls_sptr);
        }break;
        case 2:;
        {
            ((*(void (*)(struct pc_decls_varrec *,struct pc_decls_varrec *))(fnaddr)))(pc_decls_sptr,(pc_decls_sptr + (int64_t)1));
        }break;
        case 3:;
        {
            ((*(void (*)(struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_varrec *))(fnaddr)))(pc_decls_sptr,(pc_decls_sptr + (int64_t)1),(pc_decls_sptr + (int64_t)2));
        }break;
        case 4:;
        {
            ((*(void (*)(struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_varrec *))(fnaddr)))(pc_decls_sptr,(pc_decls_sptr + (int64_t)1),(pc_decls_sptr + (int64_t)2),(pc_decls_sptr + (int64_t)3));
        }break;
        default: {
            pc_support_pcerror((uint8_t*)"callhost/proc");
        }
        } //SW
;
    };
    av_1 = nparams;
    while (av_1-- > 0) {
L666 :;
        if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
            pc_pcfns_pc_unshare(pc_decls_sptr);
        };
        ++pc_decls_sptr;
L667 :;
    }L668 :;
    ;
}

static void pc_host_pch_leftstr(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c,struct pc_decls_varrec * result) {
    int64_t n;
    int64_t length;
    int64_t padchar;
    uint8_t *  s;
    struct pc_decls_objrec *  pa;
    padchar = (int64_t)32;
    if (((int64_t)((*c).tag)==(int64_t)0)) {
    }else if (((int64_t)((*c).tag)==(int64_t)5)) {
        if (((int64_t)((*(*c).objptr).ustr.length) == (int64_t)1)) {
            padchar = (int64_t)((*(*(*c).objptr).ustr.strptr));
        } else {
            pc_support_pcerror((uint8_t*)"left/padx");
        };
    }else if (((int64_t)((*c).tag)==(int64_t)1)) {
        padchar = (*c).value;
    } else {
        pc_support_pcerror((uint8_t*)"left/pad?");
    };
    if (((int64_t)((*b).tag)==(int64_t)0)) {
        n = (int64_t)1;
    }else if (((int64_t)((*b).tag)==(int64_t)1)) {
        n = (*b).value;
    } else {
        pc_support_pcerror((uint8_t*)"left:bad n");
    };
    if (((int64_t)((uint64_t)((*a).tag)) != (int64_t)5)) {
        pc_support_pcerror((uint8_t*)"left:not str");
    };
    pa = (*a).objptr;
    length = (int64_t)((*pa).ustr.length);
    s = (*pa).ustr.strptr;
    if ((n == (int64_t)0)) {
        pc_pcfns_pc_emptystring(result);
        return;
    };
    (*result).tagx = (uint64_t)((int64_t)65541);
    if ((n > (int64_t)0)) {
        if ((n <= length)) {
            pc_host_leftstring(a,n,result);
        } else {
            pc_host_padstring_right(a,n,padchar,result);
        };
    } else {
        n = -(n);
        if ((n < length)) {
            pc_host_leftstring(a,(length - n),result);
        } else {
            pc_pcfns_pc_emptystring(result);
        };
    };
}

static void pc_host_pch_rightstr(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c,struct pc_decls_varrec * result) {
    int64_t n;
    int64_t length;
    int64_t padchar;
    uint8_t *  s;
    struct pc_decls_objrec *  pa;
    padchar = (int64_t)32;
    if (((int64_t)((*c).tag)==(int64_t)0)) {
    }else if (((int64_t)((*c).tag)==(int64_t)5)) {
        if (((int64_t)((*(*c).objptr).ustr.length) == (int64_t)1)) {
            padchar = (int64_t)((*(*(*c).objptr).ustr.strptr));
        } else {
            pc_support_pcerror((uint8_t*)"right/padx");
        };
    }else if (((int64_t)((*c).tag)==(int64_t)1)) {
        padchar = (*c).value;
    } else {
        pc_support_pcerror((uint8_t*)"right/pad?");
    };
    if (((int64_t)((*b).tag)==(int64_t)0)) {
        n = (int64_t)1;
    }else if (((int64_t)((*b).tag)==(int64_t)1)) {
        n = (*b).value;
    } else {
        pc_support_pcerror((uint8_t*)"right:bad n");
    };
    pa = (*a).objptr;
    if (((int64_t)((uint64_t)((*a).tag)) != (int64_t)5)) {
        pc_support_pcerror((uint8_t*)"right:not str");
    };
    length = (int64_t)((*pa).ustr.length);
    s = (*pa).ustr.strptr;
    (*result).tagx = (uint64_t)((int64_t)65541);
    if ((n == (int64_t)0)) {
        pc_pcfns_pc_emptystring(result);
        return;
    };
    if ((n > (int64_t)0)) {
        if ((n <= length)) {
            pc_host_rightstring(a,n,result);
        } else {
            pc_host_padstring_left(a,n,padchar,result);
        };
    } else {
        n = -(n);
        if ((n < length)) {
            pc_host_rightstring(a,(length - n),result);
        } else {
            pc_pcfns_pc_emptystring(result);
        };
    };
}

static void pc_host_pch_convlc(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result) {
    pc_host_checkparam(a,(int64_t)5,(int64_t)-999999);
    (*result) = (*a);
    ++(*(*result).objptr).refcount;
    if (!!((uint64_t)((*result).hasref))) {
        pc_pcfns_pc_dupl(result);
    };
    pc_pcfns_pc_iconvcase(result,b,(int64_t)0);
}

static void pc_host_pch_convuc(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result) {
    pc_host_checkparam(a,(int64_t)5,(int64_t)-999999);
    (*result) = (*a);
    ++(*(*result).objptr).refcount;
    if (!!((uint64_t)((*result).hasref))) {
        pc_pcfns_pc_dupl(result);
    };
    pc_pcfns_pc_iconvcase(result,b,(int64_t)1);
}

static void pc_host_pch_iconvlc(struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    pc_host_checkparam(a,(int64_t)22,(int64_t)-999999);
    pc_pcfns_pc_iconvcase((*a).varptr,b,(int64_t)0);
}

static void pc_host_pch_iconvuc(struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    pc_host_checkparam(a,(int64_t)22,(int64_t)-999999);
    pc_pcfns_pc_iconvcase((*a).varptr,b,(int64_t)1);
}

static void pc_host_pch_stop(void) {
    pc_support_pcerror((uint8_t*)"host_stop not impl");
}

static void pc_host_pch_stopx(struct pc_decls_varrec * a) {
    pc_support_pcerror((uint8_t*)"host_stopx not impl");
}

static void pc_host_pch_ismain(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    int64_t mainmod;
    int64_t ismain;
    pc_host_checkparam(a,(int64_t)5,(int64_t)-999999);
    (*result).tagx = (uint64_t)((int64_t)1);
    if (!!(mlib_eqstring(pc_decls_strpclversion,(uint8_t*)"404"))) {
        mainmod = (int64_t)1;
    } else {
        mainmod = pc_decls_nmodules;
    };
    ismain = (pc_pcfns_cmpstring_len((*(*a).objptr).ustr.strptr,pc_decls_moduletable[(mainmod)].name,(int64_t)((*(*a).objptr).ustr.length),(int64_t)(strlen((int8_t *)(pc_decls_moduletable[(mainmod)].name)))) == (int64_t)0);
    (*result).value = ismain;
}

static void pc_host_pch_waitkey(struct pc_decls_varrec * result) {
    (*result).tagx = (uint64_t)((int64_t)1);
    (*result).value = osnos_os_getch();
}

static void pc_host_pch_testkey(struct pc_decls_varrec * result) {
    (*result).tagx = (uint64_t)((int64_t)1);
    (*result).value = osnos_os_kbhit();
}

static void pc_host_pch_execwait(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c,struct pc_decls_varrec * result) {
    uint8_t *  workdir;
    int64_t flag;
    struct pc_decls_objrec *  pa;
    pc_host_checkparam(a,(int64_t)5,(int64_t)-999999);
    pa = (*a).objptr;
    flag = pc_host_checkparam(b,(int64_t)1,(int64_t)0);
    if (((int64_t)((uint64_t)((*c).tag)) == (int64_t)0)) {
        workdir = (uint8_t *)(0);
    } else {
        pc_host_checkparam(c,(int64_t)5,(int64_t)-999999);
        workdir = pc_support_convcstring((*(*c).objptr).ustr.strptr,(int64_t)((*(*c).objptr).ustr.length));
    };
    (*result).tagx = (uint64_t)((int64_t)1);
    (*result).value = osnos_os_execwait(pc_support_convcstring((*pa).ustr.strptr,(int64_t)((*pa).ustr.length)),flag,workdir);
}

static void pc_host_pch_execcmd(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c,struct pc_decls_varrec * result) {
    uint8_t *  workdir;
    int64_t flag;
    struct pc_decls_objrec *  pa;
    pc_host_checkparam(a,(int64_t)5,(int64_t)-999999);
    pa = (*a).objptr;
    flag = pc_host_checkparam(b,(int64_t)1,(int64_t)0);
    if (((int64_t)((uint64_t)((*c).tag)) == (int64_t)0)) {
        workdir = (uint8_t *)(0);
    } else {
        pc_host_checkparam(c,(int64_t)5,(int64_t)-999999);
        workdir = pc_support_convcstring((*(*c).objptr).ustr.strptr,(int64_t)((*(*c).objptr).ustr.length));
    };
    (*result).tagx = (uint64_t)((int64_t)1);
    (*result).value = osnos_os_execcmd(pc_support_convcstring((*pa).ustr.strptr,(int64_t)((*pa).ustr.length)),flag);
}

static void pc_host_pch_makestr(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result) {
    int64_t n;
    struct pc_decls_objrec *  s;
    switch ((int64_t)((*a).tag)) {
    case 23:;
    {
    }break;
    case 1:;
    {
    }break;
    default: {
        pc_support_pcerror((uint8_t*)"makestr");
    }
    } //SW
;
    n = pc_support_getintvalue(b);
    (*result).tagx = (uint64_t)((int64_t)65541);
    s = pc_objlib_make_strslicexobj((uint8_t *)((*a).uref.ptr),n);
    (*result).objptr = s;
}

static void pc_host_pch_makestrslice(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result) {
    pc_support_pcerror((uint8_t*)"MAKESTRSLICE");
}

static void pc_host_pch_makeref(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result) {
    byte *  ptr;
    switch ((int64_t)(pc_decls_ttbasetype[((int64_t)((*a).tag))])) {
    case 22:;
    case 23:;
    case 1:;
    {
        ptr = (*a).uref.ptr;
    }break;
    case 5:;
    case 30:;
    case 29:;
    case 9:;
    {
        ptr = (*(*a).objptr).uarray.ptr;
    }break;
    default: {
        pc_support_pcerror((uint8_t*)"makeref");
    }
    } //SW
;
    (*result).tagx = (uint64_t)((int64_t)23);
    (*result).uref.ptr = ptr;
    (*result).uref.elemtag = (uint64_t)(pc_support_getintvalue(b));
    if (((int64_t)((*result).uref.elemtag)==(int64_t)41) || ((int64_t)((*result).uref.elemtag)==(int64_t)42) || ((int64_t)((*result).uref.elemtag)==(int64_t)43)) {
        (*result).tag = (uint64_t)((int64_t)24);
        (*result).uref.bitoffset = (uint64_t)((int64_t)0);
        (*result).uref.bitlength = (uint64_t)((int64_t)0);
    };
}

static void pc_host_pch_new(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c,struct pc_decls_varrec * d,struct pc_decls_varrec * result) {
    struct pc_decls_varrec v;
    int64_t t;
    int64_t offset;
    int64_t elemtype;
    int64_t n;
    struct pc_host_dimrec dims;
    struct pc_decls_varrec *  qvar;
    byte *  qbyte;
    struct pc_decls_objrec *  p;
    int64_t av_1;
    int64_t av_2;
    int64_t av_3;
    int64_t av_4;
    t = pc_support_getintvalue(a);
    if (((t < (int64_t)0) || (t > pc_decls_ntypes))) {
        pc_support_pcustypet((uint8_t*)"New:bad type",t);
    };
    v.tagx = (uint64_t)((t | (int64_t)65536));
    switch ((int64_t)(pc_decls_ttbasetype[(t)])) {
    case 29:;
    {
        pc_host_getbounds(b,&dims,(int64_t)1);
        p = pc_objlib_list_new(dims.length,dims.lbound,(struct pc_decls_varrec *)(0));
        v.objptr = p;
        if (!!(dims.length)) {
            if ((!!(c) && ((int64_t)((uint64_t)((*c).tag)) != (int64_t)0))) {
                qvar = (*p).ulist.vptr;
                av_1 = dims.length;
                while (av_1-- > 0) {
L669 :;
                    (*qvar) = (*c);
                    if (!!((uint64_t)((*qvar).hasref))) {
                        pc_pcfns_pc_share(qvar);
                    };
                    ++qvar;
L670 :;
                }L671 :;
                ;
            };
        };
    }break;
    case 30:;
    {
        if (!!((uint64_t)(pc_decls_ttlength[(t)]))) {
            elemtype = (int64_t)(pc_decls_tttarget[(t)]);
            dims.length = (int64_t)(pc_decls_ttlength[(t)]);
            dims.lbound = (int64_t)(pc_decls_ttlower[(t)]);
            dims.upper = ((dims.length + dims.lbound) - (int64_t)1);
            d = b;
            goto L672 ;
;
        };
        elemtype = pc_support_getintvalue(b);
        pc_host_getbounds(c,&dims,(int64_t)1);
        if (((elemtype >= (int64_t)41) && (elemtype <= (int64_t)43))) {
            v.tag = (uint64_t)((t = (int64_t)31));
            goto L673 ;
;
        };
        //doarray2:
L672 :;
;
        p = pc_objlib_array_new(t,elemtype,dims.length,dims.lbound);
        v.objptr = p;
        if (!!(dims.length)) {
            if ((!!(d) && ((int64_t)((uint64_t)((*d).tag)) != (int64_t)0))) {
                qbyte = (*p).uarray.ptr;
                av_2 = dims.length;
                while (av_2-- > 0) {
L674 :;
                    pc_pcfns_pc_storepacked(qbyte,d,elemtype);
                    qbyte += pc_decls_ttsize[(elemtype)];
L675 :;
                }L676 :;
                ;
            };
        };
    }break;
    case 31:;
    {
        if (!!((uint64_t)(pc_decls_ttlength[(t)]))) {
            elemtype = (int64_t)(pc_decls_tttarget[(t)]);
            dims.length = (int64_t)(pc_decls_ttlength[(t)]);
            dims.lbound = (int64_t)(pc_decls_ttlower[(t)]);
            dims.upper = ((dims.length + dims.lbound) - (int64_t)1);
            d = b;
            goto L673 ;
;
        };
        elemtype = pc_support_getintvalue(b);
        if (((elemtype < (int64_t)41) || (elemtype > (int64_t)43))) {
            pc_support_pcerror((uint8_t*)"new: bad bits elem");
        };
        pc_host_getbounds(c,&dims,(int64_t)1);
        //dobits2:
L673 :;
;
        p = pc_objlib_bits_new(elemtype,dims.length,dims.lbound);
        v.objptr = p;
        if (!!(dims.length)) {
            if ((!!(d) && ((int64_t)((uint64_t)((*d).tag)) != (int64_t)0))) {
                qbyte = (*p).ubits.ptr;
                offset = (int64_t)0;
                av_3 = dims.length;
                while (av_3-- > 0) {
L677 :;
                    pc_pcfns_pc_storebit(qbyte,offset,d,elemtype,(int64_t)0);
                    offset += (int64_t)(pc_decls_ttbitwidth[(elemtype)]);
                    if ((offset >= (int64_t)8)) {
                        offset = (int64_t)0;
                        ++qbyte;
                    };
L678 :;
                }L679 :;
                ;
            };
        };
    }break;
    case 9:;
    {
        pc_host_getbounds(b,&dims,(int64_t)0);
        if ((dims.lbound < (int64_t)0)) {
            pc_support_pcerror((uint8_t*)"new:set:lwb");
        };
        if ((dims.lbound != (int64_t)0)) {
            dims.lbound = (int64_t)0;
            dims.length = (dims.upper + (int64_t)1);
        };
        p = pc_objlib_set_new(dims.length,(int64_t)0);
        v.objptr = p;
    }break;
    case 32:;
    {
        p = pc_objlib_record_new(t);
        pc_objlib_objtovar(p,&v);
        if ((!!(b) && ((int64_t)((uint64_t)((*b).tag)) != (int64_t)0))) {
            qvar = (*p).urec.vptr;
            av_4 = (int64_t)(pc_decls_ttlength[(t)]);
            while (av_4-- > 0) {
L680 :;
                (*qvar) = (*b);
                if (!!((uint64_t)((*qvar).hasref))) {
                    pc_pcfns_pc_share(qvar);
                };
                ++qvar;
L681 :;
            }L682 :;
            ;
        };
    }break;
    case 33:;
    {
        p = pc_objlib_struct_new(t);
        pc_objlib_objtovar(p,&v);
        if ((!!(b) && ((int64_t)((uint64_t)((*b).tag)) != (int64_t)0))) {
            pc_support_pcerror((uint8_t*)"New: struct init");
        };
    }break;
    case 1:;
    case 2:;
    case 3:;
    case 18:;
    case 22:;
    {
        v.value = (int64_t)0;
        v.hasref = (uint64_t)((int64_t)0);
        if ((!!(b) && ((int64_t)((uint64_t)((*b).tag)) != (int64_t)0))) {
            pc_support_pcerror((uint8_t*)"NEW(int/value)");
        };
    }break;
    case 5:;
    {
        pc_host_getbounds(b,&dims,(int64_t)0);
        pc_pcfns_pc_makestringn(dims.length,&v);
    }break;
    case 10:;
    {
        pc_host_getbounds(b,&dims,(int64_t)1);
        n = pc_support_nextpoweroftwo(dims.length);
        p = pc_objlib_dict_new(n);
        (*p).udict.dictitems = (uint64_t)((int64_t)0);
        v.objptr = p;
    }break;
    default: {
        pc_support_pcustypet((uint8_t*)"new",t);
    }
    } //SW
;
    //finish:
L683 :;
;
    (*result) = v;
}

static void pc_host_pch_newheap(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c,struct pc_decls_varrec * d,struct pc_decls_varrec * result) {
    struct pc_decls_varrec *  p;
    p = (struct pc_decls_varrec *)(mlib_pcm_alloc((int64_t)16));
    pc_host_pch_new(a,b,c,d,p);
    (*result).tagx = (uint64_t)((int64_t)22);
    (*result).varptr = p;
}

static void pc_host_pch_heapvar(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    (*result).tagx = (uint64_t)((int64_t)1);
    (*result).value = (int64_t)12345678;
}

static void pc_host_pch_freeheap(struct pc_decls_varrec * a) {
    pc_support_pcerror((uint8_t*)"FREEHEAP");
}

static void pc_host_pch_getcmdparam(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    int64_t n;
    if (((int64_t)((uint64_t)((*a).tag)) == (int64_t)0)) {
        (*result).tagx = (uint64_t)((int64_t)1);
        (*result).value = (pc_decls_ncmdparams + (int64_t)1);
        return;
    };
    n = pc_support_getintvalue(a);
    pc_pcfns_pc_makestring(pc_decls_cmdparamtable[(n)],(int64_t)-1,result);
}

static void pc_host_pch_setpcerror(struct pc_decls_varrec * a) {
    struct pc_decls_objrec *  pa;
    pc_host_checkparam(a,(int64_t)5,(int64_t)-999999);
    pa = (*a).objptr;
    if (!!(pc_decls_pcerror_mess)) {
        free((void *)(pc_decls_pcerror_mess));
        pc_decls_pcerror_mess = (uint8_t *)(0);
    };
    if (!!((int64_t)((*pa).ustr.length))) {
        pc_decls_pcerror_mess = (uint8_t *)(malloc((uint64_t)(((int64_t)((*pa).ustr.length) + (int64_t)1))));
        memcpy((void *)(pc_decls_pcerror_mess),(void *)((*pa).ustr.strptr),(uint64_t)((*pa).ustr.length));
        (*(pc_decls_pcerror_mess + (int64_t)((*pa).ustr.length))) = (uint64_t)0u;
    };
}

static void pc_host_pch_setdebug(struct pc_decls_varrec * a) {
    pc_host_checkparam(a,(int64_t)1,(int64_t)-999999);
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"SETDEBUG.................",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mlib_fdebug = (*a).value;
}

static void pc_host_pch_setfprintf(struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    pc_host_checkparam(a,(int64_t)19,(int64_t)-999999);
    pc_host_checkparam(b,(int64_t)19,(int64_t)-999999);
    pc_decls_fprintf_ptr = (void (*)(void))((*a).refptr);
    pc_decls_fgets_ptr = (void (*)(void))((*b).refptr);
}

static void pc_host_pch_ticks(struct pc_decls_varrec * result) {
    (*result).tagx = (uint64_t)((int64_t)1);
    (*result).value = osnos_os_clock();
}

static void pc_host_pch_sleep(struct pc_decls_varrec * a) {
    pc_host_checkparam(a,(int64_t)1,(int64_t)-999999);
    osnos_os_sleep((*a).value);
}

static void pc_host_pch_random(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    int64_t n;
    int64_t x;
    (*result).tagx = (uint64_t)((int64_t)1);
    if (((int64_t)((uint64_t)((*a).tag)) == (int64_t)4)) {
        x = mlib_mrandomrange((int64_t)((*a).range_lower),(int64_t)((*a).range_upper));
    } else {
        pc_host_checkparam(a,(int64_t)1,(int64_t)-999999);
        n = (*a).value;
        if ((n > (int64_t)1)) {
            x = mlib_mrandomint(n);
        } else if ((n == (int64_t)0)) {
            x = (int64_t)(mlib_mrandom());
        } else if ((n == (int64_t)1)) {
            (*result).tagx = (uint64_t)((int64_t)3);
            (*result).xvalue = mlib_mrandomreal();
            return;
        } else {
        };
    };
    (*result).value = x;
}

static void pc_host_pch_findmetafunction(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    uint8_t *  sdata;
    struct pc_decls_objrec *  pa;
    struct pc_decls_strec *  d;
    int64_t av_1;
    pc_host_checkparam(a,(int64_t)5,(int64_t)-999999);
    pa = (*a).objptr;
    (*result).tagx = (uint64_t)((int64_t)18);
    (*result).value = (int64_t)0;
    if (!!((int64_t)((*pa).ustr.length))) {
        sdata = pc_support_convcstring((*pa).ustr.strptr,(int64_t)((*pa).ustr.length));
    } else {
        return;
    };
    d = &(*pc_decls_pcsymboltable)[((int64_t)1)-1];
    av_1 = pc_decls_nsymbols;
    while (av_1-- > 0) {
L684 :;
        if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)5)) {
            if ((!!((*d).metadata) && (strstr((int8_t *)((*d).metadata),(int8_t *)(sdata)) != 0))) {
                (*result).refptr = (byte *)((*d).address);
                return;
            };
        };
        ++d;
L685 :;
    }L686 :;
    ;
}

static void pc_host_pch_loadpcl(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result) {
    pc_support_pcerror((uint8_t*)"host_loadpcl not impl");
}

static void pc_host_pch_runpcl(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result) {
    pc_support_pcerror((uint8_t*)"host_runpcl not impl");
}

static void pc_host_pch_runtask(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result) {
    pc_support_pcerror((uint8_t*)"host_runtask not impl");
}

static void pc_host_pch_callext(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c) {
    pc_support_pcerror((uint8_t*)"host_callext not impl");
}

static void pc_host_pch_system(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    pc_host_checkparam(a,(int64_t)5,(int64_t)-999999);
    (*result).tagx = (uint64_t)((int64_t)1);
    (*result).value = (int64_t)(system((int8_t *)(pc_support_convcstring((*(*a).objptr).ustr.strptr,(int64_t)((*(*a).objptr).ustr.length)))));
}

static void pc_host_pch_shellexec(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result) {
    struct pc_decls_objrec *  pa;
    struct pc_decls_objrec *  pb;
    pc_host_checkparam(a,(int64_t)5,(int64_t)-999999);
    pc_host_checkparam(b,(int64_t)5,(int64_t)-999999);
    pa = (*a).objptr;
    pb = (*b).objptr;
    (*result).tagx = (uint64_t)((int64_t)1);
    (*result).value = osnos_os_shellexec(pc_support_convcstring((*pa).ustr.strptr,(int64_t)((*pa).ustr.length)),pc_support_convcstring((*pb).ustr.strptr,(int64_t)((*pb).ustr.length)));
}

static void pc_host_pch_gethash(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    (*result).tagx = (uint64_t)((int64_t)1);
    (*result).value = pc_pcfns_gethashvalue(a);
}

static void pc_host_pch_test(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result) {
    struct pc_decls_objrec *  p;
    static int64_t lastalloc = (int64_t)0;
    p = (*a).objptr;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"TEST>>>",NULL);
    msysnewc_m_print_str((uint8_t*)"P.REFCOUNT=",NULL);
    msysnewc_m_print_u64((*p).refcount,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    (*result).tagx = (uint64_t)((int64_t)1);
}

static void pc_host_pch_pcldata(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result) {
    int64_t res;
    int64_t length;
    int64_t i;
    struct pc_decls_strec *  d;
    int64_t av_1;
    pc_host_checkparam(a,(int64_t)1,(int64_t)-999999);
    res = (int64_t)0;
    if (((*a).value==(int64_t)6073471649054675536)) {
        if ((pc_decls_proclist == 0)) {
            d = &(*pc_decls_pcsymboltable)[((int64_t)1)-1];
            av_1 = pc_decls_nsymbols;
            while (av_1-- > 0) {
L687 :;
                if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)5)) {
                    pc_host_addtoproclist(d);
                };
                ++d;
L688 :;
            }L689 :;
            ;
        };
        pc_host_proclistptr = pc_decls_proclist;
    }else if (((*a).value==(int64_t)1129271888)) {
        if (!!(pc_host_proclistptr)) {
            pc_host_getproctabledata(pc_host_proclistptr,result);
            pc_host_proclistptr = (*pc_host_proclistptr).nextproc;
            return;
        };
    }else if (((*a).value==(int64_t)76194150371149)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"MODULE",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    }else if (((*a).value==(int64_t)19506716274347331)) {
        pc_pcfns_pc_makestring(pq_common_cmdnames[((*b).value)],(int64_t)-1,result);
        return;
    }else if (((*a).value==(int64_t)19496880614690115)) {
        L690 :;
        for (i=(int64_t)1;i<=(int64_t)217;i+=(int64_t)1) {
L691 :;
            length = (int64_t)(strlen((int8_t *)(pq_common_cmdnames[(i)])));
            if ((((int64_t)((*(*b).objptr).ustr.length) == length) && ((int64_t)(memcmp((void *)((*(*b).objptr).ustr.strptr),(void *)(pq_common_cmdnames[(i)]),(uint64_t)(length))) == (int64_t)0))) {
                res = i;
                goto L693 ;
            };
L692 :;
        }L693 :;
        ;
    }else if (((*a).value==(int64_t)91552836767566)) {
        res = pc_decls_cmdnopnds[((*b).value)];
    } else {
        pc_support_pcerror((uint8_t*)"pcldata/bad table");
    };
    (*result).tagx = (uint64_t)((int64_t)1);
    (*result).value = res;
}

static void pc_host_pch_getcstring(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    pc_support_pcerror((uint8_t*)"PCH/GETCSTRING");
}

static void pc_host_pch_getparam(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    pc_host_checkparam(a,(int64_t)1,(int64_t)-999999);
    (*result) = (*(struct pc_decls_varrec *)((pc_decls_frameptr + ((*a).value * (int64_t)16))));
    if (!!((uint64_t)((*result).hasref))) {
        ++(*(*result).objptr).refcount;
    };
}

static void pc_host_pch_clearlist(struct pc_decls_varrec * a) {
    pc_support_pcerror((uint8_t*)"PCH CLEARLIST");
}

static void pc_host_pch_makelink(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    if (((int64_t)(pc_decls_ttbasetype[((int64_t)((*a).tag))])==(int64_t)32)) {
        (*result).tagx = (uint64_t)((int64_t)25);
        (*result).uref.elemtag = (uint64_t)((*a).tag);
        (*result).objptr = (*a).objptr;
    }else if (((int64_t)(pc_decls_ttbasetype[((int64_t)((*a).tag))])==(int64_t)1)) {
        if (!!((*a).value)) {
            pc_support_pcerror((uint8_t*)"makelink/int");
        };
        (*result).tagx = (uint64_t)((int64_t)1);
        (*result).value = (int64_t)0;
    }else if (((int64_t)(pc_decls_ttbasetype[((int64_t)((*a).tag))])==(int64_t)25)) {
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(pc_decls_ttname[((int64_t)((*a).tag))],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(pc_decls_ttname[((int64_t)(pc_decls_ttbasetype[((int64_t)((*a).tag))]))],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        pc_support_pcerror((uint8_t*)"makelink: not record/list");
    };
}

static void pc_host_pch_allparams(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    struct pc_decls_objrec *  p;
    int64_t nparams;
    int64_t *  fnptr;
    pc_host_checkparam(a,(int64_t)18,(int64_t)-999999);
    fnptr = (int64_t *)((*a).refptr);
    nparams = (*(fnptr - (int64_t)1));
    p = pc_objlib_obj_new((int64_t)29);
    (*p).objtype = (uint64_t)((int64_t)2);
    (*p).ulist.length = (uint64_t)(nparams);
    (*p).ulist.lower = (int64_t)1;
    (*p).ulist.vptr = ((struct pc_decls_varrec *)(pc_decls_frameptr) + (int64_t)1);
    (*result).tagx = (uint64_t)((int64_t)65565);
    (*result).objptr = p;
}

static void pc_host_pch_stackvars(struct pc_decls_varrec * result) {
    pc_support_pcerror((uint8_t*)"STACKVARS");
}

static void pc_host_pch_makeempty(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    struct pc_decls_objrec *  p;
    int64_t t;
    t = (int64_t)(pc_decls_ttbasetype[((int64_t)((*a).tag))]);
    if ((t == (int64_t)13)) {
        t = (*a).value;
    };
    if ((t==(int64_t)29)) {
        p = pc_objlib_emptylist;
        ++(*p).refcount;
    }else if ((t==(int64_t)5)) {
        pc_pcfns_pc_emptystring(result);
        return;
    }else if ((t==(int64_t)30)) {
        p = pc_objlib_array_new((int64_t)30,(int64_t)((*(*a).objptr).uarray.elemtag),(int64_t)0,(int64_t)1);
    } else {
        pc_support_pcustypet((uint8_t*)"makeempty?",t);
    };
    (*result).tagx = (uint64_t)((t | (int64_t)65536));
    (*result).objptr = p;
}

static void pc_host_pch_readlines(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    byte *  p;
    byte *  q;
    byte *  pstart;
    struct pc_decls_varrec v;
    struct pc_decls_varrec *  r;
    struct pc_decls_objrec *  l;
    int64_t nlines;
    int64_t n;
    pc_host_checkparam(a,(int64_t)5,(int64_t)-999999);
    if (((int64_t)((*(*a).objptr).ustr.length) == (int64_t)0)) {
        //error:
L694 :;
;
        (*result).tagx = (uint64_t)((int64_t)1);
        (*result).value = (int64_t)0;
        return;
    };
    p = mlib_readfile((*(*a).objptr).ustr.strptr);
    if ((p == 0)) {
        goto L694 ;
;
    };
    q = p;
    nlines = (int64_t)0;
    L695 :;
    switch ((int64_t)((*q++))) {
    case 26:;
    {
        goto L696 ;
    }break;
    case 13:;
    {
        ++nlines;
        if (((int64_t)((uint64_t)((*q))) == (int64_t)10)) {
            ++q;
        };
    }break;
    case 10:;
    {
        ++nlines;
    }break;
    default: {
    }
    } //SW
goto L695 ;
L696 :;
    ;
    v.tagx = (uint64_t)((int64_t)65565);
    l = pc_objlib_list_new(nlines,(int64_t)1,(struct pc_decls_varrec *)(0));
    v.objptr = l;
    r = (*v.objptr).ulist.vptr;
    q = p;
    pstart = q;
    L697 :;
    switch ((int64_t)((*q++))) {
    case 26:;
    {
        goto L698 ;
    }break;
    case 13:;
    {
        n = ((q - pstart) - (int64_t)1);
        if (((int64_t)((uint64_t)((*q))) == (int64_t)10)) {
            ++q;
        };
        //addline:
L699 :;
;
        pc_pcfns_pc_makestring((uint8_t *)(pstart),n,r);
        ++r;
        pstart = q;
    }break;
    case 10:;
    {
        n = ((q - pstart) - (int64_t)1);
        goto L699 ;
;
    }break;
    default: {
    }
    } //SW
goto L697 ;
L698 :;
    ;
    (*result) = v;
    free((void *)(p));
}

static void pc_host_pch_dictitems(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    if (!!((uint64_t)((*a).hasref))) {
        (*result).tagx = (uint64_t)((int64_t)1);
        (*result).value = (int64_t)((*(*a).objptr).udict.dictitems);
    } else {
        pc_support_pcerror((uint8_t*)".alloclen/not heap");
    };
}

static void pc_host_pch_setoverload(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c) {
    void * (*tableptr)[];
    void (*handlerptr)(void);
    struct pc_host_overloadrec * *  ovptr;
    uint8_t str[256];
    int64_t i;
    int64_t t;
    int64_t cmd;
    static struct pc_host_pch_setoverload_rec table[2] = {
    {(int64_t)151,(void *)(&pc_decls_tostr_table),(void *)(&pc_host_tostr_handler),&pc_host_tostr_list},
    {(int64_t)85,(void *)(&pc_decls_convert_dtable),(void *)(&pc_host_convert_handler),&pc_host_convert_list}
};
    int64_t av_1;
    pc_host_checkparam(a,(int64_t)14,(int64_t)-999999);
    pc_host_checkparam(b,(int64_t)13,(int64_t)-999999);
    pc_host_checkparam(c,(int64_t)18,(int64_t)-999999);
    cmd = (*a).value;
    L700 :;
    for (i=(int64_t)1;i<=(int64_t)2;i+=(int64_t)1) {
L701 :;
        if ((table[(i)-1].cmd == cmd)) {
            tableptr = (void * (*)[])(table[(i)-1].tableptr);
            handlerptr = (void (*)(void))(table[(i)-1].handleptr);
            ovptr = table[(i)-1].ovlist;
            goto L703 ;
        };
L702 :;
    }
    {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((uint8_t*)"Setoverload: can't find calltable:",NULL);
        msysnewc_m_print_str((pq_common_cmdnames[(cmd)] + (int64_t)1),NULL);
        msysnewc_m_print_end();
        ;
        pc_support_pcerror(str);
    }L703 :;
    ;
    t = (*b).value;
    (*tableptr)[(t)] = (void *)(handlerptr);
    pc_host_addovrecord(ovptr,t,(int64_t *)((*c).refptr));
}

static void pc_host_pch_errorinfo(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    pc_host_checkparam(a,(int64_t)1,(int64_t)-999999);
    (*result).tagx = (uint64_t)((int64_t)1);
    (*result).value = (int64_t)(pc_decls_err_pcptr);
}

static void pc_host_getbounds(struct pc_decls_varrec * p,struct pc_host_dimrec * dims,int64_t lower) {
    int64_t n;
    if (!(!!(p))) {
        pc_support_pcerror((uint8_t*)"New: no bounds");
    };
    switch ((int64_t)((*p).tag)) {
    case 0:;
    {
        (*dims).lbound = lower;
        (*dims).upper = (int64_t)0;
        (*dims).length = (int64_t)0;
    }break;
    case 4:;
    {
        (*dims).lbound = (int64_t)((*p).range_lower);
        (*dims).upper = (int64_t)((*p).range_upper);
        (*dims).length = (((int64_t)((*p).range_upper) - (int64_t)((*p).range_lower)) + (int64_t)1);
        if (((*dims).length < (int64_t)0)) {
            (*dims).length = (int64_t)0;
            (*dims).upper = ((*dims).lbound - (int64_t)1);
        };
    }break;
    default: {
        n = pc_support_getintvalue(p);
        (*dims).lbound = lower;
        (*dims).upper = ((*dims).length = n);
    }
    } //SW
;
}

static int64_t pc_host_checkparam(struct pc_decls_varrec * p,int64_t tag,int64_t defaultx) {
    if (((int64_t)((*p).tag)==(int64_t)0)) {
        if ((defaultx == (int64_t)-999999)) {
            pc_support_pcerror((uint8_t*)"Missing host param");
        };
        return defaultx;
    }else if (((int64_t)((*p).tag)==tag)) {
        return (*p).value;
    };
    if ((tag == (int64_t)1)) {
        if (((int64_t)((*p).tag)==(int64_t)3)) {
            return (int64_t)((*p).xvalue);
        };
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(pc_decls_ttname[((int64_t)((*p).tag))],NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    pc_support_pcerror((uint8_t*)"Host param wrong type");
    return (int64_t)0;
}

static void pc_host_leftstring(struct pc_decls_varrec * a,int64_t n,struct pc_decls_varrec * result) {
    pc_pcfns_pc_makestring((*(*a).objptr).ustr.strptr,n,result);
}

static void pc_host_rightstring(struct pc_decls_varrec * a,int64_t n,struct pc_decls_varrec * result) {
    pc_pcfns_pc_makestring(((*(*a).objptr).ustr.strptr + ((int64_t)((*(*a).objptr).ustr.length) - n)),n,result);
}

static void pc_host_padstring_right(struct pc_decls_varrec * a,int64_t n,int64_t fillchar,struct pc_decls_varrec * result) {
    uint8_t *  s;
    int64_t length;
    int64_t av_1;
    length = (int64_t)((*(*a).objptr).ustr.length);
    pc_pcfns_pc_makestringn(n,result);
    s = (*(*result).objptr).ustr.strptr;
    if (!!(length)) {
        memcpy((void *)(s),(void *)((*(*a).objptr).ustr.strptr),(uint64_t)(length));
        s += length;
    };
    av_1 = (n - length);
    while (av_1-- > 0) {
L704 :;
        (*s) = (uint64_t)(fillchar);
        ++s;
L705 :;
    }L706 :;
    ;
}

static void pc_host_padstring_left(struct pc_decls_varrec * a,int64_t n,int64_t fillchar,struct pc_decls_varrec * result) {
    uint8_t *  s;
    int64_t length;
    int64_t padlen;
    int64_t av_1;
    length = (int64_t)((*(*a).objptr).ustr.length);
    padlen = (n - length);
    pc_pcfns_pc_makestringn(n,result);
    s = (*(*result).objptr).ustr.strptr;
    s += padlen;
    if (!!(length)) {
        memcpy((void *)(s),(void *)((*(*a).objptr).ustr.strptr),(uint64_t)(length));
    };
    av_1 = padlen;
    while (av_1-- > 0) {
L707 :;
        --s;
        (*s) = (uint64_t)(fillchar);
L708 :;
    }L709 :;
    ;
}

static void pc_host_pcld_makevint(struct pc_decls_varrec * p,int64_t a) {
    (*p).tagx = (uint64_t)((int64_t)1);
    (*p).value = a;
}

static void pc_host_pcld_makelist(struct pc_decls_varrec * p,struct pc_decls_varrec * result,int64_t n) {
    struct pc_decls_varrec *  q;
    struct pc_decls_objrec *  r;
    int64_t av_1;
    (*result).tagx = (uint64_t)((int64_t)65565);
    r = pc_objlib_list_new(n,(int64_t)1,(struct pc_decls_varrec *)(0));
    (*result).objptr = r;
    q = (*r).ulist.vptr;
    av_1 = n;
    while (av_1-- > 0) {
L710 :;
        (*q) = (*p);
        pc_pcfns_pc_dupl(q);
        ++q;
        ++p;
L711 :;
    }L712 :;
    ;
}

static void pc_host_getproctabledata(struct pc_decls_procrec * p,struct pc_decls_varrec * result) {
    struct pc_decls_varrec table[4];
    struct pc_decls_strec *  d;
    int64_t moduleno;
    d = (*p).def;
    pc_pcfns_pc_makestring((*d).name,(int64_t)-1,&table[((int64_t)1)-1]);
    pc_pcfns_pc_makestring((*d).metadata,(int64_t)-1,&table[((int64_t)2)-1]);
    moduleno = (int64_t)((*d).ax_moduleno);
    pc_host_pcld_makevint(&table[((int64_t)3)-1],moduleno);
    table[((int64_t)4)-1].tagx = (uint64_t)((int64_t)18);
    table[((int64_t)4)-1].refptr = (byte *)((*d).pcaddress);
    pc_host_pcld_makelist(&table[((int64_t)1)-1],result,(int64_t)4);
}

static int64_t * pc_host_convert_handler(int64_t _1) {
    return (int64_t *)(0);
}

static void pc_host_addtoproclist(struct pc_decls_strec * d) {
    struct pc_decls_procrec *  pp;
    ++pc_decls_nproclist;
    pp = (struct pc_decls_procrec *)(mlib_pcm_alloc((int64_t)16));
    (*pp).nextproc = pc_decls_proclist;
    pc_decls_proclist = pp;
    (*pp).def = d;
}

static int64_t * pc_host_tostr_handler(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    struct pc_host_overloadrec *  q;
    struct pc_decls_varrec vdest;
    struct pc_decls_objrec *  vp;
    q = pc_host_tostr_list;
    q = pc_host_tostr_list;
    L713 :;
    while (!!(q)) {
        if (((*q).optype == pc_decls_overloadtype)) {
            goto L715 ;
        };
        q = (*q).nextrec;
L714 :;
    }L715 :;
    ;
    if ((q == 0)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(pc_decls_ttname[((int64_t)((*p).tag))],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        pc_support_pcerror((uint8_t*)"tostr/overload");
    };
    vdest.tagx = (uint64_t)((int64_t)0);
    pci_runproc((void *)((*q).pchandler),p,fmtstr,&vdest);
    if (((int64_t)((uint64_t)(vdest.tag)) != (int64_t)5)) {
        pc_support_pcerror((uint8_t*)"custom tostr needs string result");
    };
    vp = vdest.objptr;
    if (!!((int64_t)((*vp).ustr.length))) {
        pc_print_addstring(dest,(*vp).ustr.strptr,(int64_t)((*vp).ustr.length));
    };
    pc_pcfns_pc_unshare(&vdest);
    return (int64_t *)(0);
}

static int64_t * pc_host_add_handler(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    struct pc_host_overloadrec *  q;
    struct pc_decls_varrec vdest;
    struct pc_decls_objrec *  vp;
    q = pc_host_tostr_list;
    q = pc_host_tostr_list;
    L716 :;
    while (!!(q)) {
        if (((*q).optype == pc_decls_overloadtype)) {
            goto L718 ;
        };
        q = (*q).nextrec;
L717 :;
    }L718 :;
    ;
    if ((q == 0)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(pc_decls_ttname[((int64_t)((*p).tag))],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        pc_support_pcerror((uint8_t*)"tostr/overload");
    };
    vdest.tagx = (uint64_t)((int64_t)0);
    pci_runproc((void *)((*q).pchandler),p,fmtstr,&vdest);
    if (((int64_t)((uint64_t)(vdest.tag)) != (int64_t)5)) {
        pc_support_pcerror((uint8_t*)"custom tostr needs string result");
    };
    vp = vdest.objptr;
    if (!!((int64_t)((*vp).ustr.length))) {
        pc_print_addstring(dest,(*vp).ustr.strptr,(int64_t)((*vp).ustr.length));
    };
    pc_pcfns_pc_unshare(&vdest);
    return (int64_t *)(0);
}

static void pc_host_addovrecord(struct pc_host_overloadrec * * p,int64_t t,int64_t * fnptr) {
    struct pc_host_overloadrec *  q;
    q = (struct pc_host_overloadrec *)(mlib_pcm_allocz((int64_t)32));
    (*q).optype = t;
    (*q).pchandler = fnptr;
    (*q).nextrec = (*p);
    (*p) = q;
}

static void (*pc_host_findapplproc(int64_t fnindex))(void) {
    pc_support_pcerror((uint8_t*)"EXPORTS NOT DONE");
    return (void (*)(void))(0);
}

void pc_host_do_callapplproc(int64_t fnindex,int64_t nargs,struct pc_decls_varrec * result) {
    void (*fnaddr)(void);
    byte (*paramlist)[12];
    int64_t nparams;
    int64_t rettype;
    int64_t nextra;
    int64_t na;
    uint64_t a;
    uint64_t wordargs[100];
    struct pc_decls_varrec *  args;
    struct pc_decls_varrec *  retv;
    struct msysnewc_procinforec *  info;
    int64_t i;
    fnaddr = pc_decls_applproctable[(fnindex)-1].address;
    if ((fnaddr == 0)) {
        fnaddr = pc_host_findapplproc(fnindex);
    };
    info = pc_decls_applproctable[(fnindex)-1].info;
    rettype = (int64_t)((*info).rettype);
    nparams = (int64_t)((*info).nparams);
    paramlist = &(*info).paramlist;
    args = (result - (int64_t)1);
    nextra = (int64_t)0;
    if ((nparams > nargs)) {
        L719 :;
        for (i=(nargs + (int64_t)1);i<=nparams;i+=(int64_t)1) {
L720 :;
            if (!(!!(((int64_t)((uint64_t)((*paramlist)[(i)-1])) & (int64_t)64)))) {
                pc_support_pcerror((uint8_t*)"callappl: too few args or not optional");
            };
L721 :;
        }L722 :;
        ;
        nextra = (nparams - nargs);
    } else if ((nparams < nargs)) {
        pc_support_pcerror((uint8_t*)"callappl: too many args");
    };
    na = (int64_t)0;
    L723 :;
    for (i=nargs;i>=(int64_t)1;i-=(int64_t)1) {
L724 :;
        wordargs[(++na)-1] = (uint64_t)(pc_host_vartopack(args,((int64_t)((uint64_t)((*paramlist)[(i)-1])) & (int64_t)63)));
        --args;
L725 :;
    }L726 :;
    ;
    a = osnosdll_os_pushargs(&wordargs,na,nextra,fnaddr,(rettype == (int64_t)3));
    a = (uint64_t)((int64_t)0);
    (*result).tagx = (uint64_t)(pc_host_packconvtypes[(rettype)]);
    (*result).value = (int64_t)(a);
    switch (rettype) {
    case 5:;
    case 6:;
    case 7:;
    case 8:;
    {
        (*result).uref.elemtag = (uint64_t)(((rettype - (int64_t)5) + (int64_t)37));
    }break;
    case 10:;
    case 11:;
    case 12:;
    case 13:;
    {
        (*result).uref.elemtag = (uint64_t)(((rettype - (int64_t)10) + (int64_t)44));
    }break;
    case 19:;
    {
        retv = (struct pc_decls_varrec *)(a);
        (*result) = (*retv);
    }break;
    default: {
    }
    } //SW
;
}

static int64_t pc_host_vartopack(struct pc_decls_varrec * p,int64_t tp) {
    int64_t tag;
    int64_t a;
    uint8_t *  ss;
    double xx;
    tag = (int64_t)((*p).tag);
    a = (*p).value;
    switch (tp) {
    case 19:;
    {
        return (int64_t)(p);
    }break;
    case 1:;
    {
        if ((tag==(int64_t)1) || (tag==(int64_t)2)) {
            return a;
        }else if ((tag==(int64_t)3)) {
            return (int64_t)((*p).xvalue);
        };
    }break;
    case 3:;
    {
        if ((tag==(int64_t)1) || (tag==(int64_t)2)) {
            xx = (double)(a);
            return *(int64_t*)&xx;
        }else if ((tag==(int64_t)3)) {
            return *(int64_t*)&(*p).xvalue;
        };
    }break;
    case 18:;
    {
        if (((int64_t)((*p).tag)==(int64_t)5)) {
            ss = pc_support_convcstring((*(*p).objptr).ustr.strptr,(int64_t)((*(*p).objptr).ustr.length));
            return (int64_t)(*(uint64_t*)&ss);
        };
    }break;
    case 5:;
    case 6:;
    case 7:;
    case 8:;
    case 9:;
    case 10:;
    case 11:;
    case 12:;
    case 13:;
    case 14:;
    case 15:;
    case 16:;
    {
        if (((int64_t)(pc_decls_ttbasetype[((int64_t)((*p).tag))])==(int64_t)30)) {
            return (int64_t)((*(*p).objptr).uarray.ptr);
        }else if (((int64_t)(pc_decls_ttbasetype[((int64_t)((*p).tag))])==(int64_t)23)) {
            return a;
        };
    }break;
    case 0:;
    {
        return (int64_t)0;
    }break;
    default: {
    }
    } //SW
;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(pc_decls_ttname[(tag)],NULL);
    msysnewc_m_print_str((uint8_t*)"=>",NULL);
    msysnewc_m_print_str(pc_host_packtypenames[(tp)],NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    pc_support_pcerror((uint8_t*)"vartopack?");
    return (int64_t)0;
}

int64_t pc_host_dummyfn(int64_t a,int64_t b,int64_t c) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"DUMMY FN",NULL);
    msysnewc_m_print_i64(a,NULL);
    msysnewc_m_print_i64(b,NULL);
    msysnewc_m_print_i64(c,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    return ((a + b) + c);
}

int64_t pc_host_pythag(int64_t n) {
    int64_t count;
    int64_t av_1;
    int64_t a;
    int64_t b;
    int64_t c;
    count = (int64_t)0;
    L727 :;
    for (a=(int64_t)1;a<=n;a+=(int64_t)1) {
L728 :;
        L731 :;
        for (b=a;b<=n;b+=(int64_t)1) {
L732 :;
            L735 :;
            for (c=b;c<=(n * (int64_t)2);c+=(int64_t)1) {
L736 :;
                if ((((a * a) + (b * b)) == (c * c))) {
                    ++count;
                };
L737 :;
            }L738 :;
            ;
L733 :;
        }L734 :;
        ;
L729 :;
    }L730 :;
    ;
    return count;
}

struct pc_decls_varrec * pc_host_new_random(struct pc_decls_varrec * a) {
    struct pc_decls_varrec *  result;
    int64_t n;
    int64_t x;
    result = &pc_host_applresult;
    (*result).tagx = (uint64_t)((int64_t)1);
    (*result).value = (int64_t)0;
    return result;
    if (((int64_t)((uint64_t)((*a).tag)) == (int64_t)4)) {
        x = mlib_mrandomrange((int64_t)((*a).range_lower),(int64_t)((*a).range_upper));
    } else {
        pc_host_checkparam(a,(int64_t)1,(int64_t)-999999);
        n = (*a).value;
        if ((n > (int64_t)1)) {
            x = mlib_mrandomint(n);
        } else if ((n == (int64_t)0)) {
            x = (int64_t)(mlib_mrandom());
        } else if ((n == (int64_t)1)) {
            (*result).tagx = (uint64_t)((int64_t)3);
            (*result).xvalue = mlib_mrandomreal();
            return result;
        } else {
            pc_support_pcerror((uint8_t*)"new_rand?");
        };
    };
    (*result).value = x;
    return result;
}

struct pc_decls_varrec * pc_host_new_heapvar(struct pc_decls_varrec * a) {
    struct pc_decls_varrec *  result;
    result = &pc_host_applresult;
    (*result).tagx = (uint64_t)((int64_t)1);
    (*result).value = (int64_t)12345679;
    return result;
}

int64_t pc_host_mfib(int64_t n) {
    if ((n < (int64_t)3)) {
        return (int64_t)1;
    } else {
        return (pc_host_mfib((n - (int64_t)1)) + pc_host_mfib((n - (int64_t)2)));
    };
}

void pc_dxfns_dx_iorset(struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    int64_t xlen;
    int64_t ylen;
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    px = (*x).objptr;
    py = (*y).objptr;
    xlen = (int64_t)((*px).uset.length);
    ylen = (int64_t)((*py).uset.length);
    if ((ylen == (int64_t)0)) {
    } else if ((xlen == (int64_t)0)) {
        (*x) = (*y);
    } else {
        pc_pcfns_pc_duplvar(x);
        px = (*x).objptr;
        pc_dxfns_iresizeset(x,ylen);
        pc_dxfns_iorsetbits((int64_t *)((*px).uset.ptr),(int64_t *)((*py).uset.ptr),ylen);
        pc_pcfns_pc_unshare(y);
    };
}

void pc_dxfns_dx_iandset(struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    int64_t xlen;
    int64_t ylen;
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    px = (*x).objptr;
    py = (*y).objptr;
    xlen = (int64_t)((*px).uset.length);
    ylen = (int64_t)((*py).uset.length);
    if ((ylen == (int64_t)0)) {
    } else if ((xlen == (int64_t)0)) {
        (*x) = (*y);
    } else {
        pc_pcfns_pc_duplvar(x);
        px = (*x).objptr;
        pc_dxfns_iresizeset(x,ylen);
        pc_dxfns_iandsetbits((int64_t *)((*px).uset.ptr),(int64_t *)((*py).uset.ptr),ylen);
        pc_pcfns_pc_unshare(y);
    };
}

void pc_dxfns_dx_ixorset(struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    int64_t xlen;
    int64_t ylen;
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    px = (*x).objptr;
    py = (*y).objptr;
    xlen = (int64_t)((*px).uset.length);
    ylen = (int64_t)((*py).uset.length);
    if ((ylen == (int64_t)0)) {
    } else if ((xlen == (int64_t)0)) {
        (*x) = (*y);
    } else {
        pc_pcfns_pc_duplvar(x);
        px = (*x).objptr;
        pc_dxfns_iresizeset(x,ylen);
        pc_dxfns_ixorsetbits((int64_t *)((*px).uset.ptr),(int64_t *)((*py).uset.ptr),ylen);
        pc_pcfns_pc_unshare(y);
    };
}

void pc_dxfns_dx_inotset(struct pc_decls_varrec * x) {
    struct pc_decls_objrec *  px;
    px = (*x).objptr;
    if (!!((uint64_t)((*px).uset.length))) {
        pc_pcfns_pc_duplvar(x);
        px = (*x).objptr;
        pc_dxfns_inotsetbits((int64_t *)((*px).uset.ptr),(int64_t)((*px).uset.length));
    };
}

void pc_dxfns_dx_subset(struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    int64_t xlen;
    int64_t ylen;
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    px = (*x).objptr;
    py = (*y).objptr;
    xlen = (int64_t)((*px).uset.length);
    ylen = (int64_t)((*py).uset.length);
    if ((!!(xlen) && !!(ylen))) {
        pc_pcfns_pc_dupl(x);
        px = (*x).objptr;
        pc_dxfns_iresizeset(x,ylen);
        pc_dxfns_subsetbits((int64_t *)((*px).uset.ptr),(int64_t *)((*py).uset.ptr),ylen);
    };
    pc_pcfns_pc_unshare(y);
}

void pc_dxfns_inotsetbits(int64_t * p,int64_t n) {
    int64_t av_1;
    av_1 = (((n - (int64_t)1) / (int64_t)64) + (int64_t)1);
    while (av_1-- > 0) {
L739 :;
        (*p) = ~((*p));
        ++p;
L740 :;
    }L741 :;
    ;
}

void pc_dxfns_iorsetbits(int64_t * p,int64_t * q,int64_t n) {
    int64_t av_1;
    av_1 = (((n - (int64_t)1) / (int64_t)64) + (int64_t)1);
    while (av_1-- > 0) {
L742 :;
        (*p++) |= (*q++);
L743 :;
    }L744 :;
    ;
}

void pc_dxfns_iandsetbits(int64_t * p,int64_t * q,int64_t n) {
    int64_t av_1;
    av_1 = (((n - (int64_t)1) / (int64_t)64) + (int64_t)1);
    while (av_1-- > 0) {
L745 :;
        (*p++) &= (*q++);
L746 :;
    }L747 :;
    ;
}

void pc_dxfns_ixorsetbits(int64_t * p,int64_t * q,int64_t n) {
    int64_t av_1;
    av_1 = (((n - (int64_t)1) / (int64_t)64) + (int64_t)1);
    while (av_1-- > 0) {
L748 :;
        (*p++) ^= (*q++);
L749 :;
    }L750 :;
    ;
}

void pc_dxfns_subsetbits(int64_t * p,int64_t * q,int64_t n) {
    int64_t av_1;
    av_1 = (((n - (int64_t)1) / (int64_t)64) + (int64_t)1);
    while (av_1-- > 0) {
L751 :;
        (*p) |= (*q);
        (*p) ^= (*q);
        ++p;
        ++q;
L752 :;
    }L753 :;
    ;
}

void pc_dxfns_iresizeset(struct pc_decls_varrec * p,int64_t n) {
    struct pc_decls_objrec *  pp;
    pp = (*p).objptr;
    if (((int64_t)((uint64_t)((*pp).uset.length)) >= n)) {
        return;
    };
    pc_objlib_bits_resize(pp,n);
}

int64_t pc_dxfns_dx_varinvar(struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    int64_t i;
    int64_t xt;
    int64_t yt;
    int64_t n;
    int64_t a;
    struct pc_decls_varrec *  p;
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    int64_t av_1;
    xt = (int64_t)((*x).tag);
    yt = (int64_t)(pc_decls_ttbasetype[((int64_t)((*y).tag))]);
    px = (*x).objptr;
    py = (*y).objptr;
    switch (xt) {
    case 1:;
    {
        //doi64invar:
L754 :;
;
        switch (yt) {
        case 9:;
        {
            n = (*x).value;
            //doi64inset:
L755 :;
;
            if (((uint64_t)((uint32_t)(n)) >= (uint64_t)((*py).uset.length))) {
                if (!!((uint64_t)((*y).hasref))) {
                    pc_pcfns_pc_unshare(y);
                };
                return (int64_t)0;
            };
            n = pc_support_testelem((byte (*)[])((*py).uset.ptr),n);
            pc_pcfns_pc_unshare(y);
            return n;
        }break;
        case 29:;
        {
            a = (*x).value;
            n = (int64_t)((*py).ulist.length);
            p = (*py).ulist.vptr;
            L756 :;
            for (i=(int64_t)1;i<=n;i+=(int64_t)1) {
L757 :;
                if ((((int64_t)((uint64_t)((*p).tag)) == (int64_t)1) && ((*p).value == a))) {
                    if (!!((uint64_t)((*y).hasref))) {
                        pc_pcfns_pc_unshare(y);
                    };
                    return i;
                };
                ++p;
L758 :;
            }L759 :;
            ;
            pc_pcfns_pc_unshare(y);
            return (int64_t)0;
        }break;
        case 30:;
        {
            if (((int64_t)((*py).uarray.elemtag)==(int64_t)37) || ((int64_t)((*py).uarray.elemtag)==(int64_t)44)) {
                n = pc_pcfns_u8inarray((uint64_t)((byte)((*x).value)),py);
            }else if (((int64_t)((*py).uarray.elemtag)==(int64_t)38) || ((int64_t)((*py).uarray.elemtag)==(int64_t)45)) {
                n = pc_pcfns_u16inarray((uint64_t)((uint16_t)((*x).value)),py);
            }else if (((int64_t)((*py).uarray.elemtag)==(int64_t)39) || ((int64_t)((*py).uarray.elemtag)==(int64_t)46)) {
                n = pc_pcfns_u32inarray((uint64_t)((uint32_t)((*x).value)),py);
            }else if (((int64_t)((*py).uarray.elemtag)==(int64_t)40) || ((int64_t)((*py).uarray.elemtag)==(int64_t)47)) {
                n = pc_pcfns_u64inarray((uint64_t)((*x).value),py);
            } else {
                pc_support_pcustypet((uint8_t*)"x in array",(int64_t)((*py).uarray.elemtag));
            };
            pc_pcfns_pc_unshare(y);
            return n;
        }break;
        case 31:;
        {
            if (((int64_t)((*py).ubits.elemtag)==(int64_t)41)) {
                n = pc_pcfns_bitinbits((uint64_t)((byte)((*x).value)),py);
            } else {
                pc_support_pcustypet((uint8_t*)"x in bits",(int64_t)((*py).ubits.elemtag));
            };
            pc_pcfns_pc_unshare(y);
            return n;
        }break;
        case 4:;
        {
            n = (*x).value;
            return ((n >= (int64_t)((*y).range_lower)) && (n <= (int64_t)((*y).range_upper)));
        }break;
        default: {
        }
        } //SW
;
    }break;
    case 5:;
    {
        switch (yt) {
        case 5:;
        {
            n = pc_pcfns_pc_strinstr(x,y);
            if (!!((uint64_t)((*x).hasref))) {
                pc_pcfns_pc_unshare(x);
            };
            if (!!((uint64_t)((*y).hasref))) {
                pc_pcfns_pc_unshare(y);
            };
            return n;
        }break;
        case 29:;
        {
            n = (int64_t)((*py).ulist.length);
            p = (*py).ulist.vptr;
            i = (int64_t)((*py).ulist.lower);
            av_1 = n;
            while (av_1-- > 0) {
L760 :;
                if (((int64_t)((uint64_t)((*p).tag)) == (int64_t)5)) {
                    if (!!(pc_pcfns_pc_eqstring_nf(x,p))) {
                        if (!!((uint64_t)((*x).hasref))) {
                            pc_pcfns_pc_unshare(x);
                        };
                        if (!!((uint64_t)((*y).hasref))) {
                            pc_pcfns_pc_unshare(y);
                        };
                        return i;
                    };
                };
                ++p;
                ++i;
L761 :;
            }L762 :;
            ;
            if (!!((uint64_t)((*x).hasref))) {
                pc_pcfns_pc_unshare(x);
            };
            if (!!((uint64_t)((*y).hasref))) {
                pc_pcfns_pc_unshare(y);
            };
            return (int64_t)0;
        }break;
        default: {
        }
        } //SW
;
    }break;
    default: {
        switch (yt) {
        case 29:;
        {
            n = (int64_t)((*py).ulist.length);
            p = (*py).ulist.vptr;
            L763 :;
            for (i=(int64_t)1;i<=n;i+=(int64_t)1) {
L764 :;
                if ((pc_pcfns_pc_equal_nf(x,p,(int64_t)1) == (int64_t)1)) {
                    if (!!((uint64_t)((*x).hasref))) {
                        pc_pcfns_pc_unshare(x);
                    };
                    if (!!((uint64_t)((*y).hasref))) {
                        pc_pcfns_pc_unshare(y);
                    };
                    return i;
                };
                ++p;
L765 :;
            }L766 :;
            ;
            if (!!((uint64_t)((*x).hasref))) {
                pc_pcfns_pc_unshare(x);
            };
            if (!!((uint64_t)((*y).hasref))) {
                pc_pcfns_pc_unshare(y);
            };
            return (int64_t)0;
        }break;
        default: {
        }
        } //SW
;
    }
    } //SW
;
    pc_support_pcmxtypes((uint8_t*)"varinvar:",x,y);
    return (int64_t)0;
}

int64_t pc_dxfns_dx_mixed(struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    switch ((int64_t)((*x).tag)) {
    case 1:;
    {
        switch ((int64_t)((*y).tag)) {
        case 3:;
        {
            (*x).xvalue = (double)((*x).value);
            (*x).tagx = (uint64_t)((int64_t)3);
            return (int64_t)3;
        }break;
        case 2:;
        {
            return (int64_t)1;
        }break;
        case 7:;
        {
            pc_bignum_bx_makeint((*x).value,x);
            return (int64_t)7;
        }break;
        case 0:;
        {
            goto L767 ;
;
        }break;
        default: {
            return (int64_t)0;
        }
        } //SW
;
    }break;
    case 3:;
    {
        switch ((int64_t)((*y).tag)) {
        case 1:;
        {
            (*y).xvalue = (double)((*y).value);
            (*y).tagx = (uint64_t)((int64_t)3);
            return (int64_t)3;
        }break;
        case 0:;
        {
            goto L767 ;
;
        }break;
        default: {
            return (int64_t)0;
        }
        } //SW
;
    }break;
    case 2:;
    {
        switch ((int64_t)((*y).tag)) {
        case 1:;
        {
            return (int64_t)2;
        }break;
        case 0:;
        {
            goto L767 ;
;
        }break;
        default: {
            return (int64_t)0;
        }
        } //SW
;
    }break;
    case 7:;
    {
        switch ((int64_t)((*y).tag)) {
        case 1:;
        {
            pc_bignum_bx_makeint((*y).value,y);
            return (int64_t)7;
        }break;
        default: {
            return (int64_t)0;
        }
        } //SW
;
    }break;
    case 0:;
    {
        //dxvoid:
L767 :;
;
        pc_support_pcerror((uint8_t*)"dxmix/void");
    }break;
    default: {
        if (((int64_t)((uint64_t)((*y).tag)) == (int64_t)0)) {
            goto L767 ;
;
        };
        return (int64_t)0;
    }
    } //SW
;
    return (int64_t)0;
}

void * pc_khandlers_k_zero(void) {
    pc_support_pclunimpl((int64_t)0);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_nop(void) {
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_procstart(void) {
    pc_support_pclunimpl((int64_t)2);
    return (void *)((pc_decls_pcptr + (int64_t)3));
}

void * pc_khandlers_k_procend(void) {
    pc_support_pclunimpl((int64_t)3);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_endmodule(void) {
    pc_support_pclunimpl((int64_t)4);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_push_m(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr) = (*(struct pc_decls_varrec *)((*(pc_decls_pcptr + (int64_t)1))));
    if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
        ++(*(*pc_decls_sptr).objptr).refcount;
    };
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_push_f(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr) = (*(struct pc_decls_varrec *)((pc_decls_frameptr + (*(pc_decls_pcptr + (int64_t)1)))));
    if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
        ++(*(*pc_decls_sptr).objptr).refcount;
    };
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_push_am(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)22);
    (*pc_decls_sptr).varptr = (struct pc_decls_varrec *)((*(pc_decls_pcptr + (int64_t)1)));
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_push_af(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)22);
    (*pc_decls_sptr).varptr = (struct pc_decls_varrec *)((pc_decls_frameptr + (*(pc_decls_pcptr + (int64_t)1))));
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_push_ap(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)18);
    (*pc_decls_sptr).refptr = (byte *)((*(pc_decls_pcptr + (int64_t)1)));
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_push_al(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)20);
    (*pc_decls_sptr).refptr = (byte *)((*(pc_decls_pcptr + (int64_t)1)));
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_push_ci(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = (*(pc_decls_pcptr + (int64_t)1));
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_push_cw(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)2);
    (*pc_decls_sptr).uvalue = (uint64_t)((*(pc_decls_pcptr + (int64_t)1)));
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_push_cr(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)3);
    (*pc_decls_sptr).uvalue = (uint64_t)((*(pc_decls_pcptr + (int64_t)1)));
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_push_cn(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)4);
    (*pc_decls_sptr).uvalue = (uint64_t)((*(pc_decls_pcptr + (int64_t)1)));
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_push_cs(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)65541);
    (*pc_decls_sptr).objptr = (struct pc_decls_objrec *)((*(pc_decls_pcptr + (int64_t)1)));
    ++(*(*pc_decls_sptr).objptr).refcount;
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_push_t(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)13);
    (*pc_decls_sptr).value = (*(pc_decls_pcptr + (int64_t)1));
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_push_op(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)14);
    (*pc_decls_sptr).value = (*(pc_decls_pcptr + (int64_t)1));
    (*pc_decls_sptr).uop.opdims = (uint64_t)((*(pc_decls_pcptr + (int64_t)2)));
    return (void *)((pc_decls_pcptr + (int64_t)3));
}

void * pc_khandlers_k_pushz(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint64_t)((*(pc_decls_pcptr + (int64_t)1)));
    (*pc_decls_sptr).value = (int64_t)0;
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_pushz_void(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)0);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_pushz_str(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).objptr = pc_objlib_emptystring;
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)65541);
    ++(*pc_objlib_emptystring).refcount;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_pushz_list(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)65565);
    (*pc_decls_sptr).objptr = pc_objlib_emptylist;
    ++(*pc_objlib_emptylist).refcount;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_pushz_listl(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)65565);
    (*pc_decls_sptr).objptr = pc_objlib_list_new((int64_t)0,(*(pc_decls_pcptr + (int64_t)1)),(struct pc_decls_varrec *)(0));
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_pushz_set(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)65545);
    (*pc_decls_sptr).objptr = pc_objlib_emptyset;
    ++(*pc_objlib_emptyset).refcount;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_pushz_arrayl(void) {
    pc_support_pclunimpl((int64_t)24);
    return (void *)((pc_decls_pcptr + (int64_t)3));
}

void * pc_khandlers_k_pop_m(void) {
    struct pc_decls_varrec *  a;
    a = (struct pc_decls_varrec *)((*(pc_decls_pcptr + (int64_t)1)));
    if (!!((uint64_t)((*a).hasref))) {
        pc_pcfns_pc_unshare(a);
    };
    (*a) = (*pc_decls_sptr++);
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_pop_f(void) {
    struct pc_decls_varrec *  a;
    a = (struct pc_decls_varrec *)((pc_decls_frameptr + (*(pc_decls_pcptr + (int64_t)1))));
    if (!!((uint64_t)((*a).hasref))) {
        pc_pcfns_pc_unshare(a);
    };
    (*a) = (*pc_decls_sptr++);
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_store_m(void) {
    struct pc_decls_varrec *  a;
    a = (struct pc_decls_varrec *)((*(pc_decls_pcptr + (int64_t)1)));
    if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
        pc_pcfns_pc_share(pc_decls_sptr);
    };
    if (!!((uint64_t)((*a).hasref))) {
        pc_pcfns_pc_unshare(a);
    };
    (*a) = (*pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_store_f(void) {
    struct pc_decls_varrec *  a;
    a = (struct pc_decls_varrec *)((pc_decls_frameptr + (*(pc_decls_pcptr + (int64_t)1))));
    if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
        pc_pcfns_pc_share(pc_decls_sptr);
    };
    if (!!((uint64_t)((*a).hasref))) {
        pc_pcfns_pc_unshare(a);
    };
    (*a) = (*pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_pushptr(void) {
    switch ((int64_t)((*pc_decls_sptr).tag)) {
    case 22:;
    {
        (*pc_decls_sptr) = (*(*pc_decls_sptr).varptr);
        if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
            ++(*(*pc_decls_sptr).objptr).refcount;
        };
    }break;
    case 25:;
    {
        (*pc_decls_sptr).tagx = (uint64_t)(((int64_t)((uint64_t)((*pc_decls_sptr).uref.elemtag)) | (int64_t)65536));
        ++(*(*pc_decls_sptr).objptr).refcount;
    }break;
    case 23:;
    {
        pc_pcfns_pc_loadpacked((void *)((*pc_decls_sptr).uref.ptr),(int64_t)((*pc_decls_sptr).uref.elemtag),pc_decls_sptr,(struct pc_decls_objrec *)(0));
    }break;
    case 24:;
    {
        pc_pcfns_pc_loadbit((*pc_decls_sptr).uref.ptr,(int64_t)((*pc_decls_sptr).uref.bitoffset),(int64_t)((*pc_decls_sptr).uref.elemtag),(int64_t)((*pc_decls_sptr).uref.bitlength),pc_decls_sptr);
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"pushptr",pc_decls_sptr);
    }
    } //SW
;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_popptr(void) {
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec *  q;
    p = pc_decls_sptr++;
    switch ((int64_t)((*p).tag)) {
    case 22:;
    {
        q = (*p).varptr;
        if (!!((uint64_t)((*q).hasref))) {
            pc_pcfns_pc_unshare(q);
        };
        (*q) = (*pc_decls_sptr++);
    }break;
    case 5:;
    {
        pc_pcfns_pc_storestring(p,pc_decls_sptr);
        ++pc_decls_sptr;
    }break;
    default: {
        pc_pcfns_pc_storeptr(p,pc_decls_sptr);
        ++pc_decls_sptr;
    }
    } //SW
;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_storeptr(void) {
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec *  q;
    p = pc_decls_sptr++;
    if (((int64_t)((uint64_t)((*p).tag)) == (int64_t)22)) {
        q = (*p).varptr;
        if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
            pc_pcfns_pc_share(pc_decls_sptr);
        };
        if (!!((uint64_t)((*q).hasref))) {
            pc_pcfns_pc_unshare(q);
        };
        (*q) = (*pc_decls_sptr);
    } else {
        pc_pcfns_pc_storeptr(p,pc_decls_sptr);
        if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
            pc_pcfns_pc_unshare(pc_decls_sptr);
        };
    };
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_zpop_m(void) {
    struct pc_decls_varrec *  a;
    a = (struct pc_decls_varrec *)((*(pc_decls_pcptr + (int64_t)1)));
    (*a) = (*pc_decls_sptr++);
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_zpop_f(void) {
    struct pc_decls_varrec *  a;
    a = (struct pc_decls_varrec *)((pc_decls_frameptr + (*(pc_decls_pcptr + (int64_t)1))));
    (*a) = (*pc_decls_sptr++);
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_zstore_m(void) {
    pc_support_pclunimpl((int64_t)34);
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_zstore_f(void) {
    struct pc_decls_varrec *  a;
    a = (struct pc_decls_varrec *)((pc_decls_frameptr + (*(pc_decls_pcptr + (int64_t)1))));
    (*a) = (*pc_decls_sptr);
    if (!!((uint64_t)((*a).hasref))) {
        pc_pcfns_pc_share(a);
    };
    if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
        ++(*(*pc_decls_sptr).objptr).refcount;
    };
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_copy(void) {
    if (!(!!((uint64_t)((*pc_decls_sptr).hasref)))) {
        return (void *)((pc_decls_pcptr + (int64_t)1));
    };
    pc_pcfns_pc_dupl(pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_swap(void) {
    byte tempbuffer[1024];
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    struct pc_decls_varrec u;
    struct pc_decls_varrec v;
    int64_t xt;
    int64_t yt;
    int64_t s;
    int64_t t;
    int64_t n;
    byte *  p;
    byte *  q;
    int64_t a;
    x = pc_decls_sptr++;
    y = pc_decls_sptr++;
    xt = (int64_t)((*x).tag);
    yt = (int64_t)((*y).tag);
    if ((xt != yt)) {
        pc_support_pcerror((uint8_t*)"swap mismatch");
    };
    if ((xt==(int64_t)22)) {
        v = (*(*x).varptr);
        (*(*x).varptr) = (*(*y).varptr);
        (*(*y).varptr) = v;
    }else if ((xt==(int64_t)23)) {
        s = (int64_t)((*x).uref.elemtag);
        t = (int64_t)((*y).uref.elemtag);
        if ((s != t)) {
            goto L768 ;
;
        };
        n = pc_decls_ttsize[(s)];
        if ((n==(int64_t)1)) {
            p = (*x).uref.ptr;
            q = (*y).uref.ptr;
            a = (int64_t)((*p));
            (*p) = (uint64_t)((*q));
            (*q) = (uint64_t)(a);
        } else {
            if ((pc_decls_ttsize[(s)] <= (int64_t)1024)) {
                memcpy((void *)(&tempbuffer),(void *)((*x).uref.ptr),(uint64_t)(n));
                memcpy((void *)((*x).uref.ptr),(void *)((*y).uref.ptr),(uint64_t)(n));
                memcpy((void *)((*y).uref.ptr),(void *)(&tempbuffer),(uint64_t)(n));
            } else {
                goto L768 ;
;
            };
        };
    }else if ((xt==(int64_t)24)) {
        p = (*x).uref.ptr;
        q = (*y).uref.ptr;
        pc_pcfns_pc_loadbit(p,(int64_t)((*x).uref.bitoffset),(int64_t)((*x).uref.elemtag),(int64_t)((*x).uref.bitlength),&u);
        pc_pcfns_pc_loadbit(q,(int64_t)((*y).uref.bitoffset),(int64_t)((*y).uref.elemtag),(int64_t)((*y).uref.bitlength),&v);
        pc_pcfns_pc_storebit(p,(int64_t)((*x).uref.bitoffset),&v,(int64_t)((*x).uref.elemtag),(int64_t)((*x).uref.bitlength));
        pc_pcfns_pc_storebit(q,(int64_t)((*y).uref.bitoffset),&u,(int64_t)((*y).uref.elemtag),(int64_t)((*y).uref.bitlength));
    } else {
        //swaperror:
L768 :;
;
        pc_support_pcmxtypes((uint8_t*)"SWAP",x,y);
    };
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_convptr(void) {
    struct pc_decls_varrec *  a;
    int64_t elemtype;
    void *  p;
    struct pc_decls_objrec *  pa;
    switch ((int64_t)((*pc_decls_sptr).tag)) {
    case 22:;
    {
        a = (*pc_decls_sptr).varptr;
        pa = (*a).objptr;
        switch ((int64_t)(pc_decls_ttbasetype[((int64_t)((*a).tag))])) {
        case 1:;
        case 2:;
        {
            p = (void *)(&(*a).value);
            elemtype = (int64_t)40;
        }break;
        case 3:;
        {
            p = (void *)(&(*a).value);
            elemtype = (int64_t)49;
        }break;
        case 30:;
        {
            p = (void *)((*pa).uarray.ptr);
            elemtype = (int64_t)((*(*a).objptr).uarray.elemtag);
        }break;
        case 5:;
        {
            p = (void *)((*pa).ustr.strptr);
            elemtype = (int64_t)44;
            if ((p == 0)) {
                p = (void *)((uint8_t*)"");
            };
        }break;
        case 33:;
        {
            p = (void *)((*pa).ustruct.ptr);
            elemtype = (int64_t)((*a).tag);
        }break;
        default: {
            if (!!((uint64_t)((*a).hasref))) {
                p = (void *)(pa);
                elemtype = (int64_t)0;
                goto L769 ;
;
            };
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(pc_support_gettypename((int64_t)(pc_decls_ttbasetype[((int64_t)((*a).tag))])),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            pc_support_pcustype((uint8_t*)"Getrefpack1",a);
            return (void *)(pc_decls_pcptr);
        }
        } //SW
;
    }break;
    case 23:;
    case 24:;
    {
        return (void *)((pc_decls_pcptr + (int64_t)1));
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"Getrefpack2",pc_decls_sptr);
        return (void *)(pc_decls_pcptr);
    }
    } //SW
;
    //done:
L769 :;
;
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)23);
    (*pc_decls_sptr).uref.ptr = (byte *)(p);
    (*pc_decls_sptr).uref.elemtag = (uint64_t)(elemtype);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_jump(void) {
    return (void *)((int64_t *)((*(pc_decls_pcptr + (int64_t)1))));
}

void * pc_khandlers_k_jumpptr(void) {
    if (((int64_t)((uint64_t)((*pc_decls_sptr).tag)) != (int64_t)20)) {
        pc_support_pcerror((uint8_t*)"Bad label ptr");
    };
    pc_decls_pcptr = (int64_t *)((*pc_decls_sptr).refptr);
    ++pc_decls_sptr;
    return (void *)(pc_decls_pcptr);
}

void * pc_khandlers_k_jumptrue(void) {
    return (void *)(((*pc_decls_jumptrue_table[((int64_t)((*pc_decls_sptr).tag))]))());
}

void * pc_khandlers_k_jumpfalse(void) {
    return (void *)(((*pc_decls_jumpfalse_table[((int64_t)((*pc_decls_sptr).tag))]))());
}

void * pc_khandlers_k_jumpdef(void) {
    if (((int64_t)((uint64_t)((*pc_decls_sptr).tag)) != (int64_t)0)) {
        if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
            pc_pcfns_pc_unshare(pc_decls_sptr);
        };
        ++pc_decls_sptr;
        return (void *)((int64_t *)((*(pc_decls_pcptr + (int64_t)1))));
    };
    if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
        pc_pcfns_pc_unshare(pc_decls_sptr);
    };
    ++pc_decls_sptr;
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_jumpvoid(void) {
    if (((int64_t)((uint64_t)((*pc_decls_sptr).tag)) == (int64_t)0)) {
        if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
            pc_pcfns_pc_unshare(pc_decls_sptr);
        };
        ++pc_decls_sptr;
        return (void *)((int64_t *)((*(pc_decls_pcptr + (int64_t)1))));
    };
    if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
        pc_pcfns_pc_unshare(pc_decls_sptr);
    };
    ++pc_decls_sptr;
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_jumpeq(void) {
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == yt)) {
        return (void *)(((*pc_decls_jumpeq_table[(yt)]))());
    };
    pc_decls_opc_tableptr = &pc_decls_jumpeq_table;
    return (void *)(((*pc_decls_jumpeq_dtable[((int64_t)(pc_decls_sigmap[((int64_t)((*(pc_decls_sptr + (int64_t)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_jumpne(void) {
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == yt)) {
        return (void *)(((*pc_decls_jumpne_table[(yt)]))());
    };
    pc_decls_opc_tableptr = &pc_decls_jumpne_table;
    return (void *)(((*pc_decls_jumpne_dtable[((int64_t)(pc_decls_sigmap[((int64_t)((*(pc_decls_sptr + (int64_t)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_jumplt(void) {
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == yt)) {
        return (void *)(((*pc_decls_jumplt_table[(yt)]))());
    };
    pc_decls_opc_tableptr = &pc_decls_jumplt_table;
    return (void *)(((*pc_decls_jumplt_dtable[((int64_t)(pc_decls_sigmap[((int64_t)((*(pc_decls_sptr + (int64_t)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_jumple(void) {
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == yt)) {
        return (void *)(((*pc_decls_jumple_table[(yt)]))());
    };
    pc_decls_opc_tableptr = &pc_decls_jumple_table;
    return (void *)(((*pc_decls_jumple_dtable[((int64_t)(pc_decls_sigmap[((int64_t)((*(pc_decls_sptr + (int64_t)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_jumpge(void) {
    struct pc_decls_varrec *  y;
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == yt)) {
        switch (yt) {
        case 1:;
        {
            y = pc_decls_sptr++;
            if (((*pc_decls_sptr).value >= (*y).value)) {
                ++pc_decls_sptr;
                return (void *)((int64_t *)((*(pc_decls_pcptr + (int64_t)1))));
            };
            ++pc_decls_sptr;
            return (void *)((pc_decls_pcptr + (int64_t)2));
        }break;
        default: {
            return (void *)(((*pc_decls_jumpge_table[(yt)]))());
        }
        } //SW
;
    };
    pc_decls_opc_tableptr = &pc_decls_jumpge_table;
    return (void *)(((*pc_decls_jumpge_dtable[((int64_t)(pc_decls_sigmap[((int64_t)((*(pc_decls_sptr + (int64_t)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_jumpgt(void) {
    struct pc_decls_varrec *  y;
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == yt)) {
        switch (yt) {
        case 1:;
        {
            y = pc_decls_sptr++;
            if (((*pc_decls_sptr).value > (*y).value)) {
                ++pc_decls_sptr;
                return (void *)((int64_t *)((*(pc_decls_pcptr + (int64_t)1))));
            };
            ++pc_decls_sptr;
            return (void *)((pc_decls_pcptr + (int64_t)2));
        }break;
        default: {
            return (void *)(((*pc_decls_jumpgt_table[(yt)]))());
        }
        } //SW
;
    };
    pc_decls_opc_tableptr = &pc_decls_jumpgt_table;
    return (void *)(((*pc_decls_jumpgt_dtable[((int64_t)(pc_decls_sigmap[((int64_t)((*(pc_decls_sptr + (int64_t)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_jumptesteq(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64_t xt;
    int64_t yt;
    int64_t res;
    struct pc_decls_objrec *  py;
    y = pc_decls_sptr++;
    x = pc_decls_sptr;
    xt = (int64_t)((*x).tag);
    yt = (int64_t)((*y).tag);
    if ((xt != yt)) {
        if (!!((xt = pc_dxfns_dx_mixed(x,y)))) {
            goto L770 ;
;
        };
        xt = (int64_t)((*x).tag);
        yt = (int64_t)((*y).tag);
        switch (xt) {
        case 1:;
        {
            switch (yt) {
            case 4:;
            {
                if ((((*x).value < (int64_t)((*y).range_lower)) || ((*x).value > (int64_t)((*y).range_upper)))) {
                    return (void *)((pc_decls_pcptr + (int64_t)2));
                };
            }break;
            case 9:;
            {
                py = (*y).objptr;
                if (((((int64_t)((uint64_t)((*py).uset.length)) == (int64_t)0) || ((*x).value >= (int64_t)((uint64_t)((*py).uset.length)))) || !(!!(pc_support_testelem((byte (*)[])((*py).uset.ptr),(*x).value))))) {
                    return (void *)((pc_decls_pcptr + (int64_t)2));
                };
            }break;
            default: {
                return (void *)((pc_decls_pcptr + (int64_t)2));
            }
            } //SW
;
        }break;
        default: {
            return (void *)((pc_decls_pcptr + (int64_t)2));
        }
        } //SW
;
        ++pc_decls_sptr;
        return (void *)((int64_t *)((*(pc_decls_pcptr + (int64_t)1))));
    };
    //retry:
L770 :;
;
    switch (xt) {
    case 1:;
    case 13:;
    {
        if (((*x).value == (*y).value)) {
            ++pc_decls_sptr;
            return (void *)((int64_t *)((*(pc_decls_pcptr + (int64_t)1))));
        };
    }break;
    case 3:;
    {
        if (((*x).xvalue == (*y).xvalue)) {
            ++pc_decls_sptr;
            return (void *)((int64_t *)((*(pc_decls_pcptr + (int64_t)1))));
        };
    }break;
    case 4:;
    {
        if (((*x).value == (*y).value)) {
            ++pc_decls_sptr;
            return (void *)((int64_t *)((*(pc_decls_pcptr + (int64_t)1))));
        };
    }break;
    case 5:;
    {
        res = pc_pcfns_pc_eqstring_nf(x,y);
        if (!!((uint64_t)((*y).hasref))) {
            pc_pcfns_pc_unshare(y);
        };
        if (!!(res)) {
            if (!!((uint64_t)((*x).hasref))) {
                pc_pcfns_pc_unshare(x);
            };
            ++pc_decls_sptr;
            return (void *)((int64_t *)((*(pc_decls_pcptr + (int64_t)1))));
        };
    }break;
    default: {
        res = pc_pcfns_pc_equal_nf(x,y,(int64_t)0);
        if (!!((uint64_t)((*x).hasref))) {
            pc_pcfns_pc_unshare(x);
        };
        if (!!((uint64_t)((*y).hasref))) {
            pc_pcfns_pc_unshare(y);
        };
        if (!!(res)) {
            ++pc_decls_sptr;
            return (void *)((int64_t *)((*(pc_decls_pcptr + (int64_t)1))));
        };
    }
    } //SW
;
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_jumptestne(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64_t xt;
    int64_t yt;
    int64_t res;
    struct pc_decls_objrec *  py;
    y = pc_decls_sptr++;
    x = pc_decls_sptr;
    xt = (int64_t)((*x).tag);
    yt = (int64_t)((*y).tag);
    if ((xt != yt)) {
        if (!!((xt = pc_dxfns_dx_mixed(x,y)))) {
            goto L771 ;
;
        };
        xt = (int64_t)((*x).tag);
        yt = (int64_t)((*y).tag);
        switch (xt) {
        case 1:;
        {
            switch (yt) {
            case 4:;
            {
                if ((((*x).value >= (int64_t)((*y).range_lower)) && ((*x).value <= (int64_t)((*y).range_upper)))) {
                    ++pc_decls_sptr;
                    return (void *)((pc_decls_pcptr + (int64_t)2));
                };
            }break;
            case 9:;
            {
                py = (*y).objptr;
                if ((((*x).value < (int64_t)((uint64_t)((*py).uset.length))) && !!(pc_support_testelem((byte (*)[])((*py).uset.ptr),(*x).value)))) {
                    ++pc_decls_sptr;
                    return (void *)((pc_decls_pcptr + (int64_t)2));
                };
            }break;
            default: {
            }
            } //SW
;
        }break;
        default: {
        }
        } //SW
;
        return (void *)((int64_t *)((*(pc_decls_pcptr + (int64_t)1))));
    };
    //retry:
L771 :;
;
    switch (xt) {
    case 1:;
    case 13:;
    {
        if (((*x).value != (*y).value)) {
            return (void *)((int64_t *)((*(pc_decls_pcptr + (int64_t)1))));
        };
        ++pc_decls_sptr;
    }break;
    case 3:;
    {
        if (((*x).xvalue != (*y).xvalue)) {
            return (void *)((int64_t *)((*(pc_decls_pcptr + (int64_t)1))));
        };
        ++pc_decls_sptr;
    }break;
    case 4:;
    {
        if (((*x).value != (*y).value)) {
            return (void *)((int64_t *)((*(pc_decls_pcptr + (int64_t)1))));
        };
        ++pc_decls_sptr;
    }break;
    case 5:;
    {
        res = pc_pcfns_pc_eqstring_nf(x,y);
        if (!!((uint64_t)((*y).hasref))) {
            pc_pcfns_pc_unshare(y);
        };
        if (!(!!(res))) {
            return (void *)((int64_t *)((*(pc_decls_pcptr + (int64_t)1))));
        };
        if (!!((uint64_t)((*x).hasref))) {
            pc_pcfns_pc_unshare(x);
        };
        ++pc_decls_sptr;
    }break;
    default: {
        res = pc_pcfns_pc_equal_nf(x,y,(int64_t)0);
        if (!!((uint64_t)((*y).hasref))) {
            pc_pcfns_pc_unshare(y);
        };
        if (!(!!(res))) {
            return (void *)((int64_t *)((*(pc_decls_pcptr + (int64_t)1))));
        };
        if (!!((uint64_t)((*x).hasref))) {
            pc_pcfns_pc_unshare(x);
        };
        ++pc_decls_sptr;
    }
    } //SW
;
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_jumplabel(void) {
    pc_support_pclunimpl((int64_t)53);
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_jumpclabel(void) {
    pc_support_pclunimpl((int64_t)54);
    return (void *)((pc_decls_pcptr + (int64_t)3));
}

void * pc_khandlers_k_switch(void) {
    int64_t index;
    int64_t n;
    int64_t lower;
    n = (*(pc_decls_pcptr + (int64_t)1));
    lower = (*(pc_decls_pcptr + (int64_t)2));
    if (((int64_t)((*pc_decls_sptr).tag)==(int64_t)1) || ((int64_t)((*pc_decls_sptr).tag)==(int64_t)13)) {
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(pc_decls_ttname[((int64_t)((*pc_decls_sptr).tag))],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        pc_support_pcerror((uint8_t*)"switch not int");
    };
    index = ((*pc_decls_sptr++).value - lower);
    if (((uint64_t)((uint32_t)(index)) >= (uint64_t)((uint32_t)(n)))) {
        return (void *)((int64_t *)((*((pc_decls_pcptr + (n * (int64_t)2)) + (int64_t)4))));
    } else {
        return (void *)((int64_t *)((*((pc_decls_pcptr + (index * (int64_t)2)) + (int64_t)4))));
    };
}

void * pc_khandlers_k_cswitch(void) {
    pc_support_pclunimpl((int64_t)56);
    return (void *)((pc_decls_pcptr + (int64_t)4));
}

void * pc_khandlers_k_new(void) {
    pc_support_pclunimpl((int64_t)57);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_to_f(void) {
    if (!!(--(*(struct pc_decls_varrec *)((pc_decls_frameptr + (*(pc_decls_pcptr + (int64_t)2))))).value)) {
        return (void *)((int64_t *)((*(pc_decls_pcptr + (int64_t)1))));
    } else {
        return (void *)((pc_decls_pcptr + (int64_t)3));
    };
}

void * pc_khandlers_k_for_fci(void) {
    if ((++(*(struct pc_decls_varrec *)((pc_decls_frameptr + (*(pc_decls_pcptr + (int64_t)2))))).value <= (*(pc_decls_pcptr + (int64_t)3)))) {
        return (void *)((int64_t *)((*(pc_decls_pcptr + (int64_t)1))));
    } else {
        return (void *)((pc_decls_pcptr + (int64_t)4));
    };
}

void * pc_khandlers_k_for_ff(void) {
    if ((++(*(struct pc_decls_varrec *)((pc_decls_frameptr + (*(pc_decls_pcptr + (int64_t)2))))).value <= (*(struct pc_decls_varrec *)((pc_decls_frameptr + (*(pc_decls_pcptr + (int64_t)3))))).value)) {
        return (void *)((int64_t *)((*(pc_decls_pcptr + (int64_t)1))));
    } else {
        return (void *)((pc_decls_pcptr + (int64_t)4));
    };
}

void * pc_khandlers_k_ford_fci(void) {
    if ((--(*(struct pc_decls_varrec *)((pc_decls_frameptr + (*(pc_decls_pcptr + (int64_t)2))))).value >= (*(pc_decls_pcptr + (int64_t)3)))) {
        return (void *)((int64_t *)((*(pc_decls_pcptr + (int64_t)1))));
    } else {
        return (void *)((pc_decls_pcptr + (int64_t)4));
    };
}

void * pc_khandlers_k_ford_ff(void) {
    if ((--(*(struct pc_decls_varrec *)((pc_decls_frameptr + (*(pc_decls_pcptr + (int64_t)2))))).value >= (*(struct pc_decls_varrec *)((pc_decls_frameptr + (*(pc_decls_pcptr + (int64_t)3))))).value)) {
        return (void *)((int64_t *)((*(pc_decls_pcptr + (int64_t)1))));
    } else {
        return (void *)((pc_decls_pcptr + (int64_t)4));
    };
}

void * pc_khandlers_k_call(void) {
    static int64_t count = (int64_t)10;
    if ((--count == (int64_t)0)) {
        count = (int64_t)10;
        osnos_os_peek();
    };
    if ((pc_decls_sptr <= pc_decls_stacklimit)) {
        pc_support_pcerror((uint8_t*)"Stack Overflow");
    };
    (*--pc_decls_sptr).tagx = (uint64_t)((int64_t)16);
    (*pc_decls_sptr).uret.retaddr = (pc_decls_pcptr + (int64_t)3);
    (*pc_decls_sptr).uret.frameptr_low = (int64_t)(*(int32_t*)&pc_decls_frameptr);
    (*pc_decls_sptr).uret.stackadj = (uint64_t)((*(pc_decls_pcptr + (int64_t)2)));
    pc_decls_frameptr = (byte *)(pc_decls_sptr);
    return (void *)((int64_t *)((*(pc_decls_pcptr + (int64_t)1))));
}

void * pc_khandlers_k_callptr(void) {
    int64_t *  newpc;
    if (((int64_t)((uint64_t)((*pc_decls_sptr).tag)) != (int64_t)18)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(pc_decls_ttname[((int64_t)((*pc_decls_sptr).tag))],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        pc_support_pcerror((uint8_t*)"callptr: not refproc");
    };
    newpc = (int64_t *)((*pc_decls_sptr).value);
    if (((*(pc_decls_pcptr + (int64_t)1)) != (*(newpc - (int64_t)1)))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_i64((*(pc_decls_pcptr + (int64_t)1)),NULL);
        msysnewc_m_print_i64((*(newpc - (int64_t)1)),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        pc_support_pcerror((uint8_t*)"callptr wrong # params");
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)16);
    (*pc_decls_sptr).uret.retaddr = (pc_decls_pcptr + (int64_t)3);
    (*pc_decls_sptr).uret.frameptr_low = (int64_t)(*(int32_t*)&pc_decls_frameptr);
    (*pc_decls_sptr).uret.stackadj = (uint64_t)((*(pc_decls_pcptr + (int64_t)2)));
    pc_decls_frameptr = (byte *)(pc_decls_sptr);
    return (void *)(newpc);
}

void * pc_khandlers_k_return(void) {
    if (((int64_t)((uint64_t)((*pc_decls_sptr).tag)) != (int64_t)16)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(pc_decls_ttname[((int64_t)((*pc_decls_sptr).tag))],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        pc_support_pcerror((uint8_t*)"Return error");
    };
    (*pc_decls_sptr).tag = (uint64_t)((int64_t)0);
    pc_decls_pcptr = (*pc_decls_sptr).uret.retaddr;
    (*(int32_t *)(&pc_decls_frameptr)) = (int64_t)((*pc_decls_sptr).uret.frameptr_low);
    pc_decls_sptr = (struct pc_decls_varrec *)(((byte *)(pc_decls_sptr) + (int64_t)((*pc_decls_sptr).uret.stackadj)));
    ++pc_decls_sptr;
    return (void *)(pc_decls_pcptr);
}

void * pc_khandlers_k_startdll(void) {
    if ((++pc_decls_dllcallindex > (int64_t)30)) {
        pc_support_pcerror((uint8_t*)"nested dll max");
    };
    pc_decls_dllcallstack[(pc_decls_dllcallindex)-1] = pc_decls_dllindex;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_pushdll(void) {
    int64_t s;
    int64_t t;
    int64_t u;
    struct pc_decls_objrec *  p;
    if ((++pc_decls_dllindex > (int64_t)29)) {
        pc_support_pcerror((uint8_t*)"dll params");
    };
    s = (int64_t)((*pc_decls_sptr).tag);
    if ((s == (int64_t)0)) {
        pc_support_pcerror((uint8_t*)"pushdll void arg");
    };
    t = (int64_t)(pc_decls_ttbasetype[((*(pc_decls_pcptr + (int64_t)1)))]);
    u = (int64_t)2;
    switch (t) {
    case 0:;
    {
        t = s;
        switch (s) {
        case 5:;
        {
            pc_decls_dllparams[(pc_decls_dllindex)-1] = (int64_t)(pc_support_convcstring((*(*pc_decls_sptr).objptr).ustr.strptr,(int64_t)((*(*pc_decls_sptr).objptr).ustr.length)));
        }break;
        default: {
            pc_decls_dllparams[(pc_decls_dllindex)-1] = (*pc_decls_sptr).value;
        }
        } //SW
;
        if ((s == (int64_t)3)) {
            u = (int64_t)3;
        };
    }break;
    case 40:;
    case 47:;
    case 39:;
    case 46:;
    {
        if (((int64_t)64 == (int64_t)32)) {
        };
        if ((s==(int64_t)1) || (s==(int64_t)2)) {
        }else if ((s==(int64_t)3)) {
            (*pc_decls_sptr).value = (int64_t)((*pc_decls_sptr).xvalue);
        }else if ((s==(int64_t)23)) {
            (*pc_decls_sptr).value = (int64_t)((*pc_decls_sptr).uref.ptr);
        } else {
            //error:
L772 :;
;
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(pc_decls_ttname[(s)],NULL);
            msysnewc_m_print_str((uint8_t*)"should be",NULL);
            msysnewc_m_print_str(pc_decls_ttname[(t)],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            pc_support_pcerror((uint8_t*)"DLL: param wrong type");
        };
        pc_decls_dllparams[(pc_decls_dllindex)-1] = (*pc_decls_sptr).value;
    }break;
    case 49:;
    {
        if (((int64_t)64 == (int64_t)32)) {
        };
        if ((s==(int64_t)1) || (s==(int64_t)2)) {
            (*pc_decls_sptr).xvalue = (double)((*pc_decls_sptr).value);
        }else if ((s==(int64_t)3)) {
        } else {
            goto L772 ;
;
        };
        u = (int64_t)3;
        pc_decls_dllparams[(pc_decls_dllindex)-1] = (*pc_decls_sptr).value;
    }break;
    case 5:;
    {
        if ((s==(int64_t)5)) {
            p = (*pc_decls_sptr).objptr;
            pc_decls_dllparams[(pc_decls_dllindex)-1] = (int64_t)(pc_support_convcstring((*p).ustr.strptr,(int64_t)((*p).ustr.length)));
        }else if ((s==(int64_t)1)) {
            if (((*pc_decls_sptr).value != (int64_t)0)) {
                goto L772 ;
;
            };
            pc_decls_dllparams[(pc_decls_dllindex)-1] = (int64_t)0;
        } else {
            goto L772 ;
;
        };
    }break;
    case 23:;
    {
        if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
            pc_decls_dllparams[(pc_decls_dllindex)-1] = (int64_t)((*(*pc_decls_sptr).objptr).uarray.ptr);
        } else {
            pc_decls_dllparams[(pc_decls_dllindex)-1] = (int64_t)((*pc_decls_sptr).refptr);
        };
    }break;
    case 52:;
    case 50:;
    case 51:;
    case 45:;
    {
        pc_decls_dllparams[(pc_decls_dllindex)-1] = (*pc_decls_sptr).value;
    }break;
    default: {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(pc_decls_ttname[(t)],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        pc_support_pcerror((uint8_t*)"OTHER DLL PARAM");
        pc_decls_dllparams[(pc_decls_dllindex)-1] = (*pc_decls_sptr).value;
    }
    } //SW
;
    pc_decls_dlltypes[(pc_decls_dllindex)-1] = u;
    if (((int64_t)((uint64_t)((*pc_decls_sptr).tag)) == (int64_t)5)) {
        if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
            pc_pcfns_pc_unshare(pc_decls_sptr);
        };
    };
    ++pc_decls_sptr;
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_calldll(void) {
    int64_t nparams;
    int64_t offset;
    if ((pc_decls_dllcallindex <= (int64_t)0)) {
        pc_support_pcerror((uint8_t*)"calldll??");
    };
    offset = pc_decls_dllcallstack[(pc_decls_dllcallindex)-1];
    nparams = (pc_decls_dllindex - offset);
    pc_oslayer_os_calldll((*(pc_decls_pcptr + (int64_t)2)),(*(pc_decls_pcptr + (int64_t)1)),offset,nparams,(*(pc_decls_pcptr + (int64_t)3)),pc_decls_sptr);
    pc_decls_dllindex = pc_decls_dllcallstack[(pc_decls_dllcallindex)-1];
    --pc_decls_dllcallindex;
    return (void *)((pc_decls_pcptr + (int64_t)4));
}

void * pc_khandlers_k_callhost(void) {
    pc_host_callhostfunction((*(pc_decls_pcptr + (int64_t)1)),(int64_t)0);
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_stackframe(void) {
    int64_t n;
    int64_t av_1;
    n = (*(pc_decls_pcptr + (int64_t)1));
    av_1 = n;
    while (av_1-- > 0) {
L773 :;
        (*--pc_decls_sptr).tagx = (uint64_t)((int64_t)0);
        (*pc_decls_sptr).value = (int64_t)0;
L774 :;
    }L775 :;
    ;
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_free(void) {
    int64_t n;
    int64_t av_1;
    n = (*(pc_decls_pcptr + (int64_t)1));
    av_1 = n;
    while (av_1-- > 0) {
L776 :;
        if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
            pc_pcfns_pc_unshare(pc_decls_sptr);
        };
        ++pc_decls_sptr;
L777 :;
    }L778 :;
    ;
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_addsp(void) {
    pc_decls_sptr = (struct pc_decls_varrec *)(((byte *)(pc_decls_sptr) + (*(pc_decls_pcptr + (int64_t)1))));
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_stop(void) {
    pc_khandlers_stopped = (uint64_t)((int64_t)1);
    return (void *)(pc_decls_pcptr);
}

void * pc_khandlers_k_test(void) {
    pc_support_pclunimpl((int64_t)74);
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_makelist(void) {
    int64_t n;
    int64_t lower;
    n = (*(pc_decls_pcptr + (int64_t)1));
    lower = (*(pc_decls_pcptr + (int64_t)2));
    pc_pcfns_pc_makelist(n,pc_decls_sptr,((pc_decls_sptr + n) - (int64_t)1),lower);
    pc_decls_sptr += (n - (int64_t)1);
    return (void *)((pc_decls_pcptr + (int64_t)3));
}

void * pc_khandlers_k_makerecord(void) {
    int64_t n;
    int64_t t;
    n = (*(pc_decls_pcptr + (int64_t)1));
    t = (*(pc_decls_pcptr + (int64_t)2));
    pc_pcfns_pc_makerecord(n,t,pc_decls_sptr,((pc_decls_sptr + n) - (int64_t)1));
    pc_decls_sptr += (n - (int64_t)1);
    return (void *)((pc_decls_pcptr + (int64_t)3));
}

void * pc_khandlers_k_makearray(void) {
    int64_t n;
    int64_t lower;
    int64_t t;
    n = (*(pc_decls_pcptr + (int64_t)1));
    lower = (*(pc_decls_pcptr + (int64_t)2));
    t = (*(pc_decls_pcptr + (int64_t)3));
    if (((int64_t)(pc_decls_ttbasetype[(t)]) == (int64_t)30)) {
        pc_pcfns_pc_makearray(n,t,(*(pc_decls_pcptr + (int64_t)4)),lower,pc_decls_sptr,((pc_decls_sptr + n) - (int64_t)1));
    } else {
        pc_support_pcerror((uint8_t*)"MAKEBITS");
    };
    pc_decls_sptr += (n - (int64_t)1);
    return (void *)((pc_decls_pcptr + (int64_t)5));
}

void * pc_khandlers_k_makestruct(void) {
    int64_t n;
    int64_t t;
    n = (*(pc_decls_pcptr + (int64_t)1));
    t = (*(pc_decls_pcptr + (int64_t)2));
    pc_pcfns_pc_makestruct(n,t,pc_decls_sptr,((pc_decls_sptr + n) - (int64_t)1));
    pc_decls_sptr += (n - (int64_t)1);
    return (void *)((pc_decls_pcptr + (int64_t)3));
}

void * pc_khandlers_k_makeset(void) {
    int64_t n;
    n = (*(pc_decls_pcptr + (int64_t)1));
    pc_pcfns_pc_makeset(n,pc_decls_sptr,((pc_decls_sptr + n) - (int64_t)1));
    pc_decls_sptr += (n - (int64_t)1);
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_makerange(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    pc_pcfns_pc_makerange(pc_decls_sptr,y,pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_makedict(void) {
    int64_t n;
    n = (*(pc_decls_pcptr + (int64_t)1));
    pc_pcfns_pc_makedict(n,pc_decls_sptr,((pc_decls_sptr + (n * (int64_t)2)) - (int64_t)1));
    pc_decls_sptr += ((n * (int64_t)2) - (int64_t)1);
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_pushdot(void) {
    int64_t n;
    int64_t fieldtype;
    byte *  xptr;
    int64_t dx;
    int64_t ix;
    struct pc_decls_genfielddatarec *  gd;
    struct pc_decls_genfielddatarec *  gd0;
    struct pc_decls_varrec v;
    int64_t av_1;
    v = (*pc_decls_sptr);
    if (((int64_t)(v.tag)==(int64_t)25)) {
        v.tagx = (uint64_t)(v.uref.elemtag);
    } else {
        if (!(!!((uint64_t)(v.hasref)))) {
            pc_support_pcerror((uint8_t*)"pushdot/not record");
        };
    };
    xptr = (byte *)((*v.objptr).urec.vptr);
    gd0 = (gd = &pc_decls_genfielddata[((ix = (int64_t)(pc_decls_genfieldnames[((*(pc_decls_pcptr + (int64_t)1)))-1].dataindex)))-1]);
    n = (int64_t)(pc_decls_genfieldnames[((*(pc_decls_pcptr + (int64_t)1)))-1].datalength);
    av_1 = n;
    while (av_1-- > 0) {
L779 :;
        if (((int64_t)((*gd).recordtype) == (int64_t)((uint64_t)(v.tag)))) {
            fieldtype = (int64_t)((*gd).fieldtype);
            if ((fieldtype == (int64_t)35)) {
                (*pc_decls_sptr) = (*(struct pc_decls_varrec *)((xptr + (int64_t)((*gd).offset))));
                if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
                    ++(*(*pc_decls_sptr).objptr).refcount;
                };
                if (!!((uint64_t)(v.hasref))) {
                    pc_pcfns_pc_unshare(&v);
                };
                return (void *)((pc_decls_pcptr + (int64_t)2));
            } else if ((fieldtype == (int64_t)18)) {
                dx = (gd - gd0);
                (*pc_decls_sptr).tagx = (uint64_t)((int64_t)18);
                (*pc_decls_sptr).refptr = (byte *)(pc_decls_genfieldpcaddress[((ix + (gd - gd0)))-1]);
                if (!!((uint64_t)(v.hasref))) {
                    pc_pcfns_pc_unshare(&v);
                };
                return (void *)((pc_decls_pcptr + (int64_t)2));
            } else {
                pc_pcfns_pc_loadpacked((void *)((xptr + (int64_t)((*gd).offset))),fieldtype,pc_decls_sptr,(struct pc_decls_objrec *)(0));
                if (!!((uint64_t)(v.hasref))) {
                    pc_pcfns_pc_unshare(&v);
                };
                return (void *)((pc_decls_pcptr + (int64_t)2));
            };
        };
        ++gd;
L780 :;
    }L781 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"Field:",NULL);
    msysnewc_m_print_i64(pc_decls_ngenfieldnames,NULL);
    msysnewc_m_print_str(pc_decls_genfieldnames[((*(pc_decls_pcptr + (int64_t)1)))-1].name,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    pc_support_pcustypet((uint8_t*)"Dotg: wrong record type",(int64_t)(v.tag));
    return (void *)(pc_decls_pcptr);
}

void * pc_khandlers_k_pushdotref(void) {
    struct pc_decls_varrec v;
    struct pc_decls_varrec *  p;
    int64_t n;
    int64_t fieldtype;
    int64_t isrefvar;
    int64_t rectype;
    int64_t offset;
    struct pc_decls_genfielddatarec *  gd;
    int64_t av_1;
    v = (*pc_decls_sptr);
    if (((int64_t)(v.tag)==(int64_t)22)) {
        p = v.varptr;
        isrefvar = (int64_t)1;
        rectype = (int64_t)((*p).tag);
        if ((rectype == (int64_t)25)) {
            rectype = (int64_t)((*p).uref.elemtag);
        };
        if (!(!!((uint64_t)((*(*p).objptr).urec.mutable)))) {
            (*p).objptr = pc_objlib_copyonwrite((*p).objptr,(int64_t)((*p).tag));
        };
    }else if (((int64_t)(v.tag)==(int64_t)23)) {
        isrefvar = (int64_t)0;
        rectype = (int64_t)(v.uref.elemtag);
    } else {
        pc_support_pcustype((uint8_t*)"&dotg not ref",&v);
        return (void *)(pc_decls_pcptr);
    };
    gd = &pc_decls_genfielddata[((int64_t)(pc_decls_genfieldnames[((*(pc_decls_pcptr + (int64_t)1)))-1].dataindex))-1];
    n = (int64_t)(pc_decls_genfieldnames[((*(pc_decls_pcptr + (int64_t)1)))-1].datalength);
    av_1 = n;
    while (av_1-- > 0) {
L782 :;
        if (((int64_t)((*gd).recordtype) == rectype)) {
            fieldtype = (int64_t)((*gd).fieldtype);
            offset = (int64_t)((*gd).offset);
            if (!!(isrefvar)) {
                if ((fieldtype == (int64_t)35)) {
                    (*pc_decls_sptr).refptr = ((byte *)((*(*p).objptr).urec.vptr) + offset);
                } else {
                    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)23);
                    (*pc_decls_sptr).refptr = ((*(*p).objptr).uarray.ptr + offset);
                    (*pc_decls_sptr).uref.elemtag = (uint64_t)(fieldtype);
                };
            } else {
                (*pc_decls_sptr).uref.ptr += offset;
                (*pc_decls_sptr).uref.elemtag = (uint64_t)(fieldtype);
            };
            return (void *)((pc_decls_pcptr + (int64_t)2));
        };
        ++gd;
L783 :;
    }L784 :;
    ;
    pc_support_pcustypet((uint8_t*)"&Dotg: wrong record type",rectype);
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_softconv(void) {
    int64_t t;
    t = (*(pc_decls_pcptr + (int64_t)1));
    (*pc_decls_sptr).tagx = (uint64_t)(t);
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_hardconv(void) {
    int64_t s;
    int64_t t;
    s = (int64_t)((*pc_decls_sptr).tag);
    t = (*(pc_decls_pcptr + (int64_t)1));
    if (((int64_t)((uint64_t)((*pc_decls_sptr).tag)) != t)) {
        pc_pcfns_pc_iconvert(t,pc_decls_sptr);
    };
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_mixed(void) {
    pc_support_pclunimpl((int64_t)86);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_incrptr(void) {
    struct pc_decls_varrec *  p;
    p = pc_decls_sptr++;
    switch ((int64_t)(pc_decls_ttbasetype[((int64_t)((*p).tag))])) {
    case 22:;
    {
        p = (*p).varptr;
        switch ((int64_t)((*p).tag)) {
        case 1:;
        {
            ++(*p).value;
        }break;
        case 22:;
        {
            ++(*p).varptr;
        }break;
        case 23:;
        {
            (*p).uref.ptr += pc_decls_ttsize[((int64_t)((*p).uref.elemtag))];
        }break;
        default: {
            pc_support_pcustype((uint8_t*)"incrptr/refvar",p);
        }
        } //SW
;
    }break;
    case 23:;
    {
        switch ((int64_t)((*p).uref.elemtag)) {
        case 44:;
        case 37:;
        {
            ++(*(*p).uref.ptr);
        }break;
        default: {
            pc_support_pcustypet((uint8_t*)"incrptr/ref",(int64_t)((*p).uref.elemtag));
        }
        } //SW
;
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"incrptr",p);
    }
    } //SW
;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_incrto_m(void) {
    struct pc_decls_varrec *  a;
    a = (struct pc_decls_varrec *)((*(pc_decls_pcptr + (int64_t)1)));
    switch ((int64_t)(pc_decls_ttbasetype[((int64_t)((*a).tag))])) {
    case 1:;
    {
        ++(*a).value;
    }break;
    case 22:;
    {
        ++(*a).varptr;
    }break;
    case 23:;
    {
        (*a).uref.ptr += pc_decls_ttsize[((int64_t)((*a).uref.elemtag))];
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"INCRTO_M",a);
    }
    } //SW
;
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_incrto_f(void) {
    struct pc_decls_varrec *  a;
    int64_t offset;
    a = (struct pc_decls_varrec *)((pc_decls_frameptr + (*(pc_decls_pcptr + (int64_t)1))));
    switch ((int64_t)((*a).tag)) {
    case 1:;
    {
        ++(*a).value;
        return (void *)((pc_decls_pcptr + (int64_t)2));
    }break;
    case 22:;
    {
        ++(*a).varptr;
    }break;
    case 23:;
    {
        (*a).uref.ptr += pc_decls_ttsize[((int64_t)((*a).uref.elemtag))];
    }break;
    case 24:;
    {
        if (!!((uint64_t)((*a).uref.bitlength))) {
            pc_support_pcerror((uint8_t*)"INCR/BITFIELD");
        };
        offset = ((int64_t)((uint64_t)((*a).uref.bitoffset)) + pc_types_stdtypewidths[((int64_t)((*a).uref.elemtag))]);
        if ((offset >= (int64_t)8)) {
            offset = (int64_t)0;
            ++(*a).uref.ptr;
        };
        (*a).uref.bitoffset = (uint64_t)(offset);
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"INCRTO_F",a);
    }
    } //SW
;
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_loadincr(void) {
    struct pc_decls_varrec ptr;
    ptr = (*pc_decls_sptr);
    pc_pcfns_pc_loadptr(pc_decls_sptr,pc_decls_sptr);
    --pc_decls_sptr;
    (*pc_decls_sptr) = ptr;
    return pc_khandlers_k_incrptr();
}

void * pc_khandlers_k_incrload(void) {
    int64_t *  pc;
    struct pc_decls_varrec ptr;
    ptr = (*pc_decls_sptr);
    pc = (int64_t *)(pc_khandlers_k_incrptr());
    pc_pcfns_pc_loadptr(&ptr,--pc_decls_sptr);
    return (void *)(pc);
}

void * pc_khandlers_k_decrptr(void) {
    struct pc_decls_varrec *  p;
    p = pc_decls_sptr++;
    switch ((int64_t)(pc_decls_ttbasetype[((int64_t)((*p).tag))])) {
    case 22:;
    {
        p = (*p).varptr;
        switch ((int64_t)((*p).tag)) {
        case 1:;
        {
            --(*p).value;
        }break;
        case 22:;
        {
            --(*p).varptr;
        }break;
        case 23:;
        {
            (*p).uref.ptr -= pc_decls_ttsize[((int64_t)((*p).uref.elemtag))];
        }break;
        default: {
            pc_support_pcustype((uint8_t*)"decrptr/refvar",p);
        }
        } //SW
;
    }break;
    case 23:;
    {
        switch ((int64_t)((*p).uref.elemtag)) {
        case 39:;
        {
            --(*(*p).uref.ptr64);
        }break;
        case 44:;
        case 37:;
        {
            --(*(*p).uref.ptr);
        }break;
        default: {
            pc_support_pcustypet((uint8_t*)"decrptr/ref",(int64_t)((*p).uref.elemtag));
        }
        } //SW
;
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"decrptr",p);
    }
    } //SW
;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_decrto_m(void) {
    struct pc_decls_varrec *  a;
    a = (struct pc_decls_varrec *)((*(pc_decls_pcptr + (int64_t)1)));
    switch ((int64_t)((*a).tag)) {
    case 1:;
    {
        --(*a).value;
    }break;
    case 22:;
    {
        --(*a).varptr;
    }break;
    case 23:;
    {
        (*a).uref.ptr -= pc_decls_ttsize[((int64_t)((*a).uref.elemtag))];
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"DECRTO_M",a);
    }
    } //SW
;
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_decrto_f(void) {
    struct pc_decls_varrec *  a;
    a = (struct pc_decls_varrec *)((pc_decls_frameptr + (*(pc_decls_pcptr + (int64_t)1))));
    switch ((int64_t)((*a).tag)) {
    case 1:;
    {
        --(*a).value;
    }break;
    case 22:;
    {
        --(*a).varptr;
    }break;
    case 23:;
    {
        (*a).uref.ptr -= pc_decls_ttsize[((int64_t)((*a).uref.elemtag))];
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"DECRTO_F",a);
    }
    } //SW
;
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_loaddecr(void) {
    struct pc_decls_varrec ptr;
    ptr = (*pc_decls_sptr);
    pc_pcfns_pc_loadptr(pc_decls_sptr,pc_decls_sptr);
    (*--pc_decls_sptr) = ptr;
    return pc_khandlers_k_decrptr();
}

void * pc_khandlers_k_decrload(void) {
    int64_t *  pc;
    struct pc_decls_varrec ptr;
    ptr = (*pc_decls_sptr);
    pc = (int64_t *)(pc_khandlers_k_decrptr());
    pc_pcfns_pc_loadptr(&ptr,--pc_decls_sptr);
    return (void *)(pc);
}

void * pc_khandlers_k_incr(void) {
    pc_support_pclunimpl((int64_t)97);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_decr(void) {
    if (((int64_t)((*pc_decls_sptr).tag)==(int64_t)1)) {
        --(*pc_decls_sptr).value;
    } else {
        pc_support_pcustype((uint8_t*)"decr",pc_decls_sptr);
    };
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_neg(void) {
    return (void *)(((*pc_decls_neg_table[((int64_t)((*pc_decls_sptr).tag))]))());
}

void * pc_khandlers_k_abs(void) {
    return (void *)(((*pc_decls_abs_table[((int64_t)((*pc_decls_sptr).tag))]))());
}

void * pc_khandlers_k_not(void) {
    (*pc_decls_sptr).value = !((*pc_decls_sptr).value);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_inot(void) {
    return (void *)(((*pc_decls_inot_table[((int64_t)((*pc_decls_sptr).tag))]))());
}

void * pc_khandlers_k_istrue(void) {
    return (void *)(((*pc_decls_istrue_table[((int64_t)((*pc_decls_sptr).tag))]))());
}

void * pc_khandlers_k_asc(void) {
    int64_t a;
    struct pc_decls_objrec *  s;
    switch ((int64_t)((*pc_decls_sptr).tag)) {
    case 5:;
    {
        s = (*pc_decls_sptr).objptr;
        if (((int64_t)((*s).ustr.length) == (int64_t)0)) {
            a = (int64_t)0;
        } else {
            a = (int64_t)((*(*s).ustr.strptr));
            if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
                pc_pcfns_pc_unshare(pc_decls_sptr);
            };
        };
        (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
        (*pc_decls_sptr).value = a;
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"ASC",pc_decls_sptr);
    }
    } //SW
;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_chr(void) {
    switch ((int64_t)((*pc_decls_sptr).tag)) {
    case 1:;
    {
        if (((int64_t)((*pc_decls_sptr).uvalue) > (int64_t)255)) {
            pc_support_pcerror((uint8_t*)"chr>255");
        };
        pc_pcfns_pc_makechar((*pc_decls_sptr).value,pc_decls_sptr);
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"CHR",pc_decls_sptr);
    }
    } //SW
;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_sqrt(void) {
    pc_decls_pcptr += (int64_t)1;
    switch ((int64_t)((*pc_decls_sptr).tag)) {
    case 1:;
    {
        (*pc_decls_sptr).tagx = (uint64_t)((int64_t)3);
        (*pc_decls_sptr).xvalue = sqrt(((double)((*pc_decls_sptr).value)));
    }break;
    case 3:;
    {
        (*pc_decls_sptr).xvalue = sqrt(((*pc_decls_sptr).xvalue));
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"SQRT",pc_decls_sptr);
    }
    } //SW
;
    return (void *)(pc_decls_pcptr);
}

void * pc_khandlers_k_sqr(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec result;
    x = pc_decls_sptr;
    switch ((int64_t)((*x).tag)) {
    case 1:;
    {
        (*pc_decls_sptr).value = ((*x).value * (*x).value);
    }break;
    case 3:;
    {
        (*pc_decls_sptr).xvalue = ((*x).xvalue * (*x).xvalue);
    }break;
    case 7:;
    {
        pc_bignum_bx_mul(x,x,&result);
        pc_pcfns_pc_unshare(x);
        (*pc_decls_sptr) = result;
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"SQR",x);
    }
    } //SW
;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_cube(void) {
    pc_support_pclunimpl((int64_t)108);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_sin(void) {
    struct pc_decls_varrec *  x;
    x = pc_decls_sptr;
    switch ((int64_t)((*x).tag)) {
    case 3:;
    {
        (*pc_decls_sptr).xvalue = sin((*x).xvalue);
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"SIN",x);
    }
    } //SW
;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_cos(void) {
    struct pc_decls_varrec *  x;
    x = pc_decls_sptr;
    switch ((int64_t)((*x).tag)) {
    case 3:;
    {
        (*pc_decls_sptr).xvalue = cos((*x).xvalue);
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"COS",x);
    }
    } //SW
;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_tan(void) {
    pc_support_pclunimpl((int64_t)111);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_asin(void) {
    pc_support_pclunimpl((int64_t)112);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_acos(void) {
    pc_support_pclunimpl((int64_t)113);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_atan(void) {
    struct pc_decls_varrec *  x;
    x = pc_decls_sptr;
    switch ((int64_t)((*x).tag)) {
    case 1:;
    {
        (*pc_decls_sptr).xvalue = atan((double)((*x).value));
        (*pc_decls_sptr).tagx = (uint64_t)((int64_t)3);
    }break;
    case 3:;
    {
        (*pc_decls_sptr).xvalue = atan((*x).xvalue);
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"ATAN",x);
    }
    } //SW
;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_sign(void) {
    pc_support_pclunimpl((int64_t)115);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_ln(void) {
    switch ((int64_t)((*pc_decls_sptr).tag)) {
    case 3:;
    {
        (*pc_decls_sptr).xvalue = log((*pc_decls_sptr).xvalue);
    }break;
    case 1:;
    {
        (*pc_decls_sptr).xvalue = log((double)((*pc_decls_sptr).value));
        (*pc_decls_sptr).tag = (uint64_t)((int64_t)3);
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"LN",pc_decls_sptr);
    }
    } //SW
;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_log(void) {
    pc_support_pclunimpl((int64_t)117);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_lg(void) {
    pc_support_pclunimpl((int64_t)118);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_exp(void) {
    switch ((int64_t)((*pc_decls_sptr).tag)) {
    case 3:;
    {
        (*pc_decls_sptr).xvalue = exp((*pc_decls_sptr).xvalue);
    }break;
    case 1:;
    {
        (*pc_decls_sptr).xvalue = exp((double)((*pc_decls_sptr).value));
        (*pc_decls_sptr).tag = (uint64_t)((int64_t)3);
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"EXP",pc_decls_sptr);
    }
    } //SW
;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_round(void) {
    struct pc_decls_varrec *  x;
    x = pc_decls_sptr;
    switch ((int64_t)((*x).tag)) {
    case 3:;
    {
        if (((*x).xvalue >= (double)0.)) {
            (*pc_decls_sptr).xvalue = floor(((*x).xvalue + (double)0.5));
        } else {
            (*pc_decls_sptr).xvalue = ceil(((*x).xvalue - (double)0.5));
        };
    }break;
    case 1:;
    {
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"ROUND",x);
    }
    } //SW
;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_floor(void) {
    struct pc_decls_varrec *  x;
    x = pc_decls_sptr;
    switch ((int64_t)((*x).tag)) {
    case 3:;
    {
        if (((*x).xvalue >= (double)0.)) {
            (*pc_decls_sptr).xvalue = floor((*x).xvalue);
        } else {
            (*pc_decls_sptr).xvalue = ceil((*x).xvalue);
        };
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"FLOOR",x);
    }
    } //SW
;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_ceil(void) {
    pc_support_pclunimpl((int64_t)122);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_fract(void) {
    pc_support_pclunimpl((int64_t)123);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_negto(void) {
    pc_support_pclunimpl((int64_t)124);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_absto(void) {
    pc_support_pclunimpl((int64_t)125);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_notto(void) {
    pc_support_pclunimpl((int64_t)126);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_inotto(void) {
    pc_support_pclunimpl((int64_t)127);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_len(void) {
    return (void *)(((*pc_decls_len_table[((int64_t)((*pc_decls_sptr).tag))]))());
}

void * pc_khandlers_k_lwb(void) {
    return (void *)(((*pc_decls_lwb_table[((int64_t)((*pc_decls_sptr).tag))]))());
}

void * pc_khandlers_k_upb(void) {
    return (void *)(((*pc_decls_upb_table[((int64_t)((*pc_decls_sptr).tag))]))());
}

void * pc_khandlers_k_bounds(void) {
    return (void *)(((*pc_decls_bounds_table[((int64_t)((*pc_decls_sptr).tag))]))());
}

void * pc_khandlers_k_bits(void) {
    if (((int64_t)((*pc_decls_sptr).tag)==(int64_t)13)) {
        (*pc_decls_sptr).value = (int64_t)(pc_decls_ttbitwidth[((*pc_decls_sptr).value)]);
    } else {
        (*pc_decls_sptr).value = (int64_t)(pc_decls_ttbitwidth[((int64_t)((*pc_decls_sptr).tag))]);
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_bytes(void) {
    int64_t m;
    int64_t n;
    struct pc_decls_objrec *  p;
    m = (int64_t)((*pc_decls_sptr).tag);
    if ((m == (int64_t)13)) {
        m = (*pc_decls_sptr).value;
    };
    p = (*pc_decls_sptr).objptr;
    if (((int64_t)(pc_decls_ttbasetype[(m)])==(int64_t)5)) {
        n = (int64_t)((*p).ustr.length);
    }else if (((int64_t)(pc_decls_ttbasetype[(m)])==(int64_t)30)) {
        n = ((int64_t)((uint64_t)((*p).uarray.length)) * pc_decls_ttsize[((int64_t)((*p).uarray.elemtag))]);
    }else if (((int64_t)(pc_decls_ttbasetype[(m)])==(int64_t)9)) {
        n = ((int64_t)((uint64_t)((*p).uset.length)) / (int64_t)8);
    }else if (((int64_t)(pc_decls_ttbasetype[(m)])==(int64_t)31)) {
        if (((int64_t)((*p).ubits.elemtag)==(int64_t)41)) {
            n = ((int64_t)((uint64_t)((*p).ubits.length)) / (int64_t)8);
        }else if (((int64_t)((*p).ubits.elemtag)==(int64_t)42)) {
            n = ((int64_t)((uint64_t)((*p).ubits.length)) / (int64_t)4);
        }else if (((int64_t)((*p).ubits.elemtag)==(int64_t)43)) {
            n = ((int64_t)((uint64_t)((*p).ubits.length)) / (int64_t)2);
        };
    }else if (((int64_t)(pc_decls_ttbasetype[(m)])==(int64_t)29)) {
        n = ((int64_t)((uint64_t)((*p).ulist.length)) * (int64_t)16);
    } else {
        n = pc_decls_ttsize[(m)];
    };
    if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
        pc_pcfns_pc_unshare(pc_decls_sptr);
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = n;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_type(void) {
    int64_t res;
    res = (int64_t)((*pc_decls_sptr).tag);
    if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
        pc_pcfns_pc_unshare(pc_decls_sptr);
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)13);
    (*pc_decls_sptr).value = res;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_elemtype(void) {
    int64_t res;
    if (((int64_t)(pc_decls_ttbasetype[((int64_t)((*pc_decls_sptr).tag))])==(int64_t)30)) {
        res = (int64_t)((*(*pc_decls_sptr).objptr).uarray.elemtag);
        pc_pcfns_pc_unshare(pc_decls_sptr);
    }else if (((int64_t)(pc_decls_ttbasetype[((int64_t)((*pc_decls_sptr).tag))])==(int64_t)31)) {
        res = (int64_t)((*(*pc_decls_sptr).objptr).ubits.elemtag);
        pc_pcfns_pc_unshare(pc_decls_sptr);
    }else if (((int64_t)(pc_decls_ttbasetype[((int64_t)((*pc_decls_sptr).tag))])==(int64_t)23) || ((int64_t)(pc_decls_ttbasetype[((int64_t)((*pc_decls_sptr).tag))])==(int64_t)24)) {
        res = (int64_t)((*pc_decls_sptr).uref.elemtag);
    } else {
        pc_support_pcerror((uint8_t*)"elemtype");
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)13);
    (*pc_decls_sptr).value = res;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_basetype(void) {
    int64_t res;
    if (((int64_t)((uint64_t)((*pc_decls_sptr).tag)) == (int64_t)13)) {
        res = (int64_t)(pc_decls_ttbasetype[((*pc_decls_sptr).value)]);
    } else {
        res = (int64_t)(pc_decls_ttbasetype[((int64_t)((*pc_decls_sptr).tag))]);
    };
    if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
        pc_pcfns_pc_unshare(pc_decls_sptr);
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)13);
    (*pc_decls_sptr).value = res;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_minval(void) {
    int64_t t;
    int64_t a;
    switch ((int64_t)((*pc_decls_sptr).tag)) {
    case 1:;
    {
        t = (int64_t)40;
    }break;
    case 3:;
    {
        t = (int64_t)49;
    }break;
    case 13:;
    {
        t = (*pc_decls_sptr).value;
    }break;
    case 7:;
    {
        t = (int64_t)7;
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"Maxval",pc_decls_sptr);
    }
    } //SW
;
    if ((t==(int64_t)44) || (t==(int64_t)45) || (t==(int64_t)46) || (t==(int64_t)47)) {
        a = (int64_t)0;
    }else if ((t==(int64_t)37)) {
        a = (int64_t)-128;
    }else if ((t==(int64_t)38)) {
        a = (int64_t)-32768;
    }else if ((t==(int64_t)39)) {
        a = (int64_t)-2147483648;
    }else if ((t==(int64_t)40)) {
        a = (int64_t)((uint64_t)9223372036854775808u);
    }else if ((t==(int64_t)7)) {
        a = (int64_t)((uint64_t)9223372036854775808u);
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(pc_support_gettypename(t),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        pc_support_pcerror((uint8_t*)"MINVALUE");
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = a;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_maxval(void) {
    int64_t t;
    int64_t a;
    switch ((int64_t)((*pc_decls_sptr).tag)) {
    case 1:;
    {
        t = (int64_t)40;
    }break;
    case 3:;
    {
        t = (int64_t)49;
    }break;
    case 13:;
    {
        t = (*pc_decls_sptr).value;
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"Maxval",pc_decls_sptr);
    }
    } //SW
;
    if ((t==(int64_t)44)) {
        a = (int64_t)255;
    }else if ((t==(int64_t)45)) {
        a = (int64_t)65536;
    }else if ((t==(int64_t)46)) {
        a = (int64_t)4294967295;
    }else if ((t==(int64_t)47)) {
        a = (int64_t)((uint64_t)18446744073709551615u);
    }else if ((t==(int64_t)37)) {
        a = (int64_t)127;
    }else if ((t==(int64_t)38)) {
        a = (int64_t)32767;
    }else if ((t==(int64_t)39)) {
        a = (int64_t)2147483647;
    }else if ((t==(int64_t)40)) {
        a = (int64_t)((uint64_t)9223372036854775807u);
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(pc_support_gettypename(t),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        pc_support_pcerror((uint8_t*)"MAXVALUE");
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = a;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_isint(void) {
    if ((((int64_t)((uint64_t)((*pc_decls_sptr).tag)) == (int64_t)1) || ((int64_t)((uint64_t)((*pc_decls_sptr).tag)) == (int64_t)2))) {
        (*pc_decls_sptr).value = (int64_t)1;
    } else {
        if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
            pc_pcfns_pc_unshare(pc_decls_sptr);
        };
        (*pc_decls_sptr).value = (int64_t)0;
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_isreal(void) {
    if (((int64_t)((uint64_t)((*pc_decls_sptr).tag)) == (int64_t)3)) {
        (*pc_decls_sptr).value = (int64_t)1;
    } else {
        if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
            pc_pcfns_pc_unshare(pc_decls_sptr);
        };
        (*pc_decls_sptr).value = (int64_t)0;
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_isstring(void) {
    int64_t n;
    n = ((int64_t)((uint64_t)((*pc_decls_sptr).tag)) == (int64_t)5);
    if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
        pc_pcfns_pc_unshare(pc_decls_sptr);
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = n;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_isrange(void) {
    int64_t n;
    n = ((int64_t)((uint64_t)((*pc_decls_sptr).tag)) == (int64_t)4);
    if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
        pc_pcfns_pc_unshare(pc_decls_sptr);
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = n;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_isnumber(void) {
    pc_support_pclunimpl((int64_t)143);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_isarray(void) {
    int64_t n;
    switch ((int64_t)(pc_decls_ttbasetype[((int64_t)((*pc_decls_sptr).tag))])) {
    case 29:;
    case 30:;
    case 31:;
    {
        n = (int64_t)1;
    }break;
    default: {
        n = (int64_t)0;
    }
    } //SW
;
    if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
        pc_pcfns_pc_unshare(pc_decls_sptr);
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = n;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_isrecord(void) {
    int64_t n;
    n = (int64_t)0;
    switch ((int64_t)(pc_decls_ttbasetype[((int64_t)((*pc_decls_sptr).tag))])) {
    case 32:;
    case 33:;
    {
        n = (int64_t)1;
    }break;
    default: {
    }
    } //SW
;
    if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
        pc_pcfns_pc_unshare(pc_decls_sptr);
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = n;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_ispointer(void) {
    int64_t n;
    switch ((int64_t)(pc_decls_ttbasetype[((int64_t)((*pc_decls_sptr).tag))])) {
    case 23:;
    case 22:;
    case 24:;
    case 18:;
    case 20:;
    {
        n = (int64_t)1;
    }break;
    default: {
        n = (int64_t)0;
    }
    } //SW
;
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = n;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_ismutable(void) {
    pc_support_pclunimpl((int64_t)147);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_isset(void) {
    int64_t n;
    n = ((int64_t)(pc_decls_ttbasetype[((int64_t)((*pc_decls_sptr).tag))]) == (int64_t)9);
    if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
        pc_pcfns_pc_unshare(pc_decls_sptr);
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = n;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_isvoid(void) {
    if (((int64_t)((uint64_t)((*pc_decls_sptr).tag)) == (int64_t)0)) {
        (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
        (*pc_decls_sptr).value = (int64_t)1;
    } else {
        if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
            pc_pcfns_pc_unshare(pc_decls_sptr);
        };
        (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
        (*pc_decls_sptr).value = (int64_t)0;
    };
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_isdef(void) {
    if (((int64_t)((uint64_t)((*pc_decls_sptr).tag)) != (int64_t)0)) {
        (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
        (*pc_decls_sptr).value = (int64_t)1;
    } else {
        if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
            pc_pcfns_pc_unshare(pc_decls_sptr);
        };
        (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
        (*pc_decls_sptr).value = (int64_t)0;
    };
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_tostr(void) {
    pc_support_pclunimpl((int64_t)151);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_isequal(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64_t xt;
    int64_t yt;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    xt = (int64_t)((*x).tag);
    yt = (int64_t)((*y).tag);
    if ((xt == (int64_t)25)) {
        xt = (int64_t)((*x).uref.elemtag);
        (*x).hasref = (uint64_t)((int64_t)1);
    };
    if ((yt == (int64_t)25)) {
        yt = (int64_t)((*y).uref.elemtag);
    };
    if (((xt == yt) && !!((uint64_t)((*x).hasref)))) {
        (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
        (*pc_decls_sptr).value = ((*x).objptr == (*y).objptr);
        return (void *)((pc_decls_pcptr + (int64_t)1));
    };
    if ((((((xt == (int64_t)1) && ((*x).value == (int64_t)0)) && !!((uint64_t)((*y).hasref))) || (((yt == (int64_t)1) && ((*y).value == (int64_t)0)) && !!((uint64_t)((*x).hasref)))) || ((((xt == (int64_t)1) && (yt == (int64_t)1)) && ((*x).value == (int64_t)0)) && !!((*y).value)))) {
        (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
        (*pc_decls_sptr).value = (int64_t)0;
        return (void *)((pc_decls_pcptr + (int64_t)1));
    };
    pc_support_pcmxtypes((uint8_t*)"ISEQUAL",x,y);
    return 0;
}

void * pc_khandlers_k_add(void) {
    struct pc_decls_varrec *  y;
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == yt)) {
        switch (yt) {
        case 1:;
        {
            y = pc_decls_sptr++;
            (*pc_decls_sptr).value += (*y).value;
            return (void *)((pc_decls_pcptr + (int64_t)1));
        }break;
        case 3:;
        {
            y = pc_decls_sptr++;
            (*pc_decls_sptr).xvalue += (*y).xvalue;
            return (void *)((pc_decls_pcptr + (int64_t)1));
        }break;
        default: {
            return (void *)(((*pc_decls_add_table[(yt)]))());
        }
        } //SW
;
    };
    pc_decls_opc_tableptr = &pc_decls_add_table;
    return (void *)(((*pc_decls_add_dtable[((int64_t)(pc_decls_sigmap[((int64_t)((*(pc_decls_sptr + (int64_t)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_sub(void) {
    struct pc_decls_varrec *  y;
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == yt)) {
        switch (yt) {
        case 1:;
        {
            y = pc_decls_sptr++;
            (*pc_decls_sptr).value -= (*y).value;
            return (void *)((pc_decls_pcptr + (int64_t)1));
        }break;
        case 3:;
        {
            y = pc_decls_sptr++;
            (*pc_decls_sptr).xvalue -= (*y).xvalue;
            return (void *)((pc_decls_pcptr + (int64_t)1));
        }break;
        default: {
            return (void *)(((*pc_decls_sub_table[(yt)]))());
        }
        } //SW
;
    };
    pc_decls_opc_tableptr = &pc_decls_sub_table;
    return (void *)(((*pc_decls_sub_dtable[((int64_t)(pc_decls_sigmap[((int64_t)((*(pc_decls_sptr + (int64_t)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_mul(void) {
    struct pc_decls_varrec *  y;
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == yt)) {
        switch (yt) {
        case 1:;
        {
            y = pc_decls_sptr++;
            (*pc_decls_sptr).value *= (*y).value;
            return (void *)((pc_decls_pcptr + (int64_t)1));
        }break;
        case 3:;
        {
            y = pc_decls_sptr++;
            (*pc_decls_sptr).xvalue *= (*y).xvalue;
            return (void *)((pc_decls_pcptr + (int64_t)1));
        }break;
        default: {
            return (void *)(((*pc_decls_mul_table[(yt)]))());
        }
        } //SW
;
    };
    pc_decls_opc_tableptr = &pc_decls_mul_table;
    return (void *)(((*pc_decls_mul_dtable[((int64_t)(pc_decls_sigmap[((int64_t)((*(pc_decls_sptr + (int64_t)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_div(void) {
    struct pc_decls_varrec *  y;
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == yt)) {
        switch (yt) {
        case 1:;
        {
            y = pc_decls_sptr++;
            (*pc_decls_sptr).xvalue = ((double)((*pc_decls_sptr).value) / (double)((*y).value));
            (*pc_decls_sptr).tag = (uint64_t)((int64_t)3);
            return (void *)((pc_decls_pcptr + (int64_t)1));
        }break;
        case 3:;
        {
            y = pc_decls_sptr++;
            (*pc_decls_sptr).xvalue /= (*y).xvalue;
            return (void *)((pc_decls_pcptr + (int64_t)1));
        }break;
        default: {
            return (void *)(((*pc_decls_div_table[(yt)]))());
        }
        } //SW
;
    };
    pc_decls_opc_tableptr = &pc_decls_div_table;
    return (void *)(((*pc_decls_div_dtable[((int64_t)(pc_decls_sigmap[((int64_t)((*(pc_decls_sptr + (int64_t)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_idiv(void) {
    struct pc_decls_varrec *  y;
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == yt)) {
        switch (yt) {
        case 1:;
        {
            y = pc_decls_sptr++;
            (*pc_decls_sptr).value = ((*pc_decls_sptr).value / (*y).value);
            return (void *)((pc_decls_pcptr + (int64_t)1));
        }break;
        default: {
            return (void *)(((*pc_decls_idiv_table[(yt)]))());
        }
        } //SW
;
    };
    pc_decls_opc_tableptr = &pc_decls_idiv_table;
    return (void *)(((*pc_decls_idiv_dtable[((int64_t)(pc_decls_sigmap[((int64_t)((*(pc_decls_sptr + (int64_t)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_rem(void) {
    struct pc_decls_varrec *  y;
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == yt)) {
        switch (yt) {
        case 1:;
        {
            y = pc_decls_sptr++;
            (*pc_decls_sptr).value = ((*pc_decls_sptr).value % (*y).value);
            return (void *)((pc_decls_pcptr + (int64_t)1));
        }break;
        default: {
            return (void *)(((*pc_decls_rem_table[(yt)]))());
        }
        } //SW
;
    };
    pc_decls_opc_tableptr = &pc_decls_rem_table;
    return (void *)(((*pc_decls_rem_dtable[((int64_t)(pc_decls_sigmap[((int64_t)((*(pc_decls_sptr + (int64_t)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_divrem(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64_t d;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    d = (*x).value;
    if ((((uint64_t)((*x).tag) == (uint64_t)((*y).tag)) && ((int64_t)((uint64_t)((*y).tag)) == (int64_t)1))) {
        (*x).range_lower = (d / (*y).value);
        (*x).range_upper = (d % (*y).value);
        (*x).tagx = (uint64_t)((int64_t)4);
    } else {
        pc_support_pcmxtypes((uint8_t*)"DIVREM",x,y);
    };
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_iand(void) {
    struct pc_decls_varrec *  y;
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == yt)) {
        switch (yt) {
        case 1:;
        {
            y = pc_decls_sptr++;
            (*pc_decls_sptr).value &= (*y).value;
            return (void *)((pc_decls_pcptr + (int64_t)1));
        }break;
        default: {
            return (void *)(((*pc_decls_iand_table[(yt)]))());
        }
        } //SW
;
    };
    pc_decls_opc_tableptr = &pc_decls_iand_table;
    return (void *)(((*pc_decls_iand_dtable[((int64_t)(pc_decls_sigmap[((int64_t)((*(pc_decls_sptr + (int64_t)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_ior(void) {
    struct pc_decls_varrec *  y;
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == yt)) {
        switch (yt) {
        case 1:;
        {
            y = pc_decls_sptr++;
            (*pc_decls_sptr).value |= (*y).value;
            return (void *)((pc_decls_pcptr + (int64_t)1));
        }break;
        default: {
            return (void *)(((*pc_decls_ior_table[(yt)]))());
        }
        } //SW
;
    };
    pc_decls_opc_tableptr = &pc_decls_ior_table;
    return (void *)(((*pc_decls_ior_dtable[((int64_t)(pc_decls_sigmap[((int64_t)((*(pc_decls_sptr + (int64_t)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_ixor(void) {
    struct pc_decls_varrec *  y;
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == yt)) {
        switch (yt) {
        case 1:;
        {
            y = pc_decls_sptr++;
            (*pc_decls_sptr).value ^= (*y).value;
            return (void *)((pc_decls_pcptr + (int64_t)1));
        }break;
        default: {
            return (void *)(((*pc_decls_ixor_table[(yt)]))());
        }
        } //SW
;
    };
    pc_decls_opc_tableptr = &pc_decls_ixor_table;
    return (void *)(((*pc_decls_ixor_dtable[((int64_t)(pc_decls_sigmap[((int64_t)((*(pc_decls_sptr + (int64_t)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_shl(void) {
    struct pc_decls_varrec *  y;
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == yt)) {
        switch (yt) {
        case 1:;
        {
            y = pc_decls_sptr++;
            (*pc_decls_sptr).value <<= (*y).value;
            return (void *)((pc_decls_pcptr + (int64_t)1));
        }break;
        default: {
            return (void *)(((*pc_decls_shl_table[(yt)]))());
        }
        } //SW
;
    };
    pc_decls_opc_tableptr = &pc_decls_shl_table;
    return (void *)(((*pc_decls_shl_dtable[((int64_t)(pc_decls_sigmap[((int64_t)((*(pc_decls_sptr + (int64_t)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_shr(void) {
    struct pc_decls_varrec *  y;
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == yt)) {
        switch (yt) {
        case 1:;
        {
            y = pc_decls_sptr++;
            (*pc_decls_sptr).value >>= (*y).value;
            return (void *)((pc_decls_pcptr + (int64_t)1));
        }break;
        default: {
            return (void *)(((*pc_decls_shr_table[(yt)]))());
        }
        } //SW
;
    };
    pc_decls_opc_tableptr = &pc_decls_shr_table;
    return (void *)(((*pc_decls_shr_dtable[((int64_t)(pc_decls_sigmap[((int64_t)((*(pc_decls_sptr + (int64_t)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_in(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64_t n;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    n = pc_dxfns_dx_varinvar(x,y);
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = n;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_notin(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64_t n;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    n = pc_dxfns_dx_varinvar(x,y);
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = !(n);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_inrev(void) {
    pc_support_pclunimpl((int64_t)167);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_eq(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64_t res;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    res = pc_pcfns_pc_equal(x,y,(int64_t)0);
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = res;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_ne(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64_t res;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    res = pc_pcfns_pc_equal(x,y,(int64_t)0);
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = !(res);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_lt(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64_t res;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    res = pc_pcfns_pc_compare(x,y);
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = (res < (int64_t)0);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_le(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64_t res;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    res = pc_pcfns_pc_compare(x,y);
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = (res <= (int64_t)0);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_ge(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64_t res;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    res = pc_pcfns_pc_compare(x,y);
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = (res >= (int64_t)0);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_gt(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64_t res;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    res = pc_pcfns_pc_compare(x,y);
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = (res > (int64_t)0);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_min(void) {
    struct pc_decls_varrec *  y;
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == yt)) {
        switch (yt) {
        case 1:;
        {
            y = pc_decls_sptr++;
            (*pc_decls_sptr).value=((*pc_decls_sptr).value<(*y).value?(*pc_decls_sptr).value:(*y).value);
;
            return (void *)((pc_decls_pcptr + (int64_t)1));
        }break;
        case 3:;
        {
            y = pc_decls_sptr++;
            (*pc_decls_sptr).xvalue=((*pc_decls_sptr).xvalue<(*y).xvalue?(*pc_decls_sptr).xvalue:(*y).xvalue);
;
            return (void *)((pc_decls_pcptr + (int64_t)1));
        }break;
        default: {
            return (void *)(((*pc_decls_min_table[(yt)]))());
        }
        } //SW
;
    };
    pc_decls_opc_tableptr = &pc_decls_min_table;
    return (void *)(((*pc_decls_min_dtable[((int64_t)(pc_decls_sigmap[((int64_t)((*(pc_decls_sptr + (int64_t)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_max(void) {
    struct pc_decls_varrec *  y;
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == yt)) {
        switch (yt) {
        case 1:;
        {
            y = pc_decls_sptr++;
            (*pc_decls_sptr).value=((*pc_decls_sptr).value>(*y).value?(*pc_decls_sptr).value:(*y).value);
;
            return (void *)((pc_decls_pcptr + (int64_t)1));
        }break;
        case 3:;
        {
            y = pc_decls_sptr++;
            (*pc_decls_sptr).xvalue=((*pc_decls_sptr).xvalue>(*y).xvalue?(*pc_decls_sptr).xvalue:(*y).xvalue);
;
            return (void *)((pc_decls_pcptr + (int64_t)1));
        }break;
        default: {
            return (void *)(((*pc_decls_max_table[(yt)]))());
        }
        } //SW
;
    };
    pc_decls_opc_tableptr = &pc_decls_max_table;
    return (void *)(((*pc_decls_max_dtable[((int64_t)(pc_decls_sigmap[((int64_t)((*(pc_decls_sptr + (int64_t)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_concat(void) {
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == yt)) {
        return (void *)(((*pc_decls_concat_table[(yt)]))());
    };
    pc_support_pcmxtypes((uint8_t*)"CONCAT",pc_decls_sptr,pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_append(void) {
    return (void *)(((*pc_decls_append_table[((int64_t)((*(pc_decls_sptr + (int64_t)1)).tag))]))());
}

void * pc_khandlers_k_power(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64_t xt;
    int64_t yt;
    struct pc_decls_varrec result;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    xt = (int64_t)((*x).tag);
    yt = (int64_t)((*y).tag);
    if ((xt != yt)) {
        if (((xt = pc_dxfns_dx_mixed(x,y)) == (int64_t)0)) {
            pc_support_pcmxtypes((uint8_t*)"**MIXED",x,y);
        };
    };
    switch (xt) {
    case 1:;
    {
        (*pc_decls_sptr).value = pc_support_ipower((*x).value,(*y).value);
    }break;
    case 3:;
    {
        (*pc_decls_sptr).xvalue = pow((*x).xvalue,(*y).xvalue);
    }break;
    case 7:;
    {
        pc_bignum_bx_power(x,pc_bignum_bx_int(y),&result);
        pc_pcfns_pc_unshare(x);
        if (!!((uint64_t)((*y).hasref))) {
            pc_pcfns_pc_unshare(y);
        };
        (*pc_decls_sptr) = result;
    }break;
    default: {
        pc_support_pcustype((uint8_t*)"**",x);
    }
    } //SW
;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_atan2(void) {
    pc_support_pclunimpl((int64_t)179);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_addto(void) {
    struct pc_decls_varrec *  x;
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == (int64_t)22)) {
        x = (*(pc_decls_sptr + (int64_t)1)).varptr;
        if (((int64_t)((uint64_t)((*x).tag)) == yt)) {
            return (void *)(((*pc_decls_addto_table[(yt)]))());
        };
        pc_decls_opc_tableptr = &pc_decls_addto_table;
        return (void *)(((*pc_decls_addto_dtable[((int64_t)(pc_decls_sigmap[((int64_t)((*x).tag))][(yt)]))]))());
    } else {
        pc_support_pcerror((uint8_t*)"addto not ptr");
    };
    pc_support_pcmxtypes((uint8_t*)"addto",x,pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_subto(void) {
    struct pc_decls_varrec *  x;
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == (int64_t)22)) {
        x = (*(pc_decls_sptr + (int64_t)1)).varptr;
        if (((int64_t)((uint64_t)((*x).tag)) == yt)) {
            return (void *)(((*pc_decls_subto_table[(yt)]))());
        };
        pc_decls_opc_tableptr = &pc_decls_subto_table;
        return (void *)(((*pc_decls_subto_dtable[((int64_t)(pc_decls_sigmap[((int64_t)((*x).tag))][(yt)]))]))());
    } else {
        pc_support_pcerror((uint8_t*)"subto not ptr");
    };
    pc_support_pcmxtypes((uint8_t*)"subto",x,pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_multo(void) {
    struct pc_decls_varrec *  x;
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == (int64_t)22)) {
        x = (*(pc_decls_sptr + (int64_t)1)).varptr;
        if (((int64_t)((uint64_t)((*x).tag)) == yt)) {
            return (void *)(((*pc_decls_multo_table[(yt)]))());
        };
    } else {
        pc_support_pcerror((uint8_t*)"multo not ptr");
    };
    pc_support_pcmxtypes((uint8_t*)"multo",x,pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_divto(void) {
    struct pc_decls_varrec *  x;
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == (int64_t)22)) {
        x = (*(pc_decls_sptr + (int64_t)1)).varptr;
        if (((int64_t)((uint64_t)((*x).tag)) == yt)) {
            return (void *)(((*pc_decls_divto_table[(yt)]))());
        };
    } else {
        pc_support_pcerror((uint8_t*)"divto not ptr");
    };
    pc_support_pcmxtypes((uint8_t*)"divto",x,pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_idivto(void) {
    struct pc_decls_varrec *  x;
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == (int64_t)22)) {
        x = (*(pc_decls_sptr + (int64_t)1)).varptr;
        if (((int64_t)((uint64_t)((*x).tag)) == yt)) {
            return (void *)(((*pc_decls_idivto_table[(yt)]))());
        };
    } else {
        pc_support_pcerror((uint8_t*)"idivto not ptr");
    };
    pc_support_pcmxtypes((uint8_t*)"idivto",x,pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_iandto(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec ptr;
    int64_t yt;
    int64_t *  pc;
    yt = (int64_t)((*pc_decls_sptr).tag);
    p = (pc_decls_sptr + (int64_t)1);
    if (((int64_t)((uint64_t)((*p).tag)) == (int64_t)22)) {
        x = (*p).varptr;
        if (((int64_t)((uint64_t)((*x).tag)) == yt)) {
            return (void *)(((*pc_decls_iandto_table[(yt)]))());
        };
        pc_support_pcmxtypes((uint8_t*)"iandto",x,pc_decls_sptr);
    } else {
        ptr = (*p);
        pc_pcfns_pc_loadptr(p,p);
        pc = (int64_t *)(pc_khandlers_k_iand());
        pc_pcfns_pc_storeptr(&ptr,pc_decls_sptr++);
        return (void *)(pc);
    };
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_iorto(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec ptr;
    int64_t yt;
    int64_t *  pc;
    yt = (int64_t)((*pc_decls_sptr).tag);
    p = (pc_decls_sptr + (int64_t)1);
    if (((int64_t)((uint64_t)((*p).tag)) == (int64_t)22)) {
        x = (*p).varptr;
        if (((int64_t)((uint64_t)((*x).tag)) == yt)) {
            return (void *)(((*pc_decls_iorto_table[(yt)]))());
        };
        pc_support_pcmxtypes((uint8_t*)"iorto",x,pc_decls_sptr);
    } else {
        ptr = (*p);
        pc_pcfns_pc_loadptr(p,p);
        pc = (int64_t *)(pc_khandlers_k_ior());
        pc_pcfns_pc_storeptr(&ptr,pc_decls_sptr++);
        return (void *)(pc);
    };
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_ixorto(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec ptr;
    int64_t yt;
    int64_t *  pc;
    yt = (int64_t)((*pc_decls_sptr).tag);
    p = (pc_decls_sptr + (int64_t)1);
    if (((int64_t)((uint64_t)((*p).tag)) == (int64_t)22)) {
        x = (*p).varptr;
        if (((int64_t)((uint64_t)((*x).tag)) == yt)) {
            return (void *)(((*pc_decls_ixorto_table[(yt)]))());
        };
        pc_support_pcmxtypes((uint8_t*)"ixorto",x,pc_decls_sptr);
    } else {
        ptr = (*p);
        pc_pcfns_pc_loadptr(p,p);
        pc = (int64_t *)(pc_khandlers_k_ixor());
        pc_pcfns_pc_storeptr(&ptr,pc_decls_sptr++);
        return (void *)(pc);
    };
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_shlto(void) {
    struct pc_decls_varrec *  x;
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == (int64_t)22)) {
        x = (*(pc_decls_sptr + (int64_t)1)).varptr;
        if (((int64_t)((uint64_t)((*x).tag)) == yt)) {
            return (void *)(((*pc_decls_shlto_table[(yt)]))());
        };
    } else {
        pc_support_pcerror((uint8_t*)"Shlto not ptr");
    };
    pc_support_pcmxtypes((uint8_t*)"Shlto",x,pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_shrto(void) {
    struct pc_decls_varrec *  x;
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == (int64_t)22)) {
        x = (*(pc_decls_sptr + (int64_t)1)).varptr;
        if (((int64_t)((uint64_t)((*x).tag)) == yt)) {
            return (void *)(((*pc_decls_shrto_table[(yt)]))());
        };
    } else {
        pc_support_pcerror((uint8_t*)"Shrto not ptr");
    };
    pc_support_pcmxtypes((uint8_t*)"Shrto",x,pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_minto(void) {
    struct pc_decls_varrec *  x;
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == (int64_t)22)) {
        x = (*(pc_decls_sptr + (int64_t)1)).varptr;
        if (((int64_t)((uint64_t)((*x).tag)) == yt)) {
            return (void *)(((*pc_decls_minto_table[(yt)]))());
        };
    } else {
        pc_support_pcerror((uint8_t*)"minto not ptr");
    };
    pc_support_pcmxtypes((uint8_t*)"minto",x,pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_maxto(void) {
    struct pc_decls_varrec *  x;
    int64_t yt;
    yt = (int64_t)((*pc_decls_sptr).tag);
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == (int64_t)22)) {
        x = (*(pc_decls_sptr + (int64_t)1)).varptr;
        if (((int64_t)((uint64_t)((*x).tag)) == yt)) {
            return (void *)(((*pc_decls_maxto_table[(yt)]))());
        };
    } else {
        pc_support_pcerror((uint8_t*)"maxto not ptr");
    };
    pc_support_pcmxtypes((uint8_t*)"maxto",x,pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_concatto(void) {
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == (int64_t)22)) {
        return (void *)(((*pc_decls_concatto_table[((int64_t)((*(*(pc_decls_sptr + (int64_t)1)).varptr).tag))]))());
    };
    pc_support_pcerror((uint8_t*)"Concatto not ptr");
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_appendto(void) {
    if (((int64_t)((uint64_t)((*(pc_decls_sptr + (int64_t)1)).tag)) == (int64_t)22)) {
        return (void *)(((*pc_decls_appendto_table[((int64_t)((*(*(pc_decls_sptr + (int64_t)1)).varptr).tag))]))());
    };
    pc_support_pcerror((uint8_t*)"Appendto not ptr");
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_pushix(void) {
    return (void *)(((*pc_decls_pushix_dtable[((int64_t)(pc_decls_sigmap[((int64_t)((*(pc_decls_sptr + (int64_t)1)).tag))][((int64_t)((*pc_decls_sptr).tag))]))]))());
}

void * pc_khandlers_k_pushdotix(void) {
    return (void *)(((*pc_decls_pushdotix_dtable[((int64_t)(pc_decls_sigmap[((int64_t)((*(pc_decls_sptr + (int64_t)1)).tag))][((int64_t)((*pc_decls_sptr).tag))]))]))());
}

void * pc_khandlers_k_pushkeyix(void) {
    struct pc_decls_varrec *  d;
    struct pc_decls_varrec *  k;
    struct pc_decls_varrec *  p;
    d = pc_decls_sptr++;
    k = pc_decls_sptr;
    if (((int64_t)((uint64_t)((*d).tag)) != (int64_t)10)) {
        pc_support_pcustype((uint8_t*)"keyix",d);
    };
    p = pc_pcfns_finddictitem(d,k,(int64_t)0);
    pc_pcfns_pc_unshare(d);
    if (!!((uint64_t)((*k).hasref))) {
        pc_pcfns_pc_unshare(k);
    };
    if (!!(p)) {
        (*pc_decls_sptr) = (*p);
        return (void *)((pc_decls_pcptr + (int64_t)1));
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)0);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_pushkeyixd(void) {
    struct pc_decls_varrec *  d;
    struct pc_decls_varrec *  k;
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec *  def;
    def = pc_decls_sptr++;
    d = pc_decls_sptr++;
    k = pc_decls_sptr;
    if (((int64_t)((uint64_t)((*d).tag)) != (int64_t)10)) {
        pc_support_pcustype((uint8_t*)"keyix",d);
    };
    p = pc_pcfns_finddictitem(d,k,(int64_t)0);
    pc_pcfns_pc_unshare(d);
    if (!!((uint64_t)((*k).hasref))) {
        pc_pcfns_pc_unshare(k);
    };
    if (!!(p)) {
        (*pc_decls_sptr) = (*p);
        if (!!((uint64_t)((*def).hasref))) {
            pc_pcfns_pc_unshare(def);
        };
        return (void *)((pc_decls_pcptr + (int64_t)1));
    };
    (*pc_decls_sptr) = (*def);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_pushixref(void) {
    struct pc_decls_varrec *  p;
    p = (pc_decls_sptr + (int64_t)1);
    if (((int64_t)((uint64_t)((*p).tag)) == (int64_t)22)) {
        return (void *)(((*pc_decls_pushixref_dtable[((int64_t)(pc_decls_sigmap[((int64_t)((*(*p).varptr).tag))][((int64_t)((*pc_decls_sptr).tag))]))]))());
    };
    return (void *)(pc_support_pcerror((uint8_t*)"pushixref/not ptr"));
}

void * pc_khandlers_k_pushdotixref(void) {
    struct pc_decls_varrec *  p;
    p = (pc_decls_sptr + (int64_t)1);
    if (((int64_t)((uint64_t)((*p).tag)) == (int64_t)22)) {
        return (void *)(((*pc_decls_pushdotixref_dtable[((int64_t)(pc_decls_sigmap[((int64_t)((*(*p).varptr).tag))][((int64_t)((*pc_decls_sptr).tag))]))]))());
    };
    pc_support_pcerror((uint8_t*)"pushdotixref/not ptr");
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_pushkeyixref(void) {
    struct pc_decls_varrec *  d;
    struct pc_decls_varrec *  k;
    struct pc_decls_varrec *  p;
    d = (*pc_decls_sptr).varptr;
    k = ++pc_decls_sptr;
    if (((int64_t)((uint64_t)((*d).tag)) != (int64_t)10)) {
        pc_support_pcustype((uint8_t*)"keyixref",d);
    };
    p = pc_pcfns_finddictitem(d,k,(int64_t)1);
    if (!!((uint64_t)((*k).hasref))) {
        pc_pcfns_pc_unshare(k);
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)22);
    (*pc_decls_sptr).varptr = p;
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_pushbyteix(void) {
    int64_t a;
    uint64_t index;
    if (((int64_t)((uint64_t)((*pc_decls_sptr).tag)) != (int64_t)1)) {
        pc_support_pcerror((uint8_t*)"byteix/bad index");
    };
    index = (uint64_t)((*pc_decls_sptr).value);
    ++pc_decls_sptr;
    if (((int64_t)((uint64_t)((*pc_decls_sptr).tag)) != (int64_t)1)) {
        pc_support_pcerror((uint8_t*)"byteix/not int");
    };
    a = (*pc_decls_sptr).value;
    if (((*(pc_decls_pcptr + (int64_t)1))==(int64_t)44)) {
        if (((int64_t)(index) >= (int64_t)8)) {
            if (((int64_t)(index) >= (int64_t)12)) {
                pc_support_pcerror((uint8_t*)"byteix bounds");
            };
            a = (int64_t)((*pc_decls_sptr).uret.frameptr_low);
            (*pc_decls_sptr).value = ((a >> (((int64_t)(index) - (int64_t)8) * (int64_t)8)) & (int64_t)255);
        } else {
            (*pc_decls_sptr).value = ((a >> ((int64_t)(index) * (int64_t)8)) & (int64_t)255);
        };
    } else {
        pc_support_pcerror((uint8_t*)"byteix/bad type");
    };
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_pushbyteixref(void) {
    uint64_t index;
    struct pc_decls_varrec *  p;
    if (((int64_t)((uint64_t)((*pc_decls_sptr).tag)) != (int64_t)1)) {
        pc_support_pcerror((uint8_t*)"&byteix/bad index");
    };
    index = (uint64_t)((*pc_decls_sptr).value);
    ++pc_decls_sptr;
    if (((int64_t)((uint64_t)((*pc_decls_sptr).tag)) != (int64_t)22)) {
        pc_support_pcerror((uint8_t*)"&byteix/not ptr");
    };
    p = (*pc_decls_sptr).varptr;
    if (((int64_t)((uint64_t)((*p).tag)) != (int64_t)1)) {
        pc_support_pcerror((uint8_t*)"&bytix/not int");
    };
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)23);
    if (((*(pc_decls_pcptr + (int64_t)1))==(int64_t)44)) {
        if (((int64_t)(index) >= (int64_t)8)) {
            if (((int64_t)(index) >= (int64_t)12)) {
                pc_support_pcerror((uint8_t*)"&byteix bounds");
            };
            (*pc_decls_sptr).uref.ptr = (((byte *)(p) + (int64_t)(index)) - (int64_t)4);
        } else {
            (*pc_decls_sptr).uref.ptr = (((byte *)(p) + (int64_t)8) + (int64_t)(index));
        };
        (*pc_decls_sptr).uref.elemtag = (uint64_t)((int64_t)44);
    } else {
        pc_support_pcerror((uint8_t*)"&byteix/bad type");
    };
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_appendset(void) {
    pc_support_pclunimpl((int64_t)203);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_pushdotm(void) {
    pc_support_pclunimpl((int64_t)204);
    return (void *)((pc_decls_pcptr + (int64_t)3));
}

void * pc_khandlers_k_pushdott(void) {
    pc_support_pclunimpl((int64_t)205);
    return (void *)((pc_decls_pcptr + (int64_t)3));
}

void * pc_khandlers_k_push_ad(void) {
    (*--pc_decls_sptr).tagx = (uint64_t)((int64_t)19);
    (*pc_decls_sptr).refptr = (byte *)((void *)(pc_decls_dllproctable[((*(pc_decls_pcptr + (int64_t)1)))-1].address));
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_push_try(void) {
    (*--pc_decls_sptr).tagx = (uint64_t)((int64_t)17);
    (*pc_decls_sptr).refptr = (byte *)((*(pc_decls_pcptr + (int64_t)1)));
    (*pc_decls_sptr).uexcept.frameoffset = (pc_decls_frameptr - (byte *)(pc_decls_sptr));
    (*pc_decls_sptr).uexcept.exceptiontype = (uint64_t)((*(pc_decls_pcptr + (int64_t)2)));
    (*pc_decls_sptr).uexcept.nexceptions = (*(pc_decls_pcptr + (int64_t)3));
    return (void *)((pc_decls_pcptr + (int64_t)4));
}

void * pc_khandlers_k_raise(void) {
    if (((int64_t)((uint64_t)((*pc_decls_sptr).tag)) != (int64_t)1)) {
        pc_support_pcerror((uint8_t*)"Raise: not Int on stack [not proceeding direct to RAISE]");
    };
    return (void *)(pc_misc_raiseexception((*pc_decls_sptr).value));
}

void * pc_khandlers_k_applyop(void) {
    static int64_t codeseq[10];
    codeseq[((int64_t)1)-1] = (int64_t)(pq_common_cmdmap[((*pc_decls_sptr).value)]);
    if (((int64_t)((uint64_t)((*pc_decls_sptr).tag)) != (int64_t)14)) {
        pc_support_pcerror((uint8_t*)"Apply:no op");
    };
    if (((int64_t)((uint64_t)((*pc_decls_sptr).uop.opdims)) != (*(pc_decls_pcptr + (int64_t)1)))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_i64((*(pc_decls_pcptr + (int64_t)1)),NULL);
        msysnewc_m_print_u64((*pc_decls_sptr).uop.opdims,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        pc_support_pcerror((uint8_t*)"Apply:wrong #opnds");
    };
    ++pc_decls_sptr;
    codeseq[((int64_t)2)-1] = (*(pc_decls_pcptr + (int64_t)2));
    codeseq[((int64_t)3)-1] = (*(pc_decls_pcptr + (int64_t)3));
    return (void *)(&codeseq[((int64_t)1)-1]);
}

void * pc_khandlers_k_makeiter(void) {
    struct pc_decls_objrec *  p;
    p = (*pc_decls_sptr).objptr;
    (*pc_decls_sptr).uiter.itcount = (uint64_t)(((int64_t)((uint64_t)((*p).ulist.length)) + (int64_t)1));
    if (((int64_t)((*pc_decls_sptr).tag)==(int64_t)29)) {
        (*pc_decls_sptr).varptr = (*p).ulist.vptr;
        (*pc_decls_sptr).tagx = (uint64_t)((int64_t)22);
        (*pc_decls_sptr).uiter.ittype = (uint64_t)((int64_t)29);
    }else if (((int64_t)((*pc_decls_sptr).tag)==(int64_t)5)) {
        (*pc_decls_sptr).uref.ptr = (byte *)((*p).ustr.strptr);
        (*pc_decls_sptr).tagx = (uint64_t)((int64_t)23);
        (*pc_decls_sptr).uiter.ittype = (uint64_t)((int64_t)5);
    } else {
        pc_support_pcustype((uint8_t*)"makeiter",pc_decls_sptr);
    };
    return (void *)((pc_decls_pcptr + (int64_t)2));
}

void * pc_khandlers_k_forall(void) {
    struct pc_decls_varrec *  pit;
    struct pc_decls_varrec *  ploopvar;
    struct pc_decls_varrec *  pelem;
    pit = (struct pc_decls_varrec *)((pc_decls_frameptr + (*(pc_decls_pcptr + (int64_t)2))));
    ploopvar = (struct pc_decls_varrec *)((pc_decls_frameptr + (*(pc_decls_pcptr + (int64_t)3))));
    if (((int64_t)((uint64_t)(--(*pit).uiter.itcount)) <= (int64_t)0)) {
        return (void *)((pc_decls_pcptr + (int64_t)4));
    };
    if (!!((uint64_t)((*ploopvar).hasref))) {
        --(*(*ploopvar).objptr).refcount;
    };
    if (((int64_t)((*pit).uiter.ittype)==(int64_t)29)) {
        pelem = (*pit).varptr;
        (*ploopvar) = (*pelem);
        if (!!((uint64_t)((*ploopvar).hasref))) {
            ++(*(*ploopvar).objptr).refcount;
        };
        ++(*pit).varptr;
    }else if (((int64_t)((*pit).uiter.ittype)==(int64_t)5)) {
        pc_pcfns_pc_makechar((int64_t)((*(*pit).uref.ptr)),ploopvar);
        ++(*pit).uref.ptr;
    } else {
        pc_support_pcerror((uint8_t*)"forall/type?");
    };
    return (void *)((int64_t *)((*(pc_decls_pcptr + (int64_t)1))));
}

void * pc_khandlers_k_forallx(void) {
    pc_support_pclunimpl((int64_t)212);
    return (void *)((pc_decls_pcptr + (int64_t)5));
}

void * pc_khandlers_k_foreach(void) {
    pc_support_pclunimpl((int64_t)213);
    return (void *)((pc_decls_pcptr + (int64_t)4));
}

void * pc_khandlers_k_foreachx(void) {
    pc_support_pclunimpl((int64_t)214);
    return (void *)((pc_decls_pcptr + (int64_t)5));
}

void * pc_khandlers_k_expandrange(void) {
    struct pc_decls_varrec *  x;
    x = pc_decls_sptr--;
    (*pc_decls_sptr).tagx = (uint64_t)((int64_t)1);
    (*pc_decls_sptr).value = (int64_t)((*x).range_upper);
    (*x).value = (int64_t)((*x).range_lower);
    (*x).tagx = (uint64_t)((int64_t)1);
    return (void *)((pc_decls_pcptr + (int64_t)1));
}

void * pc_khandlers_k_callappl(void) {
    int64_t index;
    int64_t nargs;
    int64_t av_1;
    index = (*(pc_decls_pcptr + (int64_t)1));
    nargs = (*(pc_decls_pcptr + (int64_t)2));
    pc_host_do_callapplproc(index,nargs,(pc_decls_sptr + nargs));
    av_1 = nargs;
    while (av_1-- > 0) {
L785 :;
        if (!!((uint64_t)((*pc_decls_sptr).hasref))) {
            pc_pcfns_pc_unshare(pc_decls_sptr);
        };
        ++pc_decls_sptr;
L786 :;
    }L787 :;
    ;
    return (void *)((pc_decls_pcptr + (int64_t)3));
}

void pc_assemc_fixup_asm(int64_t mx) {
}

int64_t pc_assemc_asmavailable(void) {
    return (int64_t)0;
}

void pc_assemc_addcountint(void * cmd) {
}

void pc_assemc_addcountext(void) {
}

void pc_assemc_showasmcmd(void * cmd) {
}

int64_t * pc_assemc_disploop_asm(void) {
    return (int64_t *)(0);
}

uint64_t pc_assemc_getasmjump(int64_t cmd) {
    return (uint64_t)((int64_t)0);
}

int64_t qci_qcompiler_prod(uint8_t * locinfile,uint8_t * locoutfile,int64_t intlibs,int64_t fdocs) {
    uint8_t *  ext;
    uint8_t *  infile;
    uint8_t *  outfile;
    qci_initdata();
    var_decls_inputfiles[((int64_t)1)] = (infile = locinfile);
    var_decls_ninputfiles = (int64_t)1;
    outfile = locoutfile;
    ext = mlib_extractext(infile,(int64_t)0);
    mlib_convlcstring(ext);
    if (!(!!(mlib_eqstring(ext,(uint8_t*)"q")))) {
        qci_loaderror((uint8_t*)"Unknown file extension:",infile);
    };
    var_decls_dointlibs = intlibs;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"Compiling",NULL);
    msysnewc_m_print_str(infile,NULL);
    msysnewc_m_print_str((uint8_t*)"to",NULL);
    msysnewc_m_print_str(outfile,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    qci_do_loadmodules(infile);
    qci_do_parse();
    qci_do_writeqa(outfile);
    qci_do_name();
    qci_do_pclgen();
    qci_do_writepcfile();
    if (!!(fdocs)) {
        qci_writedocs();
    };
    return (int64_t)1;
}

void qci_do_loadmodules(uint8_t * infile) {
    if (!!(var_decls_fverbose)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"Loading:",NULL);
        msysnewc_m_print_str(infile,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    qci_loadmainmodule(infile);
}

static int64_t qci_loadmainmodule(uint8_t * filespec) {
    uint8_t modulename[100];
    uint8_t path[300];
    uint8_t *  source;
    int64_t i;
    int64_t flag;
    mlib_pcm_clearmem((void *)(&var_decls_moduletable[((int64_t)0)]),(int64_t)126);
    var_decls_moduletable[((int64_t)0)].name = (uint8_t*)"PROGRAM";
    var_decls_moduletable[((int64_t)0)].filename = (uint8_t*)"<->";
    var_decls_moduletable[((int64_t)0)].sourcecode = (uint8_t*)"<program>";
    var_decls_moduletable[((int64_t)0)].sourcelen = (int64_t)(strlen((int8_t *)(var_decls_moduletable[((int64_t)0)].sourcecode)));
    var_decls_stprogram = qc_lib_getduplnameptr((struct var_decls_strec *)(0),qc_lex_addnamestr((uint8_t*)"$prog"),(int64_t)1);
    var_decls_moduletable[((int64_t)0)].stmodule = var_decls_stprogram;
    source = (uint8_t *)(mlib_readfile(filespec));
    if ((source == 0)) {
        qci_loaderror((uint8_t*)"Can't load main file:",filespec);
        return (int64_t)0;
    };
    strcpy((int8_t *)(modulename),(int8_t *)(mlib_extractbasefile(filespec)));
    strcpy((int8_t *)(path),(int8_t *)(mlib_extractpath(filespec)));
    if (!!((uint64_t)(path[((int64_t)1)-1]))) {
        ++var_decls_nsearchdirs;
        L788 :;
        for (i=var_decls_nsearchdirs;i>=(int64_t)2;i-=(int64_t)1) {
L789 :;
            var_decls_searchdirs[(i)-1] = var_decls_searchdirs[((i - (int64_t)1))-1];
L790 :;
        }L791 :;
        ;
        var_decls_searchdirs[((int64_t)1)-1] = mlib_pcm_copyheapstring(path);
    };
    qci_addmodule(modulename,filespec,source,mlib_rfsize,(int64_t)2,&flag);
    return (int64_t)1;
}

static int64_t qci_addmodule(uint8_t * modulename,uint8_t * filespec,uint8_t * source,int64_t length,int64_t id,int64_t * exportflag) {
    struct var_decls_modulerec m;
    uint8_t *  importnames[50];
    byte importflags[51];
    int64_t importmoduleno[50];
    int64_t nimports;
    int64_t i;
    int64_t k;
    int64_t flag;
    int64_t j;
    int64_t newmodno;
    struct var_decls_modulerec *  pmodule;
    mlib_pcm_clearmem((void *)(&m),(int64_t)126);
    m.name = mlib_pcm_copyheapstring(modulename);
    m.filename = mlib_pcm_copyheapstring(filespec);
    m.sourcecode = source;
    m.sourcelen = length;
    if (!!(var_decls_fwriteqa)) {
        qc_support_addqafile(m.filename,m.sourcecode,(int64_t)(m.sourcelen));
    };
    var_decls_stmodule = qc_lib_getduplnameptr(var_decls_stprogram,qc_lex_addnamestr(m.name),id);
    qc_lib_adddef(var_decls_stprogram,var_decls_stmodule);
    m.stmodule = var_decls_stmodule;
    if ((var_decls_nmodules >= (int64_t)50)) {
        qci_loaderror((uint8_t*)"Too many modules",modulename);
    };
    pmodule = &var_decls_moduletable[((newmodno = ++var_decls_nmodules))];
    (*pmodule) = m;
    (*pmodule).importmap[(newmodno)-1] = (uint64_t)((int64_t)1);
    (*m.stmodule).attribs.ax_moduleno = (uint64_t)(newmodno);
    memset((void *)(&importflags),(int64_t)0,(uint64_t)((int64_t)51));
    nimports = qci_readimportlist(&m,&importnames,&importflags,(int64_t)50);
    L792 :;
    for (i=(int64_t)1;i<=nimports;i+=(int64_t)1) {
L793 :;
        flag = (int64_t)0;
        if ((var_decls_fverbose == (int64_t)2)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"Load import for",NULL);
            msysnewc_m_print_str(modulename,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
        k = qci_loadimport(importnames[(i)-1],&flag,modulename);
        if (!!(flag)) {
            importflags[(i)] = (uint64_t)((int64_t)1);
        };
        (*pmodule).importmap[(k)-1] = (uint64_t)((int64_t)1);
        importmoduleno[(i)-1] = k;
L794 :;
    }L795 :;
    ;
    L796 :;
    for (i=(int64_t)1;i<=nimports;i+=(int64_t)1) {
L797 :;
        if (!!((uint64_t)(importflags[(i)]))) {
            k = importmoduleno[(i)-1];
            L800 :;
            for (j=(int64_t)1;j<=var_decls_nmodules;j+=(int64_t)1) {
L801 :;
                if (!!((uint64_t)(var_decls_moduletable[(k)].importmap[(j)-1]))) {
                    (*pmodule).importmap[(j)-1] = (uint64_t)((int64_t)1);
                };
L802 :;
            }L803 :;
            ;
        };
L798 :;
    }L799 :;
    ;
    (*exportflag) = (int64_t)(importflags[((int64_t)0)]);
    var_decls_moduleinitorder[(++var_decls_ninitmodules)-1] = newmodno;
    return newmodno;
}

static int64_t qci_loadimport(uint8_t * modulename,int64_t * exportflag,uint8_t * ownername) {
    int64_t i;
    uint8_t filespec[300];
    uint8_t *  source;
    uint8_t *  newname;
    newname = modulename;
    L804 :;
    for (i=(int64_t)1;i<=var_decls_nmodules;i+=(int64_t)1) {
L805 :;
        if (!!(mlib_eqstring(var_decls_moduletable[(i)].name,newname))) {
            return i;
        };
L806 :;
    }L807 :;
    ;
    source = qci_getmodulestr(modulename,filespec);
    return qci_addmodule(newname,filespec,source,mlib_rfsize,(int64_t)2,exportflag);
}

static int64_t qci_readimportlist(struct var_decls_modulerec * m,uint8_t * (*importnames)[],byte (*importflags)[],int64_t maximports) {
    int64_t n;
    int64_t flag;
    int64_t exportflag;
    uint8_t name[100];
    qc_lex_startlex((uint8_t*)"IMPORTS",(*m).sourcecode);
    exportflag = (int64_t)0;
    n = (int64_t)0;
    L808 :;
    while (1) {
        qc_lex_lexreadtoken();
        if (((int64_t)(qc_lex_nextlx.symbol)==(int64_t)33)) {
            goto L809 ;
        }else if (((int64_t)(qc_lex_nextlx.symbol)==(int64_t)6) || ((int64_t)(qc_lex_nextlx.symbol)==(int64_t)32)) {
        }else if (((int64_t)(qc_lex_nextlx.symbol)==(int64_t)34)) {
            flag = (int64_t)0;
            if (!!(qci_checkname((uint8_t*)"import",(int64_t)0))) {
                qc_lex_lexreadtoken();
                if ((((int64_t)(qc_lex_nextlx.symbol) == (int64_t)31) && ((int64_t)(qc_lex_nextlx.subcode) == (int64_t)107))) {
                    flag = (int64_t)1;
                    qc_lex_lexreadtoken();
                };
                if (((int64_t)(qc_lex_nextlx.symbol) != (int64_t)34)) {
                    mlib_abortprogram((uint8_t*)"import: modulename expected");
                };
                if ((++n > maximports)) {
                    mlib_abortprogram((uint8_t*)"too many imports");
                };
                strcpy((int8_t *)(name),(int8_t *)(qc_lex_convertzstring(qc_lex_nextlx.svalue,(int64_t)(qc_lex_nextlx.length))));
                (*importnames)[(n)-1] = mlib_pcm_copyheapstring(name);
                (*importflags)[(n)] = (uint64_t)(flag);
            } else if (!!(qci_checkname((uint8_t*)"importpath",(int64_t)0))) {
                var_decls_prescanmode = (int64_t)1;
                qc_lex_lexreadtoken();
                var_decls_prescanmode = (int64_t)0;
                if (((int64_t)(qc_lex_nextlx.symbol) == (int64_t)42)) {
                    strcpy((int8_t *)(name),(int8_t *)(qc_lex_convertzstring(qc_lex_nextlx.svalue,(int64_t)(qc_lex_nextlx.length))));
                    qci_addsearchdir(name);
                    qc_lex_lexreadtoken();
                } else {
                    mlib_abortprogram((uint8_t*)"string path expected");
                };
            } else if ((!!(qci_checkname((uint8_t*)"export",(int64_t)0)) || !!(qci_checkname((uint8_t*)"endexport",(int64_t)0)))) {
                exportflag = (int64_t)1;
                goto L808 ;
            } else if (!!(qci_checkname((uint8_t*)"$windows",(int64_t)0))) {
                if (!!(osnos_os_iswindows())) {
                    goto L808 ;
                } else {
                    //skipthisline:
L810 :;
;
                    L811 :;
                    do {
                        qc_lex_lexreadtoken();
L812 :;
                    } while (!(((int64_t)(qc_lex_nextlx.symbol) == (int64_t)32) || ((int64_t)(qc_lex_nextlx.symbol) == (int64_t)33)));L813 :;
                    ;
                };
            } else if (!!(qci_checkname((uint8_t*)"$linux",(int64_t)0))) {
                if (!(!!(osnos_os_iswindows()))) {
                    goto L808 ;
                } else {
                    goto L810 ;
;
                };
            } else {
                goto L809 ;
            };
        } else {
            goto L809 ;
        };
    }L809 :;
    ;
    (*importflags)[((int64_t)0)] = (uint64_t)(exportflag);
    return n;
}

void qci_initdata(void) {
    mlib_pcm_init();
    qc_lex_lexsetup();
    qc_support_inittypetables();
    qci_initsearchdirs();
    qc_lib_initqclib();
    qc_pcllib_initpclgen();
    qc_pcllib_initpcldata();
}

void qci_initsearchdirs(void) {
    uint8_t str1[300];
    uint8_t str2[300];
    var_decls_searchdirs[(++var_decls_nsearchdirs)-1] = (uint8_t*)"";
    strcpy((int8_t *)(str1),(int8_t *)(osnos_os_gethostname()));
    if (!!((uint64_t)(str1[((int64_t)1)-1]))) {
        strcpy((int8_t *)(str2),(int8_t *)(mlib_extractpath(str1)));
        var_decls_searchdirs[(++var_decls_nsearchdirs)-1] = mlib_pcm_copyheapstring(str2);
    };
    strcpy((int8_t *)(str1),(int8_t *)(osnos_os_getmpath()));
    if (!!((uint64_t)(str1[((int64_t)1)-1]))) {
        var_decls_searchdirs[(++var_decls_nsearchdirs)-1] = mlib_pcm_copyheapstring(str1);
    };
    var_decls_searchdirs[(++var_decls_nsearchdirs)-1] = mlib_pcm_copyheapstring((uint8_t*)"c:/qx/");
}

static void qci_addsearchdir(uint8_t * path) {
    int64_t i;
    L814 :;
    for (i=(int64_t)1;i<=var_decls_nsearchdirs;i+=(int64_t)1) {
L815 :;
        if (!!(mlib_eqstring(var_decls_searchdirs[(i)-1],path))) {
            return;
        };
L816 :;
    }L817 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"ADD SEARCH",NULL);
    msysnewc_m_print_str(path,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    var_decls_searchdirs[(++var_decls_nsearchdirs)-1] = mlib_pcm_copyheapstring(path);
}

static uint8_t * qci_getmodulestr(uint8_t * modulename,uint8_t * filespec) {
    uint8_t *  ifile;
    byte *  source;
    if (!!(var_decls_dointlibs)) {
        source = (byte *)(q_libs_getintlib(modulename));
        if (!!(source)) {
            strcpy((int8_t *)(filespec),(int8_t *)((uint8_t*)"<Internal>"));
            return (uint8_t *)(source);
        };
    };
    ifile = qci_findmodule(modulename);
    if ((ifile == 0)) {
        if (!(!!(var_decls_dointlibs))) {
            source = (byte *)(q_libs_getintlib(modulename));
            if (!!(source)) {
                if ((var_decls_fverbose == (int64_t)2)) {
                };
                strcpy((int8_t *)(filespec),(int8_t *)((uint8_t*)"<Internal>"));
                return (uint8_t *)(source);
            };
        };
        qci_loaderror((uint8_t*)"Can't locate import module:",modulename);
    };
    strcpy((int8_t *)(filespec),(int8_t *)(ifile));
    source = mlib_readfile(filespec);
    if ((source == 0)) {
        qci_loaderror((uint8_t*)"?Read file error:",filespec);
    };
    return (uint8_t *)(source);
}

static uint8_t * qci_findmodule(uint8_t * modulename) {
    uint8_t file[300];
    static uint8_t filespec[300];
    int64_t i;
    strcpy((int8_t *)(file),(int8_t *)(modulename));
    strcpy((int8_t *)(file),(int8_t *)(mlib_addext(file,(uint8_t*)".q")));
    if ((var_decls_fverbose == (int64_t)2)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"Locating:",NULL);
        msysnewc_m_print_str(file,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    L818 :;
    for (i=(int64_t)1;i<=var_decls_nsearchdirs;i+=(int64_t)1) {
L819 :;
        strcpy((int8_t *)(filespec),(int8_t *)(var_decls_searchdirs[(i)-1]));
        strcat((int8_t *)(filespec),(int8_t *)(file));
        if ((var_decls_fverbose == (int64_t)2)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"\t",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_i64(i,NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((uint8_t*)": Checking File",NULL);
            msysnewc_m_print_str(filespec,NULL);
            msysnewc_m_print_str((uint8_t*)"in <",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str(var_decls_searchdirs[(i)-1],NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((uint8_t*)">",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
        if (!!(mlib_checkfile(filespec))) {
            if ((var_decls_fverbose == (int64_t)2)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((uint8_t*)"\tFound:",NULL);
                msysnewc_m_print_str(filespec,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            };
            return filespec;
        };
L820 :;
    }L821 :;
    ;
    return (uint8_t *)(0);
}

static int64_t qci_checkname(uint8_t * name,int64_t length) {
    if ((length == (int64_t)0)) {
        length = (int64_t)(strlen((int8_t *)(name)));
    };
    if ((((int64_t)(qc_lex_nextlx.length) == length) && ((int64_t)(memcmp((void *)(qc_lex_nextlx.svalue),(void *)(name),(uint64_t)(length))) == (int64_t)0))) {
        return (int64_t)1;
    };
    return (int64_t)0;
}

void qci_do_parse(void) {
    int64_t m;
    int64_t i;
    L822 :;
    for (i=(int64_t)1;i<=var_decls_nmodules;i+=(int64_t)1) {
L823 :;
        m = i;
        var_decls_currmoduleno = m;
        var_decls_currmodule = &var_decls_moduletable[(m)];
        qc_parse_parsemodule(m);
L824 :;
    }L825 :;
    ;
    qc_name_fixusertypes();
}

void qci_do_name(void) {
    int64_t i;
    qc_name_tx_typetable();
    L826 :;
    for (i=(int64_t)2;i<=var_decls_nmodules;i+=(int64_t)1) {
L827 :;
        qc_name_rx_module(i);
L828 :;
    }L829 :;
    ;
    qc_name_rx_module((int64_t)1);
}

void qci_do_pclgen(void) {
    int64_t i;
    L830 :;
    for (i=(int64_t)1;i<=var_decls_nmodules;i+=(int64_t)1) {
L831 :;
        qc_pclgen_codegen(i);
L832 :;
    }L833 :;
    ;
}

void qci_loaderror(uint8_t * mess,uint8_t * mess2) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"Load Error:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_str(mess2,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"Stopping",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit(0);
}

static void qci_getsyscmdline(void) {
    int64_t i;
    L834 :;
    for (i=(int64_t)1;i<=msysnewc_nsysparams;i+=(int64_t)1) {
L835 :;
        if ((i <= (int64_t)32)) {
            var_decls_cmdparamtable[((i - (int64_t)1))] = mlib_pcm_copyheapstring(msysnewc_sysparams[(i)-1]);
        };
L836 :;
    }L837 :;
    ;
    var_decls_ncmdparams = (msysnewc_nsysparams - (int64_t)1);
}

static void qci_checkkeyword(uint8_t * kwd) {
    int64_t length;
    qc_lex_lexreadtoken();
    length = (int64_t)(strlen((int8_t *)(kwd)));
    if (!(((((int64_t)(qc_lex_nextlx.symbol) == (int64_t)34) && ((int64_t)(qc_lex_nextlx.length) == length)) && ((int64_t)(memcmp((void *)(qc_lex_nextlx.svalue),(void *)(kwd),(uint64_t)(length))) == (int64_t)0)))) {
        qci_loaderror((uint8_t*)"BA: expected:",kwd);
    };
}

static int64_t qci_readinttoken(void) {
    qc_lex_lexreadtoken();
    if (((int64_t)(qc_lex_nextlx.symbol) != (int64_t)37)) {
        qci_loaderror((uint8_t*)"Int expected",(uint8_t*)"");
    };
    return qc_lex_nextlx.value;
}

void qci_do_writepcfile(void) {
    int64_t i;
    int64_t length;
    int64_t symbolpos;
    int64_t currpos;
    uint8_t filename[300];
    strcpy((int8_t *)(filename),(int8_t *)(var_decls_moduletable[((int64_t)1)].filename));
    strcpy((int8_t *)(filename),(int8_t *)(mlib_changeext(filename,(uint8_t*)".pc")));
    qc_support_initpcdest();
    qc_pclgen_doprogramstartup();
    qc_support_writezint((int64_t)80);
    qc_support_writezint((int64_t)67);
    qc_support_writezint((int64_t)26);
    qc_support_writezint((int64_t)0);
    qc_support_writezint((int64_t)1);
    qc_support_writezstring((uint8_t*)"404");
    qc_support_writezint((int64_t)2);
    qc_support_writezint(var_decls_nmodules);
    L838 :;
    for (i=(int64_t)1;i<=var_decls_nmodules;i+=(int64_t)1) {
L839 :;
        qc_support_writezstring(var_decls_moduletable[(i)].name);
L840 :;
    }L841 :;
    ;
    qc_support_writezint((int64_t)3);
    qc_support_writezint(var_decls_ndlltable);
    L842 :;
    for (i=(int64_t)1;i<=var_decls_ndlltable;i+=(int64_t)1) {
L843 :;
        qc_support_writezstring(var_decls_dlltable[(i)-1]);
L844 :;
    }L845 :;
    ;
    qc_support_writezint((int64_t)4);
    qc_support_writezint(var_decls_ndllproctable);
    L846 :;
    for (i=(int64_t)1;i<=var_decls_ndllproctable;i+=(int64_t)1) {
L847 :;
        qc_support_writezstring(var_decls_dllproctable[(i)-1].name);
        qc_support_writezint((int64_t)(var_decls_dllproctable[(i)-1].dllindex));
L848 :;
    }L849 :;
    ;
    qc_support_writezint((int64_t)14);
    qc_support_writezint(var_decls_napplproctable);
    L850 :;
    for (i=(int64_t)1;i<=var_decls_napplproctable;i+=(int64_t)1) {
L851 :;
        qc_support_writezstring((*var_decls_applproctable[(i)-1]).name);
L852 :;
    }L853 :;
    ;
    qc_support_writezint((int64_t)5);
    symbolpos = qc_support_getpcpos();
    qc_support_writezint4((int64_t)0);
    L854 :;
    for (i=(int64_t)1;i<=var_decls_nmodules;i+=(int64_t)1) {
L855 :;
        qci_showpcsymbol(var_decls_moduletable[(i)].stmodule);
L856 :;
    }L857 :;
    ;
    L858 :;
    for (i=(int64_t)53;i<=var_decls_ntypes;i+=(int64_t)1) {
L859 :;
        qci_showpcsymbol(var_decls_ttnamedef[(i)]);
L860 :;
    }L861 :;
    ;
    L862 :;
    for (i=(int64_t)0;i<=var_decls_nmodules;i+=(int64_t)1) {
L863 :;
        qci_writesymbols(i);
L864 :;
    }L865 :;
    ;
    currpos = qc_support_getpcpos();
    qc_support_setpcpos(symbolpos);
    qc_support_writezint4(var_decls_nsymbols);
    qc_support_setpcpos(currpos);
    qc_support_writezint((int64_t)6);
    qc_support_writezint(((var_decls_ntypes - (int64_t)53) + (int64_t)1));
    L866 :;
    for (i=(int64_t)53;i<=var_decls_ntypes;i+=(int64_t)1) {
L867 :;
        qc_support_writezint(i);
        qc_support_writezstring(var_decls_ttname[(i)]);
        qc_support_writezint((int64_t)((*var_decls_ttnamedef[(i)]).bcindex));
        qc_support_writezint((int64_t)(var_decls_ttbasetype[(i)]));
        qc_support_writezint((int64_t)(var_decls_tttarget[(i)]));
        qc_support_writezint((int64_t)(var_decls_ttlower[(i)]));
        qc_support_writezint((int64_t)(var_decls_ttlength[(i)]));
        qc_support_writezint((int64_t)(var_decls_ttsize[(i)]));
L868 :;
    }L869 :;
    ;
    qci_fixup_genfields();
    qc_support_writezint((int64_t)13);
    qc_support_writezint(var_decls_nstrings);
    L870 :;
    for (i=(int64_t)1;i<=var_decls_nstrings;i+=(int64_t)1) {
L871 :;
        qc_support_writezint((*var_decls_stringlentable)[(i)-1]);
        qc_support_writezblock((byte *)((*var_decls_stringtable)[(i)-1]),(*var_decls_stringlentable)[(i)-1]);
L872 :;
    }L873 :;
    ;
    qci_writestructfields();
    L874 :;
    for (i=(int64_t)0;i<=var_decls_nmodules;i+=(int64_t)1) {
L875 :;
        qci_writepccode2pc(i);
L876 :;
    }L877 :;
    ;
    qc_support_writezint((int64_t)7);
    qc_support_writezint(var_decls_ngenfieldnames);
    L878 :;
    for (i=(int64_t)1;i<=var_decls_ngenfieldnames;i+=(int64_t)1) {
L879 :;
        qc_support_writezstring((*var_decls_genfieldnames[(i)-1].def).name);
        qc_support_writezint((int64_t)(var_decls_genfieldnames[(i)-1].dataindex));
        qc_support_writezint((int64_t)(var_decls_genfieldnames[(i)-1].datalength));
L880 :;
    }L881 :;
    ;
    qc_support_writezint((int64_t)8);
    qc_support_writezint(var_decls_ngenfielddata);
    L882 :;
    for (i=(int64_t)1;i<=var_decls_ngenfielddata;i+=(int64_t)1) {
L883 :;
        qc_support_writezint((int64_t)(var_decls_genfielddata[(i)-1].fieldindex));
        qc_support_writezint((int64_t)(var_decls_genfielddata[(i)-1].recordtype));
        qc_support_writezint((int64_t)(var_decls_genfielddata[(i)-1].fieldtype));
        qc_support_writezint((int64_t)(var_decls_genfielddata[(i)-1].offset));
L884 :;
    }L885 :;
    ;
    qc_support_writezint((int64_t)12);
    qc_support_writezeof();
    length = qc_support_getpcpos();
    qc_support_writepcdata(filename);
    if (!!(var_decls_fverbose)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"Finished writing",NULL);
        msysnewc_m_print_str(filename,NULL);
        msysnewc_m_print_i64(length,NULL);
        msysnewc_m_print_str((uint8_t*)"bytes",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
}

static void qci_writesymbols(int64_t mx) {
    int64_t *  p;
    int64_t *  pccode;
    struct var_decls_strec *  d;
    int64_t cmd;
    int64_t i;
    int64_t av_1;
    pccode = (p = (int64_t *)(var_decls_moduletable[(mx)].pccode));
    L886 :;
    while (1) {
        cmd = (*p++);
        L888 :;
        for (i=(int64_t)1;i<=(int64_t)(qc_pcllib_cmdnopnds[(cmd)]);i+=(int64_t)1) {
L889 :;
            switch ((int64_t)(pq_common_cmdfmt[(cmd)][(i)-1])) {
            case 3:;
            {
                d = (struct var_decls_strec *)((*p));
                qci_showpcsymbol(d);
                (*p) = (int64_t)((*d).bcindex);
            }break;
            case 4:;
            {
                d = (struct var_decls_strec *)((*p));
                (*p) = (int64_t)((*d).index);
            }break;
            case 1:;
            {
                d = (struct var_decls_strec *)((*p));
                qci_showpcsymbol(d);
                (*p) = (int64_t)((*d).bcindex);
            }break;
            case 2:;
            {
                d = (struct var_decls_strec *)((*p));
                (*p) = ((int64_t)((*d).index) * (int64_t)16);
            }break;
            case 9:;
            {
                if (((cmd == (int64_t)63) && (i == (int64_t)2))) {
                    (*p) = ((*p) * (int64_t)16);
                } else if (((cmd == (int64_t)64) && (i == (int64_t)2))) {
                    (*p) = ((*p) * (int64_t)16);
                } else if (((cmd == (int64_t)72) && (i == (int64_t)1))) {
                    (*p) = ((*p) * (int64_t)16);
                };
            }break;
            default: {
            }
            } //SW
;
            ++p;
L890 :;
        }L891 :;
        ;
        if (((cmd == (int64_t)4) || (cmd == (int64_t)0))) {
            goto L887 ;
        };
    }L887 :;
    ;
}

static void qci_showpcsymbol(struct var_decls_strec * d) {
    int64_t a;
    int64_t b;
    uint8_t c;
    a = (b = (int64_t)0);
    if (((int64_t)((*d).bcindex) == (int64_t)0)) {
        (*d).bcindex = ++var_decls_nsymbols;
        if (((int64_t)((*d).nameid)==(int64_t)5)) {
            c = 'P';
            a = (int64_t)((*d).index);
        }else if (((int64_t)((*d).nameid)==(int64_t)10)) {
            c = 'S';
        }else if (((int64_t)((*d).nameid)==(int64_t)2)) {
            c = 'M';
            a = (int64_t)((*d).attribs.ax_moduleno);
        }else if (((int64_t)((*d).nameid)==(int64_t)4)) {
            c = 'T';
            a = (int64_t)((*d).mode);
        }else if (((int64_t)((*d).nameid)==(int64_t)1)) {
            return;
        } else {
            qci_loaderror((uint8_t*)"SHOWPCSYM?",(uint8_t*)"");
        };
        qc_support_writezint((int64_t)(c));
        qc_support_writezstring((*d).name);
        qc_support_writezint((int64_t)((*(*d).owner).bcindex));
        qc_support_writezint(a);
        qc_support_writezint(b);
        if (((uint64_t)(c) == 'P')) {
            if (!!((*d).metadata)) {
                qc_support_writezstring((*d).metadata);
            } else {
                qc_support_writezstring((uint8_t*)"");
            };
        };
    };
}

static void qci_writepccode2pc(int64_t mx) {
    int64_t *  p;
    int64_t *  pccode;
    uint16_t (*linetable)[];
    int64_t cmd;
    int64_t i;
    int64_t pcindex;
    int64_t startindex;
    int64_t av_1;
    qc_support_writezint((int64_t)11);
    qc_support_writezint(mx);
    qc_support_writezint((int64_t)(var_decls_moduletable[(mx)].pcindex));
    pccode = (p = (int64_t *)(var_decls_moduletable[(mx)].pccode));
    linetable = var_decls_moduletable[(mx)].linetable;
    pcindex = (int64_t)1;
    L892 :;
    while (1) {
        cmd = (*p++);
        qc_support_writezint((int64_t)((*linetable)[(pcindex)]));
        qc_support_writezint(cmd);
        startindex = pcindex++;
        L894 :;
        for (i=(int64_t)1;i<=(int64_t)(qc_pcllib_cmdnopnds[(cmd)]);i+=(int64_t)1) {
L895 :;
            switch ((int64_t)(pq_common_cmdfmt[(cmd)][(i)-1])) {
            case 8:;
            case 3:;
            case 4:;
            case 1:;
            case 2:;
            case 9:;
            case 10:;
            case 13:;
            case 14:;
            case 7:;
            case 15:;
            case 16:;
            {
                qc_support_writezint((*p));
            }break;
            case 11:;
            {
                qc_support_writezreal(*(double*)&(*p));
            }break;
            case 12:;
            {
                qc_support_writezrange((byte *)(p));
            }break;
            default: {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str(pq_common_opndnames[((int64_t)(pq_common_cmdfmt[(cmd)][(i)-1]))],NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                qci_loaderror((uint8_t*)"writepc2bc/opnd?",(uint8_t*)"");
            }
            } //SW
;
            ++pcindex;
            ++p;
L896 :;
        }L897 :;
        ;
        if (((cmd == (int64_t)4) || (cmd == (int64_t)0))) {
            goto L893 ;
        };
    }L893 :;
    ;
}

static void qci_writestructfields(void) {
    int64_t structpos;
    int64_t currpos;
    int64_t nstructfields;
    int64_t i;
    int64_t j;
    int64_t t;
    struct var_decls_strec *  d;
    struct var_decls_strec *  e;
    struct var_decls_strec *  fieldlist[100];
    byte ignore[100];
    int64_t nfields;
    qc_support_writezint((int64_t)10);
    structpos = qc_support_getpcpos();
    qc_support_writezint4((int64_t)0);
    nstructfields = (int64_t)0;
    L898 :;
    for (t=(int64_t)53;t<=var_decls_ntypes;t+=(int64_t)1) {
L899 :;
        if (((int64_t)(var_decls_ttbasetype[(t)]) == (int64_t)33)) {
            d = (*var_decls_ttnamedef[(t)]).deflist;
            nfields = (int64_t)0;
            L902 :;
            while (!!(d)) {
                if ((((int64_t)((uint64_t)((*d).nameid)) == (int64_t)13) && !(!!((uint64_t)((*d).attribs.ax_at))))) {
                    ++nfields;
                    if ((nfields > (int64_t)100)) {
                        qci_loaderror((uint8_t*)"wsf: too many fields in struct",(uint8_t*)"");
                    };
                    fieldlist[(nfields)-1] = d;
                    ignore[(nfields)-1] = (uint64_t)((int64_t)0);
                };
                d = (*d).nextdef;
L903 :;
            }L904 :;
            ;
            L905 :;
            for (i=(int64_t)1;i<=nfields;i+=(int64_t)1) {
L906 :;
                d = fieldlist[(i)-1];
                L909 :;
                for (j=(i + (int64_t)1);j<=nfields;j+=(int64_t)1) {
L910 :;
                    if ((i != j)) {
                        e = fieldlist[(j)-1];
                        if (((int64_t)((*d).offset) == (int64_t)((*e).offset))) {
                            ignore[(i)-1] = (uint64_t)((int64_t)1);
                        };
                    };
L911 :;
                }L912 :;
                ;
L907 :;
            }L908 :;
            ;
            L913 :;
            for (i=nfields;i>=(int64_t)1;i-=(int64_t)1) {
L914 :;
                if (!(!!((uint64_t)(ignore[(i)-1])))) {
                    d = fieldlist[(i)-1];
                    ++nstructfields;
                    qc_support_writezint(t);
                    qc_support_writezstring((*d).name);
                    qc_support_writezint((int64_t)((*d).mode));
                    qc_support_writezint((int64_t)((*d).offset));
                };
L915 :;
            }L916 :;
            ;
        };
L900 :;
    }L901 :;
    ;
    currpos = qc_support_getpcpos();
    qc_support_setpcpos(structpos);
    qc_support_writezint4(nstructfields);
    qc_support_setpcpos(currpos);
}

static void qci_fixup_genfields(void) {
    int64_t recordtype;
    int64_t fieldtype;
    int64_t i;
    int64_t offset;
    struct var_decls_strec *  d;
    struct var_decls_strec *  p;
    struct var_decls_strec *  q;
    var_decls_ngenfielddata = (int64_t)0;
    L917 :;
    for (i=(int64_t)1;i<=var_decls_ngenfieldnames;i+=(int64_t)1) {
L918 :;
        d = var_decls_genfieldnames[(i)-1].def;
        var_decls_genfieldnames[(i)-1].dataindex = (var_decls_ngenfielddata + (int64_t)1);
        p = (*d).nextdupl;
        L921 :;
        while (!!(p)) {
            offset = (int64_t)((*p).offset);
            if (((int64_t)((uint64_t)((*p).nameid)) == (int64_t)13)) {
                recordtype = (int64_t)((*(*p).owner).mode);
                fieldtype = (int64_t)((*p).mode);
            } else if (((int64_t)((uint64_t)((*p).nameid)) == (int64_t)5)) {
                recordtype = (int64_t)((*(*p).owner).mode);
                fieldtype = (int64_t)18;
            } else if ((((int64_t)((uint64_t)((*p).nameid)) == (int64_t)19) && ((int64_t)((uint64_t)((*(*p).owner).nameid)) != (int64_t)2))) {
                q = p;
                L924 :;
                do {
                    q = (*q).equiv;
L925 :;
                } while (!((int64_t)((uint64_t)((*q).nameid)) != (int64_t)19));L926 :;
                ;
                recordtype = (int64_t)((*(*p).owner).mode);
                fieldtype = (int64_t)18;
                offset = (int64_t)((*q).offset);
            } else {
                goto L927 ;
;
            };
            if ((var_decls_ngenfielddata >= (int64_t)1000)) {
                qci_loaderror((uint8_t*)"GENFIELDDATA OVERFLOW",(uint8_t*)"");
            };
            ++var_decls_ngenfielddata;
            var_decls_genfielddata[(var_decls_ngenfielddata)-1].fieldindex = i;
            var_decls_genfielddata[(var_decls_ngenfielddata)-1].recordtype = recordtype;
            var_decls_genfielddata[(var_decls_ngenfielddata)-1].fieldtype = fieldtype;
            var_decls_genfielddata[(var_decls_ngenfielddata)-1].offset = offset;
            //skip:
L927 :;
;
            p = (*p).nextdupl;
L922 :;
        }L923 :;
        ;
        var_decls_genfieldnames[(i)-1].datalength = ((var_decls_ngenfielddata - (int64_t)(var_decls_genfieldnames[(i)-1].dataindex)) + (int64_t)1);
L919 :;
    }L920 :;
    ;
}

static void qci_showhelp(void) {
    static uint8_t *  helptext = (uint8_t*)"THIS IS THE HELP TEXT";
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(helptext,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit(0);
}

int64_t qci_nextcmd(int64_t * paramno,uint8_t * * name,uint8_t * * value,uint8_t * defext) {
    static int64_t infile = (int64_t)0;
    static uint8_t *  filestart = 0;
    static uint8_t *  fileptr = 0;
    static byte colonnext = (uint8_t)0u;
    return (int64_t)0;
}

void qci_writedocs(void) {
    uint8_t filename[300];
    struct var_decls_strec *  params[50];
    int64_t nparams;
    void *  f;
    struct var_decls_strec *  def;
    struct var_decls_strec *  e;
    struct var_decls_procrec *  p;
    int64_t i;
    strcpy((int8_t *)(filename),(int8_t *)(var_decls_moduletable[(var_decls_nmodules)].filename));
    strcpy((int8_t *)(filename),(int8_t *)(mlib_changeext(filename,(uint8_t*)".txt")));
    f = fopen((int8_t *)(filename),(int8_t *)((uint8_t*)"w"));
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"Writing Docstring file",NULL);
    msysnewc_m_print_str(filename,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    p = var_decls_proclist;
    L928 :;
    while (!!(p)) {
        def = (*p).def;
        if ((!!((*def).docstring) && !(!!((uint64_t)((*def).attribs.ax_at))))) {
            e = (*def).deflist;
            nparams = (int64_t)0;
            L931 :;
            while (!!(e)) {
                if ((((int64_t)((uint64_t)((*e).nameid)) == (int64_t)12) && ((uint64_t)((*(*e).name)) != '$'))) {
                    params[(++nparams)-1] = e;
                };
                e = (*e).nextdef;
L932 :;
            }L933 :;
            ;
            msysnewc_m_print_startfile(f);
            msysnewc_m_print_str((uint8_t*)"================================================",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startfile(f);
            msysnewc_m_print_str((((int64_t)((*def).mode) == (int64_t)0)?(uint8_t*)"Proc ":(uint8_t*)"Function "),NULL);
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startfile(f);
            msysnewc_m_print_str((*(*def).owner).name,NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((uint8_t*)".",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((*def).name,NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((uint8_t*)"(",NULL);
            msysnewc_m_print_end();
            ;
            L934 :;
            for (i=nparams;i>=(int64_t)1;i-=(int64_t)1) {
L935 :;
                e = params[(i)-1];
                if (!!((uint64_t)((*e).attribs.ax_byrefmode))) {
                    msysnewc_m_print_startfile(f);
                    msysnewc_m_print_str((uint8_t*)"&",NULL);
                    msysnewc_m_print_end();
                    ;
                };
                msysnewc_m_print_startfile(f);
                msysnewc_m_print_str((*e).name,NULL);
                msysnewc_m_print_end();
                ;
                if (!!((*e).code)) {
                    msysnewc_m_print_startfile(f);
                    msysnewc_m_print_str((uint8_t*)" =",NULL);
                    msysnewc_m_print_str((*qc_lib_strexpr((*e).code)).strptr,NULL);
                    msysnewc_m_print_end();
                    ;
                };
                if ((i != (int64_t)1)) {
                    msysnewc_m_print_startfile(f);
                    msysnewc_m_print_str((uint8_t*)",",NULL);
                    msysnewc_m_print_end();
                    ;
                };
L936 :;
            }L937 :;
            ;
            msysnewc_m_print_startfile(f);
            msysnewc_m_print_str((uint8_t*)")",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startfile(f);
            msysnewc_m_print_str((uint8_t*)"================================================",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startfile(f);
            msysnewc_m_print_str((*def).docstring,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
        p = (*p).nextproc;
L929 :;
    }L930 :;
    ;
    fclose(f);
}

static void qci_do_writeqa(uint8_t * outfile) {
    uint8_t newoutfile[300];
    if (!!(var_decls_fwriteqa)) {
        if (!!(var_decls_fbundled)) {
            qci_loaderror((uint8_t*)"-qa used with .qa input",(uint8_t*)"");
        };
        strcpy((int8_t *)(newoutfile),(int8_t *)(mlib_changeext(outfile,(uint8_t*)"qa")));
        qc_support_writeqafile(newoutfile);
        exit(0);
    };
}

void qc_support_prterror(uint8_t * mess) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"Print error:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    osnos_os_getch();
    exit((int64_t)1);
}

void qc_support_serror_gen(uint8_t * mess) {
    if ((!!(var_decls_currproc) && ((int64_t)((uint64_t)((*var_decls_currproc).nameid)) == (int64_t)5))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"In function",NULL);
        msysnewc_m_print_str((*var_decls_currproc).name,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((uint8_t*)" ",NULL);
        msysnewc_m_print_end();
        ;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"On line",NULL);
    msysnewc_m_print_i64(qc_lex_lx.lineno,NULL);
    msysnewc_m_print_str((uint8_t*)"in file",NULL);
    msysnewc_m_print_str((*var_decls_currmodule).filename,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"**** Syntax Error:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_str((uint8_t*)"****",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit((int64_t)1);
}

void qc_support_serror(uint8_t * mess) {
    qc_support_serror_gen(mess);
}

void qc_support_serror_ss(uint8_t * mess,uint8_t * a,uint8_t * b) {
    uint8_t str[256];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt(mess);
    msysnewc_m_print_str(a,NULL);
    msysnewc_m_print_str(b,NULL);
    msysnewc_m_print_end();
    ;
    qc_support_serror_gen(str);
}

void qc_support_serror_s(uint8_t * mess,uint8_t * a) {
    uint8_t str[256];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt(mess);
    msysnewc_m_print_str(a,NULL);
    msysnewc_m_print_end();
    ;
    qc_support_serror_gen(str);
}

void qc_support_error_gen(int64_t pass,uint8_t * mess,struct var_decls_unitrec * p) {
    int64_t lineno;
    int64_t fileno;
    uint8_t *  poss;
    if (!!(p)) {
        lineno = (int64_t)((*p).lineno);
        fileno = (int64_t)((*p).moduleno);
        poss = (uint8_t*)"";
    } else {
        fileno = var_decls_currmoduleno;
        poss = (uint8_t*)"?";
        lineno = (var_decls_mlineno & (int64_t)16777215);
    };
    if ((!!(var_decls_currproc) && ((int64_t)((uint64_t)((*var_decls_currproc).nameid)) == (int64_t)5))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"In function",NULL);
        msysnewc_m_print_str((*var_decls_currproc).name,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((uint8_t*)" ",NULL);
        msysnewc_m_print_end();
        ;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"On line",NULL);
    msysnewc_m_print_i64((lineno & (int64_t)16777215),NULL);
    msysnewc_m_print_str((uint8_t*)"in file",NULL);
    msysnewc_m_print_str(var_decls_moduletable[(fileno)].filename,NULL);
    msysnewc_m_print_str(poss,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    if ((pass==(int64_t)82)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"**** RX Name Error: ",NULL);
        msysnewc_m_print_end();
        ;
    }else if ((pass==(int64_t)84)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"**** TX Type Error: ",NULL);
        msysnewc_m_print_end();
        ;
    }else if ((pass==(int64_t)71)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"**** GX Code Gen Error: ",NULL);
        msysnewc_m_print_end();
        ;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    osnos_os_getch();
    exit((int64_t)1);
}

void qc_support_rxerror(uint8_t * mess,struct var_decls_unitrec * p) {
    qc_support_error_gen((int64_t)82,mess,p);
}

void qc_support_gerror(uint8_t * mess,struct var_decls_unitrec * p) {
    qc_support_error_gen((int64_t)71,mess,p);
}

void qc_support_rxerror_s(uint8_t * mess,uint8_t * a,struct var_decls_unitrec * p) {
    uint8_t str[256];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt(mess);
    msysnewc_m_print_str(a,NULL);
    msysnewc_m_print_end();
    ;
    qc_support_error_gen((int64_t)78,str,p);
}

int64_t qc_support_testelem(byte (*p)[],int64_t n) {
    return (!!(((uint64_t)((*p)[((n >> (int64_t)3))]) & (uint64_t)(qc_support_bytemasks[((n & (int64_t)7))])))?(int64_t)1:(int64_t)0);
}

void qc_support_setelem(byte (*p)[],int64_t n) {
    (*p)[((n >> (int64_t)3))] |= qc_support_bytemasks[((n & (int64_t)7))];
}

void qc_support_inittypetables(void) {
    int64_t i;
    int64_t size;
    int64_t bitsize;
    int64_t av_1;
    L938 :;
    for (i=(int64_t)0;i<=(int64_t)52;i+=(int64_t)1) {
L939 :;
        var_decls_ttname[(i)] = var_types_stdtypenames[(i)];
        var_decls_ttbasetype[(i)] = i;
        if ((i==(int64_t)50) || (i==(int64_t)51) || (i==(int64_t)52)) {
            bitsize = (int64_t)64;
        } else {
            bitsize = var_types_stdtypewidths[(i)];
        };
        switch (bitsize) {
        case 0:;
        {
        }break;
        case 1:;
        case 2:;
        case 4:;
        {
            size = (int64_t)1;
        }break;
        default: {
            size = (bitsize / (int64_t)8);
        }
        } //SW
;
        var_decls_ttsize[(i)] = size;
        var_decls_ttbitwidth[(i)] = bitsize;
        var_decls_ttlower[(i)] = (int64_t)1;
L940 :;
    }L941 :;
    ;
    var_decls_ntypes = (int64_t)52;
    var_decls_tttarget[((int64_t)22)] = (int64_t)35;
}

int64_t qc_support_nextpoweroftwo(int64_t x) {
    int64_t a;
    if ((x == (int64_t)0)) {
        return (int64_t)0;
    };
    a = (int64_t)1;
    L942 :;
    while ((a < x)) {
        a <<= (int64_t)1;
L943 :;
    }L944 :;
    ;
    return a;
}

void qc_support_initpcdest(void) {
    qc_support_pcalloc = (int64_t)16384;
    qc_support_pcstart = (byte *)(mlib_pcm_alloc(qc_support_pcalloc));
    qc_support_pcend = (qc_support_pcstart + qc_support_pcalloc);
    qc_support_pcdest = qc_support_pcstart;
}

int64_t qc_support_getpcpos(void) {
    return (qc_support_pcdest - qc_support_pcstart);
}

void qc_support_setpcpos(int64_t pos) {
    qc_support_pcdest = (qc_support_pcstart + pos);
}

int64_t qc_support_writepcdata(uint8_t * filename) {
    void *  f;
    f = fopen((int8_t *)(filename),(int8_t *)((uint8_t*)"wb"));
    if ((f == 0)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"Couldn't create",NULL);
        msysnewc_m_print_str(filename,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit((int64_t)1);
    };
    fwrite((void *)(qc_support_pcstart),(uint64_t)((qc_support_pcdest - qc_support_pcstart)),(uint64_t)((int64_t)1),f);
    fclose(f);
    return (int64_t)1;
}

void qc_support_writezstring(uint8_t * s) {
    int64_t n;
    int64_t av_1;
    qc_support_outpcbyte((int64_t)254);
    n = (int64_t)(strlen((int8_t *)(s)));
    av_1 = n;
    while (av_1-- > 0) {
L945 :;
        qc_support_outpcbyte((int64_t)((*s++)));
L946 :;
    }L947 :;
    ;
    qc_support_outpcbyte((int64_t)0);
}

void qc_support_writezblock(byte * s,int64_t length) {
    int64_t av_1;
    av_1 = length;
    while (av_1-- > 0) {
L948 :;
        qc_support_outpcbyte((int64_t)((*s++)));
L949 :;
    }L950 :;
    ;
}

void qc_support_writezint(int64_t x) {
    byte *  p;
    int64_t av_1;
    if (((x >= (int64_t)0) && (x <= (int64_t)239))) {
        qc_support_outpcbyte(x);
    } else if (((x >= (int64_t)240) && (x < (int64_t)480))) {
        qc_support_outpcbyte((int64_t)245);
        qc_support_outpcbyte((x - (int64_t)240));
    } else if (((x >= (int64_t)480) && (x < (int64_t)720))) {
        qc_support_outpcbyte((int64_t)246);
        qc_support_outpcbyte((x - (int64_t)480));
    } else if (((x >= (int64_t)720) && (x < (int64_t)960))) {
        qc_support_outpcbyte((int64_t)247);
        qc_support_outpcbyte((x - (int64_t)720));
    } else if (((x >= (int64_t)-127) && (x < (int64_t)0))) {
        qc_support_outpcbyte((int64_t)248);
        qc_support_outpcbyte(-(x));
    } else if (((x >= (int64_t)-32768) && (x <= (int64_t)32767))) {
        qc_support_outpcbyte((int64_t)249);
        qc_support_outpcword16(x);
    } else if (((x > (int64_t)-2147483648) && (x <= (int64_t)2147483647))) {
        qc_support_outpcbyte((int64_t)250);
        qc_support_outpcword(x);
    } else {
        p = (byte *)(&x);
        qc_support_outpcbyte((int64_t)251);
        av_1 = (int64_t)8;
        while (av_1-- > 0) {
L951 :;
            qc_support_outpcbyte((int64_t)((*p++)));
L952 :;
        }L953 :;
        ;
    };
}

void qc_support_writezint4(int64_t x) {
    qc_support_outpcbyte((int64_t)250);
    qc_support_outpcword(x);
}

void qc_support_writezrange(byte * p) {
    int64_t av_1;
    qc_support_outpcbyte((int64_t)251);
    av_1 = (int64_t)8;
    while (av_1-- > 0) {
L954 :;
        qc_support_outpcbyte((int64_t)((*p++)));
L955 :;
    }L956 :;
    ;
}

void qc_support_writezreal(double x) {
    byte *  p;
    int32_t *  q;
    int64_t av_1;
    int64_t av_2;
    p = (byte *)(&x);
    q = (int32_t *)(&x);
    if ((q != 0)) {
        qc_support_outpcbyte((int64_t)253);
        av_1 = (int64_t)8;
        while (av_1-- > 0) {
L957 :;
            qc_support_outpcbyte((int64_t)((*p++)));
L958 :;
        }L959 :;
        ;
    } else {
        qc_support_outpcbyte((int64_t)252);
        p += (int64_t)4;
        av_2 = (int64_t)4;
        while (av_2-- > 0) {
L960 :;
            qc_support_outpcbyte((int64_t)((*p++)));
L961 :;
        }L962 :;
        ;
    };
}

void qc_support_writezeof(void) {
    qc_support_outpcbyte((int64_t)255);
}

int64_t qc_support_ipower(int64_t a,int64_t n) {
    if ((n <= (int64_t)0)) {
        return (int64_t)0;
    } else if ((n == (int64_t)0)) {
        return (int64_t)1;
    } else if ((n == (int64_t)1)) {
        return a;
    } else if (((n & (int64_t)1) == (int64_t)0)) {
        return qc_support_ipower((a * a),(n / (int64_t)2));
    } else {
        return (a * qc_support_ipower((a * a),((n - (int64_t)1) / (int64_t)2)));
    };
}

void qc_support_gs_additem(struct mlib_strbuffer * dest,uint8_t * s) {
    uint8_t *  d;
    int64_t lastchar;
    int64_t nextchar;
    d = (*dest).strptr;
    if (!!((int64_t)((*dest).length))) {
        lastchar = (int64_t)((*((d + (int64_t)((*dest).length)) - (int64_t)1)));
        nextchar = (int64_t)((*s));
        if ((!!(qc_support_isalphanum(lastchar)) && !!(qc_support_isalphanum(nextchar)))) {
            mlib_strbuffer_add(dest,(uint8_t*)" ",(int64_t)-1);
        };
    };
    mlib_strbuffer_add(dest,s,(int64_t)-1);
}

static int64_t qc_support_isalphanum(int64_t c) {
    if (((((c >= (int64_t)65) && (c <= (int64_t)90)) || ((c >= (int64_t)97) && (c <= (int64_t)122))) || ((c >= (int64_t)48) && (c <= (int64_t)57)))) {
        return (int64_t)1;
    };
    return (int64_t)0;
}

static void qc_support_outpcbyte(int64_t x) {
    int64_t newalloc;
    int64_t oldbytes;
    byte *  pcnew;
    if ((qc_support_pcdest >= qc_support_pcend)) {
        newalloc = (qc_support_pcalloc * (int64_t)2);
        pcnew = (byte *)(mlib_pcm_alloc(newalloc));
        oldbytes = (qc_support_pcdest - qc_support_pcstart);
        memcpy((void *)(pcnew),(void *)(qc_support_pcstart),(uint64_t)(oldbytes));
        qc_support_pcstart = pcnew;
        qc_support_pcend = (qc_support_pcstart + newalloc);
        qc_support_pcdest = (qc_support_pcstart + oldbytes);
        qc_support_pcalloc = newalloc;
    };
    (*qc_support_pcdest++) = (uint64_t)(x);
}

static void qc_support_outpcword(int64_t x) {
    byte *  p;
    p = (byte *)(&x);
    qc_support_outpcbyte((int64_t)((*p++)));
    qc_support_outpcbyte((int64_t)((*p++)));
    qc_support_outpcbyte((int64_t)((*p++)));
    qc_support_outpcbyte((int64_t)((*p)));
}

static void qc_support_outpcword16(int64_t x) {
    byte *  p;
    p = (byte *)(&x);
    qc_support_outpcbyte((int64_t)((*p++)));
    qc_support_outpcbyte((int64_t)((*p)));
}

void qc_support_writeqafile(uint8_t * destfile) {
    void *  f;
    int64_t fileoffsets[100];
    int64_t headeroffsets[100];
    int64_t offset;
    int64_t nn;
    int64_t i;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"Writing QA File",NULL);
    msysnewc_m_print_str(destfile,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    f = fopen((int8_t *)(destfile),(int8_t *)((uint8_t*)"wb"));
    if (!(!!(f))) {
        qci_loaderror((uint8_t*)"Can't create qa file #",destfile);
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"WRITEQAFILE",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((uint8_t*)"qafile",NULL);
    msysnewc_m_print_i64(var_decls_nqafiles,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L963 :;
    for (i=(int64_t)1;i<=var_decls_nqafiles;i+=(int64_t)1) {
L964 :;
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_i64(i,(uint8_t*)"3");
        msysnewc_m_print_str(var_decls_qafilenames[(i)],(uint8_t*)"16jl");
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_i64(var_decls_qafilesizes[(i)],(uint8_t*)"8");
        msysnewc_m_print_end();
        ;
        headeroffsets[(i)-1] = (mlib_getfilepos(f) + (int64_t)1);
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((uint8_t*)"         ",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
L965 :;
    }L966 :;
    ;
    L967 :;
    for (i=(int64_t)1;i<=var_decls_nqafiles;i+=(int64_t)1) {
L968 :;
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_setfmt((uint8_t*)"=== # #/# ===");
        msysnewc_m_print_str(var_decls_qafilenames[(i)],NULL);
        msysnewc_m_print_i64(i,NULL);
        msysnewc_m_print_i64(var_decls_nqafiles,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        offset = mlib_getfilepos(f);
        fileoffsets[(i)-1] = offset;
        nn = mlib_writerandom(f,(byte *)(var_decls_qafiletext[(i)]),offset,var_decls_qafilesizes[(i)]);
L969 :;
    }L970 :;
    ;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((uint8_t*)"=== end ===",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L971 :;
    for (i=(int64_t)1;i<=var_decls_nqafiles;i+=(int64_t)1) {
L972 :;
        mlib_setfilepos(f,headeroffsets[(i)-1]);
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_i64(fileoffsets[(i)-1],(uint8_t*)"8");
        msysnewc_m_print_end();
        ;
L973 :;
    }L974 :;
    ;
    fclose(f);
}

void qc_support_addqafile(uint8_t * filespec,uint8_t * source,int64_t length) {
    if ((var_decls_nqafiles >= (int64_t)100)) {
        qci_loaderror((uint8_t*)"Too many qa files",(uint8_t*)"");
    };
    ++var_decls_nqafiles;
    var_decls_qafilenames[(var_decls_nqafiles)] = mlib_pcm_copyheapstring(mlib_extractfile(filespec));
    var_decls_qafiletext[(var_decls_nqafiles)] = mlib_pcm_copyheapstring(source);
    var_decls_qafilesizes[(var_decls_nqafiles)] = length;
}

void qc_lex_lexreadtoken(void) {
    int64_t c;
    int64_t hsum;
    int64_t commentseen;
    byte *  p;
    qc_lex_nextlx.subcode = (int64_t)0;
    L975 :;
    switch ((int64_t)((*qc_lex_lxsptr++))) {
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    case 103:;
    case 104:;
    case 105:;
    case 106:;
    case 107:;
    case 108:;
    case 109:;
    case 110:;
    case 111:;
    case 112:;
    case 113:;
    case 114:;
    case 115:;
    case 116:;
    case 117:;
    case 118:;
    case 119:;
    case 120:;
    case 121:;
    case 122:;
    case 36:;
    case 95:;
    {
        qc_lex_nextlx.svalue = (uint8_t *)((qc_lex_lxsptr - (int64_t)1));
        //doname:
L977 :;
;
        hsum = (int64_t)((*qc_lex_nextlx.svalue));
        qc_lex_nextlx.hashvalue = (uint64_t)((int64_t)0);
        L978 :;
        switch ((c = (int64_t)((*qc_lex_lxsptr++)))) {
        case 65:;
        case 66:;
        case 67:;
        case 68:;
        case 69:;
        case 70:;
        case 71:;
        case 72:;
        case 73:;
        case 74:;
        case 75:;
        case 76:;
        case 77:;
        case 78:;
        case 79:;
        case 80:;
        case 81:;
        case 82:;
        case 83:;
        case 84:;
        case 85:;
        case 86:;
        case 87:;
        case 88:;
        case 89:;
        case 90:;
        {
            (*(qc_lex_lxsptr - (int64_t)1)) = (uint64_t)((c + (int64_t)32));
            hsum = ((((hsum << (int64_t)4) - hsum) + c) + (int64_t)32);
        }break;
        case 97:;
        case 98:;
        case 99:;
        case 100:;
        case 101:;
        case 102:;
        case 103:;
        case 104:;
        case 105:;
        case 106:;
        case 107:;
        case 108:;
        case 109:;
        case 110:;
        case 111:;
        case 112:;
        case 113:;
        case 114:;
        case 115:;
        case 116:;
        case 117:;
        case 118:;
        case 119:;
        case 120:;
        case 121:;
        case 122:;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        case 95:;
        case 36:;
        {
            hsum = (((hsum << (int64_t)4) - hsum) + c);
        }break;
        case 34:;
        {
            --qc_lex_lxsptr;
            if ((((qc_lex_nextlx.svalue + (int64_t)1) == (uint8_t *)(qc_lex_lxsptr)) && (((uint64_t)((*qc_lex_nextlx.svalue)) == 'F') || ((uint64_t)((*qc_lex_nextlx.svalue)) == 'f')))) {
                qc_lex_readrawstring();
                return;
            };
            goto L979 ;
        }break;
        default: {
            --qc_lex_lxsptr;
            goto L979 ;
        }
        } //SW
goto L978 ;
L979 :;
        ;
        qc_lex_nextlx.symbol = (int64_t)34;
        qc_lex_nextlx.length = (qc_lex_lxsptr - (byte *)(qc_lex_nextlx.svalue));
        qc_lex_nextlx.hashvalue = (uint64_t)(((hsum << (int64_t)5) - hsum));
        return;
    }break;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 71:;
    case 72:;
    case 73:;
    case 74:;
    case 75:;
    case 76:;
    case 77:;
    case 78:;
    case 79:;
    case 80:;
    case 81:;
    case 82:;
    case 83:;
    case 84:;
    case 85:;
    case 86:;
    case 87:;
    case 88:;
    case 89:;
    case 90:;
    {
        qc_lex_nextlx.svalue = (uint8_t *)((qc_lex_lxsptr - (int64_t)1));
        (*qc_lex_nextlx.svalue) += ' ';
        goto L977 ;
;
    }break;
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    {
        c = (int64_t)((*(qc_lex_lxsptr - (int64_t)1)));
        if (((int64_t)((*qc_lex_lxsptr))==(int64_t)32) || ((int64_t)((*qc_lex_lxsptr))==(int64_t)41) || ((int64_t)((*qc_lex_lxsptr))==(int64_t)13) || ((int64_t)((*qc_lex_lxsptr))==(int64_t)44) || ((int64_t)((*qc_lex_lxsptr))==(int64_t)124)) {
            qc_lex_nextlx.symbol = (int64_t)37;
            qc_lex_nextlx.subcode = (int64_t)1;
            qc_lex_nextlx.value = (c - (int64_t)48);
        }else if (((int64_t)((*qc_lex_lxsptr))==(int64_t)120) || ((int64_t)((*qc_lex_lxsptr))==(int64_t)88)) {
            if ((c==(int64_t)48)) {
                ++qc_lex_lxsptr;
                qc_lex_readnumber((int64_t)16);
            }else if ((c==(int64_t)49)) {
                qc_lex_lxerror((uint8_t*)"Bad base");
            } else {
                ++qc_lex_lxsptr;
                qc_lex_readnumber((c - (int64_t)48));
            };
        } else {
            --qc_lex_lxsptr;
            qc_lex_readnumber((int64_t)10);
        };
        return;
    }break;
    case 33:;
    {
        //docomment:
L980 :;
;
        L981 :;
        switch ((c = (int64_t)((*qc_lex_lxsptr++)))) {
        case 13:;
        {
            ++qc_lex_lxsptr;
            goto L982 ;
        }break;
        case 10:;
        {
            goto L982 ;
        }break;
        case 26:;
        case 0:;
        {
            --qc_lex_lxsptr;
            goto L982 ;
        }break;
        default: {
        }
        } //SW
goto L981 ;
L982 :;
        ;
        ++qc_lex_nextlx.lineno;
        qc_lex_nextlx.symbol = (int64_t)32;
        return;
    }break;
    case 35:;
    {
        qc_lex_nextlx.svalue = (uint8_t *)(qc_lex_lxsptr);
        L983 :;
        switch ((c = (int64_t)((*qc_lex_lxsptr++)))) {
        case 13:;
        case 10:;
        case 26:;
        case 0:;
        {
            --qc_lex_lxsptr;
            goto L984 ;
        }break;
        default: {
        }
        } //SW
goto L983 ;
L984 :;
        ;
        qc_lex_nextlx.length = (qc_lex_lxsptr - (byte *)(qc_lex_nextlx.svalue));
        qc_lex_nextlx.symbol = (int64_t)35;
        return;
    }break;
    case 92:;
    {
        commentseen = (int64_t)0;
        L985 :;
        switch ((int64_t)((*qc_lex_lxsptr++))) {
        case 13:;
        {
            ++qc_lex_nextlx.lineno;
            ++qc_lex_lxsptr;
            goto L986 ;
        }break;
        case 10:;
        {
            ++qc_lex_nextlx.lineno;
            goto L986 ;
        }break;
        case 26:;
        case 0:;
        {
            qc_lex_nextlx.symbol = (int64_t)33;
            --qc_lex_lxsptr;
            return;
        }break;
        case 32:;
        case 9:;
        {
        }break;
        case 33:;
        {
            commentseen = (int64_t)1;
        }break;
        default: {
            if (!(!!(commentseen))) {
                qc_lex_lxerror((uint8_t*)"\\ not followed by eol");
            };
        }
        } //SW
goto L985 ;
L986 :;
        ;
        L987 :;
        switch ((int64_t)((*qc_lex_lxsptr++))) {
        case 13:;
        {
            ++qc_lex_nextlx.lineno;
            ++qc_lex_lxsptr;
        }break;
        case 10:;
        {
            ++qc_lex_nextlx.lineno;
        }break;
        case 32:;
        case 9:;
        {
        }break;
        default: {
            --qc_lex_lxsptr;
            goto L988 ;
        }
        } //SW
goto L987 ;
L988 :;
        ;
    }break;
    case 123:;
    {
        qc_lex_nextlx.symbol = (int64_t)16;
        return;
    }break;
    case 125:;
    {
        qc_lex_nextlx.symbol = (int64_t)17;
        return;
    }break;
    case 46:;
    {
        switch ((int64_t)((*qc_lex_lxsptr))) {
        case 46:;
        {
            ++qc_lex_lxsptr;
            if (((uint64_t)((*qc_lex_lxsptr)) == (uint64_t)46u)) {
                ++qc_lex_lxsptr;
                qc_lex_nextlx.symbol = (int64_t)30;
            } else {
                qc_lex_nextlx.symbol = (int64_t)29;
                qc_lex_nextlx.subcode = (int64_t)82;
            };
            return;
        }break;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        {
            --qc_lex_lxsptr;
            qc_lex_readrealnumber((uint8_t *)(0),(int64_t)0,(int64_t)10);
            return;
        }break;
        default: {
            p = (qc_lex_lxsptr - (int64_t)2);
            if ((((p < qc_lex_lxstart) || ((int64_t)((uint64_t)((*p))) == (int64_t)13)) || ((int64_t)((uint64_t)((*p))) == (int64_t)10))) {
                qc_lex_nextlx.symbol = (int64_t)3;
            } else {
                qc_lex_nextlx.symbol = (int64_t)2;
            };
            return;
        }
        } //SW
;
    }break;
    case 44:;
    {
        qc_lex_nextlx.symbol = (int64_t)5;
        return;
    }break;
    case 59:;
    {
        qc_lex_nextlx.symbol = (int64_t)6;
        return;
    }break;
    case 58:;
    {
        switch ((int64_t)((*qc_lex_lxsptr))) {
        case 61:;
        {
            ++qc_lex_lxsptr;
            if (((int64_t)((*qc_lex_lxsptr))==(int64_t)61)) {
                ++qc_lex_lxsptr;
                qc_lex_nextlx.symbol = (int64_t)10;
                qc_lex_nextlx.subcode = (int64_t)89;
            } else {
                qc_lex_nextlx.symbol = (int64_t)9;
                qc_lex_nextlx.subcode = (int64_t)88;
            };
        }break;
        case 58:;
        {
            ++qc_lex_lxsptr;
            if (((int64_t)((*qc_lex_lxsptr))==(int64_t)61)) {
                ++qc_lex_lxsptr;
                qc_lex_nextlx.symbol = (int64_t)10;
                qc_lex_nextlx.subcode = (int64_t)89;
            } else {
                qc_lex_nextlx.symbol = (int64_t)8;
            };
        }break;
        default: {
            qc_lex_nextlx.symbol = (int64_t)7;
        }
        } //SW
;
        return;
    }break;
    case 40:;
    {
        qc_lex_nextlx.symbol = (int64_t)12;
        return;
    }break;
    case 41:;
    {
        qc_lex_nextlx.symbol = (int64_t)13;
        return;
    }break;
    case 91:;
    {
        qc_lex_nextlx.symbol = (int64_t)14;
        return;
    }break;
    case 93:;
    {
        qc_lex_nextlx.symbol = (int64_t)15;
        return;
    }break;
    case 124:;
    {
        if (((uint64_t)((*qc_lex_lxsptr)) == (uint64_t)124u)) {
            ++qc_lex_lxsptr;
            qc_lex_nextlx.symbol = (int64_t)20;
        } else {
            qc_lex_nextlx.symbol = (int64_t)19;
        };
        return;
    }break;
    case 94:;
    {
        qc_lex_nextlx.symbol = (int64_t)18;
        qc_lex_nextlx.subcode = (int64_t)147;
        return;
    }break;
    case 64:;
    {
        if (((uint64_t)((*qc_lex_lxsptr)) == (uint64_t)64u)) {
            ++qc_lex_lxsptr;
            qc_lex_nextlx.symbol = (int64_t)22;
        } else {
            qc_lex_nextlx.symbol = (int64_t)21;
        };
        return;
    }break;
    case 63:;
    {
        qc_lex_nextlx.symbol = (int64_t)23;
        return;
    }break;
    case 178:;
    {
        qc_lex_nextlx.symbol = (int64_t)31;
        qc_lex_nextlx.subcode = (int64_t)162;
        return;
    }break;
    case 126:;
    {
        qc_lex_nextlx.symbol = (int64_t)27;
        return;
    }break;
    case 43:;
    {
        qc_lex_nextlx.symbol = (int64_t)31;
        if (((uint64_t)((*qc_lex_lxsptr)) == (uint64_t)43u)) {
            ++qc_lex_lxsptr;
            qc_lex_nextlx.symbol = (int64_t)36;
            qc_lex_nextlx.subcode = (int64_t)209;
            return;
        } else {
            qc_lex_nextlx.subcode = (int64_t)105;
        };
        return;
    }break;
    case 45:;
    {
        qc_lex_nextlx.symbol = (int64_t)31;
        if (((uint64_t)((*qc_lex_lxsptr)) == (uint64_t)45u)) {
            ++qc_lex_lxsptr;
            qc_lex_nextlx.symbol = (int64_t)36;
            qc_lex_nextlx.subcode = (int64_t)210;
            return;
        } else {
            qc_lex_nextlx.subcode = (int64_t)106;
        };
        return;
    }break;
    case 42:;
    {
        qc_lex_nextlx.symbol = (int64_t)31;
        if (((uint64_t)((*qc_lex_lxsptr)) == (uint64_t)42u)) {
            ++qc_lex_lxsptr;
            qc_lex_nextlx.subcode = (int64_t)145;
        } else {
            qc_lex_nextlx.subcode = (int64_t)107;
        };
        return;
    }break;
    case 47:;
    {
        qc_lex_nextlx.symbol = (int64_t)31;
        if (((int64_t)((*qc_lex_lxsptr))==(int64_t)47)) {
            ++qc_lex_lxsptr;
            qc_lex_nextlx.subcode = (int64_t)111;
        } else {
            qc_lex_nextlx.subcode = (int64_t)108;
        };
        return;
    }break;
    case 37:;
    {
        qc_lex_nextlx.symbol = (int64_t)31;
        qc_lex_nextlx.subcode = (int64_t)109;
        return;
    }break;
    case 61:;
    {
        if (((int64_t)((*qc_lex_lxsptr))==(int64_t)62)) {
            qc_lex_nextlx.symbol = (int64_t)11;
            ++qc_lex_lxsptr;
        }else if (((int64_t)((*qc_lex_lxsptr))==(int64_t)61)) {
            qc_lex_nextlx.symbol = (int64_t)31;
            qc_lex_nextlx.subcode = (int64_t)104;
            ++qc_lex_lxsptr;
        } else {
            qc_lex_nextlx.symbol = (int64_t)31;
            qc_lex_nextlx.subcode = (int64_t)98;
        };
        return;
    }break;
    case 60:;
    {
        qc_lex_nextlx.symbol = (int64_t)31;
        switch ((int64_t)((*qc_lex_lxsptr))) {
        case 61:;
        {
            ++qc_lex_lxsptr;
            qc_lex_nextlx.subcode = (int64_t)101;
        }break;
        case 62:;
        {
            ++qc_lex_lxsptr;
            qc_lex_nextlx.subcode = (int64_t)99;
        }break;
        case 60:;
        {
            ++qc_lex_lxsptr;
            qc_lex_nextlx.subcode = (int64_t)117;
        }break;
        default: {
            qc_lex_nextlx.subcode = (int64_t)100;
        }
        } //SW
;
        return;
    }break;
    case 62:;
    {
        qc_lex_nextlx.symbol = (int64_t)31;
        switch ((int64_t)((*qc_lex_lxsptr))) {
        case 61:;
        {
            ++qc_lex_lxsptr;
            qc_lex_nextlx.subcode = (int64_t)103;
        }break;
        case 62:;
        {
            ++qc_lex_lxsptr;
            qc_lex_nextlx.subcode = (int64_t)118;
        }break;
        default: {
            qc_lex_nextlx.subcode = (int64_t)102;
        }
        } //SW
;
        return;
    }break;
    case 38:;
    {
        if (((int64_t)((*qc_lex_lxsptr))==(int64_t)38)) {
            ++qc_lex_lxsptr;
            qc_lex_nextlx.symbol = (int64_t)31;
            qc_lex_nextlx.subcode = (int64_t)97;
        }else if (((int64_t)((*qc_lex_lxsptr))==(int64_t)46)) {
            ++qc_lex_lxsptr;
            qc_lex_nextlx.symbol = (int64_t)4;
            qc_lex_nextlx.subcode = (int64_t)0;
        } else {
            qc_lex_nextlx.symbol = (int64_t)24;
            qc_lex_nextlx.subcode = (int64_t)148;
        };
        return;
    }break;
    case 39:;
    case 96:;
    {
        qc_lex_lxreadstring((int64_t)39);
        return;
    }break;
    case 34:;
    {
        qc_lex_lxreadstring((int64_t)34);
        return;
    }break;
    case 32:;
    case 9:;
    {
    }break;
    case 13:;
    {
        ++qc_lex_lxsptr;
        ++qc_lex_nextlx.lineno;
        qc_lex_nextlx.symbol = (int64_t)32;
        return;
    }break;
    case 10:;
    {
        ++qc_lex_nextlx.lineno;
        qc_lex_nextlx.symbol = (int64_t)32;
        return;
    }break;
    case 26:;
    case 0:;
    {
        if (!!(qc_lex_macrolevel)) {
            qc_lex_unstackmacro();
        } else {
            qc_lex_nextlx.symbol = (int64_t)33;
            --qc_lex_lxsptr;
            return;
        };
    }break;
    case 239:;
    {
        qc_lex_lxsptr += (int64_t)2;
    }break;
    default: {
        qc_lex_nextlx.symbol = (int64_t)1;
        qc_lex_nextlx.value = c;
        return;
    }
    } //SW
goto L975 ;
L976 :;
    ;
}

static void qc_lex_lxreadstring(int64_t termchar) {
    static uint8_t psname[256];
    uint8_t *  dest;
    int64_t c;
    int64_t d;
    int64_t av_1;
    if ((termchar == (int64_t)34)) {
        qc_lex_nextlx.symbol = (int64_t)42;
        qc_lex_nextlx.subcode = (int64_t)5;
    } else {
        qc_lex_nextlx.symbol = (int64_t)40;
        qc_lex_nextlx.subcode = (int64_t)1;
    };
    if (!(!!(var_decls_prescanmode))) {
        dest = (uint8_t *)(qc_lex_lxsptr);
    } else {
        dest = psname;
    };
    qc_lex_nextlx.svalue = dest;
    L989 :;
    while (1) {
        switch ((c = (int64_t)((*qc_lex_lxsptr++)))) {
        case 92:;
        {
            c = (int64_t)((*qc_lex_lxsptr));
            if (((c >= (int64_t)65) && (c <= (int64_t)90))) {
                c += (int64_t)32;
            };
            ++qc_lex_lxsptr;
            switch (c) {
            case 97:;
            {
                c = (int64_t)7;
            }break;
            case 98:;
            {
                c = (int64_t)8;
            }break;
            case 99:;
            case 114:;
            {
                c = (int64_t)13;
            }break;
            case 101:;
            {
                c = (int64_t)26;
            }break;
            case 102:;
            {
                c = (int64_t)12;
            }break;
            case 108:;
            case 110:;
            {
                c = (int64_t)10;
            }break;
            case 115:;
            {
                c = (int64_t)27;
            }break;
            case 116:;
            {
                c = (int64_t)9;
            }break;
            case 118:;
            {
                c = (int64_t)11;
            }break;
            case 119:;
            {
                (*dest++) = (uint64_t)13u;
                c = (int64_t)10;
            }break;
            case 120:;
            {
                c = (int64_t)0;
                av_1 = (int64_t)2;
                while (av_1-- > 0) {
L991 :;
                    if (((d = (int64_t)((*qc_lex_lxsptr++)))==(int64_t)65) || ((d = (int64_t)((*qc_lex_lxsptr++)))==(int64_t)66) || ((d = (int64_t)((*qc_lex_lxsptr++)))==(int64_t)67) || ((d = (int64_t)((*qc_lex_lxsptr++)))==(int64_t)68) || ((d = (int64_t)((*qc_lex_lxsptr++)))==(int64_t)69) || ((d = (int64_t)((*qc_lex_lxsptr++)))==(int64_t)70)) {
                        c = ((((c * (int64_t)16) + d) - (int64_t)65) + (int64_t)10);
                    }else if (((d = (int64_t)((*qc_lex_lxsptr++)))==(int64_t)97) || ((d = (int64_t)((*qc_lex_lxsptr++)))==(int64_t)98) || ((d = (int64_t)((*qc_lex_lxsptr++)))==(int64_t)99) || ((d = (int64_t)((*qc_lex_lxsptr++)))==(int64_t)100) || ((d = (int64_t)((*qc_lex_lxsptr++)))==(int64_t)101) || ((d = (int64_t)((*qc_lex_lxsptr++)))==(int64_t)102)) {
                        c = ((((c * (int64_t)16) + d) - (int64_t)97) + (int64_t)10);
                    }else if (((d = (int64_t)((*qc_lex_lxsptr++)))==(int64_t)48) || ((d = (int64_t)((*qc_lex_lxsptr++)))==(int64_t)49) || ((d = (int64_t)((*qc_lex_lxsptr++)))==(int64_t)50) || ((d = (int64_t)((*qc_lex_lxsptr++)))==(int64_t)51) || ((d = (int64_t)((*qc_lex_lxsptr++)))==(int64_t)52) || ((d = (int64_t)((*qc_lex_lxsptr++)))==(int64_t)53) || ((d = (int64_t)((*qc_lex_lxsptr++)))==(int64_t)54) || ((d = (int64_t)((*qc_lex_lxsptr++)))==(int64_t)55) || ((d = (int64_t)((*qc_lex_lxsptr++)))==(int64_t)56) || ((d = (int64_t)((*qc_lex_lxsptr++)))==(int64_t)57)) {
                        c = (((c * (int64_t)16) + d) - (int64_t)48);
                    } else {
                        qc_lex_lxerror((uint8_t*)"Bad \\x code");
                    };
L992 :;
                }L993 :;
                ;
            }break;
            case 121:;
            {
                c = (int64_t)16;
            }break;
            case 122:;
            case 48:;
            {
                c = (int64_t)0;
            }break;
            case 34:;
            case 81:;
            {
                c = (int64_t)34;
            }break;
            case 92:;
            {
                c = (int64_t)92;
            }break;
            case 39:;
            {
                c = (int64_t)39;
            }break;
            default: {
                msysnewc_m_print_startcon();
                msysnewc_m_print_i64(c,NULL);
                msysnewc_m_print_c8((uint8_t)(c),NULL);
                msysnewc_m_print_str((uint8_t*)"NEXTLX.LINENO=",NULL);
                msysnewc_m_print_i64(qc_lex_nextlx.lineno,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                qc_lex_lxerror((uint8_t*)"Unknown string escape");
            }
            } //SW
;
        }break;
        case 34:;
        case 39:;
        {
            if ((c == termchar)) {
                if (((int64_t)((uint64_t)((*qc_lex_lxsptr))) == c)) {
                    ++qc_lex_lxsptr;
                } else {
                    goto L990 ;
                };
            };
        }break;
        case 13:;
        case 10:;
        case 26:;
        case 0:;
        {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"NEXTLX.LINENO=",NULL);
            msysnewc_m_print_i64(qc_lex_nextlx.lineno,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            qc_lex_lxerror((uint8_t*)"String not terminated");
        }break;
        default: {
        }
        } //SW
;
        if (!(!!(var_decls_prescanmode))) {
            (*dest++) = (uint64_t)(c);
        } else {
            if (((dest - qc_lex_nextlx.svalue) < (int64_t)251)) {
                (*dest++) = (uint64_t)(c);
            };
        };
    }L990 :;
    ;
    qc_lex_nextlx.length = (dest - qc_lex_nextlx.svalue);
    (*(qc_lex_nextlx.svalue + (int64_t)(qc_lex_nextlx.length))) = (uint64_t)0u;
}

static void qc_lex_readnumber(int64_t base) {
    byte *  pstart;
    byte *  dest;
    int64_t numtype;
    int64_t c;
    dest = (pstart = qc_lex_lxsptr);
    if ((base == (int64_t)10)) {
        L994 :;
        switch ((c = (int64_t)((*qc_lex_lxsptr++)))) {
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        {
            (*dest++) = (uint64_t)(c);
        }break;
        case 95:;
        case 39:;
        case 96:;
        {
        }break;
        default: {
            --qc_lex_lxsptr;
            goto L995 ;
        }
        } //SW
goto L994 ;
L995 :;
        ;
    } else {
        dest = qc_lex_scannumber(base);
        c = (int64_t)((*qc_lex_lxsptr));
    };
    numtype = (int64_t)0;
    switch (c) {
    case 46:;
    {
        if (((uint64_t)((*(qc_lex_lxsptr + (int64_t)1))) != (uint64_t)46u)) {
            qc_lex_readrealnumber((uint8_t *)(pstart),(dest - pstart),base);
            return;
        };
    }break;
    case 101:;
    case 69:;
    {
        if ((base <= (int64_t)10)) {
            qc_lex_readrealnumber((uint8_t *)(pstart),(dest - pstart),base);
            return;
        };
    }break;
    case 112:;
    case 80:;
    {
        if ((base == (int64_t)16)) {
            qc_lex_readrealnumber((uint8_t *)(pstart),(dest - pstart),base);
            return;
        };
    }break;
    case 105:;
    case 73:;
    {
        ++qc_lex_lxsptr;
        numtype = (int64_t)1;
    }break;
    case 119:;
    case 87:;
    case 117:;
    case 85:;
    {
        ++qc_lex_lxsptr;
        numtype = (int64_t)2;
    }break;
    case 76:;
    case 108:;
    {
        ++qc_lex_lxsptr;
        numtype = (int64_t)7;
    }break;
    default: {
    }
    } //SW
;
    qc_lex_stringtonumber((uint8_t *)(pstart),(dest - pstart),base,numtype);
}

static void qc_lex_readrealnumber(uint8_t * intstart,int64_t intlen,int64_t base) {
    byte *  fractstart;
    int64_t fractlen;
    int64_t expon;
    int64_t i;
    int64_t c;
    double basex;
    double x;
    uint8_t realstr[500];
    int64_t av_1;
    int64_t av_2;
    int64_t av_3;
    fractstart = (byte *)(0);
    fractlen = (int64_t)0;
    expon = (int64_t)0;
    if (((uint64_t)((*qc_lex_lxsptr)) == (uint64_t)46u)) {
        fractstart = ++qc_lex_lxsptr;
        fractlen = (qc_lex_scannumber(base) - fractstart);
    };
    if (((int64_t)((*qc_lex_lxsptr))==(int64_t)101) || ((int64_t)((*qc_lex_lxsptr))==(int64_t)69)) {
        if ((base != (int64_t)16)) {
            ++qc_lex_lxsptr;
            expon = qc_lex_readexponent(base);
        };
    }else if (((int64_t)((*qc_lex_lxsptr))==(int64_t)112) || ((int64_t)((*qc_lex_lxsptr))==(int64_t)80)) {
        if ((base == (int64_t)16)) {
            ++qc_lex_lxsptr;
            expon = qc_lex_readexponent(base);
        };
    };
    if (((intlen + fractlen) > (int64_t)500)) {
        qc_lex_lxerror((uint8_t*)"Real too long");
    };
    if (!!(intlen)) {
        memcpy((void *)(&realstr),(void *)(intstart),(uint64_t)(intlen));
    };
    if (!!(fractlen)) {
        memcpy((void *)((&realstr[((int64_t)1)-1] + intlen)),(void *)(fractstart),(uint64_t)(fractlen));
    };
    basex = (double)(base);
    expon -= fractlen;
    x = (double)0.;
    L996 :;
    for (i=(int64_t)1;i<=(intlen + fractlen);i+=(int64_t)1) {
L997 :;
        c = (int64_t)(realstr[(i)-1]);
        if (((c >= (int64_t)48) && (c <= (int64_t)57))) {
            x = (((x * basex) + (double)(c)) - (double)48.);
        } else if ((c > (int64_t)97)) {
            x = ((((x * basex) + (double)(c)) - (double)97.) + (double)10.);
        } else {
            x = ((((x * basex) + (double)(c)) - (double)65.) + (double)10.);
        };
L998 :;
    }L999 :;
    ;
    if ((expon >= (int64_t)0)) {
        av_2 = expon;
        while (av_2-- > 0) {
L1000 :;
            x *= basex;
L1001 :;
        }L1002 :;
        ;
    } else {
        av_3 = -(expon);
        while (av_3-- > 0) {
L1003 :;
            x /= basex;
L1004 :;
        }L1005 :;
        ;
    };
    qc_lex_nextlx.symbol = (int64_t)39;
    qc_lex_nextlx.subcode = (int64_t)3;
    qc_lex_nextlx.xvalue = x;
}

static int64_t qc_lex_readexponent(int64_t base) {
    byte *  numstart;
    int64_t length;
    int64_t neg;
    neg = (int64_t)0;
    if (((int64_t)((*qc_lex_lxsptr))==(int64_t)43)) {
        ++qc_lex_lxsptr;
    }else if (((int64_t)((*qc_lex_lxsptr))==(int64_t)45)) {
        ++qc_lex_lxsptr;
        neg = (int64_t)1;
    };
    numstart = qc_lex_lxsptr;
    length = (qc_lex_scannumber(base) - numstart);
    if ((length == (int64_t)0)) {
        qc_lex_lxerror((uint8_t*)"Bad expon");
    };
    qc_lex_stringtonumber((uint8_t *)(numstart),length,base,(int64_t)0);
    return (!!(neg)?-(qc_lex_nextlx.value):qc_lex_nextlx.value);
}

static void qc_lex_lxerror(uint8_t * mess) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_i64(qc_lex_nextlx.lineno,NULL);
    msysnewc_m_print_str((uint8_t*)"LEX ERROR",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_str((uint8_t*)"in",NULL);
    msysnewc_m_print_str((*var_decls_stmodule).name,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mlib_abortprogram((uint8_t*)"Stopping");
}

void qc_lex_printsymbol(struct qc_lex_lexrec * lp) {
    struct qc_lex_lexrec l;
    l = (*lp);
    printf((int8_t *)((uint8_t*)"%-18s"),qc_tables_symbolnames[((int64_t)(l.symbol))-1]);
    if (((int64_t)(l.symbol)==(int64_t)34)) {
        msysnewc_printstrn_app(l.svalue,(int64_t)(l.length),0);
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)" (",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_u64(l.hashvalue,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((uint8_t*)")",NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)(l.symbol)==(int64_t)45)) {
        msysnewc_printstrn_app((*l.symptr).name,(int64_t)((*l.symptr).namelen),0);
    }else if (((int64_t)(l.symbol)==(int64_t)37)) {
        if (((int64_t)(l.subcode)==(int64_t)1)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_i64(l.value,NULL);
            msysnewc_m_print_str((uint8_t*)"int",NULL);
            msysnewc_m_print_end();
            ;
        }else if (((int64_t)(l.subcode)==(int64_t)2)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_u64(l.uvalue,NULL);
            msysnewc_m_print_str((uint8_t*)"word",NULL);
            msysnewc_m_print_end();
            ;
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_i64(l.value,NULL);
            msysnewc_m_print_end();
            ;
        };
    }else if (((int64_t)(l.symbol)==(int64_t)39)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_r64(l.xvalue,NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)(l.symbol)==(int64_t)42)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"\"",NULL);
        msysnewc_m_print_end();
        ;
        msysnewc_printstrn_app(l.svalue,(int64_t)(l.length),0);
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"\"",NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)(l.symbol)==(int64_t)40)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"'",NULL);
        msysnewc_m_print_end();
        ;
        msysnewc_printstrn_app(l.svalue,(int64_t)(l.length),0);
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"'",NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)(l.symbol)==(int64_t)38)) {
        msysnewc_printstrn_app(l.svalue,(int64_t)(l.length),0);
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"L",NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)(l.symbol)==(int64_t)31) || ((int64_t)(l.symbol)==(int64_t)9) || ((int64_t)(l.symbol)==(int64_t)24) || ((int64_t)(l.symbol)==(int64_t)18) || ((int64_t)(l.symbol)==(int64_t)10) || ((int64_t)(l.symbol)==(int64_t)29)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(qc_tables_jtagnames[((int64_t)(l.subcode))],NULL);
        msysnewc_m_print_end();
        ;
    } else {
        if (!!((int64_t)(l.subcode))) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((uint8_t*)"#",NULL);
            msysnewc_m_print_i64(l.subcode,NULL);
            msysnewc_m_print_end();
            ;
        };
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static void qc_lex_stringtonumber(uint8_t * s,int64_t length,int64_t base,int64_t numtype) {
    int64_t a;
    uint64_t b;
    int64_t c;
    uint8_t *  t;
    int64_t av_1;
    int64_t av_2;
    L1006 :;
    while (((length >= (int64_t)2) && ((uint64_t)((*s)) == '0'))) {
        ++s;
        --length;
L1007 :;
    }L1008 :;
    ;
    if ((((numtype == (int64_t)7) || (length > qc_lex_maxnumlen[(base)-1])) || ((length == qc_lex_maxnumlen[(base)-1]) && ((int64_t)(strncmp((int8_t *)(s),(int8_t *)(qc_lex_maxnumlist[(base)-1]),(uint64_t)(length))) > (int64_t)0)))) {
        qc_lex_nextlx.symbol = (int64_t)38;
        qc_lex_nextlx.svalue = s;
        qc_lex_nextlx.length = length;
        switch (base) {
        case 10:;
        {
        }break;
        case 16:;
        {
            t = (uint8_t *)(mlib_pcm_alloc((((int64_t)2 + length) + (int64_t)1)));
            strcpy((int8_t *)(t),(int8_t *)((uint8_t*)"0x"));
            strcat((int8_t *)(t),(int8_t *)(s));
            qc_lex_nextlx.svalue = t;
            qc_lex_nextlx.length += (int32_t)2;
        }break;
        case 2:;
        case 3:;
        case 4:;
        case 5:;
        case 6:;
        case 7:;
        case 8:;
        case 9:;
        {
            t = (uint8_t *)(mlib_pcm_alloc((((int64_t)2 + length) + (int64_t)1)));
            qc_lex_nextlx.svalue = t;
            (*t++) = (uint64_t)((base + (int64_t)48));
            (*t++) = 'x';
            strcat((int8_t *)(t),(int8_t *)(s));
            qc_lex_nextlx.length += (int32_t)2;
        }break;
        default: {
            qc_lex_lxerror((uint8_t*)"longint/base?");
        }
        } //SW
;
        if ((!!(numtype) && (numtype != (int64_t)7))) {
            qc_lex_lxerror((uint8_t*)"Can't apply width override to longint");
        };
        return;
    };
    a = (int64_t)0;
    if ((base <= (int64_t)10)) {
        av_1 = length;
        while (av_1-- > 0) {
L1009 :;
            a = (((a * base) + (int64_t)((*s++))) - (int64_t)48);
L1010 :;
        }L1011 :;
        ;
    } else {
        av_2 = length;
        while (av_2-- > 0) {
L1012 :;
            c = (int64_t)((*s++));
            if ((c >= (int64_t)97)) {
                a = ((((a * base) + c) - (int64_t)97) + (int64_t)10);
            } else if ((c >= (int64_t)65)) {
                a = ((((a * base) + c) - (int64_t)65) + (int64_t)10);
            } else {
                a = (((a * base) + c) - (int64_t)48);
            };
L1013 :;
        }L1014 :;
        ;
    };
    qc_lex_nextlx.symbol = (int64_t)37;
    qc_lex_nextlx.value = a;
    if (!!(numtype)) {
        qc_lex_nextlx.subcode = numtype;
        return;
    };
    b = (uint64_t)(a);
    if ((b < (uint64_t)9223372036854775807u)) {
        qc_lex_nextlx.subcode = (int64_t)1;
    } else {
        qc_lex_nextlx.subcode = (int64_t)2;
    };
}

void qc_lex_lexsetup(void) {
    int64_t i;
    static int64_t n;
    int64_t av_1;
    L1015 :;
    for (i=(int64_t)1;i<=(int64_t)16;i+=(int64_t)1) {
L1016 :;
        qc_lex_maxnumlen[(i)-1] = (int64_t)(strlen((int8_t *)(qc_lex_maxnumlist[(i)-1])));
L1017 :;
    }L1018 :;
    ;
    qc_lex_inithashtable();
    n = (int64_t)0;
    L1019 :;
    for (i=(int64_t)0;i<=(int64_t)32767;i+=(int64_t)1) {
L1020 :;
        if (!!(qc_lex_hashtable[(i)].name)) {
            ++n;
        };
L1021 :;
    }L1022 :;
    ;
}

static byte * qc_lex_scannumber(int64_t base) {
    byte *  dest;
    int64_t c;
    dest = qc_lex_lxsptr;
    L1023 :;
    switch ((c = (int64_t)((*qc_lex_lxsptr++)))) {
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    {
        (*dest++) = (uint64_t)(c);
        if ((c >= ((int64_t)48 + base))) {
            qc_lex_lxerror((uint8_t*)"Digit out of range");
        };
    }break;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    {
        if ((base == (int64_t)16)) {
            (*dest++) = (uint64_t)(c);
        } else {
            --qc_lex_lxsptr;
            goto L1024 ;
        };
    }break;
    case 95:;
    case 39:;
    case 96:;
    {
    }break;
    default: {
        --qc_lex_lxsptr;
        goto L1024 ;
    }
    } //SW
goto L1023 ;
L1024 :;
    ;
    return dest;
}

static void qc_lex_readrawstring(void) {
    uint8_t *  dest;
    int64_t c;
    qc_lex_nextlx.symbol = (int64_t)42;
    qc_lex_nextlx.subcode = (int64_t)5;
    qc_lex_nextlx.svalue = (uint8_t *)(++qc_lex_lxsptr);
    dest = (uint8_t *)(qc_lex_lxsptr);
    L1025 :;
    switch ((c = (int64_t)((*qc_lex_lxsptr++)))) {
    case 34:;
    {
        if (((uint64_t)((*qc_lex_lxsptr)) == (uint64_t)34u)) {
            (*dest++) = '"';
            ++qc_lex_lxsptr;
        } else {
            (*(qc_lex_lxsptr - (int64_t)1)) = (uint64_t)((int64_t)0);
            goto L1026 ;
        };
    }break;
    case 13:;
    case 10:;
    case 26:;
    case 0:;
    {
        qc_lex_lxerror((uint8_t*)"Raw string not terminated");
        --qc_lex_lxsptr;
        goto L1026 ;
    }break;
    default: {
        (*dest++) = (uint64_t)(c);
    }
    } //SW
goto L1025 ;
L1026 :;
    ;
    qc_lex_nextlx.length = (dest - qc_lex_nextlx.svalue);
}

static int64_t qc_lex_lookup(void) {
    int64_t j;
    int64_t wrapped;
    ++qc_lex_nlookups;
    j = ((int64_t)((uint64_t)(qc_lex_nextlx.hashvalue)) & (int64_t)32767);
    qc_lex_lxsymptr = &qc_lex_hashtable[(j)];
    wrapped = (int64_t)0;
    L1027 :;
    while (1) {
        if (((*qc_lex_lxsymptr).name == 0)) {
            goto L1028 ;
        };
        if (((int64_t)((uint64_t)((*qc_lex_lxsymptr).namelen)) == (int64_t)(qc_lex_nextlx.length))) {
            if (((int64_t)(memcmp((void *)((*qc_lex_lxsymptr).name),(void *)(qc_lex_nextlx.svalue),(uint64_t)(qc_lex_nextlx.length))) == (int64_t)0)) {
                return (int64_t)1;
            };
        };
        ++qc_lex_nclashes;
        ++qc_lex_lxsymptr;
        if ((++j >= (int64_t)32768)) {
            if (!!(wrapped)) {
                mlib_abortprogram((uint8_t*)"HASHTABLE FULL");
            };
            wrapped = (int64_t)1;
            qc_lex_lxsymptr = &qc_lex_hashtable[((int64_t)0)];
            j = (int64_t)0;
        };
    }L1028 :;
    ;
    (*qc_lex_lxsymptr).name = qc_lex_nextlx.svalue;
    (*qc_lex_lxsymptr).namelen = (uint64_t)(qc_lex_nextlx.length);
    (*qc_lex_lxsymptr).symbol = (uint64_t)((int64_t)34);
    return (int64_t)0;
}

static uint64_t qc_lex_gethashvaluez(uint8_t * s) {
    uint64_t c;
    uint64_t hsum;
    if (((int64_t)((*s)) == (int64_t)0)) {
        return (uint64_t)((int64_t)0);
    };
    hsum = (uint64_t)((*s++));
    L1029 :;
    while (1) {
        c = (uint64_t)((*s++));
        if (((int64_t)(c) == (int64_t)0)) {
            goto L1030 ;
        };
        hsum = (((hsum << (int64_t)4) - hsum) + c);
    }L1030 :;
    ;
    return ((hsum << (int64_t)5) - hsum);
}

static void qc_lex_inithashtable(void) {
    int64_t i;
    int64_t av_1;
    memset((void *)(&qc_lex_hashtable),(int64_t)0,(uint64_t)((int64_t)4456448));
    L1031 :;
    for (i=(int64_t)1;i<=(int64_t)327;i+=(int64_t)1) {
L1032 :;
        qc_lex_nextlx.svalue = qc_tables_stnames[(i)-1];
        qc_lex_nextlx.length = (int64_t)(strlen((int8_t *)(qc_lex_nextlx.svalue)));
        qc_lex_nextlx.hashvalue = qc_lex_gethashvaluez(qc_lex_nextlx.svalue);
        if (!!(qc_lex_lookup())) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(qc_tables_stnames[(i)-1],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mlib_abortprogram((uint8_t*)"Duplicate symbol table entry");
        };
        (*qc_lex_lxsymptr).symbol = (uint64_t)(qc_tables_stsymbols[(i)-1]);
        if ((qc_tables_stsymbols[(i)-1]==(int64_t)44)) {
            (*qc_lex_lxsymptr).index = qc_tables_stsubcodes[(i)-1];
            (*qc_lex_lxsymptr).subcode = (int64_t)44;
            (*qc_lex_lxsymptr).symbol = (uint64_t)((int64_t)34);
        } else {
            (*qc_lex_lxsymptr).subcode = qc_tables_stsubcodes[(i)-1];
        };
L1033 :;
    }L1034 :;
    ;
}

static int64_t qc_lex_dolexdirective(int64_t index) {
    struct var_decls_strec *  symptr;
    byte *  p;
    uint8_t *  file;
    if ((index==(int64_t)1)) {
        qc_lex_lexreadtoken();
        if (((int64_t)(qc_lex_nextlx.symbol) != (int64_t)34)) {
            qc_lex_lxerror((uint8_t*)"define: name expected");
        };
        if ((!!(qc_lex_lookup()) && ((int64_t)((uint64_t)((*qc_lex_lxsymptr).symbol)) == (int64_t)47))) {
            msysnewc_printstrn_app(qc_lex_nextlx.svalue,(int64_t)(qc_lex_nextlx.length),0);
            qc_lex_lxerror((uint8_t*)"Macro already defined");
        };
        symptr = qc_lex_lxsymptr;
        qc_lex_lexreadtoken();
        if (!((((int64_t)(qc_lex_nextlx.symbol) == (int64_t)31) && ((int64_t)(qc_lex_nextlx.subcode) == (int64_t)98)))) {
            qc_lex_lxerror((uint8_t*)"\"=\" expected");
        };
        p = qc_lex_lxsptr;
        qc_lex_lexreadline();
        qc_lex_addmacro(symptr,(uint8_t *)(p),(qc_lex_lxsptr - p));
        qc_lex_lexreadtoken();
        if (((int64_t)(qc_lex_nextlx.symbol) != (int64_t)32)) {
            qc_lex_lxerror((uint8_t*)"Bad define");
        };
        return (int64_t)0;
    }else if ((index==(int64_t)14)) {
        qc_lex_lexreadtoken();
        if (((int64_t)(qc_lex_nextlx.symbol) != (int64_t)42)) {
            qc_lex_lxerror((uint8_t*)"strincl: string expected");
        };
        file = qc_lex_nextlx.svalue;
        qc_lex_nextlx.svalue = (uint8_t *)(mlib_readfile(file));
        if ((qc_lex_nextlx.svalue == 0)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(file,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            qc_lex_lxerror((uint8_t*)"Can't find strinclude file");
        };
        qc_lex_nextlx.symbol = (int64_t)42;
        qc_lex_nextlx.subcode = (int64_t)5;
        qc_lex_nextlx.length = mlib_rfsize;
        if (!!(var_decls_fwriteqa)) {
            qc_support_addqafile(file,(uint8_t *)(qc_lex_nextlx.value),mlib_rfsize);
        };
        (*(qc_lex_nextlx.svalue + mlib_rfsize)) = (uint64_t)0u;
        return (int64_t)1;
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(qc_tables_sourcedirnames[(index)-1],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        qc_lex_lxerror((uint8_t*)"Directive not implemented");
    };
    return (int64_t)0;
}

static void qc_lex_lexreadline(void) {
    L1035 :;
    switch ((int64_t)((*qc_lex_lxsptr))) {
    case 13:;
    case 10:;
    {
        return;
    }break;
    case 26:;
    case 0:;
    {
        --qc_lex_lxsptr;
        return;
    }break;
    default: {
        ++qc_lex_lxsptr;
    }
    } //SW
goto L1035 ;
L1036 :;
    ;
}

void qc_lex_startlex(uint8_t * caption,uint8_t * sourcecode) {
    qc_lex_lxsptr = (byte *)(sourcecode);
    qc_lex_nextlx.lineno = (int64_t)1;
    qc_lex_nextlx.symbol = (int64_t)6;
    qc_lex_nextlx.subcode = (int64_t)0;
}

uint8_t * qc_lex_convertzstring(uint8_t * s,int64_t length) {
    static uint8_t str[300];
    if ((length > (int64_t)300)) {
        mlib_abortprogram((uint8_t*)"convertzstr");
    };
    memcpy((void *)(&str),(void *)(s),(uint64_t)(length));
    str[((length + (int64_t)1))-1] = (uint64_t)0u;
    return str;
}

struct var_decls_strec * qc_lex_addnamestr(uint8_t * name) {
    struct qc_lex_lexrec oldlx;
    oldlx = qc_lex_nextlx;
    qc_lex_nextlx.hashvalue = qc_lex_gethashvaluez(name);
    qc_lex_nextlx.length = (int64_t)(strlen((int8_t *)(name)));
    qc_lex_nextlx.svalue = (uint8_t *)(mlib_pcm_alloc(((int64_t)(qc_lex_nextlx.length) + (int64_t)1)));
    memcpy((void *)(qc_lex_nextlx.svalue),(void *)(name),(uint64_t)(((int64_t)(qc_lex_nextlx.length) + (int64_t)1)));
    qc_lex_lookup();
    qc_lex_nextlx = oldlx;
    return qc_lex_lxsymptr;
}

void qc_lex_ps1(uint8_t * caption) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((uint8_t*)":::",NULL);
    msysnewc_m_print_end();
    ;
    qc_lex_printsymbol(&qc_lex_lx);
}

void qc_lex_ps2(uint8_t * caption) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"\t",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((uint8_t*)":##",NULL);
    msysnewc_m_print_end();
    ;
    qc_lex_printsymbol(&qc_lex_nextlx);
}

void qc_lex_ps(uint8_t * caption) {
    qc_lex_ps1(caption);
    qc_lex_ps2(caption);
}

void qc_lex_lex(void) {
    int64_t n;
    uint8_t *  p;
    qc_lex_lx = qc_lex_nextlx;
    //reenter:
L1037 :;
;
    qc_lex_lexreadtoken();
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)45)) {
        (*((*qc_lex_lx.symptr).name + (int64_t)(qc_lex_lx.length))) = (uint64_t)0u;
    };
    switch ((int64_t)(qc_lex_nextlx.symbol)) {
    case 32:;
    {
        if (((int64_t)(qc_lex_lx.symbol)==(int64_t)5) || ((int64_t)(qc_lex_lx.symbol)==(int64_t)14) || ((int64_t)(qc_lex_lx.symbol)==(int64_t)12)) {
            goto L1037 ;
;
        }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)6)) {
            goto L1037 ;
;
        } else {
            qc_lex_nextlx.symbol = (int64_t)6;
        };
    }break;
    case 34:;
    {
        if (!(!!(qc_lex_lookup()))) {
            qc_lex_nextlx.symbol = (int64_t)45;
            qc_lex_nextlx.symptr = qc_lex_lxsymptr;
            return;
        };
        qc_lex_nextlx.symbol = (int64_t)((*qc_lex_lxsymptr).symbol);
        qc_lex_nextlx.subcode = (int64_t)((*qc_lex_lxsymptr).subcode);
        switch ((int64_t)(qc_lex_nextlx.symbol)) {
        case 47:;
        {
            qc_lex_stackmacro((*qc_lex_lxsymptr).macrovalue);
            goto L1037 ;
;
        }break;
        case 46:;
        {
            if (!(!!(qc_lex_dolexdirective((int64_t)(qc_lex_nextlx.subcode))))) {
                goto L1037 ;
;
            };
        }break;
        case 34:;
        {
            if ((((int64_t)(qc_lex_nextlx.subcode) == (int64_t)44) && (((int64_t)(qc_lex_lx.symbol) == (int64_t)37) || ((int64_t)(qc_lex_lx.symbol) == (int64_t)39)))) {
                if (((int64_t)(qc_lex_lx.symbol)==(int64_t)37)) {
                    if (((int64_t)((*qc_lex_lxsymptr).index)==(int64_t)2)) {
                        qc_lex_lx.value *= (int64_t)1000000;
                    }else if (((int64_t)((*qc_lex_lxsymptr).index)==(int64_t)3)) {
                        qc_lex_lx.value *= (int64_t)1000000000;
                    }else if (((int64_t)((*qc_lex_lxsymptr).index)==(int64_t)1)) {
                        qc_lex_lx.value *= (int64_t)1000;
                    }else if (((int64_t)((*qc_lex_lxsymptr).index)==(int64_t)4)) {
                        qc_lex_lx.value *= (int64_t)1024;
                    }else if (((int64_t)((*qc_lex_lxsymptr).index)==(int64_t)5)) {
                        qc_lex_lx.value *= (int64_t)1048576;
                    }else if (((int64_t)((*qc_lex_lxsymptr).index)==(int64_t)6)) {
                        qc_lex_lx.value *= (int64_t)1073741824;
                    } else {
                        qc_lex_lxerror((uint8_t*)"Can't do this unit index");
                    };
                } else {
                    qc_lex_lxerror((uint8_t*)"Unit suffix after float not implem");
                };
                goto L1037 ;
;
            } else {
                qc_lex_nextlx.symbol = (int64_t)45;
                qc_lex_nextlx.symptr = qc_lex_lxsymptr;
            };
        }break;
        case 45:;
        {
            qc_lex_lxerror((uint8_t*)"NEXT NAME!!!");
        }break;
        case 50:;
        case 59:;
        case 75:;
        case 60:;
        case 76:;
        case 62:;
        case 63:;
        case 66:;
        case 64:;
        case 83:;
        case 84:;
        case 85:;
        case 90:;
        case 58:;
        case 86:;
        case 87:;
        case 88:;
        case 95:;
        case 67:;
        case 105:;
        case 113:;
        case 125:;
        {
            if (((int64_t)(qc_lex_lx.symbol) == (int64_t)57)) {
                qc_lex_lx.subcode = (int64_t)(qc_lex_nextlx.symbol);
                goto L1037 ;
;
            };
        }break;
        case 31:;
        {
            goto L1038 ;
;
        }break;
        case 134:;
        {
            if (((int64_t)(qc_lex_nextlx.subcode)==(int64_t)1) || ((int64_t)(qc_lex_nextlx.subcode)==(int64_t)4)) {
                qc_lex_nextlx.symbol = (int64_t)37;
                qc_lex_nextlx.value = (int64_t)0;
                qc_lex_nextlx.subcode = (int64_t)1;
            }else if (((int64_t)(qc_lex_nextlx.subcode)==(int64_t)2)) {
                qc_lex_nextlx.symbol = (int64_t)39;
                qc_lex_nextlx.xvalue = (double)3.1415926535897931;
                qc_lex_nextlx.subcode = (int64_t)3;
            }else if (((int64_t)(qc_lex_nextlx.subcode)==(int64_t)3)) {
                qc_lex_nextlx.symbol = (int64_t)42;
                qc_lex_nextlx.subcode = (int64_t)5;
                qc_lex_nextlx.svalue = (uint8_t*)"\t";
                qc_lex_nextlx.length = (int64_t)1;
            } else {
                qc_lex_lxerror((uint8_t*)"sysconst?");
            };
        }break;
        default: {
        }
        } //SW
;
    }break;
    case 3:;
    {
        goto L1037 ;
;
    }break;
    case 33:;
    {
    }break;
    case 42:;
    {
        if (((int64_t)(qc_lex_lx.symbol) == (int64_t)42)) {
            n = ((int64_t)(qc_lex_nextlx.length) + (int64_t)(qc_lex_lx.length));
            p = (uint8_t *)(mlib_pcm_alloc((n + (int64_t)1)));
            memcpy((void *)(p),(void *)(qc_lex_lx.svalue),(uint64_t)(qc_lex_lx.length));
            memcpy((void *)((p + (int64_t)(qc_lex_lx.length))),(void *)(qc_lex_nextlx.svalue),(uint64_t)(qc_lex_nextlx.length));
            (*(p + n)) = (uint64_t)0u;
            qc_lex_lx.svalue = p;
            qc_lex_lx.length = n;
            goto L1037 ;
;
        };
    }break;
    case 31:;
    {
        //doopsym:
L1038 :;
;
        if (((((int64_t)(qc_lex_nextlx.subcode) == (int64_t)119) && ((int64_t)(qc_lex_lx.symbol) == (int64_t)31)) && ((int64_t)(qc_lex_lx.subcode) == (int64_t)77))) {
            qc_lex_lx.subcode = (int64_t)120;
            goto L1037 ;
;
        };
    }break;
    default: {
    }
    } //SW
;
}

void qc_lex_showhashtablesize(void) {
    int64_t i;
    int64_t n;
    n = (int64_t)0;
    L1039 :;
    for (i=(int64_t)0;i<=(int64_t)32767;i+=(int64_t)1) {
L1040 :;
        if (!!(qc_lex_hashtable[(i)].name)) {
            ++n;
        };
L1041 :;
    }L1042 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"FINAL HASHTABLE",NULL);
    msysnewc_m_print_i64(n,NULL);
    msysnewc_m_print_i64((int64_t)32768,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static void qc_lex_addmacro(struct var_decls_strec * symptr,uint8_t * value,int64_t length) {
    uint8_t *  s;
    int64_t i;
    s = value;
    L1043 :;
    for (i=(int64_t)1;i<=length;i+=(int64_t)1) {
L1044 :;
        if (((int64_t)((*s))==(int64_t)34)) {
        }else if (((int64_t)((*s))==(int64_t)35) || ((int64_t)((*s))==(int64_t)33)) {
            length = (i - (int64_t)1);
            if ((length == (int64_t)0)) {
                qc_lex_lxerror((uint8_t*)"Null macro");
            };
            goto L1046 ;
        };
        ++s;
L1045 :;
    }L1046 :;
    ;
    (*symptr).symbol = (uint64_t)((int64_t)47);
    (*((*symptr).name + (int64_t)((*symptr).namelen))) = (uint64_t)0u;
    s = (uint8_t *)(mlib_pcm_alloc((length + (int64_t)2)));
    memcpy((void *)(s),(void *)(value),(uint64_t)(length));
    (*((s + length) + (int64_t)1)) = (uint64_t)26u;
    (*((s + length) + (int64_t)2)) = (uint64_t)0u;
    (*symptr).macrovalue = s;
}

static void qc_lex_stackmacro(uint8_t * s) {
    if ((qc_lex_macrolevel >= (int64_t)10)) {
        qc_lex_lxerror((uint8_t*)"Too many nested macros");
    };
    ++qc_lex_macrolevel;
    qc_lex_macrostack[(qc_lex_macrolevel)-1] = qc_lex_lxsptr;
    qc_lex_lxsptr = (byte *)(mlib_pcm_copyheapstring(s));
}

static void qc_lex_unstackmacro(void) {
    if ((qc_lex_macrolevel <= (int64_t)0)) {
        qc_lex_lxerror((uint8_t*)"unstack macro?");
    };
    qc_lex_lxsptr = qc_lex_macrostack[(qc_lex_macrolevel--)-1];
}

int64_t qc_parse_parsemodule(int64_t n) {
    struct var_decls_modulerec m;
    struct var_decls_strec *  owner;
    int64_t status;
    qc_parse_initparser();
    m = var_decls_moduletable[(n)];
    if (!!(var_decls_fverbose)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"Parsing::",NULL);
        msysnewc_m_print_str(m.name,NULL);
        msysnewc_m_print_i64(n,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    var_decls_stmodule = var_decls_moduletable[(n)].stmodule;
    qc_lex_startlex((uint8_t*)"PARSEMODULE",m.sourcecode);
    owner = var_decls_stmodule;
    qc_lex_lex();
    status = qc_parse_readmoduledefs(owner);
    if (!(!!(status))) {
        return (int64_t)0;
    };
    var_decls_alllines += (int64_t)(qc_lex_lx.lineno);
    return status;
}

int64_t qc_parse_readmoduledefs(struct var_decls_strec * owner) {
    int64_t globalflag;
    int64_t i;
    int64_t found;
    globalflag = (int64_t)0;
    L1047 :;
    while (1) {
        switch ((int64_t)(qc_lex_lx.symbol)) {
        case 110:;
        {
            if (!!(globalflag)) {
                qc_support_serror((uint8_t*)"global global?");
            };
            globalflag = (int64_t)1;
            qc_lex_lex();
        }break;
        case 83:;
        case 84:;
        case 85:;
        {
            qc_parse_readprocdef(owner,globalflag,(int64_t)0);
            globalflag = (int64_t)0;
        }break;
        case 100:;
        {
            qc_parse_readvardef(owner,globalflag,(int64_t)0,(int64_t)10);
            globalflag = (int64_t)0;
        }break;
        case 90:;
        {
            qc_parse_readimportmodule(owner);
        }break;
        case 95:;
        {
            qc_parse_readtypedef(owner,globalflag);
            globalflag = (int64_t)0;
        }break;
        case 99:;
        {
            qc_parse_readconstdef(owner,globalflag);
            globalflag = (int64_t)0;
        }break;
        case 105:;
        case 86:;
        {
            qc_parse_readclassdef(owner,globalflag);
            globalflag = (int64_t)0;
        }break;
        case 103:;
        {
            qc_lex_lex();
            qc_parse_readenumtype(owner,(int64_t)0,(int64_t)0);
        }break;
        case 125:;
        {
            qc_parse_readtabledef(owner,globalflag);
            globalflag = (int64_t)0;
        }break;
        case 35:;
        {
            mlib_gs_strn(var_decls_docstring,qc_lex_lx.svalue,(int64_t)(qc_lex_lx.length));
            mlib_gs_line(var_decls_docstring);
            qc_lex_lex();
        }break;
        case 89:;
        {
            if (!!(globalflag)) {
                qc_support_serror((uint8_t*)"glob/import?");
            };
            qc_lex_lex();
            if ((((int64_t)(qc_lex_lx.symbol) == (int64_t)31) && ((int64_t)(qc_lex_lx.subcode) == (int64_t)107))) {
                qc_lex_lex();
            };
            qc_parse_checksymbol((int64_t)45);
            found = (int64_t)0;
            L1049 :;
            for (i=(int64_t)1;i<=var_decls_nmodules;i+=(int64_t)1) {
L1050 :;
                if (!!(mlib_eqstring((*qc_lex_lx.symptr).name,var_decls_moduletable[(i)].name))) {
                    found = (int64_t)1;
                    goto L1052 ;
                };
L1051 :;
            }L1052 :;
            ;
            if (!(!!(found))) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((*qc_lex_lx.symptr).name,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                qc_support_serror((uint8_t*)"Import stmt out of position?");
            };
            qc_lex_lex();
        }break;
        case 91:;
        {
            qc_lex_lex();
            qc_parse_checksymbol((int64_t)42);
            qc_lex_lex();
        }break;
        case 93:;
        {
            qc_parse_readapplprocs(owner);
        }break;
        case 132:;
        {
            if (((int64_t)(qc_lex_lx.subcode)==(int64_t)1)) {
                if (!!(osnos_os_iswindows())) {
                    qc_lex_lex();
                } else {
                    //skiptoeol:
L1053 :;
;
                    L1054 :;
                    do {
                        qc_lex_lex();
L1055 :;
                    } while (!(((int64_t)(qc_lex_lx.symbol) == (int64_t)6) || ((int64_t)(qc_lex_lx.symbol) == (int64_t)33)));L1056 :;
                    ;
                };
            }else if (((int64_t)(qc_lex_lx.subcode)==(int64_t)2)) {
                if (!(!!(osnos_os_iswindows()))) {
                    qc_lex_lex();
                } else {
                    goto L1053 ;
;
                };
            } else {
                qc_support_serror((uint8_t*)"condcomp");
            };
        }break;
        case 6:;
        {
            qc_lex_lex();
        }break;
        case 33:;
        {
            goto L1048 ;
        }break;
        default: {
            qc_lex_ps1((uint8_t*)"symbol");
            qc_support_serror((uint8_t*)"Not allowed at module level");
        }
        } //SW
;
    }L1048 :;
    ;
    return (int64_t)1;
}

static void qc_parse_initparser(void) {
    uint8_t *  tabledataname;
    if (!(!!(var_decls_nullunit))) {
        var_decls_nullunit = qc_lib_createunit0((int64_t)2);
    };
    qc_parse_try_level = (int64_t)0;
    var_decls_currproc = (struct var_decls_strec *)(0);
    qc_parse_varattribs = (int64_t)0;
    qc_parse_intabledata = (int64_t)0;
    qc_parse_inreadprint = (int64_t)0;
    qc_parse_inparamlist = (int64_t)0;
    qc_parse_inrecordbody = (int64_t)0;
    qc_parse_inimportmodule = (int64_t)0;
    tabledataname = (uint8_t*)"";
    qc_parse_labelseen = (int64_t)0;
    qc_parse_currimport = (struct var_decls_strec *)(0);
    qc_parse_ndollar = (int64_t)0;
    mlib_gs_init(var_decls_docstring);
}

static void qc_parse_skipsemi(void) {
    L1057 :;
    while (((int64_t)(qc_lex_lx.symbol) == (int64_t)6)) {
        qc_lex_lex();
L1058 :;
    }L1059 :;
    ;
}

static void qc_parse_addalias(struct var_decls_strec * stold,struct var_decls_strec * stnew) {
    stnew = qc_lib_getduplnameptr((*stold).owner,stnew,(int64_t)18);
    qc_lib_adddef((*stold).owner,stnew);
    (*stnew).equiv = stold;
}

static struct var_decls_unitrec * qc_parse_makeblock(struct var_decls_unitrec * p) {
    return qc_lib_createunit1((int64_t)4,p);
}

static void qc_parse_checkequals(void) {
    if (!((((int64_t)(qc_lex_lx.symbol) == (int64_t)31) && ((int64_t)(qc_lex_lx.subcode) == (int64_t)98)))) {
        qc_support_serror((uint8_t*)"\"=\" expected");
    };
}

static int64_t qc_parse_getcurrline(void) {
    return (int64_t)(qc_lex_lx.lineno);
}

static int64_t qc_parse_checkbegin(int64_t fbrack) {
    int64_t closesym;
    qc_parse_skipsemi();
    if ((((int64_t)(qc_lex_lx.symbol) == (int64_t)12) && !!(fbrack))) {
        closesym = (int64_t)13;
        qc_lex_lex();
    } else if (((int64_t)(qc_lex_lx.symbol) == (int64_t)112)) {
        closesym = (int64_t)57;
        qc_lex_lex();
    } else if (((int64_t)(qc_lex_lx.symbol) == (int64_t)16)) {
        closesym = (int64_t)17;
        qc_lex_lex();
    } else {
        closesym = (int64_t)57;
    };
    return closesym;
}

static void qc_parse_checkbeginend(int64_t closesym,int64_t kwd,int64_t startline) {
    qc_parse_skipsemi();
    if (((closesym == (int64_t)13) || (closesym == (int64_t)17))) {
        qc_parse_checksymbol(closesym);
    } else {
        qc_parse_checkend(closesym,kwd,startline,(int64_t)0);
    };
    qc_lex_lex();
}

static void qc_parse_checkend(int64_t endsym,int64_t endkwd1,int64_t endkwd2,int64_t startline) {
    uint8_t str[100];
    if (((endsym == (int64_t)(qc_lex_lx.symbol)) && ((int64_t)(qc_lex_lx.symbol) == (int64_t)13))) {
        return;
    };
    if (((int64_t)(qc_lex_lx.symbol) != (int64_t)57)) {
        strcpy((int8_t *)(str),(int8_t *)((uint8_t*)"Bad 'end' "));
        //error:
L1060 :;
;
        if (!!(startline)) {
            msysnewc_m_print_startstr((str + (int64_t)(strlen((int8_t *)(str)))));
            msysnewc_m_print_setfmt((uint8_t*)" (from line #)");
            msysnewc_m_print_i64(startline,NULL);
            msysnewc_m_print_end();
            ;
        };
        qc_support_serror(str);
    };
    if (((int64_t)(qc_lex_lx.subcode) == (int64_t)0)) {
        return;
    };
    if (!(((!!(endkwd1) && (endkwd1 == (int64_t)(qc_lex_lx.subcode))) || (!!(endkwd2) && (endkwd2 == (int64_t)(qc_lex_lx.subcode)))))) {
        strcpy((int8_t *)(str),(int8_t *)((uint8_t*)"Mismatched 'end'"));
        goto L1060 ;
;
    };
}

static void qc_parse_addgenfield(struct var_decls_strec * d) {
    if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)14)) {
        return;
    };
    if ((var_decls_ngenfieldnames >= (int64_t)1000)) {
        qc_support_serror((uint8_t*)"Too many genfields");
    };
    (*d).nameid = (uint64_t)((int64_t)14);
    var_decls_genfieldnames[(++var_decls_ngenfieldnames)-1].def = d;
    (*d).offset = var_decls_ngenfieldnames;
}

static void qc_parse_readvardef(struct var_decls_strec * owner,int64_t isglobal,int64_t isstatic,int64_t varid) {
    int64_t nvars;
    int64_t m;
    struct var_decls_strec *  stname;
    qc_lex_lex();
    m = (int64_t)35;
    nvars = (int64_t)0;
    L1061 :;
    while (((int64_t)(qc_lex_lx.symbol) == (int64_t)45)) {
        ++nvars;
        stname = qc_lib_getduplnameptr(owner,qc_lex_lx.symptr,varid);
        (*stname).mode = m;
        (*stname).attribs.ax_global = (uint64_t)(isglobal);
        (*stname).attribs.ax_static = (uint64_t)(isstatic);
        qc_lib_adddef(owner,stname);
        qc_lex_lex();
        if ((((int64_t)(qc_lex_lx.symbol) == (int64_t)9) || (((int64_t)(qc_lex_lx.symbol) == (int64_t)31) && ((int64_t)(qc_lex_lx.subcode) == (int64_t)98)))) {
            if (((int64_t)(qc_lex_lx.symbol) == (int64_t)9)) {
                if ((varid == (int64_t)10)) {
                    qc_support_serror((uint8_t*)"Need = on static not :=");
                };
            } else {
                if ((varid == (int64_t)11)) {
                    (*stname).nameid = (uint64_t)((int64_t)10);
                    (*stname).attribs.ax_frame = (uint64_t)((int64_t)0);
                };
            };
            qc_lex_lex();
            (*stname).code = qc_parse_readexpression();
            (*stname).attribs.ax_equals = (uint64_t)((int64_t)1);
        };
        if (((int64_t)(qc_lex_lx.symbol) != (int64_t)5)) {
            goto L1063 ;
        };
        qc_lex_lex();
L1062 :;
    }L1063 :;
    ;
    if ((nvars == (int64_t)0)) {
        qc_support_serror((uint8_t*)"No vars declared");
    };
}

static void qc_parse_readconstdef(struct var_decls_strec * owner,int64_t isglobal) {
    int64_t nconsts;
    int64_t deft;
    int64_t t;
    struct var_decls_strec *  stname;
    qc_lex_lex();
    deft = (int64_t)0;
    nconsts = (int64_t)0;
    L1064 :;
    while (((int64_t)(qc_lex_lx.symbol) == (int64_t)45)) {
        stname = qc_lib_getduplnameptr(owner,qc_lex_lx.symptr,(int64_t)9);
        qc_lex_lex();
        qc_parse_checkequals();
        qc_lex_lex();
        (*stname).code = qc_parse_readconstexpr(owner,(int64_t)1);
        if ((deft == (int64_t)0)) {
            t = (int64_t)((*(*stname).code).mode);
        } else {
            t = deft;
        };
        (*stname).mode = t;
        ++nconsts;
        (*stname).attribs.ax_global = (uint64_t)(isglobal);
        qc_lib_adddef(owner,stname);
        if (((int64_t)(qc_lex_lx.symbol) != (int64_t)5)) {
            goto L1066 ;
        };
        qc_lex_lex();
L1065 :;
    }L1066 :;
    ;
    if ((nconsts == (int64_t)0)) {
        qc_support_serror((uint8_t*)"No consts declared");
    };
}

static struct var_decls_unitrec * qc_parse_readexpression(void) {
    return qc_parse_readfactor((int64_t)8);
}

static struct var_decls_unitrec * qc_parse_readfactor(int64_t level) {
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  q;
    struct var_decls_unitrec *  r;
    int64_t opc;
    int64_t opprio;
    int64_t lineno;
    if ((level <= (int64_t)1)) {
        p = qc_parse_readterm();
    } else {
        p = qc_parse_readfactor((level - (int64_t)1));
    };
    L1067 :;
    switch ((int64_t)(qc_lex_lx.symbol)) {
    case 31:;
    case 9:;
    case 29:;
    case 24:;
    case 10:;
    {
        opc = (int64_t)(qc_lex_lx.subcode);
        opprio = (int64_t)(qc_tables_jtagpriotable[(opc)]);
        lineno = (int64_t)(qc_lex_lx.lineno);
        if ((opprio != level)) {
            goto L1068 ;
        };
        qc_lex_lex();
        if (((opc == (int64_t)88) || (opc == (int64_t)89))) {
            q = qc_parse_readexpression();
        } else if ((opc == (int64_t)145)) {
            q = qc_parse_readfactor(level);
        } else {
            q = qc_parse_readfactor((level - (int64_t)1));
        };
        p = qc_lib_createunit2(opc,(r = p),q);
        (*p).lineno = lineno;
    }break;
    default: {
        goto L1068 ;
    }
    } //SW
goto L1067 ;
L1068 :;
    ;
    return p;
}

static struct var_decls_unitrec * qc_parse_readterm(void) {
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  q;
    struct var_decls_unitrec *  r;
    uint8_t *  pbyte;
    uint64_t a;
    int64_t oldipl;
    int64_t opc;
    int64_t oldinrp;
    int64_t lineno;
    int64_t shift;
    int64_t av_1;
    lineno = (int64_t)(qc_lex_lx.lineno);
    switch ((int64_t)(qc_lex_lx.symbol)) {
    case 45:;
    {
        p = qc_lib_createname(qc_lex_lx.symptr);
        (*p).lineno = (int64_t)(qc_lex_lx.lineno);
        if (((int64_t)(qc_lex_nextlx.symbol) == (int64_t)12)) {
            (*p).def = qc_lex_lx.symptr;
        };
        qc_lex_lex();
    }break;
    case 37:;
    case 39:;
    {
        p = qc_lib_createconstunit((uint64_t)(qc_lex_lx.value),(int64_t)(qc_lex_lx.subcode));
        qc_lex_lex();
    }break;
    case 42:;
    {
        p = qc_lib_createstringconstunit(qc_lex_lx.svalue,(int64_t)(qc_lex_lx.length));
        (*p).slength = (int64_t)(qc_lex_lx.length);
        qc_lex_lex();
    }break;
    case 38:;
    {
        (*(qc_lex_lx.svalue + (int64_t)(qc_lex_lx.length))) = (uint64_t)0u;
        p = qc_lib_createunit0((int64_t)9);
        (*p).svalue = qc_lex_lx.svalue;
        (*p).slength = (int64_t)(qc_lex_lx.length);
        qc_lex_lex();
    }break;
    case 40:;
    {
        a = (uint64_t)((int64_t)0);
        shift = (int64_t)0;
        pbyte = qc_lex_lx.svalue;
        av_1 = (int64_t)(qc_lex_lx.length);
        while (av_1-- > 0) {
L1069 :;
            a = (a | ((uint64_t)((*pbyte)) << shift));
            shift += (int64_t)8;
            ++pbyte;
L1070 :;
        }L1071 :;
        ;
        p = qc_lib_createconstunit(a,(int64_t)1);
        qc_lex_lex();
    }break;
    case 12:;
    {
        p = qc_parse_readlbrack();
    }break;
    case 14:;
    {
        oldipl = qc_parse_inparamlist;
        qc_parse_inparamlist = (int64_t)0;
        p = qc_parse_readlsqbrack();
        qc_parse_inparamlist = oldipl;
    }break;
    case 48:;
    case 97:;
    {
        p = qc_parse_readcast();
    }break;
    case 31:;
    {
        p = qc_parse_readopc();
    }break;
    case 36:;
    {
        opc = (int64_t)(qc_lex_lx.subcode);
        qc_lex_lex();
        p = qc_lib_createunit1(opc,qc_parse_readterm());
    }break;
    case 78:;
    {
        p = qc_parse_readsprint();
    }break;
    case 80:;
    case 81:;
    {
        p = qc_parse_readsread();
    }break;
    case 18:;
    case 24:;
    {
        opc = (int64_t)(qc_lex_lx.subcode);
        qc_lex_lex();
        p = qc_lib_createunit1(opc,qc_parse_readterm());
        if (((int64_t)((*(*p).a).tag) == (int64_t)90)) {
            if (!!((*(*p).a).b)) {
                qc_support_serror((uint8_t*)"Params not allowed");
            };
            (*p).a = (*(*p).a).a;
        };
    }break;
    case 122:;
    {
        p = qc_parse_readcompilervar();
        qc_lex_lex();
    }break;
    case 133:;
    {
        p = qc_lib_createconstunit((uint64_t)(qc_lex_lx.subcode),(int64_t)1);
        qc_lex_lex();
    }break;
    case 123:;
    {
        if (!!(qc_parse_intabledata)) {
            p = qc_lib_createstringconstunit(qc_parse_tabledataname,(int64_t)-1);
        } else {
            if ((qc_parse_ndollar <= (int64_t)0)) {
                qc_support_serror((uint8_t*)"[$] No array");
            };
            p = qc_lib_createunit1((int64_t)181,qc_parse_dollarstack[(qc_parse_ndollar)-1]);
        };
        qc_lex_lex();
    }break;
    case 127:;
    {
        p = qc_parse_readapplyop((int64_t)1);
    }break;
    case 120:;
    {
        p = qc_parse_readcastx();
    }break;
    case 121:;
    {
        qc_lex_lex();
        qc_parse_checksymbol((int64_t)12);
        qc_lex_lex();
        p = qc_lib_createunit0((int64_t)151);
        (*p).mode = qc_parse_readtypespec((struct var_decls_strec *)(0),(int64_t)0);
        qc_parse_checksymbol((int64_t)13);
        qc_lex_lex();
    }break;
    case 130:;
    {
        qc_lex_lex();
        qc_parse_checksymbol((int64_t)12);
        qc_lex_lex();
        p = qc_parse_readexpression();
        qc_parse_checksymbol((int64_t)5);
        qc_lex_lex();
        q = qc_parse_readexpression();
        if ((((int64_t)(qc_lex_lx.symbol) == (int64_t)13) && ((int64_t)((*q).tag) == (int64_t)82))) {
            r = (*q).b;
            q = (*q).a;
        } else {
            qc_parse_checksymbol((int64_t)5);
            qc_lex_lex();
            r = qc_parse_readexpression();
            qc_parse_checksymbol((int64_t)13);
        };
        qc_lex_lex();
        p = qc_lib_createunit3((int64_t)128,p,q,r);
    }break;
    case 82:;
    {
        p = qc_parse_readhostparams((struct var_decls_unitrec *)(0),(int64_t)1);
    }break;
    case 94:;
    {
        p = qc_parse_readapplcall();
    }break;
    default: {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(qc_tables_symbolnames[((int64_t)(qc_lex_lx.symbol))-1],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        qc_support_serror((uint8_t*)"readterm?");
    }
    } //SW
;
    L1072 :;
    switch ((int64_t)(qc_lex_lx.symbol)) {
    case 12:;
    {
        qc_lex_lex();
        oldinrp = qc_parse_inreadprint;
        qc_parse_inreadprint = (int64_t)0;
        q = qc_parse_readslist((int64_t)1,(int64_t)1);
        qc_parse_checksymbol((int64_t)13);
        qc_lex_lex();
        if (((int64_t)((*p).tag) == (int64_t)68)) {
            (*p).b = q;
        } else {
            p = qc_lib_createunit2((int64_t)90,p,q);
            p = qc_parse_testconstruct(p);
        };
        qc_parse_inreadprint = oldinrp;
    }break;
    case 18:;
    {
        p = qc_lib_createunit1((int64_t)146,p);
        qc_lex_lex();
    }break;
    case 14:;
    {
        p = qc_parse_readindex(p,(int64_t)0);
    }break;
    case 16:;
    {
        p = qc_parse_readkeyindex(p,(int64_t)0);
    }break;
    case 2:;
    {
        p = qc_parse_readdotsuffix(p);
    }break;
    case 7:;
    {
        if (!!(qc_parse_inreadprint)) {
            goto L1073 ;
        };
        qc_lex_lex();
        q = qc_parse_readexpression();
        p = qc_lib_createunit2((!!(qc_parse_inparamlist)?(int64_t)86:(int64_t)87),p,q);
    }break;
    case 36:;
    {
        if (((int64_t)(qc_lex_lx.subcode)==(int64_t)209)) {
            opc = (int64_t)211;
        }else if (((int64_t)(qc_lex_lx.subcode)==(int64_t)210)) {
            opc = (int64_t)212;
        };
        qc_lex_lex();
        p = qc_lib_createunit1(opc,p);
    }break;
    case 4:;
    {
        qc_lex_lex();
        qc_parse_checksymbol((int64_t)14);
        qc_lex_lex();
        q = qc_parse_readexpression();
        if (((int64_t)((*q).tag) == (int64_t)82)) {
            p = qc_lib_createunit2((int64_t)139,p,q);
        } else {
            p = qc_lib_createunit2((int64_t)138,p,q);
        };
        qc_parse_checksymbol((int64_t)15);
        qc_lex_lex();
    }break;
    case 31:;
    {
        if (((int64_t)(qc_lex_lx.subcode)==(int64_t)162)) {
            p = qc_lib_createunit1((int64_t)162,p);
            qc_lex_lex();
        } else {
            goto L1073 ;
        };
    }break;
    default: {
        goto L1073 ;
    }
    } //SW
goto L1072 ;
L1073 :;
    ;
    (*p).lineno = lineno;
    return p;
}

static struct var_decls_unitrec * qc_parse_readlbrack(void) {
    struct var_decls_unitrec *  plower;
    struct var_decls_unitrec *  ulist;
    struct var_decls_unitrec *  ulistx;
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  q;
    struct var_decls_unitrec *  r;
    int64_t lcmode;
    int64_t oldirp;
    qc_lex_lex();
    plower = (struct var_decls_unitrec *)(0);
    lcmode = (int64_t)29;
    ulist = (ulistx = (struct var_decls_unitrec *)(0));
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)21)) {
        qc_lex_lex();
        oldirp = qc_parse_inreadprint;
        qc_parse_inreadprint = (int64_t)1;
        plower = qc_parse_readexpression();
        qc_parse_inreadprint = oldirp;
        qc_parse_checksymbol((int64_t)7);
        qc_lex_lex();
    } else if ((((int64_t)(qc_lex_lx.symbol) == (int64_t)37) && ((int64_t)(qc_lex_nextlx.symbol) == (int64_t)7))) {
        plower = qc_lib_createconstunit((uint64_t)(qc_lex_lx.value),(int64_t)(qc_lex_lx.subcode));
        qc_lex_lex();
        qc_lex_lex();
    } else if ((((int64_t)(qc_lex_lx.symbol) == (int64_t)31) && ((int64_t)(qc_lex_nextlx.symbol) == (int64_t)13))) {
        p = qc_lib_createunit0((int64_t)152);
        (*p).opcode = (int64_t)(qc_lex_lx.subcode);
        qc_lex_lex();
        qc_lex_lex();
        return p;
    } else if ((((int64_t)(qc_lex_lx.symbol) == (int64_t)31) && ((int64_t)(qc_lex_nextlx.symbol) == (int64_t)9))) {
        p = qc_lib_createunit0((int64_t)152);
        (*p).opcode = qc_lib_getoptocode((int64_t)(qc_lex_lx.subcode));
        qc_lex_lex();
        qc_lex_lex();
        qc_parse_checksymbol((int64_t)13);
        qc_lex_lex();
        return p;
    } else if ((((int64_t)(qc_lex_lx.symbol) == (int64_t)95) && ((int64_t)(qc_lex_nextlx.symbol) == (int64_t)13))) {
        p = qc_lib_createunit0((int64_t)152);
        (*p).opcode = (int64_t)187;
        qc_lex_lex();
        qc_lex_lex();
        return p;
    };
    if (((int64_t)(qc_lex_lx.symbol)==(int64_t)13)) {
        qc_lex_lex();
        p = qc_lib_createunit0((int64_t)79);
        if ((plower != 0)) {
            (*p).b = plower;
        };
        return p;
    } else {
        p = qc_parse_readexpression();
    };
    if (((int64_t)(qc_lex_lx.symbol)==(int64_t)13)) {
        qc_lex_lex();
        if (!!(plower)) {
            return qc_lib_createunit2((int64_t)87,plower,p);
        } else {
            return p;
        };
    }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)6)) {
        ulist = (ulistx = p);
        L1074 :;
        do {
            qc_lex_lex();
            qc_parse_addlistunit(&ulist,&ulistx,qc_parse_readexpression());
L1075 :;
        } while (!((int64_t)(qc_lex_lx.symbol) != (int64_t)6));L1076 :;
        ;
        qc_parse_checksymbol((int64_t)13);
        qc_lex_lex();
        p = ulist;
        L1077 :;
        while (!!(p)) {
            if (((int64_t)((*p).tag)==(int64_t)88)) {
                (*p).tag = (int64_t)17;
            }else if (((int64_t)((*p).tag)==(int64_t)89)) {
                (*p).tag = (int64_t)19;
            }else if (((int64_t)((*p).tag)==(int64_t)209)) {
                (*p).tag = (int64_t)231;
            }else if (((int64_t)((*p).tag)==(int64_t)210)) {
                (*p).tag = (int64_t)232;
            }else if (((int64_t)((*p).tag)==(int64_t)211)) {
                (*p).tag = (int64_t)233;
            }else if (((int64_t)((*p).tag)==(int64_t)212)) {
                (*p).tag = (int64_t)234;
            }else if (((int64_t)((*p).tag)==(int64_t)90)) {
                (*p).tag = (int64_t)14;
            }else if (((int64_t)((*p).tag)==(int64_t)68)) {
                (*p).tag = (int64_t)67;
            }else if (((int64_t)((*p).tag)==(int64_t)91)) {
                (*p).tag = (int64_t)15;
            };
            p = (*p).nextunit;
L1078 :;
        }L1079 :;
        ;
        return qc_lib_createunit1((int64_t)84,ulist);
    }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)5)) {
        if (((int64_t)(qc_lex_nextlx.symbol) == (int64_t)13)) {
            qc_lex_lex();
            qc_lex_lex();
            return qc_lib_createunit2((int64_t)79,p,plower);
        };
        ulist = (ulistx = p);
        L1080 :;
        do {
            qc_lex_lex();
            if (((int64_t)(qc_lex_lx.symbol) == (int64_t)13)) {
                goto L1082 ;
            };
            if (((int64_t)(qc_lex_lx.symbol) == (int64_t)5)) {
                qc_support_serror((uint8_t*)",, null expr not allowed");
            };
            qc_parse_addlistunit(&ulist,&ulistx,qc_parse_readexpression());
            qc_parse_skipsemi();
L1081 :;
        } while (!((int64_t)(qc_lex_lx.symbol) != (int64_t)5));L1082 :;
        ;
        qc_parse_checksymbol((int64_t)13);
        qc_lex_lex();
        return qc_lib_createunit2((int64_t)79,ulist,plower);
    }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)19)) {
        qc_lex_lex();
        q = qc_parse_readexpression();
        if (((int64_t)(qc_lex_lx.symbol) == (int64_t)19)) {
            qc_lex_lex();
            r = qc_parse_readexpression();
            qc_parse_checksymbol((int64_t)13);
            qc_lex_lex();
            return qc_lib_createunit3((int64_t)92,p,q,r);
        };
        qc_parse_addlistunit(&ulist,&ulistx,q);
        qc_parse_checksymbol((int64_t)5);
        if (((int64_t)(qc_lex_nextlx.symbol) != (int64_t)19)) {
            L1083 :;
            do {
                qc_lex_lex();
                qc_parse_addlistunit(&ulist,&ulistx,qc_parse_readexpression());
L1084 :;
            } while (!((int64_t)(qc_lex_lx.symbol) != (int64_t)5));L1085 :;
            ;
            qc_parse_checksymbol((int64_t)19);
        } else {
            qc_lex_lex();
        };
        qc_lex_lex();
        r = qc_parse_readexpression();
        qc_parse_checksymbol((int64_t)13);
        qc_lex_lex();
        return qc_lib_createunit3((int64_t)93,p,ulist,r);
    }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)20) || ((int64_t)(qc_lex_lx.symbol)==(int64_t)62) || ((int64_t)(qc_lex_lx.symbol)==(int64_t)63)) {
        qc_support_serror((uint8_t*)"READLISTCOMP");
    } else {
        qc_support_serror((uint8_t*)"(x ...");
    };
    return (struct var_decls_unitrec *)(0);
}

static void qc_parse_addlistunit(struct var_decls_unitrec * * ulist,struct var_decls_unitrec * * ulistx,struct var_decls_unitrec * p) {
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = p);
    } else {
        (*(*ulistx)).nextunit = p;
    };
    (*ulistx) = p;
}

static void qc_parse_addlistparam(struct var_decls_strec * * ulist,struct var_decls_strec * * ulistx,struct var_decls_strec * p) {
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = p);
    } else {
        (*(*ulistx)).nextparam = p;
    };
    (*ulistx) = p;
}

static struct var_decls_unitrec * qc_parse_readlsqbrack(void) {
    struct var_decls_unitrec *  ulist;
    struct var_decls_unitrec *  ulistx;
    struct var_decls_unitrec *  p;
    qc_lex_lex();
    ulist = (ulistx = (struct var_decls_unitrec *)(0));
    if (((int64_t)(qc_lex_lx.symbol)==(int64_t)15)) {
        qc_lex_lex();
        p = qc_lib_createunit1((int64_t)81,(struct var_decls_unitrec *)(0));
        if (!(!!(qc_name_checkdict(p)))) {
            qc_name_checkconstlist(p);
        };
        return p;
    }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)7)) {
        qc_lex_lex();
        qc_parse_checksymbol((int64_t)15);
        qc_lex_lex();
        p = qc_lib_createunit1((int64_t)83,(struct var_decls_unitrec *)(0));
        return p;
    };
    L1086 :;
    while (1) {
        qc_parse_addlistunit(&ulist,&ulistx,qc_parse_readexpression());
        qc_parse_skipsemi();
        if (((int64_t)(qc_lex_lx.symbol) != (int64_t)5)) {
            goto L1087 ;
        };
        qc_lex_lex();
        if (((int64_t)(qc_lex_lx.symbol) == (int64_t)15)) {
            goto L1087 ;
        };
    }L1087 :;
    ;
    qc_parse_checksymbol((int64_t)15);
    qc_lex_lex();
    p = qc_lib_createunit1((int64_t)81,ulist);
    if (!(!!(qc_name_checkdict(p)))) {
        qc_name_checkconstlist(p);
    };
    return p;
}

static struct var_decls_unitrec * qc_parse_readcast(void) {
    struct var_decls_unitrec *  p;
    int64_t t;
    int64_t opc;
    t = qc_parse_readtypespec((struct var_decls_strec *)(0),(int64_t)0);
    if (((int64_t)(qc_lex_lx.symbol)==(int64_t)21) || ((int64_t)(qc_lex_lx.symbol)==(int64_t)12)) {
    } else {
        if ((t == (int64_t)0)) {
            p = qc_lib_createunit0((int64_t)8);
        } else {
            p = qc_lib_createunit0((int64_t)151);
        };
        (*p).mode = t;
        return p;
    };
    qc_lib_checkunpackedtype(t);
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)21)) {
        qc_lex_lex();
        opc = (int64_t)150;
    } else {
        opc = (int64_t)149;
    };
    qc_parse_checksymbol((int64_t)12);
    p = qc_parse_readlbrack();
    if (((int64_t)((*p).tag) == (int64_t)79)) {
        (*p).tag = (int64_t)80;
    };
    p = qc_lib_createunit1(opc,p);
    (*p).mode = t;
    return p;
}

static struct var_decls_unitrec * qc_parse_readopc(void) {
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  q;
    int64_t opc;
    int64_t opc2;
    opc = (int64_t)(qc_lex_lx.subcode);
    qc_lex_lex();
    if ((opc==(int64_t)105)) {
        return qc_parse_readterm();
    }else if ((opc==(int64_t)106)) {
        opc = (int64_t)156;
    }else if ((opc==(int64_t)122) || (opc==(int64_t)123) || (opc==(int64_t)144) || (opc==(int64_t)126) || (opc==(int64_t)127)) {
        qc_parse_checksymbol((int64_t)12);
        qc_lex_lex();
        p = qc_parse_readexpression();
        if (((int64_t)(qc_lex_lx.symbol) == (int64_t)5)) {
            qc_lex_lex();
            q = qc_parse_readexpression();
            qc_parse_checksymbol((int64_t)13);
            qc_lex_lex();
            return qc_lib_createunit2(opc,p,q);
        } else {
            qc_parse_checksymbol((int64_t)13);
            qc_lex_lex();
            if ((opc==(int64_t)122)) {
                opc2 = (int64_t)207;
            }else if ((opc==(int64_t)123)) {
                opc2 = (int64_t)208;
            } else {
                qc_support_serror((uint8_t*)"readopc");
            };
            return qc_lib_createunit1(opc,p);
        };
    };
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)9)) {
        qc_support_serror((uint8_t*)"op:= not allowed");
    };
    p = qc_lib_createunit1(opc,qc_parse_readterm());
    return p;
}

static struct var_decls_unitrec * qc_parse_readsprint(void) {
    int64_t oldinreadprint;
    int64_t opc;
    int64_t isfprint;
    struct var_decls_unitrec *  pformat;
    struct var_decls_unitrec *  pdev;
    struct var_decls_unitrec *  printlist;
    struct var_decls_unitrec *  printlistx;
    struct var_decls_unitrec *  p;
    oldinreadprint = qc_parse_inreadprint;
    qc_parse_inreadprint = (int64_t)1;
    opc = (int64_t)(qc_lex_lx.subcode);
    qc_lex_lex();
    qc_parse_checksymbol((int64_t)12);
    qc_lex_lex();
    if ((opc==(int64_t)55) || (opc==(int64_t)52)) {
        isfprint = (int64_t)1;
    } else {
        isfprint = (int64_t)0;
    };
    printlist = (printlistx = (struct var_decls_unitrec *)(0));
    pformat = (pdev = var_decls_nullunit);
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)21)) {
        qc_lex_lex();
        pdev = qc_parse_readexpression();
        if (((int64_t)(qc_lex_lx.symbol) == (int64_t)5)) {
            qc_lex_lex();
        } else {
            goto L1088 ;
;
        };
    };
    if (!!(isfprint)) {
        pformat = qc_parse_readexpression();
        if (((int64_t)(qc_lex_lx.symbol) == (int64_t)5)) {
            qc_lex_lex();
        } else {
            goto L1088 ;
;
        };
    };
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)13)) {
        goto L1088 ;
;
    };
    L1089 :;
    while (1) {
        if (((int64_t)(qc_lex_lx.symbol) == (int64_t)5)) {
            qc_parse_addlistunit(&printlist,&printlistx,qc_lib_createunit0((int64_t)13));
        } else {
            p = qc_parse_readexpression();
            if (((int64_t)(qc_lex_lx.symbol) == (int64_t)7)) {
                qc_lex_lex();
                p = qc_lib_createunit2((int64_t)12,p,qc_parse_readexpression());
            };
            qc_parse_addlistunit(&printlist,&printlistx,p);
        };
        if (((int64_t)(qc_lex_lx.symbol) != (int64_t)5)) {
            goto L1090 ;
        };
        qc_lex_lex();
    }L1090 :;
    ;
    qc_parse_checksymbol((int64_t)13);
    //finish:
L1088 :;
;
    qc_lex_lex();
    qc_parse_inreadprint = oldinreadprint;
    if ((((opc == (int64_t)48) || (opc == (int64_t)50)) && (printlist == 0))) {
        qc_support_serror((uint8_t*)"No print items");
    };
    if (!!(isfprint)) {
        if (((int64_t)((*pformat).tag) == (int64_t)2)) {
            qc_support_serror((uint8_t*)"No fmt str");
        };
        return qc_lib_createunit3(opc,pdev,pformat,printlist);
    } else {
        return qc_lib_createunit2(opc,pdev,printlist);
    };
}

static struct var_decls_unitrec * qc_parse_readsread(void) {
    int64_t oldinreadprint;
    int64_t opc;
    struct var_decls_unitrec *  pformat;
    struct var_decls_unitrec *  pdev;
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  readlist;
    struct var_decls_unitrec *  readlistx;
    oldinreadprint = qc_parse_inreadprint;
    qc_parse_inreadprint = (int64_t)1;
    opc = (int64_t)(qc_lex_lx.subcode);
    qc_lex_lex();
    qc_parse_checksymbol((int64_t)12);
    qc_lex_lex();
    readlist = (readlistx = (struct var_decls_unitrec *)(0));
    pformat = (pdev = var_decls_nullunit);
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)21)) {
        if ((opc == (int64_t)57)) {
            qc_support_serror((uint8_t*)"@ on read");
        };
        qc_lex_lex();
        pdev = qc_parse_readexpression();
        if (((int64_t)(qc_lex_lx.symbol) == (int64_t)5)) {
            qc_lex_lex();
        } else {
            goto L1091 ;
;
        };
    };
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)13)) {
        goto L1091 ;
;
    };
    L1092 :;
    while (1) {
        p = qc_parse_readexpression();
        if (((int64_t)(qc_lex_lx.symbol) == (int64_t)7)) {
            qc_lex_lex();
            p = qc_lib_createunit2((int64_t)12,p,qc_parse_readexpression());
        };
        qc_parse_addlistunit(&readlist,&readlistx,p);
        if (((int64_t)(qc_lex_lx.symbol) != (int64_t)5)) {
            goto L1093 ;
        };
        qc_lex_lex();
    }L1093 :;
    ;
    qc_parse_checksymbol((int64_t)13);
    //finish:
L1091 :;
;
    qc_lex_lex();
    qc_parse_inreadprint = oldinreadprint;
    if (((opc == (int64_t)57) && (readlist == 0))) {
        qc_support_serror((uint8_t*)"No read items");
    };
    return qc_lib_createunit2(opc,pdev,readlist);
}

static struct var_decls_unitrec * qc_parse_readcompilervar(void) {
    uint8_t str[100];
    struct osnos_rsystemtime tm;
    static uint8_t *  monthnames[12] = {
    (uint8_t*)"Jan",
    (uint8_t*)"Feb",
    (uint8_t*)"Mar",
    (uint8_t*)"Apr",
    (uint8_t*)"May",
    (uint8_t*)"Jun",
    (uint8_t*)"Jul",
    (uint8_t*)"Aug",
    (uint8_t*)"Sep",
    (uint8_t*)"Oct",
    (uint8_t*)"Nov",
    (uint8_t*)"Dec"
};
    if (((int64_t)(qc_lex_lx.subcode)==(int64_t)235)) {
        return qc_lib_createconstunit((uint64_t)(qc_lex_lx.lineno),(int64_t)1);
    }else if (((int64_t)(qc_lex_lx.subcode)==(int64_t)236)) {
        msysnewc_getstrint((int64_t)(qc_lex_lx.lineno),str);
    }else if (((int64_t)(qc_lex_lx.subcode)==(int64_t)237)) {
        strcpy((int8_t *)(str),(int8_t *)(var_decls_moduletable[(var_decls_currmoduleno)].name));
    }else if (((int64_t)(qc_lex_lx.subcode)==(int64_t)238)) {
        strcpy((int8_t *)(str),(int8_t *)(var_decls_moduletable[(var_decls_currmoduleno)].filename));
    }else if (((int64_t)(qc_lex_lx.subcode)==(int64_t)239)) {
        strcpy((int8_t *)(str),(!!(var_decls_currproc)?(int8_t *)((*var_decls_currproc).name):(int8_t *)((uint8_t*)"<none>")));
    }else if (((int64_t)(qc_lex_lx.subcode)==(int64_t)240)) {
        osnos_os_getsystime((void *)(&tm));
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"#-#-%#");
        msysnewc_m_print_i64(tm.day,NULL);
        msysnewc_m_print_str(monthnames[(tm.month)-1],NULL);
        msysnewc_m_print_i64(tm.year,(uint8_t*)"4");
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)(qc_lex_lx.subcode)==(int64_t)241)) {
        osnos_os_getsystime((void *)(&tm));
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"#:#:#");
        msysnewc_m_print_i64(tm.hour,(uint8_t*)"2");
        msysnewc_m_print_i64(tm.minute,(uint8_t*)"z2");
        msysnewc_m_print_i64(tm.second,(uint8_t*)"z2");
        msysnewc_m_print_end();
        ;
    } else {
        qc_support_serror((uint8_t*)"compiler not impl");
    };
    return qc_lib_createstringconstunit(mlib_pcm_copyheapstring(str),(int64_t)-1);
}

static struct var_decls_unitrec * qc_parse_readcastx(void) {
    int64_t opc;
    struct var_decls_unitrec *  pexpr;
    struct var_decls_unitrec *  p;
    int64_t ptype;
    qc_lex_lex();
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)21)) {
        qc_lex_lex();
        opc = (int64_t)150;
    } else {
        opc = (int64_t)149;
    };
    qc_parse_checksymbol((int64_t)12);
    qc_lex_lex();
    pexpr = qc_parse_readexpression();
    qc_parse_checksymbol((int64_t)5);
    qc_lex_lex();
    ptype = qc_parse_readtypespec((struct var_decls_strec *)(0),(int64_t)0);
    qc_parse_checksymbol((int64_t)13);
    qc_lex_lex();
    p = qc_lib_createunit1(opc,pexpr);
    (*p).mode = ptype;
    return p;
}

void qc_parse_checksymbol(int64_t symbol) {
    uint8_t str[100];
    if (((int64_t)(qc_lex_lx.symbol) != symbol)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"# expected, not #");
        msysnewc_m_print_str(qc_tables_symbolnames[(symbol)-1],NULL);
        msysnewc_m_print_str(qc_tables_symbolnames[((int64_t)(qc_lex_lx.symbol))-1],NULL);
        msysnewc_m_print_end();
        ;
        qc_support_serror(str);
    };
}

static int64_t qc_parse_readtypespec(struct var_decls_strec * owner,int64_t typedefx) {
    struct var_decls_strec *  d;
    int64_t t;
    int64_t kwd;
    struct var_decls_unitrec *  x;
    struct var_decls_unitrec *  lowerx;
    struct var_decls_unitrec *  upperx;
    struct var_decls_unitrec *  lengthx;
    int64_t p;
    struct var_decls_unitrec *  lowerdims[10];
    struct var_decls_unitrec *  lengthdims[10];
    int64_t ndims;
    int64_t i;
    if (((int64_t)(qc_lex_lx.symbol)==(int64_t)14)) {
        //arraybounds:
L1094 :;
;
        qc_lex_lex();
        ndims = (int64_t)0;
        qc_parse_inreadprint = (int64_t)1;
        L1095 :;
        while (1) {
            lowerx = (lengthx = (struct var_decls_unitrec *)(0));
            if ((((int64_t)(qc_lex_lx.symbol) == (int64_t)15) || ((int64_t)(qc_lex_lx.symbol) == (int64_t)5))) {
            } else {
                x = qc_parse_readconstexpr(owner,(int64_t)0);
                if (((int64_t)((*x).tag) == (int64_t)82)) {
                    lowerx = (*x).a;
                    upperx = (*x).b;
                    if ((((int64_t)((*lowerx).tag) == (int64_t)1) && ((int64_t)((*upperx).tag) == (int64_t)1))) {
                        lengthx = qc_lib_createconstunit((uint64_t)((((*upperx).value - (*lowerx).value) + (int64_t)1)),(int64_t)1);
                    } else {
                        lengthx = qc_lib_createunit2((int64_t)106,upperx,lowerx);
                        lengthx = qc_lib_createunit2((int64_t)105,lengthx,qc_lib_createconstunit((uint64_t)((int64_t)1),(int64_t)1));
                    };
                } else {
                    if (((int64_t)(qc_lex_lx.symbol)==(int64_t)15) || ((int64_t)(qc_lex_lx.symbol)==(int64_t)5)) {
                        lengthx = x;
                    }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)7)) {
                        lowerx = x;
                        qc_lex_lex();
                        if (!((((int64_t)(qc_lex_lx.symbol) == (int64_t)5) || ((int64_t)(qc_lex_lx.symbol) == (int64_t)15)))) {
                            lengthx = qc_parse_readconstexpr(owner,(int64_t)1);
                        };
                    };
                };
            };
            lowerdims[(++ndims)-1] = lowerx;
            lengthdims[(ndims)-1] = lengthx;
            if (((int64_t)(qc_lex_lx.symbol) != (int64_t)5)) {
                goto L1096 ;
            };
            qc_lex_lex();
        }L1096 :;
        ;
        qc_parse_inreadprint = (int64_t)0;
        qc_parse_checksymbol((int64_t)15);
        qc_lex_lex();
        t = qc_parse_readtypespec(owner,(int64_t)0);
        qc_lib_checkpackedtype(t);
        L1097 :;
        for (i=ndims;i>=(int64_t)1;i-=(int64_t)1) {
L1098 :;
            t = qc_lib_createarraymode(owner,t,lowerdims[(i)-1],lengthdims[(i)-1],((i == (int64_t)1)?typedefx:(int64_t)0));
L1099 :;
        }L1100 :;
        ;
        return t;
    }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)48)) {
        t = (int64_t)(qc_lex_lx.subcode);
        qc_lex_lex();
        if ((t==(int64_t)5) || (t==(int64_t)9) || (t==(int64_t)21)) {
            if ((((int64_t)(qc_lex_lx.symbol) == (int64_t)31) && ((int64_t)(qc_lex_lx.subcode) == (int64_t)107))) {
                qc_lex_lex();
                p = qc_lib_createstringmode(owner,t,qc_parse_readconstexpr(owner,(int64_t)1),typedefx);
            } else {
                p = t;
            };
        } else {
            p = t;
        };
    }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)45)) {
        d = qc_lex_lx.symptr;
        qc_lex_lex();
        if (((int64_t)(qc_lex_lx.symbol) == (int64_t)2)) {
            qc_lex_lex();
            qc_parse_checksymbol((int64_t)45);
            p = qc_lib_newusertypex(d,qc_lex_lx.symptr);
            qc_lex_lex();
        } else {
            p = qc_lib_newusertypex(d,(struct var_decls_strec *)(0));
        };
    }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)100)) {
        p = (int64_t)35;
        qc_lex_lex();
    }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)103)) {
        qc_lex_lex();
        p = qc_parse_readenumtype(owner,typedefx,(int64_t)0);
    }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)12)) {
        p = qc_parse_readenumtype(owner,typedefx,(int64_t)0);
    }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)86)) {
        qc_support_serror((uint8_t*)"Use 'record name=', not 'type name=record'");
    }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)87)) {
        kwd = (int64_t)(qc_lex_lx.symbol);
        qc_lex_lex();
        if (((int64_t)(qc_lex_lx.symbol) == (int64_t)22)) {
            if ((owner == 0)) {
                qc_support_serror((uint8_t*)"record@@");
            };
            qc_lex_lex();
            qc_parse_checksymbol((int64_t)37);
            if ((qc_lex_lx.value==(int64_t)1) || (qc_lex_lx.value==(int64_t)2) || (qc_lex_lx.value==(int64_t)4) || (qc_lex_lx.value==(int64_t)8) || (qc_lex_lx.value==(int64_t)16)) {
            } else {
                qc_support_serror((uint8_t*)"record@@ bad align");
            };
            (*owner).attribs.ax_align = (uint64_t)(qc_lex_lx.value);
            qc_lex_lex();
        };
        p = qc_parse_readstructdef(owner,typedefx,kwd);
    }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)88)) {
        qc_support_serror((uint8_t*)"Top-level union not allowed");
    }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)97)) {
        qc_lex_lex();
        if (((int64_t)(qc_lex_lx.symbol)==(int64_t)83) || ((int64_t)(qc_lex_lx.symbol)==(int64_t)84) || ((int64_t)(qc_lex_lx.symbol)==(int64_t)85)) {
            qc_support_serror((uint8_t*)"CAN'T DO REF PROC");
        } else {
            t = qc_parse_readtypespec(owner,(int64_t)0);
        };
        p = qc_lib_createrefpackmode(owner,t,typedefx);
    } else {
        qc_support_serror((uint8_t*)"Bad type starter");
    };
    return p;
}

static struct var_decls_unitrec * qc_parse_readhostparams(struct var_decls_unitrec * lhs,int64_t isfn) {
    int64_t fnindex;
    int64_t oldinrp;
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  q;
    fnindex = (int64_t)(qc_lex_lx.subcode);
    qc_lex_lex();
    qc_parse_checksymbol((int64_t)12);
    qc_lex_lex();
    oldinrp = qc_parse_inreadprint;
    qc_parse_inreadprint = (int64_t)0;
    q = qc_parse_readslist((int64_t)1,(int64_t)1);
    qc_parse_checksymbol((int64_t)13);
    qc_lex_lex();
    qc_parse_inreadprint = oldinrp;
    if (!!(lhs)) {
        (*lhs).nextunit = q;
        q = lhs;
    };
    p = qc_lib_createunit1((!!(isfn)?(int64_t)94:(int64_t)66),q);
    (*p).opcode = fnindex;
    return p;
}

static struct var_decls_unitrec * qc_parse_readslist(int64_t iscall,int64_t donulls) {
    struct var_decls_unitrec *  ulist;
    struct var_decls_unitrec *  ulistx;
    int64_t oldinparamlist;
    ulist = (ulistx = (struct var_decls_unitrec *)(0));
    qc_parse_skipsemi();
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)13)) {
        return ulist;
    };
    oldinparamlist = qc_parse_inparamlist;
    qc_parse_inparamlist = iscall;
    L1101 :;
    while (1) {
        qc_parse_skipsemi();
        if (((int64_t)(qc_lex_lx.symbol)==(int64_t)5)) {
            if (!!(donulls)) {
                qc_parse_addlistunit(&ulist,&ulistx,qc_lib_createunit0((int64_t)2));
            } else {
                qc_support_serror((uint8_t*)"null comma expr not allowed");
            };
            qc_lex_lex();
        }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)13)) {
            if (!!(donulls)) {
                qc_parse_addlistunit(&ulist,&ulistx,var_decls_nullunit);
            };
            goto L1102 ;
        } else {
            qc_parse_addlistunit(&ulist,&ulistx,qc_parse_readexpression());
            if (((int64_t)(qc_lex_lx.symbol) == (int64_t)5)) {
                qc_lex_lex();
                if (((int64_t)(qc_lex_lx.symbol) == (int64_t)13)) {
                    goto L1102 ;
                };
            } else {
                if ((((int64_t)(qc_lex_lx.symbol) == (int64_t)6) && ((int64_t)(qc_lex_nextlx.symbol) == (int64_t)13))) {
                    qc_lex_lex();
                };
                goto L1102 ;
            };
        };
    }L1102 :;
    ;
    qc_parse_inparamlist = oldinparamlist;
    return ulist;
}

static struct var_decls_unitrec * qc_parse_readindex(struct var_decls_unitrec * p,int64_t dot) {
    struct var_decls_unitrec *  q;
    qc_lex_lex();
    L1103 :;
    while (1) {
        if ((qc_parse_ndollar >= (int64_t)10)) {
            qc_support_serror((uint8_t*)"Too many nested a[$]");
        };
        qc_parse_dollarstack[(++qc_parse_ndollar)-1] = p;
        q = qc_parse_readexpression();
        --qc_parse_ndollar;
        if (((int64_t)((*q).tag) == (int64_t)82)) {
            p = qc_lib_createunit2((!!(dot)?(int64_t)136:(int64_t)131),p,q);
        } else {
            p = qc_lib_createunit2((!!(dot)?(int64_t)133:(int64_t)129),p,q);
        };
        if (((int64_t)(qc_lex_lx.symbol) != (int64_t)5)) {
            goto L1104 ;
        };
        qc_lex_lex();
    }L1104 :;
    ;
    qc_parse_checksymbol((int64_t)15);
    qc_lex_lex();
    return p;
}

static struct var_decls_unitrec * qc_parse_readkeyindex(struct var_decls_unitrec * p,int64_t dot) {
    struct var_decls_unitrec *  q;
    struct var_decls_unitrec *  r;
    qc_lex_lex();
    q = qc_parse_readexpression();
    r = (struct var_decls_unitrec *)(0);
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)5)) {
        qc_lex_lex();
        r = qc_parse_readexpression();
    };
    qc_parse_checksymbol((int64_t)17);
    qc_lex_lex();
    return (p = qc_lib_createunit3((!!(dot)?(int64_t)137:(int64_t)132),p,q,r));
}

static struct var_decls_unitrec * qc_parse_readdotsuffix(struct var_decls_unitrec * p) {
    struct var_decls_unitrec *  q;
    int64_t t;
    L1105 :;
    while (((int64_t)(qc_lex_lx.symbol) == (int64_t)2)) {
        qc_lex_lex();
        switch ((int64_t)(qc_lex_lx.symbol)) {
        case 14:;
        {
            p = qc_parse_readindex(p,(int64_t)1);
        }break;
        case 16:;
        {
            p = qc_parse_readkeyindex(p,(int64_t)1);
        }break;
        case 45:;
        {
            p = qc_lib_createunit2((int64_t)141,p,qc_lib_createname(qc_lex_lx.symptr));
            qc_lex_lex();
        }break;
        case 31:;
        {
            p = qc_lib_createunit1((int64_t)(qc_lex_lx.subcode),p);
            qc_lex_lex();
        }break;
        case 12:;
        {
            qc_lex_lex();
            p = qc_lib_createunit2((int64_t)143,p,qc_parse_readexpression());
            qc_parse_checksymbol((int64_t)13);
            qc_lex_lex();
        }break;
        case 95:;
        {
            if (((int64_t)((*p).tag)==(int64_t)151)) {
            }else if (((int64_t)((*p).tag)==(int64_t)8)) {
                (*p).tag = (int64_t)151;
            } else {
                p = qc_lib_createunit1((int64_t)187,p);
            };
            qc_lex_lex();
        }break;
        case 82:;
        {
            p = qc_parse_readhostparams(p,(int64_t)1);
        }break;
        case 48:;
        {
            t = (int64_t)(qc_lex_lx.subcode);
            qc_lex_lex();
            qc_parse_checksymbol((int64_t)14);
            qc_lex_lex();
            q = qc_parse_readexpression();
            qc_parse_checksymbol((int64_t)15);
            qc_lex_lex();
            if ((t==(int64_t)44) || (t==(int64_t)45) || (t==(int64_t)46)) {
            } else {
                qc_support_serror((uint8_t*)"Bad .type[]");
            };
            p = qc_lib_createunit2((int64_t)140,p,q);
            (*p).mode = t;
        }break;
        default: {
            qc_support_serror((uint8_t*)"Unknown dot suffix");
        }
        } //SW
;
L1106 :;
    }L1107 :;
    ;
    return p;
}

int64_t qc_parse_isconstexpr(struct var_decls_unitrec * p) {
    return ((int64_t)((*p).tag) == (int64_t)1);
}

static struct var_decls_unitrec * qc_parse_readconstexpr(struct var_decls_strec * owner,int64_t needconst) {
    struct var_decls_unitrec *  p;
    p = qc_parse_readexpression();
    return p;
}

static int64_t qc_parse_readconstexprvalue(struct var_decls_strec * owner) {
    struct var_decls_unitrec *  p;
    p = qc_parse_readexpression();
    if (((int64_t)((*p).tag) != (int64_t)1)) {
        qc_support_serror((uint8_t*)"RCEV:Not const expr");
    };
    return qc_lib_getconstvalue(p,(int64_t)0);
}

static int64_t qc_parse_readconstint(void) {
    int64_t x;
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)37)) {
        x = qc_lex_lx.value;
        qc_lex_lex();
        return x;
    };
    qc_support_serror((uint8_t*)"Can't do complex expr");
    return (int64_t)0;
}

static void qc_parse_readprocdef(struct var_decls_strec * procowner,int64_t isglobal,int64_t fflang) {
    int64_t kwd;
    int64_t startline;
    int64_t closesym;
    struct var_decls_strec *  stproc;
    kwd = (int64_t)(qc_lex_lx.symbol);
    stproc = qc_parse_readprocdecl(procowner,isglobal,fflang);
    qc_parse_checkequals();
    qc_lex_lex();
    startline = qc_parse_getcurrline();
    closesym = qc_parse_checkbegin((int64_t)0);
    var_decls_currproc = stproc;
    qc_lib_nextavindex = (int64_t)0;
    (*stproc).code = qc_parse_readblock(stproc);
    if (!!((int64_t)((*var_decls_docstring).length))) {
        (*var_decls_currproc).docstring = (*var_decls_docstring).strptr;
        mlib_gs_init(var_decls_docstring);
    };
    qc_parse_checkbeginend(closesym,kwd,startline);
    (*stproc).attribs.ax_equals = (uint64_t)((int64_t)1);
    var_decls_currproc = (struct var_decls_strec *)(0);
}

struct var_decls_strec * qc_parse_readprocdecl(struct var_decls_strec * procowner,int64_t isglobal,int64_t fflang) {
    int64_t kwd;
    int64_t varparams;
    int64_t try_level;
    int64_t prettype;
    int64_t nparams;
    uint8_t *  metadata;
    uint8_t *  truename;
    struct var_decls_strec *  pequiv;
    struct var_decls_strec *  stproc;
    struct var_decls_strec *  owner;
    struct var_decls_strec *  paramlist;
    struct var_decls_strec *  nameptr;
    kwd = (int64_t)(qc_lex_lx.symbol);
    pequiv = (struct var_decls_strec *)(0);
    metadata = (uint8_t*)"";
    truename = (uint8_t *)(0);
    varparams = (int64_t)0;
    try_level = (int64_t)0;
    qc_lex_lex();
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)42)) {
        truename = mlib_pcm_copyheapstring(qc_lex_lx.svalue);
        mlib_convlcstring(qc_lex_lx.svalue);
        qc_lex_lx.symptr = qc_lex_addnamestr(qc_lex_lx.svalue);
    } else {
        qc_parse_checksymbol((int64_t)45);
    };
    nameptr = qc_lex_lx.symptr;
    stproc = qc_parse_createprocdef(procowner,nameptr,(!!(qc_parse_currimport)?(int64_t)6:(int64_t)5),truename);
    if (((qc_lib_getscope(procowner) != (int64_t)2) && ((int64_t)((uint64_t)((*procowner).nameid)) == (int64_t)4))) {
        qc_parse_addgenfield(nameptr);
    };
    owner = stproc;
    var_decls_currproc = stproc;
    qc_lex_lex();
    if ((((int64_t)(qc_lex_lx.symbol) == (int64_t)45) && !!(mlib_eqstring((*qc_lex_lx.symptr).name,(uint8_t*)"as")))) {
        qc_lex_lex();
        qc_parse_checksymbol((int64_t)45);
        qc_parse_addalias(stproc,qc_lex_lx.symptr);
        qc_lex_lex();
    };
    paramlist = (struct var_decls_strec *)(0);
    prettype = (int64_t)0;
    nparams = (int64_t)0;
    if ((((int64_t)(qc_lex_lx.symbol) == (int64_t)31) && ((int64_t)(qc_lex_lx.subcode) == (int64_t)100))) {
        if (((int64_t)((uint64_t)((*stproc).nameid)) == (int64_t)6)) {
            qc_support_serror((uint8_t*)"Metadata on dllproc");
        };
        qc_lex_lex();
        qc_parse_checksymbol((int64_t)42);
        (*stproc).metadata = qc_lex_lx.svalue;
        qc_lex_lex();
        if (!((((int64_t)(qc_lex_lx.symbol) == (int64_t)31) && (((int64_t)(qc_lex_lx.subcode) == (int64_t)102) || ((int64_t)(qc_lex_lx.subcode) == (int64_t)103))))) {
            qc_support_serror((uint8_t*)"\">\" expected");
        };
        if ((((int64_t)(qc_lex_lx.symbol) == (int64_t)31) && ((int64_t)(qc_lex_lx.subcode) == (int64_t)103))) {
            qc_lex_lx.subcode = (int64_t)98;
        } else {
            qc_lex_lex();
        };
    };
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)12)) {
        qc_lex_lex();
        if (((int64_t)(qc_lex_lx.symbol) != (int64_t)13)) {
            if (((fflang == (int64_t)0) || (fflang == (int64_t)3))) {
                varparams = (int64_t)0;
                paramlist = qc_parse_readparams(stproc,&nparams);
            } else {
                paramlist = qc_parse_readparamsff(procowner,stproc,&varparams,&nparams);
            };
            qc_parse_checksymbol((int64_t)13);
        };
        qc_lex_lex();
        if ((((int64_t)(qc_lex_lx.symbol) == (int64_t)7) || ((int64_t)(qc_lex_lx.symbol) == (int64_t)11))) {
            qc_lex_lex();
            prettype = qc_parse_readtypespec(owner,(int64_t)0);
        } else if ((!!((uint64_t)(var_decls_typestarterset[((int64_t)(qc_lex_lx.symbol))])) || ((int64_t)(qc_lex_lx.symbol) == (int64_t)45))) {
            prettype = qc_parse_readtypespec(owner,(int64_t)0);
        };
    } else if ((((int64_t)(qc_lex_lx.symbol) == (int64_t)7) || ((int64_t)(qc_lex_lx.symbol) == (int64_t)11))) {
        qc_lex_lex();
        prettype = qc_parse_readtypespec(owner,(int64_t)0);
    };
    if (!(((prettype != (int64_t)0) || ((kwd != (int64_t)84) && (kwd != (int64_t)85))))) {
        prettype = (int64_t)35;
    };
    if (((prettype != (int64_t)0) && ((kwd != (int64_t)84) && (kwd != (int64_t)85)))) {
        qc_support_serror((uint8_t*)"Proc can't return value");
    };
    if ((((prettype != (int64_t)0) && (fflang != (int64_t)0)) && (fflang != (int64_t)3))) {
        qc_lib_checkdlltype(prettype);
    } else if (((prettype != (int64_t)0) && ((fflang == (int64_t)0) || (fflang == (int64_t)3)))) {
        qc_lib_checkunpackedtype(prettype);
    };
    (*stproc).paramlist = paramlist;
    (*stproc).attribs.ax_nparams = (uint64_t)(nparams);
    (*stproc).mode = prettype;
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)21)) {
        qc_lex_lex();
        qc_parse_checksymbol((int64_t)45);
        qc_lex_lex();
        (*stproc).attribs.ax_at = (uint64_t)((int64_t)1);
    };
    (*stproc).code = (struct var_decls_unitrec *)(0);
    if ((fflang==(int64_t)2) || (fflang==(int64_t)1) || (fflang==(int64_t)4)) {
        if ((qc_parse_currimport == 0)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((*stproc).name,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            qc_support_serror((uint8_t*)"FF should be in dll import");
        };
    } else {
        if (((int64_t)((*procowner).nameid)==(int64_t)2)) {
        }else if (((int64_t)((*procowner).nameid)==(int64_t)3)) {
            qc_support_serror((uint8_t*)"Need FF specifier");
        };
    };
    if (!!(qc_parse_currimport)) {
        isglobal = (int64_t)1;
    };
    (*stproc).attribs.ax_global = (uint64_t)(isglobal);
    (*stproc).attribs.ax_varparams = (uint64_t)(varparams);
    (*stproc).attribs.ax_fflang = (uint64_t)(fflang);
    if ((((procowner == var_decls_stmodule) && (((int64_t)((uint64_t)((*stproc).namelen)) == (int64_t)5) && !!(mlib_eqstring((*stproc).name,(uint8_t*)"start")))) || (((int64_t)((uint64_t)((*stproc).namelen)) == (int64_t)4) && !!(mlib_eqstring((*stproc).name,(uint8_t*)"main"))))) {
        (*stproc).attribs.ax_global = (uint64_t)((int64_t)1);
    };
    return stproc;
}

static struct var_decls_strec * qc_parse_readparams(struct var_decls_strec * owner,int64_t * nparams) {
    struct var_decls_strec *  stlist;
    struct var_decls_strec *  stlistx;
    struct var_decls_strec *  stname;
    int64_t foptional;
    int64_t fbyref;
    stlist = (stlistx = (struct var_decls_strec *)(0));
    foptional = (int64_t)0;
    fbyref = (int64_t)0;
    stname = (struct var_decls_strec *)(0);
    (*nparams) = (int64_t)0;
    L1108 :;
    while (1) {
        switch ((int64_t)(qc_lex_lx.symbol)) {
        case 23:;
        {
            if (!!(foptional)) {
                qc_support_serror((uint8_t*)"??");
            };
            qc_lex_lex();
            foptional = (int64_t)1;
        }break;
        case 24:;
        {
            if (!!(fbyref)) {
                qc_support_serror((uint8_t*)"& &");
            };
            qc_lex_lex();
            fbyref = (int64_t)1;
        }break;
        case 45:;
        {
            ++(*nparams);
            stname = qc_lib_getduplnameptr(owner,qc_lex_lx.symptr,(int64_t)12);
            qc_lib_adddef(owner,stname);
            (*stname).mode = (int64_t)35;
            qc_parse_addlistparam(&stlist,&stlistx,stname);
            qc_lex_lex();
            if (((int64_t)(qc_lex_lx.symbol)==(int64_t)9)) {
                qc_lex_lex();
                (*stname).code = qc_parse_readexpression();
                (*stname).attribs.ax_equals = (uint64_t)((int64_t)1);
            }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)31)) {
                if (((int64_t)(qc_lex_lx.subcode) != (int64_t)98)) {
                    qc_support_serror((uint8_t*)"param op?");
                };
                qc_lex_lex();
                foptional = (int64_t)1;
                (*stname).code = qc_parse_readexpression();
            };
            if (!!(fbyref)) {
                (*stname).attribs.ax_byrefmode = (uint64_t)((int64_t)1);
            };
            if (!!(foptional)) {
                (*stname).attribs.ax_optional = (uint64_t)((int64_t)1);
            };
        }break;
        case 13:;
        {
            goto L1109 ;
        }break;
        case 5:;
        {
            fbyref = (foptional = (int64_t)0);
            qc_lex_lex();
        }break;
        default: {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(qc_tables_symbolnames[((int64_t)(qc_lex_lx.symbol))-1],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            qc_support_serror((uint8_t*)"param");
        }
        } //SW
;
    }L1109 :;
    ;
    return stlist;
}

static struct var_decls_strec * qc_parse_readparamsff(struct var_decls_strec * procowner,struct var_decls_strec * owner,int64_t * varparams,int64_t * nparams) {
    int64_t pmode;
    if (!!((uint64_t)(var_decls_typestarterset[((int64_t)(qc_lex_lx.symbol))]))) {
        pmode = qc_parse_readtypespec(procowner,(int64_t)0);
    } else if (((int64_t)(qc_lex_lx.symbol) == (int64_t)45)) {
        pmode = qc_parse_readtypespec(procowner,(int64_t)0);
    } else {
        qc_support_serror((uint8_t*)"Readparams/type expected");
    };
    if (((qc_lex_lx.symbol == (int64_t)45) || (qc_lex_lx.symbol == (int64_t)24))) {
        return qc_parse_readparamsff_names(pmode,procowner,owner,varparams,nparams);
    } else {
        return qc_parse_readparamsff_types(pmode,procowner,owner,varparams,nparams);
    };
}

static struct var_decls_strec * qc_parse_readparamsff_types(int64_t pmode,struct var_decls_strec * procowner,struct var_decls_strec * owner,int64_t * varparams,int64_t * nparams) {
    struct var_decls_strec *  stlist;
    struct var_decls_strec *  stlistx;
    struct var_decls_strec *  stname;
    uint8_t str[30];
    stlist = (stlistx = (struct var_decls_strec *)(0));
    (*varparams) = (int64_t)0;
    goto L1110 ;
;
    L1111 :;
    while (1) {
        if (!!((uint64_t)(var_decls_typestarterset[((int64_t)(qc_lex_lx.symbol))]))) {
            pmode = qc_parse_readtypespec(procowner,(int64_t)0);
        } else if (((int64_t)(qc_lex_lx.symbol) == (int64_t)45)) {
            pmode = qc_parse_readtypespec(procowner,(int64_t)0);
        } else {
            qc_support_serror((uint8_t*)"Readparams/type expected");
        };
        //gottype:
L1110 :;
;
        qc_lib_checkdlltype(pmode);
        ++(*nparams);
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((uint8_t*)"$",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_i64((*nparams),NULL);
        msysnewc_m_print_end();
        ;
        stname = qc_lib_getduplnameptr(owner,qc_lex_addnamestr(str),(int64_t)12);
        qc_lib_adddef(owner,stname);
        qc_lib_storemode(owner,pmode,&(*stname).mode);
        qc_parse_addlistparam(&stlist,&stlistx,stname);
        if (((int64_t)(qc_lex_lx.symbol)==(int64_t)5)) {
            qc_lex_lex();
            if (((int64_t)(qc_lex_lx.symbol) == (int64_t)30)) {
                (*varparams) = (int64_t)1;
                qc_lex_lex();
                qc_parse_checksymbol((int64_t)13);
                goto L1112 ;
            };
        }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)13)) {
            goto L1112 ;
        } else {
            qc_support_serror((uint8_t*)"ffparams/types");
        };
    }L1112 :;
    ;
    return stlist;
}

static struct var_decls_strec * qc_parse_readparamsff_names(int64_t pmode,struct var_decls_strec * procowner,struct var_decls_strec * owner,int64_t * varparams,int64_t * nparams) {
    struct var_decls_strec *  stlist;
    struct var_decls_strec *  stlistx;
    struct var_decls_strec *  stname;
    int64_t m;
    int64_t fbyref;
    stlist = (stlistx = (struct var_decls_strec *)(0));
    (*varparams) = (int64_t)0;
    L1113 :;
    while (1) {
        qc_lib_checkdlltype(pmode);
        L1115 :;
        while (1) {
            fbyref = (int64_t)0;
            if (((int64_t)(qc_lex_lx.symbol) == (int64_t)24)) {
                qc_lex_lex();
                fbyref = (int64_t)1;
            };
            if (((int64_t)(qc_lex_lx.symbol) != (int64_t)45)) {
                qc_support_serror((uint8_t*)"Params: name expected");
            };
            ++(*nparams);
            stname = qc_lib_getduplnameptr(owner,qc_lex_lx.symptr,(int64_t)12);
            qc_lib_adddef(owner,stname);
            if (!!(fbyref)) {
                m = qc_lib_createrefpackmode(procowner,pmode,(int64_t)0);
                (*stname).attribs.ax_byrefmode = (uint64_t)((int64_t)1);
            } else {
                m = pmode;
            };
            qc_lib_storemode(owner,m,&(*stname).mode);
            qc_parse_addlistparam(&stlist,&stlistx,stname);
            qc_lex_lex();
            if (((int64_t)(qc_lex_lx.symbol)==(int64_t)9)) {
                //doexpr:
L1117 :;
;
                qc_lex_lex();
                (*stname).code = qc_parse_readexpression();
                (*stname).attribs.ax_equals = (uint64_t)((int64_t)1);
                (*stname).attribs.ax_optional = (uint64_t)((int64_t)1);
            }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)31)) {
                if (((int64_t)(qc_lex_lx.subcode) != (int64_t)98)) {
                    qc_support_serror((uint8_t*)"param op?");
                };
                goto L1117 ;
;
            };
            if (((int64_t)(qc_lex_lx.symbol)==(int64_t)5)) {
                qc_lex_lex();
            }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)13)) {
                goto L1114 ;
            };
            if (((int64_t)(qc_lex_lx.symbol)==(int64_t)24)) {
            }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)30)) {
                if (((int64_t)(qc_lex_lx.symbol) == (int64_t)30)) {
                    (*varparams) = (int64_t)1;
                    qc_lex_lex();
                    qc_parse_checksymbol((int64_t)13);
                    goto L1114 ;
                };
            }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)45)) {
                if (((qc_lex_nextlx.symbol == (int64_t)45) || (qc_lex_nextlx.symbol == (int64_t)24))) {
                    pmode = qc_parse_readtypespec(procowner,(int64_t)0);
                };
            } else {
                if (!!((uint64_t)(var_decls_typestarterset[((int64_t)(qc_lex_lx.symbol))]))) {
                    pmode = qc_parse_readtypespec(procowner,(int64_t)0);
                    goto L1116 ;
                } else {
                    qc_support_serror((uint8_t*)"ffparams/types");
                };
            };
        }L1116 :;
        ;
    }L1114 :;
    ;
    return stlist;
}

static struct var_decls_unitrec * qc_parse_readblock(struct var_decls_strec * owner) {
    int64_t lineno;
    int64_t globalflag;
    struct var_decls_unitrec *  ulist;
    struct var_decls_unitrec *  ulistx;
    struct var_decls_unitrec *  p;
    qc_parse_skipsemi();
    lineno = (int64_t)(qc_lex_lx.lineno);
    ulist = (ulistx = (struct var_decls_unitrec *)(0));
    L1118 :;
    while (1) {
        switch ((int64_t)(qc_lex_lx.symbol)) {
        case 111:;
        {
            qc_lex_lex();
            qc_parse_checksymbol((int64_t)100);
            qc_parse_readvardef(owner,(int64_t)0,(int64_t)1,(int64_t)10);
        }break;
        case 83:;
        case 84:;
        case 85:;
        {
            qc_parse_readprocdef(owner,(int64_t)0,(int64_t)0);
            globalflag = (int64_t)0;
        }break;
        case 100:;
        {
            qc_parse_readvardef(owner,(int64_t)0,(int64_t)0,(int64_t)11);
        }break;
        case 95:;
        {
            qc_parse_readtypedef(owner,(int64_t)0);
        }break;
        case 99:;
        {
            qc_parse_readconstdef(owner,(int64_t)0);
        }break;
        case 105:;
        case 86:;
        {
            qc_parse_readclassdef(owner,globalflag);
            globalflag = (int64_t)0;
        }break;
        case 35:;
        {
            mlib_gs_strn(var_decls_docstring,qc_lex_lx.svalue,(int64_t)(qc_lex_lx.length));
            mlib_gs_line(var_decls_docstring);
            qc_lex_lex();
        }break;
        case 103:;
        {
            qc_lex_lex();
            qc_parse_readenumtype(owner,(int64_t)0,(int64_t)0);
        }break;
        case 33:;
        {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((*owner).name,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            qc_support_serror((uint8_t*)"Unexpected EOF in proc");
        }break;
        case 13:;
        case 52:;
        case 53:;
        case 69:;
        case 61:;
        case 54:;
        case 55:;
        case 114:;
        case 57:;
        case 17:;
        {
            goto L1119 ;
        }break;
        case 6:;
        {
            qc_lex_lex();
        }break;
        default: {
            p = qc_parse_readexecstmt(owner);
            if ((((int64_t)(p) == (int64_t)1) || (p == 0))) {
                qc_support_serror((uint8_t*)"READEXEC RETURNED 1 OR NIL");
            };
            qc_parse_addlistunit(&ulist,&ulistx,p);
        }
        } //SW
;
    }L1119 :;
    ;
    return qc_lib_createunit1((int64_t)4,ulist);
}

static struct var_decls_unitrec * qc_parse_readexecstmt(struct var_decls_strec * owner) {
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  q;
    struct var_decls_strec *  stname;
    switch ((int64_t)(qc_lex_lx.symbol)) {
    case 45:;
    {
        if (((int64_t)(qc_lex_nextlx.symbol)==(int64_t)7)) {
            stname = qc_lib_getduplnameptr(var_decls_currproc,qc_lex_lx.symptr,(int64_t)16);
            qc_lib_adddef(var_decls_currproc,stname);
            p = qc_lib_createunit0((int64_t)35);
            (*p).def = stname;
            (*p).trylevel = qc_parse_try_level;
            (*stname).offset = qc_parse_try_level;
            qc_lib_setnameptr(p);
            qc_lex_lex();
            qc_lex_lx.symbol = (int64_t)6;
        } else {
            p = qc_parse_readstmtexpr(owner);
        };
    }break;
    case 74:;
    {
        p = qc_parse_readgoto(owner,(int64_t)33);
    }break;
    case 50:;
    {
        p = qc_parse_readif(owner);
    }break;
    case 58:;
    {
        p = qc_parse_readunless(owner);
    }break;
    case 59:;
    case 75:;
    {
        p = qc_parse_readswitchcase(owner);
    }break;
    case 60:;
    case 76:;
    {
        p = qc_parse_readswitchcase(owner);
    }break;
    case 62:;
    {
        p = qc_parse_readfor(owner);
    }break;
    case 63:;
    {
        p = qc_parse_readforall(owner);
    }break;
    case 64:;
    {
        p = qc_parse_readto(owner);
    }break;
    case 66:;
    {
        p = qc_parse_readdo(owner);
    }break;
    case 67:;
    {
        p = qc_parse_readwhile(owner);
    }break;
    case 68:;
    {
        p = qc_parse_readrepeat(owner);
    }break;
    case 72:;
    {
        p = qc_parse_readloopcontrol(owner);
    }break;
    case 70:;
    {
        p = qc_parse_readreturn(owner);
    }break;
    case 71:;
    {
        p = qc_parse_readstop(owner);
    }break;
    case 77:;
    {
        p = qc_parse_readprint(owner);
    }break;
    case 79:;
    {
        p = qc_parse_readread(owner);
    }break;
    case 113:;
    {
        p = qc_parse_readtry(owner);
    }break;
    case 116:;
    {
        p = qc_parse_readraise(owner);
    }break;
    case 31:;
    {
        if ((((int64_t)(qc_lex_lx.subcode) == (int64_t)107) && ((int64_t)(qc_lex_nextlx.symbol) == (int64_t)12))) {
            qc_support_serror((uint8_t*)"KTERM?");
        } else {
            p = qc_parse_readstmtexpr(owner);
        };
    }break;
    case 131:;
    {
        qc_lex_lex();
        qc_parse_checksymbol((int64_t)12);
        qc_lex_lex();
        p = qc_parse_readexpression();
        qc_parse_checksymbol((int64_t)5);
        qc_lex_lex();
        q = qc_parse_readexpression();
        qc_parse_checksymbol((int64_t)13);
        qc_lex_lex();
        p = qc_lib_createunit2((int64_t)46,p,q);
    }break;
    case 12:;
    case 36:;
    case 80:;
    case 81:;
    case 94:;
    {
        p = qc_parse_readstmtexpr(owner);
    }break;
    case 82:;
    {
        p = qc_parse_readhostparams((struct var_decls_unitrec *)(0),(int64_t)0);
    }break;
    case 124:;
    {
        qc_lex_lex();
        p = qc_lib_createunit1((int64_t)69,qc_parse_readexpression());
    }break;
    default: {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(qc_tables_symbolnames[((int64_t)(qc_lex_lx.symbol))-1],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        qc_support_serror((uint8_t*)"Stmt error");
    }
    } //SW
;
    return p;
}

static struct var_decls_unitrec * qc_parse_readstmtexpr(struct var_decls_strec * owner) {
    int64_t opc;
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  q;
    struct var_decls_unitrec *  ulist;
    struct var_decls_unitrec *  ulistx;
    if ((((int64_t)(qc_lex_lx.symbol) == (int64_t)31) && ((int64_t)(qc_lex_nextlx.symbol) == (int64_t)9))) {
        opc = (int64_t)(qc_lex_lx.subcode);
        if ((opc==(int64_t)106)) {
            opc = (int64_t)156;
        };
        qc_lex_lex();
        qc_lex_lex();
        return qc_lib_createunit1(qc_lib_getoptocode(opc),qc_parse_readterm());
    };
    p = qc_parse_readterm();
    if (((int64_t)((*p).tag)==(int64_t)209)) {
        (*p).tag = (int64_t)231;
    }else if (((int64_t)((*p).tag)==(int64_t)210)) {
        (*p).tag = (int64_t)232;
    }else if (((int64_t)((*p).tag)==(int64_t)211)) {
        (*p).tag = (int64_t)233;
    }else if (((int64_t)((*p).tag)==(int64_t)212)) {
        (*p).tag = (int64_t)234;
    };
    if (((int64_t)(qc_lex_lx.symbol)==(int64_t)9)) {
        qc_lex_lex();
        q = qc_parse_readexpression();
        p = qc_lib_createunit2((int64_t)17,p,q);
        return qc_parse_readcondsuffix(p);
    }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)10)) {
        qc_lex_lex();
        q = qc_parse_readexpression();
        p = qc_lib_createunit2((int64_t)19,p,q);
        return qc_parse_readcondsuffix(p);
    }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)31)) {
        if (((int64_t)(qc_lex_nextlx.symbol) == (int64_t)9)) {
            opc = qc_lib_getoptocode((int64_t)(qc_lex_lx.subcode));
            qc_lex_lex();
            qc_lex_lex();
            return qc_lib_createunit2(opc,p,qc_parse_readexpression());
        } else {
            qc_support_serror((uint8_t*)"op expr not allowed as statement");
        };
    }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)131)) {
        qc_lex_lex();
        return qc_lib_createunit2((int64_t)46,p,qc_parse_readterm());
    }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)5)) {
        ulist = (ulistx = p);
        qc_parse_inmultexpr = (int64_t)1;
        L1120 :;
        do {
            qc_lex_lex();
            qc_parse_addlistunit(&ulist,&ulistx,qc_parse_readexpression());
L1121 :;
        } while (!((int64_t)(qc_lex_lx.symbol) != (int64_t)5));L1122 :;
        ;
        qc_parse_inmultexpr = (int64_t)0;
        p = qc_lib_createunit1((int64_t)85,ulist);
        qc_parse_checksymbol((int64_t)9);
        qc_lex_lex();
        q = qc_parse_readexpression();
        if (((int64_t)(qc_lex_lx.symbol) != (int64_t)5)) {
            qc_support_serror((uint8_t*)"mult-expr expected after :=");
        };
        ulist = (ulistx = q);
        L1123 :;
        do {
            qc_lex_lex();
            qc_parse_addlistunit(&ulist,&ulistx,qc_parse_readexpression());
L1124 :;
        } while (!((int64_t)(qc_lex_lx.symbol) != (int64_t)5));L1125 :;
        ;
        q = qc_lib_createunit1((int64_t)85,ulist);
        p = qc_lib_createunit2((int64_t)17,p,q);
        return p;
    };
    if (((int64_t)((*p).tag)==(int64_t)88)) {
        (*p).tag = (int64_t)17;
    }else if (((int64_t)((*p).tag)==(int64_t)89)) {
        (*p).tag = (int64_t)19;
    }else if (((int64_t)((*p).tag)==(int64_t)90)) {
        (*p).tag = (int64_t)14;
        p = qc_parse_readcondsuffix(p);
    }else if (((int64_t)((*p).tag)==(int64_t)68)) {
        (*p).tag = (int64_t)67;
        p = qc_parse_readcondsuffix(p);
    }else if (((int64_t)((*p).tag)==(int64_t)91)) {
        (*p).tag = (int64_t)15;
        p = qc_parse_readcondsuffix(p);
    } else {
        if (((int64_t)((*p).tag)==(int64_t)231) || ((int64_t)((*p).tag)==(int64_t)232) || ((int64_t)((*p).tag)==(int64_t)233) || ((int64_t)((*p).tag)==(int64_t)234) || ((int64_t)((*p).tag)==(int64_t)14) || ((int64_t)((*p).tag)==(int64_t)67) || ((int64_t)((*p).tag)==(int64_t)59) || ((int64_t)((*p).tag)==(int64_t)60)) {
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(qc_tables_jtagnames[((int64_t)((*p).tag))],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            qc_support_serror((uint8_t*)"Expression not allowed as statement");
        };
    };
    return p;
}

static struct var_decls_unitrec * qc_parse_readcondsuffix(struct var_decls_unitrec * p) {
    if (((int64_t)(qc_lex_lx.symbol)==(int64_t)50) || ((int64_t)(qc_lex_lx.symbol)==(int64_t)61)) {
        qc_lex_lex();
        return qc_lib_createunit2((int64_t)21,qc_parse_readexpression(),qc_lib_createunit1((int64_t)4,p));
    }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)58)) {
        qc_lex_lex();
        return qc_lib_createunit2((int64_t)21,qc_lib_createunit1((int64_t)77,qc_parse_readexpression()),qc_lib_createunit1((int64_t)4,p));
    } else {
        return p;
    };
    return (struct var_decls_unitrec *)(0);
}

static struct var_decls_unitrec * qc_parse_readif(struct var_decls_strec * owner) {
    int64_t line;
    int64_t kwd;
    int64_t lineno;
    struct var_decls_unitrec *  pthen;
    struct var_decls_unitrec *  pcond;
    struct var_decls_unitrec *  plist;
    struct var_decls_unitrec *  plistx;
    struct var_decls_unitrec *  pelse;
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  pelsif;
    line = (int64_t)(qc_lex_lx.lineno);
    kwd = (int64_t)(qc_lex_lx.symbol);
    qc_lex_lex();
    pcond = qc_parse_readexpression();
    qc_parse_skipsemi();
    qc_parse_checksymbol((int64_t)51);
    qc_lex_lex();
    pthen = qc_parse_readblock(owner);
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)52)) {
        lineno = (int64_t)(qc_lex_lx.lineno);
        plist = (plistx = qc_lib_createunit2((int64_t)11,pcond,pthen));
        L1126 :;
        while (((int64_t)(qc_lex_lx.symbol) == (int64_t)52)) {
            lineno = (int64_t)(qc_lex_lx.lineno);
            qc_lex_lex();
            pcond = qc_parse_readexpression();
            qc_parse_checksymbol((int64_t)51);
            qc_lex_lex();
            pthen = qc_parse_readblock(owner);
            pelsif = qc_lib_createunit2((int64_t)11,pcond,pthen);
            (*pelsif).lineno = lineno;
            qc_parse_addlistunit(&plist,&plistx,pelsif);
L1127 :;
        }L1128 :;
        ;
        if (((int64_t)(qc_lex_lx.symbol)==(int64_t)53)) {
            qc_lex_lex();
            pelse = qc_parse_readblock(owner);
            qc_parse_checkend((int64_t)57,kwd,(int64_t)0,(int64_t)0);
            qc_lex_lex();
        }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)54) || ((int64_t)(qc_lex_lx.symbol)==(int64_t)55)) {
            qc_lex_lx.symbol = kwd;
            pelse = qc_parse_makeblock(qc_parse_readswitchcase(owner));
        } else {
            pelse = qc_lib_createunit0((int64_t)4);
            qc_parse_checkend((int64_t)57,kwd,(int64_t)0,(int64_t)0);
            qc_lex_lex();
        };
        p = qc_lib_createunit2((int64_t)22,plist,pelse);
        (*p).lineno = line;
        return p;
    };
    if (((int64_t)(qc_lex_lx.symbol)==(int64_t)53)) {
        qc_lex_lex();
        pelse = qc_parse_readblock(owner);
        qc_parse_checkend((int64_t)57,kwd,(int64_t)0,(int64_t)0);
        qc_lex_lex();
    } else {
        pelse = qc_lib_createunit0((int64_t)4);
        qc_parse_checkend((int64_t)57,kwd,(int64_t)0,(int64_t)0);
        qc_lex_lex();
    };
    p = qc_lib_createunit3((int64_t)21,pcond,pthen,pelse);
    (*p).lineno = line;
    return p;
}

static struct var_decls_unitrec * qc_parse_readgoto(struct var_decls_strec * owner,int64_t gototag) {
    struct var_decls_unitrec *  p;
    if (((int64_t)(qc_lex_lx.subcode) == (int64_t)1)) {
        qc_lex_lex();
        qc_parse_checksymbol((int64_t)64);
    };
    qc_lex_lex();
    p = qc_parse_readexpression();
    return qc_parse_readcondsuffix(qc_lib_createunit1(gototag,p));
}

static struct var_decls_unitrec * qc_parse_readunless(struct var_decls_strec * owner) {
    int64_t line;
    struct var_decls_unitrec *  pcond;
    struct var_decls_unitrec *  pthen;
    struct var_decls_unitrec *  pelse;
    struct var_decls_unitrec *  p;
    line = (int64_t)(qc_lex_lx.lineno);
    qc_lex_lex();
    pcond = qc_parse_readexpression();
    qc_parse_checksymbol((int64_t)51);
    qc_lex_lex();
    pthen = qc_parse_readblock(owner);
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)53)) {
        qc_lex_lex();
        pelse = qc_parse_readblock(owner);
    } else {
        pelse = qc_lib_createunit0((int64_t)4);
    };
    qc_parse_checkend((int64_t)57,(int64_t)58,(int64_t)0,(int64_t)0);
    qc_lex_lex();
    p = qc_lib_createunit3((int64_t)21,qc_lib_createunit1((int64_t)77,pcond),pthen,pelse);
    (*p).lineno = line;
    return p;
}

static struct var_decls_unitrec * qc_parse_readswitchcase(struct var_decls_strec * owner) {
    int64_t line;
    int64_t kwd;
    int64_t opc;
    int64_t lineno;
    struct var_decls_unitrec *  pexpr;
    struct var_decls_unitrec *  pwhenlist;
    struct var_decls_unitrec *  pwhenlistx;
    struct var_decls_unitrec *  pwhen;
    struct var_decls_unitrec *  pwhenx;
    struct var_decls_unitrec *  pelse;
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  pthen;
    struct var_decls_unitrec *  pwhenthen;
    line = (int64_t)(qc_lex_lx.lineno);
    kwd = (int64_t)(qc_lex_lx.symbol);
    if ((kwd == (int64_t)76)) {
        ++var_decls_ndoswitch;
    };
    if ((kwd == (int64_t)60)) {
        ++var_decls_ndocase;
    };
    opc = (int64_t)(qc_lex_lx.subcode);
    qc_lex_lex();
    pexpr = qc_parse_readexpression();
    pwhenlist = (pwhenlistx = (struct var_decls_unitrec *)(0));
    qc_parse_skipsemi();
    L1129 :;
    while (((int64_t)(qc_lex_lx.symbol) == (int64_t)61)) {
        lineno = (int64_t)(qc_lex_lx.lineno);
        qc_lex_lex();
        pwhen = (pwhenx = (struct var_decls_unitrec *)(0));
        L1132 :;
        while (1) {
            p = qc_parse_readexpression();
            (*p).lineno = lineno;
            qc_parse_addlistunit(&pwhen,&pwhenx,p);
            if (((int64_t)(qc_lex_lx.symbol) != (int64_t)5)) {
                goto L1133 ;
            };
            qc_lex_lex();
        }L1133 :;
        ;
        qc_parse_checksymbol((int64_t)51);
        qc_lex_lex();
        pthen = qc_parse_readblock(owner);
        pwhenthen = qc_lib_createunit2((int64_t)10,pwhen,pthen);
        (*pwhenthen).lineno = lineno;
        qc_parse_addlistunit(&pwhenlist,&pwhenlistx,pwhenthen);
L1130 :;
    }L1131 :;
    ;
    if (((int64_t)(qc_lex_lx.symbol)==(int64_t)53)) {
        qc_lex_lex();
        pelse = qc_parse_readblock(owner);
        qc_parse_checkend((int64_t)57,kwd,(int64_t)0,(int64_t)0);
        qc_lex_lex();
    }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)52)) {
        qc_lex_lx.symbol = kwd;
        pelse = qc_parse_makeblock(qc_parse_readif(owner));
    }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)54) || ((int64_t)(qc_lex_lx.symbol)==(int64_t)55)) {
        qc_lex_lx.symbol = kwd;
        pelse = qc_parse_makeblock(qc_parse_readswitchcase(owner));
    } else {
        pelse = qc_parse_makeblock((struct var_decls_unitrec *)(0));
        qc_parse_checkend((int64_t)57,kwd,(int64_t)0,(int64_t)0);
        qc_lex_lex();
    };
    p = qc_lib_createunit3(opc,pexpr,pwhenlist,pelse);
    (*p).lineno = line;
    return p;
}

static struct var_decls_unitrec * qc_parse_readstop(struct var_decls_strec * owner) {
    struct var_decls_unitrec *  p;
    qc_lex_lex();
    if (!!((uint64_t)(var_decls_exprstarterset[((int64_t)(qc_lex_lx.symbol))]))) {
        p = qc_lib_createunit1((int64_t)61,qc_parse_readexpression());
    } else {
        p = qc_lib_createunit0((int64_t)61);
    };
    return qc_parse_readcondsuffix(p);
}

static struct var_decls_unitrec * qc_parse_readreturn(struct var_decls_strec * owner) {
    struct var_decls_unitrec *  p;
    qc_lex_lex();
    if (!!((uint64_t)(var_decls_exprstarterset[((int64_t)(qc_lex_lx.symbol))]))) {
        p = qc_lib_createunit1((int64_t)16,qc_parse_readexpression());
    } else {
        p = qc_lib_createunit0((int64_t)16);
    };
    return qc_parse_readcondsuffix(p);
}

static struct var_decls_unitrec * qc_parse_readdo(struct var_decls_strec * owner) {
    struct var_decls_unitrec *  p;
    int64_t line;
    ++var_decls_ndo;
    line = (int64_t)(qc_lex_lx.lineno);
    qc_lex_lex();
    p = qc_parse_readblock(owner);
    qc_parse_checkend((int64_t)57,(int64_t)66,(int64_t)0,(int64_t)0);
    qc_lex_lex();
    p = qc_lib_createunit1((int64_t)41,p);
    (*p).lineno = line;
    return p;
}

static struct var_decls_unitrec * qc_parse_readto(struct var_decls_strec * owner) {
    int64_t line;
    int64_t id;
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  pcount;
    struct var_decls_unitrec *  pbody;
    ++var_decls_nto;
    line = (int64_t)(qc_lex_lx.lineno);
    qc_lex_lex();
    pcount = qc_parse_readexpression();
    qc_parse_checksymbol((int64_t)66);
    qc_lex_lex();
    pbody = qc_parse_readblock(owner);
    qc_parse_checkend((int64_t)57,(int64_t)64,(int64_t)66,(int64_t)0);
    qc_lex_lex();
    id = (int64_t)11;
    if (((int64_t)((uint64_t)((*owner).nameid)) != (int64_t)5)) {
        id = (int64_t)10;
    };
    p = qc_lib_createunit3((int64_t)20,pcount,pbody,qc_lib_createname(qc_lib_getavname(owner,id)));
    (*p).lineno = line;
    return p;
}

static struct var_decls_unitrec * qc_parse_readwhile(struct var_decls_strec * owner) {
    int64_t line;
    struct var_decls_unitrec *  pcond;
    struct var_decls_unitrec *  pbody;
    struct var_decls_unitrec *  p;
    ++var_decls_nwhile;
    line = (int64_t)(qc_lex_lx.lineno);
    qc_lex_lex();
    pcond = qc_parse_readexpression();
    qc_parse_checksymbol((int64_t)66);
    qc_lex_lex();
    pbody = qc_parse_readblock(owner);
    qc_parse_checkend((int64_t)57,(int64_t)67,(int64_t)66,(int64_t)0);
    qc_lex_lex();
    p = qc_lib_createunit2((int64_t)31,pcond,pbody);
    (*p).lineno = line;
    return p;
}

static struct var_decls_unitrec * qc_parse_readrepeat(struct var_decls_strec * owner) {
    int64_t line;
    struct var_decls_unitrec *  pbody;
    struct var_decls_unitrec *  pcond;
    struct var_decls_unitrec *  p;
    ++var_decls_nrepeat;
    line = (int64_t)(qc_lex_lx.lineno);
    qc_lex_lex();
    pbody = qc_parse_readblock(owner);
    qc_parse_checksymbol((int64_t)69);
    qc_lex_lex();
    pcond = qc_parse_readexpression();
    p = qc_lib_createunit2((int64_t)32,pbody,pcond);
    (*p).lineno = line;
    return p;
}

static struct var_decls_unitrec * qc_parse_readloopcontrol(struct var_decls_strec * owner) {
    int64_t opc;
    struct var_decls_unitrec *  p;
    opc = (int64_t)(qc_lex_lx.subcode);
    qc_lex_lex();
    if ((((int64_t)(qc_lex_lx.symbol) == (int64_t)45) && !!(mlib_eqstring((*qc_lex_lx.symptr).name,(uint8_t*)"all")))) {
        qc_lex_lex();
        p = qc_lib_createunit1(opc,qc_lib_createconstunit((uint64_t)((int64_t)0),(int64_t)1));
    } else if (!!((uint64_t)(var_decls_exprstarterset[((int64_t)(qc_lex_lx.symbol))]))) {
        p = qc_lib_createunit1(opc,qc_parse_readconstexpr(owner,(int64_t)1));
    } else {
        p = qc_lib_createunit0(opc);
    };
    return qc_parse_readcondsuffix(p);
}

static struct var_decls_unitrec * qc_parse_readprint(struct var_decls_strec * owner) {
    int64_t oldinreadprint;
    int64_t opc;
    int64_t isfprint;
    int64_t fshowname;
    int64_t length;
    struct var_decls_unitrec *  pformat;
    struct var_decls_unitrec *  pdev;
    struct var_decls_unitrec *  printlist;
    struct var_decls_unitrec *  printlistx;
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  q;
    struct mlib_strbuffer *  expr;
    uint8_t *  s;
    oldinreadprint = qc_parse_inreadprint;
    qc_parse_inreadprint = (int64_t)1;
    opc = (int64_t)(qc_lex_lx.subcode);
    if ((opc==(int64_t)50) || (opc==(int64_t)51) || (opc==(int64_t)52) || (opc==(int64_t)53)) {
        isfprint = (int64_t)1;
    } else {
        isfprint = (int64_t)0;
    };
    qc_lex_lex();
    printlist = (printlistx = (struct var_decls_unitrec *)(0));
    pformat = (pdev = (struct var_decls_unitrec *)(0));
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)21)) {
        qc_lex_lex();
        pdev = qc_parse_readexpression();
        if (((int64_t)(qc_lex_lx.symbol) == (int64_t)5)) {
            qc_lex_lex();
        } else {
            goto L1134 ;
;
        };
    };
    if (!!(isfprint)) {
        if ((!(!!((uint64_t)(var_decls_exprstarterset[((int64_t)(qc_lex_lx.symbol))]))) && (opc == (int64_t)53))) {
            goto L1134 ;
;
        };
        pformat = qc_parse_readexpression();
        if (((int64_t)(qc_lex_lx.symbol) == (int64_t)5)) {
            qc_lex_lex();
        } else {
            goto L1134 ;
;
        };
    };
    if (!(!!((uint64_t)(var_decls_exprstarterset[((int64_t)(qc_lex_lx.symbol))])))) {
        goto L1134 ;
;
    };
    L1135 :;
    while (1) {
        if (((int64_t)(qc_lex_lx.symbol) == (int64_t)5)) {
            qc_parse_addlistunit(&printlist,&printlistx,qc_lib_createunit0((int64_t)13));
        } else {
            fshowname = (int64_t)0;
            if ((((int64_t)(qc_lex_lx.symbol) == (int64_t)31) && ((int64_t)(qc_lex_lx.subcode) == (int64_t)98))) {
                fshowname = (int64_t)1;
                qc_lex_lex();
            };
            p = qc_parse_readexpression();
            if (((int64_t)(qc_lex_lx.symbol) == (int64_t)7)) {
                qc_lex_lex();
                p = qc_lib_createunit2((int64_t)12,p,qc_parse_readexpression());
            };
            if (!!(fshowname)) {
                expr = qc_lib_strexpr(p);
                length = (int64_t)((*expr).length);
                mlib_strbuffer_add(expr,(uint8_t*)"=?",(int64_t)-1);
                s = (*expr).strptr;
                mlib_iconvucn(s,length);
                (*((s + length) + (int64_t)1)) = (uint64_t)0u;
                qc_parse_addlistunit(&printlist,&printlistx,(q = qc_lib_createstringconstunit(s,(int64_t)-1)));
            };
            qc_parse_addlistunit(&printlist,&printlistx,p);
        };
        if (((int64_t)(qc_lex_lx.symbol) != (int64_t)5)) {
            goto L1136 ;
        };
        qc_lex_lex();
    }L1136 :;
    ;
    //finish:
L1134 :;
;
    qc_parse_inreadprint = oldinreadprint;
    if (((opc == (int64_t)48) && (printlist == 0))) {
        qc_support_serror((uint8_t*)"No print items");
    };
    if ((((opc == (int64_t)50) && (printlist == 0)) && (pformat == 0))) {
        qc_support_serror((uint8_t*)"No print items");
    };
    if ((((opc == (int64_t)52) && (printlist == 0)) && (pformat == 0))) {
        qc_support_serror((uint8_t*)"No cprint items");
    };
    if (!!(isfprint)) {
        if (((pformat == 0) && (opc != (int64_t)53))) {
            qc_support_serror((uint8_t*)"No fmt str");
        };
        return qc_lib_createunit3(opc,pdev,pformat,printlist);
    } else {
        return qc_lib_createunit2(opc,pdev,printlist);
    };
}

static struct var_decls_unitrec * qc_parse_readread(struct var_decls_strec * owner) {
    int64_t oldinreadprint;
    int64_t opc;
    struct var_decls_unitrec *  pformat;
    struct var_decls_unitrec *  pdev;
    struct var_decls_unitrec *  readlist;
    struct var_decls_unitrec *  readlistx;
    struct var_decls_unitrec *  p;
    oldinreadprint = qc_parse_inreadprint;
    qc_parse_inreadprint = (int64_t)1;
    opc = (int64_t)(qc_lex_lx.subcode);
    qc_lex_lex();
    readlist = (readlistx = (struct var_decls_unitrec *)(0));
    pformat = (pdev = (struct var_decls_unitrec *)(0));
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)21)) {
        if ((opc == (int64_t)57)) {
            qc_support_serror((uint8_t*)"@ on read");
        };
        qc_lex_lex();
        pdev = qc_parse_readexpression();
        if (((int64_t)(qc_lex_lx.symbol) == (int64_t)5)) {
            qc_lex_lex();
        } else {
            goto L1137 ;
;
        };
    };
    if (!(!!((uint64_t)(var_decls_exprstarterset[((int64_t)(qc_lex_lx.symbol))])))) {
        goto L1137 ;
;
    };
    L1138 :;
    while (1) {
        p = qc_parse_readexpression();
        if (((int64_t)(qc_lex_lx.symbol) == (int64_t)7)) {
            qc_lex_lex();
            p = qc_lib_createunit2((int64_t)12,p,qc_parse_readexpression());
        };
        qc_parse_addlistunit(&readlist,&readlistx,p);
        if (((int64_t)(qc_lex_lx.symbol) != (int64_t)5)) {
            goto L1139 ;
        };
        qc_lex_lex();
    }L1139 :;
    ;
    //finish:
L1137 :;
;
    qc_parse_inreadprint = oldinreadprint;
    if (((opc == (int64_t)57) && (readlist == 0))) {
        qc_support_serror((uint8_t*)"No read items");
    };
    return qc_lib_createunit2(opc,pdev,readlist);
}

static struct var_decls_unitrec * qc_parse_readtry(struct var_decls_strec * owner) {
    struct var_decls_unitrec *  ptry;
    struct var_decls_unitrec *  pexceptlist;
    struct var_decls_unitrec *  pexceptlistx;
    struct var_decls_unitrec *  px;
    struct var_decls_unitrec *  exlist;
    struct var_decls_unitrec *  exlistx;
    ++qc_parse_try_level;
    qc_lex_lex();
    ptry = qc_parse_readblock(owner);
    pexceptlist = (pexceptlistx = (struct var_decls_unitrec *)(0));
    L1140 :;
    while (((int64_t)(qc_lex_lx.symbol) == (int64_t)114)) {
        qc_lex_lex();
        exlist = (exlistx = (struct var_decls_unitrec *)(0));
        L1143 :;
        while (1) {
            qc_parse_addlistunit(&exlist,&exlistx,qc_parse_readconstexpr(owner,(int64_t)1));
            if (((int64_t)(qc_lex_lx.symbol) != (int64_t)5)) {
                goto L1144 ;
            };
            qc_lex_lex();
        }L1144 :;
        ;
        qc_parse_checksymbol((int64_t)51);
        qc_lex_lex();
        px = qc_parse_readblock(owner);
        qc_parse_addlistunit(&pexceptlist,&pexceptlistx,qc_lib_createunit2((int64_t)63,exlist,px));
L1141 :;
    }L1142 :;
    ;
    qc_parse_checkend((int64_t)57,(int64_t)113,(int64_t)0,(int64_t)0);
    qc_lex_lex();
    --qc_parse_try_level;
    return qc_lib_createunit2((int64_t)62,ptry,pexceptlist);
}

static struct var_decls_unitrec * qc_parse_readraise(struct var_decls_strec * owner) {
    struct var_decls_unitrec *  p;
    qc_lex_lex();
    p = qc_parse_readexpression();
    return qc_lib_createunit1((int64_t)65,p);
}

static struct var_decls_unitrec * qc_parse_readfor(struct var_decls_strec * owner) {
    int64_t line;
    int64_t opc;
    int64_t down;
    struct var_decls_unitrec *  pstep;
    struct var_decls_unitrec *  pvar;
    struct var_decls_unitrec *  pcond;
    struct var_decls_unitrec *  pfrom;
    struct var_decls_unitrec *  pto;
    struct var_decls_unitrec *  pelse;
    struct var_decls_unitrec *  prange;
    struct var_decls_unitrec *  pautovar;
    struct var_decls_unitrec *  pbody;
    struct var_decls_unitrec *  p;
    ++var_decls_nfor;
    line = (int64_t)(qc_lex_lx.lineno);
    qc_lex_lex();
    pvar = qc_parse_readterm();
    if (((int64_t)((*pvar).tag) != (int64_t)3)) {
        qc_support_serror((uint8_t*)"For: name expected");
    };
    opc = (int64_t)23;
    pstep = (struct var_decls_unitrec *)(0);
    pcond = (struct var_decls_unitrec *)(0);
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)31)) {
        if (((int64_t)(qc_lex_lx.subcode) == (int64_t)121)) {
            down = (int64_t)24;
        } else if (((int64_t)(qc_lex_lx.subcode) != (int64_t)119)) {
            qc_support_serror((uint8_t*)"in/inrev expected");
        };
        qc_lex_lex();
        prange = qc_parse_readexpression();
        pfrom = qc_lib_getrangelwbunit(prange);
        pto = qc_lib_getrangeupbunit(prange);
    } else {
        if (((int64_t)(qc_lex_lx.symbol) == (int64_t)9)) {
            qc_lex_lex();
            pfrom = qc_parse_readexpression();
        } else {
            pfrom = qc_lib_createconstunit((uint64_t)((int64_t)1),(int64_t)1);
        };
        qc_parse_checksymbol((int64_t)64);
        opc = (((int64_t)(qc_lex_lx.subcode) == (int64_t)1)?(int64_t)24:(int64_t)23);
        qc_lex_lex();
        pto = qc_parse_readexpression();
        if (((int64_t)(qc_lex_lx.symbol) == (int64_t)65)) {
            if ((opc == (int64_t)24)) {
                qc_support_serror((uint8_t*)"downto/by");
            };
            opc = (int64_t)25;
            qc_lex_lex();
            pstep = qc_parse_readconstexpr(owner,(int64_t)0);
            if ((((int64_t)((*pstep).tag) == (int64_t)1) && ((*pstep).value == (int64_t)1))) {
                opc = (int64_t)23;
                pstep = (struct var_decls_unitrec *)(0);
            } else if ((((int64_t)((*pstep).tag) == (int64_t)1) && ((*pstep).value == (int64_t)-1))) {
                opc = (int64_t)24;
                pstep = (struct var_decls_unitrec *)(0);
            };
        } else {
            pstep = (struct var_decls_unitrec *)(0);
        };
    };
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)61)) {
        qc_lex_lex();
        pcond = qc_parse_readexpression();
    };
    qc_parse_checksymbol((int64_t)66);
    qc_lex_lex();
    pbody = qc_parse_readblock(owner);
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)53)) {
        qc_lex_lex();
        pelse = qc_parse_readblock(owner);
    } else {
        pelse = (struct var_decls_unitrec *)(0);
    };
    qc_parse_checkend((int64_t)57,(int64_t)62,(int64_t)66,(int64_t)0);
    qc_lex_lex();
    if ((pcond != 0)) {
        pbody = qc_parse_makeblock(qc_lib_createunit2((int64_t)21,pcond,pbody));
    };
    pautovar = (struct var_decls_unitrec *)(0);
    if (!((((int64_t)((*pto).tag) == (int64_t)1) || (((int64_t)((*pto).tag) == (int64_t)3) && !!((uint64_t)((*(*pto).def).attribs.ax_frame)))))) {
        if ((opc == (int64_t)25)) {
            qc_support_serror((uint8_t*)"for: 'by' uses complex limit");
        };
        pautovar = qc_lib_createname(qc_lib_getavname(owner,(int64_t)11));
    };
    (*pvar).nextunit = pfrom;
    (*pfrom).nextunit = pto;
    (*pto).nextunit = pstep;
    (*pbody).nextunit = pelse;
    p = qc_lib_createunit3(opc,pvar,pbody,pautovar);
    (*p).lineno = line;
    return p;
}

static struct var_decls_unitrec * qc_parse_readforall(struct var_decls_strec * owner) {
    int64_t opc;
    int64_t line;
    int64_t isforall;
    struct var_decls_unitrec *  pindex;
    struct var_decls_unitrec *  pvar;
    struct var_decls_unitrec *  pcond;
    struct var_decls_unitrec *  plist;
    struct var_decls_unitrec *  pbody;
    struct var_decls_unitrec *  pelse;
    struct var_decls_unitrec *  pfor;
    struct var_decls_unitrec *  pautovar;
    line = (int64_t)(qc_lex_lx.lineno);
    ++var_decls_nfor;
    opc = (int64_t)(qc_lex_lx.subcode);
    isforall = (opc == (int64_t)26);
    qc_lex_lex();
    pvar = qc_parse_readterm();
    pindex = (struct var_decls_unitrec *)(0);
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)5)) {
        qc_lex_lex();
        pindex = pvar;
        pvar = qc_parse_readterm();
    };
    if (((int64_t)((*pvar).tag) != (int64_t)3)) {
        qc_support_serror((uint8_t*)"forall not name");
    };
    pcond = (struct var_decls_unitrec *)(0);
    if ((((int64_t)(qc_lex_lx.symbol) == (int64_t)31) && (((int64_t)(qc_lex_lx.subcode) == (int64_t)119) || ((int64_t)(qc_lex_lx.subcode) == (int64_t)121)))) {
        if (((int64_t)(qc_lex_lx.subcode) == (int64_t)121)) {
            opc = ((opc == (int64_t)26)?(int64_t)27:(int64_t)29);
        };
        qc_lex_lex();
        plist = qc_parse_readexpression();
    } else {
        qc_support_serror((uint8_t*)"in/inrev expected");
    };
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)61)) {
        qc_lex_lex();
        pcond = qc_parse_readexpression();
    };
    qc_parse_checksymbol((int64_t)66);
    qc_lex_lex();
    pbody = qc_parse_readblock(owner);
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)53)) {
        qc_lex_lex();
        pelse = qc_parse_readblock(owner);
    } else {
        pelse = (struct var_decls_unitrec *)(0);
    };
    qc_parse_checkend((int64_t)57,(int64_t)63,(int64_t)66,(int64_t)0);
    qc_lex_lex();
    if ((pindex == 0)) {
        pindex = qc_lib_createname(qc_lib_getavname(owner,(int64_t)11));
    };
    if ((pcond != 0)) {
        pbody = qc_lib_createunit2((int64_t)21,pcond,pbody);
        (*pbody).lineno = line;
    };
    pautovar = qc_lib_createname(qc_lib_getavname(var_decls_currproc,(int64_t)11));
    (*pindex).nextunit = pvar;
    (*pvar).nextunit = plist;
    (*pbody).nextunit = pelse;
    pfor = qc_lib_createunit3(opc,pindex,pbody,pautovar);
    (*pfor).lineno = line;
    return pfor;
}

void qc_parse_readtypedef(struct var_decls_strec * owner,int64_t isglobal) {
    struct var_decls_strec *  sttype;
    struct var_decls_strec *  stname;
    int64_t t;
    int64_t m;
    qc_lex_lex();
    qc_parse_checksymbol((int64_t)45);
    stname = qc_lex_lx.symptr;
    qc_lex_lex();
    qc_parse_checkequals();
    qc_lex_lex();
    sttype = (struct var_decls_strec *)(0);
    if ((sttype == 0)) {
        sttype = qc_lib_getduplnameptr(owner,stname,(int64_t)4);
        qc_lib_adddef(owner,sttype);
        m = qc_lib_createusertype(sttype);
    } else {
        m = (int64_t)((*sttype).mode);
    };
    t = qc_parse_readtypespec(sttype,m);
    (*sttype).attribs.ax_global = (uint64_t)(isglobal);
    (*sttype).mode = t;
}

static int64_t qc_parse_readstructdef(struct var_decls_strec * owner,int64_t typedefx,int64_t kwd) {
    int64_t m;
    int64_t startline;
    int64_t closesym;
    int64_t t;
    struct var_decls_strec *  recordowner;
    recordowner = owner;
    if (!(!!(typedefx))) {
        if (((int64_t)(qc_lex_lx.symbol) == (int64_t)45)) {
            owner = qc_lib_getduplnameptr(owner,qc_lex_lx.symptr,(int64_t)4);
            qc_lex_lex();
            qc_parse_checkequals();
            qc_lex_lex();
        } else {
            owner = qc_lib_getduplnameptr(var_decls_stmodule,qc_lex_addnamestr(qc_lib_nextautotype()),(int64_t)4);
        };
        qc_lib_adddef(recordowner,owner);
        qc_parse_checksymbol((int64_t)12);
        qc_lex_lex();
    } else {
        owner = var_decls_ttnamedef[(typedefx)];
        startline = qc_parse_getcurrline();
        closesym = qc_parse_checkbegin((int64_t)1);
    };
    m = qc_lib_createrecordmode(owner,(int64_t)33,typedefx);
    (*owner).mode = m;
    qc_lib_unionstr_clear(&qc_parse_unionstring);
    qc_lib_unionstr_clear(&qc_parse_unionpend);
    L1145 :;
    while (1) {
        if (((int64_t)(qc_lex_lx.symbol)==(int64_t)87) || ((int64_t)(qc_lex_lx.symbol)==(int64_t)88)) {
            qc_lib_unionstr_append(&qc_parse_unionpend,(((int64_t)(qc_lex_lx.symbol) == (int64_t)87)?(int64_t)83:(int64_t)85));
            qc_parse_unionlastvar = (struct var_decls_strec *)(0);
            qc_lex_lex();
        }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)57)) {
            if (!!((uint64_t)(qc_parse_unionstring.ulength))) {
                qc_parse_checkend((int64_t)57,((qc_lib_unionstr_last(&qc_parse_unionstring) == (int64_t)83)?(int64_t)87:(int64_t)88),(int64_t)0,(int64_t)0);
                qc_lex_lex();
                if (((qc_parse_unionlastvar == 0) || !!((uint64_t)(qc_parse_unionpend.ulength)))) {
                    qc_support_serror((uint8_t*)"Empty union group");
                };
                if ((qc_lib_unionstr_last(&(*qc_parse_unionlastvar).uflags)==(int64_t)69) || (qc_lib_unionstr_last(&(*qc_parse_unionlastvar).uflags)==(int64_t)42)) {
                } else {
                    qc_lib_unionstr_append(&(*qc_parse_unionlastvar).uflags,(int64_t)42);
                };
                qc_lib_unionstr_append(&(*qc_parse_unionlastvar).uflags,(int64_t)69);
                --qc_parse_unionstring.ulength;
            } else {
                goto L1146 ;
            };
        }else if (((int64_t)(qc_lex_lx.symbol)==(int64_t)6)) {
            qc_lex_lex();
        } else {
            if ((!!((uint64_t)(var_decls_typestarterset[((int64_t)(qc_lex_lx.symbol))])) || ((int64_t)(qc_lex_lx.symbol) == (int64_t)45))) {
                t = qc_parse_readtypespec(owner,(int64_t)0);
                qc_parse_readstructfields(owner,t);
            } else {
                goto L1146 ;
            };
        };
    }L1146 :;
    ;
    if (!(!!(typedefx))) {
        qc_parse_checksymbol((int64_t)13);
        qc_lex_lex();
    } else {
        qc_parse_checkbeginend(closesym,kwd,startline);
    };
    return m;
}

void qc_parse_readstructfields(struct var_decls_strec * owner,int64_t m) {
    int64_t nvars;
    struct var_decls_strec *  stname;
    nvars = (int64_t)0;
    L1147 :;
    while (((int64_t)(qc_lex_lx.symbol) == (int64_t)45)) {
        stname = qc_lib_getduplnameptr(owner,qc_lex_lx.symptr,(int64_t)13);
        qc_lib_storemode(owner,m,&(*stname).mode);
        ++nvars;
        if (!!((uint64_t)(qc_parse_unionpend.ulength))) {
            qc_lib_unionstr_copy(&(*stname).uflags,&qc_parse_unionpend);
            qc_lib_unionstr_concat(&qc_parse_unionstring,&qc_parse_unionpend);
            qc_lib_unionstr_clear(&qc_parse_unionpend);
        } else {
            qc_lib_unionstr_clear(&(*stname).uflags);
        };
        qc_parse_unionlastvar = stname;
        if ((qc_lib_getscope(owner) != (int64_t)2)) {
            qc_parse_addgenfield(qc_lex_lx.symptr);
        };
        qc_lib_adddef(owner,stname);
        qc_lex_lex();
        if (((int64_t)(qc_lex_lx.symbol) == (int64_t)21)) {
            qc_lex_lex();
            (*stname).attribs.ax_at = (uint64_t)((int64_t)1);
            (*stname).equiv = qc_parse_readequivfield(owner);
        } else if (((int64_t)(qc_lex_lx.symbol) == (int64_t)22)) {
            qc_lex_lex();
            qc_parse_checksymbol((int64_t)37);
            if ((qc_lex_lx.value==(int64_t)1) || (qc_lex_lx.value==(int64_t)2) || (qc_lex_lx.value==(int64_t)4) || (qc_lex_lx.value==(int64_t)8)) {
                (*stname).attribs.ax_align = (uint64_t)(qc_lex_lx.value);
            }else if ((qc_lex_lx.value==(int64_t)0)) {
                (*stname).attribs.ax_align = (uint64_t)((int64_t)255);
            } else {
                qc_support_serror((uint8_t*)"@@ bad align");
            };
            qc_lex_lex();
        };
        if (((int64_t)(qc_lex_lx.symbol) != (int64_t)5)) {
            goto L1149 ;
        };
        qc_lex_lex();
L1148 :;
    }L1149 :;
    ;
    if ((nvars == (int64_t)0)) {
        qc_support_serror((uint8_t*)"No fields declared");
    };
}

void qc_parse_readtabledef(struct var_decls_strec * owner,int64_t isglobal) {
    int64_t i;
    int64_t ncols;
    int64_t nrows;
    int64_t enums;
    int64_t nextenumvalue;
    int64_t firstval;
    int64_t lastval;
    int64_t startline;
    int64_t closesym;
    int64_t vartype;
    struct var_decls_unitrec *  plower;
    uint8_t *  enumtypename;
    struct var_decls_strec *  stvar;
    struct var_decls_strec *  stenum;
    struct var_decls_strec *  stgen;
    struct var_decls_strec *  varnameptrs[20];
    struct var_decls_unitrec *  plist[20];
    struct var_decls_unitrec *  plistx[20];
    int64_t enumvalues[500];
    qc_lex_lex();
    enums = (int64_t)0;
    enumtypename = (uint8_t *)(0);
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)12)) {
        enums = (int64_t)1;
        qc_lex_lex();
        if (((int64_t)(qc_lex_lx.symbol) == (int64_t)45)) {
            enumtypename = (*qc_lex_lx.symptr).name;
            qc_lex_lex();
        };
        qc_parse_checksymbol((int64_t)13);
        qc_lex_lex();
    };
    nextenumvalue = (int64_t)1;
    nrows = (int64_t)0;
    ncols = (int64_t)0;
    L1150 :;
    while (((int64_t)(qc_lex_lx.symbol) == (int64_t)45)) {
        if ((++ncols > (int64_t)20)) {
            qc_support_serror((uint8_t*)"tabledata/too many columns");
        };
        varnameptrs[(ncols)-1] = qc_lex_lx.symptr;
        qc_lex_lex();
        if (((int64_t)(qc_lex_lx.symbol) == (int64_t)5)) {
            qc_lex_lex();
        } else {
            goto L1152 ;
        };
L1151 :;
    }L1152 :;
    ;
    qc_parse_checkequals();
    qc_lex_lex();
    qc_parse_skipsemi();
    startline = qc_parse_getcurrline();
    closesym = qc_parse_checkbegin((int64_t)0);
    qc_parse_skipsemi();
    firstval = (lastval = (int64_t)0);
    L1153 :;
    for (i=(int64_t)1;i<=ncols;i+=(int64_t)1) {
L1154 :;
        plist[(i)-1] = (plistx[(i)-1] = (struct var_decls_unitrec *)(0));
L1155 :;
    }L1156 :;
    ;
    qc_parse_intabledata = (int64_t)1;
    L1157 :;
    while (1) {
        qc_parse_skipsemi();
        qc_parse_checksymbol((int64_t)12);
        qc_lex_lex();
        if ((++nrows > (int64_t)500)) {
            qc_support_serror((uint8_t*)"tabledata:too many rows");
        };
        if (!!(enums)) {
            qc_parse_checksymbol((int64_t)45);
            stgen = qc_lex_lx.symptr;
            qc_parse_tabledataname = (*stgen).name;
            qc_lex_lex();
            if ((((int64_t)(qc_lex_lx.symbol) == (int64_t)31) && ((int64_t)(qc_lex_lx.subcode) == (int64_t)98))) {
                qc_lex_lex();
                nextenumvalue = qc_parse_readconstint();
            };
            enumvalues[(nrows)-1] = nextenumvalue;
            stenum = qc_lib_getduplnameptr(owner,stgen,(int64_t)9);
            (*stenum).mode = (int64_t)1;
            (*stenum).code = qc_lib_createconstunit((uint64_t)(nextenumvalue),(int64_t)1);
            (*stenum).attribs.ax_global = (uint64_t)(isglobal);
            qc_lib_adddef(owner,stenum);
            if ((nrows == (int64_t)1)) {
                firstval = nextenumvalue;
            };
            lastval = nextenumvalue;
            ++nextenumvalue;
            if (!!(ncols)) {
                qc_parse_checksymbol((int64_t)5);
            };
            qc_lex_lex();
        };
        L1159 :;
        for (i=(int64_t)1;i<=ncols;i+=(int64_t)1) {
L1160 :;
            qc_parse_addlistunit(&plist[(i)-1],&plistx[(i)-1],qc_parse_readexpression());
            if ((i == ncols)) {
                qc_parse_checksymbol((int64_t)13);
            } else {
                qc_parse_checksymbol((int64_t)5);
            };
            qc_lex_lex();
L1161 :;
        }L1162 :;
        ;
        if (((int64_t)(qc_lex_lx.symbol) != (int64_t)5)) {
            goto L1158 ;
        };
        qc_lex_lex();
        if (((int64_t)(qc_lex_lx.symbol) == closesym)) {
            goto L1158 ;
        };
    }L1158 :;
    ;
    qc_parse_intabledata = (int64_t)0;
    qc_parse_skipsemi();
    qc_parse_checkbeginend(closesym,(int64_t)125,startline);
    if ((nrows == (int64_t)0)) {
        qc_support_serror((uint8_t*)"No table data");
    };
    vartype = (int64_t)35;
    L1163 :;
    for (i=(int64_t)1;i<=ncols;i+=(int64_t)1) {
L1164 :;
        stvar = qc_lib_getduplnameptr(owner,varnameptrs[(i)-1],(int64_t)10);
        if (!!(enums)) {
            plower = qc_lib_createconstunit((uint64_t)(enumvalues[((int64_t)1)-1]),(int64_t)1);
        } else {
            plower = (struct var_decls_unitrec *)(0);
        };
        (*stvar).code = qc_lib_createunit2((int64_t)79,plist[(i)-1],plower);
        (*stvar).attribs.ax_global = (uint64_t)(isglobal);
        qc_lib_adddef(owner,stvar);
L1165 :;
    }L1166 :;
    ;
}

void qc_parse_readclassdef(struct var_decls_strec * owner,int64_t isglobal) {
    int64_t kwd;
    int64_t baseclass;
    int64_t m;
    int64_t startline;
    int64_t closesym;
    int64_t mrec;
    struct var_decls_strec *  nameptr;
    struct var_decls_strec *  sttype;
    kwd = (int64_t)(qc_lex_lx.symbol);
    qc_lex_lex();
    qc_parse_checksymbol((int64_t)45);
    nameptr = qc_lex_lx.symptr;
    qc_lex_lex();
    baseclass = (int64_t)0;
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)12)) {
        qc_lex_lex();
        baseclass = qc_parse_readtypespec(owner,(int64_t)0);
        qc_parse_checksymbol((int64_t)13);
        qc_lex_lex();
    };
    qc_parse_checkequals();
    qc_lex_lex();
    sttype = qc_lib_getduplnameptr(owner,nameptr,(int64_t)4);
    qc_lib_adddef(owner,sttype);
    m = qc_lib_createusertype(sttype);
    mrec = qc_lib_createrecordmode(owner,(int64_t)32,m);
    (*sttype).mode = mrec;
    if (!!(baseclass)) {
        if ((baseclass > (int64_t)0)) {
            qc_support_serror((uint8_t*)"baseclass?");
        };
        if ((var_decls_nbaseclasses >= (int64_t)255)) {
            qc_support_serror((uint8_t*)"Too many base classes");
        };
        ++var_decls_nbaseclasses;
        qc_lib_storemode(owner,baseclass,&var_decls_baseclasstable[(var_decls_nbaseclasses)]);
        (*sttype).attribs.ax_baseclass = (uint64_t)(var_decls_nbaseclasses);
        var_decls_baseclassdef[(var_decls_nbaseclasses)] = sttype;
    };
    closesym = qc_parse_checkbegin((int64_t)1);
    startline = qc_parse_getcurrline();
    qc_parse_readclassbody(sttype,kwd);
    qc_parse_checkbeginend(closesym,kwd,startline);
    (*sttype).attribs.ax_global = (uint64_t)(isglobal);
}

static void qc_parse_readclassbody(struct var_decls_strec * owner,int64_t classkwd) {
    L1167 :;
    switch ((int64_t)(qc_lex_lx.symbol)) {
    case 99:;
    {
        qc_parse_readconstdef(owner,(int64_t)0);
    }break;
    case 100:;
    {
        qc_parse_readrecordfields(owner);
    }break;
    case 85:;
    case 84:;
    case 83:;
    {
        qc_parse_readprocdef(owner,(int64_t)0,(int64_t)0);
    }break;
    case 105:;
    {
        qc_lex_lex();
        qc_support_serror((uint8_t*)"CLASS CLASS");
    }break;
    case 86:;
    {
        qc_lex_lex();
        qc_support_serror((uint8_t*)"CLASS RECORD");
    }break;
    case 95:;
    {
        qc_lex_lex();
        qc_support_serror((uint8_t*)"CLASS TYPE");
    }break;
    case 57:;
    case 13:;
    case 17:;
    {
        goto L1168 ;
    }break;
    case 33:;
    {
        qc_support_serror((uint8_t*)"Class eof?");
        goto L1168 ;
    }break;
    case 6:;
    {
        qc_lex_lex();
    }break;
    default: {
        if (!!((uint64_t)(var_decls_typestarterset[((int64_t)(qc_lex_lx.symbol))]))) {
            qc_support_serror((uint8_t*)"Packed types not allowed in class");
        } else {
            qc_support_serror((uint8_t*)"Unknown class decl");
        };
    }
    } //SW
goto L1167 ;
L1168 :;
    ;
}

static int64_t qc_parse_readenumtype(struct var_decls_strec * owner,int64_t typedefx,int64_t isglobal) {
    struct var_decls_strec *  enumowner;
    struct var_decls_strec *  stname;
    struct var_decls_strec *  nameptr;
    int64_t isanon;
    int64_t index;
    int64_t startline;
    int64_t closesym;
    enumowner = owner;
    isanon = (int64_t)0;
    if (!(!!(typedefx))) {
        if (((int64_t)(qc_lex_lx.symbol) == (int64_t)45)) {
            stname = qc_lib_getduplnameptr(owner,qc_lex_lx.symptr,(int64_t)4);
            owner = stname;
            qc_lex_lex();
            qc_parse_checkequals();
            qc_lex_lex();
            qc_lib_adddef(enumowner,owner);
        } else {
            isanon = (int64_t)1;
        };
        qc_parse_checksymbol((int64_t)12);
        qc_lex_lex();
    } else {
        owner = var_decls_ttnamedef[(typedefx)];
        startline = qc_parse_getcurrline();
        closesym = qc_parse_checkbegin((int64_t)1);
    };
    index = (int64_t)1;
    L1169 :;
    while (((int64_t)(qc_lex_lx.symbol) == (int64_t)45)) {
        nameptr = qc_lex_lx.symptr;
        qc_lex_lex();
        if ((((int64_t)(qc_lex_lx.symbol) == (int64_t)31) && ((int64_t)(qc_lex_lx.subcode) == (int64_t)98))) {
            qc_lex_lex();
            index = qc_parse_readconstint();
        };
        if (!(!!(isanon))) {
            stname = qc_lib_getduplnameptr(owner,nameptr,(int64_t)15);
            (*stname).index = index;
            (*stname).mode = (int64_t)1;
            qc_lib_adddef(owner,stname);
        } else {
            stname = qc_lib_getduplnameptr(enumowner,nameptr,(int64_t)9);
            (*stname).code = qc_lib_createconstunit((uint64_t)(index),(int64_t)1);
            (*stname).mode = (int64_t)1;
            qc_lib_adddef(enumowner,stname);
        };
        ++index;
        (*stname).attribs.ax_global = (uint64_t)(isglobal);
        if (((int64_t)(qc_lex_lx.symbol) != (int64_t)5)) {
            goto L1171 ;
        };
        qc_lex_lex();
L1170 :;
    }L1171 :;
    ;
    if (!(!!(typedefx))) {
        qc_parse_checksymbol((int64_t)13);
        qc_lex_lex();
    } else {
        qc_parse_checkbeginend(closesym,(int64_t)103,startline);
    };
    if (!(!!(isanon))) {
        return qc_lib_createenummode(owner,typedefx);
    } else {
        return (int64_t)0;
    };
}

void qc_parse_readrecordfields(struct var_decls_strec * owner) {
    int64_t m;
    int64_t nvars;
    struct var_decls_strec *  stname;
    qc_lex_lex();
    m = (int64_t)35;
    nvars = (int64_t)0;
    L1172 :;
    while (((int64_t)(qc_lex_lx.symbol) == (int64_t)45)) {
        stname = qc_lib_getduplnameptr(owner,qc_lex_lx.symptr,(int64_t)13);
        (*stname).mode = m;
        ++nvars;
        if ((qc_lib_getscope(owner) != (int64_t)2)) {
            qc_parse_addgenfield(qc_lex_lx.symptr);
        };
        qc_lib_adddef(owner,stname);
        qc_lex_lex();
        if (((int64_t)(qc_lex_lx.symbol) == (int64_t)21)) {
            qc_lex_lex();
            (*stname).attribs.ax_at = (uint64_t)((int64_t)1);
            (*stname).equiv = qc_parse_readequivfield(owner);
        };
        if (((int64_t)(qc_lex_lx.symbol) != (int64_t)5)) {
            goto L1174 ;
        };
        qc_lex_lex();
L1173 :;
    }L1174 :;
    ;
    if ((nvars == (int64_t)0)) {
        qc_support_serror((uint8_t*)"No fields declared");
    };
}

static void qc_parse_readimportmodule(struct var_decls_strec * owner) {
    int64_t isnew;
    int64_t startline;
    int64_t closesym;
    struct var_decls_strec *  d;
    struct var_decls_strec *  stname;
    qc_lex_lex();
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)42)) {
        stname = qc_lex_addnamestr(qc_lex_lx.svalue);
    } else {
        qc_parse_checksymbol((int64_t)45);
        stname = qc_lex_lx.symptr;
    };
    qc_lex_lex();
    qc_parse_checkequals();
    qc_lex_lex();
    isnew = (int64_t)1;
    d = (*stname).nextdupl;
    L1175 :;
    while (!!(d)) {
        if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)3)) {
            stname = d;
            isnew = (int64_t)0;
            goto L1177 ;
        };
        d = (*d).nextdupl;
L1176 :;
    }L1177 :;
    ;
    if (!!(isnew)) {
        stname = qc_lib_getduplnameptr(var_decls_stprogram,stname,(int64_t)3);
        if (!!(mlib_eqstring((*stname).name,(uint8_t*)"sys"))) {
            var_decls_stsysmodule = stname;
        };
        qc_lib_adddef(var_decls_stprogram,stname);
        if ((var_decls_ndlltable >= (int64_t)50)) {
            qc_support_serror((uint8_t*)"Too many DLL libs");
        };
        var_decls_dlltable[(++var_decls_ndlltable)-1] = (*stname).name;
        var_decls_dllsttable[(var_decls_ndlltable)-1] = stname;
        (*stname).attribs.ax_dllindex = (uint64_t)(var_decls_ndlltable);
    };
    startline = qc_parse_getcurrline();
    closesym = qc_parse_checkbegin((int64_t)0);
    qc_parse_currimport = stname;
    qc_parse_readimportbody(var_decls_stmodule);
    qc_parse_currimport = (struct var_decls_strec *)(0);
    qc_parse_checkbeginend(closesym,(int64_t)90,startline);
}

static void qc_parse_readimportbody(struct var_decls_strec * owner) {
    int64_t lineno;
    int64_t fflang;
    lineno = (int64_t)(qc_lex_lx.lineno);
    L1178 :;
    while (1) {
        qc_parse_skipsemi();
        switch ((int64_t)(qc_lex_lx.symbol)) {
        case 109:;
        {
            fflang = (int64_t)(qc_lex_lx.subcode);
            qc_lex_lex();
            if (((int64_t)(qc_lex_lx.symbol)==(int64_t)83) || ((int64_t)(qc_lex_lx.symbol)==(int64_t)84) || ((int64_t)(qc_lex_lx.symbol)==(int64_t)85)) {
                qc_parse_readprocdecl(owner,(int64_t)0,fflang);
            };
        }break;
        case 83:;
        case 84:;
        case 85:;
        {
            qc_parse_readprocdecl(owner,(int64_t)0,(int64_t)0);
        }break;
        case 100:;
        {
            qc_parse_readvardef(owner,(int64_t)0,(int64_t)0,(int64_t)10);
        }break;
        case 95:;
        {
            qc_parse_readtypedef(owner,(int64_t)0);
        }break;
        case 99:;
        {
            qc_parse_readconstdef(owner,(int64_t)0);
        }break;
        case 105:;
        case 86:;
        {
            qc_parse_readclassdef(owner,(int64_t)0);
        }break;
        case 33:;
        {
            goto L1179 ;
        }break;
        case 57:;
        {
            goto L1179 ;
        }break;
        default: {
            qc_lex_ps1((uint8_t*)"symbol");
            qc_support_serror((uint8_t*)"Not allowed in importmodule");
        }
        } //SW
;
    }L1179 :;
    ;
}

static struct var_decls_strec * qc_parse_createprocdef(struct var_decls_strec * owner,struct var_decls_strec * stname,int64_t id,uint8_t * truename) {
    struct var_decls_strec *  d;
    struct var_decls_strec *  e;
    struct var_decls_unitrec *  u;
    d = qc_lib_getduplnameptr(owner,stname,id);
    qc_lib_adddef(owner,d);
    qc_lib_addtoproclist(d);
    (*d).index = (int64_t)0;
    if ((id == (int64_t)6)) {
        if ((var_decls_ndllproctable >= (int64_t)2000)) {
            qc_support_serror((uint8_t*)"Too many DLL procs");
        };
        ++var_decls_ndllproctable;
        if (!(!!(truename))) {
            truename = (*d).name;
        };
        (*d).truename = truename;
        var_decls_dllproctable[(var_decls_ndllproctable)-1].name = truename;
        var_decls_dllproctable[(var_decls_ndllproctable)-1].dllindex = (int64_t)((*qc_parse_currimport).attribs.ax_dllindex);
        (*d).index = var_decls_ndllproctable;
    } else {
        e = (*stname).nextdupl;
        L1180 :;
        while (!!(e)) {
            if ((((int64_t)((uint64_t)((*e).nameid)) == (int64_t)5) && !!((*e).callchain))) {
                u = (*e).callchain;
                L1183 :;
                do {
                    if (((int64_t)((*u).tag) != (int64_t)3)) {
                        qc_support_serror((uint8_t*)"CPD1");
                    };
                    (*u).def = d;
                    u = (*u).c;
L1184 :;
                } while (!(u == 0));L1185 :;
                ;
            };
            e = (*e).nextdupl;
L1181 :;
        }L1182 :;
        ;
    };
    return d;
}

static struct var_decls_strec * qc_parse_readequivfield(struct var_decls_strec * owner) {
    struct var_decls_strec *  p;
    struct var_decls_strec *  d;
    qc_parse_checksymbol((int64_t)45);
    d = qc_lex_lx.symptr;
    qc_lex_lex();
    p = (*owner).deflist;
    L1186 :;
    while (!!(p)) {
        if (!!(mlib_eqstring((*p).name,(*d).name))) {
            return p;
        };
        p = (*p).nextdef;
L1187 :;
    }L1188 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((*d).name,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    qc_support_serror((uint8_t*)"Can't find @ field");
    return (struct var_decls_strec *)(0);
}

static struct var_decls_unitrec * qc_parse_testconstruct(struct var_decls_unitrec * p) {
    struct var_decls_unitrec *  q;
    struct var_decls_unitrec *  paramlist;
    struct var_decls_unitrec *  r;
    struct var_decls_strec *  d;
    int64_t mode;
    q = (*p).a;
    d = (*q).def;
    if (!((((int64_t)((*q).tag) == (int64_t)3) && ((int64_t)((uint64_t)((*d).nameid)) == (int64_t)4)))) {
        return p;
    };
    paramlist = (*p).b;
    mode = (int64_t)((*d).mode);
    (*p).tag = (int64_t)80;
    (*p).a = paramlist;
    (*p).b = (struct var_decls_unitrec *)(0);
    r = qc_lib_createunit1((int64_t)149,p);
    (*r).mode = mode;
    return r;
}

static struct var_decls_unitrec * qc_parse_readapplyop(int64_t inexpr) {
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  a;
    struct var_decls_unitrec *  b;
    qc_lex_lex();
    qc_parse_checksymbol((int64_t)12);
    qc_lex_lex();
    p = qc_parse_readexpression();
    qc_parse_checksymbol((int64_t)5);
    qc_lex_lex();
    a = qc_parse_readexpression();
    b = (struct var_decls_unitrec *)(0);
    if (((int64_t)(qc_lex_lx.symbol) == (int64_t)5)) {
        qc_lex_lex();
        b = qc_parse_readexpression();
    };
    qc_parse_checksymbol((int64_t)13);
    qc_lex_lex();
    return qc_lib_createunit3((!!(inexpr)?(int64_t)96:(int64_t)95),p,a,b);
}

static void qc_parse_readapplprocs(struct var_decls_strec * owner) {
    int64_t nprocs;
    struct var_decls_strec *  stname;
    qc_lex_lex();
    nprocs = (int64_t)0;
    L1189 :;
    while (((int64_t)(qc_lex_lx.symbol) == (int64_t)45)) {
        ++nprocs;
        stname = qc_parse_findapplproc((*qc_lex_lx.symptr).name);
        if ((stname == 0)) {
            stname = qc_lib_getduplnameptr(owner,qc_lex_lx.symptr,(int64_t)8);
            (*stname).attribs.ax_global = (uint64_t)((int64_t)1);
            qc_lib_adddef(owner,stname);
            qc_parse_addapplproc(stname);
        };
        qc_lex_lex();
        if (((int64_t)(qc_lex_lx.symbol) != (int64_t)5)) {
            goto L1191 ;
        };
        qc_lex_lex();
L1190 :;
    }L1191 :;
    ;
    if ((nprocs == (int64_t)0)) {
        qc_support_serror((uint8_t*)"No procs declared");
    };
}

static struct var_decls_strec * qc_parse_defineapplproc(void) {
    struct var_decls_strec *  d;
    if ((var_decls_currproc == 0)) {
        qc_support_serror((uint8_t*)"appl. outside of proc");
    };
    d = qc_parse_findapplproc((*qc_lex_lx.symptr).name);
    if (!!(d)) {
        return d;
    };
    d = qc_lib_getduplnameptr(var_decls_currproc,qc_lex_lx.symptr,(int64_t)8);
    qc_lib_adddef(var_decls_currproc,d);
    qc_parse_addapplproc(d);
    return d;
}

static struct var_decls_strec * qc_parse_findapplproc(uint8_t * name) {
    int64_t i;
    L1192 :;
    for (i=(int64_t)1;i<=var_decls_napplproctable;i+=(int64_t)1) {
L1193 :;
        if (!!(mlib_eqstring((*var_decls_applproctable[(i)-1]).name,name))) {
            return var_decls_applproctable[(i)-1];
        };
L1194 :;
    }L1195 :;
    ;
    return (struct var_decls_strec *)(0);
}

static void qc_parse_addapplproc(struct var_decls_strec * d) {
    if ((var_decls_napplproctable >= (int64_t)500)) {
        qc_support_serror((uint8_t*)"Too many appl procs");
    };
    var_decls_applproctable[(++var_decls_napplproctable)-1] = d;
    (*d).index = var_decls_napplproctable;
}

static struct var_decls_unitrec * qc_parse_readapplcall(void) {
    struct var_decls_unitrec *  p;
    struct var_decls_strec *  d;
    qc_lex_lex();
    qc_parse_checksymbol((int64_t)2);
    qc_lex_lex();
    qc_parse_checksymbol((int64_t)45);
    d = qc_parse_defineapplproc();
    p = qc_lib_createname(d);
    (*p).lineno = (int64_t)(qc_lex_lx.lineno);
    if (((int64_t)(qc_lex_nextlx.symbol) == (int64_t)12)) {
        (*p).def = d;
    };
    p = qc_lib_createunit1((int64_t)68,p);
    qc_lex_lex();
    qc_parse_checksymbol((int64_t)12);
    return p;
}

static struct var_decls_strec * qc_lib_newstrec(void) {
    struct var_decls_strec *  p;
    p = (struct var_decls_strec *)(mlib_pcm_alloc((int64_t)136));
    memset((void *)(p),(int64_t)0,(uint64_t)((int64_t)136));
    (*p).lineno = (int64_t)(qc_lex_lx.lineno);
    (*p).attribs.ax_moduleno = (uint64_t)(var_decls_currmoduleno);
    return p;
}

void qc_lib_initqclib(void) {
    int64_t i;
    int64_t av_1;
    int64_t av_2;
    int64_t av_3;
    L1196 :;
    for (i=(int64_t)1;i<=(int64_t)36;i+=(int64_t)1) {
L1197 :;
        qc_tables_jtagpriotable[(qc_tables_oplist[(i)-1])] = (uint64_t)(qc_tables_oppriolist[(i)-1]);
L1198 :;
    }L1199 :;
    ;
    L1200 :;
    for (i=(int64_t)1;i<=(int64_t)24;i+=(int64_t)1) {
L1201 :;
        var_decls_exprstarterset[(qc_tables_d_exprstarterset[(i)-1])] = (uint64_t)((int64_t)1);
L1202 :;
    }L1203 :;
    ;
    L1204 :;
    for (i=(int64_t)1;i<=(int64_t)6;i+=(int64_t)1) {
L1205 :;
        var_decls_typestarterset[(qc_tables_d_typestarterset[(i)-1])] = (uint64_t)((int64_t)1);
L1206 :;
    }L1207 :;
    ;
    qc_tables_hostlvset[((int64_t)22)] = (uint64_t)((int64_t)1);
    qc_tables_hostlvset[((int64_t)23)] = (uint64_t)((int64_t)1);
    qc_tables_condopset[((int64_t)98)] = (uint64_t)((int64_t)1);
    qc_tables_condopset[((int64_t)99)] = (uint64_t)((int64_t)1);
    qc_tables_condopset[((int64_t)100)] = (uint64_t)((int64_t)1);
    qc_tables_condopset[((int64_t)101)] = (uint64_t)((int64_t)1);
    qc_tables_condopset[((int64_t)103)] = (uint64_t)((int64_t)1);
    qc_tables_condopset[((int64_t)102)] = (uint64_t)((int64_t)1);
}

struct var_decls_strec * qc_lib_getduplnameptr(struct var_decls_strec * owner,struct var_decls_strec * symptr,int64_t id) {
    struct var_decls_strec *  p;
    struct var_decls_strec *  q;
    p = qc_lib_newstrec();
    (*p).name = (*symptr).name;
    (*p).namelen = (uint64_t)((*symptr).namelen);
    (*p).symbol = (uint64_t)((int64_t)45);
    (*p).owner = owner;
    (*p).nameid = (uint64_t)(id);
    if (((id == (int64_t)11) || (id == (int64_t)12))) {
        (*p).attribs.ax_frame = (uint64_t)((int64_t)1);
    };
    if (!!((q = (*symptr).nextdupl))) {
        (*q).prevdupl = p;
    };
    (*p).nextdupl = q;
    (*p).prevdupl = symptr;
    (*p).firstdupl = symptr;
    (*symptr).nextdupl = p;
    return p;
}

void qc_lib_adddef(struct var_decls_strec * owner,struct var_decls_strec * p) {
    struct var_decls_strec *  q;
    if (!!((q = (*p).nextdupl))) {
        if (((*q).owner == owner)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((*q).name,NULL);
            msysnewc_m_print_str((uint8_t*)"in",NULL);
            msysnewc_m_print_str((*owner).name,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            qc_support_serror((uint8_t*)"Duplicate name");
        };
    };
    (*p).nextdef = (*owner).deflist;
    (*owner).deflist = p;
}

void qc_lib_adddef_nodupl(struct var_decls_strec * owner,struct var_decls_strec * p) {
    (*p).nextdef = (*owner).deflist;
    (*owner).deflist = p;
}

void qc_lib_printst(void * f,struct var_decls_strec * p,int64_t level) {
    struct var_decls_strec *  q;
    if (((int64_t)((uint64_t)((*p).symbol)) != (int64_t)45)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"PRINTST not name\n\n\n",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit(0);
    };
    qc_lib_printstrec(f,p,level);
    q = (*p).deflist;
    L1208 :;
    while ((q != 0)) {
        qc_lib_printst(f,q,(level + (int64_t)1));
        q = (*q).nextdef;
L1209 :;
    }L1210 :;
    ;
}

static void qc_lib_printstrec(void * f,struct var_decls_strec * p,int64_t level) {
    struct var_decls_attribrec attrs;
    struct mlib_strbuffer v;
    struct mlib_strbuffer *  d;
    int64_t col;
    int64_t offset;
    int64_t t;
    uint8_t str[2560];
    int64_t av_1;
    d = &v;
    mlib_gs_init(d);
    offset = (int64_t)0;
    av_1 = level;
    while (av_1-- > 0) {
L1211 :;
        mlib_gs_str(d,(uint8_t*)"    ");
        offset += (int64_t)4;
L1212 :;
    }L1213 :;
    ;
    mlib_gs_str(d,(uint8_t*)":");
    mlib_gs_leftstr(d,(*p).name,((int64_t)23 - offset),(int64_t)45);
    mlib_gs_leftstr(d,pq_common_namenames[((int64_t)((*p).nameid))],(int64_t)12,(int64_t)46);
    col = mlib_gs_getcol(d);
    attrs = (*p).attribs;
    strcpy((int8_t *)(str),(int8_t *)((uint8_t*)"["));
    if ((qc_lib_getscope(p)==(int64_t)1)) {
        strcat((int8_t *)(str),(int8_t *)((uint8_t*)" L"));
    }else if ((qc_lib_getscope(p)==(int64_t)3)) {
        strcat((int8_t *)(str),(int8_t *)((uint8_t*)" G"));
    }else if ((qc_lib_getscope(p)==(int64_t)2)) {
        strcat((int8_t *)(str),(int8_t *)((uint8_t*)" E"));
    };
    if (!!((uint64_t)(attrs.ax_static))) {
        strcat((int8_t *)(str),(int8_t *)((uint8_t*)" S"));
    };
    if (!!((uint64_t)(attrs.ax_fflang))) {
        strcat((int8_t *)(str),(int8_t *)((uint8_t*)" "));
        strcat((int8_t *)(str),(int8_t *)(qc_tables_fflangnames[((int64_t)(attrs.ax_fflang))]));
    };
    if (!!((uint64_t)(attrs.ax_byrefmode))) {
        strcat((int8_t *)(str),(int8_t *)((uint8_t*)" BR"));
    };
    if (!!((uint64_t)(attrs.ax_align))) {
        strcat((int8_t *)(str),(int8_t *)((uint8_t*)" @@"));
        strcat((int8_t *)(str),(int8_t *)(msysnewc_strint((int64_t)(attrs.ax_align),(uint8_t *)(0))));
        strcat((int8_t *)(str),(int8_t *)((uint8_t*)" "));
    };
    if (!!((uint64_t)(attrs.ax_optional))) {
        strcat((int8_t *)(str),(int8_t *)((uint8_t*)" Opt"));
    };
    if (!!((uint64_t)(attrs.ax_varparams))) {
        strcat((int8_t *)(str),(int8_t *)((uint8_t*)" VP"));
    };
    if (!!((uint64_t)(attrs.ax_used))) {
        strcat((int8_t *)(str),(int8_t *)((uint8_t*)" Used"));
    };
    if (!!((uint64_t)(attrs.ax_frame))) {
        strcat((int8_t *)(str),(int8_t *)((uint8_t*)" F"));
    };
    if (!!((uint64_t)(attrs.ax_autovar))) {
        strcat((int8_t *)(str),(int8_t *)((uint8_t*)" A"));
    };
    if (!!((uint64_t)(attrs.ax_nparams))) {
        strcat((int8_t *)(str),(int8_t *)((uint8_t*)" Pm:"));
        strcat((int8_t *)(str),(int8_t *)(msysnewc_strint((int64_t)(attrs.ax_nparams),(uint8_t *)(0))));
    };
    if (!!((uint64_t)(attrs.ax_moduleno))) {
        strcat((int8_t *)(str),(int8_t *)((uint8_t*)" M:"));
        strcat((int8_t *)(str),(int8_t *)(msysnewc_strint((int64_t)(attrs.ax_moduleno),(uint8_t *)(0))));
    };
    strcat((int8_t *)(str),(int8_t *)((uint8_t*)"]"));
    if (((uint64_t)(str[((int64_t)2)-1]) == ' ')) {
        str[((int64_t)2)-1] = '[';
        mlib_gs_leftstr(d,&str[((int64_t)2)-1],(int64_t)16,(int64_t)32);
    } else {
        mlib_gs_leftstr(d,str,(int64_t)16,(int64_t)32);
    };
    if (((int64_t)((*p).mode)==(int64_t)0)) {
        mlib_gs_str(d,(uint8_t*)" Vd");
    }else if (((int64_t)((*p).mode)==(int64_t)35)) {
        mlib_gs_str(d,(uint8_t*)" Va");
    } else {
        mlib_gs_str(d,(uint8_t*)" ");
        strcpy((int8_t *)(str),(int8_t *)(qc_lib_strmode((int64_t)((*p).mode),(int64_t)1)));
        mlib_gs_leftstr(d,str,(int64_t)12,(int64_t)32);
    };
    if (((int64_t)((*p).nameid)==(int64_t)13) || ((int64_t)((*p).nameid)==(int64_t)12)) {
        mlib_gs_str(d,(uint8_t*)" Off:");
        mlib_gs_strint(d,(int64_t)((*p).offset));
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_u64((*p).uflags.ulength,(uint8_t*)"v");
        msysnewc_m_print_str((uint8_t *)(&(*p).uflags.codes),(uint8_t*)".*");
        msysnewc_m_print_end();
        ;
        if (!!((*p).code)) {
            mlib_gs_str(d,(uint8_t*)" DEFAULT:");
            mlib_gs_strvar(d,qc_lib_strexpr((*p).code));
        };
    }else if (((int64_t)((*p).nameid)==(int64_t)14)) {
        mlib_gs_str(d,(uint8_t*)" Ind:");
        mlib_gs_strint(d,(int64_t)((*p).offset));
    }else if (((int64_t)((*p).nameid)==(int64_t)5)) {
        mlib_gs_str(d,(uint8_t*)" Ind:");
        mlib_gs_strint(d,(int64_t)((*p).index));
        mlib_gs_str(d,(uint8_t*)" Addr:");
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_ptr((*p).address,(uint8_t*)"H");
        msysnewc_m_print_end();
        ;
        mlib_gs_str(d,str);
        if (!!((*p).docstring)) {
            mlib_gs_str(d,(uint8_t*)"{");
            mlib_gs_str(d,(*p).docstring);
            mlib_gs_str(d,(uint8_t*)"}");
        };
    }else if (((int64_t)((*p).nameid)==(int64_t)6)) {
        mlib_gs_str(d,(uint8_t*)" DLLProc#:");
        mlib_gs_strint(d,(int64_t)((*p).index));
        if (!!((*p).truename)) {
            mlib_gs_str(d,(uint8_t*)" Truename:");
            mlib_gs_str(d,(*p).truename);
        };
    }else if (((int64_t)((*p).nameid)==(int64_t)8)) {
        mlib_gs_str(d,(uint8_t*)" APPLProc#:");
        mlib_gs_strint(d,(int64_t)((*p).index));
    }else if (((int64_t)((*p).nameid)==(int64_t)9)) {
        mlib_gs_str(d,(uint8_t*)" Const:");
        mlib_gs_strvar(d,qc_lib_strexpr((*p).code));
    }else if (((int64_t)((*p).nameid)==(int64_t)4)) {
        if (!!((t = (int64_t)((*p).attribs.ax_baseclass)))) {
            mlib_gs_str(d,(uint8_t*)" Baseclass:");
            if ((t < (int64_t)255)) {
                mlib_gs_str(d,var_decls_ttname[(t)]);
            } else {
                mlib_gs_str(d,(uint8_t*)"(Unavailable,>=255)");
            };
        };
    }else if (((int64_t)((*p).nameid)==(int64_t)15)) {
        mlib_gs_str(d,(uint8_t*)" Enum:");
        mlib_gs_strint(d,(int64_t)((*p).index));
    }else if (((int64_t)((*p).nameid)==(int64_t)3)) {
        mlib_gs_str(d,(uint8_t*)" DLL#:");
        mlib_gs_strint(d,(int64_t)((*p).attribs.ax_dllindex));
    }else if (((int64_t)((*p).nameid)==(int64_t)16)) {
        mlib_gs_str(d,(uint8_t*)" L");
        mlib_gs_strint(d,(int64_t)((*p).index));
    };
    if (!!((*p).equiv)) {
        if (((int64_t)((*p).nameid)==(int64_t)18)) {
            mlib_gs_str(d,(uint8_t*)" Alias for:");
            mlib_gs_str(d,(*(*p).equiv).name);
        }else if (((int64_t)((*p).nameid)==(int64_t)19)) {
            mlib_gs_str(d,(uint8_t*)" Link to:");
            mlib_gs_str(d,qc_lib_getdottedname((*p).equiv));
        } else {
            if (!!((uint64_t)((*p).attribs.ax_at))) {
                mlib_gs_str(d,(uint8_t*)" @");
                mlib_gs_str(d,(*(*p).equiv).name);
            };
        };
        mlib_gs_str(d,(uint8_t*)" ");
    };
    mlib_gs_str(d,(uint8_t*)" Lineno:");
    mlib_gs_strint(d,(int64_t)((*p).lineno));
    mlib_gs_println(d,f);
}

void qc_lib_printstflat(void * f) {
    int64_t i;
    struct var_decls_strec *  p;
    int64_t av_1;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((uint8_t*)"GLOBAL SYMBOL TABLE:",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L1214 :;
    for (i=(int64_t)0;i<=(int64_t)32766;i+=(int64_t)1) {
L1215 :;
        p = &qc_lex_hashtable[(i)];
        if (!!((*p).name)) {
            if (((int64_t)((*p).symbol)==(int64_t)34) || ((int64_t)((*p).symbol)==(int64_t)47)) {
                msysnewc_m_print_startfile(f);
                msysnewc_m_print_i64(i,NULL);
                msysnewc_m_print_ptr(p,NULL);
                msysnewc_m_print_str((uint8_t*)":",NULL);
                msysnewc_m_print_str((*p).name,NULL);
                msysnewc_m_print_str(qc_tables_symbolnames[((int64_t)((*p).symbol))-1],NULL);
                msysnewc_m_print_str(pq_common_namenames[((int64_t)((*p).nameid))],NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                if (((int64_t)((uint64_t)((*p).symbol)) == (int64_t)47)) {
                    msysnewc_m_print_startfile(f);
                    msysnewc_m_print_str((uint8_t*)"\t\t\t",NULL);
                    msysnewc_m_print_str((*p).macrovalue,NULL);
                    msysnewc_m_print_newline();
                    msysnewc_m_print_end();
                    ;
                };
                p = (*p).nextdupl;
                L1218 :;
                while (!!(p)) {
                    msysnewc_m_print_startfile(f);
                    msysnewc_m_print_str((uint8_t*)"\t",NULL);
                    msysnewc_m_print_ptr(p,NULL);
                    msysnewc_m_print_str((*p).name,NULL);
                    msysnewc_m_print_str(qc_tables_symbolnames[((int64_t)((*p).symbol))-1],NULL);
                    msysnewc_m_print_str(pq_common_namenames[((int64_t)((*p).nameid))],NULL);
                    msysnewc_m_print_ptr((*p).prevdupl,NULL);
                    msysnewc_m_print_str((uint8_t*)"(From",NULL);
                    msysnewc_m_print_str((!!((*p).owner)?(*(*p).owner).name:(uint8_t*)"-"),NULL);
                    msysnewc_m_print_nogap();
                    msysnewc_m_print_str((uint8_t*)")",NULL);
                    msysnewc_m_print_newline();
                    msysnewc_m_print_end();
                    ;
                    p = (*p).nextdupl;
L1219 :;
                }L1220 :;
                ;
            };
        };
L1216 :;
    }L1217 :;
    ;
}

static struct var_decls_unitrec * qc_lib_newunitrec(void) {
    struct var_decls_unitrec *  p;
    p = (struct var_decls_unitrec *)(mlib_pcm_alloc((int64_t)56));
    memset((void *)(p),(int64_t)0,(uint64_t)((int64_t)56));
    (*p).lineno = (int64_t)(qc_lex_lx.lineno);
    (*p).moduleno = var_decls_currmoduleno;
    return p;
}

struct var_decls_unitrec * qc_lib_createname(struct var_decls_strec * p) {
    struct var_decls_unitrec *  u;
    u = qc_lib_newunitrec();
    (*u).tag = (int64_t)3;
    (*u).def = p;
    return u;
}

struct var_decls_unitrec * qc_lib_createunit0(int64_t tag) {
    struct var_decls_unitrec *  u;
    u = qc_lib_newunitrec();
    (*u).tag = tag;
    return u;
}

struct var_decls_unitrec * qc_lib_createunit1(int64_t tag,struct var_decls_unitrec * p) {
    struct var_decls_unitrec *  u;
    u = qc_lib_newunitrec();
    (*u).tag = tag;
    (*u).a = p;
    return u;
}

struct var_decls_unitrec * qc_lib_createunit2(int64_t tag,struct var_decls_unitrec * p,struct var_decls_unitrec * q) {
    struct var_decls_unitrec *  u;
    u = qc_lib_newunitrec();
    (*u).tag = tag;
    (*u).a = p;
    (*u).b = q;
    return u;
}

struct var_decls_unitrec * qc_lib_createunit3(int64_t tag,struct var_decls_unitrec * p,struct var_decls_unitrec * q,struct var_decls_unitrec * r) {
    struct var_decls_unitrec *  u;
    u = qc_lib_newunitrec();
    (*u).tag = tag;
    (*u).a = p;
    (*u).b = q;
    (*u).c = r;
    return u;
}

struct var_decls_unitrec * qc_lib_createconstunit(uint64_t a,int64_t t) {
    struct var_decls_unitrec *  u;
    u = qc_lib_newunitrec();
    (*u).tag = (int64_t)1;
    (*u).value = (int64_t)(a);
    (*u).mode = t;
    return u;
}

struct var_decls_unitrec * qc_lib_createstringconstunit(uint8_t * s,int64_t length) {
    struct var_decls_unitrec *  u;
    u = qc_lib_newunitrec();
    (*u).tag = (int64_t)1;
    (*u).svalue = s;
    (*u).mode = (int64_t)5;
    if ((length == (int64_t)-1)) {
        (*u).slength = (int64_t)(strlen((int8_t *)(s)));
    } else {
        (*u).slength = length;
    };
    return u;
}

int64_t qc_lib_getoptocode(int64_t opc) {
    static int16_t opctotable[250];
    int64_t opcto;
    int64_t i;
    uint8_t str[20];
    int64_t av_1;
    opcto = (int64_t)(opctotable[(opc)]);
    if (!!(opcto)) {
        return opcto;
    };
    strcpy((int8_t *)(str),(int8_t *)(qc_tables_jtagnames[(opc)]));
    strcat((int8_t *)(str),(int8_t *)((uint8_t*)"to"));
    L1221 :;
    for (i=(int64_t)0;i<=(int64_t)249;i+=(int64_t)1) {
L1222 :;
        if (!!(mlib_eqstring(qc_tables_jtagnames[(i)],str))) {
            opctotable[(opc)] = i;
            return i;
        };
L1223 :;
    }L1224 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(qc_tables_jtagnames[(opc)],NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    qc_support_serror((uint8_t*)"Can't find -to version");
    return (int64_t)0;
}

int64_t qc_lib_checkpackedtype(int64_t m) {
    switch ((int64_t)(var_decls_ttbasetype[(m)])) {
    case 37:;
    case 38:;
    case 39:;
    case 40:;
    case 44:;
    case 45:;
    case 46:;
    case 47:;
    case 48:;
    case 49:;
    case 23:;
    case 5:;
    case 33:;
    case 21:;
    case 30:;
    case 52:;
    case 50:;
    case 51:;
    {
        return (int64_t)1;
    }break;
    default: {
    }
    } //SW
;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(qc_lib_strmode(m,(int64_t)1),NULL);
    msysnewc_m_print_str(qc_lib_strmode((int64_t)(var_decls_ttbasetype[(m)]),(int64_t)1),NULL);
    msysnewc_m_print_i64(m,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    qc_support_serror((uint8_t*)"Invalid Packed type");
    return (int64_t)0;
}

void qc_lib_checkunpackedtype(int64_t t) {
    if (((int64_t)(var_decls_ttbasetype[(t)]) > (int64_t)35)) {
        qc_support_serror((uint8_t*)"Pack type not allowed");
    };
}

int64_t qc_lib_checkdlltype(int64_t m) {
    if ((m < (int64_t)0)) {
        return (int64_t)1;
    };
    switch ((int64_t)(var_decls_ttbasetype[(m)])) {
    case 37:;
    case 38:;
    case 39:;
    case 40:;
    case 44:;
    case 45:;
    case 46:;
    case 47:;
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 23:;
    case 5:;
    case 33:;
    case 21:;
    {
        return (int64_t)1;
    }break;
    default: {
    }
    } //SW
;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(var_decls_ttname[(m)],NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    qc_support_serror((uint8_t*)"Invalid DLL param/ret type");
    return (int64_t)0;
}

int64_t qc_lib_createtype(struct var_decls_strec * d) {
    if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)4)) {
        return (int64_t)((*d).mode);
    };
    return qc_lib_createusertype(d);
}

int64_t qc_lib_createusertype(struct var_decls_strec * stname) {
    ++var_decls_ntypes;
    var_decls_ttname[(var_decls_ntypes)] = (*stname).name;
    var_decls_ttnamedef[(var_decls_ntypes)] = stname;
    var_decls_ttbasetype[(var_decls_ntypes)] = (int64_t)0;
    var_decls_ttusercat[(var_decls_ntypes)] = (uint64_t)((int64_t)2);
    var_decls_ttlineno[(var_decls_ntypes)] = (int64_t)(qc_lex_lx.lineno);
    var_decls_ttmoduleno[(var_decls_ntypes)] = (uint64_t)(var_decls_currmoduleno);
    return var_decls_ntypes;
}

int64_t qc_lib_createusertypefromstr(uint8_t * name) {
    struct var_decls_strec *  stname;
    stname = qc_lib_getduplnameptr(var_decls_stmodule,qc_lex_addnamestr(name),(int64_t)4);
    qc_lib_adddef(var_decls_stmodule,stname);
    return qc_lib_createusertype(stname);
}

int64_t qc_lib_getconstvalue(struct var_decls_unitrec * p,int64_t id) {
    if ((!!(p) && ((int64_t)((*p).tag) == (int64_t)1))) {
        return (*p).value;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"ID=",NULL);
    msysnewc_m_print_i64(id,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"ID=",NULL);
    msysnewc_m_print_i64(id,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"ID=",NULL);
    msysnewc_m_print_i64(id,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((uint8_t*)"ID=",NULL);
    msysnewc_m_print_i64(id,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    qc_support_serror((uint8_t*)"GCV Not constant");
    return (int64_t)0;
}

int64_t qc_lib_getrangelwb(struct var_decls_unitrec * p) {
    if (((int64_t)((*p).tag) == (int64_t)82)) {
        return (int64_t)((*p).range_lower);
    } else {
        qc_support_serror((uint8_t*)"getrangelwb");
    };
    return (int64_t)0;
}

int64_t qc_lib_getrangeupb(struct var_decls_unitrec * p) {
    if (((int64_t)((*p).tag) == (int64_t)82)) {
        return (int64_t)((*p).range_upper);
    } else {
        qc_support_serror((uint8_t*)"getrangeupb");
    };
    return (int64_t)0;
}

struct var_decls_unitrec * qc_lib_getrangelwbunit(struct var_decls_unitrec * p) {
    if (((int64_t)((*p).tag) == (int64_t)82)) {
        return (*p).a;
    } else {
        return qc_lib_createunit1((int64_t)180,p);
    };
}

struct var_decls_unitrec * qc_lib_getrangeupbunit(struct var_decls_unitrec * p) {
    if (((int64_t)((*p).tag) == (int64_t)82)) {
        return (*p).b;
    } else {
        return qc_lib_createunit1((int64_t)181,p);
    };
}

int64_t qc_lib_createarraymode(struct var_decls_strec * owner,int64_t target,struct var_decls_unitrec * lower,struct var_decls_unitrec * length,int64_t typedefx) {
    int64_t atype;
    int64_t m;
    if ((target==(int64_t)41) || (target==(int64_t)42) || (target==(int64_t)43)) {
        atype = (int64_t)31;
    } else {
        atype = (int64_t)30;
    };
    if ((typedefx == (int64_t)0)) {
        m = qc_lib_createusertypefromstr(qc_lib_nextautotype());
    } else {
        m = typedefx;
    };
    var_decls_ttbasetype[(m)] = atype;
    var_decls_ttlowerexpr[(m)] = lower;
    var_decls_ttlengthexpr[(m)] = length;
    var_decls_tttarget[(m)] = target;
    var_decls_ttowner[(m)] = owner;
    return m;
}

uint8_t * qc_lib_nextautotype(void) {
    static uint8_t str[32];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt((uint8_t*)"$T#");
    msysnewc_m_print_i64(++qc_lib_autotypeno,NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

int64_t qc_lib_createstringmode(struct var_decls_strec * owner,int64_t t,struct var_decls_unitrec * lengthx,int64_t typedefx) {
    int64_t m;
    if ((typedefx == (int64_t)0)) {
        m = qc_lib_createusertypefromstr(qc_lib_nextautotype());
    } else {
        m = typedefx;
    };
    var_decls_ttbasetype[(m)] = t;
    var_decls_ttlower[(m)] = ((t == (int64_t)5)?(int64_t)1:(int64_t)0);
    var_decls_ttsize[(m)] = (int64_t)0;
    var_decls_ttlengthexpr[(m)] = lengthx;
    var_decls_ttowner[(m)] = owner;
    return m;
}

int64_t qc_lib_createrefpackmode(struct var_decls_strec * owner,int64_t target,int64_t typedefx) {
    int64_t k;
    int64_t m;
    if ((target==(int64_t)35)) {
        return (int64_t)22;
    }else if ((target==(int64_t)41) || (target==(int64_t)42) || (target==(int64_t)43)) {
        qc_support_serror((uint8_t*)"CREATEREFBIT");
    };
    if ((typedefx == (int64_t)0)) {
        L1225 :;
        for (k=(int64_t)53;k<=var_decls_ntypes;k+=(int64_t)1) {
L1226 :;
            if (((((int64_t)((uint64_t)(var_decls_ttusercat[(k)])) == (int64_t)1) && ((int64_t)(var_decls_ttbasetype[(k)]) == (int64_t)23)) && ((int64_t)(var_decls_tttarget[(k)]) == target))) {
                return k;
            };
L1227 :;
        }L1228 :;
        ;
        m = qc_lib_createusertypefromstr(qc_lib_nextautotype());
    } else {
        m = typedefx;
    };
    qc_lib_storemode(owner,target,&var_decls_tttarget[(m)]);
    var_decls_ttbasetype[(m)] = (int64_t)23;
    return m;
}

int64_t qc_lib_getscope(struct var_decls_strec * p) {
    struct var_decls_strec *  owner;
    if ((p == 0)) {
        return (int64_t)1;
    };
    if (((int64_t)((*p).nameid)==(int64_t)2) || ((int64_t)((*p).nameid)==(int64_t)1)) {
        return (int64_t)3;
    }else if (((int64_t)((*p).nameid)==(int64_t)3)) {
        return (int64_t)2;
    };
    L1229 :;
    while (1) {
        owner = (*p).owner;
        if (((int64_t)((*owner).nameid)==(int64_t)2) || ((int64_t)((*owner).nameid)==(int64_t)3)) {
            goto L1230 ;
        };
        p = owner;
    }L1230 :;
    ;
    if (((int64_t)((*owner).nameid)==(int64_t)2)) {
        return (!!((uint64_t)((*p).attribs.ax_global))?(int64_t)3:(int64_t)1);
    } else {
        return (int64_t)2;
    };
    return (int64_t)0;
}

void qc_lib_setnameptr(struct var_decls_unitrec * p) {
    (*(*p).def).code = p;
}

void qc_lib_printcode(void * f,uint8_t * caption) {
    struct var_decls_strec *  p;
    struct var_decls_strec *  m;
    m = (*var_decls_stprogram).deflist;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_str((uint8_t*)"PROGRAM",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L1231 :;
    while (!!(m)) {
        p = (*m).deflist;
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((uint8_t*)"Module:",NULL);
        msysnewc_m_print_str((*m).name,(uint8_t*)"A12P*JC");
        msysnewc_m_print_str((uint8_t*)"=",(uint8_t*)"50p=");
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        L1234 :;
        while (!!(p)) {
            if (((int64_t)((*p).nameid)==(int64_t)5)) {
                msysnewc_m_print_startfile(f);
                msysnewc_m_print_str((*p).name,NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_str((uint8_t*)"=",NULL);
                msysnewc_m_print_str((!!((uint64_t)((*p).attribs.ax_global))?(uint8_t*)"Global":(uint8_t*)"Local"),NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                qc_lib_printunit((*p).code,(int64_t)0,(uint8_t*)"1",f);
                msysnewc_m_print_startfile(f);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            };
            p = (*p).nextdef;
L1235 :;
        }L1236 :;
        ;
        m = (*m).nextdef;
L1232 :;
    }L1233 :;
    ;
}

void qc_lib_printunit(struct var_decls_unitrec * p,int64_t level,uint8_t * prefix,void * dev) {
    struct var_decls_strec *  d;
    int64_t t;
    uint8_t *  idname;
    if ((p == 0)) {
        return;
    };
    if (!!((int64_t)((*p).lineno))) {
        qc_lib_currlineno = (int64_t)((*p).lineno);
    };
    msysnewc_m_print_startfile(dev);
    msysnewc_m_print_ptr(p,NULL);
    msysnewc_m_print_str((uint8_t*)": ",NULL);
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startfile(dev);
    msysnewc_m_print_str(qc_lib_getprefix(level,prefix,p),NULL);
    msysnewc_m_print_end();
    ;
    idname = qc_tables_jtagnames[((int64_t)((*p).tag))];
    msysnewc_m_print_startfile(dev);
    msysnewc_m_print_str(idname,NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((uint8_t*)": ",NULL);
    msysnewc_m_print_end();
    ;
    if (!!(mlib_fdebug)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"IDNAME=",NULL);
        msysnewc_m_print_str(idname,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    if (((int64_t)((*p).tag)==(int64_t)3)) {
        d = (*p).def;
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((*d).name,NULL);
        msysnewc_m_print_str(pq_common_namenames[((int64_t)((*d).nameid))],NULL);
        msysnewc_m_print_end();
        ;
        if (!!((*d).code)) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str((uint8_t*)" {",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str(qc_tables_jtagnames[((int64_t)((*(*d).code).tag))],NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((uint8_t*)"}",NULL);
            msysnewc_m_print_end();
            ;
        };
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((uint8_t*)" ",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(qc_lib_getdottedname(d),NULL);
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((!!((uint64_t)((*p).dottedname))?(uint8_t*)" {Dotted}":(uint8_t*)""),NULL);
        msysnewc_m_print_end();
        ;
        if (!!((*p).c)) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str((uint8_t*)" Lastcall:",NULL);
            msysnewc_m_print_ptr((*p).c,NULL);
            msysnewc_m_print_end();
            ;
        };
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((uint8_t*)" ",NULL);
        msysnewc_m_print_ptr(d,(uint8_t*)"z8h");
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)((*p).tag)==(int64_t)35)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((*(*p).def).name,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)((*p).tag)==(int64_t)1)) {
        t = (int64_t)((*p).mode);
        if ((t==(int64_t)5)) {
            if (((int64_t)((*p).slength) > (int64_t)256)) {
                msysnewc_m_print_startfile(dev);
                msysnewc_m_print_str((uint8_t*)"\"",NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_str((uint8_t*)"(LONGSTR)",NULL);
                msysnewc_m_print_str((uint8_t*)"\" *",NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_i64((*p).slength,NULL);
                msysnewc_m_print_end();
                ;
            } else {
                msysnewc_m_print_startfile(dev);
                msysnewc_m_print_str((uint8_t*)"\"",NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_str((*p).svalue,NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_str((uint8_t*)"\" *",NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_i64((*p).slength,NULL);
                msysnewc_m_print_end();
                ;
            };
        }else if ((t==(int64_t)1)) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_i64((*p).value,NULL);
            msysnewc_m_print_end();
            ;
        }else if ((t==(int64_t)2)) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_u64((*p).uvalue,NULL);
            msysnewc_m_print_end();
            ;
        }else if ((t==(int64_t)3)) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_r64((*p).xvalue,NULL);
            msysnewc_m_print_end();
            ;
        }else if ((t==(int64_t)4)) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_i64((*p).range_lower,NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((uint8_t*)"..",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_i64((*p).range_upper,NULL);
            msysnewc_m_print_end();
            ;
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(var_decls_ttname[(t)],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            qc_support_serror((uint8_t*)"PRINTUNIT BAD CONST");
        };
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((uint8_t*)" ",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(var_types_stdtypenames[(t)],NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)((*p).tag)==(int64_t)9)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((*p).svalue,NULL);
        msysnewc_m_print_str((uint8_t*)"Len:",NULL);
        msysnewc_m_print_i64((*p).slength,NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)((*p).tag)==(int64_t)94) || ((int64_t)((*p).tag)==(int64_t)66)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str(pq_common_hostfnnames[((int64_t)((*p).opcode))],NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)((*p).tag)==(int64_t)151)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str(var_decls_ttname[((int64_t)((*p).mode))],NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)((*p).tag)==(int64_t)152)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((qc_tables_jtagnames[((int64_t)((*p).opcode))] + (int64_t)2),NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)((*p).tag)==(int64_t)149)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str(var_decls_ttname[((int64_t)((*p).mode))],NULL);
        msysnewc_m_print_end();
        ;
    };
    msysnewc_m_print_startfile(dev);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    qc_lib_printunitlist(dev,(*p).a,(level + (int64_t)1),(uint8_t*)"1");
    qc_lib_printunitlist(dev,(*p).b,(level + (int64_t)1),(uint8_t*)"2");
    qc_lib_printunitlist(dev,(*p).c,(level + (int64_t)1),(uint8_t*)"3");
}

static void qc_lib_printunitlist(void * dev,struct var_decls_unitrec * p,int64_t level,uint8_t * prefix) {
    if ((p == 0)) {
        return;
    };
    L1237 :;
    while (!!(p)) {
        qc_lib_printunit(p,level,prefix,dev);
        p = (*p).nextunit;
L1238 :;
    }L1239 :;
    ;
}

static uint8_t * qc_lib_getprefix(int64_t level,uint8_t * prefix,struct var_decls_unitrec * p) {
    static uint8_t str[512];
    uint8_t indentstr[512];
    int64_t av_1;
    indentstr[((int64_t)1)-1] = (uint64_t)0u;
    if ((level > (int64_t)10)) {
        level = (int64_t)10;
    };
    av_1 = level;
    while (av_1-- > 0) {
L1240 :;
        strcat((int8_t *)(indentstr),(int8_t *)((uint8_t*)"- - "));
L1241 :;
    }L1242 :;
    ;
    strcpy((int8_t *)(str),(int8_t *)(qc_lib_getlineinfok()));
    strcat((int8_t *)(str),(int8_t *)(indentstr));
    strcat((int8_t *)(str),(int8_t *)(prefix));
    if (!!((uint64_t)((*prefix)))) {
        strcat((int8_t *)(str),(int8_t *)((uint8_t*)" "));
    };
    return str;
}

uint8_t * qc_lib_getdottedname(struct var_decls_strec * p) {
    static uint8_t str[256];
    uint8_t str2[256];
    struct var_decls_strec *  owner;
    strcpy((int8_t *)(str),(int8_t *)((*p).name));
    owner = (*p).owner;
    L1243 :;
    while ((!!(owner) && ((int64_t)((uint64_t)((*owner).nameid)) != (int64_t)1))) {
        strcpy((int8_t *)(str2),(int8_t *)(str));
        strcpy((int8_t *)(str),(int8_t *)((*owner).name));
        strcat((int8_t *)(str),(int8_t *)((uint8_t*)"."));
        strcat((int8_t *)(str),(int8_t *)(str2));
        owner = (*owner).owner;
L1244 :;
    }L1245 :;
    ;
    return str;
}

static uint8_t * qc_lib_getlineinfok(void) {
    static uint8_t str[40];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt((uint8_t*)"# ");
    msysnewc_m_print_i64(qc_lib_currlineno,(uint8_t*)"z4");
    msysnewc_m_print_end();
    ;
    return str;
}

struct var_decls_strec * qc_lib_getavname(struct var_decls_strec * owner,int64_t id) {
    struct var_decls_strec *  p;
    uint8_t str[32];
    uint8_t *  name;
    if (((id == (int64_t)11) && ((int64_t)((uint64_t)((*owner).nameid)) != (int64_t)5))) {
        qc_support_serror((uint8_t*)"Auto frame not in proc");
    };
    if ((id == (int64_t)11)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((uint8_t*)"av$",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_i64(++qc_lib_nextavindex,NULL);
        msysnewc_m_print_end();
        ;
    } else {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((uint8_t*)"sv$",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_i64(++qc_lib_nextsvindex,NULL);
        msysnewc_m_print_end();
        ;
    };
    name = mlib_pcm_copyheapstring(str);
    qc_lex_addnamestr(name);
    p = qc_lib_getduplnameptr(owner,qc_lex_addnamestr(name),id);
    (*p).mode = (int64_t)1;
    (*p).attribs.ax_autovar = (uint64_t)((int64_t)1);
    qc_lib_adddef(owner,p);
    return p;
}

void qc_lib_unionstr_clear(struct var_decls_uflagsrec * u) {
    (*u).ulength = (uint64_t)((int64_t)0);
}

void qc_lib_unionstr_append(struct var_decls_uflagsrec * u,int64_t c) {
    if (((int64_t)((uint64_t)((*u).ulength)) == (int64_t)7)) {
        qc_support_serror((uint8_t*)"Uflags overflow/a");
    };
    ++(*u).ulength;
    (*u).codes[((int64_t)((*u).ulength))-1] = (uint64_t)(c);
}

void qc_lib_unionstr_concat(struct var_decls_uflagsrec * u,struct var_decls_uflagsrec * v) {
    int64_t ulen;
    int64_t vlen;
    int64_t i;
    ulen = (int64_t)((*u).ulength);
    vlen = (int64_t)((*v).ulength);
    if (((ulen + vlen) > (int64_t)7)) {
        qc_support_serror((uint8_t*)"Uflags overflow/c");
    };
    L1246 :;
    for (i=(int64_t)1;i<=vlen;i+=(int64_t)1) {
L1247 :;
        (*u).codes[((i + ulen))-1] = (uint64_t)((*v).codes[(i)-1]);
L1248 :;
    }L1249 :;
    ;
    (*u).ulength = (uint64_t)((ulen + vlen));
}

int64_t qc_lib_unionstr_last(struct var_decls_uflagsrec * u) {
    if (!!((uint64_t)((*u).ulength))) {
        return (int64_t)((*u).codes[((int64_t)((*u).ulength))-1]);
    };
    return (int64_t)0;
}

void qc_lib_unionstr_copy(struct var_decls_uflagsrec * u,struct var_decls_uflagsrec * v) {
    memcpy((void *)(u),(void *)(v),(uint64_t)((int64_t)8));
}

void qc_lib_unionstr_print(struct var_decls_uflagsrec * u) {
    msysnewc_printstrn_app((uint8_t *)(&(*u).codes),(int64_t)((*u).ulength),0);
}

int64_t qc_lib_createrecordmode(struct var_decls_strec * owner,int64_t t,int64_t typedefx) {
    int64_t m;
    if ((typedefx == (int64_t)0)) {
        m = qc_lib_createusertype(owner);
    } else {
        m = typedefx;
    };
    var_decls_ttbasetype[(m)] = t;
    return m;
}

int64_t qc_lib_createenummode(struct var_decls_strec * owner,int64_t typedefx) {
    int64_t m;
    if ((typedefx == (int64_t)0)) {
        m = qc_lib_createusertype(owner);
    } else {
        m = typedefx;
    };
    var_decls_ttbasetype[(m)] = (int64_t)12;
    return m;
}

void qc_lib_convertstring(uint8_t * s,uint8_t * t) {
    int64_t c;
    L1250 :;
    while (!!((c = (int64_t)((*s++))))) {
        switch (c) {
        case 34:;
        {
            (*t++) = (uint64_t)92u;
            (*t++) = '"';
        }break;
        case 10:;
        {
            (*t++) = (uint64_t)92u;
            (*t++) = 'n';
        }break;
        case 13:;
        {
            (*t++) = (uint64_t)92u;
            (*t++) = 'c';
        }break;
        case 9:;
        {
            (*t++) = (uint64_t)92u;
            (*t++) = 't';
        }break;
        case 92:;
        {
            (*t++) = (uint64_t)92u;
            (*t++) = (uint64_t)92u;
        }break;
        case 7:;
        case 8:;
        case 26:;
        case 27:;
        {
            (*t++) = '<';
            (*t++) = (uint64_t)(((c / (int64_t)10) + (int64_t)48));
            (*t++) = (uint64_t)(((c % (int64_t)10) + (int64_t)48));
            (*t++) = '>';
        }break;
        default: {
            (*t++) = (uint64_t)(c);
        }
        } //SW
;
L1251 :;
    }L1252 :;
    ;
    (*t) = (uint64_t)0u;
}

struct mlib_strbuffer * qc_lib_strexpr(struct var_decls_unitrec * p) {
    mlib_gs_init(qc_lib_exprstr);
    qc_lib_jeval(qc_lib_exprstr,p);
    return qc_lib_exprstr;
}

static void qc_lib_jeval(struct mlib_strbuffer * dest,struct var_decls_unitrec * p) {
    struct var_decls_unitrec *  q;
    uint8_t str[500];
    if (((int64_t)((*p).tag)==(int64_t)1)) {
        if (((int64_t)((*p).mode)==(int64_t)5)) {
            //dostring:
L1253 :;
;
            if (((int64_t)((*p).slength) > (int64_t)250)) {
                strcpy((int8_t *)(str),(int8_t *)((uint8_t*)"LONGSTR)"));
            } else {
                qc_lib_convertstring((*p).svalue,str);
            };
            qc_support_gs_additem(dest,(uint8_t*)"\"");
            qc_support_gs_additem(dest,str);
            qc_support_gs_additem(dest,(uint8_t*)"\"");
            return;
        }else if (((int64_t)((*p).mode)==(int64_t)1)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_i64((*p).value,NULL);
            msysnewc_m_print_end();
            ;
        }else if (((int64_t)((*p).mode)==(int64_t)2)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_u64((*p).uvalue,NULL);
            msysnewc_m_print_end();
            ;
        }else if (((int64_t)((*p).mode)==(int64_t)3)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_r64((*p).xvalue,NULL);
            msysnewc_m_print_end();
            ;
        }else if (((int64_t)((*p).mode)==(int64_t)4)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_setfmt((uint8_t*)"#..#");
            msysnewc_m_print_i64((*p).range_lower,NULL);
            msysnewc_m_print_i64((*p).range_upper,NULL);
            msysnewc_m_print_end();
            ;
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(var_decls_ttname[((int64_t)((*p).mode))],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            qc_support_rxerror((uint8_t*)"EVAL/CONST",p);
        };
        qc_support_gs_additem(dest,str);
    }else if (((int64_t)((*p).tag)==(int64_t)3)) {
        qc_support_gs_additem(dest,(*(*p).def).name);
    }else if (((int64_t)((*p).tag)==(int64_t)74) || ((int64_t)((*p).tag)==(int64_t)75) || ((int64_t)((*p).tag)==(int64_t)97) || ((int64_t)((*p).tag)==(int64_t)98) || ((int64_t)((*p).tag)==(int64_t)99) || ((int64_t)((*p).tag)==(int64_t)100) || ((int64_t)((*p).tag)==(int64_t)101) || ((int64_t)((*p).tag)==(int64_t)102) || ((int64_t)((*p).tag)==(int64_t)103) || ((int64_t)((*p).tag)==(int64_t)105) || ((int64_t)((*p).tag)==(int64_t)106) || ((int64_t)((*p).tag)==(int64_t)107) || ((int64_t)((*p).tag)==(int64_t)108) || ((int64_t)((*p).tag)==(int64_t)109) || ((int64_t)((*p).tag)==(int64_t)110) || ((int64_t)((*p).tag)==(int64_t)111) || ((int64_t)((*p).tag)==(int64_t)112) || ((int64_t)((*p).tag)==(int64_t)114) || ((int64_t)((*p).tag)==(int64_t)115) || ((int64_t)((*p).tag)==(int64_t)116) || ((int64_t)((*p).tag)==(int64_t)117) || ((int64_t)((*p).tag)==(int64_t)118) || ((int64_t)((*p).tag)==(int64_t)119) || ((int64_t)((*p).tag)==(int64_t)120) || ((int64_t)((*p).tag)==(int64_t)121) || ((int64_t)((*p).tag)==(int64_t)122) || ((int64_t)((*p).tag)==(int64_t)123) || ((int64_t)((*p).tag)==(int64_t)124) || ((int64_t)((*p).tag)==(int64_t)125) || ((int64_t)((*p).tag)==(int64_t)126) || ((int64_t)((*p).tag)==(int64_t)144) || ((int64_t)((*p).tag)==(int64_t)145) || ((int64_t)((*p).tag)==(int64_t)76) || ((int64_t)((*p).tag)==(int64_t)104) || ((int64_t)((*p).tag)==(int64_t)113) || ((int64_t)((*p).tag)==(int64_t)127)) {
        strcpy((int8_t *)(str),(int8_t *)(qc_lib_getopcjname((int64_t)((*p).tag))));
        qc_support_gs_additem(dest,(uint8_t*)"(");
        qc_lib_jeval(dest,(*p).a);
        qc_support_gs_additem(dest,str);
        qc_lib_jeval(dest,(*p).b);
        qc_support_gs_additem(dest,(uint8_t*)")");
    }else if (((int64_t)((*p).tag)==(int64_t)156) || ((int64_t)((*p).tag)==(int64_t)157) || ((int64_t)((*p).tag)==(int64_t)158) || ((int64_t)((*p).tag)==(int64_t)159) || ((int64_t)((*p).tag)==(int64_t)160) || ((int64_t)((*p).tag)==(int64_t)161) || ((int64_t)((*p).tag)==(int64_t)162) || ((int64_t)((*p).tag)==(int64_t)163) || ((int64_t)((*p).tag)==(int64_t)164) || ((int64_t)((*p).tag)==(int64_t)165) || ((int64_t)((*p).tag)==(int64_t)166) || ((int64_t)((*p).tag)==(int64_t)167) || ((int64_t)((*p).tag)==(int64_t)168) || ((int64_t)((*p).tag)==(int64_t)169) || ((int64_t)((*p).tag)==(int64_t)170) || ((int64_t)((*p).tag)==(int64_t)171) || ((int64_t)((*p).tag)==(int64_t)172) || ((int64_t)((*p).tag)==(int64_t)173) || ((int64_t)((*p).tag)==(int64_t)174) || ((int64_t)((*p).tag)==(int64_t)175) || ((int64_t)((*p).tag)==(int64_t)176) || ((int64_t)((*p).tag)==(int64_t)177) || ((int64_t)((*p).tag)==(int64_t)178) || ((int64_t)((*p).tag)==(int64_t)179) || ((int64_t)((*p).tag)==(int64_t)180) || ((int64_t)((*p).tag)==(int64_t)181) || ((int64_t)((*p).tag)==(int64_t)182) || ((int64_t)((*p).tag)==(int64_t)183) || ((int64_t)((*p).tag)==(int64_t)184) || ((int64_t)((*p).tag)==(int64_t)185) || ((int64_t)((*p).tag)==(int64_t)187) || ((int64_t)((*p).tag)==(int64_t)188) || ((int64_t)((*p).tag)==(int64_t)189) || ((int64_t)((*p).tag)==(int64_t)190) || ((int64_t)((*p).tag)==(int64_t)192) || ((int64_t)((*p).tag)==(int64_t)193) || ((int64_t)((*p).tag)==(int64_t)194) || ((int64_t)((*p).tag)==(int64_t)195) || ((int64_t)((*p).tag)==(int64_t)196) || ((int64_t)((*p).tag)==(int64_t)197) || ((int64_t)((*p).tag)==(int64_t)198) || ((int64_t)((*p).tag)==(int64_t)200) || ((int64_t)((*p).tag)==(int64_t)201) || ((int64_t)((*p).tag)==(int64_t)203) || ((int64_t)((*p).tag)==(int64_t)205) || ((int64_t)((*p).tag)==(int64_t)206) || ((int64_t)((*p).tag)==(int64_t)207) || ((int64_t)((*p).tag)==(int64_t)208) || ((int64_t)((*p).tag)==(int64_t)77) || ((int64_t)((*p).tag)==(int64_t)78) || ((int64_t)((*p).tag)==(int64_t)191) || ((int64_t)((*p).tag)==(int64_t)204)) {
        strcpy((int8_t *)(str),(int8_t *)(qc_lib_getopcjname((int64_t)((*p).tag))));
        qc_support_gs_additem(dest,str);
        qc_support_gs_additem(dest,(uint8_t*)"(");
        qc_lib_jeval(dest,(*p).a);
        qc_support_gs_additem(dest,(uint8_t*)")");
    }else if (((int64_t)((*p).tag)==(int64_t)90) || ((int64_t)((*p).tag)==(int64_t)14)) {
        qc_lib_jeval(dest,(*p).a);
        qc_support_gs_additem(dest,(uint8_t*)"(");
        q = (*p).b;
        L1254 :;
        while (!!(q)) {
            qc_lib_jeval(dest,q);
            q = (*q).nextunit;
            if (!!(q)) {
                qc_support_gs_additem(dest,(uint8_t*)",");
            };
L1255 :;
        }L1256 :;
        ;
        qc_support_gs_additem(dest,(uint8_t*)")");
    }else if (((int64_t)((*p).tag)==(int64_t)94)) {
        qc_support_gs_additem(dest,(uint8_t*)"Host<");
        qc_support_gs_additem(dest,(pq_common_hostfnnames[((int64_t)((*p).opcode))] + (int64_t)5));
        qc_support_gs_additem(dest,(uint8_t*)">(");
        q = (*p).b;
        L1257 :;
        while (!!(q)) {
            qc_lib_jeval(dest,q);
            q = (*q).nextunit;
            if (!!(q)) {
                qc_support_gs_additem(dest,(uint8_t*)",");
            };
L1258 :;
        }L1259 :;
        ;
        qc_support_gs_additem(dest,(uint8_t*)")");
    }else if (((int64_t)((*p).tag)==(int64_t)129) || ((int64_t)((*p).tag)==(int64_t)133) || ((int64_t)((*p).tag)==(int64_t)131) || ((int64_t)((*p).tag)==(int64_t)136)) {
        qc_lib_jeval(dest,(*p).a);
        if ((((int64_t)((*p).tag) == (int64_t)133) || ((int64_t)((*p).tag) == (int64_t)136))) {
            qc_support_gs_additem(dest,(uint8_t*)".");
        };
        qc_support_gs_additem(dest,(uint8_t*)"[");
        qc_lib_jeval(dest,(*p).b);
        qc_support_gs_additem(dest,(uint8_t*)"]");
    }else if (((int64_t)((*p).tag)==(int64_t)132) || ((int64_t)((*p).tag)==(int64_t)137)) {
        qc_lib_jeval(dest,(*p).a);
        if (((int64_t)((*p).tag) == (int64_t)137)) {
            qc_support_gs_additem(dest,(uint8_t*)".");
        };
        qc_support_gs_additem(dest,(uint8_t*)"{");
        qc_lib_jeval(dest,(*p).b);
        qc_support_gs_additem(dest,(uint8_t*)"}");
    }else if (((int64_t)((*p).tag)==(int64_t)141)) {
        qc_lib_jeval(dest,(*p).a);
        qc_support_gs_additem(dest,(uint8_t*)".");
        qc_lib_jeval(dest,(*p).b);
    }else if (((int64_t)((*p).tag)==(int64_t)79) || ((int64_t)((*p).tag)==(int64_t)81) || ((int64_t)((*p).tag)==(int64_t)80) || ((int64_t)((*p).tag)==(int64_t)83)) {
        qc_support_gs_additem(dest,((((int64_t)((*p).tag) == (int64_t)79) || ((int64_t)((*p).tag) == (int64_t)80))?(uint8_t*)"(":(uint8_t*)"["));
        q = (*p).a;
        L1260 :;
        while (!!(q)) {
            qc_lib_jeval(dest,q);
            q = (*q).nextunit;
            if (!!(q)) {
                qc_support_gs_additem(dest,(uint8_t*)",");
            };
L1261 :;
        }L1262 :;
        ;
        qc_support_gs_additem(dest,(((int64_t)((*p).tag) == (int64_t)79)?(uint8_t*)")":(uint8_t*)"]"));
    }else if (((int64_t)((*p).tag)==(int64_t)82)) {
        qc_support_gs_additem(dest,(uint8_t*)"(");
        qc_lib_jeval(dest,(*p).a);
        qc_support_gs_additem(dest,(uint8_t*)"..");
        qc_lib_jeval(dest,(*p).b);
        qc_support_gs_additem(dest,(uint8_t*)")");
    }else if (((int64_t)((*p).tag)==(int64_t)88)) {
        qc_lib_jeval(dest,(*p).a);
        qc_support_gs_additem(dest,(uint8_t*)":=");
        qc_lib_jeval(dest,(*p).b);
    }else if (((int64_t)((*p).tag)==(int64_t)92)) {
        qc_support_gs_additem(dest,(uint8_t*)"(");
        qc_lib_jeval(dest,(*p).a);
        qc_support_gs_additem(dest,(uint8_t*)"|");
        qc_lib_jeval(dest,(*p).b);
        qc_support_gs_additem(dest,(uint8_t*)"|");
        qc_lib_jeval(dest,(*p).c);
        qc_support_gs_additem(dest,(uint8_t*)")");
    }else if (((int64_t)((*p).tag)==(int64_t)151)) {
        qc_support_gs_additem(dest,qc_lib_strmode((int64_t)((*p).mode),(int64_t)1));
    }else if (((int64_t)((*p).tag)==(int64_t)154)) {
        qc_support_gs_additem(dest,(*(*p).def).name);
        qc_support_gs_additem(dest,(uint8_t*)">");
    }else if (((int64_t)((*p).tag)==(int64_t)149)) {
        qc_support_gs_additem(dest,(uint8_t*)"(");
        qc_lib_jeval(dest,(*p).a);
        qc_support_gs_additem(dest,(uint8_t*)")");
    }else if (((int64_t)((*p).tag)==(int64_t)87)) {
        qc_lib_jeval(dest,(*p).a);
        qc_support_gs_additem(dest,(uint8_t*)":");
        qc_lib_jeval(dest,(*p).b);
    }else if (((int64_t)((*p).tag)==(int64_t)9)) {
        mlib_gs_str(dest,(uint8_t*)"Longint:");
        goto L1253 ;
;
    }else if (((int64_t)((*p).tag)==(int64_t)146)) {
        qc_lib_jeval(dest,(*p).a);
        qc_support_gs_additem(dest,(uint8_t*)"^");
    }else if (((int64_t)((*p).tag)==(int64_t)148)) {
        qc_support_gs_additem(dest,(uint8_t*)"&");
        qc_lib_jeval(dest,(*p).a);
    }else if (((int64_t)((*p).tag)==(int64_t)147)) {
        qc_lib_jeval(dest,(*p).a);
    }else if (((int64_t)((*p).tag)==(int64_t)128)) {
        qc_support_gs_additem(dest,(uint8_t*)"(");
        qc_lib_jeval(dest,(*p).a);
        qc_support_gs_additem(dest,(uint8_t*)",");
        qc_lib_jeval(dest,(*p).b);
        qc_support_gs_additem(dest,(uint8_t*)",");
        qc_lib_jeval(dest,(*p).c);
        qc_support_gs_additem(dest,(uint8_t*)")");
    }else if (((int64_t)((*p).tag)==(int64_t)4)) {
        qc_support_gs_additem(dest,(uint8_t*)"<JBLOCK>");
    }else if (((int64_t)((*p).tag)==(int64_t)85)) {
        qc_support_gs_additem(dest,(uint8_t*)"MULTEXPR(");
        q = (*p).a;
        L1263 :;
        while (!!(q)) {
            qc_lib_jeval(dest,q);
            q = (*q).nextunit;
            if (!!(q)) {
                qc_support_gs_additem(dest,(uint8_t*)",");
            };
L1264 :;
        }L1265 :;
        ;
        qc_support_gs_additem(dest,(uint8_t*)")");
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(qc_tables_jtagnames[((int64_t)((*p).tag))],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        qc_support_gerror((uint8_t*)"CAN'T DO JEVAL",p);
    };
}

uint8_t * qc_lib_getopcjname(int64_t opc) {
    int64_t i;
    int64_t av_1;
    L1266 :;
    for (i=(int64_t)1;i<=(int64_t)36;i+=(int64_t)1) {
L1267 :;
        if ((opc == qc_lib_opc_codes[(i)-1])) {
            return qc_lib_opc_names[(i)-1];
        };
L1268 :;
    }L1269 :;
    ;
    return (qc_tables_jtagnames[(opc)] + (int64_t)2);
}

uint8_t * qc_lib_strmode(int64_t m,int64_t expand) {
    static uint8_t str[4096];
    qc_lib_istrmode(m,expand,str);
    return str;
}

void qc_lib_istrmode(int64_t m,int64_t expand,uint8_t * dest) {
    struct var_decls_strec *  d;
    struct var_decls_strec *  q;
    int64_t value;
    int64_t needcomma;
    int64_t x;
    if ((m < (int64_t)0)) {
        strcpy((int8_t *)(dest),(int8_t *)((uint8_t*)"*"));
        strcat((int8_t *)(dest),(int8_t *)((*var_decls_ttnamedefx[(-(m))]).name));
        if (!!(var_decls_ttnamedefx2[(-(m))])) {
            strcat((int8_t *)(dest),(int8_t *)((uint8_t*)"."));
            strcat((int8_t *)(dest),(int8_t *)((*var_decls_ttnamedefx2[(-(m))]).name));
        };
        return;
    };
    if ((m < (int64_t)53)) {
        strcpy((int8_t *)(dest),(int8_t *)(var_decls_ttname[(m)]));
        return;
    };
    if (((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)22) || ((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)23)) {
        strcpy((int8_t *)(dest),(int8_t *)((uint8_t*)"ref "));
        if (((int64_t)(var_decls_ttbasetype[((int64_t)(var_decls_tttarget[(m)]))]) == (int64_t)33)) {
            strcat((int8_t *)(dest),(int8_t *)(var_decls_ttname[((int64_t)(var_decls_tttarget[(m)]))]));
        } else {
            qc_lib_istrmode((int64_t)(var_decls_tttarget[(m)]),(int64_t)0,(dest + (int64_t)(strlen((int8_t *)(dest)))));
        };
    }else if (((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)5)) {
        strcpy((int8_t *)(dest),(int8_t *)((uint8_t*)"string*"));
        msysnewc_m_print_startstr((dest + (int64_t)(strlen((int8_t *)(dest)))));
        msysnewc_m_print_i64(var_decls_ttlength[(m)],NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)21)) {
        strcpy((int8_t *)(dest),(int8_t *)((uint8_t*)"stringz*"));
        msysnewc_m_print_startstr((dest + (int64_t)(strlen((int8_t *)(dest)))));
        msysnewc_m_print_i64(var_decls_ttlength[(m)],NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)9)) {
        strcpy((int8_t *)(dest),(int8_t *)((uint8_t*)"set*"));
        msysnewc_m_print_startstr((dest + (int64_t)(strlen((int8_t *)(dest)))));
        msysnewc_m_print_i64(var_decls_ttlength[(m)],NULL);
        msysnewc_m_print_end();
        ;
    }else if (((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)30)) {
        if (!!((int64_t)(var_decls_ttlength[(m)]))) {
            msysnewc_m_print_startstr(dest);
            msysnewc_m_print_setfmt((uint8_t*)"[#..#]");
            msysnewc_m_print_i64(var_decls_ttlower[(m)],NULL);
            msysnewc_m_print_i64((((int64_t)(var_decls_ttlength[(m)]) + (int64_t)(var_decls_ttlower[(m)])) - (int64_t)1),NULL);
            msysnewc_m_print_end();
            ;
        } else {
            msysnewc_m_print_startstr(dest);
            msysnewc_m_print_setfmt((uint8_t*)"[#:]");
            msysnewc_m_print_i64(var_decls_ttlower[(m)],NULL);
            msysnewc_m_print_end();
            ;
        };
        qc_lib_istrmode((int64_t)(var_decls_tttarget[(m)]),(int64_t)0,(dest + (int64_t)(strlen((int8_t *)(dest)))));
    }else if (((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)12)) {
        strcpy((int8_t *)(dest),(int8_t *)((uint8_t*)"enum("));
        d = var_decls_ttnamedef[(m)];
        value = (int64_t)1;
        needcomma = (int64_t)0;
        q = (*d).deflist;
        L1270 :;
        while (!!(q)) {
            if (!!(needcomma)) {
                strcat((int8_t *)(dest),(int8_t *)((uint8_t*)","));
            };
            needcomma = (int64_t)1;
            strcat((int8_t *)(dest),(int8_t *)((*q).name));
            x = (int64_t)((*q).index);
            if ((x != value)) {
                value = x;
                msysnewc_m_print_startstr((dest + (int64_t)(strlen((int8_t *)(dest)))));
                msysnewc_m_print_i64(value,NULL);
                msysnewc_m_print_end();
                ;
            };
            ++value;
            q = (*q).nextdef;
L1271 :;
        }L1272 :;
        ;
        strcat((int8_t *)(dest),(int8_t *)((uint8_t*)")"));
    }else if (((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)32) || ((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)33)) {
        if (!(!!(expand))) {
            strcpy((int8_t *)(dest),(int8_t *)(var_decls_ttname[(m)]));
            return;
        };
        strcat((int8_t *)(dest),(int8_t *)(var_decls_ttname[((int64_t)(var_decls_ttbasetype[(m)]))]));
        strcat((int8_t *)(dest),(int8_t *)((uint8_t*)"("));
        d = var_decls_ttnamedef[(m)];
        needcomma = (int64_t)0;
        q = (*d).deflist;
        L1273 :;
        while (!!(q)) {
            if (!!(needcomma)) {
                strcat((int8_t *)(dest),(int8_t *)((uint8_t*)","));
            };
            needcomma = (int64_t)1;
            qc_lib_istrmode((int64_t)((*q).mode),(int64_t)0,(dest + (int64_t)(strlen((int8_t *)(dest)))));
            strcat((int8_t *)(dest),(int8_t *)((uint8_t*)" "));
            strcat((int8_t *)(dest),(int8_t *)((*q).name));
            q = (*q).nextdef;
L1274 :;
        }L1275 :;
        ;
        strcat((int8_t *)(dest),(int8_t *)((uint8_t*)")"));
    }else if (((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)0)) {
        strcpy((int8_t *)(dest),(int8_t *)(var_decls_ttname[(m)]));
    }else if (((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)34)) {
        strcpy((int8_t *)(dest),(int8_t *)(var_decls_ttname[(m)]));
    } else {
        qc_support_serror((uint8_t*)"NEWSTRMODE");
    };
}

int64_t qc_lib_countunits(struct var_decls_unitrec * p) {
    int64_t n;
    n = (int64_t)0;
    L1276 :;
    while (!!(p)) {
        ++n;
        p = (*p).nextunit;
L1277 :;
    }L1278 :;
    ;
    return n;
}

struct var_decls_strec * qc_lib_finddefstr(struct var_decls_strec * owner,uint8_t * name) {
    struct var_decls_strec *  d;
    d = (*owner).deflist;
    L1279 :;
    while (!!(d)) {
        if (!!(mlib_eqstring((*d).name,name))) {
            return d;
        };
        d = (*d).nextdef;
L1280 :;
    }L1281 :;
    ;
    return (struct var_decls_strec *)(0);
}

static void qc_lib_purgesymbol(struct var_decls_strec * p,struct var_decls_strec * prev,int64_t del) {
    struct var_decls_strec *  q;
    if (((int64_t)((*p).nameid)==(int64_t)13)) {
        return;
    };
    qc_lib_purgesymbollist((*p).deflist,(int64_t)0,del);
    if (!!(prev)) {
        (*prev).nextdef = (*p).nextdef;
    } else {
        (*(*p).owner).deflist = (*p).nextdef;
    };
    q = (*p).prevdupl;
    (*q).nextdupl = (*p).nextdupl;
    if (!!(del)) {
        mlib_pcm_free((void *)(p),(int64_t)136);
    };
}

void qc_lib_purgesymbollist(struct var_decls_strec * p,int64_t ismodule,int64_t del) {
    struct var_decls_strec *  q;
    struct var_decls_strec *  prev;
    prev = (struct var_decls_strec *)(0);
    L1282 :;
    while (!!(p)) {
        q = (*p).nextdef;
        if (((ismodule == (int64_t)0) || !(!!((uint64_t)((*p).attribs.ax_global))))) {
            qc_lib_purgesymbol(p,prev,del);
        } else {
            prev = p;
        };
        p = q;
L1283 :;
    }L1284 :;
    ;
}

void qc_lib_purgeprocs(struct var_decls_strec * p,int64_t del) {
    L1285 :;
    while (!!(p)) {
        if (((int64_t)((uint64_t)((*p).nameid)) == (int64_t)5)) {
            qc_lib_purgeproc(p,del);
        };
        p = (*p).nextdef;
L1286 :;
    }L1287 :;
    ;
}

void qc_lib_purgeproc(struct var_decls_strec * p,int64_t del) {
    struct var_decls_strec *  q;
    struct var_decls_strec *  prev;
    struct var_decls_strec *  r;
    q = (*p).deflist;
    prev = (struct var_decls_strec *)(0);
    L1288 :;
    while (!!(q)) {
        r = (*q).nextdef;
        if (((int64_t)((uint64_t)((*q).nameid)) == (int64_t)11)) {
            qc_lib_purgesymbol(q,prev,del);
        } else {
            prev = q;
        };
        q = r;
L1289 :;
    }L1290 :;
    ;
}

void qc_lib_printmodelist(void * f) {
    uint8_t *  mstr;
    struct mlib_strbuffer destv;
    struct mlib_strbuffer *  dest;
    int64_t m;
    dest = &destv;
    mlib_gs_init(dest);
    mlib_gs_leftstr(dest,(uint8_t*)"#",(int64_t)4,(int64_t)32);
    mlib_gs_leftstr(dest,(uint8_t*)"Name",(int64_t)13,(int64_t)32);
    mlib_gs_leftstr(dest,(uint8_t*)"Base",(int64_t)13,(int64_t)32);
    mlib_gs_leftstr(dest,(uint8_t*)"Bit",(int64_t)3,(int64_t)32);
    mlib_gs_leftstr(dest,(uint8_t*)"Target",(int64_t)12,(int64_t)32);
    mlib_gs_leftstr(dest,(uint8_t*)"Def",(int64_t)4,(int64_t)32);
    mlib_gs_leftstr(dest,(uint8_t*)"Lwb",(int64_t)3,(int64_t)32);
    mlib_gs_leftstr(dest,(uint8_t*)"Upb",(int64_t)3,(int64_t)32);
    mlib_gs_leftstr(dest,(uint8_t*)"Len",(int64_t)4,(int64_t)32);
    mlib_gs_leftstr(dest,(uint8_t*)"Size",(int64_t)5,(int64_t)32);
    mlib_gs_leftstr(dest,(uint8_t*)"Cat",(int64_t)4,(int64_t)32);
    mlib_gs_leftstr(dest,(uint8_t*)"Used",(int64_t)4,(int64_t)32);
    mlib_gs_leftstr(dest,(uint8_t*)"Mode",(int64_t)32,(int64_t)32);
    mlib_gs_println(dest,f);
    L1291 :;
    for (m=(int64_t)0;m<=var_decls_ntypes;m+=(int64_t)1) {
L1292 :;
        mlib_gs_init(dest);
        mlib_gs_leftint(dest,m,(int64_t)4,(int64_t)32);
        mlib_gs_leftstr(dest,var_decls_ttname[(m)],(int64_t)13,(int64_t)32);
        mlib_gs_leftstr(dest,var_decls_ttname[((int64_t)(var_decls_ttbasetype[(m)]))],(int64_t)13,(int64_t)32);
        mlib_gs_leftint(dest,(int64_t)(var_decls_ttbitwidth[(m)]),(int64_t)3,(int64_t)32);
        if (!!((int64_t)(var_decls_tttarget[(m)]))) {
            mlib_gs_leftstr(dest,var_decls_ttname[((int64_t)(var_decls_tttarget[(m)]))],(int64_t)12,(int64_t)32);
        } else {
            mlib_gs_leftstr(dest,(uint8_t*)"-",(int64_t)12,(int64_t)32);
        };
        if (!!(var_decls_ttnamedef[(m)])) {
            mlib_gs_leftstr(dest,(uint8_t*)"+",(int64_t)4,(int64_t)32);
        } else {
            mlib_gs_leftstr(dest,(uint8_t*)"-",(int64_t)4,(int64_t)32);
        };
        if (((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)5) || ((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)9) || ((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)30) || ((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)32) || ((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)33) || ((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)12)) {
            mlib_gs_leftint(dest,(int64_t)(var_decls_ttlower[(m)]),(int64_t)3,(int64_t)32);
            mlib_gs_leftint(dest,(((int64_t)(var_decls_ttlower[(m)]) + (int64_t)(var_decls_ttlength[(m)])) - (int64_t)1),(int64_t)3,(int64_t)32);
            mlib_gs_leftint(dest,(int64_t)(var_decls_ttlength[(m)]),(int64_t)4,(int64_t)32);
        } else {
            mlib_gs_leftstr(dest,(uint8_t*)"",(int64_t)3,(int64_t)32);
            mlib_gs_leftstr(dest,(uint8_t*)"",(int64_t)3,(int64_t)32);
            mlib_gs_leftstr(dest,(uint8_t*)"",(int64_t)4,(int64_t)32);
        };
        mlib_gs_leftint(dest,(int64_t)(var_decls_ttsize[(m)]),(int64_t)5,(int64_t)32);
        mlib_gs_leftint(dest,(int64_t)(var_decls_ttusercat[(m)]),(int64_t)4,(int64_t)32);
        mstr = qc_lib_strmode(m,(int64_t)1);
        if (((int64_t)(strlen((int8_t *)(mstr))) < (int64_t)16)) {
            mlib_gs_str(dest,mstr);
        } else {
            mlib_gs_println(dest,f);
            mlib_gs_init(dest);
            mlib_gs_str(dest,mstr);
        };
        mlib_gs_println(dest,f);
L1293 :;
    }L1294 :;
    ;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

void qc_lib_printgenfieldtable(void * f,uint8_t * caption) {
    int64_t i;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_i64(var_decls_ngenfieldnames,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L1295 :;
    for (i=(int64_t)1;i<=var_decls_ngenfieldnames;i+=(int64_t)1) {
L1296 :;
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_i64(i,NULL);
        msysnewc_m_print_str((*var_decls_genfieldnames[(i)-1].def).name,NULL);
        msysnewc_m_print_i64(var_decls_genfieldnames[(i)-1].dataindex,NULL);
        msysnewc_m_print_i64(var_decls_genfieldnames[(i)-1].datalength,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
L1297 :;
    }L1298 :;
    ;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((uint8_t*)"Genfielddata:",NULL);
    msysnewc_m_print_i64(var_decls_ngenfielddata,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L1299 :;
    for (i=(int64_t)1;i<=var_decls_ngenfielddata;i+=(int64_t)1) {
L1300 :;
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_i64(var_decls_genfielddata[(i)-1].fieldindex,NULL);
        msysnewc_m_print_str(var_decls_ttname[((int64_t)(var_decls_genfielddata[(i)-1].recordtype))],NULL);
        msysnewc_m_print_str(var_decls_ttname[((int64_t)(var_decls_genfielddata[(i)-1].fieldtype))],NULL);
        msysnewc_m_print_i64(var_decls_genfielddata[(i)-1].offset,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
L1301 :;
    }L1302 :;
    ;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

void qc_lib_addtoproclist(struct var_decls_strec * d) {
    struct var_decls_procrec *  pp;
    ++var_decls_nproclist;
    pp = (struct var_decls_procrec *)(mlib_pcm_alloc((int64_t)16));
    (*pp).nextproc = var_decls_proclist;
    var_decls_proclist = pp;
    (*pp).def = d;
}

int64_t qc_lib_newusertypex(struct var_decls_strec * d,struct var_decls_strec * e) {
    if ((var_decls_nuserxtypes >= (int64_t)5000)) {
        qc_support_serror((uint8_t*)"Too many external user types");
    };
    ++var_decls_nuserxtypes;
    var_decls_ttnamedefx[(var_decls_nuserxtypes)] = d;
    var_decls_ttnamedefx2[(var_decls_nuserxtypes)] = e;
    var_decls_ttxmoduleno[(var_decls_nuserxtypes)] = (uint64_t)(var_decls_currmoduleno);
    var_decls_ttlinenox[(var_decls_nuserxtypes)] = ((int64_t)(qc_lex_lx.lineno) & (int64_t)16777215);
    return -(var_decls_nuserxtypes);
}

void qc_lib_storemode(struct var_decls_strec * owner,int64_t m,int16_t * p) {
    struct var_decls_userxrec *  q;
    (*p) = m;
    if ((m >= (int64_t)0)) {
        return;
    };
    q = (struct var_decls_userxrec *)(mlib_pcm_alloc((int64_t)24));
    (*q).owner = owner;
    if ((owner == 0)) {
        qc_support_serror((uint8_t*)"STOREMODE/OWNER=0");
    };
    (*q).pmode = p;
    (*q).nextmode = var_decls_userxmodelist;
    var_decls_userxmodelist = q;
}

struct var_decls_unitrec * qc_lib_duplunit(struct var_decls_unitrec * p) {
    struct var_decls_unitrec *  q;
    if ((p == 0)) {
        return (struct var_decls_unitrec *)(0);
    };
    q = qc_lib_createunit0((int64_t)((*p).tag));
    (*q).a = qc_lib_duplunit((*p).a);
    (*q).b = qc_lib_duplunit((*p).b);
    (*q).c = qc_lib_duplunit((*p).c);
    (*q).lineno = (int64_t)((*p).lineno);
    (*q).value = (*p).value;
    (*q).opcode = (int64_t)((*p).opcode);
    (*q).mode = (int64_t)((*p).mode);
    (*q).moduleno = (int64_t)((*p).moduleno);
    return q;
}

void qc_name_rx_unit(struct var_decls_strec * owner,struct var_decls_unitrec * p) {
    struct var_decls_unitrec *  a;
    struct var_decls_unitrec *  b;
    int64_t n;
    a = (*p).a;
    b = (*p).b;
    var_decls_mlineno = (int64_t)((*p).lineno);
    switch ((int64_t)((*p).tag)) {
    case 3:;
    {
        qc_name_resolvename(owner,p,(int64_t)0);
    }break;
    case 86:;
    {
        qc_name_rx_unit(owner,b);
    }break;
    case 141:;
    {
        qc_name_resolvedot(owner,p);
    }break;
    case 14:;
    case 90:;
    {
        qc_name_rx_unit(owner,a);
        qc_name_rx_unitlist(owner,b);
        if (((int64_t)((*a).tag) == (int64_t)151)) {
            (*p).tag = (int64_t)149;
            (*p).a = b;
            (*p).b = (struct var_decls_unitrec *)(0);
            (*p).mode = (int64_t)((*a).mode);
            if (!!((*b).nextunit)) {
                (*p).a = qc_lib_createunit1((int64_t)79,b);
                n = (int64_t)0;
                L1303 :;
                while (!!(b)) {
                    ++n;
                    b = (*b).nextunit;
L1304 :;
                }L1305 :;
                ;
                (*(*p).a).length = n;
            };
        };
    }break;
    case 33:;
    {
        if (((int64_t)((*a).tag) != (int64_t)3)) {
            qc_support_rxerror((uint8_t*)"Not simple label",(struct var_decls_unitrec *)(0));
        };
        qc_name_resolvename(owner,a,(int64_t)0);
        if (((int64_t)((uint64_t)((*(*a).def).nameid)) != (int64_t)16)) {
            qc_support_rxerror_s((uint8_t*)"Not a label or not found: #",(*(*a).def).name,(struct var_decls_unitrec *)(0));
        };
    }break;
    case 105:;
    case 106:;
    case 107:;
    case 108:;
    case 109:;
    case 112:;
    case 114:;
    case 115:;
    case 116:;
    case 117:;
    case 118:;
    case 82:;
    {
        qc_name_rx_unitlist(owner,a);
        if (!(!!(b))) {
            qc_support_rxerror((uint8_t*)"Binop missing opnd",(struct var_decls_unitrec *)(0));
        };
        qc_name_rx_unitlist(owner,b);
        qc_name_evalbinop(p,a,b);
    }break;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 103:;
    case 102:;
    {
        if (((int64_t)((*(*p).a).tag)==(int64_t)98) || ((int64_t)((*(*p).a).tag)==(int64_t)99) || ((int64_t)((*(*p).a).tag)==(int64_t)100) || ((int64_t)((*(*p).a).tag)==(int64_t)101) || ((int64_t)((*(*p).a).tag)==(int64_t)103) || ((int64_t)((*(*p).a).tag)==(int64_t)102)) {
            qc_name_converteqeq(owner,p);
        } else {
            goto L1306 ;
;
        };
        goto L1306 ;
;
    }break;
    case 156:;
    case 157:;
    case 182:;
    case 185:;
    case 161:;
    {
        qc_name_rx_unitlist(owner,a);
        qc_name_evalmonop(p);
    }break;
    case 23:;
    case 24:;
    {
        qc_name_resolvename(owner,a,(int64_t)40);
        a = (*a).nextunit;
        goto L1306 ;
;
    }break;
    case 149:;
    {
        qc_name_rx_unit(owner,a);
        if (((int64_t)((*a).tag) == (int64_t)1)) {
            qc_name_evalmonop(p);
        };
    }break;
    default: {
        //doabc:
L1306 :;
;
        qc_name_rx_unitlist(owner,a);
        if (!!(b)) {
            qc_name_rx_unitlist(owner,b);
        };
        if (!!((*p).c)) {
            qc_name_rx_unitlist(owner,(*p).c);
        };
    }
    } //SW
;
}

int64_t qc_name_rx_module(int64_t n) {
    var_decls_currmoduleno = n;
    qc_name_rx_passdef(var_decls_stprogram,var_decls_moduletable[(n)].stmodule);
    return (int64_t)1;
}

void qc_name_rx_deflist(struct var_decls_strec * owner,struct var_decls_strec * p) {
    L1307 :;
    while (!!(p)) {
        qc_name_rx_passdef(owner,p);
        p = (*p).nextdef;
L1308 :;
    }L1309 :;
    ;
}

void qc_name_rx_passdef(struct var_decls_strec * owner,struct var_decls_strec * p) {
    if (((int64_t)((*p).nameid)==(int64_t)2) || ((int64_t)((*p).nameid)==(int64_t)3)) {
        qc_name_rx_deflist(p,(*p).deflist);
    }else if (((int64_t)((*p).nameid)==(int64_t)5)) {
        qc_name_fixmode(owner,p);
        qc_name_rx_deflist(p,(*p).deflist);
        qc_name_currstproc = p;
        qc_name_rx_unit(p,(*p).code);
        qc_name_currstproc = (struct var_decls_strec *)(0);
    }else if (((int64_t)((*p).nameid)==(int64_t)6)) {
        qc_name_fixmode(owner,p);
        qc_name_rx_deflist(p,(*p).deflist);
    }else if (((int64_t)((*p).nameid)==(int64_t)9) || ((int64_t)((*p).nameid)==(int64_t)10) || ((int64_t)((*p).nameid)==(int64_t)11) || ((int64_t)((*p).nameid)==(int64_t)12)) {
        if (!!((*p).code)) {
            qc_name_rx_unit(owner,(*p).code);
        };
    }else if (((int64_t)((*p).nameid)==(int64_t)4)) {
        qc_name_fixmode(owner,p);
        qc_name_rx_deflist(p,(*p).deflist);
    } else {
    };
}

static void qc_name_rx_unitlist(struct var_decls_strec * owner,struct var_decls_unitrec * p) {
    L1310 :;
    while (!!(p)) {
        qc_name_rx_unit(owner,p);
        p = (*p).nextunit;
L1311 :;
    }L1312 :;
    ;
}

struct var_decls_strec * qc_name_resolvetopname(struct var_decls_strec * owner,struct var_decls_strec * stnewname,int64_t moduleno,int64_t fmodule) {
    int64_t i;
    int64_t extcount;
    int64_t modno;
    struct var_decls_strec *  p;
    struct var_decls_strec *  q;
    struct var_decls_strec *  powner;
    struct var_decls_strec *  dlldef;
    struct var_decls_strec *  extdef;
    struct var_decls_strec *  moddef;
    struct var_decls_strec *  extmod;
    struct var_decls_strec *  ambiglist[10];
    int64_t ndupl;
    if (((int64_t)((uint64_t)((*owner).nameid)) == (int64_t)5)) {
        q = (*owner).deflist;
        L1313 :;
        while (!!(q)) {
            if (((*q).firstdupl == stnewname)) {
                return q;
            };
            q = (*q).nextdef;
L1314 :;
        }L1315 :;
        ;
    };
    p = (*stnewname).nextdupl;
    extcount = (int64_t)0;
    extmod = (dlldef = (extdef = (moddef = (struct var_decls_strec *)(0))));
    ndupl = (int64_t)0;
    L1316 :;
    while (!!(p)) {
        ++ndupl;
        powner = (*p).owner;
        switch ((int64_t)((*powner).nameid)) {
        case 5:;
        {
            if ((powner == owner)) {
                return p;
            };
        }break;
        case 2:;
        {
            if (((int64_t)((uint64_t)((*powner).attribs.ax_moduleno)) == moduleno)) {
                if (((int64_t)((uint64_t)((*owner).nameid)) == (int64_t)2)) {
                    return p;
                };
                moddef = p;
            } else if (!!((uint64_t)(var_decls_moduletable[(moduleno)].importmap[((int64_t)((*powner).attribs.ax_moduleno))-1]))) {
                if (!!((uint64_t)((*p).attribs.ax_global))) {
                    ++extcount;
                    extdef = p;
                    //storeextdef:
L1319 :;
;
                    if ((extcount < (int64_t)10)) {
                        ambiglist[(extcount)-1] = extdef;
                    };
                } else if ((((int64_t)((uint64_t)((*p).nameid)) == (int64_t)18) && !!((uint64_t)((*(*p).equiv).attribs.ax_global)))) {
                    ++extcount;
                    extdef = (*p).equiv;
                    goto L1319 ;
;
                };
            };
        }break;
        case 3:;
        {
            modno = (int64_t)((*powner).attribs.ax_moduleno);
            if (((modno == moduleno) || !!((uint64_t)(var_decls_moduletable[(moduleno)].importmap[(modno)-1])))) {
                dlldef = p;
            };
        }break;
        case 4:;
        {
            if ((powner == owner)) {
                return p;
            };
        }break;
        case 1:;
        {
            if (((int64_t)((uint64_t)((*p).nameid)) == (int64_t)2)) {
                if (!!(fmodule)) {
                    return p;
                };
            };
        }break;
        default: {
        }
        } //SW
;
        p = (*p).nextdupl;
L1317 :;
    }L1318 :;
    ;
    if (!!(moddef)) {
        return moddef;
    };
    if (!!(extdef)) {
        if ((extcount > (int64_t)1)) {
            L1320 :;
            for (i=(int64_t)1;i<=extcount;i+=(int64_t)1) {
L1321 :;
                extdef = ambiglist[(i)-1];
                msysnewc_m_print_startcon();
                msysnewc_m_print_i64(i,NULL);
                msysnewc_m_print_str((*(*extdef).owner).name,NULL);
                msysnewc_m_print_str(pq_common_namenames[((int64_t)((*(*extdef).owner).nameid))],NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
L1322 :;
            }L1323 :;
            ;
            qc_support_rxerror_s((uint8_t*)"Ambiguous ext name: #",(*extdef).name,(struct var_decls_unitrec *)(0));
        };
        return extdef;
    };
    if (!!(extmod)) {
        return extmod;
    };
    return dlldef;
}

void qc_name_resolvename(struct var_decls_strec * owner,struct var_decls_unitrec * p,int64_t mode) {
    struct var_decls_strec *  d;
    struct var_decls_strec *  e;
    struct var_decls_unitrec *  q;
    int64_t moduleno;
    d = (*p).def;
    moduleno = (int64_t)((*p).moduleno);
    if (!((((*d).nameid == (int64_t)0) || ((*d).nameid == (int64_t)14)))) {
        return;
    };
    e = qc_name_resolvetopname(owner,d,moduleno,qc_name_allowmodname);
    if (!(!!(e))) {
        if (((int64_t)((uint64_t)((*owner).nameid)) == (int64_t)5)) {
            e = ((*p).def = qc_lib_getduplnameptr(owner,(*p).def,(int64_t)11));
            qc_lib_adddef(owner,e);
            (*e).mode = (int64_t)35;
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((*d).name,NULL);
            msysnewc_m_print_i64((*p).lineno,NULL);
            msysnewc_m_print_str(qc_tables_jtagnames[((int64_t)((*p).tag))],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            qc_support_rxerror_s((uint8_t*)"Undefined: #",(*d).name,p);
        };
    } else {
        //retry:
L1324 :;
;
        (*p).def = e;
        if (((int64_t)((*e).nameid)==(int64_t)9)) {
            q = (*e).code;
            qc_name_rx_unit(owner,q);
            if (((int64_t)((*q).tag) != (int64_t)1)) {
                qc_support_rxerror_s((uint8_t*)"Not const expr: #",qc_tables_jtagnames[((int64_t)((*q).tag))],(struct var_decls_unitrec *)(0));
            };
            (*e).mode = (int64_t)((*q).mode);
            (*p).tag = (int64_t)1;
            (*p).value = (*q).value;
            (*p).mode = (int64_t)((*q).mode);
            (*p).slength = (int64_t)((*q).slength);
        }else if (((int64_t)((*e).nameid)==(int64_t)15)) {
            qc_support_rxerror((uint8_t*)"FOUND ENUMID",p);
        }else if (((int64_t)((*e).nameid)==(int64_t)10)) {
        }else if (((int64_t)((*e).nameid)==(int64_t)4)) {
            (*p).tag = (int64_t)151;
            (*p).mode = (int64_t)((*(*p).def).mode);
        }else if (((int64_t)((*e).nameid)==(int64_t)18)) {
            e = (*e).equiv;
            goto L1324 ;
;
        }else if (((int64_t)((*e).nameid)==(int64_t)19)) {
            qc_support_rxerror((uint8_t*)"FOUND LINK",p);
        };
    };
}

struct var_decls_strec * qc_name_finddupl(struct var_decls_strec * d,struct var_decls_strec * pdupl) {
    if (!((((*pdupl).nameid == (int64_t)0) || ((*pdupl).nameid == (int64_t)14)))) {
        return pdupl;
    };
    pdupl = (*pdupl).nextdupl;
    L1325 :;
    while (!!(pdupl)) {
        if (((*pdupl).owner == d)) {
            if ((((*pdupl).nameid == (int64_t)18) || ((*pdupl).nameid == (int64_t)19))) {
                return (*d).equiv;
            };
            return pdupl;
        };
        pdupl = (*pdupl).nextdupl;
L1326 :;
    }L1327 :;
    ;
    return (struct var_decls_strec *)(0);
}

static void qc_name_resolvedot(struct var_decls_strec * owner,struct var_decls_unitrec * p) {
    struct var_decls_strec *  rdef;
    struct var_decls_strec *  d;
    struct var_decls_strec *  newd;
    struct var_decls_strec *  e;
    struct var_decls_strec *  fielddef;
    struct var_decls_unitrec *  q;
    struct var_decls_unitrec *  r;
    int64_t nfields;
    int64_t oldallowmod;
    q = (*p).a;
    r = (*p).b;
    rdef = (*r).def;
    oldallowmod = qc_name_allowmodname;
    qc_name_allowmodname = ((int64_t)((*q).tag) == (int64_t)3);
    qc_name_rx_unit(owner,q);
    qc_name_allowmodname = oldallowmod;
    if (((int64_t)((*q).tag)==(int64_t)3)) {
        d = (*q).def;
    }else if (((int64_t)((*q).tag)==(int64_t)151)) {
        d = (*q).def;
        goto L1328 ;
;
    } else {
        rdef = (*r).def;
        goto L1329 ;
;
    };
    switch ((int64_t)((*d).nameid)) {
    case 3:;
    case 2:;
    case 4:;
    case 5:;
    case 6:;
    {
        //dotype:
L1328 :;
;
        newd = qc_name_finddupl(d,rdef);
        if (!!(newd)) {
            switch ((int64_t)((*newd).nameid)) {
            case 15:;
            {
                (*p).tag = (int64_t)1;
                (*p).value = (int64_t)((*newd).index);
                (*p).mode = (int64_t)1;
            }break;
            case 9:;
            {
                q = (*newd).code;
                if (((int64_t)((*q).tag)==(int64_t)1)) {
                    (*p).tag = (int64_t)1;
                    (*p).value = (*q).value;
                    (*p).mode = (int64_t)((*newd).mode);
                    (*p).a = ((*p).b = (struct var_decls_unitrec *)(0));
                } else {
                    qc_support_rxerror((uint8_t*)"Rxdot:const?",p);
                };
            }break;
            case 4:;
            {
                (*p).tag = (int64_t)151;
                (*p).mode = (int64_t)((*newd).mode);
                (*p).def = newd;
            }break;
            case 10:;
            {
                (*p).tag = (int64_t)3;
                (*p).def = newd;
            }break;
            case 5:;
            case 6:;
            {
                (*p).tag = (int64_t)3;
                (*p).def = newd;
                (*p).a = ((*p).b = (struct var_decls_unitrec *)(0));
                (*p).dottedname = (uint64_t)((int64_t)1);
            }break;
            case 19:;
            {
                L1330 :;
                do {
                    newd = (*newd).equiv;
L1331 :;
                } while (!((int64_t)((uint64_t)((*newd).nameid)) != (int64_t)19));L1332 :;
                ;
                (*p).tag = (int64_t)3;
                (*p).def = newd;
            }break;
            default: {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str(pq_common_namenames[((int64_t)((*newd).nameid))],NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_str((uint8_t*)".",NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_str((*newd).name,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                qc_support_rxerror((uint8_t*)"Rxdot:.name not allowed here",p);
            }
            } //SW
;
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((*d).name,NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((uint8_t*)".",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((*rdef).name,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            qc_support_rxerror((uint8_t*)"Can't resolve",p);
        };
    }break;
    case 11:;
    case 10:;
    case 12:;
    case 13:;
    case 14:;
    {
        //doexprdot:
L1329 :;
;
        nfields = (int64_t)0;
        fielddef = (struct var_decls_strec *)(0);
        e = (*rdef).nextdupl;
        L1333 :;
        while (!!(e)) {
            if (((int64_t)((*e).nameid)==(int64_t)13) || ((int64_t)((*e).nameid)==(int64_t)9) || ((int64_t)((*e).nameid)==(int64_t)5) || ((int64_t)((*e).nameid)==(int64_t)4) || ((int64_t)((*e).nameid)==(int64_t)10) || ((int64_t)((*e).nameid)==(int64_t)6) || ((int64_t)((*e).nameid)==(int64_t)19)) {
                ++nfields;
                fielddef = e;
            };
            e = (*e).nextdupl;
L1334 :;
        }L1335 :;
        ;
        if ((nfields==(int64_t)0)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((*rdef).name,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            qc_support_rxerror((uint8_t*)"Can't find field",p);
        } else {
            if (((int64_t)((uint64_t)((*rdef).nameid)) != (int64_t)14)) {
                (*rdef).nameid = (uint64_t)((int64_t)14);
                var_decls_genfieldnames[(++var_decls_ngenfieldnames)-1].def = rdef;
                (*rdef).offset = var_decls_ngenfieldnames;
            };
        };
    }break;
    default: {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(pq_common_namenames[((int64_t)((*d).nameid))],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        qc_support_rxerror((uint8_t*)"RXDOT:Unknown nameid",p);
    }
    } //SW
;
}

static void qc_name_fixmode(struct var_decls_strec * owner,struct var_decls_strec * p) {
    struct var_decls_strec *  d;
    struct var_decls_strec *  e;
    int64_t m;
    m = (int64_t)((*p).mode);
    if ((m >= (int64_t)0)) {
        return;
    };
    m = -(m);
    if (!!(var_decls_ttxmap[(m)])) {
        (*p).mode = var_decls_ttxmap[(m)];
        return;
    };
    if (!!(var_decls_ttnamedefx2[(m)])) {
        qc_support_rxerror((uint8_t*)"Can't resolve a:b tentative types yet",(struct var_decls_unitrec *)(0));
    };
    d = var_decls_ttnamedefx[(m)];
    e = qc_name_resolvetopname(owner,d,(int64_t)(var_decls_ttxmoduleno[(m)]),(int64_t)0);
    if (!!(e)) {
        var_decls_ttxmap[(m)] = (int64_t)((*e).mode);
        (*p).mode = (int64_t)((*e).mode);
    } else {
        qc_support_rxerror_s((uint8_t*)"Can't resolve tentative type: #",(*d).name,(struct var_decls_unitrec *)(0));
    };
}

static int64_t qc_name_fixmode2(struct var_decls_strec * owner,int64_t m) {
    struct var_decls_strec *  d;
    struct var_decls_strec *  e;
    uint8_t str[256];
    if ((m >= (int64_t)0)) {
        return m;
    };
    m = -(m);
    if (!!(var_decls_ttxmap[(m)])) {
        return var_decls_ttxmap[(m)];
    };
    if (!!(var_decls_ttnamedefx2[(m)])) {
        qc_support_rxerror((uint8_t*)"2:Can't resolve a:b tentative types yet",(struct var_decls_unitrec *)(0));
    };
    d = var_decls_ttnamedefx[(m)];
    if ((owner == 0)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((*d).name,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        qc_support_rxerror((uint8_t*)"FIXMODE2 OWNER=0",(struct var_decls_unitrec *)(0));
    };
    e = qc_name_resolvetopname(owner,d,(int64_t)(var_decls_ttxmoduleno[(m)]),(int64_t)0);
    if (!!(e)) {
        var_decls_ttxmap[(m)] = (int64_t)((*e).mode);
        return (int64_t)((*e).mode);
    } else {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"# in module #, line:#");
        msysnewc_m_print_str((*d).name,NULL);
        msysnewc_m_print_str(var_decls_moduletable[((int64_t)(var_decls_ttxmoduleno[(m)]))].name,NULL);
        msysnewc_m_print_i64(var_decls_ttlinenox[(m)],NULL);
        msysnewc_m_print_end();
        ;
        qc_support_rxerror_s((uint8_t*)"2:Can't resolve tentative type: #",str,(struct var_decls_unitrec *)(0));
    };
    return (int64_t)0;
}

void qc_name_fixusertypes(void) {
    struct var_decls_userxrec *  p;
    int64_t m;
    int64_t rescan;
    int64_t i;
    L1336 :;
    for (i=(int64_t)1;i<=(int64_t)2;i+=(int64_t)1) {
L1337 :;
        p = var_decls_userxmodelist;
        rescan = (int64_t)0;
        L1340 :;
        while (!!(p)) {
            m = (int64_t)((*(*p).pmode));
            if ((m < (int64_t)0)) {
                m = qc_name_fixmode2((*p).owner,m);
                if ((((m < (int64_t)0) && (i == (int64_t)2)) && !!(var_decls_ttxmap[(labs(m))]))) {
                    m = var_decls_ttxmap[(labs(m))];
                };
                if ((m < (int64_t)0)) {
                    rescan = (int64_t)1;
                } else {
                    (*(*p).pmode) = m;
                    if (((int64_t)(var_decls_tttarget[(m)]) == m)) {
                        msysnewc_m_print_startcon();
                        msysnewc_m_print_str((uint8_t*)"TTNAME[M]=",NULL);
                        msysnewc_m_print_str(var_decls_ttname[(m)],NULL);
                        msysnewc_m_print_newline();
                        msysnewc_m_print_end();
                        ;
                        qc_support_rxerror((uint8_t*)"RECURSIVE TYPE?",(struct var_decls_unitrec *)(0));
                    };
                };
            };
            p = (*p).nextmode;
L1341 :;
        }L1342 :;
        ;
        if (!(!!(rescan))) {
            goto L1339 ;
        };
L1338 :;
    }L1339 :;
    ;
    if (!!(rescan)) {
        qc_support_rxerror((uint8_t*)"FIXUSERTYPES PHASE ERROR",(struct var_decls_unitrec *)(0));
    };
    L1343 :;
    for (i=(int64_t)1;i<=var_decls_nbaseclasses;i+=(int64_t)1) {
L1344 :;
        qc_name_dobaseclass(i);
L1345 :;
    }L1346 :;
    ;
}

struct var_decls_strec * qc_name_resolve_equiv_name(struct var_decls_strec * owner,struct var_decls_strec * p) {
    if (((int64_t)((uint64_t)((*p).nameid)) == (int64_t)13)) {
        return p;
    };
    qc_support_rxerror((uint8_t*)"RESOLVE EQUIV FIELD/COMPLEX",(struct var_decls_unitrec *)(0));
    return (struct var_decls_strec *)(0);
}

static struct var_decls_strec * qc_name_addframevar(struct var_decls_strec * owner,struct var_decls_strec * d,int64_t moduleno,int64_t mode) {
    struct var_decls_strec *  e;
    e = qc_lib_getduplnameptr(owner,d,(int64_t)11);
    qc_lib_storemode(owner,mode,&(*e).mode);
    qc_lib_adddef(owner,e);
    return e;
}

static void qc_name_converteqeq(struct var_decls_strec * owner,struct var_decls_unitrec * p) {
    int64_t leftop;
    int64_t rightop;
    struct var_decls_unitrec *  w;
    struct var_decls_unitrec *  y1;
    struct var_decls_unitrec *  y2;
    struct var_decls_unitrec *  z;
    w = (*p).a;
    y1 = (*w).b;
    y2 = qc_lib_duplunit(y1);
    z = (*p).b;
    leftop = (int64_t)((*w).tag);
    rightop = (int64_t)((*p).tag);
    (*p).tag = (int64_t)74;
    (*p).b = qc_lib_createunit2(rightop,y2,z);
    qc_name_rx_unitlist(owner,w);
    qc_name_rx_unitlist(owner,y2);
    qc_name_rx_unitlist(owner,z);
}

void qc_name_evalbinop(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    int64_t x;
    int64_t y;
    int64_t z;
    int64_t xt;
    int64_t yt;
    if (!((((int64_t)((*a).tag) == (int64_t)((*b).tag)) && ((int64_t)((*b).tag) == (int64_t)1)))) {
        return;
    };
    xt = (int64_t)((*a).mode);
    yt = (int64_t)((*b).mode);
    if (((xt == yt) && (yt == (int64_t)3))) {
        qc_name_evalbinop_real(p,a,b);
        return;
    };
    if (!(((xt == yt) && (yt == (int64_t)1)))) {
        return;
    };
    x = (*a).value;
    y = (*b).value;
    switch ((int64_t)((*p).tag)) {
    case 105:;
    {
        z = (x + y);
    }break;
    case 106:;
    {
        z = (x - y);
    }break;
    case 107:;
    {
        z = (x * y);
    }break;
    case 109:;
    {
        z = (x / y);
    }break;
    case 82:;
    {
        z = ((y << (int64_t)32) | (x & (int64_t)4294967295));
        qc_name_makenewconst(p,z,(int64_t)4);
        return;
    }break;
    default: {
        return;
    }
    } //SW
;
    qc_name_makenewconst(p,z,(int64_t)1);
}

static void qc_name_evalbinop_real(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    double x;
    double y;
    double z;
    x = (*a).xvalue;
    y = (*b).xvalue;
    switch ((int64_t)((*p).tag)) {
    case 105:;
    {
        z = (x + y);
    }break;
    case 106:;
    {
        z = (x - y);
    }break;
    case 107:;
    {
        z = (x * y);
    }break;
    case 108:;
    {
        z = (x / y);
    }break;
    default: {
        return;
    }
    } //SW
;
    qc_name_makenewconst(p,*(int64_t*)&z,(int64_t)3);
}

static void qc_name_makenewconst(struct var_decls_unitrec * p,int64_t value,int64_t t) {
    (*p).tag = (int64_t)1;
    (*p).value = value;
    (*p).mode = t;
    (*p).a = (struct var_decls_unitrec *)(0);
    (*p).b = (struct var_decls_unitrec *)(0);
}

void qc_name_evalmonop(struct var_decls_unitrec * p) {
    int64_t a;
    int64_t c;
    double x;
    double z;
    struct var_decls_unitrec *  pa;
    pa = (*p).a;
    if (((int64_t)((*pa).tag)==(int64_t)1)) {
    }else if (((int64_t)((*pa).tag)==(int64_t)151)) {
        if (((int64_t)((*p).tag)==(int64_t)185)) {
            qc_name_makenewconst(p,(int64_t)(var_decls_ttsize[((int64_t)((*pa).mode))]),(int64_t)1);
            return;
        }else if (((int64_t)((*p).tag)==(int64_t)182)) {
            return;
        };
    } else {
        return;
    };
    a = (*pa).value;
    x = (*pa).xvalue;
    if (((int64_t)((*(*p).a).mode)==(int64_t)1)) {
        switch ((int64_t)((*p).tag)) {
        case 156:;
        {
            c = -(a);
        }break;
        case 157:;
        {
            c = labs(a);
        }break;
        case 149:;
        {
            if (((int64_t)(var_decls_ttbasetype[((int64_t)((*p).mode))])==(int64_t)3)) {
                x = (double)(a);
                qc_name_makenewconst(p,*(int64_t*)&x,(int64_t)3);
                return;
            } else {
                return;
            };
        }break;
        case 161:;
        {
            z = sqrt(((double)(a)));
            qc_name_makenewconst(p,*(int64_t*)&z,(int64_t)3);
            return;
        }break;
        default: {
            return;
        }
        } //SW
;
    }else if (((int64_t)((*(*p).a).mode)==(int64_t)3)) {
        switch ((int64_t)((*p).tag)) {
        case 156:;
        {
            z = -(x);
        }break;
        case 157:;
        {
            z = fabs(x);
        }break;
        case 149:;
        {
            if (((int64_t)(var_decls_ttbasetype[((int64_t)((*p).mode))])==(int64_t)1)) {
                qc_name_makenewconst(p,(int64_t)(x),(int64_t)1);
                return;
            } else {
                return;
            };
        }break;
        case 161:;
        {
            z = sqrt((x));
        }break;
        default: {
            return;
        }
        } //SW
;
        qc_name_makenewconst(p,*(int64_t*)&z,(int64_t)3);
        return;
    }else if (((int64_t)((*(*p).a).mode)==(int64_t)5)) {
        switch ((int64_t)((*p).tag)) {
        case 182:;
        {
            c = (int64_t)((*pa).slength);
        }break;
        default: {
            return;
        }
        } //SW
;
    } else {
        return;
    };
    qc_name_makenewconst(p,c,(int64_t)1);
}

void qc_name_tx_typetable(void) {
    int64_t i;
    L1347 :;
    for (i=(int64_t)34;i<=var_decls_ntypes;i+=(int64_t)1) {
L1348 :;
        qc_name_converttype(i);
L1349 :;
    }L1350 :;
    ;
}

static void qc_name_checkconstexpr(struct var_decls_unitrec * a) {
    if (((int64_t)((*a).tag) == (int64_t)1)) {
        return;
    };
    qc_support_rxerror_s((uint8_t*)"Not const expr: %s",qc_tables_jtagnames[((int64_t)((*a).tag))],(struct var_decls_unitrec *)(0));
}

void qc_name_converttype(int64_t m) {
    struct var_decls_strec *  d;
    struct var_decls_strec *  owner;
    int64_t first;
    int64_t a;
    int64_t b;
    int64_t nbits;
    int64_t recordsize;
    int64_t index;
    struct var_decls_strec *  fieldlist[256];
    int64_t nofields;
    int64_t oldmodno;
    struct var_decls_unitrec *  plength;
    struct var_decls_unitrec *  plower;
    if (!!((int64_t)(var_decls_ttsize[(m)]))) {
        return;
    };
    owner = var_decls_ttowner[(m)];
    plower = var_decls_ttlowerexpr[(m)];
    plength = var_decls_ttlengthexpr[(m)];
    var_decls_mlineno = var_decls_ttlineno[(m)];
    oldmodno = var_decls_currmoduleno;
    var_decls_currmoduleno = (int64_t)(var_decls_ttmoduleno[(m)]);
    if (((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)5) || ((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)21)) {
        var_decls_ttsize[(m)] = (int64_t)((var_decls_ttlength[(m)] = qc_name_getconstint(owner,plength)));
    }else if (((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)9)) {
        var_decls_ttlength[(m)] = qc_name_getconstint(owner,plength);
        var_decls_ttsize[(m)] = (((((int64_t)(var_decls_ttlength[(m)]) - (int64_t)1) / (int64_t)64) + (int64_t)1) * (int64_t)8);
    }else if (((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)30)) {
        if (!!(plower)) {
            var_decls_ttlower[(m)] = qc_name_getconstint(owner,plower);
        } else {
            var_decls_ttlower[(m)] = (int64_t)1;
        };
        var_decls_ttlength[(m)] = qc_name_getconstint(owner,plength);
        if (((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)41) || ((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)42) || ((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)43)) {
            nbits = ((int64_t)(var_decls_ttlength[(m)]) * (int64_t)(var_decls_ttbitwidth[((int64_t)(var_decls_tttarget[(m)]))]));
            var_decls_ttsize[(m)] = (((nbits - (int64_t)1) / (int64_t)8) + (int64_t)1);
        } else {
            qc_name_converttype((int64_t)(var_decls_tttarget[(m)]));
            var_decls_ttsize[(m)] = ((int64_t)(var_decls_ttlength[(m)]) * (int64_t)(var_decls_ttsize[((int64_t)(var_decls_tttarget[(m)]))]));
        };
    }else if (((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)12)) {
        first = (int64_t)1;
        a = (b = (int64_t)0);
        d = (*var_decls_ttnamedef[(m)]).deflist;
        L1351 :;
        while (!!(d)) {
            if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)15)) {
                if (!!(first)) {
                    first = (int64_t)0;
                    a = (b = (int64_t)((*d).index));
                } else {
                    a = msysnewc_m_imin(a,(int64_t)((*d).index));
                    b = msysnewc_m_imax(b,(int64_t)((*d).index));
                };
            };
            d = (*d).nextdef;
L1352 :;
        }L1353 :;
        ;
        var_decls_ttlower[(m)] = a;
        var_decls_ttlength[(m)] = ((b - a) + (int64_t)1);
    }else if (((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)23)) {
        qc_name_converttype((int64_t)(var_decls_tttarget[(m)]));
        var_decls_ttsize[(m)] = (((int64_t)64 == (int64_t)64)?(int64_t)8:(int64_t)4);
    }else if (((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)32)) {
        nofields = (int64_t)0;
        d = (*var_decls_ttnamedef[(m)]).deflist;
        L1354 :;
        while (!!(d)) {
            if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)13)) {
                if (((int64_t)(var_decls_ttbasetype[((int64_t)((*d).mode))]) > (int64_t)35)) {
                    msysnewc_m_print_startcon();
                    msysnewc_m_print_str(var_decls_ttname[(m)],NULL);
                    msysnewc_m_print_newline();
                    msysnewc_m_print_end();
                    ;
                    qc_support_gerror((uint8_t*)"Packtype in record",(struct var_decls_unitrec *)(0));
                };
                if ((nofields >= (int64_t)256)) {
                    qc_support_gerror((uint8_t*)"CT: too many fields",(struct var_decls_unitrec *)(0));
                };
                fieldlist[(++nofields)-1] = d;
                qc_name_converttype((int64_t)((*d).mode));
            };
            d = (*d).nextdef;
L1355 :;
        }L1356 :;
        ;
        qc_name_nallfields = (qc_name_nfields = (int64_t)0);
        recordsize = qc_name_scanrecord(&fieldlist,nofields);
        var_decls_ttlower[(m)] = (int64_t)1;
        var_decls_ttsize[(m)] = recordsize;
        var_decls_ttlength[(m)] = qc_name_nfields;
    }else if (((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)33)) {
        nofields = (int64_t)0;
        d = (*var_decls_ttnamedef[(m)]).deflist;
        L1357 :;
        while (!!(d)) {
            if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)13)) {
                if (((int64_t)(var_decls_ttbasetype[(m)]) == (int64_t)33)) {
                    if (((int64_t)(var_decls_ttbasetype[((int64_t)((*d).mode))])==(int64_t)35)) {
                        msysnewc_m_print_startcon();
                        msysnewc_m_print_str(var_decls_ttname[(m)],NULL);
                        msysnewc_m_print_newline();
                        msysnewc_m_print_end();
                        ;
                        qc_support_gerror((uint8_t*)"Var in struct",(struct var_decls_unitrec *)(0));
                    }else if (((int64_t)(var_decls_ttbasetype[((int64_t)((*d).mode))])==(int64_t)50) || ((int64_t)(var_decls_ttbasetype[((int64_t)((*d).mode))])==(int64_t)51) || ((int64_t)(var_decls_ttbasetype[((int64_t)((*d).mode))])==(int64_t)52)) {
                        msysnewc_m_print_startcon();
                        msysnewc_m_print_str(var_decls_ttname[(m)],NULL);
                        msysnewc_m_print_newline();
                        msysnewc_m_print_end();
                        ;
                        qc_support_gerror((uint8_t*)"Intm/etc in struct",(struct var_decls_unitrec *)(0));
                    };
                } else {
                    if (((int64_t)(var_decls_ttbasetype[((int64_t)((*d).mode))]) != (int64_t)35)) {
                        msysnewc_m_print_startcon();
                        msysnewc_m_print_str(var_decls_ttname[(m)],NULL);
                        msysnewc_m_print_newline();
                        msysnewc_m_print_end();
                        ;
                        qc_support_gerror((uint8_t*)"Packtype in record",(struct var_decls_unitrec *)(0));
                    };
                };
                if ((nofields >= (int64_t)256)) {
                    qc_support_gerror((uint8_t*)"CT: too many fields",(struct var_decls_unitrec *)(0));
                };
                fieldlist[(++nofields)-1] = d;
                qc_name_converttype((int64_t)((*d).mode));
            };
            d = (*d).nextdef;
L1358 :;
        }L1359 :;
        ;
        qc_name_nallfields = (qc_name_nfields = (int64_t)0);
        index = nofields;
        recordsize = qc_name_scanstruct((int64_t)1,&fieldlist,nofields,&index,(int64_t)0,(int64_t)2);
        d = var_decls_ttnamedef[(m)];
        if (((int64_t)((*d).attribs.ax_align)==(int64_t)2)) {
            L1360 :;
            while (!!((recordsize & (int64_t)1))) {
                ++recordsize;
L1361 :;
            }L1362 :;
            ;
        }else if (((int64_t)((*d).attribs.ax_align)==(int64_t)4)) {
            L1363 :;
            while (!!((recordsize & (int64_t)3))) {
                ++recordsize;
L1364 :;
            }L1365 :;
            ;
        }else if (((int64_t)((*d).attribs.ax_align)==(int64_t)8)) {
            L1366 :;
            while (!!((recordsize & (int64_t)7))) {
                ++recordsize;
L1367 :;
            }L1368 :;
            ;
        };
        var_decls_ttlower[(m)] = (int64_t)1;
        var_decls_ttsize[(m)] = recordsize;
        var_decls_ttlength[(m)] = qc_name_nfields;
    };
    var_decls_currmoduleno = oldmodno;
}

static int64_t qc_name_scanstruct(int64_t fstruct,struct var_decls_strec * (*flist)[],int64_t flistlen,int64_t * index,int64_t nextoffset,int64_t countmode) {
    int64_t startoffset;
    int64_t maxsize;
    int64_t exitflag;
    int64_t size;
    int64_t star;
    int64_t alignment;
    struct var_decls_strec *  d;
    struct var_decls_strec *  e;
    struct var_decls_uflagsrec flags;
    startoffset = nextoffset;
    maxsize = (int64_t)0;
    exitflag = (int64_t)0;
    L1369 :;
    while ((!(!!(exitflag)) && ((*index) >= (int64_t)1))) {
        d = (*flist)[((*index))-1];
        flags = (*d).uflags;
        if (((int64_t)(flags.codes[((int64_t)1)-1])==(int64_t)83)) {
            qc_name_shiftflagsleft(&(*d).uflags);
            size = qc_name_scanstruct((int64_t)1,flist,flistlen,index,nextoffset,countmode);
        }else if (((int64_t)(flags.codes[((int64_t)1)-1])==(int64_t)85)) {
            qc_name_shiftflagsleft(&(*d).uflags);
            size = qc_name_scanstruct((int64_t)0,flist,flistlen,index,nextoffset,(!!(countmode)?(int64_t)1:(int64_t)0));
        }else if (((int64_t)(flags.codes[((int64_t)1)-1])==(int64_t)69)) {
            qc_name_shiftflagsleft(&(*d).uflags);
            if (((int64_t)((uint64_t)((*d).uflags.ulength)) == (int64_t)0)) {
                --(*index);
            };
            exitflag = (int64_t)1;
            size = (int64_t)0;
        }else if (((int64_t)(flags.codes[((int64_t)1)-1])==(int64_t)42)) {
            qc_name_shiftflagsleft(&(*d).uflags);
            star = (int64_t)1;
            goto L1372 ;
;
        } else {
            star = (int64_t)0;
            //dofield:
L1372 :;
;
            if (!!((uint64_t)((*d).attribs.ax_at))) {
                e = (*d).equiv;
                (*d).offset = (int64_t)((*e).offset);
                size = (int64_t)0;
            } else if (!!((uint64_t)((*d).attribs.ax_equals))) {
                qc_support_gerror((uint8_t*)"Can't init a field",(struct var_decls_unitrec *)(0));
            } else {
                size = (int64_t)(var_decls_ttsize[((int64_t)((*d).mode))]);
                alignment = (int64_t)((*d).attribs.ax_align);
                if ((alignment == (int64_t)255)) {
                    alignment = (size>(int64_t)8?size:(int64_t)8);
                };
                if ((alignment==(int64_t)2)) {
                    L1373 :;
                    while (!!((nextoffset & (int64_t)1))) {
                        ++nextoffset;
L1374 :;
                    }L1375 :;
                    ;
                }else if ((alignment==(int64_t)4)) {
                    L1376 :;
                    while (!!((nextoffset & (int64_t)3))) {
                        ++nextoffset;
L1377 :;
                    }L1378 :;
                    ;
                }else if ((alignment==(int64_t)8)) {
                    L1379 :;
                    while (!!((nextoffset & (int64_t)7))) {
                        ++nextoffset;
L1380 :;
                    }L1381 :;
                    ;
                };
                (*d).offset = nextoffset;
                if (!!(countmode)) {
                    ++qc_name_nfields;
                };
            };
            if (!(!!(star))) {
                --(*index);
            };
            ++qc_name_nallfields;
        };
        if (!!(fstruct)) {
            nextoffset += size;
        } else {
            maxsize = (maxsize>size?maxsize:size);
            countmode = (int64_t)0;
        };
L1370 :;
    }L1371 :;
    ;
    return (!!(fstruct)?(nextoffset - startoffset):maxsize);
}

static int64_t qc_name_scanrecord(struct var_decls_strec * (*flist)[],int64_t flistlen) {
    int64_t size;
    int64_t index;
    int64_t nextoffset;
    struct var_decls_strec *  d;
    struct var_decls_strec *  e;
    nextoffset = (int64_t)0;
    L1382 :;
    for (index=flistlen;index>=(int64_t)1;index-=(int64_t)1) {
L1383 :;
        d = (*flist)[(index)-1];
        if (!!((uint64_t)((*d).attribs.ax_at))) {
            e = (*d).equiv;
            (*d).offset = (int64_t)((*e).offset);
            size = (int64_t)0;
        } else if (!!((uint64_t)((*d).attribs.ax_equals))) {
            qc_support_gerror((uint8_t*)"Can't init a field",(struct var_decls_unitrec *)(0));
        } else {
            size = (int64_t)16;
            (*d).offset = nextoffset;
            ++qc_name_nfields;
        };
        ++qc_name_nallfields;
        nextoffset += size;
L1384 :;
    }L1385 :;
    ;
    return nextoffset;
}

static void qc_name_shiftflagsleft(struct var_decls_uflagsrec * flags) {
    int64_t i;
    int64_t av_1;
    if (!!((uint64_t)((*flags).ulength))) {
        L1386 :;
        for (i=(int64_t)1;i<=((int64_t)((uint64_t)((*flags).ulength)) - (int64_t)1);i+=(int64_t)1) {
L1387 :;
            (*flags).codes[(i)-1] = (uint64_t)((*flags).codes[((i + (int64_t)1))-1]);
L1388 :;
        }L1389 :;
        ;
        (*flags).codes[((int64_t)((*flags).ulength))-1] = (uint64_t)((int64_t)0);
        --(*flags).ulength;
    };
}

static int64_t qc_name_getconstint(struct var_decls_strec * owner,struct var_decls_unitrec * a) {
    if ((a == 0)) {
        qc_support_rxerror((uint8_t*)"GETCONSTINT A=NIL",(struct var_decls_unitrec *)(0));
    };
    qc_name_rx_unit(owner,a);
    qc_name_checkconstexpr(a);
    if (((int64_t)((*a).mode)==(int64_t)1) || ((int64_t)((*a).mode)==(int64_t)2)) {
        if (((int64_t)(var_decls_ttsize[((int64_t)((*a).mode))]) == (int64_t)16)) {
            qc_support_rxerror((uint8_t*)"GETCONSTINT/128",(struct var_decls_unitrec *)(0));
        };
        return (*a).value;
    }else if (((int64_t)((*a).mode)==(int64_t)3)) {
        return (int64_t)((*a).xvalue);
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(qc_lib_strmode((int64_t)((*a).mode),(int64_t)1),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        qc_support_rxerror((uint8_t*)"Getconstint: not int32/64",(struct var_decls_unitrec *)(0));
    };
    return (int64_t)0;
}

int64_t qc_name_checkdict(struct var_decls_unitrec * p) {
    int64_t nkeywords;
    int64_t isconst;
    struct var_decls_unitrec *  q;
    int64_t n;
    if (((int64_t)((*p).tag) != (int64_t)81)) {
        return (int64_t)0;
    };
    n = (nkeywords = (int64_t)0);
    isconst = (int64_t)1;
    q = (*p).a;
    L1390 :;
    while (!!(q)) {
        ++n;
        if (((int64_t)((*q).tag)==(int64_t)87)) {
            ++nkeywords;
        };
        q = (*q).nextunit;
L1391 :;
    }L1392 :;
    ;
    if ((nkeywords == (int64_t)0)) {
        return (int64_t)0;
    };
    if ((nkeywords != n)) {
        qc_support_rxerror((uint8_t*)"Dict: not all key:values",(struct var_decls_unitrec *)(0));
    };
    (*p).tag = (int64_t)83;
    return (int64_t)1;
}

void qc_name_checkconstlist(struct var_decls_unitrec * p) {
    struct var_decls_unitrec *  q;
    struct var_decls_strec *  stname;
    int64_t n;
    q = (*p).a;
    n = (int64_t)0;
    L1393 :;
    while (!!(q)) {
        ++n;
        if (((int64_t)((*q).tag)==(int64_t)1)) {
        }else if (((int64_t)((*q).tag)==(int64_t)3)) {
            if (!(!!((uint64_t)((*(*q).def).attribs.ax_autovar)))) {
                return;
            };
        }else if (((int64_t)((*q).tag)==(int64_t)82)) {
            if ((((int64_t)((*(*q).a).tag) != (int64_t)1) || ((int64_t)((*(*q).b).tag) != (int64_t)1))) {
                return;
            };
        } else {
            return;
        };
        q = (*q).nextunit;
L1394 :;
    }L1395 :;
    ;
    if ((n == (int64_t)0)) {
        return;
    };
    stname = qc_lib_getavname(var_decls_stmodule,(int64_t)10);
    (*stname).mode = (int64_t)35;
    (*stname).code = qc_lib_createunit2((int64_t)((*p).tag),(*p).a,(*p).b);
    (*stname).attribs.ax_equals = (uint64_t)((int64_t)1);
    (*p).tag = (int64_t)3;
    (*p).def = stname;
}

static void qc_name_duplfield(struct var_decls_strec * p,struct var_decls_strec * q) {
    if (!!((*p).code)) {
        qc_support_serror((uint8_t*)"DUPLFIELD");
    };
    (*q).attribs = (*p).attribs;
    (*q).address = (*p).address;
    (*q).uflags = (*p).uflags;
    (*q).mode = (int64_t)((*p).mode);
}

static void qc_name_dobaseclass(int64_t baseclassindex) {
    struct var_decls_strec *  sttype;
    struct var_decls_strec *  d;
    struct var_decls_strec *  e;
    struct var_decls_strec *  newd;
    int64_t baseclass;
    int64_t normalexit;
    baseclass = (int64_t)(var_decls_baseclasstable[(baseclassindex)]);
    sttype = var_decls_baseclassdef[(baseclassindex)];
    d = (*var_decls_ttnamedef[(baseclass)]).deflist;
    L1396 :;
    while (!!(d)) {
        e = (*sttype).deflist;
        normalexit = (int64_t)1;
        L1399 :;
        while (!!(e)) {
            if (!!(mlib_eqstring((*d).name,(*e).name))) {
                normalexit = (int64_t)0;
                goto L1401 ;
            };
            e = (*e).nextdef;
L1400 :;
        }L1401 :;
        ;
        if (!!(normalexit)) {
            if (((int64_t)((*d).nameid)==(int64_t)5) || ((int64_t)((*d).nameid)==(int64_t)19)) {
                newd = qc_lib_getduplnameptr(sttype,d,(int64_t)19);
                (*newd).equiv = d;
            } else {
                newd = qc_lib_getduplnameptr(sttype,d,(int64_t)((*d).nameid));
                qc_name_duplfield(d,newd);
            };
            qc_lib_adddef(sttype,newd);
        };
        d = (*d).nextdef;
L1397 :;
    }L1398 :;
    ;
}

static void qc_pclgen_evalexpr(struct var_decls_unitrec * p) {
    int64_t oldmlineno;
    int64_t opc;
    int64_t n;
    int64_t m;
    int64_t t;
    int64_t lowerx;
    int64_t lab1;
    int64_t lab2;
    int64_t oldmodno;
    struct var_decls_unitrec *  a;
    struct var_decls_unitrec *  b;
    struct var_decls_unitrec *  c;
    struct var_decls_strec *  d;
    struct var_decls_strec *  owner;
    int64_t x;
    int64_t aa;
    uint8_t *  s;
    double fsize;
    struct var_decls_unitrec *  mlist[50];
    int64_t i;
    int64_t nmult;
    a = (*p).a;
    b = (*p).b;
    c = (*p).c;
    oldmlineno = var_decls_mlineno;
    oldmodno = var_decls_currmoduleno;
    var_decls_mlineno = (int64_t)((*p).lineno);
    var_decls_currmoduleno = (int64_t)((*p).moduleno);
    switch ((int64_t)((*p).tag)) {
    case 48:;
    case 49:;
    {
        qc_pclgen_do_print(p,a,b);
    }break;
    case 50:;
    case 51:;
    {
        qc_pclgen_do_fprint(p,a,b,c);
    }break;
    case 57:;
    case 58:;
    {
        qc_pclgen_do_read(p,a,b);
    }break;
    case 17:;
    case 19:;
    {
        qc_pclgen_do_assign(p,a,b);
    }break;
    case 20:;
    {
        qc_pclgen_do_to(p,a,b,c);
    }break;
    case 31:;
    {
        qc_pclgen_do_while(p,a,b,c);
    }break;
    case 32:;
    {
        qc_pclgen_do_repeat(p,a,b);
    }break;
    case 25:;
    case 23:;
    case 24:;
    {
        qc_pclgen_do_forstep(p,a,b,c);
    }break;
    case 26:;
    case 28:;
    case 27:;
    case 29:;
    {
        qc_pclgen_do_forall(p,a,b,c);
    }break;
    case 41:;
    {
        qc_pclgen_do_do(p,a);
    }break;
    case 30:;
    {
        qc_pclgen_do_cfor(p,a,b);
    }break;
    case 21:;
    {
        qc_pclgen_do_if(p,a,b,c);
    }break;
    case 22:;
    {
        qc_pclgen_do_longif(p,a,b);
    }break;
    case 14:;
    {
        qc_pclgen_do_callproc(p,a,b);
    }break;
    case 66:;
    case 94:;
    {
        qc_pclgen_do_callhostproc(p,a);
    }break;
    case 67:;
    {
        qc_pclgen_do_callappl(p,a,b,(int64_t)0);
    }break;
    case 68:;
    {
        qc_pclgen_do_callappl(p,a,b,(int64_t)1);
    }break;
    case 16:;
    {
        qc_pclgen_do_return(p,a);
    }break;
    case 231:;
    case 232:;
    case 233:;
    case 234:;
    {
        qc_pclgen_do_preincr(p,a);
    }break;
    case 46:;
    {
        qc_pclgen_evalref(a);
        qc_pclgen_evalref(b);
        qc_pcllib_genpc((int64_t)37);
    }break;
    case 39:;
    case 36:;
    case 37:;
    case 38:;
    {
        qc_pclgen_do_exit(p,a);
    }break;
    case 35:;
    {
        qc_pcllib_lastopc = &qc_pclgen_dummyop;
        d = (*p).def;
        if (((int64_t)((*d).index) == (int64_t)0)) {
            (*d).index = (qc_pcllib_pcindex + (int64_t)1);
        } else {
            lab1 = (int64_t)((*d).index);
            qc_pclgen_definefwdlabel(&lab1);
        };
    }break;
    case 33:;
    {
        qc_pclgen_do_goto(p,a);
    }break;
    case 61:;
    {
        if (!!(a)) {
            qc_pclgen_evalexpr(a);
        } else {
            qc_pcllib_genpc((int64_t)19);
        };
        qc_pcllib_genpc((int64_t)73);
    }break;
    case 44:;
    case 45:;
    {
        qc_pclgen_do_switch(p,a,b,c);
    }break;
    case 42:;
    case 43:;
    {
        qc_pclgen_do_case(p,a,b,c);
    }break;
    case 62:;
    {
        qc_pclgen_do_try(p,a,b);
    }break;
    case 65:;
    {
        qc_pclgen_evalexpr(a);
        qc_pcllib_genpc((int64_t)208);
    }break;
    case 95:;
    {
        qc_pclgen_do_applyop(p,a,b,c);
    }break;
    case 15:;
    {
        qc_pclgen_do_callmproc(p,a,b,(int64_t)0);
    }break;
    case 69:;
    {
        qc_pclgen_evalexpr(a);
        qc_pcllib_genpc_int((int64_t)71,(int64_t)1);
    }break;
    case 1:;
    {
        x = (*p).value;
        switch ((int64_t)((*p).mode)) {
        case 5:;
        {
            s = (*p).svalue;
            if (((int64_t)((*p).slength) == (int64_t)0)) {
                qc_pcllib_genpc((int64_t)20);
            } else {
                qc_pcllib_genpc_str((int64_t)15,s,(int64_t)((*p).slength));
            };
        }break;
        case 1:;
        case 40:;
        {
            qc_pcllib_genpc_int((int64_t)11,(*p).value);
        }break;
        case 3:;
        case 49:;
        {
            if (((*p).xvalue == (double)0.)) {
                qc_pcllib_genpc_int((int64_t)18,(int64_t)3);
            } else {
                qc_pcllib_genpc_int((int64_t)13,(*p).value);
            };
        }break;
        case 2:;
        case 47:;
        {
            qc_pcllib_genpc_int((int64_t)12,(*p).value);
        }break;
        case 4:;
        {
            qc_pcllib_genpc_int((int64_t)14,(*p).value);
        }break;
        default: {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(var_decls_ttname[((int64_t)((*p).mode))],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            qc_support_gerror((uint8_t*)"CONST: Can't push this type",p);
        }
        } //SW
;
    }break;
    case 3:;
    {
        d = (*p).def;
        switch ((int64_t)((*d).nameid)) {
        case 5:;
        {
            qc_pcllib_genpc_s((int64_t)9,d);
        }break;
        case 10:;
        {
            qc_pcllib_genpc_s((int64_t)5,d);
        }break;
        case 11:;
        {
            qc_pcllib_genpc_s((int64_t)6,d);
        }break;
        case 12:;
        {
            qc_pcllib_genpc_s((int64_t)6,d);
            if (!!((uint64_t)((*d).attribs.ax_byrefmode))) {
                qc_pcllib_genpc((int64_t)29);
            };
        }break;
        case 16:;
        {
            if (((int64_t)((*d).index) == (int64_t)0)) {
                (*d).index = qc_pclgen_createfwdlabel();
            };
            qc_pcllib_genpc_lab((int64_t)10,(int64_t)((*d).index));
        }break;
        case 6:;
        {
            qc_pcllib_genpc_s((int64_t)206,d);
        }break;
        default: {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(pq_common_namenames[((int64_t)((*d).nameid))],NULL);
            msysnewc_m_print_str((*d).name,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            qc_support_gerror((uint8_t*)"Name?",p);
        }
        } //SW
;
    }break;
    case 97:;
    case 105:;
    case 106:;
    case 107:;
    case 108:;
    case 110:;
    case 111:;
    case 112:;
    case 114:;
    case 115:;
    case 116:;
    case 117:;
    case 118:;
    case 119:;
    case 120:;
    case 121:;
    case 122:;
    case 123:;
    case 124:;
    case 125:;
    case 126:;
    case 127:;
    case 144:;
    case 145:;
    case 104:;
    case 113:;
    {
        //dobinop:
L1402 :;
;
        if ((b == 0)) {
            qc_support_gerror((uint8_t*)"Binop: opnd missing",p);
        };
        opc = qc_pclgen_getpclop((int64_t)((*p).tag));
        qc_pclgen_evalexpr(a);
        qc_pclgen_evalexpr(b);
        qc_pcllib_genpc(opc);
    }break;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    case 103:;
    {
        if ((b == 0)) {
            qc_support_gerror((uint8_t*)"Binop: opnd missing",p);
        };
        opc = qc_pclgen_getpclop((int64_t)((*p).tag));
        qc_pclgen_evalexpr((*p).a);
        qc_pclgen_evalexpr((*p).b);
        qc_pcllib_genpc(opc);
    }break;
    case 213:;
    case 214:;
    case 215:;
    case 216:;
    case 217:;
    case 218:;
    case 219:;
    case 220:;
    case 221:;
    case 222:;
    case 223:;
    case 224:;
    case 225:;
    case 227:;
    case 226:;
    {
        opc = qc_pclgen_getpclop((int64_t)((*p).tag));
        qc_pclgen_evalref(a);
        qc_pclgen_evalexpr(b);
        qc_pcllib_genpc(opc);
    }break;
    case 109:;
    {
        qc_pclgen_do_idiv(a,b);
    }break;
    case 74:;
    {
        qc_pclgen_do_and(a,b);
    }break;
    case 75:;
    {
        qc_pclgen_do_or(a,b);
    }break;
    case 76:;
    {
        qc_pclgen_evalexpr(a);
        if (!(!!(qc_pclgen_islogical(a)))) {
            qc_pcllib_genpc((int64_t)103);
        };
        qc_pclgen_evalexpr(b);
        if (!(!!(qc_pclgen_islogical(a)))) {
            qc_pcllib_genpc((int64_t)103);
        };
        qc_pcllib_genpc((int64_t)162);
    }break;
    case 146:;
    {
        if (((int64_t)((*a).tag) == (int64_t)1)) {
            qc_support_gerror((uint8_t*)"pushptr/const",(struct var_decls_unitrec *)(0));
        };
        qc_pclgen_evalexpr(a);
        qc_pcllib_genpc((int64_t)29);
    }break;
    case 77:;
    {
        qc_pclgen_evalexpr(a);
        if (!(!!(qc_pclgen_islogical(a)))) {
            qc_pcllib_genpc((int64_t)103);
        };
        qc_pcllib_genpc((int64_t)101);
    }break;
    case 185:;
    {
        if (((int64_t)((*a).tag) == (int64_t)151)) {
            m = (int64_t)((*a).mode);
            if ((((int64_t)(var_decls_ttbasetype[(m)]) >= (int64_t)41) && ((int64_t)(var_decls_ttbasetype[(m)]) <= (int64_t)43))) {
                fsize = ((double)((int64_t)(var_decls_ttbitwidth[(m)])) / (double)8.);
                qc_pcllib_genpc_int((int64_t)13,*(int64_t*)&fsize);
            } else {
                qc_pclgen_genpushint((uint64_t)(var_decls_ttsize[(m)]));
            };
        } else {
            qc_pclgen_evalexpr(a);
            qc_pcllib_genpc(qc_pclgen_getpclop((int64_t)185));
        };
    }break;
    case 184:;
    {
        if (((int64_t)((*a).tag) == (int64_t)151)) {
            m = (int64_t)((*a).mode);
            qc_pclgen_genpushint((uint64_t)(var_decls_ttbitwidth[(m)]));
        } else {
            qc_pclgen_evalexpr(a);
            qc_pcllib_genpc(qc_pclgen_getpclop((int64_t)184));
        };
    }break;
    case 205:;
    {
        if (((int64_t)((*a).tag) == (int64_t)151)) {
            if (((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)2) || ((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)41) || ((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)43) || ((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)44) || ((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)45) || ((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)46) || ((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)47)) {
                aa = (int64_t)0;
            }else if (((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)37)) {
                aa = (int64_t)-128;
            }else if (((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)38)) {
                aa = (int64_t)-32768;
            }else if (((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)39)) {
                aa = (int64_t)-2147483648;
            }else if (((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)40) || ((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)1)) {
                aa = (int64_t)((uint64_t)9223372036854775808u);
            } else {
                goto L1403 ;
;
            };
            qc_pclgen_genpushint((uint64_t)(aa));
        } else {
            //dominval:
L1403 :;
;
            qc_pclgen_evalexpr(a);
            qc_pcllib_genpc(qc_pclgen_getpclop((int64_t)205));
        };
    }break;
    case 206:;
    {
        if (((int64_t)((*a).tag) == (int64_t)151)) {
            opc = (int64_t)11;
            if (((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)41)) {
                aa = (int64_t)1;
            }else if (((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)42)) {
                aa = (int64_t)3;
            }else if (((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)43)) {
                aa = (int64_t)15;
            }else if (((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)44)) {
                aa = (int64_t)255;
            }else if (((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)45)) {
                aa = (int64_t)65535;
            }else if (((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)46)) {
                aa = (int64_t)4294967295;
            }else if (((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)47) || ((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)2)) {
                aa = (int64_t)((uint64_t)18446744073709551615u);
                opc = (int64_t)12;
            }else if (((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)37)) {
                aa = (int64_t)127;
            }else if (((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)38)) {
                aa = (int64_t)32767;
            }else if (((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)39)) {
                aa = (int64_t)2147483647;
            }else if (((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)40) || ((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)1)) {
                aa = (int64_t)((uint64_t)9223372036854775807u);
            }else if (((int64_t)(var_decls_ttbasetype[((int64_t)((*a).mode))])==(int64_t)51)) {
                aa = (((int64_t)64 == (int64_t)32)?(int64_t)4294967295:(int64_t)((uint64_t)18446744073709551615u));
            } else {
                goto L1404 ;
;
            };
            if ((opc == (int64_t)11)) {
                qc_pclgen_genpushint((uint64_t)(aa));
            } else {
                qc_pcllib_genpc_int(opc,aa);
            };
        } else {
            //domaxval:
L1404 :;
;
            qc_pclgen_evalexpr(a);
            qc_pcllib_genpc(qc_pclgen_getpclop((int64_t)206));
        };
    }break;
    case 156:;
    case 157:;
    case 158:;
    case 159:;
    case 160:;
    case 161:;
    case 162:;
    case 163:;
    case 164:;
    case 165:;
    case 166:;
    case 167:;
    case 168:;
    case 169:;
    case 170:;
    case 171:;
    case 172:;
    case 173:;
    case 174:;
    case 175:;
    case 176:;
    case 177:;
    case 178:;
    case 179:;
    case 180:;
    case 181:;
    case 182:;
    case 183:;
    case 187:;
    case 188:;
    case 189:;
    case 190:;
    case 192:;
    case 193:;
    case 194:;
    case 195:;
    case 196:;
    case 197:;
    case 198:;
    case 200:;
    case 201:;
    case 203:;
    case 207:;
    case 208:;
    case 78:;
    case 191:;
    case 204:;
    {
        opc = qc_pclgen_getpclop((int64_t)((*p).tag));
        qc_pclgen_evalexpr(a);
        qc_pcllib_genpc(opc);
    }break;
    case 186:;
    {
        qc_pcllib_genpc((int64_t)19);
        qc_pclgen_evalexpr(a);
        qc_pclgen_callhostfn((int64_t)40,(int64_t)1);
    }break;
    case 90:;
    {
        if (((int64_t)((*a).tag) == (int64_t)3)) {
            d = (*a).def;
            if ((((int64_t)((*d).mode) == (int64_t)0) && ((int64_t)((uint64_t)((*d).nameid)) != (int64_t)8))) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((*d).name,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                qc_support_gerror((uint8_t*)"Proc return value",(struct var_decls_unitrec *)(0));
            };
        };
        qc_pclgen_do_callproc(p,a,b);
    }break;
    case 91:;
    {
        qc_pclgen_do_callmproc(p,a,b,(int64_t)1);
    }break;
    case 209:;
    {
        qc_pclgen_evalref(a);
        qc_pcllib_genpc((int64_t)91);
    }break;
    case 211:;
    {
        qc_pclgen_evalref(a);
        qc_pcllib_genpc((int64_t)90);
    }break;
    case 210:;
    {
        qc_pclgen_evalref(a);
        qc_pcllib_genpc((int64_t)96);
    }break;
    case 212:;
    {
        qc_pclgen_evalref(a);
        qc_pcllib_genpc((int64_t)95);
    }break;
    case 129:;
    case 131:;
    {
        qc_pclgen_evalexpr(a);
        qc_pclgen_evalexpr(b);
        qc_pcllib_genpc((int64_t)194);
    }break;
    case 133:;
    case 136:;
    {
        qc_pclgen_evalexpr(a);
        qc_pclgen_evalexpr(b);
        qc_pcllib_genpc((int64_t)195);
    }break;
    case 140:;
    {
        qc_pclgen_evalexpr(a);
        qc_pclgen_evalexpr(b);
        qc_pcllib_genpc_int((int64_t)201,(int64_t)((*p).mode));
    }break;
    case 132:;
    case 137:;
    {
        qc_pclgen_evalexpr(b);
        qc_pclgen_evalexpr(a);
        if (!!(c)) {
            qc_pclgen_evalexpr(c);
            qc_pcllib_genpc((int64_t)197);
        } else {
            qc_pcllib_genpc((int64_t)196);
        };
    }break;
    case 141:;
    {
        qc_pclgen_evalexpr(a);
        d = (*b).def;
        if (((int64_t)((*d).nameid)==(int64_t)5) || ((int64_t)((*d).nameid)==(int64_t)6)) {
            owner = (*d).owner;
            if (((int64_t)((*owner).nameid)==(int64_t)2) || ((int64_t)((*owner).nameid)==(int64_t)3)) {
                t = (int64_t)0;
            } else {
                t = (int64_t)((*owner).mode);
            };
            qc_pcllib_genpc_int((int64_t)204,t);
            qc_pcllib_genopnd_s(d);
        }else if (((int64_t)((*d).nameid)==(int64_t)4)) {
            qc_pcllib_genpc_int2((int64_t)205,(int64_t)((*(*d).owner).mode),(int64_t)((*d).mode));
        } else {
            qc_pcllib_genpc_int((int64_t)82,(int64_t)((*d).offset));
        };
    }break;
    case 79:;
    case 80:;
    {
        if (!!(b)) {
            lowerx = qc_lib_getconstvalue(b,(int64_t)100);
        } else {
            lowerx = (int64_t)1;
        };
        if ((a == 0)) {
            if ((lowerx == (int64_t)1)) {
                qc_pcllib_genpc((int64_t)21);
            } else {
                qc_pcllib_genpc_int((int64_t)22,lowerx);
            };
        } else {
            n = (int64_t)0;
            L1405 :;
            while (!!(a)) {
                ++n;
                qc_pclgen_evalexpr(a);
                a = (*a).nextunit;
L1406 :;
            }L1407 :;
            ;
            qc_pcllib_genpc_int2((int64_t)75,n,lowerx);
        };
    }break;
    case 81:;
    {
        if ((a == 0)) {
            qc_pcllib_genpc((int64_t)23);
        } else {
            n = (int64_t)0;
            L1408 :;
            while (!!(a)) {
                ++n;
                qc_pclgen_evalexpr(a);
                a = (*a).nextunit;
L1409 :;
            }L1410 :;
            ;
            qc_pcllib_genpc_int((int64_t)79,n);
        };
    }break;
    case 83:;
    {
        n = (int64_t)0;
        L1411 :;
        while (!!(a)) {
            ++n;
            qc_pclgen_evalexpr(a);
            a = (*a).nextunit;
L1412 :;
        }L1413 :;
        ;
        qc_pcllib_genpc_int((int64_t)81,n);
    }break;
    case 82:;
    {
        qc_pclgen_evalexpr(a);
        qc_pclgen_evalexpr(b);
        qc_pcllib_genpc((int64_t)80);
    }break;
    case 88:;
    case 89:;
    {
        qc_pclgen_do_assign(p,a,b);
    }break;
    case 92:;
    {
        lab1 = qc_pclgen_createfwdlabel();
        lab2 = qc_pclgen_createfwdlabel();
        qc_pclgen_genjumpcond((int64_t)0,a,lab1);
        qc_pclgen_evalexpr(b);
        qc_pclgen_genjumpl(lab2);
        qc_pclgen_definefwdlabel(&lab1);
        qc_pclgen_evalexpr(c);
        qc_pcllib_genpc((int64_t)1);
        qc_pclgen_definefwdlabel(&lab2);
    }break;
    case 149:;
    {
        qc_pclgen_do_convert((int64_t)((*p).mode),a);
    }break;
    case 150:;
    {
        qc_pclgen_evalexpr(a);
        qc_pcllib_genpc_int((int64_t)84,(int64_t)((*p).mode));
    }break;
    case 147:;
    {
        if (((int64_t)((*a).tag) == (int64_t)146)) {
            qc_pclgen_evalexpr((*a).a);
        } else {
            qc_pclgen_evalref(a);
        };
    }break;
    case 148:;
    {
        qc_pclgen_evalref(a);
        qc_pcllib_genpc((int64_t)38);
    }break;
    case 151:;
    {
        qc_pcllib_genpc_int((int64_t)16,(int64_t)((*p).mode));
    }break;
    case 93:;
    {
        qc_pclgen_do_selectx(a,b,c);
    }break;
    case 84:;
    {
        L1414 :;
        while ((!!(a) && !!((*a).nextunit))) {
            qc_pclgen_do_stmt(a);
            a = (*a).nextunit;
L1415 :;
        }L1416 :;
        ;
        qc_pclgen_evalexpr(a);
    }break;
    case 70:;
    {
        qc_pcllib_genpc((int64_t)21);
        qc_pclgen_do_stmt(a);
    }break;
    case 8:;
    {
        qc_pcllib_genpc_int((int64_t)18,(int64_t)((*p).mode));
    }break;
    case 87:;
    {
        qc_pclgen_evalexpr(a);
        qc_pclgen_evalexpr(b);
    }break;
    case 9:;
    {
        qc_pcllib_genpc_str((int64_t)15,(*p).svalue,(int64_t)((*p).slength));
        qc_pcllib_genpc_int((int64_t)85,(int64_t)7);
    }break;
    case 54:;
    {
        qc_pclgen_do_print(p,a,b);
    }break;
    case 55:;
    {
        qc_pclgen_do_fprint(p,a,b,c);
    }break;
    case 128:;
    {
        qc_pclgen_do_clamp(a,b,c);
    }break;
    case 96:;
    {
        qc_pclgen_do_applyopx(a,b,c);
    }break;
    case 152:;
    {
        opc = qc_pclgen_getpclop((int64_t)((*p).opcode));
        qc_pcllib_genpc_int2((int64_t)17,opc,qc_pclgen_noperands);
    }break;
    case 85:;
    {
        nmult = (int64_t)0;
        L1417 :;
        while (!!(a)) {
            if ((nmult >= (int64_t)50)) {
                qc_support_gerror((uint8_t*)"Too many mult elems",(struct var_decls_unitrec *)(0));
            };
            mlist[(++nmult)-1] = a;
            a = (*a).nextunit;
L1418 :;
        }L1419 :;
        ;
        L1420 :;
        for (i=nmult;i>=(int64_t)1;i-=(int64_t)1) {
L1421 :;
            qc_pclgen_do_stmt(mlist[(i)-1]);
L1422 :;
        }L1423 :;
        ;
    }break;
    default: {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(qc_tables_jtagnames[((int64_t)((*p).tag))],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        qc_support_gerror((uint8_t*)"E:CAN'T EVALUATE",p);
    }
    } //SW
;
    var_decls_mlineno = oldmlineno;
    var_decls_currmoduleno = oldmodno;
}

static void qc_pclgen_do_stmt(struct var_decls_unitrec * p) {
    qc_pclgen_evalexpr(p);
}

int64_t qc_pclgen_codegen(int64_t n) {
    static struct var_decls_modulerec m;
    struct var_decls_strec *  d;
    struct var_decls_strec *  e;
    m = var_decls_moduletable[(n)];
    var_decls_stmodule = m.stmodule;
    qc_pcllib_linetable = m.linetable;
    qc_pclgen_initgenpcl((int64_t)(m.sourcelen));
    d = (*m.stmodule).deflist;
    L1424 :;
    while (!!(d)) {
        if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)5)) {
            qc_pclgen_do_procdef(d);
            e = (*d).deflist;
            L1427 :;
            while (!!(e)) {
                if (((int64_t)((uint64_t)((*e).nameid)) == (int64_t)5)) {
                    qc_pclgen_do_procdef(e);
                };
                e = (*e).nextdef;
L1428 :;
            }L1429 :;
            ;
        } else if (((int64_t)((uint64_t)((*d).nameid)) == (int64_t)4)) {
            e = (*d).deflist;
            L1430 :;
            while (!!(e)) {
                if (((int64_t)((uint64_t)((*e).nameid)) == (int64_t)5)) {
                    qc_pclgen_do_procdef(e);
                };
                e = (*e).nextdef;
L1431 :;
            }L1432 :;
            ;
        };
        d = (*d).nextdef;
L1425 :;
    }L1426 :;
    ;
    qc_pclgen_genstartproc(m.stmodule);
    qc_pcllib_genpc((int64_t)4);
    m.pccode = qc_pcllib_pccode;
    m.npccode = qc_pcllib_npccode;
    m.pcindex = qc_pcllib_pcindex;
    m.linetable = qc_pcllib_linetable;
    var_decls_moduletable[(n)] = m;
    return (int64_t)1;
}

static void qc_pclgen_scanidata(struct var_decls_strec * p) {
    struct var_decls_strec *  d;
    struct var_decls_strec *  defs[30000];
    int64_t i;
    int64_t ndefs;
    qc_pclgen_genidata(p);
    d = (*p).deflist;
    if (!(!!(d))) {
        return;
    };
    ndefs = (int64_t)0;
    L1433 :;
    while (!!(d)) {
        ++ndefs;
        if ((ndefs > (int64_t)30000)) {
            qc_support_gerror((uint8_t*)"Too many idata defs",(struct var_decls_unitrec *)(0));
        };
        defs[(ndefs)-1] = d;
        d = (*d).nextdef;
L1434 :;
    }L1435 :;
    ;
    L1436 :;
    for (i=ndefs;i>=(int64_t)1;i-=(int64_t)1) {
L1437 :;
        d = defs[(i)-1];
        if (!!((uint64_t)((*d).attribs.ax_autovar))) {
            qc_pclgen_scanidata(d);
        };
L1438 :;
    }L1439 :;
    ;
    L1440 :;
    for (i=ndefs;i>=(int64_t)1;i-=(int64_t)1) {
L1441 :;
        d = defs[(i)-1];
        if (!(!!((uint64_t)((*d).attribs.ax_autovar)))) {
            qc_pclgen_scanidata(d);
        };
L1442 :;
    }L1443 :;
    ;
}

static void qc_pclgen_genidata(struct var_decls_strec * p) {
    struct var_decls_unitrec *  e;
    if (((int64_t)((uint64_t)((*p).nameid)) == (int64_t)2)) {
        return;
    };
    if ((qc_lib_getscope(p) == (int64_t)2)) {
        return;
    };
    if (((int64_t)((uint64_t)((*p).nameid)) == (int64_t)10)) {
        e = (*p).code;
        if ((e == 0)) {
            return;
        };
        qc_pclgen_evalexpr(e);
        qc_pcllib_genpc_s(((int64_t)32 + (int64_t)((uint64_t)((*p).attribs.ax_frame))),p);
    };
}

static void qc_pclgen_initgenpcl(int64_t sourcelen) {
    qc_pcllib_initpcl(msysnewc_m_imax((sourcelen / (int64_t)2),(int64_t)1000));
    qc_pclgen_loopindex = (int64_t)0;
    qc_pcllib_stcurrproc = (struct var_decls_strec *)(0);
    qc_pclgen_st_startproc = qc_lib_getduplnameptr(var_decls_stmodule,qc_lex_addnamestr((uint8_t*)"$startproc"),(int64_t)5);
    (*qc_pclgen_st_startproc).attribs.ax_global = (uint64_t)((int64_t)1);
    (*qc_pclgen_st_startproc).mode = (int64_t)0;
    qc_lib_adddef_nodupl(var_decls_stmodule,qc_pclgen_st_startproc);
}

void qc_pclgen_doprogramstartup(void) {
    int64_t i;
    int64_t m;
    struct var_decls_strec *  d;
    qc_pcllib_initpcl((int64_t)1000);
    L1444 :;
    for (i=(int64_t)1;i<=var_decls_nmodules;i+=(int64_t)1) {
L1445 :;
        m = var_decls_moduleinitorder[(i)-1];
        d = qc_lib_finddefstr(var_decls_moduletable[(m)].stmodule,(uint8_t*)"$startproc");
        if ((d == 0)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(var_decls_moduletable[(m)].name,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            qc_support_gerror((uint8_t*)"Can't find $startproc",(struct var_decls_unitrec *)(0));
        };
        qc_pcllib_genpc_s((int64_t)63,d);
        qc_pcllib_genopnd_int((int64_t)0);
L1446 :;
    }L1447 :;
    ;
    var_decls_stopseq = &(*qc_pcllib_pccode)[((qc_pcllib_pcindex + (int64_t)1))-1];
    qc_pclgen_genpushint((uint64_t)((int64_t)0));
    qc_pcllib_genpc((int64_t)73);
    var_decls_raiseseq = &(*qc_pcllib_pccode)[((qc_pcllib_pcindex + (int64_t)1))-1];
    qc_pcllib_genpc((int64_t)208);
    qc_pcllib_genpc((int64_t)208);
    qc_pcllib_genpc((int64_t)208);
    qc_pcllib_genpc((int64_t)208);
    qc_pcllib_genpc((int64_t)4);
    var_decls_moduletable[((int64_t)0)].pccode = qc_pcllib_pccode;
    var_decls_moduletable[((int64_t)0)].npccode = qc_pcllib_npccode;
    var_decls_moduletable[((int64_t)0)].pcindex = qc_pcllib_pcindex;
    var_decls_moduletable[((int64_t)0)].linetable = qc_pcllib_linetable;
}

static void qc_pclgen_do_block(struct var_decls_unitrec * p) {
    struct var_decls_unitrec *  q;
    q = (*p).a;
    L1448 :;
    while (!!(q)) {
        qc_pclgen_do_stmt(q);
        q = (*q).nextunit;
L1449 :;
    }L1450 :;
    ;
}

static void qc_pclgen_do_print(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    int64_t issprint;
    struct var_decls_unitrec *  x;
    issprint = ((int64_t)((*p).tag) == (int64_t)54);
    if (!!(issprint)) {
        qc_pclgen_callhostfn((int64_t)3,(int64_t)0);
    } else {
        if (!!(a)) {
            qc_pclgen_evalexpr(a);
            qc_pclgen_callhostfn((int64_t)1,(int64_t)0);
        } else {
            qc_pclgen_callhostfn((int64_t)2,(int64_t)0);
        };
    };
    x = b;
    L1451 :;
    while (!!(x)) {
        if (((int64_t)((*x).tag)==(int64_t)12)) {
            qc_pclgen_evalexpr((*x).b);
            qc_pclgen_evalexpr((*x).a);
            qc_pclgen_callhostfn((int64_t)7,(int64_t)0);
        }else if (((int64_t)((*x).tag)==(int64_t)13)) {
            qc_pclgen_callhostfn((int64_t)10,(int64_t)0);
        } else {
            qc_pcllib_genpc((int64_t)19);
            qc_pclgen_evalexpr(x);
            qc_pclgen_callhostfn((int64_t)7,(int64_t)0);
        };
        x = (*x).nextunit;
L1452 :;
    }L1453 :;
    ;
    if (((int64_t)((*p).tag) == (int64_t)49)) {
        qc_pclgen_callhostfn((int64_t)9,(int64_t)0);
    };
    if (!!(issprint)) {
        qc_pcllib_genpc((int64_t)19);
        qc_pclgen_callhostfn((int64_t)6,(int64_t)1);
    } else {
        qc_pclgen_callhostfn((int64_t)5,(int64_t)0);
    };
}

static void qc_pclgen_do_fprint(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b,struct var_decls_unitrec * c) {
    int64_t issfprint;
    struct var_decls_unitrec *  x;
    issfprint = ((int64_t)((*p).tag) == (int64_t)55);
    if (!!(issfprint)) {
        qc_pclgen_callhostfn((int64_t)3,(int64_t)0);
    } else {
        if (!!(a)) {
            qc_pclgen_evalexpr(a);
            qc_pclgen_callhostfn((int64_t)1,(int64_t)0);
        } else {
            qc_pclgen_callhostfn((int64_t)2,(int64_t)0);
        };
    };
    qc_pclgen_evalexpr(b);
    qc_pclgen_callhostfn((int64_t)4,(int64_t)0);
    x = c;
    L1454 :;
    while (!!(x)) {
        if (((int64_t)((*x).tag)==(int64_t)12)) {
            qc_pclgen_evalexpr((*x).b);
            qc_pclgen_evalexpr((*x).a);
            qc_pclgen_callhostfn((int64_t)7,(int64_t)0);
        }else if (((int64_t)((*x).tag)==(int64_t)13)) {
            qc_pclgen_callhostfn((int64_t)10,(int64_t)0);
        } else {
            qc_pcllib_genpc((int64_t)19);
            qc_pclgen_evalexpr(x);
            qc_pclgen_callhostfn((int64_t)7,(int64_t)0);
        };
        x = (*x).nextunit;
L1455 :;
    }L1456 :;
    ;
    if (((int64_t)((*p).tag) == (int64_t)51)) {
        qc_pclgen_callhostfn((int64_t)9,(int64_t)0);
    };
    if (!!(issfprint)) {
        qc_pcllib_genpc((int64_t)19);
        qc_pclgen_callhostfn((int64_t)6,(int64_t)1);
    } else {
        qc_pclgen_callhostfn((int64_t)5,(int64_t)0);
    };
}

static void qc_pclgen_do_read(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    struct var_decls_unitrec *  x;
    struct var_decls_unitrec *  xloop;
    if (((int64_t)((*p).tag) == (int64_t)58)) {
        if (!!(a)) {
            qc_pclgen_evalexpr(a);
            qc_pclgen_callhostfn((int64_t)11,(int64_t)0);
        } else {
            qc_pcllib_genpc((int64_t)19);
            qc_pclgen_callhostfn((int64_t)11,(int64_t)0);
        };
    };
    xloop = b;
    L1457 :;
    while (!!(xloop)) {
        x = xloop;
        qc_pcllib_genpc((int64_t)19);
        if (((int64_t)((*x).tag) == (int64_t)12)) {
            qc_pclgen_evalexpr((*x).b);
            qc_pclgen_callhostfn((int64_t)13,(int64_t)1);
            x = (*x).a;
        } else {
            qc_pcllib_genpc((int64_t)19);
            qc_pclgen_callhostfn((int64_t)13,(int64_t)1);
        };
        if (((int64_t)((*x).tag) == (int64_t)3)) {
            qc_pcllib_genpc_s(((int64_t)25 + (int64_t)((uint64_t)((*(*x).def).attribs.ax_frame))),(*x).def);
            (*(*x).def).attribs.ax_used = (uint64_t)((int64_t)1);
        } else {
            qc_pclgen_evalref(x);
            qc_pcllib_genpc((int64_t)30);
        };
        xloop = (*xloop).nextunit;
L1458 :;
    }L1459 :;
    ;
}

static void qc_pclgen_do_assign(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    int64_t fstore;
    int64_t n;
    int64_t mult;
    struct var_decls_unitrec *  q;
    struct var_decls_strec *  d;
    fstore = (((int64_t)((*p).tag) == (int64_t)88) | ((int64_t)((*p).tag) == (int64_t)89));
    qc_pclgen_evalexpr(b);
    if (((int64_t)((*p).tag)==(int64_t)19) || ((int64_t)((*p).tag)==(int64_t)89)) {
        qc_pcllib_genpc((int64_t)36);
    };
    if (((int64_t)((*a).tag) == (int64_t)85)) {
        a = (*a).a;
        mult = (int64_t)1;
    } else {
        mult = (int64_t)0;
    };
    L1460 :;
    while (!!(a)) {
        switch ((int64_t)((*a).tag)) {
        case 3:;
        {
            d = (*a).def;
            if (((int64_t)((*d).nameid)==(int64_t)11)) {
                (*d).attribs.ax_used = (uint64_t)((int64_t)1);
            }else if (((int64_t)((*d).nameid)==(int64_t)10)) {
            }else if (((int64_t)((*d).nameid)==(int64_t)12)) {
                if (!!((uint64_t)((*d).attribs.ax_byrefmode))) {
                    qc_pcllib_genpc_s((int64_t)6,d);
                    qc_pcllib_genpc((!!(fstore)?(int64_t)31:(int64_t)30));
                    return;
                };
            } else {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str(pq_common_namenames[((int64_t)((*d).nameid))],NULL);
                msysnewc_m_print_str((*d).name,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                qc_support_gerror((uint8_t*)"Can't assign to",(struct var_decls_unitrec *)(0));
            };
            qc_pcllib_genpc_s(((!!(fstore)?(int64_t)27:(int64_t)25) + (int64_t)((uint64_t)((*d).attribs.ax_frame))),d);
        }break;
        case 129:;
        case 133:;
        case 131:;
        case 136:;
        case 132:;
        case 137:;
        case 140:;
        {
            qc_pclgen_evalref(a);
            qc_pcllib_genpc((!!(fstore)?(int64_t)31:(int64_t)30));
        }break;
        case 79:;
        {
            q = (*a).a;
            if ((q == 0)) {
                qc_support_gerror((uint8_t*)"assign to ()?",(struct var_decls_unitrec *)(0));
            } else {
                n = (int64_t)0;
                L1463 :;
                while (!!(q)) {
                    ++n;
                    qc_pclgen_evalref(q);
                    q = (*q).nextunit;
L1464 :;
                }L1465 :;
                ;
                qc_pcllib_genpc_int2((int64_t)75,n,(int64_t)1);
            };
            qc_pcllib_genpc((!!(fstore)?(int64_t)31:(int64_t)30));
        }break;
        case 141:;
        {
            qc_pclgen_evalref((*a).a);
            d = (*(*a).b).def;
            qc_pcllib_genpc_int((int64_t)83,(int64_t)((*d).offset));
            qc_pcllib_genpc((!!(fstore)?(int64_t)31:(int64_t)30));
        }break;
        case 146:;
        {
            qc_pclgen_evalref(a);
            qc_pcllib_genpc((!!(fstore)?(int64_t)31:(int64_t)30));
        }break;
        case 92:;
        {
            qc_pclgen_evalref(a);
            qc_pcllib_genpc((!!(fstore)?(int64_t)31:(int64_t)30));
        }break;
        default: {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(qc_tables_jtagnames[((int64_t)((*a).tag))],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            qc_support_gerror((uint8_t*)"DOASSIGN?",p);
        }
        } //SW
;
        if (!!(mult)) {
            a = (*a).nextunit;
        } else {
            goto L1462 ;
        };
L1461 :;
    }L1462 :;
    ;
}

static void qc_pclgen_do_to(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b,struct var_decls_unitrec * c) {
    int64_t lab_a;
    int64_t lab_b;
    int64_t lab_c;
    int64_t lab_d;
    struct var_decls_strec *  temp;
    lab_a = qc_pclgen_definelabel();
    temp = (*c).def;
    qc_pclgen_evalexpr(a);
    qc_pcllib_genpc_s((int64_t)33,temp);
    lab_b = qc_pclgen_createfwdlabel();
    lab_c = qc_pclgen_createfwdlabel();
    lab_d = qc_pclgen_createfwdlabel();
    qc_pclgen_stacklooplabels(&lab_a,&lab_b,&lab_c,&lab_d);
    if (((int64_t)((*a).tag) != (int64_t)1)) {
        qc_pcllib_genpc_s((int64_t)6,temp);
        qc_pcllib_genpc_int((int64_t)11,(int64_t)0);
        qc_pcllib_genpc_lab((int64_t)48,lab_d);
    } else if (((*a).value <= (int64_t)0)) {
        qc_pcllib_genpc_lab((int64_t)39,lab_d);
    };
    qc_pclgen_definefwdlabel(&lab_b);
    qc_pclgen_do_block(b);
    qc_pclgen_definefwdlabel(&lab_c);
    qc_pcllib_genpc_lab((int64_t)58,lab_b);
    qc_pcllib_genopnd_s(temp);
    qc_pclgen_definefwdlabel(&lab_d);
    qc_pclgen_unstacklooplabels();
}

static void qc_pclgen_do_while(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b,struct var_decls_unitrec * c) {
    int64_t lab_ab;
    int64_t lab_c;
    int64_t lab_d;
    lab_ab = qc_pclgen_createfwdlabel();
    lab_c = qc_pclgen_createfwdlabel();
    lab_d = qc_pclgen_createfwdlabel();
    qc_pclgen_stacklooplabels(&lab_ab,&lab_ab,&lab_c,&lab_d);
    qc_pclgen_genjumpl(lab_c);
    qc_pclgen_definefwdlabel(&lab_ab);
    qc_pclgen_do_block(b);
    qc_pclgen_definefwdlabel(&lab_c);
    qc_pclgen_genjumpcond((int64_t)1,a,lab_ab);
    if (!!(c)) {
        qc_pclgen_do_block(c);
    };
    qc_pclgen_definefwdlabel(&lab_d);
    qc_pclgen_unstacklooplabels();
}

static void qc_pclgen_do_repeat(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    int64_t lab_ab;
    int64_t lab_c;
    int64_t lab_d;
    lab_ab = qc_pclgen_definelabel();
    lab_c = qc_pclgen_createfwdlabel();
    lab_d = qc_pclgen_createfwdlabel();
    qc_pclgen_stacklooplabels(&lab_ab,&lab_ab,&lab_c,&lab_d);
    qc_pclgen_do_block(a);
    qc_pclgen_definefwdlabel(&lab_c);
    qc_pclgen_genjumpcond((int64_t)0,b,lab_ab);
    qc_pclgen_definefwdlabel(&lab_d);
    qc_pclgen_unstacklooplabels();
}

static void qc_pclgen_do_forstep(struct var_decls_unitrec * p,struct var_decls_unitrec * pvar,struct var_decls_unitrec * pbody,struct var_decls_unitrec * pautovar) {
    struct var_decls_unitrec *  pfrom;
    struct var_decls_unitrec *  pto;
    struct var_decls_unitrec *  pstep;
    struct var_decls_unitrec *  pelse;
    struct var_decls_strec *  dvar;
    struct var_decls_strec *  limitvar;
    int64_t lab_a;
    int64_t lab_b;
    int64_t lab_c;
    int64_t lab_d;
    int64_t lab_e;
    int64_t opc;
    int64_t step;
    int64_t fromval;
    int64_t limit;
    int64_t jumpinto;
    pfrom = (*pvar).nextunit;
    pto = (*pfrom).nextunit;
    pstep = (*pto).nextunit;
    pelse = (*pbody).nextunit;
    dvar = (*pvar).def;
    (*dvar).attribs.ax_used = (uint64_t)((int64_t)1);
    if (((int64_t)((*p).tag)==(int64_t)23)) {
        step = (int64_t)1;
    }else if (((int64_t)((*p).tag)==(int64_t)24)) {
        step = (int64_t)-1;
    } else {
        step = qc_lib_getconstvalue(pstep,(int64_t)101);
        if (((step != (int64_t)1) && (step != (int64_t)-1))) {
            qc_support_gerror((uint8_t*)"Can't do for with odd step",(struct var_decls_unitrec *)(0));
        };
    };
    jumpinto = (int64_t)1;
    lab_a = qc_pclgen_definelabel();
    lab_b = qc_pclgen_createfwdlabel();
    lab_c = qc_pclgen_createfwdlabel();
    lab_d = qc_pclgen_createfwdlabel();
    lab_e = (!!(pelse)?qc_pclgen_createfwdlabel():lab_d);
    qc_pclgen_stacklooplabels(&lab_a,&lab_b,&lab_c,&lab_d);
    if (((int64_t)((*pfrom).tag) == (int64_t)1)) {
        fromval = (*pfrom).value;
        if (((int64_t)((*pto).tag) == (int64_t)1)) {
            limit = (*pto).value;
            (*pto).mode = (int64_t)1;
            if ((((step == (int64_t)-1) && (fromval >= limit)) || ((step == (int64_t)1) && (fromval <= limit)))) {
                jumpinto = (int64_t)0;
            };
        };
        if (!!(jumpinto)) {
            if ((step < (int64_t)0)) {
                ++fromval;
            } else {
                --fromval;
            };
            (*pfrom).value = fromval;
        };
        qc_pclgen_genpushint((uint64_t)((*pfrom).value));
        qc_pcllib_genpc_s(((int64_t)25 + (int64_t)((uint64_t)((*dvar).attribs.ax_frame))),dvar);
    } else {
        qc_pclgen_evalexpr(pfrom);
        qc_pcllib_genpc_s(((int64_t)25 + (int64_t)((uint64_t)((*dvar).attribs.ax_frame))),dvar);
        qc_pcllib_genpc_s((((step < (int64_t)0)?(int64_t)88:(int64_t)93) + (int64_t)((uint64_t)((*dvar).attribs.ax_frame))),dvar);
    };
    if (!!(pautovar)) {
        if ((((int64_t)((*pto).tag) == (int64_t)3) && !!((uint64_t)((*(*pto).def).attribs.ax_frame)))) {
            pautovar = (struct var_decls_unitrec *)(0);
        };
    };
    if (!!(pautovar)) {
        qc_pclgen_evalexpr(pto);
        limitvar = (*pautovar).def;
        qc_pcllib_genpc_s((int64_t)33,limitvar);
        pto = pautovar;
    } else {
        limitvar = (*pto).def;
    };
    if (!!(jumpinto)) {
        qc_pclgen_genjumpl(lab_c);
    };
    qc_pclgen_definefwdlabel(&lab_b);
    qc_pclgen_do_block(pbody);
    qc_pclgen_definefwdlabel(&lab_c);
    if (((int64_t)((*pto).tag) == (int64_t)1)) {
        opc = ((step < (int64_t)0)?(int64_t)61:(int64_t)59);
    } else {
        opc = ((step < (int64_t)0)?(int64_t)62:(int64_t)60);
    };
    qc_pcllib_genpc_lab(opc,lab_b);
    qc_pcllib_genopnd_s(dvar);
    qc_pcllib_genopnd_s(limitvar);
    if (!!(pelse)) {
        qc_pclgen_definefwdlabel(&lab_e);
        qc_pclgen_do_block(pelse);
    };
    qc_pclgen_definefwdlabel(&lab_d);
    qc_pclgen_unstacklooplabels();
}

static void qc_pclgen_do_forall(struct var_decls_unitrec * p,struct var_decls_unitrec * pindex,struct var_decls_unitrec * pbody,struct var_decls_unitrec * pautovar) {
    int64_t lab_a;
    int64_t lab_b;
    int64_t lab_c;
    int64_t lab_d;
    int64_t lab_e;
    int64_t step;
    struct var_decls_unitrec *  pvar;
    struct var_decls_unitrec *  plist;
    struct var_decls_unitrec *  pelse;
    struct var_decls_strec *  indexvar;
    struct var_decls_strec *  vardef;
    struct var_decls_strec *  autodef;
    pvar = (*pindex).nextunit;
    vardef = (*pvar).def;
    plist = (*pvar).nextunit;
    pelse = (*pbody).nextunit;
    indexvar = (*pindex).def;
    step = ((((int64_t)((*p).tag) == (int64_t)26) || ((int64_t)((*p).tag) == (int64_t)28))?(int64_t)1:(int64_t)-1);
    lab_a = qc_pclgen_definelabel();
    lab_b = qc_pclgen_createfwdlabel();
    lab_c = qc_pclgen_createfwdlabel();
    lab_d = qc_pclgen_createfwdlabel();
    lab_e = (!!(pelse)?qc_pclgen_createfwdlabel():lab_d);
    qc_pclgen_stacklooplabels(&lab_a,&lab_b,&lab_c,&lab_d);
    qc_pclgen_evalexpr(plist);
    qc_pcllib_genpc((int64_t)131);
    qc_pcllib_genpc((int64_t)215);
    autodef = (*pautovar).def;
    if ((step == (int64_t)1)) {
        qc_pcllib_genpc_s((int64_t)33,autodef);
        qc_pcllib_genpc((int64_t)98);
        qc_pcllib_genpc_s((!!((uint64_t)((*indexvar).attribs.ax_autovar))?(int64_t)33:(int64_t)26),indexvar);
    } else {
        qc_pcllib_genpc((int64_t)97);
        qc_pcllib_genpc_s((!!((uint64_t)((*indexvar).attribs.ax_autovar))?(int64_t)33:(int64_t)26),indexvar);
        qc_pcllib_genpc_s((int64_t)33,autodef);
    };
    qc_pclgen_genjumpl(lab_c);
    qc_pclgen_definefwdlabel(&lab_b);
    qc_pclgen_evalexpr(plist);
    qc_pclgen_evalexpr(pindex);
    if ((((int64_t)((*p).tag) == (int64_t)26) || ((int64_t)((*p).tag) == (int64_t)27))) {
        qc_pcllib_genpc((int64_t)194);
    } else {
        qc_pcllib_genpc((int64_t)195);
    };
    qc_pcllib_genpc_s((int64_t)26,vardef);
    if (((int64_t)((*pbody).tag) == (int64_t)4)) {
        qc_pclgen_do_block(pbody);
    } else {
        qc_pclgen_do_stmt(pbody);
    };
    qc_pclgen_definefwdlabel(&lab_c);
    qc_pcllib_genpc_lab(((step == (int64_t)1)?(int64_t)60:(int64_t)62),lab_b);
    qc_pcllib_genopnd_s(indexvar);
    qc_pcllib_genopnd_s(autodef);
    if (!!(pelse)) {
        qc_pclgen_definefwdlabel(&lab_e);
        qc_pclgen_do_block(pelse);
    };
    qc_pclgen_definefwdlabel(&lab_d);
    qc_pclgen_unstacklooplabels();
}

static void qc_pclgen_do_do(struct var_decls_unitrec * p,struct var_decls_unitrec * a) {
    int64_t lab_abc;
    int64_t lab_d;
    lab_abc = qc_pclgen_definelabel();
    lab_d = qc_pclgen_createfwdlabel();
    qc_pclgen_stacklooplabels(&lab_abc,&lab_abc,&lab_abc,&lab_d);
    qc_pclgen_do_block(a);
    qc_pclgen_genjumpl(lab_abc);
    qc_pclgen_definefwdlabel(&lab_d);
    qc_pclgen_unstacklooplabels();
}

static void qc_pclgen_do_cfor(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    int64_t lab_a;
    int64_t lab_b;
    int64_t lab_c;
    int64_t lab_d;
    int64_t lab_test;
    struct var_decls_unitrec *  pinit;
    struct var_decls_unitrec *  pcond;
    struct var_decls_unitrec *  pstep;
    lab_a = qc_pclgen_definelabel();
    lab_b = qc_pclgen_createfwdlabel();
    lab_c = qc_pclgen_createfwdlabel();
    lab_d = qc_pclgen_createfwdlabel();
    lab_test = qc_pclgen_createfwdlabel();
    qc_pclgen_stacklooplabels(&lab_a,&lab_b,&lab_c,&lab_d);
    pinit = a;
    pcond = (*pinit).nextunit;
    pstep = (*pcond).nextunit;
    qc_pclgen_do_stmt(pinit);
    qc_pclgen_genjumpl(lab_test);
    qc_pclgen_definefwdlabel(&lab_b);
    qc_pclgen_do_block(b);
    qc_pclgen_definefwdlabel(&lab_c);
    qc_pclgen_do_stmt(pstep);
    qc_pclgen_definefwdlabel(&lab_test);
    qc_pclgen_genjumpcond((int64_t)1,pcond,lab_b);
    qc_pclgen_definefwdlabel(&lab_d);
    qc_pclgen_unstacklooplabels();
}

static void qc_pclgen_do_if(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b,struct var_decls_unitrec * pelse) {
    int64_t lab1;
    int64_t lab2;
    lab1 = qc_pclgen_createfwdlabel();
    if (!!(pelse)) {
        lab2 = qc_pclgen_createfwdlabel();
    };
    qc_pclgen_genjumpcond((int64_t)0,a,lab1);
    qc_pclgen_do_block(b);
    if (!!(pelse)) {
        qc_pclgen_genjumpl(lab2);
        qc_pclgen_definefwdlabel(&lab1);
        qc_pclgen_do_block(pelse);
        qc_pclgen_definefwdlabel(&lab2);
    } else {
        qc_pclgen_definefwdlabel(&lab1);
    };
}

static void qc_pclgen_do_longif(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    struct var_decls_unitrec *  q;
    int64_t labend;
    int64_t lab2;
    labend = qc_pclgen_createfwdlabel();
    q = a;
    L1466 :;
    while (!!(q)) {
        lab2 = qc_pclgen_createfwdlabel();
        qc_pclgen_genjumpcond((int64_t)0,(*q).a,lab2);
        qc_pclgen_do_block((*q).b);
        q = (*q).nextunit;
        if ((!!(q) || !!(b))) {
            qc_pclgen_genjumpl(labend);
        };
        qc_pclgen_definefwdlabel(&lab2);
L1467 :;
    }L1468 :;
    ;
    if (!!(b)) {
        qc_pclgen_do_block(b);
    };
    qc_pclgen_definefwdlabel(&labend);
}

static void qc_pclgen_do_callproc(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    struct var_decls_strec *  d;
    struct var_decls_strec *  pm;
    struct var_decls_unitrec *  pbody;
    struct var_decls_unitrec *  x;
    struct var_decls_unitrec *  r;
    int64_t naparams;
    int64_t fkeyword;
    int64_t nparams;
    int64_t i;
    int64_t j;
    int64_t k;
    int64_t ffcode;
    int64_t isfn;
    int64_t fbyref;
    struct var_decls_unitrec *  cparams[64];
    struct var_decls_strec *  dparams[64];
    int64_t dparamsdone;
    uint8_t *  name;
    dparamsdone = (int64_t)0;
    if (((int64_t)((*a).tag)==(int64_t)3)) {
    }else if (((int64_t)((*a).tag)==(int64_t)141)) {
        qc_pclgen_do_callmproc(p,a,b,((int64_t)((*p).tag) == (int64_t)90));
        return;
    } else {
        qc_pclgen_do_callptr(p,a,b);
        return;
    };
    d = (*a).def;
    if (((int64_t)((*d).nameid)==(int64_t)5) || ((int64_t)((*d).nameid)==(int64_t)6)) {
    }else if (((int64_t)((*d).nameid)==(int64_t)8)) {
        qc_pclgen_do_callappl(p,a,b,((int64_t)((*p).tag) == (int64_t)90));
        return;
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((*d).name,NULL);
        msysnewc_m_print_str(pq_common_namenames[((int64_t)((*d).nameid))],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        qc_support_gerror((uint8_t*)"Callproc: not proc",p);
    };
    pbody = (*d).code;
    if (((ffcode = (int64_t)((*d).attribs.ax_fflang))==(int64_t)1) || ((ffcode = (int64_t)((*d).attribs.ax_fflang))==(int64_t)2) || ((ffcode = (int64_t)((*d).attribs.ax_fflang))==(int64_t)4)) {
        qc_pclgen_do_calldll(p,a,b);
        return;
    };
    isfn = ((int64_t)((*d).mode) != (int64_t)0);
    if (!!(isfn)) {
        qc_pcllib_genpc((int64_t)19);
    };
    nparams = (int64_t)((*d).attribs.ax_nparams);
    memset((void *)(&cparams),(int64_t)0,(uint64_t)(((int64_t)8 * nparams)));
    fkeyword = (int64_t)0;
    x = b;
    naparams = (int64_t)0;
    L1469 :;
    while (!!(x)) {
        ++naparams;
        if ((naparams > nparams)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((*d).name,NULL);
            msysnewc_m_print_i64(naparams,NULL);
            msysnewc_m_print_i64(nparams,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            qc_support_gerror((uint8_t*)"Too many params",p);
        };
        if ((!!(fkeyword) && ((int64_t)((*x).tag) != (int64_t)86))) {
            qc_support_gerror((uint8_t*)"Normal param follows keyword param",p);
        };
        if (((int64_t)((*x).tag)==(int64_t)86)) {
            if (!(((int64_t)((*(*x).a).tag) == (int64_t)3))) {
                qc_support_gerror((uint8_t*)"Kwd: not name",(struct var_decls_unitrec *)(0));
            };
            fkeyword = (int64_t)1;
            name = (*(*(*x).a).def).name;
            if (!(!!(dparamsdone))) {
                qc_pclgen_extractparams(d,&dparams);
                dparamsdone = (int64_t)1;
            };
            j = (int64_t)0;
            k = (int64_t)0;
            L1472 :;
            for (j=(int64_t)1;j<=nparams;j+=(int64_t)1) {
L1473 :;
                if (!!(mlib_eqstring((*dparams[(j)-1]).name,name))) {
                    k = j;
                    goto L1475 ;
                };
L1474 :;
            }L1475 :;
            ;
            if ((k == (int64_t)0)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str(name,NULL);
                msysnewc_m_print_str((uint8_t*)"in",NULL);
                msysnewc_m_print_str((*d).name,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                qc_support_gerror((uint8_t*)"Can't find keyword param",(struct var_decls_unitrec *)(0));
            };
            if (!!(cparams[(k)-1])) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str(name,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                qc_support_gerror((uint8_t*)"Param already set",(struct var_decls_unitrec *)(0));
            };
            cparams[(k)-1] = (*x).b;
        }else if (((int64_t)((*x).tag)==(int64_t)2)) {
        } else {
            cparams[(naparams)-1] = x;
        };
        x = (*x).nextunit;
L1470 :;
    }L1471 :;
    ;
    L1476 :;
    for (i=(int64_t)1;i<=nparams;i+=(int64_t)1) {
L1477 :;
        x = cparams[(i)-1];
        if ((x == 0)) {
            if (!(!!(dparamsdone))) {
                qc_pclgen_extractparams(d,&dparams);
                dparamsdone = (int64_t)1;
            };
            pm = dparams[(i)-1];
            if (!!((*pm).code)) {
                cparams[(i)-1] = (*pm).code;
            } else if (!(!!((uint64_t)((*pm).attribs.ax_optional)))) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((*pm).name,NULL);
                msysnewc_m_print_str((uint8_t*)"in",NULL);
                msysnewc_m_print_str((*d).name,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                qc_support_gerror((uint8_t*)"Param not optional",(struct var_decls_unitrec *)(0));
            };
        };
L1478 :;
    }L1479 :;
    ;
    L1480 :;
    for (i=nparams;i>=(int64_t)1;i-=(int64_t)1) {
L1481 :;
        x = cparams[(i)-1];
        if (!(!!(dparamsdone))) {
            qc_pclgen_extractparams(d,&dparams);
            dparamsdone = (int64_t)1;
        };
        fbyref = (int64_t)((*dparams[(i)-1]).attribs.ax_byrefmode);
        if ((x == 0)) {
            if (!!(fbyref)) {
                qc_support_gerror((uint8_t*)"&void param",(struct var_decls_unitrec *)(0));
            };
            qc_pcllib_genpc((int64_t)19);
        } else {
            if (!!(fbyref)) {
                qc_pclgen_evalref(x);
            } else {
                qc_pclgen_evalexpr(x);
            };
        };
L1482 :;
    }L1483 :;
    ;
    qc_pcllib_genpc_s((int64_t)63,d);
    qc_pcllib_genopnd_int((int64_t)0);
    L1484 :;
    for (i=(int64_t)1;i<=nparams;i+=(int64_t)1) {
L1485 :;
        r = cparams[(i)-1];
        if (((r == 0) || !!(qc_pclgen_issimpleparam(r)))) {
            if (((*qc_pcllib_lastopc)==(int64_t)72)) {
                ++(*(qc_pcllib_lastopc + (int64_t)1));
            }else if (((*qc_pcllib_lastopc)==(int64_t)63)) {
                if (((*(qc_pcllib_lastopc + (int64_t)2)) < (int64_t)8)) {
                    ++(*(qc_pcllib_lastopc + (int64_t)2));
                } else {
                    qc_pcllib_genpc_int((int64_t)72,(int64_t)1);
                };
            } else {
                qc_pcllib_genpc_int((int64_t)72,(int64_t)1);
            };
        } else {
            if (((*qc_pcllib_lastopc)==(int64_t)71)) {
                ++(*(qc_pcllib_lastopc + (int64_t)1));
            } else {
                qc_pclgen_genfree((int64_t)1);
            };
        };
L1486 :;
    }L1487 :;
    ;
    if ((!!(isfn) && ((int64_t)((*p).tag) == (int64_t)14))) {
        qc_pclgen_genfree((int64_t)1);
    };
}

static void qc_pclgen_do_callhostproc(struct var_decls_unitrec * p,struct var_decls_unitrec * a) {
    int64_t calledasfn;
    int64_t isfn;
    int64_t index;
    int64_t nap;
    int64_t i;
    int64_t nparams;
    int64_t fparams;
    struct var_decls_unitrec *  plist[10];
    struct var_decls_unitrec *  q;
    int64_t av_1;
    calledasfn = ((int64_t)((*p).tag) == (int64_t)94);
    index = (int64_t)((*p).opcode);
    isfn = pq_common_hostisfn[(index)];
    if ((!!(calledasfn) && !(!!(isfn)))) {
        qc_support_gerror((uint8_t*)"Host proc is not function",(struct var_decls_unitrec *)(0));
    };
    if (((!!(isfn) && (index == (int64_t)64)) && (((!!(a) && ((*a).nextunit == 0)) && ((int64_t)((*a).tag) == (int64_t)1)) && ((*a).value == (int64_t)0)))) {
        qc_pclgen_genpushint((uint64_t)(qc_pclgen_nprocparamvars));
        return;
    };
    if (!!(isfn)) {
        qc_pcllib_genpc((int64_t)19);
    };
    q = a;
    nap = (int64_t)0;
    L1488 :;
    while (!!(q)) {
        if ((nap >= (int64_t)10)) {
            qc_support_gerror((uint8_t*)"far too many host params",(struct var_decls_unitrec *)(0));
        };
        ++nap;
        plist[(nap)-1] = q;
        q = (*q).nextunit;
L1489 :;
    }L1490 :;
    ;
    if (((index == (int64_t)67) && (a == 0))) {
        nparams = (int64_t)1;
    } else {
        nparams = nap;
    };
    if (((nparams == (int64_t)0) && !!((uint64_t)(qc_tables_hostlvset[(index)])))) {
        qc_support_gerror((uint8_t*)"LV hostfn: needs 1+ params",(struct var_decls_unitrec *)(0));
    };
    fparams = pq_common_hostnparams[(index)];
    if ((nparams > fparams)) {
        qc_support_gerror((uint8_t*)"Hostfn too many params",(struct var_decls_unitrec *)(0));
    };
    av_1 = (fparams - nparams);
    while (av_1-- > 0) {
L1491 :;
        qc_pcllib_genpc((int64_t)19);
L1492 :;
    }L1493 :;
    ;
    L1494 :;
    for (i=nparams;i>=(int64_t)1;i-=(int64_t)1) {
L1495 :;
        if (((i == (int64_t)1) && !!((uint64_t)(qc_tables_hostlvset[(index)])))) {
            qc_pclgen_evalref(plist[(i)-1]);
        } else if ((((i == (int64_t)1) && (index == (int64_t)67)) && (nap == (int64_t)0))) {
            isfn = ((int64_t)((*qc_pcllib_stcurrproc).mode) != (int64_t)0);
            qc_pcllib_genpc_s((int64_t)9,qc_pcllib_stcurrproc);
        } else {
            qc_pclgen_evalexpr(plist[(i)-1]);
        };
L1496 :;
    }L1497 :;
    ;
    qc_pclgen_callhostfn(index,calledasfn);
}

static void qc_pclgen_do_return(struct var_decls_unitrec * p,struct var_decls_unitrec * a) {
    int64_t isfn;
    isfn = ((int64_t)((*qc_pcllib_stcurrproc).mode) != (int64_t)0);
    if ((a == 0)) {
        if (!!(isfn)) {
            qc_support_gerror((uint8_t*)"Fn needs return value",p);
        };
        if (!!(qc_pclgen_trylevel)) {
            qc_pcllib_genpc_int((int64_t)72,qc_pclgen_trylevel);
        };
        if (!!(qc_pclgen_nprocframevars)) {
            qc_pclgen_genjumpl(qc_pclgen_retindex);
        } else {
            qc_pcllib_genpc((int64_t)65);
        };
        return;
    };
    if (!(!!(isfn))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((*qc_pcllib_stcurrproc).name,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        qc_support_gerror((uint8_t*)"Can't return value from proc",(struct var_decls_unitrec *)(0));
    };
    qc_pclgen_evalexpr(a);
    qc_pcllib_genpc_s((int64_t)33,qc_pclgen_stretval);
    if (!!(qc_pclgen_trylevel)) {
        qc_pcllib_genpc_int((int64_t)72,qc_pclgen_trylevel);
    };
    if (!!(qc_pclgen_nprocframevars)) {
        qc_pclgen_genjumpl(qc_pclgen_retindex);
    } else {
        qc_pcllib_genpc((int64_t)65);
    };
}

static void qc_pclgen_genstartproc(struct var_decls_strec * dmodule) {
    int64_t retadjust;
    int64_t lab1;
    int64_t lab2;
    struct var_decls_strec *  stmain;
    struct var_decls_strec *  ststart;
    if ((qc_pclgen_st_startproc == 0)) {
        qc_support_gerror((uint8_t*)"$startproc not present",(struct var_decls_unitrec *)(0));
    };
    retadjust = (int64_t)0;
    qc_pcllib_genpc_s((int64_t)2,qc_pclgen_st_startproc);
    qc_pcllib_genopnd_int((int64_t)0);
    (*qc_pclgen_st_startproc).index = (qc_pcllib_pcindex + (int64_t)1);
    qc_pclgen_scanidata(dmodule);
    stmain = qc_lib_finddefstr(var_decls_stmodule,(uint8_t*)"main");
    ststart = qc_lib_finddefstr(var_decls_stmodule,(uint8_t*)"start");
    if ((!!(stmain) && !!(ststart))) {
        lab1 = qc_pclgen_createfwdlabel();
        lab2 = qc_pclgen_createfwdlabel();
        qc_pcllib_genpc((int64_t)19);
        qc_pcllib_genpc_str((int64_t)15,(*var_decls_stmodule).name,(int64_t)((*var_decls_stmodule).namelen));
        qc_pclgen_callhostfn((int64_t)26,(int64_t)1);
        qc_pcllib_genpc_lab((int64_t)42,lab1);
        qc_pcllib_genpc_s((int64_t)63,stmain);
        qc_pcllib_genopnd_int((int64_t)0);
        qc_pcllib_genpc_lab((int64_t)39,lab2);
        qc_pclgen_definefwdlabel(&lab1);
        qc_pcllib_genpc_s((int64_t)63,ststart);
        qc_pcllib_genopnd_int((int64_t)0);
        qc_pclgen_definefwdlabel(&lab2);
    } else if (!!(stmain)) {
        lab1 = qc_pclgen_createfwdlabel();
        qc_pcllib_genpc((int64_t)19);
        qc_pcllib_genpc_str((int64_t)15,(*var_decls_stmodule).name,(int64_t)((*var_decls_stmodule).namelen));
        qc_pclgen_callhostfn((int64_t)26,(int64_t)1);
        qc_pcllib_genpc_lab((int64_t)42,lab1);
        qc_pcllib_genpc_s((int64_t)63,stmain);
        qc_pcllib_genopnd_int((int64_t)0);
        qc_pclgen_definefwdlabel(&lab1);
    } else if (!!(ststart)) {
        qc_pcllib_genpc_s((int64_t)63,ststart);
        qc_pcllib_genopnd_int((int64_t)0);
    };
    qc_pcllib_genpc((int64_t)65);
    qc_pcllib_genpc((int64_t)3);
}

static void qc_pclgen_do_procdef(struct var_decls_strec * p) {
    int64_t nfreevars;
    int64_t nnofreevars;
    if ((p == qc_pclgen_st_startproc)) {
        return;
    };
    qc_pcllib_stcurrproc = p;
    qc_pclgen_retindex = qc_pclgen_createfwdlabel();
    qc_pclgen_genprocentry(p,&nfreevars,&nnofreevars);
    if (((*p).code == 0)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"EMPTY PROC BODY",NULL);
        msysnewc_m_print_str((*p).name,NULL);
        msysnewc_m_print_str(qc_tables_scopenames[(qc_lib_getscope(p))],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    } else {
        qc_pclgen_do_block((*p).code);
    };
    if (((int64_t)((*p).mode) != (int64_t)0)) {
        if (((int64_t)((uint64_t)((*(*p).owner).nameid)) != (int64_t)4)) {
            if (!(!!(qc_pclgen_checkblockreturn((*p).code)))) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((*p).name,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                qc_support_gerror((uint8_t*)"Function needs explicit return statement",(*p).code);
            };
        };
    };
    qc_pclgen_definefwdlabel(&qc_pclgen_retindex);
    qc_pclgen_genprocexit(nfreevars,nnofreevars);
    qc_pcllib_genpc((int64_t)3);
}

static void qc_pclgen_genprocentry(struct var_decls_strec * p,int64_t * nfreevars,int64_t * nnofreevars) {
    int64_t nparamvars;
    int64_t nframevars;
    int64_t isfn;
    int64_t hasretval;
    int64_t fv;
    int64_t nallocvars;
    int64_t ninitvars;
    int64_t i;
    int64_t j;
    int64_t nextoffset;
    struct var_decls_strec *  d;
    struct var_decls_strec *  varlist[64];
    int64_t fvlist[64];
    struct var_decls_unitrec *  expr;
    struct var_decls_strec *  locals[256];
    int64_t nlocals;
    d = (*p).deflist;
    isfn = ((int64_t)((*p).mode) != (int64_t)0);
    if (!!(isfn)) {
        qc_pclgen_stretval = qc_lib_getduplnameptr(p,qc_lex_addnamestr((uint8_t*)"$retval"),(int64_t)12);
        (*qc_pclgen_stretval).mode = (int64_t)((*p).mode);
        (*qc_pclgen_stretval).attribs.ax_autovar = (uint64_t)((int64_t)1);
        qc_lib_adddef_nodupl(p,qc_pclgen_stretval);
    } else {
        qc_pclgen_stretval = (struct var_decls_strec *)(0);
    };
    nparamvars = (nframevars = (int64_t)0);
    hasretval = (int64_t)0;
    d = (*p).deflist;
    nlocals = (int64_t)0;
    L1498 :;
    while (!!(d)) {
        if ((nlocals >= (int64_t)256)) {
            qc_support_gerror((uint8_t*)"Too many locals",(struct var_decls_unitrec *)(0));
        };
        locals[(++nlocals)-1] = d;
        d = (*d).nextdef;
L1499 :;
    }L1500 :;
    ;
    L1501 :;
    for (i=nlocals;i>=(int64_t)1;i-=(int64_t)1) {
L1502 :;
        d = locals[(i)-1];
        if (((int64_t)((*d).nameid)==(int64_t)11)) {
            if ((nframevars >= (int64_t)64)) {
                var_decls_mlineno = (int64_t)((*d).lineno);
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((*p).name,NULL);
                msysnewc_m_print_str((*d).name,NULL);
                msysnewc_m_print_i64(nframevars,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                qc_support_gerror((uint8_t*)"Too many frame vars",(struct var_decls_unitrec *)(0));
            };
            ++nframevars;
            varlist[(nframevars)-1] = d;
            fvlist[(nframevars)-1] = (int64_t)0;
        }else if (((int64_t)((*d).nameid)==(int64_t)12)) {
            (*d).index = ++nparamvars;
            if (!!((uint64_t)((*d).attribs.ax_autovar))) {
                hasretval = (int64_t)1;
            };
        };
L1503 :;
    }L1504 :;
    ;
    qc_pclgen_nprocframevars = nframevars;
    qc_pclgen_nprocparamvars = (nparamvars - isfn);
    nallocvars = (ninitvars = (int64_t)0);
    (*nfreevars) = ((*nnofreevars) = (int64_t)0);
    L1505 :;
    for (i=(int64_t)1;i<=nframevars;i+=(int64_t)1) {
L1506 :;
        d = varlist[(i)-1];
        expr = (struct var_decls_unitrec *)(0);
        if (!!((*d).code)) {
            expr = (*d).code;
        };
        if (!!((uint64_t)((*d).attribs.ax_autovar))) {
            fv = (int64_t)0;
            ++nallocvars;
            ++(*nnofreevars);
        } else if (!!(expr)) {
            fv = (int64_t)1;
            ++nallocvars;
            ++(*nfreevars);
        } else {
            fv = (int64_t)2;
            ++ninitvars;
            ++(*nfreevars);
        };
        fvlist[(i)-1] = fv;
L1507 :;
    }L1508 :;
    ;
    nextoffset = (int64_t)0;
    L1509 :;
    for (i=(int64_t)2;i>=(int64_t)0;i-=(int64_t)1) {
L1510 :;
        L1513 :;
        for (j=(int64_t)1;j<=nframevars;j+=(int64_t)1) {
L1514 :;
            if ((fvlist[(j)-1] == i)) {
                nextoffset -= (int64_t)1;
                (*varlist[(j)-1]).index = nextoffset;
            };
L1515 :;
        }L1516 :;
        ;
L1511 :;
    }L1512 :;
    ;
    qc_pcllib_genpc_s((int64_t)2,p);
    qc_pcllib_genopnd_int((nparamvars - hasretval));
    (*p).index = (qc_pcllib_pcindex + (int64_t)1);
    if (!!((ninitvars + nallocvars))) {
        qc_pcllib_genpc_int((int64_t)70,(ninitvars + nallocvars));
    };
    L1517 :;
    for (i=(int64_t)1;i<=nframevars;i+=(int64_t)1) {
L1518 :;
        d = varlist[(i)-1];
        if (!!((*d).code)) {
            qc_pclgen_evalexpr((*d).code);
            (*d).attribs.ax_used = (uint64_t)((int64_t)1);
            qc_pcllib_genpc_s((int64_t)33,d);
        };
L1519 :;
    }L1520 :;
    ;
}

static void qc_pclgen_genprocexit(int64_t nfree,int64_t nnofree) {
    if (!!(nnofree)) {
        qc_pcllib_genpc_int((int64_t)72,nnofree);
    };
    if (!!(nfree)) {
        qc_pclgen_genfree(nfree);
    };
    qc_pcllib_genpc((int64_t)65);
}

static void qc_pclgen_do_preincr(struct var_decls_unitrec * p,struct var_decls_unitrec * a) {
    int64_t isincr;
    isincr = (((int64_t)((*p).tag) == (int64_t)231) | ((int64_t)((*p).tag) == (int64_t)233));
    if ((((int64_t)((*a).tag) == (int64_t)3) && ((int64_t)((uint64_t)((*(*a).def).nameid)) != (int64_t)12))) {
        qc_pcllib_genpc_s(((!!(isincr)?(int64_t)88:(int64_t)93) + (int64_t)((uint64_t)((*(*a).def).attribs.ax_frame))),(*a).def);
    } else {
        qc_pclgen_evalref(a);
        qc_pcllib_genpc((!!(isincr)?(int64_t)87:(int64_t)92));
    };
}

static void qc_pclgen_do_exit(struct var_decls_unitrec * p,struct var_decls_unitrec * a) {
    int64_t k;
    int64_t index;
    int64_t n;
    if (((int64_t)((*p).tag)==(int64_t)36)) {
        k = (int64_t)1;
    }else if (((int64_t)((*p).tag)==(int64_t)37)) {
        k = (int64_t)2;
    }else if (((int64_t)((*p).tag)==(int64_t)38)) {
        k = (int64_t)3;
    }else if (((int64_t)((*p).tag)==(int64_t)39)) {
        k = (int64_t)4;
    };
    if (!!(a)) {
        index = (*a).value;
    } else {
        index = (int64_t)1;
    };
    n = qc_pclgen_findlooplabel(k,index);
    if ((n == (int64_t)0)) {
        qc_support_gerror((uint8_t*)"Bad exit/loop index",p);
    } else {
        if ((qc_pclgen_trylevel > qc_pclgen_looptrylevel)) {
            qc_pcllib_genpc_int((int64_t)72,(qc_pclgen_trylevel - qc_pclgen_looptrylevel));
        };
        qc_pclgen_genjumpl(n);
    };
}

static void qc_pclgen_do_goto(struct var_decls_unitrec * p,struct var_decls_unitrec * a) {
    struct var_decls_strec *  d;
    int64_t ntries;
    if (((int64_t)((*a).tag)==(int64_t)3)) {
        d = (*a).def;
        if (((int64_t)((*d).index) == (int64_t)0)) {
            (*d).index = qc_pclgen_createfwdlabel();
        };
        if (((int64_t)((*d).nameid)==(int64_t)16)) {
            ntries = (qc_pclgen_trylevel - (int64_t)((*d).offset));
            if ((ntries < (int64_t)0)) {
                qc_support_gerror((uint8_t*)"Jumping into try block",(struct var_decls_unitrec *)(0));
            } else if (!!(ntries)) {
                qc_pcllib_genpc_int((int64_t)72,ntries);
            };
            qc_pcllib_genpc_lab((int64_t)39,(int64_t)((*d).index));
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((*d).name,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            qc_support_gerror((uint8_t*)"Not label name",(struct var_decls_unitrec *)(0));
        };
    } else {
        qc_support_gerror((uint8_t*)"GOTO PTR",(struct var_decls_unitrec *)(0));
    };
}

static void qc_pclgen_do_switch(struct var_decls_unitrec * p,struct var_decls_unitrec * pindex,struct var_decls_unitrec * pwhenthen,struct var_decls_unitrec * pelse) {
    int64_t minlab;
    int64_t maxlab;
    int64_t x;
    int64_t y;
    int64_t i;
    int64_t n;
    struct var_decls_unitrec *  w;
    struct var_decls_unitrec *  wt;
    minlab = (int64_t)1000000;
    maxlab = (int64_t)-1000000;
    n = (int64_t)0;
    wt = pwhenthen;
    L1521 :;
    while (!!(wt)) {
        w = (*wt).a;
        L1524 :;
        while (!!(w)) {
            if (((int64_t)((*w).tag)==(int64_t)1)) {
                if (((int64_t)((*w).mode)==(int64_t)4)) {
                    x = (int64_t)((*w).range_lower);
                    y = (int64_t)((*w).range_upper);
                    //dorange:
L1527 :;
;
                    L1528 :;
                    for (i=x;i<=y;i+=(int64_t)1) {
L1529 :;
                        minlab = (minlab<i?minlab:i);
                        maxlab = (maxlab>i?maxlab:i);
L1530 :;
                    }L1531 :;
                    ;
                }else if (((int64_t)((*w).mode)==(int64_t)1)) {
                    x = (y = (*w).value);
                    goto L1527 ;
;
                } else {
                    qc_support_gerror((uint8_t*)"Switch when1: not const int",w);
                };
            }else if (((int64_t)((*w).tag)==(int64_t)151)) {
                x = (y = (int64_t)((*w).mode));
                goto L1527 ;
;
            } else {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((uint8_t*)"STREXPR(W)=",NULL);
                msysnewc_m_print_ptr(qc_lib_strexpr(w),NULL);
                msysnewc_m_print_str(qc_tables_jtagnames[((int64_t)((*w).tag))],NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                qc_support_gerror((uint8_t*)"Switch when2: not const",w);
            };
            w = (*w).nextunit;
L1525 :;
        }L1526 :;
        ;
        wt = (*wt).nextunit;
L1522 :;
    }L1523 :;
    ;
    if (((maxlab - minlab) <= (int64_t)512)) {
        qc_pclgen_do_simpleswitch(p,pindex,pwhenthen,pelse,minlab,maxlab);
        return;
    };
    qc_support_gerror((uint8_t*)"COMPLEX SWITCH/NOT COMPLETE",(struct var_decls_unitrec *)(0));
}

static void qc_pclgen_do_simpleswitch(struct var_decls_unitrec * p,struct var_decls_unitrec * pindex,struct var_decls_unitrec * pwhenthen,struct var_decls_unitrec * pelse,int64_t a,int64_t b) {
    struct var_decls_unitrec *  w;
    struct var_decls_unitrec *  wt;
    struct var_decls_unitrec *  q;
    int64_t loopsw;
    int64_t n;
    int64_t offset;
    int64_t x;
    int64_t y;
    int64_t x0;
    int64_t i;
    int64_t labstmt;
    int64_t elselab;
    int64_t labels[513];
    int64_t lab_a;
    int64_t lab_d;
    loopsw = ((int64_t)((*p).tag) == (int64_t)45);
    n = ((b - a) + (int64_t)1);
    offset = (a - (int64_t)1);
    if (!!(loopsw)) {
        lab_a = qc_pclgen_definelabel();
        lab_d = qc_pclgen_createfwdlabel();
        qc_pclgen_stacklooplabels(&lab_a,&lab_a,&lab_a,&lab_d);
    } else {
        lab_d = qc_pclgen_createfwdlabel();
    };
    qc_pclgen_evalexpr(pindex);
    qc_pcllib_genpc_int2((int64_t)55,n,a);
    L1532 :;
    for (i=(int64_t)1;i<=n;i+=(int64_t)1) {
L1533 :;
        qc_pcllib_genpc_lab((int64_t)53,(int64_t)0);
        labels[(i)-1] = qc_pcllib_pcindex;
L1534 :;
    }L1535 :;
    ;
    qc_pcllib_genpc_lab((int64_t)53,(int64_t)0);
    labels[((n + (int64_t)1))-1] = qc_pcllib_pcindex;
    wt = pwhenthen;
    L1536 :;
    while (!!(wt)) {
        labstmt = qc_pclgen_definelabel();
        w = (*wt).a;
        L1539 :;
        while (!!(w)) {
            if (((int64_t)((*w).tag)==(int64_t)1)) {
                if (((int64_t)((*w).mode) == (int64_t)4)) {
                    x0 = (int64_t)((*w).range_lower);
                    y = (int64_t)((*w).range_upper);
                } else {
                    x0 = (y = (*w).value);
                };
            }else if (((int64_t)((*w).tag)==(int64_t)151)) {
                x0 = (y = (int64_t)((*w).mode));
            };
            L1542 :;
            for (x=x0;x<=y;x+=(int64_t)1) {
L1543 :;
                i = (x - offset);
                if (!!((*qc_pcllib_pccode)[(labels[(i)-1])-1])) {
                    msysnewc_m_print_startcon();
                    msysnewc_m_print_i64(x,NULL);
                    msysnewc_m_print_c8((uint8_t)(x),NULL);
                    msysnewc_m_print_newline();
                    msysnewc_m_print_end();
                    ;
                    qc_support_gerror((uint8_t*)"Dupl switch value",(struct var_decls_unitrec *)(0));
                };
                (*qc_pcllib_pccode)[(labels[(i)-1])-1] = labstmt;
L1544 :;
            }L1545 :;
            ;
            w = (*w).nextunit;
L1540 :;
        }L1541 :;
        ;
        qc_pclgen_do_block((*wt).b);
        if (!(!!(loopsw))) {
            qc_pclgen_genjumpl(lab_d);
        } else {
            qc_pclgen_genjumpl(lab_a);
        };
        wt = (*wt).nextunit;
L1537 :;
    }L1538 :;
    ;
    if (!!(pelse)) {
        if (((*pelse).nextunit == 0)) {
            q = pelse;
        } else {
            q = (struct var_decls_unitrec *)(0);
        };
        if ((((!!(loopsw) && !!(q)) && ((int64_t)((*q).tag) == (int64_t)39)) && (((*q).a == 0) || (qc_lib_getconstvalue((*q).a,(int64_t)102) == (int64_t)1)))) {
            elselab = lab_d;
            pelse = (struct var_decls_unitrec *)(0);
        } else {
            elselab = qc_pclgen_createfwdlabel();
        };
    } else {
        elselab = (!!(loopsw)?lab_a:lab_d);
    };
    if (!!(pelse)) {
        qc_pclgen_definefwdlabel(&elselab);
        qc_pclgen_do_block(pelse);
    };
    L1546 :;
    for (i=(int64_t)1;i<=n;i+=(int64_t)1) {
L1547 :;
        if (((*qc_pcllib_pccode)[(labels[(i)-1])-1] == (int64_t)0)) {
            (*qc_pcllib_pccode)[(labels[(i)-1])-1] = elselab;
        };
L1548 :;
    }L1549 :;
    ;
    (*qc_pcllib_pccode)[(labels[((n + (int64_t)1))-1])-1] = elselab;
    if (!!(loopsw)) {
        qc_pclgen_genjumpl(lab_a);
        qc_pclgen_definefwdlabel(&lab_d);
        qc_pclgen_unstacklooplabels();
    } else {
        qc_pclgen_definefwdlabel(&lab_d);
    };
}

static void qc_pclgen_do_case(struct var_decls_unitrec * p,struct var_decls_unitrec * pindex,struct var_decls_unitrec * pwhenthen,struct var_decls_unitrec * pelse) {
    int64_t lab_a;
    int64_t lab_d;
    int64_t loopsw;
    int64_t fmult;
    int64_t labnextwhen;
    int64_t labstmtstart;
    struct var_decls_unitrec *  w;
    struct var_decls_unitrec *  wt;
    loopsw = ((int64_t)((*p).tag) == (int64_t)43);
    if (!!(loopsw)) {
        lab_a = qc_pclgen_definelabel();
        lab_d = qc_pclgen_createfwdlabel();
        qc_pclgen_stacklooplabels(&lab_a,&lab_a,&lab_a,&lab_d);
    } else {
        lab_d = qc_pclgen_createfwdlabel();
    };
    qc_pclgen_evalexpr(pindex);
    wt = pwhenthen;
    L1550 :;
    while (!!(wt)) {
        w = (*wt).a;
        fmult = ((*w).nextunit != 0);
        labnextwhen = qc_pclgen_createfwdlabel();
        if (!!(fmult)) {
            labstmtstart = qc_pclgen_createfwdlabel();
        };
        L1553 :;
        while (!!(w)) {
            qc_pclgen_evalexpr(w);
            w = (*w).nextunit;
            if (!!(w)) {
                qc_pcllib_genpc_lab((int64_t)51,labstmtstart);
            } else {
                qc_pcllib_genpc_lab((int64_t)52,labnextwhen);
            };
L1554 :;
        }L1555 :;
        ;
        if (!!(fmult)) {
            qc_pclgen_definefwdlabel(&labstmtstart);
        };
        qc_pclgen_do_block((*wt).b);
        if (!(!!(loopsw))) {
            qc_pclgen_genjumpl(lab_d);
        } else {
            qc_pclgen_genjumpl(lab_a);
        };
        qc_pclgen_definefwdlabel(&labnextwhen);
        wt = (*wt).nextunit;
L1551 :;
    }L1552 :;
    ;
    qc_pclgen_genfree((int64_t)1);
    if (!!(pelse)) {
        qc_pclgen_do_block(pelse);
    };
    if (!!(loopsw)) {
        qc_pclgen_genjumpl(lab_a);
        qc_pclgen_definefwdlabel(&lab_d);
        qc_pclgen_unstacklooplabels();
    } else {
        qc_pclgen_definefwdlabel(&lab_d);
    };
}

static void qc_pclgen_do_try(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    int64_t labend;
    int64_t labx;
    struct var_decls_unitrec *  ptry;
    struct var_decls_unitrec *  pexcept;
    struct var_decls_unitrec *  pexcode;
    ++qc_pclgen_trylevel;
    labend = qc_pclgen_createfwdlabel();
    ptry = a;
    labx = qc_pclgen_createfwdlabel();
    pexcept = b;
    if ((pexcept == 0)) {
        qc_support_gerror((uint8_t*)"try: no except",(struct var_decls_unitrec *)(0));
    } else if (!!((*pexcept).nextunit)) {
        qc_support_gerror((uint8_t*)"Try:multiple except block not implemented",(struct var_decls_unitrec *)(0));
    };
    L1556 :;
    while (!!(pexcept)) {
        pexcode = (*pexcept).a;
        if (((pexcode == 0) || !!((*pexcode).nextunit))) {
            qc_support_gerror((uint8_t*)"Try:multiple except codes not implemented",(struct var_decls_unitrec *)(0));
        };
        qc_pcllib_genpc_lab((int64_t)207,labx);
        qc_pcllib_genopnd_int(qc_lib_getconstvalue(pexcode,(int64_t)103));
        qc_pcllib_genopnd_int((int64_t)1);
        qc_pclgen_do_block(ptry);
        qc_pclgen_genjumpl(labend);
        qc_pclgen_definefwdlabel(&labx);
        qc_pclgen_do_block((*pexcept).b);
        qc_pclgen_definefwdlabel(&labend);
        pexcept = (*pexcept).nextunit;
L1557 :;
    }L1558 :;
    ;
    qc_pcllib_genpc_int((int64_t)72,(int64_t)1);
    --qc_pclgen_trylevel;
}

static void qc_pclgen_do_applyop(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b,struct var_decls_unitrec * c) {
    int64_t lab;
    if (!!(c)) {
        qc_pclgen_evalref(b);
        qc_pclgen_evalexpr(c);
        qc_pclgen_evalexpr(a);
        qc_pcllib_genpc_int((int64_t)209,(int64_t)2);
    } else {
        qc_pclgen_evalref(b);
        qc_pclgen_evalexpr(a);
        qc_pcllib_genpc_int((int64_t)209,(int64_t)1);
    };
    lab = qc_pclgen_createfwdlabel();
    qc_pcllib_genpc_lab((int64_t)39,lab);
    qc_pcllib_genpc((int64_t)1);
    qc_pclgen_definefwdlabel(&lab);
}

static void qc_pclgen_evalref(struct var_decls_unitrec * p) {
    struct var_decls_strec *  d;
    int64_t lab1;
    int64_t lab2;
    switch ((int64_t)((*p).tag)) {
    case 1:;
    {
        qc_support_gerror((uint8_t*)"ref on const",(struct var_decls_unitrec *)(0));
    }break;
    case 3:;
    {
        d = (*p).def;
        if (((int64_t)((*d).nameid)==(int64_t)5)) {
            qc_pcllib_genpc_s((int64_t)9,d);
        }else if (((int64_t)((*d).nameid)==(int64_t)10)) {
            qc_pcllib_genpc_s((int64_t)7,d);
        }else if (((int64_t)((*d).nameid)==(int64_t)11)) {
            qc_pcllib_genpc_s((int64_t)8,d);
            (*d).attribs.ax_used = (uint64_t)((int64_t)1);
        }else if (((int64_t)((*d).nameid)==(int64_t)12)) {
            if (!!((uint64_t)((*d).attribs.ax_byrefmode))) {
                qc_pcllib_genpc_s((int64_t)6,d);
            } else {
                qc_pcllib_genpc_s((int64_t)8,d);
            };
        }else if (((int64_t)((*d).nameid)==(int64_t)16)) {
            if (((int64_t)((*d).index) == (int64_t)0)) {
                (*d).index = qc_pclgen_createfwdlabel();
            };
            qc_pcllib_genpc_lab((int64_t)10,(int64_t)((*d).index));
        }else if (((int64_t)((*d).nameid)==(int64_t)6)) {
            qc_pcllib_genpc_s((int64_t)206,d);
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(pq_common_namenames[((int64_t)((*d).nameid))],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            qc_support_gerror((uint8_t*)"&name",(struct var_decls_unitrec *)(0));
        };
    }break;
    case 129:;
    case 131:;
    {
        qc_pclgen_evalref((*p).a);
        qc_pclgen_evalexpr((*p).b);
        qc_pcllib_genpc((int64_t)198);
    }break;
    case 133:;
    {
        qc_pclgen_evalref((*p).a);
        qc_pclgen_evalexpr((*p).b);
        qc_pcllib_genpc((int64_t)199);
    }break;
    case 136:;
    {
        qc_pclgen_evalexpr((*p).a);
        qc_pclgen_evalexpr((*p).b);
        qc_pcllib_genpc((int64_t)195);
    }break;
    case 140:;
    {
        qc_pclgen_evalref((*p).a);
        qc_pclgen_evalexpr((*p).b);
        qc_pcllib_genpc_int((int64_t)202,(int64_t)((*p).mode));
    }break;
    case 132:;
    case 137:;
    {
        qc_pclgen_evalexpr((*p).b);
        qc_pclgen_evalref((*p).a);
        qc_pcllib_genpc((int64_t)200);
    }break;
    case 146:;
    {
        qc_pclgen_evalexpr((*p).a);
    }break;
    case 141:;
    {
        qc_pclgen_evalref((*p).a);
        d = (*(*p).b).def;
        qc_pcllib_genpc_int((int64_t)83,(int64_t)((*d).offset));
    }break;
    case 92:;
    {
        lab1 = qc_pclgen_createfwdlabel();
        lab2 = qc_pclgen_createfwdlabel();
        qc_pclgen_genjumpcond((int64_t)0,(*p).a,lab1);
        qc_pclgen_evalref((*p).b);
        qc_pclgen_genjumpl(lab2);
        qc_pclgen_definefwdlabel(&lab1);
        qc_pclgen_evalref((*p).c);
        qc_pcllib_genpc((int64_t)1);
        qc_pclgen_definefwdlabel(&lab2);
    }break;
    default: {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(qc_tables_jtagnames[((int64_t)((*p).tag))],NULL);
        msysnewc_m_print_str((uint8_t*)"MLINENO=",NULL);
        msysnewc_m_print_i64(var_decls_mlineno,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        qc_support_gerror((uint8_t*)"EVALREF: Can't do tag",(struct var_decls_unitrec *)(0));
    }
    } //SW
;
}

static int64_t qc_pclgen_getpclop(int64_t opc) {
    int64_t i;
    int64_t av_1;
    L1559 :;
    for (i=(int64_t)1;i<=(int64_t)100;i+=(int64_t)1) {
L1560 :;
        if ((qc_pclgen_pcl_jcodes[(i)-1] == opc)) {
            qc_pclgen_noperands = (int64_t)(qc_pclgen_pcl_nopnds[(i)-1]);
            return qc_pclgen_pcl_kcodes[(i)-1];
        };
L1561 :;
    }L1562 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(qc_tables_jtagnames[(opc)],NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    qc_support_gerror((uint8_t*)"PCL:GETOPC No Op",(struct var_decls_unitrec *)(0));
    return (int64_t)0;
}

static void qc_pclgen_genjumpl(int64_t lab) {
    qc_pcllib_genpc_lab((int64_t)39,lab);
}

static int64_t qc_pclgen_definelabel(void) {
    int64_t lab;
    lab = (qc_pcllib_pcindex + (int64_t)1);
    qc_pcllib_lastopc = &qc_pclgen_dummyop;
    return lab;
}

static int64_t qc_pclgen_createfwdlabel(void) {
    int64_t lab;
    if ((qc_pcllib_nextfreelabel == (int64_t)0)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_i64((int64_t)1000,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        qc_support_gerror((uint8_t*)"Too many labels",(struct var_decls_unitrec *)(0));
    };
    lab = qc_pcllib_nextfreelabel;
    qc_pcllib_nextfreelabel = (int64_t)(qc_pcllib_labeltable[(lab)-1]);
    qc_pcllib_labeltable[(lab)-1] = (int64_t)0;
    return -(lab);
}

static void qc_pclgen_definefwdlabel(int64_t * oldlab) {
    int64_t pc;
    int64_t nextpc;
    int64_t newlab;
    int64_t index;
    qc_pcllib_lastopc = &qc_pclgen_dummyop;
    index = (*oldlab);
    if ((index >= (int64_t)0)) {
        qc_support_gerror((uint8_t*)"deffwdlabel?",(struct var_decls_unitrec *)(0));
    };
    index = -(index);
    newlab = (qc_pcllib_pcindex + (int64_t)1);
    pc = (int64_t)(qc_pcllib_labeltable[(index)-1]);
    L1563 :;
    while (!!(pc)) {
        nextpc = (*qc_pcllib_pccode)[(pc)-1];
        (*qc_pcllib_pccode)[(pc)-1] = newlab;
        pc = nextpc;
L1564 :;
    }L1565 :;
    ;
    qc_pcllib_labeltable[(index)-1] = qc_pcllib_nextfreelabel;
    qc_pcllib_nextfreelabel = index;
    (*oldlab) = newlab;
}

static void qc_pclgen_stacklooplabels(int64_t * a,int64_t * b,int64_t * c,int64_t * d) {
    if ((qc_pclgen_loopindex >= (int64_t)20)) {
        qc_support_gerror((uint8_t*)"Too many nested loops",(struct var_decls_unitrec *)(0));
    };
    ++qc_pclgen_loopindex;
    qc_pclgen_loopstack[(qc_pclgen_loopindex)-1][((int64_t)1)-1] = a;
    qc_pclgen_loopstack[(qc_pclgen_loopindex)-1][((int64_t)2)-1] = b;
    qc_pclgen_loopstack[(qc_pclgen_loopindex)-1][((int64_t)3)-1] = c;
    qc_pclgen_loopstack[(qc_pclgen_loopindex)-1][((int64_t)4)-1] = d;
    qc_pclgen_trylevelstack[(qc_pclgen_loopindex)-1] = qc_pclgen_trylevel;
}

static void qc_pclgen_unstacklooplabels(void) {
    --qc_pclgen_loopindex;
}

static int64_t qc_pclgen_findlooplabel(int64_t k,int64_t n) {
    int64_t i;
    if ((n == (int64_t)0)) {
        i = (int64_t)1;
    } else {
        i = (qc_pclgen_loopindex - (n - (int64_t)1));
    };
    if (((i < (int64_t)1) || (i > qc_pclgen_loopindex))) {
        qc_support_gerror((uint8_t*)"Bad loop index",(struct var_decls_unitrec *)(0));
    };
    qc_pclgen_looptrylevel = qc_pclgen_trylevelstack[(i)-1];
    return (*qc_pclgen_loopstack[(i)-1][(k)-1]);
}

static int64_t qc_pclgen_issimpleparam(struct var_decls_unitrec * p) {
    switch ((int64_t)((*p).tag)) {
    case 1:;
    {
        return (int64_t)1;
    }break;
    case 182:;
    case 180:;
    case 181:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 103:;
    case 102:;
    case 158:;
    case 210:;
    case 209:;
    case 212:;
    case 211:;
    {
        return (int64_t)1;
    }break;
    default: {
    }
    } //SW
;
    return (int64_t)0;
}

static void qc_pclgen_genjumpcond(int64_t opc,struct var_decls_unitrec * p,int64_t lab) {
    int64_t oldmlineno;
    int64_t lab2;
    struct var_decls_unitrec *  q;
    struct var_decls_unitrec *  r;
    int64_t x;
    oldmlineno = var_decls_mlineno;
    var_decls_mlineno = (int64_t)((*p).lineno);
    q = (*p).a;
    r = (*p).b;
    switch ((int64_t)((*p).tag)) {
    case 74:;
    {
        if ((opc==(int64_t)0)) {
            qc_pclgen_genjumpcond((int64_t)0,q,lab);
            qc_pclgen_genjumpcond((int64_t)0,r,lab);
        }else if ((opc==(int64_t)1)) {
            lab2 = qc_pclgen_createfwdlabel();
            qc_pclgen_genjumpcond((int64_t)0,q,lab2);
            qc_pclgen_genjumpcond((int64_t)1,r,lab);
            qc_pclgen_definefwdlabel(&lab2);
        };
    }break;
    case 75:;
    {
        if ((opc==(int64_t)0)) {
            lab2 = qc_pclgen_createfwdlabel();
            qc_pclgen_genjumpcond((int64_t)1,q,lab2);
            qc_pclgen_genjumpcond((int64_t)0,r,lab);
            qc_pclgen_definefwdlabel(&lab2);
        }else if ((opc==(int64_t)1)) {
            qc_pclgen_genjumpcond((int64_t)1,q,lab);
            qc_pclgen_genjumpcond((int64_t)1,r,lab);
        };
    }break;
    case 77:;
    {
        if ((opc==(int64_t)0)) {
            qc_pclgen_genjumpcond((int64_t)1,q,lab);
        }else if ((opc==(int64_t)1)) {
            qc_pclgen_genjumpcond((int64_t)0,q,lab);
        };
    }break;
    case 78:;
    {
        qc_pclgen_genjumpcond(opc,q,lab);
    }break;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 103:;
    case 102:;
    {
        qc_pclgen_gcomparejump(opc,p,q,r,lab);
    }break;
    case 3:;
    {
        qc_pclgen_evalexpr(p);
        qc_pcllib_genpc_lab((!!(opc)?(int64_t)41:(int64_t)42),lab);
    }break;
    case 1:;
    {
        x = (*p).value;
        if (((int64_t)((*p).mode) == (int64_t)1)) {
            goto L1566 ;
;
        };
        if ((((x != (int64_t)0) && (opc == (int64_t)1)) || ((x == (int64_t)0) && (opc == (int64_t)0)))) {
            qc_pclgen_genjumpl(lab);
        };
    }break;
    default: {
        //doelse:
L1566 :;
;
        if (((int64_t)((*p).tag)==(int64_t)192) || ((int64_t)((*p).tag)==(int64_t)190)) {
            qc_pclgen_evalexpr(q);
            if ((opc == (int64_t)1)) {
                qc_pcllib_genpc_lab((((int64_t)((*p).tag) == (int64_t)192)?(int64_t)43:(int64_t)44),lab);
            } else {
                qc_pcllib_genpc_lab((((int64_t)((*p).tag) == (int64_t)192)?(int64_t)44:(int64_t)43),lab);
            };
        } else {
            qc_pclgen_evalexpr(p);
            qc_pcllib_genpc_lab((!!(opc)?(int64_t)41:(int64_t)42),lab);
        };
    }
    } //SW
;
    var_decls_mlineno = oldmlineno;
}

static void qc_pclgen_gcomparejump(int64_t jumpopc,struct var_decls_unitrec * p,struct var_decls_unitrec * lhs,struct var_decls_unitrec * rhs,int64_t lab) {
    int64_t cond;
    int64_t opc;
    cond = (int64_t)((*p).tag);
    if ((jumpopc == (int64_t)0)) {
        cond = qc_pclgen_reversecond(cond);
    };
    if ((cond==(int64_t)98)) {
        opc = (int64_t)45;
    }else if ((cond==(int64_t)99)) {
        opc = (int64_t)46;
    }else if ((cond==(int64_t)100)) {
        opc = (int64_t)47;
    }else if ((cond==(int64_t)101)) {
        opc = (int64_t)48;
    }else if ((cond==(int64_t)103)) {
        opc = (int64_t)49;
    }else if ((cond==(int64_t)102)) {
        opc = (int64_t)50;
    };
    qc_pclgen_evalexpr(lhs);
    qc_pclgen_evalexpr(rhs);
    qc_pcllib_genpc_lab(opc,lab);
}

static int64_t qc_pclgen_reversecond(int64_t op) {
    if ((op==(int64_t)98)) {
        return (int64_t)99;
    }else if ((op==(int64_t)99)) {
        return (int64_t)98;
    }else if ((op==(int64_t)100)) {
        return (int64_t)103;
    }else if ((op==(int64_t)101)) {
        return (int64_t)102;
    }else if ((op==(int64_t)103)) {
        return (int64_t)100;
    }else if ((op==(int64_t)102)) {
        return (int64_t)101;
    };
    return (int64_t)0;
}

static void qc_pclgen_do_convert(int64_t m,struct var_decls_unitrec * p) {
    int64_t n;
    int64_t elemmode;
    int64_t i;
    int64_t lowerx;
    int64_t lbound;
    struct var_decls_unitrec *  plist[50];
    if ((((int64_t)((*p).tag) != (int64_t)79) && ((int64_t)((*p).tag) != (int64_t)80))) {
        if (((int64_t)(var_decls_ttbasetype[(m)]) == (int64_t)32)) {
            p = qc_lib_createunit2((int64_t)79,p,(struct var_decls_unitrec *)(0));
            goto L1567 ;
;
        };
        //doconv:
L1568 :;
;
        qc_pclgen_evalexpr(p);
        qc_pcllib_genpc_int((int64_t)85,m);
        return;
    };
    //skip:
L1567 :;
;
    n = qc_pclgen_unitstoarray((*p).a,&plist,(int64_t)50);
    if (((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)32) || ((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)33)) {
        if ((n < (int64_t)(var_decls_ttlength[(m)]))) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(var_decls_ttname[(m)],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            qc_support_gerror((uint8_t*)"Too few fields",p);
        } else if ((n > (int64_t)(var_decls_ttlength[(m)]))) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(var_decls_ttname[(m)],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            qc_support_gerror((uint8_t*)"Too many fields",p);
        };
        L1569 :;
        for (i=(int64_t)1;i<=n;i+=(int64_t)1) {
L1570 :;
            qc_pclgen_evalexpr(plist[(i)-1]);
L1571 :;
        }L1572 :;
        ;
        qc_pcllib_genpc_int2((((int64_t)(var_decls_ttbasetype[(m)]) == (int64_t)32)?(int64_t)76:(int64_t)78),n,m);
    }else if (((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)29)) {
        if (!!((*p).b)) {
            lowerx = qc_lib_getconstvalue((*p).b,(int64_t)104);
        } else {
            lowerx = (int64_t)1;
        };
        if ((n == (int64_t)0)) {
            qc_pcllib_genpc_int((int64_t)22,lowerx);
        } else {
            L1573 :;
            for (i=(int64_t)1;i<=n;i+=(int64_t)1) {
L1574 :;
                qc_pclgen_evalexpr(plist[(i)-1]);
L1575 :;
            }L1576 :;
            ;
            qc_pcllib_genpc_int2((int64_t)75,n,lowerx);
        };
    }else if (((int64_t)(var_decls_ttbasetype[(m)])==(int64_t)30)) {
        L1577 :;
        for (i=(int64_t)1;i<=n;i+=(int64_t)1) {
L1578 :;
            qc_pclgen_evalexpr(plist[(i)-1]);
L1579 :;
        }L1580 :;
        ;
        if ((m == (int64_t)30)) {
            if (!!((*p).b)) {
                lbound = qc_lib_getconstvalue((*p).b,(int64_t)105);
            } else {
                lbound = (int64_t)1;
            };
            if ((n == (int64_t)0)) {
                qc_pcllib_genpc_int2((int64_t)24,(int64_t)39,lbound);
            } else {
                qc_pcllib_genpc_int4((int64_t)77,n,lbound,(int64_t)30,(int64_t)39);
            };
        } else {
            elemmode = (int64_t)(var_decls_tttarget[(m)]);
            if (!!((*p).b)) {
                qc_support_gerror((uint8_t*)"2:Can't override lwb",(struct var_decls_unitrec *)(0));
            };
            lbound = (int64_t)(var_decls_ttlower[(m)]);
            if (!!((int64_t)(var_decls_ttlength[(m)]))) {
                if ((n < (int64_t)(var_decls_ttlength[(m)]))) {
                    msysnewc_m_print_startcon();
                    msysnewc_m_print_str(var_decls_ttname[(m)],NULL);
                    msysnewc_m_print_newline();
                    msysnewc_m_print_end();
                    ;
                    qc_support_gerror((uint8_t*)"Too few elements",p);
                } else if ((n > (int64_t)(var_decls_ttlength[(m)]))) {
                    msysnewc_m_print_startcon();
                    msysnewc_m_print_str(var_decls_ttname[(m)],NULL);
                    msysnewc_m_print_newline();
                    msysnewc_m_print_end();
                    ;
                    qc_support_gerror((uint8_t*)"Too many elements",p);
                };
                if ((n == (int64_t)0)) {
                    qc_pcllib_genpc_int2((int64_t)24,elemmode,lbound);
                } else {
                    qc_pcllib_genpc_int4((int64_t)77,n,lbound,m,elemmode);
                };
            } else {
                if ((n == (int64_t)0)) {
                    qc_pcllib_genpc_int2((int64_t)24,elemmode,lbound);
                } else {
                    qc_pcllib_genpc_int4((int64_t)77,n,lbound,m,elemmode);
                };
            };
        };
    } else {
        qc_pclgen_evalexpr(p);
        qc_pcllib_genpc_int((int64_t)85,m);
    };
}

static void qc_pclgen_do_selectx(struct var_decls_unitrec * pindex,struct var_decls_unitrec * pplist,struct var_decls_unitrec * pelse) {
    int64_t n;
    int64_t labend;
    int64_t i;
    int64_t lab;
    int64_t elselab;
    struct var_decls_unitrec *  x;
    struct var_decls_unitrec *  plist[512];
    int64_t labels[513];
    n = qc_pclgen_unitstoarray(pplist,&plist,(int64_t)512);
    if ((n > (int64_t)512)) {
        qc_support_gerror((uint8_t*)"Selectx too complex",(struct var_decls_unitrec *)(0));
    };
    labend = qc_pclgen_createfwdlabel();
    qc_pclgen_evalexpr(pindex);
    qc_pcllib_genpc_int2((int64_t)55,n,(int64_t)1);
    L1581 :;
    for (i=(int64_t)1;i<=n;i+=(int64_t)1) {
L1582 :;
        qc_pcllib_genpc_lab((int64_t)53,(int64_t)0);
        labels[(i)-1] = qc_pcllib_pcindex;
L1583 :;
    }L1584 :;
    ;
    qc_pcllib_genpc_lab((int64_t)53,(int64_t)0);
    labels[((n + (int64_t)1))-1] = qc_pcllib_pcindex;
    i = (int64_t)1;
    L1585 :;
    for (i=(int64_t)1;i<=n;i+=(int64_t)1) {
L1586 :;
        x = plist[(i)-1];
        lab = qc_pclgen_definelabel();
        (*qc_pcllib_pccode)[(labels[(i)-1])-1] = lab;
        qc_pclgen_evalexpr(x);
        qc_pclgen_genjumpl(labend);
L1587 :;
    }L1588 :;
    ;
    elselab = qc_pclgen_definelabel();
    (*qc_pcllib_pccode)[(labels[((n + (int64_t)1))-1])-1] = elselab;
    qc_pclgen_evalexpr(pelse);
    qc_pcllib_genpc((int64_t)1);
    qc_pclgen_definefwdlabel(&labend);
}

static void qc_pclgen_do_calldll(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    struct var_decls_strec *  d;
    struct var_decls_strec *  pm;
    struct var_decls_unitrec *  x;
    int64_t naparams;
    int64_t fkeyword;
    int64_t nparams;
    int64_t i;
    int64_t j;
    int64_t k;
    int64_t resmode;
    int64_t m;
    int64_t varparams;
    int64_t isfn;
    int64_t fbyref;
    int64_t langcode;
    struct var_decls_unitrec *  cparams[64];
    struct var_decls_strec *  dparams[64];
    int64_t dparamsdone;
    uint8_t *  name;
    dparamsdone = (int64_t)0;
    d = (*a).def;
    if (!!((varparams = (int64_t)((*d).attribs.ax_varparams)))) {
        qc_pclgen_do_calldllvar(p,a,b);
        return;
    };
    resmode = (int64_t)((*d).mode);
    isfn = (resmode != (int64_t)0);
    if ((((int64_t)((*p).tag) == (int64_t)90) && !(!!(isfn)))) {
        qc_support_gerror((uint8_t*)"DLL: needs function",(struct var_decls_unitrec *)(0));
    };
    if (((int64_t)((*p).tag) == (int64_t)14)) {
        isfn = (int64_t)0;
        resmode = (int64_t)0;
    };
    if (!!(isfn)) {
        qc_pcllib_genpc((int64_t)19);
    };
    fkeyword = (int64_t)0;
    naparams = (int64_t)0;
    nparams = (int64_t)((*d).attribs.ax_nparams);
    memset((void *)(&cparams),(int64_t)0,(uint64_t)(((int64_t)8 * nparams)));
    x = b;
    L1589 :;
    while (!!(x)) {
        ++naparams;
        cparams[(naparams)-1] = (struct var_decls_unitrec *)(0);
        if ((naparams > nparams)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((*d).name,NULL);
            msysnewc_m_print_i64(naparams,NULL);
            msysnewc_m_print_i64(nparams,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            qc_support_gerror((uint8_t*)"Too many params",p);
        };
        if ((!!(fkeyword) && ((int64_t)((*x).tag) != (int64_t)86))) {
            qc_support_gerror((uint8_t*)"Normal param follows keyword param",p);
        };
        if (((int64_t)((*x).tag)==(int64_t)86)) {
            fkeyword = (int64_t)1;
            name = (*(*(*x).a).def).name;
            if (!(!!(dparamsdone))) {
                qc_pclgen_extractparams(d,&dparams);
                dparamsdone = (int64_t)1;
            };
            k = (int64_t)0;
            L1592 :;
            for (j=(int64_t)1;j<=nparams;j+=(int64_t)1) {
L1593 :;
                if (!!(mlib_eqstring((*dparams[(j)-1]).name,name))) {
                    k = j;
                    goto L1595 ;
                };
L1594 :;
            }L1595 :;
            ;
            if ((k == (int64_t)0)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str(name,NULL);
                msysnewc_m_print_str((uint8_t*)"in",NULL);
                msysnewc_m_print_str((*d).name,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                qc_support_gerror((uint8_t*)"Can't find keyword param",(struct var_decls_unitrec *)(0));
            };
            if (!!(cparams[(k)-1])) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str(name,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                qc_support_gerror((uint8_t*)"Param already set",(struct var_decls_unitrec *)(0));
            };
            cparams[(k)-1] = (*x).b;
        }else if (((int64_t)((*x).tag)==(int64_t)2)) {
        } else {
            cparams[(naparams)-1] = x;
        };
        x = (*x).nextunit;
L1590 :;
    }L1591 :;
    ;
    L1596 :;
    for (i=(int64_t)1;i<=nparams;i+=(int64_t)1) {
L1597 :;
        x = cparams[(i)-1];
        if ((x == 0)) {
            if (!(!!(dparamsdone))) {
                qc_pclgen_extractparams(d,&dparams);
                dparamsdone = (int64_t)1;
            };
            pm = dparams[(i)-1];
            if (!!((*pm).code)) {
                cparams[(i)-1] = (*pm).code;
            } else if (!(!!((uint64_t)((*pm).attribs.ax_optional)))) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((*pm).name,NULL);
                msysnewc_m_print_str((uint8_t*)"in",NULL);
                msysnewc_m_print_str((*d).name,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                qc_support_gerror((uint8_t*)"Param not optional",(struct var_decls_unitrec *)(0));
            };
        };
L1598 :;
    }L1599 :;
    ;
    qc_pcllib_genpc((int64_t)66);
    L1600 :;
    for (i=(int64_t)1;i<=nparams;i+=(int64_t)1) {
L1601 :;
        x = cparams[(i)-1];
        if (!(!!(dparamsdone))) {
            qc_pclgen_extractparams(d,&dparams);
            dparamsdone = (int64_t)1;
        };
        m = (int64_t)((*dparams[(i)-1]).mode);
        fbyref = (int64_t)((*dparams[(i)-1]).attribs.ax_byrefmode);
        if (!!(fbyref)) {
            qc_support_gerror((uint8_t*)"Byref on dll call",(struct var_decls_unitrec *)(0));
        };
        if ((x == 0)) {
            qc_support_gerror((uint8_t*)"Dll missing param - no default",(struct var_decls_unitrec *)(0));
        } else {
            qc_pclgen_evalexpr(x);
            qc_pcllib_genpc_int((int64_t)67,m);
        };
L1602 :;
    }L1603 :;
    ;
    if (((int64_t)((*d).attribs.ax_fflang)==(int64_t)1)) {
        langcode = (int64_t)87;
    }else if (((int64_t)((*d).attribs.ax_fflang)==(int64_t)2)) {
        langcode = (int64_t)67;
    }else if (((int64_t)((*d).attribs.ax_fflang)==(int64_t)4)) {
        langcode = (int64_t)77;
    } else {
        qc_support_gerror((uint8_t*)"Bad FF?",(struct var_decls_unitrec *)(0));
    };
    qc_pcllib_genpc_s((int64_t)68,d);
    qc_pcllib_genopnd_int(langcode);
    qc_pcllib_genopnd_int(resmode);
}

static int64_t qc_pclgen_islogical(struct var_decls_unitrec * p) {
    if (((int64_t)((*p).tag)==(int64_t)78) || ((int64_t)((*p).tag)==(int64_t)77) || ((int64_t)((*p).tag)==(int64_t)74) || ((int64_t)((*p).tag)==(int64_t)75) || ((int64_t)((*p).tag)==(int64_t)76)) {
        return (int64_t)1;
    };
    return (int64_t)0;
}

static void qc_pclgen_do_and(struct var_decls_unitrec * x,struct var_decls_unitrec * y) {
    int64_t a;
    int64_t b;
    a = qc_pclgen_createfwdlabel();
    b = qc_pclgen_createfwdlabel();
    qc_pclgen_genjumpcond((int64_t)0,x,a);
    qc_pclgen_genjumpcond((int64_t)0,y,a);
    qc_pcllib_genpc_int((int64_t)11,(int64_t)1);
    qc_pclgen_genjumpl(b);
    qc_pclgen_definefwdlabel(&a);
    qc_pcllib_genpc_int((int64_t)11,(int64_t)0);
    qc_pcllib_genpc((int64_t)1);
    qc_pclgen_definefwdlabel(&b);
}

static void qc_pclgen_do_or(struct var_decls_unitrec * x,struct var_decls_unitrec * y) {
    int64_t a;
    int64_t b;
    a = qc_pclgen_createfwdlabel();
    b = qc_pclgen_createfwdlabel();
    qc_pclgen_genjumpcond((int64_t)1,x,a);
    qc_pclgen_genjumpcond((int64_t)1,y,a);
    qc_pcllib_genpc_int((int64_t)11,(int64_t)0);
    qc_pclgen_genjumpl(b);
    qc_pclgen_definefwdlabel(&a);
    qc_pcllib_genpc_int((int64_t)11,(int64_t)1);
    qc_pcllib_genpc((int64_t)1);
    qc_pclgen_definefwdlabel(&b);
}

static void qc_pclgen_do_callptr(struct var_decls_unitrec * p,struct var_decls_unitrec * pproc,struct var_decls_unitrec * pparams) {
    int64_t n;
    int64_t i;
    struct var_decls_unitrec *  params[64];
    struct var_decls_unitrec *  x;
    struct var_decls_unitrec *  q;
    qc_pcllib_genpc((int64_t)19);
    n = (int64_t)0;
    q = pparams;
    L1604 :;
    while (!!(q)) {
        params[(++n)-1] = q;
        q = (*q).nextunit;
L1605 :;
    }L1606 :;
    ;
    L1607 :;
    for (i=n;i>=(int64_t)1;i-=(int64_t)1) {
L1608 :;
        x = params[(i)-1];
        if (((int64_t)((*x).tag) == (int64_t)2)) {
            qc_pcllib_genpc_int((int64_t)18,(int64_t)0);
        } else {
            qc_pclgen_evalexpr(x);
        };
L1609 :;
    }L1610 :;
    ;
    if (((int64_t)((*pproc).tag) != (int64_t)146)) {
        qc_support_gerror((uint8_t*)"Callptr?",(struct var_decls_unitrec *)(0));
    };
    qc_pclgen_evalexpr((*pproc).a);
    qc_pcllib_genpc_int2((int64_t)64,n,(int64_t)0);
    if (!!(n)) {
        qc_pclgen_genfree(n);
    };
    if (((int64_t)((*p).tag) == (int64_t)14)) {
        qc_pclgen_genfree((int64_t)1);
    };
}

static void qc_pclgen_do_callmproc(struct var_decls_unitrec * p,struct var_decls_unitrec * pproc,struct var_decls_unitrec * pparams,int64_t calledasfn) {
    int64_t n;
    int64_t isfn;
    int64_t i;
    struct var_decls_unitrec *  params[64];
    struct var_decls_unitrec *  x;
    struct var_decls_unitrec *  pleft;
    isfn = (int64_t)1;
    if (!!(isfn)) {
        qc_pcllib_genpc((int64_t)19);
    };
    n = qc_pclgen_unitstoarray(pparams,&params,(int64_t)64);
    L1611 :;
    for (i=n;i>=(int64_t)1;i-=(int64_t)1) {
L1612 :;
        x = params[(i)-1];
        if (((int64_t)((*x).tag) == (int64_t)2)) {
            qc_pcllib_genpc((int64_t)19);
        } else {
            qc_pclgen_evalexpr(x);
        };
L1613 :;
    }L1614 :;
    ;
    if (((int64_t)((*pproc).tag) != (int64_t)141)) {
        qc_support_gerror((uint8_t*)"Callmproc/not dot",(struct var_decls_unitrec *)(0));
    };
    pleft = (*pproc).a;
    qc_pclgen_evalref(pleft);
    qc_pclgen_evalexpr(pproc);
    qc_pcllib_genpc_int2((int64_t)64,(n + (int64_t)1),(int64_t)0);
    qc_pclgen_genfree((n + (int64_t)1));
    if (!(!!(calledasfn))) {
        qc_pclgen_genfree((int64_t)1);
    };
}

static int64_t qc_pclgen_checkblockreturn(struct var_decls_unitrec * p) {
    struct var_decls_unitrec *  q;
    struct var_decls_unitrec *  r;
    if ((p == 0)) {
        return (int64_t)0;
    };
    if (((int64_t)((*p).tag) != (int64_t)4)) {
        qc_support_gerror((uint8_t*)"CBR?",(struct var_decls_unitrec *)(0));
    };
    q = (*p).a;
    if ((q == 0)) {
        return (int64_t)0;
    };
    L1615 :;
    while (!!((r = (*q).nextunit))) {
        q = r;
L1616 :;
    }L1617 :;
    ;
    if (((int64_t)((*q).tag)==(int64_t)16)) {
        return (int64_t)1;
    }else if (((int64_t)((*q).tag)==(int64_t)21)) {
        return (!!(qc_pclgen_checkblockreturn((*q).b)) && !!(qc_pclgen_checkblockreturn((*q).c)));
    }else if (((int64_t)((*q).tag)==(int64_t)22)) {
        r = (*q).a;
        L1618 :;
        while (!!(r)) {
            if (!(!!(qc_pclgen_checkblockreturn((*r).b)))) {
                return (int64_t)0;
            };
            r = (*r).nextunit;
L1619 :;
        }L1620 :;
        ;
        return qc_pclgen_checkblockreturn((*q).b);
    };
    return (int64_t)0;
}

static void qc_pclgen_genfree(int64_t n) {
    qc_pcllib_genpc_int((int64_t)71,n);
}

static void qc_pclgen_do_clamp(struct var_decls_unitrec * x,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    qc_pclgen_evalexpr(x);
    qc_pclgen_evalexpr(a);
    qc_pcllib_genpc((int64_t)175);
    qc_pclgen_evalexpr(b);
    qc_pcllib_genpc((int64_t)174);
}

static void qc_pclgen_do_applyopx(struct var_decls_unitrec * x,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    int64_t lab;
    if (!!(b)) {
        qc_pclgen_evalexpr(a);
        qc_pclgen_evalexpr(b);
        qc_pclgen_evalexpr(x);
        qc_pcllib_genpc_int((int64_t)209,(int64_t)2);
    } else {
        qc_pclgen_evalexpr(a);
        qc_pclgen_evalexpr(x);
        qc_pcllib_genpc_int((int64_t)209,(int64_t)1);
    };
    lab = qc_pclgen_createfwdlabel();
    qc_pcllib_genpc_lab((int64_t)39,lab);
    qc_pcllib_genpc((int64_t)1);
    qc_pclgen_definefwdlabel(&lab);
}

static void qc_pclgen_do_calldllvar(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    struct var_decls_strec *  d;
    struct var_decls_unitrec *  x;
    int64_t naparams;
    int64_t nparams;
    int64_t i;
    int64_t resmode;
    int64_t isfn;
    int64_t t;
    int64_t langcode;
    struct var_decls_strec *  dparams[64];
    int64_t dparamsdone;
    dparamsdone = (int64_t)0;
    d = (*a).def;
    resmode = (int64_t)((*d).mode);
    isfn = (resmode != (int64_t)0);
    if ((((int64_t)((*p).tag) == (int64_t)90) && !(!!(isfn)))) {
        qc_support_gerror((uint8_t*)"DLL: needs function",(struct var_decls_unitrec *)(0));
    };
    if (((int64_t)((*p).tag) == (int64_t)14)) {
        isfn = (int64_t)0;
        resmode = (int64_t)0;
    };
    if (!!(isfn)) {
        qc_pcllib_genpc((int64_t)19);
    };
    nparams = (int64_t)((*d).attribs.ax_nparams);
    qc_pclgen_extractparams(d,&dparams);
    qc_pcllib_genpc((int64_t)66);
    x = b;
    naparams = (int64_t)0;
    i = (int64_t)1;
    L1621 :;
    while (!!(x)) {
        ++naparams;
        qc_pclgen_evalexpr(x);
        if ((i <= nparams)) {
            t = (int64_t)((*dparams[(i)-1]).mode);
        } else {
            t = (int64_t)0;
        };
        qc_pcllib_genpc_int((int64_t)67,t);
        x = (*x).nextunit;
        ++i;
L1622 :;
    }L1623 :;
    ;
    if (((int64_t)((*d).attribs.ax_fflang)==(int64_t)1)) {
        langcode = (int64_t)87;
    }else if (((int64_t)((*d).attribs.ax_fflang)==(int64_t)2)) {
        langcode = (int64_t)67;
    }else if (((int64_t)((*d).attribs.ax_fflang)==(int64_t)4)) {
        langcode = (int64_t)77;
    } else {
        qc_support_gerror((uint8_t*)"Bad FF?",(struct var_decls_unitrec *)(0));
    };
    qc_pcllib_genpc_s((int64_t)68,d);
    qc_pcllib_genopnd_int(langcode);
    qc_pcllib_genopnd_int(resmode);
}

static void qc_pclgen_callhostfn(int64_t fnindex,int64_t calledasfn) {
    qc_pcllib_genpc_int((int64_t)69,fnindex);
    if ((!!(pq_common_hostisfn[(fnindex)]) && !(!!(calledasfn)))) {
        qc_pclgen_genfree((int64_t)1);
    };
}

static void qc_pclgen_extractparams(struct var_decls_strec * d,struct var_decls_strec * (*params)[]) {
    struct var_decls_strec *  p;
    int64_t i;
    p = (*d).paramlist;
    i = (int64_t)0;
    L1624 :;
    while (!!(p)) {
        (*params)[(++i)-1] = p;
        p = (*p).nextparam;
L1625 :;
    }L1626 :;
    ;
}

static int64_t qc_pclgen_unitstoarray(struct var_decls_unitrec * p,struct var_decls_unitrec * (*plist)[],int64_t maxunits) {
    int64_t n;
    n = (int64_t)0;
    L1627 :;
    while (!!(p)) {
        if ((n >= maxunits)) {
            qc_support_gerror((uint8_t*)"UTO Too many units",(struct var_decls_unitrec *)(0));
        };
        (*plist)[(++n)-1] = p;
        p = (*p).nextunit;
L1628 :;
    }L1629 :;
    ;
    return n;
}

static void qc_pclgen_do_idiv(struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    int64_t x;
    if ((b == 0)) {
        qc_support_gerror((uint8_t*)"Idiv?",(struct var_decls_unitrec *)(0));
    };
    qc_pclgen_evalexpr(a);
    if ((((int64_t)((*b).tag) == (int64_t)1) && ((int64_t)((*b).mode) == (int64_t)1))) {
        if (((x = (*b).value)==(int64_t)0)) {
            qc_support_gerror((uint8_t*)"div 0",(struct var_decls_unitrec *)(0));
        }else if (((x = (*b).value)==(int64_t)1)) {
            return;
        };
    };
    qc_pclgen_evalexpr(b);
    qc_pcllib_genpc((int64_t)157);
}

static int64_t qc_pclgen_ispoweroftwo(int64_t x) {
    int64_t a;
    int64_t n;
    int64_t av_1;
    a = (int64_t)1;
    n = (int64_t)0;
    av_1 = (int64_t)30;
    while (av_1-- > 0) {
L1630 :;
        ++n;
        a = (a << (int64_t)1);
        if ((a == x)) {
            return n;
        };
L1631 :;
    }L1632 :;
    ;
    return (int64_t)0;
}

static void qc_pclgen_genpushint(uint64_t a) {
    qc_pcllib_genpc_int((int64_t)11,(int64_t)(a));
}

static void qc_pclgen_do_callappl(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b,int64_t callasfn) {
    struct var_decls_strec *  d;
    struct var_decls_unitrec *  pbody;
    struct var_decls_unitrec *  r;
    int64_t nparams;
    int64_t i;
    struct var_decls_unitrec *  params[64];
    int64_t dparamsdone;
    int64_t index;
    dparamsdone = (int64_t)0;
    d = (*a).def;
    index = (int64_t)((*d).index);
    pbody = (*d).code;
    qc_pcllib_genpc((int64_t)19);
    nparams = (int64_t)0;
    r = b;
    L1633 :;
    while (!!(r)) {
        params[(++nparams)-1] = r;
        r = (*r).nextunit;
L1634 :;
    }L1635 :;
    ;
    L1636 :;
    for (i=nparams;i>=(int64_t)1;i-=(int64_t)1) {
L1637 :;
        qc_pclgen_evalexpr(params[(i)-1]);
L1638 :;
    }L1639 :;
    ;
    qc_pcllib_genpc_int2((int64_t)216,index,nparams);
    if (!(!!(callasfn))) {
        qc_pclgen_genfree((int64_t)1);
    };
}

void qc_pcllib_initpcl(int64_t size) {
    int64_t i;
    int64_t j;
    int64_t nn;
    qc_pcllib_npccode = (size * (int64_t)2);
    qc_pcllib_pccode = (int64_t (*)[])(mlib_pcm_alloc(((qc_pcllib_npccode + (int64_t)16) * (int64_t)8)));
    qc_pcllib_linetable = (uint16_t (*)[])(mlib_pcm_allocz((qc_pcllib_npccode * (int64_t)2)));
    qc_pcllib_pcindex = (int64_t)0;
    var_decls_mlineno = (int64_t)0;
    L1640 :;
    for (i=(int64_t)1;i<=(int64_t)217;i+=(int64_t)1) {
L1641 :;
        nn = (int64_t)0;
        L1644 :;
        for (j=(int64_t)1;j<=(int64_t)4;j+=(int64_t)1) {
L1645 :;
            if (((int64_t)((uint64_t)(pq_common_cmdfmt[(i)][(j)-1])) == (int64_t)0)) {
                goto L1647 ;
            };
            ++nn;
L1646 :;
        }L1647 :;
        ;
        qc_pcllib_cmdnopnds[(i)] = nn;
L1642 :;
    }L1643 :;
    ;
}

void qc_pcllib_initpcldata(void) {
    int64_t i;
    int64_t j;
    int64_t nn;
    L1648 :;
    for (i=(int64_t)1;i<=(int64_t)217;i+=(int64_t)1) {
L1649 :;
        nn = (int64_t)0;
        L1652 :;
        for (j=(int64_t)1;j<=(int64_t)4;j+=(int64_t)1) {
L1653 :;
            if (((int64_t)((uint64_t)(pq_common_cmdfmt[(i)][(j)-1])) == (int64_t)0)) {
                goto L1655 ;
            };
            ++nn;
L1654 :;
        }L1655 :;
        ;
        qc_pcllib_cmdnopnds[(i)] = nn;
L1650 :;
    }L1651 :;
    ;
    var_decls_stringtable = (uint8_t * (*)[])(mlib_alloctable((int64_t)150000,(int64_t)8));
    var_decls_stringlentable = (int64_t (*)[])(mlib_alloctable((int64_t)150000,(int64_t)8));
}

void qc_pcllib_initpclgen(void) {
    int64_t i;
    int64_t av_1;
    L1656 :;
    for (i=(int64_t)1;i<=(int64_t)999;i+=(int64_t)1) {
L1657 :;
        qc_pcllib_labeltable[(i)-1] = (i + (int64_t)1);
L1658 :;
    }L1659 :;
    ;
    qc_pcllib_labeltable[((int64_t)1000)-1] = (int64_t)0;
    qc_pcllib_nextfreelabel = (int64_t)1;
}

static void qc_pcllib_writepcl3(int64_t pc) {
    uint8_t str[512];
    byte fmt[4];
    int64_t cmdcode;
    int64_t a;
    int64_t needcomma;
    int64_t i;
    int64_t lineno;
    int64_t *  ptr;
    struct var_decls_strec *  d;
    ptr = &(*qc_pcllib_pccode)[(pc)-1];
    cmdcode = (*ptr++);
    memcpy((void *)(&fmt),(void *)(&pq_common_cmdfmt[(cmdcode)]),(uint64_t)((int64_t)4));
    lineno = (int64_t)((*qc_pcllib_linetable)[(pc)]);
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt((uint8_t*)"#: # ");
    msysnewc_m_print_i64(lineno,(uint8_t*)"5");
    msysnewc_m_print_i64(pc,(uint8_t*)"z5");
    msysnewc_m_print_end();
    ;
    mlib_gs_str(qc_pcllib_pcl,str);
    if ((cmdcode==(int64_t)2)) {
        mlib_gs_str(qc_pcllib_pcl,(uint8_t*)"PROC:");
        d = (struct var_decls_strec *)((*ptr));
        mlib_gs_str(qc_pcllib_pcl,(*d).name);
        mlib_gs_str(qc_pcllib_pcl,(uint8_t*)" ");
        mlib_gs_strint(qc_pcllib_pcl,(*(ptr + (int64_t)1)));
        mlib_gs_strln(qc_pcllib_pcl,(uint8_t*)":");
        return;
    }else if ((cmdcode==(int64_t)3)) {
        mlib_gs_line(qc_pcllib_pcl);
        return;
    };
    if (!!((uint64_t)((*qc_pcllib_labelmap)[(pc)-1]))) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"L#:");
        msysnewc_m_print_i64(pc,NULL);
        msysnewc_m_print_end();
        ;
        mlib_gs_strln(qc_pcllib_pcl,str);
        mlib_gs_str(qc_pcllib_pcl,(uint8_t*)"             ");
    };
    strcpy((int8_t *)(str),(int8_t *)((pq_common_cmdnames[(cmdcode)] + (int64_t)1)));
    a = (int64_t)1;
    if ((cmdcode==(int64_t)69)) {
        a = (int64_t)2;
        strcat((int8_t *)(str),(int8_t *)((uint8_t*)"."));
        strcat((int8_t *)(str),(int8_t *)((pq_common_hostfnnames[((*ptr++))] + (int64_t)5)));
    };
    mlib_gs_leftstr(qc_pcllib_pcl,(uint8_t*)" ",(int64_t)11,(int64_t)45);
    mlib_gs_leftstr(qc_pcllib_pcl,str,(int64_t)23,(int64_t)32);
    mlib_gs_str(qc_pcllib_pcl,(uint8_t*)"     ");
    needcomma = (int64_t)0;
    L1660 :;
    for (i=a;i<=(int64_t)4;i+=(int64_t)1) {
L1661 :;
        if (((int64_t)(fmt[(i)-1])==(int64_t)0)) {
            goto L1663 ;
        } else {
            if (!!(needcomma)) {
                mlib_gs_str(qc_pcllib_pcl,(uint8_t*)", ");
            };
            strcpy((int8_t *)(str),(int8_t *)(qc_pcllib_writepclopnd3((int64_t)(fmt[(i)-1]),(*ptr++),i,cmdcode)));
            mlib_gs_str(qc_pcllib_pcl,str);
            needcomma = (int64_t)1;
        };
L1662 :;
    }L1663 :;
    ;
    mlib_gs_line(qc_pcllib_pcl);
}

static uint8_t * qc_pcllib_writepclopnd3(int64_t fmt,int64_t x,int64_t n,int64_t cmdcode) {
    static uint8_t str[512];
    static uint8_t str2[512];
    struct var_decls_strec *  d;
    uint8_t *  suffix;
    int64_t slen;
    d = (struct var_decls_strec *)(x);
    if ((fmt==(int64_t)0)) {
        return (uint8_t*)"None";
    }else if ((fmt==(int64_t)9) || (fmt==(int64_t)10)) {
        if ((fmt==(int64_t)9)) {
            suffix = (uint8_t*)"i";
        }else if ((fmt==(int64_t)10)) {
            suffix = (uint8_t*)"w";
        } else {
            suffix = (uint8_t*)"";
        };
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_i64(x,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(suffix,NULL);
        msysnewc_m_print_end();
        ;
    }else if ((fmt==(int64_t)11)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_i64(x,NULL);
        msysnewc_m_print_r64(*(double*)&x,NULL);
        msysnewc_m_print_end();
        ;
    }else if ((fmt==(int64_t)12)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"#..#");
        msysnewc_m_print_i64((x & (int64_t)4294967295),NULL);
        msysnewc_m_print_i64((x >> (int64_t)32),NULL);
        msysnewc_m_print_end();
        ;
    }else if ((fmt==(int64_t)13)) {
        slen = (*var_decls_stringlentable)[(x)-1];
        if ((slen >= (int64_t)255)) {
            slen = (int64_t)255;
        };
        memcpy((void *)(str),(void *)((*var_decls_stringtable)[(x)-1]),(uint64_t)(slen));
        str[((slen + (int64_t)1))-1] = (uint64_t)0u;
        qc_lib_convertstring(str,str2);
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"\"#\"");
        msysnewc_m_print_str(str2,NULL);
        msysnewc_m_print_end();
        ;
    }else if ((fmt==(int64_t)1)) {
        strcpy((int8_t *)(str),(int8_t *)((uint8_t*)"["));
        strcat((int8_t *)(str),(int8_t *)(qc_lib_getdottedname(d)));
        strcat((int8_t *)(str),(int8_t *)((uint8_t*)"]"));
    }else if ((fmt==(int64_t)2)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"[#:#]");
        msysnewc_m_print_str(qc_lib_getdottedname(d),NULL);
        msysnewc_m_print_i64((*d).index,NULL);
        msysnewc_m_print_end();
        ;
    }else if ((fmt==(int64_t)3)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"[&#] #");
        msysnewc_m_print_str(qc_lib_getdottedname(d),NULL);
        msysnewc_m_print_i64((*d).index,NULL);
        msysnewc_m_print_end();
        ;
    }else if ((fmt==(int64_t)4)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"[DLL:#]");
        msysnewc_m_print_str(qc_lib_getdottedname(d),NULL);
        msysnewc_m_print_end();
        ;
    }else if ((fmt==(int64_t)7)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((uint8_t*)"GENFIELD:",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_i64(x,NULL);
        msysnewc_m_print_end();
        ;
    }else if ((fmt==(int64_t)6)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((uint8_t*)".",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((*d).name,NULL);
        msysnewc_m_print_end();
        ;
    }else if ((fmt==(int64_t)14)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"T:# <#>");
        msysnewc_m_print_str(var_decls_ttname[(x)],NULL);
        msysnewc_m_print_i64(x,NULL);
        msysnewc_m_print_end();
        ;
    }else if ((fmt==(int64_t)8)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((uint8_t*)"L",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_i64(x,NULL);
        msysnewc_m_print_end();
        ;
    }else if ((fmt==(int64_t)15)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((uint8_t*)"OP:",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(pq_common_cmdnames[(x)],NULL);
        msysnewc_m_print_end();
        ;
    }else if ((fmt==(int64_t)16)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"[Applproc:#:#]");
        msysnewc_m_print_i64(x,NULL);
        msysnewc_m_print_str((*var_decls_applproctable[(x)-1]).name,NULL);
        msysnewc_m_print_end();
        ;
    } else {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((uint8_t*)"<# #>");
        msysnewc_m_print_i64(fmt,NULL);
        msysnewc_m_print_str(pq_common_opndnames[(fmt)],NULL);
        msysnewc_m_print_end();
        ;
    };
    return str;
}

struct mlib_strbuffer * qc_pcllib_writepccode(uint8_t * caption,int64_t n) {
    int64_t cmd;
    int64_t pc;
    int64_t lab;
    mlib_gs_init(qc_pcllib_pcl);
    mlib_gs_str(qc_pcllib_pcl,(uint8_t*)"PROC ");
    mlib_gs_str(qc_pcllib_pcl,caption);
    mlib_gs_str(qc_pcllib_pcl,(uint8_t*)"/MODULE:");
    mlib_gs_str(qc_pcllib_pcl,var_decls_moduletable[(n)].name);
    mlib_gs_str(qc_pcllib_pcl,(uint8_t*)"/");
    mlib_gs_strint(qc_pcllib_pcl,n);
    mlib_gs_str(qc_pcllib_pcl,(uint8_t*)"/");
    mlib_gs_strint(qc_pcllib_pcl,(int64_t)(var_decls_moduletable[(n)].pcindex));
    mlib_gs_strln(qc_pcllib_pcl,(uint8_t*)":");
    mlib_gs_line(qc_pcllib_pcl);
    qc_pcllib_pccode = var_decls_moduletable[(n)].pccode;
    qc_pcllib_pcindex = (int64_t)(var_decls_moduletable[(n)].pcindex);
    pc = (int64_t)1;
    qc_pcllib_linetable = var_decls_moduletable[(n)].linetable;
    qc_pcllib_labelmap = (byte (*)[])(mlib_zalloctable(qc_pcllib_pcindex,(int64_t)1));
    L1664 :;
    while ((pc <= qc_pcllib_pcindex)) {
        cmd = (*qc_pcllib_pccode)[(pc)-1];
        if (((int64_t)((uint64_t)(pq_common_cmdfmt[(cmd)][((int64_t)1)-1])) == (int64_t)8)) {
            lab = (*qc_pcllib_pccode)[((pc + (int64_t)1))-1];
            (*qc_pcllib_labelmap)[(lab)-1] = (uint64_t)((int64_t)1);
        };
        pc += ((int64_t)(qc_pcllib_cmdnopnds[(cmd)]) + (int64_t)1);
L1665 :;
    }L1666 :;
    ;
    pc = (int64_t)1;
    L1667 :;
    while ((pc <= qc_pcllib_pcindex)) {
        cmd = (*qc_pcllib_pccode)[(pc)-1];
        qc_pcllib_writepcl3(pc);
        pc += ((int64_t)(qc_pcllib_cmdnopnds[(cmd)]) + (int64_t)1);
L1668 :;
    }L1669 :;
    ;
    mlib_gs_line(qc_pcllib_pcl);
    return qc_pcllib_pcl;
}

void qc_pcllib_genpc(int64_t opc) {
    if ((qc_pcllib_pcindex >= qc_pcllib_npccode)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((uint8_t*)"PCINDEX=",NULL);
        msysnewc_m_print_i64(qc_pcllib_pcindex,NULL);
        msysnewc_m_print_i64(qc_pcllib_npccode,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        qc_support_gerror((uint8_t*)"pccode overflow",(struct var_decls_unitrec *)(0));
    };
    (*qc_pcllib_pccode)[(++qc_pcllib_pcindex)-1] = opc;
    qc_pcllib_lastopc = &(*qc_pcllib_pccode)[(qc_pcllib_pcindex)-1];
    (*qc_pcllib_linetable)[(qc_pcllib_pcindex)] = (uint64_t)(var_decls_mlineno);
}

void qc_pcllib_genopnd_int(int64_t x) {
    (*qc_pcllib_pccode)[(++qc_pcllib_pcindex)-1] = x;
}

void qc_pcllib_genopnd_s(struct var_decls_strec * d) {
    (*qc_pcllib_pccode)[(++qc_pcllib_pcindex)-1] = (int64_t)(d);
}

void qc_pcllib_genpc_int(int64_t opc,int64_t a) {
    qc_pcllib_genpc(opc);
    (*qc_pcllib_pccode)[(++qc_pcllib_pcindex)-1] = a;
}

void qc_pcllib_genpc_int2(int64_t opc,int64_t a,int64_t b) {
    qc_pcllib_genpc(opc);
    (*qc_pcllib_pccode)[(++qc_pcllib_pcindex)-1] = a;
    (*qc_pcllib_pccode)[(++qc_pcllib_pcindex)-1] = b;
}

void qc_pcllib_genpc_int4(int64_t opc,int64_t a,int64_t b,int64_t c,int64_t d) {
    qc_pcllib_genpc(opc);
    qc_pcllib_genopnd_int(a);
    qc_pcllib_genopnd_int(b);
    qc_pcllib_genopnd_int(c);
    qc_pcllib_genopnd_int(d);
}

void qc_pcllib_genpc_s(int64_t opc,struct var_decls_strec * d) {
    if (((((opc == (int64_t)6) && !!(qc_pcllib_lastopc)) && ((*qc_pcllib_lastopc) == (int64_t)26)) || ((opc == (int64_t)5) && ((*qc_pcllib_lastopc) == (int64_t)25)))) {
        if (((int64_t)(d) == (*qc_pcllib_pccode)[(qc_pcllib_pcindex)-1])) {
            (*qc_pcllib_lastopc) = ((opc == (int64_t)6)?(int64_t)28:(int64_t)27);
            return;
        };
    };
    qc_pcllib_genpc(opc);
    (*qc_pcllib_pccode)[(++qc_pcllib_pcindex)-1] = (int64_t)(d);
}

void qc_pcllib_genpc_str(int64_t opc,uint8_t * s,int64_t length) {
    qc_pcllib_genpc(opc);
    qc_pcllib_genopnd_str(s,length);
}

void qc_pcllib_genopnd_str(uint8_t * s,int64_t length) {
    qc_pcllib_genopnd_int(qc_pcllib_addstringtotable(s,length));
}

void qc_pcllib_genpc_lab(int64_t opc,int64_t a) {
    int64_t lastpc;
    qc_pcllib_genpc(opc);
    if ((a >= (int64_t)0)) {
        (*qc_pcllib_pccode)[(++qc_pcllib_pcindex)-1] = a;
        return;
    };
    a = -(a);
    lastpc = (int64_t)(qc_pcllib_labeltable[(a)-1]);
    (*qc_pcllib_pccode)[(++qc_pcllib_pcindex)-1] = lastpc;
    qc_pcllib_labeltable[(a)-1] = qc_pcllib_pcindex;
}

int64_t qc_pcllib_isframe_s(struct var_decls_strec * p) {
    return (int64_t)((*p).attribs.ax_frame);
}

int64_t qc_pcllib_addstringtotable(uint8_t * s,int64_t length) {
    if ((var_decls_nstrings >= (int64_t)150000)) {
        qc_support_gerror((uint8_t*)"Too many strings",(struct var_decls_unitrec *)(0));
    };
    ++var_decls_nstrings;
    (*var_decls_stringtable)[(var_decls_nstrings)-1] = s;
    (*var_decls_stringlentable)[(var_decls_nstrings)-1] = length;
    return var_decls_nstrings;
}

uint8_t * q_libs_getintlib(uint8_t * name) {
    int64_t i;
    uint8_t *  source;
    uint8_t *  newsource;
    int64_t av_1;
    L1670 :;
    for (i=(int64_t)1;i<=(int64_t)18;i+=(int64_t)1) {
L1671 :;
        if (!!(mlib_eqstring(name,q_libs_libnames[(i)-1]))) {
            source = q_libs_libtext[(i)-1];
            mlib_rfsize = (int64_t)(strlen((int8_t *)(source)));
            newsource = (uint8_t *)(mlib_pcm_alloc((mlib_rfsize + (int64_t)4)));
            memcpy((void *)(newsource),(void *)(source),(uint64_t)(mlib_rfsize));
            (*(newsource + mlib_rfsize)) = (uint64_t)26u;
            (*((newsource + mlib_rfsize) + (int64_t)1)) = (uint64_t)0u;
            return newsource;
        };
L1672 :;
    }L1673 :;
    ;
    return (uint8_t *)(0);
}


/* ********** End of C Code ********** */
