// Generated C
#pragma GCC diagnostic ignored "-Wbuiltin-declaration-mismatch"

extern double sqrt(double);
extern double sin(double);
extern double cos(double);
extern double tan(double);
extern double asin(double);
extern double acos(double);
extern double atan(double);
extern double log(double);
extern double log10(double);
extern double exp(double);
extern double floor(double);
extern double ceil(double);
extern double atan2(double, double);
extern double fmod(double, double);
extern double pow(double, double);

typedef signed char		i8;
typedef short			i16;
typedef int				i32;
typedef long long int	i64;
typedef unsigned char			u8;
typedef unsigned short			u16;
typedef unsigned int			u32;
typedef unsigned long long int	u64;

typedef unsigned char byte;

typedef float r32;
typedef double r64;

extern void exit(i32);
extern void memset(u64, i32, u64);

#define asi8(x)  *(i8*)&x
#define asi16(x) *(i16*)&x
#define asi32(x) *(i32*)&x
#define asi64(x) *(i64*)&x

#define asu8(x)  *(u8*)&x
#define asu16(x) *(u16*)&x
#define asu32(x) *(u32*)&x
#define asu64(x) *(u64*)&x

#define asr32(x) *(r32*)&x
#define asr64(x) *(r64*)&x


#define toi8(x)  (i8)x
#define toi16(x) (i16)x
#define toi32(x) (i32)x
#define toi64(x) (i64)x

#define tou8(x)  (u8)x
#define tou16(x) (u16)x
#define tou32(x) (u32)x
#define tou64(x) (u64)x

#define tor32(x) (r32)x
#define tor64(x) (r64)x


#define toi8p(x)  (i8*)x
#define toi16p(x) (i16*)x
#define toi32p(x) (i32*)x
#define toi64p(x) (i64*)x

#define tou8p(x)  (u8*)x
#define tou16p(x) (u16*)x
#define tou32p(x) (u32*)x
#define tou64p(x) (u64*)x

#define tor32p(x) (r32*)x
#define tor64p(x) (r64*)x


i64 Getdotindex(u64 a, int i);
u64 Setdotindex(u64 a, i64 i, i64 x);
i64 Getdotslice(u64 a, i64 i, i64 j);
u64 Setdotslice(u64 a, i64 i, i64 j, u64 x);
i64 Poweri64(i64 a, i64 n);

#define Min(x, y) (x<=y ? x : y)
#define Max(x, y) (x>=y ? x : y)

i64 ncmdparams;
i64 nenvstrings;
char* (*cmdparams)[];
i64 $cmdskip;

/*
PROC START
*/
void qq_cli_main();
void (*entrypoint)(void) = qq_cli_main;

// ***** Types *****
struct $B1 {u64 a[10];};   // mem:80;
struct $B2 {u16 a[5];};   // mem:10;
struct $B3 {u64 a[2];};   // mem:16;
struct $B4 {u64 a[512];};   // mem:4096;
struct $B5 {u32 a[25];};   // mem:100;
struct $B6 {u64 a[40];};   // mem:320;
struct $B7 {u64 a[301];};   // mem:2408;
struct $B8 {u64 a[3];};   // mem:24;
struct $B9 {u32 a[3];};   // mem:12;
struct $B10 {u8 a[2049];};   // mem:2049;
struct $B11 {u64 a[9];};   // mem:72;
struct $B12 {u64 a[6];};   // mem:48;
struct $B13 {u32 a[9];};   // mem:36;
struct $B14 {u32 a[65];};   // mem:260;
struct $B15 {u32 a[75];};   // mem:300;
struct $B16 {u64 a[32];};   // mem:256;
struct $B17 {u32 a[5];};   // mem:20;
struct $B18 {u64 a[140000];};   // mem:1120000;
struct $B19 {u64 a[1000];};   // mem:8000;
struct $B20 {u64 a[50];};   // mem:400;
struct $B21 {u16 a[25];};   // mem:50;
struct $B22 {u64 a[2000];};   // mem:16000;
struct $B23 {u64 a[250];};   // mem:2000;
struct $B24 {u64 a[256];};   // mem:2048;
struct $B25 {u64 a[64];};   // mem:512;
struct $B26 {u64 a[201];};   // mem:1608;
struct $B27 {u64 a[30];};   // mem:240;
struct $B28 {u64 a[100];};   // mem:800;
struct $B29 {u64 a[23];};   // mem:184;
struct $B30 {u8 a[23];};   // mem:23;
struct $B31 {u64 a[202];};   // mem:1616;
struct $B32 {u64 a[4];};   // mem:32;
struct $B33 {u64 a[524288];};   // mem:4194304;
struct $B34 {u64 a[1];};   // mem:8;
struct $B35 {u64 a[20];};   // mem:160;
struct $B36 {u64 a[12];};   // mem:96;
struct $B37 {u64 a[18];};   // mem:144;
struct $B38 {u16 a[101];};   // mem:202;
struct $B39 {u64 a[101];};   // mem:808;
struct $B40 {u64 a[33];};   // mem:264;
struct $B41 {u64 a[80];};   // mem:640;
struct $B42 {u16 a[3];};   // mem:6;
struct $B43 {u64 a[15];};   // mem:120;
struct $B44 {u64 a[41];};   // mem:328;
struct $B45 {u8 a[41];};   // mem:41;
struct $B46 {u64 a[92];};   // mem:736;
struct $B47 {u32 a[23];};   // mem:92;
struct $B48 {u64 a[132];};   // mem:1056;
struct $B49 {u64 a[27];};   // mem:216;
struct $B50 {u64 a[188];};   // mem:1504;
struct $B51 {u32 a[47];};   // mem:188;
struct $B52 {u64 a[60];};   // mem:480;
struct $B53 {u32 a[15];};   // mem:60;
struct $B54 {u8 a[27];};   // mem:27;
struct $B55 {u8 a[133];};   // mem:133;
struct $B56 {u8 a[7];};   // mem:7;
struct $B57 {u64 a[26];};   // mem:208;
struct $B58 {u32 a[33];};   // mem:132;
struct $B59 {u64 a[251];};   // mem:2008;
struct $B60 {u16 a[251];};   // mem:502;
struct $B61 {u8 a[251];};   // mem:251;
struct $B62 {u64 a[5000];};   // mem:40000;
struct $B63 {u64 a[625];};   // mem:5000;
struct $B64 {u64 a[7];};   // mem:56;
struct $B65 {u64 a[128];};   // mem:1024;
struct $B66 {u64 a[5];};   // mem:40;
struct $B67 {u64 a[13];};   // mem:104;
struct $B68 {u64 a[16];};   // mem:128;
struct $B69 {u8 a[1];};   // mem:0;
struct $B70 {u64 a[2048];};   // mem:16384;
struct $B71 {u64 a[45];};   // mem:360;
struct $B72 {u64 a[320];};   // mem:2560;
struct $B73 {u64 a[200];};   // mem:1600;
struct $B74 {u32 a[125];};   // mem:500;
struct $B75 {u64 a[513];};   // mem:4104;
struct $B76 {u64 a[400];};   // mem:3200;
struct $B77 {u64 a[25];};   // mem:200;
struct $B78 {u64 a[257];};   // mem:2056;

// Function Ptr Types:
typedef i64 (*F1)(u64);
typedef i64 (*F2)();
typedef i64 (*F3)(i64);
typedef i64 (*F4)(i64, i64);
typedef i64 (*F5)(i64, i64, i64);
typedef i64 (*F6)(i64, i64, i64, i64);
typedef i64 (*F7)(i64, i64, i64, i64, i64);
typedef i64 (*F8)(i64, i64, i64, i64, i64, i64);
typedef i64 (*F9)(i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F10)(i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F11)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F12)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F13)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef r64 (*F14)();
typedef r64 (*F15)(i64);
typedef r64 (*F16)(i64, i64);
typedef u64 (*F17)();
typedef void (*F18)();
typedef void (*F19)(u64);
typedef void (*F20)(u64, u64);
typedef void (*F21)(u64, u64, u64);
typedef void (*F22)(u64, u64, u64, u64);
typedef void (*F23)(u64, u64, u64, u64, u64);

// ***** Variables *****
static i64 msysc_fmtparam;
i64 msysc_$cmdskip;
static i64 msysc_needgap;
static i64 msysc_outdev;
static u64 msysc_outchan;
static u64 msysc_fmtstr;
static struct $B1 msysc_outchan_stack;
static struct $B1 msysc_outdev_stack;
static struct $B1 msysc_fmtstr_stack;
static struct $B2 msysc_needgap_stack;
static struct $B1 msysc_ptr_stack;
static i64 msysc_niostack;
static struct $B3 msysc_digits;
static struct $B3 msysc_defaultfmt;
static u64 msysc_rd_buffer;
static i64 msysc_rd_length;
static u64 msysc_rd_pos;
static u64 msysc_rd_lastpos;
static i64 msysc_termchar;
static i64 msysc_itemerror;
static struct $B4 msysc_printbuffer;
static u64 msysc_printptr;
static i64 msysc_printlen;
static i64 msysc_ncmdparams;
static u64 msysc_cmdparams;
static struct $B3 msysc_getfmt_fmt;
static struct $B5 msysc_strint_str;
static struct $B5 msysc_strword_str;
static struct $B6 msysc_strreal_str;
static struct $B7 mlib_allocupper;
static i64 mlib_alloccode;
static i64 mlib_allocbytes;
static i64 mlib_fdebug;
static i64 mlib_rfsize;
static u64 mlib_maxmemory;
static i64 mlib_maxalloccode;
static u8 mlib_pcm_setup;
static i64 mlib_show;
static i64 mlib_memtotal;
static i64 mlib_smallmemtotal;
static i64 mlib_smallmemobjs;
static i64 mlib_maxmemtotal;
static struct $B8 mlib_memalloctable;
static struct $B9 mlib_memallocsize;
static u64 mlib_pcheapstart;
static u64 mlib_pcheapend;
static u64 mlib_pcheapptr;
static struct $B10 mlib_sizeindextable;
static struct $B11 mlib_freelist;
static struct $B12 mlib_pmnames;
static struct $B3 mlib_seed;
static i64 mlib_pcm_newblock_totalheapsize;
static struct $B14 mlib_changeext_newfile;
static struct $B14 mlib_extractpath_str;
static struct $B5 mlib_extractbasefile_str;
static struct $B15 mlib_nextcmdparamnew_str;
static struct $B16 mlib_readnextfileitem_str;
static struct $B16 mlib_padstr_str;
static u64 mlib_chr_str;
static u64 mwindows_hconsole;
static u64 mwindows_hconsolein;
static struct $B17 mwindows_lastkey;
static struct $B17 mwindows_pendkey;
static i64 mwindows_keypending;
static i64 mwindows_hpfreq;
static u64 mwindows_wndproc_callbackfn;
static i64 mwindows_init_flag;
static u8 mwindows_os_gxregisterclass_registered;
static struct $B15 mwindows_os_gethostname_name;
static i64 mwindows_os_gethostname_n;
static i64 mwindows_os_peek_lastticks;
static i64 qq_cli_nalldot;
static i64 qq_cli_nalldot1field;
static u64 qq_cli_syslibname;
static struct $B12 qq_cli_runnames;
static u8 qq_cli_fshowpcl1;
static u8 qq_cli_fshowpcl2;
static u8 qq_cli_fshowast1;
static u8 qq_cli_fshowast2;
static u8 qq_cli_fshowst;
static u8 qq_cli_fshowstflat;
static u8 qq_cli_fshowtypes;
static u8 qq_cli_foptimise;
static u8 qq_cli_fwriteqa;
static u8 qq_cli_fshowmodules;
static u8 qq_cli_fallsp;
static u8 qq_cli_runcode;
static u64 qq_cli_sourcestr;
static u64 qq_cli_inputfile;
static u64 qq_cli_allprocdefs;
static u64 qq_cli_allstaticdefs;
static u64 qq_cli_pclstr;
static i64 qq_cli_cmdstartindex;
static struct $B3 qq_decls_nextlx;
static struct $B3 qq_decls_lx;
static i64 qq_decls_qpos;
static i64 qq_decls_pcerrorpos;
static u64 qq_decls_pcerrormodule;
static struct $B18 qq_decls_varstack;
static u64 qq_decls_sptr;
static u64 qq_decls_stacklimit;
static u64 qq_decls_frameptr;
static u64 qq_decls_pcptr;
static i64 qq_decls_stopped;
static u64 qq_decls_stprogram;
static u64 qq_decls_stmodule;
static u64 qq_decls_stsubprog;
static u64 qq_decls_stcurrmodule;
static u64 qq_decls_stcurrproc;
static u64 qq_decls_currmodule;
static i64 qq_decls_debug;
static i64 qq_decls_inproc;
static struct $B19 qq_decls_genfieldtable;
static i64 qq_decls_ngenfields;
static i64 qq_decls_nlibfiles;
static struct $B20 qq_decls_libtable;
static struct $B21 qq_decls_libtypes;
static struct $B20 qq_decls_dllinsttable;
static i64 qq_decls_ndllprocs;
static struct $B22 qq_decls_dllproctable;
static struct $B23 qq_decls_dllproclibindex;
static struct $B22 qq_decls_dllprocaddr;
static u8 qq_decls_usebundled;
static struct $B12 qq_decls_dispatchnames;
static i64 qq_decls_nqparams;
static struct $B16 qq_decls_qparamtable;
static u64 qq_decls_proclist;
static u64 qq_decls_proclistx;
static i64 qq_decls_nproclist;
static u64 qq_decls_pcl_callbackfn;
static struct $B24 qq_decls_chrtable;
static u8 qq_decls_fnosys;
static u8 qq_decls_fverbose;
static struct $B25 qq_decls_baseclasstable;
static struct $B24 qq_decls_baseclassdef;
static i64 qq_decls_nbaseclasses;
static i64 qq_decls_lastretindex;
static struct $B26 qq_decls_modules;
static struct $B27 qq_decls_subprogs;
static i64 qq_decls_nmodules;
static i64 qq_decls_nsubprogs;
static i64 qq_decls_nalllines;
static struct $B28 qq_decls_qafilenames;
static struct $B28 qq_decls_qatext;
static struct $B28 qq_decls_qasize;
static i64 qq_decls_nqafiles;
static struct $B29 qq_decls_optionnames;
static struct $B29 qq_decls_optionvars;
static struct $B30 qq_decls_optionvalues;
static u64 qq_decls_stopseq;
static u64 qq_decls_raiseseq;
static i64 qq_decls_nproclocals;
static u64 qq_decls_pproclocals;
static struct $B31 qq_decls_pclcounts;
static i64 qq_decls_nallpcl;
static struct $B32 qq_decimal_fpnames;
static i64 qq_decimal_currprec;
static i64 qq_decimal_stblz;
static u64 qq_decimal_constlist;
static i64 qq_decimal_decstrsize;
static struct $B3 qq_decimal_vtemp;
static u8 qq_dicts_expanddict_inuse;
static u64 qq_host_procrefs;
static struct $B16 qq_host_pch_gethostname_name;
static struct $B16 qq_host_pch_getprogname_name;
static i64 qq_host_initprocrefs_oldnprocs;
static u64 qq_lex_lxsource;
static u64 qq_lex_lxstart;
static u64 qq_lex_lxsptr;
static i64 qq_lex_lxifcond;
static i64 qq_lex_longsuffix;
static i64 qq_lex_lxlineno;
static i64 qq_lex_nextlxlength;
static i64 qq_lex_lxlength;
static struct $B33 qq_lex_hashtable;
static u64 qq_lex_hashtablelast;
static u64 qq_lex_u64maxstr;
static struct $B16 qq_lex_namemap;
static i64 qq_lex_lexinit_n;
static i64 qq_lib_currlineno;
static i64 qq_lib_nextavindex;
static struct $B3 qq_lib_exprstrvar;
static u64 qq_lib_exprstr;
static i64 qq_lib_nlocalunits;
static u64 qq_lib_errormess;
static u64 qq_lib_bytemasks;
static struct $B23 qq_lib_convtostringz_strbuffer1;
static struct $B23 qq_lib_convtostringz_strbuffer2;
static struct $B23 qq_lib_convtostringz_strbuffer3;
static struct $B23 qq_lib_convtostringz_strbuffer4;
static struct $B23 qq_lib_convtostringz_strbuffer5;
static struct $B23 qq_lib_convtostringz_strbuffer6;
static u64 qq_lists_emptylist;
static struct $B15 qq_modules_getmodulefilename_str;
static i64 qq_names_sdsize;
static i64 qq_names_sdoffset;
static i64 qq_names_sdaligned;
static i64 qq_names_sdlevel;
static i64 qq_names_sdmode;
static i64 qq_names_sdnfields;
static i64 qq_names_sdmaxalign;
static struct $B2 qq_names_sdunion;
static struct $B1 qq_names_sdmaxsize;
static i64 qq_parse_intabledata;
static u64 qq_parse_tabledataname;
static struct $B1 qq_parse_dollarstack;
static i64 qq_parse_ndollar;
static u8 qq_parse_yieldseen;
static i64 qq_parse_currdllindex;
static i64 qq_parse_nextlambdaindex;
static struct $B35 qq_parse_listtypestack;
static i64 qq_parse_nlisttype;
static i64 qq_parse_listtype;
static i64 qq_parse_addstructflag_structseqno;
static struct $B37 qq_pcltabs_opndnames;
static struct $B31 qq_pcltabs_pclnames;
static struct $B38 qq_pcltabs_pclopnd;
static struct $B39 qq_pcltabs_pclattrs;
static struct $B40 qq_pcltabs_bintotable;
static struct $B41 qq_pclgen_loopstack;
static struct $B35 qq_pclgen_trylevelstack;
static i64 qq_pclgen_loopindex;
static i64 qq_pclgen_looptrylevel;
static i64 qq_pclgen_trylevel;
static i64 qq_pclgen_retindex;
static i64 qq_pclgen_retvaloffset;
static i64 qq_pclgen_nprocparams;
static u64 qq_pclgen_pprocentry;
static i64 qq_pclgen_procskiplabel;
static u64 qq_pcllib_pcstart;
static u64 qq_pcllib_pccurr;
static u64 qq_pcllib_pcend;
static i64 qq_pcllib_pcalloc;
static u64 qq_pcllib_pcsourcestart;
static u64 qq_pcllib_pcsourcecurr;
static i64 qq_pcllib_pclcurrlineno;
static u64 qq_pcllib_labelpctable;
static i64 qq_pcllib_labelalloc;
static i64 qq_pcllib_nextlabelno;
static i64 qq_print_mindev;
static i64 qq_print_moutdev;
static u64 qq_print_minchan;
static u64 qq_print_moutchan;
static struct $B3 qq_print_minvar;
static struct $B3 qq_print_moutvar;
static struct $B8 qq_print_moutdevstack;
static struct $B12 qq_print_moutchanstack;
static struct $B36 qq_print_moutvarstack;
static struct $B42 qq_print_mgapstack;
static struct $B12 qq_print_mfmtstrstack;
static struct $B12 qq_print_mfmtcurrstack;
static i64 qq_print_noclevels;
static u64 qq_print_mfmtstr;
static u64 qq_print_mfmtcurr;
static struct $B3 qq_print_defaultfmt;
static u8 qq_print_mgapneeded;
static u64 qq_print_kb_start;
static u64 qq_print_kb_pos;
static u64 qq_print_kb_lastpos;
static i64 qq_print_kb_size;
static i64 qq_print_kb_linelength;
static i64 qq_print_kb_length;
static i64 qq_print_kb_lastlength;
static u8 qq_print_termchar;
static i64 qq_print_itemerror;
static u64 qq_print_testfilech;
static i64 qq_print_listdepth;
static i64 qq_resolve_nprocs;
static i64 qq_resolve_noexpand;
static i64 qq_resolve_symbolmode;
static i64 qq_resolve_macrolevels;
static i64 qq_resolve_allowmodname;
static struct $B20 qq_resolve_macroparams;
static struct $B20 qq_resolve_macroparamsgen;
static struct $B20 qq_resolve_macroargs;
static i64 qq_resolve_nmacroparams;
static i64 qq_resolve_nmacroargs;
static struct $B28 qq_resolve_structfields;
static i64 qq_resolve_ntopfields;
static i64 qq_resolve_nallfields;
static u64 qq_runx_jumptable;
static u8 qq_runx_getjt;
static i64 qq_runaux_runproc_m_rmsg_typeno;
static struct $B6 qq_runaux_k_map_codeseq;
static u64 qq_strings_emptystring;
static struct $B43 qq_syslibs_syslibnames;
static struct $B43 qq_syslibs_libtext;
static struct $B44 qq_tables_stdtypenames;
static struct $B45 qq_tables_stdtypewidths;
static struct $B46 qq_tables_jtagnames;
static struct $B47 qq_tables_jflags;
static struct $B47 qq_tables_jhasvalue;
static struct $B48 qq_tables_symbolnames;
static struct $B49 qq_tables_namenames;
static struct $B8 qq_tables_objtypenames;
static struct $B8 qq_tables_scopenames;
static struct $B50 qq_tables_stnames;
static struct $B51 qq_tables_stsymbols;
static struct $B51 qq_tables_stsubcodes;
static struct $B52 qq_tables_hostfnnames;
static struct $B53 qq_tables_hostnparams;
static struct $B53 qq_tables_hostisfn;
static struct $B53 qq_tables_hostinternal;
static struct $B52 qq_tables_hosthandlers;
static struct $B54 qq_tables_d_binopset;
static struct $B55 qq_tables_binopset;
static struct $B56 qq_tables_d_unaryopset;
static struct $B55 qq_tables_unaryopset;
static struct $B2 qq_tables_d_addopset;
static struct $B42 qq_tables_d_cmpopset;
static struct $B56 qq_tables_d_mulopset;
static struct $B55 qq_tables_addopset;
static struct $B55 qq_tables_cmpopset;
static struct $B55 qq_tables_mulopset;
static struct $B55 qq_tables_exprendset;
static struct $B57 qq_tables_d_exprstarterset;
static struct $B58 qq_tables_exprstarterset;
static struct $B59 qq_tables_ttname;
static struct $B59 qq_tables_ttnamedef;
static struct $B60 qq_tables_ttbasetype;
static struct $B60 qq_tables_tttarget;
static struct $B59 qq_tables_ttlower;
static struct $B59 qq_tables_ttlength;
static struct $B59 qq_tables_ttlowerexpr;
static struct $B59 qq_tables_ttlengthexpr;
static struct $B59 qq_tables_ttsize;
static struct $B61 qq_tables_ttbitwidth;
static struct $B59 qq_tables_ttfields;
static struct $B61 qq_tables_ttcaligned;
static struct $B59 qq_tables_ttowner;
static i64 qq_tables_ntypes;
static i64 qq_tables_firstusertype;
static i64 qq_tables_nuserxtypes;
static i64 qq_tables_userxtypebase;
static u64 qq_tables_userxmodelist;
static struct $B62 qq_tables_ttnamedefx;
static struct $B62 qq_tables_ttxmap;
static struct $B63 qq_tables_ttxmoduleno;
static struct $B53 qq_tables_hostlvset;
static struct $B64 qq_tables_cvnames;
static struct $B8 qq_tables_loopnames;
static struct $B37 qq_tables_mathsnames;
static struct $B12 qq_tables_condnames;
static struct $B42 qq_tables_revconds;
static u64 qq_show_labelmap;
static i64 qq_show_currlineno;
static u64 qq_show_currpclproc;
static struct $B3 qq_show_pclv;
static u64 qq_show_pcldest;
static struct $B65 qq_show_getprefix_str;
static struct $B66 qq_show_getlineinfok_str;
static struct $B24 qq_show_strmode_str;
static struct $B24 qq_show_istrmode_str;
static i64 qq_showpcl_currlineno;
static u64 qq_showpcl_currpclproc;
static struct $B25 qq_showpcl_writepclopnd_str;
static struct $B25 qq_showpcl_writepclopnd_str2;
static struct $B32 qq_vars_zeroobj;
static i64 $nprocs;
static struct $B34 $procname;
static struct $B34 $procaddr;

// ***** Imported Functions *****
extern u64 malloc(u64 $1);
extern u64 realloc(u64 $1, u64 $2);
extern void free(u64 $1);
extern void memset(u64 $1, i32 $2, u64 $3);
extern void memcpy(u64 $1, u64 $2, u64 $3);
extern void memmove(u64 $1, u64 $2, u64 $3);
extern i32 clock();
extern i32 ftell(u64 $1);
extern i32 fseek(u64 $1, i32 $2, i32 $3);
extern u64 fread(u64 $1, u64 $2, u64 $3, u64 $4);
extern u64 fwrite(u64 $1, u64 $2, u64 $3, u64 $4);
extern i32 getc(u64 $1);
extern i32 ungetc(i32 $1, u64 $2);
extern u64 fopen(u64 a, u64 b);
extern i32 fclose(u64 $1);
extern u64 fgets(u64 $1, i64 $2, u64 $3);
extern i32 remove(u64 $1);
extern i32 rename(u64 $1, u64 $2);
extern i32 getchar();
extern void putchar(i32 $1);
extern void setbuf(u64 $1, u64 $2);
extern i64 strlen(u64 $1);
extern u64 strcpy(u64 $1, u64 $2);
extern i32 strcmp(u64 $1, u64 $2);
extern i32 strncmp(u64 $1, u64 $2, u64 $3);
extern u64 strncpy(u64 $1, u64 $2, u64 $3);
extern i32 memcmp(u64 $1, u64 $2, u64 $3);
extern u64 strcat(u64 $1, u64 $2);
extern i32 tolower(i32 $1);
extern i32 toupper(i32 $1);
extern i32 isalpha(i32 $1);
extern i32 isupper(i32 $1);
extern i32 islower(i32 $1);
extern i32 isalnum(i32 $1);
extern i32 isspace(i32 $1);
extern u64 strstr(u64 $1, u64 $2);
extern i64 atol(u64 $1);
extern i32 atoi(u64 $1);
extern r64 strtod(u64 $1, u64 $2);
extern u64 _strdup(u64 $1);
extern i32 puts(u64 $1);
extern i32 printf(u64 $1, ...);
extern i32 sprintf(u64 $1, u64 $2, ...);
extern i32 sscanf(u64 $1, u64 $2, ...);
extern i32 scanf(u64 $1, ...);
extern i32 rand();
extern void srand(u32 $1);
extern i32 system(u64 $1);
extern i32 fgetc(u64 $1);
extern i32 fputc(i32 $1, u64 $2);
extern i32 fprintf(u64 $1, u64 $2, ...);
extern i32 fputs(u64 $1, u64 $2);
extern i32 feof(u64 $1);
extern i32 getch();
extern i32 _getch();
extern i32 kbhit();
extern i32 _mkdir(u64 $1);
extern i32 mkdir(u64 $1);
extern u64 strchr(u64 $1, i32 $2);
extern i32 _setmode(i32 $1, i32 $2);
extern void _exit(i32 $1);
extern void exit(i32 $1);
extern r64 pow(r64 $1, r64 $2);
extern r64 sin(r64 $1);
extern r64 cos(r64 $1);
extern r64 tan(r64 $1);
extern r64 asin(r64 $1);
extern r64 acos(r64 $1);
extern r64 atan(r64 $1);
extern r64 log(r64 $1);
extern r64 log10(r64 $1);
extern r64 exp(r64 $1);
extern r64 floor(r64 $1);
extern r64 ceil(r64 $1);
extern void qsort(u64 $1, u64 $2, u64 $3, u64 $4);
extern i32 __getmainargs(u64 $1, u64 $2, u64 $3, i64 $4, u64 $5);
extern u64 GetStdHandle(u32 $1);
extern i64 GetConsoleScreenBufferInfo(u64 $1, u64 $2);
extern i64 SetConsoleCtrlHandler(u64 $1, i64 $2);
extern i64 SetConsoleMode(u64 $1, u32 $2);
extern i64 CreateProcessA(u64 $1, u64 $2, u64 $3, u64 $4, i64 $5, u32 $6, u64 $7, u64 $8, u64 $9, u64 $10);
extern u32 GetLastError();
extern u32 WaitForSingleObject(u64 $1, u32 $2);
extern i64 GetExitCodeProcess(u64 $1, u64 $2);
extern i64 CloseHandle(u64 $1);
extern i64 GetNumberOfConsoleInputEvents(u64 $1, u64 $2);
extern i64 FlushConsoleInputBuffer(u64 $1);
extern u64 LoadLibraryA(u64 $1);
extern u64 GetProcAddress(u64 $1, u64 $2);
extern u64 LoadCursorA(u64 $1, u64 $2);
extern u32 RegisterClassExA(u64 $1);
extern i64 DefWindowProcA(u64 $1, u32 $2, u64 $3, u64 $4);
extern i64 ReadConsoleInputA(u64 $1, u64 $2, u32 $3, u64 $4);
extern void Sleep(u32 $1);
extern u32 GetModuleFileNameA(u64 $1, u64 $2, u32 $3);
extern void ExitProcess(u32 $1);
extern void PostQuitMessage(i32 $1);
extern void MessageBoxA(i32 x, u64 message, u64 caption, i32 y);
extern u32 QueryPerformanceCounter(u64 $1);
extern u32 QueryPerformanceFrequency(u64 $1);
extern u64 CreateFileA(u64 $1, u32 $2, u32 $3, u64 $4, u32 $5, u32 $6, u64 $7);
extern u32 GetFileTime(u64 $1, u64 $2, u64 $3, u64 $4);
extern void GetSystemTime(u64 $1);
extern void GetLocalTime(u64 $1);
extern u64 GetTickCount64();
extern u32 PeekMessageA(u64 $1, u64 $2, u32 $3, u32 $4, u32 $5);
extern u64 GetCommandLineA();
extern u64 VirtualAlloc(u64 $1, u32 $2, u32 $3, u32 $4);
extern u32 VirtualProtect(u64 $1, u32 $2, u32 $3, u64 $4);
extern u32 WriteConsoleA(u64 $1, u64 $2, i32 $3, u64 $4, u64 $5);
extern u64 FindFirstFileA(u64 $1, u64 $2);
extern u32 FindNextFileA(u64 $1, u64 $2);
extern u32 FindClose(u64 $1);
extern u32 MessageBeep(i32 $1);
extern u32 Beep(i32 freq, i32 dur);

// ***** Function Declarations *****
static u64 msysc_getfmt(u64 fmtstyle);
static u64 msysc_strint(i64 a, u64 fmtstyle);
static u64 msysc_strword(u64 a, u64 fmtstyle);
static u64 msysc_strreal(r64 a, u64 fmtstyle);
static u64 mlib_pcm_newblock(i64 itemsize);
static i64 mlib_pcm_round(i64 n);
static u64 mlib_changeext(u64 s, u64 newext);
static u64 mlib_extractpath(u64 s);
static u64 mlib_extractbasefile(u64 s);
static i64 mlib_nextcmdparamnew(u64 paramno, u64 name, u64 value, u64 defext);
static i64 mlib_readnextfileitem(u64 fileptr, u64 item);
static u64 mlib_padstr(u64 s, i64 width, u64 padchar);
static u64 mlib_chr(i64 c);
static void mwindows_os_gxregisterclass(u64 classname);
static i64 mwindows_mainwndproc(u64 hwnd, u32 message, u64 wparam, u64 lparam);
static u64 mwindows_os_gethostname();
static void mwindows_os_peek();
static void qq_dicts_expanddict(u64 vd);
static void qq_host_pch_gethostname(u64 result);
static void qq_host_pch_getprogname(u64 result);
static void qq_host_initprocrefs();
static void qq_lex_lexinit();
static u64 qq_lib_convtostringz(u64 svalue, i64 length);
static u64 qq_modules_getmodulefilename(u64 path, u64 name);
static u64 qq_modules_loadstring(u64 name, u64 source);
static void qq_parse_addstructflag(u64 owner, i64 id);
static u64 qq_parse_readcompilervar();
static void qq_vars_var_add(u64 a, u64 b);
static void qq_vars_var_addmixed(u64 a, u64 b);
static void qq_vars_var_sub(u64 a, u64 b);
static void qq_vars_var_submixed(u64 a, u64 b);
static void qq_vars_var_mul(u64 a, u64 b);
static void qq_vars_var_mulmixed(u64 a, u64 b);
static void qq_vars_var_div(u64 a, u64 b);
static void qq_vars_var_divmixed(u64 a, u64 b);
static void qq_vars_var_iand(u64 a, u64 b);
static void qq_vars_var_ior(u64 a, u64 b);
static void qq_vars_var_ixor(u64 a, u64 b);
static void qq_vars_var_min(u64 a, u64 b);
static void qq_vars_var_max(u64 a, u64 b);
static void qq_vars_var_shl(u64 a, u64 b);
static void qq_vars_var_shr(u64 a, u64 b);
static void qq_runx_disploop();
static i64 qq_runaux_runproc_m(u64 amsg);
static u64 qq_runaux_k_map(u64 sp, u64 pc, u64 newsp);
static void qq_sets_var_make_set(u64 data, u64 dest, i64 n);
static i64 qq_sets_var_in_set(u64 a, u64 b);
static void qq_print_pch_startprint(u64 p);
static void qq_print_pch_startprintcon();
static void qq_print_pch_strstartprint();
static void qq_print_pch_setformat(u64 p);
static void qq_print_pch_endprint();
static void qq_print_pch_strendprint(u64 dest);
static void qq_print_pch_print(u64 p, u64 fmt);
static void qq_print_pch_print_nf(u64 p);
static void qq_print_pch_println();
static void qq_print_pch_printnogap();
static void qq_print_pch_printspace();
static void qq_print_pch_readln(u64 dev);
static void qq_print_pch_sreadln(u64 dev, u64 dest);
static void qq_print_pch_sread(u64 fmt, u64 dest);
static void qq_print_pch_rereadln();
static void qq_print_pch_reread();
static void qq_print_pch_strtoval(u64 p, u64 fmt, u64 dest);
static void qq_print_pch_tostr(u64 a, u64 b, u64 result);
static void qq_host_pch_leftstr(u64 a, u64 b, u64 c, u64 result);
static void qq_host_pch_rightstr(u64 a, u64 b, u64 c, u64 result);
static void qq_host_pch_convlc(u64 a, u64 b, u64 result);
static void qq_host_pch_convuc(u64 a, u64 b, u64 result);
static void qq_host_pch_waitkey(u64 result);
static void qq_host_pch_testkey(u64 result);
static void qq_host_pch_execwait(u64 a, u64 b, u64 c, u64 result);
static void qq_host_pch_execcmd(u64 a, u64 b, u64 c, u64 result);
static void qq_host_pch_system(u64 a, u64 result);
static void qq_host_pch_makestr(u64 a, u64 b, u64 result);
static void qq_host_pch_makeref(u64 a, u64 b, u64 result);
static void qq_host_pch_new(u64 a, u64 b, u64 c, u64 d, u64 result);
static void qq_host_pch_getcmdparam(u64 a, u64 result);
static void qq_host_pch_$setdebug(u64 a);
static void qq_host_pch_$test2(u64 a, u64 result);
static void qq_host_pch_$test(u64 a, u64 b, u64 c, u64 result);
static void qq_host_pch_$refcount(u64 a, u64 result);
static void qq_host_pch_ticks(u64 result);
static void qq_host_pch_clock(u64 result);
static void qq_host_pch_sleep(u64 a);
static void qq_host_pch_random(u64 a, u64 result);
static void qq_host_pch_gethash(u64 a, u64 result);
static void qq_host_pch_getos(u64 result);
static void qq_host_pch_iswindows(u64 result);
static void qq_host_pch_setmesshandler(u64 fn);
static void qq_host_pch_$getparam(u64 a, u64 result);
static void qq_host_pch_makeempty(u64 a, u64 result);
static void qq_host_pch_$smallmemtotal(u64 result);
static void qq_host_pch_$id(u64 a, u64 result);
static void qq_host_pch_copy(u64 a, u64 dest);
static void qq_host_pch_$nan(u64 dest);
static void qq_host_pch_$infinity(u64 dest);
static void qq_host_pch_$nprocs(u64 result);
static void qq_host_pch_$procname(u64 a, u64 result);
static void qq_host_pch_$procref(u64 a, u64 result);
static void qq_host_pch_allocexec(u64 a, u64 result);
static void qq_host_pch_runnative(u64 a, u64 b, u64 result);
static void qq_host_pch_setlwb(u64 a, u64 b);
static u64 qq_show_getprefix(i64 level, u64 prefix, u64 p);
static u64 qq_show_getlineinfok();
static void qq_show_showmoduleinfo(u64 dev);
static u64 qq_show_strmode(i64 t, i64 expand);
static void qq_show_istrmode(i64 t, u64 dest, i64 expand);
static u64 qq_showpcl_writepclopnd(u64 pcstart, u64 pc, i64 pass);
static void msysc_$getcommands(i64 ncmd, u64 cmds, i64 cmdskipl);
static void msysc_m$print_startcon();
static void msysc_m$print_str_nf(u64 s);
static void msysc_m$print_i64_nf(i64 a);
static void msysc_m$print_newline();
static void msysc_m$print_end();
static void msysc_pushio();
static void msysc_m$print_startfile(u64 dev);
static void msysc_resetprintbuffer();
static void msysc_m$print_startstr(u64 s);
static void msysc_m$print_startptr(u64 p);
static void msysc_m$print_setfmt(u64 format);
static void msysc_nextfmtchars(i64 lastx);
static void msysc_dumpprintbuffer();
static void msysc_m$print_ptr(u64 a, u64 fmtstyle);
static void msysc_m$print_u64(u64 a, u64 fmtstyle);
static void msysc_m$print_ptr_nf(u64 a);
static void msysc_m$print_i64(i64 a, u64 fmtstyle);
static i64 msysc_u64tostr(u64 aa, u64 s, u64 base, i64 sep);
static void msysc_printstr_n(u64 s, i64 n);
static void msysc_strtofmt(u64 s, i64 slen, u64 fmt);
static void msysc_tostr_i64(i64 a, u64 fmt);
static void msysc_m$print_bool(i64 a, u64 fmtstyle);
static void msysc_m$print_str(u64 s, u64 fmtstyle);
static void msysc_printstr(u64 s);
static void msysc_tostr_u64(u64 a, u64 fmt);
static void msysc_m$print_r64(r64 x, u64 fmtstyle);
static void msysc_tostr_r64(r64 x, u64 fmt);
static void msysc_m$print_r32(r32 x, u64 fmtstyle);
static void msysc_m$print_c8(i64 a, u64 fmtstyle);
static i64 msysc_domultichar(u64 p, i64 n, u64 dest, u64 fmt);
static i64 msysc_getutfsize(u64 s);
static void msysc_tostr_str(u64 s, i64 oldlen, u64 fmt);
static void msysc_m$print_strn(u64 s, i64 length, u64 fmtstyle);
static void msysc_m$print_strsl(struct $B3 s, u64 fmtstyle);
static void mlib_abortprogram(u64 s);
static void msysc_m$print_nogap();
static void msysc_m$print_space();
static void msysc_dumpstr(u64 s, i64 n, i64 fbuffer);
static void msysc_printstrn_app(u64 s, i64 length, u64 f);
static void msysc_printchar(i64 ch);
static i64 msysc_expandstr(u64 s, u64 t, i64 n, u64 fmt);
static i64 msysc_i64tostrfmt(i64 aa, u64 s, u64 fmt);
static i64 msysc_i64mintostr(u64 s, i64 base, i64 sep);
static u64 mlib_convlcstring(u64 s);
static i64 msysc_u64tostrfmt(i64 aa, u64 s, u64 fmt);
static i64 msysc_strtostrfmt(u64 s, u64 t, i64 n, u64 fmt);
static u64 mlib_pcm_alloc(i64 n);
static u64 mlib_convucstring(u64 s);
static void mlib_pcm_free(u64 p, i64 n);
static u64 msysc_getstr(u64 s, u64 fmt);
static void msysc_getstrint(i64 a, u64 dest);
static u64 mlib_pcm_copyheapstring(u64 s);
static void msysc_initreadbuffer();
static void msysc_m$read_conline();
static void mlib_readlinen(u64 handlex, u64 buffer, i64 size);
static void msysc_m$read_fileline(u64 f);
static void msysc_m$read_strline(u64 s);
static u64 msysc_readitem(u64 itemlength);
static i64 msysc_strtoint(u64 s, i64 length, u64 base);
static i64 msysc_m$read_i64(i64 fmt);
static r64 msysc_m$read_r64(i64 fmt);
static void msysc_m$read_str(u64 dest, i64 destlen, i64 fmt);
static void mlib_iconvlcn(u64 s, i64 n);
static void msysc_readstr(u64 dest, i64 fmt, i64 destlen);
static void msysc_rereadln();
static void msysc_reread();
static i64 msysc_valint(u64 s, i64 fmt);
static r64 msysc_valreal(u64 s);
static void msysc_mclunimpl(u64 mess);
static void msysc_addtobuffer(u64 s, i64 n);
static i64 msysc_m$sign_i64(i64 a);
static r64 msysc_m$sign_r64(r64 x);
static void mlib_pcm_init();
static i64 mlib_pcm_getac(i64 size);
static u64 mlib_allocmem(i64 n);
static void mlib_pcm_freeac(u64 p, i64 alloc);
static void mlib_pcm_clearmem(u64 p, i64 n);
static u64 mlib_pcm_allocz(i64 n);
static u64 mlib_pcm_copyheapstringn(u64 s, i64 n);
static u64 mlib_pcm_copyheapblock(u64 s, i64 length);
static u64 mlib_reallocmem(u64 p, i64 n);
static i64 mlib_getfilesize(u64 handlex);
static void mlib_readrandom(u64 handlex, u64 memx, i64 offset, i64 size);
static i64 mlib_writerandom(u64 handlex, u64 memx, i64 offset, i64 size);
static i64 mlib_setfilepos(u64 file, i64 offset);
static i64 mlib_getfilepos(u64 file);
static u64 mlib_readfile(u64 filename);
static i64 mlib_writefile(u64 filename, u64 data, i64 size);
static i64 mlib_checkfile(u64 file);
static u64 mwindows_os_getstdin();
static void mlib_iconvucn(u64 s, i64 n);
static u64 mlib_extractext(u64 s, i64 period);
static u64 mlib_extractfile(u64 s);
static u64 mlib_addext(u64 s, u64 newext);
static u64 mlib_pcm_alloc32();
static void mlib_pcm_free32(u64 p);
static void mlib_outbyte(u64 f, i64 x);
static void mlib_outu16(u64 f, u64 x);
static void mlib_outu32(u64 f, u64 x);
static void mlib_outu64(u64 f, u64 x);
static void mlib_outstring(u64 f, u64 s);
static void mlib_outblock(u64 f, u64 p, i64 n);
static i64 mlib_myeof(u64 f);
static void mlib_strbuffer_add(u64 dest, u64 s, i64 n);
static void mlib_gs_init(u64 dest);
static void mlib_gs_free(u64 dest);
static void mlib_gs_str(u64 dest, u64 s);
static void mlib_gs_char(u64 dest, i64 c);
static void mlib_gs_strn(u64 dest, u64 s, i64 length);
static void mlib_gs_strvar(u64 dest, u64 s);
static void mlib_gs_strint(u64 dest, i64 a);
static void mlib_gs_strln(u64 dest, u64 s);
static void mlib_gs_line(u64 dest);
static void mlib_gs_strsp(u64 dest, u64 s);
static i64 mlib_gs_getcol(u64 dest);
static void mlib_gs_leftstr(u64 dest, u64 s, i64 w, i64 padch);
static void mlib_gs_leftint(u64 dest, i64 a, i64 w, i64 padch);
static void mlib_gs_padto(u64 dest, i64 col, i64 ch);
static void mlib_gs_println(u64 dest, u64 f);
static i64 mlib_eqstring(u64 s, u64 t);
static void mlib_ipadstr(u64 s, i64 width, u64 padchar);
static i64 mlib_cmpstring(u64 s, u64 t);
static i64 mlib_cmpstringn(u64 s, u64 t, i64 n);
static i64 mlib_cmpbytes(u64 p, u64 q, i64 n);
static i64 mlib_eqbytes(u64 p, u64 q, i64 n);
static void mlib_mseed(u64 a, u64 b);
static u64 mlib_mrandom();
static i64 mlib_mrandomp();
static i64 mlib_mrandomint(i64 n);
static i64 mlib_mrandomrange(i64 a, i64 b);
static r64 mlib_mrandomreal();
static r64 mlib_mrandomreal1();
static u64 mlib_readline();
static u64 mlib_findfunction(u64 name);
static i64 mlib_roundtoblock(i64 n, i64 align);
static u64 mlib_pcm_allocnfz(i64 n);
static void mwindows_os_init();
static i64 mwindows_os_execwait(u64 cmdline, i64 newconsole, u64 workdir);
static i64 mwindows_os_execcmd(u64 cmdline, i64 newconsole);
static i64 mwindows_os_getch();
static i64 mwindows_os_getchx();
static i64 mwindows_os_kbhit();
static u64 mwindows_os_getdllinst(u64 name);
static u64 mwindows_os_getdllprocaddr(i64 hinst, u64 name);
static void mwindows_os_initwindows();
static void mwindows_os_setmesshandler(u64 addr);
static u64 mwindows_os_getos();
static i64 mwindows_os_gethostsize();
static i64 mwindows_os_shellexec(u64 opc, u64 file);
static void mwindows_os_sleep(i64 a);
static u64 mwindows_os_getstdout();
static u64 mwindows_os_getmpath();
static i64 mwindows_os_clock();
static i64 mwindows_os_hpcounter();
static i64 mwindows_os_ticks();
static i64 mwindows_os_iswindows();
static void mwindows_os_getsystime(u64 tm);
static u64 mwindows_os_allocexecmem(i64 n);
static i64 mwindows_dirlist(u64 filespec, u64 dest, i64 capacity, i64 t);
static i64 mwindows_os_hpfreq();
static u64 mwindllc_os_calldllfunction(u64 fnaddr, i64 retcode, i64 nargs, u64 args, u64 argcodes);
static i64 mwindllc_calldll_cint(u64 fnaddr, u64 params, i64 nparams);
static i64 mwindllc_calldll_creal(u64 fnaddr, u64 params, i64 nparams);
static u64 mwindllc_os_pushargs(u64 args, i64 nargs, i64 nextra, u64 fnaddr, i64 isfloat);
static void mwindllc_os_dummycall(r64 a, r64 b, r64 c, r64 d);
void qq_cli_main();
static void qq_cli_start();
static void qq_cli_initdata();
static void qq_cli_getinputoptions();
static void qq_modules_readqabundle();
static void qq_cli_loadsyslib();
static void qq_cli_compile_sp(u64 filename, u64 source);
static void qq_show_showast(u64 sp, u64 file);
static void qq_cli_writeqafile();
static i64 qq_runx_runqprogram(u64 sp, i64 ismain);
static void qq_show_showlogfile();
static void qq_cli_do_option(i64 sw, u64 value);
static void qq_lib_loaderror(u64 mess, u64 mess2);
static void qq_cli_setcli(u64 cmds, i64 ncmds);
static u64 qq_modules_loadsp(u64 filename, u64 source);
static void qq_parse_parsemodule(u64 pm);
static void qq_resolve_fixusertypes();
static void qq_resolve_tx_typetable();
static void qq_resolve_rx_module(u64 pm);
static void qq_pclgen_gencodemodule(u64 sp, i64 moduleno);
static void qq_showpcl_showpcl(u64 sp, i64 pass);
static void qq_cli_fixup_sp(u64 sp);
static void qq_cli_resetcompiler();
static void qq_cli_setcmdparam(i64 index, u64 s);
static u64 qq_lex_addnamestr(u64 name);
static u64 qq_names_createdupldef(u64 owner, u64 symptr, i64 id);
static void qq_show_deletetempfiles();
static void qq_cli_fixupmodule(u64 pm);
static void qq_cli_optimise_module(u64 pm);
static void qq_runx_fixupcode(u64 pm);
static void qq_cli_fixproc(u64 d);
static u64 qq_strings_obj_make_string(u64 s, i64 mutable);
static u64 qq_cli_optim(u64 pc);
static void qq_arrays_var_empty_array(i64 tag, i64 elemtype, i64 lower, u64 dest);
static u64 qq_arrays_obj_newarray(i64 elemtype, i64 lower, i64 length);
static void qq_arrays_obj_free_array(u64 p);
static void qq_arrays_obj_free_vector(u64 p);
static void qq_arrays_var_make_array(u64 a, u64 dest, i64 lower, i64 n, i64 axtype, i64 elemtype);
static void qq_runaux_pcerror(u64 mess, u64 param);
static void qq_packed_var_storepacked(u64 p, u64 q, i64 t);
static u64 qq_vars_obj_new();
static u64 qq_arrays_obj_newarray_u(i64 usertag);
static void qq_arrays_var_getix_array(u64 a, i64 index);
static void qq_packed_var_loadpacked(u64 p, i64 t, u64 dest, u64 ownerobj);
static void qq_arrays_var_putix_array(u64 a, i64 index, u64 x);
static void qq_arrays_obj_append_array(u64 a, u64 x);
static void qq_arrays_var_getixref_array(u64 a, i64 index);
static void qq_lib_pcnotmut();
static void qq_arrays_obj_resize_array(u64 p, i64 n);
static void qq_arrays_var_appendto_array(u64 a, u64 x);
static void qq_arrays_var_dupl_array(u64 a);
static void qq_arrays_var_dupl_vector(u64 a);
static i64 qq_arrays_var_equal_array(u64 a, u64 b);
static void qq_arrays_var_concatto_array(u64 a, u64 b);
static void qq_arrays_var_getslice_array(u64 a, i64 i, i64 j);
static void qq_vars_obj_shareu(u64 p);
static i64 qq_arrays_u8inarray(u8 a, u64 p);
static i64 qq_arrays_u16inarray(u16 a, u64 p);
static i64 qq_arrays_u32inarray(u32 a, u64 p);
static i64 qq_arrays_u64inarray(u64 a, u64 p);
static i64 qq_arrays_var_inx_array(u64 a, u64 b, i64 usertag);
static void qq_runaux_pcustype(u64 mess, u64 x);
static void qq_arrays_var_expand_array(u64 p, u64 dest, i64 m);
static void qq_bits_obj_free_bits(u64 p, i64 tag);
static i64 qq_bits_getbitssize(i64 n, i64 t);
static void qq_bits_var_make_bits(u64 a, u64 dest, i64 lower, i64 n, i64 bxtype, i64 elemtype);
static u64 qq_bits_obj_newbits(i64 elemtype, i64 lower, i64 length);
static void qq_vars_var_storebit(u64 p, i64 shift, u64 q, i64 t, i64 bitlength);
static void qq_bits_var_getix_bits(u64 a, i64 index);
static void qq_runaux_pcustype_t(u64 mess, i64 t);
static void qq_bits_var_putix_bits(u64 a, i64 index, u64 x);
static void qq_bits_obj_append_bits(u64 a, u64 x);
static u64 qq_bits_getindexoffset(u64 p, i64 offset, i64 index, i64 t, u64 newoffset);
static void qq_bits_var_getixref_bits(u64 a, i64 index);
static void qq_bits_obj_resize_bits(u64 p, i64 n);
static void qq_bits_var_appendto_bits(u64 a, u64 x);
static i64 qq_bits_bits_bytesize(u64 p);
static void qq_bits_var_dupl_bits(u64 a);
static i64 qq_bits_var_equal_bits(u64 a, u64 b);
static void qq_bits_var_concatto_bits(u64 a, u64 b);
static void qq_bits_var_getslice_bits(u64 a, i64 i, i64 j);
static void qq_calldll_calldll(u64 d, u64 args, u64 result, i64 nargs);
static u64 qq_calldll_vartopacked(u64 p, u64 d);
static u64 qq_calldll_getlibprocaddr(u64 d);
static void qq_calldll_packedtovar(u64 retval, i64 t, u64 dest);
static u64 qq_calldll_loaddllfunction(u64 d);
static void qq_runaux_pcmxtypestt(u64 mess, i64 t, i64 u);
static void qq_strings_var_make_string(u64 s, u64 dest, i64 mutable);
static void qq_decimal_obj_free_dec(u64 p);
static void qq_decimal_var_dupl_dec(u64 a);
static void qq_decimal_var_empty_dec(u64 dest);
static u64 qq_decimal_makebignum(i64 length);
static void qq_decimal_var_make_dec_str(u64 s, i64 length, u64 dest);
static u64 qq_decimal_bn_makestr(u64 s, i64 length);
static void qq_decimal_var_make_dec_int(i64 a, u64 dest);
static u64 qq_decimal_bn_makeint(i64 x);
static u64 qq_decimal_badnumber();
static i64 qq_decimal_readexpon(u64 s);
static i64 qq_decimal_strvaln(u64 s, i64 n);
static u64 qq_decimal_var_tostr_dec(u64 a, i64 fmt);
static u64 qq_decimal_obj_tostr_dec(u64 a, i64 fmt);
static i64 qq_decimal_bn_isint(u64 a);
static u64 qq_decimal_tostring_scient(u64 a);
static u64 qq_decimal_tostring_float(u64 a, i64 fmt);
static i64 qq_decimal_obj_len_dec(u64 a);
static i64 qq_decimal_bn_getprec(u64 a);
static i64 qq_decimal_bn_iszero(u64 a);
static i64 qq_decimal_var_equal_dec(u64 a, u64 b);
static i64 qq_decimal_bn_equal(u64 a, u64 b);
static void qq_decimal_var_add_dec(u64 a, u64 b);
static u64 qq_decimal_bn_init();
static i64 qq_decimal_bn_add(u64 dest, u64 a, u64 b);
static void qq_decimal_var_sub_dec(u64 a, u64 b);
static i64 qq_decimal_bn_sub(u64 dest, u64 a, u64 b);
static void qq_decimal_var_mul_dec(u64 a, u64 b);
static i64 qq_decimal_bn_mul(u64 dest, u64 a, u64 b);
static void qq_decimal_var_div_dec(u64 a, u64 b);
static i64 qq_decimal_bn_div(u64 dest, u64 a, u64 b, i64 prec);
static void qq_decimal_var_idiv_dec(u64 a, u64 b);
static i64 qq_decimal_bn_idiv(u64 dest, u64 a, u64 b);
static void qq_decimal_var_irem_dec(u64 a, u64 b);
static i64 qq_decimal_bn_irem(u64 dest, u64 a, u64 b);
static void qq_decimal_var_neg_dec(u64 a);
static void qq_decimal_bn_negto(u64 a);
static void qq_decimal_var_abs_dec(u64 a);
static void qq_decimal_bn_absto(u64 a);
static i64 qq_decimal_var_compare_dec(u64 a, u64 b);
static i64 qq_decimal_bn_cmp(u64 a, u64 b);
static i64 qq_decimal_getbintype(u64 a, u64 b);
static void qq_decimal_bn_setzero(u64 a);
static void qq_decimal_bn_dupl(u64 a, u64 b);
static void qq_decimal_bn_setnan(u64 dest);
static void qq_decimal_bn_addu(u64 dest, u64 a, u64 b);
static void qq_decimal_bn_subu(u64 dest, u64 a, u64 b);
static u64 qq_decimal_makesmallnum(i64 length);
static void qq_decimal_freesmall(u64 p, i64 length);
static u64 qq_decimal_smalltobig(u64 c, u64 a, i64 length, i64 alloc, i64 offset);
static void qq_decimal_bn_move(u64 a, u64 b);
static void qq_decimal_bn_setinf(u64 dest);
static void qq_decimal_var_setnan(u64 dest);
static void qq_decimal_var_setinf(u64 dest);
static void qq_decimal_bn_mulu(u64 dest, u64 a, u64 b);
static i64 qq_decimal_bn_mulp(u64 dest, u64 a, u64 b, i64 prec);
static void qq_decimal_bn_setprec(u64 a, i64 prec);
static i64 qq_decimal_smallmulto(u64 p, u64 q, i64 plen, i64 m);
static void qq_decimal_bn_fdivu(u64 dest, u64 a, u64 b, i64 precision);
static void qq_decimal_bn_idivu(u64 dest, u64 a, u64 b, u64 rm);
static i64 qq_decimal_bn_idivrem(u64 dest, u64 rm, u64 a, u64 b);
static i64 qq_decimal_smalldiv(u64 x, u64 b, u64 xlen, i64 nb);
static i64 qq_decimal_smallsubto(u64 p, u64 q, i64 plen, i64 qlen);
static i64 qq_decimal_bn_getglobalprec();
static void qq_decimal_bn_setglobalprec(i64 prec);
static u64 qq_decimal_bn_makefloat(r64 x);
static u64 qq_decimal_dectemp(u64 a);
static void qq_decimal_freedectemp();
static void qq_decimal_bn_ipower(u64 d, u64 a, i64 n);
static void qq_decimal_var_power_dec(u64 a, i64 n);
static i64 qq_decimal_var_convert_dec_int(u64 a);
static i64 qq_decimal_bn_toint(u64 a);
static void qq_dicts_var_make_dict(u64 a, u64 dest, i64 n);
static u64 qq_dicts_obj_new_dict(i64 n);
static void qq_dicts_adddictitem(u64 d, u64 p, u64 q);
static i64 qq_lib_nextpoweroftwo(i64 x);
static u64 qq_lists_obj_newlist(i64 n, i64 lower, u64 defval);
static void qq_dicts_obj_free_dict(u64 p, i64 internal);
static void qq_vars_var_unshareu(u64 p);
static void qq_dicts_var_dupl_dict(u64 a);
static void qq_vars_var_duplu(u64 a);
static i64 qq_dicts_var_equal_dict(u64 x, u64 y);
static u64 qq_dicts_var_finddictitem(u64 vd, u64 p, i64 doins);
static i64 qq_vars_var_gethashvalue(u64 p);
static i64 qq_records_var_equal_record(u64 x, u64 y);
static void qq_vars_var_objtovar(i64 tag, u64 p, u64 q);
static u64 qq_host_callhostfunction(i64 hostfn, u64 sp);
static void qq_strings_var_empty_string(u64 dest, i64 mutable);
static void qq_host_leftstring(u64 a, i64 n, u64 result);
static void qq_host_padstring_right(u64 a, i64 n, i64 fillchar, u64 result);
static void qq_host_rightstring(u64 a, i64 n, u64 result);
static void qq_host_padstring_left(u64 a, i64 n, i64 fillchar, u64 result);
static i64 qq_host_checkparam(u64 p, i64 tag, i64 defaultx);
static void qq_strings_var_iconvcase(u64 a, u64 b, i64 upper);
static i64 qq_vars_var_getintvalue(u64 p);
static u64 qq_strings_obj_make_strslicexobj(u64 s, i64 length);
static void qq_strings_var_make_stringn(u64 s, i64 length, u64 dest, i64 mutable);
static void qq_strings_var_new_stringn(i64 length, u64 dest);
static void qq_host_getbounds(u64 p, u64 dims, i64 lower);
static void qq_strings_var_new_string(u64 a, u64 b, u64 dest);
static u64 qq_sets_obj_newset(i64 length);
static u64 qq_records_obj_new_record(i64 m, u64 defval);
static void qq_vars_var_fromobj(i64 tag, u64 p, u64 dest);
static u64 qq_packed_obj_new_struct(i64 m);
static void qq_lists_var_empty_list(i64 lower, u64 dest);
static void qq_host_setcmdparam(i64 index, u64 s);
static void qq_lex_lexreadtoken();
static i64 qq_lex_lookup(u64 name, i64 length, i64 hashindex);
static void qq_lex_readrawstring();
static void qq_lex_readhex();
static void qq_lex_readbin();
static void qq_lib_lxerror(u64 mess);
static void qq_lex_readdec();
static void qq_lex_readreal();
static void qq_lex_lxreadstring(i64 termchar);
static void qq_lex_readrawxname();
static i64 qq_lex_readhexcode(u64 s, i64 n, i64 sp);
static i64 qq_lex_getutf8(i64 c, u64 s);
static void qq_lex_lxerror_s(u64 mess, u64 a);
static void qq_lex_inithashtable();
static i64 qq_lex_gethashvaluez(u64 s);
static void qq_lex_start();
static void qq_lex_addstname(u64 name, i64 symbol, i64 subcode);
static void qq_lex_startlex(u64 pm);
static void qq_lex_ps(u64 caption);
static void qq_show_printsymbol(u64 lp);
static void qq_lex_psnext(u64 caption);
static void qq_lex_lex();
static void qq_lex_makedecimal(u64 s, i64 length, i64 base);
static void qq_lib_reportcterror(u64 errortype, u64 mess, i64 pos, u64 currproc);
static struct $B12 qq_lib_geterrorinfo(u64 pos, u64 currproc);
static void qq_lib_showerrorsource(struct $B12 loc);
static void qq_lib_stopcompiler(struct $B12 loc);
static void qq_lib_gerror(u64 mess, u64 p);
static void qq_lib_gerror_s(u64 mess, u64 param, u64 p);
static void qq_lib_serror(u64 mess);
static void qq_lib_serror_s(u64 mess, u64 param);
static void qq_lib_rxerror(u64 mess, u64 p);
static void qq_lib_rxerror_s(u64 mess, u64 param, u64 p);
static void qq_lib_prterror(u64 mess);
static u64 qq_lib_allocunitrec();
static u64 qq_lib_createintunit(i64 a);
static u64 qq_lib_createrealunit(r64 x);
static u64 qq_lib_createstringunit(u64 s, i64 slength);
static u64 qq_lib_createunit0(i64 tag);
static u64 qq_lib_createunit1(i64 tag, u64 p);
static u64 qq_lib_createunit2(i64 tag, u64 p, u64 q);
static u64 qq_lib_createname(u64 p);
static void qq_lib_addlistunit(u64 ulist, u64 ulistx, u64 p);
static u64 qq_lib_createavname();
static u64 qq_lib_findprocname(u64 fnptr);
static u64 qq_lib_strexpr(u64 p);
static void qq_lib_jeval(u64 p);
static u64 qq_lib_strexpr_s(u64 p);
static void qq_lib_additem(u64 s);
static void qq_lib_convertstring(u64 s, u64 t);
static u64 qq_lib_getopcname(i64 opc);
static void qq_lib_jevallist(u64 p);
static i64 qq_lib_isalphanum(i64 c);
static u64 qq_lib_createavnamex(u64 owner);
static void qq_resolve_resolvename(u64 owner, u64 p, i64 mode);
static void qq_lib_storemode(u64 owner, i64 m, u64 p);
static i64 qq_lib_testelem(u64 p, i64 n);
static void qq_lib_setelem(u64 p, i64 n);
static void qq_lib_setelemblock(u64 p, i64 a, i64 b);
static i64 qq_lib_ispoweroftwo(i64 x);
static void qq_lib_deleteunit(u64 p, u64 q);
static void qq_lib_skipsemi();
static void qq_lib_checksymbol(i64 symbol);
static void qq_lib_skipsymbol(i64 symbol);
static i64 qq_lib_getpcloffset(u64 p, u64 q);
static void qq_lists_start();
static void qq_lists_var_make_list(u64 a, u64 dest, i64 n, i64 lower);
static void qq_lists_obj_free_list(u64 p);
static void qq_lists_var_getix_list(u64 a, i64 index);
static void qq_lists_var_getslice_list(u64 a, i64 i, i64 j);
static void qq_lists_var_getixref_list(u64 a, i64 index);
static void qq_lists_obj_append_list(u64 a, u64 x);
static void qq_lists_var_putix_list(u64 a, i64 index, u64 x);
static void qq_lists_var_putslice_list(u64 a, i64 i, i64 j, u64 x);
static void qq_lists_obj_resize_list(u64 p, i64 n);
static void qq_lists_var_appendto_list(u64 a, u64 x);
static void qq_lists_var_dupl_list(u64 a);
static void qq_lists_var_mul_list(u64 p, i64 m);
static i64 qq_lists_var_equal_list(u64 x, u64 y);
static i64 qq_vars_var_equal(u64 a, u64 b);
static void qq_lists_var_concatto_list(u64 a, u64 b);
static i64 qq_lists_var_inx_list(u64 a, u64 b);
static u64 qq_modules_loadsourcefile(u64 filespec, i64 issyslib);
static i64 qq_modules_loadqafile(u64 pm);
static i64 qq_syslibs_loadsysmodule(u64 pm);
static u64 qq_modules_readfileline(u64 s);
static u64 qq_modules_findnextlineheader(u64 s);
static u64 qq_names_addglobalname(u64 name);
static u64 qq_names_newstrec();
static u64 qq_names_addsymbol(u64 owner, u64 d, i64 id, i64 isglobal);
static void qq_names_addproc(u64 d);
static i64 qq_names_newusertypex(u64 d, u64 e);
static u64 qq_names_resolvedottedname(u64 owner, u64 d);
static void qq_names_addgenfield(u64 d);
static i64 qq_names_makereftype(i64 target, u64 owner);
static i64 qq_names_addanontype();
static i64 qq_names_makeaxtype(i64 target, u64 plower, u64 plength);
static i64 qq_names_makestrtype(i64 m, u64 pwidth);
static void qq_names_createusertype(u64 d, i64 m);
static i64 qq_names_getalignment(i64 m);
static void qq_names_duplfield(u64 p, u64 q);
static void qq_names_writesig(u64 d, u64 dev);
static i64 qq_packed_getfslength(u64 s, i64 m);
static void qq_packed_setfslength(u64 s, i64 m, i64 n);
static void qq_packed_var_make_struct(u64 a, u64 dest, i64 n, i64 rectype);
static void qq_packed_var_dupl_struct(u64 a);
static void qq_packed_obj_free_struct(u64 p);
static i64 qq_packed_var_equal_struct(u64 x, u64 y);
static void qq_packed_var_getix_struct(u64 a, i64 index);
static u64 qq_parse_readsunit(i64 inwhile);
static u64 qq_parse_readexpression();
static u64 qq_parse_readterm2();
static u64 qq_parse_readassignment(u64 p);
static u64 qq_parse_readorterms(u64 p);
static u64 qq_parse_readandterms(u64 p);
static u64 qq_parse_readcmpterms(u64 p);
static u64 qq_parse_readinterms(u64 p);
static u64 qq_parse_readrangeterm(u64 p);
static u64 qq_parse_readaddterms(u64 p);
static u64 qq_parse_readmulterms(u64 p);
static u64 qq_parse_readpowerterms(u64 p);
static u64 qq_parse_readterm();
static u64 qq_parse_readtermsuffix(u64 p, i64 pos);
static u64 qq_parse_readslist(u64 nparams, i64 ftrailing);
static u64 qq_parse_readcondsuffix(u64 p);
static u64 qq_parse_readindex(u64 p, i64 dot);
static u64 qq_parse_readdotsuffix(u64 p);
static u64 qq_parse_readkeyindex(u64 p);
static u64 qq_parse_readlbrack();
static u64 qq_parse_readcast();
static u64 qq_parse_checkoperator();
static u64 qq_parse_readset();
static u64 qq_parse_readpair(i64 tag, i64 pclop);
static u64 qq_parse_readsprint();
static void qq_parse_lexchecksymbol(i64 symbol);
static u64 qq_parse_readgoto();
static u64 qq_parse_readif();
static u64 qq_parse_readunless();
static u64 qq_parse_readswitchcase();
static u64 qq_parse_readfor();
static u64 qq_parse_readto();
static u64 qq_parse_readdo();
static u64 qq_parse_readwhile();
static u64 qq_parse_readrepeat();
static u64 qq_parse_readloopcontrol();
static u64 qq_parse_readreturn();
static u64 qq_parse_readstop();
static u64 qq_parse_readprint();
static u64 qq_parse_readread();
static u64 qq_parse_readtry();
static u64 qq_parse_readhostparams(u64 lhs, i64 isfn);
static u64 qq_parse_readlambda();
static void qq_parse_readprocdef(i64 isglobal);
static u64 qq_parse_readvardef(i64 isglobal, i64 isstatic);
static void qq_parse_readconstdef(i64 isglobal);
static void qq_parse_readtypedef(i64 isglobal);
static void qq_parse_readrecorddef(i64 isglobal, u64 d);
static void qq_parse_readtabledef(i64 isglobal);
static void qq_parse_readimportdll();
static void qq_parse_readmacrodef(i64 isglobal);
static void qq_parse_checkequals();
static void qq_parse_pushlisttype(i64 ltype);
static void qq_parse_poplisttype();
static u64 qq_parse_makeblock(u64 p);
static void qq_parse_checkend(i64 endkwd1, i64 endkwd2, i64 startline);
static u64 qq_parse_readintunit();
static u64 qq_parse_readsread();
static void qq_parse_readffiparams(u64 stproc);
static void qq_parse_readpackvars(u64 owner, i64 id);
static i64 qq_parse_readtypespec(i64 allowvar, u64 owner);
static void qq_parse_readtypeparams(u64 stproc, i64 ptype);
static void qq_parse_readtypenameparams(u64 stproc, i64 ptype);
static i64 qq_parse_istypestarter();
static i64 qq_parse_readrecordbody(u64 owner);
static i64 qq_parse_readstructbody(u64 owner, i64 caligned);
static void qq_parse_readrecordfields(u64 owner);
static u64 qq_parse_readatfield();
static void qq_parse_readparams(u64 stproc);
static void qq_pclgen_evalunit(u64 p, i64 res);
static void qq_pcllib_genpc_int(i64 opc, i64 a);
static void qq_pcllib_genpc_real(i64 opc, r64 x);
static void qq_pclgen_pushstring(u64 s);
static void qq_pcllib_genpc_name(i64 opc, u64 d);
static void qq_pcllib_genpc(i64 opc);
static i64 qq_pcllib_createfwdlabel();
static void qq_pcllib_genpc_lab(i64 opc, i64 lab);
static void qq_pclgen_do_call(u64 p, u64 a, u64 b, i64 res, u64 procflag);
static void qq_pclgen_do_return(u64 p, u64 a, i64 res);
static void qq_pclgen_do_callhost(u64 p, u64 a, i64 res);
static void qq_pclgen_do_assign(u64 a, u64 b, i64 res, i64 deepcopy);
static void qq_pclgen_do_to(u64 p, u64 pcount, u64 pbody);
static void qq_pclgen_do_if(u64 p, u64 a, u64 b, u64 pelse, i64 res);
static void qq_pclgen_do_for(u64 p, u64 pvar, u64 pbody);
static void qq_pclgen_do_forx(u64 p, u64 pvar, u64 pbody);
static void qq_pclgen_do_forall(u64 p, u64 pindex, u64 pbody);
static void qq_pclgen_do_while(u64 p, u64 pcond, u64 pbody);
static void qq_pclgen_do_repeat(u64 p, u64 a, u64 b);
static void qq_pcllib_gencomment(u64 s);
static i64 qq_pcllib_definelabel();
static void qq_pcllib_definefwdlabel(i64 lab);
static void qq_pclgen_do_loop(u64 p);
static void qq_pclgen_do_do(u64 p, u64 a);
static void qq_pclgen_do_case(u64 p, u64 pindex, u64 pwhenthen, i64 res);
static void qq_pclgen_do_switch(u64 p, u64 pindex, u64 pwhenthen, i64 res);
static void qq_pclgen_evalref(u64 p);
static void qq_pclgen_do_select(u64 pindex, u64 pplist, i64 res);
static void qq_pclgen_do_print(u64 p, u64 a, u64 b);
static void qq_pclgen_do_fprint(u64 p, u64 a, u64 b, u64 c);
static void qq_pclgen_do_read(u64 p, u64 a, u64 b);
static void qq_pclgen_do_try(u64 p, u64 a, u64 b);
static void qq_pclgen_do_andl(u64 x, u64 y);
static void qq_pclgen_do_orl(u64 x, u64 y);
static void qq_pclgen_do_pushlist(u64 a, i64 n);
static void qq_pcllib_genpc_xy(i64 opc, i64 x, i64 y);
static void qq_pclgen_do_makedict(u64 a, i64 n);
static void qq_pclgen_do_map(u64 p, u64 popcode, u64 x);
static void qq_pclgen_do_idiv(u64 a, u64 b);
static void qq_pclgen_do_irem(u64 a, u64 b);
static void qq_pclgen_do_bin(u64 a, u64 b, i64 opc);
static void qq_pclgen_do_convert(u64 pconv);
static void qq_pclgen_do_incr(u64 p, u64 a, i64 res);
static void qq_pcllib_genpc_n(i64 opc, i64 n);
static void qq_pcllib_resetpcl(i64 sourcesize);
static void qq_pclgen_do_procdef(u64 p);
static void qq_pclgen_genprocentry(u64 p, u64 nfreevars, u64 nnofreevars);
static i64 qq_pclgen_checkblockreturn(u64 p);
static void qq_pclgen_genprocexit(i64 nfree, i64 nnofree, i64 isfunc);
static void qq_pclgen_genjumpcond(i64 opc, u64 p, i64 lab);
static void qq_pclgen_genjumpl(i64 lab);
static void qq_pclgen_gcomparejump(i64 opc, i64 cond, i64 lab);
static void qq_pclgen_stacklooplabels(i64 a, i64 b, i64 c);
static void qq_pclgen_unstacklooplabels();
static i64 qq_pclgen_findlooplabel(i64 k, i64 n);
static void qq_pclgen_do_multassign(u64 a, u64 b, i64 deepcopy, i64 res);
static void qq_pclgen_do_store(u64 a, i64 res);
static void qq_pclgen_do_binref(u64 a, u64 b, i64 opc);
static void qq_pclgen_do_unary(u64 a, i64 opc);
static void qq_pclgen_do_unaryref(u64 a, i64 opc);
static i64 qq_pclgen_pushparams(u64 d, u64 arglist, i64 nargs, i64 kwdindex);
static void qq_pclgen_pushkwdparams(u64 d, u64 arglist, i64 nargs, i64 kwdindex);
static void qq_pclgen_evalparam(u64 a, i64 byref);
static void qq_pclgen_callhostfn(i64 fnindex, i64 calledasfn);
static void qq_pclgen_do_case_nc(u64 p, u64 pindex, u64 pwhenthen, i64 res);
static i64 qq_pclgen_getconstvalue(u64 p);
static void qq_pcllib_genxy(i64 x, i64 y);
static i64 qq_pclgen_unitstoarray(u64 p, u64 plist, i64 maxunits);
static void qq_pclgen_genfree(i64 n);
static void qq_pclgen_do_makerecordkv(i64 m, i64 nkeyvals, u64 kvlist);
static void qq_pclgen_checkelems(i64 n, i64 length, u64 p);
static void qq_pclgen_do_simpleswitch(u64 p, u64 pindex, u64 pwhenthen, u64 pelse, i64 a, i64 b, i64 res);
static void qq_pcllib_genopnd_strz(u64 s);
static void qq_pcllib_start();
static void qq_pcllib_extendpcldata();
static void qq_pcllib_genopnd_str(u64 s);
static void qq_pcllib_genopnd_obj(u64 p);
static void qq_pcllib_extendlabeltable();
static void qq_print_printstr_n(u64 s, i64 n);
static void qq_print_printnextfmtchars(i64 lastx);
static i64 qq_print_getreadfmtcode(u64 p);
static u64 qq_print_readint(u64 sold, i64 length, u64 dest, i64 dodec);
static void qq_print_stepkbpos(u64 s);
static u64 qq_print_readreal(u64 sold, i64 length, u64 dest);
static u64 qq_print_readname(u64 s, i64 length, u64 dest);
static u64 qq_print_readstring(u64 s, i64 length, u64 dest);
static u64 qq_print_readhex(u64 sold, i64 length, u64 dest);
static u64 qq_print_readbin(u64 sold, i64 length, u64 dest);
static u64 qq_print_readany(u64 sold, i64 length, u64 dest);
static u64 qq_print_readitem(u64 s, i64 length, u64 itemstr, u64 itemlength);
static void qq_print_strtoint(u64 s, i64 length, u64 dest, i64 dodec);
static void qq_print_strtoreal(u64 s, i64 length, u64 dest);
static u64 qq_print_pc_getfmt(u64 p, u64 fmt);
static void qq_print_addstring(u64 p, u64 t, i64 n);
static void qq_print_domultichar(u64 p, i64 n, u64 dest, u64 fmt);
static void qq_print_tostr_int(u64 p, u64 fmt, u64 dest);
static void qq_print_tostr_real(u64 p, u64 fmt, u64 dest);
static void qq_print_tostr_str(u64 p, u64 fmt, u64 dest);
static u64 qq_strings_obj_new_string(i64 n);
static void qq_print_tostr(u64 p, u64 fmt, u64 dest);
static void qq_print_tostr_range(u64 p, u64 fmt, u64 dest);
static void qq_print_tostr_array(u64 p, u64 fmt, u64 dest);
static void qq_print_tostr_bits(u64 p, u64 fmt, u64 dest);
static void qq_vars_var_loadbit(u64 p, i64 shift, i64 t, i64 bitlength, u64 dest);
static void qq_print_tostr_struct(u64 p, u64 fmt, u64 dest);
static void qq_print_tostr_set(u64 p, u64 fmt, u64 dest);
static void qq_print_tostr_dict(u64 p, u64 fmt, u64 dest);
static void qq_print_tostr_decimal(u64 p, u64 fmt, u64 dest);
static void qq_print_tostr_list(u64 p, u64 fmt, u64 dest);
static void qq_records_var_make_record(u64 a, u64 dest, i64 n, i64 rectype);
static void qq_records_obj_free_record(u64 p);
static void qq_records_var_dupl_record(u64 a);
static void qq_records_var_getix_record(u64 a, i64 index);
static void qq_records_var_putix_record(u64 a, i64 index, u64 x);
static void qq_records_var_getixref_record(u64 a, i64 index, u64 dest);
static void qq_resolve_rx_passdef(u64 owner, u64 p);
static void qq_resolve_rx_unit(u64 owner, u64 p);
static void qq_resolve_rx_deflist(u64 owner, u64 p, i64 doanon);
static void qq_resolve_fixmode(u64 owner, u64 p);
static void qq_resolve_expandmacro(u64 p, u64 a, u64 b);
static void qq_resolve_resolvedot(u64 owner, u64 p);
static void qq_resolve_rx_unitlist(u64 owner, u64 p);
static void qq_resolve_evalbinop(u64 p, u64 lhs, u64 rhs);
static void qq_resolve_evalmonop(u64 p);
static void qq_show_printunit(u64 p, i64 level, u64 prefix, u64 dev);
static void qq_resolve_makeintconst(u64 p, i64 value);
static void qq_resolve_makerealconst(u64 p, r64 xvalue);
static u64 qq_resolve_resolvetopname(u64 owner, u64 stnewname, i64 moduleno, i64 allowmod);
static void qq_resolve_resolvedot_sym(u64 owner, u64 p);
static u64 qq_resolve_finddupl(u64 d, u64 pdupl);
static u64 qq_resolve_copyunit(u64 p);
static void qq_resolve_replaceunit(u64 p, u64 q);
static u64 qq_resolve_copylistunit(u64 p);
static i64 qq_resolve_fixmode2(u64 owner, i64 m);
static void qq_resolve_dobaseclass(i64 baseclassindex);
static void qq_resolve_converttype(i64 m);
static i64 qq_resolve_getconstint(u64 owner, u64 a, i64 ownerid);
static void qq_resolve_scanstruct(i64 smode, u64 fields, u64 index, u64 isize, i64 offset, i64 calign, u64 maxalign, i64 countmode);
static void qq_runaux_k_swap(u64 x, u64 y);
static void qq_runaux_k_convrefpack(u64 sp);
static i64 qq_vars_var_istruel(u64 a);
static i64 qq_vars_var_compare(u64 a, u64 b);
static i64 qq_runaux_k_when(u64 x, u64 y);
static u64 qq_runaux_k_makelist(u64 sp, i64 lower, i64 n);
static void qq_runaux_k_incrptr(u64 p, i64 step);
static void qq_vars_var_loadptr(u64 x, u64 y);
static void qq_vars_var_neg(u64 a);
static void qq_vars_var_abs(u64 a);
static void qq_vars_var_inot(u64 a);
static void qq_strings_var_makechar(i64 ch, u64 dest);
static void qq_runaux_k_maths(u64 sp, i64 opc);
static void qq_runaux_k_maths2(u64 x, u64 y, i64 opc);
static void qq_runaux_k_len(u64 sp);
static void qq_runaux_k_lwb(u64 sp);
static void qq_runaux_k_upb(u64 sp);
static void qq_runaux_k_bounds(u64 sp, u64 lower, u64 upper);
static i64 qq_runaux_k_bytesize(u64 sp);
static i64 qq_runaux_k_type(u64 sp, i64 n);
static void qq_runaux_k_minval(u64 sp);
static void qq_runaux_k_maxval(u64 sp);
static void qq_vars_var_convert(u64 x, i64 t, u64 dest);
static void qq_vars_var_idiv(u64 a, u64 b);
static void qq_vars_var_irem(u64 a, u64 b);
static i64 qq_vars_var_in(u64 a, u64 b);
static i64 qq_vars_var_inx(u64 a, u64 b);
static i64 qq_runaux_k_cmp(i64 cc, u64 x, u64 y);
static void qq_vars_var_concat(u64 a, u64 b);
static void qq_vars_var_append(u64 a, u64 b);
static void qq_vars_var_power(u64 a, u64 b);
static void qq_vars_var_inplace(i64 index, u64 px, u64 y);
static i64 qq_vars_var_appendto(u64 a, u64 b);
static i64 qq_vars_var_concatto(u64 a, u64 b);
static void qq_runaux_k_dot(u64 sp, u64 g);
static u64 qq_runaux_k_popdot(u64 sp, u64 g);
static void qq_runaux_k_dotref(u64 sp, u64 g);
static void qq_vars_var_getix(u64 a, i64 index);
static void qq_vars_var_getslice(u64 a, i64 i, i64 j);
static void qq_runaux_pcmxtypes(u64 mess, u64 x, u64 y);
static void qq_vars_var_putix(u64 a, i64 index, u64 x);
static void qq_vars_var_putslice(u64 a, i64 i, i64 j, u64 x);
static void qq_vars_var_getixref(u64 a, i64 index);
static u64 qq_runaux_k_keyindex(u64 sp);
static u64 qq_runaux_k_popkeyindex(u64 sp);
static u64 qq_runaux_k_keyindexref(u64 sp);
static void qq_vars_var_getdotix(u64 a, i64 index);
static void qq_vars_var_getdotslice(u64 a, i64 i, i64 j);
static void qq_vars_var_putdotix(u64 p, i64 index, u64 x);
static void qq_vars_var_putdotslice(u64 p, i64 i, i64 j, u64 x);
static void qq_vars_var_getdotixref(u64 p, i64 index);
static void qq_vars_var_getdotsliceref(u64 p, i64 i, i64 j);
static void qq_vars_var_expand(u64 a, u64 dest, i64 m);
static u64 qq_runaux_raiseexception(i64 exceptno);
static void qq_runx_start();
static void qq_runaux_reportpcerror(u64 pcptr, u64 mess, u64 param);
static struct $B12 qq_runaux_getpcerrorpos(u64 pc);
static i64 qq_runaux_findmodulefrompc(u64 pc);
static u64 qq_runaux_resolvefield(u64 g, i64 rectype);
static void qq_runaux_runproc(u64 fnptr, u64 a, u64 b, u64 dest);
static void qq_sets_obj_free_set(u64 p);
static void qq_sets_var_dupl_set(u64 a);
static i64 qq_sets_var_equal_set(u64 x, u64 y);
static i64 qq_sets_getsetbytes(u64 x);
static void qq_sets_var_emptyset(u64 dest);
static void qq_sets_var_getix_set(u64 a, i64 index);
static void qq_sets_var_putix_set(u64 a, i64 index, u64 x);
static u64 qq_sets_getoffset(u64 p, i64 index, u64 newoffset);
static void qq_sets_var_getixref_set(u64 a, i64 index);
static void qq_sets_iresizeset(u64 p, i64 n);
static void qq_sets_obj_resize_set(u64 p, i64 n);
static void qq_sets_iorsetbits(u64 p, u64 q, i64 n);
static void qq_sets_ixorsetbits(u64 p, u64 q, i64 n);
static void qq_sets_iandsetbits(u64 p, u64 q, i64 n);
static void qq_sets_inotsetbits(u64 p, i64 n);
static void qq_sets_var_iorto_set(u64 x, u64 y);
static void qq_sets_var_iandto_set(u64 x, u64 y);
static void qq_sets_var_ixorto_set(u64 x, u64 y);
static void qq_sets_var_inotto_set(u64 x);
static void qq_strings_start();
static u64 qq_strings_obj_make_stringn(u64 s, i64 length, i64 mutable);
static void qq_strings_obj_free_string(u64 p);
static void qq_strings_var_dupl_string(u64 a);
static void qq_strings_var_getix_string(u64 a, i64 index);
static void qq_strings_stringslice(u64 a, i64 i, i64 j, u64 dest);
static void qq_strings_var_getixref_string(u64 a, i64 index);
static void qq_strings_var_getdotix_string(u64 a, i64 index);
static void qq_strings_var_getdotixref_string(u64 a, i64 index, u64 dest);
static void qq_strings_var_getslice_string(u64 a, i64 i, i64 j);
static void qq_strings_var_putix_string(u64 a, i64 index, u64 x);
static void qq_strings_var_addto_string(u64 a, u64 b);
static void qq_strings_var_putslice_string(u64 a, i64 i, i64 j, u64 x);
static void qq_strings_var_putdotix_string(u64 a, i64 index, u64 x);
static void qq_strings_var_addto_string_ch(u64 a, i64 ch);
static void qq_strings_obj_resize_string(u64 p, i64 n);
static void qq_strings_var_add_string(u64 a, u64 b);
static i64 qq_strings_var_equal_string(u64 x, u64 y);
static i64 qq_strings_var_compare_string(u64 x, u64 y);
static i64 qq_strings_cmpstring_len(u64 s, u64 t, i64 slen, i64 tlen);
static i64 qq_strings_var_inx_string(u64 x, u64 y);
static void qq_strings_var_makestrslicexobj(u64 s, i64 length, u64 dest);
static i64 qq_strings_var_asc(u64 a);
static void qq_strings_var_mul_string(u64 a, i64 m);
static void qq_strings_var_convert_string_list(u64 a, i64 t, u64 dest);
static void qq_strings_var_expand_string(u64 a, u64 dest, i64 m);
static u64 qq_syslibs_findsyslib(u64 filename);
static void qq_tables_start();
static void qq_show_printunitlist(u64 dev, u64 p, i64 level, u64 prefix);
static void qq_show_printglobalsymbols(u64 f);
static void qq_show_printst(u64 f, u64 p, i64 level);
static void qq_show_printstrec(u64 f, u64 p, i64 level);
static void qq_show_printtypetables(u64 f);
static void qq_show_showsttree();
static void qq_show_showtypes();
static void qq_show_showast2(u64 f, u64 sp);
static void qq_show_showstflat();
static void qq_show_addtolog(u64 filename, u64 logdest);
static void qq_showpcl_writepcl(u64 pcstart, u64 pc, u64 pclsource, i64 pass, u64 sourcecode);
static void qq_showpcl_gstr(u64 s);
static void qq_showpcl_gline();
static void qq_showpcl_gstrln(u64 s);
static void qq_showpcl_glabeldef(u64 pcstart, u64 pc);
static void qq_showpcl_gstrint(i64 a);
static void qq_showpcl_writeallpcl(u64 pm, i64 pass);
static void qq_showpcl_showpcl2(u64 sp, i64 pass);
static void qq_vars_var_free(u64 a);
static u64 qq_vars_void_new();
static i64 qq_vars_var_addto(u64 p, u64 b);
static i64 qq_vars_var_equalmixed(u64 a, u64 b);
static i64 qq_vars_var_comparemixed(u64 a, u64 b);
static void qq_vars_var_storeptr(u64 p, u64 q);
static void qq_vars_var_inplace_unary(u64 px, u64 fnneg);
static void qq_vars_var_putdotix_intint(u64 a, i64 index, u64 b);
static void qq_vars_var_powermixed(u64 a, u64 b);


int main(int nargs, char** args) {
    msysc_$getcommands(nargs, (u64)args, 0);
    qq_cli_main();
}

// **************************************************
static i64 msysc_fmtparam;
i64 msysc_$cmdskip;
static i64 msysc_needgap = 0;

static i64 msysc_outdev = 1;

static u64 msysc_outchan = 0;

static u64 msysc_fmtstr = 0;

static struct $B1 msysc_outchan_stack;
static struct $B1 msysc_outdev_stack;
static struct $B1 msysc_fmtstr_stack;
static struct $B2 msysc_needgap_stack;
static struct $B1 msysc_ptr_stack;
static i64 msysc_niostack = 0;

static struct $B3 msysc_digits = {{
3978425819141910832,
5063528411713059128}};

static struct $B3 msysc_defaultfmt = {{
112287625641984,
20992}};

static u64 msysc_rd_buffer;
static i64 msysc_rd_length;
static u64 msysc_rd_pos;
static u64 msysc_rd_lastpos;
static i64 msysc_termchar;
static i64 msysc_itemerror;
static struct $B4 msysc_printbuffer;
static u64 msysc_printptr;
static i64 msysc_printlen;
static i64 msysc_ncmdparams;
static u64 msysc_cmdparams;
static struct $B3 msysc_getfmt_fmt;
static struct $B5 msysc_strint_str;
static struct $B5 msysc_strword_str;
static struct $B6 msysc_strreal_str;
static struct $B7 mlib_allocupper;
static i64 mlib_alloccode;
static i64 mlib_allocbytes;
static i64 mlib_fdebug = 0;

static i64 mlib_rfsize;
static u64 mlib_maxmemory;
static i64 mlib_maxalloccode;
static u8 mlib_pcm_setup = 0;

static i64 mlib_show = 0;

static i64 mlib_memtotal = 0;

static i64 mlib_smallmemtotal = 0;

static i64 mlib_smallmemobjs = 0;

static i64 mlib_maxmemtotal = 0;

static struct $B8 mlib_memalloctable;
static struct $B9 mlib_memallocsize;
static u64 mlib_pcheapstart;
static u64 mlib_pcheapend;
static u64 mlib_pcheapptr;
static struct $B10 mlib_sizeindextable;
static struct $B11 mlib_freelist;
static struct $B12 mlib_pmnames = {{
(u64)"pm_end",
(u64)"pm_option",
(u64)"pm_sourcefile",
(u64)"pm_libfile",
(u64)"pm_colon",
(u64)"pm_extra"}};

static struct $B3 mlib_seed = {{
2993073034246558322,
1617678968452121188}};

static i64 mlib_pcm_newblock_totalheapsize;
// Istatic skipped:mlib.pcm_round.allocbytes

static struct $B14 mlib_changeext_newfile;
static struct $B14 mlib_extractpath_str;
static struct $B5 mlib_extractbasefile_str;
// Istatic skipped:mlib.nextcmdparamnew.infile

// Istatic skipped:mlib.nextcmdparamnew.filestart

// Istatic skipped:mlib.nextcmdparamnew.fileptr

// Istatic skipped:mlib.nextcmdparamnew.colonseen

static struct $B15 mlib_nextcmdparamnew_str;
static struct $B16 mlib_readnextfileitem_str;
static struct $B16 mlib_padstr_str;
static u64 mlib_chr_str;
static u64 mwindows_hconsole;
static u64 mwindows_hconsolein;
static struct $B17 mwindows_lastkey;
static struct $B17 mwindows_pendkey;
static i64 mwindows_keypending;
static i64 mwindows_hpfreq;
static u64 mwindows_wndproc_callbackfn = 0;

static i64 mwindows_init_flag = 0;

static u8 mwindows_os_gxregisterclass_registered;
// Istatic skipped:mwindows.mainwndproc.count

static struct $B15 mwindows_os_gethostname_name;
static i64 mwindows_os_gethostname_n;
static i64 mwindows_os_peek_lastticks;
static i64 qq_cli_nalldot;
static i64 qq_cli_nalldot1field;
static u64 qq_cli_syslibname;
static struct $B12 qq_cli_runnames = {{
(u64)"load_cc",
(u64)"parse_cc",
(u64)"names_cc",
(u64)"gencode_cc",
(u64)"fixup_cc",
(u64)"run_cc"}};

static u8 qq_cli_fshowpcl1;
static u8 qq_cli_fshowpcl2;
static u8 qq_cli_fshowast1;
static u8 qq_cli_fshowast2;
static u8 qq_cli_fshowst;
static u8 qq_cli_fshowstflat;
static u8 qq_cli_fshowtypes;
static u8 qq_cli_foptimise = 1;

static u8 qq_cli_fwriteqa;
static u8 qq_cli_fshowmodules;
static u8 qq_cli_fallsp;
static u8 qq_cli_runcode = 6;

static u64 qq_cli_sourcestr;
static u64 qq_cli_inputfile;
static u64 qq_cli_allprocdefs;
static u64 qq_cli_allstaticdefs;
static u64 qq_cli_pclstr;
static i64 qq_cli_cmdstartindex;
static struct $B3 qq_decls_nextlx;
static struct $B3 qq_decls_lx;
static i64 qq_decls_qpos;
static i64 qq_decls_pcerrorpos;
static u64 qq_decls_pcerrormodule;
static struct $B18 qq_decls_varstack;
static u64 qq_decls_sptr;
static u64 qq_decls_stacklimit;
static u64 qq_decls_frameptr;
static u64 qq_decls_pcptr;
static i64 qq_decls_stopped;
static u64 qq_decls_stprogram;
static u64 qq_decls_stmodule;
static u64 qq_decls_stsubprog;
static u64 qq_decls_stcurrmodule;
static u64 qq_decls_stcurrproc;
static u64 qq_decls_currmodule;
static i64 qq_decls_debug;
static i64 qq_decls_inproc;
static struct $B19 qq_decls_genfieldtable;
static i64 qq_decls_ngenfields;
static i64 qq_decls_nlibfiles;
static struct $B20 qq_decls_libtable;
static struct $B21 qq_decls_libtypes;
static struct $B20 qq_decls_dllinsttable;
static i64 qq_decls_ndllprocs;
static struct $B22 qq_decls_dllproctable;
static struct $B23 qq_decls_dllproclibindex;
static struct $B22 qq_decls_dllprocaddr;
static u8 qq_decls_usebundled = 1;

static struct $B12 qq_decls_dispatchnames = {{
(u64)"-lab",
(u64)"-sw",
(u64)"-fn",
(u64)"-debug",
(u64)"-fdebug",
(u64)"-asm"}};

static i64 qq_decls_nqparams;
static struct $B16 qq_decls_qparamtable;
static u64 qq_decls_proclist;
static u64 qq_decls_proclistx;
static i64 qq_decls_nproclist;
static u64 qq_decls_pcl_callbackfn = 0;

static struct $B24 qq_decls_chrtable;
static u8 qq_decls_fnosys;
static u8 qq_decls_fverbose;
static struct $B25 qq_decls_baseclasstable;
static struct $B24 qq_decls_baseclassdef;
static i64 qq_decls_nbaseclasses;
static i64 qq_decls_lastretindex;
static struct $B26 qq_decls_modules;
static struct $B27 qq_decls_subprogs;
static i64 qq_decls_nmodules;
static i64 qq_decls_nsubprogs;
static i64 qq_decls_nalllines;
static struct $B28 qq_decls_qafilenames;
static struct $B28 qq_decls_qatext;
static struct $B28 qq_decls_qasize;
static i64 qq_decls_nqafiles;
static struct $B29 qq_decls_optionnames = {{
(u64)"load",
(u64)"parse",
(u64)"names",
(u64)"gen",
(u64)"fixup",
(u64)"run",
(u64)"ast1",
(u64)"ast2",
(u64)"pcl1",
(u64)"pcl2",
(u64)"allsp",
(u64)"st",
(u64)"stflat",
(u64)"types",
(u64)"modules",
(u64)"opt",
(u64)"no",
(u64)"ext",
(u64)"qa",
(u64)"qas",
(u64)"v",
(u64)"nosys",
(u64)"sys"}};

static struct $B29 qq_decls_optionvars = {{
(u64)&qq_cli_runcode,
(u64)&qq_cli_runcode,
(u64)&qq_cli_runcode,
(u64)&qq_cli_runcode,
(u64)&qq_cli_runcode,
(u64)&qq_cli_runcode,
(u64)&qq_cli_fshowast1,
(u64)&qq_cli_fshowast2,
(u64)&qq_cli_fshowpcl1,
(u64)&qq_cli_fshowpcl2,
(u64)&qq_cli_fallsp,
(u64)&qq_cli_fshowst,
(u64)&qq_cli_fshowstflat,
(u64)&qq_cli_fshowtypes,
(u64)&qq_cli_fshowmodules,
(u64)&qq_cli_foptimise,
(u64)&qq_cli_foptimise,
(u64)&qq_decls_usebundled,
(u64)&qq_cli_fwriteqa,
(u64)&qq_cli_fwriteqa,
(u64)&qq_decls_fverbose,
(u64)&qq_decls_fnosys,
(u64)&qq_decls_fnosys}};

static struct $B30 qq_decls_optionvalues = {{
1,
2,
3,
4,
5,
6,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
0,
1,
2,
1,
1,
0}};

static u64 qq_decls_stopseq;
static u64 qq_decls_raiseseq;
static i64 qq_decls_nproclocals;
static u64 qq_decls_pproclocals;
static struct $B31 qq_decls_pclcounts;
static i64 qq_decls_nallpcl;
static struct $B32 qq_decimal_fpnames = {{
(u64)"zero_type",
(u64)"normal_type",
(u64)"inf_type",
(u64)"nan_type"}};

static i64 qq_decimal_currprec = 55;

static i64 qq_decimal_stblz;
static u64 qq_decimal_constlist = 0;

static i64 qq_decimal_decstrsize;
static struct $B3 qq_decimal_vtemp;
static u8 qq_dicts_expanddict_inuse;
static u64 qq_host_procrefs;
static struct $B16 qq_host_pch_gethostname_name;
static struct $B16 qq_host_pch_getprogname_name;
static i64 qq_host_initprocrefs_oldnprocs;
static u64 qq_lex_lxsource;
static u64 qq_lex_lxstart;
static u64 qq_lex_lxsptr;
static i64 qq_lex_lxifcond;
static i64 qq_lex_longsuffix;
static i64 qq_lex_lxlineno;
static i64 qq_lex_nextlxlength;
static i64 qq_lex_lxlength;
static struct $B33 qq_lex_hashtable;
static u64 qq_lex_hashtablelast;
static u64 qq_lex_u64maxstr = (u64)"18446744073709551615";

static struct $B16 qq_lex_namemap;
static i64 qq_lex_lexinit_n;
static i64 qq_lib_currlineno;
static i64 qq_lib_nextavindex = 0;

static struct $B3 qq_lib_exprstrvar;
static u64 qq_lib_exprstr = (u64)&qq_lib_exprstrvar;

static i64 qq_lib_nlocalunits;
static u64 qq_lib_errormess;
static u64 qq_lib_bytemasks = -9205322385119247871;

static struct $B23 qq_lib_convtostringz_strbuffer1;
static struct $B23 qq_lib_convtostringz_strbuffer2;
static struct $B23 qq_lib_convtostringz_strbuffer3;
static struct $B23 qq_lib_convtostringz_strbuffer4;
static struct $B23 qq_lib_convtostringz_strbuffer5;
static struct $B23 qq_lib_convtostringz_strbuffer6;
// Istatic skipped:qq_lib.convtostringz.strindex

// Istatic skipped:qq_lib.convtostringz.table

// Istatic skipped:qq_lib.convtostringz.longstr

static u64 qq_lists_emptylist;
static struct $B15 qq_modules_getmodulefilename_str;
// Istatic skipped:qq_modules.loadstring.nextstrname

static i64 qq_names_sdsize;
static i64 qq_names_sdoffset;
static i64 qq_names_sdaligned;
static i64 qq_names_sdlevel;
static i64 qq_names_sdmode;
static i64 qq_names_sdnfields;
static i64 qq_names_sdmaxalign;
static struct $B2 qq_names_sdunion;
static struct $B1 qq_names_sdmaxsize;
static i64 qq_parse_intabledata;
static u64 qq_parse_tabledataname = 0;

static struct $B1 qq_parse_dollarstack;
static i64 qq_parse_ndollar = 0;

static u8 qq_parse_yieldseen;
static i64 qq_parse_currdllindex;
static i64 qq_parse_nextlambdaindex;
static struct $B35 qq_parse_listtypestack;
static i64 qq_parse_nlisttype;
static i64 qq_parse_listtype;
static i64 qq_parse_addstructflag_structseqno;
// Istatic skipped:qq_parse.readcompilervar.monthnames

static struct $B37 qq_pcltabs_opndnames = {{
(u64)"cnone",
(u64)"cstatic",
(u64)"cframe",
(u64)"cproc",
(u64)"cdllproc",
(u64)"cgenfield",
(u64)"clabel",
(u64)"cint",
(u64)"creal",
(u64)"cstring",
(u64)"cstringz",
(u64)"ctype",
(u64)"csymbol",
(u64)"coperator",
(u64)"cmaths",
(u64)"chost",
(u64)"cbinto",
(u64)"?"}};

static struct $B31 qq_pcltabs_pclnames = {{
(u64)"knop",
(u64)"kskip",
(u64)"kprocdef",
(u64)"kprocent",
(u64)"kprocend",
(u64)"kendmod",
(u64)"kcomment",
(u64)"kpushm",
(u64)"kpushf",
(u64)"kpushmref",
(u64)"kpushfref",
(u64)"kpushlab",
(u64)"kpopm",
(u64)"kpopf",
(u64)"kpushci",
(u64)"kpushvoid",
(u64)"kpushnil",
(u64)"kpushcr",
(u64)"kpushcs",
(u64)"kpushtype",
(u64)"kpushopc",
(u64)"kpushsym",
(u64)"kpushptr",
(u64)"kpopptr",
(u64)"kzpopm",
(u64)"kzpopf",
(u64)"kdupl",
(u64)"kcopy",
(u64)"kswap",
(u64)"kconvrefp",
(u64)"kjump",
(u64)"kjumpptr",
(u64)"kjumpt",
(u64)"kjumpf",
(u64)"kjumpeq",
(u64)"kjumpne",
(u64)"kjumplt",
(u64)"kjumple",
(u64)"kjumpge",
(u64)"kjumpgt",
(u64)"kwheneq",
(u64)"kwhenne",
(u64)"kjumplab",
(u64)"kswitch",
(u64)"ktom",
(u64)"ktof",
(u64)"kformci",
(u64)"kforfci",
(u64)"kformm",
(u64)"kforff",
(u64)"kcallproc",
(u64)"kcallptr",
(u64)"kretproc",
(u64)"kretfn",
(u64)"kmodcall",
(u64)"kmodret",
(u64)"kcalldll",
(u64)"kcallhost",
(u64)"kunshare",
(u64)"kaddsp",
(u64)"kstop",
(u64)"kmakelist",
(u64)"kmakevrec",
(u64)"kmakeax",
(u64)"kmakebits",
(u64)"kmaketrec",
(u64)"kmakeset",
(u64)"kmakerang",
(u64)"kmakedict",
(u64)"kmakedec",
(u64)"kincrptr",
(u64)"kincrtom",
(u64)"kincrtof",
(u64)"kloadincr",
(u64)"kincrload",
(u64)"kneg",
(u64)"kabs",
(u64)"knotl",
(u64)"kinot",
(u64)"kistruel",
(u64)"kasc",
(u64)"kchr",
(u64)"ksqr",
(u64)"kmaths",
(u64)"kmaths2",
(u64)"kunaryto",
(u64)"knotlto",
(u64)"klen",
(u64)"klwb",
(u64)"kupb",
(u64)"kbounds",
(u64)"kbytesize",
(u64)"ktype",
(u64)"kdictsize",
(u64)"kisfound",
(u64)"kminval",
(u64)"kmaxval",
(u64)"kistype",
(u64)"kisvoid",
(u64)"kconvert",
(u64)"ktypepun",
(u64)"kadd",
(u64)"ksub",
(u64)"kmul",
(u64)"kdiv",
(u64)"kidiv",
(u64)"kirem",
(u64)"kidivrem",
(u64)"kiand",
(u64)"kior",
(u64)"kixor",
(u64)"kshl",
(u64)"kshr",
(u64)"kin",
(u64)"kinx",
(u64)"kcmp",
(u64)"kmin",
(u64)"kmax",
(u64)"kconcat",
(u64)"kappend",
(u64)"ksame",
(u64)"kpower",
(u64)"kbinto",
(u64)"kandlto",
(u64)"korlto",
(u64)"kconcatto",
(u64)"kappendto",
(u64)"kdot",
(u64)"kpopdot",
(u64)"kdotref",
(u64)"kindex",
(u64)"kpopix",
(u64)"kindexref",
(u64)"kkeyindex",
(u64)"kpopkeyix",
(u64)"kkeyixref",
(u64)"kdotix",
(u64)"kpopdotix",
(u64)"kdotixref",
(u64)"kexpand",
(u64)"kpushtry",
(u64)"kraise",
(u64)"kmap",
(u64)"kpushfff",
(u64)"kpushff",
(u64)"kpushmm",
(u64)"kpushfm",
(u64)"kpushmf",
(u64)"kpushmci",
(u64)"kpushfci",
(u64)"kmoveff",
(u64)"kmovemm",
(u64)"kmovefm",
(u64)"kmovemf",
(u64)"kzmoveff",
(u64)"kmovefci",
(u64)"kmovemci",
(u64)"kzmovefci",
(u64)"kpushv2",
(u64)"kpushv3",
(u64)"kjmpeqfci",
(u64)"kjmpnefci",
(u64)"kjmpltfci",
(u64)"kjmplefci",
(u64)"kjmpgefci",
(u64)"kjmpgtfci",
(u64)"kjmpeqff",
(u64)"kjmpneff",
(u64)"kjmpltff",
(u64)"kjmpleff",
(u64)"kjmpgeff",
(u64)"kjmpgtff",
(u64)"kaddfci",
(u64)"ksubfci",
(u64)"kaddff",
(u64)"ksubff",
(u64)"kaddci",
(u64)"ksubci",
(u64)"kiandci",
(u64)"kshlci",
(u64)"kshrci",
(u64)"kbintof",
(u64)"kaddtof",
(u64)"kaddtofci",
(u64)"ksubtofci",
(u64)"kshltofci",
(u64)"kshrtofci",
(u64)"kindexmf",
(u64)"kindexff",
(u64)"kswitchf",
(u64)"kpushptrf",
(u64)"kpushipm",
(u64)"kpushipf",
(u64)"kpopipm",
(u64)"kpopipf",
(u64)"kupbm",
(u64)"kupbf",
(u64)"klenf",
(u64)"kstoref",
(u64)"kwheneqci",
(u64)"kwhenneci",
(u64)"klastpcl"}};

static struct $B38 qq_pcltabs_pclopnd = {{
0,
12,
0,
256,
258,
1538,
513,
7,
2048,
2825,
3085,
0,
513,
0,
0,
6,
1542,
1542,
1542,
1542,
1542,
6,
1542,
1542,
1542,
3,
0,
12,
3844,
0,
0,
0,
0,
0,
0,
256,
2,
0,
0,
0,
0,
3584,
3342,
0,
0,
0,
0,
0,
2816,
2816,
11,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
16,
0,
1280,
1285,
0,
0,
0,
0,
0,
6,
512,
2,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
0,
1792,
519,
514,
514,
2,
0,
0,
0,
0,
0,
1792,
7}};

static struct $B39 qq_pcltabs_pclattrs = {{
2314885530818453536,
2314885865825902624,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314983765310447648,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885865825902702,
2340033895776417902,
2314885530818453536,
2314885530818453614,
2314885865825902702,
2314983765310447726,
8535862225592677752,
2314979368712370552,
2314885530818453624,
2314885530818453624,
2314885908775575672,
2314885908775575672,
2314885530818453624,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453614,
2314885530818453614,
2314885530818453536,
2314885530818453536,
2314885530818453614,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885865825902624,
2314885818581262368,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885865825902624,
2314885908775598456,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536,
2314885530818453536}};

static struct $B40 qq_pcltabs_bintotable = {{
101,
(u64)&qq_vars_var_add,
(u64)&qq_vars_var_addmixed,
102,
(u64)&qq_vars_var_sub,
(u64)&qq_vars_var_submixed,
103,
(u64)&qq_vars_var_mul,
(u64)&qq_vars_var_mulmixed,
104,
(u64)&qq_vars_var_div,
(u64)&qq_vars_var_divmixed,
108,
(u64)&qq_vars_var_iand,
0,
109,
(u64)&qq_vars_var_ior,
0,
110,
(u64)&qq_vars_var_ixor,
0,
116,
(u64)&qq_vars_var_min,
0,
117,
(u64)&qq_vars_var_max,
0,
111,
(u64)&qq_vars_var_shl,
0,
112,
(u64)&qq_vars_var_shr,
0}};

static struct $B41 qq_pclgen_loopstack;
static struct $B35 qq_pclgen_trylevelstack;
static i64 qq_pclgen_loopindex = 0;

static i64 qq_pclgen_looptrylevel;
static i64 qq_pclgen_trylevel = 0;

static i64 qq_pclgen_retindex;
static i64 qq_pclgen_retvaloffset;
static i64 qq_pclgen_nprocparams;
static u64 qq_pclgen_pprocentry;
static i64 qq_pclgen_procskiplabel;
static u64 qq_pcllib_pcstart;
static u64 qq_pcllib_pccurr;
static u64 qq_pcllib_pcend;
static i64 qq_pcllib_pcalloc;
static u64 qq_pcllib_pcsourcestart;
static u64 qq_pcllib_pcsourcecurr;
static i64 qq_pcllib_pclcurrlineno;
static u64 qq_pcllib_labelpctable;
static i64 qq_pcllib_labelalloc;
static i64 qq_pcllib_nextlabelno;
static i64 qq_print_mindev;
static i64 qq_print_moutdev;
static u64 qq_print_minchan;
static u64 qq_print_moutchan;
static struct $B3 qq_print_minvar;
static struct $B3 qq_print_moutvar;
static struct $B8 qq_print_moutdevstack;
static struct $B12 qq_print_moutchanstack;
static struct $B36 qq_print_moutvarstack;
static struct $B42 qq_print_mgapstack;
static struct $B12 qq_print_mfmtstrstack;
static struct $B12 qq_print_mfmtcurrstack;
static i64 qq_print_noclevels;
static u64 qq_print_mfmtstr;
static u64 qq_print_mfmtcurr;
static struct $B3 qq_print_defaultfmt = {{
112287625641984,
20992}};

static u8 qq_print_mgapneeded;
static u64 qq_print_kb_start;
static u64 qq_print_kb_pos;
static u64 qq_print_kb_lastpos;
static i64 qq_print_kb_size;
static i64 qq_print_kb_linelength;
static i64 qq_print_kb_length;
static i64 qq_print_kb_lastlength;
static u8 qq_print_termchar;
static i64 qq_print_itemerror;
static u64 qq_print_testfilech;
static i64 qq_print_listdepth = 0;

static i64 qq_resolve_nprocs;
static i64 qq_resolve_noexpand;
static i64 qq_resolve_symbolmode;
static i64 qq_resolve_macrolevels;
static i64 qq_resolve_allowmodname;
static struct $B20 qq_resolve_macroparams;
static struct $B20 qq_resolve_macroparamsgen;
static struct $B20 qq_resolve_macroargs;
static i64 qq_resolve_nmacroparams;
static i64 qq_resolve_nmacroargs;
static struct $B28 qq_resolve_structfields;
static i64 qq_resolve_ntopfields;
static i64 qq_resolve_nallfields;
static u64 qq_runx_jumptable;
static u8 qq_runx_getjt;
// Istatic skipped:qq_runx.disploop.count

static i64 qq_runaux_runproc_m_rmsg_typeno;
static struct $B6 qq_runaux_k_map_codeseq;
// Istatic skipped:qq_sets.var_make_set.count

// Istatic skipped:qq_sets.var_in_set.masks

static u64 qq_strings_emptystring;
static struct $B43 qq_syslibs_syslibnames = {{
(u64)"syswin.q",
(u64)"syslin.q",
(u64)"sysp.q",
(u64)"windows.q",
(u64)"clibp.q",
(u64)"smlib.q",
(u64)"winapi.q",
(u64)"gxlib.q",
(u64)"bmlib.q",
(u64)"console.q",
(u64)"winconsts.q",
(u64)"wingxlib.q",
(u64)"winmessages.q",
(u64)"gxmisc.q",
(u64)"dates.q"}};

static struct $B43 qq_syslibs_libtext = {{
(u64)"!Q standard library - Windows\n\n!===============================\nmodule sysp\nmodule clibp\nmodule winapi\nmodule windows\n\nmodule gxlib\nmodule bmlib\nmodule console\nmodule winconsts\nmodule wingxlib\nmodule winmessages\nmodule gxmisc\nmodule dates\nmodule smlib\n!===============================\n",
(u64)"!Q standard library - Windows\n\n!===============================\nmodule sysp\nmodule clibp\n!module winapi\n\n!module gxlib\n!module bmlib\n!module console\nmodule lincon\n!module winconsts\n!module wingxlib\n!module winmessages\n!module gxmisc\n!module dates\n!module smlib\n!===============================\n",
(u64)"!Q Main Library\n\nexport type rkey=struct\t!key info as it's used locally\n\tu16\tcharcode\n\tbyte\tkeycode\n\tbyte\tshift\nend\n\nexport var ncmdparams\nexport var cmdparams\nexport var stclock=0\n\nexport const tab=\"\\t\"\n\nexport var readfilesize\n\nexport var infinity=$infinity()\nexport var nan=$nan()\n\nproc start=\n\n\tncmdparams:=getcmdparam()\n\n\tcmdparams:=new(list,1..ncmdparams)\n\n\ts::=\"\"\n\tfor i:=1 to ncmdparams do\n\t\tcmdparams[i]:=getcmdparam(i)\n\t\ts+:=cmdparams[i]+\" \"\n    od\n\n\tsreadln(s)\nend\n\nexport proc reporterror(m)=\n#print \"Error:\" followed by message m. Is that it? Count as being deprecated\n\n\tprintln \"Error:\",m\nend\n\nexport func splitstring(s,?sep)=\n#split up the string s into strings separated by the sep sequence\n#return a list of all the individual strings, excluding the sep seq\n\n\tif s=\"\" or sep=\"\" then return (s,) fi\n\n\ta::=()\n\tns:=0\n\n\tif sep.isvoid then\t\t\t!use any white space of variable width\n\n\t\twhitespace:=(' ','\\t',13,10)\n\n\t\ts:=s+chr(0)\n\t\tp:=&s\n\t\tt::=\"\"\n\t\tinstr:=0\n\n\t\twhile c:=p++^ do\n\t\t\tif c in whitespace then\n\t\t\t\tif instr then\n\t\t\t\t\ta[++ns]:=t\n\t\t\t\t\tt::=\"\"\n\t\t\t\t\tinstr:=0\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tinstr:=1\n\t\t\t\tt+:=c\n\t\t\tfi\n\t\tod\n\t\n\t\tif t then\n\t\t\ta[++ns]:=t\n\t\tfi\n\n\t\treturn a\n\n\telse\n\t\tdo\n\t\t\tn:=sep inx s\n\t\t\tif not n.isfound then\n\t\t\t\ta[++ns]:=s\n\t\t\t\treturn a\n\t\t\tfi\n\t\t\tt:=leftstr(s,n-1)\n\t\t\ta[++ns]:=t\n\t\t\ts:=rightstr(s,-(n+sep.len-1))\n\t\tod\n\tfi\n\treturn \"\"\nend\n\nexport func joinstrings(a,sep)=\n#join the strings in list, using the given separator string\n#return new single string\n\tif a.upb=0 then return \"\" fi\n\ts:=a[1]\n\tfor i:=2 to a.upb do\n\t\ts:=s+sep+a[i]\n\tod\n\treturn s\nend\n\nexport proc abort(s)=\n#Print message, pause for keypress, then stop the interpreter with stopcode 1\n\n\tprintln \"Abort:\",s,\"Error\"\n\twaitkey()\n\tstop 1\nend\n\nexport func extractpath(fs)=\n#fs is a full filespec string\n#extract any path from it and return that; ie, strip the filename\n#otherwise return \"\"\n\tl:=fs.len\n\tfor i:=l downto 1 do\n\t\tif chr(fs.[i]) in \"\\\\/:\" then\n\t\t\treturn leftstr(fs,i)\n\t\tfi\n\tod\n\treturn \"\"\nend\n\nexport func extractfile(fs)=\n#return filename portion of path fs\n\tp:=extractpath(fs)\n\tif p=\"\" then return fs fi\n\treturn rightstr(fs,-p.len)\nend\n\nexport func extractbasefile(fs)=\n#return filename portion of path fs\n\tf:=extractfile(fs)\n\tif f=\"\" then return \"\" fi\n\te:=extractext(f)\n\tif e.len then\n\t\tf:=leftstr(f,-e.len)\n\tfi\n\tif rightstr(f)=\".\" then\n\t\tf:=leftstr(f,-1)\n\tfi\n\treturn f\nend\n\nexport func extractext(fs,period=0)=\n#extract extension part of filespec fs\n#endings of \"xxx\" (no extension) and \"xxx.\" both return \"\"\n#with period=1, then \"xxx\" returns \"\" and \"xxx.\" returns . (so can be used to\n#override default extensions)\n\n\tf:=extractfile(fs)\n\tif f=\"\" then return \"\" fi\n\te:=\"\"\n\tdo\n\t\tn:=\".\" inx f\n\t\tif n.isfound then\n\t\t\te:=rightstr(f,-n)\n\t\t\tif e=\"\" then\t\t!. ending\n\t\t\t\treturn (period.defined and period|\".\"|\"\")\n\t\t\tfi\n\n\t\t\tf:=e\n\t\telse\n\t\t\texit\n\t\tfi\n\tod\n\n\treturn e\nend\n\nexport func changeext(file,newext,soft=0)=\n#normally face a change of extension to the file spec\n#use soft=1 to only change extension if no extension is present (a \".\" ending is an extension)\n\text:=extractext(file)\n\n\tp:=extractpath(file)\n\tbf:=extractbasefile(file)\n\tep:=extractext(file,1)\n\n\tif soft and ep<>\"\" then return file fi\t\t!has extension, don't change!\n\n\tif newext=\"\" then\n\t\treturn p+bf\n\telsif leftstr(newext)=\".\" then\n\t\treturn p+bf+newext\n\telse\n\t\treturn p+bf+\".\"+newext\n\tfi\nend\n\nexport func addpath(path,file)=\n#If file doesn't already have an absolute path (here, starting with \\ / or ?:)\n#then prepend 'path', which must end with \\ or /\n\tif leftstr(file) in \"/\\\\.\" or file.len>=2 and file.[2]=\":\" then\n\t\treturn file\n\tfi\n\treturn path+file\nend\n\nexport func addext(file,ext)=\n#add extension to filename, if it doesn't already have it's own extenstion\n\n\tif extractext(file,1)=\"\" then\n\t\treturn changeext(file,ext)\n\tfi\n\treturn file\nend\n\nexport func replacestr (s,a,b)=\n#if string a exists in s, then replace with b\n#return original or modified s\n\tdo\n\t\tn:=a inx s\n\t\tif not n.isfound then return s fi\n\t\ts:=leftstr(s,n-1)+b+rightstr(s,1-n-a.len)\n\tod\n\treturn \"\"\nend\n\nexport func parsecmdparams(cmd)=\n#cmd consists of:\n#blocks of text separated by whitespace or commas\n#each block is one of these formats\n# ...\t\tparam only\n# /...\t\tconsists of switches only\n# .../...\tparam followed by switches\n#return of (params,switches), where each is a list of strings\n#note that any correspondence between params and switches is lost; all switches assumed\n#to be global, but can appear anywhere\n#NOTE: cmd can also already be a list of blocks\n\n\tconst dash=\"-\"\n\n\tif cmd.islist then\n\t\tblocks:=cmd\n\telse\n\t\tsreadln(cmd)\n\t\tblocks::=()\n\t\tdo\n\t\t\tread a:\"s\"\n\t\t\tif a=\"\" then exit fi\n\t\t\tblocks append:=a\n\t\tod\n\tfi\n\n\tparams::=()\n\tswitches::=()\n\n\tfor x in blocks do\n\t\tn:=dash inx x\n!\t\tif n=0 then\t\t!pure param\n!\t\t\tparams append:=x\n\t\tif n=1 then\t\t!pure switches\n\t\t\tswitches concat:=splitstring(convlc(rightstr(x,-1)),\"/\")\n\t\telse\t\t\t!param followed by switches\n\t\t\tparams append:=x\n!\t\t\tparams append:=leftstr(x,n-1)\n!\t\t\tswitches concat:=splitstring(convlc(rightstr(x,-n)),\"/\")\n\t\tfi\n\tod\n\n\treturn (params,switches)\nend\n\nexport proc waitsec(secs)=\n#wait for given number of seconds, which can be a float. Call sleep()\n\tsleep(int(secs*1000))\nend\n\nexport func cmd_getswitches=\n#params is a list of strings, which\n#read all switches, and return a list of switch names (minus the \"/\")\n#each string can have more than one switch\n#some switches can follow a name in a string\n\n\tswitches::=()\n\tfor i:=1 to cmdparams.upb do\t\t!use 1..len in case called on <cmdparams> which has lwb 0\n\t\ts:=cmdparams[i]\n\t\tif leftstr(s) in \"-/\" then\n\t\t\tswitches append:=convlc(rightstr(s,-1))\n\t\tfi\n\tod\n\treturn switches\nend\n\nexport func cmd_getparams=\n#params is a list of strings\n#return list of actual params, not including any switches\n#switches are read separately using cmd_getswitches, but are not associated with\n#specific params. That would need to be done here (when / is detected in the middle\n#of a param, then make use readswitches. But to return that info, may be best to\n#create a parallel function)\n\n\tcmds::=()\n\n\tfor i:=1 to cmdparams.upb do\n\t\tpm:=cmdparams[i]\n!for pm in params do\n\t\tif leftstr(pm) in \"/-\" then\n\t\t\tnextloop\n\t\tfi\n!\tn:=\"/\" in pm\n!\tif n=0 then\n\t\t\tcmds append:=pm\n!\telse\n!\t\tcmds append:=leftstr(pm,n-1)\n!\tfi\n\tod\n\treturn cmds\nend\n\nexport func starttimer=\n#Start timer and remember ticks at this point\n\treturn stclock:=ticks()\nend\n\nexport func stoptimer=\n#Return number of ticks since starttimer was called, or last stoptimer\n#as the count is reset\n\n \td:=ticks()-stclock\n\tstclock:=ticks()\n\treturn d\nend\n\nexport func bnfact(n)=\n#n is limited to 9 million million million\n\n\tif n<=2 then\n\t\treturn longint(n)\n\tfi\n\n\tf:=1L\n\tg:=2L\n\tto n-1 do\n\t\tf:=f*g\n\t\tg:=g+1L\n\n\tod\n\treturn f\nend\n\nexport proc isort(a,?ll,?rr)=\n#inplace quicksort of a, which is anything that is indexable\n#ll rr are used for recursive calls\n\tif ll.isvoid then\n\t\tll:=a.lwb\n\t\trr:=a.upb\n\tfi\n\n\ti:=ll\n\tj:=rr\n\n\tpivot:=a[(ll+rr)%2]\n\n\trepeat\n\t\twhile pivot>a[i] and i<rr do ++i od\n\t\twhile pivot<a[j] and j>ll do --j od\n\t\tif i<=j then\n\t\t\tswap(a[i],a[j])\n\t\t\t++i\n\t\t\t--j\n\t\tfi\n\tuntil i>j\n\tif ll<j then isort(a,ll,j) fi\n\tif i<rr then isort(a,i,rr) fi\nend\n\nexport func sort(a)=\n#quicksort a and return newly sorted list. Duplicates a then uses isort\n\tb::=a\n\tisort(b)\n\treturn b\nend\n\nexport func pcerror(m)=\n#Force an interpreter error; advantage is that source location is reported.\n\n\tprintln \"Internal error:\",m\n\ta:=b+c\n\treturn 0\nend\n\n\n\n!=========================================\nexport proc insert(&a, b, c)=\n#insert value c just before index b\n#c is always a single value; to insert a sequence c, use insertn()\n\tn:=a.upb\n\ta[n+1]:=c\n\tfor i:=n downto b do\n\t\tswap(a[i+1],a[i])\n\tod\nend\n\nexport proc isort2(a,b,?ll,?rr)=\n#Like isort but also sorts b in parallel; sort order is determined by a however\n\tif ll.isvoid then\n\t\tll:=a.lwb\n\t\trr:=a.upb\n\tfi\n\n\ti:=ll\n\tj:=rr\n\n\tpivot:=a[(ll+rr)%2]\n\n\trepeat\n\t\twhile pivot>a[i] and i<rr do ++i od\n\t\twhile pivot<a[j] and j>ll do --j od\n\t\tif i<=j then\n\t\t\tswap(a[i],a[j])\n\t\t\tswap(b[i],b[j])\n\t\t\t++i\n\t\t\t--j\n\t\tfi\n\tuntil i>j\n\tif ll<j then isort2(a,b,ll,j) fi\n\tif i<rr then isort2(a,b,i,rr) fi\nend\n\nexport func left(a,n=1)=\n#return leftmost n elements of a (default left element)\n#when n is negative, all except rightmost -n\n\n\tif n>=0 then\n\t\treturn take(a,n)\n\telse\n\t\treturn take(a,a.len+n)\n\tfi\nend\n\nexport func right(a,n=1)=\n#return rightmost n elements of a (default right element)\n#when n is negative, all except leftmost -n\n\n\tif n>=0 then\n\t\treturn drop(a,a.len-n)\n\telse\n\t\treturn drop(a,-n)\n\tfi\nend\n\nexport func reverse(a)=\n#return reversed version of a\n#when 0, returns empty\n#when 1 element, returns a distinct, writeable copy\n\n\tif a.len=0 then\n\t\treturn makeempty(a)\n\tfi\n\tb::=a\n\n\tif a then\n\t\tfor i in a.bounds do\n\t\t\tb[a.upb-i+a.lwb]:=a[i]\n\t\tod\n\tfi\n\treturn b\nend\n\nexport func expandrange(a,step=1)=\n#Turn range a into a list of inclusive values\n\tx::=()\n\ti:=a.lwb\n\twhile i<=a.upb do\n\t\tx append:=i\n\t\ti+:=step\n\tod\n\treturn x\nend\n\nexport func head(a)=\n#return first element, or empty when empty\n\n\tif a.len then\n\t\treturn a[a.lwb]\n\telse\n\t\treturn makeempty(a)\n\tfi\nend\n\nexport func tail(a)=\n#return all except the first element\n#returns empty when only 0 or 1 elements\n\n\tcase a.len\n\twhen 0,1 then\n\t\treturn makeempty(a)\n\tesac\n\treturn a[2..$]\nend\n\nexport func init(a)=\n#return all except last element\n#returns empty when only 0 or 1 elements\n\tcase a.len\n\twhen 0,1 then\n\t\treturn makeempty(a)\n\tesac\n\treturn a[a.lwb..$-1]\nend\n\nexport func last(a)=\n#return last element, or empty\n\tif a.len then\n\t\treturn a[$]\n\telse\n\t\treturn makeempty(a)\n\tfi\nend\n\nexport func take(a,n)=\n#return first n elements from list/string a\n#returns () or \"\" when a is empty\n#n > 0 (n<=0 returns empty)\n\n\tif a.len=0 or n<=0 then\n\t\treturn makeempty(a)\n\tfi\n\tif n>=a.len then\n\t\treturn a\n\tfi\n\treturn a[a.lwb..a.lwb+n-1]\nend\n\nexport func drop(a,n)=\n#skips first n elements of a then returns the rest\n#returns () when empty, or skipping the whole list\n#n >= 0\n\n\tif a.len=0 or n>=a.len then\n\t\treturn makeempty(a)\n\tfi\n\tif n<=0 then\n\t\treturn a\n\tfi\n\treturn a[a.lwb+n..$]\nend\n\nexport func zip(a,b)=\n#return a list consisting of alternate elements from a and b\n#uses smaller of the two dimensions\n\n\tn:=min(a.len,b.len)\n\tc::=()\n\n!\tj:=a.lwb; k:=b.lwb\n\t(j, k) := (a.lwb, b.lwb)\n\n\tto n do\n\t\tc append:=a[j++]\n\t\tc append:=b[k++]\n\tod\n\treturn c\nend\n\nexport func repeatlist(a,n)=\n#duplicate a n times, and return the result\n#this ought to be built-in as a*n, but that's only implemented for a.len=1\n\n\tb:=makeempty(a)\n\tto n do\n\t\tb concat:=a\n\tod\n\treturn b\nend\n\n!export func minimum(a)=\n!#return minimum value of elements in a\n!\tif not a then\n!\t\treturn void\n!\tfi\n!\tx:=head(a)\n!\tfor y in tail(a) do\n!\t\tx min:=y\n!\tod\n!\treturn x\n!end\n!\n!export func maximum(a)=\n!#return maximum value of elements in a\n!\tif not a then\n!\t\treturn void\n!\tfi\n!\tx:=head(a)\n!\tfor y in tail(a) do\n!\t\tx max:=y\n!\tod\n!\treturn x\n!end\n!\n!export func sumlist(a)=\n!# apply \"+\" between all elements of a, and return result\n!# all elements must be compatble (all strings or all numbers for example)\n!# returns void then a is empty, or head(a) when just one element\n!\n!\tif not a then\n!\t\treturn void\n!\tfi\n!\tx:=head(a)\n!\tfor y in tail(a) do\n!\t\tx +:=y\n!\tod\n!\treturn x\n!end\n\nexport proc delete(&a,?b)=\n#delete element b\n\tn:=a.upb\n\tif b.isvoid then b:=n fi\n\n\tif n=b=1 then\n\t\ta::=()\n\t\treturn\n\tfi\n\n\tif b>n then return fi\n\tif b<a.lwb then return fi\n\tfor i:=b to n-1 do\n\t\tswap(a[i],a[i+1])\t\t\t!swap is faster for complex elements\n\tod\n!a[n]:=0\t\t!don't leave any heap data beyond new end of list\n\n\tresize(a,n-1)\nend\n\nexport proc resize(&a,n)=\n#hange the upper bound of a to n\n\n\tif n<a.lwb then\n\t\ta:=makeempty(a)\n\t\treturn\n\tfi\n\n\ta::=a[a.lwb..n]\t\t\t!duplication forces original to be freed\nend\n \nexport func makebits(data,t=bit)=\n#turn data (list, array, or bit array of different type) into a bit array\n\n\ta:=new(bits,t,data.bounds)\n\tfor i:=data.lwb to data.upb do\n\t\ta[i]:=data[i]\n\tod\n\treturn a\nend\n\nexport func makearray(data,t=i64)=\n#turn data (list, array of different type, or bit array) into an array of \n#given element type\n\n\ta:=new(array,t,data.bounds)\n\tfor i:=data.lwb to data.upb do\n\t\ta[i]:=data[i]\n\tod\n\treturn a\nend\n\nexport func tolist(a)=\n#convert a, a string, array or bits, to a list, and return that list\n\n\tcase a.basetype\n\twhen array,string,bits then\n\t\tb:=new(list,a.bounds)\n\t\tfor i,x in a do\n\t\t\tb[i]:=x\n\t\tod\n\t\treturn b\n!\twhen string then\n!\t\tb:=new(list,a.len)\n!\t\ti:=1\n!\t\tfor i,x in a do\n!\t\t\tb[i++]:=x\n!\t\tod\n!\t\treturn b\n\n\twhen list then\n\t\treturn a\n\telse\n\t\tpcerror(\"tolist:\"+tostr(a.type))\n\tesac\n\treturn 0\nend\n\nexport func toarray(a,?t)=\n#convert a, a list, string, array or bits, to an array, and return that array\n#can be used to turn one array type into another\n\tcase a.basetype\n\twhen list then\n\t\tif t.isvoid then\n\t\t\tif a then\n\t\t\t\tt:=a[a.lwb].type\n\t\t\telse\n\t\t\t\tt:=i32\n\t\t\tfi\n\t\tfi\n\n\twhen bits then\n\t\tif t.isvoid then\n\t\t\tt:=byte\n\t\tfi\n\n\twhen string then\n\t\tif t.isvoid then t:=byte fi\n\t\tb:=new(array,t,a.len)\n\t\tforeach i,x in a do\n\t\t\tb[i]:=x\n\t\tod\n\t\treturn b\n\twhen array then\n\t\tif t.isvoid then\n\t\t\treturn a\n\t\tfi\n\t\tu:=e.elemtype\n\t\tif t=u then return a fi\n\telse\n\t\tpcerror(\"toarray:\"+tostr(a.type))\n\tesac\n\tb:=new(array,t,a.bounds)\n\n\tfor i,x in a do\n\t\tb[i]:=x\n\tod\n\treturn b\nend\n\nexport func tobits(a,t=bit)=\n#convert a, a list, array or other bit array, into a bit array\n\n\tcase a.basetype\n\twhen list,array then\n\n\twhen bits then\n\t\tif a.elemtype=t then\n\t\t\treturn a\n\t\tfi\n\n\telse\n\t\tpcerror(\"tobits:\"+tostr(a.type))\n\tesac\n\tb:=new(bits,t,a.bounds)\n\tfor i,x in a do\n\t\tb[i]:=x\n\tod\n\treturn b\nend\n\nexport func listtostring(a)=\n#a should be a list or array\n#interpreter elements as characters and form a single string\n\ts:=\"\"\n\tfor x in a do\n\t\ts+:=chr(x)\n\tod\n\treturn s\nend\n\nexport func qversion=\n\treturn \"4.0\"\nend\n\nexport proc issort(a,?ll,?rr)=\n#Version of isort that works with dot-indexing\n\n\tif ll.isvoid then\n\t\tll:=a.lwb\n\t\trr:=a.upb\n\tfi\n\n\ti:=ll\n\tj:=rr\n\n\tpivot:=a.[(ll+rr)%2]\n\n\trepeat\n\t\twhile pivot>a.[i] and i<rr do ++i od\n\t\twhile pivot<a.[j] and j>ll do --j od\n\t\tif i<=j then\n\t\t\tswap(a.[i],a.[j])\n\t\t\t++i\n\t\t\t--j\n\t\tfi\n\tuntil i>j\n\tif ll<j then issort(a,ll,j) fi\n\tif i<rr then issort(a,i,rr) fi\nend\n\nexport func ssort(a)=\n#Version of sort() with dot-indexing, eg. strings, or int bits\n\n\tb::=a\n\tissort(b)\n\treturn b\nend\n\nexport func maketable(rows, cols, initval=0)=\n#Create a table: a rectangular list, set to either 0 or to initval\n#Each rows/cols is a range, or length\n\n\trow:=new(list,cols,initval)\n\n\ttable::=new(list,rows)\n\tif rows.isint then rows:=1..rows fi\n\n\tfor i in rows do\n\t\ttable[i]::=row\n\tod\n\n\treturn table\nend\n\nexport func mapv(op,a)=\n#Apply operator or suitable unary func to all elements of vector a,\n#and return new list \n\tb::=makeempty(a)\n\tfor i,x in a do\n\t\t\tb[i]:=mapss(op,x)\n\tod\n\treturn b\nend\n\nexport func mapvv(op,a,b)=\n#Apply op or func between corresponding elements of vectors a and b\n\tc::=makeempty(a)\n\tfor i,x in a do\n\t\tc[i]:=mapss(op,x,b[i])\n\tod\n\treturn c\nend\n\nexport func mapvs(op,a,bs)=\n#Apply op or func between elements of vector a and single value bs\n\tc::=makeempty(a)\n\tfor i,x in a do\n\t\tc[i]:=mapss(op,x,bs)\n\tod\n\treturn c\nend\n\nexport func mapsv(op,as,b)=\n#Apply op or func between elements of single value as and vector b\n!\tc::=makeempty(b)\n\tc::=()\n\tfor i,x in b do\n\t\tc[i]:=mapss(op,as,x)\n\tod\n\treturn c\nend\n\nexport func openfile(name,option=\"rb\")=\n#Open a file for reading. Uses C's fopen and default option is for binary mode\n#Return a valid file handle, which is an i64 value, or 0 when not found\n\tif not name.isstring or name=\"\" then\n\t\treturn 0\n\tfi\n\treturn fopen(name,option)\nend\n\nexport func createfile(name,options=\"wb\")=\n#Create a new file and return its handle, or 0 if there was an error\n\tif not name.isstring or name=\"\" then return 0 fi\n\treturn fopen(name,options)\nend\n\nexport func closefile(f)=\n#close the file associated with handle f\n\treturn fclose(f)=0\nend\n\nexport func checkfile(name)=\n#return 1 if file name exists, otherwise 0\n\tfile:=fopen(name,\"rb\")\n\tif file=0 then return 0 fi\n\tfclose(file)\n\treturn 1\nend\n\nexport func eof(f)=\n#return 1 if at eof on currently open file handle f\n\tc:=fgetc(f)\n\tif c=-1 then return 1 fi\n\n\tungetc(c,f)\n\treturn 0\nend\n\nexport func getfilesize(f)=\n#return size of bytes of currently open file f\n\tp:=ftell(f)\t\t\t!p=current position\n\tfseek(f,0,2)\t\t!get eof position\n\tsize:=ftell(f)\t\t!size in bytes\n\tfseek(f,p,0)\t\t!restore file position\n\treturn size\nend\n\nexport func getfilesize64(f)=\n#return size of bytes of currently open file f\n\tp:=_ftelli64(f)\t\t\t!p=current position\n\t_fseeki64(f,0,2)\t\t!get eof position\n\tsize:=_ftelli64(f)\t\t!size in bytes\n\t_fseeki64(f,p,0)\t\t!restore file position\n\treturn size\nend\n\nexport func setfilepos(f,offset)=\n#set position in file f to given byte offset\n\treturn fseek(f,offset,0)\nend\n\nexport func getfilepos(f)=\n#return current file position\n\treturn ftell(f)\nend\n\nexport func readrandom(f,mem,offset,size)=\n#read size bytes from file f, to memory at mem, from given offset\n#returns number of bytes read\n#mem needs to be a pointer\n#new file offset will be offset+size (or offset+byte read if smaller)\n\tfseek(f,offset,0)\n\treturn fread(mem,1,size,f)\nend\n\nexport func writerandom(f,mem,offset,size)=\n#write size bytes from memory at mem, to current file f from given offset\n#returns bytes written\n\tfseek(f,offset,0)\n\treturn fwrite(mem,1,size,f)\nend\n\nexport func readbytes(f,mem,size)=\n#read size bytes from current position in file f to mem\n\treturn fread(mem,1,size,f)\nend\n\nexport func writebytes(f,mem,size)=\n#write size bytes from mem to current position in f\n\treturn fwrite(mem,1,size,f)\nend\n\nexport func inbyte(file)=\t\t!INBYTE\n\treturn fgetc(file)\nend\n\nexport func inword(file)=\t\t!INWORD\n\tbb:=fgetc(file)\n\treturn fgetc(file)<<8+bb\nend\n\nexport func inlong(file)=\t\t!INLONG\n\tww:=inword(file)\n\treturn inword(file)<<16+ww\nend\n\nexport proc outbyte(file,x)=\t\t!OUTBYTE\n!writerandom(file,&x,getfilepos(file),1)\n\tfputc(x,file)\nend\n\nexport proc outword(file,x)=\t\t!OUTWORD\n\toutbyte(file,x iand 255)\n\toutbyte(file,x.[15..8])\nend\n\nexport proc outlong(file,x)=\t\t!OUTLONG\n\toutword(file,x iand 65535)\n\toutword(file,x>>16)\nend\n\nexport func instring(file)=\t\t!INSTRING\n\ts::=\"\"\n\tdo\n\t\tc:=inbyte(file)\n\t\tif c=0 then return s fi\n\t\ts+:=c\n\tod\n\treturn s\nend\n\nexport func appendfile(a,b)=\n#append line-based text file a to file b\n\n\tf:=openfile(a)\n\tif f=0 then return 0 fi\n\n\th:=openfile(b,\"ab\")\n\tif h=0 then return 0 fi\n\n\twhile not eof(f) do\n\t\treadln @f,x:\"l\"\n\t\tprintln @h,x\n\tod\n\n\tclosefile(f)\n\tclosefile(h)\n\treturn 1\nend\n\nexport func readblockfile(filename,doetx=0)=\n#read text file into a memory block\n#block is allocated here\n#return byte pointer to start of block, or nil\n#doetx=1 to add etx byte to end\n\n\tf:=openfile(filename)\n\tif f=0 then return nil fi\n\n\tn:=getfilesize(f)\n\treadfilesize:=n\n\n\ts:=malloc(n+doetx)\n\tif s=0 then abort(\"Readfile/Malloc fails\") fi\n\tsptr:=makeref(s,byte)\n\n!\treadrandom(f,&s,0,n)\n\treadrandom(f,s,0,n)\n\n\tif doetx then\n\t\t(sptr+n)^:=26\n\tfi\n\n\tclosefile(f)\n\treturn sptr\nend\n\nexport func readstrfile(filename,doetx=0)=\n#read text file into a single string\n#return string, or 0 if there was an error\n\n\tf:=openfile(filename)\n\tif f=0 then return 0 fi\n\n\tn:=getfilesize(f)\n\treadfilesize:=n\n\n\tptr:=malloc(n+1+doetx)\n\tif ptr=0 then abort(\"Readfile/Malloc fails\") fi\n\n\treadrandom(f,ptr,0,n)\n\tif doetx then\n\t\t(makeref(ptr,byte)+n)^:=26\n\tfi\n\n\tclosefile(f)\n\n\ts::=makestr(ptr,n+doetx)\n\n\tfree(ptr)\n\treturn s\nend\n\nexport func writestrfile(filename,s)=\n#read text file from a single string\n#return status\n\n\tf:=createfile(filename)\n\tif f=0 then return 0 fi\n\n\twriterandom(f,makeref(s,byte),0,s.len)\n\n\treturn closefile(f)\nend\n\nexport func readbinfile(filename)=\n#read binary file into byte array\n#return () (empty list not array) on error\n\n\tf:=openfile(filename)\n\tif f=0 then return 0 fi\n\n\tn:=getfilesize(f)\n\treadfilesize:=n\n\n\ta:=new(array,byte,n)\n\treadrandom(f,&a,0,n)\n\n\tclosefile(f)\n\treturn a\nend\n\nexport func writebinfile(filename,a)=\n#write binary file from byte array a\n#return status 1/0\n\n\tf:=createfile(filename)\n\tif f=0 then return 0 fi\n\n\twriterandom(f,(&a),0,a.len)\n\n\tclosefile(f)\n\treturn 1\nend\n\nexport func writeblockfile(filename,p,length)=\n#return status 1/0\n\n\tf:=createfile(filename)\n\tif f=0 then return 0 fi\n\n\tif not writerandom(f,p,0,length) then return 0 fi\n\n\tclosefile(f)\n\treturn 1\nend\n\nexport func erasefile(filename)=\n#delete given file, return status (check msdn)\n\treturn remove(filename)\nend\n\nexport func renamefile(oldfilename,newfilename)=\n#rename file, return status (check msnd)\n\treturn rename(oldfilename,newfilename)\nend\n\nexport func readtextfile(file)=\n#read text file into a list of strings; one per line\n#return list, or 0 on error\n\tf:=openfile(file)\n\tif not f then\n\t\treturn 0 \n\tfi\n\n\treadfilesize:=getfilesize(f)\n\ta::=()\n\n\twhile not eof(f) do\n\t\ta append:= sreadln(f)\n\tod\n\tclosefile(f)\n\treturn a\nend\n\nexport func writetextfile(file,a)=\n#write list of strings <a> as a text file <file>\n\tf:=createfile(file)\n\tif not f then return 0 fi\n\n\tfor i:=a.lwb to a.upb do\n\t\tprintln @f,a[i]\n\tod\n\tclosefile(f)\n\treturn 1\nend\n\nexport func readbinaryfile(filename,t)=\n#read binary file consisting of an array of type t values, into array of t\n#return () (empty list not array) on error\n\n\tf:=openfile(filename)\n\tif f=0 then return () fi\n\n\tn:=getfilesize(f)\n\treadfilesize:=n\n\telems:=n%t.bytes\n\n\ta:=new(array,t,elems)\n\treadrandom(f,&a,0,n)\n\n\tclosefile(f)\n\treturn a\nend\n\nexport func writebinaryfile(filename,data)=\n#write binary file from array of a fixed type to a file\n#return 1/0 status\n\treturn writeblockfile(filename,&data,data.bytes)\nend\n\nexport func confirm(m,caption=\"Confirm\",default=1)=\n#Pop-up box to ask for confirmationdefault=1/2/3 for yes/no/cancel button\n#Return 1 or 0\n\n\tflags:=0x20000+0x20\t!foreground window/question mark icon\n\tflags ior:=3\t\t!yes/no/cancel\n\n\tflags ior:=(default|0,0x100,0x200|0)\n\n\tstatus:=messagebox(nil,m,caption,flags)\n\treturn status=6\nend\n\nexport func messagebox(a=nil,mess,caption=\"Caption\",d=0)=\n#Standard Windows' Messagebox\n\treturn messageboxa(nil,mess,caption,d)\nend\n\nexport proc beep1=\n#Standard beep\n\tmessagebeep(0)\nend\n\nexport proc mem(mess)=\n\tstatic var startmem\n\tif startmem.isvoid then\n\t\tstartmem:=$smallmemtotal()\n\tfi\n\tprintln mess,,\":\",$smallmemtotal()-startmem\nend\n\nexport func reduce(op, a)=\n\tx:=head(a)\n\tfor y in tail(a) do\n\t\tx:=mapss(op,x,y)\n\tod\n\tx\nend\n",
(u64)"export func dirlist(s,t=1)=\n#s is a export filename (eg. \"*.dwg\") with possible drive/path; scan\n#directory for all matching files and return as a list of names\n#also returns total no. of files so far\n#t= +1\tInclude normal files, no sub-directory names\n#t= +2  Include directories\n#t= +3  Include all files including directories\n#t= +4  Convert to lower case\n#t=  0  Defaults to +1\n\n!CPL \"DIRLIST/WINLIB\"\n\n\tif t.isvoid then t:=1 fi\t\t\t!files only\n\n\tnfiles:=0\n\tdata::=()\n\tfile:=new(ws_finddata)\n\n\tif (hfind:=findfirstfile(s,&file))<>-1 then\t!at least one file\n\t\trepeat\n\t\t\tif (file.fileattributes iand 16) then\t\t!this is a directory\n\t\t\t\tif (t iand 2)=0 then goto skip fi\t\t!no directories\n\t\t\telse\t\t\t\t\t\t!this is a file\n\t\t\t\tif (t iand 1)=0 then goto skip fi\n\t\t\tfi\n\t\t\t++nfiles\n\t\t\tif (t iand 4) then\t\t\t\t!to lower case\n\t\t\t\tdata[nfiles]:=convlc(file.filename)\n\t\t\telse\n\t\t\t\tdata[nfiles]::=file.filename\n\t\t\tfi\n\tskip:\n\t\tuntil not findnextfile(hfind,&file)\n\t\tfindclose(hfind)\n\tfi\n\treturn data\nend\n\nexport func setcurrdir(newdir)=\n#Set current directory; return Windows' status code\n\treturn setcurrentdirectory(newdir)\nend\n\nexport func getcurrdir=\n#Return current directory name, always ends with \\ or /\n\ta:=new(array,byte,256)\n\tn:=getcurrentdirectory(a.len,&a[1])\n\n\tif n then\n\t\tdir::=makestr(&a[1],n)\n\telse\n\t\tdir:=\"\"\n\tfi\n\n\tif not (rightstr(dir) in \"\\\\/\") then dir +:= \"\\\\\" fi\n\treturn dir\nend\n\nexport func createdir(name)=\n#Create a new directory\n\treturn createdirectory(name,0)\nend\n\nexport func direxists(path)=\n#Return 1 if directory path exists\n\tconst file_attribute_directory=16\n\tconst invalid_file_attributes=-1\n\n\tattrib := getfileattributesa(path)\n\n\treturn attrib<>invalid_file_attributes and (attrib iand file_attribute_directory)\nend\n\n",
(u64)"importdll msvcrt=\n!importdll msvcr100=\n!importdll msvcr120=\n\tfunc \"malloc\"        (i64)ref byte\n\tfunc realloc(i64, i32)i64\n\tproc free        (i64)\n\tproc memset      (ref byte, i32, i32)\n\tproc memcpy      (ref byte, ref byte, i32)\n\tfunc memcmp      (ref byte, ref byte, i32)i32\n!\tfunc clock       :i32\n\tfunc ftell       (i64)i32\n\tfunc _ftelli64   (i64)i64\n\tfunc fseek       (i64, i32, i32)i32\n\tfunc _fseeki64   (i64, i32, i32)i64\n\tfunc fread       (ref byte, i32, i32, i64)i32\n\tfunc fwrite      (ref byte, i32, i32, i64)i32\n\tfunc getc   (i64)i32\n\tfunc ungetc (i32, i64)i32\n\tfunc fopen       (stringz, stringz)i64\n\tfunc fclose      (i64)i32\n\tfunc fgets       (ref byte, i32, i64)ref byte\n\tfunc remove      (stringz)i32\n\tfunc rename      (stringz, stringz)i32\n\tfunc getchar     :i32\n\tproc putchar     (i32)\n\tproc setbuf      (i64, i64)\n\n\tfunc rand        :i32\n\tproc srand       (i32)\n\n\tfunc puts        (stringz)i32\n\tfunc printf      (stringz, ...)i32\n\n\tfunc sprintf     (stringz, stringz, ...)i32\n\n\tfunc sscanf      (stringz, stringz, ...)i32\n\tfunc isalpha     (i32)i32\n\tfunc tolower     (i32)i32\n\tfunc strlen      (ref byte)i32\n\tfunc atoi        (stringz)i32\n\n!   clang func system      (stringz)i32\n\n\tfunc fgetc  (i64)i32\n\tfunc fputc  (i32,  i64)i32\n\tfunc fprintf     (i64, stringz, ...)i32\n\tfunc fputs       (stringz,  i64)i32\n\tfunc feof        (i64)i32\n!   clang func getch       :i32\n\tfunc _getch      :i32\n\nend\n\nglobal const c_eof     = -1\nglobal const seek_set  = 0\nglobal const seek_curr = 1\nglobal const seek_end  = 2\n\n",
(u64)"\nexport var popuplist::=()\nexport var focuslist::=()\nexport var npopups=0\nexport var message\nexport var messw, messa, messb\nexport var wpopup=nil\n\nrecord blockrec=\n\tvar posx, posy\t\t\t\t!pixel position of top left of block: relative to other\n\t\t\t\t\t\t\t\t!blocks, later within client area of containing window\n\tvar dimx,dimy\t\t\t\t!'client' area of block, including margins, cells and gaps\n\tvar celldimx, celldimy\t\t!size of each cell, in pixels\n\tvar cellsx, cellsy\t\t\t!number of identically-svert hoz and vertical controls\n\tvar gapx, gapy\t\t\t\t!gap between cells, in pixels\n\tvar marginx, marginy\t\t!margins around all cells\n\tvar labelwidth\t\t\t\t!for edit boxes, how many pixels on left are for label\n\tvar cellposx,cellposy\t\t!position of top left cell within block\n\tvar pitchx,pitchy\t\t\t!1st cell is at for edit boxes, how many pixels on left are for label\n\tvar blockstyle\t\t\t\t!style record for blocks\n\tvar name\t\t\t\t\t!name for debugging\n\tvar dir\t\t\t\t\t\t!'H' or 'V' for stepping direction\n\nend\n\nvar blocklist::=()\nvar nblocks=0\nvar\tcurrblock =nil\t\t\t\t!current blockrec\nvar\tcurrgroup =nil\t\t\t\t!rwindow corresponding to currblock\nvar\tcurrpopup =nil\t\t\t\t!rwindow for menu to contain current set of blocks\nvar cellx, celly\t\t\t\t!current cell within current block\nvar slposx,slposy,sldir\t\t\t!set by smcreate in case sl-functions are used\n\n!proc showblockinfo(block)=\n!println \"Block:      \",(block.name.isdef|block.name|\"\")\n!println \"Pos:        \",block.posx,block.posy\n!println \"Dim:        \",block.dimx,block.dimy\n!println \"CellDim:    \",block.celldimx,block.celldimy\n!println \"Gap:        \",block.gapx,block.gapy\n!println \"Cells:      \",block.cellsx,block.cellsy\n!println \"Gaps:       \",block.gapx,block.gapy\n!println \"Margins:    \",block.marginx,block.marginy\n!println \"Labelwidth: \",block.labelwidth\n!println \"Cellpos:    \",block.cellposx,block.cellposy\n!println \"Pitch:      \",block.pitchx,block.pitchy\n!println \"Dir:        \",block.dir\n!println\n!end\n\nexport proc sminit=\n\tblocklist::=()\n\tnblocks:=0\nend\n\nexport func smdefblock(?dim,cells=1,style=\"\",gap=0,labeldim=\"\",margin=0,dir='V')=\n!define a matrix of cells, all the same size, to be used as controls\n!dim\tis a the size of each cell, as pixel dims, or as a sample string\n!cells\tis a the hoz and vert cell count. Or it can be an int for vert column only\n!gap\tis the inter-cell gap, specified in pixels. Default is to use chx or chy.\n!\t\tgap can be (x,y), or just n for the same gap in hoz and vert\n!style\tCurrently, a string containing various styles and options. Will be\n!\tcompatible with old uses of these functions. Or can be replaced with a dict\n!label\tWhen specified, is a sample string givibg the length of the label on the left\n!\t\tof edit boxes; can also be a pixel width\n!return handle to block\n!also add block to export blocklist\n\n\tblock:=new(blockrec,0)\n\tblock.dir:=dir\n!block.dir:='H'\n\n\tif dim.isstring then\n\t\tblock.celldimx:=gxtextwidth(labelfont,dim)+smx*2\n\t\tblock.celldimy:=chy+smy*2\n\telse\n\t\t(block.celldimx,block.celldimy):=dim\n\tfi\n\n\tif cells.isint then\n\t\tblock.cellsx:=1\n\t\tblock.cellsy:=cells\n\telse\n\t\t(block.cellsx,block.cellsy):=cells\n\tfi\n\n\tif gap.isint then\n\t\tblock.gapx:=gap\n\t\tblock.gapy:=gap\n\telse\n\t\t(block.gapx,block.gapy):=gap\n\tfi\n\n\tif margin.isint then\n\t\tblock.marginx:=margin\n\t\tblock.marginy:=margin\n\telse\n\t\t(block.marginx,block.marginy):=margin\n\tfi\n\n\tif labeldim then\n\t\tif labeldim.isstring then\n\t\t\tblock.labelwidth:=gxtextwidth(labelfont,labeldim)+smx*2\n\t\telse\n\t\t\tblock.labelwidth:=labeldim\n\t\tfi\n\t\tblock.celldimx+:=block.labelwidth\n\tfi\n\n\tblock.blockstyle:=readstylestr(style)\n\n!CPL \"BLOCKSTYLE\",STYLE,BLOCK.BLOCKSTYLE\n\n!now work out overall size of the block, and the pitch between cells\n!this needs to take account of the frame size of each cell, which depends on\n!its border style\n!block position is done at a higher level using smorder\n\n\tbdx:=bdy:=1\t\t\t\t!use border widths of 0 for now (and assume same all round)\n\n\tblock.pitchx:=block.celldimx+bdx*2+block.gapx\t\t!hoz pitch\n\tblock.pitchy:=block.celldimy+bdy*2+block.gapy\t\t!vert\n\n!CPL \"PITCHY\",BLOCK.PITCHY,=BDY,=BLOCK.GAPY\n!CPL \"MARGINY\",BLOCK.MARGINY\n\n\tblock.cellposx:=block.marginx+bdx\t\t\t\t\t!position of client area of 1st cell\n\tblock.cellposy:=block.marginy+bdy\n\n\tblock.dimx:=block.pitchx*block.cellsx-block.gapx+block.marginx*2\n\tblock.dimy:=block.pitchy*block.cellsy-block.gapy+block.marginy*2\n\n\tblocklist[++nblocks]:=block\n\n\treturn block\nend\n\nexport func smmenusize(margin=chy)=\n!work out overall bounding box for all blocks, and relocate blocks (or set their\n!pos values) so that each is positioned within to the bounding box rectangle\n!return (dimx,dimy)\n\n!get bounding box in (x1,y1), (x2,y2)\n\tfor i,block in blocklist do\n\t\tif i=1 then\t\t\t\t!first block\n\t\t\tx1:=block.posx\n\t\t\ty1:=block.posy\n\t\t\tx2:=x1+block.dimx-1\n\t\t\ty2:=y1+block.dimy-1\n\t\telse\n\t\t\tx1 min:=block.posx\n\t\t\ty1 min:=block.posy\n\t\t\tx2 max:=block.posx+block.dimx-1\n\t\t\ty2 max:=block.posy+block.dimy-1\n\t\tfi\n\tod\n\n!now, need to relocate each block so they stay at the same position relative to\n!each other, but are positioned within the client area of an owner window\n!this effectively relocates (x1,y1) to (0,0), so the offset to be applied to\n!each block is -(x1,y1), plus (margin,margin)\n\n\tfor block in blocklist do\n\t\tblock.posx+:=margin-x1\n\t\tblock.posy+:=margin-y1\n\tod\n\n!return (x1-margin,y1-margin,x2-y1+margin*2+1,y2-y1+margin*2+1)\n\treturn (x2-x1+margin*2+1,y2-y1+margin*2+1)\nend\n\nexport proc smorder(blocks,dir='D')=\n!take a blocks, and arrange all in a line, relative to the first\n!dir is one of \"U\", \"D\", \"L\", \"R\" (or can be char codes or in lower case)\n!some block elements can be an integer specifing a gap between the blocks.\n!the gap is specified in pixels. The default gap is chx for hoz and chy for vertical\n!(***I THINK that the gap override is only between two blocks, so needs the reset to\n!default after. That mean also that the first list item must be a block***)\n\n\tif dir.isstring then\n\t\tdir:=asc(convuc(dir))\t\t\t!\"r\",\"R\" or 'R' possible, but not 'r'\n\tfi\n\n\tbdx:=bdy:=1\t\t\t\t\t\t!border widths for the blocks\n\n\tdx:=chx+bdx\n\tdy:=chy+bdy\n\tfirstblock:=1\n\n\tfor block in blocks do\n\t\tif block.isint then\t\t\t!is a gap\n\t\t\tdx:=block+bdx*2\n\t\t\tdy:=block+bdy*2\n\t\t\tnextloop\n\t\tfi\n\t\tif firstblock then\n\t\t\tlastblock:=block\n\t\t\tfirstblock:=0\n\t\t\tnextloop\n\t\tfi\n\t\tcase dir\n\t\twhen 'D' then\t\t\t!add below\n\t\t\tblock.posx:=lastblock.posx\n\t\t\tblock.posy:=lastblock.posy+lastblock.dimy+dy\n\t\twhen 'R' then\n\t\t\tblock.posx:=lastblock.posx+lastblock.dimx+dx\n\t\t\tblock.posy:=lastblock.posy\n\t\twhen 'U' then\t\t\t!add above\n\t\t\tblock.posx:=lastblock.posx\n\t\t\tblock.posy:=lastblock.posy-block.dimy-dy\n\t\twhen 'L' then\n\t\t\tblock.posx:=lastblock.posx-block.dimx-dx\n\t\t\tblock.posy:=lastblock.posy\n\t\tesac\n\t\tlastblock:=block\n\tod\nend\n\nproc showtestmenu(dim)=\n\twapplic:=gxcreatewindow(dim:dim,caption:\"test\")\n\n\tfor block in blocklist do\n\t\tgxbutton(pos:(block.posx,block.posy),dim:(block.dimx,block.dimy),caption:block.name,\n\t\towner:wapplic,style:[ss_border:bs_simplew])\n\tod\n\n\teventloop()\nend\n\nexport func smcreate(caption=\"\",?dim,?pos)=\n!create a pop-up menu window\n!dim ix (x,y) client area size in pixels\n!?pos is optional position, but can also existing button, then menu is placed nearby\n!Normally used after after series of smdefblock etc calls to setup a menu layout\n!Dim usually is a call to smmenusize which exactly contains the blocks\n!return handle to window\n\n\tif dim.isvoid then dim:=smmenusize() fi\n\n\tw:=gxcreatewindow(caption:caption, dim:dim, options:[wf_minmax:0],pos:pos)\n!\tw:=gxcreatewindow(caption:caption, dim:dim)\n\tw.windclass:=popup_class\n\tcurrpopup:=w\n\tsetforegroundwindow(w.gdi.hwnd)\n\n\tslposx:=chx\n\tslposy:=chy\n\tsldir:=(dim[1]>dim[2]|'H'|'V')\n\n\twpopup:=w\n\n\toldfocus:=wfocus\n\tif wfocus then\n\t\tgxkillfocus()\n\tfi\n\n\tpopuplist[++npopups]:=w\n\tfocuslist[npopups]:=oldfocus\t\t!of underlying window\n\n\treturn w\nend\n\nexport func smblock(block,border=0)=\n!set block as the current block for subsequent \n!unlike old versions of the library, an actual window is created for the block,\n!and a handle to that is returned. That is a child group control.\n\n\twblock:=gxpanel(pos:(block.posx,block.posy),dim:(block.dimx,block.dimy),\n\t\towner:currpopup, style:[ss_border:border])\n\tcurrblock:=block\n\tcurrgroup:=wblock\n\tcellx:=celly:=1\n\n\treturn wblock\nend\n\n!export func smpanel=\n!!set block as the current block for subsequent \n!!unlike old versions of the library, an actual window is created for the block,\n!!and a handle to that is returned. That is a child group control.\n!\n!\treturn gxpanel(pos:getsmpos(),dim:getsmdim(),\n!\t\towner:currgroup, style:[ss_border:border])\n!end\n!\nexport proc smclose=\n!NOTE: for nested menus, ie. invoking another popup menu while one is still\n!on the screen, requires:\n! * blocklist needs to be moved elsewhere, eg. to data field of current popup rwindow\n! * Then smclose can close blocks in that list, not the export one\n! * Global blocklist can be reused\n! * It might require that the owner window is disabled from being clicked on, but\n!   that will be awkward to do without disabling each control within it. Or perhaps\n!   this is a check that can be done within process_wmmessage, to see if click-window\n!   has an owner that has been disabled.\n!    Disabling is one with smcreate, and re-enableing here in smclose\n\n\tgxclose(wpopup)\n!\tfor block in blocklist do\n!\t\tblock:=0\n!!\t\tfreehandle(block)\n!\tod\n\n\toldfocus:=focuslist[npopups]\n\t--npopups\n\tif npopups then\n\t\twpopup:=popuplist[npopups]\n\t\tif oldfocus then\n\t\t\tgxfocus(oldfocus)\n\t\tfi\n\telse\n\t\twpopup:=nil\n\tfi\nend\n\n!export proc smoff=\n!\tsmclose()\n!end\n\nproc nextcell=\n!step cellx,y to next cell within current block\n\tif currblock.dir='V' then\n\t\t++celly\n\t\tif celly>currblock.cellsy then\n\t\t\tcelly:=1\n\t\t\t++cellx\n\t\tfi\n\telse\t\t\t\t\t!hoz\n\t\t++cellx\n\t\tif cellx>currblock.cellsx then\n\t\t\tcellx:=1\n\t\t\t++celly\n\t\tfi\n\tfi\nend\n\nfunc getsmpos=\n\treturn ((cellx-1)*currblock.pitchx+currblock.cellposx,\n        (celly-1)*currblock.pitchy+currblock.cellposy)\nend\n\nfunc getsmdim=\n\treturn (currblock.celldimx,currblock.celldimy)\nend\n\nfunc getslpos=\n\treturn (slposx,slposy)\nend\n\nfunc getsldim(s)=\n\tif s.isint then\n\t\treturn (s*chx+chx*2,chy+smy*2)\n\telse\n\t\treturn (gxtextwidth(labelfont,s)+smx*2,chy+smy*2)\n\tfi\nend\n\nproc nextslcell(dim)=\n\tif sldir='H' then\n\t\tslposx+:=dim[1]+chx\n\telse\n\t\tslposy+:=dim[2]+chy\n\tfi\nend\n\nexport func smcmd(caption,id=0,enable=1)=\n!create button within current block\n!caption can also be an integer code:\n! 0\t\tskip this cell (just leave a blank space)\n! -1\tinsert divider line\n!when id is omitted or is zero, then creates a static label instead\n\n\tif caption.isint then\n\t\tcase caption\n\t\twhen 0 then\n\t\twhen -1 then\n\t\tesac\n\t\tnextcell()\n\t\treturn nil\n\tfi\n\n\tif id=0 then\n\t\treturn smlabel(caption)\n\tfi\n\n\tss:=[ss_border:bs_ownpanel]\n\n\tw:=gxbutton(pos:getsmpos(), dim:getsmdim(), caption:caption, id:id,\n\t\towner:currgroup, style:ss, enable:enable)\n\tnextcell()\n\treturn w\nend\n\nexport func smhozscrollbar(id=0)=\n\tw:=gxhozscrollbar(owner:currgroup, pos:getsmpos(), dim:getsmdim(), id:id,\n\tstyle:[ss_border:bs_simplew])\n\n\tnextcell()\n\treturn w\nend\n\nexport func smvertscrollbar(id=0)=\n\tw:=gxvertscrollbar(owner:currgroup, pos:getsmpos(), dim:getsmdim(), id:id,\n\tstyle:[ss_border:bs_simplew])\n\n\tnextcell()\n\treturn w\nend\n\nexport func smlabel(caption)=\n\tpos:=getsmpos()\n\tdim:=(currblock.celldimx,currblock.celldimy)\n\n\tw:=gxlabel(pos:pos,dim:dim,caption:caption,owner:currgroup)\n\tnextcell()\n\treturn w\nend\n\nexport func smarrow(dir,id)=\n\tpos:=getsmpos()\n\tdim:=(currblock.celldimx,currblock.celldimy)\n\n\tw:=gxarrow(pos:pos,dim:dim,dir:dir,owner:currgroup)\n\tnextcell()\n\treturn w\nend\n\nexport func smtoggle(caption,linkvar,id=0,enable=1)=\n!create toggle control within current block\n\n\tw:=gxtoggle(pos:getsmpos(), dim:getsmdim(), caption:caption,\n\t\t\t\tlinkvar:linkvar,id:id,owner:currgroup, enable:enable,\n\t\t\t\tstyle:currblock.blockstyle)\n\n\tnextcell()\n\treturn w\nend\n\nexport func smselect(caption,linkvar,onvalue=1,id=0,enable=1)=\n!create toggle control within current block\n\n\tw:=gxselect(pos:getsmpos(), dim:getsmdim(), caption:caption,\n\t\t\tlinkvar:linkvar,onvalue:onvalue,\n\t\t\tid:id,owner:currgroup, enable:enable, style:currblock.blockstyle)\n\n\tnextcell()\n\treturn w\nend\n\nexport func smeditbox(?caption,linkvar,id=0,enable=1,?style)=\n!create toggle control within current block\n!CPL \"SMED\",CURRBLOCK\n\tpos:=getsmpos()\n\tdim:=getsmdim()\n\n!CPL =DIM\n\n\tif caption.isdef then\n\t\tgxlabel(pos:pos, dim:(currblock.labelwidth-chx,dim[2]), caption:caption,\n\t\t owner:currgroup)\n\t\tpos[1]+:=currblock.labelwidth\n\t\tdim[1]-:=currblock.labelwidth\n\tfi\n\n\tw:=gxeditbox(pos:pos, dim:dim,\n\t\tlinkvar:linkvar,\n\t\tid:id,owner:currgroup, enable:enable, style:getstyle(style))\n!\tgxdrawmode(w,dm_screenmemory)\n\n\tnextcell()\n\treturn w\nend\n\nexport func smlistbox(linkvar,id=0,enable=1)=\n\n!CPL =CURRBLOCK.CELLSY,\"(ROWS)\"\n!CPL =CURRBLOCK.PITCHY,\"(PITCH)\"\n!CPL =CURRBLOCK.CELLDIMY,\"(CELLDIMY)\"\n!CPL =CURRBLOCK.CELLPOSY,\"(OFFSET)\"\n!CPL =CURRBLOCK.GAPY,\"(GAPY)\"\n!CPL =CURRBLOCK.DIMY,\"(DIMY)\"\n!CPL \"LBDIMY=\",CURRBLOCK.DIMY-CURRBLOCK.MARGINY*2\n!CPL =CURRBLOCK.MARGINY\n\n!$SETDEBUG(1)\n\tw:=gxlistbox(pos:getsmpos(),\n\t\tdim:(currblock.dimx-currblock.marginx*2,currblock.dimy-currblock.marginy*2),\n\t\tlinkvar:linkvar,\n\t\tstyle:[ss_vscroll:1,\n\t\tss_border:bs_simplew],\n\t\trows:currblock.cellsy,\n\t\tpitch:currblock.pitchy,\n\t!\toffset:currblock.cellposy,\n\t\tid:id,owner:currgroup)\n!CPL \"SMLB2\"\n\treturn w\nend\n\nexport func sllabel(caption)=\n\tpos:=getslpos()\n\tdim:=getsldim(caption)\n\n\tw:=gxlabel(pos:pos,dim:dim,caption:caption,owner:currpopup)\n\tnextslcell(dim)\n\treturn w\nend\n\nexport func slcmd(caption,id=201,enable=1)=\n!create button within current block\n!caption can also be an integer code:\n! 0\t\tskip this cell (just leave a blank space)\n! -1\tinsert divider line\n!when id is omitted or is zero, then creates a static label instead\n\n\tpos:=getslpos()\n\tdim:=getsldim(caption)\n\tss:=[ss_border:bs_simplew]\n\n\tw:=gxbutton(pos:pos,dim:dim,caption:caption,id:id,owner:currpopup, \n\t\tstyle:ss)\n\tnextslcell(dim)\n\treturn w\nend\n\nexport func sleditbox(linkvar,width=30,id=0,enable=1)=\n\tpos:=getslpos()\n\tdim:=getsldim(width)\n\n\tw:=gxeditbox(pos:pos, dim:dim,\n\t\tlinkvar:linkvar,\n\t\tid:id,owner:currpopup)\n\n\tnextslcell(dim)\n\treturn w\nend\n\nexport func smok(caption=\"OK\",enable=1)=\n\treturn smcmd(caption,mm_ok,enable)\nend\n\nexport func smcancel(caption=\"Cancel\",enable=1)=\n\treturn smcmd(caption,mm_cancel,enable)\nend\n\nexport func slok(caption=\"OK\")=\n\treturn slcmd(caption,mm_ok)\nend\n\nexport func slcancel(caption=\"Cancel\")=\n\treturn slcmd(caption,mm_cancel)\nend\n\nexport proc smokcancel=\n\tsmok()\n\tsmcancel()\nend\n\nexport proc slinit(w)=\n\tcurrpopup:=w\n\tslposx:=chx\n\tslposy:=0\n\tsldir:=(w.dimx>w.dimy|'H'|'V')\nend\n\nexport proc settab(?a,?b,?c,?d,?e,?f,?g,?h,?i)=\n\tstatic var oldtabs\n\n\tif not a.defined then\n\t\tgxtabstops(oldtabs)\n\t\treturn\n\tfi\n\n\toldtabs:=gxtabstops()\n\tparams::=allparams()\n\n!\tgxtabstops(allparams())\n\tgxtabstops(param)\nend\n\nexport proc smupdatevalue(w)=\n\tgxupdate(w)\nend\n\nexport proc setfocus(w,?b)=\n\tgxfocus(w)\nend\n\nexport proc askmenu(a)=\n\tmessage:=gxaskmess(1)\n\tmessw:=currmess.wind\nend\n\nfunc readstylestr(s)=\n!read cell style string s, and return option dict\n\td:=new(dict)\n\tif s=\"\" then return d fi\n\n\ts:=convuc(s)\n\n\tforeach c in s do\n\t\tcase c\n\t\twhen 'X' then d{ss_marktype}:=check_mark\n\t\twhen 'M' then d{ss_marktype}:=radio_mark\n\t\twhen 'I' then d{ss_marktype}:=invert_mark\n\t\twhen 'R' then d{ss_returnmess}:=1\n\t\twhen 'N' then d{ss_noupdate}:=1\n\t\tesac\n\tod\n\treturn d\nend\n\nfunc getstyle(style)=\n\tif style.defined then\n\t\treturn readstylestr(style)\n\telse\n\t\treturn currblock.blockstyle\n\tfi\nend\n",
(u64)"\nexport type wt_word\t\t= u16\nexport type wt_bool\t\t= u32\nexport type wt_dword\t= u32\nexport type wt_wchar\t= u16\nexport type wt_char\t\t= byte\nexport type wt_ichar\t= stringz\nexport type wt_string\t= stringz\nexport type wt_ptr\t\t= ref byte\nexport type wt_wndproc\t= u64\n\nexport type wt_handle\t= ref void\nexport type wt_int\t\t= i32\nexport type wt_uint\t\t= u32\nexport type wt_long\t\t= i32\nexport type wt_wparam\t= u64\nexport type wt_lparam\t= u64\nexport type wt_size\t\t= u64\n\nexport type wt_wparam32\t= u32\nexport type wt_lparam32\t= u32\nexport type wt_handle32\t= u32\nexport type wt_ptr32\t= u32\nexport type wt_string32\t= u32\nexport type wt_wndproc32\t= u32\n\nexport type wt_wparam64\t= u64\nexport type wt_lparam64\t= u64\nexport type wt_handle64\t= u64\nexport type wt_ptr64\t= u64\nexport type wt_string64\t= u64\nexport type wt_wndproc64= u64\n\nexport type wt_result\t= u64\nexport type wt_intptr\t= u64\nexport type wt_coord\t= u32\n\nexport type ws_spoint= struct\n\ti16 x,y\nend\n\nexport type ws_srect=struct\n\ti16 leftx,top, rightx,bottom\nend\n\nexport type ws_charinfo=struct\n\tunion\n\t\twt_word\tunicodechar\n\t\twt_char\tasciichar\n\tend union\n\twt_word\t\tattributes\nend\n\nexport type ws_palette16=[0..15]i32\n\nexport type ws_console=struct\n\tws_spoint size,pos\n\twt_word attributes\n\tws_srect window\n\tws_spoint maxwindowsize\nend\n\nexport type ws_consoleex=struct\n\ti32 recsize\n\tws_spoint size,pos\n\twt_word attributes\n\tws_srect window\n\tws_spoint maxwindowsize\n\twt_word wpopup\n\ti32 fullscreen\n\tws_palette16 palette\nend\n\nexport type ws_keyevent = struct $caligned\n\twt_word\teventtype\n\t\twt_bool\tkeydown\n\t\twt_word\trepeatcount\n\t\twt_word\tvirtualkeycode\n\t\twt_word\tvirtualscancode\n\t\tunion\n\t\t\twt_word unicodechar\n\t\t\twt_char asciichar\n\t\tend\n\t\twt_dword controlkeystate\nend\n\nexport type ws_cursor=struct\n\ti32 size,visible\nend\n\nexport var hconsole, hconsolein\n\nexport const stdoutputhandle=0xffff_fff5\nexport const stdinputhandle=0xfffffff6\nexport const stderrorputhandle=0xfffffff4\nexport const invalidhandlevalue=0xffffffff\n\nexport const maxpathlen=260\n\ntype spath=stringz*maxpathlen\ntype sshort=stringz*14\n!\nexport type ws_filetime=struct\n\ti32 ftlow\n\ti32 fthigh\nend\n\nexport type ws_finddata=struct\n\ti32\t\tfileattributes\n\tws_filetime\tcreationtime\n\tws_filetime\tlastaccesstime\n\tws_filetime\tlastwritetime\n\ti32\t\tfilesizehigh\n\ti32\t\tfilesizelow\n\ti32\t\treserved0\n\ti32\t\treserved1\n\tspath\t\tfilename\n\tsshort\t\tshortfilename\nend\n\nexport type ws_systemtime = struct\n\tu16\tyear\n\tu16\tmonth\n\tu16\tdayofweek\n\tu16\tday\n\tu16\thour\n\tu16\tminute\n\tu16\tsecond\n\tu16\tmilliseconds\nend\n\nexport type ws_msg64 = struct $caligned\n\tref void\thwnd\n\ti32\t\tmessage\n\ti64\t\twparam\n\ti64\t\tlparam\n\ti32\t\ttime\n\ti32\t\tptx\n\ti32\t\tpty\nend\n\nexport type ws_point = struct\n\ti32 x, y\nend\n\nexport type ws_rect=struct\t\t!rect record occupying 16 bytes\n\tunion\n\t\tstruct\n\t\t\ti32 leftx,top, rightx,bottom\n\t\tend\n\t\tstruct\n\t\t\tunion i32 x,x1 end\n\t\t\tunion i32 y,y1 end\n\t\t\ti32 x2,y2\n\t\tend\n\tend\nend\n\nexport type ws_logbrush = struct\n\ti32 lbstyle\n\ti32 lbcolour\n\ti32 lbhatch\nend\n\nexport type ws_textmetrics = struct\n\ti32\theight\n\ti32\tascent\n\ti32\tdescent\n\ti32\ti32ernalleading\n\ti32\texternalleading\n\ti32\tavecharwidth\n\ti32\tmaxcharwidth\n\ti32\tweight\n\ti32\toverhang\n\ti32\tdigitizedaspectx\n\ti32\tdigitizedaspecty\n\tbyte\tfirstchar\n\tbyte\tlastchar\n\tbyte\tdefaultchar\n\tbyte\tbreakchar\n\tbyte\titalic\n\tbyte\tunderlined\n\tbyte\tstruckout\n\tbyte\tpitchandfamily\n\tbyte\tcharset\nend\n!=========================================\n\nexport type ws_bitmapv5header = struct\n\ti32\tsize\n\ti32\twidth\n\ti32\theight\n\tu16\tplanes\n\tu16\tbitcount\n\ti32\tcompression\n\ti32\tsizeimage\n\ti32\txpelspermeter\n\ti32\typelspermeter\n\ti32\tclrused\n\ti32\tclrimportant\n\ti32\tredmask\n\ti32\tgreenmask\n\ti32\tbluemask\n\ti32\talphamask\n\ti32\tcstype\n\t[1..9]i32 endpoints\n\ti32\tredgamma\n\ti32\tgreengamma\n\ti32\tbluegamma\n\ti32\tintent\n\ti32\tprofiledata\n\ti32\tprofilesize\n\ti32\treserved\nend\n\nexport type ws_bitmapfileheader = struct\n\twt_word\t\ttypex\n\twt_dword\tsize\n\twt_word\t\tres1, res2\n\twt_dword\toffbits\nend\n\nexport type ws_bitmapinfoheader = struct\n\twt_dword \tsize\n\twt_long\t\twidth\n\twt_long\t\theight\n\twt_word\t\tplanes\n\twt_word\t\tbitcount\n\twt_dword\tcompression\n\twt_dword\tsizeimage\n\twt_long\t\txpelspermetre\n\twt_long\t\typelspermetre\n\twt_dword\tclrused\n\twt_dword\tclrimportant\nend\n\nexport type ws_paintstruct = struct\n!\ti64\t\thdc\n\ti64\t\thdc\n\ti32\t\terase\n\tws_rect\t\tpaintrect\n\ti32\t\trestore\n\ti32\t\tincupdate\n\t[32]byte\trgbreserved\nend\n\n!32-BIT VERSION\nexport type ws_openfilename32 = struct\n\twt_dword\t\tstructsize\n\twt_handle32\t\towner\n\twt_handle32\t\tinstance\n\twt_string32\t\tfilter\n\twt_string32\t\tcustomfilter\n\twt_dword\t\tmaxcustfilter\n\twt_dword\t\tfilterindex\n\twt_string32\t\tfile\n\twt_dword\t\tmaxfile\n\twt_string32\t\tfiletitle\n\twt_dword\t\tmaxfiletitle\n\twt_string32\t\tinitialdir\n\twt_string32\t\ttitle\n\twt_dword\t\tflags\n\twt_word\t\t\tfileoffset\n\twt_word\t\t\tfileextension\n\twt_string32\t\tdefext\n\twt_lparam32\t\tcustdata\n\twt_wndproc32\thook\n\twt_string32\t\ttemplatename\n\twt_ptr32\t\treserved1\n\twt_dword\t\treserved2\n\twt_dword\t\tflagsex\nend\n\n!64-BIT VERSION\nexport type ws_openfilename64 = struct $caligned\n\twt_dword\t\tstructsize\n\twt_handle64\t\towner\n\twt_handle64\t\tinstance\n\twt_string64\t\tfilter\n\twt_string64\t\tcustomfilter\n\twt_dword\t\tmaxcustfilter\n\twt_dword\t\tfilterindex\n\twt_string64\t\tfile\n\twt_dword\t\tmaxfile\n\twt_string64\t\tfiletitle\n\twt_dword\t\tmaxfiletitle\n\twt_string64\t\tinitialdir\n\twt_string64\t\ttitle\n\twt_dword\t\tflags\n\twt_word\t\t\tfileoffset\n\twt_word\t\t\tfileextension\n\twt_string64\t\tdefext\n\twt_lparam64\t\tcustdata\n\twt_wndproc64\thook\n\twt_string64\t\ttemplatename\n\twt_ptr64\t\treserved1\n\twt_dword\t\treserved2\n\twt_dword\t\tflagsex\nend\n\nimportdll kernel32=\n\tfunc\t\"GetLastError\"\t\t\t\t\t:wt_dword\n\tfunc\t\"GetStdHandle\"\t\t\t\t\t(wt_dword)wt_handle\n\tfunc\t\"WriteConsoleA\" as writeconsole\t\t\t\t(wt_handle,wt_string,wt_dword,wt_ptr,wt_ptr)wt_bool\n\tfunc\t\"SetConsoleCursorPosition\"\t\t(wt_handle,wt_coord)wt_bool\n\tfunc\t\"GetConsoleScreenBufferInfo\"\t(wt_handle,wt_ptr)wt_bool\n\tfunc\t\"SetConsoleMode\"\t\t\t\t(wt_handle,wt_dword)wt_bool\n\tfunc\t\"WriteConsoleOutputA\" as writeconsoleoutput\t\t\t(wt_handle,wt_ptr,wt_coord,wt_coord,wt_ptr)wt_bool\n\n\tfunc\t\"GetConsoleScreenBufferInfoEx\"\t(wt_handle,wt_ptr)wt_bool\n\tfunc\t\"SetConsoleScreenBufferInfoEx\"\t(wt_handle,wt_ptr)wt_bool\n\tfunc\t\"GetConsoleWindow\"\t\t\t\t:wt_handle\n\n\tfunc\t\"SetConsoleTextAttribute\"\t\t(wt_handle,wt_word)wt_bool\n\tfunc\t\"SetConsoleTitleA\" as setconsoletitle\t\t\t\t(wt_string)wt_bool\n\tfunc\t\"ReadConsoleInputA\" as readconsoleinput\t\t\t(wt_handle,wt_ptr,wt_dword,wt_ptr)wt_bool\n\tfunc\t\"PeekConsoleInputA\"\t\t\t(wt_handle,wt_ptr,wt_dword,wt_ptr)wt_bool\n\tfunc\t\"FlushConsoleInputBuffer\"\t\t(wt_handle)wt_bool\n\tfunc\t\"SetConsoleWindowInfo\"\t\t\t(wt_handle,wt_bool,wt_ptr)wt_bool\n\tfunc\t\"SetConsoleScreenBufferSize\"\t(wt_handle,wt_coord)wt_bool\n\tfunc\t\"GetConsoleCursorInfo\"\t\t\t(wt_handle,wt_ptr)wt_bool\n\tfunc\t\"SetConsoleCursorInfo\"\t\t\t(wt_handle,wt_ptr)wt_bool\n\tfunc\t\"GetNumberOfConsoleInputEvents\"(wt_handle,wt_ptr)wt_bool\n\n\tfunc\t\"FindFirstFileA\" as findfirstfile\t\t(stringz,ref i32)i32\n\tfunc\t\"FindNextFileA\"  as findnextfile\t\t\t(i32,ref i32)i32\n\tfunc\t\"FindClose\"\t\t\t\t\t(i32)i32\n\tfunc\t\"SetCurrentDirectoryA\" as setcurrentdirectory\t(stringz)i32\n\tfunc\t\"GetCurrentDirectoryA\" as getcurrentdirectory\t(i32,i32)i32\n\tfunc\t\"CreateDirectoryA\" as createdirectory\t\t(stringz,i32)i32\n\tfunc\t\"GetFileAttributesA\"\t\t\t(stringz)i32\n\tfunc\t\"GetModuleHandleA\" as getmodulehandle\t\t(wt_string)wt_handle\n\tfunc\t\"GetTickCount\"\t\t\t\t\t\t\t\t:wt_dword\n\tfunc\t\"GlobalAlloc\"\t\t\t\t\t\t\t\t\t(wt_uint,wt_size)wt_handle\n\tfunc\t\"GlobalLock\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_ptr\n\tfunc\t\"GlobalUnlock\"\t\t\t\t\t\t\t\t(wt_handle)wt_bool\n\tfunc\t\"GlobalSize\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_size\n\n\tfunc\t\"GetSystemTime\"(ref byte)i32\n\tfunc\t\"Beep\"\t\t\t\t\t\t\t(wt_dword, wt_dword)wt_bool\n\tfunc\t\"SetConsoleCP\"\t\t\t\t\t\t\t\t(wt_uint)wt_bool\n\tfunc\t\"GetCommandLineA\" : stringz\nend\n\nimportdll user32=\n\tfunc\t\"CreateWindowExA\" as createwindowex\t\t(wt_dword, wt_string, wt_string, wt_dword, wt_int,wt_int,wt_int,wt_int,\n\t\t\t\t\t\t\t\t\t\t\t\t\t wt_handle, wt_handle, wt_handle, wt_ptr)wt_handle\n\n\tfunc \"GetMessageA\" as getmessage\t\t\t\t(wt_ptr, wt_handle, wt_uint, wt_uint)wt_bool\n\tfunc \"TranslateMessage\"\t\t\t\t\t\t\t(wt_ptr)wt_bool\n\tfunc \"DispatchMessageA\" as dispatchmessage\t\t(wt_ptr)wt_result\n\tfunc \"SetTimer\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_intptr,wt_uint,wt_ptr)wt_intptr\n\tfunc \"KillTimer\"\t\t\t\t\t\t\t\t(wt_handle,wt_intptr)wt_bool\n\tfunc \"SystemParametersInfoA\"\t\t\t\t\t(wt_uint,wt_uint,wt_ptr,wt_uint)wt_bool\n\tfunc \"GetSystemMetrics\"\t\t\t\t\t\t\t(wt_int)wt_int\n!\tfunc \"CreateMenu\"\t\t\t\t\t\t\t\t:int\n\tfunc \"AppendMenuA\" as appendmenu\t\t\t\t(wt_handle,wt_uint,wt_intptr,wt_string)wt_bool\n\tfunc \"GetDC\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_handle\n\tfunc \"ReleaseDC\"\t\t\t\t\t\t\t\t(wt_handle,wt_handle)wt_int\n\n\tfunc \"SendMessageA\" as sendmessage\t\t\t\t(wt_handle,wt_uint,wt_wparam,wt_lparam)wt_result\n\tfunc \"PostMessageA\" as postmessage\t\t\t\t(wt_handle,wt_uint,wt_wparam,wt_lparam)wt_bool\n\tfunc \"PeekMessageA\" as peekmessage\t\t\t\t(wt_ptr,wt_handle,wt_uint,wt_uint,wt_uint)wt_bool\n\tfunc \"BeginPaint\"\t\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_handle\n\tfunc \"EndPaint\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\tproc \"PostQuitMessage\"\t\t\t\t\t\t\t(wt_int)\n\tfunc \"LoadIconA\" as loadicon\t\t\t\t\t(wt_handle,wt_string)wt_handle\n\tfunc \"LoadCursorA\" as loadcursor\t\t\t\t(wt_handle,wt_string)wt_handle\n\tfunc \"SetCursor\"\t\t\t\t\t\t\t\t(wt_handle)wt_handle\n\tfunc \"DrawMenuBar\"\t\t\t\t\t\t\t\t(wt_handle)wt_bool\n\tfunc \"GetSystemMenu\"\t\t\t\t\t\t\t(wt_handle,wt_bool)wt_handle\n\tfunc \"CreateMenu\"\t\t\t\t\t\t\t\t:wt_handle\n\tfunc \"CreatePopupMenu\"\t\t\t\t\t\t\t:wt_handle\n\tfunc \"DestroyMenu\"\t\t\t\t\t\t\t\t(wt_handle)wt_bool\n\tfunc \"CheckMenuItem\"\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_uint)wt_dword\n\tfunc \"EnableMenuItem\"\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_uint)wt_bool\n\tfunc \"GetSubMenu\"\t\t\t\t\t\t\t\t(wt_handle,wt_int)wt_handle\n\tfunc \"GetMenuItemID\"\t\t\t\t\t\t\t(wt_handle,wt_int)wt_uint\n\tfunc \"GetMenuItemCount\"\t\t\t\t\t\t\t(wt_handle)wt_int\n\tfunc \"InsertMenuA\" as insertmenu\t\t\t\t(wt_handle,wt_uint,wt_uint,wt_intptr,wt_string)wt_bool\n\tfunc \"ModifyMenuA\" as modifymenu\t\t\t\t(wt_handle,wt_uint,wt_uint,wt_intptr,wt_string)wt_bool\n\tfunc \"RemoveMenu\"\t\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_uint)wt_bool\n\tfunc \"DeleteMenu\"\t\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_uint)wt_bool\n\n\tfunc \"DestroyWindow\"\t\t\t\t\t\t\t(wt_handle)wt_bool\n\tfunc \"InvalidateRect\"\t\t\t\t\t\t\t(wt_handle,wt_ptr,wt_bool)wt_bool\n\tfunc \"ValidateRect\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\tfunc \"ShowWindow\"\t\t\t\t\t\t\t\t(wt_handle,wt_int)wt_bool\n\tfunc \"GetClassLongA\" as getclassint\t\t\t(wt_handle,wt_int)wt_word\n\tfunc \"SetClassLongA\" as setclasslong\t\t\t(wt_handle,wt_int,wt_dword)wt_word\n\tfunc \"SetWindowTextA\" as setwindowtext\t\t\t(wt_handle,wt_string)wt_bool\n\tfunc \"GetWindowTextA\" as getwindowtext\t\t\t(wt_handle,wt_string,wt_int)wt_int\n\tfunc \"GetWindowTextLengthA\" as getwindowtextlength\t(wt_handle)wt_int\n\tfunc \"GetKeyState\"\t\t\t\t\t\t\t\t(wt_int)wt_word\n\n!\tfunc \"GetWindowLongPtrA\" as getwindowlongptr\t(wt_handle,wt_int)i64\n!\tfunc \"SetWindowLongPtrA\" as setwindowlongptr\t(wt_handle,wt_int,wt_int)i64\n\tfunc \"GetWindowLongA\" as getwindowlongptr\t\t(wt_handle,wt_int)i64\n\tfunc \"SetWindowLongA\" as setwindowlongptr\t\t(wt_handle,wt_int,i64)i64\n\n\tfunc \"GetClientRect\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\tfunc \"ClientToScreen\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\tfunc \"ScreenToClient\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\tfunc \"GetWindowRect\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\tfunc \"GetSysColor\" as getsyscolour\t\t\t\t(wt_int)wt_dword\n\tfunc \"GetScrollInfo\"\t\t\t\t\t\t\t(wt_handle,wt_int,wt_ptr)wt_bool\n\tfunc \"GetMenu\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_handle\n\tfunc \"SetMenu\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_handle)wt_ptr\n\tfunc \"TrackPopupMenu\"\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_int,wt_int,wt_int,wt_handle,wt_ptr)wt_bool\n\tfunc \"GetMenuState\"\t\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_uint)wt_uint\n\tfunc \"MessageBoxA\" \t\t\t\t\t\t\t\t(wt_handle a=nil,wt_string message, wt_string caption=\"Caption\", wt_uint b=0)wt_int\n\tfunc \"OpenClipboard\"\t\t\t\t\t\t\t(wt_handle)wt_bool\n\tfunc \"CloseClipboard\"\t\t\t\t\t\t\t:wt_bool\n\tfunc \"EmptyClipboard\"\t\t\t\t\t\t\t:wt_bool\n\tfunc \"GetClipboardData\"\t\t\t\t\t\t\t(wt_uint)wt_handle\n\tfunc \"SetClipboardData\"\t\t\t\t\t\t\t(wt_uint,wt_handle)wt_handle\n\tfunc \"MessageBeep\"\t\t\t\t\t\t\t\t(wt_uint x=0)wt_bool\n\tfunc \"SetActiveWindow\"\t\t\t\t\t\t\t(wt_handle)wt_handle\n\tfunc \"SetForegroundWindow\"\t\t\t\t\t\t(wt_handle)wt_bool\nend\n\nimportdll gdi32=\n\tfunc \"Rectangle\"\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int)wt_bool\n\tfunc \"RoundRect\"\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int)wt_bool\n\tfunc \"Ellipse\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int)wt_bool\n\tfunc \"Arc\"\t\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int)wt_bool\n\tfunc \"Chord\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int)wt_bool\n\tfunc \"Pie\"\t\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int)wt_bool\n\tfunc \"Polygon\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_handle,wt_int)wt_bool\n\tfunc \"TextOutA\" as textout\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_string,wt_int)wt_bool\n\tfunc \"TextOutW\" \t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_ptr,wt_int)wt_bool\n\tfunc \"GetStockObject\"\t\t\t\t\t\t\t(wt_int)wt_handle\n\tfunc \"SelectObject\"\t\t\t\t\t\t\t\t(wt_handle,wt_handle)wt_handle\n\tfunc \"CreateDCA\" as createdc\t\t\t\t\t(wt_string,wt_string,wt_string,wt_ptr)wt_handle\n\tfunc \"MoveToEx\"\t\t\t\t\t\t\t\t\t(wt_handle a,wt_int b,wt_int c,wt_ptr d=nil)wt_bool\n\tfunc \"CreatePen\"\t\t\t\t\t\t\t\t(wt_int,wt_int,wt_dword)wt_handle\n\tfunc \"CreateSolidBrush\"\t\t\t\t\t\t\t(wt_dword)wt_handle\n\tfunc \"CreateBrushIndirect\"\t\t\t\t\t\t(wt_ptr)wt_handle\n\tfunc \"LineTo\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int)wt_bool\n\tfunc \"GetPixel\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int)wt_dword\n\tfunc \"SetPixel\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_dword)wt_dword\n\tfunc \"SetGraphicsMode\"\t\t\t\t\t\t\t(wt_handle,wt_int)wt_int\n\tfunc \"CreateFontIndirectA\" as createfontindirect\t(wt_ptr)wt_handle\n\tfunc \"CreateFontA\" as createfont \\\n\t\t\t(wt_int height, wt_int width=0, wt_int escapement=0, wt_int orientation=0, wt_int bold=0,\n\t\t\t wt_dword italic=0, wt_dword underline=0, wt_dword strikeout=0, wt_dword charset=0,\n\t\t\t wt_dword outprec=0, wt_dword clipprec=0, wt_dword quality=0, wt_dword pitch=0, wt_string facename)wt_handle\n\tfunc \"SaveDC\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_int\n\tfunc \"GetTextMetricsA\" as gettextmetrics\t\t(wt_handle,wt_ptr)wt_bool\n\tfunc \"DeleteObject\"\t\t\t\t\t\t\t\t(wt_handle)wt_bool\n\tfunc \"RestoreDC\"\t\t\t\t\t\t\t\t(wt_handle,wt_int)wt_bool\n\tfunc \"GetTextExtentPoint32A\" as gettextextentpoint32\t(wt_handle,wt_string,wt_int,wt_ptr)wt_bool\n\tfunc \"GetObjectA\" as getobject\t\t\t\t\t(wt_handle,wt_int,wt_ptr)wt_int\n\tfunc \"CreatePalette\"\t\t\t\t\t\t\t(wt_ptr)wt_handle\n\tfunc \"GetWindowExtEx\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\tfunc \"CreateCompatibleBitmap\"\t\t\t\t\t(wt_handle,wt_int,wt_int)wt_handle\n\tfunc \"SetBitmapBits\"\t\t\t\t\t\t\t(wt_handle,wt_dword,wt_ptr)wt_long\n\tfunc \"SelectPalette\"\t\t\t\t\t\t\t(wt_handle,wt_handle,wt_bool)wt_handle\n\tfunc \"RealizePalette\"\t\t\t\t\t\t\t(wt_handle)wt_uint\n\tfunc \"SetDIBitsToDevice\"\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_dword,wt_dword,wt_int,wt_int,wt_uint,wt_uint,wt_ptr,wt_ptr,wt_uint)wt_int\n\tfunc \"StretchDIBits\"\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_ptr,wt_ptr,wt_uint,wt_dword)wt_int\n\tfunc \"SetStretchBltMode\"\t\t\t\t\t\t(wt_handle,wt_int)wt_int\n\tfunc \"PatBlt\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_dword)wt_bool\n\tfunc \"BitBlt\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_handle,wt_int,wt_int,wt_dword)wt_bool\n\tfunc \"SetROP2\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int)wt_int\n\tfunc \"CreateCompatibleDC\"\t\t\t\t\t\t(wt_handle)wt_handle\n\tfunc \"DeleteDC\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_bool\n\tfunc \"CreateBitmap\"\t\t\t\t\t\t\t\t(wt_int,wt_int,wt_uint,wt_uint,wt_ptr)wt_handle\n\tfunc \"CreateBitmapIndirect\"\t\t\t\t\t\t(wt_ptr)wt_handle\n\tfunc \"CreateDIBitmap\"\t\t\t\t\t\t\t(wt_handle,wt_ptr,wt_dword,wt_ptr,wt_ptr,wt_uint)wt_handle\n\tfunc \"CreateDIBSection\"\t\t\t\t\t\t\t(wt_handle,wt_ptr,wt_uint,wt_ptr,wt_handle,wt_dword)wt_handle\n\tfunc \"StretchBlt\"\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int, wt_int,wt_int,wt_handle, wt_int,wt_int,wt_int, wt_int,wt_dword)wt_bool\n\tfunc \"PlgBlt\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_ptr,wt_handle, wt_int,wt_int,wt_int,wt_int, wt_handle, wt_int,wt_int)wt_bool\n\tfunc \"SetTextColor\"  as settextcolour\t\t\t(wt_handle,wt_dword)wt_dword\n\tfunc \"SetTextAlign\"\t\t\t\t\t\t\t\t(wt_handle,wt_uint)wt_uint\n\tfunc \"SetTextJustification\"\t\t\t\t\t\t(wt_handle,wt_int,wt_int)wt_bool\n\tfunc \"SetBkColor\"  as setbkcolour\t\t\t\t(wt_handle,wt_dword)wt_dword\n\tfunc \"SetBkMode\"\t\t\t\t\t\t\t\t(wt_handle,wt_int)wt_int\n\tfunc \"GetBkColor\"  as getbkcolour\t\t\t\t(wt_handle)wt_dword\n\tfunc \"GetBkMode\"\t\t\t\t\t\t\t\t(wt_handle)wt_int\n\tfunc \"StartDocA\" as startdoc\t\t\t\t\t(wt_handle,wt_ptr)wt_int\n\tfunc \"StartPage\"\t\t\t\t\t\t\t\t(wt_handle)wt_int\n\tfunc \"EndPage\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_int\n\tfunc \"EndDoc\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_int\n\tfunc \"AbortDoc\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_int\n\tfunc \"GetViewportOrgEx\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\tfunc \"GetDIBits\"\t\t\t\t\t\t\t\t(wt_handle,wt_handle,wt_uint,wt_uint,wt_ptr,wt_ptr,wt_uint)wt_int\n\tfunc \"GetDIBColorTable\" as getdibcolourtable\t(wt_handle,wt_uint,wt_uint,wt_ptr)wt_uint\n\tfunc \"SetDIBColorTable\" as setdibcolourtable\t(wt_handle,wt_uint,wt_uint,wt_ptr)wt_uint\n\tfunc \"GetTextAlign\"\t\t\t\t\t\t\t\t(wt_handle)wt_uint\nend\n\nimportdll comdlg32=\n\tfunc \"GetOpenFileNameA\"\t\t\t\t\t\t\t(wt_ptr)wt_bool\n\tfunc \"GetSaveFileNameA\"\t\t\t\t\t\t\t(wt_ptr)wt_bool\nend\n",
(u64)"!MODULE winmessages\nmodule sysp\n\nmodule winconsts\nmodule winapi\nmodule wingxlib\nmodule gxmisc\n\nVAR GGDI\n\nexport var debug=0\n\nexport var messhandlertable=9000\t!message by windowclass table of message handlers\nexport var actionhandlertable\n\nexport var chx,chy\t\t!default text sizes for menus\nexport var cha,chd\t\t!ascender/descender heights\nexport const smx=3\t\t!margins around button text in pixels (both sides)\nexport const smy=4\nexport var arrowdim\nexport var markdim\nexport var buttonheight\nexport var listrowheight\nexport const labelfont=1\n\nexport var tabstops=(8,)*20\n\nexport var wmouse=nil\nexport var wfocus=nil\nexport var wprinter=nil\nexport var lastmousepos=nil\nexport var lastmousewindow=nil\nexport var currmousewindow=nil\n\nexport var mousepos\nexport var mousesw\nexport var quitmess=0\nexport var dragmode=0\nexport var lastbuttontime=0\n\nexport var buttonstate=0\nexport var wmessagetable\t\t!see initdata\nexport var buttontable\t\t!see initdata\n\nconst maxqueuesize=100\nexport var messagequeue=()\nexport var nmessages=()\n\nconst dragtol=1\n\nexport var copymode=4\n\nvar vktomesstable\n\n!Describe gx window (also bitmap, control or child window)\nexport record rwindow =\n\n\tvar windclass\t\t\t\t\t! type of window (popup, control, etc)\n\tvar flags\t\t\t\t\t\t! general purpose flags\n\tvar style\t\t\t\t\t\t! stylerec entry\n\tvar name\t\t\t\t\t\t! Optional debugging name\n\n\tvar owner\t\t\t\t\t\t! owner when this is a child window\n\tvar index\t\t\t\t\t\t! index 1..n when part of a list (eg. .childlist of owner)\n\tvar childlist\t\t\t\t\t! list of child windows\n\n!framepos/dim describe the overall window size including Windows or gx-drawn borders,\n\tvar frameposx, frameposy\t\t! top left of frame, in screen or owner window client coords\n\tvar framedimx, framedimy\t\t! pixels dims including frame and caption\n\n\tvar\tposx, posy\t\t\t\t\t! Pixel pos client area as seen by application\n\tvar\tdimx, dimy\t\t\t\t\t! Pixel dims of client area as seen by application\n\n\tvar gdi\t\t\t\t\t\t\t! (rgdistate)\tgdi state record\n\n\tvar enable\t\t\t\t\t\t! 1 to enable toggle/button/arrow etc, 0 to disable and show greyed out\n\tvar id\t\t\t\t\t\t\t! button/et al: command code associated with control\n\tvar text\t\t\t\t\t\t! caption or label or primary data\n!\t\tvar data \t@text\n\tvar linkvar\t\t\t\t\t\t! pointer to linked var for toggle/select/scroll\n\tvar gindex\t\t\t\t\t\t! window export index\n\n\tvar attrs\t\t\t\t\t\t! general purpose attributes, depends on window class\n\n!bitmap data\n\tvar pixelbits\t\t\t\t\t! 1, 4, 16, 24, 32 bits per pixel\n\tvar pixelptr\t\t\t\t\t! pointer to image data\n\tvar pixelbytes\t\t\t\t\t!bytes/pixel (round up to next whole byte)\n\tvar linebytes\t\t\t\t\t!bytes/per row, also pitch\n\tvar framebytes\n\tvar paltype\t\t\t\t\t\t!0, or palette type\n\n\tvar closed\nend\n\nexport enumdata paltypenames =\n\t(no_pal=0,\t\t$),\n\t(greyscale_pal,\t$),\n\t(tinted_pal,\t$),\n\t(colour_pal,\t$),\n\t(uv_pal,\t\t$),\nend\n\nexport type rgdistate = struct\n\tref void hwnd\t\t\t\t! win32 handle (hwnd)\n\tref void hdc\t\t\t\t! 0 or device context handle for hwnd\n\tref void hwnd2\t\t\t\t! secondary window/memory backup\n\tref void hdc2\t\t\t\t! 0 or hwnd3 DC screen or memory hdc\n\ti64 originalwndproc\t! win32 control handling proc\n\tunion\n\t\ti64 menuhandle\t\t! win32 handle to any menubar\n\t\ti64 oldbmobj\t\t\t!used for bitmaps\n\tend\n\ti32 drawmode\t\t\t! see dm- drawcodes\n\ti32 updated\t\t\t\t! 1 when pixels have changed\n\n\ti32 posx,posy\t\t\t!current drawing position\n\ti32 pencolour\t\t\t! current line colour (rgb)\n\ti32 penwidth\t\t\t! current line width\n\n\ti32 penstyle\t\t\t! current line dotted style\n\n\ti32 xormode\t\t\t\t! 0=normal, 1=xor\n\ti32 brushcolour\t\t\t! current brush colour\n\ti32 brushstyle\t\t\t! current brush style (bs_solid/etc)\n\ti32 brushpattern\t\t! current brush hatch/bitmap pattern\n\n\ti32 font\t\t\t\t! current font number\nend\n\nexport enumdata marktypenames =\n\t(no_mark=0,\t\t\t$),\n\t(radio_mark,\t\t$),\n\t(tick_mark,\t\t\t$),\n\t(check_mark,\t\t$),\n\t(invert_mark,\t\t$),\n\t(outline_mark,\t\t$),\n\t(bold_mark,\t\t\t$),\nend\n\nexport enumdata hilitetypenames =\n\t(no_hilite=0,\t\t$),\n\t(invert_hilite,\t\t$),\n\t(outline_hilite,\t$),\nend\n\nexport record togglerec=\t\t!for toggle and select\n\tvar textoffset\n\tvar onvalue\nend\n\nexport record scrollbarrec=\t\t!scroll bars\n\tvar limits\t\t\t\t\t\t!range\n\tvar span\t\t\t\t\t\t!portion of limits represented by visible data (0 means not relevant)\n\tvar thumbsize\t\t\t\t\t!pixel length of thumb (vert or hoz extent along scrollbar)\n\tvar thumbspan\t\t\t\t\t!pixels that the thumb can move\n\tvar thumbpos\t\t\t\t\t!current thumb position in pixels from start of scrollbar\n\tvar currpos\t\t\t\t\t\t!current position, will be in limits range\n\tvar dragmode\t\t\t\t\t!1 if thum currently being dragged\nend\n\nexport record editboxrec=\t\t!edit boxes\n!current char position within edit text\n!if text has N characters, then position will be 1..N+1\n!The position is just /before/ the stated character\n!This matches column position within the MED text editor\n\tvar currpos\t\t\t\t\t\t!cursor position, 1 to N+1 (N=chars in edit text)\n\tvar caretpos\t\t\t\t\t!current pixel position of any caret\n\tvar textpos\t\t\t\t\t\t!start x,y pixel position of text, set by gxjust_text\nend\n\nexport record listboxrec=\n\tvar rows\t\t\t\t\t\t!number of displayed rows\n\tvar pagepos\t\t\t\t\t\t!data position corresponding to row 1 of display\n\tvar length\t\t\t\t\t\t!all data items, same as linkvar^.len\n\tvar currpos\t\t\t\t\t\t!cursor position within the data, 1 to N (can be 0 when N=0)\n\tvar pitch, offset\t\t\t\t!pixel dims of each row\nend\n\nexport record rmessage=\n\tvar\t\twind\t\t!main window/button associated with message\n\tvar\t\tmenuwind\t!top-level window owning button\n\tvar\t\tmessage\t\t!message number\n\tvar\t\tstate\t\t!button/shift key state at time of message\n\tvar\t\ta,b\t\t\t!general purpose data, depends on message\n\tvar\t\tx,y\t\t\t!current mouse position\nend\n\n!contains many different flags and style codes for assorted controls\n!But at one mostly byte each, is very low overhead (32 values is same as two vars)\n\nexport type stylerec = struct\n\tbyte\tborder\t\t\t\t!bs_ code\n\tbyte\tjustify\t\t\t\t!'L', 'R', 'C'\n\tbyte\tvjustify\t\t\t!'T', 'B', 'M'\n\tbyte\twindbgnd\t\t\t!colour index for window background\n\tbyte\ttextfgnd\t\t\t!colour index\n\tbyte\ttextbgnd\t\t\t!\n\tbyte\tbgndmode\t\t\t!\n\tbyte\ttextfont\t\t\t!font index\n\tbyte\ttextsize\t\t\t!pixel size\n\tbyte\ttextbold\t\t\t!1 if bold\n\tbyte\ttextitalic\t\t\t!1 if italic\n\tbyte\tispassword\t\t\t!1 when edit field is a password\n\tbyte\tfieldwidth\t\t\t!edit field maximum char width\n\tbyte\tdir\t\t\t\t\t!'L','R','U','D'\n\tbyte\tmarktype\t\t\t!xxx_mark style, or:\n\tbyte\thilitetype\t\t\t!xxx_hilite style\n\tbyte\tiframe\t\t\t\t!1: pos/dim include frame\n\tbyte\timark\t\t\t\t!1: pos/dim include mark for toggle/select\n\tbyte\thscroll\t\t\t\t!1: include windows-drawn hoz scroll bar\n\tbyte\tvscroll\t\t\t\t!1: include windows-drawn vert scroll bar\n\tbyte\tlbchange\t\t\t!1: return mm_change on list boxes when row has changed\n\tbyte\treturnmess\t\t\t!1: return id code when clicking toggle/select/editbox\n\tbyte\tnoupdate\t\t\t!1: don't change or allow editing on toggle/select/editbox\nend\n\nexport record rpoint = var x,y end\nexport record rrect  =\n\tvar pos,dim\nend\n\nexport record rframe =\n\tvar x1,y1,x2,y2\nend\n\nexport record getrec=\n\tfun getbounds(&self)= 0\n\tfun getitem(&self,n)= 0\n\tfun getstritem(&self,n)= \"\"\nend\n\nexport enumdata stylenames =\t! (default)\n\t(ss_border,\t\t\t$),\t\t! Border style (wbs_simple)\n\t(ss_justify,\t\t$),\t\t! 'L' 'C' 'R'\tHorizontal text justify ('L')\n\t(ss_vjustify,\t\t$),\t\t! 'T' 'M' 'B'\tVertical text justify ('M' for buttons)\n\t(ss_textfgnd,\t\t$),\t\t! Text colour index (black)\n\t(ss_textbgnd,\t\t$),\t\t! Text background colour index (if opaque mode) (0)\n\t(ss_bgndmode,\t\t$),\t\t! 0\n\t(ss_textfont,\t\t$),\t\t! Text font number (1)\n\t(ss_textsize,\t\t$),\t\t! (0)\n\t(ss_textbold,\t\t$),\t\t! (0)\n\t(ss_textitalic,\t\t$),\t\t! (0)\n\t(ss_ispassword,\t\t$),\t\t! (0)\n\t(ss_marktype,\t\t$),\t\t! Toggle/select mark style (radio_mark)\n\t(ss_hilitetype,\t\t$),\t\t! Toggle/select hilite style (no_hilite)\n\t(ss_iframe,\t\t\t$),\t\t! Whether pos and dim include frame width (also caption bar/menu for windows)\n\t(ss_windbgnd,\t\t$),\t\t! Background colour of window or button (ltgrey)\n\t(ss_imark,\t\t\t$),\t\t! Background colour of window or button (ltgrey)\n\t(ss_hscroll,\t\t$),\t\t! (0)\n\t(ss_vscroll,\t\t$),\t\t! (0)\n\t(ss_lbchange,\t\t$),\t\t! (0)\n\t(ss_returnmess,\t\t$),\t\t! (0) Toggle/select/editbox, return id when clicked\n\t(ss_noupdate,\t\t$),\t\t! (0) Toggle/select/editbox, don't change or allow edit\nend\n\nexport enumdata drawmodenames =\n\t\t\t\t\t\t\t\t!HDC\tHDC2\tRestore\n\t(dm_screen=0,\t\t$),\t\t!screen\t--\t\tCustom routine\tDraw directly to screen; no mem backup\n\t(dm_memory,\t\t\t$),\t\t!memory\t--\t\tNA\t\t\t\tDraw to memory only; no screen hdc (eg. bitmap)\n\t(dm_screenmemory,\t$),\t\t!screen\tmemory\tBlit mem->scr\tDraw to both screen and memory at same time\n\t(dm_memoryscreen,\t$),\t\t!memory\tscreen\tBlit mem->scr\tDraw to memory; update screen periodically\nend\n\n!var windowlist=nil\n\nexport enumdata wfnames =\n\t(wa_rightclick=0,\t$),\t\t!allow right click\n\t(wa_middleclick,\t$),\t\t!allow middle click\n\t(wa_leftdbl,\t\t$),\t\t!allow left double click\n\t(wa_rightdbl,\t\t$),\t\t!allow right double click\n\t(wa_middledbl,\t\t$),\t\t!allow middle double click\n\t(wa_leftdrag,\t\t$),\t\t!allow left drag\n\t(wa_rightdrag,\t\t$),\t\t!etc\n\t(wa_middledrag,\t\t$),\n\t(wa_autoupdate,\t\t$),\t\t!auto update screen for toggles/etc\n\t(wa_tab,\t\t\t$), \t!allow tab to switch to next button which has watab\n\t(wa_strvar,\t\t\t$), \t!1 for listbox linkvar to use string not index\n\t(wa_retmess,\t\t$), \t!1 for button to return .value as mess not qmcommand\n\t(wa_retsel,\t\t\t$), \t!1 for button to return .value as mess not qmcommand\n\t(wa_memory,\t\t\t$), \t!1 when hdc/hdcmem have been switched, hdc points to memory dev\n\t(wa_maximised,\t\t$),\t\t!1 when maximised, 0 when normal/minimised\n\t(wa_param1,\t\t\t$), \t!general purpose control-specific flags\n\t(wa_param2,\t\t\t$), \n\t(wa_useenter,\t\t$),\n\t(wa_closed,\t\t\t$),\t\t!whether window has been closed\n\n\t(wa_$last,\t\t\t$)\nend\n\nconst wa_needdbl\t= wa_param1\t!1 requires double-click on listbox to return wmcommand\nconst wa_editdd\t\t= wa_param2\t!1 means editable dropdown box\n\n!GX border styles, used for child windows.\n!some child windows\nexport enumdata bsnames, bscat, bswidths=\n\t(bs_none=0,\t\t$,\t0,\tws_rect(0,0,0,0)),\t\t\t!no border\n!\t(bs_windows,\t$,\t'W',\tws_rect(0,0,0,0)),\t\t\t!windows-drawn, but no own-drawn border\n\t(bs_simplew,\t$,\t'W',\tws_rect(1,1,1,1)),\t\t\t!single 1-pixel black line, windows drawn\n\t(bs_simple,\t\t$,\t'X',\tws_rect(1,1,1,1)),\t\t\t!single 1-pixel black line\n\t(bs_thick,\t\t$,\t'X',\tws_rect(2,2,2,2)),\t\t\t!2-pixel border\n\t(bs_panel,\t\t$,\t'X',\tws_rect(1,1,1,1)),\t\t\t!raised panel, 1-pixel\n\t(bs_inset,\t\t$,\t'X',\tws_rect(1,1,1,1)),\t\t\t!inset panel, 1-pixel\n\t(bs_ownsimple,\t$,\t'I',\tws_rect(0,0,0,0)),\t\t\t!included inset panel, 1-pixel (drawn as part of client area)\n\t(bs_ownpanel,\t$,\t'I',\tws_rect(0,0,0,0)),\t\t\t!included inset panel, 1-pixel (drawn as part of client area)\n\t(bs_owninset,\t$,\t'I',\tws_rect(0,0,0,0)),\t\t\t!included inset panel, 1-pixel\n\t(bs_testext,\t$,\t'X',\tws_rect(10,10,10,10)),\n\t(bs_testint,\t$,\t'I',\tws_rect(8,8,8,8)),\n\t(bs_dummy,\t\t$,\t0,\tws_rect(0,0,0,0))\nend\n\nexport enumdata windowclassnames, defaultborderstyles =\n\t(no_class=0,\t\t$,\tbs_none),\t\t\t!Unassigned\n\t(window_class,\t\t$,\twbs_resize),\t\t!Main window\n\t(memwindow_class,\t$,\twbs_none),\t\t\t!memory backup to any window\n\t(popup_class,\t\t$,\twbs_thick),\t\t\t!Pop-up window (forms a stack)\n\t(float_class,\t\t$,\tbs_thick),\t\t\t!Independent window\n\t(bitmap_class,\t\t$,\tbs_none),\t\t\t!(image handling)\n\t(screen_class,\t\t$,\tbs_none),\t\t\t!Describes the desktop screen (not owned by my app)\n\t(printer_class,\t\t$,\tbs_none),\t\t\t!Used for printing\n\n\t(group_class,\t\t$,\tbs_inset),\t\t\t!Used mainly for grouping other buttons (eg. for Smdefblock)\n\t(panel_class,\t\t$,\tbs_inset),\t\t\t!General purpose panel for drawing in etc\n!\t(button_class,\t\t$,\tbs_panel),\t\t\t!Click button\n\t(button_class,\t\t$,\tbs_simplew),\t\t!Click button\n\t(toggle_class,\t\t$,\tbs_none),\t\t\t!Toggle button (can be composite, eg mark and label)\n\t(select_class,\t\t$,\tbs_none),\t\t\t!Select from several choices\n\t(editbox_class,\t\t$,\tbs_simplew),\t\t!Single-line edit control\n\t(scrollbar_class,\t$,\tbs_simplew),\t\t!Hoz or vert scroll bar (Some windows can also have Windows-drawn scroll bars)\n\t(listbox_class,\t\t$,\tbs_simplew),\t\t!List of options (scrollable usually)\n\t(dropdown_class,\t$,\tbs_none),\t\t\t!Button revealing attached listbox when clicked\n\t(framebar_class,\t$,\tbs_panel),\t\t\t!Left or right full-height panel used for toolboxes etc\n\t(statusbar_class,\t$,\tbs_panel),\t\t\t!Top or bottom full-width panel used for scrollbars\n\t(tooltip_class,\t\t$,\tbs_simplew),\t\t!Tooltops displayed when hovering over enabled buttons\n\t(arrow_class,\t\t$,\tbs_ownpanel),\t\t!Click button normally displaying an error in one of 4 orientations\n\t(mark_class,\t\t$,\tbs_none),\t\t\t!Toggle or select mark\n\t(label_class,\t\t$,\tbs_none),\t\t\t!Contains unclickable text usually\n\t(dummy_class,\t\t$,\tbs_none)\nend\n\nexport enumdata actionnames=\n\t(draw_w,\t\t$),\n\t(update_w,\t\t$),\n\t(last_w,\t\t$),\nend\n\n!MM Message Numbers\n\nexport enumdata messagenames=\n\n!all messages have x,y coord relative to top most window or child window\n!\n\t(mm_null=0,\t\t\t$),\t\t! empty message\n\n!window messages\n\t(mm_activate,\t\t$),\t\t! (w,a) a=1/0 activate/deactivate window\n\t(mm_close,\t\t\t$),\t\t! (w) close window (X button clicked)\n\t(mm_sizewindow,\t\t$),\t\t! (w...) resize window\n\t(mm_movewindow,\t\t$),\t\t! (w...) move window\n\t(mm_restore,\t\t$),\t\t! (w...) repaint window\n\n!cursor/focus messages\n\t(mm_setcursor,\t\t$),\t\t! (w...) update cursor type\n\t(mm_setfocus,\t\t$),\t\t! (w...) set focus to w\n\t(mm_killfocus,\t\t$),\t\t! (w...) lose focus from w\n\n!basic mouse messages (click messages can be promoted to other messages eg mm_command)\n\t(mm_move,\t\t\t$),\t\t! (w,x,y,b) mouse move, btns up/down (also drag messages when down)\n\t(mm_click,\t\t\t$),\t\t! (w,x,y) left btn click, can be promoted to mm_command etc depending on context\n\t(mm_dblclick,\t\t$),\t\t! (w,x,y) left btn dbl click, usu promoted\n\t(mm_clickup,\t\t$),\t\t! (w,x,y) left btn released\n\t(mm_rclick,\t\t\t$),\t\t! (w,x,y) right click in window, these usu. promoted\n\t(mm_rdblclick,\t\t$),\t\t! (w,x,y) right double click\n\t(mm_rclickup,\t\t$),\t\t! (w,x,y) right button released\n\t(mm_mclick,\t\t\t$),\t\t! (w,x,y) middle button versions of above\n\t(mm_mdblclick,\t\t$),\t\t! (w,x,y)\n\t(mm_mclickup,\t\t$),\t\t! (w,x,y)\n\t(mm_hover,\t\t\t$),\t\t! (w,x,y) paused over button\n\n\t(mm_onwindow,\t\t$),\t\t! (w,x,y) newly over a window\n\t(mm_offwindow,\t\t$),\t\t! (w,x,y) just came off window\n\t(mm_draw,\t\t\t$),\t\t! (w,x,y) redraw window\n\t(mm_update,\t\t\t$),\t\t! (w,x,y) update window (change of pos etc)\n\n!drag messages\n\t(mm_startdrag,\t\t$),\t\t! (w) start mouse movement with some btns down\n\t(mm_rstartdrag,\t\t$),\t\t! (w)\n\t(mm_mstartdrag,\t\t$),\t\t! (w)\n\t(mm_drag,\t\t\t$),\t\t! (w,x,y) moving mouse with buttons down (also qmmove sent)\n\t(mm_enddrag,\t\t$),\t\t! (w,x,y) all buttons up after drag\n\n!left command\n\t(mm_command,\t\t$),\t\t! (w,id) button clicked, id and sub-event given\n\t(mm_dblcommand,\t\t$),\t\t! (w,id) button double clicked\n\n!right command\n\t(mm_rcommand,\t\t$),\t\t! (w,id) right click button\n\t(mm_rdblcommand,\t$),\t\t! (w,id) right double click button\n\n!middle command\n\t(mm_mcommand,\t\t$),\t\t! (w,id)\n\t(mm_mdblcommand,\t$),\t\t! (w,id)\n\n!general key messages\n\t(mm_char,\t\t\t$),\t\t! (w,ch)\n\t(mm_key,\t\t\t$),\t\t! (w,k,shift)\n\t(mm_keyup,\t\t\t$),\t\t! (w,k,shift)\n\n!scroll/select/wheel messages\n\t(mm_sethozpos,\t\t$),\t\t! (w,pos)\t\tNew logical position set by hoz scrollbar\n\t(mm_setvertpos,\t\t$),\t\t! (w,pos)\t\tfrom vertical scrollbar\n\t(mm_select,\t\t\t$),\t\t! (w,n)\t\t\tSet nth item as current/highlighted/selected item\n\t(mm_pick,\t\t\t$),\t\t! (w,n)\t\t\tPick and return item n\n\t(mm_wheel,\t\t\t$),\t\t! (w,delta)\t\tMove log pos etc but depends on context\n\t(mm_lbchange,\t\t$),\t\t! (w,n)\t\t\tA listbox position has changed\n\n!misc messages\n\t(mm_timer,\t\t\t$),\t\t! (w)\n\n!high level window messages\n\t(mm_cancel,\t\t\t$),\t\t! (w)\n\t(mm_ok,\t\t\t\t$),\t\t! (w)\n\t(mm_help,\t\t\t$),\t\t! (w,id)\n\t(mm_cmdline,\t\t$),\t\t! (w,s)\n\n!specific key messages\n\t(mm_leftkey ,\t\t$),\t\t! (w,shift)\n\t(mm_rightkey,\t\t$),\t\t! (w,shift)\n\t(mm_upkey,\t\t\t$),\t\t! (w,shift)\n\t(mm_downkey,\t\t$),\t\t! (w,shift)\n\t(mm_pageupkey,\t\t$),\t\t! (w,shift)\n\t(mm_pagedownkey,\t$),\t\t! (w,shift)\n\t(mm_homekey,\t\t$),\t\t! (w,shift)\n\t(mm_endkey,\t\t\t$),\t\t! (w,shift)\n\t(mm_tabkey,\t\t\t$),\t\t! (w,shift)\n\t(mm_bskey,\t\t\t$),\t\t! (w,shift)\n\t(mm_deletekey,\t\t$),\t\t! (w,shift)\n\t(mm_enterkey,\t\t$),\t\t! (w,shift)\n\t(mm_insertkey,\t\t$),\t\t! (w,shift)\n\t(mm_functionkey,\t$),\t\t! (w,shift)\n\n!Other messages for controls, mainly for attached arrow buttons\n\t(mm_up,\t\t\t\t$),\t\t! (w,id) Arrow up/etc\n\t(mm_down,\t\t\t$),\t\t! (w,id)\n\t(mm_right,\t\t\t$),\t\t! (w,id)\n\t(mm_left,\t\t\t$),\t\t! (w,id)\n\t(mm_edit,\t\t\t$),\t\t! (w,id)\tUpdate of edit box\n\t(mm_edited,\t\t\t$),\t\t! (w,id)\tFinished edit box entry (tab etc)\n\t(mm_last,\t\t\t$)\nend\n\n!export const mm_scroll\t= mm_hscroll\t!general scroll independent of orientation\n\n!!other messages wmuser+ are user assigned, usually applied as\n!ids to controls. Depending on the options to Waitmess(), a wm_commmand message\n!is coverted to a direct message number. So (wm_command, 230) is covered to\n!message 230. So message ids have to start from 200 so that they occupy a different\n!number space from normal message codes.\nexport const mm_user\t= 200\n\nexport const kb_lbutton\t= 0x1\t!used in buttonstate\nexport const kb_rbutton\t= 0x2\nexport const kb_mbutton\t= 0x4\n\nexport const kb_shift\t= 0x8\t!used in shiftstate\nexport const kb_ctrl\t= 0x10\nexport const kb_alt\t\t= 0x20\nexport const kb_capslock\t= 0x40\nexport const kb_dblclick\t= 0x80\t!used for some messages that don't have dblclick versions,\n\nexport const kb_rshift\t= 0x100\nexport const kb_rctrl\t= 0x200\nexport const kb_ralt\t= 0x400\n\nexport enumdata colournames, colourvalues =\n!\t\t\t\t\t   BB'GG'RR\n\t(black,\t\t$,\t0x_00'00'00),\n\t(red,\t\t$,\t0x_00'00'C0),\n\t(dkred,\t\t$,\t0x_00'00'90),\n\t(red3,\t\t$,\t0x_00'00'70),\n\t(green,\t\t$,\t0x_00'C0'00),\n\t(dkgreen,\t$,\t0x_00'90'00),\n\t(green3,\t$,\t0x_00'70'00),\n\t\n\t(blue,\t\t$,\t0x_C0'00'00),\n\t(dkblue,\t$,\t0x_90'00'00),\n\t(blue3,\t\t$,\t0x_70'00'00),\n\n\t(cyan,\t\t$,\t0x_c0'c0'00),\n\t(dkcyan,\t$,\t0x_90'90'00),\n\t(cyan3,\t\t$,\t0x_70'70'00),\n\n\t(magenta,\t$,\t0x_c0'00'c0),\n\t(dkmagenta,\t$,\t0x_90'00'90),\n\t(magenta3,\t$,\t0x_70'00'70),\n\n\t(yellow,\t$,\t0x_00'C0'C0),\n\t(dkyellow,\t$,\t0x_00'90'90),\n\t(yellow3,\t$,\t0x_00'70'70),\n\t(yellow4,\t$,\t0x_00'50'50),\n\n\t(white,\t\t$,\t0x_FF'FF'FF),\n\t(ltgrey,\t$,\t0x_C0'C0'C0),\n\t(grey,\t\t$,\t0x_90'90'90),\n\t(dkgrey,\t$,\t0x_70'70'70),\n\n\t(ltorange,\t$,\t0x_00'A0'FF),\n\t(orange,\t$,\t0x_00'60'FF),\n\t(flesh,\t\t$,\t0x_70'85'EE),\n\t(pink,\t\t$,\t0x_9A'32'DB),\n\t(dkpink,\t$,\t0x_72'24'A9),\n\t(brown,\t\t$,\t0x_46'43'7D),\n\t(blue4,\t\t$,\t0x_B7'1C'5E),\n\t(blue5,\t\t$,\t0x_6F'3D'0D),\n\t(olive,\t\t$,\t0x_05'A0'88),\n\t(ltbrown,\t$,\t0x_00'70'B0),\n\n\t(blue6,\t\t$,\t0x_9C'63'1C),\n\t(green4,\t$,\t0x_12'51'11),\n\t(purple,\t$,\t0x_5E'0D'73),\n\t(blue7,\t\t$,\t0x_E6'27'1C),\n\t(crimson,\t$,\t0x_15'2A'D3),\n\t(violet,\t$,\t0x_54'16'A0),\n\t(blue8,\t\t$,\t0x_86'68'1E),\n\t(dkorange,\t$,\t0x_25'6A'D4),\n\t(green5,\t$,\t0x_09'46'41),\n\t(blue9,\t\t$,\t0x_65'0A'1D),\n\n\t(ltred,\t\t$,\t0x_00'00'FF),\n\t(ltgreen,\t$,\t0x_00'FF'00),\n\t(ltblue,\t$,\t0x_FF'00'00),\n\t(ltcyan,\t$,\t0x_FF'FF'00),\n\t(ltmagenta,\t$,\t0x_FF'00'FF),\n\t(ltyellow,\t$,\t0x_00'FF'FF),\n\n!The following are the Windows system colours, set up as indices\n!Init needs need to retrieve the values and set up the rgb values in this table\n\t(button_col,\t$,\t0),\t\t!button colour\n\t(window_col,\t$,\t0),\t\t!window colour\n\t(text_col,\t\t$,\t0),\t\t!text in windows\nend\n\nexport const skipmess = 1\t\t!message has been processed; caller must wait for another message\nexport const thismess = 0\t\t!caller should deal with this message (it has not been processed, or has been but caller can process it too)\n\nexport var bmbgnd\nexport var defstyle\t\t\t!set initdata\nexport var currmess=nil\n\nexport var wapplic=nil\nexport var wscreen=nil\n\nvar data,ndata\nvar tabstack,ntab\nvar breakflag\n\nconst k_menu=30000\nconst kdivide=30001\nconst kcolumn=30002\nconst kfilehistory=30003\n\nvar caretdrawn=0\nvar dkcolour=0x000000\nvar ltcolour=0xFFFFFF\nvar thumbdragmode=0\nvar thumbstartpos=0\n\nvar dirtomess=['L':mm_left,'R':mm_right,'U':mm_up,'D':mm_down]\n\nproc start=\n!CPL \"GXLIB START\"\n\n\tinitdata()\n\tmxinit()\n\tinitmenuhandlers()\nend\n\nexport proc setupgdi(w,hwnd)=\t\t\t!SETUPGDI\n!NOTE: rare care of a func within a data header. This is to allow bitmap module\n!to be higher up the hierarchy than gx, but still let it use some gx functions.\n\n!set up the default gdi descriptor for window w\n\n\tif w.gdi then\n\t\treturn\t\t\t!assume already done\n\tfi\n\n\tgdi:=new(rgdistate)\n\tgdi.hwnd:=hwnd\n\n!start with default drawmodes of dm_screen, or dm_memory for bitmaps\n!These can be converted later using gxdrawmode\n\n\tif w.type=rwindow then\n\t\tgdi.hdc:=getdc(hwnd)\n\t\tgdi.drawmode:=dm_screen\n\telse\t\t\t\t\t\t!assume bitmap\n\t\tgdi.hdc:=createcompatibledc(nil)\n\t\tgdi.drawmode:=dm_memory\n\tfi\n\n\tgdi.posx:=gdi.posy:=0\n\tgdi.updated:=0\n\tgdi.font:=0\n\tgdi.pencolour:=getsyscolour(colour_windowtext)\n\tgdi.penwidth:=0\n\tgdi.penstyle:=ps_solid\n\tgdi.xormode:=0\n\tgdi.brushcolour:=0xff'ff'ff\n\tgdi.brushstyle:=bs_solid\n\tgdi.brushpattern:=0\n\tw.gdi:=gdi\n\tend\n\nexport const arleft = \"<\"\nexport const arright = \">\"\nexport const arup = \"^\"\nexport const ardown = \"V\"\n\nexport var allwindows::=()\t\t\t!list of all windows and controls\n\nexport func ctrlpressed = return (currmess.state iand kb_ctrl) end\nexport func shiftpressed = return (currmess.state iand kb_shift) end\n\nproc initdata=\n\tmessagequeue:=new(list,100)\n\tnmessages:=0\n\n\tcolourvalues::=colourvalues\n\n\tcolourvalues[button_col]:=getsyscolour(colour_btnface)\n\n\tcolourvalues[window_col]:=getsyscolour(colour_window)\n\tcolourvalues[text_col]:=getsyscolour(colour_windowtext)\n\n\tdefstyle:=new(stylerec)\n\tdefstyle.border\t\t:= bs_simplew\n\tdefstyle.justify\t:= 'L'\n\tdefstyle.vjustify\t:= 'M'\n\tdefstyle.textfgnd\t:= black\n\tdefstyle.marktype\t:= check_mark\n\tdefstyle.hilitetype\t:= no_hilite\n\tdefstyle.windbgnd\t:= button_col\n\tdefstyle.imark\t\t:= 1\n!defstyle.windbgnd\t:= window_col\n\n\tinit_handlertables()\n\td:=gxchardim(labelfont)\n\tchx:=d.x\n\tchy:=d.y\n\n\td:=gxchardim(0,1)\n\tcha:=d.x\n\tchd:=d.y\n\tarrowdim:=chy+2\n\tmarkdim:=arrowdim-2\n\n\tbuttonheight:=chy+smy*2\n\tlistrowheight:=chy+smy*2\nend\n\nexport func gxcreatewindow(?caption,?pos,?dim,?options,owner=nil)=\t\t!CREATEWINDOW\n\t#create a popup window which is not a child window.\n\t#(nevertheless, it can have an owner window, such as the main window of the\n\t#application)\n\t#returns an rwindow handle\n\t#caption\toptional caption txt\n\t#pos\t\t(x,y) is pixel pos of top left corner in screen coordinates (of frame?)\n\t#\t\t\"cent\" to place centrally\n\t#\t\tomitted: use default placement\n\t#dim\t\t(width,height) overall pixel size\n\t#\t\t\"max\" maximised\n\t#\t\t\"desktop\" fill desktop screen\n\t#\t\tomitted: use (640,480)\n\t#owner\toptional owner window (default nil)\n\t#options\toption dict, default is [wf_caption:1, wf_border:wbs_resize]\n\n\thwnd:=wx_createpopup(caption,pos,dim,options,(owner|owner.gdi.hwnd|nil))\n\n\tw:=newwindow(hwnd,0,no_class,bs_windows)\n\n\tif wapplic=nil then\n\t\twapplic:=w\n\tfi\n\n\tW.STYLE:=NEW(STYLEREC)\n\tW.STYLE.BORDER:=0\n\tW.WINDCLASS:=WINDOW_CLASS\n\tW.STYLE.WINDBGND:=WINDOW_COL\n\tW.ENABLE:=1\n\tW.FLAGS.[WA_LEFTDRAG]:=1\n\tW.FLAGS.[WA_LEFTDBL]:=1\n\n\tsetwindowdims_w(w,hwnd)\n\n\tsetupgdi(w,hwnd)\n\tgxfont(w,1)\n\n\tGXDRAWMODE(W,DM_SCREENMEMORY)\n\tGXCLEAR(W)\n\n\treturn w\nend\n\nproc setwindowdims_w(w,hwnd)=\t\t\t!SETWINDOWDIMS\n!use windows functions to set up client and frame pos and dims of top-level window\n\n\tbox:=new(ws_rect)\n\tgetwindowrect(hwnd,&box)\n\tw.frameposx:=box.x\n\tw.frameposy:=box.y\n\tw.framedimx:=box.x2-box.x\n\tw.framedimy:=box.y2-box.y\n\n\tgetclientrect(hwnd,&box)\n\n\tw.dimx:=box.x2-box.x\n\tw.dimy:=box.y2-box.y\n\n\tpt:=ws_point(0,0)\n\tclienttoscreen(hwnd,&pt)\t\t!pos starts at 0,0\n\tw.posx:=pt.x\n\tw.posy:=pt.y\nend\n\nproc setwindowdims_c(w,hwnd)=\t\t\t!SETWINDOWDIMS\n!use windows functions to set up client and frame pos and dims of child window\n\n\n\tbox:=new(ws_rect)\n\tgetwindowrect(hwnd,&box)\t\t\t!client dims also Windows frame dims as has no Windows border\n\tw.posx:=box.x-w.owner.posx\n\tw.posy:=box.y-w.owner.posy\n\tw.dimx:=box.x2-box.x\n\tw.dimy:=box.y2-box.y\n\n\twidths:=bswidths[w.style.border]\n\tif bscat[w.style.border]='I' then widths:=ws_rect(0,0,0,0) fi\n\n\tw.frameposx:=w.posx-widths.x1\n\tw.frameposy:=w.posy-widths.y1\n\tw.framedimx:=w.dimx+widths.x1+widths.x2\n\tw.framedimy:=w.dimy+widths.y1+widths.y2\nend\n\nexport proc gxclear(w,?colour)=\t\t\t!GXCLEAR\n\t#fill window w with <colour>, or with current background if omitted\n\n!RETURN\n\tgdi:=w.gdi\n\tgdi.updated:=1\n\n\tgxcolour(w,getrgb(black))\n\tgxstyle(w,0)\n\n\tif colour.isvoid then\n\t\tcolour:=getrgb(w.style.windbgnd)\n\tfi\n\n\toldpenstyle:=gdi.penstyle\n\toldbrushstyle:=gdi.brushstyle\n\n\tgxbrushstyle(w,bs_solid)\n\tgxstyle(w,ps_null)\n\n\tgxfillrect(w,0,0,w.dimx,w.dimy,colour)\n\tgxbrushstyle(w,oldbrushstyle)\n\tgxstyle(w,oldpenstyle)\nend\n\nexport func gxstyle(w,?style)=\t\t\t!GXSTYLE\n\t#style omitted: get pen current pen style\n\t#style supplied: set pen style for subsequent line drawing\n\t#Style is a char code or int refering to a small variety of Windows dotted styles:\n\t#\t0 S |\t\tSolid\n\t#\tSpace\t\tNull (pen up?)\n\t#\t-\t\t\tDotted\n\t#\t:\t\t\tDashdotdot\n\t#\t!\t\t\tDashdotd\n\t#\tF\t\t\tInside frame\n\n\tgdi:=w.gdi\n\n\tif style.isdef and gdi.penstyle<>style then\n\t\tcase style\n\t\twhen '!' then style:=ps_dashdot\n\t\twhen ':' then style:=ps_dashdotdot\n\t\twhen '-' then style:=ps_dot\n\t\twhen ' ' then style:=ps_null\n\t\twhen 'D' then style:=ps_alternate\n\t\twhen '|','S',0 then style:=ps_solid\n\t\twhen 'F' then style:=ps_insideframe\n\t\tesac\n\n\t\tgdi.penstyle:=style\n\t\tif style>=10 then style:=ps_dot fi\n\t\tdeleteobject(selectobject(gdi.hdc,createpen(style,gdi.penwidth,gdi.pencolour)))\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\tdeleteobject(selectobject(gdi.hdc2,createpen(style,gdi.penwidth,gdi.pencolour)))\n\t\tfi\n\tfi\n\treturn gdi.penstyle\nend\n\nexport proc gxbrushstyle(w,?style,?pattern)=\t\t!GXBRUSHSTYLE\n\t#Set Windows brush style and pattern\n\t#Style supplied:\tset style\n\t#pattern supplied:\tset style\n\t#style is:\t\tS, H, Space, B for Solid, Hatched, Null, DIB\n\t#pattern is:\t- | \\ / + x/X for Hoz, Vert, Diag, Fwd Diag, Cross, Diag Cross\n\n\tgdi:=w.gdi\n\tbrush:=new(ws_logbrush)\n\n\tif style.isdef then\n\t\tif style<>gdi.brushstyle then\n\t\t\tcase style\n\t\t\twhen 'S' then style:=bs_solid\n\t\t\twhen 'H' then style:=bs_hatched\n\t\t\twhen ' ' then style:=bs_null\n\t\t\twhen 'B' then style:=bs_dibpattern\n\t\t\tesac\n\n\t\t\tgdi.brushstyle:=style\n\t\tfi\n\t\tgdi.brushpattern:=0\t\t!default to no pattern, will be changed by pattern if supplied\n\tfi\n\n\tif pattern.isdef and pattern<>gdi.brushpattern then\n\t\tcase pattern\n\t\twhen '-' then pattern:=hs_horizontal\n\t\twhen '|' then pattern:=hs_vertical\n\t\twhen '\\\\' then pattern:=hs_fdiagonal\n\t\twhen '/' then pattern:=hs_bdiagonal\n\t\twhen '+' then pattern:=hs_cross\n\t\twhen 'x','X' then pattern:=hs_diagcross\n\t\tesac\n\t\tgdi.brushpattern:=pattern\n\tfi\n\n\tbrush.lbstyle:=gdi.brushstyle\n\tbrush.lbcolour:=gdi.brushcolour\n\tbrush.lbhatch:=gdi.brushpattern\n\n\tdeleteobject(selectobject(gdi.hdc,createbrushindirect(&brush)))\n\tif gdi.drawmode=dm_screenmemory then\n\t\tdeleteobject(x:=selectobject(gdi.hdc2,createbrushindirect(&brush)))\n\tfi\nend\n\nexport func gxbrushcolour(w,?colour)=\t\t\t!GXBRUSHCOLOUR\n\t#colour supplied:\tset current fill colour\n\t#colour omitted:\treturn current fill colour\n\n\tgdi:=w.gdi\n\n\tif colour.isdef and colour<>gdi.brushcolour then\n\t\tgdi.brushcolour:=colour\n\t\tbrush:=new(ws_logbrush)\n\t\tbrush.lbstyle:=gdi.brushstyle\n\t\tbrush.lbcolour:=colour\n\t\tbrush.lbhatch:=gdi.brushpattern\n\n\t\tdeleteobject(selectobject(gdi.hdc,createbrushindirect(&brush)))\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\tdeleteobject(selectobject(gdi.hdc2,createbrushindirect(&brush)))\n\t\tfi\n\tfi\n\treturn gdi.brushcolour\nend\n\nexport proc gxfillrect(w,x,y,width,height,?colour,mode=0)=\t\t!GXFILLRECT\n\t#Draw filled rectangle with optional outline\n\t#x,y are top-left coordinates\n\t#width, height are overall pixel dimensions, inclusive; they include any outline\n\t#(When the outline is drawn, the filled region is 1 pixel smaller all round)\n\t#colour is the colour of the filled region (current brush colour when omitted)\n\t#mode=1 to draw the outline, or mode=0 (default) to omit it\n\t#The outline is drawn in the current pen colour\n\n\tgdi:=w.gdi\n\tgdi.updated:=1\n\n\toldbrushcolour:=gdi.brushcolour\n\tif colour.isdef then\n\t\tgxbrushcolour(w,colour)\n\tfi\n\n\toldpenstyle:=gdi.penstyle\n\tif mode=0 then\t\t!inside only\n\t\tgxstyle(w,ps_null)\n\tfi\n\n\tif height<0 then y:=y+height+1; height:=-height fi\n\tif width<0 then x:=x+width+1; width:=-width fi\n\n\tif mode=0 then\t\t!inside only, needs extra pixel width\n\t\trectangle(gdi.hdc,x, y,x+width+1,y+height+1)\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\trectangle(gdi.hdc2,x,y,x+width+1,y+height+1)\n\t\tfi\n\telse\t\t\t!inside and outside\n\t\trectangle(gdi.hdc,x, y, x+width, y+height)\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\trectangle(gdi.hdc2,x,y,x+width,y+height)\n\t\tfi\n\tfi\n\tgxstyle(w,oldpenstyle)\n\tgxbrushcolour(w,oldbrushcolour)\nend\n\nexport func gxcolour(w,?colour)=\t\t!GXCOLOUR\n\t# colour supplied:\tset current outline colour for subsequent line drawing\n\t# colour omitted:\treturn current outline colour\n\n\tgdi:=w.gdi\n\n\tif colour.isdef and gdi.pencolour<>colour then\n\t\tgdi.pencolour:=colour\n\t\tgdi.xormode:=0\n\t\tdeleteobject(selectobject(gdi.hdc,createpen(gdi.penstyle,gdi.penwidth,gdi.pencolour)))\n\t\tsetrop2(gdi.hdc,r2_copypen)\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\tdeleteobject(selectobject(gdi.hdc2,createpen(gdi.penstyle,gdi.penwidth,gdi.pencolour)))\n\t\t\tsetrop2(gdi.hdc2,r2_copypen)\n\t\tfi\n\n\tfi\n\n\treturn gdi.pencolour\nend\n\nexport proc gxsetpen(w,pen)=\n\tgxcolour(w,getrgb(pen))\nend\n\nexport proc gxline(w,x,y,?x2,?y2)=\t\t!GXLINE\n\t#gxline(w,x,y)\t\t\tDraw line from current position to x,y\n\t#gxline(w,x,y,x2,y2)\tDraw line from x,y to x2,y2\n\n\tgdi:=w.gdi\n\n\tif x2.isvoid then\t\t!assume 2 params\n\t\tx2:=x\n\t\ty2:=y\n\n\t\tmovetoex(gdi.hdc,gdi.posx, gdi.posy)\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\tmovetoex(gdi.hdc2,gdi.posx, gdi.posy)\n\t\tfi\n\telse\n\t\tmovetoex(gdi.hdc,x, y)\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\tmovetoex(gdi.hdc2,x, y)\n\t\tfi\n\t\tgdi.posx:=x\n\t\tgdi.posy:=y\n\tfi\n\n\tlineto(gdi.hdc,x2,y2)\n\n\tif gdi.drawmode=dm_screenmemory then\n\t\tlineto(gdi.hdc2,x2,y2)\n\tfi\n\tgdi.posx:=x2\n\tgdi.posy:=y2\nend\n\nexport func gxwidth(w,width)=\n!get/set pen width for subsequent line drawing\n\tgdi:=w.gdi\n\tif width.isvoid then\n\t\treturn gdi.penwidth\n\tfi\n\n\tif gdi.penwidth<>width then\n\t\tgdi.penwidth:=width\n\t\tdeleteobject(selectobject(gdi.hdc,createpen(gdi.penstyle,gdi.penwidth,gdi.pencolour)))\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\tdeleteobject(selectobject(gdi.hdc2,createpen(gdi.penstyle,gdi.penwidth,gdi.pencolour)))\n\t\tfi\n\n\tfi\n\treturn width\nend\n\nexport proc gxlinerel(w,dx,dy)=\t\t!GXLINEREL\n\t#Draw line from current position, to current position + (dx,dy)\n\n\tgdi:=w.gdi\n\tmovetoex(gdi.hdc, gdi.posx, gdi.posy)\n\tif gdi.drawmode=dm_screenmemory then\n\t\tmovetoex(gdi.hdc2, gdi.posx, gdi.posy)\n\tfi\n\tx:=gdi.posx+dx\n\ty:=gdi.posy+dy\n\tgxline(w,x,y)\n\tgdi.posx:=x\n\tgdi.posy:=y\nend\n\nexport proc gxmove(w,x2,y2)=\t\t!GXMOVE\n\t#Set current position to x2,y2\n\n\tgdi:=w.gdi\n\n\tmovetoex(gdi.hdc, x2, y2)\n\tif gdi.drawmode=dm_screenmemory then\n\t\tmovetoex(gdi.hdc2,x2, y2)\n\tfi\n\tgdi.posx:=x2\n\tgdi.posy:=y2\nend\n\nexport proc gxmoverel(w,dx,dy)=\t\t!GXMOVEREL\n\t#\tSet current position to current position+(dx,dy)\n\tgdi:=w.gdi\n\n\tgdi.posx+:=dx\n\tgdi.posy+:=dy\n\n\tmovetoex(gdi.hdc,gdi.posx, gdi.posy)\n\tif gdi.drawmode=dm_screenmemory then\n\t\tmovetoex(gdi.hdc2,gdi.posx, gdi.posy)\n\tfi\nend\n\nexport proc gxrect(w,x,y,width,height)=\t\t!GXRECT\n\t#draw outline rectangle starting from x,y at top left, in current pen colour\n\t#overall size is width by height pixels inclusive (x,y to x+width+1,y+height-1)\n\t#outline is 1 pixel wide\n\n\tgdi:=w.gdi\n\tgdi.updated:=1\n\tif height<0 then y:=y+height+1; height:=-height fi\n\tif width<0 then x:=x+width+1; width:=-width fi\n\n\toldbrushstyle:=gdi.brushstyle\n\tgxbrushstyle(w,bs_hollow)\n\n\trectangle(gdi.hdc,x, y, x+width, y+height)\n\tif gdi.drawmode=dm_screenmemory then\n\t\trectangle(gdi.hdc2,x, y, x+width,y+height)\n\tfi\n\tgxbrushstyle(w,oldbrushstyle)\nend\n\nexport proc gxcircle(w,x,y,r)=\t\t!GXCIRCLE\n\t#draw circle at centre x,y in window w, of radius r, using current pen colour\n\t#outline is 1 pixel wide\n\n\tgdi:=w.gdi\n\tgdi.updated:=1\n\toldbrushstyle:=gdi.brushstyle\n\tgxbrushstyle(w,bs_hollow)\n\n\tellipse(gdi.hdc,x-r, y-r, x+r-1, y+r-1)\n\tif gdi.drawmode=dm_screenmemory then\n\t\tellipse(gdi.hdc2,x-r, y-r, x+r-1, y+r-1)\n\tfi\n\tgxbrushstyle(w,oldbrushstyle)\nend\n\nexport proc gxfillcircle(w,x,y,r,?colour,mode=0)=\t\t!GXFILLCIRCLE\n\t#Draw filled circle with optional outline\n\t#x,y is the centre, r is the radius\n\t#(When the outline is drawn, the filled region is 1 pixel smaller all round)\n\t#colour is the colour of the filled region (current brush colour when omitted)\n\t#mode=1 to draw the outline, or mode=0 (default) to omit it\n\t#The outline is drawn in the current pen colour\n\tgdi:=w.gdi\n\n\tgdi.updated:=1\n\toldbrushcolour:=gdi.brushcolour\n\tif colour.isdef then\n\t\tgxbrushcolour(w,colour)\n\tfi\n\n\toldpenstyle:=gdi.penstyle\n\tif mode=0 then\t\t!inside only\n\t\tgxstyle(w,ps_null)\n\tfi\n\n\tellipse(gdi.hdc,x-r, y-r, x+r-1, y+r-1)\n\tif gdi.drawmode=dm_screenmemory then\n\t\tellipse(gdi.hdc2,x-r, y-r, x+r-1, y+r-1)\n\tfi\n\n\tgxstyle(w,oldpenstyle)\n\tgxbrushcolour(w,oldbrushcolour)\nend\n\nexport func gxpixel(w,x,y,?colour)=\t\t!GXPIXEL\n\t#colour provided: set pixel at point x,y of window w to colour\n\t#colour omitted: return pixel colour from point x,y\n!set pixel at x,y with given rgb colour, or return pixel value if omitted (-1)\n\tw.gdi.updated:=1\n\n\tif colour.isvoid then\t\t!get pixel\n\t\tres:=getpixel(w.gdi.hdc, x, y)\n\t\tif w.gdi.drawmode=dm_screenmemory then\n\t\t\tgetpixel(w.gdi.hdc2, x, y)\n\t\tfi\n\t\treturn res\n\telse\n\t\tsetpixel(w.gdi.hdc,x, y, colour)\n\t\tif w.gdi.drawmode=dm_screenmemory then\n\t\t\tsetpixel(w.gdi.hdc2,x,y,colour)\n\t\tfi\n\t\treturn colour\n\tfi\nend\n\nexport func gxcaption(w,?caption)=\t\t!GXCAPTION\n\t#caption omitted:  return current window caption text\n\t#caption provided: set new window caption text\n\n\tcase w.windclass\n\twhen window_class,popup_class then\n\n\t\tif caption.isdef then\t\t!set text\n\t\t\tsetwindowtext(w.gdi.hwnd,caption)\n\t\t\treturn caption\n\t\telse\n\t\t\tbuffer:=new(array,byte,512)\n\t\t\tn:=getwindowtext(w.gdi.hwnd,int(&buffer),buffer.len)\n\t\t\tif n then\n\t\t\t\ts:=makestr(&buffer,n)\t\t!needs assigment to ensure a copy is made befor buffer\n\t\t\t\t\t\t\t\t\t\t\t!is freed (assignment of return value might do the same)\n\t\t\telse\n\t\t\t\ts:=\"\"\n\t\t\tfi\n\t\t\treturn s\n\t\tfi\n\tesac\n\n\tif caption.isdef then\t\t!set text\n\t\tw.text:=caption\n\t\tgxdraw(w)\n\tfi\n\n\treturn w.text\nend\n\nexport proc gxtext(w,s,?x,?y)=\t\t!GXTEXT\n\t#Display text s\n\t#Text is drawn starting at (x,y) when provided, otherwise at current position\n\t#insertion point refers either to base line, or to top left of cell (not sure)\n\t#Text is drawn in current font, size, style and mode\n\t#Text typically contains no control codes, but can also contain cr and lf (also\n\t#tabs, but currently position isn't changed). However, text with control codes is\n\t#drawn a character at a time\n\t#Finishes with current position set to the end of the text\n\n!uses chr(16) for reverse tab. Reverse tabs are usually encoded as:\n!  chr(9)+chr(16), ie. normal tab then reverse tab\n!Reverse tab, after tabbing to next stop, then moves position back by width\n!of next substring\n\n\treturn when s=\"\"\n\n\tgdi:=w.gdi\n\n\tif x.isvoid then x:=gdi.posx fi\n\tif y.isvoid then y:=gdi.posy fi\n\tgdi.updated:=1\n\n!scan the string and create a table of substrings and control codes\n\tstartpos::=lengths::=()\n\tngroups:=0\n\n\tforeach i,c in s do\n\t\tif c<32 then\n\t\t\t++ngroups\n\t\t\tstartpos[ngroups]:=i\n\t\t\tlengths[ngroups]:=0\n\t\telse\n\t\t\tif ngroups and lengths[ngroups] then\t\t!extend this group\n\t\t\t\t++lengths[ngroups]\n\t\t\telse\t\t\t\t\t\t\t\t\t\t!start new substring group\n\t\t\t\t++ngroups\n\t\t\t\tstartpos[ngroups]:=i\n\t\t\t\tlengths[ngroups]:=1\n\t\t\tfi\n\t\tfi\n\tod\n\n\tfor i,l in lengths do\n\t\tpos:=startpos[i]\n\t\tif l then\n\t\t\tslicex:=pos..pos+l-1\n\t\t\ttextout(gdi.hdc,x, y,s.[slicex],l)\n\n\t\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\t\ttextout(gdi.hdc2,x,y,s.[slicex],l)\n\t\t\tfi\n\t\t\tx +:= gxtextwidth(w,s.[slicex])\n\n\t\telse\t\t\t\t!Deal with control codes\n\t\t\tcase s.[pos]\n\t\t\twhen 13 then\n\t\t\t\tx:=0\n\t\t\twhen 10 then\n\t\t\t\ty+:=20\t\t\t\t!NEEDS TO PICK CURRENT FONT DIMS\n\n\t\t\twhen 9,16 then\t\t\t!16 will be used as reverse tab\n\t\t\t\tcurrx:=x\n\t\t\t\tx:=0\n\t\t\t\tfor t in tabstops do\n\t\t\t\t\tx+:=t*chx\t\t\t\t!MUST BE CURRENT FONT NOT CHX\n\t\t\t\t\tif x>currx then exit fi\n\t\t\t\tod\n\t\t\t\twhile x<=currx do x+:=chx*8 od\n\n\t\t\t\tif s.[pos]=16 and i<ngroups and lengths[i+1] then\t!reverse offset for next substring\n\t\t\t\t\tpos:=startpos[i+1]\n\t\t\t\t\tx -:= gxtextwidth(w,s.[pos..pos+lengths[i+1]-1])+1\n\t\t\t\tfi\n\n\t\t\tesac\t\n\t\tfi\n\tod\n\n\tgdi.posx:=x\n\tgdi.posy:=y\nend\n\nexport func gxtextcolour(w,?colour,?bgndcolour)=\t\t!GXTEXTCOLOUR\n\t#Set either text foreground colour or background colour, or both, or neither,\n\t#depending on which are supplied\n\t#Text colours will be colour indices, not rgb\n\t#Always returned current or new foreground\n\n\tgdi:=w.gdi\n\n\tif colour.isdef and colour<>w.style.textfgnd then\n\t\tw.style.textfgnd:=colour\n\t\tsettextcolour(gdi.hdc,getrgb(colour))\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\tsettextcolour(gdi.hdc2,getrgb(colour))\n\t\tfi\n\tfi\n\tif bgndcolour.isdef and bgndcolour<>w.style.textbgnd then\n\t\tgxbgndcolour(w,bgndcolour)\n\tfi\n\n\treturn w.style.textfgnd\nend\n\nexport func gxtextwidth(font,?s)=\t\t!GXTEXTWIDTH\n\t# font is a window, or a font number within fonttable\n\t# font can be zero (then uses font 1)\n\t# return total pixel width of string s, using given font\n\n\tif s=\"\" then return 0 fi\n\n!if not font.isint then\t\t\t!aasume font is window\n!CPL =FONT\n!CPL =FONT.TYPE\n\n\n!if not font.ispointer then\t\t\t!aasume font is window\n\tif not font.isint then\t\t\t!aasume font is window\n\t\tfont:=font.gdi.font\n\tfi\n\tif font=0 then font:=1 fi\n\n\tselectobject(screendc,fonttable[font])\n\twidthheight:=new(ws_point)\n\n!CPL =S\n\n\tgettextextentpoint32(screendc,s,s.len,&widthheight)\n\n\treturn widthheight.x\nend\n\nexport func gxloadfont(n,facename,?style,height=0,width=0)=\t\t!GXLOADFONT\n\t#define new font\n\t#N is index into fonttable\n\t#facename is the name of the font\n\t#Style is optional font style, a string containing any of:\n\t#\tB,b\t\tBold\n\t#\tI,i\t\tItalic\n\t#\tU,u\t\tUnderline\n\t#\tS,s\t\tStrikeout\n\t#Height is height of text (default 0, gives default height?)\n\t#Weight is width; defautl 0 normally used for normal aspect of text\n\n\tCPL \"GXLOADFONT\"\n\n\tif n<=0 then return 0 fi\n!n:=min(n,nglobalfonts)\n\n\tif style.isvoid then style:=\"\" fi\n\n\tif n<=nglobalfonts and fonttable[n] then\t\t\t!remove existing font\n\t\tigxremovefont(n)\n\tfi\n\n\tp:=style\n\tbold:=400\n\titalic:=0\n\tunderline:=0\n\tstrikeout:=0\n\tfor c in style do\n\t\tcase asc(convuc(c))\n\t\twhen 'B' then bold:=700\n\t\twhen 'I' then italic:=1\n\t\twhen 'U' then underline:=1\n\t\twhen 'S' then strikeout:=1\n\t\tesac\n\tod\n\n\thfont:=createfont(\n\t\tfacename:\tfacename,\n\t\theight:\t\theight,\n\t\twidth:\t\twidth,\n\t\tbold:\t\tbold,\n\t\titalic:\t\titalic,\n\t\tunderline:\tunderline,\n\t\tcharset:\t0,\n\t\tquality:\t2,\n\t\tescapement:\t0,\n\t\torientation:0)\n\n\tif hfont=0 then\n\t\thfont:=getstockobject(system_font)\n\tfi\n\n\tfonttable[n]:=hfont\n\tnglobalfonts:=max(n,nglobalfonts)\n\n\tselectobject(screendc,fonttable[n])\n\n\ttm:=new(ws_textmetrics)\n\n\tgettextmetrics(screendc,&tm)\n\n\tfontdimtable[n]::=ws_point(tm.avecharwidth, tm.height+tm.externalleading)\n\tfontvdimtable[n]::=ws_point(tm.ascent, tm.descent)\n\n\tselectobject(screendc,getstockobject(system_font))\n\n\treturn n\nend\n\nproc igxremovefont(n)=\n!unload font n, free table entry\n\n\tunless n in 1..nglobalfonts then return end\n\tif fonttable[n]=0 then return fi\t!already freed\n\n!w:=windowlist\n!while w<>nil do\n!\tif w.gdi.hdc and w.gdi.font>0 then\t\t!font was in use, set as undefined\n!\t\tw.gdi.font:=1\n!\t\tselectobject(w.gdi.hdc,fonttable[w.gdi.font])\n!\t\tif w.gdi.hdc2 then\n!\t\t\tselectobject(w.gdi.hdc2,fonttable[w.gdi.font])\n!\t\tfi\n!\tfi\n!\tw:=w.nextwind\n!od\n\n\tdeleteobject(fonttable[n])\t\t!get rid of this font\n\tfonttable[n]:=0\nend\n\nexport func gxfont(w,font=1)=\t\t!GXFONT\n\t# select font from font table for subsequent text display; default is font 1\n\n\tif not w then w:=wapplic fi\n\tif not w then w:=wscreen fi\n\n\tgdi:=w.gdi\n\n\tif font.isdef and font<>gdi.font then\n\t\tif font not in 1..nglobalfonts then\n\t\t\tabort(\"Bad font number \"+tostr(font))\n\t\tfi\n\t\tgdi.font:=font\n\t\tif fonttable[font]=0 then\n\t\t\tabort(\"Font not in use \"+tostr(font))\n\t\tfi\n\n\t\toldhfont:=selectobject(gdi.hdc,fonttable[font])\n\t\tsendmessage(gdi.hwnd,wm_setfont,fonttable[font],0)\n\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\toldhfont:=selectobject(gdi.hdc2,fonttable[font])\n\t\t\tsendmessage(gdi.hwnd2,wm_setfont,fonttable[font],0)\n\t\tfi\n\t\tif fontdimtable[font].x=0 then\t\t!set up dims\n\t\t\tgxchardim(font,0)\n\t\tfi\n\tfi\n\treturn gdi.font\nend\n\nfunc hascontrolchars(s)=\t\t!TESTCTRLCHAR\n!scan string s looking for control chars\n!return 1 if control chars (<20H) are present\n\n\tforeach c in s do\n\t\tif c<32 then return 1 fi\n\tod\n\treturn 0\nend\n\nexport func gxchardim(font,vert=0)=\t\t\t!GXCHARDIM\n\t#return font char average width/height info as a point rec\n\t#wfont is a font number, or hwindow when the current font in that window is used\n\t#vert=1 means get ascent/descent pair instead of (vert=0) average width/height\n\n\tif not font.isint then\n\t\tfont:=font.gdi.font\n\tfi\n\tif font=0 then font:=1 fi\n\n!CPL =FONTDIMTABLE,=FONT\n\n\tif fontdimtable[font].x=0 then\t\t!probably stock fonts not setup with gxloadfont\n\t\tselectobject(screendc,fonttable[font])\n\t\ttm:=new(ws_textmetrics)\n\t\tgettextmetrics(screendc,&tm)\n\n\t\tfontdimtable[font]::=ws_point(tm.avecharwidth, tm.height+tm.externalleading)\n\n\t\tfontvdimtable[font]::=ws_point(tm.ascent, fontvdimtable[font].y:=tm.descent)\n\n\t\tselectobject(screendc,getstockobject(ansi_var_font))\n\tfi\n\n\tif vert then\n\t\treturn fontvdimtable[font]\n\tfi\n\n\treturn fontdimtable[font]\nend\n\nexport func gxbgndcolour(w,?colour)=\t\t!GXBGNDCOLOUR\n\t#Set background colour (for text mainly)\n\t#colour will be a colour index\n\t#return current colour when omitted\n\tgdi:=w.gdi\n\n\tif colour.isdef then\n\n\t\tif colour<>w.style.textbgnd then\n\t\t\tw.style.textbgnd:=colour\n\t\t\tsetbkcolour(gdi.hdc,getrgb(colour))\n\t\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\t\tsetbkcolour(gdi.hdc2,getrgb(colour))\n\t\t\tfi\n\t\tfi\n\t\tgxbgndmode(w,(colour<>w.style.windbgnd|1|0))\n\tfi\n\treturn w.style.textbgnd\nend\n\nexport func gxbgndmode(w,?mode)=\t\t!GXBGNDMODE\n\t#\tmode supplied: set new background mode:\n\t#\t\t1 y Y T\t\tSet opaque (T for True? Looks like Transparent)\n\t#\t\t0 n N F\t\tSet Transparent\n\n\tgdi:=w.gdi\n\n\tif mode.isdef  then\n\t\tcase mode\n\t\twhen 1,'y','Y','T' then\n\t\t\tw.style.bgndmode:=opaque\n\t\telse\n\t\t\tw.style.bgndmode:=transparent\n\t\tesac\n\n\t\tsetbkmode(gdi.hdc,mode+1)\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\tsetbkmode(gdi.hdc2,mode+1)\n\t\tfi\n\tfi\n\treturn w.style.bgndmode\nend\n\nexport proc gxhighlight(w,x,y,width,height)=\t\t!GXHIGHLIGHT\n\t#Invert rectangular region\n\tconst dstinvert=0x00550009\t!patblt\n\tgdi:=w.gdi\n\n\tgdi.updated:=1\n\tpatblt(gdi.hdc, x, y, width,height,dstinvert)\n\tif gdi.drawmode=dm_screenmemory then\n\t\tpatblt(gdi.hdc2, x,y, width,height,dstinvert)\n\tfi\nend\n\nexport proc gxbitblt(w,x2,y2,width,height,x,y)=\t\t\t!GXBITBLT\n\t#Copy rectangular region of window to another location\n\tgdi:=w.gdi\n\tgdi.updated:=1\n\tbitblt(gdi.hdc, x2, y2, width,height,\n\t\t\t\tgdi.hdc,x,y,srccopy)\n\n\tif gdi.drawmode=dm_screenmemory then\n\t\tbitblt(gdi.hdc2,x2,y2,width,height,gdi.hdc2,x,y,srccopy)\n\tfi\nend\n\nexport func gxaskmess(mode=0)=\n\t#wait for next message and return message number\n\t#return 0 if close or quit message seen\n\t#some messages will be ignored here (processsed via procmess) and will wait for next\n\t#mode=0\t\tReturn currmess.message\n\t#mode=1\t\tReturn currmess.message, but if a mm_command message, then return\n\t#\t\t\tthe command id. This means message numbers and command ids share the\n\t#\t\t\tsame space. This should work because messages are below 200, and ids above 200\n\n!CPL \"AM1\",$REFCOUNT(WAPPLIC)\n\trepeat\n\t\tif mxwait_mm_message()=0 then\nCPL \"GXAM MAXWAIT =0\"\n\t\t\treturn mm_cancel\n\t\tfi\n\t\tif quitmess then return mm_cancel fi\n\t\tx:=process_message(currmess)\n\n\t\tif currmess.message=mm_key and currmess.a=27 then\n\t\t\treturn mm_cancel\n\t\tfi\n\n\tuntil x=thismess\t\t\t\t\t!message ready to return\n\n\tif mode=1 and currmess.message=mm_command then\n\t\treturn currmess.a\n\tfi\n\n\treturn currmess.message\nend\n\nfunc process_message(mess)=\n\t#user or default event processing for mm message\n\t#will call event handler if there is one\n\t#returns 1 (skipmess) if message has been processed here; caller must wait for another message\n\t#returns 0 (thismess) caller should deal with this message (it has not been processed, or has beenbut caller can process it too)\n\n!\tCP \"\t\";SHOWMESSAGE(\"PROCMESS\",MESS)\n\n\n\tif mess.wind=nil then\n\t\treturn thismess\n\tfi\n\n\tcase mess.message\n\twhen mm_close then\n\t\treturn thismess\n\tesac\n\n!CPL \"PROCESS MESSAGE\"\n\n\tstatus:=domessage(mess)\n!CPL =STATUS,\"AFTER DOMESS\"\n\n\treturn status\nend\n\nexport proc docs=\n!export proc where dostringzs for entire lib can go\n\t#Option dicts: used as args to gccreatewindow/gxcreatechildwindow:\n\t#\twf_border\t\tBorder style; see wbs_ enums\n\t#\twf_resize\t\t1 for resizable border (for top-level windows)\n\t# wf_hscroll\t\t1 for horizontal scrollbar\n\t# wf_vscroll\t\t1 for vertical scrollbar\n\t# wf_menu\t\t\t1 for a menubar\n\t# wf_caption\t\t1 for a caption bar (needs to be the right kind of border too)\n\t# wf_max\t\t\t1 for a max button\n\t# wf_minmax\t\t1 for a min/max buttons\n\t# wf_sysmenu\t\t1 for a system menu (right-click on top left I think)\n\t# wf_desktop\t\t1 to fill desktop\n\t# wf_clip\t\t\t1 to clip windows to desktop\n\t# wf_show\t\t\t1 to show window after creating\n\t# wf_iframe\t\t1 for pos/dim to refer to frame rather than client area\n\t# wf_cent\t\t\t1 to centre window\n\t# wf_toolwind\t\t1 for tool window (not sure what this means)\n\nend\n\nfunc newwindow(hwnd,index,windclass,borderstyle)=\n\n\tw:=new(rwindow,0)\n\tw.windclass:=windclass\n!w.style.borderstyle:=borderstyle\n\tw.index:=index\n\tw.childlist::=()\n\tw.owner:=nil\n\tw.closed:=0\n\n\taddwindow(w)\n\twx_setw(hwnd,w.gindex)\n\treturn w\nend\n\nexport func getrgb(index)=\n\tif index=0 then return 0 fi\n\treturn colourvalues[index]\nend\n\nfunc readstyle(owner,windclass,options)=\n!process gx options stored in the given dict type\n!return a stylerec all filled in\n\n\tif options.type=stylerec then\t\t\t!already a stylerec\n\t\treturn options\n\tfi\n\n\tss:=new(stylerec)\n\tif options.isvoid then\t\t\t\t!use bunch of defaults\n\t\td::=defstyle\n\t\td.border:=defaultborderstyles[windclass]\n\t\treturn d\n\tfi\n\n\tss.border\t:=options{ss_border,defaultborderstyles[windclass]}\n\tss.justify\t:=options{ss_justify,defstyle.justify}\n\tss.vjustify\t:=options{ss_vjustify,defstyle.vjustify}\n\tss.textfgnd\t:=options{ss_textfgnd,defstyle.textfgnd}\n\tss.textbgnd\t:=options{ss_textbgnd,defstyle.textbgnd}\n\tss.bgndmode\t:=options{ss_bgndmode,defstyle.bgndmode}\n\n\tss.iframe\t:=options{ss_iframe,0}\n\n\tss.hilitetype\t:=options{ss_hilitetype,defstyle.hilitetype}\n\tss.marktype\t:=options{ss_marktype,(ss.hilitetype|0|defstyle.marktype)}\n\tss.imark\t:=options{ss_imark,defstyle.imark}\n\n\tif windclass in [toggle_class, select_class,mark_class] and ss.marktype then\n\t\tdef:=owner.style.windbgnd\n\telse\n\t\tdef:=defstyle.windbgnd\n\tfi\n\n\tss.windbgnd\t:=options{ss_windbgnd,def}\n\tss.hscroll\t:=options{ss_hscroll,0}\n\tss.vscroll\t:=options{ss_vscroll,0}\n\tss.lbchange\t:=options{ss_lbchange,0}\n\tss.returnmess\t:=options{ss_returnmess,0}\n\tss.noupdate\t:=options{ss_noupdate,0}\n\n\treturn ss\nend\n\nexport func gxpanel(owner,pos,dim,?style)=\n\tss:=readstyle(owner,panel_class,style)\n\tw:=gxcontrol(owner,panel_class,pos,dim,ss)\n\tgxdraw(w)\n\n\treturn w\nend\n\nexport func gxgroup(owner,pos,dim,?style)=\n\tss:=readstyle(owner,group_class,style)\n\tw:=gxcontrol(owner,group_class,pos,dim,ss)\n\tgxdraw(w)\n\n\treturn w\nend\n\nexport func gxstatusbar(owner,pos,dim,?style)=\n\n\tss:=readstyle(owner,statusbar_class,style)\n\n\tif ss.iframe=0 then\t\t\t\t\t!frame not included, but can't have it leaking outside owner\n\t\tbs:=ss.border\n\t\tif bscat[bs]<>'I' then\t\t\t!do adjustments\n\t\t\tdim+:=bswidths[bs].y1+bswidths[bs].y2\n\t\tfi\n\t\tss.iframe:=1\t\t\t\t\t!stop gxcontrol expanding dims\n\tfi\n\n\t(ecapos,ecadim):=gxclientarea(owner)\n\n\tif pos.isint then pos:=chr(pos) fi\n!if pos.ispointer then pos:=chr(pos) fi\n\tif convuc(pos) in \"T TOP\" then\t\t\t!along the top\n\t\tpos:=ecapos\n\t\tdir:='T'\n\telse\t\t\t\t\t\t\t\t\t!along the bottom\n\t\tpos:=(ecapos[1],ecadim[2]-dim+ecapos[2])\n\t\tdir:='B'\n\tfi\n\tdim:=(ecadim[1],dim)\n\n\tss.dir:=dir\n\n\tw:=gxcontrol(owner,statusbar_class,pos,dim,ss)\n\n\tgxdraw(w)\n\n\treturn w\nend\n\nexport func gxframebar(owner,pos,dim,?style)=\n\n\tss:=readstyle(owner,framebar_class,style)\n\tif ss.iframe=0 then\t\t\t\t\t!frame not included, but can't have it leaking outside owner\n\t\tbs:=ss.border\n\t\tif bscat[bs]<>'I' then\t\t\t!do adjustments\n\t\t\tdim+:=bswidths[bs].y1+bswidths[bs].y2\n\t\tfi\n\t\tss.iframe:=1\t\t\t\t\t!stop gxcontrol expanding dims\n\tfi\n\n\t(ecapos,ecadim):=gxclientarea(owner)\n\n!if pos.isint then pos:=chr(pos) fi\n\tif pos.ispointer then pos:=chr(pos) fi\n\tif convuc(pos) in \"L LEFT\" then\t\t\t!along the left\n\t\tpos:=ecapos\n\t\tdir:='L'\n\telse\t\t\t\t\t\t\t\t\t!along the right\n\t\tpos:=(ecadim[1]-dim+ecapos[1],ecapos[2])\n\t\tdir:='R'\n\tfi\n\tdim:=(dim,ecadim[2])\n\n\tss.dir:=dir\n\n\tw:=gxcontrol(owner,\tframebar_class,pos,dim,ss)\n\n\tgxdraw(w)\n\n\treturn w\nend\n\nexport func gxbutton(owner,pos,dim,caption,?style,id=201,enable=1)=\n\t#create clickable button\n\t#returns rwindow\n\n\tss:=readstyle(owner,button_class,style)\n\n\tw:=gxcontrol(owner,button_class,pos,dim,ss)\n\tw.id:=id\n\n\tw.text:=caption\n\tw.enable:=enable\n\tgxdraw(w)\n\n\treturn w\nend\n\nexport func gxlabel(owner,pos,dim,caption,?style)=\n\t#create static label button\n\t#returns rwindow\n\n\tss:=readstyle(owner,label_class,style)\n\n\tw:=gxcontrol(owner,label_class,pos,dim,ss)\n\n\tw.text:=caption\n\tgxdraw(w)\n\n\treturn w\nend\n\nfunc gxcontrol(owner,windclass=button_class,pos,dim,?ss)=\n\n\tif ss.type=dict or ss.isvoid then\n\t\tss:=readstyle(owner,windclass,ss)\n\tfi\n\twb:=wbs_none\n\tcase ss.border\t\t\t!find wbs- version of windows-drawn borders\n\twhen bs_simplew then\n\t\twb:=wbs_simple\n\tesac\n\n\tif ss.iframe and bscat[ss.border]<>'I' then\n\t\twidths:=bswidths[ss.border]\n\t\tpos[1]+:=widths.x1\n\t\tpos[2]+:=widths.y1\n\t\tdim[1]-:=widths.x1+widths.x2\n\t\tdim[2]-:=widths.y1+widths.y2\n\tFI\n\n\thwnd:=wx_createcontrol(pos:pos,dim:dim,border:wb,owner:owner.gdi.hwnd)\n\n\tif hwnd=0 then\n\t\tabort(\"Can't create control window\")\n\tfi\n\n\tw:=newwindow(hwnd,0,no_class,ss.border)\n\tw.windclass:=windclass\n\tw.style:=ss\n\tw.owner:=owner\n\tw.enable:=1\n\n\tsetwindowdims_c(w,hwnd)\n\tsetupgdi(w,hwnd)\n\n\tgxdrawmode(w,dm_screenmemory)\n\n\tgxfont(w,labelfont)\n\n\tgxtextcolour(w,w.style.textfgnd,w.style.textbgnd)\n\n\tgxbgndmode(w,w.style.bgndmode)\n\n!link into owner\n\tw.owner.childlist append:=w\n\tw.index:=w.owner.childlist.upb\n\n\treturn w\nend\n\nexport func gxtoggle(owner,pos,dim,caption=\"\",linkvar,?style,id=201,enable=1)=\n\n\t(posx,posy):=pos\n\t(dimx,dimy):=dim\n\ttextoffset:=0\n\n\n\tss:=readstyle(owner,toggle_class,style)\n\n!work out whether an auxiliary window is needed\n\n\tif ss.marktype then\n\t\tif ss.imark=0 then\t\t\t!dims don't include the mark\n\t\t\tposx-:=markdim\n\t\t\tdimx+:=markdim\n\t\t\ttextoffset:=markdim\n\t\tfi\n\tfi\n\n\tw:=gxcontrol(owner,toggle_class,(posx,posy),(dimx,dimy),ss)\n!RETURN 0\n\tw.linkvar:=linkvar\n\tw.id:=id\n\tw.text:=caption\n\tw.attrs:=togglerec(textoffset,1)\n\tw.enable:=enable\n\n\tif w.style.marktype then\n!\tgxmark(owner:w,pos:(0,(w.dimy-markdim)%2),id:id,style:style)\n\t\tgxmark(owner:w,pos:(0,(w.dimy-markdim)%2),id:id, style:ss)\n\tfi\n\n\tgxdraw(w)\n\treturn w\nend\n\nexport func gxselect(owner,pos,dim,caption=\"\",linkvar,onvalue,?style,id=201,enable=1)=\n\n\t(posx,posy):=pos\n\t(dimx,dimy):=dim\n\ttextoffset:=0\n\n\tss:=readstyle(owner,select_class,style)\n\n!work out whether an auxiliary window is needed\n\tif ss.marktype and ss.imark=0 then\t\t\t!dims don't include the mark\n\t\tposx-:=markdim\n\t\tdimx+:=markdim\n\t\ttextoffset:=markdim\n\tfi\n\n\tw:=gxcontrol(owner,select_class,(posx,posy),(dimx,dimy),ss)\n\n\tw.linkvar:=linkvar\n\tw.id:=id\n\tw.text:=caption\n\tw.attrs:=togglerec(textoffset,onvalue)\n\tw.enable:=enable\n\tif w.style.marktype then\n\t\tgxmark(owner:w,pos:(0,(w.dimy-markdim)%2),id:id, style:style)\n\tfi\n\n\tgxdraw(w)\n\treturn w\nend\n\nexport proc showmessage(caption,mess)=\n!RETURN\n!\tCPL MESS.MESSAGE\n\tcp caption,,\":\",leftstr(messagenames[mess.message],14)\n\tcp \"A:\",,mess.a,\"B:\",,mess.b\n\tcp \" (X:\",,mess.x,\"Y:\",,mess.y,,\") Buttons:\",mess.state:\"b\"\n\n\tif mess.wind then\n\t\tcpl \"\tWindow:\",mess.wind.name\n\telse\n\t\tcpl\n\tfi\nend\n\nfunc domessage(mess)=\n\n\tm:=mess.message\n\tw:=mess.wind\n\n\tcase m\n\twhen mm_move,mm_setcursor then\n\t\treturn skipmess\n\tesac\n\n!CPL \"DOMESSAGE\",MESSAGENAMES[M]\n\n!\tCPL messhandlertable[m,w.windclass]\n\tx:=messhandlertable[m,w.windclass](mess,w)\n\n\treturn x\nend\n\nproc init_handlertables=\n\tmesshandlertable:=maketable(mm_null..mm_last, no_class..dummy_class, nil)\n\tactionhandlertable:=maketable(actionnames.bounds, no_class..dummy_class, nil)\n\n\tmessalltable:=new(list,mm_null..mm_last,0)\t\t!for all mess_mess_all handlers\n\tfnallall:=nil\t\t\t\t\t\t\t\t\t!for single mess_all_all handler\n\tfnfixups:=nil\n\n\tactionalltable:=new(list,actionnames.bounds,0)\n\n\tfor d to $nprocs() do\n\t\tfnptr:=$procref(d)\n\t\tfnname:=$procname(d)\n\n\t\t(name,messname,windname):=splitstring(fnname,\"_\")\t\t\t!split func name\n\n\t\tif fnname=\"gxhandler_fixups\" then\n\t\t\tfnfixups:=fnptr\n\t\telsif leftstr(fnname,5)=\"mess_\" then\n\t\t\tif messname=\"all\" and windname=\"all\" then\n\t\t\t\tfnallall:=fnptr\n\t\t\telse\n\t\t\t\tmessage:=(\"mm_\"+messname) inx messagenames\n\t\t\t\tif not message.isfound then\n\t\t\t\t\tABORT(\"CAN'T FIND MESSAGE <\"+messname+\">\")\n\t\t\t\tfi\n\n\t\t\t\tif windname=\"all\" then\t\t\t\t!assume <mess> all\n\t\t\t\t\tmessalltable[message]:=fnptr\n\t\t\t\telse\n\t\t\t\t\tmesshandlertable[message,WX:=findwindclass(windname)]:=fnptr\n\t\t\t\tfi\n\t\t\tfi\n\n\t\telsif leftstr(fnname,8)=\"do_draw_\" or leftstr(fnname,10)=\"do_update_\" then\n\t\t\taction:=messname+\"_w\" inx actionnames\n\t\t\tif not action.isfound then\n\t\t\t\tABORT(\"CAN'T FIND ACTION \"+MESSNAME)\n\t\t\tfi\n\t\t\tif windname=\"all\" then\n\t\t\t\tactionalltable[action]:=fnptr\n\t\t\telse\n\t\t\t\twindclass:=findwindclass(windname)\n\t\t\t\tactionhandlertable[action,windclass]:=fnptr\n\t\t\tfi\n\t\tfi\n\tod\n\n!!do some manual fixups\n\tif fnfixups then\n\t\tfnfixups()\n\tfi\n\n\tfor mx:=0 to mm_last do\n\t\tfor wx:=0 to dummy_class do\n\t\t\tif not messhandlertable[mx,wx] then\n\t\t\t\tmesshandlertable[mx,wx]:=(messalltable[mx]|messalltable[mx]|fnallall)\n\t\t\tfi\n\t\tod\n\tod\n\n\tif not fnallall then\n\t\tpcerror(\"Can't find all/all mess handler\")\n\tfi\n\n\tfor ax:=1 to DRAW_w do\n\t\tfor wx:=0 to dummy_class do\n\t\t\tif not actionhandlertable[ax,wx] then\n\t\t\t\tif not actionalltable then\n\t\t\t\t\tpcerror(\"No DO/ALL handler for:\"+actionnames[ax])\n\t\t\t\tfi\n\t\t\t\tactionhandlertable[ax,wx]:=actionalltable[ax]\n\t\t\tfi\n\t\tod\n\tod\nend\n\nfunc findwindclass(name)=\n\t\twindclass:=name+\"_class\" inx windowclassnames\n\t\tunless windclass.isfound then\n\t\t\tABORT(\"CAN'T FIND WINDOW \"+windname)\n\t\tend\n\t\treturn windclass\nend\n\nexport proc gxdraw(w)=\n\tfnptr:=actionhandlertable[draw_w,w.windclass]\n\n\tif fnptr then\n\t\tfnptr(w)\n\telse\n\t\tcpl \"NO DRAW HANDLER\",windowclassnames[w.windclass],w.name\n\t\twaitkey()\n\t\tstop\n\tfi\nend\n\nexport proc gxupdate(w)=\n\tfnptr:=actionhandlertable[update_w,w.windclass]\n\tif fnptr then\n\t\tfnptr(w)\n\telse\n\t\tgxdraw(w)\n\tfi\nend\n\nexport proc eventloop=\n\tdo\n\t\tm:=gxaskmess()\n\n\t\tSHOWMESSAGE(\"EVENTLOOP\",CURRMESS)\n\n\t\tcase m\n\t\twhen 0,mm_cancel then\n\t\t\treturn\n\t\tesac\n\n\tod\nend\n\nexport func gxeditbox(owner,pos,dim,linkvar,?style,id=201,enable=1)=\n\n\tss:=readstyle(owner,editbox_class,style)\n\n\tw:=gxcontrol(owner,editbox_class,pos,dim,ss)\n\n\tw.linkvar:=linkvar\n\tw.id:=id\n\tw.attrs:=new(editboxrec)\n\tw.attrs.currpos:=linkvar^.len+1\n\tw.enable:=enable\n\n\tgxdraw(w)\n\treturn w\nend\n\nexport proc gxebchange(w,?linkvar,charpos=-1)=\n\n\tif linkvar.isdef then\n\t\tw.linkvar:=linkvar\n\tfi\n\n\tif charpos=-1 then\n\t\tw.attrs.currpos:=w.linkvar^.len+1\n\telse\n\t\tw.attrs.currpos:=charpos\n\tfi\n\tgxupdate(w)\nend\n\nexport proc gxsetlbdata(w,linkvar,?pos)=\n\tw.linkvar:=linkvar\n\tif pos.isvoid then\n\t\tpos:=(linkvar^|1|0)\n\tfi\n\tw.attrs.currpos:=pos\n\n\tif w.childlist[1] then\n!\tgxsetscrolllimits(ws,linkvar^.bounds,w.attrs.rows)\n\t\tgxsetscrolllimits(ws,getlvbounds(linkvar),w.attrs.rows)\n\t\tgxscrollpos(ws,pos)\n\tfi\nend\n\nexport proc gxsetlbpos(w,pos)=\n!change in pos\n\tw.attrs.currpos:=pos\n\n!work out screen row\n\tif pos then\n\t\toldpagepos:=w.attrs.pagepos\n\t\tif pos<oldpagepos then\n\t\t\tw.attrs.pagepos:=pos\n\t\telsif pos>oldpagepos+w.attrs.rows-1 then\n\t\t\tw.attrs.pagepos:=pos-w.attrs.rows+1\n\t\tfi\n\t\tif w.attrs.pagepos<>oldpagepos then\n\t\t\tif w.childlist then\n\t\t\t\tgxscrollpos(w.childlist[1],w.attrs.pagepos)\n\t\t\tfi\n\t\t\tm:=mm_draw\n\t\telse\n\t\t\tm:=mm_update\n\t\tfi\n\telse\n\t\tm:=mm_draw\n\tfi\n\n\tpostmess(w,m)\n\tif w.style.lbchange then\n\t\tpostmess(w,mm_lbchange,w.attrs.currpos)\n\tfi\nend\n\nexport proc gxsetlbpage(w,pagepos)=\n!change in pagepos (originates from scrollbar message)\n\tw.attrs.pagepos:=pagepos\n\n\toldpos:=w.attrs.currpos\n\tif oldpos<pagepos then\n\t\tw.attrs.currpos:=pagepos\n\telsif oldpos>=pagepos+w.attrs.rows then\n\t\tw.attrs.currpos:=pagepos+w.attrs.rows-1\n\tfi\n\n\tif w.childlist then\n\t\tgxscrollpos(w.childlist[1],pagepos)\n\tfi\n\n\tpostmess(w,mm_draw)\n\tif w.style.lbchange and oldpos<>w.attrs.currpos then\n\t\tpostmess(w,mm_lbchange,w.attrs.currpos)\n\tfi\nend\n\nexport func gxlistbox(owner,pos,dim,linkvar,?style,id=201,rows=0,pitch=0,offset=0)=\n\n\tss:=readstyle(owner,listbox_class,style)\n\n\t(dimx,dimy):=dim\n\tif ss_vscroll and ss_imark=0 then\t\t\t!dims don't include the scrollbar\n\t\tdimx+:=arrowdim\n\tfi\n\n\tw:=gxcontrol(owner,listbox_class,pos,(dimx,dimy),ss)\n\tw.linkvar:=linkvar\n\tw.id:=id\n\tw.attrs:=new(listboxrec)\n\n\tif pitch=0 then\t\t\t\t\t\t\t\t!calculate all these here\n\t\tpitch:=listrowheight\n\t\toffset:=0\n\t\trows:=w.dimy%pitch\n\tfi\n\tw.attrs.rows:=rows\n\tw.attrs.pitch:=pitch\n\tw.attrs.offset:=offset\n\n\tw.attrs.pagepos:=1\n\tw.attrs.currpos:=(getlvbounds(linkvar).len|1|0)\n\n\tif w.style.vscroll then\n\t\tws:=gxvertscrollbar(owner:w,pos:(w.dimx-arrowdim,0),dim:w.dimy,id:id,style:style)\n\t\tgxsetscrolllimits(ws,getlvbounds(linkvar),w.attrs.rows)\n\n\t\tgxscrollpos(ws,getlvbounds(linkvar).lwb)\n\tfi\n\n\tgxdraw(w)\n\treturn w\nend\n\nexport func gxarrow(owner,pos,?dim,dir,?style,id=201)=\n\n\tss:=readstyle(owner,arrow_class,style)\n\tif dim.isvoid then\n\t\tdim:=(arrowdim,arrowdim)\n\tfi\n\n\tw:=gxcontrol(owner,arrow_class,pos,dim,ss)\n\tw.id:=id\n\tif dir.isstring then dir:=asc(dir) fi\n\tcase dir\t\t\t\t\t!allow compass bearings too, but convert to UDLR\n\twhen 'N' then dir:='U'\n\twhen 'E' then dir:='R'\n\twhen 'S' then dir:='D'\n\twhen 'W' then dir:='L'\n\tesac\n\n\tw.style.dir:=dir\t\t\t!don't dir allow via style options\n\tgxdraw(w)\n\n\treturn w\nend\n\nexport proc gxsetscrolllimits(w,limits,span=0)=\n!set up or change scrollbar limits\n!span=0:\n!\tPure ranging control. Limits are actual range of the thumb.\n!\tThumb is drawn at a fixed, nominal size. Might be suppressed when limits are <=1\n!\tInitial position set to limits.lwb\n!span=M:\n!\tPaging control, such as used on a listbox or text editor.\n!\tSpan can be the number of rows display at one time.\n!\tLimit can be single number N, or range 1..N.\n!\tActual scroll bar range will be 1..N-M+1. When upper limit<1 then\n!\tlimit will be 1..1, and thumb might not be drawn\n!\tData position will: actually there /is/ not data position, except for the\n!\tdata position represented by the top row, which will be the same as the scroll\n!\tposition.\n!Arrows should be disabled (and perhaps thumb suppressed) when scroll range if 1..1,\n!or data range is nor larger than a span\n\n\tw.attrs.span:=span\n\tif w.style.dir='H' then\n\t\twidth:=w.dimx\n\telse\n\t\twidth:=w.dimy\n\tfi\n\tm:=width-arrowdim*2\t\t\t\t!number of pixels movement between arrows\n\n\tif span=0 then\t\t\t\t\t\t!pure scrolling control\n\t\tw.attrs.limits:=limits\n\t\tw.attrs.currpos:=limits.lwb\n\t\tw.attrs.thumbsize:=arrowdim\n\t\tenable:=limits.len>1\n\t\tw.attrs.thumbsize:=arrowdim*enable\n\telse\n\t\tif limits.isrange then\n\t\t\tlength:=limits.len\n\t\telse\n\t\t\tlength:=limits\n\t\tfi\n\t\tif length<=span then\n\t\t\tenable:=0\n\t\t\tw.attrs.limits:=1..1\n\t\t\tw.attrs.thumbsize:=0\n\t\telse\n\t\t\tw.attrs.limits:=1..length-span+1\n\t\t\tenable:=1\n\t\t\tw.attrs.thumbsize:=max(10,int(m*(span/length)))\n\t\tfi\n\tfi\n\n\tw.attrs.currpos:=w.attrs.limits.lwb\n\tw.enable:=enable\n\n\tw.attrs.thumbspan:=m-w.attrs.thumbsize\t\t!movement available to thumb\n\tw.attrs.thumbpos:=arrowdim\n\tpostmess(w,mm_draw)\nend\n\nexport func gxscrollpos(w,pos,u=0)=\n!\n\tif pos.isvoid then\n\t\treturn w.attrs.currpos\n\tfi\n\n\tCPL =POS\n\tCPL =W.ATTRS.CURRPOS\n\tCPL =W.ATTRS.LIMITS\n\n\tw.attrs.currpos:=pos\n\tif pos not in w.attrs.limits then\n\t\tpcerror(\"Bad scroll pos\")\n\tfi\n\n\ttpos:=int(w.attrs.thumbspan*((pos-w.attrs.limits.lwb)/(w.attrs.limits.len-1)))\n\tw.attrs.thumbpos:=arrowdim+tpos\n\n\tw.childlist[1].enable:=pos>w.attrs.limits.lwb\n\tw.childlist[2].enable:=pos<w.attrs.limits.upb\n\n\tif u then\n\t\tpostmess(w,mm_update)\n\tfi\n\treturn 0\nend\n\nexport func gxhozscrollbar(owner,pos,dim,?style,id=201)=\n\n\tss:=readstyle(owner,scrollbar_class,style)\n\twidth:=arrowdim\n\tif dim.isint then\n!if dim.ispointer then\n\t\tdim:=(dim,width)\n\telse\n\t\twidth:=dim[1]\n\tfi\n\n\tw:=gxcontrol(owner,scrollbar_class,pos,dim,ss)\n\tw.id:=id\n\tw.style.dir:='H'\n\n\tw.attrs:=new(scrollbarrec)\n\tw.flags.[wa_leftdrag]:=1\n\n!Now, create the arrows at each end. The thumbbar is not an explicit control,\n!it's just a drawn box\n\twa:=gxarrow(owner:w, pos:(0,0), dim:(width,width),dir:'L')\n\twb:=gxarrow(owner:w, pos:(dim[1]-width,0), dim:(width,width),dir:'R')\n\n\tgxsetscrolllimits(w,1..200,20)\n\tgxscrollpos(w,1)\n\n\tgxdraw(w)\n\n\treturn w\nend\n\nexport func gxvertscrollbar(owner,pos,dim,?style,id=201)=\n\tss:=readstyle(owner,scrollbar_class,style)\n\twidth:=arrowdim\n\tif dim.isint then\n!if dim.ispointer then\n\t\tdim:=(width,dim)\n\telse\n\t\twidth:=dim[2]\n\tfi\n\n\tw:=gxcontrol(owner,scrollbar_class,pos,dim,ss)\n\tw.id:=id\n\tw.style.dir:='V'\n\n\tw.attrs:=new(scrollbarrec)\n\tw.flags.[wa_leftdrag]:=1\n\n!Now, create the arrows at each end. The thumbbar is not an explicit control,\n!it's just a drawn box\n\twa:=gxarrow(owner:w, pos:(0,0), dim:(width,width),dir:'U')\n\twb:=gxarrow(owner:w, pos:(0,dim[2]-width), dim:(width,width),dir:'D')\n\tgxsetscrolllimits(w,100..200,2)\n\n\tgxscrollpos(w,100)\n\n\tgxdraw(w)\n\n\treturn w\nend\n\nexport func gxmark(owner,pos,?dim,?style,id=201)=\n\n\tss:=readstyle(owner,mark_class,style)\n\tif dim.isvoid then\n\t\tdim:=(markdim,markdim)\n\tfi\n\n\tw:=gxcontrol(owner,mark_class,pos,dim,style)\n\tw.id:=id\n\tgxdraw(w)\n\n\treturn w\nend\n\nexport proc gxfocus(w)=\n!switch focus to window w\n\tif wfocus==w then\n\t\treturn\n\tfi\n\n\tif wfocus then\n\t\tdomessage(makemess(wfocus,mm_killfocus))\n\tfi\n\tcaretdrawn:=0\n\tdomessage(makemess(w,mm_setfocus))\nend\n\nexport proc gxkillfocus=\n\tif wfocus then\n\t\tdrawcaret(0)\n\tfi\n\twfocus:=nil\nend\n\nexport func gxcopy(w,?bm,x=0,y=0,scalex=1.0,scaley=0,sx=0,sy=0,dimx=0,dimy=0)=\t\t!GXCOPY\n!copy bitmap bm to window w, at position x,y in w. Scalex/y can be 0 for 1:1,\n!or Scalex/y can be any real value for unequal x/y scaling\n!For equal x/y scaling, Scaley can be 0\n!Entire bitmap is copied (sx,sy,w,h all 0); for portion, set sx,sy to top left of rect\n!and w,h to size to be copied\n![1..100]char str\n\n\tif bm.isvoid then\n\t\tbm:=w\n\t\tw:=nil\n\tfi\n\tif bm.isvoid then\n\t\treturn nil\n\tfi\n\n\tif dimx=0 then dimx:=bm.dimx-sx fi\n\tif dimy=0 then dimy:=bm.dimy-sy fi\n\n\tif scalex=0 then scalex:=1.0 fi\n\tif scaley=0 then scaley:=scalex fi\n\n\tif w=nil then\t\t!create appropriate window\n\t\tw:=gxcreatewindow(caption:\"Bitmap \"+tostr(bm.pixelbits)+\" bit\",pos:(500,500),\n\t\t\t\tdim:(bm.dimx*scalex,bm.dimy*scaley))\n\t\tw.gdi.drawmode:=dm_screenmemory\t\t\t!default when using auto-window\n\tfi\n\n\tgdi:=w.gdi\n\tgdi.updated:=1\n\n\tmode:=copymode\n\n\tsetstretchbltmode(gdi.hdc,mode)\n\tstretchblt(gdi.hdc, x, y,int(dimx*scalex),int(dimy*scaley),\n\t\t\t\t\t\t\t\t\t\t\t\tbm.gdi.hdc,sx,sy,dimx,dimy, srccopy)\n\tif gdi.drawmode=dm_screenmemory then\n\t\tsetstretchbltmode(gdi.hdc2,mode)\n\t\tstretchblt(gdi.hdc2,x,y,int(dimx*scalex),int(dimy*scaley),\n\t\t\t\t\t\t\t\t\t\t\t\tbm.gdi.hdc,sx,sy,dimx,dimy, srccopy)\n\tfi\n\n\treturn w\nend\n\nexport proc gxrestore(w,?r)=\n!repaint window w\n!only called when repaint can be done from a backup\n!r is the region to restore within w; or restore all if omitted\n\n\tif r.isvoid then\n\t\tx1:=y1:=0\n\n\t\twidth:=w.dimx\n\t\theight:=w.dimy\n\telse\n\t\tx1:=r.x1\n\t\ty1:=r.x2\n\t\twidth:=r.x2-x1+1\n\t\theight:=r.y2-y1+1\n\tfi\n\n\tcase w.gdi.drawmode\n\twhen dm_screen then\t\t\t!can't restore; need to call gx_draw\n\t\tgxdraw(w)\n\twhen dm_screenmemory then\n\t\tdestdc:=w.gdi.hdc\n\t\tsourcedc:=w.gdi.hdc2\n\twhen dm_memoryscreen then\n\t\tdestdc:=w.gdi.hdc2\n\t\tsourcedc:=w.gdi.hdc\n\telse\n\t\tabort(\"gxrest/?\")\n\tesac\n\n\tbitblt(destdc,x1,y1, width,height, sourcedc, x1,y1, srccopy)\n\nend\n\nexport func gxdrawmode(w,?drawmode)=\n!set or get drawmode\n!really requires window to be cleared afterwards.\n\n\tolddrawmode:=w.gdi.drawmode\n\tif drawmode.isvoid then\n\t\treturn olddrawmode\n\tfi\n\n\tif olddrawmode=drawmode then\t\t!already set\n\t\treturn drawmode\n\telsif olddrawmode<>dm_screen then\t!can only change screen => screenmemory/memoryscreen\n\t\tabort(\"gxdrawmode2\")\t\t\t!not memory to anything else\n\tfi\n\n!assuming currently on screen, will need extra compatible bitmap\n\tmemhwnd:=createcompatiblebitmap(screendc,w.dimx,w.dimy)\n\tmemhdc:=createcompatibledc(nil)\n\tselectobject(memhdc,memhwnd)\n\n!need to change draw mode\n\tcase drawmode\n\twhen dm_screenmemory then\n\t\tw.gdi.hwnd2:=memhwnd\n\t\tw.gdi.hdc2:=memhdc\n\twhen dm_memoryscreen then\n\t\tw.gdi.hwnd2:=w.gdi.hwnd\t\t\t!screen becomes secondary\n\t\tw.gdi.hdc2:=w.gdi.hdc\n\t\tw.gdi.hwnd:=memhwnd\n\t\tw.gdi.hdc:=memhdc\n\telse\n\t\tabort(\"gxdrawmode?\")\n\tesac\n\n\tw.gdi.drawmode:=drawmode\n\treturn drawmode\nend\n\nexport proc switchdest(w)=\n!for a window with screenmemory drawmode, switch things around so that\n!it's drawing into the memory area only\n\tgdi:=w.gdi\n\n\tcase gdi.drawmode\n\twhen dm_screenmemory then\n\t\tt:=gdi.hwnd; gdi.hwnd:=gdi.hwnd2; gdi.hwnd2:=t\n\t\tt:=gdi.hdc; gdi.hdc:=gdi.hdc2; gdi.hdc2:=t\n\t\tgdi.drawmode:=dm_memory\n\twhen dm_memory then\n\t\tt:=gdi.hwnd; gdi.hwnd:=gdi.hwnd2; gdi.hwnd2:=t\n\t\tt:=gdi.hdc; gdi.hdc:=gdi.hdc2; gdi.hdc2:=t\n\t\tgdi.drawmode:=dm_screenmemory\n\tesac\nend\n\nexport proc gxclose(w)=\n\n!CPL \"GXCLOSE1\",$REFCOUNT(W)\n\n\tcase w.windclass\n\twhen bitmap_class then\n\telse\n!ID:=$ID(W)\n\t\tif issubwindow(w,wfocus) then\n\t\t\twfocus:=nil\n\t\tfi\n\n\t\tif issubwindow(w,wmouse) then\t\n\t\t\tlastmousewindow:=nil\n\t\t\twmouse:=nil\n\t\tfi\n\n\t\tdestroywindow(w.gdi.hwnd)\n\n!IF $ID(CURRMESS.WIND)=ID THEN\n!CPL \"-------CLOSED CURRMESS.WIND\"\n!CURRMESS.WIND:=NIL\n!FI\n!CPL \"GXCLOSE2\",$REFCOUNT(W)\n\n\t\tgxfreewindow(w)\n!CPL \"GXCLOSE3\",$REFCOUNT(W)\n\n\tIF W=WAPPLIC THEN WAPPLIC:=NIL FI\n\n\tesac\nend\n\nproc gxfreewindow(w)=\n!recover memory used by this window and all childwindows\n\tfor wc in w.childlist do\n\t\tgxfreewindow(wc)\n\tod\n\n\tremovewindow(w)\n\n!CPL \"FREEING2\",$ID(W),$ID(W.GDI), $REFCOUNT(W), $REFCOUNT(W.GDI)\n\tw.gdi:=0\n\n!\tw:=0\nend\n\nexport func gxmsgbox(message,caption=\"\",options=\"\")=\n\n\tconst mb_abortretryignore\t= 0x02\n\tconst mb_applmodal\t\t\t= 0x00\n\tconst mb_defbutton1\t\t\t= 0x00\n\tconst mb_defbutton2\t\t\t= 100\n\tconst mb_defbutton3\t\t\t= 200\n\tconst mb_defbutton4\t\t\t= 300\n\tconst mb_help\t\t\t\t= 4000\n\tconst mb_iconasterisk\t\t= 40\n\tconst mb_iconerror\t\t\t= 10\n\tconst mb_iconexclamation\t= 30\n\tconst mb_iconhand\t\t\t= mb_iconerror\n\tconst mb_iconinformation\t= mb_iconasterisk\n\tconst mb_iconquestion\t\t= 20\n\tconst mb_iconstop\t\t\t= mb_iconhand\n\tconst mb_iconwarning\t\t= mb_iconexclamation\n\tconst mb_ok\t\t\t\t\t= 0x00\n\tconst mb_okcancel\t\t\t= 0x01\n\tconst mb_retrycancel\t\t= 0x05\n\tconst mb_right\t\t\t\t= 80000\n\tconst mb_setforeground\t\t= 10000\n\tconst mb_systemmodal \t\t= 1000\n\tconst mb_taskmodal\t\t\t= 2000\n\tconst mb_yesno\t\t\t\t= 0x04\n\tconst mb_yesnocancel\t\t= 0x03\n\tconst mb_topmost\t\t\t= 0x040000\n\n!return values\n\tconst idfail\t= 0\n\tconst idok\t\t= 1\n\tconst idcancel\t= 2\n\tconst idabort\t= 3\n\tconst idretry\t= 4\n\tconst idignore\t= 5\n\tconst idyes\t\t= 6\n\tconst idno\t\t= 7\n\n\tstatic var rettable=(0:\"fail\",\"ok\",\"cancel\",\"abort\",\"retry\",\"ignore\",\"yes\",\"no\",\n\t\t\t\"\",\"\",\"tryagain\",\"continue\")\n\n\tstatic var styletable=(\n\t(\"bari\",mb_abortretryignore),\n\t(\"bo\",mb_ok),\n\t(\"boc\",mb_okcancel),\n\t(\"brc\",mb_retrycancel),\n\t(\"byn\",mb_yesno),\n\t(\"bync\",mb_yesnocancel),\n\t(\"ix\",mb_iconexclamation),\n\t(\"iw\",mb_iconwarning),\n\t(\"ii\",mb_iconinformation),\n\t(\"iq\",mb_iconquestion),\n\t(\"is\",mb_iconstop),\n\t(\"ie\",mb_iconerror),\n\t(\"ih\",mb_iconhand),\n\t(\"d1\",mb_defbutton1),\n\t(\"d2\",mb_defbutton2),\n\t(\"d3\",mb_defbutton3),\n\t(\"d4\",mb_defbutton4),\n\t(\"h\",mb_help),\n\t(\"rj\",mb_right),\n\t(\"sm\",mb_systemmodal))\n\n\thwnd:=nil\n\n\tstyle:=0\n\toptioncodes:=splitstring(options,\" \")\n\n\tfor opt in optioncodes do\n\t\tfor i to styletable.len do\n\t\t\tif styletable[i,1]=opt then style ior:=styletable[i,2] fi\n\t\tod\n\tod\n\n\tstyle ior:=0x10000\n\n\tx:=messageboxa(hwnd,message,caption,style)\n\treturn rettable[x]\nend\n\n\nexport proc gxhandler(windclass,mess,fnptr)=\n!windclass is a window, or a window class\n!override the current message handler for w's window class, and fo message mess\n\n!if not windclass.isint then\n\tif not windclass.ispointer then\n\t\twindclass:=windclass.windclass\n\tfi\n\n!CPL \"SETTING GXHANDLER\",MESS,WINDCLASS,FNPTR\n\tmesshandlertable[mess,windclass]:=fnptr\nend\n\nexport func gxaskfile(caption=\"File\",filespec=\"*.*\",deffile=\"\",startdir=\"\")=\n\n\tsave:=0\n\tif caption='*' then\n\t\tsave:=1\n\t\tcaption:=rightstr(caption,-1)\n\tfi\n\n\tfilters:=array(filespec+\"@@@\")\t\t!turn into a byte-array\n\n\tfor i,bb in filters do\t\t\t!convert all @ into embedded zeros\n\t\tif bb='@' then filters[i]:=0 fi\n\tod\n\n\tofn:=new((iswin32|ws_openfilename32|ws_openfilename64))\n\n\tofn.structsize:=ofn.bytes\n\tofn.owner:=wapplic.gdi.hwnd\n\tofn.instance:=getmodulehandle(0)\n\tofn.filter:=int(&filters)\n\tofn.flags:=ofn_explorer ior ofn_nochangedir ior ofn_hidereadonly !IOR OFN_NOVALIDATE\n\n\tofn.initialdir:=getstringz(startdir)\n\n\tofn.defext:=getstringz(\"\")\n\n\tresult:=new(array,byte,300)\n\n\tresult[1]:=0\n\tif deffile<>\"\" then\n\t\tmemcpy(&result,&deffile,deffile.len)\n\tfi\n\n\tofn.file:=int(&result)\n\n\tofn.maxfile:=256\n\tofn.title:=getstringz(caption)\n\n\tif not (not save | getopenfilenamea(&ofn) | getsavefilenamea(&ofn)) then\n\t\tresult[1]:=0\t\t!return \"\" on error\n\tfi\n\n\treturn string(result)\nend\n\nexport func gxcurrpos(w)=\n\treturn w.attrs.currpos\nend\n\nexport func gxtabstops(?tabs,signed=0)=\n\tif tabs.isdef then\n\t\ttabstops::=tabs\n\t\tif signed then\n\t\t\tfor i,x in tabstops do\n\t\t\t\ttabstops[i]:=abs(x)\n\t\t\tod\n\t\tfi\n\tfi\n\treturn tabstops\n\nend\n\nexport func getlvbounds(linkvar)=\n\tif linkvar.ispointer and linkvar^.islist then\n\t\treturn linkvar^.bounds\n\telse\n\t\treturn linkvar.getbounds()\n\tfi\n\treturn 0\nend\n\nexport func getlvitem(linkvar,n)=\n\tif linkvar.ispointer and linkvar^.islist then\n\t\treturn linkvar^[n]\n\telse\n\t\tPCERROR(\"GETLVITEM\")\n\tfi\n\treturn 0\nend\n\nexport func getlvstritem(linkvar,n)=\n\tif linkvar.ispointer and linkvar^.islist then\n\t\treturn tostr(linkvar^[n])\n\telse\n\t\treturn linkvar.getstritem(n)\n\tfi\n\treturn 0\nend\n\nexport proc gxtext16(w,s,n,x=0,y=0)=\t\t!GXTEXT\n\t\tgdi:=w.gdi\n\n\t\ttextoutw(gdi.hdc,x, y,&s,n)\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\ttextoutw(gdi.hdc2,x,y,&s,n)\n\t\tfi\nend\n\nexport func gxenable(w,flag)=\n\tif flag.isdef then\n\t\tw.enable:=flag\n\t\tgxupdate(w)\n\tfi\n\treturn w.enable\nend\n\nexport func gxclientarea(w)=\n!scan child windows of w, work out remaining client area after taking account of\n!framebars etc\n!return (pos, dim), each being a 2-element list\n\n\taposx:=aposy:=0\n\n\tadimx:=w.dimx\n\tadimy:=w.dimy\n\n\tcentx:=(aposx+adimx)%2\n\tcenty:=(aposy+adimy)%2\n\n!for cw in w.childlist when cw.windclass in [statusbar_class,framebar_class] do\n\tfor cw in w.childlist do\n\n\t\t(posx,posy):=(cw.frameposx,cw.frameposy)\n\t\t(dimx,dimy):=(cw.framedimx,cw.framedimy)\n\n!need to find out which of the four sides the bar is against, and set up side= L R T B\n\t\tcase cw.style.dir\n\t\twhen 'B' then\t\t\t\t!bottom\n\t\t\tif posy<(aposy+adimy) then\n\t\t\t\tadimy-:=dimy\n\t\t\tfi\n\n\t\twhen 'T' then\t\t\t\t!top\n\t\t\tif (posy+dimy)>aposy then\t\t!\n\t\t\t\taposy+:=(posy+dimy)\n\t\t\t\tadimy-:=(posy+dimy)\n\t\t\tfi\n\n\t\twhen 'R' then\t\t\t\t!right\n\t\t\tif posx<(aposx+adimx) then\n\t\t\t\tadimx-:=dimx\n\t\t\tfi\n\n\t\twhen 'L' then\t\t\t\t!LEFT\n\t\t\tif (posx+dimx)>aposx then\t\t!\n\t\t\t\taposx+:=(posx+dimx)\n\t\t\t\tadimx-:=(posx+dimx)\n\t\t\tfi\n\t\telse\n\n\t\t\tif dimx>dimy then\t\t\t!assume hoz\n\t\t\t\tif posy>centy then\t\t\t!assume bottom\n\t\t\t\t\tif posy<(aposy+adimy) then\n\t\t\t\t\t\tadimy-:=dimy\n\t\t\t\t\tfi\n\n\t\t\t\telse\t\t\t\t\t!top\n\t\t\t\t\tif (posy+dimy)>aposy then\t\t!\n\t\t\t\t\t\taposy+:=(posy+dimy)\n\t\t\t\t\t\tadimy-:=(posy+dimy)\n\t\t\t\t\tfi\n\t\t\t\tfi\n\t\t\telse\t\t\t\t\t!assume vert\n\t\t\t\tif posx>centx then\t\t\t!assume right\n\n\t\t\t\t\tif posx<(aposx+adimx) then\n\t\t\t\t\t\tadimx-:=dimx\n\t\t\t\t\tfi\n\n\t\t\t\telse\t\t\t\t\t!left\n\n\t\t\t\t\tif (posx+dimx)>aposx then\t\t!\n\t\t\t\t\t\taposx+:=(posx+dimx)\n\t\t\t\t\t\tadimx-:=(posx+dimx)\n\t\t\t\t\tfi\n\n\t\t\t\tfi\n\t\t\tfi\n\t\tesac\n\tod\n\n\treturn ((aposx,aposy), (adimx,adimy))\nend\n\nexport func addwindow(w)=\n!w is a newly created window\n!add it to all windows\n\tn:=nil inx allwindows\n\tif not n.isfound then\n\t\tn:=allwindows.len+1\n\tfi\n\n\tallwindows[n]:=w\n\tw.gindex:=n\n\treturn n\nend\n\nexport proc removewindow(w)=\n!remove w from all windows\n\tn:=w inx allwindows\n\tif n.isfound then\n\t\tallwindows[n]:=nil\n\tfi\n\n\tfor i to nmessages do\n\t\tm:=messagequeue[i]\n\t\tif m.wind==w then\n\t\t\tm.wind:=nil\n\t\tfi\n\tod\n\n!\tif currmess.wind==w then\n!\t\tcurrmess.wind:=nil\n!\tfi\n\nend\n\nfunc process_wmmessage(msg)=\n!STATIC VAR CC=0\n!CPL \"PROCESS/WMMESSAGE\",++CC\n!CPL \"PROC/WM1\",MSG, MSG.HWND\n\t\tx:=process_wmmessage2(msg)\n!CPL \"RETURN X:\",X\n!$SETDEBUG(1)\n\t\treturn x\nend\n\nfunc process_wmmessage2(msg)=\n!msg is a windows rmsg record\n!Called from MainWndProc callback func (via mechanisms for B code to call into MPL code)\n!this func processes some wm_ Windows messages and converts them\n!into mm_ messages as necessary\n!It returns:\n!\t0 The wm_ message has been processed\n!\t1 The wm_ message has not been processed, and the caller should call DefWindowProc.\n!\t  Or, the DefWindowProc should also be called anyway.\n\n!CPL \"PROCESSWMM2\",MSG.MESSAGE, WINMESSAGENAMES{MSG.MESSAGE}\n\n\thwnd:=msg.hwnd\n!CPL \"PM2\",=HWND,MSG.HWND\n\tw:=getwindow(hwnd)\n!CPL \"AFTER GW1\"\n\n\tmessage:=msg.message\n\twparam:=msg.wparam\n\tlparam:=msg.lparam\n\n\tcase msg.message\n\twhen wm_command then\n\t\tw:=getwindow(lparam)\t\t\t!w was owner, use control window\n!CPL \"AFTER GW2\"\n\t\ti:=wparam iand 0xffff\t\t\t!id\n\t\tj:=wparam>>16\t\t\t\t!notify code\n\t\tm:=mm_command\n\n\t\tif not w then\n\t\t\tw:=wapplic\n\t\tfi\n\n\t\tpostmess(w,m,i,j,0)\n\n\t\treturn 0\n\n\twhen wm_activate then\n\t\tif wparam then\t\t\t\t!being activated\n\t\tfi\n\n\twhen wm_syskeydown,wm_syskeyup,wm_keydown,wm_keyup then\n!\n!\tSTATIC VAR COUNT=0\n!\n!\tIF MSG.MESSAGE=WM_KEYDOWN THEN\n!\tCPL \"KEY\",++COUNT\n!\tFI\n\n\t\tif dokeymessage(hwnd,message,wparam,lparam) then\n\t\t\treturn 0\n\t\tfi\n\n\twhen wm_char then\n\t\tpostmess((wfocus|wfocus|w),mm_char,wparam,lparam,0)\n\n\twhen wm_close then\n\t\tif w==wapplic then\n\t\t\tpostmess(w,mm_close,0,0,0)\n\t\t\treturn 0\n\t\telse\n\t\t\tpostmess(w,mm_cancel,0,0,0)\n\t\t\treturn 0\n\t\tfi\n\n\twhen wm_timer then\n\t\tif not background and not stationary then\t\t!test for pausing of mouse\n\t\t\tif gettickcount()-lastxytime>pausetime then\n\t\t\t\tstationary:=1\n\t\t\tfi\n\t\tfi\n\n\twhen wm_destroy then\n\t\tif w and wapplic and w==wapplic then\n\t\t\tkilltimer(hwnd,1)\n!*\t\tif tick then killtimer(hwnd,1) fi\n!CPL \"**********************POSTING QUIT WM\",WAPPLIC\n\n\n!\t\t\tpostquitmessage(0)\t\t\t!mm_quit message\n\t\t\treturn 0\n\t\telse\n\t\t\treturn 1\n\t\tfi\n\n!when wm_setcursor then\n!\tpostmess(w,mm_setcursor,wparam,lparam,0)\n\n\twhen wm_mousemove then\n\n\t\tbuttonstate:=wparam iand (kb_lbutton ior kb_rbutton ior kb_mbutton)\n\t\tmousepos.x:=lparam iand 65535\n\t\tmousepos.y:=lparam>>16\n\n\tdomousemove:\n\t\txyvalid:=1\t\t\t\t!known again\n\t\tsetnewmousewindow(w)\n\n\t\twmouse:=w\n\t\tpostmess(wmouse,mm_move)\n\n\t\tlastxy::=getscreencoords(wmouse,mousepos)\n\t\tlastxytime:=gettickcount()\n\t\tstationary:=0\n\n!do drag processing; states are:\n!pen up/recent pen down/first drag/subsequent drag\n!any drag messages are sent as well as mm_move messages\n!dragmode=1/2/3 indicates drag has started (reset by buttonswitching)\n\n\t\tif buttonstate<>0 and lastmousewindow<>nil then\t\t!switch pressed\n\t\t\tpt:=getscreencoords(lastmousewindow,lastmousepos)\n\t\t\tdx:=lastxy.x-pt.x\n\t\t\tdy:=lastxy.y-pt.y\n\n\t\t\tif dragmode then\t\t!1st drag message already generated\n\t\t\t\tpostmess(lastmousewindow,mm_drag,dx,dy,-1)\t\t\t!send latest drag coords\n\n\t\t\telse\t\t\t\t!test for drag enabling\n\t\t\t\tif ((mousesw=1 and lastmousewindow.flags.[wa_leftdrag]<>0) or \\\n\t\t\t\t\t\t\t\t(mousesw=2 and lastmousewindow.flags.[wa_rightdrag]<>0) or \\\n\t\t\t\t\t\t\t\t(mousesw=3 and lastmousewindow.flags.[wa_middledrag]<>0)) and \\\n\t\t\t\t\t\t\t(abs(dx)>dragtol or abs(dy)>dragtol) then\n\t\t\t\t\tdragmode:=mousesw\n\t\t\t\t\tpostmess(lastmousewindow,mm_startdrag,dx,dy,-1)\t\t!send latest drag coords\n\t\t\t\tfi\n\n\t\t\tfi\n\t\telse\n\t\t\tif dragmode then\n\t\t\t\tpostmess(lastmousewindow,mm_enddrag,dx,dy,-1)\t!send latest drag coords\n\t\t\t\tdragmode:=0\n\t\t\tfi\n\t\tfi\n\n\t\treturn 0\n\n\twhen wm_enteridle then\t\t!enter idle\n\t\tidlemode:=1\n\t\treturn 0\n\n\twhen wm_paint then\n\n\t\tif w<>nil then\n\t\t\tps:=new(ws_paintstruct)\n\t\t\trect:=new(ws_rect)\n\t\t\tbeginpaint(hwnd,&ps)\n\t\t\tpostmess(w,mm_restore,0,0,0)\n\t\t\tendpaint(hwnd,&ps)\n\t\t\treturn 0\n\t\tfi\n\n\twhen wm_erasebkgnd then\n\n\twhen wm_move then\n\t\tif w<>nil then\n!*!\t\tgxmovewindow(w,lparam iand 65535,lparam>>16)\n\t\tfi\n\n\twhen wm_size then\n\t\tx:=lparam iand 0xffff\n\t\ty:=lparam>>16\n\t\tif w<>nil  and (w.dimx<>x or w.dimy<>y) then\n!*!\t\tgxmplresize(w,x,y,wparam)\n\t\t\treturn 0\n\t\tfi\n\n!when wm_killfocus,wm_setfocus then\n\n\twhen wm_contextmenu then\n\t\tsendmess(w,mm_rclick,wparam>>16,wparam iand 0xffff,0)\n\t\treturn 0\n\n\twhen wm_mousewheel then\n\t\tif not wmouse then wmouse:=w fi\n\t\tpostmess(wmouse,mm_wheel,int(wparam>>16),wparam iand 0xffff,0)\n\t\treturn 0\n\n\twhen wm_nclbuttondown,wm_nclbuttondblclick then\n\n\twhen wm_activateapp then\n\t\tif wparam then\n\t\t\tpostmess(w,mm_activate,1,0,0)\n\t\tfi\n\n\telse\n\tbtnmessages:\n!check for sequential messages\n!CPL \"FALLTHROUGH\"\n\t\tif message>=wm_lbuttondown and message<=wm_mbuttondblclk then\n\t\t\tbuttonmessages(hwnd,message,wparam,lparam)\n\t\t\treturn 0\n\t\tfi\n\tesac\n!end\n!fall-through here to do default message processing instead of/in addition to local processing\n\treturn 1\t!defwindowproc(hwnd,imsg,wparam,lparam)\nend\n\nexport proc mxinit=\n\twmessagetable := [\\\n\t\twm_lbuttondown:\t\tmm_click,\n\t\twm_lbuttonup:\t\tmm_clickup,\n\t\twm_lbuttondblclk:\tmm_dblclick,\n\n\t\twm_rbuttondown:\t\tmm_rclick,\n\t\twm_rbuttonup:\t\tmm_rclickup,\n\t\twm_rbuttondblclk:\tmm_rdblclick,\n\n\t\twm_mbuttondown:\t\tmm_mclick,\n\t\twm_mbuttonup:\t\tmm_mclickup,\n\t\twm_mbuttondblclk:\tmm_mdblclick]\n\n!table gives button number 1,2,3 for Windows button message (always 0 for button up)\n\tbuttontable\t:= [\\\n\t\twm_lbuttondown:\t\t1,\n\t\twm_lbuttonup:\t\t0,\n\t\twm_lbuttondblclk:\t1,\n\n\t\twm_rbuttondown:\t\t2,\n\t\twm_rbuttonup:\t\t0,\n\t\twm_rbuttondblclk:\t2,\n\n\t\twm_mbuttondown:\t\t3,\n\t\twm_mbuttonup:\t\t0,\n\t\twm_mbuttondblclk:\t3]\n\n\tmousepos:=new(ws_point)\n\n\tsetmesshandler(process_wmmessage)\n!CPL =PROCESS_WMMESSAGE\n!setmesshandler(bill)\n\n\tvktomesstable:=[\\\n\t\tvkleft:\t\tmm_leftkey,\n\t\tvkright:\tmm_rightkey,\n\t\tvkup:\t\tmm_upkey,\n\t\tvkdown:\t\tmm_downkey,\n\t\tvkpageup:\tmm_pageupkey,\n\t\tvkpagedown:\tmm_pagedownkey,\n\t\tvkhome:\t\tmm_homekey,\n\t\tvkend:\t\tmm_endkey,\n\t\tvktab:\t\tmm_tabkey,\n\t\tvkbackspace:\tmm_bskey,\n\t\tvkdelete:\tmm_deletekey,\n\t\tvkenter:\tmm_enterkey,\n\t\tvkinsert:\tmm_insertkey,\n\t\tvkescape:\tmm_cancel\n\t]\nend\n\nexport func postmess(w,mess,a=0,b=0,c=0)=\n!add message m to end of message queue\n!use mess+1000 to add message to start of queue rather than the end\n\n\tif w=nil then w:=wapplic fi\n\tif w=nil then\n return 0 fi\n\n\tif w.flags.[wa_closed] then\n\n return 0 fi\n\n\tif mess>=1000 then\n\t\theadx:=1; mess-:=1000\n\telse\n\t\theadx:=0\n\tfi\n\n!check if new message can be combined with an old message\n\tcase mess\n\twhen mm_sethozpos,mm_setvertpos,mm_draw,mm_restore,mm_update then\n\t\tfor i:=1 to nmessages do\n\t\t\tm:=messagequeue[i].message\n\t\t\tif m=mess and w==messagequeue[i].wind then\t\t\t\t!use the old message but update any params\n\t\t\t\tmessagequeue[i].a:=a\n\t\t\t\tmessagequeue[i].b:=b\n\t\t\t\treturn 0\n\t\t\telsif mess=mm_draw and m=mm_update then\t\t!convert update to draw\n\t\t\t\tmessagequeue[i].message:=mm_draw\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tod\n\tesac\n\n\tif quitmess or nmessages>=maxqueuesize then\n\t\treturn 0\n\tfi\n\n\tpostmsg(makemess(w,mess,a,b,c))\n\n\treturn 0\t\t\t\t\t!return zero for use in mainwndproc\nend\n\nexport func postmsg(msg,headx=0)=\n!add complete message msg to end of message queue\n!use head=1 to add to start of queue rather than the end\n\n\tif quitmess or nmessages>=maxqueuesize then\n\t\treturn 0\n\tfi\n\n\tif msg.wind.flags.[wa_closed] then return 0 fi\n\n\tif headx then\n\n!avoid dupl paint messages\n\t\t++nmessages\n\t\tfor i:=nmessages downto 2 do\n\t\t\tmessagequeue[i]:=messagequeue[i-1]\n\t\tod\n\t\tmessagequeue[1]:=msg\n\n\telse\n\t\t++nmessages\n\t\tmessagequeue[nmessages]:=msg\n\tfi\n\n\treturn 0\t\t\t\t\t!return zero for use in mainwndproc\nend\n\nexport proc sendmess(w,mess,a=0,b=0,c=0)=\n!add message m to head of message queue\n!(may be 100% handled in q smlib)\n\n\tif w=nil then return fi\n\tif w.flags.[wa_closed] then return fi\n\n\tsendmsg(makemess(w,mess,a,b,c))\nend\n\nproc sendmsg(msg)=\n!call event handler for msg or add to head of queue\n\tif msg.wind.flags.[wa_closed] then return fi\n\tpostmsg(msg,1)\nend\n\nexport func makemess(w,mess,a=0,b=0,state=-1)=\n!turn params into a new messrec @nemm_ess\n!the q version makemess also accepts makemess(w,msg)\n\n\tif w=nil then w:=wapplic fi\n\n\tm:=new(rmessage,0)\n\n\tm.wind:=w\n\n\tm.message:=mess\n\tm.a:=a\n\tm.b:=b\n\tm.state:=state\n\n\tm.x:=mousepos.x\n\tm.y:=mousepos.y\n\n\tif m.state=-1 then m.state:=getshiftstate() fi\n\n\treturn m\nend\n\nfunc dokeymessage(hwnd,msg,wparam,lparam)=\n!return 1 if message has been dealt with\n\n\tcase msg\n\twhen wm_syskeydown then\n\t\tif wparam=vkf10 then msg:=wm_keydown; goto dokey fi\n\n\twhen wm_syskeyup then\n\t\tif wparam=vkf10 then msg:=wm_keyup; goto dokey fi\n\n\twhen wm_keydown,wm_keyup then\n\tdokey:\n\t\tcase wparam\n\t\twhen vkshift,vkctrl,vkalt,vkcapslock then\n\t\telse\n\t\t\tw:=wfocus\n!\t\tif not w then w:=wx_getw(hwnd) fi\n!CPL \"XXXXX\"\n\t\t\tif not w then w:=getwindow(hwnd)\n!CPL \"AFTER GW3\"\n fi\n!CPL =GETSHIFTSTATE()\n!\t\tpostmess(w,(msg=wm_keydown|mm_key|mm_keyup),wparam,getshiftstate(),lparam)\n\t\t\tpostmess(w,(msg=wm_keydown|mm_key|mm_keyup),wparam,lparam,-1)\n\t\t\treturn 1\n\t\tesac\n\tesac\n\treturn 0\nend\n\nfunc getshiftstate=\n\tstate:=0\n\n\tif getkeystate(vklshift) iand 0x8000 then state ior:=kb_shift fi\n\tif getkeystate(vklcontrol) iand 0x8000 then state ior:=kb_ctrl fi\n\tif getkeystate(vklalt) iand 0x8000 then state ior:=kb_alt fi\n\n\tif getkeystate(vkrshift) iand 0x8000 then state ior:=kb_rshift fi\n\tif getkeystate(vkrcontrol) iand 0x8000 then state ior:=kb_rctrl fi\n\tif getkeystate(vkralt) iand 0x8000 then\n\t\tstate ior:=kb_ralt\n\t\tstate iand:=(inot kb_ctrl)\t\t\t!AltGr gives Lctrl+Ralt; return Ralt only\n\tfi\n\tif getkeystate(vkcapslock) iand 1 then state ior:=kb_capslock fi\n\n\treturn state ior buttonstate\nend\n\nproc buttonmessages(hwnd,msg,wp,lp)=\n!process Windows mouse message <msg>\n\n!update button from wparam, excluding ctrl/shift (which are updated from key msgs)\n\tbuttonstate:=wp iand (kb_lbutton ior kb_rbutton ior kb_mbutton)\n\n!update mouse position\n\tmousepos.x:=lp iand 0xffff\n\tmousepos.y:=int(lp)>>16\n\twmouse:=getwindow(hwnd)\n!CPL \"AFTER GW4\"\n\n!set mousesw to last pressed button (1,2,3) or 0 if one just released\n!(note other buttons may still be down, used for drag processing)\n\tmousesw:=buttontable{msg}\n\n\tif mousesw then\t\t\t!down up on click or dblclick\n\t\tlastbuttontime:=gettickcount()\n\t\tlastmousepos::=mousepos\n\t\tlastmousewindow:=wmouse\n\telse\n\t\tmousesw:=0\n\n\t\tif dragmode then\n\t\t\tpostmess(lastmousewindow,mm_enddrag,0,0,-1)\n\t\t\tdragmode:=0\n\t\tfi\n\n\t\tlastbuttontime:=0\n\t\tlastmousewindow:=nil\n\tfi\n\n\tnewmess:=wmessagetable{msg}\n\n!filter double-click messages and convert to repeated click if not enabled\n\tcase newmess\n\twhen mm_dblclick then unless wmouse.flags.[wa_leftdbl] then newmess:=mm_click end\n\twhen mm_rdblclick then unless wmouse.flags.[wa_rightdbl] then newmess:=mm_click end\n\tesac\n\n\tpostmess(wmouse,newmess,wmouse.id,0,-1)\nend\n\nproc setnewmousewindow(w)=\n\treturn when not currmousewindow\n\tunless w==currmousewindow then\t\t!changed\n\t\tif currmousewindow<>nil then\n\t\t\tpostmess(currmousewindow,mm_offwindow,0,0,0)\n\t\tfi\n\n\t\tcurrmousewindow:=w\n\t\tpostmess(w,mm_onwindow,0,0,0)\n\tend unless\nend\n\nproc frame2rect(f,r)=\n\tr^.x:=f^.x\n\tr^.y:=f^.y\n\n\tr^.dimx:=f^.x2-f^.x1+1\n\tr^.dimy:=f^.y2-f^.y1+1\nend\n\nexport func mxwait_mm_message=\n\t#do windows dispatch loop\n\t#calling dispatchmessage() results in mainwndproc being called in interpreter,\n\t#which passes the Windows message params on to process_wmmessage() in this module\n\t#process_wmmessage() converts wm-messages to mpl mm-messages\n\t#return when at least one mm message is ready; (will return immediately if there\n\t#is already one in the queue)\n\t#return value is normall 1, or 0 when quitmess has been encountered\n\n\tif quitmess then\t\t\t\t!quit message already seen\nCPL \"-----------------QUITMESS SEEN\"\n\t\treturn 0\n\tfi\n\n\twindmsg:=new((iswin32|ws_msg32|ws_msg64))\n\n\twhile nmessages<=0 do\n\t\tif x:=getmessage(&windmsg,nil,0,0)<>0 then\n\t\t\tw:=windmsg.hwnd\n\t\t\ttranslatemessage(&windmsg)\n\t\t\tdispatchmessage(&windmsg)\n\t\telse\nCPL \"----GETMESSAGE RETURMS 0\"\n\t\t\tquitmess:=1\n\t\t\texit\n\t\tfi\n\tod\n\n\tif not nmessages then\t\t\t!assume quit message seen\nCPL \"----------NO MESSAGES\"\n\t\treturn 0\n\tfi\t\n\n\tcurrmess:=messagequeue[1]\n\t--nmessages\n\n\txlatkeyboard()\n\n\tfor i:=1 to nmessages do\n\t\tmessagequeue[i]:=messagequeue[i+1]\n\tod\n\treturn 1\nend\n\nproc xlatkeyboard=\n!expand any mm_key messages to special key messages\n!uses and modified currmess\n\tm:=currmess.message\n\n\tif m=mm_key then\n\n\t\tk:=currmess.a\n\t\tif k>=vkf1 and k<=vkf12 then\n\t\t\tnewmsg:=currmess\n\t\t\tcurrmess.message:=mm_functionkey\n\t\t\tcurrmess.a:=k-vkf1+1\n\t\telse\n\t\t\tkeymess:=vktomesstable{k,0}\n\t\t\tif keymess then\n\t\t\t\tcurrmess.message:=keymess\n\t\t\tfi\n\t\tfi\n\tfi\nend\n\nfunc getscreencoords(w,pos)=\n\tpt::=pos\n\tif not w then\n\t\tPCERROR(\"GSC/W=0\")\n\tfi\n\n\tclienttoscreen(w.gdi.hwnd,&pt)\t\t!pos starts at 0,0\n\treturn pt\nend\n\nexport func getwindow(hwnd)=\n!convert hwnd to window\n!return nil if any problem\n\tif hwnd=0 then\n\t\treturn nil\n\tfi\n\n\tindex:=wx_getw(hwnd)\n\tif index then\n\t\treturn allwindows[index]\n\tfi\n\treturn nil\nend\n\nproc initmenuhandlers=\n\tltcolour:=getrgb(ltgrey)\n\tdkcolour:=getrgb(dkgrey)\nend\n\nproc gxhandler_fixups=\n!do some manual fixups for various shared handlers\n!(the automatic fixup routine allows multiple window classes per message, but not\n! multiple message per window class)\n\tmesshandlertable[mm_startdrag,scrollbar_class]:=mess_drag_scrollbar\n\tmesshandlertable[mm_enddrag,scrollbar_class]:=mess_drag_scrollbar\n\tmesshandlertable[mm_leftkey,scrollbar_class]:=mess_upkey_scrollbar\nend\n\nfunc mess_all_all(mess,w)=\n!CPL \"MESSAA1\"\n\tcase mess.message\n\twhen mm_startdrag,mm_drag,mm_enddrag then\n\twhen mm_command then\n\twhen mm_ok,mm_cancel then\n\twhen mm_click then\n\t\tcase w.windclass\n\t\twhen label_class, group_class then\n\t\t\treturn skipmess\n\t\tesac\n\twhen mm_key then\n\twhen mm_sethozpos,mm_setvertpos then\n\twhen mm_pick,mm_lbchange then\n\twhen mm_leftkey,mm_rightkey,mm_upkey,mm_downkey,mm_enterkey,mm_tabkey then\n\twhen mm_pageupkey,mm_pagedownkey then\n\twhen mm_homekey, mm_endkey then\n\twhen mm_functionkey then\n\twhen mm_wheel then\n\twhen mm_edited then\n\telse\n!CPL \"MESSAA2\"\n\t\treturn skipmess\n\tesac\n!CPL \"MESSAA3\"\n\n\treturn thismess\nend\n\nfunc mess_restore_all(mess,w)=\n\tgxrestore(W)\n\n\treturn skipmess\nend\n\nfunc mess_killfocus_all(mess,w)=\n!note: can be called from mess_setfocus_all, with a different mess, but correct w\n!assume w is same as wfocus\n\n\tdrawcaret(0)\n\twfocus:=nil\n\n\treturn skipmess\nend\n\nfunc mess_setfocus_all(mess,w)=\n\tif wfocus then\n\t\tmess_killfocus_all(mess,wfocus)\n\tfi\n\n\twfocus:=w\n\tdrawcaret(1)\n\treturn skipmess\nend\n\nfunc mess_update_all(mess,w)=\n\tgxupdate(w)\n\treturn skipmess\nend\n\nfunc mess_draw_all(mess,w)=\n\tgxdraw(w)\n\treturn skipmess\nend\n\nfunc mess_click_select(mess,w)=\n\tif w.enable then\n\t\tif not w.style.noupdate then\n\t\t\tp:=w.linkvar\n\t\t\tp^:=w.attrs.onvalue\n\t\t\tfor wc in w.owner.childlist do\n\t\t\t\tif wc.windclass=select_class and wc.linkvar=p then\n\t\t\t\t\tgxdraw(wc)\n\t\t\t\tfi\n\t\t\tod\n\t\tfi\n\t\tif w.style.returnmess then\n\t\t\tpostmess(w,mm_command,w.id)\n\t\tfi\n\tfi\n\treturn skipmess\nend\n\nfunc mess_click_toggle(mess,w)=\n\tif w.enable then\n\t\tif not w.style.noupdate then\n\t\t\tw.linkvar^:=not w.linkvar^\n\t\t\tgxdraw(w)\n\t\tfi\n\t\tif w.style.returnmess then\n\t\t\tpostmess(w,mm_command,w.id)\n\t\tfi\n\tfi\n\treturn skipmess\nend\n\nfunc mess_click_button(mess,w)=\n\n\tif w.enable=0 then\n\t\tbeep1()\n\t\treturn skipmess\n\tfi\n\n\tif w.id in 0..199 then\t\t\t\t!speficies an actual message number (but no params)\n\t\tpostmess(w,w.id)\n\telse\n\t\tpostmess(w,mm_command,w.id)\n\tfi\n\treturn skipmess\nend\n\nfunc mess_click_editbox(mess,w)=\n\tif w.enable then\n\t\tif not w.style.noupdate then\n\t\t\tunless w==wfocus then\n\t\t\t\tgxfocus(w)\n\t\t\tend\n\t\tfi\n\t\tif w.style.returnmess then\n\t\t\tpostmess(w,mm_command,w.id)\n\t\tfi\n\tfi\n\n\treturn skipmess\nend\n\nfunc mess_click_arrow(mess,w)=\n\n\tcase w.owner.windclass\n\twhen scrollbar_class then\n\t\tpostmess(w.owner,dirtomess{w.style.dir},w.id,0,-1)\n\telse\n\t\tmess.message:=dirtomess{w.style.dir}\n\t\tmess.a:=w.id\n\t\treturn thismess\n\tesac\n\treturn skipmess\nend\n\nfunc mess_click_mark(mess,w)=\n\n\tcase w.owner.windclass\n\twhen toggle_class,select_class then\n\t\tpostmess(w.owner,mess.message,w.id,0,-1)\n\tesac\n\treturn skipmess\nend\n\nfunc mess_click_listbox(mess,w)=\n\tgxfocus(w)\n\n\ty:=max(w.attrs.offset,mess.y)\n\n\tpos:=(y-w.attrs.offset)%w.attrs.pitch+w.attrs.pagepos\n\tif pos<=getlvbounds(w.linkvar).len then\n\t\tgxsetlbpos(w,pos)\n\t\tpostmess(w,mm_pick,pos)\n\tfi\n\n\treturn skipmess\nend\n\nfunc mess_click_scrollbar(mess,w)=\n\tonthumb:=isonthumb(w,(w.style.dir='H'|mess.x|mess.y))\n\tstep:=w.attrs.span\n\ta:=w.attrs.currpos\n\n\tcase w.owner.windclass\n\twhen listbox_class then\n\t\tcase onthumb\n\t\twhen -1 then\n\t\t\tif a>w.attrs.limits.lwb then\n\t\t\t\ta:=max(a-step,w.attrs.limits.lwb)\n\t\t\t\tgxsetlbpage(w.owner,a)\n\t\t\tfi\n\t\twhen 1 then\n\t\t\tif a<w.attrs.limits.upb then\n\t\t\t\ta:=min(a+step,w.attrs.limits.upb)\n\t\t\t\tgxsetlbpage(w.owner,a)\n\t\t\tfi\n\t\tesac\n\telse\n\t\tif not step then step:=10 fi\n\n\t\tcase onthumb\n\t\twhen -1 then\n\t\t\tif a>w.attrs.limits.lwb then\n\t\t\t\ta:=max(a-step,w.attrs.limits.lwb)\n\t\t\t\tgxscrollpos(w,a,1)\n\t\t\t\tpostmess(w,mm_sethozpos,a)\n\t\t\tfi\n\t\twhen 1 then\n\t\t\tif a<w.attrs.limits.upb then\n\t\t\t\ta:=min(a+step,w.attrs.limits.upb)\n\t\t\t\tgxscrollpos(w,a,1)\n\t\t\t\tpostmess(w,mm_sethozpos,a)\n\t\t\tfi\n\t\tesac\n\tesac\n\treturn skipmess\nend\n\nfunc mess_wheel_scrollbar(mess,w)=\n\tdelta:=currmess.a\n\tn:=abs(currmess.a%120)\n\tto n do\n\t\tcase w.windclass\n\t\twhen scrollbar_class then\n\tdoscroll:\n\t\t\tpostmess(w,(delta>0|mm_up|mm_down))\n\t\twhen listbox_class then\n\t\t\tif w.childlist then\n\t\t\t\tw:=w.childlist[1]\n\t\t\t\tgoto doscroll\n\t\t\tfi\n\t\t\tpostmess(w,(delta>0|mm_upkey|mm_downkey))\n\t\tesac\n\tod\n\treturn skipmess\nend\n\nfunc mess_up_scrollbar(mess,w)=\n\ta:=w.attrs.currpos\n\tif a<=w.attrs.limits.lwb then\n\t\treturn skipmess\n\tfi\n\tcase w.owner.windclass\n\twhen listbox_class then\n\t\tgxsetlbpage(w.owner,a-1)\n\t\treturn skipmess\n\telse\n\t\t--a\n\t\tgxscrollpos(w,a,1)\n\t\tpostmess(w,mm_setvertpos,a)\n\tesac\n\treturn skipmess\nend\n\nfunc mess_left_scrollbar(mess,w)=\n\n\tcase w.owner.windclass\n\twhen listbox_class then\n\t\treturn skipmess\n\telse\n\t\ta:=w.attrs.currpos\n\t\tif a>w.attrs.limits.lwb then\n\t\t\t--a\n\t\t\tgxscrollpos(w,a,1)\n\t\t\tpostmess(w,mm_sethozpos,a)\n\t\tfi\n\tesac\n\treturn skipmess\nend\n\nfunc mess_right_scrollbar(mess,w)=\n\n\tcase w.owner.windclass\n\twhen listbox_class then\n\t\treturn skipmess\n\telse\n\t\ta:=w.attrs.currpos\n\t\tif a<w.attrs.limits.upb then\n\t\t\t++a\n\t\t\tgxscrollpos(w,a,1)\n\t\t\tpostmess(w,mm_sethozpos,a)\n\t\tfi\n\n\tesac\n\treturn skipmess\nend\n\nfunc mess_down_scrollbar(mess,w)=\n\n\ta:=w.attrs.currpos\n\tif a>=w.attrs.limits.upb then\n\t\treturn thismess\n\tfi\n\tcase w.owner.windclass\n\twhen listbox_class then\n\t\tgxsetlbpage(w.owner,a+1)\n\t\treturn skipmess\n\telse\n\t\t++a\n\t\tgxscrollpos(w,a,1)\n\t\tpostmess(w,mm_setvertpos,a)\n\n\tesac\n\treturn skipmess\nend\n\nfunc mess_drag_scrollbar(mess,w)=\n\tcase mess.message\n\twhen mm_startdrag then\n\t\tif isonthumb(w,(w.style.dir='H'|mess.x|mess.y))=0 then\n\t\t\tthumbdragmode:=1\t\t\t!then treat as mm_drag\n\t\t\tthumbstartpos:=w.attrs.thumbpos-arrowdim\t\t!use thumb pos at start of drag\n\t\telse\t\t\t\t\t\t\t!dragging other part of scrollbar\n\t\t\treturn skipmess\n\t\tfi\n\twhen mm_enddrag then\n\t\tthumbdragmode:=0\n\t\treturn skipmess\n\telsif not thumbdragmode then\n\t\treturn skipmess\n\tesac\n\n\toffset:=(w.style.dir='H'|mess.a|mess.b)\t\t!pixel offset from initial drag start pos\n\tnewpos:=thumbstartpos+offset\t\t\t\t\t\t!could outside thumb span range\n\n\tpos:=int(round((newpos/w.attrs.thumbspan)*(w.attrs.limits.len-1)+w.attrs.limits.lwb))\n\tpos:=clamp(pos,w.attrs.limits.lwb,w.attrs.limits.upb)\n\n\tcase w.owner.windclass\n\twhen listbox_class then\n\t\tgxsetlbpage(w.owner,pos)\n\telse\n\t\tgxscrollpos(w,pos,1)\n\t\tpostmess(w,(w.style.dir='H'|mm_sethozpos|mm_setvertpos),pos)\n\tesac\n\treturn skipmess\nend\n\nfunc mess_move_button(mess,w)=\n\treturn skipmess\nend\n\nfunc mess_move_all(mess,w)=\n\treturn skipmess\nend\n\nfunc mess_char_editbox(mess,w)=\n!\tSHOWMESSAGE(\"CHAREDIT\",MESS)\n\n\t\tif mess.a not in 32..255 then\n!\tcpl \"CHAR/EDIT2\",MESS.A,VKENTER\n\t\t\tcase mess.a\n\t\t\twhen vkenter then\n\t\t\t\tCPL \"ENTER\"\n\t\t\t\tm:=mm_edited\n\t\t\telse\n\t\t\t\tm:=mm_key\n\t\t\tesac\n\n\t\t\tif wapplic then\n!\tCPL \"CHAR/EDIT CONTROL\",=MESS.A,MESS.B\n\t\t\t\tpostmess(wapplic,m, mess.a,mess.b,mess.state)\n\t\t\tfi\n\t\t\treturn skipmess\n\t\tfi\n\t\tif not w.enable or w.style.noupdate then return skipmess fi\n\t\ts:=w.linkvar^\n\t\tn:=w.attrs.currpos\n\t\tc:=chr(mess.a)\n\n\t\tif n>s.len then\t\t\t\t!at end\n\t\t\ts+:=c\n\t\telsif n=1 then\t\t\t\t!at start\n\t\t\ts:=c+s\n\t\telse\t\t\t\t\t\t!in middle\n\t\t\ts:=leftstr(s,n-1)+c+rightstr(s,-(n-1))\n\t\tfi\n\n\t\tw.linkvar^:=s\n\t\t++w.attrs.currpos\n\t\tgxdraw(w)\n\n\t\treturn skipmess\nend\n\nfunc mess_key_editbox(mess,w)=\n!\tCPL \"KEY/EDITBOX\"\n\n\tpostmess(wapplic,mm_key,mess.a,mess.b,mess.state)\n\n\treturn skipmess\nend\n\nfunc mess_leftkey_editbox(mess,w)=\n\tif ctrlpressed() then\n\t\tpostmess(wapplic,mm_leftkey,mess.a,mess.b,mess.state)\n\t\treturn skipmess\n\tfi\n\n\tif w.attrs.currpos>1 then\n\t\tdrawcaret(0)\n\t\t--w.attrs.currpos\n\t\tdrawcaret(1)\n\tfi\n\treturn skipmess\nend\n\nfunc mess_rightkey_editbox(mess,w)=\n\tif ctrlpressed() then\n\t\tpostmess(wapplic,mm_rightkey,mess.a,mess.b,mess.state)\n\t\treturn skipmess\n\tfi\n\n\tif w.attrs.currpos<=w.linkvar^.len then\n\t\tdrawcaret(0)\n\t\t++w.attrs.currpos\n\t\tdrawcaret(1)\n\tfi\n\treturn skipmess\nend\n\nfunc mess_bskey_editbox(mess,w)=\n\ts:=w.linkvar^\n\tif not s then return skipmess fi\n\tn:=w.attrs.currpos\n\tif n=1 then return skipmess fi\n\n\tif n>s.len then\t\t\t\t!at end\n\t\ts:=leftstr(s,-1)\n\telse\t\t\t\t\t\t!in middle\n\t\ts:=leftstr(s,n-2)+rightstr(s,-(n-1))\n\tfi\n\n\tw.linkvar^:=s\n\t--w.attrs.currpos\n\tgxdraw(w)\n\n\treturn skipmess\nend\n\nfunc mess_deletekey_editbox(mess,w)=\n\ts:=w.linkvar^\n\tif not s then return skipmess fi\n\tn:=w.attrs.currpos\n\tif n>s.len then return skipmess fi\n\n\tif n=1 then\t\t\t\t!at start\n\t\ts:=rightstr(s,-1)\n\telse\t\t\t\t\t\t!in middle\n\t\ts:=leftstr(s,n-1)+rightstr(s,-n)\n\tfi\n\tw.linkvar^:=s\n\tgxdraw(w)\n\n\treturn skipmess\nend\n\nfunc mess_homekey_editbox(mess,w)=\n\tif ctrlpressed() then\n\t\tpostmess(wapplic,mm_homekey,mess.a,mess.b,mess.state)\n\t\treturn skipmess\n\tfi\n\n\tdrawcaret(0)\n\tw.attrs.currpos:=1\n\tdrawcaret(1)\n\n\treturn skipmess\nend\n\nfunc mess_homekey_listbox(mess,w)=\n\tif w.attrs.currpos>1 then\n\t\tgxsetlbpos(w,1)\n\tfi\n\n\treturn skipmess\nend\n\nfunc mess_endkey_editbox(mess,w)=\n\tif ctrlpressed() then\n\t\tpostmess(wapplic,mm_endkey,mess.a,mess.b,mess.state)\n\t\treturn skipmess\n\tfi\n\n\tdrawcaret(0)\n\tw.attrs.currpos:=w.linkvar^.len+1\n\tdrawcaret(1)\n\n\treturn skipmess\nend\n\nfunc mess_endkey_listbox(mess,w)=\n!if w.attrs.currpos<w.linkvar^.len then\n\tif w.attrs.currpos<getlvbounds(w.linkvar).len then\n!\tgxsetlbpos(w,w.linkvar^.len)\n\t\tgxsetlbpos(w,getlvbounds(w.linkvar).len)\n\tfi\n\n\treturn skipmess\nend\n\nfunc mess_upkey_listbox(mess,w)=\n\tif w.attrs.currpos>1 then\n\t\tgxsetlbpos(w,w.attrs.currpos-1)\n\tfi\n\n\treturn skipmess\nend\n\nfunc mess_upkey_scrollbar(mess,w)=\n!assume that this is independent scrollbar\n!(linked scrollbar wouldn't get the focus)\n\n\ta:=w.attrs.currpos\n\tif a>w.attrs.limits.lwb then\n\t\t--a\n\t\tgxscrollpos(w,a,1)\n\t\tpostmess(w,mm_setvertpos,a)\n\tfi\n\treturn skipmess\nend\n\nfunc mess_downkey_listbox(mess,w)=\n!if w.attrs.currpos<w.linkvar^.len then\n\tif w.attrs.currpos<getlvbounds(w.linkvar).len then\n\t\tgxsetlbpos(w,w.attrs.currpos+1)\n\tfi\n\n\treturn skipmess\nend\n\nfunc mess_pageupkey_listbox(mess,w)=\n\tif (a:=w.attrs.currpos)>1 then\n\t\ta:=max(a-w.attrs.rows,1)\n\t\tgxsetlbpos(w,a)\n\tfi\n\n\treturn skipmess\nend\n\nfunc mess_pagedownkey_listbox(mess,w)=\n\tif (a:=w.attrs.currpos)<getlvbounds(w.linkvar).len then\n\t\ta:=min(a+w.attrs.rows,getlvbounds(w.linkvar).len)\n\t\tgxsetlbpos(w,a)\n\tfi\n\n\treturn skipmess\nend\n\nfunc mess_enterkey_listbox(mess,w)=\n\tif w.attrs.currpos then\n\t\tpostmess(w,mm_pick,w.attrs.currpos)\n\tfi\n\n\treturn skipmess\nend\n\nproc do_draw_all(w)=\n\tgxclear(w)\n\tdrawborder(w)\n\tdrawchildborders(w)\nend\n\nproc do_draw_button(w)=\n\tgxclear(w)\n\n\tgxtext_just(w,w.text,0,w.enable)\n\n\tdrawborder(w)\n\nend\n\nproc do_draw_label(w)=\n\tdo_draw_button(w)\nend\n\nproc do_draw_toggle(w)=\n\tgxclear(w)\n\n\tVALSTR:=\"\"\n\n\tturnedon:=istrue w.linkvar^\n\n\tif w.style.marktype then\n\t\tdrawmark(w.childlist[1],turnedon,w.enable)\n\n\t\tgxtext_just(w,w.text+valstr,markdim,w.enable)\n\telse\n!\tcase w.style.hilitetype\n!\twhen invert_hilite then\n\t\t\tif turnedon then\n\t\t\t\tgxclear(w,getrgb(green))\n\t\t\tfi\n!\tesac\n\n\t\tgxtext_just(w,w.text+valstr)\n\tfi\nend\n\nproc do_draw_select(w)=\n\tgxclear(w)\n\n\tturnedon:=w.linkvar^=w.attrs.onvalue\n\n\tif w.style.marktype then\n\t\tdrawmark(w.childlist[1],turnedon,w.enable)\n\t\tgxtext_just(w,w.text,markdim,w.enable)\n\telse\n\t\tcase w.style.hilitetype\n\t\twhen invert_hilite then\n\t\t\tif turnedon then\n\t\t\t\tgxclear(w,getrgb(white))\n\t\t\tfi\n\t\tesac\n\t\t\tgxtext_just(w,w.text)\n\tfi\nend\n\nproc do_draw_editbox(w)=\n\tgxclear(w)\n\n\tgxtext_just(w,w.linkvar^,enable:w.enable)\n\n!Now, have to draw the cursor\n\tunless wfocus==w then\t\t\t!only draw it when this window has the focus\n\t\treturn\n\tend\n\n\tcaretdrawn:=0\n\n\tdrawcaret(1)\nend\n\nproc do_draw_arrow(w)=\n\tgxclear(w)\n\n\tdrawborder(w)\n\tdrawarrow(w,w.enable)\nend\n\nproc do_draw_mark(w)=\n\n\tcase w.owner.windclass\n\twhen toggle_class, select_class then\n\t\treturn\t\t\t\t\t!mark drawn by owner\n\tesac\n\n\tgxclear(w,getrgb(w.owner.style.windbgnd))\n\n\tdrawborder(w)\nend\n\nproc do_draw_scrollbar(w)=\n\tgxclear(w)\n\tdrawborder(w)\n\tgxdraw(w.childlist[1])\t\t\t!arrows\n\tgxdraw(w.childlist[2])\n\n!now draw the thumb\n\tif w.attrs.thumbsize then\n\t\tif w.style.dir='H' then\n\t\t\tx:=w.attrs.thumbpos\n\t\t\tdx:=w.attrs.thumbsize\n\t\t\tdrawthumb(w,x,0,dx,w.dimy)\n\t\telse\n\t\t\ty:=w.attrs.thumbpos\n\t\t\tdy:=w.attrs.thumbsize\n\t\t\tdrawthumb(w,0,y,w.dimx,dy)\n\t\tfi\n\tfi\nend\n\nproc do_draw_listbox(w)=\n\tgxclear(w)\n\tdrawborder(w)\n\tif w.childlist then\t\t\t!scrollbar\n\t\tgxdraw(w.childlist[1])\n\tfi\n\n\tfor i:=1 to w.attrs.rows do\n\t\tk:=i+w.attrs.pagepos-1\n\t\tif k<=getlvbounds(w.linkvar).len then\n\t\t\tdrawlbtext(w,i,getlvstritem(w.linkvar,k),0,k=w.attrs.currpos)\n\t\tfi\n\tod\nend\n\nproc do_update_all(w)=\n\tgxdraw(w)\nend\n\nproc do_update_listbox(w)=\n\tgxdraw(w)\nend\n\nproc drawcaret(x)=\n!x=1: draw caret in wfocus window at current position\n!x=0: delete caret in wsfocus window\n!returns x-pixel position of caret\n\n\tif wfocus=nil then\t\t!no window has focus\n\t\tcaretdrawn:=0\n\t\treturn\n\tfi\n\n\tcase wfocus.windclass\n\twhen editbox_class then\n\t\tif x then\t\t\t!new caret\n\t\t\tif caretdrawn then return fi\t!already drawn\n\t\t\txpos:=getcaretpos(wfocus.linkvar^,wfocus.attrs.currpos,0)\n\t\t\twfocus.attrs.caretpos:=xpos\t\t\t!record position\n\t\telse\t\t\t!delete caret\n\t\t\tif not caretdrawn then return fi\t!already deleted\n\t\t\txpos:=wfocus.attrs.caretpos\t\t!use stored value\n\t\tfi\n\n\t\tcaretwidth:=2\n\n\t\tgxhighlight(wfocus,xpos+wfocus.attrs.textpos[1],wfocus.attrs.textpos[2]-chd,caretwidth,20)\n\n\t\tcaretdrawn:=x\n\tesac\nend\n\nfunc getcaretpos(s,pos,offset)=\n!return pixel position of in front of pos'th character in string s\n!offset is no. of chars not shown, to left of string\n\tif pos=1 then return 0 fi\n\n\treturn wx_gettextwidth(wfocus.gdi.hdc, leftstr(s,pos-1))\nend\n\nproc drawborder(w)=\n!do own-drawn borders\n!other kinds of borders are windows-drawn, no-border, and the main bs- style\n!borders which exist in the owner's client area\n!for own-drawn borders, the window should have been cleared first\n\n\tcase bscat[w.style.border]\n\twhen 0 then\t\t\t\t\t!no border\n\t\treturn\n\twhen 'W' then\t\t\t\t!windows-drawn\n\t\treturn\n\twhen 'X' then\t\t\t\t!external (drawn in owner's client space\n\t\tposx:=w.frameposx\n\t\tposy:=w.frameposy\n\t\tdimx:=w.framedimx\n\t\tdimy:=w.framedimy\n\t\tbs:=w.style.border\n\n\t\tbs:=w.style.border\n\t\two:=w.owner\n\t\tcase bs\n\t\twhen bs_simple then\t\t\t!USUALLY BS_SIMPLE converts to BS_WINDOWS; must be override\n\t\t\tgxcolour(wo,0)\n\t\t\tgxrect(wo,posx,posy,dimx,dimy)\n\t\twhen bs_thick then\n\t\twhen bs_panel then\n\t\t\tgxcolour(wo,ltcolour)\n\t\t\tgxline(wo,posx+dimx-1,posy, posx,posy)\n\t\t\tgxline(wo,posx,posy+dimy-1)\n\t\t\tgxcolour(wo,dkcolour)\n\t\t\tgxline(wo,posx+dimx-1,posy+dimy-1)\n\t\t\tgxline(wo,posx+dimx-1,posy)\n\t\twhen bs_inset then\n\t\t\tgxcolour(wo,dkcolour)\n\t\t\tgxline(wo,posx+dimx-1,posy, posx,posy)\n\t\t\tgxline(wo,posx,posy+dimy-1)\n\t\t\tgxcolour(wo,ltcolour)\n\t\t\tgxline(wo,posx+dimx-1,posy+dimy-1)\n\t\t\tgxline(wo,posx+dimx-1,posy)\n\t\twhen bs_testext then\n\t\t\tgxcolour(wo,0)\n\t\t\tgxrect(wo,posx,posy,dimx,dimy)\n\t\t\tgxrect(wo,posx+9,posy+9,dimx-18,dimy-18)\n\t\tesac\n\twhen 'I' then\t\t\t\t!internal (drawn within window's client space\n\t\tposx:=w.frameposx\n\t\tposy:=w.frameposy\n\t\tdimx:=w.dimx\n\t\tdimy:=w.dimy\n\n\t\tcase w.style.border\n\t\twhen bs_ownpanel then\n\t\t\tgxcolour(w,ltcolour)\n\t\t\tgxline(w,w.framedimx-1,0,0,0)\n\t\t\tgxline(w,0,w.framedimy-1)\n\t\t\tgxcolour(w,dkcolour)\n\t\t\tgxline(w,w.framedimx-1,w.framedimy-1)\n\t\t\tgxline(w,w.framedimx-1,0)\n\n\t\twhen bs_owninset then\n\t\t\tgxcolour(w,dkcolour)\n\t\t\tgxline(w,w.framedimx-1,0,0,0)\n\t\t\tgxline(w,0,w.framedimy-1)\n\t\t\tgxcolour(w,ltcolour)\n\t\t\tgxline(w,w.framedimx-1,w.framedimy-1)\n\t\t\tgxline(w,w.framedimx-1,0)\n\t\twhen bs_ownsimple then\n\t\t\tgxcolour(w,0)\n\t\t\tgxrect(w,0,0,w.framedimx,w.framedimy)\n\t\twhen bs_testint then\n\t\t\tgxcolour(w,0)\n\t\t\tgxrect(w,0,0,dimx,dimy)\n\t\t\tgxrect(w,7,7,dimx-14,dimy-14)\n\t\tesac\n\tesac\nend\n\nproc drawchildborders(w)=\n\tif not w.childlist then\n\t\treturn\n\tfi\n\tfor wc in w.childlist do\n\t\tif wc.style.border in [bs_simple,bs_thick,bs_panel,bs_inset] then\n\t\t\tdrawborder(wc)\n\t\tfi\n\tod\nend\n\nproc drawarrow(w,enable)=\n!w has already been cleared\n!e=1/omitted to enable, 0 to disable (shown grey)\n\tconst factor=0.3\n\n\tgxsetpen(w,(enable|black|dkgrey))\n\n\twidth:=w.dimx\n\theight:=w.dimy\n\n\tcase w.style.dir\n\twhen 'D' then\n\t\tx:=int(round(width/2)-1)\n\n\t\twd:=0\n\n\t\th:=int(round(min(height,width)*factor))\n\t\tif h<3 then h:=3 fi\n\t\ty:=int((height+h)*0.5)-1\n\n\t\tto h do\n\t\t\tgxline(w,x,y,x+wd,y)\n\t\t\tx-:=1\n\t\t\ty-:=1\n\t\t\twd+:=2\n\t\tod\n\n\twhen 'U' then\n\t\tx:=int(round(width/2)-1)\n\t\twd:=0\n\n\t\th:=int(round(min(height,width)*factor))\n\t\tif h<3 then h:=3 fi\n\t\ty:=int(round((height-h)*0.5))\n\t\tto h do\n\t\t\tgxline(w,x,y,x+wd,y)\n\t\t\tx-:=1\n\t\t\ty+:=1\n\t\t\twd+:=2\n\t\tod\n\n\twhen 'L' then\n\t\ty:=height%2\n\n\t\tht:=0\n\t\twd:=y\n\n\t\twd:=int(round(min(height,width)*factor))\n\t\tif wd<3 then wd:=3 fi\n\t\tx:=int(round((width-wd)*0.5)-1)\n\n\t\tto wd do\n\t\t\tgxline(w,x,y,x,y+ht)\n\t\t\ty-:=1\n\t\t\tx+:=1\n\t\t\tht+:=2\n\t\tod\n\n\twhen 'R' then\n\t\ty:=height%2\n\t\tht:=0\n\n\t\twd:=int(round(min(height,width)*factor))\n\t\tif wd<3 then wd:=3 fi\n\t\tx:=int(round((width+wd)*0.5)-1)\n\n\t\tto wd do\n\t\t\tgxline(w,x,y,x,y+ht)\n\t\t\ty-:=1\n\t\t\tx-:=1\n\t\t\tht+:=2\n\t\tod\n\tesac\nend\n\nexport proc gxtext_just(w,s,offset=0,enable=1)=\n\t\tdimx:=w.dimx\n\t\tdimy:=w.dimy\n\t\twidth:=wx_gettextwidth(w.gdi.hdc, s)\n\t\theight:=chy\t\t\t\t!assume basic font\n\n\t\tcase w.style.justify\n\t\twhen 'L' then\tx:=smx\n\t\twhen 'R' then\tx:=dimx-width-smx\n\t\telse\n\t\t\t\t\tx:=(dimx-width)%2\n\t\tesac\n\n\t\tcase w.style.vjustify\n\t\twhen 'T' then\ty:=smy\n\t\twhen 'B' then\ty:=dimy-height-smy\n\t\telse\n\t\t\t\t\ty:=(dimy-height)%2!\t\t-smy%2\n\t\tesac\n\n\t\tif not enable then\n\t\t\toldtextfgnd:=w.style.textfgnd\n\t\t\tgxtextcolour(w,grey)\n\t\tfi\n\n\t\tgxtext(w,s,x+offset,y)\n\n\t\tif not enable then\n\t\t\tgxtextcolour(w,oldtextfgnd)\n\t\tfi\n\t\tif w.windclass=editbox_class then\n\t\t\tw.attrs.textpos:=(x+offset,y)\n\t\tfi\nend\n\nproc drawthumb(w,x,y,dx,dy)=\n!w is a scrollbar, vert or hoz\n!draw thumb within w, as a simple rectangle starting at x,y at top left of size dx,dy\n\n\tgxcolour(w,0)\n\tgxrect(w,x,y,dx,dy)\n\tgxfillrect(w,x+1,y+1,dx-2,dy-2,getrgb(grey))\nend\n\nfunc isonthumb(w,d)=\n!w is a scrollbar, d is a pixel position along it (0 being at left or top)\n!return:\n! -1\tis before the thumb\n!  0\tis on the thumb\n! +1\tif after the thumb\n!d can specify a spot off the thumbar if being dragged\n\n\ta:=w.attrs.thumbpos\n\tb:=w.attrs.thumbsize\n\n\tif d<a then\n\t\treturn -1\n\telsif d>(a+b) then\n\t\treturn 1\n\telse\n\t\treturn 0\n\tfi\nend\n\nproc drawmark(w,turnedon,enable)=\n!!w has already been cleared\n!draw checked check mark, tick, or radio button, according to whether\n!turnedon is 1 or 0\n!e=1 to enable, 0 to disable (shown grey)\n\n\tgxclear(w,getrgb(w.owner.style.windbgnd))\n\tgxsetpen(w,(enable|black|red))\n\n\twidth:=w.dimx\n\theight:=w.dimy\n\tx:=y:=1\n\twd:=width-2\n\tht:=height-2\n\tgxrect(w,x,y,wd,ht)\n\tif not turnedon then return fi\n\n\tcase w.style.marktype\n\twhen radio_mark then\n\n\t\tgxfillrect(w,x+3,y+3,wd-6,ht-6,getrgb(red))\n\n\twhen check_mark then\n\n\t\tgxline(w,x,y,x+wd-1,y+ht-1)\n\t\tgxline(w,x+wd-1,y,x,y+ht-1)\n\n\twhen tick_mark then\n\n\t\tgxline(w,x+3,y+ht%2,x+wd%2,y+ht-4)\n\t\tgxline(w,x+wd-3,y+2)\n\n\tesac\nend\n\nproc drawlbtext(w,row,text,clr=0,hilite=0)=\n!draw text inside given row of listbox w\n!clr=1 to clear the background first (not needed when entired lb has been cleared)\n!hilite=1 to highlight this row\n\n\tx:=0\n\ty:=(row-1)*w.attrs.pitch+w.attrs.offset\n\n\tif clr or hilite then\n\t\tgxfillrect(w,x,y,w.dimx,w.attrs.pitch,(hilite|getrgb(grey)|getrgb(w.style.windbgnd)))\n\tfi\n\n\tif hilite then\n\t\toldtextcolour:=gxtextcolour(w)\n\t\tgxtextcolour(w,white)\n\tfi\n!RETURN\n\n\tgxtext(w,text,x+smx,y+smy)\n\tif hilite then\n\t\tgxtextcolour(w,oldtextcolour)\n\tfi\nend\n\nfunc readnextitem(a)=\n!return (level,value,labelx,options)\n!special values used for divider, new column, new menu\n!next line of file should already have been read\n\n\tif a=\"\" then return list(0,0,0,0) fi\n\n\tlevel:=1\n\ttabs:=0\n\toptions:=\"\"\n\n\twhile asc(a) in [9,' '] do tabs+:=1; a:=rightstr(a,-1) od\n\n\tif a=\"\" then return list(0,0,0,0) fi\n\n\tcase asc(a)\n\twhen '!' then\n\t\treturn list(0,0,0,0)\n\tesac\n\n\tif tabs then\n\t\tj:=0\n\t\tfor i:=1 to ntab do\n\t\t\tif tabs=tabstack[i] then j:=i; exit fi\n\t\tod\n\n\t\tif j=0 then\n\t\t\tif tabs>tabstack[ntab] then\n\t\t\t\tntab+:=1\n\t\t\t\ttabstack[ntab]:=tabs\n\t\t\tfi\n\t\t\tlevel:=ntab\n\t\telse\n\t\t\tlevel:=j\n\t\t\tif j<ntab then ntab:=j fi\n\t\tfi\n\tfi\n\n\tif asc(a) in ['0'..'9'] then\n\t\tvalue:=strtoval(a)\n\t\tn:=\" \" inx a\n\t\tif not n.isfound then\n\t\t\tn:=chr(9) in a\n\t\tfi\n\t\tif n.isfound then\n\t\t\tlabelx:=rightstr(a,-n)\n\t\telse\n\t\t\tlabelx:=\"?\"\n\t\tfi\n\n\telse\t\t\t!no preceding number, maybe top-level menu\n\n\t\tif \"=\" in a then\t!command def for mpl\n\t\t\treturn (0,0,0,0)\n\t\tfi\n\n\t\tvalue:=k_menu\n\t\tlabelx:=a\n\t\tcase convlc(labelx)\n\t\twhen \"hozbreak\",\"divider\" then\n\t\t\tvalue:=kdivide\n\t\twhen \"vertbreak\" then\n\t\t\tvalue:=kcolumn\n\t\twhen \"filehistory\" then\n\t\t\tvalue:=kfilehistory\n\t\telse\n\t\t\tif leftstr(labelx)=\"-\" then value:=kdivide fi\n\t\tesac\n\tfi\n\n\tif labelx=\"\" then\t\t\t!maybe [cmd] only\n\t\treturn list(0,0,0,0)\n\tfi\n\n\treturn (level,value,(labelx),options)\nend\n\nfunc readmenu(m,n,level)=\n!starting at index n in data, read all following items that are\n!at lower level (ie. higher level number) than given level\n!insert items into menu handle m\n!return index of next item in data, which is at <level> or higher\n!will stop at end of data, and return ndata+1\n\n\trestartx:\n\tfor i:=n to ndata do\n\t\t(l,value,labelx,options):=data[i]\n\n\t\tif l<=level then\t\t!end of this submenu\n\t\t\treturn i\n\t\tfi\n\n\t\tflags:=breakflag\n\t\tenable:=1\n\t\tif rightstr(labelx)=\"?\" then\n\t\t\tenable:=0\n\t\t\tlabelx:=leftstr(labelx,-1)\n\t\tfi\n\n\t\tif options<>\"\" then\n\t\t\tif \"H\" in options then flags+:=\"h\" fi\n\t\t\tif \"C\" in options then flags+:=\"c\" fi\n\t\tfi\n\n\t\tcase value\n\t\twhen kdivide then\n\t\t\tgxaddmb(m,style:\"d\")\n\t\twhen kcolumn then\n\t\t\tbreakflag:=\"v\"\n\t\twhen k_menu then\t\t!submenu\n\t\t\tnewm:=gxcreatemb()\n\t\t\tn:=readmenu(newm,i+1,l)\n\t\t\tgxaddmb(m,labelx,newm,\"p\"+flags,enable)\n\t\t\tbreakflag:=\"\"\n\t\t\tgoto restartx\n\t\twhen kfilehistory then\n\t\t\tnfiles:=8\n\t\t\tgxaddmb(m,\"filehistory\",1060,breakflag)\n\t\telse\t\t\t\t!ordinary command\n\tnormalcmd:\n\t\t\tgxaddmb(m,labelx,value,flags,enable)\n\t\t\tbreakflag:=\"\"\n\t\tesac\n\n\tskip:\n\tod\n\n\treturn ndata+1\t\t\t!eod reached\nend\n\nfunc mbreaddata(a)=\n!a is a list of tab-indented strings for a menu bar\n!a can also be a text file containing the strings\n\n\ttabstack::=(0,)\n\tntab:=1\n\tdata::=()\n\tndata:=0\n\tbreakflag:=\"\"\n\n\tif a.isstring then\t\t!read from file\n\t\ta:=readtextfile(a)\n\t\tif a=0 then\n\t\t\ta:=(\"CANTOPENFILE\",)\n\t\tfi\n\tfi\n\n\tfor i:=1 to a.upb do\n\t\tx:=readnextitem(a[i])\n\n\t\tif x[1] then\n\t\t\t++ndata\n\t\t\tdata[ndata]:=x\n\t\tfi\n\tod\n\n\tm:=gxcreatemb()\n\treadmenu(m,1,0)\n\treturn m\nend\n\nexport func gxmenubar(w,?a)=\n!called as:\n!\tgxmenubar(a):\tcreate standalone menu; return handle\n!\tgxmenubar(w,a):\tadd menu to windows w (returns 0)\n!a:\n!\tstring:\t\t\tassume this is a filename containing menubar tabbed layout\n!\tlist:\t\t\ta list of strings containing the data\n\n\tif a.defined then\t\t!w,m: read menu into window w\n\t\tm:=mbreaddata(a)\n\n\t\tif not w.ispointer then\n\t\t\twhile w.owner<>nil do\n\t\t\t\tw:=w.owner\n\t\t\tod\n\t\tfi\n\n\t\tgxsetmb(w,m)\n\t\treturn 0\n\telse\t\t\t\t!create standalone menu, return handle\n\t\treturn mbreaddata(w)\n\tfi\nend\n\nfunc gxcreatemb(?s)=\n\tif s.defined and s in \"Pp\" then\n\t\treturn createpopupmenu()\n\telse\n\t\treturn createmenu()\n\tfi\nend\n\nproc gxsetmb(w,m)=\n\n\thwnd:=w.gdi.hwnd\n\ta:=getmenu(hwnd)\n\ts:=setmenu(hwnd,m)\n\tif a then destroymenu(a) fi\nend\n\nfunc gxaddmb(wm,caption=\"X\",id=0,style=\"\",enable=0)=\n\n\tif wm.ispointer then\t\t\t\t!assume handle\n\t\thmenu:=wm\n\t\twm:=nil\n\telse\n\t\thmenu:=getmenu(wm.gdi.hwnd)\n\tfi\n\n\tflags:=mf_string ior mf_unchecked\n\n\tif not enable then flags ior:=mf_greyed fi\n\n\tforeach c in convuc(style) do\n\t\tcase c\n\t\twhen 0 then exit\n\t\twhen 'P' then flags ior:=mf_popup\n\t\twhen 'D' then flags ior:=mf_separator\n\t\twhen 'B' then flags ior:=mf_menubreak\n\t\twhen 'V' then flags ior:=mf_menubarbreak\n\t\twhen 'H' then flags ior:=mf_help\n\t\twhen 'C' then flags ior:=mf_checked\n\t\tesac\n\tod\n\n\tif appendmenu(hmenu,flags,id,caption) then\n\t\tif wm<>nil then drawmenubar(wm.gdi.hwnd) fi\n\t\treturn hmenu\n\tfi\n\treturn 0\nend\n\nproc gxshowmb(wm,w,x,y)=\n!update menu associated with window; call this func if it has been updated\n!when wm is a menu handle, draw the popup on the screen at x,y\n!if wm.isint then\n\tif wm.ispointer then\n\n\t\tif not y.defined then\n\t\t\tx:=w\n\t\t\ty:=x\n\t\t\tw:=nil\n\t\t\thwnd:=wapplic.gdi.hwnd\n\t\telse\n\t\t\thwnd:=w.gdi.hwnd\n\t\tfi\n\n\t\tpos:=ws_point(x,y)\n\n\t\tif w<>nil then\n\t\t\tclienttoscreen(w.gdi.hwnd,&pos)\n\t\tfi\n\n\t\ttrackpopupmenu(wm,0,pos.x,pos.y,0,hwnd,0)\n\telse\n\t\tdrawmenubar(wm.gdi.hwnd)\n\tfi\nend\n\nfunc gxenablemb(wm,id,enable)=\n\n\tif wm.ispointer then\t\t\t\t!assume handle\n\t\thmenu:=wm\n\telse\n\t\thmenu:=getmenu(wm.gdi.hwnd)\n\tfi\n\n\tif enable.defined then\n\t\treturn enablemenuitem(hmenu,id,(enable|0|mf_greyed)+mf_bycommand)\n\telse\n\t\treturn (getmenustate(hmenu,id,mf_bycommand) iand mf_greyed|0|1)\n\tfi\nend\n\nfunc gxcheckmb(wm,id,check)=\n\tif wm.ispointer then\t\t\t\t!assume handle\n\t\thmenu:=wm\n\telse\n\t\thmenu:=getmenu(wm.gdi.hwnd)\n\tfi\n\n\tif check.defined then\n\t\treturn checkmenuitem(hmenu,id,(check|mf_checked|mf_unchecked)+mf_bycommand)\n\telse\n\t\treturn (getmenustate(hmenu,id,mf_bycommand) iand mf_checked|1|0)\n\tfi\nend\n\nproc gxclosemb(m)=\n\tdestroymenu(m)\nend\n\nexport func gxconfirm(m)=\n\tx:=gxmsgbox(m,\"Confirm\",\"byn\")\n\treturn x=\"yes\"\nend\n\nfunc issubwindow(w,w2)=\n\twhile w2 do\n\t\tif w2==w then return 1 fi\n\t\tw2:=w2.owner\n\tod\n\treturn 0\nend\n\nexport proc flushmessages=\n\nend\n\nPROC CHECKWIND(W, NAME)=\n\tIF W=NIL THEN RETURN FI\n\tIF W.NAME=NAME THEN\n\t\tCPL \"CHECKWIND MATCHES****************\"\n\tFI\nEND\n\nEXPORT PROC CHECKCLOSED(NAME)=\n!CPL \"CC:\",=NAME\n!CPL \"CC:\",=CURRMESS.WIND\n\n\tCHECKWIND(CURRMESS.WIND,NAME)\n\tCHECKWIND(WFOCUS,NAME)\n\n\tfor w in allwindows do\n\t\tcheckwind(w, name)\n!CPL =W\n!CPL =W.CHILDLIST.TYPE\n\t\tif w then\n\t\tfor wc in w.childlist do\n\t\t\tcheckwind(wc, name)\n\t\tod\n\t\tfi\n\tod\n\n\tfor i to nmessages do\n\t\tm:=messagequeue[i]\n\t\tcheckwind(m.wind,name)\n\tod\n\n\tCPL \"CC: OK*****\"\nEND\n",
(u64)"VAR DEBUG=0\n\nimportdll imglib =\n    func imgload_rgb\t\t(stringz, ref byte, ref byte, ref byte, i32)ref byte\n\n    func imgload_bgr\t\t(stringz, ref i32, ref i32, ref i32, i32)ref byte\n\n!    func nanoloadjpeg\t\t(stringz, ref i32, ref i32, ref i32)ref byte\n!    func loadjpegm\t\t\t(stringz, ref i64, ref i64, ref i64)ref byte\n\n    proc          imgload_free\t\t(ref byte)\n    func imgsave_jpeg_rgb\t(stringz, ref byte, i32, i32, i32)i32\n    func imgsave_jpeg_bgr\t(stringz, ref byte, i32, i32, i32)i32\nend\n\nimportdll jpeg =\n    func loadjpegm\t\t\t(stringz, ref i64, ref i64, ref i64)ref byte\nend\n\ntype bmpheader = struct\n\tws_bitmapfileheader fh\n\tws_bitmapinfoheader bh\nend\n\nvar\tshifts=[2:1, 4:2, 8:3, 16:4, 32:5, 64:6]\n\nproc main=\n\n!\tCPL \"TESTING BMMAIN NEW\"\n!\tFILE:=\"C:/JPEG/girl.jpg\"\n!\tFILE:=\"C:/JPEG/girl.png\"\n!\tFILE:=\"C:/JPEG/fifteen.png\"\n\tFILE:=\"C:/JPEG/CARD2.jpg\"\n!\tFILE:=\"C:/JPEG/MONA.jpg\"\n!\n\tBM:=BMLOAD(FILE)\n!\tCPL =BM.TYPE\n!\tCPL =BM\n!\tIF NOT BM THEN STOP FI\n!\n!\tBMSAVE(\"freddy.jpg\", BM)\n!\n\n!\tw:=640\n!\th:=480\n!\tw:=640\n!\th:=48\n!\n!\tbm:=bmcreate(8,w,h)\n!!\tgxclear(bm, 0xFF7FFF)\n!\n!\tgxtext(bm,\"Hello, World\")\n!\tfor y:=0 to h-1 do\n!\t\tfor x:=0 to w-1 do\n!\t\t\tc:=0x00'FF'00\n!!\t\t\tgxpixel(bm,x,y,c<<16+c<<8+c)\n!\t\t\tgxpixel(bm,x,y,c)\n!\t\tod\n!\tod\n!\t\n\n!\tbm2:=bmtopal(bm)\n!\tbm2:=bmrgb24torgb32(bm)\n!\tbm2:=bmtogrey(bm,8)\n!\tbm2:=bmtogrey(bm,24)\n!\tbm2:=bmdupl(bm)\n\n!BM2.PALTYPE:=COLOUR_PAL\n!BMRESETPALETTE(BM2)\n!CPL =BM2.PIXELBITS\n!\tBMSAVE(\"PALA.PPM\",BM2)\n!\tBMSAVE(\"FRED.bmp\",BM2)\n!\tBMSAVE(\"PALB.PPM\",BM2,1)\n\n\n!\tCPL \"LOADED\"\n!\tSTOP\n\n\tw:=GXCREATEWINDOW(DIM:(1800,700),caption:\"HI THERE\")\n\tgxcopy(w,bm)\n!\tgxcopy(w,bm,scalex:0.5)\n!\tgxcopy(w,bm,scalex:5.0, x:100)\n!\tgxcopy(w,bm,scalex:2.0, x:100)\n!\tgxcopy(w,bm)\n!T:=clock()\n!to 100 do\n!\tgxcopy(w,bm)\n!od\nglobal const srccopy =  13369376\n\n!CPL =SRCCOPY\n\tbitblt(w.gdi.hdc, 0, 0, 500,300,\n\t\t\t\tw.gdi.hdc,0,0,srccopy)\n\n\n!\tgxcopy(w,bm)\n!\tgxcopy(w,bm)\n!\tgxcopy(w,bm)\n!\tgxcopy(w,bm)\n!cpl =clock()-t\n!WAITKEY()\n\teventloop()\n\nend\n\nexport func bmcreate(pixelbits,width,height)=\n!create new bitmap with given specs, return handle to bitmap (=rwindow ref)\n!when maskptr<>nil, set up mask values\n\n\tbminfo:=new(ws_bitmapv5header)\n\tbminfo.size:=ws_bitmapv5header.bytes\n\tbminfo.width:=width\n\tbminfo.height:=-height\n\tbminfo.planes:=1\n\tbminfo.bitcount:=pixelbits\n\n\tpixelptr:=nil\n\n\tif pixelbits not in [8,24,32] then\n\t\tabort(\"bmcreate pixel size not supported:\"+tostr(pixelbits))\n\tfi\n\n!\thwnd:=createdibsection(screendc,&bminfo,0,&pixelptr,0,0)\n\n!CPL =BMINFO.BYTES\n!CPL =WS_BITMAPV5HEADER.BYTES\n!CPL =BMINFO.SIZE\n!CPL =BMINFO.WIDTH\n!CPL =BMINFO.HEIGHT\n!CPL =BMINFO.PLANES\n!CPL =BMINFO.BITCOUNT\n\n\thwnd:=createdibsection(nil,&bminfo,0,&pixelptr,nil,0)\n\n\tpixelptr:=makeref(pixelptr,byte)\n\n\tif hwnd=0 then\n\t\terror:=getlasterror()\n\t\tabort(\"bmcreate:CreateDIB failed:\"+tostr(error))\n\tfi\n\n!now create a bm record based around this handle\n\n\tbm:=new(rwindow,0)\n\tbm.windclass:=bitmap_class\n\n\tbm.dimx:=width\n\tbm.dimy:=abs(height)\t\t!neg height used for top-down bitmaps\n\n\tbm.style:=defstyle\n\n\tbm.pixelbits:=pixelbits\n\tbm.pixelptr:=pixelptr\n\n!set bytes per pixel\n\tbm.pixelbytes:=pixelbits%8\n\n!set bytes per scanline\n\tn:=bm.pixelbytes*width\n\n!n must be a multiple of 4 bytes\n\tif (n iand 3)<>0 then\t!make bytes a multiple of 4\n\t\tn:=(n+4) iand 0xfffc\n\tfi\n\tbm.linebytes:=n\n!CPL \"XXX\",=BM.TYPE\n!CPL =BM.BASETYPE\n\n\tbm.framebytes:=bm.linebytes*bm.dimy\n\n!set palette colours, using winrgb order\n\tif pixelbits=8 then\n\t\tpalette:=new(array,i32,0..255)\n\t\tbm.paltype:=greyscale_pal\n\t\tcolour:=0\n\t\tfor i:=0 to 255 do\n\t\t\tpalette[i]:=colour\n\t\t\tcolour+:=0x10101\n\t\tod\n\tfi\n\n\tsetupgdi(bm,hwnd)\n\n\tbm.gdi.hdc:=createcompatibledc(nil)\n\tbm.gdi.drawmode:=dm_memory\n\tbm.gdi.oldbmobj:=selectobject(bm.gdi.hdc,hwnd)\t!should store original bitmap\n\tsetstretchbltmode(bm.gdi.hdc,4)\t\t\t!average pixels for best result\n\n\tbmputpalette(bm,palette)\n\n\treturn bm\nend\n\nexport func bmgetpalette(bm)=\n!extract entire palette to p, in bmrgb order\n\tif bm.paltype then\n\t\tpalette:=new(array,i32,0..256)\n\t\tgetdibcolortable(bm.gdi.hdc,0,256,&palette)\n\t\tpalette[256]:=bm.paltype\n\t\treversepalette(palette)\n\telse\n\t\tpalette:=()\n\tfi\n\treturn palette\nend\n\nexport proc bmputpalette(bm,p,reverse=1)=\n!update entire palette from p, in bmrgb order\n\tif bm.paltype then\n\t\tif reverse then reversepalette(p) fi\t\t!fix colours\n\t\tsetdibcolortable(bm.gdi.hdc,0,256,&p)\t!store\n\t\tif reverse then reversepalette(p) fi\t\t\t!restore orignal palette\n\t\tif p.upb=256 then\n\t\t\tbm.paltype:=p[256]\n\t\tfi\n\tfi\nend\n\nexport func bmcolour(bm,n,?colour)=\n!get/set palette info:\n!n=given:\n! colour given: update colour entry\n! colour omitted(-1): return colour value\n\n\tif colour.isdef then\t\t!set colour\n\t\tcolour:=revpixel(colour)\n\t\tsetdibcolortable(bm.gdi.hdc,n,1,&colour)\n\t\treturn colour\n\telse\t\t\t\t!get colour\n\t\tcolour:=0\n\t\tgetdibcolortable(bm.gdi.hdc,n,1,&colour)\n\t\treturn revpixel(colour)\n\tfi\nend\n\nexport proc reversepalette(&p)=\n!reverse values of 32-bit colour data at p\n\tfor i:=0 to 255 do\n\t\tp[i]:=revpixel(p[i])\n\tod\nend\n\nexport func revpixel(a)=\n!change rgb to bgr\n!windows colours use red in lsb, bitmaps use blue in lsb, in 24-bit pixels and palette colours\nreturn (a iand 0x00ff00) ior (a>>16 iand 255) ior ((a iand 255)<<16)\nend\n\nexport proc bmshow(bm)=\n\tgxcopy(bm)\nend\n\nexport proc bmfree(bm)=\n\treturn when bm=nil\n\tif not deletedc(bm.gdi.hdc) then\n\t\tpcerror(\"ERROR DELETING BM/HDC\")\n\tfi\n\n\tif not deleteobject(bm.gdi.hwnd) then\n\t\tpcerror(\"ERROR DELETING DIB\")\n\tfi\nend\n\nexport func bmdupl(bm)=\n\tnewbm:=bmcreate(bm.pixelbits, bm.dimx, bm.dimy)\n\tmemcpy(newbm.pixelptr, bm.pixelptr, bm.linebytes*bm.dimy)\n\n\tbmduplpalette(newbm,bm)\n\n\treturn newbm\nend\n\nexport proc bmduplpalette(newbm,bm)=\n\tif bm.paltype then\n\t\tpal:=bmgetpalette(bm)\n\t\tbmputpalette(newbm,pal)\n\t\tnewbm.paltype:=bm.paltype\n\tfi\nend\n\nexport func bmduplz(bm)=\n\tnewbm:=bmcreate(bm.pixelbits, bm.dimx, bm.dimy)\n\treturn newbm\nend\n\nexport func bmgetptr(bm,x,y)=\n!return byte pointer to given pixel\n\treturn bm.pixelptr+(bm.linebytes*y+x*bm.pixelbytes)\nend\n\nexport func bmgetrowptr(bm,y)=\n\treturn bm.pixelptr+y*bm.linebytes\nend\n\n!export func bmgetpixel(bm,y)=\n!\treturn bm.pixelptr+y*bm.linebytes\n!end\n\nfunc getcbbitmap(hwnd)=\n\n\tp:=globallock(hwnd)\n\thsize:=ws_bitmapinfoheader.bytes\n\tbm:=nil\n\n\tif p then\n\t\tp:=makeref(p,ws_bitmapinfoheader)\n\t\tpb:=makeref(p,byte)\n\n\t\tbm:=bmcreate(p^.bitcount,p^.width,p^.height)\n\t\toffset:=(bm.paltype|1024|0)\t\t!offset due to palette table\n\n\t\tif offset then\n\t\t\tsetdibcolortable(bm.gdi.hdc,0,256,pb+hsize)\n\t\tfi\n\n\t\tpb:=pb+hsize+offset\n\t\tfor y:=0 to bm.dimy-1 do\n\t\t\tq:=bmgetrowptr(bm,bm.dimy-y-1)\n\t\t\tmemcpy(q,pb,bm.linebytes)\n\t\t\tpb:=pb+bm.linebytes\n\t\tod\n\n\tfi\n\n\tglobalunlock(hwnd)\n\n\treturn bm\nend\n\nexport func bmgetclipboard=\n!get image from clipboard if one is there, otherwise return nil\n\tif openclipboard(nil)=0 then\n\t\treturn nil\n\tfi\n\n\thwnd:=getclipboarddata(cf_dib)\n\n\tbm:=nil\n\tif hwnd then\n\t\tbm:=getcbbitmap(hwnd)\n\tfi\n\n\tcloseclipboard()\n\n\treturn bm\nend\n\nexport func bmputclipboard(bm)=\n\tif openclipboard(0)=0 then\n\t\treturn nil\n\tfi\n\n\temptyclipboard()\n\n\thwnd:=putcbbitmap(bm)\n\tif hwnd then\n\t\tsetclipboarddata(cf_dib,hwnd)\n\tfi\n\n\tcloseclipboard()\n\treturn 1\nend\n\nfunc putcbbitmap(bm)=\n\tvar mem\n\n\thsize:=ws_bitmapinfoheader.bytes\n\tpsize:=(bm.paltype|1024|0)\n\tfsize:=bm.linebytes*bm.dimy\n\n\thmem:=globalalloc(0,hsize+psize+fsize)\n\tmem:=makeref(globallock(hmem),byte)\n\tmem:=0!makeref(globallock(hmem),byte)\n\n\thdr:=new(ws_bitmapinfoheader)\n\thdr.size:=hsize\n\thdr.width:=bm.dimx\n\thdr.height:=bm.dimy\n\thdr.bitcount:=bm.pixelbits\n\thdr.planes:=1\n\thdr.xpelspermetre:=11811\n\thdr.ypelspermetre:=11811\n\thdr.clrused:=0\n\n\tmemcpy(mem,&hdr,hsize)\n\n\tif psize then\n\t\tpal:=bmgetpalette(bm)\n\t\tmemcpy(mem+hsize,&pal,psize)\n\tfi\n\n\tmem:=mem+hsize+psize\n\tfor y:=0 to bm.dimy-1 do\n\t\tp:=bmgetrowptr(bm,bm.dimy-1-y)\n\t\tmemcpy(mem, p, bm.linebytes)\n\t\tmem:=mem+bm.linebytes\n\tod\n\tglobalunlock(hmem)\n\n\treturn hmem\nend\n\nproc copy24to8(newbm,oldbm)=\n!both images are same size. Copy 1st plane of 24-bit oldbm to 8-bit newbm\n\tfor y:=0 to oldbm.dimy-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(oldbm,y)\n\t\tto oldbm.dimx do\n\t\t\tp++^:=q^\n\t\t\tq:=q+3\n\t\tod\n\tod\nend\n\n!proc copy8to24(newbm,oldbm)=\n!!both images are same size. Copy only plane of 8-bit oldbm to all planes of 24-bit newbm\n!\tfor y:=0 to oldbm.dimy-1 do\n!\t\tp:=bmgetrowptr(newbm,y)\n!\t\tq:=bmgetrowptr(oldbm,y)\n!\t\tto oldbm.dimx do\n!\t\t\tp++^:=q^\n!\t\t\tq:=q+3\n!\t\tod\n!\tod\n!end\n\nexport proc bmresetpalette(bm)=\n# set palette back to greyscale\n\tpal:=new(array,i32,0..256)\n\tcolour:=0\n\tfor i:=0 to 255 do\n\t\tpal[i]:=colour\n\t\tcolour+:=0x010101\n\tod\n\tbmputpalette(bm,pal)\n\tbm.paltype:=greyscale_pal\nend\n\nfunc makescalemap(x)=\n!x=0..1; create 256-element lookup table to multiply 0..255 by x\n\tmap:=new(list,0..255)\n\tfor i:=0 to 255 do\n\t\tmap[i]:=clamp(int(round(i*x)),0,255)\n\tod\n\treturn map\nend\n\nfunc bmunimpl(mess)=\n!ABORT(\"UNIMPLEMENTED: \"+MESS)\nPRINTLN \"UNIMPLEMENTED:\",MESS\nPRINTLN \"ABORTING\"\nSTOP\nreturn 0\nend\n\n!===========================================================================\n!========= HANDLERS\n!===========================================================================\n\nexport func bmload(filename)=\n!CPL \"BMLOAD:\",FILENAME\n\tcase e:=convlc(extractext(filename))\n\twhen \"jpg\",\"jpeg\" then\n\t\treturn bmloadjpg(filename)\n\twhen \"bmp\" then\n\t\treturn bmloadbmp(filename)\n!\twhen \"pgm\" then\n!\t\treturn bmloadpgm_p2p5(filename)\n\twhen \"ppm\",\"pgm\" then\n\t\treturn bmloadppm_p3p6(filename)\n\twhen \"png\" then\n\t\treturn bmloadpng(filename)\n\twhen \"\" then\t\t\t\t!try all\n\t\texts:=(\"jpg\",\"bmp\",\"pgm\",\"ppm\",\"png\")\n\t\tfor ext in exts do\n\t\t\tbm:=bmload(addext(filename,ext))\n\t\t\tif bm then\n\t\t\t\treturn bm\n\t\t\tfi\n\t\tod\n\t\treturn nil\n\telse\n\t\tprintln \"CAN'T LOAD\",E,\"IMAGE\"\n\t\treturn nil\n\tesac\n\treturn nil\nend\n\nfunc bmloadbmp(filename)=\n\tf:=openfile(filename)\n\tif not f then return nil fi\n\n\tfileheader:=new(bmpheader)\n\n\treadrandom(f,&fileheader,0,bmpheader.bytes)\n\tfiledimx:=fileheader.bh.width\n\tfiledimy:=fileheader.bh.height\n\tinvert:=1\n\tif filedimy<0 then\n\t\tfiledimy:=abs(filedimy)\n\t\tinvert:=0\n\tfi\n\n\tif fileheader.fh.typex<>'BM' then\n\t\tclosefile(f)\n\t\treturn nil\n\tfi\n\n\tif fileheader.bh.compression<>0 then\n\t\tclosefile(f)\n\t\treturn nil\n\tfi\n\n\tbm:=bmcreate(fileheader.bh.bitcount,filedimx,filedimy)\n\tframebytes:=bm.linebytes*filedimy\n\n\tif bm.paltype then\n\t\tpalette:=new(array,i32,0..255)\n\t\treadrandom(f,&palette,bmpheader.bytes,1024)\n\t\tbmputpalette(bm,palette,0)\n\t\tcolour:=0\n\t\tfor i:=0 to 255 do\n\t\t\tif palette[i]<>colour then\n\t\t\t\tbm.paltype:=colour_pal\n\t\t\t\texit\n\t\t\tfi\n\t\t\tcolour+:=0x010101\n\t\tod\n\n\tfi\n\n\treadrandom(f,bm.pixelptr,fileheader.fh.offbits,framebytes)\n\tclosefile(f)\n\n\n\tif invert then\n\t\tn:=bm.linebytes\n\t\tbuffer:=makeref(malloc(n),byte)\n\n\t\tfor y:=0 to filedimy%2 do\n\t\t\tp:=bmgetrowptr(bm,y)\n\t\t\tq:=bmgetrowptr(bm,filedimy-1-y)\n!\n\t\t\tmemcpy(buffer,p,n)\n\t\t\tmemcpy(p,q,n)\n\t\t\tmemcpy(q,buffer,n)\n\t\tod\n\t\tfree(buffer)\n\tfi\n\n\treturn bm\nend\n\nexport func bmloadjpg(filename)=\n\tw:=h:=n:=0\n\nCPL \"LOADJ1\"\n!\tp:=imgload_bgr(filename,&w,&h,&n,3)\n\n!\tp:=imgload_bgr(filename,&w,&h,&n,3)\n\tp:=loadjpegm(filename,&w,&h,&n);\n!\tp:=nanoloadjpeg(filename,&w,&h,&n)\n\n\n!\tp:=imgload_bgr(filename,&w,&h,&n)\nCPL \"LOADJ2\",=P, W,H,N\n\tIF P=NIL THEN PCERROR(\"CAN'T LOAD JPG\") FI\n\n\tpixelbits:=n*8\n\n\tif p=nil then\n\t\treturn nil\n\tfi\n\n\tq:=makeref(p,byte)\n\n\tbm:=bmcreate(pixelbits,w,h)\n\n\tnbytes:=w*h*n\n\tdest:=makeref(bm.pixelptr,byte)\n\n\tto h do\n\t\tmemcpy(dest,q,w*n)\n\t\tdest:=dest+bm.linebytes\n\t\tq:=q+w*n\n\tod\n\n!\timgload_free(p)\n\n\treturn bm\nend\n\nfunc bmloadpbm_p1p4(filename)=\nCPL \"CAN'T LOAD PBM\"\nRETURN NIL\n!return bmunimpl(\"bmloadpbm\")\nend\n\nfunc bmloadpgm_p2p5(filename)=\n\nCPL \"LOAD PGM P25\",FILENAME\n\tf:=openfile(filename,\"rb\")\n\tif f=0 then return nil fi\n\n\treadln @f, sig:\"s\"\n\n!CPL =SIG\n\tcase sig\n\twhen \"P5\" then\n\t\tbinary:=1\n\twhen \"P2\" then\n\t\tbinary:=0\n\telse\n\t\tabort(\"Can't read pgm\")\n\t\treturn nil\n\tesac\t\n\n\twidth:=readnextint(f)\n\theight:=readnextint(f)\n\tmaxpix:=readnextint(f)\n\n\tbm:=bmcreate(8,width,height)\n\n\tlinebytes:=width\n\tdest:=makeref(bm.pixelptr,byte)\n\nCPL =WIDTH,=HEIGHT, LINEBYTES,=BM\n\tto height do\n\t\tif binary then\n\t\t\treadbytes(f,dest,width)\t\t\t!will be bgr\n\t\telse\n\t\t\tp:=dest\n\t\t\tto linebytes do\n\t\t\t\tp++^:=readffint(f)\n\t\t\tod\n\t\tfi\n\n\t\tdest:=dest+bm.linebytes\n\tod\n\n\tclosefile(f)\n\n\treturn bm\nend\n\nfunc bmloadppm_p3p6(filename)=\n!read p6 ppm which is binary 24-bit, but will also recognise other formats\n\n!CPL \"P3P6\"\n\tf:=openfile(filename,\"rb\")\n\tif f=0 then return nil fi\n\n\treadln @f, sig:\"s\"\n\n!CPL =SIG\n\tcase sig\n\twhen \"P6\" then\n\t\tbinary:=1\n\twhen \"P3\" then\n\t\tbinary:=0\n\twhen \"P5\",\"P2\" then\n\t\tclosefile(f)\n\t\treturn bmloadpgm_p2p5(filename)\n!\twhen \"P4\",\"P1\" then\n!\t\tclosefile(f)\n!\t\treturn bmloadpbm_p1p4(filename)\n\telse\n\t\tabort(\"Can't read ppm:\"+sig)\n\t\treturn nil\n\tesac\t\n\n!CPL \"READING P6/P3 PPM\"\n\n\twidth:=readnextint(f)\n\theight:=readnextint(f)\n\tmaxpix:=readnextint(f)\n\n\tbm:=bmcreate(24,width,height)\n\n\tlinebytes:=width*3\n\tdest:=makeref(bm.pixelptr,byte)\n\n\tto height do\n\t\tif binary then\n\t\t\treadbytes(f,dest,linebytes)\t\t\t!will be bgr\n\t\telse\n\t\t\tp:=dest\n\t\t\tto linebytes do\n\t\t\t\tp++^:=readffint(f)\n\t\t\tod\n\t\tfi\n\n\t\tp:=dest\t\t\t\t\t\t\t\t!convert to rgb\n\t\tto width do\n\t\t\tswap(p^,(p+2)^)\n\t\t\tp:=p+3\n\t\tod\n\n\t\tdest:=dest+bm.linebytes\n\tod\n\n\tclosefile(f)\n\n\treturn bm\nend\n\nfunc readnextint(f)=\n\tread x\n\twhile not x.isint and not eof(f) do\n\t\treadln @f,x\n\tod\n\tif not x.isint then return 0 fi\n\treturn x\nend\n\nfunc readffint(f)=\n!read next free-format int from f\n\trepeat\n\t\tc:=inbyte(f)\n\tuntil c in '0'..'9'\n\n\ta:=c-'0'\n\tdo\n\t\tc:=inbyte(f)\n\t\tif c in '0'..'9' then\n\t\t\ta:=a*10+c-'0'\n\t\telse\n\t\t\texit\n\t\tfi\n\tod\n\n\treturn a\nend\n\nfunc bmloadpng(filename)=\n\tw:=h:=n:=0\n\nCPL \"LOADP1\"\n!\tp:=imgload_bgr(filename,&w,&h,&n,3)\n\n\tp:=imgload_bgr(filename,&w,&h,&n,0)\n\n!\tp:=nanoloadjpeg(filename,&w,&h,&n)\n\n\n\n!\tp:=imgload_bgr(filename,&w,&h,&n)\nCPL \"LOADP2\",=P, W,H,N\n\n\tpixelbits:=n*8\n\n\tif p=nil then\n\t\treturn nil\n\tfi\n\n\tq:=makeref(p,byte)\n\n\tbm:=bmcreate(pixelbits,w,h)\n\n\tnbytes:=w*h*n\n\tdest:=makeref(bm.pixelptr,byte)\n\n\tto h do\n\t\tmemcpy(dest,q,w*n)\n\t\tdest:=dest+bm.linebytes\n\t\tq:=q+w*n\n\tod\n\n\timgload_free(p)\n\n\treturn bm\nend\n\nexport func bmsave(filename,bm,binary=0)=\n\tcase e:=convlc(extractext(filename))\n\twhen \"jpg\",\"jpeg\" then\n\t\treturn bmsavejpg(filename,bm)\n\twhen \"bmp\" then\n\t\treturn bmsavebmp(filename,bm)\n\twhen \"ppm\",\"pgm\" then\n\t\treturn bmsaveppm_p3p6(filename,bm,binary)\n\telse\n\t\tprintln \"CAN'T SAVE\",E,\"IMAGE\"\n\t\treturn nil\n\tesac\n\treturn nil\nend\n\nfunc bmsavebmp(filename,bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tpixelbytes:=bm.pixelbytes\n\tframebytes:=bm.linebytes*h\n\tpalettebytes:=(pixelbytes=1|1024|0)\n\n\tbmfile:=createfile(filename)\n\tif bmfile=nil then\n\t\treturn 0\n\tfi\n\n\tfileheader:=new(bmpheader)\n\n\tfileheader.fh.typex:='BM'\n\tfileheader.fh.offbits:=bmpheader.bytes+palettebytes\n\tfileheader.fh.size:=fileheader.fh.offbits+framebytes\n\tfileheader.bh.size:=ws_bitmapinfoheader.bytes\n\tfileheader.bh.width:=bm.dimx\n\tfileheader.bh.height:=-bm.dimy\n\tfileheader.bh.bitcount:=bm.pixelbits\n\tfileheader.bh.planes:=1\n\tfileheader.bh.xpelspermetre:=11811\t\t!300 dpi\n\tfileheader.bh.ypelspermetre:=11811\n\tfileheader.bh.clrused:=0\n\n\twriterandom(bmfile,&fileheader,0,bmpheader.bytes)\n\n\tif palettebytes then\n\t\tpalette:=bmgetpalette(bm)\n\t\treversepalette(palette)\n\t\twriterandom(bmfile,&palette,bmpheader.bytes,palettebytes)\n\tfi\n\n\twriterandom(bmfile,bm.pixelptr,fileheader.fh.offbits,framebytes)\n\n\treturn closefile(bmfile)\nend\n\nfunc bmsavejpg(filename,bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tpixelbytes:=bm.pixelbytes\n\tlinebytes:=bm.linebytes\n\n\tp:=q:=malloc(pixelbytes*w*h)\n\n\ts:=makeref(bm.pixelptr,byte)\n\n\tto h do\n\t\tmemcpy(q,s,w*pixelbytes)\n\t\tq:=q+bm.linebytes\n\t\ts:=s+w*pixelbytes\n\tod\n\n\tstatus:=imgsave_jpeg_bgr(filename,p,w,h,pixelbytes)\n\n\tfree(p)\n\n\treturn status\nend\n\nfunc bmsavepbm_p1p4(filename,bm,binary)=\nreturn bmunimpl(\"bmsaveppm-1bit\")\nend\n\nfunc bmsavepgm_p2p5(filename,bm,binary)=\n\twidth:=bm.dimx\n\theight:=bm.dimy\n\n\tf:=createfile(filename)\n\n\tCPL \"WRITEPGM\",filename\n\n\tif not f then return 0 fi\n\n\tprintln @f,(binary|\"P5\"|\"P2\")\n\tprintln @f,width,height\n\tprintln @f,\"255\"\n\n\tbuffer:=data\n\n\tbuffer:=malloc(bm.linebytes)\n\tif buffer=nil then return 0 fi\n\tbuffer:=makeref(buffer,byte)\n\n\tlinebytes:=width\t\t\t!also number of values per line when in text mode\n\n\tfor y:=0 to height-1 do\n\t\tmemcpy(buffer,bmgetrowptr(bm,y),linebytes)\n\t\tif binary then\n\t\t\twritebytes(f,buffer,linebytes)\n\t\telse\n\t\t\tp:=buffer\n\t\t\tto linebytes do\n\t\t\t\tprint @f,p++^,,\" \"\n\t\t\tod\n\t\t\tprintln @f\n\t\tfi\n\tod\n\tclosefile(f)\n\treturn 1\nend\n\nfunc bmsaveppm_p3p6(filename,bm,binary)=\n!\treturn bmunimpl(\"bmsaveppm\")\n\n\tcase bm.pixelbits\n\twhen 24 then\n\twhen 8 then\n\t\treturn bmsavepgm_p2p5(filename,bm,binary)\n\telse\n\t\treturn 0\n\tesac\n\n\twidth:=bm.dimx\n\theight:=bm.dimy\n\n\tf:=createfile(filename)\n\n\tCPL \"WRITEPPM\",filename\n\n\tif not f then return 0 fi\n\n\tprintln @f,(binary|\"P6\"|\"P3\")\n\tprintln @f,width\n\tprintln @f,height\n\tprintln @f,\"255\"\n\n\tbuffer:=data\n\n\tbuffer:=malloc(bm.linebytes)\n\tif buffer=nil then return 0 fi\n\tbuffer:=makeref(buffer,byte)\n\n\tlinebytes:=width*3\t\t\t!also number of values per line when in text mode\n\n\tfor y:=0 to height-1 do\n\t\tmemcpy(buffer,bmgetrowptr(bm,y),linebytes)\n\t\tp:=buffer\t\t\t\t\t!convert to bgr\n\t\tto width do\n\t\t\tswap(p^,(p+2)^)\n\t\t\tp:=p+3\n\t\tod\n\t\tif binary then\n\t\t\twritebytes(f,buffer,linebytes)\n\t\telse\n\t\t\tp:=buffer\n\t\t\tto linebytes do\n\t\t\t\tprint @f,p++^,,\" \"\n\t\t\tod\n\t\t\tprintln @f\n\t\tfi\n\tod\n\tclosefile(f)\n\treturn 1\nend\n\nexport func bmrotate(bm, angle)=\n\tcase angle\n\twhen 0 then return bmdupl(bm)\n\twhen -90 then return bmrotleft90(bm)\n\twhen +90 then return bmrotright90(bm)\n\twhen 180 then return rot180(bm)\n\tesac\n\treturn bmunimpl(\"bmrotate by \"+tostr(angle))\nend\n\nexport func bmrotleft90(bm)=\n\tcase bm.pixelbits\n\twhen 8 then return rotleft90_8(bm)\n\twhen 24 then return rotleft90_24(bm)\n\twhen 32 then return bmunimpl(\"ROTLEFT90/32\")\n\tesac\n\treturn nil\nend\n\nexport func bmrotright90(bm)=\n\tcase bm.pixelbits\n\twhen 8 then return rotright90_8(bm)\n\twhen 24 then return rotright90_24(bm)\n\twhen 32 then return bmunimpl(\"ROTRIGHT90/32\")\n\tesac\n\treturn nil\nend\n\nexport func rot180(bm)=\n\tnewbm1:=bmfliphoz(bm)\n\tnewbm2:=bmflipvert(newbm1)\n\tbmfree(newbm1)\n\treturn newbm2\nend\n\nfunc rotleft90_8(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tlinebytes:=bm.linebytes\n\n\tnewbm:=bmcreate(8,h,w)\n\n\tfor y:=0 to w-1 do\n\t\tq:=bmgetptr(bm,w-y-1,0)\n\t\tp:=bmgetrowptr(newbm,y)\n\n\t\tto h do\n\t\t\tp++^:=q^\n!\t\t\tq:=q+w\n\t\t\tq:=q+linebytes\n\t\tod\n\tod\n\n\tbmduplpalette(newbm,bm)\n\treturn newbm\nend\n\nfunc rotright90_8(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tlinebytes:=bm.linebytes\n\n\tnewbm:=bmcreate(8,h,w)\n\n\tfor y:=0 to w-1 do\n\t\tq:=bmgetptr(bm,y,h-1)\n\t\tp:=bmgetrowptr(newbm,y)\n\n\t\tto h do\n\t\t\tp++^:=q^\n\t\t\tq:=q-linebytes\n\t\tod\n\tod\n\n\tbmduplpalette(newbm,bm)\n\treturn newbm\nend\n\n!function rotleft90_24(bm)=\n!\tnewbm:=bmcreate(24,bm.dimy,bm.dimx)\n!\n!\txform:=new(array,ws_point,3)\n!\txform[1].y:=bm.dimx\n!\txform[3].x:=bm.dimy\n!\txform[3].y:=bm.dimx\n!\n!\tplgblt(newbm.gdi.hdc,&xform, bm.gdi.hdc,0,0,bm.dimx,bm.dimy, nil,0,0)\n!\n!\treturn newbm\n!end\n\nfunc rotleft90_24(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tnewbm:=bmcreate(24,h,w)\n\n\tfor y:=0 to w-1 do\n\t\tq:=bmgetptr(bm,w-y-1,0)\n\t\tp:=bmgetrowptr(newbm,y)\n\n\t\tto h do\n\t\t\tp++^:=q^\n\t\t\tp++^:=(q+1)^\n\t\t\tp++^:=(q+2)^\n\t\t\tq:=q+bm.linebytes\n\t\tod\n\tod\n\n\treturn newbm\nend\n\n!function rotright90_24(bm)=\n!\tnewbm:=bmcreate(24,bm.dimy,bm.dimx)\n!\n!\txform:=new(array,ws_point,3)\n!\txform[1].X:=bm.dimy\n!\txform[2].x:=bm.dimy\n!\txform[2].y:=bm.dimx\n!\n!\tplgblt(newbm.gdi.hdc,&xform, bm.gdi.hdc,0,0,bm.dimx,bm.dimy, nil,0,0)\n!\n!\treturn newbm\n!end\n\nfunc rotright90_24(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tnewbm:=bmcreate(24,h,w)\n\n\tfor y:=0 to w-1 do\n\t\tq:=bmgetptr(bm,y,h-1)\n\t\tp:=bmgetrowptr(newbm,y)\n\n\t\tto h do\n\t\t\tp++^:=q^\n\t\t\tp++^:=(q+1)^\n\t\t\tp++^:=(q+2)^\n\t\t\tq:=q-bm.linebytes\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nfunc rotate8(bm,angle)=\nreturn bmunimpl(\"rotate8\")\nend\n\nexport func bmfliphoz(bm)=\n\tcase bm.pixelbytes\n    when 1 then return fliphoz8(bm)\n    when 3 then return fliphoz24(bm)\n    when 4 then return fliphoz32(bm)\n\tesac\n\treturn nil\nend\n\nfunc fliphoz8(bm)=\n\tnewbm:=bmdupl(bm)\n\n\tw:=newbm.dimx\n\th:=newbm.dimy\n\tbuffer:=makeref(malloc(bm.linebytes),byte)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=p+w-1\n\t\tfor x:=0 to w%2 do\n\t\t\tt:=p^\n\t\t\tp^:=q^\n\t\t\tq^:=t\n\t\t\t++p; --q\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nfunc fliphoz24(bm)=\n\tnewbm:=bmdupl(bm)\n\n\tw:=newbm.dimx\n\th:=newbm.dimy\n\tbuffer:=makeref(malloc(bm.linebytes),byte)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tmemcpy(buffer,p,bm.linebytes)\n\t\tq:=buffer+(w-1)*3\n\n\t\tto w do\n\t\t\tp++^:=q++^\n\t\t\tp++^:=q++^\n\t\t\tp++^:=q^\n\n\t\t\tq:=q-5\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nfunc fliphoz32(bm)=\nreturn bmunimpl(\"fliphoz_32\")\nend\n\nexport func bmflipvert(bm)=\n\tnewbm:=bmdupl(bm)\n\n\tw:=newbm.dimx\n\th:=newbm.dimy\n\tn:=bm.linebytes\n\tbuffer:=makeref(malloc(n),byte)\n\n\tfor y:=0 to h%2 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(newbm,h-1-y)\n!\n\t\tmemcpy(buffer,p,n)\n\t\tmemcpy(p,q,n)\n\t\tmemcpy(q,buffer,n)\n\tod\n\tfree(buffer)\n\n\treturn newbm\nend\n\nexport func bmrepeat(bm,cols,rows)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tnewbm:=bmcreate(bm.pixelbits, w*cols, h*rows)\n\tlinebytes:=bm.linebytes\n\n\tfor y:=0 to h-1 do\n\t\ts:=bmgetrowptr(bm,y)\n\t\tfor r:=0 to rows-1 do\n\t\t\tfor c:=0 to cols-1 do\n\t\t\t\tmemcpy(bmgetptr(newbm,c*w,r*h+y),s,linebytes)\n\t\t\tod\n\t\tod\n\tod\n\n\tif bm.pixelbits=8 then\n\t\tbmduplpalette(newbm,bm)\n\tfi\n\n\treturn newbm\nend\n\nexport func bmscale(bm, sx,?sy)=\n\tif sy.isvoid then sy:=sx fi\n\tcase bm.pixelbits\n\twhen 8 then return scalex8(bm,sx,sy)\n\twhen 24,32 then return scalex24(bm,sx,sy)\n\tesac\n\treturn nil\nend\n\nfunc scalex8(bm,sx,sy)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tneww:=int(round(w*sx))\n\tnewh:=int(round(h*sy))\n\n\tnewbm:=bmcreate(24, neww,newh)\n\treturn nil when not newbm\n\n\tbm24:=bmtorgb(bm,24)\n\n\tstretchblt(newbm.gdi.hdc,0,0,neww,newh,bm24.gdi.hdc,0,0,w,h, srccopy)\n\n\tif bm.paltype=greyscale_pal then\n\t\tnewbm8:=bmgetplane(newbm,\"R\")\n\telse\n\t\tnewbm8:=bmtopal(newbm)\n\tfi\n\tbmfree(newbm)\n\n\treturn newbm8\nend\n\nfunc scalex24(bm,sx,sy)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tneww:=int(round(w*sx))\n\tnewh:=int(round(h*sy))\n\n\tif neww<8 or newh<8 then return nil fi\n\n\tnewbm:=bmcreate(bm.pixelbits, neww,newh)\n\tif newbm then\n\t\tstretchblt(newbm.gdi.hdc,0,0,neww,newh,bm.gdi.hdc,0,0,w,h, srccopy)\n\tfi\n\n\treturn newbm\nend\n\nfunc bmscaleupi8(bm,sx,sy)=\nreturn bmunimpl(\"bmscaleupi8\")\nend\n\nfunc bmscaleupi24(bm,sx,sy)=\nreturn bmunimpl(\"bmscaleupi24\")\nend\n\nfunc bmscaleupi32(bm,sx,sy)=\nreturn bmunimpl(\"bmscaleupi32\")\nend\n\nfunc bmscaledowni8(bm,sx,sy)=\nreturn bmunimpl(\"bmscaledowni8\")\nend\n\nfunc bmscaledowni24(bm,sx,sy)=\nreturn bmunimpl(\"bmscaledowni24\")\nend\n\nfunc bmscaledowni32(bm,sx,sy)=\nreturn bmunimpl(\"bmscaledowni32\")\nend\n\nexport func bmneg(bm)=\n\tnewbm:=bmdupl(bm)\n\n\tdx:=newbm.dimx-1\n\tdy:=newbm.dimy-1\n\tn:=newbm.linebytes\n\tdo32:=0\n\tif n rem 4=0 then\n\t\tdo32:=1\n\t\tn:=n%4\n\tfi\n\n\tfor y:=0 to dy do\n\t\tif do32 then\n\t\t\tp:=makeref(bmgetrowptr(newbm,y),i32)\n\t\t\tto n do\n\t\t\t\tp++^ := p^ ixor 0xFFFFFFFF\n\t\t\tod\n\t\telse\n\t\t\tp:= bmgetrowptr(newbm,y)\n\t\t\tto n do\n\t\t\t\tp++^ := p^ ixor 255\n\t\t\tod\n\t\tfi\n\tod\n\treturn newbm\nend\n\nexport func bmmap(bm,map, channels=\"RGB\")=\n\tif channels=\"\" then channels:=\"RGB\" fi\n\n\tcase bm.pixelbits\n\twhen 8 then\n\t\treturn mapall(bm,map)\n\twhen 24 then\n\t\tif channels=\"RGB\" then\n\t\t\treturn mapall(bm,map)\n\t\tfi\n\t\treturn mapchan_24(bm,map,channels,0)\n\twhen 32 then\n\t\tif channels=\"RGBA\" then\n\t\t\treturn mapall(bm,map)\n\t\tfi\n\t\treturn mapchan_24(bm,map,channels,1)\n\tesac\n\n\treturn nil\nend\n\nfunc mapall(bm,map)=\n\tnewbm:=bmdupl(bm)\n\tp:=newbm.pixelptr\n\tto newbm.framebytes do\n\t\tp^:=map[p^]\n\t\t++p\n\tod\n\treturn newbm\nend\n\nfunc mapchan_24(bm,map,channels,alpha=0)=\n\tdored:=\"R\" in channels\n\tdogreen:=\"G\" in channels\n\tdoblue:=\"B\" in channels\n\tdoalpha:=\"A\" in channels\n\n\tnewbm:=bmdupl(bm)\n\n\tfor y:=0 to newbm.dimy-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tto newbm.dimx do\n\t\t\tif doblue then p^:=map[p^] fi\n\t\t\t++p\n\t\t\tif dogreen then p^:=map[p^] fi\n\t\t\t++p\n\t\t\tif dored then p^:=map[p^] fi\n\t\t\t++p\n\t\t\tif alpha then\n\t\t\t\tif doalpha then p^:=map[p^] fi\n\t\t\t\t++p\n\t\t\tfi\n\t\tod\n\tod\n\n\treturn newbm\nend\n\n!function mapchan_32(bm,map,channels)=\n!return bmunimpl(\"mapchan_32\")\n!end\n\nexport func bmbright(bm,dx,channels=\"RGB\")=\n\treturn bmunimpl(\"bmbright\")\nend\n\nexport func bmcont(bm,x,channels=\"RGB\")=\n\treturn bmunimpl(\"bmcont\")\nend\n\nexport func bmgamma(bm,x,channels=\"RGB\")=\nreturn bmunimpl(\"bmgamma\")\nend\n\nexport func bmtogrey(bm,destbits=24)=\n\tif destbits=0 then destbits:=bm.pixelbits fi\n\tcase bm.pixelbits\n\twhen 8 then\n\t\tcase destbits\n\t\twhen 8 then\n\t\t\treturn pal8togrey8(bm)\n\t\twhen 24 then\n\t\t\tcm:=pal8togrey8(bm)\n\t\t\tnewbm:=grey8torgb24(cm)\n\t\t\tbmfree(cm)\n\t\t\treturn newbm\n\t\tesac\n\twhen 24,32 then\n\t\tcase destbits\n\t\twhen 8 then\n\t\t\treturn rgb24togrey8(bm)\n\t\twhen 24 then\n\t\t\tcm:=rgb24togrey8(bm)\n\t\t\tnewbm:=grey8torgb24(cm)\n\t\t\tbmfree(cm)\n\t\t\treturn newbm\n\t\tesac\n\tesac\nCPL =BM.PIXELBITS, =DESTBITS\n\treturn bmunimpl(\"bmtogrey bad combos\")\n\nend\n\nfunc pal8togrey8(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\t(rmap, gmap, bmap):=getlumtables()\n\n\tnewbm:=bmcreate(8,w,h)\n\tpal:=bmgetpalette(bm)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(bm,y)\n\n\t\tto w do\n\t\t\tcolour:=pal[q++^]\n\t\t\tr:=colour.[0..7]\n\t\t\tg:=colour.[8..15]\n\t\t\tb:=colour.[16..23]\n\t\t\tp++^:=rmap[r]+gmap[g]+bmap[b]\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nfunc pal8togrey24(bm)=\nreturn bmunimpl(\"pal8togrey24\")\nend\n\nfunc rgb24togrey8(bm)=\n!does 24/32 bits\n\tqincr:=(bm.pixelbits=32|1|0)\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\t(rmap, gmap, bmap):=getlumtables()\n\n\tnewbm:=bmcreate(8,w,h)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(bm,y)\n\n\t\tto w do\n\t\t\tb:=q++^; g:=q++^; r:=q++^\n\t\t\tp++^:=rmap[r]+gmap[g]+bmap[b]\n\t\t\tq:=q+qincr\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nfunc rgb24togrey24(bm)=\nreturn bmunimpl(\"rgb24togrey24\")\nend\n\nexport func bmtorgb(bm,destbits=24)=\n\tif destbits=0 then destbits:=24 fi\n\tcase bm.pixelbits\n\twhen destbits then\n\t\treturn bmdupl(bm)\n\n\twhen 8 then\n\t\tcase destbits\n\t\twhen 8 then\n\t\t\tbmunimpl(\"8 to 8 bits rgb\")\n\t\twhen 24 then\n\t\t\tif bm.paltype=greyscale_pal then\n\t\t\t\treturn grey8torgb24(bm)\n\t\t\telse\n\t\t\t\treturn paltorgb24(bm)\n\t\t\tfi\n\t\tesac\n\twhen 24 then\n\t\tif destbits=32 then\n\t\t\treturn bmrgb24torgb32(bm)\n\t\tfi\n\twhen 32 then\n\t\tif destbits=24 then\n\t\t\treturn bmrgb32torgb24(bm)\n\t\tfi\n\tesac\nCPL =BM.PIXELBITS, =DESTBITS\n\treturn bmunimpl(\"bmtorgb bad combos\")\nend\n\nfunc paltorgb24(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tnewbm:=bmcreate(24,w,h)\n\tpal:=bmgetpalette(bm)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(bm,y)\n\n\t\tto w do\n\t\t\tcolour:=pal[q++^]\n\t\t\tr:=colour.[0..7]\n\t\t\tg:=colour.[8..15]\n\t\t\tb:=colour.[16..23]\n\n\t\t\tp++^:=b\n\t\t\tp++^:=g\n\t\t\tp++^:=r\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nfunc grey8torgb24(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tnewbm:=bmcreate(24,w,h)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(bm,y)\n\n\t\tto w do\n\t\t\tlum:=q++^\n\t\t\tp++^:=lum\n\t\t\tp++^:=lum\n\t\t\tp++^:=lum\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nexport func bmrgb24torgb32(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tnewbm:=bmcreate(32,w,h)\n\n\tfor y:=0 to h-1 do\n\t\tq:=bmgetrowptr(bm,y)\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tto w do\n\t\t\tp++^:=q++^\n\t\t\tp++^:=q++^\n\t\t\tp++^:=q++^\n\t\t\tp++^:=128\n\t\tod\n\tod\n\treturn newbm\nend\n\nexport func bmrgb32torgb24(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tnewbm:=bmcreate(24,w,h)\n\n\tfor y:=0 to h-1 do\n\t\tq:=bmgetrowptr(bm,y)\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tto w do\n\t\t\tp++^:=q++^\n\t\t\tp++^:=q++^\n\t\t\tp++^:=q++^\n\t\t\tq++\n\t\tod\n\tod\n\treturn newbm\nend\n\nexport func bmtopal(bm)=\n\tif bm.pixelbits=8 then return bmdupl(bm) fi\n\tqincr:=(bm.pixelbits=32)\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tnewbm:=bmcreate(8,w,h)\n\n\tpal:=new(array,i32,0..255)\n\n!create special palette mapping for rrrgggbb\n\tfor r:=0 to 7 do\n\t\tfor g:=0 to 7 do\n\t\t\tfor b:=0 to 3 do\n\t\t\t\tindex:=r<<5+g<<2+b\n!\t\t\t\tpal[index]:=r<<5+g<<13+b<<18\n\t\t\t\tpal[index]:=r<<5+g<<13+b<<22\n\t\t\tod\n\t\tod\n\tod\n\tbmputpalette(newbm,pal)\n\tbm.paltype:=colour_pal\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(bm,y)\n\n!noise:=-16..16\n!noise:=-8..8\n\n\t\tto w do\n\t\t\tb:=q++^; g:=q++^; r:=q++^\n\n!\t\t\tr+:=clamp(random(noise),0,255)\n!\t\t\tg+:=clamp(random(noise),0,255)\n!\t\t\tb+:=clamp(random(noise),0,255)\n!\n\t\t\tp++^:=r>>5<<5 + g>>5<<2 + b>>6\n\t\t\tq:=q+qincr\n\t\tod\n\tod\n\n\treturn newbm\n\nend\n\nexport func bmsplittorgb(bm,greydest=1)=\n# split 24-bit bitmap into three separate 8-bit planes\n# return 3 new bitmaps in the order red, green, blue\n# return () on error\n# dogreyscale=1 for each image to have a greyscale palette. Otherwise\n# the red image will be shades of red, etc\n\n\tif bm.pixelbits<24 then\n\t\treturn ()\n\tfi\n\tchannels:=bm.pixelbytes\n\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tpal:=new(array,i32,0..255)\n\timages::=()\n\n\tfor offset:=channels-1 downto 0 do\n\n\t\tnewbm:=bmcreate(8,w,h)\n\n\t\tfor y:=0 to h-1 do\n\t\t\tq:=bmgetrowptr(bm,y)+offset\n\t\t\tp:=bmgetrowptr(newbm,y)\n\t\t\tto w do\n\t\t\t\tp++^:=q^\n\t\t\t\tq:=q+channels\n\t\t\tod\n\t\tod\n\n\t\tif not greydest then\n\t\t\tcolour:=0\n\t\t\tincr:=(3-offset|0x00'00'01,0x00'01'00,0x01'00'00|0x01'01'01)\n\t\t\tfor i:=0 to 255 do\n\t\t\t\tpal[i]:=colour\n\t\t\t\tcolour+:=incr\n\t\t\tod\n\t\t\tbmputpalette(newbm,pal)\n\t\t\tnewbm.paltype:=tinted_pal\n\t\tfi\n\n\t\timages append:=newbm\n\tod\n\n!image order is r,g,b, or a,r,g,b\n\tif images.len=4 then\n\t\treturn (images[2],images[3],images[4],images[1])\n\telse\n\t\treturn images\n\tfi\nend\n\nexport func bmsplittoyuv(bm)=\n# split 24-bit bitmap into three separate 8-bit planes\n# return 3 new bitmaps in the order y, u, v\n# return () on error\n\n\tneedfree:=0\n\tcase bm.pixelbits\n\twhen 24 then\n\twhen 32 then\n\t\tbm:=bmtorgb(bm,24)\n\t\tneedfree:=1\n\telse\n\t\treturn nil\n\tesac\n\n!get y plane first with existing routine\n\tgreybm:=bmtogrey(bm,8)\n\n\tw:=bm.dimx\n\th:=bm.dimy\n\n!equations used are:\n! u:=int(round(0.492*(b-y)+128)\n! v:=int(round(0.702*(r-y)+128)\n!b-y and r-y will be in range +/- 255\n\n\tumap:=new(list,-255..255)\n\tvmap:=new(list,-255..255)\n\tfor i:=-255 to 255 do\n\t\tumap[i]:=int(round(0.492*(i)+128))\n\t\tvmap[i]:=int(round(0.702*(i)+128))\n\tod\n\n\tubm:=bmcreate(8,w,h)\n\tvbm:=bmcreate(8,w,h)\n\tfor c:=1 to 2 do\n\t\tif c=1 then\n\t\t\toffset:=0\n\t\t\tmap:=umap\n\t\telse\n\t\t\toffset:=2\n\t\t\tmap:=vmap\n\t\tfi\n\n\t\tfor yy:=0 to h-1 do\n\t\t\tpy:=bmgetrowptr(greybm,yy)\n\t\t\tp:=bmgetrowptr(bm,yy)\t\t\t!point to bgr pixels in original\n\n\t\t\tpu:=bmgetrowptr(ubm,yy)\n\t\t\tpv:=bmgetrowptr(vbm,yy)\n\t\t\tto w do\n\t\t\t\ty:=py++^\n\t\t\t\tr:=(p+2)^\n\t\t\t\tb:=p^\n\t\t\t\tpu++^:=umap[b-y]\n!CPL =B,=Y,=PV,=VMAP.TYPE\n\t\t\t\tpv++^:=vmap[r-y]\n\n\t\t\t\tp:=p+3\n\t\t\tod\n\t\tod\n\tod\n\n!create special greyscale for u/v images, since point of zero colour\n!info has been offset to +128\n\tpal:=new(array,i32,0..256)\n\tcolour:=0\n\tpal[128]:=0\n\tfor i:=1 to 127 do\n\t\tcolour+:=0x020202\n\t\tpal [i+128]:=colour\n\t\tpal [128-i]:=colour\n\tod\n\tpal[256]:=uv_pal\n\tbmputpalette(ubm,pal)\n\tbmputpalette(vbm,pal)\n\n\tif needfree then\n\t\tbmfree(bm)\n\tfi\n\n\treturn (greybm,ubm,vbm)\nend\n\nexport func bmgetplane(bm,plane)=\n# plane is one of \"R\",\"G\",\"B\"\n# extract given plane of a 24-bit bitmaps into a single 8-bit greyscale image\n# Return new image\n\n\tincr:=bm.pixelbytes\n\tif plane.len<>1 or bm.pixelbytes<3 then\n\t\treturn nil\n\tfi\n\n\tcase asc(plane)\n\twhen 'R' then offset:=2\n\twhen 'G' then offset:=1\n\twhen 'B' then offset:=0\n\twhen 'A' then offset:=3\n\telse return nil\n\tesac\n\n\tw:=bm.dimx\n\th:=bm.dimy\n\tnewbm:=bmcreate(8,w,h)\n\n\tfor y:=0 to h-1 do\n\t\tq:=bmgetrowptr(bm,y)+offset\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tto w do\n\t\t\tp++^:=q^\n\t\t\tq:=q+incr\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nexport func bmjoinrgb(redbm,greenbm,bluebm,alphabm=nil)=\n\n\tw:=redbm.dimx\n\th:=redbm.dimy\n\n\tnewbm:=bmcreate((alphabm|32|24),w,h)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\n\t\tr:=bmgetrowptr(redbm,y)\n\t\tg:=bmgetrowptr(greenbm,y)\n\t\tb:=bmgetrowptr(bluebm,y)\n\n\t\tif alphabm then\n\t\t\ta:=bmgetrowptr(alphabm,y)\n\t\t\tto w do\n\t\t\t\tp++^:=b++^\n\t\t\t\tp++^:=g++^\n\t\t\t\tp++^:=r++^\n\t\t\t\tp++^:=a++^\n\t\t\tod\n\t\telse\n\t\t\tto w do\n\t\t\t\tp++^:=b++^\n\t\t\t\tp++^:=g++^\n\t\t\t\tp++^:=r++^\n\t\t\tod\n\t\tfi\n\tod\n\n\treturn newbm\nend\n\nexport func bmjoinyuv(ybm,ubm,vbm)=\n# combine y, u, v separations into a single rgb image\n# return new bitmap, or nil\n\n\tif ybm.pixelbits<>8 then\n\t\treturn nil\n\tfi\n\n\tw:=ybm.dimx\n\th:=ybm.dimy\n\n\tv1425map:=new(list,0..255)\n\tv726map:=new(list,0..255)\n\tu395map:=new(list,0..255)\n\tu2032map:=new(list,0..255)\n\n\tfor i:=0 to 255 do\n\t\tv1425map[i]:=int(round(1.425*(i-128)))\n\t\tv726map[i]:=int(round(0.726*(i-128)))\n\t\tu395map[i]:=int(round(0.395*(i-128)))\n\t\tu2032map[i]:=int(round(2.032*(i-128)))\n\tod\n\n\tnewbm:=bmcreate(24,w,h)\n\n\tfor yy:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,yy)\n\t\tqy:=bmgetrowptr(ybm,yy)\n\t\tqu:=bmgetrowptr(ubm,yy)\n\t\tqv:=bmgetrowptr(vbm,yy)\n\n!\t\tto w do\n\t\tFOR X:=0 TO W-1 DO\n\t\t\ty:=qy++^\n\t\t\tr:=y+v1425map[qv^]\n\t\t\tg:=y-u395map[qu^]-v726map[qv^]\n\t\t\tb:=y+u2032map[qu^]\n\t\t\t++qu\n\t\t\t++qv\n\t\t\tp++^:=clamp(b,0,255)\n\t\t\tp++^:=clamp(g,0,255)\n\t\t\tp++^:=clamp(r,0,255)\n\t\tod\n\tod\n\treturn newbm\nend\n\nexport func bmblur(bm,n)=\n\tcase bm.pixelbits\n\twhen 8 then\n\t\treturn blur8(bm,n)\n\twhen 24 then\n\t\treturn blur24(bm,n)\n\twhen 32 then\n\t\treturn blur32(bm,n)\n\tesac\n\treturn nil\nend\n\nfunc blur8(bm,n)=\n\tshift:=shifts{n,1}\n\n\tnewbm:=bmdupl(bm)\n\tiblurhoz8(newbm,n)\n\n\tnewbm2:=rotleft90_8(newbm)\n\tiblurhoz8(newbm2,n)\n\n\tnewbm3:=rotright90_8(newbm2)\n\tbmfree(newbm)\n\tbmfree(newbm2)\n\n\tbmduplpalette(newbm3,bm)\n\treturn newbm3\nend\n\nfunc blur24(bm,n)=\n\t(r,g,b):=bmsplittorgb(bm)\n\n\tr2:=bmblur(r,n)\n\tg2:=bmblur(g,n)\n\tb2:=bmblur(b,n)\n\n\tnewbm:=bmjoinrgb(r2,g2,b2)\n\tbmfree(r2)\n\tbmfree(g2)\n\tbmfree(b2)\n\n\treturn newbm\nend\n\nfunc blur32(bm,n)=\nreturn bmunimpl(\"blur32\")\nend\n\nproc iblurhoz8(bm,n)=\n\tshift:=shifts{n,1}\n\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(bm,y)\n!\t\tblurhelper(w-n-1, n, shift, p)\n\n\t\tto w-n-1 do\n\t\t\tsum:=0\n\t\t\tq:=p\n\t\t\tto n do\n\t\t\t\tsum+:=q++^\n\t\t\tod\n\t\t\tp++^:=sum>>shift\n\t\tod\n\tod\nend\n\nproc blurhelper(m, n, shift, p)=\n\tvar sum\n\tvar q\n\n\tto m do\n\t\tsum:=0\n\t\tq:=p\n\t\tto n do\n\t\t\tsum+:=q++^\n\t\tod\n\t\tp++^:=sum>>shift\n\tod\nend\n\nfunc blurhoz24(bm,n)=\nreturn bmunimpl(\"blurhoz24\")\nend\n\nfunc blurhoz32(bm,n)=\nreturn bmunimpl(\"blurhoz32\")\nend\n\nexport func bmsharpen(bm,n=0)=\n\tcase bm.pixelbits\n\twhen 8 then\n\t\treturn sharpen8(bm,n)\n\twhen 24 then\n\t\treturn sharpen24(bm,n)\n\twhen 32 then\n\t\treturn sharpen32(bm,n)\n\tesac\n\treturn nil\nend\n\nexport func sharpen8(bm,n)=\n!blur in-place horizontally by averaging each set of n pixels\n!n must be multiple of 2 from 2 to 64\n!return new modified image\n\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tnewbm:=bmdupl(bm)\n\n\tfor y:=1 to h-2 do\n\t\tp:=bmgetptr(newbm,1,y)\n\n\t\tq:=bmgetptr(bm,1,y-1)\n\t\tr:=bmgetptr(bm,1,y)\n\t\ts:=bmgetptr(bm,1,y+1)\n\n\t\tto w-2 do\n!\t\t\tabcdefghij\n\t\t\ta:=(q-1)^\n\t\t\tb:=q^\n\t\t\tc:=(q+1)^\n\t\t\td:=(r-1)^\n\t\t\te:=r^\n\t\t\tf:=(r+1)^\n\t\t\tg:=(s-1)^\n\t\t\th:=s^\n\t\t\ti:=(s+1)^\n\n! a b c\n! d e f\n! g h i\n!\t\t\tsum:=e*4-b-d-f-h\n!\t\t\tp^:=clamp(p^+sum%4,0,255)\n\n\t\t\tsum:=e*8-a-b-c-d-f-g-h-i\n\t\t\tp^:=clamp(p^+sum%8,0,255)\n\n!\t\t\tsum:=e*4+c+g+i-2*(b+d+f+h)\n!\t\t\tp^:=clamp(p^+sum%4,0,255)\n\n\t\t\t++p\n\t\t\t++q\n\t\t\t++r\n\t\t\t++s\n\t\tod\n\tod\n\n\treturn newbm\n\nend\n\nexport func sharpen24(bm,n)=\n\t(r,g,b):=bmsplittorgb(bm)\n\n\tr2:=bmsharpen(r,n)\n\tg2:=bmsharpen(g,n)\n\tb2:=bmsharpen(b,n)\n\n\tnewbm:=bmjoinrgb(r2,g2,b2)\n\tbmfree(r2)\n\tbmfree(g2)\n\tbmfree(b2)\n\n\treturn newbm\nend\n\nexport func sharpen32(bm,n)=\nreturn bmunimpl(\"bmsharpen32\")\nend\n\nfunc getlumtables=\n\trmap:=makescalemap(0.299)\n\tgmap:=makescalemap(0.587)\n\tbmap:=makescalemap(0.111)\n\treturn (rmap, gmap, bmap)\nend\n",
(u64)"!!Virtual keycodes\nexport const vklbutton=1\t\t!note these are physical not logical buttons\nexport const vkrbutton=2\nexport const vkmbutton=4\t\t!middle button is correct\nexport const vkbackspace=8\nexport const vktab=9\nexport const vkclear=12\nexport const vkenter=13\nexport const vkshift=16\nexport const vkctrl=17\nexport const vkalt=18\nexport const vkbreak=19\nexport const vkcapslock=20\n!export const vkrshift=21\nexport const vkrctrl=22\n!export const vkralt=23\nexport const vkinslock=24\nexport const vkescape=27\nexport const vkspace=32\nexport const vkpageup=33\nexport const vkpagedown=34\nexport const vkend=35\nexport const vkhome=36\nexport const vkleft=37\nexport const vkup=38\nexport const vkright=39\nexport const vkdown=40\nexport const vkinsert=45\nexport const vkdelete=46\nexport const vkhelp=47\nexport const vk0='0'\nexport const vka='A'\nexport const vkwindows=91\nexport const vkrightbutton=93\nexport const vknumpad0=96\t\t!96..105 = '0'..'9'\nexport const vkmul=106\nexport const vkadd=107\nexport const vksub=109\nexport const vkdecimal=110\nexport const vkdiv=111\nexport const vkf1=112\nexport const vkf2=113\nexport const vkf3=114\nexport const vkf4=115\nexport const vkf5=116\nexport const vkf6=117\nexport const vkf7=118\nexport const vkf8=119\nexport const vkf9=120\nexport const vkf10=121\nexport const vkf11=122\nexport const vkf12=123\n!export const vklsq=128\n!export const vkrsq=129\n!export const vksemi=130\n!export const vkquote=131\n!export const vkstroke=132\n!export const vkdot=133\n!export const vkcomma=134\n!export const vkbackslash=135\n!export const vkquote2=136\n!export const vkequals=137\n!export const vkminus=138\n!export const vkhash=139\nexport const vklshift=160\nexport const vkrshift=161\nexport const vklcontrol=162\nexport const vkrcontrol=163\nexport const vklalt=164\nexport const vkralt=165\n\n!oem codes\nexport const vkminus=189\nexport const vkequals=187\nexport const vklsq=219\nexport const vkrsq=221\nexport const vksemi=186\nexport const vkquote=192\nexport const vkhash=222\nexport const vkcomma=188\nexport const vkperiod=190\nexport const vkslash=191\nexport const vkbackslash=220\nexport const vkbackquote=223\n\nexport const con_black=0\nexport const con_dkblue=1\nexport const con_dkred=2\nexport const con_dkmagenta=3\nexport const con_dkgreen=4\nexport const con_dkcyan=5\nexport const con_dkyellow=6\nexport const con_dkgrey=7\nexport const con_grey=8\nexport const con_blue=9\nexport const con_red=10\nexport const con_magenta=11\nexport const con_green=12\nexport const con_cyan=13\nexport const con_yellow=14\nexport const con_white=15\n\n\nexport record winrec =\n\tvar posx,posy\n\tvar cols,rows\n\tvar fgnd,bgnd\t\t\t!default text/background colour\n\n\tvar columns\t\t\t!used when divided into columns\n\tvar itemcols\t\t\t!width of each column\n\tvar pagesize\t\t\t!columns*rows\n\n\tvar name\n\n\tvar hdata\t\t\t!pointer to data record, or is nil\nend\n\nexport var wconscreen\nexport var screencols,screenrows\n\nexport var chardata\t\t\t!string these two represent row of the console\nexport var attrdata\t\t\t!string\n\nexport var defscreenfgnd=con_black\nexport var defscreenbgnd=con_grey\nexport var rlkey=0\t\t!set by readline, when special key has been input\nexport var rlbuffer\t\t\t!contents of readline buffer when special key pressed\n\nvar cmdindex,ncmds\nvar cmdhistory\n\nexport const capsmask  = 0x8\t\t!shift states as they are in .keyshift\nexport const altmask   = 0x4\nexport const ctrlmask  = 0x2\nexport const shiftmask = 0x1\n\nexport const capsbit=3\nexport const altbit=2\nexport const ctrlbit=1\nexport const shiftbit=0\n\nvar keypending=0\nvar lastkey\nvar pendkey\nexport var hconsole, hconsolein\nvar colourpalette\n\n!export var wscreencols,wscreenrows\n!export var currbgnd=-1,currfgnd=-1\nexport var currbgnd=con_grey, currfgnd=con_black\n\n!export var screencolour=con_dkred..con_grey\n\n!export var colourmap\nexport VAR SUPPRESS=0\n\nVAR ALLCHARS\n\nproc START=\n!if iswindows() then\n!\tCPL \"WINCON INIT\"\n\t\tinit()\n!fi\n\tend\n\nproc main=\n\tinit()\n\tsettitle(\"New Title\")\n\n!keyscreentest()\n\n!W:=MAKEWIN((1,20),(20,20))\n!CLEARWIN(W)\n\n!SHOWTEXT(\"^^^^^^^^^^^^^^^^^\")\n\na:=rkey(10,20,30)\n!\tsetpos(12, 10)\n!\tprint \"***********hello\"\n!\twaitkey()\nend\n\nproc keyscreentest=\n\t(cols,rows):=(screencols, screenrows)\n\tCPL =COLS,=ROWS\n\n\trow:=rows%2\n\tcol:=cols%2\n\tch:=\"X\"\n\n\tsetcolour(6,1)\n\n\tdo\n\t\tsetpos(col,row)\n\t\tcp ch\n\t\tsetpos(col,row)\n\t\tk:=getkey().keycode\n\t\tcase k\n\t\twhen 27 then\n\t\t\texit\n\t\twhen vkleft then col:=max(1,col-1)\n\t\twhen vkright then col:=min(cols,col+1)\n\t\twhen vkup then row:=max(1,row-1)\n\t\twhen vkdown then row:=min(rows,row+1)\n\t\tesac\n\tod\n\n!waitkey()\n\nend\n\nexport func makerspoint(x,y)=\n!combine x,y into 32-bit value (rspoint)\n\treturn y<<16 ior x\nend\n\nexport proc setpos(col,row)=\n\n!!ROW+:=10\n!fprint \"\\s[{#};{#}H\",row,col\n\n\tsetconsolecursorposition(hconsole,makerspoint(col-1,row-1))\nend\n\nexport func getpos=\n\tinfo:=new(ws_console)\n\tgetconsolescreenbufferinfo(hconsole,&info)\n\treturn (info.pos.x+1,info.pos.y+1)\nend\n\nexport proc init(cols=100)=\n!static var setdimdone=0\n\n!CPL \"CONSOLE INIT-----------\"\n\n\n!\tconsolesw.init(cols)\n\tcmdhistory::=()\t!\"one\",\"two\",\"three\",\"four\")\n\tncmds:=cmdhistory.upb\n\tcmdindex:=0\n\n!screencols:=consolesw.wscreencols\n!screenrows:=consolesw.wscreenrows\n!\n\n\thconsole:=getstdhandle(-11)\n\thconsolein:=getstdhandle(-10)\n\tlastkey:=new(ws_keyevent)\n\tlastkey.repeatcount:=0\n\tpendkey:=new(ws_keyevent)\n\n\tsetdims(cols,60)\n!\tsetdims(50,20)\n\n\tgetdims()\n\n!CPL =SCREENCOLS\n\n\twconscreen:=makewin((1,1),(screencols,screenrows),defscreencolour)\n\n\tcolourpalette:=new(ws_palette16)\n\n\tsetstdpalette()\nend\n\nexport func setcursor(?visible)=\n\tcursor:=new(ws_cursor)\n\tgetconsolecursorinfo(hconsole,&cursor)\n\n\tif visible.defined then\n\t\tcursor.visible:=visible\n\t\tsetconsolecursorinfo(hconsole,&cursor)\n\tfi\n\treturn cursor.visible\nend\n\nexport proc setcolour(fgnd, ?bgnd)=\n!call with as (fgnd,bgnd) or as (fgnd..bgnd)\n\n\tif bgnd.isvoid then bgnd:=currbgnd fi\n\n\tif fgnd=currfgnd and bgnd=currbgnd then\n!\t\treturn\n\tfi\n\n\tcurrfgnd:=fgnd\n\tcurrbgnd:=bgnd\n\n\tsetconsoletextattribute(hconsole,(bgnd*16+fgnd))\nend\n\nexport proc settitle(caption)=\n\tsetconsoletitle(caption)\nend\n\nexport func getkeychar=\n!wait for any key, return single char code; as returned by C's getch()\n\treturn waitkey()\nend\n\nexport func getkey2=\n!wait for any key, return keyrec\n!includes shift key presses as discrete keys\n!use getkey() to ignore these\n\n\treturn getchx()\n\n\tk:=getchx()\t\t\t!get keyrec, encoded as int\n\n\tkey:=new(rkey)\t\t\t!convert to proper keyrec\n\tkey.charcode:=k iand 65535\n\tkey.shift:=k>>24\n\tkey.keycode:=k.[23..16]\n!CPL \"GK2:\",KEY\n\n\treturn key\nend\n\nexport func getkey=\n!calls igetkey but doesn't return shift keys as discrete key presses\n\tdo\n\t\tk:=getkey2()\n\t\tcase k.keycode\n\t\twhen vkshift,vkctrl,vkalt,vkcapslock then\n\t\telse\n\t\t\texit\n\t\tesac\n\tod\n\treturn k\nend\n\nexport func keyready=\n\treturn testkey()\nend\n\nexport proc showtext(s,?x,?y)=\n\n\tif x.defined then\n\t\tsetpos(x,y)\n\tfi\n\n\tcount:=0\n\tif s then\n\t\tif not suppress then\n\t\t\twriteconsole(hconsole,s,s.len,&count,nil)\n\t\tfi\n\tfi\nend\n\nproc setwindowsize(cols,rows)=\n\tr:=new(ws_srect)\n\tr.leftx:=0\n\tr.rightx:=cols-1\n\tr.top:=0\n\tr.bottom:=rows-1\n\tif not setconsolewindowinfo(hconsole,1,&r) then\n!\tCPL \"WINDOW ERROR 1\"\n!\tabort(\"Window error 1\")\n\tfi\nend\n\nexport proc setdims(cols,rows)=\n!set new size for console, by reinitialising\n\n\tmaxcol:=cols\n\tmaxrow:=rows\n\n\tinfo:=new(ws_console)\n\toldscreenattributes:=info.attributes\n\toldscreensize:=info.size\n\n\toldcols:=info.window.rightx-info.window.leftx+1\n\toldrows:=info.window.bottom-info.window.top+1\n\n\tIF OLDSCREENSIZE.X>COLS OR OLDSCREENSIZE.Y>ROWS THEN\t!need to reduce window size first\n\t\tsetwindowsize(oldscreensize.x min cols, oldscreensize.y min rows)\n\tfi\n\n!Set the new size of the entire (virtual) console window\n\tif setconsolescreenbuffersize(hconsole,rows<<16+cols)=0 then\n!\tabort(\"Buffer size error\")\n\tfi\n\n!now set the size of the displayed portion of it; in this case exactly the same\n!size as the buffer, with no scrollbars\n\tsetwindowsize(cols,rows)\n\n\twscreencols:=cols\n\twscreenrows:=rows\n\n!hide blinking cursor\n\tcursor:=new(ws_cursor)\n\tcursor.size:=10\n\tcursor.visible:=1\nend\n\nexport proc setpalette(index,colour)=\n!index is 0..15; colour is an rgb value bbggrr\n!updates local palette array\n!to update actual console, use writepalette\n\tcolourpalette[index]:=colour\nend\n\nexport proc writepalette=\n\tr:=new(ws_consoleex)\n\tr.recsize:=ws_consoleex.bytes\n\tX:=getconsolescreenbufferinfoex(hconsole,&r)\n\n\tr.palette:=colourpalette\n\n\tR.WINDOW.RIGHTX:=R.WINDOW.RIGHTX+1\t\t!workaround off-by-one bug\n\tR.WINDOW.BOTTOM:=R.WINDOW.BOTTOM+1\n\n\tX:=setconsolescreenbufferinfoex(hconsole,&r)\n\n!export proc READPALETTE=\n!r:=new(rconsoleex)\n!r.recsize:=rconsoleex.bytes\n!x:=getconsolescreenbufferinfoex(hconsole,&r)\n!\n!CPL \"GCSBI X=\",X\n!FOR I:=0 TO 15 DO\n! CPL I,\":\",R.PALETTE[I]:\"H\"\n!OD\n!\nend\n\nproc setstdpalette=\n!export const con_black=0\n!export const con_dkblue=1\n!export const con_dkred=2\n!export const con_dkmagenta=3\n!export const con_dkgreen=4\n!export const con_dkcyan=5\n!export const con_dkyellow=6\n!export const con_grey=7\n!export const con_dkgrey=8\n!export const con_blue=9\n!export const con_red=10\n!export const con_magenta=11\n!export const con_green=12\n!export const con_cyan=13\n!export const con_yellow=14\n!export const con_white=15\n\n!R G B\n\tcols:=(\n\t(0,\t\t0,\t\t0),\t\t\t!black\n\t(0,\t\t0,\t\t128),\t\t!dk blue\n\t(128,\t0,\t\t0),\t\t\t!dk red\n\t(128,\t0,\t\t128),\t\t!dk magenta\n\t(0,\t\t128,\t0),\t\t\t!dk green\n\t(0,\t\t128,\t128),\t\t!dk cyan\n\t(128,\t128,\t0),\t\t\t!dk yellow\n\t(128,\t128,\t128),\t\t!dk grey\n\t(192,\t192,\t192),\t\t!grey\n\t(0,\t\t0,\t\t192),\t\t!blue\n\t(192,\t0,\t\t0),\t\t\t!red\n\t(192,\t0,\t\t192),\t\t!magenta\n\t(0,\t\t192,\t0),\t\t\t!green\n\t(0,\t\t192,\t192),\t\t!cyan\n\t(192,\t192,\t0),\t\t\t!yellow\n\t(255,\t255,\t255))\t\t!white\n\n\tfor i,c in cols do\n\t\tsetpalette(i-1,c[3]<<16+c[2]<<8+c[1])\n\tod\n!CPL \"WRITEPAL\"; WAITKEY()\n\twritepalette()\nend\n\nproc getdims=\n\tinfo:=new(ws_console)\n\tgetconsolescreenbufferinfo(hconsole,&info)\n\n\tscreencols:=info.window.rightx-info.window.leftx+1\n\tscreenrows:=info.window.bottom-info.window.top+1\nend\n\nexport func getchx=\n\tconst rightaltmask\t= 1\t\t\t\t!masks used by .controlkeystate\n\tconst leftaltmask\t= 2\n\tconst leftctrlmask\t= 8\n\tconst rightctrlmask\t= 4\n\tconst shiftmask\t\t= 16\n\tconst capsmask\t\t= 128\n\tconst scrollmask\t= 64\n\n\tconst leftctrlbit\t= 3\t\t!for c.l.p\n\tconst rightctrlbit\t= 2\n\n\tif keypending then\n\t\tlastkey:=pendkey\n\t\tkeypending:=0\n\telse\n\t\tif lastkey.repeatcount=0 then\n\t\t\trepeat\n\t\t\t\tcount:=0\n\t\t\t\treadconsoleinput(hconsolein,&lastkey,1,&count)\n\t\t\tuntil lastkey.eventtype=1 and lastkey.keydown=1\n\t\tfi\n\tfi\n\n\taltdown\t\t:= (lastkey.controlkeystate iand (leftaltmask ior rightaltmask)|1|0)\n\tctrldown\t:= (lastkey.controlkeystate iand (leftctrlmask ior rightctrlmask)|1|0)\n\tshiftdown\t:= (lastkey.controlkeystate iand shiftmask|1|0)\n\tcapslock\t:= (lastkey.controlkeystate iand capsmask|1|0)\n\n\tlastkey.repeatcount:=lastkey.repeatcount-1\n\n\tcharcode:=lastkey.asciichar\n\tkeycode:=lastkey.virtualkeycode iand 255\n\n!for keycodes in range 186 to 223, which are all stand-alone punctuation keys, I might\n!wish to set charcode to the appropriate printed char code (currently charcode will be\n!zero, and keyboard handlers need to detect keycodes such as vkequals)\n!\n\tif altdown and ctrldown and charcode=166 then\n\t\taltdown:=ctrldown:=0;\n\telse\n\t\tif altdown or ctrldown then\n\t\t\tcharcode:=0;\n\t\t\tif keycode>='A' and keycode<= 'Z' then\n\t\t\t\tcharcode:=keycode-'@'\n\t\t\tfi\n\t\tfi\n\tfi\n\n\tkeyshift:=capslock<<3 ior altdown<<2 ior ctrldown<<1 ior shiftdown\n\n\tkeyshift.[4]:=lastkey.controlkeystate.[leftctrlbit]\t\t!for c.l.p\n\tkeyshift.[5]:=lastkey.controlkeystate.[rightctrlbit]\n\n!need to be more ruthless with how keycoded and charcodes are combined.\n!More combinations need to have only charcode or keycode set, and the other zero\n\n\tswitch charcode\n\twhen 'A'..'Z','a'..'z','0'..'9' then\n\twhen 8,9,13,27,' ','`' then\n\twhen 0 then\t\t\t\t!already key-only event\n\telse\n\t\tkeycode:=0\n\tend switch\n\n\treturn rkey(charcode,keycode,keyshift)\n\nend\n\nexport proc flushkeyboard=\n\tflushconsoleinputbuffer(hconsolein)\nend\n\nexport proc w_writeconsolerow(text, attributes, length, row)=\n\tbuffersize:=1<<16+length\n\tcoord:=0\n\n\tbox:=ws_srect(0,row-1,length-1,row-1)\n\n\tbuffer:=new(array,ws_charinfo,length)\n\n\tfor i:=1 to length do\n\t\tx:=new(ws_charinfo)\n\t\tx.asciichar  := text.[i]\n\t\tx.attributes := attributes.[i]\n!\tx.attributes := attributes.[1]\n\t\tbuffer[i]:=x\n\tod\n!CPL \"HELLO\",text; WAITKEY()\n\n\twriteconsoleoutputa(hconsole, &buffer,buffersize,coord,&box)\nend\n\nexport func setclipboard(s)=\n!copy text to the Windows clipboard\n!return status 0 if no clipboard o/p was possible\n\tconst ghnd=2 + 0x40\n\n\tif openclipboard(nil)=0 then\n\t\treturn 0\n\tfi\n\n\temptyclipboard()\n\n\tif s<>\"\" then\n\t\th:=globalalloc(ghnd,s.len+1)\n\t\tp:=globallock(h)\n\n\t\tmemcpy(p,&s,s.len+1)\n\tglobalunlock(h)\n\t\tsetclipboarddata(cf_text,h)\n\tfi\n\n\tcloseclipboard()\n\n\treturn 1\nend\n\nexport func getclipboard=\n!copy text from Windows clipboard\n!return clipboard text, or \"\" when error or not text data available\n\n\tif openclipboard(nil)=0 then\n\t\treturn \"\"\n\tfi\n\n\thtext:=getclipboarddata(cf_text)\n\n\tif not htext then\n\t\treturn \"\"\n\tfi\n\n\tsize:=globalsize(htext)\t\t!should include zero terminator\n\n\tp:=globallock(htext)\n\ts:=makestr(p,size-1)\t\t!assignment should copy the string data\n\n\tglobalunlock(htext)\n\n\tcloseclipboard()\n\treturn s\nend\n\nexport func makewin(pos, dims, fgnd=con_black,bgnd=con_grey,name=\"Anon\")=\n!export func makewin(pos, dims, ?colour)=\n\n\tw:=new(winrec)\n\tw.posx:=pos[1]\n\tw.posy:=pos[2]\n\tw.cols:=dims[1]\n\tw.rows:=dims[2]\n\tw.columns:=1\n\tif dims.len>=3 then\n\t\tw.columns:=dims[3]\n\tfi\n\n!CPL =POS,=DIMS,=W.COLUMNS\n\n\tw.itemcols:=w.cols%w.columns\n\tw.pagesize:=w.rows*w.columns\n\tw.hdata:=nil\n\n\tw.fgnd:=fgnd\n\tw.bgnd:=bgnd\n\tw.name:=name\n\n\treturn w\nend\n\nexport proc clearwin(w)=\n!clear region used by listbox\n!can clear multi-columns at once\n\tspaces:=\" \"*w.cols\n\n\tsetcolour(w.fgnd,w.bgnd)\n\tfor i:=1 to w.rows do\n\t\tshowtext(spaces,w.posx,w.posy+i-1)\n\tod\n\tsetpos(w.posx,w.posy)\nend\n\nexport proc wsetpos(w,col,row)=\n\tsetpos(w.posx+col-1,w.posy+row-1)\nend\n\nexport proc wshowtext(w,s,?col,?row)=\n\tif col.defined then\n\t\tshowtext(s,w.posx+col-1,w.posy+row-1)\n\telse\n\t\tshowtext(s)\n\tfi\nend\n\nexport proc wshowtext_b(w,s,col,fgnd,bgnd)=\n!version of wshowtext that dumps into char/attr buffer.\n!w is used for absolute column number\n\n\tlength:=s.len\n\toffset:=w.posx-1\t!hoz offset\n\n\tchardata.[(col+offset)..(col-1+length+offset)]:=s\n\n!\tattr:=consolesw.colourmap[bgnd]<<4+consolesw.colourmap[fgnd]\n\tattr:=bgnd<<4+fgnd\n\n\tattrdata.[(col+offset)..(col-1+length+offset)]:=chr(attr)*length\nend\n\nexport proc updateconsolerow(row)=\n!write out latest contents to chardata/attrdata to console\n!this represents an entire composite wlineno+wvgap+wedit row, for given row within wedit\n!etc\n\tw_writeconsolerow(chardata,attrdata,screencols,row)\nend\n\nexport func getkeyname(key)=\n\tcase key.keycode\n\twhen vkleft then name:=\"left\"\n\twhen vkright then name:=\"right\"\n\twhen vkup then name:=\"up\"\n\twhen vkdown then name:=\"down\"\n\twhen vkpageup then name:=\"pageup\"\n\twhen vkpagedown then name:=\"pagedown\"\n\twhen vkhome then name:=\"home\"\n\twhen vkend then name:=\"end\"\n\twhen vkinsert then name:=\"insert\"\n\twhen vkdelete then name:=\"delete\"\n\twhen vktab then name:=\"tab\"\n\twhen vkescape then name:=\"escape\"\n\twhen vkbackspace then name:=\"backspace\"\n\twhen vkenter then name:=\"enter\"\n\twhen vkf1..vkf12 then name:=\"f\"+tostr(key.keycode-vkf1+1)\n\twhen vkspace then name:=\"space\"\n\telse\n\t\tif key.charcode in [1..26] then\t!ctrl code\n\t\t\tname:=chr(key.charcode+'a'-1)\n\t\telsif key.charcode in ['!','\"','\xA3','$','%','^','&','*','(',')','-','_','+','=','[',']',\n\t\t'{','}',':',';','\\'','@','~','#','<','>',',','.','/','\xAC','\xA6','|','\\\\','?'] then\n\t\t\tname:=chr(key.charcode)\n\t\t\tkey.shift iand:=inot shiftmask\t\t!ignore any shift press needed to get char\n\n\t\telsif key.keycode in ['A'..'Z','0'..'9'] then\n\t\t\tif (key.shift iand (ctrlmask ior altmask))=0 then\n\t\t\t\tname:=chr(key.charcode)\n\t\t\t\tkey.shift iand:=inot shiftmask\n\t\t\telse\n\t\t\t\tname:=convlc(chr(key.keycode))\n\t\t\tfi\n\t\telsif key.keycode in (186..223) then\n\t\t\tcase key.keycode\n\t\t\twhen vkminus then name:=\"-\"\n\t\t\twhen vkequals then name:=\"=\"\n\t\t\twhen vklsq then name:=\"[\"\n\t\t\twhen vkrsq then name:=\"]\"\n\t\t\twhen vksemi then name:=\";\"\n\t\t\twhen vkquote then name:=\"'\"\n\t\t\twhen vkhash then name:=\"#\"\n\t\t\twhen vkcomma then name:=\",\"\n\t\t\twhen vkperiod then name:=\".\"\n\t\t\twhen vkslash then name:=\"/\"\n\t\t\twhen vkbackslash then name:=\"\\\\\"\n\t\t\twhen vkbackquote then name:=\"`\"\n\t\t\telse\n\t\t\t\treturn \"?\"\n\t\t\tesac\n\t\telse\n\t\t\treturn \"?\"\n\t\tfi\n\tesac\n\n\tprefix::=\"*\"\n\tif key.shift iand shiftmask then prefix+:=\"s\" fi\n\tif key.shift iand ctrlmask then prefix+:=\"c\" fi\n\tif key.shift iand altmask then prefix+:=\"a\" fi\n\treturn prefix+name\n\nend\n\nexport func keynametokey(name)=\n!given a key name in the format \"*...\", reconstruct an rkey record, and return that\n\tcharcode:=shift:=keycode:=0\n\n\tname:=rightstr(name,-1)\t\t!get rid of \"*\"\n\n\tif name.len=1 then\t\t!simple printable key, no shifts\n\t\tcharcode:=asc(name)\n\t\tgoto simplekey\n\n\telse\t\t\t\t!any letters s,c,a on left indicate a modifier\n\t\twhile name.len>1 do\n\t\t\tcase leftstr(name)\n\t\t\twhen \"s\" then\n\t\t\t\tshift ior:=shiftmask\n\t\t\t\tname:=rightstr(name,-1)\n\t\t\twhen \"c\" then\n\t\t\t\tshift ior:=ctrlmask\n\t\t\t\tname:=rightstr(name,-1)\n\t\t\twhen \"a\" then\n\t\t\t\tshift ior:=altmask\n\t\t\t\tname:=rightstr(name,-1)\n\t\t\telse\n\t\t\t\texit\n\t\t\tesac\n\t\tod\n\n\t\tcase name\n\t\twhen \"left\" then keycode:=vkleft\n\t\twhen \"right\" then keycode:=vkright\n\t\twhen \"up\" then keycode:=vkup\n\t\twhen \"down\" then keycode:=vkdown\n\t\twhen \"pageup\" then keycode:=vkpageup\n\t\twhen \"pagedown\" then keycode:=vkpagedown\n\t\twhen \"home\" then keycode:=vkhome\n\t\twhen \"end\" then keycode:=vkend\n\t\twhen \"insert\" then keycode:=vkinsert\n\t\twhen \"delete\" then keycode:=vkdelete\n\t\twhen \"tab\" then keycode:=charcode:=vktab\n\t\twhen \"escape\" then keycode:=vkescape\n\t\twhen \"backspace\" then keycode:=charcode:=vkbackspace\n\t\twhen \"enter\" then keycode:=charcode:=vkenter\n\t\twhen \"space\" then keycode:=charcode:=vkspace\n\t\telse\n\t\t\tif name.len>=2 and leftstr(name)=\"f\" then\t!function key\n\t\t\t\tkeycode:=vkf1+strtoval(rightstr(name,-1))-1\n\t\t\telsif name.len=1 then\t\t\t\t!ordinary key, but with shifts\n\tsimplekey:\n\t\t\t\tc:=asc(name)\n\t\t\t\tcase c\n\t\t\t\twhen ['A'..'Z'] then\n\t\t\t\t\tkeycode:=c\n\t\t\t\twhen ['a'..'z'] then\n\t\t\t\t\tkeycode:=c-' '\n\t\t\t\twhen ['0'..'9'] then\n\t\t\t\t\tkeycode:=c\n\t\t\t\twhen '-','_' then keycode:=vkminus\n\t\t\t\twhen '=','+' then keycode:=vkequals\n\t\t\t\twhen '[','{' then keycode:=vklsq\n\t\t\t\twhen ']','}' then keycode:=vkrsq\n\t\t\t\twhen ';',':' then keycode:=vksemi\n\t\t\t\twhen '\\'','@' then keycode:=vkquote\n\t\t\t\twhen ',','<' then keycode:=vkcomma\n\t\t\t\twhen '.','>' then keycode:=vkperiod\n\t\t\t\twhen '/','?' then keycode:=vkslash\n\t\t\t\twhen '\\\\','|' then keycode:=vkbackslash\n\t\t\t\twhen '`','\xAC' then keycode:=vkbackquote\n\t\t\t\twhen '#','~' then keycode:=vkhash\n\t\t\t\twhen '!' then keycode:='1'\n\t\t\t\twhen '\"' then keycode:='2'\n\t\t\t\twhen '\xA3' then keycode:='3'\n\t\t\t\twhen '$' then keycode:='4'\n\t\t\t\twhen '%' then keycode:='5'\n\t\t\t\twhen '^' then keycode:='6'\n\t\t\t\twhen '&' then keycode:='7'\n\t\t\t\twhen '*' then keycode:='8'\n\t\t\t\twhen '(' then keycode:='9'\n\t\t\t\twhen ')' then keycode:='0'\n\t\t\t\telse\n\t\t\t\t\tpcerror(\"keynametokey\")\n\t\t\t\tend\n\t\t\tfi\n\t\tesac\n\tfi\n\n\tif shift iand (altmask ior ctrlmask) then\n\t\tcharcode:=0\n\t\tif keycode in 'A'..'Z' then\n\t\t\tcharcode:=keycode-'@'\n\t\tfi\n\tfi\n\n\tkey:=new(rkey)\t\t\t!convert to proper keyrec\n\tkey.charcode:=charcode\n\tkey.shift:=shift\n\tkey.keycode:=keycode\n\treturn key\nend\n\nexport proc clearscreen(?bgnd,?fgnd)=\n\nif bgnd.isvoid then bgnd:=defscreenbgnd fi\nif fgnd.isvoid then fgnd:=defscreenfgnd fi\nsetcolour(fgnd,bgnd)\n\nfor i:=1 to screenrows do\n\tsetpos(1,i)\n\tshowtext(\" \"*screencols)\n!\tshowtext(\"*\"*screencols)\nod\nsetpos(1,1)\nend\n\nexport func readline(?cmdline,donewline=1)=\n!this func doesn't handle tabs properly\n!would need to maintain 2 buffers, one with tabs translated to spaces\n!or convert tabs to another char which is translated back to tabs on exit\n!return with input buffer set to the line, but also returns the complete line\n!newline=1 to end with a newline, 0 to leave it\n\n!readln\n!return\n\n\tbuffer:=\"\"\n\tnchars:=0\n!congetpos()\n\n!NOTE: getpos is dodgy using TERMCON; MAY NEED CALLER TO SPECIFY START POINT\n\t(startx,starty):=(getpos())\n\n\tpos:=0\t\t!with nchars shown, pos can be 0 to nchars\n\n\treenter:\n\tif cmdline.defined and cmdline<>\"\" then\n\t\tbuffer:=cmdline\n\treenter2:\n\t\tpos:=nchars:=buffer.len\n\tfi\n\n\tdo\n! print \"_\"\n\t\trlkey:=0\t\t\t!normal input starts with \"*\" will expect rlkey to be a keyrec\n\t\tsetpos(startx,starty)\n\t\tprint buffer\n\t\tsetpos(startx+pos,starty)\n\n\t\tkey:=getkey()\n\t\tkeycode:=key.keycode\n\t\tkeyshift:=key.shift\n\n\t\tcase keycode\n\t\twhen vkpageup,vkpagedown,vkup,vkdown,vkinsert,vkf1..vkf12 then\n\n\tdospecial:\n\t\trlbuffer:=buffer\n\t\t\toldbufferlen:=buffer.len\t\t!to help erase old buffer\n\t\t\tbuffer:=getkeyname(key)\n\t\t\trlkey:=key\t\t\t\t!allow caller to use key code rather than name\n\t\t\texit\n\n\t\twhen vkleft then\n\t\t\tif buffer=\"\" then goto dospecial fi\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\n\t\t\tif pos>0 then\n\t\t\t\t--pos\n\t\t\tfi\n\n\t\twhen vkhome then\n\t\t\tif buffer=\"\" then goto dospecial fi\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\t\t\tpos:=0\n\n\t\twhen vkend then\n\t\t\tif buffer=\"\" then goto dospecial fi\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\t\t\tpos:=nchars\n\n\t\twhen vkright then\n\t\t\tif buffer=\"\" then goto dospecial fi\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\t\t\tif pos<nchars then\n\t\t\t\t++pos\n\t\t\tfi\n\n\t\twhen vkenter then\n\n!  println\n\t\t\texit\n\n\t\twhen vkbackspace then\n\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\t\t\tif nchars then\n\t\t\t\tsetpos(startx,starty)\n\t\t\t\tprint \" \"*buffer.len\n\n\t\t\t\tcase pos\n\t\t\t\twhen 0 then\t\t\t!not allowed\n\t\t\t\twhen nchars then\t\t!at end\n\t\t\t\t\tbuffer:=leftstr(buffer,-1)\n\t\t\t\t\t--nchars\n\t\t\t\t\t--pos\n\t\t\t\telse\t\t\t\t!in middle\n\t\t\t\t\tbuffer:=leftstr(buffer,pos-1)+rightstr(buffer,-(pos))\n\t\t\t\t\t--nchars\n\t\t\t\t\t--pos\n\t\t\t\tesac\n\n\t\t\tfi\n\n\t\twhen vkdelete then\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\t\t\tif nchars and nchars=pos then\n\t\t\t\tgoto delline\n\t\t\tfi\n\t\t\tif nchars=0 then\n\t\t\t\tgoto dospecial\n\t\t\tfi\n\t\t\tif nchars then\n!CPL \"\\NNCHARS\",=NCHARS,++CCC,=POS,\"\\N\"\n\t\t\t\tsetpos(startx,starty)\n\t\t\t\tprint \" \"*buffer.len\n\n\t\t\t\tcase pos\n\t\t\t\twhen nchars then\t\t!not allowed\n!\t\t\twhen 0 then\t\t\t!at start\n!\t\t\t\tbuffer:=leftstr(buffer,-1)\n!\t\t\t\t--nchars\n\t\t\t\telse\t\t\t\t!in middle\n\t\t\t\t\tbuffer:=leftstr(buffer,pos)+rightstr(buffer,-(pos+1))\n\t\t\t\t\t--nchars\n!    --pos\n\t\t\t\tesac\n\n\t\t\tfi\n\n\t\twhen vkescape then\n\t\t\tif nchars=0 then\n\t\t\t\tgoto dospecial\n!   oldbufferlen:=buffer.len\n!   buffer:=\"*esc\"\n!   exit\n\t\t\tfi\n\tdelline:\n\t\t\tsetpos(startx,starty)\n\t\t\tprint \" \"*buffer.len\n\n\t\t\tbuffer:=\"\"\n\t\t\tnchars:=pos:=0\n\n\t\twhen vktab then\n\t\t\tgoto normalkey\n\n\t\telse\n\tnormalkey:\n\t\t\tif (key.charcode>=' ' or key.charcode=9) then\n\t\t\t\tif pos=0 then\n\t\t\t\t\tbuffer:=chr(key.charcode)+buffer\n\t\t\t\telsif pos=nchars then\n\t\t\t\t\tbuffer:=buffer+chr(key.charcode)\n\t\t\t\telse\n\t\t\t\t\tbuffer:=leftstr(buffer,pos)+chr(key.charcode)+rightstr(buffer,-(pos))\n\t\t\t\tfi\n\t\t\t\t++nchars\n\t\t\t\t++pos\n\t\t\telse\n\t\t\t\tGOTO DOSPECIAL\n\t\t\t\tprint \"<\",keycode,key.charcode,\">\"\n\t\t\tfi\n\n\t\tesac\n\tod\n\n\tcase buffer\n\twhen \"*cup\",\"*cdown\" then\n\t\tif ncmds then\n\t\t\tsetpos(startx,starty)\n\t\t\tprint \" \"*oldbufferlen\n\n\t\t\tif cmdindex=0 then\t\t!get started on last\n\t\t\t\tcmdline:=cmdhistory[ncmds]\n\t\t\t\tcmdindex:=ncmds\n\t\t\t\tgoto reenter\n\t\t\tfi\n\n\t\t\tif buffer=\"*cup\" and cmdindex>1 then\n\t\t\t\t--cmdindex\n\t\t\telsif buffer=\"*cdown\" and cmdindex<ncmds then\n\t\t\t\t++cmdindex\n\t\t\tfi\n\t\t\tcmdline:=cmdhistory[cmdindex]\n\t\t\tgoto reenter\n\t\tfi\n\t\tbuffer:=\"\"\n\t\tgoto reenter2\n\tesac\n\n\tif buffer.len>1 and leftstr(buffer)<>\"*\" then\n\t\tif ncmds=0 or cmdhistory[ncmds]<>buffer then\n\t\t\tcmdhistory[++ncmds]:=buffer\n\t\tfi\n\t\tcmdindex:=0\n\tfi\n\n\tif donewline then println fi\n\n\treturn sreadln(buffer)\nend\n\nexport proc wsetcolumns(w,columns)=\n\tw.columns:=columns\n\tw.itemcols:=w.cols%w.columns\n\tw.pagesize:=w.rows*w.columns\nend\n\n",
(u64)"!Windows win32 constants\n\nglobal const driverversion =  0\nglobal const technology =  2\nglobal const horzsize =  4\nglobal const vertsize =  6\nglobal const horzres =  8\nglobal const vertres =  10\nglobal const bitspixel =  12\nglobal const bitplanes =  14\nglobal const numbrushes =  16\nglobal const numpens =  18\nglobal const nummarkers =  20\nglobal const numfonts =  22\nglobal const numcolours =  24\nglobal const pdevicesize =  26\nglobal const curvecaps =  28\nglobal const linecaps =  30\nglobal const polygonalcaps =  32\nglobal const textcaps =  34\nglobal const clipcaps =  36\nglobal const rastercaps =  38\nglobal const aspectx =  40\nglobal const aspecty =  42\nglobal const aspectxy =  44\nglobal const logpixelsx =  88\nglobal const logpixelsy =  90\nglobal const sizepalette =  104\nglobal const numreserved =  106\nglobal const colourres =  108\nglobal const physicalwidth =  110\nglobal const physicalheight =  111\nglobal const physicaloffsetx =  112\nglobal const physicaloffsety =  113\nglobal const scalingfactorx =  114\nglobal const scalingfactory =  115\nglobal const fw_dontcare =  0\nglobal const fw_thin =  100\nglobal const fw_extralight =  200\nglobal const fw_ultralight =  200\nglobal const fw_light =  300\nglobal const fw_normal =  400\nglobal const fw_regular =  400\nglobal const fw_medium =  500\nglobal const fw_semibold =  600\nglobal const fw_demibold =  600\nglobal const fw_bold =  700\nglobal const fw_extrabold =  800\nglobal const fw_ultrabold =  800\nglobal const fw_heavy =  900\nglobal const fw_black =  900\nglobal const cs_vredraw =  1\nglobal const cs_hredraw =  2\nglobal const cs_keycvtwindow =  4\nglobal const cs_dblclks =  8\nglobal const cs_owndc =  32\nglobal const cs_classdc =  64\nglobal const cs_parentdc =  128\nglobal const cs_nokeycvt =  256\nglobal const cs_noclose =  512\nglobal const cs_savebits =  2048\nglobal const cs_bytealignclient =  4096\nglobal const cs_bytealignwindow =  8192\nglobal const cs_publicclass =  16384\nglobal const sw_hide =  0\nglobal const sw_shownormal =  1\nglobal const sw_normal =  1\nglobal const sw_showminimized =  2\nglobal const sw_showmaximized =  3\nglobal const sw_maximize =  3\nglobal const sw_shownoactivate =  4\nglobal const sw_show =  5\nglobal const sw_minimize =  6\nglobal const sw_showminnoactive =  7\nglobal const sw_showna =  8\nglobal const sw_restore =  9\nglobal const sw_showdefault =  10\nglobal const sw_max =  10\nglobal const pm_noremove =  0\nglobal const pm_remove =  1\nglobal const pm_noyield =  2\nglobal const wm_null =  0\nglobal const wm_create =  1\nglobal const wm_destroy =  2\nglobal const wm_move =  3\nglobal const wm_size =  5\nglobal const wm_activate =  6\nglobal const wa_inactive =  0\nglobal const wa_active =  1\nglobal const wa_clickactive =  2\nglobal const wm_setfocus =  7\nglobal const wm_killfocus =  8\nglobal const wm_enable =  10\nglobal const wm_setredraw =  11\nglobal const wm_settext =  12\nglobal const wm_gettext =  13\nglobal const wm_gettextlength =  14\nglobal const wm_paint =  15\nglobal const wm_close =  16\nglobal const wm_queryendsession =  17\nglobal const wm_quit =  18\nglobal const wm_queryopen =  19\nglobal const wm_erasebkgnd =  20\nglobal const wm_syscolourchange =  21\nglobal const wm_endsession =  22\nglobal const wm_showwindow =  24\nglobal const wm_wininichange =  26\nglobal const wm_devmodechange =  27\nglobal const wm_activateapp =  28\nglobal const wm_fontchange =  29\nglobal const wm_timechange =  30\nglobal const wm_cancelmode =  31\nglobal const wm_setcursor =  32\nglobal const wm_mouseactivate =  33\nglobal const wm_childactivate =  34\nglobal const wm_queuesync =  35\nglobal const wm_getminmaxinfo =  36\nglobal const wm_drawitem =  43\nglobal const wm_notify =  78\nglobal const wm_contextmenu =  123\nglobal const wm_geticon =  127\nglobal const wm_seticon =  128\nglobal const wm_nchittest =  132\n\nglobal const wm_nclbuttondown\t= 161\nglobal const wm_nclbuttonup\t= 162\nglobal const wm_nclbuttondblclick\t= 163\n\nglobal const wm_menurbuttonup\t= 290\n\nglobal const wm_parentnotify =  528\nglobal const wm_dropfiles =  563\nglobal const wm_enteridle =  289\nglobal const wm_user =  1024\nglobal const wm_mdicreate =  544\nglobal const wm_mdidestroy =  545\nglobal const wm_mdiactivate =  546\nglobal const wm_mdirestore =  547\nglobal const wm_mdinext =  548\nglobal const wm_mdimaximize =  549\nglobal const wm_mditile =  550\nglobal const wm_mdicascade =  551\nglobal const wm_mdiiconarange =  552\nglobal const wm_mdigetactive =  553\nglobal const wm_mdisetmenu =  560\nglobal const wm_entersizemove =  561\nglobal const wm_exitsizemove =  562\nglobal const wm_mdirefrshmenu =  564\nglobal const wm_lbuttondblclk =  515\nglobal const wm_rbuttondblclk =  518\nglobal const wm_lbuttondown =  513\nglobal const wm_rbuttondown =  516\nglobal const wm_mbuttondown =  519\nglobal const wm_mousemove =  512\nglobal const wm_lbuttonup =  514\nglobal const wm_rbuttonup =  517\nglobal const wm_mbuttonup =  520\nglobal const wm_mbuttondblclk =  521\nglobal const wm_mousewheel =  522\nglobal const snd_filename =  131072\nglobal const snd_async =  1\nglobal const dt_singleline =  32\nglobal const dt_centre =  1\nglobal const dt_vcentre =  4\nglobal const ws_overlapped =  0\nglobal const ws_popup =  2147483648\nglobal const ws_child =  1073741824\nglobal const ws_minimize =  536870912\nglobal const ws_visible =  268435456\nglobal const ws_disabled =  134217728\nglobal const ws_clipsiblings =  67108864\nglobal const ws_clipchildren =  33554432\nglobal const ws_maximize =  16777216\nglobal const ws_caption =  12582912\nglobal const ws_border =  8388608\nglobal const ws_dlgframe =  4194304\nglobal const ws_hscroll =  1048576\nglobal const ws_vscroll =  2097152\nglobal const ws_sysmenu =  524288\nglobal const ws_thickframe =  262144\nglobal const ws_group =  131072\nglobal const ws_tabstop =  0\nglobal const ws_scrollbars =  3145728\nglobal const ws_minimizebox =  131072\nglobal const ws_maximizebox =  65536\nglobal const ws_tiled =  0\nglobal const ws_iconic =  536870912\nglobal const ws_sizebox =  262144\nglobal const ws_overlappedwindow =  13565952\nglobal const ws_tiledwindow =  13565952\nglobal const ws_popupwindow =  -2138570752\nglobal const ws_childwindow =  1073741824\nglobal const ws_ex_acceptfiles =  16\nglobal const ws_ex_appwindow =  262144\nglobal const ws_ex_clientedge =  512\nglobal const ws_ex_contexthelp =  1024\nglobal const ws_ex_controlparent =  65536\nglobal const ws_ex_dlgmodalframe =  1\nglobal const ws_ex_left =  0\nglobal const ws_ex_leftscrollbar =  16384\nglobal const ws_ex_ltrreading =  0\nglobal const ws_ex_mdichild =  64\nglobal const ws_ex_noparentnotify =  4\nglobal const ws_ex_overlappedwindow =  768\nglobal const ws_ex_palettewindow =  392\nglobal const ws_ex_right =  4096\nglobal const ws_ex_rightscrollbar =  0\nglobal const ws_ex_rtlreading =  8192\nglobal const ws_ex_staticedge =  131072\nglobal const ws_ex_toolwindow =  128\nglobal const ws_ex_topmost =  8\nglobal const ws_ex_transparent =  32\nglobal const ws_ex_windowedge =  256\n\nglobal const gw_hwndfirst =  0\nglobal const gw_hwndlast =  1\nglobal const gw_hwndnext =  2\nglobal const gw_hwndprev =  3\nglobal const gw_owner =  4\nglobal const gw_child =  5\nglobal const gw_enabledpopup =  6\nglobal const cb_geteditsel =  320\nglobal const cb_limittext =  321\nglobal const cb_seteditsel =  322\nglobal const cb_addstring =  323\nglobal const cb_deletestring =  324\nglobal const cb_dir =  325\nglobal const cb_getcount =  326\nglobal const cb_getcursel =  327\nglobal const cb_getlbtext =  328\nglobal const cb_getlbtextlen =  329\nglobal const cb_insertstring =  330\nglobal const cb_resetcontent =  331\nglobal const cb_findstring =  332\nglobal const cb_findstringexact =  344\nglobal const cb_selectstring =  333\nglobal const cb_setcursel =  334\nglobal const cb_showdropdown =  335\nglobal const cb_getitemdata =  336\nglobal const cb_setitemdata =  337\nglobal const cb_getdroppedcontrolrect =  338\nglobal const cb_setitemheight =  339\nglobal const cb_getitemheight =  340\nglobal const cb_setextendedui =  341\nglobal const cb_getextendedui =  342\nglobal const cb_getdroppedstate =  343\nglobal const cb_setlocale =  345\nglobal const cb_getlocale =  346\nglobal const cb_gettopindex =  347\nglobal const cb_settopindex =  348\nglobal const cb_gethorizontalextent =  349\nglobal const cb_sethorizontalextent =  350\nglobal const cb_getdroppedwidth =  351\nglobal const cb_setdroppedwidth =  352\nglobal const cb_initstorage =  353\nglobal const cb_multipleaddstring =  355\nglobal const bm_click =  245\nglobal const bm_getcheck =  240\nglobal const bm_getimage =  246\nglobal const bm_getstate =  242\nglobal const bm_setcheck =  241\nglobal const bm_setimage =  247\nglobal const bm_setstate =  243\nglobal const bm_setstyle =  244\nglobal const cf_bitmap =  2\nglobal const cf_dib =  8\nglobal const cf_palette =  9\nglobal const cf_enhmetafile =  14\nglobal const cf_metafilepict =  3\nglobal const cf_oemtext =  7\nglobal const cf_text =  1\t\t\t!used in sys\nglobal const cf_unicodetext =  13\nglobal const cf_dif =  5\nglobal const cf_dspbitmap =  130\nglobal const cf_dspenhmetafile =  142\nglobal const cf_dspmetafilepict =  131\nglobal const cf_dsptext =  129\nglobal const cf_gdiobjfirst =  768\nglobal const cf_gdiobjlast =  1023\nglobal const cf_hdrop =  15\nglobal const cf_locale =  16\nglobal const cf_ownerdisplay =  128\nglobal const cf_pendata =  10\nglobal const cf_privatefirst =  512\nglobal const cf_privatelast =  767\nglobal const cf_riff =  11\nglobal const cf_sylk =  4\nglobal const cf_wave =  12\nglobal const cf_tiff =  6\n\nglobal const tcif_text =  1\nglobal const tcif_image =  2\nglobal const tcif_param =  8\nglobal const tcif_rtlreading =  4\n\nglobal const wm_keydown =  256\nglobal const wm_keyup =  257\nglobal const wm_char =  258\nglobal const wm_syschar =  262\nglobal const wm_sysdeadchar =  263\nglobal const wm_syskeydown =  260\nglobal const wm_syskeyup =  261\nglobal const mf_insert =  0\nglobal const mf_change =  128\nglobal const mf_append =  256\nglobal const mf_delete =  512\nglobal const mf_remove =  4096\nglobal const mf_bycommand =  0\nglobal const mf_byposition =  1024\nglobal const mf_separator =  2048\nglobal const mf_enabled =  0\nglobal const mf_grayed =  1\nglobal const mf_greyed =  1\nglobal const mf_disabled =  2\nglobal const mf_unchecked =  0\nglobal const mf_checked =  8\nglobal const mf_usecheckbitmaps =  512\nglobal const mf_string =  0\nglobal const mf_bitmap =  4\nglobal const mf_ownerdraw =  256\nglobal const mf_popup =  16\nglobal const mf_menubarbreak =  32\nglobal const mf_menubreak =  64\nglobal const mf_unhilite =  0\nglobal const mf_hilite =  128\nglobal const mf_sysmenu =  8192\nglobal const mf_help =  16384\nglobal const mf_mouseselect =  32768\n\n!global const bn_clicked =  0\n!global const bn_dblclk =  5\n!global const bn_disable =  4\n!global const bn_doubleclicked =  5\n!global const bn_hilite =  2\n!global const bn_killfocus =  7\n!global const bn_paint =  1\n!global const bn_pushed =  2\n!global const bn_setfocus =  6\n!global const bn_unhilite =  3\n!global const bn_unpushed =  3\n!global const en_setfocus =  256\n!global const en_killfocus =  512\n!global const en_change =  768\n!global const en_update =  1024\n!global const en_errspace =  1280\n!global const en_maxtext =  1281\n!global const en_hscroll =  1537\n!global const en_vscroll =  1538\n!global const lbn_errspace =  -2\n!global const lbn_selchange =  1\n!global const lbn_dblclk =  2\n!global const lbn_selcancel =  3\n!global const lbn_setfocus =  4\n!global const lbn_killfocus =  5\n!global const cbn_errspace =  -1\n!global const cbn_selchange =  1\n!global const cbn_dblclk =  2\n!global const cbn_setfocus =  3\n!global const cbn_killfocus =  4\n!global const cbn_editchange =  5\n!global const cbn_editupdate =  6\n!global const cbn_dropdown =  7\n!global const cbn_closeup =  8\n!global const cbn_selendok =  9\n!global const cbn_selendcancel =  10\n!\n!global const cbs_autohscroll =  64\n!global const cbs_disablenoscroll =  2048\n!global const cbs_dropdown =  2\n!global const cbs_dropdownlist =  3\n!global const cbs_hasstrings =  512\n!global const cbs_lowercase =  16384\n!global const cbs_nointegralheight =  1024\n!global const cbs_oemconvert =  128\n!global const cbs_ownerdrawfixed =  16\n!global const cbs_ownerdrawvariable =  32\n!global const cbs_simple =  1\n!global const cbs_sort =  256\n!global const cbs_uppercase =  8192\n\nglobal const wm_command =  273\nglobal const wm_menuselect =  287\nglobal const wm_cut =  768\nglobal const wm_copy =  769\nglobal const wm_paste =  770\nglobal const wm_clear =  771\nglobal const wm_undo =  772\nglobal const em_getsel =  176\nglobal const em_setsel =  177\nglobal const em_scroll =  181\nglobal const em_linescroll =  182\nglobal const em_scrollcaret =  183\nglobal const em_getmodify =  184\nglobal const em_setmodify =  185\nglobal const em_getlinecount =  186\nglobal const em_lineindex =  187\nglobal const em_sethandle =  188\nglobal const em_gethandle =  189\nglobal const em_getthumb =  190\nglobal const em_linelength =  193\nglobal const em_replacesel =  194\nglobal const em_getline =  196\nglobal const em_limittext =  197\nglobal const em_canundo =  198\nglobal const em_undo =  199\nglobal const em_fmtlines =  200\nglobal const em_linefromchar =  201\nglobal const em_settabstops =  203\nglobal const em_setpasswordchar =  204\nglobal const em_emptyundobuffer =  205\nglobal const em_getfirstvisibleline =  206\nglobal const em_setreadonly =  207\nglobal const em_setwordbreakproc =  208\nglobal const em_getwordbreakproc =  209\nglobal const em_getpasswordchar =  210\nglobal const em_setlimittext =  197\nglobal const em_getseltext =  1086\nglobal const em_setcharformat =  1092\nglobal const em_getcharformat =  1082\nglobal const em_settextmode =  1113\nglobal const em_gettextmode =  1114\nglobal const em_gettextex =  1118\nglobal const em_gettextlengthex =  1119\nglobal const tm_plaintext =  1\nglobal const tm_richtext =  2\nglobal const tm_singlelevelundo =  4\nglobal const tm_multilevelundo =  8\nglobal const tm_singlecodepage =  16\nglobal const tm_multicodepage =  32\nglobal const scf_word =  2\nglobal const scf_selection =  1\nglobal const sb_getborders =  1031\nglobal const sb_getparts =  1030\nglobal const sb_getrect =  1034\nglobal const sb_gettextw =  1037\nglobal const sb_gettextlengthw =  1036\nglobal const sb_settextw =  1035\nglobal const sb_gettexta =  1026\nglobal const sb_gettextlengtha =  1027\nglobal const sb_settexta =  1025\nglobal const sb_gettext =  1026\nglobal const sb_gettextlength =  1027\nglobal const sb_settext =  1025\nglobal const sb_setminheight =  1032\nglobal const sb_setparts =  1028\nglobal const sb_simple =  1033\nglobal const wm_setfont =  48\nglobal const wm_getfont =  49\nglobal const gm_advanced =  2\nglobal const transparent =  1\nglobal const opaque =  2\nglobal const mwt_identity =  1\nglobal const cw_usedefault =  0x8000'0000\nglobal const idc_arrow =  32512\nglobal const idc_ibeam =  32513\nglobal const idc_wait =  32514\nglobal const idc_cross =  32515\nglobal const idc_uparrow =  32516\nglobal const idc_sizenwse =  32642\nglobal const idc_sizenesw =  32643\nglobal const idc_sizewe =  32644\nglobal const idc_sizens =  32645\nglobal const idc_sizeall =  32646\nglobal const idc_no =  32648\nglobal const idc_appstarting =  32650\nglobal const idc_help =  32651\nglobal const idi_application =  32512\nglobal const idi_hand =  32513\nglobal const idi_question =  32514\nglobal const idi_exclamation =  32515\nglobal const idi_asterisk =  32516\nglobal const idi_winlogo =  32517\nglobal const idc_size =  32640\nglobal const idc_icon =  32641\nglobal const arrowpointer =  32512\nglobal const ibeampointer =  32513\nglobal const waitpointer =  32514\nglobal const crosspointer =  32515\nglobal const uparrowpointer =  32516\nglobal const sizenwsepointer =  32642\nglobal const sizeneswpointer =  32643\nglobal const sizewepointer =  32644\nglobal const sizenspointer =  32645\nglobal const sizeallpointer =  32646\nglobal const nopointer =  32648\nglobal const appstartingpointer =  32650\nglobal const helpicon =  32651\nglobal const applicationicon =  32512\nglobal const handicon =  32513\nglobal const questionicon =  32514\nglobal const exclamationicon =  32515\nglobal const asteriskicon =  32516\nglobal const winlogoicon =  32517\nglobal const sizepointer =  32640\nglobal const iconicon =  32641\nglobal const sm_cymin =  29\nglobal const sm_cxmin =  28\nglobal const sm_arrange =  56\nglobal const sm_cleanboot =  67\nglobal const sm_cmetrics =  76\nglobal const sm_cmousebuttons =  43\nglobal const sm_cxborder =  5\nglobal const sm_cyborder =  6\nglobal const sm_cxcursor =  13\nglobal const sm_cycursor =  14\nglobal const sm_cxdlgframe =  7\nglobal const sm_cydlgframe =  8\nglobal const sm_cxdoubleclk =  36\nglobal const sm_cydoubleclk =  37\nglobal const sm_cxdrag =  68\nglobal const sm_cydrag =  69\nglobal const sm_cxedge =  45\nglobal const sm_cyedge =  46\nglobal const sm_cxfixedframe =  7\nglobal const sm_cyfixedframe =  8\nglobal const sm_cxframe =  32\nglobal const sm_cyframe =  33\nglobal const sm_cxfullscreen =  16\nglobal const sm_cyfullscreen =  17\nglobal const sm_cxhscroll =  21\nglobal const sm_cyhscroll =  3\nglobal const sm_cxhthumb =  10\nglobal const sm_cxicon =  11\nglobal const sm_cyicon =  12\nglobal const sm_cxiconspacing =  38\nglobal const sm_cyiconspacing =  39\nglobal const sm_cxmaximized =  61\nglobal const sm_cymaximized =  62\nglobal const sm_cxmaxtrack =  59\nglobal const sm_cymaxtrack =  60\nglobal const sm_cxmenucheck =  71\nglobal const sm_cymenucheck =  72\nglobal const sm_cxmenusize =  54\nglobal const sm_cymenusize =  55\nglobal const sm_cxminimized =  57\nglobal const sm_cyminimized =  58\nglobal const sm_cxminspacing =  47\nglobal const sm_cyminspacing =  48\nglobal const sm_cxmintrack =  34\nglobal const sm_cymintrack =  35\nglobal const sm_cxscreen =  0\nglobal const sm_cyscreen =  1\nglobal const sm_cxsize =  30\nglobal const sm_cysize =  31\nglobal const sm_cxsizeframe =  32\nglobal const sm_cysizeframe =  33\nglobal const sm_cxsmicon =  49\nglobal const sm_cysmicon =  50\nglobal const sm_cxsmsize =  52\nglobal const sm_cysmsize =  53\nglobal const sm_cxvscroll =  2\nglobal const sm_cyvscroll =  20\nglobal const sm_cyvthumb =  9\nglobal const sm_cycaption =  4\nglobal const sm_cykanjiwindow =  18\nglobal const sm_cymenu =  15\nglobal const sm_cysmcaption =  51\nglobal const sm_dbcsenabled =  42\nglobal const sm_debug =  22\nglobal const sm_menudropalignment =  40\nglobal const sm_mideastenabled =  74\nglobal const sm_mousepresent =  19\nglobal const sm_mousewheelpresent =  75\nglobal const sm_network =  63\nglobal const sm_penwindows =  41\nglobal const sm_reserved1 =  24\nglobal const sm_reserved2 =  25\nglobal const sm_reserved3 =  26\nglobal const sm_reserved4 =  27\nglobal const sm_secure =  44\nglobal const sm_showsounds =  70\nglobal const sm_slowmachine =  73\nglobal const sm_swapbutton =  23\nglobal const arw_bottomleft =  0\nglobal const arw_bottomright =  1\nglobal const arw_hide =  8\nglobal const arw_topleft =  2\nglobal const arw_topright =  3\nglobal const arw_down =  4\nglobal const arw_left =  0\nglobal const arw_right =  0\nglobal const arw_up =  4\nglobal const white_brush =  0\nglobal const ltgray_brush =  1\nglobal const gray_brush =  2\nglobal const dkgray_brush =  3\nglobal const black_brush =  4\nglobal const null_brush =  5\nglobal const hollow_brush =  5\nglobal const white_pen =  6\nglobal const black_pen =  7\nglobal const null_pen =  8\nglobal const oem_fixed_font =  10\nglobal const ansi_fixed_font =  11\nglobal const ansi_var_font =  12\nglobal const system_font =  13\nglobal const device_default_font =  14\nglobal const default_palette =  15\nglobal const system_fixed_font =  16\nglobal const stock_last =  16\n\n!global const sbm_setpos =  224\n!global const sbm_getpos =  225\n!global const sbm_setrange =  226\n!global const sbm_setrangeredraw =  230\n!global const sbm_getrange =  227\n!global const sbm_enable_arrows =  228\n!global const sbs_horz =  0\n!global const sbs_vert =  1\n!global const sbs_topalign =  2\n!global const sbs_leftalign =  2\n!global const sbs_bottomalign =  4\n!global const sbs_rightalign =  4\n!global const sbs_sizeboxtopleftalign =  2\n!global const sbs_sizeboxbottomrightalign =  4\n!global const sbs_sizebox =  8\n\nglobal const wm_hscroll =  276\nglobal const wm_vscroll =  277\n\n!global const sb_horz =  0\n!global const sb_hoz =  0\n!global const sb_vert =  1\n!global const sb_ctl =  2\n!global const sb_both =  3\n!global const sb_lineup =  0\n!global const sb_lineleft =  0\n!global const sb_linedown =  1\n!global const sb_lineright =  1\n!global const sb_pageup =  2\n!global const sb_pageleft =  2\n!global const sb_pagedown =  3\n!global const sb_pageright =  3\n!global const sb_thumbposition =  4\n!global const sb_thumbtrack =  5\n!global const sb_top =  6\n!global const sb_left =  6\n!global const sb_bottom =  7\n!global const sb_right =  7\n!global const sb_endscroll =  8\n!global const sif_disablenoscroll =  8\n!global const sif_page =  2\n!global const sif_pos =  4\n!global const sif_range =  1\n!global const sif_trackpos =  16\n!global const sif_all =  23\n\nglobal const wm_ctlcolourmsgbox =  306\nglobal const wm_ctlcolouredit =  307\nglobal const wm_ctlcolourlistbox =  308\nglobal const wm_ctlcolourbtn =  309\nglobal const wm_ctlcolourdlg =  310\nglobal const wm_ctlcolourscrollbar =  311\nglobal const wm_ctlcolourstatic =  312\nglobal const wm_timer =  275\n\nglobal const srccopy =  13369376\nglobal const srcpaint =  15597702\nglobal const srcand =  8913094\nglobal const srcinvert =  6684742\nglobal const srcerase =  4457256\n\nglobal const notsrccopy =  3342344\nglobal const notsrcerase =  1114278\nglobal const mergecopy =  12583114\nglobal const mergepaint =  12255782\nglobal const patcopy =  15728673\nglobal const patpaint =  16452105\nglobal const patinvert =  5898313\nglobal const dstinvert =  5570569\nglobal const blackness =  66\nglobal const whiteness =  16711778\n\nglobal const r2_black =  1\nglobal const r2_notmergepen =  2\nglobal const r2_masknotpen =  3\nglobal const r2_notcopypen =  4\nglobal const r2_maskpennot =  5\nglobal const r2_not =  6\nglobal const r2_xorpen =  7\nglobal const r2_notmaskpen =  8\nglobal const r2_maskpen =  9\nglobal const r2_notxorpen =  10\nglobal const r2_nop =  11\nglobal const r2_mergenotpen =  12\nglobal const r2_copypen =  13\nglobal const r2_mergepennot =  14\nglobal const r2_mergepen =  15\nglobal const r2_white =  16\nglobal const r2_last =  16\n\nglobal const gdi_error =  4294967295\nglobal const hgdi_error =  4294967295\nglobal const clr_invalid =  4278190080\nglobal const clr_default =  4278190080\nglobal const clr_none =  4294967295\nglobal const ofn_readonly =  1\nglobal const ofn_overwriteprompt =  2\nglobal const ofn_hidereadonly =  4\nglobal const ofn_nochangedir =  8\nglobal const ofn_showhelp =  16\nglobal const ofn_enablehook =  32\nglobal const ofn_enabletemplate =  64\nglobal const ofn_enabletemplatehandle =  128\nglobal const ofn_novalidate =  256\nglobal const ofn_allowmultiselect =  512\nglobal const ofn_extensiondifferent =  1024\nglobal const ofn_pathmustexist =  2048\nglobal const ofn_filemustexist =  4096\nglobal const ofn_createprompt =  8192\nglobal const ofn_shareaware =  16384\nglobal const ofn_noreadonlyreturn =  32768\nglobal const ofn_notestfilecreate =  65536\nglobal const ofn_nonetworkbutton =  131072\nglobal const ofn_nolongnames =  262144\nglobal const ofn_explorer =  524288\nglobal const ofn_nodereferencelinks =  1048576\nglobal const ofn_longnames =  2097152\nglobal const ofn_sharefallthrough =  2\nglobal const ofn_sharenowarn =  1\nglobal const ofn_sharewarn =  0\n!global const gmem_fixed =  0\n!global const gmem_moveable =  2\n!global const gmem_nocompact =  16\n!global const gmem_nodiscard =  32\n!global const gmem_zeroinit =  64\n!global const gmem_modify =  128\n!global const gmem_discardable =  256\n!global const gmem_not_banked =  4096\n!global const gmem_share =  8192\n!global const gmem_ddeshare =  8192\n!global const gmem_notify =  16384\n!global const gmem_lower =  4096\n!global const gmem_valid_flags =  32626\n!global const gmem_invalid_handle =  32768\n!global const gmem_clipboard =  8194\n!global const ghnd =  66\n!global const gptr =  64\n!global const pd_allpages =  0\n!global const pd_collate =  16\n!global const pd_disableprinttofile =  524288\n!global const pd_enableprinthook =  4096\n!global const pd_enableprinttemplate =  16384\n!global const pd_enableprinttemplatehandle =  65536\n!global const pd_enablesetuphook =  8192\n!global const pd_enablesetuptemplate =  32768\n!global const pd_enablesetuptemplatehandle =  131072\n!global const pd_hideprinttofile =  1048576\n!global const pd_nopagenums =  8\n!global const pd_noselection =  4\n!global const pd_nowarning =  128\n!global const pd_pagenums =  2\n!global const pd_printsetup =  64\n!global const pd_printtofile =  32\n!global const pd_returndc =  256\n!global const pd_returndefault =  1024\n!global const pd_returnic =  512\n!global const pd_selection =  1\n!global const pd_showhelp =  2048\n!global const pd_usedevmodecopies =  262144\n!global const pd_usedevmodecopiesandcollate =  262144\nglobal const dib_rgb_colours =  0\nglobal const dib_pal_colours =  1\nglobal const dib_pal_indices =  2\nglobal const dib_pal_physindices =  2\nglobal const dib_pal_logindices =  4\nglobal const stm_seticon =  368\nglobal const stm_setimage =  370\nglobal const lr_loadfromfile =  16\nglobal const image_bitmap =  0\nglobal const image_icon =  1\nglobal const lr_copydeleteorg =  8\nglobal const lr_copyreturnorg =  4\nglobal const lr_monochrome =  1\nglobal const lr_createdibsection =  8192\nglobal const lr_defaultsize =  64\nglobal const ss_icon =  3\nglobal const ss_bitmap =  14\nglobal const gcl_menuname =  -8\nglobal const gcl_hbrbackground =  -10\nglobal const gcl_hcursor =  -12\nglobal const gcl_hicon =  -14\nglobal const gcl_hmodule =  -16\nglobal const gcl_cbwndextra =  -18\nglobal const gcl_cbclsextra =  -20\nglobal const gcl_wndproc =  -24\nglobal const gcl_style =  -26\nglobal const gcw_atom =  -32\nglobal const colour_scrollbar =  0\nglobal const colour_background =  1\nglobal const colour_desktop =  1\nglobal const colour_activecaption =  2\nglobal const colour_inactivecaption =  3\nglobal const colour_menu =  4\nglobal const colour_window =  5\nglobal const colour_windowframe =  6\nglobal const colour_menutext =  7\nglobal const colour_windowtext =  8\nglobal const colour_captiontext =  9\nglobal const colour_activeborder =  10\nglobal const colour_inactiveborder =  11\nglobal const colour_appworkspace =  12\nglobal const colour_highlight =  13\nglobal const colour_highlighttext =  14\nglobal const colour_btnface =  15\nglobal const colour_3dface =  15\nglobal const colour_btnshadow =  16\nglobal const colour_3dshadow =  16\nglobal const colour_graytext =  17\nglobal const colour_btntext =  18\nglobal const colour_inactivecaptiontext =  19\nglobal const colour_btnhighlight =  20\nglobal const colour_3dhilight =  20\nglobal const colour_3ddkshadow =  21\nglobal const colour_3dlight =  22\nglobal const colour_infotext =  23\nglobal const colour_infobk =  24\nglobal const colour_tooltipbk =  24\nglobal const mk_lbutton =  1\nglobal const mk_rbutton =  2\nglobal const mk_shift =  4\nglobal const mk_control =  8\nglobal const mk_mbutton =  16\nglobal const cbm_createdib =  2\nglobal const cbm_init =  4\nglobal const cc_enablehook =  16\nglobal const cc_enabletemplate =  32\nglobal const cc_enabletemplatehandle =  64\nglobal const cc_fullopen =  2\nglobal const cc_preventfullopen =  4\nglobal const cc_rgbinit =  1\nglobal const cc_showhelp =  8\nglobal const cc_solidcolour =  128\nglobal const cf_screenfonts =  1\nglobal const cf_printerfonts =  2\nglobal const cf_effects =  256\nglobal const size_restored =  0\nglobal const size_minimized =  1\nglobal const size_maximized =  2\nglobal const size_maxshow =  3\nglobal const size_maxhide =  4\n!global const gwl_wndproc =  -4\n!global const gwl_hinstance =  -6\n!global const gwl_hwndparent =  -8\n!global const gwl_style =  -16\n!global const gwl_exstyle =  -20\nglobal const gwl_userdata =  -21\nglobal const gwl_id =  -12\nglobal const ta_top =  0\nglobal const ta_left =  0\nglobal const ta_noupdatecp =  0\nglobal const ta_updatecp =  1\nglobal const ta_right =  2\nglobal const ta_centre =  6\nglobal const vta_centre =  6\nglobal const ta_bottom =  8\nglobal const ta_baseline =  24\nglobal const vta_baseline =  24\nglobal const ta_rtlreading =  256\nglobal const aligntop =  0\nglobal const alignbottom =  8\nglobal const alignbaseline =  24\nglobal const aligncentre =  6\nglobal const alignleft =  0\nglobal const alignright =  2\n\nglobal const em_exgetsel =  1076\nglobal const em_exlimittext =  1077\nglobal const em_exlinefromchar =  1078\nglobal const em_exsetsel =  1079\nglobal const em_getparaformat =  1085\nglobal const em_setparaformat =  1095\nglobal const em_streamin =  1097\nglobal const em_streamout =  1098\nglobal const em_gettextrange =  1099\nglobal const em_findtext =  1080\nglobal const em_findtextex =  1103\n\n!global const ttf_idishwnd =  1\n!global const ttf_centretip =  2\n!global const ttf_rtlreading =  4\n!global const ttf_subclass =  16\n!global const ttf_track =  32\n!global const ttf_absolute =  128\n!global const ttf_transparent =  256\n!global const ttf_di_setitem =  32768\n\nglobal const hwnd_top =  0\nglobal const hwnd_bottom =  1\nglobal const hwnd_topmost =  -1\nglobal const hwnd_notopmost =  -2\n\nglobal const normalwind =  0\nglobal const modalwind =  -1\nglobal const dialogwind =  -2\nglobal const minimize =  2\nglobal const maximize =  3\nglobal const shiftmask =  1\nglobal const controlmask =  2\nglobal const altmask =  4\nglobal const windowcolour =  15\nglobal const ps_geometric =  65536\nglobal const ps_cosmetic =  0\nglobal const ps_alternate =  8\nglobal const ps_solid =  0\nglobal const ps_dash =  1\nglobal const ps_dot =  2\nglobal const ps_dashdot =  3\nglobal const ps_dashdotdot =  4\nglobal const ps_null =  5\nglobal const ps_insideframe =  6\nglobal const ps_userstyle =  7\nglobal const ps_endcap_round =  0\nglobal const ps_endcap_square =  256\nglobal const ps_endcap_flat =  512\nglobal const ps_join_bevel =  4096\nglobal const ps_join_miter =  8192\nglobal const ps_join_round =  0\nglobal const ps_style_mask =  15\nglobal const ps_endcap_mask =  3840\nglobal const ps_type_mask =  983040\nglobal const bs_solid =  0\nglobal const bs_hollow =  1\nglobal const bs_null =  1\nglobal const bs_hatched =  2\nglobal const bs_pattern =  3\nglobal const bs_dibpattern =  5\nglobal const bs_dibpatternpt =  6\nglobal const bs_pattern8x8 =  7\nglobal const bs_dibpattern8x8 =  8\nglobal const hs_horizontal =  0\nglobal const hs_vertical =  1\nglobal const hs_fdiagonal =  2\nglobal const hs_bdiagonal =  3\nglobal const hs_cross =  4\nglobal const hs_diagcross =  5\n\n!global const gl_points =  0\n!global const gl_lines =  1\n!global const gl_line_loop =  2\n!global const gl_line_strip =  3\n!global const gl_triangles =  4\n!global const gl_triangle_strip =  5\n!global const gl_triangle_fan =  6\n!global const gl_quads =  7\n!global const gl_quad_strip =  8\n!global const gl_polygon =  9\n\nglobal const spi_getworkarea =  48\n\nproc start=\nend\n\n",
(u64)"!import winmessages\n!import winconsts\n!import gxmisc\n!import winapi\n\n!module winapi\n\nexport var hwapplic=nil\nexport var hwchild=nil\nexport var iswin32\nexport var screendc\n\nexport var nglobalfonts=0\nexport var fonttable::=()\t\t\t![]font handles\nexport var fontdimtable::=()\t\t![]rpoint (width,total line height)\nexport var fontvdimtable::=()\t\t![]rpoint (ascenders, descenders) \n\nproc start\t=\n\tinitdata()\nend\n\nproc initdata=\n!CPL \"---------WINGXLIB\"\n\tiswin32:=(getos()=\"W32\")\n\tscreendc:=getdc(nil)\n\n\tfonttable:=(0,)*20\n\tfontdimtable:=(0,)*20\n\tfontvdimtable:=(0,)*20\n\n\tfonttable[1]:=getstockobject(17)\t!default gui\n\tfonttable[2]:=getstockobject(13)\t!system font\n\tfonttable[3]:=getstockobject(16)\t!system fixed\n\tfonttable[4]:=getstockobject(10)\t!oem fixed\n\tfor i:=1 to 4 do\n\t\tfontdimtable[i]::=ws_point(0,0)\n\t\tfontvdimtable[i]::=ws_point(0,0)\n\tod\n\tnglobalfonts:=4\nend\n\nfunc checkoption(optionnames,optionvalues,name,default=-1)=\n!search for option with given name\n!return value of option, or -1 if not present\n!options (which can be void) will be a list of (name,value) list pairs\n\n\tn:=name in optionnames\n\tif not n then return default fi\n\treturn optionvalues[n]\nend\n\nglobal proc wx_waitmess=\n\twindmsg:=new((iswin32|ws_msg32|ws_msg64))\n\n\tdo\n\t\tif getmessage(&windmsg,nil,0,0)<>0 then\n\t\t\tw:=windmsg.hwnd\n\t\t\tif windmsg.message=wm_keydown and windmsg.wparam=27 then exit fi\n\t\t\tif windmsg.message=wm_timer then CPL \"TIMER!!\" fi\n\t\t\ttranslatemessage(&windmsg)\n\t\t\tdispatchmessage(&windmsg)\n\t\t\tif windmsg.message=wm_close then exit fi\n\t\telse\n\t\t\texit\n\t\tfi\n\tod\nend\n\nglobal func wx_getw(hwnd)=\n!return allwindow-index of window that has been stored into it\n\tn:=getwindowlongptr(hwnd, gwl_userdata)\n\treturn n\nend\n\nglobal proc wx_setw(hwnd,index)=\n!store mm window handle into win32 window\n!index is .gindex (index into allwindows)\n\tsetwindowlongptr(hwnd, gwl_userdata, index)\nend\n\nglobal func wx_gettextwidth(hdc,s)=\n\tsize:=new(ws_point)\n\tgettextextentpoint32(hdc,s,s.len,&size)\n\treturn size.x\nend\n\nglobal func wx_createpopup(?caption,?pos,?dim,?options,owner=nil)=\n!wrapper around win32 createwindow\n!return win32 handle to newly created window\n\tconst gap=40\n\tconst smallestwidth=150\n\n\tif options.isvoid then\n options:=[wf_caption:1,wf_border:wbs_resize]\n\tfi\n\n\tposx:=posy:=-1\n\tdimx:=640\n\tdimy:=480\n\tfcentre:=0\n\tfautopos:=0\n\tfmax:=fdesktop:=0\n!\tfconsole:=0\n\n\tif caption.isvoid then caption:=\"<No Caption>\" fi\n\n\tif dim.defined then\n\t\tif dim.isstring and dim=\"max\" then\n\t\t\tfmax:=1\n\t\telsif dim.isstring and dim=\"desktop\" then\n\t\t\tfdesktop:=1\n!\t\telsif dim.isstring and dim=\"console\" then\n!\t\t\tfconsole:=1\n\t\telse\n\t\t\tdimx:=dim[1]\n\t\t\tdimy:=dim[2]\n\t\tfi\n\tfi\n\n\tif pos.isvoid or pos=\"cent\" then\n\t\tfcentre:=1\n\telsif pos=\"auto\" then\n\t\tfautopos:=1\n\telsif pos.defined and not pos.isstring then\n\t\tposx:=pos[1]\n\t\tposy:=pos[2]\n\telse\t\t\t\t!check options?\n\t\tabort(\"gxcw bad pos\")\n\tfi\n\n\tbstyle:=bxstyle:=0\n\tnocap:=0\t\t\t!whether to suppress caption\n\n\tframex:=framey:=0\n\n\tcase options{wf_border,wbs_resize}\n\twhen wbs_none then\t\t!no border\n\t\tnocap:=1\n\t\tframex:=0\n\t\tframey:=0\n\twhen wbs_simple then\t\t!single line\n\t\tnocap:=1\n\t\tbstyle:=ws_border\n\t\tframex:=1\n\t\tframey:=1\n\twhen wbs_thick then\t\t!thick line\n\t\tbstyle:=ws_dlgframe\n\t\tfixedframe:=0\n\t\tframex:=getsystemmetrics(sm_cxfixedframe)\n\t\tframey:=getsystemmetrics(sm_cyfixedframe)\n\twhen wbs_resize then\n\t\tbstyle:=ws_sizebox\n\t\tframex:=getsystemmetrics(sm_cxsizeframe)\n\t\tframey:=getsystemmetrics(sm_cysizeframe)\n\twhen wbs_sunken,wbs_sunken2 then\t\t!sunken\n\t\tbstyle:=ws_dlgframe\n\t\tbxstyle:=ws_ex_clientedge\n\t\tframex:=5\n\t\tframey:=5\n\twhen wbs_sunkenrs then\n\t\tbstyle:=ws_sizebox\n\t\tbxstyle:=ws_ex_clientedge\n\t\tframex:=6\n\t\tframey:=6\n\tesac\n\n\tcapheight:=getsystemmetrics(sm_cycaption)\n\tmbheight:=getsystemmetrics(sm_cymenu)\n\n\tstyle:=0\n\texstyle:=0\n\n\tif options{wf_show,1} then\n\t\tstyle ior:=ws_visible\n\tfi\n\n\tmxleft:=framex\n\tmxright:=framey\n\tmytop:=framey+capheight\n\tmybottom:=framey\n\tshowstyle:=sw_shownormal\n\n\thcwmenu:=nil\n\tif options{wf_menu,0}=1 then\n\t\tmytop+:=mbheight\n\t\thcwmenu:=createmenu()\n\t\tappendmenu(hcwmenu,0,998,\"fred\")\n\tfi\n\n\tstyle ior:=ws_clipchildren\n\n\tif nocap or options{wf_caption,1}=0 then\n\t\tmytop-:=capheight\n\t\tstyle ior:=ws_popup\n\tfi\n\n\tif options{wf_iframe,0}=0 then\n\t\tif not fautopos then\n\t\t\tposx-:=mxleft\n\t\t\tposy-:=mytop\n\t\tfi\n\t\tdimx+:=mxleft+mxright\n\t\tdimy+:=mytop+mybottom\n\tfi\n\n\tif fcentre or options{wf_cent,0}=1 then\n\t\tfautopos:=0\n\t\tbox:=new(ws_rect)\n\t\tsystemparametersinfoa(spi_getworkarea,0,&box,0)\n\t\tposx:=box.rightx%2-dimx%2\n\t\tposy:=(box.bottom-box.top)%2-dimy%2+box.top\n\tfi\n\n\tif fmax or options{wf_max,0} then\n\t\tshowstyle:=sw_maximize\n\t\tstyle ior:=ws_maximize\n\tfi\n\n\n\tif options{wf_minmax,1}=1 then\n\t\tstyle ior:=(ws_maximizebox ior ws_minimizebox)\n\n\tfi\n\n\tif options{wf_sysmenu,1}=1 then\n\t\tstyle ior:=ws_sysmenu\n\tfi\n\n\tif fautopos=0 and options{wf_clip,0}=1 then\n\t\tbox:=new(ws_rect)\n\t\tsystemparametersinfoa(spi_getworkarea,0,&box,0)\n\n\t\tif posx<box.leftx+gap then posx:=box.leftx+gap fi\n\n\t\tif posy<box.top+gap then posy:=box.top+gap fi\n\t\tdimxmin:=dimx max smallestwidth\n\t\tif posx+dimxmin>=box.rightx+gap then posx:=box.rightx-gap-dimxmin fi\n\t\tif posy+dimy>=box.bottom+gap then posy:=box.bottom-gap-dimy fi\n\telsif fautopos then\n\t\tposx:=posy:=cw_usedefault\n\tfi\n\n\tif fdesktop or options{wf_desktop,0}=1 then\n\t\tbox:=new(ws_rect)\n\t\tsystemparametersinfoa(spi_getworkarea,0,&box,0)\n\t\tposx:=box.leftx\n\t\tposy:=box.top\n\t\tdimx:=box.rightx-box.leftx\n\t\tdimy:=box.bottom-box.top\n\tfi\n\n\tif options{wf_toolwind,0}=1 then\n\t\texstyle ior:=ws_ex_toolwindow\n\tfi\n\n\tclassname:=\"pcc001\"\n\n\tSTYLE IOR:=WS_VISIBLE\n\n\tstyle ior:=bstyle\n\texstyle ior:=bxstyle\n\n!\tif fconsole then\n!\t\thwnd:=getconsolewindow()\n!CPL \"CONSOLE\", =HWND\n!STOP\n!\n!\telse\n\n\t\thwnd:=createwindowex(\n\t\t\texstyle,\n\t\t\tclassname,\n\t\t\tcaption,\n\t\t\tstyle,\n\t\t\tposx,posy,\t\t\t!initial position and size\n\t\t\tdimx,dimy,\n\t\t\towner,\t\t\t!will be 0 for 1st window, other popups use hwapplic as owner\n\t\t\thcwmenu,\t\t\t!menu handle\n\t\t\tnil,\t!proginstance,\t\t!instance handle\n\t\t\tnil)\t\t\t!creation params\n!\tfi\n\n\tif hwnd=nil then\n\t\te:=getlasterror()\n\t\tabort(\"wx:Can't create popup window \"+tostr(e))\n\tfi\n\treturn hwnd\nend\n\nglobal func wx_createcontrol(?pos,?dim,border=wbs_simple,owner)=\n!wrapper around win32 createwindow\n!return win32 handle to newly created window\n\tconst gap=40\n\tconst smallestwidth=150\n\n\tposx:=posy:=0\n\tdimx:=160\n\tdimy:=120\n\n\tif dim.defined then\n\t\tdimx:=dim[1]\n\t\tdimy:=dim[2]\n\tfi\n\n\tif pos.defined then\n\t\tposx:=pos[1]\n\t\tposy:=pos[2]\n\tfi\n\n\tbstyle:=bxstyle:=0\n\n\tcase border\n\twhen wbs_none then\t\t\t!no border\n\twhen wbs_simple then\t\t!single line\n\t\tbstyle:=ws_border\n\telse\n\t\tpcerror(\"createcontrol/bad border \"+wbsnames[border])\n\tesac\n\n\tstyle:=0\n\texstyle:=0\n\n\tstyle ior:=ws_clipchildren\n\n\tclassname:=\"pcc001\"\n\n\tstyle ior:=ws_child\n\tstyle ior:=ws_visible\n\n\tstyle ior:=bstyle\n\texstyle ior:=bxstyle\n\n\thwnd:=createwindowex(\n\t\texstyle,\n\t\tclassname,\n\t\tnil,\n\t\tstyle,\n\t\tposx,posy,\t\t\t!initial position and size\n\t\tdimx,dimy,\n\t\towner,\t\t\t\t!will be 0 for 1st window, other popups use hwapplic as owner\n\t\tnil,\t\t\t\t!menu handle\n\t\tnil,\n\t\tnil)\t\t\t\t!creation params\n\n\tif hwnd=0 then\n\t\te:=getlasterror()\n\t\tabort(\"wx:Can't create child window \"+tostr(e))\n\tfi\n\n\treturn hwnd\nend\n\n",
(u64)"export var winmessagenames=[\n\t(0:\"wm_null\"),\n\t(1:\"wm_create\"),\n\t(2:\"wm_destroy\"),\n\t(3:\"wm_move\"),\n\t(4:\"pgk_menu\"),\n\t(5:\"wm_size\"),\n\t(6:\"wm_activate\"),\n\t(7:\"wm_setfocus\"),\n\t(8:\"wm_killfocus\"),\n\t(9:\"cbn_selendok\"),\n\t(10:\"wm_enable\"),\n\t(11:\"wm_setredraw\"),\n\t(12:\"wm_settext\"),\n\t(13:\"wm_gettext\"),\n\t(14:\"wm_gettextlength\"),\n\t(15:\"wm_paint\"),\n\t(16:\"wm_close\"),\n\t(17:\"wm_queryendsession\"),\n\t(18:\"wm_quit\"),\n\t(19:\"wm_queryopen\"),\n\t(20:\"wm_erasebkgnd\"),\n\t(21:\"wm_syscolorchange\"),\n\t(22:\"wm_endsession\"),\n\t(24:\"wm_showwindow\"),\n\t(26:\"wm_wininichange\"),\n\t(27:\"wm_devmodechange\"),\n\t(28:\"wm_activateapp\"),\n\t(29:\"wm_fontchange\"),\n\t(30:\"wm_timechange\"),\n\t(31:\"wm_cancelmode\"),\n\t(32:\"wm_setcursor\"),\n\t(33:\"wm_mouseactivate\"),\n\t(34:\"wm_childactivate\"),\n\t(35:\"wm_queuesync\"),\n\t(36:\"wm_getminmaxinfo\"),\n\t(38:\"wm_painticon\"),\n\t(39:\"wm_iconerasebkgnd\"),\n\t(40:\"wm_nextdlgctl\"),\n\t(42:\"wm_spoolerstatus\"),\n\t(43:\"wm_drawitem\"),\n\t(44:\"wm_measureitem\"),\n\t(45:\"wm_deleteitem\"),\n\t(46:\"wm_vkeytoitem\"),\n\t(47:\"wm_chartoitem\"),\n\t(48:\"wm_setfont\"),\n\t(49:\"wm_getfont\"),\n\t(50:\"wm_sethotkey\"),\n\t(51:\"wm_gethotkey\"),\n\t(55:\"wm_querydragicon\"),\n\t(57:\"wm_compareitem\"),\n\t(64:\"tbif_size\"),\n\t(65:\"wm_compacting\"),\n\t(70:\"wm_windowposchanging\"),\n\t(71:\"wm_windowposchanged\"),\n\t(72:\"wm_power\"),\n\t(74:\"wm_copydata\"),\n\t(75:\"wm_canceljournal\"),\n\t(78:\"wm_notify\"),\n\t(80:\"wm_inputlangchangerequest\"),\n\t(81:\"wm_inputlangchange\"),\n\t(82:\"wm_tcard\"),\n\t(83:\"wm_help\"),\n\t(84:\"wm_userchanged\"),\n\t(85:\"wm_notifyformat\"),\n\t(123:\"wm_contextmenu\"),\n\t(124:\"wm_stylechanging\"),\n\t(125:\"wm_stylechanged\"),\n\t(126:\"wm_displaychange\"),\n\t(127:\"wm_geticon\"),\n\t(128:\"wm_seticon\"),\n\t(129:\"wm_nccreate\"),\n\t(130:\"wm_ncdestroy\"),\n\t(131:\"wm_nccalcsize\"),\n\t(132:\"wm_nchittest\"),\n\t(133:\"wm_ncpaint\"),\n\t(134:\"wm_ncactivate\"),\n\t(135:\"wm_getdlgcode\"),\n\t(160:\"wm_ncmousemove\"),\n\t(161:\"wm_nclbuttondown\"),\n\t(162:\"wm_nclbuttonup\"),\n\t(163:\"wm_nclbuttondblclk\"),\n\t(164:\"wm_ncrbuttondown\"),\n\t(165:\"wm_ncrbuttonup\"),\n\t(166:\"wm_ncrbuttondblclk\"),\n\t(167:\"wm_ncmbuttondown\"),\n\t(168:\"wm_ncmbuttonup\"),\n\t(169:\"wm_ncmbuttondblclk\"),\n\t(176:\"em_getsel\"),\n\t(177:\"em_setsel\"),\n\t(178:\"em_getrect\"),\n\t(179:\"em_setrect\"),\n\t(180:\"em_setrectnp\"),\n\t(181:\"em_scroll\"),\n\t(182:\"em_linescroll\"),\n\t(183:\"em_scrollcaret\"),\n\t(184:\"em_getmodify\"),\n\t(185:\"em_setmodify\"),\n\t(186:\"em_getlinecount\"),\n\t(187:\"em_lineindex\"),\n\t(188:\"em_sethandle\"),\n\t(189:\"em_gethandle\"),\n\t(190:\"em_getthumb\"),\n\t(193:\"em_linelength\"),\n\t(194:\"em_replacesel\"),\n\t(196:\"em_getline\"),\n\t(197:\"em_setlimittext\"),\n\t(198:\"em_canundo\"),\n\t(199:\"em_undo\"),\n\t(200:\"em_fmtlines\"),\n\t(201:\"em_linefromchar\"),\n\t(203:\"em_settabstops\"),\n\t(204:\"em_setpasswordchar\"),\n\t(205:\"em_emptyundobuffer\"),\n\t(206:\"em_getfirstvisibleline\"),\n\t(207:\"em_setreadonly\"),\n\t(208:\"em_setwordbreakproc\"),\n\t(209:\"em_getwordbreakproc\"),\n\t(210:\"em_getpasswordchar\"),\n\t(211:\"em_setmargins\"),\n\t(212:\"em_getmargins\"),\n\t(213:\"em_getlimittext\"),\n\t(214:\"em_posfromchar\"),\n\t(215:\"em_charfrompos\"),\n\t(224:\"sbm_setpos\"),\n\t(225:\"sbm_getpos\"),\n\t(226:\"sbm_setrange\"),\n\t(227:\"sbm_getrange\"),\n\t(228:\"sbm_enable_arrows\"),\n\t(230:\"sbm_setrangeredraw\"),\n\t(233:\"sbm_setscrollinfo\"),\n\t(234:\"sbm_getscrollinfo\"),\n\t(240:\"bm_getcheck\"),\n\t(241:\"bm_setcheck\"),\n\t(242:\"bm_getstate\"),\n\t(243:\"bm_setstate\"),\n\t(244:\"bm_setstyle\"),\n\t(245:\"bm_click\"),\n\t(246:\"bm_getimage\"),\n\t(247:\"bm_setimage\"),\n\t(255:\"wm_input\"),\n\t(256:\"wm_keydown\"),\n\t(257:\"wm_keyup\"),\n\t(258:\"wm_char\"),\n\t(259:\"wm_deadchar\"),\n\t(260:\"wm_syskeydown\"),\n\t(261:\"wm_syskeyup\"),\n\t(262:\"wm_syschar\"),\n\t(263:\"wm_sysdeadchar\"),\n\t(269:\"wm_ime_startcomposition\"),\n\t(270:\"wm_ime_endcomposition\"),\n\t(271:\"wm_ime_composition\"),\n\t(272:\"wm_initdialog\"),\n\t(273:\"wm_command\"),\n\t(274:\"wm_syscommand\"),\n\t(275:\"wm_timer\"),\n\t(276:\"wm_hscroll\"),\n\t(277:\"wm_vscroll\"),\n\t(278:\"wm_initmenu\"),\n\t(279:\"wm_initmenupopup\"),\n\t(287:\"wm_menuselect\"),\n\t(288:\"wm_menuchar\"),\n\t(289:\"wm_enteridle\"),\n\t(290:\"wm_menurbuttonup\"),\n\t(295:\"wm_changeuistate\"),\n\t(296:\"wm_updateuistate\"),\n\t(297:\"wm_queryuistate\"),\n\t(306:\"wm_ctlcolormsgbox\"),\n\t(307:\"wm_ctlcoloredit\"),\n\t(308:\"wm_ctlcolorlistbox\"),\n\t(309:\"wm_ctlcolorbtn\"),\n\t(310:\"wm_ctlcolordlg\"),\n\t(311:\"wm_ctlcolorscrollbar\"),\n\t(312:\"wm_ctlcolorstatic\"),\n\t(320:\"cb_geteditsel\"),\n\t(321:\"cb_limittext\"),\n\t(322:\"cb_seteditsel\"),\n\t(323:\"cb_addstring\"),\n\t(324:\"cbem_deleteitem\"),\n\t(325:\"cb_dir\"),\n\t(326:\"cb_getcount\"),\n\t(327:\"cb_getcursel\"),\n\t(328:\"cb_getlbtext\"),\n\t(329:\"cb_getlbtextlen\"),\n\t(330:\"cb_insertstring\"),\n\t(331:\"cb_resetcontent\"),\n\t(332:\"cb_findstring\"),\n\t(333:\"cb_selectstring\"),\n\t(334:\"cb_setcursel\"),\n\t(335:\"cb_showdropdown\"),\n\t(336:\"cb_getitemdata\"),\n\t(337:\"cb_setitemdata\"),\n\t(338:\"cb_getdroppedcontrolrect\"),\n\t(339:\"cb_setitemheight\"),\n\t(340:\"cb_getitemheight\"),\n\t(341:\"cb_setextendedui\"),\n\t(342:\"cb_getextendedui\"),\n\t(343:\"cb_getdroppedstate\"),\n\t(344:\"cb_findstringexact\"),\n\t(345:\"cb_setlocale\"),\n\t(346:\"cb_getlocale\"),\n\t(347:\"cb_gettopindex\"),\n\t(348:\"cb_settopindex\"),\n\t(349:\"cb_gethorizontalextent\"),\n\t(350:\"cb_sethorizontalextent\"),\n\t(351:\"cb_getdroppedwidth\"),\n\t(352:\"cb_setdroppedwidth\"),\n\t(353:\"cb_initstorage\"),\n\t(368:\"stm_seticon\"),\n\t(369:\"stm_geticon\"),\n\t(370:\"stm_setimage\"),\n\t(371:\"stm_getimage\"),\n\t(384:\"lb_addstring\"),\n\t(385:\"lb_insertstring\"),\n\t(386:\"lb_deletestring\"),\n\t(387:\"lb_selitemrangeex\"),\n\t(388:\"lb_resetcontent\"),\n\t(389:\"lb_setsel\"),\n\t(390:\"lb_setcursel\"),\n\t(391:\"lb_getsel\"),\n\t(392:\"lb_getcursel\"),\n\t(393:\"lb_gettext\"),\n\t(394:\"lb_gettextlen\"),\n\t(395:\"lb_getcount\"),\n\t(396:\"lb_selectstring\"),\n\t(397:\"lb_dir\"),\n\t(398:\"lb_gettopindex\"),\n\t(399:\"lb_findstring\"),\n\t(400:\"lb_getselcount\"),\n\t(401:\"lb_getselitems\"),\n\t(402:\"lb_settabstops\"),\n\t(403:\"lb_gethorizontalextent\"),\n\t(404:\"lb_sethorizontalextent\"),\n\t(405:\"lb_setcolumnwidth\"),\n\t(406:\"lb_addfile\"),\n\t(407:\"lb_settopindex\"),\n\t(408:\"lb_getitemrect\"),\n\t(409:\"lb_getitemdata\"),\n\t(410:\"lb_setitemdata\"),\n\t(411:\"lb_selitemrange\"),\n\t(412:\"lb_setanchorindex\"),\n\t(413:\"lb_getanchorindex\"),\n\t(414:\"lb_setcaretindex\"),\n\t(415:\"lb_getcaretindex\"),\n\t(416:\"lb_setitemheight\"),\n\t(417:\"lb_getitemheight\"),\n\t(418:\"lb_findstringexact\"),\n\t(421:\"lb_setlocale\"),\n\t(422:\"lb_getlocale\"),\n\t(423:\"lb_setcount\"),\n\t(424:\"lb_initstorage\"),\n\t(425:\"lb_itemfrompoint\"),\n\t(512:\"wm_mousemove\"),\n\t(513:\"wm_lbuttondown\"),\n\t(514:\"wm_lbuttonup\"),\n\t(515:\"wm_lbuttondblclk\"),\n\t(516:\"wm_rbuttondown\"),\n\t(517:\"wm_rbuttonup\"),\n\t(518:\"wm_rbuttondblclk\"),\n\t(519:\"wm_mbuttondown\"),\n\t(520:\"wm_mbuttonup\"),\n\t(521:\"wm_mbuttondblclk\"),\n\t(522:\"wm_mousewheel\"),\n\t(523:\"wm_xbuttondown\"),\n\t(524:\"wm_xbuttonup\"),\n\t(525:\"wm_xbuttondblclk\"),\n\t(528:\"wm_parentnotify\"),\n\t(529:\"wm_entermenuloop\"),\n\t(530:\"wm_exitmenuloop\"),\n\t(531:\"wm_nextmenu\"),\n\t(532:\"wm_sizing\"),\n\t(533:\"wm_capturechanged\"),\n\t(534:\"wm_moving\"),\n\t(536:\"wm_powerbroadcast\"),\n\t(537:\"wm_devicechange\"),\n\t(544:\"wm_mdicreate\"),\n\t(545:\"wm_mdidestroy\"),\n\t(546:\"wm_mdiactivate\"),\n\t(547:\"wm_mdirestore\"),\n\t(548:\"wm_mdinext\"),\n\t(549:\"wm_mdimaximize\"),\n\t(550:\"wm_mditile\"),\n\t(551:\"wm_mdicascade\"),\n\t(552:\"wm_mdiiconarrange\"),\n\t(553:\"wm_mdigetactive\"),\n\t(560:\"wm_mdisetmenu\"),\n\t(561:\"wm_entersizemove\"),\n\t(562:\"wm_exitsizemove\"),\n\t(563:\"wm_dropfiles\"),\n\t(564:\"wm_mdirefreshmenu\"),\n\t(641:\"wm_ime_setcontext\"),\n\t(642:\"wm_ime_notify\"),\n\t(643:\"wm_ime_control\"),\n\t(644:\"wm_ime_compositionfull\"),\n\t(645:\"wm_ime_select\"),\n\t(646:\"wm_ime_char\"),\n\t(656:\"wm_ime_keydown\"),\n\t(657:\"wm_ime_keyup\"),\n\t(673:\"wm_mousehover\"),\n\t(675:\"wm_mouseleave\"),\n\t(689:\"wm_wtssession_change\"),\n\t(768:\"wm_cut\"),\n\t(769:\"wm_copy\"),\n\t(770:\"wm_paste\"),\n\t(771:\"wm_clear\"),\n\t(772:\"wm_undo\"),\n\t(773:\"wm_renderformat\"),\n\t(774:\"wm_renderallformats\"),\n\t(775:\"wm_destroyclipboard\"),\n\t(776:\"wm_drawclipboard\"),\n\t(777:\"wm_paintclipboard\"),\n\t(778:\"wm_vscrollclipboard\"),\n\t(779:\"wm_sizeclipboard\"),\n\t(780:\"wm_askcbformatname\"),\n\t(781:\"wm_changecbchain\"),\n\t(782:\"wm_hscrollclipboard\"),\n\t(783:\"wm_querynewpalette\"),\n\t(784:\"wm_paletteischanging\"),\n\t(785:\"wm_palettechanged\"),\n\t(786:\"wm_hotkey\"),\n\t(791:\"wm_print\"),\n\t(792:\"wm_printclient\"),\n\t(896:\"wm_penwinirst\"),\n\t(911:\"wm_penwinlast\"),\n\t(1024:\"infotipsize\"),\n\t(1025:\"cbem_insertitema\"),\n\t(1026:\"cbem_setimagelist\"),\n\t(1027:\"cbem_getimagelist\"),\n\t(1028:\"cbem_getitema\"),\n\t(1029:\"cbem_setitema\"),\n\t(1030:\"cbem_getcombocontrol\"),\n\t(1031:\"cbem_geteditcontrol\"),\n\t(1032:\"cbem_setexstyle\"),\n\t(1033:\"cbem_getextendedstyle\"),\n\t(1034:\"cbem_haseditchanged\"),\n\t(1035:\"cbem_insertitemw\"),\n\t(1036:\"cbem_setitemw\"),\n\t(1037:\"cbem_getitemw\"),\n\t(1038:\"cbem_setextendedstyle\"),\n\t(1039:\"ttm_getcurrenttoola\"),\n\t(1040:\"ttm_windowfrompoint\"),\n\t(1041:\"ttm_trackactivate\"),\n\t(1042:\"ttm_trackposition\"),\n\t(1043:\"ttm_settipbkcolor\"),\n\t(1044:\"ttm_settiptextcolor\"),\n\t(1045:\"ttm_getdelaytime\"),\n\t(1046:\"ttm_gettipbkcolor\"),\n\t(1047:\"ttm_gettiptextcolor\"),\n\t(1048:\"ttm_setmaxtipwidth\"),\n\t(1049:\"ttm_getmaxtipwidth\"),\n\t(1050:\"ttm_setmargin\"),\n\t(1051:\"ttm_getmargin\"),\n\t(1052:\"ttm_pop\"),\n\t(1053:\"tb_getitemrect\"),\n\t(1054:\"tb_buttonstructsize\"),\n\t(1055:\"tb_setbuttonsize\"),\n\t(1056:\"tb_setbitmapsize\"),\n\t(1057:\"tb_autosize\"),\n\t(1059:\"tb_gettooltips\"),\n\t(1060:\"tb_settooltips\"),\n\t(1061:\"tb_setparent\"),\n\t(1063:\"tb_setrows\"),\n\t(1064:\"tb_getrows\"),\n\t(1065:\"tb_getbitmapflags\"),\n\t(1066:\"tb_setcmdid\"),\n\t(1067:\"tb_changebitmap\"),\n\t(1068:\"tb_getbitmap\"),\n\t(1069:\"tb_getbuttontexta\"),\n\t(1070:\"tb_replacebitmap\"),\n\t(1071:\"tb_setindent\"),\n\t(1072:\"tb_setimagelist\"),\n\t(1073:\"tb_getimagelist\"),\n\t(1074:\"ttm_addtoolw\"),\n\t(1075:\"ttm_deltoolw\"),\n\t(1076:\"ttm_newtoolrectw\"),\n\t(1077:\"ttm_gettoolinfow\"),\n\t(1078:\"ttm_settoolinfow\"),\n\t(1079:\"ttm_hittestw\"),\n\t(1080:\"ttm_gettextw\"),\n\t(1081:\"ttm_updatetiptextw\"),\n\t(1082:\"ttm_enumtoolsw\"),\n\t(1083:\"ttm_getcurrenttoolw\"),\n\t(1084:\"tb_setmaxtextrows\"),\n\t(1085:\"tb_gettextrows\"),\n\t(1086:\"em_getseltext\"),\n\t(1087:\"em_hideselection\"),\n\t(1088:\"em_pastespecial\"),\n\t(1089:\"em_requestresize\"),\n\t(1090:\"em_selectiontype\"),\n\t(1091:\"tb_insertbuttonw\"),\n\t(1092:\"tb_addbuttonsw\"),\n\t(1093:\"tb_hittest\"),\n\t(1094:\"em_setolecallback\"),\n\t(1095:\"em_setparaformat\"),\n\t(1096:\"em_settargetdevice\"),\n\t(1097:\"em_streamin\"),\n\t(1098:\"em_streamout\"),\n\t(1099:\"tb_getbuttontextw\"),\n\t(1100:\"tb_saverestorew\"),\n\t(1101:\"tb_addstringw\"),\n\t(1102:\"em_getoptions\"),\n\t(1103:\"tb_getinsertmark\"),\n\t(1104:\"tb_setinsertmark\"),\n\t(1105:\"tb_insertmarkhittest\"),\n\t(1106:\"tb_movebutton\"),\n\t(1107:\"tb_getmaxsize\"),\n\t(1108:\"tb_setextendedstyle\"),\n\t(1109:\"tb_getextendedstyle\"),\n\t(1110:\"tb_getpadding\"),\n\t(1111:\"tb_setpadding\"),\n\t(1112:\"tb_setinsertmarkcolor\"),\n\t(1113:\"tb_getinsertmarkcolor\"),\n\t(1114:\"tb_mapacceleratorw\"),\n\t(1124:\"em_setpunctuation\"),\n\t(1125:\"wm_choosefont_setlogfont\"),\n\t(1126:\"wm_choosefont_setflags\"),\n\t(1127:\"udm_setpos\"),\n\t(1128:\"udm_getpos\"),\n\t(1129:\"udm_setbuddy\"),\n\t(1130:\"udm_getbuddy\"),\n\t(1131:\"udm_setaccel\"),\n\t(1132:\"udm_getaccel\"),\n\t(1133:\"udm_setbase\"),\n\t(1134:\"udm_getbase\"),\n\t(1135:\"psm_settitlea\"),\n\t(1136:\"psm_setwizbuttons\"),\n\t(1137:\"psm_pressbutton\"),\n\t(1138:\"psm_setcurselid\"),\n\t(1139:\"psm_setfinishtexta\"),\n\t(1140:\"psm_gettabcontrol\"),\n\t(1141:\"psm_isdialogmessage\"),\n\t(1142:\"psm_getcurrentpagehwnd\"),\n\t(1144:\"psm_settitlew\"),\n\t(1145:\"psm_setfinishtextw\"),\n\t(1157:\"dl_begindrag\"),\n\t(1158:\"dl_dragging\"),\n\t(1159:\"dl_dropped\"),\n\t(1160:\"dl_canceldrag\"),\n\t(1280:\"en_errspace\"),\n\t(1281:\"en_maxtext\"),\n\t(1537:\"en_hscroll\"),\n\t(1538:\"en_vscroll\"),\n\t(1792:\"en_msgfilter\"),\n\t(1793:\"en_requestresize\"),\n\t(1794:\"en_selchange\"),\n\t(1795:\"en_dropfiles\"),\n\t(1796:\"en_protected\"),\n\t(1797:\"en_correcttext\"),\n\t(1798:\"en_stopnoundo\"),\n\t(1799:\"en_imechange\"),\n\t(1800:\"en_saveclipboard\"),\n\t(1801:\"en_oleopfailed\"),\n\t(4096:\"lvm_getbkcolor\"),\n\t(4097:\"lvm_setbkcolor\"),\n\t(4098:\"lvm_getimagelist\"),\n\t(4099:\"lvm_setimagelist\"),\n\t(4100:\"lvm_getitemcount\"),\n\t(4101:\"lvm_getitema\"),\n\t(4102:\"lvm_setitema\"),\n\t(4103:\"lvm_insertitema\"),\n\t(4104:\"lvm_deleteitem\"),\n\t(4105:\"lvm_deleteallitems\"),\n\t(4106:\"lvm_getcallbackmask\"),\n\t(4107:\"lvm_setcallbackmask\"),\n\t(4108:\"lvm_getnextitem\"),\n\t(4109:\"lvm_finditema\"),\n\t(4110:\"lvm_getitemrect\"),\n\t(4111:\"lvm_setitemposition\"),\n\t(4112:\"lvm_getitemposition\"),\n\t(4113:\"lvm_getstringwidtha\"),\n\t(4114:\"lvm_hittest\"),\n\t(4115:\"lvm_ensurevisible\"),\n\t(4116:\"lvm_scroll\"),\n\t(4117:\"lvm_redrawitems\"),\n\t(4118:\"lvm_arrange\"),\n\t(4119:\"lvm_editlabela\"),\n\t(4120:\"lvm_geteditcontrol\"),\n\t(4121:\"lvm_getcolumna\"),\n\t(4122:\"lvm_setcolumna\"),\n\t(4123:\"lvm_insertcolumna\"),\n\t(4124:\"lvm_deletecolumn\"),\n\t(4125:\"lvm_getcolumnwidth\"),\n\t(4126:\"lvm_setcolumnwidth\"),\n\t(4129:\"lvm_createdragimage\"),\n\t(4130:\"lvm_getviewrect\"),\n\t(4131:\"lvm_gettextcolor\"),\n\t(4132:\"lvm_settextcolor\"),\n\t(4133:\"lvm_gettextbkcolor\"),\n\t(4134:\"lvm_settextbkcolor\"),\n\t(4135:\"lvm_gettopindex\"),\n\t(4136:\"lvm_getcountperpage\"),\n\t(4137:\"lvm_getorigin\"),\n\t(4138:\"lvm_update\"),\n\t(4139:\"lvm_setitemstate\"),\n\t(4140:\"lvm_getitemstate\"),\n\t(4141:\"lvm_getitemtexta\"),\n\t(4142:\"lvm_setitemtexta\"),\n\t(4143:\"lvm_setitemcount\"),\n\t(4144:\"lvm_sortitems\"),\n\t(4145:\"lvm_setitemposition32\"),\n\t(4146:\"lvm_getselectedcount\"),\n\t(4147:\"lvm_getitemspacing\"),\n\t(4148:\"lvm_getisearchstringa\"),\n\t(4171:\"lvm_getitemw\"),\n\t(4172:\"lvm_setitemw\"),\n\t(4173:\"lvm_insertitemw\"),\n\t(4179:\"lvm_finditemw\"),\n\t(4183:\"lvm_getstringwidthw\"),\n\t(4191:\"lvm_getcolumnw\"),\n\t(4192:\"lvm_setcolumnw\"),\n\t(4193:\"lvm_insertcolumnw\"),\n\t(4211:\"lvm_getitemtextw\"),\n\t(4212:\"lvm_setitemtextw\"),\n\t(4213:\"lvm_getisearchstringw\"),\n\t(4214:\"lvm_editlabelw\"),\n\t(4352:\"tvm_insertitema\"),\n\t(4353:\"tvm_deleteitem\"),\n\t(4354:\"tvm_expand\"),\n\t(4356:\"tvm_getitemrect\"),\n\t(4357:\"tvm_getcount\"),\n\t(4358:\"tvm_getindent\"),\n\t(4359:\"tvm_setindent\"),\n\t(4360:\"tvm_getimagelist\"),\n\t(4361:\"tvm_setimagelist\"),\n\t(4362:\"tvm_getnextitem\"),\n\t(4363:\"tvm_selectitem\"),\n\t(4364:\"tvm_getitema\"),\n\t(4365:\"tvm_setitema\"),\n\t(4366:\"tvm_editlabela\"),\n\t(4367:\"tvm_geteditcontrol\"),\n\t(4368:\"tvm_getvisiblecount\"),\n\t(4369:\"tvm_hittest\"),\n\t(4370:\"tvm_createdragimage\"),\n\t(4371:\"tvm_sortchildren\"),\n\t(4372:\"tvm_ensurevisible\"),\n\t(4373:\"tvm_sortchildrencb\"),\n\t(4374:\"tvm_endeditlabelnow\"),\n\t(4375:\"tvm_getisearchstringa\"),\n\t(4402:\"tvm_insertitemw\"),\n\t(4414:\"tvm_getitemw\"),\n\t(4415:\"tvm_setitemw\"),\n\t(4416:\"tvm_getisearchstringw\"),\n\t(4417:\"tvm_editlabelw\"),\n\t(4608:\"hdm_getitemcount\"),\n\t(4609:\"hdm_insertitema\"),\n\t(4610:\"hdm_deleteitem\"),\n\t(4611:\"hdm_getitema\"),\n\t(4612:\"hdm_setitema\"),\n\t(4613:\"hdm_layout\"),\n\t(4614:\"hdm_hittest\"),\n\t(4618:\"hdm_insertitemw\"),\n\t(4619:\"hdm_getitemw\"),\n\t(4620:\"hdm_setitemw\"),\n\t(4864:\"tcm_first\"),\n\t(4866:\"tcm_getimagelist\"),\n\t(4867:\"tcm_setimagelist\"),\n\t(4868:\"tcm_getitemcount\"),\n\t(4869:\"tcm_getitema\"),\n\t(4870:\"tcm_setitema\"),\n\t(4871:\"tcm_insertitema\"),\n\t(4872:\"tcm_deleteitem\"),\n\t(4873:\"tcm_deleteallitems\"),\n\t(4874:\"tcm_getitemrect\"),\n\t(4875:\"tcm_getcursel\"),\n\t(4876:\"tcm_setcursel\"),\n\t(4877:\"tcm_hittest\"),\n\t(4878:\"tcm_setitemextra\"),\n\t(4904:\"tcm_adjustrect\"),\n\t(4905:\"tcm_setitemsize\"),\n\t(4906:\"tcm_removeimage\"),\n\t(4907:\"tcm_setpadding\"),\n\t(4908:\"tcm_getrowcount\"),\n\t(4909:\"tcm_gettooltips\"),\n\t(4910:\"tcm_settooltips\"),\n\t(4911:\"tcm_getcurfocus\"),\n\t(4912:\"tcm_setcurfocus\"),\n\t(4924:\"tcm_getitemw\"),\n\t(4925:\"tcm_setitemw\"),\n\t(4926:\"tcm_insertitemw\"),\n\t(5120:\"pgm_first\"),\n\t(8192:\"ccm_first\")]\n\nproc start=\nend\n",
(u64)"export enumdata optionnames =\n\t(wf_border,\t\t$),\t\t! wbs_simple\n\t(wf_resize,\t\t$),\t\t! 0\n\t(wf_hscroll,\t$),\t\t! 0\n\t(wf_vscroll,\t$),\t\t! 0\n\t(wf_menu,\t\t$),\t\t! 0\n\t(wf_caption,\t$),\t\t! 1\n\t(wf_max,\t\t$),\t\t! 0\n\t(wf_minmax,\t\t$),\t\t! 1\n\t(wf_sysmenu,\t$),\t\t! 1\n\t(wf_desktop,\t$),\t\t! 0\n\t(wf_clip,\t\t$),\t\t! 0\n\t(wf_show,\t\t$),\t\t!\n\t(wf_iframe,\t\t$),\t\t! 1\n\t(wf_cent,\t\t$),\t\t!\n\t(wf_toolwind,\t$)\t\t!\nend\n\n!Windows border styles, used for pop-up windows. Could also be used for\n!some child windows\nexport enumdata wbsnames=\n\t(wbs_none=0,$),\n\t(wbs_simple,$),\n\t(wbs_thick,$),\n\t(wbs_resize,$),\n\t(wbs_sunken,$),\n\t(wbs_sunken2,$),\n\t(wbs_sunkenrs,$),\n\t(wbs_dummy,$)\nend\n",
(u64)"\nexport var daynames=(\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\")\n\nexport var Monthnames=(\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\n\t\t\"August\",\"September\",\"October\",\"November\",\"December\")\n\nexport var days=(31,28,31, 30,31,30, 31,31,30, 31,30,31)\n\nexport record rdate=\n\tvar day,month,year\nend\n\nexport record rdatetime = \n\tvar\tday\n\tvar\tmonth\n\tvar\tyear\n\tvar\thour\n\tvar\tminute\n\tvar\tsecond\n\tvar\tmilliseconds\n\tvar\tdayofweek\nend\n\n!proc start=\n!end\n!\n!proc main=\n!end\n\nexport func makedatetime(d,m,y, h=0, minute=0, s=0)=\n\n\td:=rdatetime(d,m,y, h,minute,s,0,0)\n\td.dayofweek:=getdow(d)\n\treturn d\nend\n\nexport proc setdow(&d)=\n\td.dayofweek:=getdow(d)\nend\n\nexport func strdate(d,sep=\"-\")=\n!return leftstr(daynames[d.dayofweek],3)+\" \"+tostr(d.day)+sep+leftstr(monthnames[d.month],3)+sep+tostr(d.year)\n\treturn tostr(d.day)+sep+leftstr(monthnames[d.month],3)+sep+tostr(d.year)\nend\n\nexport func strtime(d,sep=\":\")=\n\treturn tostr(d.hour)+sep+tostr(d.minute,\"z2\")+sep+tostr(d.second,\"z2\")\nend\n\nexport func strdow(d,n=0)=\n\tif n then\n\t\treturn leftstr(daynames[d.dayofweek],n)\n\telse\n\t\treturn daynames[d.dayofweek]\n\tfi\nend\n\nexport func strdatetime(d,dsep=\"-\",tsep=\":\")=\n\treturn strdate(d,dsep)+\" \"+strtime(d,tsep)\nend\n\nexport func parsedate(s,defdate)=\n!parse string s into a new date record\n!def = default date to work from, eg. for missing year\n!return date record obtained, or 0 if error\n\n\tday:=defdate.day\n\tmonth:=defdate.month\n\tyear:=defdate.year\n\tif s.[1]=\" \" then s:=rightstr(s,-1) fi\n\n\tsepset:=[' ', '-', '/', '.']\n\n\tseppos:=0\n\tfor i:=1 to s.len do if s.[i] in sepset then seppos:=i; exit fi od\n\n\tif not seppos then\t\t!day only\n\t\tday:=strtoval(s)\n\t\tgoto gotday\n\tfi\n\tday:=strtoval(leftstr(s,seppos-1))\n\n\ts:=rightstr(s,-seppos)\t\t!month and possible year\n\tseppos:=0\n\tfor i:=1 to s.len do if s.[i] in sepset then seppos:=i; exit fi od\n\n\tif seppos then\n\t\tmonthstr:=leftstr(s,seppos-1)\n\t\tyearstr:=rightstr(s,s.len-seppos)\n\telse\n\t\tmonthstr:=s\n\t\tyearstr:=\"\"\n\tfi\n\n\tif asc(leftstr(monthstr)) in ['0'..'9'] then\t!numeric month\n\t\tmonth:=strtoval(monthstr)\n\t\tif month<1 or month>12 then\n\t\t\treturn 0\n\t\tfi\n\telse\n\t\tmonth:=0\n\t\tfor i:=1 to 12 do\n\t\t\tif convlc(leftstr(monthnames[i],3))=convlc(leftstr(monthstr,3)) then\n\t\t\t\tmonth:=i\n\t\t\t\texit\n\t\t\tfi\n\t\tod\n\t\tif not month then\n\t\t\treturn 0\n\t\tfi\n\tfi\n\n\tif yearstr<>\"\" then\n\t\tyear:=strtoval(yearstr)\n\t\tif year<200 then\n\t\t\tif year in [00..89] then\n\t\t\t\tyear+:=2000\n\t\t\telse\n\t\t\t\tyear+:=1900\n\t\t\tfi\n\t\tfi\n\tfi\n\ngotday:\n!check the date, rather than correct using addday(d,0)\n\tdd:=days[month] \n\tif leapyear(year) and month=2 then dd+:=1 fi\n\tif day<1 or day>dd then return 0 fi\n\tif year<1990 or year>2089 then return 0 fi\n\treturn makedatetime(day,month,year)\nend\n\nexport func leapyear(y)=\n!return true if y (eg. 1994) is a leap year\n\treturn (y-1900) rem 4=0\nend\n\nexport func getdow(d)=\n!return day of week for given date, returning 1..7 (monday..sunday)\n\treturn ((getday(d)-1) rem 7)+1\nend\n\nexport func getday(d)=\n!return day number for date d, measured from 1.1.90\n\tday:=0\n\tfor i:=1990 to d.year-1 do\n\t\tday+:=(leapyear(i)|366|365)\n\tod\n\n\tfor i:=1 to d.month-1 do\n\t\tday+:=(i=2|(leapyear(d.year)|29|28)|days[i])\n\tod\n\tday+:=d.day\n\treturn day\nend\n\nexport func getdays(m,y)=\n!return no. of days in month m, for year y\n\tif leapyear(y) and m=2 then return 29 fi\n\treturn days[m]\nend\n\nexport func getmonthname(m,?n)=\n\tif not m.isint then\n\t\tm:=m.month\n\tfi\n\tm:=monthnames[m]\n\tif n.defined then m:=leftstr(m,n) fi\n\treturn m\nend\n\nexport func getdayname(d,?n)=\n\tif not d.isint then\n\t\td:=getdow(d)\n\tfi\n\td:=daynames[d]\n\tif n.defined then d:=leftstr(d,n) fi\n\treturn d\nend\n\nexport func addday(d0,i)=\n\td:=d0\n\tif i>0 then\n\t\tto i do\n\t\t\t++d.day\n\t\t\tif d.day>getdays(d.month,d.year) then\n\t\t\t\td.day:=1\n\t\t\t\t++d.month\n\t\t\t\tif d.month>12 then\n\t\t\t\t\td.month:=1\n\t\t\t\t\t++d.year\n\t\t\t\tfi\n\t\t\tfi\n\t\tod\n\telse\n\t\tto -i do\n\t\t\t--d.day\n\t\t\tif d.day<1 then\n\t\t\t\t--d.month\n\t\t\t\tif d.month<1 then\n\t\t\t\t\td.month:=12\n\t\t\t\t\t--d.year\n\t\t\t\tfi\n\t\t\t\td.day:=getdays(d.month,d.year)\n\t\t\tfi\n\t\tod\n\tfi\n\n!do checking\n\tif d.year<1990 then d:=makedatetime(1,1,1990) fi\n\tif d.year>2089 then d:=makedatetime(31,12,2089) fi\n\n\tdd:=getdays(d.month,d.year)\n\tif leapyear(d.year) and d.month=2 then dd+:=1 fi\n\tif d.day<1 then d.day:=1 fi\n\tif d.day>dd then d.day:=dd fi\n\tsetdow(d)\n\treturn d\nend\n\nexport func getdatetime=\n\ttm:=getsystime()\n\n\treturn rdatetime(tm.day,tm.month,tm.year,\n\t\t\ttm.hour, tm.minute, tm.second, tm.milliseconds,tm.dayofweek)\nend\n\nexport func getsystime=\n\ttm:=new(ws_systemtime)\n\tgetsystemtime(&tm)\n\n\tif tm.dayofweek=0 then\n\t\ttm.dayofweek:=7\n\tfi\n\n\treturn tm\nend\n"}};

static struct $B44 qq_tables_stdtypenames = {{
(u64)"void",
(u64)"int",
(u64)"real",
(u64)"decimal",
(u64)"range",
(u64)"set",
(u64)"dict",
(u64)"vector",
(u64)"bits",
(u64)"string",
(u64)"list",
(u64)"array",
(u64)"record",
(u64)"struct",
(u64)"refvar",
(u64)"refbit",
(u64)"refpack",
(u64)"symbol",
(u64)"type",
(u64)"operator",
(u64)"retaddr",
(u64)"except",
(u64)"number",
(u64)"i8",
(u64)"i16",
(u64)"i32",
(u64)"i64",
(u64)"u8",
(u64)"u16",
(u64)"u32",
(u64)"u64",
(u64)"r32",
(u64)"r64",
(u64)"u1",
(u64)"u2",
(u64)"u4",
(u64)"packstrc",
(u64)"packstrz",
(u64)"stringz",
(u64)"refproc",
(u64)"slice"}};

static struct $B45 qq_tables_stdtypewidths = {{
0,
64,
64,
0,
64,
0,
0,
0,
0,
0,
0,
0,
0,
0,
64,
128,
64,
64,
64,
64,
0,
0,
0,
8,
16,
32,
64,
8,
16,
32,
64,
32,
64,
1,
2,
4,
0,
0,
64,
64,
0}};

static struct $B46 qq_tables_jtagnames = {{
(u64)"jnone",
(u64)"jlabeldef",
(u64)"jassign",
(u64)"jkeyword",
(u64)"jkeyvalue",
(u64)"joperator",
(u64)"jblock",
(u64)"jif",
(u64)"jselect",
(u64)"jwhenthen",
(u64)"jcase",
(u64)"jdocase",
(u64)"jswitch",
(u64)"jdoswitch",
(u64)"jrecase",
(u64)"jfor",
(u64)"jforx",
(u64)"jforall",
(u64)"jforeach",
(u64)"jdo",
(u64)"jto",
(u64)"jwhile",
(u64)"jrepeat",
(u64)"jtry",
(u64)"jexcept",
(u64)"jraise",
(u64)"jcall",
(u64)"jcallhost",
(u64)"jnil",
(u64)"jswap",
(u64)"jgoto",
(u64)"jstop",
(u64)"jreturn",
(u64)"jeval",
(u64)"jtypeconst",
(u64)"jconvert",
(u64)"jtypepun",
(u64)"jmap",
(u64)"jcmpchain",
(u64)"jname",
(u64)"jsymbol",
(u64)"jintconst",
(u64)"jrealconst",
(u64)"jstringconst",
(u64)"jdecimal",
(u64)"jstrinclude",
(u64)"jdot",
(u64)"jindex",
(u64)"jdotindex",
(u64)"jkeyindex",
(u64)"jloop",
(u64)"jptr",
(u64)"jaddrof",
(u64)"jvoid",
(u64)"jprint",
(u64)"jfprint",
(u64)"jnogap",
(u64)"jspace",
(u64)"jfmtitem",
(u64)"jread",
(u64)"jincrload",
(u64)"jloadincr",
(u64)"junary",
(u64)"jbin",
(u64)"jmaths",
(u64)"jmaths2",
(u64)"jproperty",
(u64)"jbounds",
(u64)"jgettype",
(u64)"jistype",
(u64)"jisvoid",
(u64)"jcmp",
(u64)"jandl",
(u64)"jorl",
(u64)"jnotl",
(u64)"jistruel",
(u64)"jin",
(u64)"jinx",
(u64)"junaryto",
(u64)"jbinto",
(u64)"jandlto",
(u64)"jorlto",
(u64)"jnotlto",
(u64)"jistruelto",
(u64)"jappendto",
(u64)"jconcatto",
(u64)"jidivrem",
(u64)"jmakerange",
(u64)"jmakelist",
(u64)"jmakeset",
(u64)"jmakedict",
(u64)"jcvattr"}};

static struct $B47 qq_tables_jflags = {{
33685760,
33619970,
33686018,
33620482,
16908802,
33686018,
16908546,
16843264,
16777473,
66049,
1,
33685760,
16908802,
33685505,
33685504,
33620225,
16843265,
33620225,
16843266,
33620482,
16843266,
33554946,
65793}};

static struct $B47 qq_tables_jhasvalue = {{
16908288,
33685761,
131074,
2,
0,
0,
16842752,
1,
16842754,
16843009,
16843009,
16843009,
16777473,
257,
0,
16843009,
16843009,
16843009,
16843009,
65793,
0,
16908288,
16843009}};

static struct $B48 qq_tables_symbolnames = {{
491496043109,
7630692,
418447716195,
1768777075,
474315779939,
121390429860705,
122545691846003,
1701865840,
118074580820588,
118074580820594,
7435116,
7435122,
133506683724652,
133506683724658,
7500912,
7496034,
29793,
7957695015460107633,
1919181921,
435526984050,
8316305113558576229,
6579297,
6452595,
7107949,
7760228,
1986618473,
1835364969,
30792314748757097,
1818521185,
7107183,
1684955497,
7499625,
1919907945,
7104627,
7497843,
132359843113325,
110425311047777,
127961628831587,
28265,
7892585,
491328597872,
1701667187,
29029,
25966,
29804,
25964,
25959,
29799,
1819570030,
1953459817,
30510852590564201,
7561825,
6517601,
7497827,
495673696621,
55471255085421,
1886351984,
111533748417385,
110404004377449,
1919118953,
7106405,
6713189,
8391171955410366057,
8391171955409249636,
32778015450820710,
8391171955410233443,
8391171955410236531,
7308604897319546485,
1701667182,
28552639593870451,
491260502889,
26217,
1852139636,
439855836261,
1702063205,
7310293699684166757,
131337507007589,
30510843782458469,
6581861,
126939460038261,
1702060387,
111546229548402,
1852139639,
7499622,
28532,
31074,
28516,
435610544247,
127961662514546,
465625706101,
121437875889522,
1886352499,
1886351212,
1869901671,
114776364119923,
500068610672,
128017564332147,
1684104562,
1668248176,
1668183398,
465557414252,
110442657834354,
127970521019507,
474315583093,
111516500389741,
128034844732777,
28275532515798377,
1701869940,
6710642,
7496054,
478660485485,
28783,
500152823651,
119165519096935,
109304575259763,
121390429397347,
7959156,
128026086176869,
435727982962,
1953718627,
32195308665270115,
125762756439908,
1818326629,
27431034385752436,
7364973,
482871438435,
1885435763,
8391171955410303347,
121386319441768,
7104878,
30508623351411827,
123623711273075}};

static struct $B49 qq_tables_namenames = {{
(u64)"genericid",
(u64)"programid",
(u64)"subprogid",
(u64)"moduleid",
(u64)"dllmoduleid",
(u64)"procid",
(u64)"anonprocid",
(u64)"dllprocid",
(u64)"dllvarid",
(u64)"recordid",
(u64)"typeid",
(u64)"fieldid",
(u64)"structfieldid",
(u64)"staticid",
(u64)"frameid",
(u64)"paramid",
(u64)"dllparamid",
(u64)"labelid",
(u64)"constid",
(u64)"enumid",
(u64)"aliasid",
(u64)"linkid",
(u64)"macroid",
(u64)"macroparamid",
(u64)"structblockid",
(u64)"unionblockid",
(u64)"endblockid"}};

static struct $B8 qq_tables_objtypenames = {{
(u64)"normal_obj",
(u64)"slice_obj",
(u64)"extslice_obj"}};

static struct $B8 qq_tables_scopenames = {{
(u64)"local_scope",
(u64)"global_scope",
(u64)"export_scope"}};

static struct $B50 qq_tables_stnames = {{
(u64)"if",
(u64)"then",
(u64)"elsif",
(u64)"else",
(u64)"elsecase",
(u64)"elseswitch",
(u64)"case",
(u64)"docase",
(u64)"recase",
(u64)"when",
(u64)"for",
(u64)"foreach",
(u64)"to",
(u64)"downto",
(u64)"by",
(u64)"do",
(u64)"end",
(u64)"while",
(u64)"repeat",
(u64)"until",
(u64)"always",
(u64)"return",
(u64)"stop",
(u64)"redoloop",
(u64)"nextloop",
(u64)"exit",
(u64)"goto",
(u64)"switch",
(u64)"doswitch",
(u64)"tabledata",
(u64)"enumdata",
(u64)"clamp",
(u64)"maps",
(u64)"mapss",
(u64)"eval",
(u64)"print",
(u64)"println",
(u64)"fprint",
(u64)"fprintln",
(u64)"sprint",
(u64)"sfprint",
(u64)"cp",
(u64)"cpl",
(u64)"read",
(u64)"readln",
(u64)"cast",
(u64)"proc",
(u64)"sub",
(u64)"function",
(u64)"func",
(u64)"fun",
(u64)"method",
(u64)"type",
(u64)"record",
(u64)"struct",
(u64)"union",
(u64)"ref",
(u64)"var",
(u64)"macro",
(u64)"static",
(u64)"$caligned",
(u64)"const",
(u64)"module",
(u64)"import",
(u64)"importdll",
(u64)"strinclude",
(u64)"unless",
(u64)"try",
(u64)"except",
(u64)"raise",
(u64)"global",
(u64)"export",
(u64)"swap",
(u64)"void",
(u64)"int",
(u64)"real",
(u64)"string",
(u64)"list",
(u64)"array",
(u64)"vector",
(u64)"bits",
(u64)"set",
(u64)"dict",
(u64)"decimal",
(u64)"longint",
(u64)"typetype",
(u64)"range",
(u64)"recordtype",
(u64)"cvoid",
(u64)"i8",
(u64)"i16",
(u64)"i32",
(u64)"i64",
(u64)"bit",
(u64)"u1",
(u64)"u2",
(u64)"u4",
(u64)"byte",
(u64)"u8",
(u64)"u16",
(u64)"u32",
(u64)"u64",
(u64)"r32",
(u64)"r64",
(u64)"stringc",
(u64)"stringz",
(u64)"cstring",
(u64)"ichar",
(u64)"million",
(u64)"billion",
(u64)"as",
(u64)"$lineno",
(u64)"$strlineno",
(u64)"$filename",
(u64)"$modulename",
(u64)"$function",
(u64)"$date",
(u64)"$time",
(u64)"$",
(u64)"and",
(u64)"or",
(u64)"iand",
(u64)"ior",
(u64)"ixor",
(u64)"in",
(u64)"inx",
(u64)"rem",
(u64)"divrem",
(u64)"min",
(u64)"max",
(u64)"not",
(u64)"istrue",
(u64)"inot",
(u64)"abs",
(u64)"asc",
(u64)"chr",
(u64)"sqrt",
(u64)"sqr",
(u64)"cos",
(u64)"sin",
(u64)"tan",
(u64)"asin",
(u64)"acos",
(u64)"atan",
(u64)"atan2",
(u64)"sign",
(u64)"log",
(u64)"log10",
(u64)"exp",
(u64)"round",
(u64)"floor",
(u64)"ceil",
(u64)"fract",
(u64)"fmod",
(u64)"append",
(u64)"concat",
(u64)"len",
(u64)"lwb",
(u64)"upb",
(u64)"bounds",
(u64)"bytes",
(u64)"isfound",
(u64)"dictitems",
(u64)"basetype",
(u64)"elemtype",
(u64)"isvoid",
(u64)"isdef",
(u64)"defined",
(u64)"isint",
(u64)"isreal",
(u64)"islist",
(u64)"isstring",
(u64)"isrange",
(u64)"ispointer",
(u64)"isarray",
(u64)"isrecord",
(u64)"isset",
(u64)"isnumber",
(u64)"fi",
(u64)"esac",
(u64)"od",
(u64)"nil",
(u64)"con",
(u64)"pi",
(u64)"true",
(u64)"false",
(u64)"$neg",
(u64)"$$dummy"}};

static struct $B51 qq_tables_stsymbols = {{
1263159624,
1364282700,
1414812498,
1465275733,
1515804751,
1566333786,
1600019805,
2122087519,
1618705789,
1633706080,
1650483297,
1667463266,
1684300900,
1751606892,
1936682605,
1785295220,
1968210795,
1920104310,
1179010687,
1179010630,
1179010630,
1179010630,
1179010630,
1179010630,
1179010630,
1179010630,
1179010630,
2034517060,
2038004089,
494565753,
555753246,
471541799,
858858532,
909456434,
926365495,
926365495,
926365496,
926365495,
639973431,
960051513,
993605945,
993737531,
976894522,
976894522,
1330592314,
2155905615,
8683648}};

static struct $B51 qq_tables_stsubcodes = {{
458752,
185207818,
16777230,
256,
0,
16777216,
201327362,
65549,
0,
67305985,
65542,
16780545,
65536,
0,
0,
0,
68,
33619968,
33619968,
118163977,
50726152,
201593347,
421009152,
572596506,
471538467,
538910237,
639968548,
16777986,
84148994,
1207961350,
1852664905,
1802108928,
1263170932,
1364216910,
50594305,
134678021,
185207058,
252579084,
1987514640,
1515804759,
1650286171,
1684305509,
151650817,
202051076,
1363678725,
16973911,
2950404}};

static struct $B52 qq_tables_hostfnnames = {{
(u64)"h_dummy",
(u64)"h_startprint",
(u64)"h_startprintcon",
(u64)"h_strstartprint",
(u64)"h_setformat",
(u64)"h_endprint",
(u64)"h_strendprint",
(u64)"h_print",
(u64)"h_print_nf",
(u64)"h_println",
(u64)"h_printnogap",
(u64)"h_printspace",
(u64)"h_readln",
(u64)"h_sreadln",
(u64)"h_sread",
(u64)"h_rereadln",
(u64)"h_reread",
(u64)"h_strtoval",
(u64)"h_tostr",
(u64)"h_leftstr",
(u64)"h_rightstr",
(u64)"h_convlc",
(u64)"h_convuc",
(u64)"h_waitkey",
(u64)"h_testkey",
(u64)"h_execwait",
(u64)"h_execcmd",
(u64)"h_system",
(u64)"h_makestr",
(u64)"h_makeref",
(u64)"h_new",
(u64)"h_getcmdparam",
(u64)"h_gethostname",
(u64)"h_getprogname",
(u64)"h_$setdebug",
(u64)"h_$test2",
(u64)"h_$test",
(u64)"h_$refcount",
(u64)"h_ticks",
(u64)"h_clock",
(u64)"h_sleep",
(u64)"h_random",
(u64)"h_gethash",
(u64)"h_getos",
(u64)"h_iswindows",
(u64)"h_setmesshandler",
(u64)"h_$getparam",
(u64)"h_makeempty",
(u64)"h_$smallmemtotal",
(u64)"h_$id",
(u64)"h_copy",
(u64)"h_$nan",
(u64)"h_$infinity",
(u64)"h_$nprocs",
(u64)"h_$procname",
(u64)"h_$procref",
(u64)"h_allocexec",
(u64)"h_runnative",
(u64)"h_setlwb",
(u64)"h_last"}};

static struct $B53 qq_tables_hostnparams = {{
256,
33554433,
1,
65793,
50463232,
131587,
16974592,
17039874,
33619968,
259,
65793,
16843008,
65792,
16842752,
131585}};

static struct $B53 qq_tables_hostisfn = {{
0,
65536,
0,
65792,
16843008,
16843009,
16843009,
16843009,
16777473,
16843009,
16843008,
16842753,
16843009,
16843009,
257}};

static struct $B53 qq_tables_hostinternal = {{
16843009,
16843009,
16843009,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
16777216}};

static struct $B52 qq_tables_hosthandlers = {{
0,
(u64)&qq_print_pch_startprint,
(u64)&qq_print_pch_startprintcon,
(u64)&qq_print_pch_strstartprint,
(u64)&qq_print_pch_setformat,
(u64)&qq_print_pch_endprint,
(u64)&qq_print_pch_strendprint,
(u64)&qq_print_pch_print,
(u64)&qq_print_pch_print_nf,
(u64)&qq_print_pch_println,
(u64)&qq_print_pch_printnogap,
(u64)&qq_print_pch_printspace,
(u64)&qq_print_pch_readln,
(u64)&qq_print_pch_sreadln,
(u64)&qq_print_pch_sread,
(u64)&qq_print_pch_rereadln,
(u64)&qq_print_pch_reread,
(u64)&qq_print_pch_strtoval,
(u64)&qq_print_pch_tostr,
(u64)&qq_host_pch_leftstr,
(u64)&qq_host_pch_rightstr,
(u64)&qq_host_pch_convlc,
(u64)&qq_host_pch_convuc,
(u64)&qq_host_pch_waitkey,
(u64)&qq_host_pch_testkey,
(u64)&qq_host_pch_execwait,
(u64)&qq_host_pch_execcmd,
(u64)&qq_host_pch_system,
(u64)&qq_host_pch_makestr,
(u64)&qq_host_pch_makeref,
(u64)&qq_host_pch_new,
(u64)&qq_host_pch_getcmdparam,
(u64)&qq_host_pch_gethostname,
(u64)&qq_host_pch_getprogname,
(u64)&qq_host_pch_$setdebug,
(u64)&qq_host_pch_$test2,
(u64)&qq_host_pch_$test,
(u64)&qq_host_pch_$refcount,
(u64)&qq_host_pch_ticks,
(u64)&qq_host_pch_clock,
(u64)&qq_host_pch_sleep,
(u64)&qq_host_pch_random,
(u64)&qq_host_pch_gethash,
(u64)&qq_host_pch_getos,
(u64)&qq_host_pch_iswindows,
(u64)&qq_host_pch_setmesshandler,
(u64)&qq_host_pch_$getparam,
(u64)&qq_host_pch_makeempty,
(u64)&qq_host_pch_$smallmemtotal,
(u64)&qq_host_pch_$id,
(u64)&qq_host_pch_copy,
(u64)&qq_host_pch_$nan,
(u64)&qq_host_pch_$infinity,
(u64)&qq_host_pch_$nprocs,
(u64)&qq_host_pch_$procname,
(u64)&qq_host_pch_$procref,
(u64)&qq_host_pch_allocexec,
(u64)&qq_host_pch_runnative,
(u64)&qq_host_pch_setlwb,
0}};

static struct $B54 qq_tables_d_binopset = {{
29,
30,
43,
44,
45,
46,
48,
47,
22,
23,
24,
25,
26,
27,
31,
32,
33,
34,
35,
36,
38,
41,
28,
56,
37,
19,
42}};

static struct $B55 qq_tables_binopset;
static struct $B56 qq_tables_d_unaryopset = {{
49,
50,
52,
51,
53,
54,
55}};

static struct $B55 qq_tables_unaryopset;
static struct $B2 qq_tables_d_addopset = {{
5910,
8223,
9761,
9253,
10771}};

static struct $B42 qq_tables_d_cmpopset = {{
11307,
11821,
12335}};

static struct $B56 qq_tables_d_mulopset = {{
24,
25,
26,
27,
34,
35,
28}};

static struct $B55 qq_tables_addopset;
static struct $B55 qq_tables_cmpopset;
static struct $B55 qq_tables_mulopset;
static struct $B55 qq_tables_exprendset;
static struct $B57 qq_tables_d_exprstarterset = {{
9,
11,
15,
19,
69,
60,
63,
64,
65,
66,
67,
70,
125,
13,
97,
122,
121,
126,
109,
120,
21,
130,
129,
72,
102,
103}};

static struct $B58 qq_tables_exprstarterset;
static struct $B59 qq_tables_ttname;
static struct $B59 qq_tables_ttnamedef;
static struct $B60 qq_tables_ttbasetype;
static struct $B60 qq_tables_tttarget;
static struct $B59 qq_tables_ttlower;
static struct $B59 qq_tables_ttlength;
static struct $B59 qq_tables_ttlowerexpr;
static struct $B59 qq_tables_ttlengthexpr;
static struct $B59 qq_tables_ttsize;
static struct $B61 qq_tables_ttbitwidth;
static struct $B59 qq_tables_ttfields;
static struct $B61 qq_tables_ttcaligned;
static struct $B59 qq_tables_ttowner;
static i64 qq_tables_ntypes;
static i64 qq_tables_firstusertype;
static i64 qq_tables_nuserxtypes;
static i64 qq_tables_userxtypebase;
static u64 qq_tables_userxmodelist;
static struct $B62 qq_tables_ttnamedefx;
static struct $B62 qq_tables_ttxmap;
static struct $B63 qq_tables_ttxmoduleno;
static struct $B53 qq_tables_hostlvset;
static struct $B64 qq_tables_cvnames = {{
(u64)"cv_lineno",
(u64)"cv_strlineno",
(u64)"cv_filename",
(u64)"cv_modulename",
(u64)"cv_function",
(u64)"cv_date",
(u64)"cv_time"}};

static struct $B8 qq_tables_loopnames = {{
(u64)"loop_redo",
(u64)"loop_next",
(u64)"loop_exit"}};

static struct $B37 qq_tables_mathsnames = {{
(u64)"mm_sqrt",
(u64)"mm_sqr",
(u64)"mm_sin",
(u64)"mm_cos",
(u64)"mm_tan",
(u64)"mm_asin",
(u64)"mm_acos",
(u64)"mm_atan",
(u64)"mm_sign",
(u64)"mm_log",
(u64)"mm_log10",
(u64)"mm_exp",
(u64)"mm_round",
(u64)"mm_floor",
(u64)"mm_ceil",
(u64)"mm_fract",
(u64)"mm_fmod",
(u64)"mm_atan2"}};

static struct $B12 qq_tables_condnames = {{
(u64)"eq",
(u64)"ne",
(u64)"lt",
(u64)"le",
(u64)"ge",
(u64)"gt"}};

static struct $B42 qq_tables_revconds = {{
1,
1284,
770}};

static u64 qq_show_labelmap;
static i64 qq_show_currlineno;
static u64 qq_show_currpclproc;
static struct $B3 qq_show_pclv;
static u64 qq_show_pcldest = (u64)&qq_show_pclv;

static struct $B65 qq_show_getprefix_str;
static struct $B66 qq_show_getlineinfok_str;
// Istatic skipped:qq_show.showmoduleinfo.tab

static struct $B24 qq_show_strmode_str;
static struct $B24 qq_show_istrmode_str;
static i64 qq_showpcl_currlineno;
static u64 qq_showpcl_currpclproc;
static struct $B25 qq_showpcl_writepclopnd_str;
static struct $B25 qq_showpcl_writepclopnd_str2;
static struct $B32 qq_vars_zeroobj;
static void msysc_$getcommands(i64 ncmd, u64 cmds, i64 cmdskipl) {
    u64 R1, R2; 
	msysc_m$print_startcon();
	R1 = tou64("$CMDSKIP=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = msysc_$cmdskip;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("CMDSKIPL=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = cmdskipl;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = ncmd;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_ncmdparams = asi64(R1);
	asu64(R1) = cmds;
	msysc_cmdparams = asu64(R1);
	return;
}

static void msysc_pushio() {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_niostack;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L4;
	R1 = tou64("Too many io levels\n");
	asi32(R1) = printf(asu64(R1));
	R1 = 53;
	exit(R1);
L4:
	R1 = (u64)&msysc_niostack;
	(*toi64p(R1)) += 1;
	asu64(R1) = msysc_outchan;
	R2 = (u64)&msysc_outchan_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = msysc_outdev;
	R2 = (u64)&msysc_outdev_stack;
	asi64(R3) = msysc_niostack;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = msysc_fmtstr;
	R2 = (u64)&msysc_fmtstr_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = msysc_needgap;
	R2 = (u64)&msysc_needgap_stack;
	asi64(R3) = msysc_niostack;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 0;
	msysc_fmtstr = asu64(R1);
	R1 = 0;
	msysc_outchan = asu64(R1);
	return;
}

static void msysc_m$print_startfile(u64 dev) {
    u64 R1; 
	msysc_pushio();
	asu64(R1) = dev;
	msysc_outchan = asu64(R1);
	asu64(R1) = dev;
	if (!asu64(R1)) goto L7;
	R1 = 2;
	msysc_outdev = asi64(R1);
	goto L6;
L7:
	R1 = 1;
	msysc_outdev = asi64(R1);
L6:
	msysc_resetprintbuffer();
	return;
}

static void msysc_m$print_startstr(u64 s) {
    u64 R1, R2, R3; 
	u64 p;
	msysc_pushio();
	asu64(R1) = s;
	R2 = (u64)&msysc_ptr_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&msysc_ptr_stack;
	asi64(R2) = msysc_niostack;
	R1 += (i64)R2*8-8;
	p = asu64(R1);
	asu64(R1) = p;
	msysc_outchan = asu64(R1);
	R1 = 3;
	msysc_outdev = asi64(R1);
	return;
}

static void msysc_m$print_startptr(u64 p) {
    u64 R1; 
	msysc_pushio();
	asu64(R1) = p;
	msysc_outchan = asu64(R1);
	R1 = 3;
	msysc_outdev = asi64(R1);
	return;
}

static void msysc_m$print_startcon() {
    u64 R1; 
	msysc_pushio();
	R1 = 1;
	msysc_outdev = asi64(R1);
	msysc_resetprintbuffer();
	return;
}

static void msysc_m$print_setfmt(u64 format) {
    u64 R1; 
	asu64(R1) = format;
	msysc_fmtstr = asu64(R1);
	return;
}

static void msysc_m$print_end() {
    u64 R1, R2; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 1;
	msysc_nextfmtchars(asi64(R1));
	asi64(R1) = msysc_niostack;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L14;
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L15;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L14;
L15:
	msysc_dumpprintbuffer();
L14:
	asi64(R1) = msysc_niostack;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L17;
	goto L12;
L17:
	R1 = (u64)&msysc_outchan_stack;
	asi64(R2) = msysc_niostack;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_outchan = asu64(R1);
	R1 = (u64)&msysc_outdev_stack;
	asi64(R2) = msysc_niostack;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	msysc_outdev = asi64(R1);
	R1 = (u64)&msysc_fmtstr_stack;
	asi64(R2) = msysc_niostack;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_fmtstr = asu64(R1);
	R1 = (u64)&msysc_needgap_stack;
	asi64(R2) = msysc_niostack;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	msysc_needgap = asi64(R1);
	R1 = (u64)&msysc_niostack;
	(*toi64p(R1)) -=1;
L12:
	return;
}

static void msysc_m$print_ptr(u64 a, u64 fmtstyle) {
    u64 R1, R2; 
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L20;
	R1 = tou64("z8H");
	fmtstyle = asu64(R1);
L20:
	asu64(R1) = fmtstyle;
	asu64(R2) = a;
	msysc_m$print_u64(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_ptr_nf(u64 a) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = a;
	msysc_m$print_ptr(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_i64(i64 a, u64 fmtstyle) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	struct $B66 s;
	struct $B3 fmt;
	i64 n;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L24;
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L26;
	R1 = 0;
	R2 = 10;
	R3 = (u64)&s;
	asi64(R4) = a;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
	goto L25;
L26:
	asi64(R1) = a;
	R2 = 0x8000000000000000;
	if (asi64(R1) != asi64(R2)) goto L27;
	(R1_B3) = msysc_defaultfmt;
	fmt = (R1_B3);
	goto L28;
	goto L25;
L27:
	R1 = 45;
	R2 = (u64)&s;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = 10;
	R3 = (u64)&s;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R4) = a;
	asi64(R4) = -asi64(R4);
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
L25:
	asi64(R1) = n;
	R2 = (u64)&s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L23;
L24:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = 14;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 86;
	if (asu64(R1) != asu64(R2)) goto L30;
	asi64(R1) = a;
	msysc_fmtparam = asi64(R1);
	R1 = 0;
	msysc_needgap = asi64(R1);
	goto L29;
L30:
// msysc.m$print_i64.dofmt:
L28:
	R1 = (u64)&fmt;
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
L29:
L23:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_i64_nf(i64 a) {
    u64 R1, R2; 
	R1 = 0;
	asi64(R2) = a;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	return;
}

static void msysc_m$print_bool(i64 a, u64 fmtstyle) {
    u64 R1, R2; 
	asi64(R1) = a;
	if (!asi64(R1)) goto L34;
	asu64(R1) = fmtstyle;
	R2 = tou64("True");
	msysc_m$print_str(asu64(R2), asu64(R1));
	goto L33;
L34:
	asu64(R1) = fmtstyle;
	R2 = tou64("False");
	msysc_m$print_str(asu64(R2), asu64(R1));
L33:
	return;
}

static void msysc_m$print_u64(u64 a, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B66 s;
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L37;
	asu64(R1) = a;
	R2 = tou64("%llu");
	R3 = (u64)&s;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&s;
	msysc_printstr(asu64(R1));
	goto L36;
L37:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asu64(R2) = a;
	msysc_tostr_u64(asu64(R2), asu64(R1));
L36:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_r64(r64 x, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B71 s;
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L40;
	asr64(R1) = x;
	R2 = tou64("%f");
	R3 = (u64)&s;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asr64(R1));
	R1 = (u64)&s;
	msysc_printstr(asu64(R1));
	goto L39;
L40:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asr64(R2) = x;
	msysc_tostr_r64(asr64(R2), asu64(R1));
L39:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_r32(r32 x, u64 fmtstyle) {
    u64 R1, R2; 
	asu64(R1) = fmtstyle;
	asr32(R2) = x;
    asr64(R2) = tor64(asr32(R2));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	return;
}

static void msysc_m$print_c8(i64 a, u64 fmtstyle) {
    u64 R1, R2, R3, R4; 
	struct $B32 s;
	struct $B3 fmt;
	i64 n;
	u8 charmode;
	R1 = 0;
	charmode = asu8(R1);
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	if (!asu64(R1)) goto L44;
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	charmode = asu8(R1);
L44:
	asu8(R1) = charmode;
	R1 = toi64(tou8(R1));
	R2 = 77;
	if (asi64(R1) != asi64(R2)) goto L46;
	R1 = (u64)&fmt;
	R2 = (u64)&s;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L45;
L46:
	asi64(R1) = a;
	R2 = (u64)&s;
	*toi64p(R2) = asi64(R1);
	R1 = 0;
	R2 = (u64)&s;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&s;
	asi64(R1) = msysc_getutfsize(asu64(R1));
	n = asi64(R1);
L45:
	asi64(R1) = n;
	R2 = (u64)&s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_str(u64 s, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L49;
	R1 = tou64("<null>");
	msysc_printstr(asu64(R1));
	goto L47;
L49:
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L51;
	asu64(R1) = s;
	msysc_printstr(asu64(R1));
	goto L50;
L51:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = s;
	msysc_tostr_str(asu64(R3), asi64(R2), asu64(R1));
L50:
	R1 = 1;
	msysc_needgap = asi64(R1);
L47:
	return;
}

static void msysc_m$print_strn(u64 s, i64 length, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L54;
	R1 = tou64("<null>");
	msysc_printstr(asu64(R1));
	goto L52;
L54:
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L56;
	asi64(R1) = length;
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L55;
L56:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asi64(R2) = length;
	asu64(R3) = s;
	msysc_tostr_str(asu64(R3), asi64(R2), asu64(R1));
L55:
	R1 = 1;
	msysc_needgap = asi64(R1);
L52:
	return;
}

static void msysc_m$print_str_nf(u64 s) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = s;
	msysc_m$print_str(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_strsl(struct $B3 s, u64 fmtstyle) {
    u64 R1; 
	R1 = tou64("PRTSL");
	mlib_abortprogram(asu64(R1));
	return;
}

static void msysc_m$print_newline() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 1;
	msysc_nextfmtchars(asi64(R1));
	R1 = tou64("\r\n");
	msysc_printstr(asu64(R1));
	return;
}

static void msysc_m$print_nogap() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_space() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = tou64(" ");
	msysc_printstr(asu64(R1));
	return;
}

static void msysc_printstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_printstr_n(u64 s, i64 n) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = n;
	asu64(R3) = s;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void msysc_printstrn_app(u64 s, i64 length, u64 f) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = length;
	if (!asi64(R1)) goto L66;
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L68;
	asu64(R1) = s;
	asi64(R2) = length;
	R3 = tou64("%.*s");
	asi32(R1) = printf(asu64(R3), asi64(R2), asu64(R1));
	goto L67;
L68:
	asu64(R1) = s;
	asi64(R2) = length;
	R3 = tou64("%.*s");
	asu64(R4) = f;
	asi32(R1) = fprintf(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
L67:
L66:
	return;
}

static void msysc_printchar(i64 ch) {
    u64 R1, R2, R3; 
	u32 str;
	asi64(R1) = ch;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_nextfmtchars(i64 lastx) {
    u64 R1, R2; 
	u8 c;
	u64 pstart;
	i64 n;
	asu64(R1) = msysc_fmtstr;
	if (asu64(R1)) goto L72;
	asi64(R1) = msysc_needgap;
	if (!asi64(R1)) goto L74;
	R1 = 32;
	msysc_printchar(asi64(R1));
L74:
	R1 = 0;
	msysc_needgap = asi64(R1);
	goto L70;
L72:
	asu64(R1) = msysc_fmtstr;
	pstart = asu64(R1);
	R1 = 0;
	n = asi64(R1);
L75:
	asu64(R1) = msysc_fmtstr;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 35;
	if (asu64(R1) == asu64(R2)) goto L78;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L79;
	R2 = 126;
	if (asu64(R1) == asu64(R2)) goto L80;
	goto L81;
L78:
	asi64(R1) = lastx;
	if (!asi64(R1)) goto L83;
	goto L84;
L83:
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	if (!asi64(R1)) goto L86;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
L86:
	goto L70;
	goto L77;
L79:
	asi64(R1) = n;
	if (!asi64(R1)) goto L88;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L87;
L88:
	asi64(R1) = lastx;
	if (asi64(R1)) goto L89;
	R1 = 1;
	R2 = tou64("|");
	msysc_printstr_n(asu64(R2), asi64(R1));
L89:
L87:
	goto L70;
	goto L77;
L80:
	asi64(R1) = n;
	if (!asi64(R1)) goto L91;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
	R1 = 0;
	n = asi64(R1);
L91:
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asu64(R1) = msysc_fmtstr;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	if (!asu8(R1)) goto L93;
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	msysc_printchar(asi64(R1));
L93:
	asu64(R1) = msysc_fmtstr;
	pstart = asu64(R1);
	goto L77;
L81:
// msysc.nextfmtchars.skip:
L84:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
L77:
	goto L75;
L70:
	return;
}

static void msysc_strtofmt(u64 s, i64 slen, u64 fmt) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	i64 c;
	i64 base;
	u8 wset;
	i64 n;
	struct $B5 str;
	(R1_B3) = msysc_defaultfmt;
	asu64(R2) = fmt;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L96;
	goto L94;
L96:
	asi64(R1) = slen;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L98;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	slen = asi64(R1);
L98:
	asi64(R1) = slen;
	asu64(R2) = s;
	R3 = (u64)&str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = slen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	s = asu64(R1);
	R1 = 0;
	wset = asu8(R1);
	goto L100;
L99:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) != asi64(R2)) goto L103;
	R1 = 65;
	asu64(R2) = fmt;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L102;
L103:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) != asi64(R2)) goto L104;
	R1 = 97;
	asu64(R2) = fmt;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L102;
L104:
	asi64(R1) = c;
	asi32(R1) = toupper(asi32(R1));
	R1 = toi64(toi32(R1));
	switch (asi64(R1)) {
	case 66: goto L108;
	case 67: goto L137;
	case 68: goto L136;
	case 69: goto L133;
	case 70: goto L134;
	case 71: goto L135;
	case 72: goto L109;
	case 73: case 75: case 76: case 82: case 87: goto L107;
	case 74: goto L119;
	case 77: goto L138;
	case 78: goto L141;
	case 79: goto L110;
	case 80: goto L126;
	case 81: goto L118;
	case 83: goto L123;
	case 84: goto L129;
	case 85: goto L132;
	case 86: goto L139;
	case 88: goto L111;
	case 89: goto L140;
	case 90: goto L122;
	default: goto L107;
    };
// SWITCH
L108:
	R1 = 2;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L109:
	R1 = 16;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L110:
	R1 = 8;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L111:
	R1 = 0;
	base = asi64(R1);
L112:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L115;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L115;
	asi64(R1) = base;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	base = asi64(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L114;
L115:
	goto L113;
L114:
	goto L112;
L113:
	asi64(R1) = base;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L117;
	R2 = 16;
	if (asi64(R1) > asi64(R2)) goto L117;
	asi64(R1) = base;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L117:
	goto L105;
L118:
	R1 = 34;
	asu64(R2) = fmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L119:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = fmt;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L121;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L121:
	goto L105;
L122:
	R1 = 48;
	asu64(R2) = fmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L123:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L125;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L125:
	goto L105;
L126:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L128;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L128:
	goto L105;
L129:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L131;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L131:
	goto L105;
L132:
	R1 = 87;
	asu64(R2) = fmt;
	R3 = 11;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L133:
	R1 = 101;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L134:
	R1 = 102;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L135:
	R1 = 103;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L136:
	R1 = 68;
	asu64(R2) = fmt;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L137:
	R1 = 67;
	asu64(R2) = fmt;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L138:
	R1 = 77;
	asu64(R2) = fmt;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L139:
	R1 = 86;
	asu64(R2) = fmt;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L140:
	R1 = 1;
	asu64(R2) = fmt;
	R3 = 15;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L105;
L141:
	R1 = 1;
	asu64(R2) = fmt;
	R3 = 15;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L105;
L107:
	asi64(R1) = c;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L143;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L144;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L144;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L145;
	R2 = 126;
	if (asi64(R1) == asi64(R2)) goto L146;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L147;
	goto L148;
L143:
	R1 = 1;
	wset = asu8(R1);
	goto L142;
L144:
	asi64(R1) = c;
	asu64(R2) = fmt;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L145:
	R1 = 43;
	asu64(R2) = fmt;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L146:
	R1 = 126;
	asu64(R2) = fmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L147:
	asi64(R1) = msysc_fmtparam;
	n = asi64(R1);
	goto L149;
	goto L142;
L148:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L151;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L151;
	asi64(R1) = c;
	R2 = 48;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
L152:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L155;
	goto L153;
L155:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L157;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L157;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	goto L156;
L157:
	goto L153;
L156:
	goto L152;
L153:
// msysc.strtofmt.gotwidth:
L149:
	asu8(R1) = wset;
	if (asu8(R1)) goto L159;
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	wset = asu8(R1);
	goto L158;
L159:
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 1;
	*toi8p(((i64)R2+(i64)R3)) = asi8(R1);
L158:
L151:
L142:
L105:
L102:
L100:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L99;
L94:
	return;
}

static i64 msysc_domultichar(u64 p, i64 n, u64 dest, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B17 str;
	u64 q;
	i64 nchars;
	i64 av_1;
	R1 = (u64)&str;
	q = asu64(R1);
	asi64(R1) = n;
	nchars = asi64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L163;
L161:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L165;
	goto L163;
L165:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&q;
	(*tou64p(R1)) += 1;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L161;
L163:
	R1 = 0;
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asi64(R2) = strlen(asu64(R2));
	asu64(R3) = dest;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L160;
L160:
	return asi64(R1);
}

static i64 msysc_expandstr(u64 s, u64 t, i64 n, u64 fmt) {
    u64 R1, R2, R3; 
	i64 i;
	i64 w;
	i64 m;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 av_4;
	i64 av_5;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	w = asi64(R1);
	asi64(R1) = w;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L169;
	asi64(R1) = w;
	asi64(R2) = n;
	if (asi64(R1) > asi64(R2)) goto L168;
L169:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = n;
	goto L166;
L168:
	asu64(R1) = fmt;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 76;
	if (asu64(R1) != asu64(R2)) goto L171;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L174;
L172:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	i += 1; if (i <= av_1) goto L172;
L174:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	goto L170;
L171:
	asu64(R1) = fmt;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 82;
	if (asu64(R1) != asu64(R2)) goto L175;
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) != asu64(R2)) goto L177;
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L177;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L178;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) != asu64(R2)) goto L177;
L178:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L181;
L179:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_2)) goto L179;
L181:
	asi64(R1) = n;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	asu64(R2) = s;
	R3 = 1;
	R2 += (i64)R3;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	goto L176;
L177:
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L184;
L182:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_3)) goto L182;
L184:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L176:
	goto L170;
L175:
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 2;
	asi64(R1) /= asi64(R2);
	m = asi64(R1);
	asi64(R1) = m;
	av_4 = asi64(R1);
	asi64(R1) = av_4;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L187;
L185:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_4)) goto L185;
L187:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	asi64(R2) = m;
	asi64(R1) -= asi64(R2);
	av_5 = asi64(R1);
	asi64(R1) = av_5;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L190;
L188:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_5)) goto L188;
L190:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L170:
	asi64(R1) = w;
	goto L166;
L166:
	return asi64(R1);
}

static i64 msysc_u64tostr(u64 aa, u64 s, u64 base, i64 sep) {
    u64 R1, R2, R3; 
	struct $B71 t;
	u64 dd;
	i64 i;
	i64 j;
	i64 k;
	i64 g;
	u64 s0;
	R1 = 0;
	i = asi64(R1);
	R1 = 0;
	k = asi64(R1);
	asu64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L193;
	R1 = 3;
	goto L192;
L193:
	R1 = 4;
L192:
	g = asi64(R1);
L194:
	asu64(R1) = aa;
	asu64(R2) = base;
	asu64(R1) %= asu64(R2);
	dd = asu64(R1);
	asu64(R1) = aa;
	asu64(R2) = base;
	asu64(R1) /= asu64(R2);
	aa = asu64(R1);
	R1 = (u64)&msysc_digits;
	asu64(R2) = dd;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&t;
	R3 = (u64)&i;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&k;
	(*toi64p(R1)) += 1;
	asi64(R1) = sep;
	if (!asi64(R1)) goto L198;
	asu64(R1) = aa;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L198;
	asi64(R1) = k;
	asi64(R2) = g;
	if (asi64(R1) != asi64(R2)) goto L198;
	asi64(R1) = sep;
	R2 = (u64)&t;
	R3 = (u64)&i;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
L198:
	asu64(R1) = aa;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L194;
	asi64(R1) = i;
	j = asi64(R1);
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L200;
L199:
	R1 = (u64)&t;
	R2 = (u64)&i;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L200:
	asi64(R1) = i;
	if (asi64(R1)) goto L199;
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = j;
	goto L191;
L191:
	return asi64(R1);
}

static i64 msysc_i64tostrfmt(i64 aa, u64 s, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B71 str;
	i64 n;
	i64 usigned;
	R1 = 0;
	usigned = asi64(R1);
	asu64(R1) = fmt;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L204;
	R1 = 1;
	usigned = asi64(R1);
L204:
	asi64(R1) = aa;
	R2 = 0x8000000000000000;
	if (asi64(R1) != asi64(R2)) goto L206;
	asi64(R1) = usigned;
	if (asi64(R1)) goto L206;
	R1 = 45;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = (u64)&str;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R1) = msysc_i64mintostr(asu64(R3), asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	goto L205;
L206:
	asi64(R1) = usigned;
	if (asi64(R1)) goto L210;
	asi64(R1) = aa;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L209;
L210:
	asu64(R1) = fmt;
	R2 = 6;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L208;
L209:
	asi64(R1) = aa;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L212;
	asi64(R1) = aa;
	asi64(R1) = -asi64(R1);
	aa = asi64(R1);
	R1 = 45;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L211;
L212:
	R1 = 43;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L211:
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	goto L207;
L208:
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
L207:
L205:
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L214;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L214:
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L217;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L216;
L217:
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) != asu64(R2)) goto L216;
	R1 = (u64)&str;
	asu64(R1) = mlib_convlcstring(asu64(R1));
L216:
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = s;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L202;
L202:
	return asi64(R1);
}

static i64 msysc_u64tostrfmt(i64 aa, u64 s, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B71 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L220;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L220:
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L223;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L222;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) != asu64(R2)) goto L222;
L223:
L222:
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = s;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L218;
L218:
	return asi64(R1);
}

static i64 msysc_i64mintostr(u64 s, i64 base, i64 sep) {
    u64 R1, R2, R3; 
	struct $B71 t;
	i64 i;
	i64 j;
	i64 k;
	i64 g;
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L226;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L227;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L228;
	goto L229;
L226:
	R1 = tou64("9223372036854775808");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 3;
	j = asi64(R1);
	goto L225;
L227:
	R1 = tou64("8000000000000000");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 1;
	j = asi64(R1);
	goto L225;
L228:
	R1 = tou64("1000000000000000000000000000000000000000000000000000000000000000");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 7;
	j = asi64(R1);
	goto L225;
L229:
	R1 = tou64("<mindint>");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L225:
	R1 = (u64)&t;
	R2 = 0;
	R1 += (i64)R2;
	asi64(R1) = strlen(asu64(R1));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = sep;
	if (!asi64(R1)) goto L231;
	asi64(R1) = j;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
L231:
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L233;
	R1 = 3;
	goto L232;
L233:
	R1 = 4;
L232:
	g = asi64(R1);
	goto L235;
L234:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	R1 = (u64)&t;
	R2 = (u64)&i;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = sep;
	if (!asi64(R1)) goto L238;
	asi64(R1) = i;
	if (!asi64(R1)) goto L238;
	R1 = (u64)&k;
	asi64(R1) = *(toi64p(R1)) += 1;
	asi64(R2) = g;
	if (asi64(R1) != asi64(R2)) goto L238;
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	asi64(R1) = sep;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
L238:
L235:
	asi64(R1) = i;
	if (asi64(R1)) goto L234;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	goto L224;
L224:
	return asi64(R1);
}

static i64 msysc_strtostrfmt(u64 s, u64 t, i64 n, u64 fmt) {
    u64 R1, R2, R3, R4; 
	u64 u;
	u64 v;
	struct $B16 str;
	i64 w;
	i64 nheap;
	R1 = 0;
	nheap = asi64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L242;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L241;
L242:
	asi64(R1) = n;
	R2 = 256;
	if (asi64(R1) >= asi64(R2)) goto L244;
	R1 = (u64)&str;
	u = asu64(R1);
	goto L243;
L244:
	asi64(R1) = n;
	R2 = 3;
	asi64(R1) += asi64(R2);
	nheap = asi64(R1);
	asi64(R1) = nheap;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	u = asu64(R1);
L243:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L246;
	asu64(R1) = u;
	v = asu64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&v;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	if (!asi64(R1)) goto L248;
	asu64(R1) = s;
	asu64(R2) = v;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&v;
	*tou64p(R2) += asu64(R1);
L248:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&v;
	(*tou64p(R1)) += 1;
	R1 = 0;
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = 2;
	R2 = (u64)&n;
	*toi64p(R2) += asi64(R1);
	goto L245;
L246:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = u;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L245:
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) == asu64(R2)) goto L250;
	R2 = 65;
	if (asu64(R1) == asu64(R2)) goto L251;
	goto L252;
L250:
	asu64(R1) = u;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	goto L249;
L251:
	asu64(R1) = u;
	asu64(R1) = mlib_convucstring(asu64(R1));
	goto L249;
L252:
L249:
	asu64(R1) = u;
	s = asu64(R1);
L241:
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	w = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	if (asi64(R1) <= asi64(R2)) goto L254;
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = t;
	asu64(R4) = s;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	goto L253;
L254:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L253:
	asi64(R1) = nheap;
	if (!asi64(R1)) goto L256;
	asi64(R1) = nheap;
	asu64(R2) = u;
	mlib_pcm_free(asu64(R2), asi64(R1));
L256:
	asi64(R1) = n;
	goto L239;
L239:
	return asi64(R1);
}

static void msysc_tostr_i64(i64 a, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B71 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L259;
	R2 = 77;
	if (asu64(R1) == asu64(R2)) goto L260;
	goto L261;
L259:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asi64(R3) = a;
	asi64(R1) = msysc_i64tostrfmt(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L258;
L260:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L258;
L261:
	R1 = 0;
	asi64(R2) = a;
	msysc_m$print_c8(asi64(R2), asu64(R1));
	goto L257;
L258:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
L257:
	return;
}

static void msysc_tostr_u64(u64 a, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B71 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 77;
	if (asu64(R1) == asu64(R2)) goto L264;
	R2 = 67;
	if (asu64(R1) == asu64(R2)) goto L265;
	goto L266;
L264:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L263;
L265:
	R1 = 0;
	asu64(R2) = a;
	msysc_m$print_c8(asi64(R2), asu64(R1));
	goto L262;
	goto L263;
L266:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asu64(R3) = a;
	asi64(R1) = msysc_u64tostrfmt(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
L263:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
L262:
	return;
}

static void msysc_tostr_r64(r64 x, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B71 str;
	struct $B71 str2;
	struct $B2 cfmt;
	i64 n;
	R1 = 37;
	R2 = (u64)&cfmt;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L269;
	R1 = 46;
	R2 = (u64)&cfmt;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 42;
	R2 = (u64)&cfmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cfmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cfmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	asu64(R2) = fmt;
	R3 = 1;
	asi8(R2) = *toi8p(((i64)R2+(i64)R3));
	R2 = toi64(toi8(R2));
	R3 = (u64)&cfmt;
	R4 = (u64)&str;
	asi32(R1) = sprintf(asu64(R4), asu64(R3), asi64(R2), asr64(R1));
	goto L268;
L269:
	asu64(R1) = fmt;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cfmt;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cfmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	R2 = (u64)&cfmt;
	R3 = (u64)&str;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asr64(R1));
L268:
	R1 = (u64)&str;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) >= asi64(R2)) goto L271;
	asu64(R1) = fmt;
	asi64(R2) = n;
	R3 = (u64)&str2;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	R1 = (u64)&str2;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L271:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_tostr_str(u64 s, i64 oldlen, u64 fmt) {
    u64 R1, R2, R3, R4; 
	i64 newlen;
	i64 n;
	u64 t;
	asi64(R1) = oldlen;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L274;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	oldlen = asi64(R1);
L274:
	asi64(R1) = oldlen;
	newlen = asi64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L277;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = newlen;
	if (asi64(R1) > asi64(R2)) goto L277;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L277;
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L276;
L277:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L279;
	R1 = 2;
	R2 = (u64)&newlen;
	*toi64p(R2) += asi64(R1);
L279:
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = newlen;
	if (asi64(R1) <= asi64(R2)) goto L281;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	newlen = asi64(R1);
L281:
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	t = asu64(R1);
	asu64(R1) = fmt;
	asi64(R2) = oldlen;
	asu64(R3) = t;
	asu64(R4) = s;
	asi64(R1) = msysc_strtostrfmt(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L283;
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	R1 = toi64(toi8(R1));
	R2 = (u64)&n;
    *toi64p(R2) = Min(*toi64p(R2), asi64(R1));
L283:
	asi64(R1) = n;
	asu64(R2) = t;
	msysc_printstr_n(asu64(R2), asi64(R1));
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = t;
	mlib_pcm_free(asu64(R2), asi64(R1));
	goto L275;
L276:
	asi64(R1) = oldlen;
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
L275:
	return;
}

static u64 msysc_getfmt(u64 fmtstyle) {
    u64 R1, R2, R3; 
	asu64(R1) = fmtstyle;
	if (!asu64(R1)) goto L286;
	R1 = (u64)&msysc_getfmt_fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&msysc_getfmt_fmt;
	goto L285;
L286:
	R1 = (u64)&msysc_defaultfmt;
L285:
	goto L284;
L284:
	return asu64(R1);
}

static u64 msysc_strint(i64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strint_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strint_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L287;
L287:
	return asu64(R1);
}

static void msysc_getstrint(i64 a, u64 dest) {
    u64 R1, R2; 
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = 0;
	asu64(R1) = msysc_getfmt(asu64(R1));
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	return;
}

static u64 msysc_strword(u64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strword_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asu64(R2) = a;
	msysc_tostr_u64(asu64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strword_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L289;
L289:
	return asu64(R1);
}

static u64 msysc_strreal(r64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strreal_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asr64(R2) = a;
	msysc_tostr_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strreal_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L290;
L290:
	return asu64(R1);
}

static u64 msysc_getstr(u64 s, u64 fmt) {
    u64 R1, R2; 
	asu64(R1) = fmt;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L293;
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	goto L292;
L293:
	asu64(R1) = s;
L292:
	goto L291;
L291:
	return asu64(R1);
}

static void msysc_initreadbuffer() {
    u64 R1, R2; 
	asu64(R1) = msysc_rd_buffer;
	if (!asu64(R1)) goto L296;
	goto L294;
L296:
	R1 = 16384;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	msysc_rd_buffer = asu64(R1);
	R1 = 0;
	asu64(R2) = msysc_rd_buffer;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = msysc_rd_buffer;
	R2 = R1;
	msysc_rd_lastpos = asu64(R2);
	msysc_rd_pos = asu64(R1);
L294:
	return;
}

static void msysc_m$read_conline() {
    u64 R1, R2, R3; 
	msysc_initreadbuffer();
	R1 = 16384;
	asu64(R2) = msysc_rd_buffer;
	R3 = 0;
	mlib_readlinen(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = msysc_rd_buffer;
	asi64(R1) = strlen(asu64(R1));
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static void msysc_m$read_fileline(u64 f) {
    u64 R1, R2, R3; 
	msysc_initreadbuffer();
	asu64(R1) = f;
	R2 = 1;
	if (asu64(R1) != asu64(R2)) goto L300;
	R1 = tou64("READ CMDLINE");
	mlib_abortprogram(asu64(R1));
	goto L298;
L300:
	R1 = 16384;
	asu64(R2) = msysc_rd_buffer;
	asu64(R3) = f;
	mlib_readlinen(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = msysc_rd_buffer;
	asi64(R1) = strlen(asu64(R1));
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
L298:
	return;
}

static void msysc_m$read_strline(u64 s) {
    u64 R1, R2, R3; 
	i64 n;
	msysc_initreadbuffer();
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 16384;
	if (asi64(R1) >= asi64(R2)) goto L303;
	asu64(R1) = s;
	asu64(R2) = msysc_rd_buffer;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L302;
L303:
	R1 = 16383;
	asu64(R2) = s;
	asu64(R3) = msysc_rd_buffer;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = msysc_rd_buffer;
	R3 = 16384;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
L302:
	asi64(R1) = n;
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static u64 msysc_readitem(u64 itemlength) {
    u64 R1, R2; 
	u64 p;
	u64 s;
	u64 itemstr;
	u8 quotechar;
	u8 c;
	asu64(R1) = msysc_rd_buffer;
	if (asu64(R1)) goto L306;
	msysc_initreadbuffer();
L306:
	asu64(R1) = msysc_rd_pos;
	s = asu64(R1);
	goto L308;
L307:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L308:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L307;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L307;
	asu64(R1) = s;
	itemstr = asu64(R1);
	asu64(R1) = s;
	R2 = R1;
	msysc_rd_pos = asu64(R2);
	msysc_rd_lastpos = asu64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L311;
	R1 = 0;
	msysc_termchar = asi64(R1);
	R1 = 0;
	asu64(R2) = itemlength;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = s;
	goto L304;
L311:
	R1 = 0;
	quotechar = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) != asu64(R2)) goto L313;
	R1 = 34;
	quotechar = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L312;
L313:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 39;
	if (asu64(R1) != asu64(R2)) goto L314;
	R1 = 39;
	quotechar = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L314:
L312:
	asu64(R1) = s;
	R2 = R1;
	itemstr = asu64(R2);
	p = asu64(R1);
	goto L316;
L315:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L319;
	goto L320;
L319:
	asu8(R1) = quotechar;
	if (asu8(R1)) goto L323;
	asu64(R1) = p;
	asu64(R2) = s;
	if (asu64(R1) != asu64(R2)) goto L322;
L323:
	goto L324;
L322:
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
	goto L317;
	goto L318;
L320:
// msysc.readitem.normalchar:
L324:
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	asu8(R2) = quotechar;
	R2 = tou64(tou8(R2));
	if (asu64(R1) != asu64(R2)) goto L326;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asu8(R2) = quotechar;
	R2 = tou64(tou8(R2));
	if (asu64(R1) != asu64(R2)) goto L328;
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L327;
L328:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
	asi64(R1) = msysc_termchar;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L331;
	R2 = 61;
	if (asi64(R1) != asi64(R2)) goto L330;
L331:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
L330:
	goto L317;
L327:
	goto L325;
L326:
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L325:
L318:
L316:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L315;
L317:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L333;
	R1 = 0;
	msysc_termchar = asi64(R1);
L333:
	asu64(R1) = p;
	asu64(R2) = itemstr;
	asi64(R1) -= asi64(R2);
	asu64(R2) = itemlength;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = itemstr;
	goto L304;
L304:
	return asu64(R1);
}

static i64 msysc_strtoint(u64 s, i64 length, u64 base) {
    u64 R1, R2; 
	u8 signd;
	u64 aa;
	u64 c;
	u64 d;
	R1 = 0;
	msysc_itemerror = asi64(R1);
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L336;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L336:
	R1 = 0;
	signd = asu8(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L338;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) != asu64(R2)) goto L338;
	R1 = 1;
	signd = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	goto L337;
L338:
	asi64(R1) = length;
	if (!asi64(R1)) goto L339;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) != asu64(R2)) goto L339;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
L339:
L337:
	R1 = 0;
	aa = asu64(R1);
	goto L341;
L340:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	c = asu64(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	asu64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L344;
	R2 = 70;
	if (asi64(R1) > asi64(R2)) goto L344;
	asu64(R1) = c;
	R2 = 65;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	d = asu64(R1);
	goto L343;
L344:
	asu64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L345;
	R2 = 102;
	if (asi64(R1) > asi64(R2)) goto L345;
	asu64(R1) = c;
	R2 = 97;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	d = asu64(R1);
	goto L343;
L345:
	asu64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L346;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L346;
	asu64(R1) = c;
	R2 = 48;
	asu64(R1) -= asu64(R2);
	d = asu64(R1);
	goto L343;
L346:
	asu64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L348;
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L347;
L348:
	goto L341;
	goto L343;
L347:
	R1 = 1;
	msysc_itemerror = asi64(R1);
	goto L342;
L343:
	asu64(R1) = d;
	asu64(R2) = base;
	if (asu64(R1) < asu64(R2)) goto L350;
	R1 = 1;
	msysc_itemerror = asi64(R1);
	goto L342;
L350:
	asu64(R1) = aa;
	asu64(R2) = base;
	asu64(R1) *= asu64(R2);
	asu64(R2) = d;
	asu64(R1) += asu64(R2);
	aa = asu64(R1);
L341:
	asi64(R1) = length;
	if (asi64(R1)) goto L340;
L342:
	asu8(R1) = signd;
	if (!asu8(R1)) goto L352;
	asu64(R1) = aa;
	asu64(R1) = -asu64(R1);
	goto L351;
L352:
	asu64(R1) = aa;
L351:
	goto L334;
L334:
	return asi64(R1);
}

static i64 msysc_m$read_i64(i64 fmt) {
    u64 R1, R2, R3; 
	u64 s;
	i64 length;
	asi64(R1) = fmt;
	asi32(R1) = toupper(asi32(R1));
	R1 = toi64(toi32(R1));
	fmt = asi64(R1);
	asi64(R1) = fmt;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L355;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L356;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L357;
	goto L358;
L355:
	asu64(R1) = msysc_rd_pos;
	msysc_rd_lastpos = asu64(R1);
	asu64(R1) = msysc_rd_pos;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L360;
	R1 = (u64)&msysc_rd_pos;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	goto L353;
	goto L359;
L360:
	R1 = 0;
	goto L353;
L359:
	goto L354;
L356:
	asi64(R1) = msysc_termchar;
	goto L353;
	goto L354;
L357:
	asi64(R1) = msysc_itemerror;
	goto L353;
	goto L354;
L358:
L354:
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = fmt;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L362;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L362;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L363;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L364;
	goto L365;
L362:
	R1 = 10;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L363:
	R1 = 2;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L364:
	R1 = 16;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L365:
L361:
	R1 = 0;
	goto L353;
L353:
	return asi64(R1);
}

static r64 msysc_m$read_r64(i64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B25 str;
	u64 s;
	i64 length;
	i32 numlength;
	r64 x;
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L369;
	asi64(R1) = length;
	R2 = 512;
	if (asi64(R1) < asi64(R2)) goto L368;
L369:
	asr64(R1) = 0.000000000000000000e+000;
	goto L366;
L368:
	asi64(R1) = length;
	asu64(R2) = s;
	R3 = (u64)&str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	msysc_itemerror = asi64(R1);
	R1 = (u64)&numlength;
	R2 = (u64)&x;
	R3 = tou64("%lf%n");
	R4 = (u64)&str;
	asi32(R1) = sscanf(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L372;
	asi32(R1) = numlength;
	R1 = toi64(toi32(R1));
	asi64(R2) = length;
	if (asi64(R1) == asi64(R2)) goto L371;
L372:
	asr64(R1) = 0.000000000000000000e+000;
	x = asr64(R1);
	R1 = 1;
	msysc_itemerror = asi64(R1);
L371:
	asr64(R1) = x;
	goto L366;
L366:
	return asr64(R1);
}

static void msysc_m$read_str(u64 dest, i64 destlen, i64 fmt) {
    u64 R1, R2, R3; 
	u64 s;
	i64 length;
	R1 = 0;
	msysc_itemerror = asi64(R1);
	asi64(R1) = fmt;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L376;
	R2 = 108;
	if (asi64(R1) != asi64(R2)) goto L375;
L376:
	asu64(R1) = msysc_rd_pos;
	s = asu64(R1);
	asu64(R1) = msysc_rd_buffer;
	asi64(R2) = msysc_rd_length;
	R1 += (i64)R2;
	asu64(R2) = msysc_rd_pos;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	goto L374;
L375:
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = fmt;
	R2 = 78;
	if (asi64(R1) == asi64(R2)) goto L379;
	R2 = 110;
	if (asi64(R1) != asi64(R2)) goto L378;
L379:
	asi64(R1) = length;
	asu64(R2) = s;
	mlib_iconvlcn(asu64(R2), asi64(R1));
L378:
L374:
	asi64(R1) = destlen;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L381;
	asi64(R1) = length;
	asi64(R2) = destlen;
	if (asi64(R1) < asi64(R2)) goto L383;
	asi64(R1) = destlen;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	R1 = 1;
	msysc_itemerror = asi64(R1);
L383:
L381:
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = dest;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void msysc_readstr(u64 dest, i64 fmt, i64 destlen) {
    u64 R1, R2, R3; 
	asi64(R1) = fmt;
	asi64(R2) = destlen;
	asu64(R3) = dest;
	msysc_m$read_str(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void msysc_rereadln() {
    u64 R1; 
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = msysc_rd_pos;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static void msysc_reread() {
    u64 R1; 
	asu64(R1) = msysc_rd_lastpos;
	msysc_rd_pos = asu64(R1);
	return;
}

static i64 msysc_valint(u64 s, i64 fmt) {
    u64 R1; 
	u64 old_pos;
	u64 old_lastpos;
	i64 aa;
	msysc_initreadbuffer();
	asu64(R1) = msysc_rd_pos;
	old_pos = asu64(R1);
	asu64(R1) = msysc_rd_lastpos;
	old_lastpos = asu64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	asi64(R1) = fmt;
	asi64(R1) = msysc_m$read_i64(asi64(R1));
	aa = asi64(R1);
	asu64(R1) = old_pos;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = old_lastpos;
	msysc_rd_lastpos = asu64(R1);
	asi64(R1) = aa;
	goto L387;
L387:
	return asi64(R1);
}

static r64 msysc_valreal(u64 s) {
    u64 R1; 
	u64 old_pos;
	u64 old_lastpos;
	r64 x;
	msysc_initreadbuffer();
	asu64(R1) = msysc_rd_pos;
	old_pos = asu64(R1);
	asu64(R1) = msysc_rd_lastpos;
	old_lastpos = asu64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	asr64(R1) = msysc_m$read_r64(asi64(R1));
	x = asr64(R1);
	asu64(R1) = old_pos;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = old_lastpos;
	msysc_rd_lastpos = asu64(R1);
	asr64(R1) = x;
	goto L388;
L388:
	return asr64(R1);
}

static void msysc_mclunimpl(u64 mess) {
    u64 R1, R2; 
	asu64(R1) = mess;
	R2 = tou64("MCL-UNIMPL: %s\n");
	asi32(R1) = printf(asu64(R2), asu64(R1));
	R1 = 1;
	exit(R1);
	return;
}

static void msysc_dumpstr(u64 s, i64 n, i64 fbuffer) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asi64(R1) = msysc_outdev;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L392;
	asu64(R1) = msysc_outchan;
	p = asu64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L394;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = p;
	asu64(R3) = *tou64p(R3);
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	asu64(R2) = p;
	*tou64p(R2) += asu64(R1);
L394:
	R1 = 0;
	asu64(R2) = p;
	asu64(R2) = *tou64p(R2);
	*tou8p(R2) = asu8(R1);
	goto L390;
L392:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L396;
	goto L390;
L396:
	asi64(R1) = fbuffer;
	if (!asi64(R1)) goto L398;
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L398;
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L398;
	R1 = (u64)&msysc_printptr;
	(*tou64p(R1)) -=1;
	asu64(R1) = msysc_printptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L400;
	asu64(R1) = msysc_printptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L402;
	R1 = 0;
	asu64(R2) = msysc_printptr;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	goto L401;
L402:
	R1 = 0;
	asu64(R2) = msysc_printptr;
	*tou8p(R2) = asu8(R1);
L401:
	R1 = (u64)&msysc_printbuffer;
	asi32(R1) = puts(asu64(R1));
	goto L390;
L400:
L398:
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L404;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L405;
	goto L406;
L404:
	asu64(R1) = s;
	asi64(R2) = n;
	R3 = tou64("%.*s");
	asi32(R1) = printf(asu64(R3), asi64(R2), asu64(R1));
	goto L403;
L405:
	asu64(R1) = s;
	asi64(R2) = n;
	R3 = tou64("%.*s");
	asu64(R4) = msysc_outchan;
	asi32(R1) = fprintf(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L403;
L406:
L403:
L390:
	return;
}

static void msysc_dumpprintbuffer() {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_printlen;
	if (!asi64(R1)) goto L409;
	R1 = 1;
	asi64(R2) = msysc_printlen;
	R3 = (u64)&msysc_printbuffer;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
L409:
	msysc_resetprintbuffer();
	return;
}

static void msysc_resetprintbuffer() {
    u64 R1; 
	R1 = (u64)&msysc_printbuffer;
	msysc_printptr = asu64(R1);
	R1 = 0;
	msysc_printlen = asi64(R1);
	return;
}

static void msysc_addtobuffer(u64 s, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_printlen;
	asi64(R2) = n;
	asi64(R1) += asi64(R2);
	R2 = 4088;
	if (asi64(R1) < asi64(R2)) goto L413;
	msysc_dumpprintbuffer();
L413:
	asi64(R1) = n;
	R2 = 4096;
	if (asi64(R1) >= asi64(R2)) goto L415;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = msysc_printptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&msysc_printptr;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&msysc_printlen;
	*toi64p(R2) += asi64(R1);
	goto L411;
L415:
	R1 = 0;
	asi64(R2) = n;
	asu64(R3) = s;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
L411:
	return;
}

static i64 msysc_getutfsize(u64 s) {
    u64 R1, R2, R3; 
	i64 a;
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L418;
	R1 = 0;
	goto L417;
L418:
	asi64(R1) = a;
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L419;
	R1 = 1;
	goto L417;
L419:
	asi64(R1) = a;
	R2 = 5;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L420;
	R1 = 2;
	goto L417;
L420:
	asi64(R1) = a;
	R2 = 4;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L421;
	R1 = 3;
	goto L417;
L421:
	asi64(R1) = a;
	R2 = 3;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 30;
	if (asi64(R1) != asi64(R2)) goto L422;
	R1 = 4;
	goto L417;
L422:
	R1 = 1;
L417:
	goto L416;
L416:
	return asi64(R1);
}

static i64 msysc_m$sign_i64(i64 a) {
    u64 R1, R2; 
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L425;
	R1 = -1;
	goto L424;
L425:
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L427;
	R1 = 1;
	goto L426;
L427:
	R1 = 0;
L426:
L424:
	goto L423;
L423:
	return asi64(R1);
}

static r64 msysc_m$sign_r64(r64 x) {
    u64 R1, R2; 
	asr64(R1) = x;
	asr64(R2) = 0.000000000000000000e+000;
	if (asr64(R1) >= asr64(R2)) goto L430;
	asr64(R1) = -1.000000000000000000e+000;
	goto L428;
L430:
	asr64(R1) = x;
	asr64(R2) = 0.000000000000000000e+000;
	if (asr64(R1) <= asr64(R2)) goto L432;
	asr64(R1) = 1.000000000000000000e+000;
	goto L428;
L432:
	asr64(R1) = 0.000000000000000000e+000;
	goto L428;
L428:
	return asr64(R1);
}

static u64 mlib_pcm_alloc(i64 n) {
    u64 R1, R2, R3; 
	u64 p;
	asu8(R1) = mlib_pcm_setup;
	if (asu8(R1)) goto L435;
	mlib_pcm_init();
L435:
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L437;
	asi64(R1) = n;
	asi64(R1) = mlib_pcm_getac(asi64(R1));
	mlib_alloccode = asi64(R1);
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = mlib_alloccode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	mlib_allocbytes = asi64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R1) = mlib_allocmem(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L439;
	R1 = tou64("pcm_alloc failure");
	mlib_abortprogram(asu64(R1));
L439:
	asu64(R1) = p;
	goto L433;
L437:
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	mlib_alloccode = asi64(R1);
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = mlib_alloccode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	mlib_allocbytes = asi64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = (u64)&mlib_smallmemtotal;
	*toi64p(R2) += asi64(R1);
	R1 = (u64)&mlib_freelist;
	asi64(R2) = mlib_alloccode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	p = asu64(R2);
	if (!asu64(R1)) goto L441;
	R1 = (u64)&mlib_freelist;
	asi64(R2) = mlib_alloccode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_freelist;
	asi64(R3) = mlib_alloccode;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = p;
	goto L433;
L441:
	asu64(R1) = mlib_pcheapptr;
	p = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = mlib_pcheapptr;
	asu64(R2) = mlib_pcheapend;
	if (asu64(R1) < asu64(R2)) goto L443;
	asi64(R1) = mlib_allocbytes;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L433;
L443:
	asu64(R1) = p;
	goto L433;
L433:
	return asu64(R1);
}

static void mlib_pcm_free(u64 p, i64 n) {
    u64 R1, R2, R3; 
	i64 acode;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L446;
	goto L444;
L446:
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L448;
	asu64(R1) = p;
	free(asu64(R1));
	goto L444;
L448:
	asu64(R1) = p;
	if (!asu64(R1)) goto L450;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	acode = asi64(R1);
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = acode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&mlib_smallmemtotal;
	*toi64p(R2) -= asi64(R1);
	R1 = (u64)&mlib_freelist;
	asi64(R2) = acode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&mlib_freelist;
	asi64(R3) = acode;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
L450:
L444:
	return;
}

static void mlib_pcm_freeac(u64 p, i64 alloc) {
    u64 R1, R2; 
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = alloc;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static void mlib_pcm_clearmem(u64 p, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	return;
}

static void mlib_pcm_init() {
    u64 R1, R2, R3; 
	i64 j;
	i64 k;
	i64 size;
	i64 av_1;
	i64 i;
	R1 = 0;
	mlib_alloccode = asi64(R1);
	asu8(R1) = mlib_pcm_setup;
	if (!asu8(R1)) goto L455;
	goto L453;
L455:
	R1 = 0;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	R1 = 1;
	i = asi64(R1);
L456:
	R1 = 1;
	j = asi64(R1);
	R1 = 16;
	k = asi64(R1);
	goto L460;
L459:
	asi64(R1) = k;
	R2 = 1;
	asi64(R1) <<= asi64(R2);
	k = asi64(R1);
	R1 = (u64)&j;
	(*toi64p(R1)) += 1;
L460:
	asi64(R1) = i;
	asi64(R2) = k;
	if (asi64(R1) > asi64(R2)) goto L459;
	asi64(R1) = j;
	R2 = (u64)&mlib_sizeindextable;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= 2048) goto L456;
	R1 = 16;
	R2 = (u64)&mlib_allocupper;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 16;
	size = asi64(R1);
	R1 = 2;
	i = asi64(R1);
L462:
	R1 = 2;
	R2 = (u64)&size;
	*toi64p(R2) *= asi64(R1);
	asi64(R1) = size;
	R2 = (u64)&mlib_allocupper;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = size;
	R2 = 33554432;
	if (asi64(R1) < asi64(R2)) goto L466;
	asi64(R1) = i;
	k = asi64(R1);
	goto L464;
L466:
	i += 1; if (i <= 27) goto L462;
L464:
	asi64(R1) = k;
	R2 = 1;
	asi64(R1) += asi64(R2);
	i = asi64(R1);
	R1 = 300;
	av_1 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_1;
	if (asi64(R1) > asi64(R2)) goto L469;
L467:
	R1 = 33554432;
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = size;
	R2 = 8589934592;
	if (asi64(R1) >= asi64(R2)) goto L471;
	asi64(R1) = size;
	R2 = (u64)&mlib_allocupper;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = size;
	mlib_maxmemory = asu64(R1);
	goto L470;
L471:
	asi64(R1) = i;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	mlib_maxalloccode = asi64(R1);
	goto L469;
L470:
	i += 1; if (i <= av_1) goto L467;
L469:
	R1 = 1;
	mlib_pcm_setup = asu8(R1);
L453:
	return;
}

static i64 mlib_pcm_getac(i64 size) {
    u64 R1, R2; 
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L474;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	goto L472;
L474:
	asi64(R1) = size;
	R2 = 255;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) >>= asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L476;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	asi64(R1) += asi64(R2);
	goto L472;
L476:
	asi64(R1) = size;
	R2 = 63;
	asi64(R1) += asi64(R2);
	R2 = 6;
	asi64(R1) >>= asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L478;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	asi64(R1) += asi64(R2);
	goto L472;
L478:
	asi64(R1) = size;
	R2 = 2048;
	asi64(R1) -= asi64(R2);
	R2 = 2047;
	asi64(R1) += asi64(R2);
	R2 = 2048;
	asi64(R1) /= asi64(R2);
	R2 = 22;
	asi64(R1) += asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	goto L472;
L472:
	return asi64(R1);
}

static u64 mlib_pcm_newblock(i64 itemsize) {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 2097152;
	R2 = (u64)&mlib_pcm_newblock_totalheapsize;
	*toi64p(R2) += asi64(R1);
	R1 = 0;
	mlib_alloccode = asi64(R1);
	R1 = 2097152;
	asu64(R1) = mlib_allocmem(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L481;
	R1 = tou64("Can't alloc pc heap");
	mlib_abortprogram(asu64(R1));
L481:
	R1 = 2097152;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asu64(R1) = p;
	mlib_pcheapptr = asu64(R1);
	asu64(R1) = p;
	R2 = 2097152;
	R1 += (i64)R2;
	mlib_pcheapend = asu64(R1);
	asu64(R1) = mlib_pcheapstart;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L483;
	asu64(R1) = p;
	mlib_pcheapstart = asu64(R1);
L483:
	asi64(R1) = itemsize;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = p;
	goto L479;
L479:
	return asu64(R1);
}

static i64 mlib_pcm_round(i64 n) {
    u64 R1, R2, R3; 
// PROC LOCAL STATICS GO HERE
	static struct $B13 mlib_pcm_round_allocbytes = {{
0,
	16,
	32,
	64,
	128,
	256,
	512,
	1024,
	2048    }};
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L486;
	asi64(R1) = n;
	goto L485;
L486:
	R1 = (u64)&mlib_pcm_round_allocbytes;
	R2 = (u64)&mlib_sizeindextable;
	asi64(R3) = n;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
L485:
	goto L484;
L484:
	return asi64(R1);
}

static u64 mlib_pcm_allocz(i64 n) {
    u64 R1, R2, R3; 
	u64 p;
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asu64(R1) = p;
	goto L487;
L487:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapstring(u64 s) {
    u64 R1, R2, R3; 
	u64 q;
	i64 n;
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L490;
	R1 = 0;
	goto L488;
L490:
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = q;
	goto L488;
L488:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapstringn(u64 s, i64 n) {
    u64 R1, R2, R3; 
	u64 q;
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L493;
	R1 = 0;
	goto L491;
L493:
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = q;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	goto L491;
L491:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapblock(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 q;
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L496;
	R1 = 0;
	goto L494;
L496:
	asi64(R1) = length;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = q;
	goto L494;
L494:
	return asu64(R1);
}

static u64 mlib_allocmem(i64 n) {
    u64 R1; 
	u64 p;
	asi64(R1) = n;
	asu64(R1) = malloc(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L499;
	asu64(R1) = p;
	goto L497;
L499:
	msysc_m$print_startcon();
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = mlib_memtotal;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Alloc mem failure");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L497;
L497:
	return asu64(R1);
}

static u64 mlib_reallocmem(u64 p, i64 n) {
    u64 R1, R2; 
	asi64(R1) = n;
	asu64(R2) = p;
	asu64(R1) = realloc(asu64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L502;
	asu64(R1) = p;
	goto L500;
L502:
	msysc_m$print_startcon();
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Realloc mem failure");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L500;
L500:
	return asu64(R1);
}

static void mlib_abortprogram(u64 s) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = s;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("ABORTING: Press key...");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 5;
	exit(R1);
	return;
}

static i64 mlib_getfilesize(u64 handlex) {
    u64 R1, R2, R3; 
	u32 p;
	u32 size;
	asu64(R1) = handlex;
	asi32(R1) = ftell(asu64(R1));
	p = asu32(R1);
	R1 = 2;
	R2 = 0;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi32(R1) = ftell(asu64(R1));
	size = asu32(R1);
	R1 = 0;
	asu32(R2) = p;
	R2 = toi64(tou32(R2));
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu32(R1) = size;
	R1 = toi64(tou32(R1));
	goto L504;
L504:
	return asi64(R1);
}

static void mlib_readrandom(u64 handlex, u64 memx, i64 offset, i64 size) {
    u64 R1, R2, R3, R4; 
	i64 a;
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 1;
	asu64(R4) = memx;
	asi64(R1) = fread(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	a = asi64(R1);
	return;
}

static i64 mlib_writerandom(u64 handlex, u64 memx, i64 offset, i64 size) {
    u64 R1, R2, R3, R4; 
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 1;
	asu64(R4) = memx;
	asi64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L506;
L506:
	return asi64(R1);
}

static i64 mlib_setfilepos(u64 file, i64 offset) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = file;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	R1 = toi64(toi32(R1));
	goto L507;
L507:
	return asi64(R1);
}

static i64 mlib_getfilepos(u64 file) {
    u64 R1; 
	asu64(R1) = file;
	asi32(R1) = ftell(asu64(R1));
	R1 = toi64(toi32(R1));
	goto L508;
L508:
	return asi64(R1);
}

static u64 mlib_readfile(u64 filename) {
    u64 R1, R2, R3, R4; 
	u64 f;
	i64 size;
	u64 m;
	u64 p;
	R1 = tou64("rb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L511;
	R1 = 0;
	goto L509;
L511:
	asu64(R1) = f;
	asi64(R1) = mlib_getfilesize(asu64(R1));
	R2 = R1;
	size = asi64(R2);
	mlib_rfsize = asi64(R1);
	asi64(R1) = size;
	R2 = 2;
	asu64(R1) += asu64(R2);
	asu64(R1) = malloc(asu64(R1));
	m = asu64(R1);
	asu64(R1) = m;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L513;
	R1 = 0;
	goto L509;
L513:
	asi64(R1) = size;
	R2 = 0;
	asu64(R3) = m;
	asu64(R4) = f;
	mlib_readrandom(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = m;
	asi64(R2) = size;
	R1 += (i64)R2;
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	*tou16p(R2) = asu16(R1);
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asu64(R1) = m;
	goto L509;
L509:
	return asu64(R1);
}

static i64 mlib_writefile(u64 filename, u64 data, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 f;
	i64 n;
	R1 = tou64("wb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L516;
	R1 = 0;
	goto L514;
L516:
	asi64(R1) = size;
	R2 = 0;
	asu64(R3) = data;
	asu64(R4) = f;
	asi64(R1) = mlib_writerandom(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asi64(R1) = n;
	goto L514;
L514:
	return asi64(R1);
}

static i64 mlib_checkfile(u64 file) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("rb");
	asu64(R2) = file;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	R2 = R1;
	f = asu64(R2);
	if (!asu64(R1)) goto L519;
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	R1 = 1;
	goto L517;
L519:
	R1 = 0;
	goto L517;
L517:
	return asi64(R1);
}

static void mlib_readlinen(u64 handlex, u64 buffer, i64 size) {
    u64 R1, R2, R3; 
	i64 ch;
	u64 p;
	i64 n;
	u8 crseen;
	asu64(R1) = handlex;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L522;
	asu64(R1) = mwindows_os_getstdin();
	handlex = asu64(R1);
L522:
	asu64(R1) = handlex;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L524;
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = buffer;
	p = asu64(R1);
L525:
	asi32(R1) = getchar();
	R1 = toi64(toi32(R1));
	ch = asi64(R1);
	asi64(R1) = ch;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L529;
	asi64(R1) = ch;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L529;
	asi64(R1) = ch;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L528;
L529:
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L520;
L528:
	asi64(R1) = ch;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = n;
	asi64(R2) = size;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	if (asi64(R1) < asi64(R2)) goto L531;
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L520;
L531:
	goto L525;
L524:
	R1 = 0;
	asu64(R2) = buffer;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	asu64(R3) = buffer;
	asu64(R1) = fgets(asu64(R3), asi64(R2), asu64(R1));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L533;
	goto L520;
L533:
	asu64(R1) = buffer;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L535;
	goto L520;
L535:
	asu64(R1) = buffer;
	asi64(R2) = n;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	p = asu64(R1);
	R1 = 0;
	crseen = asu8(R1);
	goto L537;
L536:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L541;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L540;
L541:
	R1 = 1;
	crseen = asu8(R1);
L540:
	R1 = 0;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) -= 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L537:
	asu64(R1) = p;
	asu64(R2) = buffer;
	if (asu64(R1) < asu64(R2)) goto L542;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L536;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L536;
L542:
	asu8(R1) = crseen;
	if (asu8(R1)) goto L544;
	asi64(R1) = n;
	R2 = 4;
	asi64(R1) += asi64(R2);
	asi64(R2) = size;
	if (asi64(R1) <= asi64(R2)) goto L544;
	msysc_m$print_startcon();
	asi64(R1) = size;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("line too long");
	mlib_abortprogram(asu64(R1));
L544:
L520:
	return;
}

static void mlib_iconvlcn(u64 s, i64 n) {
    u64 R1, R2; 
	i64 av_1;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L548;
L546:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = tolower(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L546;
L548:
	return;
}

static void mlib_iconvucn(u64 s, i64 n) {
    u64 R1, R2; 
	i64 av_1;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L552;
L550:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L550;
L552:
	return;
}

static u64 mlib_convlcstring(u64 s) {
    u64 R1, R2; 
	u64 s0;
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L555;
L554:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = tolower(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L555:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L554;
	asu64(R1) = s0;
	goto L553;
L553:
	return asu64(R1);
}

static u64 mlib_convucstring(u64 s) {
    u64 R1, R2; 
	u64 s0;
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L559;
L558:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L559:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L558;
	asu64(R1) = s0;
	goto L557;
L557:
	return asu64(R1);
}

static u64 mlib_changeext(u64 s, u64 newext) {
    u64 R1, R2, R3; 
	struct $B32 newext2;
	u64 sext;
	i64 n;
	asu64(R1) = s;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = newext;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L563;
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L564;
	goto L565;
L563:
	R1 = 0;
	R2 = (u64)&newext2;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&newext2;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L562;
L564:
	asu64(R1) = newext;
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L562;
L565:
	R1 = tou64(".");
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = newext;
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L562:
	R1 = 1;
	asu64(R2) = s;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	sext = asu64(R1);
	asu64(R1) = sext;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L567;
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L568;
	goto L569;
L567:
	R1 = (u64)&newext2;
	R2 = 0;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L566;
L568:
	R1 = (u64)&newext2;
	R2 = 1;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L566;
L569:
	asu64(R1) = sext;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	R2 = 2;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	R1 = (u64)&newext2;
	R2 = 0;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asi64(R3) = n;
	R2 += (i64)R3+1;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L566:
	R1 = (u64)&mlib_changeext_newfile;
	R2 = 0;
	R1 += (i64)R2;
	goto L561;
L561:
	return asu64(R1);
}

static u64 mlib_extractext(u64 s, i64 period) {
    u64 R1, R2; 
	u64 t;
	u64 u;
	asu64(R1) = s;
	asu64(R1) = mlib_extractfile(asu64(R1));
	t = asu64(R1);
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L572;
	R1 = tou64("");
	goto L570;
L572:
	asu64(R1) = t;
	asu64(R2) = t;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	u = asu64(R1);
	goto L574;
L573:
	asu64(R1) = u;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L577;
	asu64(R1) = u;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L579;
	asi64(R1) = period;
	if (!asi64(R1)) goto L581;
	R1 = tou64(".");
	goto L580;
L581:
	R1 = tou64("");
L580:
	goto L570;
L579:
	asu64(R1) = u;
	R2 = 1;
	R1 += (i64)R2;
	goto L570;
L577:
	R1 = (u64)&u;
	(*tou64p(R1)) -=1;
L574:
	asu64(R1) = u;
	asu64(R2) = t;
	if (asu64(R1) >= asu64(R2)) goto L573;
	R1 = tou64("");
	goto L570;
L570:
	return asu64(R1);
}

static u64 mlib_extractpath(u64 s) {
    u64 R1, R2, R3; 
	u64 t;
	i64 n;
	asu64(R1) = s;
	asu64(R2) = s;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	t = asu64(R1);
	goto L584;
L583:
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) == asu64(R2)) goto L587;
	R2 = 47;
	if (asu64(R1) == asu64(R2)) goto L587;
	R2 = 58;
	if (asu64(R1) == asu64(R2)) goto L587;
	goto L588;
L587:
	asu64(R1) = t;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	R3 = (u64)&mlib_extractpath_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractpath_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_extractpath_str;
	goto L582;
	goto L586;
L588:
L586:
	R1 = (u64)&t;
	(*tou64p(R1)) -=1;
L584:
	asu64(R1) = t;
	asu64(R2) = s;
	if (asu64(R1) >= asu64(R2)) goto L583;
	R1 = tou64("");
	goto L582;
L582:
	return asu64(R1);
}

static u64 mlib_extractfile(u64 s) {
    u64 R1, R2; 
	u64 t;
	asu64(R1) = s;
	asu64(R1) = mlib_extractpath(asu64(R1));
	t = asu64(R1);
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L591;
	asu64(R1) = s;
	goto L589;
L591:
	asu64(R1) = s;
	asu64(R2) = t;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	goto L589;
L589:
	return asu64(R1);
}

static u64 mlib_extractbasefile(u64 s) {
    u64 R1, R2, R3; 
	u64 f;
	u64 e;
	i64 n;
	i64 flen;
	asu64(R1) = s;
	asu64(R1) = mlib_extractfile(asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asi64(R1) = strlen(asu64(R1));
	flen = asi64(R1);
	asi64(R1) = flen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L594;
	R1 = tou64("");
	goto L592;
L594:
	R1 = 0;
	asu64(R2) = f;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L596;
	asi64(R1) = flen;
	asu64(R2) = e;
	asi64(R2) = strlen(asu64(R2));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = f;
	R3 = (u64)&mlib_extractbasefile_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractbasefile_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_extractbasefile_str;
	goto L592;
L596:
	asu64(R1) = f;
	asi64(R2) = flen;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L598;
	asi64(R1) = flen;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	asu64(R2) = f;
	R3 = (u64)&mlib_extractbasefile_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractbasefile_str;
	asi64(R3) = flen;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&mlib_extractbasefile_str;
	goto L592;
L598:
	asu64(R1) = f;
	goto L592;
L592:
	return asu64(R1);
}

static u64 mlib_addext(u64 s, u64 newext) {
    u64 R1, R2; 
	u64 sext;
	R1 = 1;
	asu64(R2) = s;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	sext = asu64(R1);
	asu64(R1) = sext;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L601;
	asu64(R1) = newext;
	asu64(R2) = s;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	goto L599;
L601:
	asu64(R1) = s;
	goto L599;
L599:
	return asu64(R1);
}

static u64 mlib_pcm_alloc32() {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 32;
	mlib_allocbytes = asi64(R1);
	R1 = 32;
	R2 = (u64)&mlib_smallmemtotal;
	*toi64p(R2) += asi64(R1);
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	p = asu64(R2);
	if (!asu64(R1)) goto L604;
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_freelist;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = p;
	goto L602;
L604:
	R1 = 32;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	goto L602;
L602:
	return asu64(R1);
}

static void mlib_pcm_free32(u64 p) {
    u64 R1, R2, R3; 
	R1 = 32;
	R2 = (u64)&mlib_smallmemtotal;
	*toi64p(R2) -= asi64(R1);
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&mlib_freelist;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	return;
}

static void mlib_outbyte(u64 f, i64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 1;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu16(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 2;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu32(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 4;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu64(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 8;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outstring(u64 f, u64 s) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	asu64(R3) = s;
	asi64(R3) = strlen(asu64(R3));
	R4 = 1;
	asu64(R3) += asu64(R4);
	asu64(R4) = s;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outblock(u64 f, u64 p, i64 n) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	asi64(R3) = n;
	asu64(R4) = p;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static i64 mlib_myeof(u64 f) {
    u64 R1, R2; 
	i64 c;
	asu64(R1) = f;
	asi32(R1) = fgetc(asu64(R1));
	R1 = toi64(toi32(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L614;
	R1 = 1;
	goto L612;
L614:
	asu64(R1) = f;
	asi64(R2) = c;
	asi32(R1) = ungetc(asi32(R2), asu64(R1));
	R1 = 0;
	goto L612;
L612:
	return asi64(R1);
}

static void mlib_strbuffer_add(u64 dest, u64 s, i64 n) {
    u64 R1, R2, R3, R4; 
	i64 newlen;
	i64 oldlen;
	u64 newptr;
	asi64(R1) = n;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L617;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
L617:
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	oldlen = asi64(R1);
	asi64(R1) = oldlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L619;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = dest;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = n;
	asu64(R2) = dest;
	R3 = 8;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = dest;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L615;
L619:
	asi64(R1) = oldlen;
	asi64(R2) = n;
	asi64(R1) += asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = dest;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) <= asi64(R2)) goto L621;
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	newptr = asu64(R1);
	asi64(R1) = oldlen;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = newptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = newptr;
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = dest;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L621:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = dest;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R4) = oldlen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = newlen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = newlen;
	asu64(R2) = dest;
	R3 = 8;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L615:
	return;
}

static void mlib_gs_init(u64 dest) {
    u64 R1, R2; 
	R1 = 16;
	asu64(R2) = dest;
	mlib_pcm_clearmem(asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_free(u64 dest) {
    u64 R1, R2, R3; 
	asu64(R1) = dest;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L625;
	asu64(R1) = dest;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L625:
	return;
}

static void mlib_gs_str(u64 dest, u64 s) {
    u64 R1, R2, R3; 
	R1 = -1;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_char(u64 dest, i64 c) {
    u64 R1, R2, R3; 
	struct $B3 s;
	asi64(R1) = c;
	R2 = (u64)&s;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&s;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strn(u64 dest, u64 s, i64 length) {
    u64 R1, R2, R3; 
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strvar(u64 dest, u64 s) {
    u64 R1, R2, R3; 
	R1 = -1;
	asu64(R2) = s;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strint(u64 dest, i64 a) {
    u64 R1, R2, R3; 
	R1 = -1;
	R2 = 0;
	asi64(R3) = a;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strln(u64 dest, u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	mlib_gs_line(asu64(R1));
	return;
}

static void mlib_gs_strsp(u64 dest, u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void mlib_gs_line(u64 dest) {
    u64 R1, R2, R3; 
	R1 = -1;
	R2 = tou64("\n");
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static i64 mlib_gs_getcol(u64 dest) {
    u64 R1, R2; 
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	goto L634;
L634:
	return asi64(R1);
}

static void mlib_gs_leftstr(u64 dest, u64 s, i64 w, i64 padch) {
    u64 R1, R2, R3, R4; 
	i64 col;
	i64 i;
	i64 n;
	i64 slen;
	struct $B72 str;
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	col = asi64(R1);
	asu64(R1) = s;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	slen = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = slen;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L637;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L640;
L638:
	asi64(R1) = padch;
	R2 = (u64)&str;
	asi64(R3) = slen;
	asi64(R4) = i;
	asi64(R3) += asi64(R4);
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= n) goto L638;
L640:
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = slen;
	asi64(R4) = n;
	asi64(R3) += asi64(R4);
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L637:
	R1 = (u64)&str;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void mlib_gs_leftint(u64 dest, i64 a, i64 w, i64 padch) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = padch;
	asi64(R2) = w;
	R3 = 0;
	asi64(R4) = a;
	asu64(R3) = msysc_strint(asi64(R4), asu64(R3));
	asu64(R4) = dest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mlib_gs_padto(u64 dest, i64 col, i64 ch) {
    u64 R1, R2, R3; 
	i64 n;
	struct $B72 str;
	i64 i;
	asi64(R1) = col;
	asu64(R2) = dest;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L644;
	goto L642;
L644:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L647;
L645:
	asi64(R1) = ch;
	R2 = (u64)&str;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= n) goto L645;
L647:
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
L642:
	return;
}

static void mlib_gs_println(u64 dest, u64 f) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L650;
	goto L648;
L650:
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	R4 = 8;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L652;
	msysc_m$print_startcon();
	asu64(R1) = dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("\r");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L651;
L652:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("\r");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L651:
L648:
	return;
}

static i64 mlib_nextcmdparamnew(u64 paramno, u64 name, u64 value, u64 defext) {
    u64 R1, R2; 
	u64 q;
	u64 item;
	u64 fileext;
	i64 length;
// PROC LOCAL STATICS GO HERE
	static i64 mlib_nextcmdparamnew_infile = 0;
	static u64 mlib_nextcmdparamnew_filestart = 0;
	static u64 mlib_nextcmdparamnew_fileptr = 0;
	static u8 mlib_nextcmdparamnew_colonseen = 0;
// mlib.nextcmdparamnew.reenter:
L654:
	R1 = 0;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = mlib_nextcmdparamnew_infile;
	if (!asi64(R1)) goto L656;
	R1 = (u64)&item;
	R2 = (u64)&mlib_nextcmdparamnew_fileptr;
	asi64(R1) = mlib_readnextfileitem(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L658;
	asu64(R1) = mlib_nextcmdparamnew_filestart;
	free(asu64(R1));
	R1 = 0;
	mlib_nextcmdparamnew_infile = asi64(R1);
	goto L654;
L658:
	goto L655;
L656:
	asu64(R1) = paramno;
	asi64(R1) = *toi64p(R1);
	asi64(R2) = msysc_ncmdparams;
	if (asi64(R1) <= asi64(R2)) goto L660;
	R1 = 0;
	goto L653;
L660:
	asu64(R1) = msysc_cmdparams;
	asu64(R2) = paramno;
	asi64(R2) = *toi64p(R2);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	item = asu64(R1);
	asu64(R1) = paramno;
	(*toi64p(R1)) += 1;
	asu64(R1) = item;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 64;
	if (asu64(R1) != asu64(R2)) goto L662;
	asu64(R1) = item;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R1) = mlib_readfile(asu64(R1));
	R2 = R1;
	mlib_nextcmdparamnew_fileptr = asu64(R2);
	mlib_nextcmdparamnew_filestart = asu64(R1);
	asu64(R1) = mlib_nextcmdparamnew_filestart;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L664;
	msysc_m$print_startcon();
	R1 = tou64("Can't open");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = item;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 7;
	exit(R1);
L664:
	R1 = 1;
	mlib_nextcmdparamnew_infile = asi64(R1);
	goto L654;
L662:
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 58;
	if (asu64(R1) != asu64(R2)) goto L666;
	R1 = 1;
	mlib_nextcmdparamnew_colonseen = asu8(R1);
	R1 = 4;
	goto L653;
L666:
L655:
	R1 = 0;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) != asu64(R2)) goto L668;
	asu64(R1) = item;
	asu8(R2) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R2)) goto L670;
	R2 = 0;
	goto L669;
L670:
	R2 = 1;
L669:
	R1 += (i64)R2;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	R1 = 58;
	asu64(R2) = item;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	q = asu64(R1);
	asu64(R1) = q;
	if (asu64(R1)) goto L672;
	R1 = 61;
	asu64(R2) = item;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	q = asu64(R1);
L672:
	asu64(R1) = q;
	if (!asu64(R1)) goto L674;
	asu64(R1) = q;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
L674:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L676;
	R1 = 5;
	goto L675;
L676:
	R1 = 1;
L675:
	goto L653;
L668:
	R1 = 0;
	asu64(R2) = item;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	fileext = asu64(R1);
	asu64(R1) = item;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = fileext;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L678;
	asu64(R1) = name;
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_nextcmdparamnew_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = defext;
	if (!asu64(R1)) goto L680;
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (asu8(R1)) goto L680;
	asu64(R1) = defext;
	R2 = (u64)&mlib_nextcmdparamnew_str;
	asu64(R1) = mlib_addext(asu64(R2), asu64(R1));
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
L680:
	goto L677;
L678:
	R1 = tou64("dll");
	asu64(R2) = fileext;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L682;
	R1 = tou64("mcx");
	asu64(R2) = fileext;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L681;
L682:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L684;
	R1 = 5;
	goto L683;
L684:
	R1 = 3;
L683:
	goto L653;
L681:
L677:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L686;
	R1 = 5;
	goto L685;
L686:
	R1 = 2;
L685:
	goto L653;
L653:
	return asi64(R1);
}

static i64 mlib_readnextfileitem(u64 fileptr, u64 item) {
    u64 R1, R2, R3; 
	u64 p;
	u64 pstart;
	u64 pend;
	i64 n;
	asu64(R1) = fileptr;
	asu64(R1) = *tou64p(R1);
	p = asu64(R1);
// mlib.readnextfileitem.reenter:
L688:
L689:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L692;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L692;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L692;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L692;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L693;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L693;
	goto L694;
L692:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L691;
L693:
	R1 = 0;
	goto L687;
	goto L691;
L694:
	goto L690;
L691:
	goto L689;
L690:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 33;
	if (asu64(R1) == asu64(R2)) goto L696;
	R2 = 35;
	if (asu64(R1) == asu64(R2)) goto L696;
	goto L697;
L696:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L698:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L700;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L701;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L701;
	goto L702;
L700:
	goto L688;
	goto L698;
L701:
	asu64(R1) = p;
	R2 = 1;
	R1 -= (i64)R2;
	asu64(R2) = fileptr;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	goto L687;
	goto L698;
L702:
	goto L698;
	goto L695;
L697:
L695:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L704;
	goto L705;
L704:
	R1 = (u64)&p;
	asu64(R1) = *(tou64p(R1)) += 1;
	pstart = asu64(R1);
L706:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L709;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L709;
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L710;
	goto L711;
L709:
	msysc_m$print_startcon();
	R1 = tou64("Unexpected EOF in @file");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 8;
	exit(R1);
	goto L708;
L710:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	pend = asu64(R1);
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 44;
	if (asu64(R1) != asu64(R2)) goto L713;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L713:
	goto L707;
	goto L708;
L711:
L708:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L706;
L707:
	goto L703;
L705:
	asu64(R1) = p;
	pstart = asu64(R1);
L714:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L718;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L718;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L718;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L718;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L718;
	goto L719;
L717:
	asu64(R1) = p;
	pend = asu64(R1);
	goto L715;
	goto L716;
L718:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	pend = asu64(R1);
	goto L715;
	goto L716;
L719:
L716:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L714;
L715:
L703:
	asu64(R1) = pend;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 256;
	if (asi64(R1) < asi64(R2)) goto L721;
	msysc_m$print_startcon();
	R1 = tou64("@file item too long");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 9;
	exit(R1);
L721:
	asi64(R1) = n;
	asu64(R2) = pstart;
	R3 = (u64)&mlib_readnextfileitem_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_readnextfileitem_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_readnextfileitem_str;
	asu64(R2) = item;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = fileptr;
	*tou64p(R2) = asu64(R1);
	R1 = 1;
	goto L687;
L687:
	return asi64(R1);
}

static void mlib_ipadstr(u64 s, i64 width, u64 padchar) {
    u64 R1, R2; 
	i64 n;
	i64 av_1;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = width;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L725;
L723:
	asu64(R1) = padchar;
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	if (--asi64(av_1)) goto L723;
L725:
	return;
}

static u64 mlib_padstr(u64 s, i64 width, u64 padchar) {
    u64 R1, R2, R3; 
	asu64(R1) = s;
	R2 = (u64)&mlib_padstr_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = padchar;
	asi64(R2) = width;
	R3 = (u64)&mlib_padstr_str;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&mlib_padstr_str;
	goto L726;
L726:
	return asu64(R1);
}

static u64 mlib_chr(i64 c) {
    u64 R1, R2, R3; 
	asi64(R1) = c;
	R2 = (u64)&mlib_chr_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mlib_chr_str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&mlib_chr_str;
	goto L727;
L727:
	return asu64(R1);
}

static i64 mlib_cmpstring(u64 s, u64 t) {
    u64 R1, R2; 
	i64 res;
	asu64(R1) = t;
	asu64(R2) = s;
	asi32(R1) = strcmp(asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L730;
	R1 = -1;
	goto L729;
L730:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L731;
	R1 = 1;
	goto L729;
L731:
	R1 = 0;
L729:
	goto L728;
L728:
	return asi64(R1);
}

static i64 mlib_cmpstringn(u64 s, u64 t, i64 n) {
    u64 R1, R2, R3; 
	i64 res;
	asi64(R1) = n;
	asu64(R2) = t;
	asu64(R3) = s;
	asi32(R1) = strncmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L734;
	R1 = -1;
	goto L733;
L734:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L735;
	R1 = 1;
	goto L733;
L735:
	R1 = 0;
L733:
	goto L732;
L732:
	return asi64(R1);
}

static i64 mlib_eqstring(u64 s, u64 t) {
    u64 R1, R2; 
	asu64(R1) = t;
	asu64(R2) = s;
	asi32(R1) = strcmp(asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L736;
L736:
	return asi64(R1);
}

static i64 mlib_cmpbytes(u64 p, u64 q, i64 n) {
    u64 R1, R2, R3; 
	i64 res;
	asi64(R1) = n;
	asu64(R2) = q;
	asu64(R3) = p;
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L739;
	R1 = -1;
	goto L738;
L739:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L740;
	R1 = 1;
	goto L738;
L740:
	R1 = 0;
L738:
	goto L737;
L737:
	return asi64(R1);
}

static i64 mlib_eqbytes(u64 p, u64 q, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = q;
	asu64(R3) = p;
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L741;
L741:
	return asi64(R1);
}

static void mlib_mseed(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = (u64)&mlib_seed;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = b;
	if (!asu64(R1)) goto L744;
	asu64(R1) = b;
	R2 = (u64)&mlib_seed;
	R3 = 2;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	goto L743;
L744:
	asu64(R1) = a;
	R2 = (u64)&mlib_seed;
	R3 = 2;
	R2 += (i64)R3*8-8;
	*toi64p(R2) ^= asi64(R1);
L743:
	return;
}

static u64 mlib_mrandom() {
    u64 R1, R2, R3; 
	i64 x;
	i64 y;
	R1 = (u64)&mlib_seed;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	x = asi64(R1);
	R1 = (u64)&mlib_seed;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	y = asi64(R1);
	asi64(R1) = y;
	R2 = (u64)&mlib_seed;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = x;
	R2 = 23;
	asi64(R1) <<= asi64(R2);
	R2 = (u64)&x;
	*toi64p(R2) ^= asi64(R1);
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) ^= asi64(R2);
	asi64(R2) = x;
	R3 = 17;
	asi64(R2) >>= asi64(R3);
	asi64(R1) ^= asi64(R2);
	asi64(R2) = y;
	R3 = 26;
	asi64(R2) >>= asi64(R3);
	asi64(R1) ^= asi64(R2);
	R2 = (u64)&mlib_seed;
	R3 = 2;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&mlib_seed;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = y;
	asu64(R1) += asu64(R2);
	goto L745;
L745:
	return asu64(R1);
}

static i64 mlib_mrandomp() {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandom();
	R2 = 9223372036854775807;
	asi64(R1) &= asi64(R2);
	goto L746;
L746:
	return asi64(R1);
}

static i64 mlib_mrandomint(i64 n) {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandomp();
	asi64(R2) = n;
	asi64(R1) %= asi64(R2);
	goto L747;
L747:
	return asi64(R1);
}

static i64 mlib_mrandomrange(i64 a, i64 b) {
    u64 R1, R2; 
	i64 span;
	asi64(R1) = b;
	asi64(R2) = a;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	span = asi64(R1);
	asi64(R1) = span;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L750;
	R1 = 0;
	goto L748;
L750:
	asi64(R1) = mlib_mrandomp();
	asi64(R2) = span;
	asi64(R1) %= asi64(R2);
	asi64(R2) = a;
	asi64(R1) += asi64(R2);
	goto L748;
L748:
	return asi64(R1);
}

static r64 mlib_mrandomreal() {
    u64 R1, R2; 
	r64 x;
L752:
	asi64(R1) = mlib_mrandomp();
	asr64(R1) = tor64(asi64(R1));
	asr64(R2) = 9.223372036854775800e+018;
	asr64(R1) /= asr64(R2);
	x = asr64(R1);
	asr64(R1) = x;
	asr64(R2) = 1.000000000000000000e+000;
	if (asr64(R1) == asr64(R2)) goto L752;
	asr64(R1) = x;
	goto L751;
L751:
	return asr64(R1);
}

static r64 mlib_mrandomreal1() {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandomp();
	asr64(R1) = tor64(asi64(R1));
	asr64(R2) = 9.223372036854775800e+018;
	asr64(R1) /= asr64(R2);
	goto L755;
L755:
	return asr64(R1);
}

static u64 mlib_readline() {
    u64 R1; 
	msysc_m$read_conline();
	asu64(R1) = msysc_rd_buffer;
	goto L756;
L756:
	return asu64(R1);
}

static u64 mlib_findfunction(u64 name) {
    u64 R1, R2, R3; 
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = $nprocs;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L760;
L758:
	asu64(R1) = name;
	R2 = (u64)&$procname;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L762;
	R1 = (u64)&$procaddr;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L757;
L762:
	i += 1; if (i <= av_1) goto L758;
L760:
	R1 = 0;
	goto L757;
L757:
	return asu64(R1);
}

static i64 mlib_roundtoblock(i64 n, i64 align) {
    u64 R1, R2, R3, R4, R5; 
	asi64(R1) = n;
	asi64(R2) = align;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L765;
	asi64(R1) = n;
	goto L763;
L765:
	asi64(R1) = n;
	asi64(R2) = align;
	asi64(R3) = n;
	asi64(R4) = align;
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) &= asi64(R4);
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	goto L763;
L763:
	return asi64(R1);
}

static u64 mlib_pcm_allocnfz(i64 n) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asi64(R1) = n;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L768;
	asi64(R1) = n;
	R2 = 8;
	asi64(R3) = n;
	R4 = 7;
	asi64(R3) &= asi64(R4);
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	n = asi64(R1);
L768:
	asu64(R1) = mlib_pcheapptr;
	p = asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = mlib_pcheapptr;
	asu64(R2) = mlib_pcheapend;
	if (asu64(R1) < asu64(R2)) goto L770;
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	p = asu64(R1);
L770:
	asu64(R1) = p;
	goto L766;
L766:
	return asu64(R1);
}

static void mwindows_os_init() {
    u64 R1, R2, R3; 
	R1 = -11;
	asi64(R1) = toi64(tou32(R1));
	asu64(R1) = GetStdHandle(asu32(R1));
	mwindows_hconsole = asu64(R1);
	R1 = -10;
	asi64(R1) = toi64(tou32(R1));
	asu64(R1) = GetStdHandle(asu32(R1));
	mwindows_hconsolein = asu64(R1);
	R1 = 0;
	R2 = (u64)&mwindows_lastkey;
	R3 = 8;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 0;
	mwindows_keypending = asi64(R1);
	R1 = 1;
	R2 = 0;
	asi64(R1) = SetConsoleCtrlHandler(asu64(R2), asi64(R1));
	R1 = 3;
	asu64(R2) = mwindows_hconsole;
	asi64(R1) = SetConsoleMode(asu64(R2), asu32(R1));
	R1 = 1;
	mwindows_init_flag = asi64(R1);
	return;
}

static i64 mwindows_os_execwait(u64 cmdline, i64 newconsole, u64 workdir) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8, R9, R10; 
	u32 exitcode;
	i64 status;
	i64 cflags;
	struct $B67 si;
	struct $B8 xpi;
	R1 = 0;
	cflags = asi64(R1);
	R1 = (u64)&si;
	memset(R1, 0, 104);
	R1 = (u64)&xpi;
	memset(R1, 0, 24);
	asi64(R1) = newconsole;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L774;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L775;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L776;
	goto L777;
L774:
	R1 = 32;
	cflags = asi64(R1);
	goto L773;
L775:
	R1 = 48;
	cflags = asi64(R1);
	goto L773;
L776:
	R1 = 48;
	cflags = asi64(R1);
	goto L773;
L777:
L773:
	R1 = 104;
	R2 = (u64)&si;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&xpi;
	R2 = (u64)&si;
	R3 = 0;
	R4 = 0;
	asi64(R5) = cflags;
	R6 = 1;
	R7 = 0;
	R8 = 0;
	asu64(R9) = cmdline;
	R10 = 0;
	asi64(R1) = CreateProcessA(asu64(R10), asu64(R9), asu64(R8), asu64(R7), asi64(R6), asu32(R5), asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	status = asi64(R1);
	asi64(R1) = status;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L779;
	asu32(R1) = GetLastError();
	R1 = toi64(tou32(R1));
	status = asi64(R1);
	asi64(R1) = status;
	R2 = tou64("Winexec error: %lld\n");
	asi32(R1) = printf(asu64(R2), asi64(R1));
	R1 = -1;
	goto L772;
L779:
	R1 = 4294967295;
	R2 = (u64)&xpi;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu32(R1) = WaitForSingleObject(asu64(R2), asu32(R1));
	R1 = (u64)&exitcode;
	R2 = (u64)&xpi;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = GetExitCodeProcess(asu64(R2), asu64(R1));
	R1 = (u64)&xpi;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = CloseHandle(asu64(R1));
	R1 = (u64)&xpi;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = CloseHandle(asu64(R1));
	asu32(R1) = exitcode;
	R1 = toi64(tou32(R1));
	goto L772;
L772:
	return asi64(R1);
}

static i64 mwindows_os_execcmd(u64 cmdline, i64 newconsole) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8, R9, R10; 
	struct $B67 si;
	struct $B8 xpi;
	R1 = (u64)&si;
	memset(R1, 0, 104);
	R1 = (u64)&xpi;
	memset(R1, 0, 24);
	R1 = 104;
	R2 = (u64)&si;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&xpi;
	R2 = (u64)&si;
	R3 = 0;
	R4 = 0;
	R5 = 32;
	asi64(R6) = newconsole;
	if (!asi64(R6)) goto L782;
	R6 = 16;
	goto L781;
L782:
	R6 = 0;
L781:
	asi64(R5) |= asi64(R6);
	R6 = 1;
	R7 = 0;
	R8 = 0;
	asu64(R9) = cmdline;
	R10 = 0;
	asi64(R1) = CreateProcessA(asu64(R10), asu64(R9), asu64(R8), asu64(R7), asi64(R6), asu32(R5), asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&xpi;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = CloseHandle(asu64(R1));
	R1 = (u64)&xpi;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = CloseHandle(asu64(R1));
	R1 = 1;
	goto L780;
L780:
	return asi64(R1);
}

static i64 mwindows_os_getch() {
    u64 R1, R2; 
	i64 k;
	asi64(R1) = mwindows_os_getchx();
	R2 = 255;
	asi64(R1) &= asi64(R2);
	k = asi64(R1);
	asi64(R1) = k;
	goto L783;
L783:
	return asi64(R1);
}

static i64 mwindows_os_kbhit() {
    u64 R1, R2; 
	u32 count;
	asi64(R1) = mwindows_init_flag;
	if (asi64(R1)) goto L786;
	mwindows_os_init();
L786:
	R1 = (u64)&count;
	asu64(R2) = mwindows_hconsolein;
	asi64(R1) = GetNumberOfConsoleInputEvents(asu64(R2), asu64(R1));
	asu32(R1) = count;
	R1 = toi64(tou32(R1));
	R2 = 1;
	asi64(R1) = asi64(R1)  >  asi64(R2);
	goto L784;
L784:
	return asi64(R1);
}

static u64 mwindows_os_getdllinst(u64 name) {
    u64 R1; 
	u64 hinst;
	asu64(R1) = name;
	asu64(R1) = LoadLibraryA(asu64(R1));
	hinst = asu64(R1);
	asu64(R1) = hinst;
	goto L787;
L787:
	return asu64(R1);
}

static u64 mwindows_os_getdllprocaddr(i64 hinst, u64 name) {
    u64 R1, R2; 
	asu64(R1) = name;
	asi64(R2) = hinst;
	asu64(R1) = GetProcAddress(asu64(R2), asu64(R1));
	goto L788;
L788:
	return asu64(R1);
}

static void mwindows_os_initwindows() {
    u64 R1; 
	mwindows_os_init();
	R1 = tou64("pcc001");
	mwindows_os_gxregisterclass(asu64(R1));
	return;
}

static void mwindows_os_gxregisterclass(u64 classname) {
    u64 R1, R2, R3; 
	struct $B1 r;
	asu8(R1) = mwindows_os_gxregisterclass_registered;
	if (!asu8(R1)) goto L792;
	goto L790;
L792:
	R1 = (u64)&r;
	memset(R1, 0, 80);
	R1 = 80;
	R2 = (u64)&r;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 40;
	R2 = (u64)&r;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mwindows_mainwndproc;
	R2 = (u64)&r;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&r;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&r;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 32512;
	R2 = 0;
	asu64(R1) = LoadCursorA(asu64(R2), asu64(R1));
	R2 = (u64)&r;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 16;
	R2 = (u64)&r;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&r;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = classname;
	R2 = (u64)&r;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&r;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&r;
	asu32(R1) = RegisterClassExA(asu64(R1));
	R1 = toi64(tou32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L794;
	asu32(R1) = GetLastError();
	R1 = toi64(tou32(R1));
	asu64(R2) = classname;
	R3 = tou64("Regclass error: %lld %lld\n");
	asi32(R1) = printf(asu64(R3), asu64(R2), asi64(R1));
	R1 = 1;
	exit(R1);
L794:
	R1 = 1;
	mwindows_os_gxregisterclass_registered = asu8(R1);
L790:
	return;
}

static i64 mwindows_mainwndproc(u64 hwnd, u32 message, u64 wparam, u64 lparam) {
    u64 R1, R2, R3, R4; 
	struct $B12 m;
	i64 result;
// PROC LOCAL STATICS GO HERE
	static i64 mwindows_mainwndproc_count = 0;
	asu64(R1) = hwnd;
	R2 = (u64)&m;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu32(R1) = message;
	R2 = (u64)&m;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = wparam;
	R2 = (u64)&m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = lparam;
	R2 = (u64)&m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&m;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	R2 = (u64)&m;
	R3 = 44;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = mwindows_wndproc_callbackfn;
	if (!asu64(R1)) goto L797;
	R1 = (u64)&m;
	asu64(R2) = mwindows_wndproc_callbackfn;
	asi64(R1) = ((F1)R2)(asu64(R1));
	result = asi64(R1);
	goto L796;
L797:
	R1 = 0;
	result = asi64(R1);
L796:
	R1 = (u64)&m;
	R2 = 8;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L799;
	R1 = 0;
	goto L795;
L799:
	asi64(R1) = result;
	if (asi64(R1)) goto L801;
	asu64(R1) = lparam;
	asu64(R2) = wparam;
	asu32(R3) = message;
	R3 = toi64(tou32(R3));
	asu64(R4) = hwnd;
	asi64(R1) = DefWindowProcA(asu64(R4), asu32(R3), asu64(R2), asu64(R1));
	goto L800;
L801:
	R1 = 0;
L800:
	goto L795;
L795:
	return asi64(R1);
}

static void mwindows_os_setmesshandler(u64 addr) {
    u64 R1; 
	asu64(R1) = addr;
	mwindows_wndproc_callbackfn = asu64(R1);
	return;
}

static i64 mwindows_os_getchx() {
    u64 R1, R2, R3, R4; struct $B17 R1_B17; 
	i64 count;
	i64 charcode;
	i64 keyshift;
	i64 keycode;
	i64 altdown;
	i64 ctrldown;
	i64 shiftdown;
	i64 capslock;
	asi64(R1) = mwindows_init_flag;
	if (asi64(R1)) goto L805;
	mwindows_os_init();
L805:
	asi64(R1) = mwindows_keypending;
	if (!asi64(R1)) goto L807;
	(R1_B17) = mwindows_pendkey;
	mwindows_lastkey = (R1_B17);
	R1 = 0;
	mwindows_keypending = asi64(R1);
	goto L806;
L807:
	R1 = (u64)&mwindows_lastkey;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L809;
L810:
	R1 = 0;
	count = asi64(R1);
	R1 = (u64)&count;
	R2 = 1;
	R3 = (u64)&mwindows_lastkey;
	asu64(R4) = mwindows_hconsolein;
	asi64(R1) = ReadConsoleInputA(asu64(R4), asu64(R3), asu32(R2), asu64(R1));
	R1 = (u64)&mwindows_lastkey;
	R2 = 0;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L810;
	R1 = (u64)&mwindows_lastkey;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L810;
L809:
L806:
	R1 = (u64)&mwindows_lastkey;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 3;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L814;
	R1 = 1;
	goto L813;
L814:
	R1 = 0;
L813:
	altdown = asi64(R1);
	R1 = (u64)&mwindows_lastkey;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 12;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L816;
	R1 = 1;
	goto L815;
L816:
	R1 = 0;
L815:
	ctrldown = asi64(R1);
	R1 = (u64)&mwindows_lastkey;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L818;
	R1 = 1;
	goto L817;
L818:
	R1 = 0;
L817:
	shiftdown = asi64(R1);
	R1 = (u64)&mwindows_lastkey;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 128;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L820;
	R1 = 1;
	goto L819;
L820:
	R1 = 0;
L819:
	capslock = asi64(R1);
	R1 = (u64)&mwindows_lastkey;
	R2 = 8;
	R1 += (i64)R2;
	(*tou16p(R1)) -=1;
	R1 = (u64)&mwindows_lastkey;
	R2 = 14;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	charcode = asi64(R1);
	R1 = (u64)&mwindows_lastkey;
	R2 = 10;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 255;
	asi64(R1) &= asi64(R2);
	keycode = asi64(R1);
	asi64(R1) = charcode;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L822;
	asi64(R1) = charcode;
	R2 = -128;
	if (asi64(R1) >= asi64(R2)) goto L824;
	R1 = 0;
	charcode = asi64(R1);
	goto L823;
L824:
	R1 = 256;
	R2 = (u64)&charcode;
	*toi64p(R2) += asi64(R1);
L823:
L822:
	asi64(R1) = altdown;
	if (!asi64(R1)) goto L826;
	asi64(R1) = ctrldown;
	if (!asi64(R1)) goto L826;
	asi64(R1) = charcode;
	R2 = 166;
	if (asi64(R1) != asi64(R2)) goto L826;
	R1 = 0;
	R2 = R1;
	ctrldown = asi64(R2);
	altdown = asi64(R1);
	goto L825;
L826:
	asi64(R1) = altdown;
	if (asi64(R1)) goto L829;
	asi64(R1) = ctrldown;
	if (!asi64(R1)) goto L828;
L829:
	R1 = 0;
	charcode = asi64(R1);
	asi64(R1) = keycode;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L831;
	asi64(R1) = keycode;
	R2 = 90;
	if (asi64(R1) > asi64(R2)) goto L831;
	asi64(R1) = keycode;
	R2 = 64;
	asi64(R1) -= asi64(R2);
	charcode = asi64(R1);
L831:
L828:
L825:
	asi64(R1) = capslock;
	R2 = 3;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = altdown;
	R3 = 2;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	asi64(R2) = ctrldown;
	R3 = 1;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	asi64(R2) = shiftdown;
	asi64(R1) |= asi64(R2);
	keyshift = asi64(R1);
	asi64(R1) = keyshift;
	R2 = 24;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = keycode;
	R3 = 16;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	asi64(R2) = charcode;
	asi64(R1) |= asi64(R2);
	goto L803;
L803:
	return asi64(R1);
}

static u64 mwindows_os_getos() {
    u64 R1; 
	R1 = tou64("W64");
	goto L832;
L832:
	return asu64(R1);
}

static i64 mwindows_os_gethostsize() {
    u64 R1; 
	R1 = 64;
	goto L833;
L833:
	return asi64(R1);
}

static i64 mwindows_os_shellexec(u64 opc, u64 file) {
    u64 R1; 
	asu64(R1) = file;
	asi32(R1) = system(asu64(R1));
	R1 = toi64(toi32(R1));
	goto L834;
L834:
	return asi64(R1);
}

static void mwindows_os_sleep(i64 a) {
    u64 R1; 
	asi64(R1) = a;
	Sleep(asu32(R1));
	return;
}

static u64 mwindows_os_getstdin() {
    u64 R1, R2; 
	R1 = tou64("rb");
	R2 = tou64("con");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	goto L836;
L836:
	return asu64(R1);
}

static u64 mwindows_os_getstdout() {
    u64 R1, R2; 
	R1 = tou64("wb");
	R2 = tou64("con");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	goto L837;
L837:
	return asu64(R1);
}

static u64 mwindows_os_gethostname() {
    u64 R1, R2, R3; 
	R1 = 300;
	R2 = (u64)&mwindows_os_gethostname_name;
	R3 = 0;
	asu32(R1) = GetModuleFileNameA(asu64(R3), asu64(R2), asu32(R1));
	R1 = (u64)&mwindows_os_gethostname_name;
	goto L838;
L838:
	return asu64(R1);
}

static u64 mwindows_os_getmpath() {
    u64 R1; 
	R1 = tou64("C:@@@@\\m\\\"");
	goto L839;
L839:
	return asu64(R1);
}

static i64 mwindows_os_clock() {
    u64 R1; 
	asi64(R1) = mwindows_os_hpcounter();
	goto L840;
L840:
	return asi64(R1);
}

static i64 mwindows_os_ticks() {
    u64 R1; 
	asi64(R1) = GetTickCount64();
	goto L841;
L841:
	return asi64(R1);
}

static i64 mwindows_os_iswindows() {
    u64 R1; 
	R1 = 1;
	goto L842;
L842:
	return asi64(R1);
}

static void mwindows_os_getsystime(u64 tm) {
    u64 R1; 
	asu64(R1) = tm;
	GetLocalTime(asu64(R1));
	return;
}

static void mwindows_os_peek() {
    u64 R1, R2, R3, R4, R5; 
	i64 ticks;
	struct $B5 m;
	asi64(R1) = GetTickCount64();
	ticks = asi64(R1);
	asi64(R1) = ticks;
	asi64(R2) = mwindows_os_peek_lastticks;
	asi64(R1) -= asi64(R2);
	R2 = 1000;
	if (asi64(R1) < asi64(R2)) goto L846;
	asi64(R1) = ticks;
	mwindows_os_peek_lastticks = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = (u64)&m;
	asu32(R1) = PeekMessageA(asu64(R5), asu64(R4), asu32(R3), asu32(R2), asu32(R1));
L846:
	return;
}

static u64 mwindows_os_allocexecmem(i64 n) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u32 oldprot;
	i64 status;
	R1 = 1;
	R2 = 12288;
	asi64(R3) = n;
	R4 = 0;
	asu64(R1) = VirtualAlloc(asu64(R4), asu32(R3), asu32(R2), asu32(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L849;
	R1 = 0;
	goto L847;
L849:
	R1 = (u64)&oldprot;
	R2 = 64;
	asi64(R3) = n;
	asu64(R4) = p;
	asu32(R1) = VirtualProtect(asu64(R4), asu32(R3), asu32(R2), asu64(R1));
	R1 = toi64(tou32(R1));
	status = asi64(R1);
	asi64(R1) = status;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L851;
	R1 = 0;
	goto L847;
L851:
	asu64(R1) = p;
	goto L847;
L847:
	return asu64(R1);
}

static i64 mwindows_dirlist(u64 filespec, u64 dest, i64 capacity, i64 t) {
    u64 R1, R2, R3; 
	u64 hfind;
	struct $B44 file;
	i64 nfiles;
	struct $B15 path;
	struct $B15 fullfilename;
	R1 = 0;
	nfiles = asi64(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_extractpath(asu64(R1));
	R2 = (u64)&path;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&file;
	asu64(R2) = filespec;
	asu64(R1) = FindFirstFileA(asu64(R2), asu64(R1));
	R2 = R1;
	hfind = asu64(R2);
	R2 = -1;
	if (asu64(R1) == asu64(R2)) goto L854;
L855:
	R1 = (u64)&file;
	R2 = 0;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L859;
	asi64(R1) = t;
	R2 = 2;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L861;
	goto L856;
L861:
	goto L858;
L859:
	asi64(R1) = t;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L863;
	goto L856;
L863:
L858:
	asi64(R1) = nfiles;
	asi64(R2) = capacity;
	if (asi64(R1) < asi64(R2)) goto L865;
	R1 = -1;
	nfiles = asi64(R1);
	goto L857;
L865:
	asi64(R1) = t;
	R2 = 4;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L867;
	R1 = (u64)&file;
	R2 = 44;
	R1 += (i64)R2;
	asu64(R1) = mlib_convlcstring(asu64(R1));
L867:
	R1 = (u64)&path;
	R2 = (u64)&fullfilename;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&file;
	R2 = 44;
	R1 += (i64)R2;
	R2 = (u64)&fullfilename;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&fullfilename;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = dest;
	R3 = (u64)&nfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L856:
	R1 = (u64)&file;
	asu64(R2) = hfind;
	asu32(R1) = FindNextFileA(asu64(R2), asu64(R1));
	if (asu32(R1)) goto L855;
L857:
	asu64(R1) = hfind;
	asu32(R1) = FindClose(asu64(R1));
L854:
	asi64(R1) = nfiles;
	goto L852;
L852:
	return asi64(R1);
}

static i64 mwindows_os_hpcounter() {
    u64 R1, R2; 
	i64 a;
	asi64(R1) = mwindows_hpfreq;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L870;
	asi64(R1) = mwindows_os_hpfreq();
	R2 = 1000;
	asi64(R1) /= asi64(R2);
	mwindows_hpfreq = asi64(R1);
L870:
	R1 = (u64)&a;
	asu32(R1) = QueryPerformanceCounter(asu64(R1));
	asi64(R1) = a;
	asi64(R2) = mwindows_hpfreq;
	asi64(R1) /= asi64(R2);
	goto L868;
L868:
	return asi64(R1);
}

static i64 mwindows_os_hpfreq() {
    u64 R1; 
	i64 a;
	R1 = (u64)&a;
	asu32(R1) = QueryPerformanceFrequency(asu64(R1));
	asi64(R1) = a;
	goto L871;
L871:
	return asi64(R1);
}

static u64 mwindllc_os_calldllfunction(u64 fnaddr, i64 retcode, i64 nargs, u64 args, u64 argcodes) {
    u64 R1, R2, R3; 
	u64 a;
	r64 x;
	i64 oddstack;
	i64 nextra;
	i64 pushedbytes;
	asi64(R1) = retcode;
	R2 = 73;
	if (asi64(R1) != asi64(R2)) goto L874;
	asi64(R1) = nargs;
	asu64(R2) = args;
	asu64(R3) = fnaddr;
	asu64(R1) = mwindllc_calldll_cint(asu64(R3), asu64(R2), asi64(R1));
	goto L873;
L874:
	asi64(R1) = nargs;
	asu64(R2) = args;
	asu64(R3) = fnaddr;
	asu64(R1) = mwindllc_calldll_creal(asu64(R3), asu64(R2), asi64(R1));
L873:
	goto L872;
L872:
	return asu64(R1);
}

static u64 mwindllc_os_pushargs(u64 args, i64 nargs, i64 nextra, u64 fnaddr, i64 isfloat) {
    u64 R1, R2, R3, R4, R5; 
	u64 a;
	r64 x;
	R1 = 0;
	asu64(R2) = args;
	asi64(R3) = nargs;
	asi64(R4) = isfloat;
	if (!asi64(R4)) goto L877;
	R4 = 0;
	goto L876;
L877:
	R4 = 73;
L876:
	asu64(R5) = fnaddr;
	asu64(R1) = mwindllc_os_calldllfunction(asu64(R5), asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	goto L875;
L875:
	return asu64(R1);
}

static i64 mwindllc_calldll_cint(u64 fnaddr, u64 params, i64 nparams) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13; 
	asi64(R1) = nparams;
	switch (asi64(R1)) {
	case 0: goto L882;
	case 1: goto L883;
	case 2: goto L884;
	case 3: goto L885;
	case 4: goto L886;
	case 5: goto L887;
	case 6: goto L888;
	case 7: goto L881;
	case 8: goto L889;
	case 9: goto L890;
	case 10: goto L891;
	case 11: goto L892;
	case 12: goto L893;
	default: goto L881;
    };
// SWITCH
L882:
	asu64(R1) = fnaddr;
	asi64(R1) = ((F2)R1)();
	goto L878;
	goto L879;
L883:
	asu64(R1) = params;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = fnaddr;
	asi64(R1) = ((F3)R2)(asi64(R1));
	goto L878;
	goto L879;
L884:
	asu64(R1) = params;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 1;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = fnaddr;
	asi64(R1) = ((F4)R3)(asi64(R2), asi64(R1));
	goto L878;
	goto L879;
L885:
	asu64(R1) = params;
	R2 = 3;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 2;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 1;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = fnaddr;
	asi64(R1) = ((F5)R4)(asi64(R3), asi64(R2), asi64(R1));
	goto L878;
	goto L879;
L886:
	asu64(R1) = params;
	R2 = 4;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 3;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 2;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 1;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = fnaddr;
	asi64(R1) = ((F6)R5)(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L878;
	goto L879;
L887:
	asu64(R1) = params;
	R2 = 5;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 4;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 3;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 2;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 1;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = fnaddr;
	asi64(R1) = ((F7)R6)(asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L878;
	goto L879;
L888:
	asu64(R1) = params;
	R2 = 6;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 5;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 4;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 3;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 2;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 1;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = fnaddr;
	asi64(R1) = ((F8)R7)(asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L878;
	goto L879;
L889:
	asu64(R1) = params;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 7;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 6;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 5;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 4;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 3;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 2;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 1;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = fnaddr;
	asi64(R1) = ((F9)R9)(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L878;
	goto L879;
L890:
	asu64(R1) = params;
	R2 = 9;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 7;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 6;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 5;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 4;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 3;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 2;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 1;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = fnaddr;
	asi64(R1) = ((F10)R10)(asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L878;
	goto L879;
L891:
	asu64(R1) = params;
	R2 = 10;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 9;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 8;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 7;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 6;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 5;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 4;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 3;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 2;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 1;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = fnaddr;
	asi64(R1) = ((F11)R11)(asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L878;
	goto L879;
L892:
	asu64(R1) = params;
	R2 = 11;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 10;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 9;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 8;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 7;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 6;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 5;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 4;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 3;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 2;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = params;
	R12 = 1;
	asi64(R11) = *toi64p(((i64)R11+(i64)R12*8-8));
	asu64(R12) = fnaddr;
	asi64(R1) = ((F12)R12)(asi64(R11), asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L878;
	goto L879;
L893:
	asu64(R1) = params;
	R2 = 12;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 11;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 10;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 9;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 8;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 7;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 6;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 5;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 4;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 3;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = params;
	R12 = 2;
	asi64(R11) = *toi64p(((i64)R11+(i64)R12*8-8));
	asu64(R12) = params;
	R13 = 1;
	asi64(R12) = *toi64p(((i64)R12+(i64)R13*8-8));
	asu64(R13) = fnaddr;
	asi64(R1) = ((F13)R13)(asi64(R12), asi64(R11), asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L878;
	goto L879;
L881:
	msysc_m$print_startcon();
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("calldll/c/int unsupported # of params");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L879:
	R1 = 0;
	goto L878;
L878:
	return asi64(R1);
}

static i64 mwindllc_calldll_creal(u64 fnaddr, u64 params, i64 nparams) {
    u64 R1, R2, R3, R4, R5; 
	r64 x;
	asi64(R1) = nparams;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L896;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L897;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L898;
	goto L899;
L896:
	asu64(R1) = fnaddr;
	asr64(R1) = ((F14)R1)();
	R1 = toi64(asr64(R1));
	goto L894;
	goto L895;
L897:
	asu64(R1) = params;
	R2 = 4;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = params;
	R3 = 3;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asr64(R2) = tor64(asi64(R2));
	asu64(R3) = params;
	R4 = 2;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asr64(R3) = tor64(asi64(R3));
	asu64(R4) = params;
	R5 = 1;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asr64(R4) = tor64(asi64(R4));
	mwindllc_os_dummycall(asr64(R4), asr64(R3), asr64(R2), asr64(R1));
	asu64(R1) = params;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = fnaddr;
	asr64(R1) = ((F15)R2)(asi64(R1));
	x = asr64(R1);
	goto L895;
L898:
	asu64(R1) = params;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 1;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = fnaddr;
	asr64(R1) = ((F16)R3)(asi64(R2), asi64(R1));
	x = asr64(R1);
	goto L895;
L899:
	msysc_m$print_startcon();
	R1 = tou64("calldll/c/real too many params");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L895:
	asr64(R1) = x;
	asi64(R1) = asi64(R1);
	goto L894;
L894:
	return asi64(R1);
}

static void mwindllc_os_dummycall(r64 a, r64 b, r64 c, r64 d) {
	return;
}

void qq_cli_main() {
    u64 R1, R2, R3; 
	u64 source;
	i64 i;
	i64 nnames;
	i64 t;
	i64 tstart;
	i64 stopcode;
	u64 p;
	qq_cli_start();
	qq_cli_initdata();
	qq_cli_getinputoptions();
	qq_modules_readqabundle();
	qq_cli_loadsyslib();
	R1 = 0;
	asu64(R2) = qq_cli_inputfile;
	qq_cli_compile_sp(asu64(R2), asu64(R1));
	asu8(R1) = qq_cli_fallsp;
	if (!asu8(R1)) goto L903;
	asu8(R1) = qq_cli_fshowast1;
	if (!asu8(R1)) goto L905;
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L905;
	R1 = tou64("AST1");
	R2 = 0;
	qq_show_showast(asu64(R2), asu64(R1));
L905:
	asu8(R1) = qq_cli_fshowast2;
	if (!asu8(R1)) goto L907;
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L907;
	R1 = tou64("AST2");
	R2 = 0;
	qq_show_showast(asu64(R2), asu64(R1));
L907:
L903:
	qq_cli_writeqafile();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nsubprogs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L910;
L908:
	asi64(R1) = i;
	asi64(R2) = qq_decls_nsubprogs;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	R2 = (u64)&qq_decls_subprogs;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = qq_runx_runqprogram(asu64(R2), asi64(R1));
	stopcode = asi64(R1);
	i += 1; if (i <= qq_decls_nsubprogs) goto L908;
L910:
	qq_show_showlogfile();
	asi64(R1) = stopcode;
	exit(R1);
	R1 = 0;
	exit(R1);
	return;
}

static void qq_cli_getinputoptions() {
    u64 R1, R2, R3, R4; 
	i64 paramno;
	i64 pmtype;
	u64 name;
	u64 value;
	u64 appstr;
	u64 appname;
	u64 fnaddr;
	i64 av_1;
	i64 sw;
	R1 = tou64("getbuiltin_app");
	asu64(R1) = mlib_findfunction(asu64(R1));
	fnaddr = asu64(R1);
	R1 = 1;
	paramno = asi64(R1);
	goto L913;
L912:
	asi64(R1) = pmtype;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L916;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L917;
	goto L918;
L916:
	asu64(R1) = name;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	R1 = 1;
	sw = asi64(R1);
	R1 = 23;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L922;
L919:
	R1 = (u64)&qq_decls_optionnames;
	asi64(R2) = sw;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L924;
	asu64(R1) = value;
	asi64(R2) = sw;
	qq_cli_do_option(asi64(R2), asu64(R1));
	goto L921;
L924:
	sw += 1; if (sw <= av_1) goto L919;
L922:
	msysc_m$print_startcon();
	R1 = tou64("Unknown option:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = name;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 99;
	exit(R1);
L921:
	goto L915;
L917:
	asu64(R1) = fnaddr;
	if (!asu64(R1)) goto L926;
	R1 = (u64)&paramno;
	(*toi64p(R1)) -=1;
	goto L914;
L926:
	asu64(R1) = name;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	qq_cli_inputfile = asu64(R1);
	goto L914;
	goto L915;
L918:
L915:
L913:
	R1 = tou64("q");
	R2 = (u64)&value;
	R3 = (u64)&name;
	R4 = (u64)&paramno;
	asi64(R1) = mlib_nextcmdparamnew(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R2 = R1;
	pmtype = asi64(R2);
	if (asi64(R1)) goto L912;
L914:
	asu64(R1) = fnaddr;
	if (!asu64(R1)) goto L928;
	asu64(R1) = fnaddr;
	asu64(R1) = ((F17)R1)();
	appstr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("DO BUILT-IN");
	qq_lib_loaderror(asu64(R2), asu64(R1));
	goto L927;
L928:
	asu64(R1) = qq_cli_inputfile;
	if (asu64(R1)) goto L929;
	msysc_m$print_startcon();
	R1 = tou64("Q7.0 Interpreter");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Usage:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = msysc_cmdparams;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("filename[.q]");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	exit(R1);
L929:
L927:
	asi64(R1) = paramno;
	qq_cli_cmdstartindex = asi64(R1);
	asi64(R1) = msysc_ncmdparams;
	asi64(R2) = qq_cli_cmdstartindex;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = msysc_cmdparams;
	asi64(R3) = qq_cli_cmdstartindex;
	R2 += (i64)R3*8;
	qq_cli_setcli(asu64(R2), asi64(R1));
	return;
}

static void qq_cli_do_option(i64 sw, u64 value) {
    u64 R1, R2; 
	u64 p;
	R1 = (u64)&qq_decls_optionvars;
	asi64(R2) = sw;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L932;
	R1 = (u64)&qq_decls_optionvalues;
	asi64(R2) = sw;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L930;
L932:
L930:
	return;
}

static void qq_cli_compile_sp(u64 filename, u64 source) {
    u64 R1, R2; 
	u64 qafile;
	u64 sp;
	i64 a;
	i64 b;
	i64 m;
	asu64(R1) = source;
	asu64(R2) = filename;
	asu64(R1) = qq_modules_loadsp(asu64(R2), asu64(R1));
	sp = asu64(R1);
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) >= asi64(R2)) goto L935;
	goto L933;
L935:
	asu64(R1) = sp;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	a = asi64(R1);
	asu64(R1) = sp;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	b = asi64(R1);
	asi64(R1) = a;
	m = asi64(R1);
	asi64(R1) = m;
	asi64(R2) = b;
	if (asi64(R1) > asi64(R2)) goto L938;
L936:
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	qq_parse_parsemodule(asu64(R1));
	m += 1; if (m <= b) goto L936;
L938:
	qq_resolve_fixusertypes();
	asu8(R1) = qq_cli_fshowast1;
	if (!asu8(R1)) goto L940;
	asu8(R1) = qq_cli_fallsp;
	if (asu8(R1)) goto L940;
	R1 = tou64("AST1");
	asu64(R2) = sp;
	qq_show_showast(asu64(R2), asu64(R1));
L940:
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) >= asi64(R2)) goto L942;
	goto L933;
L942:
	qq_resolve_tx_typetable();
	asi64(R1) = a;
	m = asi64(R1);
	asi64(R1) = m;
	asi64(R2) = b;
	if (asi64(R1) > asi64(R2)) goto L945;
L943:
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	qq_resolve_rx_module(asu64(R1));
	m += 1; if (m <= b) goto L943;
L945:
	asu8(R1) = qq_cli_fshowast2;
	if (!asu8(R1)) goto L947;
	asu8(R1) = qq_cli_fallsp;
	if (asu8(R1)) goto L947;
	R1 = tou64("AST2");
	asu64(R2) = sp;
	qq_show_showast(asu64(R2), asu64(R1));
L947:
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L949;
	goto L933;
L949:
	asi64(R1) = a;
	m = asi64(R1);
	asi64(R1) = m;
	asi64(R2) = b;
	if (asi64(R1) > asi64(R2)) goto L952;
L950:
	asi64(R1) = m;
	asu64(R2) = sp;
	qq_pclgen_gencodemodule(asu64(R2), asi64(R1));
	m += 1; if (m <= b) goto L950;
L952:
	asu8(R1) = qq_cli_fshowpcl1;
	if (!asu8(R1)) goto L954;
	asu8(R1) = qq_cli_fallsp;
	if (asu8(R1)) goto L954;
	R1 = 1;
	asu64(R2) = sp;
	qq_showpcl_showpcl(asu64(R2), asi64(R1));
L954:
	asu64(R1) = sp;
	qq_cli_fixup_sp(asu64(R1));
	asu8(R1) = qq_cli_fshowpcl2;
	if (!asu8(R1)) goto L956;
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L956;
	asu8(R1) = qq_cli_fallsp;
	if (asu8(R1)) goto L956;
	R1 = 2;
	asu64(R2) = sp;
	qq_showpcl_showpcl(asu64(R2), asi64(R1));
L956:
	qq_cli_resetcompiler();
L933:
	return;
}

static void qq_cli_setcli(u64 cmds, i64 ncmds) {
    u64 R1, R2; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncmds;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L960;
L958:
	asu64(R1) = cmds;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = i;
	qq_cli_setcmdparam(asi64(R2), asu64(R1));
	i += 1; if (i <= ncmds) goto L958;
L960:
	return;
}

static void qq_cli_writeqafile() {
    u64 R1, R2, R3, R4; 
	struct $B15 filename;
	struct $B73 sflist;
	u64 f;
	i64 offset;
	i64 nfiles;
	i64 fileno;
	u64 pm;
	i64 leadmod;
	i64 i;
	asu8(R1) = qq_cli_fwriteqa;
	if (asu8(R1)) goto L963;
	goto L961;
L963:
	R1 = tou64("qa");
	asu64(R2) = qq_cli_inputfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	R2 = (u64)&filename;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	nfiles = asi64(R1);
	R1 = (u64)&qq_decls_subprogs;
	asi64(R2) = qq_decls_nsubprogs;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	leadmod = asi64(R1);
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = leadmod;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&sflist;
	R3 = (u64)&nfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L966;
L964:
	asi64(R1) = i;
	asi64(R2) = leadmod;
	if (asi64(R1) == asi64(R2)) goto L968;
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	asu64(R1) = pm;
	R2 = 41;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L970;
	asu8(R1) = qq_cli_fwriteqa;
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L970;
	goto L965;
L970:
	asu64(R1) = pm;
	R2 = (u64)&sflist;
	R3 = (u64)&nfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L968:
L965:
	i += 1; if (i <= qq_decls_nmodules) goto L964;
L966:
	asi64(R1) = nfiles;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L972;
	R1 = tou64("");
	R2 = tou64("QA:no files");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L972:
	R1 = tou64("wb");
	R2 = (u64)&filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	if (asu64(R1)) goto L974;
	R1 = (u64)&filename;
	R2 = tou64("Can't create qa file #");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L974:
	msysc_m$print_startcon();
	R1 = tou64("Writing ");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("=== QA # ===");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = nfiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L977;
L975:
	R1 = (u64)&sflist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pm = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("=== #.q # # #/# ===");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pm;
	R2 = 41;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = pm;
	R2 = 42;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = nfiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	asi64(R1) = mlib_getfilepos(asu64(R1));
	offset = asi64(R1);
	asu64(R1) = pm;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = offset;
	asu64(R3) = pm;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = f;
	asi64(R1) = mlib_writerandom(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= nfiles) goto L975;
L977:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("=== END ===");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L980;
L978:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("# #.q");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&sflist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= nfiles) goto L978;
L980:
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	R1 = 0;
	exit(R1);
L961:
	return;
}

static void qq_cli_initdata() {
    u64 R1, R2, R3; 
	qq_lex_lexinit();
	R1 = 1;
	R2 = tou64("$prog");
	asu64(R2) = qq_lex_addnamestr(asu64(R2));
	R3 = 0;
	asu64(R1) = qq_names_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	qq_decls_stprogram = asu64(R1);
	mwindows_os_initwindows();
	R1 = 41;
	qq_tables_firstusertype = asi64(R1);
	qq_show_deletetempfiles();
	return;
}

static void qq_cli_loadsyslib() {
    u64 R1, R2; 
	struct $B15 str;
	asu8(R1) = qq_decls_fnosys;
	if (!asu8(R1)) goto L984;
	goto L982;
L984:
	asi64(R1) = mwindows_os_iswindows();
	if (!asi64(R1)) goto L986;
	R1 = tou64("syswin.q");
	qq_cli_syslibname = asu64(R1);
	goto L985;
L986:
	R1 = tou64("syslin.q");
	qq_cli_syslibname = asu64(R1);
L985:
	asu8(R1) = qq_decls_usebundled;
	if (!asu8(R1)) goto L988;
	R1 = 0;
	asu64(R2) = qq_cli_syslibname;
	qq_cli_compile_sp(asu64(R2), asu64(R1));
	goto L987;
L988:
	R1 = tou64("c:/qx/");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = qq_cli_syslibname;
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	qq_cli_compile_sp(asu64(R2), asu64(R1));
L987:
L982:
	return;
}

static void qq_cli_resetcompiler() {
    u64 R1, R2; 
	u64 userxmodelist;
	R1 = 0;
	qq_tables_nuserxtypes = asi64(R1);
	R1 = 0;
	qq_tables_userxtypebase = asi64(R1);
	R1 = 0;
	userxmodelist = asu64(R1);
	R1 = (u64)&qq_tables_ttxmap;
	memset(R1, 0, 40000);
	asi64(R1) = qq_tables_ntypes;
	R2 = 1;
	asi64(R1) += asi64(R2);
	qq_tables_firstusertype = asi64(R1);
	return;
}

static void qq_cli_setcmdparam(i64 index, u64 s) {
    u64 R1, R2, R3; 
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L992;
	asi64(R1) = index;
	qq_decls_nqparams = asi64(R1);
	goto L991;
L992:
	asi64(R1) = index;
	R2 = 32;
	if (asi64(R1) > asi64(R2)) goto L993;
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&qq_decls_qparamtable;
	asi64(R3) = index;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = index;
	R2 = (u64)&qq_decls_nqparams;
    *toi64p(R2) = Max(*toi64p(R2), asi64(R1));
L993:
L991:
	return;
}

static void qq_cli_fixup_sp(u64 sp) {
    u64 R1, R2; 
	i64 av_1;
	i64 i;
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) >= asi64(R2)) goto L996;
	goto L994;
L996:
	asu64(R1) = sp;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	i = asi64(R1);
	asu64(R1) = sp;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	av_1 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_1;
	if (asi64(R1) > asi64(R2)) goto L999;
L997:
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	qq_cli_fixupmodule(asu64(R1));
	asu8(R1) = qq_cli_foptimise;
	if (!asu8(R1)) goto L1001;
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	qq_cli_optimise_module(asu64(R1));
L1001:
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	qq_runx_fixupcode(asu64(R1));
	i += 1; if (i <= av_1) goto L997;
L999:
L994:
	return;
}

static void qq_cli_fixproc(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = d;
	R2 = 127;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L1004;
	asu64(R1) = qq_cli_allprocdefs;
	asu64(R2) = d;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	qq_cli_allprocdefs = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 127;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1004:
	return;
}

static void qq_cli_fixupmodule(u64 pm) {
    u64 R1, R2, R3; 
	u64 pc;
	u64 pcstart;
	i64 cmd;
	i64 y;
	u64 d;
	u64 p;
	asu64(R1) = pm;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	pcstart = asu64(R2);
	pc = asu64(R1);
L1006:
	asu64(R1) = pc;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cmd = asi64(R1);
	asi64(R1) = cmd;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1010;
	goto L1011;
L1010:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_cli_fixproc(asu64(R1));
	goto L1009;
L1011:
L1009:
	R1 = (u64)&qq_pcltabs_pclopnd;
	asi64(R2) = cmd;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1013;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1014;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1015;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L1016;
	goto L1017;
L1013:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	qq_cli_fixproc(asu64(R1));
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1012;
L1014:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L1019;
	asu64(R1) = d;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = pc;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	R2 = 8;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	goto L1018;
L1019:
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1021;
	asu64(R1) = qq_cli_allstaticdefs;
	asu64(R2) = d;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	qq_cli_allstaticdefs = asu64(R1);
	R1 = 16;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = d;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1021:
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1018:
	goto L1012;
L1015:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 104;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L1012;
L1016:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_strings_obj_make_string(asu64(R2), asi64(R1));
	asu64(R2) = pc;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1012;
L1017:
L1012:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asi64(R1) = cmd;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1006;
	return;
}

static void qq_cli_optimise_module(u64 pm) {
    u64 R1, R2, R3; 
	u64 pc;
	asu64(R1) = pm;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
L1023:
	asu64(R1) = pc;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1026;
	goto L1024;
L1026:
	asu64(R1) = pc;
	asu64(R1) = qq_cli_optim(asu64(R1));
	pc = asu64(R1);
	goto L1023;
L1024:
	asu64(R1) = pm;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L1030;
L1027:
	R1 = (u64)&qq_decls_pclcounts;
	asu64(R2) = pc;
	R3 = 8;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R1 += (i64)R2*8;
	(*toi64p(R1)) += 1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1030:
	asu64(R1) = pc;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1027;
	return;
}

static u64 qq_cli_optim(u64 pc) {
    u64 R1, R2, R3; 
	i64 skip;
	i64 index;
	u64 g;
	u64 pcdest;
	u8 cmd;
	u8 newcmd;
	u8 abc;
	u8 aux;
	i64 i;
	asu64(R1) = pc;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	newcmd = asu8(R2);
	cmd = asu8(R1);
	R1 = 0;
	skip = asi64(R1);
	asu8(R1) = cmd;
	R1 = toi64(tou8(R1));
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L1034;
	asu8(R1) = cmd;
	R1 = toi64(tou8(R1));
	R2 = 34;
	if (asi64(R1) < asi64(R2)) goto L1035;
	R2 = 39;
	if (asi64(R1) <= asi64(R2)) goto L1034;
L1035:
	asu8(R1) = cmd;
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L1036;
	R2 = 33;
	if (asi64(R1) != asi64(R2)) goto L1033;
L1036:
L1034:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcdest = asu64(R1);
	asu64(R1) = pcdest;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 30;
	if (asi64(R1) != asi64(R2)) goto L1038;
L1039:
	asu64(R1) = pcdest;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcdest = asu64(R1);
	asu64(R1) = pcdest;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L1039;
	asu64(R1) = pcdest;
	asu64(R2) = pc;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1038:
L1033:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L1043;
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	goto L1031;
L1043:
	R1 = 1;
	abc = asu8(R1);
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L1045;
	R1 = 0;
	abc = asu8(R1);
L1045:
	asu8(R1) = cmd;
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1047;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1048;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L1049;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L1050;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1051;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L1052;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L1053;
	goto L1054;
L1047:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1056;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1057;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L1058;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L1059;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L1060;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L1061;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L1062;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L1063;
	R2 = 89;
	if (asi64(R1) == asi64(R2)) goto L1064;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L1065;
	goto L1066;
L1056:
	asu8(R1) = abc;
	if (asu8(R1)) goto L1068;
	goto L1069;
L1068:
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1071;
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L1072;
	R2 = 102;
	if (asi64(R1) == asi64(R2)) goto L1073;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L1074;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L1075;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L1076;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L1077;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L1078;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L1079;
	R2 = 130;
	if (asi64(R1) == asi64(R2)) goto L1080;
	goto L1081;
L1071:
	R1 = 143;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1070;
L1072:
	R1 = 174;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1070;
L1073:
	R1 = 2;
	skip = asi64(R1);
	goto L1070;
L1074:
	R1 = 166;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1070;
L1075:
	R1 = 167;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1070;
L1076:
	R1 = 168;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1070;
L1077:
	R1 = 169;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1070;
L1078:
	R1 = 170;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1070;
L1079:
	R1 = 171;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1070;
L1080:
	R1 = 188;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1070;
L1081:
// qq_cli.optim.dopushff:
L1069:
	R1 = 144;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
L1070:
	goto L1055;
L1057:
	goto L1055;
L1058:
	asu8(R1) = abc;
	if (asu8(R1)) goto L1083;
	goto L1084;
L1083:
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L1086;
	R2 = 102;
	if (asi64(R1) == asi64(R2)) goto L1087;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L1088;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L1089;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L1090;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L1091;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L1092;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L1093;
	goto L1094;
L1086:
	R1 = 172;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1085;
L1087:
	R1 = 173;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1085;
L1088:
	R1 = 162;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1085;
L1089:
	R1 = 163;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1085;
L1090:
	R1 = 164;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1085;
L1091:
	R1 = 165;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1085;
L1092:
	R1 = 160;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1085;
L1093:
	R1 = 161;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1085;
L1094:
// qq_cli.optim.dopushfci:
L1084:
	R1 = 149;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
L1085:
	goto L1055;
L1059:
	R1 = 1;
	skip = asi64(R1);
	goto L1055;
L1060:
	R1 = 150;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
	goto L1055;
L1061:
	R1 = 1;
	skip = asi64(R1);
	goto L1055;
L1062:
	R1 = 1;
	skip = asi64(R1);
	goto L1055;
L1063:
	R1 = 1;
	skip = asi64(R1);
	goto L1055;
L1064:
	R1 = 1;
	skip = asi64(R1);
	goto L1055;
L1065:
	R1 = 190;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
	goto L1055;
L1066:
L1055:
	goto L1046;
L1048:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1096;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L1097;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L1098;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L1099;
	goto L1100;
L1096:
	asu8(R1) = abc;
	if (!asu8(R1)) goto L1102;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 130;
	if (asi64(R1) != asi64(R2)) goto L1102;
	R1 = 187;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1101;
L1102:
	R1 = 1;
	skip = asi64(R1);
L1101:
	goto L1095;
L1097:
	R1 = 1;
	skip = asi64(R1);
	goto L1095;
L1098:
	R1 = 1;
	skip = asi64(R1);
	goto L1095;
L1099:
	R1 = 148;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
	goto L1095;
L1100:
L1095:
	goto L1046;
L1049:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L1104;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L1105;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L1106;
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L1107;
	R2 = 102;
	if (asi64(R1) == asi64(R2)) goto L1108;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L1109;
	R2 = 111;
	if (asi64(R1) == asi64(R2)) goto L1110;
	R2 = 112;
	if (asi64(R1) == asi64(R2)) goto L1111;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L1112;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L1113;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1114;
	goto L1115;
L1104:
	R1 = 1;
	skip = asi64(R1);
	goto L1103;
L1105:
	R1 = 155;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
	goto L1103;
L1106:
	R1 = 1;
	skip = asi64(R1);
	goto L1103;
L1107:
	R1 = 176;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
	goto L1103;
L1108:
	R1 = 177;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
	goto L1103;
L1109:
	R1 = 178;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
	goto L1103;
L1110:
	R1 = 179;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
	goto L1103;
L1111:
	R1 = 180;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
	goto L1103;
L1112:
	R1 = 199;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
	goto L1103;
L1113:
	R1 = 200;
	newcmd = asu8(R1);
	R1 = 1;
	skip = asi64(R1);
	goto L1103;
L1114:
	asu8(R1) = abc;
	if (!asu8(R1)) goto L1117;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 122;
	if (asi64(R1) != asi64(R2)) goto L1117;
	R1 = (u64)&qq_pcltabs_bintotable;
	asu64(R2) = pc;
	R3 = 2;
	R2 += (i64)R3*32;
	R3 = 16;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R1 += (i64)R2*24-24;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L1119;
	R2 = 102;
	if (asi64(R1) == asi64(R2)) goto L1120;
	R2 = 111;
	if (asi64(R1) == asi64(R2)) goto L1121;
	R2 = 112;
	if (asi64(R1) == asi64(R2)) goto L1122;
	goto L1123;
L1119:
	R1 = 183;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1118;
L1120:
	R1 = 184;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1118;
L1121:
	R1 = 185;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1118;
L1122:
	R1 = 186;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1118;
L1123:
L1118:
L1117:
	goto L1103;
L1115:
L1103:
	goto L1046;
L1050:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L1125;
	goto L1126;
L1125:
	asu8(R1) = abc;
	if (!asu8(R1)) goto L1128;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L1128;
	R1 = 2;
	skip = asi64(R1);
	goto L1127;
L1128:
	R1 = 1;
	skip = asi64(R1);
L1127:
	goto L1124;
L1126:
L1124:
	goto L1046;
L1051:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L1130;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1131;
	goto L1132;
L1130:
	asu8(R1) = abc;
	if (!asu8(R1)) goto L1134;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L1136;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L1137;
	goto L1138;
L1136:
	R1 = 192;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1135;
L1137:
	R1 = 194;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1135;
L1138:
L1135:
L1134:
	goto L1129;
L1131:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 16;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1140;
	R1 = 182;
	newcmd = asu8(R1);
	goto L1139;
L1140:
	R1 = 181;
	newcmd = asu8(R1);
L1139:
	R1 = 1;
	skip = asi64(R1);
	goto L1129;
L1132:
L1129:
	goto L1046;
L1052:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L1142;
	goto L1143;
L1142:
	asu8(R1) = abc;
	if (!asu8(R1)) goto L1145;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L1147;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L1148;
	goto L1149;
L1147:
	R1 = 191;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1146;
L1148:
	R1 = 193;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
	goto L1146;
L1149:
L1146:
L1145:
	goto L1141;
L1143:
L1141:
	goto L1046;
L1053:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1151;
	goto L1152;
L1151:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L1154;
	R1 = 198;
	newcmd = asu8(R1);
	R1 = 2;
	skip = asi64(R1);
L1154:
	goto L1150;
L1152:
L1150:
	goto L1046;
L1054:
L1046:
// qq_cli.optim.finish:
	asu8(R1) = newcmd;
	asu64(R2) = pc;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = skip;
	if (!asi64(R1)) goto L1157;
	asu8(R1) = newcmd;
	R1 = toi64(tou8(R1));
	asu8(R2) = cmd;
	R2 = toi64(tou8(R2));
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	aux = asu8(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = skip;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1160;
L1158:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asu8(R1) = aux;
	R1 = tou64(tou8(R1));
	asu64(R2) = pc;
	R3 = 11;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	i += 1; if (i <= skip) goto L1158;
L1160:
L1157:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	goto L1031;
L1031:
	return asu64(R1);
}

static void qq_arrays_var_empty_array(i64 tag, i64 elemtype, i64 lower, u64 dest) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = lower;
	asi64(R3) = elemtype;
	asu64(R1) = qq_arrays_obj_newarray(asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = tag;
	R2 = 256;
	asi64(R1) |= asi64(R2);
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	return;
}

static void qq_arrays_obj_free_array(u64 p) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L1164;
	asu64(R1) = p;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_tables_ttsize;
	asu64(R3) = p;
	R4 = 6;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L1164:
	asu64(R1) = p;
	mlib_pcm_free32(asu64(R1));
	return;
}

static void qq_arrays_obj_free_vector(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L1167;
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L1167:
	asu64(R1) = p;
	mlib_pcm_free32(asu64(R1));
	return;
}

static void qq_arrays_var_make_array(u64 a, u64 dest, i64 lower, i64 n, i64 axtype, i64 elemtype) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	i64 m;
	i64 av_1;
	asi64(R1) = axtype;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1170;
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = axtype;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	m = asi64(R1);
	asi64(R1) = n;
	asi64(R2) = m;
	if (asi64(R1) == asi64(R2)) goto L1172;
	msysc_m$print_startcon();
	R1 = tou64("N=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("M=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = m;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("Too few/too many elements");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1172:
	goto L1169;
L1170:
	asi64(R1) = n;
	if (!asi64(R1)) goto L1173;
	asi64(R1) = elemtype;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1175;
	asu64(R1) = a;
	asi64(R2) = n;
	R1 += (i64)R2*16;
	R2 = 1;
	R1 -= (i64)R2*16;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1177;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1178;
	goto L1179;
L1177:
	R1 = 26;
	elemtype = asi64(R1);
	goto L1176;
L1178:
	R1 = 32;
	elemtype = asi64(R1);
	goto L1176;
L1179:
	R1 = 26;
	elemtype = asi64(R1);
L1176:
L1175:
	goto L1169;
L1173:
	asi64(R1) = elemtype;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1180;
	R1 = 26;
	elemtype = asi64(R1);
L1180:
L1169:
	asi64(R1) = n;
	asi64(R2) = lower;
	asi64(R3) = elemtype;
	asu64(R1) = qq_arrays_obj_newarray(asi64(R3), asi64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1183;
L1181:
	asi64(R1) = elemtype;
	asu64(R2) = a;
	asu64(R3) = q;
	qq_packed_var_storepacked(asu64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = elemtype;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&q;
	*tou64p(R2) += asu64(R1);
	R1 = (u64)&a;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L1181;
L1183:
	asi64(R1) = axtype;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1185;
	R1 = 267;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L1184;
L1185:
	R1 = 263;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = axtype;
	asu64(R2) = p;
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
L1184:
	asu64(R1) = p;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 qq_arrays_obj_newarray(i64 elemtype, i64 lower, i64 length) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	i64 elemsize;
	asu64(R1) = qq_vars_obj_new();
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = lower;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1188;
	R2 = 1;
	if (asi64(R1) > asi64(R2)) goto L1188;
	asi64(R1) = lower;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L1187;
L1188:
	R1 = tou64("");
	R2 = tou64("Lwb not 0/1");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1187:
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = elemtype;
	asu64(R2) = p;
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = elemtype;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	elemsize = asi64(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L1190;
	asi64(R1) = length;
	asi64(R2) = elemsize;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asi64(R2) = elemsize;
	asi64(R1) /= asi64(R2);
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L1190:
	asu64(R1) = p;
	goto L1186;
L1186:
	return asu64(R1);
}

static u64 qq_arrays_obj_newarray_u(i64 usertag) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	i64 elemsize;
	asu64(R1) = qq_vars_obj_new();
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = usertag;
	asu64(R2) = p;
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = (u64)&qq_tables_ttsize;
	R2 = (u64)&qq_tables_tttarget;
	asi64(R3) = usertag;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	elemsize = asi64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = usertag;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L1193;
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = usertag;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asi64(R2) = elemsize;
	asi64(R1) /= asi64(R2);
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L1193:
	asu64(R1) = p;
	goto L1191;
L1191:
	return asu64(R1);
}

static void qq_arrays_var_getix_array(u64 a, i64 index) {
    u64 R1, R2, R3, R4, R5, R6, R7; struct $B3 R1_B3; 
	struct $B3 v;
	u64 p;
	i64 elemtype;
	i64 length;
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	v = (R1_B3);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = (u64)&v;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L1196;
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	length = asi64(R1);
	R1 = (u64)&qq_tables_ttlower;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&index;
	*toi64p(R2) -= asi64(R1);
	R1 = (u64)&qq_tables_tttarget;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemtype = asi64(R1);
	goto L1195;
L1196:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = (u64)&index;
	*toi64p(R2) -= asi64(R1);
L1195:
	asi64(R1) = index;
	asi64(R2) = length;
	if (asu64(R1) < asu64(R2)) goto L1198;
	R1 = tou64("");
	R2 = tou64("ax[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1198:
	asi64(R1) = elemtype;
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L1200;
	R1 = 1;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = index;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L1199;
L1200:
	R1 = 0;
	asu64(R2) = a;
	asi64(R3) = elemtype;
	asu64(R4) = p;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asi64(R5) = index;
	R6 = (u64)&qq_tables_ttsize;
	asi64(R7) = elemtype;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8));
	asi64(R5) *= asi64(R6);
	R4 += (i64)R5;
	qq_packed_var_loadpacked(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
L1199:
	return;
}

static void qq_arrays_var_putix_array(u64 a, i64 index, u64 x) {
    u64 R1, R2, R3, R4, R5, R6; struct $B3 R1_B3; 
	struct $B3 v;
	u64 p;
	i64 elemtype;
	i64 length;
	i64 lower;
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	v = (R1_B3);
	R1 = (u64)&v;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = (u64)&v;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L1203;
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	length = asi64(R1);
	R1 = (u64)&qq_tables_ttlower;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	lower = asi64(R1);
	R1 = (u64)&qq_tables_tttarget;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemtype = asi64(R1);
	goto L1202;
L1203:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	lower = asi64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
L1202:
	asi64(R1) = lower;
	R2 = (u64)&index;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = index;
	asi64(R2) = length;
	if (asu64(R1) < asu64(R2)) goto L1205;
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L1207;
	R1 = tou64("");
	R2 = tou64("lwb");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L1206;
L1207:
	asi64(R1) = index;
	asi64(R2) = length;
	if (asi64(R1) != asi64(R2)) goto L1208;
	R1 = (u64)&v;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L1210;
	R1 = tou64("");
	R2 = tou64("Can't append user type");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1210:
	asu64(R1) = x;
	asu64(R2) = p;
	qq_arrays_obj_append_array(asu64(R2), asu64(R1));
	goto L1206;
L1208:
	R1 = tou64("");
	R2 = tou64("ax[i]:=x bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1206:
L1205:
	asi64(R1) = elemtype;
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L1212;
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1214;
	R1 = tou64("");
	R2 = tou64("rhs not int");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1214:
	R1 = 1;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = index;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1211;
L1212:
	asi64(R1) = elemtype;
	asu64(R2) = x;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R4) = index;
	R5 = (u64)&qq_tables_ttsize;
	asi64(R6) = elemtype;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8));
	asi64(R4) *= asi64(R5);
	R3 += (i64)R4;
	qq_packed_var_storepacked(asu64(R3), asu64(R2), asi64(R1));
L1211:
	return;
}

static void qq_arrays_var_getixref_array(u64 a, i64 index) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	struct $B3 v;
	u64 p;
	i64 elemtype;
	i64 length;
	i64 lower;
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	v = (R1_B3);
	R1 = (u64)&v;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = (u64)&v;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L1217;
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	length = asi64(R1);
	R1 = (u64)&qq_tables_ttlower;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	lower = asi64(R1);
	R1 = (u64)&qq_tables_tttarget;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemtype = asi64(R1);
	goto L1216;
L1217:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	lower = asi64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
L1216:
	asi64(R1) = lower;
	R2 = (u64)&index;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = index;
	asi64(R2) = length;
	if (asu64(R1) < asu64(R2)) goto L1219;
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L1221;
	R1 = tou64("");
	R2 = tou64("lwb");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L1220;
L1221:
	asi64(R1) = index;
	asi64(R2) = length;
	if (asu64(R1) != asu64(R2)) goto L1223;
	R1 = tou64("");
	R2 = tou64("PUTIXREF NEEDS IAPPEND");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L1222;
L1223:
	R1 = tou64("");
	R2 = tou64("ax[i]:=x bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1222:
L1220:
L1219:
	R1 = 16;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = elemtype;
	asu64(R2) = a;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = index;
	R3 = (u64)&qq_tables_ttsize;
	asi64(R4) = elemtype;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8));
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_arrays_obj_append_array(u64 a, u64 x) {
    u64 R1, R2, R3, R4, R5; 
	i64 n;
	u64 q;
	asu64(R1) = a;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1226;
	R1 = tou64("");
	R2 = tou64("Can't extend slice");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1226:
	asu64(R1) = a;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L1228;
	qq_lib_pcnotmut();
L1228:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = a;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L1230;
	asi64(R1) = n;
	asu64(R2) = a;
	qq_arrays_obj_resize_array(asu64(R2), asi64(R1));
	goto L1229;
L1230:
	asi64(R1) = n;
	asu64(R2) = a;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L1229:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = n;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	R3 = (u64)&qq_tables_ttsize;
	asu64(R4) = a;
	R5 = 6;
	asu16(R4) = *tou16p(((i64)R4+(i64)R5));
	R4 = toi64(tou16(R4));
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8));
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	q = asu64(R1);
	asu64(R1) = a;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = x;
	asu64(R3) = q;
	qq_packed_var_storepacked(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_arrays_var_appendto_array(u64 a, u64 x) {
    u64 R1, R2, R3; 
	asu64(R1) = x;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_arrays_obj_append_array(asu64(R2), asu64(R1));
	return;
}

static void qq_arrays_obj_resize_array(u64 p, i64 n) {
    u64 R1, R2, R3; 
	u64 q;
	i64 elemsize;
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	elemsize = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L1234;
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L1233;
L1234:
	asi64(R1) = n;
	asi64(R2) = elemsize;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L1236;
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = elemsize;
	asu64(R1) *= asu64(R2);
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = elemsize;
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L1236:
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mlib_allocbytes;
	asi64(R2) = elemsize;
	asi64(R1) /= asi64(R2);
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L1233:
	return;
}

static void qq_arrays_var_dupl_array(u64 a) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	i64 elemsize;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 4;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 0;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	asu64(R3) = p;
	R4 = 6;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	asu64(R1) = qq_arrays_obj_newarray(asi64(R3), asi64(R2), asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L1239;
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_tables_ttsize;
	asu64(R3) = p;
	R4 = 6;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asu64(R1) *= asu64(R2);
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = q;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L1239:
	return;
}

static void qq_arrays_var_dupl_vector(u64 a) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	i64 elemsize;
	i64 length;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	length = asi64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R1) = qq_arrays_obj_newarray_u(asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L1242;
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = q;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L1242:
	return;
}

static i64 qq_arrays_var_equal_array(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	i64 length;
	i64 elemsize;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemsize = asi64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = q;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	if (asi64(R1) == asi64(R2)) goto L1245;
	R1 = 0;
	goto L1243;
L1245:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asi64(R1) = length;
	asu64(R2) = q;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) == asi64(R2)) goto L1247;
	R1 = 0;
	goto L1243;
L1247:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1249;
	R1 = 1;
	goto L1243;
L1249:
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asi64(R2) = length;
	asi64(R1) *= asi64(R2);
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R1) = mlib_eqbytes(asu64(R3), asu64(R2), asi64(R1));
	goto L1243;
L1243:
	return asi64(R1);
}

static void qq_arrays_var_concatto_array(u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 d;
	i64 n;
	i64 alen;
	i64 blen;
	i64 newlen;
	i64 oldbytes;
	i64 newbytes;
	i64 elemsize;
	u64 v;
	u64 pa;
	u64 pb;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pb = asu64(R1);
	asu64(R1) = pa;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L1252;
	qq_lib_pcnotmut();
L1252:
	asu64(R1) = pa;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = pb;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	if (asi64(R1) == asi64(R2)) goto L1254;
	R1 = tou64("");
	R2 = tou64("concat/not compat");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1254:
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = pa;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	elemsize = asi64(R1);
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	alen = asi64(R1);
	asu64(R1) = pb;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	blen = asi64(R1);
	asi64(R1) = alen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1256;
	asi64(R1) = blen;
	if (!asi64(R1)) goto L1258;
	asi64(R1) = blen;
	asu64(R2) = pa;
	qq_arrays_obj_resize_array(asu64(R2), asi64(R1));
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = blen;
	asi64(R2) = elemsize;
	asu64(R1) *= asu64(R2);
	asu64(R2) = pb;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = d;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L1258:
	goto L1255;
L1256:
	asi64(R1) = blen;
	if (!asi64(R1)) goto L1259;
	asi64(R1) = alen;
	asi64(R2) = blen;
	asi64(R1) += asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	asu64(R2) = pa;
	qq_arrays_obj_resize_array(asu64(R2), asi64(R1));
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = alen;
	asi64(R3) = elemsize;
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	d = asu64(R1);
	asi64(R1) = blen;
	asi64(R2) = elemsize;
	asu64(R1) *= asu64(R2);
	asu64(R2) = pb;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = d;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L1259:
L1255:
	return;
}

static void qq_arrays_var_getslice_array(u64 a, i64 i, i64 j) {
    u64 R1, R2, R3; 
	i64 alower;
	i64 elemsize;
	u64 p;
	u64 q;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	alower = asi64(R1);
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	elemsize = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = alower;
	if (asi64(R1) < asi64(R2)) goto L1263;
	asi64(R1) = j;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R3) = alower;
	asi64(R2) += asi64(R3);
	R3 = 1;
	asi64(R2) -= asi64(R3);
	if (asi64(R1) > asi64(R2)) goto L1263;
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) <= asi64(R2)) goto L1262;
L1263:
	R1 = tou64("");
	R2 = tou64("array/slice bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1262:
	asu64(R1) = qq_vars_obj_new();
	q = asu64(R1);
	R1 = 1;
	asu64(R2) = q;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = q;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 1;
	asu64(R2) = q;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asi64(R3) = alower;
	asi64(R2) -= asi64(R3);
	asi64(R3) = elemsize;
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = p;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1265;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1266;
	goto L1267;
L1265:
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_vars_obj_shareu(asu64(R1));
	goto L1264;
L1266:
	R1 = 0;
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2;
	asu64(R2) = q;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1264;
L1267:
	asu64(R1) = p;
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	(*tou32p(R1)) += 1;
L1264:
	asi64(R1) = j;
	asi64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = q;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static i64 qq_arrays_u8inarray(u8 a, u64 p) {
    u64 R1, R2; 
	i64 i;
	u64 q;
	i64 av_1;
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	i = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1271;
L1269:
	asu64(R1) = q;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	asu8(R2) = a;
	R2 = toi64(tou8(R2));
	if (asi64(R1) != asi64(R2)) goto L1273;
	asi64(R1) = i;
	goto L1268;
L1273:
	R1 = (u64)&q;
	(*tou64p(R1)) += 1;
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	if (--asi64(av_1)) goto L1269;
L1271:
	R1 = 0x8000000000000000;
	goto L1268;
L1268:
	return asi64(R1);
}

static i64 qq_arrays_u16inarray(u16 a, u64 p) {
    u64 R1, R2; 
	i64 i;
	u64 q;
	i64 av_1;
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	i = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1277;
L1275:
	asu64(R1) = q;
	asu16(R1) = *tou16p(R1);
	R1 = toi64(tou16(R1));
	asu16(R2) = a;
	R2 = toi64(tou16(R2));
	if (asi64(R1) != asi64(R2)) goto L1279;
	asi64(R1) = i;
	goto L1274;
L1279:
	R1 = (u64)&q;
	(*tou64p(R1)) += 2;
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	if (--asi64(av_1)) goto L1275;
L1277:
	R1 = 0x8000000000000000;
	goto L1274;
L1274:
	return asi64(R1);
}

static i64 qq_arrays_u32inarray(u32 a, u64 p) {
    u64 R1, R2; 
	i64 i;
	u64 q;
	i64 av_1;
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	i = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1283;
L1281:
	asu64(R1) = q;
	asu32(R1) = *tou32p(R1);
	R1 = toi64(tou32(R1));
	asu32(R2) = a;
	R2 = toi64(tou32(R2));
	if (asi64(R1) != asi64(R2)) goto L1285;
	asi64(R1) = i;
	goto L1280;
L1285:
	R1 = (u64)&q;
	(*tou64p(R1)) += 4;
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	if (--asi64(av_1)) goto L1281;
L1283:
	R1 = 0x8000000000000000;
	goto L1280;
L1280:
	return asi64(R1);
}

static i64 qq_arrays_u64inarray(u64 a, u64 p) {
    u64 R1, R2; 
	i64 i;
	u64 q;
	i64 av_1;
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	i = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1289;
L1287:
	asu64(R1) = q;
	asu64(R1) = *tou64p(R1);
	asu64(R2) = a;
	if (asu64(R1) != asu64(R2)) goto L1291;
	asi64(R1) = i;
	goto L1286;
L1291:
	R1 = (u64)&q;
	(*tou64p(R1)) += 8;
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	if (--asi64(av_1)) goto L1287;
L1289:
	R1 = 0x8000000000000000;
	goto L1286;
L1286:
	return asi64(R1);
}

static i64 qq_arrays_var_inx_array(u64 a, u64 b, i64 usertag) {
    u64 R1, R2, R3; 
	i64 n;
	u64 q;
	i64 elemtag;
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asi64(R1) = usertag;
	if (!asi64(R1)) goto L1294;
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = usertag;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemtag = asi64(R1);
	goto L1293;
L1294:
	asu64(R1) = q;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtag = asi64(R1);
L1293:
	asi64(R1) = elemtag;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L1296;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L1296;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L1297;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L1297;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L1298;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L1298;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L1299;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L1299;
	goto L1300;
L1296:
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_arrays_u8inarray(asu8(R2), asu64(R1));
	n = asi64(R1);
	goto L1295;
L1297:
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_arrays_u16inarray(asu16(R2), asu64(R1));
	n = asi64(R1);
	goto L1295;
L1298:
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_arrays_u32inarray(asu32(R2), asu64(R1));
	n = asi64(R1);
	goto L1295;
L1299:
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_arrays_u64inarray(asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L1295;
L1300:
	asu64(R1) = b;
	R2 = tou64("x in array");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L1295:
	asi64(R1) = n;
	goto L1292;
L1292:
	return asi64(R1);
}

static void qq_arrays_var_expand_array(u64 p, u64 dest, i64 m) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 i;
	i64 n;
	i64 elemtype;
	i64 length;
	u64 pa;
	i64 av_1;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1303;
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asu64(R1) = pa;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	goto L1302;
L1303:
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = pa;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	length = asi64(R1);
	R1 = (u64)&qq_tables_tttarget;
	asu64(R2) = pa;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemtype = asi64(R1);
L1302:
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = 1;
	n = asi64(R1);
	asi64(R1) = m;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1306;
L1304:
	asi64(R1) = n;
	asi64(R2) = length;
	if (asi64(R1) <= asi64(R2)) goto L1308;
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L1307;
L1308:
	R1 = 0;
	asu64(R2) = dest;
	asi64(R3) = elemtype;
	asu64(R4) = q;
	qq_packed_var_loadpacked(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = elemtype;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&q;
	*tou64p(R2) += asu64(R1);
L1307:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	R1 = (u64)&dest;
	(*tou64p(R1)) -=16;
	if (--asi64(av_1)) goto L1304;
L1306:
	return;
}

static void qq_bits_obj_free_bits(u64 p, i64 tag) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L1311;
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_bits_getbitssize(asi64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L1311:
	asu64(R1) = p;
	mlib_pcm_free32(asu64(R1));
	return;
}

static void qq_bits_var_make_bits(u64 a, u64 dest, i64 lower, i64 n, i64 bxtype, i64 elemtype) {
    u64 R1, R2, R3, R4, R5; 
	u64 p;
	u64 q;
	i64 bitwidthx;
	i64 offset;
	i64 av_1;
	asi64(R1) = n;
	asi64(R2) = lower;
	asi64(R3) = elemtype;
	asu64(R1) = qq_bits_obj_newbits(asi64(R3), asi64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = (u64)&qq_tables_ttbitwidth;
	asi64(R2) = elemtype;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	bitwidthx = asi64(R1);
	R1 = 0;
	offset = asi64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1315;
L1313:
	asi64(R1) = bitwidthx;
	asi64(R2) = elemtype;
	asu64(R3) = a;
	asi64(R4) = offset;
	asu64(R5) = q;
	qq_vars_var_storebit(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = bitwidthx;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = offset;
	R2 = 8;
	if (asi64(R1) < asi64(R2)) goto L1317;
	R1 = (u64)&q;
	(*tou64p(R1)) += 1;
	R1 = 0;
	offset = asi64(R1);
L1317:
	R1 = (u64)&a;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L1313;
L1315:
	asi64(R1) = bxtype;
	R2 = 256;
	asi64(R1) |= asi64(R2);
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 qq_bits_obj_newbits(i64 elemtype, i64 lower, i64 length) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	i64 nbits;
	i64 bitwidthx;
	i64 nbytes;
	asu64(R1) = qq_vars_obj_new();
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = lower;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = elemtype;
	asu64(R2) = p;
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L1320;
	asi64(R1) = elemtype;
	asi64(R2) = length;
	asi64(R1) = qq_bits_getbitssize(asi64(R2), asi64(R1));
	nbytes = asi64(R1);
	asi64(R1) = nbytes;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = 8;
	R3 = (u64)&qq_tables_ttbitwidth;
	asi64(R4) = elemtype;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R2) /= asi64(R3);
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L1320:
	asu64(R1) = p;
	goto L1318;
L1318:
	return asu64(R1);
}

static void qq_bits_var_getix_bits(u64 a, i64 index) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	i64 elemtype;
	i64 offset;
	i64 shift;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = (u64)&index;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = index;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L1323;
	R1 = tou64("");
	R2 = tou64("ax[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1323:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&index;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L1325;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L1326;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L1327;
	goto L1328;
L1325:
	asu64(R1) = q;
	asi64(R2) = index;
	R3 = 3;
	asi64(R2) >>= asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R3) = index;
	R4 = 7;
	asi64(R3) &= asi64(R4);
	asi64(R2) <<= asi64(R3);
	asi64(R1) &= asi64(R2);
	asi64(R1) = !!asi64(R1);
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L1324;
L1326:
	asi64(R1) = index;
	R2 = 3;
	asi64(R1) &= asi64(R2);
	R2 = 2;
	asi64(R1) *= asi64(R2);
	shift = asi64(R1);
	asu64(R1) = q;
	asi64(R2) = index;
	R3 = 2;
	asi64(R2) >>= asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R1) &= asi64(R2);
	asi64(R2) = shift;
	asi64(R1) >>= asi64(R2);
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L1324;
L1327:
	asi64(R1) = index;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	R2 = 4;
	asi64(R1) *= asi64(R2);
	shift = asi64(R1);
	asu64(R1) = q;
	asi64(R2) = index;
	R3 = 1;
	asi64(R2) >>= asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R1) &= asi64(R2);
	asi64(R2) = shift;
	asi64(R1) >>= asi64(R2);
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L1324;
L1328:
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = tou64("bitix");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L1324:
	return;
}

static void qq_bits_var_putix_bits(u64 a, i64 index, u64 x) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 p;
	u64 q;
	i64 elemtype;
	i64 newoffset;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = (u64)&index;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = index;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L1331;
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L1333;
	R1 = tou64("");
	R2 = tou64("lwb");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L1332;
L1333:
	asi64(R1) = index;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L1334;
	asu64(R1) = x;
	asu64(R2) = p;
	qq_bits_obj_append_bits(asu64(R2), asu64(R1));
	goto L1332;
L1334:
	R1 = tou64("");
	R2 = tou64("bx[i]:=x bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1332:
L1331:
	R1 = (u64)&newoffset;
	asi64(R2) = elemtype;
	asi64(R3) = index;
	asu64(R4) = p;
	R5 = 7;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R5) = p;
	R6 = 8;
	asu64(R5) = *tou64p(((i64)R5+(i64)R6));
	asu64(R1) = qq_bits_getindexoffset(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	q = asu64(R1);
	R1 = 0;
	asi64(R2) = elemtype;
	asu64(R3) = x;
	asi64(R4) = newoffset;
	R5 = (u64)&qq_tables_ttbitwidth;
	asi64(R6) = elemtype;
	asu8(R5) = *tou8p(((i64)R5+(i64)R6));
	R5 = toi64(tou8(R5));
	asi64(R4) *= asi64(R5);
	asu64(R5) = q;
	qq_vars_var_storebit(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void qq_bits_var_getixref_bits(u64 a, i64 index) {
    u64 R1, R2, R3, R4, R5, R6; 
	struct $B3 v;
	u64 p;
	u64 q;
	i64 offset;
	i64 newoffset;
	i64 elemtype;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = (u64)&index;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = index;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L1337;
	R1 = tou64("");
	R2 = tou64("&bx[i] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1337:
	R1 = (u64)&newoffset;
	asi64(R2) = elemtype;
	asi64(R3) = index;
	asu64(R4) = p;
	R5 = 7;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R5) = p;
	R6 = 8;
	asu64(R5) = *tou64p(((i64)R5+(i64)R6));
	asu64(R1) = qq_bits_getindexoffset(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	q = asu64(R1);
	R1 = 15;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = elemtype;
	asu64(R2) = a;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = newoffset;
	R2 = (u64)&qq_tables_ttbitwidth;
	asi64(R3) = elemtype;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) *= asi64(R2);
	asu64(R2) = a;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static u64 qq_bits_getindexoffset(u64 p, i64 offset, i64 index, i64 t, u64 newoffset) {
    u64 R1, R2; 
	asi64(R1) = offset;
	R2 = (u64)&index;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = t;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L1340;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L1341;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L1342;
	goto L1343;
L1340:
	asi64(R1) = index;
	R2 = 3;
	asi64(R1) >>= asi64(R2);
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = index;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	asu64(R2) = newoffset;
	*toi64p(R2) = asi64(R1);
	goto L1339;
L1341:
	asi64(R1) = index;
	R2 = 2;
	asi64(R1) >>= asi64(R2);
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = index;
	R2 = 3;
	asi64(R1) &= asi64(R2);
	asu64(R2) = newoffset;
	*toi64p(R2) = asi64(R1);
	goto L1339;
L1342:
	asi64(R1) = offset;
	R2 = 2;
	asi64(R1) >>= asi64(R2);
	R2 = (u64)&index;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = index;
	R2 = 1;
	asi64(R1) >>= asi64(R2);
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = index;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	asu64(R2) = newoffset;
	*toi64p(R2) = asi64(R1);
	goto L1339;
L1343:
L1339:
	asu64(R1) = p;
	goto L1338;
L1338:
	return asu64(R1);
}

static void qq_bits_obj_append_bits(u64 a, u64 x) {
    u64 R1, R2, R3, R4, R5, R6; 
	i64 n;
	i64 newoffset;
	i64 elemtype;
	u64 q;
	asu64(R1) = a;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1346;
	R1 = tou64("");
	R2 = tou64("Can't extend slice");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1346:
	asu64(R1) = a;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L1348;
	qq_lib_pcnotmut();
L1348:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asu64(R1) = a;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = a;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L1350;
	asi64(R1) = n;
	asu64(R2) = a;
	qq_bits_obj_resize_bits(asu64(R2), asi64(R1));
	goto L1349;
L1350:
	asi64(R1) = n;
	asu64(R2) = a;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L1349:
	R1 = (u64)&newoffset;
	asi64(R2) = elemtype;
	asi64(R3) = n;
	asu64(R4) = a;
	R5 = 4;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 0;
    asi64(R4) = Getdotindex(asu64(R4), asi64(R5));
	asi64(R3) -= asi64(R4);
	asu64(R4) = a;
	R5 = 7;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R5) = a;
	R6 = 8;
	asu64(R5) = *tou64p(((i64)R5+(i64)R6));
	asu64(R1) = qq_bits_getindexoffset(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	q = asu64(R1);
	R1 = 0;
	asi64(R2) = elemtype;
	asu64(R3) = x;
	asi64(R4) = newoffset;
	R5 = (u64)&qq_tables_ttbitwidth;
	asi64(R6) = elemtype;
	asu8(R5) = *tou8p(((i64)R5+(i64)R6));
	R5 = toi64(tou8(R5));
	asi64(R4) *= asi64(R5);
	asu64(R5) = q;
	qq_vars_var_storebit(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void qq_bits_var_appendto_bits(u64 a, u64 x) {
    u64 R1, R2, R3; 
	asu64(R1) = x;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_bits_obj_append_bits(asu64(R2), asu64(R1));
	return;
}

static void qq_bits_obj_resize_bits(u64 p, i64 n) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 newsize;
	i64 elemtype;
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L1354;
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L1353;
L1354:
	asi64(R1) = elemtype;
	asi64(R2) = n;
	asi64(R1) = qq_bits_getbitssize(asi64(R2), asi64(R1));
	newsize = asi64(R1);
	asi64(R1) = newsize;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L1356;
	asu64(R1) = p;
	asu64(R1) = qq_bits_bits_bytesize(asu64(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = elemtype;
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_bits_getbitssize(asi64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L1356:
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = 8;
	R3 = (u64)&qq_tables_ttbitwidth;
	asi64(R4) = elemtype;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R2) /= asi64(R3);
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L1353:
	return;
}

static void qq_bits_var_dupl_bits(u64 a) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	i64 elemsize;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 4;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 0;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	asu64(R3) = p;
	R4 = 6;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	asu64(R1) = qq_bits_obj_newbits(asi64(R3), asi64(R2), asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L1359;
	asu64(R1) = p;
	asu64(R1) = qq_bits_bits_bytesize(asu64(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = q;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L1359:
	return;
}

static i64 qq_bits_var_equal_bits(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	i64 length;
	i64 elemsize;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemsize = asi64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = q;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	if (asi64(R1) == asi64(R2)) goto L1362;
	R1 = 0;
	goto L1360;
L1362:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asi64(R1) = length;
	asu64(R2) = q;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) == asi64(R2)) goto L1364;
	R1 = 0;
	goto L1360;
L1364:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1366;
	R1 = 1;
	goto L1360;
L1366:
	asu64(R1) = p;
	asi64(R1) = qq_bits_bits_bytesize(asu64(R1));
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R1) = mlib_eqbytes(asu64(R3), asu64(R2), asi64(R1));
	goto L1360;
L1360:
	return asi64(R1);
}

static void qq_bits_var_concatto_bits(u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 d;
	i64 n;
	i64 alen;
	i64 blen;
	i64 newlen;
	i64 oldbytes;
	i64 newbytes;
	i64 elemsize;
	u64 v;
	u64 pa;
	u64 pb;
	R1 = tou64("var_concatto_bits");
	R2 = tou64("VAR/BITS/NOT READY");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pb = asu64(R1);
	asu64(R1) = pa;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L1369;
	qq_lib_pcnotmut();
L1369:
	asu64(R1) = pa;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = pb;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	if (asi64(R1) == asi64(R2)) goto L1371;
	R1 = tou64("");
	R2 = tou64("concat/not compat");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1371:
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = pa;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	elemsize = asi64(R1);
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	alen = asi64(R1);
	asu64(R1) = pb;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	blen = asi64(R1);
	asi64(R1) = alen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1373;
	asi64(R1) = blen;
	if (!asi64(R1)) goto L1375;
	asi64(R1) = blen;
	asu64(R2) = pa;
	qq_bits_obj_resize_bits(asu64(R2), asi64(R1));
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = blen;
	asi64(R2) = elemsize;
	asu64(R1) *= asu64(R2);
	asu64(R2) = pb;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = d;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L1375:
	goto L1372;
L1373:
	asi64(R1) = blen;
	if (!asi64(R1)) goto L1376;
	asi64(R1) = alen;
	asi64(R2) = blen;
	asi64(R1) += asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	asu64(R2) = pa;
	qq_bits_obj_resize_bits(asu64(R2), asi64(R1));
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = alen;
	asi64(R3) = elemsize;
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	d = asu64(R1);
	asi64(R1) = blen;
	asi64(R2) = elemsize;
	asu64(R1) *= asu64(R2);
	asu64(R2) = pb;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = d;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L1376:
L1372:
	return;
}

static void qq_bits_var_getslice_bits(u64 a, i64 i, i64 j) {
    u64 R1, R2, R3, R4, R5, R6; 
	i64 alower;
	i64 elemtype;
	i64 newoffset;
	u64 p;
	u64 q;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	alower = asi64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = alower;
	if (asi64(R1) < asi64(R2)) goto L1380;
	asi64(R1) = j;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R3) = alower;
	asi64(R2) += asi64(R3);
	R3 = 1;
	asi64(R2) -= asi64(R3);
	if (asi64(R1) > asi64(R2)) goto L1380;
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) <= asi64(R2)) goto L1379;
L1380:
	R1 = tou64("");
	R2 = tou64("bits/slice bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1379:
	asu64(R1) = qq_vars_obj_new();
	q = asu64(R1);
	R1 = 1;
	asu64(R2) = q;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = q;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 1;
	asu64(R2) = q;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = elemtype;
	asu64(R2) = q;
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = (u64)&newoffset;
	asi64(R2) = elemtype;
	asi64(R3) = i;
	asi64(R4) = alower;
	asi64(R3) -= asi64(R4);
	asu64(R4) = p;
	R5 = 7;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R5) = p;
	R6 = 8;
	asu64(R5) = *tou64p(((i64)R5+(i64)R6));
	asu64(R1) = qq_bits_getindexoffset(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = newoffset;
	asu64(R2) = q;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1382;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1383;
	goto L1384;
L1382:
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_vars_obj_shareu(asu64(R1));
	goto L1381;
L1383:
	R1 = 0;
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2;
	asu64(R2) = q;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1381;
L1384:
	asu64(R1) = p;
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	(*tou32p(R1)) += 1;
L1381:
	asi64(R1) = j;
	asi64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = q;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static i64 qq_bits_bits_bytesize(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_bits_getbitssize(asi64(R2), asi64(R1));
	goto L1385;
L1385:
	return asi64(R1);
}

static i64 qq_bits_getbitssize(i64 n, i64 t) {
    u64 R1, R2, R3; 
	i64 nbits;
	asi64(R1) = n;
	R2 = (u64)&qq_tables_ttbitwidth;
	asi64(R3) = t;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) *= asi64(R2);
	nbits = asi64(R1);
	asi64(R1) = nbits;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = 64;
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) *= asi64(R2);
	goto L1386;
L1386:
	return asi64(R1);
}

static void qq_calldll_calldll(u64 d, u64 args, u64 result, i64 nargs) {
    u64 R1, R2, R3, R4, R5; 
	u64 e;
	struct $B28 arglist;
	i64 n;
	i64 retcode;
	i64 retval;
	i64 fnindex;
	i64 libindex;
	u64 dllinst;
	u64 fnaddr;
	u64 name;
	i64 i;
	asi64(R1) = nargs;
	R2 = 100;
	if (asi64(R1) <= asi64(R2)) goto L1389;
	R1 = tou64("");
	R2 = tou64("Too many dll args");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1389:
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nargs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1392;
L1390:
	asu64(R1) = e;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1394;
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 8;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L1396;
	R1 = 0;
	asu64(R2) = args;
	asi64(R1) = qq_calldll_vartopacked(asu64(R2), asu64(R1));
	R2 = (u64)&arglist;
	asi64(R3) = i;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&args;
	(*tou64p(R1)) += 16;
	goto L1395;
L1396:
	R1 = tou64("");
	R2 = tou64("Too many dll args");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1395:
	goto L1393;
L1394:
	asu64(R1) = e;
	asu64(R2) = args;
	asi64(R1) = qq_calldll_vartopacked(asu64(R2), asu64(R1));
	R2 = (u64)&arglist;
	asi64(R3) = i;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&args;
	(*tou64p(R1)) += 16;
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1393:
	i += 1; if (i <= nargs) goto L1390;
L1392:
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 32;
	if (asi64(R1) != asi64(R2)) goto L1398;
	R1 = 82;
	retcode = asi64(R1);
	goto L1397;
L1398:
	R1 = 73;
	retcode = asi64(R1);
L1397:
	asu64(R1) = d;
	asu64(R1) = qq_calldll_getlibprocaddr(asu64(R1));
	fnaddr = asu64(R1);
	R1 = 0;
	R2 = (u64)&arglist;
	asi64(R3) = nargs;
	asi64(R4) = retcode;
	asu64(R5) = fnaddr;
	asi64(R1) = mwindllc_os_calldllfunction(asu64(R5), asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	retval = asi64(R1);
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L1401;
	asu64(R1) = result;
	asu64(R2) = d;
	R3 = 116;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asi64(R3) = retval;
	qq_calldll_packedtovar(asu64(R3), asi64(R2), asu64(R1));
L1401:
	return;
}

static u64 qq_calldll_getlibprocaddr(u64 d) {
    u64 R1, R2, R3; 
	u64 fnaddr;
	R1 = (u64)&qq_decls_dllprocaddr;
	asu64(R2) = d;
	R3 = 96;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	fnaddr = asu64(R1);
	asu64(R1) = fnaddr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1404;
	asu64(R1) = d;
	asu64(R1) = qq_calldll_loaddllfunction(asu64(R1));
	fnaddr = asu64(R1);
L1404:
	asu64(R1) = fnaddr;
	goto L1402;
L1402:
	return asu64(R1);
}

static u64 qq_calldll_vartopacked(u64 p, u64 d) {
    u64 R1, R2, R3; 
	i64 s;
	i64 t;
	u64 a;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	s = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1407;
	asi64(R1) = s;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L1409;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1410;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1410;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L1410;
	goto L1411;
L1409:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_lib_convtostringz(asu64(R2), asi64(R1));
	goto L1405;
	goto L1408;
L1410:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L1405;
	goto L1408;
L1411:
	R1 = tou64("");
	R2 = tou64("Bad variadic param");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1408:
L1407:
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L1413;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L1413;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L1413;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L1413;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L1413;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L1413;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L1414;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L1415;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L1416;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L1417;
	goto L1418;
L1413:
	asi64(R1) = s;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1420;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L1420;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L1420;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1421;
	goto L1422;
L1420:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L1405;
	goto L1419;
L1421:
	asu64(R1) = p;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = tou64(asr64(R1));
	goto L1405;
	goto L1419;
L1422:
// qq_calldll.vartopacked.error:
L1423:
	msysc_m$print_startcon();
	R1 = tou64("'#' should be '#' (param # #)");
	msysc_m$print_setfmt(asu64(R1));
	R1 = 1;
	asi64(R2) = s;
	asu64(R1) = qq_show_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asi64(R2) = t;
	asu64(R1) = qq_show_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("DLL: wrong param type");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1419:
	goto L1412;
L1414:
	asi64(R1) = s;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1425;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1426;
	goto L1427;
L1425:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R1) = asu64(R1);
	goto L1405;
	goto L1424;
L1426:
	asu64(R1) = p;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R1) = asu64(R1);
	goto L1405;
	goto L1424;
L1427:
	goto L1423;
L1424:
	goto L1412;
L1415:
	asi64(R1) = s;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L1429;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L1430;
	goto L1431;
L1429:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_lib_convtostringz(asu64(R2), asi64(R1));
	goto L1405;
	goto L1428;
L1430:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L1405;
	goto L1428;
L1431:
	goto L1423;
L1428:
	goto L1412;
L1416:
	asi64(R1) = s;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L1433;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1434;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1434;
	goto L1435;
L1433:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L1405;
	goto L1432;
L1434:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L1405;
	goto L1432;
L1435:
	goto L1423;
L1432:
	goto L1412;
L1417:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	R1 += (i64)R2;
	goto L1405;
	goto L1412;
L1418:
	asi64(R1) = t;
	asi64(R2) = s;
	R3 = tou64("DLL params:");
	qq_runaux_pcmxtypestt(asu64(R3), asi64(R2), asi64(R1));
L1412:
	R1 = 0;
	goto L1405;
L1405:
	return asu64(R1);
}

static void qq_calldll_packedtovar(u64 retval, i64 t, u64 dest) {
    u64 R1, R2, R3; 
	i64 tbase;
	u64 a;
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	tbase = asi64(R1);
	asi64(R1) = tbase;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1438;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L1439;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L1440;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L1441;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L1441;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L1442;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L1443;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L1444;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L1445;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L1446;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L1447;
	goto L1448;
L1438:
	goto L1437;
L1439:
	R1 = 2;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = retval;
	asr64(R1) = asr64(R1);
	asu64(R2) = dest;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L1437;
L1440:
	R1 = tou64("");
	R2 = tou64("dll/r32ret");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L1437;
L1441:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = retval;
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L1437;
L1442:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = retval;
	asi64(R1) = toi64(toi32(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L1437;
L1443:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = retval;
	asi64(R1) = toi64(tou32(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L1437;
L1444:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = retval;
	asi64(R1) = toi64(toi16(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L1437;
L1445:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = retval;
	asi64(R1) = toi64(tou16(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L1437;
L1446:
	R1 = 16;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = retval;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R2) = dest;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L1437;
L1447:
	asu64(R1) = retval;
	if (!asu64(R1)) goto L1450;
	R1 = 0;
	asu64(R2) = dest;
	asu64(R3) = retval;
	qq_strings_var_make_string(asu64(R3), asu64(R2), asi64(R1));
	goto L1449;
L1450:
	R1 = 0;
	asu64(R2) = dest;
	R3 = tou64("");
	qq_strings_var_make_string(asu64(R3), asu64(R2), asi64(R1));
L1449:
	goto L1437;
L1448:
	R1 = (u64)&qq_tables_ttname;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("Rettype not supported:");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1437:
	return;
}

static u64 qq_calldll_loaddllfunction(u64 d) {
    u64 R1, R2, R3; 
	i64 fnindex;
	i64 libindex;
	u64 dllinst;
	u64 fnaddr;
	u64 name;
	asu64(R1) = d;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	fnindex = asi64(R1);
	R1 = (u64)&qq_decls_dllprocaddr;
	asi64(R2) = fnindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	fnaddr = asu64(R1);
	asu64(R1) = fnaddr;
	if (!asu64(R1)) goto L1453;
	asu64(R1) = fnaddr;
	goto L1451;
L1453:
	R1 = (u64)&qq_decls_dllproclibindex;
	asi64(R2) = fnindex;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	libindex = asi64(R1);
	R1 = (u64)&qq_decls_dllinsttable;
	asi64(R2) = libindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	dllinst = asu64(R1);
	asu64(R1) = dllinst;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1455;
	R1 = (u64)&qq_decls_libtable;
	asi64(R2) = libindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mwindows_os_getdllinst(asu64(R1));
	dllinst = asu64(R1);
	asu64(R1) = dllinst;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1457;
	R1 = (u64)&qq_decls_libtable;
	asi64(R2) = libindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't load DLL:");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1457:
	asu64(R1) = dllinst;
	R2 = (u64)&qq_decls_dllinsttable;
	asi64(R3) = libindex;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L1455:
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L1459;
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L1458;
L1459:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L1458:
	name = asu64(R1);
	asu64(R1) = name;
	asu64(R2) = dllinst;
	asu64(R1) = mwindows_os_getdllprocaddr(asi64(R2), asu64(R1));
	fnaddr = asu64(R1);
	asu64(R1) = fnaddr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1461;
	asu64(R1) = name;
	R2 = tou64("Can't find DLL func:");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1461:
	asu64(R1) = fnaddr;
	R2 = (u64)&qq_decls_dllprocaddr;
	asi64(R3) = fnindex;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = fnaddr;
	goto L1451;
L1451:
	return asu64(R1);
}

static void qq_decimal_obj_free_dec(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L1464;
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4;
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L1464:
	asu64(R1) = p;
	mlib_pcm_free32(asu64(R1));
	return;
}

static void qq_decimal_var_dupl_dec(u64 a) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	i64 size;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = qq_vars_obj_new();
	p = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = q;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = q;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 26;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4;
	asi64(R1) *= asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	if (!asi64(R1)) goto L1467;
	asi64(R1) = size;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = size;
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L1467:
	asu64(R1) = p;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_decimal_var_empty_dec(u64 dest) {
    u64 R1, R2, R3; 
	R1 = 259;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R1) = qq_decimal_makebignum(asi64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_decimal_var_make_dec_str(u64 s, i64 length, u64 dest) {
    u64 R1, R2, R3; 
	R1 = 259;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R1) = qq_decimal_bn_makestr(asu64(R2), asi64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_decimal_var_make_dec_int(i64 a, u64 dest) {
    u64 R1, R2, R3; 
	R1 = 259;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = a;
	asu64(R1) = qq_decimal_bn_makeint(asi64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 qq_decimal_badnumber() {
    u64 R1, R2, R3; 
	u64 c;
	R1 = 0;
	asu64(R1) = qq_decimal_makebignum(asi64(R1));
	c = asu64(R1);
	R1 = 3;
	asu64(R2) = c;
	R3 = 26;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = c;
	goto L1471;
L1471:
	return asu64(R1);
}

static u64 qq_decimal_bn_makestr(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 t;
	u64 u;
	u64 oldt;
	i64 tlength;
	i64 neg;
	i64 dpindex;
	i64 expon;
	i64 nonzeros;
	i64 talloc;
	i64 dpseen;
	i64 leadingzeros;
	i64 trailingzeros;
	i64 zerosafterdp;
	i64 d;
	i64 n;
	i64 wd;
	i64 dp;
	i64 wdp;
	i64 w;
	i64 d2;
	i64 na;
	i64 nb;
	i64 c;
	u64 a;
	i64 av_1;
	i64 av_2;
	i64 i;
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1474;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L1474:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L1476;
	asu64(R1) = qq_decimal_badnumber();
	goto L1472;
L1476:
	asi64(R1) = length;
	R2 = 1;
	asu64(R1) += asu64(R2);
	asu64(R1) = malloc(asu64(R1));
	t = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = t;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = t;
	oldt = asu64(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	tlength = asi64(R1);
	asu64(R1) = t;
	s = asu64(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 10;
	asi64(R1) += asi64(R2);
	talloc = asi64(R1);
	R1 = 0;
	neg = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) == asu64(R2)) goto L1478;
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L1479;
	goto L1480;
L1478:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L1477;
L1479:
	R1 = 1;
	neg = asi64(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L1477;
L1480:
L1477:
	asi64(R1) = talloc;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	u = asu64(R2);
	t = asu64(R1);
	R1 = -1;
	dpindex = asi64(R1);
	R1 = 0;
	R2 = R1;
	zerosafterdp = asi64(R2);
	dpseen = asi64(R1);
	R1 = 0;
	nonzeros = asi64(R1);
	R1 = 0;
	R2 = R1;
	trailingzeros = asi64(R2);
	leadingzeros = asi64(R1);
	R1 = 0;
	expon = asi64(R1);
L1481:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 49;
	if (asi64(R1) < asi64(R2)) goto L1484;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L1484;
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R2 = (u64)&u;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	trailingzeros = asi64(R1);
	R1 = 1;
	nonzeros = asi64(R1);
	goto L1483;
L1484:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L1486;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L1487;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L1487;
	R2 = 96;
	if (asi64(R1) == asi64(R2)) goto L1487;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L1487;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L1487;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1487;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L1488;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1489;
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L1490;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L1490;
	goto L1491;
L1486:
	asi64(R1) = nonzeros;
	if (!asi64(R1)) goto L1493;
	R1 = (u64)&trailingzeros;
	(*toi64p(R1)) += 1;
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R2 = (u64)&u;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1492;
L1493:
	R1 = (u64)&leadingzeros;
	(*toi64p(R1)) += 1;
	asi64(R1) = dpseen;
	if (!asi64(R1)) goto L1495;
	R1 = (u64)&zerosafterdp;
	(*toi64p(R1)) += 1;
L1495:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L1492:
	goto L1485;
L1487:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L1485;
L1488:
	asi64(R1) = dpseen;
	if (asi64(R1)) goto L1498;
	asi64(R1) = dpindex;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1497;
L1498:
	asu64(R1) = qq_decimal_badnumber();
	goto L1472;
L1497:
	asi64(R1) = nonzeros;
	if (!asi64(R1)) goto L1500;
	asu64(R1) = u;
	asu64(R2) = t;
	asi64(R1) -= asi64(R2);
	dpindex = asi64(R1);
	goto L1499;
L1500:
	R1 = 1;
	dpseen = asi64(R1);
L1499:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L1485;
L1489:
	goto L1482;
	goto L1485;
L1490:
	asu64(R1) = s;
	R2 = 1;
	R1 += (i64)R2;
	asi64(R1) = qq_decimal_readexpon(asu64(R1));
	expon = asi64(R1);
	goto L1482;
	goto L1485;
L1491:
	asu64(R1) = qq_decimal_badnumber();
	goto L1472;
L1485:
L1483:
	goto L1481;
L1482:
	R1 = 0;
	asu64(R2) = u;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = u;
	asu64(R2) = t;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = dpindex;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L1502;
	asi64(R1) = dpseen;
	if (!asi64(R1)) goto L1504;
	asi64(R1) = zerosafterdp;
	asi64(R1) = -asi64(R1);
	dpindex = asi64(R1);
	goto L1503;
L1504:
	asi64(R1) = length;
	dpindex = asi64(R1);
L1503:
L1502:
	asi64(R1) = trailingzeros;
	R2 = (u64)&length;
	*toi64p(R2) -= asi64(R1);
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1506;
	R1 = 0;
	asu64(R1) = qq_decimal_bn_makeint(asi64(R1));
	goto L1472;
L1506:
	asi64(R1) = dpindex;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R2) = expon;
	asi64(R1) += asi64(R2);
	d = asi64(R1);
	asi64(R1) = length;
	n = asi64(R1);
	R1 = 0;
	dp = asi64(R1);
	R1 = 1;
	na = asi64(R1);
	asi64(R1) = n;
	asi64(R2) = na;
	asi64(R1) -= asi64(R2);
	nb = asi64(R1);
	R1 = 9;
	w = asi64(R1);
	asi64(R1) = d;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1508;
	asi64(R1) = d;
	asi64(R2) = w;
	asi64(R1) /= asi64(R2);
	wd = asi64(R1);
	asi64(R1) = d;
	asi64(R2) = w;
	asi64(R1) %= asi64(R2);
	wdp = asi64(R1);
	goto L1507;
L1508:
	asi64(R1) = d;
	R2 = 1;
	asi64(R1) += asi64(R2);
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	d2 = asi64(R1);
	asi64(R1) = d2;
	asi64(R2) = w;
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R1) = -asi64(R1);
	wd = asi64(R1);
	asi64(R1) = w;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R2) = d2;
	asi64(R3) = w;
	asi64(R2) %= asi64(R3);
	asi64(R1) -= asi64(R2);
	wdp = asi64(R1);
L1507:
	asi64(R1) = wdp;
	R2 = 1;
	asi64(R1) += asi64(R2);
	na = asi64(R1);
	asi64(R1) = n;
	asi64(R2) = na;
	asi64(R1) -= asi64(R2);
	R2 = 0;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	nb = asi64(R1);
	goto L1510;
L1509:
	R1 = (u64)&nb;
	(*toi64p(R1)) += 1;
L1510:
	asi64(R1) = nb;
	asi64(R2) = w;
	asi64(R1) %= asi64(R2);
	if (asi64(R1)) goto L1509;
	asi64(R1) = nb;
	asi64(R2) = w;
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	length = asi64(R1);
	asu64(R1) = t;
	asi64(R2) = n;
	R1 += (i64)R2;
	u = asu64(R1);
	asi64(R1) = na;
	asi64(R2) = nb;
	asi64(R1) += asi64(R2);
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1514;
L1512:
	R1 = 48;
	R2 = (u64)&u;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	if (--asi64(av_1)) goto L1512;
L1514:
	asi64(R1) = na;
	asi64(R2) = nb;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = length;
	asu64(R1) = qq_decimal_makebignum(asi64(R1));
	a = asu64(R1);
	asi64(R1) = neg;
	asu64(R2) = a;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = wd;
	asu64(R2) = a;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = t;
	u = asu64(R1);
	asi64(R1) = na;
	asu64(R2) = u;
	asi64(R1) = qq_decimal_strvaln(asu64(R2), asi64(R1));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = na;
	R2 = (u64)&u;
	*tou64p(R2) += asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1517;
L1515:
	asi64(R1) = w;
	asu64(R2) = u;
	asi64(R1) = qq_decimal_strvaln(asu64(R2), asi64(R1));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = w;
	R2 = (u64)&u;
	*tou64p(R2) += asu64(R1);
	i += 1; if (i <= av_2) goto L1515;
L1517:
	asi64(R1) = talloc;
	asu64(R2) = t;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = oldt;
	free(asu64(R1));
	asu64(R1) = a;
	goto L1472;
L1472:
	return asu64(R1);
}

static i64 qq_decimal_readexpon(u64 s) {
    u64 R1, R2, R3; 
	i64 neg;
	i64 expon;
	i64 c;
	R1 = 0;
	R2 = R1;
	expon = asi64(R2);
	neg = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) == asu64(R2)) goto L1520;
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L1521;
	goto L1522;
L1520:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L1519;
L1521:
	R1 = 1;
	neg = asi64(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L1519;
L1522:
L1519:
L1523:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L1526;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L1526;
	asi64(R1) = expon;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asu64(R2) = s;
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	R3 = 48;
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	expon = asi64(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L1525;
L1526:
	asi64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L1528;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L1528;
	R2 = 96;
	if (asi64(R1) == asi64(R2)) goto L1528;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L1528;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1529;
	goto L1530;
L1528:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L1527;
L1529:
	goto L1524;
	goto L1527;
L1530:
	R1 = tou64("");
	R2 = tou64("make expon?");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1527:
L1525:
	goto L1523;
L1524:
	asi64(R1) = neg;
	if (!asi64(R1)) goto L1532;
	asi64(R1) = expon;
	asi64(R1) = -asi64(R1);
	goto L1531;
L1532:
	asi64(R1) = expon;
L1531:
	goto L1518;
L1518:
	return asi64(R1);
}

static u64 qq_decimal_bn_makeint(i64 x) {
    u64 R1, R2, R3; 
	u64 a;
	struct $B16 str;
	asi64(R1) = x;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1535;
	R1 = 0;
	asu64(R1) = qq_decimal_makebignum(asi64(R1));
	a = asu64(R1);
	goto L1534;
L1535:
	asi64(R1) = x;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1536;
	R2 = 999999999;
	if (asi64(R1) > asi64(R2)) goto L1536;
	R1 = 1;
	asu64(R1) = qq_decimal_makebignum(asi64(R1));
	a = asu64(R1);
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	goto L1534;
L1536:
	asi64(R1) = x;
	asi64(R1) = -asi64(R1);
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1537;
	R2 = 999999999;
	if (asi64(R1) > asi64(R2)) goto L1537;
	R1 = 1;
	asu64(R1) = qq_decimal_makebignum(asi64(R1));
	a = asu64(R1);
	asi64(R1) = x;
	asi64(R1) = -asi64(R1);
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L1534;
L1537:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asi64(R1) = x;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = (u64)&str;
	asu64(R1) = qq_decimal_bn_makestr(asu64(R2), asi64(R1));
	a = asu64(R1);
L1534:
	asu64(R1) = a;
	goto L1533;
L1533:
	return asu64(R1);
}

static u64 qq_decimal_var_tostr_dec(u64 a, i64 fmt) {
    u64 R1, R2, R3; 
	asi64(R1) = fmt;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_decimal_obj_tostr_dec(asu64(R2), asi64(R1));
	goto L1538;
L1538:
	return asu64(R1);
}

static u64 qq_decimal_obj_tostr_dec(u64 a, i64 fmt) {
    u64 R1, R2, R3; 
	i64 expon;
	i64 upper;
	u64 s;
	u64 t;
	R1 = 0;
	t = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1541;
	R1 = tou64("<void>");
	t = asu64(R1);
	goto L1540;
L1541:
	asu64(R1) = a;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1543;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1544;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1545;
	goto L1546;
L1543:
	asi64(R1) = fmt;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L1549;
	asi64(R1) = fmt;
	R2 = 70;
	if (asi64(R1) != asi64(R2)) goto L1548;
L1549:
	R1 = tou64("0.0");
	goto L1547;
L1548:
	R1 = tou64("0");
L1547:
	t = asu64(R1);
	goto L1542;
L1544:
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L1551;
	R1 = tou64("-Infinity");
	goto L1550;
L1551:
	R1 = tou64("Infinity");
L1550:
	t = asu64(R1);
	goto L1542;
L1545:
	R1 = tou64("<NaN>");
	t = asu64(R1);
	goto L1542;
L1546:
L1542:
L1540:
	asu64(R1) = t;
	if (!asu64(R1)) goto L1553;
	asu64(R1) = t;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = R1;
	qq_decimal_decstrsize = asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	s = asu64(R1);
	asu64(R1) = t;
	asu64(R2) = s;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = s;
	goto L1539;
L1553:
	asi64(R1) = fmt;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1556;
	asi64(R1) = fmt;
	R2 = 65;
	if (asi64(R1) != asi64(R2)) goto L1555;
L1556:
	asu64(R1) = a;
	asi64(R1) = qq_decimal_bn_isint(asu64(R1));
	if (!asi64(R1)) goto L1558;
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = 9;
	asi64(R1) *= asi64(R2);
	R2 = 60;
	if (asi64(R1) >= asi64(R2)) goto L1558;
	R1 = 73;
	fmt = asi64(R1);
	goto L1557;
L1558:
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 9;
	asi64(R1) *= asi64(R2);
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	R2 = 60;
	if (asi64(R1) >= asi64(R2)) goto L1559;
	R1 = 70;
	fmt = asi64(R1);
	goto L1557;
L1559:
	R1 = 69;
	fmt = asi64(R1);
L1557:
L1555:
	asi64(R1) = fmt;
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L1561;
	asu64(R1) = a;
	asu64(R1) = qq_decimal_tostring_scient(asu64(R1));
	s = asu64(R1);
	goto L1560;
L1561:
	asi64(R1) = fmt;
	asu64(R2) = a;
	asu64(R1) = qq_decimal_tostring_float(asu64(R2), asi64(R1));
	s = asu64(R1);
L1560:
	asu64(R1) = s;
	goto L1539;
L1539:
	return asu64(R1);
}

static u64 qq_decimal_tostring_scient(u64 a) {
    u64 R1, R2, R3, R4; 
	u64 s;
	u64 t;
	i64 expon;
	i64 nchars;
	i64 n;
	i64 shift;
	i64 x;
	i64 scale;
	i64 av_1;
	i64 i;
	R1 = 3;
	nchars = asi64(R1);
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 9;
	asi64(R1) *= asi64(R2);
	expon = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	x = asi64(R1);
	R1 = 1;
	scale = asi64(R1);
	R1 = 0;
	shift = asi64(R1);
	goto L1564;
L1563:
	asi64(R1) = x;
	R2 = 10;
	asi64(R1) /= asi64(R2);
	x = asi64(R1);
	R1 = 10;
	R2 = (u64)&scale;
	*toi64p(R2) *= asi64(R1);
	R1 = (u64)&expon;
	(*toi64p(R1)) += 1;
	R1 = (u64)&shift;
	(*toi64p(R1)) += 1;
L1564:
	asi64(R1) = x;
	R2 = 10;
	if (asi64(R1) >= asi64(R2)) goto L1563;
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 9;
	asi64(R1) *= asi64(R2);
	R2 = 16;
	asi64(R1) += asi64(R2);
	nchars = asi64(R1);
	asi64(R1) = nchars;
	R2 = R1;
	qq_decimal_decstrsize = asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	t = asu64(R2);
	s = asu64(R1);
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L1567;
	R1 = 45;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L1567:
	asu64(R1) = t;
	msysc_m$print_startstr(asu64(R1));
	asi64(R1) = x;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = t;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = shift;
	if (!asi64(R1)) goto L1569;
	asu64(R1) = t;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("v");
	asi64(R2) = shift;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("z*");
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R3) = x;
	asi64(R4) = scale;
	asi64(R3) *= asi64(R4);
	asi64(R2) -= asi64(R3);
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = t;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
L1569:
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1572;
L1570:
	asu64(R1) = t;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("z9");
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = t;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	i += 1; if (i <= av_1) goto L1570;
L1572:
	goto L1574;
L1573:
	R1 = (u64)&t;
	(*tou64p(R1)) -=1;
L1574:
	asu64(R1) = t;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) != asu64(R2)) goto L1576;
	asu64(R1) = t;
	R2 = 2;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L1573;
L1576:
	asu64(R1) = t;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("e");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = expon;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	asu64(R1) = t;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = s;
	goto L1562;
L1562:
	return asu64(R1);
}

static u64 qq_decimal_tostring_float(u64 a, i64 fmt) {
    u64 R1, R2, R3; 
	i64 expon;
	i64 upper;
	i64 nchars;
	i64 w;
	i64 prel;
	i64 n;
	i64 showdot;
	u64 s;
	u64 t;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 av_4;
	i64 i;
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	expon = asi64(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	upper = asi64(R1);
	asi64(R1) = fmt;
	R2 = 73;
	if (asi64(R1) != asi64(R2)) goto L1579;
	asu64(R1) = a;
	asi64(R1) = qq_decimal_bn_isint(asu64(R1));
	if (!asi64(R1)) goto L1579;
	R1 = 0;
	showdot = asi64(R1);
	goto L1578;
L1579:
	R1 = 1;
	showdot = asi64(R1);
L1578:
	R1 = 9;
	w = asi64(R1);
	R1 = 3;
	nchars = asi64(R1);
	asi64(R1) = expon;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L1581;
	asi64(R1) = expon;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	asi64(R2) = w;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&nchars;
	*toi64p(R2) += asi64(R1);
L1581:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = w;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&nchars;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = expon;
	asi64(R2) = upper;
	asi64(R1) -= asi64(R2);
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1583;
	asi64(R1) = expon;
	asi64(R2) = upper;
	asi64(R1) -= asi64(R2);
	asi64(R2) = w;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&nchars;
	*toi64p(R2) += asi64(R1);
L1583:
	R1 = 8;
	R2 = (u64)&nchars;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = nchars;
	R2 = R1;
	qq_decimal_decstrsize = asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	t = asu64(R2);
	s = asu64(R1);
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L1585;
	R1 = 45;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L1585:
	R1 = 0;
	prel = asi64(R1);
	asi64(R1) = expon;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L1587;
	R1 = 1;
	prel = asi64(R1);
	R1 = 48;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 46;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = expon;
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1590;
L1588:
	R1 = 9;
	av_1 = asi64(R1);
L1591:
	R1 = 48;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	if (--asi64(av_1)) goto L1591;
	if (--asi64(av_2)) goto L1588;
L1590:
L1587:
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = upper;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1596;
L1594:
	asu64(R1) = t;
	msysc_m$print_startstr(asu64(R1));
	asi64(R1) = i;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L1599;
	asi64(R1) = prel;
	if (!asi64(R1)) goto L1598;
L1599:
	R1 = tou64("z9");
	goto L1597;
L1598:
	R1 = tou64("");
L1597:
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = t;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = expon;
	asi64(R2) = i;
	if (asi64(R1) != asi64(R2)) goto L1601;
	asi64(R1) = i;
	asi64(R2) = upper;
	if (asi64(R1) >= asi64(R2)) goto L1601;
	asi64(R1) = showdot;
	if (!asi64(R1)) goto L1601;
	R1 = 46;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L1601:
	i += 1; if (i <= upper) goto L1594;
L1596:
	asi64(R1) = expon;
	asi64(R2) = upper;
	asi64(R1) -= asi64(R2);
	av_4 = asi64(R1);
	asi64(R1) = av_4;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1604;
L1602:
	R1 = 9;
	av_3 = asi64(R1);
L1605:
	R1 = 48;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	if (--asi64(av_3)) goto L1605;
	if (--asi64(av_4)) goto L1602;
L1604:
	asi64(R1) = expon;
	asi64(R2) = upper;
	if (asi64(R1) < asi64(R2)) goto L1609;
	asi64(R1) = showdot;
	if (!asi64(R1)) goto L1609;
	R1 = 46;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 48;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L1609:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = s;
	goto L1577;
L1577:
	return asu64(R1);
}

static i64 qq_decimal_strvaln(u64 s, i64 n) {
    u64 R1, R2; 
	i64 a;
	i64 av_1;
	R1 = 0;
	a = asi64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1613;
L1611:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 95;
	if (asu64(R1) == asu64(R2)) goto L1615;
	asi64(R1) = a;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asu64(R2) = s;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	a = asi64(R1);
L1615:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L1611;
L1613:
	asi64(R1) = a;
	goto L1610;
L1610:
	return asi64(R1);
}

static i64 qq_decimal_bn_isint(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 1;
	asi64(R2) += asi64(R3);
	asi64(R1) = asi64(R1)  <=  asi64(R2);
	goto L1616;
L1616:
	return asi64(R1);
}

static i64 qq_decimal_obj_len_dec(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	asi64(R1) = qq_decimal_bn_getprec(asu64(R1));
	goto L1617;
	asu64(R1) = a;
	asi64(R1) = qq_decimal_bn_isint(asu64(R1));
	if (asi64(R1)) goto L1619;
	R1 = 0;
	goto L1617;
L1619:
	asu64(R1) = a;
	asi64(R1) = qq_decimal_bn_iszero(asu64(R1));
	if (!asi64(R1)) goto L1621;
	R1 = 1;
	goto L1617;
L1621:
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = a;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 9;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	goto L1617;
L1617:
	return asi64(R1);
}

static i64 qq_decimal_bn_iszero(u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L1622;
L1622:
	return asi64(R1);
}

static i64 qq_decimal_var_equal_dec(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_decimal_bn_equal(asu64(R2), asu64(R1));
	goto L1623;
L1623:
	return asi64(R1);
}

static void qq_decimal_var_add_dec(u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 dest;
	asu64(R1) = qq_decimal_bn_init();
	dest = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	asi64(R1) = qq_decimal_bn_add(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = dest;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_decimal_var_sub_dec(u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 dest;
	asu64(R1) = qq_decimal_bn_init();
	dest = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	asi64(R1) = qq_decimal_bn_sub(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = dest;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_decimal_var_mul_dec(u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 dest;
	asu64(R1) = qq_decimal_bn_init();
	dest = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	asi64(R1) = qq_decimal_bn_mul(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = dest;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_decimal_var_div_dec(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	u64 dest;
	asu64(R1) = qq_decimal_bn_init();
	dest = asu64(R1);
	R1 = 0;
	asu64(R2) = b;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = a;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = dest;
	asi64(R1) = qq_decimal_bn_div(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = dest;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_decimal_var_idiv_dec(u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 dest;
	asu64(R1) = qq_decimal_bn_init();
	dest = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	asi64(R1) = qq_decimal_bn_idiv(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = dest;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_decimal_var_irem_dec(u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 dest;
	asu64(R1) = qq_decimal_bn_init();
	dest = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	asi64(R1) = qq_decimal_bn_irem(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = dest;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_decimal_var_neg_dec(u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_decimal_bn_negto(asu64(R1));
	return;
}

static void qq_decimal_var_abs_dec(u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_decimal_bn_absto(asu64(R1));
	return;
}

static i64 qq_decimal_var_compare_dec(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_decimal_bn_cmp(asu64(R2), asu64(R1));
	goto L1632;
L1632:
	return asi64(R1);
}

static i64 qq_decimal_bn_cmp(u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 d;
	i64 neg;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_decimal_bn_equal(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L1635;
	R1 = 0;
	goto L1633;
L1635:
	asu64(R1) = qq_decimal_bn_init();
	d = asu64(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = d;
	asi64(R1) = qq_decimal_bn_sub(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	neg = asi64(R1);
	asu64(R1) = d;
	qq_decimal_obj_free_dec(asu64(R1));
	asi64(R1) = neg;
	if (!asi64(R1)) goto L1637;
	R1 = -1;
	goto L1636;
L1637:
	R1 = 1;
L1636:
	goto L1633;
L1633:
	return asi64(R1);
}

static i64 qq_decimal_bn_equal(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1640;
	asu64(R1) = a;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = b;
	R3 = 26;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	if (asi64(R1) != asi64(R2)) goto L1640;
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = b;
	R3 = 24;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L1638;
L1640:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L1643;
	asu64(R1) = a;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = b;
	R3 = 26;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	if (asi64(R1) != asi64(R2)) goto L1643;
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = b;
	R3 = 24;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	if (asi64(R1) != asi64(R2)) goto L1643;
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = b;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) == asi64(R2)) goto L1642;
L1643:
	R1 = 0;
	goto L1638;
L1642:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1645;
	R1 = 1;
	goto L1638;
L1645:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4;
	asi64(R1) *= asi64(R2);
	asu64(R2) = b;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = a;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R1) = mlib_eqbytes(asu64(R3), asu64(R2), asi64(R1));
	goto L1638;
L1638:
	return asi64(R1);
}

static i64 qq_decimal_bn_add(u64 dest, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 nega;
	i64 negb;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_decimal_getbintype(asu64(R2), asu64(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1648;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1649;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1650;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1651;
	goto L1652;
L1648:
	goto L1647;
L1649:
	asu64(R1) = dest;
	qq_decimal_bn_setzero(asu64(R1));
	R1 = 1;
	goto L1646;
	goto L1647;
L1650:
	asu64(R1) = a;
	asu64(R2) = dest;
	qq_decimal_bn_dupl(asu64(R2), asu64(R1));
	R1 = 1;
	goto L1646;
	goto L1647;
L1651:
	asu64(R1) = b;
	asu64(R2) = dest;
	qq_decimal_bn_dupl(asu64(R2), asu64(R1));
	R1 = 1;
	goto L1646;
	goto L1647;
L1652:
	asu64(R1) = dest;
	qq_decimal_bn_setnan(asu64(R1));
	R1 = 0;
	goto L1646;
L1647:
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	nega = asi64(R1);
	asu64(R1) = b;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	negb = asi64(R1);
	asi64(R1) = nega;
	if (asi64(R1)) goto L1654;
	asi64(R1) = negb;
	if (asi64(R1)) goto L1654;
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = dest;
	qq_decimal_bn_addu(asu64(R3), asu64(R2), asu64(R1));
	goto L1653;
L1654:
	asi64(R1) = nega;
	if (!asi64(R1)) goto L1655;
	asi64(R1) = negb;
	if (!asi64(R1)) goto L1655;
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = dest;
	qq_decimal_bn_addu(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = dest;
	qq_decimal_bn_negto(asu64(R1));
	goto L1653;
L1655:
	asi64(R1) = nega;
	if (asi64(R1)) goto L1656;
	asi64(R1) = negb;
	if (!asi64(R1)) goto L1656;
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = dest;
	qq_decimal_bn_subu(asu64(R3), asu64(R2), asu64(R1));
	goto L1653;
L1656:
	asu64(R1) = a;
	asu64(R2) = b;
	asu64(R3) = dest;
	qq_decimal_bn_subu(asu64(R3), asu64(R2), asu64(R1));
L1653:
	R1 = 1;
	goto L1646;
L1646:
	return asi64(R1);
}

static i64 qq_decimal_bn_sub(u64 dest, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 nega;
	i64 negb;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_decimal_getbintype(asu64(R2), asu64(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1659;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1660;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1661;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1662;
	goto L1663;
L1659:
	goto L1658;
L1660:
	asu64(R1) = dest;
	qq_decimal_bn_setzero(asu64(R1));
	R1 = 1;
	goto L1657;
	goto L1658;
L1661:
	asu64(R1) = a;
	asu64(R2) = dest;
	qq_decimal_bn_dupl(asu64(R2), asu64(R1));
	R1 = 1;
	goto L1657;
	goto L1658;
L1662:
	asu64(R1) = b;
	asu64(R2) = dest;
	qq_decimal_bn_dupl(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	qq_decimal_bn_negto(asu64(R1));
	R1 = 1;
	goto L1657;
	goto L1658;
L1663:
	asu64(R1) = dest;
	qq_decimal_bn_setnan(asu64(R1));
	R1 = 0;
	goto L1657;
L1658:
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	nega = asi64(R1);
	asu64(R1) = b;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	negb = asi64(R1);
	asi64(R1) = nega;
	if (asi64(R1)) goto L1665;
	asi64(R1) = negb;
	if (asi64(R1)) goto L1665;
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = dest;
	qq_decimal_bn_subu(asu64(R3), asu64(R2), asu64(R1));
	goto L1664;
L1665:
	asi64(R1) = nega;
	if (!asi64(R1)) goto L1666;
	asi64(R1) = negb;
	if (!asi64(R1)) goto L1666;
	asu64(R1) = a;
	asu64(R2) = b;
	asu64(R3) = dest;
	qq_decimal_bn_subu(asu64(R3), asu64(R2), asu64(R1));
	goto L1664;
L1666:
	asi64(R1) = nega;
	if (asi64(R1)) goto L1667;
	asi64(R1) = negb;
	if (!asi64(R1)) goto L1667;
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = dest;
	qq_decimal_bn_addu(asu64(R3), asu64(R2), asu64(R1));
	goto L1664;
L1667:
	asu64(R1) = b;
	asu64(R2) = dest;
	qq_decimal_bn_dupl(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	qq_decimal_bn_negto(asu64(R1));
	asu64(R1) = dest;
	asu64(R2) = a;
	asu64(R3) = dest;
	asi64(R1) = qq_decimal_bn_add(asu64(R3), asu64(R2), asu64(R1));
L1664:
	R1 = 1;
	goto L1657;
L1657:
	return asi64(R1);
}

static void qq_decimal_bn_addu(u64 dest, u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	i64 preca;
	i64 precb;
	i64 precc;
	i64 uppera;
	i64 upperb;
	i64 upperc;
	i64 offset;
	i64 carry;
	i64 expona;
	i64 exponb;
	i64 dc;
	u64 j;
	u64 pa;
	u64 pb;
	u64 pax;
	u64 pbx;
	u64 c;
	u64 c2;
	i64 i;
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = b;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) >= asi64(R2)) goto L1670;
	R1 = (u64)&a;
	R2 = (u64)&b;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L1670:
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	expona = asi64(R1);
	asu64(R1) = b;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	exponb = asi64(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	preca = asi64(R1);
	asu64(R1) = b;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	precb = asi64(R1);
	asi64(R1) = expona;
	asi64(R2) = exponb;
	asi64(R1) -= asi64(R2);
	offset = asi64(R1);
	asi64(R1) = preca;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	uppera = asi64(R1);
	asi64(R1) = precb;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	upperb = asi64(R1);
	asi64(R1) = uppera;
	asi64(R2) = upperb;
	asi64(R3) = offset;
	asi64(R2) += asi64(R3);
	if (asi64(R1) <= asi64(R2)) goto L1672;
	asi64(R1) = uppera;
	upperc = asi64(R1);
	goto L1671;
L1672:
	asi64(R1) = upperb;
	asi64(R2) = offset;
	asi64(R1) += asi64(R2);
	upperc = asi64(R1);
L1671:
	asi64(R1) = upperc;
	R2 = 1;
	asi64(R1) += asi64(R2);
	precc = asi64(R1);
	asi64(R1) = precc;
	asu64(R1) = qq_decimal_makesmallnum(asi64(R1));
	c = asu64(R1);
	R1 = 0;
	carry = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pb = asu64(R1);
	asi64(R1) = upperc;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1675;
L1673:
	asi64(R1) = i;
	asi64(R2) = offset;
	asu64(R1) -= asu64(R2);
	j = asu64(R1);
	asi64(R1) = i;
	asi64(R2) = uppera;
	if (asi64(R1) > asi64(R2)) goto L1677;
	asu64(R1) = j;
	asi64(R2) = upperb;
	if (asu64(R1) > asu64(R2)) goto L1677;
	asu64(R1) = pa;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asu64(R2) = pb;
	asu64(R3) = j;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	asi64(R2) = carry;
	asi64(R1) += asi64(R2);
	dc = asi64(R1);
	goto L1676;
L1677:
	asi64(R1) = i;
	asi64(R2) = uppera;
	if (asi64(R1) > asi64(R2)) goto L1678;
	asu64(R1) = pa;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asi64(R2) = carry;
	asi64(R1) += asi64(R2);
	dc = asi64(R1);
	goto L1676;
L1678:
	asu64(R1) = j;
	asi64(R2) = upperb;
	if (asu64(R1) > asu64(R2)) goto L1679;
	asu64(R1) = pb;
	asu64(R2) = j;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asi64(R2) = carry;
	asi64(R1) += asi64(R2);
	dc = asi64(R1);
	goto L1676;
L1679:
	asi64(R1) = carry;
	dc = asi64(R1);
L1676:
	asi64(R1) = dc;
	R2 = 1000000000;
	if (asi64(R1) < asi64(R2)) goto L1681;
	R1 = 1;
	carry = asi64(R1);
	asi64(R1) = dc;
	R2 = 1000000000;
	asi64(R1) -= asi64(R2);
	asu64(R2) = c;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	goto L1680;
L1681:
	asi64(R1) = dc;
	asu64(R2) = c;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 0;
	carry = asi64(R1);
L1680:
	i += -1; if (i >= 0) goto L1673;
L1675:
	asi64(R1) = carry;
	if (!asi64(R1)) goto L1683;
	asi64(R1) = precc;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = qq_decimal_makesmallnum(asi64(R1));
	c2 = asu64(R1);
	asi64(R1) = carry;
	asu64(R2) = c2;
	*toi32p(R2) = asi32(R1);
	asi64(R1) = precc;
	R2 = 4;
	asu64(R1) *= asu64(R2);
	asu64(R2) = c;
	asu64(R3) = c2;
	R4 = 1;
	R3 += (i64)R4*4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = precc;
	asu64(R2) = c;
	qq_decimal_freesmall(asu64(R2), asi64(R1));
	asu64(R1) = c2;
	c = asu64(R1);
	R1 = (u64)&precc;
	(*toi64p(R1)) += 1;
L1683:
	R1 = 0;
	asi64(R2) = precc;
	asi64(R3) = precc;
	asu64(R4) = c;
	asu64(R5) = dest;
	asu64(R1) = qq_decimal_smalltobig(asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = expona;
	asi64(R2) = carry;
	asi64(R1) += asi64(R2);
	asu64(R2) = dest;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void qq_decimal_bn_subu(u64 dest, u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	i64 preca;
	i64 precb;
	i64 precc;
	i64 uppera;
	i64 upperb;
	i64 upperc;
	i64 offset;
	i64 carry;
	i64 expona;
	i64 da;
	i64 db;
	i64 dc;
	i64 isneg;
	i64 z;
	i64 newprec;
	i64 diff;
	u64 j;
	u64 pa;
	u64 pb;
	u64 c;
	i64 i;
	R1 = 0;
	isneg = asi64(R1);
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = b;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) >= asi64(R2)) goto L1686;
	R1 = (u64)&a;
	R2 = (u64)&b;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
	R1 = 1;
	isneg = asi64(R1);
L1686:
// qq_decimal.bn_subu.retry:
L1687:
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	expona = asi64(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	preca = asi64(R1);
	asu64(R1) = b;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	precb = asi64(R1);
	asi64(R1) = expona;
	asu64(R2) = b;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	offset = asi64(R1);
	asi64(R1) = preca;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	uppera = asi64(R1);
	asi64(R1) = precb;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	upperb = asi64(R1);
	asi64(R1) = uppera;
	asi64(R2) = upperb;
	asi64(R3) = offset;
	asi64(R2) += asi64(R3);
	if (asi64(R1) <= asi64(R2)) goto L1689;
	asi64(R1) = uppera;
	upperc = asi64(R1);
	goto L1688;
L1689:
	asi64(R1) = upperb;
	asi64(R2) = offset;
	asi64(R1) += asi64(R2);
	upperc = asi64(R1);
L1688:
	asi64(R1) = upperc;
	R2 = 1;
	asi64(R1) += asi64(R2);
	precc = asi64(R1);
	asi64(R1) = precc;
	asu64(R1) = qq_decimal_makesmallnum(asi64(R1));
	c = asu64(R1);
	R1 = 0;
	carry = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pb = asu64(R1);
	asi64(R1) = upperc;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1692;
L1690:
	asi64(R1) = i;
	asi64(R2) = offset;
	asu64(R1) -= asu64(R2);
	j = asu64(R1);
	asi64(R1) = i;
	asi64(R2) = uppera;
	if (asi64(R1) > asi64(R2)) goto L1694;
	asu64(R1) = j;
	asi64(R2) = upperb;
	if (asu64(R1) > asu64(R2)) goto L1694;
	asu64(R1) = pa;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asu64(R2) = pb;
	asu64(R3) = j;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	asi64(R2) = carry;
	asi64(R1) -= asi64(R2);
	diff = asi64(R1);
	goto L1693;
L1694:
	asi64(R1) = i;
	asi64(R2) = uppera;
	if (asi64(R1) > asi64(R2)) goto L1695;
	asu64(R1) = pa;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asi64(R2) = carry;
	asi64(R1) -= asi64(R2);
	diff = asi64(R1);
	goto L1693;
L1695:
	asu64(R1) = j;
	asi64(R2) = upperb;
	if (asu64(R1) > asu64(R2)) goto L1696;
	asu64(R1) = pb;
	asu64(R2) = j;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asi64(R1) = -asi64(R1);
	asi64(R2) = carry;
	asi64(R1) -= asi64(R2);
	diff = asi64(R1);
	goto L1693;
L1696:
	asi64(R1) = carry;
	asi64(R1) = -asi64(R1);
	diff = asi64(R1);
L1693:
	asi64(R1) = diff;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L1698;
	R1 = 1;
	carry = asi64(R1);
	asi64(R1) = diff;
	R2 = 1000000000;
	asi64(R1) += asi64(R2);
	asu64(R2) = c;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	goto L1697;
L1698:
	asi64(R1) = diff;
	asu64(R2) = c;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 0;
	carry = asi64(R1);
L1697:
	i += -1; if (i >= 0) goto L1690;
L1692:
	asi64(R1) = carry;
	if (!asi64(R1)) goto L1700;
	asi64(R1) = isneg;
	if (!asi64(R1)) goto L1702;
	R1 = tou64("");
	R2 = tou64("SUBU/CARRY");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1702:
	R1 = (u64)&a;
	R2 = (u64)&b;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
	R1 = 1;
	isneg = asi64(R1);
	asi64(R1) = precc;
	asu64(R2) = c;
	qq_decimal_freesmall(asu64(R2), asi64(R1));
	goto L1687;
L1700:
	R1 = 0;
	asi64(R2) = precc;
	asi64(R3) = precc;
	asu64(R4) = c;
	asu64(R5) = dest;
	asu64(R1) = qq_decimal_smalltobig(asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = isneg;
	asu64(R2) = dest;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = expona;
	asi64(R2) = qq_decimal_stblz;
	asi64(R1) -= asi64(R2);
	asu64(R2) = dest;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static u64 qq_decimal_makebignum(i64 length) {
    u64 R1, R2, R3; 
	u64 a;
	asu64(R1) = qq_vars_obj_new();
	a = asu64(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L1705;
	asi64(R1) = length;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 26;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L1704;
L1705:
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = a;
	R3 = 26;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L1704:
	asi64(R1) = length;
	asu64(R2) = a;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	asu64(R2) = a;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asu64(R2) = a;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = a;
	goto L1703;
L1703:
	return asu64(R1);
}

static u64 qq_decimal_makesmallnum(i64 length) {
    u64 R1, R2; 
	asi64(R1) = length;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	goto L1706;
L1706:
	return asu64(R1);
}

static u64 qq_decimal_smalltobig(u64 c, u64 a, i64 length, i64 alloc, i64 offset) {
    u64 R1, R2, R3, R4; 
	u64 p;
	i64 leadingzeros;
	i64 trailingzeros;
	i64 nonzeros;
	i64 newlength;
	i64 av_1;
	asu64(R1) = c;
	qq_decimal_bn_setzero(asu64(R1));
	asu64(R1) = a;
	p = asu64(R1);
	R1 = 0;
	R2 = R1;
	nonzeros = asi64(R2);
	R2 = R1;
	trailingzeros = asi64(R2);
	leadingzeros = asi64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1710;
L1708:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 4; asu64(R1) = asu64(R2);
	asi32(R1) = *toi32p(R1);
	if (!asi32(R1)) goto L1712;
	R1 = 1;
	nonzeros = asi64(R1);
	R1 = 0;
	trailingzeros = asi64(R1);
	goto L1711;
L1712:
	asi64(R1) = nonzeros;
	if (!asi64(R1)) goto L1714;
	R1 = (u64)&trailingzeros;
	(*toi64p(R1)) += 1;
	goto L1713;
L1714:
	R1 = (u64)&leadingzeros;
	(*toi64p(R1)) += 1;
L1713:
L1711:
	if (--asi64(av_1)) goto L1708;
L1710:
	asi64(R1) = leadingzeros;
	qq_decimal_stblz = asi64(R1);
	asi64(R1) = nonzeros;
	if (!asi64(R1)) goto L1716;
	asi64(R1) = length;
	asi64(R2) = trailingzeros;
	asi64(R1) -= asi64(R2);
	asi64(R2) = leadingzeros;
	asi64(R1) -= asi64(R2);
	newlength = asi64(R1);
	asi64(R1) = newlength;
	asi64(R2) = length;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L1718;
	asi64(R2) = alloc;
	if (asi64(R1) != asi64(R2)) goto L1718;
	asu64(R1) = a;
	asu64(R2) = c;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1717;
L1718:
	asi64(R1) = newlength;
	asu64(R1) = qq_decimal_makesmallnum(asi64(R1));
	asu64(R2) = c;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = newlength;
	R2 = 4;
	asu64(R1) *= asu64(R2);
	asu64(R2) = a;
	asi64(R3) = leadingzeros;
	R2 += (i64)R3*4;
	asu64(R3) = c;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = alloc;
	asu64(R2) = a;
	asi64(R3) = offset;
	R2 += (i64)R3*4;
	qq_decimal_freesmall(asu64(R2), asi64(R1));
L1717:
	asi64(R1) = newlength;
	asu64(R2) = c;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = c;
	R3 = 26;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R2) = leadingzeros;
	asi64(R1) -= asi64(R2);
	asu64(R2) = c;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L1715;
L1716:
	asi64(R1) = alloc;
	if (!asi64(R1)) goto L1719;
	asi64(R1) = alloc;
	asu64(R2) = a;
	asi64(R3) = offset;
	R2 += (i64)R3*4;
	qq_decimal_freesmall(asu64(R2), asi64(R1));
L1719:
L1715:
	asu64(R1) = c;
	goto L1707;
L1707:
	return asu64(R1);
}

static void qq_decimal_freesmall(u64 p, i64 length) {
    u64 R1, R2; 
	asi64(R1) = length;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static u64 qq_decimal_bn_init() {
    u64 R1; 
	u64 a;
	R1 = 0;
	asu64(R1) = qq_decimal_makebignum(asi64(R1));
	a = asu64(R1);
	asu64(R1) = a;
	goto L1721;
L1721:
	return asu64(R1);
}

static void qq_decimal_bn_setzero(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	if (!asu64(R1)) goto L1724;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L1726;
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_decimal_freesmall(asu64(R2), asi64(R1));
L1726:
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = a;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	asu64(R2) = a;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 0;
	asu64(R2) = a;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asu64(R2) = a;
	R3 = 26;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L1724:
	return;
}

static void qq_decimal_bn_move(u64 a, u64 b) {
    u64 R1, R2, R3; struct $B8 R1_B8; 
	asu64(R1) = a;
	qq_decimal_bn_setzero(asu64(R1));
	asu64(R1) = b;
	R2 = 8;
	(R1_B8) = *(struct $B8*)(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	*(struct $B8*)(((i64)R2+(i64)R3)) = (R1_B8);
	asu64(R1) = b;
	R2 = 8;
	R1 += (i64)R2;
	memset(R1, 0, 24);
	return;
}

static void qq_decimal_bn_dupl(u64 a, u64 b) {
    u64 R1, R2, R3, R4; struct $B32 R1_B32; 
	u64 c;
	i64 size;
	asu64(R1) = qq_decimal_bn_init();
	c = asu64(R1);
	asu64(R1) = b;
	(R1_B32) = *(struct $B32*)(R1);
	asu64(R2) = c;
	*(struct $B32*)(R2) = (R1_B32);
	asu64(R1) = c;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L1730;
	asu64(R1) = c;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	size = asi64(R2);
	asu64(R1) = qq_decimal_makesmallnum(asi64(R1));
	asu64(R2) = c;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = size;
	R2 = 4;
	asu64(R1) *= asu64(R2);
	asu64(R2) = b;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = c;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L1730:
	asu64(R1) = c;
	asu64(R2) = a;
	qq_decimal_bn_move(asu64(R2), asu64(R1));
	asu64(R1) = c;
	qq_decimal_obj_free_dec(asu64(R1));
	return;
}

static void qq_decimal_bn_setinf(u64 dest) {
    u64 R1, R2, R3; 
	asu64(R1) = dest;
	qq_decimal_bn_setzero(asu64(R1));
	R1 = 2;
	asu64(R2) = dest;
	R3 = 26;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	return;
}

static void qq_decimal_bn_setnan(u64 dest) {
    u64 R1, R2, R3; 
	asu64(R1) = dest;
	qq_decimal_bn_setzero(asu64(R1));
	R1 = 3;
	asu64(R2) = dest;
	R3 = 26;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	return;
}

static void qq_decimal_var_setnan(u64 dest) {
    u64 R1, R2, R3; 
	R1 = 259;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R1) = qq_decimal_makebignum(asi64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = dest;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_decimal_bn_setnan(asu64(R1));
	return;
}

static void qq_decimal_var_setinf(u64 dest) {
    u64 R1, R2, R3; 
	R1 = 259;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R1) = qq_decimal_makebignum(asi64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = dest;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_decimal_bn_setinf(asu64(R1));
	return;
}

static i64 qq_decimal_getbintype(u64 a, u64 b) {
    u64 R1, R2; 
	i64 atype;
	i64 btype;
	asu64(R1) = a;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	atype = asi64(R1);
	asu64(R1) = b;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	btype = asi64(R1);
	asi64(R1) = atype;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1738;
	asi64(R1) = btype;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1737;
L1738:
	R1 = 4;
	goto L1735;
L1737:
	asi64(R1) = atype;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1740;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1741;
	goto L1742;
L1740:
	asi64(R1) = btype;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1744;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1745;
	goto L1746;
L1744:
	R1 = 1;
	goto L1743;
L1745:
	R1 = 5;
	goto L1743;
L1746:
	R1 = 6;
L1743:
	goto L1739;
L1741:
	asi64(R1) = btype;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1748;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1749;
	goto L1750;
L1748:
	R1 = 7;
	goto L1747;
L1749:
	R1 = 2;
	goto L1747;
L1750:
	R1 = 9;
L1747:
	goto L1739;
L1742:
	asi64(R1) = btype;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1752;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1753;
	goto L1754;
L1752:
	R1 = 8;
	goto L1751;
L1753:
	R1 = 10;
	goto L1751;
L1754:
	R1 = 3;
L1751:
L1739:
	goto L1735;
L1735:
	return asi64(R1);
}

static void qq_decimal_bn_negto(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	asi64(R1) = qq_decimal_bn_iszero(asu64(R1));
	if (asi64(R1)) goto L1757;
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asi64(R1) = !asi64(R1);
	asu64(R2) = a;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L1757:
	return;
}

static void qq_decimal_bn_absto(u64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = a;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	return;
}

static i64 qq_decimal_bn_mul(u64 dest, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 neg;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_decimal_getbintype(asu64(R2), asu64(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1761;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1762;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1762;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1762;
	goto L1763;
L1761:
	goto L1760;
L1762:
	asu64(R1) = dest;
	qq_decimal_bn_setzero(asu64(R1));
	R1 = 1;
	goto L1759;
	goto L1760;
L1763:
	asu64(R1) = dest;
	qq_decimal_bn_setnan(asu64(R1));
	R1 = 0;
	goto L1759;
L1760:
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = b;
	R3 = 24;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	neg = asi64(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = dest;
	qq_decimal_bn_mulu(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = neg;
	if (!asi64(R1)) goto L1765;
	asu64(R1) = dest;
	qq_decimal_bn_negto(asu64(R1));
L1765:
	R1 = 1;
	goto L1759;
L1759:
	return asi64(R1);
}

static i64 qq_decimal_bn_mulp(u64 dest, u64 a, u64 b, i64 prec) {
    u64 R1, R2, R3; 
	i64 res;
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = dest;
	asi64(R1) = qq_decimal_bn_mul(asu64(R3), asu64(R2), asu64(R1));
	res = asi64(R1);
	asi64(R1) = res;
	if (!asi64(R1)) goto L1768;
	asi64(R1) = prec;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1770;
	asi64(R1) = qq_decimal_currprec;
	goto L1769;
L1770:
	asi64(R1) = prec;
L1769:
	asu64(R2) = dest;
	qq_decimal_bn_setprec(asu64(R2), asi64(R1));
L1768:
	asi64(R1) = res;
	goto L1766;
L1766:
	return asi64(R1);
}

static void qq_decimal_bn_mulu(u64 dest, u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	i64 uppera;
	i64 upperb;
	i64 upperc;
	i64 precc;
	i64 expona;
	i64 exponb;
	i64 ax;
	i64 bx;
	i64 cx;
	i64 i;
	i64 cx1;
	i64 nc2;
	i64 pd;
	i64 pr;
	i64 p;
	i64 carry;
	i64 x;
	u64 d;
	u64 c;
	i64 pdquot;
	i64 pdrem;
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	expona = asi64(R1);
	asu64(R1) = b;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	exponb = asi64(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	uppera = asi64(R1);
	asu64(R1) = b;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	upperb = asi64(R1);
	asi64(R1) = uppera;
	asi64(R2) = upperb;
	asi64(R1) += asi64(R2);
	R2 = 2;
	asi64(R1) += asi64(R2);
	precc = asi64(R1);
	asi64(R1) = precc;
	nc2 = asi64(R1);
	asi64(R1) = nc2;
	asu64(R1) = qq_decimal_makesmallnum(asi64(R1));
	c = asu64(R1);
	asi64(R1) = precc;
	R2 = 4;
	asu64(R1) *= asu64(R2);
	R2 = 0;
	asu64(R3) = c;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asi64(R1) = precc;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	cx = asi64(R1);
	asi64(R1) = upperb;
	bx = asi64(R1);
	asi64(R1) = bx;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1774;
L1772:
	R1 = 0;
	carry = asi64(R1);
	asi64(R1) = cx;
	cx1 = asi64(R1);
	asi64(R1) = uppera;
	ax = asi64(R1);
	asi64(R1) = ax;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1777;
L1775:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = ax;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asu64(R2) = b;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = bx;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) *= asi64(R2);
	asi64(R2) = carry;
	asi64(R1) += asi64(R2);
	p = asi64(R1);
	asi64(R1) = p;
	R2 = 1000000000;
	asi64(R1) /= asi64(R2);
	pd = asi64(R1);
	asi64(R1) = p;
	asi64(R2) = pd;
	R3 = 1000000000;
	asi64(R2) *= asi64(R3);
	asi64(R1) -= asi64(R2);
	pr = asi64(R1);
	asu64(R1) = c;
	asi64(R2) = cx1;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asi64(R2) = pr;
	asi64(R1) += asi64(R2);
	x = asi64(R1);
	asi64(R1) = x;
	R2 = 999999999;
	if (asi64(R1) <= asi64(R2)) goto L1779;
	asi64(R1) = pd;
	R2 = 1;
	asi64(R1) += asi64(R2);
	carry = asi64(R1);
	asi64(R1) = x;
	R2 = 1000000000;
	asi64(R1) -= asi64(R2);
	asu64(R2) = c;
	R3 = (u64)&cx1;
	asi64(R4) = *toi64p(R3); *(toi64p(R3)) -= 1; asi64(R3) = asi64(R4);
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	goto L1778;
L1779:
	asi64(R1) = pd;
	carry = asi64(R1);
	asi64(R1) = x;
	asu64(R2) = c;
	R3 = (u64)&cx1;
	asi64(R4) = *toi64p(R3); *(toi64p(R3)) -= 1; asi64(R3) = asi64(R4);
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L1778:
	ax += -1; if (ax >= 0) goto L1775;
L1777:
	asi64(R1) = carry;
	asu64(R2) = c;
	asi64(R3) = cx1;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&cx;
	(*toi64p(R1)) -=1;
	bx += -1; if (bx >= 0) goto L1772;
L1774:
	R1 = 0;
	asi64(R2) = nc2;
	asi64(R3) = precc;
	asu64(R4) = c;
	asu64(R5) = dest;
	asu64(R1) = qq_decimal_smalltobig(asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = expona;
	asi64(R2) = exponb;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R2) = qq_decimal_stblz;
	asi64(R1) -= asi64(R2);
	asu64(R2) = dest;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static i64 qq_decimal_smallmulto(u64 p, u64 q, i64 plen, i64 m) {
    u64 R1, R2, R3; 
	u64 pp;
	u64 qq;
	i64 carry;
	i64 d;
	i64 av_1;
	i64 av_2;
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1782;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1783;
	goto L1784;
L1782:
	R1 = 0;
	asu64(R2) = p;
	*toi32p(R2) = asi32(R1);
	R1 = 1;
	goto L1780;
	goto L1781;
L1783:
	asi64(R1) = plen;
	R2 = 4;
	asu64(R1) *= asu64(R2);
	asu64(R2) = q;
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = plen;
	goto L1780;
	goto L1781;
L1784:
L1781:
	asu64(R1) = p;
	asi64(R2) = plen;
	R1 += (i64)R2*4;
	R2 = 1;
	R1 -= (i64)R2*4;
	pp = asu64(R1);
	asu64(R1) = q;
	asi64(R2) = plen;
	R1 += (i64)R2*4;
	R2 = 1;
	R1 -= (i64)R2*4;
	qq = asu64(R1);
	R1 = 0;
	carry = asi64(R1);
	asi64(R1) = plen;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1787;
L1785:
	asu64(R1) = qq;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	asi64(R2) = m;
	asi64(R1) *= asi64(R2);
	asi64(R2) = carry;
	asi64(R1) += asi64(R2);
	d = asi64(R1);
	asi64(R1) = d;
	R2 = 1000000000;
	asi64(R1) %= asi64(R2);
	asu64(R2) = pp;
	*toi32p(R2) = asi32(R1);
	asi64(R1) = d;
	R2 = 1000000000;
	asi64(R1) /= asi64(R2);
	carry = asi64(R1);
	R1 = (u64)&qq;
	(*tou64p(R1)) -=4;
	R1 = (u64)&pp;
	(*tou64p(R1)) -=4;
	if (--asi64(av_1)) goto L1785;
L1787:
	asi64(R1) = carry;
	if (!asi64(R1)) goto L1789;
	asu64(R1) = p;
	asi64(R2) = plen;
	R1 += (i64)R2*4;
	pp = asu64(R1);
	asi64(R1) = plen;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1792;
L1790:
	asu64(R1) = pp;
	R2 = 1;
	R1 -= (i64)R2*4;
	asi32(R1) = *toi32p(R1);
	asu64(R2) = pp;
	*toi32p(R2) = asi32(R1);
	R1 = (u64)&pp;
	(*tou64p(R1)) -=4;
	if (--asi64(av_2)) goto L1790;
L1792:
	asi64(R1) = carry;
	asu64(R2) = pp;
	*toi32p(R2) = asi32(R1);
	R1 = (u64)&plen;
	(*toi64p(R1)) += 1;
L1789:
	asi64(R1) = plen;
	goto L1780;
L1780:
	return asi64(R1);
}

static i64 qq_decimal_bn_div(u64 dest, u64 a, u64 b, i64 prec) {
    u64 R1, R2, R3, R4; 
	i64 neg;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_decimal_getbintype(asu64(R2), asu64(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1795;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1796;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1797;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1797;
	goto L1798;
L1795:
	goto L1794;
L1796:
	asu64(R1) = dest;
	qq_decimal_bn_setzero(asu64(R1));
	R1 = 1;
	goto L1793;
	goto L1794;
L1797:
	asu64(R1) = dest;
	qq_decimal_bn_setinf(asu64(R1));
	R1 = 0;
	goto L1793;
	goto L1794;
L1798:
	asu64(R1) = dest;
	qq_decimal_bn_setnan(asu64(R1));
	R1 = 0;
	goto L1793;
L1794:
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = b;
	R3 = 24;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	neg = asi64(R1);
	asi64(R1) = prec;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = dest;
	qq_decimal_bn_fdivu(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = neg;
	if (!asi64(R1)) goto L1800;
	asu64(R1) = dest;
	qq_decimal_bn_negto(asu64(R1));
L1800:
	R1 = 1;
	goto L1793;
L1793:
	return asi64(R1);
}

static i64 qq_decimal_bn_idiv(u64 dest, u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	i64 neg;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_decimal_getbintype(asu64(R2), asu64(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1803;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1804;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1805;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1805;
	goto L1806;
L1803:
	goto L1802;
L1804:
	asu64(R1) = dest;
	qq_decimal_bn_setzero(asu64(R1));
	R1 = 1;
	goto L1801;
	goto L1802;
L1805:
	asu64(R1) = dest;
	qq_decimal_bn_setinf(asu64(R1));
	R1 = 0;
	goto L1801;
	goto L1802;
L1806:
	asu64(R1) = dest;
	qq_decimal_bn_setnan(asu64(R1));
	R1 = 0;
	goto L1801;
L1802:
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = b;
	R3 = 24;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	neg = asi64(R1);
	R1 = 0;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = dest;
	qq_decimal_bn_idivu(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = neg;
	if (!asi64(R1)) goto L1808;
	asu64(R1) = dest;
	qq_decimal_bn_negto(asu64(R1));
L1808:
	R1 = 1;
	goto L1801;
L1801:
	return asi64(R1);
}

static i64 qq_decimal_bn_idivrem(u64 dest, u64 rm, u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	i64 nega;
	i64 negb;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_decimal_getbintype(asu64(R2), asu64(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1811;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1812;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1813;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1813;
	goto L1814;
L1811:
	goto L1810;
L1812:
	asu64(R1) = dest;
	qq_decimal_bn_setzero(asu64(R1));
	asu64(R1) = rm;
	qq_decimal_bn_setzero(asu64(R1));
	R1 = 1;
	goto L1809;
	goto L1810;
L1813:
	asu64(R1) = dest;
	qq_decimal_bn_setinf(asu64(R1));
	asu64(R1) = rm;
	qq_decimal_bn_setzero(asu64(R1));
	R1 = 0;
	goto L1809;
	goto L1810;
L1814:
	asu64(R1) = dest;
	qq_decimal_bn_setnan(asu64(R1));
	R1 = 0;
	goto L1809;
L1810:
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	nega = asi64(R1);
	asu64(R1) = b;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	negb = asi64(R1);
	asu64(R1) = rm;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = dest;
	qq_decimal_bn_idivu(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = nega;
	asi64(R2) = negb;
	if (asi64(R1) == asi64(R2)) goto L1816;
	asu64(R1) = dest;
	qq_decimal_bn_negto(asu64(R1));
L1816:
	asi64(R1) = nega;
	if (!asi64(R1)) goto L1818;
	asu64(R1) = rm;
	qq_decimal_bn_negto(asu64(R1));
L1818:
	R1 = 1;
	goto L1809;
L1809:
	return asi64(R1);
}

static i64 qq_decimal_bn_irem(u64 dest, u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	u64 rm;
	u64 d;
	i64 nega;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_decimal_getbintype(asu64(R2), asu64(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1821;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1822;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1823;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1823;
	goto L1824;
L1821:
	goto L1820;
L1822:
	asu64(R1) = b;
	asu64(R2) = dest;
	qq_decimal_bn_dupl(asu64(R2), asu64(R1));
	R1 = 1;
	goto L1819;
	goto L1820;
L1823:
	asu64(R1) = dest;
	qq_decimal_bn_setinf(asu64(R1));
	asu64(R1) = dest;
	qq_decimal_bn_setzero(asu64(R1));
	R1 = 0;
	goto L1819;
	goto L1820;
L1824:
	asu64(R1) = dest;
	qq_decimal_bn_setnan(asu64(R1));
	R1 = 0;
	goto L1819;
L1820:
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	nega = asi64(R1);
	asu64(R1) = qq_decimal_bn_init();
	d = asu64(R1);
	asu64(R1) = dest;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = d;
	qq_decimal_bn_idivu(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = nega;
	if (!asi64(R1)) goto L1826;
	asu64(R1) = dest;
	qq_decimal_bn_negto(asu64(R1));
L1826:
	asu64(R1) = d;
	qq_decimal_obj_free_dec(asu64(R1));
	R1 = 1;
	goto L1819;
L1819:
	return asi64(R1);
}

static void qq_decimal_bn_idivu(u64 dest, u64 a, u64 b, u64 rm) {
    u64 R1, R2, R3, R4, R5; 
	u64 c;
	u64 x;
	u64 e;
	i64 expona;
	i64 exponb;
	i64 badjust;
	i64 exponc;
	i64 na;
	i64 nb;
	i64 nc;
	i64 nx;
	i64 ne;
	i64 nx2;
	i64 ne2;
	i64 cx;
	i64 nupper;
	i64 uppera;
	i64 upperb;
	i64 upperc;
	i64 n;
	i64 k;
	i64 nexta;
	i64 xx;
	i64 y;
	u64 pa;
	u64 pb;
	u64 d;
	i64 i;
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	na = asi64(R1);
	asu64(R1) = b;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	nb = asi64(R1);
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	expona = asi64(R1);
	asu64(R1) = b;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	exponb = asi64(R1);
	asi64(R1) = exponb;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R2) = nb;
	asi64(R1) -= asi64(R2);
	badjust = asi64(R1);
	asi64(R1) = na;
	asi64(R2) = expona;
	R3 = 1;
	asi64(R2) += asi64(R3);
	if (asi64(R1) > asi64(R2)) goto L1830;
	asi64(R1) = nb;
	asi64(R2) = exponb;
	R3 = 1;
	asi64(R2) += asi64(R3);
	if (asi64(R1) <= asi64(R2)) goto L1829;
L1830:
	R1 = tou64("");
	R2 = tou64("idivu:a or b not int");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1829:
	asi64(R1) = expona;
	R2 = 1;
	asi64(R1) += asi64(R2);
	nc = asi64(R1);
	asi64(R1) = expona;
	asi64(R2) = exponb;
	if (asi64(R1) >= asi64(R2)) goto L1832;
	asu64(R1) = dest;
	qq_decimal_bn_setzero(asu64(R1));
	asu64(R1) = rm;
	if (!asu64(R1)) goto L1834;
	asu64(R1) = a;
	asu64(R2) = rm;
	qq_decimal_bn_dupl(asu64(R2), asu64(R1));
L1834:
	goto L1827;
L1832:
	asi64(R1) = na;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	uppera = asi64(R1);
	asi64(R1) = nb;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	upperb = asi64(R1);
	asi64(R1) = nc;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	upperc = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pb = asu64(R1);
	asi64(R1) = nb;
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = R1;
	nx2 = asi64(R2);
	asu64(R1) = qq_decimal_makesmallnum(asi64(R1));
	x = asu64(R1);
	asi64(R1) = n;
	nx = asi64(R1);
	asi64(R1) = nc;
	asi64(R2) = badjust;
	asi64(R1) -= asi64(R2);
	nupper = asi64(R1);
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = upperb;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1837;
L1835:
	asi64(R1) = i;
	asi64(R2) = uppera;
	if (asi64(R1) > asi64(R2)) goto L1839;
	asu64(R1) = pa;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	asu64(R2) = x;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	goto L1838;
L1839:
	R1 = 0;
	asu64(R2) = x;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L1838:
	i += 1; if (i <= upperb) goto L1835;
L1837:
	asi64(R1) = nc;
	asu64(R1) = qq_decimal_makesmallnum(asi64(R1));
	c = asu64(R1);
	R1 = 0;
	cx = asi64(R1);
L1840:
	asi64(R1) = nb;
	R2 = (u64)&nx;
	asu64(R3) = pb;
	asu64(R4) = x;
	asi64(R1) = qq_decimal_smalldiv(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	k = asi64(R1);
	asi64(R1) = k;
	asu64(R2) = c;
	R3 = (u64)&cx;
	asi64(R4) = *toi64p(R3); *(toi64p(R3)) += 1; asi64(R3) = asi64(R4);
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = n;
	asi64(R2) = nupper;
	if (asi64(R1) < asi64(R2)) goto L1843;
	goto L1841;
L1843:
	asi64(R1) = n;
	asi64(R2) = uppera;
	if (asi64(R1) <= asi64(R2)) goto L1845;
	R1 = 0;
	goto L1844;
L1845:
	asu64(R1) = pa;
	asi64(R2) = n;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
L1844:
	nexta = asi64(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = nx;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1847;
	asu64(R1) = x;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1847;
	asi64(R1) = nexta;
	asu64(R2) = x;
	*toi32p(R2) = asi32(R1);
	goto L1846;
L1847:
	asi64(R1) = nexta;
	asu64(R2) = x;
	asi64(R3) = nx;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&nx;
	(*toi64p(R1)) += 1;
L1846:
	goto L1840;
L1841:
	asu64(R1) = rm;
	if (!asu64(R1)) goto L1849;
	asi64(R1) = exponb;
	asi64(R2) = nb;
	if (asi64(R1) >= asi64(R2)) goto L1849;
	R1 = 0;
	asi64(R2) = nx2;
	asi64(R3) = nx;
	asu64(R4) = x;
	asu64(R5) = rm;
	asu64(R1) = qq_decimal_smalltobig(asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L1848;
L1849:
	asi64(R1) = nx2;
	asu64(R2) = x;
	qq_decimal_freesmall(asu64(R2), asi64(R1));
L1848:
	asi64(R1) = cx;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1851;
	asu64(R1) = c;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1851;
	asi64(R1) = nc;
	asu64(R2) = c;
	qq_decimal_freesmall(asu64(R2), asi64(R1));
	asu64(R1) = dest;
	qq_decimal_bn_setzero(asu64(R1));
	asu64(R1) = rm;
	if (!asu64(R1)) goto L1853;
	asu64(R1) = a;
	asu64(R2) = rm;
	qq_decimal_bn_dupl(asu64(R2), asu64(R1));
L1853:
	goto L1827;
L1851:
	asu64(R1) = c;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1855;
	asi64(R1) = cx;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L1855;
	R1 = -1;
	asi64(R2) = nc;
	asi64(R3) = cx;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R4) = c;
	R5 = 1;
	R4 += (i64)R5*4;
	asu64(R5) = dest;
	asu64(R1) = qq_decimal_smalltobig(asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L1854;
L1855:
	R1 = 0;
	asi64(R2) = nc;
	asi64(R3) = cx;
	asu64(R4) = c;
	asu64(R5) = dest;
	asu64(R1) = qq_decimal_smalltobig(asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
L1854:
	asu64(R1) = rm;
	if (!asu64(R1)) goto L1857;
	asi64(R1) = exponb;
	asi64(R2) = nb;
	if (asi64(R1) < asi64(R2)) goto L1857;
	asu64(R1) = qq_decimal_bn_init();
	d = asu64(R1);
	asu64(R1) = dest;
	asu64(R2) = b;
	asu64(R3) = d;
	qq_decimal_bn_mulu(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = d;
	asu64(R2) = a;
	asu64(R3) = rm;
	qq_decimal_bn_subu(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = d;
	qq_decimal_obj_free_dec(asu64(R1));
L1857:
L1827:
	return;
}

static void qq_decimal_bn_fdivu(u64 dest, u64 a, u64 b, i64 precision) {
    u64 R1, R2, R3, R4, R5; 
	u64 c;
	u64 x;
	u64 e;
	i64 expona;
	i64 exponb;
	i64 badjust;
	i64 exponc;
	i64 na;
	i64 nb;
	i64 nc;
	i64 nx;
	i64 ne;
	i64 nx2;
	i64 ne2;
	i64 cx;
	i64 nupper;
	i64 nc2;
	i64 uppera;
	i64 upperb;
	i64 upperc;
	i64 n;
	i64 k;
	i64 nexta;
	i64 xx;
	i64 y;
	u64 pa;
	u64 pb;
	i64 i;
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	na = asi64(R1);
	asu64(R1) = b;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	nb = asi64(R1);
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	expona = asi64(R1);
	asu64(R1) = b;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	exponb = asi64(R1);
	asi64(R1) = precision;
	if (!asi64(R1)) goto L1860;
	asi64(R1) = precision;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = 9;
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	precision = asi64(R1);
	goto L1859;
L1860:
	asi64(R1) = qq_decimal_currprec;
	precision = asi64(R1);
L1859:
	asi64(R1) = precision;
	nc = asi64(R1);
	asi64(R1) = na;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	uppera = asi64(R1);
	asi64(R1) = nb;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	upperb = asi64(R1);
	asi64(R1) = nc;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	upperc = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pb = asu64(R1);
	asi64(R1) = nb;
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = R1;
	nx2 = asi64(R2);
	asu64(R1) = qq_decimal_makesmallnum(asi64(R1));
	x = asu64(R1);
	asi64(R1) = n;
	nx = asi64(R1);
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = upperb;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1863;
L1861:
	asi64(R1) = i;
	asi64(R2) = uppera;
	if (asi64(R1) > asi64(R2)) goto L1865;
	asu64(R1) = pa;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	asu64(R2) = x;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	goto L1864;
L1865:
	R1 = 0;
	asu64(R2) = x;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L1864:
	i += 1; if (i <= upperb) goto L1861;
L1863:
	asi64(R1) = nc;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = R1;
	nc2 = asi64(R2);
	asu64(R1) = qq_decimal_makesmallnum(asi64(R1));
	c = asu64(R1);
	R1 = 0;
	cx = asi64(R1);
L1866:
	asi64(R1) = nb;
	R2 = (u64)&nx;
	asu64(R3) = pb;
	asu64(R4) = x;
	asi64(R1) = qq_decimal_smalldiv(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	k = asi64(R1);
	asi64(R1) = k;
	asu64(R2) = c;
	R3 = (u64)&cx;
	asi64(R4) = *toi64p(R3); *(toi64p(R3)) += 1; asi64(R3) = asi64(R4);
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = cx;
	asi64(R2) = nc;
	if (asi64(R1) <= asi64(R2)) goto L1869;
	goto L1867;
L1869:
	asi64(R1) = n;
	asi64(R2) = uppera;
	if (asi64(R1) <= asi64(R2)) goto L1871;
	R1 = 0;
	goto L1870;
L1871:
	asu64(R1) = pa;
	asi64(R2) = n;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
L1870:
	nexta = asi64(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = nx;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1873;
	asu64(R1) = x;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1873;
	asi64(R1) = nexta;
	asu64(R2) = x;
	*toi32p(R2) = asi32(R1);
	goto L1872;
L1873:
	asi64(R1) = nexta;
	asu64(R2) = x;
	asi64(R3) = nx;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&nx;
	(*toi64p(R1)) += 1;
L1872:
	goto L1866;
L1867:
	asi64(R1) = nx2;
	asu64(R2) = x;
	qq_decimal_freesmall(asu64(R2), asi64(R1));
	asi64(R1) = cx;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1875;
	asu64(R1) = c;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1875;
	asi64(R1) = nc2;
	asu64(R2) = c;
	qq_decimal_freesmall(asu64(R2), asi64(R1));
	asu64(R1) = dest;
	qq_decimal_bn_setzero(asu64(R1));
	goto L1858;
L1875:
	asu64(R1) = c;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1877;
	asi64(R1) = cx;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L1877;
	R1 = -1;
	asi64(R2) = nc2;
	asi64(R3) = cx;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R4) = c;
	R5 = 1;
	R4 += (i64)R5*4;
	asu64(R5) = dest;
	asu64(R1) = qq_decimal_smalltobig(asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = expona;
	asi64(R2) = exponb;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = dest;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L1876;
L1877:
	R1 = 0;
	asi64(R2) = nc2;
	asi64(R3) = cx;
	asu64(R4) = c;
	asu64(R5) = dest;
	asu64(R1) = qq_decimal_smalltobig(asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = expona;
	asi64(R2) = exponb;
	asi64(R1) -= asi64(R2);
	asu64(R2) = dest;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L1876:
L1858:
	return;
}

static i64 qq_decimal_smalldiv(u64 x, u64 b, u64 xlen, i64 nb) {
    u64 R1, R2, R3, R4; 
	i64 k;
	i64 count;
	i64 xx;
	i64 y;
	i32 xi;
	i32 bi;
	u64 e;
	i64 esize;
	i64 ne;
	i64 nx;
	i64 av_1;
	i64 i;
	asu64(R1) = xlen;
	asi64(R1) = *toi64p(R1);
	nx = asi64(R1);
	R1 = 0;
	k = asi64(R1);
	R1 = 0;
	count = asi64(R1);
	asi64(R1) = nb;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = R1;
	esize = asi64(R2);
	asu64(R1) = qq_decimal_makesmallnum(asi64(R1));
	e = asu64(R1);
L1879:
	asi64(R1) = nx;
	asi64(R2) = nb;
	if (asi64(R1) >= asi64(R2)) goto L1882;
	goto L1880;
	goto L1881;
L1882:
	asi64(R1) = nx;
	asi64(R2) = nb;
	if (asi64(R1) <= asi64(R2)) goto L1883;
	asu64(R1) = x;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	R2 = 1000000000;
	asi64(R1) *= asi64(R2);
	asu64(R2) = x;
	R3 = 1;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	xx = asi64(R1);
	asi64(R1) = xx;
	asu64(R2) = b;
	asi32(R2) = *toi32p(R2);
	R2 = toi64(toi32(R2));
	R3 = 1;
	asi64(R2) += asi64(R3);
	asi64(R1) /= asi64(R2);
	y = asi64(R1);
	goto L1881;
L1883:
	asu64(R1) = x;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	asu64(R2) = b;
	asi32(R2) = *toi32p(R2);
	R2 = toi64(toi32(R2));
	R3 = 1;
	asi64(R2) += asi64(R3);
	if (asi64(R1) < asi64(R2)) goto L1885;
	asu64(R1) = x;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	asu64(R2) = b;
	asi32(R2) = *toi32p(R2);
	R2 = toi64(toi32(R2));
	R3 = 1;
	asi64(R2) += asi64(R3);
	asi64(R1) /= asi64(R2);
	y = asi64(R1);
	goto L1884;
L1885:
	R1 = 1;
	y = asi64(R1);
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = nb;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1888;
L1886:
	asu64(R1) = x;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	xi = asi32(R1);
	asu64(R1) = b;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	bi = asi32(R1);
	asi32(R1) = xi;
	R1 = toi64(toi32(R1));
	asi32(R2) = bi;
	R2 = toi64(toi32(R2));
	if (asi64(R1) >= asi64(R2)) goto L1890;
	R1 = 0;
	y = asi64(R1);
	goto L1880;
	goto L1889;
L1890:
	asi32(R1) = xi;
	R1 = toi64(toi32(R1));
	asi32(R2) = bi;
	R2 = toi64(toi32(R2));
	if (asi64(R1) <= asi64(R2)) goto L1891;
	goto L1888;
L1891:
L1889:
	i += 1; if (i <= av_1) goto L1886;
L1888:
L1884:
L1881:
	asi64(R1) = y;
	R2 = (u64)&k;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = y;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L1893;
	asi64(R1) = y;
	asi64(R2) = nb;
	asu64(R3) = b;
	asu64(R4) = e;
	asi64(R1) = qq_decimal_smallmulto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	ne = asi64(R1);
	asi64(R1) = ne;
	asi64(R2) = nx;
	asu64(R3) = e;
	asu64(R4) = x;
	asi64(R1) = qq_decimal_smallsubto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	nx = asi64(R1);
	goto L1892;
L1893:
	asi64(R1) = y;
	if (!asi64(R1)) goto L1894;
	asi64(R1) = nb;
	asi64(R2) = nx;
	asu64(R3) = b;
	asu64(R4) = x;
	asi64(R1) = qq_decimal_smallsubto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	nx = asi64(R1);
	goto L1892;
L1894:
	R1 = tou64("");
	R2 = tou64("smalldiv:Y=0");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1892:
	goto L1879;
L1880:
	asi64(R1) = esize;
	asu64(R2) = e;
	qq_decimal_freesmall(asu64(R2), asi64(R1));
	asi64(R1) = nx;
	asu64(R2) = xlen;
	*toi64p(R2) = asi64(R1);
	asi64(R1) = k;
	goto L1878;
L1878:
	return asi64(R1);
}

static i64 qq_decimal_smallsubto(u64 p, u64 q, i64 plen, i64 qlen) {
    u64 R1, R2, R3; 
	u64 pp;
	u64 qq;
	i64 carry;
	i64 diff;
	i64 z;
	i64 av_1;
	i64 av_2;
	asu64(R1) = p;
	asi64(R2) = plen;
	R1 += (i64)R2*4;
	R2 = 1;
	R1 -= (i64)R2*4;
	pp = asu64(R1);
	asu64(R1) = q;
	asi64(R2) = qlen;
	R1 += (i64)R2*4;
	R2 = 1;
	R1 -= (i64)R2*4;
	qq = asu64(R1);
	R1 = 0;
	carry = asi64(R1);
	R1 = 0;
	z = asi64(R1);
	asi64(R1) = plen;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1898;
L1896:
	asu64(R1) = qq;
	asu64(R2) = q;
	if (asu64(R1) < asu64(R2)) goto L1900;
	asu64(R1) = pp;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	asu64(R2) = qq;
	asi32(R2) = *toi32p(R2);
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	asi64(R2) = carry;
	asi64(R1) -= asi64(R2);
	diff = asi64(R1);
	R1 = (u64)&qq;
	(*tou64p(R1)) -=4;
	goto L1899;
L1900:
	asu64(R1) = pp;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	asi64(R2) = carry;
	asi64(R1) -= asi64(R2);
	diff = asi64(R1);
L1899:
	asi64(R1) = diff;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L1902;
	R1 = 1;
	carry = asi64(R1);
	asi64(R1) = diff;
	R2 = 1000000000;
	asi64(R1) += asi64(R2);
	asu64(R2) = pp;
	*toi32p(R2) = asi32(R1);
	goto L1901;
L1902:
	asi64(R1) = diff;
	asu64(R2) = pp;
	*toi32p(R2) = asi32(R1);
	R1 = 0;
	carry = asi64(R1);
L1901:
	asu64(R1) = pp;
	asi32(R1) = *toi32p(R1);
	if (!asi32(R1)) goto L1904;
	R1 = 0;
	z = asi64(R1);
	goto L1903;
L1904:
	R1 = (u64)&z;
	(*toi64p(R1)) += 1;
L1903:
	R1 = (u64)&pp;
	(*tou64p(R1)) -=4;
	if (--asi64(av_1)) goto L1896;
L1898:
	asi64(R1) = carry;
	if (!asi64(R1)) goto L1906;
	R1 = tou64("");
	R2 = tou64("SSUBTO/CARRY?");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1906:
	asi64(R1) = z;
	asi64(R2) = plen;
	if (asi64(R1) != asi64(R2)) goto L1908;
	R1 = (u64)&z;
	(*toi64p(R1)) -=1;
L1908:
	asi64(R1) = z;
	if (!asi64(R1)) goto L1910;
	asi64(R1) = z;
	R2 = (u64)&plen;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = p;
	pp = asu64(R1);
	asu64(R1) = p;
	asi64(R2) = z;
	R1 += (i64)R2*4;
	qq = asu64(R1);
	asi64(R1) = plen;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1913;
L1911:
	R1 = (u64)&qq;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 4; asu64(R1) = asu64(R2);
	asi32(R1) = *toi32p(R1);
	R2 = (u64)&pp;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 4; asu64(R2) = asu64(R3);
	*toi32p(R2) = asi32(R1);
	if (--asi64(av_2)) goto L1911;
L1913:
L1910:
	asi64(R1) = plen;
	goto L1895;
L1895:
	return asi64(R1);
}

static i64 qq_decimal_bn_getprec(u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 9;
	asi64(R1) *= asi64(R2);
	goto L1914;
L1914:
	return asi64(R1);
}

static void qq_decimal_bn_setprec(u64 a, i64 prec) {
    u64 R1, R2, R3; 
	i64 oldlength;
	i64 newlength;
	u64 c;
	i64 av_1;
	i64 i;
	asu64(R1) = a;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1917;
	goto L1915;
L1917:
	asi64(R1) = prec;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1920;
	asi64(R1) = prec;
	R2 = 10000000;
	if (asi64(R1) <= asi64(R2)) goto L1919;
L1920:
	goto L1915;
L1919:
	asi64(R1) = prec;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = 9;
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 9;
	asi64(R1) *= asi64(R2);
	prec = asi64(R1);
	asi64(R1) = prec;
	R2 = 9;
	asi64(R1) /= asi64(R2);
	newlength = asi64(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	oldlength = asi64(R1);
	asi64(R1) = oldlength;
	asi64(R2) = newlength;
	if (asi64(R1) > asi64(R2)) goto L1922;
	goto L1915;
L1922:
	asi64(R1) = newlength;
	asu64(R1) = qq_decimal_makebignum(asi64(R1));
	c = asu64(R1);
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = c;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = c;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = newlength;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1925;
L1923:
	asi64(R1) = i;
	asi64(R2) = oldlength;
	if (asi64(R1) >= asi64(R2)) goto L1927;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	asu64(R2) = c;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	goto L1926;
L1927:
	R1 = 0;
	asu64(R2) = c;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L1926:
	i += 1; if (i <= av_1) goto L1923;
L1925:
	asu64(R1) = c;
	asu64(R2) = a;
	qq_decimal_bn_move(asu64(R2), asu64(R1));
	asu64(R1) = c;
	qq_decimal_obj_free_dec(asu64(R1));
L1915:
	return;
}

static i64 qq_decimal_bn_getglobalprec() {
    u64 R1, R2; 
	asi64(R1) = qq_decimal_currprec;
	R2 = 9;
	asi64(R1) *= asi64(R2);
	goto L1928;
L1928:
	return asi64(R1);
}

static void qq_decimal_bn_setglobalprec(i64 prec) {
    u64 R1, R2; 
	asi64(R1) = prec;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = 9;
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	qq_decimal_currprec = asi64(R1);
	return;
}

static u64 qq_decimal_bn_makefloat(r64 x) {
    u64 R1, R2; 
	u64 a;
	struct $B24 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64(".15g");
	asr64(R2) = x;
	msysc_m$print_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = (u64)&str;
	asu64(R1) = qq_decimal_bn_makestr(asu64(R2), asi64(R1));
	goto L1930;
L1930:
	return asu64(R1);
}

static u64 qq_decimal_dectemp(u64 a) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	R1 = 259;
	R2 = (u64)&qq_decimal_vtemp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1933;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1934;
	goto L1935;
L1933:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_decimal_bn_makeint(asi64(R1));
	R2 = (u64)&qq_decimal_vtemp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1932;
L1934:
	asu64(R1) = a;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_decimal_bn_makefloat(asr64(R1));
	R2 = (u64)&qq_decimal_vtemp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1932;
L1935:
	R1 = tou64("");
	R2 = tou64("dectemp");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L1932:
	(R1_B3) = qq_decimal_vtemp;
	asu64(R2) = a;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = a;
	goto L1931;
L1931:
	return asu64(R1);
}

static void qq_decimal_freedectemp() {
    u64 R1, R2; 
	R1 = (u64)&qq_decimal_vtemp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_decimal_obj_free_dec(asu64(R1));
	return;
}

static void qq_decimal_bn_ipower(u64 d, u64 a, i64 n) {
    u64 R1, R2, R3; 
	u64 e;
	u64 f;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L1939;
	asu64(R1) = d;
	qq_decimal_bn_setzero(asu64(R1));
	goto L1938;
L1939:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1940;
	R1 = 1;
	asu64(R1) = qq_decimal_bn_makeint(asi64(R1));
	asu64(R2) = d;
	qq_decimal_bn_move(asu64(R2), asu64(R1));
	goto L1938;
L1940:
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1941;
	asu64(R1) = a;
	asu64(R2) = d;
	qq_decimal_bn_dupl(asu64(R2), asu64(R1));
	goto L1938;
L1941:
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1942;
	asu64(R1) = qq_decimal_bn_init();
	e = asu64(R1);
	asu64(R1) = a;
	asu64(R2) = a;
	asu64(R3) = e;
	qq_decimal_bn_mulu(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = 2;
	asi64(R1) /= asi64(R2);
	asu64(R2) = e;
	asu64(R3) = d;
	qq_decimal_bn_ipower(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = e;
	qq_decimal_obj_free_dec(asu64(R1));
	goto L1938;
L1942:
	asu64(R1) = qq_decimal_bn_init();
	e = asu64(R1);
	asu64(R1) = qq_decimal_bn_init();
	f = asu64(R1);
	asu64(R1) = a;
	asu64(R2) = a;
	asu64(R3) = e;
	qq_decimal_bn_mulu(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = 2;
	asi64(R1) /= asi64(R2);
	asu64(R2) = e;
	asu64(R3) = f;
	qq_decimal_bn_ipower(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = f;
	asu64(R2) = a;
	asu64(R3) = d;
	qq_decimal_bn_mulu(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = e;
	qq_decimal_obj_free_dec(asu64(R1));
	asu64(R1) = f;
	qq_decimal_obj_free_dec(asu64(R1));
L1938:
	return;
}

static void qq_decimal_var_power_dec(u64 a, i64 n) {
    u64 R1, R2, R3; 
	u64 dest;
	asu64(R1) = qq_decimal_bn_init();
	dest = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	qq_decimal_bn_ipower(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = dest;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static i64 qq_decimal_var_convert_dec_int(u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = qq_decimal_bn_toint(asu64(R1));
	goto L1944;
L1944:
	return asi64(R1);
}

static i64 qq_decimal_bn_toint(u64 a) {
    u64 R1, R2, R3; 
	i64 x;
	i64 av_1;
	i64 av_2;
	i64 i;
	asu64(R1) = a;
	asi64(R1) = qq_decimal_bn_isint(asu64(R1));
	if (asi64(R1)) goto L1947;
	R1 = tou64("");
	R2 = tou64("dec-float->int not ready");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	R1 = 0;
	goto L1945;
L1947:
	asu64(R1) = a;
	asi64(R1) = qq_decimal_bn_iszero(asu64(R1));
	if (!asi64(R1)) goto L1949;
	R1 = 0;
	goto L1945;
L1949:
	R1 = 0;
	x = asi64(R1);
	R1 = 0;
	i = asi64(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1952;
L1950:
	asi64(R1) = x;
	R2 = 1000000000;
	asi64(R1) *= asi64(R2);
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	x = asi64(R1);
	i += 1; if (i <= av_1) goto L1950;
L1952:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	i = asi64(R1);
	asu64(R1) = a;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	av_2 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_2;
	if (asi64(R1) > asi64(R2)) goto L1955;
L1953:
	R1 = 1000000000;
	R2 = (u64)&x;
	*toi64p(R2) *= asi64(R1);
	i += 1; if (i <= av_2) goto L1953;
L1955:
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L1957;
	asi64(R1) = x;
	asi64(R1) = -asi64(R1);
	goto L1956;
L1957:
	asi64(R1) = x;
L1956:
	goto L1945;
L1945:
	return asi64(R1);
}

static void qq_dicts_var_make_dict(u64 a, u64 dest, i64 n) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 p;
	u64 b;
	struct $B3 v;
	i64 av_1;
	asi64(R1) = n;
	asu64(R1) = qq_dicts_obj_new_dict(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	R1 = 262;
	R2 = (u64)&v;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	R2 = (u64)&v;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1961;
L1959:
	asu64(R1) = a;
	R2 = 1;
	R1 += (i64)R2*16;
	asu64(R2) = a;
	R3 = (u64)&v;
	qq_dicts_adddictitem(asu64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	R2 = (u64)&a;
	*tou64p(R2) += asu64(R1)*16;
	if (--asi64(av_1)) goto L1959;
L1961:
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 28;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	(R1_B3) = v;
	asu64(R2) = dest;
	*(struct $B3*)(R2) = (R1_B3);
	return;
}

static u64 qq_dicts_obj_new_dict(i64 n) {
    u64 R1, R2, R3; 
	u64 p;
	i64 m;
	R1 = 16;
	asi64(R2) = n;
	R3 = 2;
	asi64(R2) *= asi64(R3);
	asi64(R2) = qq_lib_nextpoweroftwo(asi64(R2));
	asi64(R1) = Max(asi64(R1), asi64(R2));
	m = asi64(R1);
	R1 = 0;
	R2 = 1;
	asi64(R3) = m;
	asu64(R1) = qq_lists_obj_newlist(asi64(R3), asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L1962;
L1962:
	return asu64(R1);
}

static void qq_dicts_obj_free_dict(u64 p, i64 internal) {
    u64 R1, R2, R3; 
	u64 q;
	struct $B3 v;
	i64 av_1;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1966;
L1964:
	asu64(R1) = q;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1968;
	asu64(R1) = q;
	qq_vars_var_unshareu(asu64(R1));
L1968:
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L1964;
L1966:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L1970;
	asu64(R1) = p;
	R2 = 24;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L1970:
	asi64(R1) = internal;
	if (asi64(R1)) goto L1972;
	asu64(R1) = p;
	mlib_pcm_free32(asu64(R1));
L1972:
	return;
}

static void qq_dicts_var_dupl_dict(u64 a) {
    u64 R1, R2, R3, R4; struct $B32 R1_B32; struct $B3 R1_B3; 
	u64 p;
	u64 q;
	u64 plist;
	u64 qlist;
	i64 av_1;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 28;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R1) = qq_dicts_obj_new_dict(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	(R1_B32) = *(struct $B32*)(R1);
	asu64(R2) = q;
	*(struct $B32*)(R2) = (R1_B32);
	R1 = 1;
	asu64(R2) = q;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	asu64(R2) = q;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1975;
	goto L1973;
L1975:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	asu64(R3) = q;
	R4 = 8;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	qlist = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = 16;
	asi64(R1) /= asi64(R2);
	asu64(R2) = q;
	R3 = 24;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	plist = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1978;
L1976:
	asu64(R1) = plist;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = qlist;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = qlist;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1980;
	asu64(R1) = qlist;
	qq_vars_var_duplu(asu64(R1));
L1980:
	R1 = (u64)&qlist;
	(*tou64p(R1)) += 16;
	R1 = (u64)&plist;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L1976;
L1978:
L1973:
	return;
}

static i64 qq_dicts_var_equal_dict(u64 x, u64 y) {
    u64 R1, R2; 
	i64 xlen;
	i64 ylen;
	i64 res;
	u64 px;
	u64 py;
	u64 a;
	u64 b;
	R1 = tou64("");
	R2 = tou64("EQUALDICT");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	R1 = 1;
	goto L1981;
L1981:
	return asi64(R1);
}

static u64 qq_dicts_var_finddictitem(u64 vd, u64 p, i64 doins) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	i64 hash;
	i64 index;
	i64 size;
	i64 keytag;
	i64 wrapped;
	i64 limit;
	i64 keyvalue;
	u64 q;
	u64 pa;
	u64 qa;
	u64 d;
// qq_dicts.var_finddictitem.retry:
L1983:
	asu64(R1) = vd;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	asi64(R1) /= asi64(R2);
	size = asi64(R1);
	asu64(R1) = p;
	asi64(R1) = qq_vars_var_gethashvalue(asu64(R1));
	asi64(R2) = size;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) &= asi64(R2);
	index = asi64(R1);
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = index;
	R3 = 2;
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2*16;
	q = asu64(R1);
	R1 = 0;
	wrapped = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	keytag = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	keyvalue = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
L1984:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1987;
	goto L1985;
	goto L1986;
L1987:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = keytag;
	if (asi64(R1) != asi64(R2)) goto L1988;
	asi64(R1) = keytag;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1990;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1990;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1990;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L1991;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L1992;
	goto L1993;
L1990:
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = keyvalue;
	if (asi64(R1) != asi64(R2)) goto L1995;
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
	asu64(R1) = q;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1997;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L1997:
	asu64(R1) = q;
	goto L1982;
L1995:
	goto L1989;
L1991:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qa = asu64(R1);
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = qa;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L1999;
	asu64(R1) = pa;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = qa;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = pa;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2001;
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
	asu64(R1) = q;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2003;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L2003:
	asu64(R1) = q;
	goto L1982;
L2001:
L1999:
	goto L1989;
L1992:
	asu64(R1) = q;
	asu64(R2) = p;
	asi64(R1) = qq_records_var_equal_record(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L2005;
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
	asu64(R1) = q;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2007;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L2007:
	asu64(R1) = q;
	goto L1982;
L2005:
	goto L1989;
L1993:
L1989:
L1988:
L1986:
	R1 = (u64)&index;
	(*toi64p(R1)) += 1;
	R1 = 2;
	R2 = (u64)&q;
	*tou64p(R2) += asu64(R1)*16;
	asi64(R1) = index;
	asi64(R2) = size;
	if (asi64(R1) < asi64(R2)) goto L2009;
	asi64(R1) = wrapped;
	if (!asi64(R1)) goto L2011;
	R1 = tou64("");
	R2 = tou64("DICT FULL?");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2011:
	R1 = 1;
	wrapped = asi64(R1);
	R1 = 0;
	index = asi64(R1);
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L2009:
	goto L1984;
L1985:
	asi64(R1) = doins;
	if (!asi64(R1)) goto L2013;
	asi64(R1) = size;
	R2 = 3;
	asi64(R1) *= asi64(R2);
	R2 = 4;
	asi64(R1) /= asi64(R2);
	limit = asi64(R1);
	asu64(R1) = d;
	R2 = 28;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asi64(R2) = limit;
	if (asi64(R1) < asi64(R2)) goto L2015;
	asu64(R1) = vd;
	qq_dicts_expanddict(asu64(R1));
	goto L1983;
L2015:
	asu64(R1) = p;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = q;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = q;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2017;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L2017:
	asu64(R1) = d;
	R2 = 28;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	asu64(R1) = q;
	R2 = 1;
	R1 += (i64)R2*16;
	goto L2012;
L2013:
	R1 = 0;
L2012:
	goto L1982;
L1982:
	return asu64(R1);
}

static void qq_dicts_expanddict(u64 vd) {
    u64 R1, R2, R3; struct $B3 R1_B3; struct $B32 R1_B32; 
	i64 n;
	i64 m;
	i64 i;
	i64 j;
	i64 k;
	i64 oldrefcount;
	u64 d;
	u64 e;
	struct $B32 temp;
	u64 p;
	u64 q;
	u64 r;
	struct $B3 ev;
	asu8(R1) = qq_dicts_expanddict_inuse;
	if (!asu8(R1)) goto L2020;
	R1 = tou64("");
	R2 = tou64("expanddict?");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2020:
	R1 = 1;
	qq_dicts_expanddict_inuse = asu8(R1);
	asu64(R1) = vd;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 24;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 2;
	asi64(R1) /= asi64(R2);
	m = asi64(R1);
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asi64(R1) = m;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	asu64(R1) = qq_dicts_obj_new_dict(asi64(R1));
	e = asu64(R1);
	R1 = (u64)&ev;
	asu64(R2) = e;
	R3 = 6;
	qq_vars_var_objtovar(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	q = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = m;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2023;
L2021:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2025;
	R1 = 1;
	asu64(R2) = q;
	R3 = (u64)&ev;
	asu64(R1) = qq_dicts_var_finddictitem(asu64(R3), asu64(R2), asi64(R1));
	r = asu64(R1);
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
	R1 = (u64)&q;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 16; asu64(R1) = asu64(R2);
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = r;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = r;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2027;
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L2027:
	goto L2024;
L2025:
	R1 = 2;
	R2 = (u64)&q;
	*tou64p(R2) += asu64(R1)*16;
L2024:
	i += 1; if (i <= m) goto L2021;
L2023:
	R1 = 1;
	asu64(R2) = d;
	qq_dicts_obj_free_dict(asu64(R2), asi64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	oldrefcount = asi64(R1);
	asu64(R1) = e;
	(R1_B32) = *(struct $B32*)(R1);
	asu64(R2) = d;
	*(struct $B32*)(R2) = (R1_B32);
	R1 = 8;
	asu64(R2) = e;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asi64(R1) = oldrefcount;
	asu64(R2) = d;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	qq_dicts_expanddict_inuse = asu8(R1);
	return;
}

static void qq_dicts_adddictitem(u64 d, u64 p, u64 q) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 da;
	u64 r;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	da = asu64(R1);
	asu64(R1) = da;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2030;
	R1 = tou64("");
	R2 = tou64("NULL DICT");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2030:
	R1 = 1;
	asu64(R2) = p;
	asu64(R3) = d;
	asu64(R1) = qq_dicts_var_finddictitem(asu64(R3), asu64(R2), asi64(R1));
	r = asu64(R1);
	asu64(R1) = q;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2032;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L2032:
	asu64(R1) = r;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2034;
	asu64(R1) = r;
	qq_vars_var_unshareu(asu64(R1));
L2034:
	asu64(R1) = q;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = r;
	*(struct $B3*)(R2) = (R1_B3);
	return;
}

static u64 qq_host_callhostfunction(i64 hostfn, u64 sp) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 fnaddr;
	i64 nparams;
	i64 isfn;
	u64 p;
	i64 av_1;
	R1 = (u64)&qq_tables_hosthandlers;
	asi64(R2) = hostfn;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	fnaddr = asu64(R1);
	R1 = (u64)&qq_tables_hostnparams;
	asi64(R2) = hostfn;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	nparams = asi64(R1);
	R1 = (u64)&qq_tables_hostisfn;
	asi64(R2) = hostfn;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	isfn = asi64(R1);
	asu64(R1) = fnaddr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2037;
	R1 = (u64)&qq_tables_hostfnnames;
	asi64(R2) = hostfn;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("Hostfn not implemented:");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2037:
	asi64(R1) = nparams;
	asi64(R2) = isfn;
	asi64(R1) += asi64(R2);
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2039;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2040;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2041;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2042;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2043;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2044;
	goto L2045;
L2039:
	asu64(R1) = fnaddr;
	((F18)R1)();
	goto L2038;
L2040:
	asu64(R1) = sp;
	asu64(R2) = fnaddr;
	((F19)R2)(asu64(R1));
	goto L2038;
L2041:
	asu64(R1) = sp;
	R2 = 1;
	R1 -= (i64)R2*16;
	asu64(R2) = sp;
	asu64(R3) = fnaddr;
	((F20)R3)(asu64(R2), asu64(R1));
	goto L2038;
L2042:
	asu64(R1) = sp;
	R2 = 2;
	R1 -= (i64)R2*16;
	asu64(R2) = sp;
	R3 = 1;
	R2 -= (i64)R3*16;
	asu64(R3) = sp;
	asu64(R4) = fnaddr;
	((F21)R4)(asu64(R3), asu64(R2), asu64(R1));
	goto L2038;
L2043:
	asu64(R1) = sp;
	R2 = 3;
	R1 -= (i64)R2*16;
	asu64(R2) = sp;
	R3 = 2;
	R2 -= (i64)R3*16;
	asu64(R3) = sp;
	R4 = 1;
	R3 -= (i64)R4*16;
	asu64(R4) = sp;
	asu64(R5) = fnaddr;
	((F22)R5)(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L2038;
L2044:
	asu64(R1) = sp;
	R2 = 4;
	R1 -= (i64)R2*16;
	asu64(R2) = sp;
	R3 = 3;
	R2 -= (i64)R3*16;
	asu64(R3) = sp;
	R4 = 2;
	R3 -= (i64)R4*16;
	asu64(R4) = sp;
	R5 = 1;
	R4 -= (i64)R5*16;
	asu64(R5) = sp;
	asu64(R6) = fnaddr;
	((F23)R6)(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L2038;
L2045:
	R1 = tou64("");
	R2 = tou64("callhost/proc");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2038:
	asi64(R1) = nparams;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2048;
L2046:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2050;
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2052;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L2052:
L2050:
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	if (--asi64(av_1)) goto L2046;
L2048:
	asu64(R1) = sp;
	goto L2035;
L2035:
	return asu64(R1);
}

static void qq_host_pch_leftstr(u64 a, u64 b, u64 c, u64 result) {
    u64 R1, R2, R3, R4; 
	i64 n;
	i64 length;
	i64 padchar;
	u64 s;
	u64 pa;
	R1 = 32;
	padchar = asi64(R1);
	asu64(R1) = c;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2055;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2056;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2057;
	goto L2058;
L2055:
	goto L2054;
L2056:
	asu64(R1) = c;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2060;
	asu64(R1) = c;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	padchar = asi64(R1);
	goto L2059;
L2060:
	R1 = tou64("");
	R2 = tou64("left/padx");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2059:
	goto L2054;
L2057:
	asu64(R1) = c;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	padchar = asi64(R1);
	goto L2054;
L2058:
	R1 = tou64("");
	R2 = tou64("left/pad?");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2054:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2062;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2063;
	goto L2064;
L2062:
	R1 = 1;
	n = asi64(R1);
	goto L2061;
L2063:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	goto L2061;
L2064:
	R1 = tou64("");
	R2 = tou64("left:bad n");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2061:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2066;
	R1 = tou64("");
	R2 = tou64("left:not str");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2066:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2068;
	R1 = 1;
	asu64(R2) = result;
	qq_strings_var_empty_string(asu64(R2), asi64(R1));
	goto L2053;
L2068:
	R1 = 265;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2070;
	asi64(R1) = n;
	asi64(R2) = length;
	if (asi64(R1) > asi64(R2)) goto L2072;
	asu64(R1) = result;
	asi64(R2) = n;
	asu64(R3) = a;
	qq_host_leftstring(asu64(R3), asi64(R2), asu64(R1));
	goto L2071;
L2072:
	asu64(R1) = result;
	asi64(R2) = padchar;
	asi64(R3) = n;
	asu64(R4) = a;
	qq_host_padstring_right(asu64(R4), asi64(R3), asi64(R2), asu64(R1));
L2071:
	goto L2069;
L2070:
	asi64(R1) = n;
	asi64(R1) = -asi64(R1);
	n = asi64(R1);
	asi64(R1) = n;
	asi64(R2) = length;
	if (asi64(R1) >= asi64(R2)) goto L2074;
	asu64(R1) = result;
	asi64(R2) = length;
	asi64(R3) = n;
	asi64(R2) -= asi64(R3);
	asu64(R3) = a;
	qq_host_leftstring(asu64(R3), asi64(R2), asu64(R1));
	goto L2073;
L2074:
	R1 = 1;
	asu64(R2) = result;
	qq_strings_var_empty_string(asu64(R2), asi64(R1));
L2073:
L2069:
L2053:
	return;
}

static void qq_host_pch_rightstr(u64 a, u64 b, u64 c, u64 result) {
    u64 R1, R2, R3, R4; 
	i64 n;
	i64 length;
	i64 padchar;
	u64 s;
	u64 pa;
	R1 = 32;
	padchar = asi64(R1);
	asu64(R1) = c;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2077;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2078;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2079;
	goto L2080;
L2077:
	goto L2076;
L2078:
	asu64(R1) = c;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2082;
	asu64(R1) = c;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	padchar = asi64(R1);
	goto L2081;
L2082:
	R1 = tou64("");
	R2 = tou64("right/padx");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2081:
	goto L2076;
L2079:
	asu64(R1) = c;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	padchar = asi64(R1);
	goto L2076;
L2080:
	R1 = tou64("");
	R2 = tou64("right/pad?");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2076:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2084;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2085;
	goto L2086;
L2084:
	R1 = 1;
	n = asi64(R1);
	goto L2083;
L2085:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	goto L2083;
L2086:
	R1 = tou64("");
	R2 = tou64("right:bad n");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2083:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2088;
	R1 = tou64("");
	R2 = tou64("right:not str");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2088:
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	R1 = 265;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2090;
	R1 = 1;
	asu64(R2) = result;
	qq_strings_var_empty_string(asu64(R2), asi64(R1));
	goto L2075;
L2090:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2092;
	asi64(R1) = n;
	asi64(R2) = length;
	if (asi64(R1) > asi64(R2)) goto L2094;
	asu64(R1) = result;
	asi64(R2) = n;
	asu64(R3) = a;
	qq_host_rightstring(asu64(R3), asi64(R2), asu64(R1));
	goto L2093;
L2094:
	asu64(R1) = result;
	asi64(R2) = padchar;
	asi64(R3) = n;
	asu64(R4) = a;
	qq_host_padstring_left(asu64(R4), asi64(R3), asi64(R2), asu64(R1));
L2093:
	goto L2091;
L2092:
	asi64(R1) = n;
	asi64(R1) = -asi64(R1);
	n = asi64(R1);
	asi64(R1) = n;
	asi64(R2) = length;
	if (asi64(R1) >= asi64(R2)) goto L2096;
	asu64(R1) = result;
	asi64(R2) = length;
	asi64(R3) = n;
	asi64(R2) -= asi64(R3);
	asu64(R3) = a;
	qq_host_rightstring(asu64(R3), asi64(R2), asu64(R1));
	goto L2095;
L2096:
	R1 = 1;
	asu64(R2) = result;
	qq_strings_var_empty_string(asu64(R2), asi64(R1));
L2095:
L2091:
L2075:
	return;
}

static void qq_host_pch_convlc(u64 a, u64 b, u64 result) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	R1 = -999999;
	R2 = 9;
	asu64(R3) = a;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = result;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = result;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
	asu64(R1) = result;
	qq_vars_var_duplu(asu64(R1));
	R1 = 0;
	asu64(R2) = b;
	asu64(R3) = result;
	qq_strings_var_iconvcase(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_host_pch_convuc(u64 a, u64 b, u64 result) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	R1 = -999999;
	R2 = 9;
	asu64(R3) = a;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = result;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = result;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
	asu64(R1) = result;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2100;
	asu64(R1) = result;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2102;
	asu64(R1) = result;
	qq_vars_var_duplu(asu64(R1));
L2102:
L2100:
	R1 = 1;
	asu64(R2) = b;
	asu64(R3) = result;
	qq_strings_var_iconvcase(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_host_pch_waitkey(u64 result) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mwindows_os_getch();
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_pch_execwait(u64 a, u64 b, u64 c, u64 result) {
    u64 R1, R2, R3, R4, R5; 
	u64 workdir;
	i64 flag;
	u64 pa;
	R1 = -999999;
	R2 = 9;
	asu64(R3) = a;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	R1 = 0;
	R2 = 1;
	asu64(R3) = b;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	flag = asi64(R1);
	asu64(R1) = c;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2106;
	R1 = 0;
	workdir = asu64(R1);
	goto L2105;
L2106:
	R1 = -999999;
	R2 = 9;
	asu64(R3) = c;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = c;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = c;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_lib_convtostringz(asu64(R2), asi64(R1));
	workdir = asu64(R1);
L2105:
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = workdir;
	asi64(R2) = flag;
	asu64(R3) = pa;
	R4 = 16;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asu64(R4) = pa;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R3) = qq_lib_convtostringz(asu64(R4), asi64(R3));
	asi64(R1) = mwindows_os_execwait(asu64(R3), asi64(R2), asu64(R1));
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_pch_execcmd(u64 a, u64 b, u64 c, u64 result) {
    u64 R1, R2, R3, R4; 
	u64 workdir;
	i64 flag;
	u64 pa;
	R1 = -999999;
	R2 = 9;
	asu64(R3) = a;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	R1 = 0;
	R2 = 1;
	asu64(R3) = b;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	flag = asi64(R1);
	asu64(R1) = c;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2109;
	R1 = 0;
	workdir = asu64(R1);
	goto L2108;
L2109:
	R1 = -999999;
	R2 = 9;
	asu64(R3) = c;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = c;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = c;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_lib_convtostringz(asu64(R2), asi64(R1));
	workdir = asu64(R1);
L2108:
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = flag;
	asu64(R2) = pa;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = pa;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R2) = qq_lib_convtostringz(asu64(R3), asi64(R2));
	asi64(R1) = mwindows_os_execcmd(asu64(R2), asi64(R1));
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_pch_makestr(u64 a, u64 b, u64 result) {
    u64 R1, R2, R3; 
	i64 n;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L2112;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2113;
	goto L2114;
L2112:
	goto L2111;
L2113:
	goto L2111;
L2114:
	R1 = tou64("");
	R2 = tou64("makestr");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2111:
	asu64(R1) = b;
	asi64(R1) = qq_vars_var_getintvalue(asu64(R1));
	n = asi64(R1);
	R1 = 265;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_strings_obj_make_strslicexobj(asu64(R2), asi64(R1));
	asu64(R2) = result;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_host_pch_makeref(u64 a, u64 b, u64 result) {
    u64 R1, R2, R3; 
	u64 ptr;
	R1 = (u64)&qq_tables_ttbasetype;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L2117;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L2117;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2117;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2118;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2118;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L2118;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2118;
	goto L2119;
L2117:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ptr = asu64(R1);
	goto L2116;
L2118:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ptr = asu64(R1);
	goto L2116;
L2119:
	R1 = tou64("");
	R2 = tou64("makeref");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2116:
	R1 = 16;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = ptr;
	asu64(R2) = result;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = b;
	asi64(R1) = qq_vars_var_getintvalue(asu64(R1));
	asu64(R2) = result;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = result;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L2121;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L2121;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L2121;
	goto L2122;
L2121:
	R1 = 15;
	asu64(R2) = result;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = result;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = result;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2120;
L2122:
L2120:
	return;
}

static void qq_host_pch_getcmdparam(u64 a, u64 result) {
    u64 R1, R2, R3, R4; 
	i64 n;
	u64 s;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2125;
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = qq_decls_nqparams;
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L2123;
L2125:
	asu64(R1) = a;
	asi64(R1) = qq_vars_var_getintvalue(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2128;
	asi64(R2) = qq_decls_nqparams;
	if (asi64(R1) <= asi64(R2)) goto L2127;
L2128:
	R1 = tou64("");
	R2 = tou64("getcmdpm");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2127:
	R1 = 0;
	asu64(R2) = result;
	R3 = (u64)&qq_decls_qparamtable;
	asi64(R4) = n;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	qq_strings_var_make_string(asu64(R3), asu64(R2), asi64(R1));
L2123:
	return;
}

static void qq_host_pch_clock(u64 result) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mwindows_os_clock();
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_pch_allocexec(u64 a, u64 result) {
    u64 R1, R2, R3; 
	i64 n;
	u64 p;
	asu64(R1) = a;
	asi64(R1) = qq_vars_var_getintvalue(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R1) = mwindows_os_allocexecmem(asi64(R1));
	p = asu64(R1);
	R1 = 16;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = result;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 27;
	asu64(R2) = result;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	return;
}

static void qq_host_pch_runnative(u64 a, u64 b, u64 result) {
    u64 R1, R2, R3; 
	i64 n;
	u64 fnptr;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L2133;
	R1 = tou64("");
	R2 = tou64("runnative?");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2133:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fnptr = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = fnptr;
	asi64(R1) = ((F3)R2)(asi64(R1));
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	return;
}

static void qq_host_pch_setlwb(u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 n;
	u64 p;
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2136;
	goto L2137;
L2136:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L2139;
	qq_lib_pcnotmut();
L2139:
	R1 = -999999;
	R2 = 1;
	asu64(R3) = b;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L2141;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2142;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L2142;
	goto L2143;
L2141:
	asi64(R1) = n;
	R2 = -32768;
	if (asi64(R1) < asi64(R2)) goto L2146;
	R2 = 32767;
	if (asi64(R1) <= asi64(R2)) goto L2145;
L2146:
	R1 = tou64("");
	R2 = tou64("lwb not i16");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2145:
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 6;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L2140;
L2142:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L2149;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L2148;
L2149:
	R1 = tou64("");
	R2 = tou64("lwb not 0/1");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2148:
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L2140;
L2143:
// qq_host.pch_setlwb.error:
L2137:
	R1 = tou64("");
	R2 = tou64("Can't set lwb");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2140:
	return;
}

static void qq_host_pch_ticks(u64 result) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mwindows_os_ticks();
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_pch_sleep(u64 a) {
    u64 R1, R2, R3; 
	R1 = -999999;
	R2 = 1;
	asu64(R3) = a;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mwindows_os_sleep(asi64(R1));
	return;
}

static void qq_host_pch_random(u64 a, u64 result) {
    u64 R1, R2, R3, R4; 
	i64 n;
	i64 x;
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2154;
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 16;
	R4 = 63;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R1) = mlib_mrandomrange(asi64(R2), asi64(R1));
	x = asi64(R1);
	goto L2153;
L2154:
	R1 = -999999;
	R2 = 1;
	asu64(R3) = a;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L2156;
	asi64(R1) = n;
	asi64(R1) = mlib_mrandomint(asi64(R1));
	x = asi64(R1);
	goto L2155;
L2156:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2157;
	asi64(R1) = mlib_mrandom();
	x = asi64(R1);
	goto L2155;
L2157:
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2158;
	R1 = 2;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asr64(R1) = mlib_mrandomreal();
	asu64(R2) = result;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L2152;
	goto L2155;
L2158:
	R1 = 0;
	asi64(R2) = n;
	asi64(R2) = -asi64(R2);
	mlib_mseed(asu64(R2), asu64(R1));
	R1 = 0;
	x = asi64(R1);
L2155:
L2153:
	asi64(R1) = x;
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2152:
	return;
}

static void qq_host_pch_system(u64 a, u64 result) {
    u64 R1, R2, R3; 
	R1 = -999999;
	R2 = 9;
	asu64(R3) = a;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_lib_convtostringz(asu64(R2), asi64(R1));
	asi32(R1) = system(asu64(R1));
	R1 = toi64(toi32(R1));
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_pch_$getparam(u64 a, u64 result) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	R1 = -999999;
	R2 = 1;
	asu64(R3) = a;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = qq_decls_frameptr;
	asu64(R2) = a;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 16;
	asi64(R2) *= asi64(R3);
	R1 -= (i64)R2;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = result;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = result;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2162;
	asu64(R1) = result;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L2162:
	return;
}

static i64 qq_host_checkparam(u64 p, i64 tag, i64 defaultx) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2165;
	asi64(R2) = tag;
	if (asi64(R1) == asi64(R2)) goto L2166;
	goto L2167;
L2165:
	asi64(R1) = defaultx;
	R2 = -999999;
	if (asi64(R1) != asi64(R2)) goto L2169;
	R1 = tou64("");
	R2 = tou64("Missing host param");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2169:
	asi64(R1) = defaultx;
	goto L2163;
	goto L2164;
L2166:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L2163;
	goto L2164;
L2167:
L2164:
	asi64(R1) = tag;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2171;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2173;
	goto L2174;
L2173:
	asu64(R1) = p;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = toi64(asr64(R1));
	goto L2163;
	goto L2172;
L2174:
L2172:
L2171:
	msysc_m$print_startcon();
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("Host param wrong type");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	R1 = 0;
	goto L2163;
L2163:
	return asi64(R1);
}

static void qq_host_leftstring(u64 a, i64 n, u64 result) {
    u64 R1, R2, R3, R4, R5; 
	u64 p;
	R1 = 1;
	asu64(R2) = result;
	asi64(R3) = n;
	asu64(R4) = a;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_host_rightstring(u64 a, i64 n, u64 result) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 p;
	R1 = 1;
	asu64(R2) = result;
	asi64(R3) = n;
	asu64(R4) = a;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R5) = a;
	R6 = 8;
	asu64(R5) = *tou64p(((i64)R5+(i64)R6));
	R6 = 16;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6));
	asi64(R6) = n;
	asi64(R5) -= asi64(R6);
	R4 += (i64)R5;
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_host_padstring_right(u64 a, i64 n, i64 fillchar, u64 result) {
    u64 R1, R2, R3; 
	u64 s;
	i64 length;
	i64 av_1;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asu64(R1) = result;
	asi64(R2) = n;
	qq_strings_var_new_stringn(asi64(R2), asu64(R1));
	asu64(R1) = result;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L2179;
	asi64(R1) = length;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = length;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
L2179:
	asi64(R1) = n;
	asi64(R2) = length;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2182;
L2180:
	asi64(R1) = fillchar;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L2180;
L2182:
	return;
}

static void qq_host_padstring_left(u64 a, i64 n, i64 fillchar, u64 result) {
    u64 R1, R2, R3, R4; 
	u64 s;
	i64 length;
	i64 padlen;
	i64 av_1;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asi64(R1) = n;
	asi64(R2) = length;
	asi64(R1) -= asi64(R2);
	padlen = asi64(R1);
	R1 = 0;
	asu64(R2) = result;
	asi64(R3) = n;
	R4 = 0;
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	asu64(R1) = result;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asi64(R1) = padlen;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L2185;
	asi64(R1) = length;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L2185:
	asi64(R1) = padlen;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2188;
L2186:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	asi64(R1) = fillchar;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	if (--asi64(av_1)) goto L2186;
L2188:
	return;
}

static void qq_host_getbounds(u64 p, u64 dims, i64 lower) {
    u64 R1, R2, R3, R4; 
	i64 n;
	asu64(R1) = p;
	if (asu64(R1)) goto L2191;
	R1 = tou64("");
	R2 = tou64("New: no bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2191:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2193;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2194;
	goto L2195;
L2193:
	asi64(R1) = lower;
	asu64(R2) = dims;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	asu64(R2) = dims;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	asu64(R2) = dims;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L2192;
L2194:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	R3 = 63;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = dims;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = dims;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 16;
	R4 = 63;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = dims;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = dims;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L2197;
	R1 = 0;
	asu64(R2) = dims;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = dims;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = dims;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2197:
	goto L2192;
L2195:
	asu64(R1) = p;
	asi64(R1) = qq_vars_var_getintvalue(asu64(R1));
	n = asi64(R1);
	asi64(R1) = lower;
	asu64(R2) = dims;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = n;
	R2 = R1;
	asu64(R3) = dims;
	R4 = 16;
	*toi64p(((i64)R3+(i64)R4)) = asi64(R2);
	asu64(R2) = dims;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2192:
	return;
}

static void qq_host_pch_new(u64 a, u64 b, u64 c, u64 d, u64 result) {
    u64 R1, R2, R3, R4, R5; struct $B3 R1_B3; 
	struct $B3 v;
	i64 i;
	i64 t;
	i64 nbytes;
	i64 ival;
	i64 nwords;
	i64 nbits;
	i64 offset;
	i64 elemtype;
	i64 n;
	i64 usertag;
	struct $B8 dims;
	u64 qvar;
	u64 qint;
	u64 qbyte;
	u64 ptr;
	u64 p;
	i64 av_1;
	i64 av_2;
	asu64(R1) = a;
	asi64(R1) = qq_vars_var_getintvalue(asu64(R1));
	t = asi64(R1);
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L2201;
	asi64(R1) = t;
	asi64(R2) = qq_tables_ntypes;
	if (asi64(R1) <= asi64(R2)) goto L2200;
L2201:
	asi64(R1) = t;
	R2 = tou64("New:bad type");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L2200:
	asi64(R1) = t;
	R2 = 256;
	asi64(R1) |= asi64(R2);
	R2 = (u64)&v;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	usertag = asi64(R1);
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	switch (asi64(R1)) {
	case 1: case 2: case 14: goto L2242;
	case 3: goto L2248;
	case 4: goto L2204;
	case 5: goto L2233;
	case 6: goto L2245;
	case 7: goto L2219;
	case 8: goto L2220;
	case 9: goto L2205;
	case 10: goto L2206;
	case 11: goto L2207;
	case 12: goto L2238;
	case 13: goto L2239;
	default: goto L2204;
    };
// SWITCH
L2205:
	asu64(R1) = result;
	asu64(R2) = c;
	asu64(R3) = b;
	qq_strings_var_new_string(asu64(R3), asu64(R2), asu64(R1));
	goto L2198;
	goto L2202;
L2206:
	R1 = 1;
	R2 = (u64)&dims;
	asu64(R3) = b;
	qq_host_getbounds(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = c;
	R2 = (u64)&dims;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = (u64)&dims;
	R4 = 16;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asu64(R1) = qq_lists_obj_newlist(asi64(R3), asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&v;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L2202;
L2207:
	asu64(R1) = b;
	asi64(R1) = qq_vars_var_getintvalue(asu64(R1));
	elemtype = asi64(R1);
	R1 = 1;
	R2 = (u64)&dims;
	asu64(R3) = c;
	qq_host_getbounds(asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = elemtype;
	R2 = 33;
	if (asi64(R1) < asi64(R2)) goto L2209;
	asi64(R1) = elemtype;
	R2 = 35;
	if (asi64(R1) > asi64(R2)) goto L2209;
	R1 = 8;
	R2 = R1;
	t = asi64(R2);
	R2 = (u64)&v;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2210;
L2209:
	R1 = (u64)&dims;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&dims;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R3) = elemtype;
	asu64(R1) = qq_arrays_obj_newarray(asi64(R3), asi64(R2), asi64(R1));
	p = asu64(R1);
// qq_host.pch_new.doarray2:
L2211:
	asu64(R1) = p;
	R2 = (u64)&v;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&dims;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L2213;
	asu64(R1) = d;
	if (!asu64(R1)) goto L2215;
	asu64(R1) = d;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2215;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qbyte = asu64(R1);
	R1 = (u64)&dims;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2218;
L2216:
	asi64(R1) = elemtype;
	asu64(R2) = d;
	asu64(R3) = qbyte;
	qq_packed_var_storepacked(asu64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = elemtype;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&qbyte;
	*tou64p(R2) += asu64(R1);
	if (--asi64(av_1)) goto L2216;
L2218:
L2215:
L2213:
	goto L2202;
L2219:
	asi64(R1) = t;
	usertag = asi64(R1);
	R1 = 7;
	R2 = (u64)&v;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemtype = asi64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&dims;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&qq_tables_ttlower;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&dims;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&dims;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&dims;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&dims;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = b;
	d = asu64(R1);
	asi64(R1) = t;
	asu64(R1) = qq_arrays_obj_newarray_u(asi64(R1));
	p = asu64(R1);
	goto L2211;
	goto L2202;
L2220:
	asu64(R1) = b;
	asi64(R1) = qq_vars_var_getintvalue(asu64(R1));
	elemtype = asi64(R1);
	asi64(R1) = elemtype;
	R2 = 33;
	if (asi64(R1) < asi64(R2)) goto L2223;
	R2 = 35;
	if (asi64(R1) <= asi64(R2)) goto L2222;
L2223:
	R1 = tou64("");
	R2 = tou64("new: bad bits elem");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2222:
	R1 = 1;
	R2 = (u64)&dims;
	asu64(R3) = c;
	qq_host_getbounds(asu64(R3), asu64(R2), asi64(R1));
// qq_host.pch_new.dobits2:
L2210:
	R1 = (u64)&dims;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&dims;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R3) = elemtype;
	asu64(R1) = qq_bits_obj_newbits(asi64(R3), asi64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&v;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&dims;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L2225;
	asu64(R1) = d;
	if (!asu64(R1)) goto L2227;
	asu64(R1) = d;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2227;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qbyte = asu64(R1);
	R1 = 0;
	offset = asi64(R1);
	R1 = (u64)&dims;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2230;
L2228:
	R1 = 0;
	asi64(R2) = elemtype;
	asu64(R3) = d;
	asi64(R4) = offset;
	asu64(R5) = qbyte;
	qq_vars_var_storebit(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&qq_tables_ttbitwidth;
	asi64(R2) = elemtype;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = offset;
	R2 = 8;
	if (asi64(R1) < asi64(R2)) goto L2232;
	R1 = 0;
	offset = asi64(R1);
	R1 = (u64)&qbyte;
	(*tou64p(R1)) += 1;
L2232:
	if (--asi64(av_2)) goto L2228;
L2230:
L2227:
L2225:
	goto L2202;
L2233:
	R1 = 0;
	R2 = (u64)&dims;
	asu64(R3) = b;
	qq_host_getbounds(asu64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&dims;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L2235;
	R1 = tou64("");
	R2 = tou64("new:set:lwb");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2235:
	R1 = (u64)&dims;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2237;
	R1 = 0;
	R2 = (u64)&dims;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&dims;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&dims;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2237:
	R1 = (u64)&dims;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_sets_obj_newset(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&v;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L2202;
L2238:
	asu64(R1) = b;
	asi64(R2) = t;
	asu64(R1) = qq_records_obj_new_record(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&v;
	asu64(R2) = p;
	asi64(R3) = t;
	qq_vars_var_fromobj(asi64(R3), asu64(R2), asu64(R1));
	R1 = 12;
	R2 = (u64)&v;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = t;
	usertag = asi64(R1);
	goto L2202;
L2239:
	asi64(R1) = t;
	asu64(R1) = qq_packed_obj_new_struct(asi64(R1));
	p = asu64(R1);
	R1 = (u64)&v;
	asu64(R2) = p;
	asi64(R3) = t;
	qq_vars_var_objtovar(asi64(R3), asu64(R2), asu64(R1));
	R1 = 13;
	R2 = (u64)&v;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = t;
	usertag = asi64(R1);
	asu64(R1) = b;
	if (!asu64(R1)) goto L2241;
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2241;
	R1 = tou64("");
	R2 = tou64("New: struct init");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2241:
	goto L2202;
L2242:
	R1 = 0;
	R2 = (u64)&v;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	R2 = (u64)&v;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = b;
	if (!asu64(R1)) goto L2244;
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2244;
	R1 = tou64("");
	R2 = tou64("NEW(int/value)");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2244:
	goto L2202;
L2245:
	R1 = 1;
	R2 = (u64)&dims;
	asu64(R3) = b;
	qq_host_getbounds(asu64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&dims;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2247;
	R1 = tou64("");
	R2 = tou64("new:dict:lwb");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2247:
	R1 = (u64)&dims;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_dicts_obj_new_dict(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&v;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L2202;
L2248:
	asu64(R1) = result;
	qq_decimal_var_empty_dec(asu64(R1));
	goto L2198;
	goto L2202;
L2204:
	asi64(R1) = t;
	R2 = tou64("new");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L2202:
// qq_host.pch_new.finish:
	asi64(R1) = usertag;
	if (!asi64(R1)) goto L2251;
	asi64(R1) = usertag;
	R2 = (u64)&v;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
L2251:
	(R1_B3) = v;
	asu64(R2) = result;
	*(struct $B3*)(R2) = (R1_B3);
L2198:
	return;
}

static void qq_host_pch_gethostname(u64 result) {
    u64 R1, R2, R3; 
	asu64(R1) = mwindows_os_gethostname();
	R2 = (u64)&qq_host_pch_gethostname_name;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = result;
	R3 = (u64)&qq_host_pch_gethostname_name;
	qq_strings_var_make_string(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_host_pch_getprogname(u64 result) {
    u64 R1, R2, R3; 
	asu64(R1) = qq_cli_inputfile;
	R2 = (u64)&qq_host_pch_getprogname_name;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = result;
	R3 = (u64)&qq_host_pch_getprogname_name;
	qq_strings_var_make_string(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_host_pch_$test(u64 a, u64 b, u64 c, u64 result) {
    u64 R1, R2, R3; 
	u64 p;
	msysc_m$print_startcon();
	R1 = tou64("$TEST:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asu64(R2) = c;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_pch_$test2(u64 a, u64 result) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	return;
}

static void qq_host_pch_$refcount(u64 a, u64 result) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2258;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L2257;
L2258:
	R1 = 0;
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2257:
	return;
}

static void qq_host_pch_testkey(u64 result) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mwindows_os_kbhit();
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_pch_getos(u64 result) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = result;
	asu64(R3) = mwindows_os_getos();
	qq_strings_var_make_string(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_host_pch_setmesshandler(u64 fn) {
    u64 R1, R2; 
	asu64(R1) = fn;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L2264;
	asu64(R1) = fn;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2263;
L2264:
	R1 = tou64("");
	R2 = tou64("Not proc ref");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2263:
	asu64(R1) = fn;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_decls_pcl_callbackfn = asu64(R1);
	R1 = (u64)&qq_runaux_runproc_m;
	mwindows_os_setmesshandler(asu64(R1));
	return;
}

static void qq_host_pch_$smallmemtotal(u64 result) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mlib_smallmemtotal;
	R2 = 16;
	asi64(R1) /= asi64(R2);
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_pch_$id(u64 a, u64 result) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_pch_iswindows(u64 result) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mwindows_os_iswindows();
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_pch_$setdebug(u64 a) {
    u64 R1, R2, R3; 
	R1 = -999999;
	R2 = 1;
	asu64(R3) = a;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	msysc_m$print_startcon();
	R1 = tou64("SETDEBUG.................");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mlib_fdebug = asi64(R1);
	return;
}

static void qq_host_pch_copy(u64 a, u64 dest) {
    u64 R1, R2; struct $B3 R1_B3; 
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = dest;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = dest;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2271;
	asu64(R1) = dest;
	qq_vars_var_duplu(asu64(R1));
L2271:
	return;
}

static void qq_host_pch_gethash(u64 a, u64 result) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	asi64(R1) = qq_vars_var_gethashvalue(asu64(R1));
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_pch_makeempty(u64 a, u64 result) {
    u64 R1, R2, R3, R4; 
	u64 p;
	i64 t;
	R1 = (u64)&qq_tables_ttbasetype;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	asi64(R1) = t;
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L2275;
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	t = asi64(R1);
L2275:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asi64(R1) = t;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L2277;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2278;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2279;
	goto L2280;
L2277:
	asu64(R1) = result;
	asu64(R2) = p;
	R3 = 6;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	qq_lists_var_empty_list(asi64(R2), asu64(R1));
	goto L2273;
	goto L2276;
L2278:
	asu64(R1) = qq_strings_emptystring;
	p = asu64(R1);
	asu64(R1) = p;
	(*tou32p(R1)) += 1;
	goto L2276;
L2279:
	asu64(R1) = result;
	asu64(R2) = p;
	R3 = 4;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 0;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	asu64(R3) = p;
	R4 = 6;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	asi64(R4) = t;
	qq_arrays_var_empty_array(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	goto L2273;
	goto L2276;
L2280:
	asi64(R1) = t;
	R2 = tou64("makeempty?");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L2276:
	asi64(R1) = t;
	R2 = 256;
	asi64(R1) |= asi64(R2);
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = result;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L2273:
	return;
}

static void qq_host_pch_$infinity(u64 dest) {
    u64 R1; 
	asu64(R1) = dest;
	qq_decimal_var_setinf(asu64(R1));
	return;
}

static void qq_host_pch_$nan(u64 dest) {
    u64 R1; 
	asu64(R1) = dest;
	qq_decimal_var_setnan(asu64(R1));
	return;
}

static void qq_host_setcmdparam(i64 index, u64 s) {
    u64 R1, R2, R3; 
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2285;
	asi64(R1) = index;
	qq_decls_nqparams = asi64(R1);
	goto L2284;
L2285:
	asi64(R1) = index;
	R2 = 32;
	if (asi64(R1) > asi64(R2)) goto L2286;
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&qq_decls_qparamtable;
	asi64(R3) = index;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = index;
	R2 = (u64)&qq_decls_nqparams;
    *toi64p(R2) = Max(*toi64p(R2), asi64(R1));
L2286:
L2284:
	return;
}

static void qq_host_pch_$nprocs(u64 result) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = qq_decls_nproclist;
	asu64(R2) = result;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_host_initprocrefs() {
    u64 R1, R2, R3; 
	u64 pp;
	i64 i;
	asi64(R1) = qq_host_initprocrefs_oldnprocs;
	asi64(R2) = qq_decls_nproclist;
	if (asi64(R1) != asi64(R2)) goto L2290;
	goto L2288;
L2290:
	asi64(R1) = qq_decls_nproclist;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	qq_host_procrefs = asu64(R1);
	asu64(R1) = qq_decls_proclist;
	pp = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nproclist;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2293;
L2291:
	asu64(R1) = pp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = qq_host_procrefs;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pp = asu64(R1);
	i += 1; if (i <= qq_decls_nproclist) goto L2291;
L2293:
	asi64(R1) = qq_decls_nproclist;
	qq_host_initprocrefs_oldnprocs = asi64(R1);
L2288:
	return;
}

static void qq_host_pch_$procname(u64 a, u64 result) {
    u64 R1, R2, R3, R4; 
	i64 n;
	R1 = -999999;
	R2 = 1;
	asu64(R3) = a;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	qq_host_initprocrefs();
	R1 = 0;
	asu64(R2) = result;
	asu64(R3) = qq_host_procrefs;
	asi64(R4) = n;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_strings_var_make_string(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_host_pch_$procref(u64 a, u64 result) {
    u64 R1, R2, R3; 
	i64 n;
	u64 pp;
	R1 = -999999;
	R2 = 1;
	asu64(R3) = a;
	asi64(R1) = qq_host_checkparam(asu64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	qq_host_initprocrefs();
	R1 = 17;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = qq_host_procrefs;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = result;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_lex_lexreadtoken() {
    u64 R1, R2, R3, R4; 
	i64 c;
	i64 csum;
	i64 hsum;
	i64 commentseen;
	u64 pstart;
	u64 pnext;
	u64 p;
	u64 ss;
	R1 = 0;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2297:
	asu64(R1) = qq_lex_lxsptr;
	qq_lex_lxstart = asu64(R1);
	R1 = (u64)&qq_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 0: case 26: goto L2419;
	case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 11: case 12: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 27: case 28: case 29: case 30: case 31: goto L2300;
	case 9: case 32: goto L2416;
	case 10: goto L2418;
	case 13: goto L2417;
	case 33: case 35: goto L2326;
	case 34: goto L2414;
	case 36: case 95: case 97: case 98: case 99: case 100: case 101: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 117: case 118: case 119: case 120: case 121: case 122: goto L2301;
	case 37: goto L2392;
	case 38: goto L2409;
	case 39: goto L2413;
	case 40: goto L2372;
	case 41: goto L2373;
	case 42: goto L2388;
	case 43: goto L2380;
	case 44: goto L2361;
	case 45: goto L2383;
	case 46: goto L2353;
	case 47: goto L2391;
	case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L2317;
	case 58: goto L2363;
	case 59: goto L2362;
	case 60: goto L2398;
	case 61: goto L2393;
	case 62: goto L2404;
	case 63: goto L2379;
	case 64: goto L2378;
	case 65: case 66: case 67: case 68: case 69: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: goto L2309;
	case 70: goto L2314;
	case 91: goto L2374;
	case 92: goto L2334;
	case 93: goto L2375;
	case 94: goto L2377;
	case 96: goto L2415;
	case 102: goto L2311;
	case 123: goto L2351;
	case 124: goto L2376;
	case 125: goto L2352;
	default: goto L2300;
    };
// SWITCH
L2301:
// qq_lex.lexreadtoken.dolower:
L2302:
	asu64(R1) = qq_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
// qq_lex.lexreadtoken.doname:
L2303:
	R1 = (u64)&qq_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	hsum = asi64(R1);
L2304:
	R1 = (u64)&qq_lex_namemap;
	R2 = (u64)&qq_lex_lxsptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	R3 = R2;
	c = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2306;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2307;
	goto L2308;
L2306:
	asi64(R1) = hsum;
	R2 = 4;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	hsum = asi64(R1);
	goto L2304;
L2307:
	asi64(R1) = c;
	R2 = 32;
	asu64(R1) += asu64(R2);
	asu64(R2) = qq_lex_lxsptr;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = hsum;
	R2 = 4;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 32;
	asi64(R1) += asi64(R2);
	hsum = asi64(R1);
	goto L2304;
L2308:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2305;
	goto L2304;
L2305:
	asi64(R1) = hsum;
	R2 = 5;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	R2 = 32767;
	asi64(R1) &= asi64(R2);
	asu64(R2) = qq_lex_lxsptr;
	R3 = (u64)&qq_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R2) -= asi64(R3);
	R3 = (u64)&qq_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R1) = qq_lex_lookup(asu64(R3), asi64(R2), asi64(R1));
	goto L2296;
	goto L2297;
L2309:
// qq_lex.lexreadtoken.doupper:
L2310:
	asu64(R1) = qq_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 32;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*tou8p(R2) += asu8(R1);
	goto L2303;
	goto L2297;
L2311:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L2313;
	goto L2302;
L2313:
	qq_lex_readrawstring();
	goto L2296;
	goto L2297;
L2314:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L2316;
	goto L2310;
L2316:
	qq_lex_readrawstring();
	goto L2296;
	goto L2297;
L2317:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 41;
	if (asu64(R1) == asu64(R2)) goto L2319;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L2319;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L2319;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L2319;
	R2 = 120;
	if (asu64(R1) == asu64(R2)) goto L2320;
	R2 = 88;
	if (asu64(R1) == asu64(R2)) goto L2320;
	goto L2321;
L2319:
	R1 = 63;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = qq_lex_lxstart;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 48;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L2318;
L2320:
	asu64(R1) = qq_lex_lxstart;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) == asu64(R2)) goto L2323;
	R2 = 50;
	if (asu64(R1) == asu64(R2)) goto L2324;
	goto L2325;
L2323:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	qq_lex_readhex();
	goto L2322;
L2324:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	qq_lex_readbin();
	goto L2322;
L2325:
	R1 = tou64("Bad base");
	qq_lib_lxerror(asu64(R1));
L2322:
	goto L2318;
L2321:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	qq_lex_readdec();
L2318:
	goto L2296;
	goto L2297;
L2326:
// qq_lex.lexreadtoken.docomment:
L2328:
	R1 = (u64)&qq_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L2330;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L2331;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L2332;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2332;
	goto L2333;
L2330:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&qq_lex_lxlineno;
	(*toi64p(R1)) += 1;
	goto L2329;
	goto L2328;
L2331:
	R1 = (u64)&qq_lex_lxlineno;
	(*toi64p(R1)) += 1;
	goto L2329;
	goto L2328;
L2332:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2329;
	goto L2328;
L2333:
	goto L2328;
L2329:
	R1 = 61;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2296;
	goto L2297;
L2334:
	R1 = 0;
	commentseen = asi64(R1);
L2335:
	R1 = (u64)&qq_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L2337;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L2338;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L2339;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L2339;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L2340;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L2340;
	R2 = 33;
	if (asu64(R1) == asu64(R2)) goto L2341;
	goto L2342;
L2337:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&qq_lex_lxlineno;
	(*toi64p(R1)) += 1;
	goto L2336;
	goto L2335;
L2338:
	R1 = (u64)&qq_lex_lxlineno;
	(*toi64p(R1)) += 1;
	goto L2336;
	goto L2335;
L2339:
	R1 = 62;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2296;
	goto L2335;
L2340:
	goto L2335;
L2341:
	R1 = 1;
	commentseen = asi64(R1);
	goto L2335;
L2342:
	asi64(R1) = commentseen;
	if (asi64(R1)) goto L2344;
	R1 = tou64("\\ not followed by eol");
	qq_lib_lxerror(asu64(R1));
L2344:
	goto L2335;
L2336:
L2345:
	R1 = (u64)&qq_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L2347;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L2348;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L2349;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L2349;
	goto L2350;
L2347:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&qq_lex_lxlineno;
	(*toi64p(R1)) += 1;
	goto L2345;
L2348:
	R1 = (u64)&qq_lex_lxlineno;
	(*toi64p(R1)) += 1;
	goto L2345;
L2349:
	goto L2345;
L2350:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2346;
	goto L2345;
L2346:
	goto L2297;
L2351:
	R1 = 13;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2296;
	goto L2297;
L2352:
	R1 = 14;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2296;
	goto L2297;
L2353:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L2355;
	goto L2356;
L2355:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L2358;
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 21;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2357;
L2358:
	R1 = 20;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 87;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2357:
	goto L2296;
	goto L2354;
L2356:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L2360;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L2360;
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	qq_lex_readreal();
	goto L2296;
	goto L2359;
L2360:
	R1 = 2;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2296;
L2359:
L2354:
	goto L2297;
L2361:
	R1 = 3;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2296;
	goto L2297;
L2362:
	R1 = 4;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2296;
	goto L2297;
L2363:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L2365;
	R2 = 58;
	if (asu64(R1) == asu64(R2)) goto L2366;
	goto L2367;
L2365:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 6;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2364;
L2366:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L2369;
	goto L2370;
L2369:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 6;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2368;
L2370:
	goto L2371;
L2368:
	goto L2364;
L2367:
	R1 = 5;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2364:
	goto L2296;
	goto L2297;
L2372:
	R1 = 9;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2296;
	goto L2297;
L2373:
	R1 = 10;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2296;
	goto L2297;
L2374:
	R1 = 11;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2296;
	goto L2297;
L2375:
	R1 = 12;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2296;
	goto L2297;
L2376:
	R1 = 16;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2296;
	goto L2297;
L2377:
	R1 = 15;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2296;
	goto L2297;
L2378:
	R1 = 17;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2296;
	goto L2297;
L2379:
	R1 = 18;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2296;
	goto L2297;
L2380:
	R1 = 22;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 101;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) != asu64(R2)) goto L2382;
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 60;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2382:
	goto L2296;
	goto L2297;
L2383:
	R1 = 23;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 102;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L2385;
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L2386;
	goto L2387;
L2385:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 60;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2384;
L2386:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 8;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2384;
L2387:
L2384:
	goto L2296;
	goto L2297;
L2388:
	R1 = 24;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 103;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 42;
	if (asu64(R1) != asu64(R2)) goto L2390;
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 41;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 121;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2390:
	goto L2296;
	goto L2297;
L2391:
	R1 = 25;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 104;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2296;
	goto L2297;
L2392:
	R1 = 26;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 105;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2296;
	goto L2297;
L2393:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L2395;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L2396;
	goto L2397;
L2395:
	R1 = 7;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L2394;
L2396:
	R1 = 42;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 120;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L2394;
L2397:
	R1 = 43;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2394:
	goto L2296;
	goto L2297;
L2398:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L2400;
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L2401;
	R2 = 60;
	if (asu64(R1) == asu64(R2)) goto L2402;
	goto L2403;
L2400:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 46;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2399;
L2401:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 44;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2399;
L2402:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 34;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 111;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2399;
L2403:
	R1 = 45;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 2;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2399:
	goto L2296;
	goto L2297;
L2404:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L2406;
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L2407;
	goto L2408;
L2406:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 47;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2405;
L2407:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 35;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 112;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2405;
L2408:
	R1 = 48;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 5;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2405:
	goto L2296;
	goto L2297;
L2409:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 38;
	if (asu64(R1) == asu64(R2)) goto L2411;
	goto L2412;
L2411:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 38;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 118;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2410;
L2412:
	R1 = 19;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2410:
	goto L2296;
	goto L2297;
L2413:
	R1 = 39;
	qq_lex_lxreadstring(asi64(R1));
	goto L2296;
	goto L2297;
L2414:
	R1 = 34;
	qq_lex_lxreadstring(asi64(R1));
	goto L2296;
	goto L2297;
L2415:
	qq_lex_readrawxname();
	goto L2296;
	goto L2297;
L2416:
	goto L2297;
L2417:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&qq_lex_lxlineno;
	(*toi64p(R1)) += 1;
	R1 = 61;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2296;
	goto L2297;
L2418:
	R1 = 61;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&qq_lex_lxlineno;
	(*toi64p(R1)) += 1;
	goto L2296;
	goto L2297;
L2419:
	R1 = 62;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2296;
	goto L2297;
L2300:
	asu64(R1) = qq_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 226;
	if (asi64(R1) != asi64(R2)) goto L2421;
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 136;
	if (asi64(R1) != asi64(R2)) goto L2421;
	asu64(R1) = qq_lex_lxsptr;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 154;
	if (asi64(R1) != asi64(R2)) goto L2421;
	R1 = 2;
	R2 = (u64)&qq_lex_lxsptr;
	*tou64p(R2) += asu64(R1);
	R1 = 55;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2296;
L2421:
	asi64(R1) = c;
	R2 = 128;
	if (asi64(R1) < asi64(R2)) goto L2423;
	goto L2303;
L2423:
// qq_lex.lexreadtoken.error:
L2371:
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = c;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L2296;
	goto L2297;
L2296:
	return;
}

static void qq_lex_lxreadstring(i64 termchar) {
    u64 R1, R2, R3, R4; 
	u64 s;
	u64 t;
	i64 c;
	i64 d;
	i64 length;
	i64 hasescape;
	i64 a;
	i64 n;
	u64 str;
	i64 pass;
	asi64(R1) = termchar;
	R2 = 34;
	if (asi64(R1) != asi64(R2)) goto L2426;
	R1 = 67;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2425;
L2426:
	R1 = 66;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2425:
	R1 = 0;
	length = asi64(R1);
	R1 = 0;
	hasescape = asi64(R1);
	R1 = 0;
	t = asu64(R1);
	R1 = 1;
	pass = asi64(R1);
L2427:
	asu64(R1) = qq_lex_lxsptr;
	s = asu64(R1);
L2430:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L2433;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L2434;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L2434;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L2435;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L2435;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2435;
	goto L2436;
L2433:
	R1 = 1;
	hasescape = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L2438;
	asi64(R1) = c;
	R2 = 90;
	if (asi64(R1) > asi64(R2)) goto L2438;
	R1 = 32;
	R2 = (u64)&c;
	*toi64p(R2) += asi64(R1);
L2438:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) == asi64(R2)) goto L2440;
	R2 = 98;
	if (asi64(R1) == asi64(R2)) goto L2441;
	R2 = 99;
	if (asi64(R1) == asi64(R2)) goto L2442;
	R2 = 114;
	if (asi64(R1) == asi64(R2)) goto L2442;
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L2443;
	R2 = 102;
	if (asi64(R1) == asi64(R2)) goto L2444;
	R2 = 104;
	if (asi64(R1) == asi64(R2)) goto L2445;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L2446;
	R2 = 110;
	if (asi64(R1) == asi64(R2)) goto L2446;
	R2 = 116;
	if (asi64(R1) == asi64(R2)) goto L2447;
	R2 = 117;
	if (asi64(R1) == asi64(R2)) goto L2448;
	R2 = 118;
	if (asi64(R1) == asi64(R2)) goto L2448;
	R2 = 119;
	if (asi64(R1) == asi64(R2)) goto L2449;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L2450;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L2451;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L2452;
	goto L2453;
L2440:
	R1 = 7;
	c = asi64(R1);
	goto L2439;
L2441:
	R1 = 8;
	c = asi64(R1);
	goto L2439;
L2442:
	R1 = 13;
	c = asi64(R1);
	goto L2439;
L2443:
	R1 = 27;
	c = asi64(R1);
	goto L2439;
L2444:
	R1 = 12;
	c = asi64(R1);
	goto L2439;
L2445:
	goto L2455;
L2454:
	R1 = 1;
	R2 = 2;
	R3 = (u64)&s;
	asi64(R1) = qq_lex_readhexcode(asu64(R3), asi64(R2), asi64(R1));
	c = asi64(R1);
	asi64(R1) = pass;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2458;
	asi64(R1) = c;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L2458:
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
L2455:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) != asu64(R2)) goto L2454;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&t;
	(*tou64p(R1)) -=1;
	goto L2439;
L2446:
	R1 = 10;
	c = asi64(R1);
	goto L2439;
L2447:
	R1 = 9;
	c = asi64(R1);
	goto L2439;
L2448:
	asi64(R1) = pass;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2460;
	asu64(R1) = t;
	goto L2459;
L2460:
	R1 = 0;
L2459:
	R2 = 0;
	asi64(R3) = c;
	R4 = 117;
	if (asi64(R3) != asi64(R4)) goto L2462;
	R3 = 4;
	goto L2461;
L2462:
	R3 = 6;
L2461:
	R4 = (u64)&s;
	asi64(R2) = qq_lex_readhexcode(asu64(R4), asi64(R3), asi64(R2));
	asi64(R1) = qq_lex_getutf8(asi64(R2), asu64(R1));
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	goto L2430;
	goto L2439;
L2449:
	asi64(R1) = pass;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2464;
	R1 = 13;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L2464:
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	R1 = 10;
	c = asi64(R1);
	goto L2439;
L2450:
	R1 = 0;
	R2 = 2;
	R3 = (u64)&s;
	asi64(R1) = qq_lex_readhexcode(asu64(R3), asi64(R2), asi64(R1));
	c = asi64(R1);
	goto L2439;
L2451:
	R1 = 16;
	c = asi64(R1);
	goto L2439;
L2452:
	R1 = 0;
	c = asi64(R1);
	goto L2439;
L2453:
	asi64(R1) = c;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L2466;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L2467;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L2468;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L2469;
	goto L2470;
L2466:
	R1 = 34;
	c = asi64(R1);
	goto L2465;
L2467:
	R1 = 92;
	c = asi64(R1);
	goto L2465;
L2468:
	R1 = 39;
	c = asi64(R1);
	goto L2465;
L2469:
	R1 = 0;
	c = asi64(R1);
	goto L2465;
L2470:
	asi64(R1) = c;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&str;
	R2 = tou64("Unknown string escape: #");
	qq_lex_lxerror_s(asu64(R2), asu64(R1));
L2465:
L2439:
	goto L2432;
L2434:
	asi64(R1) = c;
	asi64(R2) = termchar;
	if (asi64(R1) != asi64(R2)) goto L2472;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	asi64(R2) = c;
	if (asi64(R1) != asi64(R2)) goto L2474;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L2473;
L2474:
	goto L2431;
L2473:
L2472:
	R1 = 1;
	hasescape = asi64(R1);
	goto L2432;
L2435:
	R1 = tou64("String not terminated");
	qq_lib_lxerror(asu64(R1));
	goto L2432;
L2436:
L2432:
	asi64(R1) = pass;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2476;
	asi64(R1) = c;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L2476:
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	goto L2430;
L2431:
	asi64(R1) = pass;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2478;
	asu64(R1) = t;
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&qq_decls_nextlx;
	R3 = 14;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = hasescape;
	if (!asi64(R1)) goto L2480;
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	t = asu64(R2);
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L2479;
L2480:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2481;
	R1 = tou64("");
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = s;
	qq_lex_lxsptr = asu64(R1);
	goto L2424;
	goto L2479;
L2481:
	asi64(R1) = length;
	asu64(R2) = qq_lex_lxsptr;
	asu64(R1) = mlib_pcm_copyheapstringn(asu64(R2), asi64(R1));
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = s;
	qq_lex_lxsptr = asu64(R1);
	goto L2424;
L2479:
	goto L2477;
L2478:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = s;
	qq_lex_lxsptr = asu64(R1);
L2477:
	pass += 1; if (pass <= 2) goto L2427;
L2424:
	return;
}

static i64 qq_lex_readhexcode(u64 s, i64 n, i64 sp) {
    u64 R1, R2; 
	i64 a;
	i64 c;
	i64 i;
	R1 = 0;
	a = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2485;
L2483:
	asi64(R1) = sp;
	if (!asi64(R1)) goto L2487;
	asi64(R1) = i;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L2487;
L2488:
	asu64(R1) = s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L2488;
	goto L2486;
L2487:
	asu64(R1) = s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
L2486:
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L2492;
	R2 = 70;
	if (asi64(R1) > asi64(R2)) goto L2492;
	asi64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 65;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asi64(R1) += asi64(R2);
	a = asi64(R1);
	goto L2491;
L2492:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L2493;
	R2 = 102;
	if (asi64(R1) > asi64(R2)) goto L2493;
	asi64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 97;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asi64(R1) += asi64(R2);
	a = asi64(R1);
	goto L2491;
L2493:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L2494;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L2494;
	asi64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	a = asi64(R1);
	goto L2491;
L2494:
	R1 = tou64("Bad hex digit");
	qq_lib_lxerror(asu64(R1));
L2491:
	i += 1; if (i <= n) goto L2483;
L2485:
	asi64(R1) = a;
	goto L2482;
L2482:
	return asi64(R1);
}

static i64 qq_lex_getutf8(i64 c, u64 s) {
    u64 R1, R2, R3, R4; 
	i64 n;
	struct $B3 str;
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2497;
	R1 = (u64)&str;
	s = asu64(R1);
L2497:
	asi64(R1) = c;
	R2 = 127;
	if (asi64(R1) > asi64(R2)) goto L2499;
	R1 = 1;
	n = asi64(R1);
	asi64(R1) = c;
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2498;
L2499:
	asi64(R1) = c;
	R2 = 2047;
	if (asi64(R1) > asi64(R2)) goto L2500;
	R1 = 2;
	n = asi64(R1);
	R1 = 192;
	asi64(R2) = c;
	R3 = 6;
	R4 = 10;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 0;
	R4 = 5;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2498;
L2500:
	asi64(R1) = c;
	R2 = 65535;
	if (asi64(R1) > asi64(R2)) goto L2501;
	R1 = 3;
	n = asi64(R1);
	R1 = 224;
	asi64(R2) = c;
	R3 = 12;
	R4 = 15;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 6;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 0;
	R4 = 5;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2498;
L2501:
	asi64(R1) = c;
	R2 = 1114111;
	if (asi64(R1) > asi64(R2)) goto L2502;
	R1 = 4;
	n = asi64(R1);
	R1 = 240;
	asi64(R2) = c;
	R3 = 18;
	R4 = 20;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 12;
	R4 = 17;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 6;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 0;
	R4 = 5;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2498;
L2502:
	R1 = 0;
	n = asi64(R1);
L2498:
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = n;
	goto L2495;
L2495:
	return asi64(R1);
}

static void qq_lex_lexinit() {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 4194304;
	R2 = 0;
	R3 = (u64)&qq_lex_hashtable;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = (u64)&qq_lex_hashtable;
	R2 = 4194176;
	R1 += (i64)R2;
	qq_lex_hashtablelast = asu64(R1);
	qq_lex_inithashtable();
	return;
}

static void qq_lex_readrawstring() {
    u64 R1, R2, R3; 
	u64 pstart;
	i64 length;
	R1 = 67;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&qq_lex_lxsptr;
	asu64(R1) = *(tou64p(R1)) += 1;
	pstart = asu64(R1);
	R1 = 0;
	length = asi64(R1);
L2505:
	R1 = (u64)&qq_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L2507;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L2508;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L2508;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L2508;
	goto L2509;
L2507:
	goto L2506;
	goto L2505;
L2508:
	R1 = tou64("Raw string not terminated");
	qq_lib_lxerror(asu64(R1));
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2506;
	goto L2505;
L2509:
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	goto L2505;
L2506:
	asi64(R1) = length;
	qq_lex_nextlxlength = asi64(R1);
	asi64(R1) = length;
	asu64(R2) = pstart;
	asu64(R1) = mlib_pcm_copyheapstringn(asu64(R2), asi64(R1));
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static i64 qq_lex_lookup(u64 name, i64 length, i64 hashindex) {
    u64 R1, R2, R3, R4; 
	i64 j;
	i64 wrapped;
	i64 n;
	u64 d;
	u64 s;
	R1 = (u64)&qq_lex_hashtable;
	asi64(R2) = hashindex;
	R1 += (i64)R2*128;
	d = asu64(R1);
	R1 = 0;
	wrapped = asi64(R1);
L2511:
	asu64(R1) = d;
	R2 = 126;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	n = asi64(R2);
	asi64(R2) = length;
	if (asi64(R1) != asi64(R2)) goto L2514;
	asi64(R1) = n;
	asu64(R2) = name;
	asu64(R3) = d;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2514;
	asu64(R1) = d;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 123;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 112;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	goto L2510;
	goto L2513;
L2514:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2515;
	goto L2512;
L2515:
L2513:
	R1 = (u64)&d;
	asu64(R1) = *(tou64p(R1)) += 128;
	asu64(R2) = qq_lex_hashtablelast;
	if (asu64(R1) <= asu64(R2)) goto L2517;
	asi64(R1) = wrapped;
	if (!asi64(R1)) goto L2519;
	R1 = tou64("HASHTABLE FULL");
	mlib_abortprogram(asu64(R1));
L2519:
	R1 = 1;
	wrapped = asi64(R1);
	R1 = (u64)&qq_lex_hashtable;
	R2 = 0;
	R1 += (i64)R2;
	d = asu64(R1);
L2517:
	goto L2511;
L2512:
	asi64(R1) = length;
	asu64(R2) = name;
	asu64(R1) = mlib_pcm_copyheapstringn(asu64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = d;
	R3 = 126;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 69;
	asu64(R2) = d;
	R3 = 123;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 123;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 112;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	goto L2510;
L2510:
	return asi64(R1);
}

static i64 qq_lex_gethashvaluez(u64 s) {
    u64 R1, R2; 
	i64 c;
	i64 hsum;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2522;
	R1 = 0;
	goto L2520;
L2522:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	hsum = asi64(R1);
L2523:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2526;
	goto L2524;
L2526:
	asi64(R1) = hsum;
	R2 = 4;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	hsum = asi64(R1);
	goto L2523;
L2524:
	asi64(R1) = hsum;
	R2 = 5;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	R2 = 32767;
	asi64(R1) &= asi64(R2);
	goto L2520;
L2520:
	return asi64(R1);
}

static void qq_lex_start() {
    u64 R1, R2, R3; 
	i64 av_1;
	i64 c;
	R1 = 0;
	c = asi64(R1);
	R1 = 255;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L2530;
L2528:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L2534;
	R2 = 122;
	if (asi64(R1) <= asi64(R2)) goto L2533;
L2534:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L2535;
	R2 = 57;
	if (asi64(R1) <= asi64(R2)) goto L2533;
L2535:
	asi64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L2533;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L2533;
	asi64(R1) = c;
	R2 = 128;
	if (asi64(R1) < asi64(R2)) goto L2532;
	R2 = 255;
	if (asi64(R1) > asi64(R2)) goto L2532;
L2533:
	R1 = 1;
	R2 = (u64)&qq_lex_namemap;
	asi64(R3) = c;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2531;
L2532:
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L2536;
	R2 = 90;
	if (asi64(R1) > asi64(R2)) goto L2536;
	R1 = 2;
	R2 = (u64)&qq_lex_namemap;
	asi64(R3) = c;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2536:
L2531:
	c += 1; if (c <= av_1) goto L2528;
L2530:
	return;
}

static void qq_lex_inithashtable() {
    u64 R1, R2, R3, R4; 
	i64 i;
	u64 name;
	i64 av_1;
	i64 av_2;
	R1 = 1;
	i = asi64(R1);
	R1 = 188;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2540;
L2538:
	R1 = (u64)&qq_tables_stsubcodes;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&qq_tables_stsymbols;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	R3 = (u64)&qq_tables_stnames;
	asi64(R4) = i;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	qq_lex_addstname(asu64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= av_1) goto L2538;
L2540:
	R1 = 1;
	i = asi64(R1);
	R1 = 59;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2543;
L2541:
	R1 = (u64)&qq_tables_hostinternal;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2545;
	R1 = (u64)&qq_tables_hostfnnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 2;
	R1 += (i64)R2;
	name = asu64(R1);
	asi64(R1) = i;
	R2 = 129;
	asu64(R3) = name;
	qq_lex_addstname(asu64(R3), asi64(R2), asi64(R1));
L2545:
	i += 1; if (i <= av_2) goto L2541;
L2543:
	return;
}

static void qq_lex_addstname(u64 name, i64 symbol, i64 subcode) {
    u64 R1, R2, R3; 
	asu64(R1) = name;
	asi64(R1) = qq_lex_gethashvaluez(asu64(R1));
	asu64(R2) = name;
	asi64(R2) = strlen(asu64(R2));
	asu64(R3) = name;
	asi64(R1) = qq_lex_lookup(asu64(R3), asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L2548;
	msysc_m$print_startcon();
	asu64(R1) = name;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Dupl ST entry");
	mlib_abortprogram(asu64(R1));
L2548:
	asi64(R1) = symbol;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 123;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = subcode;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 112;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	return;
}

static void qq_lex_startlex(u64 pm) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = pm;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = R1;
	qq_lex_lxsptr = asu64(R2);
	qq_lex_lxsource = asu64(R1);
	R1 = 4;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pm;
	R2 = 46;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = tou64(toi16(R1));
	R2 = (u64)&qq_decls_nextlx;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 24;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 1;
	qq_lex_lxlineno = asi64(R1);
	return;
}

static u64 qq_lex_addnamestr(u64 name) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	struct $B3 oldlx;
	u64 symptr;
	(R1_B3) = qq_decls_nextlx;
	oldlx = (R1_B3);
	asu64(R1) = name;
	asi64(R1) = strlen(asu64(R1));
	qq_lex_nextlxlength = asi64(R1);
	asi64(R1) = qq_lex_nextlxlength;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = qq_lex_nextlxlength;
	R2 = 1;
	asu64(R1) += asu64(R2);
	asu64(R2) = name;
	R3 = (u64)&qq_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = name;
	asi64(R1) = qq_lex_gethashvaluez(asu64(R1));
	asi64(R2) = qq_lex_nextlxlength;
	R3 = (u64)&qq_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R1) = qq_lex_lookup(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&qq_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	symptr = asu64(R1);
	(R1_B3) = oldlx;
	qq_decls_nextlx = (R1_B3);
	asu64(R1) = symptr;
	goto L2550;
L2550:
	return asu64(R1);
}

static void qq_lex_ps(u64 caption) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":::");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&qq_decls_lx;
	qq_show_printsymbol(asu64(R1));
	return;
}

static void qq_lex_psnext(u64 caption) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":##");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&qq_decls_nextlx;
	qq_show_printsymbol(asu64(R1));
	return;
}

static void qq_lex_lex() {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	i64 lineno;
	i64 n;
	i64 dir;
	i64 namelen;
	u64 p;
	u64 symptr;
	(R1_B3) = qq_decls_nextlx;
	qq_decls_lx = (R1_B3);
	asi64(R1) = qq_lex_lxlineno;
	R2 = (u64)&qq_decls_lx;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 23;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = qq_lex_nextlxlength;
	qq_lex_lxlength = asi64(R1);
// qq_lex.lex.reenter:
L2554:
	qq_lex_lexreadtoken();
// qq_lex.lex.reenter2:
L2555:
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L2557;
	R2 = 128;
	if (asi64(R1) == asi64(R2)) goto L2558;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L2559;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L2560;
	goto L2561;
L2557:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L2563;
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L2564;
	goto L2565;
L2563:
	R1 = (u64)&qq_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 112;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2567;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2568;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2569;
	goto L2570;
L2567:
	R1 = 1000000;
	R2 = (u64)&qq_decls_lx;
	*toi64p(R2) *= asi64(R1);
	goto L2566;
L2568:
	R1 = 1000000000;
	R2 = (u64)&qq_decls_lx;
	*toi64p(R2) *= asi64(R1);
	goto L2566;
L2569:
	R1 = 1000;
	R2 = (u64)&qq_decls_lx;
	*toi64p(R2) *= asi64(R1);
	goto L2566;
L2570:
	R1 = tou64("Can't do this unit index");
	qq_lib_lxerror(asu64(R1));
L2566:
	R1 = 1;
	R2 = (u64)&qq_decls_lx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2554;
	goto L2562;
L2564:
	R1 = tou64("unit symbol after float?");
	qq_lib_lxerror(asu64(R1));
	goto L2562;
L2565:
	R1 = 69;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2562:
	goto L2556;
L2558:
	R1 = (u64)&qq_decls_nextlx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2572;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2573;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2574;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2575;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2576;
	goto L2577;
L2572:
	R1 = 63;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2571;
L2573:
	R1 = 65;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = 3.141592653589793100e+000;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	R1 = 2;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2571;
L2574:
	R1 = 67;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = tou64("\t");
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	qq_lex_nextlxlength = asi64(R1);
	goto L2571;
L2575:
	R1 = 63;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2571;
L2576:
	R1 = 63;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2571;
L2577:
	R1 = tou64("sysconst?");
	qq_lib_lxerror(asu64(R1));
L2571:
	goto L2556;
L2559:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2579;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2579;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2579;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L2579;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2579;
	goto L2580;
L2579:
	qq_lex_lexreadtoken();
	goto L2555;
	goto L2554;
	goto L2578;
L2580:
	R1 = (u64)&qq_tables_binopset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2582;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L2582;
	qq_lex_lexreadtoken();
	goto L2555;
L2582:
L2578:
	R1 = 4;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2556;
L2560:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 49;
	if (asi64(R1) != asi64(R2)) goto L2584;
	R1 = 39;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_lx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2554;
L2584:
	goto L2556;
L2561:
L2556:
	return;
}

static void qq_lex_lxerror_s(u64 mess, u64 a) {
    u64 R1; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	qq_lib_lxerror(asu64(R1));
	return;
}

static void qq_lex_makedecimal(u64 s, i64 length, i64 base) {
    u64 R1, R2, R3; 
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L2588;
	R1 = tou64("MAKEDECIMAL/16/2");
	qq_lib_lxerror(asu64(R1));
L2588:
	R1 = 64;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R1) = mlib_pcm_copyheapstringn(asu64(R2), asi64(R1));
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = length;
	qq_lex_nextlxlength = asi64(R1);
	return;
}

static void qq_lex_readdec() {
    u64 R1, R2, R3; 
	i64 c;
	u64 dest;
	u64 destend;
	u64 pstart;
	i64 islong;
	i64 length;
	struct $B65 str;
	u64 a;
	i64 av_1;
	R1 = 0;
	islong = asi64(R1);
	asu64(R1) = qq_lex_lxsptr;
	pstart = asu64(R1);
	R1 = (u64)&str;
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1024;
	R1 += (i64)R2;
	R2 = 10;
	R1 -= (i64)R2;
	destend = asu64(R1);
	R1 = 0;
	a = asu64(R1);
L2590:
	R1 = (u64)&qq_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L2593;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L2593;
	asu64(R1) = a;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	a = asu64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2592;
L2593:
	asi64(R1) = c;
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L2595;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L2595;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L2596;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L2597;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L2597;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L2598;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L2598;
	R2 = 98;
	if (asi64(R1) == asi64(R2)) goto L2599;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L2599;
	goto L2600;
L2595:
	asu64(R1) = pstart;
	qq_lex_lxsptr = asu64(R1);
	qq_lex_readreal();
	goto L2589;
	goto L2594;
L2596:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L2602;
	asu64(R1) = pstart;
	qq_lex_lxsptr = asu64(R1);
	qq_lex_readreal();
	goto L2589;
L2602:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2591;
	goto L2594;
L2597:
	goto L2594;
L2598:
	R1 = 0;
	asu64(R2) = dest;
	*tou8p(R2) = asu8(R1);
	R1 = 10;
	asu64(R2) = dest;
	R3 = (u64)&str;
	asi64(R2) -= asi64(R3);
	R3 = (u64)&str;
	qq_lex_makedecimal(asu64(R3), asi64(R2), asi64(R1));
	goto L2589;
	goto L2594;
L2599:
	asu64(R1) = dest;
	R2 = (u64)&str;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 64;
	if (asi64(R1) <= asi64(R2)) goto L2604;
	R1 = tou64("bin overflow");
	qq_lib_lxerror(asu64(R1));
L2604:
	R1 = (u64)&str;
	dest = asu64(R1);
	R1 = 0;
	a = asu64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2607;
L2605:
	asu64(R1) = dest;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 50;
	if (asu64(R1) < asu64(R2)) goto L2609;
	R1 = tou64("bad bin digit");
	qq_lib_lxerror(asu64(R1));
L2609:
	asu64(R1) = a;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	a = asu64(R1);
	if (--asi64(av_1)) goto L2605;
L2607:
	goto L2610;
	goto L2594;
L2600:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2591;
L2594:
L2592:
	asu64(R1) = dest;
	asu64(R2) = destend;
	if (asu64(R1) < asu64(R2)) goto L2612;
	R1 = tou64("Numlit too long");
	qq_lib_lxerror(asu64(R1));
L2612:
	goto L2590;
L2591:
	asu64(R1) = dest;
	R2 = (u64)&str;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 20;
	if (asi64(R1) > asi64(R2)) goto L2615;
	asi64(R1) = length;
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L2614;
	R1 = 20;
	asu64(R2) = qq_lex_u64maxstr;
	R3 = (u64)&str;
	asi32(R1) = strncmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2614;
L2615:
	R1 = 10;
	asi64(R2) = length;
	R3 = (u64)&str;
	qq_lex_makedecimal(asu64(R3), asi64(R2), asi64(R1));
	goto L2589;
L2614:
// qq_lex.readdec.finish:
L2610:
	R1 = 63;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2589:
	return;
}

static void qq_lex_readhex() {
    u64 R1, R2, R3; 
	i64 c;
	u64 dest;
	u64 destend;
	u64 pstart;
	i64 length;
	struct $B65 str;
	u64 a;
	asu64(R1) = qq_lex_lxsptr;
	pstart = asu64(R1);
	R1 = (u64)&str;
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1024;
	R1 += (i64)R2;
	R2 = 10;
	R1 -= (i64)R2;
	destend = asu64(R1);
	R1 = 0;
	a = asu64(R1);
L2617:
	R1 = (u64)&qq_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L2620;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L2620;
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	a = asu64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2619;
L2620:
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L2621;
	R2 = 70;
	if (asi64(R1) > asi64(R2)) goto L2621;
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 65;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	a = asu64(R1);
	goto L2619;
L2621:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L2622;
	R2 = 102;
	if (asi64(R1) > asi64(R2)) goto L2622;
	asi64(R1) = c;
	R2 = 32;
	asu64(R1) -= asu64(R2);
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 97;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	a = asu64(R1);
	goto L2619;
L2622:
	asi64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L2624;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L2624;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L2625;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L2625;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L2626;
	goto L2627;
L2624:
	goto L2623;
L2625:
	R1 = 0;
	asu64(R2) = dest;
	*tou8p(R2) = asu8(R1);
	R1 = 16;
	asu64(R2) = dest;
	R3 = (u64)&str;
	asi64(R2) -= asi64(R3);
	R3 = (u64)&str;
	qq_lex_makedecimal(asu64(R3), asi64(R2), asi64(R1));
	goto L2616;
	goto L2623;
L2626:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2618;
	goto L2623;
L2627:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2618;
L2623:
L2619:
	asu64(R1) = dest;
	asu64(R2) = destend;
	if (asu64(R1) < asu64(R2)) goto L2629;
	R1 = tou64("Numlit too long");
	qq_lib_lxerror(asu64(R1));
L2629:
	goto L2617;
L2618:
	asu64(R1) = dest;
	R2 = (u64)&str;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 16;
	if (asi64(R1) <= asi64(R2)) goto L2631;
	R1 = 16;
	asi64(R2) = length;
	R3 = (u64)&str;
	qq_lex_makedecimal(asu64(R3), asi64(R2), asi64(R1));
	goto L2616;
L2631:
	R1 = 63;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2616:
	return;
}

static void qq_lex_readbin() {
    u64 R1, R2, R3; 
	i64 c;
	u64 dest;
	u64 destend;
	u64 pstart;
	i64 length;
	struct $B65 str;
	u64 a;
	asu64(R1) = qq_lex_lxsptr;
	pstart = asu64(R1);
	R1 = (u64)&str;
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1024;
	R1 += (i64)R2;
	R2 = 10;
	R1 -= (i64)R2;
	destend = asu64(R1);
	R1 = 0;
	a = asu64(R1);
L2633:
	R1 = (u64)&qq_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L2636;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L2636;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L2637;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L2637;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L2638;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L2638;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L2639;
	goto L2640;
L2636:
	asu64(R1) = a;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	a = asu64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2635;
L2637:
	goto L2635;
L2638:
	R1 = 0;
	asu64(R2) = dest;
	*tou8p(R2) = asu8(R1);
	R1 = 2;
	asu64(R2) = dest;
	R3 = (u64)&str;
	asi64(R2) -= asi64(R3);
	R3 = (u64)&str;
	qq_lex_makedecimal(asu64(R3), asi64(R2), asi64(R1));
	goto L2632;
	goto L2635;
L2639:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2634;
	goto L2635;
L2640:
	asi64(R1) = c;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L2642;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L2642;
	R1 = tou64("bin bad digit");
	qq_lib_lxerror(asu64(R1));
	goto L2641;
L2642:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2634;
L2641:
L2635:
	asu64(R1) = dest;
	asu64(R2) = destend;
	if (asu64(R1) < asu64(R2)) goto L2644;
	R1 = tou64("bin overflow");
	qq_lib_lxerror(asu64(R1));
L2644:
	goto L2633;
L2634:
	asu64(R1) = dest;
	R2 = (u64)&str;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 64;
	if (asi64(R1) <= asi64(R2)) goto L2646;
	R1 = 2;
	asi64(R2) = length;
	R3 = (u64)&str;
	qq_lex_makedecimal(asu64(R3), asi64(R2), asi64(R1));
	goto L2632;
L2646:
	R1 = 63;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2632:
	return;
}

static void qq_lex_readreal() {
    u64 R1, R2, R3; 
	i64 c;
	i64 n;
	i64 negexpon;
	i64 dotseen;
	i64 length;
	i64 fractlen;
	i64 expon;
	i64 expseen;
	r64 x;
	struct $B65 str;
	u64 dest;
	u64 destend;
	u64 pexpon;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 i;
	R1 = (u64)&str;
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1024;
	R1 += (i64)R2;
	R2 = 100;
	R1 -= (i64)R2;
	destend = asu64(R1);
	R1 = 0;
	R2 = R1;
	fractlen = asi64(R2);
	R2 = R1;
	expon = asi64(R2);
	R2 = R1;
	expseen = asi64(R2);
	R2 = R1;
	dotseen = asi64(R2);
	R2 = R1;
	negexpon = asi64(R2);
	length = asi64(R1);
L2648:
	R1 = (u64)&qq_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L2651;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L2651;
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	asi64(R1) = dotseen;
	if (!asi64(R1)) goto L2653;
	R1 = (u64)&fractlen;
	(*toi64p(R1)) += 1;
L2653:
	goto L2650;
L2651:
	asi64(R1) = c;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L2655;
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L2656;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L2656;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L2657;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L2657;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L2658;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L2658;
	goto L2659;
L2655:
	asi64(R1) = dotseen;
	if (!asi64(R1)) goto L2661;
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2649;
L2661:
	R1 = 1;
	dotseen = asi64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2654;
L2656:
	asi64(R1) = expseen;
	if (!asi64(R1)) goto L2663;
	R1 = tou64("double expon");
	qq_lib_lxerror(asu64(R1));
L2663:
	R1 = 1;
	expseen = asi64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2665;
L2664:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) += 1;
L2665:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L2664;
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L2669;
	R2 = 45;
	if (asi64(R1) != asi64(R2)) goto L2668;
L2669:
	asu64(R1) = qq_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) != asu64(R2)) goto L2671;
	R1 = 1;
	negexpon = asi64(R1);
L2671:
	R1 = (u64)&qq_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L2668:
	R1 = 0;
	expon = asi64(R1);
L2672:
	R1 = (u64)&qq_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L2675;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L2675;
	asi64(R1) = expon;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	expon = asi64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = dest;
	asu64(R2) = destend;
	if (asu64(R1) < asu64(R2)) goto L2677;
	R1 = tou64("expon?");
	qq_lib_lxerror(asu64(R1));
L2677:
	goto L2674;
L2675:
	asi64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L2679;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L2679;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L2680;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L2680;
	goto L2681;
L2679:
	goto L2678;
L2680:
	R1 = 0;
	asu64(R2) = dest;
	*tou8p(R2) = asu8(R1);
	R1 = 10;
	asu64(R2) = dest;
	R3 = (u64)&str;
	asi64(R2) -= asi64(R3);
	R3 = (u64)&str;
	qq_lex_makedecimal(asu64(R3), asi64(R2), asi64(R1));
	goto L2647;
	goto L2678;
L2681:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2649;
L2678:
L2674:
	goto L2672;
	goto L2654;
L2657:
	goto L2654;
L2658:
	R1 = 10;
	asu64(R2) = dest;
	R3 = (u64)&str;
	asi64(R2) -= asi64(R3);
	R3 = (u64)&str;
	qq_lex_makedecimal(asu64(R3), asi64(R2), asi64(R1));
	goto L2647;
	goto L2654;
L2659:
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2649;
L2654:
L2650:
	asu64(R1) = dest;
	asu64(R2) = destend;
	if (asu64(R1) < asu64(R2)) goto L2683;
	R1 = tou64("r64lit too long");
	qq_lib_lxerror(asu64(R1));
L2683:
	goto L2648;
L2649:
	R1 = 0;
	asu64(R2) = dest;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = negexpon;
	if (!asi64(R1)) goto L2685;
	asi64(R1) = expon;
	asi64(R1) = -asi64(R1);
	expon = asi64(R1);
L2685:
	asi64(R1) = fractlen;
	R2 = (u64)&expon;
	*toi64p(R2) -= asi64(R1);
	asr64(R1) = 0.000000000000000000e+000;
	x = asr64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = length;
	asi64(R2) = dotseen;
	asi64(R1) += asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2688;
L2686:
	R1 = (u64)&str;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L2690;
	asr64(R1) = x;
	asr64(R2) = 1.000000000000000000e+001;
	asr64(R1) *= asr64(R2);
	asi64(R2) = c;
	asr64(R2) = tor64(asi64(R2));
	asr64(R1) += asr64(R2);
	R2 = 48;
	asr64(R2) = tor64(asu64(R2));
	asr64(R1) -= asr64(R2);
	x = asr64(R1);
L2690:
	i += 1; if (i <= av_1) goto L2686;
L2688:
	asi64(R1) = expon;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L2692;
	asi64(R1) = expon;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2695;
L2693:
	asr64(R1) = 1.000000000000000000e+001;
	R2 = (u64)&x;
	*tor64p(R2) *= asr64(R1);
	if (--asi64(av_2)) goto L2693;
L2695:
	goto L2691;
L2692:
	asi64(R1) = expon;
	asi64(R1) = -asi64(R1);
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2698;
L2696:
	asr64(R1) = 1.000000000000000000e+001;
	R2 = (u64)&x;
	*tor64p(R2) /= asr64(R1);
	if (--asi64(av_3)) goto L2696;
L2698:
L2691:
	asr64(R1) = x;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	R1 = 65;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 2;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2647:
	return;
}

static void qq_lex_readrawxname() {
    u64 R1, R2, R3, R4; 
	i64 c;
	i64 hsum;
	i64 length;
	asu64(R1) = qq_lex_lxsptr;
	R2 = (u64)&qq_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	hsum = asi64(R1);
	goto L2701;
L2700:
	asi64(R1) = hsum;
	R2 = 4;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	hsum = asi64(R1);
L2701:
	R1 = (u64)&qq_lex_namemap;
	R2 = (u64)&qq_lex_lxsptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	R3 = R2;
	c = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2700;
	R1 = (u64)&qq_lex_lxsptr;
	(*tou64p(R1)) -=1;
	asi64(R1) = hsum;
	R2 = 5;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	R2 = 32767;
	asi64(R1) &= asi64(R2);
	asu64(R2) = qq_lex_lxsptr;
	R3 = (u64)&qq_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R2) -= asi64(R3);
	R3 = (u64)&qq_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R1) = qq_lex_lookup(asu64(R3), asi64(R2), asi64(R1));
	goto L2699;
L2699:
	return;
}

static void qq_lib_reportcterror(u64 errortype, u64 mess, i64 pos, u64 currproc) {
    u64 R1, R2; struct $B12 R1_B12; 
	struct $B12 loc;
	asu64(R1) = currproc;
	asi64(R2) = pos;
	(R1_B12) = qq_lib_geterrorinfo(asu64(R2), asu64(R1));
	loc = (R1_B12);
	msysc_m$print_startcon();
	asu64(R1) = errortype;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Error:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("    ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = pos;
	if (asi64(R1)) goto L2706;
	asi64(R1) = qq_decls_qpos;
	if (!asi64(R1)) goto L2705;
L2706:
	(R1_B12) = loc;
	qq_lib_showerrorsource((R1_B12));
L2705:
	(R1_B12) = loc;
	qq_lib_stopcompiler((R1_B12));
	return;
}

static struct $B12 qq_lib_geterrorinfo(u64 pos, u64 currproc) {
    u64 R1, R2, R3; struct $B12 R1_B12; 
	i64 soffset;
	i64 moduleno;
	struct $B12 loc;
	R1 = (u64)&loc;
	memset(R1, 0, 48);
	asu64(R1) = pos;
	R2 = 0;
	R3 = 23;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = (u64)&loc;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pos;
	R2 = 24;
	R3 = 31;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	moduleno = asi64(R1);
	asi64(R1) = moduleno;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2709;
	(R1_B12) = loc;
	goto L2707;
L2709:
	asu64(R1) = currproc;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2711;
	R1 = tou64("GETERRORINFO: no currproc");
	mlib_abortprogram(asu64(R1));
L2711:
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = moduleno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&loc;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&qq_decls_subprogs;
	R2 = (u64)&loc;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 44;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&loc;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = currproc;
	R2 = (u64)&loc;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	(R1_B12) = loc;
	goto L2707;
L2707:
	return (R1_B12);
}

static void qq_lib_showerrorsource(struct $B12 loc) {
    u64 R1, R2; 
	u64 s;
	R1 = (u64)&loc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L2714;
	goto L2712;
L2714:
	msysc_m$print_startcon();
	R1 = tou64("Line:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&loc;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("in Module");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&loc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".q:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&loc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L2716;
	msysc_m$print_startcon();
	R1 = tou64("In function:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&loc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L2716:
L2712:
	return;
}

static void qq_lib_stopcompiler(struct $B12 loc) {
    u64 R1, R2; 
	u64 f;
	R1 = (u64)&loc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L2719;
	R1 = tou64("w");
	R2 = tou64("$error.tmp");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = (u64)&loc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&loc;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
L2719:
	R1 = 1;
	exit(R1);
	return;
}

static void qq_lib_gerror(u64 mess, u64 p) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = qq_decls_stcurrproc;
	asu64(R2) = p;
	if (!asu64(R2)) goto L2722;
	asu64(R2) = p;
	R3 = 4;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	goto L2721;
L2722:
	asi64(R2) = qq_decls_qpos;
L2721:
	asu64(R3) = mess;
	R4 = tou64("Code Gen");
	qq_lib_reportcterror(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	return;
}

static void qq_lib_gerror_s(u64 mess, u64 param, u64 p) {
    u64 R1, R2, R3, R4; 
	struct $B15 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = qq_decls_stcurrproc;
	asu64(R2) = p;
	if (!asu64(R2)) goto L2725;
	asu64(R2) = p;
	R3 = 4;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	goto L2724;
L2725:
	asi64(R2) = qq_decls_qpos;
L2724:
	R3 = (u64)&str;
	R4 = tou64("Code Gen");
	qq_lib_reportcterror(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	return;
}

static void qq_lib_serror(u64 mess) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = qq_decls_stcurrproc;
	R2 = (u64)&qq_decls_lx;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = mess;
	R4 = tou64("Syntax");
	qq_lib_reportcterror(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	return;
}

static void qq_lib_serror_s(u64 mess, u64 param) {
    u64 R1, R2, R3, R4; 
	struct $B15 str;
	asu64(R1) = mess;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = param;
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = qq_decls_stcurrproc;
	R2 = (u64)&qq_decls_lx;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = (u64)&str;
	R4 = tou64("Syntax");
	qq_lib_reportcterror(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	return;
}

static void qq_lib_rxerror(u64 mess, u64 p) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = qq_decls_stcurrproc;
	asu64(R2) = p;
	if (!asu64(R2)) goto L2730;
	asu64(R2) = p;
	R3 = 4;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	goto L2729;
L2730:
	asi64(R2) = qq_decls_qpos;
L2729:
	asu64(R3) = mess;
	R4 = tou64("Resolve");
	qq_lib_reportcterror(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	return;
}

static void qq_lib_rxerror_s(u64 mess, u64 param, u64 p) {
    u64 R1, R2; 
	struct $B15 str;
	asu64(R1) = mess;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = param;
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = (u64)&str;
	qq_lib_rxerror(asu64(R2), asu64(R1));
	return;
}

static void qq_lib_lxerror(u64 mess) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = qq_decls_stcurrproc;
	R2 = (u64)&qq_decls_lx;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = mess;
	R4 = tou64("Lex");
	qq_lib_reportcterror(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	return;
}

static void qq_lib_loaderror(u64 mess, u64 mess2) {
    u64 R1, R2; 
	struct $B25 str;
	R1 = 35;
	asu64(R2) = mess;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	if (!asu64(R1)) goto L2735;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mess2;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L2734;
L2735:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L2734:
	msysc_m$print_startcon();
	R1 = tou64("Load Error:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Stopping");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void qq_lib_prterror(u64 mess) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("Print error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = mwindows_os_getch();
	R1 = 1;
	exit(R1);
	return;
}

static u64 qq_lib_allocunitrec() {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 32;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L2737;
L2737:
	return asu64(R1);
}

static u64 qq_lib_createintunit(i64 a) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = qq_lib_allocunitrec();
	u = asu64(R1);
	R1 = 41;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = a;
	asu64(R2) = u;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = u;
	goto L2738;
L2738:
	return asu64(R1);
}

static u64 qq_lib_createrealunit(r64 x) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = qq_lib_allocunitrec();
	u = asu64(R1);
	R1 = 42;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	asu64(R2) = u;
	R3 = 16;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asu64(R1) = u;
	goto L2739;
L2739:
	return asu64(R1);
}

static u64 qq_lib_createstringunit(u64 s, i64 slength) {
    u64 R1, R2, R3, R4; 
	u64 u;
	asi64(R1) = slength;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L2742;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	slength = asi64(R1);
L2742:
	asu64(R1) = qq_lib_allocunitrec();
	u = asu64(R1);
	R1 = 43;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = slength;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = slength;
	if (!asi64(R1)) goto L2744;
	asi64(R1) = slength;
	asu64(R2) = s;
	asu64(R3) = u;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L2744:
	R1 = 0;
	asu64(R2) = u;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = slength;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = slength;
	asu64(R2) = u;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = u;
	goto L2740;
L2740:
	return asu64(R1);
}

static u64 qq_lib_createunit0(i64 tag) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = qq_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = u;
	goto L2745;
L2745:
	return asu64(R1);
}

static u64 qq_lib_createunit1(i64 tag, u64 p) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = qq_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L2746;
L2746:
	return asu64(R1);
}

static u64 qq_lib_createunit2(i64 tag, u64 p, u64 q) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = qq_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = u;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L2747;
L2747:
	return asu64(R1);
}

static u64 qq_lib_createname(u64 p) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = qq_lib_allocunitrec();
	u = asu64(R1);
	R1 = 39;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L2748;
L2748:
	return asu64(R1);
}

static void qq_lib_addlistunit(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	goto L2751;
L2750:
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2754;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L2753;
L2754:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L2753:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L2751:
	asu64(R1) = p;
	if (asu64(R1)) goto L2750;
	return;
}

static u64 qq_lib_createavname() {
    u64 R1; 
	u64 p;
	struct $B32 str;
	u64 name;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("av$");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&qq_lib_nextavindex;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	name = asu64(R1);
	asu64(R1) = name;
	asu64(R1) = qq_lex_addnamestr(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	asu64(R1) = qq_lib_createname(asu64(R1));
	goto L2755;
L2755:
	return asu64(R1);
}

static u64 qq_lib_convtostringz(u64 svalue, i64 length) {
    u64 R1, R2, R3; 
	u64 p;
// PROC LOCAL STATICS GO HERE
	static i64 qq_lib_convtostringz_strindex = 0;
	static struct $B12 qq_lib_convtostringz_table = {{
	(u64)&qq_lib_convtostringz_strbuffer1,
	(u64)&qq_lib_convtostringz_strbuffer2,
	(u64)&qq_lib_convtostringz_strbuffer3,
	(u64)&qq_lib_convtostringz_strbuffer4,
	(u64)&qq_lib_convtostringz_strbuffer5,
	(u64)&qq_lib_convtostringz_strbuffer6    }};
	static u64 qq_lib_convtostringz_longstr = 0;
	asi64(R1) = length;
	R2 = 2000;
	if (asi64(R1) < asi64(R2)) goto L2758;
	asu64(R1) = qq_lib_convtostringz_longstr;
	if (!asu64(R1)) goto L2760;
	asu64(R1) = qq_lib_convtostringz_longstr;
	free(asu64(R1));
L2760:
	asi64(R1) = length;
	R2 = 1;
	asu64(R1) += asu64(R2);
	asu64(R1) = malloc(asu64(R1));
	qq_lib_convtostringz_longstr = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = svalue;
	asu64(R3) = qq_lib_convtostringz_longstr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = qq_lib_convtostringz_longstr;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = qq_lib_convtostringz_longstr;
	goto L2756;
L2758:
	asu64(R1) = svalue;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2762;
	R1 = tou64("");
	goto L2756;
L2762:
	R1 = (u64)&qq_lib_convtostringz_strindex;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L2764;
	R1 = 0;
	qq_lib_convtostringz_strindex = asi64(R1);
L2764:
	R1 = (u64)&qq_lib_convtostringz_table;
	asi64(R2) = qq_lib_convtostringz_strindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	p = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = svalue;
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L2756;
L2756:
	return asu64(R1);
}

static u64 qq_lib_findprocname(u64 fnptr) {
    u64 R1, R2; 
	u64 name;
	i64 n;
	i64 i;
	asi64(R1) = $nprocs;
	n = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2768;
L2766:
	R1 = (u64)&$procaddr;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = fnptr;
	if (asu64(R1) != asu64(R2)) goto L2770;
	R1 = (u64)&$procname;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L2765;
L2770:
	i += 1; if (i <= n) goto L2766;
L2768:
	R1 = tou64("?");
	goto L2765;
L2765:
	return asu64(R1);
}

static u64 qq_lib_strexpr(u64 p) {
    u64 R1; 
	asu64(R1) = qq_lib_exprstr;
	mlib_gs_init(asu64(R1));
	asu64(R1) = p;
	qq_lib_jeval(asu64(R1));
	asu64(R1) = qq_lib_exprstr;
	goto L2771;
L2771:
	return asu64(R1);
}

static u64 qq_lib_strexpr_s(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2774;
	R1 = tou64("");
	goto L2772;
L2774:
	asu64(R1) = qq_lib_exprstr;
	mlib_gs_init(asu64(R1));
	asu64(R1) = p;
	qq_lib_jeval(asu64(R1));
	asu64(R1) = qq_lib_exprstr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L2772;
L2772:
	return asu64(R1);
}

static void qq_lib_jeval(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	struct $B74 str;
	i64 i;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L2777;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2777;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L2778;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L2779;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L2780;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L2781;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L2782;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L2782;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L2783;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L2784;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2785;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L2786;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L2787;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2788;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L2789;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L2790;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L2791;
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L2792;
	goto L2793;
L2777:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	qq_lib_additem(asu64(R1));
	goto L2776;
L2778:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asr64(R2) = tor64(asi64(R2));
	asu64(R1) = msysc_strreal(asr64(R2), asu64(R1));
	qq_lib_additem(asu64(R1));
	goto L2776;
L2779:
	asu64(R1) = p;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 250;
	if (asi64(R1) <= asi64(R2)) goto L2795;
	R1 = tou64("LONGSTR)");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L2794;
L2795:
	R1 = (u64)&str;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_lib_convertstring(asu64(R2), asu64(R1));
L2794:
	R1 = tou64("\"");
	qq_lib_additem(asu64(R1));
	R1 = (u64)&str;
	qq_lib_additem(asu64(R1));
	R1 = tou64("\"");
	qq_lib_additem(asu64(R1));
	goto L2776;
L2780:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_additem(asu64(R1));
	goto L2776;
L2781:
	R1 = tou64("Host<");
	qq_lib_additem(asu64(R1));
	R1 = (u64)&qq_tables_hostfnnames;
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 2;
	R1 += (i64)R2;
	qq_lib_additem(asu64(R1));
	R1 = tou64(">(");
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L2797;
L2796:
	asu64(R1) = q;
	qq_lib_jeval(asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L2800;
	R1 = tou64(",");
	qq_lib_additem(asu64(R1));
L2800:
L2797:
	asu64(R1) = q;
	if (asu64(R1)) goto L2796;
	R1 = tou64(")");
	qq_lib_additem(asu64(R1));
	goto L2776;
L2782:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 48;
	if (asi64(R1) != asi64(R2)) goto L2802;
	R1 = tou64(".");
	qq_lib_additem(asu64(R1));
L2802:
	R1 = tou64("[");
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	R1 = tou64("]");
	qq_lib_additem(asu64(R1));
	goto L2776;
L2783:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	R1 = tou64("{");
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	R1 = tou64("}");
	qq_lib_additem(asu64(R1));
	goto L2776;
L2784:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	R1 = tou64(".");
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	goto L2776;
L2785:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	R1 = tou64(":=");
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	goto L2776;
L2786:
	R1 = 0;
	asu64(R2) = p;
	R3 = 24;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = qq_show_strmode(asi64(R2), asi64(R1));
	qq_lib_additem(asu64(R1));
	goto L2776;
L2787:
	R1 = 0;
	asu64(R2) = p;
	R3 = 24;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = qq_show_strmode(asi64(R2), asi64(R1));
	qq_lib_additem(asu64(R1));
	R1 = tou64("(");
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	R1 = tou64(")");
	qq_lib_additem(asu64(R1));
	goto L2776;
L2788:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	R1 = tou64(":");
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	goto L2776;
L2789:
	R1 = tou64("nil");
	qq_lib_additem(asu64(R1));
	goto L2776;
L2790:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	R1 = tou64(".$");
	qq_lib_additem(asu64(R1));
	goto L2776;
L2791:
	R1 = tou64("CMPCHAIN:");
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	qq_lib_jeval(asu64(R1));
	R1 = 1;
	i = asi64(R1);
L2803:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	R1 += (i64)R2;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2807;
	goto L2805;
L2807:
	R1 = (u64)&qq_tables_jtagnames;
	asu64(R2) = p;
	R3 = 24;
	R2 += (i64)R3;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	qq_lib_additem(asu64(R1));
	asu64(R1) = q;
	qq_lib_jeval(asu64(R1));
	i += 1; if (i <= 4) goto L2803;
L2805:
	goto L2776;
L2792:
	R1 = (u64)&qq_tables_mathsnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 3;
	R1 += (i64)R2;
	qq_lib_additem(asu64(R1));
	R1 = tou64("(");
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jeval(asu64(R1));
	R1 = tou64(")");
	qq_lib_additem(asu64(R1));
	goto L2776;
L2793:
	R1 = (u64)&qq_tables_jflags;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2809;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R1) = qq_lib_getopcname(asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("(");
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jevallist(asu64(R1));
	R1 = (u64)&str;
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jevallist(asu64(R1));
	R1 = tou64(")");
	qq_lib_additem(asu64(R1));
	goto L2808;
L2809:
	R1 = (u64)&qq_tables_jflags;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2810;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R1) = qq_lib_getopcname(asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	qq_lib_additem(asu64(R1));
	R1 = tou64("(");
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_lib_jevallist(asu64(R1));
	R1 = tou64(")");
	qq_lib_additem(asu64(R1));
	goto L2808;
L2810:
	msysc_m$print_startcon();
	R1 = (u64)&qq_tables_jtagnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&qq_tables_jtagnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("CAN'T DO JEVAL:");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L2808:
L2776:
	return;
}

static void qq_lib_jevallist(u64 p) {
    u64 R1, R2; 
	u64 q;
	asu64(R1) = p;
	if (asu64(R1)) goto L2813;
	goto L2811;
L2813:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L2815;
	R1 = tou64("(");
	qq_lib_additem(asu64(R1));
	asu64(R1) = p;
	q = asu64(R1);
	goto L2817;
L2816:
	asu64(R1) = q;
	qq_lib_jeval(asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L2820;
	R1 = tou64(",");
	qq_lib_additem(asu64(R1));
L2820:
L2817:
	asu64(R1) = q;
	if (asu64(R1)) goto L2816;
	R1 = tou64(")");
	qq_lib_additem(asu64(R1));
	goto L2811;
	goto L2814;
L2815:
	asu64(R1) = p;
	qq_lib_jeval(asu64(R1));
L2814:
L2811:
	return;
}

static void qq_lib_additem(u64 s) {
    u64 R1, R2, R3; 
	u64 d;
	i64 lastchar;
	i64 nextchar;
	asu64(R1) = qq_lib_exprstr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = qq_lib_exprstr;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L2823;
	asu64(R1) = d;
	asu64(R2) = qq_lib_exprstr;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	lastchar = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	nextchar = asi64(R1);
	asi64(R1) = lastchar;
	asi64(R1) = qq_lib_isalphanum(asi64(R1));
	if (!asi64(R1)) goto L2825;
	asi64(R1) = nextchar;
	asi64(R1) = qq_lib_isalphanum(asi64(R1));
	if (!asi64(R1)) goto L2825;
	R1 = -1;
	R2 = tou64(" ");
	asu64(R3) = qq_lib_exprstr;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
L2825:
L2823:
	R1 = -1;
	asu64(R2) = s;
	asu64(R3) = qq_lib_exprstr;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static i64 qq_lib_isalphanum(i64 c) {
    u64 R1, R2; 
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L2830;
	asi64(R1) = c;
	R2 = 90;
	if (asi64(R1) <= asi64(R2)) goto L2829;
L2830:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L2831;
	asi64(R1) = c;
	R2 = 122;
	if (asi64(R1) <= asi64(R2)) goto L2829;
L2831:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L2828;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L2828;
L2829:
	R1 = 1;
	goto L2826;
L2828:
	R1 = 0;
	goto L2826;
L2826:
	return asi64(R1);
}

static u64 qq_lib_getopcname(i64 opc) {
    u64 R1, R2; 
	R1 = (u64)&qq_tables_jtagnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	goto L2832;
L2832:
	return asu64(R1);
}

static void qq_lib_convertstring(u64 s, u64 t) {
    u64 R1, R2, R3; 
	i64 c;
	goto L2835;
L2834:
	asi64(R1) = c;
	switch (asi64(R1)) {
	case 7: case 8: case 26: case 27: goto L2845;
	case 9: goto L2843;
	case 10: goto L2841;
	case 11: case 12: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 28: case 29: case 30: case 31: case 32: case 33: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: goto L2839;
	case 13: goto L2842;
	case 34: goto L2840;
	case 92: goto L2844;
	default: goto L2839;
    };
// SWITCH
L2840:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 34;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2837;
L2841:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 110;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2837;
L2842:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 99;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2837;
L2843:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 116;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2837;
L2844:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2837;
L2845:
	R1 = 60;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = c;
	R2 = 10;
	asi64(R1) /= asi64(R2);
	R2 = 48;
	asu64(R1) += asu64(R2);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = c;
	R2 = 10;
	asi64(R1) %= asi64(R2);
	R2 = 48;
	asu64(R1) += asu64(R2);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 62;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L2837;
L2839:
	asi64(R1) = c;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L2837:
L2835:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	if (asi64(R1)) goto L2834;
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	return;
}

static u64 qq_lib_createavnamex(u64 owner) {
    u64 R1, R2, R3; 
	u64 p;
	u64 d;
	asu64(R1) = qq_lib_createavname();
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	asu64(R3) = owner;
	qq_resolve_resolvename(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L2848;
	R1 = (u64)&qq_decls_nproclocals;
	(*toi64p(R1)) += 1;
	asi64(R1) = qq_decls_nproclocals;
	asu64(R2) = d;
	R3 = 96;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = qq_decls_nproclocals;
	asu64(R2) = qq_pclgen_pprocentry;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2848:
	asu64(R1) = p;
	goto L2846;
L2846:
	return asu64(R1);
}

static void qq_lib_storemode(u64 owner, i64 m, u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	asi64(R1) = m;
	asu64(R2) = p;
	*toi16p(R2) = asi16(R1);
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L2851;
	goto L2849;
L2851:
	R1 = 24;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asu64(R1) = owner;
	asu64(R2) = q;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = owner;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2853;
	R1 = tou64("STOREMODE/OWNER=0");
	qq_lib_serror(asu64(R1));
L2853:
	asu64(R1) = p;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = qq_tables_userxmodelist;
	asu64(R2) = q;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	qq_tables_userxmodelist = asu64(R1);
L2849:
	return;
}

static i64 qq_lib_nextpoweroftwo(i64 x) {
    u64 R1, R2; 
	i64 a;
	asi64(R1) = x;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2856;
	R1 = 0;
	goto L2854;
L2856:
	R1 = 1;
	a = asi64(R1);
	goto L2858;
L2857:
	R1 = 1;
	R2 = (u64)&a;
	*toi64p(R2) <<= asi64(R1);
L2858:
	asi64(R1) = a;
	asi64(R2) = x;
	if (asi64(R1) < asi64(R2)) goto L2857;
	asi64(R1) = a;
	goto L2854;
L2854:
	return asi64(R1);
}

static i64 qq_lib_testelem(u64 p, i64 n) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = p;
	asi64(R2) = n;
	R3 = 3;
	asi64(R2) >>= asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&qq_lib_bytemasks;
	asi64(R3) = n;
	R4 = 7;
	asi64(R3) &= asi64(R4);
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L2862;
	R1 = 1;
	goto L2861;
L2862:
	R1 = 0;
L2861:
	goto L2860;
L2860:
	return asi64(R1);
}

static void qq_lib_setelem(u64 p, i64 n) {
    u64 R1, R2, R3, R4; 
	R1 = (u64)&qq_lib_bytemasks;
	asi64(R2) = n;
	R3 = 7;
	asi64(R2) &= asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	asi64(R3) = n;
	R4 = 3;
	asi64(R3) >>= asi64(R4);
	R2 += (i64)R3;
	*tou8p(R2) |= asu8(R1);
	return;
}

static void qq_lib_setelemblock(u64 p, i64 a, i64 b) {
    u64 R1, R2, R3; 
	i64 ax;
	i64 bx;
	i64 nwords;
	i64 nx;
	i64 alast;
	i64 bfirst;
	u64 q;
	i64 av_1;
	i64 i;
	asi64(R1) = a;
	asi64(R2) = b;
	if (asi64(R1) <= asi64(R2)) goto L2866;
	goto L2864;
L2866:
	asi64(R1) = a;
	R2 = -64;
	asi64(R1) &= asi64(R2);
	ax = asi64(R1);
	asi64(R1) = b;
	R2 = -64;
	asi64(R1) &= asi64(R2);
	R2 = 64;
	asi64(R1) += asi64(R2);
	bx = asi64(R1);
	asi64(R1) = ax;
	nx = asi64(R1);
	R1 = -1;
	R2 = R1;
	bfirst = asi64(R2);
	alast = asi64(R1);
	asi64(R1) = bx;
	asi64(R2) = ax;
	asi64(R1) -= asi64(R2);
	R2 = 64;
	asi64(R1) /= asi64(R2);
	nwords = asi64(R1);
	asi64(R1) = nwords;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2868;
	asi64(R1) = ax;
	asi64(R2) = a;
	if (asi64(R1) != asi64(R2)) goto L2871;
	asi64(R1) = b;
	asi64(R2) = bx;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	if (asi64(R1) == asi64(R2)) goto L2870;
L2871:
	asi64(R1) = a;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = b;
	if (asi64(R1) > asi64(R2)) goto L2874;
L2872:
	asi64(R1) = i;
	asu64(R2) = p;
	qq_lib_setelem(asu64(R2), asi64(R1));
	i += 1; if (i <= b) goto L2872;
L2874:
	goto L2864;
L2870:
	goto L2867;
L2868:
	asi64(R1) = ax;
	asi64(R2) = a;
	if (asi64(R1) == asi64(R2)) goto L2876;
	R1 = (u64)&nwords;
	(*toi64p(R1)) -=1;
	asi64(R1) = ax;
	R2 = 64;
	asi64(R1) += asi64(R2);
	nx = asi64(R1);
	asi64(R1) = nx;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	alast = asi64(R1);
L2876:
	asi64(R1) = b;
	asi64(R2) = bx;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	if (asi64(R1) == asi64(R2)) goto L2878;
	R1 = (u64)&nwords;
	(*toi64p(R1)) -=1;
	asi64(R1) = b;
	R2 = -64;
	asi64(R1) &= asi64(R2);
	bfirst = asi64(R1);
L2878:
L2867:
	asi64(R1) = alast;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L2880;
	asi64(R1) = a;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = alast;
	if (asi64(R1) > asi64(R2)) goto L2883;
L2881:
	asi64(R1) = i;
	asu64(R2) = p;
	qq_lib_setelem(asu64(R2), asi64(R1));
	i += 1; if (i <= alast) goto L2881;
L2883:
L2880:
	asu64(R1) = p;
	asi64(R2) = nx;
	R3 = 3;
	asi64(R2) >>= asi64(R3);
	R1 += (i64)R2;
	q = asu64(R1);
	asi64(R1) = nwords;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2886;
L2884:
	R1 = -1;
	asu64(R2) = q;
	*tou64p(R2) = asu64(R1);
	R1 = (u64)&q;
	(*tou64p(R1)) += 8;
	if (--asi64(av_1)) goto L2884;
L2886:
	asi64(R1) = bfirst;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L2888;
	asi64(R1) = bfirst;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = b;
	if (asi64(R1) > asi64(R2)) goto L2891;
L2889:
	asi64(R1) = i;
	asu64(R2) = p;
	qq_lib_setelem(asu64(R2), asi64(R1));
	i += 1; if (i <= b) goto L2889;
L2891:
L2888:
L2864:
	return;
}

static i64 qq_lib_ispoweroftwo(i64 x) {
    u64 R1, R2; 
	i64 a;
	i64 n;
	i64 av_1;
	R1 = 1;
	a = asi64(R1);
	R1 = 0;
	n = asi64(R1);
	R1 = 60;
	av_1 = asi64(R1);
L2893:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = a;
	R2 = 1;
	asi64(R1) <<= asi64(R2);
	a = asi64(R1);
	asi64(R1) = a;
	asi64(R2) = x;
	if (asi64(R1) != asi64(R2)) goto L2897;
	asi64(R1) = n;
	goto L2892;
L2897:
	if (--asi64(av_1)) goto L2893;
	R1 = 0;
	goto L2892;
L2892:
	return asi64(R1);
}

static void qq_lib_deleteunit(u64 p, u64 q) {
    u64 R1, R2, R3; struct $B32 R1_B32; 
	u64 r;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = q;
	(R1_B32) = *(struct $B32*)(R1);
	asu64(R2) = p;
	*(struct $B32*)(R2) = (R1_B32);
	asu64(R1) = r;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_lib_skipsemi() {
    u64 R1, R2; 
	goto L2901;
L2900:
	qq_lex_lex();
L2901:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2900;
	return;
}

static void qq_lib_checksymbol(i64 symbol) {
    u64 R1, R2, R3, R4; 
	struct $B5 str;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = symbol;
	if (asi64(R1) == asi64(R2)) goto L2905;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("# expected, not #");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("m");
	R2 = (u64)&qq_tables_symbolnames;
	asi64(R3) = symbol;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	msysc_m$print_u64(asu64(R2), asu64(R1));
	R1 = tou64("m");
	R2 = (u64)&qq_tables_symbolnames;
	R3 = (u64)&qq_decls_lx;
	R4 = 12;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	msysc_m$print_u64(asu64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	qq_lib_serror(asu64(R1));
L2905:
	return;
}

static void qq_lib_skipsymbol(i64 symbol) {
    u64 R1; 
	asi64(R1) = symbol;
	qq_lib_checksymbol(asi64(R1));
	qq_lex_lex();
	return;
}

static void qq_lib_pcnotmut() {
    u64 R1, R2; 
	R1 = tou64("");
	R2 = tou64("Not mutable");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	return;
}

static i64 qq_lib_getpcloffset(u64 p, u64 q) {
    u64 R1, R2; 
	asu64(R1) = p;
	asu64(R2) = q;
	asi64(R1) -= asi64(R2);
	R2 = 32;
	asi64(R1) /= asi64(R2);
	goto L2908;
L2908:
	return asi64(R1);
}

static void qq_lists_start() {
    u64 R1, R2, R3; 
	asu64(R1) = qq_vars_obj_new();
	qq_lists_emptylist = asu64(R1);
	R1 = 1;
	asu64(R2) = qq_lists_emptylist;
	R3 = 6;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 0;
	asu64(R2) = qq_lists_emptylist;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void qq_lists_var_empty_list(i64 lower, u64 dest) {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 0;
	asi64(R2) = lower;
	R3 = 0;
	asu64(R1) = qq_lists_obj_newlist(asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 266;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	return;
}

static void qq_lists_var_make_list(u64 a, u64 dest, i64 n, i64 lower) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 p;
	u64 b;
	i64 av_1;
	R1 = 0;
	asi64(R2) = lower;
	asi64(R3) = n;
	asu64(R1) = qq_lists_obj_newlist(asi64(R3), asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L2913;
	asu64(R1) = a;
	if (!asu64(R1)) goto L2913;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2916;
L2914:
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = b;
	*(struct $B3*)(R2) = (R1_B3);
	R1 = (u64)&a;
	(*tou64p(R1)) += 16;
	R1 = (u64)&b;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L2914;
L2916:
L2913:
	R1 = 266;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 qq_lists_obj_newlist(i64 n, i64 lower, u64 defval) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 p;
	u64 a;
	i64 av_1;
	i64 av_2;
	asu64(R1) = qq_vars_obj_new();
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = lower;
	R2 = -32768;
	if (asi64(R1) < asi64(R2)) goto L2920;
	R2 = 32767;
	if (asi64(R1) <= asi64(R2)) goto L2919;
L2920:
	R1 = tou64("");
	R2 = tou64("List LWB not 16-bit");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2919:
	asi64(R1) = lower;
	asu64(R2) = p;
	R3 = 6;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L2922;
	asi64(R1) = n;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	a = asu64(R2);
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = 16;
	asi64(R1) /= asi64(R2);
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = defval;
	if (!asu64(R1)) goto L2924;
	asu64(R1) = defval;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2924;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2927;
L2925:
	asu64(R1) = defval;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2929;
	asu64(R1) = defval;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L2929:
	asu64(R1) = defval;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = a;
	*(struct $B3*)(R2) = (R1_B3);
	R1 = (u64)&a;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L2925;
L2927:
	goto L2923;
L2924:
	asi64(R1) = n;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2932;
L2930:
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&a;
	(*tou64p(R1)) += 16;
	if (--asi64(av_2)) goto L2930;
L2932:
L2923:
L2922:
	asu64(R1) = p;
	goto L2917;
L2917:
	return asu64(R1);
}

static void qq_lists_obj_free_list(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	struct $B3 v;
	i64 av_1;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2936;
L2934:
	asu64(R1) = q;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2938;
	asu64(R1) = q;
	qq_vars_var_unshareu(asu64(R1));
L2938:
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L2934;
L2936:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L2940;
	asu64(R1) = p;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L2940:
	asu64(R1) = p;
	mlib_pcm_free32(asu64(R1));
	return;
}

static void qq_lists_var_getix_list(u64 a, i64 index) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 p;
	u64 q;
	u64 offset;
	i64 lower;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 6;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	lower = asi64(R1);
	asi64(R1) = index;
	asi64(R2) = lower;
	asu64(R1) -= asu64(R2);
	offset = asu64(R1);
	asu64(R1) = offset;
	asu64(R2) = q;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L2943;
	R1 = tou64("");
	R2 = tou64("getlist[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2943:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = offset;
	R1 += (i64)R2*16;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = a;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2945;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L2945:
	return;
}

static void qq_lists_var_getslice_list(u64 a, i64 i, i64 j) {
    u64 R1, R2, R3; 
	struct $B3 v;
	struct $B3 v2;
	i64 alower;
	u64 p;
	u64 q;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 6;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	alower = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = alower;
	if (asi64(R1) < asi64(R2)) goto L2949;
	asi64(R1) = j;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R3) = alower;
	asi64(R2) += asi64(R3);
	R3 = 1;
	asi64(R2) -= asi64(R3);
	if (asi64(R1) > asi64(R2)) goto L2949;
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) <= asi64(R2)) goto L2948;
L2949:
	R1 = tou64("");
	R2 = tou64("list/slice bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2948:
	asu64(R1) = qq_vars_obj_new();
	q = asu64(R1);
	asu64(R1) = q;
	R2 = (u64)&v;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = q;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = q;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 1;
	asu64(R2) = q;
	R3 = 6;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	R1 += (i64)R2*16;
	asi64(R2) = alower;
	R1 -= (i64)R2*16;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2951;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2952;
	goto L2953;
L2951:
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_vars_obj_shareu(asu64(R1));
	goto L2950;
L2952:
	R1 = 0;
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2;
	asu64(R2) = q;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2950;
L2953:
	asu64(R1) = p;
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	(*tou32p(R1)) += 1;
L2950:
	asi64(R1) = j;
	asi64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = q;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_lists_var_getixref_list(u64 a, i64 index) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	u64 offset;
	struct $B3 v;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asi64(R1) = index;
	asu64(R2) = q;
	R3 = 6;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) -= asu64(R2);
	offset = asu64(R1);
	asu64(R1) = offset;
	asu64(R2) = q;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L2956;
	asu64(R1) = offset;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L2958;
	R1 = tou64("");
	R2 = tou64("&list[int] lwb");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L2957;
L2958:
	asu64(R1) = offset;
	asu64(R2) = q;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L2959;
	asu64(R1) = q;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2961;
	R1 = tou64("");
	R2 = tou64("Can't extend slice/ext");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2961:
	R1 = 0;
	R2 = (u64)&v;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&v;
	asu64(R2) = q;
	qq_lists_obj_append_list(asu64(R2), asu64(R1));
	goto L2957;
L2959:
	R1 = tou64("");
	R2 = tou64("putlist[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2957:
L2956:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = offset;
	R1 += (i64)R2*16;
	p = asu64(R1);
	R1 = 14;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_lists_var_putix_list(u64 a, i64 index, u64 x) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 dest;
	u64 q;
	u64 offset;
	i64 lower;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L2964;
	qq_lib_pcnotmut();
L2964:
	asi64(R1) = index;
	asu64(R2) = q;
	R3 = 6;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) -= asu64(R2);
	offset = asu64(R1);
	asu64(R1) = offset;
	asu64(R2) = q;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L2966;
	asu64(R1) = offset;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L2968;
	R1 = tou64("");
	R2 = tou64("putlist[int] lwb");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L2967;
L2968:
	asu64(R1) = offset;
	asu64(R2) = q;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L2969;
	asu64(R1) = q;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2971;
	R1 = tou64("");
	R2 = tou64("Can't extend slice/ext");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2971:
	asu64(R1) = x;
	asu64(R2) = q;
	qq_lists_obj_append_list(asu64(R2), asu64(R1));
	goto L2962;
	goto L2967;
L2969:
	R1 = tou64("");
	R2 = tou64("putlist[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2967:
L2966:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = offset;
	R1 += (i64)R2*16;
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2973;
	asu64(R1) = dest;
	qq_vars_var_unshareu(asu64(R1));
L2973:
	asu64(R1) = x;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = dest;
	*(struct $B3*)(R2) = (R1_B3);
L2962:
	return;
}

static void qq_lists_var_putslice_list(u64 a, i64 i, i64 j, u64 x) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 r;
	u64 s;
	u64 p;
	u64 q;
	i64 length;
	i64 sublength;
	i64 av_1;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L2976;
	qq_lib_pcnotmut();
L2976:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2979;
	asi64(R1) = j;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L2979;
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) <= asi64(R2)) goto L2978;
L2979:
	R1 = tou64("");
	R2 = tou64("list/slice bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2978:
	asi64(R1) = j;
	asi64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	sublength = asi64(R1);
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = sublength;
	if (asi64(R1) >= asi64(R2)) goto L2981;
	R1 = tou64("");
	R2 = tou64("substr too short");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2981:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	R1 += (i64)R2*16;
	R2 = 1;
	R1 -= (i64)R2*16;
	r = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asi64(R1) = sublength;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2984;
L2982:
	asu64(R1) = s;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = r;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = r;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2986;
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L2986:
	R1 = (u64)&r;
	(*tou64p(R1)) += 16;
	R1 = (u64)&s;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L2982;
L2984:
	return;
}

static void qq_lists_obj_append_list(u64 a, u64 x) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	i64 n;
	asu64(R1) = a;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2989;
	R1 = tou64("");
	R2 = tou64("Can't extend slice");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L2989:
	asu64(R1) = a;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L2991;
	qq_lib_pcnotmut();
L2991:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = a;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L2993;
	asi64(R1) = n;
	asu64(R2) = a;
	qq_lists_obj_resize_list(asu64(R2), asi64(R1));
	goto L2992;
L2993:
	asi64(R1) = n;
	asu64(R2) = a;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2992:
	asu64(R1) = x;
	if (!asu64(R1)) goto L2995;
	asu64(R1) = x;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = n;
	R2 += (i64)R3*16;
	R3 = 1;
	R2 -= (i64)R3*16;
	*(struct $B3*)(R2) = (R1_B3);
L2995:
	return;
}

static void qq_lists_obj_resize_list(u64 p, i64 n) {
    u64 R1, R2, R3; 
	u64 q;
	u32 allocated;
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L2998;
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L2997;
L2998:
	asi64(R1) = n;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = 16;
	asi64(R1) /= asi64(R2);
	allocated = asu32(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L3000;
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) *= asu64(R2);
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L3000:
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu32(R1) = allocated;
	R1 = toi64(tou32(R1));
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2997:
	return;
}

static void qq_lists_var_appendto_list(u64 a, u64 x) {
    u64 R1, R2, R3; 
	asu64(R1) = x;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_lists_obj_append_list(asu64(R2), asu64(R1));
	return;
}

static void qq_lists_var_dupl_list(u64 a) {
    u64 R1, R2, R3, R4; struct $B32 R1_B32; struct $B3 R1_B3; 
	u64 p;
	u64 q;
	u64 plist;
	u64 qlist;
	i64 av_1;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = qq_vars_obj_new();
	q = asu64(R1);
	asu64(R1) = p;
	(R1_B32) = *(struct $B32*)(R1);
	asu64(R2) = q;
	*(struct $B32*)(R2) = (R1_B32);
	R1 = 1;
	asu64(R2) = q;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	asu64(R2) = q;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3004;
	goto L3002;
L3004:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	asu64(R3) = q;
	R4 = 8;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	qlist = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = 16;
	asi64(R1) /= asi64(R2);
	asu64(R2) = q;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	plist = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3007;
L3005:
	asu64(R1) = plist;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = qlist;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = qlist;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L3009;
	asu64(R1) = qlist;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3011;
	asu64(R1) = qlist;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L3011:
	goto L3008;
L3009:
	asu64(R1) = qlist;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3013;
	asu64(R1) = qlist;
	qq_vars_var_duplu(asu64(R1));
L3013:
L3008:
	R1 = (u64)&qlist;
	(*tou64p(R1)) += 16;
	R1 = (u64)&plist;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L3005;
L3007:
L3002:
	return;
}

static void qq_lists_var_mul_list(u64 p, i64 m) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	i64 oldlength;
	i64 newlength;
	i64 n;
	u64 q;
	u64 r;
	u64 a;
	u64 b;
	i64 av_1;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	oldlength = asi64(R1);
	asi64(R1) = oldlength;
	asi64(R2) = m;
	asi64(R1) *= asi64(R2);
	newlength = asi64(R1);
	asi64(R1) = oldlength;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3016;
	goto L3014;
L3016:
	asi64(R1) = newlength;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L3018;
	R1 = tou64("");
	R2 = tou64("list*int <0");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L3017;
L3018:
	asi64(R1) = newlength;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3019;
	R1 = 0;
	asu64(R2) = q;
	R3 = 6;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R3 = 0;
	asu64(R1) = qq_lists_obj_newlist(asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L3014;
L3019:
L3017:
	R1 = 0;
	asu64(R2) = q;
	R3 = 6;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asi64(R3) = newlength;
	asu64(R1) = qq_lists_obj_newlist(asi64(R3), asi64(R2), asu64(R1));
	r = asu64(R1);
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	asi64(R1) = newlength;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3022;
L3020:
	asu64(R1) = b;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = a;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3024;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L3024:
	R1 = (u64)&a;
	(*tou64p(R1)) += 16;
	asi64(R1) = oldlength;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L3026;
	R1 = (u64)&b;
	(*tou64p(R1)) += 16;
	R1 = (u64)&n;
	asi64(R1) = *(toi64p(R1)) += 1;
	asi64(R2) = oldlength;
	if (asi64(R1) != asi64(R2)) goto L3028;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	R1 = 0;
	n = asi64(R1);
L3028:
L3026:
	if (--asi64(av_1)) goto L3020;
L3022:
	asu64(R1) = r;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3014:
	return;
}

static i64 qq_lists_var_equal_list(u64 x, u64 y) {
    u64 R1, R2; 
	i64 xlen;
	i64 ylen;
	i64 res;
	u64 px;
	u64 py;
	u64 a;
	u64 b;
	i64 av_1;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	py = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = py;
	if (asu64(R1) != asu64(R2)) goto L3031;
	R1 = 1;
	goto L3029;
L3031:
	asu64(R1) = px;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	xlen = asi64(R1);
	asu64(R1) = py;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	ylen = asi64(R1);
	asi64(R1) = xlen;
	asi64(R2) = ylen;
	if (asi64(R1) == asi64(R2)) goto L3033;
	R1 = 0;
	goto L3029;
L3033:
	asi64(R1) = xlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3035;
	R1 = 1;
	goto L3029;
L3035:
	asu64(R1) = px;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = py;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asi64(R1) = xlen;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3038;
L3036:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_vars_var_equal(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3040;
	R1 = 0;
	goto L3029;
L3040:
	R1 = (u64)&a;
	(*tou64p(R1)) += 16;
	R1 = (u64)&b;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L3036;
L3038:
	R1 = 1;
	goto L3029;
L3029:
	return asi64(R1);
}

static void qq_lists_var_concatto_list(u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 newptr;
	u64 c;
	u64 d;
	i64 n;
	i64 alen;
	i64 blen;
	i64 newlen;
	i64 oldbytes;
	i64 newbytes;
	u64 v;
	u64 pa;
	u64 pb;
	i64 av_1;
	i64 av_2;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = pa;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L3043;
	qq_lib_pcnotmut();
L3043:
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pb = asu64(R1);
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	alen = asi64(R1);
	asu64(R1) = pb;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	blen = asi64(R1);
	asi64(R1) = alen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3045;
	asi64(R1) = blen;
	if (!asi64(R1)) goto L3047;
	asi64(R1) = blen;
	asu64(R2) = pa;
	qq_lists_obj_resize_list(asu64(R2), asi64(R1));
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = blen;
	R2 = 16;
	asu64(R1) *= asu64(R2);
	asu64(R2) = pb;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = d;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = blen;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3050;
L3048:
	asu64(R1) = d;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3052;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L3052:
	R1 = (u64)&d;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L3048;
L3050:
L3047:
	goto L3044;
L3045:
	asi64(R1) = blen;
	if (!asi64(R1)) goto L3053;
	asi64(R1) = alen;
	asi64(R2) = blen;
	asi64(R1) += asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	asu64(R2) = pa;
	qq_lists_obj_resize_list(asu64(R2), asi64(R1));
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = alen;
	R1 += (i64)R2*16;
	d = asu64(R1);
	asi64(R1) = blen;
	R2 = 16;
	asu64(R1) *= asu64(R2);
	asu64(R2) = pb;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = d;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = blen;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3056;
L3054:
	asu64(R1) = d;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3058;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L3058:
	R1 = (u64)&d;
	(*tou64p(R1)) += 16;
	if (--asi64(av_2)) goto L3054;
L3056:
L3053:
L3044:
	return;
}

static i64 qq_lists_var_inx_list(u64 a, u64 b) {
    u64 R1, R2; 
	i64 n;
	i64 lowerm1;
	u64 x;
	i64 i;
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 6;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	lowerm1 = asi64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3062;
L3060:
	asu64(R1) = x;
	asu64(R2) = a;
	asi64(R1) = qq_vars_var_equal(asu64(R2), asu64(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3064;
	asi64(R1) = i;
	asi64(R2) = lowerm1;
	asi64(R1) += asi64(R2);
	goto L3059;
L3064:
	R1 = (u64)&x;
	(*tou64p(R1)) += 16;
	i += 1; if (i <= n) goto L3060;
L3062:
	R1 = 0x8000000000000000;
	goto L3059;
L3059:
	return asi64(R1);
}

static u64 qq_modules_loadsp(u64 filename, u64 source) {
    u64 R1, R2, R3, R4; 
	u64 sp;
	struct $B28 modnames;
	struct $B28 subnames;
	i64 nmods;
	i64 nsubs;
	i64 firstmod;
	i64 lastmod;
	i64 issyslib;
	u64 pm;
	u64 d;
	struct $B15 path;
	i64 i;
	R1 = 0;
	nmods = asi64(R1);
	R1 = 0;
	nsubs = asi64(R1);
	R1 = 0;
	issyslib = asi64(R1);
	asu64(R1) = source;
	if (!asu64(R1)) goto L3067;
	asu64(R1) = source;
	asu64(R2) = filename;
	asu64(R1) = qq_modules_loadstring(asu64(R2), asu64(R1));
	pm = asu64(R1);
	R1 = 0;
	R2 = (u64)&path;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L3066;
L3067:
	asu64(R1) = filename;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	R2 = (u64)&path;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = qq_cli_syslibname;
	if (!asu64(R1)) goto L3069;
	asu64(R1) = qq_cli_syslibname;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	R2 = (u64)&path;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3069;
	R1 = 1;
	issyslib = asi64(R1);
L3069:
	asi64(R1) = issyslib;
	asu64(R2) = filename;
	asu64(R1) = qq_modules_loadsourcefile(asu64(R2), asi64(R1));
	pm = asu64(R1);
	asu64(R1) = pm;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3071;
	asu64(R1) = filename;
	R2 = tou64("Can't load lead module: #");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3071:
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&path;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L3066:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nsubprogs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3074;
L3072:
	R1 = (u64)&qq_decls_subprogs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3076;
	asu64(R1) = sp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Subprog already loaded: #");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3076:
	i += 1; if (i <= qq_decls_nsubprogs) goto L3072;
L3074:
	asu64(R1) = pm;
	qq_lex_startlex(asu64(R1));
L3077:
	qq_lex_lex();
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 105;
	if (asi64(R1) == asi64(R2)) goto L3080;
	R2 = 106;
	if (asi64(R1) == asi64(R2)) goto L3081;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3082;
	goto L3083;
L3080:
	qq_lex_lex();
	R1 = 69;
	qq_lib_checksymbol(asi64(R1));
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L3085;
	asi64(R1) = nmods;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L3087;
	R1 = tou64("");
	R2 = tou64("Too many modules in header");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3087:
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&modnames;
	R3 = (u64)&nmods;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L3085:
	goto L3079;
L3081:
	qq_lex_lex();
	R1 = 69;
	qq_lib_checksymbol(asi64(R1));
	asi64(R1) = nsubs;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L3089;
	R1 = tou64("");
	R2 = tou64("Too many imports in header");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3089:
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&subnames;
	R3 = (u64)&nsubs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L3079;
L3082:
	goto L3079;
L3083:
	goto L3078;
L3079:
	goto L3077;
L3078:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nsubs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3092;
L3090:
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&subnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3094;
	R1 = tou64("");
	R2 = tou64("Importing self");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3094:
	R1 = 0;
	R2 = (u64)&subnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = tou64("");
	asu64(R2) = qq_modules_getmodulefilename(asu64(R3), asu64(R2));
	qq_cli_compile_sp(asu64(R2), asu64(R1));
	i += 1; if (i <= nsubs) goto L3090;
L3092:
	asi64(R1) = qq_decls_nsubprogs;
	R2 = 30;
	if (asi64(R1) < asi64(R2)) goto L3096;
	R1 = tou64("");
	R2 = tou64("Too many subprogs");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3096:
	R1 = 32;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	sp = asu64(R1);
	asu64(R1) = sp;
	R2 = (u64)&qq_decls_subprogs;
	R3 = (u64)&qq_decls_nsubprogs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = qq_decls_nsubprogs;
	asu64(R2) = sp;
	R3 = 31;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = qq_decls_nmodules;
	R2 = 1;
	asi64(R1) += asi64(R2);
	firstmod = asi64(R1);
	asi64(R1) = firstmod;
	asi64(R2) = nmods;
	asi64(R1) += asi64(R2);
	lastmod = asi64(R1);
	asi64(R1) = lastmod;
	R2 = 200;
	if (asi64(R1) <= asi64(R2)) goto L3098;
	R1 = tou64("");
	R2 = tou64("Too many modules");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3098:
	asi64(R1) = lastmod;
	qq_decls_nmodules = asi64(R1);
	asi64(R1) = qq_decls_nsubprogs;
	asu64(R2) = pm;
	R3 = 44;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = pm;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = firstmod;
	asu64(R2) = pm;
	R3 = 46;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 3;
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = qq_lex_addnamestr(asu64(R2));
	asu64(R3) = qq_decls_stprogram;
	asu64(R1) = qq_names_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	R2 = R1;
	d = asu64(R2);
	asu64(R2) = pm;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = firstmod;
	asu64(R2) = d;
	R3 = 114;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pm;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = firstmod;
	asu64(R2) = sp;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = lastmod;
	asu64(R2) = sp;
	R3 = 26;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = issyslib;
	asu64(R2) = sp;
	R3 = 30;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pm;
	R2 = (u64)&qq_decls_modules;
	asi64(R3) = firstmod;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nmods;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3101;
L3099:
	asi64(R1) = issyslib;
	R2 = (u64)&modnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = (u64)&path;
	asu64(R2) = qq_modules_getmodulefilename(asu64(R3), asu64(R2));
	asu64(R1) = qq_modules_loadsourcefile(asu64(R2), asi64(R1));
	pm = asu64(R1);
	asu64(R1) = pm;
	if (asu64(R1)) goto L3103;
	R1 = (u64)&modnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = tou64("Can't load: ##");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3103:
	asu64(R1) = pm;
	R2 = (u64)&qq_decls_modules;
	asi64(R3) = firstmod;
	asi64(R4) = i;
	asi64(R3) += asi64(R4);
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 3;
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = qq_lex_addnamestr(asu64(R2));
	asu64(R3) = qq_decls_stprogram;
	asu64(R1) = qq_names_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	R2 = R1;
	d = asu64(R2);
	asu64(R2) = pm;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = qq_decls_nsubprogs;
	asu64(R2) = pm;
	R3 = 44;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = firstmod;
	asi64(R2) = i;
	asi64(R1) += asi64(R2);
	R2 = R1;
	asu64(R3) = pm;
	R4 = 46;
	*toi16p(((i64)R3+(i64)R4)) = asi16(R2);
	asu64(R2) = d;
	R3 = 114;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= nmods) goto L3099;
L3101:
	asu64(R1) = sp;
	goto L3065;
L3065:
	return asu64(R1);
}

static u64 qq_modules_getmodulefilename(u64 path, u64 name) {
    u64 R1, R2; 
	asu64(R1) = path;
	R2 = (u64)&qq_modules_getmodulefilename_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = name;
	R2 = (u64)&qq_modules_getmodulefilename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(".q");
	R2 = (u64)&qq_modules_getmodulefilename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&qq_modules_getmodulefilename_str;
	goto L3104;
L3104:
	return asu64(R1);
}

static u64 qq_modules_loadsourcefile(u64 filespec, i64 issyslib) {
    u64 R1, R2, R3; 
	u64 pm;
	u64 s;
	u64 basefilename;
	struct $B15 str;
	R1 = 120;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	pm = asu64(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	basefilename = asu64(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = pm;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_extractpath(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = pm;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = basefilename;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = pm;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = issyslib;
	asu64(R2) = pm;
	R3 = 41;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = qq_decls_nqafiles;
	if (!asi64(R1)) goto L3107;
	asu64(R1) = pm;
	asi64(R1) = qq_modules_loadqafile(asu64(R1));
	if (!asi64(R1)) goto L3107;
	asu64(R1) = pm;
	goto L3105;
L3107:
	asi64(R1) = issyslib;
	if (!asi64(R1)) goto L3109;
	asu8(R1) = qq_decls_usebundled;
	if (!asu8(R1)) goto L3109;
	asi64(R1) = issyslib;
	asu64(R2) = pm;
	R3 = 41;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pm;
	asi64(R1) = qq_syslibs_loadsysmodule(asu64(R1));
	if (asi64(R1)) goto L3111;
	asu64(R1) = filespec;
	R2 = tou64("LS:Can't load syslib");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3111:
	asu64(R1) = pm;
	goto L3105;
L3109:
	asu64(R1) = filespec;
	asu64(R1) = mlib_readfile(asu64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	if (asu64(R1)) goto L3113;
	R1 = tou64("c:/m/libs/");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = basefilename;
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(".q");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R1) = mlib_readfile(asu64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	if (asu64(R1)) goto L3115;
	R1 = 0;
	goto L3105;
L3115:
L3113:
	asu64(R1) = s;
	asu64(R2) = pm;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_rfsize;
	asu64(R2) = pm;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	asu64(R2) = s;
	asi64(R3) = mlib_rfsize;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pm;
	goto L3105;
L3105:
	return asu64(R1);
}

static u64 qq_modules_loadstring(u64 name, u64 source) {
    u64 R1, R2, R3; 
	u64 pm;
	struct $B3 str;
// PROC LOCAL STATICS GO HERE
	static i64 qq_modules_loadstring_nextstrname = 0;
	asu64(R1) = name;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3118;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("S$");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&qq_modules_loadstring_nextstrname;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	name = asu64(R1);
L3118:
	R1 = 120;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	pm = asu64(R1);
	R1 = tou64("<string>");
	asu64(R2) = pm;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = tou64("");
	asu64(R2) = pm;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = name;
	asu64(R2) = pm;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = source;
	asu64(R2) = pm;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = source;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = pm;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pm;
	goto L3116;
L3116:
	return asu64(R1);
}

static u64 qq_modules_readfileline(u64 s) {
    u64 R1, R2, R3; 
	struct $B24 str;
	u64 t;
	i64 n;
	i64 c;
	R1 = (u64)&str;
	t = asu64(R1);
	R1 = 0;
	n = asi64(R1);
L3120:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3122;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3123;
	goto L3124;
L3122:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	goto L3121;
	goto L3120;
L3123:
	goto L3121;
	goto L3120;
L3124:
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) >= asi64(R2)) goto L3126;
	asi64(R1) = c;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3126:
	goto L3120;
L3121:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	msysc_m$read_strline(asu64(R1));
	asu64(R1) = s;
	goto L3119;
L3119:
	return asu64(R1);
}

static u64 qq_modules_findnextlineheader(u64 s) {
    u64 R1, R2; 
	i64 c;
L3128:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3130;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3131;
	goto L3132;
L3130:
	R1 = 0;
	goto L3127;
	goto L3128;
L3131:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L3134;
	asu64(R1) = s;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L3134;
	asu64(R1) = s;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L3134;
	asu64(R1) = s;
	R2 = 3;
	R1 += (i64)R2;
	goto L3127;
L3134:
	goto L3128;
L3132:
	goto L3128;
	R1 = 0;
	goto L3127;
L3127:
	return asu64(R1);
}

static i64 qq_modules_loadqafile(u64 pm) {
    u64 R1, R2, R3; 
	u64 file;
	struct $B15 filename;
	i64 i;
	asu64(R1) = pm;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_extractfile(asu64(R1));
	R2 = (u64)&filename;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nqafiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3138;
L3136:
	R1 = (u64)&qq_decls_qafilenames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&filename;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3140;
	R1 = (u64)&qq_decls_qatext;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = pm;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&qq_decls_qasize;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = pm;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	goto L3135;
L3140:
	i += 1; if (i <= qq_decls_nqafiles) goto L3136;
L3138:
	R1 = 0;
	goto L3135;
L3135:
	return asi64(R1);
}

static void qq_modules_readqabundle() {
    u64 R1, R2, R3, R4; 
	struct $B5 name;
	u64 s;
	u64 t;
	i64 sys;
	i64 support;
	i64 i;
	R1 = 0;
	asu64(R2) = qq_cli_inputfile;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	R1 = tou64("qa");
	asu64(R2) = s;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L3143;
	goto L3141;
L3143:
	asu64(R1) = qq_cli_inputfile;
	asu64(R1) = mlib_readfile(asu64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3145;
	asu64(R1) = qq_cli_inputfile;
	R2 = tou64("Can't find QA file ##");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3145:
	R1 = tou64("q");
	asu64(R2) = qq_cli_inputfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	qq_cli_inputfile = asu64(R1);
	asu64(R1) = s;
	R2 = 3;
	R1 += (i64)R2;
	asu64(R1) = qq_modules_readfileline(asu64(R1));
	s = asu64(R1);
	R1 = 0;
	R2 = 110;
	R3 = (u64)&name;
	msysc_readstr(asu64(R3), asi64(R2), asi64(R1));
	R1 = tou64("qa");
	R2 = (u64)&name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L3147;
	R1 = tou64("");
	R2 = tou64("QA: bad header");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3147:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	asu64(R1) = s;
	asu64(R1) = qq_modules_findnextlineheader(asu64(R1));
	s = asu64(R1);
L3148:
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3151;
	R1 = tou64("");
	R2 = tou64("Unexpected EOF in QA file");
	qq_lib_loaderror(asu64(R2), asu64(R1));
	goto L3149;
L3151:
	asu64(R1) = s;
	asu64(R1) = qq_modules_readfileline(asu64(R1));
	s = asu64(R1);
	R1 = 0;
	R2 = 110;
	R3 = (u64)&name;
	msysc_readstr(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R1) = msysc_m$read_i64(asi64(R1));
	sys = asi64(R1);
	R1 = 0;
	asi64(R1) = msysc_m$read_i64(asi64(R1));
	support = asi64(R1);
	R1 = tou64("end");
	R2 = (u64)&name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3153;
	goto L3149;
L3153:
	asi64(R1) = qq_decls_nqafiles;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L3155;
	R1 = tou64("");
	R2 = tou64("Too many QA files");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3155:
	asu64(R1) = s;
	asu64(R1) = qq_modules_findnextlineheader(asu64(R1));
	t = asu64(R1);
	asu64(R1) = t;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3157;
	R1 = tou64("");
	R2 = tou64("QA error");
	qq_lib_loaderror(asu64(R2), asu64(R1));
L3157:
	R1 = (u64)&qq_decls_nqafiles;
	(*toi64p(R1)) += 1;
	R1 = (u64)&name;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&qq_decls_qafilenames;
	asi64(R3) = qq_decls_nqafiles;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = t;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	R2 = 3;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&qq_decls_qasize;
	asi64(R3) = qq_decls_nqafiles;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = s;
	R2 = (u64)&qq_decls_qatext;
	asi64(R3) = qq_decls_nqafiles;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = t;
	s = asu64(R1);
	goto L3148;
L3149:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nqafiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3160;
L3158:
	R1 = 0;
	R2 = (u64)&qq_decls_qatext;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = (u64)&qq_decls_qasize;
	asi64(R4) = i;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= qq_decls_nqafiles) goto L3158;
L3160:
L3141:
	return;
}

static u64 qq_names_addglobalname(u64 name) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	struct $B3 oldlx;
	u64 d;
	(R1_B3) = qq_decls_nextlx;
	oldlx = (R1_B3);
	asu64(R1) = name;
	asi64(R1) = qq_lex_gethashvaluez(asu64(R1));
	asu64(R2) = name;
	asi64(R2) = strlen(asu64(R2));
	asu64(R3) = name;
	asi64(R1) = qq_lex_lookup(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&qq_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	(R1_B3) = oldlx;
	qq_decls_nextlx = (R1_B3);
	asu64(R1) = d;
	goto L3161;
L3161:
	return asu64(R1);
}

static u64 qq_names_newstrec() {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 128;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	R1 = 128;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asu64(R1) = p;
	goto L3162;
L3162:
	return asu64(R1);
}

static u64 qq_names_addsymbol(u64 owner, u64 d, i64 id, i64 isglobal) {
    u64 R1, R2, R3, R4; 
	u64 e;
	u64 f;
	asu64(R1) = qq_names_newstrec();
	e = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 126;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 126;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = owner;
	asu64(R2) = e;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = id;
	asu64(R2) = e;
	R3 = 124;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = id;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L3164;
	asi64(R1) = id;
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L3165;
L3164:
	R1 = 1;
	goto L3166;
L3165:
	R1 = 0;
L3166:
	asu64(R2) = e;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 9;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = qq_decls_currmodule;
	if (!asu64(R1)) goto L3168;
	asu64(R1) = qq_decls_currmodule;
	R2 = 46;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 114;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3168:
	asu64(R1) = d;
	asu64(R2) = e;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = isglobal;
	asu64(R2) = e;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 1;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = owner;
	if (asu64(R1)) goto L3170;
	asu64(R1) = e;
	goto L3163;
L3170:
	asu64(R1) = owner;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3172;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L3172;
	asu64(R1) = d;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	asu64(R2) = d;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L3174;
	asu64(R1) = e;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) != asu64(R2)) goto L3174;
	msysc_m$print_startcon();
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("in");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = owner;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("AS:Duplicate name");
	qq_lib_serror(asu64(R1));
L3174:
	goto L3171;
L3172:
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	f = asu64(R1);
	goto L3176;
L3175:
	asu64(R1) = f;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 48;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3179;
	msysc_m$print_startcon();
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("in");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = owner;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("AS2:Duplicate name");
	qq_lib_serror(asu64(R1));
L3179:
	asu64(R1) = f;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	f = asu64(R1);
L3176:
	asu64(R1) = f;
	if (asu64(R1)) goto L3175;
L3171:
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3181;
	asu64(R1) = e;
	asu64(R2) = owner;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L3180;
L3181:
	asu64(R1) = e;
	asu64(R2) = owner;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3180:
	asu64(R1) = e;
	asu64(R2) = owner;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	goto L3163;
L3163:
	return asu64(R1);
}

static void qq_names_addproc(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = qq_decls_proclist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3184;
	asu64(R1) = p;
	qq_decls_proclist = asu64(R1);
	goto L3183;
L3184:
	asu64(R1) = p;
	asu64(R2) = qq_decls_proclistx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3183:
	asu64(R1) = p;
	qq_decls_proclistx = asu64(R1);
	R1 = (u64)&qq_decls_nproclist;
	(*toi64p(R1)) += 1;
	return;
}

static i64 qq_names_newusertypex(u64 d, u64 e) {
    u64 R1, R2, R3; 
	i64 i;
	asi64(R1) = qq_tables_nuserxtypes;
	R2 = 5000;
	if (asi64(R1) < asi64(R2)) goto L3187;
	R1 = tou64("Too many external user types");
	qq_lib_serror(asu64(R1));
L3187:
	R1 = (u64)&qq_tables_nuserxtypes;
	(*toi64p(R1)) += 1;
	asu64(R1) = d;
	R2 = (u64)&qq_tables_ttnamedefx;
	asi64(R3) = qq_tables_nuserxtypes;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = qq_decls_stcurrmodule;
	R2 = 114;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_tables_ttxmoduleno;
	asi64(R3) = qq_tables_nuserxtypes;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = qq_tables_nuserxtypes;
	asi64(R1) = -asi64(R1);
	goto L3185;
L3185:
	return asi64(R1);
}

static u64 qq_names_resolvedottedname(u64 owner, u64 d) {
    u64 R1, R2; 
	u64 e;
	asu64(R1) = d;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L3190;
L3189:
	asu64(R1) = e;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L3190:
	asu64(R1) = e;
	if (!asu64(R1)) goto L3192;
	asu64(R1) = e;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) != asu64(R2)) goto L3189;
L3192:
	asu64(R1) = e;
	goto L3188;
L3188:
	return asu64(R1);
}

static void qq_names_addgenfield(u64 d) {
    u64 R1, R2, R3; 
	i64 index;
	u64 dgen;
	u64 g;
	asu64(R1) = d;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dgen = asu64(R1);
	asu64(R1) = dgen;
	R2 = 104;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	index = asi64(R1);
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3195;
	asi64(R1) = qq_decls_ngenfields;
	R2 = 1000;
	if (asi64(R1) < asi64(R2)) goto L3197;
	R1 = 0;
	R2 = tou64("Too many genfields");
	qq_lib_gerror(asu64(R2), asu64(R1));
L3197:
	R1 = (u64)&qq_decls_ngenfields;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = R1;
	index = asi64(R2);
	asu64(R2) = dgen;
	R3 = 104;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L3195:
	R1 = 16;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	g = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = g;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&qq_decls_genfieldtable;
	asi64(R2) = index;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = g;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = g;
	R2 = (u64)&qq_decls_genfieldtable;
	asi64(R3) = index;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	return;
}

static i64 qq_names_makereftype(i64 target, u64 owner) {
    u64 R1, R2, R3; 
	i64 newtype;
	i64 i;
	asu64(R1) = owner;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3200;
	R1 = 41;
	i = asi64(R1);
	asi64(R1) = qq_tables_ntypes;
	R2 = 41;
	if (asi64(R1) < asi64(R2)) goto L3203;
L3201:
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = i;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L3205;
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = i;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asi64(R2) = target;
	if (asi64(R1) != asi64(R2)) goto L3205;
	asi64(R1) = i;
	goto L3198;
L3205:
	i += 1; if (i <= qq_tables_ntypes) goto L3201;
L3203:
L3200:
	asi64(R1) = qq_names_addanontype();
	newtype = asi64(R1);
	R1 = 16;
	R2 = (u64)&qq_tables_ttbasetype;
	asi64(R3) = newtype;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = newtype;
	R1 += (i64)R2*2;
	asi64(R2) = target;
	asu64(R3) = qq_decls_stcurrproc;
	qq_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	R1 = 8;
	R2 = (u64)&qq_tables_ttsize;
	asi64(R3) = newtype;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = 64;
	R2 = (u64)&qq_tables_ttbitwidth;
	asi64(R3) = newtype;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = newtype;
	goto L3198;
L3198:
	return asi64(R1);
}

static i64 qq_names_makeaxtype(i64 target, u64 plower, u64 plength) {
    u64 R1, R2, R3; 
	i64 newtype;
	i64 length;
	asi64(R1) = qq_names_addanontype();
	newtype = asi64(R1);
	R1 = 7;
	R2 = (u64)&qq_tables_ttbasetype;
	asi64(R3) = newtype;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = newtype;
	R1 += (i64)R2*2;
	asi64(R2) = target;
	asu64(R3) = qq_decls_stcurrproc;
	qq_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	R1 = 1;
	R2 = (u64)&qq_tables_ttlower;
	asi64(R3) = newtype;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asu64(R1) = plength;
	R2 = (u64)&qq_tables_ttlengthexpr;
	asi64(R3) = newtype;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = plower;
	R2 = (u64)&qq_tables_ttlowerexpr;
	asi64(R3) = newtype;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = newtype;
	goto L3206;
L3206:
	return asi64(R1);
}

static i64 qq_names_makestrtype(i64 m, u64 pwidth) {
    u64 R1, R2, R3; 
	i64 newtype;
	asi64(R1) = qq_names_addanontype();
	newtype = asi64(R1);
	asi64(R1) = m;
	R2 = (u64)&qq_tables_ttbasetype;
	asi64(R3) = newtype;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asu64(R1) = pwidth;
	R2 = (u64)&qq_tables_ttlengthexpr;
	asi64(R3) = newtype;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_ttlower;
	asi64(R3) = newtype;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asu64(R1) = qq_decls_stcurrproc;
	R2 = (u64)&qq_tables_ttowner;
	asi64(R3) = newtype;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = newtype;
	goto L3207;
L3207:
	return asi64(R1);
}

static i64 qq_names_addanontype() {
    u64 R1, R2, R3; 
	struct $B32 str;
	asi64(R1) = qq_tables_ntypes;
	R2 = 250;
	if (asi64(R1) < asi64(R2)) goto L3210;
	R1 = 0;
	R2 = tou64("Too many types");
	qq_lib_gerror(asu64(R2), asu64(R1));
L3210:
	R1 = (u64)&qq_tables_ntypes;
	(*toi64p(R1)) += 1;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$T");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = qq_tables_ntypes;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&qq_tables_ttname;
	asi64(R3) = qq_tables_ntypes;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = qq_decls_stcurrproc;
	R2 = (u64)&qq_tables_ttowner;
	asi64(R3) = qq_tables_ntypes;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = qq_tables_ntypes;
	goto L3208;
L3208:
	return asi64(R1);
}

static void qq_names_createusertype(u64 d, i64 m) {
    u64 R1, R2, R3; 
	asu64(R1) = d;
	R2 = 116;
	R1 += (i64)R2;
	asi64(R2) = m;
	asu64(R3) = qq_decls_stcurrproc;
	qq_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = m;
	R2 = 40;
	if (asi64(R1) <= asi64(R2)) goto L3213;
	R1 = (u64)&qq_tables_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3213;
	asu64(R1) = d;
	R2 = (u64)&qq_tables_ttnamedef;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_tables_ttname;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_tables_ttowner;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
L3213:
	return;
}

static i64 qq_names_getalignment(i64 m) {
    u64 R1, R2; 
	i64 a;
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L3216;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3217;
	goto L3218;
L3216:
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asi64(R1) = qq_names_getalignment(asi64(R1));
	goto L3214;
	goto L3215;
L3217:
	goto L3215;
L3218:
L3215:
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3220;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3220;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3220;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3220;
	goto L3221;
L3220:
	asi64(R1) = a;
	goto L3214;
	goto L3219;
L3221:
L3219:
	msysc_m$print_startcon();
	R1 = (u64)&qq_tables_ttname;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = a;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Getalign not 1248");
	qq_lib_gerror(asu64(R2), asu64(R1));
	R1 = 0;
	goto L3214;
L3214:
	return asi64(R1);
}

static void qq_names_duplfield(u64 p, u64 q) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L3224;
	R1 = tou64("DUPLFIELD");
	qq_lib_serror(asu64(R1));
L3224:
	asu64(R1) = p;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 96;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 108;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 108;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	return;
}

static void qq_names_writesig(u64 d, u64 dev) {
    u64 R1, R2, R3; 
	u64 e;
	i64 n;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("# #(");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 4;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L3227;
	R1 = tou64("function");
	goto L3226;
L3227:
	R1 = tou64("proc");
L3226:
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	goto L3231;
L3228:
	asu64(R1) = e;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L3233;
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asu64(R1) = e;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L3235;
	asu64(R1) = e;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L3235;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("#=#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = e;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_lib_strexpr(asu64(R1));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L3234;
L3235:
	asu64(R1) = e;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L3236;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("?");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L3234;
L3236:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L3234:
	asi64(R1) = n;
	asu64(R2) = d;
	R3 = 104;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	if (asi64(R1) >= asi64(R2)) goto L3238;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(", ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L3238:
L3233:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L3231:
	asu64(R1) = e;
	if (asu64(R1)) goto L3228;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(")\t[#]");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static u64 qq_names_createdupldef(u64 owner, u64 symptr, i64 id) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	asu64(R1) = qq_names_newstrec();
	p = asu64(R1);
	asu64(R1) = symptr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = symptr;
	R2 = 126;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 126;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 69;
	asu64(R2) = p;
	R3 = 123;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = owner;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = id;
	asu64(R2) = p;
	R3 = 124;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = symptr;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = symptr;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = owner;
	if (!asu64(R1)) goto L3241;
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3243;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = owner;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = owner;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L3242;
L3243:
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3242:
L3241:
	asu64(R1) = p;
	goto L3239;
L3239:
	return asu64(R1);
}

static void qq_packed_var_loadpacked(u64 p, i64 t, u64 dest, u64 ownerobj) {
    u64 R1, R2, R3, R4; 
	i64 length;
	u64 q;
	u64 r;
	u64 pp;
	u64 s;
	u64 ss;
	i64 av_1;
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	switch (asi64(R1)) {
	case 23: goto L3248;
	case 24: goto L3249;
	case 25: goto L3250;
	case 26: goto L3251;
	case 27: goto L3252;
	case 28: goto L3253;
	case 29: goto L3254;
	case 30: goto L3255;
	case 31: goto L3257;
	case 32: goto L3256;
	case 33: case 34: case 35: goto L3247;
	case 36: goto L3258;
	case 37: goto L3261;
	default: goto L3247;
    };
// SWITCH
L3248:
	asu64(R1) = p;
	asi8(R1) = *toi8p(R1);
	R1 = toi64(toi8(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L3245;
L3249:
	asu64(R1) = p;
	asi16(R1) = *toi16p(R1);
	R1 = toi64(toi16(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L3245;
L3250:
	asu64(R1) = p;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L3245;
L3251:
	asu64(R1) = p;
	asi64(R1) = *toi64p(R1);
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L3245;
L3252:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L3245;
L3253:
	asu64(R1) = p;
	asu16(R1) = *tou16p(R1);
	R1 = toi64(tou16(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L3245;
L3254:
	asu64(R1) = p;
	asu32(R1) = *tou32p(R1);
	R1 = toi64(tou32(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L3245;
L3255:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R1) = *tou64p(R1);
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L3245;
L3256:
	R1 = 2;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asr64(R1) = *tor64p(R1);
	asu64(R2) = dest;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L3245;
L3257:
	R1 = 2;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asr32(R1) = *tor32p(R1);
    asr64(R1) = tor64(asr32(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L3245;
L3258:
	R1 = 265;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L3260;
	asi64(R1) = length;
	asu64(R2) = p;
	asi64(R1) = qq_packed_getfslength(asu64(R2), asi64(R1));
	length = asi64(R1);
	goto L3259;
L3260:
	R1 = 1;
	length = asi64(R1);
L3259:
	asi64(R1) = length;
	asu64(R2) = p;
	asu64(R1) = qq_strings_obj_make_strslicexobj(asu64(R2), asi64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L3245;
L3261:
	R1 = 265;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	ss = asu64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3264;
L3262:
	asu64(R1) = ss;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3266;
	goto L3264;
L3266:
	R1 = (u64)&ss;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L3262;
L3264:
	asu64(R1) = ss;
	asu64(R2) = p;
	asi64(R1) -= asi64(R2);
	asu64(R2) = p;
	asu64(R1) = qq_strings_obj_make_strslicexobj(asu64(R2), asi64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L3245;
L3247:
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L3268;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3269;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L3270;
	goto L3271;
L3268:
	R1 = 16;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R1) = *tou64p(R1);
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R2) = dest;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L3267;
L3269:
	asu64(R1) = qq_vars_obj_new();
	s = asu64(R1);
	R1 = 1;
	asu64(R2) = s;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = p;
	asu64(R2) = s;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = s;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 269;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = t;
	asu64(R2) = s;
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = ownerobj;
	if (!asu64(R1)) goto L3273;
	R1 = 1;
	asu64(R2) = s;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = ownerobj;
	asu64(R2) = s;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = ownerobj;
	(*tou32p(R1)) += 1;
	goto L3272;
L3273:
	R1 = 2;
	asu64(R2) = s;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3272:
	goto L3267;
L3270:
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&qq_tables_ttlower;
	asi64(R3) = t;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	R3 = (u64)&qq_tables_tttarget;
	asi64(R4) = t;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	asu64(R1) = qq_arrays_obj_newarray(asi64(R3), asi64(R2), asi64(R1));
	s = asu64(R1);
	R1 = 1;
	asu64(R2) = s;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = p;
	asu64(R2) = s;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = s;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 263;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = t;
	asu64(R2) = s;
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = ownerobj;
	if (!asu64(R1)) goto L3275;
	R1 = 1;
	asu64(R2) = s;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = ownerobj;
	asu64(R2) = s;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = ownerobj;
	(*tou32p(R1)) += 1;
	goto L3274;
L3275:
	R1 = 2;
	asu64(R2) = s;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3274:
	goto L3267;
L3271:
	asi64(R1) = t;
	R2 = (u64)&qq_tables_ttbasetype;
	asi64(R3) = t;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = tou64("loadpacked");
	qq_runaux_pcmxtypestt(asu64(R3), asi64(R2), asi64(R1));
L3267:
L3245:
	return;
}

static void qq_packed_var_storepacked(u64 p, u64 q, i64 t) {
    u64 R1, R2, R3; 
	i64 plength;
	i64 qlength;
	i64 s;
	i64 sbase;
	i64 tbase;
	u64 qa;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	sbase = asi64(R2);
	s = asi64(R1);
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	tbase = asi64(R1);
	asi64(R1) = sbase;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3278;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L3278;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3279;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L3280;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3281;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L3282;
	goto L3283;
L3278:
	asi64(R1) = tbase;
	switch (asi64(R1)) {
	case 16: case 26: case 30: goto L3290;
	case 17: case 18: case 19: case 20: case 21: case 22: goto L3286;
	case 23: case 27: goto L3287;
	case 24: case 28: goto L3288;
	case 25: case 29: goto L3289;
	case 31: goto L3291;
	case 32: goto L3292;
	default: goto L3286;
    };
// SWITCH
L3287:
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L3276;
	goto L3284;
L3288:
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	*tou16p(R2) = asu16(R1);
	goto L3276;
	goto L3284;
L3289:
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	*toi32p(R2) = asi32(R1);
	goto L3276;
	goto L3284;
L3290:
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	*toi64p(R2) = asi64(R1);
	goto L3276;
	goto L3284;
L3291:
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr32(R1) = tor32(asi64(R1));
	asu64(R2) = p;
	*tor32p(R2) = asr32(R1);
	goto L3276;
	goto L3284;
L3292:
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = p;
	*tor64p(R2) = asr64(R1);
	goto L3276;
	goto L3284;
L3286:
L3284:
	goto L3277;
L3279:
	asi64(R1) = tbase;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L3294;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L3294;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L3295;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L3295;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L3296;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L3297;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L3298;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L3298;
	goto L3299;
L3294:
	asu64(R1) = q;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = toi64(asr64(R1));
	asu64(R2) = p;
	*toi32p(R2) = asi32(R1);
	goto L3276;
	goto L3293;
L3295:
	asu64(R1) = q;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = toi64(asr64(R1));
	asu64(R2) = p;
	*toi64p(R2) = asi64(R1);
	goto L3276;
	goto L3293;
L3296:
	asu64(R1) = q;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
    asr32(R1) = tor32(asr64(R1));
	asu64(R2) = p;
	*tor32p(R2) = asr32(R1);
	goto L3276;
	goto L3293;
L3297:
	asu64(R1) = q;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	*tor64p(R2) = asr64(R1);
	goto L3276;
	goto L3293;
L3298:
	asu64(R1) = q;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = toi64(asr64(R1));
	asu64(R2) = p;
	*toi16p(R2) = asi16(R1);
	goto L3276;
	goto L3293;
L3299:
L3293:
	goto L3277;
L3280:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qa = asu64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	plength = asi64(R1);
	asu64(R1) = qa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	qlength = asi64(R1);
	asi64(R1) = tbase;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L3301;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L3302;
	goto L3303;
L3301:
	asi64(R1) = t;
	asi64(R2) = tbase;
	if (asi64(R1) != asi64(R2)) goto L3305;
	asi64(R1) = qlength;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3307;
	R1 = tou64("");
	R2 = tou64("Str not len 1");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L3307:
	asu64(R1) = qa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L3276;
L3305:
	asi64(R1) = qlength;
	asi64(R2) = plength;
	if (asi64(R1) <= asi64(R2)) goto L3309;
	asi64(R1) = plength;
	qlength = asi64(R1);
L3309:
	asi64(R1) = qlength;
	asu64(R2) = qa;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = qlength;
	asi64(R2) = plength;
	asu64(R3) = p;
	qq_packed_setfslength(asu64(R3), asi64(R2), asi64(R1));
	goto L3276;
	goto L3300;
L3302:
	asi64(R1) = qlength;
	asi64(R2) = plength;
	if (asi64(R1) < asi64(R2)) goto L3311;
	asi64(R1) = plength;
	asu64(R2) = qa;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	asi64(R3) = plength;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	goto L3310;
L3311:
	asi64(R1) = qlength;
	asu64(R2) = qa;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	asi64(R3) = qlength;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3310:
	goto L3276;
	goto L3300;
L3303:
L3300:
	goto L3277;
L3281:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	s = asi64(R1);
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) == asi64(R2)) goto L3313;
	asi64(R1) = t;
	asi64(R2) = s;
	R3 = tou64("spack struct");
	qq_runaux_pcmxtypestt(asu64(R3), asi64(R2), asi64(R1));
L3313:
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L3276;
	goto L3277;
L3282:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	s = asi64(R1);
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) == asi64(R2)) goto L3315;
	asi64(R1) = t;
	asi64(R2) = s;
	R3 = tou64("spack array");
	qq_runaux_pcmxtypestt(asu64(R3), asi64(R2), asi64(R1));
L3315:
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L3276;
	goto L3277;
L3283:
L3277:
	asi64(R1) = t;
	asi64(R2) = s;
	R3 = tou64("storepacked (source->dest)");
	qq_runaux_pcmxtypestt(asu64(R3), asi64(R2), asi64(R1));
L3276:
	return;
}

static void qq_packed_setfslength(u64 s, i64 m, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = m;
	asi64(R2) = n;
	if (asi64(R1) != asi64(R2)) goto L3318;
	goto L3317;
L3318:
	asi64(R1) = n;
	asi64(R2) = m;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	if (asi64(R1) != asi64(R2)) goto L3319;
	R1 = 0;
	asu64(R2) = s;
	asi64(R3) = m;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	goto L3317;
L3319:
	R1 = 0;
	asu64(R2) = s;
	asi64(R3) = m;
	R2 += (i64)R3;
	R3 = 2;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asi64(R3) = m;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
L3317:
	return;
}

static i64 qq_packed_getfslength(u64 s, i64 m) {
    u64 R1, R2; 
	asi64(R1) = m;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = s;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3322;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	goto L3321;
L3322:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3323;
	asi64(R1) = m;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	goto L3321;
L3323:
	asi64(R1) = m;
L3321:
	goto L3320;
L3320:
	return asi64(R1);
}

static void qq_packed_var_make_struct(u64 a, u64 dest, i64 n, i64 rectype) {
    u64 R1, R2, R3; 
	u64 d;
	u64 r;
	u64 p;
	u64 b;
	i64 m;
	u64 q;
	i64 av_1;
	asi64(R1) = rectype;
	asu64(R1) = qq_packed_obj_new_struct(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = rectype;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	m = asi64(R1);
	R1 = (u64)&qq_tables_ttnamedef;
	asi64(R2) = rectype;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asi64(R1) = n;
	asi64(R2) = m;
	if (asi64(R1) >= asi64(R2)) goto L3326;
	R1 = tou64("");
	R2 = tou64("Too few elements");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L3325;
L3326:
	asi64(R1) = n;
	asi64(R2) = m;
	if (asi64(R1) <= asi64(R2)) goto L3327;
	msysc_m$print_startcon();
	R1 = tou64("N=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("M=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = m;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("Too many elements");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L3327:
L3325:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3330;
L3328:
	asu64(R1) = r;
	asu64(R1) = *tou64p(R1);
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = a;
	asu64(R3) = q;
	qq_packed_var_storepacked(asu64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = r;
	asu64(R2) = *tou64p(R2);
	R3 = 116;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&q;
	*tou64p(R2) += asu64(R1);
	R1 = (u64)&r;
	(*tou64p(R1)) += 8;
	R1 = (u64)&a;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L3328;
L3330:
	R1 = 269;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = rectype;
	asu64(R2) = p;
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = p;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 qq_packed_obj_new_struct(i64 m) {
    u64 R1, R2, R3; 
	u64 p;
	i64 size;
	asu64(R1) = qq_vars_obj_new();
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = m;
	asu64(R2) = p;
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
	asi64(R1) = size;
	if (!asi64(R1)) goto L3333;
	asi64(R1) = size;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3333:
	asu64(R1) = p;
	goto L3331;
L3331:
	return asu64(R1);
}

static void qq_packed_var_dupl_struct(u64 a) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	i64 size;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R1) = qq_packed_obj_new_struct(asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = size;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = q;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void qq_packed_obj_free_struct(u64 p) {
    u64 R1, R2, R3; 
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = p;
	mlib_pcm_free32(asu64(R1));
	return;
}

static i64 qq_packed_var_equal_struct(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = x;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = y;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = x;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R1) = mlib_eqbytes(asu64(R3), asu64(R2), asi64(R1));
	goto L3336;
L3336:
	return asi64(R1);
}

static void qq_packed_var_getix_struct(u64 a, i64 index) {
    u64 R1, R2, R3, R4, R5, R6; struct $B3 R1_B3; 
	u64 d;
	u64 r;
	struct $B3 v;
	u64 p;
	i64 elemtype;
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	v = (R1_B3);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asi64(R1) = index;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3340;
	asi64(R1) = index;
	R2 = (u64)&qq_tables_ttlength;
	asu64(R3) = a;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	if (asi64(R1) <= asi64(R2)) goto L3339;
L3340:
	R1 = tou64("");
	R2 = tou64("struct[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L3339:
	R1 = (u64)&qq_tables_ttnamedef;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = index;
	R1 += (i64)R2*8;
	R2 = 1;
	R1 -= (i64)R2*8;
	r = asu64(R1);
	R1 = 0;
	asu64(R2) = a;
	asu64(R3) = r;
	asu64(R3) = *tou64p(R3);
	R4 = 116;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	asu64(R4) = p;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R5) = r;
	asu64(R5) = *tou64p(R5);
	R6 = 108;
	asi16(R5) = *toi16p(((i64)R5+(i64)R6));
	R5 = toi64(toi16(R5));
	R4 += (i64)R5;
	qq_packed_var_loadpacked(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void qq_parse_parsemodule(u64 pm) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asu64(R1) = pm;
	R2 = 43;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3343;
	goto L3341;
L3343:
	asu64(R1) = pm;
	qq_decls_currmodule = asu64(R1);
	asu64(R1) = qq_decls_currmodule;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_decls_stcurrmodule = asu64(R1);
	asu64(R1) = qq_decls_currmodule;
	qq_lex_startlex(asu64(R1));
	qq_lex_lex();
	qq_lex_lex();
	asu64(R1) = qq_decls_stcurrmodule;
	qq_decls_stcurrproc = asu64(R1);
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = pm;
	R4 = 48;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = qq_decls_stcurrmodule;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3345;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L3346;
	goto L3347;
L3345:
	R1 = tou64("Comma seq not allowed");
	qq_lib_serror(asu64(R1));
	goto L3344;
L3346:
	goto L3344;
L3347:
	R1 = tou64("EOF");
	qq_lex_ps(asu64(R1));
	R1 = tou64("Bad symbol at eof");
	qq_lib_serror(asu64(R1));
L3344:
L3341:
	return;
}

static u64 qq_parse_readexpression() {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = qq_parse_readterm2();
	p = asu64(R1);
	R1 = (u64)&qq_tables_exprendset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3350;
	asu64(R1) = p;
	goto L3348;
L3350:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3352;
	asu64(R1) = p;
	asu64(R1) = qq_parse_readassignment(asu64(R1));
	goto L3351;
L3352:
	asu64(R1) = p;
	asu64(R1) = qq_parse_readorterms(asu64(R1));
L3351:
	goto L3348;
L3348:
	return asu64(R1);
}

static u64 qq_parse_readassignment(u64 p) {
    u64 R1, R2, R3; 
	i64 pos;
	i64 isdeep;
	u64 q;
	u64 r;
	R1 = (u64)&qq_tables_exprendset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3355;
	asu64(R1) = p;
	goto L3353;
L3355:
	asu64(R1) = p;
	asu64(R1) = qq_parse_readorterms(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3357;
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	isdeep = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	asu64(R1) = qq_parse_readassignment(asu64(R1));
	asu64(R2) = p;
	R3 = 2;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = isdeep;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L3357:
	asu64(R1) = p;
	goto L3353;
L3353:
	return asu64(R1);
}

static u64 qq_parse_readorterms(u64 p) {
    u64 R1, R2, R3; 
	i64 pos;
	u64 q;
	u64 r;
	R1 = (u64)&qq_tables_exprendset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3360;
	asu64(R1) = p;
	goto L3358;
L3360:
	asu64(R1) = p;
	asu64(R1) = qq_parse_readandterms(asu64(R1));
	p = asu64(R1);
	goto L3362;
L3361:
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3365;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = p;
	R3 = 81;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L3363;
L3365:
	asu64(R1) = qq_parse_readterm2();
	asu64(R1) = qq_parse_readandterms(asu64(R1));
	asu64(R2) = p;
	R3 = 73;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L3362:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L3361;
L3363:
	goto L3367;
L3366:
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	R2 = R1;
	r = asu64(R2);
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 26;
	if (asi64(R1) != asi64(R2)) goto L3370;
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	goto L3374;
L3371:
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L3374:
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L3371;
	asu64(R1) = p;
	asu64(R2) = r;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	p = asu64(R1);
	goto L3369;
L3370:
	asu64(R1) = p;
	asu64(R2) = q;
	R3 = 26;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L3369:
L3367:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3366;
	asu64(R1) = p;
	goto L3358;
L3358:
	return asu64(R1);
}

static u64 qq_parse_readandterms(u64 p) {
    u64 R1, R2, R3; 
	i64 pos;
	asu64(R1) = p;
	asu64(R1) = qq_parse_readcmpterms(asu64(R1));
	p = asu64(R1);
	goto L3377;
L3376:
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3380;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = p;
	R3 = 80;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L3378;
L3380:
	asu64(R1) = qq_parse_readterm2();
	asu64(R1) = qq_parse_readcmpterms(asu64(R1));
	asu64(R2) = p;
	R3 = 72;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L3377:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L3376;
L3378:
	asu64(R1) = p;
	goto L3375;
L3375:
	return asu64(R1);
}

static u64 qq_parse_readcmpterms(u64 p) {
    u64 R1, R2, R3; 
	i64 pos;
	i64 n;
	u64 px;
	u64 q;
	u32 conds;
	asu64(R1) = p;
	asu64(R1) = qq_parse_readinterms(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&qq_tables_cmpopset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3383;
	asu64(R1) = p;
	goto L3381;
L3383:
	R1 = (u64)&conds;
	memset(R1, 0, 4);
	asu64(R1) = p;
	px = asu64(R1);
	asu64(R1) = p;
	R2 = 38;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	goto L3385;
L3384:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) <= asi64(R2)) goto L3388;
	R1 = tou64("cmpchain: Too many items");
	qq_lib_serror(asu64(R1));
L3388:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&conds;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	asu64(R1) = qq_parse_readinterms(asu64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = px;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	px = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = q;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L3385:
	R1 = (u64)&qq_tables_cmpopset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3384;
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3390;
	R1 = 71;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&conds;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L3389;
L3390:
	asu32(R1) = conds;
	asu64(R2) = p;
	R3 = 24;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L3389:
	asu64(R1) = p;
	goto L3381;
L3381:
	return asu64(R1);
}

static u64 qq_parse_readinterms(u64 p) {
    u64 R1, R2, R3; 
	i64 pos;
	i64 tag;
	i64 flag;
	asu64(R1) = p;
	asu64(R1) = qq_parse_readrangeterm(asu64(R1));
	p = asu64(R1);
L3392:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L3394;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L3394;
	goto L3395;
L3394:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L3397;
	R1 = 76;
	goto L3396;
L3397:
	R1 = 77;
L3396:
	tag = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	flag = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	asu64(R1) = qq_parse_readrangeterm(asu64(R1));
	asu64(R2) = p;
	asi64(R3) = tag;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = flag;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L3392;
L3395:
	goto L3393;
	goto L3392;
L3393:
	asu64(R1) = p;
	goto L3391;
L3391:
	return asu64(R1);
}

static u64 qq_parse_readrangeterm(u64 p) {
    u64 R1, R2, R3; 
	i64 pos;
	asu64(R1) = p;
	asu64(R1) = qq_parse_readaddterms(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L3400;
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	asu64(R1) = qq_parse_readaddterms(asu64(R1));
	asu64(R2) = p;
	R3 = 87;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L3400:
	asu64(R1) = p;
	goto L3398;
L3398:
	return asu64(R1);
}

static u64 qq_parse_readaddterms(u64 p) {
    u64 R1, R2, R3; 
	i64 pos;
	i64 opc;
	i64 a;
	i64 b;
	i64 tag;
	u64 q;
	asu64(R1) = p;
	asu64(R1) = qq_parse_readmulterms(asu64(R1));
	p = asu64(R1);
	goto L3403;
L3402:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L3406;
	R1 = 119;
	opc = asi64(R1);
L3406:
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3408;
	qq_lex_lex();
	asi64(R1) = opc;
	R2 = 119;
	if (asi64(R1) != asi64(R2)) goto L3410;
	R1 = 84;
	tag = asi64(R1);
	goto L3409;
L3410:
	asi64(R1) = opc;
	R2 = 118;
	if (asi64(R1) != asi64(R2)) goto L3411;
	R1 = 85;
	tag = asi64(R1);
	goto L3409;
L3411:
	R1 = 79;
	tag = asi64(R1);
L3409:
	asu64(R1) = qq_parse_readterm2();
	asu64(R1) = qq_parse_readassignment(asu64(R1));
	asu64(R2) = p;
	asi64(R3) = tag;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L3404;
L3408:
	asu64(R1) = qq_parse_readterm2();
	asu64(R1) = qq_parse_readmulterms(asu64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 63;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L3403:
	R1 = (u64)&qq_tables_addopset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3402;
L3404:
	asu64(R1) = p;
	goto L3401;
L3401:
	return asu64(R1);
}

static u64 qq_parse_readmulterms(u64 p) {
    u64 R1, R2, R3; 
	i64 pos;
	i64 opc;
	i64 a;
	i64 b;
	u64 q;
	asu64(R1) = p;
	asu64(R1) = qq_parse_readpowerterms(asu64(R1));
	p = asu64(R1);
	goto L3414;
L3413:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3417;
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	asu64(R1) = qq_parse_readassignment(asu64(R1));
	asu64(R2) = p;
	R3 = 79;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L3415;
L3417:
	asu64(R1) = qq_parse_readterm2();
	asu64(R1) = qq_parse_readpowerterms(asu64(R1));
	asu64(R2) = p;
	R3 = 63;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L3414:
	R1 = (u64)&qq_tables_mulopset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3413;
L3415:
	asu64(R1) = p;
	goto L3412;
L3412:
	return asu64(R1);
}

static u64 qq_parse_readpowerterms(u64 p) {
    u64 R1, R2, R3; 
	i64 pos;
	goto L3420;
L3419:
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	asu64(R1) = qq_parse_readpowerterms(asu64(R1));
	asu64(R2) = p;
	R3 = 63;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 121;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L3420:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L3419;
	asu64(R1) = p;
	goto L3418;
L3418:
	return asu64(R1);
}

static u64 qq_parse_readterm2() {
    u64 R1, R2; 
	u64 p;
	i64 pos;
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	asu64(R1) = qq_parse_readterm();
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	asu64(R1) = qq_parse_readtermsuffix(asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L3422;
L3422:
	return asu64(R1);
}

static u64 qq_parse_readtermsuffix(u64 p, i64 pos) {
    u64 R1, R2, R3; 
	u64 q;
	u64 r;
	u64 pbyte;
	u64 a;
	i64 opc;
	i64 oldipl;
	i64 shift;
	i64 t;
	i64 nparams;
L3424:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L3426;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L3427;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3428;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3429;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3430;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3431;
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L3432;
	goto L3433;
L3426:
	qq_lex_lex();
	R1 = 1;
	R2 = (u64)&nparams;
	asu64(R1) = qq_parse_readslist(asu64(R2), asi64(R1));
	q = asu64(R1);
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 26;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	asu64(R1) = qq_parse_readcondsuffix(asu64(R1));
	p = asu64(R1);
	goto L3424;
L3427:
	asu64(R1) = p;
	R2 = 51;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	qq_lex_lex();
	goto L3424;
L3428:
	R1 = 0;
	asu64(R2) = p;
	asu64(R1) = qq_parse_readindex(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L3424;
L3429:
	asu64(R1) = p;
	asu64(R1) = qq_parse_readdotsuffix(asu64(R1));
	p = asu64(R1);
	goto L3424;
L3430:
	asu64(R1) = p;
	asu64(R1) = qq_parse_readkeyindex(asu64(R1));
	p = asu64(R1);
	goto L3424;
L3431:
	asi64(R1) = qq_parse_listtype;
	R2 = 331808391504;
	if (asi64(R1) == asi64(R2)) goto L3435;
	R2 = 1413695812;
	if (asi64(R1) == asi64(R2)) goto L3436;
	goto L3437;
L3435:
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = p;
	R3 = 3;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L3434;
L3436:
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = p;
	R3 = 4;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L3434;
L3437:
	goto L3425;
L3434:
	goto L3424;
L3432:
	asu64(R1) = p;
	R2 = 61;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	qq_lex_lex();
	goto L3424;
L3433:
	goto L3425;
	goto L3424;
L3425:
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L3423;
L3423:
	return asu64(R1);
}

static u64 qq_parse_readterm() {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	u64 r;
	u64 pbyte;
	u64 a;
	i64 oldipl;
	i64 opc;
	i64 oldinrp;
	i64 pos;
	i64 shift;
	i64 t;
	i64 nparams;
	i64 length;
	u8 flag;
	u64 s;
	struct $B17 ustr;
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 2: case 114: goto L3509;
	case 3: case 4: case 5: case 6: case 7: case 8: case 10: case 12: case 14: case 16: case 17: case 20: case 21: case 42: case 58: case 59: case 61: case 62: case 68: case 71: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 82: case 83: case 86: case 90: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: case 112: case 113: case 115: case 116: case 118: case 120: case 124: case 128: goto L3441;
	case 9: goto L3450;
	case 11: goto L3486;
	case 13: goto L3535;
	case 15: case 19: goto L3494;
	case 18: case 96: goto L3526;
	case 22: goto L3456;
	case 23: goto L3459;
	case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 37: case 38: case 39: case 40: case 41: case 43: case 44: case 45: case 46: case 47: case 48: case 57: case 132: goto L3483;
	case 36: goto L3487;
	case 49: case 51: goto L3472;
	case 50: case 52: case 53: case 54: goto L3467;
	case 55: goto L3482;
	case 56: goto L3490;
	case 60: goto L3479;
	case 63: goto L3443;
	case 64: goto L3446;
	case 65: goto L3444;
	case 66: goto L3447;
	case 67: goto L3445;
	case 69: goto L3442;
	case 70: goto L3451;
	case 72: goto L3515;
	case 80: goto L3516;
	case 81: case 95: goto L3517;
	case 84: goto L3518;
	case 85: goto L3519;
	case 87: goto L3520;
	case 88: goto L3521;
	case 89: goto L3522;
	case 91: goto L3524;
	case 92: goto L3525;
	case 93: goto L3523;
	case 94: goto L3514;
	case 97: goto L3493;
	case 98: goto L3527;
	case 117: goto L3528;
	case 119: goto L3529;
	case 121: goto L3499;
	case 122: goto L3500;
	case 123: goto L3534;
	case 125: goto L3510;
	case 126: goto L3511;
	case 127: goto L3530;
	case 129: goto L3531;
	case 130: goto L3532;
	case 131: goto L3533;
	default: goto L3441;
    };
// SWITCH
L3442:
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_lib_createname(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	qq_lex_lex();
	goto L3439;
L3443:
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_lib_createintunit(asi64(R1));
	p = asu64(R1);
	qq_lex_lex();
	goto L3439;
L3444:
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_lib_createrealunit(asr64(R1));
	p = asu64(R1);
	qq_lex_lex();
	goto L3439;
L3445:
	R1 = -1;
	R2 = (u64)&qq_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_lib_createstringunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	qq_lex_lex();
	goto L3439;
L3446:
	R1 = -1;
	R2 = (u64)&qq_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_lib_createstringunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	R1 = 44;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	qq_lex_lex();
	goto L3439;
L3447:
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
	R1 = 0;
	R2 = (u64)&ustr;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = length;
	R2 = 8;
	if (asi64(R1) <= asi64(R2)) goto L3449;
	R1 = tou64("char const too long");
	qq_lib_serror(asu64(R1));
L3449:
	asi64(R1) = length;
	R2 = (u64)&qq_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&ustr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&ustr;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_lib_createintunit(asi64(R1));
	p = asu64(R1);
	qq_lex_lex();
	goto L3439;
L3450:
	asu64(R1) = qq_parse_readlbrack();
	p = asu64(R1);
	goto L3439;
L3451:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3453;
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3455;
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 108;
	if (asi64(R1) != asi64(R2)) goto L3455;
	qq_lex_lex();
	qq_lex_lex();
	R1 = 34;
	asu64(R1) = qq_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L3454;
L3455:
	R1 = 53;
	asu64(R1) = qq_lib_createunit0(asi64(R1));
	p = asu64(R1);
L3454:
	goto L3452;
L3453:
	asu64(R1) = qq_parse_readcast();
	p = asu64(R1);
L3452:
	goto L3439;
L3456:
	asu64(R1) = qq_parse_checkoperator();
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L3458;
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	p = asu64(R1);
L3458:
	goto L3439;
L3459:
	asu64(R1) = qq_parse_checkoperator();
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L3461;
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3463;
	R1 = 75;
	opc = asi64(R1);
	goto L3464;
L3463:
	asu64(R1) = qq_parse_readterm2();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L3466;
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = -asi64(R1);
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L3465;
L3466:
	asu64(R1) = p;
	R2 = 62;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 75;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3465:
L3461:
	goto L3439;
L3467:
	asu64(R1) = qq_parse_checkoperator();
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L3469;
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3471;
// qq_parse.readterm.dounaryto:
L3464:
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	R2 = 78;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3470;
L3471:
	asu64(R1) = qq_parse_readterm2();
	R2 = 62;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3470:
L3469:
	goto L3439;
L3472:
	asu64(R1) = qq_parse_checkoperator();
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L3474;
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3476;
	asi64(R1) = opc;
	R2 = 74;
	if (asi64(R1) != asi64(R2)) goto L3478;
	R1 = 82;
	goto L3477;
L3478:
	R1 = 83;
L3477:
	opc = asi64(R1);
	qq_lex_lex();
L3476:
	asu64(R1) = qq_parse_readterm2();
	asi64(R2) = opc;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
L3474:
	goto L3439;
L3479:
	asu64(R1) = qq_parse_checkoperator();
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L3481;
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	R2 = 60;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3481:
	goto L3439;
L3482:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	R2 = 64;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3439;
L3483:
	asu64(R1) = qq_parse_checkoperator();
	R2 = R1;
	p = asu64(R2);
	if (asu64(R1)) goto L3485;
	R1 = tou64("Operator?");
	qq_lib_serror(asu64(R1));
L3485:
	goto L3439;
L3486:
	asu64(R1) = qq_parse_readset();
	p = asu64(R1);
	goto L3439;
L3487:
	asu64(R1) = qq_parse_checkoperator();
	R2 = R1;
	p = asu64(R2);
	if (!asu64(R1)) goto L3489;
	goto L3488;
L3489:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	asu64(R1) = qq_parse_readpair(asi64(R2), asi64(R1));
	p = asu64(R1);
L3488:
	goto L3439;
L3490:
	asu64(R1) = qq_parse_checkoperator();
	R2 = R1;
	p = asu64(R2);
	if (!asu64(R1)) goto L3492;
	goto L3491;
L3492:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 65;
	asu64(R1) = qq_parse_readpair(asi64(R2), asi64(R1));
	p = asu64(R1);
L3491:
	goto L3439;
L3493:
	asu64(R1) = qq_parse_readsprint();
	p = asu64(R1);
	goto L3439;
L3494:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	flag = asu8(R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	R2 = 52;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu8(R1) = flag;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 26;
	if (asi64(R1) != asi64(R2)) goto L3496;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L3498;
	R1 = tou64("Params not allowed");
	qq_lib_serror(asu64(R1));
L3498:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3496:
	goto L3439;
L3499:
	asu64(R1) = qq_parse_readcompilervar();
	p = asu64(R1);
	qq_lex_lex();
	goto L3439;
L3500:
	asi64(R1) = qq_parse_intabledata;
	if (!asi64(R1)) goto L3502;
	asu64(R1) = qq_parse_tabledataname;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3504;
	R1 = tou64("$:No enum");
	qq_lib_serror(asu64(R1));
L3504:
	asu64(R1) = qq_parse_tabledataname;
	s = asu64(R1);
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L3506;
	qq_lex_lex();
	qq_lex_lex();
	R1 = 63;
	qq_lib_checksymbol(asi64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
L3506:
	R1 = -1;
	asu64(R2) = s;
	asu64(R1) = qq_lib_createstringunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L3501;
L3502:
	asi64(R1) = qq_parse_ndollar;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L3508;
	R1 = tou64("[$] No array");
	qq_lib_serror(asu64(R1));
L3508:
	R1 = (u64)&qq_parse_dollarstack;
	asi64(R2) = qq_parse_ndollar;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 66;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 89;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3501:
	qq_lex_lex();
	goto L3439;
L3509:
	R1 = 69;
	qq_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_lib_createname(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	qq_lex_lex();
	goto L3439;
L3510:
	R1 = 0;
	R2 = 37;
	asu64(R1) = qq_parse_readpair(asi64(R2), asi64(R1));
	p = asu64(R1);
	goto L3439;
L3511:
	R1 = 9;
	qq_parse_lexchecksymbol(asi64(R1));
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	p = asu64(R1);
	R1 = 3;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = qq_parse_readexpression();
	q = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3513;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 87;
	if (asi64(R1) != asi64(R2)) goto L3513;
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L3512;
L3513:
	R1 = 3;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = qq_parse_readexpression();
	r = asu64(R1);
	R1 = 10;
	qq_lib_checksymbol(asi64(R1));
L3512:
	qq_lex_lex();
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 63;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	q = asu64(R1);
	R1 = 117;
	asu64(R2) = q;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = r;
	asu64(R2) = q;
	R3 = 63;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 116;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3439;
L3514:
	asu64(R1) = qq_parse_readgoto();
	p = asu64(R1);
	goto L3439;
L3515:
	asu64(R1) = qq_parse_readif();
	p = asu64(R1);
	goto L3439;
L3516:
	asu64(R1) = qq_parse_readunless();
	p = asu64(R1);
	goto L3439;
L3517:
	asu64(R1) = qq_parse_readswitchcase();
	p = asu64(R1);
	goto L3439;
L3518:
	asu64(R1) = qq_parse_readfor();
	p = asu64(R1);
	goto L3439;
L3519:
	asu64(R1) = qq_parse_readto();
	p = asu64(R1);
	goto L3439;
L3520:
	asu64(R1) = qq_parse_readdo();
	p = asu64(R1);
	goto L3439;
L3521:
	asu64(R1) = qq_parse_readwhile();
	p = asu64(R1);
	goto L3439;
L3522:
	asu64(R1) = qq_parse_readrepeat();
	p = asu64(R1);
	goto L3439;
L3523:
	asu64(R1) = qq_parse_readloopcontrol();
	p = asu64(R1);
	goto L3439;
L3524:
	asu64(R1) = qq_parse_readreturn();
	p = asu64(R1);
	goto L3439;
L3525:
	asu64(R1) = qq_parse_readstop();
	p = asu64(R1);
	goto L3439;
L3526:
	asu64(R1) = qq_parse_readprint();
	p = asu64(R1);
	goto L3439;
L3527:
	asu64(R1) = qq_parse_readread();
	p = asu64(R1);
	goto L3439;
L3528:
	asu64(R1) = qq_parse_readtry();
	p = asu64(R1);
	goto L3439;
L3529:
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	R2 = 25;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L3439;
L3530:
	R1 = 0;
	R2 = 29;
	asu64(R1) = qq_parse_readpair(asi64(R2), asi64(R1));
	p = asu64(R1);
	goto L3439;
L3531:
	R1 = 1;
	R2 = 0;
	asu64(R1) = qq_parse_readhostparams(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L3439;
L3532:
	R1 = 28;
	asu64(R1) = qq_lib_createunit0(asi64(R1));
	p = asu64(R1);
	qq_lex_lex();
	goto L3439;
L3533:
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	R2 = 45;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L3439;
L3534:
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	R2 = 33;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L3439;
L3535:
	asu64(R1) = qq_parse_readlambda();
	p = asu64(R1);
	goto L3439;
L3441:
// qq_parse.readterm.error:
	msysc_m$print_startcon();
	R1 = tou64("d");
	R2 = (u64)&qq_tables_symbolnames;
	R3 = (u64)&qq_decls_lx;
	R4 = 12;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	msysc_m$print_u64(asu64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("readterm?");
	qq_lib_serror(asu64(R1));
L3439:
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L3438;
L3438:
	return asu64(R1);
}

static u64 qq_parse_readsunit(i64 inwhile) {
    u64 R1, R2, R3, R4; 
	i64 lineno;
	i64 m;
	i64 globalflag;
	i64 staticflag;
	u64 ulist;
	u64 ulistx;
	u64 p;
	u64 q;
	u64 r;
	u64 stname;
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	lineno = asi64(R1);
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = 0;
	globalflag = asi64(R1);
	R1 = 0;
	staticflag = asi64(R1);
L3538:
	goto L3542;
L3541:
	qq_lex_lex();
L3542:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3541;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 4: goto L3578;
	case 5: case 6: case 8: case 9: case 12: case 13: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 59: case 60: case 61: case 63: case 64: case 65: case 66: case 67: case 68: case 70: case 71: case 72: case 78: case 80: case 81: case 82: case 84: case 85: case 86: case 88: case 89: case 91: case 92: case 93: case 94: case 95: case 96: case 97: case 98: case 101: case 104: case 109: case 112: case 116: case 117: case 119: case 120: case 121: case 122: case 123: goto L3546;
	case 7: case 10: case 14: case 73: case 74: case 75: case 76: case 77: case 79: case 83: case 90: case 118: goto L3565;
	case 11: goto L3579;
	case 62: goto L3564;
	case 69: goto L3566;
	case 87: goto L3571;
	case 99: case 100: goto L3551;
	case 102: case 103: goto L3560;
	case 105: case 106: goto L3574;
	case 107: goto L3562;
	case 108: goto L3559;
	case 110: goto L3552;
	case 111: goto L3563;
	case 113: goto L3556;
	case 114: goto L3548;
	case 115: goto L3547;
	case 124: goto L3561;
	default: goto L3546;
    };
// SWITCH
L3547:
	qq_lex_lex();
	R1 = 1;
	staticflag = asi64(R1);
	goto L3538;
	goto L3544;
L3548:
	asi64(R1) = globalflag;
	if (!asi64(R1)) goto L3550;
	R1 = tou64("global global?");
	qq_lib_serror(asu64(R1));
L3550:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	globalflag = asi64(R1);
	qq_lex_lex();
	goto L3538;
	goto L3544;
L3551:
	asi64(R1) = globalflag;
	qq_parse_readprocdef(asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L3544;
L3552:
	asi64(R1) = staticflag;
	asi64(R2) = globalflag;
	asu64(R1) = qq_parse_readvardef(asi64(R2), asi64(R1));
	q = asu64(R1);
	goto L3554;
L3553:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = r;
	q = asu64(R1);
L3554:
	asu64(R1) = q;
	if (asu64(R1)) goto L3553;
	R1 = 0;
	R2 = R1;
	staticflag = asi64(R2);
	globalflag = asi64(R1);
	goto L3544;
L3556:
	asi64(R1) = staticflag;
	if (!asi64(R1)) goto L3558;
	R1 = tou64("static?");
	qq_lib_serror(asu64(R1));
L3558:
	asi64(R1) = globalflag;
	qq_parse_readconstdef(asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L3544;
L3559:
	asi64(R1) = globalflag;
	qq_parse_readtypedef(asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L3544;
L3560:
	R1 = 0;
	asi64(R2) = globalflag;
	qq_parse_readrecorddef(asi64(R2), asu64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L3544;
L3561:
	asi64(R1) = globalflag;
	qq_parse_readtabledef(asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L3544;
L3562:
	qq_parse_readimportdll();
	goto L3544;
L3563:
	asi64(R1) = globalflag;
	qq_parse_readmacrodef(asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L3544;
L3564:
	goto L3540;
	goto L3544;
L3565:
	goto L3540;
	goto L3544;
L3566:
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3568;
	goto L3569;
L3568:
	R1 = 0;
	R2 = 17;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = qq_lib_createname(asu64(R1));
	R2 = 1;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	qq_lex_lex();
	R1 = 4;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	goto L3567;
L3569:
	goto L3570;
L3567:
	goto L3544;
L3571:
	asi64(R1) = inwhile;
	if (!asi64(R1)) goto L3573;
	goto L3540;
L3573:
	goto L3570;
	goto L3544;
L3574:
L3575:
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3575;
	goto L3544;
L3578:
	goto L3544;
L3579:
	goto L3570;
	goto L3544;
L3546:
// qq_parse.readsunit.doexec:
L3570:
	asu64(R1) = qq_parse_readexpression();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L3581;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L3581;
	R1 = tou64("Possibly var/let needed");
	qq_lib_serror(asu64(R1));
L3581:
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 87;
	if (asi64(R1) != asi64(R2)) goto L3583;
	goto L3540;
L3583:
L3544:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3538;
L3540:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3585;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L3585;
	R2 = 74;
	if (asi64(R1) == asi64(R2)) goto L3585;
	R2 = 75;
	if (asi64(R1) == asi64(R2)) goto L3585;
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L3585;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L3585;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L3585;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L3585;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L3585;
	R2 = 77;
	if (asi64(R1) == asi64(R2)) goto L3585;
	R2 = 118;
	if (asi64(R1) == asi64(R2)) goto L3585;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L3585;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L3585;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3585;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L3585;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L3585;
	goto L3586;
L3585:
	goto L3584;
L3586:
	R1 = tou64("Readsunit: \";\" expected, or bad unit starter");
	qq_lib_serror(asu64(R1));
L3584:
	asu64(R1) = ulist;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3589;
	asu64(R1) = ulist;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L3588;
L3589:
	asu64(R1) = ulist;
	R2 = 6;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	goto L3587;
L3588:
	asu64(R1) = ulist;
L3587:
	goto L3537;
L3537:
	return asu64(R1);
}

static void qq_parse_checkequals() {
    u64 R1, R2; 
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L3592;
	R1 = tou64("\"=\" expected");
	qq_lib_serror(asu64(R1));
L3592:
	return;
}

static u64 qq_parse_readindex(u64 p, i64 dot) {
    u64 R1, R2, R3; 
	u64 q;
	u64 plower;
	u64 pupper;
	qq_lex_lex();
L3594:
	asi64(R1) = qq_parse_ndollar;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L3597;
	R1 = tou64("Too many nested a[$]");
	qq_lib_serror(asu64(R1));
L3597:
	asu64(R1) = p;
	R2 = (u64)&qq_parse_dollarstack;
	R3 = (u64)&qq_parse_ndollar;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = qq_parse_readexpression();
	q = asu64(R1);
	R1 = (u64)&qq_parse_ndollar;
	(*toi64p(R1)) -=1;
	asu64(R1) = q;
	asu64(R2) = p;
	asi64(R3) = dot;
	if (!asi64(R3)) goto L3599;
	R3 = 48;
	goto L3598;
L3599:
	R3 = 47;
L3598:
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3601;
	goto L3595;
L3601:
	qq_lex_lex();
	goto L3594;
L3595:
	R1 = 12;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = p;
	goto L3593;
L3593:
	return asu64(R1);
}

static u64 qq_parse_readdotsuffix(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	i64 t;
	u8 flag;
	goto L3604;
L3603:
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3607;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L3608;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L3609;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L3610;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L3611;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L3612;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L3613;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L3614;
	goto L3615;
L3607:
	R1 = 1;
	asu64(R2) = p;
	asu64(R1) = qq_parse_readindex(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L3606;
L3608:
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_lib_createname(asu64(R1));
	asu64(R2) = p;
	R3 = 46;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	qq_lex_lex();
	goto L3606;
L3609:
// qq_parse.readdotsuffix.doprop:
L3616:
	asu64(R1) = p;
	R2 = 66;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	qq_lex_lex();
	goto L3606;
L3610:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L3618;
	R1 = 1;
	flag = asu8(R1);
// qq_parse.readdotsuffix.dogettype:
L3619:
	asu64(R1) = p;
	R2 = 68;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu8(R1) = flag;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3618:
	qq_lex_lex();
	goto L3606;
L3611:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 116;
	if (asi64(R1) != asi64(R2)) goto L3621;
	R1 = 95;
	goto L3620;
L3621:
	R1 = 96;
L3620:
	R2 = (u64)&qq_decls_lx;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3616;
	goto L3606;
L3612:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 98;
	if (asi64(R1) == asi64(R2)) goto L3623;
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L3624;
	goto L3625;
L3623:
	R1 = 0;
	flag = asu8(R1);
	goto L3619;
	goto L3622;
L3624:
	R1 = 2;
	flag = asu8(R1);
	goto L3619;
	goto L3622;
L3625:
	asu64(R1) = p;
	R2 = 70;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 118;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	qq_lex_lex();
L3622:
	goto L3606;
L3613:
	asu64(R1) = p;
	R2 = 69;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	qq_lex_lex();
	goto L3606;
L3614:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L3627;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L3627;
	R1 = tou64("...name.$ needed");
	qq_lib_serror(asu64(R1));
L3627:
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	qq_lex_lex();
	goto L3606;
L3615:
	R1 = tou64("Unknown dot suffix");
	qq_lib_serror(asu64(R1));
L3606:
L3604:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3603;
	asu64(R1) = p;
	goto L3602;
L3602:
	return asu64(R1);
}

static u64 qq_parse_readslist(u64 nparams, i64 ftrailing) {
    u64 R1, R2, R3; 
	u64 ulist;
	u64 ulistx;
	i64 oldinparamlist;
	i64 donulls;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = 0;
	asu64(R2) = nparams;
	*toi64p(R2) = asi64(R1);
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3630;
	asu64(R1) = ulist;
	goto L3628;
L3630:
	R1 = 331808391504;
	qq_parse_pushlisttype(asi64(R1));
	R1 = 1;
	donulls = asi64(R1);
L3631:
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3634;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3635;
	goto L3636;
L3634:
	R1 = tou64("null comma expr not allowed");
	qq_lib_serror(asu64(R1));
	goto L3633;
L3635:
	goto L3632;
	goto L3633;
L3636:
	asu64(R1) = qq_parse_readexpression();
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = nparams;
	(*toi64p(R1)) += 1;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3638;
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3640;
	asu64(R1) = nparams;
	asi64(R1) = *toi64p(R1);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3643;
	asi64(R1) = ftrailing;
	if (asi64(R1)) goto L3642;
L3643:
	R1 = tou64("Trailing comma");
	qq_lib_serror(asu64(R1));
L3642:
	goto L3632;
L3640:
	goto L3637;
L3638:
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3645;
	goto L3632;
L3645:
	R1 = tou64("SLIST?");
	qq_lib_serror(asu64(R1));
L3637:
L3633:
	goto L3631;
L3632:
	qq_parse_poplisttype();
	asu64(R1) = ulist;
	goto L3628;
L3628:
	return asu64(R1);
}

static u64 qq_parse_readcondsuffix(u64 p) {
    u64 R1, R2, R3; 
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L3648;
	R2 = 80;
	if (asi64(R1) == asi64(R2)) goto L3649;
	goto L3650;
L3648:
	qq_lex_lex();
	asu64(R1) = p;
	R2 = 6;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R2) = qq_parse_readexpression();
	R3 = 7;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L3647;
L3649:
	qq_lex_lex();
	asu64(R1) = p;
	R2 = 6;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R2) = qq_parse_readexpression();
	R3 = 74;
	asu64(R2) = qq_lib_createunit1(asi64(R3), asu64(R2));
	R3 = 7;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L3647;
L3650:
	asu64(R1) = p;
L3647:
	goto L3646;
L3646:
	return asu64(R1);
}

static u64 qq_parse_readkeyindex(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	q = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3653;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3653:
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 49;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 14;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = p;
	goto L3651;
L3651:
	return asu64(R1);
}

static u64 qq_parse_readlbrack() {
    u64 R1, R2, R3; 
	u64 ulist;
	u64 ulistx;
	u64 p;
	u64 q;
	u64 r;
	i64 oldirp;
	i64 length;
	i64 lower;
	i64 lowerseen;
	i64 elemtype;
	i64 opc;
	qq_lex_lex();
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = 0;
	length = asi64(R1);
	R1 = 1;
	lower = asi64(R1);
	R1 = 0;
	lowerseen = asi64(R1);
	R1 = 0;
	elemtype = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 70;
	if (asi64(R1) != asi64(R2)) goto L3656;
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3656;
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	elemtype = asi64(R1);
	qq_lex_lex();
	qq_lex_lex();
L3656:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L3658;
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3658;
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	lower = asi64(R1);
	R1 = 1;
	lowerseen = asi64(R1);
	qq_lex_lex();
	qq_lex_lex();
L3658:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3660;
	goto L3661;
L3660:
	qq_lex_lex();
	R1 = 88;
	asu64(R1) = qq_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = lower;
	asu64(R2) = p;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = elemtype;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L3654;
	goto L3659;
L3661:
	R1 = (u64)&qq_tables_binopset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3664;
	R1 = (u64)&qq_tables_unaryopset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3664;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L3663;
L3664:
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3663;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L3666;
	R1 = 119;
	opc = asi64(R1);
	goto L3665;
L3666:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
L3665:
// qq_parse.readlbrack.doopc:
L3667:
	R1 = 5;
	asu64(R1) = qq_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	qq_lex_lex();
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = p;
	goto L3654;
	goto L3662;
L3663:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 132;
	if (asi64(R1) == asi64(R2)) goto L3669;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L3670;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L3671;
	goto L3672;
L3669:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L3674;
	R2 = 23899;
	if (asi64(R1) == asi64(R2)) goto L3675;
	goto L3676;
L3674:
	R1 = 75;
	opc = asi64(R1);
	goto L3673;
L3675:
	R1 = 130;
	opc = asi64(R1);
	goto L3673;
L3676:
	R1 = 0;
	opc = asi64(R1);
L3673:
	goto L3667;
	goto L3668;
L3670:
	R1 = 113;
	opc = asi64(R1);
	goto L3667;
	goto L3668;
L3671:
	R1 = 114;
	opc = asi64(R1);
	goto L3667;
	goto L3668;
L3672:
	asu64(R1) = qq_parse_readexpression();
	p = asu64(R1);
L3668:
L3662:
L3659:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3678;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3679;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L3680;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3681;
	goto L3682;
L3678:
	qq_lex_lex();
	asi64(R1) = lowerseen;
	if (!asi64(R1)) goto L3684;
	asu64(R1) = p;
	asi64(R2) = lower;
	asu64(R2) = qq_lib_createintunit(asi64(R2));
	R3 = 4;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L3684:
	asu64(R1) = p;
	goto L3654;
	goto L3677;
L3679:
	R1 = 1;
	length = asi64(R1);
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3686;
	qq_lex_lex();
	qq_lex_lex();
	asu64(R1) = p;
	R2 = 88;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = lower;
	asu64(R2) = p;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = elemtype;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L3654;
L3686:
	asu64(R1) = p;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L3687:
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3691;
	goto L3689;
L3691:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3693;
	R1 = tou64(", , null expr not allowed");
	qq_lib_serror(asu64(R1));
L3693:
	asu64(R1) = qq_parse_readexpression();
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3687;
L3689:
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = ulist;
	R2 = 88;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = lower;
	asu64(R2) = p;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = elemtype;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L3654;
	goto L3677;
L3680:
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	q = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L3695;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3696;
	goto L3697;
L3695:
	qq_lex_lex();
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	r = asu64(R1);
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = r;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 7;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L3654;
	goto L3694;
L3696:
	qq_lex_lex();
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 7;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L3654;
	goto L3694;
L3697:
L3694:
	asu64(R1) = q;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = 3;
	qq_lib_checksymbol(asi64(R1));
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L3699;
L3700:
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3700;
	R1 = 16;
	qq_lib_checksymbol(asi64(R1));
	goto L3698;
L3699:
	qq_lex_lex();
L3698:
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	r = asu64(R1);
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = r;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = ulist;
	asu64(R2) = p;
	R3 = 8;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L3654;
	goto L3677;
L3681:
	asu64(R1) = p;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L3703:
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3707;
	goto L3705;
L3707:
	asu64(R1) = qq_parse_readexpression();
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3703;
L3705:
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = ulist;
	asu64(R1) = qq_parse_makeblock(asu64(R1));
	goto L3654;
	goto L3677;
L3682:
	R1 = tou64("(x ...");
	qq_lib_serror(asu64(R1));
L3677:
	R1 = 0;
	goto L3654;
L3654:
	return asu64(R1);
}

static u64 qq_parse_readif() {
    u64 R1, R2, R3; 
	i64 line;
	i64 kwd;
	i64 lineno;
	u64 pthen;
	u64 pcond;
	u64 plist;
	u64 plistx;
	u64 pelse;
	u64 p;
	u64 pelsif;
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	line = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	qq_lex_lex();
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pcond = asu64(R1);
	qq_lib_skipsemi();
	R1 = 73;
	qq_lib_skipsymbol(asi64(R1));
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pthen = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 74;
	if (asi64(R1) == asi64(R2)) goto L3710;
	R2 = 75;
	if (asi64(R1) == asi64(R2)) goto L3711;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L3712;
	R2 = 77;
	if (asi64(R1) == asi64(R2)) goto L3712;
	goto L3713;
L3710:
	R1 = 72;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = qq_parse_readif();
	pelse = asu64(R1);
	goto L3709;
L3711:
	qq_lex_lex();
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pelse = asu64(R1);
	R1 = 0;
	R2 = 0;
	asi64(R3) = kwd;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	goto L3709;
L3712:
	asi64(R1) = kwd;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = qq_parse_readswitchcase();
	asu64(R1) = qq_parse_makeblock(asu64(R1));
	pelse = asu64(R1);
	goto L3709;
L3713:
	R1 = 0;
	pelse = asu64(R1);
	R1 = 0;
	R2 = 0;
	asi64(R3) = kwd;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
L3709:
	asu64(R1) = pelse;
	asu64(R2) = pthen;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pthen;
	asu64(R2) = pcond;
	R3 = 7;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = line;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L3708;
L3708:
	return asu64(R1);
}

static void qq_parse_checkend(i64 endkwd1, i64 endkwd2, i64 startline) {
    u64 R1, R2; 
	struct $B16 str;
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L3716;
	R1 = tou64("'End' expected");
	qq_lib_serror(asu64(R1));
L3716:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3718;
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = endkwd1;
	if (asi64(R1) == asi64(R2)) goto L3721;
	asi64(R2) = endkwd2;
	if (asi64(R1) != asi64(R2)) goto L3720;
L3721:
	qq_lex_lex();
	goto L3714;
	goto L3719;
L3720:
// qq_parse.checkend.error:
L3722:
	R1 = tou64("Mismatched end ");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = startline;
	if (!asi64(R1)) goto L3724;
	R1 = (u64)&str;
	R2 = (u64)&str;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64(" (from line #)");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = startline;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L3724:
	R1 = (u64)&str;
	qq_lib_serror(asu64(R1));
L3719:
L3718:
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = endkwd1;
	if (asi64(R1) == asi64(R2)) goto L3727;
	asi64(R2) = endkwd2;
	if (asi64(R1) != asi64(R2)) goto L3726;
L3727:
	qq_lex_lex();
	goto L3725;
L3726:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3728;
	goto L3722;
L3728:
L3725:
L3714:
	return;
}

static u64 qq_parse_readunless() {
    u64 R1, R2, R3; 
	i64 line;
	u64 pcond;
	u64 pthen;
	u64 pelse;
	u64 p;
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	line = asi64(R1);
	qq_lex_lex();
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pcond = asu64(R1);
	R1 = 73;
	qq_lib_skipsymbol(asi64(R1));
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pthen = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 75;
	if (asi64(R1) != asi64(R2)) goto L3731;
	qq_lex_lex();
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pelse = asu64(R1);
	goto L3730;
L3731:
	R1 = 0;
	pelse = asu64(R1);
L3730:
	R1 = 0;
	R2 = 0;
	R3 = 80;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pelse;
	asu64(R2) = pthen;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pthen;
	asu64(R2) = pcond;
	R3 = 74;
	asu64(R2) = qq_lib_createunit1(asi64(R3), asu64(R2));
	R3 = 7;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = line;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L3729;
L3729:
	return asu64(R1);
}

static u64 qq_parse_readwhile() {
    u64 R1, R2, R3; 
	i64 pos;
	u64 pcond;
	u64 pbody;
	u64 p;
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	qq_lex_lex();
	R1 = 1;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pcond = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3734;
	qq_lex_lex();
	R1 = 1;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	asu64(R2) = pcond;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3734:
	R1 = 87;
	qq_lib_skipsymbol(asi64(R1));
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pbody = asu64(R1);
	R1 = 0;
	R2 = 87;
	R3 = 88;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pbody;
	asu64(R2) = pcond;
	R3 = 21;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L3732;
L3732:
	return asu64(R1);
}

static u64 qq_parse_readrepeat() {
    u64 R1, R2, R3; 
	i64 pos;
	u64 pbody;
	u64 pcond;
	u64 p;
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	qq_lex_lex();
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pbody = asu64(R1);
	R1 = 90;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = qq_parse_readexpression();
	pcond = asu64(R1);
	asu64(R1) = pcond;
	asu64(R2) = pbody;
	R3 = 22;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L3735;
L3735:
	return asu64(R1);
}

static u64 qq_parse_readfor() {
    u64 R1, R2, R3; 
	i64 line;
	i64 opc;
	i64 down;
	i64 isforeach;
	u64 pstep;
	u64 pvar;
	u64 pcond;
	u64 pfrom;
	u64 pto;
	u64 pelse;
	u64 pbody;
	u64 p;
	u64 plist;
	u64 pvar2;
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	line = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	isforeach = asi64(R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	pvar = asu64(R1);
	asu64(R1) = pvar;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L3738;
	R1 = tou64("For: name expected");
	qq_lib_serror(asu64(R1));
	goto L3737;
L3738:
	R1 = 1;
	asu64(R2) = pvar;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 122;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3737:
	R1 = 15;
	opc = asi64(R1);
	R1 = 0;
	pstep = asu64(R1);
	R1 = 0;
	pcond = asu64(R1);
	R1 = 0;
	pvar2 = asu64(R1);
	R1 = 0;
	down = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3740;
	qq_lex_lex();
	asu64(R1) = qq_parse_readterm2();
	pvar2 = asu64(R1);
L3740:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L3742;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	plist = asu64(R1);
	asu64(R1) = plist;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L3744;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L3745;
	goto L3746;
L3744:
	asu64(R1) = plist;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pfrom = asu64(R1);
	asu64(R1) = plist;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pto = asu64(R1);
	goto L3743;
L3745:
	R1 = 1;
	asu64(R2) = plist;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 16;
	opc = asi64(R1);
	goto L3743;
L3746:
	R1 = 17;
	opc = asi64(R1);
L3743:
	goto L3741;
L3742:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3748;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	pfrom = asu64(R1);
	goto L3747;
L3748:
	R1 = 1;
	asu64(R1) = qq_lib_createintunit(asi64(R1));
	pfrom = asu64(R1);
L3747:
	R1 = 85;
	qq_lib_checksymbol(asi64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	down = asi64(R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	pto = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 86;
	if (asi64(R1) != asi64(R2)) goto L3750;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	pstep = asu64(R1);
	asu64(R1) = pstep;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L3752;
	R1 = tou64("BY needs int constant");
	qq_lib_serror(asu64(R1));
L3752:
	asu64(R1) = pstep;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L3754;
	R1 = tou64("Step must be positive");
	qq_lib_serror(asu64(R1));
	goto L3753;
L3754:
	asu64(R1) = pstep;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3755;
	R1 = tou64("Zero step");
	qq_lib_serror(asu64(R1));
L3755:
L3753:
	asu64(R1) = pstep;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	asu64(R2) = pstep;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pstep;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3757;
	R1 = 0;
	pstep = asu64(R1);
L3757:
L3750:
L3741:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L3759;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	pcond = asu64(R1);
L3759:
	R1 = 87;
	qq_lib_skipsymbol(asi64(R1));
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pbody = asu64(R1);
	asu64(R1) = pcond;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3761;
	asu64(R1) = pbody;
	asu64(R2) = pcond;
	R3 = 7;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = qq_parse_makeblock(asu64(R1));
	pbody = asu64(R1);
L3761:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 75;
	if (asi64(R1) != asi64(R2)) goto L3763;
	qq_lex_lex();
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pelse = asu64(R1);
	asu64(R1) = pelse;
	asu64(R2) = pbody;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L3762;
L3763:
	R1 = 0;
	pelse = asu64(R1);
L3762:
	R1 = 0;
	R2 = 87;
	R3 = 84;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = opc;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L3765;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L3766;
	goto L3767;
L3765:
	asu64(R1) = plist;
	asu64(R2) = pvar;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pvar2;
	asu64(R2) = plist;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pbody;
	asu64(R2) = pvar;
	asi64(R3) = opc;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L3764;
L3766:
	asu64(R1) = plist;
	asu64(R2) = pvar;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pbody;
	asu64(R2) = pvar;
	asi64(R3) = opc;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L3764;
L3767:
	asu64(R1) = pfrom;
	asu64(R2) = pvar;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pto;
	asu64(R2) = pfrom;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pstep;
	asu64(R2) = pto;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pbody;
	asu64(R2) = pvar;
	asi64(R3) = opc;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L3764:
	asi64(R1) = down;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = isforeach;
	if (!asi64(R1)) goto L3769;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L3771;
	R1 = 18;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3770;
L3771:
	R1 = tou64("Foreach?");
	qq_lib_serror(asu64(R1));
L3770:
L3769:
	asi64(R1) = line;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = pvar2;
	if (!asu64(R1)) goto L3773;
	asi64(R1) = opc;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L3773;
	R1 = tou64("for i, j not allowed");
	qq_lib_serror(asu64(R1));
L3773:
	asu64(R1) = p;
	goto L3736;
L3736:
	return asu64(R1);
}

static u64 qq_parse_readdo() {
    u64 R1, R2, R3; 
	u64 p;
	i64 line;
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	line = asi64(R1);
	qq_lex_lex();
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	p = asu64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 87;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 19;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = line;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L3774;
L3774:
	return asu64(R1);
}

static u64 qq_parse_readto() {
    u64 R1, R2, R3; 
	i64 line;
	i64 id;
	u64 p;
	u64 pcount;
	u64 pbody;
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	line = asi64(R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	pcount = asu64(R1);
	R1 = 87;
	qq_lib_skipsymbol(asi64(R1));
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pbody = asu64(R1);
	R1 = 0;
	R2 = 87;
	R3 = 85;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = qq_lib_createavname();
	asu64(R2) = pcount;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pbody;
	asu64(R2) = pcount;
	R3 = 20;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = line;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L3775;
L3775:
	return asu64(R1);
}

static u64 qq_parse_makeblock(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 6;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	goto L3776;
L3776:
	return asu64(R1);
}

static u64 qq_parse_readvardef(i64 isglobal, i64 isstatic) {
    u64 R1, R2, R3, R4; 
	i64 nvars;
	i64 varid;
	i64 opc;
	u64 d;
	u64 ulist;
	u64 ulistx;
	u64 p;
	qq_lex_lex();
	asu64(R1) = qq_decls_stcurrproc;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3780;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3779;
L3780:
	asi64(R1) = isstatic;
	if (!asi64(R1)) goto L3782;
	R1 = 13;
	goto L3781;
L3782:
	R1 = 14;
L3781:
	varid = asi64(R1);
	goto L3778;
L3779:
	R1 = 13;
	varid = asi64(R1);
L3778:
	R1 = 0;
	nvars = asi64(R1);
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	goto L3784;
L3783:
	R1 = (u64)&nvars;
	(*toi64p(R1)) += 1;
	asi64(R1) = isglobal;
	asi64(R2) = varid;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L3787;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L3788;
	goto L3789;
L3787:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	asi64(R1) = varid;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L3791;
	asu64(R1) = qq_decls_stcurrproc;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3794;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3793;
L3794:
	R1 = tou64("Need '=' for static in proc");
	qq_lib_serror(asu64(R1));
L3793:
L3791:
	asi64(R1) = opc;
	R2 = 2;
	asu64(R1) += asu64(R2);
	asu64(R2) = d;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 11;
	R4 = 12;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = d;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = varid;
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L3796;
	asu64(R1) = d;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	asu64(R2) = qq_lib_createname(asu64(R2));
	R3 = 2;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L3796:
	goto L3786;
L3788:
	asi64(R1) = varid;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3798;
	R1 = tou64("Need ':=' for non-static");
	qq_lib_serror(asu64(R1));
L3798:
	qq_lex_lex();
	R1 = 1;
	asu64(R2) = d;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 11;
	R4 = 12;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = d;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L3786;
L3789:
L3786:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3800;
	goto L3785;
L3800:
	qq_lex_lex();
L3784:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L3783;
L3785:
	asi64(R1) = nvars;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3802;
	R1 = tou64("No vars declared");
	qq_lib_serror(asu64(R1));
L3802:
	asu64(R1) = ulist;
	goto L3777;
L3777:
	return asu64(R1);
}

static void qq_parse_readconstdef(i64 isglobal) {
    u64 R1, R2, R3, R4; 
	i64 nvars;
	u64 d;
	qq_lex_lex();
	R1 = 0;
	nvars = asi64(R1);
	goto L3805;
L3804:
	R1 = (u64)&nvars;
	(*toi64p(R1)) += 1;
	asi64(R1) = isglobal;
	R2 = 18;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 43;
	qq_parse_lexchecksymbol(asi64(R1));
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = d;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3808;
	goto L3806;
L3808:
	qq_lex_lex();
L3805:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L3804;
L3806:
	asi64(R1) = nvars;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3810;
	R1 = tou64("No consts declared");
	qq_lib_serror(asu64(R1));
L3810:
	return;
}

static u64 qq_parse_readreturn() {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	u64 r;
	qq_lex_lex();
	R1 = 0;
	q = asu64(R1);
	R1 = (u64)&qq_tables_exprstarterset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3813;
	asu64(R1) = qq_parse_readexpression();
	q = asu64(R1);
L3813:
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	asu64(R1) = qq_parse_readcondsuffix(asu64(R1));
	goto L3811;
L3811:
	return asu64(R1);
}

static u64 qq_parse_readprint() {
    u64 R1, R2, R3; 
	i64 opc;
	i64 flags;
	i64 fshowname;
	i64 length;
	u64 pformat;
	u64 pdev;
	u64 printlist;
	u64 printlistx;
	u64 p;
	u64 q;
	u64 expr;
	u64 s;
	R1 = 362090680912;
	qq_parse_pushlisttype(asi64(R1));
	R1 = 54;
	opc = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	flags = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L3816;
	R1 = 1;
	flags = asi64(R1);
	goto L3815;
L3816:
	asi64(R1) = flags;
	R2 = 2;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L3817;
	R1 = 55;
	opc = asi64(R1);
L3817:
L3815:
	qq_lex_lex();
	R1 = 0;
	R2 = R1;
	printlistx = asu64(R2);
	printlist = asu64(R1);
	R1 = 0;
	R2 = R1;
	pdev = asu64(R2);
	pformat = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L3819;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	pdev = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3821;
	qq_lex_lex();
	goto L3820;
L3821:
	goto L3822;
L3820:
L3819:
	asi64(R1) = opc;
	R2 = 55;
	if (asi64(R1) != asi64(R2)) goto L3824;
	asu64(R1) = qq_parse_readexpression();
	pformat = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3826;
	qq_lex_lex();
	goto L3825;
L3826:
	goto L3822;
L3825:
L3824:
	R1 = (u64)&qq_tables_exprstarterset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3828;
	goto L3822;
L3828:
L3829:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3832;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L3833;
	goto L3834;
L3832:
	R1 = 56;
	asu64(R1) = qq_lib_createunit0(asi64(R1));
	R2 = (u64)&printlistx;
	R3 = (u64)&printlist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	goto L3831;
L3833:
	R1 = 57;
	asu64(R1) = qq_lib_createunit0(asi64(R1));
	R2 = (u64)&printlistx;
	R3 = (u64)&printlist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	qq_lex_lex();
	goto L3831;
L3834:
	R1 = 0;
	fshowname = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) != asi64(R2)) goto L3836;
	R1 = 1;
	fshowname = asi64(R1);
	qq_lex_lex();
L3836:
	asu64(R1) = qq_parse_readexpression();
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3838;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = p;
	R3 = 58;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L3838:
	asi64(R1) = fshowname;
	if (!asi64(R1)) goto L3840;
	asu64(R1) = p;
	asu64(R1) = qq_lib_strexpr(asu64(R1));
	expr = asu64(R1);
	R1 = -1;
	R2 = tou64("=");
	asu64(R3) = expr;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = expr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asu64(R1) = expr;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = expr;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_iconvucn(asu64(R2), asi64(R1));
	asu64(R1) = expr;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = s;
	asu64(R1) = qq_lib_createstringunit(asu64(R2), asi64(R1));
	R2 = R1;
	q = asu64(R2);
	R2 = (u64)&printlistx;
	R3 = (u64)&printlist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L3840:
	asu64(R1) = p;
	R2 = (u64)&printlistx;
	R3 = (u64)&printlist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L3831:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3842;
	goto L3830;
L3842:
	qq_lex_lex();
	goto L3829;
L3830:
// qq_parse.readprint.finish:
L3822:
	asi64(R1) = flags;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L3844;
	asi64(R1) = opc;
	R2 = 54;
	if (asi64(R1) != asi64(R2)) goto L3848;
	asu64(R1) = printlist;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3847;
L3848:
	asi64(R1) = opc;
	R2 = 55;
	if (asi64(R1) != asi64(R2)) goto L3846;
	asu64(R1) = printlist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3846;
	asu64(R1) = pformat;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3846;
L3847:
	R1 = tou64("No print items");
	qq_lib_serror(asu64(R1));
L3846:
L3844:
	qq_parse_poplisttype();
	asi64(R1) = opc;
	R2 = 55;
	if (asi64(R1) != asi64(R2)) goto L3850;
	asu64(R1) = pformat;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3852;
	R1 = tou64("No fmt str");
	qq_lib_serror(asu64(R1));
L3852:
	asu64(R1) = pformat;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3854;
	asu64(R1) = pformat;
	asu64(R1) = qq_parse_makeblock(asu64(R1));
	pformat = asu64(R1);
L3854:
	asu64(R1) = printlist;
	asu64(R2) = pformat;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pformat;
	asu64(R2) = pdev;
	asi64(R3) = opc;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L3849;
L3850:
	asu64(R1) = printlist;
	asu64(R2) = pdev;
	asi64(R3) = opc;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L3849:
	asi64(R1) = flags;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L3814;
L3814:
	return asu64(R1);
}

static u64 qq_parse_readread() {
    u64 R1, R2, R3; 
	i64 opc;
	i64 flags;
	u64 pformat;
	u64 pdev;
	u64 readlist;
	u64 readlistx;
	u64 p;
	R1 = 362090680912;
	qq_parse_pushlisttype(asi64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	flags = asi64(R1);
	qq_lex_lex();
	R1 = 0;
	R2 = R1;
	readlistx = asu64(R2);
	readlist = asu64(R1);
	R1 = 0;
	R2 = R1;
	pdev = asu64(R2);
	pformat = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L3857;
	asi64(R1) = opc;
	R2 = 59;
	if (asi64(R1) != asi64(R2)) goto L3859;
	R1 = tou64("@ on read");
	qq_lib_serror(asu64(R1));
L3859:
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	pdev = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3861;
	qq_lex_lex();
	goto L3860;
L3861:
	goto L3862;
L3860:
L3857:
	R1 = (u64)&qq_tables_exprstarterset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3864;
	goto L3862;
L3864:
L3865:
	asu64(R1) = qq_parse_readexpression();
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3868;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = p;
	R3 = 58;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L3868:
	asu64(R1) = p;
	R2 = (u64)&readlistx;
	R3 = (u64)&readlist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3870;
	goto L3866;
L3870:
	qq_lex_lex();
	goto L3865;
L3866:
// qq_parse.readread.finish:
L3862:
	asi64(R1) = opc;
	R2 = 59;
	if (asi64(R1) != asi64(R2)) goto L3872;
	asu64(R1) = readlist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3872;
	R1 = tou64("No read items");
	qq_lib_serror(asu64(R1));
L3872:
	qq_parse_poplisttype();
	asu64(R1) = readlist;
	asu64(R2) = pdev;
	R3 = 59;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = flags;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L3855;
L3855:
	return asu64(R1);
}

static u64 qq_parse_readloopcontrol() {
    u64 R1, R2, R3; 
	i64 opc;
	u64 p;
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L3875;
	R1 = tou64("all");
	R2 = (u64)&qq_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3875;
	qq_lex_lex();
	R1 = 0;
	asu64(R1) = qq_lib_createintunit(asi64(R1));
	R2 = 50;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L3874;
L3875:
	R1 = (u64)&qq_tables_exprstarterset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3876;
	asu64(R1) = qq_parse_readintunit();
	R2 = 50;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L3874;
L3876:
	R1 = 1;
	asu64(R1) = qq_lib_createintunit(asi64(R1));
	R2 = 50;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
L3874:
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	asu64(R1) = qq_parse_readcondsuffix(asu64(R1));
	goto L3873;
L3873:
	return asu64(R1);
}

static u64 qq_parse_readintunit() {
    u64 R1, R2; 
	u64 p;
	asu64(R1) = qq_parse_readexpression();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L3879;
	R1 = tou64("int expr needed");
	qq_lib_serror(asu64(R1));
L3879:
	asu64(R1) = p;
	goto L3877;
L3877:
	return asu64(R1);
}

static u64 qq_parse_readswitchcase() {
    u64 R1, R2, R3; 
	i64 pos;
	i64 kwd;
	i64 opc;
	i64 lineno;
	i64 rangeused;
	i64 nwhen;
	u64 pexpr;
	u64 pwhenlist;
	u64 pwhenlistx;
	u64 pwhen;
	u64 pwhenx;
	u64 pelse;
	u64 p;
	u64 pthen;
	u64 pwhenthen;
	u64 q;
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	qq_lex_lex();
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L3882;
	asi64(R1) = kwd;
	R2 = 95;
	if (asi64(R1) != asi64(R2)) goto L3884;
	R1 = tou64("switch expr missing");
	qq_lib_serror(asu64(R1));
L3884:
	R1 = 0;
	asu64(R1) = qq_lib_createunit0(asi64(R1));
	pexpr = asu64(R1);
	goto L3881;
L3882:
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pexpr = asu64(R1);
L3881:
	R1 = 0;
	R2 = R1;
	pwhenlistx = asu64(R2);
	pwhenlist = asu64(R1);
	R1 = 0;
	rangeused = asi64(R1);
	R1 = 0;
	nwhen = asi64(R1);
	qq_lib_skipsemi();
	goto L3886;
L3885:
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	qq_lex_lex();
	R1 = 0;
	R2 = R1;
	pwhenx = asu64(R2);
	pwhen = asu64(R1);
L3888:
	asu64(R1) = qq_parse_readexpression();
	p = asu64(R1);
	R1 = (u64)&nwhen;
	(*toi64p(R1)) += 1;
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 87;
	if (asi64(R1) != asi64(R2)) goto L3891;
	R1 = 1;
	rangeused = asi64(R1);
L3891:
	asu64(R1) = p;
	R2 = (u64)&pwhenx;
	R3 = (u64)&pwhen;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3893;
	goto L3889;
L3893:
	qq_lex_lex();
	goto L3888;
L3889:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L3895;
	R1 = 7;
	qq_lib_checksymbol(asi64(R1));
L3895:
	qq_lex_lex();
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pthen = asu64(R1);
	asu64(R1) = pthen;
	asu64(R2) = pwhen;
	R3 = 9;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	pwhenthen = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = pwhenthen;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = pwhenthen;
	R2 = (u64)&pwhenlistx;
	R3 = (u64)&pwhenlist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L3886:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L3885;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 75;
	if (asi64(R1) == asi64(R2)) goto L3897;
	R2 = 74;
	if (asi64(R1) == asi64(R2)) goto L3898;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L3899;
	R2 = 77;
	if (asi64(R1) == asi64(R2)) goto L3899;
	goto L3900;
L3897:
	qq_lex_lex();
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	pelse = asu64(R1);
	R1 = 0;
	R2 = 0;
	asi64(R3) = kwd;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	goto L3896;
L3898:
	asi64(R1) = kwd;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = qq_parse_readif();
	asu64(R1) = qq_parse_makeblock(asu64(R1));
	pelse = asu64(R1);
	goto L3896;
L3899:
	asi64(R1) = kwd;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = qq_parse_readswitchcase();
	pelse = asu64(R1);
	goto L3896;
L3900:
	R1 = 0;
	pelse = asu64(R1);
	R1 = 0;
	R2 = 0;
	asi64(R3) = kwd;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
L3896:
	asu64(R1) = pelse;
	asu64(R2) = pexpr;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pwhenlist;
	asu64(R2) = pexpr;
	asi64(R3) = opc;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L3880;
L3880:
	return asu64(R1);
}

static u64 qq_parse_readgoto() {
    u64 R1, R2; 
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	R2 = 30;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R1) = qq_parse_readcondsuffix(asu64(R1));
	goto L3901;
L3901:
	return asu64(R1);
}

static u64 qq_parse_readstop() {
    u64 R1, R2, R3; 
	u64 p;
	i64 i;
	qq_lex_lex();
	R1 = (u64)&qq_tables_exprstarterset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3904;
	asu64(R1) = qq_parse_readexpression();
	R2 = 31;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L3903;
L3904:
	R1 = 0;
	asu64(R1) = qq_lib_createintunit(asi64(R1));
	R2 = 31;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
L3903:
	asu64(R1) = p;
	asu64(R1) = qq_parse_readcondsuffix(asu64(R1));
	goto L3902;
L3902:
	return asu64(R1);
}

static u64 qq_parse_readcast() {
    u64 R1, R2, R3; 
	u64 p;
	i64 t;
	i64 opc;
	i64 pclop;
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	t = asi64(R1);
	qq_lex_lex();
	asi64(R1) = t;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3907;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L3907;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3910;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3909;
L3910:
	R1 = tou64("MAKERANGELEN");
	qq_lib_serror(asu64(R1));
	goto L3908;
L3909:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 87;
	if (asi64(R1) != asi64(R2)) goto L3911;
	goto L3908;
L3911:
	R1 = tou64("need a..b or a:n");
	qq_lib_serror(asu64(R1));
L3908:
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = p;
	goto L3905;
L3907:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L3913;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L3913;
	goto L3914;
L3913:
	goto L3912;
L3914:
	R1 = 34;
	asu64(R1) = qq_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = p;
	goto L3905;
L3912:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L3916;
	qq_lex_lex();
	R1 = 36;
	opc = asi64(R1);
	R1 = 100;
	pclop = asi64(R1);
	goto L3915;
L3916:
	R1 = 35;
	opc = asi64(R1);
	R1 = 99;
	pclop = asi64(R1);
L3915:
	R1 = 9;
	qq_lib_checksymbol(asi64(R1));
	asu64(R1) = qq_parse_readterm();
	p = asu64(R1);
	asu64(R1) = p;
	asi64(R2) = opc;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pclop;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 24;
	R1 += (i64)R2;
	asi64(R2) = t;
	asu64(R3) = qq_decls_stcurrproc;
	qq_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = p;
	goto L3905;
L3905:
	return asu64(R1);
}

static u64 qq_parse_readset() {
    u64 R1, R2, R3; 
	i64 length;
	i64 nkeyvalues;
	i64 oldinparamlist;
	u64 p;
	u64 ulist;
	u64 ulistx;
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L3919;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3920;
	goto L3921;
L3919:
	qq_lex_lex();
	R1 = 0;
	R2 = 89;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	goto L3917;
	goto L3918;
L3920:
	R1 = 12;
	qq_parse_lexchecksymbol(asi64(R1));
	qq_lex_lex();
	R1 = 0;
	R2 = 90;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	goto L3917;
	goto L3918;
L3921:
L3918:
	R1 = 1413695812;
	qq_parse_pushlisttype(asi64(R1));
	asu64(R1) = qq_parse_readexpression();
	p = asu64(R1);
	R1 = 1;
	length = asi64(R1);
	R1 = 0;
	nkeyvalues = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3923;
	R1 = (u64)&nkeyvalues;
	(*toi64p(R1)) += 1;
L3923:
	asu64(R1) = p;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	goto L3925;
L3924:
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L3928;
	goto L3926;
L3928:
	asu64(R1) = qq_parse_readexpression();
	R2 = R1;
	p = asu64(R2);
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3930;
	R1 = (u64)&nkeyvalues;
	(*toi64p(R1)) += 1;
L3930:
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	qq_lib_skipsemi();
L3925:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3924;
L3926:
	R1 = 12;
	qq_lib_skipsymbol(asi64(R1));
	asi64(R1) = nkeyvalues;
	if (!asi64(R1)) goto L3932;
	asi64(R1) = length;
	asi64(R2) = nkeyvalues;
	if (asi64(R1) <= asi64(R2)) goto L3934;
	R1 = tou64("dict: mixed elements");
	qq_lib_serror(asu64(R1));
L3934:
	asu64(R1) = ulist;
	R2 = 90;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L3931;
L3932:
	asu64(R1) = ulist;
	R2 = 89;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
L3931:
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	qq_parse_poplisttype();
	asu64(R1) = p;
	goto L3917;
L3917:
	return asu64(R1);
}

static void qq_parse_readtabledef(i64 isglobal) {
    u64 R1, R2, R3, R4; 
	i64 i;
	i64 ncols;
	i64 nrows;
	i64 enums;
	i64 nextenumvalue;
	i64 startline;
	i64 firstvalue;
	i64 ltype;
	i64 lower;
	u8 commas;
	u8 semis;
	u64 ulist;
	u64 ulistx;
	u64 plower;
	u64 p;
	struct $B35 varnames;
	struct $B35 plist;
	struct $B35 plistx;
	u64 d;
	u64 nameptr;
	R1 = 0;
	commas = asu8(R1);
	R1 = 0;
	semis = asu8(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	enums = asi64(R1);
	qq_lex_lex();
	R1 = 1;
	R2 = R1;
	nextenumvalue = asi64(R2);
	firstvalue = asi64(R1);
	R1 = 0;
	nrows = asi64(R1);
	R1 = 0;
	ncols = asi64(R1);
	goto L3937;
L3936:
	R1 = (u64)&ncols;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 20;
	if (asi64(R1) <= asi64(R2)) goto L3940;
	R1 = tou64("tabledata/too many columns");
	qq_lib_serror(asu64(R1));
L3940:
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&varnames;
	asi64(R3) = ncols;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3942;
	qq_lex_lex();
	goto L3941;
L3942:
	goto L3938;
L3941:
L3937:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L3936;
L3938:
	qq_parse_checkequals();
	qq_lex_lex();
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	startline = asi64(R1);
	qq_lib_skipsemi();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3945;
L3943:
	R1 = 0;
	R2 = R1;
	R3 = (u64)&plistx;
	asi64(R4) = i;
	*tou64p(((i64)R3+(i64)R4*8-8)) = asu64(R2);
	R2 = (u64)&plist;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= ncols) goto L3943;
L3945:
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = 1;
	qq_parse_intabledata = asi64(R1);
L3946:
	qq_lib_skipsemi();
	asi64(R1) = ncols;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3949;
	R1 = 9;
	qq_lib_skipsymbol(asi64(R1));
L3949:
	R1 = (u64)&nrows;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 500;
	if (asi64(R1) <= asi64(R2)) goto L3951;
	R1 = tou64("tabledata:too many rows");
	qq_lib_serror(asu64(R1));
L3951:
	asi64(R1) = enums;
	if (!asi64(R1)) goto L3953;
	R1 = 69;
	qq_lib_checksymbol(asi64(R1));
	asi64(R1) = isglobal;
	R2 = 19;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L3955;
	goto L3956;
L3955:
	asi64(R1) = nrows;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L3958;
	R1 = tou64("tabledata '=' not 1st");
	qq_lib_serror(asu64(R1));
L3958:
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L3960;
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	nextenumvalue = asi64(R2);
	firstvalue = asi64(R1);
	goto L3959;
L3960:
	R1 = tou64("TABLEDATA: COMPLEX ENUM VAL");
	qq_lib_serror(asu64(R1));
L3959:
	goto L3954;
L3956:
L3954:
	R1 = (u64)&nextenumvalue;
	asi64(R2) = *toi64p(R1); *(toi64p(R1)) += 1; asi64(R1) = asi64(R2);
	asu64(R2) = d;
	R3 = 96;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_parse_tabledataname = asu64(R1);
	asi64(R1) = ncols;
	if (!asi64(R1)) goto L3962;
	R1 = 3;
	qq_lib_skipsymbol(asi64(R1));
L3962:
L3953:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3965;
L3963:
	asu64(R1) = qq_parse_readexpression();
	R2 = (u64)&plistx;
	asi64(R3) = i;
	R2 += (i64)R3*8-8;
	R3 = (u64)&plist;
	asi64(R4) = i;
	R3 += (i64)R4*8-8;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	asi64(R2) = ncols;
	if (asi64(R1) != asi64(R2)) goto L3967;
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	goto L3966;
L3967:
	R1 = 3;
	qq_lib_skipsymbol(asi64(R1));
L3966:
	i += 1; if (i <= ncols) goto L3963;
L3965:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3969;
	goto L3970;
L3969:
	R1 = (u64)&commas;
	(*tou8p(R1)) += 1;
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 79;
	if (asi64(R1) != asi64(R2)) goto L3972;
	goto L3947;
L3972:
	goto L3968;
L3970:
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 79;
	if (asi64(R1) != asi64(R2)) goto L3974;
	goto L3947;
L3974:
	R1 = (u64)&semis;
	(*tou8p(R1)) += 1;
L3968:
	goto L3946;
L3947:
	asu8(R1) = semis;
	if (!asu8(R1)) goto L3976;
	asu8(R1) = commas;
	if (!asu8(R1)) goto L3976;
	R1 = tou64("mixed commas");
	qq_lib_serror(asu64(R1));
L3976:
	R1 = 0;
	qq_parse_intabledata = asi64(R1);
	qq_lib_skipsemi();
	asi64(R1) = startline;
	R2 = 0;
	R3 = 124;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = nrows;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3978;
	R1 = tou64("No table data");
	qq_lib_serror(asu64(R1));
L3978:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3981;
L3979:
	asi64(R1) = isglobal;
	R2 = 13;
	R3 = (u64)&varnames;
	asi64(R4) = i;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	R1 = (u64)&plist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 88;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	R2 = R1;
	asu64(R3) = d;
	R4 = 88;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	p = asu64(R1);
	asi64(R1) = nrows;
	asu64(R2) = p;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = firstvalue;
	asu64(R2) = p;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	i += 1; if (i <= ncols) goto L3979;
L3981:
	return;
}

static u64 qq_parse_readtry() {
    u64 R1, R2, R3; 
	u64 ptry;
	u64 pexceptlist;
	u64 pexceptlistx;
	u64 px;
	u64 q;
	u64 exlist;
	u64 exlistx;
	qq_lex_lex();
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	ptry = asu64(R1);
	R1 = 0;
	R2 = R1;
	pexceptlistx = asu64(R2);
	pexceptlist = asu64(R1);
	goto L3984;
L3983:
	qq_lex_lex();
	R1 = 0;
	R2 = R1;
	exlistx = asu64(R2);
	exlist = asu64(R1);
L3986:
	asu64(R1) = qq_parse_readexpression();
	R2 = (u64)&exlistx;
	R3 = (u64)&exlist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3989;
	goto L3987;
L3989:
	qq_lex_lex();
	goto L3986;
L3987:
	R1 = 73;
	qq_lib_skipsymbol(asi64(R1));
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	px = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = exlist;
	R3 = 24;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	R2 = (u64)&pexceptlistx;
	R3 = (u64)&pexceptlist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L3984:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 118;
	if (asi64(R1) == asi64(R2)) goto L3983;
	R1 = 0;
	R2 = 0;
	R3 = 117;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pexceptlist;
	asu64(R2) = ptry;
	R3 = 23;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L3982;
L3982:
	return asu64(R1);
}

static u64 qq_parse_readsprint() {
    u64 R1, R2, R3; 
	i64 opc;
	i64 flags;
	i64 isfprint;
	u64 pformat;
	u64 pdev;
	u64 printlist;
	u64 printlistx;
	u64 p;
	R1 = 362090680912;
	qq_parse_pushlisttype(asi64(R1));
	R1 = 54;
	opc = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	flags = asi64(R1);
	R1 = 9;
	qq_parse_lexchecksymbol(asi64(R1));
	qq_lex_lex();
	asi64(R1) = flags;
	R2 = 2;
	asi64(R1) &= asi64(R2);
	isfprint = asi64(R1);
	asi64(R1) = flags;
	R2 = 2;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L3992;
	R1 = 55;
	opc = asi64(R1);
L3992:
	R1 = 0;
	R2 = R1;
	printlistx = asu64(R2);
	printlist = asu64(R1);
	R1 = 0;
	R2 = R1;
	pdev = asu64(R2);
	pformat = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L3994;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	pdev = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3996;
	qq_lex_lex();
	goto L3995;
L3996:
	goto L3997;
L3995:
L3994:
	asi64(R1) = isfprint;
	if (!asi64(R1)) goto L3999;
	asu64(R1) = qq_parse_readexpression();
	pformat = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4001;
	qq_lex_lex();
	goto L4000;
L4001:
	goto L3997;
L4000:
L3999:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L4003;
	goto L3997;
L4003:
L4004:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4007;
	R1 = 56;
	asu64(R1) = qq_lib_createunit0(asi64(R1));
	R2 = (u64)&printlistx;
	R3 = (u64)&printlist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	goto L4006;
L4007:
	asu64(R1) = qq_parse_readexpression();
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4009;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = p;
	R3 = 58;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L4009:
	asu64(R1) = p;
	R2 = (u64)&printlistx;
	R3 = (u64)&printlist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L4006:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4011;
	goto L4005;
L4011:
	qq_lex_lex();
	goto L4004;
L4005:
	R1 = 10;
	qq_lib_checksymbol(asi64(R1));
// qq_parse.readsprint.finish:
L3997:
	qq_lex_lex();
	asi64(R1) = opc;
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L4014;
	asi64(R1) = opc;
	R2 = 55;
	if (asi64(R1) != asi64(R2)) goto L4013;
L4014:
	asu64(R1) = printlist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4013;
	R1 = tou64("No print items");
	qq_lib_serror(asu64(R1));
L4013:
	qq_parse_poplisttype();
	asi64(R1) = isfprint;
	if (!asi64(R1)) goto L4016;
	asu64(R1) = pformat;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4018;
	R1 = tou64("No fmt str");
	qq_lib_serror(asu64(R1));
L4018:
	asu64(R1) = printlist;
	asu64(R2) = pformat;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pformat;
	asu64(R2) = pdev;
	asi64(R3) = opc;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L4015;
L4016:
	asu64(R1) = printlist;
	asu64(R2) = pdev;
	asi64(R3) = opc;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L4015:
	asi64(R1) = flags;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L3990;
L3990:
	return asu64(R1);
}

static u64 qq_parse_readsread() {
    u64 R1, R2, R3; 
	i64 opc;
	u64 pformat;
	u64 pdev;
	u64 p;
	u64 readlist;
	u64 readlistx;
	msysc_m$print_startcon();
	R1 = tou64("SREAD");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 362090680912;
	qq_parse_pushlisttype(asi64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	R1 = 9;
	qq_parse_lexchecksymbol(asi64(R1));
	qq_lex_lex();
	R1 = 0;
	R2 = R1;
	readlistx = asu64(R2);
	readlist = asu64(R1);
	R1 = 0;
	R2 = R1;
	pdev = asu64(R2);
	pformat = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L4021;
	asi64(R1) = opc;
	R2 = 59;
	if (asi64(R1) != asi64(R2)) goto L4023;
	R1 = tou64("@ on read");
	qq_lib_serror(asu64(R1));
L4023:
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	pdev = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4025;
	qq_lex_lex();
	goto L4024;
L4025:
	goto L4026;
L4024:
L4021:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L4028;
	goto L4026;
L4028:
L4029:
	asu64(R1) = qq_parse_readexpression();
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4032;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = p;
	R3 = 58;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L4032:
	asu64(R1) = p;
	R2 = (u64)&readlistx;
	R3 = (u64)&readlist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4034;
	goto L4030;
L4034:
	qq_lex_lex();
	goto L4029;
L4030:
	R1 = 10;
	qq_lib_checksymbol(asi64(R1));
// qq_parse.readsread.finish:
L4026:
	qq_lex_lex();
	asi64(R1) = opc;
	R2 = 59;
	if (asi64(R1) != asi64(R2)) goto L4036;
	asu64(R1) = readlist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4036;
	R1 = tou64("No read items");
	qq_lib_serror(asu64(R1));
L4036:
	qq_parse_poplisttype();
	asu64(R1) = readlist;
	asu64(R2) = pdev;
	asi64(R3) = opc;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L4019;
L4019:
	return asu64(R1);
}

static void qq_parse_readimportdll() {
    u64 R1, R2, R3, R4, R5; 
	struct $B16 str;
	u64 stproc;
	u64 d;
	u64 stname;
	i64 startpos;
	i64 isfunc;
	i64 isnew;
	i64 libtype;
	i64 i;
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	libtype = asi64(R1);
	R1 = 69;
	qq_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	stname = asu64(R1);
	R1 = 43;
	qq_parse_lexchecksymbol(asi64(R1));
	qq_lex_lex();
	R1 = 1;
	isnew = asi64(R1);
	asu64(R1) = stname;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nlibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4040;
L4038:
	asu64(R1) = stname;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_decls_libtable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4042;
	R1 = (u64)&qq_decls_libtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	stname = asu64(R1);
	R1 = 0;
	isnew = asi64(R1);
	goto L4040;
L4042:
	i += 1; if (i <= qq_decls_nlibfiles) goto L4038;
L4040:
	asi64(R1) = isnew;
	if (!asi64(R1)) goto L4044;
	R1 = 0;
	R2 = 4;
	asu64(R3) = stname;
	R4 = 0;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	stname = asu64(R1);
	asi64(R1) = qq_decls_nlibfiles;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L4046;
	R1 = tou64("Too many DLL libs");
	qq_lib_serror(asu64(R1));
L4046:
	asu64(R1) = stname;
	R2 = (u64)&qq_decls_libtable;
	R3 = (u64)&qq_decls_nlibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = libtype;
	R2 = (u64)&qq_decls_libtypes;
	asi64(R3) = qq_decls_nlibfiles;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = qq_decls_nlibfiles;
	asu64(R2) = stname;
	R3 = 96;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4044:
	asu64(R1) = stname;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	qq_parse_currdllindex = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	startpos = asi64(R1);
L4047:
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 99;
	if (asi64(R1) == asi64(R2)) goto L4050;
	R2 = 100;
	if (asi64(R1) == asi64(R2)) goto L4050;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L4051;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L4052;
	goto L4053;
L4050:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 100;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	isfunc = asi64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L4055;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4056;
	goto L4057;
L4055:
	R1 = 1;
	R2 = 7;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	stproc = asu64(R1);
	goto L4054;
L4056:
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	R1 = 1;
	R2 = 7;
	R3 = (u64)&str;
	asu64(R3) = qq_names_addglobalname(asu64(R3));
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	stproc = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = stproc;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4054;
L4057:
	R1 = tou64("fn name expected");
	qq_lib_serror(asu64(R1));
L4054:
	asi64(R1) = isfunc;
	asu64(R2) = stproc;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 4;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 1;
	asu64(R2) = stproc;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = qq_decls_ndllprocs;
	R2 = 2000;
	if (asi64(R1) < asi64(R2)) goto L4059;
	R1 = tou64("Too many DLL procs");
	qq_lib_serror(asu64(R1));
L4059:
	asu64(R1) = stproc;
	R2 = (u64)&qq_decls_dllproctable;
	R3 = (u64)&qq_decls_ndllprocs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = qq_parse_currdllindex;
	R2 = (u64)&qq_decls_dllproclibindex;
	asi64(R3) = qq_decls_ndllprocs;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = qq_decls_ndllprocs;
	asu64(R2) = stproc;
	R3 = 96;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L4061;
	R1 = tou64("as");
	R2 = (u64)&qq_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4061;
	R1 = 69;
	qq_parse_lexchecksymbol(asi64(R1));
	R1 = 1;
	R2 = 20;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = stproc;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = stproc;
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	qq_lex_lex();
L4061:
	asu64(R1) = stproc;
	qq_parse_readffiparams(asu64(R1));
	goto L4049;
L4051:
	R1 = 1;
	qq_parse_readtypedef(asi64(R1));
	goto L4049;
L4052:
	goto L4048;
	goto L4049;
L4053:
	R1 = 8;
	asu64(R2) = qq_decls_stcurrproc;
	qq_parse_readpackvars(asu64(R2), asi64(R1));
L4049:
	goto L4047;
L4048:
	asi64(R1) = startpos;
	R2 = 0;
	R3 = 107;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	return;
}

static void qq_parse_readffiparams(u64 stproc) {
    u64 R1, R2, R3, R4; 
	i64 pret;
	i64 ptype;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L4064;
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L4066;
	qq_lex_lex();
	goto L4065;
L4066:
	R1 = 0;
	R2 = 0;
	asi64(R1) = qq_parse_readtypespec(asi64(R2), asu64(R1));
	ptype = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4069;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L4068;
L4069:
	asi64(R1) = ptype;
	asu64(R2) = stproc;
	qq_parse_readtypeparams(asu64(R2), asi64(R1));
	goto L4067;
L4068:
	asi64(R1) = ptype;
	asu64(R2) = stproc;
	qq_parse_readtypenameparams(asu64(R2), asi64(R1));
L4067:
L4065:
L4064:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4072;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L4071;
L4072:
	asu64(R1) = stproc;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 4;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L4074;
	R1 = tou64("Return type for proc?");
	qq_lib_serror(asu64(R1));
L4074:
	qq_lex_lex();
L4071:
	R1 = 0;
	pret = asi64(R1);
	asu64(R1) = stproc;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 4;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L4076;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L4078;
	R1 = tou64("Return type missing");
	qq_lib_serror(asu64(R1));
L4078:
	R1 = 0;
	R2 = 0;
	asi64(R1) = qq_parse_readtypespec(asi64(R2), asu64(R1));
	pret = asi64(R1);
L4076:
	asu64(R1) = stproc;
	R2 = 116;
	R1 += (i64)R2;
	asi64(R2) = pret;
	asu64(R3) = stproc;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	return;
}

static void qq_parse_readtypeparams(u64 stproc, i64 ptype) {
    u64 R1, R2, R3, R4; 
	struct $B32 str;
	i64 nparams;
	u64 stname;
	R1 = 0;
	nparams = asi64(R1);
L4080:
	R1 = (u64)&nparams;
	(*toi64p(R1)) += 1;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = 16;
	R3 = (u64)&str;
	asu64(R3) = qq_names_addglobalname(asu64(R3));
	asu64(R4) = stproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	R2 = 116;
	R1 += (i64)R2;
	asi64(R2) = ptype;
	asu64(R3) = stproc;
	qq_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = stproc;
	R2 = 104;
	R1 += (i64)R2;
	(*toi16p(R1)) += 1;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4083;
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L4085;
	R1 = 1;
	asu64(R2) = stproc;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 8;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	qq_lex_lex();
	goto L4081;
L4085:
	R1 = 0;
	R2 = 0;
	asi64(R1) = qq_parse_readtypespec(asi64(R2), asu64(R1));
	ptype = asi64(R1);
	goto L4082;
L4083:
	goto L4081;
L4082:
	goto L4080;
L4081:
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	return;
}

static void qq_parse_readtypenameparams(u64 stproc, i64 ptype) {
    u64 R1, R2, R3, R4; 
	u64 stname;
	R1 = 69;
	qq_lib_checksymbol(asi64(R1));
	R1 = 0;
	R2 = 16;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = stproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	R2 = 116;
	R1 += (i64)R2;
	asi64(R2) = ptype;
	asu64(R3) = stproc;
	qq_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = stproc;
	R2 = 104;
	R1 += (i64)R2;
	(*toi16p(R1)) += 1;
	qq_lex_lex();
L4087:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) != asi64(R2)) goto L4090;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = stname;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = stname;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 7;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L4090:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4092;
	goto L4093;
L4092:
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L4095;
	R1 = 1;
	asu64(R2) = stproc;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 8;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	qq_lex_lex();
	goto L4088;
L4095:
	asi64(R1) = qq_parse_istypestarter();
	if (!asi64(R1)) goto L4097;
	R1 = 0;
	R2 = 0;
	asi64(R1) = qq_parse_readtypespec(asi64(R2), asu64(R1));
	ptype = asi64(R1);
L4097:
	R1 = 69;
	qq_lib_checksymbol(asi64(R1));
	R1 = 0;
	R2 = 16;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = stproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	R2 = 116;
	R1 += (i64)R2;
	asi64(R2) = ptype;
	asu64(R3) = stproc;
	qq_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = stproc;
	R2 = 104;
	R1 += (i64)R2;
	(*toi16p(R1)) += 1;
	qq_lex_lex();
	goto L4091;
L4093:
	goto L4088;
L4091:
	goto L4087;
L4088:
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	return;
}

static void qq_parse_readrecorddef(i64 isglobal, u64 d) {
    u64 R1, R2, R3, R4; 
	i64 kwd;
	i64 baseclass;
	i64 m;
	i64 startline;
	i64 caligned;
	u8 lbopening;
	u64 nameptr;
	R1 = 0;
	lbopening = asu8(R1);
	R1 = 0;
	baseclass = asi64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L4100;
	R1 = 108;
	kwd = asi64(R1);
	goto L4101;
L4100:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	R1 = 69;
	qq_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	nameptr = asu64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L4103;
	qq_lex_lex();
	R1 = 0;
	R2 = 0;
	asi64(R1) = qq_parse_readtypespec(asi64(R2), asu64(R1));
	baseclass = asi64(R1);
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
L4103:
	qq_parse_checkequals();
	qq_lex_lex();
	asi64(R1) = isglobal;
	asi64(R2) = kwd;
	R3 = 102;
	if (asi64(R2) != asi64(R3)) goto L4105;
	R2 = 9;
	goto L4104;
L4105:
	R2 = 10;
L4104:
	asu64(R3) = nameptr;
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = baseclass;
	if (!asi64(R1)) goto L4107;
	asi64(R1) = baseclass;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4109;
	R1 = tou64("baseclass?");
	qq_lib_serror(asu64(R1));
L4109:
	asi64(R1) = qq_decls_nbaseclasses;
	R2 = 255;
	if (asi64(R1) < asi64(R2)) goto L4111;
	R1 = tou64("Too many base classes");
	qq_lib_serror(asu64(R1));
L4111:
	R1 = (u64)&qq_decls_nbaseclasses;
	(*toi64p(R1)) += 1;
	R1 = (u64)&qq_decls_baseclasstable;
	asi64(R2) = qq_decls_nbaseclasses;
	R1 += (i64)R2*2;
	asi64(R2) = baseclass;
	asu64(R3) = qq_decls_stcurrproc;
	qq_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = qq_decls_nbaseclasses;
	asu64(R2) = d;
	R3 = 110;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = d;
	R2 = (u64)&qq_decls_baseclassdef;
	asi64(R3) = qq_decls_nbaseclasses;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
L4107:
// qq_parse.readrecorddef.gotname:
L4101:
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	startline = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L4113;
	R1 = 1;
	lbopening = asu8(R1);
	qq_lex_lex();
L4113:
	asi64(R1) = kwd;
	R2 = 102;
	if (asi64(R1) != asi64(R2)) goto L4115;
	asu64(R1) = d;
	asi64(R1) = qq_parse_readrecordbody(asu64(R1));
	m = asi64(R1);
	goto L4114;
L4115:
	R1 = 0;
	caligned = asi64(R1);
	asi64(R1) = caligned;
	asu64(R2) = d;
	asi64(R1) = qq_parse_readstructbody(asu64(R2), asi64(R1));
	m = asi64(R1);
L4114:
	asu8(R1) = lbopening;
	if (!asu8(R1)) goto L4117;
	R1 = 10;
	qq_lib_checksymbol(asi64(R1));
	qq_lex_lex();
	goto L4116;
L4117:
	asi64(R1) = startline;
	R2 = 0;
	R3 = 102;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
L4116:
	return;
}

static i64 qq_parse_readrecordbody(u64 owner) {
    u64 R1, R2, R3; 
	u64 oldstcurrproc;
	u64 e;
	i64 m;
	i64 nfields;
	asi64(R1) = qq_names_addanontype();
	m = asi64(R1);
	asu64(R1) = qq_decls_stcurrproc;
	oldstcurrproc = asu64(R1);
	asu64(R1) = owner;
	qq_decls_stcurrproc = asu64(R1);
L4119:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 113;
	if (asi64(R1) == asi64(R2)) goto L4121;
	R2 = 110;
	if (asi64(R1) == asi64(R2)) goto L4122;
	R2 = 100;
	if (asi64(R1) == asi64(R2)) goto L4123;
	R2 = 99;
	if (asi64(R1) == asi64(R2)) goto L4123;
	R2 = 102;
	if (asi64(R1) == asi64(R2)) goto L4124;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L4125;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L4126;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4126;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4126;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L4127;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4128;
	goto L4129;
L4121:
	R1 = 0;
	qq_parse_readconstdef(asi64(R1));
	goto L4119;
L4122:
	asu64(R1) = owner;
	qq_parse_readrecordfields(asu64(R1));
	goto L4119;
L4123:
	R1 = 0;
	qq_parse_readprocdef(asi64(R1));
	goto L4119;
L4124:
	R1 = 0;
	R2 = 0;
	qq_parse_readrecorddef(asi64(R2), asu64(R1));
	goto L4119;
L4125:
	qq_lex_lex();
	R1 = tou64("CLASS TYPE");
	qq_lib_serror(asu64(R1));
	goto L4119;
L4126:
	goto L4120;
	goto L4119;
L4127:
	R1 = tou64("Class eof?");
	qq_lib_serror(asu64(R1));
	goto L4120;
	goto L4119;
L4128:
	qq_lex_lex();
	goto L4119;
L4129:
	R1 = tou64("Unknown record field decl");
	qq_lib_serror(asu64(R1));
	goto L4119;
L4120:
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	nfields = asi64(R1);
	goto L4133;
L4130:
	asu64(R1) = e;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L4135;
	asu64(R1) = e;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L4135;
	R1 = (u64)&nfields;
	(*toi64p(R1)) += 1;
L4135:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L4133:
	asu64(R1) = e;
	if (asu64(R1)) goto L4130;
	asi64(R1) = nfields;
	asu64(R2) = owner;
	R3 = 104;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_tables_ttfields;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = nfields;
	R2 = (u64)&qq_tables_ttlength;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_ttlower;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = 12;
	R2 = (u64)&qq_tables_ttbasetype;
	asi64(R3) = m;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asi64(R1) = m;
	asu64(R2) = owner;
	qq_names_createusertype(asu64(R2), asi64(R1));
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L4137;
L4136:
	asu64(R1) = e;
	qq_names_addgenfield(asu64(R1));
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L4137:
	asu64(R1) = e;
	if (asu64(R1)) goto L4136;
	R1 = 16;
	asu64(R2) = owner;
	R3 = 104;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asi64(R1) *= asi64(R2);
	R2 = (u64)&qq_tables_ttsize;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asu64(R1) = oldstcurrproc;
	qq_decls_stcurrproc = asu64(R1);
	asi64(R1) = m;
	goto L4118;
L4118:
	return asi64(R1);
}

static void qq_parse_readrecordfields(u64 owner) {
    u64 R1, R2, R3, R4; 
	i64 nvars;
	i64 offset;
	i64 index;
	u64 d;
	qq_lex_lex();
	R1 = 0;
	nvars = asi64(R1);
	asu64(R1) = owner;
	R2 = 104;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	index = asi64(R1);
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = 0;
	offset = asi64(R1);
	goto L4143;
L4140:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L4145;
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L4145;
	R1 = 16;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L4145:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L4143:
	asu64(R1) = d;
	if (asu64(R1)) goto L4140;
	goto L4147;
L4146:
	R1 = (u64)&nvars;
	(*toi64p(R1)) += 1;
	R1 = 0;
	R2 = 11;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L4150;
	qq_lex_lex();
	asu64(R1) = qq_parse_readatfield();
	asu64(R2) = d;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 108;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 108;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 96;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4149;
L4150:
	asi64(R1) = offset;
	asu64(R2) = d;
	R3 = 108;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 16;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	R1 = (u64)&index;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 96;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4149:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4152;
	goto L4148;
L4152:
	qq_lex_lex();
L4147:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L4146;
L4148:
	asi64(R1) = nvars;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4154;
	R1 = tou64("No fields");
	qq_lib_serror(asu64(R1));
L4154:
	return;
}

static i64 qq_parse_readstructbody(u64 owner, i64 caligned) {
    u64 R1, R2, R3; 
	i64 m;
	i64 ngroups;
	i64 nvars;
	i64 t;
	u64 d;
	u64 e;
	asi64(R1) = qq_names_addanontype();
	m = asi64(R1);
	R1 = 0;
	ngroups = asi64(R1);
L4156:
	qq_lib_skipsemi();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 103;
	if (asi64(R1) == asi64(R2)) goto L4159;
	R2 = 104;
	if (asi64(R1) == asi64(R2)) goto L4160;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L4161;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4162;
	goto L4163;
L4159:
	R1 = (u64)&ngroups;
	(*toi64p(R1)) += 1;
	qq_lex_lex();
	R1 = 24;
	asu64(R2) = owner;
	qq_parse_addstructflag(asu64(R2), asi64(R1));
	goto L4158;
L4160:
	R1 = (u64)&ngroups;
	(*toi64p(R1)) += 1;
	qq_lex_lex();
	R1 = 25;
	asu64(R2) = owner;
	qq_parse_addstructflag(asu64(R2), asi64(R1));
	goto L4158;
L4161:
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 103;
	if (asi64(R1) == asi64(R2)) goto L4166;
	R2 = 104;
	if (asi64(R1) != asi64(R2)) goto L4165;
L4166:
	qq_lex_lex();
L4165:
// qq_parse.readstructbody.doend:
L4167:
	asi64(R1) = ngroups;
	if (!asi64(R1)) goto L4169;
	R1 = (u64)&ngroups;
	(*toi64p(R1)) -=1;
	qq_lex_lex();
	R1 = 26;
	asu64(R2) = owner;
	qq_parse_addstructflag(asu64(R2), asi64(R1));
	goto L4168;
L4169:
	goto L4157;
L4168:
	goto L4158;
L4162:
	goto L4167;
	goto L4158;
L4163:
	R1 = 12;
	asu64(R2) = owner;
	qq_parse_readpackvars(asu64(R2), asi64(R1));
L4158:
	goto L4156;
L4157:
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_tables_ttfields;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = owner;
	R2 = 104;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = (u64)&qq_tables_ttlength;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_ttlower;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asi64(R1) = caligned;
	R2 = (u64)&qq_tables_ttcaligned;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 13;
	R2 = (u64)&qq_tables_ttbasetype;
	asi64(R3) = m;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asi64(R1) = m;
	asu64(R2) = owner;
	qq_names_createusertype(asu64(R2), asi64(R1));
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L4171;
L4170:
	asu64(R1) = e;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L4174;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L4174;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L4174;
	goto L4175;
L4174:
	goto L4173;
L4175:
	asu64(R1) = e;
	qq_names_addgenfield(asu64(R1));
L4173:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L4171:
	asu64(R1) = e;
	if (asu64(R1)) goto L4170;
	asi64(R1) = m;
	goto L4155;
L4155:
	return asi64(R1);
}

static void qq_parse_addstructflag(u64 owner, i64 id) {
    u64 R1, R2, R3, R4; 
	struct $B32 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$$#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_parse_addstructflag_structseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = 0;
	asi64(R2) = id;
	R3 = (u64)&str;
	asu64(R3) = qq_names_addglobalname(asu64(R3));
	asu64(R4) = owner;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void qq_parse_readprocdef(i64 isglobal) {
    u64 R1, R2, R3, R4; 
	i64 kwd;
	i64 startline;
	i64 nparams;
	i64 shortfun;
	u64 pcode;
	u64 d;
	u64 oldstcurrproc;
	struct $B16 str;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	shortfun = asi64(R1);
	R1 = 69;
	qq_parse_lexchecksymbol(asi64(R1));
	asu64(R1) = qq_decls_stcurrproc;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4180;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L4179;
L4180:
	R1 = tou64("Nested proc");
	qq_lib_serror(asu64(R1));
L4179:
	asu64(R1) = qq_decls_stcurrproc;
	oldstcurrproc = asu64(R1);
	asi64(R1) = isglobal;
	R2 = 5;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R2 = R1;
	d = asu64(R2);
	qq_decls_stcurrproc = asu64(R1);
	asu64(R1) = d;
	qq_names_addproc(asu64(R1));
	qq_lex_lex();
	R1 = 0;
	asu64(R2) = d;
	R3 = 116;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L4182;
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4184;
	asu64(R1) = d;
	qq_parse_readparams(asu64(R1));
	goto L4183;
L4184:
	qq_lex_lex();
L4183:
L4182:
	qq_parse_checkequals();
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	startline = asi64(R1);
	asi64(R1) = shortfun;
	if (asi64(R1)) goto L4186;
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	asu64(R2) = d;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = startline;
	R2 = 0;
	asi64(R3) = kwd;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	goto L4185;
L4186:
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = d;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 4;
	qq_lib_checksymbol(asi64(R1));
L4185:
	R1 = tou64("start");
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4188;
	asu64(R1) = d;
	asu64(R2) = qq_decls_currmodule;
	R3 = 104;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4187;
L4188:
	R1 = tou64("main");
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4189;
	asu64(R1) = d;
	asu64(R2) = qq_decls_currmodule;
	R3 = 112;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4189:
L4187:
	asi64(R1) = kwd;
	R2 = 100;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	asu64(R2) = qq_decls_stcurrproc;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 4;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = oldstcurrproc;
	qq_decls_stcurrproc = asu64(R1);
	return;
}

static u64 qq_parse_readatfield() {
    u64 R1, R2, R3; 
	u64 p;
	u64 d;
	R1 = 69;
	qq_lib_checksymbol(asi64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	qq_lex_lex();
	asu64(R1) = qq_decls_stcurrproc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L4192;
L4191:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4195;
	asu64(R1) = p;
	goto L4190;
L4195:
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L4192:
	asu64(R1) = p;
	if (asu64(R1)) goto L4191;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't find @ field");
	qq_lib_serror_s(asu64(R2), asu64(R1));
	R1 = 0;
	goto L4190;
L4190:
	return asu64(R1);
}

static i64 qq_parse_istypestarter() {
    u64 R1, R2; 
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L4198;
	R2 = 109;
	if (asi64(R1) == asi64(R2)) goto L4198;
	R2 = 110;
	if (asi64(R1) == asi64(R2)) goto L4198;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L4198;
	goto L4199;
L4198:
	R1 = 1;
	goto L4196;
	goto L4197;
L4199:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L4201;
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L4203;
	R1 = 1;
	goto L4196;
L4203:
L4201:
L4197:
	R1 = 0;
	goto L4196;
L4196:
	return asi64(R1);
}

static void qq_parse_readmacrodef(i64 isglobal) {
    u64 R1, R2, R3, R4; 
	u64 stmacro;
	u64 stname;
	u64 owner;
	R1 = 69;
	qq_parse_lexchecksymbol(asi64(R1));
	asi64(R1) = isglobal;
	R2 = 22;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	stmacro = asu64(R1);
	asu64(R1) = stmacro;
	owner = asu64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L4206;
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4208;
L4209:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L4212;
	goto L4213;
L4212:
	R1 = 0;
	R2 = 23;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = owner;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	stname = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = stname;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L4215;
	goto L4210;
L4215:
	R1 = 3;
	qq_lib_skipsymbol(asi64(R1));
	goto L4211;
L4213:
	R1 = tou64("macro def params");
	qq_lib_serror(asu64(R1));
L4211:
	goto L4209;
L4210:
L4208:
	qq_lex_lex();
L4206:
	qq_parse_checkequals();
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = stmacro;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 qq_parse_readhostparams(u64 lhs, i64 isfn) {
    u64 R1, R2, R3; 
	i64 fnindex;
	i64 nargs;
	u64 p;
	u64 q;
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	fnindex = asi64(R1);
	R1 = 9;
	qq_parse_lexchecksymbol(asi64(R1));
	qq_lex_lex();
	R1 = 0;
	R2 = (u64)&nargs;
	asu64(R1) = qq_parse_readslist(asu64(R2), asi64(R1));
	q = asu64(R1);
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = lhs;
	if (!asu64(R1)) goto L4218;
	asu64(R1) = q;
	asu64(R2) = lhs;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = lhs;
	q = asu64(R1);
L4218:
	asu64(R1) = q;
	R2 = 27;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = fnindex;
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	goto L4216;
L4216:
	return asu64(R1);
}

static void qq_parse_pushlisttype(i64 ltype) {
    u64 R1, R2, R3; 
	asi64(R1) = qq_parse_nlisttype;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L4221;
	R1 = tou64("listtype overflow");
	qq_lib_serror(asu64(R1));
L4221:
	asi64(R1) = qq_parse_listtype;
	R2 = (u64)&qq_parse_listtypestack;
	R3 = (u64)&qq_parse_nlisttype;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = ltype;
	qq_parse_listtype = asi64(R1);
	return;
}

static void qq_parse_poplisttype() {
    u64 R1, R2, R3; 
	R1 = (u64)&qq_parse_listtypestack;
	R2 = (u64)&qq_parse_nlisttype;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	qq_parse_listtype = asi64(R1);
	return;
}

static u64 qq_parse_readcompilervar() {
    u64 R1, R2, R3, R4; 
	struct $B5 str;
	struct $B3 tm;
// PROC LOCAL STATICS GO HERE
	static struct $B36 qq_parse_readcompilervar_monthnames = {{
	(u64)"Jan",
	(u64)"Feb",
	(u64)"Mar",
	(u64)"Apr",
	(u64)"May",
	(u64)"Jun",
	(u64)"Jul",
	(u64)"Aug",
	(u64)"Sep",
	(u64)"Oct",
	(u64)"Nov",
	(u64)"Dec"    }};
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4225;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4226;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4227;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4228;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4229;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4230;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L4231;
	goto L4232;
L4225:
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 23;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R1) = qq_lib_createintunit(asi64(R1));
	goto L4223;
	goto L4224;
L4226:
	R1 = 0;
	R2 = (u64)&qq_decls_lx;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 23;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4224;
L4227:
	asu64(R1) = qq_decls_currmodule;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4224;
L4228:
	asu64(R1) = qq_decls_currmodule;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4224;
L4229:
	asu64(R1) = qq_decls_stcurrproc;
	if (!asu64(R1)) goto L4234;
	asu64(R1) = qq_decls_stcurrproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L4233;
L4234:
	R1 = tou64("<none>");
L4233:
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4224;
L4230:
	R1 = (u64)&tm;
	mwindows_os_getsystime(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#-#-#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&tm;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&qq_parse_readcompilervar_monthnames;
	R2 = (u64)&tm;
	R3 = 2;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("4");
	R2 = (u64)&tm;
	R3 = 0;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	goto L4224;
L4231:
	R1 = (u64)&tm;
	mwindows_os_getsystime(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#:#:#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("2");
	R2 = (u64)&tm;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("z2");
	R2 = (u64)&tm;
	R3 = 10;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("z2");
	R2 = (u64)&tm;
	R3 = 12;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	goto L4224;
L4232:
	R1 = tou64("compiler var not impl");
	qq_lib_serror(asu64(R1));
L4224:
	R1 = -1;
	R2 = (u64)&str;
	asu64(R2) = mlib_pcm_copyheapstring(asu64(R2));
	asu64(R1) = qq_lib_createstringunit(asu64(R2), asi64(R1));
	goto L4223;
L4223:
	return asu64(R1);
}

static u64 qq_parse_readpair(i64 tag, i64 pclop) {
    u64 R1, R2, R3; 
	u64 p;
	u64 a;
	u64 b;
	R1 = 9;
	qq_parse_lexchecksymbol(asi64(R1));
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	a = asu64(R1);
	R1 = 3;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = qq_parse_readexpression();
	b = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4237;
	asi64(R1) = tag;
	R2 = 37;
	if (asi64(R1) != asi64(R2)) goto L4237;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = b;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4237:
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R3) = tag;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pclop;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L4235;
L4235:
	return asu64(R1);
}

static void qq_parse_lexchecksymbol(i64 symbol) {
    u64 R1; 
	qq_lex_lex();
	asi64(R1) = symbol;
	qq_lib_checksymbol(asi64(R1));
	return;
}

static void qq_parse_readtypedef(i64 isglobal) {
    u64 R1, R2, R3, R4; 
	i64 ptype;
	u64 d;
	R1 = 69;
	qq_parse_lexchecksymbol(asi64(R1));
	asi64(R1) = isglobal;
	R2 = 10;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 43;
	qq_parse_lexchecksymbol(asi64(R1));
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 102;
	if (asi64(R1) != asi64(R2)) goto L4241;
	qq_lex_lex();
	R1 = 9;
	asu64(R2) = d;
	R3 = 124;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	asi64(R2) = isglobal;
	qq_parse_readrecorddef(asi64(R2), asu64(R1));
	goto L4239;
L4241:
	asu64(R1) = d;
	R2 = 0;
	asi64(R1) = qq_parse_readtypespec(asi64(R2), asu64(R1));
	ptype = asi64(R1);
	asi64(R1) = ptype;
	asu64(R2) = d;
	qq_names_createusertype(asu64(R2), asi64(R1));
L4239:
	return;
}

static i64 qq_parse_readtypespec(i64 allowvar, u64 owner) {
    u64 R1, R2, R3; 
	i64 flags;
	i64 arraycode;
	i64 oldipl;
	i64 a;
	i64 b;
	i64 t;
	i64 startline;
	i64 caligned;
	u64 d;
	struct $B1 lowerdims;
	struct $B1 lengthdims;
	i64 ndims;
	u64 x;
	u64 lowerx;
	u64 upperx;
	u64 lengthx;
	i64 i;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L4244;
	R2 = 109;
	if (asi64(R1) == asi64(R2)) goto L4245;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L4246;
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L4247;
	R2 = 102;
	if (asi64(R1) == asi64(R2)) goto L4248;
	R2 = 103;
	if (asi64(R1) == asi64(R2)) goto L4249;
	goto L4250;
L4244:
// qq_parse.readtypespec.dolsq:
L4251:
	qq_lex_lex();
	R1 = 0;
	ndims = asi64(R1);
	R1 = 0;
	qq_parse_pushlisttype(asi64(R1));
L4252:
	R1 = 0;
	R2 = R1;
	lengthx = asu64(R2);
	lowerx = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L4256;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4255;
L4256:
	goto L4254;
L4255:
	asu64(R1) = qq_parse_readexpression();
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 87;
	if (asi64(R1) != asi64(R2)) goto L4258;
	asu64(R1) = x;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	lowerx = asu64(R1);
	asu64(R1) = x;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	upperx = asu64(R1);
	asu64(R1) = lowerx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L4260;
	asu64(R1) = upperx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L4260;
	asu64(R1) = upperx;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = lowerx;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = qq_lib_createintunit(asi64(R1));
	lengthx = asu64(R1);
	goto L4259;
L4260:
	asu64(R1) = lowerx;
	asu64(R2) = upperx;
	R3 = 63;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	lengthx = asu64(R1);
	R1 = 102;
	asu64(R2) = lengthx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R1) = qq_lib_createintunit(asi64(R1));
	asu64(R2) = lengthx;
	R3 = 63;
	asu64(R1) = qq_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	lengthx = asu64(R1);
	R1 = 101;
	asu64(R2) = lengthx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4259:
	goto L4257;
L4258:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L4262;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4262;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4263;
	goto L4264;
L4262:
	asu64(R1) = x;
	lengthx = asu64(R1);
	goto L4261;
L4263:
	asu64(R1) = x;
	lowerx = asu64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4266;
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L4266;
	asu64(R1) = qq_parse_readexpression();
	lengthx = asu64(R1);
L4266:
	goto L4261;
L4264:
L4261:
L4257:
L4254:
	asu64(R1) = lowerx;
	R2 = (u64)&lowerdims;
	R3 = (u64)&ndims;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = lengthx;
	R2 = (u64)&lengthdims;
	asi64(R3) = ndims;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4268;
	goto L4253;
L4268:
	qq_lex_lex();
	goto L4252;
L4253:
	R1 = 12;
	qq_lib_skipsymbol(asi64(R1));
	qq_parse_poplisttype();
	R1 = 0;
	R2 = 0;
	asi64(R1) = qq_parse_readtypespec(asi64(R2), asu64(R1));
	t = asi64(R1);
	asi64(R1) = ndims;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4271;
L4269:
	R1 = (u64)&lengthdims;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&lowerdims;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R3) = t;
	asi64(R1) = qq_names_makeaxtype(asi64(R3), asu64(R2), asu64(R1));
	t = asi64(R1);
	i += -1; if (i >= 1) goto L4269;
L4271:
	asi64(R1) = t;
	goto L4242;
	goto L4243;
L4245:
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 70;
	if (asi64(R1) != asi64(R2)) goto L4273;
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4273;
	qq_lex_lex();
	asu64(R1) = owner;
	R2 = 0;
	asi64(R1) = qq_names_makereftype(asi64(R2), asu64(R1));
	goto L4242;
	goto L4272;
L4273:
	asu64(R1) = owner;
	R2 = 0;
	R3 = 0;
	asi64(R2) = qq_parse_readtypespec(asi64(R3), asu64(R2));
	asi64(R1) = qq_names_makereftype(asi64(R2), asu64(R1));
	goto L4242;
L4272:
	goto L4243;
L4246:
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4275;
	R1 = 69;
	qq_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&qq_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	asi64(R1) = qq_names_newusertypex(asu64(R2), asu64(R1));
	t = asi64(R1);
	qq_lex_lex();
	asi64(R1) = t;
	goto L4242;
	goto L4274;
L4275:
	R1 = 0;
	asu64(R2) = d;
	asi64(R1) = qq_names_newusertypex(asu64(R2), asu64(R1));
	goto L4242;
L4274:
	goto L4243;
L4247:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L4277;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L4278;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L4279;
	goto L4280;
L4277:
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 24;
	if (asi64(R1) != asi64(R2)) goto L4282;
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	R2 = 37;
	asi64(R1) = qq_names_makestrtype(asi64(R2), asu64(R1));
	goto L4242;
	goto L4281;
L4282:
	R1 = 38;
	goto L4242;
L4281:
	goto L4276;
L4278:
	R1 = 24;
	qq_parse_lexchecksymbol(asi64(R1));
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	R2 = 36;
	asi64(R1) = qq_names_makestrtype(asi64(R2), asu64(R1));
	goto L4242;
	goto L4276;
L4279:
	R1 = 11;
	qq_parse_lexchecksymbol(asi64(R1));
	goto L4251;
	goto L4276;
L4280:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	t = asi64(R1);
	asi64(R1) = t;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4284;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4285;
	goto L4286;
L4284:
	R1 = 26;
	t = asi64(R1);
	goto L4283;
L4285:
	R1 = 32;
	t = asi64(R1);
	goto L4283;
L4286:
L4283:
	qq_lex_lex();
	asi64(R1) = t;
	goto L4242;
L4276:
	goto L4243;
L4248:
	asu64(R1) = owner;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4288;
	R1 = tou64("anon record");
	qq_lib_serror(asu64(R1));
L4288:
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	startline = asi64(R1);
	asu64(R1) = owner;
	asi64(R1) = qq_parse_readrecordbody(asu64(R1));
	t = asi64(R1);
	asi64(R1) = startline;
	R2 = 0;
	R3 = 102;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	goto L4242;
	goto L4243;
L4249:
	asu64(R1) = owner;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4290;
	R1 = tou64("anon struct");
	qq_lib_serror(asu64(R1));
L4290:
	qq_lex_lex();
	R1 = 0;
	caligned = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 116;
	if (asi64(R1) != asi64(R2)) goto L4292;
	R1 = 1;
	caligned = asi64(R1);
	qq_lex_lex();
L4292:
	R1 = (u64)&qq_decls_lx;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	startline = asi64(R1);
	asi64(R1) = caligned;
	asu64(R2) = owner;
	asi64(R1) = qq_parse_readstructbody(asu64(R2), asi64(R1));
	t = asi64(R1);
	asi64(R1) = startline;
	R2 = 0;
	R3 = 103;
	qq_parse_checkend(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	goto L4242;
	goto L4243;
L4250:
	R1 = tou64("Type expected");
	qq_lib_serror(asu64(R1));
L4243:
	asi64(R1) = t;
	goto L4242;
L4242:
	return asi64(R1);
}

static void qq_parse_readparams(u64 stproc) {
    u64 R1, R2, R3, R4; 
	i64 isbyref;
	i64 isoptional;
	u64 d;
	R1 = 0;
	R2 = R1;
	isoptional = asi64(R2);
	isbyref = asi64(R1);
L4294:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L4297;
	R1 = (u64)&isbyref;
	(*toi64p(R1)) += 1;
	qq_lex_lex();
L4297:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L4299;
	R1 = (u64)&isoptional;
	(*toi64p(R1)) += 1;
	qq_lex_lex();
L4299:
	R1 = 69;
	qq_lib_checksymbol(asi64(R1));
	R1 = 0;
	R2 = 15;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = stproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = stproc;
	R2 = 104;
	R1 += (i64)R2;
	(*toi16p(R1)) += 1;
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) != asi64(R2)) goto L4301;
	R1 = 1;
	isoptional = asi64(R1);
	qq_lex_lex();
	asu64(R1) = qq_parse_readexpression();
	asu64(R2) = d;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4301:
	asi64(R1) = isbyref;
	if (!asi64(R1)) goto L4303;
	asi64(R1) = isoptional;
	if (!asi64(R1)) goto L4303;
	R1 = tou64("Mixed byref/optional");
	qq_lib_serror(asu64(R1));
L4303:
	asi64(R1) = isbyref;
	asu64(R2) = d;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 5;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = isoptional;
	asu64(R2) = d;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 7;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 0;
	R2 = R1;
	isoptional = asi64(R2);
	isbyref = asi64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4305;
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L4307;
	R1 = 1;
	asu64(R2) = stproc;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 8;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	qq_lex_lex();
	goto L4295;
L4307:
	goto L4304;
L4305:
	goto L4295;
L4304:
	goto L4294;
L4295:
	R1 = 10;
	qq_lib_skipsymbol(asi64(R1));
	return;
}

static u64 qq_parse_checkoperator() {
    u64 R1, R2, R3; 
	u64 p;
	i64 opc;
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4311;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4311;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L4310;
L4311:
	R1 = 5;
	asu64(R1) = qq_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 132;
	if (asi64(R1) != asi64(R2)) goto L4313;
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L4315;
	R2 = 23899;
	if (asi64(R1) == asi64(R2)) goto L4316;
	goto L4317;
L4315:
	R1 = 75;
	opc = asi64(R1);
	goto L4314;
L4316:
	R1 = 130;
	opc = asi64(R1);
	goto L4314;
L4317:
	R1 = 0;
	opc = asi64(R1);
L4314:
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4312;
L4313:
	R1 = (u64)&qq_tables_cmpopset;
	R2 = (u64)&qq_decls_lx;
	R3 = 12;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4318;
	R1 = tou64("(CMP OP) NOT READY");
	qq_lib_serror(asu64(R1));
	goto L4312;
L4318:
	R1 = (u64)&qq_decls_lx;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4312:
	qq_lex_lex();
	asu64(R1) = p;
	goto L4308;
L4310:
	R1 = 0;
	goto L4308;
L4308:
	return asu64(R1);
}

static u64 qq_parse_readlambda() {
    u64 R1, R2, R3, R4; 
	u64 p;
	struct $B28 params;
	u64 oldstcurrproc;
	u64 stproc;
	u64 d;
	struct $B17 str;
	i64 nparams;
	u8 byref;
	asu64(R1) = qq_decls_stcurrproc;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4321;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4322;
	goto L4323;
L4321:
	goto L4320;
L4322:
	R1 = tou64("Nested {}");
	qq_lib_serror(asu64(R1));
	goto L4320;
L4323:
	R1 = tou64("{} not in fn");
	qq_lib_serror(asu64(R1));
L4320:
	asu64(R1) = qq_decls_stcurrproc;
	oldstcurrproc = asu64(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$F");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&qq_parse_nextlambdaindex;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = 6;
	R3 = (u64)&str;
	asu64(R3) = qq_lex_addnamestr(asu64(R3));
	asu64(R4) = qq_decls_stcurrproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	stproc = asu64(R1);
	asu64(R1) = stproc;
	qq_decls_stcurrproc = asu64(R1);
	asu64(R1) = stproc;
	qq_names_addproc(asu64(R1));
	qq_lex_lex();
	R1 = 0;
	nparams = asi64(R1);
	R1 = 0;
	byref = asu8(R1);
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L4325;
	qq_lex_lex();
	R1 = 1;
	byref = asu8(R1);
L4325:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L4327;
	R1 = (u64)&qq_decls_nextlx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4328;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4327;
L4328:
L4329:
	R1 = 69;
	qq_lib_checksymbol(asi64(R1));
	R1 = 0;
	R2 = 15;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = stproc;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = (u64)&params;
	R3 = (u64)&nparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu8(R1) = byref;
	R1 = tou64(tou8(R1));
	asu64(R2) = d;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 5;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 0;
	byref = asu8(R1);
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4332;
	goto L4330;
L4332:
	qq_lex_lex();
	goto L4329;
L4330:
	R1 = 5;
	qq_lib_checksymbol(asi64(R1));
	qq_lex_lex();
L4327:
	asi64(R1) = nparams;
	asu64(R2) = stproc;
	R3 = 104;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 1;
	asu64(R2) = stproc;
	R3 = 120;
	R2 += (i64)R3;
	R3 = 4;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 0;
	asu64(R1) = qq_parse_readsunit(asi64(R1));
	asu64(R2) = stproc;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 14;
	qq_lib_skipsymbol(asi64(R1));
	asu64(R1) = stproc;
	asu64(R1) = qq_lib_createname(asu64(R1));
	p = asu64(R1);
	asu64(R1) = oldstcurrproc;
	qq_decls_stcurrproc = asu64(R1);
	asu64(R1) = p;
	goto L4319;
L4319:
	return asu64(R1);
}

static void qq_parse_readpackvars(u64 owner, i64 id) {
    u64 R1, R2, R3, R4; 
	i64 t;
	i64 nvars;
	u64 d;
	R1 = 0;
	R2 = 0;
	asi64(R1) = qq_parse_readtypespec(asi64(R2), asu64(R1));
	t = asi64(R1);
	R1 = 0;
	nvars = asi64(R1);
	goto L4335;
L4334:
	R1 = (u64)&nvars;
	(*toi64p(R1)) += 1;
	R1 = 0;
	asi64(R2) = id;
	R3 = (u64)&qq_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = owner;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 116;
	R1 += (i64)R2;
	asi64(R2) = t;
	asu64(R3) = owner;
	qq_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	qq_lex_lex();
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4338;
	goto L4336;
L4338:
	R1 = 69;
	qq_parse_lexchecksymbol(asi64(R1));
L4335:
	R1 = (u64)&qq_decls_lx;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L4334;
L4336:
	asi64(R1) = nvars;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4340;
	R1 = tou64("bad decl?");
	qq_lib_serror(asu64(R1));
L4340:
	return;
}

static void qq_pclgen_evalunit(u64 p, i64 res) {
    u64 R1, R2, R3, R4, R5; 
	u64 a;
	u64 b;
	u64 d;
	i64 procflag;
	i64 index;
	i64 av_1;
	i64 i;
	asu64(R1) = p;
	R2 = 4;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	qq_decls_qpos = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 0: goto L4347;
	case 1: goto L4390;
	case 2: goto L4377;
	case 3: case 9: case 14: case 24: case 38: case 45: case 56: case 57: case 58: case 67: case 80: case 81: case 82: case 83: case 86: goto L4344;
	case 4: goto L4412;
	case 5: goto L4452;
	case 6: goto L4364;
	case 7: goto L4379;
	case 8: goto L4398;
	case 10: case 11: goto L4395;
	case 12: case 13: goto L4396;
	case 15: goto L4380;
	case 16: goto L4381;
	case 17: case 18: goto L4382;
	case 19: goto L4394;
	case 20: goto L4378;
	case 21: goto L4383;
	case 22: goto L4384;
	case 23: goto L4405;
	case 25: goto L4455;
	case 26: goto L4374;
	case 27: goto L4376;
	case 28: goto L4454;
	case 29: goto L4397;
	case 30: goto L4385;
	case 31: goto L4402;
	case 32: goto L4375;
	case 33: goto L4457;
	case 34: goto L4451;
	case 35: goto L4449;
	case 36: goto L4450;
	case 37: goto L4413;
	case 39: goto L4349;
	case 40: goto L4361;
	case 41: goto L4345;
	case 42: goto L4346;
	case 43: goto L4348;
	case 44: goto L4373;
	case 46: goto L4437;
	case 47: goto L4438;
	case 48: goto L4439;
	case 49: goto L4440;
	case 50: goto L4393;
	case 51: goto L4443;
	case 52: goto L4444;
	case 53: goto L4456;
	case 54: goto L4399;
	case 55: goto L4400;
	case 59: goto L4401;
	case 60: case 61: goto L4453;
	case 62: case 66: goto L4426;
	case 63: goto L4414;
	case 64: goto L4462;
	case 65: goto L4465;
	case 68: goto L4458;
	case 69: goto L4435;
	case 70: goto L4436;
	case 71: goto L4461;
	case 72: goto L4406;
	case 73: goto L4407;
	case 74: goto L4433;
	case 75: goto L4434;
	case 76: goto L4459;
	case 77: goto L4460;
	case 78: goto L4429;
	case 79: goto L4419;
	case 84: case 85: goto L4430;
	case 87: goto L4411;
	case 88: goto L4408;
	case 89: goto L4409;
	case 90: goto L4410;
	default: goto L4344;
    };
// SWITCH
L4345:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	goto L4342;
L4346:
	asu64(R1) = p;
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R2 = 17;
	qq_pcllib_genpc_real(asi64(R2), asr64(R1));
	goto L4342;
L4347:
	goto L4342;
L4348:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_pclgen_pushstring(asu64(R1));
	goto L4342;
L4349:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L4351;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4352;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L4352;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L4353;
	goto L4354;
L4351:
	asu64(R1) = d;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L4356;
	R1 = 22;
	qq_pcllib_genpc(asi64(R1));
L4356:
	goto L4350;
L4352:
	asu64(R1) = d;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L4350;
L4353:
	asu64(R1) = d;
	R2 = 80;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4358;
	asi64(R1) = qq_pcllib_createfwdlabel();
	asu64(R2) = d;
	R3 = 80;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L4358:
	asi64(R1) = res;
	if (asi64(R1)) goto L4360;
	asu64(R1) = d;
	R2 = 80;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 30;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	goto L4341;
	goto L4359;
L4360:
	asu64(R1) = d;
	R2 = 80;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 11;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
L4359:
	goto L4350;
L4354:
	asu64(R1) = d;
	R2 = 21;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
L4350:
	goto L4342;
L4361:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L4363;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 21;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L4362;
L4363:
	R1 = 0;
	R2 = tou64(".$ name expected");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4362:
	goto L4342;
L4364:
	asu64(R1) = a;
	if (!asu64(R1)) goto L4366;
	goto L4368;
L4367:
	R1 = 0;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L4368:
	asu64(R1) = a;
	if (!asu64(R1)) goto L4370;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L4367;
L4370:
	asu64(R1) = a;
	if (!asu64(R1)) goto L4372;
	asi64(R1) = res;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
L4372:
	goto L4365;
L4366:
L4365:
	goto L4342;
L4373:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_pclgen_pushstring(asu64(R1));
	R1 = 69;
	qq_pcllib_genpc(asi64(R1));
	goto L4342;
L4374:
	R1 = (u64)&procflag;
	asi64(R2) = res;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	qq_pclgen_do_call(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L4342;
L4375:
	asi64(R1) = res;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_return(asu64(R3), asu64(R2), asi64(R1));
	goto L4342;
L4376:
	asi64(R1) = res;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_callhost(asu64(R3), asu64(R2), asi64(R1));
	goto L4342;
L4377:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = res;
	asu64(R3) = b;
	asu64(R4) = a;
	qq_pclgen_do_assign(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L4342;
L4378:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_to(asu64(R3), asu64(R2), asu64(R1));
	goto L4342;
L4379:
	asi64(R1) = res;
	asu64(R2) = b;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	qq_pclgen_do_if(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L4342;
L4380:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_for(asu64(R3), asu64(R2), asu64(R1));
	goto L4342;
L4381:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_forx(asu64(R3), asu64(R2), asu64(R1));
	goto L4342;
L4382:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_forall(asu64(R3), asu64(R2), asu64(R1));
	goto L4342;
L4383:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_while(asu64(R3), asu64(R2), asu64(R1));
	goto L4342;
L4384:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_repeat(asu64(R3), asu64(R2), asu64(R1));
	goto L4342;
L4385:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L4387;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L4387;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 80;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4389;
	asi64(R1) = qq_pcllib_createfwdlabel();
	asu64(R2) = d;
	R3 = 80;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L4389:
	asu64(R1) = d;
	R2 = 80;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 30;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	goto L4386;
L4387:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 31;
	qq_pcllib_genpc(asi64(R1));
L4386:
	goto L4342;
L4390:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_pcllib_gencomment(asu64(R1));
	asu64(R1) = d;
	R2 = 80;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4392;
	asi64(R1) = qq_pcllib_definelabel();
	asu64(R2) = d;
	R3 = 80;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L4391;
L4392:
	asu64(R1) = d;
	R2 = 80;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	index = asi64(R1);
	asi64(R1) = index;
	qq_pcllib_definefwdlabel(asi64(R1));
L4391:
	goto L4342;
L4393:
	asu64(R1) = p;
	qq_pclgen_do_loop(asu64(R1));
	goto L4342;
L4394:
	asu64(R1) = a;
	asu64(R2) = p;
	qq_pclgen_do_do(asu64(R2), asu64(R1));
	goto L4342;
L4395:
	asi64(R1) = res;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	qq_pclgen_do_case(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L4342;
L4396:
	asi64(R1) = res;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	qq_pclgen_do_switch(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L4342;
L4397:
	asu64(R1) = a;
	qq_pclgen_evalref(asu64(R1));
	asu64(R1) = b;
	qq_pclgen_evalref(asu64(R1));
	R1 = 28;
	qq_pcllib_genpc(asi64(R1));
	goto L4342;
L4398:
	asi64(R1) = res;
	asu64(R2) = b;
	asu64(R3) = a;
	qq_pclgen_do_select(asu64(R3), asu64(R2), asi64(R1));
	goto L4342;
L4399:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_print(asu64(R3), asu64(R2), asu64(R1));
	goto L4342;
L4400:
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	qq_pclgen_do_fprint(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L4342;
L4401:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_read(asu64(R3), asu64(R2), asu64(R1));
	goto L4342;
L4402:
	asu64(R1) = a;
	if (!asu64(R1)) goto L4404;
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L4403;
L4404:
	R1 = 0;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
L4403:
	R1 = 60;
	qq_pcllib_genpc(asi64(R1));
	goto L4342;
L4405:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_try(asu64(R3), asu64(R2), asu64(R1));
	goto L4342;
L4406:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_pclgen_do_andl(asu64(R2), asu64(R1));
	goto L4342;
L4407:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_pclgen_do_orl(asu64(R2), asu64(R1));
	goto L4342;
L4408:
	asu64(R1) = p;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	qq_pclgen_do_pushlist(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 61;
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	goto L4342;
L4409:
	asu64(R1) = p;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	qq_pclgen_do_pushlist(asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 66;
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	goto L4342;
L4410:
	asu64(R1) = p;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	qq_pclgen_do_makedict(asu64(R2), asi64(R1));
	goto L4342;
L4411:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 67;
	qq_pcllib_genpc(asi64(R1));
	goto L4342;
L4412:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L4342;
L4413:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_map(asu64(R3), asu64(R2), asu64(R1));
	goto L4342;
L4414:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 105;
	if (asi64(R1) == asi64(R2)) goto L4416;
	R2 = 106;
	if (asi64(R1) == asi64(R2)) goto L4417;
	goto L4418;
L4416:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_pclgen_do_idiv(asu64(R2), asu64(R1));
	goto L4415;
L4417:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_pclgen_do_irem(asu64(R2), asu64(R1));
	goto L4415;
L4418:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	qq_pcllib_genpc(asi64(R1));
L4415:
	goto L4342;
L4419:
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = a;
	qq_pclgen_evalref(asu64(R1));
	R1 = 122;
	qq_pcllib_genpc(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	R1 = 11;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4423;
L4420:
	R1 = (u64)&qq_pcltabs_bintotable;
	asi64(R2) = i;
	R1 += (i64)R2*24-24;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) != asi64(R2)) goto L4425;
	asi64(R1) = i;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4422;
L4425:
	i += 1; if (i <= av_1) goto L4420;
L4423:
	R1 = 0;
	R2 = tou64("No binto entry");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4422:
	goto L4342;
L4426:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 90;
	if (asi64(R1) != asi64(R2)) goto L4428;
	R1 = 1;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4428:
	goto L4342;
L4429:
	asu64(R1) = a;
	qq_pclgen_evalref(asu64(R1));
	R1 = 85;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4342;
L4430:
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = a;
	qq_pclgen_evalref(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) != asi64(R2)) goto L4432;
	R1 = 126;
	goto L4431;
L4432:
	R1 = 125;
L4431:
	qq_pcllib_genpc(asi64(R1));
	goto L4342;
L4433:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 77;
	qq_pcllib_genpc(asi64(R1));
	goto L4342;
L4434:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 79;
	qq_pcllib_genpc(asi64(R1));
	goto L4342;
L4435:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 97;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = p;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4342;
L4436:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 98;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4342;
L4437:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 127;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L4342;
L4438:
	R1 = 130;
	asu64(R2) = b;
	asu64(R3) = a;
	qq_pclgen_do_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L4342;
L4439:
	R1 = 136;
	asu64(R2) = b;
	asu64(R3) = a;
	qq_pclgen_do_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L4342;
L4440:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4442;
	R1 = 1;
	asu64(R2) = b;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L4441;
L4442:
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
L4441:
	R1 = 133;
	qq_pcllib_genpc(asi64(R1));
	goto L4342;
L4443:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 22;
	qq_pcllib_genpc(asi64(R1));
	goto L4342;
L4444:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4446;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 51;
	if (asi64(R1) != asi64(R2)) goto L4448;
	R1 = 1;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L4447;
L4448:
	asu64(R1) = a;
	qq_pclgen_evalref(asu64(R1));
L4447:
	goto L4445;
L4446:
	asu64(R1) = a;
	qq_pclgen_evalref(asu64(R1));
	R1 = 29;
	qq_pcllib_genpc(asi64(R1));
L4445:
	goto L4342;
L4449:
	asu64(R1) = p;
	qq_pclgen_do_convert(asu64(R1));
	goto L4342;
L4450:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 100;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	goto L4342;
L4451:
	asu64(R1) = p;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 19;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	goto L4342;
L4452:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	goto L4342;
L4453:
	asi64(R1) = res;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_pclgen_do_incr(asu64(R3), asu64(R2), asi64(R1));
	goto L4342;
L4454:
	R1 = 16;
	qq_pcllib_genpc(asi64(R1));
	goto L4342;
L4455:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 141;
	qq_pcllib_genpc(asi64(R1));
	goto L4342;
L4456:
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
	goto L4342;
L4457:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	R2 = 58;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
	goto L4342;
L4458:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 92;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
	goto L4342;
L4459:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 113;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4342;
L4460:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 114;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4342;
L4461:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 115;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
	goto L4342;
L4462:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4464;
	R1 = 82;
	qq_pcllib_genpc(asi64(R1));
	goto L4463;
L4464:
	R1 = 83;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4463:
	goto L4342;
L4465:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 84;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4342;
L4344:
	asu64(R1) = p;
	R2 = (u64)&qq_tables_jtagnames;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("UNSUPPORTED TAG:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L4342:
	R1 = (u64)&qq_tables_jhasvalue;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4467;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4468;
	goto L4469;
L4467:
	asi64(R1) = res;
	if (!asi64(R1)) goto L4471;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L4475;
	R2 = 55;
	if (asi64(R1) != asi64(R2)) goto L4474;
L4475:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L4473;
L4474:
	R1 = 0;
	R2 = (u64)&qq_tables_jtagnames;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("Value expected:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L4473:
L4471:
	goto L4466;
L4468:
	asi64(R1) = res;
	if (asi64(R1)) goto L4477;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 26;
	if (asi64(R1) != asi64(R2)) goto L4479;
	asi64(R1) = procflag;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4479;
	goto L4478;
L4479:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L4481;
	R2 = 61;
	if (asi64(R1) != asi64(R2)) goto L4480;
L4481:
	goto L4478;
L4480:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L4482;
	R1 = (u64)&qq_tables_hostisfn;
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4482;
	goto L4478;
L4482:
	R1 = 1;
	R2 = 58;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
L4478:
L4477:
	goto L4466;
L4469:
L4466:
L4341:
	return;
}

static void qq_pclgen_gencodemodule(u64 sp, i64 moduleno) {
    u64 R1, R2, R3, R4; 
	struct $B28 anonprocs;
	i64 nanonprocs;
	u64 d;
	u64 e;
	i64 lab;
	i64 a;
	i64 b;
	u64 pm;
	u64 pc;
	u64 pctarget;
	u64 labelmap;
	i64 av_1;
	i64 av_2;
	i64 i;
	R1 = 0;
	nanonprocs = asi64(R1);
	asu64(R1) = sp;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	a = asi64(R1);
	asu64(R1) = sp;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	b = asi64(R1);
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = moduleno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	asu64(R1) = pm;
	qq_decls_currmodule = asu64(R1);
	asu64(R1) = qq_decls_currmodule;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	qq_decls_stcurrmodule = asu64(R2);
	qq_decls_stcurrproc = asu64(R1);
	asu64(R1) = pm;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	qq_pcllib_resetpcl(asi64(R1));
	R1 = tou64("Module data init code:");
	qq_pcllib_gencomment(asu64(R1));
	R1 = 0;
	qq_decls_qpos = asi64(R1);
	asi64(R1) = moduleno;
	R2 = (u64)&qq_decls_qpos;
	R3 = 24;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = moduleno;
	asi64(R2) = a;
	if (asi64(R1) != asi64(R2)) goto L4485;
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab = asi64(R1);
	asi64(R1) = lab;
	R2 = 30;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	R1 = 1;
	R2 = 60;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
	asu64(R1) = qq_pcllib_pccurr;
	qq_decls_stopseq = asu64(R1);
	asu64(R1) = qq_pcllib_pccurr;
	R2 = 1;
	R1 += (i64)R2*32;
	qq_decls_raiseseq = asu64(R1);
	R1 = 0;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	R1 = 141;
	qq_pcllib_genpc(asi64(R1));
	asi64(R1) = lab;
	qq_pcllib_definefwdlabel(asi64(R1));
L4485:
	asu64(R1) = qq_decls_stcurrmodule;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L4487;
L4486:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4490;
	asu64(R1) = d;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4490;
	R1 = 1;
	asu64(R2) = d;
	R3 = 88;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
	R3 = 12;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4492;
	R1 = 27;
	qq_pcllib_genpc(asi64(R1));
L4492:
	asu64(R1) = d;
	R2 = 24;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L4489;
L4490:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4493;
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L4495;
L4494:
	asu64(R1) = e;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4498;
	asu64(R1) = e;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4498;
	R1 = 1;
	asu64(R2) = e;
	R3 = 88;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = e;
	R2 = 24;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L4497;
L4498:
	asu64(R1) = e;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L4499;
	asi64(R1) = nanonprocs;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L4501;
	R1 = 0;
	R2 = tou64("Too many anons");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4501:
	asu64(R1) = e;
	R2 = (u64)&anonprocs;
	R3 = (u64)&nanonprocs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4499:
L4497:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L4495:
	asu64(R1) = e;
	if (asu64(R1)) goto L4494;
L4493:
L4489:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L4487:
	asu64(R1) = d;
	if (asu64(R1)) goto L4486;
	asi64(R1) = moduleno;
	asi64(R2) = a;
	if (asi64(R1) != asi64(R2)) goto L4503;
	asi64(R1) = b;
	i = asi64(R1);
	asi64(R1) = a;
	R2 = 1;
	asi64(R1) += asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_1;
	if (asi64(R1) < asi64(R2)) goto L4506;
L4504:
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 54;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	i += -1; if (i >= av_1) goto L4504;
L4506:
	asi64(R1) = b;
	i = asi64(R1);
	asi64(R1) = a;
	R2 = 1;
	asi64(R1) += asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_2;
	if (asi64(R1) < asi64(R2)) goto L4509;
L4507:
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4511;
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 50;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
L4511:
	i += -1; if (i >= av_2) goto L4507;
L4509:
	asu64(R1) = qq_decls_currmodule;
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4513;
	asu64(R1) = qq_decls_currmodule;
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 50;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
L4513:
	asu64(R1) = qq_decls_currmodule;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4515;
	asu64(R1) = qq_decls_currmodule;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 50;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
L4515:
	R1 = 0;
	asu64(R2) = qq_decls_stcurrmodule;
	R3 = 88;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	R1 = 60;
	qq_pcllib_genpc(asi64(R1));
	goto L4502;
L4503:
	R1 = 0;
	asu64(R2) = qq_decls_stcurrmodule;
	R3 = 88;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 55;
	qq_pcllib_genpc(asi64(R1));
L4502:
	R1 = tou64("Procs:");
	qq_pcllib_gencomment(asu64(R1));
	asu64(R1) = qq_decls_stcurrmodule;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L4517;
L4516:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 5: case 6: goto L4522;
	case 7: goto L4535;
	case 8: goto L4538;
	case 9: goto L4524;
	case 10: goto L4534;
	case 11: case 12: case 14: case 15: case 16: case 21: goto L4521;
	case 13: goto L4523;
	case 17: goto L4533;
	case 18: goto L4531;
	case 19: goto L4532;
	case 20: goto L4536;
	case 22: goto L4537;
	default: goto L4521;
    };
// SWITCH
L4522:
	asu64(R1) = d;
	qq_pclgen_do_procdef(asu64(R1));
	goto L4519;
L4523:
	goto L4519;
L4524:
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L4528;
L4525:
	asu64(R1) = e;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4530;
	asu64(R1) = e;
	qq_pclgen_do_procdef(asu64(R1));
L4530:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L4528:
	asu64(R1) = e;
	if (asu64(R1)) goto L4525;
	goto L4519;
L4531:
	goto L4519;
L4532:
	goto L4519;
L4533:
	goto L4519;
L4534:
	goto L4519;
L4535:
	goto L4519;
L4536:
	goto L4519;
L4537:
	goto L4519;
L4538:
	goto L4519;
L4521:
	R1 = 0;
	R2 = (u64)&qq_tables_namenames;
	asu64(R3) = d;
	R4 = 124;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("?Module def:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L4519:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L4517:
	asu64(R1) = d;
	if (asu64(R1)) goto L4516;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nanonprocs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4541;
L4539:
	R1 = (u64)&anonprocs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	qq_pclgen_do_procdef(asu64(R1));
	i += 1; if (i <= nanonprocs) goto L4539;
L4541:
	R1 = 5;
	qq_pcllib_genpc(asi64(R1));
	asi64(R1) = qq_pcllib_nextlabelno;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	labelmap = asu64(R1);
	asu64(R1) = qq_pcllib_pcstart;
	pc = asu64(R1);
	goto L4545;
L4542:
	R1 = (u64)&qq_pcltabs_pclopnd;
	asu64(R2) = pc;
	R3 = 8;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L4547;
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	lab = asi64(R1);
	asu64(R1) = qq_pcllib_labelpctable;
	asi64(R2) = lab;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pctarget = asu64(R1);
	asu64(R1) = pctarget;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4549;
	R1 = 0;
	R2 = 0;
	asi64(R3) = lab;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	R3 = tou64("Lab undef:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L4549:
	R1 = 1;
	asu64(R2) = labelmap;
	asi64(R3) = lab;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = pctarget;
	asu64(R2) = pc;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4547:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L4545:
	asu64(R1) = pc;
	asu64(R2) = qq_pcllib_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L4542;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_pcllib_nextlabelno;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4552;
L4550:
	asu64(R1) = labelmap;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L4554;
	R1 = 1;
	asu64(R2) = qq_pcllib_labelpctable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 11;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L4554:
	i += 1; if (i <= qq_pcllib_nextlabelno) goto L4550;
L4552:
	asi64(R1) = qq_pcllib_nextlabelno;
	asu64(R2) = labelmap;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = qq_pcllib_pcstart;
	asu64(R2) = pm;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = qq_pcllib_pccurr;
	asu64(R2) = pm;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = qq_pcllib_pcstart;
	asu64(R2) = qq_pcllib_pccurr;
	asi64(R1) = qq_lib_getpcloffset(asu64(R2), asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = pm;
	R3 = 72;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = qq_pcllib_pcsourcestart;
	asu64(R2) = pm;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_pclgen_do_procdef(u64 p) {
    u64 R1, R2, R3; 
	i64 nfreevars;
	i64 nnofreevars;
	i64 isfunc;
	u64 oldcurrproc;
	asu64(R1) = qq_decls_stcurrproc;
	oldcurrproc = asu64(R1);
	asu64(R1) = p;
	qq_decls_stcurrproc = asu64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	qq_pclgen_retindex = asi64(R1);
	asu64(R1) = p;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 4;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	isfunc = asi64(R1);
	R1 = (u64)&nnofreevars;
	R2 = (u64)&nfreevars;
	asu64(R3) = p;
	qq_pclgen_genprocentry(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4557;
	R1 = 0;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Empty proc body");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
	goto L4556;
L4557:
	asi64(R1) = isfunc;
	asu64(R2) = p;
	R3 = 88;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = isfunc;
	if (!asi64(R1)) goto L4559;
	asu64(R1) = p;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = qq_pclgen_checkblockreturn(asu64(R1));
	if (asi64(R1)) goto L4561;
	R1 = 0;
	R2 = tou64("Func: return value missing");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4561:
L4559:
L4556:
	asi64(R1) = qq_pclgen_retindex;
	qq_pcllib_definefwdlabel(asi64(R1));
	asi64(R1) = isfunc;
	asi64(R2) = nnofreevars;
	asi64(R3) = nfreevars;
	qq_pclgen_genprocexit(asi64(R3), asi64(R2), asi64(R1));
	R1 = 4;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = qq_pclgen_pprocentry;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4563;
	R1 = (u64)&qq_pclgen_pprocentry;
	(*tou64p(R1)) += 32;
L4563:
	asu64(R1) = qq_pclgen_pprocentry;
	asu64(R2) = p;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = oldcurrproc;
	qq_decls_stcurrproc = asu64(R1);
	return;
}

static void qq_pclgen_genprocentry(u64 p, u64 nfreevars, u64 nnofreevars) {
    u64 R1, R2, R3; 
	struct $B77 str;
	i64 n;
	u64 d;
	asu64(R1) = p;
	R2 = 2;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	R1 = 0;
	R2 = R1;
	qq_decls_nproclocals = asi64(R2);
	qq_pclgen_nprocparams = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L4566;
L4565:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4569;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L4570;
	goto L4571;
L4569:
	R1 = (u64)&qq_decls_nproclocals;
	(*toi64p(R1)) += 1;
	asi64(R1) = qq_decls_nproclocals;
	asu64(R2) = d;
	R3 = 96;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4568;
L4570:
	R1 = (u64)&qq_pclgen_nprocparams;
	(*toi64p(R1)) += 1;
	goto L4568;
L4571:
L4568:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L4566:
	asu64(R1) = d;
	if (asu64(R1)) goto L4565;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = qq_pclgen_nprocparams;
	n = asi64(R1);
	goto L4575;
L4572:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L4577;
	goto L4578;
L4577:
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R1) = -asi64(R1);
	asu64(R2) = d;
	R3 = 96;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4576;
L4578:
L4576:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L4575:
	asu64(R1) = d;
	if (asu64(R1)) goto L4572;
	asi64(R1) = qq_pclgen_nprocparams;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R1) = -asi64(R1);
	qq_pclgen_retvaloffset = asi64(R1);
	asi64(R1) = qq_decls_nproclocals;
	R2 = 3;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
	asu64(R1) = qq_pcllib_pccurr;
	qq_pclgen_pprocentry = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L4580;
L4579:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4583;
	goto L4584;
L4583:
	asu64(R1) = d;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4586;
	R1 = 1;
	asu64(R2) = d;
	R3 = 88;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
	R3 = 12;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4588;
	R1 = 27;
	qq_pcllib_genpc(asi64(R1));
L4588:
	asu64(R1) = d;
	R2 = 24;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
L4586:
	goto L4582;
L4584:
L4582:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L4580:
	asu64(R1) = d;
	if (asu64(R1)) goto L4579;
	return;
}

static void qq_pclgen_genprocexit(i64 nfree, i64 nnofree, i64 isfunc) {
    u64 R1, R2, R3; 
	i64 offset;
	asi64(R1) = isfunc;
	if (!asi64(R1)) goto L4591;
	asi64(R1) = qq_pclgen_nprocparams;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R1) = -asi64(R1);
	R2 = 16;
	asi64(R1) *= asi64(R2);
	offset = asi64(R1);
	asi64(R1) = offset;
	asi64(R2) = qq_decls_nproclocals;
	R3 = 53;
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = qq_pclgen_nprocparams;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4590;
L4591:
	asi64(R1) = qq_pclgen_nprocparams;
	R2 = 52;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
	asi64(R1) = qq_decls_nproclocals;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 12;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L4590:
	return;
}

static void qq_pclgen_evalref(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 a;
	u64 b;
	u64 c;
	u64 d;
	i64 lab1;
	i64 lab2;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L4594;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L4595;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L4596;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L4597;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L4598;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L4599;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L4600;
	goto L4601;
L4594:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4604;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L4603;
L4604:
	R1 = 0;
	R2 = tou64("^ not allowed");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4603:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L4606;
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L4606;
	asu64(R1) = d;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L4605;
L4606:
	asu64(R1) = d;
	R2 = 9;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
L4605:
	goto L4593;
L4595:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 129;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L4593;
L4596:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 132;
	qq_pcllib_genpc(asi64(R1));
	goto L4593;
L4597:
	asu64(R1) = a;
	qq_pclgen_evalref(asu64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 138;
	qq_pcllib_genpc(asi64(R1));
	goto L4593;
L4598:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4608;
	R1 = 0;
	R2 = tou64("Def val not allowed");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4608:
	R1 = 135;
	qq_pcllib_genpc(asi64(R1));
	goto L4593;
L4599:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L4593;
L4600:
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab1 = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab1;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 33;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_pclgen_evalref(asu64(R1));
	asi64(R1) = lab2;
	qq_pclgen_genjumpl(asi64(R1));
	asi64(R1) = lab1;
	qq_pcllib_definefwdlabel(asi64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_pclgen_evalref(asu64(R1));
	asi64(R1) = lab2;
	qq_pcllib_definefwdlabel(asi64(R1));
	goto L4593;
L4601:
	R1 = 0;
	R2 = (u64)&qq_tables_jtagnames;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("evalref");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L4593:
	return;
}

static void qq_pclgen_genjumpcond(i64 opc, u64 p, i64 lab) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 r;
	u64 s;
	i64 oldpos;
	i64 lab2;
	i64 i;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L4611;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L4612;
	R2 = 74;
	if (asi64(R1) == asi64(R2)) goto L4613;
	R2 = 75;
	if (asi64(R1) == asi64(R2)) goto L4614;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4615;
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L4616;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L4617;
	goto L4618;
L4611:
	asi64(R1) = opc;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L4620;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L4621;
	goto L4622;
L4620:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 33;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 33;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L4619;
L4621:
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab2;
	asu64(R2) = q;
	R3 = 33;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 32;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab2;
	qq_pcllib_definefwdlabel(asi64(R1));
	goto L4619;
L4622:
L4619:
	goto L4610;
L4612:
	asi64(R1) = opc;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L4624;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L4625;
	goto L4626;
L4624:
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab2;
	asu64(R2) = q;
	R3 = 32;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 33;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab2;
	qq_pcllib_definefwdlabel(asi64(R1));
	goto L4623;
L4625:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 32;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 32;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L4623;
L4626:
L4623:
	goto L4610;
L4613:
	asi64(R1) = opc;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L4628;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L4629;
	goto L4630;
L4628:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 32;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L4627;
L4629:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 33;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L4627;
L4630:
L4627:
	goto L4610;
L4614:
	asi64(R1) = lab;
	asu64(R2) = q;
	asi64(R3) = opc;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L4610;
L4615:
	goto L4632;
L4631:
	R1 = 1;
	asu64(R2) = q;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L4632:
	asu64(R1) = q;
	if (!asu64(R1)) goto L4634;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L4631;
L4634:
	asi64(R1) = lab;
	asu64(R2) = q;
	asi64(R3) = opc;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L4610;
L4616:
	R1 = 1;
	asu64(R2) = q;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = r;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = opc;
	qq_pclgen_gcomparejump(asi64(R3), asi64(R2), asi64(R1));
	goto L4610;
L4617:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = opc;
	R2 = 33;
	if (asi64(R1) != asi64(R2)) goto L4636;
	goto L4638;
L4637:
	R1 = 1;
	asu64(R2) = q;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = r;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = lab;
	R2 = (u64)&qq_tables_revconds;
	asu64(R3) = p;
	R4 = 24;
	R3 += (i64)R4;
	asi64(R4) = i;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 32;
	qq_pclgen_gcomparejump(asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	asu64(R1) = r;
	q = asu64(R1);
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L4638:
	asu64(R1) = r;
	if (asu64(R1)) goto L4637;
	goto L4635;
L4636:
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab2 = asi64(R1);
	goto L4641;
L4640:
	R1 = 1;
	asu64(R2) = q;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = r;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4644;
	asi64(R1) = lab2;
	R2 = (u64)&qq_tables_revconds;
	asu64(R3) = p;
	R4 = 24;
	R3 += (i64)R4;
	asi64(R4) = i;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 32;
	qq_pclgen_gcomparejump(asi64(R3), asi64(R2), asi64(R1));
	goto L4643;
L4644:
	asi64(R1) = lab;
	asu64(R2) = p;
	R3 = 24;
	R2 += (i64)R3;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	R3 = 32;
	qq_pclgen_gcomparejump(asi64(R3), asi64(R2), asi64(R1));
L4643:
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	asu64(R1) = r;
	q = asu64(R1);
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L4641:
	asu64(R1) = r;
	if (asu64(R1)) goto L4640;
	asi64(R1) = lab2;
	qq_pcllib_definefwdlabel(asi64(R1));
L4635:
	goto L4610;
L4618:
	R1 = 1;
	asu64(R2) = p;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asi64(R2) = opc;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
L4610:
	asi64(R1) = oldpos;
	qq_decls_qpos = asi64(R1);
	return;
}

static void qq_pclgen_gcomparejump(i64 opc, i64 cond, i64 lab) {
    u64 R1, R2, R3; 
	asi64(R1) = opc;
	R2 = 33;
	if (asi64(R1) != asi64(R2)) goto L4647;
	R1 = (u64)&qq_tables_revconds;
	asi64(R2) = cond;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cond = asi64(R1);
L4647:
	asi64(R1) = lab;
	R2 = 34;
	asi64(R3) = cond;
	asi64(R2) += asi64(R3);
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	return;
}

static void qq_pclgen_genjumpl(i64 lab) {
    u64 R1, R2; 
	asi64(R1) = lab;
	R2 = 30;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	return;
}

static void qq_pclgen_stacklooplabels(i64 a, i64 b, i64 c) {
    u64 R1, R2, R3; 
	asi64(R1) = qq_pclgen_loopindex;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L4651;
	R1 = 0;
	R2 = tou64("Too many nested loops");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4651:
	R1 = (u64)&qq_pclgen_loopindex;
	(*toi64p(R1)) += 1;
	asi64(R1) = a;
	R2 = (u64)&qq_pclgen_loopstack;
	asi64(R3) = qq_pclgen_loopindex;
	R2 += (i64)R3*32-32;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&qq_pclgen_loopstack;
	asi64(R3) = qq_pclgen_loopindex;
	R2 += (i64)R3*32-32;
	R3 = 2;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = c;
	R2 = (u64)&qq_pclgen_loopstack;
	asi64(R3) = qq_pclgen_loopindex;
	R2 += (i64)R3*32-32;
	R3 = 3;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	return;
}

static void qq_pclgen_unstacklooplabels() {
    u64 R1; 
	R1 = (u64)&qq_pclgen_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static i64 qq_pclgen_findlooplabel(i64 k, i64 n) {
    u64 R1, R2, R3; 
	i64 i;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4655;
	R1 = 1;
	i = asi64(R1);
	goto L4654;
L4655:
	asi64(R1) = qq_pclgen_loopindex;
	asi64(R2) = n;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) -= asi64(R2);
	i = asi64(R1);
L4654:
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4658;
	asi64(R1) = i;
	asi64(R2) = qq_pclgen_loopindex;
	if (asi64(R1) <= asi64(R2)) goto L4657;
L4658:
	R1 = 0;
	R2 = tou64("Bad loop index");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4657:
	R1 = (u64)&qq_pclgen_trylevelstack;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	qq_pclgen_looptrylevel = asi64(R1);
	R1 = (u64)&qq_pclgen_loopstack;
	asi64(R2) = i;
	R1 += (i64)R2*32-32;
	asi64(R2) = k;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L4653;
L4653:
	return asi64(R1);
}

static void qq_pclgen_do_assign(u64 a, u64 b, i64 res, i64 deepcopy) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 n;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L4661;
	R2 = 88;
	if (asi64(R1) != asi64(R2)) goto L4661;
	asi64(R1) = res;
	if (!asi64(R1)) goto L4663;
	R1 = 0;
	R2 = tou64("mult/ass::=");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4663:
	asi64(R1) = res;
	asi64(R2) = deepcopy;
	asu64(R3) = b;
	asu64(R4) = a;
	qq_pclgen_do_multassign(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L4659;
L4661:
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = deepcopy;
	if (!asi64(R1)) goto L4665;
	R1 = 27;
	qq_pcllib_genpc(asi64(R1));
L4665:
	asi64(R1) = res;
	asu64(R2) = a;
	qq_pclgen_do_store(asu64(R2), asi64(R1));
L4659:
	return;
}

static void qq_pclgen_do_bin(u64 a, u64 b, i64 opc) {
    u64 R1, R2; 
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = opc;
	qq_pcllib_genpc(asi64(R1));
	return;
}

static void qq_pclgen_do_binref(u64 a, u64 b, i64 opc) {
    u64 R1, R2; 
	asu64(R1) = a;
	qq_pclgen_evalref(asu64(R1));
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = opc;
	qq_pcllib_genpc(asi64(R1));
	return;
}

static void qq_pclgen_do_unary(u64 a, i64 opc) {
    u64 R1, R2; 
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = opc;
	qq_pcllib_genpc(asi64(R1));
	return;
}

static void qq_pclgen_do_unaryref(u64 a, i64 opc) {
    u64 R1; 
	asu64(R1) = a;
	qq_pclgen_evalref(asu64(R1));
	asi64(R1) = opc;
	qq_pcllib_genpc(asi64(R1));
	return;
}

static void qq_pclgen_do_pushlist(u64 a, i64 n) {
    u64 R1, R2; 
	goto L4674;
L4671:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L4674:
	asu64(R1) = a;
	if (asu64(R1)) goto L4671;
	return;
}

static void qq_pclgen_do_makedict(u64 a, i64 n) {
    u64 R1, R2, R3; 
	i64 av_1;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4678;
L4676:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L4680;
	R1 = 1;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = a;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L4679;
L4680:
	R1 = 0;
	R2 = tou64("dict not key:val");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4679:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	if (--asi64(av_1)) goto L4676;
L4678:
	R1 = 0;
	asi64(R2) = n;
	R3 = 68;
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	return;
}

static void qq_pclgen_do_call(u64 p, u64 a, u64 b, i64 res, u64 procflag) {
    u64 R1, R2, R3, R4; 
	i64 nargs;
	i64 nsimple;
	i64 isfunc;
	i64 kwdindex;
	u64 d;
	u64 c;
	struct $B28 arglist;
	i64 i;
	R1 = 1;
	isfunc = asi64(R1);
	R1 = 0;
	R2 = R1;
	nsimple = asi64(R2);
	nargs = asi64(R1);
	R1 = 0;
	kwdindex = asi64(R1);
	asu64(R1) = b;
	c = asu64(R1);
	goto L4683;
L4682:
	asu64(R1) = c;
	R2 = (u64)&arglist;
	R3 = (u64)&nargs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = c;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L4687;
	R2 = 42;
	if (asi64(R1) != asi64(R2)) goto L4686;
L4687:
	R1 = (u64)&nsimple;
	(*toi64p(R1)) += 1;
L4686:
	asu64(R1) = c;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4689;
	asi64(R1) = kwdindex;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4691;
	asi64(R1) = nargs;
	kwdindex = asi64(R1);
L4691:
	goto L4688;
L4689:
	asi64(R1) = kwdindex;
	if (!asi64(R1)) goto L4692;
	R1 = 0;
	R2 = tou64("Non-kwd follows kwd arg");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4692:
L4688:
	asu64(R1) = c;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	c = asu64(R1);
L4683:
	asu64(R1) = c;
	if (asu64(R1)) goto L4682;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L4694;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L4695;
	goto L4696;
L4694:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
// qq_pclgen.do_call.retry:
L4697:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4699;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4699;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L4700;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L4701;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L4702;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4702;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L4702;
	goto L4703;
L4699:
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 4;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L4705;
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
	asi64(R1) = kwdindex;
	asi64(R2) = nargs;
	R3 = (u64)&arglist;
	asu64(R4) = d;
	asi64(R1) = qq_pclgen_pushparams(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	nargs = asi64(R1);
	asu64(R1) = d;
	R2 = 50;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L4704;
L4705:
	R1 = 0;
	isfunc = asi64(R1);
	asi64(R1) = kwdindex;
	asi64(R2) = nargs;
	R3 = (u64)&arglist;
	asu64(R4) = d;
	asi64(R1) = qq_pclgen_pushparams(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	nargs = asi64(R1);
	asu64(R1) = d;
	R2 = 50;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
L4704:
	asi64(R1) = nargs;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4698;
L4700:
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 4;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L4707;
	R1 = 0;
	isfunc = asi64(R1);
	goto L4706;
L4707:
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
L4706:
	asi64(R1) = kwdindex;
	asi64(R2) = nargs;
	R3 = (u64)&arglist;
	asu64(R4) = d;
	asi64(R1) = qq_pclgen_pushparams(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	nargs = asi64(R1);
	asu64(R1) = d;
	R2 = 56;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asi64(R1) = nargs;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4698;
L4701:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L4697;
	goto L4698;
L4702:
	goto L4708;
	goto L4698;
L4703:
	R1 = 0;
	R2 = (u64)&qq_tables_namenames;
	asu64(R3) = d;
	R4 = 124;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("CAN'T CALL:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L4698:
	goto L4693;
L4695:
	asi64(R1) = kwdindex;
	if (!asi64(R1)) goto L4710;
	goto L4708;
L4710:
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_pclgen_evalref(asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nargs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4713;
L4711:
	R1 = 1;
	R2 = (u64)&arglist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	i += 1; if (i <= nargs) goto L4711;
L4713:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = (u64)&nargs;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 51;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
	goto L4693;
L4696:
// qq_pclgen.do_call.docallptr:
L4708:
	asi64(R1) = kwdindex;
	if (!asi64(R1)) goto L4715;
	R1 = 0;
	R2 = tou64("Kwd params not allowed for fnptr");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4715:
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nargs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4718;
L4716:
	R1 = 1;
	R2 = (u64)&arglist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	i += 1; if (i <= nargs) goto L4716;
L4718:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = nargs;
	R2 = 51;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
L4693:
	asi64(R1) = res;
	if (!asi64(R1)) goto L4720;
	asi64(R1) = isfunc;
	if (asi64(R1)) goto L4720;
	R1 = 0;
	R2 = tou64("Func ret value expected");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4720:
	asi64(R1) = isfunc;
	asi64(R1) = !asi64(R1);
	asu64(R2) = procflag;
	*toi64p(R2) = asi64(R1);
	return;
}

static i64 qq_pclgen_pushparams(u64 d, u64 arglist, i64 nargs, i64 kwdindex) {
    u64 R1, R2, R3, R4; 
	i64 nparams;
	i64 extra;
	i64 n;
	struct $B28 paramlist;
	struct $B5 byreflist;
	u64 e;
	u64 p;
	i64 i;
	asu64(R1) = d;
	R2 = 104;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	nparams = asi64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	goto L4723;
L4722:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asu64(R1) = e;
	R2 = (u64)&paramlist;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = e;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = (u64)&byreflist;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L4723:
	asu64(R1) = e;
	if (asu64(R1)) goto L4722;
	asi64(R1) = kwdindex;
	if (!asi64(R1)) goto L4726;
	asi64(R1) = kwdindex;
	asi64(R2) = nargs;
	asu64(R3) = arglist;
	asu64(R4) = d;
	qq_pclgen_pushkwdparams(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = d;
	R2 = 104;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	goto L4721;
L4726:
	R1 = 0;
	extra = asi64(R1);
	asi64(R1) = nargs;
	asi64(R2) = nparams;
	if (asi64(R1) != asi64(R2)) goto L4728;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nargs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4731;
L4729:
	R1 = (u64)&byreflist;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = arglist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_evalparam(asu64(R2), asi64(R1));
	i += 1; if (i <= nargs) goto L4729;
L4731:
	asi64(R1) = nargs;
	goto L4727;
L4728:
	asi64(R1) = nargs;
	asi64(R2) = nparams;
	if (asi64(R1) >= asi64(R2)) goto L4732;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nargs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4735;
L4733:
	R1 = (u64)&byreflist;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = arglist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_evalparam(asu64(R2), asi64(R1));
	i += 1; if (i <= nargs) goto L4733;
L4735:
	asi64(R1) = nargs;
	R2 = 1;
	asi64(R1) += asi64(R2);
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = nparams;
	if (asi64(R1) > asi64(R2)) goto L4738;
L4736:
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L4740;
	asu64(R1) = p;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L4740;
	R1 = 0;
	R2 = 0;
	asi64(R3) = i;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	R3 = tou64("Param not optional:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L4740:
	asu64(R1) = p;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4742;
	R1 = (u64)&byreflist;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L4744;
	R1 = 0;
	R2 = tou64("byref with default val");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4744:
	R1 = 1;
	asu64(R2) = p;
	R3 = 88;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L4741;
L4742:
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
L4741:
	i += 1; if (i <= nparams) goto L4736;
L4738:
	asi64(R1) = nparams;
	goto L4727;
L4732:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4747;
L4745:
	R1 = (u64)&byreflist;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = arglist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_evalparam(asu64(R2), asi64(R1));
	i += 1; if (i <= nparams) goto L4745;
L4747:
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 8;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L4749;
	R1 = 0;
	R2 = tou64("Too many args");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4749:
	asi64(R1) = nparams;
	R2 = 1;
	asi64(R1) += asi64(R2);
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = nargs;
	if (asi64(R1) > asi64(R2)) goto L4752;
L4750:
	R1 = 1;
	asu64(R2) = arglist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	i += 1; if (i <= nargs) goto L4750;
L4752:
	asi64(R1) = nargs;
L4727:
	goto L4721;
L4721:
	return asi64(R1);
}

static void qq_pclgen_evalparam(u64 a, i64 byref) {
    u64 R1, R2; 
	asi64(R1) = byref;
	if (!asi64(R1)) goto L4755;
	asu64(R1) = a;
	qq_pclgen_evalref(asu64(R1));
	goto L4754;
L4755:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
L4754:
	return;
}

static void qq_pclgen_pushkwdparams(u64 d, u64 arglist, i64 nargs, i64 kwdindex) {
    u64 R1, R2, R3; 
	i64 nparams;
	i64 i;
	i64 j;
	i64 k;
	struct $B28 paramlist;
	struct $B5 byreflist;
	struct $B28 keyunits;
	u64 p;
	u64 q;
	u64 e;
	i64 av_1;
	asu64(R1) = d;
	R2 = 104;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	nparams = asi64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4759;
L4757:
	asu64(R1) = e;
	R2 = (u64)&paramlist;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = e;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = (u64)&byreflist;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	i += 1; if (i <= nparams) goto L4757;
L4759:
	asi64(R1) = nargs;
	asi64(R2) = nparams;
	if (asi64(R1) <= asi64(R2)) goto L4761;
	R1 = 0;
	R2 = tou64("Too many args");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4761:
	asi64(R1) = kwdindex;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = nparams;
	if (asi64(R1) > asi64(R2)) goto L4764;
L4762:
	R1 = 0;
	R2 = (u64)&keyunits;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= nparams) goto L4762;
L4764:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = kwdindex;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4767;
L4765:
	R1 = (u64)&byreflist;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = arglist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_evalparam(asu64(R2), asi64(R1));
	i += 1; if (i <= av_1) goto L4765;
L4767:
	asi64(R1) = kwdindex;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = nargs;
	if (asi64(R1) > asi64(R2)) goto L4770;
L4768:
	asu64(R1) = arglist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L4772;
	R1 = 0;
	R2 = tou64("kwd not a name");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4772:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	k = asi64(R1);
	R1 = 1;
	j = asi64(R1);
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4775;
L4773:
	R1 = (u64)&paramlist;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4777;
	asi64(R1) = j;
	k = asi64(R1);
	goto L4775;
L4777:
	j += 1; if (j <= nparams) goto L4773;
L4775:
	asi64(R1) = k;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4779;
	R1 = 0;
	asu64(R2) = e;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Can't find kwd param:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L4779:
	asi64(R1) = k;
	asi64(R2) = kwdindex;
	if (asi64(R1) >= asi64(R2)) goto L4781;
	R1 = 0;
	asu64(R2) = e;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Kwd arg already positional:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L4781:
	R1 = (u64)&keyunits;
	asi64(R2) = k;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	if (!asu64(R1)) goto L4783;
	R1 = 0;
	asu64(R2) = e;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Repeating kwd arg:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L4783:
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&keyunits;
	asi64(R3) = k;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= nargs) goto L4768;
L4770:
	asi64(R1) = kwdindex;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = nparams;
	if (asi64(R1) > asi64(R2)) goto L4786;
L4784:
	R1 = (u64)&keyunits;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4788;
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4790;
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L4790;
	R1 = 0;
	R2 = 0;
	asi64(R3) = i;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	R3 = tou64("Param not optional:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L4790:
	asu64(R1) = q;
	R2 = (u64)&keyunits;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4788:
	i += 1; if (i <= nparams) goto L4784;
L4786:
	asi64(R1) = kwdindex;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = nparams;
	if (asi64(R1) > asi64(R2)) goto L4793;
L4791:
	R1 = (u64)&keyunits;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	if (!asu64(R1)) goto L4795;
	R1 = (u64)&byreflist;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&keyunits;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_evalparam(asu64(R2), asi64(R1));
	goto L4794;
L4795:
	R1 = (u64)&byreflist;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L4796;
	R1 = 0;
	R2 = tou64("byref param not optional");
	qq_lib_gerror(asu64(R2), asu64(R1));
	goto L4794;
L4796:
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
L4794:
	i += 1; if (i <= nparams) goto L4791;
L4793:
	return;
}

static void qq_pclgen_do_if(u64 p, u64 a, u64 b, u64 pelse, i64 res) {
    u64 R1, R2, R3; 
	i64 lab1;
	i64 lab2;
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab1 = asi64(R1);
	asu64(R1) = pelse;
	if (asu64(R1)) goto L4800;
	asi64(R1) = res;
	if (!asi64(R1)) goto L4799;
L4800:
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab2 = asi64(R1);
L4799:
	asi64(R1) = lab1;
	asu64(R2) = a;
	R3 = 33;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = res;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = pelse;
	if (asu64(R1)) goto L4803;
	asi64(R1) = res;
	if (!asi64(R1)) goto L4802;
L4803:
	asi64(R1) = lab2;
	qq_pclgen_genjumpl(asi64(R1));
	asi64(R1) = lab1;
	qq_pcllib_definefwdlabel(asi64(R1));
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L4805;
	asi64(R1) = res;
	asu64(R2) = pelse;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L4804;
L4805:
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
L4804:
	asi64(R1) = lab2;
	qq_pcllib_definefwdlabel(asi64(R1));
	goto L4801;
L4802:
	asi64(R1) = lab1;
	qq_pcllib_definefwdlabel(asi64(R1));
L4801:
	return;
}

static void qq_pclgen_do_do(u64 p, u64 a) {
    u64 R1, R2, R3; 
	i64 lab_abc;
	i64 lab_d;
	i64 lab_test;
	asi64(R1) = qq_pcllib_definelabel();
	lab_abc = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_abc;
	asi64(R3) = lab_abc;
	qq_pclgen_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = lab_abc;
	qq_pclgen_genjumpl(asi64(R1));
	asi64(R1) = lab_d;
	qq_pcllib_definefwdlabel(asi64(R1));
	qq_pclgen_unstacklooplabels();
	return;
}

static void qq_pclgen_do_loop(u64 p) {
    u64 R1, R2, R3; 
	i64 n;
	i64 index;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	index = asi64(R1);
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4809;
	asi64(R1) = qq_pclgen_loopindex;
	index = asi64(R1);
L4809:
	asi64(R1) = index;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) = qq_pclgen_findlooplabel(asi64(R2), asi64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4811;
	msysc_m$print_startcon();
	R1 = tou64("BAD LOOP");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L4810;
L4811:
	asi64(R1) = n;
	qq_pclgen_genjumpl(asi64(R1));
L4810:
	return;
}

static void qq_pclgen_do_to(u64 p, u64 pcount, u64 pbody) {
    u64 R1, R2, R3, R4; 
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	u64 temp;
	u64 pav;
	asu64(R1) = pcount;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pav = asu64(R1);
	asu64(R1) = pav;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	temp = asu64(R1);
	R1 = 1;
	asu64(R2) = pcount;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = temp;
	R2 = 24;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_b = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_b;
	qq_pclgen_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pcount;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L4814;
	asu64(R1) = temp;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	R1 = 0;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	asi64(R1) = lab_d;
	R2 = 37;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	goto L4813;
L4814:
	asu64(R1) = pcount;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L4815;
	asi64(R1) = lab_d;
	R2 = 30;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
L4815:
L4813:
	asi64(R1) = lab_b;
	qq_pcllib_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R2) = pbody;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = lab_c;
	qq_pcllib_definefwdlabel(asi64(R1));
	asi64(R1) = lab_b;
	R2 = 44;
	asu64(R3) = temp;
	R4 = 120;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 9;
    asi64(R3) = Getdotindex(asu64(R3), asi64(R4));
	asi64(R2) += asi64(R3);
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	asu64(R1) = temp;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asi64(R1) = lab_d;
	qq_pcllib_definefwdlabel(asi64(R1));
	qq_pclgen_unstacklooplabels();
	return;
}

static void qq_pclgen_do_while(u64 p, u64 pcond, u64 pbody) {
    u64 R1, R2, R3; 
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	i64 lab_incr;
	u64 pincr;
	asu64(R1) = pcond;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pincr = asu64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_b = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_d = asi64(R1);
	asu64(R1) = pincr;
	if (!asu64(R1)) goto L4818;
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_incr = asi64(R1);
	goto L4817;
L4818:
	asi64(R1) = lab_c;
	lab_incr = asi64(R1);
L4817:
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_b;
	qq_pclgen_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = lab_incr;
	qq_pclgen_genjumpl(asi64(R1));
	asi64(R1) = lab_b;
	qq_pcllib_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R2) = pbody;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = lab_c;
	qq_pcllib_definefwdlabel(asi64(R1));
	asu64(R1) = pincr;
	if (!asu64(R1)) goto L4820;
	R1 = 1;
	asu64(R2) = pincr;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = lab_incr;
	qq_pcllib_definefwdlabel(asi64(R1));
L4820:
	asi64(R1) = lab_b;
	asu64(R2) = pcond;
	R3 = 32;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab_d;
	qq_pcllib_definefwdlabel(asi64(R1));
	R1 = (u64)&qq_pclgen_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void qq_pclgen_do_repeat(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	asi64(R1) = qq_pcllib_definelabel();
	lab_b = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_b;
	qq_pclgen_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = lab_c;
	qq_pcllib_definefwdlabel(asi64(R1));
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L4824;
	asu64(R1) = b;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4823;
L4824:
	asi64(R1) = lab_b;
	asu64(R2) = b;
	R3 = 33;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
L4823:
	asi64(R1) = lab_d;
	qq_pcllib_definefwdlabel(asi64(R1));
	R1 = (u64)&qq_pclgen_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void qq_pclgen_do_for(u64 p, u64 pvar, u64 pbody) {
    u64 R1, R2, R3; 
	u64 pfrom;
	u64 pto;
	u64 pstep;
	u64 pelse;
	u64 plimit;
	u64 pautovar;
	u64 dvar;
	u64 limitvar;
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	i64 lab_e;
	i64 opc;
	i64 oldqpos;
	i64 step;
	i64 fromval;
	i64 limit;
	i64 jumpinto;
	asu64(R1) = pvar;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pfrom = asu64(R1);
	asu64(R1) = pfrom;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pto = asu64(R1);
	asu64(R1) = pto;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pstep = asu64(R1);
	R1 = 0;
	pautovar = asu64(R1);
	asu64(R1) = pstep;
	if (!asu64(R1)) goto L4827;
	R1 = 0;
	R2 = tou64("By N not implem");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4827:
	asu64(R1) = pbody;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pelse = asu64(R1);
	asu64(R1) = pvar;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dvar = asu64(R1);
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L4831;
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L4830;
L4831:
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L4829;
	asu64(R1) = pto;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = dvar;
	R3 = 120;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	if (asu64(R1) == asu64(R2)) goto L4829;
L4830:
	asu64(R1) = qq_decls_stcurrproc;
	asu64(R1) = qq_lib_createavnamex(asu64(R1));
	pautovar = asu64(R1);
L4829:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4833;
	R1 = -1;
	step = asi64(R1);
	goto L4832;
L4833:
	R1 = 1;
	step = asi64(R1);
L4832:
	R1 = 1;
	jumpinto = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_b = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_d = asi64(R1);
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L4835;
	asi64(R1) = qq_pcllib_createfwdlabel();
	goto L4834;
L4835:
	asi64(R1) = lab_d;
L4834:
	lab_e = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_b;
	qq_pclgen_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pfrom;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L4837;
	asu64(R1) = pfrom;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	fromval = asi64(R1);
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L4839;
	asu64(R1) = pto;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	limit = asi64(R1);
	asi64(R1) = step;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L4843;
	asi64(R1) = fromval;
	asi64(R2) = limit;
	if (asi64(R1) >= asi64(R2)) goto L4842;
L4843:
	asi64(R1) = step;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4841;
	asi64(R1) = fromval;
	asi64(R2) = limit;
	if (asi64(R1) > asi64(R2)) goto L4841;
L4842:
	R1 = 0;
	jumpinto = asi64(R1);
L4841:
L4839:
	asi64(R1) = jumpinto;
	if (!asi64(R1)) goto L4845;
	asi64(R1) = step;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L4847;
	R1 = (u64)&fromval;
	(*toi64p(R1)) += 1;
	goto L4846;
L4847:
	R1 = (u64)&fromval;
	(*toi64p(R1)) -=1;
L4846:
	asi64(R1) = fromval;
	asu64(R2) = pfrom;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L4845:
	asu64(R1) = pfrom;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	asu64(R1) = dvar;
	R2 = 12;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L4836;
L4837:
	R1 = 1;
	asu64(R2) = pfrom;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = dvar;
	R2 = 12;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asu64(R1) = dvar;
	R2 = 71;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asi64(R1) = step;
	asi64(R1) = -asi64(R1);
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 12;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L4836:
	asu64(R1) = pautovar;
	if (!asu64(R1)) goto L4849;
	R1 = 1;
	asu64(R2) = pto;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = pautovar;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	limitvar = asu64(R1);
	asu64(R1) = limitvar;
	R2 = 24;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asu64(R1) = pautovar;
	pto = asu64(R1);
	goto L4848;
L4849:
	asu64(R1) = pto;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	limitvar = asu64(R1);
L4848:
	asi64(R1) = jumpinto;
	if (!asi64(R1)) goto L4851;
	asi64(R1) = lab_c;
	qq_pclgen_genjumpl(asi64(R1));
L4851:
	asi64(R1) = lab_b;
	qq_pcllib_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R2) = pbody;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = lab_c;
	qq_pcllib_definefwdlabel(asi64(R1));
	asi64(R1) = step;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4853;
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L4855;
	R1 = 46;
	asu64(R2) = dvar;
	R3 = 120;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	asi64(R1) += asi64(R2);
	opc = asi64(R1);
	goto L4854;
L4855:
	asu64(R1) = dvar;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = limitvar;
	R3 = 120;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	if (asu64(R1) != asu64(R2)) goto L4856;
	R1 = 48;
	asu64(R2) = dvar;
	R3 = 120;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	asi64(R1) += asi64(R2);
	opc = asi64(R1);
	goto L4854;
L4856:
	R1 = 0;
	R2 = tou64("for:mixed m/f vars");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4854:
	asi64(R1) = qq_decls_qpos;
	oldqpos = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	qq_decls_qpos = asi64(R1);
	asi64(R1) = lab_b;
	asi64(R2) = opc;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	asi64(R1) = oldqpos;
	qq_decls_qpos = asi64(R1);
	asu64(R1) = dvar;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L4858;
	asu64(R1) = pto;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	goto L4857;
L4858:
	asu64(R1) = limitvar;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
L4857:
	goto L4852;
L4853:
	asu64(R1) = dvar;
	R2 = 71;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	R1 = -1;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 12;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = dvar;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L4860;
	asu64(R1) = pto;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	goto L4859;
L4860:
	asu64(R1) = limitvar;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
L4859:
	asi64(R1) = lab_b;
	R2 = 38;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
L4852:
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L4862;
	asi64(R1) = lab_e;
	qq_pcllib_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R2) = pelse;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
L4862:
	asi64(R1) = lab_d;
	qq_pcllib_definefwdlabel(asi64(R1));
	qq_pclgen_unstacklooplabels();
	return;
}

static void qq_pclgen_do_forx(u64 p, u64 pvar, u64 pbody) {
    u64 R1, R2, R3, R4; 
	u64 pbounds;
	u64 pelse;
	u64 plimit;
	u64 pautovar;
	u64 dvar;
	u64 limitvar;
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	i64 lab_e;
	i64 opc;
	msysc_m$print_startcon();
	R1 = tou64("FORX");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = pvar;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pbounds = asu64(R1);
	asu64(R1) = qq_decls_stcurrproc;
	asu64(R1) = qq_lib_createavnamex(asu64(R1));
	pautovar = asu64(R1);
	asu64(R1) = pbody;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pelse = asu64(R1);
	asu64(R1) = pvar;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dvar = asu64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_b = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_d = asi64(R1);
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L4865;
	asi64(R1) = qq_pcllib_createfwdlabel();
	goto L4864;
L4865:
	asi64(R1) = lab_d;
L4864:
	lab_e = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_b;
	qq_pclgen_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = pbounds;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = pautovar;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	limitvar = asu64(R1);
	asu64(R1) = limitvar;
	R2 = 24;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	R1 = 1;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	R1 = 102;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = dvar;
	R2 = 12;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asi64(R1) = lab_c;
	qq_pclgen_genjumpl(asi64(R1));
	asi64(R1) = lab_b;
	qq_pcllib_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R2) = pbody;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = lab_c;
	qq_pcllib_definefwdlabel(asi64(R1));
	asu64(R1) = dvar;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = limitvar;
	R3 = 120;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	if (asu64(R1) != asu64(R2)) goto L4867;
	asi64(R1) = lab_b;
	R2 = 48;
	asu64(R3) = dvar;
	R4 = 120;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 9;
    asi64(R3) = Getdotindex(asu64(R3), asi64(R4));
	asi64(R2) += asi64(R3);
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	goto L4866;
L4867:
	R1 = 0;
	R2 = tou64("forx:mixed m/f");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4866:
	asu64(R1) = dvar;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asu64(R1) = limitvar;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L4869;
	asi64(R1) = lab_e;
	qq_pcllib_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R2) = pelse;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
L4869:
	asi64(R1) = lab_d;
	qq_pcllib_definefwdlabel(asi64(R1));
	qq_pclgen_unstacklooplabels();
	return;
}

static void qq_pclgen_do_print(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 issprint;
	u64 x;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	asi64(R1) &= asi64(R2);
	issprint = asi64(R1);
	asi64(R1) = issprint;
	if (!asi64(R1)) goto L4872;
	R1 = 0;
	R2 = 3;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	goto L4871;
L4872:
	asu64(R1) = a;
	if (!asu64(R1)) goto L4874;
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	goto L4873;
L4874:
	R1 = 0;
	R2 = 2;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
L4873:
L4871:
	asu64(R1) = b;
	x = asu64(R1);
	goto L4876;
L4875:
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L4879;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L4880;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L4881;
	goto L4882;
L4879:
	R1 = 1;
	asu64(R2) = x;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = x;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 7;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	goto L4878;
L4880:
	R1 = 0;
	R2 = 10;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	goto L4878;
L4881:
	R1 = 0;
	R2 = 11;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	goto L4878;
L4882:
	R1 = 1;
	asu64(R2) = x;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 8;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
L4878:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
L4876:
	asu64(R1) = x;
	if (asu64(R1)) goto L4875;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4884;
	R1 = 0;
	R2 = 9;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
L4884:
	asi64(R1) = issprint;
	if (!asi64(R1)) goto L4886;
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
	R1 = 0;
	R2 = 6;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	goto L4885;
L4886:
	R1 = 0;
	R2 = 5;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
L4885:
	return;
}

static void qq_pclgen_do_fprint(u64 p, u64 a, u64 b, u64 c) {
    u64 R1, R2, R3; 
	i64 issfprint;
	u64 x;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	asi64(R1) &= asi64(R2);
	issfprint = asi64(R1);
	asi64(R1) = issfprint;
	if (!asi64(R1)) goto L4889;
	R1 = 0;
	R2 = 3;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	goto L4888;
L4889:
	asu64(R1) = a;
	if (!asu64(R1)) goto L4891;
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	goto L4890;
L4891:
	R1 = 0;
	R2 = 2;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
L4890:
L4888:
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 4;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	asu64(R1) = c;
	x = asu64(R1);
	goto L4893;
L4892:
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L4896;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L4897;
	goto L4898;
L4896:
	R1 = 1;
	asu64(R2) = x;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = x;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 7;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	goto L4895;
L4897:
	R1 = 0;
	R2 = 10;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	goto L4895;
L4898:
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
	R1 = 1;
	asu64(R2) = x;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 7;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
L4895:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
L4893:
	asu64(R1) = x;
	if (asu64(R1)) goto L4892;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4900;
	R1 = 0;
	R2 = 9;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
L4900:
	asi64(R1) = issfprint;
	if (!asi64(R1)) goto L4902;
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
	R1 = 0;
	R2 = 6;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	goto L4901;
L4902:
	R1 = 0;
	R2 = 5;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
L4901:
	return;
}

static void qq_pclgen_do_read(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 x;
	u64 xloop;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4905;
	asu64(R1) = a;
	if (!asu64(R1)) goto L4907;
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 12;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	goto L4906;
L4907:
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
	R1 = 0;
	R2 = 12;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
L4906:
L4905:
	asu64(R1) = b;
	xloop = asu64(R1);
	goto L4909;
L4908:
	asu64(R1) = xloop;
	x = asu64(R1);
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 58;
	if (asi64(R1) != asi64(R2)) goto L4912;
	R1 = 1;
	asu64(R2) = x;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 14;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	asu64(R1) = x;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	goto L4911;
L4912:
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
	R1 = 0;
	R2 = 14;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
L4911:
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L4914;
	asu64(R1) = x;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 12;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L4913;
L4914:
	asu64(R1) = x;
	qq_pclgen_evalref(asu64(R1));
	R1 = 23;
	qq_pcllib_genpc(asi64(R1));
L4913:
	asu64(R1) = xloop;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	xloop = asu64(R1);
L4909:
	asu64(R1) = xloop;
	if (asu64(R1)) goto L4908;
	return;
}

static void qq_pclgen_do_forall(u64 p, u64 pindex, u64 pbody) {
    u64 R1, R2, R3, R4; 
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	i64 lab_e;
	u64 ploopvar;
	u64 plist;
	u64 pelse;
	u64 plimitvar;
	u64 plistvar;
	u64 indexvar;
	u64 limitvar;
	u64 loopvar;
	u64 listvar;
	asu64(R1) = pindex;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	plist = asu64(R1);
	asu64(R1) = plist;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ploopvar = asu64(R1);
	asu64(R1) = ploopvar;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4917;
	asu64(R1) = pindex;
	ploopvar = asu64(R1);
	asu64(R1) = qq_decls_stcurrproc;
	asu64(R1) = qq_lib_createavnamex(asu64(R1));
	pindex = asu64(R1);
L4917:
	asu64(R1) = ploopvar;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	loopvar = asu64(R1);
	asu64(R1) = qq_decls_stcurrproc;
	asu64(R1) = qq_lib_createavnamex(asu64(R1));
	plimitvar = asu64(R1);
	asu64(R1) = plimitvar;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	limitvar = asu64(R1);
	asu64(R1) = pindex;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	indexvar = asu64(R1);
	asu64(R1) = plist;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L4920;
	asu64(R1) = plist;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = loopvar;
	R3 = 120;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	if (asu64(R1) == asu64(R2)) goto L4919;
L4920:
	asu64(R1) = qq_decls_stcurrproc;
	asu64(R1) = qq_lib_createavnamex(asu64(R1));
	plistvar = asu64(R1);
	asu64(R1) = plistvar;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	listvar = asu64(R1);
	R1 = 1;
	asu64(R2) = plist;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = listvar;
	R2 = 24;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L4918;
L4919:
	asu64(R1) = plist;
	plistvar = asu64(R1);
	asu64(R1) = plistvar;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	listvar = asu64(R1);
L4918:
	asu64(R1) = indexvar;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = loopvar;
	R3 = 120;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asu64(R1) != asu64(R2)) goto L4923;
	asu64(R2) = listvar;
	R3 = 120;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	if (asu64(R1) == asu64(R2)) goto L4922;
L4923:
	R1 = 0;
	R2 = tou64("forall: mixed vars");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4922:
	asu64(R1) = pbody;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pelse = asu64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_b = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_d = asi64(R1);
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L4925;
	asi64(R1) = qq_pcllib_createfwdlabel();
	goto L4924;
L4925:
	asi64(R1) = lab_d;
L4924:
	lab_e = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_b;
	qq_pclgen_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = listvar;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	R1 = 2;
	R2 = 90;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
	asu64(R1) = limitvar;
	R2 = 24;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	R1 = 1;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	R1 = 102;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = indexvar;
	R2 = 24;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asi64(R1) = lab_c;
	qq_pclgen_genjumpl(asi64(R1));
	asi64(R1) = lab_b;
	qq_pcllib_definefwdlabel(asi64(R1));
	asu64(R1) = listvar;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = pindex;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L4927;
	R1 = 130;
	goto L4926;
L4927:
	R1 = 136;
L4926:
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = loopvar;
	R2 = 12;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = pbody;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = lab_c;
	qq_pcllib_definefwdlabel(asi64(R1));
	asu64(R1) = indexvar;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = limitvar;
	R3 = 120;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	if (asu64(R1) != asu64(R2)) goto L4929;
	asi64(R1) = lab_b;
	R2 = 48;
	asu64(R3) = indexvar;
	R4 = 120;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 9;
    asi64(R3) = Getdotindex(asu64(R3), asi64(R4));
	asi64(R2) += asi64(R3);
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	goto L4928;
L4929:
	R1 = 0;
	R2 = tou64("forall:mixed m/f");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4928:
	asu64(R1) = indexvar;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asu64(R1) = limitvar;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L4931;
	asi64(R1) = lab_e;
	qq_pcllib_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R2) = pelse;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
L4931:
	asi64(R1) = lab_d;
	qq_pcllib_definefwdlabel(asi64(R1));
	qq_pclgen_unstacklooplabels();
	return;
}

static void qq_pclgen_do_case(u64 p, u64 pindex, u64 pwhenthen, i64 res) {
    u64 R1, R2, R3, R4; 
	i64 lab_a;
	i64 lab_d;
	i64 loopsw;
	i64 labnextwhen;
	i64 labstmtstart;
	i64 fmult;
	u64 w;
	u64 wt;
	u64 pelse;
	asu64(R1) = pindex;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4934;
	asi64(R1) = res;
	asu64(R2) = pwhenthen;
	asu64(R3) = pindex;
	asu64(R4) = p;
	qq_pclgen_do_case_nc(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L4932;
L4934:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L4935;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L4936;
L4935:
	R1 = 1;
	goto L4937;
L4936:
	R1 = 0;
L4937:
	loopsw = asi64(R1);
	asu64(R1) = pindex;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pelse = asu64(R1);
	asi64(R1) = loopsw;
	if (!asi64(R1)) goto L4939;
	asi64(R1) = qq_pcllib_definelabel();
	lab_a = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_a;
	asi64(R3) = lab_a;
	qq_pclgen_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	goto L4938;
L4939:
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_d = asi64(R1);
L4938:
	R1 = 1;
	asu64(R2) = pindex;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = pwhenthen;
	wt = asu64(R1);
	goto L4941;
L4940:
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = asu64(R1)  !=  asu64(R2);
	fmult = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	labnextwhen = asi64(R1);
	asi64(R1) = fmult;
	if (!asi64(R1)) goto L4944;
	asi64(R1) = qq_pcllib_createfwdlabel();
	labstmtstart = asi64(R1);
L4944:
	goto L4946;
L4945:
	R1 = 1;
	asu64(R2) = w;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	asu64(R1) = w;
	if (!asu64(R1)) goto L4949;
	asi64(R1) = labstmtstart;
	R2 = 40;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	goto L4948;
L4949:
	asi64(R1) = labnextwhen;
	R2 = 41;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
L4948:
L4946:
	asu64(R1) = w;
	if (asu64(R1)) goto L4945;
	asi64(R1) = fmult;
	if (!asi64(R1)) goto L4951;
	asi64(R1) = labstmtstart;
	qq_pcllib_definefwdlabel(asi64(R1));
L4951:
	asi64(R1) = res;
	asu64(R2) = wt;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = loopsw;
	if (asi64(R1)) goto L4953;
	asi64(R1) = lab_d;
	qq_pclgen_genjumpl(asi64(R1));
	goto L4952;
L4953:
	asi64(R1) = lab_a;
	qq_pclgen_genjumpl(asi64(R1));
L4952:
	asi64(R1) = labnextwhen;
	qq_pcllib_definefwdlabel(asi64(R1));
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L4941:
	asu64(R1) = wt;
	if (asu64(R1)) goto L4940;
	R1 = 1;
	R2 = 58;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L4955;
	asi64(R1) = res;
	asu64(R2) = pelse;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L4954;
L4955:
	asi64(R1) = res;
	if (!asi64(R1)) goto L4956;
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
L4956:
L4954:
	asi64(R1) = loopsw;
	if (!asi64(R1)) goto L4958;
	asi64(R1) = lab_a;
	qq_pclgen_genjumpl(asi64(R1));
	asi64(R1) = lab_d;
	qq_pcllib_definefwdlabel(asi64(R1));
	qq_pclgen_unstacklooplabels();
	goto L4957;
L4958:
	asi64(R1) = lab_d;
	qq_pcllib_definefwdlabel(asi64(R1));
L4957:
L4932:
	return;
}

static void qq_pclgen_do_case_nc(u64 p, u64 pindex, u64 pwhenthen, i64 res) {
    u64 R1, R2, R3; 
	i64 lab_a;
	i64 lab_d;
	i64 labnextwhen;
	i64 labstmtstart;
	i64 fmult;
	u64 w;
	u64 wt;
	u64 pelse;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4961;
	R1 = 0;
	R2 = tou64("case-nc");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4961:
	asu64(R1) = pindex;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pelse = asu64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_d = asi64(R1);
	asu64(R1) = pwhenthen;
	wt = asu64(R1);
	goto L4963;
L4962:
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = asu64(R1)  !=  asu64(R2);
	fmult = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	labnextwhen = asi64(R1);
	asi64(R1) = fmult;
	if (!asi64(R1)) goto L4966;
	asi64(R1) = qq_pcllib_createfwdlabel();
	labstmtstart = asi64(R1);
L4966:
	goto L4968;
L4967:
	R1 = 1;
	asu64(R2) = w;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	asu64(R1) = w;
	if (!asu64(R1)) goto L4971;
	asi64(R1) = labstmtstart;
	R2 = 32;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	goto L4970;
L4971:
	asi64(R1) = labnextwhen;
	R2 = 33;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
L4970:
L4968:
	asu64(R1) = w;
	if (asu64(R1)) goto L4967;
	asi64(R1) = fmult;
	if (!asi64(R1)) goto L4973;
	asi64(R1) = labstmtstart;
	qq_pcllib_definefwdlabel(asi64(R1));
L4973:
	asi64(R1) = res;
	asu64(R2) = wt;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = lab_d;
	qq_pclgen_genjumpl(asi64(R1));
	asi64(R1) = labnextwhen;
	qq_pcllib_definefwdlabel(asi64(R1));
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L4963:
	asu64(R1) = wt;
	if (asu64(R1)) goto L4962;
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L4975;
	asi64(R1) = res;
	asu64(R2) = pelse;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L4974;
L4975:
	asi64(R1) = res;
	if (!asi64(R1)) goto L4976;
	R1 = 0;
	R2 = tou64("Needs Else branch");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4976:
L4974:
	asi64(R1) = lab_d;
	qq_pcllib_definefwdlabel(asi64(R1));
	return;
}

static void qq_pclgen_do_try(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 labend;
	i64 labx;
	u64 ptry;
	u64 x;
	u64 pexcept;
	u64 pexcode;
	R1 = (u64)&qq_pclgen_trylevel;
	(*toi64p(R1)) += 1;
	asi64(R1) = qq_pcllib_createfwdlabel();
	labend = asi64(R1);
	asu64(R1) = a;
	ptry = asu64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	labx = asi64(R1);
	asu64(R1) = b;
	pexcept = asu64(R1);
	asu64(R1) = pexcept;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4979;
	R1 = 0;
	R2 = tou64("try: no except");
	qq_lib_gerror(asu64(R2), asu64(R1));
	goto L4978;
L4979:
	asu64(R1) = pexcept;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4980;
	R1 = 0;
	R2 = tou64("Try:multiple except block not implemented");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4980:
L4978:
	goto L4982;
L4981:
	asu64(R1) = pexcept;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pexcode = asu64(R1);
	asu64(R1) = pexcode;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L4986;
	asu64(R1) = pexcode;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4985;
L4986:
	R1 = 0;
	R2 = tou64("Try:multiple except codes not implemented");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4985:
	asi64(R1) = labx;
	R2 = 140;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = pexcode;
	asi64(R2) = qq_pclgen_getconstvalue(asu64(R2));
	qq_pcllib_genxy(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = ptry;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = labend;
	qq_pclgen_genjumpl(asi64(R1));
	asi64(R1) = labx;
	qq_pcllib_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R2) = pexcept;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = labend;
	qq_pcllib_definefwdlabel(asi64(R1));
	asu64(R1) = pexcept;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pexcept = asu64(R1);
L4982:
	asu64(R1) = pexcept;
	if (asu64(R1)) goto L4981;
	R1 = 1;
	R2 = 59;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
	R1 = (u64)&qq_pclgen_trylevel;
	(*toi64p(R1)) -=1;
	return;
}

static i64 qq_pclgen_unitstoarray(u64 p, u64 plist, i64 maxunits) {
    u64 R1, R2, R3; 
	i64 n;
	R1 = 0;
	n = asi64(R1);
	goto L4989;
L4988:
	asi64(R1) = n;
	asi64(R2) = maxunits;
	if (asi64(R1) < asi64(R2)) goto L4992;
	R1 = 0;
	R2 = tou64("UTA Too many units");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4992:
	asu64(R1) = p;
	asu64(R2) = plist;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L4989:
	asu64(R1) = p;
	if (asu64(R1)) goto L4988;
	asi64(R1) = n;
	goto L4987;
L4987:
	return asi64(R1);
}

static void qq_pclgen_do_select(u64 pindex, u64 pplist, i64 res) {
    u64 R1, R2, R3; 
	i64 n;
	i64 labend;
	i64 i;
	i64 lab;
	i64 elselab;
	u64 x;
	u64 pelse;
	struct $B4 plist;
	struct $B75 labels;
	asu64(R1) = pindex;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pelse = asu64(R1);
	R1 = 512;
	R2 = (u64)&plist;
	asu64(R3) = pplist;
	asi64(R1) = qq_pclgen_unitstoarray(asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 512;
	if (asi64(R1) <= asi64(R2)) goto L4995;
	R1 = 0;
	R2 = tou64("Selectx too complex");
	qq_lib_gerror(asu64(R2), asu64(R1));
L4995:
	asi64(R1) = qq_pcllib_createfwdlabel();
	labend = asi64(R1);
	R1 = 1;
	asu64(R2) = pindex;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = n;
	R2 = 1;
	R3 = 43;
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4998;
L4996:
	R1 = 0;
	R2 = 42;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	asu64(R1) = qq_pcllib_pccurr;
	R2 = (u64)&labels;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L4996;
L4998:
	R1 = 0;
	R2 = 42;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	asu64(R1) = qq_pcllib_pccurr;
	R2 = (u64)&labels;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5001;
L4999:
	R1 = (u64)&plist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	x = asu64(R1);
	asi64(R1) = qq_pcllib_definelabel();
	lab = asi64(R1);
	asi64(R1) = lab;
	R2 = (u64)&labels;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = res;
	asu64(R2) = x;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = labend;
	qq_pclgen_genjumpl(asi64(R1));
	i += 1; if (i <= n) goto L4999;
L5001:
	asi64(R1) = qq_pcllib_definelabel();
	elselab = asi64(R1);
	asi64(R1) = elselab;
	R2 = (u64)&labels;
	asi64(R3) = n;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L5003;
	asi64(R1) = res;
	asu64(R2) = pelse;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L5002;
L5003:
	asi64(R1) = res;
	if (!asi64(R1)) goto L5004;
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
L5004:
L5002:
	R1 = 0;
	qq_pcllib_genpc(asi64(R1));
	asi64(R1) = labend;
	qq_pcllib_definefwdlabel(asi64(R1));
	return;
}

static void qq_pclgen_do_andl(u64 x, u64 y) {
    u64 R1, R2, R3; 
	i64 a;
	i64 b;
	asi64(R1) = qq_pcllib_createfwdlabel();
	a = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	b = asi64(R1);
	asi64(R1) = a;
	asu64(R2) = x;
	R3 = 33;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = a;
	asu64(R2) = y;
	R3 = 33;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	R1 = 1;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	asi64(R1) = b;
	qq_pclgen_genjumpl(asi64(R1));
	asi64(R1) = a;
	qq_pcllib_definefwdlabel(asi64(R1));
	R1 = 0;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	R1 = 0;
	qq_pcllib_genpc(asi64(R1));
	asi64(R1) = b;
	qq_pcllib_definefwdlabel(asi64(R1));
	return;
}

static void qq_pclgen_do_orl(u64 x, u64 y) {
    u64 R1, R2, R3; 
	i64 a;
	i64 b;
	asi64(R1) = qq_pcllib_createfwdlabel();
	a = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	b = asi64(R1);
	asi64(R1) = a;
	asu64(R2) = x;
	R3 = 32;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = a;
	asu64(R2) = y;
	R3 = 32;
	qq_pclgen_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	asi64(R1) = b;
	qq_pclgen_genjumpl(asi64(R1));
	asi64(R1) = a;
	qq_pcllib_definefwdlabel(asi64(R1));
	R1 = 1;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	R1 = 0;
	qq_pcllib_genpc(asi64(R1));
	asi64(R1) = b;
	qq_pcllib_definefwdlabel(asi64(R1));
	return;
}

static void qq_pclgen_do_incr(u64 p, u64 a, i64 res) {
    u64 R1, R2, R3; 
	u64 d;
	i64 opc;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 60;
	if (asi64(R1) != asi64(R2)) goto L5009;
	R1 = 74;
	goto L5008;
L5009:
	R1 = 73;
L5008:
	opc = asi64(R1);
	asi64(R1) = res;
	if (!asi64(R1)) goto L5011;
	asi64(R1) = opc;
	asu64(R2) = a;
	qq_pclgen_do_unaryref(asu64(R2), asi64(R1));
	goto L5010;
L5011:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L5012;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L5014;
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5014;
	R1 = 70;
	asu64(R2) = a;
	qq_pclgen_do_unaryref(asu64(R2), asi64(R1));
	goto L5013;
L5014:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 71;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
L5013:
	goto L5010;
L5012:
	R1 = 70;
	asu64(R2) = a;
	qq_pclgen_do_unaryref(asu64(R2), asi64(R1));
L5010:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5016;
	R1 = -1;
	goto L5015;
L5016:
	R1 = 1;
L5015:
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 12;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	return;
}

static void qq_pclgen_do_callhost(u64 p, u64 a, i64 res) {
    u64 R1, R2, R3; 
	i64 index;
	i64 isfunc;
	i64 nargs;
	i64 nparams;
	i64 fparams;
	struct $B1 plist;
	u64 q;
	i64 av_1;
	i64 i;
	asu64(R1) = p;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	index = asi64(R1);
	R1 = (u64)&qq_tables_hostisfn;
	asi64(R2) = index;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	isfunc = asi64(R1);
	asi64(R1) = res;
	if (!asi64(R1)) goto L5019;
	asi64(R1) = isfunc;
	if (asi64(R1)) goto L5019;
	R1 = 0;
	R2 = tou64("Host proc not a function");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5019:
	asi64(R1) = isfunc;
	if (!asi64(R1)) goto L5021;
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
L5021:
	R1 = 0;
	nargs = asi64(R1);
	asu64(R1) = a;
	q = asu64(R1);
	goto L5023;
L5022:
	asi64(R1) = nargs;
	R2 = 10;
	if (asi64(R1) <= asi64(R2)) goto L5026;
	R1 = 0;
	R2 = tou64("Too many host args");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5026:
	asu64(R1) = q;
	R2 = (u64)&plist;
	R3 = (u64)&nargs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5023:
	asu64(R1) = q;
	if (asu64(R1)) goto L5022;
	asi64(R1) = nargs;
	nparams = asi64(R1);
	asi64(R1) = nparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5028;
	R1 = (u64)&qq_tables_hostlvset;
	asi64(R2) = index;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5028;
	R1 = 0;
	R2 = tou64("LV hostfn: needs 1+ params");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5028:
	R1 = (u64)&qq_tables_hostnparams;
	asi64(R2) = index;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	fparams = asi64(R1);
	asi64(R1) = nparams;
	asi64(R2) = fparams;
	if (asi64(R1) <= asi64(R2)) goto L5030;
	R1 = 0;
	R2 = tou64("Hostfn too many params");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5030:
	asi64(R1) = fparams;
	asi64(R2) = nparams;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5033;
L5031:
	R1 = 15;
	qq_pcllib_genpc(asi64(R1));
	if (--asi64(av_1)) goto L5031;
L5033:
	asi64(R1) = nparams;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5036;
L5034:
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5038;
	R1 = (u64)&qq_tables_hostlvset;
	asi64(R2) = index;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5038;
	R1 = (u64)&plist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	qq_pclgen_evalref(asu64(R1));
	goto L5037;
L5038:
	R1 = 1;
	R2 = (u64)&plist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
L5037:
	i += -1; if (i >= 1) goto L5034;
L5036:
	asi64(R1) = res;
	asi64(R2) = index;
	qq_pclgen_callhostfn(asi64(R2), asi64(R1));
	return;
}

static void qq_pclgen_callhostfn(i64 fnindex, i64 calledasfn) {
    u64 R1, R2; 
	asi64(R1) = fnindex;
	R2 = 57;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	return;
}

static void qq_pclgen_genfree(i64 n) {
    u64 R1, R2; 
	asi64(R1) = n;
	R2 = 58;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
	return;
}

static void qq_pclgen_do_return(u64 p, u64 a, i64 res) {
    u64 R1, R2; 
	asu64(R1) = a;
	if (!asu64(R1)) goto L5043;
	asu64(R1) = qq_decls_stcurrproc;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 4;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L5045;
	R1 = 0;
	R2 = tou64("Proc can't return a value");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5045:
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L5042;
L5043:
	asu64(R1) = qq_decls_stcurrproc;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 4;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5047;
	R1 = 0;
	R2 = tou64("Func needs return value");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5047:
L5042:
	asi64(R1) = res;
	if (asi64(R1)) goto L5049;
	asi64(R1) = qq_pclgen_retindex;
	qq_pclgen_genjumpl(asi64(R1));
L5049:
	return;
}

static void qq_pclgen_do_multassign(u64 a, u64 b, i64 deepcopy, i64 res) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	struct $B28 plist;
	i64 n;
	i64 i;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	goto L5052;
L5051:
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5055;
	R1 = 0;
	R2 = tou64("Too few RHS elems");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5055:
	R1 = 1;
	asu64(R2) = q;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = n;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L5057;
	R1 = 0;
	R2 = tou64("Too many elems");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5057:
	asu64(R1) = p;
	R2 = (u64)&plist;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5052:
	asu64(R1) = p;
	if (asu64(R1)) goto L5051;
	asu64(R1) = q;
	if (!asu64(R1)) goto L5059;
	R1 = 0;
	R2 = tou64("Too few LHS elems");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5059:
	asi64(R1) = n;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5062;
L5060:
	asi64(R1) = deepcopy;
	if (!asi64(R1)) goto L5064;
	R1 = 27;
	qq_pcllib_genpc(asi64(R1));
L5064:
	R1 = 0;
	R2 = (u64)&plist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_do_store(asu64(R2), asi64(R1));
	i += -1; if (i >= 1) goto L5060;
L5062:
	return;
}

static void qq_pclgen_do_store(u64 a, i64 res) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 p;
	struct $B28 plist;
	i64 n;
	i64 i;
	asi64(R1) = res;
	if (!asi64(R1)) goto L5067;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L5067;
	R1 = 26;
	qq_pcllib_genpc(asi64(R1));
L5067:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L5069;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L5070;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L5071;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L5072;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L5073;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L5074;
	R2 = 88;
	if (asi64(R1) == asi64(R2)) goto L5075;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5076;
	goto L5077;
L5069:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L5079;
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5079;
	asi64(R1) = res;
	if (!asi64(R1)) goto L5081;
	R1 = 26;
	qq_pcllib_genpc(asi64(R1));
L5081:
	asu64(R1) = d;
	R2 = 7;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	R1 = 23;
	qq_pcllib_genpc(asi64(R1));
	goto L5078;
L5079:
	asi64(R1) = res;
	if (!asi64(R1)) goto L5082;
	R1 = 26;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = d;
	R2 = 12;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L5078;
L5082:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5084;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L5083;
L5084:
	R1 = 0;
	R2 = tou64("Not lvalue");
	qq_lib_gerror(asu64(R2), asu64(R1));
	goto L5078;
L5083:
	asu64(R1) = d;
	R2 = 12;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
L5078:
	goto L5068;
L5070:
	R1 = 1;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 128;
	qq_pcllib_genpc_name(asi64(R2), asu64(R1));
	goto L5068;
L5071:
	R1 = 131;
	asu64(R2) = a;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = a;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_pclgen_do_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L5068;
L5072:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_pclgen_evalref(asu64(R1));
	R1 = 1;
	asu64(R2) = a;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 137;
	qq_pcllib_genpc(asi64(R1));
	goto L5068;
L5073:
	R1 = 1;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 23;
	qq_pcllib_genpc(asi64(R1));
	goto L5068;
L5074:
	R1 = 134;
	asu64(R2) = a;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = a;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_pclgen_do_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L5068;
L5075:
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L5086;
L5085:
	asi64(R1) = n;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L5089;
	R1 = 0;
	R2 = tou64("Too many elems");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5089:
	asu64(R1) = p;
	R2 = (u64)&plist;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L5086:
	asu64(R1) = p;
	if (asu64(R1)) goto L5085;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5091;
	R1 = 0;
	R2 = tou64("Empty lhs list");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5091:
	asi64(R1) = n;
	R2 = 139;
	qq_pcllib_genpc_n(asi64(R2), asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5094;
L5092:
	R1 = 0;
	R2 = (u64)&plist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_do_store(asu64(R2), asi64(R1));
	i += 1; if (i <= n) goto L5092;
L5094:
	goto L5068;
L5076:
	asu64(R1) = a;
	qq_pclgen_evalref(asu64(R1));
	R1 = 23;
	qq_pcllib_genpc(asi64(R1));
	goto L5068;
L5077:
	asu64(R1) = a;
	R2 = (u64)&qq_tables_jtagnames;
	asu64(R3) = a;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("Can't store to this unit yet:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L5068:
	return;
}

static i64 qq_pclgen_getconstvalue(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	if (!asu64(R1)) goto L5097;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L5097;
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L5095;
L5097:
	R1 = 0;
	R2 = tou64("gcv Not const");
	qq_lib_gerror(asu64(R2), asu64(R1));
	R1 = 0;
	goto L5095;
L5095:
	return asi64(R1);
}

static void qq_pclgen_do_convert(u64 pconv) {
    u64 R1, R2, R3, R4; 
	i64 n;
	i64 elemmode;
	i64 i;
	i64 lowerx;
	i64 lbound;
	i64 m;
	i64 mbase;
	i64 nfields;
	struct $B76 plist;
	u64 p;
	i64 av_1;
	asu64(R1) = pconv;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
	asu64(R1) = pconv;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	mbase = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 88;
	if (asi64(R1) != asi64(R2)) goto L5101;
	asi64(R1) = mbase;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L5100;
L5101:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 88;
	if (asi64(R1) != asi64(R2)) goto L5103;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	qq_lib_deleteunit(asu64(R2), asu64(R1));
L5103:
	R1 = 1;
	asu64(R2) = p;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = m;
	R2 = 99;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	goto L5098;
L5100:
	R1 = 400;
	R2 = (u64)&plist;
	asu64(R3) = p;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R1) = qq_pclgen_unitstoarray(asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L5105;
	R1 = (u64)&plist;
	R2 = 1;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L5105;
	asi64(R1) = mbase;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5107;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5107;
	goto L5108;
L5107:
	R1 = (u64)&plist;
	asi64(R2) = n;
	asi64(R3) = m;
	qq_pclgen_do_makerecordkv(asi64(R3), asi64(R2), asu64(R1));
	goto L5106;
L5108:
	R1 = 0;
	R2 = tou64("key:value not allowed");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5106:
	goto L5098;
L5105:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5111;
L5109:
	R1 = 1;
	R2 = (u64)&plist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	i += 1; if (i <= n) goto L5109;
L5111:
	asi64(R1) = mbase;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5113;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5113;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5114;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5115;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5116;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5117;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5118;
	goto L5119;
L5113:
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	nfields = asi64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L5121;
	asu64(R1) = p;
	asi64(R2) = nfields;
	asi64(R3) = n;
	qq_pclgen_checkelems(asi64(R3), asi64(R2), asu64(R1));
	goto L5120;
L5121:
	asi64(R1) = nfields;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5124;
L5122:
	R1 = 0;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	if (--asi64(av_1)) goto L5122;
L5124:
	asi64(R1) = nfields;
	n = asi64(R1);
L5120:
	R1 = 0;
	asi64(R2) = n;
	asi64(R3) = mbase;
	R4 = 12;
	if (asi64(R3) != asi64(R4)) goto L5126;
	R3 = 62;
	goto L5125;
L5126:
	R3 = 65;
L5125:
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = m;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5112;
L5114:
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	lowerx = asi64(R1);
	asi64(R1) = lowerx;
	asi64(R2) = n;
	R3 = 61;
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	goto L5112;
L5115:
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = n;
	R3 = 63;
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	R1 = 11;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5112;
L5116:
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemmode = asi64(R1);
	R1 = (u64)&qq_tables_ttlower;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	lowerx = asi64(R1);
	asu64(R1) = p;
	R2 = (u64)&qq_tables_ttlength;
	asi64(R3) = m;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R3) = n;
	qq_pclgen_checkelems(asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = lowerx;
	asi64(R2) = n;
	R3 = 63;
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = m;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = elemmode;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5112;
L5117:
	asi64(R1) = m;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L5128;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = n;
	R3 = 64;
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	R1 = 8;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5130;
	R1 = 33;
	goto L5129;
L5130:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
L5129:
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5127;
L5128:
	R1 = 0;
	R2 = tou64("user-define bit array not ready");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5127:
	goto L5112;
L5118:
	R1 = 0;
	asi64(R2) = n;
	R3 = 66;
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	goto L5112;
L5119:
	R1 = 0;
	R2 = 0;
	asi64(R3) = mbase;
	asu64(R2) = qq_show_strmode(asi64(R3), asi64(R2));
	R3 = tou64("Convert list");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L5112:
L5098:
	return;
}

static void qq_pclgen_checkelems(i64 n, i64 length, u64 p) {
    u64 R1, R2; 
	asi64(R1) = n;
	asi64(R2) = length;
	if (asi64(R1) >= asi64(R2)) goto L5133;
	R1 = 0;
	R2 = tou64("Too few elements");
	qq_lib_gerror(asu64(R2), asu64(R1));
	goto L5132;
L5133:
	asi64(R1) = n;
	asi64(R2) = length;
	if (asi64(R1) <= asi64(R2)) goto L5134;
	R1 = 0;
	R2 = tou64("Too many elements");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5134:
L5132:
	return;
}

static void qq_pclgen_do_switch(u64 p, u64 pindex, u64 pwhenthen, i64 res) {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	i64 minlab;
	i64 maxlab;
	i64 x;
	i64 y;
	i64 i;
	i64 n;
	u64 w;
	u64 wt;
	u64 pelse;
	asu64(R1) = pindex;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pelse = asu64(R1);
	R1 = 1000000;
	minlab = asi64(R1);
	R1 = -1000000;
	maxlab = asi64(R1);
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = pwhenthen;
	wt = asu64(R1);
	goto L5137;
L5136:
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	goto L5140;
L5139:
	asu64(R1) = w;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L5143;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L5144;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L5145;
	goto L5146;
L5143:
	asu64(R1) = w;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = qq_pclgen_getconstvalue(asu64(R1));
	x = asi64(R1);
	asu64(R1) = w;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = qq_pclgen_getconstvalue(asu64(R1));
	y = asi64(R1);
// qq_pclgen.do_switch.dorange:
L5147:
	asi64(R1) = x;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = y;
	if (asi64(R1) > asi64(R2)) goto L5150;
L5148:
	asi64(R1) = minlab;
	asi64(R2) = i;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	minlab = asi64(R1);
	asi64(R1) = maxlab;
	asi64(R2) = i;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	maxlab = asi64(R1);
	i += 1; if (i <= y) goto L5148;
L5150:
	goto L5142;
L5144:
	asu64(R1) = w;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	y = asi64(R2);
	x = asi64(R1);
	goto L5147;
	goto L5142;
L5145:
	asu64(R1) = w;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = R1;
	y = asi64(R2);
	x = asi64(R1);
	goto L5147;
	goto L5142;
L5146:
	R1 = 0;
	asu64(R2) = w;
	asu64(R2) = qq_lib_strexpr(asu64(R2));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Switch when2: not const");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L5142:
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
L5140:
	asu64(R1) = w;
	if (asu64(R1)) goto L5139;
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L5137:
	asu64(R1) = wt;
	if (asu64(R1)) goto L5136;
	asi64(R1) = maxlab;
	asi64(R2) = minlab;
	asi64(R1) -= asi64(R2);
	R2 = 512;
	if (asi64(R1) > asi64(R2)) goto L5152;
	asi64(R1) = res;
	asi64(R2) = maxlab;
	asi64(R3) = minlab;
	asu64(R4) = pelse;
	asu64(R5) = pwhenthen;
	asu64(R6) = pindex;
	asu64(R7) = p;
	qq_pclgen_do_simpleswitch(asu64(R7), asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L5135;
L5152:
	R1 = 0;
	R2 = tou64("COMPLEX SWITCH/NOT COMPLETE");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5135:
	return;
}

static void qq_pclgen_do_simpleswitch(u64 p, u64 pindex, u64 pwhenthen, u64 pelse, i64 a, i64 b, i64 res) {
    u64 R1, R2, R3; 
	u64 w;
	u64 wt;
	u64 q;
	i64 loopsw;
	i64 n;
	i64 offset;
	i64 x;
	i64 y;
	i64 x0;
	i64 i;
	i64 labstmt;
	i64 elselab;
	struct $B75 labels;
	i64 lab_a;
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	loopsw = asi64(R1);
	asi64(R1) = b;
	asi64(R2) = a;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = a;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	offset = asi64(R1);
	asi64(R1) = loopsw;
	if (!asi64(R1)) goto L5155;
	asi64(R1) = qq_pcllib_definelabel();
	lab_a = asi64(R1);
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_a;
	asi64(R3) = lab_a;
	qq_pclgen_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	goto L5154;
L5155:
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab_d = asi64(R1);
L5154:
	asi64(R1) = qq_pcllib_createfwdlabel();
	elselab = asi64(R1);
	R1 = 1;
	asu64(R2) = pindex;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = b;
	asi64(R2) = a;
	R3 = 43;
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5158;
L5156:
	R1 = 0;
	R2 = 42;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	asu64(R1) = qq_pcllib_pccurr;
	R2 = (u64)&labels;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L5156;
L5158:
	R1 = 0;
	R2 = 42;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	asu64(R1) = qq_pcllib_pccurr;
	R2 = (u64)&labels;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = pwhenthen;
	wt = asu64(R1);
	goto L5160;
L5159:
	asi64(R1) = qq_pcllib_definelabel();
	labstmt = asi64(R1);
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	goto L5163;
L5162:
	asu64(R1) = w;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L5166;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L5167;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L5168;
	goto L5169;
L5166:
	asu64(R1) = w;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = qq_pclgen_getconstvalue(asu64(R1));
	x0 = asi64(R1);
	asu64(R1) = w;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = qq_pclgen_getconstvalue(asu64(R1));
	y = asi64(R1);
	goto L5165;
L5167:
	asu64(R1) = w;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	y = asi64(R2);
	x0 = asi64(R1);
	goto L5165;
L5168:
	asu64(R1) = w;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = R1;
	y = asi64(R2);
	x0 = asi64(R1);
	goto L5165;
L5169:
L5165:
	asi64(R1) = x0;
	x = asi64(R1);
	asi64(R1) = x;
	asi64(R2) = y;
	if (asi64(R1) > asi64(R2)) goto L5172;
L5170:
	asi64(R1) = x;
	asi64(R2) = offset;
	asi64(R1) -= asi64(R2);
	i = asi64(R1);
	R1 = (u64)&labels;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L5174;
	msysc_m$print_startcon();
	asi64(R1) = x;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = 0;
	asi64(R2) = x;
	asu64(R2) = tou64(tou8(R2));
	msysc_m$print_c8(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Dupl switch value");
	qq_lib_gerror(asu64(R2), asu64(R1));
L5174:
	asi64(R1) = labstmt;
	R2 = (u64)&labels;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	x += 1; if (x <= y) goto L5170;
L5172:
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
L5163:
	asu64(R1) = w;
	if (asu64(R1)) goto L5162;
	asi64(R1) = res;
	asu64(R2) = wt;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asi64(R1) = loopsw;
	if (asi64(R1)) goto L5176;
	asi64(R1) = lab_d;
	qq_pclgen_genjumpl(asi64(R1));
	goto L5175;
L5176:
	asi64(R1) = lab_a;
	qq_pclgen_genjumpl(asi64(R1));
L5175:
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L5160:
	asu64(R1) = wt;
	if (asu64(R1)) goto L5159;
	asi64(R1) = elselab;
	qq_pcllib_definefwdlabel(asi64(R1));
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L5178;
	asi64(R1) = res;
	asu64(R2) = pelse;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
L5178:
	asi64(R1) = loopsw;
	if (!asi64(R1)) goto L5180;
	asi64(R1) = lab_a;
	qq_pclgen_genjumpl(asi64(R1));
	asi64(R1) = lab_d;
	qq_pcllib_definefwdlabel(asi64(R1));
	qq_pclgen_unstacklooplabels();
	goto L5179;
L5180:
	asi64(R1) = lab_d;
	qq_pcllib_definefwdlabel(asi64(R1));
L5179:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5183;
L5181:
	R1 = (u64)&labels;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5185;
	asi64(R1) = elselab;
	R2 = (u64)&labels;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L5185:
	i += 1; if (i <= n) goto L5181;
L5183:
	asi64(R1) = elselab;
	R2 = (u64)&labels;
	asi64(R3) = n;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_pclgen_do_makerecordkv(i64 m, i64 nkeyvals, u64 kvlist) {
    u64 R1, R2, R3; 
	u64 p;
	struct $B76 plist;
	i64 nfields;
	i64 index;
	u64 d;
	u64 e;
	u64 f;
	u64 k;
	i64 i;
	R1 = (u64)&qq_tables_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	nfields = asi64(R1);
	goto L5190;
L5187:
	asu64(R1) = e;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5193;
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L5192;
L5193:
	asu64(R1) = e;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5192;
	R1 = (u64)&nfields;
	(*toi64p(R1)) += 1;
	R1 = 0;
	R2 = (u64)&plist;
	asi64(R3) = nfields;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L5192:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L5190:
	asu64(R1) = e;
	if (asu64(R1)) goto L5187;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nkeyvals;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5196;
L5194:
	asu64(R1) = kvlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	k = asu64(R1);
	asu64(R1) = kvlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	f = asu64(R1);
	goto L5200;
L5197:
	asu64(R1) = e;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5203;
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L5202;
L5203:
	asu64(R1) = e;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = k;
	if (asu64(R1) != asu64(R2)) goto L5202;
	asu64(R1) = e;
	f = asu64(R1);
	goto L5199;
L5202:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L5200:
	asu64(R1) = e;
	if (asu64(R1)) goto L5197;
L5199:
	asu64(R1) = f;
	if (asu64(R1)) goto L5205;
	R1 = 0;
	asu64(R2) = k;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Can't find field:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L5205:
	asu64(R1) = f;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	index = asi64(R1);
	R1 = (u64)&plist;
	asi64(R2) = index;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	if (!asu64(R1)) goto L5207;
	R1 = 0;
	asu64(R2) = k;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Dupl key:");
	qq_lib_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L5207:
	asu64(R1) = p;
	R2 = (u64)&plist;
	asi64(R3) = index;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= nkeyvals) goto L5194;
L5196:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nfields;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5210;
L5208:
	R1 = (u64)&plist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	if (!asu64(R1)) goto L5212;
	R1 = 1;
	R2 = (u64)&plist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	goto L5211;
L5212:
	R1 = 0;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
L5211:
	i += 1; if (i <= nfields) goto L5208;
L5210:
	R1 = 0;
	asi64(R2) = nfields;
	R3 = 62;
	qq_pcllib_genpc_xy(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = m;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void qq_pclgen_do_idiv(u64 a, u64 b) {
    u64 R1, R2; 
	i64 n;
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L5215;
	asu64(R1) = b;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = qq_lib_ispoweroftwo(asi64(R1));
	R2 = R1;
	n = asi64(R2);
	if (!asi64(R1)) goto L5215;
	asi64(R1) = n;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	R1 = 112;
	qq_pcllib_genpc(asi64(R1));
	goto L5214;
L5215:
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 105;
	qq_pcllib_genpc(asi64(R1));
L5214:
	return;
}

static void qq_pclgen_do_irem(u64 a, u64 b) {
    u64 R1, R2; 
	i64 n;
	u64 m;
	R1 = 1;
	asu64(R2) = a;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L5218;
	asu64(R1) = b;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = qq_lib_ispoweroftwo(asi64(R1));
	R2 = R1;
	n = asi64(R2);
	if (!asi64(R1)) goto L5218;
	R1 = -1;
	asi64(R2) = n;
	asu64(R1) <<= asu64(R2);
	asu64(R1) = ~asu64(R1);
	m = asu64(R1);
	asu64(R1) = m;
	R2 = 14;
	qq_pcllib_genpc_int(asi64(R2), asi64(R1));
	R1 = 108;
	qq_pcllib_genpc(asi64(R1));
	goto L5217;
L5218:
	R1 = 1;
	asu64(R2) = b;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 106;
	qq_pcllib_genpc(asi64(R1));
L5217:
	return;
}

static void qq_pclgen_do_map(u64 p, u64 popcode, u64 x) {
    u64 R1, R2, R3; 
	i64 lab;
	R1 = 1;
	asu64(R2) = x;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5221;
	R1 = 1;
	asu64(R2) = x;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
L5221:
	R1 = 1;
	asu64(R2) = popcode;
	qq_pclgen_evalunit(asu64(R2), asi64(R1));
	R1 = 142;
	qq_pcllib_genpc(asi64(R1));
	asi64(R1) = qq_pcllib_createfwdlabel();
	lab = asi64(R1);
	asi64(R1) = lab;
	R2 = 30;
	qq_pcllib_genpc_lab(asi64(R2), asi64(R1));
	R1 = 0;
	qq_pcllib_genpc(asi64(R1));
	asi64(R1) = lab;
	qq_pcllib_definefwdlabel(asi64(R1));
	return;
}

static void qq_pclgen_pushstring(u64 s) {
    u64 R1; 
	R1 = 18;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = s;
	qq_pcllib_genopnd_strz(asu64(R1));
	return;
}

static i64 qq_pclgen_checkblockreturn(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	u64 r;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5225;
	R1 = 0;
	goto L5223;
L5225:
	R1 = (u64)&qq_tables_jhasvalue;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5227;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5228;
	goto L5229;
L5227:
	R1 = 0;
	goto L5223;
	goto L5226;
L5228:
	R1 = 1;
	goto L5223;
	goto L5226;
L5229:
L5226:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5231;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5232;
	goto L5233;
L5231:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5235;
	R1 = 0;
	goto L5223;
L5235:
	goto L5237;
L5236:
	asu64(R1) = r;
	q = asu64(R1);
L5237:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	r = asu64(R2);
	if (asu64(R1)) goto L5236;
	asu64(R1) = q;
	asi64(R1) = qq_pclgen_checkblockreturn(asu64(R1));
	goto L5223;
	goto L5230;
L5232:
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = qq_pclgen_checkblockreturn(asu64(R1));
	if (!asi64(R1)) goto L5239;
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = qq_pclgen_checkblockreturn(asu64(R1));
	if (!asi64(R1)) goto L5239;
	R1 = 1;
	goto L5240;
L5239:
	R1 = 0;
L5240:
	goto L5223;
	goto L5230;
L5233:
	R1 = 1;
	goto L5223;
L5230:
	R1 = 0;
	goto L5223;
L5223:
	return asi64(R1);
}

static void qq_pcllib_start() {
    u64 R1, R2; 
	i64 nn;
	mlib_pcm_init();
	R1 = 8192;
	qq_pcllib_labelalloc = asi64(R1);
	R1 = 8;
	asi64(R2) = qq_pcllib_labelalloc;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	qq_pcllib_labelpctable = asu64(R1);
	return;
}

static void qq_pcllib_resetpcl(i64 sourcesize) {
    u64 R1, R2; 
	i64 pclsize;
	R1 = 0;
	qq_decls_qpos = asi64(R1);
	R1 = 0;
	qq_pcllib_nextlabelno = asi64(R1);
	R1 = 0;
	qq_pcllib_pclcurrlineno = asi64(R1);
	asi64(R1) = sourcesize;
	pclsize = asi64(R1);
	R1 = 1024;
	qq_pcllib_pcalloc = asi64(R1);
	goto L5244;
L5243:
	R1 = 1;
	R2 = (u64)&qq_pcllib_pcalloc;
	*toi64p(R2) <<= asi64(R1);
L5244:
	asi64(R1) = qq_pcllib_pcalloc;
	asi64(R2) = pclsize;
	if (asi64(R1) < asi64(R2)) goto L5243;
	asi64(R1) = qq_pcllib_pcalloc;
	R2 = 32;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	qq_pcllib_pcstart = asu64(R1);
	asu64(R1) = qq_pcllib_pcstart;
	R2 = 1;
	R1 -= (i64)R2*32;
	qq_pcllib_pccurr = asu64(R1);
	asu64(R1) = qq_pcllib_pcstart;
	asi64(R2) = qq_pcllib_pcalloc;
	R1 += (i64)R2*32;
	R2 = 8;
	R1 -= (i64)R2*32;
	qq_pcllib_pcend = asu64(R1);
	asi64(R1) = qq_pcllib_pcalloc;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	qq_pcllib_pcsourcestart = asu64(R1);
	asu64(R1) = qq_pcllib_pcsourcestart;
	qq_pcllib_pcsourcecurr = asu64(R1);
	R1 = 8;
	asi64(R2) = qq_pcllib_labelalloc;
	asi64(R1) *= asi64(R2);
	asu64(R2) = qq_pcllib_labelpctable;
	mlib_pcm_clearmem(asu64(R2), asi64(R1));
	return;
}

static void qq_pcllib_genpc(i64 opc) {
    u64 R1, R2, R3; 
	R1 = (u64)&qq_pcllib_pccurr;
	(*tou64p(R1)) += 32;
	asu64(R1) = qq_pcllib_pccurr;
	asu64(R2) = qq_pcllib_pcend;
	if (asu64(R1) < asu64(R2)) goto L5248;
	qq_pcllib_extendpcldata();
L5248:
	asi64(R1) = opc;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&qq_pcllib_pcsourcecurr;
	(*tou64p(R1)) += 4;
	asi64(R1) = qq_decls_qpos;
	asu64(R2) = qq_pcllib_pcsourcecurr;
	*toi32p(R2) = asi32(R1);
	return;
}

static void qq_pcllib_genpc_int(i64 opc, i64 a) {
    u64 R1, R2, R3; 
	asi64(R1) = opc;
	qq_pcllib_genpc(asi64(R1));
	asi64(R1) = a;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_pcllib_genpc_n(i64 opc, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = opc;
	qq_pcllib_genpc(asi64(R1));
	asi64(R1) = n;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void qq_pcllib_genpc_xy(i64 opc, i64 x, i64 y) {
    u64 R1, R2, R3; 
	asi64(R1) = opc;
	qq_pcllib_genpc(asi64(R1));
	asi64(R1) = x;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 12;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = y;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 14;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	return;
}

static void qq_pcllib_genpc_name(i64 opc, u64 d) {
    u64 R1, R2, R3; 
	asi64(R1) = opc;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = d;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_pcllib_genopnd_strz(u64 s) {
    u64 R1, R2, R3; 
	asu64(R1) = s;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_pcllib_genopnd_str(u64 s) {
    u64 R1, R2, R3; 
	asu64(R1) = s;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_pcllib_genopnd_obj(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_pcllib_genpc_real(i64 opc, r64 x) {
    u64 R1, R2, R3; 
	asi64(R1) = opc;
	qq_pcllib_genpc(asi64(R1));
	asr64(R1) = x;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	return;
}

static void qq_pcllib_genpc_lab(i64 opc, i64 lab) {
    u64 R1, R2, R3; 
	asi64(R1) = opc;
	qq_pcllib_genpc(asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_pcllib_gencomment(u64 s) {
    u64 R1; 
	R1 = 6;
	qq_pcllib_genpc(asi64(R1));
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	qq_pcllib_genopnd_strz(asu64(R1));
	return;
}

static void qq_pcllib_extendpcldata() {
    u64 R1, R2, R3; 
	i64 newpcalloc;
	u64 newpcstart;
	u64 newpcsourcestart;
	asi64(R1) = qq_pcllib_pcalloc;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	newpcalloc = asi64(R1);
	R1 = 32;
	asi64(R2) = newpcalloc;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	newpcstart = asu64(R1);
	R1 = 4;
	asi64(R2) = newpcalloc;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	newpcsourcestart = asu64(R1);
	asu64(R1) = qq_pcllib_pcstart;
	asu64(R2) = qq_pcllib_pccurr;
	asi64(R1) = qq_lib_getpcloffset(asu64(R2), asu64(R1));
	R2 = 32;
	asu64(R1) *= asu64(R2);
	asu64(R2) = qq_pcllib_pcstart;
	asu64(R3) = newpcstart;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = qq_pcllib_pcstart;
	asu64(R2) = qq_pcllib_pccurr;
	asi64(R1) = qq_lib_getpcloffset(asu64(R2), asu64(R1));
	R2 = 4;
	asu64(R1) *= asu64(R2);
	asu64(R2) = qq_pcllib_pcsourcestart;
	asu64(R3) = newpcsourcestart;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = newpcstart;
	asu64(R2) = qq_pcllib_pcstart;
	asu64(R3) = qq_pcllib_pccurr;
	asi64(R2) = qq_lib_getpcloffset(asu64(R3), asu64(R2));
	R1 += (i64)R2*32;
	qq_pcllib_pccurr = asu64(R1);
	asu64(R1) = newpcstart;
	asi64(R2) = newpcalloc;
	R1 += (i64)R2*32;
	R2 = 10;
	R1 -= (i64)R2*32;
	qq_pcllib_pcend = asu64(R1);
	asu64(R1) = newpcsourcestart;
	asu64(R2) = qq_pcllib_pcsourcecurr;
	asu64(R3) = qq_pcllib_pcsourcestart;
	asi64(R2) -= asi64(R3);
    asi64(R2) /= 4;
	R1 += (i64)R2*4;
	qq_pcllib_pcsourcecurr = asu64(R1);
	asi64(R1) = qq_pcllib_pcalloc;
	R2 = 32;
	asi64(R1) *= asi64(R2);
	asu64(R2) = qq_pcllib_pcstart;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asi64(R1) = qq_pcllib_pcalloc;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	asu64(R2) = qq_pcllib_pcsourcestart;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = newpcstart;
	qq_pcllib_pcstart = asu64(R1);
	asi64(R1) = newpcalloc;
	qq_pcllib_pcalloc = asi64(R1);
	asu64(R1) = newpcsourcestart;
	qq_pcllib_pcsourcestart = asu64(R1);
	return;
}

static void qq_pcllib_extendlabeltable() {
    u64 R1, R2, R3; 
	i64 newlabelalloc;
	u64 newlabeltable;
	asi64(R1) = qq_pcllib_labelalloc;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	newlabelalloc = asi64(R1);
	R1 = 8;
	asi64(R2) = newlabelalloc;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	newlabeltable = asu64(R1);
	asi64(R1) = qq_pcllib_labelalloc;
	R2 = 8;
	asu64(R1) *= asu64(R2);
	asu64(R2) = qq_pcllib_labelpctable;
	asu64(R3) = newlabeltable;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = qq_pcllib_labelalloc;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R2) = qq_pcllib_labelpctable;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = newlabeltable;
	qq_pcllib_labelpctable = asu64(R1);
	asi64(R1) = newlabelalloc;
	qq_pcllib_labelalloc = asi64(R1);
	return;
}

static i64 qq_pcllib_definelabel() {
    u64 R1, R2, R3; 
	asi64(R1) = qq_pcllib_nextlabelno;
	asi64(R2) = qq_pcllib_labelalloc;
	if (asi64(R1) < asi64(R2)) goto L5263;
	qq_pcllib_extendlabeltable();
L5263:
	R1 = (u64)&qq_pcllib_nextlabelno;
	(*toi64p(R1)) += 1;
	asu64(R1) = qq_pcllib_pccurr;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = qq_pcllib_labelpctable;
	asi64(R3) = qq_pcllib_nextlabelno;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = qq_pcllib_nextlabelno;
	goto L5261;
L5261:
	return asi64(R1);
}

static i64 qq_pcllib_createfwdlabel() {
    u64 R1, R2, R3; 
	asi64(R1) = qq_pcllib_nextlabelno;
	asi64(R2) = qq_pcllib_labelalloc;
	if (asi64(R1) < asi64(R2)) goto L5266;
	qq_pcllib_extendlabeltable();
L5266:
	R1 = (u64)&qq_pcllib_nextlabelno;
	(*toi64p(R1)) += 1;
	R1 = 0;
	asu64(R2) = qq_pcllib_labelpctable;
	asi64(R3) = qq_pcllib_nextlabelno;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = qq_pcllib_nextlabelno;
	goto L5264;
L5264:
	return asi64(R1);
}

static void qq_pcllib_definefwdlabel(i64 lab) {
    u64 R1, R2, R3; 
	asu64(R1) = qq_pcllib_labelpctable;
	asi64(R2) = lab;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	if (!asu64(R1)) goto L5269;
	R1 = tou64("dupl label?");
	qq_lib_serror(asu64(R1));
L5269:
	asu64(R1) = qq_pcllib_pccurr;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = qq_pcllib_labelpctable;
	asi64(R3) = lab;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	return;
}

static void qq_pcllib_genxy(i64 x, i64 y) {
    u64 R1, R2, R3; 
	asi64(R1) = x;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 12;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = y;
	asu64(R2) = qq_pcllib_pccurr;
	R3 = 14;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	return;
}

static void qq_print_pch_print(u64 p, u64 fmt) {
    u64 R1, R2, R3; 
	struct $B3 v;
	u64 q;
	u64 s;
	struct $B3 emptyfmt;
	asu64(R1) = fmt;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5273;
	R1 = (u64)&emptyfmt;
	fmt = asu64(R1);
	R1 = 0;
	R2 = (u64)&emptyfmt;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L5273:
	asu64(R1) = qq_print_mfmtstr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5275;
	asu8(R1) = qq_print_mgapneeded;
	if (!asu8(R1)) goto L5277;
	R1 = 1;
	R2 = tou64(" ");
	qq_print_printstr_n(asu64(R2), asi64(R1));
	goto L5276;
L5277:
	R1 = 1;
	qq_print_mgapneeded = asu8(R1);
L5276:
	goto L5274;
L5275:
	R1 = 0;
	qq_print_printnextfmtchars(asi64(R1));
L5274:
	R1 = 0;
	qq_print_listdepth = asi64(R1);
	R1 = (u64)&v;
	asu64(R2) = fmt;
	asu64(R3) = p;
	qq_print_pch_tostr(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&v;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&v;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_print_printstr_n(asu64(R2), asi64(R1));
	R1 = (u64)&v;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5279;
	R1 = (u64)&v;
	qq_vars_var_unshareu(asu64(R1));
L5279:
	return;
}

static void qq_print_pch_print_nf(u64 p) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = p;
	qq_print_pch_print(asu64(R2), asu64(R1));
	return;
}

static void qq_print_pch_printnogap() {
    u64 R1; 
	R1 = 0;
	qq_print_mgapneeded = asu8(R1);
	return;
}

static void qq_print_pch_println() {
    u64 R1, R2; 
	asu64(R1) = qq_print_mfmtstr;
	if (!asu64(R1)) goto L5284;
	R1 = 1;
	qq_print_printnextfmtchars(asi64(R1));
L5284:
	R1 = 0;
	qq_print_mgapneeded = asu8(R1);
	R1 = -1;
	R2 = tou64("\n");
	qq_print_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void qq_print_pch_reread() {
    u64 R1; 
	asu64(R1) = qq_print_kb_lastpos;
	qq_print_kb_pos = asu64(R1);
	asi64(R1) = qq_print_kb_lastlength;
	qq_print_kb_length = asi64(R1);
	return;
}

static void qq_print_pch_rereadln() {
    u64 R1; 
	asu64(R1) = qq_print_kb_start;
	qq_print_kb_pos = asu64(R1);
	asi64(R1) = qq_print_kb_linelength;
	qq_print_kb_length = asi64(R1);
	return;
}

static void qq_print_pch_startprint(u64 p) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 s;
	R1 = (u64)&qq_print_noclevels;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5289;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5289;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5290;
	goto L5291;
L5289:
	goto L5288;
L5290:
	R1 = tou64("print #x overflow");
	qq_lib_prterror(asu64(R1));
	goto L5288;
L5291:
	asi64(R1) = qq_print_moutdev;
	R2 = (u64)&qq_print_moutdevstack;
	asi64(R3) = qq_print_noclevels;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	asu64(R1) = qq_print_moutchan;
	R2 = (u64)&qq_print_moutchanstack;
	asi64(R3) = qq_print_noclevels;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	(R1_B3) = qq_print_moutvar;
	R2 = (u64)&qq_print_moutvarstack;
	asi64(R3) = qq_print_noclevels;
	*(struct $B3*)(((i64)R2+(i64)R3*16-16)) = (R1_B3);
	asu64(R1) = qq_print_mfmtstr;
	R2 = (u64)&qq_print_mfmtstrstack;
	asi64(R3) = qq_print_noclevels;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = qq_print_mfmtcurr;
	R2 = (u64)&qq_print_mfmtcurrstack;
	asi64(R3) = qq_print_noclevels;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu8(R1) = qq_print_mgapneeded;
	R2 = (u64)&qq_print_mgapstack;
	asi64(R3) = qq_print_noclevels;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L5288:
	R1 = 0;
	qq_print_mfmtstr = asu64(R1);
	R1 = 0;
	qq_print_mfmtcurr = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5293;
	goto L5294;
L5293:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5296;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5297;
	goto L5298;
L5296:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5300;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5301;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5302;
	goto L5303;
L5300:
// qq_print.pch_startprint.doconsole:
L5294:
	R1 = 0;
	qq_print_moutdev = asi64(R1);
	R1 = 0;
	qq_print_moutchan = asu64(R1);
	goto L5299;
L5301:
	R1 = 2;
	qq_print_moutdev = asi64(R1);
	R1 = 0;
	qq_print_moutchan = asu64(R1);
	R1 = 265;
	R2 = (u64)&qq_print_moutvar;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = qq_vars_obj_new();
	s = asu64(R1);
	R1 = 1;
	asu64(R2) = s;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = s;
	R2 = (u64)&qq_print_moutvar;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L5299;
L5302:
	asu64(R1) = qq_print_testfilech;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5305;
	R1 = tou64("@2: file not open");
	qq_lib_prterror(asu64(R1));
L5305:
	R1 = 1;
	qq_print_moutdev = asi64(R1);
	asu64(R1) = qq_print_testfilech;
	qq_print_moutchan = asu64(R1);
	goto L5299;
L5303:
	R1 = 1;
	qq_print_moutdev = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_print_moutchan = asu64(R1);
L5299:
	goto L5295;
L5297:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5307;
	goto L5308;
L5307:
	R1 = 4;
	qq_print_moutdev = asi64(R1);
	R1 = 0;
	qq_print_moutchan = asu64(R1);
	R1 = 14;
	R2 = (u64)&qq_print_moutvar;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	R2 = (u64)&qq_print_moutvar;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L5306;
L5308:
	msysc_m$print_startcon();
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Print@^?");
	qq_lib_prterror(asu64(R1));
L5306:
	goto L5295;
L5298:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5310;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5310;
	goto L5311;
L5310:
	R1 = 0;
	qq_print_moutdev = asi64(R1);
	goto L5309;
L5311:
	msysc_m$print_startcon();
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Can't do startprint...");
	qq_lib_prterror(asu64(R1));
L5309:
L5295:
	R1 = 0;
	qq_print_mgapneeded = asu8(R1);
	return;
}

static void qq_print_pch_startprintcon() {
    u64 R1, R2, R3; 
	struct $B3 v;
	R1 = 1;
	R2 = (u64)&v;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	R2 = (u64)&v;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&v;
	qq_print_pch_startprint(asu64(R1));
	return;
}

static void qq_print_pch_endprint() {
    u64 R1, R2; struct $B3 R1_B3; 
	u64 p;
	asu64(R1) = qq_print_mfmtstr;
	if (!asu64(R1)) goto L5315;
	R1 = 1;
	qq_print_printnextfmtchars(asi64(R1));
L5315:
	asi64(R1) = qq_print_moutdev;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5317;
	goto L5318;
L5317:
	R1 = (u64)&qq_print_moutvar;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L5316;
L5318:
L5316:
	asu64(R1) = qq_print_mfmtstr;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L5320;
	asu64(R1) = qq_print_mfmtstr;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = qq_print_mfmtstr;
	mlib_pcm_free(asu64(R2), asi64(R1));
L5320:
	R1 = (u64)&qq_print_noclevels;
	asi64(R1) = *(toi64p(R1)) -= 1;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L5322;
	R1 = tou64("resetoc??");
	qq_lib_prterror(asu64(R1));
L5322:
	asi64(R1) = qq_print_noclevels;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5324;
	R1 = 0;
	qq_print_moutdev = asi64(R1);
	goto L5323;
L5324:
	R1 = (u64)&qq_print_moutdevstack;
	asi64(R2) = qq_print_noclevels;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	qq_print_moutdev = asi64(R1);
	R1 = (u64)&qq_print_moutchanstack;
	asi64(R2) = qq_print_noclevels;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	qq_print_moutchan = asu64(R1);
	R1 = (u64)&qq_print_moutvarstack;
	asi64(R2) = qq_print_noclevels;
	(R1_B3) = *(struct $B3*)(((i64)R1+(i64)R2*16));
	qq_print_moutvar = (R1_B3);
	R1 = (u64)&qq_print_mgapstack;
	asi64(R2) = qq_print_noclevels;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	qq_print_mgapneeded = asu8(R1);
	R1 = (u64)&qq_print_mfmtstrstack;
	asi64(R2) = qq_print_noclevels;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	qq_print_mfmtstr = asu64(R1);
	R1 = (u64)&qq_print_mfmtcurrstack;
	asi64(R2) = qq_print_noclevels;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	qq_print_mfmtcurr = asu64(R1);
L5323:
	R1 = 0;
	qq_print_mgapneeded = asu8(R1);
	return;
}

static void qq_print_pch_strstartprint() {
    u64 R1, R2, R3; 
	struct $B3 p;
	R1 = 1;
	R2 = (u64)&p;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	R2 = (u64)&p;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&p;
	qq_print_pch_startprint(asu64(R1));
	return;
}

static void qq_print_pch_strendprint(u64 dest) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	asu64(R1) = qq_print_mfmtstr;
	if (!asu64(R1)) goto L5328;
	R1 = 1;
	qq_print_printnextfmtchars(asi64(R1));
L5328:
	asi64(R1) = qq_print_moutdev;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5330;
	R1 = tou64("STRENDPRT/NOT STR");
	qq_lib_prterror(asu64(R1));
L5330:
	(R1_B3) = qq_print_moutvar;
	asu64(R2) = dest;
	*(struct $B3*)(R2) = (R1_B3);
	R1 = 0;
	R2 = (u64)&qq_print_moutvar;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	qq_print_pch_endprint();
	return;
}

static void qq_print_pch_printspace() {
    u64 R1; 
	R1 = 0;
	qq_print_mgapneeded = asu8(R1);
	msysc_m$print_startcon();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	return;
}

static void qq_print_pch_readln(u64 dev) {
    u64 R1, R2, R3; 
	u64 ch;
	i64 length;
	u64 pdev;
	asu64(R1) = qq_print_kb_start;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5334;
	R1 = 1048576;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	qq_print_kb_start = asu64(R1);
	R1 = 1048576;
	qq_print_kb_size = asi64(R1);
	asu64(R1) = qq_print_kb_start;
	qq_print_kb_lastpos = asu64(R1);
	asu64(R1) = qq_print_kb_start;
	qq_print_kb_pos = asu64(R1);
	R1 = 0;
	qq_print_kb_length = asi64(R1);
	R1 = 0;
	qq_print_kb_lastlength = asi64(R1);
	R1 = 0;
	qq_print_kb_linelength = asi64(R1);
L5334:
	asu64(R1) = dev;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5336;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5337;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5338;
	goto L5339;
L5336:
// qq_print.pch_readln.doconsole:
L5340:
	asi64(R1) = qq_print_kb_size;
	asu64(R2) = qq_print_kb_start;
	R3 = 0;
	mlib_readlinen(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = qq_print_kb_start;
	asi64(R1) = strlen(asu64(R1));
	qq_print_kb_length = asi64(R1);
	goto L5335;
L5337:
	asu64(R1) = dev;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5342;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5343;
	goto L5344;
L5342:
	goto L5340;
	goto L5341;
L5343:
	asu64(R1) = qq_print_testfilech;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5346;
	R1 = tou64("R@2: file not open");
	qq_lib_prterror(asu64(R1));
L5346:
	asu64(R1) = qq_print_testfilech;
	ch = asu64(R1);
	goto L5341;
L5344:
	asu64(R1) = dev;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ch = asu64(R1);
L5341:
	asi64(R1) = qq_print_kb_size;
	asu64(R2) = qq_print_kb_start;
	asu64(R3) = ch;
	mlib_readlinen(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = qq_print_kb_start;
	asi64(R1) = strlen(asu64(R1));
	qq_print_kb_length = asi64(R1);
	goto L5335;
L5338:
	asu64(R1) = dev;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdev = asu64(R1);
	asu64(R1) = pdev;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5348;
	R1 = 0;
	qq_print_kb_length = asi64(R1);
	R1 = 0;
	asu64(R2) = qq_print_kb_start;
	*tou8p(R2) = asu8(R1);
	goto L5347;
L5348:
	asi64(R1) = length;
	asi64(R2) = qq_print_kb_size;
	if (asi64(R1) < asi64(R2)) goto L5349;
	R1 = tou64("KB overflow");
	qq_lib_prterror(asu64(R1));
	goto L5347;
L5349:
	asi64(R1) = length;
	qq_print_kb_length = asi64(R1);
	asi64(R1) = length;
	asu64(R2) = pdev;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = qq_print_kb_start;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L5347:
	goto L5335;
L5339:
	asu64(R1) = dev;
	R2 = tou64("readln@");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L5335:
	asu64(R1) = qq_print_kb_start;
	qq_print_kb_pos = asu64(R1);
	asu64(R1) = qq_print_kb_pos;
	qq_print_kb_lastpos = asu64(R1);
	asi64(R1) = qq_print_kb_length;
	qq_print_kb_linelength = asi64(R1);
	return;
}

static void qq_print_pch_sread(u64 fmt, u64 dest) {
    u64 R1, R2, R3, R4; 
	i64 fmtcode;
	u8 c;
	asu64(R1) = fmt;
	asi64(R1) = qq_print_getreadfmtcode(asu64(R1));
	fmtcode = asi64(R1);
	asu64(R1) = qq_print_kb_pos;
	qq_print_kb_lastpos = asu64(R1);
	asi64(R1) = qq_print_kb_length;
	qq_print_kb_lastlength = asi64(R1);
	asi64(R1) = fmtcode;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L5352;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L5353;
	R2 = 78;
	if (asi64(R1) == asi64(R2)) goto L5354;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L5355;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L5356;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L5357;
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L5358;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L5359;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5360;
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L5361;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L5362;
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L5363;
	goto L5364;
L5352:
	R1 = 0;
	asu64(R2) = dest;
	asi64(R3) = qq_print_kb_length;
	asu64(R4) = qq_print_kb_pos;
	asu64(R1) = qq_print_readint(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	qq_print_stepkbpos(asu64(R1));
	goto L5351;
L5353:
	asu64(R1) = dest;
	asi64(R2) = qq_print_kb_length;
	asu64(R3) = qq_print_kb_pos;
	asu64(R1) = qq_print_readreal(asu64(R3), asi64(R2), asu64(R1));
	qq_print_stepkbpos(asu64(R1));
	goto L5351;
L5354:
	asu64(R1) = dest;
	asi64(R2) = qq_print_kb_length;
	asu64(R3) = qq_print_kb_pos;
	asu64(R1) = qq_print_readname(asu64(R3), asi64(R2), asu64(R1));
	qq_print_stepkbpos(asu64(R1));
	goto L5351;
L5355:
	asu64(R1) = dest;
	asi64(R2) = qq_print_kb_length;
	asu64(R3) = qq_print_kb_pos;
	asu64(R1) = qq_print_readstring(asu64(R3), asi64(R2), asu64(R1));
	qq_print_stepkbpos(asu64(R1));
	goto L5351;
L5356:
	asu64(R1) = dest;
	asi64(R2) = qq_print_kb_length;
	asu64(R3) = qq_print_kb_pos;
	asu64(R1) = qq_print_readhex(asu64(R3), asi64(R2), asu64(R1));
	qq_print_stepkbpos(asu64(R1));
	goto L5351;
L5357:
	asu64(R1) = dest;
	asi64(R2) = qq_print_kb_length;
	asu64(R3) = qq_print_kb_pos;
	asu64(R1) = qq_print_readbin(asu64(R3), asi64(R2), asu64(R1));
	qq_print_stepkbpos(asu64(R1));
	goto L5351;
L5358:
	asu64(R1) = dest;
	asi64(R2) = qq_print_kb_length;
	asu64(R3) = qq_print_kb_pos;
	asu64(R1) = qq_print_readany(asu64(R3), asi64(R2), asu64(R1));
	qq_print_stepkbpos(asu64(R1));
	goto L5351;
L5359:
	asi64(R1) = qq_print_kb_length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5366;
	R1 = 0;
	asu64(R2) = dest;
	qq_strings_var_empty_string(asu64(R2), asi64(R1));
	goto L5365;
L5366:
	R1 = 1;
	asu64(R2) = dest;
	asi64(R3) = qq_print_kb_length;
	asu64(R4) = qq_print_kb_pos;
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = qq_print_kb_length;
	R2 = (u64)&qq_print_kb_pos;
	*tou64p(R2) += asu64(R1);
	R1 = 0;
	qq_print_kb_length = asi64(R1);
L5365:
	goto L5351;
L5360:
	asi64(R1) = qq_print_kb_length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5368;
	R1 = 0;
	asu64(R2) = dest;
	qq_strings_var_empty_string(asu64(R2), asi64(R1));
	goto L5367;
L5368:
	asu64(R1) = qq_print_kb_pos;
	asu8(R1) = *tou8p(R1);
	qq_print_termchar = asu8(R1);
// qq_print.pch_sread.dochar:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu8(R1) = qq_print_termchar;
	R1 = toi64(tou8(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&qq_print_kb_pos;
	(*tou64p(R1)) += 1;
	R1 = (u64)&qq_print_kb_length;
	(*toi64p(R1)) -=1;
L5367:
	goto L5351;
L5361:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu8(R1) = qq_print_termchar;
	R1 = toi64(tou8(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5351;
L5362:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = qq_print_itemerror;
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5351;
L5363:
	R1 = 1;
	asu64(R2) = dest;
	asi64(R3) = qq_print_kb_length;
	asu64(R4) = qq_print_kb_pos;
	asu64(R1) = qq_print_readint(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	qq_print_stepkbpos(asu64(R1));
	goto L5351;
L5364:
	R1 = tou64("SREAD/FMT?");
	qq_lib_prterror(asu64(R1));
L5351:
	return;
}

static void qq_print_pch_sreadln(u64 dev, u64 dest) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = dev;
	qq_print_pch_readln(asu64(R1));
	R1 = 1;
	asu64(R2) = dest;
	asi64(R3) = qq_print_kb_length;
	asu64(R4) = qq_print_kb_start;
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	return;
}

static u64 qq_print_readname(u64 s, i64 length, u64 dest) {
    u64 R1, R2, R3, R4; 
	u64 send;
	u64 itemstr;
	i64 itemlength;
	R1 = (u64)&itemlength;
	R2 = (u64)&itemstr;
	asi64(R3) = length;
	asu64(R4) = s;
	asu64(R1) = qq_print_readitem(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	send = asu64(R1);
	R1 = 1;
	asu64(R2) = dest;
	asi64(R3) = itemlength;
	asu64(R4) = itemstr;
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	asu64(R1) = dest;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_iconvlcn(asu64(R2), asi64(R1));
	asu64(R1) = send;
	goto L5371;
L5371:
	return asu64(R1);
}

static u64 qq_print_readstring(u64 s, i64 length, u64 dest) {
    u64 R1, R2, R3, R4; 
	u64 send;
	u64 itemstr;
	i64 itemlength;
	R1 = (u64)&itemlength;
	R2 = (u64)&itemstr;
	asi64(R3) = length;
	asu64(R4) = s;
	asu64(R1) = qq_print_readitem(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	send = asu64(R1);
	R1 = 1;
	asu64(R2) = dest;
	asi64(R3) = itemlength;
	asu64(R4) = itemstr;
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	asu64(R1) = send;
	goto L5372;
L5372:
	return asu64(R1);
}

static u64 qq_print_readint(u64 sold, i64 length, u64 dest, i64 dodec) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 s;
	u64 send;
	u64 itemstr;
	i64 itemlength;
	i64 numlength;
	R1 = (u64)&itemlength;
	R2 = (u64)&s;
	asi64(R3) = length;
	asu64(R4) = sold;
	asu64(R1) = qq_print_readitem(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	send = asu64(R1);
	asi64(R1) = dodec;
	asu64(R2) = dest;
	asi64(R3) = itemlength;
	asu64(R4) = s;
	qq_print_strtoint(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	asu64(R1) = send;
	goto L5373;
L5373:
	return asu64(R1);
}

static u64 qq_print_readhex(u64 sold, i64 length, u64 dest) {
    u64 R1, R2, R3; 
	struct $B16 str;
	u64 p;
	u64 s;
	u8 res;
	i64 aa;
	i64 a;
	i64 t;
	i64 nalloc;
	u8 c;
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5376;
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	qq_print_termchar = asu8(R1);
	asu64(R1) = sold;
	goto L5374;
L5376:
	goto L5378;
L5377:
	R1 = (u64)&sold;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
L5378:
	asi64(R1) = length;
	if (!asi64(R1)) goto L5380;
	asu64(R1) = sold;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L5377;
	asu64(R1) = sold;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5377;
L5380:
	asi64(R1) = length;
	R2 = 256;
	if (asi64(R1) > asi64(R2)) goto L5382;
	R1 = (u64)&str;
	s = asu64(R1);
	R1 = 0;
	nalloc = asi64(R1);
	goto L5381;
L5382:
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	nalloc = asi64(R1);
	asi64(R1) = nalloc;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	s = asu64(R1);
L5381:
	asu64(R1) = s;
	p = asu64(R1);
	goto L5384;
L5383:
	asu64(R1) = sold;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	c = asu8(R1);
	R1 = (u64)&sold;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) < asu64(R2)) goto L5387;
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 57;
	if (asu64(R1) > asu64(R2)) goto L5387;
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L5386;
L5387:
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 65;
	if (asu64(R1) < asu64(R2)) goto L5388;
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 70;
	if (asu64(R1) > asu64(R2)) goto L5388;
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L5386;
L5388:
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 95;
	if (asu64(R1) != asu64(R2)) goto L5389;
	goto L5386;
L5389:
	asu8(R1) = c;
	qq_print_termchar = asu8(R1);
	goto L5385;
L5386:
L5384:
	asi64(R1) = length;
	if (asi64(R1)) goto L5383;
L5385:
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = p;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 16;
	if (asi64(R1) > asi64(R2)) goto L5391;
	R1 = 1;
	t = asi64(R1);
	goto L5390;
L5391:
	R1 = 3;
	t = asi64(R1);
L5390:
	asu64(R1) = s;
	p = asu64(R1);
	asi64(R1) = t;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5393;
	goto L5394;
L5393:
	R1 = 0;
	aa = asi64(R1);
L5395:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5398;
	goto L5396;
L5398:
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 65;
	if (asu64(R1) >= asu64(R2)) goto L5400;
	asi64(R1) = aa;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu8(R2) = c;
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	aa = asi64(R1);
	goto L5399;
L5400:
	asi64(R1) = aa;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu8(R2) = c;
	R2 = tou64(tou8(R2));
	R3 = 65;
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	R2 = 10;
	asi64(R1) += asi64(R2);
	aa = asi64(R1);
L5399:
	goto L5395;
L5396:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = aa;
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5392;
L5394:
	R1 = tou64("Readhex/long");
	qq_lib_prterror(asu64(R1));
L5392:
	asi64(R1) = nalloc;
	if (!asi64(R1)) goto L5402;
	asi64(R1) = nalloc;
	asu64(R2) = s;
	mlib_pcm_free(asu64(R2), asi64(R1));
L5402:
	asu64(R1) = sold;
	goto L5374;
L5374:
	return asu64(R1);
}

static u64 qq_print_readbin(u64 sold, i64 length, u64 dest) {
    u64 R1, R2, R3; 
	struct $B16 str;
	u64 p;
	u64 s;
	u8 res;
	i64 aa;
	i64 a;
	i64 t;
	i64 nalloc;
	u8 c;
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5405;
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	qq_print_termchar = asu8(R1);
	asu64(R1) = sold;
	goto L5403;
L5405:
	goto L5407;
L5406:
	R1 = (u64)&sold;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
L5407:
	asi64(R1) = length;
	if (!asi64(R1)) goto L5409;
	asu64(R1) = sold;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L5406;
	asu64(R1) = sold;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5406;
L5409:
	asi64(R1) = length;
	R2 = 256;
	if (asi64(R1) > asi64(R2)) goto L5411;
	R1 = (u64)&str;
	s = asu64(R1);
	R1 = 0;
	nalloc = asi64(R1);
	goto L5410;
L5411:
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	nalloc = asi64(R1);
	asi64(R1) = nalloc;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	s = asu64(R1);
L5410:
	asu64(R1) = s;
	p = asu64(R1);
	goto L5413;
L5412:
	asu64(R1) = sold;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	c = asu8(R1);
	R1 = (u64)&sold;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) < asu64(R2)) goto L5416;
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 49;
	if (asu64(R1) > asu64(R2)) goto L5416;
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L5415;
L5416:
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 95;
	if (asu64(R1) != asu64(R2)) goto L5417;
	goto L5415;
L5417:
	asu8(R1) = c;
	qq_print_termchar = asu8(R1);
	goto L5414;
L5415:
L5413:
	asi64(R1) = length;
	if (asi64(R1)) goto L5412;
L5414:
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = p;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 64;
	if (asi64(R1) > asi64(R2)) goto L5419;
	R1 = 1;
	t = asi64(R1);
	goto L5418;
L5419:
	R1 = 3;
	t = asi64(R1);
L5418:
	asu64(R1) = s;
	p = asu64(R1);
	asi64(R1) = t;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5421;
	goto L5422;
L5421:
	R1 = 0;
	aa = asi64(R1);
L5423:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5426;
	goto L5424;
L5426:
	asi64(R1) = aa;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	asu8(R2) = c;
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	aa = asi64(R1);
	goto L5423;
L5424:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = aa;
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5420;
L5422:
	R1 = tou64("Readbin/long");
	qq_lib_prterror(asu64(R1));
L5420:
	asi64(R1) = nalloc;
	if (!asi64(R1)) goto L5428;
	asi64(R1) = nalloc;
	asu64(R2) = s;
	mlib_pcm_free(asu64(R2), asi64(R1));
L5428:
	asu64(R1) = sold;
	goto L5403;
L5403:
	return asu64(R1);
}

static u64 qq_print_readreal(u64 sold, i64 length, u64 dest) {
    u64 R1, R2, R3, R4; 
	struct $B25 str;
	r64 x;
	u64 send;
	u64 itemstr;
	i64 itemlength;
	i64 numlength;
	R1 = (u64)&itemlength;
	R2 = (u64)&itemstr;
	asi64(R3) = length;
	asu64(R4) = sold;
	asu64(R1) = qq_print_readitem(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	send = asu64(R1);
	asu64(R1) = dest;
	asi64(R2) = itemlength;
	asu64(R3) = itemstr;
	qq_print_strtoreal(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = send;
	goto L5429;
L5429:
	return asu64(R1);
}

static i64 qq_print_getreadfmtcode(u64 p) {
    u64 R1, R2, R3; 
	u8 c;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L5433;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5432;
L5433:
	R1 = 65;
	goto L5430;
L5432:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5435;
	msysc_m$print_startcon();
	R1 = tou64("P=%s");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Readfmt?");
	qq_lib_prterror(asu64(R1));
L5435:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5437;
	R1 = 65;
	goto L5430;
L5437:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	c = asu8(R1);
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 73;
	if (asu64(R1) == asu64(R2)) goto L5439;
	R2 = 82;
	if (asu64(R1) == asu64(R2)) goto L5439;
	R2 = 78;
	if (asu64(R1) == asu64(R2)) goto L5439;
	R2 = 83;
	if (asu64(R1) == asu64(R2)) goto L5439;
	R2 = 70;
	if (asu64(R1) == asu64(R2)) goto L5439;
	R2 = 84;
	if (asu64(R1) == asu64(R2)) goto L5439;
	R2 = 90;
	if (asu64(R1) == asu64(R2)) goto L5439;
	R2 = 67;
	if (asu64(R1) == asu64(R2)) goto L5439;
	R2 = 76;
	if (asu64(R1) == asu64(R2)) goto L5439;
	R2 = 72;
	if (asu64(R1) == asu64(R2)) goto L5439;
	R2 = 66;
	if (asu64(R1) == asu64(R2)) goto L5439;
	R2 = 65;
	if (asu64(R1) == asu64(R2)) goto L5439;
	R2 = 69;
	if (asu64(R1) == asu64(R2)) goto L5439;
	R2 = 68;
	if (asu64(R1) == asu64(R2)) goto L5439;
	goto L5440;
L5439:
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	goto L5430;
	goto L5438;
L5440:
L5438:
	R1 = tou64("Readfmt2?");
	qq_lib_prterror(asu64(R1));
	R1 = 0;
	goto L5430;
L5430:
	return asi64(R1);
}

static void qq_print_stepkbpos(u64 s) {
    u64 R1, R2; 
	i64 newlen;
	asu64(R1) = s;
	asu64(R2) = qq_print_kb_pos;
	asi64(R1) -= asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5443;
	goto L5441;
L5443:
	asi64(R1) = newlen;
	asi64(R2) = qq_print_kb_length;
	if (asi64(R1) < asi64(R2)) goto L5445;
	asu64(R1) = qq_print_kb_pos;
	asi64(R2) = qq_print_kb_length;
	R1 += (i64)R2;
	qq_print_kb_pos = asu64(R1);
	R1 = 0;
	qq_print_kb_length = asi64(R1);
	goto L5444;
L5445:
	asu64(R1) = qq_print_kb_pos;
	asi64(R2) = newlen;
	R1 += (i64)R2;
	qq_print_kb_pos = asu64(R1);
	asi64(R1) = newlen;
	R2 = (u64)&qq_print_kb_length;
	*toi64p(R2) -= asi64(R1);
L5444:
L5441:
	return;
}

static u64 qq_print_readany(u64 sold, i64 length, u64 dest) {
    u64 R1, R2, R3, R4; 
	struct $B16 str;
	u64 p;
	u64 s;
	u8 signd;
	u8 res;
	i64 aa;
	i64 digits;
	i64 expon;
	i64 other;
	i64 t;
	i64 nalloc;
	u8 c;
	u64 send;
	u64 itemstr;
	i64 itemlength;
	i64 numlength;
	i64 av_1;
	R1 = 0;
	qq_print_itemerror = asi64(R1);
	R1 = (u64)&itemlength;
	R2 = (u64)&s;
	asi64(R3) = length;
	asu64(R4) = sold;
	asu64(R1) = qq_print_readitem(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	send = asu64(R1);
	asu64(R1) = s;
	p = asu64(R1);
	R1 = 0;
	R2 = R1;
	other = asi64(R2);
	R2 = R1;
	expon = asi64(R2);
	digits = asi64(R1);
	asi64(R1) = itemlength;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5449;
L5447:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 43: case 45: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 95: goto L5453;
	case 44: case 47: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 68: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 96: case 97: case 98: case 99: case 100: goto L5452;
	case 46: case 69: case 101: goto L5454;
	default: goto L5452;
    };
// SWITCH
L5453:
	R1 = 1;
	digits = asi64(R1);
	goto L5450;
L5454:
	R1 = 1;
	expon = asi64(R1);
	goto L5450;
L5452:
	R1 = 1;
	other = asi64(R1);
L5450:
	if (--asi64(av_1)) goto L5447;
L5449:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = other;
	if (asi64(R1)) goto L5457;
	asi64(R1) = itemlength;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5456;
L5457:
	R1 = 5395539;
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = dest;
	asi64(R3) = itemlength;
	asu64(R4) = s;
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	goto L5455;
L5456:
	asi64(R1) = expon;
	if (!asi64(R1)) goto L5458;
	asu64(R1) = dest;
	asi64(R2) = itemlength;
	asu64(R3) = s;
	qq_print_strtoreal(asu64(R3), asi64(R2), asu64(R1));
	goto L5455;
L5458:
	R1 = 0;
	asu64(R2) = dest;
	asi64(R3) = itemlength;
	asu64(R4) = s;
	qq_print_strtoint(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
L5455:
	asu64(R1) = send;
	goto L5446;
L5446:
	return asu64(R1);
}

static u64 qq_print_readitem(u64 s, i64 length, u64 itemstr, u64 itemlength) {
    u64 R1, R2, R3; 
	u64 p;
	u8 quotechar;
	u8 c;
	goto L5461;
L5460:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
L5461:
	asi64(R1) = length;
	if (!asi64(R1)) goto L5463;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L5460;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5460;
L5463:
	asu64(R1) = s;
	asu64(R2) = itemstr;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5465;
	R1 = 0;
	qq_print_termchar = asu8(R1);
	R1 = 0;
	asu64(R2) = itemlength;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = s;
	goto L5459;
L5465:
	R1 = 0;
	quotechar = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) != asu64(R2)) goto L5467;
	R1 = 34;
	quotechar = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	goto L5466;
L5467:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 39;
	if (asu64(R1) != asu64(R2)) goto L5468;
	R1 = 39;
	quotechar = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
L5468:
L5466:
	asu64(R1) = s;
	R2 = R1;
	asu64(R3) = itemstr;
	*tou64p(R3) = asu64(R2);
	p = asu64(R1);
	goto L5470;
L5469:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L5473;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L5473;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L5473;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L5473;
	R2 = 59;
	if (asu64(R1) == asu64(R2)) goto L5473;
	goto L5474;
L5473:
	asu8(R1) = quotechar;
	if (asu8(R1)) goto L5477;
	asu64(R1) = p;
	asu64(R2) = s;
	if (asu64(R1) != asu64(R2)) goto L5476;
L5477:
	goto L5478;
L5476:
	asu8(R1) = c;
	qq_print_termchar = asu8(R1);
	goto L5471;
	goto L5472;
L5474:
// qq_print.readitem.normalchar:
L5478:
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	asu8(R2) = quotechar;
	R2 = tou64(tou8(R2));
	if (asu64(R1) != asu64(R2)) goto L5480;
	asi64(R1) = length;
	if (!asi64(R1)) goto L5482;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asu8(R2) = quotechar;
	R2 = tou64(tou8(R2));
	if (asu64(R1) != asu64(R2)) goto L5482;
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L5481;
L5482:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	qq_print_termchar = asu8(R1);
	asu8(R1) = qq_print_termchar;
	R1 = tou64(tou8(R1));
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L5485;
	asu8(R1) = qq_print_termchar;
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L5484;
L5485:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	qq_print_termchar = asu8(R1);
L5484:
	goto L5471;
L5481:
	goto L5479;
L5480:
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L5479:
L5472:
L5470:
	asi64(R1) = length;
	if (asi64(R1)) goto L5469;
L5471:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5487;
	R1 = 0;
	qq_print_termchar = asu8(R1);
L5487:
	asu64(R1) = p;
	asu64(R2) = itemstr;
	asu64(R2) = *tou64p(R2);
	asi64(R1) -= asi64(R2);
	asu64(R2) = itemlength;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = s;
	goto L5459;
L5459:
	return asu64(R1);
}

static void qq_print_strtoreal(u64 s, i64 length, u64 dest) {
    u64 R1, R2, R3, R4; 
	struct $B25 str;
	r64 x;
	i32 numlength;
	R1 = 2;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = length;
	R2 = 512;
	if (asi64(R1) >= asi64(R2)) goto L5491;
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5490;
L5491:
	asr64(R1) = 0.000000000000000000e+000;
	asu64(R2) = dest;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L5488;
L5490:
	asi64(R1) = length;
	asu64(R2) = s;
	R3 = (u64)&str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	qq_print_itemerror = asi64(R1);
	R1 = (u64)&numlength;
	R2 = (u64)&x;
	R3 = tou64("%lf%n");
	R4 = (u64)&str;
	asi32(R1) = sscanf(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5494;
	asi32(R1) = numlength;
	R1 = toi64(toi32(R1));
	asi64(R2) = length;
	if (asi64(R1) == asi64(R2)) goto L5493;
L5494:
	asi32(R1) = numlength;
	R1 = toi64(toi32(R1));
	asi64(R2) = length;
	if (asi64(R1) != asi64(R2)) goto L5496;
	asr64(R1) = 0.000000000000000000e+000;
	x = asr64(R1);
L5496:
	R1 = 1;
	qq_print_itemerror = asi64(R1);
L5493:
	asr64(R1) = x;
	asu64(R2) = dest;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
L5488:
	return;
}

static void qq_print_strtoint(u64 s, i64 length, u64 dest, i64 dodec) {
    u64 R1, R2, R3; 
	struct $B16 str;
	u64 p;
	u64 q;
	u8 signd;
	i64 aa;
	i64 a;
	i64 res;
	i64 cat;
	i64 t;
	i64 nalloc;
	u8 c;
	R1 = 0;
	qq_print_itemerror = asi64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5499;
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5497;
L5499:
	R1 = 0;
	signd = asu8(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L5501;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) != asu64(R2)) goto L5501;
	R1 = 1;
	signd = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	goto L5500;
L5501:
	asi64(R1) = length;
	if (!asi64(R1)) goto L5502;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) != asu64(R2)) goto L5502;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
L5502:
L5500:
	goto L5504;
L5503:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
L5504:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) != asu64(R2)) goto L5506;
	asi64(R1) = length;
	R2 = 1;
	if (asi64(R1) > asi64(R2)) goto L5503;
L5506:
	asu64(R1) = s;
	R2 = R1;
	q = asu64(R2);
	p = asu64(R1);
	goto L5508;
L5507:
	R1 = (u64)&q;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) < asu64(R2)) goto L5511;
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 57;
	if (asu64(R1) > asu64(R2)) goto L5511;
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L5510;
L5511:
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 95;
	if (asu64(R1) != asu64(R2)) goto L5513;
	goto L5512;
L5513:
	R1 = 1;
	qq_print_itemerror = asi64(R1);
	goto L5509;
L5512:
L5510:
L5508:
	asi64(R1) = length;
	if (asi64(R1)) goto L5507;
L5509:
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = p;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 18;
	if (asi64(R1) > asi64(R2)) goto L5515;
	R1 = 65;
	cat = asi64(R1);
	goto L5514;
L5515:
	asi64(R1) = length;
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L5516;
	R1 = tou64("9223372036854775808");
	asu64(R2) = s;
	asi64(R1) = mlib_cmpstring(asu64(R2), asu64(R1));
	R2 = -1;
	if (asi64(R1) == asi64(R2)) goto L5518;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5519;
	goto L5520;
L5518:
	R1 = 65;
	cat = asi64(R1);
	goto L5517;
L5519:
	R1 = 66;
	cat = asi64(R1);
	goto L5517;
L5520:
	R1 = 67;
	cat = asi64(R1);
L5517:
	goto L5514;
L5516:
	asi64(R1) = length;
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L5521;
	R1 = tou64("18446744073709551615");
	asu64(R2) = s;
	asi64(R1) = mlib_cmpstring(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L5523;
	R1 = 67;
	cat = asi64(R1);
	goto L5522;
L5523:
	R1 = 68;
	cat = asi64(R1);
L5522:
	goto L5514;
L5521:
	R1 = 68;
	cat = asi64(R1);
L5514:
	asi64(R1) = dodec;
	if (!asi64(R1)) goto L5525;
	R1 = 68;
	cat = asi64(R1);
L5525:
	asu8(R1) = signd;
	if (!asu8(R1)) goto L5527;
	asi64(R1) = cat;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L5529;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5530;
	goto L5531;
L5529:
	R1 = 65;
	cat = asi64(R1);
	goto L5528;
L5530:
	R1 = 68;
	cat = asi64(R1);
	goto L5528;
L5531:
L5528:
L5527:
	asi64(R1) = cat;
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L5533;
	goto L5534;
L5533:
	R1 = 1;
	t = asi64(R1);
	goto L5532;
L5534:
	R1 = 3;
	t = asi64(R1);
L5532:
	asu64(R1) = s;
	p = asu64(R1);
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5536;
	R1 = 0;
	aa = asi64(R1);
L5537:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5540;
	goto L5538;
L5540:
	asi64(R1) = aa;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asu8(R2) = c;
	R2 = tou64(tou8(R2));
	R3 = 48;
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	aa = asi64(R1);
	goto L5537;
L5538:
	asu8(R1) = signd;
	if (!asu8(R1)) goto L5542;
	asi64(R1) = aa;
	asi64(R1) = -asi64(R1);
	aa = asi64(R1);
L5542:
	asi64(R1) = t;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = aa;
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5535;
L5536:
	asu64(R1) = dest;
	asi64(R2) = length;
	asu64(R3) = s;
	qq_decimal_var_make_dec_str(asu64(R3), asi64(R2), asu64(R1));
L5535:
L5497:
	return;
}

static void qq_print_printnextfmtchars(i64 lastx) {
    u64 R1, R2; 
	u8 c;
	u64 pstart;
	i64 n;
	asu64(R1) = qq_print_mfmtcurr;
	pstart = asu64(R1);
	R1 = 0;
	n = asi64(R1);
L5544:
	asu64(R1) = qq_print_mfmtcurr;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 35;
	if (asu64(R1) == asu64(R2)) goto L5547;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L5548;
	R2 = 126;
	if (asu64(R1) == asu64(R2)) goto L5549;
	goto L5550;
L5547:
	asi64(R1) = lastx;
	if (!asi64(R1)) goto L5552;
	goto L5553;
L5552:
	R1 = (u64)&qq_print_mfmtcurr;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	if (!asi64(R1)) goto L5555;
	asi64(R1) = n;
	asu64(R2) = pstart;
	qq_print_printstr_n(asu64(R2), asi64(R1));
L5555:
	goto L5543;
	goto L5546;
L5548:
	asi64(R1) = n;
	if (!asi64(R1)) goto L5557;
	asi64(R1) = n;
	asu64(R2) = pstart;
	qq_print_printstr_n(asu64(R2), asi64(R1));
	goto L5556;
L5557:
	asi64(R1) = lastx;
	if (asi64(R1)) goto L5558;
	R1 = 1;
	R2 = tou64("|");
	qq_print_printstr_n(asu64(R2), asi64(R1));
L5558:
L5556:
	goto L5543;
	goto L5546;
L5549:
	asi64(R1) = n;
	if (!asi64(R1)) goto L5560;
	asi64(R1) = n;
	asu64(R2) = pstart;
	qq_print_printstr_n(asu64(R2), asi64(R1));
	R1 = 0;
	n = asi64(R1);
L5560:
	R1 = (u64)&qq_print_mfmtcurr;
	(*tou64p(R1)) += 1;
	asu64(R1) = qq_print_mfmtcurr;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	if (!asu8(R1)) goto L5562;
	R1 = (u64)&qq_print_mfmtcurr;
	(*tou64p(R1)) += 1;
	R1 = 1;
	R2 = (u64)&c;
	qq_print_printstr_n(asu64(R2), asi64(R1));
L5562:
	asu64(R1) = qq_print_mfmtcurr;
	pstart = asu64(R1);
	goto L5546;
L5550:
// qq_print.printnextfmtchars.skip:
L5553:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	R1 = (u64)&qq_print_mfmtcurr;
	(*tou64p(R1)) += 1;
L5546:
	goto L5544;
L5543:
	return;
}

static void qq_print_pch_setformat(u64 p) {
    u64 R1, R2, R3; 
	i64 n;
	u64 s;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5565;
	R1 = tou64("(str)");
	qq_lib_prterror(asu64(R1));
L5565:
	asu64(R1) = qq_print_mfmtstr;
	if (!asu64(R1)) goto L5567;
	R1 = tou64("Setfmt?");
	qq_lib_prterror(asu64(R1));
L5567:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	qq_print_mfmtstr = asu64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L5569;
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = qq_print_mfmtstr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L5569:
	asu64(R1) = qq_print_mfmtstr;
	asi64(R2) = n;
	R1 += (i64)R2;
	s = asu64(R1);
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = qq_print_mfmtstr;
	qq_print_mfmtcurr = asu64(R1);
	return;
}

static u64 qq_print_pc_getfmt(u64 p, u64 fmt) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L5573;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5572;
L5573:
	R1 = (u64)&qq_print_defaultfmt;
	goto L5571;
L5572:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5575;
	R1 = tou64("pc_getfmt/not str?");
	qq_lib_prterror(asu64(R1));
L5575:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5577;
	R1 = (u64)&qq_print_defaultfmt;
	goto L5576;
L5577:
	asu64(R1) = fmt;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = fmt;
L5576:
L5571:
	goto L5570;
L5570:
	return asu64(R1);
}

static void qq_print_addstring(u64 p, u64 t, i64 n) {
    u64 R1, R2, R3, R4; 
	i64 oldlen;
	i64 newlen;
	i64 oldbytes;
	i64 newbytes;
	u64 newptr;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5581;
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5580;
L5581:
	goto L5578;
L5580:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L5583;
	asu64(R1) = t;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
L5583:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	oldlen = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5585;
	asi64(R1) = oldlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5587;
	asi64(R1) = n;
	asu64(R2) = t;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5586;
L5587:
	asi64(R1) = n;
	asu64(R2) = t;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R4) = oldlen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = oldlen;
	asi64(R2) = n;
	asi64(R1) += asi64(R2);
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L5586:
	goto L5578;
L5585:
	asi64(R1) = oldlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5589;
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = t;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L5588;
L5589:
	asi64(R1) = oldlen;
	asi64(R2) = n;
	asi64(R1) += asi64(R2);
	newlen = asi64(R1);
	asu64(R1) = p;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	oldbytes = asi64(R1);
	asi64(R1) = oldlen;
	asi64(R2) = n;
	asi64(R1) += asi64(R2);
	newbytes = asi64(R1);
	asi64(R1) = newbytes;
	asi64(R2) = oldbytes;
	if (asi64(R1) > asi64(R2)) goto L5591;
	asi64(R1) = n;
	asu64(R2) = t;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R4) = oldlen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L5590;
L5591:
	asi64(R1) = newbytes;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	newptr = asu64(R1);
	asi64(R1) = oldlen;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = newptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	asu64(R2) = t;
	asu64(R3) = newptr;
	asi64(R4) = oldlen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = oldbytes;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = newptr;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5590:
	asi64(R1) = newlen;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L5588:
L5578:
	return;
}

static void qq_print_domultichar(u64 p, i64 n, u64 dest, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B17 str;
	u64 q;
	i64 i;
	i64 nchars;
	i64 av_1;
	R1 = (u64)&str;
	q = asu64(R1);
	asi64(R1) = n;
	nchars = asi64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5595;
L5593:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5597;
	goto L5595;
L5597:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&q;
	(*tou64p(R1)) += 1;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L5593;
L5595:
	R1 = 0;
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = fmt;
	asi64(R2) = nchars;
	asu64(R3) = dest;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	return;
}

static void qq_print_printstr_n(u64 s, i64 n) {
    u64 R1, R2, R3, R4; 
	u64 p;
	i64 x;
	asi64(R1) = n;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L5600;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
L5600:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5602;
	goto L5598;
L5602:
	asi64(R1) = qq_print_moutdev;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5604;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5605;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5606;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5607;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5608;
	goto L5609;
L5604:
	R1 = 0;
	asi64(R2) = n;
	asu64(R3) = s;
	msysc_printstrn_app(asu64(R3), asi64(R2), asu64(R1));
	goto L5603;
L5605:
	asu64(R1) = qq_print_moutchan;
	asi64(R2) = n;
	asu64(R3) = s;
	msysc_printstrn_app(asu64(R3), asi64(R2), asu64(R1));
	goto L5603;
L5606:
	asi64(R1) = n;
	asu64(R2) = s;
	R3 = (u64)&qq_print_moutvar;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	goto L5603;
L5607:
	R1 = (u64)&qq_print_moutvar;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5611;
	R1 = tou64("prtstrn1");
	qq_lib_prterror(asu64(R1));
L5611:
	asi64(R1) = n;
	asu64(R2) = s;
	R3 = (u64)&qq_print_moutvar;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	goto L5603;
L5608:
	goto L5603;
L5609:
L5603:
L5598:
	return;
}

static void qq_print_pch_strtoval(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3, R4; 
	i64 fmtcode;
	i64 length;
	u8 oldmutable;
	u64 q;
	struct $B65 str;
	u64 s;
	R1 = (u64)&str;
	s = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1024;
	if (asi64(R1) >= asi64(R2)) goto L5614;
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asu64(R3) = q;
	R4 = 16;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5613;
L5614:
	R1 = tou64("");
	R2 = tou64("STRTOVAL/string too long");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L5613:
	asu64(R1) = fmt;
	asi64(R1) = qq_print_getreadfmtcode(asu64(R1));
	fmtcode = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5616;
	R1 = tou64("strval");
	qq_lib_prterror(asu64(R1));
L5616:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asi64(R1) = fmtcode;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L5618;
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L5619;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L5620;
	R2 = 78;
	if (asi64(R1) == asi64(R2)) goto L5621;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L5622;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L5623;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L5624;
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L5625;
	goto L5626;
L5618:
	R1 = 0;
	asu64(R2) = dest;
	asi64(R3) = length;
	asu64(R4) = s;
	asu64(R1) = qq_print_readint(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	goto L5617;
L5619:
	R1 = 1;
	asu64(R2) = dest;
	asi64(R3) = length;
	asu64(R4) = s;
	asu64(R1) = qq_print_readint(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	goto L5617;
L5620:
	asu64(R1) = dest;
	asi64(R2) = length;
	asu64(R3) = s;
	asu64(R1) = qq_print_readreal(asu64(R3), asi64(R2), asu64(R1));
	goto L5617;
L5621:
	asu64(R1) = dest;
	asi64(R2) = length;
	asu64(R3) = s;
	asu64(R1) = qq_print_readname(asu64(R3), asi64(R2), asu64(R1));
	goto L5617;
L5622:
	asu64(R1) = dest;
	asi64(R2) = length;
	asu64(R3) = s;
	asu64(R1) = qq_print_readstring(asu64(R3), asi64(R2), asu64(R1));
	goto L5617;
L5623:
	asu64(R1) = dest;
	asi64(R2) = length;
	asu64(R3) = s;
	asu64(R1) = qq_print_readhex(asu64(R3), asi64(R2), asu64(R1));
	goto L5617;
L5624:
	asu64(R1) = dest;
	asi64(R2) = length;
	asu64(R3) = s;
	asu64(R1) = qq_print_readbin(asu64(R3), asi64(R2), asu64(R1));
	goto L5617;
L5625:
	asu64(R1) = dest;
	asi64(R2) = length;
	asu64(R3) = s;
	asu64(R1) = qq_print_readany(asu64(R3), asi64(R2), asu64(R1));
	goto L5617;
L5626:
	R1 = tou64("strval:fmt?");
	qq_lib_prterror(asu64(R1));
L5617:
	return;
}

static void qq_print_tostr_int(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3, R4, R5; 
	struct $B65 str;
	asu64(R1) = fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 77;
	if (asu64(R1) == asu64(R2)) goto L5629;
	R2 = 68;
	if (asu64(R1) == asu64(R2)) goto L5629;
	R2 = 67;
	if (asu64(R1) == asu64(R2)) goto L5630;
	goto L5631;
L5629:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	R3 = 8;
	asu64(R4) = p;
	R5 = 8;
	R4 += (i64)R5;
	qq_print_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	goto L5628;
L5630:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5628;
L5631:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asu64(R3) = p;
	R4 = 8;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asi64(R1) = msysc_i64tostrfmt(asi64(R3), asu64(R2), asu64(R1));
L5628:
	asu64(R1) = fmt;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5633;
	R1 = 2;
	R2 = tou64("I:");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5633:
	R1 = (u64)&str;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&str;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_print_tostr_real(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3, R4; 
	struct $B65 str;
	struct $B65 str2;
	struct $B2 cfmt;
	i64 n;
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L5636;
	R1 = 46;
	R2 = (u64)&cfmt;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 42;
	R2 = (u64)&cfmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cfmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cfmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("v");
	asu64(R2) = fmt;
	R3 = 1;
	asi8(R2) = *toi8p(((i64)R2+(i64)R3));
	R2 = toi64(toi8(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = (u64)&cfmt;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
	goto L5635;
L5636:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("fmt");
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
L5635:
	R1 = (u64)&str;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) >= asi64(R2)) goto L5638;
	asu64(R1) = fmt;
	asi64(R2) = n;
	R3 = (u64)&str2;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&str2;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L5638:
	R1 = (u64)&str;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&str;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_print_tostr_str(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3, R4, R5; 
	i64 oldlen;
	i64 newlen;
	u64 s;
	struct $B5 str;
	u64 q;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	oldlen = asi64(R1);
	asi64(R1) = oldlen;
	newlen = asi64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5642;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = newlen;
	if (asi64(R1) <= asi64(R2)) goto L5641;
L5642:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5644;
	R1 = 2;
	R2 = (u64)&newlen;
	*toi64p(R2) += asi64(R1);
L5644:
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = newlen;
	if (asi64(R1) <= asi64(R2)) goto L5646;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	newlen = asi64(R1);
L5646:
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	s = asu64(R1);
	asu64(R1) = fmt;
	asi64(R2) = oldlen;
	asu64(R3) = s;
	asu64(R4) = q;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asi64(R1) = msysc_strtostrfmt(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = newlen;
	asu64(R2) = s;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = s;
	mlib_pcm_free(asu64(R2), asi64(R1));
	goto L5640;
L5641:
	asi64(R1) = oldlen;
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5640:
	return;
}

static void qq_print_pch_tostr(u64 a, u64 b, u64 result) {
    u64 R1, R2, R3; 
	struct $B3 fmt;
	u64 ifmt;
	u64 p;
	R1 = (u64)&fmt;
	asu64(R2) = b;
	asu64(R1) = qq_print_pc_getfmt(asu64(R2), asu64(R1));
	ifmt = asu64(R1);
	R1 = 0;
	asu64(R1) = qq_strings_obj_new_string(asi64(R1));
	p = asu64(R1);
	R1 = 0;
	qq_print_listdepth = asi64(R1);
	asu64(R1) = p;
	asu64(R2) = ifmt;
	asu64(R3) = a;
	qq_print_tostr(asu64(R3), asu64(R2), asu64(R1));
	R1 = 265;
	asu64(R2) = result;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = result;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_print_tostr_range(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3, R4, R5; 
	struct $B65 str;
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asu64(R3) = p;
	R4 = 0;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	R4 = 16;
	R5 = 63;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	asi64(R1) = msysc_i64tostrfmt(asi64(R3), asu64(R2), asu64(R1));
	R1 = tou64("..");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = -1;
	R2 = (u64)&str;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asu64(R3) = p;
	R4 = 8;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asi64(R1) = msysc_i64tostrfmt(asi64(R3), asu64(R2), asu64(R1));
	R1 = -1;
	R2 = (u64)&str;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_print_tostr_array(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3, R4; 
	struct $B65 str;
	u64 q;
	i64 i;
	i64 m;
	i64 elemtype;
	i64 a;
	i64 b;
	i64 lower;
	i64 length;
	struct $B3 v;
	u64 pa;
	u64 ptr;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	m = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L5651;
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asu64(R1) = pa;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	lower = asi64(R1);
	asu64(R1) = pa;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	goto L5650;
L5651:
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = pa;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	length = asi64(R1);
	R1 = (u64)&qq_tables_ttlower;
	asu64(R2) = pa;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	lower = asi64(R1);
	R1 = (u64)&qq_tables_tttarget;
	asu64(R2) = pa;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemtype = asi64(R1);
L5650:
	asi64(R1) = lower;
	a = asi64(R1);
	asi64(R1) = length;
	asi64(R2) = lower;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	b = asi64(R1);
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = fmt;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5653;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#[#:#]A");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_tables_ttname;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lower;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&qq_tables_ttname;
	asi64(R2) = elemtype;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = -1;
	R2 = (u64)&str;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5653:
	R1 = -1;
	R2 = tou64("(");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = a;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = b;
	if (asi64(R1) > asi64(R2)) goto L5656;
L5654:
	R1 = 0;
	R2 = (u64)&v;
	asi64(R3) = elemtype;
	asu64(R4) = q;
	qq_packed_var_loadpacked(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = elemtype;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&q;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = dest;
	asu64(R2) = fmt;
	R3 = (u64)&v;
	qq_print_tostr(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	asi64(R2) = b;
	if (asi64(R1) >= asi64(R2)) goto L5658;
	R1 = 1;
	R2 = tou64(",");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5658:
	i += 1; if (i <= b) goto L5654;
L5656:
	R1 = 1;
	R2 = tou64(")");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_print_tostr_bits(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3, R4, R5; 
	struct $B65 str;
	u64 q;
	i64 i;
	i64 m;
	i64 elemtype;
	i64 a;
	i64 b;
	i64 bitwidthx;
	i64 offset;
	struct $B3 v;
	u64 pa;
	u64 ptr;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	m = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = pa;
	R2 = 6;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	a = asi64(R1);
	asu64(R1) = pa;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = a;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	b = asi64(R1);
	R1 = (u64)&qq_tables_ttbitwidth;
	asi64(R2) = elemtype;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	bitwidthx = asi64(R1);
	asu64(R1) = pa;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = bitwidthx;
	asi64(R1) *= asi64(R2);
	offset = asi64(R1);
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = fmt;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5661;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#[#:#]A");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_tables_ttname;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pa;
	R2 = 6;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&qq_tables_ttname;
	asi64(R2) = elemtype;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = -1;
	R2 = (u64)&str;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5661:
	R1 = -1;
	R2 = tou64("(");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = a;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = b;
	if (asi64(R1) > asi64(R2)) goto L5664;
L5662:
	R1 = (u64)&v;
	R2 = 0;
	asi64(R3) = elemtype;
	asi64(R4) = offset;
	asu64(R5) = q;
	qq_vars_var_loadbit(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = bitwidthx;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = offset;
	R2 = 8;
	if (asi64(R1) < asi64(R2)) goto L5666;
	R1 = 0;
	offset = asi64(R1);
	R1 = (u64)&q;
	(*tou64p(R1)) += 1;
L5666:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	R3 = (u64)&v;
	qq_print_tostr(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	asi64(R2) = b;
	if (asi64(R1) >= asi64(R2)) goto L5668;
	R1 = 1;
	R2 = tou64(",");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5668:
	i += 1; if (i <= b) goto L5662;
L5664:
	R1 = 1;
	R2 = tou64(")");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_print_tostr_struct(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 q;
	i64 i;
	i64 m;
	i64 nfields;
	i64 needcomma;
	struct $B3 v;
	u64 pa;
	u64 ptr;
	u64 d;
	u64 r;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = pa;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	m = asi64(R1);
	R1 = (u64)&qq_tables_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	nfields = asi64(R1);
	R1 = 0;
	needcomma = asi64(R1);
	R1 = -1;
	R2 = tou64("(");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nfields;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5672;
L5670:
	R1 = 0;
	R2 = (u64)&v;
	asu64(R3) = r;
	asu64(R3) = *tou64p(R3);
	R4 = 116;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	asu64(R4) = pa;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R5) = r;
	asu64(R5) = *tou64p(R5);
	R6 = 108;
	asi16(R5) = *toi16p(((i64)R5+(i64)R6));
	R5 = toi64(toi16(R5));
	R4 += (i64)R5;
	qq_packed_var_loadpacked(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = needcomma;
	if (!asi64(R1)) goto L5674;
	R1 = -1;
	R2 = tou64(",");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5674:
	R1 = 1;
	needcomma = asi64(R1);
	asu64(R1) = dest;
	asu64(R2) = fmt;
	R3 = (u64)&v;
	qq_print_tostr(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&r;
	(*tou64p(R1)) += 8;
	i += 1; if (i <= nfields) goto L5670;
L5672:
	R1 = -1;
	R2 = tou64(")");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_print_tostr_set(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3, R4; 
	struct $B65 str;
	u64 q;
	i64 i;
	i64 j;
	i64 first;
	struct $B3 v;
	u64 s;
	asu64(R1) = fmt;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5677;
	R1 = (u64)&qq_print_defaultfmt;
	fmt = asu64(R1);
L5677:
	R1 = 1;
	R2 = tou64("[");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	R1 = 1;
	first = asi64(R1);
	R1 = 0;
	i = asi64(R1);
	goto L5679;
L5678:
	asi64(R1) = i;
	asu64(R2) = s;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_lib_testelem(asu64(R2), asi64(R1));
	if (!asi64(R1)) goto L5682;
	asi64(R1) = i;
	R2 = 1;
	asi64(R1) += asi64(R2);
	j = asi64(R1);
	goto L5684;
L5683:
	R1 = (u64)&j;
	(*toi64p(R1)) += 1;
L5684:
	asi64(R1) = j;
	asu64(R2) = s;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) >= asi64(R2)) goto L5686;
	asi64(R1) = j;
	asu64(R2) = s;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_lib_testelem(asu64(R2), asi64(R1));
	if (asi64(R1)) goto L5683;
L5686:
	R1 = (u64)&j;
	(*toi64p(R1)) -=1;
	asi64(R1) = first;
	if (asi64(R1)) goto L5688;
	R1 = 1;
	R2 = tou64(",");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5688:
	R1 = 0;
	first = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) != asi64(R2)) goto L5690;
	R1 = 1;
	R2 = (u64)&v;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = i;
	R2 = (u64)&v;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5689;
L5690:
	R1 = 4;
	R2 = (u64)&v;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = i;
	R2 = (u64)&v;
	R3 = 16;
	R4 = 63;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = j;
	R2 = (u64)&v;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5689:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	R3 = (u64)&v;
	qq_print_tostr(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = j;
	R2 = 1;
	asi64(R1) += asi64(R2);
	i = asi64(R1);
	goto L5681;
L5682:
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
L5681:
L5679:
	asi64(R1) = i;
	asu64(R2) = s;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) < asi64(R2)) goto L5678;
	R1 = 1;
	R2 = tou64("]");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_print_tostr_dict(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3; 
	struct $B65 str;
	u64 q;
	i64 i;
	i64 length;
	i64 needcomma;
	u64 pa;
	R1 = 0;
	needcomma = asi64(R1);
	asu64(R1) = fmt;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5693;
	R1 = (u64)&qq_print_defaultfmt;
	fmt = asu64(R1);
L5693:
	R1 = -1;
	R2 = tou64("[");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	asi64(R1) /= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5696;
L5694:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5698;
	R1 = 2;
	R2 = (u64)&q;
	*tou64p(R2) += asu64(R1)*16;
	goto L5695;
L5698:
	asi64(R1) = needcomma;
	if (!asi64(R1)) goto L5700;
	R1 = 1;
	R2 = tou64(",");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5700:
	R1 = 1;
	needcomma = asi64(R1);
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = q;
	qq_print_tostr(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
	R1 = 1;
	R2 = tou64(":");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = q;
	qq_print_tostr(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
L5695:
	i += -1; if (i >= 1) goto L5694;
L5696:
	R1 = 1;
	R2 = tou64("]");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_print_tostr_decimal(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3; 
	u64 s;
	R1 = 0;
	asu64(R2) = p;
	asu64(R1) = qq_decimal_var_tostr_dec(asu64(R2), asi64(R1));
	s = asu64(R1);
	R1 = -1;
	asu64(R2) = s;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = qq_decimal_decstrsize;
	asu64(R2) = s;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static void qq_print_tostr(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3, R4; 
	struct $B65 str;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5704;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5705;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5706;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5707;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5708;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5708;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5709;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5709;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5710;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5711;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5712;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5713;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5714;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5715;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5716;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L5717;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L5718;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L5719;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L5720;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L5721;
	goto L5722;
L5704:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = p;
	qq_print_tostr_int(asu64(R3), asu64(R2), asu64(R1));
	goto L5703;
L5705:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = p;
	qq_print_tostr_real(asu64(R3), asu64(R2), asu64(R1));
	goto L5703;
L5706:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = p;
	qq_print_tostr_str(asu64(R3), asu64(R2), asu64(R1));
	goto L5703;
L5707:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = p;
	qq_print_tostr_range(asu64(R3), asu64(R2), asu64(R1));
	goto L5703;
L5708:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = p;
	qq_print_tostr_list(asu64(R3), asu64(R2), asu64(R1));
	goto L5703;
L5709:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = p;
	qq_print_tostr_array(asu64(R3), asu64(R2), asu64(R1));
	goto L5703;
L5710:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = p;
	qq_print_tostr_bits(asu64(R3), asu64(R2), asu64(R1));
	goto L5703;
L5711:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = p;
	qq_print_tostr_set(asu64(R3), asu64(R2), asu64(R1));
	goto L5703;
L5712:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = p;
	qq_print_tostr_struct(asu64(R3), asu64(R2), asu64(R1));
	goto L5703;
L5713:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = p;
	qq_print_tostr_decimal(asu64(R3), asu64(R2), asu64(R1));
	goto L5703;
L5714:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = p;
	qq_print_tostr_dict(asu64(R3), asu64(R2), asu64(R1));
	goto L5703;
L5715:
	R1 = -1;
	R2 = tou64("<Void>");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	goto L5703;
L5716:
	asu64(R1) = fmt;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5724;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#<#>:");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5726;
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	goto L5725;
L5726:
	R1 = tou64("");
L5725:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = -1;
	R2 = (u64)&str;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5724:
// qq_print.tostr.showptr:
L5727:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5729;
	R1 = -1;
	R2 = tou64("nil");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	goto L5728;
L5729:
	R1 = -1;
	R2 = tou64("H");
	asu64(R3) = p;
	R4 = 8;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5728:
	goto L5703;
L5717:
	asu64(R1) = fmt;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5731;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#<#>:");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5733;
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	goto L5732;
L5733:
	R1 = tou64("");
L5732:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = -1;
	R2 = (u64)&str;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5731:
	goto L5727;
	goto L5703;
L5718:
	asu64(R1) = fmt;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5735;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#<#>(#,#):");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5737;
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	goto L5736;
L5737:
	R1 = tou64("");
L5736:
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = -1;
	R2 = (u64)&str;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5735:
	goto L5727;
	goto L5703;
L5719:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5739;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("<#:\"#\">");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_tables_namenames;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 124;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = -1;
	R2 = (u64)&str;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	goto L5738;
L5739:
	R1 = -1;
	R2 = tou64("<nil>");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5738:
	goto L5703;
L5720:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = -1;
	R2 = (u64)&str;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	goto L5703;
L5721:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("(#)");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_pcltabs_pclnames;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 1;
	R1 += (i64)R2;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = -1;
	R2 = (u64)&str;
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	goto L5703;
L5722:
	asu64(R1) = p;
	R2 = tou64("Tostr:");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L5703:
	return;
}

static void qq_print_tostr_list(u64 p, u64 fmt, u64 dest) {
    u64 R1, R2, R3; 
	u64 q;
	i64 i;
	i64 n;
	u8 c;
	u64 r;
	i64 av_1;
	R1 = (u64)&qq_print_listdepth;
	(*toi64p(R1)) += 1;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = r;
	R2 = 0;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L5743;
	asi64(R1) = qq_print_listdepth;
	R2 = 4;
	if (asi64(R1) <= asi64(R2)) goto L5742;
L5743:
	R1 = 3;
	R2 = tou64("...");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&qq_print_listdepth;
	(*toi64p(R1)) -=1;
	goto L5740;
L5742:
	asu64(R1) = r;
	R2 = 0;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asi64(R1) = -asi64(R1);
	asu64(R2) = r;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5745;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	goto L5744;
L5745:
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = r;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	n = asi64(R1);
L5744:
	asu64(R1) = fmt;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5747;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5750;
L5748:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = q;
	qq_print_tostr(asu64(R3), asu64(R2), asu64(R1));
	R1 = -1;
	R2 = tou64("\n");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L5748;
L5750:
	goto L5746;
L5747:
	R1 = 1;
	R2 = tou64("(");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = n;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5753;
L5751:
	asu64(R1) = dest;
	asu64(R2) = fmt;
	asu64(R3) = q;
	qq_print_tostr(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5755;
	R1 = 1;
	R2 = tou64(",");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5755:
	i += -1; if (i >= 1) goto L5751;
L5753:
	R1 = 1;
	R2 = tou64(")");
	asu64(R3) = dest;
	qq_print_addstring(asu64(R3), asu64(R2), asi64(R1));
L5746:
	asu64(R1) = r;
	R2 = 0;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asi64(R1) = -asi64(R1);
	asu64(R2) = r;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&qq_print_listdepth;
	(*toi64p(R1)) -=1;
L5740:
	return;
}

static void qq_records_var_make_record(u64 a, u64 dest, i64 n, i64 rectype) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 p;
	u64 b;
	i64 m;
	i64 av_1;
	R1 = 0;
	asi64(R2) = rectype;
	asu64(R1) = qq_records_obj_new_record(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = rectype;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	m = asi64(R1);
	asi64(R1) = n;
	asi64(R2) = m;
	if (asi64(R1) >= asi64(R2)) goto L5758;
	R1 = tou64("");
	R2 = tou64("Too few elements");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L5757;
L5758:
	asi64(R1) = n;
	asi64(R2) = m;
	if (asi64(R1) <= asi64(R2)) goto L5759;
	msysc_m$print_startcon();
	R1 = tou64("N=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("M=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = m;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("Too many elements");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L5759:
L5757:
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5762;
L5760:
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = b;
	*(struct $B3*)(R2) = (R1_B3);
	R1 = (u64)&a;
	(*tou64p(R1)) += 16;
	R1 = (u64)&b;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L5760;
L5762:
	R1 = 268;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = rectype;
	asu64(R2) = p;
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = p;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 qq_records_obj_new_record(i64 m, u64 defval) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 p;
	u64 a;
	i64 n;
	i64 av_1;
	i64 av_2;
	asu64(R1) = qq_vars_obj_new();
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	n = asi64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L5765;
	asi64(R1) = n;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	a = asu64(R2);
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = defval;
	if (!asu64(R1)) goto L5767;
	asu64(R1) = defval;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5767;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5770;
L5768:
	asu64(R1) = defval;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = a;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5772;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L5772:
	R1 = (u64)&a;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L5768;
L5770:
	goto L5766;
L5767:
	asi64(R1) = n;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5775;
L5773:
	R1 = 1;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&a;
	(*tou64p(R1)) += 16;
	if (--asi64(av_2)) goto L5773;
L5775:
L5766:
L5765:
	asu64(R1) = p;
	goto L5763;
L5763:
	return asu64(R1);
}

static void qq_records_obj_free_record(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	i64 av_1;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5779;
L5777:
	asu64(R1) = q;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5781;
	asu64(R1) = q;
	qq_vars_var_unshareu(asu64(R1));
L5781:
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L5777;
L5779:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L5783;
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L5783:
	asu64(R1) = p;
	mlib_pcm_free32(asu64(R1));
	return;
}

static void qq_records_var_dupl_record(u64 a) {
    u64 R1, R2, R3, R4; struct $B32 R1_B32; struct $B3 R1_B3; 
	u64 p;
	u64 q;
	u64 plist;
	u64 qlist;
	i64 length;
	i64 av_1;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = qq_vars_obj_new();
	q = asu64(R1);
	asu64(R1) = p;
	(R1_B32) = *(struct $B32*)(R1);
	asu64(R2) = q;
	*(struct $B32*)(R2) = (R1_B32);
	R1 = 1;
	asu64(R2) = q;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	asu64(R2) = q;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5786;
	goto L5784;
L5786:
	asi64(R1) = length;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	asu64(R3) = q;
	R4 = 8;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	qlist = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	plist = asu64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5789;
L5787:
	asu64(R1) = plist;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = qlist;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = qlist;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L5791;
	asu64(R1) = qlist;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5793;
	asu64(R1) = qlist;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L5793:
	goto L5790;
L5791:
	asu64(R1) = qlist;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5795;
	asu64(R1) = qlist;
	qq_vars_var_duplu(asu64(R1));
L5795:
L5790:
	R1 = (u64)&qlist;
	(*tou64p(R1)) += 16;
	R1 = (u64)&plist;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L5787;
L5789:
L5784:
	return;
}

static i64 qq_records_var_equal_record(u64 x, u64 y) {
    u64 R1, R2, R3; 
	i64 xlen;
	i64 ylen;
	i64 res;
	u64 px;
	u64 py;
	u64 a;
	u64 b;
	i64 av_1;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	py = asu64(R1);
	asu64(R1) = px;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = py;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	if (asi64(R1) == asi64(R2)) goto L5798;
	R1 = 0;
	goto L5796;
L5798:
	asu64(R1) = px;
	asu64(R2) = py;
	if (asu64(R1) != asu64(R2)) goto L5800;
	R1 = 1;
	goto L5796;
L5800:
	asu64(R1) = px;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = py;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = px;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5803;
L5801:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_vars_var_equal(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5805;
	R1 = 0;
	goto L5796;
L5805:
	R1 = (u64)&a;
	(*tou64p(R1)) += 16;
	R1 = (u64)&b;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L5801;
L5803:
	R1 = 1;
	goto L5796;
L5796:
	return asi64(R1);
}

static void qq_records_var_getix_record(u64 a, i64 index) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	u64 q;
	u64 offset;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asi64(R1) = index;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	offset = asu64(R1);
	asu64(R1) = offset;
	R2 = (u64)&qq_tables_ttlength;
	asu64(R3) = q;
	R4 = 6;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	if (asu64(R1) < asu64(R2)) goto L5808;
	R1 = tou64("");
	R2 = tou64("record[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L5808:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = offset;
	R1 += (i64)R2*16;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = a;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5810;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L5810:
	return;
}

static void qq_records_var_putix_record(u64 a, i64 index, u64 x) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	u64 dest;
	u64 q;
	u64 offset;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L5813;
	qq_lib_pcnotmut();
L5813:
	asi64(R1) = index;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	offset = asu64(R1);
	asu64(R1) = offset;
	R2 = (u64)&qq_tables_ttlength;
	asu64(R3) = q;
	R4 = 6;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	if (asu64(R1) < asu64(R2)) goto L5815;
	R1 = tou64("");
	R2 = tou64("rec[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L5815:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = offset;
	R1 += (i64)R2*16;
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5817;
	asu64(R1) = dest;
	qq_vars_var_unshareu(asu64(R1));
L5817:
	asu64(R1) = x;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = dest;
	*(struct $B3*)(R2) = (R1_B3);
	return;
}

static void qq_records_var_getixref_record(u64 a, i64 index, u64 dest) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	u64 offset;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asi64(R1) = index;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	offset = asu64(R1);
	asu64(R1) = offset;
	asu64(R2) = q;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L5820;
	R1 = tou64("");
	R2 = tou64("^rec[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L5820:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = offset;
	R1 += (i64)R2*16;
	p = asu64(R1);
	R1 = 14;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_resolve_rx_module(u64 pm) {
    u64 R1, R2; 
	asu64(R1) = pm;
	qq_decls_currmodule = asu64(R1);
	asu64(R1) = qq_decls_currmodule;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	qq_decls_stcurrmodule = asu64(R2);
	qq_decls_stcurrproc = asu64(R1);
	R1 = 0;
	qq_resolve_nprocs = asi64(R1);
	asu64(R1) = qq_decls_stcurrmodule;
	asu64(R2) = qq_decls_stprogram;
	qq_resolve_rx_passdef(asu64(R2), asu64(R1));
	asi64(R1) = qq_resolve_nprocs;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5823;
	asu64(R1) = qq_decls_currmodule;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = qq_decls_stcurrmodule;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	goto L5822;
L5823:
	asu64(R1) = qq_decls_currmodule;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5824;
	asu64(R1) = qq_decls_currmodule;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = qq_decls_stcurrmodule;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
L5824:
L5822:
	return;
}

static void qq_resolve_rx_passdef(u64 owner, u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = p;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5827;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5828;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5828;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5829;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L5830;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5830;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5830;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L5830;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5831;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5831;
	goto L5832;
L5827:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	qq_resolve_rx_deflist(asu64(R3), asu64(R2), asi64(R1));
	goto L5826;
L5828:
	R1 = (u64)&qq_resolve_nprocs;
	(*toi64p(R1)) += 1;
	asu64(R1) = p;
	asu64(R2) = owner;
	qq_resolve_fixmode(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	qq_resolve_rx_deflist(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = p;
	qq_decls_stcurrproc = asu64(R1);
	asu64(R1) = p;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = qq_decls_stcurrmodule;
	qq_decls_stcurrproc = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	qq_resolve_rx_deflist(asu64(R3), asu64(R2), asi64(R1));
	goto L5826;
L5829:
	asu64(R1) = p;
	asu64(R2) = owner;
	qq_resolve_fixmode(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	qq_resolve_rx_deflist(asu64(R3), asu64(R2), asi64(R1));
	goto L5826;
L5830:
	asu64(R1) = p;
	asu64(R2) = owner;
	qq_resolve_fixmode(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5834;
	asu64(R1) = p;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
L5834:
	goto L5826;
L5831:
	asu64(R1) = p;
	asu64(R2) = owner;
	qq_resolve_fixmode(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	qq_resolve_rx_deflist(asu64(R3), asu64(R2), asi64(R1));
	goto L5826;
L5832:
L5826:
	return;
}

static void qq_resolve_rx_deflist(u64 owner, u64 p, i64 doanon) {
    u64 R1, R2; 
	goto L5837;
L5836:
	asi64(R1) = doanon;
	if (!asi64(R1)) goto L5842;
	asu64(R1) = p;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5841;
L5842:
	asi64(R1) = doanon;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5840;
	asu64(R1) = p;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5840;
L5841:
	asu64(R1) = p;
	asu64(R2) = owner;
	qq_resolve_rx_passdef(asu64(R2), asu64(R1));
L5840:
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L5837:
	asu64(R1) = p;
	if (asu64(R1)) goto L5836;
	return;
}

static void qq_resolve_rx_unit(u64 owner, u64 p) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 a;
	u64 b;
	i64 n;
	i64 flags;
	i64 oldnoexpand;
	i64 oldsymbolmode;
	i64 nk;
	u64 pm;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	qq_decls_qpos = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L5845;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5846;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L5847;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L5848;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L5849;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L5849;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L5850;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L5850;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L5851;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L5852;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L5853;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L5854;
	goto L5855;
L5845:
	R1 = 0;
	asu64(R2) = p;
	asu64(R3) = owner;
	qq_resolve_resolvename(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L5857;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L5857;
	asi64(R1) = qq_resolve_noexpand;
	if (asi64(R1)) goto L5857;
	R1 = (u64)&qq_resolve_macrolevels;
	(*toi64p(R1)) += 1;
	R1 = 0;
	asu64(R2) = p;
	asu64(R3) = p;
	qq_resolve_expandmacro(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	R1 = (u64)&qq_resolve_macrolevels;
	(*toi64p(R1)) -=1;
L5857:
	goto L5844;
L5846:
	asu64(R1) = b;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	goto L5844;
L5847:
	asu64(R1) = p;
	asu64(R2) = owner;
	qq_resolve_resolvedot(asu64(R2), asu64(R1));
	goto L5844;
L5848:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L5859;
	asi64(R1) = qq_resolve_noexpand;
	oldnoexpand = asi64(R1);
	R1 = 1;
	qq_resolve_noexpand = asi64(R1);
	asu64(R1) = a;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asi64(R1) = oldnoexpand;
	qq_resolve_noexpand = asi64(R1);
	goto L5858;
L5859:
	asu64(R1) = a;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
L5858:
	asu64(R1) = b;
	asu64(R2) = owner;
	qq_resolve_rx_unitlist(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 34;
	if (asi64(R1) != asi64(R2)) goto L5861;
	R1 = 35;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = a;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 0;
	nk = asi64(R1);
	asu64(R1) = b;
	R2 = 88;
	asu64(R1) = qq_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	goto L5863;
L5862:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5866;
	R1 = (u64)&nk;
	(*toi64p(R1)) += 1;
	R1 = 4;
	asu64(R2) = b;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5866:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
L5863:
	asu64(R1) = b;
	if (asu64(R1)) goto L5862;
	asi64(R1) = nk;
	if (!asi64(R1)) goto L5868;
	asi64(R1) = nk;
	asi64(R2) = n;
	if (asi64(R1) == asi64(R2)) goto L5868;
	R1 = 0;
	R2 = tou64("Mixed key:value");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L5868:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5870;
	asi64(R1) = n;
	asi64(R1) = -asi64(R1);
	n = asi64(R1);
L5870:
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5860;
L5861:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L5871;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L5871;
	R1 = (u64)&qq_resolve_macrolevels;
	(*toi64p(R1)) += 1;
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_resolve_expandmacro(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	R1 = (u64)&qq_resolve_macrolevels;
	(*toi64p(R1)) -=1;
L5871:
L5860:
	goto L5844;
L5849:
	asu64(R1) = a;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = b;
	if (asu64(R1)) goto L5873;
	R1 = 0;
	R2 = tou64("Binop missing opnd");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L5873:
	asu64(R1) = b;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	qq_resolve_evalbinop(asu64(R3), asu64(R2), asu64(R1));
	goto L5844;
L5850:
	asu64(R1) = a;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = p;
	qq_resolve_evalmonop(asu64(R1));
	goto L5844;
L5851:
	R1 = 1;
	asu64(R2) = a;
	asu64(R3) = owner;
	qq_resolve_resolvename(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L5874;
	goto L5844;
L5852:
	asu64(R1) = a;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = p;
	qq_resolve_evalmonop(asu64(R1));
	goto L5844;
L5853:
	asi64(R1) = qq_resolve_noexpand;
	oldnoexpand = asi64(R1);
	asi64(R1) = qq_resolve_symbolmode;
	oldsymbolmode = asi64(R1);
	R1 = 1;
	qq_resolve_noexpand = asi64(R1);
	R1 = 1;
	qq_resolve_symbolmode = asi64(R1);
	asu64(R1) = a;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asi64(R1) = oldnoexpand;
	qq_resolve_noexpand = asi64(R1);
	asi64(R1) = oldsymbolmode;
	qq_resolve_symbolmode = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L5876;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L5877;
	goto L5878;
L5876:
	goto L5875;
L5877:
	R1 = (u64)&qq_tables_ttnamedef;
	asu64(R2) = a;
	R3 = 24;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L5880;
	asu64(R1) = d;
	asu64(R2) = a;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 39;
	asu64(R2) = a;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5879;
L5880:
	R1 = 0;
	R2 = tou64("T.$?");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L5879:
	goto L5875;
L5878:
	R1 = 0;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = a;
	qq_show_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = tou64(".$ not name");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L5875:
	goto L5844;
L5854:
	asu64(R1) = a;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L5882;
	R1 = 0;
	R2 = tou64("Not strconst");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L5882:
	R1 = 0;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_modules_loadsourcefile(asu64(R2), asi64(R1));
	pm = asu64(R1);
	asu64(R1) = pm;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pm;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = a;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = a;
	asu64(R2) = p;
	qq_lib_deleteunit(asu64(R2), asu64(R1));
	goto L5844;
L5855:
// qq_resolve.rx_unit.doabc:
L5874:
	R1 = (u64)&qq_tables_jflags;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	flags = asi64(R1);
	asi64(R1) = flags;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5884;
	asu64(R1) = a;
	asu64(R2) = owner;
	qq_resolve_rx_unitlist(asu64(R2), asu64(R1));
L5884:
	asi64(R1) = flags;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L5886;
	asu64(R1) = b;
	asu64(R2) = owner;
	qq_resolve_rx_unitlist(asu64(R2), asu64(R1));
L5886:
L5844:
	return;
}

static void qq_resolve_rx_unitlist(u64 owner, u64 p) {
    u64 R1, R2; 
	goto L5889;
L5888:
	asu64(R1) = p;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L5889:
	asu64(R1) = p;
	if (asu64(R1)) goto L5888;
	return;
}

static void qq_resolve_evalmonop(u64 p) {
    u64 R1, R2; 
	i64 a;
	i64 c;
	r64 x;
	r64 z;
	goto L5893;
L5893:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L5895;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L5896;
	goto L5897;
L5895:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 75;
	if (asi64(R1) == asi64(R2)) goto L5899;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L5900;
	goto L5901;
L5899:
	asi64(R1) = a;
	asi64(R1) = -asi64(R1);
	c = asi64(R1);
	goto L5898;
L5900:
	asi64(R1) = a;
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	c = asi64(R1);
	goto L5898;
L5901:
	goto L5891;
L5898:
// qq_resolve.evalmonop.newint:
	asi64(R1) = c;
	asu64(R2) = p;
	qq_resolve_makeintconst(asu64(R2), asi64(R1));
	goto L5894;
L5896:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	x = asr64(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 75;
	if (asi64(R1) == asi64(R2)) goto L5904;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L5905;
	goto L5906;
L5904:
	asr64(R1) = x;
	asr64(R1) = -asr64(R1);
	z = asr64(R1);
	goto L5903;
L5905:
	asr64(R1) = x;
	if (asr64(R1) < 0) asr64(R1) = -asr64(R1);
	z = asr64(R1);
	goto L5903;
L5906:
	goto L5891;
L5903:
	asr64(R1) = z;
	asu64(R2) = p;
	qq_resolve_makerealconst(asu64(R2), asr64(R1));
	goto L5894;
L5897:
	goto L5891;
L5894:
L5891:
	return;
}

static void qq_resolve_evalbinop(u64 p, u64 lhs, u64 rhs) {
    u64 R1, R2, R3; 
	i64 a;
	i64 b;
	i64 c;
	r64 x;
	r64 y;
	r64 z;
	asu64(R1) = lhs;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = rhs;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	R2 = 2687017;
	if (asi64(R1) == asi64(R2)) goto L5909;
	R2 = 2752554;
	if (asi64(R1) == asi64(R2)) goto L5910;
	goto L5911;
L5909:
	asu64(R1) = lhs;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asu64(R1) = rhs;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	b = asi64(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L5913;
	R2 = 102;
	if (asi64(R1) == asi64(R2)) goto L5914;
	R2 = 103;
	if (asi64(R1) == asi64(R2)) goto L5915;
	R2 = 105;
	if (asi64(R1) == asi64(R2)) goto L5916;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L5917;
	goto L5918;
L5913:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) += asi64(R2);
	c = asi64(R1);
	goto L5912;
L5914:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) -= asi64(R2);
	c = asi64(R1);
	goto L5912;
L5915:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) *= asi64(R2);
	c = asi64(R1);
	goto L5912;
L5916:
	asi64(R1) = b;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5920;
	R1 = 0;
	R2 = tou64("x/0");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L5920:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) /= asi64(R2);
	c = asi64(R1);
	goto L5912;
L5917:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) = Poweri64(asi64(R1), asi64(R2));
	c = asi64(R1);
	goto L5912;
L5918:
	goto L5907;
L5912:
	asi64(R1) = c;
	asu64(R2) = p;
	qq_resolve_makeintconst(asu64(R2), asi64(R1));
	goto L5908;
L5910:
	asu64(R1) = lhs;
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	x = asr64(R1);
	asu64(R1) = rhs;
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	y = asr64(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L5922;
	R2 = 102;
	if (asi64(R1) == asi64(R2)) goto L5923;
	R2 = 103;
	if (asi64(R1) == asi64(R2)) goto L5924;
	R2 = 104;
	if (asi64(R1) == asi64(R2)) goto L5925;
	goto L5926;
L5922:
	asr64(R1) = x;
	asr64(R2) = y;
	asr64(R1) += asr64(R2);
	z = asr64(R1);
	goto L5921;
L5923:
	asr64(R1) = x;
	asr64(R2) = y;
	asr64(R1) -= asr64(R2);
	z = asr64(R1);
	goto L5921;
L5924:
	asr64(R1) = x;
	asr64(R2) = y;
	asr64(R1) *= asr64(R2);
	z = asr64(R1);
	goto L5921;
L5925:
	asr64(R1) = x;
	asr64(R2) = y;
	asr64(R1) /= asr64(R2);
	z = asr64(R1);
	goto L5921;
L5926:
	goto L5907;
L5921:
	asr64(R1) = z;
	asu64(R2) = p;
	qq_resolve_makerealconst(asu64(R2), asr64(R1));
	goto L5908;
L5911:
	goto L5907;
L5908:
L5907:
	return;
}

static void qq_resolve_makeintconst(u64 p, i64 value) {
    u64 R1, R2, R3, R4; 
	R1 = 41;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = value;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	return;
}

static void qq_resolve_makerealconst(u64 p, r64 xvalue) {
    u64 R1, R2, R3, R4; 
	R1 = 42;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asr64(R1) = xvalue;
	asu64(R2) = p;
	R3 = 16;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	R1 = 2;
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	return;
}

static void qq_resolve_resolvename(u64 owner, u64 p, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	u64 f;
	u64 q;
	i64 moduleno;
	i64 n;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 24;
	R3 = 31;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	moduleno = asi64(R1);
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5931;
	goto L5929;
L5931:
	asi64(R1) = qq_resolve_allowmodname;
	asi64(R2) = moduleno;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = qq_resolve_resolvetopname(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (asu64(R1)) goto L5933;
	asu64(R1) = owner;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5935;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5935;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5936;
	goto L5937;
L5935:
	R1 = 0;
	R2 = 14;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R2 = R1;
	asu64(R3) = p;
	R4 = 16;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	e = asu64(R1);
	goto L5934;
L5936:
	R1 = 0;
	R2 = 13;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R2 = R1;
	asu64(R3) = p;
	R4 = 16;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	e = asu64(R1);
	goto L5934;
L5937:
	asu64(R1) = p;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Undefined: #");
	qq_lib_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L5934:
	goto L5932;
L5933:
// qq_resolve.resolvename.$else:
// qq_resolve.resolvename.retry:
	asu64(R1) = e;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L5941;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L5942;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5943;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5944;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5944;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L5945;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5946;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L5946;
	goto L5947;
L5941:
	asi64(R1) = qq_resolve_symbolmode;
	if (!asi64(R1)) goto L5949;
	goto L5929;
L5949:
	asu64(R1) = e;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L5951;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L5951;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L5951;
	R1 = 0;
	R2 = (u64)&qq_tables_jtagnames;
	asu64(R3) = q;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("Not const expr: #");
	qq_lib_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L5951:
	asu64(R1) = q;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 116;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = q;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = q;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5940;
L5942:
	asi64(R1) = qq_resolve_symbolmode;
	if (!asi64(R1)) goto L5953;
	goto L5929;
L5953:
	R1 = 41;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = e;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L5940;
L5943:
	goto L5940;
L5944:
	R1 = 34;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L5940;
L5945:
	asu64(R1) = p;
	R2 = tou64("FOUND LINK");
	qq_lib_rxerror(asu64(R2), asu64(R1));
	goto L5940;
L5946:
	asu64(R1) = qq_decls_stcurrproc;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5955;
	asu64(R1) = e;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5955;
	R1 = 0;
	R2 = tou64("Accessing transient vars from {}");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L5955:
	goto L5940;
L5947:
L5940:
L5932:
L5929:
	return;
}

static u64 qq_resolve_resolvetopname(u64 owner, u64 stnewname, i64 moduleno, i64 allowmod) {
    u64 R1, R2, R3; 
	i64 extcount;
	i64 subprogno;
	u64 p;
	u64 q;
	u64 powner;
	u64 d;
	u64 e;
	u64 extdef;
	u64 moddef;
	struct $B1 ambiglist;
	i64 i;
	asu64(R1) = owner;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5958;
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L5962;
L5959:
	asu64(R1) = q;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = stnewname;
	if (asu64(R1) != asu64(R2)) goto L5964;
	asu64(R1) = q;
	goto L5956;
L5964:
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5962:
	asu64(R1) = q;
	if (asu64(R1)) goto L5959;
	asu64(R1) = owner;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	owner = asu64(R1);
L5958:
	asu64(R1) = owner;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L5966;
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L5970;
L5967:
	asu64(R1) = q;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = stnewname;
	if (asu64(R1) != asu64(R2)) goto L5972;
	asu64(R1) = q;
	goto L5956;
L5972:
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5970:
	asu64(R1) = q;
	if (asu64(R1)) goto L5967;
L5966:
	asu64(R1) = stnewname;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = moduleno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	subprogno = asi64(R1);
	R1 = 0;
	extcount = asi64(R1);
	R1 = 0;
	R2 = R1;
	moddef = asu64(R2);
	extdef = asu64(R1);
	goto L5976;
L5973:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	powner = asu64(R1);
	asu64(R1) = powner;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5978;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5979;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5980;
	goto L5981;
L5978:
	asu64(R1) = powner;
	R2 = 114;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = moduleno;
	if (asi64(R1) != asi64(R2)) goto L5983;
	asu64(R1) = p;
	goto L5956;
	goto L5982;
L5983:
	asu64(R1) = p;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 1;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L5984;
	R1 = (u64)&qq_decls_modules;
	asu64(R2) = powner;
	R3 = 114;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = subprogno;
	if (asi64(R1) == asi64(R2)) goto L5987;
	asu64(R1) = p;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 1;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5987;
	asu64(R1) = p;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 2;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5986;
L5987:
	R1 = (u64)&extcount;
	(*toi64p(R1)) += 1;
	asu64(R1) = p;
	extdef = asu64(R1);
	asi64(R1) = extcount;
	R2 = 10;
	if (asi64(R1) >= asi64(R2)) goto L5989;
	asu64(R1) = extdef;
	R2 = (u64)&ambiglist;
	asi64(R3) = extcount;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L5989:
L5986:
L5984:
L5982:
	goto L5977;
L5979:
	asu64(R1) = powner;
	asu64(R2) = owner;
	if (asu64(R1) == asu64(R2)) goto L5992;
	asu64(R1) = powner;
	asu64(R2) = owner;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L5991;
L5992:
	asu64(R1) = p;
	goto L5956;
L5991:
	goto L5977;
L5980:
	asu64(R1) = p;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5994;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5994;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L5995;
	goto L5996;
L5994:
	asi64(R1) = allowmod;
	if (!asi64(R1)) goto L5998;
	asu64(R1) = p;
	moddef = asu64(R1);
L5998:
	goto L5993;
L5995:
	asu64(R1) = p;
	goto L5956;
	goto L5993;
L5996:
L5993:
	goto L5977;
L5981:
L5977:
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L5976:
	asu64(R1) = p;
	if (asu64(R1)) goto L5973;
	asu64(R1) = extdef;
	if (!asu64(R1)) goto L6000;
	asi64(R1) = extcount;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L6002;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = extcount;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6005;
L6003:
	R1 = (u64)&ambiglist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	extdef = asu64(R1);
	msysc_m$print_startcon();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = extdef;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_namenames;
	asu64(R2) = extdef;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 124;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= extcount) goto L6003;
L6005:
	R1 = 0;
	asu64(R2) = extdef;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Ambiguous ext name: #");
	qq_lib_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L6002:
	asu64(R1) = extdef;
	goto L5956;
L6000:
	asu64(R1) = moddef;
	goto L5956;
L5956:
	return asu64(R1);
}

static void qq_resolve_resolvedot(u64 owner, u64 p) {
    u64 R1, R2, R3, R4; 
	u64 qdef;
	u64 rdef;
	u64 d;
	u64 newd;
	u64 e;
	u64 fielddef;
	u64 q;
	u64 r;
	i64 nfields;
	i64 oldallowmod;
	asi64(R1) = qq_resolve_symbolmode;
	if (!asi64(R1)) goto L6008;
	asu64(R1) = p;
	asu64(R2) = owner;
	qq_resolve_resolvedot_sym(asu64(R2), asu64(R1));
	goto L6006;
L6008:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = r;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	rdef = asu64(R1);
	asi64(R1) = qq_resolve_allowmodname;
	oldallowmod = asi64(R1);
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	qq_resolve_allowmodname = asi64(R1);
	asu64(R1) = q;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asi64(R1) = oldallowmod;
	qq_resolve_allowmodname = asi64(R1);
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L6010;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L6011;
	goto L6012;
L6010:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L6009;
L6011:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L6013;
	goto L6009;
L6012:
	asu64(R1) = r;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	rdef = asu64(R1);
	goto L6014;
L6009:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6016;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6016;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6016;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6016;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6017;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6017;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L6017;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6017;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6017;
	goto L6018;
L6016:
// qq_resolve.resolvedot.dotype:
L6013:
	asu64(R1) = rdef;
	asu64(R2) = d;
	asu64(R1) = qq_resolve_finddupl(asu64(R2), asu64(R1));
	newd = asu64(R1);
	asu64(R1) = newd;
	if (!asu64(R1)) goto L6020;
	asu64(R1) = newd;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L6022;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6023;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6024;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6025;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6026;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6026;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L6027;
	goto L6028;
L6022:
	R1 = 41;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = newd;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L6021;
L6023:
	asu64(R1) = newd;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L6030;
	goto L6031;
L6030:
	R1 = 41;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = newd;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L6029;
L6031:
	asu64(R1) = p;
	R2 = tou64("Rxdot:const?");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L6029:
	goto L6021;
L6024:
	R1 = 34;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = newd;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 24;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = newd;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L6021;
L6025:
	R1 = 39;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = newd;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L6021;
L6026:
	R1 = 39;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = newd;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L6021;
L6027:
	asu64(R1) = e;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L6033;
	asi64(R1) = qq_resolve_noexpand;
	if (asi64(R1)) goto L6033;
	R1 = (u64)&qq_resolve_macrolevels;
	(*toi64p(R1)) += 1;
	R1 = 0;
	asu64(R2) = p;
	asu64(R3) = p;
	qq_resolve_expandmacro(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	R1 = (u64)&qq_resolve_macrolevels;
	(*toi64p(R1)) -=1;
L6033:
	goto L6021;
L6028:
	msysc_m$print_startcon();
	R1 = (u64)&qq_tables_namenames;
	asu64(R2) = newd;
	R3 = 124;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = newd;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = tou64("Rxdot:.name not allowed here");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L6021:
	goto L6019;
L6020:
	msysc_m$print_startcon();
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = rdef;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = tou64("Can't resolve");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L6019:
	goto L6015;
L6017:
// qq_resolve.resolvedot.doexprdot:
L6014:
	R1 = 0;
	nfields = asi64(R1);
	R1 = 0;
	fielddef = asu64(R1);
	asu64(R1) = rdef;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L6035;
L6034:
	asu64(R1) = e;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6038;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6038;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6038;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6038;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6038;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6038;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6038;
	goto L6039;
L6038:
	R1 = (u64)&nfields;
	(*toi64p(R1)) += 1;
	asu64(R1) = e;
	fielddef = asu64(R1);
	goto L6037;
L6039:
L6037:
	asu64(R1) = e;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L6035:
	asu64(R1) = e;
	if (asu64(R1)) goto L6034;
	asi64(R1) = nfields;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6041;
	goto L6042;
L6041:
	msysc_m$print_startcon();
	asu64(R1) = rdef;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Can't find field");
	qq_lib_rxerror(asu64(R2), asu64(R1));
	goto L6040;
L6042:
	asu64(R1) = rdef;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6044;
	R1 = 0;
	R2 = tou64("Field name not generic");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L6044:
L6040:
	goto L6015;
L6018:
	msysc_m$print_startcon();
	R1 = (u64)&qq_tables_namenames;
	asu64(R2) = d;
	R3 = 124;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = tou64("RXDOT:Unknown nameid");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L6015:
L6006:
	return;
}

static void qq_resolve_resolvedot_sym(u64 owner, u64 p) {
    u64 R1, R2, R3, R4; 
	u64 qdef;
	u64 rdef;
	u64 d;
	u64 newd;
	u64 e;
	u64 fielddef;
	u64 q;
	u64 r;
	i64 nfields;
	i64 oldallowmod;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = r;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	rdef = asu64(R1);
	asi64(R1) = qq_resolve_allowmodname;
	oldallowmod = asi64(R1);
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	qq_resolve_allowmodname = asi64(R1);
	asu64(R1) = q;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asi64(R1) = oldallowmod;
	qq_resolve_allowmodname = asi64(R1);
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L6047;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L6048;
	goto L6049;
L6047:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L6046;
L6048:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = qq_resolve_symbolmode;
	if (!asi64(R1)) goto L6051;
	asu64(R1) = rdef;
	asu64(R2) = d;
	asu64(R1) = qq_resolve_finddupl(asu64(R2), asu64(R1));
	newd = asu64(R1);
	asu64(R1) = newd;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6053;
	R1 = 0;
	asu64(R2) = rdef;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Can't resolve .");
	qq_lib_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L6053:
	asu64(R1) = newd;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6055;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6055;
	goto L6056;
L6055:
	msysc_m$print_startcon();
	R1 = tou64("*******FIELD.$");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L6054;
L6056:
	R1 = 0;
	R2 = (u64)&qq_tables_namenames;
	asu64(R3) = newd;
	R4 = 124;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64(".$ ON type:");
	qq_lib_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L6054:
L6051:
	goto L6057;
	goto L6046;
L6049:
	R1 = 0;
	R2 = tou64("RXDOTSYM?");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L6046:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6059;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6059;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6059;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6059;
	goto L6060;
L6059:
// qq_resolve.resolvedot_sym.dotype:
L6057:
	asu64(R1) = rdef;
	asu64(R2) = d;
	asu64(R1) = qq_resolve_finddupl(asu64(R2), asu64(R1));
	newd = asu64(R1);
	asu64(R1) = newd;
	if (!asu64(R1)) goto L6062;
	R1 = 39;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = newd;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L6061;
L6062:
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64(".$ Can't resolve");
	qq_lib_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L6061:
	goto L6058;
L6060:
	asu64(R1) = p;
	R2 = (u64)&qq_tables_namenames;
	asu64(R3) = d;
	R4 = 124;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("RX.$: Unknown nameid:");
	qq_lib_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L6058:
	return;
}

static u64 qq_resolve_finddupl(u64 d, u64 pdupl) {
    u64 R1, R2; 
	asu64(R1) = pdupl;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6065;
	asu64(R1) = pdupl;
	goto L6063;
L6065:
	asu64(R1) = pdupl;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdupl = asu64(R1);
	goto L6067;
L6066:
	asu64(R1) = pdupl;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L6070;
	asu64(R1) = pdupl;
	goto L6063;
L6070:
	asu64(R1) = pdupl;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdupl = asu64(R1);
L6067:
	asu64(R1) = pdupl;
	if (asu64(R1)) goto L6066;
	R1 = 0;
	goto L6063;
L6063:
	return asu64(R1);
}

static void qq_resolve_expandmacro(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 d;
	u64 pm;
	u64 pnew;
	i64 ignoreargs;
	asi64(R1) = qq_resolve_macrolevels;
	R2 = 10;
	if (asi64(R1) <= asi64(R2)) goto L6073;
	R1 = 0;
	R2 = tou64("Too many macro levels (recursive macro?)");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L6073:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	R1 = 0;
	qq_resolve_nmacroparams = asi64(R1);
	goto L6075;
L6074:
	asi64(R1) = qq_resolve_nmacroparams;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L6078;
	R1 = 0;
	R2 = tou64("macro param overflow");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L6078:
	asu64(R1) = pm;
	R2 = (u64)&qq_resolve_macroparams;
	R3 = (u64)&qq_resolve_nmacroparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pm;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_resolve_macroparamsgen;
	asi64(R3) = qq_resolve_nmacroparams;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pm;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
L6075:
	asu64(R1) = pm;
	if (asu64(R1)) goto L6074;
	R1 = 0;
	qq_resolve_nmacroargs = asi64(R1);
	goto L6080;
L6079:
	asi64(R1) = qq_resolve_nmacroargs;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L6083;
	R1 = 0;
	R2 = tou64("macro arg overflow");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L6083:
	asu64(R1) = b;
	R2 = (u64)&qq_resolve_macroargs;
	R3 = (u64)&qq_resolve_nmacroargs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
L6080:
	asu64(R1) = b;
	if (asu64(R1)) goto L6079;
	asi64(R1) = qq_resolve_nmacroargs;
	asi64(R2) = qq_resolve_nmacroparams;
	if (asi64(R1) >= asi64(R2)) goto L6085;
	R1 = 0;
	R2 = tou64("Too few macro args");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L6085:
	R1 = 0;
	ignoreargs = asi64(R1);
	asi64(R1) = qq_resolve_nmacroargs;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6087;
	asi64(R1) = qq_resolve_nmacroparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6087;
	R1 = 1;
	ignoreargs = asi64(R1);
	R1 = 0;
	R2 = R1;
	qq_resolve_nmacroparams = asi64(R2);
	qq_resolve_nmacroargs = asi64(R1);
	goto L6086;
L6087:
	asi64(R1) = qq_resolve_nmacroargs;
	asi64(R2) = qq_resolve_nmacroparams;
	if (asi64(R1) <= asi64(R2)) goto L6088;
	R1 = 0;
	R2 = tou64("Too many macro args");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L6088:
L6086:
	asu64(R1) = d;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_resolve_copyunit(asu64(R1));
	pnew = asu64(R1);
	asi64(R1) = ignoreargs;
	if (asi64(R1)) goto L6090;
	asu64(R1) = pnew;
	asu64(R2) = p;
	qq_resolve_replaceunit(asu64(R2), asu64(R1));
	goto L6089;
L6090:
	asu64(R1) = pnew;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6089:
	return;
}

static u64 qq_resolve_copylistunit(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	u64 plist;
	u64 plistx;
	R1 = 0;
	R2 = R1;
	plistx = asu64(R2);
	plist = asu64(R1);
	goto L6093;
L6092:
	asu64(R1) = p;
	asu64(R1) = qq_resolve_copyunit(asu64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = (u64)&plistx;
	R3 = (u64)&plist;
	qq_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L6093:
	asu64(R1) = p;
	if (asu64(R1)) goto L6092;
	asu64(R1) = plist;
	goto L6091;
L6091:
	return asu64(R1);
}

static u64 qq_resolve_copyunit(u64 p) {
    u64 R1, R2, R3; struct $B32 R1_B32; 
	u64 q;
	u64 d;
	i64 i;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6097;
	R1 = 0;
	goto L6095;
L6097:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L6099;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_resolve_nmacroparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6102;
L6100:
	R1 = (u64)&qq_resolve_macroparamsgen;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L6104;
	R1 = (u64)&qq_resolve_macroargs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = qq_resolve_copyunit(asu64(R1));
	goto L6095;
	goto L6102;
L6104:
	i += 1; if (i <= qq_resolve_nmacroparams) goto L6100;
L6102:
L6099:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R1) = qq_lib_createunit0(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	(R1_B32) = *(struct $B32*)(R1);
	asu64(R2) = q;
	*(struct $B32*)(R2) = (R1_B32);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&qq_tables_jflags;
	asu64(R2) = q;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6106;
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_resolve_copylistunit(asu64(R1));
	asu64(R2) = q;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&qq_tables_jflags;
	asu64(R2) = q;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6108;
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_resolve_copylistunit(asu64(R1));
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6108:
L6106:
	asu64(R1) = q;
	goto L6095;
L6095:
	return asu64(R1);
}

static void qq_resolve_replaceunit(u64 p, u64 q) {
    u64 R1, R2, R3; struct $B32 R1_B32; 
	u64 pnext;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pnext = asu64(R1);
	asu64(R1) = q;
	(R1_B32) = *(struct $B32*)(R1);
	asu64(R2) = p;
	*(struct $B32*)(R2) = (R1_B32);
	asu64(R1) = pnext;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_resolve_fixmode(u64 owner, u64 p) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	i64 m;
	asu64(R1) = p;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6112;
	goto L6110;
L6112:
	asi64(R1) = m;
	asi64(R1) = -asi64(R1);
	m = asi64(R1);
	R1 = (u64)&qq_tables_ttxmap;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L6114;
	R1 = (u64)&qq_tables_ttxmap;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 116;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L6110;
L6114:
	R1 = (u64)&qq_tables_ttnamedefx;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	R1 = 0;
	R2 = (u64)&qq_tables_ttxmoduleno;
	asi64(R3) = m;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = qq_resolve_resolvetopname(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L6116;
	asu64(R1) = e;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = (u64)&qq_tables_ttxmap;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asu64(R1) = e;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 116;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L6115;
L6116:
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Can't resolve type: #");
	qq_lib_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L6115:
L6110:
	return;
}

static i64 qq_resolve_fixmode2(u64 owner, i64 m) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	struct $B16 str;
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6119;
	asi64(R1) = m;
	goto L6117;
L6119:
	asi64(R1) = m;
	asi64(R1) = -asi64(R1);
	m = asi64(R1);
	R1 = (u64)&qq_tables_ttxmap;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L6121;
	R1 = (u64)&qq_tables_ttxmap;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	goto L6117;
L6121:
	R1 = (u64)&qq_tables_ttnamedefx;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = owner;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6123;
	R1 = 0;
	R2 = tou64("FM2/owner");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L6123:
	R1 = 0;
	R2 = (u64)&qq_tables_ttxmoduleno;
	asi64(R3) = m;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = qq_resolve_resolvetopname(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L6125;
	asu64(R1) = e;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = (u64)&qq_tables_ttxmap;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asu64(R1) = e;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	goto L6117;
	goto L6124;
L6125:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("# in module #, line:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_decls_modules;
	R2 = (u64)&qq_tables_ttxmoduleno;
	asi64(R3) = m;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = (u64)&str;
	R3 = tou64("2:Can't resolve type: #");
	qq_lib_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L6124:
	R1 = 0;
	goto L6117;
L6117:
	return asi64(R1);
}

static void qq_resolve_fixusertypes() {
    u64 R1, R2, R3; 
	u64 p;
	u64 pmode;
	i64 m;
	i64 rescan;
	i64 i;
	R1 = 1;
	i = asi64(R1);
L6127:
	asu64(R1) = qq_tables_userxmodelist;
	p = asu64(R1);
	R1 = 0;
	rescan = asi64(R1);
	goto L6131;
L6130:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi16(R1) = *toi16p(R1);
	R1 = toi64(toi16(R1));
	m = asi64(R1);
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L6134;
	asi64(R1) = m;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_resolve_fixmode2(asu64(R2), asi64(R1));
	m = asi64(R1);
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L6136;
	asi64(R1) = i;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6136;
	R1 = (u64)&qq_tables_ttxmap;
	asi64(R2) = m;
	if (asi64(R2) < 0) asi64(R2) = -asi64(R2);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L6136;
	R1 = (u64)&qq_tables_ttxmap;
	asi64(R2) = m;
	if (asi64(R2) < 0) asi64(R2) = -asi64(R2);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	m = asi64(R1);
L6136:
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L6138;
	R1 = 1;
	rescan = asi64(R1);
	goto L6137;
L6138:
	asi64(R1) = m;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*toi16p(R2) = asi16(R1);
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asi64(R2) = m;
	if (asi64(R1) != asi64(R2)) goto L6140;
	R1 = 0;
	R2 = (u64)&qq_tables_ttname;
	asi64(R3) = m;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("recursive type?");
	qq_lib_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L6140:
L6137:
L6134:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L6131:
	asu64(R1) = p;
	if (asu64(R1)) goto L6130;
	asi64(R1) = rescan;
	if (asi64(R1)) goto L6142;
	goto L6129;
L6142:
	i += 1; if (i <= 2) goto L6127;
L6129:
	asi64(R1) = rescan;
	if (!asi64(R1)) goto L6144;
	R1 = 0;
	R2 = tou64("FUT Phase Error");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L6144:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nbaseclasses;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6147;
L6145:
	asi64(R1) = i;
	qq_resolve_dobaseclass(asi64(R1));
	i += 1; if (i <= qq_decls_nbaseclasses) goto L6145;
L6147:
	return;
}

static void qq_resolve_tx_typetable() {
    u64 R1, R2; 
	i64 i;
	R1 = 41;
	i = asi64(R1);
	asi64(R1) = qq_tables_ntypes;
	R2 = 41;
	if (asi64(R1) < asi64(R2)) goto L6151;
L6149:
	asi64(R1) = i;
	qq_resolve_converttype(asi64(R1));
	i += 1; if (i <= qq_tables_ntypes) goto L6149;
L6151:
	return;
}

static i64 qq_resolve_getconstint(u64 owner, u64 a, i64 ownerid) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	asu64(R2) = owner;
	qq_resolve_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L6154;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L6155;
	goto L6156;
L6154:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L6152;
	goto L6153;
L6155:
	asu64(R1) = a;
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = toi64(asr64(R1));
	goto L6152;
	goto L6153;
L6156:
	R1 = 0;
	R2 = (u64)&qq_tables_jtagnames;
	asu64(R3) = a;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("Getconstint: not int/real");
	qq_lib_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L6153:
	R1 = 0;
	goto L6152;
L6152:
	return asi64(R1);
}

static void qq_resolve_converttype(i64 m) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	u64 d;
	u64 f;
	u64 owner;
	i64 first;
	i64 a;
	i64 b;
	i64 index;
	i64 length;
	i64 lower;
	i64 elemtype;
	i64 nbits;
	struct $B78 fieldlist;
	i64 oldmodno;
	i64 pos;
	i64 ownerid;
	i64 maxalign;
	i64 nfields;
	i64 size;
	u64 plength;
	u64 plower;
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L6159;
	goto L6157;
L6159:
	R1 = (u64)&qq_tables_ttowner;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	owner = asu64(R1);
	R1 = (u64)&qq_tables_ttlowerexpr;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	plower = asu64(R1);
	R1 = (u64)&qq_tables_ttlengthexpr;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	plength = asu64(R1);
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L6161;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L6161;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6162;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6163;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6164;
	goto L6165;
L6161:
	R1 = 0;
	asu64(R2) = plength;
	asu64(R3) = owner;
	asi64(R1) = qq_resolve_getconstint(asu64(R3), asu64(R2), asi64(R1));
	R2 = R1;
	R3 = (u64)&qq_tables_ttlength;
	asi64(R4) = m;
	*toi64p(((i64)R3+(i64)R4*8)) = asi64(R2);
	R2 = (u64)&qq_tables_ttsize;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	goto L6160;
L6162:
	asi64(R1) = m;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L6167;
	msysc_m$print_startcon();
	R1 = tou64("CT:ARRAY/ARRAY");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L6167:
	R1 = (u64)&qq_tables_ttowner;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (!asu64(R1)) goto L6169;
	R1 = (u64)&qq_tables_ttowner;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	ownerid = asi64(R1);
	goto L6168;
L6169:
	R1 = 0;
	ownerid = asi64(R1);
L6168:
	asu64(R1) = plower;
	if (!asu64(R1)) goto L6171;
	asi64(R1) = ownerid;
	asu64(R2) = plower;
	asu64(R3) = owner;
	asi64(R1) = qq_resolve_getconstint(asu64(R3), asu64(R2), asi64(R1));
	R2 = (u64)&qq_tables_ttlower;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	goto L6170;
L6171:
	R1 = 1;
	R2 = (u64)&qq_tables_ttlower;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
L6170:
	asu64(R1) = plength;
	if (!asu64(R1)) goto L6173;
	asi64(R1) = ownerid;
	asu64(R2) = plength;
	asu64(R3) = owner;
	asi64(R1) = qq_resolve_getconstint(asu64(R3), asu64(R2), asi64(R1));
	R2 = (u64)&qq_tables_ttlength;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	goto L6172;
L6173:
	R1 = 0;
	R2 = (u64)&qq_tables_ttlength;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
L6172:
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemtype = asi64(R1);
	asi64(R1) = elemtype;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L6175;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L6175;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L6175;
	goto L6176;
L6175:
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&qq_tables_ttbitwidth;
	R3 = (u64)&qq_tables_tttarget;
	asi64(R4) = m;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) *= asi64(R2);
	nbits = asi64(R1);
	asi64(R1) = nbits;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = 8;
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&qq_tables_ttsize;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	goto L6174;
L6176:
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	qq_resolve_converttype(asi64(R1));
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&qq_tables_ttsize;
	R3 = (u64)&qq_tables_tttarget;
	asi64(R4) = m;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	R2 = (u64)&qq_tables_ttsize;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
L6174:
	goto L6160;
L6163:
	R1 = (u64)&qq_tables_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	f = asu64(R1);
	R1 = 0;
	nfields = asi64(R1);
	goto L6178;
L6177:
	asi64(R1) = nfields;
	R2 = 256;
	if (asi64(R1) < asi64(R2)) goto L6181;
	R1 = 0;
	R2 = tou64("Too many fields");
	qq_lib_rxerror(asu64(R2), asu64(R1));
L6181:
	asu64(R1) = f;
	R2 = (u64)&fieldlist;
	R3 = (u64)&nfields;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = f;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	f = asu64(R1);
L6178:
	asu64(R1) = f;
	if (asu64(R1)) goto L6177;
	R1 = 0;
	R2 = (u64)&fieldlist;
	asi64(R3) = nfields;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 0;
	R2 = R1;
	qq_resolve_nallfields = asi64(R2);
	qq_resolve_ntopfields = asi64(R1);
	R1 = 1;
	maxalign = asi64(R1);
	R1 = 1;
	index = asi64(R1);
	R1 = 2;
	R2 = (u64)&maxalign;
	R3 = (u64)&qq_tables_ttcaligned;
	asi64(R4) = m;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	R4 = 0;
	R5 = (u64)&size;
	R6 = (u64)&index;
	R7 = (u64)&fieldlist;
	R8 = 1;
	qq_resolve_scanstruct(asi64(R8), asu64(R7), asu64(R6), asu64(R5), asi64(R4), asi64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&qq_tables_ttcaligned;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6183;
	asi64(R1) = maxalign;
	asi64(R2) = size;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	size = asi64(R1);
	asi64(R1) = maxalign;
	asu64(R2) = d;
	R3 = 106;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L6182;
L6183:
	R1 = 1;
	asu64(R2) = d;
	R3 = 106;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L6182:
	asi64(R1) = size;
	R2 = (u64)&qq_tables_ttsize;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_ttlower;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asi64(R1) = qq_resolve_ntopfields;
	R2 = (u64)&qq_tables_ttlength;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = 8;
	asi64(R2) = qq_resolve_ntopfields;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = d;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 8;
	asi64(R2) = qq_resolve_ntopfields;
	asu64(R1) *= asu64(R2);
	R2 = (u64)&qq_resolve_structfields;
	asu64(R3) = d;
	R4 = 88;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L6160;
L6164:
	goto L6160;
L6165:
	msysc_m$print_startcon();
	R1 = tou64("CAN'T DO:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asi64(R2) = m;
	asu64(R1) = qq_show_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	R2 = (u64)&qq_tables_ttbasetype;
	asi64(R3) = m;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu64(R1) = qq_show_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L6160:
L6157:
	return;
}

static void qq_resolve_scanstruct(i64 smode, u64 fields, u64 index, u64 isize, i64 offset, i64 calign, u64 maxalign, i64 countmode) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	u64 f;
	i64 newoffset;
	i64 fieldsize;
	i64 alignment;
	i64 nfields;
	i64 structmode;
	i64 ndepth;
	i64 size;
	R1 = 0;
	size = asi64(R1);
	goto L6186;
L6185:
	asu64(R1) = f;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6189;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L6190;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L6191;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L6192;
	goto L6193;
L6189:
	asu64(R1) = f;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	qq_resolve_converttype(asi64(R1));
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = f;
	R3 = 116;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	fieldsize = asi64(R1);
	asi64(R1) = calign;
	if (!asi64(R1)) goto L6195;
	asu64(R1) = f;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asi64(R1) = qq_names_getalignment(asi64(R1));
	alignment = asi64(R1);
	asi64(R1) = alignment;
	asu64(R2) = maxalign;
    *toi64p(R2) = Max(*toi64p(R2), asi64(R1));
	asi64(R1) = alignment;
	asi64(R2) = offset;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	newoffset = asi64(R1);
	asi64(R1) = newoffset;
	asi64(R2) = offset;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	goto L6194;
L6195:
	asi64(R1) = offset;
	newoffset = asi64(R1);
L6194:
	asi64(R1) = newoffset;
	asu64(R2) = f;
	R3 = 108;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = index;
	asi64(R1) = *toi64p(R1);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = f;
	R3 = 96;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = newoffset;
	offset = asi64(R1);
// qq_resolve.scanstruct.countfields:
	R1 = (u64)&qq_resolve_nallfields;
	(*toi64p(R1)) += 1;
	asi64(R1) = countmode;
	if (!asi64(R1)) goto L6198;
	asu64(R1) = f;
	R2 = (u64)&qq_resolve_structfields;
	R3 = (u64)&qq_resolve_ntopfields;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L6198:
	goto L6188;
L6190:
	asi64(R1) = countmode;
	asu64(R2) = maxalign;
	asi64(R3) = calign;
	asi64(R4) = offset;
	R5 = (u64)&fieldsize;
	asu64(R6) = index;
	asu64(R7) = fields;
	R8 = 1;
	qq_resolve_scanstruct(asi64(R8), asu64(R7), asu64(R6), asu64(R5), asi64(R4), asi64(R3), asu64(R2), asi64(R1));
	goto L6188;
L6191:
	asi64(R1) = countmode;
	if (!asi64(R1)) goto L6200;
	R1 = 1;
	goto L6199;
L6200:
	R1 = 0;
L6199:
	asu64(R2) = maxalign;
	asi64(R3) = calign;
	asi64(R4) = offset;
	R5 = (u64)&fieldsize;
	asu64(R6) = index;
	asu64(R7) = fields;
	R8 = 0;
	qq_resolve_scanstruct(asi64(R8), asu64(R7), asu64(R6), asu64(R5), asi64(R4), asi64(R3), asu64(R2), asi64(R1));
	goto L6188;
L6192:
	asi64(R1) = size;
	asu64(R2) = isize;
	*toi64p(R2) = asi64(R1);
	goto L6184;
	goto L6188;
L6193:
L6188:
	asi64(R1) = smode;
	if (!asi64(R1)) goto L6202;
	asi64(R1) = fieldsize;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = fieldsize;
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	goto L6201;
L6202:
	asi64(R1) = size;
	asi64(R2) = fieldsize;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	size = asi64(R1);
	R1 = 0;
	countmode = asi64(R1);
L6201:
L6186:
	asu64(R1) = fields;
	asu64(R2) = index;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) += 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = R1;
	f = asu64(R2);
	if (asu64(R1)) goto L6185;
	asi64(R1) = size;
	asu64(R2) = isize;
	*toi64p(R2) = asi64(R1);
L6184:
	return;
}

static void qq_resolve_dobaseclass(i64 baseclassindex) {
    u64 R1, R2, R3, R4; 
	u64 sttype;
	u64 d;
	u64 e;
	u64 newd;
	i64 baseclass;
	i64 normalexit;
	R1 = (u64)&qq_decls_baseclasstable;
	asi64(R2) = baseclassindex;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	baseclass = asi64(R1);
	R1 = (u64)&qq_decls_baseclassdef;
	asi64(R2) = baseclassindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	sttype = asu64(R1);
	R1 = (u64)&qq_tables_ttnamedef;
	asi64(R2) = baseclass;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L6205;
L6204:
	asu64(R1) = sttype;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 1;
	normalexit = asi64(R1);
	goto L6208;
L6207:
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L6211;
	R1 = 0;
	normalexit = asi64(R1);
	goto L6209;
L6211:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L6208:
	asu64(R1) = e;
	if (asu64(R1)) goto L6207;
L6209:
	asi64(R1) = normalexit;
	if (!asi64(R1)) goto L6213;
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6215;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L6215;
	goto L6216;
L6215:
	R1 = 0;
	R2 = 21;
	asu64(R3) = d;
	R4 = 48;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = sttype;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	newd = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = newd;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L6214;
L6216:
	R1 = 0;
	asu64(R2) = d;
	R3 = 124;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = d;
	R4 = 48;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = sttype;
	asu64(R1) = qq_names_addsymbol(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	newd = asu64(R1);
	asu64(R1) = newd;
	asu64(R2) = d;
	qq_names_duplfield(asu64(R2), asu64(R1));
	asu64(R1) = sttype;
	R2 = 104;
	R1 += (i64)R2;
	(*toi16p(R1)) += 1;
	asu64(R1) = sttype;
	R2 = 104;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = (u64)&qq_tables_ttlength;
	asu64(R3) = sttype;
	R4 = 116;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asu64(R1) = sttype;
	R2 = 104;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = newd;
	R3 = 96;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = newd;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = newd;
	R3 = 108;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L6214:
	asu64(R1) = newd;
	qq_names_addgenfield(asu64(R1));
L6213:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L6205:
	asu64(R1) = d;
	if (asu64(R1)) goto L6204;
	return;
}

static void qq_runx_disploop() {
    u64 R1, R2, R3, R4, R5, R6; struct $B3 R1_B3; 
	u64 pc;
	u64 sp;
	u64 fp;
	u64 x;
	u64 y;
	u64 z;
	i64 n;
	i64 index;
	u64 dest;
	u64 px;
	u64 d;
	i64 nloc;
	u64 pz;
	u64 pp;
	u64 q;
	u64 g;
	i64 xt;
	i64 yt;
	i64 res;
	i64 lower;
	i64 upper;
	i64 moduleno;
	i64 offset;
	u64 newsp;
	u64 e;
	u64 localjumptable;
	struct $B3 vx;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 av_4;
// PROC LOCAL STATICS GO HERE
	static i64 qq_runx_disploop_count = 100;
	asu8(R1) = qq_runx_getjt;
	if (!asu8(R1)) goto L6219;
	asu64(R1) = localjumptable;
	qq_runx_jumptable = asu64(R1);
	goto L6217;
L6219:
	asu64(R1) = qq_decls_sptr;
	sp = asu64(R1);
	asu64(R1) = qq_decls_pcptr;
	pc = asu64(R1);
	asu64(R1) = qq_decls_frameptr;
	fp = asu64(R1);
L6220:
	asu64(R1) = pc;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 0: goto L6224;
	case 1: goto L6225;
	case 2: goto L6227;
	case 3: goto L6228;
	case 4: goto L6232;
	case 5: goto L6233;
	case 6: goto L6234;
	case 7: goto L6235;
	case 8: goto L6238;
	case 9: goto L6243;
	case 10: goto L6245;
	case 11: goto L6253;
	case 12: goto L6247;
	case 13: goto L6250;
	case 14: goto L6254;
	case 15: goto L6257;
	case 16: goto L6258;
	case 17: goto L6259;
	case 18: goto L6260;
	case 19: goto L6261;
	case 20: goto L6262;
	case 21: goto L6263;
	case 22: goto L6264;
	case 23: goto L6278;
	case 24: goto L6286;
	case 25: goto L6287;
	case 26: goto L6288;
	case 27: goto L6291;
	case 28: goto L6294;
	case 29: goto L6297;
	case 30: goto L6298;
	case 31: goto L6299;
	case 32: goto L6302;
	case 33: goto L6311;
	case 34: goto L6320;
	case 35: goto L6327;
	case 36: goto L6334;
	case 37: goto L6344;
	case 38: goto L6351;
	case 39: goto L6358;
	case 40: goto L6425;
	case 41: goto L6436;
	case 42: goto L6448;
	case 43: goto L6449;
	case 44: goto L6454;
	case 45: goto L6456;
	case 46: goto L6459;
	case 47: goto L6461;
	case 48: goto L6464;
	case 49: goto L6466;
	case 50: goto L6469;
	case 51: goto L6470;
	case 52: goto L6477;
	case 53: goto L6489;
	case 54: goto L6490;
	case 55: goto L6491;
	case 56: goto L6492;
	case 57: goto L6493;
	case 58: goto L6494;
	case 59: goto L6870;
	case 60: goto L6500;
	case 61: goto L6501;
	case 62: goto L6502;
	case 63: goto L6503;
	case 64: goto L6504;
	case 65: goto L6505;
	case 66: goto L6506;
	case 67: goto L6507;
	case 68: goto L6514;
	case 69: goto L6515;
	case 70: goto L6522;
	case 71: goto L6523;
	case 72: goto L6525;
	case 73: goto L6534;
	case 74: goto L6535;
	case 75: goto L6536;
	case 76: goto L6539;
	case 77: goto L6542;
	case 78: goto L6545;
	case 79: goto L6550;
	case 80: goto L6553;
	case 81: goto L6559;
	case 82: goto L6562;
	case 83: goto L6567;
	case 84: goto L6568;
	case 85: goto L6569;
	case 86: goto L6570;
	case 87: goto L6571;
	case 88: goto L6572;
	case 89: goto L6573;
	case 90: goto L6575;
	case 91: goto L6583;
	case 92: goto L6586;
	case 93: goto L6589;
	case 94: goto L6596;
	case 95: goto L6599;
	case 96: goto L6600;
	case 97: goto L6601;
	case 98: goto L6611;
	case 99: goto L6614;
	case 100: goto L6619;
	case 101: goto L6620;
	case 102: goto L6629;
	case 103: goto L6637;
	case 104: goto L6645;
	case 105: goto L6652;
	case 106: goto L6659;
	case 107: goto L6664;
	case 108: goto L6668;
	case 109: goto L6675;
	case 110: goto L6682;
	case 111: goto L6689;
	case 112: goto L6696;
	case 113: goto L6703;
	case 114: goto L6708;
	case 115: goto L6713;
	case 116: goto L6718;
	case 117: goto L6725;
	case 118: goto L6732;
	case 119: goto L6735;
	case 120: goto L6738;
	case 121: goto L6745;
	case 122: goto L6750;
	case 123: goto L6781;
	case 124: goto L6782;
	case 125: goto L6787;
	case 126: goto L6783;
	case 127: goto L6791;
	case 128: goto L6800;
	case 129: goto L6813;
	case 130: goto L6814;
	case 131: goto L6821;
	case 132: goto L6832;
	case 133: goto L6838;
	case 134: goto L6839;
	case 135: goto L6840;
	case 136: goto L6841;
	case 137: goto L6848;
	case 138: goto L6859;
	case 139: goto L6864;
	case 140: goto L6865;
	case 141: goto L6866;
	case 142: goto L6869;
	case 143: goto L6876;
	case 144: goto L6871;
	case 145: case 146: case 147: case 151: case 152: case 153: case 154: case 156: case 157: case 158: case 159: case 175: case 189: case 196: case 197: goto L6223;
	case 148: goto L6883;
	case 149: goto L6886;
	case 150: goto L6916;
	case 155: goto L6913;
	case 160: goto L6365;
	case 161: goto L6370;
	case 162: goto L6375;
	case 163: goto L6380;
	case 164: goto L6385;
	case 165: goto L6390;
	case 166: goto L6395;
	case 167: goto L6400;
	case 168: goto L6405;
	case 169: goto L6410;
	case 170: goto L6415;
	case 171: goto L6420;
	case 172: goto L6892;
	case 173: goto L6895;
	case 174: goto L6889;
	case 176: goto L6898;
	case 177: goto L6901;
	case 178: goto L6904;
	case 179: goto L6907;
	case 180: goto L6910;
	case 181: goto L6757;
	case 182: goto L6764;
	case 183: goto L6769;
	case 184: goto L6772;
	case 185: goto L6775;
	case 186: goto L6778;
	case 187: goto L6927;
	case 188: goto L6921;
	case 190: goto L6277;
	case 191: goto L6941;
	case 192: goto L6946;
	case 193: goto L6953;
	case 194: goto L6958;
	case 195: goto L6938;
	case 198: goto L6965;
	case 199: goto L6928;
	case 200: goto L6933;
	case 201: goto L6968;
	default: goto L6223;
    };
// SWITCH
L6224:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6225:
	goto L6226;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6227:
	goto L6226;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6228:
	asu64(R1) = pc;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6231;
L6229:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 0;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	if (--asi64(av_1)) goto L6229;
L6231:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6232:
	goto L6226;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6233:
	goto L6226;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6234:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6235:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6237;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6237:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6238:
// qq_runx.disploop.jpushf:
L6239:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6241;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6241:
// qq_runx.disploop.freddy:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6243:
// qq_runx.disploop.jpushmref:
L6244:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 14;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6245:
// qq_runx.disploop.jpushfref:
L6246:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 14;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6247:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6249;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6249:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6250:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6252;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6252:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6253:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 16;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = sp;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6254:
// qq_runx.disploop.jpushci:
L6255:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
// qq_runx.disploop.jpushcix:
	goto L6220;
L6257:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 0;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6258:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 16;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = sp;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6259:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 2;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6260:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 265;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6261:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 18;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6262:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 19;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6263:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 17;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6264:
	asu64(R1) = sp;
	x = asu64(R1);
// qq_runx.disploop.jpushptr:
L6265:
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6267;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L6268;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L6269;
	goto L6270;
L6267:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = sp;
	*(struct $B3*)(R2) = (R1_B3);
	goto L6266;
L6268:
	asu64(R1) = x;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6272;
	goto L6273;
L6272:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6274;
	goto L6271;
L6273:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	R1 = 0;
	asu64(R2) = sp;
	asu64(R3) = x;
	R4 = 4;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	asu64(R4) = x;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	qq_packed_var_loadpacked(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
L6271:
	goto L6266;
L6269:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	asu64(R2) = x;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = x;
	R4 = 4;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	asu64(R4) = x;
	R5 = 2;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R5) = x;
	R6 = 8;
	asu64(R5) = *tou64p(((i64)R5+(i64)R6));
	qq_vars_var_loadbit(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	goto L6266;
L6270:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = x;
	R2 = tou64("Pushptr");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L6266:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6276;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6276:
// qq_runx.disploop.refpackend:
L6274:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6277:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6265;
	goto L6220;
L6278:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	asu64(R1) = y;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6280;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L6281;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L6282;
	goto L6283;
L6280:
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6285;
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_vars_var_unshareu(asu64(R1));
L6285:
	asu64(R1) = x;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = y;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*(struct $B3*)(R2) = (R1_B3);
	goto L6279;
L6281:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = x;
	asu64(R3) = y;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_packed_var_storepacked(asu64(R3), asu64(R2), asi64(R1));
	goto L6279;
L6282:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = x;
	asu64(R4) = y;
	R5 = 2;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R5) = y;
	R6 = 8;
	asu64(R5) = *tou64p(((i64)R5+(i64)R6));
	qq_vars_var_storebit(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6279;
L6283:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = y;
	R2 = tou64("Popptr");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L6279:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6286:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6287:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6288:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	asu64(R1) = sp;
	R2 = 1;
	R1 -= (i64)R2*16;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	R1 -= (i64)R2*16;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6290;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6290:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6291:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6293;
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	qq_vars_var_duplu(asu64(R1));
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6293:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6294:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6296;
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L6296;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&vx;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&vx;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6295;
L6296:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	qq_runaux_k_swap(asu64(R2), asu64(R1));
L6295:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6297:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	qq_runaux_k_convrefpack(asu64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6298:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6220;
L6299:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L6301;
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("jumpptr?");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6301:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	goto L6220;
L6302:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6304;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L6306;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6305;
L6306:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6305:
	goto L6303;
L6304:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = x;
	asi64(R1) = qq_vars_var_istruel(asu64(R1));
	if (!asi64(R1)) goto L6308;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6307;
L6308:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6307:
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6310;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6310:
L6303:
	goto L6220;
L6311:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6313;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (asi64(R1)) goto L6315;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6314;
L6315:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6314:
	goto L6312;
L6313:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = x;
	asi64(R1) = qq_vars_var_istruel(asu64(R1));
	if (asi64(R1)) goto L6317;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6316;
L6317:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6316:
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6319;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6319:
L6312:
	goto L6220;
L6320:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6322;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6322;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L6324;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6323;
L6324:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6323:
	goto L6321;
L6322:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_equal(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L6326;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6325;
L6326:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6325:
L6321:
	goto L6220;
L6327:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6329;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6329;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) == asi64(R2)) goto L6331;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6330;
L6331:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6330:
	goto L6328;
L6329:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_equal(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L6333;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6332;
L6333:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6332:
L6328:
	goto L6220;
L6334:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6336;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6336;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) >= asi64(R2)) goto L6338;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6337;
L6338:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6337:
	goto L6335;
L6336:
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6339;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6339;
	asu64(R1) = x;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	if (asr64(R1) >= asr64(R2)) goto L6341;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6340;
L6341:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6340:
	goto L6335;
L6339:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_compare(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L6343;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6342;
L6343:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6342:
L6335:
	goto L6220;
L6344:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6346;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6346;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L6348;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6347;
L6348:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6347:
	goto L6345;
L6346:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_compare(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L6350;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6349;
L6350:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6349:
L6345:
	goto L6220;
L6351:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6353;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6353;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) < asi64(R2)) goto L6355;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6354;
L6355:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6354:
	goto L6352;
L6353:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_compare(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6357;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6356;
L6357:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6356:
L6352:
	goto L6220;
L6358:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6360;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6360;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L6362;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6361;
L6362:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6361:
	goto L6359;
L6360:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_compare(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6364;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6363;
L6364:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6363:
L6359:
	goto L6220;
L6365:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6367;
	goto L6239;
L6367:
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L6369;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6368;
L6369:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6368:
	goto L6220;
L6370:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6372;
	goto L6239;
L6372:
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) == asi64(R2)) goto L6374;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6373;
L6374:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6373:
	goto L6220;
L6375:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6377;
	goto L6239;
L6377:
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) >= asi64(R2)) goto L6379;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6378;
L6379:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6378:
	goto L6220;
L6380:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6382;
	goto L6239;
L6382:
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L6384;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6383;
L6384:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6383:
	goto L6220;
L6385:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6387;
	goto L6239;
L6387:
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) < asi64(R2)) goto L6389;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6388;
L6389:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6388:
	goto L6220;
L6390:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6392;
	goto L6239;
L6392:
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L6394;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6393;
L6394:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6393:
	goto L6220;
L6395:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6397;
	goto L6239;
L6397:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L6399;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6398;
L6399:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6398:
	goto L6220;
L6400:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6402;
	goto L6239;
L6402:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) == asi64(R2)) goto L6404;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6403;
L6404:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6403:
	goto L6220;
L6405:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6407;
	goto L6239;
L6407:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) >= asi64(R2)) goto L6409;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6408;
L6409:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6408:
	goto L6220;
L6410:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6412;
	goto L6239;
L6412:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L6414;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6413;
L6414:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6413:
	goto L6220;
L6415:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6417;
	goto L6239;
L6417:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) < asi64(R2)) goto L6419;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6418;
L6419:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6418:
	goto L6220;
L6420:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6422;
	goto L6239;
L6422:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L6424;
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6423;
L6424:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6423:
	goto L6220;
L6425:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6427;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6427;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L6429;
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6428;
L6429:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6428:
	goto L6426;
L6427:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_runaux_k_when(asu64(R2), asu64(R1));
	res = asi64(R1);
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6431;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6431:
	asi64(R1) = res;
	if (!asi64(R1)) goto L6433;
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6435;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6435:
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6432;
L6433:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6432:
L6426:
	goto L6220;
L6436:
// qq_runx.disploop.jwhenne:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6439;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6439;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) == asi64(R2)) goto L6441;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6440;
L6441:
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6440:
	goto L6438;
L6439:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_runaux_k_when(asu64(R2), asu64(R1));
	res = asi64(R1);
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6443;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6443:
	asi64(R1) = res;
	if (asi64(R1)) goto L6445;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6444;
L6445:
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6447;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6447:
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6444:
L6438:
	goto L6220;
L6448:
	goto L6226;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6449:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6451;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6451;
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = sp;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("switch not int");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6451:
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = pc;
	R3 = 12;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	if (asi64(R1) < asi64(R2)) goto L6453;
	asu64(R2) = pc;
	R3 = 14;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	if (asi64(R1) > asi64(R2)) goto L6453;
	asu64(R1) = pc;
	asi64(R2) = n;
	R1 += (i64)R2*32;
	asu64(R2) = pc;
	R3 = 12;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R1 -= (i64)R2*32;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6452;
L6453:
	asu64(R1) = pc;
	asu64(R2) = pc;
	R3 = 14;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R1 += (i64)R2*32;
	asu64(R2) = pc;
	R3 = 12;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R1 -= (i64)R2*32;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
L6452:
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	goto L6220;
L6454:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	goto L6455;
	goto L6220;
L6456:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
// qq_runx.disploop.doto:
L6455:
	asu64(R1) = x;
	R2 = 8;
	R1 += (i64)R2;
	asi64(R1) = *(toi64p(R1)) -= 1;
	if (!asi64(R1)) goto L6458;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6457;
L6458:
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6457:
	goto L6220;
L6459:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	goto L6460;
	goto L6220;
L6461:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
// qq_runx.disploop.doforfci:
L6460:
	asu64(R1) = x;
	R2 = 8;
	R1 += (i64)R2;
	(*toi64p(R1)) += 1;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 2;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L6463;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6462;
L6463:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6462:
	goto L6220;
L6464:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	asu64(R1) = pc;
	R2 = 2;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	y = asu64(R1);
	goto L6465;
	goto L6220;
L6466:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 2;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	y = asu64(R1);
// qq_runx.disploop.doforff:
L6465:
	asu64(R1) = x;
	R2 = 8;
	R1 += (i64)R2;
	(*toi64p(R1)) += 1;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L6468;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6467;
L6468:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6467:
	goto L6220;
L6469:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 20;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = fp;
	asu64(R2) = sp;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = sp;
	fp = asu64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6220;
L6470:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6472;
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("Probably undefined function");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6472:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L6474;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L6474:
	asu64(R1) = d;
	R2 = 104;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = pc;
	R3 = 9;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L6476;
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 104;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = tou64("Callptr: wrong # params; need:");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6476:
	R1 = 20;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = fp;
	asu64(R2) = sp;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = sp;
	fp = asu64(R1);
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6220;
L6477:
// qq_runx.disploop.doretproc:
L6478:
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6481;
L6479:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6483;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6483:
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	if (--asi64(av_2)) goto L6479;
L6481:
	asu64(R1) = pc;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	n = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	asu64(R1) = fp;
	R2 = -4294967296;
	asi64(R1) &= asi64(R2);
	asu64(R2) = sp;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R1) |= asu64(R2);
	fp = asu64(R1);
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	asi64(R1) = n;
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6486;
L6484:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6488;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6488:
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	if (--asi64(av_3)) goto L6484;
L6486:
	goto L6220;
L6489:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 14;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	goto L6478;
	goto L6220;
L6490:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 114;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	moduleno = asi64(R1);
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 20;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = moduleno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6220;
L6491:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6220;
L6492:
	asu64(R1) = pc;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	n = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = sp;
	asi64(R3) = n;
	R2 -= (i64)R3*16;
	asu64(R3) = sp;
	asi64(R4) = n;
	R3 -= (i64)R4*16;
	R4 = 1;
	R3 += (i64)R4*16;
	asu64(R4) = pc;
	R5 = 16;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	qq_calldll_calldll(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = n;
	R2 = (u64)&sp;
	*tou64p(R2) -= asu64(R1)*16;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6493:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_host_callhostfunction(asi64(R2), asu64(R1));
	sp = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6494:
	asu64(R1) = pc;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	av_4 = asi64(R1);
	asi64(R1) = av_4;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6497;
L6495:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6499;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6499:
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	if (--asi64(av_4)) goto L6495;
L6497:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6500:
	R1 = 1;
	qq_decls_stopped = asi64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	goto L6221;
	goto L6220;
L6501:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = pc;
	R3 = 14;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R3) = sp;
	asu64(R1) = qq_runaux_k_makelist(asu64(R3), asi64(R2), asi64(R1));
	sp = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6502:
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	n = asi64(R1);
	asu64(R1) = sp;
	asu64(R2) = pc;
	R3 = 12;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R1 -= (i64)R2*16;
	R2 = 1;
	R1 += (i64)R2*16;
	x = asu64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = pc;
	R3 = 12;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R3) = x;
	asu64(R4) = x;
	qq_records_var_make_record(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = x;
	sp = asu64(R1);
	R1 = 0;
	asu64(R2) = sp;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6503:
	asu64(R1) = sp;
	asu64(R2) = pc;
	R3 = 12;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R1 -= (i64)R2*16;
	R2 = 1;
	R1 += (i64)R2*16;
	x = asu64(R1);
	asu64(R1) = pc;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = pc;
	R4 = 12;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	asu64(R4) = pc;
	R5 = 14;
	asi16(R4) = *toi16p(((i64)R4+(i64)R5));
	R4 = toi64(toi16(R4));
	asu64(R5) = x;
	asu64(R6) = x;
	qq_arrays_var_make_array(asu64(R6), asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = x;
	sp = asu64(R1);
	R1 = 0;
	asu64(R2) = sp;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6504:
	goto L6226;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6505:
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	n = asi64(R1);
	asu64(R1) = sp;
	asi64(R2) = n;
	R1 -= (i64)R2*16;
	R2 = 1;
	R1 += (i64)R2*16;
	x = asu64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = n;
	asu64(R3) = x;
	asu64(R4) = x;
	qq_packed_var_make_struct(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = x;
	sp = asu64(R1);
	R1 = 0;
	asu64(R2) = sp;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6506:
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	n = asi64(R1);
	asu64(R1) = sp;
	asi64(R2) = n;
	R1 -= (i64)R2*16;
	R2 = 1;
	R1 += (i64)R2*16;
	x = asu64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = x;
	asu64(R3) = x;
	qq_sets_var_make_set(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = x;
	sp = asu64(R1);
	R1 = 0;
	asu64(R2) = sp;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6507:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6510;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6509;
L6510:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("makerange/not int");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6509:
	R1 = 4;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	lower = asi64(R1);
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	upper = asi64(R1);
	asi64(R1) = lower;
	R2 = -281474976710656;
	if (asi64(R1) < asi64(R2)) goto L6513;
	R2 = 281474976710655;
	if (asi64(R1) <= asi64(R2)) goto L6512;
L6513:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("Range lwb bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6512:
	asi64(R1) = upper;
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = lower;
	asu64(R2) = sp;
	R3 = 16;
	R4 = 63;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6514:
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	n = asi64(R1);
	asu64(R1) = sp;
	asi64(R2) = n;
	R3 = 2;
	asi64(R2) *= asi64(R3);
	R1 -= (i64)R2*16;
	R2 = 1;
	R1 += (i64)R2*16;
	x = asu64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = x;
	asu64(R3) = x;
	qq_dicts_var_make_dict(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = x;
	sp = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6515:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&vx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6517;
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("Not str");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6517:
	R1 = (u64)&vx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pp = asu64(R1);
	asu64(R1) = pp;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6519;
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("Null str");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6519:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	asu64(R2) = pp;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = pp;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_decimal_var_make_dec_str(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6521;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6521:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6522:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = sp;
	qq_runaux_k_incrptr(asu64(R2), asi64(R1));
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6523:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	goto L6524;
	goto L6220;
L6525:
// qq_runx.disploop.jincrtof:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
// qq_runx.disploop.doincrto:
L6524:
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6528;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6529;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L6530;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6531;
	goto L6532;
L6528:
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = x;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
	goto L6527;
L6529:
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = x;
	R3 = 8;
	R2 += (i64)R3;
	*tou64p(R2) += asu64(R1)*16;
	goto L6527;
L6530:
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = x;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = pc;
	R3 = 12;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asi64(R1) *= asi64(R2);
	asu64(R2) = x;
	R3 = 8;
	R2 += (i64)R3;
	*tou64p(R2) += asu64(R1);
	goto L6527;
L6531:
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = x;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) += asr64(R1);
	goto L6527;
L6532:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = x;
	R2 = tou64("incrto");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L6527:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
// qq_runx.disploop.jincrtofx:
	goto L6220;
L6534:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	asu64(R2) = sp;
	qq_vars_var_loadptr(asu64(R2), asu64(R1));
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = (u64)&vx;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&vx;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = sp;
	qq_runaux_k_incrptr(asu64(R2), asi64(R1));
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6535:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = sp;
	qq_runaux_k_incrptr(asu64(R2), asi64(R1));
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	R1 = (u64)&sp;
	asu64(R1) = *(tou64p(R1)) += 16;
	R2 = (u64)&vx;
	qq_vars_var_loadptr(asu64(R2), asu64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6536:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	qq_vars_var_neg(asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6538;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6538:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6539:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	qq_vars_var_abs(asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6541;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6541:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6542:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	asi64(R1) = qq_vars_var_istruel(asu64(R1));
	asi64(R1) = !asi64(R1);
	res = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6544;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6544:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = res;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6545:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6547;
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = ~asi64(R1);
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6546;
L6547:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	qq_vars_var_inot(asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6549;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6549:
L6546:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6550:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	asi64(R1) = qq_vars_var_istruel(asu64(R1));
	n = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6552;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6552:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6553:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6555;
	goto L6556;
L6555:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L6558;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	n = asi64(R1);
	goto L6557;
L6558:
	R1 = 0;
	n = asi64(R1);
L6557:
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6554;
L6556:
	asu64(R1) = sp;
	R2 = tou64("ASC");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L6554:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6559:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6561;
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	asu64(R2) = sp;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	qq_strings_var_makechar(asi64(R2), asu64(R1));
	goto L6560;
L6561:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	R2 = tou64("CHR");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L6560:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6562:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6564;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6565;
	goto L6566;
L6564:
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) *= asi64(R1);
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6563;
L6565:
	asu64(R1) = sp;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R1) *= asr64(R1);
	asu64(R2) = sp;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L6563;
L6566:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	R2 = tou64("sqr");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L6563:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6567:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = sp;
	qq_runaux_k_maths(asu64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6568:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = sp;
	asu64(R3) = sp;
	R4 = 1;
	R3 -= (i64)R4*16;
	qq_runaux_k_maths2(asu64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6569:
	goto L6226;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6570:
	goto L6226;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6571:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	qq_runaux_k_len(asu64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6572:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	qq_runaux_k_lwb(asu64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6573:
// qq_runx.disploop.jupb:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	qq_runaux_k_upb(asu64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6575:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	R1 = (u64)&upper;
	R2 = (u64)&lower;
	asu64(R3) = sp;
	qq_runaux_k_bounds(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = pc;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6577;
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6579;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6579:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = lower;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = upper;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6576;
L6577:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6581;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6581:
	R1 = 4;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = lower;
	asu64(R2) = sp;
	R3 = 16;
	R4 = 63;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = upper;
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6576:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6583:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	asi64(R1) = qq_runaux_k_bytesize(asu64(R1));
	res = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6585;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6585:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = res;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6586:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = sp;
	asi64(R1) = qq_runaux_k_type(asu64(R2), asi64(R1));
	n = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6588;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6588:
	R1 = 18;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6589:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6591;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6592;
	goto L6593;
L6591:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 28;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	n = asi64(R1);
	goto L6590;
L6592:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	goto L6590;
L6593:
	asu64(R1) = sp;
	R2 = tou64("Dictitems/digits");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L6590:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6595;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6595:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6596:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6598;
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("isfound");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6598:
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0x8000000000000000;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6599:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	qq_runaux_k_minval(asu64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6600:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	qq_runaux_k_maxval(asu64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6601:
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L6603;
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6606;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L6606;
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L6605;
L6606:
	R1 = 1;
	n = asi64(R1);
L6605:
	goto L6602;
L6603:
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) != asi64(R2)) goto L6608;
	R1 = 1;
	n = asi64(R1);
L6608:
L6602:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6610;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6610:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6611:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	res = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6613;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6613:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = res;
	asu64(R2) = pc;
	R3 = 9;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) ^= asi64(R2);
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6614:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) == asi64(R2)) goto L6616;
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = (u64)&vx;
	qq_vars_var_convert(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6618;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6618:
L6616:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6619:
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6620:
// qq_runx.disploop.jadd:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6623;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6623;
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
	goto L6622;
L6623:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6624;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6624;
	asu64(R1) = y;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) += asr64(R1);
	goto L6622;
L6624:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_add(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6626;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6626:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6628;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6628:
L6622:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6629:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6631;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6631;
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) -= asi64(R1);
	goto L6630;
L6631:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6632;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6632;
	asu64(R1) = y;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) -= asr64(R1);
	goto L6630;
L6632:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_sub(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6634;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6634:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6636;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6636:
L6630:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6637:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6639;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6639;
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) *= asi64(R1);
	goto L6638;
L6639:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6640;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6640;
	asu64(R1) = y;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) *= asr64(R1);
	goto L6638;
L6640:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_mul(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6642;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6642:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6644;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6644:
L6638:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6645:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6647;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6647;
	asu64(R1) = y;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) /= asr64(R1);
	goto L6646;
L6647:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_div(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6649;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6649:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6651;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6651:
L6646:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6652:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6654;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6654;
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) /= asi64(R1);
	goto L6653;
L6654:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_idiv(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6656;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6656:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6658;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6658:
L6653:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6659:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_irem(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6661;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6661:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6663;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6663:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6664:
	asu64(R1) = sp;
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 1;
	R1 -= (i64)R2*16;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6667;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6666;
L6667:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("divrem");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6666:
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) /= asi64(R2);
	lower = asi64(R1);
	msysc_m$print_startcon();
	R1 = tou64("X.VALUE=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) %= asi64(R2);
	asu64(R2) = y;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = lower;
	asu64(R2) = x;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 2;
	R2 = 1;
	asu64(R3) = sp;
	asu64(R1) = qq_runaux_k_makelist(asu64(R3), asi64(R2), asi64(R1));
	sp = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6668:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6670;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6670;
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) &= asi64(R1);
	goto L6669;
L6670:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_iand(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6672;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6672:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6674;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6674:
L6669:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6675:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6677;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6677;
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) |= asi64(R1);
	goto L6676;
L6677:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_ior(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6679;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6679:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6681;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6681:
L6676:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6682:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6684;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6684;
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) ^= asi64(R1);
	goto L6683;
L6684:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_ixor(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6686;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6686:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6688;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6688:
L6683:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6689:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6691;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6691;
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) <<= asi64(R1);
	goto L6690;
L6691:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_shl(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6693;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6693:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6695;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6695:
L6690:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6696:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6698;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6698;
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) >>= asi64(R1);
	goto L6697;
L6698:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_shr(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6700;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6700:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6702;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6702:
L6697:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6703:
	asu64(R1) = sp;
	y = asu64(R1);
	R1 = (u64)&sp;
	asu64(R1) = *(tou64p(R1)) -= 16;
	x = asu64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_in(asu64(R2), asu64(R1));
	asu64(R2) = pc;
	R3 = 9;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) ^= asi64(R2);
	n = asi64(R1);
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6705;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6705:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6707;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6707:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6708:
	asu64(R1) = sp;
	y = asu64(R1);
	R1 = (u64)&sp;
	asu64(R1) = *(tou64p(R1)) -= 16;
	x = asu64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_inx(asu64(R2), asu64(R1));
	n = asi64(R1);
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6710;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6710:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6712;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6712:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6713:
	asu64(R1) = sp;
	y = asu64(R1);
	R1 = (u64)&sp;
	asu64(R1) = *(tou64p(R1)) -= 16;
	x = asu64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asu64(R3) = pc;
	R4 = 9;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = qq_runaux_k_cmp(asi64(R3), asu64(R2), asu64(R1));
	res = asi64(R1);
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6715;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6715:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6717;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6717:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = res;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6718:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	x = asu64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_compare(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L6720;
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6722;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6722:
	goto L6719;
L6720:
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6724;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6724:
	asu64(R1) = y;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = sp;
	*(struct $B3*)(R2) = (R1_B3);
L6719:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6725:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	x = asu64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_compare(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6727;
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6729;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6729:
	goto L6726;
L6727:
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6731;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6731:
	asu64(R1) = y;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = sp;
	*(struct $B3*)(R2) = (R1_B3);
L6726:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6732:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	(R1_B3) = *(struct $B3*)(R1);
	vx = (R1_B3);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_concat(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6734;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6734:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6735:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	(R1_B3) = *(struct $B3*)(R1);
	vx = (R1_B3);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_append(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6737;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6737:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6738:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6740;
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6740;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L6740;
	R1 = 1;
	res = asi64(R1);
	goto L6739;
L6740:
	R1 = 0;
	res = asi64(R1);
L6739:
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6742;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6742:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6744;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6744:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = res;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6745:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	qq_vars_var_power(asu64(R2), asu64(R1));
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6747;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6747:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6749;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6749:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6750:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	z = asu64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6752;
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L6752;
	asu64(R1) = z;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6753;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6753;
	R1 = 1;
	goto L6754;
L6753:
	R1 = 0;
L6754:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L6752;
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = z;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
	goto L6751;
L6752:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	asu64(R3) = pc;
	R4 = 16;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	qq_vars_var_inplace(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6756;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6756:
L6751:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6757:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	z = asu64(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 16;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6759;
	asu64(R1) = z;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6760;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6760;
	R1 = 1;
	goto L6761;
L6760:
	R1 = 0;
L6761:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L6759;
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = z;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
	goto L6758;
L6759:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	R1 = 14;
	R2 = (u64)&vx;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = z;
	R2 = (u64)&vx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = y;
	R2 = (u64)&vx;
	asu64(R3) = pc;
	R4 = 1;
	R3 += (i64)R4*32;
	R4 = 16;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	qq_vars_var_inplace(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6763;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6763:
L6758:
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6220;
L6764:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	z = asu64(R1);
	asu64(R1) = z;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6766;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6766;
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = z;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
	goto L6765;
L6766:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	R1 = 14;
	R2 = (u64)&vx;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = z;
	R2 = (u64)&vx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = y;
	R2 = (u64)&vx;
	asu64(R3) = pc;
	R4 = 1;
	R3 += (i64)R4*32;
	R4 = 16;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	qq_vars_var_inplace(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6768;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6768:
L6765:
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6220;
L6769:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	z = asu64(R1);
	asu64(R1) = z;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6771;
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = z;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
	goto L6770;
L6771:
	goto L6255;
L6770:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6220;
L6772:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	z = asu64(R1);
	asu64(R1) = z;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6774;
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = z;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) -= asi64(R1);
	goto L6773;
L6774:
	goto L6255;
L6773:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6220;
L6775:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	z = asu64(R1);
	asu64(R1) = z;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6777;
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = z;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) <<= asi64(R1);
	goto L6776;
L6777:
	goto L6255;
L6776:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6220;
L6778:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	z = asu64(R1);
	asu64(R1) = z;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6780;
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = z;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) >>= asi64(R1);
	goto L6779;
L6780:
	goto L6255;
L6779:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6220;
L6781:
	goto L6226;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6782:
	goto L6226;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6783:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	px = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = px;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6785;
	goto L6786;
L6785:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = px;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_vars_var_appendto(asu64(R2), asu64(R1));
	goto L6784;
L6786:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = px;
	R2 = tou64("Appendto");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L6784:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6787:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	px = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = px;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6789;
	goto L6790;
L6789:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = px;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_vars_var_concatto(asu64(R2), asu64(R1));
	goto L6788;
L6790:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = px;
	R2 = tou64("Concatto");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L6788:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6791:
	R1 = (u64)&qq_decls_genfieldtable;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	g = asu64(R1);
	asu64(R1) = g;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6793;
	asu64(R1) = g;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L6793;
	R1 = (u64)&qq_decls_genfieldtable;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = d;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 116;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	if (asi64(R1) == asi64(R2)) goto L6795;
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("Dot1: wrong type");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6795:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 108;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R3 = 16;
	asi64(R2) /= asi64(R3);
	R1 += (i64)R2*16;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6797;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6797:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6799;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L6799:
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6792;
L6793:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = g;
	asu64(R2) = sp;
	qq_runaux_k_dot(asu64(R2), asu64(R1));
L6792:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6800:
	R1 = (u64)&qq_decls_genfieldtable;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	g = asu64(R1);
	asu64(R1) = g;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6802;
	asu64(R1) = g;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L6802;
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6804;
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("Popdot1: not rec");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6804:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L6806;
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	qq_lib_pcnotmut();
L6806:
	asu64(R1) = g;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = e;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 116;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	if (asi64(R1) == asi64(R2)) goto L6808;
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("Popdot1: wrong type");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6808:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 108;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R3 = 16;
	asi64(R2) /= asi64(R3);
	R1 += (i64)R2*16;
	z = asu64(R1);
	asu64(R1) = z;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6810;
	asu64(R1) = z;
	qq_vars_var_unshareu(asu64(R1));
L6810:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = z;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = z;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6812;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6812:
	goto L6801;
L6802:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = g;
	asu64(R2) = sp;
	asu64(R1) = qq_runaux_k_popdot(asu64(R2), asu64(R1));
	sp = asu64(R1);
L6801:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6813:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	R1 = (u64)&qq_decls_genfieldtable;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = sp;
	qq_runaux_k_dotref(asu64(R2), asu64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6814:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6816;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6817;
	goto L6818;
L6816:
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	qq_vars_var_getix(asu64(R2), asi64(R1));
	goto L6815;
L6817:
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 16;
	R4 = 63;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R3) = sp;
	qq_vars_var_getslice(asu64(R3), asi64(R2), asi64(R1));
	goto L6815;
L6818:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = y;
	R2 = (u64)&vx;
	R3 = tou64("Index");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L6815:
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6820;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6820:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6821:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	z = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = z;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6823;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6824;
	goto L6825;
L6823:
	asu64(R1) = x;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = y;
	qq_vars_var_putix(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6827;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6827:
	goto L6822;
L6824:
	asu64(R1) = x;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = z;
	R4 = 0;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	R4 = 16;
	R5 = 63;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	asu64(R4) = y;
	qq_vars_var_putslice(asu64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6829;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6829:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6831;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6831:
	goto L6822;
L6825:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = z;
	asu64(R2) = y;
	R3 = tou64("Popix");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L6822:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6832:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6834;
	goto L6835;
L6834:
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	qq_vars_var_getixref(asu64(R2), asi64(R1));
	goto L6833;
L6835:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	R3 = tou64("Indexref");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L6833:
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6837;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6837:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6838:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	asu64(R1) = qq_runaux_k_keyindex(asu64(R1));
	sp = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6839:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	asu64(R1) = qq_runaux_k_popkeyindex(asu64(R1));
	sp = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6840:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	asu64(R1) = qq_runaux_k_keyindexref(asu64(R1));
	sp = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6841:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&vx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6843;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6844;
	goto L6845;
L6843:
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	qq_vars_var_getdotix(asu64(R2), asi64(R1));
	goto L6842;
L6844:
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 16;
	R4 = 63;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R3) = sp;
	qq_vars_var_getdotslice(asu64(R3), asi64(R2), asi64(R1));
	goto L6842;
L6845:
	asu64(R1) = y;
	R2 = (u64)&vx;
	R3 = tou64("Dotindex");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L6842:
	R1 = (u64)&vx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6847;
	R1 = (u64)&vx;
	qq_vars_var_unshareu(asu64(R1));
L6847:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6848:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	z = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = z;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6850;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6851;
	goto L6852;
L6850:
	asu64(R1) = x;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = y;
	qq_vars_var_putdotix(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6854;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6854:
	goto L6849;
L6851:
	asu64(R1) = x;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = z;
	R4 = 0;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	R4 = 16;
	R5 = 63;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	asu64(R4) = y;
	qq_vars_var_putdotslice(asu64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6856;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6856:
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6858;
	asu64(R1) = y;
	qq_vars_var_unshareu(asu64(R1));
L6858:
	goto L6849;
L6852:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = z;
	asu64(R2) = y;
	R3 = tou64("Popdotindex");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L6849:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6859:
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = y;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6861;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6862;
	goto L6863;
L6861:
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	qq_vars_var_getdotixref(asu64(R2), asi64(R1));
	goto L6860;
L6862:
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 16;
	R4 = 63;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R3) = sp;
	qq_vars_var_getdotsliceref(asu64(R3), asi64(R2), asi64(R1));
	goto L6860;
L6863:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = sp;
	R3 = tou64("Dotindexref");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L6860:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6864:
	asu64(R1) = sp;
	asu64(R2) = pc;
	R3 = 9;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R1 += (i64)R2*16;
	R2 = 1;
	R1 -= (i64)R2*16;
	x = asu64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = x;
	asu64(R3) = sp;
	qq_vars_var_expand(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = x;
	sp = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6865:
	R1 = 21;
	R2 = (u64)&sp;
	asu64(R2) = *(tou64p(R2)) += 16;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = fp;
	asu64(R2) = sp;
	asi64(R1) -= asi64(R2);
	asu64(R2) = sp;
	R3 = 4;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc;
	R2 = 14;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 6;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6866:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6868;
	R1 = tou64("");
	R2 = tou64("Raise: not Int");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L6868:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = fp;
	qq_decls_frameptr = asu64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_runaux_raiseexception(asi64(R1));
	pc = asu64(R1);
	asu64(R1) = qq_decls_sptr;
	sp = asu64(R1);
	asu64(R1) = qq_decls_frameptr;
	fp = asu64(R1);
	goto L6220;
L6869:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	R1 = (u64)&newsp;
	asu64(R2) = pc;
	asu64(R3) = sp;
	asu64(R1) = qq_runaux_k_map(asu64(R3), asu64(R2), asu64(R1));
	pc = asu64(R1);
	asu64(R1) = newsp;
	sp = asu64(R1);
	goto L6220;
L6870:
	asu64(R1) = pc;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&sp;
	*tou64p(R2) -= asu64(R1)*16;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L6220;
L6871:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = sp;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6873;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6873:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = sp;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6875;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6875:
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6220;
L6876:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6878;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6878:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6880;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6880:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 2;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 2;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6882;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6882:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6220;
L6883:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6885;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6885:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6220;
L6886:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6888;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6888:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6220;
L6889:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6891;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6891;
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6890;
L6891:
	goto L6239;
L6890:
	goto L6220;
L6892:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6894;
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6893;
L6894:
	goto L6239;
L6893:
	goto L6220;
L6895:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6897;
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6896;
L6897:
	goto L6239;
L6896:
	goto L6220;
L6898:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6900;
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6899;
L6900:
	goto L6255;
L6899:
	goto L6220;
L6901:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6903;
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) -= asi64(R1);
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6902;
L6903:
	goto L6255;
L6902:
	goto L6220;
L6904:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6906;
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) &= asi64(R1);
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6905;
L6906:
	goto L6255;
L6905:
	goto L6220;
L6907:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6909;
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) <<= asi64(R1);
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6908;
L6909:
	goto L6255;
L6908:
	goto L6220;
L6910:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6912;
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) >>= asi64(R1);
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6911;
L6912:
	goto L6255;
L6911:
	goto L6220;
L6913:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6915;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6915:
	R1 = 1;
	asu64(R2) = x;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6220;
L6916:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	y = asu64(R1);
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6918;
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6918:
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6920;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L6920:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6220;
L6921:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
// qq_runx.disploop.doindexff:
L6922:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	y = asu64(R1);
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = y;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6924;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6925;
	goto L6926;
L6924:
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	qq_vars_var_getix(asu64(R2), asi64(R1));
	goto L6923;
L6925:
	asu64(R1) = y;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 16;
	R4 = 63;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R3) = sp;
	qq_vars_var_getslice(asu64(R3), asi64(R2), asi64(R1));
	goto L6923;
L6926:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = tou64("Indexff");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L6923:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6220;
L6927:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	goto L6922;
	goto L6220;
L6928:
	asu64(R1) = sp;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6930;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L6932;
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6931;
L6932:
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6931:
	goto L6929;
L6930:
	goto L6255;
L6929:
	goto L6220;
L6933:
	asu64(R1) = sp;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6935;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) == asi64(R2)) goto L6937;
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6936;
L6937:
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L6936:
	goto L6934;
L6935:
	goto L6255;
L6934:
	goto L6220;
L6938:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6940;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6940:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	asu64(R1) = sp;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = sp;
	qq_runaux_k_upb(asu64(R1));
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6220;
L6941:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L6944;
	asu64(R1) = x;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6943;
L6944:
	goto L6244;
L6943:
	goto L6945;
	goto L6220;
L6946:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L6949;
	asu64(R1) = x;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6948;
L6949:
	goto L6246;
L6948:
// qq_runx.disploop.dopushipf:
L6945:
	R1 = (u64)&sp;
	(*tou64p(R1)) += 16;
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = x;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6951;
	goto L6952;
L6951:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = x;
	R3 = 8;
	R2 += (i64)R3;
	*tou64p(R2) += asu64(R1);
	goto L6950;
L6952:
L6950:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6220;
L6953:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L6956;
	asu64(R1) = x;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L6956;
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6955;
L6956:
	goto L6244;
L6955:
	goto L6957;
	goto L6220;
L6958:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L6961;
	asu64(R1) = x;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L6961;
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6960;
L6961:
	goto L6246;
L6960:
// qq_runx.disploop.dopopipf:
L6957:
	asu64(R1) = x;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6963;
	goto L6964;
L6963:
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*tou8p(R2) = asu8(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = x;
	R3 = 8;
	R2 += (i64)R3;
	*tou64p(R2) += asu64(R1);
	goto L6962;
L6964:
L6962:
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6220;
L6965:
	asu64(R1) = fp;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	x = asu64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6967;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L6967:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
	goto L6220;
L6968:
	goto L6226;
	goto L6220;
L6223:
// qq_runx.disploop.unimpl:
L6226:
	asu64(R1) = pc;
	qq_decls_pcptr = asu64(R1);
	R1 = (u64)&qq_pcltabs_pclnames;
	asu64(R2) = pc;
	R3 = 8;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("Unimpl op:");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	R1 = 1;
	exit(R1);
	goto L6220;
L6221:
L6217:
	return;
}

static void qq_runx_start() {
    u64 R1; 
	R1 = 1;
	qq_runx_getjt = asu8(R1);
	qq_runx_disploop();
	R1 = 0;
	qq_runx_getjt = asu8(R1);
	return;
}

static void qq_runx_fixupcode(u64 pm) {
    u64 R1, R2, R3; 
	u64 pc;
	asu64(R1) = qq_runx_jumptable;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6972;
	goto L6970;
L6972:
	asu64(R1) = pm;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	goto L6976;
L6973:
	asu64(R1) = qq_runx_jumptable;
	asu64(R2) = pc;
	R3 = 8;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = pc;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L6976:
	asu64(R1) = pc;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L6973;
L6970:
	return;
}

static i64 qq_runx_runqprogram(u64 sp, i64 ismain) {
    u64 R1, R2, R3; 
	i64 tt;
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) >= asi64(R2)) goto L6979;
	R1 = 0;
	goto L6977;
L6979:
	R1 = (u64)&qq_decls_varstack;
	R2 = 0;
	R1 += (i64)R2;
	qq_decls_sptr = asu64(R1);
	R1 = (u64)&qq_decls_varstack;
	R2 = 1118384;
	R1 += (i64)R2;
	qq_decls_stacklimit = asu64(R1);
	R1 = (u64)&qq_decls_modules;
	asu64(R2) = sp;
	R3 = 24;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_decls_pcptr = asu64(R1);
	R1 = 0;
	qq_decls_stopped = asi64(R1);
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	tt = asi64(R1);
	qq_runx_disploop();
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	tt = asi64(R1);
	asu64(R1) = qq_decls_sptr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L6977;
L6977:
	return asi64(R1);
}

static void qq_runaux_pcerror(u64 mess, u64 param) {
    u64 R1, R2, R3; 
	asu64(R1) = param;
	asu64(R2) = mess;
	asu64(R3) = qq_decls_pcptr;
	qq_runaux_reportpcerror(asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void qq_runaux_pcustype(u64 mess, u64 x) {
    u64 R1, R2; 
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = mess;
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
	return;
}

static void qq_runaux_pcustype_t(u64 mess, i64 t) {
    u64 R1, R2, R3; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("Type not supported: # : #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_ttname;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = tou64("");
	R2 = (u64)&str;
	asu64(R3) = qq_decls_pcptr;
	qq_runaux_reportpcerror(asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void qq_runaux_pcmxtypes(u64 mess, u64 x, u64 y) {
    u64 R1, R2, R3; 
	asu64(R1) = y;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = x;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = mess;
	qq_runaux_pcmxtypestt(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void qq_runaux_pcmxtypestt(u64 mess, i64 t, i64 u) {
    u64 R1, R2, R3; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("Types not supported: # : #/#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_ttname;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_ttname;
	asi64(R2) = u;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = tou64("");
	R2 = (u64)&str;
	asu64(R3) = qq_decls_pcptr;
	qq_runaux_reportpcerror(asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void qq_runaux_reportpcerror(u64 pcptr, u64 mess, u64 param) {
    u64 R1, R2; struct $B12 R1_B12; 
	u64 s;
	u64 send;
	u64 pc;
	i64 count;
	u64 pm;
	struct $B12 loc;
	struct $B12 loc2;
	asu64(R1) = pcptr;
	(R1_B12) = qq_runaux_getpcerrorpos(asu64(R1));
	loc = (R1_B12);
	R1 = (u64)&loc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("80p*");
	R2 = tou64(" ");
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("PC Error:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("    ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Line:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&loc;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("in Module");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&loc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".q:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&loc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6987;
	msysc_m$print_startcon();
	R1 = tou64("In function:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&loc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L6987:
	asu64(R1) = qq_decls_sptr;
	s = asu64(R1);
	R1 = (u64)&qq_decls_varstack;
	R2 = 0;
	R1 += (i64)R2;
	send = asu64(R1);
	R1 = 0;
	count = asi64(R1);
	goto L6989;
L6988:
	asu64(R1) = s;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L6992;
	asu64(R1) = s;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 1;
	R1 -= (i64)R2*32;
	pc = asu64(R1);
	asu64(R1) = pc;
	(R1_B12) = qq_runaux_getpcerrorpos(asu64(R1));
	loc2 = (R1_B12);
	msysc_m$print_startcon();
	R1 = tou64("Called from line");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&loc2;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("in");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&loc2;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&count;
	(*toi64p(R1)) += 1;
L6992:
	R1 = (u64)&s;
	(*tou64p(R1)) -=16;
L6989:
	asu64(R1) = s;
	asu64(R2) = send;
	if (asu64(R1) < asu64(R2)) goto L6993;
	asi64(R1) = count;
	R2 = 5;
	if (asi64(R1) < asi64(R2)) goto L6988;
L6993:
	msysc_m$print_startcon();
	R1 = tou64("PC/STOPC");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&loc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	R1 = (u64)&loc;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("LOC.PM.FILESPEC=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&loc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	(R1_B12) = loc;
	qq_lib_stopcompiler((R1_B12));
	return;
}

static struct $B12 qq_runaux_getpcerrorpos(u64 pc) {
    u64 R1, R2, R3; struct $B12 R1_B12; 
	i64 offset;
	i64 pos;
	i64 soffset;
	i64 moduleno;
	u64 pcstart;
	u64 pcsrcstart;
	u64 pm;
	struct $B12 loc;
	R1 = (u64)&loc;
	memset(R1, 0, 48);
	R1 = (u64)&qq_decls_modules;
	asu64(R2) = pc;
	asi64(R2) = qq_runaux_findmodulefrompc(asu64(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	asu64(R1) = pm;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcstart = asu64(R1);
	asu64(R1) = pm;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcsrcstart = asu64(R1);
	asu64(R1) = pcstart;
	asu64(R2) = pc;
	asi64(R1) = qq_lib_getpcloffset(asu64(R2), asu64(R1));
	offset = asi64(R1);
	asu64(R1) = pcsrcstart;
	asi64(R2) = offset;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	pos = asi64(R1);
	asi64(R1) = pos;
	R2 = 0;
	R3 = 23;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = (u64)&loc;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = pos;
	R2 = 24;
	R3 = 31;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	moduleno = asi64(R1);
	asi64(R1) = moduleno;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6996;
	R1 = 1;
	moduleno = asi64(R1);
	R1 = 0;
	soffset = asi64(R1);
L6996:
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = moduleno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&loc;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&qq_decls_subprogs;
	asu64(R2) = pm;
	R3 = 44;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&loc;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&loc;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	(R1_B12) = loc;
	goto L6994;
L6994:
	return (R1_B12);
}

static i64 qq_runaux_findmodulefrompc(u64 pc) {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7000;
L6998:
	asu64(R1) = pc;
	R2 = (u64)&qq_decls_modules;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 56;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L7002;
	asu64(R1) = pc;
	R2 = (u64)&qq_decls_modules;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 64;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) >= asu64(R2)) goto L7002;
	asi64(R1) = i;
	goto L6997;
L7002:
	i += 1; if (i <= qq_decls_nmodules) goto L6998;
L7000:
	msysc_m$print_startcon();
	R1 = tou64("Can't find pcptr module");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc;
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	R1 = 0;
	goto L6997;
L6997:
	return asi64(R1);
}

static u64 qq_runaux_k_makelist(u64 sp, i64 lower, i64 n) {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	asu64(R1) = sp;
	asi64(R2) = n;
	R1 -= (i64)R2*16;
	R2 = 1;
	R1 += (i64)R2*16;
	x = asu64(R1);
	asu64(R1) = x;
	sp = asu64(R1);
	asi64(R1) = lower;
	asi64(R2) = n;
	asu64(R3) = sp;
	asu64(R4) = x;
	qq_lists_var_make_list(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = sp;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = sp;
	goto L7003;
L7003:
	return asu64(R1);
}

static void qq_runaux_k_len(u64 sp) {
    u64 R1, R2, R3, R4; 
	u64 p;
	i64 n;
	i64 t;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7006;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7006;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7006;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7006;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7007;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7008;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7008;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7008;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7009;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7010;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7011;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L7012;
	goto L7013;
L7006:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	goto L7005;
L7007:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	goto L7005;
L7008:
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	n = asi64(R1);
	goto L7005;
L7009:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	goto L7005;
L7010:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 16;
	R4 = 63;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	goto L7005;
L7011:
	asu64(R1) = p;
	asi64(R1) = qq_decimal_obj_len_dec(asu64(R1));
	n = asi64(R1);
	goto L7005;
L7012:
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	t = asi64(R1);
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7015;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7015;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7015;
	goto L7016;
L7015:
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	n = asi64(R1);
	goto L7014;
L7016:
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	n = asi64(R1);
L7014:
	goto L7005;
L7013:
	asu64(R1) = sp;
	R2 = tou64("Len");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7005:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7018;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L7018:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_runaux_k_maths(u64 sp, i64 opc) {
    u64 R1, R2, R3; 
	r64 x;
	asu64(R1) = sp;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	x = asr64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7021;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7022;
	goto L7023;
L7021:
	asi64(R1) = opc;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7025;
	goto L7026;
L7025:
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) *= asi64(R1);
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L7019;
	goto L7024;
L7026:
L7024:
	R1 = 2;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	x = asr64(R1);
	goto L7020;
L7022:
	goto L7020;
L7023:
	asu64(R1) = sp;
	R2 = tou64("Maths:");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7020:
	asi64(R1) = opc;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7028;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7029;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7030;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7031;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7032;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7033;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7034;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7035;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7036;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7037;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7038;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7039;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7040;
	goto L7041;
L7028:
	asr64(R1) = x;
	asr64(R1) *= asr64(R1);
	x = asr64(R1);
	goto L7027;
L7029:
	asr64(R1) = x;
	asr64(R1) = sqrt(asr64(R1));
	x = asr64(R1);
	goto L7027;
L7030:
	asr64(R1) = x;
	asr64(R1) = sin(asr64(R1));
	x = asr64(R1);
	goto L7027;
L7031:
	asr64(R1) = x;
	asr64(R1) = cos(asr64(R1));
	x = asr64(R1);
	goto L7027;
L7032:
	asr64(R1) = x;
	asr64(R1) = tan(asr64(R1));
	x = asr64(R1);
	goto L7027;
L7033:
	asr64(R1) = x;
	asr64(R1) = asin(asr64(R1));
	x = asr64(R1);
	goto L7027;
L7034:
	asr64(R1) = x;
	asr64(R1) = acos(asr64(R1));
	x = asr64(R1);
	goto L7027;
L7035:
	asr64(R1) = x;
	asr64(R1) = atan(asr64(R1));
	x = asr64(R1);
	goto L7027;
L7036:
	asr64(R1) = x;
	asr64(R1) = log(asr64(R1));
	x = asr64(R1);
	goto L7027;
L7037:
	asr64(R1) = x;
	asr64(R1) = log10(asr64(R1));
	x = asr64(R1);
	goto L7027;
L7038:
	asr64(R1) = x;
	asr64(R2) = 0.000000000000000000e+000;
	if (asr64(R1) < asr64(R2)) goto L7043;
	asr64(R1) = x;
	asr64(R2) = 5.000000000000000000e-001;
	asr64(R1) += asr64(R2);
	asr64(R1) = floor(asr64(R1));
	x = asr64(R1);
	goto L7042;
L7043:
	asr64(R1) = x;
	asr64(R2) = 5.000000000000000000e-001;
	asr64(R1) -= asr64(R2);
	asr64(R1) = ceil(asr64(R1));
	x = asr64(R1);
L7042:
	goto L7027;
L7039:
	asr64(R1) = x;
	asr64(R1) = floor(asr64(R1));
	x = asr64(R1);
	goto L7027;
L7040:
	asr64(R1) = x;
	asr64(R1) = ceil(asr64(R1));
	x = asr64(R1);
	goto L7027;
L7041:
	R1 = (u64)&qq_tables_mathsnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = tou64("Maths op:");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7027:
	asr64(R1) = x;
	asu64(R2) = sp;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
L7019:
	return;
}

static void qq_runaux_k_maths2(u64 x, u64 y, i64 opc) {
    u64 R1, R2, R3; 
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L7047;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7046;
L7047:
	R1 = tou64("");
	R2 = tou64("maths2");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7046:
	goto L7049;
L7049:
	R1 = (u64)&qq_tables_mathsnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = tou64("Maths2:");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	return;
}

static void qq_runaux_k_lwb(u64 sp) {
    u64 R1, R2, R3; 
	u64 p;
	i64 n;
	i64 t;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7052;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7053;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7053;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7054;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7054;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7055;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7055;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7056;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7057;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7058;
	goto L7059;
L7052:
	asu64(R1) = p;
	R2 = 6;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	n = asi64(R1);
	goto L7051;
L7053:
	R1 = 1;
	n = asi64(R1);
	goto L7051;
L7054:
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	n = asi64(R1);
	goto L7051;
L7055:
	R1 = 1;
	n = asi64(R1);
	goto L7051;
L7056:
	R1 = (u64)&qq_tables_ttlower;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	n = asi64(R1);
	goto L7051;
L7057:
	R1 = 0;
	n = asi64(R1);
	goto L7051;
L7058:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	R3 = 63;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	n = asi64(R1);
	goto L7051;
L7059:
	asu64(R1) = sp;
	R2 = tou64("Lwb");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7051:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7061;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L7061:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_runaux_k_upb(u64 sp) {
    u64 R1, R2, R3; 
	u64 p;
	i64 n;
	i64 t;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7064;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7065;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7065;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7066;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7066;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7067;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7067;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7068;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7069;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7070;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L7071;
	goto L7072;
L7064:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 6;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	goto L7063;
L7065:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	goto L7063;
L7066:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 4;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 0;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	goto L7063;
L7067:
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	n = asi64(R1);
	goto L7063;
L7068:
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	t = asi64(R1);
	goto L7073;
	goto L7063;
L7069:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	goto L7063;
L7070:
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	goto L7063;
L7071:
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	t = asi64(R1);
// qq_runaux.k_upb.dotype:
L7073:
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7075;
	goto L7076;
L7075:
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&qq_tables_ttlower;
	asi64(R3) = t;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	goto L7074;
L7076:
	asu64(R1) = sp;
	R2 = tou64("t.upb");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7074:
	goto L7063;
L7072:
	asu64(R1) = sp;
	R2 = tou64("Upb");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7063:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7078;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L7078:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = n;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_runaux_k_swap(u64 x, u64 y) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	struct $B65 tempbuffer;
	struct $B3 v;
	i64 s;
	i64 t;
	i64 n;
	u64 p;
	u64 q;
	i64 a;
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L7081;
	R1 = tou64("");
	R2 = tou64("Swap mismatch");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7081:
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7083;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L7084;
	goto L7085;
L7083:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(R1_B3) = *(struct $B3*)(R1);
	v = (R1_B3);
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = x;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*(struct $B3*)(R2) = (R1_B3);
	(R1_B3) = v;
	asu64(R2) = y;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*(struct $B3*)(R2) = (R1_B3);
	goto L7082;
L7084:
	asu64(R1) = x;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	s = asi64(R1);
	asu64(R1) = y;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	t = asi64(R1);
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) == asi64(R2)) goto L7087;
	goto L7088;
L7087:
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = s;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7090;
	goto L7091;
L7090:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	a = asi64(R1);
	asu64(R1) = q;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = a;
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
	goto L7089;
L7091:
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = s;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 1024;
	if (asi64(R1) > asi64(R2)) goto L7093;
	asi64(R1) = n;
	asu64(R2) = x;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&tempbuffer;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	asu64(R2) = y;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = x;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&tempbuffer;
	asu64(R3) = y;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L7092;
L7093:
	goto L7088;
L7092:
L7089:
	goto L7082;
L7085:
// qq_runaux.k_swap.swaperror:
L7088:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = tou64("Swap");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L7082:
	return;
}

static void qq_runaux_k_bounds(u64 sp, u64 lower, u64 upper) {
    u64 R1, R2, R3; 
	i64 a;
	i64 b;
	i64 m;
	i64 t;
	u64 p;
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	m = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asi64(R1) = m;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7096;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7097;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7097;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7098;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7098;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7099;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7100;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7100;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7101;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7102;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L7103;
	goto L7104;
L7096:
	asu64(R1) = p;
	R2 = 6;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	a = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = a;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	b = asi64(R1);
	goto L7095;
L7097:
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	a = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = a;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	b = asi64(R1);
	goto L7095;
L7098:
	R1 = 1;
	a = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	b = asi64(R1);
	goto L7095;
L7099:
	asu64(R1) = sp;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	R3 = 63;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	a = asi64(R1);
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	b = asi64(R1);
	goto L7095;
L7100:
	R1 = 1;
	a = asi64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	b = asi64(R1);
	goto L7095;
L7101:
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	t = asi64(R1);
	goto L7105;
	goto L7095;
L7102:
	R1 = 0;
	a = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	b = asi64(R1);
	goto L7095;
L7103:
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	t = asi64(R1);
// qq_runaux.k_bounds.dotype:
L7105:
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7107;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7107;
	goto L7108;
L7107:
	R1 = (u64)&qq_tables_ttlower;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	a = asi64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asi64(R2) = a;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	b = asi64(R1);
	goto L7106;
L7108:
	asu64(R1) = sp;
	R2 = tou64("t.bounds");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7106:
	goto L7095;
L7104:
	asu64(R1) = sp;
	R2 = tou64("Bounds");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7095:
	asi64(R1) = a;
	asu64(R2) = lower;
	*toi64p(R2) = asi64(R1);
	asi64(R1) = b;
	asu64(R2) = upper;
	*toi64p(R2) = asi64(R1);
	return;
}

static i64 qq_runaux_k_type(u64 sp, i64 n) {
    u64 R1, R2, R3; 
	i64 t;
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	t = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7111;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7112;
	goto L7113;
L7111:
	goto L7110;
L7112:
	asi64(R1) = t;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7115;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7115;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7115;
	goto L7116;
L7115:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	t = asi64(R1);
	goto L7114;
L7116:
L7114:
	goto L7110;
L7113:
	asi64(R1) = t;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7118;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7118;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L7119;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7119;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7119;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7120;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7121;
	goto L7122;
L7118:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	t = asi64(R1);
	goto L7117;
L7119:
	asu64(R1) = sp;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	t = asi64(R1);
	goto L7117;
L7120:
	R1 = 33;
	t = asi64(R1);
	goto L7117;
L7121:
	R1 = (u64)&qq_tables_tttarget;
	asu64(R2) = sp;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	goto L7117;
L7122:
	R1 = 0;
	t = asi64(R1);
L7117:
L7110:
	asi64(R1) = t;
	goto L7109;
L7109:
	return asi64(R1);
}

static void qq_runaux_k_dot(u64 sp, u64 g) {
    u64 R1, R2, R3, R4, R5, R6; struct $B3 R1_B3; 
	u64 d;
	u64 p;
	u64 q;
	i64 rectype;
	struct $B3 v;
// qq_runaux.k_dot.restart:
L7124:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7126;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7126;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7127;
	goto L7128;
L7126:
	goto L7125;
L7127:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	sp = asu64(R1);
	goto L7124;
	goto L7125;
L7128:
	asu64(R1) = sp;
	R2 = tou64("1:dot/not record");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7125:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	rectype = asi64(R1);
	asi64(R1) = rectype;
	asu64(R2) = g;
	asu64(R1) = qq_runaux_resolvefield(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7130;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7131;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7132;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L7133;
	goto L7134;
L7130:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 108;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R3 = 16;
	asi64(R2) /= asi64(R3);
	R1 += (i64)R2*16;
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7136;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L7136:
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7138;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L7138:
	asu64(R1) = p;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = sp;
	*(struct $B3*)(R2) = (R1_B3);
	goto L7129;
L7131:
	R1 = 0;
	R2 = (u64)&v;
	asu64(R3) = d;
	R4 = 116;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	asu64(R4) = sp;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R5) = d;
	R6 = 108;
	asi16(R5) = *toi16p(((i64)R5+(i64)R6));
	R5 = toi64(toi16(R5));
	R4 += (i64)R5;
	qq_packed_var_loadpacked(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7140;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L7140:
	(R1_B3) = v;
	asu64(R2) = sp;
	*(struct $B3*)(R2) = (R1_B3);
	goto L7129;
L7132:
	R1 = 17;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = d;
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L7129;
L7133:
	R1 = 17;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L7129;
L7134:
	R1 = (u64)&qq_tables_namenames;
	asu64(R2) = d;
	R3 = 124;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("DOT: can't do this fieldtype:");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7129:
	return;
}

static void qq_runaux_k_dotref(u64 sp, u64 g) {
    u64 R1, R2, R3; 
	u64 d;
	u64 p;
	u64 q;
	i64 rectype;
// qq_runaux.k_dotref.restart:
L7142:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7144;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7144;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7145;
	goto L7146;
L7144:
	goto L7143;
L7145:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	sp = asu64(R1);
	goto L7142;
	goto L7143;
L7146:
	asu64(R1) = sp;
	R2 = tou64("2:dot/not record");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7143:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	rectype = asi64(R1);
	asi64(R1) = rectype;
	asu64(R2) = g;
	asu64(R1) = qq_runaux_resolvefield(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7148;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7149;
	goto L7150;
L7148:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 108;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R3 = 16;
	asi64(R2) /= asi64(R3);
	R1 += (i64)R2*16;
	p = asu64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7152;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L7152:
	R1 = 14;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L7147;
L7149:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 108;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R1 += (i64)R2;
	q = asu64(R1);
	asu64(R1) = sp;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7154;
	asu64(R1) = sp;
	qq_vars_var_unshareu(asu64(R1));
L7154:
	R1 = 16;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = q;
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = sp;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L7147;
L7150:
	R1 = (u64)&qq_tables_namenames;
	asu64(R2) = d;
	R3 = 124;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("DOTREF: can't do this fieldtype:");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7147:
	return;
}

static u64 qq_runaux_k_popdot(u64 sp, u64 g) {
    u64 R1, R2, R3, R4, R5; struct $B3 R1_B3; 
	u64 d;
	u64 p;
	u64 x;
	u64 y;
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7157;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7157;
	goto L7158;
L7157:
	goto L7156;
L7158:
	asu64(R1) = x;
	R2 = tou64("3:dot/not record");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7156:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = g;
	asu64(R1) = qq_runaux_resolvefield(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7160;
	R1 = tou64("");
	R2 = tou64("POPDOT");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7160:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L7162;
	qq_lib_pcnotmut();
L7162:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7164;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7165;
	goto L7166;
L7164:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 108;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R3 = 16;
	asi64(R2) /= asi64(R3);
	R1 += (i64)R2*16;
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7168;
	asu64(R1) = p;
	qq_vars_var_unshareu(asu64(R1));
L7168:
	asu64(R1) = y;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = p;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7170;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L7170:
	goto L7163;
L7165:
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asu64(R2) = y;
	asu64(R3) = x;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = d;
	R5 = 108;
	asi16(R4) = *toi16p(((i64)R4+(i64)R5));
	R4 = toi64(toi16(R4));
	R3 += (i64)R4;
	qq_packed_var_storepacked(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = x;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7172;
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
L7172:
	goto L7163;
L7166:
	R1 = (u64)&qq_tables_namenames;
	asu64(R2) = d;
	R3 = 124;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("POPDOT: can't do this fieldtype:");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7163:
	asu64(R1) = sp;
	goto L7155;
L7155:
	return asu64(R1);
}

static u64 qq_runaux_resolvefield(u64 g, i64 rectype) {
    u64 R1, R2; 
	u64 d;
	goto L7175;
L7174:
	asu64(R1) = g;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asi64(R2) = rectype;
	if (asi64(R1) != asi64(R2)) goto L7178;
	asu64(R1) = d;
	goto L7173;
L7178:
	asu64(R1) = g;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	g = asu64(R1);
L7175:
	asu64(R1) = g;
	if (asu64(R1)) goto L7174;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't resolve field:");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	R1 = 0;
	goto L7173;
L7173:
	return asu64(R1);
}

static void qq_runaux_k_convrefpack(u64 sp) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 tag;
	i64 elemtype;
	u64 p;
	u64 pa;
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7181;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L7182;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7182;
	goto L7183;
L7181:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7185;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L7185;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7186;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7187;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7188;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7189;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7190;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7191;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7192;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7193;
	goto L7194;
L7185:
	asu64(R1) = a;
	R2 = 8;
	R1 += (i64)R2;
	p = asu64(R1);
	R1 = 26;
	elemtype = asi64(R1);
	goto L7184;
L7186:
	asu64(R1) = a;
	R2 = 8;
	R1 += (i64)R2;
	p = asu64(R1);
	R1 = 32;
	elemtype = asi64(R1);
	goto L7184;
L7187:
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = pa;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	goto L7184;
L7188:
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pa;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&qq_tables_ttbitwidth;
	asu64(R3) = pa;
	R4 = 6;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) *= asi64(R2);
	asu64(R2) = sp;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = sp;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 15;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pa;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = sp;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L7179;
	goto L7184;
L7189:
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = sp;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = sp;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 15;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 33;
	asu64(R2) = sp;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L7179;
	goto L7184;
L7190:
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = 27;
	elemtype = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7196;
	R1 = tou64("");
	p = asu64(R1);
L7196:
	goto L7184;
L7191:
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = pa;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	goto L7184;
L7192:
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = pa;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	goto L7184;
L7193:
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = 25;
	elemtype = asi64(R1);
	goto L7184;
L7194:
	asu64(R1) = a;
	R2 = tou64("Getrefpack1");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7184:
	goto L7180;
L7182:
	goto L7179;
	goto L7180;
L7183:
	asu64(R1) = sp;
	R2 = tou64("Getrefpack2");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7180:
// qq_runaux.k_convrefpack.done:
	R1 = 16;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = elemtype;
	asu64(R2) = sp;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L7179:
	return;
}

static void qq_runaux_k_incrptr(u64 p, i64 step) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7200;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L7201;
	goto L7202;
L7200:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7204;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7205;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L7206;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7207;
	goto L7208;
L7204:
	asi64(R1) = step;
	asu64(R2) = p;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
	goto L7203;
L7205:
	asi64(R1) = step;
	asu64(R2) = p;
	R3 = 8;
	R2 += (i64)R3;
	*tou64p(R2) += asu64(R1)*16;
	goto L7203;
L7206:
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asi64(R2) = step;
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 8;
	R2 += (i64)R3;
	*tou64p(R2) += asu64(R1);
	goto L7203;
L7207:
	asi64(R1) = step;
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) += asr64(R1);
	goto L7203;
L7208:
	asu64(R1) = p;
	R2 = tou64("incrptr/refvar");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7203:
	goto L7199;
L7201:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L7210;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L7210;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L7211;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L7211;
	goto L7212;
L7210:
	asi64(R1) = step;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*tou8p(R2) += asu8(R1);
	goto L7209;
L7211:
	asi64(R1) = step;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*tou16p(R2) += asu16(R1);
	goto L7209;
L7212:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = tou64("incrptr/ref");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L7209:
	goto L7199;
L7202:
	asu64(R1) = p;
	R2 = tou64("incrptr");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7199:
	return;
}

static i64 qq_runaux_k_cmp(i64 cc, u64 x, u64 y) {
    u64 R1, R2; 
	i64 res;
	asi64(R1) = cc;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7215;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7216;
	goto L7217;
L7215:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_equal(asu64(R2), asu64(R1));
	goto L7214;
L7216:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_equal(asu64(R2), asu64(R1));
	asi64(R1) = !asi64(R1);
	goto L7214;
L7217:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_compare(asu64(R2), asu64(R1));
	res = asi64(R1);
	asi64(R1) = cc;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7219;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7220;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7221;
	goto L7222;
L7219:
	asi64(R1) = res;
	R2 = 0;
	asi64(R1) = asi64(R1)  <  asi64(R2);
	goto L7218;
L7220:
	asi64(R1) = res;
	R2 = 0;
	asi64(R1) = asi64(R1)  <=  asi64(R2);
	goto L7218;
L7221:
	asi64(R1) = res;
	R2 = 0;
	asi64(R1) = asi64(R1)  >=  asi64(R2);
	goto L7218;
L7222:
	asi64(R1) = res;
	R2 = 0;
	asi64(R1) = asi64(R1)  >  asi64(R2);
L7218:
L7214:
	goto L7213;
L7213:
	return asi64(R1);
}

static i64 qq_runaux_k_bytesize(u64 sp) {
    u64 R1, R2, R3, R4; 
	i64 t;
	u64 p;
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	t = asi64(R1);
	asi64(R1) = t;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L7225;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7226;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7226;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7226;
	goto L7227;
L7225:
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	t = asi64(R1);
	goto L7224;
L7226:
	asu64(R1) = sp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	t = asi64(R1);
	goto L7224;
L7227:
L7224:
	asi64(R1) = t;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7229;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7230;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7231;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7232;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7233;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7233;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7234;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7234;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7234;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7235;
	goto L7236;
L7229:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_tables_ttsize;
	asu64(R3) = p;
	R4 = 6;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	goto L7228;
L7230:
	R1 = 33;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_bits_getbitssize(asi64(R2), asi64(R1));
	goto L7228;
L7231:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L7228;
L7232:
	asu64(R1) = p;
	asi64(R1) = qq_bits_bits_bytesize(asu64(R1));
	goto L7228;
L7233:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) *= asi64(R2);
	goto L7228;
L7234:
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	goto L7228;
L7235:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4;
	asi64(R1) *= asi64(R2);
	goto L7228;
L7236:
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
L7228:
	goto L7223;
L7223:
	return asi64(R1);
}

static i64 qq_runaux_k_when(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	R2 = 65540;
	if (asi64(R1) == asi64(R2)) goto L7239;
	R2 = 65541;
	if (asi64(R1) == asi64(R2)) goto L7240;
	R2 = 1179653;
	if (asi64(R1) == asi64(R2)) goto L7240;
	goto L7241;
L7239:
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 16;
	R4 = 63;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asi64(R1) < asi64(R2)) goto L7243;
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L7243;
	R1 = 1;
	goto L7242;
L7243:
	R1 = 0;
L7242:
	goto L7238;
L7240:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_sets_var_in_set(asu64(R2), asu64(R1));
	goto L7238;
L7241:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R1) = qq_vars_var_equal(asu64(R2), asu64(R1));
L7238:
	goto L7237;
L7237:
	return asi64(R1);
}

static u64 qq_runaux_raiseexception(i64 exceptno) {
    u64 R1, R2, R3; 
	u64 stackend;
	u64 oldsptr;
	R1 = (u64)&qq_decls_varstack;
	R2 = 0;
	R1 += (i64)R2;
	stackend = asu64(R1);
	asu64(R1) = qq_decls_sptr;
	oldsptr = asu64(R1);
L7245:
	asu64(R1) = qq_decls_sptr;
	asu64(R2) = stackend;
	if (asu64(R1) > asu64(R2)) goto L7248;
	asu64(R1) = oldsptr;
	qq_decls_sptr = asu64(R1);
	R1 = tou64("");
	R2 = tou64("DEFAULT EXCEPTION");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7248:
	asu64(R1) = qq_decls_sptr;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L7250;
	asi64(R1) = exceptno;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7251;
	asu64(R1) = qq_decls_sptr;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = exceptno;
	if (asi64(R1) != asi64(R2)) goto L7250;
L7251:
	goto L7246;
L7250:
	asu64(R1) = qq_decls_sptr;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7253;
	asu64(R1) = qq_decls_sptr;
	qq_vars_var_unshareu(asu64(R1));
L7253:
	R1 = (u64)&qq_decls_sptr;
	(*tou64p(R1)) -=16;
	goto L7245;
L7246:
	asu64(R1) = qq_decls_sptr;
	asu64(R2) = qq_decls_sptr;
	R3 = 4;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	R1 += (i64)R2;
	qq_decls_frameptr = asu64(R1);
	asu64(R1) = qq_decls_sptr;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L7244;
L7244:
	return asu64(R1);
}

static i64 qq_runaux_runproc_m(u64 amsg) {
    u64 R1, R2, R3, R4; 
	struct $B3 a;
	struct $B3 b;
	struct $B3 dest;
	i64 i;
	i64 result;
	struct $B32 obj;
	asi64(R1) = qq_runaux_runproc_m_rmsg_typeno;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7256;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_tables_ntypes;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7259;
L7257:
	R1 = tou64("ws_msg64");
	R2 = (u64)&qq_tables_ttname;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7261;
	asi64(R1) = i;
	qq_runaux_runproc_m_rmsg_typeno = asi64(R1);
	goto L7259;
L7261:
	i += 1; if (i <= qq_tables_ntypes) goto L7257;
L7259:
L7256:
	asi64(R1) = qq_runaux_runproc_m_rmsg_typeno;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7263;
	R1 = tou64("mainwndproc: can't find rmsg");
	mlib_abortprogram(asu64(R1));
L7263:
	R1 = 32;
	R2 = 0;
	R3 = (u64)&obj;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 99;
	R2 = (u64)&obj;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = amsg;
	R2 = (u64)&obj;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = qq_runaux_runproc_m_rmsg_typeno;
	R2 = (u64)&obj;
	R3 = 6;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 269;
	R2 = (u64)&a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&obj;
	R2 = (u64)&a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&dest;
	R2 = 0;
	R3 = (u64)&a;
	asu64(R4) = qq_decls_pcl_callbackfn;
	qq_runaux_runproc(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&dest;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	result = asi64(R1);
	R1 = 0;
	result = asi64(R1);
	asi64(R1) = result;
	goto L7254;
L7254:
	return asi64(R1);
}

static void qq_runaux_runproc(u64 fnptr, u64 a, u64 b, u64 dest) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 oldsptr;
	u64 oldframeptr;
	u64 oldpcptr;
	u8 oldstopped;
	i64 nparams;
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = qq_decls_stopped;
	oldstopped = asu8(R1);
	asu64(R1) = qq_decls_pcptr;
	oldpcptr = asu64(R1);
	asu64(R1) = qq_decls_sptr;
	oldsptr = asu64(R1);
	asu64(R1) = qq_decls_frameptr;
	oldframeptr = asu64(R1);
	R1 = 999;
	R2 = (u64)&qq_decls_sptr;
	asu64(R2) = *(tou64p(R2)) += 16;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = b;
	if (!asu64(R1)) goto L7266;
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7266;
	R1 = 2;
	nparams = asi64(R1);
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	R2 = (u64)&qq_decls_sptr;
	asu64(R2) = *(tou64p(R2)) += 16;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = b;
	(R1_B3) = *(struct $B3*)(R1);
	R2 = (u64)&qq_decls_sptr;
	asu64(R2) = *(tou64p(R2)) += 16;
	*(struct $B3*)(R2) = (R1_B3);
	goto L7265;
L7266:
	asu64(R1) = a;
	if (!asu64(R1)) goto L7267;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7267;
	R1 = 1;
	nparams = asi64(R1);
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	R2 = (u64)&qq_decls_sptr;
	asu64(R2) = *(tou64p(R2)) += 16;
	*(struct $B3*)(R2) = (R1_B3);
	goto L7265;
L7267:
	R1 = 0;
	nparams = asi64(R1);
L7265:
	R1 = 20;
	R2 = (u64)&qq_decls_sptr;
	asu64(R2) = *(tou64p(R2)) += 16;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = qq_decls_stopseq;
	asu64(R2) = qq_decls_sptr;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = qq_decls_frameptr;
	asu64(R2) = qq_decls_sptr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = qq_decls_sptr;
	qq_decls_frameptr = asu64(R1);
	asu64(R1) = fnptr;
	qq_decls_pcptr = asu64(R1);
	qq_runx_disploop();
	asu64(R1) = qq_decls_sptr;
	R2 = 11;
	R1 -= (i64)R2*16;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L7269;
	asu64(R1) = qq_decls_sptr;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = dest;
	*(struct $B3*)(R2) = (R1_B3);
	goto L7268;
L7269:
	R1 = (u64)&qq_decls_sptr;
	(*tou64p(R1)) -=16;
	asu64(R1) = qq_decls_sptr;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = dest;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = dest;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7271;
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L7271:
L7268:
	asu64(R1) = oldpcptr;
	qq_decls_pcptr = asu64(R1);
	asu8(R1) = oldstopped;
	R1 = toi64(tou8(R1));
	qq_decls_stopped = asi64(R1);
	asu64(R1) = oldsptr;
	qq_decls_sptr = asu64(R1);
	asu64(R1) = oldframeptr;
	qq_decls_frameptr = asu64(R1);
	asu8(R1) = oldstopped;
	R1 = toi64(tou8(R1));
	qq_decls_stopped = asi64(R1);
	return;
}

static u64 qq_runaux_k_keyindex(u64 sp) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 d;
	u64 k;
	u64 p;
	u64 def;
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	def = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	k = asu64(R1);
	asu64(R1) = sp;
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7274;
	asu64(R1) = d;
	R2 = tou64("dict{}");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7274:
	R1 = 0;
	asu64(R2) = k;
	asu64(R3) = d;
	asu64(R1) = qq_dicts_var_finddictitem(asu64(R3), asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = d;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7276;
	asu64(R1) = d;
	qq_vars_var_unshareu(asu64(R1));
L7276:
	asu64(R1) = k;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7278;
	asu64(R1) = k;
	qq_vars_var_unshareu(asu64(R1));
L7278:
	asu64(R1) = p;
	if (!asu64(R1)) goto L7280;
	asu64(R1) = p;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = sp;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = def;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7282;
	asu64(R1) = def;
	qq_vars_var_unshareu(asu64(R1));
L7282:
	goto L7279;
L7280:
	asu64(R1) = def;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = sp;
	*(struct $B3*)(R2) = (R1_B3);
L7279:
	asu64(R1) = sp;
	goto L7272;
L7272:
	return asu64(R1);
}

static u64 qq_runaux_k_popkeyindex(u64 sp) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 d;
	u64 k;
	u64 p;
	u64 x;
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	k = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	d = asu64(R1);
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	x = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7285;
	asu64(R1) = d;
	R2 = tou64("dict{}:=");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7285:
	R1 = 1;
	asu64(R2) = k;
	asu64(R3) = d;
	asu64(R1) = qq_dicts_var_finddictitem(asu64(R3), asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7287;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7289;
	asu64(R1) = p;
	qq_vars_var_unshareu(asu64(R1));
L7289:
L7287:
	asu64(R1) = x;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = p;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = d;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7291;
	asu64(R1) = d;
	qq_vars_var_unshareu(asu64(R1));
L7291:
	asu64(R1) = k;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7293;
	asu64(R1) = k;
	qq_vars_var_unshareu(asu64(R1));
L7293:
	asu64(R1) = sp;
	goto L7283;
L7283:
	return asu64(R1);
}

static u64 qq_runaux_k_keyindexref(u64 sp) {
    u64 R1, R2, R3; 
	u64 d;
	u64 k;
	u64 p;
	u64 x;
	R1 = (u64)&sp;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) -= 16; asu64(R1) = asu64(R2);
	k = asu64(R1);
	asu64(R1) = sp;
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7296;
	asu64(R1) = d;
	R2 = tou64("&dict{}");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7296:
	R1 = 0;
	asu64(R2) = k;
	asu64(R3) = d;
	asu64(R1) = qq_dicts_var_finddictitem(asu64(R3), asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7298;
	R1 = tou64("");
	R2 = tou64("&dict{} not found");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7298:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7300;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L7300:
	asu64(R1) = k;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7302;
	asu64(R1) = k;
	qq_vars_var_unshareu(asu64(R1));
L7302:
	asu64(R1) = d;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7304;
	asu64(R1) = d;
	qq_vars_var_unshareu(asu64(R1));
L7304:
	R1 = 14;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = sp;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = sp;
	goto L7294;
L7294:
	return asu64(R1);
}

static u64 qq_runaux_k_map(u64 sp, u64 pc, u64 newsp) {
    u64 R1, R2, R3; struct $B32 R1_B32; 
	i64 nargs;
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L7307;
	goto L7308;
L7307:
	asu64(R1) = qq_runx_jumptable;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7310;
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_runaux_k_map_codeseq;
	R3 = 1;
	R2 += (i64)R3*32-32;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L7309;
L7310:
	asu64(R1) = qq_runx_jumptable;
	asu64(R2) = sp;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&qq_runaux_k_map_codeseq;
	R3 = 1;
	R2 += (i64)R3*32-32;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7309:
	R1 = (u64)&sp;
	(*tou64p(R1)) -=16;
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	(R1_B32) = *(struct $B32*)(R1);
	R2 = (u64)&qq_runaux_k_map_codeseq;
	R3 = 2;
	*(struct $B32*)(((i64)R2+(i64)R3*32-32)) = (R1_B32);
	goto L7306;
L7308:
	R1 = tou64("");
	R2 = tou64("Apply:no op");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7306:
	asu64(R1) = sp;
	asu64(R2) = newsp;
	*tou64p(R2) = asu64(R1);
	R1 = (u64)&qq_runaux_k_map_codeseq;
	R2 = 0;
	R1 += (i64)R2;
	goto L7305;
L7305:
	return asu64(R1);
}

static void qq_runaux_k_maxval(u64 sp) {
    u64 R1, R2, R3; 
	i64 a;
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L7313;
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L7313:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L7315;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L7316;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L7317;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L7318;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L7319;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L7320;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L7321;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L7322;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7322;
	goto L7323;
L7315:
	R1 = 255;
	a = asi64(R1);
	goto L7314;
L7316:
	R1 = 65536;
	a = asi64(R1);
	goto L7314;
L7317:
	R1 = 4294967295;
	a = asi64(R1);
	goto L7314;
L7318:
	R1 = -1;
	a = asi64(R1);
	goto L7314;
L7319:
	R1 = 127;
	a = asi64(R1);
	goto L7314;
L7320:
	R1 = 32767;
	a = asi64(R1);
	goto L7314;
L7321:
	R1 = 2147483647;
	a = asi64(R1);
	goto L7314;
L7322:
	R1 = 9223372036854775807;
	a = asi64(R1);
	goto L7314;
L7323:
	asu64(R1) = sp;
	R2 = tou64("MAXVALUE");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7314:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = a;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&qq_decls_pcptr;
	(*tou64p(R1)) += 32;
	return;
}

static void qq_runaux_k_minval(u64 sp) {
    u64 R1, R2, R3; 
	i64 a;
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L7326;
	asu64(R1) = sp;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L7326:
	asu64(R1) = sp;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L7328;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L7328;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L7328;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L7328;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L7329;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L7330;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L7331;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7332;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L7332;
	goto L7333;
L7328:
	R1 = 0;
	a = asi64(R1);
	goto L7327;
L7329:
	R1 = -128;
	a = asi64(R1);
	goto L7327;
L7330:
	R1 = -32768;
	a = asi64(R1);
	goto L7327;
L7331:
	R1 = -2147483648;
	a = asi64(R1);
	goto L7327;
L7332:
	R1 = 0x8000000000000000;
	a = asi64(R1);
	goto L7327;
L7333:
	asu64(R1) = sp;
	R2 = tou64("MINVALUE");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L7327:
	R1 = 1;
	asu64(R2) = sp;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = a;
	asu64(R2) = sp;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&qq_decls_pcptr;
	(*tou64p(R1)) += 32;
	return;
}

static void qq_sets_obj_free_set(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L7336;
	R1 = 33;
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_bits_getbitssize(asi64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L7336:
	asu64(R1) = p;
	mlib_pcm_free32(asu64(R1));
	return;
}

static void qq_sets_var_dupl_set(u64 a) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	i64 nbytes;
	i64 nbits;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	nbits = asi64(R1);
	asi64(R1) = nbits;
	asu64(R1) = qq_sets_obj_newset(asi64(R1));
	q = asu64(R1);
	asi64(R1) = nbits;
	if (!asi64(R1)) goto L7339;
	R1 = 33;
	asi64(R2) = nbits;
	asu64(R1) = qq_bits_getbitssize(asi64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = q;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L7339:
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static i64 qq_sets_var_equal_set(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	i64 xbytes;
	i64 ybytes;
	asu64(R1) = x;
	asi64(R1) = qq_sets_getsetbytes(asu64(R1));
	xbytes = asi64(R1);
	asu64(R1) = y;
	asi64(R1) = qq_sets_getsetbytes(asu64(R1));
	ybytes = asi64(R1);
	asi64(R1) = xbytes;
	asi64(R2) = ybytes;
	if (asi64(R1) == asi64(R2)) goto L7342;
	R1 = 0;
	goto L7340;
L7342:
	asi64(R1) = xbytes;
	asu64(R2) = y;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = x;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R1) = mlib_eqbytes(asu64(R3), asu64(R2), asi64(R1));
	goto L7340;
L7340:
	return asi64(R1);
}

static i64 qq_sets_getsetbytes(u64 x) {
    u64 R1, R2; 
	i64 nbits;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	nbits = asi64(R1);
	asi64(R1) = nbits;
	if (!asi64(R1)) goto L7345;
	asi64(R1) = nbits;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L7347;
	asi64(R1) = nbits;
	R2 = 8;
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	goto L7346;
L7347:
	asi64(R1) = nbits;
	R2 = 8;
	asi64(R1) /= asi64(R2);
L7346:
	goto L7344;
L7345:
	R1 = 0;
L7344:
	goto L7343;
L7343:
	return asi64(R1);
}

static void qq_sets_var_make_set(u64 data, u64 dest, i64 n) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 p;
	i64 top;
	i64 a;
	i64 b;
	i64 i;
	i64 j;
	i64 t;
	i64 size;
	u8 alloc;
	u64 s;
	i64 av_1;
	i64 av_2;
// PROC LOCAL STATICS GO HERE
	static i64 qq_sets_var_make_set_count = 0;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7350;
	asu64(R1) = dest;
	qq_sets_var_emptyset(asu64(R1));
	goto L7348;
L7350:
	R1 = 0;
	top = asi64(R1);
	asu64(R1) = data;
	q = asu64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7353;
L7351:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7355;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7356;
	goto L7357;
L7355:
	asu64(R1) = q;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	R3 = 63;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	a = asi64(R1);
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	b = asi64(R1);
	goto L7354;
L7356:
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7359;
	asi64(R1) = a;
	asi64(R1) = -asi64(R1);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	a = asi64(R1);
	asi64(R1) = a;
	asi64(R2) = top;
	if (asi64(R1) <= asi64(R2)) goto L7361;
	asi64(R1) = a;
	top = asi64(R1);
L7361:
	goto L7352;
L7359:
	asi64(R1) = a;
	b = asi64(R1);
	goto L7354;
L7357:
	asu64(R1) = q;
	asi64(R1) = qq_vars_var_getintvalue(asu64(R1));
	R2 = R1;
	a = asi64(R2);
	b = asi64(R1);
L7354:
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7364;
	asi64(R1) = b;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7363;
L7364:
	R1 = tou64("");
	R2 = tou64("Neg range element");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7363:
	asi64(R1) = a;
	R2 = (u64)&top;
    *toi64p(R2) = Max(*toi64p(R2), asi64(R1));
	asi64(R1) = b;
	R2 = (u64)&top;
    *toi64p(R2) = Max(*toi64p(R2), asi64(R1));
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
L7352:
	if (--asi64(av_1)) goto L7351;
L7353:
	asi64(R1) = top;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = qq_sets_obj_newset(asi64(R1));
	s = asu64(R1);
	asu64(R1) = data;
	q = asu64(R1);
	asi64(R1) = n;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7367;
L7365:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7369;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7370;
	goto L7371;
L7369:
	asu64(R1) = q;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	R3 = 63;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	a = asi64(R1);
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	b = asi64(R1);
	asi64(R1) = a;
	asi64(R2) = b;
	if (asi64(R1) <= asi64(R2)) goto L7373;
	R1 = (u64)&a;
	R2 = (u64)&b;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
L7373:
	goto L7368;
L7370:
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	a = asi64(R2);
	b = asi64(R1);
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7375;
	goto L7366;
L7375:
	goto L7368;
L7371:
	asu64(R1) = q;
	asi64(R1) = qq_vars_var_getintvalue(asu64(R1));
	R2 = R1;
	a = asi64(R2);
	b = asi64(R1);
L7368:
	asi64(R1) = b;
	asi64(R2) = a;
	asu64(R3) = s;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_lib_setelemblock(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
L7366:
	if (--asi64(av_2)) goto L7365;
L7367:
	asu64(R1) = dest;
	asu64(R2) = s;
	R3 = 5;
	qq_vars_var_objtovar(asi64(R3), asu64(R2), asu64(R1));
L7348:
	return;
}

static u64 qq_sets_obj_newset(i64 length) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	i64 nbits;
	i64 nbytes;
	asu64(R1) = qq_vars_obj_new();
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = 64;
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) *= asi64(R2);
	nbytes = asi64(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L7378;
	asi64(R1) = nbytes;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_clearmem(asu64(R2), asi64(R1));
	goto L7377;
L7378:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7377:
	asu64(R1) = p;
	goto L7376;
L7376:
	return asu64(R1);
}

static void qq_sets_var_emptyset(u64 dest) {
    u64 R1, R2, R3; 
	asu64(R1) = dest;
	R2 = 0;
	asu64(R2) = qq_sets_obj_newset(asi64(R2));
	R3 = 5;
	qq_vars_var_objtovar(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void qq_sets_var_getix_set(u64 a, i64 index) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asi64(R1) = index;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L7382;
	R1 = tou64("");
	R2 = tou64("set[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7382:
	R1 = 1;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = index;
	R3 = 3;
	asi64(R2) >>= asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R3) = index;
	R4 = 7;
	asi64(R3) &= asi64(R4);
	asi64(R2) <<= asi64(R3);
	asi64(R1) &= asi64(R2);
	asi64(R1) = !!asi64(R1);
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_sets_var_putix_set(u64 a, i64 index, u64 x) {
    u64 R1, R2, R3, R4, R5; 
	u64 p;
	u64 q;
	i64 newoffset;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L7385;
	qq_lib_pcnotmut();
L7385:
	asi64(R1) = index;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L7387;
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7389;
	R1 = tou64("");
	R2 = tou64("lwb");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L7388;
L7389:
	R1 = tou64("");
	R2 = tou64("set[i]:=x bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7388:
L7387:
	R1 = (u64)&newoffset;
	asi64(R2) = index;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R1) = qq_sets_getoffset(asu64(R3), asi64(R2), asu64(R1));
	q = asu64(R1);
	R1 = 0;
	R2 = 33;
	asu64(R3) = x;
	asi64(R4) = newoffset;
	asu64(R5) = q;
	qq_vars_var_storebit(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void qq_sets_var_getixref_set(u64 a, i64 index) {
    u64 R1, R2, R3, R4; 
	struct $B3 v;
	u64 p;
	u64 q;
	i64 offset;
	i64 newoffset;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L7392;
	qq_lib_pcnotmut();
L7392:
	asi64(R1) = index;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L7394;
	R1 = tou64("");
	R2 = tou64("&set[i] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7394:
	R1 = (u64)&newoffset;
	asi64(R2) = index;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R1) = qq_sets_getoffset(asu64(R3), asi64(R2), asu64(R1));
	q = asu64(R1);
	R1 = 15;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 33;
	asu64(R2) = a;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = newoffset;
	asu64(R2) = a;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static u64 qq_sets_getoffset(u64 p, i64 index, u64 newoffset) {
    u64 R1, R2; 
	asi64(R1) = index;
	R2 = 3;
	asi64(R1) >>= asi64(R2);
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = index;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	asu64(R2) = newoffset;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = p;
	goto L7395;
L7395:
	return asu64(R1);
}

static i64 qq_sets_var_in_set(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	i64 i;
	i64 m;
	u64 p;
// PROC LOCAL STATICS GO HERE
	static u64 qq_sets_var_in_set_masks = -9205322385119247871;
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	i = asi64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asi64(R1) = i;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L7398;
	R1 = 0;
	goto L7396;
L7398:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	R3 = 3;
	asi64(R2) >>= asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&qq_sets_var_in_set_masks;
	asi64(R3) = i;
	R4 = 7;
	asi64(R3) &= asi64(R4);
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L7400;
	R1 = 1;
	goto L7399;
L7400:
	R1 = 0;
L7399:
	goto L7396;
L7396:
	return asi64(R1);
}

static void qq_sets_iresizeset(u64 p, i64 n) {
    u64 R1, R2; 
	u64 pp;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pp = asu64(R1);
	asu64(R1) = pp;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = n;
	if (asi64(R1) < asi64(R2)) goto L7403;
	goto L7401;
L7403:
	asi64(R1) = n;
	asu64(R2) = pp;
	qq_sets_obj_resize_set(asu64(R2), asi64(R1));
L7401:
	return;
}

static void qq_sets_obj_resize_set(u64 p, i64 n) {
    u64 R1, R2, R3; 
	u64 q;
	i64 newsize;
	i64 elemtype;
	asu64(R1) = p;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	elemtype = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L7406;
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L7405;
L7406:
	R1 = 33;
	asi64(R2) = n;
	asi64(R1) = qq_bits_getbitssize(asi64(R2), asi64(R1));
	newsize = asi64(R1);
	asi64(R1) = newsize;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L7408;
	R1 = 33;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_bits_getbitssize(asi64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 33;
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_bits_getbitssize(asi64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L7408:
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L7405:
	return;
}

static void qq_sets_iorsetbits(u64 p, u64 q, i64 n) {
    u64 R1, R2, R3; 
	i64 av_1;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = 64;
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7412;
L7410:
	R1 = (u64)&q;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 8; asu64(R1) = asu64(R2);
	asi64(R1) = *toi64p(R1);
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 8; asu64(R2) = asu64(R3);
	*toi64p(R2) |= asi64(R1);
	if (--asi64(av_1)) goto L7410;
L7412:
	return;
}

static void qq_sets_ixorsetbits(u64 p, u64 q, i64 n) {
    u64 R1, R2, R3; 
	i64 av_1;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = 64;
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7416;
L7414:
	R1 = (u64)&q;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 8; asu64(R1) = asu64(R2);
	asi64(R1) = *toi64p(R1);
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 8; asu64(R2) = asu64(R3);
	*toi64p(R2) ^= asi64(R1);
	if (--asi64(av_1)) goto L7414;
L7416:
	return;
}

static void qq_sets_iandsetbits(u64 p, u64 q, i64 n) {
    u64 R1, R2, R3; 
	i64 av_1;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = 64;
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7420;
L7418:
	R1 = (u64)&q;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 8; asu64(R1) = asu64(R2);
	asi64(R1) = *toi64p(R1);
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 8; asu64(R2) = asu64(R3);
	*tou64p(R2) &= asu64(R1);
	if (--asi64(av_1)) goto L7418;
L7420:
	return;
}

static void qq_sets_inotsetbits(u64 p, i64 n) {
    u64 R1, R2; 
	i64 av_1;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = 64;
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7424;
L7422:
	asu64(R1) = p;
	asu64(R1) = *tou64p(R1);
	asu64(R1) = ~asu64(R1);
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 8;
	if (--asi64(av_1)) goto L7422;
L7424:
	return;
}

static void qq_sets_var_iorto_set(u64 x, u64 y) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	i64 xlen;
	i64 ylen;
	i64 n;
	i64 i;
	u64 p;
	u64 px;
	u64 py;
	u64 pp;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	py = asu64(R1);
	asu64(R1) = px;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	xlen = asi64(R1);
	asu64(R1) = py;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	ylen = asi64(R1);
	asi64(R1) = ylen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7427;
	goto L7426;
L7427:
	asi64(R1) = xlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7428;
	asu64(R1) = y;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = x;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = x;
	qq_sets_var_dupl_set(asu64(R1));
	goto L7426;
L7428:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asi64(R1) = ylen;
	asu64(R2) = x;
	qq_sets_iresizeset(asu64(R2), asi64(R1));
	asi64(R1) = ylen;
	asu64(R2) = py;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = px;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_sets_iorsetbits(asu64(R3), asu64(R2), asi64(R1));
L7426:
	return;
}

static void qq_sets_var_iandto_set(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	i64 xlen;
	i64 ylen;
	i64 n;
	i64 i;
	u64 p;
	u64 px;
	u64 py;
	u64 pp;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	py = asu64(R1);
	asu64(R1) = px;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	xlen = asi64(R1);
	asu64(R1) = py;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	ylen = asi64(R1);
	asi64(R1) = ylen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7431;
	asu64(R1) = x;
	qq_sets_var_emptyset(asu64(R1));
	goto L7430;
L7431:
	asi64(R1) = xlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7432;
	goto L7430;
L7432:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asi64(R1) = ylen;
	asu64(R2) = x;
	qq_sets_iresizeset(asu64(R2), asi64(R1));
	asi64(R1) = ylen;
	asu64(R2) = py;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = px;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_sets_iandsetbits(asu64(R3), asu64(R2), asi64(R1));
L7430:
	return;
}

static void qq_sets_var_ixorto_set(u64 x, u64 y) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	i64 xlen;
	i64 ylen;
	i64 n;
	i64 i;
	u64 p;
	u64 px;
	u64 py;
	u64 pp;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	py = asu64(R1);
	asu64(R1) = px;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	xlen = asi64(R1);
	asu64(R1) = py;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	ylen = asi64(R1);
	asi64(R1) = ylen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7435;
	asu64(R1) = x;
	qq_sets_var_emptyset(asu64(R1));
	goto L7434;
L7435:
	asi64(R1) = xlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7436;
	asu64(R1) = y;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = x;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = x;
	qq_sets_var_dupl_set(asu64(R1));
	goto L7434;
L7436:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asi64(R1) = ylen;
	asu64(R2) = x;
	qq_sets_iresizeset(asu64(R2), asi64(R1));
	asi64(R1) = ylen;
	asu64(R2) = py;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = px;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_sets_ixorsetbits(asu64(R3), asu64(R2), asi64(R1));
L7434:
	return;
}

static void qq_sets_var_inotto_set(u64 x) {
    u64 R1, R2, R3; 
	i64 xlen;
	u64 px;
	u64 py;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asu64(R1) = px;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	xlen = asi64(R1);
	asi64(R1) = xlen;
	if (!asi64(R1)) goto L7439;
	asi64(R1) = xlen;
	asu64(R2) = px;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	qq_sets_inotsetbits(asu64(R2), asi64(R1));
L7439:
	return;
}

static void qq_strings_start() {
    u64 R1, R2, R3; 
	asu64(R1) = qq_vars_obj_new();
	qq_strings_emptystring = asu64(R1);
	R1 = 1;
	asu64(R2) = qq_strings_emptystring;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = qq_strings_emptystring;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void qq_strings_var_empty_string(u64 dest, i64 mutable) {
    u64 R1, R2, R3; 
	R1 = 265;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mutable;
	if (asi64(R1)) goto L7443;
	asu64(R1) = qq_strings_emptystring;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = qq_strings_emptystring;
	(*tou32p(R1)) += 1;
	goto L7442;
L7443:
	R1 = 1;
	R2 = 0;
	R3 = 0;
	asu64(R1) = qq_strings_obj_make_stringn(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7442:
	return;
}

static void qq_strings_var_make_string(u64 s, u64 dest, i64 mutable) {
    u64 R1, R2, R3; 
	R1 = 265;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mutable;
	asu64(R2) = s;
	asu64(R1) = qq_strings_obj_make_string(asu64(R2), asi64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_strings_var_make_stringn(u64 s, i64 length, u64 dest, i64 mutable) {
    u64 R1, R2, R3; 
	R1 = 265;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mutable;
	asi64(R2) = length;
	asu64(R3) = s;
	asu64(R1) = qq_strings_obj_make_stringn(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 qq_strings_obj_new_string(i64 n) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = qq_vars_obj_new();
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L7448;
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L7448:
	asu64(R1) = p;
	goto L7446;
L7446:
	return asu64(R1);
}

static u64 qq_strings_obj_make_string(u64 s, i64 mutable) {
    u64 R1, R2, R3, R4; 
	u64 p;
	i64 n;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	asu64(R1) = qq_strings_obj_new_string(asi64(R1));
	p = asu64(R1);
	asi64(R1) = mutable;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L7451;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L7451:
	asu64(R1) = p;
	goto L7449;
L7449:
	return asu64(R1);
}

static u64 qq_strings_obj_make_stringn(u64 s, i64 length, i64 mutable) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asi64(R1) = length;
	asu64(R1) = qq_strings_obj_new_string(asi64(R1));
	p = asu64(R1);
	asi64(R1) = mutable;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L7454;
	asu64(R1) = s;
	if (!asu64(R1)) goto L7456;
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L7455;
L7456:
	asi64(R1) = length;
	R2 = 0;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memset(asu64(R3), asi32(R2), asu64(R1));
L7455:
L7454:
	asu64(R1) = p;
	goto L7452;
L7452:
	return asu64(R1);
}

static void qq_strings_obj_free_string(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L7459;
	asu64(R1) = p;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L7459:
	asu64(R1) = p;
	mlib_pcm_free32(asu64(R1));
	return;
}

static void qq_strings_var_dupl_string(u64 a) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_strings_obj_new_string(asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L7462;
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = q;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L7462:
	return;
}

static void qq_strings_var_getix_string(u64 a, i64 index) {
    u64 R1, R2, R3, R4; 
	u64 q;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asi64(R1) = index;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	asu64(R2) = q;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L7465;
	R1 = tou64("");
	R2 = tou64("getstring[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7465:
	asu64(R1) = a;
	asi64(R2) = index;
	asi64(R3) = index;
	asu64(R4) = a;
	qq_strings_stringslice(asu64(R4), asi64(R3), asi64(R2), asu64(R1));
	return;
}

static void qq_strings_var_getixref_string(u64 a, i64 index) {
    u64 R1, R2, R3; 
	u64 q;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asi64(R1) = index;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	asu64(R2) = q;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L7468;
	R1 = tou64("");
	R2 = tou64("getixref[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7468:
	R1 = 16;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 27;
	asu64(R2) = a;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = index;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_strings_var_getdotix_string(u64 a, i64 index) {
    u64 R1, R2, R3; 
	u64 q;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asi64(R1) = index;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	asu64(R2) = q;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L7471;
	R1 = tou64("");
	R2 = tou64("x.[] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7471:
	R1 = 1;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = index;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_strings_var_getdotixref_string(u64 a, i64 index, u64 dest) {
    u64 R1, R2, R3; 
	u64 q;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = (u64)&index;
	(*toi64p(R1)) -=1;
	asi64(R1) = index;
	asu64(R2) = q;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) < asu64(R2)) goto L7474;
	R1 = tou64("");
	R2 = tou64("x.[] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7474:
	R1 = 16;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 27;
	asu64(R2) = dest;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = index;
	R1 += (i64)R2;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_strings_var_getslice_string(u64 a, i64 i, i64 j) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7478;
	asi64(R1) = j;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L7478;
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) <= asi64(R2)) goto L7477;
L7478:
	R1 = tou64("");
	R2 = tou64("string/slice bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7477:
	asu64(R1) = a;
	asi64(R2) = j;
	asi64(R3) = i;
	asu64(R4) = a;
	qq_strings_stringslice(asu64(R4), asi64(R3), asi64(R2), asu64(R1));
	return;
}

static void qq_strings_stringslice(u64 a, i64 i, i64 j, u64 dest) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = qq_vars_obj_new();
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = q;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = j;
	asi64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = q;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = q;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7481;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7482;
	goto L7483;
L7481:
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
	goto L7480;
L7482:
	R1 = 0;
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2;
	asu64(R2) = q;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L7480;
L7483:
	asu64(R1) = p;
	(*tou32p(R1)) += 1;
	asu64(R1) = p;
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7480:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = q;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_strings_var_putix_string(u64 a, i64 index, u64 x) {
    u64 R1, R2, R3; 
	u64 s;
	u64 p;
	u64 q;
	i64 length;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L7486;
	qq_lib_pcnotmut();
L7486:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asi64(R1) = index;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7489;
	asi64(R2) = length;
	if (asi64(R1) <= asi64(R2)) goto L7488;
L7489:
	asi64(R1) = index;
	asi64(R2) = length;
	R3 = 1;
	asi64(R2) += asi64(R3);
	if (asi64(R1) != asi64(R2)) goto L7491;
	asu64(R1) = x;
	asu64(R2) = a;
	qq_strings_var_addto_string(asu64(R2), asu64(R1));
	goto L7484;
	goto L7490;
L7491:
	R1 = tou64("");
	R2 = tou64("putstring[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7490:
L7488:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = index;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	s = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7493;
	R1 = tou64("");
	R2 = tou64("s[i]:= not str");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7493:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7495;
	R1 = tou64("");
	R2 = tou64("s[i]:=\"\"");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7495:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
L7484:
	return;
}

static void qq_strings_var_putslice_string(u64 a, i64 i, i64 j, u64 x) {
    u64 R1, R2, R3; 
	u64 s;
	u64 p;
	u64 q;
	i64 length;
	i64 sublength;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L7498;
	qq_lib_pcnotmut();
L7498:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7501;
	asi64(R1) = j;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L7501;
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) <= asi64(R2)) goto L7500;
L7501:
	R1 = tou64("");
	R2 = tou64("string/slice bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7500:
	asi64(R1) = j;
	asi64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	sublength = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	s = asu64(R1);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7503;
	R1 = tou64("");
	R2 = tou64("s[i..j]:= not str");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7503:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = sublength;
	if (asi64(R1) >= asi64(R2)) goto L7505;
	R1 = tou64("");
	R2 = tou64("substr too short");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7505:
	asi64(R1) = sublength;
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void qq_strings_var_putdotix_string(u64 a, i64 index, u64 x) {
    u64 R1, R2, R3; 
	u64 s;
	u64 p;
	u64 q;
	i64 length;
	i64 ch;
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7508;
	R1 = tou64("");
	R2 = tou64("s.[i]:= not int");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7508:
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	ch = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L7510;
	qq_lib_pcnotmut();
L7510:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	asi64(R1) = index;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7513;
	asi64(R2) = length;
	if (asi64(R1) <= asi64(R2)) goto L7512;
L7513:
	asi64(R1) = index;
	asi64(R2) = length;
	R3 = 1;
	asi64(R2) += asi64(R3);
	if (asi64(R1) != asi64(R2)) goto L7515;
	asi64(R1) = ch;
	asu64(R2) = a;
	qq_strings_var_addto_string_ch(asu64(R2), asi64(R1));
	goto L7506;
	goto L7514;
L7515:
	R1 = tou64("");
	R2 = tou64("str.[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7514:
L7512:
	asi64(R1) = ch;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = index;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
L7506:
	return;
}

static void qq_strings_obj_resize_string(u64 p, i64 n) {
    u64 R1, R2, R3; 
	u64 s;
	i64 oldalloc;
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L7518;
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L7517;
L7518:
	asu64(R1) = p;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	oldalloc = asi64(R1);
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	s = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L7520;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = oldalloc;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L7520:
	asu64(R1) = s;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L7517:
	return;
}

static void qq_strings_var_add_string(u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	u64 p;
	u64 q;
	u64 r;
	i64 alen;
	i64 blen;
	i64 newlen;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	alen = asi64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	blen = asi64(R1);
	asi64(R1) = blen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7523;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
	goto L7521;
	goto L7522;
L7523:
	asi64(R1) = alen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7524;
	R1 = 1;
	asu64(R2) = a;
	asi64(R3) = blen;
	asu64(R4) = q;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	goto L7521;
L7524:
L7522:
	asi64(R1) = alen;
	asi64(R2) = blen;
	asi64(R1) += asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	asu64(R1) = qq_strings_obj_new_string(asi64(R1));
	r = asu64(R1);
	asi64(R1) = alen;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = r;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = blen;
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = r;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R4) = alen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = r;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7521:
	return;
}

static void qq_strings_var_addto_string(u64 a, u64 b) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	u64 p;
	u64 q;
	i64 alen;
	i64 blen;
	i64 newlen;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	alen = asi64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	blen = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L7527;
	qq_lib_pcnotmut();
L7527:
	asi64(R1) = blen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7529;
	goto L7525;
	goto L7528;
L7529:
	asi64(R1) = alen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7530;
	asu64(R1) = a;
	qq_vars_var_unshareu(asu64(R1));
	asu64(R1) = b;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = a;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = a;
	qq_vars_var_duplu(asu64(R1));
	goto L7525;
L7530:
L7528:
	asi64(R1) = alen;
	asi64(R2) = blen;
	asi64(R1) += asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	asu64(R2) = p;
	qq_strings_obj_resize_string(asu64(R2), asi64(R1));
	asi64(R1) = blen;
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R4) = alen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L7525:
	return;
}

static void qq_strings_var_addto_string_ch(u64 a, i64 ch) {
    u64 R1, R2, R3; 
	u64 p;
	i64 alen;
	i64 n;
	struct $B32 str;
	u64 s;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	alen = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L7533;
	qq_lib_pcnotmut();
L7533:
	asi64(R1) = alen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = p;
	qq_strings_obj_resize_string(asu64(R2), asi64(R1));
	asi64(R1) = ch;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = alen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static i64 qq_strings_var_equal_string(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	i64 n;
	i64 res;
	u64 px;
	u64 py;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	py = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = py;
	if (asu64(R1) != asu64(R2)) goto L7536;
	R1 = 1;
	goto L7534;
L7536:
	asu64(R1) = px;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = py;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) == asi64(R2)) goto L7538;
	R1 = 0;
	goto L7537;
L7538:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7539;
	R1 = 1;
	goto L7537;
L7539:
	asi64(R1) = n;
	asu64(R2) = py;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = px;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R1) = mlib_eqbytes(asu64(R3), asu64(R2), asi64(R1));
L7537:
	goto L7534;
L7534:
	return asi64(R1);
}

static i64 qq_strings_var_compare_string(u64 x, u64 y) {
    u64 R1, R2, R3, R4, R5; 
	i64 res;
	u64 px;
	u64 py;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	py = asu64(R1);
	asu64(R1) = py;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = px;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = py;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = px;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asi64(R1) = qq_strings_cmpstring_len(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	res = asi64(R1);
	asi64(R1) = res;
	goto L7540;
L7540:
	return asi64(R1);
}

static i64 qq_strings_cmpstring_len(u64 s, u64 t, i64 slen, i64 tlen) {
    u64 R1, R2, R3; 
	asi64(R1) = slen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7543;
	asi64(R1) = tlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7545;
	R1 = 0;
	goto L7544;
L7545:
	R1 = -1;
L7544:
	goto L7542;
L7543:
	asi64(R1) = tlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7546;
	R1 = 1;
	goto L7542;
L7546:
	asi64(R1) = slen;
	asi64(R2) = tlen;
	if (asi64(R1) != asi64(R2)) goto L7548;
	asi64(R1) = slen;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7550;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asu64(R2) = t;
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	if (asu64(R1) >= asu64(R2)) goto L7552;
	R1 = -1;
	goto L7541;
	goto L7551;
L7552:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asu64(R2) = t;
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	if (asu64(R1) <= asu64(R2)) goto L7553;
	R1 = 1;
	goto L7541;
	goto L7551;
L7553:
	R1 = 0;
	goto L7541;
L7551:
L7550:
	asi64(R1) = slen;
	asu64(R2) = t;
	asu64(R3) = s;
	asi64(R1) = mlib_cmpstringn(asu64(R3), asu64(R2), asi64(R1));
	goto L7547;
L7548:
	asi64(R1) = tlen;
	asu64(R2) = t;
	asu64(R1) = qq_lib_convtostringz(asu64(R2), asi64(R1));
	asi64(R2) = slen;
	asu64(R3) = s;
	asu64(R2) = qq_lib_convtostringz(asu64(R3), asi64(R2));
	asi64(R1) = mlib_cmpstring(asu64(R2), asu64(R1));
L7547:
L7542:
	goto L7541;
L7541:
	return asi64(R1);
}

static i64 qq_strings_var_inx_string(u64 x, u64 y) {
    u64 R1, R2; 
	i64 xlen;
	i64 ylen;
	i64 result;
	i64 i;
	i64 j;
	i64 k;
	u64 sx;
	u64 sy;
	u64 px;
	u64 py;
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	py = asu64(R1);
	asu64(R1) = px;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	xlen = asi64(R1);
	asu64(R1) = py;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	ylen = asi64(R1);
	asi64(R1) = xlen;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7557;
	asi64(R1) = ylen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7556;
L7557:
	R1 = 0x8000000000000000;
	goto L7554;
L7556:
	asi64(R1) = ylen;
	asi64(R2) = xlen;
	asi64(R1) -= asi64(R2);
	k = asi64(R1);
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = k;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7560;
L7558:
	asu64(R1) = px;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	sx = asu64(R1);
	asu64(R1) = py;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	R1 += (i64)R2;
	sy = asu64(R1);
	R1 = 1;
	j = asi64(R1);
	asi64(R1) = xlen;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7563;
L7561:
	asu64(R1) = sx;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asu64(R2) = sy;
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	if (asu64(R1) == asu64(R2)) goto L7565;
	goto L7566;
L7565:
	R1 = (u64)&sx;
	(*tou64p(R1)) += 1;
	R1 = (u64)&sy;
	(*tou64p(R1)) += 1;
	j += 1; if (j <= xlen) goto L7561;
L7563:
	asi64(R1) = i;
	R2 = 1;
	asi64(R1) += asi64(R2);
	goto L7554;
// qq_strings.var_inx_string.nextpos:
L7566:
	i += 1; if (i <= k) goto L7558;
L7560:
	R1 = 0x8000000000000000;
	goto L7554;
L7554:
	return asi64(R1);
}

static void qq_strings_var_iconvcase(u64 a, u64 b, i64 upper) {
    u64 R1, R2, R3; 
	i64 i;
	i64 n;
	u64 s;
	u64 pa;
	i64 av_1;
	i64 av_2;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7569;
	asu64(R1) = b;
	asi64(R1) = qq_vars_var_getintvalue(asu64(R1));
	n = asi64(R1);
	goto L7568;
L7569:
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
L7568:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7571;
	R1 = tou64("");
	R2 = tou64("convcase/notstr");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7571:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7573;
	R1 = tou64("");
	R2 = tou64("CONVCASE N<0");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7573:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7575;
	goto L7567;
L7575:
	asi64(R1) = n;
	asu64(R2) = pa;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L7577;
	msysc_m$print_startcon();
	R1 = tou64("N=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("convcase/N?");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7577:
	asu64(R1) = pa;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asi64(R1) = upper;
	if (!asi64(R1)) goto L7579;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7582;
L7580:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L7580;
L7582:
	goto L7578;
L7579:
	asi64(R1) = n;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7585;
L7583:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = tolower(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_2)) goto L7583;
L7585:
L7578:
L7567:
	return;
}

static void qq_strings_var_makestrslicexobj(u64 s, i64 length, u64 dest) {
    u64 R1, R2, R3; 
	R1 = 265;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R1) = qq_strings_obj_make_strslicexobj(asu64(R2), asi64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 qq_strings_obj_make_strslicexobj(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 p;
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7589;
	R1 = 0;
	s = asu64(R1);
L7589:
	asu64(R1) = qq_vars_obj_new();
	p = asu64(R1);
	asu64(R1) = s;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 2;
	asu64(R2) = p;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L7587;
L7587:
	return asu64(R1);
}

static i64 qq_strings_var_asc(u64 a) {
    u64 R1, R2; 
	u64 p;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7592;
	R1 = tou64("");
	R2 = tou64("Asc:not str");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7592:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) >= asi64(R2)) goto L7594;
	R1 = tou64("");
	R2 = tou64("Asc:empty");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7594:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	goto L7590;
L7590:
	return asi64(R1);
}

static void qq_strings_var_new_string(u64 a, u64 b, u64 dest) {
    u64 R1, R2, R3, R4; 
	i64 length;
	i64 ch;
	asu64(R1) = a;
	asi64(R1) = qq_vars_var_getintvalue(asu64(R1));
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7597;
	R1 = tou64("");
	R2 = tou64("Length<0");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7597:
	R1 = 0;
	asu64(R2) = dest;
	asi64(R3) = length;
	R4 = 0;
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7599;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7600;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7601;
	goto L7602;
L7599:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	ch = asi64(R1);
	goto L7598;
L7600:
	asu64(R1) = b;
	asi64(R1) = qq_strings_var_asc(asu64(R1));
	ch = asi64(R1);
	goto L7598;
L7601:
	R1 = 32;
	ch = asi64(R1);
	goto L7598;
L7602:
	R1 = tou64("");
	R2 = tou64("Not int/str");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7598:
	asi64(R1) = length;
	if (!asi64(R1)) goto L7604;
	asi64(R1) = length;
	asi64(R2) = ch;
	asu64(R3) = dest;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memset(asu64(R3), asi32(R2), asu64(R1));
L7604:
	return;
}

static void qq_strings_var_new_stringn(i64 length, u64 dest) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7607;
	R1 = tou64("");
	R2 = tou64("Length<0");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7607:
	R1 = 0;
	asu64(R2) = dest;
	asi64(R3) = length;
	R4 = 0;
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_strings_var_mul_string(u64 a, i64 m) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	i64 i;
	i64 oldlen;
	i64 newlen;
	u64 newptr;
	u64 p;
	struct $B3 v;
	u64 pa;
	u64 s;
	i64 av_1;
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7610;
	R1 = tou64("");
	R2 = tou64("neg str mul");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L7609;
L7610:
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7611;
	R1 = 0;
	asu64(R2) = a;
	qq_strings_var_empty_string(asu64(R2), asi64(R1));
	goto L7608;
	goto L7609;
L7611:
	asi64(R1) = m;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7612;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
	goto L7608;
	goto L7609;
L7612:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pa = asu64(R1);
	asu64(R1) = pa;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	oldlen = asi64(R1);
	asi64(R1) = oldlen;
	if (!asi64(R1)) goto L7614;
	asi64(R1) = oldlen;
	asi64(R2) = m;
	asi64(R1) *= asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	asu64(R1) = qq_strings_obj_new_string(asi64(R1));
	R2 = (u64)&v;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 265;
	R2 = (u64)&v;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&v;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asi64(R1) = oldlen;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7616;
	asi64(R1) = m;
	asu64(R2) = pa;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	goto L7615;
L7616:
	asi64(R1) = m;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7619;
L7617:
	asi64(R1) = oldlen;
	asu64(R2) = pa;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = oldlen;
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	if (--asi64(av_1)) goto L7617;
L7619:
L7615:
	(R1_B3) = v;
	asu64(R2) = a;
	*(struct $B3*)(R2) = (R1_B3);
	goto L7613;
L7614:
	R1 = 0;
	asu64(R2) = a;
	qq_strings_var_empty_string(asu64(R2), asi64(R1));
	goto L7608;
L7613:
L7609:
L7608:
	return;
}

static void qq_strings_var_convert_string_list(u64 a, i64 t, u64 dest) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	i64 length;
	u64 s;
	i64 av_1;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	R1 = 1;
	asi64(R2) = length;
	asu64(R3) = dest;
	R4 = 0;
	qq_lists_var_make_list(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = dest;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7623;
L7621:
	R1 = 1;
	asu64(R2) = q;
	R3 = 1;
	asu64(R4) = s;
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&q;
	(*tou64p(R1)) += 16;
	if (--asi64(av_1)) goto L7621;
L7623:
	return;
}

static void qq_strings_var_expand_string(u64 a, u64 dest, i64 m) {
    u64 R1, R2, R3, R4; 
	u64 b;
	u64 c;
	u64 p;
	u64 s;
	i64 n;
	i64 av_1;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = dest;
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	R1 = 1;
	n = asi64(R1);
	asi64(R1) = m;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7627;
L7625:
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L7629;
	R1 = 0;
	asu64(R2) = dest;
	qq_strings_var_empty_string(asu64(R2), asi64(R1));
	goto L7628;
L7629:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 1;
	asu64(R4) = s;
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L7628:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	R1 = (u64)&dest;
	(*tou64p(R1)) -=16;
	if (--asi64(av_1)) goto L7625;
L7627:
	return;
}

static void qq_strings_var_makechar(i64 ch, u64 dest) {
    u64 R1, R2, R3, R4; 
	struct $B3 v;
	u64 str;
	u64 p;
	asi64(R1) = ch;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7633;
	R2 = 255;
	if (asi64(R1) <= asi64(R2)) goto L7632;
L7633:
	R1 = tou64("");
	R2 = tou64("chr range");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L7632:
	R1 = (u64)&qq_decls_chrtable;
	asi64(R2) = ch;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7635;
	asi64(R1) = ch;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&v;
	R3 = 1;
	R4 = (u64)&str;
	qq_strings_var_make_stringn(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&v;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	p = asu64(R2);
	R2 = (u64)&qq_decls_chrtable;
	asi64(R3) = ch;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
L7635:
	asu64(R1) = p;
	(*tou32p(R1)) += 1;
	R1 = 265;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 qq_syslibs_findsyslib(u64 filename) {
    u64 R1, R2; 
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	R1 = 15;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7639;
L7637:
	R1 = (u64)&qq_syslibs_syslibnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = filename;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7641;
	R1 = (u64)&qq_syslibs_libtext;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L7636;
L7641:
	i += 1; if (i <= av_1) goto L7637;
L7639:
	R1 = 0;
	goto L7636;
L7636:
	return asu64(R1);
}

static i64 qq_syslibs_loadsysmodule(u64 pm) {
    u64 R1, R2, R3; 
	u64 source;
	asu64(R1) = pm;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_syslibs_findsyslib(asu64(R1));
	source = asu64(R1);
	asu64(R1) = source;
	if (!asu64(R1)) goto L7644;
	asu64(R1) = source;
	asu64(R2) = pm;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = source;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = pm;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	goto L7643;
L7644:
	R1 = 0;
L7643:
	goto L7642;
L7642:
	return asi64(R1);
}

static void qq_tables_start() {
    u64 R1, R2, R3, R4; 
	i64 i;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 av_4;
	i64 av_5;
	i64 av_6;
	R1 = 1;
	i = asi64(R1);
	R1 = 27;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7648;
L7646:
	R1 = 1;
	R2 = (u64)&qq_tables_binopset;
	R3 = (u64)&qq_tables_d_binopset;
	asi64(R4) = i;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_exprstarterset;
	R3 = (u64)&qq_tables_d_binopset;
	asi64(R4) = i;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_1) goto L7646;
L7648:
	R1 = 1;
	i = asi64(R1);
	R1 = 7;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7651;
L7649:
	R1 = 1;
	R2 = (u64)&qq_tables_unaryopset;
	R3 = (u64)&qq_tables_d_unaryopset;
	asi64(R4) = i;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_exprstarterset;
	R3 = (u64)&qq_tables_d_unaryopset;
	asi64(R4) = i;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_2) goto L7649;
L7651:
	R1 = 1;
	i = asi64(R1);
	R1 = 26;
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7654;
L7652:
	R1 = 1;
	R2 = (u64)&qq_tables_exprstarterset;
	R3 = (u64)&qq_tables_d_exprstarterset;
	asi64(R4) = i;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_3) goto L7652;
L7654:
	R1 = 1;
	R2 = (u64)&qq_tables_exprendset;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_exprendset;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_exprendset;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_exprendset;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_exprendset;
	R3 = 79;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_exprendset;
	R3 = 87;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_exprendset;
	R3 = 85;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	i = asi64(R1);
	R1 = 10;
	av_4 = asi64(R1);
	asi64(R1) = av_4;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7657;
L7655:
	R1 = 1;
	R2 = (u64)&qq_tables_addopset;
	R3 = (u64)&qq_tables_d_addopset;
	asi64(R4) = i;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_4) goto L7655;
L7657:
	R1 = 1;
	i = asi64(R1);
	R1 = 7;
	av_5 = asi64(R1);
	asi64(R1) = av_5;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7660;
L7658:
	R1 = 1;
	R2 = (u64)&qq_tables_mulopset;
	R3 = (u64)&qq_tables_d_mulopset;
	asi64(R4) = i;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_5) goto L7658;
L7660:
	R1 = 1;
	i = asi64(R1);
	R1 = 6;
	av_6 = asi64(R1);
	asi64(R1) = av_6;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7663;
L7661:
	R1 = 1;
	R2 = (u64)&qq_tables_cmpopset;
	R3 = (u64)&qq_tables_d_cmpopset;
	asi64(R4) = i;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_6) goto L7661;
L7663:
	R1 = 0;
	i = asi64(R1);
L7664:
	R1 = (u64)&qq_tables_stdtypenames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&qq_tables_ttname;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = i;
	R2 = (u64)&qq_tables_ttbasetype;
	asi64(R3) = i;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = 1;
	R2 = (u64)&qq_tables_ttlower;
	asi64(R3) = i;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = (u64)&qq_tables_stdtypewidths;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_tables_ttbitwidth;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&qq_tables_stdtypewidths;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	asi64(R1) /= asi64(R2);
	R2 = (u64)&qq_tables_ttsize;
	asi64(R3) = i;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	i += 1; if (i <= 40) goto L7664;
	R1 = 40;
	qq_tables_ntypes = asi64(R1);
	return;
}

static void qq_show_printunit(u64 p, i64 level, u64 prefix, u64 dev) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 d;
	i64 t;
	i64 flags;
	u64 idname;
	i64 a;
	r32 x32;
	i64 i;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7669;
	goto L7667;
L7669:
	asu64(R1) = p;
	R2 = 4;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 16777215;
	asi64(R1) &= asi64(R2);
	qq_show_currlineno = asi64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	msysc_m$print_ptr_nf(asu64(R1));
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	asu64(R2) = prefix;
	asi64(R3) = level;
	asu64(R1) = qq_show_getprefix(asi64(R3), asu64(R2), asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&qq_tables_jtagnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	idname = asu64(R1);
	asu64(R1) = idname;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 106;
	if (asu64(R1) != asu64(R2)) goto L7671;
	R1 = (u64)&idname;
	(*tou64p(R1)) += 1;
L7671:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = idname;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L7673;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L7674;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L7675;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L7676;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L7677;
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L7678;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L7679;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7680;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7681;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L7681;
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L7681;
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L7681;
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L7681;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L7681;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L7681;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7681;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L7681;
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L7681;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L7681;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L7681;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L7682;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L7682;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L7682;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L7682;
	R2 = 78;
	if (asi64(R1) == asi64(R2)) goto L7682;
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L7683;
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L7683;
	R2 = 88;
	if (asi64(R1) == asi64(R2)) goto L7684;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L7685;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L7685;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L7685;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L7686;
	goto L7687;
L7673:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7689;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L7689:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_namenames;
	asu64(R2) = d;
	R3 = 124;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Module:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 4;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 24;
	R4 = 31;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_end();
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7691;
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L7691;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L7691:
	goto L7672;
L7674:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L7672;
L7675:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asi64(R1));
	msysc_m$print_end();
	goto L7672;
L7676:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\"#\"");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7672;
L7677:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("L");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7672;
L7678:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = (u64)&qq_tables_condnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7672;
L7679:
	R1 = 1;
	i = asi64(R1);
L7692:
	asu64(R1) = p;
	R2 = 24;
	R1 += (i64)R2;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7696;
	goto L7694;
L7696:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = (u64)&qq_tables_condnames;
	asu64(R2) = p;
	R3 = 24;
	R2 += (i64)R3;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	i += 1; if (i <= 4) goto L7692;
L7694:
	goto L7672;
L7680:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = (u64)&qq_pcltabs_pclnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7672;
L7681:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L7672;
L7682:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("<#>");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_pcltabs_pclnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 1;
	R1 += (i64)R2;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7672;
L7683:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("<#>");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_tables_mathsnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 3;
	R1 += (i64)R2;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7672;
L7684:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("P.LENGTH=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7672;
L7685:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = p;
	R3 = 24;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7672;
L7686:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = (u64)&qq_tables_hostfnnames;
	asu64(R2) = p;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 2;
	R1 += (i64)R2;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7672;
L7687:
L7672:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&qq_tables_jflags;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	flags = asi64(R1);
	asi64(R1) = flags;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7698;
	R1 = tou64("1");
	asi64(R2) = level;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R3) = p;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = dev;
	qq_show_printunitlist(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
L7698:
	asi64(R1) = flags;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L7700;
	R1 = tou64("2");
	asi64(R2) = level;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R3) = p;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = dev;
	qq_show_printunitlist(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
L7700:
L7667:
	return;
}

static void qq_show_printunitlist(u64 dev, u64 p, i64 level, u64 prefix) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7703;
	goto L7701;
L7703:
	goto L7705;
L7704:
	asu64(R1) = dev;
	asu64(R2) = prefix;
	asi64(R3) = level;
	asu64(R4) = p;
	qq_show_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L7705:
	asu64(R1) = p;
	if (asu64(R1)) goto L7704;
L7701:
	return;
}

static u64 qq_show_getprefix(i64 level, u64 prefix, u64 p) {
    u64 R1, R2, R3; 
	struct $B65 indentstr;
	struct $B70 modestr;
	i64 av_1;
	R1 = 0;
	R2 = (u64)&indentstr;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = level;
	R2 = 20;
	if (asi64(R1) <= asi64(R2)) goto L7709;
	R1 = 10;
	level = asi64(R1);
L7709:
	asi64(R1) = level;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7712;
L7710:
	R1 = tou64("- ");
	R2 = (u64)&indentstr;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	if (--asi64(av_1)) goto L7710;
L7712:
	asu64(R1) = qq_show_getlineinfok();
	R2 = (u64)&qq_show_getprefix_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&indentstr;
	R2 = (u64)&qq_show_getprefix_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = prefix;
	R2 = (u64)&qq_show_getprefix_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = prefix;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L7714;
	R1 = tou64(" ");
	R2 = (u64)&qq_show_getprefix_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L7714:
	R1 = (u64)&qq_show_getprefix_str;
	goto L7707;
L7707:
	return asu64(R1);
}

static u64 qq_show_getlineinfok() {
    u64 R1, R2; 
	R1 = tou64("z4");
	asi64(R2) = qq_show_currlineno;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&qq_show_getlineinfok_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&qq_show_getlineinfok_str;
	goto L7715;
L7715:
	return asu64(R1);
}

static void qq_show_printglobalsymbols(u64 f) {
    u64 R1, R2, R3; 
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC Global Symbol Table");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	asu64(R2) = qq_decls_stprogram;
	asu64(R3) = f;
	qq_show_printst(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void qq_show_printst(u64 f, u64 p, i64 level) {
    u64 R1, R2, R3; 
	u64 q;
	asi64(R1) = level;
	asu64(R2) = p;
	asu64(R3) = f;
	qq_show_printstrec(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L7719;
L7718:
	asi64(R1) = level;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = q;
	asu64(R3) = f;
	qq_show_printst(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L7719:
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7718;
	return;
}

static void qq_show_printstrec(u64 f, u64 p, i64 level) {
    u64 R1, R2, R3, R4, R5; struct $B68 R1_B68; 
	struct $B68 dd;
	u64 q;
	struct $B3 v;
	u64 d;
	i64 col;
	i64 offset;
	i64 n;
	struct $B16 str;
	u64 s;
	i64 av_1;
	u64 tab;
	R1 = (u64)&v;
	d = asu64(R1);
	R1 = 0;
	offset = asi64(R1);
	asi64(R1) = level;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7724;
L7722:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("    ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 4;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	R1 = 4;
	R2 = (u64)&col;
	*toi64p(R2) += asi64(R1);
	if (--asi64(av_1)) goto L7722;
L7724:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("-");
	R2 = 22;
	asi64(R3) = offset;
	asi64(R2) -= asi64(R3);
	asu64(R3) = p;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R1) = mlib_padstr(asu64(R3), asi64(R2), asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(".");
	R2 = 12;
	R3 = (u64)&qq_tables_namenames;
	asu64(R4) = p;
	R5 = 124;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8));
	asu64(R1) = mlib_padstr(asu64(R3), asi64(R2), asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 40;
	col = asi64(R1);
	asu64(R1) = p;
	(R1_B68) = *(struct $B68*)(R1);
	dd = (R1_B68);
	R1 = (u64)&dd;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 2;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L7726;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Imp ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7725;
L7726:
	R1 = (u64)&dd;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 1;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L7727;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = (u64)&dd;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 1;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	switch (asi64(R1)) {
	case 1: goto L7731;
	case 2: goto L7732;
	default: goto L7730;
    };
// SWITCH
L7731:
	R1 = tou64("Glob ");
	goto L7728;
L7732:
	R1 = tou64("Exp ");
	goto L7728;
L7730:
	R1 = tou64("Local ");
L7728:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L7727:
L7725:
	R1 = (u64)&dd;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L7734;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("byref ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L7734:
	R1 = (u64)&dd;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L7736;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("opt ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L7736:
	R1 = (u64)&dd;
	R2 = 114;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7738;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Modno:#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&dd;
	R2 = 114;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L7738:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("==========");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&dd;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7740;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("(#)");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&dd;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("-");
	R2 = 18;
	R3 = (u64)&str;
	asu64(R1) = mlib_padstr(asu64(R3), asi64(R2), asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7739;
L7740:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("-");
	R2 = 18;
	R3 = tou64("()");
	asu64(R1) = mlib_padstr(asu64(R3), asi64(R2), asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L7739:
	R1 = (u64)&dd;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7742;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7742;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7742;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L7742;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7743;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7744;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7745;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7745;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7745;
	goto L7746;
L7742:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Ix:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&dd;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&dd;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L7748;
	R1 = (u64)&dd;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7748;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("@");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&dd;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
L7748:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Offset:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&dd;
	R2 = 108;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7741;
L7743:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Offset:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&dd;
	R2 = 108;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" Ix:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&dd;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	goto L7741;
L7744:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Nfields:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&dd;
	R2 = 104;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7741;
L7745:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64(" Nparms:# ");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&dd;
	R2 = 104;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("DD.MISFUNC=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	R2 = (u64)&dd;
	R3 = 120;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 4;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_end();
	goto L7741;
L7746:
L7741:
	R1 = (u64)&dd;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7750;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7750;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L7750;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L7750;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7750;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L7750;
	goto L7751;
L7750:
	R1 = (u64)&dd;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7753;
	R1 = (u64)&dd;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
	R3 = 12;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L7755;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L7756;
	goto L7757;
L7755:
	R1 = tou64("::=");
	s = asu64(R1);
	goto L7754;
L7756:
	R1 = tou64(":=");
	s = asu64(R1);
	goto L7754;
L7757:
	R1 = tou64("=");
	s = asu64(R1);
L7754:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = s;
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&dd;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = qq_lib_strexpr(asu64(R1));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
L7753:
	goto L7749;
L7751:
L7749:
	R1 = (u64)&dd;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L7759;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Mode:#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = 0;
	R2 = (u64)&dd;
	R3 = 116;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = qq_show_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&dd;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L7759:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("          ");
	tab = asu64(R1);
	return;
}

static void qq_show_printtypetables(u64 f) {
    u64 R1, R2, R3; 
	u64 d;
	u64 p;
	i64 m;
	i64 i;
	msysc_m$print_startcon();
	R1 = tou64("PRINT TYPE TABLES");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = qq_tables_nuserxtypes;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC TYPE TABLES");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	m = asi64(R1);
	asi64(R1) = qq_tables_ntypes;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7763;
L7761:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("#: # ");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("3");
	asi64(R2) = m;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("jl12");
	R2 = (u64)&qq_tables_ttname;
	asi64(R3) = m;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&qq_tables_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\tST=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\tLen=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("Lower");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_ttlower;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\tSize=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\tBasetype=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&qq_tables_ttname;
	R2 = (u64)&qq_tables_ttbasetype;
	asi64(R3) = m;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\tTarget=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&qq_tables_ttname;
	R2 = (u64)&qq_tables_tttarget;
	asi64(R3) = m;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\tCaligned=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_ttcaligned;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&qq_tables_ttfields;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L7765;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\tFields:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L7767;
L7766:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t\t");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L7770;
	R1 = 0;
	asu64(R2) = d;
	R3 = 116;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = qq_show_strmode(asi64(R2), asi64(R1));
	goto L7769;
L7770:
	R1 = tou64("");
L7769:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L7767:
	asu64(R1) = d;
	if (asu64(R1)) goto L7766;
L7765:
	m += 1; if (m <= qq_tables_ntypes) goto L7761;
L7763:
	asu64(R1) = qq_tables_userxmodelist;
	p = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_tables_nuserxtypes;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7773;
L7771:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = i;
	asi64(R1) = -asi64(R1);
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&qq_tables_ttnamedefx;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= qq_tables_nuserxtypes) goto L7771;
L7773:
	return;
}

static void qq_show_showsttree() {
    u64 R1, R2, R3, R4; 
	u64 f;
	u64 m;
	u64 d;
	u64 g;
	u64 p;
	i64 i;
	asu8(R1) = qq_cli_fshowst;
	if (asu8(R1)) goto L7776;
	goto L7774;
L7776:
	R1 = tou64("w");
	R2 = tou64("ST");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	qq_show_printglobalsymbols(asu64(R1));
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Modules");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = qq_decls_nmodules;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7779;
L7777:
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	m = asu64(R1);
	asu64(R1) = m;
	if (!asu64(R1)) goto L7781;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = m;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("M.COMPILED=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = m;
	R2 = 43;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("M.PCSTART=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = m;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	R1 = tou64("M.PCSIZE=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = m;
	R2 = 72;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L7780;
L7781:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("MODULE");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("MISSING");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L7780:
	i += 1; if (i <= qq_decls_nmodules) goto L7777;
L7779:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC Global GenField Table");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = qq_decls_ngenfields;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_ngenfields;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7784;
L7782:
	R1 = (u64)&qq_decls_genfieldtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	g = asu64(R1);
	asu64(R1) = g;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7786;
	goto L7783;
L7786:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("   #) #:");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = g;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L7788;
L7787:
	asu64(R1) = g;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("      ");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_tables_namenames;
	asu64(R2) = d;
	R3 = 124;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = g;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	g = asu64(R1);
L7788:
	asu64(R1) = g;
	if (asu64(R1)) goto L7787;
L7783:
	i += 1; if (i <= qq_decls_ngenfields) goto L7782;
L7784:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("DLL Table");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = qq_decls_nlibfiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nlibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7792;
L7790:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_decls_libtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	R2 = (u64)&qq_decls_dllinsttable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	msysc_m$print_u64(asu64(R2), asi64(R1));
	R1 = tou64("c");
	R2 = (u64)&qq_decls_libtypes;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= qq_decls_nlibfiles) goto L7790;
L7792:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("DLL Proc Table");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = qq_decls_ndllprocs;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_ndllprocs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7795;
L7793:
	R1 = (u64)&qq_decls_dllproctable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_decls_dllproclibindex;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&qq_decls_dllprocaddr;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_ptr_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 120;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 8;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L7797;
	R1 = tou64("Variadic");
	goto L7796;
L7797:
	R1 = tou64("");
L7796:
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("c");
	R2 = (u64)&qq_decls_libtypes;
	R3 = (u64)&qq_decls_dllproclibindex;
	asi64(R4) = i;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("D.INDEX=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("DLLPROCTABLE[D.INDEX]=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_decls_dllproctable;
	asu64(R2) = d;
	R3 = 96;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_ptr_nf(asu64(R1));
	R1 = tou64("D=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= qq_decls_ndllprocs) goto L7793;
L7795:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("All Proc Table");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = qq_decls_nproclist;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = qq_decls_proclist;
	p = asu64(R1);
	goto L7799;
L7798:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Proc:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L7799:
	asu64(R1) = p;
	if (asu64(R1)) goto L7798;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L7774:
	return;
}

static void qq_show_showtypes() {
    u64 R1, R2; 
	u64 f;
	u64 m;
	asu8(R1) = qq_cli_fshowtypes;
	if (asu8(R1)) goto L7803;
	goto L7801;
L7803:
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L7805;
	goto L7801;
L7805:
	R1 = tou64("w");
	R2 = tou64("TYPES");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	qq_show_printtypetables(asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L7801:
	return;
}

static void qq_show_showast(u64 sp, u64 file) {
    u64 R1, R2; 
	u64 f;
	u64 pm;
	u64 d;
	i64 k;
	i64 i;
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L7808;
	goto L7806;
L7808:
	R1 = tou64("w");
	asu64(R2) = file;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	if (asu64(R1)) goto L7810;
	goto L7806;
L7810:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = file;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = sp;
	if (!asu64(R1)) goto L7812;
	asu64(R1) = sp;
	asu64(R2) = f;
	qq_show_showast2(asu64(R2), asu64(R1));
	goto L7811;
L7812:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nsubprogs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7815;
L7813:
	R1 = (u64)&qq_decls_subprogs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = f;
	qq_show_showast2(asu64(R2), asu64(R1));
	i += 1; if (i <= qq_decls_nsubprogs) goto L7813;
L7815:
L7811:
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L7806:
	return;
}

static void qq_show_showast2(u64 f, u64 sp) {
    u64 R1, R2, R3, R4, R5; 
	u64 pm;
	u64 d;
	u64 e;
	i64 k;
	i64 i;
	i64 av_1;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Proc Subprog");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = sp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": ******\n");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = sp;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	i = asi64(R1);
	asu64(R1) = sp;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	av_1 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_1;
	if (asi64(R1) > asi64(R2)) goto L7819;
L7817:
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Module:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = pm;
	R5 = 48;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	qq_show_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = pm;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L7823;
L7820:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L7825;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\n---PROC");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = d;
	R5 = 88;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	qq_show_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L7829;
L7826:
	asu64(R1) = e;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L7831;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\n---ANONPROC");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("ANON");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = e;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = e;
	R5 = 88;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	qq_show_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
L7831:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L7829:
	asu64(R1) = e;
	if (asu64(R1)) goto L7826;
L7825:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L7823:
	asu64(R1) = d;
	if (asu64(R1)) goto L7820;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= av_1) goto L7817;
L7819:
	return;
}

static void qq_show_showlogfile() {
    u64 R1, R2, R3; 
	struct $B16 str;
	u64 logdev;
	asu8(R1) = qq_cli_fshowpcl1;
	R1 = toi64(tou8(R1));
	asu8(R2) = qq_cli_fshowpcl2;
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu8(R2) = qq_cli_fshowast1;
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu8(R2) = qq_cli_fshowast2;
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu8(R2) = qq_cli_fshowst;
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu8(R2) = qq_cli_fshowtypes;
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu8(R2) = qq_cli_fshowmodules;
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu8(R2) = qq_cli_fshowstflat;
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7834;
	goto L7832;
L7834:
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L7836;
	goto L7832;
L7836:
	msysc_m$print_startcon();
	R1 = tou64("PRESS KEY");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = mwindows_os_getch();
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L7838;
	R1 = 0;
	exit(R1);
L7838:
	asu8(R1) = qq_cli_fshowst;
	if (!asu8(R1)) goto L7840;
	qq_show_showsttree();
L7840:
	asu8(R1) = qq_cli_fshowstflat;
	if (!asu8(R1)) goto L7842;
	qq_show_showstflat();
L7842:
	asu8(R1) = qq_cli_fshowtypes;
	if (!asu8(R1)) goto L7844;
	qq_show_showtypes();
L7844:
	R1 = tou64("w");
	R2 = tou64("qq.log");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	logdev = asu64(R1);
	asu8(R1) = qq_cli_fshowmodules;
	if (!asu8(R1)) goto L7846;
	asu64(R1) = logdev;
	qq_show_showmoduleinfo(asu64(R1));
L7846:
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L7848;
	asu8(R1) = qq_cli_fshowpcl2;
	if (!asu8(R1)) goto L7848;
	asu64(R1) = logdev;
	R2 = tou64("PCL2");
	qq_show_addtolog(asu64(R2), asu64(R1));
L7848:
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L7850;
	asu8(R1) = qq_cli_fshowpcl1;
	if (!asu8(R1)) goto L7850;
	asu64(R1) = logdev;
	R2 = tou64("PCL1");
	qq_show_addtolog(asu64(R2), asu64(R1));
L7850:
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) < asi64(R2)) goto L7852;
	asu8(R1) = qq_cli_fshowast2;
	if (!asu8(R1)) goto L7852;
	asu64(R1) = logdev;
	R2 = tou64("AST2");
	qq_show_addtolog(asu64(R2), asu64(R1));
L7852:
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L7854;
	asu8(R1) = qq_cli_fshowast1;
	if (!asu8(R1)) goto L7854;
	asu64(R1) = logdev;
	R2 = tou64("AST1");
	qq_show_addtolog(asu64(R2), asu64(R1));
L7854:
	asu8(R1) = qq_cli_fshowst;
	if (!asu8(R1)) goto L7856;
	asu64(R1) = logdev;
	R2 = tou64("ST");
	qq_show_addtolog(asu64(R2), asu64(R1));
L7856:
	asu8(R1) = qq_cli_fshowstflat;
	if (!asu8(R1)) goto L7858;
	asu64(R1) = logdev;
	R2 = tou64("STFLAT");
	qq_show_addtolog(asu64(R2), asu64(R1));
L7858:
	asu8(R1) = qq_cli_fshowtypes;
	if (!asu8(R1)) goto L7860;
	asu64(R1) = logdev;
	R2 = tou64("TYPES");
	qq_show_addtolog(asu64(R2), asu64(R1));
L7860:
	asu64(R1) = logdev;
	asi32(R1) = fclose(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("c:/m/scripts/med.bat #");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("qq.log");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = 0;
	R3 = (u64)&str;
	asi64(R1) = mwindows_os_execwait(asu64(R3), asi64(R2), asu64(R1));
L7832:
	return;
}

static void qq_show_addtolog(u64 filename, u64 logdest) {
    u64 R1, R2; 
	u64 f;
	i64 c;
	R1 = tou64("rb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7863;
	goto L7861;
L7863:
L7864:
	asu64(R1) = f;
	asi32(R1) = fgetc(asu64(R1));
	R1 = toi64(toi32(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L7867;
	goto L7865;
L7867:
	asu64(R1) = logdest;
	asi64(R2) = c;
	asi32(R1) = fputc(asi32(R2), asu64(R1));
	goto L7864;
L7865:
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L7861:
	return;
}

static void qq_show_showstflat() {
    u64 R1, R2, R3, R4; 
	u64 f;
	u64 p;
	i64 sym;
	i64 av_1;
	i64 i;
	asu8(R1) = qq_cli_fshowstflat;
	if (asu8(R1)) goto L7870;
	goto L7868;
L7870:
	R1 = tou64("w");
	R2 = tou64("STFLAT");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("GLOBAL FLAT SYMBOL TABLE:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	i = asi64(R1);
	R1 = 32766;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L7873;
L7871:
	R1 = (u64)&qq_lex_hashtable;
	asi64(R2) = i;
	R1 += (i64)R2*128;
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7875;
	asu64(R1) = p;
	R2 = 123;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L7877;
	goto L7878;
L7877:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = p;
	msysc_m$print_ptr_nf(asu64(R1));
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("m");
	R2 = (u64)&qq_tables_symbolnames;
	asu64(R3) = p;
	R4 = 123;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	msysc_m$print_u64(asu64(R2), asu64(R1));
	R1 = (u64)&qq_tables_namenames;
	asu64(R2) = p;
	R3 = 124;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L7880;
L7879:
	asu64(R1) = p;
	R2 = 123;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	sym = asi64(R1);
	asi64(R1) = sym;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7883;
	R1 = 1;
	sym = asi64(R1);
L7883:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	msysc_m$print_ptr_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("m");
	R2 = (u64)&qq_tables_symbolnames;
	asi64(R3) = sym;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	msysc_m$print_u64(asu64(R2), asu64(R1));
	R1 = (u64)&qq_tables_namenames;
	asu64(R2) = p;
	R3 = 124;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("(From");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7885;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L7884;
L7885:
	R1 = tou64("-");
L7884:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(")");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L7880:
	asu64(R1) = p;
	if (asu64(R1)) goto L7879;
	goto L7876;
L7878:
L7876:
L7875:
	i += 1; if (i <= av_1) goto L7871;
L7873:
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L7868:
	return;
}

static void qq_show_showmoduleinfo(u64 dev) {
    u64 R1, R2, R3; 
	u64 pm;
	u64 ps;
	i64 av_1;
	u64 d;
	u64 id;
	i64 i;
	i64 j;
// PROC LOCAL STATICS GO HERE
	static u64 qq_show_showmoduleinfo_tab = (u64)"    ";
	msysc_m$print_startcon();
	R1 = tou64("SMI0");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Project Structure:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("---------------------------------------");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Modules");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = qq_decls_nmodules;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7889;
L7887:
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = qq_show_showmoduleinfo_tab;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("2");
	asi64(R2) = i;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("16jl");
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = tou64("Lead:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pm;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("Sys:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pm;
	R2 = 41;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("Path:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Sub:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&qq_decls_subprogs;
	asu64(R2) = pm;
	R3 = 44;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("File:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pm;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= qq_decls_nmodules) goto L7887;
L7889:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Subprograms");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = qq_decls_nsubprogs;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nsubprogs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7892;
L7890:
	R1 = (u64)&qq_decls_subprogs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ps = asu64(R1);
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = qq_show_showmoduleinfo_tab;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = ps;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Sys:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = ps;
	R2 = 30;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("Path:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = ps;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Spec:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = ps;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Comp:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = ps;
	R2 = 28;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = ps;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L7894;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = qq_show_showmoduleinfo_tab;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = qq_show_showmoduleinfo_tab;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = ps;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = ps;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = ps;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	j = asi64(R1);
	asu64(R1) = ps;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	av_1 = asi64(R1);
	asi64(R1) = j;
	asi64(R2) = av_1;
	if (asi64(R1) > asi64(R2)) goto L7897;
L7895:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = (u64)&qq_decls_modules;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	j += 1; if (j <= av_1) goto L7895;
L7897:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L7894:
	i += 1; if (i <= qq_decls_nsubprogs) goto L7890;
L7892:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = qq_decls_stprogram;
	if (asu64(R1)) goto L7899;
	goto L7886;
L7899:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Symboltable:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = qq_decls_stprogram;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L7903;
L7900:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7905;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7906;
	goto L7907;
L7905:
	R1 = tou64("Mod");
	id = asu64(R1);
	goto L7904;
L7906:
	R1 = tou64("Sub");
	id = asu64(R1);
	goto L7904;
L7907:
	R1 = tou64("---");
	id = asu64(R1);
L7904:
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("    # # (m#, s#)");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = id;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 114;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = d;
	R2 = 115;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L7903:
	asu64(R1) = d;
	if (asu64(R1)) goto L7900;
	asu64(R1) = dev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L7886:
	return;
}

static void qq_show_printsymbol(u64 lp) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	struct $B3 l;
	asu64(R1) = lp;
	(R1_B3) = *(struct $B3*)(R1);
	l = (R1_B3);
	msysc_m$print_startcon();
	R1 = tou64("m 18 jl");
	R2 = (u64)&qq_tables_symbolnames;
	R3 = (u64)&l;
	R4 = 12;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	msysc_m$print_u64(asu64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&l;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L7910;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L7911;
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L7912;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L7913;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L7914;
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L7915;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7916;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L7916;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7916;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L7916;
	goto L7917;
L7910:
	R1 = (u64)&l;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 126;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&l;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L7909;
L7911:
	R1 = (u64)&l;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7919;
	goto L7920;
L7919:
	msysc_m$print_startcon();
	R1 = (u64)&l;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("int");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7918;
L7920:
	msysc_m$print_startcon();
	R1 = (u64)&l;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L7918:
	goto L7909;
L7912:
	msysc_m$print_startcon();
	R1 = 0;
	R2 = (u64)&l;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asi64(R1));
	msysc_m$print_end();
	goto L7909;
L7913:
	msysc_m$print_startcon();
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	R1 = (u64)&l;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_printstr(asu64(R1));
	msysc_m$print_startcon();
	msysc_m$print_space();
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7909;
L7914:
	msysc_m$print_startcon();
	R1 = tou64("'");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	R1 = (u64)&l;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_printstr(asu64(R1));
	msysc_m$print_startcon();
	msysc_m$print_space();
	R1 = tou64("'");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7909;
L7915:
	R1 = (u64)&l;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_printstr(asu64(R1));
	msysc_m$print_startcon();
	R1 = tou64("L");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7909;
L7916:
	msysc_m$print_startcon();
	R1 = (u64)&qq_tables_jtagnames;
	R2 = (u64)&l;
	R3 = 13;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7909;
L7917:
	R1 = (u64)&l;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7922;
	msysc_m$print_startcon();
	R1 = tou64("#");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&l;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L7922:
L7909:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static u64 qq_show_strmode(i64 t, i64 expand) {
    u64 R1, R2, R3; 
	asi64(R1) = expand;
	R2 = (u64)&qq_show_strmode_str;
	asi64(R3) = t;
	qq_show_istrmode(asi64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&qq_show_strmode_str;
	goto L7923;
L7923:
	return asu64(R1);
}

static void qq_show_istrmode(i64 t, u64 dest, i64 expand) {
    u64 R1, R2, R3, R4; 
	u64 d;
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L7926;
	R1 = tou64("*");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&qq_tables_ttnamedefx;
	asi64(R2) = t;
	asi64(R2) = -asi64(R2);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L7924;
L7926:
	asi64(R1) = t;
	R2 = 40;
	if (asi64(R1) >= asi64(R2)) goto L7928;
	R1 = (u64)&qq_tables_ttname;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L7924;
L7928:
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L7930;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7931;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7932;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7933;
	goto L7934;
L7930:
	R1 = tou64("ref ");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	asu64(R3) = dest;
	asi64(R3) = strlen(asu64(R3));
	R2 += (i64)R3;
	R3 = (u64)&qq_tables_tttarget;
	asi64(R4) = t;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	qq_show_istrmode(asi64(R3), asu64(R2), asi64(R1));
	goto L7929;
L7931:
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[#..#]");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_tables_ttlower;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&qq_tables_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&qq_tables_ttlower;
	asi64(R3) = t;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = 0;
	asu64(R2) = dest;
	asu64(R3) = dest;
	asi64(R3) = strlen(asu64(R3));
	R2 += (i64)R3;
	R3 = (u64)&qq_tables_tttarget;
	asi64(R4) = t;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	qq_show_istrmode(asi64(R3), asu64(R2), asi64(R1));
	goto L7929;
L7932:
	asi64(R1) = expand;
	if (asi64(R1)) goto L7936;
	goto L7937;
L7936:
	R1 = tou64("struct(");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
// qq_show.istrmode.dostruct:
L7938:
	R1 = (u64)&qq_tables_ttfields;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	goto L7942;
L7939:
	R1 = 0;
	asu64(R2) = dest;
	asu64(R3) = dest;
	asi64(R3) = strlen(asu64(R3));
	R2 += (i64)R3;
	asu64(R3) = d;
	R4 = 116;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	qq_show_istrmode(asi64(R3), asu64(R2), asi64(R1));
	R1 = tou64(" ");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7944;
	R1 = tou64(", ");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L7944:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L7942:
	asu64(R1) = d;
	if (asu64(R1)) goto L7939;
	R1 = tou64(")");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L7929;
L7933:
	asi64(R1) = expand;
	if (asi64(R1)) goto L7946;
	goto L7937;
L7946:
	R1 = tou64("record(");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L7938;
	goto L7929;
L7934:
// qq_show.istrmode.$else:
L7937:
	R1 = (u64)&qq_tables_ttname;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L7929:
L7924:
	return;
}

static void qq_show_deletetempfiles() {
    u64 R1; 
	R1 = tou64("PCL1");
	asi32(R1) = remove(asu64(R1));
	R1 = tou64("PCL2");
	asi32(R1) = remove(asu64(R1));
	R1 = tou64("PCL3");
	asi32(R1) = remove(asu64(R1));
	R1 = tou64("AST1");
	asi32(R1) = remove(asu64(R1));
	R1 = tou64("AST2");
	asi32(R1) = remove(asu64(R1));
	R1 = tou64("TYPES");
	asi32(R1) = remove(asu64(R1));
	R1 = tou64("STFLAT");
	asi32(R1) = remove(asu64(R1));
	R1 = tou64("ST");
	asi32(R1) = remove(asu64(R1));
	return;
}

static void qq_showpcl_writepcl(u64 pcstart, u64 pc, u64 pclsource, i64 pass, u64 sourcecode) {
    u64 R1, R2, R3, R4; 
	struct $B25 str;
	i64 cmdcode;
	i64 a;
	i64 soffset;
	i64 moduleno;
	i64 offset;
	i64 attrs;
	u64 d;
	i64 av_1;
	asu64(R1) = pc;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cmdcode = asi64(R1);
	asi64(R1) = cmdcode;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7950;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7951;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7952;
	goto L7953;
L7950:
	goto L7948;
	goto L7949;
L7951:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_showpcl_currpclproc = asu64(R1);
	R1 = tou64("!      ----------");
	qq_showpcl_gstr(asu64(R1));
	R1 = tou64("Procdef:");
	qq_showpcl_gstr(asu64(R1));
	asu64(R1) = qq_showpcl_currpclproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_showpcl_gstr(asu64(R1));
	qq_showpcl_gline();
	goto L7948;
	goto L7949;
L7952:
	R1 = tou64("!      ----------");
	qq_showpcl_gstr(asu64(R1));
	asu64(R1) = pc;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L7955;
	R1 = tou64("<LABEL>");
	qq_showpcl_gstr(asu64(R1));
L7955:
	R1 = tou64("End");
	qq_showpcl_gstrln(asu64(R1));
	goto L7948;
	goto L7949;
L7953:
L7949:
	asu64(R1) = pc;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L7957;
	R1 = tou64("                 ");
	qq_showpcl_gstr(asu64(R1));
	asu64(R1) = pc;
	asu64(R2) = pcstart;
	qq_showpcl_glabeldef(asu64(R2), asu64(R1));
L7957:
	asu64(R1) = pcstart;
	asu64(R2) = pc;
	asi64(R1) = qq_lib_getpcloffset(asu64(R2), asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	offset = asi64(R1);
	asu64(R1) = pclsource;
	asi64(R2) = offset;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	soffset = asi64(R1);
	asi64(R1) = soffset;
	R2 = 16777215;
	asi64(R1) &= asi64(R2);
	qq_showpcl_currlineno = asi64(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#: [#]: ");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("4");
	asu64(R2) = pcstart;
	asu64(R3) = pc;
	asi64(R2) = qq_lib_getpcloffset(asu64(R3), asu64(R2));
	R3 = 1;
	asi64(R2) += asi64(R3);
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("05jr");
	asi64(R2) = qq_showpcl_currlineno;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	qq_showpcl_gstr(asu64(R1));
	asi64(R1) = cmdcode;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7959;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7960;
	goto L7961;
L7959:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_showpcl_currpclproc = asu64(R1);
	goto L7948;
	goto L7958;
L7960:
	R1 = tou64("! ");
	qq_showpcl_gstr(asu64(R1));
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_showpcl_gstrln(asu64(R1));
	goto L7948;
	goto L7958;
L7961:
L7958:
	R1 = 0;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = pc;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L7963;
	R1 = tou64("*");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L7963:
	R1 = (u64)&qq_pcltabs_pclnames;
	asi64(R2) = cmdcode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 1;
	R1 += (i64)R2;
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 1;
	a = asi64(R1);
	R1 = 45;
	R2 = 7;
	R3 = tou64(" ");
	asu64(R4) = qq_show_pcldest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = 32;
	R2 = 11;
	R3 = (u64)&str;
	asu64(R4) = qq_show_pcldest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&qq_pcltabs_pclopnd;
	asi64(R2) = cmdcode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7965;
	asi64(R1) = pass;
	asu64(R2) = pc;
	asu64(R3) = pcstart;
	asu64(R1) = qq_showpcl_writepclopnd(asu64(R3), asu64(R2), asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	qq_showpcl_gstr(asu64(R1));
	R1 = tou64(" ");
	qq_showpcl_gstr(asu64(R1));
L7965:
	R1 = (u64)&qq_pcltabs_pclattrs;
	asi64(R2) = cmdcode;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	attrs = asi64(R1);
	asi64(R1) = attrs;
	R2 = 538976288;
	if (asi64(R1) == asi64(R2)) goto L7967;
	R1 = tou64("<");
	qq_showpcl_gstr(asu64(R1));
	R1 = 4;
	av_1 = asi64(R1);
L7968:
	asi64(R1) = attrs;
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L7972;
	R2 = 110;
	if (asu64(R1) == asu64(R2)) goto L7973;
	R2 = 98;
	if (asu64(R1) == asu64(R2)) goto L7973;
	R2 = 120;
	if (asu64(R1) == asu64(R2)) goto L7974;
	R2 = 121;
	if (asu64(R1) == asu64(R2)) goto L7975;
	R2 = 99;
	if (asu64(R1) == asu64(R2)) goto L7976;
	R2 = 117;
	if (asu64(R1) == asu64(R2)) goto L7977;
	R2 = 118;
	if (asu64(R1) == asu64(R2)) goto L7978;
	goto L7979;
L7972:
	goto L7970;
	goto L7971;
L7973:
	asu64(R1) = pc;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	qq_showpcl_gstrint(asi64(R1));
	goto L7971;
L7974:
	asu64(R1) = pc;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	qq_showpcl_gstrint(asi64(R1));
	goto L7971;
L7975:
	asu64(R1) = pc;
	R2 = 14;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	qq_showpcl_gstrint(asi64(R1));
	goto L7971;
L7976:
	R1 = (u64)&qq_tables_condnames;
	asu64(R2) = pc;
	R3 = 9;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	qq_showpcl_gstr(asu64(R1));
	goto L7971;
L7977:
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	qq_showpcl_gstr(asu64(R1));
	goto L7971;
L7978:
	R1 = (u64)&qq_tables_ttname;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	qq_showpcl_gstr(asu64(R1));
	goto L7971;
L7979:
L7971:
	R1 = 8;
	R2 = (u64)&attrs;
	*toi64p(R2) >>= asi64(R1);
	asi64(R1) = attrs;
	R2 = 255;
	asi64(R1) &= asi64(R2);
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L7981;
	R1 = tou64(" ");
	qq_showpcl_gstr(asu64(R1));
L7981:
	if (--asi64(av_1)) goto L7968;
L7970:
	R1 = tou64(">");
	qq_showpcl_gstr(asu64(R1));
L7967:
	qq_showpcl_gline();
L7948:
	return;
}

static u64 qq_showpcl_writepclopnd(u64 pcstart, u64 pc, i64 pass) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 suffix;
	u64 s;
	i64 slen;
	u64 p;
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = (u64)&qq_pcltabs_pclopnd;
	asu64(R2) = pc;
	R3 = 8;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7984;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7985;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7986;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7987;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7988;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7989;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7990;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7991;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7992;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7993;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7994;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7995;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7996;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7997;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L7998;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7999;
	goto L8000;
L7984:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L7983;
L7985:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = 0;
	asu64(R2) = pc;
	R3 = 16;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asi64(R1));
	msysc_m$print_end();
	goto L7983;
L7986:
	asi64(R1) = pass;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8002;
	goto L8003;
L8002:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	slen = asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8005;
	R1 = tou64("\"");
	goto L7982;
L8005:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	goto L8006;
	goto L7983;
L7987:
// qq_showpcl.writepclopnd.docstringz:
L8003:
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	slen = asi64(R1);
// qq_showpcl.writepclopnd.dostring:
L8006:
	asi64(R1) = slen;
	R2 = 255;
	if (asi64(R1) < asi64(R2)) goto L8008;
	R1 = 255;
	slen = asi64(R1);
L8008:
	asi64(R1) = slen;
	asu64(R2) = s;
	R3 = (u64)&qq_showpcl_writepclopnd_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&qq_showpcl_writepclopnd_str;
	asi64(R3) = slen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&qq_showpcl_writepclopnd_str2;
	R2 = (u64)&qq_showpcl_writepclopnd_str;
	qq_lib_convertstring(asu64(R2), asu64(R1));
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("\"#\"");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_showpcl_writepclopnd_str2;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7983;
L7988:
	asi64(R1) = pass;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8010;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_showpcl_writepclopnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L8009;
L8010:
	asu64(R1) = qq_cli_allstaticdefs;
	d = asu64(R1);
	goto L8014;
L8011:
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L8016;
	goto L8013;
L8016:
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L8014:
	asu64(R1) = d;
	if (asu64(R1)) goto L8011;
L8013:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[#] (#:#)");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("h");
	asu64(R2) = d;
	R3 = 80;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_ptr(asu64(R2), asu64(R1));
	asu64(R1) = d;
	if (!asu64(R1)) goto L8018;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L8017;
L8018:
	R1 = tou64("?");
L8017:
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	if (!asu64(R1)) goto L8020;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L8019;
L8020:
	R1 = tou64("?");
L8019:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L8009:
	goto L7983;
L7989:
	asi64(R1) = pass;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8022;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_showpcl_writepclopnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L8021;
L8022:
	asu64(R1) = qq_showpcl_currpclproc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L8024;
L8023:
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L8028;
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L8027;
L8028:
	asu64(R1) = d;
	R2 = 96;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L8027;
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[#] (#)");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) /= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	goto L7982;
L8027:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L8024:
	asu64(R1) = d;
	if (asu64(R1)) goto L8023;
L8021:
	goto L7983;
L7990:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#.$");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7983;
L7991:
	asi64(R1) = pass;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8030;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&qq_showpcl_writepclopnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L8029;
L8030:
	asu64(R1) = qq_cli_allprocdefs;
	d = asu64(R1);
	goto L8034;
L8031:
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L8036;
	goto L8033;
L8036:
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L8034:
	asu64(R1) = d;
	if (asu64(R1)) goto L8031;
L8033:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[#] (#:#)");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = pc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	asu64(R1) = d;
	if (!asu64(R1)) goto L8038;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L8037;
L8038:
	R1 = tou64("?");
L8037:
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	if (!asu64(R1)) goto L8040;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L8039;
L8040:
	R1 = tou64("?");
L8039:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L8029:
	goto L7983;
L7992:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[DLL:#]");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7983;
L7993:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&qq_tables_hostfnnames;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 2;
	R1 += (i64)R2;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7983;
L7994:
	asi64(R1) = pass;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8042;
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64(".#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L8041;
L8042:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("## (#)");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("#");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&qq_decls_genfieldtable;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L8041:
	goto L7983;
L7995:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("T:# (#)");
	msysc_m$print_setfmt(asu64(R1));
	R1 = 0;
	asu64(R2) = pc;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = qq_show_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L7983;
L7996:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("L#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = pcstart;
	asu64(R2) = pc;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = qq_lib_getpcloffset(asu64(R2), asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L7983;
L7997:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("(#)");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_pcltabs_pclnames;
	asu64(R2) = pc;
	R3 = 16;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7983;
L7998:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("(# #)");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = pc;
	R2 = 16;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&qq_pcltabs_pclnames;
	R2 = (u64)&qq_pcltabs_bintotable;
	asu64(R3) = pc;
	R4 = 16;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	R2 += (i64)R3*24-24;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7983;
L7999:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("<#>");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_tables_mathsnames;
	asu64(R2) = pc;
	R3 = 16;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 3;
	R1 += (i64)R2;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L7983;
L8000:
// qq_showpcl.writepclopnd.other:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("<#>");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&qq_pcltabs_opndnames;
	R2 = (u64)&qq_pcltabs_pclopnd;
	asu64(R3) = pc;
	R4 = 8;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L7983:
	R1 = (u64)&qq_showpcl_writepclopnd_str;
	goto L7982;
L7982:
	return asu64(R1);
}

static void qq_showpcl_writeallpcl(u64 pm, i64 pass) {
    u64 R1, R2, R3, R4, R5; 
	i64 cmd;
	u64 pc;
	u64 pclcode;
	u64 pclsource;
	u64 sourcecode;
	R1 = 0;
	qq_showpcl_currlineno = asi64(R1);
	R1 = tou64("PCL FOR MODULE:");
	qq_showpcl_gstr(asu64(R1));
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	qq_showpcl_gstrln(asu64(R1));
	asu64(R1) = pm;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	pclcode = asu64(R2);
	pc = asu64(R1);
	asu64(R1) = pm;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pclsource = asu64(R1);
	asu64(R1) = pm;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	sourcecode = asu64(R1);
L8045:
	asu64(R1) = pc;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cmd = asi64(R1);
	asu64(R1) = sourcecode;
	asi64(R2) = pass;
	asu64(R3) = pclsource;
	asu64(R4) = pc;
	asu64(R5) = pclcode;
	qq_showpcl_writepcl(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	asi64(R1) = cmd;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L8045;
	qq_showpcl_gline();
	return;
}

static void qq_showpcl_showpcl(u64 sp, i64 pass) {
    u64 R1, R2, R3; 
	u64 f;
	i64 i;
	asu8(R1) = qq_cli_runcode;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8050;
	goto L8048;
L8050:
	asu64(R1) = qq_show_pcldest;
	mlib_gs_init(asu64(R1));
	R1 = tou64("PROC ALL PCL pass:");
	asu64(R2) = qq_show_pcldest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asi64(R1) = pass;
	asu64(R2) = qq_show_pcldest;
	mlib_gs_strint(asu64(R2), asi64(R1));
	asu64(R1) = qq_show_pcldest;
	mlib_gs_line(asu64(R1));
	asu64(R1) = sp;
	if (!asu64(R1)) goto L8052;
	asi64(R1) = pass;
	asu64(R2) = sp;
	qq_showpcl_showpcl2(asu64(R2), asi64(R1));
	goto L8051;
L8052:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = qq_decls_nsubprogs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8055;
L8053:
	asi64(R1) = pass;
	R2 = (u64)&qq_decls_subprogs;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	qq_showpcl_showpcl2(asu64(R2), asi64(R1));
	i += 1; if (i <= qq_decls_nsubprogs) goto L8053;
L8055:
L8051:
	R1 = tou64("w");
	asi64(R2) = pass;
	switch (asi64(R2)) {
	case 1: goto L8059;
	case 2: goto L8060;
	default: goto L8058;
    };
// SWITCH
L8059:
	R2 = tou64("PCL1");
	goto L8056;
L8060:
	R2 = tou64("PCL2");
	goto L8056;
L8058:
	R2 = tou64("PCL3");
L8056:
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	if (asu64(R1)) goto L8062;
	goto L8048;
L8062:
	asu64(R1) = f;
	asu64(R2) = qq_show_pcldest;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L8048:
	return;
}

static void qq_showpcl_showpcl2(u64 sp, i64 pass) {
    u64 R1, R2, R3; 
	i64 av_1;
	i64 i;
	asu64(R1) = sp;
	R2 = 24;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	i = asi64(R1);
	asu64(R1) = sp;
	R2 = 26;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	av_1 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_1;
	if (asi64(R1) > asi64(R2)) goto L8066;
L8064:
	asi64(R1) = pass;
	R2 = (u64)&qq_decls_modules;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	qq_showpcl_writeallpcl(asu64(R2), asi64(R1));
	i += 1; if (i <= av_1) goto L8064;
L8066:
	return;
}

static void qq_showpcl_gstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = qq_show_pcldest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void qq_showpcl_gstrln(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = qq_show_pcldest;
	mlib_gs_strln(asu64(R2), asu64(R1));
	return;
}

static void qq_showpcl_gline() {
    u64 R1; 
	asu64(R1) = qq_show_pcldest;
	mlib_gs_line(asu64(R1));
	return;
}

static void qq_showpcl_gstrint(i64 a) {
    u64 R1, R2; 
	asi64(R1) = a;
	asu64(R2) = qq_show_pcldest;
	mlib_gs_strint(asu64(R2), asi64(R1));
	return;
}

static void qq_showpcl_glabeldef(u64 pcstart, u64 pc) {
    u64 R1, R2; 
	R1 = tou64("L");
	qq_showpcl_gstr(asu64(R1));
	asu64(R1) = pcstart;
	asu64(R2) = pc;
	asi64(R1) = qq_lib_getpcloffset(asu64(R2), asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	qq_showpcl_gstrint(asi64(R1));
	R1 = tou64(": ");
	qq_showpcl_gstrln(asu64(R1));
	return;
}

static void qq_vars_var_unshareu(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu32(R1) = *(tou32p(R1)) -= 1;
	R1 = toi64(tou32(R1));
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L8074;
	asu64(R1) = p;
	qq_vars_var_free(asu64(R1));
L8074:
	return;
}

static void qq_vars_obj_shareu(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	(*tou32p(R1)) += 1;
	return;
}

static u64 qq_vars_void_new() {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 16;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8076;
L8076:
	return asu64(R1);
}

static u64 qq_vars_obj_new() {
    u64 R1, R2, R3; struct $B32 R1_B32; 
	u64 p;
	R1 = 32;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	(R1_B32) = qq_vars_zeroobj;
	asu64(R2) = p;
	*(struct $B32*)(R2) = (R1_B32);
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L8077;
L8077:
	return asu64(R1);
}

static i64 qq_vars_var_getintvalue(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8080;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L8080;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8081;
	goto L8082;
L8080:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L8078;
	goto L8079;
L8081:
	asu64(R1) = p;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = toi64(asr64(R1));
	goto L8078;
	goto L8079;
L8082:
	asu64(R1) = p;
	R2 = tou64("getintvalue");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8079:
	R1 = 0;
	goto L8078;
L8078:
	return asi64(R1);
}

static void qq_vars_var_fromobj(i64 tag, u64 p, u64 dest) {
    u64 R1, R2, R3; 
	asi64(R1) = tag;
	R2 = 256;
	asi64(R1) |= asi64(R2);
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_vars_var_free(u64 a) {
    u64 R1, R2, R3; 
	struct $B3 v;
	u64 q;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L8086;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8087;
	goto L8088;
L8086:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8090;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8091;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8092;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8093;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8094;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8095;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L8096;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8097;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8098;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8099;
	goto L8100;
L8090:
	asu64(R1) = q;
	qq_lists_obj_free_list(asu64(R1));
	goto L8089;
L8091:
	asu64(R1) = q;
	qq_records_obj_free_record(asu64(R1));
	goto L8089;
L8092:
	asu64(R1) = q;
	qq_strings_obj_free_string(asu64(R1));
	goto L8089;
L8093:
	asu64(R1) = q;
	qq_arrays_obj_free_array(asu64(R1));
	goto L8089;
L8094:
	asu64(R1) = q;
	qq_arrays_obj_free_vector(asu64(R1));
	goto L8089;
L8095:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = q;
	qq_bits_obj_free_bits(asu64(R2), asi64(R1));
	goto L8089;
L8096:
	asu64(R1) = q;
	qq_packed_obj_free_struct(asu64(R1));
	goto L8089;
L8097:
	R1 = 0;
	asu64(R2) = q;
	qq_dicts_obj_free_dict(asu64(R2), asi64(R1));
	goto L8089;
L8098:
	asu64(R1) = q;
	qq_sets_obj_free_set(asu64(R1));
	goto L8089;
L8099:
	asu64(R1) = q;
	qq_decimal_obj_free_dec(asu64(R1));
	goto L8089;
L8100:
	asu64(R1) = a;
	R2 = tou64("free");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8089:
	goto L8085;
L8087:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&v;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&v;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&v;
	qq_vars_var_unshareu(asu64(R1));
	asu64(R1) = q;
	mlib_pcm_free32(asu64(R1));
	goto L8085;
L8088:
	asu64(R1) = q;
	mlib_pcm_free32(asu64(R1));
L8085:
	return;
}

static void qq_vars_var_duplu(u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8103;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8104;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8105;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8106;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8107;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8108;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8109;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8110;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L8111;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8112;
	goto L8113;
L8103:
	asu64(R1) = a;
	qq_strings_var_dupl_string(asu64(R1));
	goto L8102;
L8104:
	asu64(R1) = a;
	qq_sets_var_dupl_set(asu64(R1));
	goto L8102;
L8105:
	asu64(R1) = a;
	qq_lists_var_dupl_list(asu64(R1));
	goto L8102;
L8106:
	asu64(R1) = a;
	qq_dicts_var_dupl_dict(asu64(R1));
	goto L8102;
L8107:
	asu64(R1) = a;
	qq_arrays_var_dupl_array(asu64(R1));
	goto L8102;
L8108:
	asu64(R1) = a;
	qq_arrays_var_dupl_vector(asu64(R1));
	goto L8102;
L8109:
	asu64(R1) = a;
	qq_bits_var_dupl_bits(asu64(R1));
	goto L8102;
L8110:
	asu64(R1) = a;
	qq_records_var_dupl_record(asu64(R1));
	goto L8102;
L8111:
	asu64(R1) = a;
	qq_packed_var_dupl_struct(asu64(R1));
	goto L8102;
L8112:
	asu64(R1) = a;
	qq_decimal_var_dupl_dec(asu64(R1));
	goto L8102;
L8113:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("dupl");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8102:
	return;
}

static void qq_vars_var_neg(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8116;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8117;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8118;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8119;
	goto L8120;
L8116:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = -asi64(R1);
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8115;
L8117:
	asu64(R1) = a;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R1) = -asr64(R1);
	asu64(R2) = a;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L8115;
L8118:
	asu64(R1) = a;
	qq_decimal_var_dupl_dec(asu64(R1));
	asu64(R1) = a;
	qq_decimal_var_neg_dec(asu64(R1));
	goto L8115;
L8119:
	asu64(R1) = a;
	qq_sets_var_dupl_set(asu64(R1));
	asu64(R1) = a;
	qq_sets_var_inotto_set(asu64(R1));
	goto L8115;
L8120:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("neg");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8115:
	return;
}

static void qq_vars_var_abs(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8123;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8124;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8125;
	goto L8126;
L8123:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8122;
L8124:
	asu64(R1) = a;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	if (asr64(R1) < 0) asr64(R1) = -asr64(R1);
	asu64(R2) = a;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L8122;
L8125:
	asu64(R1) = a;
	qq_decimal_var_dupl_dec(asu64(R1));
	asu64(R1) = a;
	qq_decimal_var_abs_dec(asu64(R1));
	goto L8122;
L8126:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("abs");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8122:
	return;
}

static void qq_vars_var_inot(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8129;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8130;
	goto L8131;
L8129:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = ~asi64(R1);
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8128;
L8130:
	asu64(R1) = a;
	qq_sets_var_dupl_set(asu64(R1));
	asu64(R1) = a;
	qq_sets_var_inotto_set(asu64(R1));
	goto L8128;
L8131:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("inot");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8128:
	return;
}

static i64 qq_vars_var_istruel(u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8134;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L8134;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L8134;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L8134;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L8134;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L8134;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8135;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8136;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8136;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8136;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8136;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8136;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8137;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8138;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L8138;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8139;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L8140;
	goto L8141;
L8134:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = !!asi64(R1);
	goto L8132;
	goto L8133;
L8135:
	asu64(R1) = a;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R2) = 0.000000000000000000e+000;
	if (asr64(R1) == asr64(R2)) goto L8143;
	R1 = 1;
	goto L8142;
L8143:
	R1 = 0;
L8142:
	goto L8132;
	goto L8133;
L8136:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	goto L8132;
	goto L8133;
L8137:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	goto L8132;
	goto L8133;
L8138:
	R1 = 1;
	goto L8132;
	goto L8133;
L8139:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = qq_decimal_bn_iszero(asu64(R1));
	asi64(R1) = !asi64(R1);
	goto L8132;
	goto L8133;
L8140:
	R1 = 0;
	goto L8132;
	goto L8133;
L8141:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("istruel");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8133:
	R1 = 0;
	goto L8132;
L8132:
	return asi64(R1);
}

static void qq_vars_var_add(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8146;
	asu64(R1) = b;
	asu64(R2) = a;
	qq_vars_var_addmixed(asu64(R2), asu64(R1));
	goto L8144;
L8146:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8148;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8149;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8150;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8151;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8152;
	goto L8153;
L8148:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
	goto L8147;
L8149:
	asu64(R1) = b;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) += asr64(R1);
	goto L8147;
L8150:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_decimal_var_add_dec(asu64(R2), asu64(R1));
	goto L8147;
L8151:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_strings_var_add_string(asu64(R2), asu64(R1));
	goto L8147;
L8152:
	asu64(R1) = a;
	qq_sets_var_dupl_set(asu64(R1));
	asu64(R1) = b;
	asu64(R2) = a;
	qq_sets_var_iorto_set(asu64(R2), asu64(R1));
	goto L8147;
L8153:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("add");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8147:
L8144:
	return;
}

static void qq_vars_var_addmixed(u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 newtag;
	i64 tt;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	newtag = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	R2 = 65538;
	if (asi64(R1) == asi64(R2)) goto L8156;
	R2 = 131073;
	if (asi64(R1) == asi64(R2)) goto L8157;
	R2 = 65539;
	if (asi64(R1) == asi64(R2)) goto L8158;
	R2 = 131075;
	if (asi64(R1) == asi64(R2)) goto L8158;
	R2 = 196609;
	if (asi64(R1) == asi64(R2)) goto L8159;
	R2 = 196610;
	if (asi64(R1) == asi64(R2)) goto L8159;
	R2 = 1048577;
	if (asi64(R1) == asi64(R2)) goto L8160;
	goto L8161;
L8156:
	R1 = 2;
	newtag = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = b;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asr64(R1) += asr64(R2);
	asu64(R2) = a;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L8155;
L8157:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) += asr64(R1);
	goto L8155;
L8158:
	R1 = 3;
	newtag = asi64(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R2) = qq_decimal_dectemp(asu64(R2));
	qq_decimal_var_add_dec(asu64(R2), asu64(R1));
	qq_decimal_freedectemp();
	goto L8155;
L8159:
	asu64(R1) = b;
	asu64(R1) = qq_decimal_dectemp(asu64(R1));
	asu64(R2) = a;
	qq_decimal_var_add_dec(asu64(R2), asu64(R1));
	goto L8155;
L8160:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8163;
	R1 = tou64("");
	R2 = tou64("Nil+x");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8163:
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = a;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) *= asi64(R2);
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*tou64p(R2) += asu64(R1);
	goto L8155;
L8161:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = tou64("Addmixed");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L8155:
	asi64(R1) = newtag;
	asu64(R2) = a;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static i64 qq_vars_var_addto(u64 p, u64 b) {
    u64 R1, R2, R3; 
	u64 a;
	i64 newtag;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L8166;
	R1 = 0;
	goto L8164;
L8166:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	newtag = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8168;
	asi64(R1) = newtag;
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L8170;
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8170;
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	qq_strings_var_addto_string_ch(asu64(R2), asi64(R1));
	R1 = 1;
	goto L8164;
L8170:
	R1 = 0;
	goto L8164;
L8168:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8172;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8173;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8174;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8175;
	goto L8176;
L8172:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
	goto L8171;
L8173:
	asu64(R1) = b;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) += asr64(R1);
	goto L8171;
L8174:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_strings_var_addto_string(asu64(R2), asu64(R1));
	goto L8171;
L8175:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_sets_var_iorto_set(asu64(R2), asu64(R1));
	goto L8171;
L8176:
	R1 = 0;
	goto L8164;
L8171:
	asi64(R1) = newtag;
	asu64(R2) = a;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	goto L8164;
L8164:
	return asi64(R1);
}

static void qq_vars_var_sub(u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	i64 elemsize;
	i64 x;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8179;
	asu64(R1) = b;
	asu64(R2) = a;
	qq_vars_var_submixed(asu64(R2), asu64(R1));
	goto L8177;
L8179:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8181;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8182;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8183;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L8184;
	goto L8185;
L8181:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) -= asi64(R1);
	goto L8180;
L8182:
	asu64(R1) = b;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) -= asr64(R1);
	goto L8180;
L8183:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_decimal_var_sub_dec(asu64(R2), asu64(R1));
	goto L8180;
L8184:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = a;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	elemsize = asi64(R2);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8187;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8188;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8189;
	goto L8190;
L8187:
	asu64(R1) = p;
	asu64(R2) = q;
	asi64(R1) -= asi64(R2);
	x = asi64(R1);
	goto L8186;
L8188:
	asu64(R1) = p;
	asu64(R2) = q;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) >>= asi64(R2);
	x = asi64(R1);
	goto L8186;
L8189:
	asu64(R1) = p;
	asu64(R2) = q;
	asi64(R1) -= asi64(R2);
	R2 = 2;
	asi64(R1) >>= asi64(R2);
	x = asi64(R1);
	goto L8186;
L8190:
	asu64(R1) = p;
	asu64(R2) = q;
	asi64(R1) -= asi64(R2);
	asi64(R2) = elemsize;
	asi64(R1) /= asi64(R2);
	x = asi64(R1);
L8186:
	R1 = 1;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8180;
L8185:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("sub");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8180:
L8177:
	return;
}

static void qq_vars_var_submixed(u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 newtag;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	newtag = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	R2 = 65538;
	if (asi64(R1) == asi64(R2)) goto L8193;
	R2 = 131073;
	if (asi64(R1) == asi64(R2)) goto L8194;
	R2 = 65539;
	if (asi64(R1) == asi64(R2)) goto L8195;
	R2 = 131075;
	if (asi64(R1) == asi64(R2)) goto L8195;
	R2 = 196609;
	if (asi64(R1) == asi64(R2)) goto L8196;
	R2 = 196610;
	if (asi64(R1) == asi64(R2)) goto L8196;
	R2 = 1048577;
	if (asi64(R1) == asi64(R2)) goto L8197;
	goto L8198;
L8193:
	R1 = 2;
	newtag = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = b;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asr64(R1) -= asr64(R2);
	asu64(R2) = a;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L8192;
L8194:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) -= asr64(R1);
	goto L8192;
L8195:
	R1 = 3;
	newtag = asi64(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R2) = qq_decimal_dectemp(asu64(R2));
	qq_decimal_var_sub_dec(asu64(R2), asu64(R1));
	qq_decimal_freedectemp();
	goto L8192;
L8196:
	asu64(R1) = b;
	asu64(R1) = qq_decimal_dectemp(asu64(R1));
	asu64(R2) = a;
	qq_decimal_var_sub_dec(asu64(R2), asu64(R1));
	goto L8192;
L8197:
	R1 = (u64)&qq_tables_ttsize;
	asu64(R2) = a;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) *= asi64(R2);
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*tou64p(R2) -= asu64(R1);
	goto L8192;
L8198:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = tou64("Submixed");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L8192:
	asi64(R1) = newtag;
	asu64(R2) = a;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void qq_vars_var_mul(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8201;
	asu64(R1) = b;
	asu64(R2) = a;
	qq_vars_var_mulmixed(asu64(R2), asu64(R1));
	goto L8199;
L8201:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8203;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8204;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8205;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8206;
	goto L8207;
L8203:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) *= asi64(R1);
	goto L8202;
L8204:
	asu64(R1) = b;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) *= asr64(R1);
	goto L8202;
L8205:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_decimal_var_mul_dec(asu64(R2), asu64(R1));
	goto L8202;
L8206:
	asu64(R1) = a;
	qq_sets_var_dupl_set(asu64(R1));
	asu64(R1) = b;
	asu64(R2) = a;
	qq_sets_var_iandto_set(asu64(R2), asu64(R1));
	goto L8202;
L8207:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("mul");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8202:
L8199:
	return;
}

static void qq_vars_var_mulmixed(u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 newtag;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	newtag = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	R2 = 65538;
	if (asi64(R1) == asi64(R2)) goto L8210;
	R2 = 131073;
	if (asi64(R1) == asi64(R2)) goto L8211;
	R2 = 65539;
	if (asi64(R1) == asi64(R2)) goto L8212;
	R2 = 131075;
	if (asi64(R1) == asi64(R2)) goto L8212;
	R2 = 196609;
	if (asi64(R1) == asi64(R2)) goto L8213;
	R2 = 196610;
	if (asi64(R1) == asi64(R2)) goto L8213;
	R2 = 589825;
	if (asi64(R1) == asi64(R2)) goto L8214;
	R2 = 655361;
	if (asi64(R1) == asi64(R2)) goto L8215;
	goto L8216;
L8210:
	R1 = 2;
	newtag = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = b;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asr64(R1) *= asr64(R2);
	asu64(R2) = a;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L8209;
L8211:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) *= asr64(R1);
	goto L8209;
L8212:
	R1 = 3;
	newtag = asi64(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R2) = qq_decimal_dectemp(asu64(R2));
	qq_decimal_var_mul_dec(asu64(R2), asu64(R1));
	qq_decimal_freedectemp();
	goto L8209;
L8213:
	asu64(R1) = b;
	asu64(R1) = qq_decimal_dectemp(asu64(R1));
	asu64(R2) = a;
	qq_decimal_var_mul_dec(asu64(R2), asu64(R1));
	goto L8209;
L8214:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	qq_strings_var_mul_string(asu64(R2), asi64(R1));
	goto L8209;
L8215:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	qq_lists_var_mul_list(asu64(R2), asi64(R1));
	goto L8209;
L8216:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = tou64("Mulmixed");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L8209:
	asi64(R1) = newtag;
	asu64(R2) = a;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void qq_vars_var_div(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8219;
	asu64(R1) = b;
	asu64(R2) = a;
	qq_vars_var_divmixed(asu64(R2), asu64(R1));
	goto L8217;
L8219:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8221;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8222;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8223;
	goto L8224;
L8221:
	R1 = 2;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asr64(R2) = tor64(asi64(R2));
	asr64(R1) /= asr64(R2);
	asu64(R2) = a;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L8220;
L8222:
	asu64(R1) = b;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) /= asr64(R1);
	goto L8220;
L8223:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_decimal_var_div_dec(asu64(R2), asu64(R1));
	goto L8220;
L8224:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("div");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8220:
L8217:
	return;
}

static void qq_vars_var_divmixed(u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 newtag;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	newtag = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	R2 = 65538;
	if (asi64(R1) == asi64(R2)) goto L8227;
	R2 = 131073;
	if (asi64(R1) == asi64(R2)) goto L8228;
	goto L8229;
L8227:
	R1 = 2;
	newtag = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = b;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asr64(R1) /= asr64(R2);
	asu64(R2) = a;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L8226;
L8228:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*tor64p(R2) /= asr64(R1);
	goto L8226;
L8229:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = tou64("Divmixed");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L8226:
	asi64(R1) = newtag;
	asu64(R2) = a;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void qq_vars_var_idiv(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8232;
	R1 = tou64("");
	R2 = tou64("idivmixed");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L8230;
L8232:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8234;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8235;
	goto L8236;
L8234:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L8238;
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) /= asi64(R2);
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8237;
L8238:
	R1 = tou64("");
	R2 = tou64("Divide by 0");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8237:
	goto L8233;
L8235:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_decimal_var_idiv_dec(asu64(R2), asu64(R1));
	goto L8233;
L8236:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("idiv");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8233:
L8230:
	return;
}

static void qq_vars_var_irem(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8241;
	R1 = tou64("");
	R2 = tou64("iremmixed");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L8239;
L8241:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8243;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8244;
	goto L8245;
L8243:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) %= asi64(R2);
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8242;
L8244:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_decimal_var_irem_dec(asu64(R2), asu64(R1));
	goto L8242;
L8245:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("irem");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8242:
L8239:
	return;
}

static void qq_vars_var_iand(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8248;
	R1 = tou64("");
	R2 = tou64("iand mixed");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L8246;
L8248:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8250;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8251;
	goto L8252;
L8250:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) &= asi64(R1);
	goto L8249;
L8251:
	asu64(R1) = a;
	qq_sets_var_dupl_set(asu64(R1));
	asu64(R1) = b;
	asu64(R2) = a;
	qq_sets_var_iandto_set(asu64(R2), asu64(R1));
	goto L8249;
L8252:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("iand");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8249:
L8246:
	return;
}

static void qq_vars_var_ior(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8255;
	R1 = tou64("");
	R2 = tou64("ior mixed");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L8253;
L8255:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8257;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8258;
	goto L8259;
L8257:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) |= asi64(R1);
	goto L8256;
L8258:
	asu64(R1) = a;
	qq_sets_var_dupl_set(asu64(R1));
	asu64(R1) = b;
	asu64(R2) = a;
	qq_sets_var_iorto_set(asu64(R2), asu64(R1));
	goto L8256;
L8259:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("ior");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8256:
L8253:
	return;
}

static void qq_vars_var_ixor(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8262;
	R1 = tou64("");
	R2 = tou64("ixor mixed");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L8260;
L8262:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8264;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8265;
	goto L8266;
L8264:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) ^= asi64(R1);
	goto L8263;
L8265:
	asu64(R1) = a;
	qq_sets_var_dupl_set(asu64(R1));
	asu64(R1) = b;
	asu64(R2) = a;
	qq_sets_var_ixorto_set(asu64(R2), asu64(R1));
	goto L8263;
L8266:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("ixor");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8263:
L8260:
	return;
}

static void qq_vars_var_shl(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8269;
	R1 = tou64("");
	R2 = tou64("ishl mixed");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L8267;
L8269:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8271;
	goto L8272;
L8271:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) <<= asi64(R1);
	goto L8270;
L8272:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("shl");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8270:
L8267:
	return;
}

static void qq_vars_var_shr(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8275;
	R1 = tou64("");
	R2 = tou64("ishr mixed");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L8273;
L8275:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8277;
	goto L8278;
L8277:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) >>= asi64(R1);
	goto L8276;
L8278:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("shr");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8276:
L8273:
	return;
}

static i64 qq_vars_var_in(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	i64 n;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	R2 = 65541;
	if (asi64(R1) == asi64(R2)) goto L8281;
	R2 = 1179653;
	if (asi64(R1) == asi64(R2)) goto L8281;
	R2 = 65540;
	if (asi64(R1) == asi64(R2)) goto L8282;
	goto L8283;
L8281:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_sets_var_in_set(asu64(R2), asu64(R1));
	goto L8279;
	goto L8280;
L8282:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 16;
	R4 = 63;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asi64(R1) < asi64(R2)) goto L8285;
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L8285;
	R1 = 1;
	goto L8284;
L8285:
	R1 = 0;
L8284:
	goto L8279;
	goto L8280;
L8283:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8287;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8287;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8287;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8287;
	goto L8288;
L8287:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_vars_var_inx(asu64(R2), asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0x8000000000000000;
	if (asi64(R1) == asi64(R2)) goto L8290;
	R1 = 1;
	goto L8289;
L8290:
	R1 = 0;
L8289:
	goto L8279;
	goto L8286;
L8288:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = tou64("in");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L8286:
L8280:
	R1 = 0;
	goto L8279;
L8279:
	return asi64(R1);
}

static i64 qq_vars_var_inx(u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 n;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	R2 = 589833;
	if (asi64(R1) == asi64(R2)) goto L8293;
	R2 = 65547;
	if (asi64(R1) == asi64(R2)) goto L8294;
	R2 = 131083;
	if (asi64(R1) == asi64(R2)) goto L8294;
	R2 = 65543;
	if (asi64(R1) == asi64(R2)) goto L8295;
	R2 = 131079;
	if (asi64(R1) == asi64(R2)) goto L8295;
	goto L8296;
L8293:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_strings_var_inx_string(asu64(R2), asu64(R1));
	goto L8291;
	goto L8292;
L8294:
	R1 = 0;
	asu64(R2) = b;
	asu64(R3) = a;
	asi64(R1) = qq_arrays_var_inx_array(asu64(R3), asu64(R2), asi64(R1));
	goto L8291;
	goto L8292;
L8295:
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = b;
	asu64(R3) = a;
	asi64(R1) = qq_arrays_var_inx_array(asu64(R3), asu64(R2), asi64(R1));
	goto L8291;
	goto L8292;
L8296:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8298;
	goto L8299;
L8298:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_lists_var_inx_list(asu64(R2), asu64(R1));
	goto L8291;
	goto L8297;
L8299:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = tou64("inx");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L8297:
L8292:
	R1 = 0;
	goto L8291;
L8291:
	return asi64(R1);
}

static i64 qq_vars_var_equal(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8302;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_vars_var_equalmixed(asu64(R2), asu64(R1));
	goto L8300;
L8302:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8304;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L8304;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L8304;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L8304;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L8304;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L8304;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8305;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8306;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8307;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8308;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8309;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8310;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8311;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8311;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8312;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8313;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L8314;
	goto L8315;
L8304:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L8300;
	goto L8303;
L8305:
	asu64(R1) = a;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	if (asr64(R1) != asr64(R2)) goto L8317;
	R1 = 1;
	goto L8316;
L8317:
	R1 = 0;
L8316:
	goto L8300;
	goto L8303;
L8306:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_decimal_var_equal_dec(asu64(R2), asu64(R1));
	goto L8300;
	goto L8303;
L8307:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_strings_var_equal_string(asu64(R2), asu64(R1));
	goto L8300;
	goto L8303;
L8308:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_sets_var_equal_set(asu64(R2), asu64(R1));
	goto L8300;
	goto L8303;
L8309:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_lists_var_equal_list(asu64(R2), asu64(R1));
	goto L8300;
	goto L8303;
L8310:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_dicts_var_equal_dict(asu64(R2), asu64(R1));
	goto L8300;
	goto L8303;
L8311:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_arrays_var_equal_array(asu64(R2), asu64(R1));
	goto L8300;
	goto L8303;
L8312:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_bits_var_equal_bits(asu64(R2), asu64(R1));
	goto L8300;
	goto L8303;
L8313:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_records_var_equal_record(asu64(R2), asu64(R1));
	goto L8300;
	goto L8303;
L8314:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_packed_var_equal_struct(asu64(R2), asu64(R1));
	goto L8300;
	goto L8303;
L8315:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("equal");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8303:
	R1 = 0;
	goto L8300;
L8300:
	return asi64(R1);
}

static i64 qq_vars_var_equalmixed(u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 result;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	R2 = 65538;
	if (asi64(R1) == asi64(R2)) goto L8320;
	R2 = 131073;
	if (asi64(R1) == asi64(R2)) goto L8321;
	R2 = 65539;
	if (asi64(R1) == asi64(R2)) goto L8322;
	R2 = 131075;
	if (asi64(R1) == asi64(R2)) goto L8322;
	R2 = 196609;
	if (asi64(R1) == asi64(R2)) goto L8323;
	R2 = 196610;
	if (asi64(R1) == asi64(R2)) goto L8323;
	goto L8324;
L8320:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = b;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	if (asr64(R1) != asr64(R2)) goto L8326;
	R1 = 1;
	goto L8325;
L8326:
	R1 = 0;
L8325:
	goto L8318;
	goto L8319;
L8321:
	asu64(R1) = a;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asr64(R2) = tor64(asi64(R2));
	if (asr64(R1) != asr64(R2)) goto L8328;
	R1 = 1;
	goto L8327;
L8328:
	R1 = 0;
L8327:
	goto L8318;
	goto L8319;
L8322:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R2) = qq_decimal_dectemp(asu64(R2));
	asi64(R1) = qq_decimal_var_equal_dec(asu64(R2), asu64(R1));
	result = asi64(R1);
	qq_decimal_freedectemp();
	asi64(R1) = result;
	goto L8318;
	goto L8319;
L8323:
	asu64(R1) = b;
	asu64(R1) = qq_decimal_dectemp(asu64(R1));
	asu64(R2) = a;
	asi64(R1) = qq_decimal_var_equal_dec(asu64(R2), asu64(R1));
	goto L8318;
	goto L8319;
L8324:
	R1 = 0;
	goto L8318;
L8319:
	R1 = 0;
	goto L8318;
L8318:
	return asi64(R1);
}

static i64 qq_vars_var_compare(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8331;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_vars_var_comparemixed(asu64(R2), asu64(R1));
	goto L8329;
L8331:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8333;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L8333;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8334;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8335;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8336;
	goto L8337;
L8333:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) >= asi64(R2)) goto L8339;
	R1 = -1;
	goto L8338;
L8339:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L8341;
	R1 = 1;
	goto L8340;
L8341:
	R1 = 0;
L8340:
L8338:
	goto L8329;
	goto L8332;
L8334:
	asu64(R1) = a;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	if (asr64(R1) >= asr64(R2)) goto L8343;
	R1 = -1;
	goto L8342;
L8343:
	asu64(R1) = a;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	if (asr64(R1) <= asr64(R2)) goto L8345;
	R1 = 1;
	goto L8344;
L8345:
	R1 = 0;
L8344:
L8342:
	goto L8329;
	goto L8332;
L8335:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_decimal_var_compare_dec(asu64(R2), asu64(R1));
	goto L8329;
	goto L8332;
L8336:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_strings_var_compare_string(asu64(R2), asu64(R1));
	goto L8329;
	goto L8332;
L8337:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("compare");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8332:
	R1 = 0;
	goto L8329;
L8329:
	return asi64(R1);
}

static i64 qq_vars_var_comparemixed(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	R2 = 65538;
	if (asi64(R1) == asi64(R2)) goto L8348;
	R2 = 131073;
	if (asi64(R1) == asi64(R2)) goto L8349;
	goto L8350;
L8348:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = b;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	if (asr64(R1) >= asr64(R2)) goto L8352;
	R1 = -1;
	goto L8351;
L8352:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = b;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	if (asr64(R1) <= asr64(R2)) goto L8354;
	R1 = 1;
	goto L8353;
L8354:
	R1 = 0;
L8353:
L8351:
	goto L8346;
	goto L8347;
L8349:
	asu64(R1) = a;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asr64(R2) = tor64(asi64(R2));
	if (asr64(R1) >= asr64(R2)) goto L8356;
	R1 = -1;
	goto L8355;
L8356:
	asu64(R1) = a;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asr64(R2) = tor64(asi64(R2));
	if (asr64(R1) <= asr64(R2)) goto L8358;
	R1 = 1;
	goto L8357;
L8358:
	R1 = 0;
L8357:
L8355:
	goto L8346;
	goto L8347;
L8350:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = tou64("comparemixed");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L8347:
	R1 = 0;
	goto L8346;
L8346:
	return asi64(R1);
}

static void qq_vars_var_concat(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8361;
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = tou64("Concat");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L8361:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8363;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8364;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8365;
	goto L8366;
L8363:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_strings_var_add_string(asu64(R2), asu64(R1));
	goto L8362;
L8364:
	asu64(R1) = a;
	qq_lists_var_dupl_list(asu64(R1));
	asu64(R1) = b;
	asu64(R2) = a;
	qq_lists_var_concatto_list(asu64(R2), asu64(R1));
	goto L8362;
L8365:
	asu64(R1) = a;
	qq_arrays_var_dupl_array(asu64(R1));
	asu64(R1) = b;
	asu64(R2) = a;
	qq_arrays_var_concatto_array(asu64(R2), asu64(R1));
	goto L8362;
L8366:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("concat");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8362:
	return;
}

static void qq_vars_var_append(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8369;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8371;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8372;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8373;
	goto L8374;
L8371:
	goto L8375;
	goto L8370;
L8372:
	goto L8376;
	goto L8370;
L8373:
	goto L8377;
	goto L8370;
L8374:
L8370:
	goto L8378;
	goto L8368;
L8369:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8380;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8381;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8382;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8383;
	goto L8384;
L8380:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_strings_var_add_string(asu64(R2), asu64(R1));
	asu64(R1) = b;
	qq_vars_var_unshareu(asu64(R1));
	goto L8379;
L8381:
// qq_vars.var_append.dolist:
L8375:
	asu64(R1) = a;
	qq_lists_var_dupl_list(asu64(R1));
	asu64(R1) = b;
	asu64(R2) = a;
	qq_lists_var_appendto_list(asu64(R2), asu64(R1));
	goto L8379;
L8382:
// qq_vars.var_append.doarray:
L8376:
	asu64(R1) = a;
	qq_arrays_var_dupl_array(asu64(R1));
	asu64(R1) = b;
	asu64(R2) = a;
	qq_arrays_var_appendto_array(asu64(R2), asu64(R1));
	goto L8379;
L8383:
// qq_vars.var_append.dobits:
L8377:
	asu64(R1) = a;
	qq_bits_var_dupl_bits(asu64(R1));
	asu64(R1) = b;
	asu64(R2) = a;
	qq_bits_var_appendto_bits(asu64(R2), asu64(R1));
	goto L8379;
L8384:
// qq_vars.var_append.error:
L8378:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("append");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8379:
L8368:
	return;
}

static void qq_vars_var_min(u64 a, u64 b) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8387;
	R1 = tou64("");
	R2 = tou64("VARMIN");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L8385;
L8387:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_vars_var_compare(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L8389;
	asu64(R1) = b;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8391;
	asu64(R1) = b;
	qq_vars_var_unshareu(asu64(R1));
L8391:
	goto L8388;
L8389:
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8393;
	asu64(R1) = a;
	qq_vars_var_unshareu(asu64(R1));
L8393:
	asu64(R1) = b;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = a;
	*(struct $B3*)(R2) = (R1_B3);
L8388:
L8385:
	return;
}

static void qq_vars_var_max(u64 a, u64 b) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8396;
	R1 = tou64("");
	R2 = tou64("VARMAX");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
	goto L8394;
L8396:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R1) = qq_vars_var_compare(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L8398;
	asu64(R1) = b;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8400;
	asu64(R1) = b;
	qq_vars_var_unshareu(asu64(R1));
L8400:
	goto L8397;
L8398:
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8402;
	asu64(R1) = a;
	qq_vars_var_unshareu(asu64(R1));
L8402:
	asu64(R1) = b;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = a;
	*(struct $B3*)(R2) = (R1_B3);
L8397:
L8394:
	return;
}

static i64 qq_vars_var_concatto(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8405;
	R1 = tou64("");
	R2 = tou64("concatto/mixed");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8405:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8407;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8408;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8409;
	goto L8410;
L8407:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_strings_var_addto_string(asu64(R2), asu64(R1));
	goto L8406;
L8408:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_lists_var_concatto_list(asu64(R2), asu64(R1));
	goto L8406;
L8409:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_arrays_var_concatto_array(asu64(R2), asu64(R1));
	goto L8406;
L8410:
	asu64(R1) = a;
	R2 = tou64("concat");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8406:
	R1 = 1;
	goto L8403;
L8403:
	return asi64(R1);
}

static i64 qq_vars_var_appendto(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8413;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8415;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8416;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8417;
	goto L8418;
L8415:
	goto L8419;
	goto L8414;
L8416:
	goto L8420;
	goto L8414;
L8417:
	goto L8421;
	goto L8414;
L8418:
	R1 = tou64("");
	R2 = tou64("appendto/mixed");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8414:
L8413:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8423;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8424;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8425;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8426;
	goto L8427;
L8423:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_strings_var_addto_string(asu64(R2), asu64(R1));
	asu64(R1) = b;
	qq_vars_var_unshareu(asu64(R1));
	goto L8422;
L8424:
// qq_vars.var_appendto.dolist:
L8419:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_lists_var_appendto_list(asu64(R2), asu64(R1));
	goto L8422;
L8425:
// qq_vars.var_appendto.doarray:
L8420:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_arrays_var_appendto_array(asu64(R2), asu64(R1));
	goto L8422;
L8426:
// qq_vars.var_appendto.dobits:
L8421:
	asu64(R1) = b;
	asu64(R2) = a;
	qq_bits_var_appendto_bits(asu64(R2), asu64(R1));
	goto L8422;
L8427:
	asu64(R1) = a;
	R2 = tou64("append");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
	R1 = 0;
	goto L8411;
L8422:
	R1 = 1;
	goto L8411;
L8411:
	return asi64(R1);
}

static void qq_vars_var_getix(u64 a, i64 index) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8430;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8431;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8431;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8432;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8432;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8433;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8434;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8435;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8436;
	goto L8437;
L8430:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_strings_var_getix_string(asu64(R2), asi64(R1));
	goto L8429;
L8431:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_lists_var_getix_list(asu64(R2), asi64(R1));
	goto L8429;
L8432:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_arrays_var_getix_array(asu64(R2), asi64(R1));
	goto L8429;
L8433:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_bits_var_getix_bits(asu64(R2), asi64(R1));
	goto L8429;
L8434:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_sets_var_getix_set(asu64(R2), asi64(R1));
	goto L8429;
L8435:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_records_var_getix_record(asu64(R2), asi64(R1));
	goto L8429;
L8436:
	asi64(R1) = index;
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 16;
	R4 = 63;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asi64(R1) < asi64(R2)) goto L8439;
	asu64(R2) = a;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) > asi64(R2)) goto L8439;
	R1 = 1;
	asu64(R2) = a;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = index;
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8438;
L8439:
	R1 = tou64("");
	R2 = tou64("range/bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8438:
	goto L8429;
L8437:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("getix");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8429:
	return;
}

static void qq_vars_var_putix(u64 a, i64 index, u64 x) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8442;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8443;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8444;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8444;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8445;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8446;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8447;
	goto L8448;
L8442:
	asu64(R1) = x;
	asi64(R2) = index;
	asu64(R3) = a;
	qq_strings_var_putix_string(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = x;
	qq_vars_var_unshareu(asu64(R1));
	goto L8441;
L8443:
	asu64(R1) = x;
	asi64(R2) = index;
	asu64(R3) = a;
	qq_lists_var_putix_list(asu64(R3), asi64(R2), asu64(R1));
	goto L8441;
L8444:
	asu64(R1) = x;
	asi64(R2) = index;
	asu64(R3) = a;
	qq_arrays_var_putix_array(asu64(R3), asi64(R2), asu64(R1));
	goto L8441;
L8445:
	asu64(R1) = x;
	asi64(R2) = index;
	asu64(R3) = a;
	qq_bits_var_putix_bits(asu64(R3), asi64(R2), asu64(R1));
	goto L8441;
L8446:
	asu64(R1) = x;
	asi64(R2) = index;
	asu64(R3) = a;
	qq_sets_var_putix_set(asu64(R3), asi64(R2), asu64(R1));
	goto L8441;
L8447:
	asu64(R1) = x;
	asi64(R2) = index;
	asu64(R3) = a;
	qq_records_var_putix_record(asu64(R3), asi64(R2), asu64(R1));
	goto L8441;
L8448:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("putix");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8441:
	return;
}

static void qq_vars_var_getixref(u64 a, i64 index) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8451;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8452;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8453;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8453;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8454;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8455;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8456;
	goto L8457;
L8451:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_strings_var_getixref_string(asu64(R2), asi64(R1));
	goto L8450;
L8452:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_lists_var_getixref_list(asu64(R2), asi64(R1));
	goto L8450;
L8453:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_arrays_var_getixref_array(asu64(R2), asi64(R1));
	goto L8450;
L8454:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_bits_var_getixref_bits(asu64(R2), asi64(R1));
	goto L8450;
L8455:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_sets_var_getixref_set(asu64(R2), asi64(R1));
	goto L8450;
L8456:
	asu64(R1) = a;
	asi64(R2) = index;
	asu64(R3) = a;
	qq_records_var_getixref_record(asu64(R3), asi64(R2), asu64(R1));
	goto L8450;
L8457:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("getixref");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8450:
	return;
}

static void qq_vars_var_getslice(u64 a, i64 i, i64 j) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8460;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8461;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8462;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8463;
	goto L8464;
L8460:
	asi64(R1) = j;
	asi64(R2) = i;
	asu64(R3) = a;
	qq_strings_var_getslice_string(asu64(R3), asi64(R2), asi64(R1));
	goto L8459;
L8461:
	asi64(R1) = j;
	asi64(R2) = i;
	asu64(R3) = a;
	qq_lists_var_getslice_list(asu64(R3), asi64(R2), asi64(R1));
	goto L8459;
L8462:
	asi64(R1) = j;
	asi64(R2) = i;
	asu64(R3) = a;
	qq_arrays_var_getslice_array(asu64(R3), asi64(R2), asi64(R1));
	goto L8459;
L8463:
	asi64(R1) = j;
	asi64(R2) = i;
	asu64(R3) = a;
	qq_bits_var_getslice_bits(asu64(R3), asi64(R2), asi64(R1));
	goto L8459;
L8464:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("getslice");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8459:
	return;
}

static void qq_vars_var_putslice(u64 a, i64 i, i64 j, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = x;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8467;
	R1 = tou64("");
	R2 = tou64("putslice: not compatible");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8467:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8469;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8470;
	goto L8471;
L8469:
	asu64(R1) = x;
	asi64(R2) = j;
	asi64(R3) = i;
	asu64(R4) = a;
	qq_strings_var_putslice_string(asu64(R4), asi64(R3), asi64(R2), asu64(R1));
	goto L8468;
L8470:
	asu64(R1) = x;
	asi64(R2) = j;
	asi64(R3) = i;
	asu64(R4) = a;
	qq_lists_var_putslice_list(asu64(R4), asi64(R3), asi64(R2), asu64(R1));
	goto L8468;
L8471:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("putslice");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8468:
	return;
}

static void qq_vars_var_getdotix(u64 a, i64 index) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8474;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8475;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8476;
	goto L8477;
L8474:
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L8480;
	R2 = 63;
	if (asi64(R1) <= asi64(R2)) goto L8479;
L8480:
	R1 = tou64("");
	R2 = tou64("int.[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8479:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = index;
	asi64(R1) >>= asi64(R2);
	R2 = 1;
	asi64(R1) &= asi64(R2);
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8473;
L8475:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_strings_var_getdotix_string(asu64(R2), asi64(R1));
	goto L8473;
L8476:
	asi64(R1) = index;
	asu64(R2) = a;
	qq_records_var_getix_record(asu64(R2), asi64(R1));
	goto L8473;
L8477:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("getdotix");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8473:
	return;
}

static void qq_vars_var_putdotix(u64 p, i64 index, u64 x) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 a;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L8483;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8485;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8486;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8487;
	goto L8488;
L8485:
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L8491;
	R2 = 63;
	if (asi64(R1) <= asi64(R2)) goto L8490;
L8491:
	R1 = tou64("");
	R2 = tou64("int.[int]:= bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8490:
	R1 = 1;
	R2 = 33;
	asu64(R3) = x;
	asi64(R4) = index;
	asu64(R5) = a;
	R6 = 8;
	R5 += (i64)R6;
	qq_vars_var_storebit(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8484;
L8486:
	asu64(R1) = x;
	asi64(R2) = index;
	asu64(R3) = a;
	qq_strings_var_putdotix_string(asu64(R3), asi64(R2), asu64(R1));
	goto L8484;
L8487:
	asu64(R1) = x;
	asi64(R2) = index;
	asu64(R3) = a;
	qq_records_var_putix_record(asu64(R3), asi64(R2), asu64(R1));
	goto L8484;
L8488:
	asu64(R1) = a;
	R2 = tou64("putdotix");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8484:
	goto L8482;
L8483:
	asu64(R1) = p;
	R2 = tou64("putdotix");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8482:
	return;
}

static void qq_vars_var_getdotixref(u64 p, i64 index) {
    u64 R1, R2, R3; 
	u64 a;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L8494;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8496;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8497;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8498;
	goto L8499;
L8496:
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L8502;
	R2 = 63;
	if (asi64(R1) <= asi64(R2)) goto L8501;
L8502:
	R1 = tou64("");
	R2 = tou64("&int.[int] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8501:
	asu64(R1) = a;
	R2 = 8;
	R1 += (i64)R2;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 15;
	asu64(R2) = p;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 33;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = index;
	asu64(R2) = p;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L8495;
L8497:
	asu64(R1) = p;
	asi64(R2) = index;
	asu64(R3) = a;
	qq_strings_var_getdotixref_string(asu64(R3), asi64(R2), asu64(R1));
	goto L8495;
L8498:
	asu64(R1) = p;
	asi64(R2) = index;
	asu64(R3) = a;
	qq_records_var_getixref_record(asu64(R3), asi64(R2), asu64(R1));
	goto L8495;
L8499:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("getdotixref");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8495:
	goto L8493;
L8494:
	asu64(R1) = p;
	R2 = tou64("not refvar");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8493:
	return;
}

static void qq_vars_var_getdotslice(u64 a, i64 i, i64 j) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8505;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8506;
	goto L8507;
L8505:
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) <= asi64(R2)) goto L8509;
	R1 = (u64)&i;
	R2 = (u64)&j;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
L8509:
	asi64(R1) = i;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L8512;
	asi64(R1) = j;
	R2 = 63;
	if (asi64(R1) <= asi64(R2)) goto L8511;
L8512:
	R1 = tou64("");
	R2 = tou64("int.[slice] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8511:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asi64(R1) >>= asi64(R2);
	R2 = -1;
	asi64(R3) = j;
	asi64(R4) = i;
	asi64(R3) -= asi64(R4);
	R4 = 1;
	asi64(R3) += asi64(R4);
	asu64(R2) <<= asu64(R3);
	asu64(R2) = ~asu64(R2);
	asi64(R1) &= asi64(R2);
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8504;
L8506:
	asi64(R1) = j;
	asi64(R2) = i;
	asu64(R3) = a;
	qq_strings_var_getslice_string(asu64(R3), asi64(R2), asi64(R1));
	goto L8504;
L8507:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("getdotslice");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8504:
	return;
}

static void qq_vars_var_putdotslice(u64 p, i64 i, i64 j, u64 x) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 a;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L8515;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8517;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8518;
	goto L8519;
L8517:
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) <= asi64(R2)) goto L8521;
	R1 = (u64)&i;
	R2 = (u64)&j;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
L8521:
	asi64(R1) = i;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L8524;
	asi64(R1) = j;
	R2 = 63;
	if (asi64(R1) <= asi64(R2)) goto L8523;
L8524:
	R1 = tou64("");
	R2 = tou64("int.[slice]:= bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8523:
	asi64(R1) = j;
	asi64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 33;
	asu64(R3) = x;
	asi64(R4) = i;
	asu64(R5) = a;
	R6 = 8;
	R5 += (i64)R6;
	qq_vars_var_storebit(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8516;
L8518:
	asu64(R1) = x;
	asi64(R2) = j;
	asi64(R3) = i;
	asu64(R4) = a;
	qq_strings_var_putslice_string(asu64(R4), asi64(R3), asi64(R2), asu64(R1));
	goto L8516;
L8519:
	asu64(R1) = a;
	R2 = tou64("putdotslice");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8516:
	goto L8514;
L8515:
	asu64(R1) = p;
	R2 = tou64("not ref");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8514:
	return;
}

static void qq_vars_var_getdotsliceref(u64 p, i64 i, i64 j) {
    u64 R1, R2, R3; 
	u64 a;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L8527;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8529;
	goto L8530;
L8529:
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) <= asi64(R2)) goto L8532;
	R1 = (u64)&i;
	R2 = (u64)&j;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
L8532:
	asi64(R1) = i;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L8535;
	asi64(R1) = j;
	R2 = 63;
	if (asi64(R1) <= asi64(R2)) goto L8534;
L8535:
	R1 = tou64("");
	R2 = tou64("&int.[slice] bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8534:
	asu64(R1) = a;
	R2 = 8;
	R1 += (i64)R2;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 15;
	asu64(R2) = p;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 33;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = i;
	asu64(R2) = p;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = j;
	asi64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = p;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L8528;
L8530:
	asu64(R1) = a;
	R2 = tou64("getdotsliceref");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8528:
	goto L8526;
L8527:
	asu64(R1) = p;
	R2 = tou64("not ref");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8526:
	return;
}

static void qq_vars_var_expand(u64 a, u64 dest, i64 m) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	u64 b;
	u64 c;
	u64 p;
	u64 s;
	i64 n;
	i64 length;
	i64 av_1;
	i64 av_2;
	asi64(R1) = m;
	R2 = 2;
	if (asi64(R1) >= asi64(R2)) goto L8538;
	R1 = tou64("");
	R2 = tou64("Expand: LHS too few");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8538:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8540;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8541;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8542;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8543;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8544;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8544;
	goto L8545;
L8540:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
// qq_vars.var_expand.dolist:
L8546:
	asu64(R1) = dest;
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	c = asu64(R1);
	R1 = 1;
	n = asi64(R1);
	asi64(R1) = m;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L8549;
L8547:
	asi64(R1) = n;
	asi64(R2) = length;
	if (asi64(R1) <= asi64(R2)) goto L8551;
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L8550;
L8551:
	asu64(R1) = c;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = dest;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = dest;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8553;
	asu64(R1) = dest;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L8553:
	R1 = (u64)&c;
	(*tou64p(R1)) += 16;
L8550:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	R1 = (u64)&dest;
	(*tou64p(R1)) -=16;
	if (--asi64(av_1)) goto L8547;
L8549:
	goto L8539;
L8541:
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	R3 = 63;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&dest;
	(*tou64p(R1)) -=16;
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = m;
	R2 = 2;
	asi64(R1) -= asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L8556;
L8554:
	R1 = (u64)&dest;
	(*tou64p(R1)) -=16;
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	if (--asi64(av_2)) goto L8554;
L8556:
	goto L8539;
L8542:
	asi64(R1) = m;
	asu64(R2) = dest;
	asu64(R3) = a;
	qq_strings_var_expand_string(asu64(R3), asu64(R2), asi64(R1));
	goto L8539;
L8543:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = (u64)&qq_tables_ttlength;
	asu64(R2) = p;
	R3 = 6;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	length = asi64(R1);
	goto L8546;
	goto L8539;
L8544:
	asi64(R1) = m;
	asu64(R2) = dest;
	asu64(R3) = a;
	qq_arrays_var_expand_array(asu64(R3), asu64(R2), asi64(R1));
	goto L8539;
L8545:
	asu64(R1) = a;
	R2 = tou64("expand");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8539:
	return;
}

static void qq_vars_var_inplace(i64 index, u64 px, u64 y) {
    u64 R1, R2, R3; 
	u64 fnadd;
	u64 fnaddmixed;
	struct $B3 x;
	struct $B3 z;
	R1 = (u64)&qq_pcltabs_bintotable;
	asi64(R2) = index;
	R1 += (i64)R2*24-24;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 101;
	if (asi64(R1) != asi64(R2)) goto L8559;
	asu64(R1) = y;
	asu64(R2) = px;
	asi64(R1) = qq_vars_var_addto(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L8561;
	goto L8557;
L8561:
L8559:
	R1 = (u64)&qq_pcltabs_bintotable;
	asi64(R2) = index;
	R1 += (i64)R2*24-24;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fnadd = asu64(R1);
	R1 = (u64)&qq_pcltabs_bintotable;
	asi64(R2) = index;
	R1 += (i64)R2*24-24;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fnaddmixed = asu64(R1);
	R1 = (u64)&x;
	asu64(R2) = px;
	qq_vars_var_loadptr(asu64(R2), asu64(R1));
	R1 = (u64)&x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = y;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) != asi64(R2)) goto L8563;
	asu64(R1) = y;
	R2 = (u64)&x;
	asu64(R3) = fnadd;
	((F20)R3)(asu64(R2), asu64(R1));
	goto L8562;
L8563:
	asu64(R1) = fnaddmixed;
	if (!asu64(R1)) goto L8564;
	asu64(R1) = y;
	R2 = (u64)&x;
	asu64(R3) = fnaddmixed;
	((F20)R3)(asu64(R2), asu64(R1));
	goto L8562;
L8564:
	msysc_m$print_startcon();
	R1 = (u64)&qq_pcltabs_pclnames;
	R2 = (u64)&qq_pcltabs_bintotable;
	asi64(R3) = index;
	R2 += (i64)R3*24-24;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = y;
	R2 = (u64)&x;
	R3 = tou64("Inplace mixed");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L8562:
	R1 = (u64)&x;
	asu64(R2) = px;
	qq_vars_var_storeptr(asu64(R2), asu64(R1));
L8557:
	return;
}

static void qq_vars_var_inplace_unary(u64 px, u64 fnneg) {
    u64 R1, R2; 
	struct $B3 x;
	R1 = (u64)&x;
	asu64(R2) = px;
	qq_vars_var_loadptr(asu64(R2), asu64(R1));
	R1 = (u64)&x;
	asu64(R2) = fnneg;
	((F19)R2)(asu64(R1));
	R1 = (u64)&x;
	asu64(R2) = px;
	qq_vars_var_storeptr(asu64(R2), asu64(R1));
	return;
}

static void qq_vars_var_loadptr(u64 x, u64 y) {
    u64 R1, R2, R3, R4, R5, R6; struct $B3 R1_B3; 
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L8568;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L8569;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L8570;
	goto L8571;
L8568:
	asu64(R1) = x;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = y;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8573;
	asu64(R1) = y;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(*tou32p(R1)) += 1;
L8573:
	goto L8567;
L8569:
	R1 = 0;
	asu64(R2) = y;
	asu64(R3) = x;
	R4 = 4;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	asu64(R4) = x;
	R5 = 8;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	qq_packed_var_loadpacked(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	goto L8567;
L8570:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = x;
	R4 = 4;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	asu64(R4) = x;
	R5 = 2;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R5) = x;
	R6 = 8;
	asu64(R5) = *tou64p(((i64)R5+(i64)R6));
	qq_vars_var_loadbit(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	goto L8567;
L8571:
	asu64(R1) = x;
	R2 = tou64("var_loadptr");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8567:
	return;
}

static void qq_vars_var_storeptr(u64 p, u64 q) {
    u64 R1, R2, R3, R4, R5, R6; struct $B3 R1_B3; 
	u64 dest;
	u64 pptr;
	u64 qptr;
	struct $B3 v;
	i64 i;
	i64 n;
	i64 etag;
	i64 poffset;
	i64 qoffset;
	i64 bitwidthx;
	u64 pp;
	u64 qq;
	i64 aa;
	i64 bb;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L8576;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L8577;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L8578;
	goto L8579;
L8576:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8581;
	asu64(R1) = dest;
	qq_vars_var_unshareu(asu64(R1));
L8581:
	asu64(R1) = q;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = dest;
	*(struct $B3*)(R2) = (R1_B3);
	goto L8575;
L8577:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = q;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_packed_var_storepacked(asu64(R3), asu64(R2), asi64(R1));
	goto L8575;
L8578:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = q;
	asu64(R4) = p;
	R5 = 2;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R5) = p;
	R6 = 8;
	asu64(R5) = *tou64p(((i64)R5+(i64)R6));
	qq_vars_var_storebit(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L8575;
L8579:
	asu64(R1) = p;
	R2 = tou64("var_popptr");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8575:
	return;
}

static void qq_vars_var_loadbit(u64 p, i64 shift, i64 t, i64 bitlength, u64 dest) {
    u64 R1, R2, R3; 
	u64 pd;
	u64 mask;
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = t;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L8584;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L8585;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L8586;
	goto L8587;
L8584:
	asi64(R1) = bitlength;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8589;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R1) &= asi64(R2);
	asi64(R1) = !!asi64(R1);
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8588;
L8589:
	asu64(R1) = p;
	pd = asu64(R1);
	R1 = -2;
	mask = asu64(R1);
	asi64(R1) = bitlength;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8591;
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L8592;
	goto L8593;
L8591:
	goto L8590;
L8592:
	R1 = 0;
	mask = asu64(R1);
	goto L8590;
L8593:
	asi64(R1) = bitlength;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&mask;
	*tou64p(R2) <<= asu64(R1);
L8590:
	asu64(R1) = pd;
	asu64(R1) = *tou64p(R1);
	asi64(R2) = shift;
	asu64(R1) >>= asu64(R2);
	asu64(R2) = mask;
	asu64(R2) = ~asu64(R2);
	asi64(R1) &= asi64(R2);
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L8588:
	goto L8583;
L8585:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 3;
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R1) &= asi64(R2);
	asi64(R2) = shift;
	asi64(R1) >>= asi64(R2);
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8583;
L8586:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 15;
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R1) &= asi64(R2);
	asi64(R2) = shift;
	asi64(R1) >>= asi64(R2);
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8583;
L8587:
	asi64(R1) = t;
	R2 = tou64("loadbit");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8583:
	return;
}

static void qq_vars_var_storebit(u64 p, i64 shift, u64 q, i64 t, i64 bitlength) {
    u64 R1, R2, R3; 
	u64 pd;
	u8 bb;
	u64 mask1;
	u64 mask2;
	u64 newvalue;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8596;
	R1 = tou64("");
	R2 = tou64("storebit not int");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8596:
	asi64(R1) = t;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L8598;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L8599;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L8600;
	goto L8601;
L8598:
	asi64(R1) = bitlength;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8603;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R2) = ~asi64(R2);
	asi64(R1) &= asi64(R2);
	asu64(R2) = q;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 1;
	asi64(R2) &= asi64(R3);
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L8602;
L8603:
	asu64(R1) = p;
	pd = asu64(R1);
	R1 = -2;
	mask1 = asu64(R1);
	asi64(R1) = bitlength;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8605;
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L8606;
	goto L8607;
L8605:
	goto L8604;
L8606:
	R1 = 0;
	mask1 = asu64(R1);
	goto L8604;
L8607:
	asi64(R1) = bitlength;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&mask1;
	*tou64p(R2) <<= asu64(R1);
L8604:
	asu64(R1) = mask1;
	asu64(R1) = ~asu64(R1);
	mask1 = asu64(R1);
	asi64(R1) = shift;
	if (!asi64(R1)) goto L8609;
	asi64(R1) = shift;
	R2 = (u64)&mask1;
	*tou64p(R2) <<= asu64(R1);
L8609:
	asu64(R1) = mask1;
	asu64(R1) = ~asu64(R1);
	mask2 = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	newvalue = asu64(R1);
	asi64(R1) = shift;
	if (!asi64(R1)) goto L8611;
	asi64(R1) = shift;
	R2 = (u64)&newvalue;
	*tou64p(R2) <<= asu64(R1);
L8611:
	asu64(R1) = pd;
	asu64(R1) = *tou64p(R1);
	asu64(R2) = mask2;
	asu64(R1) &= asu64(R2);
	asu64(R2) = newvalue;
	asu64(R3) = mask1;
	asu64(R2) &= asu64(R3);
	asu64(R1) |= asu64(R2);
	asu64(R2) = pd;
	*tou64p(R2) = asu64(R1);
L8602:
	goto L8597;
L8599:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 3;
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R2) = ~asi64(R2);
	asi64(R1) &= asi64(R2);
	asu64(R2) = q;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 3;
	asi64(R2) &= asi64(R3);
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L8597;
L8600:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 15;
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R2) = ~asi64(R2);
	asi64(R1) &= asi64(R2);
	asu64(R2) = q;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 15;
	asi64(R2) &= asi64(R3);
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L8597;
L8601:
	asi64(R1) = t;
	R2 = tou64("storebit");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8597:
	return;
}

static void qq_vars_var_convert(u64 x, i64 t, u64 dest) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	i64 s;
	i64 tbase;
	i64 aa;
	struct $B3 bn;
	asu64(R1) = x;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = dest;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = x;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	s = asi64(R1);
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L8614;
	goto L8612;
L8614:
	asi64(R1) = t;
	tbase = asi64(R1);
	asi64(R1) = t;
	asu64(R2) = dest;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = s;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8616;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8617;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L8618;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L8618;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L8618;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8619;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L8620;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8621;
	goto L8622;
L8616:
	asi64(R1) = tbase;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8624;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8625;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8626;
	goto L8627;
L8624:
	goto L8623;
L8625:
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L8623;
L8626:
	asu64(R1) = dest;
	asu64(R2) = x;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	qq_decimal_var_make_dec_int(asi64(R2), asu64(R1));
	goto L8623;
L8627:
	asi64(R1) = t;
	R2 = tou64("conv int=>");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8623:
	goto L8615;
L8617:
	asi64(R1) = tbase;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8629;
	goto L8630;
L8629:
	asu64(R1) = x;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = toi64(asr64(R1));
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8628;
L8630:
	asi64(R1) = t;
	R2 = tou64("conv real=>");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8628:
	goto L8615;
L8618:
	R1 = (u64)&qq_tables_ttbasetype;
	asi64(R2) = tbase;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8632;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L8633;
	goto L8634;
L8632:
	goto L8631;
L8633:
	R1 = 16;
	asu64(R2) = dest;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&qq_tables_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R2) = dest;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L8631;
L8634:
	asi64(R1) = t;
	R2 = tou64("conv ptr=>");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8631:
	goto L8615;
L8619:
	asi64(R1) = tbase;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8636;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8637;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8638;
	goto L8639;
L8636:
	asu64(R1) = dest;
	asi64(R2) = t;
	asu64(R3) = x;
	qq_strings_var_convert_string_list(asu64(R3), asi64(R2), asu64(R1));
	goto L8635;
L8637:
	asu64(R1) = dest;
	asu64(R2) = x;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = x;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	qq_decimal_var_make_dec_str(asu64(R3), asi64(R2), asu64(R1));
	goto L8635;
L8638:
	goto L8635;
L8639:
	asi64(R1) = t;
	R2 = tou64("string=>");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8635:
	goto L8615;
L8620:
	asi64(R1) = tbase;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8641;
	asi64(R1) = t;
	R2 = tou64("type=>");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8641:
	goto L8615;
L8621:
	asi64(R1) = tbase;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8643;
	goto L8644;
L8643:
	asu64(R1) = x;
	asi64(R1) = qq_decimal_var_convert_dec_int(asu64(R1));
	aa = asi64(R1);
	R1 = 1;
	asu64(R2) = dest;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = aa;
	asu64(R2) = dest;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8642;
L8644:
	asi64(R1) = t;
	R2 = tou64("decimal=>");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8642:
	goto L8615;
L8622:
	asi64(R1) = t;
	asi64(R2) = s;
	R3 = tou64("Convert s.t");
	qq_runaux_pcmxtypestt(asu64(R3), asi64(R2), asi64(R1));
L8615:
L8612:
	return;
}

static i64 qq_vars_var_gethashvalue(u64 p) {
    u64 R1, R2; 
	i64 hsum;
	i64 csum;
	i64 c;
	i64 n;
	i64 i;
	i64 result;
	u64 s;
	u64 s0;
	u64 q;
	i64 av_1;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8647;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8648;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8648;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8648;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8649;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8650;
	goto L8651;
L8647:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	asi64(R1) = n;
	if (asi64(R1)) goto L8653;
	R1 = 0;
	goto L8645;
L8653:
	R1 = 0;
	hsum = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L8656;
L8654:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = hsum;
	R2 = 4;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	hsum = asi64(R1);
	if (--asi64(av_1)) goto L8654;
L8656:
	asi64(R1) = hsum;
	R2 = 5;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	result = asi64(R1);
	asi64(R1) = result;
	R2 = 9223372036854775807;
	asi64(R1) &= asi64(R2);
	goto L8645;
	goto L8646;
L8648:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L8645;
	goto L8646;
L8649:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8658;
	R1 = 0;
	goto L8645;
	goto L8657;
L8658:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	goto L8645;
L8657:
	goto L8646;
L8650:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L8645;
	goto L8646;
L8651:
	asu64(R1) = p;
	R2 = tou64("Can't hash:");
	qq_runaux_pcustype(asu64(R2), asu64(R1));
L8646:
	R1 = 0;
	goto L8645;
L8645:
	return asi64(R1);
}

static void qq_vars_var_objtovar(i64 tag, u64 p, u64 q) {
    u64 R1, R2, R3; 
	asi64(R1) = tag;
	R2 = 256;
	asi64(R1) |= asi64(R2);
	asu64(R2) = q;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void qq_vars_var_putdotix_intint(u64 a, i64 index, u64 b) {
    u64 R1, R2, R3; 
	u64 x;
	u64 y;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	x = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	y = asu64(R1);
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L8663;
	R2 = 63;
	if (asi64(R1) <= asi64(R2)) goto L8662;
L8663:
	R1 = tou64("");
	R2 = tou64("int.[int]:= bounds");
	qq_runaux_pcerror(asu64(R2), asu64(R1));
L8662:
	asu64(R1) = x;
	R2 = 1;
	asi64(R3) = index;
	asi64(R2) <<= asi64(R3);
	asi64(R2) = ~asi64(R2);
	asi64(R1) &= asi64(R2);
	asu64(R2) = y;
	asi64(R3) = index;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void qq_vars_var_power(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L8666;
	asu64(R1) = b;
	asu64(R2) = a;
	qq_vars_var_powermixed(asu64(R2), asu64(R1));
	goto L8664;
L8666:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8668;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8669;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8670;
	goto L8671;
L8668:
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = Poweri64(asi64(R1), asi64(R2));
	asu64(R2) = a;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L8667;
L8669:
	asu64(R1) = b;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asr64(R1) = pow(asr64(R2), asr64(R1));
	asu64(R2) = a;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L8667;
L8670:
	asu64(R1) = b;
	asi64(R1) = qq_decimal_var_convert_dec_int(asu64(R1));
	asu64(R2) = a;
	qq_decimal_var_power_dec(asu64(R2), asi64(R1));
	goto L8667;
L8671:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = tou64("power");
	qq_runaux_pcustype_t(asu64(R2), asi64(R1));
L8667:
L8664:
	return;
}

static void qq_vars_var_powermixed(u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 newtag;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	newtag = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	R2 = 65538;
	if (asi64(R1) == asi64(R2)) goto L8674;
	R2 = 131073;
	if (asi64(R1) == asi64(R2)) goto L8675;
	R2 = 196609;
	if (asi64(R1) == asi64(R2)) goto L8676;
	goto L8677;
L8674:
	R1 = 2;
	newtag = asi64(R1);
	asu64(R1) = b;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asr64(R2) = tor64(asi64(R2));
	asr64(R1) = pow(asr64(R2), asr64(R1));
	asu64(R2) = a;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L8673;
L8675:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = a;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asr64(R1) = pow(asr64(R2), asr64(R1));
	asu64(R2) = a;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	goto L8673;
L8676:
	asu64(R1) = b;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	qq_decimal_var_power_dec(asu64(R2), asi64(R1));
	goto L8673;
L8677:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = tou64("Powermixed");
	qq_runaux_pcmxtypes(asu64(R3), asu64(R2), asu64(R1));
L8673:
	asi64(R1) = newtag;
	asu64(R2) = a;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void qq_cli_start() {
	qq_lex_start();
	qq_lists_start();
	qq_pcllib_start();
	qq_runx_start();
	qq_strings_start();
	qq_tables_start();
	return;
}

static struct $B34 $procaddr = {{
(u64)&qq_print_pch_strstartprint}};

static struct $B34 $procname = {{
(u64)"pch_strstartprint"}};

static i64 $nprocs = 1;

// ***** PCL Support Library *****

i64 Getdotindex(u64 a, int i) {
	return (a & (1LL<<i))>>i;
}

u64 Setdotindex(u64 a, i64 i, i64 x) {
	return (a & ~(1LL<<i)) | ((u64)(x)<<i);
}

i64 Getdotslice(u64 a, i64 i, i64 j) {
	if (i>=j)
		return (a>>j) & ~(0xFFFFFFFFFFFFFFFF<<(i-j+1));
	else
		return (a>>i) & ~(0xFFFFFFFFFFFFFFFF<<(j-i+1));
}

u64 Setdotslice(u64 a, i64 i, i64 j, u64 x) {
	u64 mask64;
	if (i>j) {i64 t=i; i=j; j=t;}

	mask64=~((0xFFFFFFFFFFFFFFFF<<(j-i+1)))<<i;
	return (a & ~mask64) ^ (x<<i);
}

i64 Poweri64(i64 a, i64 n) {
	if (n<0)
		return 0;
	else if (n==0)
		return 1;
	else if ((n&1)==0)
		return Poweri64(a*a, n/2);
	else
		return Poweri64(a*a, (n-1)/2)*a;
}

// End of C Code

